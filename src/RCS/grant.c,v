head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.21.04.54.23;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.07.07.01.38;	author myc;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.30.04.34.05;	author myc;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.22.06.12.34;	author myc;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.21.19.14.53;	author jps;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.15.18.53.39;	author myc;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.15.17.49.24;	author myc;	state Exp;
branches;
next	;


desc
@The command grant system.
@


1.11
log
@New target finding mechanism in find.c.
@
text
@/***************************************************************************
 * $Id: grant.c,v 1.10 2009/02/21 03:30:16 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: grant.c                                        Part of FieryMUD *
 *  Usage: utilities to facilitate the command grant system                *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#define __GRANT_C__

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "comm.h"
#include "interpreter.h"
#include "db.h"
#include "utils.h"
#include "screen.h"
#include "olc.h"
#include "grant.h"
#include "handler.h"
#include "math.h"
#include "constants.h"
#include "modify.h"

static void gedit_setup_new(struct descriptor_data *d);
static void gedit_setup_existing(struct descriptor_data *d, int group);
void gedit_disp_menu(struct descriptor_data *d);
static void gedit_save_internally(struct descriptor_data *d);
static void gedit_save_to_disk();
static void add_group(int **listptr, struct command_group *group);
static void remove_group(int **listptr, struct command_group *group);
static void free_command_groups();

#define top_of_cmd_groups	(cmd_groups + num_cmd_groups)
#define VALID_GROUP_NUM(gg)	((gg) >= cmd_groups && (gg) < top_of_cmd_groups)
#define GROUP_NUM(gg)		((gg) - cmd_groups)

/* The dynamically allocated array of command groups. */
static struct command_group *cmd_groups = NULL;
static int num_cmd_groups = 0;

/* Command groups list; MUST have the same # of entries as cmd_info */
static struct command_group_info *grp_info = NULL;

int command_group_number(struct command_group *group)
{
  return VALID_GROUP_NUM(group) ? GROUP_NUM(group) : -1;
}

static int find_command_group(char *name)
{
  struct command_group *group = cmd_groups;

  while (group < top_of_cmd_groups) {
    if (!str_cmp(group->alias, name))
      return GROUP_NUM(group);
    ++group;
  }

  return (-1);

/*
 * I'm a giant noob, and forgot that doing a binary search requires
 * the group index to be in alphabetic order.  Rather than complicate
 * the other code by introducing sorting, I'm just replacing the binary
 * search below with a linear search.
 */
#if 0
  struct command_group *bot, *top, *mid;

  bot = cmd_groups;
  top = top_of_cmd_groups - 1;

  if (!bot || !top)
    return (-1);

  /* Do binary search on the command groups */
  while (TRUE) {
    mid = bot + (top - bot) / 2;

    if (!str_cmp(mid->alias, name))
      return GROUP_NUM(mid);
    if (bot >= top)
      return (-1);
    if (str_cmp(mid->alias, name) > 0)
      top = mid - 1;
    else
      bot = mid + 1;
  }
#endif

}

static void free_command_groups() {
  struct command_group *group;
  int cmd;

  for (group = cmd_groups; group < top_of_cmd_groups; ++group) {
    if (group->alias)
      free(group->alias);
    if (group->name)
      free(group->name);
    if (group->description)
       free(group->description);
  }
  if (cmd_groups)
    free(cmd_groups);
  cmd_groups = NULL;
  num_cmd_groups = 0;

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (grp_info[cmd].groups) {
      free(grp_info[cmd].groups);
      grp_info[cmd].groups = NULL;
    }
}


static struct grant_type *grant_in_list(struct grant_type *list, int grant)
{
  while (list) {
    if (list->grant == grant)
      break;
    list = list->next;
  }

  return list;
}

static bool remove_grant(struct grant_type **list, int grant)
{
  struct grant_type dummy, *temp, *node;

  if (!list)
    return FALSE;

  dummy.next = *list;
  node = &dummy;

  while (node->next) {
    if (node->next->grant == grant) {
      temp = node->next;
      node->next = node->next->next;
      free(temp->grantor);
      free(temp);
      *list = dummy.next;
      return TRUE;
    }
    node = node->next;
  }

  return FALSE;
}


static void add_grant(struct grant_type **list, int grant, const char *grantor, int grant_level)
{
  struct grant_type *temp;
  CREATE(temp, struct grant_type, 1);
  temp->grant = grant;
  temp->grantor = strdup(grantor);
  temp->level = grant_level;
  temp->next = *list;
  *list = temp;
}


/*
 * Precondition: 
 */
void cache_grants(struct char_data *ch)
{
  int cmd;

  if (!GET_GRANT_CACHE(ch))
    CREATE(GET_GRANT_CACHE(ch), flagvector, FLAGVECTOR_SIZE(num_of_cmds));
  if (!GET_REVOKE_CACHE(ch))
    CREATE(GET_REVOKE_CACHE(ch), flagvector, FLAGVECTOR_SIZE(num_of_cmds));

  for (cmd = 1; cmd < num_of_cmds; ++cmd) {
    switch (command_grant_usability(ch, cmd)) {
    case CMD_GRANTED:
      SET_FLAG(GET_GRANT_CACHE(ch), cmd);
      break;
    case CMD_REVOKED:
      SET_FLAG(GET_REVOKE_CACHE(ch), cmd);
      break;
    case CMD_NOT_GRANTED:
      /* do nothing */
      break;
    }
  }
}


bool can_use_command(struct char_data *ch, int cmd)
{
  /* NPCs can't have grants */
  if (cmd < 0 || cmd >= num_of_cmds)
    return FALSE;
  else if (IS_NPC(ch))
    return CMD_USEABLE_FOR_LEVEL(ch, cmd);
  else if (IS_FLAGGED(GET_GRANT_CACHE(ch), cmd))
    return TRUE;
  else if (IS_FLAGGED(GET_REVOKE_CACHE(ch), cmd))
    return FALSE;
  else
    return CMD_USEABLE_FOR_LEVEL(ch, cmd);
}


int command_grant_usability(struct char_data *ch, int cmd)
{
  int usability = CMD_NOT_GRANTED, i;

  /* If we are in a command group with the command, we can use it */
  if (grp_info[cmd].groups)
    for (i = 0; grp_info[cmd].groups[i] >= 0; ++i)
      if (grant_in_list(GET_GRANT_GROUPS(ch), grp_info[cmd].groups[i]))
        usability = CMD_GRANTED;

  /* If the command is explicitly revoked, we can't use it.  Period. */
  if (GET_REVOKES(ch) && grant_in_list(GET_REVOKES(ch), cmd))
    return CMD_REVOKED;

  /* If we're revoked the group, we can't use it unless explicitly 
   * granted this command */
  if (grp_info[cmd].groups)
    for (i = 0; grp_info[cmd].groups[i] >= 0; ++i)
      if (grant_in_list(GET_REVOKE_GROUPS(ch), grp_info[cmd].groups[i]))
        usability = CMD_REVOKED;

  /* If we're granted the command, we can use it */
  if (GET_GRANTS(ch) && grant_in_list(GET_GRANTS(ch), cmd))
    usability = CMD_GRANTED;

  return usability;
}

static bool can_grant_group(struct char_data *ch, int group)
{
  if (group < 0 && group >= num_cmd_groups)
    return FALSE;
  else if (grant_in_list(GET_REVOKE_GROUPS(ch), group))
    return FALSE;
  else if (grant_in_list(GET_GRANT_GROUPS(ch), group))
    return TRUE;
  else
    return (cmd_groups[group].minimum_level <= GET_LEVEL(ch));
}


static void cache_grant(flagvector *cache, int cmd, bool is_group, bool set)
{
  if (is_group) {
    if (cmd < num_cmd_groups) {
      int group = cmd, grp;
      for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
        if (grp_info[cmd].groups)
          for (grp = 0; grp_info[cmd].groups[grp] >= 0; ++grp)
            if (grp_info[cmd].groups[grp] == group) {
              if (set)
                SET_FLAG(cache, cmd);
              else
                REMOVE_FLAG(cache, cmd);
              break;
            }
    }
  }

  else if (cmd < num_of_cmds) {
    if (set)
      SET_FLAG(cache, cmd);
    else
      REMOVE_FLAG(cache, cmd);
  }
}

static void str_cat_command_grant_list(char *buf, struct grant_type *grant)
{
  int found = 0;
  for (; grant; grant = grant->next)
    str_catf(buf, "%s%-15s", found++ % 4 == 0 ? "\r\n" : "",
             cmd_info[grant->grant].command);
  str_cat(buf, "\r\n");
}

static void str_cat_grant_group_list(char *buf, struct grant_type *grant)
{
  int found = 0;
  for (; grant; grant = grant->next)
    str_catf(buf, "%s%-15s", found++ % 4 == 0 ? "\r\n" : "",
             cmd_groups[grant->grant].alias);
  str_cat(buf, "\r\n");
}

static void do_list_grants(struct char_data *ch, struct char_data *vict)
{
  if (!GET_GRANTS(vict) && !GET_REVOKES(vict) &&
      !GET_GRANT_GROUPS(vict) && !GET_REVOKE_GROUPS(vict)) {
    send_to_char("No granted commands found.\r\n", ch);
    return;
  }

  str_start(buf, sizeof(buf));

  if (GET_GRANTS(vict)) {
    str_catf(buf, "%s has been granted the following commands:",
             GET_NAME(vict));
    str_cat_command_grant_list(buf, GET_GRANTS(vict));
  }

  if (GET_REVOKES(vict)) {
    str_catf(buf, "%s has the following commands revoked:",
             GET_NAME(vict));
    str_cat_command_grant_list(buf, GET_REVOKES(vict));
  }

  if (GET_GRANT_GROUPS(vict)) {
    str_catf(buf, "%s has been granted the following command groups:",
             GET_NAME(vict));
    str_cat_grant_group_list(buf, GET_GRANT_GROUPS(vict));
  }

  if (GET_REVOKE_GROUPS(vict)) {
    str_catf(buf, "%s has the following command groups revoked:",
             GET_NAME(vict));
    str_cat_grant_group_list(buf, GET_REVOKE_GROUPS(vict));
  }

  send_to_char(buf, ch);
}


static void send_grant_usage(struct char_data *ch)
{
  send_to_char("Usage: grant <name> [ command <command> | group <group> ] [ level ]\r\n"
               "       revoke <name> [ command <command> | group <group> ] [ level ]\r\n"
               "       ungrant <name> [ command <command> | group <group> ]\r\n"
               "       grant <name> [ clear | list ]\r\n", ch);
}


#define GRANT_COMMAND 0
#define GRANT_GROUP   1

static void do_grant_revoke(struct char_data *ch, struct char_data *vict, char *argument, int subcmd, int type)
{
  struct grant_type **list, **unlist, **temp;
  struct grant_type *grant;
  flagvector *cache, *uncache;
  struct command_group *group;
  int level, command = 0;
  const char *present_action, *past_action, *preposition;
  char name[MAX_INPUT_LENGTH];
  bool is_group;

  argument = any_one_arg(argument, arg);
  skip_spaces(&argument);
  level = *argument && is_number(argument) ? atoi(argument) : GET_LEVEL(ch);

  if ((subcmd != SCMD_GRANT && subcmd != SCMD_REVOKE && subcmd != SCMD_UNGRANT) ||
      (type != GRANT_COMMAND && type != GRANT_GROUP)) {
    send_to_char("Warning: grant command incorrectly invoked.\r\n", ch);
    log("SYSERR: do_grant incorrectly invoked");
    return;
  }
  else if (type == GRANT_COMMAND) {
    list = &GET_GRANTS(vict);
    unlist = &GET_REVOKES(vict);
    is_group = FALSE;
  }
  else {
    list = &GET_GRANT_GROUPS(vict);
    unlist = &GET_REVOKE_GROUPS(vict);
    is_group = TRUE;
  }
  if (subcmd == SCMD_REVOKE) {
    temp = list;
    list = unlist;
    unlist = temp;
    present_action = "revoke";
    past_action = "revoked";
    preposition = "from";
    cache = GET_REVOKE_CACHE(vict);
    uncache = GET_GRANT_CACHE(vict);
  }
  else {
    present_action = "grant";
    past_action = "granted";
    preposition = "to";
    cache = GET_GRANT_CACHE(vict);
    uncache = GET_REVOKE_CACHE(vict);
  }

  if (ch == vict) {
    send_to_char("You cannot grant or revoke your own commands.\r\n", ch);
    return;
  }
  if (!*arg) {
    send_grant_usage(ch);
    return;
  }

  if (type == GRANT_COMMAND && ((command = parse_command(arg)) <= 0 ||
      !strcpy(name, arg))) {
    send_to_char("No such command.\r\n", ch);
    list_similar_commands(ch, arg);
    return;
  }

  else if (type == GRANT_GROUP && ((command = find_command_group(arg)) < 0 ||
      !sprintf(name, "the %s group", arg))) {
    int found = 0;
    str_start(buf, sizeof(buf));
    str_cat(buf, "No such command group.");
    if (cmd_groups) {
      str_cat(buf, "  Possible groups:\r\n");
      for (group = cmd_groups; group < top_of_cmd_groups; ++group)
        str_catf(buf, "%s%-15s", found++ % 4 == 0 ? "\r\n" : "",
                 group->alias);
    }
    str_cat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }

  else if (type == GRANT_COMMAND && !can_use_command(ch, command))
    send_to_char("You cannot grant or revoke a command you yourself cannot use.\r\n", ch);
  else if (type == GRANT_GROUP && !can_grant_group(ch, command))
    send_to_char("You cannot grant or revoke a group you yourself cannot use.\r\n", ch);
  else if (subcmd != SCMD_UNGRANT && grant_in_list(*list, command))
    cprintf(ch, "%s has already has %s %s.\r\n", GET_NAME(vict), arg, past_action);
  else if (((grant = grant_in_list(*unlist, command)) ||
            (subcmd == SCMD_UNGRANT &&
             (grant = grant_in_list(*list, command)))) &&
           grant->level > GET_LEVEL(ch))
    cprintf(ch, "You cannot change %s's access to %s, because %s (level %d) granted or revoked it.\r\n",
            GET_NAME(vict), arg,
            grant->grantor, grant->level);
  else if (subcmd == SCMD_UNGRANT) {
    remove_grant(unlist, command);
    cache_grant(uncache, command, is_group, FALSE);
    remove_grant(list, command);
    cache_grant(cache, command, is_group, FALSE);
    cprintf(ch, "Revoked all grants on %s for %s.\r\n",
            GET_NAME(vict), arg);
  }
  else {
    remove_grant(unlist, command);
    cache_grant(uncache, command, is_group, FALSE);
    add_grant(list, command, GET_NAME(ch), level);
    cache_grant(cache, command, is_group, TRUE);
    cprintf(ch, "%c%s %s %s %s at level %d.\r\n",
            UPPER(*past_action), past_action + 1, arg, preposition,
            GET_NAME(vict), level);
  }
}

static int clear_grant_list(struct char_data *ch, struct grant_type **list)
{
  struct grant_type *node, *next;
  int count = 0;

  if (!list)
    return count;

  for (node = *list; node; node = next) {
    next = node->next;
    if (node->level <= GET_LEVEL(ch)) {
      free(node->grantor);
      free(node);
      ++count;
    }
  }

  *list = NULL;

  return count;
}

static void do_clear_grants(struct char_data *ch, struct char_data *vict)
{
  int count = 0;
  count += clear_grant_list(ch, &GET_GRANTS(vict));
  count += clear_grant_list(ch, &GET_REVOKES(vict));
  count += clear_grant_list(ch, &GET_GRANT_GROUPS(vict));
  count += clear_grant_list(ch, &GET_REVOKE_GROUPS(vict));
  CLEAR_FLAGS(GET_GRANT_CACHE(vict), num_of_cmds);
  CLEAR_FLAGS(GET_REVOKE_CACHE(vict), num_of_cmds);
  cprintf(ch, "%d grant%s cleared.\r\n", count, count == 1 ? "" : "s");
}

ACMD(do_grant)
{
  struct char_data *vict;

  argument = any_one_arg(argument, arg);
  if (!*arg) {
    send_grant_usage(ch);
    return;
  }

  if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return;
  }

  argument = any_one_arg(argument, arg);
  if (subcmd == SCMD_GRANT && GET_LEVEL(ch) >= GET_LEVEL(vict) &&
      (!*arg || is_abbrev(arg, "list")))
    do_list_grants(ch, vict);
  else if (GET_LEVEL(ch) <= GET_LEVEL(vict))
    act("You cannot grant or revoke $N's commands.", FALSE, ch, 0, vict, TO_CHAR);
  else if (is_abbrev(arg, "command"))
    do_grant_revoke(ch, vict, argument, subcmd, GRANT_COMMAND);
  else if (is_abbrev(arg, "group"))
    do_grant_revoke(ch, vict, argument, subcmd, GRANT_GROUP);
  else if (subcmd == SCMD_REVOKE)
    send_grant_usage(ch);
  else if (is_abbrev(arg, "clear"))
    do_clear_grants(ch, vict);
  else
    send_grant_usage(ch);
}


ACMD(do_gedit)
{
  int group;
  struct descriptor_data *d;

  if (IS_NPC(ch) || !ch->desc)
    return;

  /* Edit which command group? */
  argument = any_one_arg(argument, arg);
  if (!*arg) {
    send_to_char("Specify a command group to edit.\r\n", ch);
    return;
  }

  /* Make sure it exists, or create a new one */
  if (!str_cmp(arg, "new"))
    group = -1;
  else if (!str_cmp(arg, "save")) {
    send_to_char("Saving all command groups.\r\n", ch);
    sprintf(buf, "OLC: %s saves command groups.", GET_NAME(ch));
    mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
    gedit_save_to_disk();
    return;
  }
  else if ((group = find_command_group(arg)) < 0) {
    cprintf(ch, "Command group '%s' not found.  Use 'gedit new' to create it.\r\n", arg);
    return;
  }

  /* Make sure it's not being edited already */
  if (group >= 0)
    for (d = descriptor_list; d; d = d->next)
      if (d->connected == CON_GEDIT && d->olc && OLC_NUM(d) == group) {
        cprintf(ch, "That command group is currently being edited by %s.\r\n",
                PERS(ch, d->character));
        return;
      }
  d = ch->desc;

  /* Give descriptor an OLC structure */
  CREATE(d->olc, struct olc_data, 1);

  if (group >= 0)
    gedit_setup_existing(d, group);
  else
    gedit_setup_new(d);
  STATE(d) = CON_GEDIT;

  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
  SET_FLAG(PLR_FLAGS(ch), PLR_WRITING);
}

static void gedit_setup_existing(struct descriptor_data *d, int group)
{
  int cmd, grp, count = 0;

  OLC_NUM(d) = group;

  CREATE(OLC_GROUP(d), struct olc_command_group, 1);

  OLC_GROUP(d)->alias = strdup(cmd_groups[group].alias);
  OLC_GROUP(d)->name = strdup(cmd_groups[group].name);
  OLC_GROUP(d)->description = strdup(cmd_groups[group].description);
  OLC_GROUP(d)->commands = NULL;

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (grp_info[cmd].groups)
      for (grp = 0; grp_info[cmd].groups[grp] >= 0; ++grp)
        if (grp_info[cmd].groups[grp] == group)
          ++count;

  if (count) {
    CREATE(OLC_GROUP(d)->commands, int, count + 1);

  count = 0;

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (grp_info[cmd].groups)
      for (grp = 0; grp_info[cmd].groups[grp] >= 0; ++grp)
        if (grp_info[cmd].groups[grp] == group)
          OLC_GROUP(d)->commands[count++] = cmd;
  }

  gedit_disp_menu(d);
  OLC_VAL(d) = 0;
}

static void gedit_setup_new(struct descriptor_data *d)
{
  OLC_NUM(d) = -1;

  CREATE(OLC_GROUP(d), struct olc_command_group, 1);

  OLC_GROUP(d)->alias = strdup("newgroup");
  OLC_GROUP(d)->name = strdup("New Command Group");
  OLC_GROUP(d)->description = strdup("A new command group.\r\n");
  OLC_GROUP(d)->commands = NULL;

  gedit_disp_menu(d);
  OLC_VAL(d) = 0;
}

void gedit_parse(struct descriptor_data *d, char *arg)
{
  int num, i;

  switch (OLC_MODE(d)) {
  case GEDIT_MAIN_MENU:
    switch (LOWER(*arg)) {
    case '1':
      write_to_output("Enter new group alias: ", d);
      OLC_MODE(d) = GEDIT_ALIAS;
      break;
    case '2':
      write_to_output("Enter new group name: ", d);
      OLC_MODE(d) = GEDIT_NAME;
      break;
    case '3':
      write_to_output("Enter new group description (/s saves /h for help): \r\n\r\n", d);
      OLC_MODE(d) = GEDIT_DESCRIPTION;
      string_write(d, &OLC_GROUP(d)->description, MAX_STRING_LENGTH);
      break;
    case '4':
      write_to_output("Enter minimum level for admin access to group: ", d);
      OLC_MODE(d) = GEDIT_LEVEL;
      break;
    case 'a':
      write_to_output("Command to add to group: ", d);
      OLC_MODE(d) = GEDIT_ADD_COMMAND;
      break;
    case 'r':
      write_to_output("Command to remove from group: ", d);
      OLC_MODE(d) = GEDIT_REMOVE_COMMAND;
      break;
    case 'c':
      write_to_output("All commands cleared.\r\n", d);
      free(OLC_GROUP(d)->commands);
      OLC_GROUP(d)->commands = NULL;
      OLC_VAL(d) = 1;
      gedit_disp_menu(d);
      break;
    case 'q':
      for (i = 0; i < num_cmd_groups; ++i)
        if (i != OLC_NUM(d) && !strcmp(cmd_groups[i].alias, OLC_GROUP(d)->alias)) {
          write_to_output("This command group has the same alias as another existing group.\r\n"
                          "It cannot be saved until the alias is changed.\r\n", d);
          return;
        }
      if (OLC_VAL(d)) {
        write_to_output("Do you wish to save the changes to the command group? (y/n) : ", d);
        OLC_MODE(d) = GEDIT_CONFIRM_SAVE;
      }
      else {
        write_to_output("No changes made.\r\n", d);
        cleanup_olc(d, CLEANUP_ALL);
      }
    }
    return;
  case GEDIT_ALIAS:
    skip_spaces(&arg);
    if (!*arg) {
      write_to_output("Group alias must consist of at least one letter or number.\r\n"
                      "Try again: ", d);
      return;
    }
    for (i = 0; arg[i]; ++i)
      if (!isalpha(arg[i]) && !isdigit(arg[i])) {
        write_to_output("Group alias may only consist of letters and numbers.\r\n"
                        "Try again: ", d);
        return;
      }
    if (OLC_GROUP(d)->alias)
      free(OLC_GROUP(d)->alias);
    else
      log("SYSERR: OLC: GEDIT_ALIAS: no alias to free!");
    OLC_GROUP(d)->alias = strdup(arg);
    gedit_disp_menu(d);
    break;
  case GEDIT_NAME:
    if (OLC_GROUP(d)->name)
      free(OLC_GROUP(d)->name);
    else
      log("SYSERR: OLC: GEDIT_NAME: no name to free!");
    OLC_GROUP(d)->name = strdup(arg);
    gedit_disp_menu(d);
    break;
  case GEDIT_DESCRIPTION:
    if (OLC_GROUP(d)->description)
      free(OLC_GROUP(d)->description);
    else
      log("SYSERR: OLC: GEDIT_DESCRIPTION: no description to free!");
    OLC_GROUP(d)->description = strdup(arg);
    gedit_disp_menu(d);
    break;
  case GEDIT_LEVEL:
    OLC_GROUP(d)->minimum_level = LIMIT(0, atoi(arg), LVL_IMPL);
    gedit_disp_menu(d);
    break;
  case GEDIT_ADD_COMMAND:
    if (!*arg) {
      gedit_disp_menu(d);
      return;
    }
    if ((num = parse_command(arg)) <= 0) {
      write_to_output("Unrecognized command.  Try again: ", d);
      return;
    }
    if (OLC_GROUP(d)->commands) {
      for (i = 0; OLC_GROUP(d)->commands[i]; ++i)
        if (OLC_GROUP(d)->commands[i] == num) {
          write_to_output("This command group already contains that command.\r\n", d);
          gedit_disp_menu(d);
          return;
        }
      RECREATE(OLC_GROUP(d)->commands, int, i + 2);
      OLC_GROUP(d)->commands[i + 1] = 0;
    }
    else {
      CREATE(OLC_GROUP(d)->commands, int, 2);
      i = 0;
    }
    OLC_GROUP(d)->commands[i] = num;
    gedit_disp_menu(d);
    break;
  case GEDIT_REMOVE_COMMAND:
    if (!*arg) {
      gedit_disp_menu(d);
      return;
    }
    if ((num = parse_command(arg)) <= 0) {
      write_to_output("Unrecognized command.  Try again: ", d);
      return;
    }
    if (OLC_GROUP(d)->commands) {
      for (i = 0; OLC_GROUP(d)->commands[i]; ++i)
        if (OLC_GROUP(d)->commands[i] == num)
          num = -1;
        else if (num < 0)
          OLC_GROUP(d)->commands[i - 1] = OLC_GROUP(d)->commands[i];
      if (num < 0) {
        OLC_GROUP(d)->commands[i - 1] = 0;
        gedit_disp_menu(d);
        break;
      }
    }
    write_to_output("This command group does not contain that command.\r\n", d);
    gedit_disp_menu(d);
    return;
  case GEDIT_CONFIRM_SAVE:
    switch (LOWER(*arg)) {
    case 'y':
      write_to_output("Saving command group in memory.\r\n", d);
      gedit_save_internally(d);
      sprintf(buf, "OLC: %s edits command group %s.",
              GET_NAME(d->character), OLC_GROUP(d)->alias);
      mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
      /* Fall through */
    case 'n':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      write_to_output("Invalid choice!\r\n"
                      "Do you wish to save the command group? : ", d);
      break;
    }
    return;
  }
  OLC_VAL(d) = 1;
}

void gedit_disp_menu(struct descriptor_data *d)
{
  struct olc_command_group *group = OLC_GROUP(d);
  int i;

  get_char_cols(d->character);

  str_start(buf, sizeof(buf));

  str_catf(buf,
#if defined(CLEAR_SCREEN)
           ".[H.[J"
#endif
           "-- Command Group: id [%s%5d%s]\r\n"
           "%s1%s) Alias       : %s%s\r\n"
           "%s2%s) Name        : %s%s\r\n"
           "%s3%s) Description :\r\n%s%s"
           "%s4%s) Minimum Lvl : %s%d\r\n"
           "%sGroup Commands :\r\n",

           grn, OLC_NUM(d), nrm,
           grn, nrm, yel, group->alias,
           grn, nrm, yel, group->name,
           grn, nrm, yel, group->description,
           grn, nrm, yel, group->minimum_level,
           nrm);

  if (group->commands)
    for (i = 0; group->commands[i]; ++i)
      str_catf(buf, "  %s\r\n", cmd_info[group->commands[i]].command);
  else
    str_cat(buf, "  None.\r\n");

  str_catf(buf,
           "%sA%s) Add command to group.\r\n"
           "%sR%s) Remove command from group.\r\n"
           "%sC%s) Clear all commands in group.\r\n"
           "%sQ%s) Quit\r\n"
           "Enter your choice : ",
           grn, nrm, grn, nrm, grn, nrm, grn, nrm
           );

  write_to_output(buf, d);

  OLC_MODE(d) = GEDIT_MAIN_MENU;
}

static void add_group(int **listptr, struct command_group *group)
{
  int i;

  if (*listptr) {
    for (i = 0; (*listptr)[i] >= 0; ++i);
    RECREATE(*listptr, int, i + 1);
  }
  else {
    i = 0;
    CREATE(*listptr, int, 2);
  }

  (*listptr)[i] = GROUP_NUM(group);
  (*listptr)[i + 1] = -1;
}

static void remove_group(int **listptr, struct command_group *group)
{
  int i, found = FALSE;

  if (*listptr) {
    for (i = 0; (*listptr)[i] >= 0; ++i)
      if ((*listptr)[i] == GROUP_NUM(group))
        found = TRUE;
      else if (found)
        (*listptr)[i - 1] = (*listptr)[i];
    if (found) {
      (*listptr)[i - 1] = -1;
      if (i - 1 == 0) {
        free(*listptr);
        *listptr = NULL;
      }
    }
  }
}

static bool group_in_list(int *list, struct command_group *group)
{
  int i = 0;
  if (list)
    for (i = 0; list[i] >= 0; ++i)
      if (list[i] == GROUP_NUM(group))
        return TRUE;
  return FALSE;
}

static void gedit_save_internally(struct descriptor_data *d)
{
  struct command_group *group;
  int cmd;

  if (OLC_NUM(d) >= 0)
    group = cmd_groups + OLC_NUM(d);
  else {
    if (cmd_groups)
      RECREATE(cmd_groups, struct command_group, num_cmd_groups + 1);
    else
      CREATE(cmd_groups, struct command_group, 1);
    group = &cmd_groups[num_cmd_groups++];
  }

  group->alias = strdup(OLC_GROUP(d)->alias);
  group->name = strdup(OLC_GROUP(d)->name);
  group->description = strdup(OLC_GROUP(d)->description);
  group->minimum_level = OLC_GROUP(d)->minimum_level;

  /* Remove group from all commands */
  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    remove_group(&grp_info[cmd].groups, group);

  /* Add group to commands */
  if (OLC_GROUP(d)->commands)
    for (cmd = 0; OLC_GROUP(d)->commands[cmd]; ++cmd)
      add_group(&grp_info[OLC_GROUP(d)->commands[cmd]].groups, group);
}

static void gedit_save_to_disk()
{
  struct command_group *group;
  FILE *file;
  int cmd;

  if (!(file = fopen(GROUP_FILE, "w"))) {
    mudlog("SYSERR: OLC: gedit_save_to_disk: Can't write to command group file.",
           BRF, LVL_GOD, TRUE);
    return;
  }

  for (group = cmd_groups; group < top_of_cmd_groups; ++group) {
    fprintf(file,
            "alias: %s\n"
            "name: %s\n"
            "desc:\n%s~\n"
            "level: %d\n"
            "commands:\n",
            filter_chars(buf, group->alias, "\r\n"),
            filter_chars(buf1, group->name, "\r\n"),
            filter_chars(buf2, group->description, "\r~"),
            group->minimum_level);
    for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
      if (group_in_list(grp_info[cmd].groups, group))
        fprintf(file, "%s\n", filter_chars(buf, cmd_info[cmd].command, "\r\n"));
    fprintf(file, "~\n~~\n");
  }

  fprintf(file, "~~~\n");

  fclose(file);
}

void boot_command_groups()
{
  FILE *file;
  char line[MAX_INPUT_LENGTH];
  char tag[128];
  struct command_group *group;
  int buffer, cmd;

  if (cmd_groups)
    free_command_groups();

  /*
   * This is necessary for the game to work.  The grp_info array
   * parallels the cmd_info array because cmd_info is const.
   */
  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd);
  CREATE(grp_info, struct command_group_info, cmd + 1);

  if (!(file = fopen(GROUP_FILE, "r"))) {
    log("SYSERR: boot_command_groups: Can't read command group file.");
    return;
  }

  CREATE(cmd_groups, struct command_group, (buffer = 10));
  group = NULL;
  num_cmd_groups = 0;

  while (get_line(file, line)) {
    if (!strcmp(line, "~~~"))
      break;
    else if (!strcmp(line, "~~")) {
      ++num_cmd_groups;
      group = NULL;
      continue;
    }

    if (!group) {
      if (num_cmd_groups >= buffer) {
        buffer += 10;
        RECREATE(cmd_groups, struct command_group, buffer);
      }
      group = &cmd_groups[num_cmd_groups];
    }

    tag_argument(line, tag);

    if (!strcmp(tag, "alias"))
      group->alias = strdup(line);
    else if (!strcmp(tag, "name"))
      group->name = strdup(line);
    else if (!strcmp(tag, "desc"))
      group->description = fread_string(file, "boot_command_groups");
    else if (!strcmp(tag, "level"))
      group->minimum_level = atoi(line);
    else if (!strcmp(tag, "commands")) {
      while (get_line(file, line)) {
        if (*line == '~')
          break;
        if ((cmd = find_command(line)) >= 0)
          add_group(&grp_info[cmd].groups, group);
      }
    }
  }

  fclose(file);

  if (!num_cmd_groups) {
    free(cmd_groups);
    cmd_groups = NULL;
  }
}

void write_player_grants(FILE *fl, struct char_data *ch)
{
  struct grant_type *grant;

  if (GET_GRANTS(ch)) {
    fprintf(fl, "grants:\n");
    for (grant = GET_GRANTS(ch); grant; grant = grant->next)
      fprintf(fl, "%s %s %d\n", cmd_info[grant->grant].command,
              grant->grantor, grant->level);
    fprintf(fl, "~\n");
  }

  if (GET_REVOKES(ch)) {
    fprintf(fl, "revokes:\n");
    for (grant = GET_REVOKES(ch); grant; grant = grant->next)
      fprintf(fl, "%s %s %d\n", cmd_info[grant->grant].command,
              grant->grantor, grant->level);
    fprintf(fl, "~\n");
  }

  if (GET_GRANT_GROUPS(ch)) {
    fprintf(fl, "grantgroups:\n");
    for (grant = GET_GRANT_GROUPS(ch); grant; grant = grant->next)
      fprintf(fl, "%s %s %d\n", cmd_groups[grant->grant].alias,
              grant->grantor, grant->level);
    fprintf(fl, "~\n");
  }

  if (GET_REVOKE_GROUPS(ch)) {
    fprintf(fl, "revokegroups:\n");
    for (grant = GET_REVOKE_GROUPS(ch); grant; grant = grant->next)
      fprintf(fl, "%s %s %d\n", cmd_groups[grant->grant].alias,
              grant->grantor, grant->level);
    fprintf(fl, "~\n");
  }
}


static void read_player_grant_list(FILE *fl, struct grant_type **list, int (*cmd_lookup)(char *name))
{
  char line[MAX_INPUT_LENGTH + 1], *ptr;
  struct grant_type *grant;
  int line_fail;

  while (TRUE) {
    get_line(fl, line);
    if (*line == '~')
      return;
    else if (strchr(line, ':')) {
      sprintf(buf, "SYSERR: read_player_grants: invalid command/group or grantor (err 1): %s", line);
      mudlog(buf, BRF, LVL_IMMORT, TRUE);
      return;
    }
    line_fail = 0;
    CREATE(grant, struct grant_type, 1);
    ptr = strchr(line, ' ');
    if (ptr) {
      *(ptr++) = '\0';
      if ((grant->grant = (*cmd_lookup)(line)) >= 0) {
        grant->grantor = ptr;
        ptr = strchr(ptr, ' ');
        if (ptr) {
          *(ptr++) = '\0';
          grant->grantor = strdup(grant->grantor);
          grant->level = LIMIT(0, atoi(ptr), LVL_IMPL);
        }
        else
          line_fail = 3;
      }
      else
        line_fail = 2;
    }
    else
      line_fail = 1;
    if (!line_fail) {
      grant->next = *list;
      *list = grant;
    }
    else {
      sprintf(buf, "SYSERR: read_player_grants: invalid command/group or grantor (err 2.%d): %s/%s", line_fail, line, ptr ? ptr : "(null)");
      mudlog(buf, BRF, LVL_IMMORT, TRUE);
      free(grant);
    }
  }
}

void read_player_grants(FILE *fl, struct grant_type **list) {
  read_player_grant_list(fl, list, find_command);
}

void read_player_grant_groups(FILE *fl, struct grant_type **list) {
  read_player_grant_list(fl, list, find_command_group);
}

void do_show_command_groups(struct char_data *ch, char *argument)
{
  struct command_group *group;
  int num, cmd, grp, found = 0;

  skip_spaces(&argument);

  if (*argument && (num = find_command_group(argument)) >= 0) {
    group = &cmd_groups[num];
    str_start(buf, sizeof(buf));
    str_catf(buf, "Command Group    : @@y%s@@0 (@@g%d@@0)\r\n"
                  "Name             : @@c%s@@0\r\n"
                  "Description      :\r\n@@c%s@@0"
                  "Min. Admin Lvl.  : @@c%d@@0\r\n"
                  "Commands         : @@c",
             group->alias, num,
             group->name,
             group->description,
             group->minimum_level);
    for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
      if (grp_info[cmd].groups)
        for (grp = 0; grp_info[cmd].groups[grp] >= 0; ++grp)
          if (grp_info[cmd].groups[grp] == num)
            str_catf(buf, "%s%s", found++ ? ", " : "", cmd_info[cmd].command);
    str_cat(buf, found ? "@@0\r\n" : "NONE@@0\r\n");
    send_to_char(buf, ch);
  }
  else if (cmd_groups) {
    send_to_char("Alias         MinLvl  Name\r\n"
                 "------------  ------  ---------------------------------\r\n", ch);
    for (group = cmd_groups; group < top_of_cmd_groups; ++group)
      cprintf(ch, "%-16.16s %3d  %s\r\n",
              group->alias, group->minimum_level, group->name);
  }
  else
    send_to_char("No command groups.\r\n", ch);
}

void do_show_command(struct char_data *ch, char *argument)
{
  struct command_info *command;
  int cmd, grp;

  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Usage: show command <command>\r\n", ch);
    return;
  }

  if ((cmd = parse_command(argument)) <= 0) {
    send_to_char("Command not found.\r\n", ch);
    return;
  }

  command = &cmd_info[cmd];

  str_start(buf, sizeof(buf));

  sprintbit(command->flags, command_flags, buf1);

  str_catf(buf, "Command           : @@y%s@@0 (@@g%d@@0)\r\n"
                "Minimum Position  : @@c%s@@0\r\n"
                "Minimum Stance    : @@c%s@@0\r\n"
                "Minimum Level     : @@c%d@@0\r\n"
                "Subcommand Code   : @@c%d@@0\r\n"
                "Usage Flags       : @@c%s@@0\r\n"
                "Groups            : @@c",
           command->command, cmd,
           position_types[(int) command->minimum_position],
           stance_types[(int) command->minimum_stance],
           command->minimum_level,
           command->subcmd,
           buf1);

  if (grp_info[cmd].groups) {
    for (grp = 0; grp_info[cmd].groups[grp] >= 0; ++grp)
      str_catf(buf, "%s%s", grp ? ", " : "", cmd_groups[grp_info[cmd].groups[grp]].alias);
    str_cat(buf, "@@0\r\n");
  }
  else
    str_cat(buf, "NONE@@0\r\n");

  send_to_char(buf, ch);
}


/***************************************************************************
 * $Log: grant.c,v $
 * Revision 1.10  2009/02/21 03:30:16  myc
 * Passing an invalid command number to can_use_command is now
 * legal; it simply returns FALSE.
 *
 * Revision 1.9  2009/01/17 00:28:02  myc
 * Fix possible use of uninitialized variable.
 *
 * Revision 1.8  2008/09/21 04:54:23  myc
 * Added grant caches to the player structure to make can_use_command
 * take less execution time.
 *
 * Revision 1.7  2008/09/07 07:01:38  myc
 * Fix crash bug in gedit saving.  Fix search bug in find_command_group.
 *
 * Revision 1.6  2008/08/30 04:34:05  myc
 * can_use_command was returning FALSE when a command was granted
 * instead of TRUE.
 *
 * Revision 1.5  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.4  2008/07/22 06:12:34  myc
 * Make sure the grp_info array is always initialized by boot_command_groups.
 *
 * Revision 1.3  2008/07/21 19:14:53  jps
 * Avoid crash when cmdgroups file is not present.
 *
 * Revision 1.2  2008/07/15 18:53:39  myc
 * Renamed some structs and functions.  Fixed bug in find_command_group.
 * Added 'show command' and added functionality to 'show group' to
 * display single command group info.
 *
 * Revision 1.1  2008/07/15 17:49:24  myc
 * Initial revision
 *
 *
 ***************************************************************************/
@


1.10
log
@Passing an invalid command number to can_use_command is now
legal; it simply returns FALSE.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.9 2009/01/17 00:28:02 myc Exp myc $
d514 1
a514 1
  if (!(vict = get_char_vis(ch, arg))) {
d1222 4
@


1.9
log
@Fix possible use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.8 2008/09/21 04:54:23 myc Exp myc $
d209 3
a211 1
  if (IS_NPC(ch))
d1222 3
@


1.8
log
@Added grant caches to the player structure to make can_use_command
take less execution time.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.7 2008/09/07 07:01:38 myc Exp myc $
d361 1
a361 1
  int level, command;
d404 1
a404 1
  if (ch == vict)
d406 3
a408 1
  else if (!*arg)
d410 5
a414 2
  else if (type == GRANT_COMMAND && ((command = parse_command(arg)) <= 0 ||
           !strcpy(name, arg))) {
d417 1
d419 1
d421 1
a421 1
            !sprintf(name, "the %s group", arg))) {
d433 1
d435 1
d1220 4
@


1.7
log
@Fix crash bug in gedit saving.  Fix search bug in find_command_group.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.6 2008/08/30 04:34:05 myc Exp myc $
d178 28
d208 10
a217 1
  bool usable = FALSE, i;
d219 4
a222 3
  /* If we're above the min level, we can use it, unless it's ungranted */
  if (cmd_info[cmd].minimum_level <= GET_LEVEL(ch))
    usable = TRUE;
d225 1
a225 1
  if (!usable && grp_info[cmd].groups)
d228 1
a228 1
        usable = TRUE;
d230 3
a232 3
  /* If the command is explicitly ungranted, we can't use it.  Period. */
  if (usable && grant_in_list(GET_UNGRANTS(ch), cmd))
    return FALSE;
d234 1
a234 1
  /* If we're ungranted the group, we can't use it unless explicitly 
d236 1
a236 1
  if (usable && grp_info[cmd].groups)
d238 2
a239 2
      if (grant_in_list(GET_UNGRANT_GROUPS(ch), grp_info[cmd].groups[i]))
        usable = FALSE;
d242 2
a243 2
  if (!usable && grant_in_list(GET_GRANTS(ch), cmd))
    usable = TRUE;
d245 1
a245 1
  return usable;
d252 1
a252 1
  else if (grant_in_list(GET_UNGRANT_GROUPS(ch), group))
d261 26
d307 2
a308 2
  if (!GET_GRANTS(vict) && !GET_UNGRANTS(vict) &&
      !GET_GRANT_GROUPS(vict) && !GET_UNGRANT_GROUPS(vict)) {
d321 1
a321 1
  if (GET_UNGRANTS(vict)) {
d324 1
a324 1
    str_cat_command_grant_list(buf, GET_UNGRANTS(vict));
d333 1
a333 1
  if (GET_UNGRANT_GROUPS(vict)) {
d336 1
a336 1
    str_cat_grant_group_list(buf, GET_UNGRANT_GROUPS(vict));
d347 1
d359 1
d364 1
d370 1
a370 1
  if ((subcmd != SCMD_GRANT && subcmd != SCMD_REVOKE) ||
d374 1
d378 2
a379 1
    unlist = &GET_UNGRANTS(vict);
d383 2
a384 1
    unlist = &GET_UNGRANT_GROUPS(vict);
d393 2
d400 2
d431 16
a446 10
  else if (grant_in_list(*list, command)) {
    sprintf(buf, "%s has already had %s %s.", GET_NAME(vict), arg, past_action);
    send_to_char(buf, ch);
  }
  else if ((grant = grant_in_list(*unlist, command)) &&
           grant->level > GET_LEVEL(ch)) {
    sprintf(buf, "You cannot %s %s %s %s, because %s (level %d) %s it.\r\n",
            present_action, arg, preposition, GET_NAME(vict),
            grant->grantor, grant->level, past_action);
    send_to_char(buf, ch);
d450 1
d452 2
a453 1
    sprintf(buf, "%c%s %s %s %s at level %d.\r\n",
a455 1
    send_to_char(buf, ch);
d461 1
a461 1
  struct grant_type dummy, *node, *temp;
d467 5
a471 9
  dummy.next = *list;
  node = &dummy;

  while (node && node->next) {
    if (node->next->level <= GET_LEVEL(ch)) {
      temp = node->next;
      node->next = node->next->next;
      free(temp->grantor);
      free(temp);
a473 1
    node = node->next;
d476 1
a476 1
  *list = dummy.next;
d485 1
a485 1
  count += clear_grant_list(ch, &GET_UNGRANTS(vict));
d487 4
a490 3
  count += clear_grant_list(ch, &GET_UNGRANT_GROUPS(vict));
  sprintf(buf, "%d grant%s cleared.\r\n", count, count == 1 ? "" : "s");
  send_to_char(buf, ch);
d553 1
a553 2
    sprintf(buf, "Command group '%s' not found.  Use 'gedit new' to create it.\r\n", arg);
    send_to_char(buf, ch);
d561 1
a561 1
        sprintf(buf, "That command group is currently being edited by %s.\r\n",
a562 1
        send_to_char(buf, ch);
d1040 3
a1042 3
  if (GET_UNGRANTS(ch)) {
    fprintf(fl, "ungrants:\n");
    for (grant = GET_UNGRANTS(ch); grant; grant = grant->next)
d1056 3
a1058 3
  if (GET_UNGRANT_GROUPS(ch)) {
    fprintf(fl, "ungrantgroups:\n");
    for (grant = GET_UNGRANT_GROUPS(ch); grant; grant = grant->next)
d1152 2
a1153 2
    for (group = cmd_groups; group < top_of_cmd_groups; ++group) {
      sprintf(buf, "%-16.16s %3d  %s\r\n",
a1154 2
      send_to_char(buf, ch);
    }
d1211 3
@


1.6
log
@can_use_command was returning FALSE when a command was granted
instead of TRUE.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.5 2008/08/14 09:45:22 jps Exp myc $
d62 17
d100 2
d775 1
a775 1
    for (i = 0; (*listptr)[i]; ++i);
d792 1
a792 1
    for (i = 0; (*listptr)[i]; ++i)
d797 1
a797 1
    if (found)
d799 5
d1138 4
@


1.5
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.4 2008/07/22 06:12:34 myc Exp jps $
d186 1
a186 1
    usable = FALSE;
d1114 3
@


1.4
log
@Make sure the grp_info array is always initialized by boot_command_groups.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.3 2008/07/21 19:14:53 jps Exp myc $
d33 1
d1114 3
@


1.3
log
@Avoid crash when cmdgroups file is not present.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.2 2008/07/15 18:53:39 myc Exp jps $
a165 2
  if (!grp_info) return usable;

a863 5
  if (!(file = fopen(GROUP_FILE, "r"))) {
    log("SYSERR: boot_command_groups: Can't read command group file.");
    return;
  }

d867 4
d874 5
d1113 3
@


1.2
log
@Renamed some structs and functions.  Fixed bug in find_command_group.
Added 'show command' and added functionality to 'show group' to
display single command group info.
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.1 2008/07/15 17:49:24 myc Exp myc $
d166 2
d394 1
a394 1
  sprintf(buf, "%d grant%s cleared.\r\n", count, count > 1 ? "s" : "");
d1111 5
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: grant.c,v 1.1 $
d32 1
d39 3
a41 3
static void add_group(int **listptr, struct grant_group *group);
static void remove_group(int **listptr, struct grant_group *group);
static void free_grant_groups();
d48 1
a48 1
static struct grant_group *cmd_groups = NULL;
d52 1
a52 3
static struct command_group_info {
  int *groups;
} *grp_info = NULL;
d54 1
a54 2

int grant_group_number(struct grant_group *group)
d61 1
a61 1
  struct grant_group *bot, *top, *mid;
d64 1
a64 1
  top = top_of_cmd_groups;
d84 2
a85 2
static void free_grant_groups() {
  struct grant_group *group;
d274 1
a274 1
  struct grant_group *group;
d491 1
a491 1
  CREATE(OLC_GROUP(d), struct olc_grant_group, 1);
d524 1
a524 1
  CREATE(OLC_GROUP(d), struct olc_grant_group, 1);
d705 1
a705 1
  struct olc_grant_group *group = OLC_GROUP(d);
d750 1
a750 1
static void add_group(int **listptr, struct grant_group *group)
d767 1
a767 1
static void remove_group(int **listptr, struct grant_group *group)
d782 1
a782 1
static bool group_in_list(int *list, struct grant_group *group)
d794 1
a794 1
  struct grant_group *group;
d801 1
a801 1
      RECREATE(cmd_groups, struct grant_group, num_cmd_groups + 1);
d803 1
a803 1
      CREATE(cmd_groups, struct grant_group, 1);
d824 1
a824 1
  struct grant_group *group;
d861 1
a861 1
  struct grant_group *group;
d870 1
a870 1
    free_grant_groups();
d875 1
a875 1
  CREATE(cmd_groups, struct grant_group, (buffer = 10));
d891 1
a891 1
        RECREATE(cmd_groups, struct grant_group, buffer);
d1020 26
a1045 2
  struct grant_group *group;
  if (cmd_groups) {
d1058 49
d1109 3
@
