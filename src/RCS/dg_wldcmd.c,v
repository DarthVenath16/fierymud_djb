head	1.59;
access;
symbols;
locks; strict;
comment	@ * @;


1.59
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.26.04.39.21;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.26.03.42.01;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.17.20.23.56;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.27.05.50.34;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.27.05.30.45;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.27.01.33.22;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.07.05.42.18;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.14.05.10.06;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.11.05.48.55;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2008.04.05.20.42.21;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.05.19.43.46;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.05.18.35.57;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.02.19.56.51;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.17.19.23.07;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.19.20.49.42;	author myc;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.30.19.42.46;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.30.11.09.12;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.25.00.38.03;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.24.23.34.00;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.11.19.34.15;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.17.23.59.16;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.30.05.02.40;	author jps;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.14.20.41.49;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.12.02.31.01;	author jps;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.29.03.36.42;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.24.22.22.30;	author jjl;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.25.06.59.02;	author mtp;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.19.23.46.52;	author mtp;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.22.23.15.13;	author mtp;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.21.04.42.14;	author rsd;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.07.00.45.24;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.27.22.16.48;	author mtp;	state Exp;
branches;
next	1.6;

1.6
date	99.11.20.00.28.32;	author rsd;	state Exp;
branches;
next	1.5;

1.5
date	99.11.19.07.52.40;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	99.10.30.15.33.07;	author rsd;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.02.10.44;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/**************************************************************************
*  File: wldcmd.c                                                         *
*  Usage: contains the command_interpreter for rooms,                     *
*         room commands.                                                  *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 03:27:07 $
*  $Revision: 3.12 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern char *dirs[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;

void die(struct char_data * ch, struct char_data * killer);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
void send_to_zone(char *messg, int zone_rnum);
long asciiflag_conv(char *flag);
char_data *get_char_by_room(room_data *room, char *name);
room_data *get_room(char *name);
obj_data *get_obj_by_room(room_data *room, char *name);

#define WCMD(name)  \
    void (name)(room_data *room, char *argument, int cmd, int subcmd)


struct wld_command_info {
    char *command;
    void (*command_pointer)
           (room_data *room, char *argument, int cmd, int subcmd);
    int	subcmd;
};


/* do_wsend */
#define SCMD_WSEND        0
#define SCMD_WECHOAROUND  1



/* attaches room vnum to msg and sends it to script_log */
void wld_log(room_data *room, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Wld (room %d): %s", room->number, msg);
    script_log(buf);
}


/* sends str to room */
void act_to_room(char *str, room_data *room)
{
    /* no one is in the room */
    if (!room->people)
	return;

    /*
     * since you can't use act(..., TO_ROOM) for an room, send it
     * TO_ROOM and TO_CHAR for some char in the room.
     * (just dont use $n or you might get strange results)
     */
    act(str, FALSE, room->people, 0, 0, TO_ROOM);
    act(str, FALSE, room->people, 0, 0, TO_CHAR);
}



/* World commands */

/* prints the argument to all the rooms aroud the room */
WCMD(do_wasound)
{
    int  door;

    skip_spaces(&argument);

    if (!*argument) {
	wld_log(room, "wasound called with no argument");
	return;
    }

    for (door = 0; door < NUM_OF_DIRS; door++) {
	struct room_direction_data *exit;

	if ((exit = room->dir_option[door]) && (exit->to_room != NOWHERE) &&
	    room != &world[exit->to_room])
	    act_to_room(argument, &world[exit->to_room]);
    }
}


WCMD(do_wecho)
{
    skip_spaces(&argument);

    if (!*argument)
	wld_log(room, "wecho called with no args");

    else
	act_to_room(argument, room);
}


WCMD(do_wsend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;

    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
	wld_log(room, "wsend called with no args");
	return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
	wld_log(room, "wsend called without a message");
	return;
    }

    if ((ch = get_char_by_room(room, buf)))
    {
	if (subcmd == SCMD_WSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_WECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
    }

    else
	wld_log(room, "no target found for wsend");
}

static int real_zone(int number)
{
  int counter;

  for (counter = 0; counter <= top_of_zone_table; counter++)
    if ((number >= (zone_table[counter].number * 100)) &&
      (number <= (zone_table[counter].top)))
      return counter;

  return -1;
}

WCMD(do_wzoneecho)
{
    int zone;
    char zone_name[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH], *msg;

    msg = any_one_arg(argument, zone_name);
    skip_spaces(&msg);

    if (!*zone_name || !*msg)
	wld_log(room, "wzoneecho called with too few args");

    else if ((zone = real_zone(atoi(zone_name))) < 0)
	wld_log(room, "wzoneecho called for nonexistant zone");

    else {
	sprintf(buf, "%s\r\n", msg);
	send_to_zone(buf, zone);
    }
}


WCMD(do_wdoor)
{
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
	"purge",
	"description",
	"flags",
	"key",
	"name",
	"room",
	"\n"
    };


    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);

    if (!*target || !*direction || !*field) {
	wld_log(room, "wdoor called with too few args");
	return;
    }

    if ((rm = get_room(target)) == NULL) {
	wld_log(room, "wdoor: invalid target");
	return;
    }

    if ((dir = search_block(direction, (char **)dirs, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid direction");
	return;
    }

    if ((fd = search_block(field, (char **)door_field, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid field");
	return;
    }

    exit = rm->dir_option[dir];

    /* purge exit */
    if (fd == 0) {
	if (exit) {
	    if (exit->general_description)
		free(exit->general_description);
	    if (exit->keyword)
		free(exit->keyword);
	    free(exit);
	    rm->dir_option[dir] = NULL;
	}
    }

    else {
	if (!exit) {
	    CREATE(exit, struct room_direction_data, 1);
	    rm->dir_option[dir] = exit;
	}

	switch (fd) {
	case 1:  /* description */
	    if (exit->general_description)
		free(exit->general_description);
	    CREATE(exit->general_description, char, strlen(value) + 3);
	    strcpy(exit->general_description, value);
	    strcat(exit->general_description, "\r\n");
	    break;
	case 2:  /* flags       */
	    exit->exit_info = (int)asciiflag_conv(value);
	    break;
	case 3:  /* key         */
	    exit->key = atoi(value);
	    break;
	case 4:  /* name        */
	    if (exit->keyword)
		free(exit->keyword);
	    CREATE(exit->keyword, char, strlen(value) + 1);
	    strcpy(exit->keyword, value);
	    break;
	case 5:  /* room        */
	    if ((to_room = real_room(atoi(value))) != NOWHERE)
		exit->to_room = to_room;
	    else
		wld_log(room, "wdoor: invalid door target");
	    break;
	}
    }
}


WCMD(do_wteleport)
{
    char_data *ch, *next_ch;
    int target, nr;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2) {
	wld_log(room, "wteleport called with too few args");
	return;
    }

    nr = atoi(arg2);
    target = real_room(nr);

    if (target == NOWHERE)
	wld_log(room, "wteleport target is an invalid room");

    else if (!str_cmp(arg1, "all")) {
	if (nr == room->number) {
	    wld_log(room, "wteleport all target is itself");
	    return;
	}

	for (ch = room->people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;

	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    }

    else
    {
	if ((ch = get_char_by_room(room, arg1))) {
	    char_from_room(ch);
	    char_to_room(ch, target);
	}

	else
	    wld_log(room, "wteleport: no target found");
    }
}


WCMD(do_wforce)
{
    char_data *ch, *next_ch;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);

    if (!*arg1 || !*line) {
	wld_log(room, "wforce called with too few args");
	return;
    }

    if (!str_cmp(arg1, "all"))
    {
	for (ch = room->people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;

	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, line);
	    }
	}
    }

    else
    {
	if ((ch = get_char_by_room(room, arg1)))
	{
	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, line);
	    }
	}

	else
	    wld_log(room, "wforce: no target found");
    }
}


/* increases the target's exp */
WCMD(do_wexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
	wld_log(room, "wexp: too few arguments");
	return;
    }

    if ((ch = get_char_by_room(room, name)))
	gain_exp(ch, atoi(amount));
    else {
	wld_log(room, "wexp: target not found");
	return;
    }
}


/* purge all objects an npcs in room, or specified object or mob */
WCMD(do_wpurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *obj, *next_obj;

    one_argument(argument, arg);

    if (!*arg) {
	for (ch = room->people; ch; ch = next_ch ) {
	    next_ch = ch->next_in_room;
	    if (IS_NPC(ch))
		extract_char(ch);
	}

	for (obj = room->contents; obj; obj = next_obj ) {
	    next_obj = obj->next_content;
	    extract_obj(obj);
	}

	return;
    }

    if (!(ch = get_char_by_room(room, arg))) {
	if ((obj = get_obj_by_room(room, arg))) {
	    extract_obj(obj);
	} else
	    wld_log(room, "wpurge: bad argument");

	return;
    }

    if (!IS_NPC(ch)) {
	wld_log(room, "wpurge: purging a PC");
	return;
    }

    extract_char(ch);
}


/* loads a mobile or object into the room */
WCMD(do_wload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;


    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
	wld_log(room, "wload: bad syntax");
	return;
    }

    if (is_abbrev(arg1, "mob")) {
	if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad mob vnum");
	    return;
	}
	char_to_room(mob, real_room(room->number));
    }

    else if (is_abbrev(arg1, "obj")) {
	if ((object = read_object(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad object vnum");
	    return;
	}

	obj_to_room(object, real_room(room->number));
    }

    else
	wld_log(room, "wload: bad type");
}

WCMD(do_wdamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	wld_log(room, "wdamage: bad syntax");
	return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_room(room, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being a god, you carefully avoid a trap.", ch);
	    return;
	}
        GET_HIT(ch) -= dam;
        if (dam < 0) {
          send_to_char("You feel rejuvinated.\r\n", ch);
          return;
        }

	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
    	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
    	    }
    	    die(ch, NULL);
	}
    }
    else
	wld_log(room, "wdamage: target not found");
}

WCMD(do_wat) {
    char location[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int vnum = 0;
    room_data *r2;

    void wld_command_interpreter(room_data *room, char *argument);

    half_chop(argument, location, arg2);

    if (!*location || !*arg2 || !isdigit(*location)) {
	wld_log(room, "wat: bad syntax");
	return;
    }
    vnum = atoi(location);
    if (NOWHERE == real_room(vnum)) {
	wld_log(room, "wat: location not found");
	return;
    }

    r2 = &world[vnum];
    wld_command_interpreter(r2, arg2);
}

const struct wld_command_info wld_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

    { "wasound"    , do_wasound   , 0 },
    { "wdoor"      , do_wdoor     , 0 },
    { "wecho"      , do_wecho     , 0 },
    { "wechoaround", do_wsend     , SCMD_WECHOAROUND },
    { "wexp"       , do_wexp      , 0 },
    { "wforce"     , do_wforce    , 0 },
    { "wload"      , do_wload     , 0 },
    { "wpurge"     , do_wpurge    , 0 },
    { "wsend"      , do_wsend     , SCMD_WSEND },
    { "wteleport"  , do_wteleport , 0 },
    { "wzoneecho"  , do_wzoneecho , 0 },
    { "wdamage"    , do_wdamage,    0 },
    { "wat"        , do_wat,        0 },
    { "\n", 0, 0 }	/* this must be last */
};


/*
 *  This is the command interpreter used by rooms, called by script_driver.
 */
void wld_command_interpreter(room_data *room, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];

    skip_spaces(&argument);

    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg), cmd = 0;
	 *wld_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(wld_cmd_info[cmd].command, arg, length))
	    break;

    if (*wld_cmd_info[cmd].command == '\n') {
	sprintf(buf2, "Unknown world cmd: '%s'", argument);
	wld_log(room, buf2);
    } else
	((*wld_cmd_info[cmd].command_pointer)
	 (room, line, cmd, wld_cmd_info[cmd].subcmd));
}
@


1.59
log
@Rewrote gain_exp and retired gain_exp_regardless.
@
text
@/***************************************************************************
 * $Id: dg_wldcmd.c,v 1.58 2009/03/09 04:33:20 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: dg_wldcmd.c                                    Part of FieryMUD *
 *  Usage: contains the command_interpreter for rooms,room commands.       *
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/09 04:33:20 $                                           *
 *  $Revision: 1.58 $                                                      *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *                                                                         *
 * This code was received origonally from HubisMUD in 1998 and no lable or *
 * claim of ownership or copyright was made anywhere in the file.          *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "quest.h"
#include "constants.h"
#include "chars.h"
#include "events.h"
#include "regen.h"
#include "exits.h"
#include "olc.h" /* for real_zone */
#include "pfiles.h"
#include "players.h"
#include "movement.h"
#include "limits.h"
#include "damage.h"
#include "directions.h"

void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
long asciiflag_conv(char *flag);
room_data *get_room(char *name);
int script_driver(void *go_address, trig_data *trig, int type, int mode);
int get_room_location(char *name);
struct find_context find_dg_by_name(char *name);

#define WCMD(name)  \
    void (name)(room_data *room, struct trig_data * t, char *argument, int cmd, int subcmd)


struct wld_command_info {
  char *command;
  void (*command_pointer)
       (room_data *room, struct trig_data * t, char *argument, int cmd, int subcmd);
       int        subcmd;
};


/* do_wsend */
#define SCMD_WSEND        0
#define SCMD_WECHOAROUND  1



/* attaches room vnum to msg and sends it to script_log */
void wld_log(room_data *room, struct trig_data *t,char *msg)
{
  char buf[MAX_INPUT_LENGTH + 100];

  void script_log(struct trig_data *t,char *msg);

  sprintf(buf, "(TRG)(room %d): %s", room->vnum, msg);
  script_log(t,buf);
}


/* sends str to room */
void act_to_room(char *str, room_data *room)
{
  /* no one is in the room */
  if (!room->people)
    return;

  /*
   * since you can't use act(..., TO_ROOM) for an room, send it
   * TO_ROOM and TO_CHAR for some char in the room.
   * (just dont use $n or you might get strange results)
   */
  act(str, FALSE, room->people, 0, 0, TO_ROOM);
  act(str, FALSE, room->people, 0, 0, TO_CHAR);
}



/* World commands */

/* prints the argument to all the rooms aroud the room */
WCMD(do_wasound)
{
  int  door;

  skip_spaces(&argument);

  if (!*argument) {
    wld_log(room, t, "wasound called with no argument");
    return;
  }

  for (door = 0; door < NUM_OF_DIRS; door++) {
    struct exit *exit;

    if ((exit = room->exits[door]) && (exit->to_room != NOWHERE) &&
        room != &world[exit->to_room])
      act_to_room(argument, &world[exit->to_room]);
  }
}


WCMD(do_wecho)
{
  skip_spaces(&argument);

  if (!*argument)
    wld_log(room, t, "wecho called with no args");

  else
    act_to_room(argument, room);
}


WCMD(do_wsend)
{
  char buf[MAX_INPUT_LENGTH], *msg;
  char_data *ch;

  msg = any_one_arg(argument, buf);

  if (!*buf)
    {
      wld_log(room, t, "wsend called with no args");
      return;
    }

  skip_spaces(&msg);

  if (!*msg)
    {
      wld_log(room, t, "wsend called without a message");
      return;
    }

  if ((ch = find_char_around_room(room, find_dg_by_name(buf))))
    {
      if (subcmd == SCMD_WSEND)
        sub_write(msg, ch, TRUE, TO_CHAR);
      else if (subcmd == SCMD_WECHOAROUND)
        sub_write(msg, ch, TRUE, TO_ROOM);
    }

  else
    wld_log(room, t, "no target found for wsend");
}

WCMD(do_wzoneecho)
{
  int zone_rnum, zone_vnum;
  char zone_name[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH], *msg;

  msg = any_one_arg(argument, zone_name);
  skip_spaces(&msg);

  if (!*zone_name || !*msg)
    wld_log(room, t, "wzoneecho called with too few args");
  else if (!isdigit(*zone_name)) {
    sprintf(buf, "wzoneecho called with invalid zone number \"%s\"", zone_name);
    wld_log(room, t, buf);
  } else {
    zone_vnum = atoi(zone_name);
    if ((zone_rnum = real_zone(zone_vnum)) < 0) {
      sprintf(buf, "wzoneecho called for nonexistent zone %s", zone_name);
      wld_log(room, t, buf);
    } else {
      sprintf(buf, "%s\r\n", msg);
      send_to_zone(buf, zone_vnum, NOWHERE, STANCE_RESTING);
    }
  }
}


WCMD(do_wdoor)
{
  char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
  char field[MAX_INPUT_LENGTH], *value, *desc;
  room_data *rm;
  struct exit *exit;
  int dir, fd, to_room;

  const char *door_field[] = {
    "purge",
    "description",
    "flags",
    "key",
    "name",
    "room",
    "\n"
  };


  argument = two_arguments(argument, target, direction);
  value = one_argument(argument, field);
  skip_spaces(&value);

  if (!*target || !*direction || !*field) {
    wld_log(room, t, "wdoor called with too few args");
    return;
  }

  if ((rm = get_room(target)) == NULL) {
    wld_log(room, t, "wdoor: invalid target");
    return;
  }

  if ((dir = parse_direction(direction)) == -1) {
    wld_log(room, t, "wdoor: invalid direction");
    return;
  }

  if ((fd = searchblock(field, door_field, FALSE)) == -1) {
    wld_log(room, t, "wdoor: invalid field");
    return;
  }

  exit = rm->exits[dir];

  /* purge exit */
  if (fd == 0) {
    if (exit) {
      if (exit->general_description)
        free(exit->general_description);
      if (exit->keyword)
        free(exit->keyword);
      free(exit);
      rm->exits[dir] = NULL;
    }
  }

  else {
    if (!exit) {
      exit = create_exit(NOWHERE);
      rm->exits[dir] = exit;
    }

    switch (fd) {
    case 1:  /* description */
      if (exit->general_description)
        free(exit->general_description);
      CREATE(desc, char, strlen(value) + 1);
      strcpy(desc, value);
      replace_str(&desc, "\\n", "\r\n", 1, MAX_INPUT_LENGTH);
      CREATE(exit->general_description, char, strlen(desc) + 3);
      strcpy(exit->general_description, desc);
      strcat(exit->general_description, "\r\n");
      free(desc);
      break;
    case 2:  /* flags       */
      exit->exit_info = (int)asciiflag_conv(value);
      break;
    case 3:  /* key         */
      exit->key = atoi(value);
      break;
    case 4:  /* name        */
      if (exit->keyword)
        free(exit->keyword);
      CREATE(exit->keyword, char, strlen(value) + 1);
      strcpy(exit->keyword, value);
      break;
    case 5:  /* room        */
      if ((to_room = real_room(atoi(value))) != NOWHERE)
        exit->to_room = to_room;
      else
        wld_log(room, t, "wdoor: invalid door target");
      break;
    }
  }
}


WCMD(do_wteleport)
{
  char_data *ch, *next_ch;
  int target;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  two_arguments(argument, arg1, arg2);

  if (!*arg1 || !*arg2) {
    wld_log(room, t, "wteleport called with too few args");
    return;
  }

  target = get_room_location(arg2);

  if (target == NOWHERE)
    wld_log(room, t, "wteleport target is an invalid room");

  else if (!str_cmp(arg1, "all")) {
    if (world[target].vnum == room->vnum) {
      wld_log(room, t, "wteleport all target is itself");
      return;
    }

    for (ch = room->people; ch; ch = next_ch) {
      next_ch = ch->next_in_room;

      dismount_char(ch);
      char_from_room(ch);
      char_to_room(ch, target);
    }
  }

  else {
    if ((ch = find_char_around_room(room, find_dg_by_name(arg1)))) {
      dismount_char(ch);
      char_from_room(ch);
      char_to_room(ch, target);
    }

    else
      wld_log(room, t, "wteleport: no target found");
  }
}


WCMD(do_wforce)
{
  char_data *ch, *next_ch;
  char arg1[MAX_INPUT_LENGTH], *line;

  line = one_argument(argument, arg1);

  if (!*arg1 || !*line) {
    wld_log(room, t, "wforce called with too few args");
    return;
  }

  if (!str_cmp(arg1, "all"))
    {
      for (ch = room->people; ch; ch = next_ch)
        {
          next_ch = ch->next_in_room;

          if (GET_LEVEL(ch)<LVL_IMMORT)
            {
              command_interpreter(ch, line);
            }
        }
    }

  else
    {
      if ((ch = find_char_around_room(room, find_dg_by_name(arg1))))
        {
          if (GET_LEVEL(ch)<LVL_IMMORT)
            {
              command_interpreter(ch, line);
            }
        }

      else
        wld_log(room, t, "wforce: no target found");
    }
}


/* increases the target's exp */
WCMD(do_wexp)
{
  char_data *ch;
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

  two_arguments(argument, name, amount);

  if (!*name || !*amount) {
    wld_log(room, t, "wexp: too few arguments");
    return;
  }

  if ((ch = find_char_around_room(room, find_dg_by_name(name))))
    gain_exp(ch, atoi(amount), GAIN_IGNORE_LEVEL_BOUNDARY |
                               GAIN_IGNORE_LOCATION);
  else {
    wld_log(room, t, "wexp: target not found");
    return;
  }
}


/* purge all objects an npcs in room, or specified object or mob */
WCMD(do_wpurge)
{
  char arg[MAX_INPUT_LENGTH];
  char_data *ch, *next_ch;
  obj_data *obj, *next_obj;

  one_argument(argument, arg);

  if (!*arg) {
    for (ch = room->people; ch; ch = next_ch ) {
      next_ch = ch->next_in_room;
      if (IS_NPC(ch))
         fullpurge_char(ch);
    }

    for (obj = room->contents; obj; obj = next_obj ) {
      next_obj = obj->next_content;
      extract_obj(obj);
    }

    return;
  }

  if (!(ch = find_char_around_room(room, find_dg_by_name(arg)))) {
    if ((obj = find_obj_around_room(room, find_by_name(arg)))) {
      extract_obj(obj);
    } else
      wld_log(room, t, "wpurge: bad argument");

    return;
  }

  if (!IS_NPC(ch)) {
    wld_log(room, t, "wpurge: purging a PC");
    return;
  }

  fullpurge_char(ch);
}


/* loads a mobile or object into the room */
WCMD(do_wload)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int number = 0, rnum;
  char_data *mob;
  obj_data *object;


  two_arguments(argument, arg1, arg2);

  if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
    wld_log(room, t, "wload: bad syntax");
    return;
  }

  if (is_abbrev(arg1, "mob")) {
    if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
      wld_log(room, t, "wload: bad mob vnum");
      return;
    }
    if( (rnum = real_room(room->vnum)) == NOWHERE) {
      wld_log(room, t, "wload: room is NOWHERE");
      return;
    }
    char_to_room(mob, rnum);
    load_mtrigger(mob);
  }

  else if (is_abbrev(arg1, "obj")) {
    if ((object = read_object(number, VIRTUAL)) == NULL) {
      wld_log(room, t, "wload: bad object vnum");
      return;
    }

    if( (rnum = real_room(room->vnum)) == NOWHERE) {
      wld_log(room, t, "wload: room is NOWHERE");
      return;
    }
    obj_to_room(object, rnum);
  }

  else
    wld_log(room, t, "wload: bad type");
}

WCMD(do_wheal) {
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
  int dam = 0;
  char_data *ch;

  two_arguments(argument, name, amount);

  if (!*name || !*amount || !isdigit(*amount)) {
    wld_log(room, t, "wheal: bad syntax");
    return;
  }

  dam = atoi(amount);
  if (dam > 32767 )
          dam = 32767;        /* hitpoint is a short signed int */

  if ((ch = find_char_around_room(room, find_dg_by_name(name)))) {
    if (GET_LEVEL(ch)>=LVL_IMMORT) {
      send_to_char("Being a god, you don't need healing.\r\n", ch);
      return;
    }
    hurt_char(ch, NULL, -dam, TRUE);
  }
  else
    wld_log(room, t, "wheal: target not found");
}

WCMD(do_wdamage) {
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH], damtype[MAX_INPUT_LENGTH];
  int dam = 0, dtype = DAM_UNDEFINED;
  char_data *ch;

  t->damdone = 0;

  argument = one_argument(argument, name);
  argument = one_argument(argument, amount);

  if (!*name || !*amount || !isdigit(*amount)) {
    wld_log(room, t, "wdamage: bad syntax");
    return;
  }

  dam = atoi(amount);
  if (dam > 32767)
    dam = 32767;        /* hitpoint is a short signed int */

  ch = find_char_around_room(room, find_dg_by_name(name));
  if (!ch) {
    wld_log(room, t, "wdamage: target not found");
    return;
  }

  if (GET_LEVEL(ch) >= LVL_IMMORT) return;

  /* Check for and use optional damage-type parameter */
  argument = one_argument(argument, damtype);
  if (*damtype) {
    dtype = parse_damtype(0, damtype);
    if (dtype == DAM_UNDEFINED) {
      sprintf(buf,
            "wdamage called with invalid third argument (\"%s\") - not a damage type",
            damtype);
      wld_log(room, t, buf);
      return;
    }
    dam = dam * susceptibility(ch, dtype) / 100;
    if (!dam) return;
  }

  t->damdone = dam;
  sethurtevent(0, ch, dam);
}

/*
 * Room version of do_quest
 * note, we don't return anything regardless of success of fail (whats a room gonna do?)
 * and we DONT allow the godly commands (rewind, restart) or stage since its a bit
 * pointless..
 * conversley, we CAN match any player in the mud, even invis/hidden whatever
 */
WCMD(do_wld_quest)
{
  perform_quest(t, argument, NULL, NULL, room);
}

WCMD(do_wat) {
  char location[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  room_data *r2;

  void wld_command_interpreter(room_data *room, struct trig_data *t, char *argument);

  half_chop(argument, location, arg2);

  if (!*location || !*arg2 || (!isdigit(*location) && *location != UID_CHAR)) {
    wld_log(room, t, "wat: bad syntax");
    return;
  }
  r2 = get_room(location);
  if (r2 == NULL) {
    wld_log(room, t, "wat: location not found");
    return;
  }

  wld_command_interpreter(r2, t, arg2);
}

WCMD(do_w_run_room_trig) {
   char arg1[MAX_INPUT_LENGTH];
   int runtrig, found = 0;
   struct script_data *sc;
   trig_data *tr;

   if (!*argument) {
      wld_log(room, t, "w_run_room_trig called with no argument");
      return;
   }

   one_argument(argument, arg1);

   if (!*arg1 || !is_number(arg1)) {
      wld_log(room, t, "w_run_room_trig: bad syntax");
      return;
   }

   runtrig = atoi(arg1);

   if ((sc = SCRIPT(room))) {
      for (tr = TRIGGERS(sc); tr; tr = tr->next) {
         if (GET_TRIG_VNUM(tr) == runtrig) {
            found = 1;
            break;
         }
      }
   }

   if (found) {
      script_driver(&room, tr, WLD_TRIGGER, TRIG_NEW);
   } else {
      sprintf(buf, "w_run_room_trig finds no such trigger %d", runtrig);
      wld_log(room, t, buf);
   }
}


WCMD(do_wld_log) {
  wld_log(room, t, argument);
}

WCMD(do_wrent)
{
  struct char_data *ch;

  extern void rem_memming(struct char_data *ch);

  argument = any_one_arg(argument, arg);

  if (!*arg) {
    wld_log(room, t, "wrent called with no args");
    return;
  }

  if (!(ch = find_char_around_room(room, find_dg_by_name(arg)))) {
    wld_log(room, t, "no target found for wsend");
    return;
  }

  if (IS_NPC(ch)) {
    wld_log(room, t, "wrent target is not player");
    return;
  }

  if (!ch->desc)
    wld_log(room, t, "wrent called on player without descriptor");

  if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
    act("$N ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("&8You stop meditating.\r\n&0", ch);
    REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
  }

  rem_memming(ch);
  sprintf(buf, "%s rented by trigger %d in %s (%d).", GET_NAME(ch),
          GET_TRIG_VNUM(t), world[ch->in_room].name,
          world[ch->in_room].vnum);
  mudlog(buf, NRM, LVL_IMMORT, TRUE);
  remove_player_from_game(ch, QUIT_WRENT);
}

const struct wld_command_info wld_cmd_info[] = {
  { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

  { "wasound"    , do_wasound   , 0 },
  { "wdoor"      , do_wdoor     , 0 },
  { "wecho"      , do_wecho     , 0 },
  { "wechoaround", do_wsend     , SCMD_WECHOAROUND },
  { "wexp"       , do_wexp      , 0 },
  { "wforce"     , do_wforce    , 0 },
  { "wload"      , do_wload     , 0 },
  { "wpurge"     , do_wpurge    , 0 },
  { "wsend"      , do_wsend     , SCMD_WSEND },
  { "wteleport"  , do_wteleport , 0 },
  { "wzoneecho"  , do_wzoneecho , 0 },
  { "wdamage"    , do_wdamage   , 0 },
  { "wheal"      , do_wheal     , 0 },
  { "wat"        , do_wat       , 0 },
  { "wrent"      , do_wrent     , 0 },
  { "quest"      , do_wld_quest , 0 },
  { "log"        , do_wld_log   , 0 },
  { "w_run_room_trig", do_w_run_room_trig, 0 },
  { "\n", 0, 0 }        /* this must be last */
};


/*
 *  This is the command interpreter used by rooms, called by script_driver.
 */
void wld_command_interpreter(room_data *room, struct trig_data *t,char *argument)
{
  int cmd, length;
  char *line, arg[MAX_INPUT_LENGTH];

  skip_spaces(&argument);

  /* just drop to next line for hitting CR */
  if (!*argument)
    return;

  line = any_one_arg(argument, arg);


  /* find the command */
  for (length = strlen(arg), cmd = 0;
       *wld_cmd_info[cmd].command != '\n'; cmd++)
    if (!strncmp(wld_cmd_info[cmd].command, arg, length))
      break;

  if (*wld_cmd_info[cmd].command == '\n') {
    sprintf(buf2, "Unknown world cmd: '%s'", argument);
    wld_log(room, t, buf2);
  } else
    ((*wld_cmd_info[cmd].command_pointer)
     (room, t, line, cmd, wld_cmd_info[cmd].subcmd));
}

/***************************************************************************
 * $Log: dg_wldcmd.c,v $
 * Revision 1.58  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.57  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.56  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.55  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.54  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.53  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.52  2008/08/26 04:39:21  jps
 * Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
 *
 * Revision 1.51  2008/08/26 03:42:01  jps
 * More detailed error reporting for wzoneecho.
 *
 * Revision 1.50  2008/08/17 20:23:56  jps
 * Use macro parse_direction
 *
 * Revision 1.49  2008/07/27 05:50:34  jps
 * Include players.h header file.
 *
 * Revision 1.48  2008/07/27 05:30:45  jps
 * Using remove_player_from_game function for rent trigger.
 *
 * Revision 1.47  2008/07/27 01:33:22  jps
 * Added room vnum to trigger-rented message.
 *
 * Revision 1.46  2008/07/07 05:42:18  myc
 * Added 'wrent' command.
 *
 * Revision 1.45  2008/06/19 18:53:12  myc
 * Now using real_zone() from olc.c.
 *
 * Revision 1.44  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.43  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.42  2008/05/14 05:10:06  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.41  2008/05/11 05:48:55  jps
 * Calling alter_hit() which also takes care of position changes.
 *
 * Revision 1.40  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.39  2008/04/05 20:42:21  jps
 * wdamage sets an event to do damage rather than doing it itself.
 *
 * Revision 1.38  2008/04/05 19:43:46  jps
 * Set damdone to the damage done by wdamage. Don't send any messages
 * when someone receives 0 damage.
 *
 * Revision 1.37  2008/04/05 18:35:57  jps
 * Allow an optional third parameter to wdamage which specifies a
 * damage type, allowing the victim to resist.
 *
 * Revision 1.36  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.35  2008/04/02 03:24:44  myc
 * Removed unnecessary function declaration.
 *
 * Revision 1.34  2008/02/02 19:56:51  myc
 * script_driver now requires an address
 *
 * Revision 1.33  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.32  2008/01/17 19:23:07  myc
 * Modified wdoor, wat, and wteleport to accept room UIDs.
 *
 * Revision 1.31  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.30  2007/12/19 20:49:42  myc
 * send_to_zone is now in a header file.
 *
 * Revision 1.29  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.28  2007/08/30 19:42:46  jps
 * Cause *purge dg script commands to destroy all of a mobile's inventory
 * and equipment when purging mobs.
 *
 * Revision 1.27  2007/08/30 11:09:12  jps
 * Allow "\n" embedded in wdoor desc commands to insert newlines.
 *
 * Revision 1.26  2007/08/03 22:00:11  myc
 * Fixed some \r\n typoes in send_to_chars.
 *
 * Revision 1.25  2007/07/25 00:38:03  jps
 * Give send_to_zone a room to skip, and make it use virtual zone number.
 *
 * Revision 1.24  2007/07/24 23:34:00  jps
 * Add a parameter min_position to send_to_zone()
 *
 * Revision 1.23  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.22  2007/05/11 19:34:15  myc
 * Modified the quest command functions so they are thin wrappers for
 * perform_quest() in quest.c.  Error handling and messages should be
 * much better now.  Advance and rewind now accept another argument
 * specifying how many stages to advance or rewind.
 *
 * Revision 1.21  2007/04/17 23:59:16  myc
 * New trigger type: Load.  It goes off any time a mobile is loaded, whether
 * it be god command, zone command, or trigger command.
 *
 * Revision 1.20  2006/11/30 05:02:40  jps
 * Add w_run_room_trig
 *
 * Revision 1.19  2006/11/14 20:41:49  jps
 * Make trap damage regenerate normally.
 *
 * Revision 1.18  2006/11/12 02:31:01  jps
 * You become unmounted when magically moved to another room.
 *
 * Revision 1.17  2003/07/29 03:36:42  rsd
 * added (TRG) to the logging output of the log command
 * for ease of parsing.
 *
 * Revision 1.16  2003/07/24 22:22:30  jjl
 * Added the "log" command for mob, room, and object triggers.  Spits
 * whatever you want into the log.
 *
 * Revision 1.15  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.14  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.13  2001/07/25 06:59:02  mtp
 * modified logging to hopefully be a bit more helpful by specifying the
 * trigger id wherever possible. This does not apply to logging of mob trigs yet
 * as mobs use the same commands as players :-(
 *
 * Revision 1.12  2001/06/19 23:46:52  mtp
 * improved quest error messages
 *
 * Revision 1.11  2000/11/22 23:15:13  mtp
 * added ability to use quest command in here
 *
 * Revision 1.10  2000/11/21 04:42:14  rsd
 * Altered the comment header and added the early rlog
 * messages that were left out prior to the addition of
 * the $log$ string.
 *
 * Revision 1.9  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.8  2000/10/07 00:45:24  mtp
 * amount of hp affected in wheal and wdamage is limited to a signed short int (max hp is restrivcted)
 *
 * Revision 1.7  2000/03/27 22:16:48  mtp
 * added wheal which wasnt there before for some reason
 *
 * Revision 1.6  1999/11/20 00:28:32  rsd
 * Fixed a coders change that was checked in over the paladin
 * exp fix, thus deleting it.  The coder failed to diff in his
 * change so it fried the file.
 * It's fixed now
 *
 * Revision 1.4  1999/10/30 15:33:07  rsd
 * Jimmy coded alignement restrictions for paladins and exp
 * altered gain_exp() to reference victim alignment for check.
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 02:10:44  mud
 * Alterred comment header
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.58
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.57 2009/03/08 21:43:27 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/08 21:43:27 $                                           *
 *  $Revision: 1.57 $                                                      *
d393 2
a394 1
    gain_exp(ch, NULL, atoi(amount));
d736 4
@


1.57
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.56 2009/03/03 19:43:44 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2009/03/03 19:43:44 $                                           *
 *  $Revision: 1.56 $                                                      *
d42 1
d735 3
@


1.56
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.55 2008/09/02 06:52:30 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/09/02 06:52:30 $                                           *
 *  $Revision: 1.55 $                                                      *
d41 1
d734 3
@


1.55
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.54 2008/09/01 23:47:49 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/09/01 23:47:49 $                                           *
 *  $Revision: 1.54 $                                                      *
a43 1
char_data *get_char_by_room(room_data *room, char *name);
a44 1
obj_data *get_obj_by_room(room_data *room, char *name);
d47 1
d154 1
a154 1
  if ((ch = get_char_by_room(room, buf)))
d324 1
a324 1
    if ((ch = get_char_by_room(room, arg1))) {
d363 1
a363 1
      if ((ch = get_char_by_room(room, arg1)))
d390 1
a390 1
  if ((ch = get_char_by_room(room, name)))
d423 2
a424 2
  if (!(ch = get_char_by_room(room, arg))) {
    if ((obj = get_obj_by_room(room, arg))) {
d503 1
a503 1
  if ((ch = get_char_by_room(room, name))) {
d533 1
a533 1
  ch = get_char_by_room(room, name);
d648 1
a648 1
  if (!(ch = get_char_by_room(room, arg))) {
d733 3
@


1.54
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.53 2008/09/01 22:15:59 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/09/01 22:15:59 $                                           *
 *  $Revision: 1.53 $                                                      *
d40 1
d734 3
@


1.53
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.52 2008/08/26 04:39:21 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/08/26 04:39:21 $                                           *
 *  $Revision: 1.52 $                                                      *
d39 1
a45 1
void dismount_char(struct char_data * ch);
d733 3
@


1.52
log
@Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.51 2008/08/26 03:42:01 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/08/26 03:42:01 $                                           *
 *  $Revision: 1.51 $                                                      *
d672 1
a672 1
  remove_player_from_game(ch, SAVE_WRENT);
d733 3
@


1.51
log
@More detailed error reporting for wzoneecho.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.50 2008/08/17 20:23:56 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/08/17 20:23:56 $                                           *
 *  $Revision: 1.50 $                                                      *
d168 1
a168 1
  int zone;
a175 1

a178 3
  } else if ((zone = real_zone(atoi(zone_name))) < 0) {
    sprintf(buf, "wzoneecho called for nonexistent zone %s", zone_name);
    wld_log(room, t, buf);
d180 8
a187 2
    sprintf(buf, "%s\r\n", msg);
    send_to_zone(buf, zone_table[zone].number, NOWHERE, STANCE_RESTING);
d733 3
@


1.50
log
@Use macro parse_direction
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.49 2008/07/27 05:50:34 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/07/27 05:50:34 $                                           *
 *  $Revision: 1.49 $                                                      *
d177 7
a183 4
  else if ((zone = real_zone(atoi(zone_name))) < 0)
    wld_log(room, t, "wzoneecho called for nonexistent zone");

  else {
d731 3
@


1.49
log
@Include players.h header file.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.48 2008/07/27 05:30:45 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/07/27 05:30:45 $                                           *
 *  $Revision: 1.48 $                                                      *
d220 1
a220 1
  if ((dir = searchblock(direction, dirs, FALSE)) == -1) {
d728 3
@


1.48
log
@Using remove_player_from_game function for rent trigger.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.47 2008/07/27 01:33:22 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/07/27 01:33:22 $                                           *
 *  $Revision: 1.47 $                                                      *
d38 1
d728 3
@


1.47
log
@Added room vnum to trigger-rented message.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.46 2008/07/07 05:42:18 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/07/07 05:42:18 $                                           *
 *  $Revision: 1.46 $                                                      *
d662 1
a662 2
  save_objects(ch, SAVE_RENT);
  sprintf(buf, "%s rented by trigger %d in %s (%d).", GET_NAME(ch), 
d666 1
a666 3
  GET_LOADROOM(ch) = world[ch->in_room].vnum;
  save_quests(ch);
  extract_char(ch); /* calls save_player */
d727 3
@


1.46
log
@Added 'wrent' command.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.45 2008/06/19 18:53:12 myc Exp $
d8 2
a9 2
 *  $Date: 2008/06/19 18:53:12 $                                           *
 *  $Revision: 1.45 $                                                      *
d663 3
a665 2
  sprintf(buf, "%s rented by trigger %d at %s.", GET_NAME(ch), 
          GET_TRIG_VNUM(t), world[ch->in_room].name);
d730 3
@


1.45
log
@Now using real_zone() from olc.c.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.44 2008/05/18 05:18:06 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/05/18 05:18:06 $                                           *
 *  $Revision: 1.44 $                                                      *
d37 1
d629 42
d688 1
d729 3
@


1.44
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.43 2008/05/17 04:32:25 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/17 04:32:25 $                                           *
 *  $Revision: 1.43 $                                                      *
d36 1
a163 12
static int real_zone(int number)
{
  int counter;

  for (counter = 0; counter <= top_of_zone_table; counter++)
    if ((number >= (zone_table[counter].number * 100)) &&
        (number <= (zone_table[counter].top)))
      return counter;

  return -1;
}

d685 4
@


1.43
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.42 2008/05/14 05:10:06 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/14 05:10:06 $                                           *
 *  $Revision: 1.42 $                                                      *
d71 1
a71 1
  sprintf(buf, "(TRG)(room %d): %s", room->number, msg);
d313 1
a313 1
    if (world[target].number == room->number) {
d466 1
a466 1
    if( (rnum = real_room(room->number)) == NOWHERE) {
d480 1
a480 1
    if( (rnum = real_room(room->number)) == NOWHERE) {
d696 3
@


1.42
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.41 2008/05/11 05:48:55 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/11 05:48:55 $                                           *
 *  $Revision: 1.41 $                                                      *
d35 1
d109 1
a109 1
    struct room_direction_data *exit;
d111 1
a111 1
    if ((exit = room->dir_option[door]) && (exit->to_room != NOWHERE) &&
d201 1
a201 1
  struct room_direction_data *exit;
d239 1
a239 1
  exit = rm->dir_option[dir];
d249 1
a249 1
      rm->dir_option[dir] = NULL;
d255 2
a256 2
      CREATE(exit, struct room_direction_data, 1);
      rm->dir_option[dir] = exit;
d696 3
@


1.41
log
@Calling alter_hit() which also takes care of position changes.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.40 2008/04/07 03:02:54 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/07 03:02:54 $                                           *
 *  $Revision: 1.40 $                                                      *
d511 1
a511 1
    alter_hit(ch, NULL, -dam, TRUE);
d695 3
@


1.40
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.39 2008/04/05 20:42:21 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 20:42:21 $                                           *
 *  $Revision: 1.39 $                                                      *
d34 1
d511 1
a511 6
    if ((GET_HIT(ch) + dam) < GET_MAX_HIT(ch))
            GET_HIT(ch) += dam;
    else
        GET_HIT(ch) = GET_MAX_HIT(ch);

    update_pos(ch);
d695 4
@


1.39
log
@wdamage sets an event to do damage rather than doing it itself.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.38 2008/04/05 19:43:46 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 19:43:46 $                                           *
 *  $Revision: 1.38 $                                                      *
d189 1
a189 1
    send_to_zone(buf, zone_table[zone].number, NOWHERE, POS_RESTING);
d699 3
@


1.38
log
@Set damdone to the damage done by wdamage. Don't send any messages
when someone receives 0 damage.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.37 2008/04/05 18:35:57 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 18:35:57 $                                           *
 *  $Revision: 1.37 $                                                      *
d33 1
a562 1
  alter_hit(ch, dam, TRUE);
d564 1
a564 37
  update_pos(ch);
  switch (GET_POS(ch)) {
  case POS_MORTALLYW:
    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
    break;
  case POS_INCAP:
    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    break;
  case POS_STUNNED:
    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    break;
  case POS_DEAD:
    death_mtrigger (ch, (char_data *)NULL );        /* allow mob killed by wdamage to run death trigger */
    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You are dead!  Sorry...\r\n", ch);
    break;

  default:                        /* >= POSITION SLEEPING */
    if (dam > (GET_MAX_HIT(ch) >> 2))
      act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
      sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
              CLRLV(ch, FRED, C_SPR), CLRLV(ch, ANRM, C_SPR));
      send_to_char(buf2, ch);
    }
  }
  if (GET_POS(ch) == POS_DEAD) {
    if (!IS_NPC(ch)) {
      sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
              world[ch->in_room].name);
      mudlog(buf2, BRF, 0, TRUE);
    }
    die(ch, NULL);
  }
d699 4
@


1.37
log
@Allow an optional third parameter to wdamage which specifies a
damage type, allowing the victim to resist.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.36 2008/04/03 02:02:05 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/04/03 02:02:05 $                                           *
 *  $Revision: 1.36 $                                                      *
d525 2
d536 2
a537 2
  if (dam > 32767 )
          dam = 32767;        /* hitpoint is a short signed int */
d545 1
a545 4
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("Being a god, you carefully avoid a trap.\r\n", ch);
    return;
  }
d559 1
a559 5
    if (!dam) {
      send_to_char("You are unaffected by the trap.\r\n", ch);
      act("$n is unharmed.", TRUE, ch, 0, 0, TO_ROOM);
      return;
    }
d563 1
d735 4
@


1.36
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.35 2008/04/02 03:24:44 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/04/02 03:24:44 $                                           *
 *  $Revision: 1.35 $                                                      *
d32 1
d51 1
a51 1
       int	subcmd;
d65 1
a65 1
  
d67 1
a67 1
  
d79 1
a79 1
  
d97 1
a97 1
  
d99 1
a99 1
  
d104 1
a104 1
  
d107 1
a107 1
    
d109 1
a109 1
	room != &world[exit->to_room])
d118 2
a119 2
  
  if (!*argument) 
d121 2
a122 2
  
  else 
d131 1
a131 1
  
d133 1
a133 1
  
d139 1
a139 1
  
d141 1
a141 1
  
d147 1
a147 1
  
d151 1
a151 1
	sub_write(msg, ch, TRUE, TO_CHAR);
d153 1
a153 1
	sub_write(msg, ch, TRUE, TO_ROOM);
d155 1
a155 1
  
d163 1
a163 1
  
d166 1
a166 1
	(number <= (zone_table[counter].top)))
d168 1
a168 1
  
d176 1
a176 1
  
d179 1
a179 1
  
d182 1
a182 1
  
d185 2
a186 2
  
  else { 
d200 1
a200 1
  
d210 2
a211 2
  
  
d215 1
a215 1
  
d220 1
a220 1
  
d225 1
a225 1
  
d230 1
a230 1
  
d235 1
a235 1
  
d237 1
a237 1
  
d242 1
a242 1
	free(exit->general_description);
d244 1
a244 1
	free(exit->keyword);
d249 1
a249 1
  
d253 1
a253 1
      rm->dir_option[dir] = exit; 
d255 1
a255 1
    
d276 1
a276 1
	free(exit->keyword);
d282 1
a282 1
	exit->to_room = to_room;
d284 1
a284 1
	wld_log(room, t, "wdoor: invalid door target");
d296 1
a296 1
  
d298 1
a298 1
  
d303 1
a303 1
  
d305 2
a306 2
  
  if (target == NOWHERE) 
d308 1
a308 1
  
d314 1
a314 1
    
d317 1
a317 1
	
d323 1
a323 1
  
d330 1
a330 1
      
d341 1
a341 1
  
d343 1
a343 1
  
d348 1
a348 1
  
d352 8
a359 8
	{
	  next_ch = ch->next_in_room;
	  
	  if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
	      command_interpreter(ch, line);
	    }
	}
d361 1
a361 1
  
d365 7
a371 7
	{
	  if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
	      command_interpreter(ch, line);
	    }
	}
      
d373 1
a373 1
	wld_log(room, t, "wforce: no target found");
d383 1
a383 1
  
d385 1
a385 1
  
d390 2
a391 2
  
  if ((ch = get_char_by_room(room, name))) 
d406 1
a406 1
  
d408 1
a408 1
  
d415 1
a415 1
    
d420 1
a420 1
    
d423 1
a423 1
  
d427 1
a427 1
    } else 
d429 1
a429 1
    
d432 1
a432 1
  
d437 1
a437 1
  
d449 2
a450 2
  
  
d452 1
a452 1
  
d457 1
a457 1
  
d470 1
a470 1
  
d481 1
a481 1
    obj_to_room(object, rnum); 
d483 1
a483 1
  
d492 1
a492 1
  
d494 1
a494 1
  
d499 1
a499 1
  
d502 2
a503 2
	  dam = 32767;	/* hitpoint is a short signed int */
  
d510 1
a510 1
    	GET_HIT(ch) += dam;
d513 1
a513 1
    
d521 2
a522 2
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
  int dam = 0;
d524 4
a527 3
  
  two_arguments(argument, name, amount);
  
d532 1
a532 1
  
d535 22
a556 5
	  dam = 32767;	/* hitpoint is a short signed int */
  
  if ((ch = get_char_by_room(room, name))) {
    if (GET_LEVEL(ch)>=LVL_IMMORT) {
      send_to_char("Being a god, you carefully avoid a trap.\r\n", ch);
d559 5
a563 29
    alter_hit(ch, dam, TRUE);
    update_pos(ch);
    switch (GET_POS(ch)) {
    case POS_MORTALLYW:
      act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
      break;
    case POS_INCAP:
      act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
      break;
    case POS_STUNNED:
      act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
      break;
    case POS_DEAD:
      death_mtrigger (ch, (char_data *)NULL );	/* allow mob killed by wdamage to run death trigger */
      act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You are dead!  Sorry...\r\n", ch);
      break;
      
    default:			/* >= POSITION SLEEPING */
      if (dam > (GET_MAX_HIT(ch) >> 2))
	act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
      if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		CLRLV(ch, FRED, C_SPR), CLRLV(ch, ANRM, C_SPR));
	send_to_char(buf2, ch);
      }
d565 37
a601 7
    if (GET_POS(ch) == POS_DEAD) {
      if (!IS_NPC(ch)) {
	sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
		world[ch->in_room].name);
	mudlog(buf2, BRF, 0, TRUE);
      }
      die(ch, NULL);
d603 1
a604 2
  else
    wld_log(room, t, "wdamage: target not found");
d622 1
a622 1
  
d624 1
a624 1
  
d626 1
a626 1
  
d678 1
a678 1
WCMD(do_wld_log) {  
d684 1
a684 1
  
d700 1
a700 1
  { "log"        , do_wld_log   , 0 }, 
d702 1
a702 1
  { "\n", 0, 0 }	/* this must be last */
d713 1
a713 1
  
d715 1
a715 1
  
d719 1
a719 1
  
d721 2
a722 2
  
  
d728 1
a728 1
  
d733 1
a733 1
    ((*wld_cmd_info[cmd].command_pointer) 
d739 3
@


1.35
log
@Removed unnecessary function declaration.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.34 2008/02/02 19:56:51 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/02 19:56:51 $                                           *
 *  $Revision: 1.34 $                                                      *
d566 1
a566 1
		CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
d715 3
@


1.34
log
@script_driver now requires an address
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.33 2008/01/29 21:02:31 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/29 21:02:31 $                                           *
 *  $Revision: 1.33 $                                                      *
a32 1
void die(struct char_data * ch, struct char_data * killer);
d715 3
@


1.33
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.32 2008/01/17 19:23:07 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 19:23:07 $                                           *
 *  $Revision: 1.32 $                                                      *
d40 1
a40 1
int script_driver(void *go, trig_data *trig, int type, int mode);
d647 1
a647 1
      script_driver(room, tr, WLD_TRIGGER, TRIG_NEW);
d716 4
@


1.32
log
@Modified wdoor, wat, and wteleport to accept room UIDs.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.31 2008/01/10 05:39:43 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/10 05:39:43 $                                           *
 *  $Revision: 1.31 $                                                      *
d31 1
a31 6

extern struct index_data **trig_index;
extern struct room_data *world;
extern char *dirs[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;
d226 1
a226 1
  if ((dir = searchblock(direction, (char **)dirs, FALSE)) == -1) {
d231 1
a231 1
  if ((fd = searchblock(field, (char **)door_field, FALSE)) == -1) {
d716 3
@


1.31
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.30 2007/12/19 20:49:42 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/12/19 20:49:42 $                                           *
 *  $Revision: 1.30 $                                                      *
d46 1
d299 1
a299 1
  int target, nr;
d309 1
a309 2
  nr = atoi(arg2);
  target = real_room(nr);
d315 1
a315 1
    if (nr == room->number) {
d320 2
a321 3
    for (ch = room->people; ch; ch = next_ch)
      {
	next_ch = ch->next_in_room;
d323 4
a326 4
   dismount_char(ch);
	char_from_room(ch);
	char_to_room(ch, target);
      }
d329 6
a334 7
  else
    {
      if ((ch = get_char_by_room(room, arg1))) {
         dismount_char(ch);
	char_from_room(ch);
	char_to_room(ch, target);
      }
d336 3
a338 3
      else
	wld_log(room, t, "wteleport: no target found");
    }
a602 1
  int vnum = 0;    
d609 1
a609 1
  if (!*location || !*arg2 || !isdigit(*location)) {
d613 2
a614 2
  vnum = atoi(location);
  if (NOWHERE == real_room(vnum)) {
a618 2
  /* Changed by Matt Lyveden 11/17/99, added real_room reference */
  r2 = &world[real_room(vnum)];
d721 4
@


1.30
log
@send_to_zone is now in a header file.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.29 2007/10/17 17:18:04 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/10/17 17:18:04 $                                           *
 *  $Revision: 1.29 $                                                      *
d548 1
a548 1
    alter_hit(ch, dam, 2);
d726 3
@


1.29
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.28 2007/08/30 19:42:46 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/08/30 19:42:46 $                                           *
 *  $Revision: 1.28 $                                                      *
a39 1
void send_to_zone(char *messg, int zone_vnum, int skip_room, int min_position);
d726 4
@


1.28
log
@Cause *purge dg script commands to destroy all of a mobile's inventory
and equipment when purging mobs.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.27 2007/08/30 11:09:12 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/30 11:09:12 $                                           *
 *  $Revision: 1.27 $                                                      *
d231 1
a231 1
  if ((dir = search_block(direction, (char **)dirs, FALSE)) == -1) {
d236 1
a236 1
  if ((fd = search_block(field, (char **)door_field, FALSE)) == -1) {
d727 4
@


1.27
log
@Allow "\n" embedded in wdoor desc commands to insert newlines.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.26 2007/08/03 22:00:11 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/08/03 22:00:11 $                                           *
 *  $Revision: 1.26 $                                                      *
d421 1
a421 1
	extract_char(ch);
d446 1
a446 1
  extract_char(ch);
d727 3
@


1.26
log
@Fixed some \r\n typoes in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.25 2007/07/25 00:38:03 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/07/25 00:38:03 $                                           *
 *  $Revision: 1.25 $                                                      *
d201 1
a201 1
  char field[MAX_INPUT_LENGTH], *value;
d264 6
a269 3
	free(exit->general_description);
      CREATE(exit->general_description, char, strlen(value) + 3);
      strcpy(exit->general_description, value);
d271 1
d727 3
@


1.25
log
@Give send_to_zone a room to skip, and make it use virtual zone number.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.24 2007/07/24 23:34:00 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/07/24 23:34:00 $                                           *
 *  $Revision: 1.24 $                                                      *
d510 1
a510 1
      send_to_char("Being a god, you don't need healing.", ch);
d542 1
a542 1
      send_to_char("Being a god, you carefully avoid a trap.", ch);
d723 3
@


1.24
log
@Add a parameter min_position to send_to_zone()
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.23 2007/07/24 23:02:52 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/07/24 23:02:52 $                                           *
 *  $Revision: 1.23 $                                                      *
d40 1
a40 1
void send_to_zone(char *messg, int zone_rnum, int min_position);
d193 1
a193 1
    send_to_zone(buf, zone, POS_RESTING);
d723 3
@


1.23
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.22 2007/05/11 19:34:15 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/05/11 19:34:15 $                                           *
 *  $Revision: 1.22 $                                                      *
d40 1
a40 1
void send_to_zone(char *messg, int zone_rnum);
d193 1
a193 1
    send_to_zone(buf, zone);
d723 3
@


1.22
log
@Modified the quest command functions so they are thin wrappers for
perform_quest() in quest.c.  Error handling and messages should be
much better now.  Advance and rewind now accept another argument
specifying how many stages to advance or rewind.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.21 2007/04/17 23:59:16 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/04/17 23:59:16 $                                           *
 *  $Revision: 1.21 $                                                      *
d189 1
a189 1
    wld_log(room, t, "wzoneecho called for nonexistant zone");
d723 6
@


1.21
log
@New trigger type: Load.  It goes off any time a mobile is loaded, whether
it be god command, zone command, or trigger command.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.20 2006/11/30 05:02:40 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                       *
 *  $Date: 2006/11/30 05:02:40 $                                           *
 *  $Revision: 1.20 $                                                       *
d597 2
a598 96
  char arg[MAX_INPUT_LENGTH];
  char qcmd[12];	/*longest command is complete (8chars)*/
  char * qname;
  char subclass[25];
  char variable[21]; 
  char value[21]; 

  struct char_data * vict;
  int retc;
  extern struct char_data *character_list;

  argument = one_argument(argument, qcmd);
  if (strlen(qcmd) == 0)
	  return;

  argument = one_argument(argument,arg);
  if (strlen(arg) == 0)
	  return;
  CREATE(qname,char,strlen(arg) +1);
  sprintf(qname,"%s",arg);
  argument = one_argument(argument,arg);
  if (strlen(arg) == 0)
  {
	  free(qname);
	  return;
  }

  /*
   * need to find the person this command is goig to affect
   */
  for (vict = character_list; vict; vict = vict->next)
    if (!IS_NPC(vict) && !str_cmp(vict->player.name, arg))
	    break;
  if (vict)	/* if we ran out of chars then vict is null*/
  {
	  /* based on command, run the appropriate procedure */
	  if (!strn_cmp(qcmd,"complete",strlen(qcmd)))
		  retc = quest_complete(qname,vict);
	  else if (!strn_cmp(qcmd,"fail",strlen(qcmd)))
		  retc = quest_fail(qname,vict);
	  else if (!strn_cmp(qcmd, "variable", strlen(qcmd)))
	    {
	      argument = one_argument(argument, variable);
              argument = one_argument(argument, value);
              retc = set_quest_variable(qname, vict, variable, value);

	    }
	  else if (!strn_cmp(qcmd,"start",strlen(qcmd)))
	  {
		  argument = one_argument(argument,subclass);
		  retc = quest_start(qname,vict,subclass);
		  if (retc < 1)
		  {
			  switch (retc)
			  {
			  case -3:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to start second subclass quest for %s",room->name,room->number,GET_NAME(vict));
				  mudlog(buf ,NRM, LVL_GOD, TRUE);
				  break;

			  case -4:
				  sprintf(buf,"QUEST ERROR:Attempt by %s(%d) to start subclass with bad start or dest class in quest %s",room->name,room->number,qname);
				  mudlog(buf, NRM, LVL_GOD, TRUE);
				  break;
			  case -7:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to start subclass quest without specifying subclass",room->name,room->number);
				  mudlog(buf,NRM,LVL_GOD, TRUE);
				  break;
			  }
		  }
	  }
	  else if (!strn_cmp(qcmd,"advance",strlen(qcmd)))
	  {
		  retc = quest_advance(qname,vict);
		  if (retc < 0)
		  {
			  switch (retc)
			  {
				  /* note: only send to char if quest starter was a mob*/
			  case -1:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to advance from final stage in quest %s\r\n",room->name,room->number,qname);
				  mudlog(buf,NRM,LVL_GOD,TRUE);
				  break;
			  case -2:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to advance failed quest %s\n",room->name,room->number,qname);
				  mudlog(buf ,NRM, LVL_GOD, TRUE);
				  break;
			  }
		  }
	  }
	  else
	  {
		free(qname);
	  	return;
	  }
  }
a599 2
  free(qname);
}
d723 4
@


1.20
log
@Add w_run_room_trig
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.19 2006/11/14 20:41:49 jps Exp jps $
d8 2
a9 2
 *  $Date: 2006/11/14 20:41:49 $                                           *
 *  $Revision: 1.19 $                                                       *
d472 1
d819 3
@


1.19
log
@Make trap damage regenerate normally.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.18 2006/11/12 02:31:01 jps Exp jps $
d8 2
a9 2
 *  $Date: 2006/11/12 02:31:01 $                                           *
 *  $Revision: 1.18 $                                                       *
d32 1
d46 1
d719 38
d780 1
d818 3
@


1.18
log
@You become unmounted when magically moved to another room.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.17 2003/07/29 03:36:42 rsd Exp jps $
d7 3
a9 3
 *  $Author: rsd $                                                       *
 *  $Date: 2003/07/29 03:36:42 $                                           *
 *  $Revision: 1.17 $                                                       *
d542 1
a542 2
    GET_HIT(ch) -= dam;
    
d777 3
@


1.17
log
@added (TRG) to the logging output of the log command
for ease of parsing.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.16 2003/07/24 22:22:30 jjl Exp $
d7 3
a9 3
 *  $Author: jjl $                                                       *
 *  $Date: 2003/07/24 22:22:30 $                                           *
 *  $Revision: 1.16 $                                                       *
d44 1
d319 1
d328 1
d778 4
@


1.16
log
@Added the "log" command for mob, room, and object triggers.  Spits
whatever you want into the log.
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.15 2002/09/19 01:07:53 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/19 01:07:53 $                                           *
 *  $Revision: 1.15 $                                                       *
d70 1
a70 1
  sprintf(buf, "(room %d): %s", room->number, msg);
d775 4
@


1.15
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.14 2002/09/13 02:32:10 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/13 02:32:10 $                                           *
 *  $Revision: 1.14 $                                                       *
d715 4
d733 5
a737 4
  { "wdamage"    , do_wdamage,    0 },
  { "wheal"    , do_wheal,    0 },
  { "wat"        , do_wat,        0 },
  { "quest"        , do_wld_quest,        0 },
d775 3
@


1.14
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_wldcmd.c,v 1.13 2001/07/25 06:59:02 mtp Exp $
d7 3
a9 3
 *  $Author: mtp $                                                       *
 *  $Date: 2001/07/25 06:59:02 $                                           *
 *  $Revision: 1.13 $                                                       *
d596 3
d632 7
d770 3
@


1.13
log
@modified logging to hopefully be a bit more helpful by specifying the
trigger id wherever possible. This does not apply to logging of mob trigs yet
as mobs use the same commands as players :-(
@
text
@d1 3
a3 1
// $Id: dg_wldcmd.c,v 1.11 2000/11/22 23:15:13 mtp Exp $
d8 2
a9 2
 *  $Date: 2000/11/22 23:15:13 $                                           *
 *  $Revision: 1.11 $                                                       *
d758 50
a807 43
// $Log: dg_wldcmd.c,v $
// Revision 1.12  2001/06/19 23:46:52  mtp
// improved quest error messages
//
// Revision 1.11  2000/11/22 23:15:13  mtp
// added ability to use quest command in here
//
// Revision 1.10  2000/11/21 04:42:14  rsd
// Altered the comment header and added the early rlog
// messages that were left out prior to the addition of
// the $log$ string.
//
// Revision 1.9  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.8  2000/10/07 00:45:24  mtp
// amount of hp affected in wheal and wdamage is limited to a signed short int (max hp is restrivcted)
//
// Revision 1.7  2000/03/27 22:16:48  mtp
// added wheal which wasnt there before for some reason
//
// Revision 1.6  1999/11/20 00:28:32  rsd
// Fixed a coders change that was checked in over the paladin
// exp fix, thus deleting it.  The coder failed to diff in his
// change so it fried the file.
// It's fixed now
//
// Revision 1.4  1999/10/30 15:33:07  rsd
// Jimmy coded alignement restrictions for paladins and exp
// altered gain_exp() to reference victim alignment for check.
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 02:10:44  mud
// Alterred comment header
// Indented file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.12
log
@improved quest error messages
@
text
@d44 1
a44 1
    void (name)(room_data *room, char *argument, int cmd, int subcmd)
d50 1
a50 1
       (room_data *room, char *argument, int cmd, int subcmd);
d62 1
a62 1
void wld_log(room_data *room, char *msg)
d66 1
a66 1
  void script_log(char *msg);
d68 2
a69 2
  sprintf(buf, "Wld (room %d): %s", room->number, msg);
  script_log(buf);
d101 1
a101 1
    wld_log(room, "wasound called with no argument");
d120 1
a120 1
    wld_log(room, "wecho called with no args");
d136 1
a136 1
      wld_log(room, "wsend called with no args");
d144 1
a144 1
      wld_log(room, "wsend called without a message");
d157 1
a157 1
    wld_log(room, "no target found for wsend");
d181 1
a181 1
    wld_log(room, "wzoneecho called with too few args");
d184 1
a184 1
    wld_log(room, "wzoneecho called for nonexistant zone");
d217 1
a217 1
    wld_log(room, "wdoor called with too few args");
d222 1
a222 1
    wld_log(room, "wdoor: invalid target");
d227 1
a227 1
    wld_log(room, "wdoor: invalid direction");
d232 1
a232 1
    wld_log(room, "wdoor: invalid field");
d280 1
a280 1
	wld_log(room, "wdoor: invalid door target");
d296 1
a296 1
    wld_log(room, "wteleport called with too few args");
d304 1
a304 1
    wld_log(room, "wteleport target is an invalid room");
d308 1
a308 1
      wld_log(room, "wteleport all target is itself");
d329 1
a329 1
	wld_log(room, "wteleport: no target found");
d342 1
a342 1
    wld_log(room, "wforce called with too few args");
d370 1
a370 1
	wld_log(room, "wforce: no target found");
d384 1
a384 1
    wld_log(room, "wexp: too few arguments");
d391 1
a391 1
    wld_log(room, "wexp: target not found");
d425 1
a425 1
      wld_log(room, "wpurge: bad argument");
d431 1
a431 1
    wld_log(room, "wpurge: purging a PC");
d451 1
a451 1
    wld_log(room, "wload: bad syntax");
d457 1
a457 1
      wld_log(room, "wload: bad mob vnum");
d461 1
a461 1
      wld_log(room, "wload: room is NOWHERE");
d469 1
a469 1
      wld_log(room, "wload: bad object vnum");
d474 1
a474 1
      wld_log(room, "wload: room is NOWHERE");
d481 1
a481 1
    wld_log(room, "wload: bad type");
d492 1
a492 1
    wld_log(room, "wheal: bad syntax");
d513 1
a513 1
    wld_log(room, "wheal: target not found");
d524 1
a524 1
    wld_log(room, "wdamage: bad syntax");
d578 1
a578 1
    wld_log(room, "wdamage: target not found");
d684 1
a684 1
  void wld_command_interpreter(room_data *room, char *argument);
d689 1
a689 1
    wld_log(room, "wat: bad syntax");
d694 1
a694 1
    wld_log(room, "wat: location not found");
d700 1
a700 1
  wld_command_interpreter(r2, arg2);
d728 1
a728 1
void wld_command_interpreter(room_data *room, char *argument)
d750 1
a750 1
    wld_log(room, buf2);
d753 1
a753 1
     (room, line, cmd, wld_cmd_info[cmd].subcmd));
d757 3
@


1.11
log
@added ability to use quest command in here
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.10 2000/11/21 04:42:14 rsd Exp $
d5 3
a7 3
 *  $Author: rsd $                                                       *
 *  $Date: 2000/11/21 04:42:14 $                                           *
 *  $Revision: 1.10 $                                                       *
d631 19
d652 1
d654 16
d757 3
@


1.10
log
@Altered the comment header and added the early rlog
messages that were left out prior to the addition of
the $log$ string.
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.9 2000/11/03 17:28:33 jimmy Exp $
d5 3
a7 3
 *  $Author: jimmy $                                                       *
 *  $Date: 2000/11/03 17:28:33 $                                           *
 *  $Revision: 1.9 $                                                       *
d28 1
d581 62
d684 1
d721 5
@


1.9
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.8 2000/10/07 00:45:24 mtp Exp $
d3 5
a7 3
 *  File: dg_wldcmd.c                                 NOW Part of FieryMUD *
 *  Usage: contains the command_interpreter for rooms,                     *
 *         room commands.                                                  *
d9 6
a14 4
 *  By: Unknown                                                            *
 *  $Author: mtp $                                                       *
 *  $Date: 2000/10/07 00:45:24 $                                           *
 *  $Revision: 1.8 $                                                       *
a19 1

d655 1
d657 5
d680 7
@


1.8
log
@amount of hp affected in wheal and wdamage is limited to a signed short int (max hp is restrivcted)
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.7 2000/03/27 22:16:48 mtp Exp mtp $
d9 2
a10 2
 *  $Date: 2000/03/27 22:16:48 $                                           *
 *  $Revision: 1.7 $                                                       *
d439 1
a439 1
  int number = 0;
d456 5
a460 1
    char_to_room(mob, real_room(room->number));
d468 6
a473 2
    
    obj_to_room(object, real_room(room->number)); 
d653 3
@


1.7
log
@added wheal which wasnt there before for some reason
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.6 1999/11/20 00:28:32 rsd Exp $
d8 3
a10 3
 *  $Author: rsd $                                                       *
 *  $Date: 1999/11/20 00:28:32 $                                           *
 *  $Revision: 1.6 $                                                       *
d485 2
d517 2
d542 1
d645 3
@


1.6
log
@Fixed a coders change that was checked in over the paladin
exp fix, thus deleting it.  The coder failed to diff in his
change so it fried the file.
It's fixed now
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.4 1999/10/30 15:33:07 rsd Exp $
d9 2
a10 2
 *  $Date: 1999/10/30 15:33:07 $                                           *
 *  $Revision: 1.4 $                                                       *
d472 30
a521 4
    if (dam < 0) {
      send_to_char("You feel rejuvinated.\r\n", ch);
      return;
    }
d603 1
d640 6
@


1.5
log
@fixed 'wat' command
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.4 1999/10/30 15:33:07 rsd Exp mtp $
d385 1
a385 1
    gain_exp(ch, atoi(amount));
d556 2
a557 1
  
@


1.4
log
@Jimmy coded alignement restrictions for paladins and exp
altered gain_exp() to reference victim alignment for check.
@
text
@d1 1
a1 1
// $Id: dg_wldcmd.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d8 3
a10 3
 *  $Author: jimmy $                                                       *
 *  $Date: 1999/09/05 07:00:39 $                                           *
 *  $Revision: 1.3 $                                                       *
d385 1
a385 1
    gain_exp(ch, NULL, atoi(amount));
d557 1
a557 1
  r2 = &world[vnum];
d612 4
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d8 3
a10 3
 *  $Author: mud $                                                         *
 *  $Date: 1999/01/31 02:10:44 $                                           *
 *  $Revision: 1.2 $                                                       *
d385 1
a385 1
    gain_exp(ch, atoi(amount));
d611 4
a614 1
// $Log$
@


1.2
log
@Alterred comment header
Indented file
@
text
@d1 1
d9 2
a10 2
 *  $Date: 1999/01/29 01:23:30 $                                           *
 *  $Revision: 1.1 $                                                       *
d611 1
@


1.1
log
@Initial revision
@
text
@d1 10
a10 10
/**************************************************************************
*  File: wldcmd.c                                                         *
*  Usage: contains the command_interpreter for rooms,                     *
*         room commands.                                                  *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 03:27:07 $
*  $Revision: 3.12 $
**************************************************************************/
d43 4
a46 4
    char *command;
    void (*command_pointer)
           (room_data *room, char *argument, int cmd, int subcmd);
    int	subcmd;
d59 6
a64 6
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Wld (room %d): %s", room->number, msg);
    script_log(buf);
d71 11
a81 11
    /* no one is in the room */
    if (!room->people)
	return;

    /*
     * since you can't use act(..., TO_ROOM) for an room, send it
     * TO_ROOM and TO_CHAR for some char in the room.
     * (just dont use $n or you might get strange results)
     */
    act(str, FALSE, room->people, 0, 0, TO_ROOM);
    act(str, FALSE, room->people, 0, 0, TO_CHAR);
d91 8
a98 8
    int  door;
 
    skip_spaces(&argument);

    if (!*argument) {
	wld_log(room, "wasound called with no argument");
	return;
    }
d100 7
a106 7
    for (door = 0; door < NUM_OF_DIRS; door++) {
	struct room_direction_data *exit;
	
	if ((exit = room->dir_option[door]) && (exit->to_room != NOWHERE) &&
	    room != &world[exit->to_room])
	    act_to_room(argument, &world[exit->to_room]);
    }
d112 7
a118 7
    skip_spaces(&argument);

    if (!*argument) 
	wld_log(room, "wecho called with no args");

    else 
	act_to_room(argument, room);
d124 4
a127 2
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
d129 1
a129 3
    msg = any_one_arg(argument, buf);

    if (!*buf)
d131 2
a132 2
	wld_log(room, "wsend called with no args");
	return;
d134 4
a137 4

    skip_spaces(&msg);

    if (!*msg)
d139 2
a140 2
	wld_log(room, "wsend called without a message");
	return;
d142 2
a143 2

    if ((ch = get_char_by_room(room, buf)))
d145 4
a148 4
	if (subcmd == SCMD_WSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_WECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
d150 3
a152 3

    else
	wld_log(room, "no target found for wsend");
d158 1
a158 1
      
d161 1
a161 1
      (number <= (zone_table[counter].top)))
d163 1
a163 1
 
d169 5
a173 2
    int zone;
    char zone_name[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH], *msg;
d175 10
a184 13
    msg = any_one_arg(argument, zone_name);
    skip_spaces(&msg);

    if (!*zone_name || !*msg)
	wld_log(room, "wzoneecho called with too few args");

    else if ((zone = real_zone(atoi(zone_name))) < 0)
	wld_log(room, "wzoneecho called for nonexistant zone");

    else { 
	sprintf(buf, "%s\r\n", msg);
	send_to_zone(buf, zone);
    }
d190 59
a248 29
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
	"purge",
	"description",
	"flags",
	"key",
	"name",
	"room",
	"\n"
    };


    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);

    if (!*target || !*direction || !*field) {
	wld_log(room, "wdoor called with too few args");
	return;
    }
  
    if ((rm = get_room(target)) == NULL) {
	wld_log(room, "wdoor: invalid target");
	return;
a249 30
  
    if ((dir = search_block(direction, (char **)dirs, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid direction");
	return;
    }

    if ((fd = search_block(field, (char **)door_field, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid field");
	return;
    }

    exit = rm->dir_option[dir];

    /* purge exit */
    if (fd == 0) {
	if (exit) {
	    if (exit->general_description)
		free(exit->general_description);
	    if (exit->keyword)
		free(exit->keyword);
	    free(exit);
	    rm->dir_option[dir] = NULL;
	}
    }

    else {
	if (!exit) {
	    CREATE(exit, struct room_direction_data, 1);
	    rm->dir_option[dir] = exit; 
	}
d251 26
a276 27
	switch (fd) {
	case 1:  /* description */
	    if (exit->general_description)
		free(exit->general_description);
	    CREATE(exit->general_description, char, strlen(value) + 3);
	    strcpy(exit->general_description, value);
	    strcat(exit->general_description, "\r\n");
	    break;
	case 2:  /* flags       */
	    exit->exit_info = (int)asciiflag_conv(value);
	    break;
	case 3:  /* key         */
	    exit->key = atoi(value);
	    break;
	case 4:  /* name        */
	    if (exit->keyword)
		free(exit->keyword);
	    CREATE(exit->keyword, char, strlen(value) + 1);
	    strcpy(exit->keyword, value);
	    break;
	case 5:  /* room        */
	    if ((to_room = real_room(atoi(value))) != NOWHERE)
		exit->to_room = to_room;
	    else
		wld_log(room, "wdoor: invalid door target");
	    break;
	}
d278 1
d284 21
a304 9
    char_data *ch, *next_ch;
    int target, nr;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2) {
	wld_log(room, "wteleport called with too few args");
	return;
d306 9
a314 6

    nr = atoi(arg2);
    target = real_room(nr);
  
    if (target == NOWHERE) 
	wld_log(room, "wteleport target is an invalid room");
d316 1
a316 16
    else if (!str_cmp(arg1, "all")) {
	if (nr == room->number) {
	    wld_log(room, "wteleport all target is itself");
	    return;
	}

	for (ch = room->people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;

	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    }
  
    else
d318 7
a324 7
	if ((ch = get_char_by_room(room, arg1))) {
	    char_from_room(ch);
	    char_to_room(ch, target);
	}
	
	else
	    wld_log(room, "wteleport: no target found");
d331 4
a334 4
    char_data *ch, *next_ch;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);
d336 4
a339 4
    if (!*arg1 || !*line) {
	wld_log(room, "wforce called with too few args");
	return;
    }
d341 1
a341 1
    if (!str_cmp(arg1, "all"))
d343 1
a343 1
	for (ch = room->people; ch; ch = next_ch)
d345 3
a347 3
	    next_ch = ch->next_in_room;
      
	    if (GET_LEVEL(ch)<LVL_IMMORT)
d349 1
a349 1
		command_interpreter(ch, line);
d354 1
a354 1
    else
d356 1
a356 1
	if ((ch = get_char_by_room(room, arg1)))
d358 1
a358 1
	    if (GET_LEVEL(ch)<LVL_IMMORT)
d360 1
a360 1
		command_interpreter(ch, line);
d363 3
a365 3
    
	else
	    wld_log(room, "wforce: no target found");
d373 16
a388 16
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
	wld_log(room, "wexp: too few arguments");
	return;
    }

    if ((ch = get_char_by_room(room, name))) 
	gain_exp(ch, atoi(amount));
    else {
	wld_log(room, "wexp: target not found");
	return;
    }
d395 12
a406 17
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *obj, *next_obj;

    one_argument(argument, arg);
  
    if (!*arg) {
	for (ch = room->people; ch; ch = next_ch ) {
	    next_ch = ch->next_in_room;
	    if (IS_NPC(ch))
		extract_char(ch);
	}
	
	for (obj = room->contents; obj; obj = next_obj ) {
	    next_obj = obj->next_content;
	    extract_obj(obj);
	}
d408 3
a410 1
	return;
d412 3
d416 5
a420 5
    if (!(ch = get_char_by_room(room, arg))) {
	if ((obj = get_obj_by_room(room, arg))) {
	    extract_obj(obj);
	} else 
	    wld_log(room, "wpurge: bad argument");
d422 7
a428 2
	return;
    }
d430 1
a430 6
    if (!IS_NPC(ch)) {
	wld_log(room, "wpurge: purging a PC");
	return;
    }
    
    extract_char(ch);
d437 25
a461 19
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;
  

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
	wld_log(room, "wload: bad syntax");
	return;
    }

    if (is_abbrev(arg1, "mob")) {
	if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad mob vnum");
	    return;
	}
	char_to_room(mob, real_room(room->number));
d463 3
d467 2
a468 11
    else if (is_abbrev(arg1, "obj")) {
	if ((object = read_object(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad object vnum");
	    return;
	}

	obj_to_room(object, real_room(room->number)); 
    }

    else
	wld_log(room, "wload: bad type");
d472 22
a493 9
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	wld_log(room, "wdamage: bad syntax");
	return;
d495 40
a534 53

    dam = atoi(amount);

    if ((ch = get_char_by_room(room, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being a god, you carefully avoid a trap.", ch);
	    return;
	}
        GET_HIT(ch) -= dam;
        if (dam < 0) {
          send_to_char("You feel rejuvinated.\r\n", ch);
          return;
        }

	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
    	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
    	    }
    	    die(ch, NULL);
	}
    }
    else
	wld_log(room, "wdamage: target not found");
d538 20
a557 20
    char location[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int vnum = 0;    
    room_data *r2;
 
    void wld_command_interpreter(room_data *room, char *argument);

    half_chop(argument, location, arg2);

    if (!*location || !*arg2 || !isdigit(*location)) {
	wld_log(room, "wat: bad syntax");
	return;
    }
    vnum = atoi(location);
    if (NOWHERE == real_room(vnum)) {
	wld_log(room, "wat: location not found");
	return;
    }

    r2 = &world[vnum];
    wld_command_interpreter(r2, arg2);
d561 16
a576 16
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */
    
    { "wasound"    , do_wasound   , 0 },
    { "wdoor"      , do_wdoor     , 0 },
    { "wecho"      , do_wecho     , 0 },
    { "wechoaround", do_wsend     , SCMD_WECHOAROUND },
    { "wexp"       , do_wexp      , 0 },
    { "wforce"     , do_wforce    , 0 },
    { "wload"      , do_wload     , 0 },
    { "wpurge"     , do_wpurge    , 0 },
    { "wsend"      , do_wsend     , SCMD_WSEND },
    { "wteleport"  , do_wteleport , 0 },
    { "wzoneecho"  , do_wzoneecho , 0 },
    { "wdamage"    , do_wdamage,    0 },
    { "wat"        , do_wat,        0 },
    { "\n", 0, 0 }	/* this must be last */
d585 2
a586 2
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
d588 1
a588 1
    skip_spaces(&argument);
d590 19
a608 19
    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg), cmd = 0;
	 *wld_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(wld_cmd_info[cmd].command, arg, length))
	    break;
  
    if (*wld_cmd_info[cmd].command == '\n') {
	sprintf(buf2, "Unknown world cmd: '%s'", argument);
	wld_log(room, buf2);
    } else
	((*wld_cmd_info[cmd].command_pointer) 
	 (room, line, cmd, wld_cmd_info[cmd].subcmd));
@
