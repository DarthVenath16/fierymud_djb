head	1.196;
access;
symbols;
locks; strict;
comment	@ * @;


1.196
date	2011.08.06.15.39.48;	author rsd;	state Exp;
branches;
next	1.195;

1.195
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.194;

1.194
date	2010.06.05.15.09.42;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2009.07.16.19.15.54;	author myc;	state Exp;
branches;
next	1.192;

1.192
date	2009.06.09.05.37.23;	author myc;	state Exp;
branches;
next	1.191;

1.191
date	2009.03.20.23.02.59;	author myc;	state Exp;
branches;
next	1.190;

1.190
date	2009.03.20.15.00.40;	author jps;	state Exp;
branches;
next	1.189;

1.189
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.188;

1.188
date	2009.03.09.05.59.57;	author myc;	state Exp;
branches;
next	1.187;

1.187
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.184;

1.184
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.183;

1.183
date	2009.03.08.03.54.13;	author jps;	state Exp;
branches;
next	1.182;

1.182
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.180;

1.180
date	2008.09.29.05.04.33;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2008.09.26.18.37.49;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2008.09.22.02.30.31;	author myc;	state Exp;
branches;
next	1.177;

1.177
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.176;

1.176
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.175;

1.175
date	2008.09.21.04.54.23;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.173;

1.173
date	2008.09.01.18.29.38;	author jps;	state Exp;
branches;
next	1.172;

1.172
date	2008.08.30.20.35.49;	author jps;	state Exp;
branches;
next	1.171;

1.171
date	2008.08.30.20.22.12;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.168;

1.168
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2008.08.29.05.26.06;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2008.08.25.00.20.33;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2008.08.17.08.11.56;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2008.08.17.06.51.42;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2008.07.22.07.25.26;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2008.07.15.17.49.24;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.160;

1.160
date	2008.06.08.00.57.29;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2008.06.07.19.31.44;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.157;

1.157
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.156;

1.156
date	2008.05.26.18.24.48;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2008.05.14.05.13.22;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2008.05.11.05.46.00;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.04.07.17.24.22;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.04.07.04.31.23;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2008.04.05.16.39.18;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.145;

1.145
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.141;

1.141
date	2008.03.23.00.24.29;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.03.22.21.43.34;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2008.03.22.17.12.19;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2008.03.21.14.54.19;	author myc;	state Exp;
branches;
next	1.137;

1.137
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.136;

1.136
date	2008.03.16.00.20.02;	author jps;	state Exp;
branches;
next	1.135;

1.135
date	2008.03.11.02.54.53;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.133;

1.133
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.03.08.23.20.06;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2008.03.05.05.08.28;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.127;

1.127
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.126;

1.126
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2008.02.10.20.19.19;	author jps;	state Exp;
branches;
next	1.124;

1.124
date	2008.02.10.19.43.38;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2008.02.09.03.04.23;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2008.01.30.19.20.57;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.27.13.41.28;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.22.09.04.17;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.22.05.02.05;	author myc;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.15.03.18.19;	author myc;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2008.01.09.09.18.00;	author jps;	state Exp;
branches;
next	1.108;

1.108
date	2008.01.09.08.31.14;	author jps;	state Exp;
branches;
next	1.107;

1.107
date	2008.01.09.04.12.42;	author jps;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.09.02.29.58;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2008.01.06.18.16.10;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2008.01.06.05.35.55;	author jps;	state Exp;
branches;
next	1.103;

1.103
date	2008.01.05.20.32.43;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.05.05.43.10;	author jps;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2007.12.25.19.46.25;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2007.12.25.16.39.53;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2007.12.21.07.34.36;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2007.12.19.20.46.56;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2007.09.28.20.49.35;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2007.09.20.21.45.02;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.12.22.23.04;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2007.09.04.06.49.19;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2007.08.24.22.49.05;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2007.08.24.17.01.36;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.22.17.59.49;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2007.08.17.02.23.36;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2007.08.02.00.23.34;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2007.07.25.02.58.01;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2007.07.19.21.59.52;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.18.18.47.38;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.18.16.23.58;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2007.07.18.01.21.34;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.18.00.04.41;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.14.02.16.22;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.18.17.26.26;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.17.23.59.16;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.31.23.31.30;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.04.18.12.31;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.21.03.45.52;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.18.19.57.16;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.05.20.46.23;	author rls;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.05.15.53.51;	author rls;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.05.15.06.14;	author rls;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.27.03.06.25;	author jwk;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.01.03.29.38;	author rsd;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.01.02.56.56;	author rsd;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.06.20.40.37;	author jjl;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.06.20.00.30;	author jjl;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.29.21.54.45;	author jjl;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.09.19.09.45;	author jjl;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.07.22.15.56;	author dce;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.09.23.08.18;	author dce;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.21.02.44.35;	author dce;	state Exp;
branches;
next	1.53;

1.53
date	2001.12.18.01.37.34;	author dce;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.16.20.07.53;	author dce;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.07.02.09.56;	author dce;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.24.05.12.01;	author dce;	state Exp;
branches;
next	1.49;

1.49
date	2001.01.12.03.45.50;	author dce;	state Exp;
branches;
next	1.48;

1.48
date	2001.01.05.01.30.24;	author mtp;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.28.01.37.03;	author mtp;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.28.01.10.58;	author mtp;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.28.00.47.01;	author mtp;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.21.01.03.00;	author rsd;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.15.00.24.09;	author mtp;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.07.01.48.17;	author mtp;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.03.21.25.59;	author jimmy;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.03.20.31.48;	author jimmy;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.03.05.37.17;	author jimmy;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.31.23.31.44;	author mtp;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.31.00.43.37;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.11.23.54.20;	author rsd;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.05.19.03.59;	author rsd;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.01.20.09.16;	author rsd;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.29.20.40.51;	author rsd;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.26.22.51.45;	author rsd;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.22.22.35.49;	author rsd;	state Exp;
branches;
next	1.28;

1.28
date	2000.03.20.04.32.39;	author rsd;	state Exp;
branches;
next	1.27;

1.27
date	2000.03.08.22.05.09;	author mtp;	state Exp;
branches;
next	1.26;

1.26
date	99.11.29.00.21.47;	author cso;	state Exp;
branches;
next	1.25;

1.25
date	99.11.28.23.09.31;	author cso;	state Exp;
branches;
next	1.24;

1.24
date	99.10.04.20.00.50;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.22;

1.22
date	99.09.04.18.46.52;	author jimmy;	state Exp;
branches;
next	1.21;

1.21
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.20;

1.20
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	99.07.21.03.10.19;	author jimmy;	state Exp;
branches;
next	1.18;

1.18
date	99.07.09.22.30.27;	author jimmy;	state Exp;
branches;
next	1.17;

1.17
date	99.07.06.19.57.05;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.15;

1.15
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.05.04.17.19.33;	author dce;	state Exp;
branches;
next	1.13;

1.13
date	99.04.09.17.25.33;	author jen;	state Exp;
branches;
next	1.12;

1.12
date	99.04.07.01.20.18;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.03.06.23.51.54;	author dce;	state Exp;
branches;
next	1.10;

1.10
date	99.03.03.20.11.02;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.03.01.05.31.34;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.18.42.19;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.06.00.40.36;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.05.07.47.42;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.02.07.35.17;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.01.08.18.12;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.22.12.02;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/*
************************************************************************
*   File: db.c                                          Part of CircleMUD *
*  Usage: Loading/saving chars, booting/resetting world, internal funcs   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __DB_C__

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "handler.h"
#include "spells.h"
#include "mail.h"
#include "interpreter.h"
#include "house.h"
#include "corpse_save.h"
#include "ships.h"
#include "dg_scripts.h"
#include "weather.h"
#include "clan.h"

void mprog_read_programs(FILE * fp, struct index_data * pMobIndex);
void init_clans(void);
char err_buf[MAX_STRING_LENGTH];

/*object limit function*/
void boot_obj_limit();

void load_results(struct char_data *ch);
void update_stats(struct char_data *ch);
int total_stats_of_wears(struct char_data *ch, int TYPE);

/**************************************************************************
*  declarations of most of the 'global' variables                         *
************************************************************************ */


struct room_data *world = NULL;	/* array of rooms		 */
int top_of_world = 0;		/* ref to top element of world	 */
struct raff_node *raff_list = NULL;  /* list of room affections */

struct char_data *character_list = NULL; /* global linked list of chars */

struct index_data **trig_index; /* index table for triggers      */
int top_of_trigt = 0;           /* top of trigger index table    */
long max_id = 100000;           /* for unique mob/obj id's       */

struct index_data *mob_index;	/* index table for mobile file	 */
struct char_data *mob_proto;	/* prototypes for mobs		 */
int top_of_mobt = 0;		/* top of mobile index table	 */
int get_ac(int level, int race, int class);
struct obj_data *object_list = NULL;	/* global linked list of objs	 */
struct index_data *obj_index;	/* index table for object file	 */
struct obj_data *obj_proto;	/* prototypes for objs		 */
int top_of_objt = 0;		/* top of object index table	 */
struct spell_dam spell_dam_info[MAX_SPELLS + 1];/*internal spell dam*/
struct player_frags_data pos_player_frags[15];/*internal frag list 10 high 10 low*/
struct player_frags_data neg_player_frags[15];/*internal neg frag list*/
struct zone_data *zone_table;	/* zone table			 */
int top_of_zone_table = 0;	/* top element of zone tab	 */
struct message_list fight_messages[MAX_MESSAGES];	/* fighting messages	 */
extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
extern const char *iscommand[];

struct player_index_element *player_table = NULL;	/* index to plr file	 */
FILE *player_fl = NULL;		/* file desc of player file	 */
int top_of_p_table = 0;		/* ref to top of table		 */
int top_of_p_file = 0;		/* ref of size of p file	 */
long top_idnum = 0;		/* highest idnum in use		 */

int no_mail = 0;		/* mail disabled?		 */
int mini_mud = 0;		/* mini-mud mode?		 */
int no_rent_check = 0;		/* skip rent check on boot?	 */
time_t boot_time = 0;		/* time of mud boot		 */
int restrict = 0;		/* level of game restriction	 */
int r_mortal_start_room;	/* rnum of mortal start room	 */
int r_immort_start_room;	/* rnum of immort start room	 */
int r_frozen_start_room;	/* rnum of frozen start room	 */

char *credits = NULL;		/* game credits			 */
char *news = NULL;		/* mud news			 */
char *anews = NULL;
char *motd = NULL;		/* message of the day - mortals */
char *imotd = NULL;		/* message of the day - immorts */
char *help = NULL;		/* help screen			 */
char *info = NULL;		/* info page			 */
char *wizlist = NULL;		/* list of higher gods		 */
char *immlist = NULL;		/* list of peon gods		 */
char *background = NULL;	/* background story		 */
char *handbook = NULL;		/* handbook for new immortals	 */
char *policies = NULL;		/* policies page		 */

struct help_index_element *help_table = 0;	/* the help table	 */
int top_of_helpt = 0;		/* top of help index table	 */

struct time_info_data time_info;/* the infomation about the time    */
struct weather_data weather_info;	/* the infomation about the weather */
struct player_special_data dummy_mob;	/* dummy spec area for mobs	 */
struct reset_q_type reset_q;	/* queue of zones to be reset	 */


void init_ships();
/* local functions */
void set_mob_skills(int i, int class, int race);
void setup_dir(FILE * fl, int room, int dir);
void index_boot(int mode);
void do_newbie(struct char_data *vict);
void discrete_load(FILE * fl, int mode);
void parse_trigger(FILE *fl, int virtual_nr);
void parse_room(FILE * fl, int virtual_nr);
void parse_mobile(FILE * mob_f, int nr);
char *parse_object(FILE * obj_f, int nr);
void load_zones(FILE * fl, char *zonename);
void load_help(FILE *fl);
void assign_mobiles(void);
void assign_objects(void);
void assign_rooms(void);
void assign_the_shopkeepers(void);
void build_player_index(void);
void char_to_store(struct char_data * ch, struct char_file_u * st);
void store_to_char(struct char_file_u * st, struct char_data * ch);
int is_empty(int zone_nr);
void reset_zone(int zone, byte pop);
int file_to_string(char *name, char *buf);
int file_to_string_alloc(char *name, char **buf);
void check_start_rooms(void);
void renum_world(void);
void renum_zone_table(void);
void log_zone_error(int zone, int cmd_no, char *message);
void reset_time(void);
void clear_char(struct char_data * ch);
long get_set_exp(int level, int race, int class, int zone);
sh_int get_set_hit(int level, int race, int class, int state) ;sbyte get_set_hd(int level, int race, int class, int state);
int get_set_dice(int level, int race, int class, int state);
byte mob_find_size(int);
int get_copper(int);
/* external functions */
extern struct descriptor_data *descriptor_list;
void load_messages(void);
void weather_and_time(int mode);
void mag_assign_spells(void);
void boot_social_messages(void);
void update_obj_file(void);	/* In objsave.c */
void sort_commands(void);
void sort_spells(void);
void load_banned(void);
void Read_Invalid_List(void);
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
int hsort(const void *a, const void *b);
extern void save_mem_list(struct char_data *ch);
extern void assign_mem_list(struct char_data *ch);
extern void update_skills(struct char_data *ch);
const char  *std_prompt =  "<&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)>%_&0<%t&0>:<%o&0>";
void boot_frags();
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
int search_block2(char *arg, const char **list, int exact);

/* external vars */
extern int no_specials;

#define READ_SIZE 256
#define GET_ZONE(ch) (ch)->mob_specials.zone

#define GET_SDESC(mob) ((mob)->player.short_descr)
#define GET_LDESC(mob) ((mob)->player.long_descr)
#define GET_NDD(mob) ((mob)->mob_specials.damnodice)
#define GET_SDD(mob) ((mob)->mob_specials.damsizedice)
#define MOB_MONSUM_I		130
#define MOB_MONSUM_II		140
#define MOB_MONSUM_III		150
#define MOB_GATE_I		160
#define MOB_GATE_II		170
#define MOB_GATE_III		180
#define MOB_ELEMENTAL_BASE	110
#define MOB_CLONE		69
#define MOB_ZOMBIE		11
#define MOB_AERIALSERVANT	109
#define MOB_MENTAL     17
#define MOB_MENTAL2    21
/*************************************************************************
*  routines for booting the system                                       *
*********************************************************************** */

/* this is necessary for the autowiz system */
void reboot_wizlists(void)
{
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
}


ACMD(do_reboot)
{
  int i;

  one_argument(argument, arg);

  if (!str_cmp(arg, "all") || *arg == '*') {
    file_to_string_alloc(WIZLIST_FILE, &wizlist);
    file_to_string_alloc(IMMLIST_FILE, &immlist);
    file_to_string_alloc(NEWS_FILE, &news);
	file_to_string_alloc(ANEWS_FILE, &anews);
    file_to_string_alloc(CREDITS_FILE, &credits);
    file_to_string_alloc(MOTD_FILE, &motd);
    file_to_string_alloc(IMOTD_FILE, &imotd);
    file_to_string_alloc(HELP_PAGE_FILE, &help);
    file_to_string_alloc(INFO_FILE, &info);
    file_to_string_alloc(POLICIES_FILE, &policies);
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
    file_to_string_alloc(BACKGROUND_FILE, &background);
  } else if (!str_cmp(arg, "wizlist"))
    file_to_string_alloc(WIZLIST_FILE, &wizlist);
  else if (!str_cmp(arg, "immlist"))
    file_to_string_alloc(IMMLIST_FILE, &immlist);
  else if (!str_cmp(arg, "news"))
    file_to_string_alloc(NEWS_FILE, &news);
  else if (!str_cmp(arg, "anews"))
    file_to_string_alloc(ANEWS_FILE, &anews);
  else if (!str_cmp(arg, "credits"))
    file_to_string_alloc(CREDITS_FILE, &credits);
  else if (!str_cmp(arg, "motd"))
    file_to_string_alloc(MOTD_FILE, &motd);
  else if (!str_cmp(arg, "imotd"))
    file_to_string_alloc(IMOTD_FILE, &imotd);
  else if (!str_cmp(arg, "help"))
    file_to_string_alloc(HELP_PAGE_FILE, &help);
  else if (!str_cmp(arg, "info"))
    file_to_string_alloc(INFO_FILE, &info);
  else if (!str_cmp(arg, "policy"))
    file_to_string_alloc(POLICIES_FILE, &policies);
  else if (!str_cmp(arg, "handbook"))
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
  else if (!str_cmp(arg, "background"))
    file_to_string_alloc(BACKGROUND_FILE, &background);
  else if (!str_cmp(arg, "xhelp")) {
    if (help_table) {
      for (i = 0; i <= top_of_helpt; i++) {
        if (help_table[i].keyword)
	  free(help_table[i].keyword);
        if (help_table[i].entry && !help_table[i].duplicate)
	  free(help_table[i].entry);
      }
      free(help_table);
    }
    top_of_helpt = 0;
    index_boot(DB_BOOT_HLP);
  } else {
    send_to_char("Unknown reload option.\r\n", ch);
    return;
  }

  send_to_char(OK, ch);
}


long get_set_exp(int level, int race, int class, int zone)
/*class/species*/
{
long exp;
int cfactor = 100;
int sfactor = 100;
int zfactor = 100;
for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
if (zone == zone_table[zfactor].number)
break;
}
zfactor = zone_table[zfactor].zone_factor;
/*zfactor = 100;*/

/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
	switch(class)
	{
	case MCLASS_VOID:
		cfactor = 80;
		break;
	case MCLASS_SORCERER:
		cfactor = 120;
		break;
	case MCLASS_CLERIC:
		cfactor = 100;
		break;
	case MCLASS_WARRIOR:
		cfactor = 100;
		break;
	case MCLASS_THIEF:
		cfactor = 100;
		break;
	default:
		cfactor = 100;
		break;
	}

	switch(race)
	{
	case SPECIES_OTHER:
		sfactor = 80;
		break;
	case SPECIES_UNDEAD:
		sfactor = 110;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 110;
		break;
	case SPECIES_GOBLIN:
		sfactor = 60;
		break;
	default:
		cfactor = 100;
		break;
	}

	if (level < 50)
		exp = (long) (((float)(level * level * level)) + 1000);
	else if (level >= 50)/*50 and under equation*/
		exp = (long) (level * level * 50) + 1000;
/*51 and over equation*/

	sfactor = ((int)((sfactor + zfactor + cfactor)/3));
	exp = (long) (((float)((sfactor*exp)/100)));
	return exp;
}

sh_int get_set_hit(int level, int race, int class, int state)
/*class/species*/
{
/*main - is the main bonus chucnk of hps
*/
 /*struct descriptor_data *d;
*/	sh_int main = 0;
	sh_int face = 1;
	int cfactor = 100;
	int sfactor = 100;

/*
The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/




	switch(class)
	{
	case MCLASS_VOID:
		cfactor = 100;
		break;
	case MCLASS_SORCERER:
		cfactor = 80;
		break;
	case MCLASS_CLERIC:
		cfactor = 80;
		break;
	case MCLASS_WARRIOR:
		cfactor = 120;
		break;
	case MCLASS_THIEF:
		cfactor = 90;
		break;
	default:
		cfactor = 100;
		break;
	}

	switch(race)
	{
	case SPECIES_OTHER:
		sfactor = 110;
		break;
case SPECIES_TROLL:
sfactor = 120;
break;
case SPECIES_OGRE:
sfactor = 130;
break;

	case SPECIES_UNDEAD:
		sfactor = 100;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 120;
		break;
	case SPECIES_GOBLIN:
		sfactor = 60;
		break;
	default:
		sfactor = 100;
	break;
	}
/* here is the function*/
/*auto setting sets hit and mana to 5 and 10 thus 5d10 extra = average 25*/
if (level < 20)
main = (sh_int) (3 * ((float)level * (float)(level/1.25))); 	/*50 and under equation*/

else if (level < 35)
main = (sh_int) (3 * ((float)level * (float)(level/1.35))); 	/*50 and under equation*/

else if (level < 50)
main = (sh_int) (3 * ((float)level * (float)level/1.25)); 	/*50 and under equation*/

else if (level >= 50)
main = (sh_int) (3 * ((float)level * (float)level/1.25));  /*51 and over equation*/
if (level <=5)
face = 1;
else if (level <=10) {
main -= 25;
face = 5;
}
else if (level <= 20) {
main -= 100;
face = 10;
}
else if (level <=30)  {
main -= 200;
face = 20;
}
else {
main -= 2000;
face = 200;
}


/*finally taking the factors into account*/
sfactor = ((int)((sfactor + cfactor)/2));
main = (sh_int) (((float)(sfactor*main)/100));


if (state == 2)
return face;
else
return main;


}


sbyte get_set_hd(int level, int race, int class, int state)
/*class/species*/
{
sbyte hit = 0;
sbyte dam = 0;
int cfactor = 100;
int sfactor = 100;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(class) {
case MCLASS_VOID:
   cfactor = 130;
   break;
case MCLASS_SORCERER:
	cfactor = 80;
	break;
case MCLASS_CLERIC:
	cfactor = 80;
	break;
case MCLASS_WARRIOR:
	cfactor = 120;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 100;
break;
}

switch(race) {
case SPECIES_OTHER:
   sfactor = 120;
   break;
case SPECIES_UNDEAD:
	sfactor = 100;
	break;
case SPECIES_HUMANOID:
	sfactor = 100;
	break;
case SPECIES_TROLL:
sfactor = 110;
break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 120;
        break;
case SPECIES_GIANT:
	sfactor = 120;
	break;
	case SPECIES_GOBLIN:
	sfactor = 60;
	break;
default:
sfactor = 100;
break;
}

/*hit calculations*/
if (!state) {
if (level <10)
hit = (sbyte) (level/1.5);
else if (level < 30)
hit = (sbyte) (level/1.8);
else if (level < 50)
hit = (sbyte) (level/1.3);	/*50 and under equation*/
else if (level >= 50)
hit = (sbyte) (level/1.4);	 /*51 and over equation*/


/*hit factor considerations*/
sfactor = ((int)((sfactor + cfactor)/2));
hit = (sbyte) (((float)(sfactor*hit)/100));


}

/*dam calculations*/
if (state) {
if (level < 10)
dam = (sbyte) (level /4.0);
else if (level < 20)
dam = (sbyte) (level / 4.0); /*under 20*/
else if (level < 35)
dam = (sbyte) (level/4.3); /*under 35*/

else if (level < 50)
dam = (sbyte) (level / 4.6);	/*50 and under equation*/

else if (level >= 50)
dam = (sbyte) (level / 4.4);	/*51 and over equation*/

/*dam factor considerations*/
sfactor = ((int)((sfactor + cfactor)/2));
dam = (sbyte) (((float)(sfactor*dam)/100));
}



if (!state)
return hit;
else
return dam;
}

int get_set_dice(int level, int race, int class, int state)

/*class/species*/
{
int dice = 0;
int face = 0;
int cfactor = 100;
int sfactor = 100;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(class) {
case MCLASS_VOID:
   cfactor = 100;
   break;
case MCLASS_SORCERER:
	cfactor = 60;
	break;
case MCLASS_CLERIC:
	cfactor = 70;
	break;
case MCLASS_WARRIOR:
	cfactor = 120;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 100;
break;
}

switch(race) {
case SPECIES_OTHER:
   sfactor = 80;
   break;
case SPECIES_UNDEAD:
	sfactor = 110;
	break;
case SPECIES_OGRE:
sfactor = 120;
break;
case SPECIES_TROLL:
sfactor = 110;
break;
case SPECIES_HUMANOID:
	sfactor = 100;
	break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 120;
	break;
case SPECIES_GIANT:
	sfactor = 100;
	break;
	case SPECIES_GOBLIN:
	sfactor = 60;
	break;
default:
sfactor = 100;
break;
}

/*dice calculations*/
if (!state) {
if (level < 10)
dice = MAX(1, (int) ((level/3) + .5));

else if (level < 30)
dice = (int) ((float)(level/3) + .5); /*under 30*/

else if (level <= 50)
dice = (int) ((level /3) + .5);	/*50 and under equation*/

else if (level > 50)
dice = (int) ((level / 2.5) + .5);	/*51 and over equation*/

sfactor = ((int)((sfactor + cfactor)/2));
dice = (sbyte) (((float)(sfactor*dice)/100));
}
/*face calucs*/
if (state) {
if (level < 10)
face = 3;
else if (level < 26)
face = 4;
else if (level < 36)
face = 4;

else if (level <= 50)
face = 5;	/*50 and under equation*/
else if ((level > 50) && (level <= 60))
face = 8;	   /*50 over equation*/
else if (level > 60)
face = 10;

/*face = (sbyte) (((float)sfactor/100) * ((float)cfactor/100) * face);
*/}



if (!state)
return dice;
else
return face;
}


int get_copper(int i)
/*class/species*/
{
	/*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
int copper = 0;
int cfactor = 100;
int sfactor = 100;
int zfactor;
for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
if (GET_ZONE(mob_proto + i) == zone_table[zfactor].number)
break;
}
zfactor = zone_table[zfactor].zone_factor;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(mob_proto[i].player.class) {
case MCLASS_VOID:
   cfactor = 20;
   break;
case MCLASS_SORCERER:
	cfactor = 100;
	break;
case MCLASS_CLERIC:
	cfactor = 100;
	break;
case MCLASS_WARRIOR:
	cfactor = 100;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 40;
break;
}

switch(mob_proto[i].player.race) {
case SPECIES_OTHER:
   sfactor = 0;
   break;
case SPECIES_UNDEAD:
	sfactor = 40;
	break;
case SPECIES_HUMANOID:
	sfactor = 40;
	break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 140;
	break;
case SPECIES_GIANT:
	sfactor = 120;
	break;
	case SPECIES_GOBLIN:
	sfactor = 65;
	break;
	case SPECIES_ANIMAL:
	sfactor = 0;
	break;
	default:
sfactor = 40;
break;
}
if ((sfactor == 0) || (cfactor == 0))
	return 0;

/*copper calculations*/
copper = (number(1, 15)) * mob_proto[i].player.level;
sfactor = (int)((sfactor + cfactor + zfactor)/3);

copper = (int)((float)((sfactor/100.0) * copper));

return copper;
}


int get_ac(int level, int race, int class)
/*class/species*/
{
/*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
int ac = 0;
int cfactor = 100;
int sfactor = 100;

/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
	switch(class)
	{
	case MCLASS_VOID:
		cfactor = 105;
		break;
   case MCLASS_SORCERER:
	   cfactor = 75;
	   break;
   case MCLASS_CLERIC:
	   cfactor = 100;
	   break;
   case MCLASS_WARRIOR:
	   cfactor = 120;
	   break;
   case MCLASS_THIEF:
	   cfactor = 80;
	   break;
   default:
      cfactor = 100;
   break;
   }

   switch(race)
   {
   case SPECIES_OTHER:
      sfactor = 105;
      break;
   case SPECIES_UNDEAD:
	   sfactor = 110;
	   break;
   case SPECIES_HUMANOID:
	   sfactor = 60;
	   break;
   case SPECIES_DRAGON:
	   sfactor = 140;
	   break;
   case SPECIES_DEMON:
	   sfactor = 120;
	   break;
   case SPECIES_GIANT:
	   sfactor = 120;
	   break;
	case SPECIES_GOBLIN:
	   sfactor = 90;
	   break;
	case SPECIES_ANIMAL:
	   sfactor = 65;
	   break;
   case SPECIES_TROLL:
      sfactor = 100;
      break;
   case SPECIES_OGRE:
      sfactor = 90;
      break;
	default:
      sfactor = 100;
      break;
   }
   if (level < 30)
      ac = 90;
   else
      ac = 50;

      /*ac calculations*/
   ac = ac - (2 * level);
   sfactor = (int)((sfactor + cfactor)/2);

   ac = (int)((float)((sfactor/100.0) * ac));
   ac = MIN(100, MAX(-100, ac));
   return ac;
}





/*This requres a file in lib/misc/spell_dams, It will tell you if you dont
It then boots, note that if anything goes wrong to file
you can re-write it by saving under sdedit, the viewer is in act.informative.c
The olc code is in sdedit.c

  Proky*/
void boot_spell_dams()
{
int i;
FILE *ifptr;
char line[256];
char *err = "Spell Dam";
    if ((ifptr = fopen(SPELL_DAM_FILE, "r")) == NULL)
    {
        log("No spells dam file it should be at lib/misc/spell_dam.");
        exit(1);
    }
    else
    {
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        if (str_cmp(line, "spell_dam"))
        {
            log("Error in booting spell dams");
           /* return;
      */  }
        for (i = 1; i <= MAX_SPELLS;i++)
        {
            get_line(ifptr, line);
            sscanf(line, "%hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd",
            &SD_SPELL(i), &SD_INTERN_DAM(i),
&SD_NPC_STATIC(i), &SD_NPC_NO_DICE(i), &SD_NPC_NO_FACE(i),
            &SD_PC_STATIC(i), &SD_PC_NO_DICE(i), &SD_PC_NO_FACE(i), &SD_NPC_REDUCE_FACTOR(i), &SD_USE_BONUS(i),
            &SD_BONUS(i), &SD_LVL_MULT(i));
            if (SD_NPC_REDUCE_FACTOR(i) == 0)
                SD_NPC_REDUCE_FACTOR(i) = 100;

            SD_NOTE(i) = fread_string(ifptr, err);
        }
        fclose (ifptr);
    }
}
/*each player has a frag, which is a float of how many pc's they have killed
There is a structure:
struct player_frags_data {
    int playerid;
    char	name[MAX_NAME_LENGTH+1];
    float frag;
}
struct player_frags[19] - 0 -> 9 top 10, 10 - 19 bottom 10
- this is a globel defined in db.c
This code simply reads througth playerfile and checks for the highest and lowest
frags and thus any errors in the frags should be fixed with a boot*/

void boot_frags()
{
    struct char_file_u chara;
    FILE *pfptr;
    int i, j;
    int pid = 0;

    if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
    {
        if (errno != ENOENT)
        {
            perror("fatal error opening playerfile");
            exit(1);
        }
        else
        {
            log("No playerfile.  Creating a new one.");
            touch(PLAYER_FILE);
            if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
            {
	            perror("fatal error opening playerfile");
	            exit(1);
            }
        }
    }

    while (!feof(pfptr))
    {/*loops through playerfile now its open and all is well*/
        fread(&chara , sizeof(struct char_file_u), 1, pfptr);
        if (chara.player_specials_saved.frag > 0.0)
        {
            for (i = 0;i <= 14;i++)
            {
                if (!str_cmp(pos_player_frags[i].name, chara.name))
                    break;/*solve the empty new character that happens*/
                if (pos_player_frags[i].frag < chara.player_specials_saved.frag)
                {/*ok insert person with frag details.*/
                /*1. copy all others down*/
                    for (j = 14;j > i; j--)
                    {
                        pos_player_frags[j] = pos_player_frags[j-1];
                    }
                    pos_player_frags[i].playerid = pid;
                    strcpy(pos_player_frags[i].name, chara.name);
                    pos_player_frags[i].frag = chara.player_specials_saved.frag;
                    break;
                }
            }
        }
        else if (chara.player_specials_saved.frag < 0.0)
        {
            for (i = 0;i <= 14;i++)
            {
                if (!str_cmp(neg_player_frags[i].name, chara.name))
                    break;/*solve the empty new character that happens*/
                if (neg_player_frags[i].frag > chara.player_specials_saved.frag)
                {/*ok insert person with frag details.*/
            /*1. copy all others down*/
                    for (j = 14;j > i; j--)
                    {
                        neg_player_frags[j] = neg_player_frags[j-1];
                    }
                    neg_player_frags[i].playerid = pid;
                    strcpy(neg_player_frags[i].name, chara.name);
                    neg_player_frags[i].frag = chara.player_specials_saved.frag;
                    break;
                }
            }
        }
        pid++;
    }

	rewind(pfptr);
}




void boot_world(void)
{
  log("Loading zone table.");
  index_boot(DB_BOOT_ZON);

  log("Loading triggers and generating index.");
  index_boot(DB_BOOT_TRG);


  log("Loading rooms.");
  index_boot(DB_BOOT_WLD);

  log("Renumbering rooms.");
  renum_world();

  log("Checking start rooms.");
  check_start_rooms();

  log("Loading mobs and generating index.");
  index_boot(DB_BOOT_MOB);

  log("Loading objs and generating index.");
  index_boot(DB_BOOT_OBJ);

  log("Booting object limit");
  boot_obj_limit();

  log("Renumbering zone table.");
  renum_zone_table();

   log("Booting spell_dam's.");
 boot_spell_dams();


  if (!no_specials) {
    log("Loading shops.");
    index_boot(DB_BOOT_SHP);
  }
}



/* body of the booting system */
void boot_db(void)
{
  int i;

  log("Boot db -- BEGIN.");

  log ("Booting frags");
  boot_frags();

  log("Reading a&news, credits, help, bground, info & motds.");
  file_to_string_alloc(NEWS_FILE, &news);
  file_to_string_alloc(ANEWS_FILE, &anews);
  file_to_string_alloc(CREDITS_FILE, &credits);
  file_to_string_alloc(MOTD_FILE, &motd);
  file_to_string_alloc(IMOTD_FILE, &imotd);
  file_to_string_alloc(HELP_PAGE_FILE, &help);
  file_to_string_alloc(INFO_FILE, &info);
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
  file_to_string_alloc(POLICIES_FILE, &policies);
  file_to_string_alloc(HANDBOOK_FILE, &handbook);
  file_to_string_alloc(BACKGROUND_FILE, &background);


  boot_world();

  log("Resetting the game time:");
  reset_time();

  log("Loading help entries.");
  index_boot(DB_BOOT_HLP);

  log("Generating player index.");
  build_player_index();

  log("Loading fight messages.");
  load_messages();

  log("Loading social messages.");
  boot_social_messages();

  log("Assigning function pointers:");

  if (!no_specials) {
    log("   Mobiles.");
    assign_mobiles();
    log("   Shopkeepers.");
    assign_the_shopkeepers();
    log("   Objects.");
    assign_objects();
    log("   Rooms.");
    assign_rooms();
  }
  log("   Spells.");
  mag_assign_spells();

  log("Assigning spell and skill levels.");
  init_spell_levels();

  log("Sorting command list and spells.");
  sort_commands();
  sort_spells();

  log("Booting Clans.");
  init_clans();

  log("Booting mail system.");
  if (!scan_file()) {
    log("    Mail boot failed -- Mail system disabled");
    no_mail = 1;
  }
  log("Reading banned site and invalid-name list.");
  load_banned();
  Read_Invalid_List();

  if (!no_rent_check) {
    log("Deleting timed-out crash and rent files:");
    update_obj_file();
    log("Done.");
  }
  for (i = 0; i <= top_of_zone_table; i++) {
    sprintf(buf2, "Resetting %s (rooms %d-%d).",
	    zone_table[i].name, (i ? (zone_table[i - 1].top + 1) : 0),
	    zone_table[i].top);
    log(buf2);
    reset_zone(i, TRUE);
  }

  reset_q.head = reset_q.tail = NULL;

  if (!mini_mud) {
    log("Booting houses.");
    House_boot();
  }

  log("Booting corpses.");
  Corpse_boot();

  boot_time = time(0);

  MOBTrigger = TRUE;

  init_ships();
  log("Booting ships.");

  log("Boot db -- DONE.");
}


/* reset the time in the game from file */
void reset_time(void)
{
  long beginning_of_time = 650336715;
  struct time_info_data mud_time_passed(time_t t2, time_t t1);

  time_info = mud_time_passed(time(0), beginning_of_time);
  log("entering if-else chain");
  /* okay, saved time represents HEMISPHERE_NORTHWEST/ ...SOUTHWEST */
  if (time_info.hours <= 7)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
  log("end of <=7");

  }
  else if (time_info.hours == 8)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_SET;
  log("end of ==8");

  }
  else if (time_info.hours <= 20)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_DARK;
  log("end <= 20");

  }
  else if (time_info.hours == 21)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_RISE;
  log("==21");

  }
  else
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_LIGHT;
    log("end else...");
}

    log("setting up seasons");

  /* setup the seasons */
  if(time_info.month < 4)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SUMMER;
      log("winter");

  }
  else if(time_info.month < 8)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = AUTUMN;
  log("spring");

  }
  else if(time_info.month < 12)
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = WINTER;
  log("summer");

  }
  else
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_NORTHEAST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SPRING;
  log("autumn");

  }

  sprintf(buf, "   Current Gametime: %dH %dD %dM %dY.", time_info.hours,
	  time_info.day, time_info.month, time_info.year);
  log(buf);
  log("calling init_weather");

  init_weather();
}



/* generate index table for the player file */
void build_player_index(void)
{
  int nr = -1, i;
  long size, recs;
  struct char_file_u dummy;

  if (!(player_fl = fopen(PLAYER_FILE, "r+b"))) {
    if (errno != ENOENT) {
      perror("fatal error opening playerfile");
      exit(1);
    } else {
      log("No playerfile.  Creating a new one.");
      touch(PLAYER_FILE);
      if (!(player_fl = fopen(PLAYER_FILE, "r+b"))) {
	perror("fatal error opening playerfile");
	exit(1);
      }
    }
  }

  fseek(player_fl, 0L, SEEK_END);
  size = ftell(player_fl);
  rewind(player_fl);
  if (size % sizeof(struct char_file_u))
    fprintf(stderr, "\aWARNING:  PLAYERFILE IS PROBABLY CORRUPT!\n");
  recs = size / sizeof(struct char_file_u);
  if (recs) {
    sprintf(buf, "   %ld players in database.", recs);
    log(buf);
    CREATE(player_table, struct player_index_element, recs);
  } else {
    player_table = NULL;
    top_of_p_file = top_of_p_table = -1;
    return;
  }

  for (; !feof(player_fl);) {
    fread(&dummy, sizeof(struct char_file_u), 1, player_fl);
    if (!feof(player_fl)) {	/* new record */
      nr++;
      CREATE(player_table[nr].name, char, strlen(dummy.name) + 1);
      for (i = 0;
	   (*(player_table[nr].name + i) = LOWER(*(dummy.name + i))); i++);
      player_table[nr].id = dummy.char_specials_saved.idnum;
      top_idnum = MAX(top_idnum, dummy.char_specials_saved.idnum);
    }
  }

  top_of_p_file = top_of_p_table = nr;
}



/* function to count how many hash-mark delimited records exist in a file */
int count_hash_records(FILE * fl)
{
  char buf[128];
  int count = 0;

  while (fgets(buf, 128, fl))
    if (*buf == '#')
      count++;

  return count;
}



void index_boot(int mode)
{
  char *index_filename, *prefix;
  FILE *index, *db_file;
  int rec_count = 0;

  switch (mode) {
  case DB_BOOT_TRG:
    prefix = TRG_PREFIX;
    break;
  case DB_BOOT_WLD:
    prefix = WLD_PREFIX;
    break;
  case DB_BOOT_MOB:
    prefix = MOB_PREFIX;
    break;
  case DB_BOOT_OBJ:
    prefix = OBJ_PREFIX;
    break;
  case DB_BOOT_ZON:
    prefix = ZON_PREFIX;
    break;
  case DB_BOOT_SHP:
    prefix = SHP_PREFIX;
    break;
  case DB_BOOT_HLP:
    prefix = HLP_PREFIX;
    break;
  default:
    log("SYSERR: Unknown subcommand to index_boot!");
    exit(1);
    break;
  }

  if (mini_mud)
    index_filename = MINDEX_FILE;
  else
    index_filename = INDEX_FILE;

  sprintf(buf2, "%s/%s", prefix, index_filename);

  if (!(index = fopen(buf2, "r"))) {
    sprintf(buf1, "Error opening index file '%s'", buf2);
    perror(buf1);
    exit(1);
  }

  /* first, count the number of records in the file so we can malloc */
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s/%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      log("file listed in index not found");
      exit(1);
    } else {
      if (mode == DB_BOOT_ZON)
	rec_count++;
      else
	rec_count += count_hash_records(db_file);
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }

  /* Exit if 0 records, unless this is shops */
  if (!rec_count) {
    if (mode == DB_BOOT_SHP)
      return;
    log("SYSERR: boot error - 0 records counted");
    exit(1);
  }

  rec_count++;

  switch (mode) {
  case DB_BOOT_TRG:
    CREATE(trig_index, struct index_data *, rec_count);
    break;
  case DB_BOOT_WLD:
    CREATE(world, struct room_data, rec_count);
    break;
  case DB_BOOT_MOB:
    CREATE(mob_proto, struct char_data, rec_count);
    CREATE(mob_index, struct index_data, rec_count);
    break;
  case DB_BOOT_OBJ:
    CREATE(obj_proto, struct obj_data, rec_count);
    CREATE(obj_index, struct index_data, rec_count);
    break;
  case DB_BOOT_ZON:
    CREATE(zone_table, struct zone_data, rec_count);
    break;
  case DB_BOOT_HLP:
    CREATE(help_table, struct help_index_element, rec_count * 2);
    break;
  }

  rewind(index);
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s/%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      exit(1);
    }
    switch (mode) {
	case DB_BOOT_TRG:
    case DB_BOOT_WLD:
    case DB_BOOT_OBJ:
    case DB_BOOT_MOB:
      discrete_load(db_file, mode);
      break;
    case DB_BOOT_ZON:
      load_zones(db_file, buf2);
      break;
    case DB_BOOT_HLP:
      load_help(db_file);
      break;
    case DB_BOOT_SHP:
      boot_the_shops(db_file, buf2, rec_count);
      break;
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }

  /* sort the help index */
  if (mode == DB_BOOT_HLP) {
    qsort(help_table, top_of_helpt, sizeof(struct help_index_element), hsort);
    top_of_helpt--;
  }}

int tmp_debug = 0;

void discrete_load(FILE * fl, int mode)
{
  int nr = -1, last = 0;
  char line[256];
  char *modes[] = {"world", "mob", "obj", "ZON", "SHP", "HLP", "trg"};
  for (;;) {
    /*
     * we have to do special processing with the obj files because they have
     * no end-of-record marker :(
     */
    if (mode != DB_BOOT_OBJ || nr < 0)
    {
tmp_debug++;
  if (!get_line(fl, line)) {
	fprintf(stderr, "Format error after %s #%d\n", modes[mode], nr);
fprintf(stderr, "Offending line: '%s'in file down list%d\n", line,
tmp_debug);
	exit(1);
      }
   }
 if (*line == '$')
      return;

    if (*line == '#') {
      last = nr;
      if (sscanf(line, "#%d", &nr) != 1) {
	fprintf(stderr, "Format error after %s #%d\n", modes[mode], last);
fprintf(stderr, "Offending line: '%s'\n", line);
	exit(1);
      }
      if (nr >= 198999)
	return;
      else
	switch (mode) {
    case DB_BOOT_TRG:
      parse_trigger(fl, nr);
      break;
	case DB_BOOT_WLD:
	  parse_room(fl, nr);
	  break;
	case DB_BOOT_MOB:
	  parse_mobile(fl, nr);
	  break;
	case DB_BOOT_OBJ:
	  strcpy(line, parse_object(fl, nr));
	  break;
	}
    } else {
      fprintf(stderr, "Format error in %s file near %s #%d\n",
	      modes[mode], modes[mode], nr);
      fprintf(stderr, "Offending line: '%s'\n", line);
      exit(1);
    }
  }
}


long asciiflag_conv(char *flag)
{
  long flags = 0;
  int is_number = 1;
  register char *p;

  for (p = flag; *p; p++) {
    if (islower(*p))
      flags |= 1 << (*p - 'a');
    else if (isupper(*p))
      flags |= 1 << (26 + (*p - 'A'));

    if (!isdigit(*p))
      is_number = 0;
  }

  if (is_number)
    flags = atol(flag);

  return flags;
}

char fread_letter(FILE *fp)
 {
   char c;
   do {
     c = getc(fp);
   } while (isspace(c));
   return c;
 }



/* load the rooms */
void parse_room(FILE * fl, int virtual_nr)
{
  static int room_nr = 0, zone = 0;
  int t[10], i;
  char line[256], flags[128];
  struct extra_descr_data *new_descr;
  char letter;

  if (virtual_nr <= (zone ? zone_table[zone - 1].top : -1)) {
    fprintf(stderr, "Room #%d is below zone %d.\n", virtual_nr, zone);
    exit(1);
  }
  while (virtual_nr > zone_table[zone].top)
    if (++zone > top_of_zone_table) {
      fprintf(stderr, "Room %d is outside of any zone.\n", virtual_nr);
      exit(1);
    }
  world[room_nr].zone = zone;
  world[room_nr].number = virtual_nr;
  world[room_nr].name = fread_string(fl, buf2);
  world[room_nr].description = fread_string(fl, buf2);

  if (!get_line(fl, line) || sscanf(line, " %d %s %d ", t, flags, t + 2) != 3) {
    fprintf(stderr, "Format error in room #%d\n", virtual_nr);
    exit(1);
  }
  /* t[0] is the zone number; ignored with the zone-file system */
  world[room_nr].room_flags = asciiflag_conv(flags);
  world[room_nr].sector_type = t[2];

  world[room_nr].func = NULL;
  world[room_nr].contents = NULL;
  world[room_nr].people = NULL;
  world[room_nr].light = 0;	/* Zero light sources */

  for (i = 0; i < NUM_OF_DIRS; i++)
    world[room_nr].dir_option[i] = NULL;

  world[room_nr].ex_description = NULL;

  sprintf(buf, "Format error in room #%d (expecting D/E/S)", virtual_nr);

  for (;;) {
    if (!get_line(fl, line)) {
      fprintf(stderr, "%s\n", buf);
      exit(1);
    }
    switch (*line) {
    case 'D':
      setup_dir(fl, room_nr, atoi(line + 1));
      break;
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(fl, buf2);
      new_descr->description = fread_string(fl, buf2);
      new_descr->next = world[room_nr].ex_description;
      world[room_nr].ex_description = new_descr;
      break;
    case 'S':			/* end of room */
      letter = fread_letter(fl);
      ungetc(letter, fl);
      while (letter=='T') {
        dg_read_trigger(fl, &world[room_nr], WLD_TRIGGER);
        letter = fread_letter(fl);
        ungetc(letter, fl);
      }
      top_of_world = room_nr++;
      return;
      break;
    default:
      fprintf(stderr, "%s\n", buf);
      exit(1);
      break;
    }
  }
}



/* read direction data */
void setup_dir(FILE * fl, int room, int dir)
{
  int t[5];
  char line[256];

  sprintf(buf2, "room #%d, direction D%d", world[room].number, dir);

  CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
  world[room].dir_option[dir]->general_description = fread_string(fl, buf2);
  world[room].dir_option[dir]->keyword = fread_string(fl, buf2);

  if (!get_line(fl, line)) {
    fprintf(stderr, "Format error, %s\n", buf2);
    exit(1);
  }
  if (sscanf(line, " %d %d %d ", t, t + 1, t + 2) != 3) {
    fprintf(stderr, "Format error, %s\n", buf2);
    exit(1);
  }
  if (t[0] == 1)
    world[room].dir_option[dir]->exit_info = EX_ISDOOR;
  else if (t[0] == 2)
    world[room].dir_option[dir]->exit_info = EX_ISDOOR | EX_PICKPROOF;
  else
    world[room].dir_option[dir]->exit_info = 0;

  world[room].dir_option[dir]->key = t[1];
  world[room].dir_option[dir]->to_room = t[2];
}


/* make sure the start rooms exist & resolve their vnums to rnums */
void check_start_rooms(void)
{
  extern int mortal_start_room;
  extern int immort_start_room;
  extern int frozen_start_room;

  if ((r_mortal_start_room = real_room(mortal_start_room)) < 0) {
    log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
    exit(1);
  }
  if ((r_immort_start_room = real_room(immort_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Immort start room does not exist.  Change in config.c.");
    r_immort_start_room = r_mortal_start_room;
  }
  if ((r_frozen_start_room = real_room(frozen_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Frozen start room does not exist.  Change in config.c.");
    r_frozen_start_room = r_mortal_start_room;
  }
}


/* resolve all vnums into rnums in the world */
void renum_world(void)
{
  register int room, door;

  for (room = 0; room <= top_of_world; room++)
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (world[room].dir_option[door])
	if (world[room].dir_option[door]->to_room != NOWHERE)
	  world[room].dir_option[door]->to_room =
	    real_room(world[room].dir_option[door]->to_room);
}


#define ZCMD zone_table[zone].cmd[cmd_no]

/* resulve vnums into rnums in the zone reset tables */
void renum_zone_table(void)
{
  int zone, cmd_no, a, b;

  for (zone = 0; zone <= top_of_zone_table; zone++)
    for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {
      a = b = 0;
      switch (ZCMD.command) {
      case 'M':
	a = ZCMD.arg1 = real_mobile(ZCMD.arg1);
	b = ZCMD.arg3 = real_room(ZCMD.arg3);
	break;
      case 'O':
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	if (ZCMD.arg3 != NOWHERE)
	  b = ZCMD.arg3 = real_room(ZCMD.arg3);
	break;
      case 'G':
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	break;
      case 'E':
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	break;
      case 'P':
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	b = ZCMD.arg3 = real_object(ZCMD.arg3);
	break;
      case 'D':
	a = ZCMD.arg1 = real_room(ZCMD.arg1);
	break;
      case 'R': /* rem obj from room */
        a = ZCMD.arg1 = real_room(ZCMD.arg1);
	b = ZCMD.arg2 = real_object(ZCMD.arg2);
        break;
      }
      if (a < 0 || b < 0) {
	if (!mini_mud)
	  log_zone_error(zone, cmd_no, "Invalid vnum, cmd disabled");
	ZCMD.command = '*';
      }
    }
}



#define OLC_MOB(d)	((d)->olc->mob)
void parse_simple_mob(FILE *mob_f, int i, int nr)
{

	int j, t[10];
  char line[256];
  long k = 0;
  mob_proto[i].real_abils.str = 11;
    mob_proto[i].real_abils.intel = 11;
    mob_proto[i].real_abils.wis = 11;
    mob_proto[i].real_abils.dex = 11;
    mob_proto[i].real_abils.con = 15;
    mob_proto[i].real_abils.cha = 11;

    get_line(mob_f, line);
    if (sscanf(line, " %d %d %d %dd%d+%d %dd%d+%d ",
	  t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8) != 9) {
      fprintf(stderr, "Format error in mob #%d, first line after S flag\n"
	      "...expecting line of form '# # # #d#+# #d#+#'\n", nr);
      exit(1);
    }
    GET_LEVEL(mob_proto + i) = t[0];
// No negative hitroll bonus DO_NOT CHANGE -Banyal
   mob_proto[i].mob_specials.ex_hitroll = BOUNDED(0, t[1], 20);

   mob_proto[i].mob_specials.ex_armor = 10 * t[2];
	/*if ac onmedit is 0 then ignore it*/


    /* max hit = 0 is a flag that H, M, V is xdy+z */
    mob_proto[i].points.max_hit = 0;

	mob_proto[i].mob_specials.ex_max_hit = 0;
	mob_proto[i].mob_specials.ex_no_dice = t[3];
    mob_proto[i].mob_specials.ex_face = t[4];

	/*mob_proto[i].points.hit = t[3];
    mob_proto[i].points.mana = t[4];
   */

	mob_proto[i].points.move = t[5];
	mob_proto[i].points.max_mana = 10;
    mob_proto[i].points.max_move = 50;

    mob_proto[i].mob_specials.ex_damnodice = t[6];
    mob_proto[i].mob_specials.ex_damsizedice = t[7];
    mob_proto[i].mob_specials.ex_damroll = t[8];

    get_line(mob_f, line);
    if (sscanf(line, " %d %d %d %d", t, t + 1, t + 2, t + 3) > 3)
	{
	GET_ZONE(mob_proto + i) = t[2];
	GET_EX_GOLD(mob_proto + i) = t[0];
	GET_EX_PLAT(mob_proto + i) = t[1];
}else
{	GET_ZONE(mob_proto + i) = (nr/100);
GET_EX_GOLD(mob_proto + i) = 0;
	GET_EX_PLAT(mob_proto + i) = 0;

}	GET_EX_GOLD(mob_proto + i) = t[0];



    get_line(mob_f, line);
    if ((sscanf(line, " %d %d %d %d %d %d %d %d ", t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7))  > 3) {


	mob_proto[i].player.class = t[3];
    mob_proto[i].player.race = t[4];
	mob_proto[i].player.race_align = t[5];
	mob_proto[i].player.size = mob_find_size(t[4]);
	mob_proto[i].char_specials.position = t[0];
    mob_proto[i].mob_specials.default_pos = t[1];
	mob_proto[i].player.sex = t[2];
	}	else {
	mob_proto[i].player.class = 13;t[3] = 13;
    mob_proto[i].player.race = 17;
	mob_proto[i].player.race_align = 0;
	mob_proto[i].player.size = mob_find_size(17);
	mob_proto[i].char_specials.position = t[0];
    mob_proto[i].mob_specials.default_pos = t[1];
	mob_proto[i].player.sex = t[2];
	}


    mob_proto[i].player.height = 198;
	/*exp modifier, class/level*/
mob_proto[i].points.coins.gold = 0;
mob_proto[i].points.coins.plat = 0;
mob_proto[i].points.coins.silver = 0;
mob_proto[i].points.coins.copper = 0;

	/*Money adder*/
	k = 0;j=0;
	k = get_copper(i);
	j = ((60*k)/100);
	mob_proto[i].points.coins.plat = ((int) (j/1000));
	j = ((int)((20*k)/100)) + (j % 1000);
	mob_proto[i].points.coins.gold = ((int) (j/200));
	j = ((int)((18*k)/100)) + (j % 200);
	mob_proto[i].points.coins.silver = ((int) (j/20));
	if (mob_proto[i].player.level > 20)
		j = ((int)((.5*k)/100)) + (j % 50);
		j = ((int)((2*k)/100)) + (j % 50);
	mob_proto[i].points.coins.copper = j;

	mob_proto[i].points.coins.plat = MAX(0, mob_proto[i].points.coins.plat + GET_EX_PLAT(mob_proto + i));
	mob_proto[i].points.coins.gold = MAX(0, mob_proto[i].points.coins.gold + GET_EX_GOLD(mob_proto + i));

	/*auto ac stuff*/
/*	l = get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
    sprintf(buf, "get is: %d", l);
	mudlog(buf, BRF, LVL_IMPL, TRUE);
*/
	if ((mob_proto[i].mob_specials.ex_armor != 100))
		mob_proto[i].points.armor = mob_proto[i].mob_specials.ex_armor + get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
	else
		mob_proto[i].points.armor = (sh_int) get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));



		/*num of hp dice is hit*/
	GET_EXP(mob_proto + i) = get_set_exp(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i),  GET_ZONE(mob_proto + i));
	GET_EXP(mob_proto + i) += GET_EX_EXP(mob_proto + i);

	mob_proto[i].points.mana = get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 2);
	mob_proto[i].points.hit = 20;
	mob_proto[i].points.mana += mob_proto[i].mob_specials.ex_face;
	mob_proto[i].points.hit += mob_proto[i].mob_specials.ex_no_dice;
	GET_EX_MAIN_HP(mob_proto + i) = (get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1));

	mob_proto[i].points.damroll	= get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
	mob_proto[i].points.damroll	+= mob_proto[i].mob_specials.ex_damroll;
   // Changed to get rid of the -199 mobb hitrolls Do NOT change -Banyal
	mob_proto[i].points.hitroll = BOUNDED(10, get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i),
        GET_CLASS(mob_proto + i), 0), 80);
	mob_proto[i].points.hitroll += mob_proto[i].mob_specials.ex_hitroll;

	mob_proto[i].mob_specials.damnodice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 0);
    mob_proto[i].mob_specials.damnodice += mob_proto[i].mob_specials.ex_damnodice;
	mob_proto[i].mob_specials.damsizedice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
	mob_proto[i].mob_specials.damsizedice += mob_proto[i].mob_specials.ex_damsizedice;

/*last check values above 0*/
	mob_proto[i].mob_specials.damsizedice = MAX(0, mob_proto[i].mob_specials.damsizedice);
	mob_proto[i].mob_specials.damnodice = MAX(0, mob_proto[i].mob_specials.damnodice);
	mob_proto[i].points.hitroll = MAX(0, mob_proto[i].points.hitroll);
	mob_proto[i].points.damroll = MAX(0, mob_proto[i].points.damroll);
	mob_proto[i].points.armor = MIN(100, MAX(-100, mob_proto[i].points.armor));

	for (j = 0;j <= NUM_SPELL_CIRCLES - 4;j++)
	mob_proto[i].mob_specials.mem_memed[j] = spells_of_circle[(int)(mob_proto[i].player.level)][(j + 1)];
	for (j= 0; j <= 11;j++)
	mob_proto[i].mob_specials.mem_state[j] = 0;



	for (j = 0; j < 3; j++)
      GET_COND(mob_proto + i, j) = -1;

	for (j = 0; j < 4; j++)
      GET_INNT(mob_proto + i, j) = -1;

    /*
     * these are now save applies; base save numbers for MOBs are now from
     * the warrior save table.
     */
    for (j = 0; j < 5; j++)
      GET_SAVE(mob_proto + i, j) = 0;
set_mob_skills(i, t[3], t[4]);
}




/*
 * interpret_espec is the function that takes espec keywords and values
 * and assigns the correct value to the mob as appropriate.  Adding new
 * e-specs is absurdly easy -- just add a new CASE statement to this
 * function!  No other changes need to be made anywhere in the code.
 */

#define CASE(test) if (!matched && !str_cmp(keyword, test) && (matched = 1))
#define RANGE(low, high) (num_arg = MAX((low), MIN((high), (num_arg))))

void interpret_espec(char *keyword, char *value, int i, int nr)
{
  int num_arg, matched = 0;

  num_arg = atoi(value);

  CASE("BareHandAttack") {
    RANGE(0, 99);
    mob_proto[i].mob_specials.attack_type = num_arg;
  }

  CASE("Str") {
    RANGE(3, 25);
    mob_proto[i].real_abils.str = num_arg;
  }

  CASE("StrAdd") {
    RANGE(0, 100);
    mob_proto[i].real_abils.str_add = num_arg;
  }

  CASE("Int") {
    RANGE(3, 25);
    mob_proto[i].real_abils.intel = num_arg;
  }

  CASE("Wis") {
    RANGE(3, 25);
    mob_proto[i].real_abils.wis = num_arg;
  }

  CASE("Dex") {
    RANGE(3, 25);
    mob_proto[i].real_abils.dex = num_arg;
  }

  CASE("Con") {
    RANGE(3, 25);
    mob_proto[i].real_abils.con = num_arg;
  }

  CASE("Cha") {
    RANGE(3, 25);
    mob_proto[i].real_abils.cha = num_arg;
  }

  if (!matched) {
    fprintf(stderr, "Warning: unrecognized espec keyword %s in mob #%d\n",
	    keyword, nr);
  }
}

#undef CASE
#undef RANGE

void parse_espec(char *buf, int i, int nr)
{
  char *ptr;

  if ((ptr = strchr(buf, ':')) != NULL) {
    *(ptr++) = '\0';
    while (isspace(*ptr))
      ptr++;
  } else
    ptr = "";

  interpret_espec(buf, ptr, i, nr);
}


void parse_enhanced_mob(FILE *mob_f, int i, int nr)
{
  char line[256];

  parse_simple_mob(mob_f, i, nr);

  while (get_line(mob_f, line)) {
    if (!strcmp(line, "E"))	/* end of the ehanced section */
      return;
    else if (*line == '#') {	/* we've hit the next mob, maybe? */
      fprintf(stderr, "Unterminated E section in mob #%d\n", nr);
      exit(1);
    } else
      parse_espec(line, i, nr);
  }

  fprintf(stderr, "Unexpected end of file reached after mob #%d\n", nr);
  exit(1);
}


void parse_mobile(FILE * mob_f, int nr)
{
  static int i = 0;
  int j, t[10];
  char line[256], *tmpptr, letter;
  char f1[128], f2[128];

  mob_index[i].virtual = nr;
  mob_index[i].number = 0;
  mob_index[i].func = NULL;

  clear_char(mob_proto + i);

  mob_proto[i].player_specials = &dummy_mob;
  sprintf(buf2, "mob vnum %d", nr);

  /***** String data *** */
  mob_proto[i].player.name = fread_string(mob_f, buf2);
  tmpptr = mob_proto[i].player.short_descr = fread_string(mob_f, buf2);
  if (tmpptr && *tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
	!str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);
  mob_proto[i].player.long_descr = fread_string(mob_f, buf2);
  mob_proto[i].player.description = fread_string(mob_f, buf2);
  mob_proto[i].player.title = NULL;
  mob_proto[i].player.prompt = NULL;

  /* *** Numeric data *** */
  get_line(mob_f, line);
  sscanf(line, "%s %s %d %c", f1, f2, t + 2, &letter);
  MOB_FLAGS(mob_proto + i) = asciiflag_conv(f1);
  SET_BIT(MOB_FLAGS(mob_proto + i), MOB_ISNPC);
  AFF_FLAGS(mob_proto + i) = asciiflag_conv(f2);
  GET_ALIGNMENT(mob_proto + i) = t[2];

  switch (letter) {
  case 'S':	/* Simple monsters */
    parse_simple_mob(mob_f, i, nr);
    break;
  case 'E':	/* Circle3 Enhanced monsters */
    parse_enhanced_mob(mob_f, i, nr);
    break;
  /* add new mob types here.. */
  default:
    fprintf(stderr, "Unsupported mob type '%c' in mob #%d\n", letter, nr);
    exit(1);
    break;
  }

  letter = fread_letter(mob_f);
  ungetc(letter, mob_f);
  while (letter=='T') {
    dg_read_trigger(mob_f, &mob_proto[i], MOB_TRIGGER);
    letter = fread_letter(mob_f);
    ungetc(letter, mob_f);
  }


  mob_proto[i].aff_abils = mob_proto[i].real_abils;

  for (j = 0; j < NUM_WEARS; j++)
    mob_proto[i].equipment[j] = NULL;

  mob_proto[i].nr = i;
  mob_proto[i].desc = NULL;

  letter = fread_letter(mob_f);
   if (letter == '>') {
     ungetc(letter, mob_f);
     (void)  mprog_read_programs(mob_f, &mob_index[i]);
   } else ungetc(letter, mob_f);


  top_of_mobt = i++;
}




/* read all objects from obj file; generate index and prototypes */
char *parse_object(FILE * obj_f, int nr)
{
  static int i = 0, retval;
  static char line[256];
  int t[10], j;
  char *tmpptr;
  char f1[256], f2[256];
  struct extra_descr_data *new_descr;

  obj_index[i].virtual = nr;
  obj_index[i].number = 0;
  obj_index[i].func = NULL;

  clear_object(obj_proto + i);
  obj_proto[i].in_room = NOWHERE;
  obj_proto[i].item_number = i;

  sprintf(buf2, "object #%d", nr);

  /* *** string data *** */
  if ((obj_proto[i].name = fread_string(obj_f, buf2)) == NULL) {
    fprintf(stderr, "Null obj name or format error at or near %s\n", buf2);
    exit(1);
  }
  tmpptr = obj_proto[i].short_description = fread_string(obj_f, buf2);
  if (*tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
	!str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);

  tmpptr = obj_proto[i].description = fread_string(obj_f, buf2);
  if (tmpptr && *tmpptr)
    *tmpptr = UPPER(*tmpptr);
  obj_proto[i].action_description = fread_string(obj_f, buf2);

  /* *** numeric data *** */
  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, " %d %s %s", t, f1, f2)) != 3) {
    fprintf(stderr, "Format error in first numeric line (expecting 3 args, got %d), %s\n", retval, buf2);
   /* exit(1);*/
  }
  obj_proto[i].obj_flags.type_flag = t[0];
  obj_proto[i].obj_flags.extra_flags = asciiflag_conv(f1);
  obj_proto[i].obj_flags.wear_flags = asciiflag_conv(f2);

  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, "%d %d %d %d %d %d %d", t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6)) != 7) {
    fprintf(stderr, "Format error in second numeric line (expecting 7 args, got %d), %s\n", retval, buf2);
    /*exit(1);*/
  }
  obj_proto[i].obj_flags.value[0] = t[0];
  obj_proto[i].obj_flags.value[1] = t[1];
  obj_proto[i].obj_flags.value[2] = t[2];
  obj_proto[i].obj_flags.value[3] = t[3];
  obj_proto[i].spare1 = t[4];
  obj_proto[i].spare2 = t[5];
  obj_proto[i].spare3 = t[6];

  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, "%d %d %d %d %d %d %d %d", t, t + 1, t + 2, t + 3, t+ 4, t + 5, t + 6, t + 7)) != 8)
{
fprintf(stderr, "Format error in third numeric line (expecting 6 args, got %d), %s\n", retval, buf2);
    /*exit(1);*/
  }
  /* IF A PORTAL (ie == 24) */
  if (obj_proto[i].obj_flags.type_flag == 24){
	  obj_proto[i].obj_flags.weight = t[0];
	  obj_proto[i].obj_flags.cost = t[1];
	  obj_proto[i].obj_flags.timer = t[2];
	  obj_proto[i].obj_flags.spell_flags = t[3];
	  obj_proto[i].spell_component = t[4];
	  obj_proto[i].object_limitation = t[5];
         obj_proto[i].obj_flags.spell_flags2 = 0;
         obj_proto[i].obj_flags.spell_flags3 = 0;
  }

  else{
	  obj_proto[i].obj_flags.weight = t[0];
  obj_proto[i].obj_flags.cost = t[1];
  obj_proto[i].obj_flags.cost_per_day = t[2];
  obj_proto[i].obj_flags.spell_flags = t[3]; //Duh this was somehow removed -Banyal
   obj_proto[i].spell_component = t[4];
	  obj_proto[i].object_limitation = t[5];
         obj_proto[i].obj_flags.spell_flags2 = 0;
         obj_proto[i].obj_flags.spell_flags3 = 0;
  }

  /* check to make sure that weight of containers exceeds curr. quantity */
  if (obj_proto[i].obj_flags.type_flag == ITEM_DRINKCON ||
      obj_proto[i].obj_flags.type_flag == ITEM_FOUNTAIN) {
    if (obj_proto[i].obj_flags.weight < obj_proto[i].obj_flags.value[1])
      obj_proto[i].obj_flags.weight = obj_proto[i].obj_flags.value[1] + 5;
  }

  /* *** extra descriptions and affect fields *** */

  for (j = 0; j < MAX_OBJ_AFFECT; j++) {
    obj_proto[i].affected[j].location = APPLY_NONE;
    obj_proto[i].affected[j].modifier = 0;
  }

  strcat(buf2, ", after numeric constants (expecting E/A/#xxx)");
  j = 0;

  for (;;) {
    if (!get_line(obj_f, line)) {
      fprintf(stderr, "Format error in %s\n", buf2);
      exit(1);
    }
    switch (*line) {
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(obj_f, buf2);
      new_descr->description = fread_string(obj_f, buf2);
      new_descr->next = obj_proto[i].ex_description;
      obj_proto[i].ex_description = new_descr;
      break;
    case 'A':
      if (j >= MAX_OBJ_AFFECT) {
	fprintf(stderr, "Too many A fields (%d max), %s\n", MAX_OBJ_AFFECT, buf2);
	exit(1);
      }
      get_line(obj_f, line);
      sscanf(line, " %d %d ", t, t + 1);
      obj_proto[i].affected[j].location = t[0];
      obj_proto[i].affected[j].modifier = t[1];
      j++;
      break;

/*
** affect player flags (see AFF_XXX flags in structs.h )
** This allows players flags to be affected by an item, for example
** create a ring which gives the player permanent sense life when worn.
**
** Note: more 'C' fields are allowed because all found 'C' (set char bits)
**       fields are added to the current values. (nice for builders who
**       don't want those large bitvector numbers in the obj file).
*/
    case 'C':
      get_line(obj_f, line);
      sscanf(line, "%d ", t);
      obj_proto[i].obj_flags.bitvector = obj_proto[i].obj_flags.bitvector | t[0];
      break;
	case 'T':  /* DG triggers */
      dg_obj_trigger(line, &obj_proto[i]);
      break;

    case '$':
    case '#':
      top_of_objt = i++;
      return line;
      break;
    default:
      fprintf(stderr, "Format error in %s\n", buf2);
      exit(1);
      break;
    }
  }
}


#define Z	zone_table[zone]

/* load the zone table and command tables */
void load_zones(FILE * fl, char *zonename)
{
  static int zone = 0;
  int cmd_no = 0, num_of_cmds = 0, line_num = 0, tmp, error;
  char *ptr, buf[256], zname[256];

  strcpy(zname, zonename);

  while (get_line(fl, buf))
    num_of_cmds++;		/* this should be correct within 3 or so */
  rewind(fl);

  if (num_of_cmds == 0) {
    fprintf(stderr, "%s is empty!\n", zname);
    exit(0);
  } else
    CREATE(Z.cmd, struct reset_com, num_of_cmds);

  line_num += get_line(fl, buf);

  if (sscanf(buf, "#%d", &Z.number) != 1) {
    fprintf(stderr, "Format error in %s, line %d\n", zname, line_num);
    exit(0);
  }
  sprintf(buf2, "beginning of zone #%d", Z.number);

  line_num += get_line(fl, buf);
  if ((ptr = strchr(buf, '~')) != NULL)	/* take off the '~' if it's there */
    *ptr = '\0';
  Z.name = str_dup(buf);

  line_num += get_line(fl, buf);
  if (sscanf(buf, " %d %d %d %d %d %d", &Z.top, &Z.lifespan,
         &Z.reset_mode, &Z.zone_factor, &Z.hemisphere, &Z.climate) != 4)
   Z.zone_factor = 100;
 /* fprintf(stderr, " %d me this one has a factor of %d done by set by
me, line \n", Z.number, Z.zone_factor);
   *//*
  cmd_no = 0;
	   */
  for (;;) {
    if ((tmp = get_line(fl, buf)) == 0) {
      fprintf(stderr, "Format error in %s - premature end of file\n", zname);
      exit(0);
    }
    line_num += tmp;
    ptr = buf;
    skip_spaces(&ptr);

    if ((ZCMD.command = *ptr) == '*')
      continue;

    ptr++;

    if (ZCMD.command == 'S' || ZCMD.command == '$') {
      ZCMD.command = 'S';
      break;
    }
    error = 0;
	if (ZCMD.command == 'F')  /* force mobile command */ {
      skip_spaces(&ptr);
      if (*ptr) {
        tmp = *ptr;
        ptr++;
        skip_spaces(&ptr);
        ZCMD.sarg = str_dup(ptr);
      } else
        error = 1;
    } else
    if (strchr("MOEPD", ZCMD.command) == NULL) {	/* a 3-arg command */
      if (sscanf(ptr, " %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2) != 3)
	error = 1;
    } else {
      if (sscanf(ptr, " %d %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2,
		 &ZCMD.arg3) != 4)
	error = 1;
    }

    ZCMD.if_flag = tmp;

    if (error) {
      fprintf(stderr, "Format error in %s, line %d: '%s'\n", zname,
line_num, buf);
      exit(0);
    }
    ZCMD.line = line_num;
    cmd_no++;
  }

  top_of_zone_table = zone++;
}

#undef Z


void get_one_line(FILE *fl, char *buf)
{
  if (fgets(buf, READ_SIZE, fl) == NULL) {
    log("error reading help file: not terminated with $?");
    exit(1);
  }

  buf[strlen(buf) - 1] = '\0'; /* take off the trailing \n */
}


void load_help(FILE *fl)
{
  char key[READ_SIZE+1], next_key[READ_SIZE+1], entry[32384];
  char line[READ_SIZE+1], *scan;
  struct help_index_element el;

  /* get the first keyword line */
  get_one_line(fl, key);
  while (*key != '$') {
    /* read in the corresponding help entry */
    strcpy(entry, strcat(key, "\r\n"));
    get_one_line(fl, line);
    while (*line != '#') {
      strcat(entry, strcat(line, "\r\n"));
      get_one_line(fl, line);
    }

    el.min_level = 0;
    if ((*line == '#') && (*(line + 1) != 0))
      el.min_level = atoi((line + 1));

    el.min_level = MAX(0, MIN(el.min_level, LVL_IMPL));



    /* now, add the entry to the index with each keyword on the keyword line */
    el.duplicate = 0;
    el.entry = str_dup(entry);
    scan = one_word(key, next_key);
    while (*next_key) {
      el.keyword = str_dup(next_key);
      help_table[top_of_helpt++] = el;
      el.duplicate++;
      scan = one_word(scan, next_key);
    }

    /* get next keyword line (or $) */
    get_one_line(fl, key);
  }
}


int hsort(const void *a, const void *b)
{
  struct help_index_element *a1, *b1;

  a1 = (struct help_index_element *) a;
  b1 = (struct help_index_element *) b;

  return (str_cmp(a1->keyword, b1->keyword));
}


/*************************************************************************
*  procedures for resetting, both play-time and boot-time	 	 *
*********************************************************************** */



int vnum_mobile(char *searchname, struct char_data * ch)
{
  int nr, found = 0;

  for (nr = 0; nr <= top_of_mobt; nr++) {
    if (isname(searchname, mob_proto[nr].player.name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      mob_index[nr].virtual,
	      mob_proto[nr].player.short_descr);
      send_to_char(buf, ch);
    }
  }

  return (found);
}



int vnum_object(char *searchname, struct char_data * ch)
{
  int nr, found = 0;

  for (nr = 0; nr <= top_of_objt; nr++) {
    if (isname(searchname, obj_proto[nr].name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      obj_index[nr].virtual,
	      obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }
  return (found);
}


int vnum_mob_zone(int zone, struct char_data *ch)
{
  int r_num, nr, found = 0;

  for (nr = (zone_table[zone].number)*100;nr <= zone_table[zone].top;nr++)
     if((r_num = real_mobile(nr)) >= 0) {
	sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
		mob_index[r_num].virtual,
		mob_proto[r_num].player.short_descr);
	send_to_char(buf, ch);
     }
  return found;
}

int vnum_object_zone(int zone, struct char_data *ch)
{
  int r_num, nr, found = 0;

  for (nr = (zone_table[zone].number)*100;nr < zone_table[zone].top;nr++)
     if((r_num = real_object(nr)) >= 0) {
	sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
		obj_index[r_num].virtual,
		obj_proto[r_num].short_description);
	send_to_char(buf, ch);
     }
  return found;
}


/* create a character, and add it to the char list */
struct char_data *create_char(void)
{
  struct char_data *ch;

  CREATE(ch, struct char_data, 1);
  clear_char(ch);
  ch->next = character_list;
  character_list = ch;
  GET_ID(ch) = max_id++;
  return ch;
}


/* create a new mobile from a prototype */
struct char_data *read_mobile(int nr, int type)
{
  int i;
  struct char_data *mob;

  if (type == VIRTUAL) {
    if ((i = real_mobile(nr)) < 0) {
      sprintf(buf, "Mobile (V) %d does not exist in database.", nr);
      return (0);
    }
  } else
    i = nr;

  CREATE(mob, struct char_data, 1);
  clear_char(mob);
  *mob = mob_proto[i];
  mob->next = character_list;
  character_list = mob;

if (!mob->points.max_hit) {    mob->points.max_hit = MAX(0, MIN(32000,
(dice(mob->points.hit, mob->points.mana) +   GET_EX_MAIN_HP(mob) +
mob->points.move)));      } else    mob->points.max_hit =
number(mob->points.hit, mob->points.mana);


  mob->points.mana = mob->points.max_mana; /*rests mobs mana*/
  mob->points.move = mob->points.max_move;/*resets mob moves*/
  mob->points.hit = mob->points.max_hit;   /*sets full hps*/

  mob->player.time.birth = time(0);
  mob->player.time.played = 0;
  mob->player.time.logon = time(0);

  mob_index[i].number++;
  GET_ID(mob) = max_id++;
  assign_triggers(mob, MOB_TRIGGER);

  return mob;
}

/* create an object, and add it to the object list */
struct obj_data *create_obj(void)
{
  struct obj_data *obj;

  CREATE(obj, struct obj_data, 1);
  clear_object(obj);
  obj->next = object_list;
  object_list = obj;
  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  return obj;
}


/* create a new object from a prototype */
struct obj_data *read_object(int nr, int type)
{
  struct obj_data *obj;
  int i;

  if (nr < 0) {
    log("SYSERR: trying to create obj with negative num!");
    return NULL;
  }
  if (type == VIRTUAL) {
    if ((i = real_object(nr)) < 0) {
      sprintf(buf, "Object (V) %d does not exist in database.", nr);
      return NULL;
    }
  } else
    i = nr;

  CREATE(obj, struct obj_data, 1);
  clear_object(obj);
  *obj = obj_proto[i];
  obj->next = object_list;
  object_list = obj;

  obj_index[i].number++;
  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  return obj;
}



#define ZO_DEAD  999

/* update zone ages, queue for reset if necessary, and dequeue when possible */
void zone_update(void)
{
  int i;
  struct reset_q_element *update_u, *temp;
  static int timer = 0;
  char buf[128];

  /* jelson 10/22/92 */
  if (((++timer * PULSE_ZONE) / PASSES_PER_SEC) >= 60) {
    /* one minute has passed */
    /*
     * NOT accurate unless PULSE_ZONE is a multiple of PASSES_PER_SEC or a
     * factor of 60
     */

    timer = 0;

    /* since one minute has passed, increment zone ages */
    for (i = 0; i <= top_of_zone_table; i++) {
      if (zone_table[i].age < zone_table[i].lifespan &&
	  zone_table[i].reset_mode)
	(zone_table[i].age)++;

      if (zone_table[i].age >= zone_table[i].lifespan &&
	  zone_table[i].age < ZO_DEAD && zone_table[i].reset_mode) {
	/* enqueue zone */

	CREATE(update_u, struct reset_q_element, 1);

	update_u->zone_to_reset = i;
	update_u->next = 0;

	if (!reset_q.head)
	  reset_q.head = reset_q.tail = update_u;
	else {
	  reset_q.tail->next = update_u;
	  reset_q.tail = update_u;
	}

	zone_table[i].age = ZO_DEAD;
      }
    }
  }	/* end - one minute has passed */


  /* dequeue zones (if possible) and reset */
  /* this code is executed every 10 seconds (i.e. PULSE_ZONE) */
  for (update_u = reset_q.head; update_u; update_u = update_u->next)
    if (zone_table[update_u->zone_to_reset].reset_mode == 2 ||
	is_empty(update_u->zone_to_reset)) {
      reset_zone(update_u->zone_to_reset, FALSE);
      sprintf(buf, "Auto zone reset: %s",
	      zone_table[update_u->zone_to_reset].name);
      mudlog(buf, CMP, LVL_GOD, FALSE);
      /* dequeue */
      if (update_u == reset_q.head)
	reset_q.head = reset_q.head->next;
      else {
	for (temp = reset_q.head; temp->next != update_u;
	     temp = temp->next);

	if (!update_u->next)
	  reset_q.tail = temp;

	temp->next = update_u->next;
      }

      free(update_u);
      break;
    }
}

void log_zone_error(int zone, int cmd_no, char *message)
{
  char buf[256];

  sprintf(buf, "SYSERR: error in zone file: %s", message);
  mudlog(buf, NRM, LVL_GOD, TRUE);

  sprintf(buf, "SYSERR: ...offending cmd: '%c' cmd in zone #%d, line %d",
	  ZCMD.command, zone_table[zone].number, ZCMD.line);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}

#define ZONE_ERROR(message) \
	{ log_zone_error(zone, cmd_no, message); last_cmd = 0; }

/* execute the reset command table of a given zone */
void reset_zone(int zone, byte pop)
{
  int cmd_no, last_cmd = 0;
  struct char_data *mob = NULL;
  struct obj_data *obj, *obj_to;

  for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {

    if (ZCMD.if_flag && !last_cmd)
      continue;

    switch (ZCMD.command) {
    case '*':			/* ignore command */
      last_cmd = 0;
      break;

	case 'F':           /* force mobile to do action */
      if (!mob) {
        ZONE_ERROR("attempt to force-command a non-existant mob");
        break;
      }
      command_interpreter(mob, ZCMD.sarg);
      break;

    case 'M':			/* read a mobile */
      if (mob_index[ZCMD.arg1].number < ZCMD.arg2) {
	mob = read_mobile(ZCMD.arg1, REAL);
	char_to_room(mob, ZCMD.arg3);
	last_cmd = 1;
      } else
	last_cmd = 0;
      break;

    case 'O':			/* read an object */

		if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
		{
			obj = read_object(ZCMD.arg1, REAL);
			if (ZCMD.arg3 >= 0)
			{
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					obj_to_room(obj, ZCMD.arg3);
					last_cmd = 1;
				}else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			}
			else
			{
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					obj->in_room = NOWHERE;
					last_cmd = 1;
				}
				else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			}
		}
		else
			last_cmd = 0;
		break;

    case 'P':			/* object to object */
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
		{
			obj = read_object(ZCMD.arg1, REAL);
			if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
			{
				if (!(obj_to = get_obj_num(ZCMD.arg3)))
				{
					ZONE_ERROR("target obj not found");
					extract_obj(obj);
					break;
				}
				obj_to_obj(obj, obj_to);
				OBJ_INDEX_LIMIT(obj->item_number) ++;
				last_cmd = 1;
			}
			else
			{
				last_cmd = 0;
				extract_obj(obj);
			}
		}
		else
			last_cmd = 0;
		break;

    case 'G':			/* obj_to_char */
		if (!mob)
		{
			ZONE_ERROR("attempt to give obj to non-existant mob");
			break;
		}
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
		{
			obj = read_object(ZCMD.arg1, REAL);
			if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
			{
				OBJ_INDEX_LIMIT(obj->item_number) ++;
				obj_to_char(obj, mob);
				last_cmd = 1;
			}else
			{
				last_cmd = 0;
				extract_obj(obj);
			}
		}
		else
			last_cmd = 0;
		break;

    case 'E':			/* object to equipment list */
        if (!mob)
		{
			ZONE_ERROR("trying to equip non-existant mob");
			break;
		}/*was make sure number less then ZCMD.arg2*/
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
		{
			if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS)
			{
				ZONE_ERROR("invalid equipment pos number");
			}
			else
			{
				obj = read_object(ZCMD.arg1, REAL);
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					equip_char(mob, obj, ZCMD.arg3);
					last_cmd = 1;
				}
				else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			}
		}
	  else
		last_cmd = 0;
      break;

    case 'R': /* rem obj from room */
      if ((obj = get_obj_in_list_num(ZCMD.arg2, world[ZCMD.arg1].contents)) != NULL) {
        obj_from_room(obj);
        extract_obj(obj);
      }
      last_cmd = 1;
      break;


    case 'D':			/* set state of door */
      if (ZCMD.arg2 < 0 || ZCMD.arg2 >= NUM_OF_DIRS ||
	  (world[ZCMD.arg1].dir_option[ZCMD.arg2] == NULL)) {
	ZONE_ERROR("door does not exist");
      } else
	switch (ZCMD.arg3) {
	case 0:
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
             EX_HIDDEN);
	  break;
	case 1:
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
             EX_HIDDEN);
	  break;
	case 2:
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_LOCKED);
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
          EX_HIDDEN);
	  break;
	case 3:
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_LOCKED);
          break;
   case 4:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_LOCKED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          break;
   case 5:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_LOCKED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          break;
	}
      last_cmd = 1;
      break;

    default:
      ZONE_ERROR("unknown cmd in reset table; cmd disabled");
      ZCMD.command = '*';
      break;
    }
  }

  zone_table[zone].age = 0;
}



/* for use in reset_zone; return TRUE if zone 'nr' is free of PC's  */
int is_empty(int zone_nr)
{
  struct descriptor_data *i;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected)
      if (world[i->character->in_room].zone == zone_nr)
	return 0;

  return 1;
}


#define MOB_MENTAL3    33
void reset_mob(struct char_data *mob, int caster_level, int i, int type, struct obj_data * obj)
{
int cfactor = 100;
int sfactor = 100;
int tfactor = 100;
int mobfactor = 100;
int corpsefactor = 100;
int decrease = 100;
sh_int main  = 0;
int corpse_level = 0;
sh_int face = 0;/*this function was written by Proky, what it does is
reset a mobs "statistics"
to suite the level of the owner (if called because a mob summmons)*/
	if (obj)
		corpse_level = CORPSE_LEVEL(obj);
	if (!corpse_level)
	{/*if this is case then not usinga  corpse*/
		corpse_level = MIN(70, (caster_level + (5 - number(0, 7))));
	}
	else
	{/*involve the casters level here */
		if ((caster_level - corpse_level) < 1)
			corpse_level = (MIN(70, ((corpse_level - number(1, 3)))));
		else if ((caster_level - corpse_level) < 10)
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 2)));
		else if ((caster_level - corpse_level) < 20)
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 5)));
		else if ((caster_level - corpse_level) < 30)
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 8)));
		else
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 15)));
	}
	i = GET_MOB_RNUM(mob);
/*mob exp cut down*//*giving it the exp of a mob half its level*/
	GET_LEVEL(mob) = corpse_level;
	GET_EXP(mob) = (long)(get_set_exp(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), GET_ZONE(mob))/2);
	GET_EXP(mob) = MAX(0, (GET_EXP(mob) + GET_EX_EXP(mob_proto + i)));

/*mob bonus*/
	switch(GET_CLASS(mob))
	{
	case MCLASS_VOID:
		cfactor = 100;
		break;
	case MCLASS_SORCERER:
		cfactor = 90;
		break;
	case MCLASS_CLERIC:
		cfactor = 100;
		break;
	case MCLASS_WARRIOR:
		cfactor = 110;
		break;
	case MCLASS_THIEF:
		cfactor = 80;
		break;
	default:
		cfactor = 100;
		break;
	}
	switch(GET_MOB_VNUM(mob))
	{
		case MOB_ZOMBIE:
			if (obj)
				if (GET_OBJ_MOB_FROM(obj))
				{
					if(GET_LDESC(mob))
					{
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
					}
				}
					mobfactor = 100;
			break;
case  (MOB_ZOMBIE + 1):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);

}
                                }

mobfactor =  90;
break;
case(MOB_ZOMBIE  + 2):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);

}
                                }

mobfactor = 100;
break;
case  (MOB_ZOMBIE  +  3):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);

}
                                }

mobfactor = 140;
break;
case (MOB_ZOMBIE+ 4):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);

}
                                }

mobfactor = 75;
break;
case (MOB_ZOMBIE +  5):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);

}
                                }

mobfactor =  120;
break;
case (4):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 200;
break;

case (5):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 180;
break;

case (6):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 170;
break;

case (7):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 160;
break;

case (29):
mobfactor = 180;
break;
case (30):
mobfactor = 150;
break;
case (MOB_MENTAL3 + 0):
mobfactor = 130;
break;

case (MOB_MENTAL3 + 1):
mobfactor = 130;
break;

case (MOB_MENTAL3 + 2):
mobfactor = 120;
break;
case (MOB_MENTAL3 + 3):
mobfactor = 120;
break;

default:
mobfactor =  100;
break;

}
	switch(GET_RACE(mob))
	{
	case SPECIES_OTHER:
		sfactor = 100;
		break;
	case SPECIES_UNDEAD:
		sfactor = 100;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 110;
		break;
	case SPECIES_GOBLIN:
		sfactor = 70;
		break;
	default:
		sfactor = 100;
		break;
	}
	switch(type)
	{
	case SPELL_SUMMON_DRACOLICH:
		tfactor = 120;
		break;
	case SPELL_SUMMON_ELEMENTAL:
		tfactor = 100;
		break;
	case SPELL_SUMMON_GREATER_DEMON:
		tfactor = 140;
		break;
	case SPELL_SUMMON_DEMON:
		tfactor = 110;
		break;
	case SPELL_ANIMATE_DEAD:
		tfactor = 100;
		break;
	default:
		tfactor = 100;
		break;
	}
	/*corpse species bonus*/
	if (obj)
		if (GET_OBJ_MOB_FROM(obj))
		{
			switch(mob_proto[GET_OBJ_MOB_FROM(obj)].player.race)
			{
			case SPECIES_HUMAN:
				corpsefactor = 100;
				break;
			case SPECIES_OTHER:
				corpsefactor = 100;
				break;
			case SPECIES_UNDEAD:
				corpsefactor = 100;
				break;
			case SPECIES_HUMANOID:
				corpsefactor = 100;
				break;
			case SPECIES_DRAGON:
				corpsefactor = 120;
				break;
			case SPECIES_DEMON:
				corpsefactor = 110;
				break;
			case SPECIES_GIANT:
				corpsefactor = 110;
				break;
			case SPECIES_GOBLIN:
				corpsefactor = 75;
				break;
			default:
				corpsefactor = 100;
				break;
			}
		}
/*fix factors*/
tfactor = ((int)((sfactor + tfactor + cfactor)/3));

	if (GET_LEVEL(mob) < 40)
	main = (sh_int)((GET_LEVEL(mob) * (int)(GET_LEVEL(mob)/5))); 	/*50 and under equation*/
	else
	main =  320;

	if (GET_LEVEL(mob) <=10)
		face = 10;
	else if (GET_LEVEL(mob) <=10)
	{
		face = 15;
	}
	else if (GET_LEVEL(mob) <= 20)
	{
		face = 15;
	}
	else if (GET_LEVEL(mob) <= 30)
	{
		face = 20;
	}
	else if (GET_LEVEL(mob) <= 40)
	{
		face = 25;
	}
	else if (GET_LEVEL(mob) <= 50)
	{
		face = 30;
	}
	else if (GET_LEVEL(mob) <= 60)
	{
		face = 35;
	}
	else
		face = 40;
	if (mobfactor > 100)
		face = (sh_int) (((float)mobfactor/100)* face);

main = (sh_int)  (main + (number(1, face) * 10));
/*finally taking the factors into account*/
	main = (sh_int) (((float)corpsefactor/100)*((float)tfactor/100) *
main);
	if (mobfactor < 100)
		main = (sh_int) (((float)mobfactor/100)* main);
/*hp factors taken into account*/

	GET_MAX_HIT(mob)= MAX(1, (main  + GET_MOVE(mob_proto +
i)));
	GET_HIT(mob) = GET_MAX_HIT(mob);

	/* I decrease all these values by a bit because they do rock to much*/
	decrease = 90;
	if (GET_LEVEL(mob) < 20)
		decrease = 90;
	else if (GET_LEVEL(mob) < 30)
		decrease = 75;
	else if (GET_LEVEL(mob) < 40)
		decrease = 60;
	else if (GET_LEVEL(mob) < 50)
		decrease = 55;
	else if (GET_LEVEL(mob) < 55)
		decrease = 50;
	else
		decrease = 50;
	GET_DAMROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);
	GET_DAMROLL(mob) = MAX(1, (GET_DAMROLL(mob) + mob_proto[i].mob_specials.ex_damroll));
	GET_DAMROLL(mob) = (sbyte)(GET_DAMROLL(mob)*((int)corpsefactor/100));
	/*hit roll is fine dont need to decrease this*/
	decrease = 100;
	GET_HITROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1))/100);
	GET_HITROLL(mob) = MAX(1, (GET_HITROLL(mob) + mob_proto[i].mob_specials.ex_hitroll));
	GET_HITROLL(mob) = BOUNDED(10, (sbyte)(GET_HITROLL(mob)*((int)corpsefactor/100)), 60);
	/*dice value should be decreased*/
	decrease = 100;
	if (GET_LEVEL(mob) < 20)
		decrease = 100;
	else if (GET_LEVEL(mob) < 30)
		decrease = 80;
	else if (GET_LEVEL(mob) < 40)
		decrease = 65;
	else if (GET_LEVEL(mob) < 50)
		decrease = 60;
	else if (GET_LEVEL(mob) < 55)
		decrease = 55;
	else
		decrease = 53;

	GET_NDD(mob) = (int)(decrease*(get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);
	GET_NDD(mob) = MAX(1, (GET_NDD(mob) + mob_proto[i].mob_specials.ex_damnodice));
	GET_NDD(mob) = (int)(GET_NDD(mob)*((int)corpsefactor/100));
	GET_SDD(mob) = get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1);
	GET_SDD(mob) = MAX(1, (GET_SDD(mob) + mob_proto[i].mob_specials.ex_damsizedice));
	GET_SDD(mob) = (int)(GET_SDD(mob)*((int)corpsefactor/100));
	GET_PLAT(mob) = 0;
	GET_GOLD(mob) = 0;
	GET_SILVER(mob) = 0;
	GET_COPPER(mob) = 0;


}


/*************************************************************************
*  stuff related to the save/load player system				 *
*********************************************************************** */


long get_id_by_name(char *name)
{
  int i;

  one_argument(name, arg);
  for (i = 0; i <= top_of_p_table; i++)
    if (!strcmp((player_table + i)->name, arg))
      return ((player_table + i)->id);

  return -1;
}


char *get_name_by_id(long id)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    if ((player_table + i)->id == id)
      return ((player_table + i)->name);

  return NULL;
}


/* Load a char, TRUE if loaded, FALSE if not */
int load_char(char *name, struct char_file_u * char_element)
{
  int player_i;
  int find_name(char *name);

  if ((player_i = find_name(name)) >= 0) {
    fseek(player_fl, (long) (player_i * sizeof(struct char_file_u)), SEEK_SET);
    fread(char_element, sizeof(struct char_file_u), 1, player_fl);
    return (player_i);
 }else
    return (-1);
}




/*
 * write the vital data of a player to the player file
 *
 * NOTE: load_room should be an *RNUM* now.  It is converted to a vnum here.
 */
void save_char(struct char_data * ch, int load_room)
{
  struct char_file_u st;

  if (IS_NPC(ch) || !ch->desc || GET_PFILEPOS(ch) < 0)
    return;

  char_to_store(ch, &st);

  strncpy(st.host, ch->desc->host, HOST_LENGTH);
  st.host[HOST_LENGTH] = '\0';

//    if (load_room == NOWHERE);
// else
   //   st.player_specials_saved.load_room = world[load_room].number;

  strcpy(st.pwd, GET_PASSWD(ch));

  fseek(player_fl, GET_PFILEPOS(ch) * sizeof(struct char_file_u), SEEK_SET);
  fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
}


int static_ac(int dex)
{
   if (dex <= 8)
      return 10;
   else if (dex <= 10)
      return 15;
   else if (dex <= 14)
      return 20;
   else if (dex <= 16)
      return 25;
   else if (dex <= 18)
      return 30;
   else if (dex <= 19)
      return 35;
   else if (dex <= 20)
      return 40;
   else if (dex <= 21)
      return 45;
   else
      return 50;
}

/* copy data from the file structure to a char struct */
/* redone by proky...Banyal*/
void store_to_char(struct char_file_u * st, struct char_data * ch)
{
  int i,member_found=0;
  sh_int clan_num;

  /* to save memory, only PC's -- not MOB's -- have player_specials */
  if (ch->player_specials == NULL)
    CREATE(ch->player_specials, struct player_special_data, 1);

  GET_SEX(ch) = st->sex;
  GET_CLASS(ch) = st->class;
  GET_RACE(ch) = st->race;
  GET_LEVEL(ch) = st->level;
  GET_RACE_ALIGN(ch) = st->race_align;
  GET_SIZE(ch) = st->size;


  ch->guarded_by = NULL;
  ch->guarding = NULL;
  ch->player.short_descr = NULL;
  ch->player.long_descr = NULL;
  ch->player.title = str_dup(st->title);
  ch->player.prompt = str_dup(st->prompt);
  ch->player.description = str_dup(st->description);

  ch->player.hometown = st->hometown;
  ch->player.time.birth = st->birth;
  ch->player.time.played = st->played;
  ch->player.time.logon = time(0);

  ch->player.weight = st->weight;
  ch->player.height = st->height;
  ch->player.size = st->size;
  ch->view_abils = st->abilities;
  ch->vaff_abils = st->abilities;

  ch->points = st->points;
  ch->char_specials.saved = st->char_specials_saved;
  ch->player_specials->saved = st->player_specials_saved;

  /* fixes funky saving throws - nechtrous */
  GET_SAVE(ch, SAVING_PARA) = 0;
  GET_SAVE(ch, SAVING_ROD) = 0;
  GET_SAVE(ch, SAVING_PETRI) = 0;
  GET_SAVE(ch, SAVING_BREATH) = 0;
  GET_SAVE(ch, SAVING_SPELL) = 0;

  /* once the specials are read in, go ahead and set the skills up */
  update_skills(ch);

  POOFIN(ch) = NULL;
  POOFOUT(ch) = NULL;

  if (ch->points.max_mana < 100)
    ch->points.max_mana = 100;

  ch->char_specials.carry_weight = 0;
  ch->char_specials.carry_items = 0;

  ch->points.armor = 100;
  /*Real race stuff....Banyal
  ch->points.hitroll = 0;
  ch->points.damroll = 0;*/
  ch->char_specials.hitgain = 0;
  ch->char_specials.managain = 0;

  /* clan snoop. -2 = no snoop, -1 = snoop all, # = snoop clan # ..  nechtrous */
  ch->clan_snoop = -2;

  /* for variable page_string -nechtrous*/
  ch->page_length = 22; /* 22 is default right now, can make saveable later*/

  if (ch->player.name == NULL)
    CREATE(ch->player.name, char, strlen(st->name) + 1);
  strcpy(ch->player.name, st->name);
  strcpy(ch->player.passwd, st->pwd);

  /* Add all spell effects */
  for (i = 0; i < MAX_AFFECT; i++) {
    if (st->affected[i].type)
      affect_to_char(ch, &st->affected[i]);
  }

  /* Check to see that this person is in their clan list, if not, add -nech*/
  if(GET_CLAN(ch) && GET_CLAN_RANK(ch)>0) {
    clan_num=find_clan_by_id(GET_CLAN(ch));
    for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
      if(!strcmp(clan[clan_num].member_list[i], GET_NAME(ch)))
        member_found = 1;
    if(!member_found)
      for(i=0;i<MAX_MEMBERS_PER_CLAN && clan[clan_num].member_list[i][0];i++);
      strcpy(clan[clan_num].member_list[i], GET_NAME(ch));
      update_clan(ch, clan_num);
  }

  /*
   * If you're not poisioned and you've been away for more than an hour of
   * real time, we'll set your HMV back to full
   */

  if (!IS_AFFECTED(ch, AFF_POISON) &&
      (((long) (time(0) - st->last_logon)) >= SECS_PER_REAL_HOUR)) {
    GET_HIT(ch) = GET_MAX_HIT(ch);
    GET_MOVE(ch) = GET_MAX_MOVE(ch);
    GET_MANA(ch) = GET_MAX_MANA(ch);
  }

 do_newbie(ch);

  if (!IS_AFFECTED(ch, AFF_INFRAVISION)){
	  switch (GET_RACE(ch)){
		   case RACE_DROW_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_DWARF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_DUERGAR:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_HALFLING:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
	  if (!IS_AFFECTED(ch, AFF_SENSE_LIFE))
	  SET_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
    break;
case RACE_TROLL:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_OGRE:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_HALF_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_GNOME:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
	  break;
  }}

  assign_mem_list(ch);

}				/* store_to_char */

int con_aff(struct char_data *ch)
{
    int bonus = 0;
//	int prevbonus = 0;

	if (GET_CON(ch) < 10)
        bonus = GET_LEVEL(ch) * -1;
    else if (GET_CON(ch) < 17)
        bonus = 0;
    else if (GET_CON(ch) < 19)
        bonus = GET_LEVEL(ch) * 1;
    else if (GET_CON(ch) < 21)
        bonus = GET_LEVEL(ch) * 2;
    else if (GET_CON(ch) < 23)
        bonus = GET_LEVEL(ch) * 2;
    else if (GET_CON(ch) < 25)
        bonus = GET_LEVEL(ch) * 3;
	else if (GET_CON(ch) < 26)
		bonus = GET_LEVEL(ch) * 4;
   else
      bonus = GET_LEVEL(ch) * 5;

   return bonus;
}

void update_stats(struct char_data *ch)
{
   int tmphps;
int x;
   /*AC change*/
   GET_AC(ch) = 100 - (static_ac(GET_DEX(ch)) + total_stats_of_wears(ch, APPLY_AC));
   /*max min this*/
   GET_AC(ch) = MIN(100, MAX(-100, GET_AC(ch)));
   /*Hit bonus*/
   tmphps = GET_MAX_HIT(ch) - GET_HIT(ch);
   GET_MAX_HIT(ch) = GET_NATHPS(ch) + con_aff(ch) + total_stats_of_wears(ch, APPLY_HIT);
   if (tmphps == 0)/*restore hps*/
   {
      alter_hit(ch, (0 - (GET_MAX_HIT(ch) - GET_HIT(ch))), 1);
   }
 x = GET_MAX_HIT(ch) - GET_HIT(ch);
   x = x - tmphps;   alter_hit(ch, 0 - x, 2);

}


int total_stats_of_wears(struct char_data *ch, int TYPE)
{
   int value = 0;
   int i, j;
   struct affected_type *af;
/*APPLY_AC = 17, ITEM_ARMOR = 9, APPLY_HIT = 13*/
   for (i = 0; i < NUM_WEARS; i++)
   {
      if (GET_EQ(ch, i))
      {
         if ((GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR) && (TYPE == APPLY_AC))
            value = value + GET_OBJ_VAL(GET_EQ(ch, i), 0);
         for (j = 0; j < MAX_OBJ_AFFECT; j++)
         {
            if (GET_EQ(ch, i)->affected[j].location == TYPE)
               value = value + GET_EQ(ch, i)->affected[j].modifier;
         }
      }
   }
   for (af = ch->affected; af; af = af->next)
   {
      if (TYPE == af->location)
      {
         if (TYPE == APPLY_AC)
            value = value - af->modifier;
         else
            value = value + af->modifier;
      }
   }
   return value;
}



/* Two functions here done by proky for his chages in car_to_ store */

void change_affected_stats(struct char_data * ch)
{
	GET_ADD(ch) = GET_ADD_VAFF(ch);
		switch (GET_RACE(ch)) {
	case RACE_GNOME:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)GNOME_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)GNOME_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)GNOME_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)GNOME_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)GNOME_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)GNOME_CON));
	break;
	case RACE_OGRE:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)OGRE_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)OGRE_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)OGRE_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)OGRE_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)OGRE_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)OGRE_CON));
		break;
	case RACE_HUMAN:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HUMAN_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HUMAN_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HUMAN_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HUMAN_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HUMAN_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HUMAN_CON));
		break;
	case RACE_BARBARIAN:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)BARBARIAN_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)BARBARIAN_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)BARBARIAN_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)BARBARIAN_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)BARBARIAN_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)BARBARIAN_CON));
		break;
	case RACE_TROLL:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)TROLL_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)TROLL_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)TROLL_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)TROLL_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)TROLL_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)TROLL_CON));
		break;
	case RACE_HALF_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALF_ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALF_ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALF_ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALF_ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALF_ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALF_ELF_CON));
		break;
	case RACE_DROW_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DROW_ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DROW_ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DROW_ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DROW_ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DROW_ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DROW_ELF_CON));
		break;
	case RACE_HALFLING:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALFLING_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALFLING_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALFLING_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALFLING_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALFLING_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALFLING_CON));
		break;
	case RACE_DWARF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DWARF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DWARF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DWARF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DWARF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DWARF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DWARF_CON));
		break;
	case RACE_DUERGAR:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DUERGAR_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DUERGAR_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DUERGAR_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DUERGAR_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DUERGAR_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DUERGAR_CON));
	break;
	case RACE_ORC:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ORC_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ORC_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ORC_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ORC_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ORC_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ORC_CON));
	break;
	case RACE_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ELF_CON));
	break;
	}
   return;
}

void load_results(struct char_data *ch)
{
	/*Ok this function's aim is to convert the data in view_abils
	into the function the computer uses real_abils, then it will aslo
	add any effects that might be effecting the player*/
	GET_RADD(ch) = GET_ADD_VIEW(ch);
	switch (GET_RACE(ch)) {
	case RACE_GNOME:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)GNOME_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)GNOME_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)GNOME_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)GNOME_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)GNOME_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)GNOME_CON));
	break;
	case RACE_HUMAN:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HUMAN_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HUMAN_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HUMAN_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HUMAN_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HUMAN_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HUMAN_CON));
	break;
	case RACE_OGRE:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)OGRE_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)OGRE_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)OGRE_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)OGRE_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)OGRE_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)OGRE_CON));
	break;
	case RACE_BARBARIAN:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)BARBARIAN_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)BARBARIAN_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)BARBARIAN_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)BARBARIAN_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)BARBARIAN_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)BARBARIAN_CON));
	break;
	case RACE_TROLL:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)TROLL_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)TROLL_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)TROLL_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)TROLL_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)TROLL_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)TROLL_CON));
	break;
	case RACE_HALF_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALF_ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALF_ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALF_ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALF_ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALF_ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALF_ELF_CON));
	break;
	case RACE_DROW_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DROW_ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DROW_ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DROW_ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DROW_ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DROW_ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DROW_ELF_CON));
	break;
	case RACE_HALFLING:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALFLING_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALFLING_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALFLING_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALFLING_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALFLING_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALFLING_CON));
	break;
	case RACE_DWARF:
	GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DWARF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DWARF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DWARF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DWARF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DWARF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DWARF_CON));
	break;
	case RACE_DUERGAR:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DUERGAR_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DUERGAR_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DUERGAR_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DUERGAR_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DUERGAR_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DUERGAR_CON));
	break;
	case RACE_ORC:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ORC_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ORC_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ORC_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ORC_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ORC_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ORC_CON));
	break;
	case RACE_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ELF_CON));
	break;
	}
	return ;
}


/* copy vital data from a players char-structure to the file structure */
/* redone by proky...Banyal
Redone a hunred times over by me and others...Banyal*/
void char_to_store(struct char_data * ch, struct char_file_u * st)
{
  int i;
  struct affected_type *af;
  struct obj_data *char_eq[NUM_WEARS];
  sh_int hit, mana, move;
sbyte stdam, hitr;
  /*
   * save current values, because unequip_char will call
   * affect_total(), which will reset points to lower values
   * if player is wearing +points items.  We will restore old
   * points level after reequiping.
   */
  hit = GET_HIT(ch);
  mana = GET_MANA(ch);
  move = GET_MOVE(ch);
  stdam = GET_DAMROLL(ch);
  hitr = GET_HITROLL(ch);

  /* Unaffect everything a character can be affected by */

  for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      char_eq[i] = unequip_char(ch, i);
    else
      char_eq[i] = NULL;
  }

  for (af = ch->affected, i = 0; i < MAX_AFFECT; i++) {
    if (af) {
      st->affected[i] = *af;
      st->affected[i].next = 0;
      af = af->next;
    } else {
      st->affected[i].type = 0;	/* Zero signifies not used */
      st->affected[i].duration = 0;
      st->affected[i].modifier = 0;
      st->affected[i].location = 0;
      st->affected[i].bitvector = 0;
      st->affected[i].bitvector2 = 0;
      st->affected[i].bitvector3 = 0;
      st->affected[i].next = 0;
    }
  }


  /*
   * remove the affections so that the raw values are stored; otherwise
the
   * effects are doubled when the char logs back in.
   */

  while (ch->affected)
    affect_remove(ch, ch->affected);

  if ((i >= MAX_AFFECT) && af && af->next)
    log("SYSERR: WARNING: OUT OF STORE ROOM FOR AFFECTED TYPES!!!");


  ch->vaff_abils = ch->view_abils;
  st->birth = ch->player.time.birth;
  st->played = ch->player.time.played;
  st->played += (long) (time(0) - ch->player.time.logon);
  st->last_logon = time(0);

  ch->player.time.played = st->played;
  ch->player.time.logon = time(0);

  st->hometown = ch->player.hometown;
  st->weight = GET_WEIGHT(ch);
  st->height = GET_HEIGHT(ch);
  st->size = GET_SIZE(ch);
  st->sex = GET_SEX(ch);
  st->class = GET_CLASS(ch);
  st->race = GET_RACE(ch);
  st->race_align = GET_RACE_ALIGN(ch);
  st->level = GET_LEVEL(ch);
  st->abilities = ch->view_abils;
  st->points = ch->points;
  st->char_specials_saved = ch->char_specials.saved;
  st->player_specials_saved = ch->player_specials->saved;

  save_mem_list(ch);

  st->points.armor = 100;
  /*EDITED OUT FOR REAL RACES..... BANYAL
  st->points.hitroll = 0;
  st->points.damroll = 0;*/

  if (GET_TITLE(ch))
    strcpy(st->title, GET_TITLE(ch));
  else
    *st->title = '\0';

    if (GET_PROMPT(ch))
      strcpy(st->prompt, GET_PROMPT(ch));
    else
      *(st->prompt) = *str_dup(std_prompt);




  if (ch->player.description)
    strcpy(st->description, ch->player.description);
  else
    *st->description = '\0';

  strcpy(st->name, GET_NAME(ch));

  /* add spell and eq affections back in now */
  for (i = 0; i < MAX_AFFECT; i++) {
    if (st->affected[i].type)
      affect_to_char(ch, &st->affected[i]);
  }

  for (i = 0; i < NUM_WEARS; i++) {
    if (char_eq[i])
      equip_char(ch, char_eq[i], i);
  }
   affect_total(ch);

  /* restore our points to previous level */
  GET_HIT(ch) = hit;
  GET_MANA(ch) = mana;
  GET_MOVE(ch) = move;
  GET_DAMROLL(ch) = stdam;	/*Real race stuff...banyal*/
  GET_HITROLL(ch) = hitr;
}				/* Char to store */


void save_etext(struct char_data * ch)
{
/* this will be really cool soon */

}


/* create a new entry in the in-memory index table for the player file */
int create_entry(char *name)
{
  int i;

  if (top_of_p_table == -1) {
    CREATE(player_table, struct player_index_element, 1);
    top_of_p_table = 0;
  } else if (!(player_table = (struct player_index_element *)
	       realloc(player_table, sizeof(struct player_index_element) *
		       (++top_of_p_table + 1)))) {
    perror("create entry");
    exit(1);
  }
  CREATE(player_table[top_of_p_table].name, char, strlen(name) + 1);

  /* copy lowercase equivalent of name to table field */
  for (i = 0; (*(player_table[top_of_p_table].name + i) = LOWER(*(name + i)));
       i++);

  return (top_of_p_table);
}



/************************************************************************
*  funcs of a (more or less) general utility nature			*
********************************************************************** */


/* read and allocate space for a '~'-terminated string from a given file */
char *fread_string(FILE * fl, char *error)
{
  char buf[MAX_STRING_LENGTH], tmp[512], *rslt;
  register char *point;
  int done = 0, length = 0, templength = 0;

  *buf = '\0';

  do {
    if (!fgets(tmp, 512, fl)) {
      fprintf(stderr, "SYSERR: fread_string: format error at or near %s\n",
	      error);
      exit(1);
    }
    /* If there is a '~', end the string; else put an "\r\n" over the '\n'. */
    if ((point = strchr(tmp, '~')) != NULL) {
      *point = '\0';
      done = 1;
    } else {
      point = tmp + strlen(tmp) - 1;
      *(point++) = '\r';
      *(point++) = '\n';
      *point = '\0';
    }

    templength = strlen(tmp);

    if (length + templength >= MAX_STRING_LENGTH) {
      log("SYSERR: fread_string: string too large (db.c)");
      log(error);
      exit(1);
    } else {
      strcat(buf + length, tmp);
      length += templength;
    }
  } while (!done);

  /* allocate space for the new string and copy it */
  if (strlen(buf) > 0) {
    CREATE(rslt, char, length + 1);
    strcpy(rslt, buf);
  } else
    rslt = NULL;

  return rslt;
}


/* release memory allocated for a char struct */
void free_char(struct char_data * ch)
{
  int i;
  struct alias *a;
  void free_alias(struct alias * a);

  if (ch->player_specials != NULL && ch->player_specials != &dummy_mob) {
    while ((a = GET_ALIASES(ch)) != NULL) {
      GET_ALIASES(ch) = (GET_ALIASES(ch))->next;
      free_alias(a);
    }
    if (ch->player_specials->poofin)
      free(ch->player_specials->poofin);
    if (ch->player_specials->poofout)
      free(ch->player_specials->poofout);
  /*  if (ch->player_specials->last_olc_targ)
      free(ch->player_specials->last_olc_targ);
  if (ch->player_specials->last_olc_mode)
      free(ch->player_specials->last_olc_mode);
  if (ch->player_specials->roll[6])
    free(ch->player_specials->roll[6]);
  if (ch->player_specials->ignored)
   free(ch->player_specials->ignored); */
    free(ch->player_specials);
    if (IS_NPC(ch))
      log("SYSERR: Mob had player_specials allocated!");
  }
  if (!IS_NPC(ch) || (IS_NPC(ch) && GET_MOB_RNUM(ch) == -1)) {
    /* if this is a player, or a non-prototyped non-player, free all */
    if (GET_NAME(ch))
      free(GET_NAME(ch));
    if (ch->player.title)
      free(ch->player.title);
	if (ch->player.prompt)
      free(ch->player.prompt);
    if (ch->player.short_descr)
      free(ch->player.short_descr);
    if (ch->player.long_descr)
      free(ch->player.long_descr);
    if (ch->player.description)
      free(ch->player.description);
  } else if ((i = GET_MOB_RNUM(ch)) > -1) {
    /* otherwise, free strings only if the string is not pointing at proto */
    if (ch->player.name && ch->player.name != mob_proto[i].player.name)
      free(ch->player.name);
    if (ch->player.title && ch->player.title != mob_proto[i].player.title)
      free(ch->player.title);
    if (ch->player.prompt && ch->player.prompt != mob_proto[i].player.prompt)
      free(ch->player.prompt);
    if (ch->player.short_descr && ch->player.short_descr != mob_proto[i].player.short_descr)
      free(ch->player.short_descr);
    if (ch->player.long_descr && ch->player.long_descr != mob_proto[i].player.long_descr)
      free(ch->player.long_descr);
    if (ch->player.description && ch->player.description != mob_proto[i].player.description)
      free(ch->player.description);
  }
  while (ch->affected)
    affect_remove(ch, ch->affected);

  free(ch);
  ch = NULL; // hope this helps *pray*
}




/* release memory allocated for an obj struct */
void free_obj(struct obj_data * obj)
{
  int nr;
  struct extra_descr_data *this, *next_one;

  if ((nr = GET_OBJ_RNUM(obj)) == -1) {
    if (obj->name)
      free(obj->name);
    if (obj->description)
      free(obj->description);
    if (obj->short_description)
      free(obj->short_description);
    if (obj->action_description)
      free(obj->action_description);
    if (obj->ex_description)
      for (this = obj->ex_description; this; this = next_one) {
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
      }
  } else {
    if (obj->name && obj->name != obj_proto[nr].name)
      free(obj->name);
    if (obj->description && obj->description != obj_proto[nr].description)
      free(obj->description);
    if (obj->short_description && obj->short_description != obj_proto[nr].short_description)
      free(obj->short_description);
    if (obj->action_description && obj->action_description != obj_proto[nr].action_description)
      free(obj->action_description);
    if (obj->ex_description && obj->ex_description != obj_proto[nr].ex_description)
      for (this = obj->ex_description; this; this = next_one) {
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
      }
  }

  free(obj);
}



/* read contets of a text file, alloc space, point buf to it */
int file_to_string_alloc(char *name, char **buf)
{
  char temp[MAX_STRING_LENGTH];

  if (*buf)
    free(*buf);

  if (file_to_string(name, temp) < 0) {
    *buf = "";
    return -1;
  } else {
    *buf = str_dup(temp);
    return 0;
  }
}


/* read contents of a text file, and place in buf */
int file_to_string(char *name, char *buf)
{
  FILE *fl;
  char tmp[READ_SIZE+3];

  *buf = '\0';

  if (!(fl = fopen(name, "r"))) {
    sprintf(tmp, "Error reading %s", name);
    perror(tmp);
    return (-1);
  }
  do {
    fgets(tmp, READ_SIZE, fl);
    tmp[strlen(tmp) - 1] = '\0'; /* take off the trailing \n */
    strcat(tmp, "\r\n");

    if (!feof(fl)) {
      if (strlen(buf) + strlen(tmp) + 1 > MAX_STRING_LENGTH) {
        sprintf(buf, "SYSERR: %s: string too big (%d max)", name,
		MAX_STRING_LENGTH);
	log(buf);
	*buf = '\0';
	return -1;
      }
      strcat(buf, tmp);
    }
  } while (!feof(fl));

  fclose(fl);

  return (0);
}



/* clear some of the the working variables of a char */
void reset_char(struct char_data * ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    GET_EQ(ch, i) = NULL;
REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
  CONSENT(ch) = NULL;
ch->followers = NULL;  ch->master = NULL;
  ch->groupees = NULL;
  ch->groupmaster = NULL;
  ch->mgroupmaster = NULL;
  ch->mgroupees = NULL;
  ch->followers = NULL;
  ch->master = NULL;
  ch->in_room = NOWHERE;
  ch->carrying = NULL;
  ch->next = NULL;
  ch->next_fighting = NULL;
  ch->next_in_room = NULL;
  FIGHTING(ch) = NULL;
  ch->char_specials.position = POS_STANDING;
  ch->char_specials.position1 = POS1_STANDING;
  ch->mob_specials.default_pos = POS_STANDING;
  ch->char_specials.carry_weight = 0;
  ch->char_specials.carry_items = 0;

  if (GET_HIT(ch) <= 0)
    GET_HIT(ch) = GET_MAX_HIT(ch) * .10;
  if (GET_MOVE(ch) <= 0)
    GET_MOVE(ch) = 1;
  if (GET_MANA(ch) <= 0)
    GET_MANA(ch) = 1;
  if (GET_NATHPS(ch) <= 0)
      GET_NATHPS(ch) = GET_MAX_HIT(ch);
  check_regen_rates(ch);	/* start regening points */

  GET_LAST_TELL(ch) = NOBODY;
}



/* clear ALL the working variables of a char; do NOT free any space alloc'ed */
void clear_char(struct char_data * ch)
{
  int i;
  memset((char *) ch, 0, sizeof(struct char_data));

  ch->in_room = NOWHERE;
  GET_PFILEPOS(ch) = -1;
  GET_WAS_IN(ch) = NOWHERE;
  GET_POS(ch) = POS_STANDING;
  GET_POS1(ch) = POS1_STANDING;
  ch->mob_specials.default_pos = POS_STANDING;

for (i = 0; i < MAX_ACTION_DELAYS; i++)
    ch->char_specials.action_delays[i] = 0;


  GET_AC(ch) = 100;		/* Basic Armor */
  if (ch->points.max_mana < 100)
    ch->points.max_mana = 100;
}


void clear_object(struct obj_data * obj)
{
  memset((char *) obj, 0, sizeof(struct obj_data));

  obj->item_number = NOTHING;
  obj->in_room = NOWHERE;
}




/* initialize a new character only if class is set */
void init_char(struct char_data * ch)
{
  int i;

  /* create a player_special structure */
  if (ch->player_specials == NULL)
    CREATE(ch->player_specials, struct player_special_data, 1);

  /* *** if this is our first player --- he be God *** */

  if (top_of_p_table == 0) {
    GET_EXP(ch) = 7000000;
    GET_LEVEL(ch) = LVL_IMPL;

    ch->points.max_hit = 500;
    ch->points.max_mana = 100;
    ch->points.max_move = 82;
  }
  set_title(ch, "\0");

  ch->player.prompt = str_dup(std_prompt);
  ch->player.short_descr = NULL;
  ch->player.long_descr = NULL;
  ch->player.description = NULL;

  /*ch->player.hometown = 1;*/

  ch->player.time.birth = time(0);
  ch->player.time.played = 0;
  ch->player.time.logon = time(0);

  for (i = 0; i < MAX_TONGUE; i++)
    GET_TALK(ch, i) = 0;

  /* Lets make them damn races diffrent sizes hey? Banyal*/
  if (ch->player.sex == SEX_MALE) {
	  if (ch->player.race == RACE_HUMAN) {
    ch->player.weight = number(120, 180);
    ch->player.height = number(60, 76);
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.weight = number(100, 170);
    ch->player.height = number(60, 76);
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.weight = number(170, 260);
    ch->player.height = number(69, 88);
	  }
	  if (ch->player.race == RACE_DWARF) {
    ch->player.weight = number(170, 200);
    ch->player.height = number(38, 50);
	  }
      if (ch->player.race == RACE_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_HALFLING) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(35, 42);
	  }
	  if (ch->player.race == RACE_GNOME) {
	ch->player.weight = number(40, 90);
    ch->player.height = number(26, 38);
	  }
	  if (ch->player.race == RACE_ORC) {
	ch->player.weight = number(90, 150);
    ch->player.height = number(58, 68);
	  }
	  if (ch->player.race == RACE_TROLL) {
	ch->player.weight = number(130, 290);
    ch->player.height = number(72, 90);
	  }
	  if (ch->player.race == RACE_OGRE) {
	ch->player.weight = number(390, 530);
    ch->player.height = number(93, 119);
	  }
	  if (ch->player.race == RACE_DUERGAR) {
	ch->player.weight = number(170, 200);
    ch->player.height = number(38, 50);
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }

  } else {
    if (ch->player.race == RACE_HUMAN) {
    ch->player.weight = number(95, 150);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.weight = number(94, 155);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.weight = number(130, 210);
    ch->player.height = number(69, 80);
	  }
	  if (ch->player.race == RACE_DWARF) {
    ch->player.weight = number(150, 190);
    ch->player.height = number(38, 50);
	  }
      if (ch->player.race == RACE_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(59, 68);
	  }
	  if (ch->player.race == RACE_HALFLING) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(35, 42);
	  }
	  if (ch->player.race == RACE_GNOME) {
	ch->player.weight = number(40, 90);
    ch->player.height = number(26, 38);
	  }
	  if (ch->player.race == RACE_ORC) {
	ch->player.weight = number(90, 150);
    ch->player.height = number(58, 68);
	  }
	  if (ch->player.race == RACE_TROLL) {
	ch->player.weight = number(130, 290);
    ch->player.height = number(72, 90);
	  }
	  if (ch->player.race == RACE_OGRE) {
	ch->player.weight = number(390, 530);
    ch->player.height = number(93, 119);
	  }
	  if (ch->player.race == RACE_DUERGAR) {
	ch->player.weight = number(150, 190);
    ch->player.height = number(38, 50);
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }

  }

   if (ch->player.race == RACE_HUMAN) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
		ch->player.size = SIZE_LARGE;
	  }
	  if (ch->player.race == RACE_DWARF) {
		ch->player.size = SIZE_MEDIUM;
	  }
      if (ch->player.race == RACE_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_HALFLING) {
		ch->player.size = SIZE_SMALL;
	  }
	  if (ch->player.race == RACE_GNOME) {
		ch->player.size = SIZE_SMALL;
	  }
	  if (ch->player.race == RACE_ORC) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_TROLL) {
		ch->player.size = SIZE_LARGE;
	  }
	  if (ch->player.race == RACE_OGRE) {
		ch->player.size = SIZE_HUGE;
	  }
	  if (ch->player.race == RACE_DUERGAR) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
		ch->player.size = SIZE_MEDIUM;
	  /*}else{ch->player.size = SIZE_MEDIUM;*/}



  ch->points.max_mana = 100;
  ch->points.mana = GET_MAX_MANA(ch);
  ch->points.hit = GET_MAX_HIT(ch);
  ch->points.max_move = 82;
  ch->points.move = GET_MAX_MOVE(ch);
  ch->points.armor = 100;

  player_table[top_of_p_table].id = GET_IDNUM(ch) = ++top_idnum;

  for (i = 1; i <= MAX_SKILLS; i++) {
    if (GET_LEVEL(ch) < LVL_IMPL)
      SET_SKILL(ch, i, 0)
    else
      SET_SKILL(ch, i, 1000);
  }

  ch->char_specials.saved.affected_by = 0;
  ch->char_specials.saved.affected_by2 = 0;
  ch->char_specials.saved.affected_by3 = 0;

  for (i = 0; i < 5; i++)
    GET_SAVE(ch, i) = 0;

 /* ch->real_abils.intel = 25;
  *ch->real_abils.wis = 25;
  *ch->real_abils.dex = 25;
  *ch->real_abils.str = 25;
  *ch->real_abils.str_add = 100;
  *ch->real_abils.con = 25;
  *ch->real_abils.cha = 25;
  */

  for (i = 0; i < 3; i++)
    GET_COND(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 24);

  for (i = 0; i < 4; i++)
    GET_INNT(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 0);

  GET_LOADROOM(ch) = NOWHERE;
  SPEAKING(ch) = LANG_COMMON;
}


/* returns the real number of the room with given virtual number */
int real_room(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_world;

  /* perform binary search on world-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((world + mid)->number == virtual)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if ((world + mid)->number > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}



/* returns the real number of the monster with given virtual number */
int real_mobile(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_mobt;

  /* perform binary search on mob-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((mob_index + mid)->virtual == virtual)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((mob_index + mid)->virtual > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

void save_char_file_u(struct char_file_u st)
{
  int player_i;
  int find_name(char *name);
  if((player_i = find_name(st.name)) >=0 )
  {
  fseek(player_fl, player_i * sizeof(struct char_file_u), SEEK_SET);
  fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
  }
}



/* returns the real number of the object with given virtual number */
int real_object(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_objt;

  /* perform binary search on obj-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((obj_index + mid)->virtual == virtual)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((obj_index + mid)->virtual > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

  /* MOBProg functions */

  /* This routine transfers between alpha and numeric forms of the
   * mob_prog bitvector types.  This allows the use of the words in the
   * mob/script files.
   */

  int mprog_name_to_type (char *name)
  {
      if (!str_cmp(name, "in_file_prog"  ))    return IN_FILE_PROG;
      if (!str_cmp(name, "act_prog"      ))    return ACT_PROG;
      if (!str_cmp(name, "speech_prog"   ))    return SPEECH_PROG;
      if (!str_cmp(name, "rand_prog"     ))    return RAND_PROG;
      if (!str_cmp(name, "fight_prog"    ))    return FIGHT_PROG;
      if (!str_cmp(name, "hitprcnt_prog" ))    return HITPRCNT_PROG;
      if (!str_cmp(name, "death_prog"    ))    return DEATH_PROG;
      if (!str_cmp(name, "entry_prog"    ))    return ENTRY_PROG;
      if (!str_cmp(name, "greet_prog"    ))    return GREET_PROG;
      if (!str_cmp(name, "all_greet_prog"))    return ALL_GREET_PROG;
      if (!str_cmp(name, "give_prog"     ))    return GIVE_PROG;
      if (!str_cmp(name, "bribe_prog"    ))    return BRIBE_PROG;

      return(ERROR_PROG);
  }


    /*
     * Read a number from a file.
     */
    int fread_number(FILE *fp)
    {
        int number;
        bool sign;
        char c;

        do {
            c = getc(fp);
        } while (isspace(c));

        number = 0;

        sign   = FALSE;
        if (c == '+') {
            c = getc(fp);
        } else if (c == '-') {
            sign = TRUE;
            c = getc(fp);
        }


        if (!isdigit(c)) {
            log("Fread_number: bad format.");
            exit(1);
        }

        while (isdigit(c)) {
            number = number * 10 + c - '0';
            c      = getc(fp);
        }

        if (sign)
            number = 0 - number;

        if (c == '|')
            number += fread_number(fp);
        else if (c != ' ')
            ungetc(c, fp);

        return number;
    }

    /*
     * Read to end of line (for comments).
     */
    void fread_to_eol(FILE *fp)
    {
        char c;

        do {
            c = getc(fp);
        } while (c != '\n' && c != '\r');

        do {
            c = getc(fp);
        } while (c == '\n' || c == '\r');

        ungetc(c, fp);
        return;
    }


    /*
     * Read one word (into static buffer).
     */
    char *fread_word(FILE *fp)
    {
        static char word[MAX_INPUT_LENGTH];
        char *pword;
        char cEnd;

        do
        {
            cEnd = getc(fp);
        }
        while (isspace(cEnd));

        if (cEnd == '\'' || cEnd == '"')
        {
            pword   = word;
        }
        else
        {
            word[0] = cEnd;
            pword   = word+1;
            cEnd    = ' ';
        }

        for (; pword < word + MAX_INPUT_LENGTH; pword++)
        {
            *pword = getc(fp);
            if (cEnd == ' ' ? isspace(*pword) || *pword == '~' : *pword == cEnd)
            {
                if (cEnd == ' ' || cEnd == '~')
                    ungetc(*pword, fp);
                *pword = '\0';
                return word;
            }
        }

        log("SYSERR: Fread_word: word too long.");
        exit(1);
        return NULL;
    }


    /* This routine reads in scripts of MOBprograms from a file */

    MPROG_DATA* mprog_file_read(char *f, MPROG_DATA *mprg,
                                struct index_data *pMobIndex)
    {

      char        MOBProgfile[ MAX_INPUT_LENGTH ];
      MPROG_DATA *mprg2;
      FILE       *progfile;
      char        letter;
      bool        done = FALSE;

      sprintf(MOBProgfile, "%s/%s", MOB_DIR, f);

      progfile = fopen(MOBProgfile, "r");
      if (!progfile)
      {
         sprintf(err_buf, "Mob: %d couldnt open mobprog file", pMobIndex->virtual);
         log(err_buf);
         exit(1);
      }

      mprg2 = mprg;
      switch (letter = fread_letter(progfile))
      {
        case '>':
         break;
        case '|':
           log("empty mobprog file.");
           exit(1);
         break;
        default:
           log("in mobprog file syntax error.");
           exit(1);
         break;
      }

      while (!done)
      {
        mprg2->type = mprog_name_to_type(fread_word(progfile));
        switch (mprg2->type)
        {
         case ERROR_PROG:
            log("mobprog file type error");
            exit(1);
          break;
         case IN_FILE_PROG:
            log("mprog file contains a call to file.");
            exit(1);
          break;
         default:
            sprintf(buf2, "Error in file %s", f);
            pMobIndex->progtypes = pMobIndex->progtypes | mprg2->type;
            mprg2->arglist       = fread_string(progfile,buf2);
            mprg2->comlist       = fread_string(progfile,buf2);
            switch (letter = fread_letter(progfile))
            {
              case '>':
                 mprg2->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg2       = mprg2->next;
                 mprg2->next = NULL;
               break;
              case '|':
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf,"in mobprog file %s syntax error.", f);
                 log(err_buf);
                 exit(1);
               break;
            }
          break;
        }
      }
      fclose(progfile);
      return mprg2;
    }


    struct index_data *get_obj_index (int vnum)
    {
      int nr;
      for(nr = 0; nr <= top_of_objt; nr++) {
        if(obj_index[nr].virtual == vnum) return &obj_index[nr];
      }
      return NULL;
    }

    struct index_data *get_mob_index (int vnum)
    {
      int nr;
      for(nr = 0; nr <= top_of_mobt; nr++) {
        if(mob_index[nr].virtual == vnum) return &mob_index[nr];
      }
      return NULL;
    }


    /* This procedure is responsible for reading any in_file MOBprograms.
     */

    void mprog_read_programs(FILE *fp, struct index_data *pMobIndex)
    {
      MPROG_DATA *mprg;
      char        letter;
      bool        done = FALSE;

      if ((letter = fread_letter(fp)) != '>')
      {
          sprintf(err_buf,"Load_mobiles: vnum %d MOBPROG char", pMobIndex->virtual);
          log(err_buf);
          exit(1);
      }
      pMobIndex->mobprogs = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
      mprg = pMobIndex->mobprogs;

      while (!done)
      {
        mprg->type = mprog_name_to_type(fread_word(fp));
        switch (mprg->type)
        {
         case ERROR_PROG:
            sprintf(err_buf, "Load_mobiles: vnum %d MOBPROG type.", pMobIndex->virtual);
            log(err_buf);
            exit(1);
          break;
         case IN_FILE_PROG:
            sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
            mprg = mprog_file_read(fread_word(fp), mprg,pMobIndex);
            fread_to_eol(fp);   /* need to strip off that silly ~*/
            switch (letter = fread_letter(fp))
            {
              case '>':
                 mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg       = mprg->next;
                 mprg->next = NULL;
               break;
              case '|':
                 mprg->next = NULL;
                 fread_to_eol(fp);
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG.", pMobIndex->virtual);
                 log(err_buf);
                 exit(1);
               break;
            }
          break;
         default:
            sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
            pMobIndex->progtypes = pMobIndex->progtypes | mprg->type;
            mprg->arglist        = fread_string(fp, buf2);
            mprg->comlist        = fread_string(fp, buf2);
            switch (letter = fread_letter(fp))
            {
              case '>':
                 mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg       = mprg->next;
                 mprg->next = NULL;
               break;
              case '|':
                 mprg->next = NULL;
                 fread_to_eol(fp);
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG (%c).",
  	       pMobIndex->virtual, letter);
                 log(err_buf);
                 exit(1);
               break;
            }
          break;
        }
      }

      return;
  }

bool _parse_name(char *arg, char *name)
{
  int i;
  char test[32];
  const char *smart_ass[] =
  {
    "someone",
    "somebody",
    "me",
    "self",
    "all",
    "group",
    "local",
    "them",
    "they",
    "nobody",
    "any",
    "something",
    "other",
    "no",
    "yes",
    "north",
    "east",
    "south",
    "west",
    "up",
    "down",
    "shape",			/* infra.. */
    "shadow",			/* summon */
    "\n"
  };

  test[0] = 0;
  for (i = 0; (*name = *arg); arg++, i++, name++) {
    *(test + i) = LOWER(*arg);
    if ((*arg < 0) || !isalpha(*arg) || (i > 15) ||
	(i && (*(test + i) != *arg)))
      return (TRUE);
  }

  if (i < 2)
    return (TRUE);

  if (search_block2(test, iscommand, TRUE) >= 0)
    return TRUE;
  if (search_block2(test, smart_ass, TRUE) >= 0)
    return TRUE;

  return FALSE;
}
@


1.196
log
@fixed - warning: format not a string literal and no format arguments
@
text
@/***************************************************************************
 * $Id: db.c,v 1.195 2011/08/06 15:22:51 rsd Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: db.c                                           Part of FieryMUD *
 *  Usage: Loading/saving chars, booting/resetting world, internal funcs   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#define __DB_C__

#include <math.h>

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "handler.h"
#include "casting.h"
#include "mail.h"
#include "interpreter.h"
#include "house.h"
#include "corpse_save.h"
#include "dg_scripts.h"
#include "weather.h"
#include "clan.h"
#include "quest.h"
#include "races.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "events.h"
#include "players.h"
#include "trophy.h"
#include "pfiles.h"
#include "regen.h"
#include "fight.h"
#include "commands.h"
#include "movement.h"
#include "board.h"
#include "composition.h"
#include "charsize.h"
#include "directions.h"
#include "money.h"
#include "textfiles.h"
#include "cooldowns.h"

void init_clans(void);
char err_buf[MAX_STRING_LENGTH];
struct player_special_data dummy_mob;

/*object limit function*/
void boot_quests();

void setup_drinkcon(struct obj_data *obj, int newliq);

/***************************************************************************
 *  declarations of most of the 'global' variables                         *
 ***************************************************************************/


struct room_data *world = NULL;        /* array of rooms                 */
int top_of_world = 0;                /* ref to top element of world         */
struct room_effect_node *room_effect_list = NULL;  /* list of room effects */

struct char_data *character_list = NULL; /* global linked list of chars */

struct index_data **trig_index; /* index table for triggers      */
int top_of_trigt = 0;           /* top of trigger index table    */
long max_id = 100000;           /* for unique mob/obj id's       */

struct index_data *mob_index;        /* index table for mobile file         */
struct char_data *mob_proto;        /* prototypes for mobs                 */
int top_of_mobt = 0;                /* top of mobile index table         */
struct obj_data *object_list = NULL;        /* global linked list of objs         */
struct index_data *obj_index;        /* index table for object file         */
struct obj_data *obj_proto;        /* prototypes for objs                 */
int top_of_objt = 0;                /* top of object index table         */
struct spell_dam spell_dam_info[MAX_SPELLS + 1];/*internal spell dam*/
struct zone_data *zone_table;        /* zone table                         */
int top_of_zone_table = 0;        /* top element of zone tab         */
struct message_list fight_messages[MAX_MESSAGES];        /* fighting messages         */

struct player_index_element *player_table = NULL;        /* index to plr file         */
int top_of_p_table = 0;                /* ref to top of table                 */
int top_of_p_file = 0;                /* ref of size of p file         */
long top_idnum = 0;                /* highest idnum in use                 */

int no_mail = 0;                /* mail disabled?                 */
#ifdef DEV
int mini_mud = 1;                /* mini-mud mode?                 */
#else
int mini_mud = 0;                /* mini-mud mode?                 */
#endif
time_t *boot_time = NULL;                /* times of mud boots (size = 1 + num_hotboots) */
int num_hotboots = 0;                    /* are we doing a hotboot? */
int restrict = 0;                /* level of game restriction         */
int restrict_reason = RESTRICT_NONE;   /* reason for restrict > 0 */
int r_mortal_start_room;        /* rnum of mortal start room         */
int r_immort_start_room;        /* rnum of immort start room         */
int r_frozen_start_room;        /* rnum of frozen start room         */

struct help_index_element *help_table = 0;        /* the help table         */
int top_of_helpt = 0;                /* top of help index table         */

struct time_info_data time_info;/* the infomation about the time    */

struct reset_q_type reset_q;        /* queue of zones to be reset         */

struct str_app_type str_app[101];
struct dex_skill_type dex_app_skill[101];
struct dex_app_type dex_app[101];
struct con_app_type con_app[101];
struct int_app_type int_app[101];
struct wis_app_type wis_app[101];

void setup_dir(FILE * fl, int room, int dir);
void index_boot(int mode);
void discrete_load(FILE * fl, int mode);
void parse_trigger(FILE *fl, int virtual_nr);
void parse_room(FILE * fl, int virtual_nr);
void parse_mobile(FILE * mob_f, int nr);
char *parse_object(FILE * obj_f, int nr);
void load_zones(FILE * fl, char *zonename);
void load_help(FILE *fl);
void assign_mobiles(void);
void assign_objects(void);
void assign_rooms(void);
void assign_the_shopkeepers(void);
int is_empty(int zone_nr);
void reset_zone(int zone, byte pop);
int file_to_string(const char *name, char *buf);
int file_to_string_alloc(const char *name, char **buf);
void check_start_rooms(void);
void renum_world(void);
void renum_zone_table(void);
void log_zone_error(int zone, int cmd_no, char *message);
void reset_time(void);
void clear_char(struct char_data * ch);
long get_set_exp(int level, int race, int class, int zone);
sh_int get_set_hit(int level, int race, int class, int state);
sbyte get_set_hd(int level, int race, int class, int state);
int get_set_dice(int level, int race, int class, int state);
int get_copper(int);
/* external functions */
void boot_social_messages(void);
void sort_commands(void);
void sort_spells(void);
void load_banned(void);
void Read_Xname_List(void);
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
int hsort(const void *a, const void *b);
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
void build_count(void);
extern void load_str_app(void);
extern void load_thief_dex(void);
extern void load_dex_app(void);
extern void load_con_app(void);
extern void load_int_app(void);
extern void load_wis_app(void);
extern void clear_memory(struct char_data *ch);

/* external vars */
extern int no_specials;

#define READ_SIZE 256
#define GET_ZONE(ch) (ch)->mob_specials.zone

#define GET_SDESC(mob) ((mob)->player.short_descr)
/*#define GET_LDESC(mob) ((mob)->player.long_descr)*/
#define GET_NDD(mob) ((mob)->mob_specials.damnodice)
#define GET_SDD(mob) ((mob)->mob_specials.damsizedice)
#define MOB_MONSUM_I                130
#define MOB_MONSUM_II                140
#define MOB_MONSUM_III                150
#define MOB_GATE_I                160
#define MOB_GATE_II                170
#define MOB_GATE_III                180
#define MOB_ELEMENTAL_BASE        110
#define MOB_CLONE                69
#define MOB_ZOMBIE                11
#define MOB_AERIALSERVANT        109
#define MOB_MENTAL              17
#define MOB_MENTAL2             21
/*************************************************************************
 *  routines for booting the system                                      *
 *************************************************************************/

long get_set_exp(int level, int race, int class, int zone)
     /*class/species*/
{
  long exp;
  int cfactor = 100;
  int sfactor = 100;
  int zfactor = 100;
  for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
    if (zone == zone_table[zfactor].number)
      break;
  }
  zfactor = zone_table[zfactor].zone_factor;
  /*zfactor = 100;*/

  /*The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  cfactor = CLASS_EXPFACTOR(class);
  sfactor = RACE_EXPFACTOR(race);

  if (level < 50)
    exp = (long) (((float)(level * level * level)) + 1000);
  else if (level >= 50)/*50 and under equation*/
    exp = (long) (level * level * 50) + 1000;
  /*51 and over equation*/

  sfactor = ((int)((sfactor + zfactor + cfactor)/3));
  exp = (long) (((float)((sfactor*exp)/100)));
  return exp;
}

sh_int get_set_hit(int level, int race, int class, int state)
     /*class/species*/
{
  /*main - is the main bonus chucnk of hps
   */
  /*struct descriptor_data *d;
   */        
  sh_int xmain = 0;
  sh_int face = 1;
  int cfactor = 100;
  int sfactor = 100;

  /* The cfactor is the factor of class to adjust exp number is percentage
     100 being standard no change */
  cfactor = CLASS_HITFACTOR(class);
  sfactor = RACE_HITFACTOR(race);

  /* here is the function*/
  /*auto setting sets hit and mana to 5 and 10 thus 5d10 extra = average 25*/
  if (level < 20)
    xmain = (sh_int) (3 * ((float)level * (float)(level/1.25)));         /*50 and under equation*/

  else if (level < 35)
    xmain = (sh_int) (3 * ((float)level * (float)(level/1.35)));         /*50 and under equation*/

  else if (level < 50)
    xmain = (sh_int) (3 * ((float)level * (float)level/1.25));         /*50 and under equation*/

  else if (level >= 50)
    xmain = (sh_int) (3 * ((float)level * (float)level/1.25));  /*51 and over equation*/
  if (level <=5)
    face = 1;
  else if (level <=10) {
    xmain -= 25;
    face = 5;
  }
  else if (level <= 20) {
    xmain -= 100;
    face = 10;
  }
  else if (level <=30)  {
    xmain -= 200;
    face = 20;
  }
  else {
    xmain -= 2000;
    face = 200;
  }


   /*finally taking the factors into account*/
  sfactor = ((int)((sfactor + cfactor)/2));
   xmain = (sh_int) (((float)(sfactor*xmain)/100));


   if (state == 2)
     return face;
   else
     return xmain/(2 - (level/100.0));


}


sbyte get_set_hd(int level, int race, int class, int state)
     /*class/species*/
{
  sbyte hit = 0;
  sbyte dam = 0;
  int cfactor = 100;
  int sfactor = 100;


  /*The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  cfactor = CLASS_HDFACTOR(class);
  sfactor = RACE_HDFACTOR(race);

  /*hit calculations*/
  if (!state) {
    if (level < 10)
      hit = (sbyte) (level/2.0);
    else if (level < 24)
      hit = (sbyte) (level/2.4);
    else if (level < 32)
      hit = (sbyte) (level/2.6);
    else if (level < 50)
      hit = (sbyte) (level/2.8);
    else if (level < 62)
      hit = (sbyte) (level/3.0);
    else if (level < 75)
      hit = (sbyte) (level/3.2);        /*50 and under equation*/
    else if (level < 82)
      hit = (sbyte) (level/3.4);
    else if (level >= 90)
      hit = (sbyte) (level/3.6);         /*51 and over equation*/


    /*hit factor considerations*/
    sfactor = ((int)((sfactor + cfactor)/2));
    hit = (sbyte) (((float)(sfactor*hit)/100));


  }

  /*dam calculations*/
  if (state) {
    if (level < 10)
      dam = (sbyte) (level /4.0);
    else if (level < 20)
      dam = (sbyte) (level / 4.0); /*under 20*/
    else if (level < 35)
      dam = (sbyte) (level/4.3); /*under 35*/

    else if (level < 50)
      dam = (sbyte) (level / 4.6);        /*50 and under equation*/

    else if (level >= 50)
      dam = (sbyte) (level / 4.4);        /*51 and over equation*/

    /*dam factor considerations*/
    sfactor = ((int)((sfactor + cfactor)/2));
    dam = (sbyte) (((float)(sfactor*dam)/100));
  }



  if (!state)
    return hit;
  else
    return dam;
}

int get_set_dice(int level, int race, int class, int state)

     /*class/species*/
{
  int dice = 0;
  int face = 0;
  int cfactor = 100;
  int sfactor = 100;


  /*The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  cfactor = CLASS_DICEFACTOR(class);
  sfactor = RACE_DICEFACTOR(race);

  /*dice calculations*/
  if (!state) {
    if (level < 10)
      dice = MAX(1, (int) ((level/3) + .5));

    else if (level < 30)
      dice = (int) ((float)(level/3) + .5); /*under 30*/

    else if (level <= 50)
      dice = (int) ((level /3) + .5);        /*50 and under equation*/

    else if (level > 50)
      dice = (int) ((level / 2.5) + .5);        /*51 and over equation*/

    sfactor = ((int)((sfactor + cfactor)/2));
    dice = (sbyte) (((float)(sfactor*dice)/100));
  }
  /*face calucs*/
  if (state) {
    if (level < 10)
      face = 3;
    else if (level < 26)
      face = 4;
    else if (level < 36)
      face = 4;

    else if (level <= 50)
      face = 5;        /*50 and under equation*/
    else if ((level > 50) && (level <= 60))
      face = 8;           /*50 over equation*/
    else if (level > 60)
      face = 10;

    /*face = (sbyte) (((float)sfactor/100) * ((float)cfactor/100) * face);
     */}



  if (!state)
    return dice;
  else
    return face;
}


int get_copper(int i)
     /*class/species*/
{
  /*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
  int copper = 0;
  int cfactor = 100;
  int sfactor = 100;
  int zfactor;
  for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++)
  {
    if (GET_ZONE(mob_proto + i) == zone_table[zfactor].number)
      break;
  }
  zfactor = zone_table[zfactor].zone_factor;


  /*The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  cfactor = CLASS_COPPERFACTOR((int)mob_proto[i].player.class);
  sfactor = RACE_COPPERFACTOR((int)mob_proto[i].player.race);

  if ((sfactor == 0) || (cfactor == 0))
    return 0;

  /*copper calculations*/
  copper = (number(1, 150)) * mob_proto[i].player.level;
  sfactor = (int)((sfactor + cfactor + zfactor)/3);

  copper = (int)((float)((sfactor/100.0) * copper));

  return copper;
}


int get_ac(int level, int race, int class)
     /*class/species*/
{
  /*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
  int ac = 0;
  int cfactor = 100;
  int sfactor = 100;

  /*The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  cfactor = CLASS_ACFACTOR(class);
  sfactor = RACE_ACFACTOR(race);

  /*ac calculations*/
  ac = 90 - (int)(2 * level * (float)(sfactor / 100.0));
  ac = MIN(100, MAX(-100, ac));
  return ac;
}

/*This requres a file in lib/misc/spell_dams, It will tell you if you dont
  It then boots, note that if anything goes wrong to file
  you can re-write it by saving under sdedit, the viewer is in act.informative.c
  The olc code is in sdedit.c 
*/
void boot_spell_dams()
{
  int i;
  FILE *ifptr;
  char line[256];
  char *err = "Spell Dam";
  if ((ifptr = fopen(SPELL_DAM_FILE, "r")) == NULL)
    {
      log("No spells dam file it should be at lib/misc/spell_dam.");
      exit(1);
    }
  else
    {
      get_line(ifptr, line);
      get_line(ifptr, line);
      get_line(ifptr, line);
/*
      sprintf(buf, "%s", line);
      log("%s",buf);
      get_line(ifptr, line);
      sprintf(buf, "%s", line);
      log("%s",buf);
      get_line(ifptr, line);
      sprintf(buf, "%s", line);
      log("%s",buf);
*/
      if (str_cmp(line, "spell_dam"))
        {
          log("Error in booting spell dams");
          /* return;
           */  }
      for (i = 1; i <= MAX_SPELLS;i++)
        {
          get_line(ifptr, line);
          sscanf(line, "%hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd",
                 &SD_SPELL(i), &SD_INTERN_DAM(i),
                 &SD_NPC_STATIC(i), &SD_NPC_NO_DICE(i), &SD_NPC_NO_FACE(i),
                 &SD_PC_STATIC(i), &SD_PC_NO_DICE(i), &SD_PC_NO_FACE(i), &SD_NPC_REDUCE_FACTOR(i), &SD_USE_BONUS(i),
                 &SD_BONUS(i), &SD_LVL_MULT(i));
          if (SD_NPC_REDUCE_FACTOR(i) == 0)
            SD_NPC_REDUCE_FACTOR(i) = 100;
        
          SD_NOTE(i) = fread_string(ifptr, err);
        }
      fclose (ifptr);
    }
}

void free_spell_dams(void) {
  int i;
  extern struct spell_dam spell_dam_info[];


  for (i = 1; i <= MAX_SPELLS; i++)
    free(spell_dam_info[i].note);
}


void boot_world(void)
{
  log("Loading attribute bonus tables.");
  load_str_app();
  load_thief_dex();
  load_dex_app();
  load_con_app();
  load_int_app();
  load_wis_app();

  log("Loading zone table.");
  index_boot(DB_BOOT_ZON);

  log("Loading triggers and generating index.");
  index_boot(DB_BOOT_TRG);

  log("Loading rooms.");
  index_boot(DB_BOOT_WLD);

  log("Renumbering rooms.");
  renum_world();

  log("Checking start rooms.");
  check_start_rooms();

  log("Loading mobs and generating index.");
  memset(&dummy_mob, 0, sizeof(struct player_special_data));
  index_boot(DB_BOOT_MOB);

  log("Loading objs and generating index.");
  index_boot(DB_BOOT_OBJ);

  /* moved here by gurlaek 8/8/1999 */
  log("Generating player index.");
  build_player_index();

  log("Renumbering zone table.");
  renum_zone_table();

  log("Booting spell_dam's.");
  boot_spell_dams();

  if (!no_specials) {
    log("Loading shops.");
    index_boot(DB_BOOT_SHP);
  }

  /* Must happen after loading the player index */
  log("Booting Clans.");
  init_clans();

  log("Booting boards.");
  board_init();
}



/* body of the booting system */
void boot_db(void)
{
  int i;

  log("Boot db -- BEGIN.");

  log("Reading anews, credits, help, bground, info and motds.");
  boot_text();

  log("Getting Build Count.");
  build_count();

  log("   Skills.");
  init_skills();

  log("Assigning skills and spells to classes.");
  assign_class_skills();

  /* Command sorting needs to happen before many other loading 
   * activities, because sorting the commands initializes the
   * num_of_cmds variable.
   */
  log("Sorting command list and skills.");
  sort_commands();
  sort_skills();

  /* Needs to happen after sorting commands */
  log("Booting command groups.");
  boot_command_groups();

  boot_world();

  log("Resetting the game time:");
  reset_time();

  log("Loading help entries.");
  index_boot(DB_BOOT_HLP);

  log("Loading fight messages.");
  load_messages();

  log("Loading social messages.");
  boot_social_messages();

  log("Assigning function pointers:");

  if (!no_specials) {
    log("   Mobiles.");
    assign_mobiles();
    log("   Shopkeepers.");
    assign_the_shopkeepers();
    log("   Objects.");
    assign_objects();
    log("   Rooms.");
    assign_rooms();
  }

  log("Booting mail system.");
  if (!scan_file()) {
    log("    Mail boot failed -- Mail system disabled");
    no_mail = 1;
  }
  log("Reading banned site and Xname list.");
  load_banned();
  Read_Xname_List();

  for (i = 0; i <= top_of_zone_table; i++) {
    sprintf(buf2, "Resetting %s (rooms %d-%d).",
            zone_table[i].name, (i ? (zone_table[i - 1].top + 1) : 0),
            zone_table[i].top);
    log("%s", buf2);
    reset_zone(i, TRUE);
  }

  reset_q.head = reset_q.tail = NULL;

  if (!mini_mud) {
    log("Booting houses.");
    House_boot();
  }

  log("Booting corpses.");
  boot_corpses();
  log("Booting quests.");
  boot_quests();

  CREATE(boot_time, time_t, 1);
  *boot_time = time(0);

  log("Boot db -- DONE.");
}


void free_extra_descriptions(struct extra_descr_data *edesc) {
  struct extra_descr_data *enext;

  for (; edesc; edesc = enext) {
    enext = edesc->next;

    if (edesc->keyword)
      free(edesc->keyword);
    if (edesc->description)
      free(edesc->description);
    free(edesc);
  }
}

void copy_extra_descriptions(struct extra_descr_data **to, struct extra_descr_data *from)
{
  struct extra_descr_data *wpos;

  CREATE(*to, struct extra_descr_data, 1);
  wpos = *to;

  for (; from; from = from->next, wpos = wpos->next) {
    if (from->keyword)
      wpos->keyword = strdup(from->keyword);
    if (from->description)
      wpos->description = strdup(from->description);
    if (from->next)
      CREATE(wpos->next, struct extra_descr_data, 1);
  }
}

void destroy_db(void) {
  ssize_t cnt, itr;
  struct char_data *chtmp;
  struct obj_data *objtmp;

  extern void destroy_shops(void);
  extern void stop_groupee(struct char_data *ch, bool hide);

  /* Active Characters */
  while (character_list) {
    chtmp = character_list;
    character_list = character_list->next;
    if (chtmp->master)
      stop_follower(chtmp, FALSE);
    if (chtmp->group_master)
      ungroup(chtmp, FALSE, FALSE);
    free_char(chtmp);
  }

  /* Active Objects */
  while (object_list) {
    objtmp = object_list;
    object_list = object_list->next;
    free_obj(objtmp);
  }

  /* Rooms */
  for (cnt = 0; cnt <= top_of_world; cnt++) {
    if (world[cnt].name)
      free(world[cnt].name);
    if (world[cnt].description)
      free(world[cnt].description);
    free_extra_descriptions(world[cnt].ex_description);

    /* free any assigned scripts */
    if (SCRIPT(&world[cnt])) {
      extract_script(SCRIPT(&world[cnt]));
      SCRIPT(&world[cnt]) = NULL;
    }
    /* free script proto list */
    free_proto_script(&world[cnt].proto_script);

    for (itr = 0; itr < NUM_OF_DIRS; itr++) {
      if (!world[cnt].exits[itr])
        continue;

      if (world[cnt].exits[itr]->general_description)
        free(world[cnt].exits[itr]->general_description);
      if (world[cnt].exits[itr]->keyword)
        free(world[cnt].exits[itr]->keyword);
      free(world[cnt].exits[itr]);
    }
  }
  free(world);
  top_of_world = 0;

  /* Objects */
  for (cnt = 0; cnt <= top_of_objt; cnt++) {
    if (obj_proto[cnt].name)
      free(obj_proto[cnt].name);
    if (obj_proto[cnt].description)
      free(obj_proto[cnt].description);
    if (obj_proto[cnt].short_description)
      free(obj_proto[cnt].short_description);
    if (obj_proto[cnt].action_description)
      free(obj_proto[cnt].action_description);
    free_extra_descriptions(obj_proto[cnt].ex_description);

    /* free script proto list */
    free_proto_script(&obj_proto[cnt].proto_script);
  }
  free(obj_proto);
  free(obj_index);

  /* Mobiles */
  for (cnt = 0; cnt <= top_of_mobt; cnt++) {
    if (mob_proto[cnt].player.namelist)
      free(mob_proto[cnt].player.namelist);
    if (mob_proto[cnt].player.title)
      free(mob_proto[cnt].player.title);
    if (mob_proto[cnt].player.short_descr)
      free(mob_proto[cnt].player.short_descr);
    if (mob_proto[cnt].player.long_descr)
      free(mob_proto[cnt].player.long_descr);
    if (mob_proto[cnt].player.description)
      free(mob_proto[cnt].player.description);

    /* free script proto list */
    free_proto_script(&mob_proto[cnt].proto_script);

    while (mob_proto[cnt].effects)
      effect_remove(&mob_proto[cnt], mob_proto[cnt].effects);
  }
  free(mob_proto);
  free(mob_index);

  /* Shops */
  destroy_shops();

  /* Zones */
#define THIS_CMD zone_table[cnt].cmd[itr]

  for (cnt = 0; cnt <= top_of_zone_table; cnt++) {
    if (zone_table[cnt].name)
      free(zone_table[cnt].name);
    if (zone_table[cnt].cmd) {
      /* then free the command list */
      free(zone_table[cnt].cmd);
    }
  }
  free(zone_table);

#undef THIS_CMD

  /* zone table reset queue */
  if (reset_q.head) {
    struct reset_q_element *ftemp=reset_q.head, *temp;
    while (ftemp) {
      temp = ftemp->next;
      free(ftemp);
      ftemp = temp;
    }
  }

  /* Triggers */
  for (cnt=0; cnt < top_of_trigt; cnt++) {
    if (trig_index[cnt]->proto) {
      /* make sure to nuke the command list (memory leak) */
      /* free_trigger() doesn't free the command list */
      if (trig_index[cnt]->proto->cmdlist) {
        struct cmdlist_element *i, *j;
        i = trig_index[cnt]->proto->cmdlist;
        while (i) {
          j = i->next;
          if (i->cmd)
            free(i->cmd);
          free(i);
          i = j;
        }
      }
      free_trigger(trig_index[cnt]->proto);
    }
    free(trig_index[cnt]);
  }
  free(trig_index);

  /* Events */
  event_free_all();

  /* Online spell damage */
  free_spell_dams();

  /* Quests */
  free_quests();
}


/* reset the time in the game from file */
void reset_time(void)
{
  long beginning_of_time = 650336715;
  struct time_info_data mud_time_passed(time_t t2, time_t t1);

  time_info = mud_time_passed(time(0), beginning_of_time);

  log("Initializing daylight for hemispheres.");
  /* okay, saved time represents HEMISPHERE_NORTHWEST/ ...SOUTHWEST */
  if (time_info.hours <= 7) {
    hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
  } else if (time_info.hours == 8) {
    hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_RISE;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_RISE;
    hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_SET;
    hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_SET;
  } else if (time_info.hours <= 20) {
    hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_LIGHT;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
    hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_DARK;
    hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_DARK;
  } else if (time_info.hours == 21) {
    hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_SET;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_SET;
    hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_RISE;
    hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_RISE;
  } else {
    hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_LIGHT;
  }

  sprintf(buf, "Setting up seasons: ");

  /* setup the seasons */
  if (time_info.month < 4) {
    hemispheres[HEMISPHERE_NORTHWEST].season = WINTER;
    hemispheres[HEMISPHERE_SOUTHWEST].season = SUMMER;
    hemispheres[HEMISPHERE_NORTHEAST].season = WINTER;
    hemispheres[HEMISPHERE_SOUTHEAST].season = SUMMER;
    strcat(buf, "Winter");
  } else if (time_info.month < 8) {
    hemispheres[HEMISPHERE_NORTHWEST].season = SPRING;
    hemispheres[HEMISPHERE_SOUTHWEST].season = AUTUMN;
    hemispheres[HEMISPHERE_NORTHEAST].season = SPRING;
    hemispheres[HEMISPHERE_SOUTHEAST].season = AUTUMN;
    strcat(buf, "Spring");
  } else if (time_info.month < 12) {
    hemispheres[HEMISPHERE_NORTHWEST].season = SUMMER;
    hemispheres[HEMISPHERE_SOUTHWEST].season = WINTER;
    hemispheres[HEMISPHERE_NORTHEAST].season = SUMMER;
    hemispheres[HEMISPHERE_SOUTHEAST].season = WINTER;
    strcat(buf, "Summer");
  } else {
    hemispheres[HEMISPHERE_NORTHWEST].season = AUTUMN;
    hemispheres[HEMISPHERE_SOUTHWEST].season = SPRING;
    hemispheres[HEMISPHERE_NORTHEAST].season = AUTUMN;
    hemispheres[HEMISPHERE_SOUTHEAST].season = SPRING;
    strcat(buf, "Autumn");
  }
  log("%s",buf);

  log("Current Gametime: %dH %dD %dM %dY.",
      time_info.hours, time_info.day, time_info.month, time_info.year);

  log("Initializing weather.");
  init_weather();
}

/* function to count how many hash-mark delimited records exist in a file */
int count_hash_records(FILE * fl)
{
  char buf[128];
  int count = 0;

  while (fgets(buf, 128, fl))
    if (*buf == '#')
      count++;

  return count;
}



void index_boot(int mode)
{
  char *index_filename, *prefix;
  FILE *index, *db_file;
  int rec_count = 0;

  switch (mode) {
  case DB_BOOT_TRG:
    prefix = TRG_PREFIX;
    break;
  case DB_BOOT_WLD:
    prefix = WLD_PREFIX;
    break;
  case DB_BOOT_MOB:
    prefix = MOB_PREFIX;
    break;
  case DB_BOOT_OBJ:
    prefix = OBJ_PREFIX;
    break;
  case DB_BOOT_ZON:
    prefix = ZON_PREFIX;
    break;
  case DB_BOOT_SHP:
    prefix = SHP_PREFIX;
    break;
  case DB_BOOT_HLP:
    prefix = HLP_PREFIX;
    break;
  default:
    log("SYSERR: Unknown subcommand to index_boot!");
    exit(1);
    break;
  }
/* Ok, not sure we ever use this in mini-mud mode so I'm making it
   to where the index is loaded instead of the MINDEX_FILE even
   in mini_mud mode which is dev mode. */
  if (mini_mud)
    index_filename = INDEX_FILE;
  else
    index_filename = INDEX_FILE;

  sprintf(buf2, "%s/%s", prefix, index_filename);

  if (!(index = fopen(buf2, "r"))) {
    sprintf(buf1, "Error opening index file '%s'", buf2);
    perror(buf1);
    exit(1);
  }

  /* first, count the number of records in the file so we can malloc */
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s/%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      log("file listed in index not found");
      exit(1);
    } else {
      if (mode == DB_BOOT_ZON)
        rec_count++;
      else
        rec_count += count_hash_records(db_file);
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }

  /* Exit if 0 records, unless this is shops */
  if (!rec_count) {
    if (mode == DB_BOOT_SHP)
      return;
    log("SYSERR: boot error - 0 records counted");
    exit(1);
  }

  rec_count++;

  switch (mode) {
  case DB_BOOT_TRG:
    CREATE(trig_index, struct index_data *, rec_count);
    break;
  case DB_BOOT_WLD:
    CREATE(world, struct room_data, rec_count);
    break;
  case DB_BOOT_MOB:
    CREATE(mob_proto, struct char_data, rec_count);
    CREATE(mob_index, struct index_data, rec_count);
    break;
  case DB_BOOT_OBJ:
    CREATE(obj_proto, struct obj_data, rec_count);
    CREATE(obj_index, struct index_data, rec_count);
    break;
  case DB_BOOT_ZON:
    CREATE(zone_table, struct zone_data, rec_count);
    break;
  case DB_BOOT_HLP:
    CREATE(help_table, struct help_index_element, rec_count * 2);
    break;
  }

  rewind(index);
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s/%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      exit(1);
    }
    switch (mode) {
    case DB_BOOT_TRG:
    case DB_BOOT_WLD:
    case DB_BOOT_OBJ:
    case DB_BOOT_MOB:
      discrete_load(db_file, mode);
      break;
    case DB_BOOT_ZON:
      load_zones(db_file, buf2);
      break;
    case DB_BOOT_HLP:
      load_help(db_file);
      break;
    case DB_BOOT_SHP:
      boot_the_shops(db_file, buf2, rec_count);
      break;
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }

  /* sort the help index */
  if (mode == DB_BOOT_HLP) {
    qsort(help_table, top_of_helpt, sizeof(struct help_index_element), hsort);
    top_of_helpt--;
  }}

int tmp_debug = 0;

void discrete_load(FILE * fl, int mode)
{
  int nr = -1, last = 0;
  char line[256];
  char *modes[] = {"world", "mob", "obj", "ZON", "SHP", "HLP", "trg"};
  for (;;) {
    /*
     * we have to do special processing with the obj files because they have
     * no end-of-record marker :(
     */
    if (mode != DB_BOOT_OBJ || nr < 0)
      {
        tmp_debug++;
        if (!get_line(fl, line)) {
          fprintf(stderr, "Format error after %s #%d\n", modes[mode], nr);
          fprintf(stderr, "Offending line: '%s'in file down list%d\n", line,
                  tmp_debug);
          exit(1);
        }
      }
    if (*line == '$')
      return;

    if (*line == '#') {
      last = nr;
      if (sscanf(line, "#%d", &nr) != 1) {
        fprintf(stderr, "Format error after %s #%d\n", modes[mode], last);
        fprintf(stderr, "Offending line: '%s'\n", line);
        exit(1);
      }
      if (nr >= 198999)
        return;
      else
        switch (mode) {
        case DB_BOOT_TRG:
          parse_trigger(fl, nr);
          break;
        case DB_BOOT_WLD:
          parse_room(fl, nr);
          break;
        case DB_BOOT_MOB:
          parse_mobile(fl, nr);
          break;
        case DB_BOOT_OBJ:
          strcpy(line, parse_object(fl, nr));
          break;
        }
    } else {
      fprintf(stderr, "Format error in %s file near %s #%d\n",
              modes[mode], modes[mode], nr);
      fprintf(stderr, "Offending line: '%s'\n", line);
      exit(1);
    }
  }
}


long asciiflag_conv(char *flag)
{
  long flags = 0;
  register char *p;

  if (is_integer(flag))
    flags = atol(flag);
  else
    for (p = flag; *p; p++) {
      if (islower(*p))
        flags |= 1 << (*p - 'a');
      else if (isupper(*p))
        flags |= 1 << (26 + (*p - 'A'));
    }

  return flags;
}

char fread_letter(FILE *fp)
{
  char c;
  do {
    c = getc(fp);
  } while (isspace(c));
  return c;
}



/* load the rooms */
void parse_room(FILE * fl, int virtual_nr)
{
  static int room_nr = 0, zone = 0;
  int t[10], i;
  char line[256], flags[128];
  struct extra_descr_data *new_descr;
  char letter;

  if (virtual_nr <= (zone ? zone_table[zone - 1].top : -1)) {
    fprintf(stderr, "Room #%d is below zone %d.\n", virtual_nr, zone);
    exit(1);
  }
  while (virtual_nr > zone_table[zone].top)
    if (++zone > top_of_zone_table) {
      fprintf(stderr, "Room %d is outside of any zone.\n", virtual_nr);
      exit(1);
    }
  world[room_nr].zone = zone;
  world[room_nr].vnum = virtual_nr;
  world[room_nr].name = fread_string(fl, buf2);
  world[room_nr].description = fread_string(fl, buf2);

  if (!get_line(fl, line) || sscanf(line, " %d %s %d ", t, flags, t + 2) != 3) {
    fprintf(stderr, "Format error in room #%d\n", virtual_nr);
    exit(1);
  }
  /* t[0] is the zone number; ignored with the zone-file system */
  /* room_flags is a flagvector array */
  world[room_nr].room_flags[0] = asciiflag_conv(flags);
  world[room_nr].sector_type = t[2];

  world[room_nr].func = NULL;
  world[room_nr].contents = NULL;
  world[room_nr].people = NULL;
  world[room_nr].light = 0;        /* Zero light sources */

  for (i = 0; i < NUM_OF_DIRS; i++)
    world[room_nr].exits[i] = NULL;

  world[room_nr].ex_description = NULL;

  sprintf(buf, "Format error in room #%d (expecting D/E/S)", virtual_nr);

  for (;;) {
    if (!get_line(fl, line)) {
      fprintf(stderr, "%s\n", buf);
      exit(1);
    }
    switch (*line) {
    case 'D':
      setup_dir(fl, room_nr, atoi(line + 1));
      break;
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(fl, buf2);
      new_descr->description = fread_string(fl, buf2);
      new_descr->next = world[room_nr].ex_description;
      world[room_nr].ex_description = new_descr;
      break;
    case 'S':                        /* end of room */
      letter = fread_letter(fl);
      ungetc(letter, fl);
      while (letter=='T') {
        dg_read_trigger(fl, &world[room_nr], WLD_TRIGGER);
        letter = fread_letter(fl);
        ungetc(letter, fl);
      }
      top_of_world = room_nr++;
      return;
      break;
    default:
      fprintf(stderr, "%s\n", buf);
      exit(1);
      break;
    }
  }
}

/* read direction data */
void setup_dir(FILE * fl, int room, int dir)
{
  int t[5];
  char line[256];
  char log_buf[100];

  sprintf(buf2, "room #%d, direction D%d", world[room].vnum, dir);
  /* added by gurlaek to stop memory leaks detected by insure++ 8/26/1999 */
  if(world[room].exits[dir]) {
    sprintf(log_buf,
          "SYSERR:db.c:setup_dir:creating direction [%d] for room %d twice!",
          dir, world[room].vnum);
    log("%s", log_buf);
  } else {
    world[room].exits[dir] = create_exit(NOWHERE);
  }
  world[room].exits[dir]->general_description = fread_string(fl, buf2);
  world[room].exits[dir]->keyword = fread_string(fl, buf2);

  if (!get_line(fl, line)) {
    fprintf(stderr, "Format error, %s\n", buf2);
    exit(1);
  }
  if (sscanf(line, " %d %d %d ", t, t + 1, t + 2) != 3) {
    fprintf(stderr, "Format error, %s\n", buf2);
    exit(1);
  }
  if (t[0] == 1)
    world[room].exits[dir]->exit_info = EX_ISDOOR;
  else if (t[0] == 2)
    world[room].exits[dir]->exit_info = EX_ISDOOR | EX_PICKPROOF;
  else if (t[0] == 3) {
    world[room].exits[dir]->exit_info = EX_DESCRIPT;
    t[1] = -1;
    t[2] = -1;
  } else
    world[room].exits[dir]->exit_info = 0;

  world[room].exits[dir]->key = t[1];
  world[room].exits[dir]->to_room = t[2];
}


/* make sure the start rooms exist & resolve their vnums to rnums */
void check_start_rooms(void)
{
  extern int mortal_start_room;
  extern int immort_start_room;
  extern int frozen_start_room;

  if ((r_mortal_start_room = real_room(mortal_start_room)) < 0) {
    log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
    exit(1);
  }
  if ((r_immort_start_room = real_room(immort_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Immort start room does not exist.  Change in config.c.");
    r_immort_start_room = r_mortal_start_room;
  }
  if ((r_frozen_start_room = real_room(frozen_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Frozen start room does not exist.  Change in config.c.");
    r_frozen_start_room = r_mortal_start_room;
  }
}


/* resolve all vnums into rnums in the world */
void renum_world(void)
{
  int rnum;
  register int room, door;

  for (room = 0; room <= top_of_world; room++)
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (world[room].exits[door])
        if (world[room].exits[door]->to_room != NOWHERE) {
          rnum = real_room(world[room].exits[door]->to_room);
          world[room].exits[door]->to_room = rnum;
          if(rnum == NOWHERE) {
            sprintf(buf, "SYSERR:db.c:renum_world():Invalid exit to NOWHERE for dir %s in room %d", dirs[door], world[room].vnum);
            log("%s",buf);
          }
        }
}



#define ZCMD zone_table[zone].cmd[cmd_no]

/* resulve vnums into rnums in the zone reset tables */
void renum_zone_table(void)
{
  int zone, cmd_no, a, b;

  for (zone = 0; zone <= top_of_zone_table; zone++)
    for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {
      a = b = 0;
      switch (ZCMD.command) {
      case 'M':
        a = ZCMD.arg1 = real_mobile(ZCMD.arg1);
        b = ZCMD.arg3 = real_room(ZCMD.arg3);
        break;
      case 'O':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        if (ZCMD.arg3 != NOWHERE)
          b = ZCMD.arg3 = real_room(ZCMD.arg3);
        break;
      case 'G':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        break;
      case 'E':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        break;
      case 'P':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        b = ZCMD.arg3 = real_object(ZCMD.arg3);
        break;
      case 'D':
        a = ZCMD.arg1 = real_room(ZCMD.arg1);
        break;
      case 'R': /* rem obj from room */
        a = ZCMD.arg1 = real_room(ZCMD.arg1);
        b = ZCMD.arg2 = real_object(ZCMD.arg2);
        break;
      }
      if (a < 0 || b < 0) {
        if (!mini_mud)
          log_zone_error(zone, cmd_no, "Invalid vnum, cmd disabled");
        ZCMD.command = '*';
      }
    }
}



#define OLC_MOB(d)        ((d)->olc->mob)
void parse_simple_mob(FILE *mob_f, int i, int nr)
{
  int j, t[10];
  char line[256];
  long k = 0;
  struct char_data *mobproto;
  extern void roll_natural_abils(struct char_data *ch);

  get_line(mob_f, line);
  if (sscanf(line, " %d %d %d %dd%d+%d %dd%d+%d ",
             t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8) != 9) {
    fprintf(stderr, "Format error in mob #%d, first line after S flag\n"
            "...expecting line of form '# # # #d#+# #d#+#'\n", nr);
    exit(1);
  }
  GET_LEVEL(mob_proto + i) = t[0];
   /*  No negative hitroll bonus DO_NOT CHANGE -Banyal */
  mob_proto[i].mob_specials.ex_hitroll = LIMIT(0, t[1], 20);

  mob_proto[i].mob_specials.ex_armor = 10 * t[2];
  /*if ac onmedit is 0 then ignore it*/


  /* max hit = 0 is a flag that H, M, V is xdy+z */
  mob_proto[i].points.max_hit = 0;

  mob_proto[i].mob_specials.ex_max_hit = 0;
  mob_proto[i].mob_specials.ex_no_dice = t[3];
  mob_proto[i].mob_specials.ex_face = t[4];

  /*mob_proto[i].points.hit = t[3];
    mob_proto[i].points.mana = t[4];
  */

  mob_proto[i].points.move = t[5];
  mob_proto[i].points.max_mana = 10;
  mob_proto[i].points.max_move = 50;

  mob_proto[i].mob_specials.ex_damnodice = t[6];
  mob_proto[i].mob_specials.ex_damsizedice = t[7];
  mob_proto[i].mob_specials.ex_damroll = t[8];

  get_line(mob_f, line);
  if (sscanf(line, " %d %d %d %d", t, t + 1, t + 2, t + 3) > 3)
    {
      GET_ZONE(mob_proto + i) = t[2];
      GET_EX_GOLD(mob_proto + i) = t[0];
      GET_EX_PLATINUM(mob_proto + i) = t[1];
    }else
      {        GET_ZONE(mob_proto + i) = (nr/100);
      GET_EX_GOLD(mob_proto + i) = 0;
      GET_EX_PLATINUM(mob_proto + i) = 0;

      }        GET_EX_GOLD(mob_proto + i) = t[0];



  get_line(mob_f, line);
  if ((sscanf(line, " %d %d %d %d %d %d %d %d ", t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7))  > 3) {
    mob_proto[i].player.class = t[3];
    mob_proto[i].player.race = t[4];
    mob_proto[i].player.race_align = t[5];
    set_base_size(&(mob_proto[i]), t[6]);
    mob_proto[i].char_specials.position = t[0];
    mob_proto[i].mob_specials.default_pos = t[1];
    mob_proto[i].player.sex = t[2];
  } else {
    mob_proto[i].player.class = CLASS_DEFAULT;t[3] = CLASS_DEFAULT;
    mob_proto[i].player.race = DEFAULT_RACE;t[4] = DEFAULT_RACE;
    mob_proto[i].player.race_align = 0;
    set_base_size(&(mob_proto[i]), SIZE_OF_RACE(DEFAULT_RACE));
    mob_proto[i].char_specials.position = t[0];
    mob_proto[i].mob_specials.default_pos = t[1];
    mob_proto[i].player.sex = t[2];
  }
  mob_proto[i].char_specials.stance = STANCE_ALERT;
  if (!VALID_CLASSNUM((int)mob_proto[i].player.class))
     mob_proto[i].player.class = CLASS_DEFAULT;
  mobproto = &mob_proto[i];
  mobproto->player_specials = &dummy_mob; /* dummy player_specials for mobs */
  roll_natural_abils(mobproto);  /* mobs now get rolled just like PC's */
  mobproto->actual_abils = mobproto->natural_abils;  /* set the initail viewed abils */
  scale_attribs(mobproto);  /* this scales the attribs for race */

  mob_proto[i].player.height = 198;

  mob_proto[i].points.coins[PLATINUM] = 0;
  mob_proto[i].points.coins[GOLD] = 0;
  mob_proto[i].points.coins[SILVER] = 0;
  mob_proto[i].points.coins[COPPER] = 0;

        /*Money adder*/
  k = j = 0;
  k = get_copper(i);
  j = (60 * k) / 100;
  mob_proto[i].points.coins[PLATINUM] = j / PLATINUM_SCALE;
  j = ((20 * k) / 100) + (j % PLATINUM_SCALE);
  mob_proto[i].points.coins[GOLD] = j / GOLD_SCALE;
  j = ((18 * k) / 100) + (j % GOLD_SCALE);
  mob_proto[i].points.coins[SILVER] = j / SILVER_SCALE;
  if (mob_proto[i].player.level > 20)
    j = (k / 200) + (j % SILVER_SCALE);
  j = ((2 * k) / 100) + (j % SILVER_SCALE);
  mob_proto[i].points.coins[COPPER] = j / COPPER_SCALE;

  mob_proto[i].points.coins[PLATINUM] = MAX(0, mob_proto[i].points.coins[PLATINUM] + GET_EX_PLATINUM(mob_proto + i));
  mob_proto[i].points.coins[GOLD] = MAX(0, mob_proto[i].points.coins[GOLD] + GET_EX_GOLD(mob_proto + i));

  /*auto ac stuff*/
  /*        l = get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
        sprintf(buf, "get is: %d", l);
        mudlog(buf, BRF, LVL_IMPL, TRUE);
  */
  if ((mob_proto[i].mob_specials.ex_armor != 100))
    mob_proto[i].points.armor = mob_proto[i].mob_specials.ex_armor + get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
        else
          mob_proto[i].points.armor = (sh_int) get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));



  /*num of hp dice is hit*/
  GET_EXP(mob_proto + i) = get_set_exp(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i),  GET_ZONE(mob_proto + i));
  GET_EXP(mob_proto + i) += GET_EX_EXP(mob_proto + i);

  mob_proto[i].points.mana = get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 2);
  mob_proto[i].points.hit = 7;;
  mob_proto[i].points.mana += mob_proto[i].mob_specials.ex_face;
  mob_proto[i].points.hit += mob_proto[i].mob_specials.ex_no_dice;
  GET_EX_MAIN_HP(mob_proto + i) = (get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1));

  mob_proto[i].points.damroll        = get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
  mob_proto[i].points.damroll        += mob_proto[i].mob_specials.ex_damroll;
   /*  Changed to get rid of the -199 mobb hitrolls Do NOT change -Banyal */
  mob_proto[i].points.hitroll = LIMIT(10, get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i),
                                                       GET_CLASS(mob_proto + i), 0), 80);
  mob_proto[i].points.hitroll += mob_proto[i].mob_specials.ex_hitroll;

  mob_proto[i].mob_specials.damnodice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 0);
  mob_proto[i].mob_specials.damnodice += mob_proto[i].mob_specials.ex_damnodice;
  mob_proto[i].mob_specials.damsizedice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
  mob_proto[i].mob_specials.damsizedice += mob_proto[i].mob_specials.ex_damsizedice;

  /*last check values above 0*/
  mob_proto[i].mob_specials.damsizedice = MAX(0, mob_proto[i].mob_specials.damsizedice);
  mob_proto[i].mob_specials.damnodice = MAX(0, mob_proto[i].mob_specials.damnodice);
  mob_proto[i].points.hitroll = MAX(0, mob_proto[i].points.hitroll);
  mob_proto[i].points.damroll = MAX(0, mob_proto[i].points.damroll);
  mob_proto[i].points.armor = MIN(100, MAX(-100, mob_proto[i].points.armor));

  for (j = 0; j <= NUM_SPELL_CIRCLES; ++j)
    GET_MOB_SPLBANK(&mob_proto[i], j) = spells_of_circle[(int) GET_LEVEL(&mob_proto[i])][j];

  for (j = 0; j < 3; j++)
    GET_COND(mob_proto + i, j) = -1;

  /*
   * these are now save applies; base save numbers for MOBs are now from
   * the warrior save table.
   */
  for (j = 0; j < 5; j++)
    GET_SAVE(mob_proto + i, j) = 0;
  /* mobs now get the same spells/skills as pc's */
  /*set_mob_skills(i, t[3], t[4]);*/
}




/*
 * interpret_espec is the function that takes espec keywords and values
 * and assigns the correct value to the mob as appropriate.  Adding new
 * e-specs is absurdly easy -- just add a new CASE statement to this
 * function!  No other changes need to be made anywhere in the code.
 */

#define CASE(test) if (!matched && !str_cmp(keyword, test) && (matched = 1))
#define RANGE(low, high) (num_arg = MAX((low), MIN((high), (num_arg))))
/* modified for the 100 attrib scale */
void interpret_espec(char *keyword, char *value, int i, int nr)
{
  int num_arg, matched = 0;

  num_arg = atoi(value);

  CASE("BareHandAttack") {
    RANGE(0, 99);
    mob_proto[i].mob_specials.attack_type = num_arg;
  }

  CASE("Str") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.str = num_arg;
  }

  CASE("Int") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.intel = num_arg;
  }

  CASE("Wis") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.wis = num_arg;
  }

  CASE("Dex") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.dex = num_arg;
  }

  CASE("Con") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.con = num_arg;
  }

  CASE("Cha") {
    RANGE(30, 100);
    mob_proto[i].natural_abils.cha = num_arg;
  }

  CASE("AFF2") {
     EFF_FLAGS(mob_proto + i)[1] = num_arg;
  }

  CASE("AFF3") {
     EFF_FLAGS(mob_proto + i)[2] = num_arg;
  }

  CASE("MOB2") {
     MOB_FLAGS(mob_proto + i)[1] = num_arg;
  }

  CASE("PERC") {
     GET_PERCEPTION(mob_proto + i) = num_arg;
  }

  CASE("HIDE") {
     GET_HIDDENNESS(mob_proto + i) = num_arg;
  }

  CASE("Lifeforce") {
     GET_LIFEFORCE(mob_proto + i) = num_arg;
  }

  CASE("Composition") {
     BASE_COMPOSITION(mob_proto + i) = num_arg;
     GET_COMPOSITION(mob_proto + i) = num_arg;
  }

  CASE("Stance") {
     GET_STANCE(mob_proto + i) = num_arg;
  }

  if (!matched) {
    fprintf(stderr, "Warning: unrecognized espec keyword %s in mob #%d\n",
            keyword, nr);
  }
}

#undef CASE
#undef RANGE

void parse_espec(char *buf, int i, int nr)
{
  char *ptr;

  if ((ptr = strchr(buf, ':')) != NULL) {
    *(ptr++) = '\0';
    while (isspace(*ptr))
      ptr++;
  } else
    ptr = "";

  interpret_espec(buf, ptr, i, nr);
}


void parse_enhanced_mob(FILE *mob_f, int i, int nr)
{
  char line[256];

  parse_simple_mob(mob_f, i, nr);

  while (get_line(mob_f, line)) {
    if (!strcmp(line, "E"))        /* end of the ehanced section */
      return;
    else if (*line == '#') {        /* we've hit the next mob, maybe? */
      fprintf(stderr, "Unterminated E section in mob #%d\n", nr);
      exit(1);
    } else
      parse_espec(line, i, nr);
  }

  fprintf(stderr, "Unexpected end of file reached after mob #%d\n", nr);
  exit(1);
}


void parse_mobile(FILE * mob_f, int nr)
{
  static int i = 0;
  int j, t[10];
  char line[256], *tmpptr, letter;
  char f1[128], f2[128];

  mob_index[i].virtual = nr;
  mob_index[i].number = 0;
  mob_index[i].func = NULL;
  clear_char(mob_proto + i);

  sprintf(buf2, "mob vnum %d", nr);

  /***** String data *** */
  mob_proto[i].player.namelist = fread_string(mob_f, buf2);
  tmpptr = mob_proto[i].player.short_descr = fread_string(mob_f, buf2);
  if (tmpptr && *tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
        !str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);
  mob_proto[i].player.long_descr = fread_string(mob_f, buf2);
  mob_proto[i].player.description = fread_string(mob_f, buf2);
  mob_proto[i].player.title = NULL;
  mob_proto[i].player.prompt = NULL;

  /* *** Numeric data *** */
  mob_proto[i].mob_specials.nr = i;
  get_line(mob_f, line);
  sscanf(line, "%s %s %d %c", f1, f2, t + 2, &letter);
  MOB_FLAGS(mob_proto + i)[0] = asciiflag_conv(f1);
  SET_FLAG(MOB_FLAGS(mob_proto + i), MOB_ISNPC);
  EFF_FLAGS(mob_proto + i)[0] = asciiflag_conv(f2);
  GET_ALIGNMENT(mob_proto + i) = t[2];

  switch (letter) {
  case 'S':        /* Simple monsters */
    parse_simple_mob(mob_f, i, nr);
    break;
  case 'E':        /* Circle3 Enhanced monsters */
    parse_enhanced_mob(mob_f, i, nr);
    break;
    /* add new mob types here.. */
  default:
    fprintf(stderr, "Unsupported mob type '%c' in mob #%d\n", letter, nr);
    exit(1);
    break;
  }

  letter = fread_letter(mob_f);
  ungetc(letter, mob_f);
  while (letter=='T') {
    dg_read_trigger(mob_f, &mob_proto[i], MOB_TRIGGER);
    letter = fread_letter(mob_f);
    ungetc(letter, mob_f);
  }


  mob_proto[i].affected_abils = mob_proto[i].natural_abils;

  for (j = 0; j < NUM_WEARS; j++)
    mob_proto[i].equipment[j] = NULL;

  mob_proto[i].desc = NULL;

  letter = fread_letter(mob_f);
  if (letter == '>')
  {
          while (fread_letter(mob_f) != '|');
          fprintf(stderr,"Mob %d has a mobprog still!\n",nr);
  }
  else
          ungetc(letter, mob_f);

  if (mob_proto[i].mob_specials.default_pos < 0 ||
        mob_proto[i].mob_specials.default_pos >= NUM_POSITIONS) {
     mob_proto[i].mob_specials.default_pos = POS_STANDING;
  }
  if (mob_proto[i].char_specials.position < 0 ||
        mob_proto[i].char_specials.position >= NUM_POSITIONS) {
     mob_proto[i].char_specials.position = POS_STANDING;
  }

  top_of_mobt = i++;
}

void verify_obj_spell(struct obj_data *obj, int valnum, bool zero_ok)
{
   if (!IS_SPELL(GET_OBJ_VAL(obj, valnum)) &&
         !(zero_ok && GET_OBJ_VAL(obj, valnum) == 0)) {
      mprintf(L_WARN, LVL_IMMORT,
            "ERROR: Invalid spell in object prototype. vnum=%d spellnum=%d",
            GET_OBJ_VNUM(obj), GET_OBJ_VAL(obj, valnum));
      /* Replace invalid spell with a benign value */
      if (zero_ok)
         GET_OBJ_VAL(obj, valnum) = 0;
      else
         GET_OBJ_VAL(obj, valnum) = SPELL_IDENTIFY;
   }
}


/* Do some post-definition processing on certain object types */
void init_obj_proto(struct obj_data *obj)
{
   char *s;
   struct extra_descr_data *ed;

   switch (GET_OBJ_TYPE(obj)) {
      case ITEM_LIGHT:
         /* Store a light's initial time as value 1, so the
          * illumination spell can restore the light accordingly. */
         GET_OBJ_VAL(obj, VAL_LIGHT_CAPACITY) = GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING);
         break;
      case ITEM_FOOD:
         /* Ensure that all food items have keyword "food". */
         if (!isname("food", obj->name)) {
            /* Prepare the new aliases string */
            /* length + "food" + space + terminator */
            s = (char *)malloc(strlen(obj->name) + 4 + 1 + 1);
            sprintf(s, "%s food", obj->name);

            /* If there is an extra description whose keywords exactly
             * match the object's aliases, give it "food" as well. */
            for (ed = obj->ex_description; ed; ed = ed->next)
               if (!strcmp(ed->keyword, obj->name)) {
                  free(ed->keyword);
                  ed->keyword = (char *)malloc(strlen(s) + 1);
                  strcpy(ed->keyword, s);
                  break;
               }

            free(obj->name);
            obj->name = s;
         }
         break;
      case ITEM_KEY:
         /* Prevent keys from being rented. */
         SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_NORENT);
         break;
      case ITEM_SCROLL:
         verify_obj_spell(obj, VAL_SCROLL_SPELL_1, FALSE);
         verify_obj_spell(obj, VAL_SCROLL_SPELL_2, TRUE);
         verify_obj_spell(obj, VAL_SCROLL_SPELL_3, TRUE);
         break;
      case ITEM_WAND:
         verify_obj_spell(obj, VAL_WAND_SPELL, FALSE);
         break;
      case ITEM_STAFF:
         verify_obj_spell(obj, VAL_STAFF_SPELL, FALSE);
         break;
      case ITEM_POTION:
         verify_obj_spell(obj, VAL_POTION_SPELL_1, FALSE);
         verify_obj_spell(obj, VAL_POTION_SPELL_2, TRUE);
         verify_obj_spell(obj, VAL_POTION_SPELL_3, TRUE);
         break;
   }

   /* Remove flags we don't want on prototypes */
   REMOVE_FLAG(GET_OBJ_FLAGS(obj), ITEM_WAS_DISARMED);
}

/* read all objects from obj file; generate index and prototypes */
char *parse_object(FILE * obj_f, int nr)
{
  static int i = 0, retval;
  static char line[256];
  int t[10], j;
  char *tmpptr;
  char f1[256], f2[256];
  struct extra_descr_data *new_descr, *edx;

  obj_index[i].virtual = nr;
  obj_index[i].number = 0;
  obj_index[i].func = NULL;

  clear_object(obj_proto + i);
  obj_proto[i].in_room = NOWHERE;
  obj_proto[i].item_number = i;

  sprintf(buf2, "object #%d", nr);

  /* *** string data *** */
  if ((obj_proto[i].name = fread_string(obj_f, buf2)) == NULL) {
    fprintf(stderr, "Null obj name or format error at or near %s\n", buf2);
    exit(1);
  }
  tmpptr = obj_proto[i].short_description = fread_string(obj_f, buf2);
  if (*tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
        !str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);

  tmpptr = obj_proto[i].description = fread_string(obj_f, buf2);
  if (tmpptr && *tmpptr)
    *tmpptr = UPPER(*tmpptr);
  obj_proto[i].action_description = fread_string(obj_f, buf2);

  /* *** numeric data *** */
  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, " %d %s %s %d", t, f1, f2, t+1)) != 4) {
    if (retval == 3) {
      sscanf(line, " %d %s %s", t, f1, f2);
      t[1] = 0;
      fprintf(stderr, "Object #%d needs a level assigned to it.\n", nr);
    } else {
      fprintf(stderr, "Format error in first numeric line (expecting 4 args, got %d), %s\n", retval, buf2);
      /* exit(1);*/
    }
  }
  obj_proto[i].obj_flags.type_flag = t[0];
  obj_proto[i].obj_flags.extra_flags[0] = asciiflag_conv(f1);
  obj_proto[i].obj_flags.wear_flags = asciiflag_conv(f2);
  obj_proto[i].obj_flags.level = t[1]; /* Zantir 3/23/01 for level based objects */

  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, "%d %d %d %d %d %d %d", t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6)) != 7) {
    fprintf(stderr, "Format error in second numeric line (expecting 7 args, got %d), %s\n", retval, buf2);
    /*exit(1);*/
  }
  obj_proto[i].obj_flags.value[0] = t[0];
  obj_proto[i].obj_flags.value[1] = t[1];
  obj_proto[i].obj_flags.value[2] = t[2];
  obj_proto[i].obj_flags.value[3] = t[3];
  obj_proto[i].obj_flags.value[4] = t[4];
  obj_proto[i].obj_flags.value[5] = t[5];
  obj_proto[i].obj_flags.value[6] = t[6];

  if (!get_line(obj_f, line) ||
      (retval = sscanf(line, "%f %d %d %d %d %d %d %d",
                       &obj_proto[i].obj_flags.weight,
                       t + 1, t + 2, t + 3, t+ 4, t + 5, t + 6, t + 7)) != 8)
    {
      fprintf(stderr, "Format error in third numeric line (expecting 8 args, got %d), %s\n", retval, buf2);
      /*exit(1);*/
    }

  obj_proto[i].obj_flags.cost = t[1];
  obj_proto[i].obj_flags.timer = t[2];
  obj_proto[i].obj_flags.effect_flags[0] = t[3];
/*    obj_proto[i].spell_component = t[4]; */
/*    obj_proto[i].object_limitation = t[5]; */
  obj_proto[i].obj_flags.effect_flags[1] = t[6];
  obj_proto[i].obj_flags.effect_flags[2] = t[7];

  /* *** extra descriptions and affect fields *** */

  for (j = 0; j < MAX_OBJ_APPLIES; j++) {
    obj_proto[i].applies[j].location = APPLY_NONE;
    obj_proto[i].applies[j].modifier = 0;
  }

  strcat(buf2, ", after numeric constants (expecting E/A/#xxx)");
  j = 0;

  for (;;) {
    if (!get_line(obj_f, line)) {
      fprintf(stderr, "Format error in %s\n", buf2);
      exit(1);
    }
    switch (*line) {
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(obj_f, buf2);
      new_descr->description = fread_string(obj_f, buf2);
      /* Put each extra desc at the end of the list as we read them.
       * Otherwise they will be reversed (yes, we really don't want that -
       * see act.informative.c, show_obj_to_char(), mode 5). */
      if ((edx = obj_proto[i].ex_description)) {
         for (;edx->next; edx = edx->next);
         edx->next = new_descr;
      } else
         obj_proto[i].ex_description = new_descr;
      break;
    case 'A':
      if (j >= MAX_OBJ_APPLIES) {
        fprintf(stderr, "Too many A fields (%d max), %s\n", MAX_OBJ_APPLIES, buf2);
        exit(1);
      }

      if (!get_line(obj_f, line) ||
          (retval = sscanf(line, " %d %d ", t, t + 1)) != 2)
        {
          fprintf(stderr, "Format error in Affect line (expecting 2 args, got %d), %s\n", retval, buf2);
          /*exit(1);*/
        }
      /* get_line(obj_f, line);
         sscanf(line, " %d %d ", t, t + 1); */
      obj_proto[i].applies[j].location = t[0];
      obj_proto[i].applies[j].modifier = t[1];
      j++;
      break;

    case 'H':  /* Hiddenness */
      get_line(obj_f, line);
      sscanf(line, "%d ", t);
      obj_proto[i].obj_flags.hiddenness = t[0];
      break;
    case 'T':  /* DG triggers */
      dg_obj_trigger(line, &obj_proto[i]);
      break;

    case '$':
    case '#':
      init_obj_proto(&obj_proto[i]);
      top_of_objt = i++;
      return line;
      break;
    default:
      fprintf(stderr, "Format error in %s\n", buf2);
      exit(1);
      break;
    }
  }
}


#define Z        zone_table[zone]

/* load the zone table and command tables */
void load_zones(FILE * fl, char *zonename)
{
  static int zone = 0;
  int cmd_no = 0, num_of_cmds = 0, line_num = 0, tmp, error;
  char *ptr, buf[256], zname[256];

  strcpy(zname, zonename);

  while (get_line(fl, buf) && buf[0] != '$')
    num_of_cmds++;

  rewind(fl);

  if (num_of_cmds == 0) {
    fprintf(stderr, "%s is empty!\n", zname);
    exit(0);
  } else
    CREATE(Z.cmd, struct reset_com, num_of_cmds);

  line_num += get_line(fl, buf);

  if (sscanf(buf, "#%d", &Z.number) != 1) {
    fprintf(stderr, "Format error in %s, line %d\n", zname, line_num);
    exit(0);
  }
  sprintf(buf2, "beginning of zone #%d", Z.number);

  line_num += get_line(fl, buf);
  if ((ptr = strchr(buf, '~')) != NULL)        /* take off the '~' if it's there */
    *ptr = '\0';
  Z.name = strdup(buf);

  line_num += get_line(fl, buf);
  if (sscanf(buf, " %d %d %d %d %d %d", &Z.top, &Z.lifespan,
             &Z.reset_mode, &Z.zone_factor, &Z.hemisphere, &Z.climate) != 4)
    Z.zone_factor = 100;

  for (;;) {
    if ((tmp = get_line(fl, buf)) == 0) {
      fprintf(stderr, "Format error in %s - premature end of file\n", zname);
      exit(0);
    }
    line_num += tmp;
    ptr = buf;
    skip_spaces(&ptr);

    if ((ZCMD.command = *ptr) == '*')
      continue;

    ptr++;

    if (ZCMD.command == 'S' || ZCMD.command == '$') {
      ZCMD.command = 'S';
      break;
    }
    error = 0;
    if (ZCMD.command == 'F')  /* force mobile command */ {
      skip_spaces(&ptr);
      if (*ptr) {
        tmp = *ptr;
        ptr++;
        skip_spaces(&ptr);
        ZCMD.sarg = strdup(ptr);
      } else
        error = 1;
    } else
      if (strchr("MOEPD", ZCMD.command) == NULL) {        /* a 3-arg command */
        if (sscanf(ptr, " %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2) != 3)
          error = 1;
      } else {
        if (sscanf(ptr, " %d %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2,
                   &ZCMD.arg3) != 4)
          error = 1;
      }

    ZCMD.if_flag = tmp;

    if (error) {
      fprintf(stderr, "Format error in %s, line %d: '%s'\n", zname,
              line_num, buf);
      exit(0);
    }
    ZCMD.line = line_num;
    cmd_no++;
  }

  top_of_zone_table = zone++;
}

#undef Z

void get_one_line(FILE *fl, char *line_buf)
{
  *line_buf = '\0';

  if (fgets(line_buf, READ_SIZE, fl) == NULL) {
    log("error reading help file: not terminated with $?");
    exit(1);
  }

  line_buf[strlen(line_buf) - 1] = '\0'; /* take off the trailing \n */
}


void load_help(FILE *fl)
{
  char key[READ_SIZE+1], next_key[READ_SIZE+1], entry[32384];
  char line[READ_SIZE+1], *scan;
  struct help_index_element el;

  /* get the first keyword line */
  get_one_line(fl, key);

  if(!strlen(key)) {
    log("Illegal blank line in help file");
    abort();
  }
  while (*key != '$') {
    /* read in the corresponding help entry */
    strcpy(entry, strcat(key, "\r\n"));
    get_one_line(fl, line);
    while (*line != '#') {
      strcat(entry, strcat(line, "\r\n"));
      get_one_line(fl, line);
    }

    el.min_level = 0;
    if ((*line == '#') && (*(line + 1) != 0))
      el.min_level = atoi((line + 1));

    el.min_level = MAX(0, MIN(el.min_level, LVL_IMPL));

    /* now, add the entry to the index with each keyword on the keyword line */
    el.duplicate = 0;
    el.entry = strdup(entry);
    scan = one_word(key, next_key);
    while (*next_key) {
      el.keyword = strdup(next_key);
      help_table[top_of_helpt++] = el;
      el.duplicate++;
      scan = one_word(scan, next_key);
    }

    /* get next keyword line (or $) */
    get_one_line(fl, key);

    if(!strlen(key)) {
      log("Illegal blank line in help file");
      abort();
    }
  }
}


int hsort(const void *a, const void *b)
{
  struct help_index_element *a1, *b1;

  a1 = (struct help_index_element *) a;
  b1 = (struct help_index_element *) b;

  return (str_cmp(a1->keyword, b1->keyword));
}

void free_help_table(void)
{
  if (help_table) {
    int hp;
    for (hp = 0; hp <= top_of_helpt; hp++) {
      if (help_table[hp].keyword)
        free(help_table[hp].keyword);
      if (help_table[hp].entry && !help_table[hp].duplicate)
        free(help_table[hp].entry);
    }
    free(help_table);
    help_table = NULL;
  }
  top_of_helpt = 0;
}


/*************************************************************************
*  procedures for resetting, both play-time and boot-time                  *
*********************************************************************** */



int vnum_zone(char *searchname, struct char_data * ch)
{
  int nr, found = 0;

  for (nr = 0; nr <= top_of_zone_table; nr++) {
    if (isname(searchname, zone_table[nr].name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
              zone_table[nr].number,
              zone_table[nr].name);
      send_to_char(buf, ch);
    }
  }
  return (found);
}


/* create a character, and add it to the char list */
struct char_data *create_char(void)
{
  struct char_data *ch;

  CREATE(ch, struct char_data, 1);
  clear_char(ch);
  ch->next = character_list;
  character_list = ch;
  GET_ID(ch) = max_id++;
  return ch;
}

/* set up mob for loading. for use in read_mobile and anywhere else we want
 * to make a mob from scratch -- mostly copied n pasted from read_mobile - 321
 */
void setup_mob(struct char_data *mob)
{
  extern void roll_natural_abils(struct char_data *ch);

  mob->player_specials = &dummy_mob;
  /* mobs now get rolled just like PC's --gurlaek 6/28/1999 */
  roll_natural_abils(mob);
  mob->actual_abils = mob->natural_abils;
  scale_attribs(mob);

  /* Set skills, innates, and other things according to class and species: */
  init_char(mob);

  if (!mob->points.max_hit)
    mob->points.max_hit = MAX(
          0,
          MIN(
             32000,
             dice(mob->points.hit, mob->points.mana) +
             GET_EX_MAIN_HP(mob) +
             mob->points.move));
  else
    mob->points.max_hit = number(mob->points.hit, mob->points.mana);

  mob->points.mana = mob->points.max_mana; /* rests mobs mana  */
  mob->points.max_move = natural_move(mob);
  mob->points.move = mob->points.max_move; /* resets mob moves */
  mob->points.hit = mob->points.max_hit;   /* sets full hps    */

  mob->player.time.birth = time(0);
  mob->player.time.played = 0;
  mob->player.time.logon = time(0);

  assign_triggers(mob, MOB_TRIGGER);
}


/* create a new mobile from a prototype */
struct char_data *read_mobile(int nr, int type)
{
  int i;
  struct char_data *mob;

  if (type == VIRTUAL)
  {
    if ((i = real_mobile(nr)) < 0)
    {
      sprintf(buf, "Mobile (V) %d does not exist in database.", nr);
      return (0);
    }
  }
  else
    i = nr;

  CREATE(mob, struct char_data, 1);
  clear_char(mob);
  *mob = mob_proto[i];

  setup_mob(mob);
  mob_index[i].number++;
  GET_ID(mob) = max_id++;

  mob->next = character_list;
  character_list = mob;

  return mob;
}

/* create an object, and add it to the object list */
struct obj_data *create_obj(void)
{
  struct obj_data *obj;

  CREATE(obj, struct obj_data, 1);
  clear_object(obj);
  obj->next = object_list;
  object_list = obj;
  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  return obj;
}


/* create a new object from a prototype */
struct obj_data *read_object(int nr, int type)
{
  struct obj_data *obj;
  int i;

  if (nr < 0) {
    log("SYSERR: trying to create obj with negative num!");
    return NULL;
  }
  if (type == VIRTUAL) {
    if ((i = real_object(nr)) < 0) {
      sprintf(buf, "Object (V) %d does not exist in database.", nr);
      return NULL;
    }
  } else
    i = nr;

  CREATE(obj, struct obj_data, 1);
  clear_object(obj);
  *obj = obj_proto[i];
  obj->next = object_list;
  object_list = obj;

  obj_index[i].number++;
  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  if (GET_OBJ_TYPE(obj) == ITEM_DRINKCON)
     setup_drinkcon(obj, -1);

  return obj;
}



#define ZO_DEAD  999

/* update zone ages, queue for reset if necessary, and dequeue when possible */
void zone_update(void)
{
  int i;
  struct reset_q_element *update_u, *temp;
  static int timer = 0;
  char buf[128];

  /* jelson 10/22/92 */
  if (((++timer * PULSE_ZONE) / PASSES_PER_SEC) >= 60) {
    /* one minute has passed */
    /*
     * NOT accurate unless PULSE_ZONE is a multiple of PASSES_PER_SEC or a
     * factor of 60
     */

    timer = 0;

    /* since one minute has passed, increment zone ages */
    for (i = 0; i <= top_of_zone_table; i++) {
      if (zone_table[i].age < zone_table[i].lifespan &&
          zone_table[i].reset_mode)
        (zone_table[i].age)++;

      if (zone_table[i].age >= zone_table[i].lifespan &&
          zone_table[i].age < ZO_DEAD && zone_table[i].reset_mode) {
        /* enqueue zone */
        
        CREATE(update_u, struct reset_q_element, 1);
        
        update_u->zone_to_reset = i;
        update_u->next = 0;
        
        if (!reset_q.head)
          reset_q.head = reset_q.tail = update_u;
        else {
          reset_q.tail->next = update_u;
          reset_q.tail = update_u;
        }
        
        zone_table[i].age = ZO_DEAD;
      }
    }
  }        /* end - one minute has passed */


  /* dequeue zones (if possible) and reset */
  /* this code is executed every 10 seconds (i.e. PULSE_ZONE) */
  for (update_u = reset_q.head; update_u; update_u = update_u->next)
    if (zone_table[update_u->zone_to_reset].reset_mode == 2 ||
        is_empty(update_u->zone_to_reset)) {
      reset_zone(update_u->zone_to_reset, FALSE);
      sprintf(buf, "Auto zone reset: %s",
              zone_table[update_u->zone_to_reset].name);
      mudlog(buf, CMP, LVL_GOD, FALSE);
      /* dequeue */
      if (update_u == reset_q.head)
        reset_q.head = reset_q.head->next;
      else {
        for (temp = reset_q.head; temp->next != update_u;
             temp = temp->next);
        
        if (!update_u->next)
          reset_q.tail = temp;
        
        temp->next = update_u->next;
      }

      free(update_u);
      break;
    }
}

void log_zone_error(int zone, int cmd_no, char *message)
{
  char buf[256];

  sprintf(buf, "SYSERR: error in zone file: %s", message);
  mudlog(buf, NRM, LVL_GOD, TRUE);

  sprintf(buf, "SYSERR: ...offending cmd: '%c' cmd in zone #%d, line %d",
          ZCMD.command, zone_table[zone].number, ZCMD.line);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}

#define ZONE_ERROR(message) \
        { log_zone_error(zone, cmd_no, message); last_cmd = 0; }

/* reset_door: returns 0 on success, 1, on invalid command */
int reset_door(room_num roomnum, int dir, int resetcmd) {
   switch (resetcmd) {
      case 0:
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         break;
      case 1:
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         break;
      case 2:
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         break;
      case 3:
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
/* allow hidden, but putting descr when no door seems to screw things up
**          SET_BIT(world[roomnum].exits[dir]->exit_info,
                  EX_DESCRIPT);
*/
          break;
      case 4:
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         break;
      case 5:
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].exits[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].exits[dir]->exit_info, EX_HIDDEN);
         break;
      default:
         return 1;
   }
   return 0;
}

/* execute the reset command table of a given zone */
void reset_zone(int zone, byte pop)
{
  int cmd_no, cmd_other, last_cmd = 0;
  struct char_data *mob = NULL;
  struct obj_data *obj, *obj_to;
  room_num other_room;
  struct reset_com *ocmd;

  for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {

    if (ZCMD.if_flag && !last_cmd)
      continue;

    switch (ZCMD.command) {
    case '*':                        /* ignore command */
      last_cmd = 0;
      break;

    case 'F':           /* force mobile to do action */
      if (!mob) {
        ZONE_ERROR("attempt to force-command a non-existent mob");
        break;
      }
      command_interpreter(mob, ZCMD.sarg);
      break;

    case 'M':                        /* read a mobile */
      if (mob_index[ZCMD.arg1].number < ZCMD.arg2) {
        mob = read_mobile(ZCMD.arg1, REAL);
        char_to_room(mob, ZCMD.arg3);
        load_mtrigger(mob);
        last_cmd = 1;
      } else
        last_cmd = 0;
      break;

    case 'O':                        /* read an object */

      if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
        {
          obj = read_object(ZCMD.arg1, REAL);
          if (ZCMD.arg3 >= 0)
            {
            obj_to_room(obj, ZCMD.arg3);
            last_cmd = 1;
            }
          else
            {
                  obj->in_room = NOWHERE;
                  last_cmd = 1;
            }
        }
      else
        last_cmd = 0;
      break;

    case 'P':                        /* object to object */
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
        {
          obj = read_object(ZCMD.arg1, REAL);
              if (!(obj_to = find_obj_in_world(find_by_rnum(ZCMD.arg3))))
                {
                  ZONE_ERROR("target obj not found");
                  extract_obj(obj);
                  break;
                }
              obj_to_obj(obj, obj_to);
              last_cmd = 1;
        }
      else
        last_cmd = 0;
      break;

    case 'G':                        /* obj_to_char */
      if (!mob)
        {
          ZONE_ERROR("attempt to give obj to non-existent mob");
          break;
        }

      if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
        {
          obj = read_object(ZCMD.arg1, REAL);

          if (GET_LEVEL(mob) < GET_OBJ_LEVEL(obj)) {
            char error_buf[2048];
            sprintf(error_buf, "Mob %s [%d] in room %d  cannot use object "
                    "%s [%d] because its level is to low.",
                    GET_NAME(mob), GET_MOB_VNUM(mob),
                    mob->in_room,
                    obj->short_description, GET_OBJ_VNUM(obj));
          }


              obj_to_char(obj, mob);
              last_cmd = 1;
        }
      else
        last_cmd = 0;
      break;

    case 'E':                        /* object to equipment list */
      if (!mob) {
         ZONE_ERROR("trying to equip non-existent mob");
         break;
      }/*was make sure number less then ZCMD.arg2*/
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) {
         if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS) {
            ZONE_ERROR("invalid equipment pos number");
         } else {
            obj = read_object(ZCMD.arg1, REAL);
            if (equip_char(mob, obj, ZCMD.arg3) != EQUIP_RESULT_SUCCESS) {
               mprintf(L_ERROR, 101, "EQUIP zone command for %s [%d] in room %d to equip %s [%d] failed.",
                     GET_NAME(mob), GET_MOB_VNUM(mob),
                     ROOM_RNUM_TO_VNUM(mob->in_room),
                     obj->short_description, GET_OBJ_VNUM(obj));
               extract_obj(obj);
            }
            last_cmd = 1;
         }
     } else
         last_cmd = 0;
      break;

    case 'R': /* rem obj from room */
      if ((obj = find_obj_in_list(world[ZCMD.arg1].contents, find_by_rnum(ZCMD.arg2))) != NULL) {
        obj_from_room(obj);
        extract_obj(obj);
      }
      last_cmd = 1;
      break;


      case 'D':                        /* set state of door */
         if (ZCMD.arg2 < 0 || ZCMD.arg2 >= NUM_OF_DIRS ||
               (world[ZCMD.arg1].exits[ZCMD.arg2] == NULL)) {
            ZONE_ERROR("door does not exist");
         } else if (reset_door(ZCMD.arg1, ZCMD.arg2, ZCMD.arg3)) {
            ZONE_ERROR("unknown cmd in reset table; cmd disabled");
            ZCMD.command = '*';
         } else {
            /* reset_door() has returned 0, indicating success */

            /* If the destination room is in another zone, we must perform
             * its door reset commands now, else the opposing sides of the
             * door will become unsynchronized. */

            /* Make sure there is an actual destination room */
            if ((other_room = world[ZCMD.arg1].exits[ZCMD.arg2]->to_room)
                  != NOWHERE) {

               /* Make sure the destination room is in a different zone */
               if (world[other_room].zone != world[ZCMD.arg1].zone) {

                  /* Make sure the destination room has an exit pointing back */
                  if (world[other_room].exits[rev_dir[ZCMD.arg2]]) {

                     /* Make sure that exit is pointing back to this room */
                     if (world[other_room].exits[rev_dir[ZCMD.arg2]]->to_room
                           == ZCMD.arg1) {

                        /* Ready to perform its door zone commands */

                        /* Must examine every zone command in that zone */
                        for (cmd_other = 0;; cmd_other++) {
                           ocmd = &(zone_table[world[other_room].zone].cmd[cmd_other]);
                           if (ocmd->command == 'S') break;

                           /* if it's a door command */
                           if (ocmd->command == 'D' &&
                                 /* and it's applied to the room opposite this exit */
                                 ocmd->arg1 == other_room &&
                                 /* and it's going in the direction toward this room */
                                 ocmd->arg2 == rev_dir[ZCMD.arg2]) {

                              /* do the command */
                              reset_door(ocmd->arg1, ocmd->arg2, ocmd->arg3);
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   zone_table[zone].age = 0;
}



/* for use in reset_zone; return TRUE if zone 'nr' is free of PC's  */
int is_empty(int zone_nr)
{
  struct descriptor_data *i;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected)
      if (world[i->character->in_room].zone == zone_nr)
        return 0;

  return 1;
}


/* now scaled for 100 point attribs */
int static_ac(int dex)
{
  if (dex <= 32)
    return 10;
  else if (dex <= 40)
    return 15;
  else if (dex <= 56)
    return 20;
  else if (dex <= 64)
    return 25;
  else if (dex <= 72)
    return 30;
  else if (dex <= 76)
    return 35;
  else if (dex <= 80)
    return 40;
  else if (dex <= 84)
    return 45;
  else
    return 50;
}

/* fixed for the 100 point scale */
int con_aff(struct char_data *ch)
{
  int bonus = 0;

  if (GET_CON(ch) < 10)
    bonus = GET_LEVEL(ch) * -1;
  else if (GET_CON(ch) < 68)
    bonus = 0;
  else if (GET_CON(ch) < 76)
    bonus = GET_LEVEL(ch) * 1;
  else if (GET_CON(ch) < 84)
    bonus = GET_LEVEL(ch) * 2;
  else if (GET_CON(ch) < 92)
    bonus = GET_LEVEL(ch) * 2;
  else if (GET_CON(ch) < 96)
    bonus = GET_LEVEL(ch) * 3;
  else
    bonus = GET_LEVEL(ch) * 4;

  return bonus;
}



/************************************************************************
 *  funcs of a (more or less) general utility nature                        *
 ************************************************************************/


/* read and allocate space for a '~'-terminated string from a given file */
char *fread_string(FILE * fl, char *error)
{
  char buf[MAX_STRING_LENGTH], tmp[512], *rslt;
  register char *point;
  int done = 0, length = 0, templength = 0;

  *buf = '\0';

  do {
    if (!fgets(tmp, 512, fl)) {
      fprintf(stderr, "SYSERR: fread_string: format error at or near %s\n",
              error);
      exit(1);
    }
    /* If there is a '~', end the string; else put an "\r\n" over the '\n'. */
    if ((point = strchr(tmp, '~')) != NULL) {
      *point = '\0';
      done = 1;
    } else {
      point = tmp + strlen(tmp) - 1;
      *(point++) = '\r';
      *(point++) = '\n';
      *point = '\0';
    }

    templength = strlen(tmp);

    if (length + templength >= MAX_STRING_LENGTH) {
      log("SYSERR: fread_string: string too large (db.c)");
      log("%s", error);
      exit(1);
    } else {
      strcat(buf + length, tmp);
      length += templength;
    }
  } while (!done);

  /* allocate space for the new string and copy it */
  if (strlen(buf) > 0) {
    CREATE(rslt, char, length + 1);
    strcpy(rslt, buf);
  } else
    rslt = NULL;

  return rslt;
}


/* release memory allocated for a char struct */
void free_char(struct char_data *ch)
{
  int i;
  struct know_spell *tmp, *tmp2;

  /* Generally speaking, extract_char() should have called char_from_room()
   * which would have cleared all battling variables.  So if ch is *still*
   * in some kind of battle mode here, something is definitely wrong. */
  if (ch->attackers || ch->target)
    mprintf(L_ERROR, LVL_GOD, "free_char: %s is in battle", GET_NAME(ch));

  while (ch->effects)
    effect_remove(ch, ch->effects);

  /* free spell recognition list if it exists */
  for (tmp = ch->see_spell; tmp; tmp = tmp2) {
    tmp2 = tmp->next;
    free(tmp);
  }
  ch->see_spell = NULL;

  if (ch->casting.misc)
    free(ch->casting.misc);

  if (ch->player_specials != NULL && ch->player_specials != &dummy_mob) {
    free_trophy(ch);
    free_aliases(GET_ALIASES(ch));

    /* Remove runtime link to clan */
    if (GET_CLAN_MEMBERSHIP(ch))
      GET_CLAN_MEMBERSHIP(ch)->player = NULL;

    if (GET_WIZ_TITLE(ch))
      free(GET_WIZ_TITLE(ch));
    if (GET_PERM_TITLES(ch)) {
      for (i = 0; GET_PERM_TITLES(ch)[i]; ++i)
        free(GET_PERM_TITLES(ch)[i]);
      free (GET_PERM_TITLES(ch));
    }
    if (GET_POOFIN(ch))
      free(GET_POOFIN(ch));
    if (GET_POOFOUT(ch))
      free(GET_POOFOUT(ch));
    if (GET_HOST(ch))
      free(GET_HOST(ch));

    if (GET_GRANT_CACHE(ch))
      free(GET_GRANT_CACHE(ch));
    if (GET_REVOKE_CACHE(ch))
      free(GET_REVOKE_CACHE(ch));

    free(ch->player_specials);
  }


  if (!IS_NPC(ch) || (IS_NPC(ch) && GET_MOB_RNUM(ch) == -1)) {
    /* if this is a player, or a non-prototyped non-player, free all */
    if (GET_NAMELIST(ch))
      free(GET_NAMELIST(ch));
    if (ch->player.title)
      free(ch->player.title);
    if (ch->player.prompt)
      free(ch->player.prompt);
    if (GET_NAME(ch))
      free(GET_NAME(ch));
    if (GET_LDESC(ch))
      free(GET_LDESC(ch));
    if (ch->player.description)
      free(ch->player.description);
  }
  else if ((i = GET_MOB_RNUM(ch)) > -1) {
    /* otherwise, free strings only if the string is not pointing at proto */
    if (ch->player.namelist && ch->player.namelist != mob_proto[i].player.namelist)
      free(ch->player.namelist);
    if (ch->player.title && ch->player.title != mob_proto[i].player.title)
      free(ch->player.title);
    if (ch->player.prompt && ch->player.prompt != mob_proto[i].player.prompt)
      free(ch->player.prompt);
    if (ch->player.short_descr && ch->player.short_descr != mob_proto[i].player.short_descr)
      free(ch->player.short_descr);
    if (GET_LDESC(ch) && GET_LDESC(ch) != mob_proto[i].player.long_descr)
      free(GET_LDESC(ch));
    if (ch->player.description && ch->player.description != mob_proto[i].player.description)
      free(ch->player.description);
  }

  if (IS_NPC(ch))
    clear_memory(ch);
  else {
    free_mem_list(ch);
    free_scribe_list(ch);
  }

  /*
   * Take out events (again).  extract_char removes events, but since
   * the load player process may attach a cooldown event, and loaded
   * players are frequently not extracted, we need to remove events
   * when freeing too.
   */
  if (ch->events)
     cancel_event_list(&(ch->events));
  for (i = 0; i < EVENT_FLAG_FIELDS; ++i)
    ch->event_flags[i] = 0;

  if (SCRIPT(ch))
    extract_script(SCRIPT(ch));

  free_quest_list(ch);

  free(ch);
}




/* release memory allocated for an obj struct */
void free_obj(struct obj_data * obj)
{
  struct spell_book_list *this_book, *next_book;

  free_obj_strings(obj);

  for (this_book = obj->spell_book; this_book; this_book = next_book) {
    next_book = this_book->next;
    free(this_book);
  }

  if (SCRIPT(obj))
    extract_script(SCRIPT(obj));

  free(obj);
}



/* read contets of a text file, alloc space, point buf to it */
int file_to_string_alloc(const char *name, char **buf)
{
  char temp[MAX_STRING_LENGTH];

  if (*buf)
    free(*buf);

  if (file_to_string(name, temp) < 0) {
    *buf = "";
    return -1;
  } else {
    *buf = strdup(temp);
    return 0;
  }
}


/* read contents of a text file, and place in buf */
int file_to_string(const char *name, char *buf)
{
  FILE *fl;
  char tmp[READ_SIZE+3];

  *buf = '\0';

  if (!(fl = fopen(name, "r"))) {
    sprintf(tmp, "Error reading %s", name);
    perror(tmp);
    return (-1);
  }
  /*  Rewritten to truncate text files read in as opposed to overflowing
   *  and crashing the mud.  Typed by Zzur, told to type by Gurlaek
   *  10/4/99
   */
  while (fgets(tmp, READ_SIZE, fl)) {
    tmp[strlen(tmp) - 1] = '\0';
    strcat(tmp, "\r\n");
    if (strlen(buf) + strlen(tmp) + 1 > MAX_STRING_LENGTH) {
      fclose(fl);
      return 0;
    }
    strcat(buf, tmp);
  }
  fclose(fl);
  return (0);
}



/* clear some of the the working variables of a char */
void reset_char(struct char_data * ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    GET_EQ(ch, i) = NULL;
  REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
  CONSENT(ch) = NULL;
  ch->scribe_list = NULL;
  ch->followers = NULL;
  ch->master = NULL;
  ch->groupees = NULL;
  ch->group_master = NULL;
  ch->followers = NULL;
  ch->master = NULL;
  ch->in_room = NOWHERE;
  ch->carrying = NULL;
  ch->next = NULL;
  ch->next_fighting = NULL;
  ch->next_in_room = NULL;
  ch->target = NULL;
  ch->attackers = NULL;
  ch->next_attacker = NULL;
  GET_POS(ch) = POS_STANDING;
  GET_STANCE(ch) = STANCE_ALERT;
  GET_DEFAULT_POS(ch) = POS_STANDING;
  ch->char_specials.carry_weight = 0;
  ch->char_specials.carry_items = 0;

  if (GET_HIT(ch) <= 0)
    GET_HIT(ch) = GET_MAX_HIT(ch) * .10;
  if (GET_MOVE(ch) <= 0)
    GET_MOVE(ch) = 1;
  if (GET_MANA(ch) <= 0)
    GET_MANA(ch) = 1;
  if (GET_BASE_HIT(ch) <= 0)
    GET_BASE_HIT(ch) = GET_MAX_HIT(ch);
  check_regen_rates(ch); /* start regening points */

  GET_LAST_TELL(ch) = NOBODY;
  init_mem_list(ch);
}



/* clear ALL the working variables of a char; do NOT free any space alloc'ed */
void clear_char(struct char_data * ch)
{
  memset((char *) ch, 0, sizeof(struct char_data));

  ch->in_room = NOWHERE;
  GET_PFILEPOS(ch) = -1;
  GET_WAS_IN(ch) = NOWHERE;
  GET_POS(ch) = POS_STANDING;
  GET_STANCE(ch) = STANCE_ALERT;
  ch->mob_specials.default_pos = POS_STANDING;
  clear_cooldowns(ch);
  GET_AC(ch) = 100;                /* Basic Armor */
  if (ch->points.max_mana < 100)
    ch->points.max_mana = 100;
}


void clear_object(struct obj_data * obj)
{
  memset((char *) obj, 0, sizeof(struct obj_data));

  obj->item_number = NOTHING;
  obj->in_room = NOWHERE;
}


/* returns the real number of the room with given virtual number */
int real_room(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_world;

  /* perform binary search on world-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((world + mid)->vnum == virtual)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if ((world + mid)->vnum > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}


int real_quest(unsigned short virtual)
{
  int bot, top, mid;

  if (!all_quests) {
    return NOWHERE;
  }

  bot = 0;
  top = max_quests;

  /* perform binary search on quest-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((all_quests + mid)->quest_id == virtual)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if ((all_quests + mid)->quest_id > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

/* returns the real number of the monster with given virtual number */
int real_mobile(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_mobt;

  /* perform binary search on mob-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((mob_index + mid)->virtual == virtual)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((mob_index + mid)->virtual > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}




/* returns the real number of the object with given virtual number */
int real_object(int virtual)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_objt;

  /* perform binary search on obj-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((obj_index + mid)->virtual == virtual)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((obj_index + mid)->virtual > virtual)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

/*
 * Read a number from a file.
 */
int fread_number(FILE *fp)
{
  int number;
  bool sign;
  char c;

  do {
    c = getc(fp);
  } while (isspace(c));

  number = 0;

  sign   = FALSE;
  if (c == '+') {
    c = getc(fp);
  } else if (c == '-') {
    sign = TRUE;
    c = getc(fp);
  }


  if (!isdigit(c)) {
    log("Fread_number: bad format.");
    exit(1);
  }

  while (isdigit(c)) {
    number = number * 10 + c - '0';
    c      = getc(fp);
  }

  if (sign)
    number = 0 - number;

  if (c == '|')
    number += fread_number(fp);
  else if (c != ' ')
    ungetc(c, fp);

  return number;
}

/*
 * Read to end of line (for comments).
 */
void fread_to_eol(FILE *fp)
{
  char c;

  do {
    c = getc(fp);
  } while (c != '\n' && c != '\r');

  do {
    c = getc(fp);
  } while (c == '\n' || c == '\r');

  ungetc(c, fp);
  return;
}


/*
 * Read one word (into static buffer).
 */
char *fread_word(FILE *fp)
{
  static char word[MAX_INPUT_LENGTH];
  char *pword;
  char cEnd;

  do
    {
      cEnd = getc(fp);
    }
  while (isspace(cEnd));

  if (cEnd == '\'' || cEnd == '"')
    {
      pword   = word;
    }
  else
    {
      word[0] = cEnd;
      pword   = word+1;
      cEnd    = ' ';
    }

  for (; pword < word + MAX_INPUT_LENGTH; pword++)
    {
      *pword = getc(fp);
      if (cEnd == ' ' ? isspace(*pword) || *pword == '~' : *pword == cEnd)
        {
          if (cEnd == ' ' || cEnd == '~')
            ungetc(*pword, fp);
          *pword = '\0';
          return word;
        }
    }

  log("SYSERR: Fread_word: word too long.");
        exit(1);
        return NULL;
}


struct index_data *get_obj_index (int vnum)
{
  int nr;
  for(nr = 0; nr <= top_of_objt; nr++) {
    if(obj_index[nr].virtual == vnum) return &obj_index[nr];
  }
  return NULL;
}

struct index_data *get_mob_index (int vnum)
{
  int nr;
  for(nr = 0; nr <= top_of_mobt; nr++) {
    if(mob_index[nr].virtual == vnum) return &mob_index[nr];
  }
  return NULL;
}

bool _parse_name(char *arg, char *name)
{
  int i;
  char test[32];
  const char *smart_ass[] =
  {
    "someone",
    "somebody",
    "me",
    "self",
    "all",
    "group",
    "local",
    "them",
    "they",
    "nobody",
    "any",
    "something",
    "other",
    "no",
    "yes",
    "north",
    "east",
    "south",
    "west",
    "up",
    "down",
    "shape",                        /* infra.. */
    "shadow",                        /* summon */
    "\n"
  };

  test[0] = 0;
  for (i = 0; (*name = *arg); arg++, i++, name++) {
    *(test + i) = LOWER(*arg);
    if ((*arg < 0) || !isalpha(*arg) || (i > 15) ||
        (i && (*(test + i) != *arg)))
      return (TRUE);
  }

  if (i < 2)
    return (TRUE);

  /* We need the case-insensitive search_block since arg can have uppercase */
  for (i = 0; *cmd_info[i].command != '\n'; ++i)
    if (!str_cmp(arg, cmd_info[i].command))
      return TRUE;
  if (search_block(arg, smart_ass, TRUE) >= 0)
    return TRUE;

  return FALSE;
}

/*
 * New functions used by ASCII files.
 */

/* Separate a 126-character id tag from the data it precedes */
void tag_argument(char *argument, char *tag) {
  char *tmp = argument, *ttag = tag, *wrt = argument;
  int i;

  for (i = 0; i < 126 && *tmp && *tmp != ' ' && *tmp != ':'; i++)
    *(ttag++) = *(tmp++);
  *ttag = '\0';
  while(*tmp == ':' || *tmp == ' ')
    tmp++;

  while(*tmp)
    *(wrt++) = *(tmp++);
  *wrt = '\0';
}

/* remove ^M's from file output */
/* There is a *similar* function in Oasis, but it has a bug. */
void kill_ems(char *str)
{
  char *ptr1, *ptr2, *tmp;

  tmp = str;
  ptr1 = str;
  ptr2 = str;

  while(*ptr1) {
    if (*ptr1 == '\r')
      ptr1++;
    else {
      *(ptr2++) = *(ptr1++);
    }
  }
  *ptr2 = '\0';
}


/***************************************************************************
 * $Log: db.c,v $
 * Revision 1.195  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.194  2010/06/05 15:09:42  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.193  2009/07/16 19:15:54  myc
 * Moved command stuff from grant.c to commands.c
 *
 * Revision 1.192  2009/06/09 05:37:23  myc
 * Simplifying code in reset_time that prints out init logs.
 *
 * Revision 1.191  2009/03/20 23:02:59  myc
 * Move text file handling routines into text.c, including
 * the reload command.
 *
 * Revision 1.190  2009/03/20 15:00:40  jps
 * Check object spell validity while reading prototypes.
 *
 * Revision 1.189  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.188  2009/03/09 05:59:57  myc
 * The mud now keeps track of all previous boot times, including
 * hotboot times.
 *
 * Revision 1.187  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.186  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.185  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.184  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.183  2009/03/08 03:54:13  jps
 * Minor code reformatting
 *
 * Revision 1.182  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.181  2009/02/21 03:30:16  myc
 * Added hooks for new board system.  Removed L_FILE flag--mprintf
 * now logs to file by default; assert L_NOFILE to prevent that.
 *
 * Revision 1.180  2008/09/29 05:04:33  jps
 * Stop calculating liquid container weights when loading protos.
 *
 * Revision 1.179  2008/09/26 18:37:49  jps
 * Don't use FIGHTING macro when changing target.
 *
 * Revision 1.178  2008/09/22 02:30:31  myc
 * Moved clan initialization after the player index is loaded.
 *
 * Revision 1.177  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.176  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.175  2008/09/21 04:54:23  myc
 * Changed order of some boot activities too ensure command sorting
 * occurs before anything that needs num_of_cmds.
 *
 * Revision 1.174  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.173  2008/09/01 18:29:38  jps
 * consolidating cooldown code in skills.c/h
 *
 * Revision 1.172  2008/08/30 20:35:49  jps
 * Removing equipment restriction check from zone EQUIP commands.  So many current
 * zone commands violate the restrictions that it isn't worth it to enforce restrictions
 * at this time.
 *
 * Revision 1.171  2008/08/30 20:22:12  jps
 * Added flag MOB_NO_EQ_RESTRICT, which allows a mobile to wear equipment
 *  without regard to align, class, or level restrictions.
 *
 * Revision 1.170  2008/08/30 18:20:53  myc
 * Removed UNIQUE item flag.  Rewrote free_obj to make use of
 * free_obj_strings.
 *
 * Revision 1.169  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.168  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.167  2008/08/29 05:26:06  myc
 * Make sure object prototypes don't have the UNIQUE or WAS_DISARMED flags.
 *
 * Revision 1.166  2008/08/25 00:20:33  myc
 * Changed the way mobs memorize spells.
 *
 * Revision 1.165  2008/08/17 08:11:56  jps
 * Logging equip errors to file.
 *
 * Revision 1.164  2008/08/17 06:51:42  jps
 * Zone command E (equip char) will handle failures better, and destroy the object
 * rather than letting it sit in nowhere.
 *
 * Revision 1.163  2008/07/22 07:25:26  myc
 * Added copy_extra_descriptions function.
 *
 * Revision 1.162  2008/07/15 17:49:24  myc
 * Boot command groups from file during boot-up sequence.
 *
 * Revision 1.161  2008/06/19 18:53:12  myc
 * Expanded item values to 7, and making obj timer values save to
 * world files.  Also don't make all spellbooks 100 pages anymore.
 *
 * Revision 1.160  2008/06/08 00:57:29  jps
 * Set a spellbook's number of pages when loading. The number is just
 * the default for now, since prototypes don't have a field for this.
 *
 * Revision 1.159  2008/06/07 19:31:44  myc
 * Fix count_applies.
 *
 * Revision 1.158  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.157  2008/06/05 02:07:43  myc
 * Rewrote corpse_saving and rent files to use ascii object files.
 * Changed object flags to use flagvectors, removed cost_per_day
 * and spell component fields.
 *
 * Revision 1.156  2008/05/26 18:24:48  jps
 * Removed code that deletes player object files.
 *
 * Revision 1.155  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.154  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.153  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.152  2008/05/14 05:13:22  jps
 * alter_hit doesn't take the attacker any more.
 *
 * Revision 1.151  2008/05/11 05:46:00  jps
 * Using regen.h. alter_hit() now takes the attacker.
 *
 * Revision 1.150  2008/04/07 17:24:22  jps
 * Add "stance" to mob e-specs.
 *
 * Revision 1.149  2008/04/07 04:31:23  jps
 * Ensure mob prototypes load with sensible position and default position.
 *
 * Revision 1.148  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.147  2008/04/05 16:39:18  jps
 * Rename the function that handles the "reload" command from do_reboot
 * to do_reload.
 *
 * Revision 1.146  2008/04/04 06:12:52  myc
 * Removed dieites/worship and ships code.
 *
 * Revision 1.145  2008/04/02 04:55:59  myc
 * Got rid of the coins struct.
 *
 * Revision 1.144  2008/04/02 03:24:44  myc
 * Rewrote group code and removed all major group code.
 *
 * Revision 1.143  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.142  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.141  2008/03/23 00:24:29  jps
 * Make sure to reset base composition.
 *
 * Revision 1.140  2008/03/22 21:43:34  jps
 * Read life force and composition from mob proto files.
 *
 * Revision 1.139  2008/03/22 17:12:19  jps
 * Set the ITEM_NORENT flag on keys when created.
 *
 * Revision 1.138  2008/03/21 14:54:19  myc
 * Added a note to free_char about freeing the event list.
 *
 * Revision 1.137  2008/03/17 16:22:42  myc
 * Updating calls to free_proto_script, and nullifying SCRIPTs after
 * extraction.
 *
 * Revision 1.136  2008/03/16 00:20:02  jps
 * Updated call to free_trophy().
 *
 * Revision 1.135  2008/03/11 02:54:53  jps
 * Use set_base_size when creating mob prototypes.
 *
 * Revision 1.134  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.133  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.132  2008/03/08 23:20:06  myc
 * Free events in free_char instead of in extract_char.
 *
 * Revision 1.131  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.130  2008/03/05 05:21:56  myc
 * Removed save_char_file_u declaration.  Removed player frags.
 *
 * Revision 1.129  2008/03/05 05:08:28  jps
 * Changed ascii player tags and allow them to be of variable length up to
 * 126 characters.
 *
 * Revision 1.128  2008/03/05 03:03:54  myc
 * Moved many player functions from here to players.c.
 *
 * Revision 1.127  2008/02/23 01:03:54  myc
 * Renamed assign_mem_list to init_mem_list.  Freeing memory and scribe
 * lists when freeing a character.
 *
 * Revision 1.126  2008/02/16 20:26:04  myc
 * Adding functions to free spell dams, extra descriptions, mobiles,
 * objects, rooms, zones, triggers, text files, players, and the
 * help table at program termination.
 *
 * Revision 1.125  2008/02/10 20:19:19  jps
 * Further quest numbering tweaks/fixes.
 *
 * Revision 1.124  2008/02/10 19:43:38  jps
 * Subclass quests now store the target subclass as a quest variable rather
 * than as 3 bits in the quest id.
 *
 * Revision 1.123  2008/02/09 21:07:50  myc
 * Removing plr/mob casting flags and using an event flag instead.
 *
 * Revision 1.122  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.121  2008/02/09 03:04:23  myc
 * Commenting out some spell dam log messages that weren't needed at all.
 *
 * Revision 1.120  2008/01/30 19:20:57  myc
 * Removing the ch->regenerating field and replacing it with an event
 * flags member.
 *
 * Revision 1.119  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.118  2008/01/27 21:09:12  myc
 * Save rage for players in store_to_char and char_to_store.
 *
 * Revision 1.117  2008/01/27 13:41:28  jps
 * Moved species-related data to races.h and races.c.
 *
 * Revision 1.116  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.115  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.114  2008/01/22 09:04:17  jps
 * Clear player flags associated with memorization and regeneration.
 *
 * Revision 1.113  2008/01/22 05:02:05  myc
 * Fix asciiflag_conv to work with negative numbers.
 *
 * Revision 1.112  2008/01/15 03:18:19  myc
 * Making SENSE_LIFE do the same thing it used to instead of add
 * a static amount to perception.  That way SENSE_LIFE only applies
 * to chars and not objs.
 *
 * Revision 1.111  2008/01/12 23:13:20  myc
 * Put the spells_of_circle declaration in a header file.
 *
 * Revision 1.110  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.109  2008/01/09 09:18:00  jps
 * Moved natural move calculations to races.c.
 *
 * Revision 1.108  2008/01/09 08:31:14  jps
 * Moved height and weight setting to races.c.
 *
 * Revision 1.107  2008/01/09 04:12:42  jps
 * Remove obsolete member next_scribing.
 *
 * Revision 1.106  2008/01/09 02:29:58  jps
 * Real mob nr moved to mob_specials.
 *
 * Revision 1.105  2008/01/06 18:16:10  jps
 * Moved player height, weight, and size to races.c.
 *
 * Revision 1.104  2008/01/06 05:35:55  jps
 * Remove function prototype which is provided by an include.
 *
 * Revision 1.103  2008/01/05 20:32:43  jps
 * Move some newbie-pref setting code in here.
 *
 * Revision 1.102  2008/01/05 05:43:10  jps
 * Calling init_char() and update_char() when appropriate. Racial
 * innates stuff moved to races.c. start_player() moved here.
 *
 * Revision 1.101  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.100  2007/12/25 19:46:25  jps
 * Remember whether a player was flying as we save them. Due to the removal of
 * all effect-causing agents, affect_modify() will stop a player from flying.
 * But since we're only saving a player, we don't want to change the player's
 * position.
 *
 * Revision 1.99  2007/12/25 16:39:53  jps
 * Fix armor calculations.
 *
 * Revision 1.98  2007/12/21 07:34:36  myc
 * Fixing positive armor applies to cause negative drops in armor.
 *
 * Revision 1.97  2007/12/19 20:46:56  myc
 * save_player() no longer requires the save room (which wasn't being used
 * anyway).  Updated clan checking code in store_to_char.  Added
 * tag_argument() function for use with ASCII files.  Currently used by
 * clan code, but could possibly be used for pfiles in the future.  Also
 * added kill_ems().  These two functions ported from v3.
 *
 * Revision 1.96  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.95  2007/10/11 20:14:48  myc
 * Changed skill defines to support chants and songs as skills, but
 * slightly distinguished from spells and skills.  TOP_SKILL is the
 * old MAX_SKILLS.
 *
 * Revision 1.94  2007/10/02 02:52:27  myc
 * Changed sense life to be dynamically added in to perception in
 * update_stats().
 *
 * Revision 1.93  2007/09/28 20:49:35  myc
 * Removed vnum_mobile, vnum_object, vnum_room, vnum_trigger, vnum_mob_zone,
 * and vnum_object_zone functions whose functionality is now implemented
 * by the vsearch suite.
 *
 * Revision 1.92  2007/09/20 21:45:02  myc
 * Saving perception and hiddenness to player file :>
 *
 * Revision 1.91  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  They are saved for mobs and object
 * files.  Perception is calculated in update_stats (which is called
 * whenever affect_total runs).  Rewrote scale_attribs to use an array
 * instead of a mass of constant defines in utils.h.
 *
 * Revision 1.90  2007/09/15 05:03:46  myc
 * Added MOB2 flags.  They're saved on mobs as an espec.  Implemented
 * MOB2_NOPOISON.
 *
 * Revision 1.89  2007/09/12 22:23:04  myc
 * Mobs get autoexit autoset on now.
 *
 * Revision 1.88  2007/09/04 06:49:19  myc
 * Updated hemisphere initialization function.
 *
 * Revision 1.87  2007/08/24 22:49:05  jps
 * Added function vnum_trigger() for use with the "tnum" command.
 *
 * Revision 1.86  2007/08/24 17:01:36  myc
 * Adding ostat and mstat commands as shorthand for vstat, rstat for stat
 * room, and mnum and onum for vnum.  Also adding rnum and znum with new
 * functionality.
 *
 * Revision 1.85  2007/08/22 17:59:49  jps
 * Add restrict_reason variable.
 *
 * Revision 1.84  2007/08/17 02:23:36  jps
 * Add global variable restrict_manual, so that autobooting code won't
 * remove a login restriction that was set by hand.
 *
 * Revision 1.83  2007/08/02 00:23:34  myc
 * Remove a defunct function call.
 *
 * Revision 1.82  2007/07/25 02:58:01  myc
 * I think I fixed the locate object bug... NEVER EVER EVER stick any
 * objects on a char before they enter the game!
 *
 * Revision 1.81  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.80  2007/07/19 21:59:52  jps
 * Dynamic strings for drink containers.
 *
 * Revision 1.79  2007/07/18 18:47:38  jps
 * Stop object extra desc lists from being reversed while loading.
 *
 * Revision 1.78  2007/07/18 16:23:58  jps
 * Force FOOD objects to have keyword "food".
 *
 * Revision 1.77  2007/07/18 01:21:34  jps
 * Restore AFF2/AFF3 flags to object prototypes.
 *
 * Revision 1.76  2007/07/18 00:04:41  jps
 * Save AFF2 and AFF3 flags for mobiles.
 *
 * Revision 1.75  2007/07/14 02:16:22  jps
 * Mountable mobs have their mv points calculated when being created.
 *
 * Revision 1.74  2007/04/18 17:26:26  jps
 * Reset both sides of doors that span zones.
 *
 * Revision 1.73  2007/04/17 23:59:16  myc
 * New trigger type: Load.  It goes off any time a mobile is loaded, whether
 * it be god command, zone command, or trigger command.
 *
 * Revision 1.72  2007/03/31 23:31:30  jps
 * Fix ac calculation for mobs level 30-94
 *
 * Revision 1.71  2007/03/27 04:27:05  myc
 * Fixed bug in store_to_char preventing hp from healing after 1hr time.
 * Replaced innate timer macro spellings.
 *
 * Revision 1.70  2007/02/04 18:12:31  myc
 * Page length now saves as a part of player specials.
 *
 * Revision 1.69  2006/11/21 03:45:52  jps
 * Store a light's initial burning time in obj val 1, when creating it.
 *
 * Revision 1.68  2006/11/18 19:57:16  jps
 * Don't use the one-hour since last login bonus to REDUCE
 * hit/mv/mana below their affected max.
 *
 * Revision 1.67  2006/05/05 20:46:23  rls
 * Some issues with mobiles having no class, no race creating
 * large sums of platinum.  Moreso than they should have anyway
 *
 * Revision 1.66  2006/05/05 15:53:51  rls
 * Set default for factors @@ 100 instead of 0
 * so that mobs without classes, etc wouldn't
 * zero out coinage amounts.
 *
 * Revision 1.65  2006/05/05 15:06:14  rls
 * Modified get_copper to give mo' money with a little bit
 * of sanity in regards to clan prices, scroll prices, etc.
 *
 * Revision 1.64  2005/07/27 03:06:25  jwk
 * Changed mob load so that when it is read from the mob file it reads the size in instead of basing it on the race.
 *
 * Revision 1.63  2004/11/01 03:29:38  rsd
 * Added a dev ifdef for compiling to supress syserrs by
 * setting the mini_mud INT to on if in dev mode.
 *
 * Revision 1.62  2004/11/01 02:56:56  rsd
 * Removed a typo in the boot sequence
 *
 * Revision 1.61  2003/07/06 20:40:37  jjl
 * Improved the message a touch.
 *
 * Revision 1.59  2002/11/29 21:54:45  jjl
 * Well, here goes something.  Things have been difficult, so this is a
 * minor tweak to change mob HP.  Basically,  Newbie mobs get hammered in
 * half,  midrange lose about 33%, and High level mobs have no change.  In the
 * end, if nothing else, it's meant to help newbies out, without wussifying
 * the whole deal.
 *
 * Revision 1.58  2002/11/09 19:09:45  jjl
 * Compressed a large block of if's into a switch.
 *
 * Revision 1.57  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.56  2002/06/07 22:15:56  dce
 * Adjusted hitrolls for mobs. Was based on 50 levels. I
 * smoothed it out and lowered it overall.
 *
 * Revision 1.55  2002/05/09 23:08:18  dce
 * Removes any saved size on a character.
 *
 * Revision 1.54  2001/12/21 02:44:35  dce
 * Undid what I previous just did. It was causing grouping
 * flags to disappear and who know what else...
 *
 * Revision 1.53  2001/12/18 01:37:34  dce
 * When a character saves all affects are removed from the
 * character and reapplied. This applies to innate affects.
 *
 * Revision 1.52  2001/12/16 20:07:53  dce
 * Fixed a problem where players could get the max dam and hitroll
 * possible by changing their alignment and getting "zapped" by
 * alignment sensitive equipment. The "zapped" they would not lose
 * the +hitroll or damroll effects because of silly Hubis code.
 *
 * Revision 1.51  2001/12/07 02:09:56  dce
 * Linkdead players will now lose exp when they die.
 * Linkdead shapechanged players will now shapechange
 * to their original form before linking out.
 *
 * Revision 1.50  2001/03/24 05:12:01  dce
 * Objects will now accept a level through olc and upon
 * booting the objects. The level code for the players will
 * follow.
 *
 * Revision 1.49  2001/01/12 03:45:50  dce
 * *** empty log message ***
 *
 * Revision 1.48  2001/01/05 01:30:24  mtp
 * moved assignement of mobs REAL NUM to before trigger check to allow
 * better error message (with REAL VNUM)
 *
 * Revision 1.47  2000/11/28 01:37:03  mtp
 * better error messgae if mobprog seen
 *
 * Revision 1.46  2000/11/28 01:10:58  mtp
 * removed more mobprog stuff
 *
 * Revision 1.44  2000/11/21 01:03:00  rsd
 * Added back rlog messages from prior to the addition
 * of the $log$ string.
 *
 * Revision 1.43  2000/11/15 00:24:09  mtp
 * removed a couple of fprintf(stderr) lines which showed quests loading
 *
 * Revision 1.42  2000/11/07 01:48:17  mtp
 * added check for qsubclass stuff in real_quest search routine and
 * also changed function according to new prototype
 *
 * Revision 1.41  2000/11/03 21:25:59  jimmy
 * Added debug to print out bogus exits
 *
 * Revision 1.40  2000/11/03 20:31:48  jimmy
 * removed last version
 *
 * Revision 1.38  2000/11/03 05:37:17  jimmy
 * Removed the quest.h file from structs.h arg!! and placed it
 * only in the appropriate files
 * Updated the dependancies in the Makefile and created
 * make supahclean.
 *
 * Revision 1.37  2000/10/31 23:31:44  mtp
 * changed harreferences to misc/quest to ALL_QUEST_FILE
 *
 * Revision 1.36  2000/10/31 00:43:37  mud
 * fixed a memlry leak in real_quest
 * /s
 *
 * Revision 1.35  2000/10/27 00:34:45  mtp
 * extra info for booting quests and a real_quest fn to find array
 * value given vnum of quest
 *
 * Revision 1.34  2000/10/11 23:54:20  rsd
 * move the piece of delete player that removes the player
 * from the index to another independant function that
 * delete_player calls.  the new function is
 * delete_player_from_index
 *
 * Revision 1.33  2000/06/05 19:03:59  rsd
 * Set players mv to be 100 or 2xCON whichever is maximum
 * when they are created.
 *
 * Revision 1.32  2000/06/01 20:09:16  rsd
 * Deleted a bunch of debug log messages from the init_weather()
 * section. Also made other log messgaes look better.
 *
 * Revision 1.31  2000/05/29 20:40:51  rsd
 * Altered ch->points.max_move to = GET_CON(ch) * 2
 * as opposed to 82 hard coded movement points.
 *
 * Revision 1.30  2000/04/26 22:51:45  rsd
 * made a delete_player function
 *
 * Revision 1.29  2000/04/22 22:35:49  rsd
 * Altered comment header while browsing the file.
 *
 * Revision 1.28  2000/03/20 04:32:39  rsd
 * added comments regarding void reboot_wizlists(void) as it
 * pertains to the removal of autowiz
 *
 * Revision 1.27  2000/03/08 22:05:09  mtp
 * fixed hidden exit with no door? for some reason setting EX_DESCRIPT seems to override
 * the other stuff about an exit...
 *
 * Revision 1.26  1999/11/29 00:21:47  cso
 * removed unused variables to kill compile warnings
 *
 * Revision 1.25  1999/11/28 23:09:31  cso
 * took unused argument from all calls to roll_natural_abils
 * new fn: setup_mob. does some of the work read_mobile used to
 * free_char: added call to free(ch->casting.misc) to plug mem leak
 *
 * Revision 1.24  1999/10/04 20:00:50  rsd
 * Fixed some function associated with reading in text files.
 * in do_reboot.  The read new truncates the files instead of
 * overflowing. good enough.
 *
 * Revision 1.23  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.22  1999/09/04 18:46:52  jimmy
 * More small but important bug fixes found with insure.  These are all runtime fixes.
 *
 * Revision 1.21  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most significant
 * changes were moving all the BREATH's to within normal spell range, and
 * fixing the way socials were allocated.  Too many small fixes to list them
 * all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.20  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.19  1999/07/21 03:10:19  jimmy
 * added an oversight to free_char.  Forgot to release mem for spell lists
 * just in case it was still there when a player was free'd
 * --gurlaek
 *
 * Revision 1.18  1999/07/09 22:30:27  jimmy
 * Attempt to control the spiraling of memory.  Added a free() to the
 * prompt code in comm.c to free memory allocated by parse_color().
 * made a global structure dummy_mob and malloc'ed it for mobs
 * to share as their player_specials to cut memory.
 * gurlaek
 *
 * Revision 1.17  1999/07/06 19:57:05  jimmy
 * This is a Mass check-in of the new skill/spell/language assignment system.
 * This New system combines the assignment of skill/spell/language for
 * both mobs and PCs.  LOts of code was touched and many errors were fixed.
 * MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
 * MObs now get random skill/spell/language levels baseed on their race/class/level
 * that exactly align with PC's.  PC's no longer have to rent to use skills gained
 * by leveling or when first creating a char.  Languages no longer reset to defaults
 * when a PC levels.  Discovered that languages have been defined right in the middle
 * of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
 * the mob files to compensate for the 13 to -1 class change.
 * --gurlaek 7/6/1999
 *
 * Revision 1.16  1999/06/30 18:25:04  jimmy
 * >> This is a major conversion from the 18 point attribute system to the
 * >> 100 point attribute system.  A few of the major changes are:
 * >> All attributes are now on a scale from 0-100
 * >> Everyone views attribs the same but, the attribs for one race
 * >>   may be differeent for that of another even if they are the
 * >>   same number.
 * >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * >> Mobs now have individual random attributes based on race/class.
 * >> The STR_ADD attrib has been completely removed.
 * >> All bonus tables for attribs in constants.c have been replaced by
 * >>   algorithims that closely duplicate the tables except on a 100 scale.
 * >> Some minor changes:
 * >> Race selection at char creation can now be toggled by using
 * >>   <world races off>
 * >> Lots of cleanup done to affected areas of code.
 * >> Setting attributes for mobs in the .mob file no longer functions
 * >>   but is still in the code for later use.
 * >> We now have a spare attribut structure in the pfile because the new
 * >>   system only used three instead of four.
 * >> --gurlaek 6/30/1999
 *
 * Revision 1.15  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
 * --Gurlaek 6/10/1999
 *
 * Revision 1.14  1999/05/04 17:19:33  dce
 * Name accept system...version one...original code by Fingh, fixed up to work
 * by Zantir.
 *
 * Revision 1.13  1999/04/09 17:25:33  jen
 * Mobs now get abil rolls (unless they're special circle 3 ones).
 * The rolls depend on class & species.
 *
 * Revision 1.12  1999/04/07 01:20:18  dce
 * Allows extra descriptions on no exits.
 *
 * Revision 1.11  1999/03/06 23:51:54  dce
 * Add's chant songs, and can only chant once every four hours
 *
 * Revision 1.10  1999/03/03 20:11:02  jimmy
 * Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
 * Spellbooks now have to be held to scribe as well as a quill in the other hand.
 *
 * -fingon
 *
 * Revision 1.9  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.8  1999/02/26 18:42:19  jimmy
 * Added obj = NULL in free_obj to help stop pointers to
 * raw memory for objects crashing the mud.
 *
 * fingon
 *
 * Revision 1.7  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.6  1999/02/06 00:40:36  jimmy
 * Major change to incorporate aliases into the pfile
 * moved alias structure from interpreter.h to structs.h
 * heavily modified alias code in interpreter.c
 * Jimmy Kincaid AKA fingon
 *
 * Revision 1.5  1999/02/05 07:47:42  jimmy
 * Added Poofs to the playerfile as well as 4 extra strings for
 * future use.  fingon
 *
 * Revision 1.4  1999/02/02 07:35:17  jimmy
 * spellcasters now lose all memmed spells at death without
 * haveing to quit and log back in.
 *
 * Revision 1.3  1999/02/01 08:18:12  jimmy
 * improved build counter
 *
 * Revision 1.2  1999/01/30 22:12:02  mud
 * Indented entire file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.195
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.194 2010/06/05 15:09:42 mud Exp $
d665 1
a665 1
    log(buf2);
d1282 1
a1282 1
    log(log_buf);
d2785 1
a2785 1
      log(error);
d3385 3
@


1.194
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.193 2009/07/16 19:15:54 myc Exp mud $
d497 1
a497 1
      log(buf);
d500 1
a500 1
      log(buf);
d503 1
a503 1
      log(buf);
d941 1
a941 1
  log(buf);
d1351 1
a1351 1
            log(buf);
d3385 3
@


1.193
log
@Moved command stuff from grant.c to commands.c
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.192 2009/06/09 05:37:23 myc Exp myc $
d55 1
d3385 3
@


1.192
log
@Simplifying code in reset_time that prints out init logs.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.191 2009/03/20 23:02:59 myc Exp myc $
d47 1
a47 1
#include "grant.h"
d2831 5
d3384 3
@


1.191
log
@Move text file handling routines into text.c, including
the reload command.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.190 2009/03/20 15:00:40 jps Exp myc $
d54 1
a54 1
#include "text.h"
d912 1
a912 1
  log("Setting up seasons:");
d920 1
a920 1
    log("                    - Winter");
d926 1
a926 1
    log("                    - Spring");
d932 1
a932 1
    log("                    - Summer");
d938 1
a938 1
    log("                    - Autumn");
d940 1
d942 2
a943 3
  sprintf(buf, "Current Gametime: %dH %dD %dM %dY.", time_info.hours,
          time_info.day, time_info.month, time_info.year);
  log(buf);
d3379 4
@


1.190
log
@Check object spell validity while reading prototypes.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.189 2009/03/09 20:36:00 myc Exp jps $
d54 1
a110 13
char *credits = NULL;                /* game credits                         */
char *news = NULL;                /* mud news                         */
char *anews = NULL;             /* Area and Code news for gods   */
char *motd = NULL;                /* message of the day - mortals  */
char *imotd = NULL;                /* message of the day - immorts  */
char *help = NULL;                /* help screen                         */
char *info = NULL;                /* info page                         */
char *wizlist = NULL;                /* list of higher gods                 */
char *immlist = NULL;                /* list of peon gods                 */
char *background = NULL;        /* background story                 */
char *handbook = NULL;                /* handbook for new immortals         */
char *policies = NULL;                /* policies page                 */

d140 2
a141 2
int file_to_string(char *name, char *buf);
int file_to_string_alloc(char *name, char **buf);
a196 76
/* this is necessary for the autowiz system */
/* autowiz is being remove but this may be used
 * to reload the wizlist when it is altered so
 * I'm leaving it. RSD 3/19/00
 */
void reboot_wizlists(void)
{
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
}


ACMD(do_reload)
{
  int i;

  one_argument(argument, arg);

  if (!str_cmp(arg, "all") || *arg == '*') {
    file_to_string_alloc(WIZLIST_FILE, &wizlist);
    file_to_string_alloc(IMMLIST_FILE, &immlist);
    file_to_string_alloc(NEWS_FILE, &news);
    file_to_string_alloc(ANEWS_FILE, &anews);
    file_to_string_alloc(CREDITS_FILE, &credits);
    file_to_string_alloc(MOTD_FILE, &motd);
    file_to_string_alloc(IMOTD_FILE, &imotd);
    file_to_string_alloc(HELP_PAGE_FILE, &help);
    file_to_string_alloc(INFO_FILE, &info);
    file_to_string_alloc(POLICIES_FILE, &policies);
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
    file_to_string_alloc(BACKGROUND_FILE, &background);
  } else if (!str_cmp(arg, "wizlist"))
    file_to_string_alloc(WIZLIST_FILE, &wizlist);
  else if (!str_cmp(arg, "immlist"))
    file_to_string_alloc(IMMLIST_FILE, &immlist);
  else if (!str_cmp(arg, "news"))
    file_to_string_alloc(NEWS_FILE, &news);
  else if (!str_cmp(arg, "anews"))
    file_to_string_alloc(ANEWS_FILE, &anews);
  else if (!str_cmp(arg, "credits"))
    file_to_string_alloc(CREDITS_FILE, &credits);
  else if (!str_cmp(arg, "motd"))
    file_to_string_alloc(MOTD_FILE, &motd);
  else if (!str_cmp(arg, "imotd"))
    file_to_string_alloc(IMOTD_FILE, &imotd);
  else if (!str_cmp(arg, "help"))
    file_to_string_alloc(HELP_PAGE_FILE, &help);
  else if (!str_cmp(arg, "info"))
    file_to_string_alloc(INFO_FILE, &info);
  else if (!str_cmp(arg, "policy"))
    file_to_string_alloc(POLICIES_FILE, &policies);
  else if (!str_cmp(arg, "handbook"))
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
  else if (!str_cmp(arg, "background"))
    file_to_string_alloc(BACKGROUND_FILE, &background);
  else if (!str_cmp(arg, "xhelp")) {
    if (help_table) {
      for (i = 0; i <= top_of_helpt; i++) {
        if (help_table[i].keyword)
          free(help_table[i].keyword);
        if (help_table[i].entry && !help_table[i].duplicate)
          free(help_table[i].entry);
      }
      free(help_table);
    }
    top_of_helpt = 0;
    index_boot(DB_BOOT_HLP);
  } else {
    send_to_char("Unknown reload option.\r\n", ch);
    return;
  }

  send_to_char(OK, ch);
}


d601 1
a601 12
  file_to_string_alloc(NEWS_FILE, &news);
  file_to_string_alloc(ANEWS_FILE, &anews);
  file_to_string_alloc(CREDITS_FILE, &credits);
  file_to_string_alloc(MOTD_FILE, &motd);
  file_to_string_alloc(IMOTD_FILE, &imotd);
  file_to_string_alloc(HELP_PAGE_FILE, &help);
  file_to_string_alloc(INFO_FILE, &info);
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
  file_to_string_alloc(POLICIES_FILE, &policies);
  file_to_string_alloc(HANDBOOK_FILE, &handbook);
  file_to_string_alloc(BACKGROUND_FILE, &background);
a874 17
void free_text_files() {
  char **textfiles[] = {
        &wizlist, &immlist, &news, &credits, &motd, &imotd, &help,
        &info, &policies, &handbook, &anews, &background, NULL
  };
  int rf;

  for (rf = 0; textfiles[rf]; rf++)
    if (*textfiles[rf]) {
      free(*textfiles[rf]);
      *textfiles[rf] = NULL;
    }

}



d2935 1
a2935 1
int file_to_string_alloc(char *name, char **buf)
d2953 1
a2953 1
int file_to_string(char *name, char *buf)
d3379 3
@


1.189
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.188 2009/03/09 05:59:57 myc Exp myc $
d1905 15
d1922 1
a1922 1
void set_objproto_defs(struct obj_data *obj)
d1959 16
a1980 1

d2123 1
a2123 1
      set_objproto_defs(&obj_proto[i]);
d3495 3
@


1.188
log
@The mud now keeps track of all previous boot times, including
hotboot times.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.187 2009/03/09 05:41:31 jps Exp myc $
d1569 1
a1569 1
      GET_EX_PLAT(mob_proto + i) = t[1];
d1573 1
a1573 1
      GET_EX_PLAT(mob_proto + i) = 0;
d1608 1
a1608 1
  mob_proto[i].points.coins[PLAT] = 0;
d1614 1
a1614 1
  k = 0;j=0;
d1616 6
a1621 6
  j = ((60*k)/100);
  mob_proto[i].points.coins[PLAT] = ((int) (j/1000));
  j = ((int)((20*k)/100)) + (j % 1000);
  mob_proto[i].points.coins[GOLD] = ((int) (j/100));
  j = ((int)((18*k)/100)) + (j % 100);
  mob_proto[i].points.coins[SILVER] = ((int) (j/10));
d1623 3
a1625 3
    j = ((int)((.5*k)/100)) + (j % 10);
  j = ((int)((2*k)/100)) + (j % 10);
  mob_proto[i].points.coins[COPPER] = j;
d1627 1
a1627 1
  mob_proto[i].points.coins[PLAT] = MAX(0, mob_proto[i].points.coins[PLAT] + GET_EX_PLAT(mob_proto + i));
d3465 4
@


1.187
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.186 2009/03/09 04:33:20 jps Exp jps $
d102 2
a103 1
time_t boot_time = 0;                /* time of mud boot                 */
d779 2
a780 1
  boot_time = time(0);
d3465 3
@


1.186
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.185 2009/03/08 23:34:14 jps Exp jps $
d53 1
d3463 4
@


1.185
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.184 2009/03/08 21:43:27 jps Exp jps $
d52 1
d3462 3
@


1.184
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.183 2009/03/08 03:54:13 jps Exp jps $
d28 1
a28 1
#include "spells.h"
d3461 3
@


1.183
log
@Minor code reformatting
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.182 2009/03/03 19:43:44 myc Exp jps $
d50 2
d3461 3
@


1.182
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.181 2009/02/21 03:30:16 myc Exp myc $
d2336 7
a2342 1
    mob->points.max_hit = MAX(0, MIN(32000, dice(mob->points.hit, mob->points.mana) + GET_EX_MAIN_HP(mob) + mob->points.move));
d3459 3
@


1.181
log
@Added hooks for new board system.  Removed L_FILE flag--mprintf
now logs to file by default; assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.180 2008/09/29 05:04:33 jps Exp myc $
d2630 1
a2630 1
              if (!(obj_to = get_obj_num(ZCMD.arg3)))
d2695 1
a2695 1
      if ((obj = get_obj_in_list_num(ZCMD.arg2, world[ZCMD.arg1].contents)) != NULL) {
d3453 4
@


1.180
log
@Stop calculating liquid container weights when loading protos.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.179 2008/09/26 18:37:49 jps Exp jps $
d49 1
d669 3
d2682 1
a2682 1
               mprintf(L_ERR | L_FILE, 101, "EQUIP zone command for %s [%d] in room %d to equip %s [%d] failed.",
d2887 1
a2887 1
    mprintf(L_ERR, LVL_GOD, "free_char: %s is in battle", GET_NAME(ch));
d3453 3
@


1.179
log
@Don't use FIGHTING macro when changing target.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.178 2008/09/22 02:30:31 myc Exp jps $
a2023 7
  /* check to make sure that weight of containers exceeds curr. quantity */
  if (obj_proto[i].obj_flags.type_flag == ITEM_DRINKCON ||
      obj_proto[i].obj_flags.type_flag == ITEM_FOUNTAIN) {
    if (obj_proto[i].obj_flags.weight < obj_proto[i].obj_flags.value[1])
      obj_proto[i].obj_flags.weight = obj_proto[i].obj_flags.value[1] + 5;
  }

d3449 3
@


1.178
log
@Moved clan initialization after the player index is loaded.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.177 2008/09/22 02:09:17 jps Exp myc $
d3082 3
a3084 1
  FIGHTING(ch) = NULL;
d3456 3
@


1.177
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.176 2008/09/21 20:40:40 jps Exp jps $
a659 1

d664 4
d702 4
d710 1
a713 3
  log("Booting Clans.");
  init_clans();

d3454 4
@


1.176
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.175 2008/09/21 04:54:23 myc Exp jps $
d2003 3
a2005 1
      (retval = sscanf(line, "%d %d %d %d %d %d %d %d", t, t + 1, t + 2, t + 3, t+ 4, t + 5, t + 6, t + 7)) != 8)
a2010 1
  obj_proto[i].obj_flags.weight = t[0];
d3449 4
@


1.175
log
@Changed order of some boot activities too ensure command sorting
occurs before anything that needs num_of_cmds.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.174 2008/09/01 23:47:49 jps Exp myc $
d2875 1
a2875 1
void free_char(struct char_data * ch)
d2880 6
a2885 1
  /* moved this here so affects get removed BEFORE player_specials are free'd --gurlaek 9/4/1999 */
d2895 1
a2895 1
  /* free the arg to the last 'cast' command to stop a memory leak -321 */
d3448 4
@


1.174
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.173 2008/09/01 18:29:38 jps Exp jps $
d693 16
a734 15
  log("   Skills.");
  init_skills();

  log("Assigning skills and spells to classes.");
  assign_class_skills();

  log("Sorting command list and skills.");
  sort_commands();
  sort_skills();

  log("Booting command groups.");
  boot_command_groups();

  log("Booting Clans.");
  init_clans();
d2909 6
a2914 1
      free (GET_HOST(ch));
d3443 3
@


1.173
log
@consolidating cooldown code in skills.c/h
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.172 2008/08/30 20:35:49 jps Exp jps $
d48 1
d3437 3
@


1.172
log
@Removing equipment restriction check from zone EQUIP commands.  So many current
zone commands violate the restrictions that it isn't worth it to enforce restrictions
at this time.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.171 2008/08/30 20:22:12 jps Exp jps $
a3089 1
  int i;
d3098 1
a3098 4

  for (i = 0; i < MAX_COOLDOWNS; ++i)
    GET_COOLDOWN(ch, i) = 0;

d3436 5
@


1.171
log
@Added flag MOB_NO_EQ_RESTRICT, which allows a mobile to wear equipment
 without regard to align, class, or level restrictions.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.170 2008/08/30 18:20:53 myc Exp jps $
d2676 1
a2676 1
            if (!(may_wear_eq(mob, obj, ZCMD.arg3, FALSE) && equip_char(mob, obj, ZCMD.arg3) == EQUIP_RESULT_SUCCESS)) {
d3440 4
@


1.170
log
@Removed UNIQUE item flag.  Rewrote free_obj to make use of
free_obj_strings.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.169 2008/08/30 01:31:51 myc Exp myc $
d2667 15
a2681 10
      if (!mob)
        {
          ZONE_ERROR("trying to equip non-existent mob");
          break;
        }/*was make sure number less then ZCMD.arg2*/
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2)
        {
          if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS)
            {
              ZONE_ERROR("invalid equipment pos number");
d2683 4
a2686 21
          else
            {
              obj = read_object(ZCMD.arg1, REAL);
                  switch (equip_char(mob, obj, ZCMD.arg3)) {
                     case EQUIP_RESULT_ERROR:
                     case EQUIP_RESULT_REFUSE:
                        mprintf(L_ERR | L_FILE, 101, "EQUIP zone command for %s [%d] in room %d to equip %s [%d] failed.",
                              GET_NAME(mob), GET_MOB_VNUM(mob),
                              ROOM_RNUM_TO_VNUM(mob->in_room),
                              obj->short_description, GET_OBJ_VNUM(obj));
                        extract_obj(obj);
                        break;
                     default:
                        ;

                  }
                  last_cmd = 1;
            }
        }
      else
        last_cmd = 0;
d3440 4
@


1.169
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.168 2008/08/29 19:18:05 myc Exp myc $
a1929 1
   REMOVE_FLAG(GET_OBJ_FLAGS(obj), ITEM_UNIQUE);
a2987 2
  int nr;
  struct extra_descr_data *this, *next_one;
d2989 2
a2990 37
  if ((nr = GET_OBJ_RNUM(obj)) == -1) {
    if (obj->name)
      free(obj->name);
    if (obj->description)
      free(obj->description);
    if (obj->short_description)
      free(obj->short_description);
    if (obj->action_description)
      free(obj->action_description);
    if (obj->ex_description)
      for (this = obj->ex_description; this; this = next_one) {
        next_one = this->next;
        if (this->keyword)
          free(this->keyword);
        if (this->description)
          free(this->description);
        free(this);
      }
  } else {
    if (obj->name && obj->name != obj_proto[nr].name)
      free(obj->name);
    if (obj->description && obj->description != obj_proto[nr].description)
      free(obj->description);
    if (obj->short_description && obj->short_description != obj_proto[nr].short_description)
      free(obj->short_description);
    if (obj->action_description && obj->action_description != obj_proto[nr].action_description)
      free(obj->action_description);
    if (obj->ex_description && obj->ex_description != obj_proto[nr].ex_description)
      for (this = obj->ex_description; this; this = next_one) {
        next_one = this->next;
        if (this->keyword)
          free(this->keyword);
        if (this->description)
          free(this->description);
        free(this);
      }
  }
d3452 6
@


1.168
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.167 2008/08/29 05:26:06 myc Exp myc $
a55 2
void update_stats(struct char_data *ch);
int count_applies(struct char_data *ch, int TYPE);
a2829 47
void update_stats(struct char_data *ch)
{
  int start_hp;

  /* AC change */
  GET_AC(ch) = 100 - static_ac(GET_DEX(ch)) + count_applies(ch, APPLY_AC);
  GET_AC(ch) = MIN(100, MAX(-100, GET_AC(ch)));

  /* Hitpoint bonus */
  start_hp = GET_MAX_HIT(ch);
  GET_MAX_HIT(ch) = GET_BASE_HIT(ch) + con_aff(ch) + count_applies(ch, APPLY_HIT);
  alter_hit(ch, start_hp - GET_MAX_HIT(ch), TRUE);

  /* Perception bonus
   * It comes out to base 480 for a level 99 human with maxed int and wis.
   */
  GET_PERCEPTION(ch) = (GET_LEVEL(ch) * ((GET_INT(ch) + GET_WIS(ch)) / 30)) +
                       count_applies(ch, APPLY_PERCEPTION);
  GET_PERCEPTION(ch) = MAX(0, MIN(GET_PERCEPTION(ch), 1000));
}


int count_applies(struct char_data *ch, int type)
{
  int value = 0;
  int i, j;
  struct effect *eff;

  for (i = 0; i < NUM_WEARS; ++i)
    if (GET_EQ(ch, i)) {
      if (type == APPLY_AC && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR)
        value -= GET_OBJ_VAL(GET_EQ(ch, i), VAL_ARMOR_AC);
      for (j = 0; j < MAX_OBJ_APPLIES; j++)
        if (GET_EQ(ch, i)->applies[j].location == type) {
          if (type == APPLY_AC)
            value -= GET_EQ(ch, i)->applies[j].modifier;
          else
            value += GET_EQ(ch, i)->applies[j].modifier;
        }
    }

  for (eff = ch->effects; eff; eff = eff->next)
    if (type == eff->location)
      value += eff->modifier;

  return value;
}
d3490 4
@


1.167
log
@Make sure object prototypes don't have the UNIQUE or WAS_DISARMED flags.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.166 2008/08/25 00:20:33 myc Exp myc $
d1588 1
a1588 1
  mobproto->viewed_abils = mobproto->natural_abils;  /* set the initail viewed abils */
d2327 1
a2327 1
  mob->viewed_abils = mob->natural_abils;
d3539 3
@


1.166
log
@Changed the way mobs memorize spells.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.165 2008/08/17 08:11:56 jps Exp myc $
d1930 4
d3539 3
@


1.165
log
@Logging equip errors to file.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.164 2008/08/17 06:51:42 jps Exp jps $
d1656 2
a1657 6
  for (j = 0;j <= NUM_SPELL_CIRCLES - 4;j++)
    mob_proto[i].mob_specials.mem_memed[j] = spells_of_circle[(int)(mob_proto[i].player.level)][(j + 1)];
  for (j= 0; j <= 11;j++)
    mob_proto[i].mob_specials.mem_state[j] = 0;


d3535 3
@


1.164
log
@Zone command E (equip char) will handle failures better, and destroy the object
rather than letting it sit in nowhere.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.163 2008/07/22 07:25:26 myc Exp jps $
d2687 1
a2687 1
                        mprintf(L_ERR, 101, "EQUIP zone command for %s [%d] in room %d to equip %s [%d] failed.",
d3539 4
@


1.163
log
@Added copy_extra_descriptions function.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.162 2008/07/15 17:49:24 myc Exp myc $
d2684 11
d2696 1
a2696 10
              if (GET_LEVEL(mob) < GET_OBJ_LEVEL(obj)) {
                char error_buf[2048];
                sprintf(error_buf, "Mob %s [%d] in room %d  cannot use object "
                        "%s [%d] because its level is to low.",
                        GET_NAME(mob), GET_MOB_VNUM(mob),
                        mob->in_room,
                        obj->short_description, GET_OBJ_VNUM(obj));
              }

                  equip_char(mob, obj, ZCMD.arg3);
d3539 3
@


1.162
log
@Boot command groups from file during boot-up sequence.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.161 2008/06/19 18:53:12 myc Exp myc $
d777 4
a780 2
    free(edesc->keyword);
    free(edesc->description);
d785 17
d3537 3
@


1.161
log
@Expanded item values to 7, and making obj timer values save to
world files.  Also don't make all spellbooks 100 pages anymore.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.160 2008/06/08 00:57:29 jps Exp myc $
d47 1
d730 3
d3518 4
@


1.160
log
@Set a spellbook's number of pages when loading. The number is just
the default for now, since prototypes don't have a field for this.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.159 2008/06/07 19:31:44 myc Exp jps $
d1972 7
a1978 9
  obj_proto[i].obj_flags.value[0].number = t[0];
  obj_proto[i].obj_flags.value[1].number = t[1];
  obj_proto[i].obj_flags.value[2].number = t[2];
  obj_proto[i].obj_flags.value[3].number = t[3];
/*
  obj_proto[i].spare1 = t[4];
  obj_proto[i].spare2 = t[5];
  obj_proto[i].spare3 = t[6];
*/
a1985 10
  if (obj_proto[i].obj_flags.type_flag == ITEM_PORTAL){
    obj_proto[i].obj_flags.weight = t[0];
    obj_proto[i].obj_flags.cost = t[1];
    obj_proto[i].obj_flags.timer = t[2];
    obj_proto[i].obj_flags.effect_flags[0] = t[3];
/*    obj_proto[i].spell_component = t[4]; */
/*    obj_proto[i].object_limitation = t[5]; */
    obj_proto[i].obj_flags.effect_flags[1] = t[6];
    obj_proto[i].obj_flags.effect_flags[2] = t[7];
  }
d1987 4
a1990 5
  else{
    obj_proto[i].obj_flags.weight = t[0];
    obj_proto[i].obj_flags.cost = t[1];
/*    obj_proto[i].obj_flags.cost_per_day = t[2]; */
    obj_proto[i].obj_flags.effect_flags[0] = t[3];
d1993 2
a1994 3
    obj_proto[i].obj_flags.effect_flags[1] = t[6];
    obj_proto[i].obj_flags.effect_flags[2] = t[7];
  }
d1999 2
a2000 2
    if (obj_proto[i].obj_flags.weight < obj_proto[i].obj_flags.value[1].number)
      obj_proto[i].obj_flags.weight = obj_proto[i].obj_flags.value[1].number + 5;
a2404 4
  else if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK)
     /* Since object prototypes don't have the number of pages, set the
      * number to a reasonable value. */
     GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) = DEFAULT_SPELLBOOK_PAGES;
d3514 4
@


1.159
log
@Fix count_applies.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.158 2008/06/07 19:06:46 myc Exp myc $
d2419 4
d3532 3
@


1.158
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.157 2008/06/05 02:07:43 myc Exp myc $
d2852 1
a2852 1
        value -= GET_OBJ_VAL(GET_EQ(ch, VAL_ARMOR_AC), 0);
d3528 3
@


1.157
log
@Rewrote corpse_saving and rent files to use ascii object files.
Changed object flags to use flagvectors, removed cost_per_day
and spell component fields.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.156 2008/05/26 18:24:48 jps Exp myc $
d1882 1
a1882 1
         GET_OBJ_VAL(obj, 1) = GET_OBJ_VAL(obj, 2);
a2416 2
  obj->spell_book_length = MAX_SPELLBOOK_PAGES;

d2852 1
a2852 1
        value -= GET_OBJ_VAL(GET_EQ(ch, i), 0);
d3528 5
@


1.156
log
@Removed code that deletes player object files.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.155 2008/05/18 20:16:11 jps Exp jps $
d757 1
a757 1
  Corpse_boot();
d1908 1
a1908 1
         SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NORENT);
d1963 1
a1963 1
  obj_proto[i].obj_flags.extra_flags = asciiflag_conv(f1);
d1965 1
a1965 1
  obj_proto[i].obj_flags.level_obj = t[1]; /* Zantir 3/23/01 for level based objects */
d1972 5
a1976 4
  obj_proto[i].obj_flags.value[0] = t[0];
  obj_proto[i].obj_flags.value[1] = t[1];
  obj_proto[i].obj_flags.value[2] = t[2];
  obj_proto[i].obj_flags.value[3] = t[3];
d1980 1
d1993 1
a1993 1
    obj_proto[i].spell_component = t[4];
d2002 1
a2002 1
    obj_proto[i].obj_flags.cost_per_day = t[2];
d2004 1
a2004 1
    obj_proto[i].spell_component = t[4];
d2013 2
a2014 2
    if (obj_proto[i].obj_flags.weight < obj_proto[i].obj_flags.value[1])
      obj_proto[i].obj_flags.weight = obj_proto[i].obj_flags.value[1] + 5;
d2019 3
a2021 3
  for (j = 0; j < MAX_OBJ_EFFECT; j++) {
    obj_proto[i].effects[j].location = APPLY_NONE;
    obj_proto[i].effects[j].modifier = 0;
d2047 2
a2048 2
      if (j >= MAX_OBJ_EFFECT) {
        fprintf(stderr, "Too many A fields (%d max), %s\n", MAX_OBJ_EFFECT, buf2);
d2060 2
a2061 2
      obj_proto[i].effects[j].location = t[0];
      obj_proto[i].effects[j].modifier = t[1];
d2855 2
a2856 2
      for (j = 0; j < MAX_OBJ_EFFECT; j++)
        if (GET_EQ(ch, i)->effects[j].location == type) {
d2858 1
a2858 1
            value -= GET_EQ(ch, i)->effects[j].modifier;
d2860 1
a2860 1
            value += GET_EQ(ch, i)->effects[j].modifier;
d3530 3
@


1.155
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.154 2008/05/18 05:18:06 jps Exp jps $
a96 1
int no_rent_check = 0;                /* skip rent check on boot?         */
a740 5
  if (!no_rent_check) {
    log("Deleting timed-out crash and rent files:");
    update_obj_file();
    log("Done.");
  }
d3528 3
@


1.154
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.153 2008/05/17 04:32:25 jps Exp jps $
d46 1
a160 1
void load_messages(void);
d3534 4
@


1.153
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.152 2008/05/14 05:13:22 jps Exp jps $
d63 2
a64 2
struct room_data *world = NULL;	/* array of rooms		 */
int top_of_world = 0;		/* ref to top element of world	 */
d73 7
a79 7
struct index_data *mob_index;	/* index table for mobile file	 */
struct char_data *mob_proto;	/* prototypes for mobs		 */
int top_of_mobt = 0;		/* top of mobile index table	 */
struct obj_data *object_list = NULL;	/* global linked list of objs	 */
struct index_data *obj_index;	/* index table for object file	 */
struct obj_data *obj_proto;	/* prototypes for objs		 */
int top_of_objt = 0;		/* top of object index table	 */
d81 8
a88 8
struct zone_data *zone_table;	/* zone table			 */
int top_of_zone_table = 0;	/* top element of zone tab	 */
struct message_list fight_messages[MAX_MESSAGES];	/* fighting messages	 */

struct player_index_element *player_table = NULL;	/* index to plr file	 */
int top_of_p_table = 0;		/* ref to top of table		 */
int top_of_p_file = 0;		/* ref of size of p file	 */
long top_idnum = 0;		/* highest idnum in use		 */
d90 1
a90 1
int no_mail = 0;		/* mail disabled?		 */
d92 1
a92 1
int mini_mud = 1;		/* mini-mud mode?		 */
d94 1
a94 1
int mini_mud = 0;		/* mini-mud mode?		 */
d96 3
a98 3
int no_rent_check = 0;		/* skip rent check on boot?	 */
time_t boot_time = 0;		/* time of mud boot		 */
int restrict = 0;		/* level of game restriction	 */
d100 3
a102 3
int r_mortal_start_room;	/* rnum of mortal start room	 */
int r_immort_start_room;	/* rnum of immort start room	 */
int r_frozen_start_room;	/* rnum of frozen start room	 */
d104 2
a105 2
char *credits = NULL;		/* game credits			 */
char *news = NULL;		/* mud news			 */
d107 9
a115 9
char *motd = NULL;		/* message of the day - mortals  */
char *imotd = NULL;		/* message of the day - immorts  */
char *help = NULL;		/* help screen			 */
char *info = NULL;		/* info page			 */
char *wizlist = NULL;		/* list of higher gods		 */
char *immlist = NULL;		/* list of peon gods		 */
char *background = NULL;	/* background story		 */
char *handbook = NULL;		/* handbook for new immortals	 */
char *policies = NULL;		/* policies page		 */
d117 2
a118 2
struct help_index_element *help_table = 0;	/* the help table	 */
int top_of_helpt = 0;		/* top of help index table	 */
d122 1
a122 1
struct reset_q_type reset_q;	/* queue of zones to be reset	 */
d188 10
a197 10
#define MOB_MONSUM_I		130
#define MOB_MONSUM_II		140
#define MOB_MONSUM_III		150
#define MOB_GATE_I		160
#define MOB_GATE_II		170
#define MOB_GATE_III		180
#define MOB_ELEMENTAL_BASE	110
#define MOB_CLONE		69
#define MOB_ZOMBIE		11
#define MOB_AERIALSERVANT	109
d316 1
a316 1
   */	
d330 1
a330 1
    xmain = (sh_int) (3 * ((float)level * (float)(level/1.25))); 	/*50 and under equation*/
d333 1
a333 1
    xmain = (sh_int) (3 * ((float)level * (float)(level/1.35))); 	/*50 and under equation*/
d336 1
a336 1
    xmain = (sh_int) (3 * ((float)level * (float)level/1.25)); 	/*50 and under equation*/
d401 1
a401 1
      hit = (sbyte) (level/3.2);	/*50 and under equation*/
d405 1
a405 1
      hit = (sbyte) (level/3.6);	 /*51 and over equation*/
d425 1
a425 1
      dam = (sbyte) (level / 4.6);	/*50 and under equation*/
d428 1
a428 1
      dam = (sbyte) (level / 4.4);	/*51 and over equation*/
d467 1
a467 1
      dice = (int) ((level /3) + .5);	/*50 and under equation*/
d470 1
a470 1
      dice = (int) ((level / 2.5) + .5);	/*51 and over equation*/
d485 1
a485 1
      face = 5;	/*50 and under equation*/
d487 1
a487 1
      face = 8;	   /*50 over equation*/
d589 3
a591 3
	  log("Error in booting spell dams");
	  /* return;
	   */  }
d594 10
a603 10
	  get_line(ifptr, line);
	  sscanf(line, "%hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd",
		 &SD_SPELL(i), &SD_INTERN_DAM(i),
		 &SD_NPC_STATIC(i), &SD_NPC_NO_DICE(i), &SD_NPC_NO_FACE(i),
		 &SD_PC_STATIC(i), &SD_PC_NO_DICE(i), &SD_PC_NO_FACE(i), &SD_NPC_REDUCE_FACTOR(i), &SD_USE_BONUS(i),
		 &SD_BONUS(i), &SD_LVL_MULT(i));
	  if (SD_NPC_REDUCE_FACTOR(i) == 0)
	    SD_NPC_REDUCE_FACTOR(i) = 100;
	
	  SD_NOTE(i) = fread_string(ifptr, err);
d749 2
a750 2
	    zone_table[i].name, (i ? (zone_table[i - 1].top + 1) : 0),
	    zone_table[i].top);
d1026 1
a1026 1
	  time_info.day, time_info.month, time_info.year);
d1107 1
a1107 1
	rec_count++;
d1109 1
a1109 1
	rec_count += count_hash_records(db_file);
d1199 7
a1205 7
	tmp_debug++;
	if (!get_line(fl, line)) {
	  fprintf(stderr, "Format error after %s #%d\n", modes[mode], nr);
	  fprintf(stderr, "Offending line: '%s'in file down list%d\n", line,
		  tmp_debug);
	  exit(1);
	}
d1213 3
a1215 3
	fprintf(stderr, "Format error after %s #%d\n", modes[mode], last);
	fprintf(stderr, "Offending line: '%s'\n", line);
	exit(1);
d1218 1
a1218 1
	return;
d1220 14
a1233 14
	switch (mode) {
	case DB_BOOT_TRG:
	  parse_trigger(fl, nr);
	  break;
	case DB_BOOT_WLD:
	  parse_room(fl, nr);
	  break;
	case DB_BOOT_MOB:
	  parse_mobile(fl, nr);
	  break;
	case DB_BOOT_OBJ:
	  strcpy(line, parse_object(fl, nr));
	  break;
	}
d1236 1
a1236 1
	      modes[mode], modes[mode], nr);
d1292 1
a1292 1
  world[room_nr].number = virtual_nr;
d1308 1
a1308 1
  world[room_nr].light = 0;	/* Zero light sources */
d1333 1
a1333 1
    case 'S':			/* end of room */
d1359 1
a1359 1
  sprintf(buf2, "room #%d, direction D%d", world[room].number, dir);
d1362 3
a1364 1
    sprintf(log_buf, "SYSERR:db.c:setup_dir:creating direction [%d] for room %d twice!", dir, world[room].number);
d1429 7
a1435 7
	if (world[room].exits[door]->to_room != NOWHERE) {
	  rnum = real_room(world[room].exits[door]->to_room);
	  world[room].exits[door]->to_room = rnum;
	  if(rnum == NOWHERE) {
            sprintf(buf, "SYSERR:db.c:renum_world():Invalid exit to NOWHERE for dir %s in room %d", dirs[door], world[room].number);
	    log(buf);
	  }
d1453 3
a1455 3
	a = ZCMD.arg1 = real_mobile(ZCMD.arg1);
	b = ZCMD.arg3 = real_room(ZCMD.arg3);
	break;
d1457 4
a1460 4
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	if (ZCMD.arg3 != NOWHERE)
	  b = ZCMD.arg3 = real_room(ZCMD.arg3);
	break;
d1462 2
a1463 2
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	break;
d1465 2
a1466 2
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	break;
d1468 3
a1470 3
	a = ZCMD.arg1 = real_object(ZCMD.arg1);
	b = ZCMD.arg3 = real_object(ZCMD.arg3);
	break;
d1472 2
a1473 2
	a = ZCMD.arg1 = real_room(ZCMD.arg1);
	break;
d1476 1
a1476 1
	b = ZCMD.arg2 = real_object(ZCMD.arg2);
d1480 3
a1482 3
	if (!mini_mud)
	  log_zone_error(zone, cmd_no, "Invalid vnum, cmd disabled");
	ZCMD.command = '*';
d1489 1
a1489 1
#define OLC_MOB(d)	((d)->olc->mob)
d1500 1
a1500 1
	     t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8) != 9) {
d1502 1
a1502 1
	    "...expecting line of form '# # # #d#+# #d#+#'\n", nr);
d1539 1
a1539 1
      {	GET_ZONE(mob_proto + i) = (nr/100);
d1543 1
a1543 1
      }	GET_EX_GOLD(mob_proto + i) = t[0];
d1581 1
a1581 1
	/*Money adder*/
d1599 3
a1601 3
  /*	l = get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
	sprintf(buf, "get is: %d", l);
	mudlog(buf, BRF, LVL_IMPL, TRUE);
d1605 2
a1606 2
	else
	  mob_proto[i].points.armor = (sh_int) get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
d1620 2
a1621 2
  mob_proto[i].points.damroll	= get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
  mob_proto[i].points.damroll	+= mob_proto[i].mob_specials.ex_damroll;
d1624 1
a1624 1
						       GET_CLASS(mob_proto + i), 0), 80);
d1748 1
a1748 1
	    keyword, nr);
d1777 1
a1777 1
    if (!strcmp(line, "E"))	/* end of the ehanced section */
d1779 1
a1779 1
    else if (*line == '#') {	/* we've hit the next mob, maybe? */
d1810 1
a1810 1
	!str_cmp(fname(tmpptr), "the"))
d1827 1
a1827 1
  case 'S':	/* Simple monsters */
d1830 1
a1830 1
  case 'E':	/* Circle3 Enhanced monsters */
d1859 2
a1860 2
	  while (fread_letter(mob_f) != '|');
	  fprintf(stderr,"Mob %d has a mobprog still!\n",nr);
d1863 1
a1863 1
  	ungetc(letter, mob_f);
d1948 1
a1948 1
	!str_cmp(fname(tmpptr), "the"))
d2052 2
a2053 2
	fprintf(stderr, "Too many A fields (%d max), %s\n", MAX_OBJ_EFFECT, buf2);
	exit(1);
d2057 5
a2061 5
	  (retval = sscanf(line, " %d %d ", t, t + 1)) != 2)
	{
	  fprintf(stderr, "Format error in Affect line (expecting 2 args, got %d), %s\n", retval, buf2);
	  /*exit(1);*/
	}
d2063 1
a2063 1
	 sscanf(line, " %d %d ", t, t + 1); */
d2093 1
a2093 1
#define Z	zone_table[zone]
d2124 1
a2124 1
  if ((ptr = strchr(buf, '~')) != NULL)	/* take off the '~' if it's there */
d2130 1
a2130 1
	     &Z.reset_mode, &Z.zone_factor, &Z.hemisphere, &Z.climate) != 4)
d2162 3
a2164 3
      if (strchr("MOEPD", ZCMD.command) == NULL) {	/* a 3-arg command */
	if (sscanf(ptr, " %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2) != 3)
	  error = 1;
d2166 3
a2168 3
	if (sscanf(ptr, " %d %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2,
		   &ZCMD.arg3) != 4)
	  error = 1;
d2175 1
a2175 1
	      line_num, buf);
d2278 1
a2278 1
*  procedures for resetting, both play-time and boot-time	 	 *
d2290 2
a2291 2
	      zone_table[nr].number,
	      zone_table[nr].name);
d2454 2
a2455 2
	  zone_table[i].reset_mode)
	(zone_table[i].age)++;
d2458 16
a2473 16
	  zone_table[i].age < ZO_DEAD && zone_table[i].reset_mode) {
	/* enqueue zone */
	
	CREATE(update_u, struct reset_q_element, 1);
	
	update_u->zone_to_reset = i;
	update_u->next = 0;
	
	if (!reset_q.head)
	  reset_q.head = reset_q.tail = update_u;
	else {
	  reset_q.tail->next = update_u;
	  reset_q.tail = update_u;
	}
	
	zone_table[i].age = ZO_DEAD;
d2476 1
a2476 1
  }	/* end - one minute has passed */
d2483 1
a2483 1
	is_empty(update_u->zone_to_reset)) {
d2486 1
a2486 1
	      zone_table[update_u->zone_to_reset].name);
d2490 1
a2490 1
	reset_q.head = reset_q.head->next;
d2492 7
a2498 7
	for (temp = reset_q.head; temp->next != update_u;
	     temp = temp->next);
	
	if (!update_u->next)
	  reset_q.tail = temp;
	
	temp->next = update_u->next;
d2514 1
a2514 1
	  ZCMD.command, zone_table[zone].number, ZCMD.line);
d2519 1
a2519 1
	{ log_zone_error(zone, cmd_no, message); last_cmd = 0; }
d2579 1
a2579 1
    case '*':			/* ignore command */
d2591 1
a2591 1
    case 'M':			/* read a mobile */
d2593 2
a2594 2
	mob = read_mobile(ZCMD.arg1, REAL);
	char_to_room(mob, ZCMD.arg3);
d2596 1
a2596 1
	last_cmd = 1;
d2598 1
a2598 1
	last_cmd = 0;
d2601 1
a2601 1
    case 'O':			/* read an object */
d2604 5
a2608 5
	{
	  obj = read_object(ZCMD.arg1, REAL);
	  if (ZCMD.arg3 >= 0)
	    {
	    obj_to_room(obj, ZCMD.arg3);
d2610 7
a2616 7
	    }
	  else
	    {
		  obj->in_room = NOWHERE;
		  last_cmd = 1;
	    }
	}
d2618 1
a2618 1
	last_cmd = 0;
d2621 1
a2621 1
    case 'P':			/* object to object */
d2623 11
a2633 11
	{
	  obj = read_object(ZCMD.arg1, REAL);
	      if (!(obj_to = get_obj_num(ZCMD.arg3)))
		{
		  ZONE_ERROR("target obj not found");
		  extract_obj(obj);
		  break;
		}
	      obj_to_obj(obj, obj_to);
	      last_cmd = 1;
	}
d2635 1
a2635 1
	last_cmd = 0;
d2638 1
a2638 1
    case 'G':			/* obj_to_char */
d2640 4
a2643 4
	{
	  ZONE_ERROR("attempt to give obj to non-existent mob");
	  break;
	}
d2646 12
a2657 2
	{
	  obj = read_object(ZCMD.arg1, REAL);
d2659 3
a2661 13
	  if (GET_LEVEL(mob) < GET_OBJ_LEVEL(obj)) {
	    char error_buf[2048];
	    sprintf(error_buf, "Mob %s [%d] in room %d  cannot use object "
		    "%s [%d] because its level is to low.",
		    GET_NAME(mob), GET_MOB_VNUM(mob),
		    mob->in_room,
		    obj->short_description, GET_OBJ_VNUM(obj));
	  }


	      obj_to_char(obj, mob);
	      last_cmd = 1;
	}
d2663 1
a2663 1
	last_cmd = 0;
d2666 1
a2666 1
    case 'E':			/* object to equipment list */
d2668 4
a2671 4
	{
	  ZONE_ERROR("trying to equip non-existent mob");
	  break;
	}/*was make sure number less then ZCMD.arg2*/
d2673 22
a2694 22
	{
	  if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS)
	    {
	      ZONE_ERROR("invalid equipment pos number");
	    }
	  else
	    {
	      obj = read_object(ZCMD.arg1, REAL);

	      if (GET_LEVEL(mob) < GET_OBJ_LEVEL(obj)) {
		char error_buf[2048];
		sprintf(error_buf, "Mob %s [%d] in room %d  cannot use object "
			"%s [%d] because its level is to low.",
			GET_NAME(mob), GET_MOB_VNUM(mob),
			mob->in_room,
			obj->short_description, GET_OBJ_VNUM(obj));
	      }

		  equip_char(mob, obj, ZCMD.arg3);
		  last_cmd = 1;
	    }
	}
d2696 1
a2696 1
	last_cmd = 0;
d2708 1
a2708 1
      case 'D':			/* set state of door */
d2774 1
a2774 1
	return 0;
d2876 1
a2876 1
 *  funcs of a (more or less) general utility nature			*
d2892 1
a2892 1
	      error);
d3047 6
a3052 6
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
d3065 6
a3070 6
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
d3197 1
a3197 1
  GET_AC(ch) = 100;		/* Basic Armor */
d3224 1
a3224 1
    if ((world + mid)->number == virtual)
d3228 1
a3228 1
    if ((world + mid)->number > virtual)
d3406 6
a3411 6
	{
	  if (cEnd == ' ' || cEnd == '~')
	    ungetc(*pword, fp);
	  *pword = '\0';
	  return word;
	}
d3465 2
a3466 2
    "shape",			/* infra.. */
    "shadow",			/* summon */
d3474 1
a3474 1
	(i && (*(test + i) != *arg)))
d3534 3
@


1.152
log
@alter_hit doesn't take the attacker any more.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.151 2008/05/11 05:46:00 jps Exp jps $
d828 1
a828 1
      if (!world[cnt].dir_option[itr])
d831 5
a835 5
      if (world[cnt].dir_option[itr]->general_description)
        free(world[cnt].dir_option[itr]->general_description);
      if (world[cnt].dir_option[itr]->keyword)
        free(world[cnt].dir_option[itr]->keyword);
      free(world[cnt].dir_option[itr]);
d1311 1
a1311 1
    world[room_nr].dir_option[i] = NULL;
d1361 1
a1361 1
  if(world[room].dir_option[dir]) {
d1365 1
a1365 1
    CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
d1367 2
a1368 2
  world[room].dir_option[dir]->general_description = fread_string(fl, buf2);
  world[room].dir_option[dir]->keyword = fread_string(fl, buf2);
d1379 1
a1379 1
    world[room].dir_option[dir]->exit_info = EX_ISDOOR;
d1381 1
a1381 1
    world[room].dir_option[dir]->exit_info = EX_ISDOOR | EX_PICKPROOF;
d1383 1
a1383 1
    world[room].dir_option[dir]->exit_info = EX_DESCRIPT;
d1387 1
a1387 1
    world[room].dir_option[dir]->exit_info = 0;
d1389 2
a1390 2
  world[room].dir_option[dir]->key = t[1];
  world[room].dir_option[dir]->to_room = t[2];
d1426 4
a1429 4
      if (world[room].dir_option[door])
	if (world[room].dir_option[door]->to_room != NOWHERE) {
	  rnum = real_room(world[room].dir_option[door]->to_room);
	  world[room].dir_option[door]->to_room = rnum;
d2523 3
a2525 3
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
d2528 3
a2530 3
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
d2533 3
a2535 3
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
d2538 3
a2540 3
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
d2542 1
a2542 1
**          SET_BIT(world[roomnum].dir_option[dir]->exit_info,
d2547 3
a2549 3
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
d2552 3
a2554 3
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_CLOSED);
         REMOVE_BIT(world[roomnum].dir_option[dir]->exit_info, EX_LOCKED);
         SET_BIT(world[roomnum].dir_option[dir]->exit_info, EX_HIDDEN);
d2708 1
a2708 1
               (world[ZCMD.arg1].dir_option[ZCMD.arg2] == NULL)) {
d2721 1
a2721 1
            if ((other_room = world[ZCMD.arg1].dir_option[ZCMD.arg2]->to_room)
d2728 1
a2728 1
                  if (world[other_room].dir_option[rev_dir[ZCMD.arg2]]) {
d2731 1
a2731 1
                     if (world[other_room].dir_option[rev_dir[ZCMD.arg2]]->to_room
d3532 3
@


1.151
log
@Using regen.h. alter_hit() now takes the attacker.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.150 2008/04/07 17:24:22 jps Exp jps $
d2836 1
a2836 1
  alter_hit(ch, NULL, start_hp - GET_MAX_HIT(ch), TRUE);
d3532 3
@


1.150
log
@Add "stance" to mob e-specs.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.149 2008/04/07 04:31:23 jps Exp jps $
d45 1
d2836 1
a2836 1
  alter_hit(ch, start_hp - GET_MAX_HIT(ch), TRUE);
d3532 3
@


1.149
log
@Ensure mob prototypes load with sensible position and default position.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.148 2008/04/07 03:02:54 jps Exp jps $
d1562 1
d1739 4
d3531 3
@


1.148
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.147 2008/04/05 16:39:18 jps Exp jps $
d1857 8
d3526 4
@


1.147
log
@Rename the function that handles the "reload" command from do_reboot
to do_reload.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.146 2008/04/04 06:12:52 myc Exp jps $
d3144 1
a3144 1
  GET_STANCE(ch) = STANCE_STANDING;
d3175 1
a3175 1
  GET_STANCE(ch) = STANCE_STANDING;
d3518 4
@


1.146
log
@Removed dieites/worship and ships code.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.145 2008/04/02 04:55:59 myc Exp myc $
d215 1
a215 1
ACMD(do_reboot)
d262 1
a262 1
	  free(help_table[i].keyword);
d264 1
a264 1
	  free(help_table[i].entry);
d3518 3
@


1.145
log
@Got rid of the coins struct.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.144 2008/04/02 03:24:44 myc Exp myc $
a32 1
#include "ships.h"
a129 1
void init_ships();
a767 3
  init_ships();
  log("Booting ships.");

d3518 3
@


1.144
log
@Rewrote group code and removed all major group code.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.143 2008/03/30 17:30:38 jps Exp myc $
d1577 4
a1580 4
  mob_proto[i].points.coins.gold = 0;
  mob_proto[i].points.coins.plat = 0;
  mob_proto[i].points.coins.silver = 0;
  mob_proto[i].points.coins.copper = 0;
d1586 1
a1586 1
  mob_proto[i].points.coins.plat = ((int) (j/1000));
d1588 1
a1588 1
  mob_proto[i].points.coins.gold = ((int) (j/100));
d1590 1
a1590 1
  mob_proto[i].points.coins.silver = ((int) (j/10));
d1594 1
a1594 1
  mob_proto[i].points.coins.copper = j;
d1596 2
a1597 2
  mob_proto[i].points.coins.plat = MAX(0, mob_proto[i].points.coins.plat + GET_EX_PLAT(mob_proto + i));
  mob_proto[i].points.coins.gold = MAX(0, mob_proto[i].points.coins.gold + GET_EX_GOLD(mob_proto + i));
d3523 3
@


1.143
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.142 2008/03/28 17:54:53 myc Exp jps $
a168 1
/*  void boot_frags(); */
a619 89
/*each player has a frag, which is a float of how many pc's they have killed
  There is a structure:
  struct player_frags_data {
  int playerid;
  char	name[MAX_NAME_LENGTH + 1];
  float frag;
  }
  struct player_frags[19] - 0 -> 9 top 10, 10 - 19 bottom 10
  - this is a globel defined in db.c
  This code simply reads througth playerfile and checks for the highest and lowest
  frags and thus any errors in the frags should be fixed with a boot
  removed by gurlaek 8/7/1999
void boot_frags()
{
  struct char_file_u chara;
  FILE *pfptr;
  int i, j;
  int pid = 0;

  if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
    {
      if (errno != ENOENT)
        {
	  perror("fatal error opening playerfile");
	  exit(1);
        }
      else
        {
	  log("No playerfile.  Creating a new one.");
	  touch(PLAYER_FILE);
	  if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
            {
	      perror("fatal error opening playerfile");
	      exit(1);
            }
        }
    }

  while (!feof(pfptr))
    {
      fread(&chara , sizeof(struct char_file_u), 1, pfptr);
      if (chara.player_specials_saved.frag > 0.0)
        {
	  for (i = 0;i <= 14;i++)
            {
	      if (!str_cmp(pos_player_frags[i].name, chara.name))
		break;
	      if (pos_player_frags[i].frag < chara.player_specials_saved.frag)
                {

		  for (j = 14;j > i; j--)
                    {
		      pos_player_frags[j] = pos_player_frags[j-1];
                    }
		  pos_player_frags[i].playerid = pid;
		  strcpy(pos_player_frags[i].name, chara.name);
		  pos_player_frags[i].frag = chara.player_specials_saved.frag;
		  break;
                }
            }
        }
      else if (chara.player_specials_saved.frag < 0.0)
        {
	  for (i = 0;i <= 14;i++)
            {
	      if (!str_cmp(neg_player_frags[i].name, chara.name))
		break;
	      if (neg_player_frags[i].frag > chara.player_specials_saved.frag)
                {
		  for (j = 14;j > i; j--)
                    {
		      neg_player_frags[j] = neg_player_frags[j-1];
                    }
		  neg_player_frags[i].playerid = pid;
		  strcpy(neg_player_frags[i].name, chara.name);
		  neg_player_frags[i].frag = chara.player_specials_saved.frag;
		  break;
                }
            }
        }
      pid++;
    }

  rewind(pfptr);
}
*/



d677 1
a677 4
  /*
  log ("Booting frags");
  boot_frags();
  */
d803 2
a804 2
    if (chtmp->groupmaster)
      stop_groupee(chtmp, FALSE);
a3133 2
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_GROUP);
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
d3139 1
a3139 3
  ch->groupmaster = NULL;
  ch->mgroupmaster = NULL;
  ch->mgroupees = NULL;
d3523 4
@


1.142
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.141 2008/03/23 00:24:29 jps Exp myc $
d45 1
a162 1
void update_obj_file(void);	/* In objsave.c */
d3620 4
@


1.141
log
@Make sure to reset base composition.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.140 2008/03/22 21:43:34 jps Exp jps $
d64 1
a64 1
struct raff_node *raff_list = NULL;  /* list of room affections */
d972 2
a973 2
    while (mob_proto[cnt].affected)
      affect_remove(&mob_proto[cnt], mob_proto[cnt].affected);
d1398 2
a1399 1
  world[room_nr].room_flags = asciiflag_conv(flags);
d1808 1
a1808 1
     AFF2_FLAGS(mob_proto + i) = num_arg;
d1812 1
a1812 1
     AFF3_FLAGS(mob_proto + i) = num_arg;
d1816 1
a1816 1
     MOB2_FLAGS(mob_proto + i) = num_arg;
d1911 3
a1913 3
  MOB_FLAGS(mob_proto + i) = asciiflag_conv(f1);
  SET_BIT(MOB_FLAGS(mob_proto + i), MOB_ISNPC);
  AFF_FLAGS(mob_proto + i) = asciiflag_conv(f2);
d2078 1
a2078 1
    obj_proto[i].obj_flags.spell_flags = t[3];
d2080 3
a2082 3
    obj_proto[i].object_limitation = t[5];
    obj_proto[i].obj_flags.spell_flags2 = t[6];
    obj_proto[i].obj_flags.spell_flags3 = t[7];
d2089 1
a2089 1
    obj_proto[i].obj_flags.spell_flags = t[3];  /* Duh this was somehow removed -Banyal */
d2091 3
a2093 3
    obj_proto[i].object_limitation = t[5];
    obj_proto[i].obj_flags.spell_flags2 = t[6];
    obj_proto[i].obj_flags.spell_flags3 = t[7];
d2105 3
a2107 3
  for (j = 0; j < MAX_OBJ_AFFECT; j++) {
    obj_proto[i].affected[j].location = APPLY_NONE;
    obj_proto[i].affected[j].modifier = 0;
d2133 2
a2134 2
      if (j >= MAX_OBJ_AFFECT) {
	fprintf(stderr, "Too many A fields (%d max), %s\n", MAX_OBJ_AFFECT, buf2);
d2146 2
a2147 2
      obj_proto[i].affected[j].location = t[0];
      obj_proto[i].affected[j].modifier = t[1];
d2208 1
a2208 1
  Z.name = str_dup(buf);
d2240 1
a2240 1
        ZCMD.sarg = str_dup(ptr);
d2312 1
a2312 1
    el.entry = str_dup(entry);
d2315 1
a2315 1
      el.keyword = str_dup(next_key);
d2690 2
a2691 10
	      if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
		{
		  OBJ_INDEX_LIMIT(obj->item_number) ++;
		  obj_to_room(obj, ZCMD.arg3);
		  last_cmd = 1;
		}else
		  {
		    last_cmd = 0;
		    extract_obj(obj);
		  }
a2694 3
	      if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
		{
		  OBJ_INDEX_LIMIT(obj->item_number) ++;
a2696 6
		}
	      else
		{
		  last_cmd = 0;
		  extract_obj(obj);
		}
a2706 2
	  if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
	    {
a2713 1
	      OBJ_INDEX_LIMIT(obj->item_number) ++;
a2714 6
	    }
	  else
	    {
	      last_cmd = 0;
	      extract_obj(obj);
	    }
a2740 3
	  if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
	    {
	      OBJ_INDEX_LIMIT(obj->item_number) ++;
a2742 5
	    }else
	      {
		last_cmd = 0;
		extract_obj(obj);
	      }
a2772 3
	      if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
		{
		  OBJ_INDEX_LIMIT(obj->item_number) ++;
a2774 6
		}
	      else
		{
		  last_cmd = 0;
		  extract_obj(obj);
		}
d2935 1
a2935 1
  struct affected_type *af;
d2941 2
a2942 2
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        if (GET_EQ(ch, i)->affected[j].location == type) {
d2944 1
a2944 1
            value -= GET_EQ(ch, i)->affected[j].modifier;
d2946 1
a2946 1
            value += GET_EQ(ch, i)->affected[j].modifier;
d2950 3
a2952 3
  for (af = ch->affected; af; af = af->next)
    if (type == af->location)
      value += af->modifier;
d3018 2
a3019 2
  while (ch->affected)
    affect_remove(ch, ch->affected);
d3181 1
a3181 1
    *buf = str_dup(temp);
d3226 3
a3228 3
  REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d3620 3
@


1.140
log
@Read life force and composition from mob proto files.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.139 2008/03/22 17:12:19 jps Exp jps $
d1831 1
d3662 3
@


1.139
log
@Set the ITEM_NORENT flag on keys when created.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.138 2008/03/21 14:54:19 myc Exp jps $
d1826 8
d3661 3
@


1.138
log
@Added a note to free_char about freeing the event list.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.137 2008/03/17 16:22:42 myc Exp myc $
d1984 4
d3653 3
@


1.137
log
@Updating calls to free_proto_script, and nullifying SCRIPTs after
extraction.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.136 2008/03/16 00:20:02 jps Exp myc $
d3119 6
d3649 4
@


1.136
log
@Updated call to free_trophy().
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.135 2008/03/11 02:54:53 jps Exp jps $
d917 1
a917 1
    if (SCRIPT(&world[cnt]))
d919 2
d922 1
a922 1
    free_proto_script(&world[cnt], WLD_TRIGGER);
d951 1
a951 1
    free_proto_script(&obj_proto[cnt], OBJ_TRIGGER);
d970 1
a970 1
    free_proto_script(&mob_proto[cnt], MOB_TRIGGER);
d3643 3
@


1.135
log
@Use set_base_size when creating mob prototypes.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.134 2008/03/10 20:46:55 myc Exp jps $
d44 1
d3059 1
a3059 1
    free_trophy(&GET_TROPHY(ch));
d3641 3
@


1.134
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.133 2008/03/09 06:38:37 jps Exp myc $
d1643 1
a1643 1
    mob_proto[i].player.size = t[6];
d1647 1
a1647 1
  }	else {
d1651 1
a1651 1
    mob_proto[i].player.size = SIZE_OF_RACE(DEFAULT_RACE);
d3640 3
@


1.133
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.132 2008/03/08 23:20:06 myc Exp jps $
a1738 3
  for (j = 0; j < 4; j++)
    GET_INNATE_TIMER(mob_proto + i, j) = -1;

d3265 3
a3267 3
  ch->char_specials.position = POS_STANDING;
  ch->char_specials.position1 = POS1_STANDING;
  ch->mob_specials.default_pos = POS_STANDING;
d3297 1
a3297 1
  GET_POS1(ch) = POS1_STANDING;
d3640 5
@


1.132
log
@Free events in free_char instead of in extract_char.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.131 2008/03/07 21:21:57 myc Exp myc $
d955 2
a956 2
    if (mob_proto[cnt].player.name)
      free(mob_proto[cnt].player.name);
d1886 1
a1886 1
  mob_proto[i].player.name = fread_string(mob_f, buf2);
d3083 2
a3084 2
    if (GET_NAME(ch))
      free(GET_NAME(ch));
d3089 2
a3090 2
    if (ch->player.short_descr)
      free(ch->player.short_descr);
d3098 2
a3099 2
    if (ch->player.name && ch->player.name != mob_proto[i].player.name)
      free(ch->player.name);
d3643 3
@


1.131
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.130 2008/03/05 05:21:56 myc Exp myc $
d3119 5
a3281 2
  for (i = 0; i < EVENT_FLAG_FIELDS; ++i)
    ch->event_flags[i] = 0;
d3643 5
@


1.130
log
@Removed save_char_file_u declaration.  Removed player frags.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.129 2008/03/05 05:08:28 jps Exp myc $
d3300 2
a3301 3
  for (i = 0; i < MAX_ACTION_DELAYS; i++)
    ch->char_specials.action_delays[i] = 0;

d3640 3
@


1.129
log
@Changed ascii player tags and allow them to be of variable length up to
126 characters.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.128 2008/03/05 03:03:54 myc Exp jps $
a53 1
void save_char_file_u(struct char_file_u st);
a78 2
struct player_frags_data pos_player_frags[15];/*internal frag list 10 high 10 low*/
struct player_frags_data neg_player_frags[15];/*internal neg frag list*/
a142 2
void char_to_store(struct char_data * ch, struct char_file_u * st);
void store_to_char(struct char_file_u * st, struct char_data * ch);
d3641 4
@


1.128
log
@Moved many player functions from here to players.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.127 2008/02/23 01:03:54 myc Exp myc $
d3607 1
a3607 1
/* Separate a 4-character id tag from the data it precedes */
d3612 1
a3612 1
  for(i = 0; i < 4; i++)
d3646 3
@


1.127
log
@Renamed assign_mem_list to init_mem_list.  Freeing memory and scribe
lists when freeing a character.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.126 2008/02/16 20:26:04 myc Exp myc $
d43 1
d47 1
a47 1
struct player_special_data *dummy_mob = NULL;
a49 1
void boot_obj_limit();
a162 4
void build_player_index(void);
void modify_player_index_file(char *name, char *newname);
void delete_player_from_index(char *name);
int delete_player(char *name);
a172 1
const char  *std_prompt =  "<&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)>%_&0<%t&0>:<%o&0> ";
d740 1
a749 3
  log("Booting object limit");
  boot_obj_limit();

a978 1
  free(dummy_mob);
a1131 223
/* generate index table for the player file */
void build_player_index(void) {
  int nr = -1, i;
  long size, recs = 0;
  struct char_file_u dummy;
  char plr_name[MAX_NAME_LENGTH + 1];
  char fn[255];
  FILE *player_fl, *player_file_index;

  sprintf(fn, "%s/%s", PLR_PREFIX, INDEX_FILE);

  if (!(player_file_index = fopen(fn, "r"))) {
    if (errno != ENOENT) {
      perror("fatal error opening playerfile index");
      exit(1);
    } else {
      log("No playerfile index.  Creating a new one.");
      touch(fn);
      if (!(player_file_index = fopen(fn, "r"))) {
	perror("fatal error opening playerfile index");
	exit(1);
      }
    }
  }

  while(fgets(plr_name, MAX_NAME_LENGTH + 1, player_file_index)) {
    recs++;
  }

  rewind(player_file_index);

  if (recs) {
    sprintf(buf, "%ld players in index file.", recs);
    log(buf);
    CREATE(player_table, struct player_index_element, recs);
  } else {
    player_table = NULL;
    top_of_p_file = top_of_p_table = -1;
    return;
  }

  while(fgets(plr_name, MAX_NAME_LENGTH + 1, player_file_index)) {
    plr_name[strlen(plr_name) - 1] = '\0'; /* remove the \n */
    plr_name[0] = toupper(plr_name[0]);
    memset(fn, 0x0, 255);

    get_filename(plr_name, fn, PLR_FILE);

    if (!(player_fl = fopen(fn, "r+"))) {
      sprintf(buf, "No player file for index name: %s", plr_name);
      log(fn);
      log(buf);
    } else {
      fseek(player_fl, 0L, SEEK_END);
      size = ftell(player_fl);
      rewind(player_fl);
      if (size % sizeof(struct char_file_u)) {
	sprintf(buf, "SYSERR: Player file for %s is CORRUPT! Skipping!", plr_name);
	log(buf);
      } else {
	nr++;
	fread(&dummy, sizeof(struct char_file_u), 1, player_fl);
	CREATE(player_table[nr].name, char, strlen(dummy.name) + 1);
	for (i = 0; (*(player_table[nr].name + i) = LOWER(*(dummy.name + i))); i++);
	player_table[nr].id = dummy.char_specials_saved.idnum;
	top_idnum = MAX(top_idnum, dummy.char_specials_saved.idnum);
      }
      fclose(player_fl);
    }
  }
  fclose(player_file_index);

  top_of_p_file = top_of_p_table = nr;
}

void modify_player_index_file(char *name, char *newname) {
  char plr_name[MAX_NAME_LENGTH + 1];
  char new_plr_name[MAX_NAME_LENGTH + 1];
  char fn[255], fn2[255];
  FILE *player_index_file, *new_player_index_file;

  sprintf(fn, "%s/%s", PLR_PREFIX, INDEX_FILE);
  sprintf(fn2, "%s/%s.new", PLR_PREFIX, INDEX_FILE);

  if (!(player_index_file = fopen(fn, "r"))) {
    perror("fatal error opening playerfile index");
    exit(1);
  }
  if (!(new_player_index_file = fopen(fn2, "w"))) {
    perror("Unable to create new player index file");
    exit(1);
  }

  strcpy(new_plr_name, newname);
  new_plr_name[0] = toupper(new_plr_name[0]);

  while(fgets(plr_name, MAX_NAME_LENGTH + 1, player_index_file)) {
    plr_name[strlen(plr_name) - 1] = '\0'; /* remove the \n */
    plr_name[0] = toupper(plr_name[0]);
    if(!strcmp(plr_name, name)) {
      fputs(new_plr_name, new_player_index_file);
    } else {
      fputs(plr_name, new_player_index_file);
    }
    fputs("\n", new_player_index_file);
  }
  fclose(player_index_file);
  fclose(new_player_index_file);
  remove(fn);
  rename(fn2, fn);
}

/* Compartmentalized from delete_player() RSD 10/11/2000 */
void delete_player_from_index(char *name) {
  char plr_name[MAX_NAME_LENGTH + 1];
  char tmp_name[MAX_NAME_LENGTH + 1];
  char fn[255], fn2[255];
  FILE *player_index_file, *new_player_index_file;

  sprintf(fn, "%s/%s", PLR_PREFIX, INDEX_FILE);
  sprintf(fn2, "%s/%s.new", PLR_PREFIX, INDEX_FILE);

  if (!(player_index_file = fopen(fn, "r"))) {
    perror("fatal error opening playerfile index");
    exit(1);
  }
  if (!(new_player_index_file = fopen(fn2, "w"))) {
    perror("Unable to create new player index file");
    exit(1);
  }
  strcpy(tmp_name, name);
  /* Write a new index w/o the player in question */
  while(fgets(plr_name, MAX_NAME_LENGTH + 1, player_index_file)) {
    plr_name[strlen(plr_name) - 1] = '\0'; /* remove the \n */
    plr_name[0] = toupper(plr_name[0]);
    tmp_name[0] = toupper(tmp_name[0]);
    if(strcmp(plr_name, tmp_name)) {
      fputs(plr_name, new_player_index_file);
      fputs("\n", new_player_index_file);
    } else {
      log("Deleted character from index!");
    }
  }
  fclose(player_index_file);
  fclose(new_player_index_file);
  remove(fn);
  rename(fn2, fn);
}


/* Deleting them */
/* This function does no checks. All check must be made by calling
   funcitons.  */

int delete_player(char *name) {
  int i;
  char fn[255];
  FILE *player_fl;
  struct player_index_element *new_player_table;

  /* Remove the player from the index */
  delete_player_from_index(name);

  get_filename(name, fn, PLR_FILE);
  /* Remove the player file */
  if (!(player_fl = fopen(fn, "r+"))) {
    sprintf(buf, "No player file for index name: %s", name);
    log(buf);
  } else {
    remove(fn);
  }
  /* Remove the object file */
  Crash_delete_file(name);

  /* create a new player table minus one record */
  if ( !(new_player_table = (struct player_index_element *)malloc(sizeof(struct player_index_element) * (top_of_p_table))) ) {
    perror("malloc failure");
    exit(1);
  }

  /* copy the old player table to the new one without the deleted player */
  for ( i = 0; i <= top_of_p_table; i++ ) {
    if( str_cmp(name, player_table[i].name) ) {
      new_player_table[i] = player_table[i];
    } else {
      free(player_table[i].name);
    }
  }
  top_of_p_table--;

  /* blow away the old table */
  free(player_table);

  /* assign the new one */
  player_table = new_player_table;
  /* Just incase the last player deletes $Mself */
  if (top_of_p_table == -1) {
    if(player_table[0].name) {
      free(player_table[0].name);
    }
    player_table = NULL;
  }
  return 1;
}


void free_player_index()
{
  int tp;

  if (!player_table)
    return;

  for (tp = 0; tp <= top_of_p_table; tp++)
    if (player_table[tp].name)
      free(player_table[tp].name);

  free(player_table);
  player_table = NULL;
  top_of_p_table = 0;
}


d1603 1
a1603 1
  mob_proto[i].mob_specials.ex_hitroll = BOUNDED(0, t[1], 20);
d1664 1
a1664 1
  mobproto->player_specials = dummy_mob; /* dummy player_specials for mobs */
d1718 1
a1718 1
  mob_proto[i].points.hitroll = BOUNDED(10, get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i),
a1882 2
  if (!dummy_mob)
    CREATE(dummy_mob, struct player_special_data, 1);
d2392 1
a2392 1
  mob->player_specials = dummy_mob;
a2895 228
/************************************************************************
 *  stuff related to the save/load player system			*
 ************************************************************************/


long get_id_by_name(char *name)
{
  int i;

  one_argument(name, arg);
  for (i = 0; i <= top_of_p_table; i++)
    if (!strcmp((player_table + i)->name, arg))
      return ((player_table + i)->id);

  return -1;
}


char *get_name_by_id(long id)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    if ((player_table + i)->id == id)
      return ((player_table + i)->name);

  return NULL;
}

/* Load a char, TRUE if loaded, FALSE if not */
int load_char(char *name, struct char_file_u *char_element) {
  int player_i;
  int find_name(char *name);
  FILE *player_fl;
  char fn[255], plr_name[MAX_NAME_LENGTH + 1];

  strcpy(plr_name, name);
  plr_name[0] = toupper(plr_name[0]);
  get_filename(plr_name, fn, PLR_FILE);

  if ((player_i = find_name(name)) >= 0) {
    if (!(player_fl = fopen(fn, "r+"))) {
      sprintf(buf, "No player file for index name: %s", name);
      log(buf);
      return -1;
    } else {
      fread(char_element, sizeof(struct char_file_u), 1, player_fl);
      fclose(player_fl);
      return player_i;
    }
  } else {
    return -1;
  }
}

/*
 * write the vital data of a player to the player file
 */

void save_player(struct char_data *ch) {
  struct char_file_u st;
  FILE *player_fl;
  char fn[255];
  int player_i = 0;

  if (IS_NPC(ch) || !ch->desc) {
    /* Added this if statement in an attempt to make link dead
       players save if they die. DCE 06-DEC-2001 */
    if (!IS_NPC(ch) && !ch->desc) {
      if ((player_i = load_char(ch->player.name, &st)) > -1) {
        char_to_store(ch, &st);
        save_char_file_u(st);
        sprintf(buf, "LINKDEATH: %s died while link dead.", GET_NAME(ch));
        log(buf);
      }
    }
    return;
  }

  char_to_store(ch, &st);
  get_filename(GET_NAME(ch), fn, PLR_FILE);

  if (!(player_fl = fopen(fn, "w"))) {
    sprintf(buf, "SYSERR: Unable to save player file for: %s", GET_NAME(ch));
    log(buf);
  } else {
    strncpy(st.host, ch->desc->host, HOST_LENGTH);
    st.host[HOST_LENGTH] = '\0';
    strcpy(st.pwd, GET_PASSWD(ch));
    fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
    fclose(player_fl);
  }
}

void save_char_file_u(struct char_file_u st) {
  int player_i;
  int find_name(char *name);
  FILE *player_fl;
  char fn[255];

  get_filename(st.name, fn, PLR_FILE);

  if((player_i = find_name(st.name)) >=0 ) {
    if (!(player_fl = fopen(fn, "w"))) {
      sprintf(buf, "SYSERR: Unable to save player file for: %s", st.name);
      log(buf);
    } else {
      fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
      fclose(player_fl);
    }
  }
}


/* copy data from the file structure to a char struct */
/* redone by proky...Banyal*/
void store_to_char(struct char_file_u * st, struct char_data * ch)
{
  int i;

  /* to save memory, only PC's -- not MOB's -- have player_specials */
  if (ch->player_specials == NULL)
    CREATE(ch->player_specials, struct player_special_data, 1);

  GET_SEX(ch) = st->sex;
  GET_CLASS(ch) = st->class;
  GET_RACE(ch) = st->race;
  GET_LEVEL(ch) = st->level;
  GET_RACE_ALIGN(ch) = st->race_align;
  ch->player.size = races[(int)ch->player.race].def_size;
  ch->guarded_by = NULL;
  ch->guarding = NULL;
  ch->player.short_descr = NULL;
  strcpy(GET_LDESC(ch), "\0");
  ch->player.title = str_dup(st->title);
  ch->player.prompt = str_dup(st->prompt);
  ch->player.description = str_dup(st->description);

  ch->player.hometown = st->hometown;
  ch->player.time.birth = st->birth;
  ch->player.time.played = st->played;
  ch->player.time.logon = time(0);

  ch->player.weight = st->weight;
  ch->player.height = st->height;
  ch->player.size = st->size;

  ch->natural_abils = st->abilities;
  ch->viewed_abils = st->abilities;
  scale_attribs(ch);  /* fix the ch->affected */

  ch->points = st->points;
  ch->char_specials.saved = st->char_specials_saved;
  ch->player_specials->saved = st->player_specials_saved;

  /*
   * Perception and hiddenness are stored in the char_specials struct
   * normally to make it less confusing in the code, but when the
   * player is saved, they're copied to the player specials to be
   * saved.  So we gotta copy them back here.
   * Same for rage.
   */
  ch->char_specials.perception = st->player_specials_saved.perception;
  ch->char_specials.hiddenness = st->player_specials_saved.hiddenness;
  ch->char_specials.rage = st->player_specials_saved.rage;

  /* fixes funky saving throws - nechtrous */
  GET_SAVE(ch, SAVING_PARA) = 0;
  GET_SAVE(ch, SAVING_ROD) = 0;
  GET_SAVE(ch, SAVING_PETRI) = 0;
  GET_SAVE(ch, SAVING_BREATH) = 0;
  GET_SAVE(ch, SAVING_SPELL) = 0;

  /* once the specials are read in, go ahead and set up the skills
   * and the class and race-related stuff */
  update_char(ch);

  if (ch->points.max_mana < 100)
    ch->points.max_mana = 100;

  ch->char_specials.carry_weight = 0;
  ch->char_specials.carry_items = 0;

  ch->points.armor = 100;
  ch->char_specials.hitgain = 0;
  ch->char_specials.managain = 0;

  ch->clan_snoop = CLAN_SNOOP_OFF;

  if (ch->player.name == NULL)
    CREATE(ch->player.name, char, strlen(st->name) + 1);
  strcpy(ch->player.name, st->name);
  strcpy(ch->player.passwd, st->pwd);

  /* Add all spell effects */
  for (i = 0; i < MAX_AFFECT; i++) {
    if (st->affected[i].type)
      affect_to_char(ch, &st->affected[i]);
  }

  /* Check to see that this person is in their clan list, if not, add */
  if (GET_CLAN(ch))
    clan_player_check(ch);

  /*
   * If you're not poisioned and you've been away for more than an hour of
   * real time, we'll set your HMV back to full.
   *
   * However, note that equipment/spell effects have not yet been applied,
   * so the true maximum may be higher than GET_MAX_XXX might say here.
   * To avoid REDUCING these values from their affected max to their
   * natural max, make sure GET_MAX_XXX is greater than the current value
   * before doing anything.
   */

  if (!IS_AFFECTED(ch, AFF_POISON) &&
      (((long) (time(0) - st->last_logon)) >= SECS_PER_REAL_HOUR)) {
    if (GET_HIT(ch) < GET_MAX_HIT(ch))
      GET_HIT(ch) = GET_MAX_HIT(ch);
    if (GET_MOVE(ch) < GET_MAX_MOVE(ch))
      GET_MOVE(ch) = GET_MAX_MOVE(ch);
    if (GET_MANA(ch) < GET_MAX_MANA(ch))
      GET_MANA(ch) = GET_MAX_MANA(ch);
  }

  init_mem_list(ch);
}				/* store_to_char */

d2953 1
a2953 1
  GET_MAX_HIT(ch) = GET_NATHPS(ch) + con_aff(ch) + count_applies(ch, APPLY_HIT);
a2990 195
/* copy vital data from a players char-structure to the file structure */
void char_to_store(struct char_data * ch, struct char_file_u * st)
{
  int i;
  struct affected_type *af;
  struct obj_data *char_eq[NUM_WEARS];
  sh_int hit = 0, move = 0;

  /* As we remove the effects, the player will lose fly even if entitled to it.
   * We'll save the position here so that flying can be restored after the
   * effects are restored. */
  int orig_pos = GET_POS(ch);

  /*
   * Make sure we don't set a players hit or move negative. This
   * is required because of +points items, possibly not being
   * re-equiped.
   */
  if (GET_HIT(ch) > 0)
    hit = 1;
  if (GET_MOVE(ch) > 0)
    move = 1;

  /* Remove everything that can put effects onto a character */

  for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      char_eq[i] = unequip_char(ch, i);
    else
      char_eq[i] = NULL;
  }

  for (af = ch->affected, i = 0; i < MAX_AFFECT; i++) {
    if (af) {
      st->affected[i] = *af;
      st->affected[i].next = 0;
      af = af->next;
    } else {
      st->affected[i].type = 0; /* Zero signifies not used */
      st->affected[i].duration = 0;
      st->affected[i].modifier = 0;
      st->affected[i].location = 0;
      st->affected[i].bitvector = 0;
      st->affected[i].bitvector2 = 0;
      st->affected[i].bitvector3 = 0;
      st->affected[i].next = 0;
    }
  }

  /*
   * remove the effects so that the raw values are stored; otherwise
   * the effects are doubled when the char logs back in.
   */

  while (ch->affected)
    affect_remove(ch, ch->affected);

  if ((i >= MAX_AFFECT) && af && af->next)
    log("SYSERR: WARNING: OUT OF STORE ROOM FOR AFFECTED TYPES!!!");

  st->birth = ch->player.time.birth;
  st->played = ch->player.time.played;
  st->played += (long) (time(0) - ch->player.time.logon);
  st->last_logon = time(0);

  ch->player.time.played = st->played;
  ch->player.time.logon = time(0);

  st->hometown = ch->player.hometown;
  st->weight = GET_WEIGHT(ch);
  st->height = GET_HEIGHT(ch);
  st->size = GET_SIZE(ch);
  st->sex = GET_SEX(ch);
  st->class = GET_CLASS(ch);
  st->race = GET_RACE(ch);
  st->race_align = GET_RACE_ALIGN(ch);
  st->level = GET_LEVEL(ch);
  st->abilities = ch->natural_abils;
  st->points = ch->points;
  st->char_specials_saved = ch->char_specials.saved;
  st->player_specials_saved = ch->player_specials->saved;

  /*
   * Perception and hiddenness are stored in the char_specials struct
   * to make it less confusing in the code, but we have to copy it to
   * the player specials when we want to save a player.
   * Same for rage.
   */
  st->player_specials_saved.perception = ch->char_specials.perception;
  st->player_specials_saved.hiddenness = ch->char_specials.hiddenness;
  st->player_specials_saved.rage = ch->char_specials.rage;

  save_mem_list(ch);

  st->points.armor = 100;

  /* Save hit and dam based on race. */
  apply_racial_bonus_hit_and_dam(ch);
  st->points.hitroll = GET_HITROLL(ch);
  st->points.damroll = GET_DAMROLL(ch);

  if (GET_TITLE(ch))
    strcpy(st->title, GET_TITLE(ch));
  else
    *st->title = '\0';

  if (GET_PROMPT(ch))
    strcpy(st->prompt, GET_PROMPT(ch));
  else
    *(st->prompt) = *str_dup(std_prompt);

  if (ch->player.description)
    strcpy(st->description, ch->player.description);
  else
    *st->description = '\0';

  strcpy(st->name, GET_NAME(ch));

  /* add spell and eq effects back in now */
  for (i = 0; i < MAX_AFFECT; i++) {
    if (st->affected[i].type)
      affect_to_char(ch, &st->affected[i]);
  }

  /* Add racial and class effects back */
  update_char(ch);

  for (i = 0; i < NUM_WEARS; i++) {
    if (char_eq[i])
      equip_char(ch, char_eq[i], i);
  }

  /* Restore original position. */
  GET_POS(ch) = orig_pos;
  affect_total(ch);

  /*
   * Make sure we don't set a players hit or move negative. This
   * is required because of +points items, possibly not being
   * re-equiped.
   */
  if (hit == 1 && GET_HIT(ch) <= 0)
    GET_HIT(ch) = 1;
  if (move == 1 && GET_MOVE(ch) <= 0)
    GET_MOVE(ch) = 1;
}  /* Char to store */


void save_etext(struct char_data * ch)
{
/* this will be really cool soon */

}


/* create a new entry in the in-memory index table for the player file */
/* Mommy make the bad man stop */
int create_entry(char *name)
{
  int i;
  char fn[255];
  FILE *player_file_index;

  sprintf(fn, "%s/%s", PLR_PREFIX, INDEX_FILE);

  if (!(player_file_index = fopen(fn, "a"))) {
    perror("fatal error opening playerfile index");
    exit(1);
  }

  fputs(name, player_file_index);
  fputs("\n", player_file_index);
  fclose(player_file_index);

  if (top_of_p_table == -1) {
    CREATE(player_table, struct player_index_element, 1);
    top_of_p_table = 0;
  } else if (!(player_table = (struct player_index_element *)
	       realloc(player_table, sizeof(struct player_index_element) *
		       (++top_of_p_table + 1)))) {
    perror("create entry");
    exit(1);
  }
  CREATE(player_table[top_of_p_table].name, char, strlen(name) + 1);

  /* copy lowercase equivalent of name to table field */
  for (i = 0; (*(player_table[top_of_p_table].name + i) = LOWER(*(name + i)));
       i++);

  return (top_of_p_table);
}




d3054 1
a3054 3
  if (ch->player_specials && !IS_NPC(ch)) {
    free(ch->player_specials);
  }
d3056 1
a3056 1
  for(tmp = ch->see_spell; tmp; tmp = tmp2) {
d3064 22
d3096 2
a3097 2
    /*    if (GET_LDESC(ch))
	  free(GET_LDESC(ch));*/
d3280 2
a3281 2
  if (GET_NATHPS(ch) <= 0)
    GET_NATHPS(ch) = GET_MAX_HIT(ch);
a3323 117
/* Initialize a player.
 *
 * This is called when character creation is confirmed.  In other words,
 * it makes a new player character Real.
 *
 * (And also when a player's name is changed, which is probably not
 * ideal. But player renaming is such a godawful mess and not very
 * common that I'll be leaving that for later.) */

void init_player(struct char_data * ch)
{
  int i, a_num, race = (int)(ch->player.race);

  /* create a player_special structure */
  if (ch->player_specials == NULL)
    CREATE(ch->player_specials, struct player_special_data, 1);

  /* *** if this is our first player --- he be God *** */

  if (top_of_p_table == 0) {
    GET_EXP(ch) = 7000000;
    GET_LEVEL(ch) = LVL_IMPL;

    ch->points.max_hit = 500;
    ch->points.max_mana = 100;
  }
  set_title(ch, "\0");

  ch->player.prompt = str_dup(std_prompt);
  ch->player.short_descr = NULL;
  strcpy(GET_LDESC(ch), "\0");
  ch->player.description = NULL;
  ch->player.time.birth = time(0);
  ch->player.time.played = 0;
  ch->player.time.logon = time(0);

  for (i = 0; i < MAX_TONGUE; i++)
    GET_TALK(ch, i) = 0;
  ch->player.size = races[race].def_size;
  ch->points.max_mana = 100;
  ch->points.mana = GET_MAX_MANA(ch);
  ch->points.hit = GET_MAX_HIT(ch);
  ch->points.max_move = natural_move(ch);
  ch->points.move = GET_MAX_MOVE(ch);
  ch->points.armor = 100;

  player_table[top_of_p_table].id = GET_IDNUM(ch) = ++top_idnum;

  for (i = 1; i <= TOP_SKILL; i++) {
    if (GET_LEVEL(ch) < LVL_IMPL)
      SET_SKILL(ch, i, 0);
    else
      SET_SKILL(ch, i, 1000);
  }

  ch->char_specials.saved.affected_by = 0;
  ch->char_specials.saved.affected_by2 = 0;
  ch->char_specials.saved.affected_by3 = 0;
  ch->player_specials->saved.chant = 0;

  for (i = 0; i < 5; i++)
    GET_SAVE(ch, i) = 0;

  GET_COND(ch, FULL) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 24);
  GET_COND(ch, THIRST) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 24);
  GET_COND(ch, DRUNK) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 0);

  for (i = 0; i < 4; i++)
    GET_INNATE_TIMER(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 0);

  GET_LOADROOM(ch) = NOWHERE;
  SPEAKING(ch) = LANG_COMMON;

  /* Zero all aliases. */
  for(a_num = 0; a_num < NUM_ALIASES; a_num++) {
    GET_ALIAS_TYPE(ch, a_num) = ALIAS_NONE;
  }

  /* Set default preferences */
  SET_BIT(PRF_FLAGS(ch), PRF_VICIOUS);        /* Finish off opponents */
  SET_BIT(PRF_FLAGS(ch), PRF_AUTOEXIT);       /* Always show room exits */
}

/* start_player()
 *
 * Sets a player's stats to be consistent with being level 1.
 * Should be called whenever a player becomes level 1, such as:
 *  -- when first created
 *  -- when the level is set to 1 by vengeful gods
 */
void start_player(struct char_data * ch)
{
  void set_innate(struct char_data * ch, char *arg);

  GET_LEVEL(ch) = 1;
  GET_EXP(ch) = 1;

  set_title(ch, "\0");
  ch->points.max_hit = 15;
  GET_NATHPS(ch) = 15;

  init_char(ch);
  advance_level(ch, TRUE);

  GET_HIT(ch) = GET_MAX_HIT(ch);
  GET_MANA(ch) = GET_MAX_MANA(ch);
  GET_MOVE(ch) = GET_MAX_MOVE(ch);

  GET_COND(ch, THIRST) = 24;
  GET_COND(ch, FULL) = 24;
  GET_COND(ch, DRUNK) = 0;

  ch->player.time.played = 0;
  ch->player.time.logon = time(0);

}

d3646 4
@


1.126
log
@Adding functions to free spell dams, extra descriptions, mobiles,
objects, rooms, zones, triggers, text files, players, and the
help table at program termination.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.125 2008/02/10 20:19:19 jps Exp myc $
a176 2
extern void save_mem_list(struct char_data *ch);
extern void assign_mem_list(struct char_data *ch);
d3354 1
a3354 1
  assign_mem_list(ch);
d3755 4
a3881 1
  extern void assign_mem_list(struct char_data *);
d3923 1
a3923 1
  assign_mem_list(ch);
d4399 5
@


1.125
log
@Further quest numbering tweaks/fixes.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.124 2008/02/10 19:43:38 jps Exp jps $
d42 1
d189 1
d621 11
d883 185
d1347 18
d2568 16
d3722 2
a3723 1
  free(ch->casting.misc);
d3738 2
a3739 1
  } else if ((i = GET_MOB_RNUM(ch)) > -1) {
d3755 8
a3763 1
  ch = NULL;  /*  hope this helps *pray* */
a3792 6
    /* Spell book Stuff --Fingon */
    if (obj->spell_book)
      for (this_book = obj->spell_book; this_book; this_book = next_book) {
	next_book = this_book->next;
	free(this_book);
      }
a3810 6
    /* Spell book Stuff --Fingon */
    if (obj->spell_book)
      for (this_book = obj->spell_book; this_book; this_book = next_book) {
	next_book = this_book->next;
	free(this_book);
      }
d3812 9
a3821 1
  obj = NULL; /* Added by Fingon */
d4398 3
@


1.124
log
@Subclass quests now store the target subclass as a quest variable rather
than as 3 bits in the quest id.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.123 2008/02/09 21:07:50 myc Exp jps $
a3870 2
  virtual &= ~SUBCLASS_BIT;

d4161 4
@


1.123
log
@Removing plr/mob casting flags and using an event flag instead.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.122 2008/02/09 04:27:47 myc Exp myc $
d3867 1
a3867 1
  if(!all_quests) {
d3871 1
a3871 5
   /* quick subclass quest check..if this is a subclass then we must ignore the
    * top 4 bits. It is a subclass if the top bit is set
    */
  if (virtual & SUBCLASS_BIT)
    virtual &= ~(SUBCLASS_MASK);
d4163 3
@


1.122
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.121 2008/02/09 03:04:23 myc Exp myc $
a3646 1
  REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
a3647 1
  REMOVE_BIT(PLR_FLAGS(ch), PLR_MEMMING);
d4167 3
@


1.121
log
@Commenting out some spell dam log messages that weren't needed at all.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.120 2008/01/30 19:20:57 myc Exp myc $
d41 1
d4169 3
@


1.120
log
@Removing the ch->regenerating field and replacing it with an event
flags member.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.119 2008/01/29 21:02:31 myc Exp myc $
d585 3
d596 1
d4168 4
@


1.119
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.118 2008/01/27 21:09:12 myc Exp myc $
d3677 2
a3678 1
  ch->regenerating = 0;
d4164 4
@


1.118
log
@Save rage for players in store_to_char and char_to_store.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.117 2008/01/27 13:41:28 jps Exp myc $
d40 1
a60 1
struct quest_info *all_quests = NULL;/* array of quests*/
a61 1
int max_quests = 0;
a72 1
int get_ac(int level, int race, int class);
a82 1
extern const char *iscommand[];
d122 1
a122 1
struct xname *xname_list=NULL;
a165 1
extern struct descriptor_data *descriptor_list;
a189 1
extern int rev_dir[];
a1461 45
void boot_quests()
{
	FILE *fl;
	char line[256];
	char *qname;
	int qnum,maxstage,numrec=0;

	max_quests=0;

	/* could use #defines for later*/
	if((fl = fopen(ALL_QUEST_FILE,"r")) == NULL)
	{
		fprintf(stderr,"Unable to find any quest data file (non-fatal)\r\n");
		return;
	}
	while (get_line(fl,line))
		numrec++;
	fclose(fl);
	CREATE(all_quests,struct quest_info,numrec);

	fl = fopen(ALL_QUEST_FILE,"r");
	while (get_line (fl,line))
	{
		CREATE(qname,char,30);
		if (sscanf(line,"%s %d %d",qname,&qnum,&maxstage) != 3)
		{
			fprintf(stderr,"Error in quest file line format(%s)\n",line);
			free(qname);
			break;
		}
		else
		{
			all_quests[max_quests].quest_name=qname;
			all_quests[max_quests].quest_id=qnum;
			all_quests[max_quests].maxstages=maxstage;

			max_quests++;
		}

	}
	fclose(fl);

}


a1532 1
  extern char *dirs[];
d4111 4
a4114 3
  if (search_block(arg, (char **) iscommand, TRUE) >= 0)
    return TRUE;
  if (search_block(arg, (char **) smart_ass, TRUE) >= 0)
d4163 3
@


1.117
log
@Moved species-related data to races.h and races.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.116 2008/01/27 09:45:41 jps Exp jps $
d3105 1
d3109 1
d3354 1
d3358 1
d4213 3
@


1.116
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.115 2008/01/26 14:26:31 jps Exp jps $
a48 1
void scale_attribs(struct char_data *ch);
a162 1
byte mob_find_size(int);
d312 1
a312 28

  switch(race)
    {
    case SPECIES_OTHER:
      sfactor = 80;
      break;
    case SPECIES_UNDEAD:
      sfactor = 110;
      break;
    case SPECIES_HUMANOID:
      sfactor = 100;
      break;
    case SPECIES_DRAGON:
      sfactor = 130;
      break;
    case SPECIES_DEMON:
      sfactor = 120;
      break;
    case SPECIES_GIANT:
      sfactor = 110;
      break;
    case SPECIES_GOBLIN:
      sfactor = 60;
      break;
    default:
      cfactor = 100;
      break;
    }
d340 1
a341 34
  switch(race)
    {
    case SPECIES_OTHER:
      sfactor = 110;
      break;
    case SPECIES_TROLL:
      sfactor = 120;
       break;
    case SPECIES_OGRE:
      sfactor = 130;
      break;

    case SPECIES_UNDEAD:
      sfactor = 100;
      break;
    case SPECIES_HUMANOID:
      sfactor = 100;
      break;
    case SPECIES_DRAGON:
      sfactor = 130;
      break;
    case SPECIES_DEMON:
      sfactor = 120;
      break;
    case SPECIES_GIANT:
      sfactor = 120;
      break;
    case SPECIES_GOBLIN:
      sfactor = 60;
      break;
    default:
      sfactor = 100;
      break;
    }
d401 1
a401 30

  switch(race) {
  case SPECIES_OTHER:
    sfactor = 120;
    break;
  case SPECIES_UNDEAD:
    sfactor = 100;
    break;
  case SPECIES_HUMANOID:
    sfactor = 100;
    break;
  case SPECIES_TROLL:
    sfactor = 110;
    break;
  case SPECIES_DRAGON:
    sfactor = 140;
    break;
  case SPECIES_DEMON:
    sfactor = 120;
    break;
  case SPECIES_GIANT:
    sfactor = 120;
    break;
  case SPECIES_GOBLIN:
    sfactor = 60;
    break;
  default:
    sfactor = 100;
    break;
  }
d471 1
a471 33

  switch(race) {
  case SPECIES_OTHER:
    sfactor = 80;
    break;
  case SPECIES_UNDEAD:
    sfactor = 110;
    break;
  case SPECIES_OGRE:
    sfactor = 120;
    break;
  case SPECIES_TROLL:
    sfactor = 110;
    break;
  case SPECIES_HUMANOID:
    sfactor = 100;
    break;
  case SPECIES_DRAGON:
    sfactor = 140;
    break;
  case SPECIES_DEMON:
    sfactor = 120;
    break;
  case SPECIES_GIANT:
    sfactor = 100;
    break;
  case SPECIES_GOBLIN:
    sfactor = 60;
    break;
  default:
    sfactor = 100;
    break;
  }
d537 1
a538 30
  switch(mob_proto[i].player.race)
  {
  case SPECIES_OTHER:
    sfactor = 75;
    break;
  case SPECIES_UNDEAD:
    sfactor = 40;
    break;
  case SPECIES_HUMANOID:
    sfactor = 100;
    break;
  case SPECIES_DRAGON:
    sfactor = 500;
    break;
  case SPECIES_DEMON:
    sfactor = 150;
    break;
  case SPECIES_GIANT:
    sfactor = 125;
    break;
  case SPECIES_GOBLIN:
    sfactor = 75;
    break;
  case SPECIES_ANIMAL:
    sfactor = 0;
    break;
  default:
    sfactor = 75;
    break;
  }
d563 1
a564 36
  switch(race)
    {
    case SPECIES_OTHER:
      sfactor = 105;
      break;
    case SPECIES_UNDEAD:
      sfactor = 110;
      break;
    case SPECIES_HUMANOID:
      sfactor = 60;
      break;
    case SPECIES_DRAGON:
      sfactor = 140;
      break;
    case SPECIES_DEMON:
      sfactor = 120;
      break;
    case SPECIES_GIANT:
      sfactor = 120;
      break;
    case SPECIES_GOBLIN:
      sfactor = 90;
      break;
    case SPECIES_ANIMAL:
      sfactor = 65;
      break;
    case SPECIES_TROLL:
      sfactor = 100;
      break;
    case SPECIES_OGRE:
      sfactor = 90;
      break;
    default:
      sfactor = 100;
      break;
    }
a565 10

/*  if (level < 30)
    ac = 90;
  else
    ac = 50;

  ac = ac - (2 * level);
  sfactor = (int)((sfactor + cfactor)/2);

  ac = (int)((float)((sfactor/100.0) * ac));*/
a570 4




d574 2
a575 3
  The olc code is in sdedit.c

  Proky*/
d1717 1
a1717 1
    mob_proto[i].player.race = 17;t[4] = 17;
d1719 1
a1719 1
    mob_proto[i].player.size = mob_find_size(17);
a2439 1
  extern void scale_attribs(struct char_data *ch);
a3265 36

const int attrib_scales[SPECIES_NUMBER][6] = {
               /* STR DEX INT WIS CON CHA */
 /* Human     */ { 72, 72, 72, 72, 72, 72 },
 /* Elf       */ { 64, 80, 88, 86, 64, 78 },
 /* Gnome     */ { 64, 76, 88, 84, 68, 76 },
 /* Dwarf     */ { 84, 76, 64, 86, 84, 68 },
 /* Troll     */ { 92, 72, 56, 56, 92, 64 },
 /* Drow Elf  */ { 64, 80, 88, 80, 64, 72 },
 /* Duergar   */ { 84, 76, 68, 72, 84, 64 },
 /* Ogre      */ { 96, 64, 52, 60,100, 60 },
 /* Orc       */ { 72, 72, 72, 72, 72, 72 },
 /* Half Elf  */ { 68, 76, 76, 76, 68, 78 },
 /* Barbarian */ { 88, 68, 60, 60, 88, 64 },
 /* Halfling  */ { 68, 96, 80, 80, 64, 76 },
 /* Undead    */ { 80, 80, 72, 72, 64, 64 },
 /* Humanoid  */ { 72, 72, 72, 72, 72, 72 },
 /* Animal    */ { 72, 72, 72, 72, 72, 72 },
 /* Dragon    */ {100, 72,100, 72, 72,100 },
 /* Giant     */ {100, 72, 44, 64, 80, 72 },
 /* Other     */ { 72, 72, 72, 72, 72, 72 },
 /* Goblin    */ { 76, 72, 64, 72, 84, 64 },
 /* Demon     */ { 80,100, 68, 68, 58, 58 },
};

/* This scales the natural values for the various races (replaces load_results) */
/* this now handles all player/mob races */
void scale_attribs(struct char_data *ch) {
  GET_AFFECTED_STR(ch) = (GET_VIEWED_STR(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_STR - 1]) / 100;
  GET_AFFECTED_DEX(ch) = (GET_VIEWED_DEX(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_DEX - 1]) / 100;
  GET_AFFECTED_INT(ch) = (GET_VIEWED_INT(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_INT - 1]) / 100;
  GET_AFFECTED_WIS(ch) = (GET_VIEWED_WIS(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_WIS - 1]) / 100;
  GET_AFFECTED_CON(ch) = (GET_VIEWED_CON(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_CON - 1]) / 100;
  GET_AFFECTED_CHA(ch) = (GET_VIEWED_CHA(ch) * attrib_scales[(int) GET_RACE(ch)][APPLY_CHA - 1]) / 100;
}

d4209 4
@


1.115
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.114 2008/01/22 09:04:17 jps Exp jps $
d75 1
a75 1
int get_ac(int level, int race, int class);  
d94 1
a94 1
#ifdef DEV 
d160 1
a160 1
long get_set_exp(int level, int race, int class, int zone); 
d162 1
a162 1
sbyte get_set_hd(int level, int race, int class, int state); 
d236 1
a236 1
  
d238 1
a238 1
  
d292 1
a292 1
  
d297 1
a297 1
long get_set_exp(int level, int race, int class, int zone)  
d299 1
a299 1
{ 
d310 1
a310 1
  
d313 3
a315 23
  switch(class) 
    {
    case MCLASS_VOID:
      cfactor = 80;
      break;
    case MCLASS_SORCERER:
      cfactor = 120;
      break;
    case MCLASS_CLERIC:
      cfactor = 100;
      break;
    case MCLASS_WARRIOR:
      cfactor = 100;
      break;
    case MCLASS_THIEF:
      cfactor = 100;
      break;
    default:
      cfactor = 100;
      break;
    }
  
  switch(race) 
d342 1
a342 1
  
d348 1
a348 1
  
d354 1
a354 1
sh_int get_set_hit(int level, int race, int class, int state)  
d356 1
a356 1
{ 
d365 6
a370 31
  
  /*
    The cfactor is the factor of class to adjust exp number is percentage
    100 being standard no change*/
  
  
  
   
  switch(class) 
    {
    case MCLASS_VOID:
      cfactor = 100;
      break;
    case MCLASS_SORCERER:
       cfactor = 80;
       break;
    case MCLASS_CLERIC:
      cfactor = 80;
      break;
    case MCLASS_WARRIOR:
      cfactor = 120;
      break;
    case MCLASS_THIEF:
      cfactor = 90;
      break;
    default:
      cfactor = 100;
      break;
    }
  
  switch(race) 
d381 1
a381 1
      
d408 1
a408 1
  
d411 1
a411 1
  
d414 1
a414 1
  
d417 1
a417 1
  if (level <=5) 
d433 4
a436 4
    face = 200; 
  } 
  
  
d440 2
a441 2
   
   
d446 2
a447 2
   
   
d451 1
a451 1
sbyte get_set_hd(int level, int race, int class, int state)  
d453 1
a453 1
{ 
d458 2
a459 2
  
  
d462 2
a463 21
  switch(class) {
  case MCLASS_VOID:
    cfactor = 130;
    break;
  case MCLASS_SORCERER:
    cfactor = 80;
    break;
  case MCLASS_CLERIC:
    cfactor = 80;
    break;
  case MCLASS_WARRIOR:
    cfactor = 120;
    break;
  case MCLASS_THIEF:
    cfactor = 100;
    break;
  default:
    cfactor = 100;
    break;
  }
  
d493 1
a493 1
  
d512 2
a513 2
    
    
d517 2
a518 2
    
    
d520 1
a520 1
  
d529 1
a529 1
    
d532 1
a532 1
    
d535 1
a535 1
    
d540 3
a542 3
  
  
  
d550 1
a550 1
     
d552 1
a552 1
{ 
d557 2
a558 2
  
  
d561 2
a562 21
  switch(class) {
  case MCLASS_VOID:
    cfactor = 100;
    break;
  case MCLASS_SORCERER:
    cfactor = 60;
    break;
  case MCLASS_CLERIC:
    cfactor = 70;
    break;
  case MCLASS_WARRIOR:
    cfactor = 120;
    break;
  case MCLASS_THIEF:
    cfactor = 100;
    break;
  default:
    cfactor = 100;
    break;
  }
  
d595 1
a595 1
  
d600 1
a600 1
    
d603 1
a603 1
    
d606 1
a606 1
    
d609 1
a609 1
    
d621 1
a621 1
    
d628 1
a628 1
    
d631 2
a632 2
  
  
d641 1
a641 1
int get_copper(int i)  
d643 1
a643 1
{ 
d649 1
a649 1
  for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) 
d655 2
a656 2
  
  
d659 3
a661 23
  switch(mob_proto[i].player.class) 
  {
  case MCLASS_VOID:
    cfactor = 75;
    break;
  case MCLASS_SORCERER:
    cfactor = 100;
    break;
  case MCLASS_CLERIC:
    cfactor = 100;
    break;
  case MCLASS_WARRIOR:
    cfactor = 100;
    break;
  case MCLASS_THIEF:
    cfactor = 100;
    break;
  default:
    cfactor = 100;
    break;
  }
  
  switch(mob_proto[i].player.race) 
d693 1
a693 1
  
d697 1
a697 1
  
d699 1
a699 1
  
d704 1
a704 1
int get_ac(int level, int race, int class)  
d706 1
a706 1
{ 
d711 1
a711 1
  
d714 1
a714 21
  switch(class) 
    {
    case MCLASS_VOID:
      cfactor = 105;
      break;
    case MCLASS_SORCERER:
      cfactor = 75;
      break;
    case MCLASS_CLERIC:
      cfactor = 100;
      break;
    case MCLASS_WARRIOR:
      cfactor = 120;
      break;
    case MCLASS_THIEF:
      cfactor = 80;
      break;
    default:
      cfactor = 100;
      break;
    }
d716 1
a716 1
  switch(race) 
d758 1
a758 1
  
d761 1
a761 1
  
d776 1
a776 1
  
d778 1
a778 1
void boot_spell_dams() 
d808 1
a808 1
	  sscanf(line, "%hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd", 
d815 1
a815 1
	  
d839 2
a840 2
  
  if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d842 1
a842 1
      if (errno != ENOENT) 
d846 2
a847 2
        } 
      else 
d851 1
a851 1
	  if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d858 1
a858 1
  
d903 1
a903 1
  
d922 1
a922 1
  
d925 1
a925 1
  
d928 1
a928 1
  
d947 1
a947 1
  
d950 1
a950 1
  
d953 2
a954 2
  
  
d967 1
a967 1
  
d991 1
a991 1
  
d1003 1
a1003 1
  
d1021 1
a1021 1
  
d1025 1
a1025 1
  
d1037 1
a1037 1
  
d1052 1
a1052 1
  
d1057 1
a1057 1
  
d1059 1
a1059 1
  Corpse_boot();  
d1062 1
a1062 1
  
d1064 1
a1064 1
  
d1067 1
a1067 1
  
d1077 1
a1077 1
  
d1108 1
a1108 1
  
d1110 1
a1110 1
  
d1117 1
a1117 1
    log("                    - Winter");      
d1129 1
a1129 1
    log("                    - Summer"); 
d1135 1
a1135 1
    log("                    - Autumn");  
d1137 1
a1137 1
  
d1142 1
a1142 1
  log("Initializing weather.");  
d1173 1
a1173 1
  }  
d1176 1
a1176 1
  
d1186 1
a1186 1
  
d1217 1
a1217 1
  
d1229 1
a1229 1
  
d1241 1
a1241 1
  
d1264 1
a1264 1
  
d1283 1
a1283 1
      fputs(plr_name, new_player_index_file);      
d1318 2
a1319 2
  Crash_delete_file(name);    
  
d1335 1
a1335 1
  
d1347 1
a1347 1
  }  
d1356 1
a1356 1
  
d1360 1
a1360 1
  
d1371 1
a1371 1
  
d1414 1
a1414 1
  
d1433 1
a1433 1
  
d1441 1
a1441 1
  
d1443 1
a1443 1
  
d1492 1
a1492 1
    
d1496 1
a1496 1
  
d1527 1
a1527 1
    
d1566 1
a1566 1
  
d1576 1
a1576 1
  
d1599 1
a1599 1
  
d1621 1
a1621 1
  
d1626 1
a1626 1
  
d1629 1
a1629 1
  
d1631 1
a1631 1
  
d1633 1
a1633 1
  
d1762 1
a1762 1
  
d1797 1
a1797 1
        }    
d1808 1
a1808 1
  
d1869 1
a1869 1
  
d1872 2
a1873 2
  
  
d1876 1
a1876 1
  
d1880 1
a1880 1
  
d1884 1
a1884 1
  
d1888 1
a1888 1
  
d1892 1
a1892 1
  
d1903 1
a1903 1
      
d1905 3
a1907 3
  
  
  
d1918 1
a1918 1
    mob_proto[i].player.class = 13;t[3] = 13;
d1926 2
d1933 1
a1933 1
  
d1940 1
a1940 1
  
d1954 1
a1954 1
  
d1957 1
a1957 1
  
d1967 3
a1969 3
  
  
  
d1972 3
a1974 3
  GET_EXP(mob_proto + i) += GET_EX_EXP(mob_proto + i); 
  
  mob_proto[i].points.mana = get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 2);  
d1979 1
a1979 1
  
d1981 1
a1981 1
  mob_proto[i].points.damroll	+= mob_proto[i].mob_specials.ex_damroll; 
d1986 1
a1986 1
  
d1991 1
a1991 1
  
d1998 1
a1998 1
  
d2003 3
a2005 3
  
  
  
d2008 1
a2008 1
  
d2011 1
a2011 1
  
d2038 1
a2038 1
  
d2040 1
a2040 1
  
d2045 1
a2045 1
  
d2099 1
a2099 1
  }    
d2108 1
a2108 1
  
d2115 1
a2115 1
  
d2123 1
a2123 1
  
d2125 1
a2125 1
  
d2135 1
a2135 1
  
d2156 1
a2156 1
  
d2168 1
a2168 1
  
d2177 1
a2177 1
  
d2191 1
a2191 1
  
d2199 2
a2200 2
  
  
d2202 1
a2202 1
  
d2205 1
a2205 1
  
d2207 1
a2207 1
  
d2216 2
a2217 2
  
  
d2290 1
a2290 1
  
d2295 1
a2295 1
  
d2312 1
a2312 1
  
d2325 1
a2325 1
  
d2342 1
a2342 1
  
d2353 1
a2353 1
  
d2360 1
a2360 1
  
d2362 1
a2362 1
  
d2367 1
a2367 1
  
d2370 1
a2370 1
  
d2408 1
a2408 1
      
d2417 1
a2417 1
      
d2441 1
a2441 1
  
d2443 1
a2443 1
  
d2448 1
a2448 1
  
d2454 1
a2454 1
  
d2456 1
a2456 1
  
d2462 1
a2462 1
  
d2467 1
a2467 1
  
d2470 1
a2470 1
	     &Z.reset_mode, &Z.zone_factor, &Z.hemisphere, &Z.climate) != 4) 
d2481 1
a2481 1
    
d2484 1
a2484 1
    
d2486 1
a2486 1
    
d2510 1
a2510 1
    
d2512 1
a2512 1
    
d2514 1
a2514 1
      fprintf(stderr, "Format error in %s, line %d: '%s'\n", zname, 
d2521 1
a2521 1
  
d2535 1
a2535 1
  
d2545 1
a2545 1
  
d2561 1
a2561 1
    
d2565 1
a2565 1
    
d2567 1
a2567 1
    
d2578 1
a2578 1
    
d2593 1
a2593 1
  
d2596 1
a2596 1
  
d2610 1
a2610 1
  
d2627 1
a2627 1
  
d2656 1
a2656 1
    mob->points.max_hit = number(mob->points.hit, mob->points.mana);    
d2662 1
a2662 1
  
d2666 1
a2666 1
  
d2677 1
a2677 1
  if (type == VIRTUAL) 
d2679 1
a2679 1
    if ((i = real_mobile(nr)) < 0) 
d2684 1
a2684 1
  } 
d2698 1
a2698 1
  
d2706 1
a2706 1
  
d2713 1
a2713 1
  
d2723 1
a2723 1
  
d2735 1
a2735 1
  
d2741 1
a2741 1
  
d2765 1
a2765 1
  
d2773 1
a2773 1
    
d2775 1
a2775 1
    
d2802 2
a2803 2
  
  
d2825 1
a2825 1
      
d2834 1
a2834 1
  
d2837 1
a2837 1
  
d2899 1
a2899 1
    
d2902 1
a2902 1
    
d2907 1
a2907 1
      
d2915 1
a2915 1
      
d2925 1
a2925 1
      
d2927 2
a2928 2
      
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2931 1
a2931 1
	  if (ZCMD.arg3 >= 0) 
d2943 2
a2944 2
	    } 
	  else 
d2958 1
a2958 1
	} 
d2962 1
a2962 1
      
d2964 1
a2964 1
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2969 1
a2969 1
	      if (!(obj_to = get_obj_num(ZCMD.arg3))) 
d2988 1
a2988 1
      
d2990 1
a2990 1
      if (!mob) 
d2996 1
a2996 1
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d3001 1
a3001 1
	    char error_buf[2048]; 
d3004 3
a3006 3
		    GET_NAME(mob), GET_MOB_VNUM(mob), 
		    mob->in_room, 
		    obj->short_description, GET_OBJ_VNUM(obj)); 
d3020 1
a3020 1
	} 
d3024 1
a3024 1
      
d3026 1
a3026 1
      if (!mob) 
d3031 1
a3031 1
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d3033 1
a3033 1
	  if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS) 
d3036 2
a3037 2
	    } 
	  else 
d3042 1
a3042 1
		char error_buf[2048]; 
d3045 3
a3047 3
			GET_NAME(mob), GET_MOB_VNUM(mob), 
			mob->in_room, 
			obj->short_description, GET_OBJ_VNUM(obj)); 
d3066 1
a3066 1
      
d3074 2
a3075 2
      
      
d3138 1
a3138 1
  
d3143 1
a3143 1
  
a3147 427
#define MOB_MENTAL3    33
void reset_mob(struct char_data *mob, int caster_level, int i, int type, struct obj_data * obj)
{
  int cfactor = 100;
  int sfactor = 100;
  int tfactor = 100;
  int mobfactor = 100;
  int corpsefactor = 100;
  int decrease = 100;
  sh_int xmain  = 0;
  int corpse_level = 0;
  sh_int face = 0;/*this function was written by Proky, what it does is
		    reset a mobs "statistics"
		    to suite the level of the owner (if called because a mob summmons)*/
  if (obj)
    corpse_level = CORPSE_LEVEL(obj);
  if (!corpse_level)
    {/*if this is case then not usinga  corpse*/
      corpse_level = MIN(70, (caster_level + (5 - number(0, 7))));
    }
  else
    {/*involve the casters level here */
      if ((caster_level - corpse_level) < 1)  
	corpse_level = (MIN(70, ((corpse_level - number(1, 3)))));
      else if ((caster_level - corpse_level) < 10)  
	corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 2)));
      else if ((caster_level - corpse_level) < 20)
	corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 5)));
      else if ((caster_level - corpse_level) < 30)
	corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 8)));
      else
	corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 15)));
    }
  i = GET_MOB_RNUM(mob);
  /*mob exp cut down giving it the exp of a mob half its level */
  GET_LEVEL(mob) = corpse_level;
  GET_EXP(mob) = (long)(get_set_exp(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), GET_ZONE(mob))/2);
  GET_EXP(mob) = MAX(0, (GET_EXP(mob) + GET_EX_EXP(mob_proto + i))); 
  
  /*mob bonus*/
  switch(GET_CLASS(mob)) 
    {
    case MCLASS_VOID:
      cfactor = 100;
      break;
    case MCLASS_SORCERER:
      cfactor = 90;
      break;
    case MCLASS_CLERIC:
      cfactor = 100;
      break;
    case MCLASS_WARRIOR:
      cfactor = 110;
      break;
    case MCLASS_THIEF:
      cfactor = 80;
      break;
    default:
      cfactor = 100;
      break;
    }
  switch(GET_MOB_VNUM(mob))
    {
    case MOB_ZOMBIE:
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2)); 
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy (GET_LDESC(mob), buf);
	      }
	  }
      mobfactor = 100;
      break;
    case  (MOB_ZOMBIE + 1):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy(GET_LDESC(mob), buf);    
		
	      }
	  }
      
      mobfactor =  90;
      break;
    case(MOB_ZOMBIE  + 2):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy(GET_LDESC(mob), buf);    
		
	      }
	  }
      
      mobfactor = 100;
      break;
    case  (MOB_ZOMBIE  +  3):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy(GET_LDESC(mob), buf);    
		
	      }
	  }
      
      mobfactor = 140;
      break;
    case (MOB_ZOMBIE+ 4):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy(GET_LDESC(mob), buf);    
		
	      }
	  }
      
      mobfactor = 75;
      break;
    case (MOB_ZOMBIE +  5):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {
	    if(GET_LDESC(mob))
	      {
		strcpy (buf, "");
		strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
		strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
		strcat(buf, ", &0stands here.\r\n");
		strcpy(GET_LDESC(mob), buf);    
		
	      }
	  }
      
      mobfactor =  120;
      break;
    case (4):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {  if(GET_LDESC(mob))
	    {
	      strcpy (buf, "");
	      strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
	      strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
	      strcat(buf, ", &0stands here.\r\n");
	      strcpy(GET_LDESC(mob), buf);
	    }}mobfactor = 200;
      break;
      
    case (5):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {  if(GET_LDESC(mob))
	    {
	      strcpy (buf, "");
	      strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
	      strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
	      strcat(buf, ", &0stands here.\r\n");
	      strcpy(GET_LDESC(mob), buf);
	    }}mobfactor = 180;
      break;
      
    case (6):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {  if(GET_LDESC(mob))
	    {
	      strcpy (buf, "");
	      strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
	      strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
	      strcat(buf, ", &0stands here.\r\n");
	      strcpy(GET_LDESC(mob), buf);
	    }}mobfactor = 170;
      break;
      
    case (7):
      if (obj)
	if (GET_OBJ_MOB_FROM(obj))
	  {  if(GET_LDESC(mob))
	    {
	      strcpy (buf, "");
	      strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
	      strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
	      strcat(buf, ", &0stands here.\r\n");
	      strcpy(GET_LDESC(mob), buf);
	    }}mobfactor = 160;
      break;
      
    case (29):
      mobfactor = 180;
      break;
    case (30):
      mobfactor = 150;
      break;
    case (MOB_MENTAL3 + 0):
      mobfactor = 130;
      break;
      
    case (MOB_MENTAL3 + 1):
      mobfactor = 130;
      break;
      
    case (MOB_MENTAL3 + 2):
      mobfactor = 120;
      break;
    case (MOB_MENTAL3 + 3):
      mobfactor = 120;
      break;
      
    default:
      mobfactor =  100;
      break;
      
    }
  switch(GET_RACE(mob)) 
    {
    case SPECIES_OTHER:
      sfactor = 100;
      break;
    case SPECIES_UNDEAD:
      sfactor = 100;
      break;
    case SPECIES_HUMANOID:
      sfactor = 100;
      break;
    case SPECIES_DRAGON:
      sfactor = 130;
      break;
    case SPECIES_DEMON:
      sfactor = 120;
      break;
    case SPECIES_GIANT:
      sfactor = 110;
      break;
    case SPECIES_GOBLIN:
      sfactor = 70;
      break;
    default:
      sfactor = 100;
      break;
    }
  switch(type) 
    {
    case SPELL_SUMMON_DRACOLICH:
      tfactor = 120;
      break;
    case SPELL_SUMMON_ELEMENTAL:
      tfactor = 100;
      break;
    case SPELL_SUMMON_GREATER_DEMON:
      tfactor = 140;
      break;
    case SPELL_SUMMON_DEMON:
      tfactor = 110;
      break;
    case SPELL_ANIMATE_DEAD:
      tfactor = 100;
      break;
    default:
      tfactor = 100;
      break;
    }
  /*corpse species bonus*/
  if (obj)
    if (GET_OBJ_MOB_FROM(obj))
      {
	switch(mob_proto[GET_OBJ_MOB_FROM(obj)].player.race)
	  {
	  case SPECIES_HUMAN:
	    corpsefactor = 100;
	    break;
	  case SPECIES_OTHER:
	    corpsefactor = 100;
	    break;
	  case SPECIES_UNDEAD:
	    corpsefactor = 100;
	    break;
	  case SPECIES_HUMANOID:
	    corpsefactor = 100;
	    break;
	  case SPECIES_DRAGON:
	    corpsefactor = 120;
	    break;
	  case SPECIES_DEMON:
	    corpsefactor = 110;
	    break;
	  case SPECIES_GIANT:
	    corpsefactor = 110;
	    break;
	  case SPECIES_GOBLIN:
	    corpsefactor = 75;
	    break;
	  default:
	    corpsefactor = 100;
	    break;
	  }		
      }
  /*fix factors*/
  tfactor = ((int)((sfactor + tfactor + cfactor)/3));
  
  if (GET_LEVEL(mob) < 40)
    xmain = (sh_int)((GET_LEVEL(mob) * (int)(GET_LEVEL(mob)/5))); 	/*50 and under equation*/
  else
    xmain =  320;
  
  if (GET_LEVEL(mob) <=10) 
    face = 10;
  else if (GET_LEVEL(mob) <=10) 
    {
      face = 15;
    }
  else if (GET_LEVEL(mob) <= 20) 
    {
      face = 15;
    }
  else if (GET_LEVEL(mob) <= 30)  
    {
      face = 20;
    }
  else if (GET_LEVEL(mob) <= 40)
    {
      face = 25;
    } 
  else if (GET_LEVEL(mob) <= 50)
    {
      face = 30;
    }
  else if (GET_LEVEL(mob) <= 60)
    {
      face = 35;
    }
  else
    face = 40;
  if (mobfactor > 100)
    face = (sh_int) (((float)mobfactor/100)* face);
  
  xmain = (sh_int)  (xmain + (number(1, face) * 10));
  /*finally taking the factors into account*/
  xmain = (sh_int) (((float)corpsefactor/100)*((float)tfactor/100) *
		   xmain);
  if (mobfactor < 100)
    xmain = (sh_int) (((float)mobfactor/100)* xmain);
  /*hp factors taken into account*/
  
  GET_MAX_HIT(mob)= MAX(1, (xmain  + GET_MOVE(mob_proto +
					     i)));
  GET_HIT(mob) = GET_MAX_HIT(mob);
  
  /* I decrease all these values by a bit because they do rock to much*/
  decrease = 90;
  if (GET_LEVEL(mob) < 20)
    decrease = 90;
  else if (GET_LEVEL(mob) < 30)
    decrease = 75;
  else if (GET_LEVEL(mob) < 40)
    decrease = 60;
  else if (GET_LEVEL(mob) < 50)
    decrease = 55;
  else if (GET_LEVEL(mob) < 55)
    decrease = 50;
  else
    decrease = 50;
  GET_DAMROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);
  GET_DAMROLL(mob) = MAX(1, (GET_DAMROLL(mob) + mob_proto[i].mob_specials.ex_damroll)); 
  GET_DAMROLL(mob) = (sbyte)(GET_DAMROLL(mob)*((int)corpsefactor/100));
  /*hit roll is fine dont need to decrease this*/
  decrease = 100;
  GET_HITROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1))/100);
  GET_HITROLL(mob) = MAX(1, (GET_HITROLL(mob) + mob_proto[i].mob_specials.ex_hitroll));
  GET_HITROLL(mob) = BOUNDED(10, (sbyte)(GET_HITROLL(mob)*((int)corpsefactor/100)), 60);
  /*dice value should be decreased*/
  decrease = 100;
  if (GET_LEVEL(mob) < 20)
    decrease = 100;
  else if (GET_LEVEL(mob) < 30)
    decrease = 80;
  else if (GET_LEVEL(mob) < 40)
    decrease = 65;
  else if (GET_LEVEL(mob) < 50)
    decrease = 60;
  else if (GET_LEVEL(mob) < 55)
    decrease = 55;
  else
    decrease = 53;
  
  GET_NDD(mob) = (int)(decrease*(get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);			
  GET_NDD(mob) = MAX(1, (GET_NDD(mob) + mob_proto[i].mob_specials.ex_damnodice));
  GET_NDD(mob) = (int)(GET_NDD(mob)*((int)corpsefactor/100));
  GET_SDD(mob) = get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1);
  GET_SDD(mob) = MAX(1, (GET_SDD(mob) + mob_proto[i].mob_specials.ex_damsizedice));
  GET_SDD(mob) = (int)(GET_SDD(mob)*((int)corpsefactor/100));
  GET_PLAT(mob) = 0;
  GET_GOLD(mob) = 0;
  GET_SILVER(mob) = 0;
  GET_COPPER(mob) = 0;
  
  
}


d3156 1
a3156 1
  
d3161 1
a3161 1
  
d3169 1
a3169 1
  
d3173 1
a3173 1
  
d3197 1
a3197 1
    } 
d3249 1
a3249 1
  
d3267 1
a3267 1
  
d3271 1
a3271 1
  
d3285 1
a3285 1
  
d3290 1
a3290 1
  
d3318 1
a3318 1
  
d3325 1
a3325 1
  
d3328 1
a3328 1
  
d3332 1
a3332 1
  
d3334 1
a3334 1
  
d3339 1
a3339 1
  
d3345 1
a3345 1
  
d3349 1
a3349 1
  
d3370 1
a3370 1
  
d3400 2
a3401 2
  int bonus = 0;   
  
d3416 1
a3416 1
  
d3527 1
a3527 1
  
d3529 1
a3529 1
  
d3536 1
a3536 1
  
d3558 1
a3558 1
  
d3561 1
a3561 1
  
d3564 1
a3564 1
  
d3569 1
a3569 1
  
d3596 1
a3596 1
  
d3608 1
a3608 1
  
d3613 1
a3613 1
  
d3618 1
a3618 1
  
d3647 1
a3647 1
    GET_MOVE(ch) = 1;  
d3654 1
a3654 1
  
d3667 1
a3667 1
  
d3676 1
a3676 1
  
d3680 1
a3680 1
  } else if (!(player_table = (struct player_index_element *) 
d3687 1
a3687 1
  
d3691 1
a3691 1
  
d3709 1
a3709 1
  
d3711 1
a3711 1
  
d3728 1
a3728 1
    
d3730 1
a3730 1
    
d3740 1
a3740 1
  
d3747 1
a3747 1
  
d3801 1
a3801 1
  
d3874 1
a3874 1
  
d3877 1
a3877 1
  
d3895 1
a3895 1
  
d3902 2
a3903 2
   *  and crashing the mud.  Typed by Zzur, told to type by Gurlaek  
   *  10/4/99 
d3905 1
a3905 1
  while (fgets(tmp, READ_SIZE, fl)) {    
d3907 1
a3907 1
    strcat(tmp, "\r\n");  
d3914 1
a3914 1
  fclose(fl);  
d3977 1
a3977 1
  
d3984 1
a3984 1
  
d3987 2
a3988 2
  
  
d3998 1
a3998 1
  
d4016 1
a4016 1
  
d4020 1
a4020 1
  
d4022 1
a4022 1
  
d4026 1
a4026 1
    
d4031 1
a4031 1
  
d4039 1
a4039 1
  
d4055 1
a4055 1
    else   
d4058 1
a4058 1
  
d4066 1
a4066 1
  
d4070 1
a4070 1
  
d4073 1
a4073 1
  
d4100 1
a4100 1
  
d4104 1
a4104 1
  
d4111 1
a4111 1
  
d4115 1
a4115 1
  
d4125 1
a4125 1
  
d4128 1
a4128 1
  
d4132 1
a4132 1
    
d4148 1
a4148 1
  
d4152 1
a4152 1
  
d4161 1
a4161 1
  
d4165 1
a4165 1
    
d4181 1
a4181 1
  
d4184 1
a4184 1
  
d4188 1
a4188 1
    
d4207 1
a4207 1
  
d4210 1
a4210 1
  
d4214 1
a4214 1
    
d4234 1
a4234 1
  
d4238 1
a4238 1
  
d4240 1
a4240 1
  
d4248 2
a4249 2
  
  
d4254 1
a4254 1
  
d4259 1
a4259 1
  
d4262 1
a4262 1
  
d4267 1
a4267 1
  
d4277 1
a4277 1
  
d4281 1
a4281 1
  
d4285 1
a4285 1
  
d4299 1
a4299 1
  
d4305 1
a4305 1
  
d4316 1
a4316 1
  
d4328 1
a4328 1
  
d4333 1
a4333 1
  
d4384 1
a4384 1
  
d4392 1
a4392 1
  
d4395 1
a4395 1
  
d4401 1
a4401 1
  
d4448 3
d4854 3
a4856 3
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to 
 * clarify their behavior to the compiler.  The name approval code was also 
d4858 1
a4858 1
 * array to a linked list to allow for on the fly adding of names to the 
d4879 1
a4879 1
 * 
d4888 1
a4888 1
 * 
d4892 1
a4892 1
 * 
@


1.114
log
@Clear player flags associated with memorization and regeneration.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.113 2008/01/22 05:02:05 myc Exp jps $
d39 1
a172 1
void mag_assign_spells(void);
d1139 2
a1140 2
  log("   Spells.");
  mag_assign_spells();
d1142 2
a1143 2
  log("Assigning spell and skill levels.");
  init_spell_levels();
d1145 1
a1145 1
  log("Sorting command list and spells.");
d1147 1
a1147 1
  sort_spells();
d4996 3
@


1.113
log
@Fix asciiflag_conv to work with negative numbers.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.112 2008/01/15 03:18:19 myc Exp myc $
d4472 1
a4472 1
  extern void assign_mem_list(struct char_data *);  
d4477 2
d4481 1
a4481 1
  CONSENT(ch) = NULL;  
d4511 3
a4513 2
  check_regen_rates(ch);	/* start regening points */
  
d4996 3
@


1.112
log
@Making SENSE_LIFE do the same thing it used to instead of add
a static amount to perception.  That way SENSE_LIFE only applies
to chars and not objs.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.111 2008/01/12 23:13:20 myc Exp myc $
a1687 1
  int is_number = 1;
d1690 1
a1690 11
  for (p = flag; *p; p++) {
    if (islower(*p))
      flags |= 1 << (*p - 'a');
    else if (isupper(*p))
      flags |= 1 << (26 + (*p - 'A'));
    
    if (!isdigit(*p))
      is_number = 0;
  }
  
  if (is_number)
d1692 7
d4993 5
@


1.111
log
@Put the spells_of_circle declaration in a header file.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.110 2008/01/10 05:39:43 myc Exp myc $
a3990 2
  if (AFF_FLAGGED(ch, AFF_SENSE_LIFE))
    GET_PERCEPTION(ch) += 4 * GET_LEVEL(ch);
d4997 3
@


1.110
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.109 2008/01/09 09:18:00 jps Exp myc $
a84 1
extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
d4999 4
@


1.109
log
@Moved natural move calculations to races.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.108 2008/01/09 08:31:14 jps Exp jps $
d3983 1
a3983 1
  start_hp = GET_MAX_HIT(ch) - GET_HIT(ch);
d3985 1
a3985 3
  if (!start_hp)
    alter_hit(ch, GET_HIT(ch) - GET_MAX_HIT(ch), 1);
  alter_hit(ch, start_hp + GET_HIT(ch) - GET_MAX_HIT(ch), 2);
d5000 3
@


1.108
log
@Moved height and weight setting to races.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.107 2008/01/09 04:12:42 jps Exp jps $
d2785 1
a2785 20

  /* Mountable mobs will have their mv points set according to level.
   * The second parameter to pow (now 0.8) controls how the points
   * increase as the level increases. If it were 1, the points would
   * increase in a straight line as the level increases. If it were
   * greater than 1, the points would increase slowly at first, and
   * then sharply curve up to their maximum as the level got close
   * to the maximum level. When it's below 1, the points increase
   * quickly at first, and then slowly reach their maximum. */

  if (MOB_FLAGGED(mob, MOB_MOUNTABLE)) {
     if (GET_LEVEL(mob) > MAX_MOUNT_LEVEL)
        mob->points.max_move = MOUNT_MAXMOVE + 2 * (GET_LEVEL(mob) - MAX_MOUNT_LEVEL) +
           number(0, 9);
     else
        mob->points.max_move = (int)(MOUNT_MINMOVE + (MOUNT_MAXMOVE - MOUNT_MINMOVE) *
              pow((GET_LEVEL(mob) - 1) / (double)(MAX_MOUNT_LEVEL - 1), 0.8)) +
           number(0, 9);
  }

a4582 1
    ch->points.max_move = 82;
d4600 1
a4600 1
  ch->points.max_move = MAX(100, GET_CON(ch) * 2);
d5002 3
@


1.107
log
@Remove obsolete member next_scribing.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.106 2008/01/09 02:29:58 jps Exp jps $
a4615 9
  
  if (ch->player.sex == SEX_MALE) {
    ch->player.weight = number(races[race].mweight_lo, races[race].mweight_hi);
    ch->player.height = number(races[race].mheight_lo, races[race].mheight_hi);
  } else {
    ch->player.weight = number(races[race].fweight_lo, races[race].fweight_hi);
    ch->player.height = number(races[race].fheight_lo, races[race].fheight_hi);
  }

d5022 3
@


1.106
log
@Real mob nr moved to mob_specials.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.105 2008/01/06 18:16:10 jps Exp jps $
a4519 1
  ch->next_scribing = NULL;
d5031 3
@


1.105
log
@Moved player height, weight, and size to races.c.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.104 2008/01/06 05:35:55 jps Exp jps $
d2296 1
a2296 1
  mob_proto[i].nr = i;
d5032 3
@


1.104
log
@Remove function prototype which is provided by an include.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.103 2008/01/05 20:32:43 jps Exp jps $
a51 1
void apply_racial_bonus_hit_and_dam(struct char_data *ch, int type);
d3849 1
a3849 46

  if (ch->player.race == RACE_HUMAN) {
    ch->player.size = SIZE_MEDIUM; 
  }
  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.size = SIZE_LARGE;
  }
  if (ch->player.race == RACE_DWARF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_HALFLING) {
    ch->player.size = SIZE_SMALL;
  }
  if (ch->player.race == RACE_GNOME) {
    ch->player.size = SIZE_SMALL;
  }
  if (ch->player.race == RACE_ORC) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_TROLL) {
    ch->player.size = SIZE_LARGE;
  }
  if (ch->player.race == RACE_OGRE) {
    ch->player.size = SIZE_HUGE;
  }
  if (ch->player.race == RACE_DUERGAR) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_DROW_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_UNDEFINED) {
    ch->player.size = SIZE_MEDIUM;
  }

/***************************************************************************
 *  GET_SIZE(ch) = st->size;
 ***************************************************************************/
  
  
d4176 1
a4176 1
  apply_racial_bonus_hit_and_dam(ch, 0);
d4589 1
a4589 1
  int i, a_num;
a4617 1
  /* FIXME: move this logic to races.c. */
d4619 2
a4620 53
    if (ch->player.race == RACE_HUMAN) {
      ch->player.weight = number(120, 180);
      ch->player.height = number(60, 76);
    }
    if (ch->player.race == RACE_HALF_ELF) {
      ch->player.weight = number(100, 170);
      ch->player.height = number(60, 76);
    }
    if (ch->player.race == RACE_BARBARIAN) {
      ch->player.weight = number(170, 260);
      ch->player.height = number(69, 88);
    }
    if (ch->player.race == RACE_DWARF) {
      ch->player.weight = number(170, 200);
      ch->player.height = number(38, 50);
    }
    if (ch->player.race == RACE_ELF) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(60, 70);
    }
    if (ch->player.race == RACE_HALFLING) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(35, 42);
    }
    if (ch->player.race == RACE_GNOME) {
      ch->player.weight = number(40, 90);
      ch->player.height = number(26, 38);
    }
    if (ch->player.race == RACE_ORC) {
      ch->player.weight = number(90, 150);
      ch->player.height = number(58, 68);
    }
    if (ch->player.race == RACE_TROLL) {
      ch->player.weight = number(130, 290);
      ch->player.height = number(72, 90);
    }
    if (ch->player.race == RACE_OGRE) {
      ch->player.weight = number(390, 530);
      ch->player.height = number(93, 119);
    }
    if (ch->player.race == RACE_DUERGAR) {
      ch->player.weight = number(170, 200);
      ch->player.height = number(38, 50);
    }
    if (ch->player.race == RACE_DROW_ELF) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(60, 70);
    }
    if (ch->player.race == RACE_UNDEFINED) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(60, 70);
    }
    
d4622 2
a4623 53
    if (ch->player.race == RACE_HUMAN) {
      ch->player.weight = number(95, 150);
      ch->player.height = number(60, 70);
    }
    if (ch->player.race == RACE_HALF_ELF) {
      ch->player.weight = number(94, 155);
      ch->player.height = number(60, 70);
    }
    if (ch->player.race == RACE_BARBARIAN) {
      ch->player.weight = number(130, 210);
      ch->player.height = number(69, 80);
    }
    if (ch->player.race == RACE_DWARF) {
      ch->player.weight = number(150, 190);
      ch->player.height = number(38, 50);
    }
    if (ch->player.race == RACE_ELF) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(59, 68);
    }
    if (ch->player.race == RACE_HALFLING) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(35, 42);
    }
    if (ch->player.race == RACE_GNOME) {
      ch->player.weight = number(40, 90);
      ch->player.height = number(26, 38);
    }
    if (ch->player.race == RACE_ORC) {
      ch->player.weight = number(90, 150);
      ch->player.height = number(58, 68);
    }
    if (ch->player.race == RACE_TROLL) {
      ch->player.weight = number(130, 290);
      ch->player.height = number(72, 90);
    }
    if (ch->player.race == RACE_OGRE) {
      ch->player.weight = number(390, 530);
      ch->player.height = number(93, 119);
    }
    if (ch->player.race == RACE_DUERGAR) {
      ch->player.weight = number(150, 190);
      ch->player.height = number(38, 50);
    }
    if (ch->player.race == RACE_DROW_ELF) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(60, 70);
    }
    if (ch->player.race == RACE_UNDEFINED) {
      ch->player.weight = number(90, 160);
      ch->player.height = number(60, 70);
    }
    
d4626 1
a4626 21

  switch (ch->player.race) {
  case RACE_OGRE:
    ch->player.size = SIZE_HUGE;
    break; 

  case RACE_BARBARIAN:
  case RACE_TROLL:
    ch->player.size = SIZE_LARGE;
    break;

  case RACE_GNOME:
  case RACE_HALFLING:
    ch->player.size = SIZE_SMALL; 
    break; 

  default:
    ch->player.size = SIZE_MEDIUM; 
  };
  

d5032 3
@


1.103
log
@Move some newbie-pref setting code in here.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.102 2008/01/05 05:43:10 jps Exp jps $
a4848 1
  void advance_level(struct char_data * ch, int);
d5201 3
@


1.102
log
@Calling init_char() and update_char() when appropriate. Racial
innates stuff moved to races.c. start_player() moved here.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.101 2008/01/04 01:53:26 jps Exp jps $
d4834 4
d5202 4
@


1.101
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.100 2007/12/25 19:46:25 jps Exp jps $
a52 2
void set_racial_affects(struct char_data *ch);
void set_class_affects(struct char_data *ch);
a135 3
/* local functions */
/*void set_mob_skills(int i, int class, int race);*/
void set_skills(struct char_data *ch);
a184 1
extern void update_skills(struct char_data *ch);
d2776 4
a2779 4
  /* mobs now also have skills based on race/class/level just like PC's 
   * --gurlaek 7/3/1999 */
  set_skills(mob);
  update_skills(mob);
d3780 1
a3780 1
void save_char(struct char_data *ch) {
d3937 3
a3939 2
  /* once the specials are read in, go ahead and set the skills up */
  update_skills(ch);
a3947 3
  /*Real race stuff....Banyal
    ch->points.hitroll = 0;
    ch->points.damroll = 0;*/
d3964 1
a3964 1
  /* Check to see that this person is in their clan list, if not, add -nech*/
a3988 33
  if (!IS_AFFECTED(ch, AFF_INFRAVISION)){
    switch (GET_RACE(ch)){
    case RACE_DROW_ELF:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_ELF:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_DWARF:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_DUERGAR:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_HALFLING:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      if (!AFF_FLAGGED(ch, AFF_SENSE_LIFE))
	SET_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
      break;
    case RACE_TROLL:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_OGRE:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_HALF_ELF:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    case RACE_GNOME:
      SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
      break;
    }}
  
d4250 2
a4251 3
  set_class_affects(ch);
  set_racial_affects(ch);
  
d4624 8
d4633 1
a4633 3

/* initialize a new character only if class is set */
void init_char(struct char_data * ch)
a4656 3
  
  /*ch->player.hometown = 1;*/
  
d4664 1
a4664 1
  /* Lets make them damn races diffrent sizes hey? Banyal*/
d4830 1
a4830 2
  /* This is necessary the first time to zero all aliases */
  /* --Fingon                                             */
d4836 11
d4848 9
d4858 10
d4869 1
d5198 4
d5215 1
a5215 1
 * save_char() no longer requires the save room (which wasn't being used
@


1.100
log
@Remember whether a player was flying as we save them. Due to the removal of
all effect-causing agents, affect_modify() will stop a player from flying.
But since we're only saving a player, we don't want to change the player's
position.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.99 2007/12/25 16:39:53 jps Exp jps $
d38 1
d5207 6
@


1.99
log
@Fix armor calculations.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.98 2007/12/21 07:34:36 myc Exp jps $
a4167 2
/* redone by proky...Banyal 
   Redone a hunred times over by me and others...Banyal*/
d4175 5
d4190 1
a4190 1
  /* Unaffect everything a character can be affected by */
d4205 1
a4205 1
      st->affected[i].type = 0;	/* Zero signifies not used */
a4214 1
  
d4217 2
a4218 3
   * remove the affections so that the raw values are stored; otherwise
   * the
   * effects are doubled when the char logs back in.
d4261 1
a4261 1
  /* Save hit and dam based on race. DCE 12-16-01 */
d4283 1
a4283 8
  /* Removed this addition 12-20-01 because it was removing
    flags like AFF_GROUP and who knows what else...DCE */
  /* Remove all affects. DCE 12-17-01 */
/*  ch->char_specials.saved.affected_by = 0;
  ch->char_specials.saved.affected_by2 = 0;
  ch->char_specials.saved.affected_by3 = 0; */

  /* add spell and eq affections back in now */
d4289 1
a4289 1
  /* Add racial and class affections back */
d4297 3
d4311 1
a4311 1
}				/* Char to store */
d5206 3
@


1.98
log
@Fixing positive armor applies to cause negative drops in armor.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.97 2007/12/19 20:46:56 myc Exp myc $
d4084 1
a4084 1
  GET_AC(ch) = 100 - static_ac(GET_DEX(ch)) - count_applies(ch, APPLY_AC);
d4114 1
a4114 1
        value += GET_OBJ_VAL(GET_EQ(ch, i), 0);
d4116 6
a4121 2
        if (GET_EQ(ch, i)->affected[j].location == type)
          value += GET_EQ(ch, i)->affected[j].modifier;
d5209 3
@


1.97
log
@save_char() no longer requires the save room (which wasn't being used
anyway).  Updated clan checking code in store_to_char.  Added
tag_argument() function for use with ASCII files.  Currently used by
clan code, but could possibly be used for pfiles in the future.  Also
added kill_ems().  These two functions ported from v3.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.96 2007/10/17 17:18:04 myc Exp myc $
d4084 1
a4084 1
  GET_AC(ch) = 100 - static_ac(GET_DEX(ch)) + count_applies(ch, APPLY_AC);
d4114 1
a4114 1
        value -= GET_OBJ_VAL(GET_EQ(ch, i), 0);
d5205 7
@


1.96
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.95 2007/10/11 20:14:48 myc Exp myc $
a3782 2
 *
 * NOTE: load_room should be an *RNUM* now.  It is converted to a vnum here.
d3785 1
a3785 1
void save_char(struct char_data *ch, int load_room) {
d3844 1
a3844 2
  int i,member_found=0;
  sh_int clan_num;
d3958 1
a3958 2
  /* clan snoop. -2 = no snoop, -1 = snoop all, # = snoop clan # ..  nechtrous */
  ch->clan_snoop = -2;
d3972 2
a3973 10
  if(GET_CLAN(ch) && GET_CLAN_RANK(ch)>0) {
    clan_num=find_clan_by_id(GET_CLAN(ch));
    for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
      if(!strcmp(clan[clan_num].member_list[i], GET_NAME(ch)))
        member_found = 1;
    if(!member_found)
      for(i=0;i<MAX_MEMBERS_PER_CLAN && clan[clan_num].member_list[i][0];i++);
    strcpy(clan[clan_num].member_list[i], GET_NAME(ch));
    update_clan(ch, clan_num);
  }
d4857 3
a4859 2
  for (i = 0; i < 3; i++)
    GET_COND(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 24);
d5162 41
d5205 4
@


1.95
log
@Changed skill defines to support chants and songs as skills, but
slightly distinguished from spells and skills.  TOP_SKILL is the
old MAX_SKILLS.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.94 2007/10/02 02:52:27 myc Exp myc $
d5164 2
a5165 1
  if (search_block2(arg, (char **) iscommand, TRUE) >= 0)
d5167 1
a5167 1
  if (search_block2(arg, (char **) smart_ass, TRUE) >= 0)
d5175 5
@


1.94
log
@Changed sense life to be dynamically added in to perception in
update_stats().
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.93 2007/09/28 20:49:35 myc Exp myc $
d4854 1
a4854 1
  for (i = 1; i <= MAX_SKILLS; i++) {
d5174 4
@


1.93
log
@Removed vnum_mobile, vnum_object, vnum_room, vnum_trigger, vnum_mob_zone,
and vnum_object_zone functions whose functionality is now implemented
by the vsearch suite.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.92 2007/09/20 21:45:02 myc Exp myc $
d2280 1
a2280 1
  if (!dummy_mob) {
a2281 2
    SET_BIT(dummy_mob->saved.pref, PRF_AUTOEXIT);
  }
d4024 1
a4024 1
      if (!IS_AFFECTED(ch, AFF_SENSE_LIFE))
d4111 2
d5174 5
@


1.92
log
@Saving perception and hiddenness to player file :>
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.91 2007/09/20 21:20:43 myc Exp myc $
a192 1
int search_block2(char *arg, const char **list, int exact);
a2740 64
int vnum_mobile(char *searchname, struct char_data * ch)
{
  int nr, found = 0;
  
  for (nr = 0; nr <= top_of_mobt; nr++) {
    if (isname(searchname, mob_proto[nr].player.name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      mob_index[nr].virtual,
	      mob_proto[nr].player.short_descr);
      send_to_char(buf, ch);
    }
  }
  
  return (found);
}



int vnum_object(char *searchname, struct char_data * ch)
{
  int nr, found = 0;
  
  for (nr = 0; nr <= top_of_objt; nr++) {
    if (isname(searchname, obj_proto[nr].name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      obj_index[nr].virtual,
	      obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }
  return (found);
}


int vnum_room(char *searchname, struct char_data * ch)
{
  int nr, found = 0;
  
  for (nr = 0; nr <= top_of_world; nr++) {
    if (isname(searchname, world[nr].name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      world[nr].number,
	      world[nr].name);
      send_to_char(buf, ch);
    }
  }
  return (found);
}

int vnum_trigger(char *searchname, struct char_data *ch)
{
   int nr, found = 0;

   for (nr = 0; nr < top_of_trigt; nr++) {
      if (isname(searchname, trig_index[nr]->proto->name)) {
         sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
               trig_index[nr]->virtual,
               trig_index[nr]->proto->name);
         send_to_char(buf, ch);
      }
   }
   return found;
}

a2756 29
int vnum_mob_zone(int zone, struct char_data *ch)
{
  int r_num, nr, found = 0;
  
  for (nr = (zone_table[zone].number)*100;nr <= zone_table[zone].top;nr++)
    if((r_num = real_mobile(nr)) >= 0) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      mob_index[r_num].virtual,
	      mob_proto[r_num].player.short_descr);
      send_to_char(buf, ch); 
    }
  return found;
}

int vnum_object_zone(int zone, struct char_data *ch)
{
  int r_num, nr, found = 0;
  
  for (nr = (zone_table[zone].number)*100;nr < zone_table[zone].top;nr++)
    if((r_num = real_object(nr)) >= 0) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
	      obj_index[r_num].virtual,
	      obj_proto[r_num].short_description);
      send_to_char(buf, ch); 
    }
  return found;
}


d5164 1
a5164 1
  if (search_block2(arg, iscommand, TRUE) >= 0)
d5166 1
a5166 1
  if (search_block2(arg, smart_ass, TRUE) >= 0)
d5174 3
@


1.91
log
@Hide points and perception are in.  They are saved for mobs and object
files.  Perception is calculated in update_stats (which is called
whenever affect_total runs).  Rewrote scale_attribs to use an array
instead of a mass of constant defines in utils.h.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.90 2007/09/15 05:03:46 myc Exp myc $
d4025 9
d4350 8
d5268 6
@


1.90
log
@Added MOB2 flags.  They're saved on mobs as an espec.  Implemented
MOB2_NOPOISON.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.89 2007/09/12 22:23:04 myc Exp myc $
d49 1
a49 1
int total_stats_of_wears(struct char_data *ch, int TYPE);
d2221 8
d2544 1
a2544 10
      /*
      ** affect player flags (see AFF_XXX flags in structs.h )
      ** This allows players flags to be affected by an item, for example
      ** create a ring which gives the player permanent sense life when worn.
      **
      ** Note: more 'C' fields are allowed because all found 'C' (set char bits)
      **       fields are added to the current values. (nice for builders who
      **       don't want those large bitvector numbers in the obj file).
      */
    case 'C':
d2547 1
a2547 1
      obj_proto[i].obj_flags.bitvector = obj_proto[i].obj_flags.bitvector | t[0];
a3936 23
/* now scaled for 100 point attribs */
int static_ac(int dex)
{
  if (dex <= 32)
    return 10;
  else if (dex <= 40)
    return 15;
  else if (dex <= 56)
    return 20;
  else if (dex <= 64)
    return 25;
  else if (dex <= 72)
    return 30;
  else if (dex <= 76)
    return 35;
  else if (dex <= 80)
    return 40;
  else if (dex <= 84)
    return 45;
  else
    return 50;
}

d4131 23
a4157 1
   /* 	int prevbonus = 0;     */
d4180 4
a4183 5
  int tmphps;
  int x;
  /*AC change*/
  GET_AC(ch) = 100 - (static_ac(GET_DEX(ch)) + total_stats_of_wears(ch, APPLY_AC));
  /*max min this*/
d4185 14
a4198 10
  /*Hit bonus*/
  tmphps = GET_MAX_HIT(ch) - GET_HIT(ch);
  GET_MAX_HIT(ch) = GET_NATHPS(ch) + con_aff(ch) + total_stats_of_wears(ch, APPLY_HIT);
  if (tmphps == 0)/*restore hps*/
    {
      alter_hit(ch, (0 - (GET_MAX_HIT(ch) - GET_HIT(ch))), 1);
    }
  x = GET_MAX_HIT(ch) - GET_HIT(ch);
  x = x - tmphps;   alter_hit(ch, 0 - x, 2);
  
d4202 1
a4202 1
int total_stats_of_wears(struct char_data *ch, int TYPE)
d4207 8
a4214 23
  /*APPLY_AC = 17, ITEM_ARMOR = 9, APPLY_HIT = 13*/
  for (i = 0; i < NUM_WEARS; i++) 
    {
      if (GET_EQ(ch, i))	
	{
	  if ((GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR) && (TYPE == APPLY_AC))
            value = value + GET_OBJ_VAL(GET_EQ(ch, i), 0);
	  for (j = 0; j < MAX_OBJ_AFFECT; j++)
	    {
	      if (GET_EQ(ch, i)->affected[j].location == TYPE)
		value = value + GET_EQ(ch, i)->affected[j].modifier;
	    }      
	}
    }
  for (af = ch->affected; af; af = af->next) 
    {
      if (TYPE == af->location)
	{
	  if (TYPE == APPLY_AC)
            value = value - af->modifier;
	  else
            value = value + af->modifier;
	}
d4216 5
d4225 24
d4252 6
a4257 172
  switch (GET_RACE(ch)) {
  case SPECIES_GNOME:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)GNOME_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)GNOME_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)GNOME_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)GNOME_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)GNOME_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)GNOME_CON));
    break;
  case SPECIES_HUMAN:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)HUMAN_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)HUMAN_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)HUMAN_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)HUMAN_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)HUMAN_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)HUMAN_CON));
    break;
  case SPECIES_OGRE:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)OGRE_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)OGRE_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)OGRE_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)OGRE_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)OGRE_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)OGRE_CON));
    break;
  case SPECIES_BARBARIAN:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)BARBARIAN_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)BARBARIAN_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)BARBARIAN_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)BARBARIAN_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)BARBARIAN_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)BARBARIAN_CON));
    break;
  case SPECIES_TROLL:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)TROLL_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)TROLL_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)TROLL_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)TROLL_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)TROLL_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)TROLL_CON));
    break;
  case SPECIES_HALF_ELF:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)HALF_ELF_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)HALF_ELF_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)HALF_ELF_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)HALF_ELF_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)HALF_ELF_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)HALF_ELF_CON));
    break;
  case SPECIES_DROW_ELF:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)DROW_ELF_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)DROW_ELF_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)DROW_ELF_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)DROW_ELF_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)DROW_ELF_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)DROW_ELF_CON));
    break;
  case SPECIES_HALFLING:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)HALFLING_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)HALFLING_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)HALFLING_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)HALFLING_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)HALFLING_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)HALFLING_CON));
    break;
  case SPECIES_DWARF:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)DWARF_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)DWARF_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)DWARF_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)DWARF_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)DWARF_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)DWARF_CON));
    break;
  case SPECIES_DUERGAR:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)DUERGAR_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)DUERGAR_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)DUERGAR_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)DUERGAR_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)DUERGAR_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)DUERGAR_CON));
    break;
  case SPECIES_ORC:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)ORC_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)ORC_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)ORC_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)ORC_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)ORC_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)ORC_CON));
    break;
  case SPECIES_ELF:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)ELF_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)ELF_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)ELF_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)ELF_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)ELF_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)ELF_CON));
    break;
  case SPECIES_UNDEAD:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)UNDEAD_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)UNDEAD_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)UNDEAD_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)UNDEAD_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)UNDEAD_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)UNDEAD_CON));
    break;
  case SPECIES_HUMANOID:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)HUMANOID_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)HUMANOID_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)HUMANOID_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)HUMANOID_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)HUMANOID_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)HUMANOID_CON));
    break;
  case SPECIES_ANIMAL:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)ANIMAL_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)ANIMAL_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)ANIMAL_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)ANIMAL_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)ANIMAL_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)ANIMAL_CON));
    break;
  case SPECIES_DRAGON:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)DRAGON_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)DRAGON_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)DRAGON_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)DRAGON_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)DRAGON_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)DRAGON_CON));
    break;
  case SPECIES_GIANT:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)GIANT_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)GIANT_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)GIANT_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)GIANT_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)GIANT_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)GIANT_CON));
    break;
  case SPECIES_OTHER:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)OTHER_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)OTHER_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)OTHER_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)OTHER_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)OTHER_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)OTHER_CON));
    break;
  case SPECIES_GOBLIN:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)GOBLIN_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)GOBLIN_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)GOBLIN_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)GOBLIN_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)GOBLIN_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)GOBLIN_CON));
    break;
  case SPECIES_DEMON:
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)DEMON_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)DEMON_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)DEMON_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)DEMON_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)DEMON_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)DEMON_CON));
    break;
  default:
    sprintf(buf, "Unknown species/race for %s", GET_NAME(ch));
    GET_AFFECTED_STR(ch) = (char) (GET_VIEWED_STR(ch)/(100/(float)HUMAN_STR));
    GET_AFFECTED_INT(ch) = (char) (GET_VIEWED_INT(ch)/(100/(float)HUMAN_INT));
    GET_AFFECTED_DEX(ch) = (char) (GET_VIEWED_DEX(ch)/(100/(float)HUMAN_DEX));
    GET_AFFECTED_WIS(ch) = (char) (GET_VIEWED_WIS(ch)/(100/(float)HUMAN_WIS));
    GET_AFFECTED_CHA(ch) = (char) (GET_VIEWED_CHA(ch)/(100/(float)HUMAN_CHA));
    GET_AFFECTED_CON(ch) = (char) (GET_VIEWED_CON(ch)/(100/(float)HUMAN_CON));
    break;
  }
  return;
d5251 4
@


1.89
log
@Mobs get autoexit autoset on now.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.88 2007/09/04 06:49:19 myc Exp myc $
d2217 4
d5402 3
@


1.88
log
@Updated hemisphere initialization function.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.87 2007/08/24 22:49:05 jps Exp myc $
d2269 1
a2269 1
  if(!dummy_mob)
d2271 2
d5398 3
@


1.87
log
@Added function vnum_trigger() for use with the "tnum" command.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.86 2007/08/24 17:01:36 myc Exp jps $
a125 1
struct weather_data weather_info;	/* the infomation about the weather */
a177 1
void weather_and_time(int mode);
d1210 2
a1211 1
  log("entering if-else chain");
d1214 4
a1217 4
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
d1219 4
a1222 4
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_SET;
d1224 4
a1227 4
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_DARK;
d1229 4
a1232 4
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_RISE;
d1234 4
a1237 4
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_LIGHT;
d1242 6
a1247 6
  /* setup the seasons */    
  if(time_info.month < 4) {
    Hemispheres[HEMISPHERE_NORTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SUMMER;
d1249 5
a1253 5
  } else if(time_info.month < 8) {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = AUTUMN;
d1255 5
a1259 5
  } else if(time_info.month < 12) {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = WINTER;
d1262 4
a1265 4
    Hemispheres[HEMISPHERE_NORTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_NORTHEAST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SPRING;
d1272 2
a1273 2
  log("Calling init_weather()");
  
d5396 3
@


1.86
log
@Adding ostat and mstat commands as shorthand for vstat, rstat for stat
room, and mnum and onum for vnum.  Also adding rnum and znum with new
functionality.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.85 2007/08/22 17:59:49 jps Exp myc $
d2787 14
d5397 5
@


1.85
log
@Add restrict_reason variable.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.84 2007/08/17 02:23:36 jps Exp jps $
d2772 32
d5383 3
@


1.84
log
@Add global variable restrict_manual, so that autobooting code won't
remove a login restriction that was set by hand.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.83 2007/08/02 00:23:34 myc Exp jps $
d104 1
a104 1
int manual_restrict = 0;   /* whether restrict was set manually */
d5351 4
@


1.83
log
@Remove a defunct function call.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.82 2007/07/25 02:58:01 myc Exp myc $
d104 1
d5351 3
@


1.82
log
@I think I fixed the locate object bug... NEVER EVER EVER stick any
objects on a char before they enter the game!
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.81 2007/07/24 23:02:52 jps Exp myc $
a141 1
void do_newbie(struct char_data *vict);
d5350 4
@


1.81
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.80 2007/07/19 21:59:52 jps Exp jps $
a4067 3
  if (!PLR_FLAGGED(ch, PLR_NEWNAME))
    do_newbie(ch);
  
d5351 3
@


1.80
log
@Dynamic strings for drink containers.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.79 2007/07/18 18:47:38 jps Exp jps $
d3107 1
a3107 1
        ZONE_ERROR("attempt to force-command a non-existant mob");
d3189 1
a3189 1
	  ZONE_ERROR("attempt to give obj to non-existant mob");
d3225 1
a3225 1
	  ZONE_ERROR("trying to equip non-existant mob");
d5354 3
@


1.79
log
@Stop object extra desc lists from being reversed while loading.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.78 2007/07/18 16:23:58 jps Exp jps $
d54 1
d192 1
a192 1
const char  *std_prompt =  "<&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)>%_&0<%t&0>:<%o&0>";
d2945 3
d5354 3
@


1.78
log
@Force FOOD objects to have keyword "food".
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.77 2007/07/18 01:21:34 jps Exp jps $
d2389 1
a2389 1
  struct extra_descr_data *new_descr;
d2453 1
a2453 2
  /* IF A PORTAL (ie == 24) */
  if (obj_proto[i].obj_flags.type_flag == 24){
d2502 8
a2509 2
      new_descr->next = obj_proto[i].ex_description;
      obj_proto[i].ex_description = new_descr;
d5350 3
@


1.77
log
@Restore AFF2/AFF3 flags to object prototypes.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.76 2007/07/18 00:04:41 jps Exp jps $
d2343 36
d2545 1
a2938 5
  /* Store a light's initial time as value 1, so the
   * illumination spell can restore the light accordingly */
  if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
     GET_OBJ_VAL(obj, 1) = GET_OBJ_VAL(obj, 2);

d5345 3
@


1.76
log
@Save AFF2 and AFF3 flags for mobiles.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.75 2007/07/14 02:16:22 jps Exp jps $
d2425 2
a2426 2
    obj_proto[i].obj_flags.spell_flags2 = 0;
    obj_proto[i].obj_flags.spell_flags3 = 0;
d2436 2
a2437 2
    obj_proto[i].obj_flags.spell_flags2 = 0;
    obj_proto[i].obj_flags.spell_flags3 = 0;
d5313 3
@


1.75
log
@Mountable mobs have their mv points calculated when being created.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.74 2007/04/18 17:26:26 jps Exp jps $
d2209 8
d5313 3
@


1.74
log
@Reset both sides of doors that span zones.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.73 2007/04/17 23:59:16 myc Exp jps $
d18 2
d2786 20
d5305 3
@


1.73
log
@New trigger type: Load.  It goes off any time a mobile is loaded, whether
it be god command, zone command, or trigger command.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.72 2007/03/31 23:31:30 jps Exp myc $
d203 1
d2972 43
d3018 1
a3018 1
  int cmd_no, last_cmd = 0;
d3021 2
d3202 54
a3255 70
    case 'D':			/* set state of door */
      if (ZCMD.arg2 < 0 || ZCMD.arg2 >= NUM_OF_DIRS ||
	  (world[ZCMD.arg1].dir_option[ZCMD.arg2] == NULL)) {
	ZONE_ERROR("door does not exist");
      } else
	switch (ZCMD.arg3) {
	case 0:
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_HIDDEN);
	  break;
	case 1:
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_HIDDEN);
	  break;
	case 2:
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_LOCKED);
	  SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		  EX_CLOSED);
	  REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_HIDDEN);
	  break;
	case 3:
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_CLOSED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
/* allow hidden, but putting descr when no door seems to screw things up
**          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_DESCRIPT);
*/
          break;
	case 4:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_LOCKED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          break;
	case 5:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
		     EX_LOCKED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_HIDDEN);
          break;
	}
      last_cmd = 1;
      break;
      
    default:
      ZONE_ERROR("unknown cmd in reset table; cmd disabled");
      ZCMD.command = '*';
      break;
    }
  }
  
  zone_table[zone].age = 0;
d5283 4
@


1.72
log
@Fix ac calculation for mobs level 30-94
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.71 2007/03/27 04:27:05 myc Exp jps $
d3000 1
d5253 3
@


1.71
log
@Fixed bug in store_to_char preventing hp from healing after 1hr time.
Replaced innate timer macro spellings.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.70 2007/02/04 18:12:31 myc Exp myc $
d881 3
a883 1
  if (level < 30)
a887 1
  /*ac calculations*/
d891 2
a892 1
  ac = (int)((float)((sfactor/100.0) * ac));
d5252 4
@


1.70
log
@Page length now saves as a part of player specials.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.69 2006/11/21 03:45:52 jps Exp myc $
d2138 1
a2138 1
    GET_INNT(mob_proto + i, j) = -1;
d3956 1
a3956 1
    if (GET_MAX_HIT(ch) < GET_HIT(ch))
d4949 1
a4949 1
    GET_INNT(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 0);
d5250 3
@


1.69
log
@Store a light's initial burning time in obj val 1, when creating it.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.68 2006/11/18 19:57:16 jps Exp jps $
a3919 3
  /* for variable page_string -nechtrous*/
  ch->page_length = 22; /* 22 is default right now, can make saveable later*/ 
  
d5250 3
@


1.68
log
@Don't use the one-hour since last login bonus to REDUCE
hit/mv/mana below their affected max.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.67 2006/05/05 20:46:23 rls Exp jps $
d2866 1
a2866 1
  /* this is temporary Fingon */
d2869 5
d5253 4
@


1.67
log
@Some issues with mobiles having no class, no race creating
large sums of platinum.  Moreso than they should have anyway
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.66 2006/05/05 15:53:51 rls Exp $
d3943 7
a3949 1
   * real time, we'll set your HMV back to full
d3954 6
a3959 3
    GET_HIT(ch) = GET_MAX_HIT(ch);
    GET_MOVE(ch) = GET_MAX_MOVE(ch);
    GET_MANA(ch) = GET_MAX_MANA(ch);
d5248 4
@


1.66
log
@Set default for factors @@ 100 instead of 0
so that mobs without classes, etc wouldn't
zero out coinage amounts.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.65 2006/05/05 15:06:14 rls Exp $
d751 1
a751 1
    cfactor = 100;
d773 1
a773 1
    sfactor = 100;
d785 1
a785 1
    sfactor = 250;
d797 1
a797 1
    sfactor = 100;
d5239 5
@


1.65
log
@Modified get_copper to give mo' money with a little bit
of sanity in regards to clan prices, scroll prices, etc.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.64 2005/07/27 03:06:25 jwk Exp $
d751 1
a751 1
    cfactor = 20;
d766 1
a766 1
    cfactor = 40;
d773 1
a773 1
    sfactor = 0;
d776 1
a776 1
    sfactor = 20;
d782 1
a782 1
    sfactor = 400;
d785 1
a785 1
    sfactor = 220;
d788 1
a788 1
    sfactor = 150;
d791 1
a791 1
    sfactor = 65;
d797 1
a797 1
    sfactor = 40;
d5239 4
@


1.64
log
@Changed mob load so that when it is read from the mob file it reads the size in instead of basing it on the race.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.63 2004/11/01 03:29:38 rsd Exp $
d738 2
a739 1
  for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
d748 2
a749 1
  switch(mob_proto[i].player.class) {
d770 2
a771 1
  switch(mob_proto[i].player.race) {
d776 1
a776 1
    sfactor = 40;
d779 1
a779 1
    sfactor = 40;
d782 1
a782 1
    sfactor = 140;
d785 1
a785 1
    sfactor = 140;
d788 1
a788 1
    sfactor = 120;
d804 1
a804 1
  copper = (number(1, 15)) * mob_proto[i].player.level;
d2798 4
a2801 2
  if (type == VIRTUAL) {
    if ((i = real_mobile(nr)) < 0) {
d2805 2
a2806 1
  } else
d5239 3
@


1.63
log
@Added a dev ifdef for compiling to supress syserrs by
setting the mini_mud INT to on if in dev mode.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.62 2004/11/01 02:56:56 rsd Exp $
d2040 1
a2040 1
    mob_proto[i].player.size = mob_find_size(t[4]);
d5233 4
@


1.62
log
@Removed a typo in the boot sequence
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.61 2003/07/06 20:40:37 jjl Exp $
d93 3
d97 1
d1522 3
a1524 1

d1526 1
a1526 1
    index_filename = MINDEX_FILE;
d5233 3
@


1.61
log
@Improved the message a touch.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.59 2002/11/29 21:54:45 jjl Exp $
d1093 1
a1093 1
  log("Reading a&news, credits, help, bground, info & motds.");
d5227 3
@


1.60
log
@Added some checking to avoid giving mobs items they can't use.
@
text
@d3062 5
a3066 4
	    sprintf(error_buf, "Attempting to give object %d to mob %d, which "
		    "cannot use it due to level restrictions!", 
		    GET_OBJ_VNUM(obj), GET_MOB_VNUM(mob)); 
	    ZONE_ERROR(error_buf); 
d3100 1
d3103 5
a3107 4
		sprintf(error_buf, "Attempting to equip object %d to mob %d,"
			" which cannot use it due to level restrictions!", 
			GET_OBJ_VNUM(obj), GET_MOB_VNUM(mob)); 
		ZONE_ERROR(error_buf); 
a3108 1
	      
@


1.59
log
@Well, here goes something.  Things have been difficult, so this is a
minor tweak to change mob HP.  Basically,  Newbie mobs get hammered in
half,  midrange lose about 33%, and High level mobs have no change.  In the
end, if nothing else, it's meant to help newbies out, without wussifying
the whole deal.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.58 2002/11/09 19:09:45 jjl Exp $
d3055 1
d3059 10
d3099 9
d5225 7
@


1.58
log
@Compressed a large block of if's into a switch.
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.57 2002/09/13 02:32:10 jjl Exp $
d492 1
a492 1
     return xmain;
d2094 1
a2094 1
  mob_proto[i].points.hit = 20;
d5205 3
@


1.57
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: db.c,v 1.56 2002/06/07 22:15:56 dce Exp $
d4854 18
a4871 2
  
  if (ch->player.race == RACE_HUMAN) {
d4873 1
a4873 38
  }
  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.size = SIZE_LARGE;
  }
  if (ch->player.race == RACE_DWARF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_HALFLING) {
    ch->player.size = SIZE_SMALL;
  }
  if (ch->player.race == RACE_GNOME) {
    ch->player.size = SIZE_SMALL;
  }
  if (ch->player.race == RACE_ORC) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_TROLL) {
    ch->player.size = SIZE_LARGE;
  }
  if (ch->player.race == RACE_OGRE) {
    ch->player.size = SIZE_HUGE;
  }
  if (ch->player.race == RACE_DUERGAR) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_DROW_ELF) {
    ch->player.size = SIZE_MEDIUM;
  }
  if (ch->player.race == RACE_UNDEFINED) {
    ch->player.size = SIZE_MEDIUM;
    /*}else{ch->player.size = SIZE_MEDIUM;*/}
  
d5205 3
@


1.56
log
@Adjusted hitrolls for mobs. Was based on 50 levels. I
smoothed it out and lowered it overall.
@
text
@d1 3
a3 1
// $Id: db.c,v 1.55 2002/05/09 23:08:18 dce Exp $
d1988 1
a1988 1
  // No negative hitroll bonus DO_NOT CHANGE -Banyal
d2101 1
a2101 1
  // Changed to get rid of the -199 mobb hitrolls Do NOT change -Banyal
d2411 1
a2411 1
    obj_proto[i].obj_flags.spell_flags = t[3]; //Duh this was somehow removed -Banyal
d3236 1
a3236 1
  /*mob exp cut down*//*giving it the exp of a mob half its level*/
d3825 3
a3827 1
//  GET_SIZE(ch) = st->size;
d3962 1
a3962 1
  //	int prevbonus = 0;    
d4508 1
a4508 1
  ch = NULL; // hope this helps *pray*
d5224 266
a5489 260
// $Log: db.c,v $
// Revision 1.55  2002/05/09 23:08:18  dce
// Removes any saved size on a character.
//
// Revision 1.54  2001/12/21 02:44:35  dce
// Undid what I previous just did. It was causing grouping
// flags to disappear and who know what else...
//
// Revision 1.53  2001/12/18 01:37:34  dce
// When a character saves all affects are removed from the
// character and reapplied. This applies to innate affects.
//
// Revision 1.52  2001/12/16 20:07:53  dce
// Fixed a problem where players could get the max dam and hitroll
// possible by changing their alignment and getting "zapped" by
// alignment sensitive equipment. The "zapped" they would not lose
// the +hitroll or damroll effects because of silly Hubis code.
//
// Revision 1.51  2001/12/07 02:09:56  dce
// Linkdead players will now lose exp when they die.
// Linkdead shapechanged players will now shapechange
// to their original form before linking out.
//
// Revision 1.50  2001/03/24 05:12:01  dce
// Objects will now accept a level through olc and upon
// booting the objects. The level code for the players will
// follow.
//
// Revision 1.49  2001/01/12 03:45:50  dce
// *** empty log message ***
//
// Revision 1.48  2001/01/05 01:30:24  mtp
// moved assignement of mobs REAL NUM to before trigger check to allow
// better error message (with REAL VNUM)
//
// Revision 1.47  2000/11/28 01:37:03  mtp
// better error messgae if mobprog seen
//
// Revision 1.46  2000/11/28 01:10:58  mtp
// removed more mobprog stuff
//
// Revision 1.44  2000/11/21 01:03:00  rsd
// Added back rlog messages from prior to the addition
// of the $log$ string.
//
// Revision 1.43  2000/11/15 00:24:09  mtp
// removed a couple of fprintf(stderr) lines which showed quests loading
//
// Revision 1.42  2000/11/07 01:48:17  mtp
// added check for qsubclass stuff in real_quest search routine and
// also changed function according to new prototype
//
// Revision 1.41  2000/11/03 21:25:59  jimmy
// Added debug to print out bogus exits
//
// Revision 1.40  2000/11/03 20:31:48  jimmy
// removed last version
//
// Revision 1.38  2000/11/03 05:37:17  jimmy
// Removed the quest.h file from structs.h arg!! and placed it
// only in the appropriate files
// Updated the dependancies in the Makefile and created
// make supahclean.
//
// Revision 1.37  2000/10/31 23:31:44  mtp
// changed harreferences to misc/quest to ALL_QUEST_FILE
//
// Revision 1.36  2000/10/31 00:43:37  mud
// fixed a memlry leak in real_quest
// /s
//
// Revision 1.35  2000/10/27 00:34:45  mtp
// extra info for booting quests and a real_quest fn to find array
// value given vnum of quest
//
// Revision 1.34  2000/10/11 23:54:20  rsd
// move the piece of delete player that removes the player
// from the index to another independant function that
// delete_player calls.  the new function is
// delete_player_from_index
//
// Revision 1.33  2000/06/05 19:03:59  rsd
// Set players mv to be 100 or 2xCON whichever is maximum
// when they are created.
//
// Revision 1.32  2000/06/01 20:09:16  rsd
// Deleted a bunch of debug log messages from the init_weather()
// section. Also made other log messgaes look better.
//
// Revision 1.31  2000/05/29 20:40:51  rsd
// Altered ch->points.max_move to = GET_CON(ch) * 2
// as opposed to 82 hard coded movement points.
//
// Revision 1.30  2000/04/26 22:51:45  rsd
// made a delete_player function
//
// Revision 1.29  2000/04/22 22:35:49  rsd
// Altered comment header while browsing the file.
//
// Revision 1.28  2000/03/20 04:32:39  rsd
// added comments regarding void reboot_wizlists(void) as it
// pertains to the removal of autowiz
//
// Revision 1.27  2000/03/08 22:05:09  mtp
// fixed hidden exit with no door? for some reason setting EX_DESCRIPT seems to override
// the other stuff about an exit...
//
// Revision 1.26  1999/11/29 00:21:47  cso
// removed unused variables to kill compile warnings
//
// Revision 1.25  1999/11/28 23:09:31  cso
// took unused argument from all calls to roll_natural_abils
// new fn: setup_mob. does some of the work read_mobile used to
// free_char: added call to free(ch->casting.misc) to plug mem leak
//
// Revision 1.24  1999/10/04 20:00:50  rsd
// Fixed some function associated with reading in text files.
// in do_reboot.  The read new truncates the files instead of
// overflowing. good enough.
//
// Revision 1.23  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.22  1999/09/04 18:46:52  jimmy
// More small but important bug fixes found with insure.  These are all runtime fixes.
//
// Revision 1.21  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most significant
// changes were moving all the BREATH's to within normal spell range, and
// fixing the way socials were allocated.  Too many small fixes to list them
// all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.20  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.19  1999/07/21 03:10:19  jimmy
// added an oversight to free_char.  Forgot to release mem for spell lists
// just in case it was still there when a player was free'd
// --gurlaek
//
// Revision 1.18  1999/07/09 22:30:27  jimmy
// Attempt to control the spiraling of memory.  Added a free() to the
// prompt code in comm.c to free memory allocated by parse_color().
// made a global structure dummy_mob and malloc'ed it for mobs
// to share as their player_specials to cut memory.
// gurlaek
//
// Revision 1.17  1999/07/06 19:57:05  jimmy
// This is a Mass check-in of the new skill/spell/language assignment system.
// This New system combines the assignment of skill/spell/language for
// both mobs and PCs.  LOts of code was touched and many errors were fixed.
// MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
// MObs now get random skill/spell/language levels baseed on their race/class/level
// that exactly align with PC's.  PC's no longer have to rent to use skills gained
// by leveling or when first creating a char.  Languages no longer reset to defaults
// when a PC levels.  Discovered that languages have been defined right in the middle
// of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
// the mob files to compensate for the 13 to -1 class change.
// --gurlaek 7/6/1999
//
// Revision 1.16  1999/06/30 18:25:04  jimmy
// >> This is a major conversion from the 18 point attribute system to the
// >> 100 point attribute system.  A few of the major changes are:
// >> All attributes are now on a scale from 0-100
// >> Everyone views attribs the same but, the attribs for one race
// >>   may be differeent for that of another even if they are the
// >>   same number.
// >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
// >> Mobs now have individual random attributes based on race/class.
// >> The STR_ADD attrib has been completely removed.
// >> All bonus tables for attribs in constants.c have been replaced by
// >>   algorithims that closely duplicate the tables except on a 100 scale.
// >> Some minor changes:
// >> Race selection at char creation can now be toggled by using
// >>   <world races off>
// >> Lots of cleanup done to affected areas of code.
// >> Setting attributes for mobs in the .mob file no longer functions
// >>   but is still in the code for later use.
// >> We now have a spare attribut structure in the pfile because the new
// >>   system only used three instead of four.
// >> --gurlaek 6/30/1999
//
// Revision 1.15  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to 
// clarify their behavior to the compiler.  The name approval code was also 
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the 
// xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
// --Gurlaek 6/10/1999
//
// Revision 1.14  1999/05/04 17:19:33  dce
// Name accept system...version one...original code by Fingh, fixed up to work
// by Zantir.
//
// Revision 1.13  1999/04/09 17:25:33  jen
// Mobs now get abil rolls (unless they're special circle 3 ones).
// The rolls depend on class & species.
//
// Revision 1.12  1999/04/07 01:20:18  dce
// Allows extra descriptions on no exits.
//
// Revision 1.11  1999/03/06 23:51:54  dce
// Add's chant songs, and can only chant once every four hours
//
// Revision 1.10  1999/03/03 20:11:02  jimmy
// Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
// Spellbooks now have to be held to scribe as well as a quill in the other hand.
// 
// -fingon
//
// Revision 1.9  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
// 
// Revision 1.8  1999/02/26 18:42:19  jimmy
// Added obj = NULL in free_obj to help stop pointers to
// raw memory for objects crashing the mud.
// 
// fingon
//
// Revision 1.7  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.6  1999/02/06 00:40:36  jimmy
// Major change to incorporate aliases into the pfile
// moved alias structure from interpreter.h to structs.h
// heavily modified alias code in interpreter.c
// Jimmy Kincaid AKA fingon
//
// Revision 1.5  1999/02/05 07:47:42  jimmy
// Added Poofs to the playerfile as well as 4 extra strings for
// future use.  fingon
//
// Revision 1.4  1999/02/02 07:35:17  jimmy
// spellcasters now lose all memmed spells at death without
// haveing to quit and log back in.
//
// Revision 1.3  1999/02/01 08:18:12  jimmy
// improved build counter
//
// Revision 1.2  1999/01/30 22:12:02  mud
// Indented entire file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.55
log
@Removes any saved size on a character.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.54 2001/12/21 02:44:35 dce Exp $
d560 6
a565 4
    if (level <10)
      hit = (sbyte) (level/1.5);
    else if (level < 30)
      hit = (sbyte) (level/1.8);
d567 9
a575 3
      hit = (sbyte) (level/1.3);	/*50 and under equation*/
    else if (level >= 50)
      hit = (sbyte) (level/1.4);	 /*51 and over equation*/
d5221 3
@


1.54
log
@Undid what I previous just did. It was causing grouping
flags to disappear and who know what else...
@
text
@d1 1
a1 1
// $Id: db.c,v 1.53 2001/12/18 01:37:34 dce Exp $
d3774 42
a3815 1
  GET_SIZE(ch) = st->size;
d5213 4
@


1.53
log
@When a character saves all affects are removed from the
character and reapplied. This applies to innate affects.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.52 2001/12/16 20:07:53 dce Exp $
d4268 2
d4271 1
a4271 1
  ch->char_specials.saved.affected_by = 0;
d4273 1
a4273 1
  ch->char_specials.saved.affected_by3 = 0;
a4274 1
  
d5172 4
@


1.52
log
@Fixed a problem where players could get the max dam and hitroll
possible by changing their alignment and getting "zapped" by
alignment sensitive equipment. The "zapped" they would not lose
the +hitroll or damroll effects because of silly Hubis code.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.51 2001/12/07 02:09:56 dce Exp $
d48 2
a49 1

a4160 1

d4267 6
d4279 4
d5171 6
@


1.51
log
@Linkdead players will now lose exp when they die.
Linkdead shapechanged players will now shapechange
to their original form before linking out.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.50 2001/03/24 05:12:01 dce Exp $
d47 1
d4169 2
a4170 2
  sh_int hit, mana, move;
  sbyte stdam, hitr;
d4172 3
a4174 4
   * save current values, because unequip_char will call
   * affect_total(), which will reset points to lower values
   * if player is wearing +points items.  We will restore old
   * points level after reequiping.
d4176 4
a4179 5
  hit = GET_HIT(ch);
  mana = GET_MANA(ch);
  move = GET_MOVE(ch);
  stdam = GET_DAMROLL(ch);
  hitr = GET_HITROLL(ch);
d4245 5
a4249 3
  /*EDITED OUT FOR REAL RACES..... BANYAL
    st->points.hitroll = 0;
  st->points.damroll = 0;*/
a4260 3
  
  
  
d4279 10
a4288 7
  
  /* restore our points to previous level */
  GET_HIT(ch) = hit;
  GET_MANA(ch) = mana;
  GET_MOVE(ch) = move;
  GET_DAMROLL(ch) = stdam;	/*Real race stuff...banyal*/
  GET_HITROLL(ch) = hitr;	
d5161 5
@


1.50
log
@Objects will now accept a level through olc and upon
booting the objects. The level code for the players will
follow.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.49 2001/01/12 03:45:50 dce Exp $
d46 2
d3682 1
d3684 11
a3694 1
  if (IS_NPC(ch) || !ch->desc)
d3696 1
d5160 5
@


1.49
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: db.c,v 1.48 2001/01/05 01:30:24 mtp Exp $
d2347 9
a2355 3
      (retval = sscanf(line, " %d %s %s", t, f1, f2)) != 3) {
    fprintf(stderr, "Format error in first numeric line (expecting 3 args, got %d), %s\n", retval, buf2);
    /* exit(1);*/
d2360 1
d5146 3
@


1.48
log
@moved assignement of mobs REAL NUM to before trigger check to allow
better error message (with REAL VNUM)
@
text
@d1 1
a1 1
// $Id: db.c,v 1.47 2000/11/28 01:37:03 mtp Exp mtp $
d2052 3
a2054 3
  mob_proto[i].points.coins.gold = ((int) (j/200));
  j = ((int)((18*k)/100)) + (j % 200);
  mob_proto[i].points.coins.silver = ((int) (j/20));
d2056 2
a2057 2
    j = ((int)((.5*k)/100)) + (j % 50);
  j = ((int)((2*k)/100)) + (j % 50);
d5139 4
@


1.47
log
@better error messgae if mobprog seen
@
text
@d1 1
a1 1
// $Id: db.c,v 1.46 2000/11/28 01:10:58 mtp Exp mtp $
d2255 1
a2290 1
  mob_proto[i].nr = i;
d5139 3
@


1.46
log
@removed more mobprog stuff
@
text
@d1 1
a1 1
// $Id: db.c,v 1.44 2000/11/21 01:03:00 rsd Exp $
d2297 1
a2297 1
	  fprintf(stderr,"Mob %d has a mobprog still!\n",i);
d5139 3
@


1.45
log
@removed mobprog stuff
@
text
@d1 1
a1 1
// $Id: db.c,v 1.44 2000/11/21 01:03:00 rsd Exp mtp $
a34 1
void mprog_read_programs(FILE * fp, struct index_data * pMobIndex);
d2294 7
a2300 4
  if (letter == '>') {
    ungetc(letter, mob_f);
    (void)  mprog_read_programs(mob_f, &mob_index[i]);
  } else ungetc(letter, mob_f);
a4959 26
  /* MOBProg functions */
  
  /* This routine transfers between alpha and numeric forms of the
   * mob_prog bitvector types.  This allows the use of the words in the
   * mob/script files.
   */

int mprog_name_to_type (char *name)
{
  if (!str_cmp(name, "in_file_prog"  ))    return IN_FILE_PROG;
  if (!str_cmp(name, "act_prog"      ))    return ACT_PROG;
  if (!str_cmp(name, "speech_prog"   ))    return SPEECH_PROG;
  if (!str_cmp(name, "rand_prog"     ))    return RAND_PROG;
  if (!str_cmp(name, "fight_prog"    ))    return FIGHT_PROG;
  if (!str_cmp(name, "hitprcnt_prog" ))    return HITPRCNT_PROG;
  if (!str_cmp(name, "death_prog"    ))    return DEATH_PROG;
  if (!str_cmp(name, "entry_prog"    ))    return ENTRY_PROG;
  if (!str_cmp(name, "greet_prog"    ))    return GREET_PROG;
  if (!str_cmp(name, "all_greet_prog"))    return ALL_GREET_PROG;
  if (!str_cmp(name, "give_prog"     ))    return GIVE_PROG;
  if (!str_cmp(name, "bribe_prog"    ))    return BRIBE_PROG;
  
  return(ERROR_PROG);
}


a5068 79
/* This routine reads in scripts of MOBprograms from a file */

MPROG_DATA* mprog_file_read(char *f, MPROG_DATA *mprg,
			    struct index_data *pMobIndex)
{
  
  char        MOBProgfile[ MAX_INPUT_LENGTH ];
  MPROG_DATA *mprg2;
  FILE       *progfile;
  char        letter;
  bool        done = FALSE;
  
  sprintf(MOBProgfile, "%s/%s", MOB_DIR, f);
  
  progfile = fopen(MOBProgfile, "r");
  if (!progfile)
    {
      sprintf(err_buf, "Mob: %d couldnt open mobprog file", pMobIndex->virtual);
      log(err_buf);
      exit(1);
    }
  
  mprg2 = mprg;
  switch (letter = fread_letter(progfile))
    {
    case '>':
      break;
    case '|':
      log("empty mobprog file.");
      exit(1);
      break;
    default:
      log("in mobprog file syntax error.");
      exit(1);
      break;
    }
  
  while (!done)
    {
      mprg2->type = mprog_name_to_type(fread_word(progfile));
      switch (mprg2->type)
        {
	case ERROR_PROG:
	  log("mobprog file type error");
	  exit(1);
          break;
	case IN_FILE_PROG:
	  log("mprog file contains a call to file.");
	  exit(1);
          break;
	default:
	  sprintf(buf2, "Error in file %s", f);
	  pMobIndex->progtypes = pMobIndex->progtypes | mprg2->type;
	  mprg2->arglist       = fread_string(progfile,buf2);
	  mprg2->comlist       = fread_string(progfile,buf2);
	  switch (letter = fread_letter(progfile))
            {
	    case '>':
	      mprg2->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
	      mprg2       = mprg2->next;
	      mprg2->next = NULL;
	      break;
	    case '|':
	      done = TRUE;
	      break;
	    default:
	      sprintf(err_buf,"in mobprog file %s syntax error.", f);
	      log(err_buf);
	      exit(1);
	      break;
            }
          break;
        }
    }
  fclose(progfile);
  return mprg2;
}


a5084 83
}


/* This procedure is responsible for reading any in_file MOBprograms.
 */

void mprog_read_programs(FILE *fp, struct index_data *pMobIndex)
{
  MPROG_DATA *mprg;
  char        letter;
  bool        done = FALSE;
  
  if ((letter = fread_letter(fp)) != '>')
    {
      sprintf(err_buf,"Load_mobiles: vnum %d MOBPROG char", pMobIndex->virtual);
      log(err_buf);
      exit(1);
    }
  pMobIndex->mobprogs = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
  mprg = pMobIndex->mobprogs;
  
  while (!done)
    {
      mprg->type = mprog_name_to_type(fread_word(fp));
      switch (mprg->type)
        {
	case ERROR_PROG:
	  sprintf(err_buf, "Load_mobiles: vnum %d MOBPROG type.", pMobIndex->virtual);
	  log(err_buf);
	  exit(1);
          break;
	case IN_FILE_PROG:
	  sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
	  mprg = mprog_file_read(fread_word(fp), mprg,pMobIndex);
	  fread_to_eol(fp);   /* need to strip off that silly ~*/
	  switch (letter = fread_letter(fp))
            {
	    case '>':
	      mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
	      mprg       = mprg->next;
	      mprg->next = NULL;
	      break;
	    case '|':
	      mprg->next = NULL;
	      fread_to_eol(fp);
	      done = TRUE;
	      break;
	    default:
	      sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG.", pMobIndex->virtual);
	      log(err_buf);
	      exit(1);
	      break;
            }
          break;
	default:
	  sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
	  pMobIndex->progtypes = pMobIndex->progtypes | mprg->type;
	  mprg->arglist        = fread_string(fp, buf2);
	  mprg->comlist        = fread_string(fp, buf2);
	  switch (letter = fread_letter(fp))
            {
	    case '>':
	      mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
	      mprg       = mprg->next;
	      mprg->next = NULL;
	      break;
	    case '|':
	      mprg->next = NULL;
	      fread_to_eol(fp);
	      done = TRUE;
	      break;
	    default:
	      sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG (%c).", 
		      pMobIndex->virtual, letter);
	      log(err_buf);
	      exit(1);
	      break;
            }
          break;
        }
    }
  
  return;
@


1.44
log
@Added back rlog messages from prior to the addition
of the $log$ string.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.43 2000/11/15 00:24:09 mtp Exp $
a1171 2
  MOBTrigger = TRUE;

d5325 4
@


1.43
log
@removed a couple of fprintf(stderr) lines which showed quests loading
@
text
@d1 1
a1 1
// $Id: db.c,v 1.42 2000/11/07 01:48:17 mtp Exp mtp $
a5325 11











d5327 3
d5404 137
@


1.42
log
@added check for qsubclass stuff in real_quest search routine and
also changed function according to new prototype
@
text
@d1 1
a1 1
// $Id: db.c,v 1.41 2000/11/03 21:25:59 jimmy Exp mtp $
a1785 1
	fprintf(stderr,"Booting the quest..\n");
a1820 2
	for (qnum=0;qnum<max_quests;qnum++)
		fprintf(stderr,"GOT QUEST %s (id = %d, stage = %d)\n",all_quests[qnum].quest_name,all_quests[qnum].quest_id,all_quests[qnum].maxstages);
d5338 4
@


1.41
log
@Added debug to print out bogus exits
@
text
@d1 1
a1 1
// $Id: db.c,v 1.40 2000/11/03 20:31:48 jimmy Exp $
d4882 1
a4882 1
int real_quest(int virtual)
d4890 6
d5341 3
@


1.40
log
@removed last version
@
text
@d1 1
a1 1
// $Id: db.c,v 1.38 2000/11/03 05:37:17 jimmy Exp $
d1896 1
d1898 2
a1899 1
  
d1903 8
a1910 3
	if (world[room].dir_option[door]->to_room != NOWHERE)
	  world[room].dir_option[door]->to_room =
	    real_room(world[room].dir_option[door]->to_room);
d1914 1
d5335 3
@


1.39
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1896 1
a1896 1
  register int room, door, rnum;
d1898 6
a1903 11
  for (room = 0; room <= top_of_world; room++) {
    for (door = 0; door < NUM_OF_DIRS; door++) {
      if (world[room].dir_option[door]) {
	/* added real_room --gurlaek 11/3/2000 */
	rnum = real_room(world[room].dir_option[door]->to_room);
	if (rnum != NOWHERE) {
	  world[room].dir_option[door]->to_room = rnum;
	}
      }
    }
  }
@


1.38
log
@Removed the quest.h file from structs.h arg!! and placed it
only in the appropriate files
Updated the dependancies in the Makefile and created
make supahclean.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.37 2000/10/31 23:31:44 mtp Exp $
d1896 1
a1896 1
  register int room, door;
d1898 11
a1908 6
  for (room = 0; room <= top_of_world; room++)
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (world[room].dir_option[door])
	if (world[room].dir_option[door]->to_room != NOWHERE)
	  world[room].dir_option[door]->to_room =
	    real_room(world[room].dir_option[door]->to_room);
d5332 6
@


1.37
log
@changed harreferences to misc/quest to ALL_QUEST_FILE
@
text
@d1 1
a1 1
// $Id: db.c,v 1.36 2000/10/31 00:43:37 mud Exp mtp $
d33 1
d5327 3
@


1.36
log
@fixed a memlry leak in real_quest
/s
@
text
@d1 1
a1 1
// $Id: db.c,v 1.35 2000/10/27 00:34:45 mtp Exp $
d1786 1
d1789 1
a1789 1
	if((fl = fopen("misc/quests","r")) == NULL)
d1799 1
a1799 1
	fl = fopen("misc/quests","r");
d5326 4
@


1.35
log
@extra info for booting quests and a real_quest fn to find array
value given vnum of quest
@
text
@d1 1
a1 1
// $Id: db.c,v 1.34 2000/10/11 23:54:20 rsd Exp mtp $
d4876 4
d5325 4
@


1.34
log
@move the piece of delete player that removes the player
from the index to another independant function that
delete_player calls.  the new function is
delete_player_from_index
@
text
@d1 1
a1 1
// $Id: db.c,v 1.33 2000/06/05 19:03:59 rsd Exp $
d41 1
d53 1
d55 1
d1166 2
d1778 45
d4872 21
d5321 6
@


1.33
log
@Set players mv to be 100 or 2xCON whichever is maximum
when they are created.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.32 2000/06/01 20:09:16 rsd Exp $
d158 1
d1360 2
a1361 6
/* Deleting them */
/* This function does no checks. All check must be made by calling
   funcitons.  */

int delete_player(char *name) {
  int i;
d1363 1
d1365 2
a1366 3
  FILE *player_index_file, *new_player_index_file, *player_fl;
  struct player_index_element *new_player_table;

d1378 1
d1383 2
a1384 1
    if(strcmp(plr_name, name)) {
d1387 3
a1389 1
    }  
d1395 15
d1423 1
a1423 2
  if ( !(new_player_table = (struct player_index_element *)
	 malloc(sizeof(struct player_index_element) * (top_of_p_table))) ) {
d5250 4
@


1.32
log
@Deleted a bunch of debug log messages from the init_weather()
section. Also made other log messgaes look better.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.31 2000/05/29 20:40:51 rsd Exp $
d4742 1
a4742 1
  ch->points.max_move = GET_CON(ch) * 2;
d5235 4
@


1.31
log
@Altered ch->points.max_move to = GET_CON(ch) * 2
as opposed to 82 hard coded movement points.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.30 2000/04/26 22:51:45 rsd Exp $
d1183 26
a1208 44
  if (time_info.hours <= 7)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
      Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
      log("end of <=7");
      
    }
  else if (time_info.hours == 8)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_RISE;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_RISE;
      Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_SET;
      Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_SET;
      log("end of ==8");
      
    }
  else if (time_info.hours <= 20)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_LIGHT;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
      Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_DARK;
      Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_DARK;
      log("end <= 20");
      
    }    
  else if (time_info.hours == 21)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_SET;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_SET;
      Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_RISE;
      Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_RISE;
      log("==21");
      
    }    
  else
    {
      Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
      Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
      Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
      Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_LIGHT;
      log("end else...");
    }
d1210 1
a1210 1
  log("setting up seasons");
d1213 25
a1237 36
  if(time_info.month < 4)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].season = WINTER;
      Hemispheres[HEMISPHERE_SOUTHWEST].season = SUMMER;
      Hemispheres[HEMISPHERE_NORTHEAST].season = WINTER;
      Hemispheres[HEMISPHERE_SOUTHEAST].season = SUMMER;
      log("winter");
      
    }
  else if(time_info.month < 8)  
    {
      Hemispheres[HEMISPHERE_NORTHWEST].season = SPRING;
      Hemispheres[HEMISPHERE_SOUTHWEST].season = AUTUMN;
      Hemispheres[HEMISPHERE_NORTHEAST].season = SPRING;
      Hemispheres[HEMISPHERE_SOUTHEAST].season = AUTUMN;
      log("spring");
      
    }
  else if(time_info.month < 12)
    {
      Hemispheres[HEMISPHERE_NORTHWEST].season = SUMMER;
      Hemispheres[HEMISPHERE_SOUTHWEST].season = WINTER;
      Hemispheres[HEMISPHERE_NORTHEAST].season = SUMMER;
      Hemispheres[HEMISPHERE_SOUTHEAST].season = WINTER;
      log("summer");
      
    }
  else
    {
      Hemispheres[HEMISPHERE_NORTHWEST].season = AUTUMN;
      Hemispheres[HEMISPHERE_SOUTHWEST].season = SPRING;
      Hemispheres[HEMISPHERE_NORTHEAST].season = AUTUMN;
      Hemispheres[HEMISPHERE_SOUTHEAST].season = SPRING;
      log("autumn");
      
    }
d1239 1
a1239 1
  sprintf(buf, "   Current Gametime: %dH %dD %dM %dY.", time_info.hours,
d1242 1
a1242 1
  log("calling init_weather");
d5235 4
@


1.30
log
@made a delete_player function
@
text
@d1 1
a1 1
// $Id: db.c,v 1.29 2000/04/22 22:35:49 rsd Exp $
d4771 1
a4771 1
  ch->points.max_move = 82;
d5264 3
@


1.29
log
@Altered comment header while browsing the file.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.28 2000/03/20 04:32:39 rsd Exp $
d94 3
a96 3
char *anews = NULL;
char *motd = NULL;		/* message of the day - mortals */
char *imotd = NULL;		/* message of the day - immorts */
a137 1
void build_player_index(void);
d151 2
a152 1
sh_int get_set_hit(int level, int race, int class, int state) ;sbyte get_set_hd(int level, int race, int class, int state); 
d156 1
d158 1
d1388 78
d4235 1
d4256 1
a4256 1
  } else if (!(player_table = (struct player_index_element *)
d4273 1
d5264 3
@


1.28
log
@added comments regarding void reboot_wizlists(void) as it
pertains to the removal of autowiz
@
text
@d1 1
a1 1
// $Id: db.c,v 1.27 2000/03/08 22:05:09 mtp Exp $
d3 1
a3 1
 *   File: db.c                                          Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
a18 1

d5182 4
@


1.27
log
@fixed hidden exit with no door? for some reason setting EX_DESCRIPT seems to override
the other stuff about an exit...
@
text
@d1 1
a1 1
// $Id: db.c,v 1.26 1999/11/29 00:21:47 cso Exp mtp $
d204 2
a205 2
#define MOB_MENTAL     17
#define MOB_MENTAL2    21
d211 4
d5181 4
@


1.26
log
@removed unused variables to kill compile warnings
@
text
@d1 1
a1 1
// $Id: db.c,v 1.25 1999/11/28 23:09:31 cso Exp cso $
d2996 1
a2996 1
/*          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
d3001 3
a3003 2
		     EX_LOCKED); */
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
d3005 1
d5177 3
@


1.25
log
@took unused argument from all calls to roll_natural_abils
new fn: setup_mob. does some of the work read_mobile used to
free_char: added call to free(ch->casting.misc) to plug mem leak
@
text
@d1 1
a1 1
// $Id: db.c,v 1.24 1999/10/04 20:00:50 rsd Exp $
a1838 1
  int choice_table[6] = {0};
a2604 1
  int rolls[6];
d5175 5
@


1.24
log
@Fixed some function associated with reading in text files.
in do_reboot.  The read new truncates the files instead of
overflowing. good enough.
@
text
@d1 1
a1 1
// $Id: db.c,v 1.23 1999/09/05 07:00:39 jimmy Exp $
d1840 1
a1840 1
  extern void roll_natural_abils(struct char_data *ch, int []);
d1911 1
a1911 1
  roll_natural_abils(mobproto, choice_table);  /* mobs now get rolled just like PC's */
d2601 34
d2639 1
a2639 1
  int i, rolls[6] = {0};
a2640 2
  extern void roll_natural_abils(struct char_data *ch, int []);
  extern void scale_attribs(struct char_data *ch);
d2654 4
a2657 1
  mob->player_specials = dummy_mob;
a2660 25
  /* mobs now get rolled just like PC's --gurlaek 6/28/1999 */
  roll_natural_abils(mob, rolls);
  mob->viewed_abils = mob->natural_abils;
  scale_attribs(mob);
  /* mobs now also have skills based on race/class/level just like PC's --gurlaek 7/3/1999*/
  set_skills(mob);
  update_skills(mob);
  if (!mob->points.max_hit) {    
    mob->points.max_hit = MAX(0, MIN(32000, (dice(mob->points.hit, mob->points.mana) + GET_EX_MAIN_HP(mob) + mob->points.move)));
  } else
    mob->points.max_hit = number(mob->points.hit, mob->points.mana);    
  
  
  mob->points.mana = mob->points.max_mana; /*rests mobs mana*/
  mob->points.move = mob->points.max_move;/*resets mob moves*/
  mob->points.hit = mob->points.max_hit;   /*sets full hps*/
  
  mob->player.time.birth = time(0);
  mob->player.time.played = 0;
  mob->player.time.logon = time(0);
  
  mob_index[i].number++;
  GET_ID(mob) = max_id++;
  assign_triggers(mob, MOB_TRIGGER);
  
d4259 2
d5177 5
@


1.23
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d4378 10
a4387 14
  do {
    fgets(tmp, READ_SIZE, fl);
    tmp[strlen(tmp) - 1] = '\0'; /* take off the trailing \n */
    strcat(tmp, "\r\n");

    if (!feof(fl)) {
      if (strlen(buf) + strlen(tmp) + 1 > MAX_STRING_LENGTH) {
        sprintf(buf, "SYSERR: %s: string too big (%d max)", name,
		MAX_STRING_LENGTH);
	log(buf);
	*buf = '\0';
	return -1;
      }
      strcat(buf, tmp);
d4389 3
a4391 4
  } while (!feof(fl));
  
  fclose(fl);
  
d5164 4
a5167 1
// $Log$
@


1.22
log
@More small but important bug fixes found with insure.  These are all runtime fixes.
@
text
@d1 1
d5169 1
@


1.21
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d2361 3
a2363 2
  while (get_line(fl, buf))
    num_of_cmds++;		/* this should be correct within 3 or so */
d2389 1
a2389 5
  /* fprintf(stderr, " %d me this one has a factor of %d done by set by 
     me, line \n", Z.number, Z.zone_factor);
  *//*
      cmd_no = 0;
    */
d4235 4
a4238 1
  
a4276 2
  while (ch->affected)
    affect_remove(ch, ch->affected);
d5149 1
a5149 1
  if (search_block2(test, iscommand, TRUE) >= 0)
d5151 1
a5151 1
  if (search_block2(test, smart_ass, TRUE) >= 0)
a5156 3
void dummy(void) {
  return;
}
@


1.20
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d1708 2
a1709 1
  
d1711 7
a1717 2
  
  CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
d2243 1
a2243 1
      fprintf(stderr, "Format error in third numeric line (expecting 6 args, got %d), %s\n", retval, buf2);
d2304 9
a2312 2
      get_line(obj_f, line);
      sscanf(line, " %d %d ", t, t + 1);
d2447 3
d2451 1
a2451 3
void get_one_line(FILE *fl, char *buf)
{
  if (fgets(buf, READ_SIZE, fl) == NULL) {
d2456 1
a2456 1
  buf[strlen(buf) - 1] = '\0'; /* take off the trailing \n */
d2468 5
a2487 2
    
    
d2501 5
@


1.19
log
@added an oversight to free_char.  Forgot to release mem for spell lists
just in case it was still there when a player was free'd
--gurlaek
@
text
@a76 1
FILE *player_fl = NULL;		/* file desc of player file	 */
d154 1
d172 1
a172 1
void boot_frags();
d919 1
a919 1
  char	name[MAX_NAME_LENGTH+1];
d925 2
a926 2
  frags and thus any errors in the frags should be fixed with a boot*/

d954 1
a954 1
    {/*loops through playerfile now its open and all is well*/
d961 1
a961 1
		break;/*solve the empty new character that happens*/
d963 2
a964 2
                {/*ok insert person with frag details.*/
		  /*1. copy all others down*/
d981 1
a981 1
		break;/*solve the empty new character that happens*/
d983 1
a983 2
                {/*ok insert person with frag details.*/
		  /*1. copy all others down*/
d1000 1
a1000 1

a1019 1
  
d1034 5
a1038 1
	
d1041 1
a1041 1

d1063 1
a1063 1
  
d1066 1
a1066 1

a1091 3
  log("Generating player index.");
  build_player_index();

a1267 2


d1269 1
a1269 2
void build_player_index(void)
{
d1271 1
a1271 1
  long size, recs;
d1273 7
a1279 2
  
  if (!(player_fl = fopen(PLAYER_FILE, "r+b"))) {
d1281 1
a1281 1
      perror("fatal error opening playerfile");
d1284 4
a1287 4
      log("No playerfile.  Creating a new one.");
      touch(PLAYER_FILE);
      if (!(player_fl = fopen(PLAYER_FILE, "r+b"))) {
	perror("fatal error opening playerfile");
d1293 6
a1298 6
  fseek(player_fl, 0L, SEEK_END);
  size = ftell(player_fl);
  rewind(player_fl);
  if (size % sizeof(struct char_file_u))
    fprintf(stderr, "\aWARNING:  PLAYERFILE IS PROBABLY CORRUPT!\n");
  recs = size / sizeof(struct char_file_u);
d1300 1
a1300 1
    sprintf(buf, "   %ld players in database.", recs);
d1309 27
a1335 9
  for (; !feof(player_fl);) {
    fread(&dummy, sizeof(struct char_file_u), 1, player_fl);
    if (!feof(player_fl)) {	/* new record */
      nr++;
      CREATE(player_table[nr].name, char, strlen(dummy.name) + 1);
      for (i = 0;
	   (*(player_table[nr].name + i) = LOWER(*(dummy.name + i))); i++);
      player_table[nr].id = dummy.char_specials_saved.idnum;
      top_idnum = MAX(top_idnum, dummy.char_specials_saved.idnum);
d1338 1
d1343 36
a3478 1

d3480 1
a3480 2
int load_char(char *name, struct char_file_u * char_element)
{
d3483 7
a3489 1
  
d3491 12
a3502 5
    fseek(player_fl, (long) (player_i * sizeof(struct char_file_u)), SEEK_SET);
    fread(char_element, sizeof(struct char_file_u), 1, player_fl);
    return (player_i);
  }else
    return (-1);
a3504 3



d3510 2
a3511 2
void save_char(struct char_data * ch, int load_room)
{
d3513 2
d3516 1
a3516 1
  if (IS_NPC(ch) || !ch->desc || GET_PFILEPOS(ch) < 0)
d3518 1
a3518 1
  
d3520 21
d3542 9
a3550 11
  strncpy(st.host, ch->desc->host, HOST_LENGTH);
  st.host[HOST_LENGTH] = '\0';
  
  //    if (load_room == NOWHERE);
  // else
  //   st.player_specials_saved.load_room = world[load_room].number;
  
  strcpy(st.pwd, GET_PASSWD(ch));
  
  fseek(player_fl, GET_PFILEPOS(ch) * sizeof(struct char_file_u), SEEK_SET);
  fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
d4123 13
a4744 10
void save_char_file_u(struct char_file_u st)
{
  int player_i;
  int find_name(char *name);
  if((player_i = find_name(st.name)) >=0 )
    {
      fseek(player_fl, player_i * sizeof(struct char_file_u), SEEK_SET);
      fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
    }
}
@


1.18
log
@Attempt to control the spiraling of memory.  Added a free() to the
prompt code in comm.c to free memory allocated by parse_color().
made a global structure dummy_mob and malloc'ed it for mobs
to share as their player_specials to cut memory.
gurlaek
@
text
@d4117 1
d4122 6
@


1.17
log
@This is a Mass check-in of the new skill/spell/language assignment system.
This New system combines the assignment of skill/spell/language for
both mobs and PCs.  LOts of code was touched and many errors were fixed.
MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
MObs now get random skill/spell/language levels baseed on their race/class/level
that exactly align with PC's.  PC's no longer have to rent to use skills gained
by leveling or when first creating a char.  Languages no longer reset to defaults
when a PC levels.  Discovered that languages have been defined right in the middle
of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
the mob files to compensate for the 13 to -1 class change.
--gurlaek 7/6/1999
@
text
@d35 1
d1847 1
a1847 1
  CREATE(mobproto->player_specials, struct player_special_data, 1);
d2046 2
a2532 1
  struct player_special_data *dummy_mob; /* dummy spec area for mobs */ 
a2545 2
  /* mobs now get a real player_specials not a dummy_mob */
  CREATE(dummy_mob, struct player_special_data, 1);
d4118 1
a4118 1
  if (ch->player_specials) {
@


1.16
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@d108 1
a108 1
struct player_special_data dummy_mob;	/* dummy spec area for mobs	 */
d120 2
a121 1
void set_mob_skills(int i, int class, int race);
d1846 1
d1850 1
a1850 1

d1935 2
a1936 1
  set_mob_skills(i, t[3], t[4]);
d2044 1
a2044 1
  
a2047 1
  
d2049 1
a2049 2
  
  mob_proto[i].player_specials = &dummy_mob;
d2530 1
d2539 1
a2539 1
  
d2543 4
d2549 1
a2549 1

d2554 3
a2556 1

a4116 1
  /*  void free_alias(struct alias * a); */
d4118 1
a4118 18
  if (ch->player_specials != NULL && ch->player_specials != &dummy_mob) {

    /*  This is no longer used. --Fingon

      while ((a = GET_ALIASES(ch)) != NULL) {
      GET_ALIASES(ch) = (GET_ALIASES(ch))->next;
      free_alias(a);
      }
    */

    /*  if (ch->player_specials->last_olc_targ)
	free(ch->player_specials->last_olc_targ);
	if (ch->player_specials->last_olc_mode)
	free(ch->player_specials->last_olc_mode);
	if (ch->player_specials->roll[6])
	free(ch->player_specials->roll[6]);
	if (ch->player_specials->ignored)
	free(ch->player_specials->ignored); */
a4119 2
    if (IS_NPC(ch))
      log("SYSERR: Mob had player_specials allocated!");
d4559 3
a4561 3
      SET_SKILL(ch, i, 0)
	else   
	  SET_SKILL(ch, i, 1000);
@


1.15
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d39 1
a39 1
void load_results(struct char_data *ch);
d111 6
d174 6
d1005 8
a1769 1
  
d1773 3
a1775 7

//  mob_proto[i].real_abils.str = 11;
//  mob_proto[i].real_abils.intel = 11;
//  mob_proto[i].real_abils.wis = 11;
//  mob_proto[i].real_abils.dex = 11;
//  mob_proto[i].real_abils.con = 15;
//  mob_proto[i].real_abils.cha = 11;
d1844 4
a1847 86

  /* The following code "rolls" abilities for the mobs based on their classes. 
     This makes for more realistic mob stats.  Selandria, 4-9-99
  */

  if (t[3] == MCLASS_WARRIOR || t[3] == MCLASS_PALADIN || t[3] == MCLASS_ANTI_PALADIN || t[3] == MCLASS_RANGER)
  {
    mob_proto[i].real_abils.str = number(15, 18);
    mob_proto[i].real_abils.intel = number(9, 14);
    mob_proto[i].real_abils.wis = number(9, 14);
    mob_proto[i].real_abils.dex = number(10, 15);
    mob_proto[i].real_abils.con = 17;
    mob_proto[i].real_abils.cha = 12;
  }
  else if (t[3] == MCLASS_SORCERER || t[3] == MCLASS_NECROMANCER || t[3] == MCLASS_CONJURER)
  {
    mob_proto[i].real_abils.str = 9;
    mob_proto[i].real_abils.intel = number(15, 18);
    mob_proto[i].real_abils.wis = number(12, 17);
    mob_proto[i].real_abils.dex = number(11, 16);
    mob_proto[i].real_abils.con = 11;
    mob_proto[i].real_abils.cha = number(10, 18);
  }
  else if (t[3] == MCLASS_CLERIC || t[3] == MCLASS_SHAMAN || t[3] == MCLASS_DRUID)
  {
    mob_proto[i].real_abils.str = number(10, 16);
    mob_proto[i].real_abils.intel = number(12, 17);
    mob_proto[i].real_abils.wis = number(15, 18);
    mob_proto[i].real_abils.dex = 12;
    mob_proto[i].real_abils.con = number(9, 14);
    mob_proto[i].real_abils.cha = 12;
  }
  else if (t[3] == MCLASS_THIEF || t[3] == MCLASS_MERCENARY || t[3] == MCLASS_ASSASSIN)
  {
    mob_proto[i].real_abils.str = number(11, 16);
    mob_proto[i].real_abils.intel = 12;
    mob_proto[i].real_abils.wis = 12;
    mob_proto[i].real_abils.dex = number(15, 18);
    mob_proto[i].real_abils.con = number(9, 14);
    mob_proto[i].real_abils.cha = 12;
  }
  else
  {
    mob_proto[i].real_abils.str = number(10, 18);
    mob_proto[i].real_abils.intel = 11;
    mob_proto[i].real_abils.wis = 11;
    mob_proto[i].real_abils.dex = 11;
    mob_proto[i].real_abils.con = 15;
    mob_proto[i].real_abils.cha = 11;
  }

  if (t[4] == SPECIES_ELF || t[4] == SPECIES_DROW_ELF || t[4] == SPECIES_HALF_ELF)
  {
    mob_proto[i].real_abils.str = MIN(16, mob_proto[i].real_abils.str);
    mob_proto[i].real_abils.intel = MIN(18, mob_proto[i].real_abils.intel + 1);
  }
  else if (t[4] == SPECIES_GNOME || t[4] == SPECIES_HALFLING)
  {
    mob_proto[i].real_abils.str = MIN(14, mob_proto[i].real_abils.str);
    mob_proto[i].real_abils.dex = MIN(18, mob_proto[i].real_abils.dex + 1);
  }
  else if (t[4] == SPECIES_DWARF || t[4] == SPECIES_DUERGAR)
  {
    mob_proto[i].real_abils.con = MIN(18, mob_proto[i].real_abils.con + 1);
    mob_proto[i].real_abils.cha = MIN(14, mob_proto[i].real_abils.cha);
  }
  else if (t[4] == SPECIES_OGRE || t[4] == SPECIES_GIANT)
  {
    mob_proto[i].real_abils.str = MIN(18, mob_proto[i].real_abils.str + 1);
    mob_proto[i].real_abils.dex = MIN(14, mob_proto[i].real_abils.dex);
  }
  else if (t[4] == SPECIES_TROLL)
  {
    mob_proto[i].real_abils.con = 18;
  }
  else if (t[4] == SPECIES_DRAGON)
  {
    mob_proto[i].real_abils.str = MIN(18, mob_proto[i].real_abils.str + 1);
    mob_proto[i].real_abils.intel = MIN(18, mob_proto[i].real_abils.intel + 2);
    mob_proto[i].real_abils.cha = MIN(18, mob_proto[i].real_abils.cha + 1);
  }
  else if (t[4] == SPECIES_GOBLIN)
  {
    mob_proto[i].real_abils.str = MIN(15, mob_proto[i].real_abils.str);
    mob_proto[i].real_abils.cha = MIN(12, mob_proto[i].real_abils.cha);
  }
d1948 1
a1948 1

d1961 2
a1962 7
    RANGE(3, 25);
    mob_proto[i].real_abils.str = num_arg;
  }

  CASE("StrAdd") {
    RANGE(0, 100);
    mob_proto[i].real_abils.str_add = num_arg;    
d1966 2
a1967 2
    RANGE(3, 25);
    mob_proto[i].real_abils.intel = num_arg;
d1971 2
a1972 2
    RANGE(3, 25);
    mob_proto[i].real_abils.wis = num_arg;
d1976 2
a1977 2
    RANGE(3, 25);
    mob_proto[i].real_abils.dex = num_arg;
d1981 2
a1982 2
    RANGE(3, 25);
    mob_proto[i].real_abils.con = num_arg;
d1986 2
a1987 2
    RANGE(3, 25);
    mob_proto[i].real_abils.cha = num_arg;
d2094 1
a2094 1
  mob_proto[i].aff_abils = mob_proto[i].real_abils;
d2525 1
a2525 1
  int i;
d2527 3
a2529 1
  
d2543 10
a2552 5
  
  if (!mob->points.max_hit) {    mob->points.max_hit = MAX(0, MIN(32000,
								  (dice(mob->points.hit, mob->points.mana) +   GET_EX_MAIN_HP(mob) +
								   mob->points.move)));      } else    mob->points.max_hit =
													 number(mob->points.hit, mob->points.mana);    
d2717 1
a2717 1
  
d3460 1
a3460 1

d3463 1
a3463 1
  if (dex <= 8)
d3465 1
a3465 1
  else if (dex <= 10)
d3467 1
a3467 1
  else if (dex <= 14)
d3469 1
a3469 1
  else if (dex <= 16)
d3471 1
a3471 1
  else if (dex <= 18)
d3473 1
a3473 1
  else if (dex <= 19)
d3475 1
a3475 1
  else if (dex <= 20)
d3477 1
a3477 1
  else if (dex <= 21)
d3483 1
d3519 5
a3523 3
  ch->view_abils = st->abilities;
  ch->vaff_abils = st->abilities;
  
a3537 4
/* Poofin/out is now saved --Fingon
 *  POOFIN(ch) = NULL;
 *  POOFOUT(ch) = NULL;
 */ 
d3631 1
d3639 1
a3639 1
  else if (GET_CON(ch) < 17)
d3641 1
a3641 1
  else if (GET_CON(ch) < 19)
d3643 1
a3643 1
  else if (GET_CON(ch) < 21)
d3645 1
a3645 1
  else if (GET_CON(ch) < 23)
d3647 1
a3647 1
  else if (GET_CON(ch) < 25)
d3649 1
a3649 1
  else if (GET_CON(ch) < 26)
a3650 2
  else
    bonus = GET_LEVEL(ch) * 5;
d3655 1
d3710 3
a3712 6

/* Two functions here done by proky for his chages in car_to_ store */

void change_affected_stats(struct char_data * ch)
{
  GET_ADD(ch) = GET_ADD_VAFF(ch);
d3714 168
a3881 95
  case RACE_GNOME:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)GNOME_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)GNOME_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)GNOME_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)GNOME_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)GNOME_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)GNOME_CON));
    break;
  case RACE_OGRE:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)OGRE_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)OGRE_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)OGRE_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)OGRE_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)OGRE_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)OGRE_CON));
    break;
  case RACE_HUMAN:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HUMAN_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HUMAN_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HUMAN_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HUMAN_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HUMAN_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HUMAN_CON));
    break;
  case RACE_BARBARIAN:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)BARBARIAN_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)BARBARIAN_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)BARBARIAN_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)BARBARIAN_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)BARBARIAN_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)BARBARIAN_CON));
    break;
  case RACE_TROLL:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)TROLL_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)TROLL_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)TROLL_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)TROLL_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)TROLL_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)TROLL_CON));
    break;
  case RACE_HALF_ELF:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALF_ELF_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALF_ELF_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALF_ELF_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALF_ELF_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALF_ELF_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALF_ELF_CON));
    break;
  case RACE_DROW_ELF:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DROW_ELF_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DROW_ELF_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DROW_ELF_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DROW_ELF_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DROW_ELF_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DROW_ELF_CON));
    break;
  case RACE_HALFLING:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALFLING_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALFLING_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALFLING_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALFLING_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALFLING_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALFLING_CON));
    break;
  case RACE_DWARF:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DWARF_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DWARF_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DWARF_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DWARF_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DWARF_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DWARF_CON));
    break;
  case RACE_DUERGAR:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DUERGAR_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DUERGAR_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DUERGAR_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DUERGAR_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DUERGAR_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DUERGAR_CON));
    break;
  case RACE_ORC:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ORC_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ORC_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ORC_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ORC_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ORC_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ORC_CON));
    break;
  case RACE_ELF:
    GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ELF_STR));
    GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ELF_INT));
    GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ELF_DEX));
    GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ELF_WIS));
    GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ELF_CHA));
    GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ELF_CON));
a3886 107
void load_results(struct char_data *ch)
{
  /*Ok this function's aim is to convert the data in view_abils
    into the function the computer uses real_abils, then it will aslo
    add any effects that might be effecting the player*/
  GET_RADD(ch) = GET_ADD_VIEW(ch);
  switch (GET_RACE(ch)) {
  case RACE_GNOME:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)GNOME_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)GNOME_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)GNOME_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)GNOME_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)GNOME_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)GNOME_CON));
    break;
  case RACE_HUMAN:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HUMAN_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HUMAN_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HUMAN_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HUMAN_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HUMAN_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HUMAN_CON));
    break;
  case RACE_OGRE:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)OGRE_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)OGRE_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)OGRE_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)OGRE_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)OGRE_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)OGRE_CON));
    break;
  case RACE_BARBARIAN:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)BARBARIAN_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)BARBARIAN_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)BARBARIAN_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)BARBARIAN_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)BARBARIAN_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)BARBARIAN_CON));
    break;
  case RACE_TROLL:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)TROLL_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)TROLL_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)TROLL_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)TROLL_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)TROLL_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)TROLL_CON));
    break;
  case RACE_HALF_ELF:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALF_ELF_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALF_ELF_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALF_ELF_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALF_ELF_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALF_ELF_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALF_ELF_CON));
    break;
  case RACE_DROW_ELF:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DROW_ELF_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DROW_ELF_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DROW_ELF_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DROW_ELF_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DROW_ELF_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DROW_ELF_CON));
    break;
  case RACE_HALFLING:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALFLING_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALFLING_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALFLING_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALFLING_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALFLING_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALFLING_CON));
    break;
  case RACE_DWARF:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DWARF_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DWARF_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DWARF_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DWARF_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DWARF_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DWARF_CON));
    break;
  case RACE_DUERGAR:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DUERGAR_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DUERGAR_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DUERGAR_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DUERGAR_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DUERGAR_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DUERGAR_CON));
    break;
  case RACE_ORC:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ORC_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ORC_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ORC_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ORC_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ORC_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ORC_CON));
    break;
  case RACE_ELF:
    GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ELF_STR));
    GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ELF_INT));
    GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ELF_DEX));
    GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ELF_WIS));
    GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ELF_CHA));
    GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ELF_CON));
    break;
  }
  return ;
}

a3948 2
  
  ch->vaff_abils = ch->view_abils;
d3966 1
a3966 1
  st->abilities = ch->view_abils;
a4582 9
  
  /* ch->real_abils.intel = 25;
   *ch->real_abils.wis = 25;
   *ch->real_abils.dex = 25;
   *ch->real_abils.str = 25;
   *ch->real_abils.str_add = 100;
   *ch->real_abils.con = 25;
   *ch->real_abils.cha = 25;
   */
@


1.14
log
@Name accept system...version one...original code by Fingh, fixed up to work
by Zantir.
@
text
@d110 1
a110 1

d157 1
a157 1
void Read_Invalid_List(void);
d350 12
a361 4
   */	sh_int main = 0;
   sh_int face = 1;
   int cfactor = 100;
   int sfactor = 100;
d363 6
a368 13
   /*
     The cfactor is the factor of class to adjust exp number is percentage
     100 being standard no change*/
   
   
   
   
   switch(class) 
     {
     case MCLASS_VOID:
       cfactor = 100;
       break;
     case MCLASS_SORCERER:
d371 21
a391 2
     case MCLASS_CLERIC:
       cfactor = 80;
d393 59
a451 78
     case MCLASS_WARRIOR:
       cfactor = 120;
       break;
     case MCLASS_THIEF:
       cfactor = 90;
       break;
     default:
       cfactor = 100;
       break;
     }
   
   switch(race) 
     {
     case SPECIES_OTHER:
       sfactor = 110;
       break;
     case SPECIES_TROLL:
       sfactor = 120;
       break;
     case SPECIES_OGRE:
       sfactor = 130;
       break;
       
     case SPECIES_UNDEAD:
       sfactor = 100;
       break;
     case SPECIES_HUMANOID:
       sfactor = 100;
       break;
     case SPECIES_DRAGON:
       sfactor = 130;
       break;
     case SPECIES_DEMON:
       sfactor = 120;
       break;
     case SPECIES_GIANT:
       sfactor = 120;
       break;
     case SPECIES_GOBLIN:
       sfactor = 60;
       break;
     default:
       sfactor = 100;
       break;
     }
   /* here is the function*/
   /*auto setting sets hit and mana to 5 and 10 thus 5d10 extra = average 25*/
   if (level < 20)
     main = (sh_int) (3 * ((float)level * (float)(level/1.25))); 	/*50 and under equation*/
   
   else if (level < 35)
     main = (sh_int) (3 * ((float)level * (float)(level/1.35))); 	/*50 and under equation*/
   
   else if (level < 50)
     main = (sh_int) (3 * ((float)level * (float)level/1.25)); 	/*50 and under equation*/
   
   else if (level >= 50)
     main = (sh_int) (3 * ((float)level * (float)level/1.25));  /*51 and over equation*/
   if (level <=5) 
     face = 1;
   else if (level <=10) {
     main -= 25;
     face = 5;
   }
   else if (level <= 20) {
     main -= 100;
     face = 10;
   }
   else if (level <=30)  {
     main -= 200;
     face = 20;
   }
   else {
     main -= 2000;
     face = 200; 
   } 
   
   
d453 2
a454 2
   sfactor = ((int)((sfactor + cfactor)/2));
   main = (sh_int) (((float)(sfactor*main)/100));
d460 1
a460 1
     return main;
d1107 1
a1107 1
  log("Reading banned site and invalid-name list.");
d1109 1
a1109 1
  Read_Invalid_List();
d3033 1
a3033 1
  sh_int main  = 0;
d3352 1
a3352 1
    main = (sh_int)((GET_LEVEL(mob) * (int)(GET_LEVEL(mob)/5))); 	/*50 and under equation*/
d3354 1
a3354 1
    main =  320;
d3387 1
a3387 1
  main = (sh_int)  (main + (number(1, face) * 10));
d3389 2
a3390 2
  main = (sh_int) (((float)corpsefactor/100)*((float)tfactor/100) *
		   main);
d3392 1
a3392 1
    main = (sh_int) (((float)mobfactor/100)* main);
d3395 1
a3395 1
  GET_MAX_HIT(mob)= MAX(1, (main  + GET_MOVE(mob_proto +
d3506 1
a3506 1
  
d5168 3
a5170 1

@


1.13
log
@Mobs now get abil rolls (unless they're special circle 3 ones).
The rolls depend on class & species.
@
text
@d3657 2
a3658 1
  do_newbie(ch);
@


1.12
log
@Allows extra descriptions on no exits.
@
text
@d1753 7
a1759 6
  mob_proto[i].real_abils.str = 11;
  mob_proto[i].real_abils.intel = 11;
  mob_proto[i].real_abils.wis = 11;
  mob_proto[i].real_abils.dex = 11;
  mob_proto[i].real_abils.con = 15;
  mob_proto[i].real_abils.cha = 11;
a1811 2
    
    
d1821 1
a1821 1
    mob_proto[i].player.race = 17;
d1828 87
a1914 2
  
  
d1916 1
a1916 1
  /*exp modifier, class/level*/
@


1.11
log
@Add's chant songs, and can only chant once every four hours
@
text
@d1648 5
a1652 1
  else
d2884 1
a2884 1
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
d2889 3
a2891 1
		     EX_LOCKED);
@


1.10
log
@Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
Spellbooks now have to be held to scribe as well as a quill in the other hand.

-fingon
@
text
@d4592 1
@


1.9
log
@Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
and take 20 seconds to scribe each page.  This will be more dynamic when the
SCRIBE skill is introduced.  --Fingon.
@
text
@d4309 1
d4313 1
d4325 1
@


1.8
log
@Added obj = NULL in free_obj to help stop pointers to
raw memory for objects crashing the mud.

fingon
@
text
@d2589 3
a2591 1
  
d4190 1
a4190 1
  
d4209 6
d4233 6
a4239 1
  
@


1.7
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d4228 1
@


1.6
log
@Major change to incorporate aliases into the pfile
moved alias structure from interpreter.h to structs.h
heavily modified alias code in interpreter.c
Jimmy Kincaid AKA fingon
@
text
@d176 1
a176 1
#define GET_LDESC(mob) ((mob)->player.long_descr)
d3004 1
a3004 1
		GET_LDESC(mob) = str_dup(buf);
d3019 1
a3019 1
		GET_LDESC(mob) = str_dup(buf);    
d3036 1
a3036 1
		GET_LDESC(mob) = str_dup(buf);    
d3053 1
a3053 1
		GET_LDESC(mob) = str_dup(buf);    
d3070 1
a3070 1
		GET_LDESC(mob) = str_dup(buf);    
d3087 1
a3087 1
		GET_LDESC(mob) = str_dup(buf);    
d3103 1
a3103 1
	      GET_LDESC(mob) = str_dup(buf);
d3116 1
a3116 1
	      GET_LDESC(mob) = str_dup(buf);
d3129 1
a3129 1
	      GET_LDESC(mob) = str_dup(buf);
d3142 1
a3142 1
	      GET_LDESC(mob) = str_dup(buf);
d3477 1
a3477 1
  ch->player.long_descr = NULL;
d4154 2
a4155 2
    if (ch->player.long_descr)
      free(ch->player.long_descr);
d4168 2
a4169 2
    if (ch->player.long_descr && ch->player.long_descr != mob_proto[i].player.long_descr)
      free(ch->player.long_descr);
d4391 1
a4391 1
  ch->player.long_descr = NULL;
@


1.5
log
@Added Poofs to the playerfile as well as 4 extra strings for
future use.  fingon
@
text
@a3600 1
  
d4120 1
a4120 2
  struct alias *a;
  void free_alias(struct alias * a);
d4123 4
a4126 1
    while ((a = GET_ALIASES(ch)) != NULL) {
d4129 3
a4131 1
    }
d4292 1
d4298 2
a4299 1
  ch->followers = NULL;  ch->master = NULL;
d4371 1
a4371 1
  int i;
d4596 6
d4603 3
@


1.4
log
@spellcasters now lose all memmed spells at death without
haveintg to quit and log back in.
@
text
@d3506 5
a3510 4
  
  POOFIN(ch) = NULL;
  POOFOUT(ch) = NULL;
  
a4128 4
    if (ch->player_specials->poofin)
      free(ch->player_specials->poofin);
    if (ch->player_specials->poofout)
      free(ch->player_specials->poofout);
@


1.3
log
@improved build counter
@
text
@d4291 1
a4291 1
  
d4327 1
@


1.2
log
@Indented entire file
@
text
@d167 1
d1056 2
@


1.1
log
@Initial revision
@
text
@d1 9
a9 10
/*
************************************************************************
*   File: db.c                                          Part of CircleMUD *
*  Usage: Loading/saving chars, booting/resetting world, internal funcs   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d43 3
a45 3
/**************************************************************************
*  declarations of most of the 'global' variables                         *
************************************************************************ */
d191 2
a192 2
*  routines for booting the system                                       *
*********************************************************************** */
d205 1
a205 1

d207 1
a207 1

d212 1
a212 1
	file_to_string_alloc(ANEWS_FILE, &anews);
d261 1
a261 1

d267 1
a267 1
/*class/species*/
d269 72
a340 72
long exp;
int cfactor = 100;
int sfactor = 100;
int zfactor = 100;
for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
if (zone == zone_table[zfactor].number)
break;
}
zfactor = zone_table[zfactor].zone_factor;
/*zfactor = 100;*/

/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
	switch(class) 
	{
	case MCLASS_VOID:
		cfactor = 80;
		break;
	case MCLASS_SORCERER:
		cfactor = 120;
		break;
	case MCLASS_CLERIC:
		cfactor = 100;
		break;
	case MCLASS_WARRIOR:
		cfactor = 100;
		break;
	case MCLASS_THIEF:
		cfactor = 100;
		break;
	default:
		cfactor = 100;
		break;
	}

	switch(race) 
	{
	case SPECIES_OTHER:
		sfactor = 80;
		break;
	case SPECIES_UNDEAD:
		sfactor = 110;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 110;
		break;
	case SPECIES_GOBLIN:
		sfactor = 60;
		break;
	default:
		cfactor = 100;
		break;
	}

	if (level < 50)
		exp = (long) (((float)(level * level * level)) + 1000);
	else if (level >= 50)/*50 and under equation*/
		exp = (long) (level * level * 50) + 1000;
/*51 and over equation*/

	sfactor = ((int)((sfactor + zfactor + cfactor)/3));
	exp = (long) (((float)((sfactor*exp)/100)));
	return exp;
d344 1
a344 1
/*class/species*/
d346 115
a460 115
/*main - is the main bonus chucnk of hps
*/
 /*struct descriptor_data *d;
*/	sh_int main = 0;
	sh_int face = 1;
	int cfactor = 100;
	int sfactor = 100;

/*
The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/

 			 


	switch(class) 
	{
	case MCLASS_VOID:
		cfactor = 100;
		break;
	case MCLASS_SORCERER:
		cfactor = 80;
		break;
	case MCLASS_CLERIC:
		cfactor = 80;
		break;
	case MCLASS_WARRIOR:
		cfactor = 120;
		break;
	case MCLASS_THIEF:
		cfactor = 90;
		break;
	default:
		cfactor = 100;
		break;
	}

	switch(race) 
	{
	case SPECIES_OTHER:
		sfactor = 110;
		break;
case SPECIES_TROLL:
sfactor = 120;
break;
case SPECIES_OGRE:
sfactor = 130;
break;

	case SPECIES_UNDEAD:
		sfactor = 100;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 120;
		break;
	case SPECIES_GOBLIN:
		sfactor = 60;
		break;
	default:
		sfactor = 100;
	break;
	}
/* here is the function*/
/*auto setting sets hit and mana to 5 and 10 thus 5d10 extra = average 25*/
if (level < 20)
main = (sh_int) (3 * ((float)level * (float)(level/1.25))); 	/*50 and under equation*/

else if (level < 35)
main = (sh_int) (3 * ((float)level * (float)(level/1.35))); 	/*50 and under equation*/

else if (level < 50)
main = (sh_int) (3 * ((float)level * (float)level/1.25)); 	/*50 and under equation*/

else if (level >= 50)
main = (sh_int) (3 * ((float)level * (float)level/1.25));  /*51 and over equation*/
if (level <=5) 
face = 1;
else if (level <=10) {
main -= 25;
face = 5;
}
else if (level <= 20) {
main -= 100;
face = 10;
}
else if (level <=30)  {
main -= 200;
face = 20;
}
else {
main -= 2000;
face = 200; 
} 


/*finally taking the factors into account*/
sfactor = ((int)((sfactor + cfactor)/2));
main = (sh_int) (((float)(sfactor*main)/100));
 

if (state == 2)
return face;
else
return main;


d465 1
a465 1
/*class/species*/
d467 104
a570 27
sbyte hit = 0;
sbyte dam = 0;
int cfactor = 100;
int sfactor = 100;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(class) {
case MCLASS_VOID:
   cfactor = 130;
   break;
case MCLASS_SORCERER:
	cfactor = 80;
	break;
case MCLASS_CLERIC:
	cfactor = 80;
	break;
case MCLASS_WARRIOR:
	cfactor = 120;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 100;
break;
d573 103
a675 46
switch(race) {
case SPECIES_OTHER:
   sfactor = 120;
   break;
case SPECIES_UNDEAD:
	sfactor = 100;
	break;
case SPECIES_HUMANOID:
	sfactor = 100;
	break;
case SPECIES_TROLL:
sfactor = 110;
break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 120;
        break;
case SPECIES_GIANT:
	sfactor = 120;
	break;
	case SPECIES_GOBLIN:
	sfactor = 60;
	break;
default:
sfactor = 100;
break;
}

/*hit calculations*/
if (!state) {
if (level <10)
hit = (sbyte) (level/1.5);
else if (level < 30)
hit = (sbyte) (level/1.8);
else if (level < 50)
hit = (sbyte) (level/1.3);	/*50 and under equation*/
else if (level >= 50)
hit = (sbyte) (level/1.4);	 /*51 and over equation*/


/*hit factor considerations*/
sfactor = ((int)((sfactor + cfactor)/2));
hit = (sbyte) (((float)(sfactor*hit)/100));

d677 4
a682 8
/*dam calculations*/
if (state) {
if (level < 10)
dam = (sbyte) (level /4.0);
else if (level < 20)
dam = (sbyte) (level / 4.0); /*under 20*/
else if (level < 35)
dam = (sbyte) (level/4.3); /*under 35*/
d684 77
a760 9
else if (level < 50)
dam = (sbyte) (level / 4.6);	/*50 and under equation*/

else if (level >= 50)
dam = (sbyte) (level / 4.4);	/*51 and over equation*/

/*dam factor considerations*/
sfactor = ((int)((sfactor + cfactor)/2));
dam = (sbyte) (((float)(sfactor*dam)/100));
d764 31
d796 48
a843 277
if (!state)
return hit;
else
return dam;
}

int get_set_dice(int level, int race, int class, int state)
 
/*class/species*/
{ 
int dice = 0;
int face = 0;
int cfactor = 100;
int sfactor = 100;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(class) {
case MCLASS_VOID:
   cfactor = 100;
   break;
case MCLASS_SORCERER:
	cfactor = 60;
	break;
case MCLASS_CLERIC:
	cfactor = 70;
	break;
case MCLASS_WARRIOR:
	cfactor = 120;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 100;
break;
}

switch(race) {
case SPECIES_OTHER:
   sfactor = 80;
   break;
case SPECIES_UNDEAD:
	sfactor = 110;
	break;
case SPECIES_OGRE:
sfactor = 120;
break;
case SPECIES_TROLL:
sfactor = 110;
break;
case SPECIES_HUMANOID:
	sfactor = 100;
	break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 120;
	break;
case SPECIES_GIANT:
	sfactor = 100;
	break;
	case SPECIES_GOBLIN:
	sfactor = 60;
	break;
default:
sfactor = 100;
break;
}

/*dice calculations*/
if (!state) {
if (level < 10)
dice = MAX(1, (int) ((level/3) + .5));

else if (level < 30)
dice = (int) ((float)(level/3) + .5); /*under 30*/

else if (level <= 50)
dice = (int) ((level /3) + .5);	/*50 and under equation*/

else if (level > 50)
dice = (int) ((level / 2.5) + .5);	/*51 and over equation*/

sfactor = ((int)((sfactor + cfactor)/2));
dice = (sbyte) (((float)(sfactor*dice)/100));
}
/*face calucs*/
if (state) {
if (level < 10)
face = 3;
else if (level < 26)
face = 4;
else if (level < 36)
face = 4;

else if (level <= 50)
face = 5;	/*50 and under equation*/
else if ((level > 50) && (level <= 60))
face = 8;	   /*50 over equation*/
else if (level > 60)
face = 10;

/*face = (sbyte) (((float)sfactor/100) * ((float)cfactor/100) * face);
*/}



if (!state)
return dice;
else
return face;
}


int get_copper(int i)  
/*class/species*/
{ 
	/*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
int copper = 0;
int cfactor = 100;
int sfactor = 100;
int zfactor;
for (zfactor = 0; zfactor <= top_of_zone_table; zfactor++) {
if (GET_ZONE(mob_proto + i) == zone_table[zfactor].number)
break;
}
zfactor = zone_table[zfactor].zone_factor;


/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
switch(mob_proto[i].player.class) {
case MCLASS_VOID:
   cfactor = 20;
   break;
case MCLASS_SORCERER:
	cfactor = 100;
	break;
case MCLASS_CLERIC:
	cfactor = 100;
	break;
case MCLASS_WARRIOR:
	cfactor = 100;
	break;
case MCLASS_THIEF:
	cfactor = 100;
	break;
default:
cfactor = 40;
break;
}

switch(mob_proto[i].player.race) {
case SPECIES_OTHER:
   sfactor = 0;
   break;
case SPECIES_UNDEAD:
	sfactor = 40;
	break;
case SPECIES_HUMANOID:
	sfactor = 40;
	break;
case SPECIES_DRAGON:
	sfactor = 140;
	break;
case SPECIES_DEMON:
	sfactor = 140;
	break;
case SPECIES_GIANT:
	sfactor = 120;
	break;
	case SPECIES_GOBLIN:
	sfactor = 65;
	break;
	case SPECIES_ANIMAL:
	sfactor = 0;
	break;
	default:
sfactor = 40;
break;
}
if ((sfactor == 0) || (cfactor == 0))
	return 0;

/*copper calculations*/
copper = (number(1, 15)) * mob_proto[i].player.level;
sfactor = (int)((sfactor + cfactor + zfactor)/3);

copper = (int)((float)((sfactor/100.0) * copper));

return copper;
}


int get_ac(int level, int race, int class)  
/*class/species*/
{ 
/*mob_proto[i].player.class, mob_proto[i].player.race, mob_proto[i].player.level, GET_ZONE(mob_proto + i)*/
int ac = 0;
int cfactor = 100;
int sfactor = 100;

/*The cfactor is the factor of class to adjust exp number is percentage
100 being standard no change*/
	switch(class) 
	{
	case MCLASS_VOID:
		cfactor = 105;
		break;
   case MCLASS_SORCERER:
	   cfactor = 75;
	   break;
   case MCLASS_CLERIC:
	   cfactor = 100;
	   break;
   case MCLASS_WARRIOR:
	   cfactor = 120;
	   break;
   case MCLASS_THIEF:
	   cfactor = 80;
	   break;
   default:
      cfactor = 100;
   break;
   }

   switch(race) 
   {
   case SPECIES_OTHER:
      sfactor = 105;
      break;
   case SPECIES_UNDEAD:
	   sfactor = 110;
	   break;
   case SPECIES_HUMANOID:
	   sfactor = 60;
	   break;
   case SPECIES_DRAGON:
	   sfactor = 140;
	   break;
   case SPECIES_DEMON:
	   sfactor = 120;
	   break;
   case SPECIES_GIANT:
	   sfactor = 120;
	   break;
	case SPECIES_GOBLIN:
	   sfactor = 90;
	   break;
	case SPECIES_ANIMAL:
	   sfactor = 65;
	   break;
   case SPECIES_TROLL:
      sfactor = 100;
      break;
   case SPECIES_OGRE:
      sfactor = 90;
      break;
	default:
      sfactor = 100;
      break;
   }
   if (level < 30)
      ac = 90;
   else
      ac = 50;

      /*ac calculations*/
   ac = ac - (2 * level);
   sfactor = (int)((sfactor + cfactor)/2);

   ac = (int)((float)((sfactor/100.0) * ac));
   ac = MIN(100, MAX(-100, ac));
   return ac;
d851 4
a854 4
It then boots, note that if anything goes wrong to file
you can re-write it by saving under sdedit, the viewer is in act.informative.c
The olc code is in sdedit.c

d858 5
a862 5
int i;
FILE *ifptr;
char line[256];
char *err = "Spell Dam";
    if ((ifptr = fopen(SPELL_DAM_FILE, "r")) == NULL)
d864 2
a865 2
        log("No spells dam file it should be at lib/misc/spell_dam.");
        exit(1);
d867 1
a867 1
    else
d869 10
a878 10
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        get_line(ifptr, line);
sprintf(buf, "%s", line);
log(buf);
        if (str_cmp(line, "spell_dam"))
d880 4
a883 4
            log("Error in booting spell dams");
           /* return;
      */  }
        for (i = 1; i <= MAX_SPELLS;i++)
d885 10
a894 10
            get_line(ifptr, line);
            sscanf(line, "%hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd %hd", 
            &SD_SPELL(i), &SD_INTERN_DAM(i),
&SD_NPC_STATIC(i), &SD_NPC_NO_DICE(i), &SD_NPC_NO_FACE(i),
            &SD_PC_STATIC(i), &SD_PC_NO_DICE(i), &SD_PC_NO_FACE(i), &SD_NPC_REDUCE_FACTOR(i), &SD_USE_BONUS(i),
            &SD_BONUS(i), &SD_LVL_MULT(i));
            if (SD_NPC_REDUCE_FACTOR(i) == 0)
                SD_NPC_REDUCE_FACTOR(i) = 100;
             
            SD_NOTE(i) = fread_string(ifptr, err);
d896 1
a896 1
        fclose (ifptr);
d900 10
a909 10
There is a structure:
struct player_frags_data {
    int playerid;
    char	name[MAX_NAME_LENGTH+1];
    float frag;
}
struct player_frags[19] - 0 -> 9 top 10, 10 - 19 bottom 10
- this is a globel defined in db.c
This code simply reads througth playerfile and checks for the highest and lowest
frags and thus any errors in the frags should be fixed with a boot*/
d913 6
a918 6
    struct char_file_u chara;
    FILE *pfptr;
    int i, j;
    int pid = 0;
    
    if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d920 1
a920 1
        if (errno != ENOENT) 
d922 2
a923 2
            perror("fatal error opening playerfile");
            exit(1);
d925 1
a925 1
        else 
d927 3
a929 3
            log("No playerfile.  Creating a new one.");
            touch(PLAYER_FILE);
            if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d931 2
a932 2
	            perror("fatal error opening playerfile");
	            exit(1);
d936 2
a937 2
 
    while (!feof(pfptr))
d939 2
a940 2
        fread(&chara , sizeof(struct char_file_u), 1, pfptr);
        if (chara.player_specials_saved.frag > 0.0)
d942 1
a942 1
            for (i = 0;i <= 14;i++)
d944 3
a946 3
                if (!str_cmp(pos_player_frags[i].name, chara.name))
                    break;/*solve the empty new character that happens*/
                if (pos_player_frags[i].frag < chara.player_specials_saved.frag)
d948 2
a949 2
                /*1. copy all others down*/
                    for (j = 14;j > i; j--)
d951 1
a951 1
                        pos_player_frags[j] = pos_player_frags[j-1];
d953 4
a956 4
                    pos_player_frags[i].playerid = pid;
                    strcpy(pos_player_frags[i].name, chara.name);
                    pos_player_frags[i].frag = chara.player_specials_saved.frag;
                    break;
d960 1
a960 1
        else if (chara.player_specials_saved.frag < 0.0)
d962 1
a962 1
            for (i = 0;i <= 14;i++)
d964 3
a966 3
                if (!str_cmp(neg_player_frags[i].name, chara.name))
                    break;/*solve the empty new character that happens*/
                if (neg_player_frags[i].frag > chara.player_specials_saved.frag)
d968 2
a969 2
            /*1. copy all others down*/
                    for (j = 14;j > i; j--)
d971 1
a971 1
                        neg_player_frags[j] = neg_player_frags[j-1];
d973 4
a976 4
                    neg_player_frags[i].playerid = pid;
                    strcpy(neg_player_frags[i].name, chara.name);
                    neg_player_frags[i].frag = chara.player_specials_saved.frag;
                    break;
d980 1
a980 1
        pid++;
d982 3
a985 2
	rewind(pfptr);
}
a986 1
  
d993 1
a993 1

d996 2
a997 2


d1000 1
a1000 1

d1018 5
a1022 5

   log("Booting spell_dam's.");
 boot_spell_dams();


d1035 1
a1035 1

d1037 1
a1037 1

d1057 1
a1057 1

d1072 1
a1072 1

d1090 1
a1090 1

d1094 1
a1094 1

d1106 1
a1106 1

d1121 1
a1121 1

d1126 1
a1126 1

d1129 1
a1129 1

d1131 1
a1131 1

d1136 1
a1136 1

d1146 1
a1146 1

d1151 8
a1158 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
  log("end of <=7");

  }
d1160 8
a1167 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_SET;
  log("end of ==8");

  }
d1169 8
a1176 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_DARK;
  log("end <= 20");

  }    
d1178 8
a1185 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_SET;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_RISE;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_RISE;
  log("==21");

  }    
d1187 10
a1196 10
  {
    Hemispheres[HEMISPHERE_NORTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_SOUTHWEST].sunlight = SUN_DARK;
    Hemispheres[HEMISPHERE_NORTHEAST].sunlight = SUN_LIGHT;
    Hemispheres[HEMISPHERE_SOUTHEAST].sunlight = SUN_LIGHT;
    log("end else...");
}

    log("setting up seasons");

d1199 5
a1203 5
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = WINTER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SUMMER;
d1205 2
a1206 2

  }
d1208 8
a1215 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SPRING;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = AUTUMN;
  log("spring");

  }
d1217 8
a1224 8
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = WINTER;
    Hemispheres[HEMISPHERE_NORTHEAST].season = SUMMER;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = WINTER;
  log("summer");

  }
d1226 9
a1234 9
  {
    Hemispheres[HEMISPHERE_NORTHWEST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHWEST].season = SPRING;
    Hemispheres[HEMISPHERE_NORTHEAST].season = AUTUMN;
    Hemispheres[HEMISPHERE_SOUTHEAST].season = SPRING;
  log("autumn");

  }
 
d1239 1
a1239 1

d1251 1
a1251 1

d1281 1
a1281 1

d1293 1
a1293 1

d1304 1
a1304 1

d1308 1
a1308 1

d1319 1
a1319 1

d1360 1
a1360 1

d1379 1
a1379 1

d1387 1
a1387 1

d1389 1
a1389 1

d1422 1
a1422 1
	case DB_BOOT_TRG:
d1438 1
a1438 1

d1442 1
a1442 1

d1462 8
a1469 7
    {
tmp_debug++;
  if (!get_line(fl, line)) {
	fprintf(stderr, "Format error after %s #%d\n", modes[mode], nr);
fprintf(stderr, "Offending line: '%s'in file down list%d\n", line,
tmp_debug);
	exit(1);
d1471 1
a1471 2
   }
 if (*line == '$')
d1473 1
a1473 1

d1478 1
a1478 1
fprintf(stderr, "Offending line: '%s'\n", line);
d1485 3
a1487 3
    case DB_BOOT_TRG:
      parse_trigger(fl, nr);
      break;
d1513 1
a1513 1

d1519 1
a1519 1

d1523 1
a1523 1

d1526 1
a1526 1

d1531 7
a1537 7
 {
   char c;
   do {
     c = getc(fp);
   } while (isspace(c));
   return c;
 }
d1549 1
a1549 1

d1571 1
a1571 1

d1576 1
a1576 1

d1579 1
a1579 1

d1581 1
a1581 1

d1583 1
a1583 1

d1626 1
a1626 1

d1628 1
a1628 1

d1659 1
a1659 1

d1681 1
a1681 1

d1697 1
a1697 1

d1743 1
a1743 1
	int j, t[10];
d1747 5
a1751 27
    mob_proto[i].real_abils.intel = 11;
    mob_proto[i].real_abils.wis = 11;
    mob_proto[i].real_abils.dex = 11;
    mob_proto[i].real_abils.con = 15;
    mob_proto[i].real_abils.cha = 11;

    get_line(mob_f, line);
    if (sscanf(line, " %d %d %d %dd%d+%d %dd%d+%d ",
	  t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8) != 9) {
      fprintf(stderr, "Format error in mob #%d, first line after S flag\n"
	      "...expecting line of form '# # # #d#+# #d#+#'\n", nr);
      exit(1);
    }
    GET_LEVEL(mob_proto + i) = t[0];
// No negative hitroll bonus DO_NOT CHANGE -Banyal
   mob_proto[i].mob_specials.ex_hitroll = BOUNDED(0, t[1], 20);
	
   mob_proto[i].mob_specials.ex_armor = 10 * t[2];
	/*if ac onmedit is 0 then ignore it*/
	
   
    /* max hit = 0 is a flag that H, M, V is xdy+z */
    mob_proto[i].points.max_hit = 0;
    
	mob_proto[i].mob_specials.ex_max_hit = 0;
	mob_proto[i].mob_specials.ex_no_dice = t[3];
    mob_proto[i].mob_specials.ex_face = t[4];
d1753 23
a1775 1
	/*mob_proto[i].points.hit = t[3];
d1777 30
a1806 30
   */
	
	mob_proto[i].points.move = t[5];
	mob_proto[i].points.max_mana = 10;
    mob_proto[i].points.max_move = 50;

    mob_proto[i].mob_specials.ex_damnodice = t[6];
    mob_proto[i].mob_specials.ex_damsizedice = t[7];
    mob_proto[i].mob_specials.ex_damroll = t[8];

    get_line(mob_f, line);
    if (sscanf(line, " %d %d %d %d", t, t + 1, t + 2, t + 3) > 3)
	{
	GET_ZONE(mob_proto + i) = t[2];
	GET_EX_GOLD(mob_proto + i) = t[0];
	GET_EX_PLAT(mob_proto + i) = t[1];
}else
{	GET_ZONE(mob_proto + i) = (nr/100);
GET_EX_GOLD(mob_proto + i) = 0;
	GET_EX_PLAT(mob_proto + i) = 0;

}	GET_EX_GOLD(mob_proto + i) = t[0];

	

    get_line(mob_f, line);
    if ((sscanf(line, " %d %d %d %d %d %d %d %d ", t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7))  > 3) {

	
	mob_proto[i].player.class = t[3];
d1808 3
a1810 3
	mob_proto[i].player.race_align = t[5];
	mob_proto[i].player.size = mob_find_size(t[4]);
	mob_proto[i].char_specials.position = t[0];
d1812 3
a1814 3
	mob_proto[i].player.sex = t[2];
	}	else {
	mob_proto[i].player.class = 13;t[3] = 13;
d1816 3
a1818 3
	mob_proto[i].player.race_align = 0;
	mob_proto[i].player.size = mob_find_size(17);
	mob_proto[i].char_specials.position = t[0];
d1820 11
a1830 11
	mob_proto[i].player.sex = t[2];
	}
 
	
    mob_proto[i].player.height = 198;
	/*exp modifier, class/level*/
mob_proto[i].points.coins.gold = 0;
mob_proto[i].points.coins.plat = 0;
mob_proto[i].points.coins.silver = 0;
mob_proto[i].points.coins.copper = 0;

d1832 19
a1850 19
	k = 0;j=0;
	k = get_copper(i);
	j = ((60*k)/100);
	mob_proto[i].points.coins.plat = ((int) (j/1000));
	j = ((int)((20*k)/100)) + (j % 1000);
	mob_proto[i].points.coins.gold = ((int) (j/200));
	j = ((int)((18*k)/100)) + (j % 200);
	mob_proto[i].points.coins.silver = ((int) (j/20));
	if (mob_proto[i].player.level > 20)
		j = ((int)((.5*k)/100)) + (j % 50);
		j = ((int)((2*k)/100)) + (j % 50);
	mob_proto[i].points.coins.copper = j;

	mob_proto[i].points.coins.plat = MAX(0, mob_proto[i].points.coins.plat + GET_EX_PLAT(mob_proto + i));
	mob_proto[i].points.coins.gold = MAX(0, mob_proto[i].points.coins.gold + GET_EX_GOLD(mob_proto + i));
	
	/*auto ac stuff*/
/*	l = get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
    sprintf(buf, "get is: %d", l);
d1852 3
a1854 3
*/
	if ((mob_proto[i].mob_specials.ex_armor != 100))
		mob_proto[i].points.armor = mob_proto[i].mob_specials.ex_armor + get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));
d1856 53
a1908 53
		mob_proto[i].points.armor = (sh_int) get_ac(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i));

	

		/*num of hp dice is hit*/
	GET_EXP(mob_proto + i) = get_set_exp(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i),  GET_ZONE(mob_proto + i));
	GET_EXP(mob_proto + i) += GET_EX_EXP(mob_proto + i); 
	
	mob_proto[i].points.mana = get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 2);  
	mob_proto[i].points.hit = 20;
	mob_proto[i].points.mana += mob_proto[i].mob_specials.ex_face;
	mob_proto[i].points.hit += mob_proto[i].mob_specials.ex_no_dice;
	GET_EX_MAIN_HP(mob_proto + i) = (get_set_hit(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1));
	 	
	mob_proto[i].points.damroll	= get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
	mob_proto[i].points.damroll	+= mob_proto[i].mob_specials.ex_damroll; 
   // Changed to get rid of the -199 mobb hitrolls Do NOT change -Banyal
	mob_proto[i].points.hitroll = BOUNDED(10, get_set_hd(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i),
        GET_CLASS(mob_proto + i), 0), 80);
	mob_proto[i].points.hitroll += mob_proto[i].mob_specials.ex_hitroll;

	mob_proto[i].mob_specials.damnodice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 0);
    mob_proto[i].mob_specials.damnodice += mob_proto[i].mob_specials.ex_damnodice;
	mob_proto[i].mob_specials.damsizedice = get_set_dice(GET_LEVEL(mob_proto + i), GET_RACE(mob_proto + i), GET_CLASS(mob_proto + i), 1);
	mob_proto[i].mob_specials.damsizedice += mob_proto[i].mob_specials.ex_damsizedice;

/*last check values above 0*/
	mob_proto[i].mob_specials.damsizedice = MAX(0, mob_proto[i].mob_specials.damsizedice);
	mob_proto[i].mob_specials.damnodice = MAX(0, mob_proto[i].mob_specials.damnodice);
	mob_proto[i].points.hitroll = MAX(0, mob_proto[i].points.hitroll);
	mob_proto[i].points.damroll = MAX(0, mob_proto[i].points.damroll);
	mob_proto[i].points.armor = MIN(100, MAX(-100, mob_proto[i].points.armor));

	for (j = 0;j <= NUM_SPELL_CIRCLES - 4;j++)
	mob_proto[i].mob_specials.mem_memed[j] = spells_of_circle[(int)(mob_proto[i].player.level)][(j + 1)];
	for (j= 0; j <= 11;j++)
	mob_proto[i].mob_specials.mem_state[j] = 0;



	for (j = 0; j < 3; j++)
      GET_COND(mob_proto + i, j) = -1;

	for (j = 0; j < 4; j++)
      GET_INNT(mob_proto + i, j) = -1;

    /*
     * these are now save applies; base save numbers for MOBs are now from
     * the warrior save table.
     */
    for (j = 0; j < 5; j++)
      GET_SAVE(mob_proto + i, j) = 0;
set_mob_skills(i, t[3], t[4]);
d1927 1
a1927 1

d1929 1
a1929 1

d1934 1
a1934 1

d1982 1
a1982 1

d1989 1
a1989 1

d1997 1
a1997 1

d1999 1
a1999 1

d2009 1
a2009 1

d2021 1
a2021 1

d2025 1
a2025 1

d2027 1
a2027 1

d2030 1
a2030 1

d2042 1
a2042 1

d2050 1
a2050 1

d2058 1
a2058 1
  /* add new mob types here.. */
d2064 1
a2064 1

d2072 2
a2073 2


d2075 1
a2075 1

d2078 1
a2078 1

d2081 1
a2081 1

d2083 6
a2088 6
   if (letter == '>') {
     ungetc(letter, mob_f);
     (void)  mprog_read_programs(mob_f, &mob_index[i]);
   } else ungetc(letter, mob_f);


d2125 1
a2125 1

d2130 1
a2130 1

d2135 1
a2135 1
   /* exit(1);*/
d2140 1
a2140 1

d2153 1
a2153 1

d2156 4
a2159 4
{
fprintf(stderr, "Format error in third numeric line (expecting 6 args, got %d), %s\n", retval, buf2);
    /*exit(1);*/
  }
d2162 8
a2169 8
	  obj_proto[i].obj_flags.weight = t[0];
	  obj_proto[i].obj_flags.cost = t[1];
	  obj_proto[i].obj_flags.timer = t[2];
	  obj_proto[i].obj_flags.spell_flags = t[3];
	  obj_proto[i].spell_component = t[4];
	  obj_proto[i].object_limitation = t[5];
         obj_proto[i].obj_flags.spell_flags2 = 0;
         obj_proto[i].obj_flags.spell_flags3 = 0;
d2171 1
a2171 1

d2173 8
a2180 8
	  obj_proto[i].obj_flags.weight = t[0];
  obj_proto[i].obj_flags.cost = t[1];
  obj_proto[i].obj_flags.cost_per_day = t[2];
  obj_proto[i].obj_flags.spell_flags = t[3]; //Duh this was somehow removed -Banyal
   obj_proto[i].spell_component = t[4];
	  obj_proto[i].object_limitation = t[5];
         obj_proto[i].obj_flags.spell_flags2 = 0;
         obj_proto[i].obj_flags.spell_flags3 = 0;
d2182 1
a2182 1

d2189 1
a2189 1

d2191 1
a2191 1

d2196 1
a2196 1

d2199 1
a2199 1

d2224 10
a2233 10
	 
/*
** affect player flags (see AFF_XXX flags in structs.h )
** This allows players flags to be affected by an item, for example
** create a ring which gives the player permanent sense life when worn.
**
** Note: more 'C' fields are allowed because all found 'C' (set char bits)
**       fields are added to the current values. (nice for builders who
**       don't want those large bitvector numbers in the obj file).
*/
d2239 1
a2239 1
	case 'T':  /* DG triggers */
d2242 1
a2242 1

d2265 1
a2265 1

d2267 1
a2267 1

d2271 1
a2271 1

d2277 1
a2277 1

d2279 1
a2279 1

d2285 1
a2285 1

d2290 1
a2290 1

d2293 7
a2299 7
         &Z.reset_mode, &Z.zone_factor, &Z.hemisphere, &Z.climate) != 4) 
   Z.zone_factor = 100;
 /* fprintf(stderr, " %d me this one has a factor of %d done by set by 
me, line \n", Z.number, Z.zone_factor);
   *//*
  cmd_no = 0;
	   */
d2308 1
a2308 1

d2311 1
a2311 1

d2313 1
a2313 1

d2319 1
a2319 1
	if (ZCMD.command == 'F')  /* force mobile command */ {
d2329 9
a2337 9
    if (strchr("MOEPD", ZCMD.command) == NULL) {	/* a 3-arg command */
      if (sscanf(ptr, " %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2) != 3)
	error = 1;
    } else {
      if (sscanf(ptr, " %d %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2,
		 &ZCMD.arg3) != 4)
	error = 1;
    }

d2339 1
a2339 1

d2342 1
a2342 1
line_num, buf);
d2348 1
a2348 1

d2361 1
a2361 1

d2371 1
a2371 1

d2382 1
a2382 1

d2386 1
a2386 1

d2388 3
a2390 3



d2401 1
a2401 1

d2411 1
a2411 1

d2414 1
a2414 1

d2428 1
a2428 1

d2437 1
a2437 1

d2446 1
a2446 1

d2462 1
a2462 1
 
d2464 6
a2469 6
     if((r_num = real_mobile(nr)) >= 0) {
	sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
		mob_index[r_num].virtual,
		mob_proto[r_num].player.short_descr);
	send_to_char(buf, ch); 
     }
d2476 1
a2476 1
 
d2478 6
a2483 6
     if((r_num = real_object(nr)) >= 0) {
	sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
		obj_index[r_num].virtual,
		obj_proto[r_num].short_description);
	send_to_char(buf, ch); 
     }
d2492 1
a2492 1

d2507 1
a2507 1

d2515 1
a2515 1

d2521 6
a2526 6

if (!mob->points.max_hit) {    mob->points.max_hit = MAX(0, MIN(32000,
(dice(mob->points.hit, mob->points.mana) +   GET_EX_MAIN_HP(mob) +
mob->points.move)));      } else    mob->points.max_hit =
number(mob->points.hit, mob->points.mana);    
 
d2531 1
a2531 1
	
d2535 1
a2535 1

d2539 1
a2539 1

d2547 1
a2547 1

d2554 1
a2554 1

d2564 1
a2564 1

d2576 1
a2576 1

d2582 1
a2582 1

d2586 1
a2586 1

d2601 1
a2601 1

d2609 1
a2609 1

d2611 1
a2611 1

d2621 1
a2621 1

d2623 1
a2623 1

d2626 1
a2626 1

d2633 1
a2633 1

d2638 2
a2639 2


d2655 1
a2655 1

d2658 1
a2658 1

d2661 1
a2661 1

d2670 1
a2670 1

d2673 1
a2673 1

d2688 1
a2688 1

d2690 1
a2690 1

d2693 1
a2693 1

d2698 2
a2699 2

	case 'F':           /* force mobile to do action */
d2706 1
a2706 1

d2715 1
a2715 1

d2717 7
a2723 2

		if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2725 12
a2736 35
			obj = read_object(ZCMD.arg1, REAL);
			if (ZCMD.arg3 >= 0) 
			{
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					obj_to_room(obj, ZCMD.arg3);
					last_cmd = 1;
				}else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			} 
			else 
			{
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					obj->in_room = NOWHERE;
					last_cmd = 1;
				}
				else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			}
		} 
		else
			last_cmd = 0;
		break;

    case 'P':			/* object to object */
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2738 3
a2740 18
			obj = read_object(ZCMD.arg1, REAL);
			if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
			{
				if (!(obj_to = get_obj_num(ZCMD.arg3))) 
				{
					ZONE_ERROR("target obj not found");
					extract_obj(obj);
					break;
				}
				obj_to_obj(obj, obj_to);
				OBJ_INDEX_LIMIT(obj->item_number) ++;
				last_cmd = 1;
			}
			else
			{
				last_cmd = 0;
				extract_obj(obj);
			}
d2742 1
a2742 6
		else
			last_cmd = 0;
		break;

    case 'G':			/* obj_to_char */
		if (!mob) 
d2744 2
a2745 2
			ZONE_ERROR("attempt to give obj to non-existant mob");
			break;
d2747 13
a2759 1
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2761 42
a2802 16
			obj = read_object(ZCMD.arg1, REAL);
			if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
			{
				OBJ_INDEX_LIMIT(obj->item_number) ++;
				obj_to_char(obj, mob);
				last_cmd = 1;
			}else
			{
				last_cmd = 0;
				extract_obj(obj);
			}
		} 
		else
			last_cmd = 0;
		break;

d2804 15
a2818 1
        if (!mob) 
d2820 5
a2824 4
			ZONE_ERROR("trying to equip non-existant mob");
			break;
		}/*was make sure number less then ZCMD.arg2*/
		if (obj_index[ZCMD.arg1].number < ZCMD.arg2) 
d2826 2
a2827 19
			if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS) 
			{
				ZONE_ERROR("invalid equipment pos number");
			} 
			else 
			{
				obj = read_object(ZCMD.arg1, REAL);
				if ((OBJ_INDEX_LIMIT(obj->item_number) < GET_OBJ_LIMITATION(obj)) || (!(GET_OBJ_LIMITATION(obj))) )
				{
					OBJ_INDEX_LIMIT(obj->item_number) ++;
					equip_char(mob, obj, ZCMD.arg3);
					last_cmd = 1;
				}
				else
				{
					last_cmd = 0;
					extract_obj(obj);
				}
			}
d2829 4
a2832 2
	  else
		last_cmd = 0;
d2834 1
a2834 1

d2842 2
a2843 2


d2856 1
a2856 1
             EX_HIDDEN);
d2864 1
a2864 1
             EX_HIDDEN);
d2872 1
a2872 1
          EX_HIDDEN);
d2876 1
a2876 1
                  EX_CLOSED);
d2880 1
a2880 1
                  EX_LOCKED);
d2882 1
a2882 1
   case 4:
d2890 1
a2890 1
   case 5:
d2894 1
a2894 1
                  EX_LOCKED);
d2901 1
a2901 1

d2908 1
a2908 1

d2918 1
a2918 1

d2923 1
a2923 1

d2931 289
a3219 164
int cfactor = 100;
int sfactor = 100;
int tfactor = 100;
int mobfactor = 100;
int corpsefactor = 100;
int decrease = 100;
sh_int main  = 0;
int corpse_level = 0;
sh_int face = 0;/*this function was written by Proky, what it does is
reset a mobs "statistics"
to suite the level of the owner (if called because a mob summmons)*/
	if (obj)
		corpse_level = CORPSE_LEVEL(obj);
	if (!corpse_level)
	{/*if this is case then not usinga  corpse*/
		corpse_level = MIN(70, (caster_level + (5 - number(0, 7))));
	}
	else
	{/*involve the casters level here */
		if ((caster_level - corpse_level) < 1)  
			corpse_level = (MIN(70, ((corpse_level - number(1, 3)))));
		else if ((caster_level - corpse_level) < 10)  
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 2)));
		else if ((caster_level - corpse_level) < 20)
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 5)));
		else if ((caster_level - corpse_level) < 30)
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 8)));
		else
			corpse_level = (MIN(70, ((corpse_level + number(1, 6)) + 15)));
	}
	i = GET_MOB_RNUM(mob);
/*mob exp cut down*//*giving it the exp of a mob half its level*/
	GET_LEVEL(mob) = corpse_level;
	GET_EXP(mob) = (long)(get_set_exp(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), GET_ZONE(mob))/2);
	GET_EXP(mob) = MAX(0, (GET_EXP(mob) + GET_EX_EXP(mob_proto + i))); 
		 
/*mob bonus*/
	switch(GET_CLASS(mob)) 
	{
	case MCLASS_VOID:
		cfactor = 100;
		break;
	case MCLASS_SORCERER:
		cfactor = 90;
		break;
	case MCLASS_CLERIC:
		cfactor = 100;
		break;
	case MCLASS_WARRIOR:
		cfactor = 110;
		break;
	case MCLASS_THIEF:
		cfactor = 80;
		break;
	default:
		cfactor = 100;
		break;
	}
	switch(GET_MOB_VNUM(mob))
	{
		case MOB_ZOMBIE:
			if (obj)
				if (GET_OBJ_MOB_FROM(obj))
				{
					if(GET_LDESC(mob))
					{
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2)); 
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
					}
				}
					mobfactor = 100;
			break;
case  (MOB_ZOMBIE + 1):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);    
 
}
                                }
 
mobfactor =  90;
break;
case(MOB_ZOMBIE  + 2):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);    
 
}
                                }
 
mobfactor = 100;
break;
case  (MOB_ZOMBIE  +  3):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);    
 
}
                                }
 
mobfactor = 140;
break;
case (MOB_ZOMBIE+ 4):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);    
 
}
                                }
 
mobfactor = 75;
break;
case (MOB_ZOMBIE +  5):
                        if (obj)
                                if (GET_OBJ_MOB_FROM(obj))
                                {
                                        if(GET_LDESC(mob))
                                        {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);    
 
}
                                }
 
mobfactor =  120;
break;
case (4):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
d3221 131
a3351 256
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj)));
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 200;
break;

case (5):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 180;
break;

case (6):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 170;
break;

case (7):
if (obj)
  if (GET_OBJ_MOB_FROM(obj))
  {  if(GET_LDESC(mob))
      {
strcpy (buf, "");
strncat(buf, GET_LDESC(mob), (strlen(GET_LDESC(mob)) - 2));
strcat(buf, GET_SDESC(mob_proto + GET_OBJ_MOB_FROM(obj))); 
strcat(buf, ", &0stands here.\r\n");
GET_LDESC(mob) = str_dup(buf);
}}mobfactor = 160;
break;

case (29):
mobfactor = 180;
break;
case (30):
mobfactor = 150;
break;
case (MOB_MENTAL3 + 0):
mobfactor = 130;
break;

case (MOB_MENTAL3 + 1):
mobfactor = 130;
break;

case (MOB_MENTAL3 + 2):
mobfactor = 120;
break;
case (MOB_MENTAL3 + 3):
mobfactor = 120;
break;

default:
mobfactor =  100;
break;

}
	switch(GET_RACE(mob)) 
	{
	case SPECIES_OTHER:
		sfactor = 100;
		break;
	case SPECIES_UNDEAD:
		sfactor = 100;
		break;
	case SPECIES_HUMANOID:
		sfactor = 100;
		break;
	case SPECIES_DRAGON:
		sfactor = 130;
		break;
	case SPECIES_DEMON:
		sfactor = 120;
		break;
	case SPECIES_GIANT:
		sfactor = 110;
		break;
	case SPECIES_GOBLIN:
		sfactor = 70;
		break;
	default:
		sfactor = 100;
		break;
	}
	switch(type) 
	{
	case SPELL_SUMMON_DRACOLICH:
		tfactor = 120;
		break;
	case SPELL_SUMMON_ELEMENTAL:
		tfactor = 100;
		break;
	case SPELL_SUMMON_GREATER_DEMON:
		tfactor = 140;
		break;
	case SPELL_SUMMON_DEMON:
		tfactor = 110;
		break;
	case SPELL_ANIMATE_DEAD:
		tfactor = 100;
		break;
	default:
		tfactor = 100;
		break;
	}
	/*corpse species bonus*/
	if (obj)
		if (GET_OBJ_MOB_FROM(obj))
		{
			switch(mob_proto[GET_OBJ_MOB_FROM(obj)].player.race)
			{
			case SPECIES_HUMAN:
				corpsefactor = 100;
				break;
			case SPECIES_OTHER:
				corpsefactor = 100;
				break;
			case SPECIES_UNDEAD:
				corpsefactor = 100;
				break;
			case SPECIES_HUMANOID:
				corpsefactor = 100;
				break;
			case SPECIES_DRAGON:
				corpsefactor = 120;
				break;
			case SPECIES_DEMON:
				corpsefactor = 110;
				break;
			case SPECIES_GIANT:
				corpsefactor = 110;
				break;
			case SPECIES_GOBLIN:
				corpsefactor = 75;
				break;
			default:
				corpsefactor = 100;
				break;
			}		
		}
/*fix factors*/
tfactor = ((int)((sfactor + tfactor + cfactor)/3));

	if (GET_LEVEL(mob) < 40)
	main = (sh_int)((GET_LEVEL(mob) * (int)(GET_LEVEL(mob)/5))); 	/*50 and under equation*/
	else
	main =  320;

	if (GET_LEVEL(mob) <=10) 
		face = 10;
	else if (GET_LEVEL(mob) <=10) 
	{
		face = 15;
	}
	else if (GET_LEVEL(mob) <= 20) 
	{
		face = 15;
	}
	else if (GET_LEVEL(mob) <= 30)  
	{
		face = 20;
	}
	else if (GET_LEVEL(mob) <= 40)
	{
		face = 25;
	} 
	else if (GET_LEVEL(mob) <= 50)
	{
		face = 30;
	}
	else if (GET_LEVEL(mob) <= 60)
	{
		face = 35;
	}
	else
		face = 40;
	if (mobfactor > 100)
		face = (sh_int) (((float)mobfactor/100)* face);

main = (sh_int)  (main + (number(1, face) * 10));
/*finally taking the factors into account*/
	main = (sh_int) (((float)corpsefactor/100)*((float)tfactor/100) *
main);
	if (mobfactor < 100)
		main = (sh_int) (((float)mobfactor/100)* main);
/*hp factors taken into account*/

	GET_MAX_HIT(mob)= MAX(1, (main  + GET_MOVE(mob_proto +
i)));
	GET_HIT(mob) = GET_MAX_HIT(mob);
		 	
	/* I decrease all these values by a bit because they do rock to much*/
	decrease = 90;
	if (GET_LEVEL(mob) < 20)
		decrease = 90;
	else if (GET_LEVEL(mob) < 30)
		decrease = 75;
	else if (GET_LEVEL(mob) < 40)
		decrease = 60;
	else if (GET_LEVEL(mob) < 50)
		decrease = 55;
	else if (GET_LEVEL(mob) < 55)
		decrease = 50;
	else
		decrease = 50;
	GET_DAMROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);
	GET_DAMROLL(mob) = MAX(1, (GET_DAMROLL(mob) + mob_proto[i].mob_specials.ex_damroll)); 
	GET_DAMROLL(mob) = (sbyte)(GET_DAMROLL(mob)*((int)corpsefactor/100));
	/*hit roll is fine dont need to decrease this*/
	decrease = 100;
	GET_HITROLL(mob) = (sbyte)(decrease*(get_set_hd(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1))/100);
	GET_HITROLL(mob) = MAX(1, (GET_HITROLL(mob) + mob_proto[i].mob_specials.ex_hitroll));
	GET_HITROLL(mob) = BOUNDED(10, (sbyte)(GET_HITROLL(mob)*((int)corpsefactor/100)), 60);
	/*dice value should be decreased*/
	decrease = 100;
	if (GET_LEVEL(mob) < 20)
		decrease = 100;
	else if (GET_LEVEL(mob) < 30)
		decrease = 80;
	else if (GET_LEVEL(mob) < 40)
		decrease = 65;
	else if (GET_LEVEL(mob) < 50)
		decrease = 60;
	else if (GET_LEVEL(mob) < 55)
		decrease = 55;
	else
		decrease = 53;

	GET_NDD(mob) = (int)(decrease*(get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 0))/100);			
	GET_NDD(mob) = MAX(1, (GET_NDD(mob) + mob_proto[i].mob_specials.ex_damnodice));
	GET_NDD(mob) = (int)(GET_NDD(mob)*((int)corpsefactor/100));
	GET_SDD(mob) = get_set_dice(GET_LEVEL(mob), GET_RACE(mob), GET_CLASS(mob), 1);
	GET_SDD(mob) = MAX(1, (GET_SDD(mob) + mob_proto[i].mob_specials.ex_damsizedice));
	GET_SDD(mob) = (int)(GET_SDD(mob)*((int)corpsefactor/100));
	GET_PLAT(mob) = 0;
	GET_GOLD(mob) = 0;
	GET_SILVER(mob) = 0;
	GET_COPPER(mob) = 0;
	

d3355 3
a3357 3
/*************************************************************************
*  stuff related to the save/load player system				 *
*********************************************************************** */
d3363 1
a3363 1

d3368 1
a3368 1

d3376 1
a3376 1

d3380 1
a3380 1

d3390 1
a3390 1

d3395 1
a3395 1
 }else
d3410 1
a3410 1

d3413 1
a3413 1

d3415 1
a3415 1

d3418 5
a3422 5

//    if (load_room == NOWHERE);
// else
   //   st.player_specials_saved.load_room = world[load_room].number;

d3424 1
a3424 1

d3432 18
a3449 18
   if (dex <= 8)
      return 10;
   else if (dex <= 10)
      return 15;
   else if (dex <= 14)
      return 20;
   else if (dex <= 16)
      return 25;
   else if (dex <= 18)
      return 30;
   else if (dex <= 19)
      return 35;
   else if (dex <= 20)
      return 40;
   else if (dex <= 21)
      return 45;
   else
      return 50;
d3458 1
a3458 1

d3462 1
a3462 1

d3469 2
a3470 2


d3478 1
a3478 1

d3483 1
a3483 1

d3503 1
a3503 1

d3506 1
a3506 1

d3509 1
a3509 1

d3512 1
a3512 1
   
d3515 2
a3516 2
  ch->points.hitroll = 0;
  ch->points.damroll = 0;*/
d3519 1
a3519 1

d3522 1
a3522 1

d3525 1
a3525 1

d3530 1
a3530 1

d3536 1
a3536 1

d3545 2
a3546 2
      strcpy(clan[clan_num].member_list[i], GET_NAME(ch));
      update_clan(ch, clan_num);
d3548 1
a3548 1

d3560 3
a3562 3

 do_newbie(ch);

d3564 32
a3595 32
	  switch (GET_RACE(ch)){
		   case RACE_DROW_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_DWARF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_DUERGAR:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_HALFLING:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
	  if (!IS_AFFECTED(ch, AFF_SENSE_LIFE))
	  SET_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
    break;
case RACE_TROLL:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_OGRE:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_HALF_ELF:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
    break;
case RACE_GNOME:
	  SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
	  break;
  }}

d3597 1
a3597 1

d3602 21
a3622 21
    int bonus = 0;   
//	int prevbonus = 0;    

	if (GET_CON(ch) < 10)
        bonus = GET_LEVEL(ch) * -1;
    else if (GET_CON(ch) < 17)
        bonus = 0;
    else if (GET_CON(ch) < 19)
        bonus = GET_LEVEL(ch) * 1;
    else if (GET_CON(ch) < 21)
        bonus = GET_LEVEL(ch) * 2;
    else if (GET_CON(ch) < 23)
        bonus = GET_LEVEL(ch) * 2;
    else if (GET_CON(ch) < 25)
        bonus = GET_LEVEL(ch) * 3;
	else if (GET_CON(ch) < 26)
		bonus = GET_LEVEL(ch) * 4;
   else
      bonus = GET_LEVEL(ch) * 5;

   return bonus;
d3627 11
a3637 11
   int tmphps;
int x;
   /*AC change*/
   GET_AC(ch) = 100 - (static_ac(GET_DEX(ch)) + total_stats_of_wears(ch, APPLY_AC));
   /*max min this*/
   GET_AC(ch) = MIN(100, MAX(-100, GET_AC(ch)));
   /*Hit bonus*/
   tmphps = GET_MAX_HIT(ch) - GET_HIT(ch);
   GET_MAX_HIT(ch) = GET_NATHPS(ch) + con_aff(ch) + total_stats_of_wears(ch, APPLY_HIT);
   if (tmphps == 0)/*restore hps*/
   {
d3639 4
a3642 4
   }
 x = GET_MAX_HIT(ch) - GET_HIT(ch);
   x = x - tmphps;   alter_hit(ch, 0 - x, 2);

d3648 6
a3653 6
   int value = 0;
   int i, j;
   struct affected_type *af;
/*APPLY_AC = 17, ITEM_ARMOR = 9, APPLY_HIT = 13*/
   for (i = 0; i < NUM_WEARS; i++) 
   {
d3655 2
a3656 2
      {
         if ((GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR) && (TYPE == APPLY_AC))
d3658 9
a3666 9
         for (j = 0; j < MAX_OBJ_AFFECT; j++)
         {
            if (GET_EQ(ch, i)->affected[j].location == TYPE)
               value = value + GET_EQ(ch, i)->affected[j].modifier;
         }      
      }
   }
   for (af = ch->affected; af; af = af->next) 
   {
d3668 2
a3669 2
      {
         if (TYPE == APPLY_AC)
d3671 1
a3671 1
         else
d3673 3
a3675 3
      }
   }
   return value;
d3684 100
a3783 100
	GET_ADD(ch) = GET_ADD_VAFF(ch);
		switch (GET_RACE(ch)) {
	case RACE_GNOME:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)GNOME_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)GNOME_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)GNOME_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)GNOME_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)GNOME_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)GNOME_CON));
	break;
	case RACE_OGRE:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)OGRE_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)OGRE_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)OGRE_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)OGRE_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)OGRE_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)OGRE_CON));
		break;
	case RACE_HUMAN:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HUMAN_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HUMAN_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HUMAN_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HUMAN_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HUMAN_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HUMAN_CON));
		break;
	case RACE_BARBARIAN:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)BARBARIAN_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)BARBARIAN_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)BARBARIAN_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)BARBARIAN_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)BARBARIAN_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)BARBARIAN_CON));
		break;
	case RACE_TROLL:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)TROLL_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)TROLL_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)TROLL_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)TROLL_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)TROLL_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)TROLL_CON));
		break;
	case RACE_HALF_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALF_ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALF_ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALF_ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALF_ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALF_ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALF_ELF_CON));
		break;
	case RACE_DROW_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DROW_ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DROW_ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DROW_ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DROW_ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DROW_ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DROW_ELF_CON));
		break;
	case RACE_HALFLING:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)HALFLING_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)HALFLING_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)HALFLING_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)HALFLING_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)HALFLING_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)HALFLING_CON));
		break;
	case RACE_DWARF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DWARF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DWARF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DWARF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DWARF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DWARF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DWARF_CON));
		break;
	case RACE_DUERGAR:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)DUERGAR_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)DUERGAR_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)DUERGAR_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)DUERGAR_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)DUERGAR_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)DUERGAR_CON));
	break;
	case RACE_ORC:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ORC_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ORC_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ORC_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ORC_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ORC_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ORC_CON));
	break;
	case RACE_ELF:
		GET_STR(ch) = (char) (GET_STR_VAFF(ch)/(100/(float)ELF_STR));
		GET_INT(ch) = (char) (GET_INT_VAFF(ch)/(100/(float)ELF_INT));
		GET_DEX(ch) = (char) (GET_DEX_VAFF(ch)/(100/(float)ELF_DEX));
		GET_WIS(ch) = (char) (GET_WIS_VAFF(ch)/(100/(float)ELF_WIS));
		GET_CHA(ch) = (char) (GET_CHA_VAFF(ch)/(100/(float)ELF_CHA));
		GET_CON(ch) = (char) (GET_CON_VAFF(ch)/(100/(float)ELF_CON));
	break;
	}
   return;
d3788 103
a3890 103
	/*Ok this function's aim is to convert the data in view_abils
	into the function the computer uses real_abils, then it will aslo
	add any effects that might be effecting the player*/
	GET_RADD(ch) = GET_ADD_VIEW(ch);
	switch (GET_RACE(ch)) {
	case RACE_GNOME:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)GNOME_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)GNOME_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)GNOME_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)GNOME_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)GNOME_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)GNOME_CON));
	break;
	case RACE_HUMAN:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HUMAN_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HUMAN_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HUMAN_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HUMAN_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HUMAN_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HUMAN_CON));
	break;
	case RACE_OGRE:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)OGRE_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)OGRE_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)OGRE_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)OGRE_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)OGRE_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)OGRE_CON));
	break;
	case RACE_BARBARIAN:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)BARBARIAN_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)BARBARIAN_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)BARBARIAN_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)BARBARIAN_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)BARBARIAN_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)BARBARIAN_CON));
	break;
	case RACE_TROLL:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)TROLL_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)TROLL_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)TROLL_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)TROLL_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)TROLL_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)TROLL_CON));
	break;
	case RACE_HALF_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALF_ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALF_ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALF_ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALF_ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALF_ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALF_ELF_CON));
	break;
	case RACE_DROW_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DROW_ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DROW_ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DROW_ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DROW_ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DROW_ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DROW_ELF_CON));
	break;
	case RACE_HALFLING:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)HALFLING_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)HALFLING_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)HALFLING_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)HALFLING_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)HALFLING_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)HALFLING_CON));
	break;
	case RACE_DWARF:
	GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DWARF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DWARF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DWARF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DWARF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DWARF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DWARF_CON));
	break;
	case RACE_DUERGAR:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)DUERGAR_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)DUERGAR_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)DUERGAR_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)DUERGAR_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)DUERGAR_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)DUERGAR_CON));
	break;
	case RACE_ORC:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ORC_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ORC_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ORC_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ORC_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ORC_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ORC_CON));
	break;
	case RACE_ELF:
		GET_RSTR(ch) = (char) (GET_STR_VIEW(ch)/(100/(float)ELF_STR));
		GET_RINT(ch) = (char) (GET_INT_VIEW(ch)/(100/(float)ELF_INT));
		GET_RDEX(ch) = (char) (GET_DEX_VIEW(ch)/(100/(float)ELF_DEX));
		GET_RWIS(ch) = (char) (GET_WIS_VIEW(ch)/(100/(float)ELF_WIS));
		GET_RCHA(ch) = (char) (GET_CHA_VIEW(ch)/(100/(float)ELF_CHA));
		GET_RCON(ch) = (char) (GET_CON_VIEW(ch)/(100/(float)ELF_CON));
	break;
	}
	return ;
d3896 1
a3896 1
Redone a hunred times over by me and others...Banyal*/
d3903 1
a3903 1
sbyte stdam, hitr;
d3915 1
a3915 1

d3917 1
a3917 1

d3924 1
a3924 1

d3941 1
a3941 1

d3945 1
a3945 1
the
d3948 1
a3948 1

d3951 1
a3951 1

d3954 1
a3954 1

d3961 1
a3961 1

d3980 1
a3980 1

d3983 1
a3983 1
  st->points.hitroll = 0;
d3990 8
a3997 8
      
    if (GET_PROMPT(ch))
      strcpy(st->prompt, GET_PROMPT(ch));
    else
      *(st->prompt) = *str_dup(std_prompt);
	  
	   

d4003 1
a4003 1

d4005 1
a4005 1

d4011 1
a4011 1

d4016 2
a4017 2
   affect_total(ch);
   
d4030 1
a4030 1

d4038 1
a4038 1

d4049 1
a4049 1

d4053 1
a4053 1

d4060 2
a4061 2
*  funcs of a (more or less) general utility nature			*
********************************************************************** */
d4070 1
a4070 1

d4072 1
a4072 1

d4089 1
a4089 1

d4091 1
a4091 1

d4101 1
a4101 1

d4108 1
a4108 1

d4119 1
a4119 1

d4129 8
a4136 8
  /*  if (ch->player_specials->last_olc_targ)
      free(ch->player_specials->last_olc_targ);
  if (ch->player_specials->last_olc_mode)
      free(ch->player_specials->last_olc_mode);
  if (ch->player_specials->roll[6])
    free(ch->player_specials->roll[6]);
  if (ch->player_specials->ignored)
   free(ch->player_specials->ignored); */
d4147 1
a4147 1
	if (ch->player.prompt)
d4172 1
a4172 1

d4185 1
a4185 1

d4223 1
a4223 1

d4233 1
a4233 1

d4236 1
a4236 1

d4254 1
a4254 1

d4276 1
a4276 1

d4278 1
a4278 1

d4288 1
a4288 1

d4291 1
a4291 1
REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
d4294 1
a4294 1
ch->followers = NULL;  ch->master = NULL;
d4320 1
a4320 1
      GET_NATHPS(ch) = GET_MAX_HIT(ch);
d4322 1
a4322 1

d4333 1
a4333 1

d4340 2
a4341 2

for (i = 0; i < MAX_ACTION_DELAYS; i++)
d4343 2
a4344 2


d4354 1
a4354 1

d4366 1
a4366 1

d4370 1
a4370 1

d4372 1
a4372 1

d4376 1
a4376 1

d4382 1
a4382 1

d4387 1
a4387 1

d4389 1
a4389 1

d4393 1
a4393 1

d4396 1
a4396 1

d4399 53
a4451 53
	  if (ch->player.race == RACE_HUMAN) {
    ch->player.weight = number(120, 180);
    ch->player.height = number(60, 76);
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.weight = number(100, 170);
    ch->player.height = number(60, 76);
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.weight = number(170, 260);
    ch->player.height = number(69, 88);
	  }
	  if (ch->player.race == RACE_DWARF) {
    ch->player.weight = number(170, 200);
    ch->player.height = number(38, 50);
	  }
      if (ch->player.race == RACE_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_HALFLING) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(35, 42);
	  }
	  if (ch->player.race == RACE_GNOME) {
	ch->player.weight = number(40, 90);
    ch->player.height = number(26, 38);
	  }
	  if (ch->player.race == RACE_ORC) {
	ch->player.weight = number(90, 150);
    ch->player.height = number(58, 68);
	  }
	  if (ch->player.race == RACE_TROLL) {
	ch->player.weight = number(130, 290);
    ch->player.height = number(72, 90);
	  }
	  if (ch->player.race == RACE_OGRE) {
	ch->player.weight = number(390, 530);
    ch->player.height = number(93, 119);
	  }
	  if (ch->player.race == RACE_DUERGAR) {
	ch->player.weight = number(170, 200);
    ch->player.height = number(38, 50);
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }

d4454 89
a4542 52
    ch->player.weight = number(95, 150);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
    ch->player.weight = number(94, 155);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
    ch->player.weight = number(130, 210);
    ch->player.height = number(69, 80);
	  }
	  if (ch->player.race == RACE_DWARF) {
    ch->player.weight = number(150, 190);
    ch->player.height = number(38, 50);
	  }
      if (ch->player.race == RACE_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(59, 68);
	  }
	  if (ch->player.race == RACE_HALFLING) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(35, 42);
	  }
	  if (ch->player.race == RACE_GNOME) {
	ch->player.weight = number(40, 90);
    ch->player.height = number(26, 38);
	  }
	  if (ch->player.race == RACE_ORC) {
	ch->player.weight = number(90, 150);
    ch->player.height = number(58, 68);
	  }
	  if (ch->player.race == RACE_TROLL) {
	ch->player.weight = number(130, 290);
    ch->player.height = number(72, 90);
	  }
	  if (ch->player.race == RACE_OGRE) {
	ch->player.weight = number(390, 530);
    ch->player.height = number(93, 119);
	  }
	  if (ch->player.race == RACE_DUERGAR) {
	ch->player.weight = number(150, 190);
    ch->player.height = number(38, 50);
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
	ch->player.weight = number(90, 160);
    ch->player.height = number(60, 70);
	  }
 
d4544 5
a4548 42

   if (ch->player.race == RACE_HUMAN) {
		ch->player.size = SIZE_MEDIUM; 
	  }
	  if (ch->player.race == RACE_HALF_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_BARBARIAN) {
		ch->player.size = SIZE_LARGE;
	  }
	  if (ch->player.race == RACE_DWARF) {
		ch->player.size = SIZE_MEDIUM;
	  }
      if (ch->player.race == RACE_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_HALFLING) {
		ch->player.size = SIZE_SMALL;
	  }
	  if (ch->player.race == RACE_GNOME) {
		ch->player.size = SIZE_SMALL;
	  }
	  if (ch->player.race == RACE_ORC) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_TROLL) {
		ch->player.size = SIZE_LARGE;
	  }
	  if (ch->player.race == RACE_OGRE) {
		ch->player.size = SIZE_HUGE;
	  }
	  if (ch->player.race == RACE_DUERGAR) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_DROW_ELF) {
		ch->player.size = SIZE_MEDIUM;
	  }
	  if (ch->player.race == RACE_UNDEFINED) {
		ch->player.size = SIZE_MEDIUM;
	  /*}else{ch->player.size = SIZE_MEDIUM;*/}


d4562 2
a4563 2
    else   
      SET_SKILL(ch, i, 1000);
d4565 1
a4565 1

d4572 10
a4581 10

 /* ch->real_abils.intel = 25;
  *ch->real_abils.wis = 25;
  *ch->real_abils.dex = 25;
  *ch->real_abils.str = 25;
  *ch->real_abils.str_add = 100;
  *ch->real_abils.con = 25;
  *ch->real_abils.cha = 25;
  */

d4584 1
a4584 1

d4587 1
a4587 1

d4597 1
a4597 1

d4600 1
a4600 1

d4604 1
a4604 1

d4622 1
a4622 1

d4625 1
a4625 1

d4629 1
a4629 1

d4646 4
a4649 4
  {
  fseek(player_fl, player_i * sizeof(struct char_file_u), SEEK_SET);
  fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
  }
d4658 1
a4658 1

d4661 1
a4661 1

d4665 1
a4665 1

d4683 15
d4699 12
a4710 14
  int mprog_name_to_type (char *name)
  {
      if (!str_cmp(name, "in_file_prog"  ))    return IN_FILE_PROG;
      if (!str_cmp(name, "act_prog"      ))    return ACT_PROG;
      if (!str_cmp(name, "speech_prog"   ))    return SPEECH_PROG;
      if (!str_cmp(name, "rand_prog"     ))    return RAND_PROG;
      if (!str_cmp(name, "fight_prog"    ))    return FIGHT_PROG;
      if (!str_cmp(name, "hitprcnt_prog" ))    return HITPRCNT_PROG;
      if (!str_cmp(name, "death_prog"    ))    return DEATH_PROG;
      if (!str_cmp(name, "entry_prog"    ))    return ENTRY_PROG;
      if (!str_cmp(name, "greet_prog"    ))    return GREET_PROG;
      if (!str_cmp(name, "all_greet_prog"))    return ALL_GREET_PROG;
      if (!str_cmp(name, "give_prog"     ))    return GIVE_PROG;
      if (!str_cmp(name, "bribe_prog"    ))    return BRIBE_PROG;
d4712 3
a4714 2
      return(ERROR_PROG);
  }
d4716 1
d4718 7
a4724 22
    /*
     * Read a number from a file.
     */
    int fread_number(FILE *fp)
    {
        int number;
        bool sign;
        char c;
  
        do {
            c = getc(fp);
        } while (isspace(c));
  
        number = 0;
  
        sign   = FALSE;
        if (c == '+') {
            c = getc(fp);
        } else if (c == '-') {
            sign = TRUE;
            c = getc(fp);
        }
d4727 4
a4730 4
        if (!isdigit(c)) {
            log("Fread_number: bad format.");
            exit(1);
        }
d4732 4
a4735 4
        while (isdigit(c)) {
            number = number * 10 + c - '0';
            c      = getc(fp);
        }
d4737 2
a4738 2
        if (sign)
            number = 0 - number;
d4740 4
a4743 4
        if (c == '|')
            number += fread_number(fp);
        else if (c != ' ')
            ungetc(c, fp);
d4745 9
a4753 2
        return number;
    }
d4755 3
a4757 6
    /*
     * Read to end of line (for comments).
     */
    void fread_to_eol(FILE *fp)
    {
        char c;
d4759 3
a4761 3
        do {
            c = getc(fp);
        } while (c != '\n' && c != '\r');
d4763 13
a4775 3
        do {
            c = getc(fp);
        } while (c == '\n' || c == '\r');
d4777 3
a4779 2
        ungetc(c, fp);
        return;
d4781 1
d4783 10
d4794 1
a4794 4
    /*
     * Read one word (into static buffer).
     */
    char *fread_word(FILE *fp)
d4796 9
a4804 3
        static char word[MAX_INPUT_LENGTH];
        char *pword;
        char cEnd;
d4806 1
a4806 30
        do
        {
            cEnd = getc(fp);
        }
        while (isspace(cEnd));
  
        if (cEnd == '\'' || cEnd == '"')
        {
            pword   = word;
        }
        else
        {
            word[0] = cEnd;
            pword   = word+1;
            cEnd    = ' ';
        }
  
        for (; pword < word + MAX_INPUT_LENGTH; pword++)
        {
            *pword = getc(fp);
            if (cEnd == ' ' ? isspace(*pword) || *pword == '~' : *pword == cEnd)
            {
                if (cEnd == ' ' || cEnd == '~')
                    ungetc(*pword, fp);
                *pword = '\0';
                return word;
            }
        }
  
        log("SYSERR: Fread_word: word too long.");
d4809 8
a4816 1
    }
d4818 5
d4824 1
a4824 1
    /* This routine reads in scripts of MOBprograms from a file */
d4826 2
a4827 2
    MPROG_DATA* mprog_file_read(char *f, MPROG_DATA *mprg,
                                struct index_data *pMobIndex)
d4829 4
d4834 14
a4847 5
      char        MOBProgfile[ MAX_INPUT_LENGTH ];
      MPROG_DATA *mprg2;
      FILE       *progfile;
      char        letter;
      bool        done = FALSE;
d4849 4
a4852 29
      sprintf(MOBProgfile, "%s/%s", MOB_DIR, f);
  
      progfile = fopen(MOBProgfile, "r");
      if (!progfile)
      {
         sprintf(err_buf, "Mob: %d couldnt open mobprog file", pMobIndex->virtual);
         log(err_buf);
         exit(1);
      }
  
      mprg2 = mprg;
      switch (letter = fread_letter(progfile))
      {
        case '>':
         break;
        case '|':
           log("empty mobprog file.");
           exit(1);
         break;
        default:
           log("in mobprog file syntax error.");
           exit(1);
         break;
      }
  
      while (!done)
      {
        mprg2->type = mprog_name_to_type(fread_word(progfile));
        switch (mprg2->type)
d4854 3
a4856 3
         case ERROR_PROG:
            log("mobprog file type error");
            exit(1);
d4858 3
a4860 3
         case IN_FILE_PROG:
            log("mprog file contains a call to file.");
            exit(1);
d4862 6
a4867 6
         default:
            sprintf(buf2, "Error in file %s", f);
            pMobIndex->progtypes = pMobIndex->progtypes | mprg2->type;
            mprg2->arglist       = fread_string(progfile,buf2);
            mprg2->comlist       = fread_string(progfile,buf2);
            switch (letter = fread_letter(progfile))
d4869 13
a4881 13
              case '>':
                 mprg2->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg2       = mprg2->next;
                 mprg2->next = NULL;
               break;
              case '|':
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf,"in mobprog file %s syntax error.", f);
                 log(err_buf);
                 exit(1);
               break;
a4884 3
      }
      fclose(progfile);
      return mprg2;
d4886 32
d4919 1
a4919 2
  
    struct index_data *get_obj_index (int vnum)
d4921 3
a4923 5
      int nr;
      for(nr = 0; nr <= top_of_objt; nr++) {
        if(obj_index[nr].virtual == vnum) return &obj_index[nr];
      }
      return NULL;
d4925 2
d4928 1
a4928 1
    struct index_data *get_mob_index (int vnum)
d4930 2
a4931 30
      int nr;
      for(nr = 0; nr <= top_of_mobt; nr++) {
        if(mob_index[nr].virtual == vnum) return &mob_index[nr];
      }
      return NULL;
    }
  
  
    /* This procedure is responsible for reading any in_file MOBprograms.
     */
  
    void mprog_read_programs(FILE *fp, struct index_data *pMobIndex)
    {
      MPROG_DATA *mprg;
      char        letter;
      bool        done = FALSE;
  
      if ((letter = fread_letter(fp)) != '>')
      {
          sprintf(err_buf,"Load_mobiles: vnum %d MOBPROG char", pMobIndex->virtual);
          log(err_buf);
          exit(1);
      }
      pMobIndex->mobprogs = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
      mprg = pMobIndex->mobprogs;
  
      while (!done)
      {
        mprg->type = mprog_name_to_type(fread_word(fp));
        switch (mprg->type)
d4933 4
a4936 4
         case ERROR_PROG:
            sprintf(err_buf, "Load_mobiles: vnum %d MOBPROG type.", pMobIndex->virtual);
            log(err_buf);
            exit(1);
d4938 5
a4942 5
         case IN_FILE_PROG:
            sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
            mprg = mprog_file_read(fread_word(fp), mprg,pMobIndex);
            fread_to_eol(fp);   /* need to strip off that silly ~*/
            switch (letter = fread_letter(fp))
d4944 15
a4958 15
              case '>':
                 mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg       = mprg->next;
                 mprg->next = NULL;
               break;
              case '|':
                 mprg->next = NULL;
                 fread_to_eol(fp);
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG.", pMobIndex->virtual);
                 log(err_buf);
                 exit(1);
               break;
d4961 6
a4966 6
         default:
            sprintf(buf2, "Mobprog for mob #%d", pMobIndex->virtual);
            pMobIndex->progtypes = pMobIndex->progtypes | mprg->type;
            mprg->arglist        = fread_string(fp, buf2);
            mprg->comlist        = fread_string(fp, buf2);
            switch (letter = fread_letter(fp))
d4968 16
a4983 16
              case '>':
                 mprg->next = (MPROG_DATA *)malloc(sizeof(MPROG_DATA));
                 mprg       = mprg->next;
                 mprg->next = NULL;
               break;
              case '|':
                 mprg->next = NULL;
                 fread_to_eol(fp);
                 done = TRUE;
               break;
              default:
                 sprintf(err_buf, "Load_mobiles: vnum %d bad MOBPROG (%c).", 
  	       pMobIndex->virtual, letter);
                 log(err_buf);
                 exit(1);
               break;
d4987 1
a4987 1
      }
d4989 2
a4990 2
      return;
  }
d5023 1
a5023 1

d5031 1
a5031 1

d5034 1
a5034 1

d5039 1
a5039 1

d5042 13
@
