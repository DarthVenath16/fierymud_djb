head	1.44;
access;
symbols;
locks; strict;
comment	@ * @;


1.44
date	2009.07.16.04.17.47;	author myc;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.20.23.55.13;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.11.02.13.41;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.11.01.57.23;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.11.01.09.58;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.09.21.50.21;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.09.05.34.09;	author myc;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.17.06.53.06;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.27.05.12.48;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.18.03.51.32;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.19.04.32.14;	author myc;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.05.05.08.28;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.08.22.36.14;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.05.06.06.35;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.05.05.36.34;	author jps;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.25.05.33.55;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.20.23.10.20;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.19.20.40.36;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.11.20.27.48;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.20.18.43.29;	author rsd;	state Exp;
branches;
next	1.4;

1.4
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.18.04.01;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/**************************************************************************
 * File: clan.c                                                     Hubis *
 * Usage: Code for the clan system                                        *
 **************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "spells.h"
#include "handler.h"
#include "clan.h"

int num_of_clans;
struct clan_rec clan[MAX_CLANS];

extern save_char_file_u(struct char_file_u st);
extern struct descriptor_data *descriptor_list;
extern struct char_data *is_playing(char *vict_name);

char clan_privileges[NUM_CP+1][20] ={
"setplan","enroll","expel","promote","demote","setfees","withdraw","setapplev"};

void send_clan_format(struct char_data *ch)
{
int c,r;

send_to_char("Clan commands available to you:\n\r",ch);
if(GET_LEVEL(ch)>=LVL_CLAN_GOD){
  send_to_char("   clan who        <clan number>\r\n",ch);
  send_to_char("   clan snoop      <off | all | clan number >\r\n",ch);
  send_to_char("   clan rename     <clan number> <name>\r\n",ch);
}
else
  send_to_char("   clan who\r\n",ch);
send_to_char("   clan status\r\n"
             "   clan info       [clan number]\r\n",ch);
if(GET_LEVEL(ch)>=LVL_CLAN_GOD)
  send_to_char("   clan create     <leader> <clan name>\r\n"
               "   clan destroy    <clan number>\r\n"
               "   clan enroll     <player> <clan number>\r\n"
               "   clan expel      <player> <clan number>\r\n"
               "   clan promote    <player> <clan number>\r\n"
               "   clan demote     <player> <clan number>\r\n"
               "   clan withdraw   <clan number> <amount>\r\n"
               "   clan deposit    <clan number> <amount>\r\n"
               "   clan set ranks  <rank>   <clan number>\r\n"
               "   clan set appfee <amount> <clan number>\r\n"
               "   clan set dues   <amount> <clan number>\r\n"
               "   clan set applev <level>  <clan number>\r\n"
               "   clan set plan   <clan number>\r\n"
               "   clan privilege  <privilege>   <rank> <clan number>\r\n"
               "   clan set title  <clan number> <rank> <title>\r\n",ch);
else {
  c=find_clan_by_id(GET_CLAN(ch));
  r=GET_CLAN_RANK(ch);
  if(r<1)
    send_to_char("   clan apply      <clan number>\r\n",ch);
  if(c>=0) {
    send_to_char("   clan deposit    <amount>\r\n",ch);
    if(r>=clan[c].privilege[CP_WITHDRAW])
      send_to_char("   clan withdraw   <amount>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_ENROLL])
      send_to_char("   clan enroll     <player>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_EXPEL])
      send_to_char("   clan expel      <player>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_PROMOTE])
      send_to_char("   clan promote    <player>\r\n",ch);
    if(r>=clan[c].privilege[CP_DEMOTE])
      send_to_char("   clan demote     <player>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_APPLEV])
      send_to_char("   clan set applev <level>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_FEES])
      send_to_char("   clan set appfee <amount>\r\n"
                   "   clan set dues   <amount>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_PLAN])
      send_to_char("   clan set plan\r\n",ch);
    if(r==clan[c].ranks)
      send_to_char("   clan set ranks  <rank>\r\n"
                   "   clan set title  <rank> <title>\r\n"
                   "   clan privilege  <privilege> <rank>\r\n",ch);
    }
  }
}

/*
   This function retitles all members to their appropriate titles
   and also purges any names in the roster that do not belong.
   Warning: the char_data passed to this function CAN BE NULL!
   So if any other uses of ch are used here, always check for null.
   -- Nechtrous
*/
void update_clan(struct char_data *ch, int clan_num)
{
int i;
struct char_data *victim;
struct char_file_u chdata;

for(i=0;i<MAX_MEMBERS_PER_CLAN;i++) {
  if(!(clan[clan_num].member_list[i][0]))
    continue;
  if((victim=is_playing(clan[clan_num].member_list[i]))) {
    if(GET_CLAN(victim) == clan[clan_num].id) {
      sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(victim)-1], clan[clan_num].name);
      set_title(victim, buf);
      save_char(victim, victim->in_room);
    }
    else {
      clan[clan_num].member_list[i][0] = '\0';
      if(ch){
        sprintf(buf,"%s was purged from %s&0's roster.\r\n",GET_NAME(victim),clan[clan_num].name);
        send_to_char(buf,ch);
      }
    }
  }
  else {
    load_char(clan[clan_num].member_list[i], &chdata);
    if(chdata.player_specials_saved.clan==clan[clan_num].id) {
      sprintf(buf, "%s %s",clan[clan_num].rank_name[chdata.player_specials_saved.clan_rank - 1], clan[clan_num].name);
      buf[80] = '\0';
      strcpy(chdata.title,buf);
      save_char_file_u(chdata);
    }
    else {
      clan[clan_num].member_list[i][0] = '\0';
      if (ch){
        sprintf(buf,"%s was purged from %s&0's roster.\r\n",chdata.name,clan[clan_num].name);
        send_to_char(buf,ch);
      }
    }
  }
}
save_clans();
}

void do_clan_create (struct char_data *ch, char *arg)
{
struct char_data *leader = NULL;
char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
int new_id=0,i;

if (!*arg) {
  send_clan_format(ch);
  return; }

if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You are not mighty enough to create new clans!\r\n", ch);
  return; }

if(num_of_clans == MAX_CLANS) {
  send_to_char("Max clans reached. WOW!\r\n",ch);
  return; }

half_chop(arg, arg1, arg2);

if(!(leader=get_char_vis(ch,arg1))) {
  send_to_char("The leader of the new clan must be present.\r\n",ch);
  return; }

if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
  send_to_char("Clan name too long! (32 characters max)\r\n",ch);
  return; }

if(GET_LEVEL(leader)>=LVL_IMMORT) {
  send_to_char("You cannot set an immortal as the leader of a clan.\r\n",ch);
  return; }

if(GET_CLAN(leader)!=0 && GET_CLAN_RANK(leader)!=0) {
  send_to_char("The leader already belongs to a clan!\r\n",ch);
  return; }

if(find_clan(arg2)!=-1) {
  send_to_char("That clan name alread exists!\r\n",ch);
  return; }

strncpy(clan[num_of_clans].name, arg2, 100);
for(i=0;i<num_of_clans;i++)
  if(new_id<clan[i].id)
    new_id=clan[i].id;
clan[num_of_clans].id=new_id+1;
clan[num_of_clans].ranks =  2;
strcpy(clan[num_of_clans].rank_name[0],"Member");
strcpy(clan[num_of_clans].rank_name[1],"Leader");
clan[num_of_clans].treasure = 0 ;
clan[num_of_clans].plat = 0;
clan[num_of_clans].gold = 0;
clan[num_of_clans].silver = 0;
clan[num_of_clans].copper = 0;
clan[num_of_clans].members = 1 ;
clan[num_of_clans].power = GET_LEVEL(leader) ;
clan[num_of_clans].app_fee = 0 ;
clan[num_of_clans].dues = 0 ;
clan[num_of_clans].app_level = DEFAULT_APP_LVL ;
for(i=0;i<20;i++)
  clan[num_of_clans].spells[i]=0;
for(i=0;i<20;i++)
  clan[num_of_clans].privilege[i]=clan[num_of_clans].ranks;
for(i=0;i<4;i++)
  clan[num_of_clans].at_war[i]=0;
for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
  clan[num_of_clans].member_list[i][0] = '\0';
strcpy(clan[num_of_clans].member_list[0], GET_NAME(leader));
num_of_clans++;
save_clans();
send_to_char("Clan created.\r\n", ch);
GET_CLAN(leader)=clan[num_of_clans-1].id;
GET_CLAN_RANK(leader)=clan[num_of_clans-1].ranks;
sprintf(buf, "%s %s", clan[num_of_clans-1].rank_name[GET_CLAN_RANK(leader) -1],
		      clan[num_of_clans-1].name);
set_title(leader, buf);
save_char(leader, leader->in_room);
sprintf(buf, "%s created clan : %s", GET_NAME(ch), clan[num_of_clans-1].name);
log(buf);
return;
}

void do_clan_rename (struct char_data *ch, char *arg)
{
char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
int clan_num;

if (!*arg) {
  send_clan_format(ch);
  return; }

if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You are not mighty enough to rename clans!\r\n", ch);
  return; }

half_chop(arg, arg1, arg2);

if(!is_number(arg1)) {
  send_to_char("You need to specify a clan number.\r\n",ch);
  return;
}
if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
  send_to_char("There is no clan with that number.\r\n",ch);
  return;
}

if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
  send_to_char("Clan name too long! (32 characters max)\r\n",ch);
  return; }

if(find_clan(arg2)!=-1) {
  send_to_char("That clan name alread exists!\r\n",ch);
  return; }

strncpy(clan[clan_num].name, arg2, 100);
send_to_char("Clan renamed.\r\n", ch);
update_clan(ch, clan_num);
return;
}


void do_clan_destroy (struct char_data *ch, char *arg)
{

int i,j;
extern int top_of_p_table;
extern struct player_index_element *player_table;
struct char_file_u chdata;
struct char_data *victim=NULL;

if (!*arg) {
  send_clan_format(ch);
  return; }

if(!is_number(arg)) {
  send_to_char("You need to specify a clan number.\r\n",ch);
  return;
}
if((i=atoi(arg))<0 || i>=num_of_clans) {
  send_to_char("There is no clan with that number.\r\n",ch);
  return;
}

if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
  send_to_char("Your not mighty enough to destroy clans!\r\n", ch);
  return; }

for (j = 0; j <= top_of_p_table; j++){
  if((victim=is_playing((player_table +j)->name))) {
    if(GET_CLAN(victim)==clan[i].id) {
      GET_CLAN(victim)=0;
      GET_CLAN_RANK(victim)=0;
      set_title(victim, "");
      save_char(victim, victim->in_room);
      send_to_char("&5&bYour clan has been destroyed!&0\r\n", victim); } }
  else {
    load_char((player_table + j)->name, &chdata);
    if(chdata.player_specials_saved.clan==clan[i].id) {
      chdata.player_specials_saved.clan=0;
      chdata.player_specials_saved.clan_rank=0;
      chdata.title[0] = '\0';
      save_char_file_u(chdata); } } }

sprintf(buf2, "%s has destroyed a clan: %s", GET_NAME(ch), clan[i].name);

memset(&clan[i], sizeof(struct clan_rec), 0);

for (j = i; j < num_of_clans - 1; j++)
  clan[j] = clan[j + 1];

num_of_clans--;

send_to_char("Clan deleted.\r\n", ch);
save_clans();
log(buf2);
return;
}

void do_clan_enroll (struct char_data *ch, char *arg)
{
struct char_data *vict=NULL;
int clan_num,immcom=0,i;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return;
}

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return;
  }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);

  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ENROLL] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return;
}
else {
  if (clan[clan_num].members >= MAX_MEMBERS_PER_CLAN){
    if (GET_LEVEL(ch) >= LVL_IMMORT)
    send_to_char("That clan already has the maximum allowed members!\r\n",ch);
    else
    send_to_char("Your clan already has the maximum allowed members!\r\n",ch);
    return;
  }
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    if(GET_CLAN_RANK(vict)>0) {
      send_to_char("They're already in a clan.\r\n",ch);
      return;
    }
    else {
      send_to_char("They didn't request to join your clan.\r\n",ch);
      return;
    }
  }
  else
    if(GET_CLAN_RANK(vict)>0) {
      send_to_char("They're already in your clan.\r\n",ch);
      return;
    }
  if(GET_LEVEL(vict)>=LVL_IMMORT) {
    send_to_char("You cannot enroll immortals in clans.\r\n",ch);
    return; }
}

GET_CLAN_RANK(vict)++;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
for(i=0;i<MAX_MEMBERS_PER_CLAN && clan[clan_num].member_list[i][0];i++);
strcpy(clan[clan_num].member_list[i], GET_NAME(vict));
clan[clan_num].power += GET_LEVEL(vict);
clan[clan_num].members++;
send_to_char("You've been enrolled in the clan you chose!\r\n",vict);
send_to_char("Your new title is:", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);

return;
}

void do_clan_expel (struct char_data *ch, char *arg)
{
struct char_data *vict=NULL;
int i,clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_EXPEL] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
    return; }
  else {
    if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot kick out that person.\r\n",ch);
      return; } } }

GET_CLAN(vict)=0;
GET_CLAN_RANK(vict)=0;
set_title(vict, "");
save_char(vict, vict->in_room);
clan[clan_num].members--;
clan[clan_num].power-=GET_LEVEL(vict);
for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
  if (!strcmp(clan[clan_num].member_list[i],GET_NAME(vict)))
    clan[clan_num].member_list[i][0] = '\0';
send_to_char("You've been kicked out of your clan!\r\n",vict);
send_to_char("Done.\r\n",ch);

return;
}

void do_clan_demote (struct char_data *ch, char *arg)
{
struct char_data *vict=NULL;
int clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_DEMOTE] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
    return; }
  else {
    if(GET_CLAN_RANK(vict)==1) {
      send_to_char("They can't be demoted any further, use expel now.\r\n",ch);
      return; }
    if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot demote a person of this rank!\r\n",ch);
      return; } } }

GET_CLAN_RANK(vict)--;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
send_to_char("You've demoted within your clan!\r\n",vict);
send_to_char("Your new title is:", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);
return;
}

void do_clan_promote (struct char_data *ch, char *arg)
{
struct char_data *vict=NULL;
int clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_PROMOTE] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
    return; }
  else {
    if(GET_CLAN_RANK(vict)==0) {
      send_to_char("They're not enrolled yet.\r\n",ch);
      return; }
    if((GET_CLAN_RANK(vict)+1)>GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot promote that person over your rank!\r\n",ch);
      return; }
    if(GET_CLAN_RANK(vict)==clan[clan_num].ranks) {
      send_to_char("You cannot promote someone over the top rank!\r\n",ch);
      return; } } }

GET_CLAN_RANK(vict)++;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
send_to_char("You've been promoted within your clan!\r\n",vict);
send_to_char("Your new title is: ", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);
return;
}

void do_clan_who (struct char_data *ch, char *arg)
{
struct char_data *victim;
struct char_file_u chdata;
int k, j, i;


if(GET_CLAN_RANK(ch)==0 && GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You do not belong to a clan!\r\n",ch);
  return; }

if(GET_LEVEL(ch) >= LVL_CLAN_GOD) {
  if (!arg) {
    send_to_char("You must specify a clan number.\r\n",ch);
    return;
  }
  if((i=atoi(arg))<0 || i>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}
else
i = find_clan_by_id(GET_CLAN(ch));

if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
  sprintf(buf, "\r\n&3&bListing of clan members&0\r\n");
  sprintf(buf, "%s&3-----------------------&0\r\n",buf);
}
else{
  sprintf(buf, "\r\n&3&bMember listing for &0%s&0\r\n\r\n", clan[i].name);
}

for(k=clan[i].ranks;k>0;k--){
  for (j=0;j<MAX_MEMBERS_PER_CLAN;j++) {
    if(!(clan[i].member_list[j][0]))
      continue;
    if((victim=is_playing(clan[i].member_list[j]))) {
      if(GET_CLAN(victim)==clan[i].id && GET_CLAN_RANK(victim)==k) {
        if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	  sprintf(buf, "%s%2d", buf, j);
        sprintf(buf, "%s&0&2&bo&0 %-20.20s %s\r\n", buf,GET_NAME(victim),GET_TITLE(victim));
      }
    }
    else {
      load_char(clan[i].member_list[j], &chdata);
      if(chdata.player_specials_saved.clan==clan[i].id
         && chdata.player_specials_saved.clan_rank == k) {
        if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	  sprintf(buf, "%s%2d", buf, j);
        sprintf(buf, "%s&0%-2.2s%-20.20s %s\r\n", buf,"",chdata.name,chdata.title);
      }
    }
  }
}
page_string(ch->desc, buf, 1);

return;
}

void do_clan_status (struct char_data *ch)
{
char line_disp[200];
int clan_num;

if(GET_LEVEL(ch)>=LVL_IMMORT) {
  send_to_char("You are immortal and cannot join any clan!\r\n",ch);
  return; }

clan_num=find_clan_by_id(GET_CLAN(ch));

if(GET_CLAN_RANK(ch)==0)
  if(clan_num>=0) {
    sprintf(line_disp,"You applied to %s\r\n",clan[clan_num].name);
    send_to_char(line_disp,ch);
    return; }
  else {
    send_to_char("You do not belong to a clan!\r\n",ch);
    return; }

 sprintf(line_disp,"You are %s (Rank %d) of %s (ID %d)\r\n",
    clan[clan_num].rank_name[GET_CLAN_RANK(ch)-1],GET_CLAN_RANK(ch),
    clan[clan_num].name,clan[clan_num].id);
 send_to_char(line_disp,ch);

return;
}

void do_clan_apply (struct char_data *ch, char *arg)
{
int clan_num;
struct char_data *vict;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)>=LVL_IMMORT) {
  send_to_char("Gods cannot apply for any clan.\r\n",ch);
  return; }

if(GET_CLAN_RANK(ch)>0) {
  send_to_char("You already belong to a clan!\r\n",ch);
  return; }
else {
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
    return;
  }
  if(!(GET_CLAN(vict)) || !(GET_CLAN_RANK(vict))) {
    send_to_char("They are not in a guild!\r\n",ch);
    return;
  }
  clan_num = find_clan_by_id(GET_CLAN(vict));
/*
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
*/
}

if(GET_LEVEL(ch) < clan[clan_num].app_level) {
  send_to_char("You are not mighty enough to apply to this clan.\r\n",ch);
  return; }

if(GET_PLAT(ch) < clan[clan_num].app_fee) {
  send_to_char("You cannot afford the application fee!\r\n", ch);
  return; }

GET_PLAT(ch) -= clan[clan_num].app_fee;
clan[clan_num].plat += clan[clan_num].app_fee;
save_clans();
GET_CLAN(ch)=clan[clan_num].id;
save_char(ch, ch->in_room);
sprintf(buf, "You've applied to %s&0!\r\n",clan[clan_num].name);
send_to_char(buf,ch);
return;
}

void do_clan_info (struct char_data *ch, char *arg)
{
int i=0,j;

if(num_of_clans == 0) {
  send_to_char("No clans have formed yet.\r\n",ch);
  return; }

if(!(*arg)) {
  sprintf(buf, "\r");
  for(i=0; i < num_of_clans; i++)
    sprintf(buf, "%s[%-3d]  %-20s Members: %3d  Power: %5d  Appfee: %d &6&bPlatinum&0\r\n",buf,
    i, clan[i].name,clan[i].members,clan[i].power,clan[i].app_fee);
  page_string(ch->desc,buf, 1);
  return; }
else {
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((i=atoi(arg))<0 || i>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
  if(GET_LEVEL(ch) < LVL_IMMORT && clan[i].id != GET_CLAN(ch)) {
    send_to_char("That information is not available to you.\r\n",ch);
    return;
  }
}

sprintf(buf, "Info for clan <<%s>>:\r\n",clan[i].name);
send_to_char(buf, ch);
sprintf(buf, "Ranks      : %d\r\nTitles     : ",clan[i].ranks);
for(j=0;j<clan[i].ranks;j++)
  sprintf(buf, "%s%s ",buf,clan[i].rank_name[j]);
sprintf(buf, "%s\r\nMembers    : %d\r\nPower      : %d\t\nTreasure   : %ld &6&bPlatinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\nSpells     : ",buf, clan[i].members, clan[i].power, clan[i].plat, clan[i].gold, clan[i].silver, clan[i].copper);
for(j=0; j<20;j++)
  if(clan[i].spells[j])
    sprintf(buf, "%s%d ",buf,clan[i].spells[j]);
sprintf(buf, "%s\r\n",buf);
send_to_char(buf, ch);
sprintf(buf,"Clan privileges:\r\n");
for(j=0; j<NUM_CP;j++)
  sprintf(buf, "%s   %-10s: %d\r\n",buf,clan_privileges[j],clan[i].privilege[j]);
sprintf(buf, "%s\r\n",buf);
send_to_char(buf, ch);
/*
sprintf(buf, "Description:\r\n%s\r\n\n", clan[i].description);
send_to_char(buf, ch);
*/
if((clan[i].at_war[0] == 0) && (clan[i].at_war[1] == 0) && (clan[i].at_war[2] == 0) && (clan[i].at_war[3] == 0))
  send_to_char("This clan is at peace with all others.\r\n", ch);
else
  send_to_char("This clan is at war.\r\n", ch);
sprintf(buf, "Application fee  : %d &6&bPlatinum&0\r\nMonthly Dues     : %d &6&bPlatinum&0\r\n", clan[i].app_fee, clan[i].dues);
send_to_char(buf, ch);
sprintf(buf, "Application level: %d\r\n", clan[i].app_level);
send_to_char(buf, ch);

return;
}

sh_int find_clan_by_id(int idnum)
{
int i;
for( i=0; i < num_of_clans; i++)
  if(idnum==clan[i].id)
    return i;
return -1;
}

sh_int find_clan(char *name)
{
int i;
for( i=0; i < num_of_clans; i++)
  if(strcmp(CAP(name), CAP(clan[i].name))==0)
    return i;
return -1;
}

void save_clans()
{
FILE *fl;

if (!(fl = fopen(CLAN_FILE, "wb"))) {
  log("SYSERR: Unable to open clan file");
  return; }

fwrite(&num_of_clans, sizeof(int), 1, fl);
fwrite(clan, sizeof(struct clan_rec), num_of_clans, fl);
fclose(fl);
return;
}


void init_clans()
{
FILE *fl;
int i,j;
extern int top_of_p_table;
extern struct player_index_element *player_table;
struct char_file_u chdata;

memset(clan,0,sizeof(struct clan_rec)*MAX_CLANS);
num_of_clans=0;
i=0;

if (!(fl = fopen(CLAN_FILE, "rb"))) {
  log("   Clan file does not exist. Will create a new one");
  save_clans();
  return; }

fread(&num_of_clans, sizeof(int), 1, fl);
fread(clan, sizeof(struct clan_rec), num_of_clans, fl);
fclose(fl);

log("   Calculating powers and members");
for(i=0;i<num_of_clans;i++) {
  clan[i].power=0;
  clan[i].members=0;
}
for (j = 0; j <= top_of_p_table; j++){
  load_char((player_table + j)->name, &chdata);
  if((i=find_clan_by_id(chdata.player_specials_saved.clan))>=0) {
    clan[i].power+=chdata.level;
    clan[i].members++;
  }
}

return;
}

void do_clan_bank(struct char_data *ch, char *arg, int action)
{
int i,clan_num,immcom=0;
long plat=0,gold=0,silver=0,copper=0,amount=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];
char arg3[MAX_INPUT_LENGTH];
char arg4[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
  strcpy(arg2,arg);
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_WITHDRAW] && !immcom && action
==CB_WITHDRAW) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg2)) {
  send_to_char("Deposit how much?\r\n",ch);
  return;
  }

for (i=0;i<4;i++){
  half_chop(arg2,arg3,arg2);
  half_chop(arg2,arg4,arg2);
  if(!(*arg3) || !(*arg4))
    continue;
  if(!is_number(arg3)) {
    send_to_char("Wrong money format.\r\nUse format: <number> p <number> g <number> s <number> c\r\n",ch);
  return;
  }
  amount=atoi(arg3);
  switch(*arg4) {
  case 'p':
    plat += amount;
    break;
  case 'g':
    gold += amount;
    break;
  case 's':
    silver += amount;
    break;
  case 'c':
    copper += amount;
    break;
  default:
    send_to_char("Wrong money type.\r\n",ch);
    break;
  }

}
if(!immcom && action==CB_DEPOSIT && (GET_PLAT(ch)<plat || GET_GOLD(ch)<gold
   || GET_SILVER(ch)<silver || GET_COPPER(ch)<copper)) {
  send_to_char("You do not have that kind of money!\r\n",ch);
  return;
  }

if(action==CB_WITHDRAW && (clan[clan_num].plat<plat
   || clan[clan_num].gold<gold || clan[clan_num].silver<silver
   || clan[clan_num].copper<copper)) {
  send_to_char("The clan is not wealthy enough for your needs!\r\n",ch);
  return;
  }

switch(action) {
  case CB_WITHDRAW:
    GET_PLAT(ch)+=plat;
    GET_GOLD(ch)+=gold;
    GET_SILVER(ch)+=silver;
    GET_COPPER(ch)+=copper;
    clan[clan_num].plat-=plat;
    clan[clan_num].gold-=gold;
    clan[clan_num].silver-=silver;
    clan[clan_num].copper-=copper;
    sprintf(buf, "You withdraw from %s&0's account: ", clan[clan_num].name);
    break;
  case CB_DEPOSIT:
    if(!immcom) {
      GET_PLAT(ch)-=plat;
      GET_GOLD(ch)-=gold;
      GET_SILVER(ch)-=silver;
      GET_COPPER(ch)-=copper;
    }
    clan[clan_num].plat+=plat;
    clan[clan_num].gold+=gold;
    clan[clan_num].silver+=silver;
    clan[clan_num].copper+=copper;
    sprintf(buf, "You deposit into %s&0's account: ", clan[clan_num].name);
    break;
  default:
    send_to_char("Problem in command, please report.\r\n",ch);
    break;
  }
sprintf(buf,"%s%ld &b&6Platinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\n"
    ,buf,plat,gold,silver,copper);
send_to_char(buf, ch);
save_char(ch, ch->in_room);
save_clans();
return;
}

void do_clan_money(struct char_data *ch, char *arg, int action)
{
int clan_num,immcom=0;
long amount=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_FEES] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg)) {
  send_to_char("Set it to how much?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set it to what?\r\n",ch);
  return;
  }

amount=atoi(arg);

switch(action) {
  case CM_APPFEE:
    clan[clan_num].app_fee=amount;
    send_to_char("You change the application fee.\r\n",ch);
    break;
  case CM_DUES:
    clan[clan_num].dues=amount;
    send_to_char("You change the monthly dues.\r\n",ch);
    break;
  default:
    send_to_char("Problem in command, please report.\r\n",ch);
    break;
  }

save_clans();
return;
}

void do_clan_ranks(struct char_data *ch, char *arg)
{
int i,j;
int clan_num,immcom=0;
int new_ranks;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];
struct char_file_u chdata;
struct char_data *victim=NULL;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg)) {
  send_to_char("Set how many ranks?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set the ranks to what?\r\n",ch);
  return;
  }

new_ranks=atoi(arg);

if(new_ranks==clan[clan_num].ranks) {
  send_to_char("The clan already has this number of ranks.\r\n",ch);
  return;
  }

if(new_ranks<2 || new_ranks>20) {
  send_to_char("Clans must have from 2 to 20 ranks.\r\n",ch);
  return;
  }

/*
if(GET_PLAT(ch)<1000 && !immcom) {
  send_to_char("Changing the clan hierarchy requires 1,000 plat!\r\n",ch);
  return;
  }

if(!immcom)
  GET_PLAT(ch)-=1000;
*/

for (j = 0; j < MAX_MEMBERS_PER_CLAN; j++) {
  if (!clan[clan_num].member_list[j][0])
    continue;
  if((victim=is_playing(clan[clan_num].member_list[j]))) {
    if(GET_CLAN(victim)==clan[clan_num].id) {
      if(GET_CLAN_RANK(victim)<clan[clan_num].ranks && GET_CLAN_RANK(victim)>0)
        GET_CLAN_RANK(victim)=1;
      if(GET_CLAN_RANK(victim)==clan[clan_num].ranks)
        GET_CLAN_RANK(victim)=new_ranks;
      save_char(victim, victim->in_room);
    }
  }
  else {
    load_char(clan[clan_num].member_list[j], &chdata);
    if(chdata.player_specials_saved.clan==clan[clan_num].id) {
      if(chdata.player_specials_saved.clan_rank<clan[clan_num].ranks && chdata.
player_specials_saved.clan_rank>0)
        chdata.player_specials_saved.clan_rank=1;
      if(chdata.player_specials_saved.clan_rank==clan[clan_num].ranks)
        chdata.player_specials_saved.clan_rank=new_ranks;
      save_char_file_u(chdata);
    }
  }
}

clan[clan_num].ranks=new_ranks;
for(i=0;i<clan[clan_num].ranks-1;i++)
  strcpy(clan[clan_num].rank_name[i],"Member");
strcpy(clan[clan_num].rank_name[clan[clan_num].ranks -1],"Leader");
for(i=0;i<NUM_CP;i++)
  clan[clan_num].privilege[i]=new_ranks;

update_clan(ch, clan_num);
save_clans();
return;
}

void do_clan_titles( struct char_data *ch, char *arg)
{
char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
int clan_num=0,rank;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
  if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg2);
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

half_chop(arg,arg1,arg2);

if(!is_number(arg1)) {
  send_to_char("You need to specify a rank number.\r\n",ch);
  return; }

rank=atoi(arg1);

if(rank<1 || rank>clan[clan_num].ranks) {
  send_to_char("This clan has no such rank number.\r\n",ch);
  return; }

if(strlen(arg2)<1 || strlen(arg2)>29) {
  send_to_char("You need a clan title of under 30 characters.\r\n",ch);
  return; }

strcpy(clan[clan_num].rank_name[rank-1],arg2);
save_clans();
send_to_char("Done.\r\n",ch);
update_clan(ch, clan_num);
return;
}

void do_clan_application( struct char_data *ch, char *arg)
{
int clan_num,immcom=0;
int applevel;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_APPLEV] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg)) {
  send_to_char("Set to which level?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set the application level to what?\r\n",ch);
  return;
  }

applevel=atoi(arg);

if(applevel<1 || applevel>999) {
  send_to_char("The application level can go from 1 to 999.\r\n",ch);
  return;
  }

clan[clan_num].app_level=applevel;
save_clans();

return;
}

void do_clan_sp(struct char_data *ch, char *arg, int priv)
{
int clan_num,immcom=0;
int rank;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }


if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg)) {
  send_to_char("Set the privilege to which rank?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set the privilege to what?\r\n",ch);
  return;
  }

rank=atoi(arg);

if(rank<1 || rank>clan[clan_num].ranks) {
  send_to_char("There is no such rank in the clan.\r\n",ch);
  return;
  }

clan[clan_num].privilege[priv]=rank;
save_clans();

return;
}

void do_clan_plan(struct char_data *ch, char *arg)
{
int clan_num;

send_to_char("Command not ready yet\r\n",ch);
return;

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; }
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_PLAN]) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return; }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(strlen(clan[clan_num].description)==0) {
   sprintf(buf, "Enter the description, or plan for clan <<%s>>.\r\n",clan[clan_num].name);
   send_to_char(buf, ch);
}
else {
   sprintf(buf, "Old plan for clan <<%s>>:\r\n", clan[clan_num].name);
   send_to_char(buf, ch);
   send_to_char(clan[clan_num].description, ch);
   send_to_char("Enter new plan:\r\n", ch);
}
send_to_char("End with @@ on a line by itself.\r\n", ch);
/*ch->desc->str   = clan[clan_num].description;*/
ch->desc->max_str = CLAN_PLAN_LENGTH;
save_clans();
return;
}

void do_clan_privilege( struct char_data *ch, char *arg)
{
char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
int i;

half_chop(arg,arg1,arg2);

if (is_abbrev(arg1,"setplan"  )) { do_clan_sp(ch,arg2,CP_SET_PLAN);   return ;}
if (is_abbrev(arg1,"enroll"   )) { do_clan_sp(ch,arg2,CP_ENROLL);     return ;}
if (is_abbrev(arg1,"expel"    )) { do_clan_sp(ch,arg2,CP_EXPEL);      return ;}
if (is_abbrev(arg1,"promote"  )) { do_clan_sp(ch,arg2,CP_PROMOTE);    return ;}
if (is_abbrev(arg1,"demote"   )) { do_clan_sp(ch,arg2,CP_DEMOTE);     return ;}
if (is_abbrev(arg1,"withdraw" )) { do_clan_sp(ch,arg2,CP_WITHDRAW);   return ;}
if (is_abbrev(arg1,"setfees"  )) { do_clan_sp(ch,arg2,CP_SET_FEES);   return ;}
if (is_abbrev(arg1,"setapplev")) { do_clan_sp(ch,arg2,CP_SET_APPLEV); return ;}
send_to_char("\r\nClan privileges:\r\n", ch);
for(i=0;i<NUM_CP;i++) {
  sprintf(arg1,"\t%s\r\n",clan_privileges[i]);
  send_to_char(arg1,ch); }
}

void do_clan_set(struct char_data *ch, char *arg)
{
char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];

half_chop(arg,arg1,arg2);

if (is_abbrev(arg1, "plan"      )) { do_clan_plan(ch,arg2);            return ;
}
if (is_abbrev(arg1, "ranks"     )) { do_clan_ranks(ch,arg2);           return ;
}
if (is_abbrev(arg1, "title"     )) { do_clan_titles(ch,arg2);          return ;
}
if (is_abbrev(arg1, "privilege" )) { do_clan_privilege(ch,arg2);       return ;
}
if (is_abbrev(arg1, "dues"      )) { do_clan_money(ch,arg2,CM_DUES);   return ;
}
if (is_abbrev(arg1, "appfee"    )) { do_clan_money(ch,arg2,CM_APPFEE); return ;
}
if (is_abbrev(arg1, "applev"    )) { do_clan_application(ch,arg2);     return ;
}
send_clan_format(ch);
}

void do_clan_snoop(struct char_data *ch, char *arg)
{
int i;

if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_clan_format(ch);
  return;
}
if(!(*arg)) {
  sprintf(buf, "You are currently snooping");
  switch(ch->clan_snoop) {
    case -2:
      sprintf(buf,"%s no clans.\r\n",buf);
      break;
    case -1:
      sprintf(buf,"%s all clans.\r\n",buf);
      break;
    default:
      if (ch->clan_snoop>=0 && ch->clan_snoop<num_of_clans)
        sprintf(buf,"%s %s.\r\n", buf, clan[ch->clan_snoop].name);
      else
        sprintf(buf,"Your clan snoop level is invalid.");
      break;
  }
  send_to_char(buf,ch);
  return;
}
else {
  if(!is_number(arg)) {
    if(is_abbrev(arg, "off"))
      ch->clan_snoop = -2;
    else if(is_abbrev(arg, "all"))
      ch->clan_snoop = -1;
    else {
      send_to_char("That is an invalid selection.\r\n",ch);
      return;
    }
  }
  else {
    if((i=atoi(arg))<0 || i>=num_of_clans) {
     send_to_char("That is an invalid number.\r\n",ch);
     return;
    }
    else
     ch->clan_snoop = atoi(arg);
  }
}

sprintf(buf, "Your are now snooping");
  switch(ch->clan_snoop) {
    case -2:
      sprintf(buf,"%s no clans.\r\n",buf);
      break;
    case -1:
      sprintf(buf,"%s all clans.\r\n",buf);
      break;
    default:
      if (ch->clan_snoop>=0 && ch->clan_snoop<num_of_clans)
        sprintf(buf,"%s %s\r\n", buf, clan[ch->clan_snoop].name);
      else
        sprintf(buf,"Your clan snoop level is invalid.");
      break;
  }
send_to_char(buf,ch);
}

ACMD(do_clan)
{
char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

half_chop(argument, arg1, arg2);

if (is_abbrev(arg1, "create"  )) { do_clan_create(ch,arg2);   return ;}
if (is_abbrev(arg1, "destroy" )) { do_clan_destroy(ch,arg2);  return ;}
if (is_abbrev(arg1, "enroll"  )) { do_clan_enroll(ch,arg2);   return ;}
if (is_abbrev(arg1, "expel"   )) { do_clan_expel(ch,arg2);    return ;}
if (is_abbrev(arg1, "who"     )) { do_clan_who(ch,arg2);           return ;}
if (is_abbrev(arg1, "status"  )) { do_clan_status(ch);        return ;}
if (is_abbrev(arg1, "info"    )) { do_clan_info(ch,arg2);     return ;}
if (is_abbrev(arg1, "apply"   )) { do_clan_apply(ch,arg2);    return ;}
if (is_abbrev(arg1, "demote"  )) { do_clan_demote(ch,arg2);   return ;}
if (is_abbrev(arg1, "promote" )) { do_clan_promote(ch,arg2);  return ;}
if (is_abbrev(arg1, "set"     )) { do_clan_set(ch,arg2);      return ;}
if (is_abbrev(arg1, "withdraw")) { do_clan_bank(ch,arg2,CB_WITHDRAW); return ;}
if (is_abbrev(arg1, "deposit" )) { do_clan_bank(ch,arg2,CB_DEPOSIT);  return ;}
if (is_abbrev(arg1, "snoop"   )) { do_clan_snoop(ch,arg2); return;}
if (is_abbrev(arg1, "rename"   )) { do_clan_rename(ch,arg2); return;}
send_clan_format(ch);
}
@


1.44
log
@Fixed two possible null pointer errors that were causing crashes.
@
text
@/***************************************************************************
 * $Id: clan.c,v 1.43 2009/06/20 23:55:13 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: clan.c                                         Part of FieryMUD *
 *  Usage: Front-end for the clan system                                   *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on HubisMUD Copyright (C) 1997, 1998.                *
 *  HubisMUD is based on DikuMUD, Copyright (C) 1990, 1991.                *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "handler.h"
#include "clan.h"
#include "math.h"
#include "players.h"
#include "screen.h"
#include "strings.h"
#include "modify.h"
#include "editor.h"
#include "act.h"


#define CLANCMD(name) \
    void (name)(struct char_data *ch, struct clan_membership *member, \
                struct clan *clan, char *argument)

extern const struct {
  char *abbr;
  bool default_on;
  char *desc;
} clan_privileges[NUM_CLAN_PRIVS];


CLANCMD(clan_list)
{
  clan_iter iter;

  if (clan_count() == 0) {
    cprintf(ch, "No clans have formed yet.\r\n");
    return;
  }

  /* List clans, # of members, power, and app fee */
  pprintf(ch, AUND " Num   Clan           Members/Power  App Fee/Lvl\r\n" ANRM);
  for (iter = clans_start(); iter != clans_end(); ++iter) {
    pprintf(ch, "[%3d]  " ELLIPSIS_FMT " "           "%3u/%-5u   "
                AHCYN "%5up" ANRM "/%-3u\n",
            (*iter)->number, ELLIPSIS_STR((*iter)->abbreviation, 18),
            (*iter)->member_count, (*iter)->power, (*iter)->app_fee,
            (*iter)->app_level);
  }

  start_paging(ch);
}


CLANCMD(clan_bank)
{
  int coins[NUM_COIN_TYPES];
  bool deposit;
  const char *verb, *preposition;

  argument = any_one_arg(argument, arg);
  deposit = is_abbrev(arg, "deposit");
  verb = deposit ? "deposit" : "withdraw";
  preposition = deposit ? "into" : "from";

  if (!parse_money(&argument, coins)) {
    cprintf(ch, "How much do you want to %s?\r\n", verb);
    return;
  }

  if (deposit) {
    /* Gods have bottomless pockets */
    if (GET_LEVEL(ch) < LVL_GOD) {
      if (GET_PLATINUM(ch) < coins[PLATINUM] ||
          GET_GOLD(ch) < coins[GOLD] ||
          GET_SILVER(ch) < coins[SILVER] ||
          GET_COPPER(ch) < coins[COPPER]) {
        cprintf(ch, "You do not have that kind of money!\r\n");
        return;
      }

      GET_PLATINUM(ch) -= coins[PLATINUM];
      GET_GOLD(ch)     -= coins[GOLD];
      GET_SILVER(ch)   -= coins[SILVER];
      GET_COPPER(ch)   -= coins[COPPER];
      save_player_char(ch);
    }
  }
  else {
    if (clan->treasure[PLATINUM] < coins[PLATINUM] ||
        clan->treasure[GOLD] < coins[GOLD] ||
        clan->treasure[SILVER] < coins[SILVER] ||
        clan->treasure[COPPER] < coins[COPPER]) {
      cprintf(ch, "The clan is not wealthy enough for your needs!\r\n");
      return;
    }
    GET_PLATINUM(ch) += coins[PLATINUM];
    GET_GOLD(ch) += coins[GOLD];
    GET_SILVER(ch) += coins[SILVER];
    GET_COPPER(ch) += coins[COPPER];
    save_player_char(ch);
  }

  statemoney(buf, coins);
  cprintf(ch, "You %s %s %s's account: %s\r\n",
          verb, preposition, clan->abbreviation, buf);

  if (deposit) {
    clan->treasure[PLATINUM] += coins[PLATINUM];
    clan->treasure[GOLD]     += coins[GOLD];
    clan->treasure[SILVER]   += coins[SILVER];
    clan->treasure[COPPER]   += coins[COPPER];
  }
  else {
    clan->treasure[PLATINUM] -= coins[PLATINUM];
    clan->treasure[GOLD]     -= coins[GOLD];
    clan->treasure[SILVER]   -= coins[SILVER];
    clan->treasure[COPPER]   -= coins[COPPER];
  }
  save_clan(clan);
}


static bool is_snooping(const struct char_data *ch, const struct clan *clan)
{
  struct clan_snoop *snoop;

  for (snoop = GET_CLAN_SNOOP(ch); snoop; snoop = snoop->next)
    if (snoop->clan == clan)
      return TRUE;

  return FALSE;
}

CLANCMD(clan_tell)
{
  struct descriptor_data *d;
  struct char_data *tch;
  struct char_data *me = REAL_CHAR(ch);

  skip_spaces(&argument);

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    cprintf(ch, "Your lips move, but no sound forms.\r\n");
    return;
  }

  if (!speech_ok(ch, 0))
    return;

  if (!*argument) {
    cprintf(ch, "What do you want to tell the clan?\r\n");
    return;
  }

  argument = drunken_speech(argument, GET_COND(ch, DRUNK));

  cprintf(ch, AFMAG "You tell %s" AFMAG ", '" AHMAG "%s" AFMAG "'\r\n" ANRM,
          member ? "your clan" : clan->abbreviation, argument);

  for (d = descriptor_list; d; d = d->next) {
    if (!IS_PLAYING(d) || !d->character)
      continue;
    tch = REAL_CHAR(d->character);
    if (!tch || tch == me)
      continue;
    if (STATE(d) != CON_PLAYING || PLR_FLAGGED(tch, PLR_WRITING) ||
        PLR_FLAGGED(tch, PLR_MAILING) || EDITING(d))
      if (!PRF_FLAGGED(tch, PRF_OLCCOMM))
        continue;
    if (PRF_FLAGGED(tch, PRF_NOCLANCOMM))
      continue;
    if ((IS_CLAN_SUPERADMIN(tch) && is_snooping(tch, clan)) ||
        (GET_CLAN(tch) == clan && !OUTRANKS(MIN_ALT_RANK, GET_CLAN_RANK(tch))))
      cprintf(FORWARD(tch),
              AFMAG "%s tells %s" AFMAG ", '" AHMAG "%s" AFMAG "'\r\n" ANRM,
              GET_INVIS_LEV(me) > GET_LEVEL(tch) ? "Someone" : GET_NAME(me),
              member && !IS_CLAN_SUPERADMIN(tch) ? "your clan" : clan->abbreviation, argument);
  }
}


CLANCMD(clan_set)
{
  argument = any_one_arg(argument, arg);

  if (is_abbrev(arg, "abbr")) {
    char *old_abbr = clan->abbreviation;
    skip_spaces(&argument);
    if (strlen(strip_ansi(argument)) > MAX_CLAN_ABBR_LEN) {
      cprintf(ch, "Clan abbreviationss may be at most %d characters in length.\r\n",
              MAX_CLAN_ABBR_LEN);
      return;
    }
    clan->abbreviation = ""; /* so find_clan doesn't find this clan */
    if (find_clan(argument)) {
      cprintf(ch, "A clan with that name or abbreviation already exists!\r\n");
      clan->abbreviation = old_abbr; /* revert */
      return;
    }
    clan->abbreviation = strdupf("%s&0", argument);
    cprintf(ch, "%s is now abbreviated %s.\r\n", clan->name, clan->abbreviation);
    mprintf(L_STAT, LVL_GOD, "(CLAN) %s changes %s's to %s",
            GET_NAME(ch), clan->name, clan->abbreviation);
    free(old_abbr);
  }

  else if (is_abbrev(arg, "addrank")) {
    int i;

    if (clan->rank_count >= MAX_CLAN_RANKS) {
      cprintf(ch, "%s already has the maximum number of ranks.\r\n", clan->name);
      return;
    }

    ++clan->rank_count;
    /* Warning! RECREATE does not initialize to zero... */
    RECREATE(clan->ranks, struct clan_rank, clan->rank_count);
    clan->ranks[clan->rank_count - 1].title = strdup("Member");
    for (i = 0; i < NUM_CLAN_PRIVS; ++i)
      if (clan_privileges[i].default_on)
        SET_FLAG(clan->ranks[clan->rank_count - 1].privileges, i);
      else
        REMOVE_FLAG(clan->ranks[clan->rank_count - 1].privileges, i);

    cprintf(ch, "You add a new rank (%u) to %s.\r\n",
            clan->rank_count, clan->name);
    clan_notification(clan, ch, "%s adds a new rank to your clan.", 
                      GET_NAME(ch));
  }

  else if (is_abbrev(arg, "appfee")) {
    any_one_arg(argument, arg);
    if (!is_number(arg)) {
      cprintf(ch, "How much platinum should the clan's application fee be?\r\n");
      return;
    }
    clan->app_fee = atoi(arg);
    cprintf(ch, "%s's application fee is now %u platinum.\r\n",
            clan->name, clan->app_fee);
  }

  else if (is_abbrev(arg, "applev")) {
    unsigned int level;
    any_one_arg(argument, arg);
    if (!is_number(arg)) {
      cprintf(ch, "What should the clan's minimum application level be?\r\n");
      return;
    }
    level = atoi(arg);
    if (level < 1 || level > LVL_IMPL) {
      cprintf(ch, "The minimum application level must be between 1 and %d.\r\n",
              LVL_IMPL);
      return;
    }
    clan->app_level = level;
    cprintf(ch, "%s's minimum application level is now %u.\r\n",
            clan->name, clan->app_level);
  }

  else if (is_abbrev(arg, "delrank")) {
    if (clan->rank_count <= MIN_CLAN_RANKS) {
      cprintf(ch, "%s already has the minimum number of ranks.\r\n", clan->name);
      return;
    }

    --clan->rank_count;
    free(clan->ranks[clan->rank_count].title);

    cprintf(ch, "You remove a rank (%u) from %s.\r\n",
            clan->rank_count + 1, clan->name);
    clan_notification(clan, ch, "%s removes a rank from your clan.",
                      GET_NAME(ch));

    for (member = clan->members; member; member = member->next)
      if (member->rank == clan->rank_count + 1) {
        --member->rank;
        if (member->player)
          cprintf(FORWARD(member->player),
                  AFMAG "You have been automatically promoted to rank %u.\r\n" ANRM,
                  member->rank);
      }
  }

  else if (is_abbrev(arg, "dues")) {
    any_one_arg(argument, arg);
    if (!is_number(arg)) {
      cprintf(ch, "How much platinum should the clan's dues be?\r\n");
      return;
    }
    clan->dues = atoi(arg);
    cprintf(ch, "%s's monthly dues are now %u platinum.\r\n",
            clan->name, clan->dues);
  }

  else if (is_abbrev(arg, "name")) {
    char *old_name = clan->name;
    skip_spaces(&argument);
    if (strlen(strip_ansi(argument)) > MAX_CLAN_NAME_LEN) {
      cprintf(ch, "Clan names may be at most %d characters in length.\r\n",
              MAX_CLAN_NAME_LEN);
      return;
    }
    clan->name = ""; /* so find_clan doesn't find this clan */
    if (find_clan(argument)) {
      cprintf(ch, "A clan with that name already exists!\r\n");
      clan->name = old_name; /* revert */
      return;
    }
    clan->name = strdupf("%s&0", argument);
    cprintf(ch, "%s is now named %s.\r\n", old_name, clan->name);
    mprintf(L_STAT, LVL_GOD, "(CLAN) %s renames %s to %s",
            GET_NAME(ch), old_name, clan->name);
    free(old_name);
  }

  else if (is_abbrev(arg, "title")) {
    unsigned int rank;
    argument = any_one_arg(argument, arg);
    if (!*arg) {
      cprintf(ch, "For which rank do you want to set a title?\r\n");
      return;
    }
    rank = atoi(arg);
    if (!is_number(arg) || rank < 1 || rank > clan->rank_count) {
      cprintf(ch, "'%s' is an invalid rank.  Valid ranks are 1-%u.\r\n",
              arg, clan->rank_count);
      return;
    }
    skip_spaces(&argument);
    if (!IS_CLAN_SUPERADMIN(ch) && !IS_CLAN_ADMIN(ch) &&
        OUTRANKS(rank, GET_CLAN_RANK(ch))) {
      cprintf(ch, "You cannot set the title for a rank above your own.\r\n");
      return;
    }
    if (strlen(strip_ansi(argument)) > MAX_CLAN_TITLE_LEN) {
      cprintf(ch, "Clan titles may be at most %u characters long.\r\n",
              MAX_CLAN_TITLE_LEN);
      return;
    }
    free(clan->ranks[rank - 1].title);
    clan->ranks[rank - 1].title = strdupf("%s&0", argument);
    cprintf(ch, "Rank %u's title is now: %s\r\n", rank, argument);
    clan_notification(clan, ch, "%s has changed rank %u's title to %s.",
                      GET_NAME(ch), rank, argument);
  }

  else {
    mprintf(L_ERROR, LVL_GOD, "SYSERR: clan_set: unknown subcommand '%s'", arg);
    return;
  }

  save_clan(clan);
}


CLANCMD(clan_alt)
{
  struct char_data *tch;
  struct clan_membership *alt;

  argument = any_one_arg(argument, arg);

  if (!*arg) {
    cprintf(ch, "Whom do you want to add or remove as an alt?\r\n");
    return;
  }

  /*
   * First, let's see if we're trying to remove an alt: they don't have
   * to be online for that.
   */
  for (alt = member->relation.alts; alt; alt = alt->next) {
    if (!str_cmp(alt->name, arg)) {
      cprintf(ch, "You remove %s as one of %s%s clan alts.\r\n",
              alt->name,
              ch == member->player ? "your" : member->name,
              ch == member->player ? "" : "'s");
      if (ch != member->player && member->player)
        cprintf(FORWARD(member->player),
                AFMAG "%s removes %s as one of your clan alts.\r\n" ANRM,
                GET_NAME(ch), alt->name);
      if (alt->player)
        cprintf(FORWARD(alt->player),
                AFMAG "You are no longer one of %s's clan alts.\r\n" ANRM, 
                member->name);
      revoke_clan_membership(alt);
      return;
    }
  }

  if (!(tch = find_char_by_desc(find_vis_by_name(ch, arg))))
    cprintf(ch, "There's no one online by the name of %s.\r\n", arg);
  else if (ch == tch)
    cprintf(ch, "You want to be your own alt?\r\n");
  else if (GET_CLAN_MEMBERSHIP(tch))
    cprintf(ch, "%s is already in a clan!\r\n", GET_NAME(tch));
  else if (!IS_CLAN_SUPERADMIN(ch) && !IS_CLAN_ADMIN(ch) &&
           strcmp(ch->desc->host, tch->desc->host))
    cprintf(ch, "%s was not found logged in as your alt.\r\n", GET_NAME(tch));
  else if (IS_CLAN_SUPERADMIN(tch))
    cprintf(ch, "%s is already a clan super-admin!\r\n", GET_NAME(tch));
  else {
    cprintf(ch, "You make %s one of %s%s clan alts.\r\n",
            GET_NAME(tch),
            ch == member->player ? "your" : member->name,
            ch == member->player ? "" : "'s");
    cprintf(tch, AFMAG "%s makes you one of %s%s clan alts.\r\n" ANRM,
            GET_NAME(ch),
            ch == member->player ? HSHR(member->player) : member->name,
            ch == member->player ? "" : "'s");
    if (ch != member->player && member->player)
      cprintf(FORWARD(member->player),
              AFMAG "%s makes %s one of your clan alts.\r\n" ANRM,
              GET_NAME(ch), GET_NAME(tch));
    CREATE(alt, struct clan_membership, 1);
    alt->name = strdup(GET_NAME(tch));
    alt->rank = ALT_RANK_OFFSET + member->rank;
    alt->since = member->since;
    alt->relation.member = member;
    alt->next = member->relation.alts;
    member->relation.alts = alt;
    alt->clan = clan;
    alt->player = tch;
    GET_CLAN_MEMBERSHIP(tch) = alt;
    save_player_char(tch);
    save_clan(clan);
  }
}


CLANCMD(clan_apply)
{
  if (GET_LEVEL(ch) < LVL_GOD && GET_PLATINUM(ch) < clan->app_fee) {
    cprintf(ch, "You don't have enough money to cover the %u platinum "
                "application fee.\r\n", clan->app_fee);
    return;
  }

  if (GET_LEVEL(ch) < clan->app_level) {
    cprintf(ch, "%s does not accept players beneath level %u.\r\n",
            clan->name, clan->app_level);
    return;
  }

  cprintf(ch, "You apply to %s.\r\n", clan->name);

  if (GET_LEVEL(ch) < LVL_GOD) {
    GET_PLATINUM(ch) -= clan->app_fee;
    clan->treasure[PLATINUM] += clan->app_fee;
  }

  clan_notification(clan, NULL, "%s has applied to your clan.",
                    GET_NAME(ch));

  CREATE(member, struct clan_membership, 1);
  member->name = strdup(GET_NAME(ch));
  member->rank = RANK_APPLICANT;
  member->since = time(0);
  member->player = ch;
  GET_CLAN_MEMBERSHIP(ch) = member;
  add_clan_membership(clan, member);
  save_player_char(ch);
  save_clan(clan);
}


CLANCMD(clan_create)
{
  unsigned int i = 0;

  fetch_word(argument, buf, sizeof(buf));

  if (!*buf)
    cprintf(ch, "What is the abbreviation for the new clan?\r\n");
  else if (strlen(strip_ansi(buf)) > 10)
    cprintf(ch, "Clan abbreviations can be at most 10 visible characters long.\r\n");
  else if (find_clan_by_abbr(strip_ansi(buf)))
    cprintf(ch, "A clan with a similar abbreviation already exists.\r\n");
  else {
    strcat(buf, "&0");
    clan = alloc_clan();
    clan->name = strdup(buf);
    clan->abbreviation = strdup(buf);
    clan->description = NULL;
    clan->motd = NULL;

    clan->dues = 0;
    clan->app_fee = 0;
    clan->app_level = 0;
    clan->power = 0;
    for (i = 0; i < NUM_COIN_TYPES; ++i)
      clan->treasure[i] = 0;

    clan->rank_count = 2;
    CREATE(clan->ranks, struct clan_rank, 2);
    clan->ranks[0].title = strdup("Leader");
    clan->ranks[1].title = strdup("Member");
    for (i = 0; i < NUM_CLAN_PRIVS; ++i) {
      SET_FLAG(clan->ranks[0].privileges, i);
      if (clan_privileges[i].default_on)
        SET_FLAG(clan->ranks[1].privileges, i);
    }

    clan->people_count = 0;
    clan->people = NULL;
    clan->member_count = 0;
    clan->members = NULL;
    clan->admin_count = 0;
    clan->admins = NULL;
    clan->applicant_count = 0;
    clan->applicants = NULL;

    cprintf(ch, "New clan created.\r\n");
    mprintf(L_STAT, LVL_GOD, "(CLAN) %s creates new clan: %s", 
            GET_NAME(ch), buf);

    save_clan(clan);
  }

}


CLANCMD(clan_rank)
{
  unsigned int rank;
  const char *action = NULL;

  argument = any_one_arg(argument, arg);

  if (is_abbrev(arg, "demote")) {
    if (!IS_CLAN_SUPERADMIN(ch) && ch != member->player && 
        !OUTRANKS(GET_CLAN_RANK(ch), member->rank))
      cprintf(ch, "You cannot demote someone at or above your rank.\r\n");
    else if (member->rank == clan->rank_count)
      cprintf(ch, "%s is already the minimum rank.\r\n", member->name);
    else if (!IS_MEMBER_RANK(member->rank))
      cprintf(ch, "%s isn't a clan member.\r\n", member->name);
    else {
      rank = member->rank + 1;
      action = "demote";
    }
  }
  else if (is_abbrev(arg, "promote")) {
    if (!IS_CLAN_SUPERADMIN(ch) && !OUTRANKS(GET_CLAN_RANK(ch), member->rank))
      cprintf(ch, "You cannot promote someone at or above your rank.\r\n");
    else if (member->rank == RANK_LEADER)
      cprintf(ch, "%s is already the maximum rank.\r\n", member->name);
    else if (!IS_MEMBER_RANK(member->rank))
      cprintf(ch, "%s isn't a clan member.\r\n", member->name);
    else {
      rank = member->rank - 1;
      action = "promote";
    }
  }
  else {
    log("SYSERR: clan_rank: invalid subcommand '%s'", arg);
    return;
  }

  /* action only gets set if all checks above were successful. */
  if (!action)
    return;

  if (ch == member->player)
    cprintf(ch, "You %s yourself to rank %u: %s\r\n",
            action, rank, clan->ranks[rank - 1].title);
  else {
    if (member->player)
      cprintf(FORWARD(member->player),
              AFMAG "%s has %sd you to rank %u: " ANRM "%s\r\n",
              GET_NAME(ch), action, rank, clan->ranks[rank - 1].title);
    cprintf(ch, "You %s %s to rank %u: %s\r\n",
            action, member->name, rank, clan->ranks[rank - 1].title);
  }
  member->rank = RANK_NONE; /* Temporary so they don't get the notification */
  clan_notification(clan, ch, "%s has %sd %s to rank %u: " ANRM "%s",
                    GET_NAME(ch), action, member->name, rank,
                    clan->ranks[rank - 1].title);
  member->rank = rank;
  /* Shift alts' ranks too */
  for (member = member->relation.alts; member; member = member->next)
    member->rank = rank + ALT_RANK_OFFSET;
  save_clan(clan);
}


CLANCMD(clan_destroy)
{
  clan_notification(clan, ch, "Your clan has been disbanded!");
  cprintf(ch, AFMAG "You have deleted the clan %s.\r\n" ANRM, clan->name);
  mprintf(L_STAT, LVL_GOD, "(CLAN) %s has destroyed the clan %s.",
          GET_NAME(ch), clan->name);
  dealloc_clan(clan);
}


CLANCMD(clan_enroll)
{
  int num;

  member->since = time(0);
  member->rank = clan->member_count ? clan->rank_count : RANK_LEADER;
  --clan->applicant_count;
  ++clan->member_count;
  if (member->player)
    clan->power += GET_LEVEL(member->player);
  else if ((num = get_ptable_by_name(member->name)))
    clan->power += player_table[num].level;

  update_clan(clan);
  save_clan(clan);

  cprintf(ch, "You %s %s %s %s.\r\n",
          member->rank == RANK_LEADER ? "appoint" : "enroll",
          member->name,
          member->rank == RANK_LEADER ? "the leader of" : "in",
          clan->name);
  if (member->player)
    cprintf(FORWARD(member->player),
            AFMAG "You've been %s %s" AFMAG "!\r\n" ANRM,
            member->rank == RANK_LEADER ? "appointed the leader of" :
            "enrolled in", clan->name);

  mprintf(L_STAT, LVL_GOD, "(CLAN) %s enrolls %s in %s.",
          GET_NAME(ch), member->name, clan->name);
}


CLANCMD(clan_expel)
{
  char *name = strdup(member->name);

  if (!IS_CLAN_SUPERADMIN(ch) && !OUTRANKS(GET_CLAN_RANK(ch), member->rank)) {
    cprintf(ch, "%s outranks you!\r\n", name);
    free(name);
    return;
  }

  clan = member->clan;

  cprintf(ch, "You expel %s from %s.\r\n", name, clan->name);

  if (member->player)
    cprintf(FORWARD(member->player),
            AFMAG "%s has expelled you from %s" AFMAG ".\r\n" ANRM,
            GET_NAME(ch), clan->name);

  mprintf(L_STAT, LVL_GOD, "(CLAN) %s expels %s from %s.",
          GET_NAME(ch), name, clan->name);
  revoke_clan_membership(member);

  clan_notification(clan, ch, "%s has expelled %s from your clan.",
                    GET_NAME(ch), name);
  free(name);
}


CLANCMD(clan_priv)
{
  enum { GRANT, REVOKE } action;
  int rank, priv;

  argument = any_one_arg(argument, arg);

  if (is_abbrev(arg, "grant"))
    action = GRANT;
  else if (is_abbrev(arg, "revoke"))
    action = REVOKE;
  else {
    log("SYSERR: clan_priv: invalid subcommand '%s'", arg);
    return;
  }

  argument = any_one_arg(argument, arg);
  rank = atoi(arg);

  if (rank < RANK_LEADER || rank > clan->rank_count) {
    cprintf(ch, "'%s' is an invalid rank.  Valid ranks are 1-%d.\r\n",
            arg, clan->rank_count);
    return;
  }

  argument = any_one_arg(argument, arg);
  for (priv = 0; priv < NUM_CLAN_PRIVS; ++priv)
    if (is_abbrev(arg, clan_privileges[priv].abbr))
      break;
  if (priv >= NUM_CLAN_PRIVS) {
    cprintf(ch, "'%s' is an invalid privilege.  Valid privileges are "
                "listed on clan info.\r\n", arg);
    return;
  }

  if (!IS_CLAN_SUPERADMIN(ch) && !IS_CLAN_ADMIN(ch) &&
      !HAS_CLAN_PRIV(ch, priv)) {
    cprintf(ch, "You cannot grant or revoke a privilege you do not have!\r\n");
    return;
  }

  if (IS_CLAN_MEMBER(ch) && !OUTRANKS(GET_CLAN_RANK(ch), rank)) {
    cprintf(ch, "You may only grant or revoke privileges on ranks below yours.\r\n");
    return;
  }

  if (action == GRANT) {
    if (IS_FLAGGED(clan->ranks[rank - 1].privileges, priv))
      cprintf(ch, "Rank %d already has the %s privilege.\r\n",
              rank, clan_privileges[priv].desc);
    else {
      SET_FLAG(clan->ranks[rank - 1].privileges, priv);
      cprintf(ch, "Granted rank %d access to the %s privilege.\r\n",
              rank, clan_privileges[priv].desc);
    }
  }
  else if (action == REVOKE) {
    if (IS_FLAGGED(clan->ranks[rank - 1].privileges, priv)) {
      REMOVE_FLAG(clan->ranks[rank - 1].privileges, priv);
      cprintf(ch, "Revoked rank %d access to the %s privilege.\r\n",
              rank, clan_privileges[priv].desc);
    }
    else
      cprintf(ch, "Rank %d doesn't have the %s privilege.\r\n",
              rank, clan_privileges[priv].desc);
  }

  save_clan(clan);
}



static void show_clan_info(struct char_data *ch,
                           const struct clan* clan)
{
  const struct clan_membership* member = GET_CLAN_MEMBERSHIP(ch);
  size_t i, j;
  bool show_all = ((member && member->clan == clan &&
                    OUTRANKS(member->rank, RANK_APPLICANT)) || 
                   IS_CLAN_SUPERADMIN(ch));

  strcpy(buf, "----------------------------------------------------------------------\r\n");
  sprintf(buf1, "[ Clan %u: %s ]", clan->number, clan->name);
  memcpy(buf + 29 - strlen(clan->name) / 2, buf1, strlen(buf1));
  pprintf(ch, "%s", buf);

  pprintf(ch, "Nickname: "   AFYEL "%s"  ANRM "  "
              "Ranks: "      AFYEL "%u"  ANRM "  "
              "Members: "    AFYEL "%u"  ANRM "  "
              "Power: "      AFYEL "%u"  ANRM "\r\n"
              "Applicants: " AFYEL "%u"  ANRM "  "
              "App Fee: "    AFCYN "%up" ANRM "  "
              "App Level: "  AFYEL "%u"  ANRM "  "
              "Dues: "       AFCYN "%up" ANRM "\r\n",
          clan->abbreviation, clan->rank_count,
          clan->member_count, clan->power,
          clan->applicant_count, clan->app_fee,
          clan->app_level, clan->dues);

  if (show_all) {
    statemoney(buf, clan->treasure);
    pprintf(ch, "Treasure: %s\r\n", buf);

    pprintf(ch, "\r\nRanks:\r\n");
    for (i = 0; i < clan->rank_count; ++i)
      pprintf(ch, "%3u  %s\r\n",
              i + 1, clan->ranks[i].title);

    pprintf(ch, "\r\nPrivileges:\r\n         ");
    for (j = 1; j <= clan->rank_count; ++j)
      pprintf(ch, "%3u", j);
    for (i = 0; i < NUM_CLAN_PRIVS; ++i) {
      pprintf(ch, "\r\n%-9s", clan_privileges[i].abbr);
      for (j = 0; j < clan->rank_count; ++j)
        pprintf(ch, "  %s%c" ANRM,
                IS_FLAGGED(clan->ranks[j].privileges, i) ? AFGRN : AFRED,
                IS_FLAGGED(clan->ranks[j].privileges, i) ? 'Y' : 'N');
    }
    pprintf(ch, "\r\n");
  }

  if (clan->description)
    pprintf(ch, "\r\nDescription:\r\n%s", clan->description);

  if (show_all)
    if (clan->motd)
      pprintf(ch, "\r\nMessage of the Day:\r\n%s", clan->motd);

  start_paging(ch);
}


CLANCMD(clan_info)
{
  argument = any_one_arg(argument, arg);

  if (!*arg) {
    if (clan)
      show_clan_info(ch, clan);
    else
      cprintf(ch, "Which clan's info do you want to view?\r\n");
  }
  else if ((clan = find_clan(arg)))
    show_clan_info(ch, clan);
  else
    cprintf(ch, "'%s' does not refer to a valid clan.\r\n", arg);
}


static void show_clan_member_status(struct char_data *ch,
                                    const struct char_data *tch)
{
  if (IS_CLAN_SUPERADMIN(tch))
    cprintf(ch, "%s %s a clan super-administrator.\r\n",
            ch == tch ? "You" : GET_NAME(tch),
            ch == tch ? "are" : "is");
  else if (IS_CLAN_REJECT(tch)) {
    unsigned int days = days_until_reapply(GET_CLAN_MEMBERSHIP(tch));
    cprintf(ch, "%s %s rejected from %s and may re-apply in %d day%s.\r\n",
            ch == tch ? "You" : GET_NAME(tch),
            ch == tch ? "were" : "was",
            GET_CLAN(tch)->name, days, days == 1 ? "" : "s");
  }
  else if (IS_CLAN_ADMIN(tch))
    cprintf(ch, "%s %s an administrator for %s.\r\n",
            ch == tch ? "You" : GET_NAME(tch),
            ch == tch ? "are" : "is",
            GET_CLAN(tch)->name);
  else if (IS_CLAN_MEMBER(tch) || IS_CLAN_ALT(tch) || IS_CLAN_APPLICANT(tch)) {
    strftime(buf, sizeof(buf), "%a, %d %b %Y",
             localtime(&GET_CLAN_MEMBERSHIP(tch)->since));
    pprintf(ch, "Clan membership status for %s:\r\n"
                "  Clan: %s\r\n", GET_NAME(tch), GET_CLAN(tch)->name);
    if (IS_CLAN_MEMBER(tch))
      pprintf(ch, "  Rank: %d - %s%s\r\n",
              GET_CLAN_RANK(tch), GET_CLAN_TITLE(tch),
              IS_CLAN_LEADER(tch) ? " (Leader)" : "");
    else if (IS_CLAN_ALT(tch))
      pprintf(ch, "  Alt rank: %d (%s)\r\n",
              GET_CLAN_RANK(tch) - ALT_RANK_OFFSET,
              GET_CLAN_MEMBERSHIP(tch)->relation.member->name);
    else if (IS_CLAN_APPLICANT(tch))
      pprintf(ch, "  Rank: Applicant\r\n");
    pprintf(ch, "  Member since: %s\r\n", buf);
    if (IS_CLAN_MEMBER(tch)) {
      if (HAS_FLAGS(GET_CLAN(tch)->ranks[GET_CLAN_RANK(tch) - 1].privileges,
                    NUM_CLAN_PRIVS)) {
        screen_buf sb = new_screen_buf();
        int i, seen = 0;
        const size_t len = strlen("  Privileges: ");
        sb_set_first_indentation(sb, len);
        sb_set_other_indentation(sb, len);
        for (i = 0; i < NUM_CLAN_PRIVS; ++i)
          if (HAS_CLAN_PRIV(tch, i))
            sb_append(sb, "%s%s", seen++ ? ", " : "",
                      clan_privileges[i].abbr);
        /* skip over the first 14 spaces (dummy indentation) */
        pprintf(ch, "  Privileges: %s\r\n", sb_get_buffer(sb) + len);
        free_screen_buf(sb);
      }
      if (GET_CLAN_MEMBERSHIP(tch)->relation.alts) {
        struct clan_membership *alt;
        screen_buf sb = new_screen_buf();
        int seen = 0;
        const size_t len = strlen("  Alts: ");
        sb_set_first_indentation(sb, len);
        sb_set_other_indentation(sb, len);
        for (alt = GET_CLAN_MEMBERSHIP(tch)->relation.alts; alt; alt = alt->next)
          sb_append(sb, "%s%s", seen++ ? ", " : "", alt->name);
        /* skip over the first 8 spaces (dummy indentation) */
        pprintf(ch, "  Alts: %s\r\n", sb_get_buffer(sb) + len);
        free_screen_buf(sb);
      }
    }
    start_paging(ch);
  }
  else
    cprintf(ch, "%s %s not associated with any clan.\r\n",
            ch == tch ? "You" : GET_NAME(tch),
            ch == tch ? "are" : "is");
}

CLANCMD(clan_status)
{
  struct char_data *tch;

  argument = any_one_arg(argument, arg);

  if (IS_CLAN_SUPERADMIN(ch)) {
    if ((tch = find_char_around_char(ch, find_vis_by_name(ch, arg))))
      show_clan_member_status(ch, tch);
    else
      cprintf(ch, "Couldn't find a player by the name of '%s'.\r\n", arg);
  }
  else
    show_clan_member_status(ch, ch);
}



struct clan_edit {
  struct clan *clan;
  char string[20];
};

static EDITOR_FUNC(clan_edit_done)
{
  struct descriptor_data *d = edit->descriptor;
  struct clan_edit *data = edit->data;

  if (edit->command == ED_EXIT_SAVE) {
    editor_default_exit(edit);
    mprintf(L_STAT, LVL_GOD, "(CLAN) %s edits %s's %s",
            GET_NAME(d->character), data->clan->name, data->string);
    save_clan(data->clan);
  }

  act("$n stops writing on the large scroll.", TRUE, d->character, 0, 0, TO_ROOM);

  return ED_PROCESSED;
}

CLANCMD(clan_edit)
{
  char **message;
  struct clan_edit *data;

  if (!ch->desc)
    return;

  any_one_arg(argument, arg);

  if (is_abbrev(arg, "motd")) {
    message = &clan->motd;
    argument = "message of the day";
  }
  else if (is_abbrev(arg, "desc")) {
    message = &clan->description;
    argument = "description";
  }
  else {
    log("SYSERR: clan_edit: unknown string specified");
    return;
  }

  CREATE(data, struct clan_edit, 1);
  data->clan = clan;
  strcpy(data->string, argument);

  if (editor_edited_by(message)) {
    cprintf(ch, "%s's %s is already being edited.", clan->name, argument);
    return;
  }

  act("$n begins writing on a large scroll.", TRUE, ch, 0, 0, TO_ROOM);

  editor_init(ch->desc, message, MAX_DESC_LENGTH);
  editor_set_begin_string(ch->desc, "Edit %s's %s below.",
                          clan->name, argument);
  editor_set_callback_data(ch->desc, data, ED_FREE_DATA);
  editor_set_callback(ch->desc, ED_EXIT_SAVE, clan_edit_done);
  editor_set_callback(ch->desc, ED_EXIT_ABORT, clan_edit_done);
}


CLANCMD(clan_quit)
{
  if (IS_CLAN_APPLICANT(ch))
    cprintf(ch, "You are no longer applying to %s.\r\n", clan->name);
  else if (IS_CLAN_ALT(ch))
    cprintf(ch, "You are no longer a clan alt in %s.\r\n", clan->name);
  else if (IS_CLAN_ADMIN(ch))
    cprintf(ch, "You are no longer an administrator for %s.\r\n", clan->name);
  else if (IS_CLAN_MEMBER(ch))
    cprintf(ch, "You are no longer a member of %s.\r\n", clan->name);
  else
    cprintf(ch, "You are no longer in %s.\r\n", clan->name);
  if (!IS_CLAN_ALT(ch)) {
    mprintf(L_STAT, LVL_GOD, "(CLAN) %s quits %s.",
            GET_NAME(ch), clan->name);
    clan_notification(clan, ch, "%s has quit your clan.", 
                      GET_NAME(ch));
  }
  revoke_clan_membership(GET_CLAN_MEMBERSHIP(ch));
}


CLANCMD(clan_reject)
{
  member->since = time(0);
  member->rank = RANK_REJECT;
  --clan->applicant_count;
  ++clan->reject_count;

  save_clan(clan);

  if (member->player)
    cprintf(FORWARD(member->player),
            AFMAG "You have been rejected from %s and may reapply in %u " AFMAG 
            "days.\r\n" ANRM, member->clan->name, days_until_reapply(member));

  mprintf(L_STAT, LVL_GOD, "(CLAN) %s rejects %s's application to %s.",
          GET_NAME(ch), member->name, member->clan->name);
  cprintf(ch, "You reject %s's application to %s.\r\n",
          member->name, clan->name);
  clan_notification(clan, ch, "%s rejects %s's application to your clan.",
                    GET_NAME(ch), member->name);
}


CLANCMD(clan_snoop)
{
  struct clan_snoop *snoop, *temp;
  clan_iter iter;

  fetch_word(argument, arg, sizeof(arg));

  if (!*arg) {
    if (GET_CLAN_SNOOP(ch)) {
      cprintf(ch, "You are currently snooping:\r\n");
      for (snoop = GET_CLAN_SNOOP(ch); snoop; snoop = snoop->next)
        cprintf(ch, "  %s\r\n", snoop->clan->name);
    }
    else
      cprintf(ch, "You are not currently snooping any clan channels.\r\n");
  }

  else if (!str_cmp(arg, "off")) {
    if (GET_CLAN_SNOOP(ch)) {
      while (GET_CLAN_SNOOP(ch)) {
        snoop = GET_CLAN_SNOOP(ch)->next;
        free(GET_CLAN_SNOOP(ch));
        GET_CLAN_SNOOP(ch) = snoop;
      }
      cprintf(ch, "You are no longer snooping any clan channels.\r\n");
    }
    else
      cprintf(ch, "You are not currently snooping any clan channels.\r\n");
  }

  else if (!str_cmp(arg, "all")) {
    for (iter = clans_start(); iter != clans_end(); ++iter)
      if (!is_snooping(ch, *iter)) {
        CREATE(snoop, struct clan_snoop, 1);
        snoop->clan = *iter;
        snoop->next = GET_CLAN_SNOOP(ch);
        GET_CLAN_SNOOP(ch) = snoop;
      }
    cprintf(ch, "You are now snooping all clan channels.\r\n");
  }

  else if ((clan = find_clan(arg))) {
    if (is_snooping(ch, clan)) {      
      snoop = GET_CLAN_SNOOP(ch);
      if (snoop->clan == clan) {
        GET_CLAN_SNOOP(ch) = snoop->next;
        free(snoop);
      }
      else {
        for (; snoop && snoop->next; snoop = snoop->next) {
          if (snoop->next->clan == clan) {
            temp = snoop->next;
            snoop->next = snoop->next->next;
            free(temp);
          }
        }
      }
      cprintf(ch, "You are no longer snooping %s.\r\n", clan->name);
    }
    else {
      CREATE(snoop, struct clan_snoop, 1);
      snoop->clan = clan;
      snoop->next = GET_CLAN_SNOOP(ch);
      GET_CLAN_SNOOP(ch) = snoop;
      cprintf(ch, "You are now snooping %s.\r\n", clan->name);
    }
  }

  else 
    cprintf(ch, "'%s' does not refer to a valid clan.\r\n", arg);
}



static void send_clan_who_line(const struct char_data *ch,
                               const struct clan_membership *member)
{
  long num;
  char level_buf[4];
  char alt_buf[50];
  char logon_buf[30];
  const char *level, *title, *last_logon, *name_color;

  num = get_ptable_by_name(member->name);
  if (num >= 0) {
    snprintf(level_buf, sizeof(level_buf), "%d", player_table[num].level);
    level = level_buf;
    strftime(logon_buf, sizeof(logon_buf), "%a, %d %b %Y %H:%M",
             localtime(&player_table[num].last));
    last_logon = logon_buf;
  }
  else {
    level = "??";
    last_logon = "";
  }

  if (IS_MEMBER_RANK(member->rank))
    title = member->clan->ranks[member->rank - 1].title;
  else if (IS_APPLICANT_RANK(member->rank))
    title = "(applicant)";
  else if (IS_ALT_RANK(member->rank)) {
    snprintf(alt_buf, sizeof(alt_buf), "(%s's alt)",
             member->relation.member->name);
    title = alt_buf;
  }
  else
    title = "";

  if (IS_ALT_RANK(member->rank))
    name_color = AFYEL;
  else if (member->player)
    name_color = AFGRN;
  else
    name_color = "";

  cprintf(ch, "[%3s] %s%-10s" ANRM " " ELLIPSIS_FMT " %s\r\n",
          level, name_color, member->name, ELLIPSIS_STR(title, 25),
          last_logon);
}

static void send_clan_who_header(const struct char_data *ch)
{
  cprintf(ch, " " AUND "Lvl" ANRM
              "  " AUND "Name     " ANRM
              "  " AUND "Rank                    " ANRM
              "  " AUND "Last Login            " ANRM "\r\n");
}

CLANCMD(clan_who)
{
  struct descriptor_data *d;
  struct char_data *tch;
  bool found = FALSE;

  cprintf(ch, AHYEL "Members in " ANRM "%s" AHYEL ":" ANRM "\r\n",
          clan->name);

  for (d = descriptor_list; d; d = d->next) {
    if (!IS_PLAYING(d))
      continue;
    tch = d->character;
    if (!CAN_SEE(ch, tch) || clan != GET_CLAN(tch))
      continue;
    if (IS_CLAN_MEMBER(tch) || IS_CLAN_ALT(tch)) {
      if (!found) {
        send_clan_who_header(ch);
        found = TRUE;
      }
      send_clan_who_line(ch, GET_CLAN_MEMBERSHIP(tch));
    }
  }

  for (member = clan->members; member && IS_MEMBER_RANK(member->rank);
       member = member->next)
    if (!member->player || !member->player->desc) {
      if (!found) {
        send_clan_who_header(ch);
        found = TRUE;
      }
      send_clan_who_line(ch, member);
    }

  if (!clan->member_count)
    cprintf(ch, "  None!\r\n");

  if (clan->applicant_count) {
    found = FALSE;
    cprintf(ch, AHYEL "Applicants to " ANRM "%s" AHYEL ":" ANRM "\r\n",
            clan->name);
    for (member = clan->applicants; member && 
         IS_APPLICANT_RANK(member->rank); member = member->next) {
      if (!found) {
        send_clan_who_header(ch);
        found = TRUE;
      }
      send_clan_who_line(ch, member);
    }
  }
}


/* Clan command permission modes */
#define NONE       (1 << 0)
#define PRIV       (1 << 1) /* RANK and PRIV are mutually exclusive   */
#define ADMIN      (1 << 2) /* because the clan_subcommand data field */
#define RANK       (1 << 3) /* holds either the minimum rank for RANK */
#define SUPER      (1 << 4) /* or the privilege for PRIV, not both    */

/* Clan command argument modes */
#define IGNORE     0
#define CLAN       (1 << 0) /* CLAN and MEMBER are not mutually       */
#define MEMBER     (1 << 1) /* exclusive but if they are encountered  */
#define REPEAT     (1 << 2) /* together, the clan is parsed first     */
#define APPLICANT  (1 << 3)

/* Clan command groupings - for aesthetics only */
#define GENERAL    0
#define MGMT       1        /* Hack alert: the PRIV/ADMIN constants   */
#define PRIV       (1 << 1) /* are already used above for a bitfield  */
#define MODIFY     3        /* but for convience we're reusing them   */
#define ADMIN      (1 << 2) /* here as their actual values of 2 and 4 */
#define NUM_GROUPS 5

static const char *clan_cmdgroup[NUM_GROUPS] = {
  "General",
  "Management",
  "Privileged",
  "Modifier",
  "Administrative"
};

/* Clan command information structure */
static const struct clan_subcommand {
  char *name;
  unsigned int group;
  unsigned int type;
  unsigned int data;
  unsigned int args;
  char *more_args;
  CLANCMD(*handler);
} commands[] = { /* KEEP THIS LIST ALPHABETIZED */
  { "abbr",     ADMIN,          ADMIN,         0,              IGNORE | REPEAT, "<name>",             clan_set     },
  { "abbr",     ADMIN,                  SUPER, 0,              CLAN   | REPEAT, "<name>",             clan_set     },
  { "addrank",  MODIFY,  PRIV | ADMIN,         CPRIV_RANKS,    IGNORE | REPEAT, "",                   clan_set     },
  { "addrank",  MODIFY,                 SUPER, CPRIV_RANKS,    CLAN   | REPEAT, "",                   clan_set     },
  { "alt",      PRIV,    PRIV,                 CPRIV_ALTS,     IGNORE,          "<player>",           clan_alt     },
  { "alt",      PRIV,           ADMIN | SUPER, 0,              MEMBER,          "<player>",           clan_alt     },
  { "appfee",   MODIFY,  PRIV | ADMIN,         CPRIV_APP_FEE,  IGNORE | REPEAT, "<platinum>",         clan_set     },
  { "appfee",   MODIFY,                 SUPER, CPRIV_APP_FEE,  CLAN   | REPEAT, "<platinum>",         clan_set     },
  { "applev",   MODIFY,  PRIV | ADMIN,         CPRIV_APP_LEV,  IGNORE | REPEAT, "<level>",            clan_set     },
  { "applev",   MODIFY,                 SUPER, CPRIV_APP_LEV,  CLAN   | REPEAT, "<level>",            clan_set     },
  { "apply",    GENERAL, NONE,                 0,              CLAN,            "",                   clan_apply   },
  { "create",   ADMIN,                  SUPER, 0,              IGNORE,          "<abbr>",             clan_create  },
  { "delrank",  MODIFY,  PRIV | ADMIN,         CPRIV_RANKS,    IGNORE | REPEAT, "",                   clan_set     },
  { "delrank",  MODIFY,                 SUPER, CPRIV_RANKS,    CLAN   | REPEAT, "",                   clan_set     },
  { "demote",   MGMT,    PRIV | ADMIN | SUPER, CPRIV_DEMOTE,   MEMBER | REPEAT, "",                   clan_rank    },
  { "deposit",  GENERAL, RANK,                 MIN_ALT_RANK,   REPEAT,          "<money>",            clan_bank    },
  { "deposit",  GENERAL,                SUPER, 0,              CLAN   | REPEAT, "<money>",            clan_bank    },
  { "desc",     MODIFY,  PRIV | ADMIN,         CPRIV_DESC,     IGNORE | REPEAT, "",                   clan_edit    },
  { "desc",     MODIFY,                 SUPER, CPRIV_DESC,     CLAN   | REPEAT, "",                   clan_edit    },
  { "destroy",  ADMIN,                  SUPER, 0,              CLAN,            "",                   clan_destroy },
  { "dues",     MODIFY,  PRIV | ADMIN,         CPRIV_DUES,     IGNORE | REPEAT, "<platinum>",         clan_set     },
  { "dues",     MODIFY,                 SUPER, CPRIV_DUES,     CLAN   | REPEAT, "<platinum>",         clan_set     },
  { "enroll",   MGMT,    PRIV | ADMIN | SUPER, CPRIV_ENROLL,   APPLICANT,       "",                   clan_enroll  },
  { "expel",    MGMT,    PRIV | ADMIN | SUPER, CPRIV_EXPEL,    MEMBER,          "",                   clan_expel   },
  { "grant",    MGMT,    PRIV | ADMIN,         CPRIV_GRANT,    IGNORE | REPEAT, "<rank> <priv>",      clan_priv    },
  { "grant",    MGMT,                   SUPER, CPRIV_GRANT,    CLAN   | REPEAT, "<rank> <priv>",      clan_priv    },
  { "info",     GENERAL, RANK,                 RANK_NONE,      IGNORE,          "[<clan>]",           clan_info    },
  { "list",     GENERAL, RANK,                 RANK_NONE,      IGNORE,          "",                   clan_list    },
  { "motd",     MODIFY,  PRIV | ADMIN,         CPRIV_MOTD,     IGNORE | REPEAT, "",                   clan_edit    },
  { "motd",     MODIFY,                 SUPER, CPRIV_MOTD,     CLAN   | REPEAT, "",                   clan_edit    },
  { "name",     ADMIN,          ADMIN,         0,              IGNORE | REPEAT, "<name>",             clan_set     },
  { "name",     ADMIN,                  SUPER, 0,              CLAN   | REPEAT, "<name>",             clan_set     },
  { "promote",  MGMT,    PRIV | ADMIN | SUPER, CPRIV_PROMOTE,  MEMBER | REPEAT, "",                   clan_rank    },
  { "quit",     GENERAL, RANK,                 RANK_APPLICANT, IGNORE,          "",                   clan_quit    },
  { "reject",   MGMT,    PRIV | ADMIN | SUPER, CPRIV_ENROLL,   APPLICANT,       "",                   clan_reject  },
  { "revoke",   MGMT,    PRIV | ADMIN,         CPRIV_GRANT,    IGNORE | REPEAT, "<rank> <privilege>", clan_priv    },
  { "revoke",   MGMT,                   SUPER, CPRIV_GRANT,    CLAN   | REPEAT, "<rank> <privilege>", clan_priv    },
  { "snoop",    GENERAL,                SUPER, 0,              IGNORE,          "{off | all | <clan>}", clan_snoop },
  { "status",   GENERAL, RANK,                 RANK_REJECT,    IGNORE,          "",                   clan_status  },
  { "status",   GENERAL,                SUPER, 0,              IGNORE,          "[<player>]",         clan_status  },
  { "tell",     GENERAL, PRIV | ADMIN,         CPRIV_CHAT,     IGNORE,          "<message>",          clan_tell    },
  { "tell",     GENERAL,                SUPER, CPRIV_CHAT,     CLAN,            "<message>",          clan_tell    },
  { "title",    MODIFY,  PRIV | ADMIN,         CPRIV_TITLE,    IGNORE | REPEAT, "<rank> <title>",     clan_set     },
  { "title",    MODIFY,                 SUPER, CPRIV_TITLE,    CLAN   | REPEAT, "<rank> <title>",     clan_set     },
  { "who",      GENERAL, RANK,                 MIN_ALT_RANK,   IGNORE,          "",                   clan_who     },
  { "who",      GENERAL,                SUPER, 0,              CLAN,            "",                   clan_who     },
  { "withdraw", PRIV,    PRIV | ADMIN,         CPRIV_WITHDRAW, REPEAT,          "<money>",            clan_bank    },
  { "withdraw", PRIV,                   SUPER, 0,              CLAN   | REPEAT, "<money>",            clan_bank    },
  { 0,          0,       0,                    0,              0,               0,                    0            },
};

static bool can_use_clan_command(const struct char_data *ch,
                                 const struct clan_subcommand *command)
{
  if (IS_SET(command->type, NONE))
    if (GET_CLAN_RANK(ch) == RANK_NONE && !IS_CLAN_SUPERADMIN(ch))
      return TRUE;
  if (IS_SET(command->type, RANK))
    if (!OUTRANKS(command->data, GET_CLAN_RANK(ch)))
      return TRUE;
  if (IS_SET(command->type, PRIV))
    if (HAS_CLAN_PRIV(ch, command->data))
      return TRUE;
  if (IS_SET(command->type, ADMIN))
    if (IS_CLAN_ADMIN(ch))
      return TRUE;
  if (IS_SET(command->type, SUPER))
    if (IS_CLAN_SUPERADMIN(ch))
      return TRUE;
  return FALSE;
}

static const struct clan_subcommand *determine_command(const struct char_data *ch,
                                                       const char *cmd)
{
  const struct clan_subcommand *command = NULL;

  for (command = commands; command->name; ++command) {
    if (*command->name < *cmd) continue;
    else if (*command->name > *cmd) break;
    else if (is_abbrev(cmd, command->name))
      if (can_use_clan_command(ch, command))
        return command;
  }

  return NULL;
}

ACMD(do_clan)
{
  const struct clan_subcommand *command = NULL;
  struct clan *clan;
  struct clan_membership *member;
  char argbuf[MAX_INPUT_LENGTH];
  unsigned int group;

  if (IS_NPC(ch) || !ch->desc) {
    cprintf(ch, "%s", HUH);
    return;
  }

  clan = GET_CLAN(ch);
  member = GET_CLAN_MEMBERSHIP(ch);

  /* Determine which command to invoke */
  argument = any_one_arg(argument, argbuf);
  if (strlen(argbuf) >= 3)
    if ((command = determine_command(ch, argbuf))) {
      if (IS_SET(command->args, CLAN)) {
        argument = any_one_arg(argument, arg);
        if (!*arg) {
          cprintf(ch, "Which clan?\r\n");
          return;
        }
        else if (!(clan = find_clan(arg))) {
          cprintf(ch, "'%s' does not refer to a valid clan.\r\n", arg);
          return;
        }
      }
      if (IS_SET(command->args, MEMBER | APPLICANT)) {
        argument = any_one_arg(argument, arg);
        CAP(arg);
        if (!*arg) {
          cprintf(ch, "Whom do you want to %s?\r\n", argbuf);
          return;
        }
        else if (!(member = find_clan_membership(arg))) {
          cprintf(ch, "%s is not a member or applicant of any clan.\r\n", arg);
          return;
        }
        else if (IS_SET(command->args, APPLICANT) &&
                 member->rank != RANK_APPLICANT) {
          cprintf(ch, "%s is not an applicant of any clan.\r\n", arg);
          return;
        }
        else if (!IS_CLAN_SUPERADMIN(ch) &&
                 GET_CLAN(ch) != member->clan) {
          cprintf(ch, "%s is not a member of your clan.\r\n", arg);
          return;
        }
        if (!IS_SET(command->args, CLAN))
          clan = member->clan;
      }
      if (IS_SET(command->args, REPEAT)) {
        strcat(argbuf, argument);
        argument = argbuf;
      }
      else
        skip_spaces(&argument);

      command->handler(ch, member, clan, argument);
      return;
    }

  for (group = 0; group < NUM_GROUPS; ++group) {
    strcpy(buf, "--------------------------------------------------------------------");
    sprintf(buf1, "[ %s commands ]", clan_cmdgroup[group]);
    strncpy(buf + 2, buf1, strlen(buf1));
    for (command = commands; command->name; ++command) {
      if (group != command->group)
        continue;
      if (can_use_clan_command(ch, command)) {
        if (*buf) {
          cprintf(ch, "\r\n%s", buf);
          *buf = '\0';
        }
        cprintf(ch, "\r\n   clan %-8s", command->name);
        if (IS_SET(command->args, CLAN))
          cprintf(ch, " <clan>");
        if (IS_SET(command->args, APPLICANT))
          cprintf(ch, " <applicant>");
        else if (IS_SET(command->args, MEMBER))
          cprintf(ch, " <member>");
        if (command->more_args)
          cprintf(ch, " %s", command->more_args);
      }
    }
  }
  cprintf(ch, "\r\n");
}

ACMD(do_ctell)
{
  struct char_data *me = REAL_CHAR(ch);
  struct clan *clan = GET_CLAN(me);

  if (IS_CLAN_SUPERADMIN(me)) {
    /* Only snooping one clan: auto send to that one */
    if (GET_CLAN_SNOOP(me) && !GET_CLAN_SNOOP(me)->next)
      clan_tell(ch, NULL, GET_CLAN_SNOOP(me)->clan, argument);
    else {
      argument = any_one_arg(argument, arg);
      if (!*arg)
        cprintf(ch, "Which clan do you want to talk to?\r\n");
      else if (!(clan = find_clan(arg)))
        cprintf(ch, "'%s' does not refer to a valid clan.\r\nYou can "
                    "only omit the clan if you are snooping just one "
                    "clan.\r\n", arg);
      else if (!is_snooping(me, clan))
        cprintf(ch, "You must be snooping %s first.\r\n", clan->name);
      else
        clan_tell(ch, NULL, clan, argument);
    }
  }
  else if (!clan || IS_CLAN_REJECT(me))
    cprintf(ch, "You're not part of a clan.\r\n");
  else if (IS_CLAN_APPLICANT(me))
    cprintf(ch, "You're not part of a clan.\r\n");
  else if (CAN_DO_PRIV(me, CPRIV_CHAT) ||
           (IS_CLAN_ALT(me) && 
            MEMBER_CAN(GET_CLAN_MEMBERSHIP(me)->relation.member, CPRIV_CHAT)))
    clan_tell(ch, GET_CLAN_MEMBERSHIP(me), clan, argument);
  else
    cprintf(ch, "You don't have access to clan chat.\r\n");
}

/***************************************************************************
 * $Log: clan.c,v $
 * Revision 1.43  2009/06/20 23:55:13  myc
 * Clean up makedrunk and rename it drunken_speech.
 *
 * Revision 1.42  2009/06/11 02:13:41  myc
 * Fix array index bug in clan demote/promote.
 *
 * Revision 1.41  2009/06/11 01:57:23  myc
 * Fix clan tell again.
 *
 * Revision 1.40  2009/06/11 01:09:58  myc
 * Allow ctell for alts.
 *
 * Revision 1.39  2009/06/09 21:50:21  myc
 * clan_notification now adds the color codes for you and surrounds
 * the message in square brackets.  Split 'clan info' back into
 * separate 'clan info' and 'clan status' commands.  Put in column
 * headers in clan who.
 *
 * Revision 1.38  2009/06/09 05:34:09  myc
 * Completely rewrote all clan-related code.  This file now only
 * contains 'front-end' code--i.e., all the clan subcommands.
 * Clan implementation code is in clansys.c.
 *
 * Revision 1.37  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.36  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.35  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.34  2009/02/11 17:03:39  myc
 * Update clan_tell to check EDITING when it checks WRITING.
 *
 * Revision 1.33  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.32  2008/08/17 06:53:06  jps
 * Removing function prototype for speech_ok since it's now in comm.h.
 *
 * Revision 1.31  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.30  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.29  2008/07/27 05:12:48  jps
 * Changed name of save_player to save_player_char, since it only saves the
 * character, not other stuff like objects and quests.
 *
 * Revision 1.28  2008/06/05 02:07:43  myc
 * Added better unknown tag error reporting.
 *
 * Revision 1.27  2008/05/18 03:51:32  jps
 * Typo fix
 *
 * Revision 1.26  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.25  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.24  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through strinwrite()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.23  2008/03/19 04:32:14  myc
 * Fixed message in do_clan_reject missing newline.
 *
 * Revision 1.22  2008/03/05 05:21:56  myc
 * Removed a save_char_file_u declaration.
 *
 * Revision 1.21  2008/03/05 05:08:28  jps
 * Changed ascii player tags and allow them to be of variable length up to
 * 126 characters.
 *
 * Revision 1.20  2008/03/05 03:03:54  myc
 * Pfiles are now ascii, so you access them differently now.  Also
 * some stuff can be retrieved directly from the index instead of
 * requiring a load_char.
 *
 * Revision 1.19  2008/02/24 17:31:13  myc
 * Clan tell will only be received in OLC if you have OLCComm toggled
 * on.  Also clan members can block clan tell with the NoClanTell toggle.
 *
 * Revision 1.18  2008/02/23 01:03:54  myc
 * Plugging a memory leak where members weren't being freed when freeing
 * all clans.
 *
 * Revision 1.17  2008/02/16 20:26:04  myc
 * Adding functions to free clans at program termination.  Replaced
 * a few RECREATE calls with CREATE calls since zmalloc was complaining
 * about them.
 *
 * Revision 1.16  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.15  2008/02/02 19:38:20  myc
 * Replacing NOONE with NOPERSON.  Changing clan desc edit to use
 * the strinwrite function.
 *
 * Revision 1.14  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.13  2008/01/08 22:36:14  myc
 * Fixing bug where plat wasn't saving if the clan had no copper.
 *
 * Revision 1.12  2008/01/05 06:06:35  myc
 * Removing an extra return in the clan command that was cutting the
 * command list short.
 *
 * Revision 1.11  2008/01/05 05:36:34  jps
 * Changed name of function save_char() to save_player(). Because it
 * only operates on players.
 *
 * Revision 1.10  2007/12/25 05:33:55  myc
 * Fixing a crash bug in clan expel.
 *
 * Revision 1.9  2007/12/20 23:10:20  myc
 * Clan deposit/withdraw no longer modifies clan god's coins on hand.
 *
 * Revision 1.8  2007/12/19 20:40:36  myc
 * Completely rewrote clan code.  Clans now use ASCII files.  Several new
 * features are also available, including alts, abbreviations (vs names),
 * descriptions, and smarter handling of just about everything.
 *
 * Revision 1.7  2004/11/11 20:27:48  rsd
 * I altered the output of the string for the clan commands
 * to be less than the compiler limited length of 509 by
 * breaking it up into 2 send_to_char's instead of the one
 * large one.  This removed a compile warning.
 *
 * Revision 1.6  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.5  2000/11/20 18:43:29  rsd
 * Fixed the comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.4  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.3  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to 
 * clarify their behavior to the compiler.  The name approval code was also 
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the 
 * xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
 * --Gurlaek 6/10/1999 
 *
 * Revision 1.2  1999/01/30 18:04:01  mud
 * indented entire file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.43
log
@Clean up makedrunk and rename it drunken_speech.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.42 2009/06/11 02:13:41 myc Exp myc $
d173 2
d176 1
a176 1
    if (!IS_PLAYING(d) || !tch || tch == me)
d1069 1
a1069 1
        for (; snoop->next; snoop = snoop->next) {
d1459 3
@


1.42
log
@Fix array index bug in clan demote/promote.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.41 2009/06/11 01:57:23 myc Exp myc $
d29 1
a147 2
  extern char *makedrunk(char *string, struct char_data *);

d167 1
a167 1
  argument = makedrunk(argument, ch);
d1457 3
@


1.41
log
@Fix clan tell again.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.40 2009/06/11 01:09:58 myc Exp myc $
d589 1
a589 1
                    clan->ranks[member->rank - 1].title);
d1458 3
@


1.40
log
@Allow ctell for alts.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.39 2009/06/09 21:50:21 myc Exp myc $
d1451 2
a1453 2
  else
    clan_tell(ch, GET_CLAN_MEMBERSHIP(me), clan, argument);
d1458 3
@


1.39
log
@clan_notification now adds the color codes for you and surrounds
the message in square brackets.  Split 'clan info' back into
separate 'clan info' and 'clan status' commands.  Put in column
headers in clan who.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.38 2009/06/09 05:34:09 myc Exp myc $
d1448 3
a1450 1
  else if (!CAN_DO_PRIV(me, CPRIV_CHAT))
d1458 6
@


1.38
log
@Completely rewrote all clan-related code.  This file now only
contains 'front-end' code--i.e., all the clan subcommands.
Clan implementation code is in clansys.c.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.37 2009/03/09 20:36:00 myc Exp myc $
d188 1
a188 1
              member ? "your clan" : clan->abbreviation, argument);
d238 1
a238 1
    clan_notification(clan, ch, AFMAG "%s adds a new rank to your clan.\r\n" ANRM, 
d282 1
a282 1
    clan_notification(clan, ch, AFMAG "%s removes a rank from your clan.\r\n" ANRM,
d354 2
a355 2
    clan_notification(clan, ch, AFMAG "%s has changed rank %u's title to %s" 
                            AFMAG ".\r\n" ANRM, GET_NAME(ch), rank, argument);
d463 1
a463 1
  clan_notification(clan, NULL, AFMAG "%s has applied to your clan.\r\n" ANRM, 
d587 1
a587 1
  clan_notification(clan, ch, AFMAG "%s has %sd %s to rank %u: " ANRM "%s\r\n",
d600 1
a600 1
  clan_notification(clan, ch, AFMAG "Your clan has been disbanded!\r\n" ANRM);
d663 1
a663 1
  clan_notification(clan, ch, AFMAG "%s has expelled %s from your clan.\r\n" ANRM,
d800 20
a819 2
static void show_clan_member_info(struct char_data *ch,
                                  const struct char_data *tch)
d840 1
a840 1
    pprintf(ch, "Clan membership information for %s:\r\n"
d891 1
a891 1
CLANCMD(clan_info)
d897 1
a897 5
  if (!*arg)
    show_clan_member_info(ch, ch);
  else if ((clan = find_clan(arg)))
    show_clan_info(ch, clan);
  else if (IS_CLAN_SUPERADMIN(ch)) {
d899 1
a899 1
      show_clan_member_info(ch, tch);
d901 1
a901 1
      cprintf(ch, "'%s' does not refer to a clan or player.\r\n", arg);
d904 1
a904 1
    cprintf(ch, "'%s' does not refer to a valid clan.\r\n", arg);
a985 1
  revoke_clan_membership(GET_CLAN_MEMBERSHIP(ch));
d989 1
a989 1
    clan_notification(clan, ch, AFMAG "%s has quit your clan.\r\n" ANRM, 
d992 1
d1014 1
a1014 1
  clan_notification(clan, ch, AFMAG "%s rejects %s's application to your clan.\r\n" ANRM,
d1106 1
a1106 1
    strftime(logon_buf, sizeof(logon_buf), "%a %d %b %Y %H:%M",
d1139 8
d1151 1
d1162 5
a1166 1
    if (IS_CLAN_MEMBER(tch) || IS_CLAN_ALT(tch))
d1168 1
d1173 7
a1179 2
    if (!member->player || !member->player->desc)
        send_clan_who_line(ch, member);
d1185 1
d1189 5
a1193 1
         IS_APPLICANT_RANK(member->rank); member = member->next)
d1195 1
d1275 2
a1276 2
  { "revoke",   MGMT,    PRIV | ADMIN,         CPRIV_GRANT,    IGNORE | REPEAT, "",                   clan_priv    },
  { "revoke",   MGMT,                   SUPER, CPRIV_GRANT,    CLAN   | REPEAT, "",                   clan_priv    },
d1278 2
d1456 5
@


1.37
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.36 2009/03/09 05:41:31 jps Exp myc $
d6 1
a6 1
 *  Usage: Code for the clan system                                        *
a20 1
#include "casting.h"
a22 1
#include "diskio.h"
d26 1
d28 1
a28 2
#include "limits.h"
#include "money.h"
a29 64
/*
 * Needed for mkdir in init_clans.  This is only guaranteed to work on 
 * systems with the GNU C library.  But I don't forsee us switching to
 * Windows or something anytime soon.
 */
#include <sys/stat.h>

/*
 * External variables and functions.
 */
struct char_data *is_playing(char *vict_name);
char *makedrunk(char *string, struct char_data *ch);

/*
 * Local variables.
 */
int num_of_clans;
struct clan_record *clans;

/*
 * Clan commands and functions.
 */
void do_clan_list(struct char_data *ch, char *argument);
void do_clan_deposit(struct char_data *ch, char *argument);
void do_clan_withdraw(struct char_data *ch, char *argument);
void do_clan_enroll(struct char_data *ch, char *argument);
void do_clan_expel(struct char_data *ch, char *argument);
void do_clan_who(struct char_data *ch, char *argument);
void do_clan_info(struct char_data *ch, char *argument);
void do_clan_apply(struct char_data *ch, char *argument);
void do_clan_demote(struct char_data *ch, char *argument);
void do_clan_promote(struct char_data *ch, char *argument);
void do_clan_set(struct char_data *ch, char *argument);
void do_clan_snoop(struct char_data *ch, char *argument);
void do_clan_create(struct char_data *ch, char *argument);
void do_clan_destroy(struct char_data *ch, char *argument);
void do_clan_tell(struct char_data *ch, char *argument);
void do_clan_status(struct char_data *ch, char *argument);
void do_clan_reject(struct char_data *ch, char *argument);
void do_clan_quit(struct char_data *ch, char *argument);
void save_clan(int clan, int mode);
void get_player(char *name, struct char_data **tch, bool *is_linkload);
void clan_set_title(struct char_data *ch);
bool load_clan(char *clan_num, int clan_index);
bool remove_player_from_clan(char *name, int clan_id);
void delete_clan(int clan_index);
void refresh_clan_member_titles(int clan_index);

/*
 * Clan constants.
 */
const char *clan_privileges[NUM_CLAN_PRIVS+1] = {
  "setdesc",
  "enroll",
  "expel",
  "promote",
  "demote",
  "setappfee",
  "withdraw",
  "setapplev",
  "setalt",
  "settitle",
  "setdues",
};
d31 3
a33 2
const char *NOCLAN = "You don't belong to any clan!\r\n";
const char *NOPRIV = "You're not influent enough in the clan to do that!\r\n";
d35 5
a40 13
/*
 * The main clan command dispatcher.  It attempts to determine which 
 * clan command the user is trying to execute.  If the player has the
 * right to use that command, it passes control on to the subcommand.
 * Otherwise, it lists all allowed clan commands to the player.
 */
#define CLAN_CMD_NONE		1
#define CLAN_CMD_ANY		2
#define CLAN_CMD_SURROGATE	3
#define CLAN_CMD_MEMBER		4
#define CLAN_CMD_PRIVILEGED	5
#define CLAN_CMD_LEADER		6
#define CLAN_CMD_MASTER		7
d42 1
a42 1
ACMD(do_clan)
d44 1
a44 28
  struct clan_command {
    char *name;
    char type;
    int privilege;
    void (*command_pointer) (struct char_data *ch, char *argument);
  } clan_commands[] = {
    {"list",	CLAN_CMD_ANY,		0,			do_clan_list},
    {"status",  CLAN_CMD_ANY,		0,			do_clan_status},
    {"tell",    CLAN_CMD_SURROGATE,	0,			do_clan_tell},
    {"deposit",	CLAN_CMD_SURROGATE,	0,			do_clan_deposit},
    {"withdraw",CLAN_CMD_PRIVILEGED,	CLAN_PRIV_WITHDRAW,	do_clan_withdraw},
    {"enroll",	CLAN_CMD_PRIVILEGED,	CLAN_PRIV_ENROLL,	do_clan_enroll},
    {"expel",	CLAN_CMD_PRIVILEGED,	CLAN_PRIV_EXPEL,	do_clan_expel},
    {"who",	CLAN_CMD_SURROGATE,	0,			do_clan_who},
    {"info",	CLAN_CMD_ANY,		0,			do_clan_info},
    {"apply",	CLAN_CMD_NONE,		0,			do_clan_apply},
    {"demote",	CLAN_CMD_PRIVILEGED,	CLAN_PRIV_DEMOTE,	do_clan_demote},
    {"promote",	CLAN_CMD_PRIVILEGED,	CLAN_PRIV_PROMOTE,	do_clan_promote},
    {"set",	CLAN_CMD_MEMBER,	0,			do_clan_set},
    {"snoop",	CLAN_CMD_MASTER,	0,			do_clan_snoop},
    {"create",	CLAN_CMD_MASTER,	0,			do_clan_create},
    {"destroy",	CLAN_CMD_MASTER,	0,			do_clan_destroy},
    {"quit",	CLAN_CMD_SURROGATE,	0,			do_clan_quit},
    {"reject",	CLAN_CMD_PRIVILEGED,	CLAN_PRIV_ENROLL,	do_clan_reject},
    {NULL,	0}
  };
  int i, clan = find_clan_by_id(GET_CLAN(ch));
  bool is_clan_god = IS_CLAN_GOD(ch);
d46 2
a47 2
  if (IS_NPC(ch)) {
    send_to_char(HUH, ch);
d51 9
a59 46
  /*
   * Determine which command, if any the player is attempting to run.
   */
  argument = any_one_arg(argument, arg);
  if (*arg)
    for (i = 0; clan_commands[i].name; ++i)
      if (is_abbrev(arg, clan_commands[i].name)) {
        if (is_clan_god) {
          /* Clan gods can do anything except apply. */
          if (clan_commands[i].type == CLAN_CMD_NONE)
            continue;
        }
        else switch (clan_commands[i].type) {
          case CLAN_CMD_NONE:
            if (IS_CLAN_MEMBER(ch) || IS_CLAN_SURROGATE(ch))
              continue;
            break;
          case CLAN_CMD_LEADER:
            if (clan >= 0 && !IS_CLAN_LEADER(ch, clan))
              continue;
            /* FALL THROUGH */
          case CLAN_CMD_PRIVILEGED:
            if (clan >= 0 && !HAS_CLAN_PRIV(ch, clan, clan_commands[i].privilege))
              continue;
            /* FALL THROUGH */
          case CLAN_CMD_MEMBER:
            if (!IS_CLAN_MEMBER(ch))
              continue;
            /* FALL THROUGH */
          case CLAN_CMD_SURROGATE:
            if (clan < 0 || IS_CLAN_APPLICANT(ch))
              continue;
            break;
        }
        /*
         * If the user is trying to use the 'destroy' command, but 
         * didn't spell out 'destroy', then don't let it go through.
         */
        if (!strcmp(clan_commands[i].name, "destroy") && str_cmp(arg, "destroy")) {
          send_to_char("You must spell out 'destroy' to reinforce your intentions.\r\n", ch);
          return;
        }
        /* Execute subcommand. */
        (*clan_commands[i].command_pointer)(ch, argument);
        return;
      }
d61 2
a62 4
  /*
   * No command was specified, or it was an unrecognized one, so list
   * allowed commands to the player.
   */
a63 1
  send_to_char("Clan commands available to you:\r\n", ch);
d65 5
a69 3
  send_to_char("   clan list\r\n"
               "   clan info       [<clan>]\r\n"
               "   clan status\r\n", ch);
d71 7
a77 7
#ifdef ALLOW_CLAN_QUIT
  if (clan >= 0)
    send_to_char("   clan quit\r\n", ch);
#endif

  if ((clan < 0 || IS_CLAN_APPLICANT(ch)) && !is_clan_god) {
    send_to_char("   clan apply      <clan number>\r\n", ch);
d81 10
a90 1
  /* Henceforth, you may assume that the player is in a clan / is a clan god. */
d92 6
a97 16
  sprintf(buf, "   clan who%s\r\n",
          is_clan_god ? "        <clan>" : "");
  send_to_char(buf, ch);

  sprintf(buf, "   clan tell       %s[#<rank>] <message>\r\n",
          is_clan_god ? "[<clan>] " : "");
  send_to_char(buf, ch);

  sprintf(buf, "   clan deposit    <amount>%s\r\n",
          is_clan_god ? " <clan number>" : "");
  send_to_char(buf, ch);

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_WITHDRAW)) {
    sprintf(buf, "   clan withdraw   <amount>%s\r\n",
            is_clan_god ? " <clan number>" : "");
    send_to_char(buf, ch);
d99 13
a111 24


  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_ENROLL)) {
    sprintf(buf, "   clan enroll     <player>%s\r\n"
                 "   clan reject     <player>\r\n",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
  }

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_EXPEL))
    send_to_char("   clan expel      <player>\r\n", ch);

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_DEMOTE))
    send_to_char("   clan demote     <player>\r\n", ch);

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_PROMOTE))
    send_to_char("   clan promote    <player>\r\n", ch);

#ifdef ALLOW_CLAN_ALTS
  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_ALT)) {
    sprintf(buf, "   clan set alt    %s%s\r\n",
            is_clan_god ? "<alt>" : "<player>",
            is_clan_god ? " <member>" : "");
    send_to_char(buf, ch);
a112 1
#endif
d114 9
a122 4
  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_APP_FEE)) {
    sprintf(buf, "   clan set appfee <platinum>%s\r\n",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
d124 5
a128 11

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_APP_LEV)) {
    sprintf(buf, "   clan set applev <level>%s\r\n",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
  }

  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_TITLE)) {
    sprintf(buf, "   clan set title  <rank>%s <title>\r\n",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
d130 2
a132 5
  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_DUES)) {
    sprintf(buf, "   clan set dues   <platinum>%s\r\n",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
  }
d134 3
a136 5
  if (is_clan_god || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_DESC)) {
    sprintf(buf, "   clan set desc%s\r\n",
            is_clan_god ? "   <clan>" : "");
    send_to_char(buf, ch);
  }
d138 3
a140 8
  if (is_clan_god || IS_CLAN_LEADER(ch, clan)) {
    /* is leader or clan god */
    sprintf(buf, "   clan set ranks  <ranks>%s\r\n"
                 "   clan set priv   <privilege> <rank>%s\r\n",
            is_clan_god ? " <clan>" : "",
            is_clan_god ? " <clan>" : "");
    send_to_char(buf, ch);
  }
d142 1
a142 7
  if (is_clan_god)
    send_to_char("   clan set name   <clan> <new name>\r\n"
                 "   clan set abbr   <clan> <new abbr>\r\n"
                 "   clan create     <clan name>\r\n"
                 "   clan destroy    <clan number>\r\n"
                 "   clan snoop      <off | all | clan number>\r\n",
                 ch);
d145 3
a147 7
/*
 * clan list
 *
 * Lists all clans.  Nothing special.
 */
void do_clan_list(struct char_data *ch, char *argument) {
  int i, j, buffer;
d149 3
a151 48
  if (num_of_clans == 0) {
    send_to_char("No clans have formed yet.\r\n", ch);
    return;
  }

  /*
   * List all the clans, # of members, power, and app fee.
   */
  for (i = 0; i < num_of_clans; ++i) {
    buffer = 20 - strlen(strip_ansi(clans[i].abbreviation));
    for (j = 0; j < buffer; ++j)
      buf1[j] = ' ';
    buf1[j] = '\0';
    pprintf(ch, "[%3d]  %s%s Members: %2d  Power: %4d  App Fee: %d &6&bPlatinum&0\r\n",
            clans[i].id, clans[i].abbreviation, buf1, 
            clans[i].members, clans[i].power, clans[i].app_fee);
  }
  start_paging(ch);
}


/*
 * clan deposit <amount>
 * clan withdraw <amount>
 * clan deposit <amount> <clan>
 * clan withdraw <amount> <clan>
 *
 * Clan gods can deposit or withdraw from any clan.  Otherwise, only 
 * clan members and surrogates can deposit in their own clan, and only
 * clan members with the withdraw privilege can withdraw from their own
 * clan.  Mortals can never deposit or withdraw from a clan to which 
 * they do not belong. 
 */
void do_clan_bank(struct char_data *ch, char *argument, bool is_deposit) {
  int plat = 0, gold = 0, silver = 0, copper = 0, amount = -1;
  int clan = find_clan_by_id(GET_CLAN(ch));

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
      return;
    }

    if (!is_deposit && !HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_WITHDRAW)) {
      send_to_char(NOPRIV, ch);
      return;
    }
  }
a152 3
  /*
   * Figure out the amount of money to deposit/withdraw.
   */
a153 34
  while (*argument) {
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      /* Not a number! */
      amount = -1;
      break;
    }
    amount = atoi(arg);
    argument = any_one_arg(argument, arg);
    if (is_abbrev(arg, "platinum"))
      plat += amount;
    else if (is_abbrev(arg, "gold"))
      gold += amount;
    else if (is_abbrev(arg, "silver"))
      silver += amount;
    else if (is_abbrev(arg, "copper"))
      copper += amount;
    /*
     * If this is the last argument and the player is a clan god,
     * then change the clan being operated on.
     */
    else if (!*arg && IS_CLAN_GOD(ch)) {
      clan = find_clan_by_id(amount);
      if (clan < 0) {
        send_to_char("There's no clan with that number.\r\n", ch);
        return;
      }
    }
    else {
      /* Not a type of money! */
      amount = -1;
      break;
    }
  }
d155 2
a156 5
  if (amount == -1 ||
      (plat == 0 && gold == 0 && silver == 0 && copper == 0)) {
    sprintf(buf, "How much do you want to %s the clan bank?\r\n", 
            is_deposit ? "deposit in" : "withdraw from");
    send_to_char(buf, ch);
d160 1
a160 4
  if (clan < 0 && IS_CLAN_GOD(ch)) {
    sprintf(buf, "Which clan's bank do you want to %s?\r\n", 
            is_deposit ? "deposit in" : "withdraw from");
    send_to_char(buf, ch);
a161 1
  }
d163 2
a164 4
  if (!IS_CLAN_GOD(ch) && is_deposit &&
      (GET_PLATINUM(ch) < plat || GET_GOLD(ch) < gold ||
       GET_SILVER(ch) < silver || GET_COPPER(ch) < copper)) {
    send_to_char("You do not have that kind of money!\r\n", ch);
d168 1
a168 7
  if (!is_deposit && (clans[clan].treasure[PLATINUM] < plat || 
                      clans[clan].treasure[GOLD] < gold ||
                      clans[clan].treasure[SILVER] < silver ||
                      clans[clan].treasure[COPPER] < copper)) {
    send_to_char("The clan is not wealthy enough for your needs!\r\n", ch);
    return;
  }
d170 2
a171 12
  sprintf(buf, "You %s %s&0's account:\r\n",
          is_deposit ? "deposit into" : "withdraw from",
          clans[clan].name);
  if (plat)
    sprintf(buf, "%s%d &6&bplatinum&0 ", buf, plat);
  if (gold)
    sprintf(buf, "%s%d &3&bgold&0 ", buf, gold);
  if (silver)
    sprintf(buf, "%s%d &7silver&0 ", buf, silver);
  if (copper)
    sprintf(buf, "%s%d &3copper&0 ", buf, copper);
  send_to_char(strcat(buf, "\r\n"), ch);
d173 16
a188 14
  /* Withdrawing is the same as depositing a negative amount. */
  if (!is_deposit) {
    plat = -plat;
    gold = -gold;
    silver = -silver;
    copper = -copper;
  }

  if (!IS_CLAN_GOD(ch)) {
    GET_PLATINUM(ch) -= plat;
    GET_GOLD(ch) -= gold;
    GET_SILVER(ch) -= silver;
    GET_COPPER(ch) -= copper;
    save_player_char(ch);
a189 14

  clans[clan].treasure[PLATINUM] += plat;
  clans[clan].treasure[GOLD] += gold;
  clans[clan].treasure[SILVER] += silver;
  clans[clan].treasure[COPPER] += copper;
  save_clan(clan, REAL);
}

void do_clan_deposit(struct char_data *ch, char *argument) {
  do_clan_bank(ch, argument, TRUE);
}

void do_clan_withdraw(struct char_data *ch, char *argument) {
  do_clan_bank(ch, argument, FALSE);
d193 2
a194 26
/*
 * clan enroll <player>
 * clan enroll <player> <clan>
 * 
 * Enroll a clan applicant in a clan.  Only clan members with the 
 * enroll privilege may enroll an applicant in their own clan.  Clan
 * gods can enroll any unaffiliated player in any clan.  If the clan
 * is empty, then the newly enrolled clan member becomes the leader.
 */
void do_clan_enroll(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  bool is_linkload;
  struct char_data *vict;

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
      return;
    }

    if (!HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_ENROLL)) {
      send_to_char(NOPRIV, ch);
      return;
    }
  }

d197 6
a202 25
  if (!*arg) {
    send_to_char("Whom do you want to enroll?\r\n", ch);
    return;
  }

  /*
   * Get the player.  If is_linkload is true, vict must be freed.
   */
  get_player(arg, &vict, &is_linkload);

  if (!vict) {
    send_to_char(NOPERSON, ch);
    return;
  }

  /*
   * Which clan should the victim be enrolled in?
   */
  if (IS_CLAN_GOD(ch)) {
    argument = any_one_arg(argument, arg);
    if (!*arg) {
      sprintf(buf, "Which clan do you want to enroll %s in?\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
      if (is_linkload)
        free_char(vict);
d205 4
a208 4
    else if ((clan = find_clan(arg)) < 0) {
      send_to_char("There's no clan with that id.\r\n", ch);
      if (is_linkload)
        free_char(vict);
d211 5
d218 2
a219 58
  if (!IS_CLAN_GOD(ch) && GET_CLAN(vict) != clans[clan].id) {
    sprintf(buf, "%s didn't request to join %s.\r\n", 
            GET_NAME(vict), clans[clan].name);
    send_to_char(buf, ch);
  }
  else if (GET_CLAN(vict) && IS_CLAN_MEMBER(vict)) {
    sprintf(buf, "%s is already in a clan.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (GET_CLAN(vict) && IS_CLAN_SURROGATE(vict)) {
    sprintf(buf, "%s is already an alt in a clan.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }  
  else if (IS_CLAN_GOD(vict))
    send_to_char("You cannot enroll clan gods in clans.\r\n", ch);
  else {
    struct clan_member *member;
    GET_CLAN(vict) = clans[clan].id;
    if (clans[clan].member_list)
      GET_CLAN_RANK(vict) = 1;
    else
      GET_CLAN_RANK(vict) = clans[clan].ranks;
    clan_set_title(vict);
    save_player_char(vict);

    CREATE(member, struct clan_member, 1);
    member->name = strdup(GET_NAME(vict));
    member->rank = GET_CLAN_RANK(vict);
    member->next = clans[clan].member_list;
    clans[clan].member_list = member;
    clans[clan].power += GET_LEVEL(vict);
    clans[clan].members++;
    if (GET_CLAN_RANK(vict) == 1) {
      if (vict->desc)
        send_to_char("You've been enrolled in your applicant clan!\r\n", vict);
      sprintf(buf, "You enroll %s in %s.\r\n", GET_NAME(vict),
              IS_CLAN_GOD(ch) ? clans[clan].name : "your clan");
    }
    else {
      if (vict->desc) {
        sprintf(buf, "You've been appointed the leader of %s!\r\n", 
                clans[clan].name);
        send_to_char(buf, vict);
      }
      sprintf(buf, "You appoint %s the leader of %s.\r\n", 
              GET_NAME(vict), clans[clan].name);
    }
    send_to_char(buf, ch);
    save_clan(clan, REAL);
    sprintf(buf, "(CLAN) %s enrolls %s in %s.", 
            GET_NAME(ch), GET_NAME(vict), clans[clan].name);
    mudlog(buf, CMP, LVL_GOD, TRUE);
  }

  if (is_linkload)
    free_char(vict);
}

d221 2
a222 15
/*
 * clan expel <member>
 *
 * Expel a clan member from a clan.  Clan members may only do this if 
 * they have the expel privilege and the victim is a lower rank.  Clan
 * gods may expel a clan member from any clan.
 */
void do_clan_expel(struct char_data *ch, char *argument) {
  bool is_linkload;
  struct char_data *vict;
  int clan = find_clan_by_id(GET_CLAN(ch));

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
d226 9
a234 7
    if (!HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_EXPEL)) {
      send_to_char(NOPRIV, ch);
      return;
    }
  }

  argument = any_one_arg(argument, arg);
d236 4
a239 5
  if (!*arg) {
    sprintf(buf, "Whom do you want to expel from %s clan?\r\n",
        IS_CLAN_GOD(ch) ? "a" : "your");
    send_to_char(buf, ch);
    return;
d242 5
a246 6
  get_player(arg, &vict, &is_linkload);

  if (!vict) {
    if (!IS_CLAN_GOD(ch) && remove_player_from_clan(arg, GET_CLAN(ch))) {
      sprintf(buf, "You remove %s from the clan.", arg);
      send_to_char(buf, ch);
d248 3
a250 3
    else
      send_to_char(NOPERSON, ch);
    return;
d253 6
a258 21
  if (!GET_CLAN(vict))
    send_to_char("They're not in a clan!\r\n", ch);
  else if (!IS_CLAN_GOD(ch) && GET_CLAN(ch) != GET_CLAN(vict))
    send_to_char("They're not even in your clan!\r\n", ch);
  else if (!IS_CLAN_GOD(ch) && IS_CLAN_MEMBER(vict) &&
           GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch))
    send_to_char("You can't expel someone at or above your rank.\r\n", ch);
  else if (IS_CLAN_APPLICANT(vict))
    send_to_char("Use 'clan reject' to reject a clan applicant!\r\n", ch);
  else if (IS_CLAN_SURROGATE(vict))
    send_to_char("You can't expel someone else's alt.\r\n", ch);
  else {
    /* Redefine to be victim's clan, which may be different if ch is clan god */
    clan = find_clan_by_id(GET_CLAN(vict));
    if (clan < 0) {
      sprintf(buf, "SYSERR: %s being expelled from invalid clan %d.", 
              GET_NAME(vict), GET_CLAN(vict));
      mudlog(buf, BRF, LVL_GOD, TRUE);
      sprintf(buf, "You expel %s from invalid clan %d.",
              GET_NAME(vict), GET_CLAN(vict));
      send_to_char(buf, ch);
d260 5
a264 12
    else {
      sprintf(buf, "You expel %s from %s.\r\n", GET_NAME(vict),
              clan < 0 ? "a clan" : clans[clan].name);
      send_to_char(buf, ch);
      if (vict->desc) {
        sprintf(buf, "You have been expelled from %s!\r\n",
                clan < 0 ? "your clan" : clans[clan].name);
        send_to_char(buf, vict);
      }
      sprintf(buf, "(CLAN) %s expels %s from %s.", 
              GET_NAME(ch), GET_NAME(vict), clans[clan].name);
      mudlog(buf, CMP, LVL_GOD, FALSE);
d266 3
a268 2
    remove_player_from_clan(GET_NAME(vict), GET_CLAN(vict));
    /* remove_player_from_clan takes care of saving char */
d271 3
a273 27
  if (is_linkload)
    free_char(vict);
}


/*
 * clan who
 * clan who <clan>
 *
 * List the members and applicants of a clan.  Clan members and 
 * surrogates may only view their own clan's who list.  Clan gods
 * may view the list for any clan.
 */
void do_clan_who(struct char_data *ch, char *argument) {
  int clan_index, i;
  struct clan_record *clan;
  clan_member *member;

  if (IS_CLAN_GOD(ch)) {
    skip_spaces(&argument);
    if (!*argument) { 
      send_to_char("You must specify a clan to list the members for.\r\n", ch);
      return;
    }
    any_one_arg(argument, arg);
    if ((clan_index = find_clan(arg)) < 0) {
      send_to_char("That's not a valid clan.\r\n", ch);
a275 6
  }
  else if ((clan_index = find_clan_by_id(GET_CLAN(ch))) < 0) {
    send_to_char(NOCLAN, ch);
    return;
  }
  clan = &clans[clan_index];
d277 2
a278 5
  if (!clan->members && !clan->applicants) {
    sprintf(buf, "There's no one in %s!\r\n", clan->name);
    send_to_char(buf, ch);
    return;
  }
d280 4
a283 1
  strcpy(buf, "");
d285 8
a292 21
  if (clan->members) {
    sprintf(buf, "&3&bMembers in &0%s&0&3&b:&0\r\n\r\n", clan->name);

    for (member = clan->member_list; member; member = member->next) {
      sprintf(buf1, " %s %-10s %s\r\n",
              is_playing(member->name) ? "O" : " ",
              member->name, clan->rank[member->rank - 1]);
      strcat(buf, buf1);
    }
  }

  if (clan->applicants) {
    sprintf(buf1, "\r\n&3&bApplicants to &0%s&0\r\n\r\n", clan->name);
    strcat(buf, buf1);

    for (i = 0; i < clans->applicants; ++i) {
      sprintf(buf1, " %s %s\r\n",
              is_playing(clan->applicant[i]) ? "O" : " ",
              clan->applicant[i]);
      strcat(buf, buf1);
    }
d295 1
a295 18
  page_string(ch, buf);
}


/*
 * clan info [<clan>]
 *
 * Display information on a clan.  Clan members, surrogates, and gods 
 * can see the full information on a clan.  Others may only see public
 * information.
 */
void do_clan_info(struct char_data *ch, char *argument) {
  struct clan_record *clan;
  int i = find_clan_by_id(GET_CLAN(ch));
  bool show_full;

  skip_spaces(&argument);
  if (*argument) {
d297 2
a298 2
    if ((i = find_clan(arg)) < 0) {
      send_to_char("That's not a valid clan.\r\n", ch);
d301 3
a303 4
  }
  else if (i < 0) {
    send_to_char("Which clan do you want to look at?\r\n", ch);
    return;
d306 6
a311 136
  clan = &clans[i];

  if (GET_LEVEL(ch) > LVL_IMMORT)
    show_full = TRUE;
  else if (IS_CLAN_APPLICANT(ch))
    show_full = FALSE;
  else if (GET_CLAN(ch) == clan->id)
    show_full = TRUE;
  else
    show_full = FALSE;

  strcpy(buf, "------------------------------------------------------------------------\r\n");
  i = strlen(clan->name);
  sprintf(buf + 29 - i / 2, "[ Clan: %s ]", clan->name);
  buf[29 - i / 2 + i + 10] = '-';
  sprintf(buf, "%sNickname: &3&b%s&0   ",
          buf, clan->abbreviation);
  if (show_full)
    sprintf(buf, "%sRanks: &3&b%d&0   ",
            buf, clan->ranks);
  sprintf(buf, "%sMembers: &3&b%d&0   Power: &3&b%d&0   ",
          buf, clan->members, clan->power);
  if (show_full)
    sprintf(buf, "%sApplicants: &3&b%d&0\r\n"
                 "Treasure: &6&b%ld&0 Platinum, &3&b%ld&0 Gold, "
                   "%ld Silver, &3%ld&0 Copper\r\n"
                 "Monthly Dues: &6&b%d&0 Platinum   ",
            buf, clan->applicants,
            clan->treasure[PLATINUM], clan->treasure[GOLD],
            clan->treasure[SILVER], clan->treasure[COPPER],
            clan->dues);
  else
    strcat(buf, "\r\n");
  sprintf(buf, "%sApp Fee: &6&b%d&0 Platinum   App Level: &3&b%d&0",
          buf, clan->app_fee, clan->app_level);
  strcat(buf, "\r\n");

  if (show_full) {
    strcat(buf, "\r\nClan Ranks:\r\n");
    for (i = 0; i < clan->ranks; ++i)
      sprintf(buf, "%s%2d  %s\r\n", buf, i + 1, clan->rank[i]);


    strcat(buf, "\r\nPrivilege Ranks:\r\n");
    for (i = 0; i < NUM_CLAN_PRIVS; ++i)
      sprintf(buf, "%s%-10s %2d (%s)\r\n", buf, clan_privileges[i], 
              clan->privilege[i], clan->rank[clan->privilege[i] - 1]);
  }

  if (clan->description) {
    strcat(buf, "\r\nDescription:\r\n");
    strcat(buf, clan->description);
  }

  page_string(ch, buf);
}


/*
 * clan apply <clan>
 *
 * Apply to a clan.  Only unaffiliated players can use this command.  If
 * the player is already an applicant for another clan, their previous
 * application is retracted.
 */
void do_clan_apply(struct char_data *ch, char *argument) {
  int clan;
  char *space;

  skip_spaces(&argument);
  space = strchr(argument, ' ');
  if (space)
    space = '\0';

  if (IS_NPC(ch))
    send_to_char("NPCs can't join clans!\r\n", ch);
  else if (IS_CLAN_MEMBER(ch))
    send_to_char("You're already in a clan!\r\n", ch);
  else if (IS_CLAN_SURROGATE(ch))
    send_to_char("You're already an alt in a clan.\r\n", ch);
  else if (IS_CLAN_GOD(ch))
    send_to_char("You're a clan god, and can't join a clan.\r\n", ch);
  else if (!*argument)
    send_to_char("To which clan do you wish to apply?\r\n", ch);
  else if ((clan = find_clan(argument)) < 0)
    send_to_char("That's not a clan!\r\n", ch);
  else if (GET_PLATINUM(ch) < clans[clan].app_fee)
    send_to_char("You don't have enough platinum to join that clan.\r\n", ch);
  else if (GET_LEVEL(ch) < clans[clan].app_level) {
    sprintf(buf, "%s does not accept players beneath level %d.\r\n",
            clans[clan].name, clans[clan].app_level);
    send_to_char(buf, ch);
  }
  else {
    int old_clan;
    if (GET_CLAN(ch) && (old_clan = find_clan_by_id(GET_CLAN(ch))) >= 0) {
      if (old_clan == clan) {
        sprintf(buf, "You've already applied to %s!\r\n", clans[clan].name);
        send_to_char(buf, ch);
        return;
      }
      sprintf(buf, "You retract your application to %s and apply to %s instead.\r\n",
              clans[old_clan].name, clans[clan].name);
      remove_player_from_clan(GET_NAME(ch), GET_CLAN(ch));
    }
    else
      sprintf(buf, "You apply to %s.\r\n", clans[clan].name);
    send_to_char(buf, ch);
    /* Transfer app fee from player to clan. */
    GET_PLATINUM(ch) -= clans[clan].app_fee;
    clans[clan].treasure[PLATINUM] += clans[clan].app_fee;
    GET_CLAN(ch) = clans[clan].id;
    GET_CLAN_RANK(ch) = RANK_APPLICANT;
    clans[clan].applicants++;
    RECREATE(clans[clan].applicant, char *, clans[clan].applicants);
    clans[clan].applicant[clans[clan].applicants - 1] = strdup(GET_NAME(ch));
    save_clan(clan, REAL);
  }
}


/*
 * clan demote <member>
 *
 * Demote a member of a clan.  Clan members may only do this if they 
 * have the demote privilege and the victim is a lower rank.  Clan gods 
 * may demote a clan member in any clan.
 */
void do_clan_demote(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  struct char_data *vict;
  bool is_linkload;

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
d314 4
a317 3

    if (!HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_DEMOTE)) {
      send_to_char(NOPRIV, ch);
d320 5
d327 6
a332 65
  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Whom do you want to demote?\r\n", ch);
    return;
  }

  get_player(arg, &vict, &is_linkload);

  if (!vict) {
    send_to_char(NOPERSON, ch);
    return;
  }

  if (IS_CLAN_GOD(ch) && (clan = find_clan_by_id(GET_CLAN(vict))) < 0) {
    sprintf(buf, "%s isn't in a valid clan!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (!IS_CLAN_GOD(ch) && GET_CLAN(ch) != GET_CLAN(vict)) {
    sprintf(buf, "%s isn't even in your clan!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (IS_CLAN_SURROGATE(vict)) {
    sprintf(buf, "%s is a clan alt.  Demote %s main character instead.\r\n",
            GET_NAME(vict), HSHR(vict));
    send_to_char(buf, ch);
  }
  else if (IS_CLAN_APPLICANT(vict)) {
    sprintf(buf, "%s hasn't even been admitted into your clan yet!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (GET_CLAN_RANK(vict) == 1) {
    sprintf(buf, "%s is already the minimum rank.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (!IS_CLAN_GOD(ch) && GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch))
    send_to_char("You can't demote someone at or above your rank!\r\n", ch);
  else {
    clan_member *member;
    int i;
    struct char_data *alt;
    bool alt_linkload;

    GET_CLAN_RANK(vict)--;
    clan_set_title(vict);
    save_player_char(vict);

    for (member = clans[clan].member_list; member; member = member->next) {
      if (!str_cmp(member->name, GET_NAME(vict))) {
        member->rank = GET_CLAN_RANK(vict);
        for (i = 0; i < member->surrogates; ++i) {
          get_player(member->surrogate[i], &alt, &alt_linkload);
          if (!alt) {
            sprintf(buf, "SYSERR: Unable to find player %s who was in %s's clan surrogate list.",
                    member->surrogate[i], member->name);
            log(buf);
          }
          GET_CLAN_RANK(alt) = -GET_CLAN_RANK(vict);
          save_player_char(alt);
          if (alt_linkload)
            free_char(alt);
        }
        save_clan(clan, REAL);
        break;
      }
d334 5
a338 8

    sprintf(buf, "You demote %s to: %s\r\n",
            GET_NAME(vict), clans[clan].rank[GET_CLAN_RANK(vict) - 1]);
    send_to_char(buf, ch);
    if (vict->desc) {
      sprintf(buf, "You've been demoted in your clan to: %s\r\n",
              clans[clan].rank[GET_CLAN_RANK(vict) - 1]);
      send_to_char(buf, vict);
d340 4
a343 22
  }

  if (is_linkload)
    free_char(vict);
}


/*
 * clan promote <member>
 *
 * Promote a member of a clan.  Clan members may only do this if they 
 * have the promote privilege and the victim is a lower rank.  Clan gods 
 * may promote a clan member in any clan.
 */
void do_clan_promote(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  struct char_data *vict;
  bool is_linkload;

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
d346 3
a348 3

    if (!HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_PROMOTE)) {
      send_to_char(NOPRIV, ch);
d351 5
d358 2
a359 11
  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Whom do you want to promote?\r\n", ch);
    return;
  }

  get_player(arg, &vict, &is_linkload);

  if (!vict) {
    send_to_char(NOPERSON, ch);
d363 1
a363 1095
  if (IS_CLAN_GOD(ch) && (clan = find_clan_by_id(GET_CLAN(vict))) < 0) {
    sprintf(buf, "%s isn't in a valid clan!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (!IS_CLAN_GOD(ch) && GET_CLAN(ch) != GET_CLAN(vict)) {
    sprintf(buf, "%s isn't even in your clan!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (IS_CLAN_SURROGATE(vict)) {
    sprintf(buf, "%s is a clan alt.  Promote %s main character instead.\r\n",
            GET_NAME(vict), HSHR(vict));
    send_to_char(buf, ch);
  }
  else if (IS_CLAN_APPLICANT(vict)) {
    sprintf(buf, "%s hasn't even been admitted into your clan yet!\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (GET_CLAN_RANK(vict) == clans[clan].ranks) {
    sprintf(buf, "%s is already the maximum rank.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (!IS_CLAN_GOD(ch) && GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch))
    send_to_char("You can't promote someone at or above your rank!\r\n", ch);
  else {
    clan_member *member;
    int i;
    struct char_data *alt;
    bool alt_linkload;

    GET_CLAN_RANK(vict)++;
    clan_set_title(vict);
    save_player_char(vict);

    for (member = clans[clan].member_list; member; member = member->next) {
      if (!str_cmp(member->name, GET_NAME(vict))) {
        member->rank = GET_CLAN_RANK(vict);
        for (i = 0; i < member->surrogates; ++i) {
          get_player(member->surrogate[i], &alt, &alt_linkload);
          if (!alt) {
            sprintf(buf, "SYSERR: Unable to find player %s who was in %s's clan surrogate list.",
                    member->surrogate[i], member->name);
            log(buf);
          }
          GET_CLAN_RANK(alt) = -GET_CLAN_RANK(vict);
          if (alt_linkload)
            free_char(alt);
        }
        save_clan(clan, REAL);
        break;
      }
    }

    sprintf(buf, "You promote %s to: %s\r\n",
            GET_NAME(vict), GET_TITLE(vict));
    send_to_char(buf, ch);
    if (vict->desc) {
      sprintf(buf, "You've been promoted in your clan to: %s\r\n",
              GET_TITLE(vict));
      send_to_char(buf, vict);
    }
  }

  if (is_linkload)
    free_char(vict);
}


/*
 * clan set ...
 *
 * Clan set is a very large command used for a variety of purposes, from
 * managing clan alts to renaming clans.  It is divided into if-blocks
 * for each clan set subcommand.  Each one has a separate description.
 */
void do_clan_set(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  argument = any_one_arg(argument, arg);

  if (clan < 0 && !IS_CLAN_GOD(ch)) {
    send_to_char(NOCLAN, ch);
    return;
  }

  /*
   * There is a save_clan() call at the end of do_clan_set.
   * If you return in one of the subcommands below, be sure
   * to save the clan yourself if you need to.
   */


  /*
   * clan set alt <player>
   * clan set alt <alt> <member>
   *
   * Set or remove a clan alt.  Clan members can only set alts for 
   * themselves, and only if they have the set alt privilege.  Clan gods 
   * can set alts for any clan member.  Clan alt management can be
   * turned off entirely by undefining ALLOW_CLAN_ALTS.
   */
#ifdef ALLOW_CLAN_ALTS
  if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_ALT)) &&
     is_abbrev(arg, "alternate")) {
    clan_member *member;
    struct char_data *vict;
    bool is_linkload;

    argument = any_one_arg(argument, buf1);

    if (!*buf1) {
      send_to_char("Whom do you want to add or remove as an alt?\r\n", ch);
      return;
    }

    CAP(buf1);

    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, buf2);
      if (!*buf2) {
        send_to_char("For whom do you want to add or remove an alt?\r\n", ch);
        return;
      }
      CAP(buf2);
      get_player(buf2, &vict, &is_linkload);
      if (!vict) {
        sprintf(buf, "There's no player named %s.\r\n", buf2);
        send_to_char(buf, ch);
        return;
      }
      /* Now we know buf2 is the name of a player. */
      if ((clan = find_clan_by_id(GET_CLAN(vict))) < 0) {
        sprintf(buf, "%s isn't in a clan!\r\n", GET_NAME(vict));
        send_to_char(buf, ch);
        if (is_linkload)
          free_char(vict);
        return;
      }
      if (!IS_CLAN_MEMBER(vict)) {
        sprintf(buf, "%s isn't a full member of %s!\r\n",
                GET_NAME(vict), clans[clan].name);
        send_to_char(buf, ch);
        if (is_linkload)
          free_char(vict);
        return;
      }
      if (is_linkload)
        free_char(vict);
    }
    else
      strcpy(buf2, GET_NAME(ch));

    get_player(buf1, &vict, &is_linkload);

    for (member = clans[clan].member_list; member; member = member->next)
      if (!str_cmp(member->name, buf2))
        break;
    if (member) {
      int i;
      bool found_online = FALSE;

      /* Check and see if the victim is already an alt.  If so, remove. */
      for (i = 0; i < member->surrogates; ++i)
        if (!str_cmp(member->surrogate[i], buf1)) {
          free(member->surrogate[i]);
          for (; i < member->surrogates - 1; ++i)
            member->surrogate[i] = member->surrogate[i + 1];
          member->surrogates--;
          if (vict) {
            GET_CLAN(vict) = 0;
            GET_CLAN_RANK(vict) = 0;
            save_player_char(vict);
            send_to_char("You've been removed as a clan alt.\r\n", vict);
          }
          sprintf(buf, "You remove %s as a clan alt for %s in %s.\r\n",
                  buf1, buf2, clans[clan].name);
          send_to_char(buf, ch);
          if (is_linkload)
            free_char(vict);
          save_clan(clan, REAL);
          return;
        }

      if (!vict) {
        sprintf(buf, "There's no player named %s.\r\n", buf1);
        send_to_char(buf, ch);
        return;
      }

      if (GET_CLAN(vict)) {
        act("$N is already in a clan!", FALSE, ch, 0, vict, TO_CHAR);
        if (is_linkload)
          free_char(vict);
        return;
      }

      /*
       * The alt must be online from the same computer as the clan 
       * member to be registered as an alt.
       */
      if (IS_CLAN_GOD(ch))
        found_online = TRUE;
      else if (!is_linkload) {
        struct descriptor_data *d;
        for (d = descriptor_list; d && !found_online; d = d->next)
          if (d->character == vict || d->original == vict)
            if (ch->desc && !strcmp(d->host, ch->desc->host))
              found_online = TRUE;
      }

      if (found_online) {
        member->surrogates++;
        RECREATE(member->surrogate, char *, member->surrogates);
        member->surrogate[member->surrogates - 1] = strdup(GET_NAME(vict));
        GET_CLAN(vict) = clans[clan].id;
        GET_CLAN_RANK(vict) = -member->rank;
        sprintf(buf, "You register %s as an alt%s%s.\r\n",
                GET_NAME(vict),
                IS_CLAN_GOD(ch) ? " for " : "",
                IS_CLAN_GOD(ch) ? buf2 : "");
        send_to_char(buf, ch);
        sprintf(buf, "You are now an alt for %s in %s.\r\n",
                buf2, clans[clan].name);
        send_to_char(buf, vict);
        save_player_char(vict);
      }
      else
        send_to_char("Your alt must be online to register them with your clan.\r\n", ch);
    }
    else {
      send_to_char("Invalid clan record.  Tell a god.\r\n", ch);
      sprintf(buf, "SYSERR: %s tried to add a clan alt (%s) for %s, "
                   "but %s was not found in clan %d's member list.",
              GET_NAME(ch), GET_NAME(vict), buf2, buf2, clans[clan].id);
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }

    if (is_linkload)
      free_char(vict);
  }
  else
#endif

  /*
   * clan set title <rank> <title>
   * clan set title <rank> <clan> <title>
   *
   * Set the title for a clan rank.  Clan members may only do this if 
   * they have the set clan rank title privilege.  A clan member cannot
   * set the title for a rank above their own.  Clan gods can set the
   * title for any rank in any clan.
   */
  if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_TITLE)) &&
      is_abbrev(arg, "title")) {
    int rank;
    clan_member *member;
    struct char_data *vict;
    bool is_linkload;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("For which rank do you want to set a title?\r\n", ch);
      return;
    }
    rank = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set a title?\r\n", ch);
        return;
      }
    }
    skip_spaces(&argument);
    if (rank <= 0 || rank > clans[clan].ranks) {
      sprintf(buf, "%s only has %d ranks.\r\n", clans[clan].name, clans[clan].ranks);
      send_to_char(buf, ch);
      return;
    }
    if (!IS_CLAN_GOD(ch) && rank > GET_CLAN_RANK(ch)) {
      send_to_char("You cannot set the title for a rank above your own.\r\n", ch);
      return;
    }
    if (strlen(strip_ansi(argument)) > 30) {
      send_to_char("Clan titles may be at most 30 characters long.\r\n", ch);
      return;
    }
    sprintf(buf1, "%s&0", argument);
    free(clans[clan].rank[rank - 1]);
    clans[clan].rank[rank - 1] = strdup(buf1);
    sprintf(buf, "Rank %d's title is now: %s\r\n", rank, buf1);
    send_to_char(buf, ch);

    for (member = clans[clan].member_list; member; member = member->next)
      if (member->rank == rank) {
        get_player(member->name, &vict, &is_linkload);
        if (vict) {
          clan_set_title(vict);
          save_player_char(vict);
          if (is_linkload)
            free_char(vict);
        }
      }
  }

  /*
   * clan set <privilege> <rank>
   * clan set <privilege> <rank> <clan>
   *
   * Set the rank for a particular privilege.  Only clan members who 
   * are at the maximum rank in their clan can use this subcommand.
   * Clan gods can set the rank for a privilege in any clan.
   */
  else if ((IS_CLAN_GOD(ch) || IS_CLAN_LEADER(ch, clan)) &&
           is_abbrev(arg, "privilege")) {
    int priv, rank;
    argument = one_argument(argument, arg);
    for (priv = 0; priv < NUM_CLAN_PRIVS; ++priv)
      if (is_abbrev(arg, clan_privileges[priv]))
        break;
    if (priv >= NUM_CLAN_PRIVS) {
      send_to_char("That is not a valid privilege.\r\n", ch);
      return;
    }
    argument = one_argument(argument, arg);
    if (!is_number(arg)) {
      send_to_char("What rank do you want to set that privilege to?\r\n", ch);
      return;
    }
    rank = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set a privilege?\r\n", ch);
        return;
      }
    }
    if (rank <= 0 || rank > clans[clan].ranks) {
      sprintf(buf, "%s only has %d ranks.\r\n", clans[clan].name, clans[clan].ranks);
      send_to_char(buf, ch);
      return;
    }
    clans[clan].privilege[priv] = rank;
    sprintf(buf, "Set the privilege %s to rank %d for %s.\r\n",
            clan_privileges[priv], rank,
            IS_CLAN_GOD(ch) ? clans[clan].abbreviation : "the clan");
    send_to_char(buf, ch);
  }

  /*
   * clan set appfee <platinum>
   * clan set appfee <platinum> <clan>
   *
   * Set the application fee (in platinum pieces) to apply to a clan.
   * Clan members with the set app fee privilege may do this for their
   * own clan.  Clan gods can do this for any clan.
   */
  else if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_APP_FEE)) &&
           is_abbrev(arg, "appfee")) {
    int app_fee;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("How much platinum should the clan's application fee be?\r\n", ch);
      return;
    }
    app_fee = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set the application fee?\r\n", ch);
        return;
      }
    }
    if (app_fee < 0) {
      send_to_char("You can't have a negative application fee.\r\n", ch);
      return;
    }
    clans[clan].app_fee = app_fee;
    sprintf(buf, "%s's application fee is now %d platinum.\r\n", clans[clan].name, app_fee);
    send_to_char(buf, ch);
  }

  /*
   * clan set applev <level>
   * clan set applev <level> <clan>
   *
   * Set the minimum application level for a clan.  Clan members with 
   * the set app level privilege may do this for their own clan.  Clan
   * gods can do this for any clan.
   */
  else if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_APP_LEV)) &&
           is_abbrev(arg, "applev")) {
    int app_level;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("What should the clan's minimum application level be?\r\n", ch);
      return;
    }
    app_level = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set the application level?\r\n", ch);
        return;
      }
    }
    if (app_level < 0 || app_level > LVL_IMMORT) {
      send_to_char("The application level must be between 0 and 100.\r\n", ch);
      return;
    }
    clans[clan].app_level = app_level;
    sprintf(buf, "%s's minimum application level is now %d.\r\n",
            clans[clan].name, app_level);
    send_to_char(buf, ch);
  }

  /*
   * clan set dues <platinum>
   * clan set dues <platinum> <clan>
   *
   * Set the monthly dues for a clan.  Clan members with the set dues 
   * privilege may change this value for their own clan.  Clan gods may
   * set this value for any clan.
   */
  else if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_DUES)) &&
           is_abbrev(arg, "dues")) {
    int dues;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("How much platinum should the clan's monthly dues be?\r\n", ch);
      return;
    }
    dues = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set the monthly dues?\r\n", ch);
        return;
      }
    }
    if (dues < 0) {
      send_to_char("The monthly dues cannot be negative.\r\n", ch);
      return;
    }
    clans[clan].dues = dues;
    sprintf(buf, "%s's monthly dues is now %d platinum.\r\n", clans[clan].name, dues);
    send_to_char(buf, ch);
  }

  /*
   * clan set description
   * clan set description <clan>
   *
   * Edit the description for a clan using the line editor.  Clan 
   * members with the set desc privilege can do this for their own clan.
   * Clan gods can edit the description for any clan.
   */
  else if ((IS_CLAN_GOD(ch) || HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_SET_DESC)) &&
           is_abbrev(arg, "description")) {
    if (!ch->desc)
      return;
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("Which clan's description do you want to edit?\r\n", ch);
        return;
      }
    }
    sprintf(buf, "Edit %s's description.  (/s saves /h for help)\r\n\r\n",
            IS_CLAN_GOD(ch) ? clans[clan].name : "your clan");
    send_to_char(buf, ch);
    act("$n starts editing a clan description.", TRUE, ch, 0, 0, TO_ROOM);
    SET_FLAG(PLR_FLAGS(ch), PLR_WRITING);
    STATE(ch->desc) = CON_CLAN_DESC_EDIT;
    string_write(ch->desc, &clans[clan].description, MAX_CLAN_DESC_LENGTH);
    ch->desc->clan_id = clans[clan].id;
  }

  /*
   * clan set ranks <ranks>
   * clan set ranks <ranks> <clan>
   *
   * Set the number of ranks in a clan.  Clan gods and clan members of 
   * the maximum rank in their clan can do this.  If the user increases
   * the number of ranks in a clan, the leader title is shifted up, and
   * any members at the max rank are moved up to the new maximum rank.
   * If the number of ranks is decreased, titles are shifted downwards,
   * and all members have their rank decremented, but not below 1.
   */
  else if ((IS_CLAN_GOD(ch) || IS_CLAN_LEADER(ch, clan)) &&
           is_abbrev(arg, "ranks")) {
    int ranks, i;
    char *leader_title;
    clan_member *member;
    struct char_data *vict;
    bool is_linkload;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("How many ranks should the clan have?\r\n", ch);
      return;
    }
    ranks = atoi(arg);
    if (IS_CLAN_GOD(ch)) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("For which clan do you want to set the number of ranks?\r\n", ch);
        return;
      }
    }
    if (ranks <= 0 || ranks > 100) {
      send_to_char("The number of ranks must be between 1 and 100, inclusive\r\n", ch);
      return;
    }
    if (ranks == clans[clan].ranks) {
      send_to_char("The clan already has that many ranks.\r\n", ch);
      return;
    }
    leader_title = clans[clan].rank[clans[clan].ranks - 1];
    if (ranks > clans[clan].ranks) {
      /*
       * Adding ranks.  Add them right below the leader rank.
       */
      RECREATE(clans[clan].rank, char *, ranks);
      /* Preserve leader title. */
      clans[clan].rank[ranks - 1] = clans[clan].rank[clans[clan].ranks - 1];
      for (i = clans[clan].ranks - 1; i < ranks - 1; ++i)
        clans[clan].rank[i] = strdup("New Rank");
      /*
       * Move anyone who was a leader to the new leader rank.
       */
      for (member = clans[clan].member_list; member; member = member->next)
        if (member->rank == clans[clan].ranks) {
          member->rank = ranks;
          get_player(member->name, &vict, &is_linkload);
          if (vict) {
            GET_CLAN_RANK(vict) = ranks;
            clan_set_title(vict);
            save_player_char(vict);
            if (is_linkload)
              free_char(vict);
          }
        }
      /*
       * Adjust any privileges that were leader-only before.
       */
      for (i = 0; i < NUM_CLAN_PRIVS; ++i)
        if (clans[clan].privilege[i] == clans[clan].ranks)
          clans[clan].privilege[i] = ranks;
      clans[clan].ranks = ranks;
    }
    else {
      /*
       * Removing ranks.
       */
      for (i = ranks - 1; i < clans[clan].ranks - 1; ++i)
        free(clans[clan].rank[i]);
      /* Preserve leader title. */
      clans[clan].rank[ranks - 1] = clans[clan].rank[clans[clan].ranks - 1];
      i = clans[clan].ranks - ranks;
      clans[clan].ranks = ranks;
      /*
       * Shift everyone's rank down, but not below rank 1.
       */
      for (member = clans[clan].member_list; member; member = member->next) {
        if (member->rank == 1)
          continue;
        member->rank = MAX(member->rank - i, 1);
        /*
         * Retitle clan member.
         */
        get_player(member->name, &vict, &is_linkload);
        if (vict) {
          GET_CLAN_RANK(vict) = ranks;
          clan_set_title(vict);
          save_player_char(vict);
          if (is_linkload)
            free_char(vict);
        }
      }
      /*
       * Adjust privileges.
       */
      for (i = 0; i < NUM_CLAN_PRIVS; ++i)
        clans[clan].privilege[i] = MIN(clans[clan].privilege[i], clans[clan].ranks);
    }
    sprintf(buf, "%s now has %d ranks.\r\n", clans[clan].name, ranks);
    send_to_char(buf, ch);
    sprintf(buf, "(CLAN) %s changes %s's number of ranks to %d.", 
            GET_NAME(ch), clans[clan].name, ranks);
    mudlog(buf, NRM, LVL_GOD, TRUE);
  }

  /*
   * clan set name <clan> <name>
   *
   * Rename a clan.  Only clan gods can use this function.
   */
  else if (IS_CLAN_GOD(ch) && is_abbrev(arg, "name")) {
    argument = any_one_arg(argument, arg);
    if ((clan = find_clan(arg)) < 0) {
      send_to_char("Which clan do you want to rename?\r\n", ch);
      return;
    }
    skip_spaces(&argument);
    if (strlen(strip_ansi(argument)) > 30) {
      send_to_char("Clan names can be at most 30 characters long.\r\n", ch);
      return;
    }
    sprintf(buf1, "%s&0", argument);
    if (find_clan_by_name(buf1) != -1) {
      send_to_char("A clan with that name already exists!\r\n", ch);
      return;
    }
    sprintf(buf, "%s is now named %s.\r\n", clans[clan].name, buf1);
    send_to_char(buf, ch);
    sprintf(buf, "(CLAN) %s renames %s to %s.",
            GET_NAME(ch), clans[clan].name, buf1);
    mudlog(buf, NRM, LVL_GOD, TRUE);
    free(clans[clan].name);
    clans[clan].name = strdup(buf1);
  }

  /*
   * clan set abbreviation <clan> <new abbr>
   *
   * Change a clan's abbreviation.  Only clan gods can use this 
   * function.  Changing a clan's abbreviation causes its members
   * titles to be refreshed.
   */
  else if (IS_CLAN_GOD(ch) && is_abbrev(arg, "abbreviation")) {
    argument = any_one_arg(argument, arg);
    if ((clan = find_clan(arg)) < 0) {
      send_to_char("Which clan do you want to rename?\r\n", ch);
      return;
    }
    skip_spaces(&argument);    
    if (strlen(strip_ansi(argument)) > 10) {
      send_to_char("Clan abbreviations can be at most 10 characters long.\r\n", ch);
      return;
    }
    sprintf(buf1, "%s&0", argument);
    if (find_clan_by_abbr(buf1) != -1) {
      send_to_char("A clan with that abbreviation already exists!\r\n", ch);
      return;
    }
    sprintf(buf, "%s is now abbreviated %s.\r\n", clans[clan].name, buf1);
    send_to_char(buf, ch);
    sprintf(buf, "(CLAN) %s sets %s's abbreviation to %s.",
            GET_NAME(ch), clans[clan].name, buf1);
    mudlog(buf, NRM, LVL_GOD, TRUE);
    free(clans[clan].abbreviation);
    clans[clan].abbreviation = strdup(buf1);
    refresh_clan_member_titles(clan);
  }

  else {
    do_clan(ch, "", 0, 0); /* Clan command with no arg shows command list */
    return; /* Don't save clan below. */
  }

  save_clan(clan, REAL);
}


/*
 * clan snoop <clan>
 * clan snoop off
 * clan snoop all
 *
 * Snoop a clan's channel.  This clan command is closely tied to clan 
 * tell.
 */
void do_clan_snoop(struct char_data *ch, char *argument) {
  if (!IS_CLAN_GOD(ch)) {
    send_to_char("Only clan gods can snoop clan channels.\r\n", ch);
    return;
  }

  skip_spaces(&argument);

  if (!*argument) {
    if (ch->clan_snoop == CLAN_SNOOP_OFF)
      send_to_char("You are not currently snooping any clan channels.\r\n", ch);
    else {
      int clan = find_clan_by_id(ch->clan_snoop);
      sprintf(buf, "You are currently snooping %s.\r\n",
              ch->clan_snoop == CLAN_SNOOP_ALL ? "all clan channels" : 
              clan < 0 ? "an invalid clan" : clans[clan].name);
      send_to_char(buf, ch);
    }
  }
  else if (is_abbrev(argument, "off")) {
    ch->clan_snoop = CLAN_SNOOP_OFF;
    send_to_char("You are no longer snooping any clan channels.\r\n", ch);
  }
  else if (is_abbrev(argument, "all")) {
    ch->clan_snoop = CLAN_SNOOP_ALL;
    send_to_char("You are now snooping all clan channels.\r\n", ch);
  }
  else {
    int clan = find_clan(argument);
    if (clan < 0)
      send_to_char("That's not a valid clan.\r\n", ch);
    else {
      ch->clan_snoop = clans[clan].id;
      sprintf(buf, "You are now snooping %s.\r\n", clans[clan].name);
      send_to_char(buf, ch);
    }
  }
}


/*
 * clan create <abbreviation>
 *
 * Create a new clan with the given abbreviation.  The new clan's name 
 * is also set to abbreviation, and must be changed using clan set.
 * The new clan will have two ranks, Member and Leader.
 */
void do_clan_create(struct char_data *ch, char *argument) {
  struct clan_record *clan;
  int i, max;
  char *space;

  if (!IS_CLAN_GOD(ch)) {
    send_to_char("You are not mighty enough to create new clans!\r\n", ch);
    return;
  }

  /* Keep only the first word of the argument. */
  skip_spaces(&argument);
  space = strchr(argument, ' ');
  if (space)
    space = '\0';

  if (!*argument) {
    send_to_char("What is the abbreviation for the new clan?\r\n", ch);
    return;
  }

  if (strlen(strip_ansi(argument)) >= 10) {
    send_to_char("Clan abbreviations can be at most 10 characters long.\r\n", ch);
    return;
  }

  sprintf(buf1, "%s&0", argument);

  if (find_clan_by_abbr(buf1) != -1) {
    send_to_char("A clan with that abbreviation already exists!\r\n", ch);
    return;
  }

  RECREATE(clans, struct clan_record, num_of_clans + 2);
  clan = &clans[num_of_clans];
  ++num_of_clans;

  for (max = i = 0; i < num_of_clans - 1; ++i)
    max = MAX(max, clans[i].id);
  clan->id = max + 1;
  clan->name = strdup(buf1);
  clan->abbreviation = strdup(buf1);
  clan->description = NULL;
  
  clan->dues = 0;
  clan->app_fee = 0;
  clan->app_level = 0;
  clan->power = 0;
  for (i = 0; i < NUM_COIN_TYPES; ++i)
    clan->treasure[i] = 0;
  for (i = 0; i < NUM_CLAN_PRIVS; ++i)
    clan->privilege[i] = 2;

  clan->ranks = 2;
  CREATE(clan->rank, char *, 2);
  clan->rank[0] = strdup("Member");
  clan->rank[1] = strdup("Leader");

  clan->members = 0;
  clan->member_list = NULL;
  clan->applicants = 0;
  clan->applicant = 0;

  send_to_char("New clan created.\r\n", ch);
  sprintf(buf, "(CLAN) %s created new clan: %s", GET_NAME(ch), buf1);
  mudlog(buf, BRF, LVL_GOD, TRUE);

  save_clan(num_of_clans - 1, REAL);

}

/*
 * clan destroy <clan id>
 *
 * Destroy a clan permanently, removing all players associated with it 
 * from the clan system.
 */
void do_clan_destroy(struct char_data *ch, char *argument) {
  int clan, i;
  struct char_data *vict;
  bool is_linkload;
  clan_member *member;

  if (!IS_CLAN_GOD(ch)) {
    send_to_char("You are not mighty enough to destroy a clan.\r\n", ch);
    return;
  }

  skip_spaces(&argument);
  if ((clan = find_clan_by_id(atoi(argument))) < 0) {
    send_to_char("You must specify the numerical ID of the clan you wish to destroy.\r\n", ch);
    return;
  }

  for (i = 0; i < clans[clan].applicants; ++i) {
    get_player(clans[clan].applicant[i], &vict, &is_linkload);
    if (vict) {
      GET_CLAN_RANK(vict) = 0;
      GET_CLAN(vict) = 0;
      if (vict->desc) {
        sprintf(buf, "The clan you applied for, %s, has been disbanded.\r\n", clans[clan].name);
        send_to_char(buf, vict);
      }
      if (is_linkload)
        free_char(vict);
    }
  }

  for (member = clans[clan].member_list; member; member = member->next) {
    get_player(member->name, &vict, &is_linkload);
    if (vict) {
      GET_CLAN_RANK(vict) = 0;
      GET_CLAN(vict) = 0;
      clan_set_title(vict);
      if (vict->desc)
        send_to_char("Your clan has been disbanded!\r\n", ch);
      if (is_linkload)
        free_char(vict);
    }
    for (i = 0; i < member->surrogates; ++i) {
      get_player(member->surrogate[i], &vict, &is_linkload);
      if (vict) {
        GET_CLAN_RANK(vict) = 0;
        GET_CLAN(vict) = 0;
        if (vict->desc)
          send_to_char("Your clan has been disbanded!\r\n", ch);
        if (is_linkload)
          free_char(vict);
      }
    }
  }

  sprintf(buf, "You have deleted the clan %s.\r\n", clans[clan].name);
  send_to_char(buf, ch);
  sprintf(buf, "(CLAN) %s has destroyed the clan %s.", GET_NAME(ch), clans[clan].name);
  mudlog(buf, BRF, LVL_GOD, TRUE);

  delete_clan(clan);
}


/*
 * clan tell [#<rank>] <message>
 * clan tell <clan> [#<rank>] <message>
 *
 * Send a message to all members and surrogates of a clan.  Clan members
 * and surrogates can only send and hear the channel of their own clan.
 * Clan gods may snoop any clan or all clans.  When snooping all clans,
 * a clan god must specify which clan to send tells to, but when only
 * snooping one clan, clan tells are automatically sent to that one.
 */
void do_clan_tell(struct char_data *ch, char *argument) {
  struct descriptor_data *d;
  int clan;
  int min_rank = 1;
  char rank_string[12] = "";

  skip_spaces(&argument);

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    send_to_char("Your lips move, but no sound forms.\r\n", ch);
    return;
  }

  if (!speech_ok(ch, 0))
    return;

  if (IS_CLAN_GOD(ch)) {
    if (ch->clan_snoop == CLAN_SNOOP_OFF) {
      send_to_char("You must be clan snooping first.\r\n", ch);
      return;
    }
    else if (ch->clan_snoop == CLAN_SNOOP_ALL) {
      argument = any_one_arg(argument, arg);
      if ((clan = find_clan(arg)) < 0) {
        send_to_char("That's not a valid clan.\r\n", ch);
        return;
      }
    }
    else if ((clan = find_clan_by_id(ch->clan_snoop)) < 0) {
      send_to_char("You're snooping an invalid clan channel.\r\n", ch);
      return;
    }
  }
  else if (GET_CLAN_RANK(ch) == RANK_APPLICANT ||
           (clan = find_clan_by_id(GET_CLAN(ch))) < 0) {
    send_to_char("You're not part of a clan.\r\n", ch);
    return;
  }

  skip_spaces(&argument);
  if (*argument == '#') {
    ++argument;
    argument = any_one_arg(argument, arg);
    if (!is_number(arg)) {
      send_to_char("What minimum rank do you want to broadcast to?\r\n", ch);
      return;
    }
    min_rank = atoi(arg);
    if (min_rank > clans[clan].ranks) {
      send_to_char("No one has a clan rank high enough to hear you!\r\n", ch);
      return;
    }
    sprintf(rank_string, " (rank %d)", min_rank);
  }

  skip_spaces(&argument);
  if (!*argument) {
    send_to_char("What do you want to tell the clan?\r\n", ch);
    return;
  }

  argument = makedrunk(argument, ch);

  if (IS_CLAN_GOD(ch))
    sprintf(buf, "&5You tell %s&0&5%s, '&b%s&0&5'&0\r\n",
            clans[clan].name, rank_string, argument);
  else
    sprintf(buf, "&5You tell your clan%s, '&b%s&0&5'&0\r\n",
            rank_string, argument);
  send_to_char(buf, ch);

  for (d = descriptor_list; d; d = d->next){
    if (!IS_PLAYING(d))
      continue;
    if (!d->character || d->character == ch)
      continue;
    if (STATE(d) != CON_PLAYING ||
        PLR_FLAGGED(d->character, PLR_WRITING) || 
        PLR_FLAGGED(d->character, PLR_MAILING) ||
        EDITING(d))
      if (!PRF_FLAGGED(d->character, PRF_OLCCOMM))
        continue;
    if (PRF_FLAGGED(d->character, PRF_NOCTELL))
      continue;
    if (IS_CLAN_GOD(d->character)) {
      if (d->character->clan_snoop == clans[clan].id ||
          d->character->clan_snoop == CLAN_SNOOP_ALL) {
        sprintf(buf, "&5%s tells &0%s&0&5, '&b%s&0&5'&0\r\n",
                IS_CLAN_GOD(ch) && GET_INVIS_LEV(ch) > GET_LEVEL(d->character) ?
                "Someone" : GET_NAME(ch), clans[clan].abbreviation, argument);
        send_to_char(buf, d->character);
      }
    }
    else if (GET_CLAN(REAL_CHAR(d->character)) == clans[clan].id &&
             abs(GET_CLAN_RANK(REAL_CHAR(d->character))) >= min_rank) {
      sprintf(buf, "&5%s tells your clan%s, '&b%s&0&5'&0\r\n",
              IS_CLAN_GOD(ch) && GET_INVIS_LEV(ch) > GET_LEVEL(d->character) ?
              "Someone" : GET_NAME(ch), rank_string, argument);
      send_to_char(buf, d->character);
    }
  }
}

ACMD(do_ctell)
{
  do_clan_tell(ch, argument);
}


/*
 * clan status
 * clan status <player>
 *
 * View information about one's membership in a clan.  Clan gods may 
 * view the clan status for other players.
 */
void do_clan_status(struct char_data *ch, char *argument) {
  int clan;
  struct char_data *tch;
  bool is_linkload = FALSE;

  skip_spaces(&argument);
  if (IS_CLAN_GOD(ch) && *argument) {
    argument = any_one_arg(argument, arg);
    get_player(arg, &tch, &is_linkload);
    if (!tch) {
      send_to_char("There is no player by that name.\r\n", ch);
      return;
    }
  }
  else
    tch = ch;

  clan = find_clan_by_id(GET_CLAN(tch));

  if (IS_CLAN_GOD(tch)) {
    if (tch == ch)
      send_to_char("You are a clan god.\r\n", ch);
    else
      act("$N is a clan god.", FALSE, ch, 0, tch, TO_CHAR);
  }
  else if (!GET_CLAN(tch)) {
    if (tch == ch)
      send_to_char("You are not in a clan.\r\n", ch);
    else
      act("$N is not in a clan.", FALSE, ch, 0, tch, TO_CHAR);
  }
  else if (clan < 0) {
    if (tch == ch)
      send_to_char("You are in an invalid clan.\r\n", ch);
    else
      act("$N is in an invalid clan.\r\n", FALSE, ch, 0, tch, TO_CHAR);
  }
  else if (IS_CLAN_APPLICANT(tch)) {
    sprintf(buf, "%s %s currently applying to %s.\r\n", 
            tch == ch ? "You" : GET_NAME(tch),
            tch == ch ? "are" : "is",
            clans[clan].name);
    send_to_char(buf, ch);
  }
  else if (IS_CLAN_SURROGATE(tch)) {
    sprintf(buf, "%s %s a clan alt (rank %d) in %s.\r\n",
            tch == ch ? "You" : GET_NAME(tch),
            tch == ch ? "are" : "is",
            -GET_CLAN_RANK(tch), clans[clan].name);
    send_to_char(buf, ch);
  }
  else {
    int i, privileges = 0, priv = 0, line = 0;
    clan_member *member;

    sprintf(buf, "Clan:       %s\r\n"
                 "Rank:       %s (rank %d)\r\n",
            clans[clan].name,
            clans[clan].rank[GET_CLAN_RANK(tch) - 1], GET_CLAN_RANK(tch));
    send_to_char(buf, ch);

    /* Does member have any privileges */
    for (i = 0; i < NUM_CLAN_PRIVS; ++i)
      if (GET_CLAN_RANK(tch) >= clans[clan].privilege[i])
        ++privileges;

    /* Print out privilege list. */
    if (privileges) {
      strcpy(buf, "Privileges:");
      line = 11; /* length of "Privileges:" */
      for (priv = i = 0; i < NUM_CLAN_PRIVS; ++i)
        if (GET_CLAN_RANK(tch) >= clans[clan].privilege[i]) {
          ++priv;
          /* Determine if the next privilege can fit on this line. */
          line += 1 + strlen(clan_privileges[i]) + (priv < privileges ? 1 : 0);
          if (line > 79) {
            strcat(buf, "\r\n           ");
            line = 11; /* indentation length of "Privileges:" */
            line += 1 + strlen(clan_privileges[i]) + (priv < privileges ? 1 : 0);
          }
          sprintf(buf, "%s %s%s", buf,
                  clan_privileges[i],
                  priv < privileges ? "," : "");
        }
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
    }

    /* Print out surrogate list */
    for (member = clans[clan].member_list; member; member = member->next)
      if (!str_cmp(member->name, GET_NAME(tch))) {
        if (member->surrogates) {
          strcpy(buf, "Surrogates:");
          line = 11; /* length of "Surrogates:" */
          for (i = 0; i < member->surrogates; ++i) {
            line += 1 + strlen(member->surrogate[i]) + (priv < privileges ? 1 : 0);
            if (line > 79) {
              strcat(buf, "\r\n           ");
              line = 11; /* indentation length of "Surrogates:" */
              line += 1 + strlen(member->surrogate[i]) + (priv < privileges ? 1 : 0);
            }
            sprintf(buf, "%s %s%s", buf, member->surrogate[i],
                    i < member->surrogates - 1? "," : "");
          }
          strcat(buf, "\r\n");
          send_to_char(buf, ch);
        }
        break;
      }
  }

  if (is_linkload)
    free_char(tch);
a365 17
/*
 * clan reject <player>
 *
 * Reject someone's application to a clan.  Clan gods or clan members 
 * with the enroll privilege may do this.  
 */
void do_clan_reject(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  int vict_clan;
  bool is_linkload;
  struct char_data *vict;

  if (!IS_CLAN_GOD(ch)) {
    if (clan < 0) {
      send_to_char(NOCLAN, ch);
      return;
    }
d367 4
a370 5
    if (!HAS_CLAN_PRIV(ch, clan, CLAN_PRIV_ENROLL)) {
      send_to_char(NOPRIV, ch);
      return;
    }
  }
d375 1
a375 1
    send_to_char("Whose application do you want to reject?\r\n", ch);
d379 21
a399 5
  get_player(arg, &vict, &is_linkload);

  if (!vict) {
    send_to_char(NOPERSON, ch);
    return;
d402 11
a412 16
  vict_clan = find_clan_by_id(GET_CLAN(vict));

  if ((vict_clan == clan || IS_CLAN_GOD(ch)) && 
      (vict_clan >= 0 && IS_CLAN_APPLICANT(vict))) {
    /* Remove as applicant. */
    remove_player_from_clan(GET_NAME(vict), GET_CLAN(vict));
    sprintf(buf, "You reject %s's application to %s!\r\n",
            GET_NAME(vict), clans[vict_clan].name);
    send_to_char(buf, ch);
    sprintf(buf, "Your application to %s has been rejected!\r\n",
            clans[vict_clan].name);
    send_to_char(buf, vict);
    sprintf(buf, "(CLAN) %s rejects %s's application to %s.", 
            GET_NAME(ch), GET_NAME(vict), clans[vict_clan].name);
    mudlog(buf, CMP, LVL_GOD, TRUE);
  }   
d414 24
a437 3
    sprintf(buf, "%s isn't even applying to %s clan!\r\n",
            GET_NAME(vict), IS_CLAN_GOD(ch) ? "a" : "your");
    send_to_char(buf, ch);
a438 3

  if (is_linkload)
    free_char(vict);
d442 7
a448 7
/*
 * clan quit
 *
 * Revoke one's membership in a clan.
 */
void do_clan_quit(struct char_data *ch, char *argument) {
  int clan = find_clan_by_id(GET_CLAN(ch));
d450 3
a452 2
  if (clan < 0) {
    send_to_char(NOCLAN, ch);
d456 5
a460 5
#ifdef ALLOW_CLAN_QUIT
  argument = any_one_arg(argument, arg);
  if (!*arg || str_cmp(arg, "yes")) {
    send_to_char("You must confirm your action with 'clan quit yes'.\r\n", ch);
    return;
d463 2
a464 10
  if (IS_CLAN_APPLICANT(ch))
    sprintf(buf, "You are no longer applying to %s.\r\n", clans[clan].name);
  else if (IS_CLAN_SURROGATE(ch))
    sprintf(buf, "You are no longer a clan alt in %s.\r\n", clans[clan].name);
  else if (IS_CLAN_MEMBER(ch))
    sprintf(buf, "You are no longer a member in %s.\r\n", clans[clan].name);
  send_to_char(buf, ch);
  sprintf(buf, "(CLAN) %s quits %s.", 
          GET_NAME(ch), clans[clan].name);
  mudlog(buf, CMP, LVL_GOD, TRUE);
d466 9
a474 4
  remove_player_from_clan(GET_NAME(ch), GET_CLAN(ch));
#else
  send_to_char("This action is not currently allowed.\r\n", ch);
#endif
d478 49
a526 7
/*
 * Go through a clan and re-set the titles for all its members.
 */
void refresh_clan_member_titles(int clan_index) {
  struct char_data *vict;
  bool is_linkload;
  clan_member *member;
d528 1
a528 7
  for (member = clans[clan_index].member_list; member; member = member->next) {
    get_player(member->name, &vict, &is_linkload);
    if (vict) {
      clan_set_title(vict);
      if (is_linkload)
        free_char(vict);
    }
d530 1
a532 11
/*
 * Get the index for a clan by searching on clan id.
 */
int find_clan_by_id(int clan_id)
{
  int i;
  for (i = 0; i < num_of_clans; ++i)
    if (clan_id == clans[i].id)
      return i;
  return (-1);
}
d534 1
a534 4
/*
 * Get the index for a clan by searching on clan name.
 */
int find_clan_by_name(const char *name)
d536 2
a537 6
  int i;
  for (i = 0; i < num_of_clans; i++)
    if (!str_cmp(name, clans[i].name))
      return i;
  return -1;
}
d539 1
a539 11
/*
 * Get the index for a clan by searching on clan abbreviation.
 */
int find_clan_by_abbr(const char *abbr)
{
  int i;
  for (i = 0; i < num_of_clans; i++)
    if (!str_cmp(abbr, clans[i].abbreviation))
      return i;
  return -1;
}
d541 24
a564 13
/*
 * Get the clan index for a clan by searching on clan id if
 * passed a number, or abbreviation and then name otherwise.
 */
int find_clan(const char *id)
{
  int i, j;
  if (is_number(id))
    return find_clan_by_id(atoi(id));
  for (i = 0; i < num_of_clans; ++i) {
    for (j = 0; clans[i].abbreviation[j]; ++j)
      if (is_abbrev(id, clans[i].abbreviation + j))
        return i;
d566 3
a568 4
  for (i = 0; i < num_of_clans; ++i) {
    for (j = 0; clans[i].name[j]; ++j)
      if (is_abbrev(id, clans[i].name + j))
        return i;
d570 25
a594 1
  return -1;
d598 1
a598 4
/*
 * Initialize the clan system by loading all clan files.
 */
void init_clans()
d600 7
a606 2
  FILE *fl;
  char clan_id[16];
d608 3
a610 129
  /*
   * Legacy-checking code.  If we successfully open the file, that means
   * it is not a directory, and is probably the binary format from the 
   * old clan system.  In this case, back it up with a .old extension.
   */
  if ((fl = fopen(CLAN_PREFIX, "r"))) {
    rename(CLAN_PREFIX, CLAN_PREFIX ".old");
    fclose(fl);
    /*
     * This is a POSIX-only.  Create the new clan directory.
     */
    log("Backed-up old clans file and creating new clan directory.");
    mkdir(CLAN_PREFIX, 0775);
  }

  if (!(fl = fopen(CLAN_INDEX_FILE, "r"))) {
    log("No clan index.  Creating a new one.");
    touch(CLAN_INDEX_FILE);
    if (!(fl = fopen(CLAN_INDEX_FILE, "r"))) {
      perror("fatal error opening clan index");
      exit(1);
    }
  }

  num_of_clans = 0;
  while (fgets(clan_id, 16, fl))
    ++num_of_clans;
  CREATE(clans, struct clan_record, num_of_clans + 1);

  rewind(fl);

  num_of_clans = 0;
  while (fgets(clan_id, 16, fl)) {
    clan_id[strlen(clan_id) - 1] = '\0'; /* remove the \n */
    if (load_clan(clan_id, num_of_clans))
      ++num_of_clans;
  }

  sprintf(buf, "%d clans loaded.", num_of_clans);
  log(buf);

  fclose(fl);
}

/*
 * Load a clan with the given number (as a string) into the clan
 * array at the given index position.
 */
bool load_clan(char *clan_num, int clan_index) {
  FBFILE *fl;
  char filename[40];
  char tag[128];
  char *line;
  int num, id;
  struct clan_record *clan = &clans[clan_index];
  clan_member *member;

  sprintf(filename, "%s/%s%s", CLAN_PREFIX, clan_num, CLAN_SUFFIX);

  if (!(fl = fbopen(filename, FB_READ))) {
    sprintf(buf, "Couldn't open clan file '%s'", filename);
    log(buf);
    return FALSE;
  }

  /* Initialize fields */
  clan->applicants = 0;
  clan->members = 0;
  clan->ranks = 0;
  clan->power = 0;
  for (num = 0; num < NUM_CLAN_PRIVS; ++num)
    clan->privilege[num] = 1;

  /* Tag-based ASCII file parser. */
  while (fbgetline(fl, buf1)) {
    tag_argument(buf1, tag);
    num = atoi(buf1);
    line = buf1;

    switch (*tag) {
    case 'A':
           if (TAG_IS("ALvl"))          clan->app_level = num;
      else if (TAG_IS("Abbr")) {
        char *space = strchr(line, ' ');
        if (space)
          space = '\0';
        clan->abbreviation = strdup(line);
      }
      else if (TAG_IS("Appl")) {
        if (clan->applicant)
          RECREATE(clan->applicant, char *, clan->applicants + 1);
        else
          CREATE(clan->applicant, char *, clan->applicants + 1);
        clan->applicant[clan->applicants] = strdup(line);
        clan->applicants++;
      }
      else goto bad_tag;
      break;
    case 'C':
           if (TAG_IS("Cppr"))          clan->treasure[COPPER] = num;
      else goto bad_tag;
      break;
    case 'D':
           if (TAG_IS("Dues"))          clan->dues = num;
      else if (TAG_IS("Desc"))          clan->description = fbgetstring(fl);
      else goto bad_tag;
      break;
    case 'F':
           if (TAG_IS("Fee "))          clan->app_fee = num;
      else goto bad_tag;
      break;
    case 'G':
           if (TAG_IS("Gold"))          clan->treasure[GOLD] = num;
      else goto bad_tag;
      break;
    case 'I':
           if (TAG_IS("Id  ")) {
        /* Make sure there isn't already a clan with this id. */
        id = num;
        for (num = 0; num < num_of_clans; ++num)
          if (clans[num].id == id)
            ++id;
        clan->id = id;
      }
      else goto bad_tag;
      break;
    case 'M':
           if (TAG_IS("Mmbr")) {
        CREATE(member, clan_member, 1);
d612 22
a633 3
        line = any_one_arg(line, arg);
        CAP(arg);
        member->name = strdup(arg);
d635 3
a637 20
        if ((num = get_ptable_by_name(arg)) >= 0)
          clan->power += player_table[num].level;
        else
          continue;

        line = any_one_arg(line, arg);
        member->rank = MAX(1, atoi(arg));

        while (*line) {
          line = any_one_arg(line, arg);
          CAP(arg);
          if (get_ptable_by_name(arg) < 0)
            continue;
          if (member->surrogate)
            RECREATE(member->surrogate, char *, member->surrogates + 1);
          else
            CREATE(member->surrogate, char *, member->surrogates + 1);
          member->surrogate[member->surrogates] = strdup(arg);
          member->surrogates++;
        }
a638 2
        member->next = clan->member_list;
        clan->member_list = member;
d640 3
a642 12
        clan->members++;
      }
      else goto bad_tag;
      break;
    case 'N':
           if (TAG_IS("Name"))          clan->name = strdup(line);
      else goto bad_tag;
      break;
    case 'P':
           if (TAG_IS("Plat"))          clan->treasure[PLATINUM] = num;
      else if (TAG_IS("Priv")) {
        int i;
d644 4
a647 31
        line = one_argument(line, arg);
        num = atoi(line); /* rank */
        for (i = 0; i < NUM_CLAN_PRIVS; ++i)
          if (!str_cmp(clan_privileges[i], arg)) {
            clan->privilege[i] = num;
            break;
          }
      }
      else goto bad_tag;
      break;
    case 'R':
           if (TAG_IS("Rank")) {
        if (clan->rank)
          RECREATE(clan->rank, char *, clan->ranks + 1);
        else
          CREATE(clan->rank, char *, clan->ranks + 1);
        clan->rank[clan->ranks] = strdup(line);
        clan->ranks++;
      }
      else goto bad_tag;
      break;
    case 'S':
           if (TAG_IS("Slvr"))          clan->treasure[SILVER] = num;
      else goto bad_tag;
      break;
    default:
    bad_tag:
      sprintf(buf, "SYSERR: Unknown tag %s in clan file %s: %s", tag, clan_num, line);
      log(buf);
      break;
    }
d650 1
a650 12
  fbclose(fl);

  if (!clan->id) {
    id = 0;
    for (num = 0; num < num_of_clans; ++num)
      id = MAX(id, clans[num].id);
    clan->id = id + 1;
  }

  return TRUE;
}

d652 1
a652 13
/*
 * Get a player by a given name, loading them from file if necessary.
 * First it searches through the character_list to see if the player
 * is already in the game.  If they are, this character is returned
 * in tch and is_linkload is unasserted.  It then attempts to load
 * the player from file.  If this fails, tch is set to NULL and 
 * is_linkload is unasserted.  Otherwise, the player is loaded and
 * returned in tch, and is_linkload is asserted.  If is_linkload is
 * asserted, the calling function MUST free_char(tch) or a memory
 * leak will result.
 */
void get_player(char *name, struct char_data **tch, bool *is_linkload) {
  *is_linkload = FALSE;
d654 4
a657 3
  for (*tch = character_list; *tch; *tch = (*tch)->next)
    if (!IS_NPC(*tch) && !str_cmp(name, GET_NAME(*tch)))
      return;
d659 3
a661 1
  *tch = NULL;
d663 3
a665 10
#ifdef ALLOW_CLAN_LINKLOAD
  CREATE(*tch, struct char_data, 1);
  clear_char(*tch);
  if (load_player(name, *tch) < 0) {
    free(*tch);
    *tch = NULL;
    return;
  }
  *is_linkload = TRUE;
#endif
d669 4
a672 13
/*
 * Set a player's title based on their clan and rank.
 */
void clan_set_title(struct char_data *ch) {
  int clan;
  if (GET_CLAN_RANK(ch) && (clan = find_clan_by_id(GET_CLAN(ch))) >= 0) {
    sprintf(buf, "%s %s", clans[clan].rank[GET_CLAN_RANK(ch) - 1],
            clans[clan].abbreviation);
    set_title(ch, buf);
  }
  else
    set_title(ch, NULL);
}
d674 1
a674 18
/*
 * Save a clan to file, provided either its array index or clan id.  (A 
 * clan id is resolved to an array index.)
 */
void perform_save_clan(int which, int mode) {
  FBFILE *fl;
  char filename[40];
  struct clan_record *clan;
  int i;
  clan_member *member;

  if (mode == VIRTUAL) {
    if ((which = find_clan_by_id(which)) < 0) {
      sprintf(buf, "Attempt to save clan with ID #%d.  Nonexistant in clan database.", which);
      log(buf);
      return;
    }
  }
d676 6
a681 8
  clan = &clans[which];

  sprintf(filename, "%s/%d%s", CLAN_PREFIX, clan->id, CLAN_SUFFIX);

  if (!(fl = fbopen(filename, FB_WRITE))) {
    sprintf(buf, "SYSERR: Couldn't open clan file %s for write", filename);
    mudlog(buf, NRM, LVL_GOD, TRUE);
    log(buf);
d685 2
a686 5
  sprintf(buf, "Id  : %d\n", clan->id);
  fbwrite(fl, buf);
  
  sprintf(buf, "Name: %s\n", clan->name);
  fbwrite(fl, buf);
d688 4
a691 7
  sprintf(buf, "Abbr: %s\n", clan->abbreviation);
  fbwrite(fl, buf);

  if (clan->description) {
    sprintf(buf, "Desc:\n%s~\n", clan->description);
    kill_ems(buf);
    fbwrite(fl, buf);
d694 8
a701 3
  if (clan->dues) {
    sprintf(buf, "Dues: %d\n", clan->dues);
    fbwrite(fl, buf);
d704 4
a707 3
  if (clan->app_fee) {
    sprintf(buf, "Fee : %d\n", clan->app_fee);
    fbwrite(fl, buf);
d710 3
a712 3
  if (clan->app_level) {
    sprintf(buf, "ALvl: %d\n", clan->app_level);
    fbwrite(fl, buf);
d715 9
a723 3
  if (clan->treasure[COPPER]) {
    sprintf(buf, "Cppr: %ld\n", clan->treasure[COPPER]);
    fbwrite(fl, buf);
d725 9
a733 11
  if (clan->treasure[SILVER]) {
    sprintf(buf, "Slvr: %ld\n", clan->treasure[SILVER]);
    fbwrite(fl, buf);
  }
  if (clan->treasure[GOLD]) {
    sprintf(buf, "Gold: %ld\n", clan->treasure[GOLD]);
    fbwrite(fl, buf);
  }
  if (clan->treasure[PLATINUM]) {
    sprintf(buf, "Plat: %ld\n", clan->treasure[PLATINUM]);
    fbwrite(fl, buf);
d736 2
a737 5
  for (i = 0; i < NUM_CLAN_PRIVS; ++i)
    if (clan->privilege[i]) {
      sprintf(buf, "Priv: %s %d\n", clan_privileges[i], clan->privilege[i]);
      fbwrite(fl, buf);
    }
a738 4
  for (i = 0; i < clan->ranks; ++i) {
    sprintf(buf, "Rank: %s\n", clan->rank[i]);
    fbwrite(fl, buf);
  }
a739 7
  for (member = clan->member_list; member; member = member->next) {
    sprintf(buf, "Mmbr: %s %d", member->name, member->rank);
    for (i = 0; i < member->surrogates; ++i)
      sprintf(buf, "%s %s", buf, member->surrogate[i]);
    strcat(buf, "\n");
    fbwrite(fl, buf);
  }
d741 55
a795 4
  for (i = 0; i < clan->applicants; ++i) {
    sprintf(buf, "Appl: %s\n", clan->applicant[i]);
    fbwrite(fl, buf);
  }    
d797 1
a797 1
  fbclose(fl);
d800 72
d873 3
a875 6
/*
 * Save the clan index file.
 */
void save_clan_index() {
  FILE *fl;
  int i;
d877 1
a877 8
  if (!(fl = fopen(CLAN_INDEX_FILE, "w"))) {
    log("No clan index.  Creating a new one.");
    touch(CLAN_INDEX_FILE);
    if (!(fl = fopen(CLAN_INDEX_FILE, "w"))) {
      perror("fatal error opening clan index");
      exit(1);
    }
  }
d879 9
a887 3
  for (i = 0; i < num_of_clans; ++i) {
    sprintf(buf, "%d\n", clans[i].id);
    fputs(buf, fl);
d889 3
a892 2
  fclose(fl);
}
d895 4
a898 9
/*
 * Save a clan and save the index.
 * If calling save_clan repeatedly, use preform_save_clan instead, and
 * be sure to save_clan_index when finished.
 */
void save_clan(int which, int mode) {
  perform_save_clan(which, mode);
  save_clan_index();
}
d900 1
a900 4
/*
 * Save all clans to disk.
 */
void save_clans()
d902 2
a903 12
  int i;
  for (i = 0; i < num_of_clans; ++i)
    perform_save_clan(i, REAL);
  save_clan_index();
}

/*
 * Free the memory used by a clan.
 */
void free_clan(struct clan_record *clan) {
  clan_member *member, *next;
  int i;
d905 5
a909 11
  free(clan->name);
  free(clan->abbreviation);
  free(clan->description);

  for (member = clan->member_list; member; member = next) {
    next = member->next;
    free(member->name);
    for (i = 0; i < member->surrogates; ++i)
      free(member->surrogate[i]);
    free(member->surrogate);
    free(member);
d912 1
a912 3
  for (i = 0; i < clan->ranks; ++i)
    free(clan->rank[i]);
  free(clan->rank);
d914 1
a914 3
  for (i = 0; i < clan->applicants; ++i)
    free(clan->applicant[i]);
  free(clan->applicant);
d917 7
d925 1
a925 6
/*
 * Delete the clan at the given array index.
 */
void delete_clan(int clan_index) {
  int i;
  char filename[40];
d927 12
a938 2
#ifdef BACKUP_CLAN_ON_DELETE
  char backup_filename[45];
d940 3
a942 2
  sprintf(filename, "%s/%d%s", CLAN_PREFIX, clans[clan_index].id, CLAN_SUFFIX);
  sprintf(backup_filename, "%s.bkup", filename);
d944 4
a947 5
  rename(filename, backup_filename);
#else
  sprintf(filename, "%s/%d%s", CLAN_PREFIX, clans[clan_index].id, CLAN_SUFFIX);
  remove(filename);
#endif
d949 1
a949 1
  free_clan(&clans[clan_index]);
d951 7
a957 2
  for (i = clan_index; i < num_of_clans - 1; ++i)
    clans[i] = clans[i + 1];
a958 1
  --num_of_clans;
d960 19
a978 1
  save_clan_index();
d982 8
a989 6
/*
 * Expel a player from a clan.
 */
bool clan_expel(char *name) {
  struct char_data *ch;
  bool is_linkload;
d991 4
a994 1
  get_player(name, &ch, &is_linkload);
d996 7
a1002 5
  if (!ch) {
    sprintf(buf, "SYSERR: tried to expel nonexistant player '%s' from clan.", name);
    log(buf);
    return FALSE;
  }
a1003 11
  if (IS_CLAN_MEMBER(ch)) {
    int clan = find_clan_by_id(GET_CLAN(ch));
    if (clan >= 0)
      clans[clan].power -= GET_LEVEL(ch);
    GET_CLAN_RANK(ch) = 0;
    clan_set_title(ch);
  }
  else
    GET_CLAN_RANK(ch) = 0;
  GET_CLAN(ch) = 0;
  save_player_char(ch);
d1005 4
a1008 4
  if (is_linkload)
    free_char(ch);
  return TRUE;
}
d1010 1
d1012 5
a1016 24
/*
 * Remove all traces of a player from a clan.
 */
bool remove_player_from_clan(char *name, int clan_id) {
  int clan = find_clan_by_id(clan_id);
  clan_member dummy; /* NOT a pointer */
  clan_member *member, *temp;
  int i;
  bool found;

  if (clan < 0) {
    sprintf(buf, "Invalid clan ID %d passed to remove_player_from_clan for player '%s'", clan_id, name);
    log(buf);
    return clan_expel(name);
  }

  found = FALSE;
  for (i = 0; i < clans[clan].applicants; ++i)
    if (!found) {
      if (!strcmp(name, clans[clan].applicant[i])) {
        /* Found in applicant list. */
        found = TRUE;
        free(clans[clan].applicant[i]);
      }
d1019 9
a1027 22
      *clans[clan].applicant[i - 1] = *clans[clan].applicant[i];
  if (found) {
    clans[clan].applicants--;
    clan_expel(name);
    save_clan(clan, REAL);
    return TRUE;
  }

  dummy.next = clans[clan].member_list;

  for (member = &dummy; member; member = member->next) {
    temp = member->next;
    /* Consider the *next* player in the list (skip the dummy) */
    if (temp && !strcmp(name, temp->name)) {
      if (temp == clans[clan].member_list)
        clans[clan].member_list = member->next->next;
      member->next = member->next->next;

      /* Clean up surrogates. */
      for (i = 0; i < temp->surrogates; ++i) {
        clan_expel(temp->surrogate[i]);
        free(temp->surrogate[i]);
d1029 1
a1029 7
      free(temp->surrogate);
      free(temp->name);
      free(temp);
      clans[clan].members--;
      clan_expel(name);
      save_clan(clan, REAL);
      return TRUE;
d1031 2
d1035 25
a1059 8
  for (member = clans[clan].member_list; member; member = member->next) {
    found = FALSE;
    for (i = 0; i < member->surrogates; ++i)
      if (!found) {
        if (!strcmp(name, member->surrogate[i])) {
          /* Found in this member's surrogate list. */
          found = TRUE;
          free(member->surrogate[i]);
d1062 8
a1069 6
      else
        member->surrogate[i - 1] = member->surrogate[i - 1];
    if (found) {
      clan_expel(name);
      save_clan(clan, REAL);
      return TRUE;
d1073 2
a1074 1
  return clan_expel(name);
a1076 7
/*
 * Replace a player's name in a clan.
 */
void rename_player_in_clan(char *old_name, char *new_name, int clan_id) {
  clan_member *member;
  int i, clan_index;
  struct clan_record *clan;
a1077 2
  if (!old_name || !new_name || !*new_name)
    return;
d1079 38
a1116 2
  if ((clan_index = find_clan_by_id(clan_id)) < 0)
    return;
d1118 131
a1248 1
    clan = &clans[clan_index];
d1250 20
a1269 7
  for (i = 0; i < clan->applicants; ++i)
    if (!str_cmp(old_name, clan->applicant[i])) {
      free(clan->applicant[i]);
      clan->applicant[i] = strdup(new_name);
      save_clan(clan_index, REAL);
      return;
    }
d1271 4
a1274 7
  for (member = clan->member_list; member; member = member->next) {
    if (!str_cmp(old_name, member->name)) {
      free(member->name);
      member->name = strdup(new_name);
      save_clan(clan_index, REAL);
      return;
    }
d1276 6
a1281 7
    for (i = 0; i < member->surrogates; ++i)
      if (!str_cmp(old_name, member->surrogate[i])) {
        free(member->surrogate[i]);
        member->surrogate[i] = strdup(new_name);
        save_clan(clan_index, REAL);
        return;
      }
d1283 2
d1287 10
a1296 11
/*
 * Ensure clan member is in clan record, sort of.
 */
void clan_player_check(struct char_data *ch) {
  int clan = find_clan_by_id(GET_CLAN(ch));
  int i, members = 0;
  clan_member *member;

  if (clan < 0) {
    sprintf(buf, "Player in nonexistant clan %d.", GET_CLAN(ch));
    log(buf);
d1300 17
a1316 15
  for (i = 0; i < clans[clan].applicants; ++i)
    if (!strcmp(GET_NAME(ch), clans[clan].applicant[i])) {
      GET_CLAN_RANK(ch) = RANK_APPLICANT;
      return; /* Player found in applicant list. */
    }

  for (member = clans[clan].member_list; member; member = member->next) {
    if (!strcmp(GET_NAME(ch), member->name)) {
      GET_CLAN_RANK(ch) = member->rank;
      return; /* Player found in clan list. */
    }
    for (i = 0; i < member->surrogates; ++i)
      if (!strcmp(GET_NAME(ch), member->surrogate[i])) {
        GET_CLAN_RANK(ch) = -(member->rank);
        return; /* Player found in surrogate list. */
d1318 30
d1349 3
a1351 1
    ++members;
d1353 21
a1373 23
    if (!member->next) {
      if (IS_CLAN_MEMBER(ch)) {
        /*
         * This is the last member in the list.  That means the player
         * was not found.  Add them on to the end.
         */
        CREATE(member->next, struct clan_member, 1);
        member->next->name = strdup(GET_NAME(ch));
        member->next->rank = GET_CLAN_RANK(ch);
        clans[clan].members = ++members;
        save_clan(clan, REAL);
        return;
      }
      else if (IS_CLAN_SURROGATE(ch)) {
        /*
         * The player is a surrogate, but wasn't in any surrogate lists.
         * There isn't a way to figure out which clan member the player
         * belongs to, so to maintain data integrity, we must remove the
         * player from the clan.
         */
        GET_CLAN(ch) = 0;
        GET_CLAN_RANK(ch) = 0;
        return;
d1377 2
d1380 4
a1383 10
  if (IS_CLAN_APPLICANT(ch)) {
    /*
     * The player is marked as a clan applicant, but wasn't in the 
     * applicant list.  Add them.
     */
    RECREATE(clans[clan].applicant, char *, clans[clan].applicants + 2);
    clans[clan].applicant[clans[clan].applicants] = strdup(GET_NAME(ch));
    clans[clan].applicants++;
    save_clan(clan, REAL);
  }
d1385 16
a1400 39
}

void modify_clan_power(int clan_id, int amount) {
  int clan = find_clan_by_id(clan_id);
  if (clan >= 0)
    clans[clan].power += amount;
}

void free_clans() {
  int i, j;
  clan_member *member;

  for (i = 0; i < num_of_clans; ++i) {
    free(clans[i].name);
    if (clans[i].abbreviation)
      free(clans[i].abbreviation);
    if (clans[i].description)
      free(clans[i].description);

    for (j = 0; j < clans[i].ranks; ++j)
      free(clans[i].rank[j]);
    if (clans[i].rank)
      free(clans[i].rank);

    for (j = 0; j < clans[i].applicants; ++j)
      if (clans[i].applicant[j])
        free(clans[i].applicant[j]);
    if (clans[i].applicant)
      free(clans[i].applicant);

    while (clans[i].member_list) {
      member = clans[i].member_list;
      clans[i].member_list = member->next;
      free(member->name);
      for (j = 0; j < member->surrogates; ++j)
        if (member->surrogate[j])
          free(member->surrogate[j]);
      free(member->surrogate);
      free(member);
d1403 8
a1410 2

  free(clans);
a1412 1

d1415 3
d1457 1
a1457 1
 * All invocations of the string editor now go through string_write()
d1495 1
a1495 1
 * the string_write function.
@


1.36
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.35 2009/03/08 23:34:14 jps Exp jps $
d425 1
a425 1
      (GET_PLAT(ch) < plat || GET_GOLD(ch) < gold ||
d431 1
a431 1
  if (!is_deposit && (clans[clan].treasure[PLAT] < plat || 
d461 1
a461 1
    GET_PLAT(ch) -= plat;
d468 1
a468 1
  clans[clan].treasure[PLAT] += plat;
d814 1
a814 1
            clan->treasure[PLAT], clan->treasure[GOLD],
d872 1
a872 1
  else if (GET_PLAT(ch) < clans[clan].app_fee)
d895 2
a896 2
    GET_PLAT(ch) -= clans[clan].app_fee;
    clans[clan].treasure[PLAT] += clans[clan].app_fee;
d2503 1
a2503 1
           if (TAG_IS("Plat"))          clan->treasure[PLAT] = num;
d2672 2
a2673 2
  if (clan->treasure[PLAT]) {
    sprintf(buf, "Plat: %ld\n", clan->treasure[PLAT]);
d3086 3
@


1.35
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.34 2009/02/11 17:03:39 myc Exp jps $
d30 1
d3086 3
@


1.34
log
@Update clan_tell to check EDITING when it checks WRITING.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.33 2008/09/02 06:52:30 jps Exp myc $
d21 1
a21 1
#include "spells.h"
d3085 3
@


1.33
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.32 2008/08/17 06:53:06 jps Exp jps $
d1994 2
a1995 1
        PLR_FLAGGED(d->character, PLR_MAILING))
d3085 3
@


1.32
log
@Removing function prototype for speech_ok since it's now in comm.h.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.31 2008/08/15 03:59:08 jps Exp jps $
d29 1
d3084 3
@


1.31
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.30 2008/08/14 09:45:22 jps Exp jps $
a40 1
int speech_ok(struct char_data *ch, int quiet);
d3083 3
@


1.30
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.29 2008/07/27 05:12:48 jps Exp jps $
a327 1
  buf[0] = '\0';
d333 2
a334 2
    sprintf(buf, "%s[%3d]  %s%s Members: %2d  Power: %4d  App Fee: %d &6&bPlatinum&0\r\n",
            buf, clans[i].id, clans[i].abbreviation, buf1, 
d337 1
a337 1
  page_string(ch->desc, buf);
d756 1
a756 1
  page_string(ch->desc, buf);
d839 1
a839 1
  page_string(ch->desc, buf);
d3084 3
@


1.29
log
@Changed name of save_player to save_player_char, since it only saves the
character, not other stuff like objects and quests.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.28 2008/06/05 02:07:43 myc Exp jps $
d28 1
d338 1
a338 1
  page_string(ch->desc, buf, 1);
d757 1
a757 1
  page_string(ch->desc, buf, TRUE);
d840 1
a840 1
  page_string(ch->desc, buf, TRUE);
d3085 4
@


1.28
log
@Added better unknown tag error reporting.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.27 2008/05/18 03:51:32 jps Exp myc $
d464 1
a464 1
    save_player(ch);
d569 1
a569 1
    save_player(vict);
d975 1
a975 1
    save_player(vict);
d988 1
a988 1
          save_player(alt);
d1081 1
a1081 1
    save_player(vict);
d1219 1
a1219 1
            save_player(vict);
d1272 1
a1272 1
        save_player(vict);
d1344 1
a1344 1
          save_player(vict);
d1583 1
a1583 1
            save_player(vict);
d1620 1
a1620 1
          save_player(vict);
d2834 1
a2834 1
  save_player(ch);
d3084 3
@


1.27
log
@Typo fix
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.26 2008/04/03 02:02:05 myc Exp jps $
d2415 1
a2415 1
           if (TAG_IS("ALvl")) clan->app_level = num;
d2430 1
d2433 2
a2434 1
           if (TAG_IS("Cppr")) clan->treasure[COPPER] = num;
d2437 3
a2439 2
           if (TAG_IS("Dues")) clan->dues = num;
      else if (TAG_IS("Desc")) clan->description = fbgetstring(fl);
d2442 2
a2443 1
           if (TAG_IS("Fee ")) clan->app_fee = num;
d2446 2
a2447 1
           if (TAG_IS("Gold")) clan->treasure[GOLD] = num;
d2458 1
d2494 1
d2497 2
a2498 1
           if (TAG_IS("Name")) clan->name = strdup(line);
d2501 1
a2501 1
           if (TAG_IS("Plat")) clan->treasure[PLAT] = num;
d2513 1
d2524 1
d2527 7
a2533 1
           if (TAG_IS("Slvr")) clan->treasure[SILVER] = num;
d3084 3
@


1.26
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.25 2008/03/28 17:54:53 myc Exp myc $
d444 1
a444 1
    sprintf(buf, "%s%d &3&bplatinum&0 ", buf, gold);
d3068 3
@


1.25
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.24 2008/03/22 03:22:38 myc Exp myc $
d27 1
d3068 4
@


1.24
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.23 2008/03/19 04:32:14 myc Exp myc $
d1517 1
a1517 1
    SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
d1923 1
a1923 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d1991 3
a1993 1
    if (STATE(d) != CON_PLAYING || PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
d3014 1
a3014 1
    clans[clan].applicant[clans[clan].applicants] = str_dup(GET_NAME(ch));
d3067 6
@


1.23
log
@Fixed message in do_clan_reject missing newline.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.22 2008/03/05 05:21:56 myc Exp myc $
a1503 1
    char *backstr;
d1519 1
a1519 7
    backstr = NULL;
    if (clans[clan].description) {
      send_to_char(clans[clan].description, ch);
      ch->desc->backstr = strdup(clans[clan].description);
    }
    string_write(ch->desc, &clans[clan].description,
                 MAX_CLAN_DESC_LENGTH, 0, backstr);
d3065 3
@


1.22
log
@Removed a save_char_file_u declaration.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.21 2008/03/05 05:08:28 jps Exp myc $
d2205 1
a2205 1
    sprintf(buf, "%s isn't even applying to %s clan!",
d3072 3
@


1.21
log
@Changed ascii player tags and allow them to be of variable length up to
126 characters.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.20 2008/03/05 03:03:54 myc Exp jps $
a37 1
extern void save_char_file_u(struct char_file_u st);
d3072 4
@


1.20
log
@Pfiles are now ascii, so you access them differently now.  Also
some stuff can be retrieved directly from the index instead of
requiring a load_char.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.19 2008/02/24 17:31:13 myc Exp myc $
d2390 1
a2390 1
  char tag[6];
d3073 5
@


1.19
log
@Clan tell will only be received in OLC if you have OLCComm toggled
on.  Also clan members can block clan tell with the NoClanTell toggle.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.18 2008/02/23 01:03:54 myc Exp myc $
d26 1
a2394 1
  struct char_file_u ch_data;
d2467 2
a2468 2
        if (load_char(arg, &ch_data))
          clan->power += ch_data.level;
d2478 1
a2478 1
          if (!load_char(arg, &ch_data))
a2551 1
  struct char_file_u tmp_store;  
d2563 1
a2563 1
  if (load_char(name, &tmp_store) < 0) {
a2567 1
  store_to_char(&tmp_store, *tch);
d3073 4
@


1.18
log
@Plugging a memory leak where members weren't being freed when freeing
all clans.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.17 2008/02/16 20:26:04 myc Exp myc $
d1994 2
d1998 5
d3075 4
@


1.17
log
@Adding functions to free clans at program termination.  Replaced
a few RECREATE calls with CREATE calls since zmalloc was complaining
about them.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.16 2008/02/09 04:27:47 myc Exp myc $
d3058 1
d3068 5
@


1.16
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.15 2008/02/02 19:38:20 myc Exp myc $
d2421 4
a2424 1
        RECREATE(clan->applicant, char *, clan->applicants + 1);
d2473 4
a2476 1
          RECREATE(member->surrogate, char *, member->surrogates + 1);
d2506 4
a2509 1
        RECREATE(clan->rank, char *, clan->ranks + 1);
d3028 37
d3067 3
@


1.15
log
@Replacing NOONE with NOPERSON.  Changing clan desc edit to use
the string_write function.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.14 2008/01/29 21:02:31 myc Exp myc $
d25 1
d3021 4
@


1.14
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.13 2008/01/08 22:36:14 myc Exp myc $
d520 1
a520 1
    send_to_char(NOONE, ch);
d644 1
a644 1
      send_to_char(NOONE, ch);
d938 1
a938 1
    send_to_char(NOONE, ch);
d1044 1
a1044 1
    send_to_char(NOONE, ch);
d1503 1
d1519 1
a1519 1
    ch->desc->backstr = NULL;
d1522 1
a1522 1
      ch->desc->backstr = str_dup(clans[clan].description);
d1524 2
a1525 2
    ch->desc->str = &clans[clan].description;
    ch->desc->max_str = MAX_CLAN_DESC_LENGTH;
d2176 1
a2176 1
    send_to_char(NOONE, ch);
d3020 4
@


1.13
log
@Fixing bug where plat wasn't saving if the clan had no copper.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.12 2008/01/05 06:06:35 myc Exp myc $
a35 2
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
d3019 3
@


1.12
log
@Removing an extra return in the clan command that was cutting the
command list short.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.11 2008/01/05 05:36:34 jps Exp myc $
d2645 1
a2645 1
  if (clan->treasure[COPPER]) {
d3021 4
@


1.11
log
@Changed name of function save_char() to save_player(). Because it
only operates on players.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.10 2007/12/25 05:33:55 myc Exp jps $
d208 1
a208 1
  if (clan >= 0) {
a209 2
    return;
  }
d3021 4
@


1.10
log
@Fixing a crash bug in clan expel.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.9 2007/12/20 23:10:20 myc Exp myc $
d466 1
a466 1
    save_char(ch);
d571 1
a571 1
    save_char(vict);
d977 1
a977 1
    save_char(vict);
d990 1
a990 1
          save_char(alt);
d1083 1
a1083 1
    save_char(vict);
d1221 1
a1221 1
            save_char(vict);
d1274 1
a1274 1
        save_char(vict);
d1346 1
a1346 1
          save_char(vict);
d1591 1
a1591 1
            save_char(vict);
d1628 1
a1628 1
          save_char(vict);
d2811 1
a2811 1
  save_char(ch);
d3023 3
@


1.9
log
@Clan deposit/withdraw no longer modifies clan god's coins on hand.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.8 2007/12/19 20:40:36 myc Exp myc $
d590 1
a590 1
        send_to_char(buf, ch);
d669 4
a672 1
      log(buf);
d674 12
a685 7
    sprintf(buf, "You expel %s from %s.\r\n", GET_NAME(vict),
            clan < 0 ? "a clan" : clans[clan].name);
    send_to_char(buf, ch);
    if (vict->desc) {
      sprintf(buf, "You have been expelled from %s!\r\n",
              clan < 0 ? "your clan" : clans[clan].name);
      send_to_char(buf, vict);
a688 3
    sprintf(buf, "(CLAN) %s expels %s from %s.", 
            GET_NAME(ch), GET_NAME(vict), clans[clan].name);
    mudlog(buf, CMP, LVL_GOD, FALSE);
d3023 3
@


1.8
log
@Completely rewrote clan code.  Clans now use ASCII files.  Several new
features are also available, including alts, abbreviations (vs names),
descriptions, and smarter handling of just about everything.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.7 2004/11/11 20:27:48 rsd Exp myc $
d461 8
a468 4
  GET_PLAT(ch) -= plat;
  GET_GOLD(ch) -= gold;
  GET_SILVER(ch) -= silver;
  GET_COPPER(ch) -= copper;
a472 2

  save_char(ch);
d3018 5
@


1.7
log
@I altered the output of the string for the clan commands
to be less than the compiler limited length of 509 by
breaking it up into 2 send_to_char's instead of the one
large one.  This removed a compile warning.
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.6 2002/09/13 02:32:10 jjl Exp $
d24 1
d26 20
d47 1
a47 5
struct clan_rec clan[MAX_CLANS];

extern void save_char_file_u(struct char_file_u st);
extern struct descriptor_data *descriptor_list;
extern struct char_data *is_playing(char *vict_name);
d49 63
a111 2
char clan_privileges[NUM_CP+1][20] ={
  "setplan","enroll","expel","promote","demote","setfees","withdraw","setapplev"};
d113 1
a113 1
void send_clan_format(struct char_data *ch)
d115 32
a146 57
  int c,r;
  
  send_to_char("Clan commands available to you:\n\r",ch);
  if(GET_LEVEL(ch)>=LVL_CLAN_GOD){
    send_to_char("   clan who        <clan number>\r\n",ch);
    send_to_char("   clan snoop      <off | all | clan number >\r\n",ch);
    send_to_char("   clan rename     <clan number> <name>\r\n",ch);
  }
  else
    send_to_char("   clan who\r\n",ch);
  send_to_char("   clan status\r\n"
	       "   clan info       [clan number]\r\n",ch);
  if(GET_LEVEL(ch)>=LVL_CLAN_GOD) {
    send_to_char("   clan create     <leader> <clan name>\r\n"
		 "   clan destroy    <clan number>\r\n"
		 "   clan enroll     <player> <clan number>\r\n"
		 "   clan expel      <player> <clan number>\r\n"
		 "   clan promote    <player> <clan number>\r\n"
		 "   clan demote     <player> <clan number>\r\n"
		 "   clan withdraw   <clan number> <amount>\r\n",ch);
    send_to_char("   clan deposit    <clan number> <amount>\r\n"
		 "   clan set ranks  <rank>   <clan number>\r\n"
		 "   clan set appfee <amount> <clan number>\r\n"
		 "   clan set dues   <amount> <clan number>\r\n"
		 "   clan set applev <level>  <clan number>\r\n"
		 "   clan set plan   <clan number>\r\n"
		 "   clan privilege  <privilege>   <rank> <clan number>\r\n"
		 "   clan set title  <clan number> <rank> <title>\r\n",ch);
  } else {
    c=find_clan_by_id(GET_CLAN(ch));
    r=GET_CLAN_RANK(ch);
    if(r<1)
      send_to_char("   clan apply      <clan number>\r\n",ch);
    if(c>=0) {
      send_to_char("   clan deposit    <amount>\r\n",ch);
      if(r>=clan[c].privilege[CP_WITHDRAW])
	send_to_char("   clan withdraw   <amount>\r\n" ,ch);
      if(r>=clan[c].privilege[CP_ENROLL])
	send_to_char("   clan enroll     <player>\r\n" ,ch);
      if(r>=clan[c].privilege[CP_EXPEL])
	send_to_char("   clan expel      <player>\r\n" ,ch);
      if(r>=clan[c].privilege[CP_PROMOTE])
	send_to_char("   clan promote    <player>\r\n",ch);
      if(r>=clan[c].privilege[CP_DEMOTE])
	send_to_char("   clan demote     <player>\r\n",ch);
      if(r>=clan[c].privilege[CP_SET_APPLEV])
	send_to_char("   clan set applev <level>\r\n",ch);
      if(r>=clan[c].privilege[CP_SET_FEES])
	send_to_char("   clan set appfee <amount>\r\n"
		     "   clan set dues   <amount>\r\n",ch);
      if(r>=clan[c].privilege[CP_SET_PLAN])
	send_to_char("   clan set plan\r\n",ch);
      if(r==clan[c].ranks)
	send_to_char("   clan set ranks  <rank>\r\n"
		     "   clan set title  <rank> <title>\r\n"
		     "   clan privilege  <privilege> <rank>\r\n",ch);
    }
a147 1
}
d149 45
a193 28
/* 
   This function retitles all members to their appropriate titles
   and also purges any names in the roster that do not belong.
   Warning: the char_data passed to this function CAN BE NULL!
   So if any other uses of ch are used here, always check for null.
   -- Nechtrous
*/
void update_clan(struct char_data *ch, int clan_num)
{
  int i;
  struct char_data *victim;
  struct char_file_u chdata;
  
  for(i=0;i<MAX_MEMBERS_PER_CLAN;i++) {
    if(!(clan[clan_num].member_list[i][0]))
      continue;
    if((victim=is_playing(clan[clan_num].member_list[i]))) {
      if(GET_CLAN(victim) == clan[clan_num].id) {
	sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(victim)-1], clan[clan_num].name);
	set_title(victim, buf);    
	save_char(victim, victim->in_room);
      }
      else {
	clan[clan_num].member_list[i][0] = '\0';
	if(ch){
	  sprintf(buf,"%s was purged from %s&0's roster.\r\n",GET_NAME(victim),clan[clan_num].name);
	  send_to_char(buf,ch);
	}
a194 20
    }
    else {
      load_char(clan[clan_num].member_list[i], &chdata);
      if(chdata.player_specials_saved.clan==clan[clan_num].id) {
	sprintf(buf, "%s %s",clan[clan_num].rank_name[chdata.player_specials_saved.clan_rank - 1], clan[clan_num].name);
	buf[80] = '\0';
	strcpy(chdata.title,buf);
	save_char_file_u(chdata); 
      } 
      else {
	clan[clan_num].member_list[i][0] = '\0';
	if (ch){
	  sprintf(buf,"%s was purged from %s&0's roster.\r\n",chdata.name,clan[clan_num].name);
	  send_to_char(buf,ch);
	}
      }
    }
  }
  save_clans();
}
d196 10
a205 80
void do_clan_create (struct char_data *ch, char *arg)
{
  struct char_data *leader = NULL;
  char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
  int new_id=0,i;
  
  if (!*arg) {
    send_clan_format(ch);
    return; }
  
  if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
    send_to_char("You are not mighty enough to create new clans!\r\n", ch);
    return; }
  
  if(num_of_clans == MAX_CLANS) {
    send_to_char("Max clans reached. WOW!\r\n",ch);
    return; }
  
  half_chop(arg, arg1, arg2);
  
  if(!(leader=get_char_vis(ch,arg1))) {
    send_to_char("The leader of the new clan must be present.\r\n",ch);
    return; }
  
  if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
    send_to_char("Clan name too long! (32 characters max)\r\n",ch);
    return; }
  
  if(GET_LEVEL(leader)>=LVL_IMMORT) {
    send_to_char("You cannot set an immortal as the leader of a clan.\r\n",ch);
    return; }
  
  if(GET_CLAN(leader)!=0 && GET_CLAN_RANK(leader)!=0) {
    send_to_char("The leader already belongs to a clan!\r\n",ch);
    return; }
  
  if(find_clan(arg2)!=-1) {
    send_to_char("That clan name alread exists!\r\n",ch);
    return; }
  
  strncpy(clan[num_of_clans].name, arg2, 100);
  for(i=0;i<num_of_clans;i++)
    if(new_id<clan[i].id)
      new_id=clan[i].id;
  clan[num_of_clans].id=new_id+1;
  clan[num_of_clans].ranks =  2;
  strcpy(clan[num_of_clans].rank_name[0],"Member");
  strcpy(clan[num_of_clans].rank_name[1],"Leader");
  clan[num_of_clans].treasure = 0 ;
  clan[num_of_clans].plat = 0;
  clan[num_of_clans].gold = 0;
  clan[num_of_clans].silver = 0;
  clan[num_of_clans].copper = 0;
  clan[num_of_clans].members = 1 ;
  clan[num_of_clans].power = GET_LEVEL(leader) ;
  clan[num_of_clans].app_fee = 0 ;
  clan[num_of_clans].dues = 0 ;
  clan[num_of_clans].app_level = DEFAULT_APP_LVL ;
  for(i=0;i<20;i++)
    clan[num_of_clans].spells[i]=0;
  for(i=0;i<20;i++)
    clan[num_of_clans].privilege[i]=clan[num_of_clans].ranks;
  for(i=0;i<4;i++)
    clan[num_of_clans].at_war[i]=0;
  for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
    clan[num_of_clans].member_list[i][0] = '\0';
  strcpy(clan[num_of_clans].member_list[0], GET_NAME(leader));
  num_of_clans++;
  save_clans();
  send_to_char("Clan created.\r\n", ch);
  GET_CLAN(leader)=clan[num_of_clans-1].id;
  GET_CLAN_RANK(leader)=clan[num_of_clans-1].ranks;
  sprintf(buf, "%s %s", clan[num_of_clans-1].rank_name[GET_CLAN_RANK(leader) -1],
	  clan[num_of_clans-1].name);
  set_title(leader, buf);
  save_char(leader, leader->in_room);
  sprintf(buf, "%s created clan : %s", GET_NAME(ch), clan[num_of_clans-1].name);
  log(buf);
  return;
}
d207 3
a209 17
void do_clan_rename (struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
  int clan_num;
  
  if (!*arg) {
    send_clan_format(ch);
    return; }
  
  if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
    send_to_char("You are not mighty enough to rename clans!\r\n", ch);
    return; }
  
  half_chop(arg, arg1, arg2);
  
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d212 4
a215 2
  if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d218 93
a310 13
  
  if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
    send_to_char("Clan name too long! (32 characters max)\r\n",ch);
    return; }
  
  if(find_clan(arg2)!=-1) {
    send_to_char("That clan name alread exists!\r\n",ch);
    return; }
  
  strncpy(clan[clan_num].name, arg2, 100);
  send_to_char("Clan renamed.\r\n", ch);
  update_clan(ch, clan_num);
  return;
d313 7
d321 2
a322 15
void do_clan_destroy (struct char_data *ch, char *arg)
{
  
  int i,j;
  extern int top_of_p_table;
  extern struct player_index_element *player_table;
  struct char_file_u chdata;
  struct char_data *victim=NULL;
  
  if (!*arg) {
    send_clan_format(ch);
    return; }
  
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d325 13
a337 3
  if((i=atoi(arg))<0 || i>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
d339 1
a339 34
  
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("Your not mighty enough to destroy clans!\r\n", ch);
    return; }
  
  for (j = 0; j <= top_of_p_table; j++){
    if((victim=is_playing((player_table +j)->name))) {
      if(GET_CLAN(victim)==clan[i].id) {
	GET_CLAN(victim)=0;
	GET_CLAN_RANK(victim)=0;
	set_title(victim, "");
	save_char(victim, victim->in_room);
	send_to_char("&5&bYour clan has been destroyed!&0\r\n", victim); } }
    else {
      load_char((player_table + j)->name, &chdata);
      if(chdata.player_specials_saved.clan==clan[i].id) {
	chdata.player_specials_saved.clan=0;
	chdata.player_specials_saved.clan_rank=0;
	chdata.title[0] = '\0';
	save_char_file_u(chdata); } } }
  
  sprintf(buf2, "%s has destroyed a clan: %s", GET_NAME(ch), clan[i].name);
  
  memset(&clan[i], sizeof(struct clan_rec), 0);
  
  for (j = i; j < num_of_clans - 1; j++)
    clan[j] = clan[j + 1];
  
  num_of_clans--;
  
  send_to_char("Clan deleted.\r\n", ch);
  save_clans();
  log(buf2);
  return;
d342 25
a366 15
void do_clan_enroll (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num,immcom=0,i;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; 
  }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
d370 32
a401 12
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; 
    }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
d403 4
a406 3
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
      return;
d409 6
a414 3
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ENROLL] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d417 5
a421 3
  
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
d424 76
a499 6
  else {
    if (clan[clan_num].members >= MAX_MEMBERS_PER_CLAN){
      if (GET_LEVEL(ch) >= LVL_IMMORT)
	send_to_char("That clan already has the maximum allowed members!\r\n",ch);
      else
	send_to_char("Your clan already has the maximum allowed members!\r\n",ch);
d502 4
a505 9
    if(GET_CLAN(vict)!=clan[clan_num].id) {
      if(GET_CLAN_RANK(vict)>0) {
	send_to_char("They're already in a clan.\r\n",ch);
	return;
      }
      else {
	send_to_char("They didn't request to join your clan.\r\n",ch);
	return;
      }
a506 8
    else
      if(GET_CLAN_RANK(vict)>0) {
	send_to_char("They're already in your clan.\r\n",ch);
	return;
      }
    if(GET_LEVEL(vict)>=LVL_IMMORT) {
      send_to_char("You cannot enroll immortals in clans.\r\n",ch);
      return; }
a507 18
  
  GET_CLAN_RANK(vict)++;
  sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
	  clan[clan_num].name);
  set_title(vict, buf);
  save_char(vict, vict->in_room);
  for(i=0;i<MAX_MEMBERS_PER_CLAN && clan[clan_num].member_list[i][0];i++);
  strcpy(clan[clan_num].member_list[i], GET_NAME(vict));
  clan[clan_num].power += GET_LEVEL(vict);
  clan[clan_num].members++;
  send_to_char("You've been enrolled in the clan you chose!\r\n",vict);
  send_to_char("Your new title is:", vict);
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  send_to_char("Done.\r\n",ch);
  
  return;
}
d509 27
a535 24
void do_clan_expel (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int i,clan_num,immcom=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; } }
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d538 4
a541 2
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d545 16
a560 8
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_EXPEL] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return; }
  
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
    return; }
d562 22
a583 3
    if(GET_CLAN(vict)!=clan[clan_num].id) {
      send_to_char("They're not in your clan.\r\n",ch);
      return; }
d585 17
a601 17
      if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
	send_to_char("You cannot kick out that person.\r\n",ch);
	return; } } }
  
  GET_CLAN(vict)=0;
  GET_CLAN_RANK(vict)=0;
  set_title(vict, "");
  save_char(vict, vict->in_room);
  clan[clan_num].members--;
  clan[clan_num].power-=GET_LEVEL(vict);
  for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
    if (!strcmp(clan[clan_num].member_list[i],GET_NAME(vict)))
      clan[clan_num].member_list[i][0] = '\0';
  send_to_char("You've been kicked out of your clan!\r\n",vict);
  send_to_char("Done.\r\n",ch);
  
  return;
d604 16
a619 24
void do_clan_demote (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num,immcom=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; } }
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d622 3
a624 2
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
a627 32
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_DEMOTE] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return; }
  
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
    return; }
  else {
    if(GET_CLAN(vict)!=clan[clan_num].id) {
      send_to_char("They're not in your clan.\r\n",ch);
      return; }
    else {
      if(GET_CLAN_RANK(vict)==1) {
	send_to_char("They can't be demoted any further, use expel now.\r\n",ch);
	return; }
      if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
	send_to_char("You cannot demote a person of this rank!\r\n",ch);
	return; } } }
  
  GET_CLAN_RANK(vict)--;
  sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
	  clan[clan_num].name);
  set_title(vict, buf);
  save_char(vict, vict->in_room);
  send_to_char("You've demoted within your clan!\r\n",vict);
  send_to_char("Your new title is:", vict);
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  send_to_char("Done.\r\n",ch);
  return;
}
d629 32
a660 15
void do_clan_promote (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num,immcom=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; } }
d662 6
a667 6
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
d669 7
a675 3
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
      return;
d677 5
d683 3
a685 34
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_PROMOTE] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return; }
  
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
    return; }
  else {
    if(GET_CLAN(vict)!=clan[clan_num].id) {
      send_to_char("They're not in your clan.\r\n",ch);
      return; }
    else {
      if(GET_CLAN_RANK(vict)==0) {
	send_to_char("They're not enrolled yet.\r\n",ch);
	return; }
      if((GET_CLAN_RANK(vict)+1)>GET_CLAN_RANK(ch) && !immcom) {
	send_to_char("You cannot promote that person over your rank!\r\n",ch);
	return; }
      if(GET_CLAN_RANK(vict)==clan[clan_num].ranks) {
	send_to_char("You cannot promote someone over the top rank!\r\n",ch);
	return; } } }
  
  GET_CLAN_RANK(vict)++;
  sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
	  clan[clan_num].name);
  set_title(vict, buf);
  save_char(vict, vict->in_room);
  send_to_char("You've been promoted within your clan!\r\n",vict);
  send_to_char("Your new title is: ", vict);
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  send_to_char("Done.\r\n",ch);
  return;
d688 18
a705 14
void do_clan_who (struct char_data *ch, char *arg)
{
  struct char_data *victim;
  struct char_file_u chdata;
  int k, j, i;
  
  
  if(GET_CLAN_RANK(ch)==0 && GET_LEVEL(ch) < LVL_CLAN_GOD) {
    send_to_char("You do not belong to a clan!\r\n",ch);
    return; }
  
  if(GET_LEVEL(ch) >= LVL_CLAN_GOD) {
    if (!arg) {
      send_to_char("You must specify a clan number.\r\n",ch);
d708 3
a710 2
    if((i=atoi(arg))<0 || i>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d714 3
a716 6
  else
    i = find_clan_by_id(GET_CLAN(ch));
  
  if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
    sprintf(buf, "\r\n&3&bListing of clan members&0\r\n");
    sprintf(buf, "%s&3-----------------------&0\r\n",buf);
d718 6
a723 2
  else{
    sprintf(buf, "\r\n&3&bMember listing for &0%s&0\r\n\r\n", clan[i].name);
d725 11
a735 21
  
  for(k=clan[i].ranks;k>0;k--){
    for (j=0;j<MAX_MEMBERS_PER_CLAN;j++) {
      if(!(clan[i].member_list[j][0]))
	continue;
      if((victim=is_playing(clan[i].member_list[j]))) {
	if(GET_CLAN(victim)==clan[i].id && GET_CLAN_RANK(victim)==k) {
	  if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	    sprintf(buf, "%s%2d", buf, j);
	  sprintf(buf, "%s&0&2&bo&0 %-20.20s %s\r\n", buf,GET_NAME(victim),GET_TITLE(victim));
	} 
      }
      else {
	load_char(clan[i].member_list[j], &chdata);
	if(chdata.player_specials_saved.clan==clan[i].id 
	   && chdata.player_specials_saved.clan_rank == k) {
	  if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	    sprintf(buf, "%s%2d", buf, j);
	  sprintf(buf, "%s&0%-2.2s%-20.20s %s\r\n", buf,"",chdata.name,chdata.title);
	} 
      } 
a737 4
  page_string(ch->desc, buf, 1);
  
  return;
}
d739 9
a747 16
void do_clan_status (struct char_data *ch)
{
  char line_disp[200];
  int clan_num;
  
  if(GET_LEVEL(ch)>=LVL_IMMORT) {
    send_to_char("You are immortal and cannot join any clan!\r\n",ch);
    return; }
  
  clan_num=find_clan_by_id(GET_CLAN(ch));
  
  if(GET_CLAN_RANK(ch)==0) {
    if(clan_num>=0) {
      sprintf(line_disp,"You applied to %s\r\n",clan[clan_num].name);
      send_to_char(line_disp,ch);
      return; 
d749 3
a751 11
    else {
      send_to_char("You do not belong to a clan!\r\n",ch);
      return; 
    }
  }  
  sprintf(line_disp,"You are %s (Rank %d) of %s (ID %d)\r\n",
	  clan[clan_num].rank_name[GET_CLAN_RANK(ch)-1],GET_CLAN_RANK(ch),
	  clan[clan_num].name,clan[clan_num].id);
  send_to_char(line_disp,ch);
  
  return;
d754 18
a771 19
void do_clan_apply (struct char_data *ch, char *arg)
{
  int clan_num;
  struct char_data *vict;
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)>=LVL_IMMORT) {
    send_to_char("Gods cannot apply for any clan.\r\n",ch);
    return; }
  
  if(GET_CLAN_RANK(ch)>0) {
    send_to_char("You already belong to a clan!\r\n",ch);
    return; }
  else {
    if(!(vict=get_char_room_vis(ch,arg))) {
      send_to_char("Er, Who ??\r\n",ch);
a773 15
    if(!(GET_CLAN(vict)) || !(GET_CLAN_RANK(vict))) {
      send_to_char("They are not in a guild!\r\n",ch);
      return;
    }
    clan_num = find_clan_by_id(GET_CLAN(vict));
    /*
      if(!is_number(arg)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
      }
      if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
      return;
      }
    */
d775 15
a789 18
  
  if(GET_LEVEL(ch) < clan[clan_num].app_level) {
    send_to_char("You are not mighty enough to apply to this clan.\r\n",ch);
    return; }
  
  if(GET_PLAT(ch) < clan[clan_num].app_fee) {
    send_to_char("You cannot afford the application fee!\r\n", ch);
    return; }
  
  GET_PLAT(ch) -= clan[clan_num].app_fee;
  clan[clan_num].plat += clan[clan_num].app_fee;
  save_clans();
  GET_CLAN(ch)=clan[clan_num].id;
  save_char(ch, ch->in_room);
  sprintf(buf, "You've applied to %s&0!\r\n",clan[clan_num].name);
  send_to_char(buf,ch);
  return;
}
d791 20
a810 52
void do_clan_info (struct char_data *ch, char *arg)
{
  int i=0,j;
  
  if(num_of_clans == 0) {
    send_to_char("No clans have formed yet.\r\n",ch);
    return; }
  
  if(!(*arg)) {
    sprintf(buf, "\r");
    for(i=0; i < num_of_clans; i++)
      sprintf(buf, "%s[%-3d]  %-20s Members: %3d  Power: %5d  Appfee: %d &6&bPlatinum&0\r\n",buf,
	      i, clan[i].name,clan[i].members,clan[i].power,clan[i].app_fee);
    page_string(ch->desc,buf, 1);
    return; }
  else {
    if(!is_number(arg)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
    }
    if((i=atoi(arg))<0 || i>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
      return;
    }
    if(GET_LEVEL(ch) < LVL_IMMORT && clan[i].id != GET_CLAN(ch)) {
      send_to_char("That information is not available to you.\r\n",ch);
      return;
    }
  }
  
  sprintf(buf, "Info for clan <<%s>>:\r\n",clan[i].name);
  send_to_char(buf, ch);
  sprintf(buf, "Ranks      : %d\r\nTitles     : ",clan[i].ranks);
  for(j=0;j<clan[i].ranks;j++)
    sprintf(buf, "%s%s ",buf,clan[i].rank_name[j]);
  sprintf(buf, "%s\r\nMembers    : %d\r\nPower      : %d\t\nTreasure   : %ld &6&bPlatinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\nSpells     : ",buf, clan[i].members, clan[i].power, clan[i].plat, clan[i].gold, clan[i].silver, clan[i].copper);
  for(j=0; j<20;j++)
    if(clan[i].spells[j])
      sprintf(buf, "%s%d ",buf,clan[i].spells[j]);
  sprintf(buf, "%s\r\n",buf);
  send_to_char(buf, ch);
  sprintf(buf,"Clan privileges:\r\n");
  for(j=0; j<NUM_CP;j++)
    sprintf(buf, "%s   %-10s: %d\r\n",buf,clan_privileges[j],clan[i].privilege[j]);
  sprintf(buf, "%s\r\n",buf);
  send_to_char(buf, ch);
  /*
    sprintf(buf, "Description:\r\n%s\r\n\n", clan[i].description);
    send_to_char(buf, ch);
  */
  if((clan[i].at_war[0] == 0) && (clan[i].at_war[1] == 0) && (clan[i].at_war[2] == 0) && (clan[i].at_war[3] == 0))
    send_to_char("This clan is at peace with all others.\r\n", ch);
d812 10
a821 8
    send_to_char("This clan is at war.\r\n", ch);
  sprintf(buf, "Application fee  : %d &6&bPlatinum&0\r\nMonthly Dues     : %d &6&bPlatinum&0\r\n", clan[i].app_fee, clan[i].dues);
  send_to_char(buf, ch);
  sprintf(buf, "Application level: %d\r\n", clan[i].app_level);
  send_to_char(buf, ch);
  
  return;
}
d823 5
a827 8
sh_int find_clan_by_id(int idnum)
{
  int i;
  for( i=0; i < num_of_clans; i++)
    if(idnum==clan[i].id)
      return i;
  return -1;
}
d829 4
a832 8
sh_int find_clan(char *name)
{
  int i;
  for( i=0; i < num_of_clans; i++)
    if(strcmp(CAP(name), CAP(clan[i].name))==0)
      return i;
  return -1;
}
d834 1
a834 12
void save_clans()
{
  FILE *fl;
  
  if (!(fl = fopen(CLAN_FILE, "wb"))) {
    log("SYSERR: Unable to open clan file");
    return; }
  
  fwrite(&num_of_clans, sizeof(int), 1, fl);
  fwrite(clan, sizeof(struct clan_rec), num_of_clans, fl);
  fclose(fl);
  return;
d838 46
a883 31
void init_clans()
{
  FILE *fl;
  int i,j;
  extern int top_of_p_table;
  extern struct player_index_element *player_table;
  struct char_file_u chdata;
  
  memset(clan,0,sizeof(struct clan_rec)*MAX_CLANS);
  num_of_clans=0;
  i=0;
  
  if (!(fl = fopen(CLAN_FILE, "rb"))) {
    log("   Clan file does not exist. Will create a new one");
    save_clans();
    return; }
  
  fread(&num_of_clans, sizeof(int), 1, fl);
  fread(clan, sizeof(struct clan_rec), num_of_clans, fl);
  fclose(fl);
  
  log("   Calculating powers and members");
  for(i=0;i<num_of_clans;i++) {
    clan[i].power=0;
    clan[i].members=0;
  }
  for (j = 0; j <= top_of_p_table; j++){
    load_char((player_table + j)->name, &chdata);
    if((i=find_clan_by_id(chdata.player_specials_saved.clan))>=0) {
      clan[i].power+=chdata.level;
      clan[i].members++;
d885 12
a897 2
  
  return;
d900 16
a915 16
void do_clan_bank(struct char_data *ch, char *arg, int action)
{
  int i,clan_num,immcom=0; 
  long plat=0,gold=0,silver=0,copper=0,amount=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];
  char arg4[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
d918 3
a920 14
    strcpy(arg2,arg);
  }
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    if(!is_number(arg1)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
    }
    if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d924 5
a928 4
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_WITHDRAW] && !immcom && action
     ==CB_WITHDRAW) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d931 5
a935 3
  
  if(!(*arg2)) {
    send_to_char("Deposit how much?\r\n",ch);
d938 8
a945 29
  
  for (i=0;i<4;i++){
    half_chop(arg2,arg3,arg2);
    half_chop(arg2,arg4,arg2);
    if(!(*arg3) || !(*arg4)) 
      continue;
    if(!is_number(arg3)) {
      send_to_char("Wrong money format.\r\nUse format: <number> p <number> g <number> s <number> c\r\n",ch);
      return;
    }
    amount=atoi(arg3);
    switch(*arg4) {
    case 'p':
      plat += amount;
      break;
    case 'g':
      gold += amount;
      break;
    case 's':
      silver += amount;
      break;
    case 'c':
      copper += amount;
      break;
    default:
      send_to_char("Wrong money type.\r\n",ch);
      break;
    }
    
d947 4
a950 4
  if(!immcom && action==CB_DEPOSIT && (GET_PLAT(ch)<plat || GET_GOLD(ch)<gold 
				       || GET_SILVER(ch)<silver || GET_COPPER(ch)<copper)) {
    send_to_char("You do not have that kind of money!\r\n",ch);
    return;
d952 3
a954 6
  
  if(action==CB_WITHDRAW && (clan[clan_num].plat<plat 
			     || clan[clan_num].gold<gold || clan[clan_num].silver<silver
			     || clan[clan_num].copper<copper)) {
    send_to_char("The clan is not wealthy enough for your needs!\r\n",ch);
    return;
d956 3
a958 29
  
  switch(action) {
  case CB_WITHDRAW:
    GET_PLAT(ch)+=plat;
    GET_GOLD(ch)+=gold;
    GET_SILVER(ch)+=silver;
    GET_COPPER(ch)+=copper;
    clan[clan_num].plat-=plat;
    clan[clan_num].gold-=gold;
    clan[clan_num].silver-=silver;
    clan[clan_num].copper-=copper;
    sprintf(buf, "You withdraw from %s&0's account: ", clan[clan_num].name);
    break;
  case CB_DEPOSIT:
    if(!immcom) {
      GET_PLAT(ch)-=plat;
      GET_GOLD(ch)-=gold;
      GET_SILVER(ch)-=silver;
      GET_COPPER(ch)-=copper;
    }
    clan[clan_num].plat+=plat;
    clan[clan_num].gold+=gold;
    clan[clan_num].silver+=silver;
    clan[clan_num].copper+=copper;
    sprintf(buf, "You deposit into %s&0's account: ", clan[clan_num].name);
    break;
  default:
    send_to_char("Problem in command, please report.\r\n",ch);
    break;
d960 31
a990 7
  sprintf(buf,"%s%ld &b&6Platinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\n"
	  ,buf,plat,gold,silver,copper);
  send_to_char(buf, ch);
  save_char(ch, ch->in_room);
  save_clans();
  return;
}
d992 7
a998 15
void do_clan_money(struct char_data *ch, char *arg, int action)
{
  int clan_num,immcom=0;
  long amount=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
d1001 21
a1021 9
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d1024 3
a1026 2
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d1030 5
a1034 3
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_FEES] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d1037 5
a1041 3
  
  if(!(*arg)) {
    send_to_char("Set it to how much?\r\n",ch);
d1044 13
a1056 4
  
  if(!is_number(arg)) {
    send_to_char("Set it to what?\r\n",ch);
    return;
d1058 3
a1060 15
  
  amount=atoi(arg);
  
  switch(action) {
  case CM_APPFEE:
    clan[clan_num].app_fee=amount;
    send_to_char("You change the application fee.\r\n",ch);
    break;
  case CM_DUES:
    clan[clan_num].dues=amount;
    send_to_char("You change the monthly dues.\r\n",ch);
    break;
  default:
    send_to_char("Problem in command, please report.\r\n",ch);
    break;
d1062 3
a1064 24
  
  save_clans();
  return;
}

void do_clan_ranks(struct char_data *ch, char *arg)
{
  int i,j;
  int clan_num,immcom=0;
  int new_ranks;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct char_file_u chdata;
  struct char_data *victim=NULL;
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
    }
d1066 2
d1069 26
a1094 9
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
d1096 8
a1103 3
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
      return;
d1106 19
a1124 3
  
  if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d1127 8
a1134 23
  
  if(!(*arg)) {
    send_to_char("Set how many ranks?\r\n",ch);
    return;
  }
  
  if(!is_number(arg)) {
    send_to_char("Set the ranks to what?\r\n",ch);
    return;
  }
  
  new_ranks=atoi(arg);
  
  if(new_ranks==clan[clan_num].ranks) {
    send_to_char("The clan already has this number of ranks.\r\n",ch);
    return;
  }
  
  if(new_ranks<2 || new_ranks>20) {
    send_to_char("Clans must have from 2 to 20 ranks.\r\n",ch);
    return;
  }
  
d1136 55
a1190 3
    if(GET_PLAT(ch)<1000 && !immcom) {
    send_to_char("Changing the clan hierarchy requires 1,000 plat!\r\n",ch);
    return;
d1192 76
a1267 15
    
    if(!immcom)
    GET_PLAT(ch)-=1000;
  */
  
  for (j = 0; j < MAX_MEMBERS_PER_CLAN; j++) {
    if (!clan[clan_num].member_list[j][0])
      continue;
    if((victim=is_playing(clan[clan_num].member_list[j]))) {
      if(GET_CLAN(victim)==clan[clan_num].id) {
	if(GET_CLAN_RANK(victim)<clan[clan_num].ranks && GET_CLAN_RANK(victim)>0)
	  GET_CLAN_RANK(victim)=1;
	if(GET_CLAN_RANK(victim)==clan[clan_num].ranks)
	  GET_CLAN_RANK(victim)=new_ranks;
	save_char(victim, victim->in_room);
d1269 2
d1273 5
a1277 9
      load_char(clan[clan_num].member_list[j], &chdata);
      if(chdata.player_specials_saved.clan==clan[clan_num].id) {
	if(chdata.player_specials_saved.clan_rank<clan[clan_num].ranks && chdata.
	   player_specials_saved.clan_rank>0)
	  chdata.player_specials_saved.clan_rank=1;
	if(chdata.player_specials_saved.clan_rank==clan[clan_num].ranks)
	  chdata.player_specials_saved.clan_rank=new_ranks;
	save_char_file_u(chdata);
      }
d1279 3
d1283 2
a1284 12
  
  clan[clan_num].ranks=new_ranks;
  for(i=0;i<clan[clan_num].ranks-1;i++)
    strcpy(clan[clan_num].rank_name[i],"Member");
  strcpy(clan[clan_num].rank_name[clan[clan_num].ranks -1],"Leader");
  for(i=0;i<NUM_CP;i++)
    clan[clan_num].privilege[i]=new_ranks;
  
  update_clan(ch, clan_num);
  save_clans();
  return;
}
d1286 27
a1312 13
void do_clan_titles( struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int clan_num=0,rank;
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
d1314 4
a1317 2
    if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d1320 2
a1321 9
  }
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg2);
    if(!is_number(arg1)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d1324 2
a1325 2
    if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d1328 16
a1344 23
  
  half_chop(arg,arg1,arg2);
  
  if(!is_number(arg1)) {
    send_to_char("You need to specify a rank number.\r\n",ch);
    return; }
  
  rank=atoi(arg1);
  
  if(rank<1 || rank>clan[clan_num].ranks) {
    send_to_char("This clan has no such rank number.\r\n",ch);
    return; }
  
  if(strlen(arg2)<1 || strlen(arg2)>29) {
    send_to_char("You need a clan title of under 30 characters.\r\n",ch);
    return; }
  
  strcpy(clan[clan_num].rank_name[rank-1],arg2);
  save_clans();
  send_to_char("Done.\r\n",ch);
  update_clan(ch, clan_num);
  return;
}
d1346 31
a1376 27
void do_clan_application( struct char_data *ch, char *arg)
{
  int clan_num,immcom=0;
  int applevel;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
    }
  }
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg2)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
      return;
d1378 3
a1380 2
    if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d1383 5
d1389 384
a1772 3
  
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_APPLEV] && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d1775 9
a1783 3
  
  if(!(*arg)) {
    send_to_char("Set to which level?\r\n",ch);
d1786 3
a1788 3
  
  if(!is_number(arg)) {
    send_to_char("Set the application level to what?\r\n",ch);
d1791 5
a1795 5
  
  applevel=atoi(arg);
  
  if(applevel<1 || applevel>999) {
    send_to_char("The application level can go from 1 to 999.\r\n",ch);
d1798 11
d1810 25
a1834 4
  clan[clan_num].app_level=applevel;
  save_clans();
  
  return;
d1837 58
a1894 16
void do_clan_sp(struct char_data *ch, char *arg, int priv)
{
  int clan_num,immcom=0;
  int rank;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
d1897 39
a1935 9
  else {
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    immcom=1;
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg1);
    if(!is_number(arg1)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d1938 9
a1946 2
    if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d1950 3
a1952 3
  
  if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
d1955 15
a1969 4
  
  if(!(*arg)) {
    send_to_char("Set the privilege to which rank?\r\n",ch);
    return;
d1971 4
a1974 3
  
  if(!is_number(arg)) {
    send_to_char("Set the privilege to what?\r\n",ch);
d1977 30
a2006 6
  
  rank=atoi(arg);
  
  if(rank<1 || rank>clan[clan_num].ranks) {
    send_to_char("There is no such rank in the clan.\r\n",ch);
    return;
a2007 5
  
  clan[clan_num].privilege[priv]=rank;
  save_clans();
  
  return;
d2010 1
a2010 1
void do_clan_plan(struct char_data *ch, char *arg)
d2012 61
a2072 12
  int clan_num;
  
  send_to_char("Command not ready yet\r\n",ch);
  return;
  
  if(GET_LEVEL(ch)<LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; }
    if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_PLAN]) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
      return; }
d2075 78
a2152 8
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; }
    if (!(*arg)) {
      send_clan_format(ch);
      return; }
    if(!is_number(arg)) {
      send_to_char("You need to specify a clan number.\r\n",ch);
d2155 3
a2157 2
    if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
      send_to_char("There is no clan with that number.\r\n",ch);
d2161 23
a2183 3
  
  if(strlen(clan[clan_num].description)==0) {
    sprintf(buf, "Enter the description, or plan for clan <<%s>>.\r\n",clan[clan_num].name);
d2185 7
a2191 1
  }
d2193 2
a2194 1
    sprintf(buf, "Old plan for clan <<%s>>:\r\n", clan[clan_num].name);
a2195 2
    send_to_char(clan[clan_num].description, ch);
    send_to_char("Enter new plan:\r\n", ch);
d2197 3
a2199 5
  send_to_char("End with @@ on a line by itself.\r\n", ch);
  /*ch->desc->str   = clan[clan_num].description;*/
  ch->desc->max_str = CLAN_PLAN_LENGTH;
  save_clans();
  return;
d2202 85
a2286 1
void do_clan_privilege( struct char_data *ch, char *arg)
a2287 1
  char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
d2289 26
a2314 15
  
  half_chop(arg,arg1,arg2);
  
  if (is_abbrev(arg1,"setplan"  )) { do_clan_sp(ch,arg2,CP_SET_PLAN);   return ;}
  if (is_abbrev(arg1,"enroll"   )) { do_clan_sp(ch,arg2,CP_ENROLL);     return ;}
  if (is_abbrev(arg1,"expel"    )) { do_clan_sp(ch,arg2,CP_EXPEL);      return ;}
  if (is_abbrev(arg1,"promote"  )) { do_clan_sp(ch,arg2,CP_PROMOTE);    return ;}
  if (is_abbrev(arg1,"demote"   )) { do_clan_sp(ch,arg2,CP_DEMOTE);     return ;}
  if (is_abbrev(arg1,"withdraw" )) { do_clan_sp(ch,arg2,CP_WITHDRAW);   return ;}
  if (is_abbrev(arg1,"setfees"  )) { do_clan_sp(ch,arg2,CP_SET_FEES);   return ;}
  if (is_abbrev(arg1,"setapplev")) { do_clan_sp(ch,arg2,CP_SET_APPLEV); return ;}
  send_to_char("\r\nClan privileges:\r\n", ch);
  for(i=0;i<NUM_CP;i++) {
    sprintf(arg1,"\t%s\r\n",clan_privileges[i]);
    send_to_char(arg1,ch); }
d2317 5
a2321 1
void do_clan_set(struct char_data *ch, char *arg)
d2323 277
a2599 1
  char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
d2601 34
a2634 3
  half_chop(arg,arg1,arg2);
  
  if (is_abbrev(arg1, "plan"      )) { do_clan_plan(ch,arg2);            return ;
d2636 3
a2638 1
  if (is_abbrev(arg1, "ranks"     )) { do_clan_ranks(ch,arg2);           return ;
d2640 3
a2642 1
  if (is_abbrev(arg1, "title"     )) { do_clan_titles(ch,arg2);          return ;
d2644 10
a2653 1
  if (is_abbrev(arg1, "privilege" )) { do_clan_privilege(ch,arg2);       return ;
d2655 7
a2661 1
  if (is_abbrev(arg1, "dues"      )) { do_clan_money(ch,arg2,CM_DUES);   return ;
d2663 24
a2686 1
  if (is_abbrev(arg1, "appfee"    )) { do_clan_money(ch,arg2,CM_APPFEE); return ;
d2688 4
a2691 1
  if (is_abbrev(arg1, "applev"    )) { do_clan_application(ch,arg2);     return ;
d2693 2
a2694 1
  send_clan_format(ch);
d2697 15
a2711 1
void do_clan_snoop(struct char_data *ch, char *arg)
d2714 155
a2868 4
  
  if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
    send_clan_format(ch);
    return;
d2870 11
a2880 12
  if(!(*arg)) {
    sprintf(buf, "You are currently snooping");
    switch(ch->clan_snoop) {
    case -2:
      sprintf(buf,"%s no clans.\r\n",buf);
      break;
    case -1:
      sprintf(buf,"%s all clans.\r\n",buf);
      break;
    default:
      if (ch->clan_snoop>=0 && ch->clan_snoop<num_of_clans)
        sprintf(buf,"%s %s.\r\n", buf, clan[ch->clan_snoop].name);
d2882 41
a2922 2
        sprintf(buf,"Your clan snoop level is invalid.");
      break;
d2924 22
a2945 1
    send_to_char(buf,ch);
d2948 16
a2963 9
  else { 
    if(!is_number(arg)) {
      if(is_abbrev(arg, "off"))
	ch->clan_snoop = -2;  
      else if(is_abbrev(arg, "all"))
	ch->clan_snoop = -1;
      else {
	send_to_char("That is an invalid selection.\r\n",ch);
	return;
d2965 26
a2990 5
    }
    else {
      if((i=atoi(arg))<0 || i>=num_of_clans) {
	send_to_char("That is an invalid number.\r\n",ch);
	return;
a2991 2
      else
	ch->clan_snoop = atoi(arg);
a2992 16
  } 
  
  sprintf(buf, "Your are now snooping");
  switch(ch->clan_snoop) {
  case -2:
    sprintf(buf,"%s no clans.\r\n",buf);
    break;
  case -1:
    sprintf(buf,"%s all clans.\r\n",buf);
    break;
  default:
    if (ch->clan_snoop>=0 && ch->clan_snoop<num_of_clans)
      sprintf(buf,"%s %s\r\n", buf, clan[ch->clan_snoop].name);
    else
      sprintf(buf,"Your clan snoop level is invalid.");
    break;
d2994 12
a3005 1
  send_to_char(buf,ch);
d3008 4
a3011 22
ACMD(do_clan)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  
  half_chop(argument, arg1, arg2);
  
  if (is_abbrev(arg1, "create"  )) { do_clan_create(ch,arg2);   return ;}
  if (is_abbrev(arg1, "destroy" )) { do_clan_destroy(ch,arg2);  return ;}
  if (is_abbrev(arg1, "enroll"  )) { do_clan_enroll(ch,arg2);   return ;}
  if (is_abbrev(arg1, "expel"   )) { do_clan_expel(ch,arg2);    return ;}
  if (is_abbrev(arg1, "who"     )) { do_clan_who(ch,arg2);           return ;}
  if (is_abbrev(arg1, "status"  )) { do_clan_status(ch);        return ;}
  if (is_abbrev(arg1, "info"    )) { do_clan_info(ch,arg2);     return ;}
  if (is_abbrev(arg1, "apply"   )) { do_clan_apply(ch,arg2);    return ;}
  if (is_abbrev(arg1, "demote"  )) { do_clan_demote(ch,arg2);   return ;}
  if (is_abbrev(arg1, "promote" )) { do_clan_promote(ch,arg2);  return ;}
  if (is_abbrev(arg1, "set"     )) { do_clan_set(ch,arg2);      return ;}
  if (is_abbrev(arg1, "withdraw")) { do_clan_bank(ch,arg2,CB_WITHDRAW); return ;}
  if (is_abbrev(arg1, "deposit" )) { do_clan_bank(ch,arg2,CB_DEPOSIT);  return ;}
  if (is_abbrev(arg1, "snoop"   )) { do_clan_snoop(ch,arg2); return;}
  if (is_abbrev(arg1, "rename"   )) { do_clan_rename(ch,arg2); return;}
  send_clan_format(ch);
d3016 6
@


1.6
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: clan.c,v 1.5 2000/11/20 18:43:29 rsd Exp $
d49 1
a49 1
  if(GET_LEVEL(ch)>=LVL_CLAN_GOD)
d56 2
a57 2
		 "   clan withdraw   <clan number> <amount>\r\n"
		 "   clan deposit    <clan number> <amount>\r\n"
d65 1
a65 1
  else {
d1558 3
@


1.5
log
@Fixed the comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: clan.c,v 1.4 1999/09/05 07:00:39 jimmy Exp $
d1556 26
a1581 20
// $Log: clan.c,v $
// Revision 1.4  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.3  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to 
// clarify their behavior to the compiler.  The name approval code was also 
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the 
// xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
// --Gurlaek 6/10/1999 
//
// Revision 1.2  1999/01/30 18:04:01  mud
// indented entire file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.4
log
@Added RCS Log and Id strings to each source file
@
text
@d1 9
a9 5
// $Id$
/**************************************************************************
 * File: clan.c                                                     Hubis *
 * Usage: Code for the clan system                                        *
 **************************************************************************/
d1554 20
a1573 1
// $Log$
@


1.3
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1 1
d1550 1
@


1.2
log
@indented entire file
@
text
@d21 1
a21 1
extern save_char_file_u(struct char_file_u st);
d670 1
a670 1
  if(GET_CLAN_RANK(ch)==0)
d674 2
a675 1
      return; }
d678 3
a680 2
      return; }
  
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
"setplan","enroll","expel","promote","demote","setfees","withdraw","setapplev"};
d30 56
a85 56
int c,r;

send_to_char("Clan commands available to you:\n\r",ch);
if(GET_LEVEL(ch)>=LVL_CLAN_GOD){
  send_to_char("   clan who        <clan number>\r\n",ch);
  send_to_char("   clan snoop      <off | all | clan number >\r\n",ch);
  send_to_char("   clan rename     <clan number> <name>\r\n",ch);
}
else
  send_to_char("   clan who\r\n",ch);
send_to_char("   clan status\r\n"
             "   clan info       [clan number]\r\n",ch);
if(GET_LEVEL(ch)>=LVL_CLAN_GOD)
  send_to_char("   clan create     <leader> <clan name>\r\n"
               "   clan destroy    <clan number>\r\n"
               "   clan enroll     <player> <clan number>\r\n"
               "   clan expel      <player> <clan number>\r\n"
               "   clan promote    <player> <clan number>\r\n"
               "   clan demote     <player> <clan number>\r\n"
               "   clan withdraw   <clan number> <amount>\r\n"
               "   clan deposit    <clan number> <amount>\r\n"
               "   clan set ranks  <rank>   <clan number>\r\n"
               "   clan set appfee <amount> <clan number>\r\n"
               "   clan set dues   <amount> <clan number>\r\n"
               "   clan set applev <level>  <clan number>\r\n"
               "   clan set plan   <clan number>\r\n"
               "   clan privilege  <privilege>   <rank> <clan number>\r\n"
               "   clan set title  <clan number> <rank> <title>\r\n",ch);
else {
  c=find_clan_by_id(GET_CLAN(ch));
  r=GET_CLAN_RANK(ch);
  if(r<1)
    send_to_char("   clan apply      <clan number>\r\n",ch);
  if(c>=0) {
    send_to_char("   clan deposit    <amount>\r\n",ch);
    if(r>=clan[c].privilege[CP_WITHDRAW])
      send_to_char("   clan withdraw   <amount>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_ENROLL])
      send_to_char("   clan enroll     <player>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_EXPEL])
      send_to_char("   clan expel      <player>\r\n" ,ch);
    if(r>=clan[c].privilege[CP_PROMOTE])
      send_to_char("   clan promote    <player>\r\n",ch);
    if(r>=clan[c].privilege[CP_DEMOTE])
      send_to_char("   clan demote     <player>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_APPLEV])
      send_to_char("   clan set applev <level>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_FEES])
      send_to_char("   clan set appfee <amount>\r\n"
                   "   clan set dues   <amount>\r\n",ch);
    if(r>=clan[c].privilege[CP_SET_PLAN])
      send_to_char("   clan set plan\r\n",ch);
    if(r==clan[c].ranks)
      send_to_char("   clan set ranks  <rank>\r\n"
                   "   clan set title  <rank> <title>\r\n"
                   "   clan privilege  <privilege> <rank>\r\n",ch);
d99 19
a117 18
int i;
struct char_data *victim;
struct char_file_u chdata;

for(i=0;i<MAX_MEMBERS_PER_CLAN;i++) {
  if(!(clan[clan_num].member_list[i][0]))
    continue;
  if((victim=is_playing(clan[clan_num].member_list[i]))) {
    if(GET_CLAN(victim) == clan[clan_num].id) {
      sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(victim)-1], clan[clan_num].name);
      set_title(victim, buf);    
      save_char(victim, victim->in_room);
    }
    else {
      clan[clan_num].member_list[i][0] = '\0';
      if(ch){
        sprintf(buf,"%s was purged from %s&0's roster.\r\n",GET_NAME(victim),clan[clan_num].name);
        send_to_char(buf,ch);
a119 9
  }
  else {
    load_char(clan[clan_num].member_list[i], &chdata);
    if(chdata.player_specials_saved.clan==clan[clan_num].id) {
      sprintf(buf, "%s %s",clan[clan_num].rank_name[chdata.player_specials_saved.clan_rank - 1], clan[clan_num].name);
      buf[80] = '\0';
      strcpy(chdata.title,buf);
      save_char_file_u(chdata); 
    } 
d121 13
a133 4
      clan[clan_num].member_list[i][0] = '\0';
      if (ch){
        sprintf(buf,"%s was purged from %s&0's roster.\r\n",chdata.name,clan[clan_num].name);
        send_to_char(buf,ch);
d137 1
a137 2
}
save_clans();
d142 77
a218 77
struct char_data *leader = NULL;
char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
int new_id=0,i;

if (!*arg) {
  send_clan_format(ch);
  return; }

if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You are not mighty enough to create new clans!\r\n", ch);
  return; }

if(num_of_clans == MAX_CLANS) {
  send_to_char("Max clans reached. WOW!\r\n",ch);
  return; }

half_chop(arg, arg1, arg2);

if(!(leader=get_char_vis(ch,arg1))) {
  send_to_char("The leader of the new clan must be present.\r\n",ch);
  return; }

if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
  send_to_char("Clan name too long! (32 characters max)\r\n",ch);
  return; }

if(GET_LEVEL(leader)>=LVL_IMMORT) {
  send_to_char("You cannot set an immortal as the leader of a clan.\r\n",ch);
  return; }

if(GET_CLAN(leader)!=0 && GET_CLAN_RANK(leader)!=0) {
  send_to_char("The leader already belongs to a clan!\r\n",ch);
  return; }

if(find_clan(arg2)!=-1) {
  send_to_char("That clan name alread exists!\r\n",ch);
  return; }

strncpy(clan[num_of_clans].name, arg2, 100);
for(i=0;i<num_of_clans;i++)
  if(new_id<clan[i].id)
    new_id=clan[i].id;
clan[num_of_clans].id=new_id+1;
clan[num_of_clans].ranks =  2;
strcpy(clan[num_of_clans].rank_name[0],"Member");
strcpy(clan[num_of_clans].rank_name[1],"Leader");
clan[num_of_clans].treasure = 0 ;
clan[num_of_clans].plat = 0;
clan[num_of_clans].gold = 0;
clan[num_of_clans].silver = 0;
clan[num_of_clans].copper = 0;
clan[num_of_clans].members = 1 ;
clan[num_of_clans].power = GET_LEVEL(leader) ;
clan[num_of_clans].app_fee = 0 ;
clan[num_of_clans].dues = 0 ;
clan[num_of_clans].app_level = DEFAULT_APP_LVL ;
for(i=0;i<20;i++)
  clan[num_of_clans].spells[i]=0;
for(i=0;i<20;i++)
  clan[num_of_clans].privilege[i]=clan[num_of_clans].ranks;
for(i=0;i<4;i++)
  clan[num_of_clans].at_war[i]=0;
for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
  clan[num_of_clans].member_list[i][0] = '\0';
strcpy(clan[num_of_clans].member_list[0], GET_NAME(leader));
num_of_clans++;
save_clans();
send_to_char("Clan created.\r\n", ch);
GET_CLAN(leader)=clan[num_of_clans-1].id;
GET_CLAN_RANK(leader)=clan[num_of_clans-1].ranks;
sprintf(buf, "%s %s", clan[num_of_clans-1].rank_name[GET_CLAN_RANK(leader) -1],
		      clan[num_of_clans-1].name);
set_title(leader, buf);
save_char(leader, leader->in_room);
sprintf(buf, "%s created clan : %s", GET_NAME(ch), clan[num_of_clans-1].name);
log(buf);
return;
d223 33
a255 19
char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
int clan_num;

if (!*arg) {
  send_clan_format(ch);
  return; }

if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You are not mighty enough to rename clans!\r\n", ch);
  return; }

half_chop(arg, arg1, arg2);

if(!is_number(arg1)) {
  send_to_char("You need to specify a clan number.\r\n",ch);
  return;
}
if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
  send_to_char("There is no clan with that number.\r\n",ch);
a258 14
if(strlen(arg2)>=100 || strlen(strip_ansi(arg2))>=32) {
  send_to_char("Clan name too long! (32 characters max)\r\n",ch);
  return; }

if(find_clan(arg2)!=-1) {
  send_to_char("That clan name alread exists!\r\n",ch);
  return; }

strncpy(clan[clan_num].name, arg2, 100);
send_to_char("Clan renamed.\r\n", ch);
update_clan(ch, clan_num);
return;
}

d262 12
a273 83

int i,j;
extern int top_of_p_table;
extern struct player_index_element *player_table;
struct char_file_u chdata;
struct char_data *victim=NULL;

if (!*arg) {
  send_clan_format(ch);
  return; }

if(!is_number(arg)) {
  send_to_char("You need to specify a clan number.\r\n",ch);
  return;
}
if((i=atoi(arg))<0 || i>=num_of_clans) {
  send_to_char("There is no clan with that number.\r\n",ch);
  return;
}

if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
  send_to_char("Your not mighty enough to destroy clans!\r\n", ch);
  return; }

for (j = 0; j <= top_of_p_table; j++){
  if((victim=is_playing((player_table +j)->name))) {
    if(GET_CLAN(victim)==clan[i].id) {
      GET_CLAN(victim)=0;
      GET_CLAN_RANK(victim)=0;
      set_title(victim, "");
      save_char(victim, victim->in_room);
      send_to_char("&5&bYour clan has been destroyed!&0\r\n", victim); } }
  else {
    load_char((player_table + j)->name, &chdata);
    if(chdata.player_specials_saved.clan==clan[i].id) {
      chdata.player_specials_saved.clan=0;
      chdata.player_specials_saved.clan_rank=0;
      chdata.title[0] = '\0';
      save_char_file_u(chdata); } } }

sprintf(buf2, "%s has destroyed a clan: %s", GET_NAME(ch), clan[i].name);

memset(&clan[i], sizeof(struct clan_rec), 0);

for (j = i; j < num_of_clans - 1; j++)
  clan[j] = clan[j + 1];

num_of_clans--;

send_to_char("Clan deleted.\r\n", ch);
save_clans();
log(buf2);
return;
}

void do_clan_enroll (struct char_data *ch, char *arg)
{
struct char_data *vict=NULL;
int clan_num,immcom=0,i;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; 
}

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
  }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; 
  }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
 
  if(!is_number(arg2)) {
d277 1
a277 1
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
d281 34
d317 10
a326 3
if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ENROLL] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
d328 6
a333 12

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return;
}
else {
  if (clan[clan_num].members >= MAX_MEMBERS_PER_CLAN){
    if (GET_LEVEL(ch) >= LVL_IMMORT)
    send_to_char("That clan already has the maximum allowed members!\r\n",ch);
    else
    send_to_char("Your clan already has the maximum allowed members!\r\n",ch);
    return;
d335 11
a345 3
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    if(GET_CLAN_RANK(vict)>0) {
      send_to_char("They're already in a clan.\r\n",ch);
d348 2
a349 2
    else {
      send_to_char("They didn't request to join your clan.\r\n",ch);
d353 16
a368 3
  else
    if(GET_CLAN_RANK(vict)>0) {
      send_to_char("They're already in your clan.\r\n",ch);
d371 36
a406 21
  if(GET_LEVEL(vict)>=LVL_IMMORT) {
    send_to_char("You cannot enroll immortals in clans.\r\n",ch);
    return; }
}

GET_CLAN_RANK(vict)++;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
for(i=0;i<MAX_MEMBERS_PER_CLAN && clan[clan_num].member_list[i][0];i++);
strcpy(clan[clan_num].member_list[i], GET_NAME(vict));
clan[clan_num].power += GET_LEVEL(vict);
clan[clan_num].members++;
send_to_char("You've been enrolled in the clan you chose!\r\n",vict);
send_to_char("Your new title is:", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);

return;
d411 7
a417 16
struct char_data *vict=NULL;
int i,clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
d419 20
a438 6
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
d440 7
a446 16
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_EXPEL] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
d449 21
a469 17
    if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot kick out that person.\r\n",ch);
      return; } } }

GET_CLAN(vict)=0;
GET_CLAN_RANK(vict)=0;
set_title(vict, "");
save_char(vict, vict->in_room);
clan[clan_num].members--;
clan[clan_num].power-=GET_LEVEL(vict);
for(i=0;i<MAX_MEMBERS_PER_CLAN;i++)
  if (!strcmp(clan[clan_num].member_list[i],GET_NAME(vict)))
    clan[clan_num].member_list[i][0] = '\0';
send_to_char("You've been kicked out of your clan!\r\n",vict);
send_to_char("Done.\r\n",ch);

return;
d474 7
a480 16
struct char_data *vict=NULL;
int clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
d482 20
a501 6
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
d503 7
a509 16
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_DEMOTE] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
d512 2
a513 2
    if(GET_CLAN_RANK(vict)==1) {
      send_to_char("They can't be demoted any further, use expel now.\r\n",ch);
d515 19
a533 15
    if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot demote a person of this rank!\r\n",ch);
      return; } } }

GET_CLAN_RANK(vict)--;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
send_to_char("You've demoted within your clan!\r\n",vict);
send_to_char("Your new title is:", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);
return;
d538 25
a562 20
struct char_data *vict=NULL;
int clan_num,immcom=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; } }
else {
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
d564 7
a570 16
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_PROMOTE] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return; }

if(!(vict=get_char_room_vis(ch,arg))) {
  send_to_char("Er, Who ??\r\n",ch);
  return; }
else {
  if(GET_CLAN(vict)!=clan[clan_num].id) {
    send_to_char("They're not in your clan.\r\n",ch);
d573 2
a574 2
    if(GET_CLAN_RANK(vict)==0) {
      send_to_char("They're not enrolled yet.\r\n",ch);
d576 22
a597 18
    if((GET_CLAN_RANK(vict)+1)>GET_CLAN_RANK(ch) && !immcom) {
      send_to_char("You cannot promote that person over your rank!\r\n",ch);
      return; }
    if(GET_CLAN_RANK(vict)==clan[clan_num].ranks) {
      send_to_char("You cannot promote someone over the top rank!\r\n",ch);
      return; } } }

GET_CLAN_RANK(vict)++;
sprintf(buf, "%s %s", clan[clan_num].rank_name[GET_CLAN_RANK(vict) -1],
		      clan[clan_num].name);
set_title(vict, buf);
save_char(vict, vict->in_room);
send_to_char("You've been promoted within your clan!\r\n",vict);
send_to_char("Your new title is: ", vict);
send_to_char(buf, vict);
send_to_char("\r\n", vict);
send_to_char("Done.\r\n",ch);
return;
d602 18
a619 13
struct char_data *victim;
struct char_file_u chdata;
int k, j, i;


if(GET_CLAN_RANK(ch)==0 && GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_to_char("You do not belong to a clan!\r\n",ch);
  return; }

if(GET_LEVEL(ch) >= LVL_CLAN_GOD) {
  if (!arg) {
    send_to_char("You must specify a clan number.\r\n",ch);
    return;
d621 30
a650 25
  if((i=atoi(arg))<0 || i>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}
else
i = find_clan_by_id(GET_CLAN(ch));

if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
  sprintf(buf, "\r\n&3&bListing of clan members&0\r\n");
  sprintf(buf, "%s&3-----------------------&0\r\n",buf);
}
else{
  sprintf(buf, "\r\n&3&bMember listing for &0%s&0\r\n\r\n", clan[i].name);
}

for(k=clan[i].ranks;k>0;k--){
  for (j=0;j<MAX_MEMBERS_PER_CLAN;j++) {
    if(!(clan[i].member_list[j][0]))
      continue;
    if((victim=is_playing(clan[i].member_list[j]))) {
      if(GET_CLAN(victim)==clan[i].id && GET_CLAN_RANK(victim)==k) {
        if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	  sprintf(buf, "%s%2d", buf, j);
        sprintf(buf, "%s&0&2&bo&0 %-20.20s %s\r\n", buf,GET_NAME(victim),GET_TITLE(victim));
a652 9
    else {
      load_char(clan[i].member_list[j], &chdata);
      if(chdata.player_specials_saved.clan==clan[i].id 
         && chdata.player_specials_saved.clan_rank == k) {
        if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
	  sprintf(buf, "%s%2d", buf, j);
        sprintf(buf, "%s&0%-2.2s%-20.20s %s\r\n", buf,"",chdata.name,chdata.title);
      } 
    } 
d654 3
a656 4
}
page_string(ch->desc, buf, 1);

return;
d661 5
a665 13
char line_disp[200];
int clan_num;

if(GET_LEVEL(ch)>=LVL_IMMORT) {
  send_to_char("You are immortal and cannot join any clan!\r\n",ch);
  return; }

clan_num=find_clan_by_id(GET_CLAN(ch));

if(GET_CLAN_RANK(ch)==0)
  if(clan_num>=0) {
    sprintf(line_disp,"You applied to %s\r\n",clan[clan_num].name);
    send_to_char(line_disp,ch);
d667 18
a684 10
  else {
    send_to_char("You do not belong to a clan!\r\n",ch);
    return; }

 sprintf(line_disp,"You are %s (Rank %d) of %s (ID %d)\r\n",
    clan[clan_num].rank_name[GET_CLAN_RANK(ch)-1],GET_CLAN_RANK(ch),
    clan[clan_num].name,clan[clan_num].id);
 send_to_char(line_disp,ch);

return;
d689 34
a722 18
int clan_num;
struct char_data *vict;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)>=LVL_IMMORT) {
  send_to_char("Gods cannot apply for any clan.\r\n",ch);
  return; }

if(GET_CLAN_RANK(ch)>0) {
  send_to_char("You already belong to a clan!\r\n",ch);
  return; }
else {
  if(!(vict=get_char_room_vis(ch,arg))) {
    send_to_char("Er, Who ??\r\n",ch);
    return;
d724 17
a740 33
  if(!(GET_CLAN(vict)) || !(GET_CLAN_RANK(vict))) {
    send_to_char("They are not in a guild!\r\n",ch);
    return;
  }
  clan_num = find_clan_by_id(GET_CLAN(vict));
/*
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
*/
}

if(GET_LEVEL(ch) < clan[clan_num].app_level) {
  send_to_char("You are not mighty enough to apply to this clan.\r\n",ch);
  return; }

if(GET_PLAT(ch) < clan[clan_num].app_fee) {
  send_to_char("You cannot afford the application fee!\r\n", ch);
  return; }

GET_PLAT(ch) -= clan[clan_num].app_fee;
clan[clan_num].plat += clan[clan_num].app_fee;
save_clans();
GET_CLAN(ch)=clan[clan_num].id;
save_char(ch, ch->in_room);
sprintf(buf, "You've applied to %s&0!\r\n",clan[clan_num].name);
send_to_char(buf,ch);
return;
d745 26
a770 25
int i=0,j;

if(num_of_clans == 0) {
  send_to_char("No clans have formed yet.\r\n",ch);
  return; }

if(!(*arg)) {
  sprintf(buf, "\r");
  for(i=0; i < num_of_clans; i++)
    sprintf(buf, "%s[%-3d]  %-20s Members: %3d  Power: %5d  Appfee: %d &6&bPlatinum&0\r\n",buf,
    i, clan[i].name,clan[i].members,clan[i].power,clan[i].app_fee);
  page_string(ch->desc,buf, 1);
  return; }
else {
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((i=atoi(arg))<0 || i>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
  if(GET_LEVEL(ch) < LVL_IMMORT && clan[i].id != GET_CLAN(ch)) {
    send_to_char("That information is not available to you.\r\n",ch);
    return;
d772 31
a802 32
}

sprintf(buf, "Info for clan <<%s>>:\r\n",clan[i].name);
send_to_char(buf, ch);
sprintf(buf, "Ranks      : %d\r\nTitles     : ",clan[i].ranks);
for(j=0;j<clan[i].ranks;j++)
  sprintf(buf, "%s%s ",buf,clan[i].rank_name[j]);
sprintf(buf, "%s\r\nMembers    : %d\r\nPower      : %d\t\nTreasure   : %ld &6&bPlatinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\nSpells     : ",buf, clan[i].members, clan[i].power, clan[i].plat, clan[i].gold, clan[i].silver, clan[i].copper);
for(j=0; j<20;j++)
  if(clan[i].spells[j])
    sprintf(buf, "%s%d ",buf,clan[i].spells[j]);
sprintf(buf, "%s\r\n",buf);
send_to_char(buf, ch);
sprintf(buf,"Clan privileges:\r\n");
for(j=0; j<NUM_CP;j++)
  sprintf(buf, "%s   %-10s: %d\r\n",buf,clan_privileges[j],clan[i].privilege[j]);
sprintf(buf, "%s\r\n",buf);
send_to_char(buf, ch);
/*
sprintf(buf, "Description:\r\n%s\r\n\n", clan[i].description);
send_to_char(buf, ch);
*/
if((clan[i].at_war[0] == 0) && (clan[i].at_war[1] == 0) && (clan[i].at_war[2] == 0) && (clan[i].at_war[3] == 0))
  send_to_char("This clan is at peace with all others.\r\n", ch);
else
  send_to_char("This clan is at war.\r\n", ch);
sprintf(buf, "Application fee  : %d &6&bPlatinum&0\r\nMonthly Dues     : %d &6&bPlatinum&0\r\n", clan[i].app_fee, clan[i].dues);
send_to_char(buf, ch);
sprintf(buf, "Application level: %d\r\n", clan[i].app_level);
send_to_char(buf, ch);

return;
d807 5
a811 5
int i;
for( i=0; i < num_of_clans; i++)
  if(idnum==clan[i].id)
    return i;
return -1;
d816 5
a820 5
int i;
for( i=0; i < num_of_clans; i++)
  if(strcmp(CAP(name), CAP(clan[i].name))==0)
    return i;
return -1;
d825 10
a834 10
FILE *fl;

if (!(fl = fopen(CLAN_FILE, "wb"))) {
  log("SYSERR: Unable to open clan file");
  return; }

fwrite(&num_of_clans, sizeof(int), 1, fl);
fwrite(clan, sizeof(struct clan_rec), num_of_clans, fl);
fclose(fl);
return;
d840 30
a869 29
FILE *fl;
int i,j;
extern int top_of_p_table;
extern struct player_index_element *player_table;
struct char_file_u chdata;

memset(clan,0,sizeof(struct clan_rec)*MAX_CLANS);
num_of_clans=0;
i=0;

if (!(fl = fopen(CLAN_FILE, "rb"))) {
  log("   Clan file does not exist. Will create a new one");
  save_clans();
  return; }

fread(&num_of_clans, sizeof(int), 1, fl);
fread(clan, sizeof(struct clan_rec), num_of_clans, fl);
fclose(fl);

log("   Calculating powers and members");
for(i=0;i<num_of_clans;i++) {
  clan[i].power=0;
  clan[i].members=0;
}
for (j = 0; j <= top_of_p_table; j++){
  load_char((player_table + j)->name, &chdata);
  if((i=find_clan_by_id(chdata.player_specials_saved.clan))>=0) {
    clan[i].power+=chdata.level;
    clan[i].members++;
d871 2
a872 3
}

return;
d877 32
a908 15
int i,clan_num,immcom=0; 
long plat=0,gold=0,silver=0,copper=0,amount=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];
char arg3[MAX_INPUT_LENGTH];
char arg4[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
d910 4
a913 10
  strcpy(arg2,arg);
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d916 3
a918 2
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d921 29
a949 6
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_WITHDRAW] && !immcom && action
==CB_WITHDRAW) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
d951 4
a954 4

if(!(*arg2)) {
  send_to_char("Deposit how much?\r\n",ch);
  return;
d956 6
a961 41

for (i=0;i<4;i++){
  half_chop(arg2,arg3,arg2);
  half_chop(arg2,arg4,arg2);
  if(!(*arg3) || !(*arg4)) 
    continue;
  if(!is_number(arg3)) {
    send_to_char("Wrong money format.\r\nUse format: <number> p <number> g <number> s <number> c\r\n",ch);
  return;
  }
  amount=atoi(arg3);
  switch(*arg4) {
  case 'p':
    plat += amount;
    break;
  case 'g':
    gold += amount;
    break;
  case 's':
    silver += amount;
    break;
  case 'c':
    copper += amount;
    break;
  default:
    send_to_char("Wrong money type.\r\n",ch);
    break;
  }

}
if(!immcom && action==CB_DEPOSIT && (GET_PLAT(ch)<plat || GET_GOLD(ch)<gold 
   || GET_SILVER(ch)<silver || GET_COPPER(ch)<copper)) {
  send_to_char("You do not have that kind of money!\r\n",ch);
  return;
  }

if(action==CB_WITHDRAW && (clan[clan_num].plat<plat 
   || clan[clan_num].gold<gold || clan[clan_num].silver<silver
   || clan[clan_num].copper<copper)) {
  send_to_char("The clan is not wealthy enough for your needs!\r\n",ch);
  return;
d963 2
a964 2

switch(action) {
d993 6
a998 6
sprintf(buf,"%s%ld &b&6Platinum&0 %ld &3&bGold&0 %ld &7Silver&0 %ld &3Copper&0\r\n"
    ,buf,plat,gold,silver,copper);
send_to_char(buf, ch);
save_char(ch, ch->in_room);
save_clans();
return;
d1003 34
a1036 12
int clan_num,immcom=0;
long amount=0;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
d1039 3
a1041 10
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d1044 3
a1046 2
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d1049 4
a1052 20
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_FEES] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
  }

if(!(*arg)) {
  send_to_char("Set it to how much?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set it to what?\r\n",ch);
  return;
  }

amount=atoi(arg);

switch(action) {
d1065 3
a1067 3

save_clans();
return;
d1072 37
a1108 15
int i,j;
int clan_num,immcom=0;
int new_ranks;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];
struct char_file_u chdata;
struct char_data *victim=NULL;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
d1111 3
a1113 10
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d1116 3
a1118 2
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d1121 6
a1126 5
}

if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
d1128 4
a1131 4

if(!(*arg)) {
  send_to_char("Set how many ranks?\r\n",ch);
  return;
d1133 22
a1154 38

if(!is_number(arg)) {
  send_to_char("Set the ranks to what?\r\n",ch);
  return;
  }

new_ranks=atoi(arg);

if(new_ranks==clan[clan_num].ranks) {
  send_to_char("The clan already has this number of ranks.\r\n",ch);
  return;
  }

if(new_ranks<2 || new_ranks>20) {
  send_to_char("Clans must have from 2 to 20 ranks.\r\n",ch);
  return;
  }

/*
if(GET_PLAT(ch)<1000 && !immcom) {
  send_to_char("Changing the clan hierarchy requires 1,000 plat!\r\n",ch);
  return;
  }

if(!immcom)
  GET_PLAT(ch)-=1000;
*/

for (j = 0; j < MAX_MEMBERS_PER_CLAN; j++) {
  if (!clan[clan_num].member_list[j][0])
    continue;
  if((victim=is_playing(clan[clan_num].member_list[j]))) {
    if(GET_CLAN(victim)==clan[clan_num].id) {
      if(GET_CLAN_RANK(victim)<clan[clan_num].ranks && GET_CLAN_RANK(victim)>0)
        GET_CLAN_RANK(victim)=1;
      if(GET_CLAN_RANK(victim)==clan[clan_num].ranks)
        GET_CLAN_RANK(victim)=new_ranks;
      save_char(victim, victim->in_room);
d1156 10
a1165 10
  }
  else {
    load_char(clan[clan_num].member_list[j], &chdata);
    if(chdata.player_specials_saved.clan==clan[clan_num].id) {
      if(chdata.player_specials_saved.clan_rank<clan[clan_num].ranks && chdata.
player_specials_saved.clan_rank>0)
        chdata.player_specials_saved.clan_rank=1;
      if(chdata.player_specials_saved.clan_rank==clan[clan_num].ranks)
        chdata.player_specials_saved.clan_rank=new_ranks;
      save_char_file_u(chdata);
d1168 11
a1178 12
}

clan[clan_num].ranks=new_ranks;
for(i=0;i<clan[clan_num].ranks-1;i++)
  strcpy(clan[clan_num].rank_name[i],"Member");
strcpy(clan[clan_num].rank_name[clan[clan_num].ranks -1],"Leader");
for(i=0;i<NUM_CP;i++)
  clan[clan_num].privilege[i]=new_ranks;

update_clan(ch, clan_num);
save_clans();
return;
d1183 16
a1198 11
char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
int clan_num=0,rank;

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return;
d1200 14
a1213 3
  if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return;
d1215 1
a1215 5
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
d1217 1
a1217 1
  strcpy(arg,arg2);
d1219 18
a1236 30
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
  }
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
  }
}

half_chop(arg,arg1,arg2);

if(!is_number(arg1)) {
  send_to_char("You need to specify a rank number.\r\n",ch);
  return; }

rank=atoi(arg1);

if(rank<1 || rank>clan[clan_num].ranks) {
  send_to_char("This clan has no such rank number.\r\n",ch);
  return; }

if(strlen(arg2)<1 || strlen(arg2)>29) {
  send_to_char("You need a clan title of under 30 characters.\r\n",ch);
  return; }

strcpy(clan[clan_num].rank_name[rank-1],arg2);
save_clans();
send_to_char("Done.\r\n",ch);
update_clan(ch, clan_num);
return;
d1241 34
a1274 12
int clan_num,immcom=0;
int applevel;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
d1277 3
a1279 10
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg2)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d1282 3
a1284 2
  if((clan_num=atoi(arg2))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d1287 6
a1292 5
}

if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_APPLEV] && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
d1294 4
a1297 15

if(!(*arg)) {
  send_to_char("Set to which level?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set the application level to what?\r\n",ch);
  return;
  }

applevel=atoi(arg);

if(applevel<1 || applevel>999) {
  send_to_char("The application level can go from 1 to 999.\r\n",ch);
a1298 6
  }

clan[clan_num].app_level=applevel;
save_clans();

return;
d1303 35
a1337 13
int clan_num,immcom=0;
int rank;
char arg1[MAX_INPUT_LENGTH];
char arg2[MAX_INPUT_LENGTH];

if (!(*arg)) {
  send_clan_format(ch);
  return; }


if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
d1340 3
a1342 10
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  immcom=1;
  half_chop(arg,arg1,arg2);
  strcpy(arg,arg1);
  if(!is_number(arg1)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
d1345 3
a1347 2
  if((clan_num=atoi(arg1))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
d1350 6
a1355 5
}

if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks && !immcom) {
  send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
  return;
d1357 4
a1360 15

if(!(*arg)) {
  send_to_char("Set the privilege to which rank?\r\n",ch);
  return;
  }

if(!is_number(arg)) {
  send_to_char("Set the privilege to what?\r\n",ch);
  return;
  }

rank=atoi(arg);

if(rank<1 || rank>clan[clan_num].ranks) {
  send_to_char("There is no such rank in the clan.\r\n",ch);
a1361 6
  }

clan[clan_num].privilege[priv]=rank;
save_clans();

return;
d1366 28
a1393 23
int clan_num;

send_to_char("Command not ready yet\r\n",ch);
return;

if(GET_LEVEL(ch)<LVL_IMMORT) {
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; }
  if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_SET_PLAN]) {
    send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
    return; }
}
else {
  if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
    send_to_char("You do not have clan privileges.\r\n", ch);
    return; }
  if (!(*arg)) {
    send_clan_format(ch);
    return; }
  if(!is_number(arg)) {
    send_to_char("You need to specify a clan number.\r\n",ch);
    return;
d1395 4
a1398 3
  if((clan_num=atoi(arg))<0 || clan_num>=num_of_clans) {
    send_to_char("There is no clan with that number.\r\n",ch);
    return;
d1400 11
a1410 17
}

if(strlen(clan[clan_num].description)==0) {
   sprintf(buf, "Enter the description, or plan for clan <<%s>>.\r\n",clan[clan_num].name);
   send_to_char(buf, ch);
}
else {
   sprintf(buf, "Old plan for clan <<%s>>:\r\n", clan[clan_num].name);
   send_to_char(buf, ch);
   send_to_char(clan[clan_num].description, ch);
   send_to_char("Enter new plan:\r\n", ch);
}
send_to_char("End with @@ on a line by itself.\r\n", ch);
/*ch->desc->str   = clan[clan_num].description;*/
ch->desc->max_str = CLAN_PLAN_LENGTH;
save_clans();
return;
d1415 17
a1431 17
char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
int i;

half_chop(arg,arg1,arg2);

if (is_abbrev(arg1,"setplan"  )) { do_clan_sp(ch,arg2,CP_SET_PLAN);   return ;}
if (is_abbrev(arg1,"enroll"   )) { do_clan_sp(ch,arg2,CP_ENROLL);     return ;}
if (is_abbrev(arg1,"expel"    )) { do_clan_sp(ch,arg2,CP_EXPEL);      return ;}
if (is_abbrev(arg1,"promote"  )) { do_clan_sp(ch,arg2,CP_PROMOTE);    return ;}
if (is_abbrev(arg1,"demote"   )) { do_clan_sp(ch,arg2,CP_DEMOTE);     return ;}
if (is_abbrev(arg1,"withdraw" )) { do_clan_sp(ch,arg2,CP_WITHDRAW);   return ;}
if (is_abbrev(arg1,"setfees"  )) { do_clan_sp(ch,arg2,CP_SET_FEES);   return ;}
if (is_abbrev(arg1,"setapplev")) { do_clan_sp(ch,arg2,CP_SET_APPLEV); return ;}
send_to_char("\r\nClan privileges:\r\n", ch);
for(i=0;i<NUM_CP;i++) {
  sprintf(arg1,"\t%s\r\n",clan_privileges[i]);
  send_to_char(arg1,ch); }
d1436 19
a1454 19
char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];

half_chop(arg,arg1,arg2);

if (is_abbrev(arg1, "plan"      )) { do_clan_plan(ch,arg2);            return ;
}
if (is_abbrev(arg1, "ranks"     )) { do_clan_ranks(ch,arg2);           return ;
}
if (is_abbrev(arg1, "title"     )) { do_clan_titles(ch,arg2);          return ;
}
if (is_abbrev(arg1, "privilege" )) { do_clan_privilege(ch,arg2);       return ;
}
if (is_abbrev(arg1, "dues"      )) { do_clan_money(ch,arg2,CM_DUES);   return ;
}
if (is_abbrev(arg1, "appfee"    )) { do_clan_money(ch,arg2,CM_APPFEE); return ;
}
if (is_abbrev(arg1, "applev"    )) { do_clan_application(ch,arg2);     return ;
}
send_clan_format(ch);
d1459 9
a1467 9
int i;

if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
  send_clan_format(ch);
  return;
}
if(!(*arg)) {
  sprintf(buf, "You are currently snooping");
  switch(ch->clan_snoop) {
d1480 3
d1484 11
a1494 9
  send_to_char(buf,ch);
  return;
}
else { 
  if(!is_number(arg)) {
    if(is_abbrev(arg, "off"))
      ch->clan_snoop = -2;  
    else if(is_abbrev(arg, "all"))
      ch->clan_snoop = -1;
d1496 6
a1501 8
      send_to_char("That is an invalid selection.\r\n",ch);
      return;
    }
  }
  else {
    if((i=atoi(arg))<0 || i>=num_of_clans) {
     send_to_char("That is an invalid number.\r\n",ch);
     return;
d1503 13
d1517 2
a1518 1
     ch->clan_snoop = atoi(arg);
d1520 1
a1520 18
} 

sprintf(buf, "Your are now snooping");
  switch(ch->clan_snoop) {
    case -2:
      sprintf(buf,"%s no clans.\r\n",buf);
      break;
    case -1:
      sprintf(buf,"%s all clans.\r\n",buf);
      break;
    default:
      if (ch->clan_snoop>=0 && ch->clan_snoop<num_of_clans)
        sprintf(buf,"%s %s\r\n", buf, clan[ch->clan_snoop].name);
      else
        sprintf(buf,"Your clan snoop level is invalid.");
      break;
  }
send_to_char(buf,ch);
d1525 21
a1545 3
char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

half_chop(argument, arg1, arg2);
a1546 17
if (is_abbrev(arg1, "create"  )) { do_clan_create(ch,arg2);   return ;}
if (is_abbrev(arg1, "destroy" )) { do_clan_destroy(ch,arg2);  return ;}
if (is_abbrev(arg1, "enroll"  )) { do_clan_enroll(ch,arg2);   return ;}
if (is_abbrev(arg1, "expel"   )) { do_clan_expel(ch,arg2);    return ;}
if (is_abbrev(arg1, "who"     )) { do_clan_who(ch,arg2);           return ;}
if (is_abbrev(arg1, "status"  )) { do_clan_status(ch);        return ;}
if (is_abbrev(arg1, "info"    )) { do_clan_info(ch,arg2);     return ;}
if (is_abbrev(arg1, "apply"   )) { do_clan_apply(ch,arg2);    return ;}
if (is_abbrev(arg1, "demote"  )) { do_clan_demote(ch,arg2);   return ;}
if (is_abbrev(arg1, "promote" )) { do_clan_promote(ch,arg2);  return ;}
if (is_abbrev(arg1, "set"     )) { do_clan_set(ch,arg2);      return ;}
if (is_abbrev(arg1, "withdraw")) { do_clan_bank(ch,arg2,CB_WITHDRAW); return ;}
if (is_abbrev(arg1, "deposit" )) { do_clan_bank(ch,arg2,CB_DEPOSIT);  return ;}
if (is_abbrev(arg1, "snoop"   )) { do_clan_snoop(ch,arg2); return;}
if (is_abbrev(arg1, "rename"   )) { do_clan_rename(ch,arg2); return;}
send_clan_format(ch);
}
@
