head	1.131;
access;
symbols;
locks; strict;
comment	@ * @;


1.131
date	2011.08.18.00.13.14;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2009.06.10.20.14.48;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.09.05.38.52;	author myc;	state Exp;
branches;
next	1.128;

1.128
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2009.03.17.07.59.42;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2009.03.06.00.46.31;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.118;

1.118
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.117;

1.117
date	2008.09.02.07.16.00;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2008.08.26.03.58.13;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2008.08.24.02.34.14;	author myc;	state Exp;
branches;
next	1.114;

1.114
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2008.06.20.20.21.44;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.108;

1.108
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.107;

1.107
date	2008.04.14.07.16.48;	author jps;	state Exp;
branches;
next	1.106;

1.106
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2008.04.05.19.43.15;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2008.03.21.21.41.58;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2008.03.21.21.36.31;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2008.03.16.00.21.16;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2008.03.10.19.55.37;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2008.02.16.07.02.15;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.02.13.21.10.14;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2008.02.11.08.50.33;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.06.03.45.08;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2008.02.04.00.22.05;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.02.19.56.51;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.01.06.44.29;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.01.06.32.23;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.19.02.17.08;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.18.20.30.31;	author myc;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.18.08.28.43;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.18.07.11.55;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.17.19.23.07;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.17.07.40.32;	author myc;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.17.06.24.23;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.17.06.19.47;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.17.04.19.07;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.17.04.10.07;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.17.02.44.16;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.17.01.51.40;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.09.02.30.56;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.20.23.19.00;	author myc;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.20.23.12.29;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.17.22.29.59;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.30.19.42.46;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.30.09.10.44;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.26.22.37.37;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.24.17.01.36;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.24.10.24.04;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.14.08.48.11;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.08.20.21.10;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.08.20.09.42;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.29.00.36.03;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.29.00.04.19;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.11.19.34.15;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.18.21.58.11;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.17.23.53.23;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.08.05.09.32;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.13.03.17.06;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.07.10.44.13;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.01.06.02.01;	author jjl;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.29.01.42.11;	author jjl;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.13.23.04.45;	author jjl;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.12.05.45.35;	author jjl;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.10.03.56.57;	author jjl;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.09.04.57.49;	author jjl;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.08.00.30.06;	author dce;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.07.03.13.09;	author dce;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.06.23.54.04;	author dce;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.03.21.25.00;	author mtp;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.03.19.48.56;	author mtp;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.25.06.59.02;	author mtp;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.19.23.57.11;	author mtp;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.12.01.26.52;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.21.23.29.49;	author mtp;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.28.01.16.25;	author mtp;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.22.00.37.38;	author mtp;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.21.04.13.38;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.09.23.59.54;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.07.01.53.34;	author mtp;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.30.18.32.35;	author mtp;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.29.16.59.12;	author mtp;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.01.23.43.29;	author mtp;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.04.00.22.16;	author mtp;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.17.07.32.27;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.16.08.13.14;	author mtp;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.13.07.34.13;	author mtp;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.11.00.29.37;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.02.22.54.25;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.01.57.43;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/**************************************************************************
*  File: scripts.c                                                        *
*  Usage: contains general functions for using scripts.                   *
*                                                                         *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/24 03:48:42 $
*  $Revision: 3.25 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "dg_event.h"
#include "db.h"
#include "screen.h"

#define PULSES_PER_MUD_HOUR     (SECS_PER_MUD_HOUR*PASSES_PER_SEC)


/* external vars from db.c */
extern int top_of_trigt;
extern struct index_data **trig_index;

/* external vars from triggers.c */
extern char *trig_types[], *otrig_types[], *wtrig_types[];

/* other external vars */
extern struct room_data *world;
extern int top_of_world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern char *item_types[];
extern char *genders[];
extern char *pc_class_types[];
extern char *pc_race_types[];
extern char *exit_bits[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;

/* external functions */
int find_target_room(char_data * ch, char *rawroomstr);
void free_varlist(struct trig_var_data *vd);
int obj_room(obj_data *obj);
int is_empty(int zone_nr);
int find_target_room(struct char_data * ch, char *rawroomstr);
trig_data *read_trigger(int nr);
struct obj_data *get_object_in_equip(struct char_data * ch, char *name, int *i);
void extract_trigger(struct trig_data *trig);
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
		    trig_data *trig, int type);


/* function protos from this file */
int script_driver(void *go, trig_data *trig, int type, int mode);
int trgvar_in_room(int vnum);
void script_log(char *msg);
struct cmdlist_element *find_done(struct cmdlist_element *cl);
struct cmdlist_element * \
  find_case(struct trig_data *trig, struct cmdlist_element *cl, \
          void *go, struct script_data *sc, int type, char *cond);

/* local structures */
struct wait_event_data {
  trig_data *trigger;
  void *go;
  int type;
};


struct trig_data *trigger_list = NULL;  /* all attached triggers */

/* Return pointer to first occurrence in string ct in */
/* cs, or NULL if not present.  Case insensitive */
char *str_str(char *cs, char *ct)
{
  char *s, *t;

  if (!cs || !ct)
    return NULL;

  while (*cs) {
    t = ct;

    while (*cs && (LOWER(*cs) != LOWER(*t)))
      cs++;

    s = cs;

    while (*t && *cs && (LOWER(*cs) == LOWER(*t))) {
      t++;
      cs++;
    }

    if (!*t)
      return s;
  }

  return NULL;
}


int trgvar_in_room(int vnum) {
    int i = 0;
    char_data *ch;

    if (NOWHERE == real_room(vnum)) {
	script_log("people.vnum: world[vnum] does not exist");
	return (-1);
    }

    for (ch = world[vnum].people; ch !=NULL; ch = ch->next_in_room)
	i++;

    return i;
}

obj_data *get_obj_in_list(char *name, obj_data *list)
{
    obj_data *i;
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);

        for (i = list; i; i = i->next_content)
            if (id == GET_ID(i))
                return i;
    }
    else
    {
        for (i = list; i; i = i->next_content)
            if (isname(name, i->name))
                return i;
    }

    return NULL;
}

obj_data *get_object_in_equip(char_data * ch, char *name, int *i)
{
    int j, n = 0, number;
    obj_data *obj;
    char tmpname[MAX_INPUT_LENGTH];
    char *tmp = tmpname;
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);

        for (j = 0; j < NUM_WEARS; j++)
            if ((obj = GET_EQ(ch, j)))
                if (id == GET_ID(obj)){
		    (*i) = j;
                    return (obj);
		}
    }
    else
    {
        strcpy(tmp, name);
        if (!(number = get_number(&tmp)))
            return NULL;

        for (j = 0; (j < NUM_WEARS) && (n <= number); j++)
            if ((obj = GET_EQ(ch, j)))
                if (isname(tmp, obj->name))
                    if (++n == number) {
			(*i) = j;
                        return (obj);
		    }
    }

    return NULL;
}

/************************************************************
 * search by number routines
 ************************************************************/

/* return char with UID n */
struct char_data *find_char(int n)
{
  struct char_data *ch;

  for (ch = character_list; ch; ch=ch->next)
  {
    if (GET_ID(ch)==n) return (ch);
  }

  return NULL;
}


/* return object with UID n */
obj_data *find_obj(int n)
{
    obj_data *i;

    for (i = object_list; i; i = i->next)
        if (n == GET_ID(i))
            return i;

    return NULL;
}

/* return room with UID n */
room_data *find_room(int n)
{
    n -= ROOM_ID_BASE;

    if ((n >= 0) && (n <= top_of_world))
        return &world[n];

    return NULL;
}



/************************************************************
 * generic searches based only on name
 ************************************************************/

/* search the entire world for a char, and return a pointer */
char_data *get_char(char *name)
{
    char_data *i;

    if (*name == UID_CHAR)
    {
        i = find_char(atoi(name + 1));

        if (i && !GET_INVIS_LEV(i))
            return i;
    }
    else
    {
        for (i = character_list; i; i = i->next)
            if (isname(name, i->player.name) &&
                !GET_INVIS_LEV(i))
                return i;
    }

    return NULL;
}


/* returns the object in the world with name name, or NULL if not found */
obj_data *get_obj(char *name)
{
    obj_data *obj;
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);

        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
    }
    else
    {
        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
    }

    return NULL;
}


/* finds room by with name.  returns NULL if not found */
room_data *get_room(char *name)
{
    int nr;

    if (*name == UID_CHAR)
        return find_room(atoi(name + 1));
    else if ((nr = real_room(atoi(name))) == NOWHERE)
        return NULL;
    else
        return &world[nr];
}


/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching with the person owing the object
 */
char_data *get_char_by_obj(obj_data *obj, char *name)
{
    char_data *ch;

    if (*name == UID_CHAR)
    {
        ch = find_char(atoi(name + 1));

        if (ch && !GET_INVIS_LEV(ch))
            return ch;
    }
    else
    {
        if (obj->carried_by &&
            isname(name, obj->carried_by->player.name) &&
            !GET_INVIS_LEV(obj->carried_by))
            return obj->carried_by;

        if (obj->worn_by &&
            isname(name, obj->worn_by->player.name) &&
            !GET_INVIS_LEV(obj->worn_by))
            return obj->worn_by;

        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;
    }

    return NULL;
}


/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching in room room first
 */
char_data *get_char_by_room(room_data *room, char *name)
{
    char_data *ch;

    if (*name == UID_CHAR)
    {
        ch = find_char(atoi(name + 1));

        if (ch && !GET_INVIS_LEV(ch))
            return ch;
    }
    else
    {
        for (ch = room->people; ch; ch = ch->next_in_room)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;

        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;
    }

    return NULL;
}


/*
 * returns the object in the world with name name, or NULL if not found
 * search based on obj
 */
obj_data *get_obj_by_obj(obj_data *obj, char *name)
{
    obj_data *i = NULL;
    int rm, wear;
    long id;

    if (!str_cmp(name, "self") || !str_cmp(name, "me"))
        return obj;

    if (obj->contains && (i = get_obj_in_list(name, obj->contains)))
        return i;

    if (obj->in_obj)
    {
        if (*name == UID_CHAR)
        {
            id = atoi(name + 1);

            if (id == GET_ID(obj->in_obj))
                return obj->in_obj;
        }
        else if (isname(name, obj->in_obj->name))
            return obj->in_obj;
    }

    else if (obj->worn_by && (i = get_object_in_equip(obj->worn_by, name, &wear)))
        return i;
    else if (obj->carried_by &&
             (i = get_obj_in_list(name, obj->carried_by->carrying)))
        return i;
    else if (((rm = obj_room(obj)) != NOWHERE) &&
             (i = get_obj_in_list(name, world[rm].contents)))
        return i;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);

        for (i = object_list; i; i = i->next)
            if (id == GET_ID(i))
                break;
    }

    else
    {
        for (i = object_list; i; i = i->next)
            if (isname(name, i->name))
                break;
    }

    return i;
}


/* returns obj with name */
obj_data *get_obj_by_room(room_data *room, char *name)
{
    obj_data *obj;
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);

        for (obj = room->contents; obj; obj = obj->next_content)
            if (id == GET_ID(obj))
                return obj;

        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
    }
    else
    {
        for (obj = room->contents; obj; obj = obj->next_content)
            if (isname(name, obj->name))
                return obj;

        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
    }

    return NULL;
}



/* checks every PLUSE_SCRIPT for random triggers */
void script_trigger_check(void)
{
  char_data *ch;
  obj_data *obj;
  struct room_data *room=NULL;
  int nr;
  struct script_data *sc;

  for (ch = character_list; ch; ch = ch->next) {
    if (SCRIPT(ch)) {
      sc = SCRIPT(ch);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
	  (!is_empty(world[IN_ROOM(ch)].zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_mtrigger(ch);
    }
  }

  for (obj = object_list; obj; obj = obj->next) {
    if (SCRIPT(obj)) {
      sc = SCRIPT(obj);

      if (IS_SET(SCRIPT_TYPES(sc), OTRIG_RANDOM))
	random_otrigger(obj);
    }
  }

  for (nr = 0; nr <= top_of_world; nr++) {
    if (SCRIPT(&world[nr])) {
      room = &world[nr];
      sc = SCRIPT(room);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
	  (!is_empty(room->zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_wtrigger(room);
    }
  }
}


EVENT(trig_wait_event)
{
  struct wait_event_data *wait_event_obj = (struct wait_event_data *)info;
  trig_data *trig;
  void *go;
  int type;

  trig = wait_event_obj->trigger;
  go = wait_event_obj->go;
  type = wait_event_obj->type;

  free(wait_event_obj);
  GET_TRIG_WAIT(trig) = NULL;

  script_driver(go, trig, type, TRIG_RESTART);
}


void do_stat_trigger(struct char_data *ch, trig_data *trig)
{
    struct cmdlist_element *cmd_list;
    char sb[MAX_STRING_LENGTH];

    if (!trig)
    {
	log("SYSERR: NULL trigger passed to do_stat_trigger.");
	return;
    }

    sprintf(sb, "Name: '%s%s%s',  VNum: [%s%5d%s], RNum: [%5d]\r\n",
	      CCYEL(ch, C_NRM), GET_TRIG_NAME(trig), CCNRM(ch, C_NRM),
	      CCGRN(ch, C_NRM), GET_TRIG_VNUM(trig), CCNRM(ch, C_NRM),
	      GET_TRIG_RNUM(trig));

    if (trig->attach_type==OBJ_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), otrig_types, buf);
    } else if (trig->attach_type==WLD_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), wtrig_types, buf);
    } else {
      send_to_char("Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), trig_types, buf);
    }

    sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
	      buf, GET_TRIG_NARG(trig),
	      ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig))
	       ? GET_TRIG_ARG(trig) : "None"));

    strcat(sb,"Commands:\r\n   ");

    cmd_list = trig->cmdlist;
    while (cmd_list)
    {
	if (cmd_list->cmd)
	{
	    strcat(sb,cmd_list->cmd);
	    strcat(sb,"\r\n   ");
	}

	cmd_list = cmd_list->next;
    }

    page_string(ch->desc, sb, 1);
}


/* find the name of what the uid points to */
void find_uid_name(char *uid, char *name)
{
  char_data *ch;
  obj_data *obj;

  if ((ch = get_char(uid)))
    strcpy(name, ch->player.name);
  else if ((obj = get_obj(uid)))
    strcpy(name, obj->name);
  else
    sprintf(name, "uid = %s, (not found)", uid + 1);
}


/* general function to display stats on script sc */
void script_stat (char_data *ch, struct script_data *sc)
{
  struct trig_var_data *tv;
  trig_data *t;
  char name[MAX_INPUT_LENGTH];

  sprintf(buf, "Global Variables: %s\r\n", sc->global_vars ? "" : "None");
  send_to_char(buf, ch);

  for (tv = sc->global_vars; tv; tv = tv->next) {
    if (*(tv->value) == UID_CHAR) {
      find_uid_name(tv->value, name);
      sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
    } else
      sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
    send_to_char(buf, ch);
  }

  for (t = TRIGGERS(sc); t; t = t->next) {
    sprintf(buf, "\r\n  Trigger: %s%s%s, VNum: [%s%5d%s], RNum: [%5d]\r\n",
	    CCYEL(ch, C_NRM), GET_TRIG_NAME(t), CCNRM(ch, C_NRM),
	    CCGRN(ch, C_NRM), GET_TRIG_VNUM(t), CCNRM(ch, C_NRM),
	    GET_TRIG_RNUM(t));
    send_to_char(buf, ch);

    if (t->attach_type==OBJ_TRIGGER) {
      send_to_char("  Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), otrig_types, buf1);
    } else if (t->attach_type==WLD_TRIGGER) {
      send_to_char("  Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), wtrig_types, buf1);
    } else {
      send_to_char("  Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), trig_types, buf1);
    }

    sprintf(buf, "  Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
	    buf1, GET_TRIG_NARG(t),
	    ((GET_TRIG_ARG(t) && *GET_TRIG_ARG(t)) ? GET_TRIG_ARG(t) :
	     "None"));
    send_to_char(buf, ch);

#if 0
    if (GET_TRIG_WAIT(t)) {
      sprintf(buf, "    Wait: %ld, Current line: %s\r\n",
	      time_to_event(GET_TRIG_WAIT(t)), t->curr_state->cmd);
      send_to_char(buf, ch);

      sprintf(buf, "  Variables: %s\r\n", GET_TRIG_VARS(t) ? "" : "None");
      send_to_char(buf, ch);

      for (tv = GET_TRIG_VARS(t); tv; tv = tv->next) {
	if (*(tv->value) == UID_CHAR) {
	  find_uid_name(tv->value, name);
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
	} else
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
	send_to_char(buf, ch);
      }
    }
#endif
  }
}


void do_sstat_room(struct char_data * ch)
{
  struct room_data *rm = &world[ch->in_room];

  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(rm)) {
    send_to_char("  None.\r\n", ch);
    return;
  }

  script_stat(ch, SCRIPT(rm));
}


void do_sstat_object(char_data *ch, obj_data *j)
{
  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(j)) {
    send_to_char("  None.\r\n", ch);
    return;
  }

  script_stat(ch, SCRIPT(j));
}


void do_sstat_character(char_data *ch, char_data *k)
{
  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(k)) {
    send_to_char("  None.\r\n", ch);
    return;
  }

  script_stat(ch, SCRIPT(k));
}


/*
 * adds the trigger t to script sc in in location loc.  loc = -1 means
 * add to the end, loc = 0 means add before all other triggers.
 */
void add_trigger(struct script_data *sc, trig_data *t, int loc)
{
  trig_data *i;
  int n;

  for (n = loc, i = TRIGGERS(sc); i && i->next && (n != 0); n--, i = i->next);

  if (!loc) {
          t->next = TRIGGERS(sc);
    TRIGGERS(sc) = t;
  } else if (!i)
    TRIGGERS(sc) = t;
  else {
    t->next = i->next;
    i->next = t;
  }

  SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(t);

  t->next_in_world = trigger_list;
  trigger_list = t;
}


ACMD(do_attach)
{
  char_data *victim;
  obj_data *object;
  trig_data *trig;
  char targ_name[MAX_INPUT_LENGTH], trig_name[MAX_INPUT_LENGTH];
  char loc_name[MAX_INPUT_LENGTH];
  int loc, room, tn, rn;


  argument = two_arguments(argument, arg, trig_name);
  two_arguments(argument, targ_name, loc_name);

  if (!*arg || !*targ_name || !*trig_name) {
    send_to_char("Usage: attach { mtr | otr | wtr } { trigger } { name } [ location ]\r\n", ch);
    return;
  }

  tn = atoi(trig_name);
  loc = (*loc_name) ? atoi(loc_name) : -1;

  if (is_abbrev(arg, "mtr")) {
    if ((victim = get_char_vis(ch, targ_name))) {
      if (IS_NPC(victim))  {

	/* have a valid mob, now get trigger */
       rn = real_trigger(tn);
	if ((rn >= 0) && (trig = read_trigger(rn))) {

	  if (!SCRIPT(victim))
	    CREATE(SCRIPT(victim), struct script_data, 1);
	  add_trigger(SCRIPT(victim), trig, loc);

	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig), GET_SHORT(victim));
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
      } else
	send_to_char("Players can't have scripts.\r\n", ch);
    } else
      send_to_char("That mob does not exist.\r\n", ch);
  }

  else if (is_abbrev(arg, "otr")) {
    if ((object = get_obj_vis(ch, targ_name))) {

      /* have a valid obj, now get trigger */
      rn = trig_index[tn] ? tn : -1;
      if ((rn >= 0) && (trig = read_trigger(rn))) {

	  if (!SCRIPT(object))
	    CREATE(SCRIPT(object), struct script_data, 1);
	  add_trigger(SCRIPT(object), trig, loc);

	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig),
		  (object->short_description ?
		   object->short_description : object->name));
	  send_to_char(buf, ch);
      } else
	send_to_char("That trigger does not exist.\r\n", ch);
    } else
      send_to_char("That object does not exist.\r\n", ch);
  }

  else if (is_abbrev(arg, "wtr")) {
    if (isdigit(*targ_name) && !strchr(targ_name, '.')) {
      if ((room = find_target_room(ch, targ_name)) != NOWHERE) {

	/* have a valid room, now get trigger */
	rn = trig_index[tn] ? tn : -1;
	if ((rn >= 0) && (trig = read_trigger(rn))) {

	  if (!(world[room].script))
	    CREATE(world[room].script, struct script_data, 1);
	  add_trigger(world[room].script, trig, loc);

	  sprintf(buf, "Trigger %d (%s) attached to room %d.\r\n",
		  tn, GET_TRIG_NAME(trig), world[room].number);
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
      }
    } else
      send_to_char("You need to supply a room number.\r\n", ch);
  }

  else
    send_to_char("Please specify 'mtr', otr', or 'wtr'.\r\n", ch);
}


/* adds a variable with given name and value to trigger */
void add_var(struct trig_var_data **var_list, char *name, char *value)
{
  struct trig_var_data *vd;

  for (vd = *var_list; vd && str_cmp(vd->name, name); vd = vd->next);

  if (vd) {
    free(vd->value);
    CREATE(vd->value, char, strlen(value) + 1);
    strcpy(vd->value, value);
  }

  else {
    CREATE(vd, struct trig_var_data, 1);

    CREATE(vd->name, char, strlen(name) + 1);
    strcpy(vd->name, name);

    CREATE(vd->value, char, strlen(value) + 1);
    strcpy(vd->value, value);

    vd->next = *var_list;
    *var_list = vd;
  }
}


/*
 *  removes the trigger specified by name, and the script of o if
 *  it removes the last trigger.  name can either be a number, or
 *  a 'silly' name for the trigger, including things like 2.beggar-death.
 *  returns 0 if did not find the trigger, otherwise 1.  If it matters,
 *  you might need to check to see if all the triggers were removed after
 *  this function returns, in order to remove the script.
 */
int remove_trigger(struct script_data *sc, char *name)
{
  trig_data *i, *j;
  int num = 0, string = FALSE, n;
  char *cname;


  if (!sc)
    return 0;

  if ((cname = strstr(name,".")) || (!isdigit(*name)) ) {
    string = TRUE;
    if (cname) {
      *cname = '\0';
      num = atoi(name);
      name = ++cname;
    }
  } else
    num = atoi(name);

  for (n = 0, j = NULL, i = TRIGGERS(sc); i; j = i, i = i->next) {
    if (string) {
      if (isname(name, GET_TRIG_NAME(i)))
        if (++n >= num)
          break;
    }

    else if (++n >= num)
      break;
  }

  if (i) {
    if (j) {
      j->next = i->next;
      extract_trigger(i);
    }

    /* this was the first trigger */
    else {
      TRIGGERS(sc) = i->next;
      extract_trigger(i);
    }

    /* update the script type bitvector */
    SCRIPT_TYPES(sc) = 0;
    for (i = TRIGGERS(sc); i; i = i->next)
      SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(i);

    return 1;
  } else
    return 0;
}

ACMD(do_detach)
{
  char_data *victim = NULL;
  obj_data *object = NULL;
  struct room_data *room;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH], arg3[MAX_INPUT_LENGTH];
  char *trigger = 0;
  int tmp;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);

  if (!*arg1 || !*arg2) {
    send_to_char("Usage: detach [ mob | object ] { target } { trigger |"
                 " 'all' }\r\n", ch);
    return;
  }

  if (!str_cmp(arg1, "room")) {
    room = &world[IN_ROOM(ch)];
    if (!SCRIPT(room))
      send_to_char("This room does not have any triggers.\r\n", ch);
    else if (!str_cmp(arg2, "all")) {
      extract_script(SCRIPT(room));
      SCRIPT(room) = NULL;
      send_to_char("All triggers removed from room.\r\n", ch);
    }

    else if (remove_trigger(SCRIPT(room), arg2)) {
      send_to_char("Trigger removed.\r\n", ch);
      if (!TRIGGERS(SCRIPT(room))) {
        extract_script(SCRIPT(room));
        SCRIPT(room) = NULL;
      }
    } else
      send_to_char("That trigger was not found.\r\n", ch);
  }

  else {
    if (is_abbrev(arg1, "mob")) {
      if (!(victim = get_char_vis(ch, arg2)))
        send_to_char("No such mobile around.\r\n", ch);
      else if (!*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }

    else if (is_abbrev(arg1, "object")) {
      if (!(object = get_obj_vis(ch, arg2)))
        send_to_char("No such object around.\r\n", ch);
      else if (!*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }
    else  {
      if ((object = get_object_in_equip_vis(ch, arg1, ch->equipment, &tmp)));
      else if ((object = get_obj_in_list_vis(ch, arg1, ch->carrying)));
      else if ((victim = get_char_room_vis(ch, arg1)));
      else if ((object = get_obj_in_list_vis(ch, arg1, world[IN_ROOM(ch)].contents)));
      else if ((victim = get_char_vis(ch, arg1)));
      else if ((object = get_obj_vis(ch, arg1)));
      else
        send_to_char("Nothing around by that name.\r\n", ch);

      trigger = arg2;
    }

    if (victim) {
      if (!IS_NPC(victim))
        send_to_char("Players don't have triggers.\r\n", ch);

      else if (!SCRIPT(victim))
        send_to_char("That mob doesn't have any triggers.\r\n", ch);
      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(victim));
        SCRIPT(victim) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n", GET_SHORT(victim));
        send_to_char(buf, ch);
      }

      else if (remove_trigger(SCRIPT(victim), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(victim))) {
          extract_script(SCRIPT(victim));
          SCRIPT(victim) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }

    else if (object) {
      if (!SCRIPT(object))
        send_to_char("That object doesn't have any triggers.\r\n", ch);

      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(object));
        SCRIPT(object) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n",
                object->short_description ? object->short_description :
                object->name);
        send_to_char(buf, ch);
      }

      else if (remove_trigger(SCRIPT(object), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(object))) {
          extract_script(SCRIPT(object));
          SCRIPT(object) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }
  }
}


/* frees memory associated with var */
void free_var_el(struct trig_var_data *var)
{
  free(var->name);
  free(var->value);
  free(var);
}


/*
 * remove var name from var_list
 * returns 1 if found, else 0
 */
int remove_var(struct trig_var_data **var_list, char *name)
{
  struct trig_var_data *i, *j;

  for (j = NULL, i = *var_list; i && str_cmp(name, i->name);
       j = i, i = i->next);

  if (i) {
    if (j) {
      j->next = i->next;
      free_var_el(i);
    } else {
      *var_list = i->next;
      free_var_el(i);
    }

    return 1;
  }

  return 0;
}


/*
 *  Logs any errors caused by scripts to the system log.
 *  Will eventually allow on-line view of script errors.
 */
void script_log(char *msg)
{
  char buf[256];

  sprintf(buf,"SCRIPT ERR: %s", msg);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}


/* sets str to be the value of var.field */
void find_replacement(void *go, struct script_data *sc, trig_data *trig,
		      int type, char *var, char *field, char *str)
{
  struct trig_var_data *vd;
  char_data *ch, *c = NULL, *rndm;
  obj_data *obj, *o = NULL;
  struct room_data *room, *r = NULL;
  char *name;
  int num, count, wear;

  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;

  if (!vd)
    for (vd = sc->global_vars; vd; vd = vd->next)
      if (!str_cmp(vd->name, var))
	break;

  if (!*field) {
    if (vd)
      strcpy(str, vd->value);
    else {
      if (!str_cmp(var, "self"))
	strcpy(str, "self");
      else
	*str = '\0';
    }

    return;
  }

  else {
    if (vd) {
      name = vd->value;

      switch (type) {
      case MOB_TRIGGER:
	ch = (char_data *) go;

	if ((o = get_object_in_equip(ch, name, &wear)));
	else if ((o = get_obj_in_list(name, ch->carrying)));
	else if ((c = get_char_room(name, IN_ROOM(ch))));
	else if ((o = get_obj_in_list(name,world[IN_ROOM(ch)].contents)));
	else if ((c = get_char(name)));
	else if ((o = get_obj(name)));
	else if ((r = get_room(name))) {}

	break;
      case OBJ_TRIGGER:
	obj = (obj_data *) go;

	if ((c = get_char_by_obj(obj, name)));
	else if ((o = get_obj_by_obj(obj, name)));
	else if ((r = get_room(name))) {}

	break;
      case WLD_TRIGGER:
	room = (struct room_data *) go;

	if ((c = get_char_by_room(room, name)));
	else if ((o = get_obj_by_room(room, name)));
	else if ((r = get_room(name))) {}

	break;
      }
    }

    else {
      if (!str_cmp(var, "self")) {
	switch (type) {
	case MOB_TRIGGER:
	  c = (char_data *) go;
	  break;
	case OBJ_TRIGGER:
	  o = (obj_data *) go;
	  break;
	case WLD_TRIGGER:
	  r = (struct room_data *) go;
	  break;
	}
      }

      else if (!str_cmp(var, "people")) {
	sprintf(str,"%d",((num = atoi(field)) > 0) ? trgvar_in_room(num) : 0);
	return;
      }
      else if (!str_cmp(var, "random")) {
	if (!str_cmp(field, "char")) {
	  rndm = NULL;
	  count = 0;

	  if (type == MOB_TRIGGER) {
	    ch = (char_data *) go;
	    for (c = world[IN_ROOM(ch)].people; c; c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && (c != ch) &&
		  CAN_SEE(ch, c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }

	  else if (type == OBJ_TRIGGER) {
	    for (c = world[obj_room((obj_data *) go)].people; c;
		 c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }

	  else if (type == WLD_TRIGGER) {
	    for (c = ((struct room_data *) go)->people; c;
		 c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }

	  if (rndm)
	    sprintf(str, "%c%ld", UID_CHAR, GET_ID(rndm));
	  else
	    *str = '\0';
	}

	else
	  sprintf(str, "%d", ((num = atoi(field)) > 0) ? number(1, num) : 0);

	return;
      }
    }

    if (c) {
      if (!str_cmp(field, "name"))
        if (GET_SHORT(c))
          strcpy(str, GET_SHORT(c));
        else
          strcpy(str, GET_NAME(c));

      else if (!str_cmp(field, "alias"))
	strcpy(str, GET_NAME(c));

      else if (!str_cmp(field, "level"))
	sprintf(str, "%d", GET_LEVEL(c));

      else if (!str_cmp(field, "align"))
	sprintf(str, "%d", GET_ALIGNMENT(c));

      else if (!str_cmp(field, "gold"))
	sprintf(str, "%d", GET_GOLD(c));

      else if (!str_cmp(field, "sex"))
	strcpy(str, genders[(int)GET_SEX(c)]);

      else if (!str_cmp(field, "canbeseen")) {
	if ((type == MOB_TRIGGER) && !CAN_SEE(((char_data *)go), c))
	  strcpy(str, "0");
	else
	  strcpy(str, "1");
      }

      else if (!str_cmp(field, "class"))
	sprinttype(GET_CLASS(c), pc_class_types, str);

#ifdef GET_RACE
      else if (!str_cmp(field, "race"))
	sprinttype(GET_RACE(c), pc_race_types, str);
#endif

      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_MOB_VNUM(c));

      else if (!str_cmp(field, "cha"))
	sprintf(str, "%d", GET_CHA(c));

      else if (!str_cmp(field, "room"))
	sprintf(str, "%d", world[IN_ROOM(c)].number);

      else {
	*str = '\0';
	sprintf(buf2,
		"Trigger: %s, VNum %d. unknown char field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), field);
	script_log(buf2);
      }
    }

    else if (o) {
      if (!str_cmp(field, "name"))
	strcpy(str, o->name);

      else if (!str_cmp(field, "shortdesc"))
	strcpy(str, o->short_description);

      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_OBJ_VNUM(o));

      else if (!str_cmp(field, "type"))
	sprinttype(GET_OBJ_TYPE(o), item_types, str);

      else if (!str_cmp(field, "val0"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 0));

      else if (!str_cmp(field, "val1"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 1));

      else if (!str_cmp(field, "val2"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 2));

      else if (!str_cmp(field, "val3"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 3));

      else {
	*str = '\0';
	sprintf(buf2,
		"Trigger: %s, VNum %d, type: %d. unknown object field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
      }
    }

    else if (r) {
      if (!str_cmp(field, "name"))
	strcpy(str, r->name);
      else if (!str_cmp(field, "north")) {
	if (r->dir_option[NORTH])
	  sprintbit(r->dir_option[NORTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "east")) {
	if (r->dir_option[EAST])
	  sprintbit(r->dir_option[EAST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "south")) {
	if (r->dir_option[SOUTH])
	  sprintbit(r->dir_option[SOUTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "west")) {
	if (r->dir_option[WEST])
	  sprintbit(r->dir_option[WEST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "up")) {
	if (r->dir_option[UP])
	  sprintbit(r->dir_option[UP]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "down")) {
	if (r->dir_option[DOWN])
	  sprintbit(r->dir_option[DOWN]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else {
	*str = '\0';
	sprintf(buf2,
		"Trigger: %s, VNum %d, type: %d. unknown room field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
      }
    }

    else
      *str = '\0';
  }
}


/* substitutes any variables into line and returns it as buf */
void var_subst(void *go, struct script_data *sc, trig_data *trig,
	       int type, char *line, char *buf)
{
  char tmp[MAX_INPUT_LENGTH], repl_str[MAX_INPUT_LENGTH], *var, *field, *p;
  int left, len;
  int paren_count = 0;

  if (!strchr(line, '%')) {
    strcpy(buf, line);
    return;
  }

  p = strcpy(tmp, line);

  left = MAX_INPUT_LENGTH - 1;

  while (*p && (left > 0)) {

    while (*p && (*p != '%') && (left > 0)) {
      *(buf++) = *(p++);
      left--;
    }

    *buf = '\0';

    /* double % */
    if (*p && (*(++p) == '%') && (left > 0)) {
      *(buf++) = *(p++);
      *buf = '\0';
      left--;
      continue;
    }

    else if (*p && (left > 0)) {

      for (var = p; *p && (*p != '%') && (*p != '.'); p++);

      field = p;
      if (*p == '.') {
	*(p++) = '\0';
	for (field = p; *p && ((*p != '%')||(paren_count)); p++) {
          if (*p=='(') paren_count++;
          else if (*p==')') paren_count--;
        }
      }

      *(p++) = '\0';

      find_replacement(go, sc, trig, type, var, field, repl_str);

      strncat(buf, repl_str, left);
      len = strlen(repl_str);
      buf += len;
      left -= len;
    }
  }
}


/* returns 1 if string is all digits, else 0 */
int is_num(char *num)
{
  while (*num && (isdigit(*num) || *num=='-'))
    num++;

  if (!*num || isspace(*num))
    return 1;
  else
    return 0;
}


/* evaluates 'lhs op rhs', and copies to result */
void eval_op(char *op, char *lhs, char *rhs, char *result, void *go,
	     struct script_data *sc, trig_data *trig)
{
  char *p;
  int n;

  /* strip off extra spaces at begin and end */
  while (*lhs && isspace(*lhs))
    lhs++;
  while (*rhs && isspace(*rhs))
    rhs++;

  for (p = lhs; *p; p++);
  for (--p; isspace(*p) && (p > lhs); *p-- = '\0');
  for (p = rhs; *p; p++);
  for (--p; isspace(*p) && (p > rhs); *p-- = '\0');


  /* find the op, and figure out the value */
  if (!strcmp("||", op)) {
    if ((!*lhs || (*lhs == '0')) && (!*rhs || (*rhs == '0')))
      strcpy(result, "0");
    else
      strcpy(result, "1");
  }

  else if (!strcmp("&&", op)) {
    if (!*lhs || (*lhs == '0') || !*rhs || (*rhs == '0'))
      strcpy (result, "0");
    else
      strcpy (result, "1");
  }

  else if (!strcmp("==", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) == atoi(rhs));
    else
      sprintf(result, "%d", !str_cmp(lhs, rhs));
  }

  else if (!strcmp("!=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) != atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs));
  }

  else if (!strcmp("<=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) <= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp(">=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) >= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp("<", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) < atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) < 0);
  }

  else if (!strcmp(">", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) > atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) > 0);
  }

  else if (!strcmp("/=", op))
    sprintf(result, "%c", str_str(lhs, rhs) ? '1' : '0');

  else if (!strcmp("*", op))
    sprintf(result, "%d", atoi(lhs) * atoi(rhs));

  else if (!strcmp("/", op))
    sprintf(result, "%d", (n = atoi(rhs)) ? (atoi(lhs) / n) : 0);

  else if (!strcmp("+", op))
    sprintf(result, "%d", atoi(lhs) + atoi(rhs));

  else if (!strcmp("-", op))
    sprintf(result, "%d", atoi(lhs) - atoi(rhs));

  else if (!strcmp("!", op)) {
    if (is_num(rhs))
      sprintf(result, "%d", !atoi(rhs));
    else
      sprintf(result, "%d", !*rhs);
  }
}


/*
 * p points to the first quote, returns the matching
 * end quote, or the last non-null char in p.
*/
char *matching_quote(char *p)
{
  for (p++; *p && (*p != '"'); p++) {
    if (*p == '\\')
      p++;
  }

  if (!*p)
    p--;

  return p;
}

/*
 * p points to the first paren.  returns a pointer to the
 * matching closing paren, or the last non-null char in p.
 */
char *matching_paren(char *p)
{
  int i;

  for (p++, i = 1; *p && i; p++) {
    if (*p == '(')
      i++;
    else if (*p == ')')
      i--;
    else if (*p == '"')
      p = matching_quote(p);
  }

  return --p;
}


/* evaluates line, and returns answer in result */
void eval_expr(char *line, char *result, void *go, struct script_data *sc,
	       trig_data *trig, int type)
{
  char expr[MAX_INPUT_LENGTH], *p;

  while (*line && isspace(*line))
    line++;

  if (eval_lhs_op_rhs(line, result, go, sc, trig, type));

  else if (*line == '(') {
    p = strcpy(expr, line);
    p = matching_paren(expr);
    *p = '\0';
    eval_expr(expr + 1, result, go, sc, trig, type);
  }

  else
    var_subst(go, sc, trig, type, line, result);
}


/*
 * evaluates expr if it is in the form lhs op rhs, and copies
 * answer in result.  returns 1 if expr is evaluated, else 0
 */
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
		    trig_data *trig, int type)
{
  char *p, *tokens[MAX_INPUT_LENGTH];
  char line[MAX_INPUT_LENGTH], lhr[MAX_INPUT_LENGTH], rhr[MAX_INPUT_LENGTH];
  int i, j;

  /*
   * valid operands, in order of priority
   * each must also be defined in eval_op()
   */
  static char *ops[] = {
    "||",
    "&&",
    "==",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    "/=",
    "-",
    "+",
    "/",
    "*",
    "!",
    "\n"
  };

  p = strcpy(line, expr);

  /*
   * initialize tokens, an array of pointers to locations
   * in line where the ops could possibly occur.
   */
  for (j = 0; *p; j++) {
    tokens[j] = p;
    if (*p == '(')
      p = matching_paren(p) + 1;
    else if (*p == '"')
      p = matching_quote(p) + 1;
    else if (isalnum(*p))
      for (p++; *p && (isalnum(*p) || isspace(*p)); p++);
    else
      p++;
  }
  tokens[j] = NULL;

  for (i = 0; *ops[i] != '\n'; i++)
    for (j = 0; tokens[j]; j++)
      if (!strn_cmp(ops[i], tokens[j], strlen(ops[i]))) {
	*tokens[j] = '\0';
	p = tokens[j] + strlen(ops[i]);

	eval_expr(line, lhr, go, sc, trig, type);
	eval_expr(p, rhr, go, sc, trig, type);
	eval_op(ops[i], lhr, rhr, result, go, sc, trig);

	return 1;
      }

  return 0;
}



/* returns 1 if cond is true, else 0 */
int process_if(char *cond, void *go, struct script_data *sc,
	       trig_data *trig, int type)
{
  char result[MAX_INPUT_LENGTH], *p;

  eval_expr(cond, result, go, sc, trig, type);

  p = result;
  skip_spaces(&p);

  if (!*p || *p == '0')
    return 0;
  else
    return 1;
}


/*
 * scans for end of if-block.
 * returns the line containg 'end', or the last
 * line of the trigger if not found.
 */
struct cmdlist_element *find_end(struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("if ", p, 3))
      c = find_end(c);
    else if (!strn_cmp("end", p, 3))
      return c;
  }

  return c;
}


/*
 * searches for valid elseif, else, or end to continue execution at.
 * returns line of elseif, else, or end if found, or last line of trigger.
 */
struct cmdlist_element *find_else_end(trig_data *trig,
				      struct cmdlist_element *cl, void *go,
				      struct script_data *sc, int type)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("if ", p, 3))
      c = find_end(c);

    else if (!strn_cmp("elseif ", p, 7)) {
      if (process_if(p + 7, go, sc, trig, type)) {
	GET_TRIG_DEPTH(trig)++;
	return c;
      }
    }

    else if (!strn_cmp("else", p, 4)) {
      GET_TRIG_DEPTH(trig)++;
      return c;
    }

    else if (!strn_cmp("end", p, 3))
      return c;
  }

  return c;
}


/* processes any 'wait' commands in a trigger */
void process_wait(void *go, trig_data *trig, int type, char *cmd,
		  struct cmdlist_element *cl)
{
  char buf[MAX_INPUT_LENGTH], *arg;
  struct wait_event_data *wait_event_obj;
  long time, hr, min, ntime;
  char c;

  extern struct time_info_data time_info;
  extern long dg_global_pulse;


  arg = any_one_arg(cmd, buf);
  skip_spaces(&arg);

  if (!*arg) {
    sprintf(buf2, "Trigger: %s, VNum %d. wait w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cl->cmd);
    script_log(buf2);
  }

  else if (!strn_cmp(arg, "until ", 6)) {

    /* valid forms of time are 14:30 and 1430 */
    if (sscanf(arg, "until %ld:%ld", &hr, &min) == 2)
      min += (hr * 60);
    else
      min = (hr % 100) + ((hr / 100) * 60);

    /* calculate the pulse of the day of "until" time */
    ntime = (min * SECS_PER_MUD_HOUR * PASSES_PER_SEC) / 60;

    /* calculate pulse of day of current time */
    time = (dg_global_pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC)) +
      (time_info.hours * SECS_PER_MUD_HOUR * PASSES_PER_SEC);

    if (time >= ntime) /* adjust for next day */
      time = (SECS_PER_MUD_DAY * PASSES_PER_SEC) - time + ntime;
    else
      time = ntime - time;
  }

  else {
    if (sscanf(arg, "%ld %c", &time, &c) == 2) {
      if (c == 't')
	time *= PULSES_PER_MUD_HOUR;
      else if (c == 's')
	time *= PASSES_PER_SEC;
    }
  }

  CREATE(wait_event_obj, struct wait_event_data, 1);
  wait_event_obj->trigger = trig;
  wait_event_obj->go = go;
  wait_event_obj->type = type;

  GET_TRIG_WAIT(trig) = add_event(time, trig_wait_event, wait_event_obj);
  trig->curr_state = cl->next;
}


/* processes a script set command */
void process_set(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH], *value;

  value = two_arguments(cmd, arg, name);

  skip_spaces(&value);

  if (!*name) {
    sprintf(buf2, "Trigger: %s, VNum %d. set w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  add_var(&GET_TRIG_VARS(trig), name, value);

}

/* processes a script eval command */
void process_eval(void *go, struct script_data *sc, trig_data *trig,
		 int type, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
  char result[MAX_INPUT_LENGTH], *expr;

  expr = two_arguments(cmd, arg, name);

  skip_spaces(&expr);

  if (!*name) {
    sprintf(buf2, "Trigger: %s, VNum %d. eval w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  eval_expr(expr, result, go, sc, trig, type);
  add_var(&GET_TRIG_VARS(trig), name, result);
}


/*
 * processes a script return command.
 * returns the new value for the script to return.
 */
int process_return(trig_data *trig, char *cmd)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  two_arguments(cmd, arg1, arg2);

  if (!*arg2) {
    sprintf(buf2, "Trigger: %s, VNum %d. return w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return 1;
  }

  return atoi(arg2);
}


/*
 * removes a variable from the global vars of sc,
 * or the local vars of trig if not found in global list.
 */
void process_unset(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], *var;

  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Trigger: %s, VNum %d. unset w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  if (!remove_var(&(sc->global_vars), var))
    remove_var(&GET_TRIG_VARS(trig), var);
}


/*
 * makes a local variable into a global variable
 */
void process_global(struct script_data *sc, trig_data *trig, char *cmd)
{
  struct trig_var_data *vd;
  char arg[MAX_INPUT_LENGTH], *var;

  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Trigger: %s, VNum %d. global w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;

  if (!vd) {
    sprintf(buf2, "Trigger: %s, VNum %d. local var '%s' not found in global call",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), var);
    script_log(buf2);
    return;
  }

  add_var(&(sc->global_vars), vd->name, vd->value);
  remove_var(&GET_TRIG_VARS(trig), vd->name);
}




/*  This is the core driver for scripts. */
int script_driver(void *go, trig_data *trig, int type, int mode)
{
  static int depth = 0;
  int ret_val = 1;
  struct cmdlist_element *cl;
  char cmd[MAX_INPUT_LENGTH], *p;
  struct script_data *sc = 0;
  struct cmdlist_element *temp;
  unsigned long loops = 0;


  void obj_command_interpreter(obj_data *obj, char *argument);
  void wld_command_interpreter(struct room_data *room, char *argument);

  if (depth > MAX_SCRIPT_DEPTH) {
    script_log("Triggers recursed beyond maximum allowed depth.");
    return ret_val;
  }

  depth++;

  switch (type) {
  case MOB_TRIGGER:
    sc = SCRIPT((char_data *) go);
    break;
  case OBJ_TRIGGER:
    sc = SCRIPT((obj_data *) go);
    break;
  case WLD_TRIGGER:
    sc = SCRIPT((struct room_data *) go);
    break;
  }

  if (mode == TRIG_NEW) {
    GET_TRIG_DEPTH(trig) = 1;
    GET_TRIG_LOOPS(trig) = 0;
  }

  for (cl = (mode == TRIG_NEW) ? trig->cmdlist : trig->curr_state;
       cl && GET_TRIG_DEPTH(trig); cl = cl->next) {
#ifdef PURGED
    if (PURGED(sc))
	return 0;
    if (PURGED(trig))
	return 0;
#endif
    for (p = cl->cmd; *p && isspace(*p); p++);

    if (*p == '*')
      continue;

    else if (!strn_cmp(p, "if ", 3)) {
      if (process_if(p + 3, go, sc, trig, type))
	GET_TRIG_DEPTH(trig)++;
      else
	cl = find_else_end(trig, cl, go, sc, type);
    }

    else if (!strn_cmp("elseif ", p, 7) ||
	     !strn_cmp("else", p, 4)) {
      cl = find_end(cl);
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("while ", p, 6)) {
      temp = find_done(cl);
      if (process_if(p + 6, go, sc, trig, type)) {
         temp->original = cl;
      } else {
         cl = temp;
         loops = 0;
      }
    } else if (!strn_cmp("switch ", p, 7)) {
      cl = find_case(trig, cl, go, sc, type, p + 7);
    } else if (!strn_cmp("end", p, 3)) {
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("done", p, 4)) {
      if (cl->original && process_if(cl->original->cmd + 6, go, sc, trig,
          type)) {
        cl = cl->original;
        loops++;
        GET_TRIG_LOOPS(trig)++;
        if (loops == 30) {
          process_wait(go, trig, type, "wait 1", cl);
           depth--;
          free(cmd);
          return ret_val;
        }
        if (GET_TRIG_LOOPS(trig) == 100) {
          char *buf = (char*)malloc(MAX_STRING_LENGTH);
          sprintf(buf,"SCRIPTERR: Trigger VNum %d has looped 100 times!!!",
            GET_TRIG_VNUM(trig));
          mudlog(buf, NRM, LVL_GOD, TRUE);
          // wtf? WHY would anyone free memory that was NOT allocated? Mud go BOOM!
          //free(buf);
        }
      }
    } else if (!strn_cmp("break", p, 5)) {
      cl = find_done(cl);
    } else if (!strn_cmp("case", p, 4)) {
       /* Do nothing, this allows multiple cases to a single instance */
    }


    else {

      var_subst(go, sc, trig, type, p, cmd);

      if (!strn_cmp(cmd, "eval ", 5))
	process_eval(go, sc, trig, type, cmd);

      else if (!strn_cmp(cmd, "halt", 4))
	break;

      else if (!strn_cmp(cmd, "global ", 7))
	process_global(sc, trig, cmd);

      else if (!strn_cmp(cmd, "return ", 7))
	ret_val = process_return(trig, cmd);

      else if (!strn_cmp(cmd, "set ", 4))
	process_set(sc, trig, cmd);

      else if (!strn_cmp(cmd, "unset ", 6))
	process_unset(sc, trig, cmd);

      else if (!strn_cmp(cmd, "wait ", 5)) {
	process_wait(go, trig, type, cmd, cl);
	depth--;
	return ret_val;
      }

      else
	switch (type) {
	case MOB_TRIGGER:
	  command_interpreter((char_data *) go, cmd);
	  break;
	case OBJ_TRIGGER:
	  obj_command_interpreter((obj_data *) go, cmd);
	  break;
	case WLD_TRIGGER:
	  wld_command_interpreter((struct room_data *) go, cmd);
	  break;
	}
    }
  }

  free_varlist(GET_TRIG_VARS(trig));
  GET_TRIG_VARS(trig) = NULL;
  GET_TRIG_DEPTH(trig) = 0;

  depth--;
  return ret_val;
}

ACMD(do_tlist)
{

  int first, last, nr, found = 0;
  char pagebuf[65536];

  strcpy(pagebuf,"");

  two_arguments(argument, buf, buf2);

  if (!*buf) {
    send_to_char("Usage: tlist <begining number or zone> [<ending number>]\r\n", ch);
    return;
  }

  first = atoi(buf);
  if (*buf2) last = atoi(buf2);
  else {
    first *= 100;
    last = first+99;
  }

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  for (nr = 0; nr < top_of_trigt && (trig_index[nr]->virtual <= last); nr++)
  {
    if (trig_index[nr]->virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              trig_index[nr]->virtual,
              trig_index[nr]->proto->name);
      strcat(pagebuf, buf);
    }
  }

  if (!found)
    send_to_char("No triggers were found in those parameters.\n\r", ch);
  else page_string(ch->desc, pagebuf, TRUE);
}

int real_trigger(int vnum)
{
  int rnum;

  for (rnum=0; rnum < top_of_trigt; rnum++)
  {
    if (trig_index[rnum]->virtual==vnum) break;
  }

  if (rnum==top_of_trigt) rnum = -1;
  return (rnum);
}

ACMD(do_tstat)
{
  int vnum, rnum;
  char str[MAX_INPUT_LENGTH];

  half_chop(argument, str, argument);
  if (*str) {
    vnum = atoi(str);
    rnum = real_trigger(vnum);
    if (rnum<0) {
      send_to_char("That vnum does not exist.\r\n", ch);
      return;
    }

    do_stat_trigger(ch, trig_index[rnum]->proto);
  } else send_to_char("Usage: tstat <vnum>\r\n", ch);
}

/*
* scans for a case/default instance
* returns the line containg the correct case instance, or the last
* line of the trigger if not found.
*/
struct cmdlist_element *
find_case(struct trig_data *trig, struct cmdlist_element *cl,
          void *go, struct script_data *sc, int type, char *cond)
{
  struct cmdlist_element *c;
  char *p, *buf;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch", p, 6))
      c = find_done(c);
    else if (!strn_cmp("case ", p, 5)) {
      buf = (char*)malloc(MAX_STRING_LENGTH);
      sprintf(buf, "(%s) == (%s)", cond, p + 5);
      if (process_if(buf, go, sc, trig, type)) {
        free(buf);
        return c;
      }
      free(buf);
    } else if (!strn_cmp("default", p, 7))
      return c;
    else if (!strn_cmp("done", p, 3))
     return c;
  }
  return c;
}

/*
* scans for end of while/switch-blocks.
* returns the line containg 'end', or the last
* line of the trigger if not found.
*/
struct cmdlist_element *
find_done(struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch ", p, 7))
      c = find_done(c);
    else if (!strn_cmp("done", p, 3))
      return c;
  }

  return c;
}
@


1.131
log
@Fix compiler warnings.
@
text
@/***************************************************************************
 * $Id: dg_scripts.c,v 1.130 2009/06/10 20:14:48 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: dg_scripts.c                                   Part of FieryMUD *
 *  Usage: contains general functions for using scripts.                   *
 *  $Author: myc $                                                         *
 *  $Date: 2009/06/10 20:14:48 $                                           *
 *  $Revision: 1.130 $                                                      *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *                                                                         *
 * This code was received origonally from HubisMUD in 1998 and no lable or *
 * claim of ownership or copyright was made anywhere in the file.          *
 ***************************************************************************/

#define __DG_SCRIPTS_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "events.h"
#include "db.h"
#include "screen.h"
#include "quest.h"
#include "class.h"
#include "races.h"
#include "clan.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "casting.h"
#include "olc.h"
#include "trophy.h"
#include "exits.h"
#include "modify.h"
#include "charsize.h"
#include "strings.h"

#define PULSES_PER_MUD_HOUR     (SECS_PER_MUD_HOUR*PASSES_PER_SEC)

/* external functions */
int find_target_room(char_data * ch, char *rawroomstr);
int obj_room(obj_data *obj);
int is_empty(int zone_nr);
int find_target_room(struct char_data * ch, char *rawroomstr);
trig_data *read_trigger(int nr);
void extract_trigger(struct trig_data *trig);
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
                    trig_data *trig, int type);
extern int find_zone(int num);
int vnumargs(struct char_data *ch, char *argument, int *first, int *second);
int group_size(struct char_data *ch);
int find_talent_num(char *name, int restrict);

/* function protos from this file */
int script_driver(void *go_address, trig_data *trig, int type, int mode);
void script_log(struct trig_data *t,char *msg);
struct cmdlist_element *find_done(struct cmdlist_element *cl);
struct cmdlist_element * \
find_case(struct trig_data *trig, struct cmdlist_element *cl, \
          void *go, struct script_data *sc, int type, char *cond);
void var_subst(void *go, struct script_data *sc, trig_data *trig, \
               int type, char *line, char *buf);

/* local structures */
struct wait_event_data {
  trig_data *trigger;
  void *go;
  int type;
};


struct trig_data *trigger_list = NULL;  /* all attached triggers */

int find_real_zone_by_room(room_num vznum) {
  int bot, top, mid;
  int low, high;

  bot = 0;
  top = top_of_zone_table;

  /* perform binary search on zone-table */
  for (;;) {
    mid = (bot + top) / 2;

    /* Upper/lower bounds of the zone. */
    low = zone_table[mid].number * 100;
    high = zone_table[mid].top;

    if (low <= vznum && vznum <= high)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if (low > vznum)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

int real_zone(int zvnum) {
   int i;

   for (i = 0; i < top_of_zone_table; i++)
      if (zone_table[i].number == zvnum)
         return i;

   return -1;
}


/************************************************************
 * search by number routines                                *
 ************************************************************/

/* return char with UID n */
struct char_data *find_char(int n)
{
  struct char_data *ch;

  for (ch = character_list; ch; ch = ch->next)
    if (GET_ID(ch) == n)
      return (ch);

  return NULL;
}


/* return object with UID n */
obj_data *find_obj(int n)
{
  obj_data *i;

  for (i = object_list; i; i = i->next)
    if (n == GET_ID(i))
      return i;

  return NULL;
}

/* return room with UID n */
room_data *find_room(int n)
{
  n -= ROOM_ID_BASE;

  if ((n >= 0) && (n <= top_of_world))
    return &world[n];

  return NULL;
}



/************************************************************
 * generic searches based only on name                      *
 ************************************************************/

/* finds room by with name.  returns NULL if not found */
room_data *get_room(char *name)
{
  int nr;

  if (*name == UID_CHAR)
    return find_room(atoi(name + 1));
  else if (isdigit(*name) && (nr = real_room(atoi(name))) != NOWHERE)
    return &world[nr];
  else
    return NULL;
}

/* finds room rnum by name.  returns NOWHERE if not found */
int get_room_location(char *name)
{
  if (*name == UID_CHAR) {
    int num = atoi(name + 1) - ROOM_ID_BASE;
    if (num >= 0 && num <= top_of_world)
      return num;
  }

  if (isdigit(*name) && !strchr(name, '.'))
    return real_room(atoi(name));

  return NOWHERE;
}


MATCH_CHAR_FUNC(match_dg_vis_char_by_id)
{
  return (GET_ID(ch) == context->number && !GET_INVIS_LEV(ch));
}

static MATCH_CHAR_FUNC(match_dg_vis_char_by_name)
{
  if (!GET_INVIS_LEV(ch))
    if (isname(context->string, GET_NAMELIST(ch)))
      if (--context->number <= 0)
        return TRUE;
  return FALSE;
}


struct find_context find_dg_by_name(char *name) {
  struct find_context context = find_by_name(name);
  if (*name == UID_CHAR)
    context.char_func = match_dg_vis_char_by_id;
  else
    context.char_func = match_dg_vis_char_by_name;
  return context;
}


/* checks every PLUSE_SCRIPT for random triggers */
void script_trigger_check(void)
{
  char_data *ch;
  obj_data *obj;
  struct room_data *room=NULL;
  int nr;
  struct script_data *sc;

  for (ch = character_list; ch; ch = ch->next) {
    if (SCRIPT(ch)) {
      sc = SCRIPT(ch);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
          (!is_empty(world[IN_ROOM(ch)].zone) ||
           IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
        random_mtrigger(ch);
    }
  }

  for (obj = object_list; obj; obj = obj->next) {
    if (SCRIPT(obj)) {
      sc = SCRIPT(obj);

      if (IS_SET(SCRIPT_TYPES(sc), OTRIG_RANDOM))
        random_otrigger(obj);
    }
  }

  for (nr = 0; nr <= top_of_world; nr++) {
    if (SCRIPT(&world[nr])) {
      room = &world[nr];
      sc = SCRIPT(room);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
          (!is_empty(room->zone) ||
           IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
        random_wtrigger(room);
    }
  }
}


EVENTFUNC(trig_wait_event)
{
  struct wait_event_data *wait_event_obj = (struct wait_event_data *)event_obj;
  trig_data *trig;
  void *go;
  int type;

  trig = wait_event_obj->trigger;
  go = wait_event_obj->go;
  type = wait_event_obj->type;

  GET_TRIG_WAIT(trig) = NULL;

  script_driver(&go, trig, type, TRIG_RESTART);
  return EVENT_FINISHED;
}

/* wait for casts...*/
void pause_while_casting(void *go, trig_data *trig, int type, struct cmdlist_element *cl)
{
  struct wait_event_data *wait_event_obj;
  long time=10L;


  CREATE(wait_event_obj, struct wait_event_data, 1);
  wait_event_obj->trigger = trig;
  wait_event_obj->go = go;
  wait_event_obj->type = type;

  GET_TRIG_WAIT(trig) = event_create(EVENT_TRIGGER_WAIT, trig_wait_event,
        wait_event_obj, TRUE, NULL, time);
  trig->curr_state = cl;
}


void do_stat_trigger(struct char_data *ch, trig_data *trig)
{
  struct cmdlist_element *cmd_list;
  char sb[MAX_STRING_LENGTH_BIG];

  if (!trig)
    {
      log("SYSERR: NULL trigger passed to do_stat_trigger.");
      return;
    }

  get_char_cols(ch);

  sprintf(sb, "Trigger Name: '%s%s%s',  VNum: [%s%5d%s], RNum: [%5d]\r\n",
          yel, GET_TRIG_NAME(trig), nrm,
          grn, GET_TRIG_VNUM(trig), nrm,
          GET_TRIG_RNUM(trig));
  send_to_char(sb, ch);

  if (trig->attach_type == OBJ_TRIGGER) {
    send_to_char("Trigger Intended Assignment: Objects\r\n", ch);
    sprintbit(GET_TRIG_TYPE(trig), otrig_types, buf);
  } else if (trig->attach_type == WLD_TRIGGER) {
    send_to_char("Trigger Intended Assignment: Rooms\r\n", ch);
    sprintbit(GET_TRIG_TYPE(trig), wtrig_types, buf);
  } else {
    send_to_char("Trigger Intended Assignment: Mobiles\r\n", ch);
    sprintbit(GET_TRIG_TYPE(trig), trig_types, buf);
  }

  sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
          buf, GET_TRIG_NARG(trig),
          ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig)) ?
          GET_TRIG_ARG(trig) : "None"));

  strcat(sb, "Commands:\r\n\r\n");

  cmd_list = trig->cmdlist;
  while (cmd_list) {
     if (cmd_list->cmd) {
        strcat(sb, escape_ansi(cmd_list->cmd));
        strcat(sb, "\r\n");
     }
     cmd_list = cmd_list->next;
  }
  page_string(ch, sb);
}


/* find the name of what the uid points to */
void find_uid_name(char *uid, char *name)
{
  char_data *ch;
  obj_data *obj;

  if ((ch = find_char_in_world(find_by_name(uid))))
    strcpy(name, GET_NAMELIST(ch));
  else if ((obj = find_obj_in_world(find_by_name(uid))))
    strcpy(name, obj->name);
  else
    sprintf(name, "uid = %s, (not found)", uid + 1);
}


/* general function to display stats on script sc */
void script_stat (char_data *ch, char *buf, struct script_data *sc)
{
  struct trig_var_data *tv;
  trig_data *t;
  char name[MAX_INPUT_LENGTH];
  int found = 0;
  extern char *t_listdisplay(int nr, int index);

  get_char_cols(ch);

  buf += sprintf(buf, "Global Variables: %s\r\n",
          sc->global_vars ? "" : "None");

  for (tv = sc->global_vars; tv; tv = tv->next) {
    if (*(tv->value) == UID_CHAR) {
      find_uid_name(tv->value, name);
      buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
    } else
      buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
  }

  for (t = TRIGGERS(sc); t; t = t->next) {
    buf += sprintf(buf, "%s", t_listdisplay(t->nr, ++found));

#if 1
    if (GET_TRIG_WAIT(t)) {
      buf += sprintf(buf, "  Wait: %ld, Current line: %s\r\n"
                          "  Variables: %s\r\n",
              event_time(GET_TRIG_WAIT(t)), t->curr_state->cmd,
              GET_TRIG_VARS(t) ? "" : "None");

      for (tv = GET_TRIG_VARS(t); tv; tv = tv->next) {
        if (*(tv->value) == UID_CHAR) {
          find_uid_name(tv->value, name);
          buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
        } else
          buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
      }
    }
#endif
  }
}


void do_sstat_room(struct char_data * ch, char *buf, struct room_data *rm)
{
  strcpy(buf, "Script information:\r\n");
  if (SCRIPT(rm))
    script_stat(ch, buf + strlen(buf), SCRIPT(rm));
  else
    strcat(buf, "  None.\r\n");
}


void do_sstat_object(char_data *ch, char *buf, obj_data *j)
{
  strcpy(buf, "Script information:\r\n");
  if (!SCRIPT(j)) {
    strcat(buf, "  None.\r\n");
    return;
  }

  script_stat(ch, buf + strlen(buf), SCRIPT(j));
}


void do_sstat_character(char_data *ch, char *buf, char_data *k)
{
  strcpy(buf, "Script information:\r\n");
  if (!SCRIPT(k)) {
    strcat(buf, "  None.\r\n");
    return;
  }

  script_stat(ch, buf + strlen(buf), SCRIPT(k));
}


/*
 * adds the trigger t to script sc in in location loc.  loc = -1 means
 * add to the end, loc = 0 means add before all other triggers.
 */
void add_trigger(struct script_data *sc, trig_data *t, int loc)
{
  trig_data *i;
  int n;

  for (n = loc, i = TRIGGERS(sc); i && i->next && (n != 0); n--, i = i->next);

  if (!loc) {
    t->next = TRIGGERS(sc);
    TRIGGERS(sc) = t;
  } else if (!i)
    TRIGGERS(sc) = t;
  else {
    t->next = i->next;
    i->next = t;
  }

  SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(t);

  t->next_in_world = trigger_list;
  trigger_list = t;
}


ACMD(do_attach)
{
  char_data *victim;
  obj_data *object;
  trig_data *trig;
  char targ_name[MAX_INPUT_LENGTH], trig_name[MAX_INPUT_LENGTH];
  char loc_name[MAX_INPUT_LENGTH];
  int loc, room, tn, rn;


  argument = two_arguments(argument, arg, trig_name);
  two_arguments(argument, targ_name, loc_name);

  if (!*arg || !*targ_name || !*trig_name) {
    send_to_char("Usage: attach { mtr | otr | wtr } { trigger } { name } [ location ]\r\n", ch);
    return;
  }

  tn = atoi(trig_name);
  loc = (*loc_name) ? atoi(loc_name) : -1;

  if (is_abbrev(arg, "mtr")) {
    if ((victim = find_char_around_char(ch, find_vis_by_name(ch, targ_name)))) {
      if (IS_NPC(victim))  {
        
        /* have a valid mob, now get trigger */
        rn = real_trigger(tn);
        if ((rn >= 0) && (trig = read_trigger(rn))) {
        
          if (!SCRIPT(victim))
            CREATE(SCRIPT(victim), struct script_data, 1);
          add_trigger(SCRIPT(victim), trig, loc);
        
          sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
                  tn, GET_TRIG_NAME(trig), GET_SHORT(victim));
          send_to_char(buf, ch);
        } else
          send_to_char("That trigger does not exist.\r\n", ch);
      } else
        send_to_char("Players can't have scripts.\r\n", ch);
    } else
      send_to_char("That mob does not exist.\r\n", ch);
  }

  else if (is_abbrev(arg, "otr")) {
    if ((object = find_obj_around_char(ch, find_vis_by_name(ch, targ_name)))) {

      /* have a valid obj, now get trigger */
      rn = trig_index[tn] ? tn : -1;
      if ((rn >= 0) && (trig = read_trigger(rn))) {
        
        if (!SCRIPT(object))
          CREATE(SCRIPT(object), struct script_data, 1);
        add_trigger(SCRIPT(object), trig, loc);
        
        sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
                tn, GET_TRIG_NAME(trig),
                (object->short_description ?
                 object->short_description : object->name));
        send_to_char(buf, ch);
      } else
        send_to_char("That trigger does not exist.\r\n", ch);
    } else
      send_to_char("That object does not exist.\r\n", ch);
  }

  else if (is_abbrev(arg, "wtr")) {
    if (isdigit(*targ_name) && !strchr(targ_name, '.')) {
      if ((room = find_target_room(ch, targ_name)) != NOWHERE) {
        
        /* have a valid room, now get trigger */
        rn = trig_index[tn] ? tn : -1;
        if ((rn >= 0) && (trig = read_trigger(rn))) {
        
          if (!(world[room].script))
            CREATE(world[room].script, struct script_data, 1);
          add_trigger(world[room].script, trig, loc);
        
          sprintf(buf, "Trigger %d (%s) attached to room %d.\r\n",
                  tn, GET_TRIG_NAME(trig), world[room].vnum);
          send_to_char(buf, ch);
        } else
          send_to_char("That trigger does not exist.\r\n", ch);
      }
    } else
      send_to_char("You need to supply a room number.\r\n", ch);
  }

  else
    send_to_char("Please specify 'mtr', otr', or 'wtr'.\r\n", ch);
}


/* adds a variable with given name and value to trigger */
void add_var(struct trig_var_data **var_list, const char *name, const char *value)
{
  struct trig_var_data *vd;

  for (vd = *var_list; vd && str_cmp(vd->name, name); vd = vd->next);

  if (vd) {
    free(vd->value);
    CREATE(vd->value, char, strlen(value) + 1);
    strcpy(vd->value, value);
  }

  else {
    CREATE(vd, struct trig_var_data, 1);

    CREATE(vd->name, char, strlen(name) + 1);
    strcpy(vd->name, name);

    CREATE(vd->value, char, strlen(value) + 1);
    strcpy(vd->value, value);

    vd->next = *var_list;
    *var_list = vd;
  }
}


/*
 *  removes the trigger specified by name, and the script of o if
 *  it removes the last trigger.  name can either be a number, or
 *  a 'silly' name for the trigger, including things like 2.beggar-death.
 *  returns 0 if did not find the trigger, otherwise 1.  If it matters,
 *  you might need to check to see if all the triggers were removed after
 *  this function returns, in order to remove the script.
 */
int remove_trigger(struct script_data *sc, char *name)
{
  trig_data *i, *j;
  int num = 0, string = FALSE, n;
  char *cname;


  if (!sc)
    return 0;

  if ((cname = strstr(name, ".")) || (!isdigit(*name)) ) {
    string = TRUE;
    if (cname) {
      *cname = '\0';
      num = atoi(name);
      name = ++cname;
    }
  } else
    num = atoi(name);

  for (n = 0, j = NULL, i = TRIGGERS(sc); i; j = i, i = i->next) {
    if (string) {
      if (isname(name, GET_TRIG_NAME(i)))
        if (++n >= num)
          break;
    }

    else if (++n >= num)
      break;
  }

  if (i) {
    if (j) {
      j->next = i->next;
      extract_trigger(i);
    }

    /* this was the first trigger */
    else {
      TRIGGERS(sc) = i->next;
      extract_trigger(i);
    }

    /* update the script type bitvector */
    SCRIPT_TYPES(sc) = 0;
    for (i = TRIGGERS(sc); i; i = i->next)
      SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(i);

    return 1;
  } else
    return 0;
}

ACMD(do_detach)
{
  char_data *victim = NULL;
  obj_data *object = NULL;
  struct room_data *room;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH], arg3[MAX_INPUT_LENGTH];
  char *trigger = 0;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);

  if (!*arg1 || !*arg2) {
    send_to_char("Usage: detach [ mob | object ] { target } { trigger |"
                 " 'all' }\r\n", ch);
    return;
  }

  if (!str_cmp(arg1, "room")) {
    room = &world[IN_ROOM(ch)];
    if (!SCRIPT(room))
      send_to_char("This room does not have any triggers.\r\n", ch);
    else if (!str_cmp(arg2, "all")) {
      extract_script(SCRIPT(room));
      SCRIPT(room) = NULL;
      send_to_char("All triggers removed from room.\r\n", ch);
    }

    else if (remove_trigger(SCRIPT(room), arg2)) {
      send_to_char("Trigger removed.\r\n", ch);
      if (!TRIGGERS(SCRIPT(room))) {
        extract_script(SCRIPT(room));
        SCRIPT(room) = NULL;
      }
    } else
      send_to_char("That trigger was not found.\r\n", ch);
  }

  else {
    if (is_abbrev(arg1, "mob")) {
      if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, arg2))))
        send_to_char("No such mobile around.\r\n", ch);
      else if (!*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }

    else if (is_abbrev(arg1, "object")) {
      if (!(object = find_obj_around_char(ch, find_vis_by_name(ch, arg2))))
        send_to_char("No such object around.\r\n", ch);
      else if (!*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }
    else  {
      if ((object = find_obj_in_eq(ch, NULL, find_vis_by_name(ch, arg1))));
      else if ((object = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1))));
      else if ((victim = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg1))));
      else if ((object = find_obj_in_list(world[IN_ROOM(ch)].contents, find_vis_by_name(ch, arg1))));
      else if ((victim = find_char_around_char(ch, find_vis_by_name(ch, arg1))));
      else if ((object = find_obj_in_world(find_vis_by_name(ch, arg1))));
      else
        send_to_char("Nothing around by that name.\r\n", ch);

      trigger = arg2;
    }

    if (victim) {
      if (!IS_NPC(victim))
        send_to_char("Players don't have triggers.\r\n", ch);

      else if (!SCRIPT(victim))
        send_to_char("That mob doesn't have any triggers.\r\n", ch);
      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(victim));
        SCRIPT(victim) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n", GET_SHORT(victim));
        send_to_char(buf, ch);
      }

      else if (remove_trigger(SCRIPT(victim), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(victim))) {
          extract_script(SCRIPT(victim));
          SCRIPT(victim) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }

    else if (object) {
      if (!SCRIPT(object))
        send_to_char("That object doesn't have any triggers.\r\n", ch);

      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(object));
        SCRIPT(object) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n",
                object->short_description ? object->short_description :
                object->name);
        send_to_char(buf, ch);
      }

      else if (remove_trigger(SCRIPT(object), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(object))) {
          extract_script(SCRIPT(object));
          SCRIPT(object) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }
  }
}


/* frees memory associated with var */
void free_var_el(struct trig_var_data *var)
{
  free(var->name);
  free(var->value);
  free(var);
}


/*
 * remove var name from var_list
 * returns 1 if found, else 0
 */
int remove_var(struct trig_var_data **var_list, char *name)
{
  struct trig_var_data *i, *j;

  for (j = NULL, i = *var_list; i && str_cmp(name, i->name);
       j = i, i = i->next);

  if (i) {
    if (j) {
      j->next = i->next;
      free_var_el(i);
    } else {
      *var_list = i->next;
      free_var_el(i);
    }

    return 1;
  }

  return 0;
}


/*
 *  Logs any errors caused by scripts to the system log.
 *  Will eventually allow on-line view of script errors.
 */
void script_log(struct trig_data *t, char *msg)
{
  char buf[256];

  if (t)
    snprintf(buf, 255, "ERROR trigger %d (%s): %s",
             GET_TRIG_VNUM(t), GET_TRIG_NAME(t), msg);
  else
    snprintf(buf, 255, "ERROR in trigger: %s", msg);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}


/*
 * Takes a zone RNUM and returns a room RNUM.
 */
int get_random_room_in_zone(int znum) {
  int low, high, to_room;

  /* Find the lower room bound for the zone. */
  for (low = 0; low <= top_of_world && world[low].zone != znum; ++low);

  /* No rooms for this zone. */
  if (low > top_of_world)
    return NOWHERE;

  /* Find the upper room bound for the zone. */
  for (high = low; high <= top_of_world && world[high].zone == znum; ++high);
  --high;

  do {
    to_room = number(low, high);
  } while (ROOM_FLAGGED(to_room, ROOM_PRIVATE) ||
           ROOM_FLAGGED(to_room, ROOM_DEATH) ||
           ROOM_FLAGGED(to_room, ROOM_GODROOM));

  return to_room;
}


#define UID_VAR(str, i)        ((i) ? sprintf((str), "%c%ld", UID_CHAR, GET_ID(i)) : sprintf((str), "0"))
#define ROOM_UID_VAR(str, r)   sprintf((str), "%c%ld", UID_CHAR, (long) r + ROOM_ID_BASE)

/* sets str to be the value of var.field */
void find_replacement(void *go, struct script_data *sc, trig_data *trig,
                      int type, char *var, char *field, char *value, char *str)
{
  struct trig_var_data *vd;
  char_data *ch, *c = NULL;
  obj_data *obj, *o = NULL;
  struct room_data *room, *r = NULL;
  char *name;
  int num;

  if (!value)
    value = "";

  /*
   * First see if there is a local variable with the specified name.
   * This means that local variables take precedence and can 'mask'
   * globals and static variables.
   */
  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;

  /*
   * If no local variable was matched, see if there is a global variable
   * with the specified name.
   *
   * Some waitstates could crash the mud if sent here with sc == NULL.
   */
  if (!vd && sc)
    for (vd = sc->global_vars; vd; vd = vd->next)
      if (!str_cmp(vd->name, var))
        break;

  /*
   * Set 'self' variables for use below.  For example, if this is a mob
   * trigger, ch is the mob executing the trigger, and obj and room are
   * null.
   */
  switch (type) {
  case MOB_TRIGGER:
    ch = (char_data *) go;
    obj = NULL;
    room = NULL;
    break;
  case OBJ_TRIGGER:
    ch = NULL;
    obj = (obj_data *) go;
    room = NULL;
    break;
  case WLD_TRIGGER:
    ch = NULL;
    obj = NULL;
    room = (struct room_data *) go;
    break;
  default:
    log("SYSERR: find_replacement encountered invalid trig type (%d) in trig %d", type, GET_TRIG_VNUM(trig));
    *str = '\0';
    return;
  }

  /*
   * If no variable field is given, we can simply drop in the variable's
   * value.
   */
  if (!*field) {
    if (vd)
      strcpy(str, vd->value);
    else {
      if (!str_cmp(var, "self")) {
        switch (type) {
        case MOB_TRIGGER: UID_VAR(str, ch); break;
        case OBJ_TRIGGER: UID_VAR(str, obj); break;
        case WLD_TRIGGER: ROOM_UID_VAR(str, real_room(room->vnum)); break;
        }
      }
      /* General scripting variable "damdone", which is the amount of damage
       * that was done by a wdamage, mdamage, or odamage command. */
      else if (!str_cmp(var, "damdone")) {
         sprintf(str, "%d", trig->damdone);
      }
      else
        *str = '\0';
    }
    return;
  }

  /*
   * If we found a local or global variable above, and a field is
   * being requested, we need to actually locate the character, object,
   * or room.
   */
  if (vd && (name = vd->value) && *name) {
    switch (type) {
    case MOB_TRIGGER:
      if ((o = find_obj_in_eq(ch, NULL, find_by_name(name))));
      else if ((o = find_obj_in_list(ch->carrying, find_by_name(name))));
      else if ((c = find_char_in_room(&world[ch->in_room], find_by_name(name))));
      else if ((o = find_obj_in_list(world[IN_ROOM(ch)].contents, find_by_name(name))));
      else if ((c = find_char_in_world(find_by_name(name))));
      else if ((o = find_obj_in_world(find_by_name(name))));
      else if ((r = get_room(name)));
      break;
    case OBJ_TRIGGER:
      if ((c = find_char_around_obj(obj, find_dg_by_name(name))));
      else if ((o = find_obj_around_obj(obj, find_by_name(name))));
      else if ((r = get_room(name)));
      break;
    case WLD_TRIGGER:
      if ((c = find_char_around_room(room, find_dg_by_name(name))));
      else if ((o = find_obj_around_room(room, find_by_name(name))));
      else if ((r = get_room(name)));
      break;
    }
  }

  /*
   * If no local or global variable named self was found above,
   * then we must be referring to the runner of the trigger.
   */
  else if (!str_cmp(var, "self")) {
    c = ch;
    o = obj;
    r = room;
  }

  /*
   * These are 'static' variables that do not go into the char/obj/room
   * section below.
   */
  else {

    if (!str_cmp(var, "time")) {
      if (!str_cmp(field, "hour"))
        sprintf(str, "%d", time_info.hours);
      else if (!str_cmp(field, "day"))
        sprintf(str, "%d", time_info.day);
      else if (!str_cmp(field, "month"))
        sprintf(str, "%d", time_info.month);
      else if (!str_cmp(field, "year"))
        sprintf(str, "%d", time_info.year);
      else if (!str_cmp(field, "stamp")) {
        num = time_info.year  * SECS_PER_MUD_YEAR +
              time_info.month * SECS_PER_MUD_MONTH +
              time_info.day   * SECS_PER_MUD_DAY +
              time_info.hours * SECS_PER_MUD_HOUR;
        /* Only game-hour granularity is available in triggers. */
        num /= SECS_PER_MUD_HOUR;
        sprintf(str, "%d", num);
      }
      else {
        *str = '\0';
        sprintf(buf2, "Unknown time field '%s'", field);
        script_log(trig, buf2);
      }
    }

    else if (!str_cmp(var, "random")) {

      /* Pick a random character in the room */
      if (!str_cmp(field, "char")) {
        if (type == MOB_TRIGGER)
          c = get_random_char_around(ch, RAND_DG_MOB);
        else if (type == OBJ_TRIGGER)
          c = get_random_char_around(world[obj_room(obj)].people, RAND_DG_OBJ);
        else if (type == WLD_TRIGGER)
          c = get_random_char_around(room->people, RAND_DG_WLD);

        UID_VAR(str, c);
      }

      /* Locate a random room globally */
      else if (!str_cmp(field, "room")) {
        do {
          num = number(0, top_of_world);
        } while (ROOM_FLAGGED(num, ROOM_PRIVATE) ||
                 ROOM_FLAGGED(num, ROOM_DEATH) ||
                 ROOM_FLAGGED(num, ROOM_GODROOM));
        sprintf(str, "%d", world[num].vnum);
      }

      /* Pick a random room in the zone */
      else if (!str_cmp(field, "room_in_zone")) {
        if (type == MOB_TRIGGER && ch->in_room != NOWHERE)
          num = world[ch->in_room].zone;
        else if (type == OBJ_TRIGGER && (num = obj_room(obj)) != NOWHERE)
          num = world[num].zone;
        else if (type == WLD_TRIGGER)
          num = room->zone;
        else
          num = -1;
        if (num >= 0 && (num = get_random_room_in_zone(num)) >= 0)
          sprintf(str, "%d", world[num].vnum);
        else
          strcpy(str, "-1");
      }

      /* Generate a random number */
      else
        sprintf(str, "%d", ((num = atoi(field)) > 0) ? number(1, num) : 0);
    }

    /* Static functions */
    else if (!str_cmp(var, "get")) {
      /* %get.obj_shortdesc[VNUM]% */
      if (!str_cmp(field, "obj_shortdesc")) {
        if (is_positive_integer(value) &&
            (num = real_object(atoi(value))) >= 0)
          strcpy(str, obj_proto[num].short_description);
        else
          sprintf(str, "[no description for object %s]", value);

      } else if (!str_cmp(field, "obj_noadesc")) {
      /* %get.obj_noadesc[VNUM]% */
        if (is_positive_integer(value) &&
            (num = real_object(atoi(value))) >= 0)
          strcpy(str, without_article(obj_proto[num].short_description));
        else
          sprintf(str, "[no description for object %s]", value);

      } else if (!str_cmp(field, "obj_pldesc")) {
      /* %get.obj_pldesc[VNUM]% */
        if (is_positive_integer(value) &&
            (num = real_object(atoi(value))) >= 0)
          strcpy(str, pluralize(obj_proto[num].short_description));
        else
          sprintf(str, "[no description for object %s]", value);

      /* %get.mob_shortdesc[VNUM]% */
      } else if (!str_cmp(field, "mob_shortdesc")) {
        if (is_positive_integer(value) &&
            (num = real_mobile(atoi(value))) >= 0)
          strcpy(str, mob_proto[num].player.short_descr);
        else
          sprintf(str, "[no description for mobile %s]", value);

      /* %get.obj_count[VNUM]% is the number of objects with VNUM in game */
      } else if (!str_cmp(field, "obj_count")) {
        if ((num = real_object(atoi(value))) >= 0)
          sprintf(str, "%d", obj_index[num].number);
        else
          strcpy(str, "0");
      /* %get.mob_count[VNUM]% is the number of mobiles with VNUM in game */
      } else if (!str_cmp(field, "mob_count")) {
        if ((num = real_mobile(atoi(value))) >= 0)
          sprintf(str, "%d", mob_index[num].number);
        else
          strcpy(str, "0");
      /* %get.room[VNUM]% returns a UID variable pointing to that room */
      } else if (!str_cmp(field, "room")) {
        if ((num = real_room(atoi(value))) >= 0)
          ROOM_UID_VAR(str, num);
        else
          strcpy(str, "0");
      /* %get.people[VNUM]% is the number of people in room */
      } else if (!str_cmp(field, "people")) {
        if (is_positive_integer(value) && (num = real_room(atoi(value))) >= 0) {
          ch = world[num].people;
          for (num = 0; ch; ch = ch->next_in_room)
            if (!GET_INVIS_LEV(ch))
              ++num;
          sprintf(str, "%d", num);
        }
        else {
          *str = '\0';
          sprintf(buf2, "get.people[%s]: room '-1' does not exist", value);
          script_log(trig, buf2);
        }
      } else if (!str_cmp(field, "opposite_dir")) {
        if ((num = search_block(value, dirs, FALSE)) >= 0)
          strcpy(str, dirs[rev_dir[num]]);
        else {
          /*
           * If they didn't give a valid direction, then reverse
           * the string, lol.
           */
          for (num = strlen(value) - 1; num >= 0; --num)
            *(str++) = *(value + num);
          *str = '\0';
        }
      } else if (!str_cmp(field, "uidchar"))
        sprintf(str, "%c", UID_CHAR);
      else {
        *str = '\0';
        sprintf(buf2, "Unknown get field: '%s'", field);
        script_log(trig, buf2);
      }
    }

    /* String functions */
    else if (!str_cmp(var, "string")) {

      if (!str_cmp(field, "reverse")) {
        for (num = strlen(value) - 1; num >= 0; --num)
          *(str++) = *(value + num);
        *str = '\0';
      }

      else if (!str_cmp(field, "length"))
        sprintf(str, "%d", strlen(value));

      else if (!str_cmp(field, "tolower")) {
        do {
          *(str++) = LOWER(*(value++));
        }
        while (*value);
      }

      else if (!str_cmp(field, "toupper")) {
        do {
          *(str++) = UPPER(*(value++));
        }
        while (*value);
      }

      else if (!str_cmp(field, "cap") || !str_cmp(field, "capitalize")) {
        strcpy(str, value);
        CAP(str);
      }

      else if (!str_cmp(field, "firstword"))
        any_one_arg(value, str);

      else {
        strcpy(str, value);
        sprintf(buf2, "Unknown string field: '%s'", field);
        script_log(trig, buf2);
      }

    }

    else
      *str = '\0';

    return;
  }

  /*
   * If a local or global variable was located above, or we are
   * accessing the 'self' variable, and we are trying to access
   * a UID variable subfield, then access the field!
   */
  if (c) {
    /* String identifiers */
    if (!str_cmp(field, "name"))
      strcpy(str, GET_SHORT(c) ? GET_SHORT(c) : GET_NAME(c));
    else if (!str_cmp(field, "p") || !str_cmp(field, "hisher"))
      strcpy(str, HSHR(c));    /* Possessive pronoun */
    else if (!str_cmp(field, "o") || !str_cmp(field, "himher"))
      strcpy(str, HMHR(c));    /* Objective pronoun */
    else if (!str_cmp(field, "n") || !str_cmp(field, "heshe"))
      strcpy(str, HSSH(c));    /* Nominative pronoun */
    else if (!str_cmp(field, "alias"))
      strcpy(str, GET_NAME(c));
    else if (!str_cmp(field, "title"))
      strcpy(str, GET_TITLE(c) ? GET_TITLE(c) : "");

    /* Identifying numbers */
    else if (!str_cmp(field, "vnum"))
      sprintf(str, "%d", GET_MOB_VNUM(c));
    else if (!str_cmp(field, "id"))
      sprintf(str, "%ld", GET_ID(c));

    /* Attributes */
    else if (!str_cmp(field, "sex") || !str_cmp(field, "gender"))
      strcpy(str, genders[(int) GET_SEX(c)]);
    else if (!str_cmp(field, "class")) {
      strcpy(str, CLASS_PLAINNAME(c));
      CAP(str);
    }
    else if (!str_cmp(field, "race"))
      strcpy(str, races[(int) GET_RACE(c)].name);
    else if (!str_cmp(field, "level"))
      sprintf(str, "%d", GET_LEVEL(c));

    else if (!str_cmp(field, "weight"))
      sprintf(str, "%d", GET_WEIGHT(c));
    else if (!str_cmp(field, "height"))
      sprintf(str, "%d", GET_HEIGHT(c));
    else if (!str_cmp(field, "size"))
      sprintf(str, "%s", SIZE_DESC(c));

    else if (!str_cmp(field, "cha"))
      sprintf(str, "%d", GET_VIEWED_CHA(c));
    else if (!str_cmp(field, "str"))
      sprintf(str, "%d", GET_VIEWED_STR(c));
    else if (!str_cmp(field, "int"))
      sprintf(str, "%d", GET_VIEWED_INT(c));
    else if (!str_cmp(field, "wis"))
      sprintf(str, "%d", GET_VIEWED_WIS(c));
    else if (!str_cmp(field, "con"))
      sprintf(str, "%d", GET_VIEWED_CON(c));
    else if (!str_cmp(field, "dex"))
      sprintf(str, "%d", GET_VIEWED_DEX(c));

    else if (!str_cmp(field, "real_cha"))
      sprintf(str, "%d", GET_CHA(c));
    else if (!str_cmp(field, "real_str"))
      sprintf(str, "%d", GET_STR(c));
    else if (!str_cmp(field, "real_int"))
      sprintf(str, "%d", GET_INT(c));
    else if (!str_cmp(field, "real_wis"))
      sprintf(str, "%d", GET_WIS(c));
    else if (!str_cmp(field, "real_con"))
      sprintf(str, "%d", GET_CON(c));
    else if (!str_cmp(field, "real_dex"))
      sprintf(str, "%d", GET_DEX(c));

    else if (!str_cmp(field, "hit"))
      sprintf(str, "%d", GET_HIT(c));
    else if (!str_cmp(field, "maxhit"))
      sprintf(str, "%d", GET_MAX_HIT(c));
    else if (!str_cmp(field, "move"))
      sprintf(str, "%d", GET_MOVE(c));
    else if (!str_cmp(field, "maxmove"))
      sprintf(str, "%d", GET_MAX_MOVE(c));
    else if (!str_cmp(field, "armor"))
      sprintf(str, "%d", GET_AC(c));
    else if (!str_cmp(field, "hitroll"))
      sprintf(str, "%d", GET_HITROLL(c));
    else if (!str_cmp(field, "damroll"))
      sprintf(str, "%d", GET_DAMROLL(c));
    else if (!str_cmp(field, "exp"))
      sprintf(str, "%ld", GET_EXP(c));
    else if (!str_cmp(field, "perception"))
      sprintf(str, "%ld", GET_PERCEPTION(c));
    else if (!str_cmp(field, "hiddenness"))
      sprintf(str, "%ld", GET_HIDDENNESS(c));
    else if (!str_cmp(field, "align") || !str_cmp(field, "alignment"))
      sprintf(str, "%d", GET_ALIGNMENT(c));

    else if (is_coin_name(field, PLATINUM))
      sprintf(str, "%d", GET_PLATINUM(c));
    else if (is_coin_name(field, GOLD))
      sprintf(str, "%d", GET_GOLD(c));
    else if (is_coin_name(field, SILVER))
      sprintf(str, "%d", GET_SILVER(c));
    else if (is_coin_name(field, COPPER))
      sprintf(str, "%d", GET_COPPER(c));

    /* Flags */
    else if (!str_cmp(field, "flags")) {
      *str = '\0';
      if (IS_NPC(c)) /* ACT flags */
        sprintflag(str, MOB_FLAGS(c), NUM_MOB_FLAGS, action_bits);
      else { /* concatenation of PLR and PRF flags */
        if (HAS_FLAGS(PLR_FLAGS(c), NUM_PLR_FLAGS) ||
            !HAS_FLAGS(PRF_FLAGS(c), NUM_PRF_FLAGS))
          sprintflag(str, PLR_FLAGS(c), NUM_PLR_FLAGS, player_bits);
        if (HAS_FLAGS(PRF_FLAGS(c), NUM_PRF_FLAGS))
          sprintflag(str + strlen(str), PRF_FLAGS(c), NUM_PRF_FLAGS, preference_bits);
      }
    }
    else if (!str_cmp(field, "flagged")) {
      if (IS_NPC(c)) {
        if ((num = search_block(value, action_bits, FALSE)) >= 0)
          strcpy(str, MOB_FLAGGED(c, num) ? "1" : "0");
        else {
          strcpy(str, "0");
          sprintf(buf2, "unrecognized NPC flag '%s' to %%%s.flagged[]%%",
                  value, var);
          script_log(trig, buf2);
        }
      }
      else {
        if ((num = search_block(value, player_bits, FALSE)) >= 0)
          strcpy(str, PLR_FLAGGED(c, (1 << num)) ? "1" : "0");
        else if ((num = search_block(value, preference_bits, FALSE)) >= 0)
          strcpy(str, PRF_FLAGGED(c, (1 << num)) ? "1" : "0");
        else {
          strcpy(str, "0");
          sprintf(buf2, "unrecognized player or preference flag '%s' to %%%s.flagged[]%%",
                  value, var);
          script_log(trig, buf2);
        }
      }
    }
    else if (!str_cmp(field, "aff_flags") || !str_cmp(field, "eff_flags"))
      sprintflag(str, EFF_FLAGS(c), NUM_EFF_FLAGS, effect_flags);

    else if (!str_cmp(field, "aff_flagged") || !str_cmp(field, "eff_flagged")) {
      if ((num = search_block(value, effect_flags, FALSE)) >= 0)
        strcpy(str, EFF_FLAGGED(c, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized effect flag '%s' to %%%s.eff_flagged[]%%",
                value, var);
        script_log(trig, buf2);
      }

    }
    else if (!str_cmp(field, "spells")) {
      struct effect *eff;
      *str = '\0';
      for (eff = c->effects; eff; eff = eff->next)
        if (eff->duration >= 0 && (!eff->next || eff->next->type != eff->type)) {
          strcat(str, skills[eff->type].name);
          strcat(str, " ");
        }
    }
    else if (!str_cmp(field, "has_spell")) {
      if ((num = find_talent_num(value, 0)) >= 0)
        strcpy(str, affected_by_spell(c, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized spell '%s' to %%%s.has_spell[]%%",
                value, var);
        script_log(trig, buf2);
      }
    }

    /* Character relationships */
    else if (!str_cmp(field, "fighting"))
      UID_VAR(str, FIGHTING(c));
    else if (!str_cmp(field, "hunting"))
      UID_VAR(str, HUNTING(c));
    else if (!str_cmp(field, "riding"))
      UID_VAR(str, RIDING(c));
    else if (!str_cmp(field, "ridden_by"))
      UID_VAR(str, RIDDEN_BY(c));
    else if (!str_cmp(field, "consented"))
      UID_VAR(str, CONSENT(c));
    else if (!str_cmp(field, "master"))
      UID_VAR(str, c->master);
    else if (!str_cmp(field, "next_in_room")) {
      /* Skip any wiz-invis folks */
      while (c->next_in_room && GET_INVIS_LEV(c->next_in_room))
        c = c->next_in_room;
      UID_VAR(str, c->next_in_room);
    }
    else if (!str_cmp(field, "group_size"))
      sprintf(str, "%d", group_size(c));
    else if (!str_cmp(field, "group_member")) {
      ch = c->group_master ? c->group_master : c;

      num = atoi(value);

      if (!IS_GROUPED(ch) || num <= 0)
        UID_VAR(str, c);
      else if (num == 1)
        UID_VAR(str, ch);
      else {
        struct group_type *g;
        for (g = ch->groupees; g; g = g->next) {
          if (--num > 1)
            continue;
          UID_VAR(str, g->groupee);
          break;
        }
        if (num > 1)
          strcpy(str, "0");
      }
    }

    /* Quests */
    else if (!str_cmp(field, "quest_variable")) {
      if (!*value) {
        script_log(trig, "quest_variable called without specifying a quest");
        strcpy(str, "0");
      }
      else if (IS_NPC(c))
        strcpy(str, "0");
      else {
        char *varptr;
        for (varptr = value; *varptr && *varptr != ':'; ++varptr);
        *(varptr++) = '\0';
        if (!*varptr) {
          script_log(trig, "quest_variable called without specifying a variable");
          strcpy(str, "0");
        }
        else
          strcpy(str, get_quest_variable(c, value, varptr));
      }
    }

    else if (!str_cmp(field, "quest_stage")) {
      if (!*value) {
        script_log(trig, "quest_stage called without specifying a quest");
        strcpy(str, "0");
      }
      else if (IS_NPC(c))
        strcpy(str, "0");
      else
        sprintf(str, "%d", quest_stage(c, value));
    }

    else if (!str_cmp(field, "has_completed")) {
      if (!*value) {
        script_log(trig, "has_completed called without specifying a quest");
        strcpy(str, "0");
      }
      else if (IS_NPC(c))
        strcpy(str, "0");
      else
        strcpy(str, has_completed_quest(value, c) ? "1" : "0");
    }

    else if (!str_cmp(field, "has_failed")) {
      if (!*value) {
        script_log(trig, "has_failed called without specifying a quest");
        strcpy(str, "0");
      }
      else if (IS_NPC(c))
        strcpy(str, "0");
      else
        strcpy(str, has_failed_quest(value, c) ? "1" : "0");
    }

    /* Object relationships */
    else if (!str_cmp(field, "inventory")) {
      if (!str_cmp(value, "count"))
        sprintf(str, "%d", IS_CARRYING_N(c));
      else if (*value) {
        /* An argument was given: find a specific object. */
        num = atoi(value);
        for (obj = c->carrying; obj; obj = obj->next_content)
          if (GET_OBJ_VNUM(obj) == num) {
            UID_VAR(str, obj);
            break;
          }
        if (!obj) /* No matching object found. */
          strcpy(str, "0");
      }
      else
        /* No argument given: return the first inventory item */
        UID_VAR(str, c->carrying);
    }
    else if (!str_cmp(field, "worn")) {
      int pos;
      if (!str_cmp(value, "count")) {
        for (num = pos = 0; pos < NUM_WEARS; ++pos)
          if (GET_EQ(c, pos))
            ++num;
        sprintf(str, "%d", num);
      }
      else if ((pos = search_block(value, wear_positions, TRUE)) >= 0)
        UID_VAR(str, GET_EQ(c, pos));
      else
        strcpy(str, "0");
    }
    else if (!str_cmp(field, "wearing")) {
      if (is_positive_integer(value)) {
        int pos;
        num = atoi(value);
        for (pos = 0; pos < NUM_WEARS; ++pos)
          if (GET_EQ(c, pos) && GET_OBJ_VNUM(GET_EQ(c, pos)) == num) {
            UID_VAR(str, GET_EQ(c, pos));
            break;
          }
        /* Not found */
        if (pos >= NUM_WEARS)
          strcpy(str, "0");
      }
      else
        strcpy(str, "0");
    }

    else if (!str_cmp(field, "position")) {
       strcpy(str, position_types[(int)GET_POS(c)]);
    }
    else if (!str_cmp(field, "stance"))
      strcpy(str, stance_types[(int) GET_STANCE(c)]);

    else if (!str_cmp(field, "room")) {
      if (IN_ROOM(c) >= 0 && IN_ROOM(c) <= top_of_world)
        sprintf(str, "%d", world[IN_ROOM(c)].vnum);
      else
        strcpy(str, "-1");
    }

    else if (!str_cmp(field, "talent") || !str_cmp(field, "skill")) {
      int talent = find_talent_num(value, 0);
      if (talent < 0)
        strcpy(str, "0");
      else
        sprintf(str, "%d", GET_SKILL(c, talent));
    }

    else if (!str_cmp(field, "clan")) {
      if (!IS_NPC(c) && GET_CLAN(c))
        strcpy(str, GET_CLAN(c)->name);
      else
        *str = '\0';
    }
    else if (!str_cmp(field, "clan_rank"))
      sprintf(str, "%d", IS_NPC(c) ? 0 : GET_CLAN_RANK(c));

    else if (!str_cmp(field, "can_be_seen"))
      strcpy(str, type == MOB_TRIGGER && !CAN_SEE(ch, c) ? "0" : "1");

    else if (!str_cmp(field, "trophy")) {
      if (IS_NPC(c))
        *str = '\0';
      else {
        struct trophy_node *node;
        num = value && *value ? atoi(value) : -1;
        *str = '\0';
        for (node = GET_TROPHY(c); node; node = node->next) {
          /* Getting list of kills */
          if (num < 0) {
            if (node->kill_type == TROPHY_MOBILE)
              sprintf(str, "%s%d ", str, node->id);
          }
          /* Looking for a specific mobile: give count if it exists */
          else if (node->kill_type == TROPHY_MOBILE && node->id == num) {
            sprintf(str, "%d", (int) node->amount);
            break;
          }
        }
        /* No mobiles found.  0 amount. */
        if (*str == '\0')
          strcpy(str, "0");
      }
    }

    else {
      *str = '\0';
      sprintf(buf2, "Unknown char field: '%s'", field);
      script_log(trig, buf2);
    }
  }

  else if (o) {
    /* String identifiers */
    if (!str_cmp(field, "name"))
      strcpy(str, o->name);
    else if (!str_cmp(field, "shortdesc"))
      strcpy(str, o->short_description);
    else if (!str_cmp(field, "description"))
      strcpy(str, o->description);

    /* Identifying numbers */
    else if (!str_cmp(field, "vnum"))
      sprintf(str, "%d", GET_OBJ_VNUM(o));
    else if (!str_cmp(field, "type"))
      strcpy(str, OBJ_TYPE_NAME(o));
    else if (!str_cmp(field, "id"))
      sprintf(str, "%ld", GET_ID(o));

    /* Numerical attributes */
    else if (!str_cmp(field, "weight"))
      sprintf(str, "%.2f", o->obj_flags.weight);
    else if (!str_cmp(field, "cost"))
      sprintf(str, "%d", GET_OBJ_COST(o));
    else if (!str_cmp(field, "cost_per_day") || !str_cmp(field, "rent"))
      strcpy(str, "0");
    else if (!str_cmp(field, "level"))
      sprintf(str, "%d", GET_OBJ_LEVEL(o));
    else if (!str_cmp(field, "val0"))
      sprintf(str, "%d", GET_OBJ_VAL(o, 0));
    else if (!str_cmp(field, "val1"))
      sprintf(str, "%d", GET_OBJ_VAL(o, 1));
    else if (!str_cmp(field, "val2"))
      sprintf(str, "%d", GET_OBJ_VAL(o, 2));
    else if (!str_cmp(field, "val3"))
      sprintf(str, "%d", GET_OBJ_VAL(o, 3));
    else if (!str_cmp(field, "timer"))
      sprintf(str, "%d", GET_OBJ_TIMER(o));
    else if (!str_cmp(field, "decomp"))
      sprintf(str, "%d", GET_OBJ_DECOMP(o));
    else if (!str_cmp(field, "hiddenness"))
      sprintf(str, "%ld", GET_OBJ_HIDDENNESS(o));
    else if (!str_cmp(field, "affect") || !str_cmp(field, "effect")) {
      if (!is_positive_integer(value) || (num = atoi(value)) > 5)
        *str = '\0';
      else
        sprintf(str, "%+d %s", o->applies[num].modifier,
                apply_types[(int) o->applies[num].location]);
    }
    else if (!str_cmp(field, "affect_value") ||
             !str_cmp(field, "effect_value"))
      sprintf(str, "%d",
              is_positive_integer(value) && (num = atoi(value) <= 5) ?
              o->applies[num].modifier : 0);

    /* Flags */
    else if (!str_cmp(field, "flags"))
      sprintflag(str, GET_OBJ_FLAGS(o), NUM_ITEM_FLAGS, extra_bits);
    else if (!str_cmp(field, "flagged")) {
      if ((num = search_block(value, extra_bits, FALSE)) >= 0)
        strcpy(str, OBJ_FLAGGED(o, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized object extra bit '%s' to %%%s.flagged[]%%",
                value, var);
        script_log(trig, buf2);
      }
    }
    else if (!str_cmp(field, "spells"))
      sprintflag(str, GET_OBJ_EFF_FLAGS(o), NUM_EFF_FLAGS, effect_flags);

    else if (!str_cmp(field, "has_spell")) {
      if ((num = search_block(value, effect_flags, FALSE)) >= 0)
        strcpy(str, OBJ_EFF_FLAGGED(o, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized effect flag '%s' to %%%s.has_spell[]%%",
                value, var);
        script_log(trig, buf2);
      }
    }

    /* Location */
    else if (!str_cmp(field, "room")) {
      num = obj_room(o);
      if (num != NOWHERE)
        sprintf(str, "%d", world[num].vnum);
      else
        strcpy(str, "-1");
    }
    else if (!str_cmp(field, "carried_by"))
      UID_VAR(str, o->carried_by);
    else if (!str_cmp(field, "worn_by"))
      UID_VAR(str, o->worn_by);
    else if (!str_cmp(field, "worn_on")) {
      if (o->worn_by)
        sprinttype(o->worn_on, wear_positions, str);
      else
        *str = '\0';
    }
    else if (!str_cmp(field, "contents")) {
      if (!str_cmp(value, "count")) {
        for (num = 0, o = o->contains; o; o = o->next_content)
          ++num;
        sprintf(str, "%d", num);
      }
      else if (*value) {
        /* An argument was given: find a specific object. */
        num = atoi(value);
        for (obj = o->contains; obj; obj = obj->next_content)
          if (GET_OBJ_VNUM(obj) == num) {
            UID_VAR(str, obj);
            break;
          }
        if (!obj) /* No matching object found. */
          strcpy(str, "0");
      }
      else
        UID_VAR(str, o->contains);
    }
    else if (!str_cmp(field, "next_in_list"))
      UID_VAR(str, o->next_content);

    else {
      *str = '\0';
      sprintf(buf2, "trigger type: %d. unknown object field: '%s'", type, field);
      script_log(trig, buf2);
    }
  }

  /*
   * Room variables
   */
  else if (r) {
    if (!str_cmp(field, "name"))
      strcpy(str, r->name);

    else if (!str_cmp(field, "vnum"))
      sprintf(str, "%d", r->vnum);
    else if (!strn_cmp(field, "sector", 6))
      sprintf(str, "%s", sectors[r->sector_type].name);
    else if (!str_cmp(field, "is_dark"))
      strcpy(str, r->light > 0 ? "1" : "0");

    else if (!str_cmp(field, "flags"))
      sprintflag(str, r->room_flags, NUM_ROOM_FLAGS, room_bits);
    else if (!str_cmp(field, "flagged")) {
      if ((num = search_block(value, room_bits, FALSE)) >= 0)
        strcpy(str, IS_FLAGGED(r->room_flags, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized room flag '%s' to %%%s.flagged%%",
                value, var);
        script_log(trig, buf2);
      }
    }
    else if (!str_cmp(field, "effects") || !str_cmp(field, "affects"))
      sprintflag(str, r->room_effects, NUM_ROOM_EFF_FLAGS, room_effects);
    else if (!str_cmp(field, "has_effect") || !str_cmp(field, "has_affect")) {
      if ((num = search_block(value, room_effects, FALSE)) >= 0)
        strcpy(str, IS_FLAGGED(r->room_effects, num) ? "1" : "0");
      else {
        strcpy(str, "0");
        sprintf(buf2, "unrecognized room effect flag '%s' to %%%s.has_effect%%",
                value, var);
        script_log(trig, buf2);
      }
    }

    else if (!str_cmp(field, "objects")) {
      if (!str_cmp(value, "count")) {
        for (num = 0, o = r->contents; o; o = o->next_content)
          ++num;
        sprintf(str, "%d", num);
      }
      else if (*value) {
        /* An argument was given: find a specific object. */
        num = atoi(value);
        for (obj = r->contents; obj; obj = obj->next_content)
          if (GET_OBJ_VNUM(obj) == num) {
            UID_VAR(str, obj);
            break;
          }
        if (!obj) /* No matching object found. */
          strcpy(str, "0");
      }
      else
        UID_VAR(str, r->contents);
    }
    else if (!str_cmp(field, "people")) {
      if (!str_cmp(value, "count")) {
        for (num = 0, c = r->people; c; c = c->next_in_room)
          if (!GET_INVIS_LEV(c))
             ++num;
        sprintf(str, "%d", num);
      }
      else if (*value) {
        /* An argument was given: find a specific vnum. */
        num = atoi(value);
        for (ch = r->people; ch; ch = ch->next_in_room)
          if (GET_MOB_VNUM(ch) == num) {
            UID_VAR(str, ch);
            break;
          }
        if (!ch) /* No matching mobile found. */
          strcpy(str, "0");
      }
      else {
        /* Skip any wiz-invis folks */
        c = r->people;
        while (c && GET_INVIS_LEV(c))
          c = c->next_in_room;
        UID_VAR(str, c);
      }
    }

    /* Exits can have values (which are actually sub-sub-variables)  */
    else if ((num = search_block(field, dirs, TRUE)) >= 0) {
      if (!r->exits[num])
        strcpy(str, "-1");
      else if (!*value) /* %room.DIR% is a vnum */
        sprintf(str, "%d", r->exits[num]->to_room != NOWHERE ?
                world[r->exits[num]->to_room].vnum: -1);
      else if (!str_cmp(value, "room")) { /* %room.DIR[room]% */
        if (r->exits[num]->to_room != NOWHERE)
          ROOM_UID_VAR(str, r->exits[num]->to_room);
        else
          strcpy(str, "0");
      }
      else if (!str_cmp(value, "key"))  /* %room.DIR[key]% */
        sprintf(str, "%d", r->exits[num]->key);
      else if (!str_cmp(value, "bits")) /* %room.DIR[bits]% */
        sprintbit(r->exits[num]->exit_info, exit_bits, str);
      else
        *str = '\0';
    }

    else {
      *str = '\0';
      sprintf(buf2, "trigger type: %d. unknown room field: '%s'",
              type, field);
      script_log(trig, buf2);
    }
  }

  else {
    *str = '\0';
    /*
     * We didn't find a matching character, object, or room, but we
     * located a variable earlier than that.  If we attempted to
     * access a subfield on a non-UID variable, log an error.
     */
    if (vd && vd->value) {
      sprintf(buf2, "attempt to access field '%s' on %s variable '%s'",
              field,
              !*vd->value              ? "empty" :
               (*vd->value == UID_CHAR ? "previously extracted UID" :
                                         "non-UID"),
              var);
      script_log(trig, buf2);
    }
  }
}


/* substitutes any variables into line and returns it as buf */
void var_subst(void *go, struct script_data *sc, trig_data *trig,
               int type, char *line, char *buf)
{
  char tmp[MAX_INPUT_LENGTH], repl_str[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH];
  char *var, *field, *subfield, *p;
  int left, len;

  /* Skip if no %'s */
  if (!strchr(line, '%')) {
    strcpy(buf, line);
    return;
  }

  p = strcpy(tmp, line);
  value[0] = '\0';

  left = MAX_INPUT_LENGTH - 1;

  while (*p && (left > 0)) {

    /* Copy until we find the first % */
    while (*p && (*p != '%') && (left > 0)) {
      *(buf++) = *(p++);
      left--;
    }

    *buf = '\0';

    /* double % */
    if (*p && (*(++p) == '%') && (left > 0)) {
      *(buf++) = *(p++);
      *buf = '\0';
      left--;
      continue;
    }

    else if (*p && (left > 0)) {

      /* search until end of var or beginning of field */
      for (var = p; *p && (*p != '%') && (*p != '.'); ++p);

      field = p;
      if (*p == '.') {
        *(p++) = '\0';

        /* search until end of field or beginning of subfield/value */
        for (field = p; *p && (*p != '%') && (*p != '['); ++p);

        subfield = p;
        if (*p == '[') {
          *(p++) = '\0';

          /* search until the end of the value */
          for (subfield = p; *p && (*p != ']'); ++p);

          if (*p == ']')
            *(p++) = '\0';
          else if (*p == '%')
            *p = '\0'; /* but don't increment p yet */

          var_subst(go, sc, trig, type, subfield, value);
        }
      }

      *(p++) = '\0';

      find_replacement(go, sc, trig, type, var, field, value, repl_str);

      strncat(buf, repl_str, left);
      len = strlen(repl_str);
      buf += len;
      left -= len;
    }
  }
}


/* returns 1 if string is all digits, else 0 */
int is_num(char *num)
{
  if (*num == '\0')
    return FALSE;

  if (*num == '+' || *num == '-')
    ++num;

  for (; *num != '\0'; ++num)
    if (!isdigit(*num))
      return FALSE;

  return TRUE;
}


/* evaluates 'lhs op rhs', and copies to result */
void eval_op(char *op, char *lhs, char *rhs, char *result, void *go,
             struct script_data *sc, trig_data *trig)
{
  char *p;
  int n;

  /* strip off extra spaces at begin and end */
  while (*lhs && isspace(*lhs))
    lhs++;
  while (*rhs && isspace(*rhs))
    rhs++;

  for (p = lhs; *p; p++);
  for (--p; isspace(*p) && (p > lhs); *p-- = '\0');
  for (p = rhs; *p; p++);
  for (--p; isspace(*p) && (p > rhs); *p-- = '\0');


  /* find the op, and figure out the value */
  if (!strcmp("||", op)) {
    if ((!*lhs || (*lhs == '0')) && (!*rhs || (*rhs == '0')))
      strcpy(result, "0");
    else
      strcpy(result, "1");
  }

  else if (!strcmp("&&", op)) {
    if (!*lhs || (*lhs == '0') || !*rhs || (*rhs == '0'))
      strcpy (result, "0");
    else
      strcpy (result, "1");
  }

  else if (!strcmp("==", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) == atoi(rhs));
    else
      sprintf(result, "%d", !str_cmp(lhs, rhs));
  }

  else if (!strcmp("!=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) != atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs));
  }

  else if (!strcmp("<=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) <= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp(">=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) >= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp("<", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) < atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) < 0);
  }

  else if (!strcmp(">", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) > atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) > 0);
  }

  else if (!strcmp("/=", op))
    sprintf(result, "%c", str_str(lhs, rhs) ? '1' : '0');

  else if (!strcmp("*", op))
    sprintf(result, "%d", atoi(lhs) * atoi(rhs));

  else if (!strcmp("/", op))
    sprintf(result, "%d", (n = atoi(rhs)) ? (atoi(lhs) / n) : 0);

  else if (!strcmp("+", op))
    sprintf(result, "%d", atoi(lhs) + atoi(rhs));

  else if (!strcmp("-", op))
    sprintf(result, "%d", atoi(lhs) - atoi(rhs));

  else if (!strcmp("!", op)) {
    if (is_num(rhs))
      sprintf(result, "%d", !atoi(rhs));
    else
      sprintf(result, "%d", !*rhs);
  }
}


/*
 * p points to the first quote, returns the matching
 * end quote, or the last non-null char in p.
*/
char *matching_quote(char *p)
{
  for (p++; *p && (*p != '"'); p++) {
    if (*p == '\\')
      p++;
  }

  if (!*p)
    p--;

  return p;
}

/*
 * p points to the first paren.  returns a pointer to the
 * matching closing paren, or the last non-null char in p.
 */
char *matching_paren(char *p)
{
  int i;

  for (p++, i = 1; *p && i; p++) {
    if (*p == '(')
      i++;
    else if (*p == ')')
      i--;
    else if (*p == '"')
      p = matching_quote(p);
  }

  return --p;
}


/* evaluates line, and returns answer in result */
void eval_expr(char *line, char *result, void *go, struct script_data *sc,
               trig_data *trig, int type)
{
  char expr[MAX_INPUT_LENGTH], *p;

  while (*line && isspace(*line))
    line++;

  if (eval_lhs_op_rhs(line, result, go, sc, trig, type));

  else if (*line == '(') {
    p = strcpy(expr, line);
    p = matching_paren(expr);
    *p = '\0';
    eval_expr(expr + 1, result, go, sc, trig, type);
  }

  else
    var_subst(go, sc, trig, type, line, result);
}


/*
 * evaluates expr if it is in the form lhs op rhs, and copies
 * answer in result.  returns 1 if expr is evaluated, else 0
 */
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
                    trig_data *trig, int type)
{
  char *p, *tokens[MAX_INPUT_LENGTH];
  char line[MAX_INPUT_LENGTH], lhr[MAX_INPUT_LENGTH], rhr[MAX_INPUT_LENGTH];
  int i, j;

  /*
   * valid operands, in order of priority
   * each must also be defined in eval_op()
   */
  static char *ops[] = {
    "||",
    "&&",
    "==",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    "/=",
    "-",
    "+",
    "/",
    "*",
    "!",
    "\n"
  };

  p = strcpy(line, expr);

  /*
   * initialize tokens, an array of pointers to locations
   * in line where the ops could possibly occur.
   */
  for (j = 0; *p; j++) {
    tokens[j] = p;
    if (*p == '(')
      p = matching_paren(p) + 1;
    else if (*p == '"')
      p = matching_quote(p) + 1;
    else if (isalnum(*p))
      for (p++; *p && (isalnum(*p) || isspace(*p)); p++);
    else
      p++;
  }
  tokens[j] = NULL;

  for (i = 0; *ops[i] != '\n'; i++)
    for (j = 0; tokens[j]; j++)
      if (!strn_cmp(ops[i], tokens[j], strlen(ops[i]))) {
        *tokens[j] = '\0';
        p = tokens[j] + strlen(ops[i]);
        
        eval_expr(line, lhr, go, sc, trig, type);
        eval_expr(p, rhr, go, sc, trig, type);
        eval_op(ops[i], lhr, rhr, result, go, sc, trig);
        
        return 1;
      }

  return 0;
}



/* returns 1 if cond is true, else 0 */
int process_if(char *cond, void *go, struct script_data *sc,
               trig_data *trig, int type)
{
  char result[MAX_INPUT_LENGTH], *p;

  eval_expr(cond, result, go, sc, trig, type);

  p = result;
  skip_spaces(&p);

  if (!*p || *p == '0')
    return 0;
  else
    return 1;
}


/*
 * scans for end of if-block.
 * returns the line containg 'end', or the last
 * line of the trigger if not found.
 */
struct cmdlist_element *find_end(trig_data *trig, struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next)) {
    script_log(trig, "'if' without 'end'. (error 1)");
    return cl;
  }

  for (c = cl->next; c; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("if ", p, 3))
      c = find_end(trig, c);
    else if (!strn_cmp("end", p, 3))
      return c;

    if (!c->next) {
      script_log(trig, "'if' without 'end'. (error 2)");
      return c;
    }
  }

  script_log(trig, "'if' without 'end'. (error 3)");
  return c;
}


/*
 * searches for valid elseif, else, or end to continue execution at.
 * returns line of elseif, else, or end if found, or last line of trigger.
 */
struct cmdlist_element *find_else_end(trig_data *trig,
                                      struct cmdlist_element *cl, void *go,
                                      struct script_data *sc, int type)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++); /* skip spaces */

    if (!strn_cmp("if ", p, 3))
      c = find_end(trig, c);

    else if (!strn_cmp("elseif ", p, 7)) {
      if (process_if(p + 7, go, sc, trig, type)) {
        GET_TRIG_DEPTH(trig)++;
        return c;
      }
    }

    else if (!strn_cmp("else", p, 4)) {
      GET_TRIG_DEPTH(trig)++;
      return c;
    }

    else if (!strn_cmp("end", p, 3))
      return c;

    if (!c->next) {
      script_log(trig, "'if' without 'end'. (error 4)");
      return c;
    }
  }

  /* If we got here, it's the last line, if it's not an end, log it. */
  for (p = c->cmd; *p && isspace(*p); ++p); /* skip spaces */
  if (strn_cmp("end", p, 3))
    script_log(trig, "'if' without 'end'. (error 5)");

  return c;
}


/* processes any 'wait' commands in a trigger */
void process_wait(void *go, trig_data *trig, int type, char *cmd,
                  struct cmdlist_element *cl)
{
  char buf[MAX_INPUT_LENGTH], *arg;
  struct wait_event_data *wait_event_obj;
  long time, hr, min, ntime;
  char c;

  extern pulse_t global_pulse;


  arg = any_one_arg(cmd, buf);
  skip_spaces(&arg);

  if (!*arg) {
    sprintf(buf2, "Wait w/o an arg: '%s'", cl->cmd);
    script_log(trig, buf2);
    return;
  }

  else if (!strn_cmp(arg, "until ", 6)) {

    /* valid forms of time are 14:30 and 1430 */
    if (sscanf(arg, "until %ld:%ld", &hr, &min) == 2)
      min += (hr * 60);
    else
      min = (hr % 100) + ((hr / 100) * 60);

    /* calculate the pulse of the day of "until" time */
    ntime = (min * SECS_PER_MUD_HOUR * PASSES_PER_SEC) / 60;

    /* calculate pulse of day of current time */
    time = (global_pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC)) +
      (time_info.hours * SECS_PER_MUD_HOUR * PASSES_PER_SEC);

    if (time >= ntime) /* adjust for next day */
      time = (SECS_PER_MUD_DAY * PASSES_PER_SEC) - time + ntime;
    else
      time = ntime - time;
  }

  else {
    if (sscanf(arg, "%ld %c", &time, &c) == 2) {
      if (c == 't')
        time *= PULSES_PER_MUD_HOUR;
      else if (c == 's')
        time *= PASSES_PER_SEC;
    }
  }

  CREATE(wait_event_obj, struct wait_event_data, 1);
  wait_event_obj->trigger = trig;
  wait_event_obj->go = go;
  wait_event_obj->type = type;

  GET_TRIG_WAIT(trig) = event_create(EVENT_TRIGGER_WAIT, trig_wait_event,
        wait_event_obj, TRUE, NULL, time);
  trig->curr_state = cl->next;
}


/* processes a script set command */
void process_set(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH], *value;

  value = two_arguments(cmd, arg, name);

  skip_spaces(&value);

  if (!*name) {
    sprintf(buf2, "Set w/o an arg: '%s'", cmd);
    script_log(trig, buf2);
    return;
  }

  add_var(&GET_TRIG_VARS(trig), name, value);

}

/* processes a script eval command */
void process_eval(void *go, struct script_data *sc, trig_data *trig,
                  int type, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
  char result[MAX_INPUT_LENGTH], *expr;

  expr = two_arguments(cmd, arg, name);

  skip_spaces(&expr);

  if (!*name) {
    sprintf(buf2, "Eval w/o an arg: '%s'", cmd);
    script_log(trig, buf2);
    return;
  }

  eval_expr(expr, result, go, sc, trig, type);
  add_var(&GET_TRIG_VARS(trig), name, result);
}


/*
 * processes a script return command.
 * returns the new value for the script to return.
 */
int process_return(trig_data *trig, char *cmd)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  two_arguments(cmd, arg1, arg2);

  if (!*arg2) {
    sprintf(buf2, "Return w/o an arg: '%s'", cmd);
    script_log(trig, buf2);
    return 1;
  }

  return atoi(arg2);
}


/*
 * removes a variable from the global vars of sc,
 * or the local vars of trig if not found in global list.
 */
void process_unset(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], *var;

  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Unset w/o an arg: '%s'", cmd);
    script_log(trig, buf2);
    return;
  }

  if (!remove_var(&(sc->global_vars), var))
    remove_var(&GET_TRIG_VARS(trig), var);
}


/*
 * makes a local variable into a global variable
 */
void process_global(struct script_data *sc, trig_data *trig, char *cmd)
{
  struct trig_var_data *vd;
  char arg[MAX_INPUT_LENGTH], *varlist;

  varlist = any_one_arg(cmd, arg);

  skip_spaces(&varlist);

  if (!*varlist) {
    sprintf(buf2, "Global w/o an arg: '%s'", cmd);
    script_log(trig, buf2);
    return;
  }

  while (*varlist) {
    varlist = any_one_arg(varlist, arg);
    skip_spaces(&varlist);

    for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
      if (!str_cmp(vd->name, arg))
        break;

    if (!vd) {
      sprintf(buf2, "Local var '%s' not found in global call", arg);
      script_log(trig, buf2);
      continue;
    }

    add_var(&(sc->global_vars), vd->name, vd->value);
    remove_var(&GET_TRIG_VARS(trig), vd->name);
  }
}




/*
 * This is the core driver for scripts.
 *
 * Arguments:
 * void *go_address
 *   A pointer to a pointer to the entity running the script.  The
 *   reason for this approach is that we want to be able to see from the
 *   calling function if the entity has been free'd.
 * trig_data *trig
 *   A pointer to the current running trigger.
 * int type
 *   MOB_TRIGGER, OBJ_TRIGGER, or WLD_TRIGGER.
 * int mode
 *   TRIG_NEW     just started from dg_triggers.c
 *   TRIG_RESTART restarted after a 'wait'
 */
int script_driver(void *go_address, trig_data *trig, int type, int mode)
{
  static int depth = 0;
  int ret_val = 1;
  struct cmdlist_element *cl;
  char cmd[MAX_INPUT_LENGTH], *p;
  struct script_data *sc = 0;
  struct cmdlist_element *temp;
  unsigned long loops = 0;
  void *go = NULL;

  void obj_command_interpreter(obj_data *obj, struct trig_data *t,char *argument);
  void wld_command_interpreter(struct room_data *room, struct trig_data *t,char *argument);

  if (depth > MAX_SCRIPT_DEPTH) {
  switch (type) {
  case MOB_TRIGGER:
    sprintf(buf, "Triggers recursed beyond maximum allowed depth on mob %d",
            GET_MOB_VNUM((char_data *) go));
    break;
  case OBJ_TRIGGER:
    sprintf(buf, "Triggers recursed beyond maximum allowed depth on obj %d",
            GET_OBJ_VNUM((obj_data *) go));
    break;
  case WLD_TRIGGER:
    sprintf(buf, "Triggers recursed beyond maximum allowed depth in room %d",
            ((struct room_data *) go)->vnum);
    break;
  }
    script_log(trig, buf);
    return ret_val;
  }

  depth++;

  switch (type) {
  case MOB_TRIGGER:
    go = *(char_data **) go_address;
    sc = SCRIPT((char_data *) go);
    break;
  case OBJ_TRIGGER:
    go = *(obj_data **) go_address;
    sc = SCRIPT((obj_data *) go);
    break;
  case WLD_TRIGGER:
    go = *(room_data **) go_address;
    sc = SCRIPT((struct room_data *) go);
    break;
  }

  if (mode == TRIG_NEW) {
    GET_TRIG_DEPTH(trig) = 1;
    GET_TRIG_LOOPS(trig) = 0;
  }

  trig->running = TRUE;
  for (cl = (mode == TRIG_NEW) ? trig->cmdlist : trig->curr_state;
       cl && GET_TRIG_DEPTH(trig); cl = cl->next) {
    /* no point in continuing if the mob has zapped itself...*/
    if (trig->purged)
      break;

    if (type == MOB_TRIGGER && !(trig->trigger_type & MTRIG_DEATH))        /* only death trigs are immune to all tests*/
    {
            if (!AWAKE((char_data *)go))
            {
                    depth --;
                    if (mode == TRIG_NEW)
                            GET_TRIG_DEPTH(trig) = 0;        /* reset trigger totally if instant bail*/
                    return 0;
            }

            if (CASTING((char_data *) go))
            {
                    pause_while_casting(go, trig, type,cl);
                    depth--;
                    return ret_val;
            }
    }
    for (p = cl->cmd; *p && isspace(*p); p++);

    if (*p == '*')
      continue;

    else if (!strn_cmp(p, "if ", 3)) {
      if (process_if(p + 3, go, sc, trig, type))
        GET_TRIG_DEPTH(trig)++;
      else
        cl = find_else_end(trig, cl, go, sc, type);
    }

    else if (!strn_cmp("elseif ", p, 7) ||
             !strn_cmp("else", p, 4)) {
      /* If not in an if-block, ignore the extra 'else[if]' and warn about it. */
      if (GET_TRIG_DEPTH(trig) == 1) {
        script_log(trig, "'else' without 'if'.");
        continue;
      }
      cl = find_end(trig, cl);
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("while ", p, 6)) {
      temp = find_done(cl);
      if (!temp) {
        script_log(trig, "'while' without 'done'.");
        return ret_val;
      }
      else if (process_if(p + 6, go, sc, trig, type)) {
        temp->original = cl;
      } else {
        cl = temp;
        loops = 0;
      }
    } else if (!strn_cmp("switch ", p, 7)) {
      cl = find_case(trig, cl, go, sc, type, p + 7);
    } else if (!strn_cmp("end", p, 3)) {
      if (GET_TRIG_DEPTH(trig) == 1) {
        script_log(trig, "'end' without 'if'.");
        continue;
      }
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("done", p, 4)) {
      /* if in a while loop, cl->original is non-NULL */
      if (cl->original) {
        char* orig_cmd = cl->original->cmd;
        while (*orig_cmd && isspace(*orig_cmd)) orig_cmd++;

        if (cl->original && process_if(orig_cmd + 6, go, sc, trig, type)) {
          cl = cl->original;
          temp = find_done(cl);
          loops++;
          GET_TRIG_LOOPS(trig)++;
          if (loops == 30) {
            process_wait(go, trig, type, "wait 1", cl);
            depth--;
            return ret_val;
          }
          if (GET_TRIG_LOOPS(trig) >= 100) {
            script_log(trig, "looped 100 times!!!");
            break;
          }
        }
      }
    } else if (!strn_cmp("break", p, 5)) {
      cl = find_done(cl);
    } else if (!strn_cmp("case", p, 4)) {
      /* Do nothing, this allows multiple cases to a single instance */
    }


    else {

      var_subst(go, sc, trig, type, p, cmd);

      if (!strn_cmp(cmd, "eval ", 5))
        process_eval(go, sc, trig, type, cmd);

      else if (!strn_cmp(cmd, "halt", 4))
        break;

      else if (!strn_cmp(cmd, "global ", 7))
        process_global(sc, trig, cmd);

      else if (!strn_cmp(cmd, "return ", 7))
        ret_val = process_return(trig, cmd);

      else if (!strn_cmp(cmd, "set ", 4))
        process_set(sc, trig, cmd);

      else if (!strn_cmp(cmd, "unset ", 6))
        process_unset(sc, trig, cmd);

      else if (!strn_cmp(cmd, "wait ", 5)) {
        process_wait(go, trig, type, cmd, cl);
        depth--;
        return ret_val;
      }

      else
        switch (type) {
        case MOB_TRIGGER:
          command_interpreter((char_data *) go, cmd);
          break;
        case OBJ_TRIGGER:
          obj_command_interpreter((obj_data *) go, trig, cmd);
          break;
        case WLD_TRIGGER:
          wld_command_interpreter((struct room_data *) go, trig, cmd);
          break;
        }
    }
  }
  trig->running = FALSE;

  if (trig->purged) {
    free_trigger(trig);
    go_address = NULL;
  }
  else
  {
    free_varlist(GET_TRIG_VARS(trig));
    GET_TRIG_VARS(trig) = NULL;
    GET_TRIG_DEPTH(trig) = 0;
  }

  depth--;
  return ret_val;
}

int real_trigger(int vnum)
{
  int rnum;

  for (rnum=0; rnum < top_of_trigt; rnum++)
    {
      if (trig_index[rnum]->virtual==vnum) break;
    }

  if (rnum==top_of_trigt) rnum = -1;
  return (rnum);
}

ACMD(do_tstat)
{
  int vnum, rnum;
  char str[MAX_INPUT_LENGTH];

  half_chop(argument, str, argument);
  if (*str) {
    vnum = atoi(str);
    rnum = real_trigger(vnum);
    if (rnum<0) {
      send_to_char("That vnum does not exist.\r\n", ch);
      return;
    }

    do_stat_trigger(ch, trig_index[rnum]->proto);
  } else send_to_char("Usage: tstat <vnum>\r\n", ch);
}

/*
 * scans for a case/default instance
 * returns the line containg the correct case instance, or the last
 * line of the trigger if not found.
 */
struct cmdlist_element *
find_case(struct trig_data *trig, struct cmdlist_element *cl,
          void *go, struct script_data *sc, int type, char *cond)
{
  char cond_expr[MAX_INPUT_LENGTH], *p;
  struct cmdlist_element *c;

  if (!(cl->next))
    return cl;

  eval_expr(cond, cond_expr, go, sc, trig, type);

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch", p, 6))
      c = find_done(c);
    else if (!strn_cmp("case ", p, 5)) {
      char case_expr[MAX_STRING_LENGTH];
      char result[16]; /* == always returns an integer, so it shouuld be safe */
      eval_expr(p + 5, case_expr, go, sc, trig, type);
      eval_op("==", cond_expr, case_expr, result, go, sc, trig);
      if (*result && *result != '0')
        return c;
    } else if (!strn_cmp("default", p, 7))
      return c;
    else if (!strn_cmp("done", p, 3))
      return c;
  }
  return c;
}

/*
 * scans for end of while/switch-blocks.
 * returns the line containg 'end', or the last
 * line of the trigger if not found.
 */
struct cmdlist_element *
find_done(struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;

  if (!cl || !(cl->next))
    return cl;

  for (c = cl->next; c && c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch ", p, 7))
      c = find_done(c);
    else if (!strn_cmp("done", p, 3))
      return c;
  }

  return c;
}


void check_time_triggers(void)
{
  char_data *ch;
  obj_data *obj;
  struct room_data *room=NULL;
  int nr;
  struct script_data *sc;

  for (ch = character_list; ch; ch = ch->next) {
    if (SCRIPT(ch)) {
      sc = SCRIPT(ch);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_TIME) &&
          (!is_empty(world[IN_ROOM(ch)].zone) ||
           IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
        time_mtrigger(ch);
    }
  }

  for (obj = object_list; obj; obj = obj->next) {
    if (SCRIPT(obj)) {
      sc = SCRIPT(obj);

      if (IS_SET(SCRIPT_TYPES(sc), OTRIG_TIME))
        time_otrigger(obj);
    }
  }

  for (nr = 0; nr <= top_of_world; nr++) {
    if (SCRIPT(&world[nr])) {
      room = &world[nr];
      sc = SCRIPT(room);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_TIME) &&
          (!is_empty(room->zone) ||
           IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
        time_wtrigger(room);
    }
  }
}

/***************************************************************************
 * $Log: dg_scripts.c,v $
 * Revision 1.130  2009/06/10 20:14:48  myc
 * Fix bug in group_members subvariable.
 *
 * Revision 1.129  2009/06/09 05:38:52  myc
 * Slight modification to find_replacement to accomodate the
 * new clan interface.
 *
 * Revision 1.128  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.127  2009/03/17 07:59:42  jps
 * Moved str_str to strings.c
 *
 * Revision 1.126  2009/03/09 21:43:50  myc
 * Use references to coin_names instead of string constants.
 *
 * Revision 1.125  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.124  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.123  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.122  2009/03/06 00:46:31  myc
 * Make MATCH_CHAR_FUNC(match_dg_vis_char_by_id) visible outside the
 * file since find_char_around_room needs to know its address.
 *
 * Revision 1.121  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.120  2009/01/17 00:28:02  myc
 * Fix possible use of uninitialized variable.
 *
 * Revision 1.119  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.118  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.117  2008/09/02 07:16:00  mud
 * Changing object TIMER uses into DECOMP where appropriate
 *
 * Revision 1.116  2008/08/26 03:58:13  jps
 * Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
 * Except the one for wzoneecho, since it needed to find a real zone by zone number.
 *
 * Revision 1.115  2008/08/24 02:34:14  myc
 * Make arguments and return values for str_str const.
 *
 * Revision 1.114  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.113  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.112  2008/06/20 20:21:44  jps
 * Made fullpurge into an event and moved it to events.c.
 *
 * Revision 1.111  2008/06/19 18:53:12  myc
 * Replaced the item_types array with a typedef struct array.
 *
 * Revision 1.110  2008/06/05 02:07:43  myc
 * Removed cost_per_day field from objects.  Changed object flags
 * to use flagvectors.
 *
 * Revision 1.109  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.108  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.107  2008/04/14 07:16:48  jps
 * Un-hardcode positions.
 *
 * Revision 1.106  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.105  2008/04/05 19:43:15  jps
 * Allow access to general variable %damdone%, which is the amount
 * of damage that a *damage command did to a character.
 *
 * Revision 1.104  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.103  2008/04/02 03:24:44  myc
 * Rewrote group code.
 *
 * Revision 1.102  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.101  2008/03/21 21:41:58  jps
 * Forgot some elses. I was confused by the code formatting.
 *
 * Revision 1.100  2008/03/21 21:36:31  jps
 * Add get.obj_noadesc[vnum] and get.obj_pldesc[vnum].
 *
 * Revision 1.99  2008/03/16 00:21:16  jps
 * Updated references to player trophies.
 *
 * Revision 1.98  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.97  2008/03/10 19:55:37  jps
 * Made a struct for sizes with name, height, and weight.  Save base height
 * weight and size so they stay the same over size changes.
 *
 * Revision 1.96  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.95  2008/03/05 03:03:54  myc
 * Redesigned the trophy structures, so had to update the trophy
 * DG variable to access it correctly.
 *
 * Revision 1.94  2008/02/16 20:26:04  myc
 * Use free_trigger instead of trig_data_free.
 *
 * Revision 1.93  2008/02/16 07:02:15  myc
 * Bug in is_num wasn't parsing negative numbers.
 *
 * Revision 1.92  2008/02/13 21:10:14  myc
 * Fix variable parsing in case statements.
 *
 * Revision 1.91  2008/02/11 08:50:33  jps
 * Make trigger lists given from 'stat' more succinct.
 *
 * Revision 1.90  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.
 *
 * Revision 1.89  2008/02/09 18:29:11  myc
 * The event code now handles freeing of event objects.
 *
 * Revision 1.88  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.87  2008/02/06 03:45:08  myc
 * Stat room and stat obj now use the pager.
 *
 * Revision 1.86  2008/02/04 00:22:05  myc
 * Making stat char use the pager.
 *
 * Revision 1.85  2008/02/02 19:56:51  myc
 * script_driver now requires an address
 *
 * Revision 1.84  2008/02/02 04:27:55  myc
 * Changing the way script_driver works: you now pass it a pointer
 * to the pointer of what you want to run the script.  That is,
 * script_driver(&ch, ...) instead of script_driver(ch, ...).
 * Adding time triggers (which execute at a given mud time each day).
 *
 * Revision 1.83  2008/02/01 06:44:29  myc
 * Oops, forgot a line in find_case.  Anyway, you'll now be able to use
 * expressions on switch lines.
 *
 * Revision 1.82  2008/02/01 06:32:23  myc
 * Various fixes to scripts: is_num won't think "------" is a number.
 * Find end reports an error if no end is found.  Other stuff...
 *
 * Revision 1.81  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.80  2008/01/29 16:51:12  myc
 * Moving skill names to the skilldef struct.
 *
 * Revision 1.79  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.78  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.77  2008/01/19 02:17:08  myc
 * Memory read bug in actor.wearing variable.
 *
 * Revision 1.76  2008/01/18 20:30:31  myc
 * Changing variable fields that return rooms to return vnums instead
 * references, like they used to be, because that's much easier to work
 * with in triggers.  You can still get a room reference at any time
 * by using the get.room function.
 *
 * Revision 1.75  2008/01/18 08:28:43  myc
 * Added room.people[vnum], room.objects[vnum], and object.contents[vnum]
 * variables.
 *
 * Revision 1.74  2008/01/18 07:11:55  myc
 * Adding a get.opposite_dir[] static variable.
 *
 * Revision 1.73  2008/01/17 19:23:07  myc
 * Added get_room_location which mimics get_room but returns the
 * rnum instead of the actual room.  Modified get_room to only
 * attempt to use a string if it starts with a digit; that way
 * we can chain get_room when looking for a target.
 *
 * Revision 1.72  2008/01/17 07:40:32  myc
 * Taking out the indentation in tstat so you can copy and paste it.
 *
 * Revision 1.71  2008/01/17 06:24:23  myc
 * Oops, wrote out the wrong object for wearing[].
 *
 * Revision 1.70  2008/01/17 06:19:47  myc
 * Adding worn[count] and wearing[vnum] fields to character variables.
 *
 * Revision 1.69  2008/01/17 04:19:07  myc
 * Fixing a bug with nested variables.
 *
 * Revision 1.68  2008/01/17 04:10:07  myc
 * Updating get_obj_by_obj() and get_char_room_mscript() to check
 * UIDs against the calling object and char (since find_replacement
 * now returns a UID for the object/char instead of "self" now).
 *
 * Revision 1.67  2008/01/17 02:44:16  myc
 * Rewrote var_subst.
 *
 * Revision 1.66  2008/01/17 01:51:40  myc
 * Was using the wrong variable (ch not c) in the %room.people[count]%
 * section of find_replacement.
 *
 * Revision 1.65  2008/01/17 01:29:10  myc
 * OMG rewrote find_replacement.  It now exposes like every char_data,
 * obj_data, and room_data field.  This calls for a giant rewrite for
 * most triggers, but it's worth it.  New stuff you can access includes:
 * trophy, effects, contents, room flags, and much more!  Also cleaned
 * up var_subst a bit too.
 *
 * Revision 1.64  2008/01/13 23:06:04  myc
 * Fixed a bug in process_global.
 *
 * Revision 1.63  2008/01/12 23:13:20  myc
 * Created a multi-purpose get_random_char_around() function to pick random
 * chars in a room.
 *
 * Revision 1.62  2008/01/09 02:30:56  jps
 * Use macro to get mob real number.
 *
 * Revision 1.61  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.60  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.59  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.58  2007/10/04 16:20:24  myc
 * Added %object.timer% variable.
 *
 * Revision 1.57  2007/09/20 23:19:00  myc
 * Fixing flags again.
 *
 * Revision 1.56  2007/09/20 23:12:29  myc
 * Wrong flags in %actor.flags%!
 *
 * Revision 1.55  2007/09/20 21:20:43  myc
 * The %actor.flags% variable now returns a sprintbit string of all
 * the flags the actor has, instead of checking bits using a [] thingy.
 *
 * Revision 1.54  2007/09/17 22:29:59  jps
 * Unbreak some triggers I broke by not checking the entire
 * world for object rnums in get_obj_by_room().
 *
 * Revision 1.53  2007/08/30 19:42:46  jps
 * Cause *purge dg script commands to destroy all of a mobile's inventory
 * and equipment when purging mobs.
 *
 * Revision 1.52  2007/08/30 09:10:44  jps
 * Change get_obj_by_room to only find objects in the requested room.
 *
 * Revision 1.51  2007/08/26 22:37:37  jps
 * %people.ROOM% back to the actual number of chars in there.
 * It was causing way too many problems the other way.
 *
 * Revision 1.50  2007/08/24 17:01:36  myc
 * Adding ostat and mstat commands as shorthand for vstat, rstat for stat
 * room, and mnum and onum for vnum.  Also adding rnum and znum with new
 * functionality.
 *
 * Revision 1.49  2007/08/24 10:24:04  jps
 * Moved zstat to act.wizard.c.
 *
 * Revision 1.48  2007/08/14 08:48:11  jps
 * Renamed dg_global_pulse to global_pulse since it will now be used for
 * other things in addition to dg scripting.
 *
 * Revision 1.47  2007/08/08 20:21:10  jps
 * Oops left an unused variable in do_tlist.
 *
 * Revision 1.46  2007/08/08 20:09:42  jps
 * tlist, mlist, olist, and rlist now accept a single parameter which they
 * take to be a zone whose objects should be listed.  If no parameter is
 * given, they will list objects in the current zone - where the character
 * issuing the command is located.
 *
 * Revision 1.45  2007/05/29 00:36:03  jps
 * Use the proper top of zone value when processing the command <tlist #>,
 * which shows a list of triggers in zone #.
 *
 * Revision 1.44  2007/05/29 00:04:19  jps
 * Escape commands in tstat so you can copy and paste the code.
 *
 * Revision 1.43  2007/05/11 19:34:15  myc
 * Modified the quest command functions so they are thin wrappers for
 * perform_quest() in quest.c.  Error handling and messages should be
 * much better now.  Advance and rewind now accept another argument
 * specifying how many stages to advance or rewind.
 *
 * Revision 1.42  2007/04/18 21:58:11  jps
 * The %people.roomvnum% variable now sees exactly the same characters
 * as %random.char% (in other words, not NOHASSLE or wizinvis'd folks).
 *
 * Revision 1.41  2007/04/17 23:53:23  myc
 * The 'global' trigger command now takes a list of local variables and
 * globalizes each one.
 *
 * Revision 1.40  2007/03/27 04:27:05  myc
 * New fields for character dg variables: position and position1.
 *
 * Revision 1.39  2006/12/08 05:09:32  myc
 * Added new fields to actor variables, and sector field to room vars.
 *
 * Revision 1.38  2006/11/13 03:17:06  jps
 * Fix memory leak in trig_wait_event.
 *
 * Revision 1.37  2006/11/07 10:44:13  jps
 * Trigger name, vnum, and rnum are displayed when using tstat.
 *
 * Revision 1.36  2004/11/01 06:02:01  jjl
 * Updating the buffer size for triggers
 *
 * Revision 1.35  2003/07/29 01:42:11  jjl
 * Fixing "while" in dg_scripts.  while only worked properly if it was the first thing on the
 * line.  (IE "while " works, but " while " wouldn't)
 *
 * Revision 1.34  2003/07/13 23:04:45  jjl
 * Fixed a crash bug in the processing of %actor.class% for mobs.
 *
 * Revision 1.33  2003/07/12 05:45:35  jjl
 * Better version of oshdesc, supports variable vnums.
 *
 * Revision 1.32  2003/07/10 03:56:57  jjl
 * Added the "oshdesc" variable for getting object short descriptions.
 * Call it as %oshdesc.vnum% (IE %oshdesc.3011%)
 *
 * Revision 1.31  2003/07/09 04:57:49  jjl
 * Increased an internal buffer that was being overflowed by Zzur's armor
 * quest.
 *
 * Revision 1.30  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.29  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.28  2002/05/08 00:30:06  dce
 * Fixed a stupid string error.
 *
 * Revision 1.27  2002/05/07 03:13:09  dce
 * Added a little error checking to the "exists" trigger
 * code to prevent crashes.
 * /s
 *
 * Revision 1.26  2002/05/06 23:54:04  dce
 * Added three new features: exists, mexists[#], oexists[#]. The show
 * the number currently in the game.
 * /s
 *
 * Revision 1.25  2001/08/03 21:25:00  mtp
 * reset trigger depth which is separate from script recursion depth, in the
 * case that a mob is asleep when a new trigger kicks off and we return
 * instantly
 *
 * Revision 1.24  2001/08/03 19:48:56  mtp
 * missing depth-- which meant that gradully triggers got into recursed error
 *
 * Revision 1.23  2001/07/25 06:59:02  mtp
 * modified logging to hopefully be a bit more helpful by specifying the
 * trigger id wherever possible. This does not apply to logging of mob trigs yet
 * as mobs use the same commands as players :-(
 *
 * Revision 1.22  2001/06/19 23:57:11  mtp
 * improved logging for trigger recursion
 *
 *
 * Revision 1.21  2001/02/12 01:26:52  mtp
 * added 2 fields, groupnum (members in group)
 * group[n] group member n
 *
 * Revision 1.20  2000/12/21 23:29:49  mtp
 * added strip_ansi to actor.class and also removed trailing WS o to allow ==
 * for class names
 *
 * Revision 1.19  2000/11/28 01:16:25  mtp
 * replaced dg_event code with events.c code
 *
 * Revision 1.17  2000/11/21 04:13:38  rsd
 * Altered the comment header and added old rlog messages
 * from prior to the $log$ string. Also the $log$ string
 * had been removed so the last 10 or so revisions weren't
 * commented in the file.  I added the string back in hopes
 * that it will continue to add the comments and included
 * the missing rlog messages.
 *
 * Revision 1.16  2000/11/09 23:59:54  mtp
 * added %actor.n% for he/she/it
 *
 * Revision 1.15  2000/11/07 01:53:34  mtp
 * added some extra fields to do with subclasses and also .o, .p for
 * him/her his/her stuff
 *
 * Revision 1.14  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.13  2000/10/30 18:32:35  mtp
 * fix for tlist
 *
 * Revision 1.12  2000/10/29 16:59:12  mtp
 * added puase_while_casting to halt (well pause cos it restarts)
 * trigger execution if mob is casting. This applies whether the cast is
 * within the trigger or external to the trigger
 *
 * Revision 1.11  2000/10/27 00:34:45  mtp
 * new fields in player structure for quest info
 *
 * Revision 1.10  2000/10/01 23:43:29  mtp
 * added extra trigger code
 * 1) can check players flags (flags 1,2,3) eg %plyr.flags[1,1]% returns true/false if player blind
 * 2) can get players in a room eg %self.people[3]% gets the third person in room
 * 3) extension to allow %self.people[%num%]% to get the %num%th person in room
 *
 * note: the people[] call returns a player variable, so all fields are available
 *
 * Revision 1.9  2000/03/04 00:22:16  mtp
 * added extra field for room object - vnum (will be mainly referenced by %self.vnum%)
 *
 * Revision 1.8  2000/02/17 07:32:27  mtp
 * added %time% structure to show mud time and object.weight field
 *
 * Revision 1.7  2000/02/16 08:13:14  mtp
 * fixed while loops (which couldhave been infinite and crashed after 30 loops anyhow)
 * while loops are now killed after 100 loops
 *
 * Revision 1.6  2000/02/13 07:34:13  mtp
 * fixed opurge/mpurge problems by not freeing the running trigger
 * until it completes (set/unset running flag in dg_scripts.c and
 * free trigger if purged flag set at end)
 *
 * Revision 1.5  2000/02/11 00:29:37  mtp
 * another world[vnum] replaced by world[real_room(vnum)] *sigh*
 *
 * Revision 1.4  2000/02/02 22:54:25  mtp
 * added new field to %actor% for %actor.worn[##]% which
 * returns the vnum of the object that is worn there or -1 if none
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 01:57:43  mud
 * Added info to the comment header
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:30 mud
 * Initial revision
 *
 ***************************************************************************/
@


1.130
log
@Fix bug in group_members subvariable.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.129 2009/06/09 05:38:52 myc Exp myc $
d8 2
a9 2
 *  $Date: 2009/06/09 05:38:52 $                                           *
 *  $Revision: 1.129 $                                                      *
d2274 1
a2274 1
  extern long global_pulse;
d2813 3
@


1.129
log
@Slight modification to find_replacement to accomodate the
new clan interface.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.128 2009/03/20 13:56:22 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/20 13:56:22 $                                           *
 *  $Revision: 1.128 $                                                      *
d1389 2
a1390 2
      if (IS_GROUPED(ch) || num <= 0)
        strcpy(str, "0");
d2813 4
@


1.128
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.127 2009/03/17 07:59:42 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/17 07:59:42 $                                           *
 *  $Revision: 1.127 $                                                      *
d1531 2
a1532 3
      if (!IS_NPC(c) && GET_CLAN(c) &&
          (num = find_clan_by_id(GET_CLAN(c))) >= 0)
        strcpy(str, clans[num].name);
a1535 2
    else if (!str_cmp(field, "clan_id"))
      sprintf(str, "%d", IS_NPC(c) ? 0 : GET_CLAN(c));
d2813 3
@


1.127
log
@Moved str_str to strings.c
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.126 2009/03/09 21:43:50 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2009/03/09 21:43:50 $                                           *
 *  $Revision: 1.126 $                                                      *
d1283 1
a1283 1
    else if (!str_cmp(field, coin_names[PLATINUM]) || !str_cmp(field, "plat"))
d1285 1
a1285 1
    else if (!str_cmp(field, coin_names[GOLD]))
d1287 1
a1287 1
    else if (!str_cmp(field, coin_names[SILVER]))
d1289 1
a1289 1
    else if (!str_cmp(field, coin_names[COPPER]))
d2816 3
@


1.126
log
@Use references to coin_names instead of string constants.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.125 2009/03/09 20:36:00 myc Exp myc $
d8 2
a9 2
 *  $Date: 2009/03/09 20:36:00 $                                           *
 *  $Revision: 1.125 $                                                      *
d46 1
a83 29
/* Return pointer to first occurrence in string ct in */
/* cs, or NULL if not present.  Case insensitive */
const char *str_str(const char *cs, const char *ct)
{
  const char *s, *t;

  if (!cs || !ct)
    return NULL;

  while (*cs) {
    t = ct;

    while (*cs && (LOWER(*cs) != LOWER(*t)))
      cs++;

    s = cs;

    while (*t && *cs && (LOWER(*cs) == LOWER(*t))) {
      t++;
      cs++;
    }

    if (!*t)
      return s;
  }

  return NULL;
}

d2816 3
@


1.125
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.124 2009/03/08 23:34:14 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/08 23:34:14 $                                           *
 *  $Revision: 1.124 $                                                      *
d1311 1
a1311 1
    else if (!str_cmp(field, "platinum") || !str_cmp(field, "plat"))
d1313 1
a1313 1
    else if (!str_cmp(field, "gold"))
d1315 1
a1315 1
    else if (!str_cmp(field, "silver"))
d1317 1
a1317 1
    else if (!str_cmp(field, "copper"))
d2844 3
@


1.124
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.123 2009/03/08 21:43:27 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/08 21:43:27 $                                           *
 *  $Revision: 1.123 $                                                      *
d1312 1
a1312 1
      sprintf(str, "%d", GET_PLAT(c));
d2844 3
@


1.123
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.122 2009/03/06 00:46:31 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2009/03/06 00:46:31 $                                           *
 *  $Revision: 1.122 $                                                      *
d40 1
a40 1
#include "spells.h"
d2844 3
@


1.122
log
@Make MATCH_CHAR_FUNC(match_dg_vis_char_by_id) visible outside the
file since find_char_around_room needs to know its address.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.121 2009/03/03 19:43:44 myc Exp myc $
d8 2
a9 2
 *  $Date: 2009/03/03 19:43:44 $                                           *
 *  $Revision: 1.121 $                                                      *
d45 1
d2844 4
@


1.121
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.120 2009/01/17 00:28:02 myc Exp myc $
d8 2
a9 2
 *  $Date: 2009/01/17 00:28:02 $                                           *
 *  $Revision: 1.120 $                                                      *
d223 1
a223 1
static MATCH_CHAR_FUNC(match_dg_vis_char_by_id)
d2843 3
@


1.120
log
@Fix possible use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.119 2008/09/22 02:09:17 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/09/22 02:09:17 $                                           *
 *  $Revision: 1.119 $                                                      *
a53 1
struct obj_data *get_object_in_equip(struct char_data * ch, char *name, int *i);
a146 59
obj_data *get_obj_in_list(char *name, obj_data *list)
{
  obj_data *i;
  long id;

  if (*name == UID_CHAR)
    {
      id = atoi(name + 1);

      for (i = list; i; i = i->next_content)
        if (id == GET_ID(i))
          return i;
    }
  else
    {
      for (i = list; i; i = i->next_content)
        if (isname(name, i->name))
          return i;
    }

  return NULL;
}

obj_data *get_object_in_equip(char_data * ch, char *name, int *i)
{
  int j, n = 0, number;
  obj_data *obj;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;
  long id;

  if (*name == UID_CHAR)
    {
      id = atoi(name + 1);

      for (j = 0; j < NUM_WEARS; j++)
        if ((obj = GET_EQ(ch, j)))
          if (id == GET_ID(obj)){
            (*i) = j;
            return (obj);
          }
    }
  else
    {
      strcpy(tmp, name);
      if (!(number = get_number(&tmp)))
        return NULL;

      for (j = 0; (j < NUM_WEARS) && (n <= number); j++)
        if ((obj = GET_EQ(ch, j)))
          if (isname(tmp, obj->name))
            if (++n == number) {
              (*i) = j;
              return (obj);
            }
    }

  return NULL;
}
a193 44
/* search the entire world for a char, and return a pointer */
char_data *get_char(char *name)
{
  char_data *i;

  if (*name == UID_CHAR) {
    i = find_char(atoi(name + 1));

    if (i && !GET_INVIS_LEV(i))
      return i;
  }
  else {
    for (i = character_list; i; i = i->next)
      if (isname(name, GET_NAMELIST(i)) && !GET_INVIS_LEV(i))
        return i;
  }

  return NULL;
}


/* returns the object in the world with name name, or NULL if not found */
obj_data *get_obj(char *name)
{
  obj_data *obj;
  long id;

  if (*name == UID_CHAR) {
    id = atoi(name + 1);

    for (obj = object_list; obj; obj = obj->next)
      if (id == GET_ID(obj))
        return obj;
  }
  else {
    for (obj = object_list; obj; obj = obj->next)
      if (isname(name, obj->name))
        return obj;
  }

  return NULL;
}


d223 1
a223 5
/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching with the person owing the object
 */
char_data *get_char_by_obj(obj_data *obj, char *name)
d225 1
a225 23
  char_data *ch;

  if (*name == UID_CHAR) {
    ch = find_char(atoi(name + 1));

    if (ch && !GET_INVIS_LEV(ch))
      return ch;
  }
  else {
    if (obj->carried_by && isname(name, GET_NAMELIST(obj->carried_by)) &&
        !GET_INVIS_LEV(obj->carried_by))
      return obj->carried_by;

    if (obj->worn_by && isname(name, GET_NAMELIST(obj->worn_by)) &&
        !GET_INVIS_LEV(obj->worn_by))
      return obj->worn_by;

    for (ch = character_list; ch; ch = ch->next)
      if (isname(name, GET_NAMELIST(ch)) && !GET_INVIS_LEV(ch))
        return ch;
  }

  return NULL;
d228 1
a228 6

/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching in room room first
 */
char_data *get_char_by_room(room_data *room, char *name)
d230 5
a234 19
  char_data *ch;

  if (*name == UID_CHAR) {
    ch = find_char(atoi(name + 1));

    if (ch && !GET_INVIS_LEV(ch))
      return ch;
  }
  else {
    for (ch = room->people; ch; ch = ch->next_in_room)
      if (isname(name, GET_NAMELIST(ch)) && !GET_INVIS_LEV(ch))
        return ch;

    for (ch = character_list; ch; ch = ch->next)
      if (isname(name, GET_NAMELIST(ch)) && !GET_INVIS_LEV(ch))
        return ch;
  }

  return NULL;
d238 7
a244 54
/*
 * returns the object in the world with name name, or NULL if not found
 * search based on obj
 */
obj_data *get_obj_by_obj(obj_data *obj, char *name)
{
  obj_data *i = NULL;
  int rm, wear;
  long id;

  if (!str_cmp(name, "self") || !str_cmp(name, "me"))
    return obj;

  if (*name == UID_CHAR && atoi(name + 1) == GET_ID(obj))
    return obj;

  if (obj->contains && (i = get_obj_in_list(name, obj->contains)))
    return i;

  if (obj->in_obj) {
    if (*name == UID_CHAR) {
      id = atoi(name + 1);
        
      if (id == GET_ID(obj->in_obj))
         return obj->in_obj;
    }
    else if (isname(name, obj->in_obj->name))
      return obj->in_obj;
  }

  else if (obj->worn_by && (i = get_object_in_equip(obj->worn_by, name, &wear)))
    return i;
  else if (obj->carried_by &&
           (i = get_obj_in_list(name, obj->carried_by->carrying)))
    return i;
  else if (((rm = obj_room(obj)) != NOWHERE) &&
           (i = get_obj_in_list(name, world[rm].contents)))
    return i;

  if (*name == UID_CHAR) {
    id = atoi(name + 1);

    for (i = object_list; i; i = i->next)
      if (id == GET_ID(i))
        break;
  }

  else {
    for (i = object_list; i; i = i->next)
      if (isname(name, i->name))
        break;
  }

  return i;
a247 44
/* returns obj with name */
obj_data *get_obj_by_room(room_data *room, char *name)
{
  obj_data *obj;
  long id;

  if (*name == UID_CHAR) {
    id = atoi(name + 1);

    for (obj = room->contents; obj; obj = obj->next_content)
      if (id == GET_ID(obj))
        return obj;

    /* Even though this function is called "get_obj_by_ROOM",
     * we may still be passed the ID of an object that is
     * NOT necessarily in the room, in a context in which it
     * MUST be identified.
     *
     * For example, in a room drop trigger, the built-in
     * variable "object" contains the dropped object's ID.
     * Whenever the script tries to resolve the this object's
     * sub-variables (e.g., %object.vnum%), it will be passed
     * here.  And, this can occur before the drop has completed,
     * and the object is still in the inventory of the
     * person performing the "drop" command.
     *
     * Therefore you need to check the entire world for the
     * object.  That's not a big problem though, because it's
     * still a VERY specific object, being identified by ID
     * and all.
     */
    for (obj = object_list; obj; obj = obj->next)
      if (id == GET_ID(obj))
        return obj;
  }
  else {
    for (obj = room->contents; obj; obj = obj->next_content)
      if (isname(name, obj->name))
        return obj;
  }

  return NULL;
}

d381 1
a381 1
  if ((ch = get_char(uid)))
d383 1
a383 1
  else if ((obj = get_obj(uid)))
d519 1
a519 1
    if ((victim = get_char_vis(ch, targ_name))) {
d542 1
a542 1
    if ((object = get_obj_vis(ch, targ_name))) {
a685 1
  int tmp;
d718 1
a718 1
      if (!(victim = get_char_vis(ch, arg2)))
d727 1
a727 1
      if (!(object = get_obj_vis(ch, arg2)))
d735 6
a740 6
      if ((object = get_object_in_equip_vis(ch, arg1, ch->equipment, &tmp)));
      else if ((object = get_obj_in_list_vis(ch, arg1, ch->carrying)));
      else if ((victim = get_char_room_vis(ch, arg1)));
      else if ((object = get_obj_in_list_vis(ch, arg1, world[IN_ROOM(ch)].contents)));
      else if ((victim = get_char_vis(ch, arg1)));
      else if ((object = get_obj_vis(ch, arg1)));
d974 6
a979 6
      if ((o = get_object_in_equip(ch, name, &num)));
      else if ((o = get_obj_in_list(name, ch->carrying)));
      else if ((c = get_char_room(name, IN_ROOM(ch))));
      else if ((o = get_obj_in_list(name, world[IN_ROOM(ch)].contents)));
      else if ((c = get_char(name)));
      else if ((o = get_obj(name)));
d983 2
a984 2
      if ((c = get_char_by_obj(obj, name)));
      else if ((o = get_obj_by_obj(obj, name)));
d988 2
a989 2
      if ((c = get_char_by_room(room, name)));
      else if ((o = get_obj_by_room(room, name)));
d2843 3
@


1.119
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.118 2008/09/09 08:23:37 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/09/09 08:23:37 $                                           *
 *  $Revision: 1.118 $                                                      *
d1175 4
d3084 4
@


1.118
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.117 2008/09/02 07:16:00 mud Exp jps $
d7 3
a9 3
 *  $Author: mud $                                                         *
 *  $Date: 2008/09/02 07:16:00 $                                           *
 *  $Revision: 1.117 $                                                      *
d1860 1
a1860 1
      sprintf(str, "%d", o->obj_flags.weight);
d3080 3
@


1.117
log
@Changing object TIMER uses into DECOMP where appropriate
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.116 2008/08/26 03:58:13 jps Exp mud $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/08/26 03:58:13 $                                           *
 *  $Revision: 1.116 $                                                      *
d1979 1
a1979 1
      sprinttype(r->sector_type, sector_types, str);
d3080 3
@


1.116
log
@Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
Except the one for wzoneecho, since it needed to find a real zone by zone number.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.115 2008/08/24 02:34:14 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/08/24 02:34:14 $                                           *
 *  $Revision: 1.115 $                                                      *
d1877 2
d3080 4
@


1.115
log
@Make arguments and return values for str_str const.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.114 2008/08/15 03:59:08 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/08/15 03:59:08 $                                           *
 *  $Revision: 1.114 $                                                      *
a61 1
int find_real_zone_by_room(room_num vznum);
d112 36
d3078 3
@


1.114
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.113 2008/08/14 09:45:22 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/08/14 09:45:22 $                                           *
 *  $Revision: 1.113 $                                                      *
d86 1
a86 1
char *str_str(char *cs, char *ct)
d88 1
a88 1
  char *s, *t;
d3043 3
@


1.113
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.112 2008/06/20 20:21:44 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/06/20 20:21:44 $                                           *
 *  $Revision: 1.112 $                                                      *
d576 1
a576 1
  page_string(ch->desc, sb);
d3043 3
@


1.112
log
@Made fullpurge into an event and moved it to events.c.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.111 2008/06/19 18:53:12 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/06/19 18:53:12 $                                           *
 *  $Revision: 1.111 $                                                      *
d44 1
d576 1
a576 1
  page_string(ch->desc, sb, 1);
d3043 3
@


1.111
log
@Replaced the item_types array with a typedef struct array.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.110 2008/06/05 02:07:43 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/06/05 02:07:43 $                                           *
 *  $Revision: 1.110 $                                                      *
a2997 8
void fullpurge_char(struct char_data *ch)
{
   void purge_objs(struct char_data *ch);

   purge_objs(ch);
   extract_char(ch);
}

d3042 3
@


1.110
log
@Removed cost_per_day field from objects.  Changed object flags
to use flagvectors.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.109 2008/05/18 05:18:06 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/05/18 05:18:06 $                                           *
 *  $Revision: 1.109 $                                                      *
d1818 1
a1818 1
      sprinttype(GET_OBJ_TYPE(o), item_types, str);
d3050 4
@


1.109
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.108 2008/05/17 04:32:25 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/17 04:32:25 $                                           *
 *  $Revision: 1.108 $                                                      *
d1828 1
a1828 1
      sprintf(str, "%d", GET_OBJ_RENT(o));
d1847 2
a1848 2
        sprintf(str, "%+d %s", o->effects[num].modifier,
                apply_types[(int) o->effects[num].location]);
d1854 1
a1854 1
              o->effects[num].modifier : 0);
d1858 1
a1858 1
      sprintbit(GET_OBJ_EXTRA(o), extra_bits, str);
d1861 1
a1861 1
        strcpy(str, IS_OBJ_STAT(o, (1 << num)) ? "1" : "0");
d3050 4
@


1.108
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.107 2008/04/14 07:16:48 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/14 07:16:48 $                                           *
 *  $Revision: 1.107 $                                                      *
d780 1
a780 1
                  tn, GET_TRIG_NAME(trig), world[room].number);
d1153 1
a1153 1
        case WLD_TRIGGER: ROOM_UID_VAR(str, real_room(room->number)); break;
d1258 1
a1258 1
        sprintf(str, "%d", world[num].number);
d1272 1
a1272 1
          sprintf(str, "%d", world[num].number);
d1745 1
a1745 1
        sprintf(str, "%d", world[IN_ROOM(c)].number);
d1887 1
a1887 1
        sprintf(str, "%d", world[num].number);
d1939 1
a1939 1
      sprintf(str, "%d", r->number);
d2023 1
a2023 1
                world[r->exits[num]->to_room].number : -1);
d2722 1
a2722 1
            ((struct room_data *) go)->number);
d3050 3
@


1.107
log
@Un-hardcode positions.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.106 2008/04/07 03:02:54 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/07 03:02:54 $                                           *
 *  $Revision: 1.106 $                                                      *
d43 1
d2019 1
a2019 1
      if (!r->dir_option[num])
d2022 2
a2023 2
        sprintf(str, "%d", r->dir_option[num]->to_room != NOWHERE ?
                world[r->dir_option[num]->to_room].number : -1);
d2025 2
a2026 2
        if (r->dir_option[num]->to_room != NOWHERE)
          ROOM_UID_VAR(str, r->dir_option[num]->to_room);
d2031 1
a2031 1
        sprintf(str, "%d", r->dir_option[num]->key);
d2033 1
a2033 1
        sprintbit(r->dir_option[num]->exit_info, exit_bits, str);
d3050 3
@


1.106
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.105 2008/04/05 19:43:15 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 19:43:15 $                                           *
 *  $Revision: 1.105 $                                                      *
d1737 1
a1737 8
      switch(GET_POS(c)) {
        case POS_STANDING: strcpy(str, "Standing"); break;
        case POS_KNEELING: strcpy(str, "Kneeling"); break;
        case POS_SITTING:  strcpy(str, "Sitting");  break;
        case POS_PRONE:    strcpy(str, "Prone");    break;
        case POS_FLYING:   strcpy(str, "Flying");    break;
        default:           strcpy(str, "Invalid");  break;
      }
d3049 4
@


1.105
log
@Allow access to general variable %damdone%, which is the amount
of damage that a *damage command did to a character.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.104 2008/04/03 02:02:05 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/04/03 02:02:05 $                                           *
 *  $Revision: 1.104 $                                                      *
d1736 8
a1743 8
    else if (!str_cmp(field, "stance")) {
      switch(GET_STANCE(c)) {
        case STANCE_STANDING: strcpy(str, "Standing"); break;
        case STANCE_KNEELING: strcpy(str, "Kneeling"); break;
        case STANCE_SITTING:  strcpy(str, "Sitting");  break;
        case STANCE_RESTING:  strcpy(str, "Resting");  break;
        case STANCE_PRONE:    strcpy(str, "Prone");    break;
        default:              strcpy(str, "Invalid");  break;
d1746 2
a1747 2
    else if (!str_cmp(field, "position"))
      strcpy(str, position_types[(int) GET_POS(c)]);
d3056 4
@


1.104
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.103 2008/04/02 03:24:44 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/04/02 03:24:44 $                                           *
 *  $Revision: 1.103 $                                                      *
d55 1
a55 1
		    trig_data *trig, int type);
d70 1
a70 1
	       int type, char *line, char *buf);
d121 2
a122 2
	if (id == GET_ID(i))
	  return i;
d127 2
a128 2
	if (isname(name, i->name))
	  return i;
d147 5
a151 5
	if ((obj = GET_EQ(ch, j)))
	  if (id == GET_ID(obj)){
	    (*i) = j;
	    return (obj);
	  }
d157 1
a157 1
	return NULL;
d160 6
a165 6
	if ((obj = GET_EQ(ch, j)))
	  if (isname(tmp, obj->name))
	    if (++n == number) {
	      (*i) = j;
	      return (obj);
	    }
d372 1
a372 1
	
d383 1
a383 1
	   (i = get_obj_in_list(name, obj->carried_by->carrying)))
d386 1
a386 1
	   (i = get_obj_in_list(name, world[rm].contents)))
d465 3
a467 3
	  (!is_empty(world[IN_ROOM(ch)].zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_mtrigger(ch);
d476 1
a476 1
	random_otrigger(obj);
d486 3
a488 3
	  (!is_empty(room->zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_wtrigger(room);
d543 3
a545 3
	  yel, GET_TRIG_NAME(trig), nrm,
	  grn, GET_TRIG_VNUM(trig), nrm,
	  GET_TRIG_RNUM(trig));
d626 5
a630 5
	if (*(tv->value) == UID_CHAR) {
	  find_uid_name(tv->value, name);
	  buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
	} else
	  buf += sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
d724 14
a737 14
	
	/* have a valid mob, now get trigger */
	rn = real_trigger(tn);
	if ((rn >= 0) && (trig = read_trigger(rn))) {
	
	  if (!SCRIPT(victim))
	    CREATE(SCRIPT(victim), struct script_data, 1);
	  add_trigger(SCRIPT(victim), trig, loc);
	
	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig), GET_SHORT(victim));
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
d739 1
a739 1
	send_to_char("Players can't have scripts.\r\n", ch);
d750 10
a759 10
	
	if (!SCRIPT(object))
	  CREATE(SCRIPT(object), struct script_data, 1);
	add_trigger(SCRIPT(object), trig, loc);
	
	sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		tn, GET_TRIG_NAME(trig),
		(object->short_description ?
		 object->short_description : object->name));
	send_to_char(buf, ch);
d761 1
a761 1
	send_to_char("That trigger does not exist.\r\n", ch);
d769 14
a782 14
	
	/* have a valid room, now get trigger */
	rn = trig_index[tn] ? tn : -1;
	if ((rn >= 0) && (trig = read_trigger(rn))) {
	
	  if (!(world[room].script))
	    CREATE(world[room].script, struct script_data, 1);
	  add_trigger(world[room].script, trig, loc);
	
	  sprintf(buf, "Trigger %d (%s) attached to room %d.\r\n",
		  tn, GET_TRIG_NAME(trig), world[room].number);
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
d1085 1
a1085 1
		      int type, char *var, char *field, char *value, char *str)
d1115 1
a1115 1
	break;
d1149 1
a1149 1
	switch (type) {
d1155 5
d1161 1
a1161 1
	*str = '\0';
d2074 1
a2074 1
	       int type, char *line, char *buf)
d2169 1
a2169 1
	     struct script_data *sc, trig_data *trig)
d2307 1
a2307 1
	       trig_data *trig, int type)
d2333 1
a2333 1
		    trig_data *trig, int type)
d2383 8
a2390 8
	*tokens[j] = '\0';
	p = tokens[j] + strlen(ops[i]);
	
	eval_expr(line, lhr, go, sc, trig, type);
	eval_expr(p, rhr, go, sc, trig, type);
	eval_op(ops[i], lhr, rhr, result, go, sc, trig);
	
	return 1;
d2400 1
a2400 1
	       trig_data *trig, int type)
d2455 2
a2456 2
				      struct cmdlist_element *cl, void *go,
				      struct script_data *sc, int type)
d2472 2
a2473 2
	GET_TRIG_DEPTH(trig)++;
	return c;
d2502 1
a2502 1
		  struct cmdlist_element *cl)
d2545 1
a2545 1
	time *= PULSES_PER_MUD_HOUR;
d2547 1
a2547 1
	time *= PASSES_PER_SEC;
d2583 1
a2583 1
		  int type, char *cmd)
d2764 1
a2764 1
    if (type == MOB_TRIGGER && !(trig->trigger_type & MTRIG_DEATH))	/* only death trigs are immune to all tests*/
d2766 7
a2772 7
	    if (!AWAKE((char_data *)go))
	    {
		    depth --;
		    if (mode == TRIG_NEW)
			    GET_TRIG_DEPTH(trig) = 0;	/* reset trigger totally if instant bail*/
		    return 0;
	    }
d2774 2
a2775 2
	    if (CASTING((char_data *) go))
	    {
d2777 3
a2779 3
		    depth--;
		    return ret_val;
	    }
d2788 1
a2788 1
	GET_TRIG_DEPTH(trig)++;
d2790 1
a2790 1
	cl = find_else_end(trig, cl, go, sc, type);
d2794 1
a2794 1
	     !strn_cmp("else", p, 4)) {
d2809 1
a2809 1
	temp->original = cl;
d2811 2
a2812 2
	cl = temp;
	loops = 0;
d2825 2
a2826 2
	char* orig_cmd = cl->original->cmd;
	while (*orig_cmd && isspace(*orig_cmd)) orig_cmd++;
d2828 11
a2838 11
	if (cl->original && process_if(orig_cmd + 6, go, sc, trig, type)) {
	  cl = cl->original;
	  temp = find_done(cl);
	  loops++;
	  GET_TRIG_LOOPS(trig)++;
	  if (loops == 30) {
	    process_wait(go, trig, type, "wait 1", cl);
	    depth--;
	    return ret_val;
	  }
	  if (GET_TRIG_LOOPS(trig) >= 100) {
d2841 2
a2842 2
	  }
	}
d2856 1
a2856 1
	process_eval(go, sc, trig, type, cmd);
d2859 1
a2859 1
	break;
d2862 1
a2862 1
	process_global(sc, trig, cmd);
d2865 1
a2865 1
	ret_val = process_return(trig, cmd);
d2868 1
a2868 1
	process_set(sc, trig, cmd);
d2871 1
a2871 1
	process_unset(sc, trig, cmd);
d2874 3
a2876 3
	process_wait(go, trig, type, cmd, cl);
	depth--;
	return ret_val;
d2880 11
a2890 11
	switch (type) {
	case MOB_TRIGGER:
	  command_interpreter((char_data *) go, cmd);
	  break;
	case OBJ_TRIGGER:
	  obj_command_interpreter((obj_data *) go, trig, cmd);
	  break;
	case WLD_TRIGGER:
	  wld_command_interpreter((struct room_data *) go, trig, cmd);
	  break;
	}
d3056 3
@


1.103
log
@Rewrote group code.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.102 2008/03/28 17:54:53 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/03/28 17:54:53 $                                           *
 *  $Revision: 1.102 $                                                      *
d540 2
d543 2
a544 2
	  CCYEL(ch, C_NRM), GET_TRIG_NAME(trig), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_TRIG_VNUM(trig), CCNRM(ch, C_NRM),
d3051 3
@


1.102
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.101 2008/03/21 21:41:58 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/03/21 21:41:58 $                                           *
 *  $Revision: 1.101 $                                                      *
d1605 1
a1605 1
      ch = c->groupmaster ? c->groupmaster : c;
d1609 1
a1609 1
      if (!EFF_FLAGGED(c, EFF_GROUP) || num <= 0)
d3049 4
@


1.101
log
@Forgot some elses. I was confused by the code formatting.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.100 2008/03/21 21:36:31 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/21 21:36:31 $                                           *
 *  $Revision: 1.100 $                                                      *
d1070 3
a1072 1
  } while (ROOM_FLAGGED(to_room, ROOM_PRIVATE | ROOM_DEATH | ROOM_GODROOM));
d1247 3
a1249 1
        } while (ROOM_FLAGGED(num, ROOM_PRIVATE | ROOM_DEATH | ROOM_GODROOM));
d1515 8
a1522 5
      if (IS_NPC(c)) { /* ACT flags */
        if (MOB_FLAGS(c) || !MOB2_FLAGS(c))
          sprintbit(MOB_FLAGS(c), action_bits, str);
        if (MOB2_FLAGS(c))
          sprintbit(MOB2_FLAGS(c), action_bits2, str + strlen(str));
a1523 9
      else { /* concatenation of PLR and PRF flags */
        if (PLR_FLAGS(c) || !PRF_FLAGS(c))
          sprintbit(PLR_FLAGS(c), player_bits, str);
        if (PRF_FLAGS(c))
          sprintbit(PRF_FLAGS(c), preference_bits, str + strlen(str));
      }
      /* Cut off the space at the end. */
      if (str)
        *(str + strlen(str) - 1) = '\0';
d1528 1
a1528 3
          strcpy(str, MOB_FLAGGED(c, (1 << num)) ? "1" : "0");
        else if ((num = search_block(value, action_bits2, FALSE)) >= 0)
          strcpy(str, MOB2_FLAGGED(c, (1 << num)) ? "1" : "0");
d1549 6
a1554 19
    else if (!str_cmp(field, "aff_flags")) {
      *str = '\0';
      if (AFF_FLAGS(c) || !(AFF2_FLAGS(c) || AFF3_FLAGS(c)))
        sprintbit(AFF_FLAGS(c), affected_bits, str);
      if (AFF2_FLAGS(c))
        sprintbit(AFF2_FLAGS(c), affected_bits2, str + strlen(str));
      if (AFF3_FLAGS(c))
        sprintbit(AFF3_FLAGS(c), affected_bits3, str + strlen(str));
      /* Cut off the space on the end. */
      if (str)
        *(str + strlen(str) - 1) = '\0';
    }
    else if (!str_cmp(field, "aff_flagged")) {
      if ((num = search_block(value, affected_bits, FALSE)) >= 0)
        strcpy(str, AFF_FLAGGED(c, (1 << num)) ? "1" : "0");
      else if ((num = search_block(value, affected_bits2, FALSE)) >= 0)
        strcpy(str, AFF2_FLAGGED(c, (1 << num)) ? "1" : "0");
      else if ((num = search_block(value, affected_bits3, FALSE)) >= 0)
        strcpy(str, AFF3_FLAGGED(c, (1 << num)) ? "1" : "0");
d1557 1
a1557 1
        sprintf(buf2, "unrecognized affection flag '%s' to %%%s.aff_flagged[]%%",
d1564 1
a1564 1
      struct affected_type *aff;
d1566 3
a1568 3
      for (aff = c->affected; aff; aff = aff->next)
        if (aff->duration >= 0 && (!aff->next || aff->next->type != aff->type)) {
          strcat(str, skills[aff->type].name);
d1609 1
a1609 1
      if (!AFF_FLAGGED(c, AFF_GROUP) || num <= 0)
a1793 3
        /* Cut off the trailing space. */
        else if (num < 0)
          *(str + strlen(str) - 1) = '\0';
d1846 2
a1847 2
        sprintf(str, "%+d %s", o->affected[num].modifier,
                apply_types[(int) o->affected[num].location]);
d1853 1
a1853 1
              o->affected[num].modifier : 0);
d1868 3
a1870 12
    else if (!str_cmp(field, "spells")) {
      *str = '\0';
      if (GET_OBJ_SPELL(o) || !(GET_OBJ_SPELL2(o) || GET_OBJ_SPELL3(o)))
        sprintbit(GET_OBJ_SPELL(o), affected_bits, str);
      if (GET_OBJ_SPELL2(o))
        sprintbit(GET_OBJ_SPELL2(o), affected_bits2, str + strlen(str));
      if (GET_OBJ_SPELL3(o))
        sprintbit(GET_OBJ_SPELL3(o), affected_bits3, str + strlen(str));
      /* Cut off the space on the end. */
      if (str)
        *(str + strlen(str) - 1) = '\0';
    }
d1872 2
a1873 6
      if ((num = search_block(value, affected_bits, FALSE)) >= 0)
        strcpy(str, IS_OBJ_SPELL_AFF(o, (1 << num)) ? "1" : "0");
      else if ((num = search_block(value, affected_bits2, FALSE)) >= 0)
        strcpy(str, IS_OBJ_SPELL_AFF2(o, (1 << num)) ? "1" : "0");
      else if ((num = search_block(value, affected_bits3, FALSE)) >= 0)
        strcpy(str, IS_OBJ_SPELL_AFF3(o, (1 << num)) ? "1" : "0");
d1876 1
a1876 1
        sprintf(buf2, "unrecognized affection flag '%s' to %%%s.has_spell[]%%",
d1945 1
a1945 1
      sprintbit(r->room_flags, room_bits, str);
d1948 1
a1948 1
        strcpy(str, IS_SET(r->room_flags, (1 << num)) ? "1" : "0");
d1957 1
a1957 1
      sprintbit(r->room_affections, room_affections, str);
d1959 2
a1960 2
      if ((num = search_block(value, room_affections, FALSE)) >= 0)
        strcpy(str, IS_SET(r->room_affections, (1 << num)) ? "1" : "0");
d1963 1
a1963 1
        sprintf(buf2, "unrecognized room affection flag '%s' to %%%s.flagged%%",
d3049 3
@


1.100
log
@Add get.obj_noadesc[vnum] and get.obj_pldesc[vnum].
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.99 2008/03/16 00:21:16 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/16 00:21:16 $                                           *
 *  $Revision: 1.99 $                                                      *
a1278 1
      }
d1280 1
a1280 1
      if (!str_cmp(field, "obj_noadesc")) {
a1286 1
      }
d1288 1
a1288 1
      if (!str_cmp(field, "obj_pldesc")) {
a1294 1
      }
d1297 1
a1297 1
      else if (!str_cmp(field, "mob_shortdesc")) {
a1302 1
      }
d1305 1
a1305 1
      else if (!str_cmp(field, "obj_count")) {
a1309 1
      }
d1311 1
a1311 1
      else if (!str_cmp(field, "mob_count")) {
a1315 1
      }
d1317 1
a1317 1
      else if (!str_cmp(field, "room")) {
a1321 1
      }
d1323 1
a1323 1
      else if (!str_cmp(field, "people")) {
d1336 1
a1336 3
      }

      else if (!str_cmp(field, "opposite_dir")) {
d1348 1
a1348 3
      }

      else if (!str_cmp(field, "uidchar"))
d3082 3
@


1.99
log
@Updated references to player trophies.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.98 2008/03/10 20:46:55 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/03/10 20:46:55 $                                           *
 *  $Revision: 1.98 $                                                      *
d1281 18
d3093 3
@


1.98
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.97 2008/03/10 19:55:37 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/03/10 19:55:37 $                                           *
 *  $Revision: 1.97 $                                                      *
d42 1
d1786 1
a1786 1
        struct trophy_data *node;
d1789 1
a1789 1
        for (node = GET_TROPHY(c).oldest; node; node = node->next) {
d3075 3
@


1.97
log
@Made a struct for sizes with name, height, and weight.  Save base height
weight and size so they stay the same over size changes.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.96 2008/03/09 06:38:37 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/09 06:38:37 $                                           *
 *  $Revision: 1.96 $                                                      *
d1738 8
a1745 8
    else if (!str_cmp(field, "position1")) {
      switch(GET_POS1(c)) {
        case POS1_STANDING: strcpy(str, "Standing"); break;
        case POS1_KNEELING: strcpy(str, "Kneeling"); break;
        case POS1_SITTING:  strcpy(str, "Sitting");  break;
        case POS1_RESTING:  strcpy(str, "Resting");  break;
        case POS1_PRONE:    strcpy(str, "Prone");    break;
        default:            strcpy(str, "Invalid");  break;
d3074 4
@


1.96
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.95 2008/03/05 03:03:54 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/03/05 03:03:54 $                                           *
 *  $Revision: 1.95 $                                                      *
d1440 1
a1440 1
      sprinttype(GET_SIZE(c) + 1, sizes, str);
d3074 5
@


1.95
log
@Redesigned the trophy structures, so had to update the trophy
DG variable to access it correctly.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.94 2008/02/16 20:26:04 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/16 20:26:04 $                                           *
 *  $Revision: 1.94 $                                                      *
d229 1
a229 1
      if (isname(name, i->player.name) && !GET_INVIS_LEV(i))
d304 1
a304 1
    if (obj->carried_by && isname(name, obj->carried_by->player.name) &&
d308 1
a308 1
    if (obj->worn_by && isname(name, obj->worn_by->player.name) &&
d313 1
a313 1
      if (isname(name, ch->player.name) && !GET_INVIS_LEV(ch))
d337 1
a337 1
      if (isname(name, ch->player.name) && !GET_INVIS_LEV(ch))
d341 1
a341 1
      if (isname(name, ch->player.name) && !GET_INVIS_LEV(ch))
d582 1
a582 1
    strcpy(name, ch->player.name);
d3074 4
@


1.94
log
@Use free_trigger instead of trig_data_free.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.93 2008/02/16 07:02:15 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/16 07:02:15 $                                           *
 *  $Revision: 1.93 $                                                      *
d1785 2
a1786 2
        int v = value && *value ? atoi(value) : -1,
            j = GET_TRTOP(c) ? GET_TRTOP(c) - 1 : USE_TROPHY;
d1788 9
a1796 4
        for (num = 0; num < USE_TROPHY; ++num, --j) {
          if (GET_TROPHY(c, j).value == 0) {
            if (v >= 0)
              strcpy(str, "0");
a1798 14
          if (v >= 0) {
            if (GET_TROPHY(c, j).virtual == v) {
              sprintf(str, "%d", (int) GET_TROPHY(c, j).value);
              break;
            }
          }
          else if (v == -1) {
            if (GET_TROPHY(c, j).virtual > 0)
              sprintf(str + strlen(str), "%d ", GET_TROPHY(c, j).virtual);
            else
              /* skip player races */;
          }
          if (j <= 0)
            j = USE_TROPHY + 1;
d1800 3
d1804 1
a1804 1
        if (*str && v == -1)
d3074 3
@


1.93
log
@Bug in is_num wasn't parsing negative numbers.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.92 2008/02/13 21:10:14 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/13 21:10:14 $                                           *
 *  $Revision: 1.92 $                                                      *
a45 1
void trig_data_free(trig_data *this);
a46 1
void free_varlist(struct trig_var_data *vd);
d2920 1
a2920 1
    trig_data_free(trig);
d3080 3
@


1.92
log
@Fix variable parsing in case statements.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.91 2008/02/11 08:50:33 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/02/11 08:50:33 $                                           *
 *  $Revision: 1.91 $                                                      *
d2182 1
a2182 1
  if (*num == '+' || *num == '=')
d3082 3
@


1.91
log
@Make trigger lists given from 'stat' more succinct.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.90 2008/02/09 21:07:50 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/02/09 21:07:50 $                                           *
 *  $Revision: 1.90 $                                                      *
d2976 1
a2976 1
  char result[MAX_INPUT_LENGTH], *p;
d2982 1
a2982 1
  eval_expr(cond, result, go, sc, trig, type);
d2990 5
a2994 3
      char buf[MAX_STRING_LENGTH];
      eval_op("==", result, p + 5, buf, go, sc, trig);
      if (*buf && *buf != '0')
d3082 3
@


1.90
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.89 2008/02/09 18:29:11 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/09 18:29:11 $                                           *
 *  $Revision: 1.89 $                                                      *
d41 1
d88 1
a88 1
  
d91 1
a91 1
  
d94 1
a94 1
    
d97 1
a97 1
    
d99 1
a99 1
    
d104 1
a104 1
    
d108 1
a108 1
  
d116 1
a116 1
  
d120 1
a120 1
      
d131 1
a131 1
  
d140 1
a140 1
  char *tmp = tmpname; 
d142 1
a142 1
  
d146 1
a146 1
      
d159 1
a159 1
      
d168 1
a168 1
  
d175 1
a175 1
 
d180 1
a180 1
  
d184 1
a184 1
  
d193 1
a193 1
  
d197 1
a197 1
  
d205 1
a205 1
  
d208 1
a208 1
  
d222 1
a222 1
  
d225 1
a225 1
      
d234 1
a234 1
  
d240 1
a240 1
obj_data *get_obj(char *name)  
d244 1
a244 1
  
d247 1
a247 1
      
d257 1
a257 1
  
d265 2
a266 2
  int nr; 
  
d298 1
a298 1
  
d301 1
a301 1
      
d309 1
a309 1
      
d313 1
a313 1
      
d318 1
a318 1
  
d328 1
a328 1
{    
d330 1
a330 1
  
d333 1
a333 1
      
d341 1
a341 1
      
d346 1
a346 1
  
d354 1
a354 1
 */  
d357 1
a357 1
  obj_data *i = NULL;  
d360 1
a360 1
  
d366 1
a366 1
  
d369 1
a369 1
  
d373 1
a373 1
	  
d380 1
a380 1
  
d389 1
a389 1
  
d392 1
a392 1
      
d397 1
a397 1
  
d403 1
a403 1
  
d405 1
a405 1
}   
d413 1
a413 1
  
d416 1
a416 1
      
d418 1
a418 1
      if (id == GET_ID(obj)) 
d447 1
a447 1
  }           
d464 1
a464 1
      
d471 1
a471 1
  
d475 1
a475 1
      
d480 1
a480 1
  
d485 1
a485 1
      
d507 1
a507 1
  
d517 2
a518 2
  
  
d523 1
a523 1
  
d534 1
a534 1
  
d540 1
a540 1
  
d546 1
a546 1
  
d557 1
a557 1
  
d582 1
a582 1
  
d598 5
a602 1
  
d605 1
a605 1
  
d610 1
a610 1
    } else 
d613 1
a613 1
  
d615 1
a615 20
    buf += sprintf(buf, "\r\n  Trigger: %s%s%s, VNum: [%s%5d%s], RNum: [%5d]\r\n",
	    CCYEL(ch, C_NRM), GET_TRIG_NAME(t), CCNRM(ch, C_NRM),
	    CCGRN(ch, C_NRM), GET_TRIG_VNUM(t), CCNRM(ch, C_NRM),
	    GET_TRIG_RNUM(t));
    
    if (t->attach_type==OBJ_TRIGGER) {
      buf += sprintf(buf, "  Trigger Intended Assignment: Objects\r\n");
      sprintbit(GET_TRIG_TYPE(t), otrig_types, name);
    } else if (t->attach_type==WLD_TRIGGER) {
      buf += sprintf(buf, "  Trigger Intended Assignment: Rooms\r\n");
      sprintbit(GET_TRIG_TYPE(t), wtrig_types, name);
    } else {
      buf += sprintf(buf, "  Trigger Intended Assignment: Mobiles\r\n");
      sprintbit(GET_TRIG_TYPE(t), trig_types, name);
    }
    
    buf += sprintf(buf, "  Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n", 
	    name, GET_TRIG_NARG(t), 
	    ((GET_TRIG_ARG(t) && *GET_TRIG_ARG(t)) ? GET_TRIG_ARG(t) :
	     "None"));
d628 1
a628 1
	} else 
d633 1
a633 1
  }  
d654 1
a654 1
  
d666 1
a666 1
  
d679 1
a679 1
  
d681 1
a681 1
  
d691 1
a691 1
  
d693 1
a693 1
  
d699 1
a699 1
ACMD(do_attach) 
d707 2
a708 2
  
  
d711 1
a711 1
  
d716 1
a716 1
  
d719 1
a719 1
  
d727 1
a727 1
	  
d731 1
a731 1
	  
d742 1
a742 1
  
d745 1
a745 1
      
d755 1
a755 1
		tn, GET_TRIG_NAME(trig), 
d762 1
a762 1
      send_to_char("That object does not exist.\r\n", ch); 
d764 1
a764 1
  
d772 1
a772 1
	  
d776 1
a776 1
	  
d786 1
a786 1
  
d796 1
a796 1
  
d798 1
a798 1
  
d804 1
a804 1
  
d807 1
a807 1
    
d810 1
a810 1
    
d813 1
a813 1
  
d833 2
a834 2
      
  
d837 1
a837 1
   
d847 1
a847 1
  
d854 1
a854 1
    
d858 1
a858 1
  
d864 1
a864 1
    
d870 1
a870 1
    
d875 1
a875 1
    
d878 2
a879 2
    return 0; 
}     
d882 1
a882 1
{  
d887 1
a887 1
  char *trigger = 0;   
d892 1
a892 1
  
d898 1
a898 1
  
d908 1
a908 1
    
d918 1
a918 1
  
d928 1
a928 1
    
d946 1
a946 1
      
d949 1
a949 1
    
d953 1
a953 1
      
d962 1
a962 1
      
d972 1
a972 1
    
d976 1
a976 1
      
d985 1
a985 1
      
d995 2
a996 2
  }  
}    
d1015 1
a1015 1
  
d1018 1
a1018 1
  
d1027 2
a1028 2
    
    return 1;      
d1030 1
a1030 1
  
d1035 1
a1035 1
/*  
d1042 1
a1042 1
  
d1090 1
a1090 1
  
d1102 1
a1102 1
  
d1112 2
a1113 2
	break; 
  
d1115 2
a1116 2
   * Set 'self' variables for use below.  For example, if this is a mob 
   * trigger, ch is the mob executing the trigger, and obj and room are 
d1157 1
a1157 1
  
d1159 2
a1160 2
   * If we found a local or global variable above, and a field is 
   * being requested, we need to actually locate the character, object, 
d1290 1
a1290 1
      
d1388 1
a1388 1
        script_log(trig, buf2);        
d1398 1
a1398 1
    
d1400 1
a1400 1
   * If a local or global variable was located above, or we are 
d1529 1
a1529 1
          sprintf(buf2, "unrecognized NPC flag '%s' to %%%s.flagged[]%%", 
d1657 1
a1657 1
 
d1823 1
a1823 1
    
d1872 1
a1872 1
              is_positive_integer(value) && (num = atoi(value) <= 5) ? 
d2081 1
a2081 1
     * We didn't find a matching character, object, or room, but we 
d2105 1
a2105 1
  
d2111 1
a2111 1
  
d2114 1
a2114 1
  
d2116 1
a2116 1
  
d2124 1
a2124 1
    
d2126 1
a2126 1
    
d2136 1
a2136 1
      
d2162 1
a2162 1
      
d2166 1
a2166 1
      
d2172 1
a2172 1
  }  
d2199 1
a2199 1
  
d2201 1
a2201 1
  while (*lhs && isspace(*lhs)) 
d2205 1
a2205 1
  
d2209 2
a2210 2
  for (--p; isspace(*p) && (p > rhs); *p-- = '\0');  
  
d2226 1
a2226 1
  
d2232 1
a2232 1
  }   
d2239 1
a2239 1
  }   
d2274 1
a2274 1
  
d2278 1
a2278 1
  else if (!strcmp("+", op)) 
d2280 1
a2280 1
  
d2303 1
a2303 1
  
d2306 1
a2306 1
  
d2317 1
a2317 1
  
d2326 1
a2326 1
  
d2336 1
a2336 1
  
d2339 1
a2339 1
  
d2341 1
a2341 1
  
d2348 1
a2348 1
  
d2364 1
a2364 1
  
d2386 1
a2386 1
  
d2388 1
a2388 1
  
d2418 1
a2418 1
  
d2431 1
a2431 1
  
d2451 1
a2451 1
  
d2456 1
a2456 1
  
d2459 1
a2459 1
    
d2470 1
a2470 1
  
d2486 1
a2486 1
  
d2489 1
a2489 1
  
d2492 1
a2492 1
    
d2495 1
a2495 1
    
d2502 1
a2502 1
    
d2507 1
a2507 1
    
d2521 1
a2521 1
  
d2534 1
a2534 1
  
d2536 2
a2537 2
  
  
d2540 1
a2540 1
  
d2546 1
a2546 1
  
d2548 1
a2548 1
    
d2554 1
a2554 1
    
d2557 1
a2557 1
    
d2561 1
a2561 1
    
d2567 1
a2567 1
  
d2576 1
a2576 1
  
d2581 1
a2581 1
  
d2592 1
a2592 1
  
d2594 1
a2594 1
  
d2596 1
a2596 1
  
d2602 3
a2604 3
  
  add_var(&GET_TRIG_VARS(trig), name, value);    
  
d2613 1
a2613 1
  
d2615 1
a2615 1
  
d2617 1
a2617 1
  
d2623 1
a2623 1
  
d2625 1
a2625 1
  add_var(&GET_TRIG_VARS(trig), name, result);    
d2636 1
a2636 1
  
d2638 1
a2638 1
  
d2644 1
a2644 1
  
d2656 1
a2656 1
  
d2658 1
a2658 1
  
d2660 1
a2660 1
  
d2666 1
a2666 1
  
d2679 1
a2679 1
  
d2681 1
a2681 1
  
d2712 1
a2712 1
/* 
d2717 1
a2717 1
 *   A pointer to a pointer to the entity running the script.  The 
d2741 1
a2741 1
  
d2760 1
a2760 1
  
d2762 1
a2762 1
  
d2808 1
a2808 1
    
d2811 1
a2811 1
    
d2818 1
a2818 1
    
d2852 1
a2852 1
	while (*orig_cmd && isspace(*orig_cmd)) orig_cmd++; 
d2872 1
a2872 1
    } else if (!strn_cmp("case", p, 4)) { 
d2875 2
a2876 2
    
    
d2878 1
a2878 1
      
d2880 1
a2880 1
      
d2883 1
a2883 1
      
d2886 1
a2886 1
      
d2889 1
a2889 1
      
d2892 1
a2892 1
      
d2895 1
a2895 1
      
d2898 1
a2898 1
      
d2904 1
a2904 1
      
d2920 1
a2920 1
  
d2931 1
a2931 1
  
d2939 1
a2939 1
  
d2944 1
a2944 1
  
d2953 1
a2953 1
  
d2962 1
a2962 1
    
d2978 1
a2978 1
  
d2980 1
a2980 1
    return cl;  
d2983 1
a2983 1
  
d2986 1
a2986 1
    
d2996 1
a2996 1
    else if (!strn_cmp("done", p, 3))   
d3000 1
a3000 1
}        
d3003 1
a3003 1
 * scans for end of while/switch-blocks.   
d3005 1
a3005 1
 * line of the trigger if not found.     
d3012 1
a3012 1
  
d3015 1
a3015 1
  
d3018 1
a3018 1
    
d3024 1
a3024 1
  
d3080 4
d3374 1
a3374 1
 * fix for tlist 
d3389 1
a3389 1
 * 
@


1.89
log
@The event code now handles freeing of event objects.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.88 2008/02/09 04:27:47 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/09 04:27:47 $                                           *
 *  $Revision: 1.88 $                                                      *
d40 1
d524 1
a524 1
        wait_event_obj, NULL, time);
d2597 1
a2597 1
        wait_event_obj, NULL, time);
d2814 1
a2814 1
	    if (MOB_FLAGGED((char_data *)go,MOB_CASTING))
d3094 3
@


1.88
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.87 2008/02/06 03:45:08 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/06 03:45:08 $                                           *
 *  $Revision: 1.87 $                                                      *
a504 1
  free(wait_event_obj);
d507 1
a507 1
  return 0;	/* MUST return 0 or event gets requeued!*/
d3093 3
@


1.87
log
@Stat room and stat obj now use the pager.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.86 2008/02/04 00:22:05 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/04 00:22:05 $                                           *
 *  $Revision: 1.86 $                                                      *
d39 1
d3094 3
@


1.86
log
@Making stat char use the pager.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.85 2008/02/02 19:56:51 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/02 19:56:51 $                                           *
 *  $Revision: 1.85 $                                                      *
d650 1
a650 1
void do_sstat_room(struct char_data * ch, struct room_data *rm)
d652 3
a654 5
  send_to_char("Script information:\r\n", ch);
  if (SCRIPT(rm)) {
    script_stat(ch, buf, SCRIPT(rm));
    send_to_char(buf, ch);
  }
d656 1
a656 1
    send_to_char("  None.\r\n", ch);
d660 1
a660 1
void do_sstat_object(char_data *ch, obj_data *j)
d662 1
a662 1
  send_to_char("Script information:\r\n", ch);
d664 1
a664 1
    send_to_char("  None.\r\n", ch);
d668 1
a668 2
  script_stat(ch, buf, SCRIPT(j));
  send_to_char(buf, ch);
d3093 3
@


1.85
log
@script_driver now requires an address
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.84 2008/02/02 04:27:55 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/02 04:27:55 $                                           *
 *  $Revision: 1.84 $                                                      *
d556 3
a558 3
   sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
         buf, GET_TRIG_NARG(trig),
         ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig)) ?
d561 1
a561 1
   strcat(sb, "Commands:\r\n\r\n");
d563 9
a571 9
   cmd_list = trig->cmdlist;
   while (cmd_list) {
      if (cmd_list->cmd) {
         strcat(sb, escape_ansi(cmd_list->cmd));
         strcat(sb, "\r\n");
      }
      cmd_list = cmd_list->next;
   }
   page_string(ch->desc, sb, 1);
d591 1
a591 1
void script_stat (char_data *ch, struct script_data *sc)
d597 2
a598 2
  sprintf(buf, "Global Variables: %s\r\n", sc->global_vars ? "" : "None");
  send_to_char(buf, ch);
d603 1
a603 1
      sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
d605 1
a605 2
      sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
    send_to_char(buf, ch);
d609 1
a609 1
    sprintf(buf, "\r\n  Trigger: %s%s%s, VNum: [%s%5d%s], RNum: [%5d]\r\n",
a612 1
    send_to_char(buf, ch);
d615 2
a616 2
      send_to_char("  Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), otrig_types, buf1);
d618 2
a619 2
      send_to_char("  Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), wtrig_types, buf1);
d621 2
a622 2
      send_to_char("  Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), trig_types, buf1);
d625 2
a626 2
    sprintf(buf, "  Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n", 
	    buf1, GET_TRIG_NARG(t), 
a628 1
    send_to_char(buf, ch);
d630 1
a630 1
#if 0
d632 4
a635 3
      sprintf(buf, "    Wait: %ld, Current line: %s\r\n",
	      time_to_event(GET_TRIG_WAIT(t)), t->curr_state->cmd);
      send_to_char(buf, ch);
a636 3
      sprintf(buf, "  Variables: %s\r\n", GET_TRIG_VARS(t) ? "" : "None");
      send_to_char(buf, ch);
      
d640 1
a640 1
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
d642 1
a642 2
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
	send_to_char(buf, ch);
d653 4
a656 2
  if (SCRIPT(rm))
    script_stat(ch, SCRIPT(rm));
d670 2
a671 1
  script_stat(ch, SCRIPT(j));
d675 1
a675 1
void do_sstat_character(char_data *ch, char_data *k)
d677 1
a677 1
  send_to_char("Script information:\r\n", ch);
d679 1
a679 1
    send_to_char("  None.\r\n", ch);
d683 1
a683 1
  script_stat(ch, SCRIPT(k));
d1072 1
a1072 1
  int low, high;
d1085 5
a1089 1
  return number(low, high);
d1259 6
a1264 2
      else if (!str_cmp(field, "room"))
        sprintf(str, "%d", world[number(0, top_of_world)].number);
d3096 3
@


1.84
log
@Changing the way script_driver works: you now pass it a pointer
to the pointer of what you want to run the script.  That is,
script_driver(&ch, ...) instead of script_driver(ch, ...).
Adding time triggers (which execute at a given mud time each day).
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.83 2008/02/01 06:44:29 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/01 06:44:29 $                                           *
 *  $Revision: 1.83 $                                                      *
d61 1
a61 1
int script_driver(void *go, trig_data *trig, int type, int mode);
d3091 6
@


1.83
log
@Oops, forgot a line in find_case.  Anyway, you'll now be able to use
expressions on switch lines.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.82 2008/02/01 06:32:23 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/01 06:32:23 $                                           *
 *  $Revision: 1.82 $                                                      *
d506 2
a507 2
  script_driver(go, trig, type, TRIG_RESTART);
  return 0;	/*MUST return 0 or event gets requeued!*/
d509 1
d2723 17
a2739 2
/*  This is the core driver for scripts. */
int script_driver(void *go, trig_data *trig, int type, int mode)
d2748 1
a2748 1

d2776 1
d2780 1
d2784 1
a2796 6
#ifdef PURGED
    if (PURGED(sc))
	return 0;
    if (PURGED(trig))
	return 0;
#endif
d2932 1
a2932 1
  if (trig->purged)
d2934 2
d3047 42
d3091 4
@


1.82
log
@Various fixes to scripts: is_num won't think "------" is a number.
Find end reports an error if no end is found.  Other stuff...
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.81 2008/01/29 21:02:31 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/29 21:02:31 $                                           *
 *  $Revision: 1.81 $                                                      *
d2977 2
d2987 1
a2987 1
      eval_op("==", result, p+5, buf, go, sc, trig);
d3034 4
@


1.81
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.80 2008/01/29 16:51:12 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/29 16:51:12 $                                           *
 *  $Revision: 1.80 $                                                      *
d1062 2
a1063 2
  	  sprintf(buf, "ERROR trigger %d (%s): %s",
                  GET_TRIG_VNUM(t),GET_TRIG_NAME(t), msg);
d1065 1
a1065 1
	  sprintf(buf, "ERROR in trigger: %s", msg);
d2189 11
a2199 7
  while (*num && (isdigit(*num) || *num=='-'))
    num++;
  
  if (!*num || isspace(*num))
    return 1;
  else
    return 0;
d2457 1
a2457 1
struct cmdlist_element *find_end(struct cmdlist_element *cl)
d2462 2
a2463 1
  if (!(cl->next))
d2465 1
d2467 1
a2467 1
  for (c = cl->next; c->next; c = c->next) {
d2471 1
a2471 1
      c = find_end(c);
d2474 5
d2481 1
d2501 1
a2501 1
    for (p = c->cmd; *p && isspace(*p); p++);
d2504 1
a2504 1
      c = find_end(c);
d2520 5
d2526 5
d2554 1
a2591 1
  wait_event_obj->trigger->curr_state=cl;
d2785 1
a2785 1
    if(trig->purged)
d2819 6
a2824 1
      cl = find_end(cl);
d2827 6
a2832 2
      temp = find_done(cl);  
      if (process_if(p + 6, go, sc, trig, type)) {
d2840 5
a2844 1
    } else if (!strn_cmp("end", p, 3)) {   
d2847 1
a2847 1

d2852 1
a2852 1
	if (process_if(orig_cmd + 6, go, sc, trig, type)) {
d2855 1
a2855 1
	  loops++;   
a2859 2
	    /* wtf? WHY would anyone free memory that was NOT allocated? Mud go BOOM!
	       free(cmd);*/
d2862 3
a2864 8
	  if (GET_TRIG_LOOPS(trig) == 100) {
	    char *buf = (char*)malloc(MAX_STRING_LENGTH);
	    sprintf(buf, "SCRIPTERR: Trigger VNum %d has looped 100 times!!!",
		    GET_TRIG_VNUM(trig));
	    mudlog(buf, NRM, LVL_GOD, TRUE);
	    free(buf);
	    /* kill the while loop */
	    temp->original = NULL;
d2972 1
a2973 1
  char *p, *buf;
d2984 3
a2986 4
      buf = (char*)malloc(MAX_STRING_LENGTH);
      sprintf(buf, "(%s) == (%s)", cond, p + 5);
      if (process_if(buf, go, sc, trig, type)) {
        free(buf);
a2987 2
      }
      free(buf);
d3007 1
a3007 1
  if (!(cl->next))
d3010 1
a3010 1
  for (c = cl->next; c->next; c = c->next) {
d3032 4
@


1.80
log
@Moving skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.79 2008/01/27 09:45:41 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/01/27 09:45:41 $                                           *
 *  $Revision: 1.79 $                                                      *
d19 2
d38 1
a41 38
/* external vars from db.c */
extern int top_of_trigt;
extern struct index_data **trig_index;

/* external vars from triggers.c */
extern char *trig_types[], *otrig_types[], *wtrig_types[];

/* other external vars */
extern struct room_data *world;
extern int top_of_world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern char *item_types[];
extern char *genders[];
extern char *sizes[];
extern char *position_types[];
extern char *sector_types[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern char *action_bits[];
extern char *action_bits2[];
extern char *player_bits[];
extern char *preference_bits[];
extern char *wear_positions[];
extern char *extra_bits[];
extern char *room_bits[];
extern char *room_affections[];
extern char *dirs[];
extern char *exit_bits[];
extern char *apply_types[];
extern int rev_dir[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;


d811 1
a811 1
void add_var(struct trig_var_data **var_list, char *name, char *value)
a1103 1
  extern struct time_info_data time_info;
a2522 1
  extern struct time_info_data time_info;
d3007 3
@


1.79
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.78 2008/01/26 14:26:31 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/01/26 14:26:31 $                                           *
 *  $Revision: 1.78 $                                                      *
d1625 1
a1625 1
          strcat(str, skillnames[aff->type]);
d3044 4
@


1.78
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.77 2008/01/19 02:17:08 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/01/19 02:17:08 $                                           *
 *  $Revision: 1.77 $                                                      *
a52 1
extern char *mclass_types[];
d1475 1
a1475 1
      strcpy(str, IS_NPC(c) ? mclass_types[(int) GET_CLASS(c) + 1] : CLASS_NAME(c));
d3044 3
@


1.77
log
@Memory read bug in actor.wearing variable.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.76 2008/01/18 20:30:31 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/18 20:30:31 $                                           *
 *  $Revision: 1.76 $                                                      *
d35 1
a70 1
extern char *spells[];
d1626 1
a1626 1
          strcat(str, spells[aff->type]);
d3045 3
@


1.76
log
@Changing variable fields that return rooms to return vnums instead
references, like they used to be, because that's much easier to work
with in triggers.  You can still get a room reference at any time
by using the get.room function.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.75 2008/01/18 08:28:43 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/18 08:28:43 $                                           *
 *  $Revision: 1.75 $                                                      *
d1779 3
d3045 6
@


1.75
log
@Added room.people[vnum], room.objects[vnum], and object.contents[vnum]
variables.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.74 2008/01/18 07:11:55 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/18 07:11:55 $                                           *
 *  $Revision: 1.74 $                                                      *
d1127 1
a1127 1
#define UID_VAR(str, i)        sprintf((str), "%c%ld", i ? UID_CHAR : '\0', i ? GET_ID(i) : 0)
d1294 2
a1295 4
      else if (!str_cmp(field, "room")) {
        num = number(0, top_of_world);
        ROOM_UID_VAR(str, num);
      }
d1308 1
a1308 1
          ROOM_UID_VAR(str, num);
d1310 1
a1310 1
          *str = '\0';
d1357 1
a1357 1
          *str = '\0';
d1433 1
a1433 1
        *str = '\0';
d1668 1
a1668 1
        *str = '\0';
d1680 1
a1680 1
          *str = '\0';
d1751 1
a1751 1
          *str = '\0';
d1768 1
a1768 1
        *str = '\0';
d1781 1
a1781 1
        *str = '\0';
d1797 6
a1802 2
    else if (!str_cmp(field, "room"))
      ROOM_UID_VAR(str, IN_ROOM(c));
d1819 4
a1822 12
    else if (!str_cmp(field, "clan_id")) {
      if (!IS_NPC(c) && GET_CLAN(c))
        sprintf(str, "%d", GET_CLAN(c));
      else
        *str = '\0';
    }
    else if (!str_cmp(field, "clan_rank")) {
      if (IS_NPC(c))
        *str = '\0';
      else
        sprintf(str, "%d", GET_CLAN_RANK(c));
    }
d1914 4
a1917 6
             !str_cmp(field, "effect_value")) {
      if (!is_positive_integer(value) || (num = atoi(value)) > 5)
        *str = '\0';
      else
        sprintf(str, "%d", o->affected[num].modifier);
    }
d1961 3
a1963 2
      if (obj_room(o) != NOWHERE)
        ROOM_UID_VAR(str, obj_room(o));
d1965 1
a1965 1
        *str = '\0';
d1992 1
a1992 1
          *str = '\0';
d2061 1
a2061 1
          *str = '\0';
d2082 1
a2082 1
          *str = '\0';
d2096 10
a2105 5
        *str = '\0';
      else if (!*value) /* %room.DIR% is a UID */
        ROOM_UID_VAR(str, real_room(r->number));
      else if (!str_cmp(value, "vnum")) /* %room.DIR[vnum]% */
        sprintf(str, "%d", world[r->dir_option[num]->to_room].number);
d3042 4
@


1.74
log
@Adding a get.opposite_dir[] static variable.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.73 2008/01/17 19:23:07 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 19:23:07 $                                           *
 *  $Revision: 1.73 $                                                      *
d1399 43
d1990 11
d2059 11
d2080 11
d3044 3
@


1.73
log
@Added get_room_location which mimics get_room but returns the
rnum instead of the actual room.  Modified get_room to only
attempt to use a string if it starts with a digit; that way
we can chain get_room when looking for a target.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.72 2008/01/17 07:40:32 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 07:40:32 $                                           *
 *  $Revision: 1.72 $                                                      *
d71 1
d1377 14
d2968 6
@


1.72
log
@Taking out the indentation in tstat so you can copy and paste it.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.71 2008/01/17 06:24:23 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 06:24:23 $                                           *
 *  $Revision: 1.71 $                                                      *
d301 1
a301 1
  else if ((nr = real_room(atoi(name))) != NOWHERE)
d307 15
d2953 3
@


1.71
log
@Oops, wrote out the wrong object for wearing[].
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.70 2008/01/17 06:19:47 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 06:19:47 $                                           *
 *  $Revision: 1.70 $                                                      *
d580 1
a580 1
   strcat(sb, "Commands:\r\n   ");
d586 1
a586 1
         strcat(sb, "\r\n   ");
d2938 3
@


1.70
log
@Adding worn[count] and wearing[vnum] fields to character variables.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.69 2008/01/17 04:19:07 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 04:19:07 $                                           *
 *  $Revision: 1.69 $                                                      *
d1705 1
a1705 1
            UID_VAR(str, obj);
d2938 3
@


1.69
log
@Fixing a bug with nested variables.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.68 2008/01/17 04:10:07 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 04:10:07 $                                           *
 *  $Revision: 1.68 $                                                      *
d1687 10
a1696 2
      int where = search_block(value, wear_positions, TRUE);
      if (where < 0)
d1698 11
d1710 1
a1710 1
        UID_VAR(str, GET_EQ(c, where));
d2938 3
@


1.68
log
@Updating get_obj_by_obj() and get_char_room_mscript() to check
UIDs against the calling object and char (since find_replacement
now returns a UID for the object/char instead of "self" now).
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.67 2008/01/17 02:44:16 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 02:44:16 $                                           *
 *  $Revision: 1.67 $                                                      *
d2073 1
a2073 1
          for (subfield = p; *p && (*p != '%') && (*p != ']'); ++p);
d2919 5
@


1.67
log
@Rewrote var_subst.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.66 2008/01/17 01:51:40 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 01:51:40 $                                           *
 *  $Revision: 1.66 $                                                      *
d380 3
d2919 3
@


1.66
log
@Was using the wrong variable (ch not c) in the %room.people[count]%
section of find_replacement.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.65 2008/01/17 01:29:10 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 01:29:10 $                                           *
 *  $Revision: 1.65 $                                                      *
d2020 2
a2021 2
  char tmp[MAX_INPUT_LENGTH], repl_str[MAX_INPUT_LENGTH], *var, *field, *p;
  char subfield[MAX_INPUT_LENGTH];
d2031 1
a2031 1
  subfield[0] = '\0';
d2056 1
a2056 1
      for (var = p; *p && (*p != '%') && (*p != '.'); p++);
d2060 18
a2077 13
	*(p++) = '\0';
	for (field = p; *p && *p != '%'; p++) {
          if (*p == '[' && *(p + 1)) {
	      /* Need to subst any variables between [ and ] */
              char ix1[MAX_INPUT_LENGTH], *ixp;
	      *p = '\0';	/* terminate 'field' */
	      strcpy(ix1, ++p);
              for (; *p && *p != ']'; ++p);
              for (ixp = ix1; *ixp && *ixp != ']'; ++ixp);
	      *ixp = '\0';	/*terminate ix1 (value between [ ] */
	      var_subst(go, sc, trig, type, ix1, subfield);	/* get result in subfield */
	      /* net result %self.people[%num%]% -> %self.people[3]%  (if num=3)*/
          }
d2083 1
a2083 1
      find_replacement(go, sc, trig, type, var, field, subfield, repl_str);
d2916 4
@


1.65
log
@OMG rewrote find_replacement.  It now exposes like every char_data,
obj_data, and room_data field.  This calls for a giant rewrite for
most triggers, but it's worth it.  New stuff you can access includes:
trophy, effects, contents, room flags, and much more!  Also cleaned
up var_subst a bit too.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.64 2008/01/13 23:06:04 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/13 23:06:04 $                                           *
 *  $Revision: 1.64 $                                                      *
d1959 1
a1959 1
          if (!GET_INVIS_LEV(ch))
d2911 7
@


1.64
log
@Fixed a bug in process_global.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.63 2008/01/12 23:13:20 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/12 23:13:20 $                                           *
 *  $Revision: 1.63 $                                                      *
d34 1
d59 9
a67 1

d69 2
d73 3
d91 3
a96 1
int trgvar_in_room(struct trig_data *t,int vnum);
a143 16

int trgvar_in_room(struct trig_data *t,int vnum) {
  int i = 0;
  char_data *ch;
  
  if (NOWHERE == real_room(vnum)) {
    script_log(t,"people.vnum: world[vnum] does not exist");
    return (-1);
  }
  
  for (ch = world[real_room(vnum)].people; ch !=NULL; ch = ch->next_in_room)
     i++;
  
  return i;
}

d213 3
a215 4
  for (ch = character_list; ch; ch=ch->next)
    {
      if (GET_ID(ch)==n) return (ch);
    }
d255 2
a256 3
  if (*name == UID_CHAR)
    {
      i = find_char(atoi(name + 1));
d258 8
a265 10
      if (i && !GET_INVIS_LEV(i))
	return i;
    }
  else
    {
      for (i = character_list; i; i = i->next)
	if (isname(name, i->player.name) &&
	    !GET_INVIS_LEV(i))
	  return i;
    }
d277 2
a278 3
  if (*name == UID_CHAR)
    {
      id = atoi(name + 1);
d280 9
a288 10
      for (obj = object_list; obj; obj = obj->next)
	if (id == GET_ID(obj))
	  return obj;
    }      
  else
    {
      for (obj = object_list; obj; obj = obj->next)
	if (isname(name, obj->name))
	  return obj;
    }
d301 3
a303 1
  else if ((nr = real_room(atoi(name))) == NOWHERE)
a304 2
  else
    return &world[nr];
d316 2
a317 3
  if (*name == UID_CHAR)
    {
      ch = find_char(atoi(name + 1));
d319 16
a334 20
      if (ch && !GET_INVIS_LEV(ch))
	return ch;
    }
  else
    {
      if (obj->carried_by &&
	  isname(name, obj->carried_by->player.name) &&
	  !GET_INVIS_LEV(obj->carried_by))
	return obj->carried_by;
      
      if (obj->worn_by &&
	  isname(name, obj->worn_by->player.name) &&
	  !GET_INVIS_LEV(obj->worn_by))
	return obj->worn_by;
      
      for (ch = character_list; ch; ch = ch->next)
	if (isname(name, ch->player.name) &&
	    !GET_INVIS_LEV(ch))
	  return ch;
    }
d348 2
a349 3
  if (*name == UID_CHAR)
    {
      ch = find_char(atoi(name + 1));
d351 12
a362 15
      if (ch && !GET_INVIS_LEV(ch))
	return ch;
    }
  else
    {
      for (ch = room->people; ch; ch = ch->next_in_room)
	if (isname(name, ch->player.name) &&
	    !GET_INVIS_LEV(ch))
	  return ch;
      
      for (ch = character_list; ch; ch = ch->next)
	if (isname(name, ch->player.name) &&
	    !GET_INVIS_LEV(ch))
	  return ch;
    }
d384 3
a386 5
  if (obj->in_obj)
    {
      if (*name == UID_CHAR)
        {
	  id = atoi(name + 1);
d388 6
a393 6
	  if (id == GET_ID(obj->in_obj))
	    return obj->in_obj;
        }
      else if (isname(name, obj->in_obj->name))
	return obj->in_obj;
    }   
d404 2
a405 3
  if (*name == UID_CHAR)
    {           
      id = atoi(name + 1);
d407 4
a410 4
      for (i = object_list; i; i = i->next)
	if (id == GET_ID(i))
	  break;
    }
d412 5
a416 6
  else
    {
      for (i = object_list; i; i = i->next)
	if (isname(name, i->name))
	  break;
    }
d436 1
a436 1
     * we may still be passed the rnum of an object that is
d441 1
a441 1
     * variable "object" contains the dropped object's rnum.
d450 3
a452 2
     * still a VERY specific object, being identified by rnum
     * and all. */
d456 2
a457 1
  } else {
a460 1
      
d561 1
a561 1
  if (trig->attach_type==OBJ_TRIGGER) {
d564 1
a564 1
  } else if (trig->attach_type==WLD_TRIGGER) {
d577 1
a577 1
   strcat(sb,"Commands:\r\n   ");
d873 1
a873 1
  if ((cname = strstr(name,".")) || (!isdigit(*name)) ) {
d1079 2
a1080 1
  	  sprintf(buf,"ERROR trigger %d (%s): %s",GET_TRIG_VNUM(t),GET_TRIG_NAME(t), msg);
d1087 24
d1113 1
a1113 1
		      int type, char *var, char *field, char *str)
a1120 1
  char buf[MAX_STRING_LENGTH];
d1123 8
d1135 7
a1141 1
  if (!vd)
d1146 27
d1177 7
a1183 2
      if (!str_cmp(var, "self"))
	strcpy(str, "self");
a1186 1
    
d1190 43
a1233 18
    if (vd) {
      name = vd->value;
      
      switch (type) {
      case MOB_TRIGGER:
	ch = (char_data *) go;
	
	if ((o = get_object_in_equip(ch, name, &num)));
	else if ((o = get_obj_in_list(name, ch->carrying)));
	else if ((c = get_char_room(name, IN_ROOM(ch))));
	else if ((o = get_obj_in_list(name,world[IN_ROOM(ch)].contents)));
	else if ((c = get_char(name)));
	else if ((o = get_obj(name)));
	else if ((r = get_room(name))) {}
	
	break;
      case OBJ_TRIGGER:
	obj = (obj_data *) go;
d1235 35
a1269 3
	if ((c = get_char_by_obj(obj, name)));
	else if ((o = get_obj_by_obj(obj, name)));
	else if ((r = get_room(name))) {}
d1271 2
a1272 3
	break;
      case WLD_TRIGGER:
	room = (struct room_data *) go;
d1274 5
a1278 3
	if ((c = get_char_by_room(room, name)));
	else if ((o = get_obj_by_room(room, name)));
	else if ((r = get_room(name))) {}
d1280 14
a1293 1
	break;
d1295 4
d1301 9
a1309 13
    else {
      if (!str_cmp(var, "self")) {
	switch (type) {
	case MOB_TRIGGER:
	  c = (char_data *) go;
	  break;
	case OBJ_TRIGGER:
	  o = (obj_data *) go;
	  break;
	case WLD_TRIGGER:
	  r = (struct room_data *) go;
	  break;
	}
d1312 38
a1349 7
      else if (!str_cmp(var, "people")) {
	sprintf(str,"%d",((num = atoi(field)) > 0) ? trgvar_in_room(trig,num) : 0);	
	return;
      }
      else if (!str_cmp(var, "time")) {
        if (!str_cmp(field,"hour")) {
          sprintf(str,"%d",time_info.hours);
d1351 4
a1354 2
        else if (!str_cmp(field,"day")) {
          sprintf(str,"%d",time_info.day);
d1356 1
a1356 15
        else if (!str_cmp(field,"month")) {
          sprintf(str,"%d",time_info.month);
        }
        else if (!str_cmp(field,"year")) {
          sprintf(str,"%d",time_info.year);
        }
        return;
      } else if (!str_cmp(var, "random")) {
         if (!str_cmp(field, "char")) {
            if (type == MOB_TRIGGER)
               c = get_random_char_around((char_data *) go, RAND_DG_MOB);
            else if (type == OBJ_TRIGGER)
               c = get_random_char_around(world[obj_room((struct obj_data *) go)].people, RAND_DG_OBJ);
            else if (type == WLD_TRIGGER)
               c = get_random_char_around(((struct room_data *) go)->people, RAND_DG_WLD);
d1358 10
a1367 6
            if (c)
               sprintf(str, "%c%ld", UID_CHAR, GET_ID(c));
            else
               *str = '\0';
         } else
            sprintf(str, "%d", ((num = atoi(field)) > 0) ? number(1, num) : 0);
d1369 2
a1370 3
         return;
      }
   }
d1372 102
a1473 83
    if (c) {
      if (!str_cmp(field, "name"))
        if (GET_SHORT(c))
          strcpy(str, GET_SHORT(c));
        else
          strcpy(str, GET_NAME(c));
      /* 'possessive' form*/
      else if (!strcmp(field,"p"))
      {
	      switch (GET_SEX(c))
	      {
		      case SEX_NEUTRAL:	sprintf(str,"its");
					break;
		      case SEX_MALE:	sprintf(str,"his");
					break;
		      case SEX_FEMALE:	sprintf(str,"her");
					break;
		      default:		mudlog("Bad sex found in expansion of %actor.p%",NRM,LVL_GOD,TRUE);
					break;
	      }
      }
      /* 'objective' form*/
      else if (!strcmp(field,"o"))
      {
	      switch (GET_SEX(c))
	      {
		      case SEX_NEUTRAL:	sprintf(str,"it");
					break;
		      case SEX_MALE:	sprintf(str,"him");
					break;
		      case SEX_FEMALE:	sprintf(str,"her");
					break;
		      default:		mudlog("Bad sex found in expansion of %actor.o%",NRM,LVL_GOD,TRUE);
					break;
	      }
      }
      /* 'nominative' form*/
      else if (!strcmp(field,"n"))
      {
	      switch (GET_SEX(c))
	      {
		      case SEX_NEUTRAL:	sprintf(str,"it");
					break;
		      case SEX_MALE:	sprintf(str,"he");
					break;
		      case SEX_FEMALE:	sprintf(str,"she");
					break;
		      default:		mudlog("Bad sex found in expansion of %actor.n%",NRM,LVL_GOD,TRUE);
					break;
	      }
      }
      
      else if (!str_cmp(field, "alias"))
	strcpy(str, GET_NAME(c));
      
      else if (!str_cmp(field, "level"))
	sprintf(str, "%d", GET_LEVEL(c));

      else if (!str_cmp(field, "align"))
	sprintf(str, "%d", GET_ALIGNMENT(c));

      else if (!str_cmp(field, "gold"))
	sprintf(str, "%d", GET_GOLD(c));

      else if (!str_cmp(field, "sex"))
	strcpy(str, genders[(int)GET_SEX(c)]);

      else if (!str_cmp(field, "canbeseen")) {
	if ((type == MOB_TRIGGER) && !CAN_SEE(((char_data *)go), c))
	  strcpy(str, "0");
	else
	  strcpy(str, "1");
      }

      else if (!str_cmp(field, "class"))
      {
	char *dumptr;

	if (!IS_NPC(c)) {
	  sprintf(str,"%s",strip_ansi(CLASS_WIDE(c)));
	} else {
	  sprintf(str,"%s",strip_ansi(mclass_types[(int)GET_CLASS(c) + 1]));
	}
d1475 70
a1544 6
	/*
	 * remove any spaces at end of name
	 */
	dumptr = str;
	while (*dumptr && *dumptr != ' ') dumptr++;
	if (*dumptr==' ') *dumptr='\0';
d1546 18
d1565 1
d1567 23
a1589 4
#ifdef GET_RACE
      else if (!str_cmp(field, "race"))
         strcpy(str, races[(int)GET_RACE(c)].displayname);
#endif
d1591 1
a1591 2
      else if (!str_cmp(field, "size"))
        sprinttype(GET_SIZE(c) + 1, sizes, str);
d1593 16
a1608 2
      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_MOB_VNUM(c));
d1610 31
a1640 47
      else if (!strn_cmp(field, "oshdesc[", 8)) { 
	int n; 
	char vnum[10]; 
	extern struct obj_data *obj_proto; 
	struct obj_data* tobj; 
	char *ptr; 
	int num; 
	ptr = field+8; 
	n=0; 
	skip_spaces(&ptr); 
	while ((*(ptr+n) != ']') &&  (*(ptr+n) != ' ') && n < 10) 
	  { 
	    vnum[n] = *(ptr+n); 
	    n++; 
	  } 
	vnum[n] = '\0'; 
	num = atoi(vnum); 
	num = real_object(num); 
	
	tobj = &obj_proto[num]; 
	
	if (tobj && tobj->short_description) { 
	  sprintf(str, "%s", tobj->short_description); 
	} 
	else { 
	  sprintf(str, "No description available."); 
	} 
	return; 
      } 

      else if (!str_cmp(field, "exists"))
	sprintf(str, "%d", mob_index[GET_MOB_RNUM(c)].number);

      else if (!strn_cmp(field, "oexists[", 8)) {
	int n, x;
        struct obj_data *objex;
        char objt[10];
        char *ptr;
	ptr = field+8;
	n=0;
	skip_spaces(&ptr);
	while ((*(ptr+n) != ']') &&  (*(ptr+n) != ' ') && n < 10)
	{
	  objt[n] = *(ptr+n);
	  n++;
	}
	objt[n] = '\0';
d1642 10
a1651 21
        if ((x = real_object(atoi(objt))) >= 0) {
          objex = read_object(x, REAL);
      	  sprintf(str, "%d", obj_index[GET_OBJ_RNUM(objex)].number - 1);
          extract_obj(objex);
        } else
      	  sprintf(str, "0");

      } else if (!strn_cmp(field, "mexists[", 8)) {
	int n, x;
        struct char_data *mobex;
        char mobt[10];
        char *ptr;
	ptr = field+8;
	n=0;
	skip_spaces(&ptr);
	while ((*(ptr+n) != ']') &&  (*(ptr+n) != ' ') && n < 10)
	{
	  mobt[n] = *(ptr+n);
	  n++;
	}
	mobt[n] = '\0';
d1653 10
a1662 29
        if ((x = real_mobile(atoi(mobt))) >= 0) {
          mobex = read_mobile(x, REAL);
  	  sprintf(str, "%d", mob_index[GET_MOB_RNUM(mobex)].number - 1);
          char_to_room(mobex, 0);
          extract_char(mobex);
        } else
      	  sprintf(str, "0");

      } else if (!str_cmp(field, "cha"))
	sprintf(str, "%d", GET_VIEWED_CHA(c));
      else if (!str_cmp(field, "str"))
        sprintf(str, "%d", GET_VIEWED_STR(c));
      else if (!str_cmp(field, "int"))
        sprintf(str, "%d", GET_VIEWED_INT(c));
      else if (!str_cmp(field, "wis"))
        sprintf(str, "%d", GET_VIEWED_WIS(c));
      else if (!str_cmp(field, "con"))
        sprintf(str, "%d", GET_VIEWED_CON(c));
      else if (!str_cmp(field, "dex"))
        sprintf(str, "%d", GET_VIEWED_DEX(c));

      else if (!str_cmp(field, "hit"))
        sprintf(str, "%d", GET_HIT(c));
      else if (!str_cmp(field, "maxhit"))
        sprintf(str, "%d", GET_MAX_HIT(c));
      else if (!str_cmp(field, "move"))
        sprintf(str, "%d", GET_MOVE(c));
      else if (!str_cmp(field, "maxmove"))
        sprintf(str, "%d", GET_MAX_MOVE(c));
d1664 22
a1685 1
      else if (!str_cmp(field, "flags")) {
d1687 12
a1698 8
        if (AFF_FLAGS(c) || !(AFF2_FLAGS(c) || AFF3_FLAGS(c)))
          sprintbit(AFF_FLAGS(c), affected_bits, str);
        if (AFF2_FLAGS(c))
          sprintbit(AFF2_FLAGS(c), affected_bits2, str + strlen(str));
        if (AFF3_FLAGS(c))
          sprintbit(AFF3_FLAGS(c), affected_bits3, str + strlen(str));
        /* Cut off the space on the end. */
        *(str + strlen(str) - 1) = '\0';
d1700 14
a1713 11
      else if (!strn_cmp(field, "quest_variable[", 15))
	{
	  char qname[MAX_QNAME_LEN];
	  char var[21];
	  char *ptr; 
	  int i,j;
	  
	  if (IS_MOB(c))
	    sprintf(str,"0");
	  else
	    {
d1715 19
a1733 27
	      ptr = field+15;
	      i = 0; 
	      j = 0;

	      skip_spaces(&ptr);
	      while ((*(ptr+i) != ':') &&  (*(ptr+i) != ' ') 
		     && i < 20)
		{
		  qname[i] = *(ptr+i);
		  i++;
		}
	      qname[i] = '\0';

	      while (*(ptr+i) == ':' || *(ptr+i) == ' ')
		i++; 

	      ptr = ptr + i; 
	      skip_spaces(&ptr); 

	      i = 0;
	      while ((*(ptr+i) != ']') &&  (*(ptr+i) != ' ') 
		     && i < 20)
		{
		  var[i] = *(ptr+i);
		  i++;
		}
	      var[i] = '\0';
d1735 2
a1736 1
	      sprintf(str, "%s", get_quest_variable(c, qname, var));
d1738 11
a1748 131
	    };
	}
      else if (!strn_cmp(field, "quest_stage[",12))
      {
	      char qname[MAX_QNAME_LEN];
	      char *ptr;
	      int i;
	      if (IS_MOB(c))
		      sprintf(str,"n/a");
	      else
	      {
		ptr = field+12;
		i=0;
		skip_spaces(&ptr);
		while ((*(ptr+i) != ']') &&  (*(ptr+i) != ' ') && i < MAX_QNAME_LEN)
		{
			qname[i] = *(ptr+i);
			i++;
		}
		qname[i] = '\0';
	      	sprintf(str,"%d",quest_stage(c, qname));
	      }
      }
      else if (!strn_cmp(field, "has_completed[",14))
      {
	      char qname[MAX_QNAME_LEN];
	      char *ptr;
	      int i;
	      if (IS_MOB(c))
		      sprintf(str,"n/a");
	      else
	      {

		ptr = field+14;
		i=0;
		skip_spaces(&ptr);
		while ((*(ptr+i) != ']') &&  (*(ptr+i) != ' ') &&  i < MAX_QNAME_LEN)
		{
			qname[i] = *(ptr+i);
			i++;
		}
		qname[i] = '\0';
	      	sprintf(str,"%s",(has_completed_quest(qname,c))?"true":"false");
	      }
      }
      else if (!strn_cmp(field, "has_failed[",11))
      {
	      char qname[MAX_QNAME_LEN];
	      char *ptr;
	      int i;
	      if (IS_MOB(c))
		      sprintf(str,"n/a");
	      else
	      {
		ptr = field+11;
		i=0;
		skip_spaces(&ptr);
		while ((*(ptr+i) != ']') &&  (*(ptr+i) != ' ') &&  i < MAX_QNAME_LEN)
		{
			qname[i] = *(ptr+i);
			i++;
		}
		qname[i] = '\0';
	      	sprintf(str,"%s",(has_failed_quest(qname,c))?"true":"false");
	      }
      }
      else if (!strn_cmp(field, "group[",6))
      {
	      int i;
	      struct group_type *g;
	      struct char_data *cc = (c->groupmaster)?c->groupmaster:c;
              char throw1[8];
              sscanf(field,"%6s%d%s",throw1,&i,buf);
	      i--;	/*coder will use 1->groupnum, we key 0->(groupnum-1)*/

	      if (i == 0)
	      {
		      /* first member of group is leader ( == 0)*/
		      sprintf(str, "%c%ld", UID_CHAR, GET_ID(cc));
	      }
	      else
	      {
		      /*
		       * group leader (=0 over all!)
		       * group member 1 (= 0 in list of groupees!)
		       */
		i--;
	      	for (g = cc->groupees; g && i; i--, g = g->next)
		{
		            if (!IS_AFFECTED(g->groupee, AFF_GROUP))
				            continue;
	      	}
	      	if (g)
	      	{
	        	sprintf(str, "%c%ld", UID_CHAR, GET_ID(g->groupee));
	      	}
	      	else
	      	{
		      /*specified a number greater than plyrs in group*/
		      /* wont log it, mistakes happen!*/
		      str="\0";
	      	}
	      }
      }
      else if (!strn_cmp(field, "groupnum",8))
      {
	      int i=0;
	      struct group_type *g = (c->groupmaster)?(c->groupmaster)->groupees:c->groupees;
	      if (g)
		      i++;	/* for the group master */
	      while (g && IS_AFFECTED(g->groupee, AFF_GROUP))
	      {
		      i++;
		      g = g->next;
	      }
	      sprintf(str,"%d",i);
      }
      else if (!strn_cmp(field, "worn[",5))
      {
        /* we are only interested in the number part so use
        ** sscanf to grab that out of the string
        */
        int i;
        char throw1[8];
        sscanf(field,"%5s%d%s",throw1,&i,buf);
        sprintf(str,"%d",(GET_EQ(c,i))? GET_OBJ_VNUM(GET_EQ(c,i)):-1);
      }
      else if (!strn_cmp(field, "position1", 9)) {
        switch(GET_POS1(c)) {
          case POS1_STANDING:
            sprintf(str, "Standing");
d1750 15
a1764 14
          case POS1_KNEELING:
            sprintf(str, "Kneeling");
            break;
          case POS1_SITTING:
            sprintf(str, "Sitting");
            break;
          case POS1_RESTING:
            sprintf(str, "Resting");
            break;
          case POS1_PRONE:
            sprintf(str, "Prone");
            break;
          default:
            sprintf(str, "Invalid POS1");
d1766 3
d1770 1
a1770 2
      else if (!strn_cmp(field, "position", 8))
	strncpy(str, position_types[(int)GET_POS(c)], MAX_INPUT_LENGTH);
d1772 59
a1830 2
      else if (!str_cmp(field, "room"))
	sprintf(str, "%d", world[IN_ROOM(c)].number);
d1832 11
a1842 2
      else if (!strn_cmp(field, "room_var", 8)) {
        sprintf(str, "%c%ld", UID_CHAR, (long) IN_ROOM(c) + ROOM_ID_BASE);
d1844 20
a1863 1

d1865 4
a1868 3
	*str = '\0';
	sprintf(buf2, "Unknown char field: '%s'", field);
	script_log(trig,buf2);
a1870 4
    
    else if (o) {
      if (!str_cmp(field, "name"))
	strcpy(str, o->name);
d1872 28
a1899 4
      else if (!str_cmp(field,"weight"))
	sprintf(str, "%d",o->obj_flags.weight);
      else if (!str_cmp(field, "shortdesc"))
	strcpy(str, o->short_description);
d1901 6
a1906 2
      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_OBJ_VNUM(o));
d1908 31
a1938 21
      else if (!str_cmp(field, "exists"))
	sprintf(str, "%d", obj_index[GET_OBJ_RNUM(o)].number);

      else if (!str_cmp(field, "type"))
	sprinttype(GET_OBJ_TYPE(o), item_types, str);
      
      else if (!str_cmp(field, "val0"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 0));
      
      else if (!str_cmp(field, "val1"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 1));
      
      else if (!str_cmp(field, "val2"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 2));
      
      else if (!str_cmp(field, "val3"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 3));
      
      else if (!str_cmp(field, "timer"))
        sprintf(str, "%d", GET_OBJ_TIMER(o));
	
d1940 4
a1943 3
	*str = '\0';
	sprintf(buf2, "trigger type: %d. unknown object field: '%s'", type, field);
	script_log(trig,buf2);
d1947 16
a1962 62
    else if (r) {
      if (!str_cmp(field, "name"))
	strcpy(str, r->name);
      else if (!str_cmp(field,"vnum"))
        sprintf(str,"%d",r->number);
      else if (!str_cmp(field, "north")) {
	if (r->dir_option[NORTH])
	  sprintbit(r->dir_option[NORTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "east")) {
	if (r->dir_option[EAST])
	  sprintbit(r->dir_option[EAST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "south")) {
	if (r->dir_option[SOUTH])
	  sprintbit(r->dir_option[SOUTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "west")) {
	if (r->dir_option[WEST])
	  sprintbit(r->dir_option[WEST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "up")) {
	if (r->dir_option[UP])
	  sprintbit(r->dir_option[UP]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "down")) {
	if (r->dir_option[DOWN])
	  sprintbit(r->dir_option[DOWN]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!strn_cmp(field,"people[",7)) {
        int i;
        char throw1[8],throw2[3];
        sscanf(field,"%7s%d%s",throw1,&i,throw2);
	i--;
	if (i < 0)	/* person[i-1] may not exist..*/
	{
		*str = '\0';
		sprintf(buf2,
		"trigger type: %d. bad access of 'people' array: '%s'",
		type, field);
		script_log(trig,buf2);
	}
	else
	{
		char_data * ch ;
 		for (ch = world[real_room(r->number)].people; i && ch !=NULL; ch = ch->next_in_room)
    			i--;
		if (i > 0)	/* not enough people in room, wont log this, people move...*/
			*str = '\0';
		else 
	        	sprintf(str, "%c%ld", UID_CHAR, GET_ID(ch));
		/*sprintf(str, "%d", GET_MOB_VNUM(ch));*/
	}
		
      } else if (!strn_cmp(field, "sector", 6))
        sprinttype(r->sector_type, sector_types, str);
d1964 5
a1968 5
	*str = '\0';
	sprintf(buf2,
		"trigger type: %d. unknown room field: '%s'",
		type, field);
	script_log(trig,buf2);
d1972 17
a1988 1
    else
d1990 22
d2021 1
a2022 1
  int paren_count = 0;
d2024 1
d2031 1
d2037 1
d2055 1
a2055 1
      /* . means field within variable, [ means array within variable*/
d2061 10
a2070 18
	for (field = p; *p && ((*p != '%')||(paren_count)); p++) {
          if (*p=='(') paren_count++;
          else if (*p==')') paren_count--;
          else if (*p == '[') {
	      /* need to subst any variables between  [ and ] */
              char ix1[128];
	      char ix2[128];
	      char *ixp;
	      *p = '\0';	/*terminate 'field'*/
	      strcpy (ix1,++p);
	      while (*(++p) != ']');
	      ixp=ix1; while (*(++ixp) != ']');
	      *ixp='\0';	/*terminate ix1 (value between [ ] */
	      var_subst(go,sc,trig,type,ix1,ix2);	/* get result in ix2 */
	      strncat(field,"[",1);
	      strncat(field,ix2,strlen(ix2));
	      strncat(field,"]",1);	/* add back to 'field'*/

d2078 1
a2078 1
      find_replacement(go, sc, trig, type, var, field, repl_str);
d2435 1
a2435 1
    script_log(trig,buf2);
d2491 1
a2491 1
    script_log(trig,buf2);
d2512 1
a2512 1
    script_log(trig,buf2);
d2533 1
a2533 1
    script_log(trig,buf2);
d2555 1
a2555 1
    script_log(trig,buf2);
d2592 1
a2592 1
      script_log(trig,buf2);
d2622 2
a2623 1
    sprintf(buf,"Triggers recursed beyond maximum allowed depth on mob %d",GET_MOB_VNUM((char_data *) go));
d2626 2
a2627 1
    sprintf(buf,"Triggers recursed beyond maximum allowed depth on obj %d",GET_OBJ_VNUM((obj_data *) go));
d2630 2
a2631 1
    sprintf(buf,"Triggers recursed beyond maximum allowed depth in room %d",((struct room_data *) go)->number);
d2634 1
a2634 1
    script_log(trig,buf);
d2735 1
a2735 1
	    sprintf(buf,"SCRIPTERR: Trigger VNum %d has looped 100 times!!!",
d2911 3
@


1.63
log
@Created a multi-purpose get_random_char_around() function to pick random
chars in a room.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.62 2008/01/09 02:30:56 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/01/09 02:30:56 $                                           *
 *  $Revision: 1.62 $                                                      *
d2334 1
a2334 1
    script_log(trig,buf2);
d2340 1
d2664 4
@


1.62
log
@Use macro to get mob real number.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.61 2008/01/04 01:53:26 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/01/04 01:53:26 $                                           *
 *  $Revision: 1.61 $                                                      *
d1109 1
a1109 1
  char_data *ch, *c = NULL, *rndm;
d1113 1
a1113 1
  int num, count, wear;
d1147 1
a1147 1
	if ((o = get_object_in_equip(ch, name, &wear)));
d1210 6
a1215 2
            rndm = NULL;
            count = 0;
d1217 2
a1218 26
            if (type == MOB_TRIGGER) {
               ch = (char_data *) go;
               for (c = world[IN_ROOM(ch)].people; c; c = c->next_in_room)
                  if (!PRF_FLAGGED(c, PRF_NOHASSLE) && (c != ch) && CAN_SEE(ch, c)) {
                     if (!number(0, count))
                        rndm = c;
                     count++;
                  }
            } else if (type == OBJ_TRIGGER) {
               for (c = world[obj_room((obj_data *) go)].people; c; c = c->next_in_room)
                  if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
                     if (!number(0, count))
                        rndm = c;
                     count++;
                  }
            } else if (type == WLD_TRIGGER) {
               for (c = ((struct room_data *) go)->people; c; c = c->next_in_room)
                  if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
                     if (!number(0, count))
                        rndm = c;
                     count++;
                  }
            }

            if (rndm)
               sprintf(str, "%c%ld", UID_CHAR, GET_ID(rndm));
d2663 3
@


1.61
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.60 2008/01/03 12:44:03 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/01/03 12:44:03 $                                           *
 *  $Revision: 1.60 $                                                      *
d1383 1
a1383 1
	sprintf(str, "%d", mob_index[c->nr].number);
d2683 4
@


1.60
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.59 2007/12/25 05:41:49 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/12/25 05:41:49 $                                           *
 *  $Revision: 1.59 $                                                      *
d33 1
a50 1
extern char *pc_race_types[];
d1343 1
a1343 1
	sprinttype(GET_RACE(c), pc_race_types, str);
d2683 4
@


1.59
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.58 2007/10/04 16:20:24 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/10/04 16:20:24 $                                           *
 *  $Revision: 1.58 $                                                      *
d32 1
a49 1
extern char *pc_class_types[];
d1327 1
a1327 1
	  sprintf(str,"%s",strip_ansi(pc_class_types[(int)GET_CLASS(c)]));
d2683 5
@


1.58
log
@Added %object.timer% variable.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.57 2007/09/20 23:19:00 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/09/20 23:19:00 $                                           *
 *  $Revision: 1.57 $                                                      *
d556 2
a557 1
  GET_TRIG_WAIT(trig) = event_create(trig_wait_event, wait_event_obj,time);
d2250 2
a2251 1
  GET_TRIG_WAIT(trig) = event_create( trig_wait_event, wait_event_obj,time);
d2683 3
@


1.57
log
@Fixing flags again.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.56 2007/09/20 23:12:29 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/09/20 23:12:29 $                                           *
 *  $Revision: 1.56 $                                                      *
d1699 3
d2681 3
@


1.56
log
@Wrong flags in %actor.flags%!
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.55 2007/09/20 21:20:43 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/09/20 21:20:43 $                                           *
 *  $Revision: 1.55 $                                                      *
d1455 1
a1455 1
        else if (AFF2_FLAGS(c))
d1457 1
a1457 1
        else if (AFF3_FLAGS(c))
d2678 3
@


1.55
log
@The %actor.flags% variable now returns a sprintbit string of all
the flags the actor has, instead of checking bits using a [] thingy.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.54 2007/09/17 22:29:59 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/09/17 22:29:59 $                                           *
 *  $Revision: 1.54 $                                                      *
d1454 1
a1454 1
          sprintbit(AFF_FLAGS(c), affected_bits, str + strlen(str));
d1456 1
a1456 1
          sprintbit(AFF_FLAGS(c), affected_bits2, str + strlen(str));
d2678 4
@


1.54
log
@Unbreak some triggers I broke by not checking the entire
world for object rnums in get_obj_by_room().
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.53 2007/08/30 19:42:46 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/30 19:42:46 $                                           *
 *  $Revision: 1.53 $                                                      *
d55 3
d1451 10
a1460 16
      else if (!strn_cmp(field, "flags[",6))
      {
	/* there are 3 levels of flags, so we need to specify which
	** we are trying to match. The second digit is the flag to
	** try for (long int value)
	*/
        long i;
	int n;
        char throw1[8];
        sscanf(field,"%6s%d,%ld%s",throw1,&n,&i,buf);
	if (n == 1)
		sprintf(str,"%s", ( AFF_FLAGGED(c,i))?"true":"false");
	else if (n == 2)
		sprintf(str,"%s", ( AFF2_FLAGGED(c,i))?"true":"false");
	else if (n == 3)
		sprintf(str,"%s", ( AFF3_FLAGGED(c,i))?"true":"false");
d2678 4
@


1.53
log
@Cause *purge dg script commands to destroy all of a mobile's inventory
and equipment when purging mobs.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.52 2007/08/30 09:10:44 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/30 09:10:44 $                                           *
 *  $Revision: 1.52 $                                                      *
d450 21
d2681 4
@


1.52
log
@Change get_obj_by_room to only find objects in the requested room.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.51 2007/08/26 22:37:37 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/26 22:37:37 $                                           *
 *  $Revision: 1.51 $                                                      *
d2650 8
d2660 3
@


1.51
log
@%people.ROOM% back to the actual number of chars in there.
It was causing way too many problems the other way.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.50 2007/08/24 17:01:36 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/08/24 17:01:36 $                                           *
 *  $Revision: 1.50 $                                                      *
d444 2
a445 3
  if (*name == UID_CHAR)
    {
      id = atoi(name + 1);
d447 7
a453 3
      for (obj = room->contents; obj; obj = obj->next_content)
	if (id == GET_ID(obj)) 
	  return obj;
d455 2
a456 15
      for (obj = object_list; obj; obj = obj->next)
	if (id == GET_ID(obj))
	  return obj;
    }
  else
    {
      for (obj = room->contents; obj; obj = obj->next_content)
	if (isname(name, obj->name))
	  return obj;
      
      for (obj = object_list; obj; obj = obj->next)
	if (isname(name, obj->name))
	  return obj;
    }           
  
d2652 4
@


1.50
log
@Adding ostat and mstat commands as shorthand for vstat, rstat for stat
room, and mnum and onum for vnum.  Also adding rnum and znum with new
functionality.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.49 2007/08/24 10:24:04 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/08/24 10:24:04 $                                           *
 *  $Revision: 1.49 $                                                      *
d136 1
a136 2
    if (!PRF_FLAGGED(ch, PRF_NOHASSLE) && !GET_INVIS_LEV(ch))
       i++;
d2662 5
@


1.49
log
@Moved zstat to act.wizard.c.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.48 2007/08/14 08:48:11 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/14 08:48:11 $                                           *
 *  $Revision: 1.48 $                                                      *
d676 1
a676 1
void do_sstat_room(struct char_data * ch)
a677 2
  struct room_data *rm = &world[ch->in_room];
  
d679 3
a681 1
  if (!SCRIPT(rm)) {
a682 4
    return;
  }
  
  script_stat(ch, SCRIPT(rm));
d2663 3
@


1.48
log
@Renamed dg_global_pulse to global_pulse since it will now be used for
other things in addition to dg scripting.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.47 2007/08/08 20:21:10 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/08 20:21:10 $                                           *
 *  $Revision: 1.47 $                                                      *
a2571 24
ACMD(do_tlist)
{
  
  int first, last, nr, found = 0;
  char pagebuf[65536];
  
  strcpy(pagebuf,"");
  if (!vnumargs(ch, argument, &first, &last)) return;
  
  for (nr = 0; nr < top_of_trigt ; nr++)
    {
      if ((trig_index[nr]->virtual >= first) && (trig_index[nr]->virtual <= last)) {
	sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
		trig_index[nr]->virtual,
		trig_index[nr]->proto->name);
	strcat(pagebuf, buf);
      }
    }
  
  if (!found)
    send_to_char("No triggers were found in those parameters.\n\r", ch);
  else page_string(ch->desc, pagebuf, TRUE);
}

d2667 4
@


1.47
log
@Oops left an unused variable in do_tlist.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.46 2007/08/08 20:09:42 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/08/08 20:09:42 $                                           *
 *  $Revision: 1.46 $                                                      *
d2196 1
a2196 1
  extern long dg_global_pulse;
d2219 1
a2219 1
    time = (dg_global_pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC)) +
d2691 3
@


1.46
log
@tlist, mlist, olist, and rlist now accept a single parameter which they
take to be a zone whose objects should be listed.  If no parameter is
given, they will list objects in the current zone - where the character
issuing the command is located.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.45 2007/05/29 00:36:03 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/05/29 00:36:03 $                                           *
 *  $Revision: 1.45 $                                                      *
d2575 1
a2575 1
  int first, last, znum, nr, found = 0;
d2691 6
@


1.45
log
@Use the proper top of zone value when processing the command <tlist #>,
which shows a list of triggers in zone #.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.44 2007/05/29 00:04:19 jps Exp jps $
d8 2
a9 2
 *  $Date: 2007/05/29 00:04:19 $                                           *
 *  $Revision: 1.44 $                                                      *
d73 1
d2579 1
a2579 36
  
  two_arguments(argument, buf, buf2);
  
  if (!*buf) {
    send_to_char("Usage: tlist <begining number or zone> [<ending number>]\r\n", ch);
    return;
  }
  
  first = atoi(buf);
  if (first < 0 || first > 99999) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (*buf2) last = atoi(buf2);
  else {
     /* One parameter given. Use it as a zone number, if possible, and show
      * everything from first*100 to the top of that zone (e.g., 30 => 3000-3499, Mielikki).
      * If the zone can't be identified, show everything from first*100 to first*100+99. */
     znum = find_zone(first);
     first *= 100;
     if (znum == -1)
        last = first + 99;
     else
        last = zone_table[znum].top;
  }
  
  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 999.\n\r", ch);
    return;
  }
  
  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }
d2691 4
@


1.44
log
@Escape commands in tstat so you can copy and paste the code.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.43 2007/05/11 19:34:15 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/05/11 19:34:15 $                                           *
 *  $Revision: 1.43 $                                                      *
d72 1
a72 1

d2574 1
a2574 1
  int first, last, nr, found = 0;
d2587 5
d2594 9
a2602 2
    first *= 100;
    last = first+99;
d2725 3
@


1.43
log
@Modified the quest command functions so they are thin wrappers for
perform_quest() in quest.c.  Error handling and messages should be
much better now.  Advance and rewind now accept another argument
specifying how many stages to advance or rewind.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.42 2007/04/18 21:58:11 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/04/18 21:58:11 $                                           *
 *  $Revision: 1.42 $                                                      *
d575 13
a587 16
  sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
	  buf, GET_TRIG_NARG(trig), 
	  ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig))
	   ? GET_TRIG_ARG(trig) : "None"));
  
  strcat(sb,"Commands:\r\n   ");
  
  cmd_list = trig->cmdlist;
  while (cmd_list)
    {
      if (cmd_list->cmd)
	{
	  strcat(sb,cmd_list->cmd);
	  strcat(sb,"\r\n   ");
	}
      
d589 2
a590 3
    }
  
  page_string(ch->desc, sb, 1);
d2713 6
@


1.42
log
@The %people.roomvnum% variable now sees exactly the same characters
as %random.char% (in other words, not NOHASSLE or wizinvis'd folks).
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.41 2007/04/17 23:53:23 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/04/17 23:53:23 $                                           *
 *  $Revision: 1.41 $                                                      *
d1502 1
a1502 1
	      sprintf(str, "%s", get_quest_variable(qname, c, var));
d1524 1
a1524 1
	      	sprintf(str,"%d",quest_stage(qname,c));
d2717 4
@


1.41
log
@The 'global' trigger command now takes a list of local variables and
globalizes each one.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.40 2007/03/27 04:27:05 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/03/27 04:27:05 $                                           *
 *  $Revision: 1.40 $                                                      *
d135 2
a136 1
    i++;
d1201 35
a1235 42
      }
      else if (!str_cmp(var, "random")) {
	if (!str_cmp(field, "char")) {
	  rndm = NULL;
	  count = 0;

	  if (type == MOB_TRIGGER) {
	    ch = (char_data *) go;
	    for (c = world[IN_ROOM(ch)].people; c; c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && (c != ch) &&
		  CAN_SEE(ch, c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  else if (type == OBJ_TRIGGER) {
	    for (c = world[obj_room((obj_data *) go)].people; c;
		 c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  else if (type == WLD_TRIGGER) {
	    for (c = ((struct room_data *) go)->people; c;
		 c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  if (rndm)
	    sprintf(str, "%c%ld", UID_CHAR, GET_ID(rndm));
	  else
	    *str = '\0';
	}
d1237 1
a1237 4
	else
	  sprintf(str, "%d", ((num = atoi(field)) > 0) ? number(1, num) : 0);
	
	return;
d1239 1
a1239 1
    }
d2717 4
@


1.40
log
@New fields for character dg variables: position and position1.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.39 2006/12/08 05:09:32 myc Exp myc $
d8 2
a9 2
 *  $Date: 2006/12/08 05:09:32 $                                           *
 *  $Revision: 1.39 $                                                      *
d2350 1
a2350 1
  char arg[MAX_INPUT_LENGTH], *var;
d2352 1
a2352 1
  var = any_one_arg(cmd, arg);
d2354 1
a2354 1
  skip_spaces(&var);
d2356 1
a2356 1
  if (!*var) {
a2360 4
  
  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;
d2362 12
a2373 5
  if (!vd) {
    sprintf(buf2, "Local var '%s' not found in global call", var);
    script_log(trig,buf2);
    return;
  }    
d2375 3
a2377 2
  add_var(&(sc->global_vars), vd->name, vd->value);
  remove_var(&GET_TRIG_VARS(trig), vd->name);
d2726 3
@


1.39
log
@Added new fields to actor variables, and sector field to room vars.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.38 2006/11/13 03:17:06 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2006/11/13 03:17:06 $                                           *
 *  $Revision: 1.38 $                                                      *
d53 1
d1640 24
d2722 3
@


1.38
log
@Fix memory leak in trig_wait_event.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.37 2006/11/07 10:44:13 jps Exp jps $
d8 2
a9 2
 *  $Date: 2006/11/07 10:44:13 $                                           *
 *  $Revision: 1.37 $                                                      *
d52 2
d1347 3
d1432 20
a1451 1
	sprintf(str, "%d", GET_CHA(c));
d1642 4
d1750 3
a1752 1
      } else {
d2697 3
@


1.37
log
@Trigger name, vnum, and rnum are displayed when using tstat.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.36 2004/11/01 06:02:01 jjl Exp $
d7 3
a9 3
 *  $Author: jjl $                                                         *
 *  $Date: 2004/11/01 06:02:01 $                                           *
 *  $Revision: 1.36 $                                                      *
d521 1
d2667 3
@


1.36
log
@Updating the buffer size for triggers
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.35 2003/07/29 01:42:11 jjl Exp $
d8 2
a9 2
 *  $Date: 2003/07/29 01:42:11 $                                           *
 *  $Revision: 1.35 $                                                      *
d553 1
a553 1
  sprintf(sb, "Name: '%s%s%s',  VNum: [%s%5d%s], RNum: [%5d]\r\n",
d557 1
d2666 3
@


1.35
log
@Fixing "while" in dg_scripts.  while only worked properly if it was the first thing on the
line.  (IE "while " works, but " while " wouldn't)
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.34 2003/07/13 23:04:45 jjl Exp $
d8 2
a9 2
 *  $Date: 2003/07/13 23:04:45 $                                           *
 *  $Revision: 1.34 $                                                      *
d545 1
a545 1
  char sb[MAX_STRING_LENGTH];
d2665 4
@


1.34
log
@Fixed a crash bug in the processing of %actor.class% for mobs.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.33 2003/07/12 05:45:35 jjl Exp $
d8 2
a9 2
 *  $Date: 2003/07/12 05:45:35 $                                           *
 *  $Revision: 1.33 $                                                      *
d2431 27
a2457 22
      if (cl->original && process_if(cl->original->cmd + 6, go, sc, trig,
				     type)) {
        cl = cl->original;
        temp = find_done(cl);
        loops++;   
        GET_TRIG_LOOPS(trig)++;
        if (loops == 30) {
          process_wait(go, trig, type, "wait 1", cl);
	  depth--;
          /* wtf? WHY would anyone free memory that was NOT allocated? Mud go BOOM!
          free(cmd);*/
          return ret_val;
        }
        if (GET_TRIG_LOOPS(trig) == 100) {
          char *buf = (char*)malloc(MAX_STRING_LENGTH);
          sprintf(buf,"SCRIPTERR: Trigger VNum %d has looped 100 times!!!",
		  GET_TRIG_VNUM(trig));
          mudlog(buf, NRM, LVL_GOD, TRUE);
          free(buf);
          /* kill the while loop */
          temp->original = NULL;
        }
d2665 3
@


1.33
log
@Better version of oshdesc, supports variable vnums.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.32 2003/07/10 03:56:57 jjl Exp $
d8 2
a9 2
 *  $Date: 2003/07/10 03:56:57 $                                           *
 *  $Revision: 1.32 $                                                      *
d51 2
d1322 6
a1327 1
	sprintf(str,"%s",strip_ansi(pc_class_types[(int)GET_CLASS(c)]));
d2660 3
@


1.32
log
@Added the "oshdesc" variable for getting object short descriptions.
Call it as %oshdesc.vnum% (IE %oshdesc.3011%)
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.31 2003/07/09 04:57:49 jjl Exp jjl $
d8 2
a9 2
 *  $Date: 2003/07/09 04:57:49 $                                           *
 *  $Revision: 1.31 $                                                      *
a1173 16
      
      else if (!str_cmp(var, "oshdesc")) {
        extern struct obj_data *obj_proto;
        struct obj_data* tobj;
        num = atoi(field);
        num = real_object(num);

        tobj = &obj_proto[num];
        if (tobj && tobj->short_description) {
          sprintf(str, "%s", tobj->short_description);
        }
        else {
          sprintf(str, "No description available.");
        }
        return;
      }
d1339 30
d2653 4
@


1.31
log
@Increased an internal buffer that was being overflowed by Zzur's armor
quest.
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.30 2002/09/19 01:07:53 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/19 01:07:53 $                                           *
 *  $Revision: 1.30 $                                                      *
d1175 16
d2639 4
@


1.30
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.29 2002/09/13 02:32:10 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/13 02:32:10 $                                           *
 *  $Revision: 1.29 $                                                      *
d1745 2
a1746 2
              char ix1[MAX_NAME_LENGTH];	/* no vars longer than 20 chars?*/
	      char ix2[MAX_NAME_LENGTH];
d2623 3
@


1.29
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_scripts.c,v 1.28 2002/05/08 00:30:06 dce Exp $
d7 3
a9 3
 *  $Author: dce $                                                         *
 *  $Date: 2002/05/08 00:30:06 $                                           *
 *  $Revision: 1.28 $                                                      *
d1407 44
a1455 1

d2623 3
@


1.28
log
@Fixed a stupid string error.
@
text
@d1 3
a3 1
// $Id: dg_scripts.c,v 1.27 2002/05/07 03:13:09 dce Exp $
d8 2
a9 2
 *  $Date: 2002/05/07 03:13:09 $                                           *
 *  $Revision: 1.27 $                                                      *
d2578 115
a2692 110
// $Log: dg_scripts.c,v $
// Revision 1.27  2002/05/07 03:13:09  dce
// Added a little error checking to the "exists" trigger
// code to prevent crashes.
// /s
//
// Revision 1.26  2002/05/06 23:54:04  dce
// Added three new features: exists, mexists[#], oexists[#]. The show
// the number currently in the game.
// /s
//
// Revision 1.25  2001/08/03 21:25:00  mtp
// reset trigger depth which is separate from script recursion depth, in the
// case that a mob is asleep when a new trigger kicks off and we return
// instantly
//
// Revision 1.24  2001/08/03 19:48:56  mtp
// missing depth-- which meant that gradully triggers got into recursed error
//
// Revision 1.23  2001/07/25 06:59:02  mtp
// modified logging to hopefully be a bit more helpful by specifying the
// trigger id wherever possible. This does not apply to logging of mob trigs yet
// as mobs use the same commands as players :-(
//
// Revision 1.22  2001/06/19 23:57:11  mtp
// improved logging for trigger recursion
//
//
// Revision 1.21  2001/02/12 01:26:52  mtp
// added 2 fields, groupnum (members in group)
// group[n] group member n
//
// Revision 1.20  2000/12/21 23:29:49  mtp
// added strip_ansi to actor.class and also removed trailing WS o to allow ==
// for class names
//
// Revision 1.19  2000/11/28 01:16:25  mtp
// replaced dg_event code with events.c code
//
// Revision 1.17  2000/11/21 04:13:38  rsd
// Altered the comment header and added old rlog messages
// from prior to the $log$ string. Also the $log$ string
// had been removed so the last 10 or so revisions weren't
// commented in the file.  I added the string back in hopes
// that it will continue to add the comments and included
// the missing rlog messages.
//
// Revision 1.16  2000/11/09 23:59:54  mtp
// added %actor.n% for he/she/it
//
// Revision 1.15  2000/11/07 01:53:34  mtp
// added some extra fields to do with subclasses and also .o, .p for
// him/her his/her stuff
//
// Revision 1.14  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.13  2000/10/30 18:32:35  mtp
// fix for tlist 
//
// Revision 1.12  2000/10/29 16:59:12  mtp
// added puase_while_casting to halt (well pause cos it restarts)
// trigger execution if mob is casting. This applies whether the cast is
// within the trigger or external to the trigger
//
// Revision 1.11  2000/10/27 00:34:45  mtp
// new fields in player structure for quest info
//
// Revision 1.10  2000/10/01 23:43:29  mtp
// added extra trigger code
// 1) can check players flags (flags 1,2,3) eg %plyr.flags[1,1]% returns true/false if player blind
// 2) can get players in a room eg %self.people[3]% gets the third person in room
// 3) extension to allow %self.people[%num%]% to get the %num%th person in room
// 
// note: the people[] call returns a player variable, so all fields are available
//
// Revision 1.9  2000/03/04 00:22:16  mtp
// added extra field for room object - vnum (will be mainly referenced by %self.vnum%)
//
// Revision 1.8  2000/02/17 07:32:27  mtp
// added %time% structure to show mud time and object.weight field
//
// Revision 1.7  2000/02/16 08:13:14  mtp
// fixed while loops (which couldhave been infinite and crashed after 30 loops anyhow)
// while loops are now killed after 100 loops
//
// Revision 1.6  2000/02/13 07:34:13  mtp
// fixed opurge/mpurge problems by not freeing the running trigger
// until it completes (set/unset running flag in dg_scripts.c and
// free trigger if purged flag set at end)
//
// Revision 1.5  2000/02/11 00:29:37  mtp
// another world[vnum] replaced by world[real_room(vnum)] *sigh*
//
// Revision 1.4  2000/02/02 22:54:25  mtp
// added new field to %actor% for %actor.worn[##]% which
// returns the vnum of the object that is worn there or -1 if none
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 01:57:43  mud
// Added info to the comment header
// Indented file
//
// Revision 1.1  1999/01/29 01:23:30 mud
// Initial revision
//
@


1.27
log
@Added a little error checking to the "exists" trigger
code to prevent crashes.
/s
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.26 2002/05/06 23:54:04 dce Exp $
d6 2
a7 2
 *  $Date: 2002/05/06 23:54:04 $                                           *
 *  $Revision: 1.26 $                                                      *
d1343 13
a1355 3
        char throw1[15];
        sscanf(field,"%8s%d%s",throw1,&n,buf);
        if ((x = real_object(n)) >= 0) {
d1365 13
a1377 3
        char throw1[15];
        sscanf(field,"%8s%d%s",throw1,&n,buf);
        if ((x = real_mobile(n)) >= 0) {
d2577 5
@


1.26
log
@Added three new features: exists, mexists[#], oexists[#]. The show
the number currently in the game.
/s
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.25 2001/08/03 21:25:00 mtp Exp $
d5 3
a7 3
 *  $Author: mtp $                                                         *
 *  $Date: 2001/08/03 21:25:00 $                                           *
 *  $Revision: 1.25 $                                                      *
d1341 1
a1341 1
	int n;
d1345 7
a1351 4
        objex = read_object(real_object(n),REAL);
    	sprintf(str, "%d", obj_index[GET_OBJ_RNUM(objex)].number - 1);
        extract_obj(objex);
 
d1353 1
a1353 1
	int n;
d1357 7
a1363 4
        mobex = read_mobile(real_mobile(n),REAL);
	sprintf(str, "%d", mob_index[GET_MOB_RNUM(mobex)].number - 1);
        char_to_room(mobex, 0);
        extract_char(mobex);
d2557 5
@


1.25
log
@reset trigger depth which is separate from script recursion depth, in the
case that a mob is asleep when a new trigger kicks off and we return
instantly
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.24 2001/08/03 19:48:56 mtp Exp mtp $
d6 2
a7 2
 *  $Date: 2001/08/03 19:48:56 $                                           *
 *  $Revision: 1.24 $                                                      *
d1337 23
a1359 1
      else if (!str_cmp(field, "cha"))
d1527 3
d2551 5
@


1.24
log
@missing depth-- which meant that gradully triggers got into recursed error
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.23 2001/07/25 06:59:02 mtp Exp mtp $
d6 2
a7 2
 *  $Date: 2001/07/25 06:59:02 $                                           *
 *  $Revision: 1.23 $                                                      *
d2257 2
d2526 3
@


1.23
log
@modified logging to hopefully be a bit more helpful by specifying the
trigger id wherever possible. This does not apply to logging of mob trigs yet
as mobs use the same commands as players :-(
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.21 2001/02/12 01:26:52 mtp Exp $
d6 2
a7 2
 *  $Date: 2001/02/12 01:26:52 $                                           *
 *  $Revision: 1.21 $                                                      *
d2255 2
d2258 1
d2524 5
@


1.22
log
@improved logging for trigger recursion
@
text
@d69 2
a70 2
int trgvar_in_room(int vnum);
void script_log(char *msg);
d118 1
a118 1
int trgvar_in_room(int vnum) {
d123 1
a123 1
    script_log("people.vnum: world[vnum] does not exist");
d1075 1
a1075 1
void script_log(char *msg)
d1079 4
a1082 1
  sprintf(buf,"SCRIPT ERR: %s", msg);
d1174 1
a1174 1
	sprintf(str,"%d",((num = atoi(field)) > 0) ? trgvar_in_room(num) : 0);	
d1488 2
a1489 4
	sprintf(buf2, 
		"Trigger: %s, VNum %d. unknown char field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), field);
	script_log(buf2);
d1522 2
a1523 4
	sprintf(buf2,
		"Trigger: %s, VNum %d, type: %d. unknown object field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
d1571 3
a1573 3
		"Trigger: %s, VNum %d, type: %d. bad access of 'people' array: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
		script_log(buf2);
d1590 3
a1592 3
		"Trigger: %s, VNum %d, type: %d. unknown room field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
d2025 2
a2026 3
    sprintf(buf2, "Trigger: %s, VNum %d. wait w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cl->cmd);
    script_log(buf2);
d2080 2
a2081 3
    sprintf(buf2, "Trigger: %s, VNum %d. set w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
d2101 2
a2102 3
    sprintf(buf2, "Trigger: %s, VNum %d. eval w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
d2122 2
a2123 3
    sprintf(buf2, "Trigger: %s, VNum %d. return w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
d2144 2
a2145 3
    sprintf(buf2, "Trigger: %s, VNum %d. unset w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
d2167 2
a2168 3
    sprintf(buf2, "Trigger: %s, VNum %d. global w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
d2177 2
a2178 3
    sprintf(buf2, "Trigger: %s, VNum %d. local var '%s' not found in global call",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), var);
    script_log(buf2);
d2201 2
a2202 2
  void obj_command_interpreter(obj_data *obj, char *argument);
  void wld_command_interpreter(struct room_data *room, char *argument);
d2216 1
a2216 1
    script_log(buf);
d2357 1
a2357 1
	  obj_command_interpreter((obj_data *) go, cmd);
d2360 1
a2360 1
	  wld_command_interpreter((struct room_data *) go, cmd);
d2403 1
a2403 1
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
d2521 4
@


1.21
log
@added 2 fields, groupnum (members in group)
group[n] group member n
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.20 2000/12/21 23:29:49 mtp Exp $
d6 2
a7 2
 *  $Date: 2000/12/21 23:29:49 $                                           *
 *  $Revision: 1.20 $                                                      *
d2213 12
a2224 1
    script_log("Triggers recursed beyond maximum allowed depth.");
d2529 4
@


1.20
log
@added strip_ansi to actor.class and also removed trailing WS o to allow ==
for class names
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.19 2000/11/28 01:16:25 mtp Exp mtp $
d6 2
a7 2
 *  $Date: 2000/11/28 01:16:25 $                                           *
 *  $Revision: 1.19 $                                                      *
d1419 51
d2518 4
@


1.19
log
@replaced dg_event code with events.c code
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.17 2000/11/21 04:13:38 rsd Exp $
d5 3
a7 3
 *  $Author: rsd $                                                         *
 *  $Date: 2000/11/21 04:13:38 $                                           *
 *  $Revision: 1.17 $                                                      *
d1313 12
a1324 1
	sprinttype(GET_CLASS(c), pc_class_types, str);
d2467 3
@


1.18
log
@hopefully a bug fix for intermittent crash bug where num char
requested in a people[] array not same as um bpeople in room
(probably cos some1 walked out) looks like it was a typioo previously
@
text
@d26 1
a26 1
#include "dg_event.h"
d505 1
a505 1
EVENT(trig_wait_event)
d507 1
a507 1
  struct wait_event_data *wait_event_obj = (struct wait_event_data *)info;
a515 1
  free(wait_event_obj);  
d519 1
d533 1
a533 1
  GET_TRIG_WAIT(trig) = add_event(time, trig_wait_event, wait_event_obj);
d2005 1
a2005 1
  GET_TRIG_WAIT(trig) = add_event(time, trig_wait_event, wait_event_obj);
d2187 1
a2187 1
    if (type == MOB_TRIGGER && !(sc->types & MTRIG_DEATH))	/* only death trigs are immune to all tests*/
@


1.17
log
@Altered the comment header and added old rlog messages
from prior to the $log$ string. Also the $log$ string
had been removed so the last 10 or so revisions weren't
commented in the file.  I added the string back in hopes
that it will continue to add the comments and included
the missing rlog messages.
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.16 2000/11/09 23:59:54 mtp Exp $
d5 3
a7 3
 *  $Author: mtp $                                                         *
 *  $Date: 2000/11/09 23:59:54 $                                           *
 *  $Revision: 1.16 $                                                      *
d1521 2
a1522 2

	        sprintf(str, "%c%ld", UID_CHAR, GET_ID(ch));
d2455 9
a2463 1
// $Log:$
@


1.16
log
@added %actor.n% for he./she/it
@
text
@d1 15
a15 10
// $Id: dg_scripts.c,v 1.13 2000/10/30 18:32:35 mtp Exp $
/**************************************************************************
 *  File: dg_scripts.c                               NOW Part of FieryMUD *
 *  Usage: contains general functions for using scripts.                  *
 *                                                                        *
 *  By: Someone of HubisMUD maybe                                         *
 *  $Author: mtp $                                                        *
 *  $Date: 2000/10/30 18:32:35 $                                          *
 *  $Revision: 1.13 $                                                      *
 **************************************************************************/
a32 1

d2454 39
d2508 10
@


1.15
log
@added some extra fields to do with subclasses and also .o, .p for
him/her his/her stuff
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.14 2000/11/03 17:28:33 jimmy Exp mtp $
d7 3
a9 3
 *  $Author: jimmy $                                                        *
 *  $Date: 2000/11/03 17:28:33 $                                          *
 *  $Revision: 1.14 $                                                      *
d1267 15
@


1.14
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.13 2000/10/30 18:32:35 mtp Exp $
d7 3
a9 3
 *  $Author: mtp $                                                        *
 *  $Date: 2000/10/30 18:32:35 $                                          *
 *  $Revision: 1.13 $                                                      *
d24 1
a60 3
int quest_stage(char *qname,struct char_data *ch);
int has_failed_quest(char *qname,struct char_data *ch);
int has_completed_quest(char *qname,struct char_data *ch);
d1089 2
a1090 1
  int num, count, wear, rnum;
d1240 30
d1315 2
a1316 2
        char throw1[8],throw2[3];
        sscanf(field,"%6s%d,%ld%s",throw1,&n,&i,throw2);
d1326 4
a1329 1
	      char throw1[14],throw2[3],qname[32];
d1334 9
a1342 2

	      	sscanf(field,"%12s %s %s",throw1,qname,throw2);
d1348 3
a1350 1
	      char throw1[16],throw2[3],qname[32];
d1356 9
a1364 1
	      	sscanf(field,"%14s %s %s",throw1,qname,throw2);
d1370 3
a1372 1
	      char throw1[13],throw2[3],qname[32];
d1377 9
a1385 1
	      	sscanf(field,"%11s %s %s",throw1,qname,throw2);
d1395 2
a1396 2
        char throw1[8],throw2[3];
        sscanf(field,"%5s%d%s",throw1,&i,throw2);
d1498 1
a1498 5
		if( (rnum = real_room(r->number)) == NOWHERE ) {
		  log("SYSERR:dg_scripts.c:find_replacement():Invalid room of NOWEHRE");
		  return;
		}
 		for (ch = world[rnum].people; i && ch !=NULL; ch = ch->next_in_room)
@


1.13
log
@fix for tlist
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.9 2000/03/04 00:22:16 mtp Exp $
d8 2
a9 2
 *  $Date: 2000/03/04 00:22:16 $                                          *
 *  $Revision: 1.9 $                                                      *
d1091 1
a1091 1
  int num, count, wear;
d1439 5
a1443 1
 		for (ch = world[real_room(r->number)].people; i && ch !=NULL; ch = ch->next_in_room)
@


1.12
log
@added puase_while_casting to halt (well pause cos it restarts)
trigger execution if mob is casting. This applies whether the cast is
within the trigger ofr external to the trigger
@
text
@d2269 1
a2269 1
  for (nr = 0; nr < top_of_trigt && (trig_index[nr]->virtual <= last); nr++)
d2271 1
a2271 1
      if (trig_index[nr]->virtual >= first) {
@


1.11
log
@new fields in player structure for quest info
@
text
@a459 2


d519 15
d1926 1
d2095 1
a2095 1
  
d2108 13
@


1.10
log
@added extra trigger code
1) can check players flags (flags 1,2,3) eg %plyr.flags[1,1]% returns true/false if player blind
2) can get players in a room eg %self.people[3]% gets the third person in room
3) extension to allow %self.people[%num%]% to get the %num%th person in room

note: the people[] call returns a player variable, so all fields are available
@
text
@d60 3
d1281 35
@


1.9
log
@added extra field for room object - vnum (will be mainly referenced by %self.vnum%)
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.8 2000/02/17 07:32:27 mtp Exp mtp $
d8 2
a9 2
 *  $Date: 2000/02/17 07:32:27 $                                          *
 *  $Revision: 1.8 $                                                      *
d70 2
d1262 17
d1372 25
d1448 1
d1457 17
@


1.8
log
@added %time% structure to show mud time and object.weight field
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d7 3
a9 3
 *  $Author: jimmy $                                                        *
 *  $Date: 1999/09/05 07:00:39 $                                          *
 *  $Revision: 1.3 $                                                      *
d1321 2
@


1.7
log
@fixed while loops (which couldhave been infinite and crashed after 30 loops anyhow)
while loops are now killed after 100 loops
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.6 2000/02/13 07:34:13 mtp Exp mtp $
d7 3
a9 3
 *  $Author: mtp $                                                        *
 *  $Date: 2000/02/13 07:34:13 $                                          *
 *  $Revision: 1.6 $                                                      *
d49 1
a49 1
void trig_data_free(trig_data * this);
d1074 1
d1153 15
d1286 2
d1989 2
a1990 2
    /* no point continuing if mob/obj has zapped itself*/
    if (trig->purged)
d2024 1
a2024 1
        temp = find_done(cl); /*in case we have to kill it..*/
d2040 1
a2040 1
          /* kill the while loop, this has gotta be an error!*/
d2093 1
a2093 1
  trig->running=FALSE;
d2247 4
a2250 2

// $Log: dg_scripts.c,v $
a2261 3
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
@


1.6
log
@fixed opurge/mpurge problems by not freeing the running trigger
until it completes (set/unset running flag in dg_scripts.c and
free trigger if purged flag set at end)
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.5 2000/02/11 00:29:37 mtp Exp mtp $
d8 2
a9 2
 *  $Date: 2000/02/11 00:29:37 $                                          *
 *  $Revision: 1.5 $                                                      *
d2006 1
d2012 2
a2013 1
          free(cmd);
d2021 3
a2023 2
          // wtf? WHY would anyone free memory that was NOT allocated? Mud go BOOM!
          //free(buf);
d2231 5
@


1.5
log
@another world[vnum] replaced by world[real_room(vnum)] *sigh*
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.4 2000/02/02 22:54:25 mtp Exp mtp $
d8 2
a9 2
 *  $Date: 2000/02/02 22:54:25 $                                          *
 *  $Revision: 1.4 $                                                      *
d49 1
d1962 1
d1971 3
d2072 1
d2074 8
a2081 3
  free_varlist(GET_TRIG_VARS(trig));
  GET_TRIG_VARS(trig) = NULL;
  GET_TRIG_DEPTH(trig) = 0;
d2228 3
@


1.4
log
@added new field to %actor% for %actor.worn[##]% which
returns the vnum of the object that is worn there or -1 if none
@
text
@d1 1
a1 1
// $Id: dg_scripts.c,v 1.3 1999/09/05 07:00:39 jimmy Exp mtp $
d7 3
a9 3
 *  $Author: jimmy $                                                        *
 *  $Date: 1999/09/05 07:00:39 $                                          *
 *  $Revision: 1.3 $                                                      *
d119 1
a119 1
  for (ch = world[vnum].people; ch !=NULL; ch = ch->next_in_room)
d2217 4
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d7 3
a9 3
 *  $Author: mud $                                                        *
 *  $Date: 1999/01/31 01:57:43 $                                          *
 *  $Revision: 1.2 $                                                      *
d1243 10
d2216 4
a2219 1
// $Log$
@


1.2
log
@Added info to the comment header
Indented file
@
text
@d1 1
d8 2
a9 2
 *  $Date: 1999/01/29 01:23:30 $                                          *
 *  $Revision: 1.1 $                                                      *
d2206 1
@


1.1
log
@Initial revision
@
text
@d2 8
a9 8
*  File: scripts.c                                                        *
*  Usage: contains general functions for using scripts.                   *
*                                                                         *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/24 03:48:42 $
*  $Revision: 3.25 $
**************************************************************************/
a13 1
 
d66 1
a66 1
  find_case(struct trig_data *trig, struct cmdlist_element *cl, \
d84 1
a84 1

d87 1
a87 1

d90 1
a90 1

d93 1
a93 1
 
d95 1
a95 1
 
d100 1
a100 1

d104 1
a104 1

d110 12
a121 12
    int i = 0;
    char_data *ch;

    if (NOWHERE == real_room(vnum)) {
	script_log("people.vnum: world[vnum] does not exist");
	return (-1);
    }

    for (ch = world[vnum].people; ch !=NULL; ch = ch->next_in_room)
	i++;

    return i;
d126 4
a129 4
    obj_data *i;
    long id;
    
    if (*name == UID_CHAR)
d131 5
a135 5
        id = atoi(name + 1);
     
        for (i = list; i; i = i->next_content)
            if (id == GET_ID(i))
                return i;
d137 1
a137 1
    else
d139 3
a141 3
        for (i = list; i; i = i->next_content)
            if (isname(name, i->name))
                return i;
d143 2
a144 2
        
    return NULL;
d149 16
a164 16
    int j, n = 0, number;
    obj_data *obj;
    char tmpname[MAX_INPUT_LENGTH];
    char *tmp = tmpname; 
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
            
        for (j = 0; j < NUM_WEARS; j++)
            if ((obj = GET_EQ(ch, j)))
                if (id == GET_ID(obj)){
		    (*i) = j;
                    return (obj);
		}
d166 1
a166 1
    else
d168 11
a178 11
        strcpy(tmp, name);
        if (!(number = get_number(&tmp)))
            return NULL;

        for (j = 0; (j < NUM_WEARS) && (n <= number); j++)
            if ((obj = GET_EQ(ch, j)))
                if (isname(tmp, obj->name))
                    if (++n == number) {
			(*i) = j;
                        return (obj);
		    }
d180 2
a181 2
    
    return NULL;
d185 1
a185 1
 * search by number routines
d192 1
a192 1

d194 4
a197 4
  {
    if (GET_ID(ch)==n) return (ch);
  }
 
d205 7
a211 7
    obj_data *i;
    
    for (i = object_list; i; i = i->next)
        if (n == GET_ID(i))
            return i;
 
    return NULL;
d217 6
a222 6
    n -= ROOM_ID_BASE;
    
    if ((n >= 0) && (n <= top_of_world))
        return &world[n];

    return NULL;
d228 1
a228 1
 * generic searches based only on name
d234 3
a236 3
    char_data *i;

    if (*name == UID_CHAR)
d238 4
a241 4
        i = find_char(atoi(name + 1));

        if (i && !GET_INVIS_LEV(i))
            return i;
d243 1
a243 1
    else
d245 4
a248 4
        for (i = character_list; i; i = i->next)
            if (isname(name, i->player.name) &&
                !GET_INVIS_LEV(i))
                return i;
d250 2
a251 2

    return NULL;
d258 4
a261 4
    obj_data *obj;
    long id;
    
    if (*name == UID_CHAR)
d263 5
a267 5
        id = atoi(name + 1);
        
        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
d269 1
a269 1
    else
d271 3
a273 3
        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
d275 3
a278 3
    return NULL;
}
 
d283 8
a290 8
    int nr; 

    if (*name == UID_CHAR)
        return find_room(atoi(name + 1));
    else if ((nr = real_room(atoi(name))) == NOWHERE)
        return NULL;
    else
        return &world[nr];
d300 3
a302 3
    char_data *ch;

    if (*name == UID_CHAR)
d304 4
a307 4
        ch = find_char(atoi(name + 1));
            
        if (ch && !GET_INVIS_LEV(ch))
            return ch;
d309 1
a309 1
    else
d311 14
a324 14
        if (obj->carried_by &&
            isname(name, obj->carried_by->player.name) &&
            !GET_INVIS_LEV(obj->carried_by))
            return obj->carried_by;
     
        if (obj->worn_by &&
            isname(name, obj->worn_by->player.name) &&
            !GET_INVIS_LEV(obj->worn_by))
            return obj->worn_by;
     
        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;
d326 2
a327 2
        
    return NULL;
d329 2
a330 2
            
                
d337 3
a339 3
    char_data *ch;

    if (*name == UID_CHAR)
d341 4
a344 4
        ch = find_char(atoi(name + 1));
 
        if (ch && !GET_INVIS_LEV(ch))
            return ch;
d346 1
a346 1
    else
d348 9
a356 9
        for (ch = room->people; ch; ch = ch->next_in_room)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;
        
        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                !GET_INVIS_LEV(ch))
                return ch;
d358 2
a359 2
            
    return NULL;
d369 11
a379 11
    obj_data *i = NULL;  
    int rm, wear;
    long id;

    if (!str_cmp(name, "self") || !str_cmp(name, "me"))
        return obj;
    
    if (obj->contains && (i = get_obj_in_list(name, obj->contains)))
        return i;
    
    if (obj->in_obj)
d381 1
a381 1
        if (*name == UID_CHAR)
d383 4
a386 4
            id = atoi(name + 1);
        
            if (id == GET_ID(obj->in_obj))
                return obj->in_obj;
d388 2
a389 2
        else if (isname(name, obj->in_obj->name))
            return obj->in_obj;
d391 11
a401 11
     
    else if (obj->worn_by && (i = get_object_in_equip(obj->worn_by, name, &wear)))
        return i;
    else if (obj->carried_by &&
             (i = get_obj_in_list(name, obj->carried_by->carrying)))
        return i;
    else if (((rm = obj_room(obj)) != NOWHERE) &&
             (i = get_obj_in_list(name, world[rm].contents)))
        return i;
                        
    if (*name == UID_CHAR)
d403 5
a407 5
        id = atoi(name + 1);
 
        for (i = object_list; i; i = i->next)
            if (id == GET_ID(i))
                break;
d409 2
a410 2

    else
d412 3
a414 3
        for (i = object_list; i; i = i->next)
            if (isname(name, i->name))
                break;
d416 3
a419 2
    return i;
}   
a420 1
        
d424 14
a437 14
    obj_data *obj;
    long id;
     
    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
        
        for (obj = room->contents; obj; obj = obj->next_content)
            if (id == GET_ID(obj)) 
                return obj;
        
        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
d439 1
a439 1
    else
d441 7
a447 7
        for (obj = room->contents; obj; obj = obj->next_content)
            if (isname(name, obj->name))
                return obj;
             
        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
d449 2
a450 2
        
    return NULL;
d467 1
a467 1

d478 1
a478 1

d483 1
a483 1

d511 1
a511 1

d518 4
a521 4
    struct cmdlist_element *cmd_list;
    char sb[MAX_STRING_LENGTH];

    if (!trig)
d523 2
a524 2
	log("SYSERR: NULL trigger passed to do_stat_trigger.");
	return;
d526 26
a551 26

    sprintf(sb, "Name: '%s%s%s',  VNum: [%s%5d%s], RNum: [%5d]\r\n",
	      CCYEL(ch, C_NRM), GET_TRIG_NAME(trig), CCNRM(ch, C_NRM),
	      CCGRN(ch, C_NRM), GET_TRIG_VNUM(trig), CCNRM(ch, C_NRM),
	      GET_TRIG_RNUM(trig));

    if (trig->attach_type==OBJ_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), otrig_types, buf);
    } else if (trig->attach_type==WLD_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), wtrig_types, buf);
    } else {
      send_to_char("Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), trig_types, buf);
    }
    
    sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
	      buf, GET_TRIG_NARG(trig), 
	      ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig))
	       ? GET_TRIG_ARG(trig) : "None"));

    strcat(sb,"Commands:\r\n   ");

    cmd_list = trig->cmdlist;
    while (cmd_list)
d553 1
a553 1
	if (cmd_list->cmd)
d555 2
a556 2
	    strcat(sb,cmd_list->cmd);
	    strcat(sb,"\r\n   ");
d558 2
a559 2

	cmd_list = cmd_list->next;
d561 2
a562 2

    page_string(ch->desc, sb, 1);
d571 1
a571 1

d587 1
a587 1

d590 1
a590 1

d599 1
a599 1

d606 1
a606 1

d632 1
a632 1

d650 1
a650 1

d656 1
a656 1

d668 1
a668 1

d693 1
a693 1

d695 1
a695 1

d697 1
a697 1
          t->next = TRIGGERS(sc);
d705 1
a705 1

d707 1
a707 1

d721 2
a722 2


d725 1
a725 1

d739 1
a739 1
       rn = real_trigger(tn);
d741 1
a741 1

d756 1
a756 1

d759 1
a759 1
	
d764 9
a772 9
	  if (!SCRIPT(object))
	    CREATE(SCRIPT(object), struct script_data, 1);
	  add_trigger(SCRIPT(object), trig, loc);
	  
	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig), 
		  (object->short_description ?
		   object->short_description : object->name));
	  send_to_char(buf, ch);
d778 1
a778 1

d786 1
a786 1

d800 1
a800 1

d810 1
a810 1

d812 1
a812 1

d818 1
a818 1

d848 1
a848 1
        
d868 1
a868 1
        
d872 1
a872 1
      
d878 1
a878 1
  
d884 1
a884 1
 
d889 1
a889 1
 
d912 1
a912 1
     
d922 1
a922 1
     
d932 1
a932 1
    
d942 1
a942 1
   
d960 1
a960 1
    
d963 1
a963 1
      
d967 1
a967 1
     
d976 1
a976 1
   
d986 1
a986 1
     
d990 1
a990 1
        
d999 1
a999 1
       
d1029 1
a1029 1

d1032 1
a1032 1

d1041 1
a1041 1

d1056 1
a1056 1

d1072 1
a1072 1

d1081 1
a1081 1

d1091 1
a1091 1

d1094 1
a1094 1

d1098 1
a1098 1

d1102 1
a1102 1

d1110 1
a1110 1

d1205 1
a1205 1

d1208 1
a1208 1

d1253 1
a1253 1

d1343 1
a1343 1

d1382 1
a1382 1

d1401 1
a1401 1

d1415 1
a1415 1

d1426 1
a1426 1

d1442 1
a1442 1

d1496 1
a1496 1

d1519 1
a1519 1

d1522 1
a1522 1

d1533 1
a1533 1

d1542 1
a1542 1

d1552 1
a1552 1

d1557 1
a1557 1

d1564 1
a1564 1

d1602 1
a1602 1

d1604 1
a1604 1

d1627 1
a1627 1

d1631 1
a1631 1

d1634 1
a1634 1

d1667 1
a1667 1

d1670 1
a1670 1

d1673 1
a1673 1

d1694 1
a1694 1

d1697 1
a1697 1

d1700 1
a1700 1

d1703 1
a1703 1

d1715 1
a1715 1

d1719 1
a1719 1

d1732 1
a1732 1

d1735 2
a1736 2


d1745 1
a1745 1

d1747 1
a1747 1

d1753 1
a1753 1

d1756 1
a1756 1

d1766 1
a1766 1

d1775 1
a1775 1

d1780 1
a1780 1

d1792 1
a1792 1

d1794 1
a1794 1

d1801 1
a1801 1

d1803 1
a1803 1

d1808 1
a1808 1
		 int type, char *cmd)
d1814 1
a1814 1

d1816 1
a1816 1

d1823 1
a1823 1

d1845 1
a1845 1

d1857 1
a1857 1

d1859 1
a1859 1

d1861 1
a1861 1

d1868 1
a1868 1

d1881 1
a1881 1

d1883 1
a1883 1

d1892 1
a1892 1

d1925 1
a1925 1

d1930 1
a1930 1

d1932 1
a1932 1

d1959 1
a1959 1

d1962 1
a1962 1

d1977 1
a1977 1
         temp->original = cl;
d1979 2
a1980 2
         cl = temp;
         loops = 0;
d1988 1
a1988 1
          type)) {
d1994 1
a1994 1
           depth--;
d2001 1
a2001 1
            GET_TRIG_VNUM(trig));
d2010 1
a2010 1
       /* Do nothing, this allows multiple cases to a single instance */
d2013 1
a2013 1
      
d2017 1
a2017 1

d2041 1
a2041 1

d2056 1
a2056 1

d2060 1
a2060 1

d2067 1
a2067 1

d2070 1
a2070 1

d2072 1
a2072 1

d2074 1
a2074 1

d2079 1
a2079 1

d2086 1
a2086 1

d2091 1
a2091 1

d2096 1
a2096 1

d2098 7
a2104 6
  {
    if (trig_index[nr]->virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              trig_index[nr]->virtual,
              trig_index[nr]->proto->name);
      strcat(pagebuf, buf);
d2106 1
a2106 2
  }

d2115 1
a2115 1

d2117 4
a2120 4
  {
    if (trig_index[rnum]->virtual==vnum) break;
  }

d2129 1
a2129 1

d2138 1
a2138 1

d2144 4
a2147 4
* scans for a case/default instance
* returns the line containg the correct case instance, or the last
* line of the trigger if not found.
*/
d2154 1
a2154 1

d2157 1
a2157 1
        
d2160 1
a2160 1
      
d2174 1
a2174 1
     return c;
d2178 1
a2178 1
       
d2180 4
a2183 4
* scans for end of while/switch-blocks.   
* returns the line containg 'end', or the last
* line of the trigger if not found.     
*/
d2192 1
a2192 1

d2195 1
a2195 1

d2201 1
a2201 1
    
@
