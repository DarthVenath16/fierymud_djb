head	1.109;
access;
symbols;
locks; strict;
comment	@ * @;


1.109
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.108;

1.108
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.107;

1.107
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.106;

1.106
date	2009.03.09.02.22.32;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2009.02.16.14.21.04;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.29.05.09.54;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2008.09.22.03.05.12;	author jps;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.11.03.35.46;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2008.09.08.05.24.50;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2008.09.01.22.25.28;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2008.08.31.23.34.20;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2008.08.31.21.44.03;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.08.19.01.58.21;	author jps;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.17.20.46.21;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.88;

1.88
date	2008.07.27.05.31.17;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2008.07.27.01.33.38;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2008.07.26.22.52.11;	author jps;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.26.21.49.53;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2008.07.26.21.34.33;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2008.07.22.06.12.17;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.13.19.04.52;	author jps;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.10.20.38.02;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2008.07.10.20.17.37;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.21.08.53.09;	author myc;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.08.03.21.58;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.08.00.58.04;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.07.19.35.39;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.07.18.52.13;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.07.18.48.21;	author myc;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.07.18.45.39;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.26.18.24.48;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.13.03.41.34;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2008.03.30.17.28.57;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2008.03.30.17.10.47;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.28.16.48.23;	author myc;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.27.18.38.54;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.27.17.26.40;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.22.17.11.38;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.22.16.29.49;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.16.07.21.39;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.15.04.49.36;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.15.04.44.04;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.15.04.38.56;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2008.03.11.04.33.11;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.27.21.14.59;	author myc;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.09.13.04.40;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.05.05.38.00;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.01.04.34.25;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.19.20.55.20;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.03.19.02.24;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.22.17.56.19;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.15.06.21.32;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.31.14.38.03;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.20.21.21.55;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.18.18.55.09;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.20.03.49.20;	author jjl;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.04.12.14.48;	author mtp;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.06.15.01.47;	author dce;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.24.19.49.45;	author dce;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.07.03.14.28;	author dce;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.04.23.12.52;	author mtp;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.22.01.34.00;	author mtp;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.26.20.28.31;	author mtp;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.24.19.17.01;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.15.00.42.44;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.03.05.37.17;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.01.00.21.15;	author mtp;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.31.22.26.42;	author mtp;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.31.21.09.45;	author mtp;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.12.21.15.55;	author cmc;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.12.21.13.53;	author cmc;	state Exp;
branches;
next	1.13;

1.13
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.12;

1.12
date	99.09.04.22.13.11;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	99.09.04.18.46.52;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.08.13.15.31.01;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	99.05.04.18.03.09;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.03.03.20.11.02;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.03.01.05.31.34;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.06.02.25.31;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.05.07.47.42;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.21.57.39;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: objsave.c                                     Part of CircleMUD *
*  Usage: loading/saving player objects for rent and crash-save           *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "spells.h"

/* these factors should be unique integers */
#define RENT_FACTOR 	1
#define CRYO_FACTOR 	4

extern struct str_app_type str_app[];
extern struct room_data *world;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
extern int min_rent_cost;

/* Extern functions */
ACMD(do_tell);
SPECIAL(receptionist);
SPECIAL(cryogenicist);




void boot_obj_limit();
extern int top_of_objt;


/********************************************************\
Object limitation functions, by Proky for Hubis.

Creates a array of however many items there are in boot, which is
left there for whole of game.  When a item is loaded through zedit
Then this array will be increased by a value to stop loads after that.
It does mean that if a item is purged or lost in some way it wont repop
this could be fixed with further checks for destroying a item latter on.
The main effect of this code is through reset zone in db.c.

- It loops through playerfile to read objects initially.
*/


void boot_obj_limit()
{
	struct char_file_u chara;
    FILE *pfptr;
	FILE *fl;
	char fnamecheck[MAX_INPUT_LENGTH];
	char fname[MAX_INPUT_LENGTH];
	struct obj_file_elem object;
	struct rent_info rent;/*basically used just to absorbe some data*/
	struct obj_data *obj;

/*loop through player list reading there eq files*/
/*General check that player file present etcetc*/
   if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
    {
        if (errno != ENOENT)
        {
            perror("fatal error opening playerfile");
            exit(1);
        }
        else
        {
            log("No playerfile.  Creating a new one.");
            touch(PLAYER_FILE);
            if (!(pfptr = fopen(PLAYER_FILE, "r+b")))
            {
	            perror("fatal error opening playerfile");
	            exit(1);
            }
        }
	}
	rewind(pfptr);
	/*actual loop through player list*/
    while (!feof(pfptr))
    {/*loops through playerfile now its open and all is well*/
        fread(&chara , sizeof(struct char_file_u), 1, pfptr);
		/*chara.name is the name string*/
	if (!(str_cmp(fnamecheck, chara.name)))
			continue;
		strcpy(fnamecheck, chara.name);
		if (chara.char_specials_saved.act & PLR_DELETED)
		    continue;

		if (chara.level >= LVL_IMMORT)
			continue;
		if (!get_filename(chara.name, fname, CRASH_FILE))
			continue;

		if (!(fl = fopen(fname, "rb")))
			continue;

		if (!feof(fl))
				fread(&rent, sizeof(struct rent_info), 1, fl);

		while (!feof(fl))/*main object limit loop*/
		{
			fread(&object, sizeof(struct obj_file_elem), 1, fl);
			if (ferror(fl))
			{
				fclose(fl);
				mudlog("Error reading object file", CMP, LVL_GOD, TRUE);
				continue;
			}
			if (!feof(fl))
				if (real_object(object.item_number) > -1)
				{/*if over 50 k items forget it ! */
					/*check that item NOT over the max items this boot*/
					/*ie check incase real_obj failed*/
				obj = read_object(object.item_number, VIRTUAL);
					if (GET_OBJ_RNUM(obj) <= top_of_objt)
						if (OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj)) < 50000)
							OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj))++;
					extract_obj(obj);
				}
		}
		fclose(fl);
	}

}

/*****************END OF OBJECT LIMIT CODE*********************/


struct obj_data *Obj_from_store_to(struct obj_file_elem object, int *locate)
{
  struct obj_data *obj;
  int j;

  if (real_object(object.item_number) > -1) {
    obj = read_object(object.item_number, VIRTUAL);
	*locate = (int) object.locate;
    GET_OBJ_VAL(obj, 0) = object.value[0];
    GET_OBJ_VAL(obj, 1) = object.value[1];
    GET_OBJ_VAL(obj, 2) = object.value[2];
    GET_OBJ_VAL(obj, 3) = object.value[3];
    GET_OBJ_EXTRA(obj) = object.extra_flags;
    GET_OBJ_WEIGHT(obj) = object.weight;
    GET_OBJ_TIMER(obj) = object.timer;
    obj->obj_flags.bitvector = object.bitvector;

    if(*(object.PSE_Desc) == '1')
    {
       CREATE(obj->ex_description, struct extra_descr_data, 1);
       memset(obj->ex_description, 0x0, sizeof(struct extra_descr_data));
       obj->ex_description->keyword = (char *) malloc(strlen("PSE")+1);
       if(obj->ex_description->keyword)
         strcpy(obj->ex_description->keyword, "PSE");

       obj->ex_description->description = (char *) malloc(128);
       if(obj->ex_description->description)
         strncpy(obj->ex_description->description, object.PSE_Desc + 1, 128);
    }

    for (j = 0; j < MAX_OBJ_AFFECT; j++)
      obj->affected[j] = object.affected[j];

    return obj;
  } else
    return NULL;
}


 /* this function used in house.c */
 struct obj_data *Obj_from_store(struct obj_file_elem object)
 {
   int locate;

   return Obj_from_store_to(object, &locate);
 }



int Obj_to_store_from(struct obj_data * obj, FILE * fl, int locate)
/*int Obj_to_store(struct obj_data * obj, FILE * fl)*/
{
  int j;
  struct obj_file_elem object;
  struct extra_descr_data *tmpdesc;

  object.item_number = GET_OBJ_VNUM(obj);
  object.locate = (int) locate; /* where worn or inventory? */
  object.value[0] = GET_OBJ_VAL(obj, 0);
  object.value[1] = GET_OBJ_VAL(obj, 1);
  object.value[2] = GET_OBJ_VAL(obj, 2);
  object.value[3] = GET_OBJ_VAL(obj, 3);
  object.extra_flags = GET_OBJ_EXTRA(obj);
  object.weight = GET_OBJ_WEIGHT(obj);
  object.timer = GET_OBJ_TIMER(obj);
  object.bitvector = obj->obj_flags.bitvector;
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    object.affected[j] = obj->affected[j];


  /* find out if this is a spellbook that needs the spells stored... */
  memset(object.PSE_Desc, 0x0, sizeof(object.PSE_Desc));

  tmpdesc = obj->ex_description;
  for(;tmpdesc; tmpdesc = tmpdesc->next)
  {
    if((tmpdesc->keyword) && (strcmp(tmpdesc->keyword, "PSE") == 0))
    {
      strcpy(object.PSE_Desc, "1");
      strcat(object.PSE_Desc, tmpdesc->description);
      break;
    }
  }

  if (fwrite(&object, sizeof(struct obj_file_elem), 1, fl) < 1) {
    perror("Error writing object in Obj_to_store");
    return 0;
  }
  return 1;
}

 int Obj_to_store(struct obj_data * obj, FILE * fl)
 {
   return Obj_to_store_from(obj, fl, 0);
 }




int Crash_delete_file(char *name)
{
  char filename[50];
  FILE *fl;

  if (!get_filename(name, filename, CRASH_FILE))
    return 0;
  if (!(fl = fopen(filename, "rb"))) {
    if (errno != ENOENT) {	/* if it fails but NOT because of no file */
      sprintf(buf1, "SYSERR: deleting crash file %s (1)", filename);
      perror(buf1);
    }
    return 0;
  }
  fclose(fl);

  if (unlink(filename) < 0) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: deleting crash file %s (2)", filename);
      perror(buf1);
    }
  }
  return (1);
}


int Crash_delete_crashfile(struct char_data * ch)
{
  char fname[MAX_INPUT_LENGTH];
  struct rent_info rent;
  FILE *fl;

  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
    return 0;
  if (!(fl = fopen(fname, "rb"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: checking for crash file %s (3)", fname);
      perror(buf1);
    }
    return 0;
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  fclose(fl);

  if (rent.rentcode == RENT_CRASH)
    Crash_delete_file(GET_NAME(ch));

  return 1;
}


int Crash_clean_file(char *name)
{
  char fname[MAX_STRING_LENGTH], filetype[20];
  struct rent_info rent;
  extern int rent_file_timeout, crash_file_timeout;
  FILE *fl;

  if (!get_filename(name, fname, CRASH_FILE))
    return 0;
  /*
   * open for write so that permission problems will be flagged now, at boot
   * time.
   */
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: OPENING OBJECT FILE %s (4)", fname);
      perror(buf1);
    }
    return 0;
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  fclose(fl);

  if ((rent.rentcode == RENT_CRASH) ||
      (rent.rentcode == RENT_FORCED) || (rent.rentcode == RENT_TIMEDOUT)) {
    if (rent.time < time(0) - (crash_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      switch (rent.rentcode) {
      case RENT_CRASH:
	strcpy(filetype, "crash");
	break;
      case RENT_FORCED:
	strcpy(filetype, "forced rent");
	break;
      case RENT_TIMEDOUT:
	strcpy(filetype, "idlesave");
	break;
      default:
	strcpy(filetype, "UNKNOWN!");
	break;
      }
      sprintf(buf, "    Deleting %s's %s file.", name, filetype);
      log(buf);
      return 1;
    }
    /* Must retrieve rented items w/in 30 days */
  } else if (rent.rentcode == RENT_RENTED)
    if (rent.time < time(0) - (rent_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      sprintf(buf, "    Deleting %s's rent file.", name);
      log(buf);
      return 1;
    }
  return (0);
}



void update_obj_file(void)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    Crash_clean_file((player_table + i)->name);
  return;
}



void Crash_listrent(struct char_data * ch, char *name)
{
  FILE *fl;
  char fname[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct obj_data *obj;
  struct rent_info rent;

  if (!get_filename(name, fname, CRASH_FILE))
    return;
  if (!(fl = fopen(fname, "rb"))) {
    sprintf(buf, "%s has no rent file.\r\n", name);
    send_to_char(buf, ch);
    return;
  }
  sprintf(buf, "%s\r\n", fname);
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  switch (rent.rentcode) {
  case RENT_RENTED:
    strcat(buf, "Rent\r\n");
    break;
  case RENT_CRASH:
    strcat(buf, "Crash\r\n");
    break;
  case RENT_CRYO:
    strcat(buf, "Cryo\r\n");
    break;
  case RENT_TIMEDOUT:
  case RENT_FORCED:
    strcat(buf, "TimedOut\r\n");
    break;
  default:
    strcat(buf, "Undef\r\n");
    break;
  }
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      fclose(fl);
      return;
    }
    if (!feof(fl))
      if (real_object(object.item_number) > -1) {
	obj = read_object(object.item_number, VIRTUAL);
	sprintf(buf, "%s [%5d] (%5dau) <%2d> %-20s\r\n", buf,
		object.item_number, GET_OBJ_RENT(obj),
		object.locate, obj->short_description);
	extract_obj(obj);
      }
  }
  send_to_char(buf, ch);
  fclose(fl);
}



int Crash_write_rentcode(struct char_data * ch, FILE * fl, struct rent_info * rent)
{
  if (fwrite(rent, sizeof(struct rent_info), 1, fl) < 1) {
    perror("Writing rent code.");
    return 0;
  }
  return 1;
}

 void auto_equip(struct char_data *ch, struct obj_data *obj, int locate)
 {
   int j;

   if (locate > 0) { /* was worn */
     switch (j = locate-1) {
     case WEAR_LIGHT:
       break;
     case WEAR_FINGER_R:
     case WEAR_FINGER_L:
       if (!CAN_WEAR(obj,ITEM_WEAR_FINGER)) /* not fitting :( */
 	locate = 0;
       break;
     case WEAR_NECK_1:
     case WEAR_NECK_2:
       if (!CAN_WEAR(obj,ITEM_WEAR_NECK))
 	locate = 0;
       break;
     case WEAR_BODY:
       if (!CAN_WEAR(obj,ITEM_WEAR_BODY))
 	locate = 0;
       break;
     case WEAR_HEAD:
       if (!CAN_WEAR(obj,ITEM_WEAR_HEAD))
 	locate = 0;
       break;
     case WEAR_LEGS:
       if (!CAN_WEAR(obj,ITEM_WEAR_LEGS))
 	locate = 0;
       break;
     case WEAR_FEET:
       if (!CAN_WEAR(obj,ITEM_WEAR_FEET))
 	locate = 0;
       break;
     case WEAR_HANDS:
       if (!CAN_WEAR(obj,ITEM_WEAR_HANDS))
 	locate = 0;
       break;
     case WEAR_ARMS:
       if (!CAN_WEAR(obj,ITEM_WEAR_ARMS))
 	locate = 0;
       break;
     case WEAR_SHIELD:
       if (!CAN_WEAR(obj,ITEM_WEAR_SHIELD))
 	locate = 0;
       break;
     case WEAR_ABOUT:
       if (!CAN_WEAR(obj,ITEM_WEAR_ABOUT))
 	locate = 0;
       break;
     case WEAR_LEAR:
 	if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
	locate =0;
	break;
     case WEAR_REAR:
        if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
        locate =0;
        break;
     case WEAR_OBELT:
	if (!CAN_WEAR(obj,ITEM_WEAR_OBELT))
        locate =0;
        break;
     case WEAR_FACE:
	if (!CAN_WEAR(obj,ITEM_WEAR_FACE))
        locate =0;
        break;
     case WEAR_EYES:
        if (!CAN_WEAR(obj,ITEM_WEAR_EYES))
        locate =0;
        break;
     case WEAR_BADGE:
        if (!CAN_WEAR(obj,ITEM_WEAR_BADGE))
        locate =0;
        break;
     case WEAR_WAIST:
       if (!CAN_WEAR(obj,ITEM_WEAR_WAIST))
 	locate = 0;
       break;
     case WEAR_WRIST_R:
     case WEAR_WRIST_L:
       if (!CAN_WEAR(obj,ITEM_WEAR_WRIST))
 	locate = 0;
       break;
     case WEAR_WIELD:
       if (!CAN_WEAR(obj,ITEM_WEAR_WIELD))
 	locate = 0;
       break;
     case WEAR_HOLD:
       if (!CAN_WEAR(obj,ITEM_WEAR_HOLD) &&
 	  !(IS_WARRIOR(ch) &&
 	    CAN_WEAR(obj,ITEM_WEAR_WIELD) && GET_OBJ_TYPE(obj) == ITEM_WEAPON))
 	locate = 0;
       break;
     default:
       locate = 0;
     }
     if (locate > 0)
       if (!GET_EQ(ch,j)) {
 /* check ch's alignment to prevent $M from being zapped through auto-equip */
 	if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
 	    (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
 	    (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)))
 	  locate = 0;
 	else
 	  equip_char(ch, obj, j);
       }
       else  /* oops - saved player with double equipment[j]? */
 	locate = 0;
   }
   if (locate <= 0)
     obj_to_char(obj, ch);
 }



 #define MAX_BAG_ROW 5


int Crash_load(struct char_data * ch)
/* return values:
	0 - successful load, keep char in rent room.
	1 - load failure or load of crash items -- put char in temple.
	2 - rented equipment lost (no $)
*/
{
  void Crash_crashsave(struct char_data * ch);

  FILE *fl;
  char fname[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct rent_info rent;
  int cost, orig_rent_code;
  float num_of_days;
  struct obj_data *obj;
  int locate, j;
  struct obj_data *obj1;
  struct obj_data *cont_row[MAX_BAG_ROW];

  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
    return 1;
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: READING OBJECT FILE %s (5)", fname);
      perror(buf1);
      send_to_char("\r\n********************* NOTICE *********************\r\n"
		   "There was a problem loading your objects from disk.\r\n"
		   "Contact a God for assistance.\r\n", ch);
    }
    sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    return 1;
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);

  if (rent.rentcode == RENT_RENTED || rent.rentcode == RENT_TIMEDOUT) {
    num_of_days = (float) (time(0) - rent.time) / SECS_PER_REAL_DAY;
    cost = (int) (rent.net_cost_per_diem * num_of_days);
    /*if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
      fclose(fl);
      sprintf(buf, "%s entering game, rented equipment lost (no $).",
	      GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      Crash_crashsave(ch);
      return 2;
    } */
    /*  GET_BANK_GOLD(ch) -= MAX(cost - GET_GOLD(ch), 0);
      GET_GOLD(ch) = MAX(GET_GOLD(ch) - cost, 0);
      save_char(ch, NOWHERE);
      */
  }
  switch (orig_rent_code = rent.rentcode) {
  case RENT_RENTED:
    sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRASH:
    sprintf(buf, "%s retrieving crash-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRYO:
    sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_FORCED:
  case RENT_TIMEDOUT:
    sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  default:
    sprintf(buf, "WARNING: %s entering game with undefined rent code.", GET_NAME(ch));
    mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  }

  for (j = 0;j < MAX_BAG_ROW;j++)
     cont_row[j] = NULL; /* empty all cont lists (you never know ...) */


  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("Reading crash file: Crash_load.");
      fclose(fl);
      return 1;
    }
    if (!feof(fl))
      if ((obj = Obj_from_store_to(object, &locate))) {
 	auto_equip(ch, obj, locate);

 /*
 what to do with a new loaded item:

   if there's a list with <locate> less than 1 below this:
     (equipped items are assumed to have <locate>==0 here) then its
     container has disappeared from the file   *gasp*
      -> put all the list back to ch's inventory

   if there's a list of contents with <locate> 1 below this:
     check if it's a container
     - if so: get it from ch, fill it, and give it back to ch (this way the
         container has its correct weight before modifying ch)
     - if not: the container is missing -> put all the list to ch's inventory

   for items with negative <locate>:
     if there's already a list of contents with the same <locate> put obj to it
     if not, start a new list

 Confused? Well maybe you can think of some better text to be put here ...

 since <locate> for contents is < 0 the list indices are switched to
 non-negative
 */

 	if (locate > 0) { /* item equipped */
 	  for (j = MAX_BAG_ROW-1;j > 0;j--)
 	    if (cont_row[j]) { /* no container -> back to ch's inventory */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }
 	  if (cont_row[0]) { /* content list existing */
 	    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
 	      /* rem item ; fill ; equip again */
 	      obj = unequip_char(ch, locate-1);
 	      obj->contains = NULL; /* should be empty - but who knows */
 	      for (;cont_row[0];cont_row[0] = obj1) {
 		obj1 = cont_row[0]->next_content;
 		obj_to_obj(cont_row[0], obj);
 	      }
 	      equip_char(ch, obj, locate-1);
 	    } else { /* object isn't container -> empty content list */
 	      for (;cont_row[0];cont_row[0] = obj1) {
 		obj1 = cont_row[0]->next_content;
 		obj_to_char(cont_row[0], ch);
 	      }
 	      cont_row[0] = NULL;
 	    }
 	  }
 	} else { /* locate <= 0 */
 	  for (j = MAX_BAG_ROW-1;j > -locate;j--)
 	    if (cont_row[j]) { /* no container -> back to ch's inventory */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }

 	  if (j == -locate && cont_row[j]) { /* content list existing */
 	    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
 	      /* take item ; fill ; give to char again */
 	      obj_from_char(obj);
 	      obj->contains = NULL;
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_obj(cont_row[j], obj);
 	      }
 	      obj_to_char(obj, ch); /* add to inv first ... */
 	    } else { /* object isn't container -> empty content list */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }
 	  }

 	  if (locate < 0 && locate >= -MAX_BAG_ROW) {
 		/* let obj be part of content list
 		   but put it at the list's end thus having the items
 		   in the same order as before renting */
 	    obj_from_char(obj);
 	    if ((obj1 = cont_row[-locate-1])) {
 	      while (obj1->next_content)
 		obj1 = obj1->next_content;
 	      obj1->next_content = obj;
 	    } else
 	      cont_row[-locate-1] = obj;
 	  }
 	}
       }
  }

  /* turn this into a crash file by re-writing the control block */
  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  rewind(fl);
  Crash_write_rentcode(ch, fl, &rent);

  fclose(fl);

  if ((orig_rent_code == RENT_RENTED) || (orig_rent_code == RENT_CRYO))
    return 0;
  else
    return 1;
}



/*int Crash_save(struct obj_data * obj, FILE * fp)*/
int Crash_save(struct obj_data * obj, FILE * fp, int locate)
{
  struct obj_data *tmp;
  int result;

  if (obj) {
    Crash_save(obj->next_content, fp, locate);
    Crash_save(obj->contains, fp, MIN(0,locate)-1);
    result = Obj_to_store_from(obj, fp, locate);

    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);

    if (!result)
      return 0;
  }
  return TRUE;
}




void Crash_restore_weight(struct obj_data * obj)
{
  if (obj) {
    Crash_restore_weight(obj->contains);
    Crash_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
  }
}



void Crash_extract_objs(struct obj_data * obj)
{
  if (obj) {
    Crash_extract_objs(obj->contains);
    Crash_extract_objs(obj->next_content);
    extract_obj(obj);
  }
}


int Crash_is_unrentable(struct obj_data * obj)
{
  if (!obj)
    return 0;

  if (IS_OBJ_STAT(obj, ITEM_NORENT) || GET_OBJ_RENT(obj) < 0 ||
      GET_OBJ_RNUM(obj) <= NOTHING || GET_OBJ_TYPE(obj) == ITEM_KEY)
    return 1;

  return 0;
}


void Crash_extract_norents(struct obj_data * obj)
{
  if (obj) {
    Crash_extract_norents(obj->contains);
    Crash_extract_norents(obj->next_content);
    if (Crash_is_unrentable(obj))
      extract_obj(obj);
  }
}

 /* get norent items from eq to inventory and
    extract norents out of worn containers */
 void Crash_extract_norents_from_equipped(struct char_data * ch)
 {
   int j;

   for (j = 0;j < NUM_WEARS;j++) {
     if (GET_EQ(ch,j)) {
       if (IS_OBJ_STAT(GET_EQ(ch,j), ITEM_NORENT) ||
 	  GET_OBJ_RENT(GET_EQ(ch,j)) < 0 ||
 	  GET_OBJ_RNUM(GET_EQ(ch,j)) <= NOTHING ||
 	  GET_OBJ_TYPE(GET_EQ(ch,j)) == ITEM_KEY)
 	obj_to_char(unequip_char(ch,j),ch);
       else
 	Crash_extract_norents(GET_EQ(ch,j));
     }
   }
 }




void Crash_extract_expensive(struct obj_data * obj)
{
  struct obj_data *tobj, *max;

  max = obj;
  for (tobj = obj; tobj; tobj = tobj->next_content)
    if (GET_OBJ_RENT(tobj) > GET_OBJ_RENT(max))
      max = tobj;
  extract_obj(max);
}



void Crash_calculate_rent(struct obj_data * obj, int *cost)
{
  if (obj) {
    *cost += MAX(0, GET_OBJ_RENT(obj));
    Crash_calculate_rent(obj->contains, cost);
    Crash_calculate_rent(obj->next_content, cost);
  }
}


void Crash_crashsave(struct char_data * ch)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }

  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
	fclose(fp);
	return;
      }
      Crash_restore_weight(GET_EQ(ch,j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
     fclose(fp);
     return;
   }
   Crash_restore_weight(ch->carrying);

  fclose(fp);
  REMOVE_BIT(PLR_FLAGS(ch), PLR_CRASH);
}


void Crash_idlesave(struct char_data * ch)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  int cost, cost_eq;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  /*for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
      obj_to_char(unequip_char(ch, j), ch);*/
  /*above is no longer needed did in the following*/
  /*function*/
  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);

  cost = 0;
  Crash_calculate_rent(ch->carrying, &cost);
  /*added inacse we every use cost for rent with autoeq Banyal*/
   cost_eq = 0;
   for (j = 0; j < NUM_WEARS; j++)
     Crash_calculate_rent(GET_EQ(ch,j), &cost_eq);

   cost <<= 1;
      cost_eq <<= 1;

   if (cost+cost_eq > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
     for (j = 0; j < NUM_WEARS; j++) /* unequip player with low money */
       if (GET_EQ(ch,j))
 	obj_to_char(unequip_char(ch, j), ch);
     cost += cost_eq;
     cost_eq = 0;

     while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
       Crash_extract_expensive(ch->carrying);
       cost = 0;
       Crash_calculate_rent(ch->carrying, &cost);
       cost <<= 1;
     }
  /* forcerent cost is 2x normal rent */
  /*while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
    Crash_extract_expensive(ch->carrying);
    cost = 0;
    Crash_calculate_rent(ch->carrying, &cost);
    cost <<= 1;*/

  }

  if (!ch->carrying) {
   for (j = 0; j < NUM_WEARS && !(GET_EQ(ch,j)); j++);
     if (j == NUM_WEARS) { /* no eq nor inv */
       fclose(fp);
       Crash_delete_file(GET_NAME(ch));
       return;
     }
  }
  rent.net_cost_per_diem = cost;

 rent.rentcode = RENT_TIMEDOUT;
  rent.time = time(0);
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);


  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  /*Banyal.. eq eq eq lets eq the basterds*/
  /*if (!Crash_save(ch->carrying, fp)) {*/

   for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
 	fclose(fp);
 	return;
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
}


void Crash_rentsave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

 /* for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
      obj_to_char(unequip_char(ch, j), ch);*/
  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);

rent.rentcode = RENT_RENTED;
  rent.time = time(0);
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);

  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  /*if (!Crash_save(ch->carrying, fp)) {*/
     for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
 	fclose(fp);
 	return;
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
}


void Crash_cryosave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

 /* for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
      obj_to_char(unequip_char(ch, j), ch);*/

  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);

  GET_GOLD(ch) = MAX(0, GET_GOLD(ch) - cost);

rent.rentcode = RENT_CRYO;
  rent.time = time(0);
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);
  rent.net_cost_per_diem = 0;

  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  /*if (!Crash_save(ch->carrying, fp)) {*/
     for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
 	fclose(fp);
 	return;
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
  SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
}


/* ************************************************************************
* Routines used for the receptionist					  *
************************************************************************* */

void Crash_rent_deadline(struct char_data * ch, struct char_data * recep,
			      long cost)
{
  long rent_deadline;

  if (!cost)
    return;

  rent_deadline = ((GET_GOLD(ch) + GET_BANK_GOLD(ch)) / cost);
  sprintf(buf,
      "$n tells you, 'You can rent for %ld day%s with the gold you have\r\n"
	  "on hand and in the bank.'\r\n",
	  rent_deadline, (rent_deadline > 1) ? "s" : "");
  act(buf, FALSE, recep, 0, ch, TO_VICT);
}

int Crash_report_unrentables(struct char_data * ch, struct char_data * recep,
			         struct obj_data * obj)
{
  char buf[128];
  int has_norents = 0;

  if (obj) {
    if (Crash_is_unrentable(obj)) {
      has_norents = 1;
      sprintf(buf, "$n tells you, 'You cannot store %s.'", OBJS(obj, ch));
      act(buf, FALSE, recep, 0, ch, TO_VICT);
    }
    has_norents += Crash_report_unrentables(ch, recep, obj->contains);
    has_norents += Crash_report_unrentables(ch, recep, obj->next_content);
  }
  return (has_norents);
}



void Crash_report_rent(struct char_data * ch, struct char_data * recep,
		            struct obj_data * obj, long *cost, long *nitems, int display, int factor)
{
  static char buf[256];

  if (obj) {
    if (!Crash_is_unrentable(obj)) {
      (*nitems)++;
      *cost += MAX(0, (GET_OBJ_RENT(obj) * factor));
      if (display) {
	sprintf(buf, "$n tells you, '%5d coins for %s..'",
		(GET_OBJ_RENT(obj) * factor), OBJS(obj, ch));
	act(buf, FALSE, recep, 0, ch, TO_VICT);
      }
    }
    Crash_report_rent(ch, recep, obj->contains, cost, nitems, display, factor);
    Crash_report_rent(ch, recep, obj->next_content, cost, nitems, display, factor);
  }
}



int Crash_offer_rent(struct char_data * ch, struct char_data * receptionist,
		         int display, int factor)
{
  extern int max_obj_save;	/* change in config.c */
  char buf[MAX_INPUT_LENGTH];
  int i;
  long totalcost = 0, numitems = 0, norent = 0;

  norent = Crash_report_unrentables(ch, receptionist, ch->carrying);
  for (i = 0; i < NUM_WEARS; i++)
    /*norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch, i));*/
	norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch,i));

  if (norent)
    return 0;

  totalcost = min_rent_cost * factor;

  Crash_report_rent(ch, receptionist, ch->carrying, &totalcost, &numitems, display, factor);

  for (i = 0; i < NUM_WEARS; i++)
	  Crash_report_rent(ch, receptionist, GET_EQ(ch,i), &totalcost, &numitems, display, factor);
    /*Crash_report_rent(ch, receptionist, GET_EQ(ch, i), &totalcost, &numitems, display, factor);*/

  /*if (!numitems) {
    act("$n tells you, 'But you are not carrying anything!  Just quit!'",
	FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
  }	*/
  if (numitems > max_obj_save) {
    sprintf(buf, "$n tells you, 'Sorry, but I cannot store more than %d items.'",
	    max_obj_save);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
  }
  if (display) {
    sprintf(buf, "$n tells you, 'Plus, my %d coin fee..'",
	    min_rent_cost * factor);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    sprintf(buf, "$n tells you, 'For a total of %ld coins%s.'",
	    totalcost, (factor == RENT_FACTOR ? " per day" : ""));
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    if (totalcost > GET_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
	  FALSE, receptionist, 0, ch, TO_VICT);
      return (0);
    } else if (factor == RENT_FACTOR)
      Crash_rent_deadline(ch, receptionist, totalcost);
  }
  return (totalcost);
}



int gen_receptionist(struct char_data * ch, struct char_data * recep,
		         int cmd, char *arg, int mode)
{
  int cost = 0;
  int save_room;
  char *action_table[] = {"smile", "dance", "sigh", "blush", "burp",
  "cough", "fart", "twiddle", "yawn"};

  ACMD(do_action);

  if (!ch->desc || IS_NPC(ch))
    return FALSE;

  if (!cmd && !number(0, 5)) {
    do_action(recep, "", find_command(action_table[number(0, 8)]), 0);
    return FALSE;
  }
  if (!CMD_IS("offer") && !CMD_IS("rent"))
    return FALSE;
  if (!AWAKE(recep)) {
    send_to_char("She is unable to talk to you...\r\n", ch);
    return TRUE;
  }
  if (!CAN_SEE(recep, ch)) {
    act("$n says, 'I don't deal with people I can't see!'", FALSE, recep, 0, 0, TO_ROOM);
    return TRUE;
  }
  /*if (free_rent) {
    return 1;
  }	*/
  if (CMD_IS("rent")) {
    if (!(cost = Crash_offer_rent(ch, recep, FALSE, mode)))
      return TRUE;
    if (mode == RENT_FACTOR)
      sprintf(buf, "&0&7&b$n&0&7&b tells you, 'Rent?, sure, come this way!.'");
    /*else if (mode == CRYO_FACTOR)
      sprintf(buf, "$n tells you, 'It will cost you %d gold coins to be frozen.'", cost);
    */act(buf, FALSE, recep, 0, ch, TO_VICT);
    /*if (cost > GET_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
	  FALSE, recep, 0, ch, TO_VICT);
      return TRUE;
    }
    if (cost && (mode == RENT_FACTOR))
      Crash_rent_deadline(ch, recep, cost);
	*/
    if (mode == RENT_FACTOR) {
      act("$n stores your belongings and helps you into your private chamber.",
	  FALSE, recep, 0, ch, TO_VICT);
      if (CMD_IS("rent"))
    GET_LOADROOM(ch) = world[ch->in_room].number;
      Crash_rentsave(ch, 500);
      sprintf(buf, "%s has rented (%d/day, %ld tot.)", GET_NAME(ch),
	      cost, GET_GOLD(ch) + GET_BANK_GOLD(ch));
    } else {			/* cryo */
      act("$n stores your belongings and helps you into your private chamber.\r\n"
	  "A white mist appears in the room, chilling you to the bone...\r\n"
	  "You begin to lose consciousness...",
	  FALSE, recep, 0, ch, TO_VICT);
      Crash_cryosave(ch, cost);
      sprintf(buf, "%s has cryo-rented.", GET_NAME(ch));
      SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
    }

    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    act("$n helps $N into $S private chamber.", FALSE, recep, 0, ch, TO_NOTVICT);
    save_room = ch->in_room;
    if (CMD_IS("rent"))
    GET_LOADROOM(ch) = world[ch->in_room].number;
    extract_char(ch);
    save_char(ch, save_room);
  } else {
    Crash_offer_rent(ch, recep, TRUE, mode);
    act("$N gives $n an offer.", FALSE, ch, 0, recep, TO_ROOM);
  }
  return TRUE;
}


SPECIAL(receptionist)
{
  return (gen_receptionist(ch, me, cmd, argument, RENT_FACTOR));
}


SPECIAL(cryogenicist)
{
  return (gen_receptionist(ch, me, cmd, argument, CRYO_FACTOR));
}


void Crash_save_all(void)
{
  struct descriptor_data *d;
  for (d = descriptor_list; d; d = d->next) {
    if ((d->connected == CON_PLAYING) && !IS_NPC(d->character)) {
      if (PLR_FLAGGED(d->character, PLR_CRASH)) {
	Crash_crashsave(d->character);
	save_char(d->character, NOWHERE);
        send_to_char("Autosaving.....\r\n", d->character);
	REMOVE_BIT(PLR_FLAGS(d->character), PLR_CRASH);
      }
    }
  }
}
@


1.109
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: pfiles.c,v 1.108 2009/03/16 19:17:52 jps Exp $
 ***************************************************************************/
/***************************************************************************
 *  File: pfiles.c                                        Part of FieryMUD *
 *  Usage: loading/saving player objects and quests                        *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "casting.h"
#include "quest.h"
#include "math.h"
#include "players.h"
#include "pfiles.h"
#include "dg_scripts.h"
#include "legacy_structs.h"
#include "constants.h"
#include "skills.h"
#include "modify.h"
#include "act.h"
#include "specprocs.h"

/* Extern functions */
ACMD(do_tell);

static void extract_unrentables(struct char_data *ch);
static bool write_rent_code(FILE *fl, int rentcode);
static bool write_object_record(struct obj_data *obj, FILE *fl, int location);
int delete_objects_file(char *name);
static void read_objects(struct char_data *ch, FILE *fl);
static void list_objects(struct obj_data *obj, struct char_data *ch, int indent, int last_indent, const char *first_indent);
static bool load_binary_objects(struct char_data *ch);

void save_player_objects(struct char_data *ch)
{
  FILE *fl;
  int i;
  char filename[MAX_INPUT_LENGTH], tempfilename[MAX_INPUT_LENGTH];

  if (IS_NPC(ch))
    return;

  if (!get_pfilename(GET_NAME(ch), tempfilename, TEMP_FILE)) {
    sprintf(buf,
          "SYSERR: Couldn't make temporary file name for saving objects for %s.",
          GET_NAME(ch));
    mudlog(buf, NRM, LVL_GOD, TRUE);
    return;
  }

  if (!get_pfilename(GET_NAME(ch), filename, OBJ_FILE)) {
    sprintf(buf,
          "SYSERR: Couldn't make final file name for saving objects for %s.",
          GET_NAME(ch));
    mudlog(buf, NRM, LVL_GOD, TRUE);
    return;
  }

  if (!(fl = fopen(tempfilename, "w"))) {
    sprintf(buf, "SYSERR: Couldn't open player file %s for write",
          tempfilename);
    mudlog(buf, NRM, LVL_GOD, TRUE);
    return;
  }

  if (ch->carrying == NULL) {
    for (i = 0; i < NUM_WEARS && !GET_EQ(ch, i); ++i);
    if (i == NUM_WEARS) { /* No equipment or inventory. */
      fclose(fl);
      delete_objects_file(GET_NAME(ch));
      return;
    }
  }

  /* Legacy.  Reason for leaving game is now in struct char_special_data
   * (thus the character save file). The loading code expects a value here,
   * and all modern object save files have one. */
  write_rent_code(fl, 1);

  for (i = 0; i < NUM_WEARS; ++i)
    if (GET_EQ(ch, i)) {
      if (!write_objects(GET_EQ(ch, i), fl, i)) {
        fclose(fl);
        return;
      }
    }

  if (!write_objects(ch->carrying, fl, WEAR_INVENTORY)) {
    fclose(fl);
    return;
  }

  if (fclose(fl)) {
    sprintf(buf, "SYSERR: Error closing rent file for %s after write",
            GET_NAME(ch));
    log("%s",buf);
  } else if (rename(tempfilename, filename)) {
    sprintf(buf, "SYSERR: Error renaming temporary rent file for %s after write",
            GET_NAME(ch));
    log("%s",buf);
  }
}

static bool is_object_unrentable(struct obj_data *obj)
{
  if (!obj)
    return FALSE;

  if (OBJ_FLAGGED(obj, ITEM_NORENT))
    return TRUE;

  return FALSE;
}

static void extract_unrentables_from_list(struct obj_data *obj)
{
  if (obj) {
    extract_unrentables_from_list(obj->contains);
    extract_unrentables_from_list(obj->next_content);
    if (is_object_unrentable(obj))
      extract_obj(obj);
  }
}

static void extract_unrentables(struct char_data *ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; ++i)
    if (GET_EQ(ch, i)) {
      if (is_object_unrentable(GET_EQ(ch, i)))
        obj_to_char(unequip_char(ch, i), ch);
      else
        extract_unrentables_from_list(GET_EQ(ch, i)->contains);
    }

  extract_unrentables_from_list(ch->carrying);
}


static bool write_rent_code(FILE *fl, int rentcode)
{
  fprintf(fl, "%d\n", rentcode);
  return FALSE;
}

bool write_objects(struct obj_data *obj, FILE *fl, int location)
{
  struct obj_data *temp;
  bool success = TRUE;

  if (obj) {
    /*
     * Traverse the list in reverse order so when they are loaded
     * and placed back on the char using obj_to_char, they will be
     * in the correct order.
     */
    write_objects(obj->next_content, fl, location);

    for (temp = obj->contains; temp; temp = temp->next_content)
      GET_OBJ_WEIGHT(obj) -= GET_OBJ_WEIGHT(temp);

    success = write_object_record(obj, fl, location);

    for (temp = obj->contains; temp; temp = temp->next_content)
      GET_OBJ_WEIGHT(obj) += GET_OBJ_WEIGHT(temp);

    /*
     * The contents of an item must be written directly after the
     * container in order to determine which container to re-place
     * them in when being loaded.
     */
    write_objects(obj->contains, fl, MIN(0, location) - 1);
  }

  return success;
}

static bool write_object_record(struct obj_data *obj, FILE *fl, int location)
{
  int i;
  struct extra_descr_data *desc;
  struct spell_book_list *spell;
  trig_data *trig;
  struct trig_var_data *var;

  fprintf(fl, "vnum: %d\n", GET_OBJ_VNUM(obj));
  fprintf(fl, "location: %d\n", location);

  fprintf(fl, "values:\n");
  for (i = 0; i < NUM_VALUES; ++i)
    fprintf(fl, "%d\n", GET_OBJ_VAL(obj, i));
  fprintf(fl, "~\n");

  fprintf(fl, "flags: ");
  write_ascii_flags(fl, GET_OBJ_FLAGS(obj), NUM_ITEM_FLAGS);
  fprintf(fl, "\n");

  /* Strings */
  if (obj->name)
    fprintf(fl, "name: %s\n",
            filter_chars(buf, obj->name, "\r\n"));
  if (obj->short_description)
    fprintf(fl, "shortdesc: %s\n",
            filter_chars(buf, obj->short_description, "\r\n"));
  if (obj->description)
    fprintf(fl, "desc: %s\n",
            filter_chars(buf, obj->description, "\r\n"));
  if (obj->action_description)
    fprintf(fl, "adesc:\n%s~\n",
            filter_chars(buf, obj->action_description, "\r~"));

  fprintf(fl, "type: %d\n", GET_OBJ_TYPE(obj));
  fprintf(fl, "weight: %.2f\n", GET_OBJ_WEIGHT(obj));
  fprintf(fl, "cost: %d\n", GET_OBJ_COST(obj));
  fprintf(fl, "timer: %d\n", GET_OBJ_TIMER(obj));
  if (IS_CORPSE(obj))
    fprintf(fl, "decomp: %d\n", GET_OBJ_DECOMP(obj));
  fprintf(fl, "level: %d\n", GET_OBJ_LEVEL(obj));
  fprintf(fl, "effects: ");
  write_ascii_flags(fl, GET_OBJ_EFF_FLAGS(obj), NUM_EFF_FLAGS);
  fprintf(fl, "\n");
  fprintf(fl, "wear: %d\n", GET_OBJ_WEAR(obj));

  for (i = 0; i < MAX_OBJ_APPLIES && !obj->applies[i].location; ++i);
  if (i < MAX_OBJ_APPLIES) {
    fprintf(fl, "applies:\n");
    for (i = 0; i < MAX_OBJ_APPLIES; ++i)
      if (obj->applies[i].modifier && obj->applies[i].location)
        fprintf(fl, "%d %d\n",
                obj->applies[i].location, obj->applies[i].modifier);
    fprintf(fl, "~\n");
  }

  if (obj->ex_description)
    for (desc = obj->ex_description; desc; desc = desc->next)
      if (desc->keyword && *desc->keyword &&
          desc->description && *desc->description)
        fprintf(fl, "extradesc: %s\n%s~\n",
                filter_chars(buf1, desc->keyword, "\r\n"),
                filter_chars(buf2, desc->description, "\r~"));

  /* Spellbooks */
  if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK && obj->spell_book) {
    fprintf(fl, "spells:\n");
    for (spell = obj->spell_book; spell; spell = spell->next)
      fprintf(fl, "%d %d\n", spell->spell, spell->length);
    fprintf(fl, "~\n");
  }

  /* Scripts */
  if (SCRIPT(obj)) {
    /* Trigger list */
    if (TRIGGERS(SCRIPT(obj))) {
      fprintf(fl, "triggers:\n");
      for (trig = TRIGGERS(SCRIPT(obj)); trig; trig = trig->next)
        fprintf(fl, "%d\n", GET_TRIG_VNUM(trig));
      fprintf(fl, "~\n");
    }

    /* Global variables */
    if (SCRIPT(obj)->global_vars) {
      fprintf(fl, "variables:\n");
      for (var = SCRIPT(obj)->global_vars; var; var = var->next)
        if (*var->name != '~')
          fprintf(fl, "%s %s\n", var->name,
                  filter_chars(buf, var->value, "\r\n"));
      fprintf(fl, "~\n");
    }
  }

  fprintf(fl, "~~\n");

  return TRUE;
}

void show_rent(struct char_data *ch, char *argument)
{
  char name[MAX_INPUT_LENGTH];
  FILE *fl;
  struct char_data *tch;
  int i;
  bool found;

  any_one_arg(argument, name);

  if (!*name) {
    send_to_char("Show rent for whom?\r\n", ch);
    return;
  }

  fl = open_player_obj_file(name, ch, FALSE);
  if (!fl) return;

  name[0] = UPPER(name[0]);

  if (!get_line(fl, buf)) {
    send_to_char("Error reading reading rent code.\r\n", ch);
    return;
  }

  if (!is_integer(buf)) {
     send_to_char("This file is in the obsolete binary format.  Please use 'objupdate' to fix it.\r\n", ch);
     return;
  }

  tch = create_char();
  load_player(name, tch);
  char_to_room(tch, 0);

  read_objects(tch, fl);

  fclose(fl);

  for (i = 0, found = FALSE; i < NUM_WEARS; ++i)
    if (GET_EQ(tch, i)) {
      found = TRUE;
      break;
    }

  if (found) {
    act("\r\n$N is wearing:", FALSE, ch, 0, tch, TO_CHAR);
    for (i = 0; i < NUM_WEARS; ++i)
      if (GET_EQ(tch, wear_order_index[i]))
        list_objects(GET_EQ(tch, wear_order_index[i]), ch,
                     strlen(where[wear_order_index[i]]), 0,
                     where[wear_order_index[i]]);
  }

  if (tch->carrying) {
    act("\r\n$N is carrying:", FALSE, ch, 0, tch, TO_CHAR);
    list_objects(tch->carrying, ch, 1, 0, NULL);
  }

  extract_objects(tch);

  /* Set this so extract_char() doesn't try to do an emergency save */
  SET_FLAG(PLR_FLAGS(tch), PLR_REMOVING);
  extract_char(tch);
}

static void list_objects(struct obj_data *list, struct char_data *ch,
                         int indent, int last_indent,
                         const char *first_indent)
{
  struct obj_data *i, *j, *display;
  bool found;
  int pos, num;
  static char buf[100];

  #define PRETTY_INDENTATION    FALSE
  #define OBJECTS_MATCH(x, y) \
    ((x)->item_number == (y)->item_number && \
     ((x)->short_description == (y)->short_description || \
      !strcmp((x)->short_description, (y)->short_description)) && \
     (x)->contains == (y)->contains)

  /* Loop through the list of objects */
  for (i = list; i; i = i->next_content) {
    /* Set to 0 in case this object can't be seen */
    num = 0;

    if (!PRF_FLAGGED(ch, PRF_EXPAND_OBJS)) {
      /* Check the list to see if we've already counted this object */
      for (j = list; j != i; j = j->next_content)
        if (OBJECTS_MATCH(i, j))
          break; /* found a matching object */
      if (i != j)
        continue; /* we counted object i earlier in the list */

      /* Count matching objects, including this one */
      for (display = j = i; j; j = j->next_content)
        if (OBJECTS_MATCH(i, j) && CAN_SEE_OBJ(ch, j)) {
          ++num;
          /* If the original item can't be seen, switch it for this one */
          if (display == i && !CAN_SEE_OBJ(ch, display))
            display = j;
        }
    }
    else if (CAN_SEE_OBJ(ch, i)) {
      display = i;
      num = 1;
    }

    /* This object or one like it can be seen by the char, so show it */
    if (num > 0) {
      buf[pos = MIN(indent, sizeof(buf) - 1)] = '\0';
      while (pos >= last_indent)
        buf[--pos] = ' ';
      if (first_indent)
        cprintf(ch, "%s", first_indent);
      else
        cprintf(ch, "%s", buf);
      if (num != 1)
        cprintf(ch, "[%d] ", num);
      print_obj_to_char(display, ch, SHOW_SHORT_DESC | SHOW_FLAGS, NULL);
      if (display->contains) {
        list_objects(display->contains, ch, indent + 3, indent, NULL);
        last_indent = indent;
      }
      found = TRUE;
    }
  }
}

void save_quests(struct char_data *ch)
{
   struct quest_list *curr;
   FILE *fp;
   char fname[PLAYER_FILENAME_LENGTH], frename[PLAYER_FILENAME_LENGTH];

   if (!get_pfilename(GET_NAME(ch), fname, TEMP_FILE)) {
      sprintf(buf,
            "SYSERR: save_quests() couldn't get temp file name for %s.",
            GET_NAME(ch));
      log("%s",buf);
      return;
   }

   if (!get_pfilename(GET_NAME(ch), frename, QUEST_FILE)) {
      sprintf(buf,
            "SYSERR: save_quests() couldn't get quest file name for %s.",
            GET_NAME(ch));
      log("%s",buf);
      return;
   }

   if (!(fp = fopen(fname, "w"))) {
      sprintf(buf, "SYSERR: save_quests() couldn't open file %s for write",
            fname);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return;
   }

   curr = ch->quests;
   while (curr) {
      int var_count;
      struct quest_var_list* vars;

      var_count = 0;
      vars = curr->variables;
      while (vars) {
         var_count++;
         vars = vars->next;
      }

      vars = curr->variables;

      fprintf(fp, "%d %d %d\n", curr->quest_id, curr->stage, var_count);

      while(vars) {
         struct   quest_var_list * temp;
         temp = vars->next;

         fprintf(fp, "%s %s\n", vars->var, vars->val);

         vars = temp;
      }

      curr = curr->next;
   }

   if (fclose(fp)) {
      sprintf(buf, "SYSERR: Error closing quest file for %s after write",
            GET_NAME(ch));
      log("%s",buf);
   } else if (rename(fname, frename)) {
      sprintf(buf, "SYSERR: Error renaming quest file for %s after write",
            GET_NAME(ch));
      log("%s",buf);
   }
}


int delete_objects_file(char *name)
{
  char filename[50];
  FILE *fl;

  if (!get_pfilename(name, filename, OBJ_FILE))
    return 0;
  if (!(fl = fopen(filename, "r"))) {
    if (errno != ENOENT) {        /* if it fails but NOT because of no file */
      sprintf(buf1, "SYSERR: deleting object file %s (1)", filename);
      perror(buf1);
    }
    return 0;
  }
  fclose(fl);

  if (unlink(filename) < 0) {
    if (errno != ENOENT) {        /* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: deleting object file %s (2)", filename);
      perror(buf1);
    }
  }
  return (1);
}


bool delete_player_obj_file(struct char_data * ch)
{
  char fname[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH];
  FILE *fl;
  int rent_code;

  if (!get_pfilename(GET_NAME(ch), fname, OBJ_FILE))
    return FALSE;

  if (!(fl = fopen(fname, "r"))) {
    if (errno != ENOENT) {        /* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: checking for object file %s (3)", fname);
      perror(buf1);
    }
    return FALSE;
  }

  if (get_line(fl, buf)) {
    rent_code = atoi(buf);
    if (rent_code == SAVE_AUTO)
      delete_objects_file(GET_NAME(ch));
  }

  fclose(fl);

  return TRUE;
}


static int auto_equip(struct char_data *ch, struct obj_data *obj, int location)
{
  if (location >= 0 && location != WEAR_INVENTORY) {
    if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch))
      location = WEAR_INVENTORY;
    if (location != WEAR_INVENTORY && !CAN_WEAR(obj, wear_flags[location]))
      location = WEAR_INVENTORY;
    /* Check alignment to prevent character from being zapped */
    if ((OBJ_FLAGGED(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
        (OBJ_FLAGGED(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
        (OBJ_FLAGGED(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)))
      location = WEAR_INVENTORY;
    if (location != WEAR_INVENTORY) {
      if (!GET_EQ(ch, location))
        equip_char(ch, obj, location);
      else
        location = WEAR_INVENTORY;
    }
  }
  return location;
}


/*
 * Code to auto-equip objects from legacy binary object files.
 */
static int binary_auto_equip(struct char_data *ch, struct obj_data *obj, int location)
{
  if (location > 0)
    location = (auto_equip(ch, obj, location - 1) != WEAR_INVENTORY);
  if (location <= 0)
    obj_to_char(obj, ch);
  return location;
}


/*
 * Parses and allocates memory for an object from a file.  Returns 
 * TRUE if successful and FALSE otherwise.  When TRUE is returned,
 * *obj will point to the object and *location will be the object's
 * location when saved (negative numbers denote objects within 
 * containers).
 */
bool build_object(FILE *fl, struct obj_data **objp, int *location)
{
  struct obj_data *obj, *proto;
  int num, num2, apply = 0;
  float f;
  char line[MAX_INPUT_LENGTH], tag[128], *value;
  struct extra_descr_data *desc, *last_desc = NULL;
  struct spell_book_list *spell, *last_spell;
  trig_data *trig;

  extern void add_var(struct trig_var_data **var_list, const char *name, const char *value);

  if (!objp || !location) {
    sprintf(buf, "SYSERR: Invalid obj or location pointers passed to build_object");
    log("%s",buf);
    return FALSE;
  }

  *objp = obj = create_obj();
  *location = WEAR_INVENTORY;

  while (get_line(fl, line)) {
    if (!strcmp(line, "~~"))
      break;

    tag_argument(line, tag);
    num = atoi(line);
    f = atof(line);

    switch (UPPER(*tag)) {
    case 'A':
      if (!strcmp(tag, "adesc"))        obj->action_description = fread_string(fl, "build_object");
      else if (!strcmp(tag, "applies")) {
        while (get_line(fl, line) && *line != '~' && apply < MAX_OBJ_APPLIES) {
          sscanf(line, "%d %d", &num, &num2);
          obj->applies[apply].location = LIMIT(0, num, NUM_APPLY_TYPES - 1);
          obj->applies[apply].modifier = num2;
          ++apply;
        }
      }
      else goto bad_tag;
      break;
    case 'C':
      if (!strcmp(tag, "cost"))         GET_OBJ_COST(obj) = MAX(0, num);
      else goto bad_tag;
      break;
    case 'D':
      if (!strcmp(tag, "desc"))         obj->description = strdup(line);
      else if (!strcmp(tag, "decomp"))   GET_OBJ_DECOMP(obj) = MAX(0, num);
      else goto bad_tag;
      break;
    case 'E':
      if (!strcmp(tag, "effects"))      load_ascii_flags(GET_OBJ_EFF_FLAGS(obj), NUM_EFF_FLAGS, line);
      else if (!strcmp(tag, "extradesc")) {
        CREATE(desc, struct extra_descr_data, 1);
        desc->keyword = strdup(line);
        desc->description = fread_string(fl, "build_object");
        if (last_desc)
          last_desc->next = desc;
        else
          obj->ex_description = desc;
        last_desc = desc;
      }
      else goto bad_tag;
      break;
    case 'F':
      if (!strcmp(tag, "flags"))        load_ascii_flags(GET_OBJ_FLAGS(obj), NUM_ITEM_FLAGS, line);
      else goto bad_tag;
      break;
    case 'H':
      if (!strcmp(tag, "hiddenness"))   GET_OBJ_HIDDENNESS(obj) = LIMIT(0, num, 1000);
      else goto bad_tag;
      break;
    case 'L':
      if (!strcmp(tag, "location"))     *location = num;
      else if (!strcmp(tag, "level"))   GET_OBJ_LEVEL(obj) = LIMIT(0, num, LVL_IMPL);
      else goto bad_tag;
      break;
    case 'N':
      if (!strcmp(tag, "name"))         obj->name = strdup(line);
      else goto bad_tag;
      break;
    case 'S':
      if (!strcmp(tag, "shortdesc"))    obj->short_description = strdup(line);
      else if (!strcmp(tag, "spells")) {
        for (last_spell = obj->spell_book; last_spell && last_spell->next; last_spell = last_spell->next);
        while (get_line(fl, line) && *line != '~') {
          CREATE(spell, struct spell_book_list, 1);
          sscanf(line, "%d %d", &spell->spell, &spell->length);
          if (last_spell)
            last_spell->next = spell;
          else /* This means obj->spell_book is NULL */
            obj->spell_book = spell;
          last_spell = spell;
        }
      }
      else goto bad_tag;
      break;
    case 'T':
      if (!strcmp(tag, "type"))         GET_OBJ_TYPE(obj) = LIMIT(0, num, NUM_ITEM_TYPES - 1);
      else if (!strcmp(tag, "timer"))   GET_OBJ_TIMER(obj) = MAX(0, num);
      else if (!strcmp(tag, "triggers")) {
        if (!SCRIPT(obj))
          CREATE(SCRIPT(obj), struct script_data, 1);
        while (get_line(fl, line) && *line != '~') {
          num = real_trigger(atoi(line));
          if (num != NOTHING && (trig = read_trigger(num)))
            add_trigger(SCRIPT(obj), trig, -1);
        }
      }
      else goto bad_tag;
      break;
    case 'V':
      if (!strcmp(tag, "vnum"))         obj->item_number = real_object(num);
      else if (!strcmp(tag, "values")) {
        num = 0;
        while (get_line(fl, line) && *line != '~')
          if (num < NUM_VALUES)
            GET_OBJ_VAL(obj, num++) = atoi(line);
        limit_obj_values(obj);
      }
      else if (!strcmp(tag, "variables")) {
        if (!SCRIPT(obj))
          CREATE(SCRIPT(obj), struct script_data, 1);
        while (get_line(fl, line) && *line != '~') {
          for (value = line; *value; ++value)
            if (*value == ' ') {
              *(value++) = '\0';
              break;
            }
          add_var(&SCRIPT(obj)->global_vars, line, value);
        }
      }
      else goto bad_tag;
      break;
    case 'W':
      if (!strcmp(tag, "weight"))       GET_OBJ_WEIGHT(obj) = MAX(0, f);
      else if (!strcmp(tag, "wear"))    GET_OBJ_WEAR(obj) = num;
      else goto bad_tag;
      break;
    default:
    bad_tag:
      sprintf(buf, "SYSERR: Unknown tag %s in rent file: %s", tag, line);
      log("%s",buf);
      break;
    }
  }

  if (feof(fl)) {
    extract_obj(obj);
    return FALSE;
  }

  /*
   * Check to see if the loaded object has strings that match the 
   * prototype.  If so, replace them.
   */
  #define CHECK_PROTO_STR(address)       do { \
                                           if (!obj->address) \
                                             obj->address = proto->address; \
                                           else if (!*obj->address || (proto->address && *proto->address && !strcmp(obj->address, proto->address))) { \
                                             free(obj->address); \
                                             obj->address = proto->address; \
                                           } \
                                         } while (FALSE);
  #define CHECK_NULL_STR(address, str)   do { \
                                           if (!*obj->address) { \
                                             free(obj->address); \
                                             obj->address = NULL; \
                                           } \
                                           if (!obj->address) \
                                             obj->address = strdup(str); \
                                         } while (FALSE);

  if (GET_OBJ_RNUM(obj) != NOTHING) {
    obj_index[GET_OBJ_RNUM(obj)].number++;

    proto = &obj_proto[GET_OBJ_RNUM(obj)];

    /* What with object weights being recalibrated, we'll overwrite them from
     * player files here. For a while...
     * Once the weights are all updated, it would be a good idea to linkload
     * and save everyone, to change all their object weights. */
    GET_OBJ_WEIGHT(obj) = GET_OBJ_WEIGHT(proto);
    /* We also need to fix the liquid container weights, since they will
     * have been set to empty just now. */
    if (GET_OBJ_TYPE(obj) == ITEM_DRINKCON)
       setup_drinkcon(obj, -1);
    /* END of weight messing-around-with */

    CHECK_PROTO_STR(name);
    CHECK_PROTO_STR(description);
    CHECK_PROTO_STR(short_description);
    CHECK_PROTO_STR(action_description);
    /* See if -all- the extra descriptions are identical. */
    if (obj->ex_description) {
      num = TRUE;
      for (desc = obj->ex_description, last_desc = proto->ex_description;
           desc && last_desc; desc = desc->next, last_desc = last_desc->next)
        if (strcmp(desc->keyword, last_desc->keyword) ||
            strcmp(desc->description, last_desc->description))
          num = FALSE;
      if (desc || last_desc)
        num = FALSE;
      if (num) {
        for (desc = obj->ex_description; desc; desc = last_desc) {
          last_desc = desc->next;
          free(desc->keyword);
          free(desc->description);
          free(desc);
        }
        obj->ex_description = proto->ex_description;
      }
    }
    obj->proto_script = proto->proto_script;
  }

  /* Still no strings?  Put in some defaults so we don't have null 
   * pointers floating around. */
  CHECK_NULL_STR(name, "item undefined-item");
  CHECK_NULL_STR(short_description, "an undefined item");
  CHECK_NULL_STR(description, "An undefined item sits here.");

  #undef CHECK_PROTO_STR
  #undef CHECK_NULL_STR

  return TRUE;
}

bool load_objects(struct char_data *ch)
{
  FILE *fl;
  char line[MAX_INPUT_LENGTH];
  int rent_code;

  fl = open_player_obj_file(GET_NAME(ch), NULL, FALSE);
  if (!fl) return FALSE;


  if (get_line(fl, line) && is_integer(line))
    rent_code = atoi(line);
  else {
    /* Object file may be in the 'old' format.  Attempt to load thusly. */
    sprintf(buf, "Invalid rent code for %s: attempting to load via legacy code...", GET_NAME(ch));
    log("%s",buf);
    fclose(fl);
    if (load_binary_objects(ch)) {
      log("   Success!");
      return TRUE;
    }
    else {
      log("   Failed!");
      send_to_char("\r\n@@W********************* NOTICE *********************\r\n"
                   "There was a problem (error 02) loading your objects from disk.\r\n"
                   "Contact a God for assistance.@@0\r\n", ch);
      sprintf(buf, "%s entering game with no equipment. (error 02)", GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      return FALSE;
    }
  }

  read_objects(ch, fl);
  fclose(fl);

  return TRUE;
}

static void read_objects(struct char_data *ch, FILE *fl)
{
  int i, depth, location;
  struct obj_data *obj, *containers[MAX_CONTAINER_DEPTH];

  for (i = 0; i < MAX_CONTAINER_DEPTH; ++i)
    containers[i] = NULL;

  while (!feof(fl)) {
    if (!build_object(fl, &obj, &location))
      break;
    location = auto_equip(ch, obj, location);
    depth = MAX(0, -location);
    for (i = MAX_CONTAINER_DEPTH - 1; i >= depth; --i)
      containers[i] = NULL;
    containers[depth] = obj;
    if (location < 0) {
      if (containers[depth - 1])
        obj_to_obj(obj, containers[depth - 1]);
      else
        location = WEAR_INVENTORY;
    }
    if (location == WEAR_INVENTORY)
      obj_to_char(obj, ch);
  }
}

void load_quests(struct char_data *ch)
{
   FILE *fl;
   char fname[MAX_STRING_LENGTH];
   int n;
   struct quest_list *plyrqsts,*curr;
   int qid,qst,qnum_vars;
   char var_name[21];  char var_val[21];
   bool skipquest, duplicates = FALSE, nonexistent = FALSE;
   struct quest_var_list *last_var;

   if (!get_pfilename(GET_NAME(ch), fname, QUEST_FILE)) {
           ch->quests= (struct quest_list *)NULL;
   } else {
      if (!(fl = fopen(fname, "r"))) {
         if (errno != ENOENT) {        /* if it fails, NOT because of no file */
            sprintf(buf1, "SYSERR: READING QUEST FILE %s (5)", fname);
            perror(buf1);
            send_to_char("\r\n********************* NOTICE *********************\r\n"
               "There was a problem loading your quests from disk.\r\n"
               "Contact a God for assistance.\r\n", ch);
         }
         sprintf(buf, "%s starting up with no quests.", GET_NAME(ch));
         mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
         ch->quests= (struct quest_list *)NULL;
      } else {
         while(!feof(fl)) {
            char buf2[256];
            get_line(fl, buf2);

            if (feof(fl)) break;

            if (sscanf(buf2, "%i %i %i\n", &qid, &qst, &qnum_vars) == 2) {
               qnum_vars = 0;
            }

            skipquest = FALSE;

            /* See if there's a quest duplication bug
             * (see if the char already has this quest) */
            for (curr = ch->quests; curr; curr = curr->next) {
               if (curr->quest_id == qid) {
                  if (!duplicates) {
                     duplicates = TRUE;
                     sprintf(buf,
                           "SYSERR: Player %s had duplicate of quest %d (skipped) (possibly more)",
                           GET_NAME(ch), qid);
                     mudlog(buf, NRM, LVL_GOD, TRUE);
                  }
                  skipquest = TRUE;
                  break;
               }
            }

            /* This quest isn't valid for whatever reason. */
            if (!skipquest && real_quest(qid) < 0) {
               skipquest = TRUE;
               if (!nonexistent) {
                  nonexistent = TRUE;
                  sprintf(buf,
                        "SYSERR: Player %s had nonexistent quest %d (skipped) (possibly more)",
                        GET_NAME(ch), qid);
                  mudlog(buf, NRM, LVL_GOD, TRUE);
               }
            }

            if (skipquest) {
               for (n = 0; n < qnum_vars; n++) {
                  /* Eat the data */
                  if (fscanf(fl, "%s %s\n", var_name, var_val) < 2)
                     break;
               }
               continue;
            }

            CREATE(curr, struct quest_list, 1);
            curr->quest_id = qid;
            curr->stage = qst;
            curr->variables = NULL;

            if (qnum_vars) {
               int n = 0;
               last_var = NULL;

               while(n < qnum_vars) {
                  fscanf(fl, "%s %s\n", var_name, var_val);

                  if (last_var == NULL) {
                     CREATE(curr->variables, struct quest_var_list,1);
                     CREATE(curr->variables->var, char, 21);
                     CREATE(curr->variables->val, char, 21);

                     strncpy(curr->variables->var, var_name, 20);
                     strncpy(curr->variables->val, var_val, 20);

                     curr->variables->var[20] = '\0';
                     curr->variables->val[20] = '\0';

                     curr->variables->next = NULL;

                     last_var = curr->variables;
                  } else {
                     CREATE(last_var->next, struct quest_var_list, 1);
                     CREATE(last_var->next->var, char, 21);
                     CREATE(last_var->next->val, char, 21);

                     strncpy(last_var->next->var, var_name, 20);
                     strncpy(last_var->next->val, var_val, 20);

                     last_var->next->var[20] = '\0';
                     last_var->next->val[20] = '\0';

                     last_var->next->next = NULL;

                     last_var = last_var->next;
                  }

                  n++;
               }
            }

            curr->next = (struct quest_list *)NULL;
            plyrqsts = ch->quests;
            if (plyrqsts == (struct quest_list *)NULL)
               ch->quests = curr;
            else {
               while (plyrqsts->next) plyrqsts=plyrqsts->next;
               plyrqsts->next = curr;
            }
         }
         fclose(fl);
      }
   } /* Done getting quest info */
}


static struct obj_data *restore_binary_object(struct obj_file_elem *store, int *locate)
{
  struct obj_data *obj;
  int j = 0, rnum;
  char *list_parse, *spell_parse, *list;
  struct spell_book_list *entry;

  if ((rnum = real_object(store->item_number)) < 0) return NULL;

  obj = read_object(store->item_number, VIRTUAL);
  *locate = (int) store->locate;
  GET_OBJ_VAL(obj, 0) = store->value[0];
  GET_OBJ_VAL(obj, 1) = store->value[1];
  GET_OBJ_VAL(obj, 2) = store->value[2];
  GET_OBJ_VAL(obj, 3) = store->value[3];
  GET_OBJ_FLAGS(obj)[0] = store->extra_flags;
  GET_OBJ_WEIGHT(obj) = store->weight;
  GET_OBJ_TIMER(obj) = store->timer;
  GET_OBJ_HIDDENNESS(obj) = store->hiddenness;

  /* Use the prototype's values for these, since they were usually saved in a
   * corrupted state in binary files. */
  GET_OBJ_EFF_FLAGS(obj)[0] = obj_proto[rnum].obj_flags.effect_flags[0];
  GET_OBJ_EFF_FLAGS(obj)[1] = obj_proto[rnum].obj_flags.effect_flags[1];
  GET_OBJ_EFF_FLAGS(obj)[2] = obj_proto[rnum].obj_flags.effect_flags[2];

  /* Handling spellbooks
   *
   * The spells written in it have been stored as a string, which
   * must be parsed so that the spell list can be restored.
   */
  if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK) {
      GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) = LEGACY_MAX_SPELLBOOK_PAGES;
      if (store->spells_in_book[0]) {
         list = store->spells_in_book;
         CREATE(obj->spell_book, struct spell_book_list, 1);
         entry = obj->spell_book;
         while ((list_parse = strsep(&list, ",")) && strlen(store->spells_in_book)) {
            if (list_parse && strlen(list_parse)) {
               if (j > 0) {
                  CREATE(entry->next, struct spell_book_list, 1);
                  entry = entry->next;
               }

               spell_parse = strsep(&list_parse, "_");
               if (!spell_parse || !*spell_parse) {
                  /* Corrupt spell list - just put magic missile */
                  entry->spell = SPELL_MAGIC_MISSILE;
                  entry->length = 1;
                  sprintf(buf, "SYSERR: restore_binary_object() found corrupt spellbook list '%s'",
                        store->spells_in_book);
                  log("%s",buf);
               } else {
                  entry->spell = atoi(spell_parse);
                  spell_parse = strsep(&list_parse, "_");
                  if (!spell_parse || !*spell_parse) {
                     /* Length corrupt - just put 1 page */
                     entry->length = 1;
                     sprintf(buf, "SYSERR: restore_binary_object() found corrupt spellbook list '%s'",
                           store->spells_in_book);
                     log("%s",buf);
                  } else {
                     entry->length = atoi(spell_parse);
                  }
               }
               j++;
            }
         }
      }
   }

  for (j = 0; j < LEGACY_MAX_OBJ_AFFECT; j++) {
    obj->applies[j].location = store->affected[j].location;
    obj->applies[j].modifier = store->affected[j].modifier;
  }

  return obj;
}

static bool load_binary_objects(struct char_data *ch)
{
  FILE *fl;
  struct obj_file_elem object;
  struct rent_info rent;
  struct obj_data *obj;
  int locate, j, eq = 0;
  struct obj_data *obj1;
  struct obj_data *cont_row[MAX_CONTAINER_DEPTH];

  fl = open_player_obj_file(GET_NAME(ch), NULL, FALSE);
  if (!fl) return FALSE;

  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);

  for (j = 0; j < MAX_CONTAINER_DEPTH; j++)
    cont_row[j] = NULL; /* empty all cont lists (you never know ...) */

  while (!feof(fl)) {
    eq = 0;
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("Reading object file: load_binary_objects()");
      fclose(fl);
      return TRUE;
    }

    if (!feof(fl))
      if ((obj = restore_binary_object(&object, &locate))) {
        eq = binary_auto_equip(ch, obj, locate);
        /* 5/5/01 - Zantir - Found a bug in the auto_equip code
           that would crash the mud if a player couldn't wear an
           container that the mud thought they were already
           wearing. So now the auto_equip function returns a value,
           if a 1 isn't returned the assume the item can't be
           reworn so set the locate value to 0. */
        if (eq == 0)
          locate = 0;

        /*
         * what to do with a new loaded item:
         *
         * if there's a list with <locate> less than 1 below this:
         * (equipped items are assumed to have <locate>==0 here) then its
         * container has disappeared from the file   *gasp*
         * -> put all the list back to ch's inventory
         *
         * if there's a list of contents with <locate> 1 below this:
         * check if it's a container
         * - if so: get it from ch, fill it, and give it back to ch (this way the
         * container has its correct weight before modifying ch)
         * - if not: the container is missing -> put all the list to ch's inventory
         *
         * for items with negative <locate>:
         * if there's already a list of contents with the same <locate> put obj to it
         * if not, start a new list
         *
         * Confused? Well maybe you can think of some better text to be put here ...
         *
         * since <locate> for contents is < 0 the list indices are switched to
         * non-negative
         */

         if (locate > 0) { /* item equipped */
           for (j = MAX_CONTAINER_DEPTH-1; j > 0; --j)
             if (cont_row[j]) { /* no container -> back to ch's inventory */
               for (; cont_row[j]; cont_row[j] = obj1) {
                 obj1 = cont_row[j]->next_content;
                 obj_to_char(cont_row[j], ch);
               }
               cont_row[j] = NULL;
             }
           if (cont_row[0]) { /* content list existing */
             if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
               /* rem item ; fill ; equip again */
               obj = unequip_char(ch, locate - 1);
               obj->contains = NULL; /* should be empty - but who knows */
               for (; cont_row[0]; cont_row[0] = obj1) {
                 obj1 = cont_row[0]->next_content;
                 obj_to_obj(cont_row[0], obj);
               }
               equip_char(ch, obj, locate - 1);
             } else { /* object isn't container -> empty content list */
               for (; cont_row[0]; cont_row[0] = obj1) {
                 obj1 = cont_row[0]->next_content;
                 obj_to_char(cont_row[0], ch);
               }
               cont_row[0] = NULL;
             }
           }
         } else { /* locate <= 0 */
           for (j = MAX_CONTAINER_DEPTH - 1; j > -locate; --j)
             if (cont_row[j]) { /* no container -> back to ch's inventory */
               for (; cont_row[j]; cont_row[j] = obj1) {
                 obj1 = cont_row[j]->next_content;
                 obj_to_char(cont_row[j], ch);
               }
               cont_row[j] = NULL;
             }

           if (j == -locate && cont_row[j]) { /* content list existing */
             if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
               /* take item ; fill ; give to char again */
               obj_from_char(obj);
               obj->contains = NULL;
               for (; cont_row[j]; cont_row[j] = obj1) {
                 obj1 = cont_row[j]->next_content;
                 obj_to_obj(cont_row[j], obj);
               }
               obj_to_char(obj, ch); /* add to inv first ... */
             } else { /* object isn't container -> empty content list */
               for (; cont_row[j]; cont_row[j] = obj1) {
                 obj1 = cont_row[j]->next_content;
                 obj_to_char(cont_row[j], ch);
               }
               cont_row[j] = NULL;
             }
           }

           if (locate < 0 && locate >= -MAX_CONTAINER_DEPTH) {
            /* let obj be part of content list
               but put it at the list's end thus having the items
               in the same order as before renting */
             obj_from_char(obj);
             if ((obj1 = cont_row[-locate-1])) {
               while (obj1->next_content)
                 obj1 = obj1->next_content;
               obj1->next_content = obj;
             } else
               cont_row[-locate-1] = obj;
           }
         }
      }
  }

  fclose(fl);

  return TRUE;
}

void auto_save_all(void)
{
   struct descriptor_data *d;
   for (d = descriptor_list; d; d = d->next) {
      if (d->connected == CON_PLAYING && !IS_NPC(d->character) &&
            PLR_FLAGGED(d->character, PLR_AUTOSAVE)) {
         GET_QUIT_REASON(d->character) = QUIT_AUTOSAVE;
         save_player(d->character);
         REMOVE_FLAG(PLR_FLAGS(d->character), PLR_AUTOSAVE);
      }
   }
}


/*************************************************************************
 * Routines used for the receptionist                                    *
 *************************************************************************/

static int report_unrentables(struct char_data *ch, struct char_data *recep,
                              struct obj_data *obj)
{
  int unrentables = 0;

  if (obj) {
    if (is_object_unrentable(obj)) {
      unrentables = 1;
      act("$n tells you, 'You cannot store $t.'",
          FALSE, recep, (void *) OBJS(obj, ch), ch, TO_VICT);
    }
    unrentables += report_unrentables(ch, recep, obj->contains);
    unrentables += report_unrentables(ch, recep, obj->next_content);
  }
  return unrentables;
}

static int list_unrentables(struct char_data *ch, struct char_data *receptionist)
{
   int i, unrentables;

   unrentables = report_unrentables(ch, receptionist, ch->carrying);
   for (i = 0; i < NUM_WEARS; i++)
      unrentables += report_unrentables(ch, receptionist, GET_EQ(ch,i));

   return unrentables;
}

void extract_objects(struct char_data *ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; ++i)
    if (GET_EQ(ch, i))
      extract_obj(GET_EQ(ch, i));

  while (ch->carrying)
    extract_obj(ch->carrying);
}

static int gen_receptionist(struct char_data * ch, struct char_data * recep,
                     int cmd, char *arg, int mode)
{
  int quit_mode = QUIT_RENT;

  if (!ch->desc || IS_NPC(ch))
    return FALSE;

  if (!CMD_IS("rent"))
    return FALSE;

  if (!AWAKE(recep)) {
    act("$E is unable to talk to you...", FALSE, ch, 0, recep, TO_CHAR);
    return TRUE;
  }

  if (!CAN_SEE(recep, ch) && GET_LEVEL(ch) < LVL_IMMORT) {
    act("$n says, 'I don't deal with people I can't see!'", FALSE, recep, 0, 0, TO_ROOM);
    return TRUE;
  }

  if (list_unrentables(ch, recep)) {
    act("$N shakes $M head at $n.", TRUE, ch, 0, recep, TO_ROOM);
    return TRUE;
  }

  if (mode == SAVE_CRYO) {
    act("$n stores your belongings and helps you into your private chamber.\r\n"
        "A white mist appears in the room, chilling you to the bone...\r\n"
        "You begin to lose consciousness...",
        FALSE, recep, 0, ch, TO_VICT);
    quit_mode = QUIT_CRYO;
    sprintf(buf, "%s has cryo-rented.", GET_NAME(ch));
  }
  else {
    act("@@W$n@@W tells you, 'Rent?  Sure, come this way!'\r\n"
        "$U$n stores your belongings and helps you into your private chamber.&0",
        FALSE, recep, 0, ch, TO_VICT);
    quit_mode = QUIT_RENT;
    sprintf(buf, "%s has rented in %s (%d).", GET_NAME(ch),
        world[ch->in_room].name,
        world[ch->in_room].vnum);
  }

  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
  act("$n helps $N into $S private chamber.", FALSE, recep, 0, ch, TO_NOTVICT);

  remove_player_from_game(ch, quit_mode);
  return TRUE;
}

SPECIAL(receptionist)
{
  return gen_receptionist(ch, me, cmd, argument, SAVE_RENT);
}


SPECIAL(cryogenicist)
{
  return gen_receptionist(ch, me, cmd, argument, SAVE_CRYO);
}

/* If quiet==TRUE, minor feedback will be suppressed.
 * But not errors. */
FILE *open_player_obj_file(char *player_name, struct char_data *ch, bool quiet)
{
  FILE *fl;
  char filename[MAX_INPUT_LENGTH];

  if (!get_pfilename(player_name, filename, OBJ_FILE)) {
    sprintf(buf, "SYSERR: Unable to construct filename to load objects for %s", GET_NAME(ch));
    log("%s",buf);
    if (ch)
      send_to_char("Couldn't construct the filename!\r\n", ch);
    return NULL;
  }

  if (!(fl = fopen(filename, "r"))) {
    if (errno != ENOENT) {
      sprintf(buf, "SYSERR: READING OBJECT FILE %s (5)", filename);
      perror(buf);
      if (ch) {
        sprintf(buf, "&1&bI/O Error %d&0: %s\r\n", errno, strerror(errno));
        send_to_char(buf, ch);
      }
    } else if (ch && !quiet) {
      sprintf(buf, "There is no object file for %s.\r\n", player_name);
      send_to_char(buf, ch);
    }
    return NULL;
  }
  return fl;
}

/* convert_player_obj_file
 *
 * The current player object file format is ASCII-based.
 * Sometimes, object files in the older format might be present due to
 * restoring players from backups.  This function is used to convert the old
 * file into the ASCII format.
 */
bool convert_player_obj_file(char *player_name, struct char_data *ch)
{
   FILE *fl, *fnew;
   char filename[MAX_INPUT_LENGTH];
   char tempfilename[MAX_INPUT_LENGTH];
   char line[MAX_INPUT_LENGTH];
   struct rent_info rent;
   struct obj_file_elem object;
   struct obj_data *obj;
   int eq, locate;

   fl = open_player_obj_file(player_name, ch, TRUE);
   if (!fl) return FALSE;

  if (get_line(fl, line) && is_integer(line)) {
     /* File is modern and doesn't need updating */
     fclose(fl);
     return FALSE;
  }

   fclose(fl);
   fl = open_player_obj_file(player_name, ch, TRUE);
   if (!fl) {
      mudlog("SYSERR: convert_player_file couldn't reopen object file!",
            NRM, LVL_GOD, TRUE);
      return FALSE;
   }

   /* Prepare output file */
   if (!get_pfilename(player_name, filename, OBJ_FILE)) {
      sprintf(buf, "SYSERR: Unable to construct filename to save objects for %s", player_name);
      log("%s",buf);
      fclose(fl);
      return FALSE;
   }

   sprintf(tempfilename, "%s.temp", filename);
   if (!(fnew = fopen(tempfilename, "w"))) {
      sprintf(buf, "SYSERR: Couldn't open player file %s for write", tempfilename);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      fclose(fl);
      return FALSE;
   }

   if (feof(fl)) {
      sprintf(buf, "SYSERR: Object file for %s is too small", player_name);
      log("%s",buf);
      fclose(fl);
      fclose(fnew);
      return FALSE;
   }

   fread(&rent, sizeof(struct rent_info), 1, fl);
   write_rent_code(fnew, rent.rentcode);

   while (!feof(fl)) {
      eq = 0;
      fread(&object, sizeof(struct obj_file_elem), 1, fl);
      if (ferror(fl)) {
         perror("Reading player object file: convert_player_obj_file()");
         fclose(fl);
         fclose(fnew);
         return FALSE;
      }

      if ((obj = restore_binary_object(&object, &locate))) {
         /* Writing 0 for the location as I don't care to convert it */
         /* Yes, the value we just read would not be correct... */
         write_object_record(obj, fnew, WEAR_INVENTORY);
         extract_obj(obj);
      }
   }

   fclose(fl);
   fclose(fnew);

   if (rename(tempfilename, filename)) {
      sprintf(buf, " * * * Error renaming %s to %s: %s * * *",
            tempfilename, filename, strerror(errno));
      log("%s",buf);
      return FALSE;
   } else {
      sprintf(buf, "Player object file converted to ASCII format: %s", player_name);
      log("%s",buf);
      if (ch) {
         strcat(buf, "\r\n");
         page_string(ch, buf);
      }
   }

   return TRUE;
}

void convert_player_obj_files(struct char_data *ch)
{
   int i;
   int converted = 0;

   for (i = 0; i <= top_of_p_table; ++i) {
      if (convert_player_obj_file(player_table[i].name, ch))
         converted++;
   }

   sprintf(buf, "Examined %d player object file%s and updated %d.\r\n",
         top_of_p_table + 1, top_of_p_table + 1 == 1 ? "" : "s", converted);
   send_to_char(buf, ch);
}

void convert_single_player_obj_file(struct char_data *ch, char *name)
{
   if (!convert_player_obj_file(name, ch))
      send_to_char("The object file was not converted.\r\n", ch);
}

/* save_player
 *
 * Saves all data related to a player: character, objects, and quests.
 */
void save_player(struct char_data *ch)
{
   int quit_mode;

   REMOVE_FLAG(PLR_FLAGS(ch), PLR_AUTOSAVE);
   quit_mode = GET_QUIT_REASON(ch);

   switch (quit_mode) {
      case QUIT_CAMP:
      case QUIT_RENT:
      case QUIT_TIMEOUT:
      case QUIT_CRYO:
      case QUIT_QUITMORT:
      case QUIT_QUITIMM:
        extract_unrentables(ch);
        break;
   }

   if (quit_mode == QUIT_QUITMORT)
      delete_player_obj_file(ch);
   else
      save_player_objects(ch);
   save_quests(ch);

   /* Set the load room */
   switch (quit_mode) {
      case QUIT_RENT:
      case QUIT_CRYO:
      case QUIT_CAMP:
      case QUIT_WRENT:
         GET_LOADROOM(ch) = world[ch->in_room].vnum;
         break;
      case QUIT_QUITIMM:
      case QUIT_QUITMORT:
         GET_LOADROOM(ch) = GET_HOMEROOM(ch);
         break;
      case QUIT_TIMEOUT:
      case QUIT_HOTBOOT:
      case QUIT_PURGE:
      case QUIT_AUTOSAVE:
      default:
         /* Imms stay where they are, but morts will reenter in the same place
          * they entered the game last time. */
         if (GET_LEVEL(ch) >= LVL_IMMORT)
            GET_LOADROOM(ch) = world[ch->in_room].vnum;
         ;
   }

   if (quit_mode == QUIT_CRYO) {
      SET_FLAG(PLR_FLAGS(ch), PLR_CRYO);
   }

   GET_QUIT_REASON(ch) = quit_mode;
   save_player_char(ch);
}


/***************************************************************************
 * $Log: pfiles.c,v $
 * Revision 1.108  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.107  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.106  2009/03/09 02:22:32  myc
 * Added a hack to print_obj_to_char to pass in additional arguments
 * for boards.
 *
 * Revision 1.105  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.104  2009/02/16 14:21:04  myc
 * Save and load decomp timer from file for corpses.
 *
 * Revision 1.103  2008/09/29 05:09:54  jps
 * Fix incoming container weights
 *
 * Revision 1.102  2008/09/22 03:05:12  jps
 * Update loaded objects' weights from the proto values.
 *
 * Revision 1.101  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.100  2008/09/11 03:35:46  jps
 * Don't reset the entry point when autosaving.
 *
 * Revision 1.99  2008/09/08 05:24:50  jps
 * Put autosave as the "quit reason" when autosaving. This is a temporary fix
 * that should stop people from losing keys when autosave code thinks their
 * quit reason is something else, like renting.
 *
 * Revision 1.98  2008/09/01 22:25:28  jps
 * Cause immortals to stay in the same room across timeouts, hotboots, and purges.
 *
 * Revision 1.97  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.96  2008/08/31 23:34:20  jps
 * Cause imms who quit to reenter the game in their home rooms.
 *
 * Revision 1.95  2008/08/31 21:44:03  jps
 * Renamed StackObjs and StackMobs prefs to ExpandObjs and ExpandMobs.
 *
 * Revision 1.94  2008/08/30 18:20:53  myc
 * You can now rent items with NOTHING vnums.
 *
 * Revision 1.93  2008/08/29 04:16:26  myc
 * Fixed the show rent command.  It now supports stacking objects.
 * And the equipment displays correctly too.
 *
 * Revision 1.92  2008/08/19 01:58:21  jps
 * Extract unrentable objects from a character when camping.
 *
 * Revision 1.91  2008/08/17 20:46:21  jps
 * Cause objects loaded from binary files to have their effect flags
 * reset to those of the prototype.
 *
 * Revision 1.90  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.89  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.88  2008/07/27 05:31:17  jps
 * Refactored the messages for entering/leaving game based on save code.
 * Added a new save_player function, which saves everything.
 *
 * Revision 1.87  2008/07/27 01:33:38  jps
 * Added room name and vnum to rented message.
 *
 * Revision 1.86  2008/07/26 22:52:11  jps
 * Detect corrupt spellbooks when restoring binary objects, so as not to crash.
 *
 * Revision 1.85  2008/07/26 21:49:53  jps
 * Skip binary obj files in show_rent, and advise user what to do.
 *
 * Revision 1.84  2008/07/26 21:34:33  jps
 * Added functions for converting old binary object files into ASCII format.
 *
 * Revision 1.83  2008/07/22 06:12:17  myc
 * Missing a break in a switch statement so 'show rent' was showing the
 * wrong message.
 *
 * Revision 1.82  2008/07/13 19:04:52  jps
 * Added a hotboot rent code, which allows people to save their keys
 * over a hotboot.
 *
 * Revision 1.81  2008/07/10 20:38:02  myc
 * Show rent was showing wrong name in message
 *
 * Revision 1.80  2008/07/10 20:17:37  myc
 * Increment world count for objects loaded by rent code.
 *
 * Revision 1.79  2008/06/21 08:53:09  myc
 * Use fread_string to read objects' action desc.  Check prototypes
 * for a string before attempting to string compare.
 *
 * Revision 1.78  2008/06/19 18:53:12  myc
 * Spellbook pages now saved as an item value.
 *
 * Revision 1.77  2008/06/08 03:21:58  jps
 * Fix text formatting of receptionist message.
 *
 * Revision 1.76  2008/06/08 00:58:04  jps
 * Ensure that the number of pages in a spellbook will be written when
 * saving a spellbook, even if the spellbook is blank.
 *
 * Revision 1.75  2008/06/07 19:35:39  jps
 * Write number of spellbook pages when saving. Limit to a maximum value.
 *
 * Revision 1.74  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.73  2008/06/07 18:52:13  myc
 * Fix spell loading again.
 *
 * Revision 1.72  2008/06/07 18:48:21  myc
 * Load spells from spellbook correctly.
 *
 * Revision 1.71  2008/06/07 18:45:39  myc
 * Don't try to equip an item in the inventory slot.
 *
 * Revision 1.70  2008/06/05 02:07:43  myc
 * Completely rewrote the rent file saving and loading to use
 * an ascii text format.  Some of the old legacy binary code
 * remains so that we don't have to actively convert old
 * object files to the new format.  When old rent files are
 * encountered, they are lazily loaded into the game, and
 * replaced by the new format when the player is saved.
 *
 * Revision 1.69  2008/05/26 18:24:48  jps
 * Removed code that deletes player object files.
 *
 * Revision 1.68  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.67  2008/04/13 03:41:34  jps
 * Made quest file saving safer by using the write-to-temp-file-and-rename
 * trick.
 *
 * Revision 1.66  2008/04/02 04:55:59  myc
 * Got rid of the coins struct.
 *
 * Revision 1.65  2008/03/30 17:28:57  jps
 * Rename objsave.c to pfiles.c.
 * Change message about loading with no quests from "entering game" to
 * "starting up", because it isn't necessarily happening at the "enter game"
 * phase (i.e. when you press 1 at the login menu).
 *
 * Revision 1.64  2008/03/30 17:10:47  jps
 * Splitting crash_load and naming it "playerload_" objs/quest.
 *
 * Revision 1.63  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.61  2008/03/27 18:38:54  jps
 * Stop loading spell flags from obj save files. They're corrupt.
 *
 * Revision 1.60  2008/03/27 17:26:40  jps
 * Save spell effect flags with objects.
 *
 * Revision 1.59  2008/03/22 17:11:38  jps
 * Change unrentable check not to look for type KEY, since keys have the
 * ITEM_NORENT flag placed upon them at creation time.
 *
 * Revision 1.58  2008/03/22 16:29:49  jps
 * Fix text format in receptionist speech.
 *
 * Revision 1.57  2008/03/16 07:21:39  jps
 * Remove a debug printf
 *
 * Revision 1.56  2008/03/15 04:49:36  jps
 * Cause one log message to be sent to gods when a player with a
 * problematic quest file logs in.
 *
 * Revision 1.55  2008/03/15 04:44:04  jps
 * Don't mudlog a duplicated-quest error - too much spam.
 *
 * Revision 1.54  2008/03/15 04:38:56  jps
 * Fix for loading a quest file with duplicated quests (I still don't
 * know how they got duplicated, though).  Removed some debug printages.
 *
 * Revision 1.53  2008/03/11 04:33:11  jps
 * Properly skip over nonexistent quests in player quest save files.
 *
 * Revision 1.52  2008/03/10 18:01:17  myc
 * Instead of removing berserking when camping/renting, we'll remove
 * it in the save-player module.
 *
 * Revision 1.51  2008/03/05 05:21:56  myc
 * Fixed boot_obj_limit to not use char_file_u.  It's not being called
 * though.
 *
 * Revision 1.50  2008/03/05 03:03:54  myc
 * get_filename is renamed to get_pfilename
 *
 * Revision 1.49  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.48  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.47  2008/01/27 21:14:59  myc
 * Make players stop berserking and zero rage when renting.
 *
 * Revision 1.46  2008/01/09 13:04:40  jps
 * Removed the "offer" command and cleaned up.
 *
 * Revision 1.45  2008/01/05 05:38:00  jps
 * Changed name of save_char() to save_player().
 *
 * Revision 1.44  2008/01/01 04:34:25  jps
 * Fix punctuation in receptionist speech.
 *
 * Revision 1.43  2007/12/19 20:55:20  myc
 * save_player() no longer requires a save room (which wasn't being used
 * anyway).
 *
 * Revision 1.42  2007/10/11 20:14:48  myc
 * Made offer a little less spammy.
 *
 * Revision 1.41  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  The hiddenness field in the object
 * file element replaced the bitvector field, which was unused.
 *
 * Revision 1.40  2007/09/03 19:02:24  jps
 * Make receptionist offer/rent conversation more sensible when you have
 * unrentable items.
 *
 * Revision 1.39  2007/08/22 17:56:19  jps
 * Remove the "Autosaving...." message.
 *
 * Revision 1.38  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.37  2007/04/15 06:21:32  jps
 * Fix saved spellbooks being reloaded broken.
 *
 * Revision 1.36  2007/03/31 14:38:03  myc
 * Made only 'offer' tell how many items the player has, instead of
 * 'rent' too.
 *
 * Revision 1.35  2007/03/27 04:27:05  myc
 * Receptionist will tell you how many items you have even if less than 50.
 *
 * Revision 1.34  2006/11/20 21:21:55  jps
 * Stop "show rent" from crashing the mud when a player has
 * too much stuff.
 *
 * Revision 1.33  2006/11/18 18:55:09  jps
 * Properly re-equip items in WEAR_HOLD2 when reentering the game.
 *
 * Revision 1.32  2002/09/20 03:49:20  jjl
 * Fix the reading of quest files so the old no variable style
 * can be read, along with the new style with a variable count.
 *
 * Revision 1.31  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.30  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.29  2001/08/04 12:14:48  mtp
 * moved the create/free portion of the quest read to hopefully avoid
 * unnecessary log messages and memory munging for people with empty quest files
 *
 * Revision 1.28  2001/05/06 15:01:47  dce
 * Fixed a crash bug in autoequip.
 *
 * Revision 1.27  2001/03/24 19:49:45  dce
 * Players with objects that are higher than their level
 * will have the objects autoremoved when unrenting.
 *
 * Revision 1.26  2001/03/07 03:14:28  dce
 * Gods can now rent while invis.
 *
 * Revision 1.25  2001/01/04 23:12:52  mtp
 * removed dodgy fprintf() which was referencing non-existent obj
 * hopefully this will now allow restore of dual wield, 2H wield on unrent
 *
 * Revision 1.24  2000/12/22 01:34:00  mtp
 * autowear of 2Hander and snd wielded weapons
 *
 * Revision 1.23  2000/11/26 20:28:31  mtp
 * oops..bug which quitted load oif no quest file found which stopped
 * load of eq
 *
 * Revision 1.22  2000/11/24 19:17:01  rsd
 * Altered comment header and added missing and back rlog
 * messages from prior to the addition of the $log$ string.
 * Also move the log string to the proper location.
 *
 * Revision 1.21  2000/11/15 00:42:44  mtp
 * remove non existent quests from players when they log in
 *
 * Revision 1.20  2000/11/03 05:37:17  jimmy
 * Removed the quest.h file from structs.h arg!! and placed it
 * only in the appropriate files
 * Updated the dependancies in the Makefile and created
 * make supahclean.
 *
 * Revision 1.19  2000/11/01 00:21:15  mtp
 * rechecked in 1.16 with the quests pointer being set to null (as in
 * changes 1.17 and 1.18) to get logging correct
 *
 * Revision 1.18  2000/10/31 22:26:42  mtp
 * more nulling of quests pointers ...
 *
 * Revision 1.17  2000/10/31 21:09:45  mtp
 * added explicit set of quests to null if no quests loaded to fix stat_char crash?
 *
 * Revision 1.16  2000/10/27 00:34:45  mtp
 * extra code to save quests and to load them
 *
 * Revision 1.15  2000/10/12 21:15:55  cmc
 * oops.. long int format, not regular int.
 *
 * Revision 1.14  2000/10/12 21:13:53  cmc
 * show how many items you have when you are over the max to rent!
 *
 * Revision 1.13  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.12  1999/09/04 22:13:11  mud
 * fixed unused variable warning
 *
 * Revision 1.11  1999/09/04 18:46:52  jimmy
 * More small but important bug fixes found with insure.  These are all runtime fixes.
 *
 * Revision 1.10  1999/08/13 15:31:01  dce
 * Fixed has rented message.
 *
 * Revision 1.9  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.8  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.7  1999/05/04 18:03:09  dce
 * Offer is fixed
 *
 * Revision 1.6  1999/03/03 20:11:02  jimmy
 * Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
 * Spellbooks now have to be held to scribe as well as a quill in the other hand.
 *
 * -fingon
 *
 * Revision 1.5  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.4  1999/02/06 02:25:31  jimmy
 * ok, This fixes the pwipe problem, apparently
 * my change didn't make it into the src last time around
 *
 * Revision 1.3  1999/02/05 07:47:42  jimmy
 * Added Poofs to the playerfile as well as 4 extra strings for
 * future use.  fingon
 *
 * Revision 1.2  1999/01/31 21:57:39  mud
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.108
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.107 2009/03/09 04:33:20 jps Exp jps $
d111 1
a111 1
    log(buf);
d115 1
a115 1
    log(buf);
d431 1
a431 1
      log(buf);
d439 1
a439 1
      log(buf);
d481 1
a481 1
      log(buf);
d485 1
a485 1
      log(buf);
d602 1
a602 1
    log(buf);
d731 1
a731 1
      log(buf);
d832 1
a832 1
    log(buf);
d1069 1
a1069 1
                  log(buf);
d1078 1
a1078 1
                     log(buf);
d1367 1
a1367 1
    log(buf);
d1428 1
a1428 1
      log(buf);
d1443 1
a1443 1
      log(buf);
d1476 1
a1476 1
      log(buf);
d1480 1
a1480 1
      log(buf);
d1574 3
@


1.107
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.106 2009/03/09 02:22:32 myc Exp jps $
d1549 1
a1549 1
         GET_LOADROOM(ch) = GET_HOME(ch);
d1574 4
@


1.106
log
@Added a hack to print_obj_to_char to pass in additional arguments
for boards.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.105 2009/03/08 23:34:14 jps Exp myc $
d36 1
d1574 4
@


1.105
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.104 2009/02/16 14:21:04 myc Exp jps $
d410 1
a410 1
      print_obj_to_char(display, ch, SHOW_SHORT_DESC | SHOW_FLAGS);
d1573 3
@


1.104
log
@Save and load decomp timer from file for corpses.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.103 2008/09/29 05:09:54 jps Exp myc $
d25 1
a25 1
#include "spells.h"
d1573 3
@


1.103
log
@Fix incoming container weights
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.102 2008/09/22 03:05:12 jps Exp jps $
d231 2
d635 1
d1573 3
@


1.102
log
@Update loaded objects' weights from the proto values.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.101 2008/09/22 02:09:17 jps Exp jps $
d761 2
a766 1
    proto = &obj_proto[GET_OBJ_RNUM(obj)];
d768 6
d1570 3
@


1.101
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.100 2008/09/11 03:35:46 jps Exp jps $
d761 4
d766 1
d1563 4
@


1.100
log
@Don't reset the entry point when autosaving.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.99 2008/09/08 05:24:50 jps Exp jps $
d228 1
a228 1
  fprintf(fl, "weight: %d\n", GET_OBJ_WEIGHT(obj));
d589 1
d612 1
d720 1
a720 1
      if (!strcmp(tag, "weight"))       GET_OBJ_WEIGHT(obj) = MAX(0, num);
d1558 3
@


1.99
log
@Put autosave as the "quit reason" when autosaving. This is a temporary fix
that should stop people from losing keys when autosave code thinks their
quit reason is something else, like renting.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.98 2008/09/01 22:25:28 jps Exp jps $
a1530 1
      case QUIT_AUTOSAVE:
d1536 1
d1556 5
@


1.98
log
@Cause immortals to stay in the same room across timeouts, hotboots, and purges.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.97 2008/09/01 22:15:59 jps Exp jps $
d1226 1
d1531 1
d1556 3
@


1.97
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.96 2008/08/31 23:34:20 jps Exp jps $
d1536 4
a1539 2
         /* Don't change the loadroom.  This will allow the player to reenter
          * the game in the same place as last time. */
d1554 3
@


1.96
log
@Cause imms who quit to reenter the game in their home rooms.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.95 2008/08/31 21:44:03 jps Exp jps $
d48 1
a48 46
void send_game_entry_message(struct char_data *ch, int quit_mode)
{
   switch(quit_mode) {
      case SAVE_RENT:
      case SAVE_WRENT:
         sprintf(buf, "%s is un-renting and entering game.", GET_NAME(ch));
         break;
      case SAVE_AUTO:
         sprintf(buf, "%s is retrieving autosaved items and entering game.",
               GET_NAME(ch));
         break;
      case SAVE_CRYO:
         sprintf(buf, "%s is un-cryo'ing and entering game.", GET_NAME(ch));
         break;
      case SAVE_FORCE:
      case SAVE_TIMEOUT:
         sprintf(buf, "%s is retrieving force-saved items and entering game.",
               GET_NAME(ch));
         break;
      case SAVE_HOTBOOT:
         sprintf(buf, "%s is popping back out for the hotboot.", GET_NAME(ch));
         break;
      case SAVE_QUITMORT:
         sprintf(buf, "%s is entering the game naked.", GET_NAME(ch));
         break;
      case SAVE_QUITIMM:
         sprintf(buf, "%s is entering the game.", GET_NAME(ch));
         break;
      case SAVE_CAMP:
         sprintf(buf, "%s breaks camp and enters the game.", GET_NAME(ch));
         break;
      case SAVE_MTRIGGER:
         sprintf(buf, "%s is reentering the  game.", GET_NAME(ch));
         break;
      case SAVE_EMERGENCY:
         sprintf(buf, "%s is reentering the game (emergency save).", GET_NAME(ch));
         break;
      default:
         sprintf(buf, "WARNING: %s entering game with undefined rent code.",
               GET_NAME(ch));
      break;
   }
   mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
}

void save_objects(struct char_data *ch, int rentcode)
a56 5
  if (rentcode == SAVE_QUITMORT) {
    delete_player_obj_file(ch);
    return;
  }

a79 11
  switch (rentcode) {
    case SAVE_CAMP:
    case SAVE_RENT:
    case SAVE_TIMEOUT:
    case SAVE_CRYO:
    case SAVE_QUITMORT:
    case SAVE_QUITIMM:
      extract_unrentables(ch);
      break;
  }

d89 4
a92 1
  write_rent_code(fl, rentcode);
d294 1
a294 1
  int rent_code, i;
a318 44
  rent_code = atoi(buf);
  switch (rent_code) {
  case SAVE_RENT:
    sprintf(buf, "%s rented.\r\n", name);
    break;
  case SAVE_AUTO:
    sprintf(buf, "%s was autosaved.\r\n", name);
    break;
  case SAVE_CRYO:
    sprintf(buf, "%s cryo-rented.\r\n", name);
    break;
  case SAVE_FORCE:
    sprintf(buf, "%s was force-saved.\r\n", name);
    break;
  case SAVE_TIMEOUT:
    sprintf(buf, "%s timed out.\r\n", name);
    break;
  case SAVE_HOTBOOT:
    sprintf(buf, "%s was saved in a hotboot.\r\n", name);
    break;
  case SAVE_QUITMORT:
    sprintf(buf, "%s quit and became naked.\r\n", name);
    break;
  case SAVE_QUITIMM:
    sprintf(buf, "%s quit, but is immortal.\r\n", name);
    break;
  case SAVE_CAMP:
    sprintf(buf, "%s camped.\r\n", name);
    break;
  case SAVE_MTRIGGER:
    sprintf(buf, "%s was saved by a mobile trigger.\r\n", name);
    break;
  case SAVE_WRENT:
    sprintf(buf, "%s was rented by a room trigger.\r\n", name);
    break;
  case SAVE_EMERGENCY:
    sprintf(buf, "%s was emergency-saved!\r\n", name);
    break;
  default:
    sprintf(buf, "%s was saved with an undefined rent code.\r\n", name);
    break;
  }
  send_to_char(buf, ch);

a830 1
  send_game_entry_message(ch, rent_code);
a1083 2
  int orig_rent_code;
  float num_of_days;
a1094 6
  if (rent.rentcode == SAVE_RENT || rent.rentcode == SAVE_TIMEOUT) {
    num_of_days = (float) (time(0) - rent.time) / SECS_PER_REAL_DAY;
  }

  send_game_entry_message(ch, orig_rent_code = rent.rentcode);

d1226 1
a1226 1
         save_player(d->character, SAVE_AUTO);
d1280 1
a1280 1
  int quit_mode = SAVE_RENT;
d1308 1
a1308 1
    quit_mode = SAVE_CRYO;
d1315 1
a1315 1
    quit_mode = SAVE_RENT;
d1496 1
a1496 1
void save_player(struct char_data *ch, int save_mode)
d1498 2
d1501 17
a1517 1
   save_objects(ch, save_mode);
d1521 5
a1525 5
   switch (save_mode) {
      case SAVE_RENT:
      case SAVE_CRYO:
      case SAVE_CAMP:
      case SAVE_WRENT:
d1528 2
a1529 2
      case SAVE_QUITIMM:
      case SAVE_QUITMORT:
d1532 3
a1534 6
      case SAVE_AUTO:
      case SAVE_FORCE:
      case SAVE_TIMEOUT:
      case SAVE_HOTBOOT:
      case SAVE_MTRIGGER:
      case SAVE_EMERGENCY:
d1541 1
a1541 1
   if (save_mode == SAVE_CRYO) {
d1545 1
d1552 3
@


1.95
log
@Renamed StackObjs and StackMobs prefs to ExpandObjs and ExpandMobs.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.94 2008/08/30 18:20:53 myc Exp jps $
a1616 1
      case SAVE_QUITIMM:
d1621 1
d1647 3
@


1.94
log
@You can now rent items with NOTHING vnums.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.93 2008/08/29 04:16:26 myc Exp myc $
d477 1
a477 1
    if (PRF_FLAGGED(ch, PRF_STACK_OBJS)) {
d1647 3
@


1.93
log
@Fixed the show rent command.  It now supports stacking objects.
And the equipment displays correctly too.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.92 2008/08/19 01:58:21 jps Exp myc $
d181 1
a181 1
  if (OBJ_FLAGGED(obj, ITEM_NORENT) || GET_OBJ_RNUM(obj) <= NOTHING)
d1647 4
@


1.92
log
@Extract unrentable objects from a character when camping.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.91 2008/08/17 20:46:21 jps Exp jps $
d35 1
a354 2
  extern struct player_special_data dummy_mob;

d422 1
a423 3
  SET_FLAG(MOB_FLAGS(tch), MOB_ISNPC); /* so we don't need to make a player_specials */
  tch->player_specials = &dummy_mob;
  GET_NAME(tch) = strdup(name);
d452 1
a452 1
  SET_FLAG(PLR_FLAGS(ch), PLR_REMOVING);
d456 1
a456 1
static void list_objects(struct obj_data *obj, struct char_data *ch,
d460 58
a517 25
  int i = indent;
  buf[i--] = '\0';
  for (; i >= last_indent; --i)
    buf[i] = ' ';
/*
  if (indent > 2) {
    buf[indent - 3] = '+';
    buf[indent - 2] = '-';
    buf[indent - 1] = ' ';
  }
*/
  sprintf(buf1, "%s%s @@W[@@4%d@@W]@@0\r\n",
          first_indent ? first_indent : (const char *) buf,          
          obj->short_description, GET_OBJ_VNUM(obj));
  send_to_char(buf1, ch);
/*
  if (indent > 2) {
    buf[indent - 3] = obj->next_content ? '|' : ' ';
    buf[indent - 2] = ' ';
  }
*/
  if (obj->contains)
    list_objects(obj->contains, ch, indent + 3, indent, NULL);
  if (obj->next_content)
    list_objects(obj->next_content, ch, indent, indent, NULL);
d1647 3
@


1.91
log
@Cause objects loaded from binary files to have their effect flags
reset to those of the prototype.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.90 2008/08/15 03:59:08 jps Exp jps $
d130 1
d1617 4
@


1.90
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.89 2008/08/14 09:45:22 jps Exp jps $
d1075 1
a1075 1
  int j = 0;
d1079 1
a1079 1
  if (real_object(store->item_number) < 0) return NULL;
d1091 6
a1096 3
  GET_OBJ_EFF_FLAGS(obj)[0] = store->effect_flags;
  GET_OBJ_EFF_FLAGS(obj)[1] = store->effect_flags2;
  GET_OBJ_EFF_FLAGS(obj)[2] = store->effect_flags3;
d1616 3
@


1.89
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.88 2008/07/27 05:31:17 jps Exp jps $
d1541 1
a1541 1
         page_string(ch->desc, buf);
d1613 3
@


1.88
log
@Refactored the messages for entering/leaving game based on save code.
Added a new save_player function, which saves everything.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.87 2008/07/27 01:33:38 jps Exp jps $
d34 1
d1541 1
a1541 1
         page_string(ch->desc, buf, 1);
d1613 4
@


1.87
log
@Added room name and vnum to rented message.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.86 2008/07/26 22:52:11 jps Exp jps $
d46 45
d100 5
d106 3
a108 1
    sprintf(buf, "SYSERR: Couldn't make temporary file name for saving objects for %s.", GET_NAME(ch));
d114 3
a116 1
    sprintf(buf, "SYSERR: Couldn't make final file name for saving objects for %s.", GET_NAME(ch));
d122 2
a123 1
    sprintf(buf, "SYSERR: Couldn't open player file %s for write", tempfilename);
d129 7
a135 5
  case SAVE_RENT:
  case SAVE_TIMEOUT:
  case SAVE_CRYO:
    extract_unrentables(ch);
    break;
a170 11

  switch (rentcode) {
  case SAVE_CRASH:
    REMOVE_FLAG(PLR_FLAGS(ch), PLR_CRASH);
    break;
  case SAVE_RENT:
  case SAVE_TIMEOUT:
  case SAVE_CRYO:
    extract_objects(ch);
    break;
  }
d379 1
a379 1
    sprintf(buf, "%s rented/camped.\r\n", name);
d381 2
a382 2
  case SAVE_CRASH:
    sprintf(buf, "%s was crash-saved.\r\n", name);
d387 2
a388 2
  case SAVE_FORCED:
    sprintf(buf, "%s was force-rented.\r\n", name);
d396 18
d451 3
d496 1
a496 1
            "SYSERR: Crash_quest_save couldn't get temp file name for %s.",
d504 1
a504 1
            "SYSERR: Crash_quest_save couldn't get quest file name for %s.",
d511 1
a511 1
      sprintf(buf, "SYSERR: Crash_quest_save couldn't open file %s for write",
d566 1
a566 1
      sprintf(buf1, "SYSERR: deleting crash file %s (1)", filename);
d575 1
a575 1
      sprintf(buf1, "SYSERR: deleting crash file %s (2)", filename);
d583 1
a583 1
bool delete_crash_file(struct char_data * ch)
d594 1
a594 1
      sprintf(buf1, "SYSERR: checking for crash file %s (3)", fname);
d602 1
a602 1
    if (rent_code == SAVE_CRASH)
d901 1
a901 25
  switch (rent_code) {
  case SAVE_RENT:
    sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
    break;
  case SAVE_CRASH:
    sprintf(buf, "%s retrieving crash-saved items and entering game.", 
            GET_NAME(ch));
    break;
  case SAVE_CRYO:
    sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
    break;
  case SAVE_FORCED:
  case SAVE_TIMEOUT:
    sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
    break;
  case SAVE_HOTBOOT:
    sprintf(buf, "%s is popping back out for the hotboot.", GET_NAME(ch));
    break;
  default:
    sprintf(buf, "WARNING: %s entering game with undefined rent code.", 
            GET_NAME(ch));
    break;
  }
  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);

a902 1

d1169 1
a1169 27
  switch (orig_rent_code = rent.rentcode) {
  case SAVE_RENT:
    sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case SAVE_CRASH:
    sprintf(buf, "%s retrieving crash-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case SAVE_CRYO:
    sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case SAVE_FORCED:
  case SAVE_TIMEOUT:
    sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case SAVE_HOTBOOT:
    sprintf(buf, "%s is popping back out for the hotboot.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  default:
    sprintf(buf, "WARNING: %s entering game with undefined rent code.", GET_NAME(ch));
    mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  }
d1178 1
a1178 1
      perror("Reading crash file: load_binary_objects()");
d1296 1
a1296 1
void crash_save_all(void)
d1298 6
a1303 8
  struct descriptor_data *d;
  for (d = descriptor_list; d; d = d->next) {
    if ((d->connected == CON_PLAYING) && !IS_NPC(d->character)) {
      if (PLR_FLAGGED(d->character, PLR_CRASH)) {
        save_objects(d->character, SAVE_CRASH);
        save_player(d->character);
        save_quests(d->character);
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_CRASH);
d1305 1
a1305 2
    }
  }
d1356 2
d1384 1
a1384 2
    SET_FLAG(PLR_FLAGS(ch), PLR_CRYO);
    save_objects(ch, SAVE_CRYO);
d1391 1
a1391 1
    save_objects(ch, SAVE_RENT);
d1400 1
a1400 3
  GET_LOADROOM(ch) = world[ch->in_room].vnum;
  save_quests(ch);
  extract_char(ch); /* calls save_player */
d1447 7
d1568 41
d1612 3
@


1.86
log
@Detect corrupt spellbooks when restoring binary objects, so as not to crash.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.85 2008/07/26 21:49:53 jps Exp jps $
d1378 3
a1380 1
    sprintf(buf, "%s has rented.", GET_NAME(ch));
d1552 3
@


1.85
log
@Skip binary obj files in show_rent, and advise user what to do.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.84 2008/07/26 21:34:33 jps Exp jps $
d33 1
d1071 20
a1090 3
               entry->spell = atoi(spell_parse);
               spell_parse = strsep(&list_parse, "_");
               entry->length = atoi(spell_parse);
d1550 3
@


1.84
log
@Added functions for converting old binary object files into ASCII format.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.83 2008/07/22 06:12:17 myc Exp jps $
d323 6
d1532 3
@


1.83
log
@Missing a break in a switch statement so 'show rent' was showing the
wrong message.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.82 2008/07/13 19:04:52 jps Exp myc $
d299 1
a299 1
  char filename[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
d314 2
a315 4
  if (!get_pfilename(name, filename, OBJ_FILE)) {
    send_to_char("Invalid name, or otherwise unable to determine filename.\r\n", ch);
    return;
  }
a318 6
  if (!(fl = fopen(filename, "r"))) {
    sprintf(buf, "%s has no rent file.\r\n", name);
    send_to_char(buf, ch);
    return;
  }

a797 1
  char filename[MAX_INPUT_LENGTH];
d801 2
a802 5
  if (!get_pfilename(GET_NAME(ch), filename, OBJ_FILE)) {
    sprintf(buf, "SYSERR: Unable to construct filename to load objects for %s", GET_NAME(ch));
    log(buf);
    return FALSE;
  }
a803 14
  if (!(fl = fopen(filename, "r"))) {
    if (errno != ENOENT) {
      sprintf(buf, "SYSERR: READING OBJECT FILE %s (5)", filename);
      perror(buf);
      send_to_char("\r\n@@W********************* NOTICE *********************\r\n"
                   "There was a problem (error 01) loading your objects from disk.\r\n"
                   "Contact a God for assistance.@@0\r\n", ch);
      sprintf(buf, "%s entering game with no equipment. (error 01)", GET_NAME(ch));
    }
    else
      sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    return TRUE;
  }
a1083 1
  char fname[MAX_INPUT_LENGTH];
d1093 2
a1094 15
  if (!get_pfilename(GET_NAME(ch), fname, OBJ_FILE))
    return FALSE;

  if (!(fl = fopen(fname, "rb"))) {
    if (errno != ENOENT) {        /* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: READING OBJECT FILE %s (5)", fname);
      perror(buf1);
      send_to_char("\r\n********************* NOTICE *********************\r\n"
                   "There was a problem (error 03) loading your objects from disk.\r\n"
                   "Contact a God for assistance.\r\n", ch);
    }
    sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    return TRUE;
  }
d1377 146
d1526 4
@


1.82
log
@Added a hotboot rent code, which allows people to save their keys
over a hotboot.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.81 2008/07/10 20:38:02 myc Exp jps $
d350 1
d1420 4
@


1.81
log
@Show rent was showing wrong name in message
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.80 2008/07/10 20:17:37 myc Exp myc $
d348 2
d867 3
d1160 4
d1419 3
@


1.80
log
@Increment world count for objects loaded by rent code.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.79 2008/06/21 08:53:09 myc Exp myc $
d334 1
a334 1
    sprintf(buf, "%s rented/camped.\r\n", GET_NAME(ch));
d337 1
a337 1
    sprintf(buf, "%s was crash-saved.\r\n", GET_NAME(ch));
d340 1
a340 1
    sprintf(buf, "%s cryo-rented.\r\n", GET_NAME(ch));
d343 1
a343 1
    sprintf(buf, "%s was force-rented.\r\n", GET_NAME(ch));
d346 1
a346 1
    sprintf(buf, "%s timed out.\r\n", GET_NAME(ch));
d349 1
a349 1
    sprintf(buf, "%s was saved with an undefined rent code.\r\n", GET_NAME(ch));
d1410 3
@


1.79
log
@Use fread_string to read objects' action desc.  Check prototypes
for a string before attempting to string compare.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.78 2008/06/19 18:53:12 myc Exp myc $
d758 2
d1410 4
@


1.78
log
@Spellbook pages now saved as an item value.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.77 2008/06/08 03:21:58 jps Exp myc $
d615 1
a615 1
      if (!strcmp(tag, "adesc"))        obj->action_description = strdup(line);
d743 1
a743 1
                                           else if (!*obj->address || !strcmp(obj->address, proto->address)) { \
d1408 3
@


1.77
log
@Fix text formatting of receptionist message.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.76 2008/06/08 00:58:04 jps Exp jps $
d264 5
a268 8
  if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK) {
    fprintf(fl, "numpages: %d\n", GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES));
    if (obj->spell_book) {
      fprintf(fl, "spells:\n");
      for (spell = obj->spell_book; spell; spell = spell->next)
        fprintf(fl, "%d %d\n", spell->spell, spell->length);
      fprintf(fl, "~\n");
    }
a662 2
      else if (!strcmp(tag, "numpages"))
         GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) = LIMIT(0, num, MAX_SPELLBOOK_PAGES);
d700 3
a702 1
          GET_OBJ_VAL(obj, num++) = atoi(line);
d1408 3
@


1.76
log
@Ensure that the number of pages in a spellbook will be written when
saving a spellbook, even if the spellbook is blank.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.75 2008/06/07 19:35:39 jps Exp jps $
d1382 1
a1382 1
        "$n stores your belongings and helps you into your private chamber.",
d1411 4
@


1.75
log
@Write number of spellbook pages when saving. Limit to a maximum value.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.74 2008/06/07 19:06:46 myc Exp jps $
d264 1
a264 1
  if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK && obj->spell_book) {
d266 6
a271 4
    fprintf(fl, "spells:\n");
    for (spell = obj->spell_book; spell; spell = spell->next)
      fprintf(fl, "%d %d\n", spell->spell, spell->length);
    fprintf(fl, "~\n");
d1411 3
@


1.74
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.73 2008/06/07 18:52:13 myc Exp myc $
d265 1
d664 2
d1409 3
@


1.73
log
@Fix spell loading again.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.72 2008/06/07 18:48:21 myc Exp myc $
d267 1
a267 1
      fprintf(fl, "%d %d\n", spell->spell, spell->spell_length);
d619 1
a619 1
          obj->applies[apply].location = num;
d627 1
a627 1
      if (!strcmp(tag, "cost"))         GET_OBJ_COST(obj) = num;
d653 1
a653 1
      if (!strcmp(tag, "hiddenness"))   GET_OBJ_HIDDENNESS(obj) = num;
d658 1
a658 1
      else if (!strcmp(tag, "level"))   GET_OBJ_LEVEL(obj) = num;
d671 1
a671 1
          sscanf(line, "%d %d", &spell->spell, &spell->spell_length);
d682 2
a683 2
      if (!strcmp(tag, "type"))         GET_OBJ_TYPE(obj) = num;
      else if (!strcmp(tag, "timer"))   GET_OBJ_TIMER(obj) = num;
d717 1
a717 1
      if (!strcmp(tag, "weight"))       GET_OBJ_WEIGHT(obj) = num;
d738 16
a753 8
  #define CHECK_STR(address)	do { \
                                  if (!obj->address) \
                                    obj->address = proto->address; \
                                  else if (!strcmp(obj->address, proto->address)) { \
                                    free(obj->address); \
                                    obj->address = proto->address; \
                                  } \
                                } while (FALSE);
d757 4
a760 4
    CHECK_STR(name);
    CHECK_STR(description);
    CHECK_STR(short_description);
    CHECK_STR(action_description);
d786 3
a788 6
  if (!obj->name)
    obj->name = strdup("item undefined-item");
  if (!obj->short_description)
    obj->short_description = strdup("an undefined item");
  if (!obj->description)
    obj->description = strdup("An undefined item sits here.");
d790 2
a791 1
  #undef CHECK_STR
d1067 1
a1067 1
      obj->spell_book_length = MAX_SPELLBOOK_PAGES;
d1082 1
a1082 1
               entry->spell_length = atoi(spell_parse);
d1406 3
@


1.72
log
@Load spells from spellbook correctly.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.71 2008/06/07 18:45:39 myc Exp myc $
d672 4
a675 1
          last_spell->next = spell;
a676 2
          if (!obj->spell_book)
            obj->spell_book = spell;
d1400 3
@


1.71
log
@Don't try to equip an item in the inventory slot.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.70 2008/06/05 02:07:43 myc Exp myc $
d668 1
a668 1
        for (last_spell = obj->spell_book; last_spell->next; last_spell = last_spell->next);
d1399 3
@


1.70
log
@Completely rewrote the rent file saving and loading to use
an ascii text format.  Some of the old legacy binary code
remains so that we don't have to actively convert old
object files to the new format.  When old rent files are
encountered, they are lazily loaded into the game, and
replaced by the new format when the player is saved.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.69 2008/05/26 18:24:48 jps Exp myc $
d555 1
a555 1
    if (location >= 0) {
d1399 8
@


1.69
log
@Removed code that deletes player object files.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.68 2008/05/18 05:39:59 jps Exp jps $
d30 3
a32 6

/* these factors should be unique integers */
#define RENT_FACTOR         1
#define CRYO_FACTOR         4

extern int min_rent_cost;
a35 2
SPECIAL(receptionist);
SPECIAL(cryogenicist);
d37 9
a45 1
struct obj_data *Obj_from_store_to(struct obj_file_elem object, int *locate)
d47 24
a70 26
   struct obj_data *obj;
   int j = 0;
   char *list_parse, *spell_parse, *list;
   struct spell_book_list *entry;

   if (real_object(object.item_number) < 0) return NULL;

   obj = read_object(object.item_number, VIRTUAL);
   *locate = (int) object.locate;
   GET_OBJ_VAL(obj, 0) = object.value[0];
   GET_OBJ_VAL(obj, 1) = object.value[1];
   GET_OBJ_VAL(obj, 2) = object.value[2];
   GET_OBJ_VAL(obj, 3) = object.value[3];
   GET_OBJ_EXTRA(obj) = object.extra_flags;
   GET_OBJ_WEIGHT(obj) = object.weight;
   GET_OBJ_TIMER(obj) = object.timer;
   obj->obj_flags.hiddenness = object.hiddenness;
   obj->obj_flags.effect_flags[0] = object.effect_flags;
   obj->obj_flags.effect_flags[1] = object.effect_flags2;
   obj->obj_flags.effect_flags[2] = object.effect_flags3;

   /* Handling spellbooks
    *
    * The spells written in it have been stored as a string, which
    * must be parsed so that the spell list can be restored.
    */
d72 18
a89 12
   if (GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK) {
      obj->spell_book_length = MAX_SPELLBOOK_PAGES;
      if (object.spells_in_book[0]) {
         list = object.spells_in_book;
         CREATE(obj->spell_book, struct spell_book_list, 1);
         entry = obj->spell_book;
         while ((list_parse = strsep(&list, ",")) && strlen(object.spells_in_book)) {
            if (list_parse && strlen(list_parse)) {
               if (j > 0) {
                  CREATE(entry->next, struct spell_book_list, 1);
                  entry = entry->next;
               }
d91 5
a95 7
               spell_parse = strsep(&list_parse, "_");
               entry->spell = atoi(spell_parse);
               spell_parse = strsep(&list_parse, "_");
               entry->spell_length = atoi(spell_parse);
               j++;
            }
         }
d97 33
a129 1
   }
d131 2
a132 2
   for (j = 0; j < MAX_OBJ_EFFECT; j++)
      obj->effects[j] = object.effects[j];
d134 1
a134 1
   return obj;
d137 9
d147 1
a147 2
/* this function used in house.c */
struct obj_data *Obj_from_store(struct obj_file_elem object)
d149 1
a149 1
  int locate;
d151 16
a166 1
  return Obj_from_store_to(object, &locate);
d169 20
d190 10
d201 1
a201 1
int Obj_to_store_from(struct obj_data * obj, FILE * fl, int locate)
d203 77
a279 4
  int j;
  struct obj_file_elem object;
  struct spell_book_list *spellbook;
  char savebuff[SPELLBOOK_SIZE];
d281 8
a288 25
  object.item_number = GET_OBJ_VNUM(obj);
  object.locate = (int) locate; /* where worn or inventory? */
  object.value[0] = GET_OBJ_VAL(obj, 0);
  object.value[1] = GET_OBJ_VAL(obj, 1);
  object.value[2] = GET_OBJ_VAL(obj, 2);
  object.value[3] = GET_OBJ_VAL(obj, 3);
  object.extra_flags = GET_OBJ_EXTRA(obj);
  object.weight = GET_OBJ_WEIGHT(obj);
  object.timer = GET_OBJ_TIMER(obj);
  object.hiddenness = obj->obj_flags.hiddenness;
  object.effect_flags = obj->obj_flags.effect_flags[0];
  object.effect_flags2 = obj->obj_flags.effect_flags[1];
  object.effect_flags3 = obj->obj_flags.effect_flags[2];
  for (j = 0; j < MAX_OBJ_EFFECT; j++)
    object.effects[j] = obj->effects[j];

  if(GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK) {

    /* this will be chaged as soon as we have some way to edit spell books */
    object.spell_book_length = MAX_SPELLBOOK_PAGES;
    /*    object.spell_book_length = obj->spell_book_length;*/
    memset(savebuff, '\0', SPELLBOOK_SIZE);
    for(spellbook = obj->spell_book; spellbook; spellbook = spellbook->next) {
      if(spellbook->spell && spellbook->spell_length)
        sprintf(savebuff, "%s%d_%d_,", savebuff, spellbook->spell, spellbook->spell_length);
a289 1
    strcpy(object.spells_in_book, savebuff);
d291 4
a294 5
  if (fwrite(&object, sizeof(struct obj_file_elem), 1, fl) < 1) {
    perror("Error writing object in Obj_to_store_from");
    return 0;
  }
  return 1;
d297 1
a297 1
int Obj_to_store(struct obj_data * obj, FILE * fl)
d299 118
a416 1
   return Obj_to_store_from(obj, fl, 0);
d419 1
a419 2

void Crash_quest_save(struct char_data *ch)
d488 1
a488 1
int Crash_delete_file(char *name)
d493 1
a493 1
  if (!get_pfilename(name, filename, CRASH_FILE))
d495 1
a495 1
  if (!(fl = fopen(filename, "rb"))) {
d514 1
a514 1
int Crash_delete_crashfile(struct char_data * ch)
d516 1
a516 2
  char fname[MAX_INPUT_LENGTH];
  struct rent_info rent;
d518 4
d523 1
a523 3
  if (!get_pfilename(GET_NAME(ch), fname, CRASH_FILE))
    return 0;
  if (!(fl = fopen(fname, "rb"))) {
d528 7
a534 1
    return 0;
d536 1
a536 2
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
d539 1
a539 4
  if (rent.rentcode == RENT_CRASH)
    Crash_delete_file(GET_NAME(ch));

  return 1;
d543 1
a543 1
void Crash_listrent(struct char_data * ch, char *name)
d545 15
a559 41
  FILE *fl;
  char fname[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct obj_data *obj;
  struct rent_info rent;
  int numitems = 0;

  if (!get_pfilename(name, fname, CRASH_FILE))
    return;
  if (!(fl = fopen(fname, "rb"))) {
    sprintf(buf, "%s has no rent file.\r\n", name);
    send_to_char(buf, ch);
    return;
  }
  sprintf(buf, "%s\r\n", fname);
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  switch (rent.rentcode) {
  case RENT_RENTED:
    strcat(buf, "Rent\r\n");
    break;
  case RENT_CRASH:
    strcat(buf, "Crash\r\n");
    break;
  case RENT_CRYO:
    strcat(buf, "Cryo\r\n");
    break;
  case RENT_TIMEDOUT:
  case RENT_FORCED:
    strcat(buf, "TimedOut\r\n");
    break;
  default:
    strcat(buf, "Undef\r\n");
    break;
  }
  send_to_char(buf, ch);
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      fclose(fl);
      return;
a560 9
    if (!feof(fl))
      if (real_object(object.item_number) > -1) {
        obj = read_object(object.item_number, VIRTUAL);
        sprintf(buf, "%4d. [%5d] (%5dau) <%2d> %-20s\r\n", ++numitems,
                object.item_number, GET_OBJ_RENT(obj),
                object.locate, obj->short_description);
        extract_obj(obj);
  send_to_char(buf, ch);
      }
d562 1
a562 1
  fclose(fl);
d566 12
d579 8
a586 1
int Crash_write_rentcode(struct char_data * ch, FILE * fl, struct rent_info * rent)
d588 13
a600 3
  if (fwrite(rent, sizeof(struct rent_info), 1, fl) < 1) {
    perror("Writing rent code.");
    return 0;
a601 2
  return 1;
}
d603 2
a604 3
int auto_equip(struct char_data *ch, struct obj_data *obj, int locate)
{
  int j;
d606 2
a607 5
  if (locate > 0) { /* was worn */
    if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch))
      locate = 0;
    switch (j = locate-1) {
    case WEAR_LIGHT:
d609 16
a624 4
    case WEAR_FINGER_R:
    case WEAR_FINGER_L:
      if (!CAN_WEAR(obj,ITEM_WEAR_FINGER)) /* not fitting :( */
         locate = 0;
d626 21
a646 4
    case WEAR_NECK_1:
    case WEAR_NECK_2:
      if (!CAN_WEAR(obj,ITEM_WEAR_NECK))
         locate = 0;
d648 31
a678 3
    case WEAR_BODY:
      if (!CAN_WEAR(obj,ITEM_WEAR_BODY))
         locate = 0;
d680 13
a692 3
    case WEAR_HEAD:
      if (!CAN_WEAR(obj,ITEM_WEAR_HEAD))
         locate = 0;
d694 20
a713 3
    case WEAR_LEGS:
      if (!CAN_WEAR(obj,ITEM_WEAR_LEGS))
         locate = 0;
d715 4
a718 3
    case WEAR_FEET:
      if (!CAN_WEAR(obj,ITEM_WEAR_FEET))
         locate = 0;
d720 4
a723 65
    case WEAR_HANDS:
      if (!CAN_WEAR(obj,ITEM_WEAR_HANDS))
         locate = 0;
      break;
    case WEAR_ARMS:
      if (!CAN_WEAR(obj,ITEM_WEAR_ARMS))
         locate = 0;
      break;
    case WEAR_SHIELD:
      if (!CAN_WEAR(obj,ITEM_WEAR_SHIELD))
         locate = 0;
      break;
    case WEAR_ABOUT:
      if (!CAN_WEAR(obj,ITEM_WEAR_ABOUT))
         locate = 0;
      break;
    case WEAR_LEAR:
         if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
          locate =0;
        break;
    case WEAR_REAR:
      if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
        locate =0;
      break;
    case WEAR_OBELT:
      if (!CAN_WEAR(obj,ITEM_WEAR_OBELT))
        locate =0;
      break;
    case WEAR_FACE:
      if (!CAN_WEAR(obj,ITEM_WEAR_FACE))
        locate =0;
      break;
    case WEAR_EYES:
      if (!CAN_WEAR(obj,ITEM_WEAR_EYES))
        locate =0;
      break;
    case WEAR_BADGE:
      if (!CAN_WEAR(obj,ITEM_WEAR_BADGE))
        locate =0;
      break;
    case WEAR_WAIST:
      if (!CAN_WEAR(obj,ITEM_WEAR_WAIST))
         locate = 0;
      break;
    case WEAR_WRIST_R:
    case WEAR_WRIST_L:
      if (!CAN_WEAR(obj,ITEM_WEAR_WRIST))
         locate = 0;
      break;
    case WEAR_WIELD:
    case WEAR_WIELD2:
      if (!CAN_WEAR(obj,ITEM_WEAR_WIELD))
         locate = 0;
      break;
    case WEAR_2HWIELD:
      if (!CAN_WEAR(obj,ITEM_WEAR_2HWIELD))
         locate = 0;
      break;
    case WEAR_HOLD:
      if (!CAN_WEAR(obj,ITEM_WEAR_HOLD))
         locate = 0;
      break;
    case WEAR_HOLD2:
      if (!CAN_WEAR(obj,ITEM_WEAR_HOLD))
         locate = 0;
a724 2
    default:
      locate = 0;
d726 42
a767 10
    if (locate > 0) {
      if (!GET_EQ(ch,j)) {
        /* check ch's alignment to prevent $M from being zapped through auto-equip */
         if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
             (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
             (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)))
           locate = 0;
         else {
           equip_char(ch, obj, j);
          return 1;
d769 1
a770 2
      else  /* oops - saved player with double equipment[j]? */
         locate = 0;
d772 1
a773 2
  if (locate <= 0)
    obj_to_char(obj, ch);
d775 12
a786 1
  return locate;
d789 27
d817 79
a895 1
void loadpfile_quest(struct char_data *ch)
a1029 1
#define MAX_BAG_ROW 5
d1031 1
a1031 1
int loadpfile_objs(struct char_data *ch)
d1033 38
a1070 6
     /* return values:
        0 - successful load, keep char in rent room.
        1 - load failure or load of crash items -- put char in temple.
        2 - rented equipment lost (no $)
     */
   void Crash_crashsave(struct char_data * ch);
d1072 7
a1078 22
   FILE *fl;
   char fname[MAX_STRING_LENGTH];
   struct obj_file_elem object;
   struct rent_info rent;
   int orig_rent_code;
   float num_of_days;
   struct obj_data *obj;
   int locate, j, eq = 0;
   struct obj_data *obj1;
   struct obj_data *cont_row[MAX_BAG_ROW];


   if (!get_pfilename(GET_NAME(ch), fname, CRASH_FILE))
      return 1;

   if (!(fl = fopen(fname, "r+b"))) {
      if (errno != ENOENT) {        /* if it fails, NOT because of no file */
         sprintf(buf1, "SYSERR: READING OBJECT FILE %s (5)", fname);
         perror(buf1);
         send_to_char("\r\n********************* NOTICE *********************\r\n"
            "There was a problem loading your objects from disk.\r\n"
            "Contact a God for assistance.\r\n", ch);
a1079 3
      sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      return 1;
d1082 39
a1120 2
   if (!feof(fl))
      fread(&rent, sizeof(struct rent_info), 1, fl);
d1122 3
a1124 3
   if (rent.rentcode == RENT_RENTED || rent.rentcode == RENT_TIMEDOUT) {
      num_of_days = (float) (time(0) - rent.time) / SECS_PER_REAL_DAY;
   }
d1126 23
a1148 23
   switch (orig_rent_code = rent.rentcode) {
      case RENT_RENTED:
         sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
         mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      break;
      case RENT_CRASH:
         sprintf(buf, "%s retrieving crash-saved items and entering game.", GET_NAME(ch));
         mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
         break;
      case RENT_CRYO:
         sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
         mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
         break;
      case RENT_FORCED:
      case RENT_TIMEDOUT:
         sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
         mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
         break;
      default:
         sprintf(buf, "WARNING: %s entering game with undefined rent code.", GET_NAME(ch));
         mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
         break;
   }
d1150 2
a1151 2
   for (j = 0; j < MAX_BAG_ROW; j++)
      cont_row[j] = NULL; /* empty all cont lists (you never know ...) */
d1153 8
a1160 8
   while (!feof(fl)) {
      eq = 0;
      fread(&object, sizeof(struct obj_file_elem), 1, fl);
      if (ferror(fl)) {
         perror("Reading crash file: playerload_objs()");
         fclose(fl);
      return 1;
      }
d1162 11
a1172 11
      if (!feof(fl))
         if ((obj = Obj_from_store_to(object, &locate))) {
            eq = auto_equip(ch, obj, locate);
            /* 5/5/01 - Zantir - Found a bug in the auto_equip code
               that would crash the mud if a player couldn't wear an
               container that the mud thought they were already
               wearing. So now the auto_equip function returns a value,
               if a 1 isn't returned the assume the item can't be
               reworn so set the locate value to 0. */
            if (eq == 0)
               locate = 0;
d1199 1
a1199 1
           for (j = MAX_BAG_ROW-1;j > 0;j--)
d1201 1
a1201 1
               for (;cont_row[j];cont_row[j] = obj1) {
d1210 1
a1210 1
               obj = unequip_char(ch, locate-1);
d1212 1
a1212 1
               for (;cont_row[0];cont_row[0] = obj1) {
d1216 1
a1216 1
               equip_char(ch, obj, locate-1);
d1218 1
a1218 1
               for (;cont_row[0];cont_row[0] = obj1) {
d1226 1
a1226 1
           for (j = MAX_BAG_ROW-1;j > -locate;j--)
d1228 1
a1228 1
               for (;cont_row[j];cont_row[j] = obj1) {
d1240 1
a1240 1
               for (;cont_row[j];cont_row[j] = obj1) {
d1246 1
a1246 1
               for (;cont_row[j];cont_row[j] = obj1) {
d1254 1
a1254 1
           if (locate < 0 && locate >= -MAX_BAG_ROW) {
a1269 6
  /* turn this into a crash file by re-writing the control block */
  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  rewind(fl);
  Crash_write_rentcode(ch, fl, &rent);

a1271 23
  if ((orig_rent_code == RENT_RENTED) || (orig_rent_code == RENT_CRYO))
    return 0;
  else
    return 1;
}


int Crash_save(struct obj_data * obj, FILE * fp, int locate)
{
  struct obj_data *tmp;
  int result;

  if (obj) {
    Crash_save(obj->next_content, fp, locate);
    Crash_save(obj->contains, fp, MIN(0,locate)-1);
    result = Obj_to_store_from(obj, fp, locate);

    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);

    if (!result)
      return 0;
  }
d1275 1
a1275 2

void Crash_restore_weight(struct obj_data * obj)
d1277 10
a1286 5
  if (obj) {
    Crash_restore_weight(obj->contains);
    Crash_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
d1291 3
a1293 9
void Crash_extract_objs(struct obj_data * obj)
{
  if (obj) {
    Crash_extract_objs(obj->contains);
    Crash_extract_objs(obj->next_content);
    extract_obj(obj);
  }
}

d1295 2
a1296 1
int Crash_is_unrentable(struct obj_data * obj)
d1298 1
a1298 9
  if (!obj)
    return 0;

  if (IS_OBJ_STAT(obj, ITEM_NORENT) || GET_OBJ_RNUM(obj) <= NOTHING)
    return 1;

  return 0;
}

a1299 2
void Crash_extract_norents(struct obj_data * obj)
{
d1301 4
a1304 19
    Crash_extract_norents(obj->contains);
    Crash_extract_norents(obj->next_content);
    if (Crash_is_unrentable(obj))
      extract_obj(obj);
  }
}

/* get norent items from eq to inventory and
   extract norents out of worn containers */
void Crash_extract_norents_from_equipped(struct char_data * ch)
{
  int j;

  for (j = 0;j < NUM_WEARS;j++) {
    if (GET_EQ(ch,j)) {
      if (Crash_is_unrentable(GET_EQ(ch, j)))
        obj_to_char(unequip_char(ch, j), ch);
      else
        Crash_extract_norents(GET_EQ(ch, j));
d1306 2
d1309 1
d1312 1
a1312 1
void Crash_extract_expensive(struct obj_data * obj)
d1314 1
a1314 1
  struct obj_data *tobj, *max;
d1316 3
a1318 6
  max = obj;
  for (tobj = obj; tobj; tobj = tobj->next_content)
    if (GET_OBJ_RENT(tobj) > GET_OBJ_RENT(max))
      max = tobj;
  extract_obj(max);
}
d1320 1
a1320 7
void Crash_calculate_rent(struct obj_data * obj, int *cost)
{
  if (obj) {
    *cost += MAX(0, GET_OBJ_RENT(obj));
    Crash_calculate_rent(obj->contains, cost);
    Crash_calculate_rent(obj->next_content, cost);
  }
d1323 1
a1323 1
void Crash_crashsave(struct char_data * ch)
d1325 1
a1325 7
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;
d1327 3
a1329 4
  if (!get_pfilename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;
d1331 2
a1332 24
  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }

  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch,j)) {
      if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
        fclose(fp);
        return;
      }
      Crash_restore_weight(GET_EQ(ch,j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  Crash_restore_weight(ch->carrying);

  fclose(fp);
  Crash_quest_save(ch);
  REMOVE_FLAG(PLR_FLAGS(ch), PLR_CRASH);
d1335 2
a1336 2

void Crash_idlesave(struct char_data * ch)
d1338 2
a1339 17
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  int cost, cost_eq;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_pfilename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);
d1341 2
a1342 2
  cost = 0;
  Crash_calculate_rent(ch->carrying, &cost);
d1344 3
a1346 20
  cost_eq = 0;
  for (j = 0; j < NUM_WEARS; j++)
    Crash_calculate_rent(GET_EQ(ch,j), &cost_eq);

  cost <<= 1;
  cost_eq <<= 1;

  if (cost+cost_eq > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
    for (j = 0; j < NUM_WEARS; j++) /* unequip player with low money */
      if (GET_EQ(ch,j))
         obj_to_char(unequip_char(ch, j), ch);
    cost += cost_eq;
    cost_eq = 0;

    while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
      Crash_extract_expensive(ch->carrying);
      cost = 0;
      Crash_calculate_rent(ch->carrying, &cost);
      cost <<= 1;
    }
d1349 3
a1351 7
  if (!ch->carrying) {
    for (j = 0; j < NUM_WEARS && !(GET_EQ(ch,j)); j++);
    if (j == NUM_WEARS) { /* no eq nor inv */
      fclose(fp);
      Crash_delete_file(GET_NAME(ch));
      return;
    }
a1352 1
  rent.net_cost_per_diem = cost;
d1354 3
a1356 5
  rent.rentcode = RENT_TIMEDOUT;
  rent.time = time(0);
  for (j = 0; j < NUM_COIN_TYPES; ++j) {
    rent.coins[j] = GET_COINS(ch)[j];
    rent.bank[j] = GET_BANK_COINS(ch)[j];
d1359 8
a1366 4

  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
d1368 6
a1373 13

  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch,j)) {
      if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
         fclose(fp);
         return;
      }
      Crash_restore_weight(GET_EQ(ch,j));
      Crash_extract_objs(GET_EQ(ch,j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
a1374 5
  fclose(fp);

  Crash_extract_objs(ch->carrying);
  Crash_quest_save(ch);
}
d1376 2
d1379 4
a1382 138
void Crash_rentsave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_pfilename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);

  rent.rentcode = RENT_RENTED;
  rent.time = time(0);
  for (j = 0; j < NUM_COIN_TYPES; ++j) {
    rent.coins[j] = GET_COINS(ch)[j];
    rent.bank[j] = GET_BANK_COINS(ch)[j];
  }

  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch,j)) {
      if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
         fclose(fp);
         return;
      }
      Crash_restore_weight(GET_EQ(ch,j));
      Crash_extract_objs(GET_EQ(ch,j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
  Crash_quest_save(ch);
}


void Crash_cryosave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_pfilename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norents_from_equipped(ch);

  Crash_extract_norents(ch->carrying);

  GET_GOLD(ch) = MAX(0, GET_GOLD(ch) - cost);

  rent.rentcode = RENT_CRYO;
  rent.time = time(0);
  for (j = 0; j < NUM_COIN_TYPES; ++j) {
    rent.coins[j] = GET_COINS(ch)[j];
    rent.bank[j] = GET_BANK_COINS(ch)[j];
  }
  rent.net_cost_per_diem = 0;

  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }

  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch,j)) {
      if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
         fclose(fp);
         return;
      }
      Crash_restore_weight(GET_EQ(ch,j));
      Crash_extract_objs(GET_EQ(ch,j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
  Crash_quest_save(ch);
  SET_FLAG(PLR_FLAGS(ch), PLR_CRYO);
}


/*************************************************************************
 * Routines used for the receptionist                                    *
 *************************************************************************/

int Crash_report_unrentables(struct char_data * ch, struct char_data * recep,
                             struct obj_data * obj)
{
  char buf[128];
  int has_norents = 0;

  if (obj) {
    if (Crash_is_unrentable(obj)) {
      has_norents = 1;
      sprintf(buf, "$n tells you, 'You cannot store %s.'", OBJS(obj, ch));
      act(buf, FALSE, recep, 0, ch, TO_VICT);
    }
    has_norents += Crash_report_unrentables(ch, recep, obj->contains);
    has_norents += Crash_report_unrentables(ch, recep, obj->next_content);
  }
  return (has_norents);
}



int Crash_report_norent(struct char_data *ch, struct char_data *receptionist)
{
   int i, norent = 0;

   norent = Crash_report_unrentables(ch, receptionist, ch->carrying);
   for (i = 0; i < NUM_WEARS; i++)
      norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch,i));

   return norent;
a1384 56

int gen_receptionist(struct char_data * ch, struct char_data * recep,
                     int cmd, char *arg, int mode)
{
   int cost = 0;

   if (!ch->desc || IS_NPC(ch))
      return FALSE;

   if (!CMD_IS("rent"))
      return FALSE;

   if (!AWAKE(recep)) {
      send_to_char("She is unable to talk to you...\r\n", ch);
      return TRUE;
   }

   if (!CAN_SEE(recep, ch) && GET_LEVEL(ch) < 100) {
      act("$n says, 'I don't deal with people I can't see!'", FALSE, recep, 0, 0, TO_ROOM);
      return TRUE;
   }

   if (Crash_report_norent(ch, recep)) {
      act("$N shakes $M head at $n.", TRUE, ch, 0, recep, TO_ROOM);
      return TRUE;
   }

   if (mode == RENT_FACTOR) {
      sprintf(buf, "&0&7&b$n&0&7&b tells you, 'Rent?  Sure, come this way!'");
      act(buf, FALSE, recep, 0, ch, TO_VICT);
      act("$n stores your belongings and helps you into your private chamber.",
            FALSE, recep, 0, ch, TO_VICT);
      if (CMD_IS("rent"))
         GET_LOADROOM(ch) = world[ch->in_room].vnum;
      Crash_rentsave(ch, 500);
      sprintf(buf, "%s has rented.", GET_NAME(ch));
   } else {
      act("$n stores your belongings and helps you into your private chamber.\r\n"
            "A white mist appears in the room, chilling you to the bone...\r\n"
            "You begin to lose consciousness...",
            FALSE, recep, 0, ch, TO_VICT);
      Crash_cryosave(ch, cost);
      sprintf(buf, "%s has cryo-rented.", GET_NAME(ch));
      SET_FLAG(PLR_FLAGS(ch), PLR_CRYO);
   }

   mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
   act("$n helps $N into $S private chamber.", FALSE, recep, 0, ch, TO_NOTVICT);

   GET_LOADROOM(ch) = world[ch->in_room].vnum;
   extract_char(ch);
   save_player(ch);
   return TRUE;
}


d1387 1
a1387 1
  return (gen_receptionist(ch, me, cmd, argument, RENT_FACTOR));
d1393 1
a1393 1
  return (gen_receptionist(ch, me, cmd, argument, CRYO_FACTOR));
a1396 14
void Crash_save_all(void)
{
  struct descriptor_data *d;
  for (d = descriptor_list; d; d = d->next) {
    if ((d->connected == CON_PLAYING) && !IS_NPC(d->character)) {
      if (PLR_FLAGGED(d->character, PLR_CRASH)) {
        Crash_crashsave(d->character);
        save_player(d->character);
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_CRASH);
      }
    }
  }
}

d1399 3
@


1.68
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.67 2008/04/13 03:41:34 jps Exp jps $
a279 70
int Crash_clean_file(char *name)
{
  char fname[MAX_STRING_LENGTH], filetype[20];
  struct rent_info rent;
  extern int rent_file_timeout, crash_file_timeout;
  FILE *fl;

  if (!get_pfilename(name, fname, CRASH_FILE))
    return 0;
  /*
   * open for write so that permission problems will be flagged now, at boot
   * time.
   */
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT) {        /* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: OPENING OBJECT FILE %s (4)", fname);
      perror(buf1);
    }
    return 0;
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  fclose(fl);

  if ((rent.rentcode == RENT_CRASH) ||
      (rent.rentcode == RENT_FORCED) || (rent.rentcode == RENT_TIMEDOUT)) {
    if (rent.time < time(0) - (crash_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      switch (rent.rentcode) {
      case RENT_CRASH:
        strcpy(filetype, "crash");
        break;
      case RENT_FORCED:
        strcpy(filetype, "forced rent");
        break;
      case RENT_TIMEDOUT:
        strcpy(filetype, "idlesave");
        break;
      default:
        strcpy(filetype, "UNKNOWN!");
        break;
      }
      sprintf(buf, "    Deleting %s's %s file.", name, filetype);
      log(buf);
      return 1;
    }
    /* Must retrieve rented items w/in 30 days */
  } else if (rent.rentcode == RENT_RENTED)
    if (rent.time < time(0) - (rent_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      sprintf(buf, "    Deleting %s's rent file.", name);
      log(buf);
      return 1;
    }
  return (0);
}



void update_obj_file(void)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    Crash_clean_file((player_table + i)->name);
  return;
}



d1269 3
@


1.67
log
@Made quest file saving safer by using the write-to-temp-file-and-rename
trick.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.66 2008/04/02 04:55:59 myc Exp jps $
d1288 1
a1288 1
         GET_LOADROOM(ch) = world[ch->in_room].number;
d1304 1
a1304 1
   GET_LOADROOM(ch) = world[ch->in_room].number;
d1339 4
@


1.66
log
@Got rid of the coins struct.
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.65 2008/03/30 17:28:57 jps Exp myc $
d161 26
a186 15
  char buf[MAX_INPUT_LENGTH];
  struct quest_list *curr;
  FILE *fp;
  /*
   * now save the players quest info
   */
  if (!get_pfilename(GET_NAME(ch), buf, QUEST_FILE))
    return;
  if (!(fp = fopen(buf, "w")))
    return;
  curr = ch->quests;
  while(curr)
  {
    int var_count;
    struct quest_var_list* vars;
d188 11
a198 7
    var_count = 0;
    vars = curr->variables;
    while(vars)
      {
        var_count++;
        vars = vars->next;
      };
d200 1
a200 1
    vars = curr->variables;
d202 1
a202 1
    fprintf(fp,"%d %d %d\n",curr->quest_id,curr->stage, var_count);
d204 3
a206 4
    while(vars)
      {
        struct  quest_var_list * temp;
        temp = vars->next;
d208 1
a208 1
        fprintf(fp, "%s %s\n", vars->var, vars->val);
d210 2
a211 2
        vars = temp;
      };
d213 2
d216 9
a224 3
    curr = curr->next;
  }
  fclose(fp);
d1339 3
@


1.65
log
@Rename objsave.c to pfiles.c.
Change message about loading with no quests from "entering game" to
"starting up", because it isn't necessarily happening at the "enter game"
phase (i.e. when you press 1 at the login menu).
@
text
@d2 1
a2 1
 * $Id: pfiles.c,v 1.64 2008/03/30 17:10:47 jps Exp jps $
d1062 4
a1065 8
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.bank.plat = GET_BANK_PLAT(ch);
  rent.bank.gold = GET_BANK_GOLD(ch);
  rent.bank.silver = GET_BANK_SILVER(ch);
  rent.bank.copper = GET_BANK_COPPER(ch);
d1114 4
a1117 8
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.bank.plat = GET_BANK_PLAT(ch);
  rent.bank.gold = GET_BANK_GOLD(ch);
  rent.bank.silver = GET_BANK_SILVER(ch);
  rent.bank.copper = GET_BANK_COPPER(ch);
d1166 4
a1169 8
  rent.coins.gold = GET_GOLD(ch);
  rent.coins.plat = GET_PLAT(ch);
  rent.coins.silver = GET_SILVER(ch);
  rent.coins.copper = GET_COPPER(ch);
  rent.bank.plat = GET_BANK_PLAT(ch);
  rent.bank.gold = GET_BANK_GOLD(ch);
  rent.bank.silver = GET_BANK_SILVER(ch);
  rent.bank.copper = GET_BANK_COPPER(ch);
d1317 6
@


1.64
log
@Splitting crash_load and naming it "playerload_" objs/quest.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.1 2008/03/30 17:04:12 jps Exp $
d5 1
a5 1
 *  File: objsave.c                                        Part of FieryMUD *
d29 1
a29 1
#include "objsave.h"
d524 1
a524 1
void playerload_quest(struct char_data *ch)
d546 1
a546 1
         sprintf(buf, "%s entering game with no quests.", GET_NAME(ch));
d661 1
a661 1
int playerload_objs(struct char_data *ch)
d1328 4
a1331 1
 * $Log: objsave.c,v $
@


1.63
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.61 2008/03/27 18:38:54 jps Exp myc $
d5 2
a6 2
 *   File: objsave.c                                      Part of FieryMUD *
 *  Usage: loading/saving player objects for rent and crash-save           *
d29 1
d42 2
a43 1
struct obj_data *Obj_from_store_to(struct obj_file_elem object, int *locate) {
d147 1
a147 1
    perror("Error writing object in Obj_to_store");
d155 1
a155 1
  return Obj_to_store_from(obj, fl, 0);
d524 1
a524 10

#define MAX_BAG_ROW 5


int Crash_load(struct char_data * ch)
     /* return values:
        0 - successful load, keep char in rent room.
        1 - load failure or load of crash items -- put char in temple.
        2 - rented equipment lost (no $)
     */
a525 2
   void Crash_crashsave(struct char_data * ch);

d528 1
a528 8
   struct obj_file_elem object;
   struct rent_info rent;
   int orig_rent_code;
   float num_of_days;
   struct obj_data *obj;
   int locate, j, eq = 0, n;
   struct obj_data *obj1;
   struct obj_data *cont_row[MAX_BAG_ROW];
a532 1

a534 4
   /*
    * get the quest info first...cos its quick and easy
    */

d657 24
d736 1
a736 1
         perror("Reading crash file: Crash_load.");
d1329 4
@


1.62
log
@can save aff flags now
@
text
@a40 68
void boot_obj_limit();

/********************************************************
 *        Object limitation functions, by Proky for Hubis.
 *
 * Creates a array of however many items there are in boot, which is
 * left there for whole of game.  When a item is loaded through zedit
 * Then this array will be increased by a value to stop loads after that.
 * It does mean that if a item is purged or lost in some way it wont repop
 * this could be fixed with further checks for destroying a item latter on.
 * The main effect of this code is through reset zone in db.c.
 *
 * - It loops through playerfile to read objects initially.
 */

void boot_obj_limit() {
  FILE *fl;
  char fname[MAX_INPUT_LENGTH];
  struct obj_file_elem object;
  struct rent_info rent; /* basically used just to absorbe some data */
  struct obj_data *obj;
  int i;

  /*actual loop through player list*/
  for (i = 0; i <= top_of_p_table; i++) {
    if (IS_SET(player_table[i].flags, PINDEX_DELETED))
      continue;

    if (player_table[i].level >= LVL_IMMORT)
      continue;

    if (!get_pfilename(player_table[i].name, fname, CRASH_FILE))
      continue;

    if (!(fl = fopen(fname, "rb")))
      continue;

    if (!feof(fl))
      fread(&rent, sizeof(struct rent_info), 1, fl);

    while (!feof(fl))/*main object limit loop*/
      {
        fread(&object, sizeof(struct obj_file_elem), 1, fl);
        if (ferror(fl))
          {
            fclose(fl);
            mudlog("Error reading object file", CMP, LVL_GOD, TRUE);
            continue;
          }
        if (!feof(fl))
          if (real_object(object.item_number) > -1)
            {/*if over 50 k items forget it ! */
              /*check that item NOT over the max items this boot*/
              /*ie check incase real_obj failed*/
              obj = read_object(object.item_number, VIRTUAL);
              if (GET_OBJ_RNUM(obj) <= top_of_objt)
                if (OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj)) < 50000)
                  OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj))++;
              extract_obj(obj);
            }
      }
    fclose(fl);
  }
}

/*****************END OF OBJECT LIMIT CODE*********************/


d59 3
a61 3
   obj->obj_flags.spell_flags = object.spell_flags;
   obj->obj_flags.spell_flags2 = object.spell_flags2;
   obj->obj_flags.spell_flags3 = object.spell_flags3;
d92 2
a93 2
   for (j = 0; j < MAX_OBJ_AFFECT; j++)
      obj->affected[j] = object.affected[j];
d126 5
a130 5
  object.spell_flags = obj->obj_flags.spell_flags;
  object.spell_flags2 = obj->obj_flags.spell_flags2;
  object.spell_flags3 = obj->obj_flags.spell_flags3;
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    object.affected[j] = obj->affected[j];
d998 1
a998 1
  REMOVE_BIT(PLR_FLAGS(ch), PLR_CRASH);
d1203 1
a1203 1
  SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
d1285 1
a1285 1
      SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
d1318 1
a1318 1
        REMOVE_BIT(PLR_FLAGS(d->character), PLR_CRASH);
@


1.61
log
@Stop loading spell flags from obj save files. They're corrupt.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.60 2008/03/27 17:26:40 jps Exp jps $
a126 3
   /* Can't load flags from the store - they are corrupt now!
    * Later, after the save files are fixed. */
   /*
a129 1
   */
d1394 3
@


1.60
log
@Save spell effect flags with objects.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.59 2008/03/22 17:11:38 jps Exp jps $
d127 3
d133 1
d1398 3
@


1.59
log
@Change unrentable check not to look for type KEY, since keys have the
ITEM_NORENT flag placed upon them at creation time.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.58 2008/03/22 16:29:49 jps Exp jps $
d127 3
d194 3
d1394 4
@


1.58
log
@Fix text format in receptionist speech.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.57 2008/03/16 07:21:39 jps Exp jps $
d969 1
a969 2
  if (IS_OBJ_STAT(obj, ITEM_NORENT) || GET_OBJ_RENT(obj) < 0 ||
      GET_OBJ_RNUM(obj) <= NOTHING || GET_OBJ_TYPE(obj) == ITEM_KEY)
d994 2
a995 5
      if (IS_OBJ_STAT(GET_EQ(ch,j), ITEM_NORENT) ||
           GET_OBJ_RENT(GET_EQ(ch,j)) < 0 ||
           GET_OBJ_RNUM(GET_EQ(ch,j)) <= NOTHING ||
           GET_OBJ_TYPE(GET_EQ(ch,j)) == ITEM_KEY)
         obj_to_char(unequip_char(ch,j),ch);
d997 1
a997 1
         Crash_extract_norents(GET_EQ(ch,j));
d1388 3
@


1.57
log
@Remove a debug printf
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.56 2008/03/15 04:49:36 jps Exp jps $
d1336 1
a1336 1
      sprintf(buf, "&0&7&b$n&0&7&b tells you, 'Rent?   Sure, come this way!'");
d1392 3
@


1.56
log
@Cause one log message to be sent to gods when a player with a
problematic quest file logs in.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.55 2008/03/15 04:44:04 jps Exp jps $
a617 1
   printf("CL: reading quest file\n");
d1392 4
@


1.55
log
@Don't mudlog a duplicated-quest error - too much spam.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.54 2008/03/15 04:38:56 jps Exp jps $
d610 1
a610 1
   bool skipquest;
d650 7
a656 3
                  sprintf(buf, "SYSERR: Player %s had duplicate of quest %d (skipped)",
                        GET_NAME(ch), qid);
                  log(buf);
d665 7
a671 3
               sprintf(buf1, "Dropping nonexistent quest %d from player %s.",
                     qid, GET_NAME(ch));
               log(buf1);
d1393 3
@


1.54
log
@Fix for loading a quest file with duplicated quests (I still don't
know how they got duplicated, though).  Removed some debug printages.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.53 2008/03/11 04:33:11 jps Exp jps $
d652 1
a652 1
                  mudlog(buf, NRM, LVL_GOD, TRUE);
d1385 4
@


1.53
log
@Properly skip over nonexistent quests in player quest save files.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.52 2008/03/10 18:01:17 myc Exp jps $
d604 1
a604 1
   int locate, j, eq = 0;
d610 1
d644 21
a664 14
            /*
             * this may not be a valid quest any more (may have been deleted)
             */
            printf(" QUEST: got quest of %d, whose real_quest# is %d\n",
                  qid, real_quest(qid));
            if (real_quest(qid) < 0) {
               if (qid > 0) {
                  int n = 0;
                  while (n < qnum_vars) {
                     /* Eat the data */
                     if (fscanf(fl, "%s %s\n", var_name, var_val) < 2)
                        break;
                     n++;
                  }
d666 5
a670 2
                  sprintf(buf1, "Dropping nonexistent quest %d from player %s.", qid, GET_NAME(ch));
                  log(buf1);
a732 1
   printf("CL: done with quest file.\n");
a736 1
   printf("CL: Opening object file.\n");
d1385 3
@


1.52
log
@Instead of removing berserking when camping/renting, we'll remove
it in the save-player module.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.51 2008/03/05 05:21:56 myc Exp myc $
d45 2
a46 2
 *                                                         
 * Creates a array of however many items there are in boot, which is 
d58 1
a58 1
  char fname[MAX_INPUT_LENGTH]; 
d68 1
a68 1
    
d71 1
a71 1
    
d74 1
a74 1
    
d77 1
a77 1
    
d80 2
a81 2
    
    while (!feof(fl))/*main object limit loop*/ 
d84 1
a84 1
        if (ferror(fl)) 
d91 1
a91 1
          if (real_object(object.item_number) > -1) 
d102 1
a102 1
    fclose(fl);         
d168 1
a168 1
  
d193 1
a193 1
  
d234 1
a234 1
    int var_count; 
d236 3
a238 3
    
    var_count = 0; 
    vars = curr->variables; 
d241 2
a242 2
        var_count++; 
        vars = vars->next; 
d245 1
a245 1
    vars = curr->variables; 
d252 1
a252 1
        temp = vars->next; 
d256 1
a256 1
        vars = temp; 
d259 1
a259 1
    
d270 1
a270 1
  
d281 1
a281 1
  
d297 1
a297 1
  
d310 1
a310 1
  
d313 1
a313 1
  
d324 1
a324 1
  
d341 1
a341 1
  
d380 1
a380 1
  
d396 1
a396 1
  
d439 1
a439 1
  send_to_char(buf, ch); 
d459 1
a459 1
  
d530 2
a531 2
        locate =0;   
      break;  
d596 1
a596 1
  
d611 1
a611 1
   struct quest_var_list *last_var; 
d617 1
d634 2
a635 2
            char buf2[256]; 
            get_line(fl, buf2); 
d637 1
a637 1
            if (feof(fl)) break; 
d640 1
a640 1
               qnum_vars = 0; 
d646 2
d650 1
a650 1
                  int n = 0; 
d652 4
a655 2
                     fscanf(fl, "%s %s\n", var_name,var_val);            
                    /* Eat the data */
d667 1
a667 1
            curr->variables = NULL; 
d670 2
a671 2
               int n = 0; 
               last_var = NULL; 
d678 2
a679 2
                     CREATE(curr->variables->var, char, 21); 
                     CREATE(curr->variables->val, char, 21); 
d687 1
a687 1
                     curr->variables->next = NULL; 
d689 1
a689 1
                     last_var = curr->variables; 
d701 1
a701 1
                     last_var->next->next = NULL; 
d703 1
a703 1
                     last_var = last_var->next; 
d706 1
a706 1
                  n++; 
d722 1
d726 2
d771 1
a771 1
  
d794 1
a794 1
               locate = 0;        
d798 1
a798 1
         * 
d803 1
a803 1
         * 
d809 1
a809 1
         * 
d813 1
a813 1
         * 
d815 1
a815 1
         * 
d819 1
a819 1
        
d856 1
a856 1
          
d875 1
a875 1
          
d891 1
a891 1
  
d897 1
a897 1
  
d899 1
a899 1
  
d911 1
a911 1
  
d916 1
a916 1
    
d919 1
a919 1
    
d952 1
a952 1
  
d956 1
a956 1
  
d976 1
a976 1
  
d993 1
a993 1
  
d1016 1
a1016 1
  
d1019 1
a1019 1
  
d1024 1
a1024 1
  
d1031 1
a1031 1
  
d1045 1
a1045 1
  
d1059 1
a1059 1
  
d1062 1
a1062 1
  
d1067 1
a1067 1
  
d1069 1
a1069 1
  
d1071 1
a1071 1
  
d1078 1
a1078 1
  
d1081 1
a1081 1
  
d1088 1
a1088 1
    
d1096 1
a1096 1
  
d1106 1
a1106 1
  
d1123 1
a1123 1
  
d1138 1
a1138 1
  
d1150 1
a1150 1
  
d1153 1
a1153 1
  
d1158 1
a1158 1
  
d1160 1
a1160 1
  
d1162 1
a1162 1
  
d1192 1
a1192 1
  
d1204 1
a1204 1
  
d1207 1
a1207 1
  
d1212 1
a1212 1
  
d1214 1
a1214 1
  
d1216 1
a1216 1
  
d1218 1
a1218 1
  
d1230 1
a1230 1
  
d1250 1
a1250 1
  
d1266 1
a1266 1
  
d1297 1
a1297 1
   
d1300 1
a1300 1
   
d1376 4
d1494 1
a1494 1
 * rechecked in 1.16 with the quests pointer being set to null (as in 
d1535 1
a1535 1
 * This fixes all of the warnings associated with the new compiler and 
d1540 1
a1540 1
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0 
d1548 1
a1548 1
 * 
d1567 1
a1567 1
 * Indented file 
@


1.51
log
@Fixed boot_obj_limit to not use char_file_u.  It's not being called
though.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.50 2008/03/05 03:03:54 myc Exp myc $
a39 1
void stop_berserking(struct char_data *ch);
a1329 3
   if (AFF_FLAGGED(ch, AFF_BERSERK))
     stop_berserking(ch);
   
d1368 4
@


1.50
log
@get_filename is renamed to get_pfilename
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.49 2008/02/09 04:27:47 myc Exp myc $
d58 1
a58 3
  struct char_file_u chara;
  FILE *player_fl, *fl;
  char fnamecheck[MAX_INPUT_LENGTH];
a59 1
  char fn[255], plr_name[MAX_NAME_LENGTH + 1];
d66 2
a67 13
  for(i = 0; i <= top_of_p_table; i++) {
    memset(fn, 0x0, 255);
    strcpy(plr_name, player_table[i].name);
    plr_name[0] = toupper(plr_name[0]);
    get_pfilename(plr_name, fn, PLR_FILE);

    if (!(player_fl = fopen(fn, "r+"))) {
      sprintf(buf, "No player file for index name: %s", player_table[i].name);
      log(buf);
      continue;
    }
    
    if(!fread(&chara , sizeof(struct char_file_u), 1, player_fl))
a68 2
    else
      fclose(player_fl);
d70 1
a70 2
    /*chara.name is the name string*/
    if (!(strn_cmp(fnamecheck, chara.name, MAX_INPUT_LENGTH)))
d73 1
a73 9
    strncpy(fnamecheck, chara.name, MAX_INPUT_LENGTH);
    
    if (chara.char_specials_saved.act & PLR_DELETED)
      continue;
    
    if (chara.level >= LVL_IMMORT)
      continue;
    
    if (!get_pfilename(chara.name, fname, CRASH_FILE))
d1106 4
a1109 4
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);
d1162 4
a1165 4
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);
d1218 4
a1221 4
  rent.coins.bank_plat = GET_BANK_PLAT(ch);
  rent.coins.bank_gold = GET_BANK_GOLD(ch);
  rent.coins.bank_silver = GET_BANK_SILVER(ch);
  rent.coins.bank_copper = GET_BANK_COPPER(ch);
d1372 3
@


1.49
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.48 2008/01/29 21:02:31 myc Exp myc $
d28 1
d73 1
a73 1
    get_filename(plr_name, fn, PLR_FILE);
d98 1
a98 1
    if (!get_filename(chara.name, fname, CRASH_FILE))
d253 1
a253 1
  if (!get_filename(GET_NAME(ch), buf, QUEST_FILE))
d297 1
a297 1
  if (!get_filename(name, filename, CRASH_FILE))
d324 1
a324 1
  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
d351 1
a351 1
  if (!get_filename(name, fname, CRASH_FILE))
d423 1
a423 1
  if (!get_filename(name, fname, CRASH_FILE))
d643 1
a643 1
   if (!get_filename(GET_NAME(ch), fname, QUEST_FILE)) {
d744 1
a744 1
   if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
d1038 1
a1038 1
  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
d1081 1
a1081 1
  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
d1172 1
a1172 1
  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
d1226 1
a1226 1
  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
d1397 3
@


1.48
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.47 2008/01/27 21:14:59 myc Exp myc $
d27 1
d1396 4
@


1.47
log
@Make players stop berserking and zero rage when renting.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.46 2008/01/09 13:04:40 jps Exp myc $
a31 7
extern struct str_app_type str_app[];
extern struct room_data *world;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
a40 1
extern int top_of_objt; 
a55 1
  extern struct player_index_element *player_table;
d1395 3
@


1.46
log
@Removed the "offer" command and cleaned up.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.45 2008/01/05 05:38:00 jps Exp jps $
d45 1
d1362 3
d1404 3
@


1.45
log
@Changed name of save_char() to save_player().
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.44 2008/01/01 04:34:25 jps Exp jps $
d29 2
a30 2
#define RENT_FACTOR 	1
#define CRYO_FACTOR 	4
d50 2
a51 2
 *	Object limitation functions, by Proky for Hubis.
 *							 
d115 18
a132 18
	fread(&object, sizeof(struct obj_file_elem), 1, fl);
	if (ferror(fl)) 
	  {
	    fclose(fl);
	    mudlog("Error reading object file", CMP, LVL_GOD, TRUE);
	    continue;
	  }
	if (!feof(fl))
	  if (real_object(object.item_number) > -1) 
	    {/*if over 50 k items forget it ! */
	      /*check that item NOT over the max items this boot*/
	      /*ie check incase real_obj failed*/
	      obj = read_object(object.item_number, VIRTUAL);
	      if (GET_OBJ_RNUM(obj) <= top_of_objt)
		if (OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj)) < 50000)
		  OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj))++;
	      extract_obj(obj);
	    }
d273 2
a274 2
	var_count++; 
	vars = vars->next; 
d283 2
a284 2
	struct  quest_var_list * temp;
	temp = vars->next; 
d286 1
a286 1
	fprintf(fp, "%s %s\n", vars->var, vars->val);
d288 1
a288 1
	vars = temp; 
d306 1
a306 1
    if (errno != ENOENT) {	/* if it fails but NOT because of no file */
d315 1
a315 1
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
d333 1
a333 1
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
d364 1
a364 1
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
d380 2
a381 2
	strcpy(filetype, "crash");
	break;
d383 2
a384 2
	strcpy(filetype, "forced rent");
	break;
d386 2
a387 2
	strcpy(filetype, "idlesave");
	break;
d389 2
a390 2
	strcpy(filetype, "UNKNOWN!");
	break;
d466 5
a470 5
	obj = read_object(object.item_number, VIRTUAL);
	sprintf(buf, "%4d. [%5d] (%5dau) <%2d> %-20s\r\n", ++numitems,
		object.item_number, GET_OBJ_RENT(obj),
		object.locate, obj->short_description);
	extract_obj(obj);
d501 1
a501 1
 	locate = 0;
d506 1
a506 1
 	locate = 0;
d510 1
a510 1
 	locate = 0;
d514 1
a514 1
 	locate = 0;
d518 1
a518 1
 	locate = 0;
d522 1
a522 1
 	locate = 0;
d526 1
a526 1
 	locate = 0;
d530 1
a530 1
 	locate = 0;
d534 1
a534 1
 	locate = 0;
d538 1
a538 1
 	locate = 0;
d541 3
a543 3
 	if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
	  locate =0;
	break;
d566 1
a566 1
 	locate = 0;
d571 1
a571 1
 	locate = 0;
d576 1
a576 1
 	locate = 0;
d580 1
a580 1
 	locate = 0;
d584 1
a584 1
 	locate = 0;
d588 1
a588 1
 	locate = 0;
d595 7
a601 7
	/* check ch's alignment to prevent $M from being zapped through auto-equip */
 	if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
 	    (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
 	    (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)))
 	  locate = 0;
 	else {
 	  equip_char(ch, obj, j);
d606 1
a606 1
 	locate = 0;
d622 3
a624 3
	0 - successful load, keep char in rent room.
	1 - load failure or load of crash items -- put char in temple.
	2 - rented equipment lost (no $)
d650 1
a650 1
 	  ch->quests= (struct quest_list *)NULL;
d653 1
a653 1
         if (errno != ENOENT) {	/* if it fails, NOT because of no file */
d681 1
a681 1
                     fscanf(fl, "%s %s\n", var_name,var_val);	    
d753 1
a753 1
      if (errno != ENOENT) {	/* if it fails, NOT because of no file */
a769 13
    /*cost = (int) (rent.net_cost_per_diem * num_of_days);
      if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
      fclose(fl);
      sprintf(buf, "%s entering game, rented equipment lost (no $).",
      GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      Crash_crashsave(ch);
      return 2;
      } */
    /*  GET_BANK_GOLD(ch) -= MAX(cost - GET_GOLD(ch), 0);
	GET_GOLD(ch) = MAX(GET_GOLD(ch) - cost, 0);
	save_player(ch);
    */
d818 1
a818 1
               locate = 0;	
d820 93
a912 93
	/*
	 * what to do with a new loaded item:
	 * 
	 * if there's a list with <locate> less than 1 below this:
	 * (equipped items are assumed to have <locate>==0 here) then its
	 * container has disappeared from the file   *gasp*
	 * -> put all the list back to ch's inventory
	 * 
	 * if there's a list of contents with <locate> 1 below this:
	 * check if it's a container
	 * - if so: get it from ch, fill it, and give it back to ch (this way the
	 * container has its correct weight before modifying ch)
	 * - if not: the container is missing -> put all the list to ch's inventory
	 * 
	 * for items with negative <locate>:
	 * if there's already a list of contents with the same <locate> put obj to it
	 * if not, start a new list
	 * 
	 * Confused? Well maybe you can think of some better text to be put here ...
	 * 
	 * since <locate> for contents is < 0 the list indices are switched to
	 * non-negative
	 */
	
 	if (locate > 0) { /* item equipped */
 	  for (j = MAX_BAG_ROW-1;j > 0;j--)
 	    if (cont_row[j]) { /* no container -> back to ch's inventory */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }
 	  if (cont_row[0]) { /* content list existing */
 	    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
 	      /* rem item ; fill ; equip again */
 	      obj = unequip_char(ch, locate-1);
 	      obj->contains = NULL; /* should be empty - but who knows */
 	      for (;cont_row[0];cont_row[0] = obj1) {
 		obj1 = cont_row[0]->next_content;
 		obj_to_obj(cont_row[0], obj);
 	      }
 	      equip_char(ch, obj, locate-1);
 	    } else { /* object isn't container -> empty content list */
 	      for (;cont_row[0];cont_row[0] = obj1) {
 		obj1 = cont_row[0]->next_content;
 		obj_to_char(cont_row[0], ch);
 	      }
 	      cont_row[0] = NULL;
 	    }
 	  }
 	} else { /* locate <= 0 */
 	  for (j = MAX_BAG_ROW-1;j > -locate;j--)
 	    if (cont_row[j]) { /* no container -> back to ch's inventory */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }
	  
 	  if (j == -locate && cont_row[j]) { /* content list existing */
 	    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
 	      /* take item ; fill ; give to char again */
 	      obj_from_char(obj);
 	      obj->contains = NULL;
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_obj(cont_row[j], obj);
 	      }
 	      obj_to_char(obj, ch); /* add to inv first ... */
 	    } else { /* object isn't container -> empty content list */
 	      for (;cont_row[j];cont_row[j] = obj1) {
 		obj1 = cont_row[j]->next_content;
 		obj_to_char(cont_row[j], ch);
 	      }
 	      cont_row[j] = NULL;
 	    }
 	  }
	  
 	  if (locate < 0 && locate >= -MAX_BAG_ROW) {
	    /* let obj be part of content list
	       but put it at the list's end thus having the items
	       in the same order as before renting */
 	    obj_from_char(obj);
 	    if ((obj1 = cont_row[-locate-1])) {
 	      while (obj1->next_content)
 		obj1 = obj1->next_content;
 	      obj1->next_content = obj;
 	    } else
 	      cont_row[-locate-1] = obj;
 	  }
 	}
a930 2

/*int Crash_save(struct obj_data * obj, FILE * fp)*/
a950 2


a961 1

d1004 4
a1007 4
 	  GET_OBJ_RENT(GET_EQ(ch,j)) < 0 ||
 	  GET_OBJ_RNUM(GET_EQ(ch,j)) <= NOTHING ||
 	  GET_OBJ_TYPE(GET_EQ(ch,j)) == ITEM_KEY)
 	obj_to_char(unequip_char(ch,j),ch);
d1009 1
a1009 1
 	Crash_extract_norents(GET_EQ(ch,j));
a1013 3



a1024 2


a1033 1

d1059 2
a1060 2
	fclose(fp);
	return;
a1091 5
  /*for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
    obj_to_char(unequip_char(ch, j), ch);*/
  /*above is no longer needed did in the following*/
  /*function*/
d1098 1
a1098 1
  /*added inacse we every use cost for rent with autoeq Banyal*/
d1109 1
a1109 1
 	obj_to_char(unequip_char(ch, j), ch);
a1118 7
    /* forcerent cost is 2x normal rent */
    /*while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
      Crash_extract_expensive(ch->carrying);
      cost = 0;
      Crash_calculate_rent(ch->carrying, &cost);
      cost <<= 1;*/
    
a1146 2
  /*Banyal.. eq eq eq lets eq the basterds*/
  /*if (!Crash_save(ch->carrying, fp)) {*/
d1151 2
a1152 2
 	fclose(fp);
 	return;
a1182 3
  /* for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch, j))
     obj_to_char(unequip_char(ch, j), ch);*/
a1201 1
  /*if (!Crash_save(ch->carrying, fp)) {*/
d1205 2
a1206 2
 	fclose(fp);
 	return;
a1236 4
  /* for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch, j))
     obj_to_char(unequip_char(ch, j), ch);*/
  
d1259 1
a1259 1
  /*if (!Crash_save(ch->carrying, fp)) {*/
d1263 2
a1264 2
 	fclose(fp);
 	return;
d1281 3
a1283 19
/* ************************************************************************
 * Routines used for the receptionist					  *
 ************************************************************************* */

void Crash_rent_deadline(struct char_data * ch, struct char_data * recep,
			 long cost)
{
  long rent_deadline;
  
  if (!cost)
    return;
  
  rent_deadline = ((GET_GOLD(ch) + GET_BANK_GOLD(ch)) / cost);
  sprintf(buf,
	  "$n tells you, 'You can rent for %ld day%s with the gold you have\r\n"
	  "on hand and in the bank.'\r\n",
	  rent_deadline, (rent_deadline > 1) ? "s" : "");
  act(buf, FALSE, recep, 0, ch, TO_VICT);
}
d1286 1
a1286 1
			     struct obj_data * obj)
a1304 20
void Crash_report_rent(struct char_data * ch, struct char_data * recep,
		       struct obj_data * obj, long *cost, long *nitems, int display, int factor)
{
  static char buf[256];
  
  if (obj) {
    if (!Crash_is_unrentable(obj)) {
      (*nitems)++;
      *cost += MAX(0, (GET_OBJ_RENT(obj) * factor));
      if (display) {
	sprintf(buf, "    %s",
		OBJS(obj, ch));
	act(buf, FALSE, recep, 0, ch, TO_VICT);
      }
    }
    Crash_report_rent(ch, recep, obj->contains, cost, nitems, display, factor);
    Crash_report_rent(ch, recep, obj->next_content, cost, nitems, display, factor);
  }
}

d1317 2
a1318 2
int Crash_offer_rent(struct char_data * ch, struct char_data * receptionist,
		     int display, int factor)
d1320 7
a1326 46
  extern int max_obj_save;	/* change in config.c */
  char buf[MAX_INPUT_LENGTH];
  int i;
  long totalcost = 0, numitems = 0;
  
  totalcost = min_rent_cost * factor;
  
  Crash_report_rent(ch, receptionist, ch->carrying, &totalcost, &numitems, display, factor);
  
  for (i = 0; i < NUM_WEARS; i++)
    Crash_report_rent(ch, receptionist, GET_EQ(ch,i), &totalcost, &numitems, display, factor);
  /*Crash_report_rent(ch, receptionist, GET_EQ(ch, i), &totalcost, &numitems, display, factor);*/
  
  /*if (!numitems) {
    act("$n tells you, 'But you are not carrying anything!  Just quit!'",
    FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
    }	*/
  if (numitems > max_obj_save) {
    sprintf(buf, "$n tells you, 'I cannot store more than %d items and you have %ld.'",
	    max_obj_save, numitems);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
  }
  if (display) { /* offer */
    sprintf(buf, "$n tells you, 'You'll be renting %ld item%s.'",
            numitems, (numitems == 1)?"":"s");
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
  }
  if (display) {
/*    sprintf(buf, "$n tells you, 'Plus, my %d coin fee..'",
	    min_rent_cost * factor);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    sprintf(buf, "$n tells you, 'For a total of %ld coins%s.'",
	    totalcost, (factor == RENT_FACTOR ? " per day" : ""));
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    if (totalcost > GET_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
	  FALSE, receptionist, 0, ch, TO_VICT);
      return (0);
    } else if (factor == RENT_FACTOR)
      Crash_rent_deadline(ch, receptionist, totalcost); */
    
  }
  return (totalcost);
}
d1328 4
d1333 4
d1338 1
a1338 31
int gen_receptionist(struct char_data * ch, struct char_data * recep,
		     int cmd, char *arg, int mode)
{
  int cost = 0;
  char *action_table[] = {"smile", "dance", "sigh", "blush", "burp",
			  "cough", "fart", "twiddle", "yawn"};
  
  ACMD(do_action);
  
  if (!ch->desc || IS_NPC(ch))
    return FALSE;
  
  if (!cmd && !number(0, 5)) {
    do_action(recep, "", find_command(action_table[number(0, 8)]), 0);
    return FALSE;
  }
  if (!CMD_IS("offer") && !CMD_IS("rent"))
    return FALSE;
  if (!AWAKE(recep)) {
    send_to_char("She is unable to talk to you...\r\n", ch);
    return TRUE;
  }
  if (!CAN_SEE(recep, ch) && GET_LEVEL(ch) < 100) {
    act("$n says, 'I don't deal with people I can't see!'", FALSE, recep, 0, 0, TO_ROOM);
    return TRUE;
  }
  /*if (free_rent) {
    return 1;
    }	*/
  if (CMD_IS("rent")) {
    if (Crash_report_norent(ch, recep)) {
d1341 5
a1345 17
    }
    if (!(cost = Crash_offer_rent(ch, recep, FALSE, mode)))
      return TRUE;
    if (mode == RENT_FACTOR)
      sprintf(buf, "&0&7&b$n&0&7&b tells you, 'Rent?  Sure, come this way!'");
    /*else if (mode == CRYO_FACTOR)
      sprintf(buf, "$n tells you, 'It will cost you %d gold coins to be frozen.'", cost);
    */act(buf, FALSE, recep, 0, ch, TO_VICT);
    /*if (cost > GET_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
      FALSE, recep, 0, ch, TO_VICT);
      return TRUE;
      }
      if (cost && (mode == RENT_FACTOR))
      Crash_rent_deadline(ch, recep, cost);
    */
    if (mode == RENT_FACTOR) {
d1347 1
a1347 1
	  FALSE, recep, 0, ch, TO_VICT);
d1349 1
a1349 1
	GET_LOADROOM(ch) = world[ch->in_room].number;
d1352 1
a1352 1
    } else {			/* cryo */
d1354 3
a1356 3
	  "A white mist appears in the room, chilling you to the bone...\r\n"
	  "You begin to lose consciousness...",
	  FALSE, recep, 0, ch, TO_VICT);
d1360 9
a1368 19
    }
    
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    act("$n helps $N into $S private chamber.", FALSE, recep, 0, ch, TO_NOTVICT);
    if (CMD_IS("rent"))
      GET_LOADROOM(ch) = world[ch->in_room].number;
    extract_char(ch);
    save_player(ch);
  } else {
    if (Crash_report_norent(ch, recep)) {
      act("$N shakes $M head at $n.", TRUE, ch, 0, recep, TO_ROOM);
      return TRUE;
    }
    act("$N gives $n an offer.", FALSE, ch, 0, recep, TO_ROOM);
    act("$n tells you, 'We do not charge for rent around these parts.'", FALSE, recep, 0, ch, TO_VICT);
    act("$n tells you, 'Here's a list of equipment you'll be renting:'", FALSE, recep, 0, ch, TO_VICT);
    Crash_offer_rent(ch, recep, TRUE, mode);
  }
  return TRUE;
d1390 3
a1392 3
	Crash_crashsave(d->character);
	save_player(d->character);
	REMOVE_BIT(PLR_FLAGS(d->character), PLR_CRASH);
d1400 3
@


1.44
log
@Fix punctuation in receptionist speech.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.43 2007/12/19 20:55:20 myc Exp jps $
d781 1
a781 1
	save_char(ch);
d1522 1
a1522 1
    save_char(ch);
d1556 1
a1556 1
	save_char(d->character);
d1565 3
d1569 1
a1569 1
 * save_char() no longer requires a save room (which wasn't being used
@


1.43
log
@save_char() no longer requires a save room (which wasn't being used
anyway).
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.42 2007/10/11 20:14:48 myc Exp myc $
d1488 1
a1488 1
      sprintf(buf, "&0&7&b$n&0&7&b tells you, 'Rent?, sure, come this way!.'");
d1565 4
@


1.42
log
@Made offer a little less spammy.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.41 2007/09/20 21:20:43 myc Exp myc $
d781 1
a781 1
	save_char(ch, NOWHERE);
a1454 1
  int save_room;
a1518 1
    save_room = ch->in_room;
d1522 1
a1522 1
    save_char(ch, save_room);
d1556 1
a1556 1
	save_char(d->character, NOWHERE);
d1565 3
@


1.41
log
@Hide points and perception are in.  The hiddenness field in the object
file element replaced the bitvector field, which was unused.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.40 2007/09/03 19:02:24 jps Exp myc $
d1377 1
a1377 1
	sprintf(buf, "$n tells you, '    %s'",
d1567 4
@


1.40
log
@Make receptionist offer/rent conversation more sensible when you have
unrentable items.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.39 2007/08/22 17:56:19 jps Exp jps $
d158 1
a158 1
   obj->obj_flags.bitvector = object.bitvector;
d222 1
a222 1
  object.bitvector = obj->obj_flags.bitvector;
d1567 4
@


1.39
log
@Remove the "Autosaving...." message.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.38 2007/07/24 23:02:52 jps Exp jps $
d1387 10
d1405 1
a1405 9
  long totalcost = 0, numitems = 0, norent = 0;
  
  norent = Crash_report_unrentables(ch, receptionist, ch->carrying);
  for (i = 0; i < NUM_WEARS; i++)
    /*norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch, i));*/
    norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch,i));
  
  if (norent)
    return 0;
d1482 4
d1526 4
d1567 3
@


1.38
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.37 2007/04/15 06:21:32 jps Exp jps $
a1548 1
        send_to_char("Autosaving.....\r\n", d->character);
d1557 3
@


1.37
log
@Fix saved spellbooks being reloaded broken.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.36 2007/03/31 14:38:03 myc Exp jps $
d1558 3
d1600 1
a1600 1
 * removed dodgy fprintf() which was referencing non-existant obj
d1616 1
a1616 1
 * remove non existant quests from players when they log in
@


1.36
log
@Made only 'offer' tell how many items the player has, instead of
'rent' too.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.35 2007/03/27 04:27:05 myc Exp myc $
d141 45
a185 26
struct obj_data *Obj_from_store_to(struct obj_file_elem object, int *locate)
{
  struct obj_data *obj;
  struct spell_book_list *book, *pbook;
  int j = 0;
  char *list_parse, *spell_parse, *list;
  
  if (real_object(object.item_number) > -1) {
    obj = read_object(object.item_number, VIRTUAL);
    *locate = (int) object.locate;
    GET_OBJ_VAL(obj, 0) = object.value[0];
    GET_OBJ_VAL(obj, 1) = object.value[1];
    GET_OBJ_VAL(obj, 2) = object.value[2];
    GET_OBJ_VAL(obj, 3) = object.value[3];
    GET_OBJ_EXTRA(obj) = object.extra_flags;
    GET_OBJ_WEIGHT(obj) = object.weight;
    GET_OBJ_TIMER(obj) = object.timer;
    obj->obj_flags.bitvector = object.bitvector;
    if(GET_OBJ_TYPE(obj) == ITEM_SPELLBOOK) {

/*      obj->spell_book_length = object.spell_book_length; */
        obj->spell_book_length = MAX_SPELLBOOK_PAGES;
      if((list = object.spells_in_book)) {
	CREATE(obj->spell_book, struct spell_book_list, 1);
        obj->spell_book->next = 0;
        book = obj->spell_book;
d187 3
a189 23
      if(book) {
	while((list_parse = strsep(&list, ",")) && strlen(object.spells_in_book))
	  {
	    if(list_parse && strlen(list_parse)) {
	      if(j > 0) {
                pbook = book;
		CREATE(book, struct spell_book_list, 1);
		pbook->next = book;
                book->next = 0;
	      }
	      spell_parse = strsep(&list_parse, "_");
	      book->spell = atoi(spell_parse);
	      spell_parse = strsep(&list_parse, "_");
	      book->spell_length = atoi(spell_parse);
	      j++;
	    }
	  }
      } else {
        log("Unable to malloc spellbook");
	return NULL;
      }
    }
    for (j = 0; j < MAX_OBJ_AFFECT; j++)
d191 2
a192 4
    
    return obj;
  } else
    return NULL;
d1558 4
@


1.35
log
@Receptionist will tell you how many items you have even if less than 50.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.34 2006/11/20 21:21:55 jps Exp myc $
d1427 5
a1431 3
  sprintf(buf, "$n tells you, 'Which comes to %ld item%s.'",
          numitems, (numitems == 1)?"":"s");
  act(buf, FALSE, receptionist, 0, ch, TO_VICT);
d1561 3
@


1.34
log
@Stop "show rent" from crashing the mud when a player has
too much stuff.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.33 2006/11/18 18:55:09 jps Exp jps $
d1427 3
d1559 4
@


1.33
log
@Properly re-equip items in WEAR_HOLD2 when reentering the game.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.32 2002/09/20 03:49:20 jjl Exp jps $
d430 1
d460 1
d470 1
a470 1
	sprintf(buf, "%s [%5d] (%5dau) <%2d> %-20s\r\n", buf,
d474 1
a476 1
  send_to_char(buf, ch);
d1556 3
@


1.32
log
@Fix the reading of quest files so the old no variable style
can be read, along with the new style with a variable count.
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.31 2002/09/19 01:07:53 jjl Exp $
d584 5
a588 3
      if (!CAN_WEAR(obj,ITEM_WEAR_HOLD) &&
 	  !(IS_WARRIOR(ch) &&
 	    CAN_WEAR(obj,ITEM_WEAR_WIELD) && GET_OBJ_TYPE(obj) == ITEM_WEAPON))
d628 1
a628 1
  void Crash_crashsave(struct char_data * ch);
d630 13
a642 13
  FILE *fl;
  char fname[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct rent_info rent;
  int orig_rent_code;
  float num_of_days;
  struct obj_data *obj;
  int locate, j, eq = 0;
  struct obj_data *obj1;
  struct obj_data *cont_row[MAX_BAG_ROW];
  struct quest_list *plyrqsts,*curr;
  int qid,qst,qnum_vars;
  char var_name[21];  char var_val[21];
d644 1
a644 1
  struct quest_var_list *last_var; 
d646 3
a648 4
  
  /*
   * get the quest info first...cos its quick and easy
   */
d650 98
a747 50
  if (!get_filename(GET_NAME(ch), fname, QUEST_FILE))
  {
	  ch->quests= (struct quest_list *)NULL;
  }
  else
  {
  if (!(fl = fopen(fname, "r"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: READING QUEST FILE %s (5)", fname);
      perror(buf1);
      send_to_char("\r\n********************* NOTICE *********************\r\n"
		   "There was a problem loading your quests from disk.\r\n"
		   "Contact a God for assistance.\r\n", ch);
    }
    sprintf(buf, "%s entering game with no quests.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    ch->quests= (struct quest_list *)NULL;
  }
  else
  {
  while(!feof(fl))
  {
    char buf2[256]; 
    get_line(fl, buf2); 
    
    if (feof(fl)) break; 

    if (sscanf(buf2, "%i %i %i\n", &qid, &qst, &qnum_vars) == 2)
      {
	qnum_vars = 0; 
      };

    /*
     * this may not be a valid quest any more (may have been deleted)
     */
    if (real_quest(qid) < 0)
      {
	if (qid > 0)
	  {
	    int n = 0; 
	    while (n < qnum_vars)
	      {
		fscanf(fl, "%s %s\n", var_name,var_val);	    
		/* Eat the data */
	      };

	    sprintf(buf1,"Dropping nonexistant quest %d from player %s",qid,GET_NAME(ch));
	    log(buf1);
	  }
	continue;
d749 1
d751 9
a759 63
    CREATE(curr,struct quest_list,1);
    curr->quest_id = qid;
    curr->stage=qst;
    curr->variables = NULL; 


    if (qnum_vars)
      {
	int n = 0; 
	last_var = NULL; 
	

	while(n < qnum_vars)
	  {
	    fscanf(fl, "%s %s\n", var_name, var_val);
	    
	    if (last_var == NULL)
	      {

       		CREATE(curr->variables, struct quest_var_list,1);
		CREATE(curr->variables->var, char, 21); 
		CREATE(curr->variables->val, char, 21); 
		
		strncpy(curr->variables->var, var_name, 20);
		strncpy(curr->variables->val, var_val, 20);

		curr->variables->var[20] = '\0';
		curr->variables->val[20] = '\0';
		
		curr->variables->next = NULL; 
		
		last_var = curr->variables; 
	      }
	    else
	      {
		CREATE(last_var->next, struct quest_var_list, 1);
		CREATE(last_var->next->var, char, 21);
		CREATE(last_var->next->val, char, 21);
		
		strncpy(last_var->next->var, var_name, 20);
		strncpy(last_var->next->val, var_val, 20);

		last_var->next->var[20] = '\0';
		last_var->next->val[20] = '\0';
		
		last_var->next->next = NULL; 
		
		last_var = last_var->next; 
	      };

	    n++; 
	  };
      };
    
    curr->next = (struct quest_list *)NULL;
    
    plyrqsts = ch->quests;
    if (plyrqsts == (struct quest_list *)NULL)
      ch->quests = curr;
    else
      {
	while(plyrqsts->next) plyrqsts=plyrqsts->next;
	plyrqsts->next = curr;
d761 4
a764 1
    
d766 2
d769 2
a770 24
  }
  fclose(fl);
  }
  }
  
  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
    return 1;
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      sprintf(buf1, "SYSERR: READING OBJECT FILE %s (5)", fname);
      perror(buf1);
      send_to_char("\r\n********************* NOTICE *********************\r\n"
		   "There was a problem loading your objects from disk.\r\n"
		   "Contact a God for assistance.\r\n", ch);
    }
    sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    return 1;
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  
  if (rent.rentcode == RENT_RENTED || rent.rentcode == RENT_TIMEDOUT) {
    num_of_days = (float) (time(0) - rent.time) / SECS_PER_REAL_DAY;
d784 35
a818 35
  }
  switch (orig_rent_code = rent.rentcode) {
  case RENT_RENTED:
    sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRASH:
    sprintf(buf, "%s retrieving crash-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRYO:
    sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_FORCED:
  case RENT_TIMEDOUT:
    sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  default:
    sprintf(buf, "WARNING: %s entering game with undefined rent code.", GET_NAME(ch));
    mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  }
  
  for (j = 0;j < MAX_BAG_ROW;j++)
    cont_row[j] = NULL; /* empty all cont lists (you never know ...) */
  
  
  while (!feof(fl)) {
    eq = 0;
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("Reading crash file: Crash_load.");
      fclose(fl);
d820 13
a832 12
    }
    if (!feof(fl))
      if ((obj = Obj_from_store_to(object, &locate))) {
 	eq = auto_equip(ch, obj, locate);
        /* 5/5/01 - Zantir - Found a bug in the auto_equip code
           that would crash the mud if a player couldn't wear an
           container that the mud thought they were already
           wearing. So now the auto_equip function returns a value,
           if a 1 isn't returned the assume the item can't be
           reworn so set the locate value to 0. */
        if (eq == 0)
          locate = 0;	
d1554 4
@


1.31
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.30 2002/09/13 02:32:10 jjl Exp $
d671 4
d676 1
a676 1
    if (fscanf(fl,"%d %d %d\n",&qid,&qst,&qnum_vars) == 2)
d1574 3
@


1.30
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: objsave.c,v 1.29 2001/08/04 12:14:48 mtp Exp $
d269 27
a295 2
	  fprintf(fp,"%d %d\n",curr->quest_id,curr->stage);
	  curr = curr->next;
d639 5
a643 1
  int qid,qst;
d671 12
a682 5
	  fscanf(fl,"%d %d\n",&qid,&qst);
	  /*
	   * this may not be a valid quest any more (may have been deleted)
	   */
	  if (real_quest(qid) < 0)
d684 9
a692 6
		  if (qid > 0)
		  {
		  	sprintf(buf1,"Dropping nonexistant quest %d from player %s",qid,GET_NAME(ch));
		  	log(buf1);
		  }
		  continue;
d694 16
a709 9
	  CREATE(curr,struct quest_list,1);
	  curr->quest_id = qid;
	  curr->stage=qst;
	  curr->next = (struct quest_list *)NULL;

	  plyrqsts = ch->quests;
	  if (plyrqsts == (struct quest_list *)NULL)
		  ch->quests = curr;
	  else
d711 53
a763 3
	  	while(plyrqsts->next) plyrqsts=plyrqsts->next;
	  	plyrqsts->next = curr;
	  }
d1570 3
@


1.29
log
@moved the create/free portion of the quest read to hopefully avoid
unnecessary log messages and memory munging for people with empty quest files
@
text
@d1 3
a3 1
// $Id: objsave.c,v 1.28 2001/05/06 15:01:47 dce Exp $
d1472 121
a1592 115
// $Log: objsave.c,v $
// Revision 1.28  2001/05/06 15:01:47  dce
// Fixed a crash bug in autoequip.
//
// Revision 1.27  2001/03/24 19:49:45  dce
// Players with objects that are higher than their level
// will have the objects autoremoved when unrenting.
//
// Revision 1.26  2001/03/07 03:14:28  dce
// Gods can now rent while invis.
//
// Revision 1.25  2001/01/04 23:12:52  mtp
// removed dodgy fprintf() which was referencing non-existant obj
// hopefully this will now allow restore of dual wield, 2H wield on unrent
//
// Revision 1.24  2000/12/22 01:34:00  mtp
// autowear of 2Hander and snd wielded weapons
//
// Revision 1.23  2000/11/26 20:28:31  mtp
// oops..bug which quitted load oif no quest file found which stopped
// load of eq
//
// Revision 1.22  2000/11/24 19:17:01  rsd
// Altered comment header and added missing and back rlog
// messages from prior to the addition of the $log$ string.
// Also move the log string to the proper location.
//
// Revision 1.21  2000/11/15 00:42:44  mtp
// remove non existant quests from players when they log in
//
// Revision 1.20  2000/11/03 05:37:17  jimmy
// Removed the quest.h file from structs.h arg!! and placed it
// only in the appropriate files
// Updated the dependancies in the Makefile and created
// make supahclean.
//
// Revision 1.19  2000/11/01 00:21:15  mtp
// rechecked in 1.16 with the quests pointer being set to null (as in 
// changes 1.17 and 1.18) to get logging correct
//
// Revision 1.18  2000/10/31 22:26:42  mtp
// more nulling of quests pointers ...
//
// Revision 1.17  2000/10/31 21:09:45  mtp
// added explicit set of quests to null if no quests loaded to fix stat_char crash?
//
// Revision 1.16  2000/10/27 00:34:45  mtp
// extra code to save quests and to load them
//
// Revision 1.15  2000/10/12 21:15:55  cmc
// oops.. long int format, not regular int.
//
// Revision 1.14  2000/10/12 21:13:53  cmc
// show how many items you have when you are over the max to rent!
//
// Revision 1.13  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.12  1999/09/04 22:13:11  mud
// fixed unused variable warning
//
// Revision 1.11  1999/09/04 18:46:52  jimmy
// More small but important bug fixes found with insure.  These are all runtime fixes.
//
// Revision 1.10  1999/08/13 15:31:01  dce
// Fixed has rented message.
//
// Revision 1.9  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.8  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0 
//
// Revision 1.7  1999/05/04 18:03:09  dce
// Offer is fixed
//
// Revision 1.6  1999/03/03 20:11:02  jimmy
// Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
// Spellbooks now have to be held to scribe as well as a quill in the other hand.
// 
// -fingon
//
// Revision 1.5  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
//
// Revision 1.4  1999/02/06 02:25:31  jimmy
// ok, This fixes the pwipe problem, apparently
// my change didn't make it into the src last time around
//
// Revision 1.3  1999/02/05 07:47:42  jimmy
// Added Poofs to the playerfile as well as 4 extra strings for
// future use.  fingon
//
// Revision 1.2  1999/01/31 21:57:39  mud
// Indented file 
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.28
log
@Fixed a crash bug in autoequip.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.27 2001/03/24 19:49:45 dce Exp $
d612 1
d640 1
a640 3
	  CREATE(curr,struct quest_list,1);
	  fscanf(fl,"%d %d\n",(int *)&(curr->quest_id),(int *)&(curr->stage));
	  curr->next = (struct quest_list *)NULL;
d644 1
a644 1
	  if (real_quest(curr->quest_id) < 0)
d646 5
a650 3
		  sprintf(buf1,"Dropping nonexistant quest %d from player %s",curr->quest_id,GET_NAME(ch));
		  log(buf1);
		  free(curr);
d653 4
d1471 3
@


1.27
log
@Players with objects that are higher than their level
will have the objects autoremoved when unrenting.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.26 2001/03/07 03:14:28 dce Exp $
d462 1
a462 1
void auto_equip(struct char_data *ch, struct obj_data *obj, int locate)
d572 1
a572 1
 	else
d574 2
d583 2
d608 1
a608 1
  int locate, j;
d728 1
d737 10
a746 2
 	auto_equip(ch, obj, locate);
	
d1466 4
@


1.26
log
@Gods can now rent while invis.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.25 2001/01/04 23:12:52 mtp Exp $
d467 2
d1453 3
@


1.25
log
@removed dodgy fprintf() which was referencing non-existant obj
hopefully this will now allow restore of dual wield, 2H wield on unrent
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.24 2000/12/22 01:34:00 mtp Exp mtp $
d1366 1
a1366 1
  if (!CAN_SEE(recep, ch)) {
d1451 4
@


1.24
log
@autowear of 2Hander and snd wielded weapons
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.23 2000/11/26 20:28:31 mtp Exp mtp $
a212 1
  fprintf(stderr,"Obj_to_store_from: obj %s from location %d\n",obj->name,locate);
a849 1
  fprintf(stderr,"Crash_save: obj %s from location %d\n",obj->name,locate);
d1451 3
@


1.23
log
@oops..bug which quitted load oif no quest file found which stopped
load of eq
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.22 2000/11/24 19:17:01 rsd Exp mtp $
d213 1
d547 1
d551 4
d851 1
d1453 4
@


1.22
log
@Altered comment header and added missing and back rlog
messages from prior to the addition of the $log$ string.
Also move the log string to the proper location.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.21 2000/11/15 00:42:44 mtp Exp $
a608 1
	  return 1;
d610 2
a622 1
    return 1;
d624 2
d652 2
d1446 5
@


1.21
log
@remove non existant quests from players when they log in
@
text
@d1 3
a3 3
// $Id: objsave.c,v 1.16 2000/10/27 00:34:45 mtp Exp $
/* ************************************************************************
 *   File: objsave.c                                     Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
a16 1

d1441 4
d1452 8
a1459 2
// rechecked in 1.16 with the quests pointer being set to null (as in changes 1.17 and 1.18)
// to get logging correct
a1460 1
// $Log: objsave.c,v $
d1472 57
@


1.20
log
@Removed the quest.h file from structs.h arg!! and placed it
only in the appropriate files
Updated the dependancies in the Makefile and created
make supahclean.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.19 2000/11/01 00:21:15 mtp Exp $
d628 11
d1440 6
a1445 1
// $Log: objsave.c,v $
d1450 1
@


1.19
log
@rechecked in 1.16 with the quests pointer being set to null (as in changes 1.17 and 1.18)
to get logging correct
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.16 2000/10/27 00:34:45 mtp Exp $
d23 1
d1430 4
@


1.18
log
@more nulling of quests pointeres ...
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.13 1999/09/05 07:00:39 jimmy Exp $
d249 1
d271 1
d606 2
a607 2
    ch->quests = (struct quest_list *)NULL;
    return 1;
d619 1
a619 1
    ch->quests = (struct quest_list *)NULL;
d637 1
a637 1

a971 1

d976 1
d1296 2
a1297 2
    sprintf(buf, "$n tells you, 'Sorry, but I cannot store more than %d items.'",
	    max_obj_save);
d1429 9
@


1.17
log
@added explicit set of quests to null if no quests loaded to fix stat_char crash?
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.16 2000/10/27 00:34:45 mtp Exp mtp $
a248 1

a269 1

d603 2
d606 1
d635 1
a635 1
  
d970 1
a974 1

d1294 2
a1295 2
    sprintf(buf, "$n tells you, 'I cannot store more than %d items and you have %ld.'",
	    max_obj_save, numitems);
a1426 9
// Revision 1.16  2000/10/27 00:34:45  mtp
// extra code to save quests and to load them
//
// Revision 1.15  2000/10/12 21:15:55  cmc
// oops.. long int format, not regular int.
//
// Revision 1.14  2000/10/12 21:13:53  cmc
// show how many items you have when you are over the max to rent!
//
@


1.16
log
@extra code to save quests and to load them
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.15 2000/10/12 21:15:55 cmc Exp mtp $
d616 1
d1426 3
@


1.15
log
@oops.. long int format, not regular int.
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.14 2000/10/12 21:13:53 cmc Exp cmc $
d250 20
d598 35
d968 1
d1075 1
d1133 1
d1195 1
d1425 3
@


1.14
log
@show how many items you have when you are over the max to rent!
@
text
@d1 1
a1 1
// $Id: objsave.c,v 1.13 1999/09/05 07:00:39 jimmy Exp cmc $
d1233 1
a1233 1
    sprintf(buf, "$n tells you, 'I cannot store more than %d items and you have %d.'",
d1366 3
@


1.13
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d1233 2
a1234 2
    sprintf(buf, "$n tells you, 'Sorry, but I cannot store more than %d items.'",
	    max_obj_save);
d1365 4
a1368 1
// $Log$
@


1.12
log
@fixed unused variable warning
@
text
@d1 1
d1365 1
@


1.11
log
@More small but important bug fixes found with insure.  These are all runtime fixes.
@
text
@d571 1
a571 1
  int cost, orig_rent_code;
@


1.10
log
@Fixed has rented message.
@
text
@d597 2
a598 2
    cost = (int) (rent.net_cost_per_diem * num_of_days);
    /*if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
@


1.9
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d1309 1
a1309 2
      sprintf(buf, "%s has rented (%d/day, %ld tot.)", GET_NAME(ch),
	      cost, GET_GOLD(ch) + GET_BANK_GOLD(ch));
@


1.8
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@a40 3



a43 1

d57 2
a58 3

void boot_obj_limit()
{
d60 1
a60 2
  FILE *pfptr;
  FILE *fl;
d63 1
d65 1
a65 1
  struct rent_info rent;/*basically used just to absorbe some data*/
d67 13
a79 20
  
  /*loop through player list reading there eq files*/
  /*General check that player file present etcetc*/	
  if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
    {
      if (errno != ENOENT) 
        {
	  perror("fatal error opening playerfile");
	  exit(1);
        } 
      else 
        {
	  log("No playerfile.  Creating a new one.");
	  touch(PLAYER_FILE);
	  if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
            {
	      perror("fatal error opening playerfile");
	      exit(1);
            }
        }
d81 46
a126 42
  rewind(pfptr);
  /*actual loop through player list*/
  while (!feof(pfptr))
    {/*loops through playerfile now its open and all is well*/
     /* The next two lines fixes the pwipe problem.   */
     /* mud would crash after total pwipe/objwipe */
     /* --Fingon                                  */

      clearerr(pfptr);

      if(!fread(&chara , sizeof(struct char_file_u), 1, pfptr))
        continue;

      /*chara.name is the name string*/
      if (!(strn_cmp(fnamecheck, chara.name, MAX_INPUT_LENGTH)))
	continue;

      strncpy(fnamecheck, chara.name, MAX_INPUT_LENGTH);

      if (chara.char_specials_saved.act & PLR_DELETED)
	continue;
      
      if (chara.level >= LVL_IMMORT)
	continue;

      if (!get_filename(chara.name, fname, CRASH_FILE))
	continue;

      if (!(fl = fopen(fname, "rb")))
	continue;
      
      if (!feof(fl))
	fread(&rent, sizeof(struct rent_info), 1, fl);
      
      while (!feof(fl))/*main object limit loop*/ 
	{
	  fread(&object, sizeof(struct obj_file_elem), 1, fl);
	  if (ferror(fl)) 
	    {
	      fclose(fl);
	      mudlog("Error reading object file", CMP, LVL_GOD, TRUE);
	      continue;
d128 3
a130 15
	  if (!feof(fl))
	    if (real_object(object.item_number) > -1) 
	      {/*if over 50 k items forget it ! */
		/*check that item NOT over the max items this boot*/
		/*ie check incase real_obj failed*/
		obj = read_object(object.item_number, VIRTUAL);
		if (GET_OBJ_RNUM(obj) <= top_of_objt)
		  if (OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj)) < 50000)
		    OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj))++;
		extract_obj(obj);
	      }
	}
      fclose(fl);         
    }
  
@


1.7
log
@Offer is fixed
@
text
@d555 1
a555 1
    if (locate > 0)
d567 1
@


1.6
log
@Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
Spellbooks now have to be held to scribe as well as a quill in the other hand.

-fingon
@
text
@d1209 2
a1210 2
	sprintf(buf, "$n tells you, '%5d coins for %s..'",
		(GET_OBJ_RENT(obj) * factor), OBJS(obj, ch));
d1257 1
a1257 1
    sprintf(buf, "$n tells you, 'Plus, my %d coin fee..'",
d1268 2
a1269 1
      Crash_rent_deadline(ch, receptionist, totalcost);
d1348 3
a1351 1
    act("$N gives $n an offer.", FALSE, ch, 0, recep, TO_ROOM);
@


1.5
log
@Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
and take 20 seconds to scribe each page.  This will be more dynamic when the
SCRIBE skill is introduced.  --Fingon.
@
text
@a254 1
log(object.spells_in_book);
@


1.4
log
@ok, This fixes the pwipe problem, apparently
my change didn't make it into the src last time around
@
text
@d159 3
a161 1
  int j;
d174 29
a202 12
    
    if(*(object.PSE_Desc) == '1')
      {  
	CREATE(obj->ex_description, struct extra_descr_data, 1);
	memset(obj->ex_description, 0x0, sizeof(struct extra_descr_data));
	obj->ex_description->keyword = (char *) malloc(strlen("PSE")+1);
	if(obj->ex_description->keyword)
	  strcpy(obj->ex_description->keyword, "PSE");
	
	obj->ex_description->description = (char *) malloc(128);
	if(obj->ex_description->description)
	  strncpy(obj->ex_description->description, object.PSE_Desc + 1, 128); 
d204 1
a204 1
    
a224 1
     /*int Obj_to_store(struct obj_data * obj, FILE * fl)*/
d228 3
a230 2
  struct extra_descr_data *tmpdesc;
  
d244 9
a252 13
  
  /* find out if this is a spellbook that needs the spells stored... */
  memset(object.PSE_Desc, 0x0, sizeof(object.PSE_Desc)); 
  
  tmpdesc = obj->ex_description;
  for(;tmpdesc; tmpdesc = tmpdesc->next)
    {
      if((tmpdesc->keyword) && (strcmp(tmpdesc->keyword, "PSE") == 0))
	{ 
	  strcpy(object.PSE_Desc, "1");
	  strcat(object.PSE_Desc, tmpdesc->description);
	  break;
	}
d254 3
a256 1
  
@


1.3
log
@Added Poofs to the playerfile as well as 4 extra strings for
future use.  fingon
@
text
@d97 1
a97 1
     /* This next line fixes the pwipe problem.   */
d100 1
d103 2
a104 1
      fread(&chara , sizeof(struct char_file_u), 1, pfptr);
@


1.2
log
@Indented file
@
text
@d97 5
d103 1
d105 1
a105 1
      if (!(str_cmp(fnamecheck, chara.name)))
d107 3
a109 1
      strcpy(fnamecheck, chara.name);
d115 1
d118 1
a118 1
      
@


1.1
log
@Initial revision
@
text
@d2 8
a9 8
*   File: objsave.c                                     Part of CircleMUD *
*  Usage: loading/saving player objects for rent and crash-save           *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d48 12
a59 12
/********************************************************\
Object limitation functions, by Proky for Hubis.

Creates a array of however many items there are in boot, which is 
left there for whole of game.  When a item is loaded through zedit
Then this array will be increased by a value to stop loads after that.
It does mean that if a item is purged or lost in some way it wont repop
this could be fixed with further checks for destroying a item latter on.
The main effect of this code is through reset zone in db.c.

- It loops through playerfile to read objects initially.
*/
d64 12
a75 12
	struct char_file_u chara;
    FILE *pfptr;
	FILE *fl;
	char fnamecheck[MAX_INPUT_LENGTH];
	char fname[MAX_INPUT_LENGTH]; 
	struct obj_file_elem object;
	struct rent_info rent;/*basically used just to absorbe some data*/
	struct obj_data *obj;
    
/*loop through player list reading there eq files*/
/*General check that player file present etcetc*/	
   if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d77 1
a77 1
        if (errno != ENOENT) 
d79 2
a80 2
            perror("fatal error opening playerfile");
            exit(1);
d82 1
a82 1
        else 
d84 3
a86 3
            log("No playerfile.  Creating a new one.");
            touch(PLAYER_FILE);
            if (!(pfptr = fopen(PLAYER_FILE, "r+b"))) 
d88 2
a89 2
	            perror("fatal error opening playerfile");
	            exit(1);
d92 4
a95 4
	}
	rewind(pfptr);
	/*actual loop through player list*/
    while (!feof(pfptr))
d97 39
a135 41
        fread(&chara , sizeof(struct char_file_u), 1, pfptr);
		/*chara.name is the name string*/
	if (!(str_cmp(fnamecheck, chara.name)))
			continue;
		strcpy(fnamecheck, chara.name);
		if (chara.char_specials_saved.act & PLR_DELETED)
		    continue;

		if (chara.level >= LVL_IMMORT)
			continue;
		if (!get_filename(chara.name, fname, CRASH_FILE))
			continue;

		if (!(fl = fopen(fname, "rb")))
			continue;
  
		if (!feof(fl))
				fread(&rent, sizeof(struct rent_info), 1, fl);

		while (!feof(fl))/*main object limit loop*/ 
		{
			fread(&object, sizeof(struct obj_file_elem), 1, fl);
			if (ferror(fl)) 
			{
				fclose(fl);
				mudlog("Error reading object file", CMP, LVL_GOD, TRUE);
				continue;
			}
			if (!feof(fl))
				if (real_object(object.item_number) > -1) 
				{/*if over 50 k items forget it ! */
					/*check that item NOT over the max items this boot*/
					/*ie check incase real_obj failed*/
				obj = read_object(object.item_number, VIRTUAL);
					if (GET_OBJ_RNUM(obj) <= top_of_objt)
						if (OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj)) < 50000)
							OBJ_INDEX_LIMIT(GET_OBJ_RNUM(obj))++;
					extract_obj(obj);
				}
		}
		fclose(fl);         
d137 3
a139 1

d149 1
a149 1

d152 1
a152 1
	*locate = (int) object.locate;
d163 12
a174 12
    {  
       CREATE(obj->ex_description, struct extra_descr_data, 1);
       memset(obj->ex_description, 0x0, sizeof(struct extra_descr_data));
       obj->ex_description->keyword = (char *) malloc(strlen("PSE")+1);
       if(obj->ex_description->keyword)
         strcpy(obj->ex_description->keyword, "PSE");
       
       obj->ex_description->description = (char *) malloc(128);
       if(obj->ex_description->description)
         strncpy(obj->ex_description->description, object.PSE_Desc + 1, 128); 
    }

d177 1
a177 1

d184 10
a193 10
 /* this function used in house.c */
 struct obj_data *Obj_from_store(struct obj_file_elem object)
 {
   int locate;
 
   return Obj_from_store_to(object, &locate);
 }
 
 
 
d195 1
a195 1
/*int Obj_to_store(struct obj_data * obj, FILE * fl)*/
d200 1
a200 1

d213 2
a214 2


d217 1
a217 1

d220 7
a226 6
  {
    if((tmpdesc->keyword) && (strcmp(tmpdesc->keyword, "PSE") == 0))
    { 
      strcpy(object.PSE_Desc, "1");
      strcat(object.PSE_Desc, tmpdesc->description);
      break;
d228 1
a228 2
  }

d236 7
a242 7
 int Obj_to_store(struct obj_data * obj, FILE * fl)
 {
   return Obj_to_store_from(obj, fl, 0);
 }
 
 
 
d248 1
a248 1

d259 1
a259 1

d275 1
a275 1

d288 1
a288 1

d291 1
a291 1

d302 1
a302 1

d319 1
a319 1

d358 1
a358 1

d373 1
a373 1

d432 11
a442 11
 void auto_equip(struct char_data *ch, struct obj_data *obj, int locate)
 {
   int j;
 
   if (locate > 0) { /* was worn */
     switch (j = locate-1) {
     case WEAR_LIGHT:
       break;
     case WEAR_FINGER_R:
     case WEAR_FINGER_L:
       if (!CAN_WEAR(obj,ITEM_WEAR_FINGER)) /* not fitting :( */
d444 4
a447 4
       break;
     case WEAR_NECK_1:
     case WEAR_NECK_2:
       if (!CAN_WEAR(obj,ITEM_WEAR_NECK))
d449 3
a451 3
       break;
     case WEAR_BODY:
       if (!CAN_WEAR(obj,ITEM_WEAR_BODY))
d453 3
a455 3
       break;
     case WEAR_HEAD:
       if (!CAN_WEAR(obj,ITEM_WEAR_HEAD))
d457 3
a459 3
       break;
     case WEAR_LEGS:
       if (!CAN_WEAR(obj,ITEM_WEAR_LEGS))
d461 3
a463 3
       break;
     case WEAR_FEET:
       if (!CAN_WEAR(obj,ITEM_WEAR_FEET))
d465 3
a467 3
       break;
     case WEAR_HANDS:
       if (!CAN_WEAR(obj,ITEM_WEAR_HANDS))
d469 3
a471 3
       break;
     case WEAR_ARMS:
       if (!CAN_WEAR(obj,ITEM_WEAR_ARMS))
d473 3
a475 3
       break;
     case WEAR_SHIELD:
       if (!CAN_WEAR(obj,ITEM_WEAR_SHIELD))
d477 3
a479 3
       break;
     case WEAR_ABOUT:
       if (!CAN_WEAR(obj,ITEM_WEAR_ABOUT))
d481 2
a482 2
       break;
     case WEAR_LEAR:
d484 1
a484 1
	locate =0;
d486 2
a487 2
     case WEAR_REAR:
        if (!CAN_WEAR(obj,ITEM_WEAR_EAR))
d489 3
a491 3
        break;
     case WEAR_OBELT:
	if (!CAN_WEAR(obj,ITEM_WEAR_OBELT))
d493 3
a495 3
        break;
     case WEAR_FACE:
	if (!CAN_WEAR(obj,ITEM_WEAR_FACE))
d497 3
a499 3
        break;
     case WEAR_EYES:
        if (!CAN_WEAR(obj,ITEM_WEAR_EYES))
d501 3
a503 3
        break;
     case WEAR_BADGE:
        if (!CAN_WEAR(obj,ITEM_WEAR_BADGE))
d505 3
a507 3
        break;  
     case WEAR_WAIST:
       if (!CAN_WEAR(obj,ITEM_WEAR_WAIST))
d509 4
a512 4
       break;
     case WEAR_WRIST_R:
     case WEAR_WRIST_L:
       if (!CAN_WEAR(obj,ITEM_WEAR_WRIST))
d514 3
a516 3
       break;
     case WEAR_WIELD:
       if (!CAN_WEAR(obj,ITEM_WEAR_WIELD))
d518 3
a520 3
       break;
     case WEAR_HOLD:
       if (!CAN_WEAR(obj,ITEM_WEAR_HOLD) &&
d524 7
a530 7
       break;
     default:
       locate = 0;
     }
     if (locate > 0)
       if (!GET_EQ(ch,j)) {
 /* check ch's alignment to prevent $M from being zapped through auto-equip */
d537 2
a538 2
       }
       else  /* oops - saved player with double equipment[j]? */
d540 10
a549 10
   }
   if (locate <= 0)
     obj_to_char(obj, ch);
 }
 
 
 
 #define MAX_BAG_ROW 5
 
 
d551 1
a551 1
/* return values:
d555 1
a555 1
*/
d558 1
a558 1

d569 1
a569 1

d586 1
a586 1

d593 1
a593 1
	      GET_NAME(ch));
d597 1
a597 1
    } */
d599 3
a601 3
      GET_GOLD(ch) = MAX(GET_GOLD(ch) - cost, 0);
      save_char(ch, NOWHERE);
      */
d626 1
a626 1

d628 3
a630 3
     cont_row[j] = NULL; /* empty all cont lists (you never know ...) */
 

d641 25
a665 25
 
 /*
 what to do with a new loaded item:
 
   if there's a list with <locate> less than 1 below this:
     (equipped items are assumed to have <locate>==0 here) then its
     container has disappeared from the file   *gasp*
      -> put all the list back to ch's inventory
 
   if there's a list of contents with <locate> 1 below this:
     check if it's a container
     - if so: get it from ch, fill it, and give it back to ch (this way the
         container has its correct weight before modifying ch)
     - if not: the container is missing -> put all the list to ch's inventory
 
   for items with negative <locate>:
     if there's already a list of contents with the same <locate> put obj to it
     if not, start a new list
 
 Confused? Well maybe you can think of some better text to be put here ...
 
 since <locate> for contents is < 0 the list indices are switched to
 non-negative
 */
 
d702 1
a702 1
 
d721 1
a721 1
 
d723 3
a725 3
 		/* let obj be part of content list
 		   but put it at the list's end thus having the items
 		   in the same order as before renting */
d735 1
a735 1
       }
d737 1
a737 1

d743 1
a743 1

d745 1
a745 1

d759 1
a759 1

d764 1
a764 1

d767 1
a767 1

d803 1
a803 1

d807 1
a807 1

d822 9
a830 9
 /* get norent items from eq to inventory and
    extract norents out of worn containers */
 void Crash_extract_norents_from_equipped(struct char_data * ch)
 {
   int j;
 
   for (j = 0;j < NUM_WEARS;j++) {
     if (GET_EQ(ch,j)) {
       if (IS_OBJ_STAT(GET_EQ(ch,j), ITEM_NORENT) ||
d835 1
a835 1
       else
d837 5
a841 5
     }
   }
 }
 
 
d847 1
a847 1

d873 1
a873 1

d876 1
a876 1

d881 1
a881 1

d891 1
a891 1
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
d898 5
a902 5
     fclose(fp);
     return;
   }
   Crash_restore_weight(ch->carrying);
 
d915 1
a915 1

d918 1
a918 1

d923 1
a923 1

d926 1
a926 1
      obj_to_char(unequip_char(ch, j), ch);*/
d930 1
a930 1

d932 1
a932 1

d936 10
a945 10
   cost_eq = 0;
   for (j = 0; j < NUM_WEARS; j++)
     Crash_calculate_rent(GET_EQ(ch,j), &cost_eq);
 
   cost <<= 1;
      cost_eq <<= 1;
 
   if (cost+cost_eq > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
     for (j = 0; j < NUM_WEARS; j++) /* unequip player with low money */
       if (GET_EQ(ch,j))
d947 16
a962 16
     cost += cost_eq;
     cost_eq = 0;
 
     while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
       Crash_extract_expensive(ch->carrying);
       cost = 0;
       Crash_calculate_rent(ch->carrying, &cost);
       cost <<= 1;
     }
  /* forcerent cost is 2x normal rent */
  /*while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
    Crash_extract_expensive(ch->carrying);
    cost = 0;
    Crash_calculate_rent(ch->carrying, &cost);
    cost <<= 1;*/

d964 1
a964 1

d966 6
a971 6
   for (j = 0; j < NUM_WEARS && !(GET_EQ(ch,j)); j++);
     if (j == NUM_WEARS) { /* no eq nor inv */
       fclose(fp);
       Crash_delete_file(GET_NAME(ch));
       return;
     }
d974 2
a975 2

 rent.rentcode = RENT_TIMEDOUT;
d993 4
a996 4
   
   for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
d999 5
a1003 5
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
d1008 1
a1008 1

d1019 1
a1019 1

d1022 1
a1022 1

d1027 4
a1030 4

 /* for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
      obj_to_char(unequip_char(ch, j), ch);*/
d1032 1
a1032 1

d1034 2
a1035 2

rent.rentcode = RENT_RENTED;
d1051 3
a1053 3
     for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
d1056 5
a1060 5
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
d1065 1
a1065 1

d1076 1
a1076 1

d1079 1
a1079 1

d1084 5
a1088 5

 /* for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j))
      obj_to_char(unequip_char(ch, j), ch);*/

d1090 1
a1090 1

d1092 1
a1092 1

d1094 2
a1095 2

rent.rentcode = RENT_CRYO;
d1106 1
a1106 1

d1112 3
a1114 3
     for (j = 0; j < NUM_WEARS; j++)
     if (GET_EQ(ch,j)) {
       if (!Crash_save(GET_EQ(ch,j), fp, j+1)) {
d1117 5
a1121 5
       }
       Crash_restore_weight(GET_EQ(ch,j));
       Crash_extract_objs(GET_EQ(ch,j));
     }
   if (!Crash_save(ch->carrying, fp, 0)) {
d1126 1
a1126 1

d1133 2
a1134 2
* Routines used for the receptionist					  *
************************************************************************* */
d1137 1
a1137 1
			      long cost)
d1140 1
a1140 1

d1143 1
a1143 1

d1146 1
a1146 1
      "$n tells you, 'You can rent for %ld day%s with the gold you have\r\n"
d1153 1
a1153 1
			         struct obj_data * obj)
d1157 1
a1157 1

d1173 1
a1173 1
		            struct obj_data * obj, long *cost, long *nitems, int display, int factor)
d1176 1
a1176 1

d1195 1
a1195 1
		         int display, int factor)
d1201 1
a1201 1

d1205 2
a1206 2
	norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch,i));

d1209 1
a1209 1

d1211 1
a1211 1

d1213 1
a1213 1

d1215 3
a1217 3
	  Crash_report_rent(ch, receptionist, GET_EQ(ch,i), &totalcost, &numitems, display, factor);
    /*Crash_report_rent(ch, receptionist, GET_EQ(ch, i), &totalcost, &numitems, display, factor);*/

d1220 1
a1220 1
	FALSE, receptionist, 0, ch, TO_VICT);
d1222 1
a1222 1
  }	*/
d1249 1
a1249 1
		         int cmd, char *arg, int mode)
d1254 2
a1255 2
  "cough", "fart", "twiddle", "yawn"};

d1257 1
a1257 1

d1260 1
a1260 1

d1277 1
a1277 1
  }	*/
d1288 1
a1288 1
	  FALSE, recep, 0, ch, TO_VICT);
d1290 2
a1291 2
    }
    if (cost && (mode == RENT_FACTOR))
d1293 1
a1293 1
	*/
d1298 1
a1298 1
    GET_LOADROOM(ch) = world[ch->in_room].number;
d1311 1
a1311 1

d1316 1
a1316 1
    GET_LOADROOM(ch) = world[ch->in_room].number;
d1353 1
@
