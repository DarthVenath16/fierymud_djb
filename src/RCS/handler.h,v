head	1.31;
access;
symbols;
locks; strict;
comment	@ * @;


1.31
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.07.22.28.59;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.20.07.30.49;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.31.01.19.54;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.30.20.25.38;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.30.20.21.07;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.17.06.52.40;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.26.18.24.48;	author jps;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.12.00.43.00;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.11.07.10.46;	author jps;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.11.05.41.03;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.05.05.35.58;	author jps;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.03.23.49.40;	author jps;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.26.21.10.17;	author jps;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.02.01.08.27;	author myc;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.14.04.17.35;	author jps;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.11.14.15.28;	author jps;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.20.03.16.43;	author rsd;	state Exp;
branches;
next	1.2;

1.2
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: handler.h                                     Part of CircleMUD *
*  Usage: header file: prototypes of handling and utility functions       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/* handling the affected-structures */
void	affect_total(struct char_data *ch);
void    do_campout(struct char_data * ch);
void	affect_modify(struct char_data *ch, byte loc, sh_int mod, long bitv, bool add, int aff_vector);
void	affect_to_char(struct char_data *ch, struct affected_type *af);
void	affect_remove(struct char_data *ch, struct affected_type *af);
void	affect_from_char(struct char_data *ch, int type);
bool	affected_by_spell(struct char_data *ch, int type);
void	affect_join(struct char_data *ch, struct affected_type *af,
bool add_dur, bool avg_dur, bool add_mod, bool avg_mod, bool refresh);


/* utility */
char *money_desc(int amount);
struct obj_data *create_money(int pamount, int gamount, int samount, int camount);
 int	isname(char *str, char *namelist);
char	*fname(char *namelist);
int	get_number(char **name);

/* ******** objects *********** */

void	obj_to_char(struct obj_data *object, struct char_data *ch);
void	obj_from_char(struct obj_data *object);

void	equip_char(struct char_data *ch, struct obj_data *obj, int pos);
struct obj_data *unequip_char(struct char_data *ch, int pos);

struct obj_data *get_obj_in_list(char *name, struct obj_data *list);
struct obj_data *get_obj_in_list_num(int num, struct obj_data *list);
struct obj_data *get_obj(char *name);
struct obj_data *get_obj_num(int nr);

void	obj_to_room(struct obj_data *object, int room);
void	obj_from_room(struct obj_data *object);
void	obj_to_obj(struct obj_data *obj, struct obj_data *obj_to);
void	obj_from_obj(struct obj_data *obj);
void	object_list_new_owner(struct obj_data *list, struct char_data *ch);

void	extract_obj(struct obj_data *obj);

/* ******* characters ********* */

struct char_data *get_char_room(char *name, int room);
struct char_data *get_char_num(int nr);
struct char_data *get_char(char *name);

void	char_from_room(struct char_data *ch);
void	char_to_room(struct char_data *ch, int room);
void	extract_char(struct char_data *ch);
/* Buru 13/12/97 - coin converters */
void	money_convert(struct char_data * ch, int amount);
void	copper_to_coins(struct char_data * ch);
void	convert_coins_copper(struct char_data * ch);

/* find if character can see */
struct char_data *get_char_room_vis(struct char_data *ch, char *name);
struct char_data *get_player_vis(struct char_data *ch, char *name, int inroom);
struct char_data *get_char_vis(struct char_data *ch, char *name);
struct obj_data *get_obj_in_list_vis(struct char_data *ch, char *name,
struct obj_data *list);
struct obj_data *get_obj_vis(struct char_data *ch, char *name);
struct obj_data *get_object_in_equip_vis(struct char_data *ch,
char *arg, struct obj_data *equipment[], int *j);


/* find all dots */

int	find_all_dots(char *arg);

#define FIND_INDIV	0
#define FIND_ALL	1
#define FIND_ALLDOT	2


/* Generic Find */

int	generic_find(char *arg, int bitvector, struct char_data *ch,
struct char_data **tar_ch, struct obj_data **tar_obj);

#define FIND_CHAR_ROOM     1
#define FIND_CHAR_WORLD    2
#define FIND_OBJ_INV       4
#define FIND_OBJ_ROOM      8
#define FIND_OBJ_WORLD    16
#define FIND_OBJ_EQUIP    32


/* prototypes from crash save system */

int	Crash_get_filename(char *orig_name, char *filename);
int	Crash_delete_file(char *name);
int	Crash_delete_crashfile(struct char_data *ch);
int	Crash_clean_file(char *name);
void	Crash_listrent(struct char_data *ch, char *name);
int	Crash_load(struct char_data *ch);
void	Crash_crashsave(struct char_data *ch);
void	Crash_idlesave(struct char_data *ch);
void	Crash_save_all(void);

/* prototypes from fight.c */
void	set_fighting(struct char_data *ch, struct char_data *victim);
void	stop_fighting(struct char_data *ch);
void	stop_follower(struct char_data *ch);
void	hit(struct char_data *ch, struct char_data *victim, int type);
void	forget(struct char_data *ch, struct char_data *victim);
void	remember(struct char_data *ch, struct char_data *victim);
void	damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype);
int	skill_message(int dam, struct char_data *ch, struct char_data *vict,
		      int attacktype);


/* prototypes from regen.c */
void    alter_hit(struct char_data *ch, int amount, int type);
void    alter_mana(struct char_data *ch, int amount);
void    alter_move(struct char_data *ch, int amount);
void    check_regen_rates(struct char_data *ch);
@


1.31
log
@Moved money functions from here to money.c.
@
text
@/***************************************************************************
 * $Id: handler.h,v 1.30 2009/03/07 22:28:59 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: handler.h                                      Part of FieryMUD *
 *  Usage: header file: prototypes of handling and utility functions       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#ifndef __FIERY_HANDLER_H
#define __FIERY_HANDLER_H

/* Prototypes for finding objs/chars */
#include "find.h"

/* handling the affected-structures */
void effect_total(struct char_data *ch);
void do_campout(struct char_data * ch);
void effect_modify(struct char_data *ch, byte loc, sh_int mod, flagvector bitv[], bool add);
void effect_to_char(struct char_data *ch, struct effect *eff);
void effect_remove(struct char_data *ch, struct effect *eff);
void active_effect_remove(struct char_data *ch, struct effect *effect);
void effect_from_char(struct char_data *ch, int type);
void active_effect_from_char(struct char_data *ch, int type);
bool affected_by_spell(struct char_data *ch, int type);
void effect_join(struct char_data *ch, struct effect *eff,
bool add_dur, bool avg_dur, bool add_mod, bool avg_mod, bool refresh);


/* utility */
 int	isname(const char *str, const char *namelist);
char	*fname(const char *namelist);

/* ******** objects *********** */

void	obj_to_char(struct obj_data *object, struct char_data *ch);
void	obj_from_char(struct obj_data *object);

enum equip_result {
   EQUIP_RESULT_ERROR,   /* Internal error; object has not been manipulated */
   EQUIP_RESULT_REFUSE,  /* Not equipped for gameplay reason; object is returned to inventory */
   EQUIP_RESULT_SUCCESS  /* Object was equipped */
};
void count_hand_eq(struct char_data *ch, int *hands_used, int *weapon_hands_used);
bool may_wear_eq(struct char_data * ch, struct obj_data * obj,
   int *where, bool sendmessage);
enum equip_result equip_char(struct char_data *ch, struct obj_data *obj, int pos);
struct obj_data *unequip_char(struct char_data *ch, int pos);

void	obj_to_room(struct obj_data *object, int room);
void	obj_from_room(struct obj_data *object);
void	obj_to_obj(struct obj_data *obj, struct obj_data *obj_to);
void	obj_from_obj(struct obj_data *obj);
void	object_list_new_owner(struct obj_data *list, struct char_data *ch);

void	extract_obj(struct obj_data *obj);

/* ******* characters ********* */

void init_char(struct char_data *ch);
void update_char(struct char_data *ch);

void	char_from_room(struct char_data *ch);
void	char_to_room(struct char_data *ch, int room);
void	extract_char(struct char_data *ch);
/* Buru 13/12/97 - coin converters */
void	money_convert(struct char_data * ch, int amount);
void	copper_to_coins(struct char_data * ch);
void	convert_coins_copper(struct char_data * ch);

/* mobact.c */
void forget(struct char_data *ch, struct char_data *victim);
void remember(struct char_data *ch, struct char_data *victim);

#endif

/***************************************************************************
 * $Log: handler.h,v $
 * Revision 1.30  2009/03/07 22:28:59  jps
 * Add function active_effect_from_char, which is called to remove effects
 * in-game and provide feedback.
 *
 * Revision 1.29  2009/03/03 19:43:44  myc
 * Split off target-finding protocol from handler into find.c.
 *
 * Revision 1.28  2008/09/20 07:30:49  jps
 * Removed unused Crash_* protos. Moved fight.c's protos to fight.h.
 *
 * Revision 1.27  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.26  2008/08/31 01:19:54  jps
 * You screwed up holding items in slots with two of the same position!
 * Fix.
 *
 * Revision 1.25  2008/08/30 20:25:38  jps
 * Moved count_hand_eq() into handler.c and mentioned it in handler.h.
 *
 * Revision 1.24  2008/08/30 20:21:07  jps
 * Moved equipment-wearability checks into function may_wear_eq() and moved
 * it to handler.c.
 *
 * Revision 1.23  2008/08/17 06:52:40  jps
 * equip_char will return one of several result codes.
 *
 * Revision 1.22  2008/05/26 18:24:48  jps
 * Removed code that deletes player object files.
 *
 * Revision 1.21  2008/05/12 00:43:00  jps
 * Pass "death" to skill_message since it wouldn't otherwise know
 * whether the victim died due to the attack.
 *
 * Revision 1.20  2008/05/11 07:10:46  jps
 * Moved active_effect_remove from spells.c to handler.c.
 *
 * Revision 1.19  2008/05/11 05:41:03  jps
 * Moved relevant prototypes to regen.h.
 *
 * Revision 1.18  2008/04/02 03:24:44  myc
 * Declaring die as a public function.
 *
 * Revision 1.17  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.16  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.15  2008/01/25 21:05:45  myc
 * Added attack() as a macro alias for hit() with fewer arguments.
 *
 * Revision 1.14  2008/01/12 23:13:20  myc
 * Added multi-purpose get_random_char_around function to pick random chars
 * in a room.
 *
 * Revision 1.13  2008/01/10 05:39:43  myc
 * damage() now returns the amount of damage it caused.  Negative values
 * indicate healing, and a return value of VICTIM_DEAD indicates that the
 * victim is dead.
 *
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.12  2008/01/05 05:35:58  jps
 * Exporting functions init_char() and update_char().
 *
 * Revision 1.11  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Fixed a lot of affect-handling
 * code to work more smoothly (and sanely).
 *
 * Revision 1.10  2007/09/03 23:49:40  jps
 * Add mass_attack_ok() so that you could kill your own pet specifically,
 * but your area spells will not harm it.
 *
 * Revision 1.9  2007/08/26 21:10:17  jps
 * Change return type of skill_message() to bool.
 *
 * Revision 1.8  2007/08/03 03:51:44  myc
 * check_pk is now attack_ok, and covers many more cases than before,
 * including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
 * offensive attacks now use attack_ok to determine whether an attack is
 * allowed.
 *
 * Revision 1.7  2007/08/02 01:08:27  myc
 * check_pk() now works for all PK cases.  Moved from magic.c to fight.c
 *
 * Revision 1.6  2007/07/14 04:17:35  jps
 * Updated call to stop_follower(), which cares whether this is being
 * done due to a violent action or not.
 *
 * Revision 1.5  2007/04/11 14:15:28  jps
 * Give money piles proper keywords and make them dissolve when stolen.
 *
 * Revision 1.4  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.3  2000/11/20 03:16:43  rsd
 * Altered comment header and added back rlog messgaes from
 * prior to the addition of the $log$ string
 *
 * Revision 1.2  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial Revision
 *
 ***************************************************************************/
@


1.30
log
@Add function active_effect_from_char, which is called to remove effects
in-game and provide feedback.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.29 2009/03/03 19:43:44 myc Exp jps $
a36 2
void money_desc(int amount, char **shortdesc, char **keywords);
struct obj_data *create_money(int pamount, int gamount, int samount, int camount);
d85 4
@


1.29
log
@Split off target-finding protocol from handler into find.c.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.28 2008/09/20 07:30:49 jps Exp myc $
d23 5
a27 5
void	effect_total(struct char_data *ch);
void    do_campout(struct char_data * ch);
void	effect_modify(struct char_data *ch, byte loc, sh_int mod, flagvector bitv[], bool add);
void	effect_to_char(struct char_data *ch, struct effect *eff);
void	effect_remove(struct char_data *ch, struct effect *eff);
d29 4
a32 3
void	effect_from_char(struct char_data *ch, int type);
bool	affected_by_spell(struct char_data *ch, int type);
void	effect_join(struct char_data *ch, struct effect *eff,
d87 3
@


1.28
log
@Removed unused Crash_* protos. Moved fight.c's protos to fight.h.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.27 2008/09/01 23:47:49 jps Exp jps $
d19 3
a39 1
int	get_number(char **name);
a56 5
struct obj_data *get_obj_in_list(char *name, struct obj_data *list);
struct obj_data *get_obj_in_list_num(int num, struct obj_data *list);
struct obj_data *get_obj(char *name);
struct obj_data *get_obj_num(int nr);

a69 4
struct char_data *get_char_room(char *name, int room);
struct char_data *get_char_num(int nr);
struct char_data *get_char(char *name);

a77 45
/* find if character can see */
struct char_data *get_char_room_vis(struct char_data *ch, char *name);
struct char_data *get_player_vis(struct char_data *ch, char *name, int inroom);
struct char_data *get_char_vis(struct char_data *ch, char *name);
struct obj_data *get_obj_in_list_vis(struct char_data *ch, char *name, 
struct obj_data *list);
struct obj_data *get_obj_vis(struct char_data *ch, char *name);
struct obj_data *get_object_in_equip_vis(struct char_data *ch,
char *arg, struct obj_data *equipment[], int *j);


/* find all dots */

int	find_all_dots(char *arg);

#define FIND_INDIV	0
#define FIND_ALL	1
#define FIND_ALLDOT	2


/* Generic Find */

int	generic_find(char *arg, int bitvector, struct char_data *ch,
struct char_data **tar_ch, struct obj_data **tar_obj);

#define FIND_CHAR_ROOM     1
#define FIND_CHAR_WORLD    2
#define FIND_OBJ_INV       4
#define FIND_OBJ_ROOM      8
#define FIND_OBJ_WORLD    16
#define FIND_OBJ_EQUIP    32

/* Pick random char in same room as ch */
struct char_data *get_random_char_around(struct char_data *ch, int mode);
#define RAND_PLAYERS       (1 << 0)
#define RAND_HASSLE        (1 << 1)
#define RAND_VISIBLE       (1 << 2)
#define RAND_NOT_SELF      (1 << 3)
#define RAND_WIZ_VIS       (1 << 4)

#define RAND_AGGRO         (RAND_HASSLE | RAND_VISIBLE | RAND_NOT_SELF)
#define RAND_DG_MOB        (RAND_AGGRO)
#define RAND_DG_OBJ        (RAND_HASSLE | RAND_WIZ_VIS)
#define RAND_DG_WLD        (RAND_HASSLE | RAND_WIZ_VIS)

d86 3
@


1.27
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.26 2008/08/31 01:19:54 jps Exp jps $
d130 1
a130 19

/* prototypes from crash save system */

int Crash_get_filename(char *orig_name, char *filename);
int Crash_delete_file(char *name);
int Crash_delete_crashfile(struct char_data *ch);
void Crash_listrent(struct char_data *ch, char *name);
int Crash_load(struct char_data *ch);
void Crash_crashsave(struct char_data *ch);
void Crash_idlesave(struct char_data *ch);
void Crash_save_all(void);

/* prototypes from fight.c */
bool attack_ok(struct char_data *ch, struct char_data *victim, bool verbose);
bool mass_attack_ok(struct char_data *ch, struct char_data *victim, bool verbose);
void set_fighting(struct char_data *ch, struct char_data *victim);
void stop_fighting(struct char_data *ch);
void hit(struct char_data *ch, struct char_data *victim, int type);
#define attack(ch, victim)      hit(ch, victim, TYPE_UNDEFINED)
a132 4
int damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype);
bool skill_message(int dam, struct char_data *ch, struct char_data *vict,
      int attacktype, bool death);
void die(struct char_data *ch, struct char_data *killer);
d138 3
@


1.26
log
@You screwed up holding items in slots with two of the same position!
Fix.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.25 2008/08/30 20:25:38 jps Exp jps $
a146 1
void stop_follower(struct char_data *ch, int violent);
d160 4
@


1.25
log
@Moved count_hand_eq() into handler.c and mentioned it in handler.h.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.24 2008/08/30 20:21:07 jps Exp jps $
d51 1
a51 1
   int where, bool sendmessage);
d161 3
@


1.24
log
@Moved equipment-wearability checks into function may_wear_eq() and moved
it to handler.c.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.23 2008/08/17 06:52:40 jps Exp jps $
d49 1
d161 4
@


1.23
log
@equip_char will return one of several result codes.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.22 2008/05/26 18:24:48 jps Exp jps $
d49 2
d160 3
@


1.22
log
@Removed code that deletes player object files.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.21 2008/05/12 00:43:00 jps Exp jps $
d44 6
a49 1
void	equip_char(struct char_data *ch, struct obj_data *obj, int pos);
d158 3
@


1.21
log
@Pass "death" to skill_message since it wouldn't otherwise know
whether the victim died due to the attack.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.20 2008/05/11 07:10:46 jps Exp jps $
a127 1
int Crash_clean_file(char *name);
d153 4
@


1.20
log
@Moved active_effect_remove from spells.c to handler.c.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.19 2008/05/11 05:41:03 jps Exp jps $
d147 1
a147 1
      int attacktype);
d154 3
@


1.19
log
@Moved relevant prototypes to regen.h.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.18 2008/04/02 03:24:44 myc Exp jps $
d25 1
d154 3
@


1.18
log
@Declaring die as a public function.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.17 2008/03/28 17:54:53 myc Exp myc $
a148 7

/* prototypes from regen.c */
void alter_hit(struct char_data *ch, int amount, bool cap_damage);
void alter_mana(struct char_data *ch, int amount);
void alter_move(struct char_data *ch, int amount);
void check_regen_rates(struct char_data *ch);

d153 3
@


1.17
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.16 2008/01/29 21:02:31 myc Exp myc $
d147 1
d160 4
@


1.16
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.15 2008/01/25 21:05:45 myc Exp myc $
d20 1
a20 1
void	affect_total(struct char_data *ch);
d22 4
a25 4
void	affect_modify(struct char_data *ch, byte loc, sh_int mod, long bitv1, long bitv2, long bitv3, bool add);
void	affect_to_char(struct char_data *ch, struct affected_type *af);
void	affect_remove(struct char_data *ch, struct affected_type *af);
void	affect_from_char(struct char_data *ch, int type);
d27 1
a27 1
void	affect_join(struct char_data *ch, struct affected_type *af,
d159 4
@


1.15
log
@Added attack() as a macro alias for hit() with fewer arguments.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.14 2008/01/12 23:13:20 myc Exp $
d34 2
a35 2
 int	isname(char *str, char *namelist);
char	*fname(char *namelist);
d159 3
@


1.14
log
@Added multi-purpose get_random_char_around function to pick random chars
in a room.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.13 2008/01/10 05:39:43 myc Exp myc $
d141 1
d159 4
@


1.13
log
@damage() now returns the amount of damage it caused.  Negative values
indicate healing, and a return value of VICTIM_DEAD indicates that the
victim is dead.

alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.12 2008/01/05 05:35:58 jps Exp myc $
d108 13
d158 8
@


1.12
log
@Exporting functions init_char() and update_char().
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.11 2007/09/20 21:20:43 myc Exp jps $
d130 1
a130 1
void damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype);
d136 1
a136 1
void alter_hit(struct char_data *ch, int amount, int type);
d145 3
@


1.11
log
@Hide points and perception are in.  Fixed a lot of affect-handling
code to work more smoothly (and sanely).
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.10 2007/09/03 23:49:40 jps Exp myc $
d16 3
d61 3
d141 2
d145 4
@


1.10
log
@Add mass_attack_ok() so that you could kill your own pet specifically,
but your area spells will not harm it.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.9 2007/08/26 21:10:17 jps Exp jps $
d19 1
a19 1
void	affect_modify(struct char_data *ch, byte loc, sh_int mod, long bitv, bool add, int aff_vector);
d137 4
@


1.9
log
@Change return type of skill_message() to bool.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.8 2007/08/03 03:51:44 myc Exp jps $
d117 1
d137 3
@


1.8
log
@check_pk is now attack_ok, and covers many more cases than before,
including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
offensive attacks now use attack_ok to determine whether an attack is
allowed.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.7 2007/08/02 01:08:27 myc Exp myc $
d105 9
a113 9
int	Crash_get_filename(char *orig_name, char *filename);
int	Crash_delete_file(char *name);
int	Crash_delete_crashfile(struct char_data *ch);
int	Crash_clean_file(char *name);
void	Crash_listrent(struct char_data *ch, char *name);
int	Crash_load(struct char_data *ch);
void	Crash_crashsave(struct char_data *ch);
void	Crash_idlesave(struct char_data *ch);
void	Crash_save_all(void);
d116 10
a125 10
bool	attack_ok(struct char_data *ch, struct char_data *victim, bool verbose);
void	set_fighting(struct char_data *ch, struct char_data *victim);
void	stop_fighting(struct char_data *ch);
void	stop_follower(struct char_data *ch, int violent);
void	hit(struct char_data *ch, struct char_data *victim, int type);
void	forget(struct char_data *ch, struct char_data *victim);
void	remember(struct char_data *ch, struct char_data *victim);
void	damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype);
int	skill_message(int dam, struct char_data *ch, struct char_data *vict,
		      int attacktype);
d129 4
a132 4
void    alter_hit(struct char_data *ch, int amount, int type);
void    alter_mana(struct char_data *ch, int amount);
void    alter_move(struct char_data *ch, int amount);
void    check_regen_rates(struct char_data *ch);
d136 6
@


1.7
log
@check_pk() now works for all PK cases.  Moved from magic.c to fight.c
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.6 2007/07/14 04:17:35 jps Exp $
d116 1
a116 1
bool	check_pk(struct char_data *ch, struct char_data *victim);
d136 3
@


1.6
log
@Updated call to stop_follower(), which cares whether this is being
done due to a violent action or not.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.5 2007/04/11 14:15:28 jps Exp jps $
d116 1
d136 4
@


1.5
log
@Give money piles proper keywords and make them dissolve when stolen.
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.4 2002/09/13 02:32:10 jjl Exp jps $
d118 1
a118 1
void	stop_follower(struct char_data *ch);
d135 3
@


1.4
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: handler.h,v 1.3 2000/11/20 03:16:43 rsd Exp $
d29 1
a29 1
char *money_desc(int amount);
d135 3
@


1.3
log
@Altered comment header and added back rlog messgaes from
prior to the addition of the $log$ string
@
text
@d1 3
a3 1
// $Id: handler.h,v 1.2 1999/09/05 07:00:39 jimmy Exp $
d133 13
a145 7
// $Log: handler.h,v $
// Revision 1.2  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial Revision
//
@


1.2
log
@Added RCS Log and Id strings to each source file
@
text
@d1 12
a12 10
// $Id$
/* ************************************************************************
*   File: handler.h                                     Part of CircleMUD *
*  Usage: header file: prototypes of handling and utility functions       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d130 8
a137 1
// $Log$
@


1.1
log
@Initial revision
@
text
@d1 1
d128 1
@
