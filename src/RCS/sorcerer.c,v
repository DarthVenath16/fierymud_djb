head	1.36;
access;
symbols;
locks; strict;
comment	@ * @;


1.36
date	2009.03.20.06.15.17;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.05.16.26.57;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.14.02.24.11;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.14.02.23.19;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.11.02.50.02;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.10.16.31.52;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.06.33.31;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.18.22.55.37;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.18.02.08.20;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.18.15.53.21;	author jps;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.14.05.11.40;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.26.23.12.42;	author jps;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.26.16.44.36;	author jps;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.13.03.19.53;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.12.19.12.05;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.12.19.08.14;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.08.07.55.17;	author jps;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.25.02.33.15;	author rsd;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.23.54.25;	author cso;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.15.15.42;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.32;	author mud;	state Exp;
branches;
next	;


desc
@/*File: sorcerer.c*
*This file was created by Proky to control Cleric type mobs *
*It is closly related to ai.h, and ai_util.c                *
*/


#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "spells.h"
#include "ai.h"

/*external memory structores*/
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct room_data *world;
extern struct str_app_type str_app[];
extern struct char_data *combat_list;
extern struct char_data *next_combat_list;
extern int cleric_subclasses[CLERIC_SUBCLASSES];

/* Locals */
void do_a_dragon_thing(struct char_data *ch);
void do_a_demon_thing(struct char_data *ch);

/*do commands*/
ACMD(do_bash);
ACMD(do_kick);
ACMD(do_breath);
ACMD(do_sweep);
ACMD(do_roar);

/*external functions*/



void sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
{
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0;
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER)
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10 && !MOB_FLAGGED(ch, MOB_PET))
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }

    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
    {
        if ((i=number_of_people_in_group(ch, victim)))
        {
            for (i=0;i< SORCERER_AREA_NO;i++)
            {
				if (counter > 1)/*only bother with top two*/
					break;
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
                {
                    counter++;
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;
                }
            }
        }
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
        {        /*ray of enf*/
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
                {
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
                }
            }
        }
    }
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
		if (counter > 3)
			break;
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
        {
            counter++;
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;
        }
    }
    return;
}

/*this is called if a mob is fighting and needs to spell up*/
bool check_sor_fight_status(struct char_data *ch)
{
    int spells_circle;
    int i, mob_circle = 0;
    i = 0;
    while (i < GET_LEVEL(ch))
    {/*calculates what circle mob can have*/
	    mob_circle++;
	    i = mob_circle*5 + 1;/*uses counter as a temp variable*/
    }
    for (i=0;i < NUMBER_SO_OFFENSE_CHECKS;i++)
    {
       if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
       {
            spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
            if (mob_circle >= spells_circle)
                if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2]))
                {
                    if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
                        if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2)))
                            continue;
                    if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
                        if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2)))
                            continue;

                    if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
                        return TRUE;
                }
       }

    }
    return FALSE;
}


void check_sor_status(struct char_data *ch)
{
int i;
int spells_circle;
int mob_circle = 0;
    if(!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch))
        return;
    if(ch->desc && ch->desc->original)
        return;
    if(MOB_FLAGGED(ch, MOB_CASTING))
        return;
    i = 0;
    if ((IS_AFFECTED(ch, AFF_CHARM)))
        return;
    /*if charmed exit so not anoying*/

    while (i < GET_LEVEL(ch))
    {/*calculates what circle mob can have*/
	    mob_circle ++;
	    i = mob_circle*5 + 1;/*uses counter as a temp variable*/
    }
    for (i=0;i < NUMBER_OF_SO_CHECKS;i++)
    {
       if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
       {
           if ((so_spells_to_check[i][0] == SPELL_INVISIBLE))
                        if (!MEMORY(ch))
                            continue;

            spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
            if (mob_circle >= spells_circle)
                if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2]))
                {

                    if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
                        if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2)))
                            continue;

                    if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
                        if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2)))
                            continue;
                    if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
                        return;
                }
       }
    }
}

void dragon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
{
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0;
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER)
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10)
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }

    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
    {
        if ((i=number_of_people_in_group(ch, victim)))
        {
            for (i=0;i< SORCERER_AREA_NO;i++)
            {
				if (counter > 1) {/*only bother with top two*/
                     if((number (1, 20)) > 11) {
                        do_a_dragon_thing(ch); // dragons -Banyal
			return;
			} else
		        break; }
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
                {
                    counter++;
                       if(number(1, 10) > 8) {
			do_a_dragon_thing(ch);
			return;}
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;
                }
            }
        }
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
        {        /*ray of enf*/
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
                {
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
                }

            }
        }
    }
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
		if (counter > 3){
 		if((number (1, 20)) > 11) {
                 do_a_dragon_thing(ch);
		 return;
		}else
			break; }
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
        {
            counter++;
             if(number(1, 10) > 8) {
                        do_a_dragon_thing(ch);
                        return;}
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;
        }
    }
if((number (1, 20)) > 11) {
                 do_a_dragon_thing(ch);
                 return;
                }else
    return;
}

void
do_a_dragon_thing(struct char_data *ch)
{
 int j;
 int cmd_breath, cmd_sweep, cmd_roar;

 j = number(1, 3);

  if (j == 1) {
   if (GET_MSKILL(ch, SKILL_BREATH)) {
        cmd_breath = find_command("breath");
        do_breath(ch, "", cmd_breath, 0);
         return;
       } return;
       } else if (j == 2) { // sweep
       if (GET_MSKILL(ch, SKILL_SWEEP)) {
        cmd_sweep = find_command("sweep");
        do_sweep(ch, "", cmd_sweep, 0);
        return;
        } return;
        } else if (j == 3) { // roar
       if (GET_MSKILL(ch, SKILL_ROAR)) {
        cmd_roar = find_command("roar");
        do_roar(ch, "", cmd_roar, 0);
        return;
         }return;
        }
}


void demon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
{
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0;
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER)
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10)
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }

    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
    {
        if ((i=number_of_people_in_group(ch, victim)))
        {
            for (i=0;i< SORCERER_AREA_NO;i++)
            {
				if (counter > 1) {/*only bother with top two*/
                     if((number (1, 20)) > 11) {
                        do_a_demon_thing(ch); // demon -Banyal
			return;
			} else
		        break; }
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
                {
                    counter++;
                    if(number(1, 10) > 8) {
                        do_a_demon_thing(ch);
                        return;}
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;
                }
            }
        }
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
        {        /*ray of enf*/
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
                {
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
                }

            }
        }
    }
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
		if (counter > 3){
 		if((number (1, 20)) > 11) {
                 do_a_demon_thing(ch);
		 return;
		}else
			break; }
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
        {
            counter++;
             if(number(1, 10) > 8) {
                        do_a_demon_thing(ch);
                        return;}
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;
        }
    }
if((number (1, 20)) > 11) {
                 do_a_demon_thing(ch);
                 return;
                }else
    return;
}

void
do_a_demon_thing(struct char_data *ch)
{
 int j;
 int cmd_breath, cmd_roar;

 j = number(1, 2);

  if (j == 1) {
   if (GET_MSKILL(ch, SKILL_BREATH)) {
        cmd_breath = find_command("breath");
        do_breath(ch, "", cmd_breath, 0);
         return;
       } return;
        } else { // roar
       if (GET_MSKILL(ch, SKILL_ROAR)) {
        cmd_roar = find_command("roar");
        do_roar(ch, "", cmd_roar, 0);
        return;
         }return;
        }
}
@


1.36
log
@Adding a TAR_GROUND cast requirement.  Added detonation,
phosphoric embers, positive field, and acid burst spells.
Removed combust and heatwave.  Made soul tap a manual spell.
@
text
@/***************************************************************************
 * $Id: sorcerer.c,v 1.35 2009/03/08 23:34:14 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: sorcerer.c                                     Part of FieryMUD *
 *  Usage: AI actions for sorcerer-type mobiles.                           *
 *     By: Laoris of FieryMUD                                              *
 *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on HubisMUD Copyright (C) 1997, 1998.                *
 *  HubisMUD is based on DikuMUD, Copyright (C) 1990, 1991.                *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "casting.h"
#include "ai.h"
#include "skills.h"
#include "races.h"
#include "math.h"
#include "spell_parser.h"
#include "magic.h"
#include "composition.h"
#include "lifeforce.h"

/* Local functions */
bool check_sorcerer_status(struct char_data *ch);

/* External functions */
int mob_cast(struct char_data *ch, struct char_data *tch, struct obj_data *tobj, int spellnum);
bool affected_by_armor_spells(struct char_data *ch);

/* Sorcerer spell lists */
const struct spell_pair mob_sorcerer_buffs[] = {
  {SPELL_STONE_SKIN, 0, EFF_STONE_SKIN},
  {SPELL_HASTE, 0, EFF_HASTE},
  {SPELL_COLDSHIELD, 0, EFF_COLDSHIELD},
  {SPELL_FIRESHIELD, 0, EFF_FIRESHIELD},
  {SPELL_WATERFORM, 0, 0},
  {SPELL_VAPORFORM, 0, 0},
  {SPELL_NEGATE_HEAT, 0, EFF_NEGATE_HEAT},
  {SPELL_NEGATE_COLD, 0, EFF_NEGATE_COLD},
  {SPELL_MAJOR_GLOBE, 0, EFF_MAJOR_GLOBE},
  {SPELL_MINOR_GLOBE, 0, EFF_MINOR_GLOBE},
  {SPELL_DETECT_INVIS, 0, EFF_DETECT_INVIS},
  {SPELL_INVISIBLE, 0, EFF_INVISIBLE},
  {SPELL_FLY, 0, EFF_FLY},
  {SPELL_MIRAGE, 0, 0},
  {SPELL_MISDIRECTION, 0, EFF_MISDIRECTION},
  {SPELL_ICE_ARMOR, 0, 0},
  {SPELL_BONE_ARMOR, 0, 0},
  {0, 0, 0}
};

/* In order of spells to attempt */
const int mob_sorcerer_offensives[] = {
  SPELL_DISINTEGRATE,
  SPELL_BIGBYS_CLENCHED_FIST,
  SPELL_ICEBALL,
  SPELL_MELT,
  SPELL_ACID_BURST,
  SPELL_POSITIVE_FIELD,
  SPELL_DEGENERATION,
  SPELL_SOUL_TAP,
  SPELL_CONE_OF_COLD,
  SPELL_ENERGY_DRAIN,
  SPELL_CONFUSION,
  SPELL_DISINTEGRATE,
  SPELL_NIGHTMARE,
  SPELL_MESMERIZE,
  SPELL_FEAR,
  SPELL_FIREBALL,
  SPELL_PHOSPHORIC_EMBERS,
  SPELL_FREEZE,
  SPELL_HYSTERIA,
  SPELL_LIGHTNING_BOLT,
  SPELL_SHOCKING_GRASP,
  SPELL_CHILL_TOUCH,
  SPELL_DETONATION,
  SPELL_FIRE_DARTS,
  SPELL_BURNING_HANDS,
  SPELL_ICE_DARTS,
  SPELL_MAGIC_MISSILE,
  SPELL_SMOKE,
  SPELL_SOUL_TAP,
  0
};

const int mob_sorcerer_area_spells[] = {
  SPELL_CHAIN_LIGHTNING,
  SPELL_COLOR_SPRAY,
  SPELL_CREMATE,
  SPELL_FIRESTORM,
  SPELL_FLOOD,
  SPELL_FREEZING_WIND,
  SPELL_ICE_SHARDS,
  SPELL_ICE_STORM,
  SPELL_METEORSWARM,
  SPELL_SEVERANCE,
  SPELL_SOUL_REAVER,
  SPELL_SUPERNOVA,
  0
};



bool sorcerer_ai_action(struct char_data * ch, struct char_data * victim)
{
  int my_health, victim_health, i, counter;

  if (!victim) {
    mudlog("No victim in sorcerer AI action.", NRM, LVL_GOD, FALSE);
    return FALSE;
  }

  my_health = (100 * GET_HIT(ch)) / GET_MAX_HIT(ch);
  victim_health = (100 * GET_HIT(victim)) / GET_MAX_HIT(victim);

  /* If mob has low health, maybe try to teleport. */
  if (my_health < 10 && !PLAYERALLY(ch) && !number(0, 3) &&
      mob_cast(ch, ch, NULL, SPELL_TELEPORT))
    return TRUE;

  /* Check buff spells */
  if (victim_health > 15 && check_sorcerer_status(ch))
    return TRUE;

  /* If the victim is grouped, try an area spell first. */
  if (group_size(victim) > 1) {
    counter = 0;
    for (i = 0; mob_sorcerer_area_spells[i]; i++) {
      if (!GET_SKILL(ch, mob_sorcerer_area_spells[i]))
        continue;
      if (mob_cast(ch, victim, NULL, mob_sorcerer_area_spells[i]))
        return TRUE;
      /* Only try the mob's best two spells. */
      if (++counter >= 2)
        break;
    }
  }

  /* Sorcerers get 13% chance to cast harness. */
  if (GET_SKILL(ch, SPELL_HARNESS) && !EFF_FLAGGED(ch, EFF_HARNESS) &&
      FIGHTING(ch) && victim_health > 75 && !number(0, 6) &&
      mob_cast(ch, ch, NULL, SPELL_HARNESS))
    return TRUE;

  /* Necromancers get 10% chance to cast poison. */
  if (GET_SKILL(ch, SPELL_POISON) && !EFF_FLAGGED(ch, EFF_POISON) &&
      victim_health > 75 && !number(0, 9) &&
      mob_cast(ch, victim, NULL, SPELL_POISON))
    return TRUE;

  /* Try and cast ray of enfeeblement! */
  if (GET_SKILL(ch, SPELL_RAY_OF_ENFEEB) &&
      !EFF_FLAGGED(victim, EFF_RAY_OF_ENFEEB) &&
      /* Better chance to attempt if victim in good condition. */
      !number(0, (victim_health > 80) ? 2 : 7) &&
      mob_cast(ch, victim, NULL, SPELL_RAY_OF_ENFEEB))
    return TRUE;

  counter = 0;
  /* Single-target offensive spell */
  for (i = 0; mob_sorcerer_offensives[i]; i++) {
    if (!GET_SKILL(ch, mob_sorcerer_offensives[i]))
      continue;

    switch (mob_sorcerer_offensives[i]) {
      case SPELL_DEGENERATION:
      case SPELL_SOUL_TAP:
      case SPELL_ENERGY_DRAIN:
        if (GET_LIFEFORCE(victim) == LIFE_UNDEAD || GET_LIFEFORCE(victim) == LIFE_MAGIC)
          continue;
        break;
      case SPELL_REBUKE_UNDEAD:
        if (GET_LIFEFORCE(victim) != LIFE_UNDEAD)
          continue;
        break;
    }

    if (mob_cast(ch, victim, NULL, mob_sorcerer_offensives[i]))
      return TRUE;

    /* Only attempt to cast this mob's best 3 spells. */
    if (++counter >= 3)
      break;
  }

  return FALSE;
}

/* This checks mob buffs. */
bool check_sorcerer_status(struct char_data *ch)
{
  int i;

  for (i = 0; mob_sorcerer_buffs[i].spell; i++) {
    if (!GET_SKILL(ch, mob_sorcerer_buffs[i].spell) ||
          !check_fluid_spell_ok(ch, ch, mob_sorcerer_buffs[i].spell, TRUE))
      continue;

    if (!valid_cast_stance(ch, i))
      continue;
    /* 20% chance to cancel if in combat. */
    if (FIGHTING(ch) && number(0, 9) < 2)
      return FALSE;
    switch (mob_sorcerer_buffs[i].spell) {
      case SPELL_COLDSHIELD:
      case SPELL_FIRESHIELD:
        /* Coldshield and fireshield don't mix. */
        if (EFF_FLAGGED(ch, EFF_COLDSHIELD) ||
            EFF_FLAGGED(ch, EFF_FIRESHIELD))
          continue;
        break;
      case SPELL_MINOR_GLOBE:
      case SPELL_MAJOR_GLOBE:
        /* Major globe and minor globe don't mix either. */
        if (EFF_FLAGGED(ch, EFF_MINOR_GLOBE) ||
            EFF_FLAGGED(ch, EFF_MAJOR_GLOBE))
          continue;
        break;
      case SPELL_MIRAGE:
      case SPELL_ICE_ARMOR:
      case SPELL_BONE_ARMOR:
        /* Armor spells don't mix. */
        if (affected_by_armor_spells(ch))
          continue;
        break;
      case SPELL_WATERFORM:
        if (GET_COMPOSITION(ch) != COMP_FLESH)
           continue;
        break;
      case SPELL_VAPORFORM:
        if (GET_COMPOSITION(ch) != COMP_FLESH)
           continue;
        break;
      default:
        /* For other spells, just check to see if they have it. */
        if (has_effect(ch, &mob_sorcerer_buffs[i]))
          continue;
    }
    if (mob_cast(ch, ch, NULL, mob_sorcerer_buffs[i].spell))
      return TRUE;
  }

  return FALSE;
}


bool mob_animate(struct char_data *ch) {
  struct obj_data *obj;

  if (ROOM_FLAGGED(ch->in_room, ROOM_NOMAGIC) || EFF_FLAGGED(ch, EFF_SILENCE))
    return FALSE;

  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
    /* There's no IS_NPC_CORPSE macro */
    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER &&
        GET_OBJ_VAL(obj, VAL_CONTAINER_CORPSE) == CORPSE_NPC &&
        GET_OBJ_MOB_FROM(obj) != NOBODY &&
        GET_LEVEL(mob_proto + GET_OBJ_MOB_FROM(obj)) + 10 < GET_LEVEL(ch))
      return mob_cast(ch, NULL, obj, SPELL_ANIMATE_DEAD);

  return FALSE;
}

/***************************************************************************
 * $Log: sorcerer.c,v $
 * Revision 1.35  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.34  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.33  2009/02/05 16:26:57  myc
 * Modify list of offensive sorcerer spells to include disintegrate
 * and others.
 *
 * Revision 1.32  2009/01/19 09:25:23  myc
 * Removed MOB_PET flag.
 *
 * Revision 1.31  2009/01/17 00:28:02  myc
 * Fix use of uninitialized variable.
 *
 * Revision 1.30  2008/09/14 02:24:11  jps
 * Using magic.h.
 *
 * Revision 1.29  2008/09/14 02:23:19  jps
 * Don't attempt to use buffs that can't be used when you're fluid.
 *
 * Revision 1.28  2008/09/11 02:50:02  jps
 * Changed skills so you have a minimum position, and fighting_ok fields.
 *
 * Revision 1.27  2008/08/10 16:31:52  jps
 * Added severance and soul reaver to sorcerer area attack spells.
 *
 * Revision 1.26  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.25  2008/05/19 06:33:31  jps
 * Add mesmerize to sorcerer attack spells.
 * Add misdirection to sorcerer buff spells.
 *
 * Revision 1.24  2008/05/18 22:55:37  jps
 * Added hysteria to the list of ai sorcerer spells.
 *
 * Revision 1.23  2008/05/18 02:08:20  jps
 * Adding nightmare to sorcerer AI spell list.
 *
 * Revision 1.22  2008/04/18 15:53:21  jps
 * Added some illusionist spells to sorcerer AI.
 *
 * Revision 1.21  2008/04/14 05:11:40  jps
 * Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
 * to fly - not that the characer is actually flying.
 *
 * Revision 1.20  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.19  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.18  2008/03/26 23:12:42  jps
 * Changed the handling of waterform and vaporform spells.
 *
 * Revision 1.17  2008/03/26 16:44:36  jps
 * Replaced all checks for undead race with checks for undead lifeforce.
 * Replaced the undead race with the plant race.
 *
 * Revision 1.16  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.15  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.14  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.13  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.12  2008/01/13 03:19:53  myc
 * Added all the new sorcerer spells to the AI casting list.  Removed
 * MSKILL references.
 *
 * Revision 1.11  2008/01/12 23:13:20  myc
 * Replaced try_cast with direct calls to mob_cast, which now
 * supports target objects.
 *
 * Revision 1.10  2008/01/12 19:12:05  myc
 * Oops, accidentally erased some of the log entries.
 *
 * Revision 1.9  2008/01/12 19:08:14  myc
 * Rerowte a lot of mob AI functionality.
 *
 * Revision 1.8  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.7  2006/11/08 07:55:17  jps
 * Change verbal instances of "breath" to "breathe"
 *
 * Revision 1.6  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.5  2000/11/25 02:33:15  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.4  1999/11/28 23:54:25  cso
 * took out the check that kept charmed mobs from casting spells. now they can
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/02/02 15:15:42  mud
 * dos2unix
 * indented file
 * added standard comment header.
 *
 * Revision 1.1  1999/01/29 01:23:32  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.35
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.34 2009/03/08 21:43:27 jps Exp jps $
a68 1
  SPELL_COMBUST,
d70 2
d73 1
a80 1
  SPELL_HEATWAVE,
d82 1
d88 1
d278 3
@


1.34
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.33 2009/02/05 16:26:57 myc Exp jps $
d25 1
a25 1
#include "spells.h"
d275 3
@


1.33
log
@Modify list of offensive sorcerer spells to include disintegrate
and others.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.32 2009/01/19 09:25:23 myc Exp myc $
a15 5
/*
 * This file was originally created by Proky of HubisMUD, but was
 * completely rewritten.
 */

d18 1
d32 2
d275 4
@


1.32
log
@Removed MOB_PET flag.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.31 2009/01/17 00:28:02 myc Exp myc $
d66 1
d68 1
d70 1
a70 2
  SPELL_BURNING_HANDS,
  SPELL_CHILL_TOUCH,
d72 2
d75 1
a76 1
  SPELL_DEGENERATION,
d78 2
a79 1
  SPELL_ENERGY_DRAIN,
d81 1
a81 1
  SPELL_FIRE_DARTS,
a83 1
  SPELL_HEATWAVE,
d85 5
a90 2
  SPELL_ICEBALL,
  SPELL_LIGHTNING_BOLT,
a91 4
  SPELL_MELT,
  SPELL_MESMERIZE,
  SPELL_NIGHTMARE,
  SPELL_SHOCKING_GRASP,
d277 3
@


1.31
log
@Fix use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.30 2008/09/14 02:24:11 jps Exp myc $
d126 1
a126 1
  if (my_health < 10 && !MOB_FLAGGED(ch, MOB_PET) && !number(0, 3) &&
d275 3
@


1.30
log
@Using magic.h.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.29 2008/09/14 02:23:19 jps Exp jps $
d168 1
d275 3
@


1.29
log
@Don't attempt to use buffs that can't be used when you're fluid.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.28 2008/09/11 02:50:02 jps Exp jps $
d35 1
d274 3
@


1.28
log
@Changed skills so you have a minimum position, and fighting_ok fields.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.27 2008/08/10 16:31:52 jps Exp jps $
d202 2
a203 1
    if (!GET_SKILL(ch, mob_sorcerer_buffs[i].spell))
d273 3
@


1.27
log
@Added severance and soul reaver to sorcerer area attack spells.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.26 2008/06/07 19:06:46 myc Exp jps $
d34 1
d205 1
a205 2
    /* If fighting, don't try cast spells that don't work in combat. */
    if (FIGHTING(ch) && skills[mob_sorcerer_buffs[i].spell].stance != STANCE_FIGHTING)
d272 3
@


1.26
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.25 2008/05/19 06:33:31 jps Exp myc $
a89 1

a93 5
  SPELL_SUPERNOVA,
  SPELL_ICE_SHARDS,
  SPELL_METEORSWARM,
  SPELL_FLOOD,
  SPELL_CREMATE,
a94 1
  SPELL_ICE_STORM,
d96 1
d98 1
d100 6
d127 1
a127 1
  
d131 1
a131 1
  
d157 1
a157 1
  
d272 3
@


1.25
log
@Add mesmerize to sorcerer attack spells.
Add misdirection to sorcerer buff spells.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.24 2008/05/18 22:55:37 jps Exp jps $
d261 1
a261 1
        GET_OBJ_VAL(obj, 3) == CORPSE_NPC &&
d271 4
@


1.24
log
@Added hysteria to the list of ai sorcerer spells.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.23 2008/05/18 02:08:20 jps Exp jps $
d58 1
d85 1
d271 3
@


1.23
log
@Adding nightmare to sorcerer AI spell list.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.22 2008/04/18 15:53:21 jps Exp jps $
d78 1
d269 3
@


1.22
log
@Added some illusionist spells to sorcerer AI.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.21 2008/04/14 05:11:40 jps Exp jps $
d83 1
d268 3
@


1.21
log
@Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
to fly - not that the characer is actually flying.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.20 2008/04/07 03:02:54 jps Exp jps $
d64 7
d72 3
a74 5
  SPELL_ICEBALL,
  SPELL_COMBUST,
  SPELL_MELT,
  SPELL_BIGBYS_CLENCHED_FIST,
  SPELL_FREEZE,
a76 3
  SPELL_ENERGY_DRAIN,
  SPELL_DEGENERATION,
  SPELL_SOUL_TAP,
d78 2
a79 1
  SPELL_CONE_OF_COLD,
d81 2
a83 1
  SPELL_CHILL_TOUCH,
d85 2
a86 4
  SPELL_FIRE_DARTS,
  SPELL_ICE_DARTS,
  SPELL_MAGIC_MISSILE,
  SPELL_BURNING_HANDS,
d267 4
@


1.20
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.19 2008/03/28 17:54:53 myc Exp jps $
d56 1
a56 1
  {SPELL_FLY, 0, EFF_FLYING},
d265 4
@


1.19
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.18 2008/03/26 23:12:42 jps Exp myc $
d198 1
a198 1
    if (FIGHTING(ch) && skills[mob_sorcerer_buffs[i].spell].min_position > POS_FIGHTING)
d265 4
@


1.18
log
@Changed the handling of waterform and vaporform spells.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.17 2008/03/26 16:44:36 jps Exp jps $
d44 17
a60 17
  {SPELL_STONE_SKIN, 0, AFF_STONE_SKIN, 1},
  {SPELL_HASTE, 0, AFF_HASTE, 1},
  {SPELL_COLDSHIELD, 0, AFF2_COLDSHIELD, 2},
  {SPELL_FIRESHIELD, 0, AFF2_FIRESHIELD, 2},
  {SPELL_WATERFORM, 0, 0, 2},
  {SPELL_VAPORFORM, 0, 0, 2},
  {SPELL_NEGATE_HEAT, 0, AFF2_NEGATE_HEAT, 2},
  {SPELL_NEGATE_COLD, 0, AFF2_NEGATE_COLD, 2},
  {SPELL_MAJOR_GLOBE, 0, AFF2_MAJOR_GLOBE, 2},
  {SPELL_MINOR_GLOBE, 0, AFF2_MINOR_GLOBE, 2},
  {SPELL_DETECT_INVIS, 0, AFF_DETECT_INVIS, 1},
  {SPELL_INVISIBLE, 0, AFF_INVISIBLE, 1},
  {SPELL_FLY, 0, AFF_FLYING, 1},
  {SPELL_MIRAGE, 0, 0, 0},
  {SPELL_ICE_ARMOR, 0, 0, 0},
  {SPELL_BONE_ARMOR, 0, 0, 0},
  {0, 0, 0, 0}
d140 1
a140 1
  if (GET_SKILL(ch, SPELL_HARNESS) && !AFF2_FLAGGED(ch, AFF2_HARNESS) &&
d146 1
a146 1
  if (GET_SKILL(ch, SPELL_POISON) && !AFF_FLAGGED(ch, AFF_POISON) &&
d153 1
a153 1
      !AFF3_FLAGGED(victim, AFF3_RAY_OF_ENFEEB) &&
d207 2
a208 2
        if (AFF2_FLAGGED(ch, AFF2_COLDSHIELD) ||
            AFF2_FLAGGED(ch, AFF2_FIRESHIELD))
d214 2
a215 2
        if (AFF2_FLAGGED(ch, AFF2_MINOR_GLOBE) ||
            AFF2_FLAGGED(ch, AFF2_MAJOR_GLOBE))
d235 1
a235 1
        if (has_affection(ch, &mob_sorcerer_buffs[i]))
d249 1
a249 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_NOMAGIC) || AFF2_FLAGGED(ch, AFF2_SILENCE))
d265 3
@


1.17
log
@Replaced all checks for undead race with checks for undead lifeforce.
Replaced the undead race with the plant race.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.16 2008/02/09 04:27:47 myc Exp jps $
d48 2
a49 1
  {SPELL_WATERFORM, 0, AFF2_WATERFORM, 2},
d226 6
a231 3
        if (AFF2_FLAGGED(ch, AFF2_WATERFORM) ||
            AFF3_FLAGGED(ch, AFF3_VAPORFORM))
          continue;
d265 4
@


1.16
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.15 2008/01/29 21:02:31 myc Exp myc $
d167 1
a167 1
        if (GET_RACE(victim) == RACE_UNDEAD)
d171 1
a171 1
        if (GET_RACE(victim) != RACE_UNDEAD)
d261 3
@


1.15
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.14 2008/01/27 13:43:50 jps Exp myc $
d33 1
d261 4
@


1.14
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.13 2008/01/26 14:26:31 jps Exp jps $
a33 3
/* External memory structores */
extern struct room_data *world;

a242 1
  extern struct char_data *mob_proto;
d260 3
@


1.13
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.12 2008/01/13 03:19:53 myc Exp jps $
d32 1
d169 1
a169 1
        if (GET_SPECIES(victim) == SPECIES_UNDEAD)
d173 1
a173 1
        if (GET_SPECIES(victim) != SPECIES_UNDEAD)
d264 3
@


1.12
log
@Added all the new sorcerer spells to the AI casting list.  Removed
MSKILL references.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.11 2008/01/12 23:13:20 myc Exp myc $
d31 1
a34 1
extern struct spell_info_type spell_info[];
d198 1
a198 1
    if (FIGHTING(ch) && spell_info[mob_sorcerer_buffs[i].spell].min_position > POS_FIGHTING)
d263 4
@


1.11
log
@Replaced try_cast with direct calls to mob_cast, which now
supports target objects.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.10 2008/01/12 19:12:05 myc Exp myc $
d41 1
d64 2
a65 1
/*  SPELL_DISINTEGRATE,*/
d67 1
d69 1
d73 3
d89 1
d92 1
d98 1
d117 1
a117 3
  if (my_health < 10 &&
      !MOB_FLAGGED(ch, MOB_PET) &&
      !number(0, 3) &&
d140 2
a141 5
  if (GET_MSKILL(ch, SPELL_HARNESS) &&
      !AFF2_FLAGGED(ch, AFF2_HARNESS) &&
      FIGHTING(ch) &&
      victim_health > 75 &&
      !number(0, 6) &&
d146 2
a147 4
  if (GET_MSKILL(ch, SPELL_POISON) &&
      !AFF_FLAGGED(ch, AFF_POISON) &&
      victim_health > 75 &&
      !number(0, 9) &&
d152 1
a152 1
  if (GET_MSKILL(ch, SPELL_RAY_OF_ENFEEB) &&
d161 1
a161 1
    if (!GET_MSKILL(ch, mob_sorcerer_offensives[i]))
d163 14
d179 1
d194 1
a194 1
    if (!GET_MSKILL(ch, mob_sorcerer_buffs[i].spell))
d196 1
d222 6
a227 4
        if (affected_by_spell(ch, mob_sorcerer_buffs[i].spell) ||
            affected_by_spell(ch, SPELL_ARMOR) ||
            affected_by_spell(ch, SPELL_BARKSKIN) ||
            affected_by_spell(ch, SPELL_DEMONSKIN))
d263 4
@


1.10
log
@Oops, accidentally erased some of the log entries.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.9 2008/01/12 19:08:14 myc Exp myc $
d40 1
a40 1

d110 1
a110 1
      try_cast(ch, ch, SPELL_TELEPORT))
d121 1
a121 1
      if (!GET_MSKILL(ch, mob_sorcerer_area_spells[i]))
d123 1
a123 1
      if (try_cast(ch, victim, mob_sorcerer_area_spells[i]))
d137 1
a137 1
      try_cast(ch, ch, SPELL_HARNESS))
d145 1
a145 1
      try_cast(ch, victim, SPELL_POISON))
d153 1
a153 1
      try_cast(ch, victim, SPELL_RAY_OF_ENFEEB))
d160 1
a160 1
    if (try_cast(ch, victim, mob_sorcerer_offensives[i]))
d214 1
a214 1
    if (try_cast(ch, ch, mob_sorcerer_buffs[i].spell))
d222 18
d242 3
@


1.9
log
@Rerowte a lot of mob AI functionality.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.8 2008/01/03 12:44:03 jps Exp myc $
d224 7
@


1.8
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.7 2006/11/08 07:55:17 jps Exp jps $
d6 3
a8 4
 *  Usage: Control of sorcererous type mobiles, it is closly related       *
 *         to ai.h, and ai_util.c.                                         *
 *     By: Proky of HubisMUD                                               *
 *                                                                         *
d16 3
a18 2
/* Original comments indicated that the file was created by Proky to control
 * Cleric type mobs.
d32 1
a32 4
/*external memory structores*/
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
d34 1
a34 14
extern struct str_app_type str_app[];
extern struct char_data *combat_list;
extern struct char_data *next_combat_list;

/* Locals */
void do_a_dragon_thing(struct char_data *ch);
void do_a_demon_thing(struct char_data *ch);

/*do commands*/
ACMD(do_bash);
ACMD(do_kick);
ACMD(do_breathe);
ACMD(do_sweep);
ACMD(do_roar);
d36 2
a37 1
/*external functions*/
d39 1
a39 105
void sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
{
  int i;
  int percent;
  int mpercent;
  int mob_circle = 0;
  int counter = 0; 
  int spells_circle;
  if (!(victim))
    {
      mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
      return;
    }
  percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
  mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
  while (counter < GET_LEVEL(ch))
    {
      mob_circle ++;
      counter = mob_circle*5 + 1;
    }
  counter = 0;
  if (GET_CLASS(ch) != MCLASS_SORCERER) 
    return;
  
  /*if mob condition low maybe teleport out*/
  if (percent < 10 && !MOB_FLAGGED(ch, MOB_PET))
    if (!(number(0, 3)))
      {
	spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
	if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	  return;
      }
  
  /*check spell up spells*/
  if (mpercent > 15)
    if (check_sor_fight_status(ch))
      return;
  
  /*check wether area spell be best*/
  i = 0;
  if (IS_AFFECTED(victim, AFF_GROUP))
    {   
      if ((i=number_of_people_in_group(ch, victim)))
        {
	  for (i=0;i< SORCERER_AREA_NO;i++)
            {
	      if (counter > 1)/*only bother with top two*/
		break;
	      spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
	      if ((mob_circle >= spells_circle))
                { 
		  counter++;
		  if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
		    return;    
                }
            }
        }
    }
  
  /*low percentage even for high levels but try to harness*/
  if (IS_FIGHTING(ch))
    if (GET_LEVEL(ch) > 50)
      if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
	if (mpercent > 75)
	  if (!(number(0, 10)))
	    {
	      spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
	      if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
		return;
	    }
  
  /*try a other type of spell*/
  if (IS_FIGHTING(ch))
    {
      i = 7;
      if (mpercent > 80)
	i = 2;
      if (!number(0, i))
        {        /*ray of enf*/
	  if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
	      spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
	      if ((mob_circle >= spells_circle))
                {
		  if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
		    return;
                }
            }
        }
    }
  /*one on one target spell*/
  for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
      if (counter > 3)
	break;
      spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
      if ((mob_circle >= spells_circle))
        {
	  counter++;
	  if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	    return;    
        }
    }
  return;
}
a40 34
/*this is called if a mob is fighting and needs to spell up*/
bool check_sor_fight_status(struct char_data *ch)
{
  int spells_circle;
  int i, mob_circle = 0;
  i = 0;
  while (i < GET_LEVEL(ch))
    {/*calculates what circle mob can have*/
      mob_circle++;
      i = mob_circle*5 + 1;/*uses counter as a temp variable*/
    }
  for (i=0;i < NUMBER_SO_OFFENSE_CHECKS;i++)
    {
      if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
	{
	  spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
	  if (mob_circle >= spells_circle)
	    if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2])) 
	      {    
		if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
		  if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2))) 
		    continue;
		if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
		  if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2))) 
		    continue;
		
		if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
		  return TRUE;
	      }
	}
      
    }
  return FALSE;
}
d42 60
d103 2
a104 49
void check_sor_status(struct char_data *ch)
{
  int i;
  int spells_circle;
  int mob_circle = 0;
  if(!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch)) 
    return;	
  if(ch->desc && ch->desc->original)
    return;
  if(MOB_FLAGGED(ch, MOB_CASTING))
    return;
  i = 0;
  /* if charmed exit so not anoying*/
  /* cancel that. we DO want charmed mobs to cast spells. -321 */
  /*  if ((IS_AFFECTED(ch, AFF_CHARM)))
   *    return;
   */

  while (i < GET_LEVEL(ch))
    {/*calculates what circle mob can have*/
      mob_circle ++;
      i = mob_circle*5 + 1;/*uses counter as a temp variable*/
    }
  for (i=0;i < NUMBER_OF_SO_CHECKS;i++)
    {
      if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
	{
	  if ((so_spells_to_check[i][0] == SPELL_INVISIBLE))
	    if (!MEMORY(ch))
	      continue;
	  
	  spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
	  if (mob_circle >= spells_circle)
	    if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2])) 
	      {   
		
		if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
		  if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2))) 
		    continue;
		
		if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
		  if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2))) 
		    continue;
		if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
		  return;
	      }
	}
    }
}
d106 22
a127 12
void dragon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
{
  int i;
  int percent;
  int mpercent;
  int mob_circle = 0;
  int counter = 0; 
  int spells_circle;
  if (!(victim))
    {
      mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
      return;
d129 1
a129 111
  percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
  mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
  while (counter < GET_LEVEL(ch))
    {
      mob_circle ++;
      counter = mob_circle*5 + 1;
    }
  counter = 0;
  if (GET_CLASS(ch) != MCLASS_SORCERER) 
    return;
  
  /*if mob condition low maybe teleport out*/
  if (percent < 10)
    if (!(number(0, 3)))
      {
	spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
	if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	  return;
      }
  
  /*check spell up spells*/
  if (mpercent > 15)
    if (check_sor_fight_status(ch))
      return;
  
  /*check wether area spell be best*/
  i = 0;
  if (IS_AFFECTED(victim, AFF_GROUP))
    {   
      if ((i=number_of_people_in_group(ch, victim)))
        {
	  for (i=0;i< SORCERER_AREA_NO;i++)
            {
	      if (counter > 1) {/*only bother with top two*/
		if((number (1, 20)) > 11) {
		  do_a_dragon_thing(ch);  /*  dragons -Banyal */
		  return;
		} else
		  break; }
	      spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
	      if ((mob_circle >= spells_circle))
                { 
		  counter++;
		  if(number(1, 10) > 8) {
		    do_a_dragon_thing(ch);
		    return;} 
		  if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
		    return;    
                }
            }
        }
    }
  
  /*low percentage even for high levels but try to harness*/
  if (IS_FIGHTING(ch))
    if (GET_LEVEL(ch) > 50)
      if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
	if (mpercent > 75)
	  if (!(number(0, 10)))
	    {
	      spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
	      if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
		return;
	    }
  
  /*try a other type of spell*/
  if (IS_FIGHTING(ch))
    {
      i = 7;
      if (mpercent > 80)
	i = 2;
      if (!number(0, i))
        {        /*ray of enf*/
	  if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
	      spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
	      if ((mob_circle >= spells_circle))
                {
		  if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
		    return;
                }
	      
            }
        }
    }
  /*one on one target spell*/
  for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
      if (counter > 3){
	if((number (1, 20)) > 11) {
	  do_a_dragon_thing(ch);
	  return;
	}else
	  break; }
      spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
      if ((mob_circle >= spells_circle))
        {
	  counter++;
	  if(number(1, 10) > 8) {
	    do_a_dragon_thing(ch);
	    return;}
	  if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	    return;    
        }
    }
  if((number (1, 20)) > 11) {
    do_a_dragon_thing(ch);
    return;
  }else   
    return;
}
d131 34
a164 26
void
do_a_dragon_thing(struct char_data *ch)
{
  int j;
  int cmd_breathe, cmd_sweep, cmd_roar;
  
  j = number(1, 3);
  
  if (j == 1) {
    if (GET_MSKILL(ch, SKILL_BREATHE)) {
      cmd_breathe = find_command("breathe");
      do_breathe(ch, "", cmd_breathe, 0);
      return;
    } return;
  } else if (j == 2) {  /*  sweep */
    if (GET_MSKILL(ch, SKILL_SWEEP)) {
      cmd_sweep = find_command("sweep");  
      do_sweep(ch, "", cmd_sweep, 0);
      return;
    } return;
  } else if (j == 3) {  /*  roar        */
    if (GET_MSKILL(ch, SKILL_ROAR)) {   
      cmd_roar = find_command("roar");
      do_roar(ch, "", cmd_roar, 0);
      return;
    }return;
d166 2
d170 2
a171 2

void demon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim)
d174 39
a212 9
  int percent;
  int mpercent;
  int mob_circle = 0;
  int counter = 0; 
  int spells_circle;
  if (!(victim))
    {
      mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
      return;
d214 5
a218 110
  percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
  mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
  while (counter < GET_LEVEL(ch))
    {
      mob_circle ++;
      counter = mob_circle*5 + 1;
    }
  counter = 0;
  if (GET_CLASS(ch) != MCLASS_SORCERER) 
    return;
  
  /*if mob condition low maybe teleport out*/
  if (percent < 10)
    if (!(number(0, 3)))
      {
	spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
	if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	  return;
      }
  
  /*check spell up spells*/
  if (mpercent > 15)
    if (check_sor_fight_status(ch))
      return;
  
  /*check wether area spell be best*/
  i = 0;
  if (IS_AFFECTED(victim, AFF_GROUP))
    {   
      if ((i=number_of_people_in_group(ch, victim)))
        {
	  for (i=0;i< SORCERER_AREA_NO;i++)
            {
	      if (counter > 1) {/*only bother with top two*/
		if((number (1, 20)) > 11) {
		  do_a_demon_thing(ch);  /*  demon -Banyal */
		  return;
		} else
		  break; }
	      spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
	      if ((mob_circle >= spells_circle))
                { 
		  counter++;
		  if(number(1, 10) > 8) {
		    do_a_demon_thing(ch);
		    return;}
		  if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
		    return;    
                }
            }
        }
    }
  
  /*low percentage even for high levels but try to harness*/
  if (IS_FIGHTING(ch))
    if (GET_LEVEL(ch) > 50)
      if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
	if (mpercent > 75)
	  if (!(number(0, 10)))
	    {
	      spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
	      if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
		return;
	    }
  
  /*try a other type of spell*/
  if (IS_FIGHTING(ch))
    {
      i = 7;
      if (mpercent > 80)
	i = 2;
      if (!number(0, i))
        {        /*ray of enf*/
	  if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
            {
	      spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
	      if ((mob_circle >= spells_circle))
                {
		  if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
		    return;
                }
	      
            }
        }
    }
  /*one on one target spell*/
  for (i=0;i< SORCERER_OFFENSE_NO;i++)
    {
      if (counter > 3){
	if((number (1, 20)) > 11) {
	  do_a_demon_thing(ch);
	  return;
	}else
	  break; }
      spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
      if ((mob_circle >= spells_circle))
        {
	  counter++;
	  if(number(1, 10) > 8) {
	    do_a_demon_thing(ch); 
	    return;}
	  if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	    return;    
        }
    }
  if((number (1, 20)) > 11) {
    do_a_demon_thing(ch);
    return;
  }else   
    return;
a220 22
void
do_a_demon_thing(struct char_data *ch)
{
  int j;
  int cmd_breathe, cmd_roar;

  j = number(1, 2);
  
  if (j == 1) {
    if (GET_MSKILL(ch, SKILL_BREATHE)) {
      cmd_breathe = find_command("breathe");
      do_breathe(ch, "", cmd_breathe, 0);
      return;
    } return;
  } else {  /*  roar        */
    if (GET_MSKILL(ch, SKILL_ROAR)) {   
      cmd_roar = find_command("roar");
      do_roar(ch, "", cmd_roar, 0);
      return;
    }return;
  }
}
@


1.7
log
@Change verbal instances of "breath" to "breathe"
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.6 2002/09/13 02:32:10 jjl Exp $
a39 1
extern int cleric_subclasses[CLERIC_SUBCLASSES];
d551 3
@


1.6
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: sorcerer.c,v 1.5 2000/11/25 02:33:15 rsd Exp $
d49 1
a49 1
ACMD(do_breath);
d376 1
a376 1
  int cmd_breath, cmd_sweep, cmd_roar;
d381 3
a383 3
    if (GET_MSKILL(ch, SKILL_BREATH)) {
      cmd_breath = find_command("breath");
      do_breath(ch, "", cmd_breath, 0);
d531 1
a531 1
  int cmd_breath, cmd_roar;
d536 3
a538 3
    if (GET_MSKILL(ch, SKILL_BREATH)) {
      cmd_breath = find_command("breath");
      do_breath(ch, "", cmd_breath, 0);
d552 3
@


1.5
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: sorcerer.c,v 1.4 1999/11/28 23:54:25 cso Exp $
d295 1
a295 1
		  do_a_dragon_thing(ch); // dragons -Banyal
d386 1
a386 1
  } else if (j == 2) { // sweep
d392 1
a392 1
  } else if (j == 3) { // roar       
d450 1
a450 1
		  do_a_demon_thing(ch); // demon -Banyal
d541 1
a541 1
  } else { // roar       
d550 21
a570 15
// $Log: sorcerer.c,v $
// Revision 1.4  1999/11/28 23:54:25  cso
// took out the check that kept charmed mobs from casting spells. now they can
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/02/02 15:15:42  mud
// dos2unix
// indented file
// added standard comment header.
//
// Revision 1.1  1999/01/29 01:23:32  mud
// Initial revision
//
@


1.4
log
@took out the check that kept charmed mobs from casting spells. now they can
@
text
@d1 1
a1 1
// $Id: sorcerer.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d3 1
a3 1
 *  File: sorcerer.c                                      Part of FieryMUD *
d5 2
a6 2
 *         to ai.h, and ai_util.c. Original comments indicated that the    *
 *         file was created by Proky to control Cleric type mobs.          *
d8 5
a12 2
 *  By: Proky of HubisMUD                                                  *
 *  Control M's removed by: Scott Davis                                    *
d15 4
a52 2


a547 1

d549 3
d554 8
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d202 6
a207 4
  if ((IS_AFFECTED(ch, AFF_CHARM)))
    return;
  /*if charmed exit so not anoying*/
  
d544 4
a547 1
// $Log$
@


1.2
log
@dos2unix
indented file
qaadded standard comment header.
@
text
@d1 1
d542 1
@


1.1
log
@Initial revision
@
text
@d1 9
a9 5
/*File: sorcerer.c*
*This file was created by Proky to control Cleric type mobs *
*It is closly related to ai.h, and ai_util.c                *
*/

d49 39
a87 39
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0; 
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER) 
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10 && !MOB_FLAGGED(ch, MOB_PET))
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }
        
    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
d89 1
a89 1
        if ((i=number_of_people_in_group(ch, victim)))
d91 1
a91 1
            for (i=0;i< SORCERER_AREA_NO;i++)
d93 4
a96 4
				if (counter > 1)/*only bother with top two*/
					break;
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
d98 3
a100 3
                    counter++;
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;    
d104 21
a124 21
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
d126 1
a126 1
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
d128 2
a129 2
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
d131 2
a132 2
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
d137 2
a138 2
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
d140 4
a143 4
		if (counter > 3)
			break;
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
d145 3
a147 3
            counter++;
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;    
d150 1
a150 1
    return;
d156 4
a159 4
    int spells_circle;
    int i, mob_circle = 0;
    i = 0;
    while (i < GET_LEVEL(ch))
d161 2
a162 2
	    mob_circle++;
	    i = mob_circle*5 + 1;/*uses counter as a temp variable*/
d164 1
a164 1
    for (i=0;i < NUMBER_SO_OFFENSE_CHECKS;i++)
d166 18
a183 18
       if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
       {
            spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
            if (mob_circle >= spells_circle)
                if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2])) 
                {    
                    if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
                        if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2))) 
                            continue;
                    if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
                        if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2))) 
                            continue;
                    
                    if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
                        return TRUE;
                }
       }

d185 1
a185 1
    return FALSE;
d191 15
a205 15
int i;
int spells_circle;
int mob_circle = 0;
    if(!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch)) 
        return;	
    if(ch->desc && ch->desc->original)
        return;
    if(MOB_FLAGGED(ch, MOB_CASTING))
        return;
    i = 0;
    if ((IS_AFFECTED(ch, AFF_CHARM)))
        return;
    /*if charmed exit so not anoying*/

    while (i < GET_LEVEL(ch))
d207 2
a208 2
	    mob_circle ++;
	    i = mob_circle*5 + 1;/*uses counter as a temp variable*/
d210 1
a210 1
    for (i=0;i < NUMBER_OF_SO_CHECKS;i++)
d212 22
a233 22
       if (GET_MSKILL(ch, so_spells_to_check[i][0]) > 0)
       {
           if ((so_spells_to_check[i][0] == SPELL_INVISIBLE))
                        if (!MEMORY(ch))
                            continue;

            spells_circle = SPELL_CIRCLE(so_spells_to_check[i][0]);
            if (mob_circle >= spells_circle)
                if (!affected_by_aff(ch, so_spells_to_check[i][0], so_spells_to_check[i][1], so_spells_to_check[i][2])) 
                {   
                    
                    if ((so_spells_to_check[i][0] == SPELL_MINOR_GLOBE))
                        if ((affected_by_aff(ch, SPELL_MINOR_GLOBE, AFF2_MINOR_GLOBE, 2)) || (affected_by_aff(ch, SPELL_MAJOR_GLOBE, AFF2_MAJOR_GLOBE, 2))) 
                            continue;
              
                    if ((so_spells_to_check[i][0] == SPELL_COLDSHIELD) || (so_spells_to_check[i][0] == SPELL_COLDSHIELD))
                        if ((affected_by_aff(ch, SPELL_COLDSHIELD, AFF2_COLDSHIELD, 2)) || (affected_by_aff(ch, SPELL_FIRESHIELD, AFF2_FIRESHIELD, 2))) 
                            continue;
                    if (try_cast(ch, ch, spells_circle, so_spells_to_check[i][0]))
                        return;
                }
       }
d239 39
a277 39
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0; 
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER) 
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10)
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }
        
    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
d279 1
a279 1
        if ((i=number_of_people_in_group(ch, victim)))
d281 1
a281 1
            for (i=0;i< SORCERER_AREA_NO;i++)
d283 8
a290 8
				if (counter > 1) {/*only bother with top two*/
                     if((number (1, 20)) > 11) {
                        do_a_dragon_thing(ch); // dragons -Banyal
			return;
			} else
		        break; }
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
d292 6
a297 6
                    counter++;
                       if(number(1, 10) > 8) {
			do_a_dragon_thing(ch);
			return;} 
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;    
d301 21
a321 21
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
d323 1
a323 1
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
d325 2
a326 2
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
d328 2
a329 2
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
d331 1
a331 1
                
d335 2
a336 2
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
d338 8
a345 8
		if (counter > 3){
 		if((number (1, 20)) > 11) {
                 do_a_dragon_thing(ch);
		 return;
		}else
			break; }
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
d347 6
a352 6
            counter++;
             if(number(1, 10) > 8) {
                        do_a_dragon_thing(ch);
                        return;}
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;    
d355 4
a358 4
if((number (1, 20)) > 11) {
                 do_a_dragon_thing(ch);
                 return;
                }else   
d365 5
a369 5
 int j;
 int cmd_breath, cmd_sweep, cmd_roar;

 j = number(1, 3);

d371 18
a388 18
   if (GET_MSKILL(ch, SKILL_BREATH)) {
        cmd_breath = find_command("breath");
        do_breath(ch, "", cmd_breath, 0);
         return;
       } return;
       } else if (j == 2) { // sweep
       if (GET_MSKILL(ch, SKILL_SWEEP)) {
        cmd_sweep = find_command("sweep");  
        do_sweep(ch, "", cmd_sweep, 0);
        return;
        } return;
        } else if (j == 3) { // roar       
       if (GET_MSKILL(ch, SKILL_ROAR)) {   
        cmd_roar = find_command("roar");
        do_roar(ch, "", cmd_roar, 0);
        return;
         }return;
        }
d394 39
a432 39
    int i;
    int percent;
    int mpercent;
    int mob_circle = 0;
    int counter = 0; 
    int spells_circle;
    if (!(victim))
    {
        mudlog("No victim in Sorcerer update.", NRM, LVL_GOD, FALSE);
        return;
    }
    percent = (int)((100 * (float)GET_HIT(ch)) / GET_MAX_HIT(ch));
    mpercent = (int)((100 * (float)GET_HIT(victim)) / GET_MAX_HIT(victim));	
    while (counter < GET_LEVEL(ch))
    {
	    mob_circle ++;
	    counter = mob_circle*5 + 1;
    }
    counter = 0;
    if (GET_CLASS(ch) != MCLASS_SORCERER) 
        return;

    /*if mob condition low maybe teleport out*/
    if (percent < 10)
        if (!(number(0, 3)))
        {
            spells_circle = SPELL_CIRCLE(SPELL_TELEPORT);
            if (try_cast(ch, ch, spells_circle, SPELL_TELEPORT))
	            return;
        }
        
    /*check spell up spells*/
    if (mpercent > 15)
        if (check_sor_fight_status(ch))
            return;

    /*check wether area spell be best*/
    i = 0;
    if (IS_AFFECTED(victim, AFF_GROUP))
d434 1
a434 1
        if ((i=number_of_people_in_group(ch, victim)))
d436 1
a436 1
            for (i=0;i< SORCERER_AREA_NO;i++)
d438 8
a445 8
				if (counter > 1) {/*only bother with top two*/
                     if((number (1, 20)) > 11) {
                        do_a_demon_thing(ch); // demon -Banyal
			return;
			} else
		        break; }
                spells_circle = SPELL_CIRCLE(sorcerer_area[i]);
                if ((mob_circle >= spells_circle))
d447 6
a452 6
                    counter++;
                    if(number(1, 10) > 8) {
                        do_a_demon_thing(ch);
                        return;}
	                if(try_cast(ch, victim, spells_circle, sorcerer_area[i]))
	                    return;    
d456 21
a476 21
     }

    /*low percentage even for high levels but try to harness*/
    if (IS_FIGHTING(ch))
        if (GET_LEVEL(ch) > 50)
		  if (!affected_by_aff(ch,SPELL_HARNESS, AFF2_HARNESS, 2))
            if (mpercent > 75)
                if (!(number(0, 10)))
                {
                    spells_circle = SPELL_CIRCLE(SPELL_HARNESS);
                    if(try_cast(ch, victim, spells_circle, SPELL_HARNESS))
	                    return;
                }

    /*try a other type of spell*/
    if (IS_FIGHTING(ch))
    {
        i = 7;
        if (mpercent > 80)
            i = 2;
        if (!number(0, i))
d478 1
a478 1
            if (!affected_by_aff(victim,SPELL_RAY_OF_ENFEEB, -1, -1))
d480 2
a481 2
                spells_circle = SPELL_CIRCLE(SPELL_RAY_OF_ENFEEB);
                if ((mob_circle >= spells_circle))
d483 2
a484 2
                    if(try_cast(ch, victim, spells_circle, SPELL_RAY_OF_ENFEEB))
	                    return;
d486 1
a486 1
                
d490 2
a491 2
    /*one on one target spell*/
    for (i=0;i< SORCERER_OFFENSE_NO;i++)
d493 8
a500 8
		if (counter > 3){
 		if((number (1, 20)) > 11) {
                 do_a_demon_thing(ch);
		 return;
		}else
			break; }
        spells_circle = SPELL_CIRCLE(sorcerer_offense[i]);
        if ((mob_circle >= spells_circle))
d502 6
a507 6
            counter++;
             if(number(1, 10) > 8) {
                        do_a_demon_thing(ch); 
                        return;}
	        if(try_cast(ch, victim, spells_circle, sorcerer_offense[i]))
	            return;    
d510 4
a513 4
if((number (1, 20)) > 11) {
                 do_a_demon_thing(ch);
                 return;
                }else   
d520 2
a521 4
 int j;
 int cmd_breath, cmd_roar;

 j = number(1, 2);
d523 2
d526 12
a537 12
   if (GET_MSKILL(ch, SKILL_BREATH)) {
        cmd_breath = find_command("breath");
        do_breath(ch, "", cmd_breath, 0);
         return;
       } return;
        } else { // roar       
       if (GET_MSKILL(ch, SKILL_ROAR)) {   
        cmd_roar = find_command("roar");
        do_roar(ch, "", cmd_roar, 0);
        return;
         }return;
        }
d539 2
@
