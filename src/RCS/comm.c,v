head	1.183;
access;
symbols;
locks; strict;
comment	@ * @;


1.183
date	2012.08.09.02.14.46;	author fierymud;	state Exp;
branches;
next	1.182;

1.182
date	2011.08.18.00.13.14;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2011.08.06.15.30.22;	author rsd;	state Exp;
branches;
next	1.180;

1.180
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2009.07.16.19.15.54;	author myc;	state Exp;
branches;
next	1.178;

1.178
date	2009.06.11.13.36.05;	author myc;	state Exp;
branches;
next	1.177;

1.177
date	2009.06.10.02.27.14;	author myc;	state Exp;
branches;
next	1.176;

1.176
date	2009.05.01.05.29.40;	author myc;	state Exp;
branches;
next	1.175;

1.175
date	2009.03.21.19.11.37;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2009.03.20.23.02.59;	author myc;	state Exp;
branches;
next	1.173;

1.173
date	2009.03.20.20.19.51;	author myc;	state Exp;
branches;
next	1.172;

1.172
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.171;

1.171
date	2009.03.09.05.59.57;	author myc;	state Exp;
branches;
next	1.170;

1.170
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.169;

1.169
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.167;

1.167
date	2009.03.07.22.30.29;	author jps;	state Exp;
branches;
next	1.166;

1.166
date	2009.02.26.17.40.41;	author rsd;	state Exp;
branches;
next	1.165;

1.165
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.164;

1.164
date	2009.02.16.19.37.21;	author myc;	state Exp;
branches;
next	1.163;

1.163
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2009.02.09.20.09.56;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2009.02.05.17.15.04;	author myc;	state Exp;
branches;
next	1.160;

1.160
date	2009.01.19.08.42.29;	author myc;	state Exp;
branches;
next	1.159;

1.159
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2008.09.21.21.50.56;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.09.21.05.26.55;	author myc;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.20.17.37.29;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2008.09.07.20.07.39;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.08.31.07.16.41;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.08.30.04.13.45;	author myc;	state Exp;
branches;
next	1.148;

1.148
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.08.26.04.39.21;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2008.08.25.02.31.30;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2008.08.25.00.20.33;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.23.14.03.30;	author jps;	state Exp;
branches;
next	1.143;

1.143
date	2008.08.14.23.02.11;	author myc;	state Exp;
branches;
next	1.142;

1.142
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.08.13.05.53.18;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.07.27.05.30.09;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2008.07.15.17.49.24;	author myc;	state Exp;
branches;
next	1.138;

1.138
date	2008.07.13.18.49.29;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.134;

1.134
date	2008.05.26.18.24.48;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.131;

1.131
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.26.23.35.43;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.19.20.17.46;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.05.21.42.50;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.05.16.49.21;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.05.05.05.00;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.123;

1.123
date	2008.04.04.05.13.46;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.119;

1.119
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.03.17.15.31.27;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.08.22.29.06;	author myc;	state Exp;
branches;
next	1.116;

1.116
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.115;

1.115
date	2008.03.06.05.11.51;	author myc;	state Exp;
branches;
next	1.114;

1.114
date	2008.03.06.04.34.38;	author myc;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.112;

1.112
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.111;

1.111
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2008.02.24.06.31.41;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.09.07.05.37;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.09.03.04.23;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.30.19.20.57;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2008.01.15.06.51.47;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2008.01.09.04.14.19;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.05.05.37.04;	author jps;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.04.04.30.47;	author jps;	state Exp;
branches;
next	1.91;

1.91
date	2007.12.25.05.21.49;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.20.23.10.39;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2007.12.19.20.45.06;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.28.09.52.19;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.23.20.20.22;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.04.06.49.19;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.27.21.18.00;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2007.08.22.18.01.46;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.19.18.34.39;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2007.08.17.02.23.36;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.14.20.13.57;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2007.08.14.10.44.05;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.25.00.38.03;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.24.23.34.00;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.28.06.59.42;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.24.07.28.34;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.18.01.02.17;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.18.00.05.59;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.20.19.52.04;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.14.22.47.10;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.14.21.30.44;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.13.02.51.02;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.10.21.00.26;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.01.21.46.23;	author rls;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.11.23.02.23;	author rsd;	state Exp;
branches;
next	1.61;

1.61
date	2003.04.16.02.00.22;	author jjl;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.29.17.29.03;	author rsd;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.17.22.41.06;	author dce;	state Exp;
branches;
next	1.57;

1.57
date	2001.12.09.14.08.32;	author dce;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.07.02.09.56;	author dce;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.17.02.55.38;	author dce;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.17.02.45.49;	author dce;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.13.16.15.58;	author dce;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.03.01.26.16;	author dce;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.14.19.04.59;	author rsd;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.09.03.05.21;	author dce;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.06.03.10.18;	author dce;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.04.17.33.19;	author dce;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.03.18.08.20;	author dce;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.24.16.47.31;	author dce;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.23.01.51.46;	author rsd;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.28.01.36.34;	author mtp;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.28.01.19.01;	author mtp;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.20.19.43.45;	author rsd;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.15.22.55.01;	author rsd;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.14.00.47.00;	author rsd;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.02.02.38.23;	author rsd;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.20.04.28.47;	author rsd;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.14.05.13.23;	author jimmy;	state Exp;
branches;
next	1.36;

1.36
date	99.11.28.22.55.42;	author cso;	state Exp;
branches;
next	1.35;

1.35
date	99.10.06.17.53.01;	author rsd;	state Exp;
branches;
next	1.34;

1.34
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.33;

1.33
date	99.08.12.18.21.47;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.31;

1.31
date	99.07.26.03.49.00;	author jimmy;	state Exp;
branches;
next	1.30;

1.30
date	99.07.09.22.30.27;	author jimmy;	state Exp;
branches;
next	1.29;

1.29
date	99.07.09.13.57.00;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	99.07.09.02.59.46;	author jimmy;	state Exp;
branches;
next	1.27;

1.27
date	99.07.09.02.38.50;	author jimmy;	state Exp;
branches;
next	1.26;

1.26
date	99.07.02.21.58.04;	author jimmy;	state Exp;
branches;
next	1.25;

1.25
date	99.06.11.16.56.55;	author jimmy;	state Exp;
branches;
next	1.24;

1.24
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	99.04.23.23.27.10;	author jimmy;	state Exp;
branches;
next	1.22;

1.22
date	99.04.23.21.35.11;	author jimmy;	state Exp;
branches;
next	1.21;

1.21
date	99.04.16.20.50.34;	author dce;	state Exp;
branches;
next	1.20;

1.20
date	99.04.10.06.04.52;	author dce;	state Exp;
branches;
next	1.19;

1.19
date	99.04.10.05.53.40;	author jen;	state Exp;
branches;
next	1.18;

1.18
date	99.04.10.05.13.48;	author jen;	state Exp;
branches;
next	1.17;

1.17
date	99.04.10.05.05.58;	author jen;	state Exp;
branches;
next	1.16;

1.16
date	99.04.09.23.19.49;	author jen;	state Exp;
branches;
next	1.15;

1.15
date	99.04.05.19.37.55;	author jen;	state Exp;
branches;
next	1.14;

1.14
date	99.04.05.19.01.05;	author jen;	state Exp;
branches;
next	1.13;

1.13
date	99.04.05.18.55.46;	author jen;	state Exp;
branches;
next	1.12;

1.12
date	99.04.02.17.07.06;	author jen;	state Exp;
branches;
next	1.11;

1.11
date	99.03.26.19.47.10;	author jen;	state Exp;
branches;
next	1.10;

1.10
date	99.03.21.21.18.12;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.03.12.19.44.42;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.03.08.20.22.35;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	99.03.06.23.51.54;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.03.01.05.31.34;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.24.22.59.35;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.07.06.46.21;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.01.30.19.42.27;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.01.29.05.42.00;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: comm.c                                        Part of CircleMUD *
*  Usage: Communication, socket handling, main(), central game loop       *
*                                                                        *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __COMM_C__

#include "conf.h"
#include "sysdep.h"


#ifdef CIRCLE_WINDOWS		/* Includes for Win32 */
#include <direct.h>
#include <mmsystem.h>
#else				/* Includes for UNIX */
#include <sys/socket.h>
#include <sys/resource.h>
#include <netinet/in.h>
#include <netdb.h>
#include <signal.h>
#endif

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "house.h"
#include "screen.h"
#include "olc.h"
#include "ships.h"
#include "events.h"
#include "dg_scripts.h"
#include "worship.h"
#include "weather.h"
#include "maputils.h"

#ifdef HAVE_ARPA_TELNET_H
#include <arpa/telnet.h>
#else
#include "telnet.h"
#endif

#ifndef INVALID_SOCKET
#define INVALID_SOCKET -1
#endif

#define YES	1
#define NO	0


/* externs */
extern int restrict;
extern int mini_mud;
extern int no_rent_check;
extern FILE *player_fl;
extern int DFLT_PORT;
extern char *DFLT_DIR;
extern int MAX_PLAYERS;
extern int MAX_DESCRIPTORS_AVAILABLE;
extern int mapnums[MAP_ROWS][MAP_COLS];
extern struct index_data *obj_index;
extern char *race_abbrevs[];
extern char *size_abbervs[];

extern void update_spell_mem(void);
extern struct room_data *world;	/* In db.c */
extern int top_of_world;	/* In db.c */
extern int top_of_zone_table;
extern struct time_info_data time_info;		/* In db.c */
extern char help[];
extern const char *save_info_msg[];	/* In olc.c */
long exp_to_level(int, int);
bool DisarmCheck(struct char_data * ch);
void die(struct char_data * ch, struct char_data * killer);

/* local globals */
struct descriptor_data *descriptor_list = NULL;		/* master desc list */
struct txt_block *bufpool = 0;	/* pool of large output buffers */
int buf_largecount = 0;		/* # of large buffers which exist */
int buf_overflows = 0;		/* # of overflows of output */
int buf_switches = 0;		/* # of switches from small to large buf */
int circle_shutdown = 0;	/* clean shutdown */
int circle_reboot = 0;		/* reboot the game after a shutdown */
int no_specials = 0;		/* Suppress ass. of special routines */
int max_players = 0;		/* max descriptors available */
int tics = 0;			/* for extern checkpointing */
int scheck = 0;			/* for syntax checking mode */
int dg_act_check;               /* toggle for act_trigger */
unsigned long dg_global_pulse = 0; /* number of pulses since game start */
bool MOBTrigger = TRUE;		/* for MOBProgs	*/
extern int nameserver_is_slow;	/* see config.c */
extern int auto_save;		/* see config.c */
extern int autosave_time;	/* see config.c */
struct timeval null_time;	/* zero-valued time structure */
unsigned long pulse = 0;	/* number of pulses since game started */

/* functions in this file */
int get_from_q(struct txt_q *queue, char *dest, int *aliased);
void init_game(int port);
void signal_setup(void);
void game_loop(int mother_desc);
int init_socket(int port);
int new_descriptor(int s);
int get_max_players(void);
int process_output(struct descriptor_data *t);
int process_input(struct descriptor_data *t);
void close_socket(struct descriptor_data *d);
struct timeval timediff(struct timeval a, struct timeval b);
struct timeval timeadd(struct timeval a, struct timeval b);
void flush_queues(struct descriptor_data *d);
void nonblock(socket_t s);
int perform_subst(struct descriptor_data *t, char *orig, char *subst);
int perform_alias(struct descriptor_data *d, char *orig);
void record_usage(void);
void make_prompt(struct descriptor_data *point);
void check_idle_passwords(void);
void heartbeat(int pulse);
char *parse_color(char *txt, struct descriptor_data *t);
int count_chars(char *txt, char character);
void do_gravity_check(void);
void do_falling_damage(struct char_data *ch, float dist_fell);
char *new_txt;


/* extern fcnts */
void boot_db(void);
void boot_world(void);
void zone_update(void);
void affect_update(void);	/* In spells.c */
void point_update(void);	/* In limits.c */
void mobile_activity(void);
void mobile_spec_activity(void);
void string_add(struct descriptor_data *d, char *str);
void perform_violence(void);
void update_casting(void);
void perform_mob_violence(void);
void casting_gain(void);
void show_string(struct descriptor_data *d, char *input);
int isbanned(char *hostname);
extern void mprog_act_trigger(char *buf, struct char_data *mob, struct char_data *ch, struct obj_data *obj, void *vo);
void redit_save_to_disk(int zone_num);
void oedit_save_to_disk(int zone_num);
void medit_save_to_disk(int zone_num);
void sedit_save_to_disk(int zone_num);
void zedit_save_to_disk(int zone_num);
void dismount_char(struct char_data * ch);
#ifndef CIRCLE_WINDOWS
void ispell_init(void);
void ispell_done(void);
#endif



/* *********************************************************************
*  main game loop and related stuff                                    *
********************************************************************* */

/* Windows doesn't have gettimeofday, so we'll simulate it. */
#ifdef CIRCLE_WINDOWS

void gettimeofday(struct timeval *t, struct timezone *dummy)
{
  DWORD millisec = GetTickCount();

  t->tv_sec = (int) (millisec / 1000);
  t->tv_usec = (millisec % 1000) * 1000;
}

#endif


int main(int argc, char **argv)
{
  int port;
  char buf[512];
  int pos = 1;
  char *dir;

  port = DFLT_PORT;
  dir = DFLT_DIR;

  while ((pos < argc) && (*(argv[pos]) == '-')) {
    switch (*(argv[pos] + 1)) {
    case 'd':
      if (*(argv[pos] + 2))
	dir = argv[pos] + 2;
      else if (++pos < argc)
	dir = argv[pos];
      else {
	log("Directory arg expected after option -d.");
	exit(1);
      }
      break;
    case 'm':
      mini_mud = 1;
      no_rent_check = 1;
      log("Running in minimized mode & with no rent check.");
      break;
    case 'c':
      scheck = 1;
      log("Syntax check mode enabled.");
      break;
    case 'q':
      no_rent_check = 1;
      log("Quick boot mode -- rent check supressed.");
      break;
    case 'r':
      restrict = 1;
      log("Restricting game -- no new players allowed.");
      break;
    case 's':
      no_specials = 1;
      log("Suppressing assignment of special routines.");
      break;
    default:
      sprintf(buf, "SYSERR: Unknown option -%c in argument string.", *(argv[pos] + 1));
      log(buf);
      break;
    }
    pos++;
  }

  if (pos < argc) {
    if (!isdigit(*argv[pos])) {
      fprintf(stderr, "Usage: %s [-c] [-m] [-q] [-r] [-s] [-d pathname] [port #]\n", argv[0]);
      exit(1);
    } else if ((port = atoi(argv[pos])) <= 1024) {
      fprintf(stderr, "Illegal port number.\n");
      exit(1);
    }
  }
#ifdef CIRCLE_WINDOWS
  if (_chdir(dir) < 0) {
#else
  if (chdir(dir) < 0) {
#endif
    perror("Fatal error changing to data directory");
    exit(1);
  }
  sprintf(buf, "Using %s as data directory.", dir);
  log(buf);

  if (scheck) {
    boot_world();
    log("Done.");
    exit(0);
  } else {
    sprintf(buf, "Running game on port %d.", port);
    log(buf);
    init_game(port);
  }

  return 0;
}



/* Init sockets, run game, and cleanup sockets */
void init_game(int port)
{
  int mother_desc;
#ifndef NO_MAPS
  int rowcounter, colcounter, vnum_read;
  FILE* mapfile;
#endif
  srandom(time(0));

  log("Finding player limit.");
  max_players = get_max_players();

  log("Opening mother connection.");
  mother_desc = init_socket(port);

  event_init();

  boot_db();

#ifndef CIRCLE_WINDOWS
  log("Signal trapping.");
  signal_setup();
#endif

#ifndef NO_MAPS
  log("Loading Surface Map. ");
  mapfile = fopen("world/surface.map", "r");
  for (rowcounter = 0; rowcounter < MAP_ROWS; rowcounter++) {
    for (colcounter = 0; colcounter < MAP_COLS; colcounter++) {
      fscanf(mapfile, "%d", &vnum_read);
        mapnums[rowcounter][colcounter] = real_room(vnum_read);
    }
  }
  fclose(mapfile);
#endif // NO_MAPS

  log("Entering game loop.");

#ifndef CIRCLE_WINDOWS
  ispell_init();
#endif

  game_loop(mother_desc);

#ifndef CIRCLE_WINDOWS
  ispell_done();
#endif

  log("Closing all sockets.");
  while (descriptor_list)
    close_socket(descriptor_list);

  CLOSE_SOCKET(mother_desc);
  fclose(player_fl);

   if (circle_reboot != 2 && olc_save_list) { /* Don't save zones. */
    struct olc_save_info *entry, *next_entry;
    for (entry = olc_save_list; entry; entry = next_entry) {
      next_entry = entry->next;
      if (entry->type < 0 || entry->type > 4) {
        sprintf(buf, "OLC: Illegal save type %d!", entry->type);
        log(buf);
      } else if (entry->zone < 0) {
        sprintf(buf, "OLC: Illegal save zone %d!", entry->zone);
        log(buf);
      } else {
        sprintf(buf, "OLC: Reboot saving %s for zone %d.",
		save_info_msg[(int)entry->type], entry->zone);
        log(buf);
        switch (entry->type) {
        case OLC_SAVE_ROOM: redit_save_to_disk(entry->zone); break;
        case OLC_SAVE_OBJ:  oedit_save_to_disk(entry->zone); break;
        case OLC_SAVE_MOB:  medit_save_to_disk(entry->zone); break;
        case OLC_SAVE_ZONE: zedit_save_to_disk(entry->zone); break;
        case OLC_SAVE_SHOP: sedit_save_to_disk(entry->zone); break;
        default:      log("Unexpected olc_save_list->type"); break;
        }
      }
    }
  }


  if (circle_reboot) {
    log("Rebooting.");
    exit(52);			/* what's so great about HHGTTG, anyhow? */
  }
  log("Normal termination of game.");
}



/*
 * init_socket sets up the mother descriptor - creates the socket, sets
 * its options up, binds it, and listens.
 */
int init_socket(int port)
{
  int s, opt;
  struct sockaddr_in sa;

  /*
   * Should the first argument to socket() be AF_INET or PF_INET?  I don't
   * know, take your pick.  PF_INET seems to be more widely adopted, and
   * Comer (_Internetworking with TCP/IP_) even makes a point to say that
   * people erroneously use AF_INET with socket() when they should be using
   * PF_INET.  However, the man pages of some systems indicate that AF_INET
   * is correct; some such as ConvexOS even say that you can use either one.
   * All implementations I've seen define AF_INET and PF_INET to be the same
   * number anyway, so ths point is (hopefully) moot.
   */

#ifdef CIRCLE_WINDOWS
  {
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);

    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
      log("WinSock not available!\n");
      exit(1);
    }
    if ((wsaData.iMaxSockets - 4) < max_players) {
      max_players = wsaData.iMaxSockets - 4;
    }
    sprintf(buf, "Max players set to %d", max_players);
    log(buf);

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {
      fprintf(stderr, "Error opening network connection: Winsock err #%d\n", WSAGetLastError());
      exit(1);
    }
  }
#else
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Error creating socket");
    exit(1);
  }
#endif				/* CIRCLE_WINDOWS */

#if defined(SO_SNDBUF)
  opt = LARGE_BUFSIZE + GARBAGE_SPACE;
  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt SNDBUF");
    exit(1);
  }
#endif

#if defined(SO_REUSEADDR)
  opt = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt REUSEADDR");
    exit(1);
  }
#endif

#if defined(SO_LINGER)
  {
    struct linger ld;

    ld.l_onoff = 0;
    ld.l_linger = 0;
    if (setsockopt(s, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld)) < 0) {
      perror("setsockopt LINGER");
      exit(1);
    }
  }
#endif

  sa.sin_family = AF_INET;
  sa.sin_port = htons(port);
  sa.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    perror("bind");
    CLOSE_SOCKET(s);
    exit(1);
  }
  nonblock(s);
  listen(s, 5);
  return s;
}


int get_max_players(void)
{
#if defined(CIRCLE_OS2) || defined(CIRCLE_WINDOWS)
  return MAX_PLAYERS;
#else

  int max_descs = 0;
  char *method;

/*
 * First, we'll try using getrlimit/setrlimit.  This will probably work
 * on most systems.
 */
#if defined (RLIMIT_NOFILE) || defined (RLIMIT_OFILE)
#if !defined(RLIMIT_NOFILE)
#define RLIMIT_NOFILE RLIMIT_OFILE
#endif
  {
    struct rlimit limit;

    /* find the limit of file descs */
    method = "rlimit";
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling getrlimit");
      exit(1);
    }
    /* set the current to the maximum */
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling setrlimit");
      exit(1);
    }
#ifdef RLIM_INFINITY
    if (limit.rlim_max == RLIM_INFINITY)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else
      max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#else
    max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#endif
  }

#elif defined (OPEN_MAX) || defined(FOPEN_MAX)
#if !defined(OPEN_MAX)
#define OPEN_MAX FOPEN_MAX
#endif
  method = "OPEN_MAX";
  max_descs = OPEN_MAX;		/* Uh oh.. rlimit didn't work, but we have
				 * OPEN_MAX */
#elif defined (POSIX)
  /*
   * Okay, you don't have getrlimit() and you don't have OPEN_MAX.  Time to
   * use the POSIX sysconf() function.  (See Stevens' _Advanced Programming
   * in the UNIX Environment_).
   */
  method = "POSIX sysconf";
  errno = 0;
  if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
    if (errno == 0)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else {
      perror("Error calling sysconf");
      exit(1);
    }
  }
#else
  /* if everything has failed, we'll just take a guess */
  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
#endif

  /* now calculate max _players_ based on max descs */
  max_descs = MIN(MAX_PLAYERS, max_descs - NUM_RESERVED_DESCS);

  if (max_descs <= 0) {
    sprintf(buf, "Non-positive max player limit!  (Set at %d using %s).",
	    max_descs, method);
    log(buf);
    exit(1);
  }
  sprintf(buf, "Setting player limit to %d using %s.", max_descs, method);
  log(buf);
  return max_descs;
#endif				/* WINDOWS or OS2 */
}



/*
 * game_loop contains the main loop which drives the entire MUD.  It
 * cycles once every 0.10 seconds and is responsible for accepting new
 * new connections, polling existing connections for input, dequeueing
 * output and sending it out to players, and calling "heartbeat" functions
 * such as mobile_activity().
 */
void game_loop(int mother_desc)
{
  fd_set input_set, output_set, exc_set, null_set;
  struct char_data *t_ch = NULL;
  struct timeval last_time, before_sleep, opt_time, process_time, now, timeout;
  char comm[MAX_INPUT_LENGTH];
  struct descriptor_data *d, *next_d;
  int missed_pulses, maxdesc, aliased;

  /* initialize various time values */
  null_time.tv_sec = 0;
  null_time.tv_usec = 0;
  opt_time.tv_usec = OPT_USEC;
  opt_time.tv_sec = 0;
  FD_ZERO(&null_set);

  gettimeofday(&last_time, (struct timezone *) 0);

  /* The Main Loop.  The Big Cheese.  The Top Dog.  The Head Honcho.  The.. */
  while (!circle_shutdown) {

    /* Sleep if we don't have any connections */
    if (descriptor_list == NULL) {
      log("No connections.  Going to sleep.");
      FD_ZERO(&input_set);
      FD_SET(mother_desc, &input_set);
      if (select(mother_desc + 1, &input_set, (fd_set *) 0, (fd_set *) 0, NULL) < 0) {
	if (errno == EINTR)
	  log("Waking up to process signal.");
	else
	  perror("Select coma");
      } else
	log("New connection.  Waking up.");
      gettimeofday(&last_time, (struct timezone *) 0);
    }
    /* Set up the input, output, and exception sets for select(). */
    FD_ZERO(&input_set);
    FD_ZERO(&output_set);
    FD_ZERO(&exc_set);
    FD_SET(mother_desc, &input_set);

    maxdesc = mother_desc;
    for (d = descriptor_list; d; d = d->next) {
#ifndef CIRCLE_WINDOWS
      if (d->descriptor > maxdesc)
	maxdesc = d->descriptor;
#endif
      FD_SET(d->descriptor, &input_set);
      FD_SET(d->descriptor, &output_set);
      FD_SET(d->descriptor, &exc_set);
    }

    /*
     * At this point, we have completed all input, output and heartbeat
     * activity from the previous iteration, so we have to put ourselves
     * to sleep until the next 0.1 second tick.  The first step is to
     * calculate how long we took processing the previous iteration.
     */

    gettimeofday(&before_sleep, (struct timezone *) 0); /* current time */
    process_time = timediff(before_sleep, last_time);

    /*
     * If we were asleep for more than one pass, count missed pulses and sleep
     * until we're resynchronized with the next upcoming pulse.
     */
    if (process_time.tv_sec == 0 && process_time.tv_usec < OPT_USEC) {
      missed_pulses = 0;
    } else {
      missed_pulses = process_time.tv_sec * PASSES_PER_SEC;
      missed_pulses += process_time.tv_usec / OPT_USEC;
      process_time.tv_sec = 0;
      process_time.tv_usec = process_time.tv_usec % OPT_USEC;
    }

    /* Calculate the time we should wake up */
    last_time = timeadd(before_sleep, timediff(opt_time, process_time));

    /* Now keep sleeping until that time has come */
    gettimeofday(&now, (struct timezone *) 0);
    timeout = timediff(last_time, now);

    /* go to sleep */
    do {
#ifdef CIRCLE_WINDOWS
      Sleep(timeout.tv_sec * 1000 + timeout.tv_usec / 1000);
#else
      if (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &timeout) < 0) {
	if (errno != EINTR) {
	  perror("Select sleep");
	  exit(1);
	}
      }
#endif /* CIRCLE_WINDOWS */
      gettimeofday(&now, (struct timezone *) 0);
      timeout = timediff(last_time, now);
    } while (timeout.tv_usec || timeout.tv_sec);

    /* poll (without blocking) for new input, output, and exceptions */
    if (select(maxdesc + 1, &input_set, &output_set, &exc_set, &null_time) < 0) {
      perror("Select poll");
      return;
    }
    /* If there are new connections waiting, accept them. */
    if (FD_ISSET(mother_desc, &input_set))
      new_descriptor(mother_desc);

    /* kick out the freaky folks in the exception set */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &exc_set)) {
	FD_CLR(d->descriptor, &input_set);
	FD_CLR(d->descriptor, &output_set);
	close_socket(d);
      }
    }

    /* process descriptors with input pending */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &input_set))
	if (process_input(d) < 0)
	  close_socket(d);
    }

    /* process commands we just read from process_input */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;

      if ((--(d->wait) <= 0) && get_from_q(&d->input, comm, &aliased)) {
	if (d->character) {
	  /* reset the idle timer & pull char back from void if necessary */
	  d->character->char_specials.timer = 0;
	  if (!d->connected && GET_WAS_IN(d->character) != NOWHERE) {
	    if (d->character->in_room != NOWHERE)
	      char_from_room(d->character);
	    char_to_room(d->character, GET_WAS_IN(d->character));
	    GET_WAS_IN(d->character) = NOWHERE;
	    act("$n has returned.", TRUE, d->character, 0, 0, TO_ROOM);
	  }
	}
	d->wait = 1;
	d->prompt_mode = 1;


	 /* reversed these top 2 if checks so that you can use the page_string */
 	 /* function in the editor */
 	if (d->showstr_count)	/* reading something w/ pager     */
  	  show_string(d, comm);
 	else if (d->str)		/* writing boards, mail, etc.     */
 	  string_add(d, comm);
	else if (d->connected != CON_PLAYING)	/* in menus, etc. */
	  nanny(d, comm);
	else {			/* else: we're playing normally */
	  if (aliased)		/* to prevent recursive aliases */
	    d->prompt_mode = 0;
	  else {
	    if (perform_alias(d, comm))		/* run it through aliasing system */
	      get_from_q(&d->input, comm, &aliased);
	  }
	  SEND_TO_Q("\r\n",d);
	  command_interpreter(d->character, comm);	/* send it to interpreter */
	}
      }
    }

    /* send queued output out to the operating system (ultimately to user) */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &output_set) && *(d->output))
	if (process_output(d) < 0)
	  close_socket(d);
	else
	  d->prompt_mode = 1;
    }

    /* kick out folks in the CON_CLOSE state */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (STATE(d) == CON_CLOSE)
	close_socket(d);
    }

    /* give each descriptor an appropriate prompt */
    for (d = descriptor_list; d; d = d->next) {
      if (d->prompt_mode) {
	make_prompt(d);
	d->prompt_mode = 0;
      }
    }

    /*
     * Now, we execute as many pulses as necessary--just one if we haven't
     * missed any pulses, or make up for lost time if we missed a few
     * pulses by sleeping for too long.
     */
    missed_pulses++;

    if (missed_pulses <= 0) {
      log("SYSERR: MISSED_PULSES IS NONPOSITIVE!!!");
      missed_pulses = 1;
    }

    /* If we missed more than 30 seconds worth of pulses, forget it */
    if (missed_pulses > (30 * PASSES_PER_SEC)) {
      log("Warning: Missed more than 30 seconds worth of pulses");
      missed_pulses = 30 * PASSES_PER_SEC;
    }

    /* Now execute the heartbeat functions */
    while (missed_pulses--)
      heartbeat(++pulse);

	for (d = descriptor_list; d; d = d->next) {

	if (d->character && d->connected == CON_PLAYING) {
	  t_ch = d->character;


	  if (t_ch->char_specials.action_delays[ACT_DELAY_BASH])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_BASH]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]);

          /* paladin/anti innates */
	  if (t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_BERSERK])
	    --t_ch->char_specials.action_delays[ACT_DELAY_BERSERK];

	  if (t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL])
	    --t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL];

	  if ((t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0)) {
	    (void) DisarmCheck(t_ch);
	  }
	  if (t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT] > 0) {
	    --t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT];
	  }
	  /* ACT_DELAY_DISARM handled in perform_violence() */
	}
      }



    /* Update tics for deadlock protection (UNIX only) */
    tics++;
  }
}


void heartbeat(int pulse)
{
  static int mins_since_crashsave = 0;
  void process_events(void);

  dg_global_pulse++;

  process_events();

  if (!(pulse % PULSE_DG_SCRIPT))
    script_trigger_check();

  event_process();

  if (!(pulse % (PASSES_PER_SEC / 2))) 		/* 1/2 second */
    do_gravity_check();

  if (!(pulse % PULSE_ZONE))
    zone_update();

  if (!(pulse % (15 * PASSES_PER_SEC)))		/* 15 seconds */
    check_idle_passwords();

  if (!(pulse % (60 * PASSES_PER_SEC)))		/* 1 minute */
    divine_intervention();

  if (!(pulse % PULSE_MOBILE))
    mobile_activity();

  if (!(pulse % PULSE_VIOLENCE)){
    perform_violence();
	update_spell_mem();
    mobile_spec_activity();

  }

  if (!(pulse % (PULSE_VIOLENCE/2))) {
	perform_mob_violence();
	update_casting();
  }

  if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC)))
  {
    update_weather_and_time(1);
    affect_update();
    point_update();
    fflush(player_fl);
	casting_gain();
  }

  /* move the ships as appropriate */
    if(!(pulse % (400)))
	  update_ships();/*_update();*/

  if (auto_save && !(pulse % (60 * PASSES_PER_SEC))) {	/* 1 minute */
    if (++mins_since_crashsave >= autosave_time) {
      mins_since_crashsave = 0;
      Crash_save_all();
      House_save_all();
    }
  }
  if (!(pulse % (5 * 60 * PASSES_PER_SEC)))	/* 5 minutes */
    record_usage();
}


/* ******************************************************************
*  general utility stuff (for local use)                            *
****************************************************************** */

/*
 *  new code to calculate time differences, which works on systems
 *  for which tv_usec is unsigned (and thus comparisons for something
 *  being < 0 fail).  Based on code submitted by ss@@sirocco.cup.hp.com.
 */

/*
 * code to return the time difference between a and b (a-b).
 * always returns a nonnegative value (floors at 0).
 */
struct timeval timediff(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  if (a.tv_sec < b.tv_sec)
    return null_time;
  else if (a.tv_sec == b.tv_sec) {
    if (a.tv_usec < b.tv_usec)
      return null_time;
    else {
      rslt.tv_sec = 0;
      rslt.tv_usec = a.tv_usec - b.tv_usec;
      return rslt;
    }
  } else {			/* a->tv_sec > b->tv_sec */
    rslt.tv_sec = a.tv_sec - b.tv_sec;
    if (a.tv_usec < b.tv_usec) {
      rslt.tv_usec = a.tv_usec + 1000000 - b.tv_usec;
      rslt.tv_sec--;
    } else
      rslt.tv_usec = a.tv_usec - b.tv_usec;
    return rslt;
  }
}

/* add 2 timevals */
struct timeval timeadd(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  rslt.tv_sec = a.tv_sec + b.tv_sec;
  rslt.tv_usec = a.tv_usec + b.tv_usec;

  while (rslt.tv_usec >= 1000000) {
    rslt.tv_usec -= 1000000;
    rslt.tv_sec++;
  }

  return rslt;
}


void record_usage(void)
{
  int sockets_connected = 0, sockets_playing = 0;
  struct descriptor_data *d;
  char buf[256];

  for (d = descriptor_list; d; d = d->next) {
    sockets_connected++;
    if (!d->connected)
      sockets_playing++;
  }

  sprintf(buf, "nusage: %-3d sockets connected, %-3d sockets playing",
	  sockets_connected, sockets_playing);
  log(buf);

#ifdef RUSAGE
  {
    struct rusage ru;

    getrusage(0, &ru);
    sprintf(buf, "rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
	    ru.ru_utime.tv_sec, ru.ru_stime.tv_sec, ru.ru_maxrss);
    log(buf);
  }
#endif

}



/*
 * Turn off echoing (specific to telnet client)
 */
void echo_off(struct descriptor_data *d)
{
  char off_string[] =
  {
    (char) IAC,
    (char) WILL,
    (char) TELOPT_ECHO,
    (char) 0,
  };

  SEND_TO_Q(off_string, d);
}


/*
 * Turn on echoing (specific to telnet client)
 */
void echo_on(struct descriptor_data *d)
{
  char on_string[] =
  {
    (char) IAC,
    (char) WONT,
    (char) TELOPT_ECHO,
    (char) TELOPT_NAOFFD,
    (char) TELOPT_NAOCRD,
    (char) 0,
  };

  SEND_TO_Q(on_string, d);
}

  /*
   Thanks to Krimson DIKUMUD for this code.
   currently siteless MUD.
*/
  int is_color(char c) {
    switch (c) {
    case 'x': return 30; break;
    case 'r': return 31; break;
    case 'g': return 32; break;
    case 'y': return 33; break;
    case 'b': return 34; break;
    case 'm': return 35; break;
    case 'c': return 36; break;
    case 'w': return 37; break;


    case '0': return 40; break;
    case '1': return 44; break;
    case '2': return 42; break;
    case '3': return 46; break;
    case '4': return 41; break;
    case '5': return 45; break;
    case '6': return 43; break;
    case '7': return 47; break;

    case 'f': return  1; break;
    case '&': return -1; break;
    default : return  0; break;
    }
  }


  char *interpret_colors(char *str, bool parse) {
    int clr = 37, bg_clr = 40, flash = 0;
    static char cbuf[MAX_STRING_LENGTH];
    char *cp, *tmp;
    char i[256];

    if (!strchr(str, '&'))
      return (str);

    cp = cbuf;

    for (;;) {
      if (*str == '&') {
        str++;
        if ((clr = is_color(LOWER(*str))) > 0 && parse) {
          if (IS_UPPER(*str)) sprintf(i, "\x1b[1;");
          else                sprintf(i, "\x1b[0;");

          if (clr >= 40) {
            bg_clr = 40;
            str++;
            continue;
          } else if (clr == 1) {
            flash = !flash;
            str++;
            continue;
          }

          sprintf(i, "%s%s%d;%dm", i, (flash ? "5;" : ""), bg_clr, clr);
          tmp = i;
        } else if (clr == -1) {
          *(cp++) = '&';
          str++;
          continue;
        } else {
          str++;
          continue;
        }
        while ((*cp = *(tmp++)))
  	cp++;
        str++;
      } else if (!(*(cp++) = *(str++)))
        break;
    }

    *cp = '\0';
    return (cbuf);
  }


  char *prompt_str(struct char_data *ch) {
   struct char_data *vict = FIGHTING(ch);
    static char pbuf[MAX_STRING_LENGTH];
    char *str = GET_PROMPT(ch);
    struct char_data *tank;
    int perc, color;
    char *cp, *tmp;
    char i[256];

    if (!str || !*str)
      str = "&0Hubis MUD&0: Set your prompt (see 'help prompt')>";

    color = (PRF_FLAGGED(ch, PRF_COLOR_1 | PRF_COLOR_2) ? 1 : 0);

    if (!strchr(str, '%'))
      return str;

    cp = pbuf;

    for (;;) {
      if (*str == '%') {
        switch (*(++str)) {
        case 'h':
          sprintf(i, "%d", GET_HIT(ch));
          tmp = i;
          break;
        case 'H':
          sprintf(i, "%d", GET_MAX_HIT(ch));
          tmp = i;
          break;
        case 'm':
          sprintf(i, "%d", GET_MANA(ch));
          tmp = i;
          break;
        case 'M':
          sprintf(i, "%d", GET_MAX_MANA(ch));
          tmp = i;
          break;
        case 'v':
          sprintf(i, "%d", GET_MOVE(ch));
          tmp = i;
          break;
        case 'V':
          sprintf(i, "%d", GET_MAX_MOVE(ch));
          tmp = i;
          break;
        case 'P':
        case 'p':
          str++;
          switch (LOWER(*str)) {
          case 'h':
            perc = (100 * GET_HIT(ch)) / MAX(1, GET_MAX_HIT(ch));
            break;
          case 'm':
            perc = (100 * GET_MANA(ch)) / MAX(1, GET_MAX_MANA(ch));
            break;
          case 'v':
            perc = (100 * GET_MOVE(ch)) / MAX(1, GET_MAX_MOVE(ch));
            break;
          default :
            perc = 0;
            break;
          }
          sprintf(i, "%d%%", perc);
          tmp = i;
          break;
        case 'O':
	case 'o': /* opponent*/
          if (vict) {
            perc = (100*GET_HIT(vict)) / MAX(1, GET_MAX_HIT(vict));
            sprintf(i, "%s &0(%s&0)&0", PERS(vict, ch),
                 (perc >= 100 ? "&2Excellent" :
					 perc >= 88 ? "&3scratches" :
                     perc >= 75 ? "&3&bsmall wounds" :
                     perc >= 50 ? "&5&bfew wounds" :
					 perc >= 30 ? "&5nasty wounds" :
					 perc >= 15 ? "&1&bpretty hurt" :
					 perc >= 0 ? "&1awful condition" : "&1bleeding awfully"));
            tmp = i;
          } else {
            str++;
            continue;
          }
          break;
        case 'g':
          sprintf(i, "%d", GET_GOLD(ch));
          tmp = i;
          break;
        case 'G':
          sprintf(i, "%ld", GET_BANK_GOLD(ch));
          tmp = i;
          break;
        case 'T':
		case 't': /* tank*/
          if (vict && (tank = FIGHTING(vict))) {
            perc = (100*GET_HIT(tank)) / GET_MAX_HIT(tank);
            sprintf(i, "%s &0(&0%s&0)&0", PERS(tank, ch),
				(perc >= 99 ? "&2Excellent" :
					 perc >= 88 ? "&3scratches" :
                     perc >= 75 ? "&3&bsmall wounds" :
                     perc >= 50 ? "&5&bfew wounds" :
					 perc >= 30 ? "&5nasty wounds" :
					 perc >= 15 ? "&1&bpretty hurt" :
					 perc >= 0 ? "&1awful condition" : "&0&1&bbleeding awfully&0"));

			tmp = i;
          } else {
            str++;
            continue;
          }
          break;


        case '_':
          tmp = "\r\n";
          break;
        case '%':
          *(cp++) = '%';
          str++;
          continue;
          break;

        default :
          str++;
          continue;
          break;
        }

        while ((*cp = *(tmp++)))
          cp++;
        str++;
      } else if (!(*(cp++) = *(str++)))
        break;
    }

    *cp = '\0';

    strcat(pbuf, " &0");
    return pbuf;
  }

void make_prompt(struct descriptor_data *d)
{
  char prompt[MAX_INPUT_LENGTH];


    /* reversed these top 2 if checks so that page_string() would work in */
    /* the editor */
    if (d->showstr_count) {
    sprintf(prompt,
	    "\r[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
	    d->showstr_page, d->showstr_count);
    write_to_descriptor(d->descriptor, prompt);
     }
    else if (d->str)
      write_to_descriptor(d->descriptor, "] ");
    else if (!d->connected) {
	  write_to_descriptor(d->descriptor,parse_color(prompt_str(d->character),d));
  /*  char prompt[MAX_INPUT_LENGTH];

    *prompt = '\0';

    if (GET_INVIS_LEV(d->character))
      sprintf(prompt, "i%d ", GET_INVIS_LEV(d->character));

    if (PRF_FLAGGED(d->character, PRF_DISPHP))
      sprintf(prompt, "%s%dH ", prompt, GET_HIT(d->character));

    if (GET_MAX_MANA(tch) != 0)
     if GET_MAX_MANA(tch) > 0)
     if (GET_MANA(tch) > 0)
    if (PRF_FLAGGED(d->character, PRF_DISPMANA))
      sprintf(prompt, "%s%dM ", prompt, GET_MANA(d->character));

    if (PRF_FLAGGED(d->character, PRF_DISPMOVE))
      sprintf(prompt, "%s%dV ", prompt, GET_MOVE(d->character));

    strcat(prompt, "> ");
    write_to_descriptor(d->descriptor, prompt);*/
  }
}


void write_to_q(char *txt, struct txt_q *queue, int aliased)
{
  struct txt_block *new;

  CREATE(new, struct txt_block, 1);
  CREATE(new->text, char, strlen(txt) + 1);
  strcpy(new->text, txt);
  new->aliased = aliased;

  /* queue empty? */
  if (!queue->head) {
    new->next = NULL;
    queue->head = queue->tail = new;
  } else {
    queue->tail->next = new;
    queue->tail = new;
    new->next = NULL;
  }
}



int get_from_q(struct txt_q *queue, char *dest, int *aliased)
{
  struct txt_block *tmp;

  /* queue empty? */
  if (!queue->head)
    return 0;

  tmp = queue->head;
  strcpy(dest, queue->head->text);
  *aliased = queue->head->aliased;
  queue->head = queue->head->next;

  free(tmp->text);
  free(tmp);

  return 1;
}



/* Empty the queues before closing connection */
void flush_queues(struct descriptor_data *d)
{
  int dummy;

  if (d->large_outbuf) {
    d->large_outbuf->next = bufpool;
    bufpool = d->large_outbuf;
  }
  while (get_from_q(&d->input, buf2, &dummy));
}

/* Add a new string to a player's output queue */

void write_to_output(char *txt, struct descriptor_data *t)
{
  int size;
  char *new_txt;

  new_txt = parse_color(txt, t);

  size = strlen(new_txt);

  /* if we're in the overflow state already, ignore this new output */
  if (t->bufptr < 0)
    return;

  /* if we have enough space, just write to buffer and that's it! */
  if (t->bufspace >= size) {
    strcpy(t->output + t->bufptr, new_txt);
    t->bufspace -= size;
    t->bufptr += size;
    free(new_txt);
    return;
  }
  /*
   * If we're already using the large buffer, or if even the large buffer
   * is too small to handle this new text, chuck the text and switch to the
   * overflow state.
   */
  if (t->large_outbuf || ((size + strlen(t->output)) > LARGE_BUFSIZE)) {
    t->bufptr = -1;
    buf_overflows++;
    free(new_txt);
    return;
  }
  buf_switches++;

  /* if the pool has a buffer in it, grab it */
  if (bufpool != NULL) {
    t->large_outbuf = bufpool;
    bufpool = bufpool->next;
  } else {                      /* else create a new one */
    CREATE(t->large_outbuf, struct txt_block, 1);
    CREATE(t->large_outbuf->text, char, LARGE_BUFSIZE);
    buf_largecount++;
  }

  strcpy(t->large_outbuf->text, t->output);     /* copy to big buffer */
  t->output = t->large_outbuf->text;    /* make big buffer primary */
  strcat(t->output, new_txt);   /* now add new text */

  /* calculate how much space is left in the buffer */
  t->bufspace = LARGE_BUFSIZE - 1 - strlen(t->output);

  /* set the pointer for the next write */
  t->bufptr = strlen(t->output);

  free(new_txt);
}



/* ******************************************************************
*  socket handling                                                  *
****************************************************************** */


int new_descriptor(int s) {
  socket_t desc;
  int sockets_connected = 0;
  unsigned long addr;
  int i;
  static int last_desc = 0;	/* last descriptor number */
  struct descriptor_data *newd;
  struct sockaddr_in peer;
  struct hostent *from;
  extern char *ANSI;

  /* accept the new connection */
  i = sizeof(peer);
  if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
    perror("accept");
    return -1;
  }
  /* keep it from blocking */
  nonblock(desc);

  /* make sure we have room for it */
  for (newd = descriptor_list; newd; newd = newd->next)
    sockets_connected++;

  if (sockets_connected >= max_players) {
    write_to_descriptor(desc, "Sorry, Hubis is full right now... please try again later!\r\n");
    CLOSE_SOCKET(desc);
    return 0;
  }
  /* create a new descriptor */
  CREATE(newd, struct descriptor_data, 1);
  memset((char *) newd, 0, sizeof(struct descriptor_data));

  /* find the sitename */
  if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
				      sizeof(peer.sin_addr), AF_INET))) {

    /* resolution failed */
    if (!nameserver_is_slow)
      perror("gethostbyaddr");

    /* find the numeric site address */
    addr = ntohl(peer.sin_addr.s_addr);
    sprintf(newd->host, "%03u.%03u.%03u.%03u", (int) ((addr & 0xFF000000) >> 24),
     (int) ((addr & 0x00FF0000) >> 16), (int) ((addr & 0x0000FF00) >> 8),
	    (int) ((addr & 0x000000FF)));
  } else {
    strncpy(newd->host, from->h_name, HOST_LENGTH);
    *(newd->host + HOST_LENGTH) = '\0';
  }

  /* determine if the site is banned */
  if (isbanned(newd->host) == BAN_ALL) {
    CLOSE_SOCKET(desc);
    sprintf(buf2, "Connection attempt denied from [%s]", newd->host);
    mudlog(buf2, CMP, LVL_GOD, TRUE);
    free(newd);
    return 0;
  }
#if 0
  /* Log new connections - probably unnecessary, but you may want it */
  sprintf(buf2, "New connection from [%s]", newd->host);
  mudlog(buf2, CMP, LVL_GOD, FALSE);
#endif

  /* initialize descriptor data */
  newd->descriptor = desc;
  newd->connected = CON_QANSI;
  newd->idle_tics = 0;
  newd->wait = 1;
  newd->output = newd->small_outbuf;
  newd->bufspace = SMALL_BUFSIZE - 1;
  newd->next = descriptor_list;
  newd->login_time = time(0);

  if (++last_desc == 1000)
    last_desc = 1;
  newd->desc_num = last_desc;

  /* prepend to list */
  descriptor_list = newd;

  SEND_TO_Q(ANSI, newd);

  return 0;
}



int process_output(struct descriptor_data *t)
{
  static char i[LARGE_BUFSIZE + GARBAGE_SPACE];
  static int result;

  /* we may need this \r\n for later -- see below */
  strcpy(i, "\r\n");

  /* now, append the 'real' output */
  strcpy(i + 2, t->output);

  /* if we're in the overflow state, notify the user */
  if (t->bufptr < 0)
    strcat(i, "**OVERFLOW**");

  /* add the extra CRLF if the person isn't in compact mode */
  if (!t->connected && t->character && !PRF_FLAGGED(t->character, PRF_COMPACT))
    strcat(i + 2, "\r\n");

  /*
   * now, send the output.  If this is an 'interruption', use the prepended
   * CRLF, otherwise send the straight output sans CRLF.
   */
  if (!t->prompt_mode)		/* && !t->connected) */
    result = write_to_descriptor(t->descriptor, i);
  else
    result = write_to_descriptor(t->descriptor, i + 2);

  /* handle snooping: prepend "% " and send to snooper */
  if (t->snoop_by) {
    SEND_TO_Q("% ", t->snoop_by);
    SEND_TO_Q(t->output, t->snoop_by);
    SEND_TO_Q("%%", t->snoop_by);
  }
  /*
   * if we were using a large buffer, put the large buffer on the buffer pool
   * and switch back to the small one
   */
  if (t->large_outbuf) {
    t->large_outbuf->next = bufpool;
    bufpool = t->large_outbuf;
    t->large_outbuf = NULL;
    t->output = t->small_outbuf;
  }
  /* reset total bufspace back to that of a small buffer */
  t->bufspace = SMALL_BUFSIZE - 1;
  t->bufptr = 0;
  *(t->output) = '\0';

  return result;
}



int write_to_descriptor(socket_t desc, char *txt)
{
  int total, bytes_written;

  total = strlen(txt);

  do {
#ifdef CIRCLE_WINDOWS
    if ((bytes_written = send(desc, txt, total, 0)) < 0) {
      if (WSAGetLastError() == WSAEWOULDBLOCK)
#else
    if ((bytes_written = write(desc, txt, total)) < 0) {
#ifdef EWOULDBLOCK
      if (errno == EWOULDBLOCK)
	errno = EAGAIN;
#endif /* EWOULDBLOCK */
      if (errno == EAGAIN)
#endif /* CIRCLE_WINDOWS */
	log("process_output: socket write would block, about to close");
      else
	perror("Write to socket");
      return -1;
    } else {
      txt += bytes_written;
      total -= bytes_written;
    }
  } while (total > 0);

  return 0;
}


/*
 * ASSUMPTION: There will be no newlines in the raw input buffer when this
 * function is called.  We must maintain that before returning.
 */
int process_input(struct descriptor_data *t)
{
  int buf_length, bytes_read, space_left, failed_subst;
  char *ptr, *read_point, *write_point, *nl_pos = NULL;
  char tmp[MAX_INPUT_LENGTH + 8];

  /* first, find the point where we left off reading data */
  buf_length = strlen(t->inbuf);
  read_point = t->inbuf + buf_length;
  space_left = MAX_RAW_INPUT_LENGTH - buf_length - 1;

  do {
    if (space_left <= 0) {
      log("process_input: about to close connection: input overflow");
      return -1;
    }
#ifdef CIRCLE_WINDOWS
    if ((bytes_read = recv(t->descriptor, read_point, space_left, 0)) < 0) {
      if (WSAGetLastError() != WSAEWOULDBLOCK) {
#else
    if ((bytes_read = read(t->descriptor, read_point, space_left)) < 0) {
#ifdef EWOULDBLOCK
      if (errno == EWOULDBLOCK)
	errno = EAGAIN;
#endif /* EWOULDBLOCK */
      if (errno != EAGAIN) {
#endif /* CIRCLE_WINDOWS */
	perror("process_input: about to lose connection");
	return -1;		/* some error condition was encountered on
				 * read */
      } else
	return 0;		/* the read would have blocked: just means no
				 * data there but everything's okay */
    } else if (bytes_read == 0) {
      log("EOF on socket read (connection broken by peer)");
      return -1;
    }
    /* at this point, we know we got some data from the read */

    *(read_point + bytes_read) = '\0';	/* terminate the string */

    /* search for a newline in the data we just read */
    for (ptr = read_point; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
	nl_pos = ptr;

    read_point += bytes_read;
    space_left -= bytes_read;

/*
 * on some systems such as AIX, POSIX-standard nonblocking I/O is broken,
 * causing the MUD to hang when it encounters input not terminated by a
 * newline.  This was causing hangs at the Password: prompt, for example.
 * I attempt to compensate by always returning after the _first_ read, instead
 * of looping forever until a read returns -1.  This simulates non-blocking
 * I/O because the result is we never call read unless we know from select()
 * that data is ready (process_input is only called if select indicates that
 * this descriptor is in the read set).  JE 2/23/95.
 */
#if !defined(POSIX_NONBLOCK_BROKEN)
  } while (nl_pos == NULL);
#else
  } while (0);

  if (nl_pos == NULL)
    return 0;
#endif /* POSIX_NONBLOCK_BROKEN */

  /*
   * okay, at this point we have at least one newline in the string; now we
   * can copy the formatted data to a new array for further processing.
   */

  read_point = t->inbuf;

  while (nl_pos != NULL) {
    write_point = tmp;
    space_left = MAX_INPUT_LENGTH - 1;

    for (ptr = read_point; (space_left > 0) && (ptr < nl_pos); ptr++) {
      if (*ptr == '\b') {	/* handle backspacing */
	if (write_point > tmp) {
	  if (*(--write_point) == '$') {
	    write_point--;
	    space_left += 2;
	  } else
	    space_left++;
	}
      } else if (isascii(*ptr) && isprint(*ptr)) {
	if ((*(write_point++) = *ptr) == '$') {		/* copy one character */
	  *(write_point++) = '$';	/* if it's a $, double it */
	  space_left -= 2;
	} else
	  space_left--;
      }
    }

    *write_point = '\0';

    if ((space_left <= 0) && (ptr < nl_pos)) {
      char buffer[MAX_INPUT_LENGTH + 64];

      sprintf(buffer, "Line too long.  Truncated to:\r\n%s\r\n", tmp);
      if (write_to_descriptor(t->descriptor, buffer) < 0)
	return -1;
    }
    if (t->snoop_by) {
      SEND_TO_Q("% ", t->snoop_by);
      SEND_TO_Q(tmp, t->snoop_by);
      SEND_TO_Q("\r\n", t->snoop_by);
    }
    failed_subst = 0;

    if (*tmp == '!')
      strcpy(tmp, t->last_input);
    else if (*tmp == '^') {
      if (!(failed_subst = perform_subst(t, t->last_input, tmp)))
	strcpy(t->last_input, tmp);
    } else
      strcpy(t->last_input, tmp);

    if (!failed_subst)
      write_to_q(tmp, &t->input, 0);

    /* find the end of this line */
    while (ISNEWL(*nl_pos))
      nl_pos++;

    /* see if there's another newline in the input buffer */
    read_point = ptr = nl_pos;
    for (nl_pos = NULL; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
	nl_pos = ptr;
  }

  /* now move the rest of the buffer up to the beginning for the next pass */
  write_point = t->inbuf;
  while (*read_point)
    *(write_point++) = *(read_point++);
  *write_point = '\0';

  return 1;
}



/*
 * perform substitution for the '^..^' csh-esque syntax
 * orig is the orig string (i.e. the one being modified.
 * subst contains the substition string, i.e. "^telm^tell"
 */
int perform_subst(struct descriptor_data *t, char *orig, char *subst)
{
  char new[MAX_INPUT_LENGTH + 5];

  char *first, *second, *strpos;

  /*
   * first is the position of the beginning of the first string (the one
   * to be replaced
   */
  first = subst + 1;

  /* now find the second '^' */
  if (!(second = strchr(first, '^'))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return 1;
  }
  /* terminate "first" at the position of the '^' and make 'second' point
   * to the beginning of the second string */
  *(second++) = '\0';

  /* now, see if the contents of the first string appear in the original */
  if (!(strpos = strstr(orig, first))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return 1;
  }
  /* now, we construct the new string for output. */

  /* first, everything in the original, up to the string to be replaced */
  strncpy(new, orig, (strpos - orig));
  new[(strpos - orig)] = '\0';

  /* now, the replacement string */
  strncat(new, second, (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* now, if there's anything left in the original after the string to
   * replaced, copy that too. */
  if (((strpos - orig) + strlen(first)) < strlen(orig))
    strncat(new, strpos + strlen(first), (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* terminate the string in case of an overflow from strncat */
  new[MAX_INPUT_LENGTH - 1] = '\0';
  strcpy(subst, new);

  return 0;
}



void close_socket(struct descriptor_data *d)
{
  char buf[128];
  struct descriptor_data *temp;
  long target_idnum = -1;

  CLOSE_SOCKET(d->descriptor);
  flush_queues(d);

  /* Forget snooping */
  if (d->snooping)
    d->snooping->snoop_by = NULL;

  if (d->snoop_by) {
    SEND_TO_Q("Your victim is no longer among us.\r\n", d->snoop_by);
    d->snoop_by->snooping = NULL;
  }


  /*. Kill any OLC stuff .*/
  switch(d->connected)
  { case CON_OEDIT:
    case CON_REDIT:
    case CON_ZEDIT:
    case CON_MEDIT:
    case CON_SEDIT:
	case CON_TRIGEDIT:
      cleanup_olc(d, CLEANUP_ALL);
    default:
      break;
  }

  if (d->character) {
    target_idnum = GET_IDNUM(d->character);
    /*
     * Plug memory leak, from Eric Green.
     */
    if (PLR_FLAGGED(d->character, PLR_MAILING) && d->str) {
      if (*(d->str))
        free(*(d->str));
      free(d->str);
    }
    if (d->connected == CON_PLAYING) {
      save_char(d->character, NOWHERE);
      act("$n has lost $s link.", TRUE, d->character, 0, 0, TO_ROOM);
      sprintf(buf, "Closing link to: %s.", GET_NAME(d->character));
      mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
      d->character->desc = NULL;
    } else {/*markquit*/
      sprintf(buf, "Losing player: %s.",
	      GET_NAME(d->character) ? GET_NAME(d->character) : "<null>");
      mudlog(buf, CMP, LVL_IMMORT, TRUE);
      free_char(d->character);
    }
  } else
    mudlog("Losing descriptor without char.", CMP, LVL_IMMORT, TRUE);

  /* JE 2/22/95 -- part of my unending quest to make switch stable */
  if (d->original && d->original->desc)
    d->original->desc = NULL;

  REMOVE_FROM_LIST(d, descriptor_list, next);

  if (d->showstr_head)
    free(d->showstr_head);
  if (d->showstr_count)
    free(d->showstr_vector);
  if (d->storage)
	  free(d->storage);

  free(d);
}



void check_idle_passwords(void)
{
  struct descriptor_data *d, *next_d;

  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME)
      continue;
    if (!d->idle_tics) {
      d->idle_tics++;
      continue;
    } else {
      echo_on(d);
      SEND_TO_Q("\r\nTimed out... goodbye.\r\n", d);
      STATE(d) = CON_CLOSE;
    }
  }
}



/*
 * I tried to universally convert Circle over to POSIX compliance, but
 * alas, some systems are still straggling behind and don't have all the
 * appropriate defines.  In particular, NeXT 2.x defines O_NDELAY but not
 * O_NONBLOCK.  Krusty old NeXT machines!  (Thanks to Michael Jones for
 * this and various other NeXT fixes.)
 */

#ifdef CIRCLE_WINDOWS

void nonblock(socket_t s)
{
  long val;

  val = 1;
  ioctlsocket(s, FIONBIO, &val);
}

#else

#ifndef O_NONBLOCK
#define O_NONBLOCK O_NDELAY
#endif

void nonblock(socket_t s)
{
  int flags;

  flags = fcntl(s, F_GETFL, 0);
  flags |= O_NONBLOCK;
  if (fcntl(s, F_SETFL, flags) < 0) {
    perror("Fatal error executing nonblock (comm.c)");
    exit(1);
  }
}


/* ******************************************************************
*  signal-handling functions (formerly signals.c)                   *
****************************************************************** */


RETSIGTYPE checkpointing()
{
  if (!tics) {
    log("SYSERR: CHECKPOINT shutdown: tics not updated");
    abort();
  } else
    tics = 0;
}


RETSIGTYPE reread_wizlists()
{
  void reboot_wizlists(void);

  mudlog("Signal received - rereading wizlists.", CMP, LVL_IMMORT, TRUE);
  reboot_wizlists();
}


RETSIGTYPE unrestrict_game()
{
  extern struct ban_list_element *ban_list;
  extern int num_invalid;

  mudlog("Received SIGUSR2 - completely unrestricting game (emergent)",
	 BRF, LVL_IMMORT, TRUE);
  ban_list = NULL;
  restrict = 0;
  num_invalid = 0;
}


RETSIGTYPE hupsig()
{
  log("Received SIGHUP, SIGINT, or SIGTERM.  Shutting down...");
  exit(0);			/* perhaps something more elegant should
				 * substituted */
}


/*
 * This is an implementation of signal() using sigaction() for portability.
 * (sigaction() is POSIX; signal() is not.)  Taken from Stevens' _Advanced
 * Programming in the UNIX Environment_.  We are specifying that all system
 * calls _not_ be automatically restarted for uniformity, because BSD systems
 * do not restart select(), even if SA_RESTART is used.
 *
 * Note that NeXT 2.x is not POSIX and does not have sigaction; therefore,
 * I just define it to be the old signal.  If your system doesn't have
 * sigaction either, you can use the same fix.
 *
 * SunOS Release 4.0.2 (sun386) needs this too, according to Tim Aldric.
 */

#ifndef POSIX
#define my_signal(signo, func) signal(signo, func)
#else
sigfunc *my_signal(int signo, sigfunc * func)
{
  struct sigaction act, oact;

  act.sa_handler = func;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
#ifdef SA_INTERRUPT
  act.sa_flags |= SA_INTERRUPT;	/* SunOS */
#endif

  if (sigaction(signo, &act, &oact) < 0)
    return SIG_ERR;

  return oact.sa_handler;
}
#endif				/* NeXT */


void signal_setup(void)
{
#ifndef CIRCLE_OS2
  struct itimerval itime;
#endif
  struct timeval interval;

  /* user signal 1: reread wizlists.  Used by autowiz system. */
  my_signal(SIGUSR1, reread_wizlists);

  /*
   * user signal 2: unrestrict game.  Used for emergencies if you lock
   * yourself out of the MUD somehow.  (Duh...)
   */
  my_signal(SIGUSR2, unrestrict_game);

  /*
   * set up the deadlock-protection so that the MUD aborts itself if it gets
   * caught in an infinite loop for more than 3 minutes.  Doesn't work with
   * OS/2.
   */
#ifndef CIRCLE_OS2
  interval.tv_sec = 180;
  interval.tv_usec = 0;
  itime.it_interval = interval;
  itime.it_value = interval;
  setitimer(ITIMER_VIRTUAL, &itime, NULL);
  my_signal(SIGVTALRM, checkpointing);
#endif

  /* just to be on the safe side: */
  my_signal(SIGHUP, hupsig);
  my_signal(SIGINT, hupsig);
  my_signal(SIGTERM, hupsig);
  my_signal(SIGPIPE, SIG_IGN);
  my_signal(SIGALRM, SIG_IGN);

#ifdef CIRCLE_OS2
#if defined(SIGABRT)
  my_signal(SIGABRT, hupsig);
#endif
#if defined(SIGFPE)
  my_signal(SIGFPE, hupsig);
#endif
#if defined(SIGILL)
  my_signal(SIGILL, hupsig);
#endif
#if defined(SIGSEGV)
  my_signal(SIGSEGV, hupsig);
#endif
#endif				/* CIRCLE_OS2 */

}

#endif				/* CIRCLE_WINDOWS */


/* ****************************************************************
*       Public routines for system-to-player-communication        *
**************************************************************** */

void send_to_char(char *messg, struct char_data *ch)
{
  if (ch->desc && messg)
    SEND_TO_Q(messg, ch->desc);
}

void send_to_zone(char *messg, int zone_rnum)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && i->character && AWAKE(i->character) &&
        (IN_ROOM(i->character) != NOWHERE) &&
(world[IN_ROOM(i->character)].zone == zone_rnum))
      SEND_TO_Q(messg, i);
}


void send_to_all(char *messg)
{
  struct descriptor_data *i;

  if (messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected)
	SEND_TO_Q(messg, i);
}

#define GET_ZONE(ch)  (zone_table[world[IN_ROOM(ch)].zone].number)

void send_to_outdoor(char *messg, int zonenum)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
  {
    if (!i->connected && i->character && AWAKE(i->character) &&
	OUTSIDE(i->character) && (GET_ZONE(i->character) == zonenum) && (STATE(i) == CON_PLAYING))
      SEND_TO_Q(messg, i);
  }
}



void send_to_room(char *messg, int room)
{
  struct char_data *i;

  if (messg)
    for (i = world[room].people; i; i = i->next_in_room)
      if (i->desc)
	SEND_TO_Q(messg, i->desc);
}



char *ACTNULL = "<NULL>";

#define CHECK_NULL(pointer, expression) \
  if ((pointer) == NULL) i = ACTNULL; else i = (expression);


/* higher-level communication: the act() function */
void perform_act(char *orig, struct char_data *ch, struct obj_data *obj,
		 void *vict_obj, struct char_data *to)
{
  register char *i = NULL, *buf;
  static char lbuf[MAX_STRING_LENGTH];
  struct char_data *dg_victim = NULL;
  struct obj_data *dg_target = NULL;
  char *dg_arg = NULL;
  char spare[40];
  int sptr = 0;
  buf = lbuf;


	for (;;)
	{		if (*orig == '&')
		{
			sptr--;
			sptr--;
		}
		sptr++;
		if (*orig == '$')
		{
			switch (*(++orig))
			{
			case 'n':
				if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
				{
					i = "someone";
					break;
				}
				if (IS_NPC(ch))
				{
					i = PERS(ch, to);
/*i = CAP(PERS(ch, to));*/					break;
				}
				if (GET_LEVEL(to) >= LVL_IMMORT)
				{
					i = PERS(ch, to);
					break;
				}	   /*rest of code is mortal only*/
if (GET_RACE_ALIGN(ch) == (GET_RACE_ALIGN(to) & (!PRF_FLAGGED(ch, PRF_NONAME))))
	{
		i = PERS(ch, to);
		if (sptr == 1)
	;/*		i = CAP(i);
	*/}else
	{
	if ((GET_LEVEL(ch) > 70) & ((!PRF_FLAGGED(ch, PRF_NONAME))))
		i = PERS(ch, to);
	else
	{
	if (CAN_SEE(to, ch) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)))
	{
		if (sptr == 1)
		{
			if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
				sprintf(spare, "An %s", RACE_ABBR(ch));
			else
				sprintf(spare, "A %s", RACE_ABBR(ch));
			i = spare;
  		} else {
	if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
		 sprintf(spare, "an %s", RACE_ABBR(ch));
			 else
		sprintf(spare, "a %s", RACE_ABBR(ch));
		i = spare;
 		}
	}
	else
	if ((sptr) == 1)
		i = "Someone";
	else
		i = "someone";
	}
}	  /*i = PERS(ch, to);	*/break;


      case 'N':
if (IS_NPC(to)) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
break;
}
if (IS_NPC((struct char_data *) vict_obj)) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	dg_victim = (struct char_data *) vict_obj;
break;
	  }

if (GET_LEVEL(to) >= LVL_IMMORT) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	dg_victim = (struct char_data *) vict_obj;
break;
}

   /*rest of code is mortal only...Buru!!!*/

if (GET_RACE_ALIGN((struct char_data *) vict_obj) == (GET_RACE_ALIGN(to) &
!PRF_FLAGGED(((struct char_data *) vict_obj), PRF_NONAME))) {
CHECK_NULL(vict_obj, PERS(((struct char_data *) vict_obj), to));
dg_victim = (struct char_data *) vict_obj;
} else {
	if (CAN_SEE(ch, (struct char_data *) vict_obj) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))) {
		if ((sptr) == 1) {
			if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE(to) == RACE_ORC)){
			 sprintf(spare, "An %s", RACE_ABBR((struct char_data *) vict_obj));
			 dg_victim = (struct char_data *) vict_obj;
			}else
			sprintf(spare, "A %s", RACE_ABBR((struct char_data *) vict_obj));
			dg_victim = (struct char_data *) vict_obj;
			i = spare;
		} else {
			if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE((struct char_data *) vict_obj) == RACE_ORC)){
			 sprintf(spare, "an %s", RACE_ABBR((struct char_data *) vict_obj));
			 dg_victim = (struct char_data *) vict_obj;
			}else
			sprintf(spare, "a %s", RACE_ABBR((struct char_data *) vict_obj));
			dg_victim = (struct char_data *) vict_obj;
			i = spare;
		}
	}
	else
		i = "someone";
}
	  /*	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	*/break;
      case 'm':
	i = HMHR(ch);
	break;
      case 'M':
	CHECK_NULL(vict_obj, HMHR((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 's':
	i = HSHR(ch);
	break;
      case 'S':
	CHECK_NULL(vict_obj, HSHR((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 'e':
	i = HSSH(ch);
	break;
      case 'E':
	CHECK_NULL(vict_obj, HSSH((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 'o':
	CHECK_NULL(obj, OBJN(obj, to));
	break;
      case 'O':
	CHECK_NULL(vict_obj, OBJN((struct obj_data *) vict_obj, to));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'p':
	CHECK_NULL(obj, OBJS(obj, to));
	break;
      case 'P':
	CHECK_NULL(vict_obj, OBJS((struct obj_data *) vict_obj, to));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'a':
	CHECK_NULL(obj, SANA(obj));
	break;
      case 'A':
	CHECK_NULL(vict_obj, SANA((struct obj_data *) vict_obj));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'T':
	CHECK_NULL(vict_obj, (char *) vict_obj);
	dg_arg = (char *) vict_obj;
	break;
      case 'F':
	CHECK_NULL(vict_obj, fname((char *) vict_obj));
	break;
      case '$':
	i = "$";
	break;
      default:
	log("SYSERR: Illegal $-code to act():");
	strcpy(buf1, "SYSERR: ");
	strcat(buf1, orig);
	log(buf1);
	break;
      }
	  while ((*buf = *(i++)))
	buf++;
      orig++;
    } else if (!(*(buf++) = *(orig++)))
      break;
  }

  *(--buf) = '\r';
  *(++buf) = '\n';
  *(++buf) = '\0';

  if (to->desc){
   SEND_TO_Q("&0", to->desc);
   SEND_TO_Q(CAP(lbuf), to->desc);
  }
  if ((IS_NPC(to) && dg_act_check) && (to != ch))
    act_mtrigger(to, lbuf, ch, dg_victim, obj, dg_target, dg_arg);
  if (MOBTrigger)
    mprog_act_trigger(lbuf, to, ch, obj, vict_obj);
}

#ifndef SENDOK
#define SENDOK(ch) ((ch)->desc && (AWAKE(ch) || sleep) && \
		    !PLR_FLAGGED((ch), PLR_WRITING))
#endif
void act(char *str, int hide_invisible, struct char_data *ch,
	 struct obj_data *obj, void *vict_obj, int type)
{
  struct char_data *to = NULL;
  static int sleep;

 if (!str) {
     MOBTrigger = TRUE;
    return;
  }


  if (!(dg_act_check = !(type & DG_NO_TRIG)))
    type &= ~DG_NO_TRIG;

  /*
   * Warning: the following TO_SLEEP code is a hack.
   *
   * I wanted to be able to tell act to deliver a message regardless of sleep
   * without adding an additional argument.  TO_SLEEP is 128 (a single bit
   * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
   * command.  It's not legal to combine TO_x's with each other otherwise.
   */

  /* check if TO_SLEEP is there, and remove it if it is. */
  if ((sleep = (type & TO_SLEEP)))
    type &= ~TO_SLEEP;


  if (type == TO_CHAR) {
    if (ch && SENDOK(ch))
      perform_act(str, ch, obj, vict_obj, ch);
	MOBTrigger = TRUE;
    return;
  }
  if (type == TO_VICT) {
    if ((to = (struct char_data *) vict_obj) && SENDOK(to))
  //  if (to == NULL)
  //  return;
  //  if (!to)
  //  return;  /* if a tree falls in the forest... Banyal cut on some bandwidth */
  //  /* and lets kill soem bugs while we here Banyal*/
  // if (to->desc && (IS_NPC(to) || !to->player_specials->ignored ||
 // (to->player_specials->ignored != ch)) && ((to != ch)))
     perform_act(str, ch, obj, vict_obj, to);
	MOBTrigger = TRUE;
    return;

  }
  /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */

   if ((ch))
   {
      if ((ch->in_room != NOWHERE))
         to = world[ch->in_room].people;
      else
         log("SYSERR: no valid target to act()!");
   }
   else if ((obj != NULL))
   {
      if ((obj->in_room != NOWHERE))
      {
         if ((obj->in_room) != 0)
            to = world[obj->in_room].people;
         else
         {
            log("SYSERR: no valid target to act()!");
            sprintf(buf, "Error in ACT, obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
            mudlog(buf, CMP, LVL_GOD, FALSE);
            return;
         }
      }
      else
      {/*if here then NO ch and NO obj ==>error*/
         log("SYSERR: no valid target to act()!");
         sprintf(buf, "Error in ACT, obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
         mudlog(buf, CMP, LVL_GOD, FALSE);
         return;
      }
   }
   else
   {
      log("SYSERR: no valid target to act()!");
      return;
   }

  for (; to; to = to->next_in_room)
    if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
	(to != ch) && (type == TO_ROOM || (to != vict_obj)))
      perform_act(str, ch, obj, vict_obj, to);
  MOBTrigger = TRUE;
}


int count_chars(char *txt, char character)
{
   int i, cnt = 0;

   for(i = 0; txt[i]; i++)
      if(txt[i] == character)
         cnt++;

   return cnt;
}

char *parse_color(char *txt, struct descriptor_data *t)
{
   char *new_txt;
   char *toret;
   register int i, j = 0;

   i = count_chars(txt, '&'); /* count how many control-chars there
                                 are in the string */


   new_txt = malloc(i * 5 + strlen(txt) + 5); /* no ansi-escape code is larger
                                                 than 5 bytes so a 5 * times
                                                 the '&' appears + strlen(txt)
                                                 + 1 character big buffer
                                                 should be enough */
   /* This fixes that ANNOYING color bleeding from prompt! -Nechtrous */
   if(t->character) {
     strcpy(new_txt + j, CCNRM(t->character, C_NRM));
     if(clr(t->character, C_NRM))
       j += 4;
   }
   /* the parser.. Huge but fast */
   for(i = 0; txt[i]; i++)
   {
      if(txt[i] == '&')
      {
         i++;
         if(!(t->character)) {
            new_txt[j] = txt[i]; j++;
 	 }
         else
         switch(txt[i])
         {
            case '0' : strcpy(new_txt + j, CCNRM(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case '1' : strcpy(new_txt + j, CCRED(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '2' : strcpy(new_txt + j, CCGRN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '3' : strcpy(new_txt + j, CCYEL(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '4' : strcpy(new_txt + j, CCBLU(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '5' : strcpy(new_txt + j, CCMAG(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '6' : strcpy(new_txt + j, CCCYN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '7' : strcpy(new_txt + j, CCWHT(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '8' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case '9' : strcpy(new_txt + j, CCBLK(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'u' : strcpy(new_txt + j, CCUND(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case 'd' : strcpy(new_txt + j, CCDAR(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case 'b' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;

            case 'R' : strcpy(new_txt + j, CCBRED(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'G' : strcpy(new_txt + j, CCBGRN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'Y' : strcpy(new_txt + j, CCBYEL(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'B' : strcpy(new_txt + j, CCBBLU(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'M' : strcpy(new_txt + j, CCBMAG(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'C' : strcpy(new_txt + j, CCBCYN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'W' : strcpy(new_txt + j, CCBWHT(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'S' : strcpy(new_txt + j, CCBBLK(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '&' : new_txt[j] = txt[i]; j++; break;

            default:  break;
         }

      }
      else
      {
         new_txt[j] = txt[i]; j++;
      }
   }

   new_txt[j] = '\0'; /* terminate the string */
   toret = strdup(new_txt); /* create a new string with no eventual memoryloss */
   free(new_txt); /* free the old buffer */

   return toret; /* the colorized buffer */
}

/*  This function scans every room of the mud and checks for IN_FLIGHT */
/*  once IN_FLIGHT rooms are found, every non flying obj, PC, NPC */
/*  falls to the earth and takes damage according to size and number */
/*  of rooms fallen.   */

/*  --Fingon */


void do_gravity_check(void)
{
  struct obj_data *i, *j;
  struct char_data *ch;
  int was_in, zn, rn, rrn, k;
  int riding = FALSE, ridden_by = FALSE, flying = FALSE;
  char gravbuf[MAX_STRING_LENGTH];

  /*  Cycle through each zone */

  for (zn = 0; zn <= top_of_zone_table; zn++) {
    if (zone_table[zn].top) {

      /*  Cycle through each room in zone */

      for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) {
	if (real_room(rn) != NOWHERE) {
	  rrn = real_room(rn);
          if (world[rrn].sector_type == SECT_FLYING) {

	    /*  start the gravity check for objects */

	    i = world[rrn].contents;
            while(i) {

	      /*  check each object */

	      if ((j=i->next_content)) {
                if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
                  (strcmp(j->description,i->description)==0)) ||
                  ((j->item_number==i->item_number) && (i->item_number!=NOTHING))) {
                  i = j;
                  continue;
                }
              }
	      while (SECT(i->in_room) == SECT_FLYING &&
                     !IS_OBJ_SPELL_AFF(i, ITEM_FLY) &&
                      i->obj_flags.type_flag != ITEM_PORTAL) {

		/*  make it fall */

	    	was_in = i->in_room;

		/*  display to people in room object is falling from */

                for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
		  if (CAN_SEE_OBJ(ch, i)) {
   		    sprintf(gravbuf, "%s &1&bplummets&0 &2downward!&0\n", i->short_description);
		    send_to_char(gravbuf, ch);
		  } else {
                    sprintf(gravbuf, "Something &1&bwhizzes&0 &2downward!&0\n");
                    send_to_char(gravbuf, ch);
                  }
                }
		obj_from_room(i);
		obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);

		/*  display to people in room object is falling through/to */

                for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
                  if (CAN_SEE_OBJ(ch, i)) {
  	  	    sprintf(gravbuf, "&1&b%s falls from above.&0\n", i->short_description);
                    send_to_char(gravbuf, ch);
                  } else {
                    sprintf(gravbuf, "&1&bSomething whizzes past you.&0\n");
                    send_to_char(gravbuf, ch);
                  }
                }

		/*  time to land */

                if (SECT(i->in_room) != SECT_FLYING) {
                  for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
                    if (CAN_SEE_OBJ(ch, i)) {
    	              sprintf(gravbuf, "&1&b%s lands with a dull&0 &1THUD!&0\n", i->short_description);
                      send_to_char(gravbuf, ch);
                    } else {
                      sprintf(gravbuf, "&1&bSomething lands with a dull&0 &1THUD!&0\n");
                      send_to_char(gravbuf, ch);
                    }
                  }
                }
              }
	      i = i->next_content;
	    }

	    /*  end of object gravity check */
	    /*  start the gravity check for players/mobs  */
	    /*  check each ch */

	    for (ch = world[rrn].people; ch != NULL; ch = ch->next_in_room) {
	      k = 0;
	      flying = 0;
	      riding = 0;
	      ridden_by = 0;

	      if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;

	      /* If either mount or mountee is flying then don't fall */
	      /* otherwise unmount and prepare to fall... */

	      if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING) {
		riding = 1;
		if (IS_AFFECTED(RIDING(ch), AFF_FLYING)) {
		  flying = 1;
		}
	      }
	      if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) {
		ridden_by = 1;
		if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) {
		  flying = 1;
		}
	      }
	      if (riding && !flying) dismount_char(ch);
	      if (ridden_by && !flying) dismount_char(RIDDEN_BY(ch));

	      /* Make them fall */

	      while (SECT(ch->in_room) == SECT_FLYING && !IS_AFFECTED(ch, AFF_FLYING) && !flying) {
		k++;

		was_in = ch->in_room;

		/*  Message to room fall started in */

		if (k == 1) {
		  send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch);
		  act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0", FALSE, ch, 0, 0, TO_ROOM);
		}

		char_from_room(ch);
		char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
		if (ch->desc != NULL)
		  look_at_room(ch, 0);

		/*  Message to rooms falling through */

		send_to_char("&2DOWN!&0\r\n", ch);
		act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);

		if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
		  do_falling_damage(ch, k);
		}
	      }
	    }




          }
	}
      }
    }
  }
  return;
}


void do_falling_damage(struct char_data *ch, float dist_fell)
{
  send_to_char("You land with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", ch);
  act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
  GET_POS(ch) = POS_SITTING;
  GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
  update_pos(ch);
  switch (GET_POS(ch)) {
  case POS_MORTALLYW:
    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
    break;
  case POS_INCAP:
    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    break;
  case POS_STUNNED:
    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    break;
  case POS_DEAD:
    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You are dead!  Sorry...\r\n", ch);
    sprintf(buf2, "%s killed by falling at %s", GET_NAME(ch), world[ch->in_room].name);
    mudlog(buf2, BRF, 0, TRUE);
    die(ch, ch);
    break;
  default:
  }
}
@


1.183
log
@Remove reference to 'ships' for memtest build.
@
text
@/***************************************************************************
 * $Id: comm.c,v 1.182 2011/08/18 00:13:14 myc Exp fierymud $
 ***************************************************************************/
/***************************************************************************
 *   File: comm.c                                         Part of FieryMUD *
 *  Usage: Communication, socket handling, main(), central game loop       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#define __COMM_C__
/* if yer really hard core....
#define __STRICT_ANSI__
*/
#include "conf.h"
#include "sysdep.h"


#ifdef CIRCLE_WINDOWS                /* Includes for Win32 */
#include <direct.h>
#include <mmsystem.h>
#else                                /* Includes for UNIX */
#include <sys/socket.h>
#include <sys/resource.h>
#include <netinet/in.h>
#include <netdb.h>
#include <signal.h>
#endif

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "house.h"
#include "screen.h"
#include "olc.h"
#include "events.h"
#include "dg_scripts.h"
#include "weather.h"
#include "casting.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "board.h"
#include "clan.h"
#include "mail.h"
#include "players.h"
#include "pfiles.h"
#include "races.h"
#include "exits.h"
#include "cooldowns.h"
#include "fight.h"
#include "commands.h"
#include "modify.h"
#include "act.h"
#include "editor.h"
#include "directions.h"
#include "effects.h"
#include "rules.h"

#ifdef HAVE_ARPA_TELNET_H
#include <arpa/telnet.h>
#else
#include "telnet.h"
#endif

#ifndef INVALID_SOCKET
#define INVALID_SOCKET -1
#endif

#define YES        1
#define NO        0


/* externs */
extern int restrict;
extern int restrict_reason;
extern int mini_mud;
extern int DFLT_PORT;
extern char *DFLT_DIR;
extern int MAX_PLAYERS;
extern int MAX_DESCRIPTORS_AVAILABLE;

extern const char *save_info_msg[];        /* In olc.c */
ACMD(do_shapechange);

extern int num_hotboots;
extern int reboot_auto;
extern pulse_t reboot_pulse;
extern unsigned int reboot_warning_minutes;
extern int last_reboot_warning;
extern int reboot_warning;

/* local globals */
static char comm_buf[MAX_STRING_LENGTH];
struct descriptor_data *descriptor_list = NULL;                /* master desc list */
struct txt_block *bufpool = 0;        /* pool of large output buffers */
int buf_largecount = 0;                /* # of large buffers which exist */
int buf_overflows = 0;                /* # of overflows of output */
int buf_switches = 0;                /* # of switches from small to large buf */
int circle_shutdown = 0;        /* clean shutdown */
int circle_reboot = 0;                /* reboot the game after a shutdown */
int no_specials = 0;                /* Suppress ass. of special routines */
int max_players = 0;                /* max descriptors available */
int tics = 0;                        /* for extern checkpointing */
int scheck = 0;                        /* for syntax checking mode */
int dg_act_check;               /* toggle for act_trigger */
pulse_t global_pulse = 0; /* number of pulses since game start */
extern int nameserver_is_slow;        /* see config.c */
struct timeval null_time;        /* zero-valued time structure */
pulse_t pulse = 0;        /* number of pulses since game started */
int gossip_channel_active = 1;        /* Flag for turning on or off gossip for the whole MUD */

ush_int port;
socket_t mother_desc;

/* functions in this file */
int get_from_q(struct txt_q *queue, char *dest, int *aliased);
void init_game(int port);
void signal_setup(void);
void game_loop(int mother_desc);
int init_socket(int port);
int new_descriptor(int s);
int get_max_players(void);
int process_output(struct descriptor_data *t);
int process_input(struct descriptor_data *t);
void close_socket(struct descriptor_data *d);
struct timeval timediff(struct timeval a, struct timeval b);
struct timeval timeadd(struct timeval a, struct timeval b);
void flush_queues(struct descriptor_data *d);
void nonblock(socket_t s);
int perform_subst(struct descriptor_data *t, char *orig, char *subst);
int perform_alias(struct descriptor_data *d, char *orig);
void record_usage(void);
void make_prompt(struct descriptor_data *point);
void check_idle_passwords(void);
void heartbeat(pulse_t pulse);
char *new_txt;
void init_descriptor(struct descriptor_data *newd, int desc);
int enter_player_game(struct descriptor_data *d);
void free_bufpools(void);


/* extern fcnts */
void boot_db(void);
void boot_world(void);
void zone_update(void);
void effect_update(void);        /* In spells.c */
void point_update(void);        /* In limits.c */
void mobile_activity(void);
void mobile_spec_activity(void);
void string_add(struct descriptor_data *d, char *str);
void perform_mob_violence(void);
int isbanned(char *hostname);
void redit_save_to_disk(int zone_num);
void oedit_save_to_disk(int zone_num);
void medit_save_to_disk(int zone_num);
void sedit_save_to_disk(int zone_num);
void zedit_save_to_disk(int zone_num);
void ispell_init(void);
void ispell_done(void);
void free_help_table(void);
void free_social_messages(void);
void free_social_messages(void);
void free_invalid_list(void);


/**********************************************************************
 *  main game loop and related stuff                                    *
 ********************************************************************* */

/* Windows doesn't have gettimeofday, so we'll simulate it. */
#ifdef CIRCLE_WINDOWS

void gettimeofday(struct timeval *t, struct timezone *dummy)
{
  DWORD millisec = GetTickCount();

  t->tv_sec = (int) (millisec / 1000);
  t->tv_usec = (millisec % 1000) * 1000;
}

#endif


int main(int argc, char **argv)
{
  int pos = 1;
  char *dir;

#ifdef MEMORY_DEBUG
  zmalloc_init();
#endif

  port = DFLT_PORT;
  dir = DFLT_DIR;

  while ((pos < argc) && (*(argv[pos]) == '-')) {
    switch (*(argv[pos] + 1)) {
    case 'd':
      if (*(argv[pos] + 2))
        dir = argv[pos] + 2;
      else if (++pos < argc)
        dir = argv[pos];
      else {
        log("Directory arg expected after option -d.");
        exit(1);
      }
      break;
    case 'H': /* -H<socket number> recover from hotbot, this is the control socket */
      num_hotboots = 1;
      mother_desc = atoi(argv[pos]+2);
      break;
    case 'm':
      mini_mud = 1;
      log("Running in minimized mode.");
      break;
    case 'c':
      scheck = 1;
      log("Syntax check mode enabled.");
      break;
    case 'q':
      log("Quick boot mode.");
      break;
    case 'r':
      restrict = 1;
      restrict_reason = RESTRICT_ARGUMENT;
      log("Restricting game -- no new players allowed.");
      break;
    case 's':
      no_specials = 1;
      log("Suppressing assignment of special routines.");
      break;
    default:
      log("SYSERR: Unknown option -%c in argument string.", *(argv[pos] + 1));
      break;
    }
    pos++;
  }

  if (pos < argc) {
    if (!isdigit(*argv[pos])) {
      fprintf(stderr, "Usage: %s [-c] [-m] [-q] [-r] [-s] [-d pathname] [port #]\n", argv[0]);
      exit(1);
    } else if ((port = atoi(argv[pos])) <= 1024) {
      fprintf(stderr, "Illegal port number.\n");
      exit(1);
    }
  }
#ifdef CIRCLE_WINDOWS
  if (_chdir(dir) < 0) {
#else
  if (chdir(dir) < 0) {
#endif
    perror("Fatal error changing to data directory");
    exit(1);
  }
  log("Using %s as data directory.", dir);

  log("Initializing runtime game constants.");
  init_flagvectors();
  init_rules();
  init_colors();
  init_races();
  init_classes();
  init_objtypes();
  init_exp_table();

  if (scheck) {
    boot_world();
  } else {
    log("Running game on port %d.", port);
    init_game(port);
  }

  log("Clearing game world.");
  destroy_db();

#ifdef MEMORY_DEBUG
  if (!scheck) {
    log("Clearing other memory.");
    free_bufpools();                /* comm.c */
    free_player_index();        /* db.c */
    free_messages();                /* fight.c */
    free_text_files();                /* db.c */
    board_cleanup();                  /* board.c */
    free(cmd_sort_info);
    free_social_messages();        /* act.social.c */
    free_help_table();                /* db.c */
    free_invalid_list();        /* ban.c */
    free_save_list();                /* olc.c */
    free_clans();                /* clan.c */
    free_mail_index();                /* mail.c */
  }

  zmalloc_check();
#endif

  return 0;
}

void hotboot_recover()
{
  struct descriptor_data *d;
  FILE *fp;
  char host[1024];
  int desc, player_i;
  bool fOld;
  char name[MAX_INPUT_LENGTH];
  int count;
  char *p;

  extern time_t *boot_time;

  log("Hotboot recovery initiated.");

  fp = fopen(HOTBOOT_FILE, "r");
  /* There are some descriptors open which will hang forever then? */
  if (!fp) {
    perror("hotboot_recover:fopen");
    log("Hotboot file not found.  Exiting.\r\n");
    exit(1);
  }

  /* In case something crashes - doesn't prevent reading */
  unlink(HOTBOOT_FILE);

  /* read boot_time - first line in file */
  if (boot_time)
    free(boot_time);
  fgets(p = buf, MAX_STRING_LENGTH, fp);
  p = any_one_arg(p, name);
  num_hotboots = atoi(name); /* actually the total number of boots */
  CREATE(boot_time, time_t, num_hotboots + 1);
  for (count = 0; count < num_hotboots; ++count) {
    p = any_one_arg(p, name);
    boot_time[count] = atol(name);
  }
  boot_time[num_hotboots] = time(0);

  /* More than 1000 iterations means something is pretty wrong. */
  for (count = 0; count <= 1000; ++count) {
    fOld = TRUE;
    fscanf(fp, "%d %s %s\n", &desc, name, host);
    if (desc == -1)
      break;

    /* Write something, and check if it goes error-free */
    if (write_to_descriptor(desc, "\r\nRestoring from hotboot...\r\n") < 0) {
      close(desc); /* nope */
      continue;
    }

    /* Create a new descriptor */
    CREATE(d, struct descriptor_data, 1);
    memset((char *) d, 0, sizeof(struct descriptor_data));
    init_descriptor(d, desc); /* set up various stuff */

    strcpy(d->host, host);
    d->next = descriptor_list;
    descriptor_list = d;

    d->connected = CON_CLOSE;

    CREATE(d->character, struct char_data, 1);
    clear_char(d->character);
    CREATE(d->character->player_specials, struct player_special_data, 1);
    d->character->desc = d;

    if ((player_i = load_player(name, d->character)) >= 0) {
      if (!PLR_FLAGGED(d->character, PLR_DELETED)) {
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_WRITING);
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_MAILING);
      }
      else
        fOld = FALSE;
    }
    else
      fOld = FALSE;

    if (!fOld) {
      write_to_descriptor(desc, "\r\nSomehow, your character was lost in the hotboot.  Sorry.\r\n");
      close_socket(d);
    }
    else {
      sprintf(buf, "\r\n%sHotboot recovery complete.%s\r\n",
              CLR(d->character, HGRN), CLR(d->character, ANRM));
      write_to_descriptor(desc, buf);
      enter_player_game(d);
      d->connected = CON_PLAYING;
      look_at_room(d->character, FALSE);
    }
  }

  fclose(fp);
}

/* Init sockets, run game, and cleanup sockets */
void init_game(int port)
{
  extern pulse_t reboot_pulse;
  extern int reboot_hours_base;
  extern int reboot_hours_deviation;

  srandom(time(0));

  log("Finding player limit.");
  max_players = get_max_players();

  if (num_hotboots == 0) {
    log("Opening mother connection.");
    mother_desc = init_socket(port);
  }

  event_init();

  boot_db();

#ifndef CIRCLE_WINDOWS
  log("Signal trapping.");
  signal_setup();
#endif

  /* Decide when to reboot */
  reboot_pulse = 3600 * PASSES_PER_SEC *
          (reboot_hours_base - reboot_hours_deviation) +
          number(0, 3600 * PASSES_PER_SEC * 2 * reboot_hours_deviation);

  if (num_hotboots > 0)
    hotboot_recover();

  log("Entering game loop.");

#ifndef CIRCLE_WINDOWS
  ispell_init();
#endif

  game_loop(mother_desc);

  auto_save_all();

#ifndef CIRCLE_WINDOWS
  ispell_done();
#endif

  log("Closing all sockets.");
  while (descriptor_list)
    close_socket(descriptor_list);

  CLOSE_SOCKET(mother_desc);

  if (circle_reboot != 2 && olc_save_list) { /* Don't save zones. */
    struct olc_save_info *entry, *next_entry;
    for (entry = olc_save_list; entry; entry = next_entry) {
      next_entry = entry->next;
      if (entry->type < 0 || entry->type > 4) {
        log("OLC: Illegal save type %d!", entry->type);
      } else if (entry->zone < 0) {
        log("OLC: Illegal save zone %d!", entry->zone);
      } else {
        log("OLC: Reboot saving %s for zone %d.",
            save_info_msg[(int)entry->type], entry->zone);
        switch (entry->type) {
          case OLC_SAVE_ROOM: redit_save_to_disk(entry->zone); break;
          case OLC_SAVE_OBJ:  oedit_save_to_disk(entry->zone); break;
          case OLC_SAVE_MOB:  medit_save_to_disk(entry->zone); break;
          case OLC_SAVE_ZONE: zedit_save_to_disk(entry->zone); break;
          case OLC_SAVE_SHOP: sedit_save_to_disk(entry->zone); break;
          default:      log("Unexpected olc_save_list->type"); break;
        }
      }
    }
  }

  if (circle_reboot)
    log("Rebooting.");
  else
    log("Normal termination of game.");
}



/*
 * init_socket sets up the mother descriptor - creates the socket, sets
 * its options up, binds it, and listens.
 */
int init_socket(int port)
{
  int s, opt;
  struct sockaddr_in sa;

  /*
   * Should the first argument to socket() be AF_INET or PF_INET?  I don't
   * know, take your pick.  PF_INET seems to be more widely adopted, and
   * Comer (_Internetworking with TCP/IP_) even makes a point to say that
   * people erroneously use AF_INET with socket() when they should be using
   * PF_INET.  However, the man pages of some systems indicate that AF_INET
   * is correct; some such as ConvexOS even say that you can use either one.
   * All implementations I've seen define AF_INET and PF_INET to be the same
   * number anyway, so ths point is (hopefully) moot.
   */

#ifdef CIRCLE_WINDOWS
  {
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);

    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
      log("WinSock not available!\n");
      exit(1);
    }
    if ((wsaData.iMaxSockets - 4) < max_players) {
      max_players = wsaData.iMaxSockets - 4;
    }
    log("Max players set to %d", max_players);

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {
      fprintf(stderr, "Error opening network connection: Winsock err #%d\n", WSAGetLastError());
      exit(1);
    }
  }
#else
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Error creating socket");
    exit(1);
  }
#endif                                /* CIRCLE_WINDOWS */

#if defined(SO_SNDBUF)
  opt = LARGE_BUFSIZE + GARBAGE_SPACE;
  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt SNDBUF");
    exit(1);
  }
#endif

#if defined(SO_REUSEADDR)
  opt = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt REUSEADDR");
    exit(1);
  }
#endif

#if defined(SO_LINGER)
  {
    struct linger ld;

    ld.l_onoff = 0;
    ld.l_linger = 0;
    if (setsockopt(s, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld)) < 0) {
      perror("setsockopt LINGER");
      exit(1);
    }
  }
#endif

  sa.sin_family = AF_INET;
  sa.sin_port = htons(port);
  sa.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    perror("bind");
    CLOSE_SOCKET(s);
    exit(1);
  }
  nonblock(s);
  listen(s, 5);
  return s;
}


int get_max_players(void)
{
  int max_descs = 0;
  char *method;

#if defined(CIRCLE_OS2) || defined(CIRCLE_WINDOWS)
  return MAX_PLAYERS;
#else

  /*
   * First, we'll try using getrlimit/setrlimit.  This will probably work
   * on most systems.
   */
#if defined (RLIMIT_NOFILE) || defined (RLIMIT_OFILE)
#if !defined(RLIMIT_NOFILE)
#define RLIMIT_NOFILE RLIMIT_OFILE
#endif
  {
    struct rlimit limit;

    /* find the limit of file descs */
    method = "rlimit";
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling getrlimit");
      exit(1);
    }
    /* set the current to the maximum */
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling setrlimit");
      exit(1);
    }
#ifdef RLIM_INFINITY
    if (limit.rlim_max == RLIM_INFINITY)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else
      max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#else
    max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#endif
  }

#elif defined (OPEN_MAX) || defined(FOPEN_MAX)
#if !defined(OPEN_MAX)
#define OPEN_MAX FOPEN_MAX
#endif
  method = "OPEN_MAX";
  max_descs = OPEN_MAX;         /* Uh oh.. rlimit didn't work, but we
                                 * have OPEN_MAX */
#elif defined (POSIX)
  /*
   * Okay, you don't have getrlimit() and you don't have OPEN_MAX.  Time to
   * use the POSIX sysconf() function.  (See Stevens' _Advanced Programming
   * in the UNIX Environment_).
   */
  method = "POSIX sysconf";
  errno = 0;
  if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
    if (errno == 0)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else {
      perror("Error calling sysconf");
      exit(1);
    }
  }
#else
  /* if everything has failed, we'll just take a guess */
  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
#endif

  /* now calculate max _players_ based on max descs */
  max_descs = MIN(MAX_PLAYERS, max_descs - NUM_RESERVED_DESCS);

  if (max_descs <= 0) {
    log("Non-positive max player limit!  (Set at %d using %s).",
            max_descs, method);
    exit(1);
  }
  log("Setting player limit to %d using %s.", max_descs, method);
  return max_descs;
#endif                                /* WINDOWS or OS2 */
}

void reboot_mud_prep()
{
  /*do global save*/
  auto_save_all();
  House_save_all();
  all_printf("Rebooting.. come back in a minute or two.\r\n"
             "           &1&b** ****** ****&0\r\n"
             "         &1&b**&0 &3&b***     *****&0  &1&b**&0\r\n"
             "       &1&b**&0 &3&b**      &1&b*&0     &3&b***&0  &1&b*&0\r\n"
             "       &1&b*&0    &3&b** **   *   *  *&0 &1&b**&0\r\n"
             "      &1&b*&0  &3&b** * *&0          &1&b*&0     &1&b*&0\r\n"
             "      &1&b*&0  &3&b*&0    &1&b**&0            &3&b* *&0 &1&b*&0\r\n"
             "     &1&b*&0 &3&b* &1&b** *&0     &3&b*   ******&0  &1&b*&0\r\n"
             "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n");
  all_printf("        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
             "         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
             "                &1&b*&0   &3&b*&0 &1&b*&0\r\n"
             "               &1&b*&0  &3&b* *&0  &1&b*&0\r\n"
             "              &1&b*&0  &3&b*  **&0  &1&b*&0\r\n"
             "              &1&b*&0 &3&b**   *&0 &1&b*&0\r\n"
             "                &1&b*&0 &3&b*&0 &1&b*&0\r\n"
             "                &1&b*&0 &3&b*&0  &1&b**&0\r\n"
             "               &1&b**&0     &1&b****&0\r\n"
             "              &1&b***&0  &3&b* *&0    &1&b****&0\r\n");
  touch("../.fastboot");
}

/* This will generally be called upon login, to let people know
 * immediately if a reboot is coming up.  It could be especially useful
 * to a god, if they log in and see "15 seconds to reboot", because
 * it would give them time to abort the reboot if they so desire. */
void personal_reboot_warning(struct char_data *ch)
{
   int minutes_till, seconds_till;

   if ((reboot_pulse - global_pulse) / (PASSES_PER_SEC * 60) < reboot_warning_minutes) {
      minutes_till = (reboot_pulse - global_pulse - 1) / (PASSES_PER_SEC * 60) + 1;
      if (minutes_till == 1) {
         seconds_till = (reboot_pulse - global_pulse) / PASSES_PER_SEC;
         cprintf(ch, "\r\n\007&4&b***&0 &7&b%d second%s to reboot&0 &4&b***&0\r\n",
               seconds_till, seconds_till == 1 ? "" : "s");
      } else {
         cprintf(ch, "\r\n\007&1&b*&3&bATTENTION&1&b*&0  The mud will &7&bREBOOT&0 in &6&b%d minute%s&0  &1&b*&3&bATTENTION&1&b*&0\r\n",
               minutes_till, minutes_till == 1 ? "" : "s");
      }
   }
}

void rebootwarning(int minutes)
{
   all_printf("&1&b*&3&bATTENTION&1&b*&0  The mud will &7&bREBOOT&0 in &6&b%d minute%s&0  &1&b*&3&bATTENTION&1&b*&0\r\n",
         minutes, minutes == 1 ? "" : "s");
}

void cancel_auto_reboot(int postponed)
{
   if (!reboot_warning) return;

   reboot_warning = 0;
   if (postponed)
      all_printf("&6*** Automatic Reboot Postponed ***&0\r\n");
   else
      all_printf("&6&b*** Automatic Reboot Cancelled ***&0\r\n");

   if (restrict) {
      if (restrict_reason == RESTRICT_NONE || restrict_reason == RESTRICT_AUTOBOOT) {
         restrict = 0;
         restrict_reason = RESTRICT_NONE;
         all_printf("*** Mortal logins reenabled ***\r\n");
         log("Login restriction removed.");
      }
   }
}

void check_auto_rebooting()
{
   int minutes_till, seconds_till;
   static int reboot_prepped = 0;

   if (!reboot_auto) return;

   if (reboot_pulse <= global_pulse) {
      /* TIME TO REBOOT! */

      /* Note that this block will be visited twice due to incrementing and
       * checking reboot_prepped. This allows the main loop to execute an
       * additional time after we call reboot_mud_prep(). Therefore, the
       * shutdown notification text (the mushroom cloud) will actually be
       * sent to player sockets. */

      if (reboot_prepped == 1) {
         circle_shutdown = circle_reboot = 1;
      } else if (reboot_prepped == 0) {
         log("Automatic reboot.");
         reboot_mud_prep();
      }
      reboot_prepped++;
   } else if ((reboot_pulse - global_pulse) / (PASSES_PER_SEC * 60) < reboot_warning_minutes) {
      minutes_till = (reboot_pulse - global_pulse - 1) / (PASSES_PER_SEC * 60) + 1;
      if (minutes_till < last_reboot_warning || !reboot_warning || !last_reboot_warning) {
         rebootwarning(minutes_till);
         /* The following disables mortal logins when there are two minutes left.
          * Or, if someone suddenly sets the mud to reboot in 1 minute ("autoboot :1")
          * it will disable mortal logins then.
          *
          * Also, if a god reenables mortal logins ("wizlock 0"), this won't
          * override that. This is intentional. */
         if ((minutes_till == 2 || (minutes_till < 2 && !reboot_warning)) && restrict < LVL_IMMORT) {
            log("Mortal logins prevented due to imminent automatic reboot.");
            restrict = LVL_IMMORT;
            restrict_reason = RESTRICT_AUTOBOOT;
            all_printf("*** No more mortal logins ***\r\n");
         }
         reboot_warning = 1;
         last_reboot_warning = minutes_till;
      } else if (minutes_till == 1) {
         /* Additional warnings during the last minute */
         seconds_till = (reboot_pulse - global_pulse) / PASSES_PER_SEC;
         if (seconds_till == 30 || seconds_till == 10 || seconds_till == 5) {
            all_printf("&4&b*&0 &7&b%d second%s to reboot&0 &4&b*&0\r\n",
                  seconds_till, seconds_till == 1 ? "" : "s");
         }
      }
   }
}

/*
 * game_loop contains the main loop which drives the entire MUD.  It
 * cycles once every 0.10 seconds and is responsible for accepting new
 * new connections, polling existing connections for input, dequeueing
 * output and sending it out to players, and calling "heartbeat functions
 * such as mobile_activity().
 */
void game_loop(int mother_desc)
{
  fd_set input_set, output_set, exc_set, null_set;
  struct timeval last_time, before_sleep, opt_time, process_time, now, timeout;
  char comm[MAX_INPUT_LENGTH];
  struct descriptor_data *d, *next_d;
  int maxdesc, aliased;
  pulse_t missed_pulses;

  /* initialize various time values */
  null_time.tv_sec = 0;
  null_time.tv_usec = 0;
  opt_time.tv_usec = OPT_USEC;
  opt_time.tv_sec = 0;
  FD_ZERO(&null_set);

  gettimeofday(&last_time, (struct timezone *) 0);

  /* The Main Loop.  The Big Cheese.  The Top Dog.  The Head Honcho.  The.. */
  while (!circle_shutdown) {

    /* Sleep if we don't have any connections and are not about to reboot */
    if (descriptor_list == NULL && !reboot_warning) {
      log("No connections.  Going to sleep.");
      FD_ZERO(&input_set);
      FD_SET(mother_desc, &input_set);
      if (select(mother_desc + 1, &input_set, (fd_set *) 0, (fd_set *) 0, NULL) < 0) {
        if (errno == EINTR)
          log("Waking up to process signal.");
        else
          perror("Select coma");
      } else
        log("New connection.  Waking up.");
      gettimeofday(&last_time, (struct timezone *) 0);
    }
    /* Set up the input, output, and exception sets for select(). */
    FD_ZERO(&input_set);
    FD_ZERO(&output_set);
    FD_ZERO(&exc_set);
    FD_SET(mother_desc, &input_set);

    maxdesc = mother_desc;
    for (d = descriptor_list; d; d = d->next) {
#ifndef CIRCLE_WINDOWS
      if (d->descriptor > maxdesc)
        maxdesc = d->descriptor;
#endif
      FD_SET(d->descriptor, &input_set);
      FD_SET(d->descriptor, &output_set);
      FD_SET(d->descriptor, &exc_set);
    }

    /*
     * At this point, we have completed all input, output and heartbeat
     * activity from the previous iteration, so we have to put ourselves
     * to sleep until the next 0.1 second tick.  The first step is to
     * calculate how long we took processing the previous iteration.
     */

    gettimeofday(&before_sleep, (struct timezone *) 0); /* current time */
    process_time = timediff(before_sleep, last_time);

    /*
     * If we were asleep for more than one pass, count missed pulses and sleep
     * until we're resynchronized with the next upcoming pulse.
     */
    if (process_time.tv_sec == 0 && process_time.tv_usec < OPT_USEC) {
      missed_pulses = 0;
    } else {
      missed_pulses = process_time.tv_sec * PASSES_PER_SEC;
      missed_pulses += process_time.tv_usec / OPT_USEC;
      process_time.tv_sec = 0;
      process_time.tv_usec = process_time.tv_usec % OPT_USEC;
    }

    /* Calculate the time we should wake up */
    last_time = timeadd(before_sleep, timediff(opt_time, process_time));

    /* Now keep sleeping until that time has come */
    gettimeofday(&now, (struct timezone *) 0);
    timeout = timediff(last_time, now);

    /* go to sleep */
    do {
#ifdef CIRCLE_WINDOWS
      Sleep(timeout.tv_sec * 1000 + timeout.tv_usec / 1000);
#else
      if (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &timeout) < 0) {
        if (errno != EINTR) {
          perror("Select sleep");
          exit(1);
        }
      }
#endif /* CIRCLE_WINDOWS */
      gettimeofday(&now, (struct timezone *) 0);
      timeout = timediff(last_time, now);
    } while (timeout.tv_usec || timeout.tv_sec);

    /* poll (without blocking) for new input, output, and exceptions */
    if (select(maxdesc + 1, &input_set, &output_set, &exc_set, &null_time) < 0) {
      perror("Select poll");
      return;
    }
    /* If there are new connections waiting, accept them. */
    if (FD_ISSET(mother_desc, &input_set))
      new_descriptor(mother_desc);

      /* kick out the freaky folks in the exception set */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &exc_set)) {
        FD_CLR(d->descriptor, &input_set);
        FD_CLR(d->descriptor, &output_set);
        close_socket(d);
      }
    }

    /* process descriptors with input pending */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &input_set))
        if (process_input(d) < 0)
          close_socket(d);
    }

    /* process commands we just read from process_input */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;

      if ((--(d->wait) <= 0) && get_from_q(&d->input, comm, &aliased)) {
        if (d->character) {
          /* reset the idle timer & pull char back from void if necessary */
          if (d->original)
            d->original->char_specials.timer = 0;
          else
            d->character->char_specials.timer = 0;
          if (!d->connected && GET_WAS_IN(d->character) != NOWHERE) {
            if (d->character->in_room != NOWHERE)
              char_from_room(d->character);
            char_to_room(d->character, GET_WAS_IN(d->character));
            GET_WAS_IN(d->character) = NOWHERE;
            act("$n has returned.", TRUE, d->character, 0, 0, TO_ROOM);
          }
        }
        d->wait = 1;
        d->prompt_mode = 1;

        /* reversed these top 2 if checks so that you can use the page_string */
        /* function in the editor */
        if (PAGING(d))        /* reading something w/ pager     */
          get_paging_input(d, comm);
        else if (EDITING(d))
          editor_interpreter(d, comm);
        else if (d->str)                /* writing boards, mail, etc.     */
          string_add(d, comm);
        else if (d->connected != CON_PLAYING)        /* in menus, etc. */
          nanny(d, comm);
        else {                        /* else: we're playing normally */
          if (aliased)                /* to prevent recursive aliases */
            d->prompt_mode = 0;
          else if (perform_alias(d, comm))                /* run it through aliasing system */
            get_from_q(&d->input, comm, &aliased);
          dprintf(d, "\r\n");
          command_interpreter(d->character, comm);        /* send it to interpreter */
        }
      }
      event_process();
    }

    /* send queued output out to the operating system (ultimately to user) */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &output_set) && *(d->output)) {
        if (process_output(d) < 0)
          close_socket(d);
        else
          d->prompt_mode = 1;
      }
    }

    /* kick out folks in the CON_CLOSE state */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (STATE(d) == CON_CLOSE)
        close_socket(d);
    }

    /* give each descriptor an appropriate prompt */
    for (d = descriptor_list; d; d = d->next) {
      if (d->prompt_mode) {
        make_prompt(d);
        d->prompt_mode = 0;
      }
    }

    /*
     * Now, we execute as many pulses as necessary--just one if we haven't
     * missed any pulses, or make up for lost time if we missed a few
     * pulses by sleeping for too long.
     */
    ++missed_pulses;

    /* If we missed more than 30 seconds worth of pulses, forget it */
    if (missed_pulses > (30 * PASSES_PER_SEC)) {
      log("Warning: Missed more than 30 seconds worth of pulses");
      missed_pulses = 30 * PASSES_PER_SEC;
    }

    /* Now execute the heartbeat functions */
    while (missed_pulses--) {
      event_process();
      heartbeat(++pulse);
    }

    /* Update tics for deadlock protection (UNIX only) */
    tics++;
  }
}


void heartbeat(pulse_t pulse)
{
  static int mins_since_autosave = 0;

  global_pulse++;

  if (!(pulse % PULSE_DG_SCRIPT))
    script_trigger_check();

  event_process();

  if (!(pulse % PULSE_ZONE))
    zone_update();

  if (!(pulse % (15 * PASSES_PER_SEC)))                /* 15 seconds */
    check_idle_passwords();

  if (!(pulse % PULSE_MOBILE))
    mobile_activity();

  if (!(pulse % PULSE_VIOLENCE)) {
    perform_violence();
    mobile_spec_activity();
  }

  if (!(pulse % (PULSE_VIOLENCE/2))) {
     /* Every other combat round, NPCs in battle attempt skill and
      * spell-based attacks. */
    perform_mob_violence();
  }

  if (!(pulse % PASSES_PER_SEC)) {
    if (reboot_auto)
      check_auto_rebooting();
  }

  if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC))) {
    update_weather(pulse);
    increment_game_time(); /* Increment game time by an hour. */
    effect_update();
    point_update();
    check_time_triggers();
  }

  if (!(pulse % PULSE_AUTOSAVE)) {        /* 1 minute */
    if (++mins_since_autosave >= 1) {
      mins_since_autosave = 0;
      auto_save_all();
      House_save_all();
    }
  }
  /* Commenting entire 5 minute check section because there would be
     nothing to run once this since function was commented - RSD  */
  /* if (!(pulse % (5 * 60 * PASSES_PER_SEC))) {  */     /* 5 minutes */
  /*  record_usage();
  }
  */
  event_process();
}

/* ******************************************************************
 *  general utility stuff (for local use)                            *
 ****************************************************************** */

/*
 *  new code to calculate time differences, which works on systems
 *  for which tv_usec is unsigned (and thus comparisons for something
 *  being < 0 fail).  Based on code submitted by ss@@sirocco.cup.hp.com.
 */

/*
 * code to return the time difference between a and b (a-b).
 * always returns a nonnegative value (floors at 0).
 */
struct timeval timediff(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  if (a.tv_sec < b.tv_sec)
    return null_time;
  else if (a.tv_sec == b.tv_sec) {
    if (a.tv_usec < b.tv_usec)
      return null_time;
    else {
      rslt.tv_sec = 0;
      rslt.tv_usec = a.tv_usec - b.tv_usec;
      return rslt;
    }
  } else {                        /* a->tv_sec > b->tv_sec */
    rslt.tv_sec = a.tv_sec - b.tv_sec;
    if (a.tv_usec < b.tv_usec) {
      rslt.tv_usec = a.tv_usec + 1000000 - b.tv_usec;
      rslt.tv_sec--;
    } else
      rslt.tv_usec = a.tv_usec - b.tv_usec;
    return rslt;
  }
}

/* add 2 timevals */
struct timeval timeadd(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  rslt.tv_sec = a.tv_sec + b.tv_sec;
  rslt.tv_usec = a.tv_usec + b.tv_usec;

  while (rslt.tv_usec >= 1000000) {
    rslt.tv_usec -= 1000000;
    rslt.tv_sec++;
  }

  return rslt;
}


void record_usage(void)
{
  int sockets_connected = 0, sockets_playing = 0;
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next) {
    sockets_connected++;
    if (!d->connected)
      sockets_playing++;
  }

  log("nusage: %-3d sockets connected, %-3d sockets playing",
          sockets_connected, sockets_playing);

#ifdef RUSAGE
  {
    struct rusage ru;

    getrusage(0, &ru);
    log("rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
            ru.ru_utime.tv_sec, ru.ru_stime.tv_sec, ru.ru_maxrss);
  }
#endif
}

/*
 * Turn off echoing (specific to telnet client)
 */
void echo_off(struct descriptor_data *d)
{
  char off_string[] = {
    (char) IAC,
    (char) WILL,
    (char) TELOPT_ECHO,
    (char) 0,
  };

  dprintf(d, "%s", off_string);
}

/*
 * Turn on echoing (specific to telnet client)
 */
void echo_on(struct descriptor_data *d)
{
  char on_string[] = {
    (char) IAC,
    (char) WONT,
    (char) TELOPT_ECHO,
    (char) TELOPT_NAOFFD,
    (char) TELOPT_NAOCRD,
    (char) 0,
  };

  dprintf(d, "%s", on_string);
}

char *prompt_str(struct char_data *ch) {
  enum token {
    TOK_UNKNOWN, /* Default, not expecting anything in particular */
    TOK_CONTROL, /* Last char was a %, next one is a control code */
    TOK_PERCENT, /* Last two chars were %p, next one is percent code */
    TOK_COIN,    /* Last two chars were %c, next one is coins code */
    TOK_COOLDOWN /* Last two chars were %d, next one is cooldown code */
  };

  struct char_data *vict = FIGHTING(ch), *tank;
  static char prompt[MAX_STRING_LENGTH];
  char block[256], *cur, *raw = GET_PROMPT(ch);
  int color, temp, pre_length = 0;
  enum token expecting = TOK_UNKNOWN;
  bool found_x = FALSE;
  struct effect *eff;

  /* No prompt?  Use the default! */
  if (!raw || !*raw)
    raw = "&0FieryMUD: Set your prompt (see 'help prompt')>";

  /* Use color? */
  color = (PRF_FLAGGED(ch, PRF_COLOR_1) || PRF_FLAGGED(ch, PRF_COLOR_2) ? 1 : 0);

  /* No need to parse if there aren't % symbols */
  if (!strchr(raw, '%')) {
    sprintf(prompt, "%s&0", raw);
    return prompt;
  }

  cur = prompt;

  /*
   * Insert wizinvis and AFK flags at the beginning.  If we DON'T find the
   * %x flag below, we'll keep it.  If not, we'll skip it when we return.
   * End all flags with an extra space!  The %x case below expects it.
   */
  if (!IS_NPC(ch)) {
    if (GET_INVIS_LEV(ch) > 0)
      pre_length += sprintf(cur + pre_length, "<wizi %03d> ",
              GET_INVIS_LEV(ch));
    if (PRF_FLAGGED(ch, PRF_ROOMVIS) && GET_INVIS_LEV(ch))
      pre_length += sprintf(cur + pre_length, "<rmvis> ");
    if (PRF_FLAGGED(ch, PRF_AFK))
      pre_length += sprintf(cur + pre_length, "<AFK> ");
    /* If any flags above, insert newline. */
    if (pre_length) {
      pre_length += sprintf(cur + pre_length, "\r\n");
      /* Advance cursor. */
      cur += pre_length;
    }
  }

  for (block[0] = '\0'; *raw; ++raw) {
    if (expecting == TOK_UNKNOWN) {
      if (*raw == '%')
        /* Next character will be a control code. */
        expecting = TOK_CONTROL;
      else
        /* Not a control code starter...just copy the character. */
        *(cur++) = *raw;
    }
    else if (expecting == TOK_CONTROL) {
      /* Reset what we are expecting for the next char. */
      expecting = TOK_UNKNOWN;
      switch (*raw) {
        case 'h':
          cur += sprintf(cur, "%d", GET_HIT(ch));
          break;
        case 'H':
          cur += sprintf(cur, "%d", GET_MAX_HIT(ch));
          break;
/* Mana isn't available...
        case 'm':
          cur += sprintf(cur, "%d", GET_MANA(ch));
          break;
        case 'M':
          cur += sprintf(cur, "%d", GET_MAX_MANA(ch));
          break;
*/
        case 'v':
          cur += sprintf(cur, "%d", GET_MOVE(ch));
          break;
        case 'V':
          cur += sprintf(cur, "%d", GET_MAX_MOVE(ch));
          break;
        case 'i':
        case 'I':
          cur += sprintf(cur, "%ld", GET_HIDDENNESS(ch));
          break;
        case 'a':
        case 'A':
          cur += sprintf(cur, "%d", GET_ALIGNMENT(ch));
          break;
        case 'n':
          /* Current character's name. */
          cur += sprintf(cur, "%s", GET_NAME(ch));
          break;
        case 'N':
          /* If switched, show original char's name. */
          cur += sprintf(cur, "%s", GET_NAME(REAL_CHAR(ch)));
          break;
        case 'd':
          /* Cooldown bar: next char will be control code */
          expecting = TOK_COOLDOWN;
          break;
        case 'e':
          /* Show current to-next-level exp status */
          cur += sprintf(cur, "%s", exp_bar(REAL_CHAR(ch), 20, 20, 20, color));
          break;
        case 'E':
          /* Show current to-next-level exp status */
          cur += sprintf(cur, "%s", exp_message(REAL_CHAR(ch)));
          break;
        case 'l':
        case 'L':
          /* List active spells. */
          for (eff = ch->effects; eff; eff = eff->next)
            if (eff->duration >= 0 && (!eff->next || eff->next->type != eff->type)) {
              if (color && EFF_FLAGGED(ch, EFF_DETECT_MAGIC)) {
                if (eff->duration <= 1)
                  cur += sprintf(cur, "%s", CLR(ch, FRED));
                else if (eff->duration <= 3)
                  cur += sprintf(cur, "%s", CLR(ch, HRED));
              }
              cur += sprintf(cur, "%s%s",
                             skills[eff->type].name,
                             eff->next ? " " : "");
              if (color && EFF_FLAGGED(ch, EFF_DETECT_MAGIC))
                cur += sprintf(cur, "%s", CLR(ch, ANRM));
            }
          break;
        case 'p':
        case 'P':
          /* Percent of x remaining: next char will be a control code. */
          expecting = TOK_PERCENT;
          break;
        case 'c':
        case 'C':
          /* Amount of gold held/in bank: next char will be a control code. */
          expecting = TOK_COIN;
          break;
        case 'w':
          /* All money held. */
          cur += sprintf(cur, "&0%d&6&8p&0 %d&3&8g&0 %ds %d&3c&0",
                  GET_PLATINUM(ch), GET_GOLD(ch),
                  GET_SILVER(ch), GET_COPPER(ch));
          break;
        case 'W':
          /* All money in bank. */
          cur += sprintf(cur, "&0%d&6&8p&0 %d&3&8g&0 %ds %d&3c&0",
                  GET_BANK_PLATINUM(ch), GET_BANK_GOLD(ch),
                  GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
          break;
        case 'o':
          /* Show the victim's name and status. */
          if (vict)
            cur += snprintf(cur, 255, "%s &0(%s)", PERS(vict, ch),
                    status_string(GET_HIT(vict), GET_MAX_HIT(vict), STATUS_ALIAS));
          break;
        case 'O':
          /* Just victim's name. */
          if (vict)
            cur += snprintf(cur, 255, "%s", PERS(vict, ch));
          break;
        case 't':
          /* Show the tank's name and status. */
          if (vict && (tank = FIGHTING(vict)))
            cur += sprintf(cur, "%s &0(%s&0)", PERS(tank, ch),
                    status_string(GET_HIT(tank), GET_MAX_HIT(tank), STATUS_ALIAS));
          break;
        case 'T':
          /* Just the tank's name. */
          if (vict && (tank = FIGHTING(vict)))
            cur += sprintf(cur, "%s", PERS(tank, ch));
          break;
        case 'g':
          if (ch->group_master)
            cur += sprintf(cur, "%s &0(%s&0)", PERS(ch->group_master, ch),
                    status_string(GET_HIT(ch->group_master),
                                  GET_MAX_HIT(ch->group_master),
                                  STATUS_ALIAS));
          break;
        case 'G':
          if (ch->group_master)
            cur += sprintf(cur, "%s", PERS(ch->group_master, ch));
          break;
        case 'r':
          cur += sprintf(cur, "%d", GET_RAGE(ch));
          break;
        case 'x':
        case 'X':
          /* Flags like wizinvis and AFK. */
          found_x = TRUE;
          /* If any flags were inserted above, copy them here instead. */
          if (pre_length >= 3) {
            /* We don't want to keep the extra space or newline. */
            snprintf(cur, pre_length - 2, "%s", prompt);
            /* snprintf returns the number of chars it WOULD have printed
             * if it didn't truncate, so we add to the pointer manually. */
            cur += pre_length - 3;
          }
          break;
        case '_':
          cur += sprintf(cur, "\r\n");
          break;
        case '-':
          cur += sprintf(cur, " ");
          break;
        case '%':
          cur += sprintf(cur, "%%");
          break;
      }
    }
    else if (expecting == TOK_PERCENT) {
      expecting = TOK_UNKNOWN;
      switch (*raw) {
        case 'h':
        case 'H':
          temp = (100 * GET_HIT(ch)) / MAX(1, GET_MAX_HIT(ch));
          break;
/*
        case 'm':
        case 'M':
          temp = (100 * GET_MANA(ch)) / MAX(1, GET_MAX_MANA(ch));
          break;
*/
        case 'v':
        case 'V':
          temp = (100 * GET_MOVE(ch)) / MAX(1, GET_MAX_MOVE(ch));
          break;
        default:
          /* If we set expecting to 0 ahead of time up here, we'll skip
             the percent sprintf below. */
          continue;
      }
      cur += sprintf(cur, "%d%%", temp);
    }
    else if (expecting == TOK_COIN) {
      expecting = TOK_UNKNOWN;
      switch (*raw) {
        case 'p': temp = GET_PLATINUM(ch); break;
        case 'g': temp = GET_GOLD(ch); break;
        case 's': temp = GET_SILVER(ch); break;
        case 'c': temp = GET_COPPER(ch); break;
        case 'P': temp = GET_BANK_PLATINUM(ch); break;
        case 'G': temp = GET_BANK_GOLD(ch); break;
        case 'S': temp = GET_BANK_SILVER(ch); break;
        case 'C': temp = GET_BANK_COPPER(ch); break;
        default:  continue; /* don't print anything */
      }
      cur += sprintf(cur, "%d", temp);
    }
    else if (expecting == TOK_COOLDOWN) {
      expecting = TOK_UNKNOWN;
      /* Show time left for particular cooldown */
      switch (*raw) {
        case 'i': temp = CD_INSTANT_KILL; break;
        case 'd': temp = CD_DISARM;       break;
        case 'm': temp = CD_SUMMON_MOUNT; break;
        case 'l': temp = CD_LAY_HANDS;    break;
        case 'f': temp = CD_FIRST_AID;    break;
        case 't': temp = CD_THROATCUT;    break;
        case 's': temp = CD_SHAPECHANGE;  break;
        case 'c': temp = CD_CHANT;        break;
        default:  continue; /* don't print anything */
      }
      cur += sprintf(cur, "%s", cooldown_bar(ch, temp, 20, 20, color));
    }
  }

  sprintf(cur, "&0");
  cur = prompt;
  if (found_x)
    cur += pre_length;
  return cur;
}

void make_prompt(struct descriptor_data *d)
{
  /* Do not use dprintf or any function that ultimately calls
   * string_to_output within make_prompt!  You must use
   * write_to_descriptor, because string_to_output resets the
   * prompt flag.
   */

  if (PAGING(d)) {
    char prompt[MAX_INPUT_LENGTH];
    sprintf(prompt, "\r[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
            PAGING_PAGE(d) + 1, PAGING_NUMPAGES(d));
    write_to_descriptor(d->descriptor, prompt);
  }
  else if (EDITING(d) || d->str)
    write_to_descriptor(d->descriptor, "] ");
  else if (!d->connected) {
    char *prompt = prompt_str(d->character);
    process_colors(prompt, MAX_STRING_LENGTH, prompt,
                   COLOR_LEV(d->character) >= C_NRM ? CLR_PARSE : CLR_STRIP);
    write_to_descriptor(d->descriptor, prompt);
  }
}

/*
 * This is one of the biggest hacks ever.
 *
 * When input is processed by the game loop (in process_input),
 * before the command is queued up for normal interpreting,
 * casting_command is called, and if the character is casting
 * and the command is ok while casting, then it's handled
 * immediately here.
 */
bool casting_command(struct descriptor_data *d, char *txt) {
  int cmd;

  /*
   * Only use this hack for descriptors with characters who are
   * actually playing.  Additionally, they must be casting.
   */
  if (!d || STATE(d) != CON_PLAYING || !d->character || !CASTING(d->character))
    return FALSE;

  /*
   * A hack-within-a-hack to enable usage of paging while casting.
   */
  if (PAGING(d)) {
    get_paging_input(d, txt);
    return TRUE;
  }
  else if (EDITING(d)) {
    editor_interpreter(d, txt);
    return TRUE;
  }
  else if (d->str) {
    string_add(d, txt);
    return TRUE;
  }

  any_one_arg(txt, arg);

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (!strncmp(cmd_info[cmd].command, arg, strlen(arg)))
      if (can_use_command(d->character, cmd))
        break;

  if (*cmd_info[cmd].command == '\n')
    return FALSE;

  /*
   * Non-casting commands will be queued up normally.
   */
  if (!IS_SET(cmd_info[cmd].flags, CMD_CAST))
    return FALSE;

  /* Handle the casting-ok command immediately. */
  dprintf(d, "\r\n");
  command_interpreter(d->character, txt);
  return TRUE;
}


void write_to_q(char *txt, struct txt_q *queue, int aliased, struct descriptor_data *d)
{
  struct txt_block *new;

  CREATE(new, struct txt_block, 1);
  CREATE(new->text, char, strlen(txt) + 1);
  strcpy(new->text, txt);
  new->aliased = aliased;

  /* queue empty? */
  if (!queue->head) {
    new->next = NULL;
    queue->head = queue->tail = new;
  } else {
    queue->tail->next = new;
    queue->tail = new;
    new->next = NULL;
  }
}


int get_from_q(struct txt_q *queue, char *dest, int *aliased)
{
  struct txt_block *tmp;

  /* queue empty? */
  if (!queue->head)
    return 0;

  tmp = queue->head;
  strcpy(dest, queue->head->text);
  *aliased = queue->head->aliased;
  queue->head = queue->head->next;

  free(tmp->text);
  free(tmp);

  return 1;
}


/* Empty the queues before closing connection */
void flush_queues(struct descriptor_data *d)
{
  int dummy;

  if (d->large_outbuf) {
    d->large_outbuf->next = bufpool;
    bufpool = d->large_outbuf;
  }

  while (get_from_q(&d->input, buf2, &dummy));
}


/* aka dprintf */
void desc_printf(struct descriptor_data *t, const char *txt, ...)
{
  va_list args;

  static unsigned int vcount = 0;
  static unsigned int scount = 0;

  if (txt && *txt) {
    if (strchr(txt, '%')) {
      va_start(args, txt);
      vsnprintf(comm_buf, sizeof(comm_buf), txt, args);
      va_end(args);
      txt = comm_buf;
      ++vcount;
    }
    else
      ++scount;
    string_to_output(t, txt);
  }

  /* TODO: check this debug data and determine if the split
   * for static strings is necessary
   */
  if ((vcount + scount) % 100 == 0)
    fprintf(stderr, "DEBUG :: log :: vprintf calls - %u, fputs calls - %u\n",
            vcount, scount);
}

/* Add a new string to a player's output queue */
void string_to_output(struct descriptor_data *t, const char *txt)
{
  int size;
  static char new_txt[2 * MAX_STRING_LENGTH];

  if (!t || !txt || !*txt)
    return;

  size = process_colors(new_txt, sizeof(new_txt), txt, t->character &&
                        COLOR_LEV(t->character) >= C_NRM ? CLR_PARSE : CLR_STRIP);

  /* if we're in the overflow state already, ignore this new output */
  if (t->bufptr < 0)
    return;

  /* if we have enough space, just write to buffer and that's it! */
  if (t->bufspace > size) {
    strcpy(t->output + t->bufptr, new_txt);
    t->bufspace -= size;
    t->bufptr += size;
    return;
  }

  /*
   * If we're already using the large buffer, or if even the large buffer
   * is too small to handle this new text, chuck the text and switch to the
   * overflow state.
   */
  if (t->large_outbuf || ((size + strlen(t->output)) > LARGE_BUFSIZE)) {
    t->bufptr = -1;
    buf_overflows++;
    return;
  }

  buf_switches++;

  /* if the pool has a buffer in it, grab it */
  if (bufpool != NULL) {
    t->large_outbuf = bufpool;
    bufpool = bufpool->next;
  }
  else {                      /* else create a new one */
    CREATE(t->large_outbuf, struct txt_block, 1);
    CREATE(t->large_outbuf->text, char, LARGE_BUFSIZE);
    buf_largecount++;
  }

  strcpy(t->large_outbuf->text, t->output);     /* copy to big buffer */
  t->output = t->large_outbuf->text;    /* make big buffer primary */
  strcat(t->output, new_txt);   /* now add new text */

  /* set the pointer for the next write */
  t->bufptr = strlen(t->output);

  /* calculate how much space is left in the buffer */
  t->bufspace = LARGE_BUFSIZE - 1 - t->bufptr;
}

void free_bufpools(void)
{
  extern struct txt_block *bufpool;
  struct txt_block *tmp;

  while (bufpool) {
    tmp = bufpool->next;
    if (bufpool->text)
      free(bufpool->text);
    free(bufpool);
    bufpool = tmp;
  }
}


  /* ******************************************************************
   *  socket handling                                                  *
   ****************************************************************** */

void init_descriptor(struct descriptor_data *newd, int desc)
{
  static int last_desc = 0;

  newd->descriptor = desc;
  newd->idle_tics = 0;
  newd->output = newd->small_outbuf;
  newd->bufspace = SMALL_BUFSIZE - 1;
  newd->login_time = time(0);
  *newd->output = '\0';
  newd->bufptr = 0;
  newd->wait = 1;
  STATE(newd) = CON_QANSI;

  if (++last_desc == 1000)
    last_desc = 1;
  newd->desc_num = last_desc;
}


int new_descriptor(int s) {
  socket_t desc;
  int sockets_connected = 0;
  unsigned long addr;
  unsigned int i;
  struct descriptor_data *newd;
  struct sockaddr_in peer;
  struct hostent *from;
  extern char *BANNEDINTHEUSA;
  extern char *BANNEDINTHEUSA2;
  extern char *BANNEDINTHEUSA3;

  /* accept the new connection */
  i = sizeof(peer);
  if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
    perror("accept");
    return -1;
  }
  /* keep it from blocking */
  nonblock(desc);

  /* make sure we have room for it */
  for (newd = descriptor_list; newd; newd = newd->next)
    sockets_connected++;

  if (sockets_connected >= max_players) {
    write_to_descriptor(desc, "Sorry, FieryMUD is full right now... please try again later!\r\n");
    CLOSE_SOCKET(desc);
    return 0;
  }
  /* create a new descriptor */
  CREATE(newd, struct descriptor_data, 1);
  memset((char *) newd, 0, sizeof(struct descriptor_data));

  /* find the sitename */
  if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
      sizeof(peer.sin_addr), AF_INET))) {

    /* resolution failed */
    if (!nameserver_is_slow)
      perror("gethostbyaddr");

    /* find the numeric site address */
    addr = ntohl(peer.sin_addr.s_addr);
    sprintf(newd->host, "%03u.%03u.%03u.%03u", (int) ((addr & 0xFF000000) >> 24),
            (int) ((addr & 0x00FF0000) >> 16), (int) ((addr & 0x0000FF00) >> 8),
            (int) ((addr & 0x000000FF)));
  } else {
    strncpy(newd->host, from->h_name, HOST_LENGTH);
    *(newd->host + HOST_LENGTH) = '\0';
  }

  /* determine if the site is banned */
  if (isbanned(newd->host) == BAN_ALL) {
    write_to_descriptor(desc, BANNEDINTHEUSA);
    write_to_descriptor(desc, BANNEDINTHEUSA2);
    write_to_descriptor(desc, BANNEDINTHEUSA3);
    sprintf(buf, "\r\n Connection logged from: %s\r\n\r\n", newd->host);
    write_to_descriptor(desc, buf);
    CLOSE_SOCKET(desc);
    mprintf(L_STAT, LVL_GOD, "BANNED: Connection attempt denied from [%s]", newd->host);
    free(newd);
    return 0;
  }
#if 0
  /* Log new connections - probably unnecessary, but you may want it */
  mprintf(L_STAT, LVL_GOD, "New connection from [%s]", newd->host);
#endif

  init_descriptor(newd, desc);

  /* prepend to list */
  newd->next = descriptor_list;
  descriptor_list = newd;

  dprintf(newd, "Do you want ANSI terminal support? (Y/n) ");

  return 0;
}


int process_output(struct descriptor_data *t)
{
  static char i[LARGE_BUFSIZE + GARBAGE_SPACE];
  static int result;

  /* we may need this \r\n for later -- see below */
  strcpy(i, "\r\n");

  /* now, append the 'real' output */
  strcpy(i + 2, t->output);

  /* if we're in the overflow state, notify the user */
  if (t->bufptr < 0)
    strcat(i, "**OVERFLOW**");

  /* add the extra CRLF if the person isn't in compact mode */
  if (!t->connected && t->character && !PRF_FLAGGED(t->character, PRF_COMPACT))
    strcat(i + 2, "\r\n");

  /*
   * now, send the output.  If this is an 'interruption', use the prepended
   * CRLF, otherwise send the straight output sans CRLF.
   */
  if (!t->prompt_mode)                /* && !t->connected) */
    result = write_to_descriptor(t->descriptor, i);
  else
    result = write_to_descriptor(t->descriptor, i + 2);

  /* handle snooping: prepend "% " and send to snooper */
  if (t->snoop_by)
    dprintf(t->snoop_by, "&2((&0 %s &2))&0", t->output);

  /*
   * if we were using a large buffer, put the large buffer on the buffer pool
   * and switch back to the small one
   */
  if (t->large_outbuf) {
    t->large_outbuf->next = bufpool;
    bufpool = t->large_outbuf;
    t->large_outbuf = NULL;
    t->output = t->small_outbuf;
  }
  /* reset total bufspace back to that of a small buffer */
  t->bufspace = SMALL_BUFSIZE - 1;
  t->bufptr = 0;
  *(t->output) = '\0';

  return result;
}


int write_to_descriptor(socket_t desc, char *txt)
{
  int total, bytes_written;

  total = strlen(txt);

  do {
#ifdef CIRCLE_WINDOWS
    if ((bytes_written = send(desc, txt, total, 0)) < 0) {
      if (WSAGetLastError() == WSAEWOULDBLOCK)
#else
    if ((bytes_written = write(desc, txt, total)) < 0) {
#ifdef EWOULDBLOCK
      if (errno == EWOULDBLOCK)
        errno = EAGAIN;
#endif /* EWOULDBLOCK */
      if (errno == EAGAIN)
#endif /* CIRCLE_WINDOWS */
        log("process_output: socket write would block, about to close");
      else
        perror("Write to socket");
      return -1;
    } else {
      txt += bytes_written;
      total -= bytes_written;
    }
  } while (total > 0);

  return 0;
}


/*
 * ASSUMPTION: There will be no newlines in the raw input buffer when this
 * function is called.  We must maintain that before returning.
 */
int process_input(struct descriptor_data *t)
{
  int buf_length, bytes_read, space_left, failed_subst;
  char *ptr, *read_point, *write_point, *nl_pos = NULL;
  char tmp[MAX_INPUT_LENGTH + 8];

  /* first, find the point where we left off reading data */
  buf_length = strlen(t->inbuf);
  read_point = t->inbuf + buf_length;
  space_left = MAX_RAW_INPUT_LENGTH - buf_length - 1;

  do {
    if (space_left <= 0) {
      log("process_input: about to close connection: input overflow");
      return -1;
    }
#ifdef CIRCLE_WINDOWS
    if ((bytes_read = recv(t->descriptor, read_point, space_left, 0)) < 0) {
      if (WSAGetLastError() != WSAEWOULDBLOCK) {
#else
    if ((bytes_read = read(t->descriptor, read_point, space_left)) < 0) {
#ifdef EWOULDBLOCK
      if (errno == EWOULDBLOCK)
        errno = EAGAIN;
#endif /* EWOULDBLOCK */
      if (errno != EAGAIN) {
#endif /* CIRCLE_WINDOWS */
        log("process_input: about to lose connection");
        return -1; /* some error condition was encountered on
                    * read */
      } else
        return 0;  /* the read would have blocked: just means no
                * data there but everything's okay */
    } else if (bytes_read == 0) {
      log("EOF on socket read (connection broken by peer)");
      return -1;
    }
    /* at this point, we know we got some data from the read */

    *(read_point + bytes_read) = '\0';        /* terminate the string */

    /* search for a newline in the data we just read */
    for (ptr = read_point; *ptr && !nl_pos; ptr++)
      if (IS_NEWLINE(*ptr))
        nl_pos = ptr;

    read_point += bytes_read;
    space_left -= bytes_read;

  /*
   * on some systems such as AIX, POSIX-standard nonblocking I/O is broken,
   * causing the MUD to hang when it encounters input not terminated by a
   * newline.  This was causing hangs at the Password: prompt, for example.
   * I attempt to compensate by always returning after the _first_ read, instead
   * of looping forever until a read returns -1.  This simulates non-blocking
   * I/O because the result is we never call read unless we know from select()
   * that data is ready (process_input is only called if select indicates that
   * this descriptor is in the read set).  JE 2/23/95.
   */
#if !defined(POSIX_NONBLOCK_BROKEN)
  } while (nl_pos == NULL);
#else
  } while (0);

  if (nl_pos == NULL)
    return 0;
#endif /* POSIX_NONBLOCK_BROKEN */

  /*
   * okay, at this point we have at least one newline in the string; now we
   * can copy the formatted data to a new array for further processing.
   */

  read_point = t->inbuf;

  while (nl_pos != NULL) {
    write_point = tmp;
    space_left = MAX_INPUT_LENGTH - 1;

    for (ptr = read_point; (space_left > 0) && (ptr < nl_pos); ptr++) {
      if (*ptr == '\b') {        /* handle backspacing */
        if (write_point > tmp) {
          if (*(--write_point) == '$') {
            write_point--;
            space_left += 2;
          } else
            space_left++;
        }
      } else if (isascii(*ptr) && isprint(*ptr)) {
        if ((*(write_point++) = *ptr) == '$') {                /* copy one character */
          *(write_point++) = '$';        /* if it's a $, double it */
          space_left -= 2;
        } else
          space_left--;
      }
    }

    *write_point = '\0';

    if ((space_left <= 0) && (ptr < nl_pos)) {
      char buffer[MAX_INPUT_LENGTH + 64];
      snprintf(buffer, sizeof(buffer), "Linen too long.  Truncated to:\r\n%s\r\n", tmp);
      if (write_to_descriptor(t->descriptor, buffer) < 0)
        return -1;
    }
    if (t->snoop_by)
      dprintf(t->snoop_by, "&6>>&b %s &0\r\n", tmp);
    failed_subst = 0;

    if (*tmp == '!')
      strcpy(tmp, t->last_input);
    else if (*tmp == '^') {
      if (!(failed_subst = perform_subst(t, t->last_input, tmp)))
        strcpy(t->last_input, tmp);
    } else
      strcpy(t->last_input, tmp);

    /*
     * If the user is casting, and the command is ok
     * when casting, then it gets processed immediately
     * by the command interpreter within casting_command().
     * Otherwise, the command is queued up and handled by
     * the game loop normally.  Oh, and this is a hack.
     */
    if (!failed_subst && !casting_command(t, tmp))
      write_to_q(tmp, &t->input, 0, t);

    /* find the end of this line */
    while (IS_NEWLINE(*nl_pos))
      nl_pos++;

    /* see if there's another newline in the input buffer */
    read_point = ptr = nl_pos;
    for (nl_pos = NULL; *ptr && !nl_pos; ptr++)
      if (IS_NEWLINE(*ptr))
        nl_pos = ptr;
  }

  /* now move the rest of the buffer up to the beginning for the next pass */
  write_point = t->inbuf;
  while (*read_point)
    *(write_point++) = *(read_point++);
  *write_point = '\0';

  return 1;
}

/*
 * perform substitution for the '^..^' csh-esque syntax
 * orig is the orig string (i.e. the one being modified.
 * subst contains the substition string, i.e. "^telm^tell"
 */
int perform_subst(struct descriptor_data *t, char *orig, char *subst)
{
  char new[MAX_INPUT_LENGTH + 5];
  char *first, *second, *strpos;

  /*
   * first is the position of the beginning of the first string (the one
   * to be replaced
   */
  first = subst + 1;

  /* now find the second '^' */
  if (!(second = strchr(first, '^'))) {
    dprintf(t, "Invalid substitution.\r\n");
    return 1;
  }
  /* terminate "first" at the position of the '^' and make 'second' point
   * to the beginning of the second string */
  *(second++) = '\0';

  /* now, see if the contents of the first string appear in the original */
  if (!(strpos = strstr(orig, first))) {
    dprintf(t, "Invalid substitution.\r\n");
    return 1;
  }
  /* now, we construct the new string for output. */

  /* first, everything in the original, up to the string to be replaced */
  strncpy(new, orig, (strpos - orig));
  new[(strpos - orig)] = '\0';

  /* now, the replacement string */
  strncat(new, second, (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* now, if there's anything left in the original after the string to
   * replaced, copy that too. */
  if (((strpos - orig) + strlen(first)) < strlen(orig))
    strncat(new, strpos + strlen(first), (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* terminate the string in case of an overflow from strncat */
  new[MAX_INPUT_LENGTH - 1] = '\0';
  strcpy(subst, new);

  return 0;
}



void close_socket(struct descriptor_data *d)
{
  struct descriptor_data *temp;
  long target_idnum = -1;

  CLOSE_SOCKET(d->descriptor);
  flush_queues(d);

  /* Forget snooping */
  if (d->snooping)
    d->snooping->snoop_by = NULL;

  if (d->snoop_by) {
    dprintf(d->snoop_by, "Your victim is no longer among us.\r\n");
    d->snoop_by->snooping = NULL;
  }

  /* Shapechange a player back to normal form */
  if (d->character) {
    if (POSSESSED(d->character))
      do_shapechange(d->character, "me", 0, 1);
  }

  /*. Kill any OLC stuff .*/
  switch(d->connected) {
    case CON_OEDIT:
    case CON_REDIT:
    case CON_ZEDIT:
    case CON_MEDIT:
    case CON_SEDIT:
    case CON_TRIGEDIT:
      cleanup_olc(d, CLEANUP_ALL);
      break;
    case CON_EXDESC:
      /* I apologize for this, but seriously, look at the editing code here */
      free(*d->str);
      if (d->backstr) {
        *d->str = d->backstr;
      } else
        *d->str = NULL;
      d->backstr = NULL;
      d->str = NULL;
      if (d->character)
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_WRITING);
      d->connected = CON_PLAYING;
      break;
    default:
      break;
  }

  if (EDITING(d))
    editor_cleanup(d);

  if (d->character) {
    target_idnum = GET_IDNUM(d->character);
    /*
     * Plug memory leak, from Eric Green.
     */
    if (PLR_FLAGGED(d->character, PLR_MAILING) && d->str) {
      if (*(d->str))
        free(*(d->str));
      free(d->str);
    }
    if (IS_PLAYING(d)) {
      save_player_char(d->character);
      act("$n has lost $s link.", TRUE, d->character, 0, 0, TO_ROOM);
      mprintf(L_STAT, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
             "Closing link to: %s.", GET_NAME(d->character));
      d->character->desc = NULL;
    }
    else {
      if (GET_NAME(d->character))
        mprintf(L_STAT, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
               "Losing player: %s.", GET_NAME(d->character));
      else
        mprintf(L_STAT, LVL_IMMORT, "Losing player: <null>.");
      d->character->desc = NULL;
      free_char(d->character);
    }
  }
  else
    mprintf(L_INFO, LVL_IMMORT, "Losing descriptor without char.");

  /* JE 2/22/95 -- part of my unending quest to make switch stable */
  if (d->original && d->original->desc)
    d->original->desc = NULL;

  REMOVE_FROM_LIST(d, descriptor_list, next);

  free_paged_text(d);
  if (d->storage)
    free(d->storage);

  free(d);
}


void check_idle_passwords(void)
{
  struct descriptor_data *d, *next_d;

  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME &&
        STATE(d) != CON_QANSI && STATE(d) != CON_MENU &&
        STATE(d) != CON_ISPELL_BOOT) {
      continue;
    }
    if (!d->idle_tics) {
      d->idle_tics++;
      continue;
    } else {
      if (d->character && STATE(d) == CON_MENU)
        save_player_char(d->character);
      echo_on(d);
      dprintf(d, "\r\nTimed out... goodbye.\r\n");
      STATE(d) = CON_CLOSE;
    }
  }
}


/*
 * I tried to universally convert Circle over to POSIX compliance, but
 * alas, some systems are still straggling behind and don't have all the
 * appropriate defines.  In particular, NeXT 2.x defines O_NDELAY but not
 * O_NONBLOCK.  Krusty old NeXT machines!  (Thanks to Michael Jones for
 * this and various other NeXT fixes.)
 */
#ifdef CIRCLE_WINDOWS

void nonblock(socket_t s)
{
  long val = 1;
  ioctlsocket(s, FIONBIO, &val);
}

#else

#ifndef O_NONBLOCK
#define O_NONBLOCK O_NDELAY
#endif

void nonblock(socket_t s)
{
  int flags;

  flags = fcntl(s, F_GETFL, 0);
  flags |= O_NONBLOCK;
  if (fcntl(s, F_SETFL, flags) < 0) {
    perror("Fatal error executing nonblock (comm.c)");
    exit(1);
  }
}


/* ******************************************************************
 *  signal-handling functions (formerly signals.c)                   *
 ****************************************************************** */

RETSIGTYPE checkpointing()
{
  if (!tics) {
    log("SYSERR: CHECKPOINT shutdown: tics not updated");
    abort();
  } else
    tics = 0;
}

RETSIGTYPE dump_core()
{
  mprintf(L_STAT, LVL_IMMORT, "Received SIGUSR1 - dumping core.");
  drop_core(NULL, "usrsig");
}

RETSIGTYPE unrestrict_game()
{
  extern struct ban_list_element *ban_list;

  mprintf(L_WARN, LVL_IMMORT,
         "Received SIGUSR2 - completely unrestricting game (emergent)");
  ban_list = NULL;
  restrict = 0;
  restrict_reason = RESTRICT_NONE;
}

RETSIGTYPE hupsig()
{
  log("Received SIGHUP, SIGINT, or SIGTERM.  Shutting down...");
  circle_shutdown = TRUE;  /* added by Gurlaek 2/14/2000 */
}


/*
 * This is an implementation of signal() using sigaction() for portability.
 * (sigaction() is POSIX; signal() is not.)  Taken from Stevens' _Advanced
 * Programming in the UNIX Environment_.  We are specifying that all system
 * calls _not_ be automatically restarted for uniformity, because BSD systems
 * do not restart select(), even if SA_RESTART is used.
 *
 * Note that NeXT 2.x is not POSIX and does not have sigaction; therefore,
 * I just define it to be the old signal.  If your system doesn't have
 * sigaction either, you can use the same fix.
 *
 * SunOS Release 4.0.2 (sun386) needs this too, according to Tim Aldric.
 */

#ifndef POSIX
#define my_signal(signo, func) signal(signo, func)
#else
sigfunc *my_signal(int signo, sigfunc * func)
{
  struct sigaction act, oact;

  act.sa_handler = func;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
#ifdef SA_INTERRUPT
  act.sa_flags |= SA_INTERRUPT;        /* SunOS */
#endif

  if (sigaction(signo, &act, &oact) < 0)
    return SIG_ERR;

  return oact.sa_handler;
}
#endif                                /* NeXT */


void signal_setup(void)
{
#ifndef CIRCLE_OS2
  struct itimerval itime;
#endif
  struct timeval interval;

  /* user signal 1: reread wizlists.  Used by autowiz system. */
  /* I'm removing the autowiz stuff. I'm leaving this here because
   * it seems to serve some vital function. It may be able to be
   * reassigned to something else now that autowiz is gone RSD 3/19/00
   */
  my_signal(SIGUSR1, dump_core);

  /*
   * user signal 2: unrestrict game.  Used for emergencies if you lock
   * yourself out of the MUD somehow.  (Duh...)
   */
  my_signal(SIGUSR2, unrestrict_game);

  /*
   * set up the deadlock-protection so that the MUD aborts itself if it gets
   * caught in an infinite loop for more than 3 minutes.  Doesn't work with
   * OS/2.
   */
#ifndef CIRCLE_OS2
  interval.tv_sec = 180;
  interval.tv_usec = 0;
  itime.it_interval = interval;
  itime.it_value = interval;
  setitimer(ITIMER_VIRTUAL, &itime, NULL);
  my_signal(SIGVTALRM, checkpointing);
#endif

  /* just to be on the safe side: */
  my_signal(SIGHUP, hupsig);
  my_signal(SIGINT, hupsig);
  my_signal(SIGTERM, hupsig);
  my_signal(SIGPIPE, SIG_IGN);
  my_signal(SIGALRM, SIG_IGN);

#ifdef CIRCLE_OS2
#if defined(SIGABRT)
  my_signal(SIGABRT, hupsig);
#endif
#if defined(SIGFPE)
  my_signal(SIGFPE, hupsig);
#endif
#if defined(SIGILL)
  my_signal(SIGILL, hupsig);
#endif
#if defined(SIGSEGV)
  my_signal(SIGSEGV, hupsig);
#endif
#endif                                /* CIRCLE_OS2 */

}

#endif                                /* CIRCLE_WINDOWS */


/* ****************************************************************
 *       Public routines for system-to-player-communication        *
 **************************************************************** */

/* aka cprintf */
void char_printf(const struct char_data *ch, const char *messg, ...)
{
  va_list args;

  static unsigned int vcount = 0;
  static unsigned int scount = 0;

  if (ch->desc && messg && *messg) {
    if (strchr(messg, '%')) {
      va_start(args, messg);
      vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
      va_end(args);
      messg = comm_buf;
      ++vcount;
    }
    else
      ++scount;
    string_to_output(ch->desc, messg);
  }

  /* TODO: check this debug data and determine if the split
   * for static strings is necessary
   */
  if ((vcount + scount) % 100 == 0)
    fprintf(stderr, "DEBUG :: cprintf :: vsnprintf calls - %u, no calls - %u\n",
            vcount, scount);
}

void zone_printf(int zone_vnum, int skip_room, int min_stance, const char *messg, ...)
{
  struct descriptor_data *i;
  va_list args;
  bool found = FALSE;
  int zone_num = real_zone(zone_vnum);

  if (!messg || !*messg)
     return;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && i->character &&
        GET_STANCE(i->character) >= min_stance &&
        IN_ROOM(i->character) != NOWHERE &&
        IN_ROOM(i->character) != skip_room &&
        IN_ZONE_RNUM(i->character) == zone_num) {
      if (!found) {
        va_start(args, messg);
        vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
        va_end(args);
        found = TRUE;
      }
      string_to_output(i, comm_buf);
    }
}

void callback_printf(CBP_FUNC(callback), void *data, const char *messg, ...)
{
  struct descriptor_data *i;
  bool found;
  va_list args;

  if (messg && *messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->character && callback(i->character, data)) {
        if (!found) {
          va_start(args, messg);
          vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
          va_end(args);
          found = TRUE;
        }
        string_to_output(i, comm_buf);
      }

 
}

void all_except_printf(struct char_data *ch, const char *messg, ...)
{
  struct descriptor_data *i;
  va_list args;
  bool found = FALSE;
  struct char_data *avoid = REAL_CHAR(ch);

  if (messg && *messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected &&
          !(avoid && avoid->desc && avoid->desc == i)) {
        if (!found) {
          va_start(args, messg);
          vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
          va_end(args);
          found = TRUE;
        }
        string_to_output(i, comm_buf);
      }
}
void all_printf(const char *messg, ...)
{
  struct descriptor_data *i;
  va_list args;
  bool found = FALSE;

  if (messg && *messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected) {
        if (!found) {
          va_start(args, messg);
          vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
          va_end(args);
          found = TRUE;
        }
        string_to_output(i, comm_buf);
      }
}


void outdoor_printf(int zone_num, char *messg, ...)
{
  struct descriptor_data *i;
  va_list args;
  bool found = FALSE;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && i->character && AWAKE(i->character) &&
        CH_OUTSIDE(i->character) && IN_ZONE_RNUM(i->character) == zone_num &&
        STATE(i) == CON_PLAYING) {
      if (!found) {
        va_start(args, messg);
        vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
        va_end(args);
        found = TRUE;
      }
      string_to_output(i, comm_buf);
    }
}

void room_printf(int roomnum, const char *messg, ...)
{
  struct char_data *i;
  int dir, rmnmlen;
  struct room_data *room;
  struct exit *exit;
  bool found = FALSE;
  va_list args;

  if (!messg || !*messg)
    return;

  if (roomnum >= 0 && roomnum <= top_of_world)
    room = &world[roomnum];
  else {
    mprintf(L_ERROR, LVL_GOD, "SYSERR: bad room rnum %d passed to send_to_room", roomnum);
    return;
  }

  for (i = room->people; i; i = i->next_in_room)
    if (i->desc) {
      if (!found) {
        snprintf(comm_buf, sizeof(comm_buf), "@@B<@@0%s@@B>@@0 ", room->name);
        rmnmlen = strlen(comm_buf);
        va_start(args, messg);
        vsnprintf(comm_buf + rmnmlen, sizeof(comm_buf) - rmnmlen, messg, args);
        va_end(args);
        found = TRUE;
      }
      /* Skip over the room name */
      string_to_output(i->desc, comm_buf + rmnmlen);
    }

  /* Reflect to OBSERVATORY rooms if this room is an ARENA. */
  if (ROOM_FLAGGED(roomnum, ROOM_ARENA)) {
    for (dir = 0; dir < NUM_OF_DIRS; ++dir)
      if ((exit = room->exits[dir]) &&
            EXIT_NDEST(exit) != NOWHERE &&
            EXIT_NDEST(exit) != roomnum &&
            ROOM_FLAGGED(EXIT_NDEST(exit), ROOM_OBSERVATORY))
        for (i = EXIT_DEST(exit)->people; i; i = i->next_in_room)
          if (i->desc) {
            if (!found) {
              snprintf(comm_buf, sizeof(comm_buf), "@@B<@@0%s@@B>@@0 ", room->name);
              rmnmlen = strlen(comm_buf);
              va_start(args, messg);
              vsnprintf(comm_buf + rmnmlen, sizeof(comm_buf) - rmnmlen, messg, args);
              va_end(args);
              found = TRUE;
            }
            string_to_output(i->desc, comm_buf);
          }
  }
}


/* SPEECH_OK
 *
 * Call this function when a character is about to do some spammable type
 * of communication, such as gossip or tell.  It will keep track of how
 * blabby they've been lately, and may suppress their communication.
 *
 * INPUTS
 *
 *     ch - Character attempting communication
 *  quiet - Boolean value. TRUE prevents this function from sending any
 *          feedback to the character.
 *
 * RETURN VALUES
 *
 *   TRUE - the communication is OK
 *  FALSE - the communication should not occur. Unless quiet=TRUE, a message
 *          has already been sent to the character, so the caller should
 *          probably do nothing.
 */

/* How long we remember communications; therefore, if you spam a lot and get
 * squelched, this is how long you must wait to completely recover */
#define SPAM_PERIOD (double)(PASSES_PER_SEC * 30)

/* How many communications during SPAM_PERIOD is enough to get you squelched? */
/* (Actually it's fewer than this, because once you get halfway, each additional
 * communication moves you twice as fast.) */
#define SPAM_THRESHOLD 15

int speech_ok(struct char_data *ch, int quiet)
{
   struct char_special_data *sd;
   struct trig_data *t;

   if (GET_LEVEL(ch) >= LVL_IMMORT) return TRUE;

   if (IS_NPC(ch) && POSSESSED(ch)) {
      /* A shapechanged player */
      sd = &ch->desc->original->char_specials;
   } else {
      sd = &ch->char_specials;
   }

   /* If it's been at least SPAM_PERIOD since the last communication, there is
    * no need for calculation - any speech_rate you may have is obsolete and
    * can be forgotten. */
   if (sd->last_speech_time == 0 ||
         global_pulse - sd->last_speech_time > SPAM_PERIOD ||
         sd->last_speech_time > global_pulse /* rollover, in case the mud runs insanely long? */
         ) {
      sd->speech_rate = 1;
      sd->last_speech_time = global_pulse;
      return TRUE;
   }

   /* If the char is executing a trigger, it's all good */
   if (SCRIPT(ch))
      for (t = SCRIPT(ch)->trig_list; t; t = t->next)
         if (t->running)
            return TRUE;

   /* The following calculation considers the amount of time since the last
    * communication and uses it to reduce the speech rate. Then it adds 1 for
    * this communication. */
   sd->speech_rate = 1 + sd->speech_rate * (SPAM_PERIOD - global_pulse +
         sd->last_speech_time) / SPAM_PERIOD;
   sd->last_speech_time = global_pulse;

   if (sd->speech_rate > SPAM_THRESHOLD) {
      /* Try to blab with laryngitis, and the recovery period starts over again. */
      sd->speech_rate = SPAM_THRESHOLD * 1.5;
      if (!quiet)
         cprintf(ch, "&5&bYour mouth refuses to move!&0\r\n");
      return FALSE;

   } else if (sd->speech_rate > SPAM_THRESHOLD / 2) {
      /* You're in the sore-throat zone!*/

      /* Add a random number to discourage brinkmanship. If you keep it up
       * even with a minor sore throat, you don't know what it will take
       * to bring on full-blown laryngitis (which occurs without warning). */
      sd->speech_rate += number(1, 4);
      if (sd->speech_rate > SPAM_THRESHOLD) {
         sd->speech_rate = SPAM_THRESHOLD * 1.5;
         if (!quiet)
            cprintf(ch, "&6&bYou feel laryngitis coming on!&0\r\n");
      } else {
         if (!quiet)
            cprintf(ch, "&5Your throat feels a little sore.&0\r\n");
      }
   }

   return TRUE;
}

void speech_report(struct char_data *ch, struct char_data *tch)
{
   struct char_special_data *sd;

   if (GET_LEVEL(tch) >= LVL_IMMORT) return;

   if (IS_NPC(tch) && POSSESSED(tch)) {
      /* A shapechanged player */
      sd = &tch->desc->original->char_specials;
   } else {
      sd = &tch->char_specials;
   }

   if (sd->last_speech_time == 0 ||
         global_pulse - sd->last_speech_time > SPAM_PERIOD ||
         sd->last_speech_time > global_pulse /* rollover, in case the mud runs insanely long? */
         ) {
      return;
   }

   sd->speech_rate = sd->speech_rate * (SPAM_PERIOD - global_pulse +
         sd->last_speech_time) / SPAM_PERIOD;
   sd->last_speech_time = global_pulse;

   if (sd->speech_rate > SPAM_THRESHOLD)
      cprintf(ch, "&5&b%s %s an acute case of laryngitis.&0\r\n",
              ch == tch ? "You" : GET_NAME(tch),
              ch == tch ? "have" : "has");
   else if (sd->speech_rate > SPAM_THRESHOLD / 2)
      cprintf(ch, "&5%s%s throat feels a little sore.&0\r\n",
              ch == tch ? "Your" : GET_NAME(tch),
              ch == tch ? "" : "'s");
}

void cure_laryngitis(struct char_data *ch)
{
   struct char_special_data *sd;

   if (IS_NPC(ch) && POSSESSED(ch)) {
      /* A shapechanged player */
      sd = &ch->desc->original->char_specials;
   } else {
      sd = &ch->char_specials;
   }
   sd->speech_rate = 0;
}


char *ACTNULL = "<NULL>";

#define CHECK_NULL(pointer, expression) \
  if ((pointer) == NULL) i = ACTNULL; else i = (expression);

/* higher-level communication: the act() function */
void perform_act(const char *orig, struct char_data *ch, struct obj_data *obj,
      const void *vict_obj, const struct char_data *to) {
   const char *i = NULL;
   char lbuf[MAX_STRING_LENGTH], *buf, *j, ibuf[20];
   bool uppercasenext = FALSE;

   buf = lbuf;

   if (!to->desc)
      return;

   for (;;) {
      if (*orig == '$') {
         switch (*(++orig)) {
            case 'n':
               i = PERS(ch, to);
               break;
            case 'N':
               CHECK_NULL(vict_obj, PERS((const struct char_data *) vict_obj, to));
               break;
            case 'm':
               i = HMHR(ch);
               break;
            case 'M':
               CHECK_NULL(vict_obj, HMHR((const struct char_data *) vict_obj));
               break;
            case 's':
               i = HSHR(ch);
               break;
            case 'S':
               CHECK_NULL(vict_obj, HSHR((const struct char_data *) vict_obj));
               break;
            case 'D':
               CHECK_NULL(vict_obj,
                     without_article(GET_NAME((const struct char_data *) vict_obj)));
               break;
            case 'e':
               i = HSSH(ch);
               break;
            case 'E':
               CHECK_NULL(vict_obj, HSSH((const struct char_data *) vict_obj));
               break;
            case 'o':
               CHECK_NULL(obj, OBJN(obj, to));
               break;
            case 'O':
               CHECK_NULL(vict_obj, OBJN((const struct obj_data *) vict_obj, to));
               break;
            case 'p':
               CHECK_NULL(obj, OBJS(obj, to));
               break;
            case 'P':
               CHECK_NULL(vict_obj, OBJS((const struct obj_data *) vict_obj, to));
               break;
            case 'a':
               CHECK_NULL(obj, SANA(obj));
               break;
            case 'A':
               CHECK_NULL(vict_obj, SANA((const struct obj_data *) vict_obj));
               break;
            case 't':
               CHECK_NULL(obj, (const char *) obj);
               break;
            case 'T':
               CHECK_NULL(vict_obj, (const char*) vict_obj);
               break;
            case 'f':
               CHECK_NULL(vict_obj, fname((char *) obj));
               break;
            case 'F':
               CHECK_NULL(vict_obj, fname((char *) vict_obj));
               break;
            case 'i':
               i = ibuf;
               sprintf(ibuf, "%d", (int) obj);
               break;
            case 'I':
               i = ibuf;
               sprintf(ibuf, "%d", (int) vict_obj);
               break;
            /* uppercase previous word */
            case 'u':
               for (j=buf; j > lbuf && !isspace((int) *(j-1)); j--);
               if (j != buf)
               *j = UPPER(*j);
               i = "";
               break;
            /* uppercase next word */
            case 'U':
               uppercasenext = TRUE;
               i = "";
               break;
               case '$':
               i = "$";
               break;
            default:
               log("SYSERR: Illegal $-code to act():\n"
                   "SYSERR: %s", orig);
               i = "";
               break;
         }
         while ((*buf = *(i++))) {
            if (uppercasenext && !isspace((int) *buf)) {
               *buf = UPPER(*buf);
               uppercasenext = FALSE;
            }
            buf++;
         }
         orig++;
      } else if (!(*(buf++) = *(orig++))) {
         break;
      } else if (uppercasenext && !isspace((int) *(buf-1))) {
         *(buf-1) = UPPER(*(buf-1));
         uppercasenext = FALSE;
      }
   }

   *(--buf) = '\r';
   *(++buf) = '\n';
   *(++buf) = '\0';

   cprintf(to, "%s", CAP(lbuf));
}

/* The "act" action interpreter */
void act(const char *str, int hide_invisible, struct char_data *ch, struct obj_data *obj, const void *vict_obj, int type)
{
   struct char_data *to = NULL;
   int sleep, olc, in_room, i, to_victroom;

   if (!str) return;

   if (!(dg_act_check = !IS_SET(type, DG_NO_TRIG)))
      REMOVE_BIT(type, DG_NO_TRIG);

   /*
    * Warning: the following TO_SLEEP code is a hack.
    *
    * I wanted to be able to tell act to deliver a message regardless of sleep
    * without adding an additional argument.  TO_SLEEP is 128 (a single bit
    * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
    * command.  It's not legal to combine TO_x's with each other otherwise.
    *
    * The TO_OLC flag is also a hack.
    */

   if ((olc = IS_SET(type, TO_OLC)))
      REMOVE_BIT(type, TO_OLC);

   if ((sleep = IS_SET(type, TO_SLEEP)))
      REMOVE_BIT(type, TO_SLEEP);

   if ((to_victroom = IS_SET(type, TO_VICTROOM)))
      REMOVE_BIT(type, TO_VICTROOM);

   if (type == TO_CHAR) {
      if (ch && SENDOK(ch))
         perform_act(str, ch, obj, vict_obj, ch);
      return;
   }

   if (type == TO_VICT) {
      if ((to = (struct char_data *) vict_obj) && SENDOK(to) &&
            !(hide_invisible && ch && !CAN_SEE(to, ch))) {
         perform_act(str, ch, obj, vict_obj, to);
      }
      return;
   }
   /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */

   if (ch) {
      if ((ch->in_room != NOWHERE)) {
         in_room = ch->in_room;
      } else {
         log("SYSERR:comm.c:act(): ch->in_room = -1, %s", GET_NAME(ch));
         return;
      }
   } else if ((obj != NULL)) {
      if ((obj->in_room != NOWHERE)) {
         if ((obj->in_room) != 0) {
            in_room = obj->in_room;
         } else {
            log("SYSERR:comm.c:act(): obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
            return;
         }
      } else {/*if here then NO ch and obj->in_room = NOWHERE*/
         log("SYSERR:comm.c:act(): obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
         return;
      }
   } else {
      /* no obj or ch */
      log("SYSERR:comm.c:act(): NULL char and object pointer");
      return;
   }

   if (to_victroom) {
         if (vict_obj) {
            in_room = ((struct char_data *) vict_obj)->in_room;
            if (in_room == NOWHERE) {
               log("SYSERR: act(): TO_VICTROOM option used but vict is in NOWHERE");
               return;
            }
         } else {
            log("SYSERR: act(): TO_VICTROOM option used but vict is NULL");
            return;
         }
   }

   for (to = world[in_room].people; to; to = to->next_in_room)
      if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
            (to != ch) && (type == TO_ROOM || (to != vict_obj)))
         perform_act(str, ch, obj, vict_obj, to);

   /*
    * Reflect TO_ROOM and TO_NOTVICT calls that occur in ARENA rooms
    * into OBSERVATORY rooms, allowing players standing in observatories
    * to watch arena battles safely.
    */
   if (ROOM_FLAGGED(in_room, ROOM_ARENA))
      for (i = 0; i < NUM_OF_DIRS; ++i)
         if (world[in_room].exits[i] &&
             world[in_room].exits[i]->to_room != NOWHERE &&
             world[in_room].exits[i]->to_room != in_room &&
             ROOM_FLAGGED(world[in_room].exits[i]->to_room, ROOM_OBSERVATORY))
            for (to = world[world[in_room].exits[i]->to_room].people; to; to = to->next_in_room)
               if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
                   (to != ch) && (type == TO_ROOM || (to != vict_obj))) {
                  cprintf(to, "&4&8<&0%s&0&4&8>&0 ", world[in_room].name);
                  perform_act(str, ch, obj, vict_obj, to);
               }
}

/* deprecated functions */
void send_to_char(const char *messg, struct char_data *ch)
{
  if (ch->desc && messg && *messg)
    string_to_output(ch->desc, messg);
}

void write_to_output(const char *messg, struct descriptor_data *d)
{
  if (messg && *messg)
    string_to_output(d, messg);
}

void send_to_all(const char *messg) {
  all_printf("%s", messg);
}

void send_to_room(const char *messg, int room) {
  room_printf(room, "%s", messg);
}

void send_to_zone(const char *messg, int zone_vnum, int skip_room, int min_stance) {
  zone_printf(zone_vnum, skip_room, min_stance, "%s", messg);
}

/***************************************************************************
 * $Log: comm.c,v $
 * Revision 1.182  2011/08/18 00:13:14  myc
 * Fix compiler warnings.
 *
 * Revision 1.181  2011/08/06 15:30:22  rsd
 * fixed -  warning: format not a string literal and no format arguments
 * in echo_off and echo_on
 *
 * Revision 1.180  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.179  2009/07/16 19:15:54  myc
 * Moved command stuff from grant.c to commands.c
 *
 * Revision 1.178  2009/06/11 13:36:05  myc
 * Make the exp bar in the prompt work while shapechanged.
 *
 * Revision 1.177  2009/06/10 02:27:14  myc
 * Added an optimization to char_printf and desc_printf which checks
 * to see if the message to be printed has any %'s before attempting
 * to vsnprintf.  This can save some time, but to see whether it's
 * really worth it, we're going to count the number of times each
 * branch is used and log it.
 *
 * Revision 1.176  2009/05/01 05:29:40  myc
 * Make the mud initialize the rules vtable index at boot.
 *
 * Revision 1.175  2009/03/21 19:11:37  myc
 * Add cooldown bar to prompt.
 *
 * Revision 1.174  2009/03/20 23:02:59  myc
 * Get rid of autowiz signal handler.
 *
 * Revision 1.173  2009/03/20 20:19:51  myc
 * Remove dependency on boards.[ch].
 *
 * Revision 1.172  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.171  2009/03/09 05:59:57  myc
 * The mud now keeps track of all previous boot times, including
 * hotboot times.
 *
 * Revision 1.170  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.169  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.168  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.167  2009/03/07 22:30:29  jps
 * Add act flag TO_VICTROOM which makes the message go to the victim's room.
 *
 * Revision 1.166  2009/02/26 17:40:41  rsd
 * Removed the once every 5 minutes tracking of how many
 * people are connected to the mud and recorded in the syslog
 * in nearly 10 years we've never used the data and it's just
 * spam.
 *
 * Revision 1.165  2009/02/21 03:30:16  myc
 * Added hooks for new board system.  Removed L_FILE flag--mprintf
 * now logs to file by default; assert L_NOFILE to prevent that.
 *
 * Revision 1.164  2009/02/16 19:37:21  myc
 * Mobs won't get laryngitis during scripts anymore.
 *
 * Revision 1.163  2009/02/11 17:03:39  myc
 * Adding hooks for new text editor to game_loop, make_prompt, and
 * close_socket.
 *
 * Revision 1.162  2009/02/09 20:09:56  myc
 * Use status_string function to describe health status in prompts.
 *
 * Revision 1.161  2009/02/05 17:15:04  myc
 * Fixing minor bug in send_to_room/room_printf that was sporadically
 * sending the room name along with the message even when not in an arena.
 *
 * Revision 1.160  2009/01/19 08:42:29  myc
 * Added $i and $I to act().
 *
 * Revision 1.159  2009/01/17 00:28:02  myc
 * Fix use of uninitialized variable.
 *
 * Revision 1.158  2008/09/21 21:50:56  jps
 * Stop trying to keep track of who's attacking who when there's a shapechange,
 * since do_shapechange handles that internally now.
 *
 * Revision 1.157  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.156  2008/09/21 05:26:55  myc
 * Added <rmvis> flag to prompt when imms are invis and roomvis.
 *
 * Revision 1.155  2008/09/20 17:37:29  jps
 * Added 'D' format char for act() which provides vict without an article
 * (as a direct object).
 *
 * Revision 1.154  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.153  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.152  2008/09/07 20:07:39  jps
 * Added all_except_printf, which is like all_printf but it avoids one character.
 *
 * Revision 1.151  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.150  2008/08/31 07:16:41  jps
 * Properly abort editing in descs. Ug.
 *
 * Revision 1.149  2008/08/30 04:13:45  myc
 * Replaced the exp_to_level monstrosity with a lookup table that gets
 * populated at boot time.
 *
 * Revision 1.148  2008/08/29 04:16:26  myc
 * Added reference to act.h header file.
 * ..
 *
 * Revision 1.147  2008/08/26 04:39:21  jps
 * Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
 *
 * Revision 1.146  2008/08/25 02:31:30  jps
 * The logic of the act() targets bits didn't fit well with the way
 * the targets were being used, so I undid the change.
 *
 * Revision 1.145  2008/08/25 00:20:33  myc
 * Changed the way mobs memorize spells.
 *
 * Revision 1.144  2008/08/23 14:03:30  jps
 * Changed the way act() messages are targeted. Now there are three basic
 * target flags, which may be or'd together in any combination, plus three
 * modifier flags for sleep, old, and trigger. The old TO_NOTVICT and
 * TO_ROOM targets are defined in terms of the new flags.
 *
 * Revision 1.143  2008/08/14 23:02:11  myc
 * Added vararg capability to all the standard output functions (like
 * send_to_char and write_to_output).  The old functions are still
 * available.  The new ones follow a *printf naming convention.
 * However, removed the send_to_outdoor functionality, and replaced
 * it with callback_printf.
 *
 * Revision 1.142  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.141  2008/08/13 05:53:18  jps
 * Allow NPCs to be affected by laryingitis too.  Ehlissa has corrupted the necromancers.
 *
 * Revision 1.140  2008/07/27 05:30:09  jps
 * Renamed "crash" stuff to "autosave". Renamed save_player to
 * save_player_char.
 *
 * Revision 1.139  2008/07/15 17:49:24  myc
 * Whether you can use a command depends not only on level now, but
 * also on command grants.
 *
 * Revision 1.138  2008/07/13 18:49:29  jps
 * Change the formatting of snoop messages.
 *
 * Revision 1.137  2008/06/19 18:53:12  myc
 * Replaced the item_types string list with a struct array,
 * and added an init_objtypes() function to check values at
 * boot time.
 *
 * Revision 1.136  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.135  2008/06/05 02:07:43  myc
 * Rewrote rent-saving code to use ascii-format files.
 *
 * Revision 1.134  2008/05/26 18:24:48  jps
 * Removed code that deletes player object files.
 *
 * Revision 1.133  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.132  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.131  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.130  2008/04/26 23:35:43  myc
 * Info about permanent effects and race skills are stored in the
 * class/race structs now, but need to be initialized at runtime
 * by the init_races and init_classes functions.
 *
 * Revision 1.129  2008/04/19 20:17:46  jps
 * Add comment at call to perform_mob_violence.
 *
 * Revision 1.128  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.127  2008/04/05 21:42:50  jps
 * Change event calling so that events scheduled for immediate
 * execution will occur before the next pulse.  If they are scheduled
 * during the execution of a player's command, they will be executed
 * before the player's next prompt is printed.
 *
 * Revision 1.126  2008/04/05 16:49:21  myc
 * Fixing conditional color for people who turn color off.
 *
 * Revision 1.125  2008/04/05 05:05:00  myc
 * Reformatted most functions.
 *
 * Revision 1.124  2008/04/04 06:12:52  myc
 * Removed dieites/worship and ships code.
 *
 * Revision 1.123  2008/04/04 05:13:46  myc
 * Removing maputil code.
 *
 * Revision 1.122  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.121  2008/04/02 03:24:44  myc
 * Rewrote group code and removed all major group code.
 *
 * Revision 1.120  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.119  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.118  2008/03/17 15:31:27  myc
 * Shutdown reboot will exit with a normal status code now, and go
 * through normal shutdown routines (like memory checks).
 *
 * Revision 1.117  2008/03/08 22:29:06  myc
 * Moving shapechange and chant to the cooldown systems.
 *
 * Revision 1.116  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.115  2008/03/06 05:11:51  myc
 * Combined the 'saved' and 'unsaved' portions of the char_specials and
 * player_specials structures by moving all fields of each saved structure
 * to its parent structure.  Also combined the skills array from the
 * player and mob structures since they are identical.
 *
 * Revision 1.114  2008/03/06 04:34:38  myc
 * Added a PULSE_AUTOSAVE define that regulates how often autosaves occur.
 *
 * Revision 1.113  2008/03/05 05:21:56  myc
 * Removed some debug logs lines from hotboot.  Bank coins are ints instead
 * of longs now.
 *
 * Revision 1.112  2008/03/05 03:03:54  myc
 * Ascii pfiles change the way players are loaded.
 *
 * Revision 1.111  2008/02/24 17:31:13  myc
 * Added a TO_OLC flag to act() to allow messages to be sent to people
 * while in OLC if they have OLCComm toggled on.
 *
 * Revision 1.110  2008/02/24 06:31:41  myc
 * The world command will now show many hotboots have ocurred since the
 * last shutdown.
 *
 * Revision 1.109  2008/02/16 20:26:04  myc
 * Adding zmalloc, a lightweight memory debugger that wraps all malloc
 * and free calls, keeping track of your memory expenditures.  To be
 * effective, however, we have to free the database and a lot of other
 * stuff at program termination, so adding a lot of functions to do all
 * of that.  Also adding some more prompt codes.
 *
 * Revision 1.108  2008/02/09 18:29:11  myc
 * No need for the name_timeout eventfunc here.
 *
 * Revision 1.107  2008/02/09 07:05:37  myc
 * Copyover is now renamed to hotboot.  Fixed the color codes in the
 * hotboot messages.
 *
 * Revision 1.106  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.105  2008/02/09 03:04:23  myc
 * Adding the 'copyover' command, which allows you to do a hot-boot
 * without disconnecting anybody.
 *
 * Revision 1.104  2008/02/06 21:53:53  myc
 * Make the format arg to act() const.
 *
 * Revision 1.103  2008/02/02 04:27:55  myc
 * Adding time triggers (they execute at a given mud time each day).
 *
 * Revision 1.102  2008/01/30 19:20:57  myc
 * Removing the loopy gravity code from here.  It's now an event.
 *
 * Revision 1.101  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.100  2008/01/29 16:51:12  myc
 * Moving skill names to the skilldef struct.
 *
 * Revision 1.99  2008/01/27 21:09:12  myc
 * Took out the spell circle codes from prompt and adding rage.
 *
 * Revision 1.98  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.97  2008/01/25 21:05:45  myc
 * Added attack() as a macro alias for hit() with fewer arguments.
 *
 * Revision 1.96  2008/01/15 06:51:47  myc
 * Made a change to exp_bar; it now accepts a sub-gradient size.
 *
 * Revision 1.95  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.94  2008/01/09 04:14:19  jps
 * Remove spell mem and scribe funcs now that that's handled by events.
 *
 * Revision 1.93  2008/01/05 05:37:04  jps
 * Changed name of function save_char() to save_player(). Because it
 * only operates on players.
 *
 * Revision 1.92  2008/01/04 04:30:47  jps
 * Made spellcasting into an event.
 *
 * Revision 1.91  2007/12/25 05:21:49  jps
 * Remove comments about trouble with obj_to_room - now alleviated due to
 * improved event code.
 *
 * Revision 1.90  2007/12/20 23:10:39  myc
 * Adding some new prompt control codes:
 *   i/I  hiddenness
 *   a/A  alignment
 *   n    current char's name
 *   N    if switched, original char's name, otherwise current
 *   e    exp TNL in bar form
 *   E    exp progress message
 *   l/L  list of active spells
 * Changed speech_report to just cprintf instead of buffering it.
 *
 * Revision 1.89  2007/12/19 20:45:06  myc
 * Added const modifiers to the char arguments to write_to_output,
 * cprintf, send_to_zone, send_to_room, and parse_color, which
 * allows you to output a const string without casting it.  save_player()
 * no longer requires a save room (which wasn't being used anyway).
 *
 * Revision 1.88  2007/11/28 09:52:19  jps
 * Clean up do_gravity_check() a bit, and hopefully avoid an intermittent
 * crash bug that would strike when a falling object ended up sinking
 * in water.
 *
 * Revision 1.87  2007/11/18 16:51:55  myc
 * Adding OBSERVATORY behavior to send_to_room.
 *
 * Revision 1.86  2007/10/23 20:20:22  myc
 * Modify the casting command handler to allow for use of the pager
 * during casting (for informative commands).
 *
 * Revision 1.85  2007/10/02 02:52:27  myc
 * Fixed idle timer to work for shapechanged druids.
 *
 * Revision 1.84  2007/09/15 15:36:48  myc
 * Removed defunct ITEM_ bitvector flags.  They are duplicating AFF_ flags.
 *
 * Revision 1.83  2007/09/04 06:49:19  myc
 * IN_ZONE macro is now an rnum.  Changed weather function calls.
 *
 * Revision 1.82  2007/08/27 21:18:00  myc
 * You can now queue up commands while casting as well as abort midcast.
 * Casting commands such as look and abort are caught and interpreted
 * before the input is normally queued up by the game loop.
 *
 * Revision 1.81  2007/08/22 18:01:46  jps
 * Reduce the beeping for autoboot warnings. Add warnings at 30, 10,
 * and 5 seconds.
 *
 * Revision 1.80  2007/08/19 18:34:39  jps
 * Don't send falling_yell to the room below.
 *
 * Revision 1.79  2007/08/17 02:23:36  jps
 * Don't let the mud sleep while it's in the automatic reboot warning phase.
 * Otherwise you would have to have someone logged in for it to reboot.
 * Generalized some autobooting code.
 *
 * Revision 1.78  2007/08/14 20:13:57  jps
 * The mud will automatically reboot after a randomized period of time,
 * though powerful deities can delay or prevent this.
 *
 * Revision 1.77  2007/08/14 10:44:05  jps
 * Add functions to keep track of how much players have been communicating
 * and to squelch them with "laryngitis" if they spam too much.
 *
 * Revision 1.76  2007/08/03 22:00:11  myc
 * act() now supports observatories: a room marked observatory that is
 * adjacent to an arena room will see all to_notvict and to_room act
 * calls to the arena room.
 * Also changed perform_act so it returns immediately if the 'to' target
 * doesn't have a descriptor.  This should save some CPU cycles.
 *
 * Revision 1.75  2007/07/25 00:38:03  jps
 * Give send_to_zone a room to skip, and make it use virtual zone number.
 *
 * Revision 1.74  2007/07/24 23:34:00  jps
 * Add a parameter min_position to send_to_zone()
 *
 * Revision 1.73  2007/05/28 06:59:42  jps
 * Removed extra space from end of prompt. Added %- code so that
 * people whose clients give them trouble with trailing spaces
 * can still add one.
 *
 * Revision 1.72  2007/05/24 07:28:34  jps
 * Transmit a surprised yell to surrounding rooms when someone starts to fall.
 *
 * Revision 1.71  2007/04/18 01:02:17  myc
 * Added some new codes to the prompt parser and added some NPC checks so
 * mobs can't use player specific ones.
 *
 * Revision 1.69  2006/11/20 19:52:04  jps
 * Levitate prevents falling damage
 *
 * Revision 1.68  2006/11/14 22:47:10  jps
 * Make sure imms don't fall in flight rooms.
 *
 * Revision 1.67  2006/11/14 21:30:44  jps
 * Stop invis'd gods from being seen by lower level imms as they
 * disconnect from the main menu.
 *
 * Revision 1.66  2006/11/13 15:54:22  jps
 * Fix implementation of hide_informative parameter to act(), when
 * the target is TO_VICT.
 *
 * Revision 1.65  2006/11/13 02:51:02  jps
 * Fix illegal pointer access.
 *
 * Revision 1.64  2006/11/10 21:00:26  jps
 * Update act() to accept $U, $u and some other format codes.
 *
 * Revision 1.63  2006/04/01 21:46:23  rls
 * Modified gravity to allow arial combat.  Simplistic hack really...
 * using aff_flying as the check rather than pos_flying (logically)
 *
 * Revision 1.62  2004/11/11 23:02:23  rsd
 * Added additional char stars for the Banning message to
 * the descriptor output because the original message was
 * to large for the compiler to not complain about
 *
 * Revision 1.61  2003/04/16 02:00:22  jjl
 * Added skill timers for Zzur.  They don't save to file, so they were a
 * quickie.
 *
 * Revision 1.60  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.59  2002/08/29 17:29:03  rsd
 * added a check for CON_ISPELL_BOOT for a password checking
 * state to be kicked offline if idle to long.
 *
 * Revision 1.58  2002/04/17 22:41:06  dce
 * Added attacker = null; to prevent shapechanged players
 * from crashing the mud.
 *
 * Revision 1.57  2001/12/09 14:08:32  dce
 * Had to add the d->character check for the shapechange thing
 * in close_socket.
 *
 * Revision 1.56  2001/12/07 02:09:56  dce
 * Linkdead players will now lose exp when they die.
 * Linkdead shapechanged players will now shapechange
 * to their original form before linking out.
 *
 * Revision 1.55  2001/05/17 02:55:38  dce
 * Fixed crash bug with menu timeout.
 *
 * Revision 1.54  2001/05/17 02:45:49  dce
 * Fixed a crash bug around saving a character at check_idle_passwords
 *
 * Revision 1.53  2001/05/13 16:15:58  dce
 * Fixed a bug where somethings wouldn't save when a player
 * died and exitied menu option 0 rather than menu option 1.
 *
 * Revision 1.52  2001/05/03 01:26:16  dce
 * Players now timeout at the menu screen.
 *
 * Revision 1.51  2001/03/14 19:04:59  rsd
 * made the default for ooc ON again.
 *
 * Revision 1.50  2001/03/09 03:05:21  dce
 * Fixed it so that immortals do not get booted out of shapechanged
 * form no matter what their alignment is.
 *
 * Revision 1.49  2001/03/06 03:10:18  dce
 * Fixed a bug where players awaiting a name approval could
 * cut their link and then crash the mud.
 *
 * Revision 1.48  2001/03/04 17:33:19  dce
 * Fixed the falling problem where players would not
 * gain hp after falling. Also fixed the problem where
 * players could cast while sitting after falling.
 *
 * Revision 1.47  2001/03/03 18:08:20  dce
 * Minor fix for shapechange
 *
 * Revision 1.46  2001/02/24 16:47:31  dce
 * Changes made for shapechange. Shapechange uses the chant
 * variable to limit its use.
 *
 * Revision 1.45  2001/01/23 01:51:46  rsd
 * turned off occ by detault
 *
 * Revision 1.44  2000/11/28 01:36:34  mtp
 * remveove last vestiges of mobprgos (damn these things get around)
 *
 * Revision 1.43  2000/11/28 01:19:01  mtp
 * remove process_events() (replaced dg_event code with events.c code)
 * removed mobprog references
 *
 * Revision 1.42  2000/11/20 19:43:45  rsd
 * added back rlog messages from prior to the $log$ string.
 *
 * Revision 1.41  2000/11/15 22:55:01  rsd
 * changed a perror() to a log()
 *
 * Revision 1.40  2000/04/14 00:47:00  rsd
 * Added some spanky code to send banned players a message about
 * being banned, also added something to the log message to make
 * it bloody obvious someone banned tried to connect...
 *
 * Revision 1.39  2000/04/02 02:38:23  rsd
 * Added the comment header while I was browsing for information.
 * I also fixed bracket problems in the social section and re-tabbed
 * that part of the function.
 *
 * Revision 1.38  2000/03/20 04:28:47  rsd
 * added comments regarding my_signal(SIGUSR1, reread_wizlists)
 *
 * Revision 1.37  2000/02/14 05:13:23  jimmy
 * Fixed hupsig signal to not exit the instant it received a SIGHUP.
 * The mud now shuts down cleanly.
 *
 * Revision 1.36  1999/11/28 22:55:42  cso
 * *** empty log message ***
 *
 * Revision 1.35  1999/10/06 17:53:01  rsd
 * Added afk to the beginning of the prompt and cmc added
 * wizinvis and afk into the prompt properly.
 *
 * Revision 1.34  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.33  1999/08/12 18:21:47  dce
 * Potential lock out bug.
 * Mud times out connections waiting at ANSI prompt.
 *
 * Revision 1.32  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.31  1999/07/26 03:49:00  jimmy
 * added debug to help with pfile problems
 *
 * Revision 1.30  1999/07/09 22:30:27  jimmy
 * Attempt to control the spiraling of memory.  Added a free() to the
 * prompt code in comm.c to free memory allocated by parse_color().
 * made a global structure dummy_mob and malloc'ed it for mobs
 * to share as their player_specials to cut memory.
 * gurlaek
 *
 * Revision 1.29  1999/07/09 13:57:00  mud
 * Changed missed reference to HUBIS to Fiery
 *
 * Revision 1.28  1999/07/09 02:59:46  jimmy
 * doh, forgot to recompile after commenting. Stupid parse error.
 *
 * Revision 1.27  1999/07/09 02:38:50  jimmy
 * rewrote parse_color() to fix silly overflows due to an estimation of the
 * length of the converted ansi string.  The function now does not malloc
 * until the string has been converted and is in it's final form.
 * --gurlaek 7/8/1999
 *
 * Revision 1.26  1999/07/02 21:58:04  jimmy
 * Highely modified worship.c/h to change from many small functions that
 * were passes as (void *) to 4 large functions that use switch().  This
 * was done to remove the warnings produced by the -pedantic compiler flag.
 * divine_intervention was also commented out for now in comm.c because we
 * don't currently use it anyway. --Gurlaek 7/2/1999
 *
 * Revision 1.25  1999/06/11 16:56:55  jimmy
 * date: 1999/06/11 16:56:55;  author: jimmy;  state: Exp;  lines: +1 -1
 * Ok, fixed do_quit to check for fighting and also not crash when mortally
 * wounded.  This was done in die() by checking for killer=NULL.
 * since no one killed you if you quit while morted the die code
 * didn't know how to deal with a NULL killer.
 * --Gurlaek 6/11/1999
 *
 * Revision 1.24  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
 * --Gurlaek 6/10/1999
 *
 * Revision 1.23  1999/04/23 23:27:10  jimmy
 * Fixed warnings/errors associated with the addition of the pendantic compiler flag
 * yeeeeehaaawwww.  --gurlaek
 *
 * Revision 1.22  1999/04/23 21:35:11  jimmy
 * fixed typecast of int i to work with the accept() function
 * in  new_descriptor().
 * -- Gurlaek
 *
 * Revision 1.21  1999/04/16 20:50:34  dce
 * Attempt to fix parse_color bug
 *
 * Revision 1.20  1999/04/10 06:04:52  dce
 * Testing
 *
 * Revision 1.19  1999/04/10 05:53:40  jen
 * sigh
 *
 * Revision 1.18  1999/04/10 05:13:48  jen
 * Revisions w/ debug info
 *
 * Revision 1.17  1999/04/10 05:05:58  jen
 * Revision for testing #1
 *
 * Revision 1.16  1999/04/09 23:19:49  jen
 * An attempt to fix a core dump when perform_act handles
 * i = "someone"; I think more drastic measures may be needed
 * but this is a first shot.
 *
 * Revision 1.15  1999/04/05 19:37:55  jen
 * Redone cap code... using toupper fn instead of CAP macro
 *
 * Revision 1.14  1999/04/05 19:01:05  jen
 * Commented out the car needscap :p
 *
 * Revision 1.13  1999/04/05 18:55:46  jen
 * Backed out the capitalization code until
 * I can figure out why it's crashing sometimes.
 *
 * Revision 1.12  1999/04/02 17:07:06  jen
 * Fixes the problem with mobs telling you stuff (or conceivably any
 * instance where an 'act' string is parsed with a $n for a mob at
 * the beginning - i.e. '$n tells you') ... it capitalizes the first
 * char of the mob name in that instance only.
 *
 * Selina
 *
 * Revision 1.11  1999/03/26 19:47:10  jen
 * Added a mortal gossip channel with 103+ godly control
 *
 * Revision 1.10  1999/03/21 21:18:12  dce
 * Fixed a Hubis crash bug.
 *
 * Revision 1.9  1999/03/12 19:44:42  jimmy
 * Updated debug messages in comm.c and handler.c to include
 * more useful info, as well as adding an abort where exit
 * used to be in order to get a core.
 * fingon
 *
 * Revision 1.8  1999/03/08 20:22:35  dce
 * Adds the skill safefall for monks.
 *
 * Revision 1.7  1999/03/06 23:51:54  dce
 * Add's chant songs, and can only chant once every four hours
 *
 * Revision 1.6  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.5  1999/02/24 22:59:35  jimmy
 * Fixed gravity code to handle IN_FLIGHT rooms with no down exits.
 * Also added fix for air rooms over water as well as semantics
 * for splashing and sinking.
 * fingon
 *
 * Revision 1.4  1999/02/07 06:46:21  jimmy
 * fixed silly div by zero in the prompt code
 * fingon
 *
 * Revision 1.3  1999/01/30 19:42:27  mud
 * Indented entire file
 *
 * Revision 1.2  1999/01/29 05:42:00  jimmy
 * ixed AFF_FLYING to GET_POS(ch) == POS_FLYING for gravity
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.182
log
@Fix compiler warnings.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.181 2011/08/06 15:30:22 rsd Exp myc $
a299 1
    free(ships);
d2998 3
@


1.181
log
@fixed -  warning: format not a string literal and no format arguments
in echo_off and echo_on
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.180 2010/06/05 14:56:27 mud Exp $
d96 2
a97 2
extern long reboot_pulse;
extern int reboot_warning_minutes;
d115 1
a115 1
unsigned long global_pulse = 0; /* number of pulses since game start */
d118 1
a118 1
unsigned long pulse = 0;        /* number of pulses since game started */
d144 1
a144 1
void heartbeat(int pulse);
d409 1
a409 1
  extern long reboot_pulse;
d805 2
a806 1
  int missed_pulses, maxdesc, aliased;
a1000 5
    if (missed_pulses <= 0) {
      log("SYSERR: MISSED_PULSES IS NONPOSITIVE!!!");
      missed_pulses = 1;
    }

d1019 1
a1019 1
void heartbeat(int pulse)
d2999 4
@


1.180
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.179 2009/07/16 19:15:54 myc Exp mud $
d1176 1
a1176 1
  dprintf(d, off_string);
d1193 1
a1193 1
  dprintf(d, on_string);
d3003 3
@


1.179
log
@Moved command stuff from grant.c to commands.c
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.178 2009/06/11 13:36:05 myc Exp myc $
d58 1
d3003 3
@


1.178
log
@Make the exp bar in the prompt work while shapechanged.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.177 2009/06/10 02:27:14 myc Exp myc $
d59 1
a59 1
#include "grant.h"
d3002 3
@


1.177
log
@Added an optimization to char_printf and desc_printf which checks
to see if the message to be printed has any %'s before attempting
to vsnprintf.  This can save some time, but to see whether it's
really worth it, we're going to count the number of times each
branch is used and log it.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.176 2009/05/01 05:29:40 myc Exp myc $
d1303 1
a1303 1
          cur += sprintf(cur, "%s", exp_bar(ch, 20, 20, 20, color));
d1307 1
a1307 1
          cur += sprintf(cur, "%s", exp_message(ch));
d3002 7
@


1.176
log
@Make the mud initialize the rules vtable index at boot.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.175 2009/03/21 19:11:37 myc Exp myc $
d1615 3
d1619 10
a1628 4
    va_start(args, txt);
    vsnprintf(comm_buf, sizeof(comm_buf), txt, args);
    va_end(args);
    string_to_output(t, comm_buf);
d1630 7
d2404 3
d2408 10
a2417 4
    va_start(args, messg);
    vsnprintf(comm_buf, sizeof(comm_buf), messg, args);
    va_end(args);
    string_to_output(ch->desc, comm_buf);
d2419 7
d3002 3
@


1.175
log
@Add cooldown bar to prompt.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.174 2009/03/20 23:02:59 myc Exp myc $
d65 1
d268 1
d2970 3
@


1.174
log
@Get rid of autowiz signal handler.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.173 2009/03/20 20:19:51 myc Exp myc $
d1194 8
d1205 2
a1206 1
  int expecting, color, temp, pre_length = 0;
d1246 2
a1247 11
  /* Expecting?
   *
   * 0    Default; not expecting anything in particular.
   * 1    Last char was a %; next one is a control code.
   * 2    Last two chars were %p; next one is a control code (for percent).
   * 3    Last two chars were %c; next one is a control code (for coins).
   */
  expecting = 0;
  block[0] = '\0';
  while (*raw) {
    if (expecting == 0) {
d1250 1
a1250 1
        expecting = 1;
d1255 1
a1255 1
    else if (expecting == 1) {
d1257 1
a1257 1
      expecting = 0;
d1295 4
d1328 1
a1328 1
          expecting = 2;
d1333 1
a1333 1
          expecting = 3;
d1407 2
a1408 1
    else if (expecting == 2) {
d1427 1
a1427 2
          expecting = 0;
          break;
d1429 1
a1429 3
      if (expecting)
        cur += sprintf(cur, "%d%%", temp);
      expecting = 0;
d1431 18
a1448 2
    else if (expecting == 3) {
      expecting = 0;
d1450 9
a1458 24
        case 'p':
          cur += sprintf(cur, "%d", GET_PLATINUM(ch));
          break;
        case 'g':
          cur += sprintf(cur, "%d", GET_GOLD(ch));
          break;
        case 's':
          cur += sprintf(cur, "%d", GET_SILVER(ch));
          break;
        case 'c':
          cur += sprintf(cur, "%d", GET_COPPER(ch));
          break;
        case 'P':
          cur += sprintf(cur, "%d", GET_BANK_PLATINUM(ch));
          break;
        case 'G':
          cur += sprintf(cur, "%d", GET_BANK_GOLD(ch));
          break;
        case 'S':
          cur += sprintf(cur, "%d", GET_BANK_SILVER(ch));
          break;
        case 'C':
          cur += sprintf(cur, "%d", GET_BANK_COPPER(ch));
          break;
d1460 1
a1461 2
    /* Move on to the source next character. */
    ++raw;
d2968 3
@


1.173
log
@Remove dependency on boards.[ch].
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.172 2009/03/09 20:36:00 myc Exp myc $
d2254 1
a2254 1
RETSIGTYPE reread_wizlists()
d2256 2
a2257 4
  void reboot_wizlists(void);

  mprintf(L_STAT, LVL_IMMORT, "Signal received - rereading wizlists.");
  reboot_wizlists();
d2326 1
a2326 1
  my_signal(SIGUSR1, reread_wizlists);
d2966 3
@


1.172
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.171 2009/03/09 05:59:57 myc Exp myc $
a50 1
#include "boards.h"
a289 1
    board_clear_all();                /* boards.c */
d2968 3
@


1.171
log
@The mud now keeps track of all previous boot times, including
hotboot times.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.170 2009/03/09 05:41:31 jps Exp myc $
d1336 1
a1336 1
                  GET_PLAT(ch), GET_GOLD(ch),
d1342 1
a1342 1
                  GET_BANK_PLAT(ch), GET_BANK_GOLD(ch),
d1435 1
a1435 1
          cur += sprintf(cur, "%d", GET_PLAT(ch));
d1447 1
a1447 1
          cur += sprintf(cur, "%d", GET_BANK_PLAT(ch));
d2970 4
@


1.170
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.169 2009/03/09 04:33:20 jps Exp jps $
d93 1
a119 1
int num_hotboots = 0;           /* Are we doing a hotboot? */
d318 1
d320 1
a320 1
  extern time_t boot_time;
d336 11
a346 2
  fscanf(fp, "%ld %d\n", &boot_time, &num_hotboots);
  ++num_hotboots;
d2970 3
@


1.169
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.168 2009/03/08 23:34:14 jps Exp jps $
d65 1
d2960 4
@


1.168
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.167 2009/03/07 22:30:29 jps Exp jps $
d64 1
d2959 3
@


1.167
log
@Add act flag TO_VICTROOM which makes the message go to the victim's room.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.166 2009/02/26 17:40:41 rsd Exp jps $
d47 1
a47 1
#include "spells.h"
d2958 3
@


1.166
log
@Removed the once every 5 minutes tracking of how many
people are connected to the mud and recorded in the syslog
in nearly 10 years we've never used the data and it's just
spam.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.165 2009/02/21 03:30:16 myc Exp $
d2827 1
a2827 1
   int sleep, olc, in_room, i;
d2851 3
d2894 13
d2958 6
@


1.165
log
@Added hooks for new board system.  Removed L_FILE flag--mprintf
now logs to file by default; assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.164 2009/02/16 19:37:21 myc Exp myc $
d1061 6
a1066 3

  if (!(pulse % (5 * 60 * PASSES_PER_SEC)))        /* 5 minutes */
    record_usage();
d2942 4
@


1.164
log
@Mobs won't get laryngitis during scripts anymore.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.163 2009/02/11 17:03:39 myc Exp myc $
d52 1
d289 2
a290 1
    board_clear_all();                /* board.c */
d1764 1
a1764 1
    mprintf(L_STAT | L_FILE, LVL_GOD, "BANNED: Connection attempt denied from [%s]", newd->host);
d2138 1
a2138 1
      mprintf(L_STAT | L_FILE, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
d2144 1
a2144 1
        mprintf(L_STAT | L_FILE, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
d2147 1
a2147 1
        mprintf(L_STAT | L_FILE, LVL_IMMORT, "Losing player: <null>.");
d2153 1
a2153 1
    mprintf(L_INFO | L_FILE, LVL_IMMORT, "Losing descriptor without char.");
d2245 1
a2245 1
  mprintf(L_STAT | L_FILE, LVL_IMMORT, "Signal received - rereading wizlists.");
d2253 1
a2253 1
  mprintf(L_WARN | L_FILE, LVL_IMMORT,
d2506 1
a2506 1
    mprintf(L_ERR | L_FILE, LVL_GOD, "SYSERR: bad room rnum %d passed to send_to_room", roomnum);
d2939 3
@


1.163
log
@Adding hooks for new text editor to game_loop, make_prompt, and
close_socket.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.162 2009/02/09 20:09:56 myc Exp myc $
d2577 1
d2600 6
d2937 4
@


1.162
log
@Use status_string function to describe health status in prompts.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.161 2009/02/05 17:15:04 myc Exp myc $
d62 1
d934 2
d943 2
a944 4
          else {
            if (perform_alias(d, comm))                /* run it through aliasing system */
              get_from_q(&d->input, comm, &aliased);
          }
d1468 1
a1468 1
  else if (d->str)
d1504 4
d2120 3
d2133 1
a2133 1
    if (d->connected == CON_PLAYING) {
d2139 2
a2140 1
    } else {/*markquit*/
d2149 2
a2150 1
  } else
d2930 3
@


1.161
log
@Fixing minor bug in send_to_room/room_printf that was sporadically
sending the room name along with the message even when not in an arena.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.160 2009/01/19 08:42:29 myc Exp myc $
d1329 3
a1331 12
          if (vict) {
            temp = (100 * GET_HIT(vict)) / MAX(1, GET_MAX_HIT(vict));
            cur += snprintf(cur, 255, "%s &0(%s&0)", PERS(vict, ch),
                    temp >= 100 ? "&2Excellent" :
                    temp >= 88 ? "&3scratches" :
                    temp >= 75 ? "&3&bsmall wounds" :
                    temp >= 50 ? "&5&bfew wounds" :
                    temp >= 30 ? "&5nasty wounds" :
                    temp >= 15 ? "&1&bpretty hurt" :
                    temp >= 0 ? "&1awful condition" :
                    "&1bleeding awfully");
          }
d1340 1
a1340 2
          if (vict && (tank = FIGHTING(vict))) {
            temp = (100 * GET_HIT(tank)) / MAX(1, GET_MAX_HIT(tank));
d1342 1
a1342 9
                    temp >= 100 ? "&2Excellent" :
                    temp >= 88 ? "&3scratches" :
                    temp >= 75 ? "&3&bsmall wounds" :
                    temp >= 50 ? "&5&bfew wounds" :
                    temp >= 30 ? "&5nasty wounds" :
                    temp >= 15 ? "&1&bpretty hurt" :
                    temp >= 0 ? "&1awful condition" :
                    "&1bleeding awfully");
          }
d1350 1
a1350 2
          if (ch->group_master) {
            temp = (100 * GET_HIT(ch->group_master)) / MAX(1, GET_MAX_HIT(ch->group_master));
d1352 3
a1354 9
                    temp >= 100 ? "&2Excellent" :
                    temp >= 88 ? "&3scratches" :
                    temp >= 75 ? "&3&bsmall wounds" :
                    temp >= 50 ? "&5&bfew wounds" :
                    temp >= 30 ? "&5nasty wounds" :
                    temp >= 15 ? "&1&bpretty hurt" :
                    temp >= 0 ? "&1awful condition" :
                    "&1bleeding awfully");
          }
d2920 4
@


1.160
log
@Added $i and $I to act().
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.159 2009/01/17 00:28:02 myc Exp myc $
a2524 1
      rmnmlen = 0;
d2533 1
d2554 1
a2554 1
            cprintf(i, comm_buf);
d2897 1
a2897 1
   perform_act(str, ch, obj, vict_obj, to);
d2904 1
a2904 3
   if (ROOM_FLAGGED(in_room, ROOM_ARENA)) {
      char rbuf[MAX_INPUT_LENGTH];

d2913 1
a2913 2
                  sprintf(rbuf, "&4&8<&0%s&0&4&8>&0 ", world[in_room].name);
                  cprintf(to, rbuf);
a2915 1
   }
d2945 3
@


1.159
log
@Fix use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.158 2008/09/21 21:50:56 jps Exp myc $
d2705 1
a2705 1
   char lbuf[MAX_STRING_LENGTH], *buf, *j;
d2762 3
d2768 2
a2769 2
            case 't':
               CHECK_NULL(obj, (const char *) obj);
d2774 8
d2949 3
@


1.158
log
@Stop trying to keep track of who's attacking who when there's a shapechange,
since do_shapechange handles that internally now.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.157 2008/09/21 20:40:40 jps Exp jps $
d2525 1
d2938 4
@


1.157
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.156 2008/09/21 05:26:55 myc Exp jps $
a2092 1
  struct char_data *attacker;
d2109 1
a2109 11
    attacker = NULL;
    if (POSSESSED(d->character)) {
      if (FIGHTING(d->character)) {
        /* NO NO NO - we're making a character shapechange back to its normal
         * form, and trying to make sure that anyone who was fighting it will
         * continue to fight the normal-form character.  This logic is duplicated
         * here and in interpreter.c. It should be an integral part of do_shapechange,
         * or at least be in a function called FROM THERE. */
        attacker = d->character->attackers;
        stop_battling(d->character);
      }
a2110 3
      if (attacker)
        set_fighting(attacker, d->character, TRUE);
    }
d2937 4
@


1.156
log
@Added <rmvis> flag to prompt when imms are invis and roomvis.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.155 2008/09/20 17:37:29 jps Exp myc $
d2113 7
a2119 2
        attacker = d->character->char_specials.fighting;
        stop_fighting(d->character);
d2123 1
a2123 1
        attack(attacker, d->character);
d2951 3
@


1.155
log
@Added 'D' format char for act() which provides vict without an article
(as a direct object).
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.154 2008/09/20 06:05:06 jps Exp jps $
d1209 2
d2946 4
@


1.154
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.153 2008/09/09 08:23:37 jps Exp jps $
d2740 4
d2944 3
@


1.153
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.152 2008/09/07 20:07:39 jps Exp jps $
d2106 1
a2106 2
  /* Shapechange a player back to normal form
     DCE 06-DEC-2001 */
d2109 1
a2109 1
    if (d->character->desc && d->character->desc->original) {
d2601 1
a2601 1
   if (IS_NPC(ch) && ch->desc && ch->desc->original) {
d2660 1
a2660 1
   if (IS_NPC(tch) && tch->desc && tch->desc->original) {
d2692 1
a2692 1
   if (IS_NPC(ch) && ch->desc && ch->desc->original) {
d2940 3
@


1.152
log
@Added all_except_printf, which is like all_printf but it avoids one character.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.151 2008/09/01 23:47:49 jps Exp jps $
d2500 1
a2500 1
        OUTSIDE(i->character) && IN_ZONE_RNUM(i->character) == zone_num &&
d2941 3
@


1.151
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.150 2008/08/31 07:16:41 jps Exp jps $
d2449 20
d2941 3
@


1.150
log
@Properly abort editing in descs. Ug.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.149 2008/08/30 04:13:45 myc Exp jps $
a161 1
void dismount_char(struct char_data * ch);
d2921 3
@


1.149
log
@Replaced the exp_to_level monstrosity with a lookup table that gets
populated at boot time.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.148 2008/08/29 04:16:26 myc Exp myc $
d2131 14
d2922 4
@


1.148
log
@Added reference to act.h header file.
..
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.147 2008/08/26 04:39:21 jps Exp myc $
d269 1
d2908 4
@


1.147
log
@Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.146 2008/08/25 02:31:30 jps Exp jps $
d61 1
d383 1
a383 1
      look_at_room(d->character, 0);
a1183 2
  extern char *exp_message(struct char_data *ch);
  extern char *exp_bar(struct char_data *ch, int length, int gradations, int sub_gradations, bool color);
d2907 3
@


1.146
log
@The logic of the act() targets bits didn't fit well with the way
the targets were being used, so I undid the change.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.145 2008/08/25 00:20:33 myc Exp jps $
d2389 1
a2389 1
void zone_printf(int zone_num, int skip_room, int min_stance, const char *messg, ...)
d2394 1
d2404 1
a2404 1
        IN_ZONE(i->character) == zone_num) {
d2467 1
a2467 1
        OUTSIDE(i->character) && IN_ZONE(i->character) == zone_num &&
d2908 4
@


1.145
log
@Changed the way mobs memorize spells.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.144 2008/08/23 14:03:30 jps Exp myc $
d2785 1
a2785 2
void act(const char *str, bool hide_invisible, struct char_data *ch,
      struct obj_data *obj, const void *vict_obj, int targets)
d2792 2
a2793 3
   dg_act_check = targets & DG_NO_TRIG;
   sleep = targets & TO_SLEEP;
   olc = targets & TO_OLC;
d2795 21
a2815 2
   if (targets & TO_CHAR && ch && SENDOK(ch)) {
      perform_act(str, ch, obj, vict_obj, ch);
d2818 5
a2822 6
   if (targets & TO_VICT && (to = (struct char_data *) vict_obj) && SENDOK(to) &&
         !(hide_invisible && ch && !CAN_SEE(to, ch)))
      perform_act(str, ch, obj, vict_obj, to);

   /* Nothing left to do but send the message to others, if so desired. */
   if (!(targets & TO_OTHERS))
d2824 2
d2854 2
a2855 2
            to != ch && to != vict_obj)
         perform_act(str, ch, obj, vict_obj, to);
d2858 3
a2860 2
    * Propagate TO_OTHERS calls that occur in ARENA rooms into OBSERVATORY
    * rooms, allowing players standing in observatories to watch arena battles safely.
d2872 1
a2872 1
                     to != ch && (targets & TO_VICT || (to != vict_obj))) {
d2907 3
@


1.144
log
@Changed the way act() messages are targeted. Now there are three basic
target flags, which may be or'd together in any combination, plus three
modifier flags for sleep, old, and trigger. The old TO_NOTVICT and
TO_ROOM targets are defined in terms of the new flags.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.143 2008/08/14 23:02:11 myc Exp jps $
a154 1
void casting_gain(void);
a1046 1
    casting_gain();
d2888 6
@


1.143
log
@Added vararg capability to all the standard output functions (like
send_to_char and write_to_output).  The old functions are still
available.  The new ones follow a *printf naming convention.
However, removed the send_to_outdoor functionality, and replaced
it with callback_printf.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.142 2008/08/14 09:45:22 jps Exp myc $
d2787 2
a2788 1
void act(const char *str, int hide_invisible, struct char_data *ch, struct obj_data *obj, const void *vict_obj, int type)
d2795 3
a2797 2
   if (!(dg_act_check = !IS_SET(type, DG_NO_TRIG)))
      REMOVE_BIT(type, DG_NO_TRIG);
d2799 3
a2801 10
   /*
    * Warning: the following TO_SLEEP code is a hack.
    *
    * I wanted to be able to tell act to deliver a message regardless of sleep
    * without adding an additional argument.  TO_SLEEP is 128 (a single bit
    * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
    * command.  It's not legal to combine TO_x's with each other otherwise.
    *
    * The TO_OLC flag is also a hack.
    */
d2803 3
a2805 11
   if ((olc = IS_SET(type, TO_OLC)))
      REMOVE_BIT(type, TO_OLC);

   if ((sleep = IS_SET(type, TO_SLEEP)))
      REMOVE_BIT(type, TO_SLEEP);

   if (type == TO_CHAR) {
      if (ch && SENDOK(ch))
         perform_act(str, ch, obj, vict_obj, ch);
      return;
   }
d2807 2
a2808 5
   if (type == TO_VICT) {
      if ((to = (struct char_data *) vict_obj) && SENDOK(to) &&
            !(hide_invisible && ch && !CAN_SEE(to, ch))) {
         perform_act(str, ch, obj, vict_obj, to);
      }
a2809 2
   }
   /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */
d2838 2
a2839 2
            (to != ch) && (type == TO_ROOM || (to != vict_obj)))
   perform_act(str, ch, obj, vict_obj, to);
d2842 2
a2843 3
    * Reflect TO_ROOM and TO_NOTVICT calls that occur in ARENA rooms
    * into OBSERVATORY rooms, allowing players standing in observatories
    * to watch arena battles safely.
d2855 1
a2855 1
                   (to != ch) && (type == TO_ROOM || (to != vict_obj))) {
d2890 7
@


1.142
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.141 2008/08/13 05:53:18 jps Exp jps $
d95 1
a190 1
  char buf[512];
d238 1
a238 2
      sprintf(buf, "SYSERR: Unknown option -%c in argument string.", *(argv[pos] + 1));
      log(buf);
d261 1
a261 2
  sprintf(buf, "Using %s as data directory.", dir);
  log(buf);
d273 1
a273 2
    sprintf(buf, "Running game on port %d.", port);
    log(buf);
d449 1
a449 2
        sprintf(buf, "OLC: Illegal save type %d!", entry->type);
        log(buf);
d451 1
a451 2
        sprintf(buf, "OLC: Illegal save zone %d!", entry->zone);
        log(buf);
d453 3
a455 4
        sprintf(buf, "OLC: Reboot saving %s for zone %d.",
          save_info_msg[(int)entry->type], entry->zone);
          log(buf);
          switch (entry->type) {
d509 1
a509 2
    sprintf(buf, "Max players set to %d", max_players);
    log(buf);
d641 1
a641 1
    sprintf(buf, "Non-positive max player limit!  (Set at %d using %s).",
a642 1
    log(buf);
d645 1
a645 2
  sprintf(buf, "Setting player limit to %d using %s.", max_descs, method);
  log(buf);
d655 19
a673 19
  send_to_all("Rebooting.. come back in a minute or two.\r\n"
              "           &1&b** ****** ****&0\r\n"
              "         &1&b**&0 &3&b***     *****&0  &1&b**&0\r\n"
              "       &1&b**&0 &3&b**      &1&b*&0     &3&b***&0  &1&b*&0\r\n"
              "       &1&b*&0    &3&b** **   *   *  *&0 &1&b**&0\r\n"
              "      &1&b*&0  &3&b** * *&0          &1&b*&0     &1&b*&0\r\n"
              "      &1&b*&0  &3&b*&0    &1&b**&0            &3&b* *&0 &1&b*&0\r\n"
              "     &1&b*&0 &3&b* &1&b** *&0     &3&b*   ******&0  &1&b*&0\r\n"
              "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n");
  send_to_all("        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
              "         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
              "                &1&b*&0   &3&b*&0 &1&b*&0\r\n"
              "               &1&b*&0  &3&b* *&0  &1&b*&0\r\n"
              "              &1&b*&0  &3&b*  **&0  &1&b*&0\r\n"
              "              &1&b*&0 &3&b**   *&0 &1&b*&0\r\n"
              "                &1&b*&0 &3&b*&0 &1&b*&0\r\n"
              "                &1&b*&0 &3&b*&0  &1&b**&0\r\n"
              "               &1&b**&0     &1&b****&0\r\n"
              "              &1&b***&0  &3&b* *&0    &1&b****&0\r\n");
d689 1
a689 1
         sprintf(buf, "\r\n\007&4&b***&0 &7&b%d second%s to reboot&0 &4&b***&0\r\n",
d692 1
a692 1
         sprintf(buf, "\r\n\007&1&b*&3&bATTENTION&1&b*&0  The mud will &7&bREBOOT&0 in &6&b%d minute%s&0  &1&b*&3&bATTENTION&1&b*&0\r\n",
a694 1
      send_to_char(buf, ch);
d700 1
a700 1
   sprintf(buf, "&1&b*&3&bATTENTION&1&b*&0  The mud will &7&bREBOOT&0 in &6&b%d minute%s&0  &1&b*&3&bATTENTION&1&b*&0\r\n",
a701 1
   send_to_all(buf);
d710 1
a710 1
      send_to_all("&6*** Automatic Reboot Postponed ***&0\r\n");
d712 1
a712 1
      send_to_all("&6&b*** Automatic Reboot Cancelled ***&0\r\n");
d718 1
a718 1
         send_to_all("*** Mortal logins reenabled ***\r\n");
d761 1
a761 1
            send_to_all("*** No more mortal logins ***\r\n");
d769 1
a769 1
            sprintf(buf, "&4&b*&0 &7&b%d second%s to reboot&0 &4&b*&0\r\n",
a770 1
            send_to_all(buf);
d944 1
a944 1
          write_to_output("\r\n",d);
d1132 1
a1132 1
  sprintf(buf, "nusage: %-3d sockets connected, %-3d sockets playing",
a1133 1
  log(buf);
d1140 1
a1140 1
    sprintf(buf, "rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
a1141 1
    log(buf);
d1158 1
a1158 1
  write_to_output(off_string, d);
d1175 1
a1175 1
  write_to_output(on_string, d);
d1215 1
a1215 1
    if(pre_length) {
d1231 1
a1231 1
  while(*raw) {
d1481 6
d1489 1
a1489 2
    sprintf(prompt,
            "\r[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
d1551 1
a1551 1
  write_to_output("\r\n", d);
d1612 13
d1626 1
a1626 1
void write_to_output(const char *txt, struct descriptor_data *t)
d1629 4
a1632 1
  static char new_txt[MAX_STRING_LENGTH];
a1730 1
  extern char *ANSI;
d1780 1
a1780 1
    sprintf(buf,"\r\n Connection logged from: %s\r\n\r\n", newd->host);
d1783 1
a1783 2
    sprintf(buf2, "BANNED: Connection attempt denied from [%s]", newd->host);
    mudlog(buf2, CMP, LVL_GOD, TRUE);
d1789 1
a1789 2
  sprintf(buf2, "New connection from [%s]", newd->host);
  mudlog(buf2, CMP, LVL_GOD, FALSE);
d1798 1
a1798 1
  write_to_output(ANSI, newd);
d1833 2
a1834 5
  if (t->snoop_by) {
    write_to_output("&2((&0 ", t->snoop_by);
    write_to_output(t->output, t->snoop_by);
    write_to_output("&2))&0", t->snoop_by);
  }
d1992 1
a1992 2

      sprintf(buffer, "Line too long.  Truncated to:\r\n%s\r\n", tmp);
d1996 2
a1997 5
    if (t->snoop_by) {
      write_to_output("&6>>&b ", t->snoop_by);
      write_to_output(tmp, t->snoop_by);
      write_to_output("&0\r\n", t->snoop_by);
    }
d2056 1
a2056 1
    write_to_output("Invalid substitution.\r\n", t);
d2065 1
a2065 1
    write_to_output("Invalid substitution.\r\n", t);
a2092 1
  char buf[128];
d2105 1
a2105 1
    write_to_output("Your victim is no longer among us.\r\n", d->snoop_by);
d2150 2
a2151 2
      sprintf(buf, "Closing link to: %s.", GET_NAME(d->character));
      mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
d2154 5
a2158 6
      if (GET_NAME(d->character)) {
        sprintf(buf, "Losing player: %s.", GET_NAME(d->character));
        mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
      } else {
        mudlog("Losing player: <null>.", CMP, LVL_IMMORT, TRUE);
      }
d2163 1
a2163 1
    mudlog("Losing descriptor without char.", CMP, LVL_IMMORT, TRUE);
d2197 1
a2197 1
      write_to_output("\r\nTimed out... goodbye.\r\n", d);
d2255 1
a2255 1
  mudlog("Signal received - rereading wizlists.", CMP, LVL_IMMORT, TRUE);
d2263 2
a2264 2
  mudlog("Received SIGUSR2 - completely unrestricting game (emergent)",
         BRF, LVL_IMMORT, TRUE);
d2378 2
a2379 1
void send_to_char(const char *messg, struct char_data *ch)
d2381 8
a2388 2
  if (ch->desc && messg)
    write_to_output(messg, ch->desc);
d2391 1
a2391 1
void send_to_zone(const char *messg, int zone_num, int skip_room, int min_stance)
d2393 3
a2395 1
   struct descriptor_data *i;
d2397 2
a2398 2
   if (!messg || !*messg)
      return;
d2400 14
a2413 7
   for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->character &&
            GET_STANCE(i->character) >= min_stance &&
            (IN_ROOM(i->character) != NOWHERE) &&
            (IN_ROOM(i->character) != skip_room) &&
            (IN_ZONE(i->character) == zone_num))
         write_to_output(messg, i);
d2416 20
d2437 1
a2437 1
void send_to_all(const char *messg)
d2440 2
d2443 1
a2443 1
  if (messg)
d2445 9
a2453 2
      if (!i->connected)
        write_to_output(messg, i);
d2457 1
a2457 1
void send_to_outdoor(char *messg, int zone_num)
d2460 2
d2469 9
a2477 2
        STATE(i) == CON_PLAYING)
      write_to_output(messg, i);
d2480 1
a2480 1
void send_to_room(const char *messg, int roomnum)
d2483 2
a2484 2
  int dir;
  struct room_data *room = &world[roomnum];
d2486 2
d2489 7
a2495 1
  if (!messg)
d2497 2
d2500 11
a2510 2
    if (i->desc)
      write_to_output(messg, i->desc);
a2513 3
    char rbuf[2 * MAX_INPUT_LENGTH];
    sprintf(rbuf, "&4&8<&0%s&0&4&8>&0 %s", room->name, messg);

d2520 11
a2530 2
          if (i->desc)
            write_to_output(rbuf, i->desc);
d2600 1
a2600 1
         send_to_char("&5&bYour mouth refuses to move!&0\r\n", ch);
d2613 1
a2613 1
            send_to_char("&6&bYou feel laryngitis coming on!&0\r\n", ch);
d2616 1
a2616 1
            send_to_char("&5Your throat feels a little sore.&0\r\n", ch);
a2625 1
   char report[100];
d2647 2
a2648 2
   if (sd->speech_rate > SPAM_THRESHOLD) {
      sprintf(report, "&5&b%s %s an acute case of laryngitis.&0\r\n",
d2651 2
a2652 3
      send_to_char(report, ch);
   } else if (sd->speech_rate > SPAM_THRESHOLD / 2) {
      sprintf(report, "&5%s%s throat feels a little sore.&0\r\n",
a2654 2
      send_to_char(report, ch);
   }
d2758 2
a2759 4
               log("SYSERR: Illegal $-code to act():");
               strcpy(buf1, "SYSERR: ");
               strcat(buf1, orig);
               log(buf1);
d2783 1
a2783 1
   write_to_output(CAP(lbuf), to->desc);
d2833 1
a2833 2
         sprintf(buf, "SYSERR:comm.c:act(): ch->in_room = -1, %s", GET_NAME(ch));
         log(buf);
d2841 1
a2841 2
            sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
            log(buf);
d2845 1
a2845 2
         sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
         log(buf);
d2876 1
a2876 1
                  write_to_output(rbuf, to->desc);
d2882 25
d2909 3
d3105 1
a3105 1
 * Changed speech_report to just send_to_char instead of buffering it.
d3109 1
a3109 1
 * send_to_char, send_to_zone, send_to_room, and parse_color, which
@


1.141
log
@Allow NPCs to be affected by laryingitis too.  Ehlissa has corrupted the necromancers.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.140 2008/07/27 05:30:09 jps Exp jps $
d60 1
a154 1
void show_string(struct descriptor_data *d, char *input);
d943 2
a944 2
        if (d->showstr_count)        /* reading something w/ pager     */
          show_string(d, comm);
d1495 1
a1495 1
  if (d->showstr_count) {
d1499 1
a1499 1
            d->showstr_page, d->showstr_count);
d1534 2
a1535 2
  if (d->showstr_count) {
    show_string(d, txt);
d2176 1
a2176 4
  if (d->showstr_head)
    free(d->showstr_head);
  if (d->showstr_count)
    free(d->showstr_vector);
d2819 3
@


1.140
log
@Renamed "crash" stuff to "autosave". Renamed save_player to
save_player_char.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.139 2008/07/15 17:49:24 myc Exp jps $
d2495 1
a2495 1
   struct player_special_data *sd;
d2499 3
a2501 7
   if (IS_NPC(ch)) {
      if (ch->desc && ch->desc->original) {
         /* A shapechanged player */
         sd = ch->desc->original->player_specials;
      } else {
         return TRUE;
      }
d2503 1
a2503 1
      sd = ch->player_specials;
d2554 1
a2554 1
   struct player_special_data *sd;
d2559 3
a2561 7
   if (IS_NPC(tch)) {
      if (tch->desc && tch->desc->original) {
         /* A shapechanged player */
         sd = tch->desc->original->player_specials;
      } else {
         return;
      }
d2563 1
a2563 1
      sd = tch->player_specials;
d2592 1
a2592 1
   struct player_special_data *sd;
d2594 3
a2596 7
   if (IS_NPC(ch)) {
      if (ch->desc && ch->desc->original) {
         /* A shapechanged player */
         sd = ch->desc->original->player_specials;
      } else {
         return;
      }
d2598 1
a2598 1
      sd = ch->player_specials;
d2822 4
@


1.139
log
@Whether you can use a command depends not only on level now, but
also on command grants.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.138 2008/07/13 18:49:29 jps Exp myc $
a107 2
extern int auto_save;                /* see config.c */
extern int autosave_time;        /* see config.c */
d435 1
a435 1
  crash_save_all();
d662 1
a662 1
  crash_save_all();
d1021 1
a1021 1
  static int mins_since_crashsave = 0;
d1064 4
a1067 4
  if (auto_save && !(pulse % PULSE_AUTOSAVE)) {        /* 1 minute */
    if (++mins_since_crashsave >= autosave_time) {
      mins_since_crashsave = 0;
      crash_save_all();
d2152 1
a2152 1
      save_player(d->character);
d2203 1
a2203 1
        save_player(d->character);
d2834 4
@


1.138
log
@Change the formatting of snoop messages.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.137 2008/06/19 18:53:12 myc Exp jps $
d59 1
d1549 1
a1549 1
      if (GET_LEVEL(d->character) >= cmd_info[cmd].minimum_level)
d2836 3
@


1.137
log
@Replaced the item_types string list with a struct array,
and added an init_objtypes() function to check values at
boot time.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.136 2008/06/07 19:06:46 myc Exp myc $
d1831 1
a1831 1
    write_to_output("% ", t->snoop_by);
d1833 1
a1833 1
    write_to_output("%%", t->snoop_by);
d1998 1
a1998 1
      write_to_output("% ", t->snoop_by);
d2000 1
a2000 1
      write_to_output("\r\n", t->snoop_by);
d2835 5
@


1.136
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.135 2008/06/05 02:07:43 myc Exp myc $
d271 1
d2835 3
@


1.135
log
@Rewrote rent-saving code to use ascii-format files.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.134 2008/05/26 18:24:48 jps Exp myc $
d435 2
d2834 3
@


1.134
log
@Removed code that deletes player object files.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.133 2008/05/18 20:16:11 jps Exp jps $
d660 1
a660 1
  Crash_save_all();
d1065 1
a1065 1
      Crash_save_all();
d2832 3
@


1.133
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.132 2008/05/17 22:03:01 jps Exp jps $
a77 1
extern int no_rent_check;
d220 1
a220 2
      no_rent_check = 1;
      log("Running in minimized mode & with no rent check.");
d227 1
a227 2
      no_rent_check = 1;
      log("Quick boot mode -- rent check supressed.");
d2832 3
@


1.132
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.131 2008/05/17 04:32:25 jps Exp jps $
d58 1
a153 1
void perform_violence(void);
a165 1
void free_messages(void);
d2835 3
@


1.131
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.130 2008/04/26 23:35:43 myc Exp jps $
d2456 4
a2459 4
            EXIT_DEST(exit) != NOWHERE &&
            EXIT_DEST(exit) != roomnum &&
            ROOM_FLAGGED(EXIT_DEST(exit), ROOM_OBSERVATORY))
        for (i = world[EXIT_DEST(exit)].people; i; i = i->next_in_room)
d2836 3
@


1.130
log
@Info about permanent effects and race skills are stored in the
class/race structs now, but need to be initialized at runtime
by the init_races and init_classes functions.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.129 2008/04/19 20:17:46 jps Exp myc $
d57 1
d2436 1
a2436 1
void send_to_room(const char *messg, int room)
d2440 2
d2445 1
a2445 1
  for (i = world[room].people; i; i = i->next_in_room)
d2450 1
a2450 1
  if (ROOM_FLAGGED(room, ROOM_ARENA)) {
d2452 1
a2452 1
    sprintf(rbuf, "&4&8<&0%s&0&4&8>&0 %s", world[room].name, messg);
d2455 5
a2459 5
      if (world[room].dir_option[dir] &&
          world[room].dir_option[dir]->to_room != NOWHERE &&
          world[room].dir_option[dir]->to_room != room &&
          ROOM_FLAGGED(world[room].dir_option[dir]->to_room, ROOM_OBSERVATORY))
        for (i = world[world[room].dir_option[dir]->to_room].people; i; i = i->next_in_room)
d2820 5
a2824 5
         if (world[in_room].dir_option[i] &&
             world[in_room].dir_option[i]->to_room != NOWHERE &&
             world[in_room].dir_option[i]->to_room != in_room &&
             ROOM_FLAGGED(world[in_room].dir_option[i]->to_room, ROOM_OBSERVATORY))
            for (to = world[world[in_room].dir_option[i]->to_room].people; to; to = to->next_in_room)
d2836 5
@


1.129
log
@Add comment at call to perform_mob_violence.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.128 2008/04/07 03:02:54 jps Exp jps $
d56 1
d269 1
d272 2
d2833 3
@


1.128
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.127 2008/04/05 21:42:50 jps Exp jps $
d1042 2
d2829 4
@


1.127
log
@Change event calling so that events scheduled for immediate
execution will occur before the next pulse.  If they are scheduled
during the execution of a player's command, they will be executed
before the player's next prompt is printed.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.126 2008/04/05 16:49:21 myc Exp jps $
d2387 1
a2387 1
void send_to_zone(const char *messg, int zone_num, int skip_room, int min_position)
d2396 1
a2396 1
            GET_POS(i->character) >= min_position &&
d2827 6
@


1.126
log
@Fixing conditional color for people who turn color off.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.125 2008/04/05 05:05:00 myc Exp myc $
d24 1
a24 1
#ifdef CIRCLE_WINDOWS		/* Includes for Win32 */
d27 1
a27 1
#else				/* Includes for UNIX */
d67 2
a68 2
#define YES	1
#define NO	0
d81 1
a81 1
extern const char *save_info_msg[];	/* In olc.c */
d91 11
a101 11
struct descriptor_data *descriptor_list = NULL;		/* master desc list */
struct txt_block *bufpool = 0;	/* pool of large output buffers */
int buf_largecount = 0;		/* # of large buffers which exist */
int buf_overflows = 0;		/* # of overflows of output */
int buf_switches = 0;		/* # of switches from small to large buf */
int circle_shutdown = 0;	/* clean shutdown */
int circle_reboot = 0;		/* reboot the game after a shutdown */
int no_specials = 0;		/* Suppress ass. of special routines */
int max_players = 0;		/* max descriptors available */
int tics = 0;			/* for extern checkpointing */
int scheck = 0;			/* for syntax checking mode */
d104 6
a109 6
extern int nameserver_is_slow;	/* see config.c */
extern int auto_save;		/* see config.c */
extern int autosave_time;	/* see config.c */
struct timeval null_time;	/* zero-valued time structure */
unsigned long pulse = 0;	/* number of pulses since game started */
int gossip_channel_active = 1;	/* Flag for turning on or off gossip for the whole MUD */
d146 2
a147 2
void effect_update(void);	/* In spells.c */
void point_update(void);	/* In limits.c */
d162 1
a162 1
void ispell_init(void);   
d181 1
a181 1
  
d194 1
a194 1
  
d201 1
a201 1
  
d206 1
a206 1
	dir = argv[pos] + 2;
d208 1
a208 1
	dir = argv[pos];
d210 2
a211 2
	log("Directory arg expected after option -d.");
	exit(1);
d267 1
a267 1
    
d285 5
a289 5
    free_bufpools();		/* comm.c */
    free_player_index();	/* db.c */
    free_messages();		/* fight.c */
    free_text_files();		/* db.c */
    board_clear_all();		/* board.c */
d291 5
a295 5
    free_social_messages();	/* act.social.c */
    free_help_table();		/* db.c */
    free_invalid_list();	/* ban.c */
    free_save_list();		/* olc.c */
    free_clans();		/* clan.c */
d297 1
a297 1
    free_mail_index();		/* mail.c */
d302 1
a302 1
    
d305 1
a305 1
  
d425 1
a425 1
      
d427 1
a427 1
      
d431 1
a431 1
      
d433 1
a433 1
      
d437 1
a437 1
      
d441 1
a441 1
      
d443 1
a443 1
      
d475 2
a476 2
  
  
d497 1
a497 1
      
d502 1
a502 1
	
d504 1
a504 1
	
d525 2
a526 2
#endif				/* CIRCLE_WINDOWS */
      
d534 1
a534 1
      
d542 1
a542 1
      
d546 1
a546 1
	
d555 1
a555 1
      
d559 1
a559 1
      
d569 2
a570 2
  
  
d612 1
a612 1
      
d643 1
a643 1
      
d653 1
a653 1
#endif				/* WINDOWS or OS2 */
d655 1
a655 1
  
d784 1
a784 1
  
d831 1
a831 1
	
d940 1
a940 1
        if (d->showstr_count)	/* reading something w/ pager     */
d942 1
a942 1
        else if (d->str)		/* writing boards, mail, etc.     */
d944 1
a944 1
        else if (d->connected != CON_PLAYING)	/* in menus, etc. */
d946 2
a947 2
        else {			/* else: we're playing normally */
          if (aliased)		/* to prevent recursive aliases */
d950 1
a950 1
            if (perform_alias(d, comm))		/* run it through aliasing system */
d954 1
a954 1
          command_interpreter(d->character, comm);	/* send it to interpreter */
d957 1
d985 1
a985 1
	
d992 1
a992 1
	
d997 1
a997 1
	
d1003 1
a1003 1
	
d1005 2
a1006 1
    while (missed_pulses--)
d1008 1
d1014 2
a1015 2
  
  
d1030 1
a1030 1
  if (!(pulse % (15 * PASSES_PER_SEC)))		/* 15 seconds */
d1044 1
a1044 1
      
d1050 1
a1050 1
  if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC))) { 
d1059 1
a1059 1
  if (auto_save && !(pulse % PULSE_AUTOSAVE)) {	/* 1 minute */
d1067 1
a1067 1
  if (!(pulse % (5 * 60 * PASSES_PER_SEC)))	/* 5 minutes */
d1069 1
d1100 1
a1100 1
  } else {			/* a->tv_sec > b->tv_sec */
d1138 1
a1138 1
      
d1186 1
a1186 1
  
d1189 1
a1189 1
  static char prompt[MAX_STRING_LENGTH];  
d1206 1
a1206 1
    sprintf(prompt, "%s&0", raw); 
d1327 1
a1327 1
          cur += sprintf(cur, "&0%d&6&8p&0 %d&3&8g&0 %ds %d&3c&0", 
d1333 1
a1333 1
          cur += sprintf(cur, "&0%d&6&8p&0 %d&3&8g&0 %ds %d&3c&0", 
d1388 1
a1388 1
                    "&1bleeding awfully");            
d1487 1
a1487 1
  
d1496 1
a1496 1
  }      
d1520 1
a1520 1
   * Only use this hack for descriptors with characters who are 
d1559 2
a1560 2
  
      
d1628 1
a1628 1
      
d1649 1
a1649 1
      
d1664 1
a1664 1
      
d1669 1
a1669 1
  t->bufspace = LARGE_BUFSIZE - 1 - t->bufptr;      
d1671 1
a1671 1
  
d1685 2
a1686 2
  
  
d1690 1
a1690 1
  
d1710 1
a1710 1
  
d1818 1
a1818 1
  if (!t->prompt_mode)		/* && !t->connected) */
d1854 1
a1854 1
      
d1924 1
a1924 1
    *(read_point + bytes_read) = '\0';	/* terminate the string */
d1965 1
a1965 1
      if (*ptr == '\b') {	/* handle backspacing */
d1974 2
a1975 2
        if ((*(write_point++) = *ptr) == '$') {		/* copy one character */
          *(write_point++) = '$';	/* if it's a $, double it */
d2086 3
a2088 3
	  
	  
	  
d2117 1
a2117 1
      do_shapechange(d->character, "me", 0, 1); 
d2223 1
a2223 1
	  
d2227 1
a2227 1
	  
d2305 1
a2305 1
  act.sa_flags |= SA_INTERRUPT;	/* SunOS */
d2313 1
a2313 1
#endif				/* NeXT */
d2370 1
a2370 1
#endif				/* CIRCLE_OS2 */
d2374 1
a2374 1
#endif				/* CIRCLE_WINDOWS */
d2610 1
a2610 1
	  
d2673 1
a2673 1
               break;   
d2731 1
a2731 1
    
d2733 1
a2733 1
    
d2739 1
a2739 1
    * 
d2747 1
a2747 1
    
d2765 1
a2765 1
      return;      
d2768 1
a2768 1
    
d2778 1
a2778 1
      if ((obj->in_room != NOWHERE)) { 
d2811 1
a2811 1
         if (world[in_room].dir_option[i] && 
d2824 1
a2824 1
 
d2827 3
d3228 3
a3230 3
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to 
 * clarify their behavior to the compiler.  The name approval code was also 
d3232 1
a3232 1
 * array to a linked list to allow for on the fly adding of names to the 
d3280 1
a3280 1
 * 
@


1.125
log
@Reformatted most functions.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.124 2008/04/04 06:12:52 myc Exp myc $
d1497 2
a1498 1
    process_colors(prompt, MAX_STRING_LENGTH, prompt, CLR_PARSE);
d1618 2
a1619 1
  size = process_colors(new_txt, sizeof(new_txt), txt, CLR_PARSE);
d2823 3
@


1.124
log
@Removed dieites/worship and ships code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.123 2008/04/04 05:13:46 myc Exp myc $
d418 4
a421 5
      /* Decide when to reboot */
      reboot_pulse = 
         3600 * PASSES_PER_SEC *
         (reboot_hours_base - reboot_hours_deviation) +
         number(0, 3600 * PASSES_PER_SEC * 2 * reboot_hours_deviation);
d423 2
a424 2
      if (num_hotboots > 0)
        hotboot_recover();
d426 1
a426 1
      log("Entering game loop.");
d429 1
a429 1
      ispell_init();
d432 1
a432 1
      game_loop(mother_desc);
d435 1
a435 1
      ispell_done();
d438 28
a465 31
      log("Closing all sockets.");
      while (descriptor_list)
	close_socket(descriptor_list);
      
      CLOSE_SOCKET(mother_desc);
      /* fclose(player_fl); */
      
      if (circle_reboot != 2 && olc_save_list) { /* Don't save zones. */
	struct olc_save_info *entry, *next_entry;
	for (entry = olc_save_list; entry; entry = next_entry) {
	  next_entry = entry->next;
	  if (entry->type < 0 || entry->type > 4) {
	    sprintf(buf, "OLC: Illegal save type %d!", entry->type);
	    log(buf);
	  } else if (entry->zone < 0) {
	    sprintf(buf, "OLC: Illegal save zone %d!", entry->zone);
	    log(buf);
	  } else {
	    sprintf(buf, "OLC: Reboot saving %s for zone %d.",
		    save_info_msg[(int)entry->type], entry->zone);
	    log(buf);
	    switch (entry->type) {
	    case OLC_SAVE_ROOM: redit_save_to_disk(entry->zone); break;
	    case OLC_SAVE_OBJ:  oedit_save_to_disk(entry->zone); break;
	    case OLC_SAVE_MOB:  medit_save_to_disk(entry->zone); break;
	    case OLC_SAVE_ZONE: zedit_save_to_disk(entry->zone); break;
	    case OLC_SAVE_SHOP: sedit_save_to_disk(entry->zone); break;
	    default:      log("Unexpected olc_save_list->type"); break;
	    }
	  }
	}
a466 6
      
      
      if (circle_reboot)
	log("Rebooting.");
      else
        log("Normal termination of game.");
d468 7
d478 9
d488 8
a495 2
   * init_socket sets up the mother descriptor - creates the socket, sets
   * its options up, binds it, and listens.
a496 15
  int init_socket(int port)
    {
      int s, opt;
      struct sockaddr_in sa;
      
      /*
       * Should the first argument to socket() be AF_INET or PF_INET?  I don't
       * know, take your pick.  PF_INET seems to be more widely adopted, and
       * Comer (_Internetworking with TCP/IP_) even makes a point to say that
       * people erroneously use AF_INET with socket() when they should be using
       * PF_INET.  However, the man pages of some systems indicate that AF_INET
       * is correct; some such as ConvexOS even say that you can use either one.
       * All implementations I've seen define AF_INET and PF_INET to be the same
       * number anyway, so ths point is (hopefully) moot.
       */
d499 3
a501 3
      {
	WORD wVersionRequested;
	WSADATA wsaData;
d503 1
a503 1
	wVersionRequested = MAKEWORD(1, 1);
d505 15
a519 15
	if (WSAStartup(wVersionRequested, &wsaData) != 0) {
	  log("WinSock not available!\n");
	  exit(1);
	}
	if ((wsaData.iMaxSockets - 4) < max_players) {
	  max_players = wsaData.iMaxSockets - 4;
	}
	sprintf(buf, "Max players set to %d", max_players);
	log(buf);
	
	if ((s = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {
	  fprintf(stderr, "Error opening network connection: Winsock err #%d\n", WSAGetLastError());
	  exit(1);
	}
      }
d521 4
a524 4
      if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
	perror("Error creating socket");
	exit(1);
      }
d528 5
a532 5
      opt = LARGE_BUFSIZE + GARBAGE_SPACE;
      if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &opt, sizeof(opt)) < 0) {
	perror("setsockopt SNDBUF");
	exit(1);
      }
d536 5
a540 5
      opt = 1;
      if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt)) < 0) {
	perror("setsockopt REUSEADDR");
	exit(1);
      }
d544 2
a545 2
      {
	struct linger ld;
d547 7
a553 7
	ld.l_onoff = 0;
	ld.l_linger = 0;
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld)) < 0) {
	  perror("setsockopt LINGER");
	  exit(1);
	}
      }
d556 13
a568 13
      sa.sin_family = AF_INET;
      sa.sin_port = htons(port);
      sa.sin_addr.s_addr = htonl(INADDR_ANY);
      
      if (bind(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
	perror("bind");
	CLOSE_SOCKET(s);
	exit(1);
      }
      nonblock(s);
      listen(s, 5);
      return s;
    }
d571 5
a575 2
  int get_max_players(void)
    {
d577 1
a577 1
      return MAX_PLAYERS;
d579 5
a583 8
      
      int max_descs = 0;
      char *method;
      
      /*
       * First, we'll try using getrlimit/setrlimit.  This will probably work
       * on most systems.
       */
d588 15
a602 15
      {
	struct rlimit limit;
	
	/* find the limit of file descs */
	method = "rlimit";
	if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
	  perror("calling getrlimit");
	  exit(1);
	}
	/* set the current to the maximum */
	limit.rlim_cur = limit.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
	  perror("calling setrlimit");
	  exit(1);
	}
d604 4
a607 4
	if (limit.rlim_max == RLIM_INFINITY)
	  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
	else
	  max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
d609 1
a609 1
	max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
d611 1
a611 1
      }
d617 3
a619 3
      method = "OPEN_MAX";
      max_descs = OPEN_MAX;		/* Uh oh.. rlimit didn't work, but we have
					 * OPEN_MAX */
d621 15
a635 15
      /*
       * Okay, you don't have getrlimit() and you don't have OPEN_MAX.  Time to
       * use the POSIX sysconf() function.  (See Stevens' _Advanced Programming
       * in the UNIX Environment_).
       */
      method = "POSIX sysconf";
      errno = 0;
      if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
	if (errno == 0)
	  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
	else {
	  perror("Error calling sysconf");
	  exit(1);
	}
      }
d637 2
a638 2
      /* if everything has failed, we'll just take a guess */
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
d640 3
d644 9
a652 12
      /* now calculate max _players_ based on max descs */
      max_descs = MIN(MAX_PLAYERS, max_descs - NUM_RESERVED_DESCS);
      
      if (max_descs <= 0) {
	sprintf(buf, "Non-positive max player limit!  (Set at %d using %s).",
		max_descs, method);
	log(buf);
	exit(1);
      }
      sprintf(buf, "Setting player limit to %d using %s.", max_descs, method);
      log(buf);
      return max_descs;
d654 1
a654 1
    }
d658 23
a680 23
    /*do global save*/
    Crash_save_all();
    House_save_all();
    send_to_all("Rebooting.. come back in a minute or two.\r\n"
 		"           &1&b** ****** ****&0\r\n"
                "         &1&b**&0 &3&b***     *****&0  &1&b**&0\r\n"
                "       &1&b**&0 &3&b**      &1&b*&0     &3&b***&0  &1&b*&0\r\n"
                "       &1&b*&0    &3&b** **   *   *  *&0 &1&b**&0\r\n"
                "      &1&b*&0  &3&b** * *&0          &1&b*&0     &1&b*&0\r\n"
                "      &1&b*&0  &3&b*&0    &1&b**&0            &3&b* *&0 &1&b*&0\r\n"
                "     &1&b*&0 &3&b* &1&b** *&0     &3&b*   ******&0  &1&b*&0\r\n"
                "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n");
    send_to_all("        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
		"         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
                "                &1&b*&0   &3&b*&0 &1&b*&0\r\n"
                "               &1&b*&0  &3&b* *&0  &1&b*&0\r\n"
                "              &1&b*&0  &3&b*  **&0  &1&b*&0\r\n"
                "              &1&b*&0 &3&b**   *&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0  &1&b**&0\r\n"
                "               &1&b**&0     &1&b****&0\r\n"
                "              &1&b***&0  &3&b* *&0    &1&b****&0\r\n");
    touch("../.fastboot");
d785 39
a823 22
  /*
   * game_loop contains the main loop which drives the entire MUD.  It
   * cycles once every 0.10 seconds and is responsible for accepting new
   * new connections, polling existing connections for input, dequeueing
   * output and sending it out to players, and calling "heartbeat functions
   * such as mobile_activity().
   */
  void game_loop(int mother_desc)
    {
      fd_set input_set, output_set, exc_set, null_set;
      struct timeval last_time, before_sleep, opt_time, process_time, now, timeout;
      char comm[MAX_INPUT_LENGTH];
      struct descriptor_data *d, *next_d;
      int missed_pulses, maxdesc, aliased;
      
      /* initialize various time values */
      null_time.tv_sec = 0;
      null_time.tv_usec = 0;
      opt_time.tv_usec = OPT_USEC;
      opt_time.tv_sec = 0;
      FD_ZERO(&null_set);
      
d825 6
a830 3
      
      /* The Main Loop.  The Big Cheese.  The Top Dog.  The Head Honcho.  The.. */
      while (!circle_shutdown) {
d832 2
a833 22
	/* Sleep if we don't have any connections and are not about to reboot */
	if (descriptor_list == NULL && !reboot_warning) {
	  log("No connections.  Going to sleep.");
	  FD_ZERO(&input_set);
	  FD_SET(mother_desc, &input_set);
	  if (select(mother_desc + 1, &input_set, (fd_set *) 0, (fd_set *) 0, NULL) < 0) {
	    if (errno == EINTR)
	      log("Waking up to process signal.");
	    else
	      perror("Select coma");
	  } else
	    log("New connection.  Waking up.");
	  gettimeofday(&last_time, (struct timezone *) 0);
	}
	/* Set up the input, output, and exception sets for select(). */
	FD_ZERO(&input_set);
	FD_ZERO(&output_set);
	FD_ZERO(&exc_set);
	FD_SET(mother_desc, &input_set);
	
	maxdesc = mother_desc;
	for (d = descriptor_list; d; d = d->next) {
d835 2
a836 2
	  if (d->descriptor > maxdesc)
	    maxdesc = d->descriptor;
d838 37
a874 37
	  FD_SET(d->descriptor, &input_set);
	  FD_SET(d->descriptor, &output_set);
	  FD_SET(d->descriptor, &exc_set);
	}
	
	/*
	 * At this point, we have completed all input, output and heartbeat
	 * activity from the previous iteration, so we have to put ourselves
	 * to sleep until the next 0.1 second tick.  The first step is to
	 * calculate how long we took processing the previous iteration.
	 */
	
	gettimeofday(&before_sleep, (struct timezone *) 0); /* current time */
	process_time = timediff(before_sleep, last_time);
	
	/*
	 * If we were asleep for more than one pass, count missed pulses and sleep
	 * until we're resynchronized with the next upcoming pulse.
	 */
	if (process_time.tv_sec == 0 && process_time.tv_usec < OPT_USEC) {
	  missed_pulses = 0;
	} else {
	  missed_pulses = process_time.tv_sec * PASSES_PER_SEC;
	  missed_pulses += process_time.tv_usec / OPT_USEC;
	  process_time.tv_sec = 0;
	  process_time.tv_usec = process_time.tv_usec % OPT_USEC;
	}
	
	/* Calculate the time we should wake up */
	last_time = timeadd(before_sleep, timediff(opt_time, process_time));
	
	/* Now keep sleeping until that time has come */
	gettimeofday(&now, (struct timezone *) 0);
	timeout = timediff(last_time, now);
	
	/* go to sleep */
	do {
d876 1
a876 1
	  Sleep(timeout.tv_sec * 1000 + timeout.tv_usec / 1000);
d878 6
a883 6
	  if (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &timeout) < 0) {
	    if (errno != EINTR) {
	      perror("Select sleep");
	      exit(1);
	    }
	  }
d885 20
a904 125
	  gettimeofday(&now, (struct timezone *) 0);
	  timeout = timediff(last_time, now);
	} while (timeout.tv_usec || timeout.tv_sec);
	
	/* poll (without blocking) for new input, output, and exceptions */
	if (select(maxdesc + 1, &input_set, &output_set, &exc_set, &null_time) < 0) {
	  perror("Select poll");
	  return;
	}
	/* If there are new connections waiting, accept them. */
	if (FD_ISSET(mother_desc, &input_set))
	  new_descriptor(mother_desc);
	
	/* kick out the freaky folks in the exception set */
	for (d = descriptor_list; d; d = next_d) {
	  next_d = d->next;
	  if (FD_ISSET(d->descriptor, &exc_set)) {
	    FD_CLR(d->descriptor, &input_set);
	    FD_CLR(d->descriptor, &output_set);
	    close_socket(d);
	  }
	}
	
	/* process descriptors with input pending */
	for (d = descriptor_list; d; d = next_d) {
	  next_d = d->next;
	  if (FD_ISSET(d->descriptor, &input_set))
	    if (process_input(d) < 0)
	      close_socket(d);
	}
	
	/* process commands we just read from process_input */
	for (d = descriptor_list; d; d = next_d) {
	  next_d = d->next;
	  
	  if ((--(d->wait) <= 0) && get_from_q(&d->input, comm, &aliased)) {
	    if (d->character) {
	      /* reset the idle timer & pull char back from void if necessary */
              if (d->original)
                d->original->char_specials.timer = 0;
              else
                d->character->char_specials.timer = 0;
	      if (!d->connected && GET_WAS_IN(d->character) != NOWHERE) {
		if (d->character->in_room != NOWHERE)
		  char_from_room(d->character);
		char_to_room(d->character, GET_WAS_IN(d->character));
		GET_WAS_IN(d->character) = NOWHERE;
		act("$n has returned.", TRUE, d->character, 0, 0, TO_ROOM);
	      }
	    }
	    d->wait = 1;
	    d->prompt_mode = 1;
	    
	    
	    /* reversed these top 2 if checks so that you can use the page_string */
	    /* function in the editor */
	    if (d->showstr_count)	/* reading something w/ pager     */
	      show_string(d, comm);
	    else if (d->str)		/* writing boards, mail, etc.     */
	      string_add(d, comm);
	    else if (d->connected != CON_PLAYING)	/* in menus, etc. */
	      nanny(d, comm);
	    else {			/* else: we're playing normally */
	      if (aliased)		/* to prevent recursive aliases */
		d->prompt_mode = 0;
	      else {
		if (perform_alias(d, comm))		/* run it through aliasing system */
		  get_from_q(&d->input, comm, &aliased);
	      }
	      SEND_TO_Q("\r\n",d);
	      command_interpreter(d->character, comm);	/* send it to interpreter */
	    }
	  }
	}
	
	/* send queued output out to the operating system (ultimately to user) */
	for (d = descriptor_list; d; d = next_d) {
	  next_d = d->next;
	  if (FD_ISSET(d->descriptor, &output_set) && *(d->output)) {
	    if (process_output(d) < 0)
	      close_socket(d);
	    else
	      d->prompt_mode = 1;
	  }
	}
	
	/* kick out folks in the CON_CLOSE state */
	for (d = descriptor_list; d; d = next_d) {
	  next_d = d->next;
	  if (STATE(d) == CON_CLOSE)
	    close_socket(d);
	}
	
	/* give each descriptor an appropriate prompt */
	for (d = descriptor_list; d; d = d->next) {
	  if (d->prompt_mode) {
	    make_prompt(d);
	    d->prompt_mode = 0;
	  }
	}
	
	/*
	 * Now, we execute as many pulses as necessary--just one if we haven't
	 * missed any pulses, or make up for lost time if we missed a few
	 * pulses by sleeping for too long.
	 */
	missed_pulses++;
	
	if (missed_pulses <= 0) {
	  log("SYSERR: MISSED_PULSES IS NONPOSITIVE!!!");
	  missed_pulses = 1;
	}
	
	/* If we missed more than 30 seconds worth of pulses, forget it */
	if (missed_pulses > (30 * PASSES_PER_SEC)) {
	  log("Warning: Missed more than 30 seconds worth of pulses");
	  missed_pulses = 30 * PASSES_PER_SEC;
	}
	
	/* Now execute the heartbeat functions */
	while (missed_pulses--)
	  heartbeat(++pulse);
	
	/* Update tics for deadlock protection (UNIX only) */
	tics++;
a906 5
  
  
  void heartbeat(int pulse)
    {
      static int mins_since_crashsave = 0;
d908 50
a957 9
      global_pulse++;
      
      if (!(pulse % PULSE_DG_SCRIPT))
	script_trigger_check();
      
      event_process();
      
      if (!(pulse % PULSE_ZONE))
	zone_update();
d959 8
a966 22
      if (!(pulse % (15 * PASSES_PER_SEC)))		/* 15 seconds */
	check_idle_passwords();
      
      /* removed until changes can be tested --gurlaek 7/22/1999 */
      /* if (!(pulse % (60 * PASSES_PER_SEC))) */	/* 1 minute */
      /* divine_intervention(); */
      
      if (!(pulse % PULSE_MOBILE))
	mobile_activity();
      
      if (!(pulse % PULSE_VIOLENCE)){
	perform_violence();
	mobile_spec_activity();
	
      }
      
      if (!(pulse % (PULSE_VIOLENCE/2))) {
	perform_mob_violence();
      }
      
      if (!(pulse % PASSES_PER_SEC)) {
        if (reboot_auto) check_auto_rebooting();
d968 1
d970 5
a974 20
      if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC))) 
	{ 
	  update_weather(pulse);
          increment_game_time(); /* Increment game time by an hour. */
	  effect_update();
	  point_update();
	  /* fflush(player_fl); */
	  casting_gain();
          check_time_triggers();
	}
      
      if (auto_save && !(pulse % PULSE_AUTOSAVE)) {	/* 1 minute */
	if (++mins_since_crashsave >= autosave_time) {
	  mins_since_crashsave = 0;
	  Crash_save_all();
	  House_save_all();
	}
      }
      if (!(pulse % (5 * 60 * PASSES_PER_SEC)))	/* 5 minutes */
	record_usage();
d976 6
a981 38
  
  
  /* ******************************************************************
   *  general utility stuff (for local use)                            *
   ****************************************************************** */
  
  /*
   *  new code to calculate time differences, which works on systems
   *  for which tv_usec is unsigned (and thus comparisons for something
   *  being < 0 fail).  Based on code submitted by ss@@sirocco.cup.hp.com.
   */
  
  /*
   * code to return the time difference between a and b (a-b).
   * always returns a nonnegative value (floors at 0).
   */
  struct timeval timediff(struct timeval a, struct timeval b)
    {
      struct timeval rslt;
      
      if (a.tv_sec < b.tv_sec)
	return null_time;
      else if (a.tv_sec == b.tv_sec) {
	if (a.tv_usec < b.tv_usec)
	  return null_time;
	else {
	  rslt.tv_sec = 0;
	  rslt.tv_usec = a.tv_usec - b.tv_usec;
	  return rslt;
	}
      } else {			/* a->tv_sec > b->tv_sec */
	rslt.tv_sec = a.tv_sec - b.tv_sec;
	if (a.tv_usec < b.tv_usec) {
	  rslt.tv_usec = a.tv_usec + 1000000 - b.tv_usec;
	  rslt.tv_sec--;
	} else
	  rslt.tv_usec = a.tv_usec - b.tv_usec;
	return rslt;
d984 11
a994 15
  
  /* add 2 timevals */
  struct timeval timeadd(struct timeval a, struct timeval b)
    {
      struct timeval rslt;
      
      rslt.tv_sec = a.tv_sec + b.tv_sec;
      rslt.tv_usec = a.tv_usec + b.tv_usec;
      
      while (rslt.tv_usec >= 1000000) {
	rslt.tv_usec -= 1000000;
	rslt.tv_sec++;
      }
      
      return rslt;
a995 21
  
  
  void record_usage(void)
    {
      int sockets_connected = 0, sockets_playing = 0;
      struct descriptor_data *d;
      char buf[256];
      
      for (d = descriptor_list; d; d = d->next) {
	sockets_connected++;
	if (!d->connected)
	  sockets_playing++;
      }
      
      sprintf(buf, "nusage: %-3d sockets connected, %-3d sockets playing",
	      sockets_connected, sockets_playing);
      log(buf);
      
#ifdef RUSAGE
      {
	struct rusage ru;
d997 4
a1000 7
	getrusage(0, &ru);
	sprintf(buf, "rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
		ru.ru_utime.tv_sec, ru.ru_stime.tv_sec, ru.ru_maxrss);
	log(buf);
      }
#endif
      
d1002 9
d1013 28
a1040 13
  
  /*
   * Turn off echoing (specific to telnet client)
   */
  void echo_off(struct descriptor_data *d)
    {
      char off_string[] =
      {
	(char) IAC,
	(char) WILL,
	(char) TELOPT_ECHO,
	(char) 0,
      };
d1042 53
a1094 1
      SEND_TO_Q(off_string, d);
d1096 38
a1133 16
  
  
  /*
   * Turn on echoing (specific to telnet client)
   */
  void echo_on(struct descriptor_data *d)
    {
      char on_string[] =
      {
	(char) IAC,
	(char) WONT,
	(char) TELOPT_ECHO,
	(char) TELOPT_NAOFFD,
	(char) TELOPT_NAOCRD,
	(char) 0,
      };
d1135 47
a1181 2
      SEND_TO_Q(on_string, d);
    }
d1550 1
a1550 1
  SEND_TO_Q("\r\n", d);
d1556 3
a1558 56
  void write_to_q(char *txt, struct txt_q *queue, int aliased, struct descriptor_data *d)
    {
      struct txt_block *new;
      
      CREATE(new, struct txt_block, 1);
      CREATE(new->text, char, strlen(txt) + 1);
      strcpy(new->text, txt);
      new->aliased = aliased;
      
      /* queue empty? */
      if (!queue->head) {
	new->next = NULL;
	queue->head = queue->tail = new;
      } else {
	queue->tail->next = new;
	queue->tail = new;
	new->next = NULL;
      }
    }
  
  
  
  int get_from_q(struct txt_q *queue, char *dest, int *aliased)
    {
      struct txt_block *tmp;
      
      /* queue empty? */
      if (!queue->head)
	return 0;
      
      tmp = queue->head;
      strcpy(dest, queue->head->text);
      *aliased = queue->head->aliased;
      queue->head = queue->head->next;
      
      free(tmp->text);
      free(tmp);
      
      return 1;
    }
  
  
  
  /* Empty the queues before closing connection */
  void flush_queues(struct descriptor_data *d)
    {
      int dummy;
      
      if (d->large_outbuf) {
	d->large_outbuf->next = bufpool;
	bufpool = d->large_outbuf;
      }
      while (get_from_q(&d->input, buf2, &dummy));
    }
  
  /* Add a new string to a player's output queue */
d1560 52
d1705 66
a1770 66
  int new_descriptor(int s) {
    socket_t desc;
    int sockets_connected = 0;
    unsigned long addr;
    unsigned int i;
    struct descriptor_data *newd;
    struct sockaddr_in peer;
    struct hostent *from;
    extern char *ANSI;
    extern char *BANNEDINTHEUSA;
    extern char *BANNEDINTHEUSA2;
    extern char *BANNEDINTHEUSA3;

    /* accept the new connection */
    i = sizeof(peer);
    if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
      perror("accept");
      return -1;
    }
    /* keep it from blocking */
    nonblock(desc);
    
    /* make sure we have room for it */
    for (newd = descriptor_list; newd; newd = newd->next)
      sockets_connected++;
    
    if (sockets_connected >= max_players) {
      write_to_descriptor(desc, "Sorry, FieryMUD is full right now... please try again later!\r\n");
      CLOSE_SOCKET(desc);
      return 0;
    }
    /* create a new descriptor */
    CREATE(newd, struct descriptor_data, 1);
    memset((char *) newd, 0, sizeof(struct descriptor_data));
    
    /* find the sitename */
    if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
						     sizeof(peer.sin_addr), AF_INET))) {
      
      /* resolution failed */
      if (!nameserver_is_slow)
	perror("gethostbyaddr");
      
      /* find the numeric site address */
      addr = ntohl(peer.sin_addr.s_addr);
      sprintf(newd->host, "%03u.%03u.%03u.%03u", (int) ((addr & 0xFF000000) >> 24),
	      (int) ((addr & 0x00FF0000) >> 16), (int) ((addr & 0x0000FF00) >> 8),
	      (int) ((addr & 0x000000FF)));
    } else {
      strncpy(newd->host, from->h_name, HOST_LENGTH);
      *(newd->host + HOST_LENGTH) = '\0';
    }
    
    /* determine if the site is banned */
    if (isbanned(newd->host) == BAN_ALL) {
      write_to_descriptor(desc, BANNEDINTHEUSA);
      write_to_descriptor(desc, BANNEDINTHEUSA2);
      write_to_descriptor(desc, BANNEDINTHEUSA3);
      sprintf(buf,"\r\n Connection logged from: %s\r\n\r\n", newd->host);
      write_to_descriptor(desc, buf);
      CLOSE_SOCKET(desc);
      sprintf(buf2, "BANNED: Connection attempt denied from [%s]", newd->host);
      mudlog(buf2, CMP, LVL_GOD, TRUE);
      free(newd);
      return 0;
    }
d1772 3
a1774 3
    /* Log new connections - probably unnecessary, but you may want it */
    sprintf(buf2, "New connection from [%s]", newd->host);
    mudlog(buf2, CMP, LVL_GOD, FALSE);
d1776 57
a1832 10
    
    init_descriptor(newd, desc);
    
    /* prepend to list */
    newd->next = descriptor_list;
    descriptor_list = newd;
    
    SEND_TO_Q(ANSI, newd);
    
    return 0;
d1834 14
a1847 62
  
  
  
  int process_output(struct descriptor_data *t)
    {
      static char i[LARGE_BUFSIZE + GARBAGE_SPACE];
      static int result;
      
      /* we may need this \r\n for later -- see below */
      strcpy(i, "\r\n");
      
      /* now, append the 'real' output */
      strcpy(i + 2, t->output);
      
      /* if we're in the overflow state, notify the user */
      if (t->bufptr < 0)
	strcat(i, "**OVERFLOW**");
      
      /* add the extra CRLF if the person isn't in compact mode */
      if (!t->connected && t->character && !PRF_FLAGGED(t->character, PRF_COMPACT))
	strcat(i + 2, "\r\n");
      
      /*
       * now, send the output.  If this is an 'interruption', use the prepended
       * CRLF, otherwise send the straight output sans CRLF.
       */
      if (!t->prompt_mode)		/* && !t->connected) */
	result = write_to_descriptor(t->descriptor, i);
      else
	result = write_to_descriptor(t->descriptor, i + 2);
      
      /* handle snooping: prepend "% " and send to snooper */
      if (t->snoop_by) {
	SEND_TO_Q("% ", t->snoop_by);
	SEND_TO_Q(t->output, t->snoop_by);
	SEND_TO_Q("%%", t->snoop_by);
      }
      /*
       * if we were using a large buffer, put the large buffer on the buffer pool
       * and switch back to the small one
       */
      if (t->large_outbuf) {
	t->large_outbuf->next = bufpool;
	bufpool = t->large_outbuf;
	t->large_outbuf = NULL;
	t->output = t->small_outbuf;
      }
      /* reset total bufspace back to that of a small buffer */
      t->bufspace = SMALL_BUFSIZE - 1;
      t->bufptr = 0;
      *(t->output) = '\0';
      
      return result;
    }
  
  
  
  int write_to_descriptor(socket_t desc, char *txt)
    {
      int total, bytes_written;
      
      total = strlen(txt);
d1849 1
a1849 1
      do {
d1851 2
a1852 2
	if ((bytes_written = send(desc, txt, total, 0)) < 0) {
	  if (WSAGetLastError() == WSAEWOULDBLOCK)
d1854 1
a1854 1
	    if ((bytes_written = write(desc, txt, total)) < 0) {
d1856 2
a1857 2
	      if (errno == EWOULDBLOCK)
		errno = EAGAIN;
d1859 1
a1859 1
	      if (errno == EAGAIN)
d1861 34
a1894 34
		log("process_output: socket write would block, about to close");
	      else
		perror("Write to socket");
	      return -1;
	    } else {
	      txt += bytes_written;
	      total -= bytes_written;
	    }
	} while (total > 0);
	
	return 0;
      }
      
      
      /*
       * ASSUMPTION: There will be no newlines in the raw input buffer when this
       * function is called.  We must maintain that before returning.
       */
      int process_input(struct descriptor_data *t)
	{
	  int buf_length, bytes_read, space_left, failed_subst;
	  char *ptr, *read_point, *write_point, *nl_pos = NULL;
	  char tmp[MAX_INPUT_LENGTH + 8];
	  
	  /* first, find the point where we left off reading data */
	  buf_length = strlen(t->inbuf);
	  read_point = t->inbuf + buf_length;
	  space_left = MAX_RAW_INPUT_LENGTH - buf_length - 1;
	  
	  do {
	    if (space_left <= 0) {
	      log("process_input: about to close connection: input overflow");
	      return -1;
	    }
d1896 2
a1897 2
	    if ((bytes_read = recv(t->descriptor, read_point, space_left, 0)) < 0) {
	      if (WSAGetLastError() != WSAEWOULDBLOCK) {
d1899 1
a1899 1
		if ((bytes_read = read(t->descriptor, read_point, space_left)) < 0) {
d1901 2
a1902 2
		  if (errno == EWOULDBLOCK)
		    errno = EAGAIN;
d1904 1
a1904 1
		  if (errno != EAGAIN) {
d1906 32
a1937 32
		    log("process_input: about to lose connection");
		    return -1;		/* some error condition was encountered on
					 * read */
		  } else
		    return 0;		/* the read would have blocked: just means no
					 * data there but everything's okay */
		} else if (bytes_read == 0) {
		  log("EOF on socket read (connection broken by peer)");
		  return -1;
		}
		/* at this point, we know we got some data from the read */
		
		*(read_point + bytes_read) = '\0';	/* terminate the string */
		
		/* search for a newline in the data we just read */
		for (ptr = read_point; *ptr && !nl_pos; ptr++)
		  if (IS_NEWLINE(*ptr))
		    nl_pos = ptr;
		
		read_point += bytes_read;
		space_left -= bytes_read;
		
		/*
		 * on some systems such as AIX, POSIX-standard nonblocking I/O is broken,
		 * causing the MUD to hang when it encounters input not terminated by a
		 * newline.  This was causing hangs at the Password: prompt, for example.
		 * I attempt to compensate by always returning after the _first_ read, instead
		 * of looping forever until a read returns -1.  This simulates non-blocking
		 * I/O because the result is we never call read unless we know from select()
		 * that data is ready (process_input is only called if select indicates that
		 * this descriptor is in the read set).  JE 2/23/95.
		 */
d1939 1
a1939 1
	      } while (nl_pos == NULL);
d1941 4
a1944 4
	    } while (0);
	    
	    if (nl_pos == NULL)
	      return 0;
d1946 134
a2079 83
	    
	    /*
	     * okay, at this point we have at least one newline in the string; now we
	     * can copy the formatted data to a new array for further processing.
	     */
	    
	    read_point = t->inbuf;
	    
	    while (nl_pos != NULL) {
	      write_point = tmp;
	      space_left = MAX_INPUT_LENGTH - 1;
	      
	      for (ptr = read_point; (space_left > 0) && (ptr < nl_pos); ptr++) {
		if (*ptr == '\b') {	/* handle backspacing */
		  if (write_point > tmp) {
		    if (*(--write_point) == '$') {
		      write_point--;
		      space_left += 2;
		    } else
		      space_left++;
		  }
		} else if (isascii(*ptr) && isprint(*ptr)) {
		  if ((*(write_point++) = *ptr) == '$') {		/* copy one character */
		    *(write_point++) = '$';	/* if it's a $, double it */
		    space_left -= 2;
		  } else
		    space_left--;
		}
	      }
	      
	      *write_point = '\0';
	      
	      if ((space_left <= 0) && (ptr < nl_pos)) {
		char buffer[MAX_INPUT_LENGTH + 64];
		
		sprintf(buffer, "Line too long.  Truncated to:\r\n%s\r\n", tmp);
		if (write_to_descriptor(t->descriptor, buffer) < 0)
		  return -1;
	      }
	      if (t->snoop_by) {
		SEND_TO_Q("% ", t->snoop_by);
		SEND_TO_Q(tmp, t->snoop_by);
		SEND_TO_Q("\r\n", t->snoop_by);
	      }
	      failed_subst = 0;
	      
	      if (*tmp == '!')
		strcpy(tmp, t->last_input);
	      else if (*tmp == '^') {
		if (!(failed_subst = perform_subst(t, t->last_input, tmp)))
		  strcpy(t->last_input, tmp);
	      } else
		strcpy(t->last_input, tmp);

	      /*
               * If the user is casting, and the command is ok
               * when casting, then it gets processed immediately
               * by the command interpreter within casting_command().
               * Otherwise, the command is queued up and handled by
               * the game loop normally.  Oh, and this is a hack.
               */
	      if (!failed_subst && !casting_command(t, tmp))
		  write_to_q(tmp, &t->input, 0, t);
	      
	      /* find the end of this line */
	      while (IS_NEWLINE(*nl_pos))
		nl_pos++;
	      
	      /* see if there's another newline in the input buffer */
	      read_point = ptr = nl_pos;
	      for (nl_pos = NULL; *ptr && !nl_pos; ptr++)
		if (IS_NEWLINE(*ptr))
		  nl_pos = ptr;
	    }
	    
	    /* now move the rest of the buffer up to the beginning for the next pass */
	    write_point = t->inbuf;
	    while (*read_point)
	      *(write_point++) = *(read_point++);
	    *write_point = '\0';
	    
	    return 1;
	  }
d2083 125
a2207 183
	  /*
	   * perform substitution for the '^..^' csh-esque syntax
	   * orig is the orig string (i.e. the one being modified.
	   * subst contains the substition string, i.e. "^telm^tell"
	   */
	  int perform_subst(struct descriptor_data *t, char *orig, char *subst)
	    {
	      char new[MAX_INPUT_LENGTH + 5];
	      
	      char *first, *second, *strpos;
	      
	      /*
	       * first is the position of the beginning of the first string (the one
	       * to be replaced
	       */
	      first = subst + 1;
	      
	      /* now find the second '^' */
	      if (!(second = strchr(first, '^'))) {
		SEND_TO_Q("Invalid substitution.\r\n", t);
		return 1;
	      }
	      /* terminate "first" at the position of the '^' and make 'second' point
	       * to the beginning of the second string */
	      *(second++) = '\0';
	      
	      /* now, see if the contents of the first string appear in the original */
	      if (!(strpos = strstr(orig, first))) {
		SEND_TO_Q("Invalid substitution.\r\n", t);
		return 1;
	      }
	      /* now, we construct the new string for output. */
	      
	      /* first, everything in the original, up to the string to be replaced */
	      strncpy(new, orig, (strpos - orig));
	      new[(strpos - orig)] = '\0';
	      
	      /* now, the replacement string */
	      strncat(new, second, (MAX_INPUT_LENGTH - strlen(new) - 1));
	      
	      /* now, if there's anything left in the original after the string to
	       * replaced, copy that too. */
	      if (((strpos - orig) + strlen(first)) < strlen(orig))
		strncat(new, strpos + strlen(first), (MAX_INPUT_LENGTH - strlen(new) - 1));
	      
	      /* terminate the string in case of an overflow from strncat */
	      new[MAX_INPUT_LENGTH - 1] = '\0';
	      strcpy(subst, new);
	      
	      return 0;
	    }
	  
	  
	  
	  void close_socket(struct descriptor_data *d)
	    {
	      char buf[128];
	      struct descriptor_data *temp;
              struct char_data *attacker;
	      long target_idnum = -1;
	      
	      CLOSE_SOCKET(d->descriptor);
	      flush_queues(d);
	      
	      /* Forget snooping */
	      if (d->snooping)
		d->snooping->snoop_by = NULL;
	      
	      if (d->snoop_by) {
		SEND_TO_Q("Your victim is no longer among us.\r\n", d->snoop_by);
		d->snoop_by->snooping = NULL;
	      }

              /* Shapechange a player back to normal form
                 DCE 06-DEC-2001 */
              if(d->character) {
                attacker = NULL;
                if(d->character->desc && d->character->desc->original) {
                  if (FIGHTING(d->character)) {
                    attacker = d->character->char_specials.fighting;
                    stop_fighting(d->character);
                  }
                  do_shapechange(d->character, "me", 0, 1); 
                  if (attacker)
                    attack(attacker, d->character);
                }
              }
	      
	      
	      /*. Kill any OLC stuff .*/
	      switch(d->connected)
		{ case CON_OEDIT:
		case CON_REDIT:
		case CON_ZEDIT:
		case CON_MEDIT:
		case CON_SEDIT:
		case CON_TRIGEDIT:
		  cleanup_olc(d, CLEANUP_ALL);
		default:
		  break;
		}
	      
	      if (d->character) {
		target_idnum = GET_IDNUM(d->character);
		/*
		 * Plug memory leak, from Eric Green.
		 */
		if (PLR_FLAGGED(d->character, PLR_MAILING) && d->str) {
		  if (*(d->str))
		    free(*(d->str));
		  free(d->str);
		}
		if (d->connected == CON_PLAYING) {
		  save_player(d->character);
		  act("$n has lost $s link.", TRUE, d->character, 0, 0, TO_ROOM);
		  sprintf(buf, "Closing link to: %s.", GET_NAME(d->character));
		  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
		  d->character->desc = NULL;
		} else {/*markquit*/
         if (GET_NAME(d->character)) {
           sprintf(buf, "Losing player: %s.", GET_NAME(d->character));
           mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
         } else {
           mudlog("Losing player: <null>.", CMP, LVL_IMMORT, TRUE);
         }
        d->character->desc = NULL;
		  free_char(d->character);
		}
	      } else
		mudlog("Losing descriptor without char.", CMP, LVL_IMMORT, TRUE);
	      
	      /* JE 2/22/95 -- part of my unending quest to make switch stable */
	      if (d->original && d->original->desc)
		d->original->desc = NULL;
	      
	      REMOVE_FROM_LIST(d, descriptor_list, next);
	      
	      if (d->showstr_head)
		free(d->showstr_head);
	      if (d->showstr_count)
		free(d->showstr_vector);
	      if (d->storage)
		free(d->storage);
	      
	      free(d);
	    }
	  
	  
	  
	  void check_idle_passwords(void)
	    {
	      struct descriptor_data *d, *next_d;
	      
	      for (d = descriptor_list; d; d = next_d) {
		next_d = d->next;
		if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME
                    && STATE(d) != CON_QANSI && STATE(d) != CON_MENU 
		    && STATE(d) != CON_ISPELL_BOOT) {
		  continue;
		}
		if (!d->idle_tics) {
		  d->idle_tics++;
		  continue;
		} else {
                  if (d->character && STATE(d) == CON_MENU)
                    save_player(d->character);
		  echo_on(d);
		  SEND_TO_Q("\r\nTimed out... goodbye.\r\n", d);
		  STATE(d) = CON_CLOSE;
		}
	      }
	    }
	  
	  
	  
	  /*
	   * I tried to universally convert Circle over to POSIX compliance, but
	   * alas, some systems are still straggling behind and don't have all the
	   * appropriate defines.  In particular, NeXT 2.x defines O_NDELAY but not
	   * O_NONBLOCK.  Krusty old NeXT machines!  (Thanks to Michael Jones for
	   * this and various other NeXT fixes.)
	   */
	  
d2209 7
a2215 9
	  
	  void nonblock(socket_t s)
	    {
	      long val;
	      
	      val = 1;
	      ioctlsocket(s, FIONBIO, &val);
	    }
	  
d2222 66
a2287 70
	  void nonblock(socket_t s)
	    {
	      int flags;
	      
	      flags = fcntl(s, F_GETFL, 0);
	      flags |= O_NONBLOCK;
	      if (fcntl(s, F_SETFL, flags) < 0) {
		perror("Fatal error executing nonblock (comm.c)");
		exit(1);
	      }
	    }
	  
	  
	  /* ******************************************************************
	   *  signal-handling functions (formerly signals.c)                   *
	   ****************************************************************** */
	  
	  
	  RETSIGTYPE checkpointing()
	    {
	      if (!tics) {
		log("SYSERR: CHECKPOINT shutdown: tics not updated");
		abort();
	      } else
		tics = 0;
	    }
	  
	  
	  RETSIGTYPE reread_wizlists()
	    {
	      void reboot_wizlists(void);
	      
	      mudlog("Signal received - rereading wizlists.", CMP, LVL_IMMORT, TRUE);
	      reboot_wizlists();
	    }
	  
	  
	  RETSIGTYPE unrestrict_game()
	    {
	      extern struct ban_list_element *ban_list;
	      
	      mudlog("Received SIGUSR2 - completely unrestricting game (emergent)",
		     BRF, LVL_IMMORT, TRUE);
	      ban_list = NULL;
	      restrict = 0;
         restrict_reason = RESTRICT_NONE;
	    }
	  
	  
	  RETSIGTYPE hupsig()
	    {
	      log("Received SIGHUP, SIGINT, or SIGTERM.  Shutting down...");
              circle_shutdown = TRUE;  /* added by Gurlaek 2/14/2000 */
	    }
	  
	  
	  /*
	   * This is an implementation of signal() using sigaction() for portability.
	   * (sigaction() is POSIX; signal() is not.)  Taken from Stevens' _Advanced
	   * Programming in the UNIX Environment_.  We are specifying that all system
	   * calls _not_ be automatically restarted for uniformity, because BSD systems
	   * do not restart select(), even if SA_RESTART is used.
	   *
	   * Note that NeXT 2.x is not POSIX and does not have sigaction; therefore,
	   * I just define it to be the old signal.  If your system doesn't have
	   * sigaction either, you can use the same fix.
	   *
	   * SunOS Release 4.0.2 (sun386) needs this too, according to Tim Aldric.
	   */
	  
d2291 7
a2297 7
	  sigfunc *my_signal(int signo, sigfunc * func)
	    {
	      struct sigaction act, oact;
	      
	      act.sa_handler = func;
	      sigemptyset(&act.sa_mask);
	      act.sa_flags = 0;
d2299 1
a2299 1
	      act.sa_flags |= SA_INTERRUPT;	/* SunOS */
d2301 6
a2306 6
	      
	      if (sigaction(signo, &act, &oact) < 0)
		return SIG_ERR;
	      
	      return oact.sa_handler;
	    }
d2308 4
a2311 4
	  
	  
	  void signal_setup(void)
	    {
d2313 1
a2313 1
	      struct itimerval itime;
d2315 20
a2334 20
	      struct timeval interval;
	      
	      /* user signal 1: reread wizlists.  Used by autowiz system. */
	      /* I'm removing the autowiz stuff. I'm leaving this here because
	       * it seems to serve some vital function. It may be able to be
	       * reassigned to something else now that autowiz is gone RSD 3/19/00
	       */
	      my_signal(SIGUSR1, reread_wizlists);
	      
	      /*
	       * user signal 2: unrestrict game.  Used for emergencies if you lock
	       * yourself out of the MUD somehow.  (Duh...)
	       */
	      my_signal(SIGUSR2, unrestrict_game);
	      
	      /*
	       * set up the deadlock-protection so that the MUD aborts itself if it gets
	       * caught in an infinite loop for more than 3 minutes.  Doesn't work with
	       * OS/2.
	       */
d2336 15
a2350 15
	      interval.tv_sec = 180;
	      interval.tv_usec = 0;
	      itime.it_interval = interval;
	      itime.it_value = interval;
	      setitimer(ITIMER_VIRTUAL, &itime, NULL);
	      my_signal(SIGVTALRM, checkpointing);
#endif
	      
	      /* just to be on the safe side: */
	      my_signal(SIGHUP, hupsig);
	      my_signal(SIGINT, hupsig);
	      my_signal(SIGTERM, hupsig);
	      my_signal(SIGPIPE, SIG_IGN);
	      my_signal(SIGALRM, SIG_IGN);
	      
d2353 1
a2353 1
	      my_signal(SIGABRT, hupsig);
d2356 1
a2356 1
	      my_signal(SIGFPE, hupsig);
d2359 1
a2359 1
	      my_signal(SIGILL, hupsig);
d2362 1
a2362 1
	      my_signal(SIGSEGV, hupsig);
d2365 3
a2367 3
	      
	    }
	  
d2369 12
a2380 12
	  
	  
	  /* ****************************************************************
	   *       Public routines for system-to-player-communication        *
	   **************************************************************** */
	  
	  void send_to_char(const char *messg, struct char_data *ch)
	    {
	      if (ch->desc && messg)
		SEND_TO_Q(messg, ch->desc);
	    }
	  
d2394 27
a2420 1
         SEND_TO_Q(messg, i);
d2422 1
a2422 31
	  
	  
	  void send_to_all(const char *messg)
	    {
	      struct descriptor_data *i;
	      
	      if (messg)
		for (i = descriptor_list; i; i = i->next)
		  if (!i->connected)
		    SEND_TO_Q(messg, i);
	    }
	  
	  void send_to_outdoor(char *messg, int zone_num)
	    {
	      struct descriptor_data *i;
	      
	      if (!messg || !*messg)
		return;
	      
	      for (i = descriptor_list; i; i = i->next)
		{
		  if (!i->connected && i->character && AWAKE(i->character) &&
		      OUTSIDE(i->character) && 
                      (IN_ZONE(i->character) == zone_num) &&
                      (STATE(i) == CON_PLAYING))
		    SEND_TO_Q(messg, i);
		}
	    }
	  
	  
	  
d2432 1
a2432 1
      SEND_TO_Q(messg, i->desc);
d2446 1
a2446 1
            SEND_TO_Q(rbuf, i->desc);
d2449 1
a2449 8
	  
	  
	  
	  char *ACTNULL = "<NULL>";
	  
#define CHECK_NULL(pointer, expression) \
  if ((pointer) == NULL) i = ACTNULL; else i = (expression);
	  
d2603 5
d2717 1
a2717 1
   SEND_TO_Q(CAP(lbuf), to->desc);
d2813 1
a2813 1
                  SEND_TO_Q(rbuf, to->desc);
d2821 3
@


1.123
log
@Removing maputil code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.122 2008/04/03 02:02:05 myc Exp myc $
a43 1
#include "ships.h"
a45 1
#include "worship.h"
a1065 4
      /* move the ships as appropriate */
      if(!(pulse % (400)))
	update_ships();
      
d2859 3
@


1.122
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.121 2008/04/02 03:24:44 myc Exp myc $
a48 1
#include "maputils.h"
a81 1
extern int mapnums[MAP_ROWS][MAP_COLS];
d394 21
a414 24
  /* Init sockets, run game, and cleanup sockets */
  void init_game(int port)
    {
      extern long reboot_pulse;
      extern int reboot_hours_base;
      extern int reboot_hours_deviation;
#ifndef NO_MAPS
      int rowcounter, colcounter, vnum_read;
      FILE* mapfile;
#endif
      srandom(time(0));
      
      log("Finding player limit.");
      max_players = get_max_players();
      
      if (num_hotboots == 0) {
        log("Opening mother connection.");
        mother_desc = init_socket(port);
      }
      
      event_init();
      
      boot_db();
      
d416 2
a417 2
      log("Signal trapping.");
      signal_setup();
a418 12
      
#ifndef NO_MAPS
      log("Loading Surface Map. ");
      mapfile = fopen("world/surface.map", "r");
      for (rowcounter = 0; rowcounter < MAP_ROWS; rowcounter++) {
	for (colcounter = 0; colcounter < MAP_COLS; colcounter++) {
	  fscanf(mapfile, "%d", &vnum_read);
	  mapnums[rowcounter][colcounter] = real_room(vnum_read);
	}
      }
      fclose(mapfile);
#endif  /*  NO_MAPS */
d2865 3
@


1.121
log
@Rewrote group code and removed all major group code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.120 2008/03/30 17:30:38 jps Exp myc $
a139 2
char *parse_color(const char *txt, struct descriptor_data *t);
int count_chars(char *txt, char character);
d273 1
d384 2
a385 3
      sprintf(buf, "\r\n%s%sHotboot recovery complete.%s\r\n",
              CCGRN(d->character, C_NRM), CCBLD(d->character, C_NRM),
              CCNRM(d->character, C_NRM));
a1222 82
  /* 
     Thanks to Krimson DIKUMUD for this code.
     currently siteless MUD.
  */
  int is_color(char c) {
    switch (c) {
    case 'x': return 30; break;
    case 'r': return 31; break;
    case 'g': return 32; break;
    case 'y': return 33; break;
    case 'b': return 34; break;
    case 'm': return 35; break;
    case 'c': return 36; break;
    case 'w': return 37; break;
      
      
    case '0': return 40; break;
    case '1': return 44; break;
    case '2': return 42; break;
    case '3': return 46; break;
    case '4': return 41; break;
    case '5': return 45; break;
    case '6': return 43; break;
    case '7': return 47; break;
    
    case 'f': return  1; break;
    case '&': return -1; break;
    default : return  0; break;
    }
  }
  
  
  char *interpret_colors(char *str, bool parse) {
    int clr = 37, bg_clr = 40, flash = 0;
    static char cbuf[MAX_STRING_LENGTH];
    char *cp, *tmp;  
    char i[256];
    
    if (!strchr(str, '&'))
      return (str);
    
    cp = cbuf;
    
    for (;;) {
      if (*str == '&') {
        str++;
        if ((clr = is_color(LOWER(*str))) > 0 && parse) {
          if (IS_UPPER(*str)) sprintf(i, "\x1b[1;");
          else                sprintf(i, "\x1b[0;");
	  
          if (clr >= 40) {
            bg_clr = 40;
            str++;
            continue;
          } else if (clr == 1) {
            flash = !flash;
            str++;
            continue;
          }
	  
          sprintf(i, "%s%s%d;%dm", i, (flash ? "5;" : ""), bg_clr, clr);
          tmp = i;
        } else if (clr == -1) {
          *(cp++) = '&';
          str++;
          continue;
        } else {
          str++;
          continue;
        }
        while ((*cp = *(tmp++)))
	  cp++;
        str++;
      } else if (!(*(cp++) = *(str++)))
        break;
    }
    
    *cp = '\0';
    return (cbuf);
  }
  
  
d1340 1
a1340 1
                  cur += sprintf(cur, "%s", KRED);
d1342 1
a1342 1
                  cur += sprintf(cur, "%s%s", KRED, KBLD);
d1348 1
a1348 1
                cur += sprintf(cur, "%s", KNRM);
d1524 17
a1540 26
  void make_prompt(struct descriptor_data *d)
    {
      char prompt[MAX_INPUT_LENGTH], *ptemp;

      /* reversed these top 2 if checks so that page_string() would work in */
      /* the editor */
      if (d->showstr_count) {
	sprintf(prompt,
		"\r[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
		d->showstr_page, d->showstr_count);
	write_to_descriptor(d->descriptor, prompt);
      }      
      else if (d->str)
	write_to_descriptor(d->descriptor, "] ");
      else if (!d->connected) {
	ptemp = parse_color(prompt_str(d->character), d);

	write_to_descriptor(d->descriptor, ptemp);

	if(ptemp) {
	  free(ptemp);
	  ptemp = NULL;
	}
      }
      
    }
d1653 10
a1662 4
  void write_to_output(const char *txt, struct descriptor_data *t)
    {
      int size;
      char *new_txt;
d1664 20
a1683 1
      new_txt = parse_color(txt, t);
d1685 14
a1698 1
      size = strlen(new_txt);
d1700 6
a1705 47
      /* if we're in the overflow state already, ignore this new output */
      if (t->bufptr < 0)
	return;
      
      /* if we have enough space, just write to buffer and that's it! */
      if (t->bufspace >= size) {
	strcpy(t->output + t->bufptr, new_txt);
	t->bufspace -= size;
	t->bufptr += size;
	free(new_txt);
	return;
      }
      /*
       * If we're already using the large buffer, or if even the large buffer
       * is too small to handle this new text, chuck the text and switch to the
       * overflow state.
       */
      if (t->large_outbuf || ((size + strlen(t->output)) > LARGE_BUFSIZE)) {
	t->bufptr = -1;
	buf_overflows++;
	free(new_txt);
	return;
      }
      buf_switches++;
      
      /* if the pool has a buffer in it, grab it */
      if (bufpool != NULL) {
	t->large_outbuf = bufpool;
	bufpool = bufpool->next;
      } else {                      /* else create a new one */
	CREATE(t->large_outbuf, struct txt_block, 1);
	CREATE(t->large_outbuf->text, char, LARGE_BUFSIZE);
	buf_largecount++;
      }
      
      strcpy(t->large_outbuf->text, t->output);     /* copy to big buffer */
      t->output = t->large_outbuf->text;    /* make big buffer primary */
      strcat(t->output, new_txt);   /* now add new text */
      
      /* calculate how much space is left in the buffer */
      t->bufspace = LARGE_BUFSIZE - 1 - strlen(t->output);
      
      /* set the pointer for the next write */
      t->bufptr = strlen(t->output);
      
      free(new_txt);
    }
a2879 200
 
 int count_chars(char *txt, char character)
   {
     int i, cnt = 0;
     
     for(i = 0; txt[i]; i++)
       if(txt[i] == character)
	 cnt++;
     
     return cnt;
   }
 /* Completely rewritten by gurlaek 7/8/1999 to fix overflows    */
 /* due to estimation of the malloc'ed strlen                    */
 /* this function returns a pointer to memory that MUST be freed */
 /* after use.  Use with care.                                   */
 char *parse_color(const char *txt, struct descriptor_data *t) {
   char new_txt[MAX_STRING_LENGTH], *toret;
   int i;
   bool too_long = FALSE;

   if(!t) {
     log("Error in parse_color, no one to send the message to!");
     return NULL;
   }
   
   memset(new_txt, 0x0, MAX_STRING_LENGTH);  /* clear the buffer */
   
   /* This fixes that ANNOYING color bleeding from prompt! -Nechtrous */
   if(t->character) {
     if((strlen(CCNRM(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
       strcat(new_txt, CCNRM(t->character, C_NRM));
     else
       too_long = TRUE;
   }
   /* the parser.. Huge but fast */
   for(i = 0; txt[i]; i++) {
     if(too_long) /* make sure not to overflow */
       break;
     if(txt[i] == '&') {
       i++;
       if(!(t->character)) {
	 if((strlen(new_txt) + 1) < MAX_STRING_LENGTH)
	   new_txt[strlen(new_txt)] = txt[i]; 
	 else
	   too_long = TRUE;
	 break;
       }
       else
	 switch(txt[i]) {
	 case '0' : 
	   if((strlen(CCNRM(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCNRM(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '1' : 
	   if((strlen(CCRED(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCRED(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '2' : 
	   if((strlen(CCGRN(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCGRN(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '3' : 
	   if((strlen(CCYEL(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCYEL(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '4' : 
	   if((strlen(CCBLU(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBLU(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '5' : 
	   if((strlen(CCMAG(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCMAG(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '6' : 
	   if((strlen(CCCYN(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCCYN(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '7' : 
	   if((strlen(CCWHT(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCWHT(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '8' : 
	   if((strlen(CCBLD(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBLD(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '9' : 
	   if((strlen(CCBLK(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBLK(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'u' : 
	   if((strlen(CCUND(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCUND(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'd' : 
	   if((strlen(CCDAR(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCDAR(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'b' : 
	   if((strlen(CCBLD(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBLD(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'R' : 
	   if((strlen(CCBRED(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBRED(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'G' : 
	   if((strlen(CCBGRN(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBGRN(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'Y' : 
	   if((strlen(CCBYEL(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBYEL(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'B' : 
	   if((strlen(CCBBLU(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBBLU(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'M' : 
	   if((strlen(CCBMAG(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBMAG(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'C' : 
	   if((strlen(CCBCYN(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBCYN(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'W' : 
	   if((strlen(CCBWHT(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBWHT(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case 'S' : 
	   if((strlen(CCBBLK(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
	     strcat(new_txt, CCBBLK(t->character, C_NRM));
	   else
	     too_long = TRUE;
	   break;
	 case '&' : 
	   if((strlen(new_txt) + 1) < MAX_STRING_LENGTH)
	     new_txt[strlen(new_txt)] = txt[i]; 
	   else
	     too_long = TRUE;
	   break;
	 default:  
	   break;
	 }
     }
     else {
       if(strlen(new_txt) + 1 < MAX_STRING_LENGTH)
	 new_txt[strlen(new_txt)] = txt[i]; 
       else
	 too_long = TRUE;
     }
   }
   if(too_long)
     log("SYSERR:comm.c:parse_color(): Converted string exceeds MAX_STRING_LENGTH");

   CREATE(toret, char, sizeof(new_txt));
   strcpy(toret, new_txt);
   return toret; /* the colorized buffer */
 }
 
d2882 3
@


1.120
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.119 2008/03/28 17:54:53 myc Exp jps $
a85 3
long exp_to_level(int, int);
bool DisarmCheck(struct char_data * ch);
void die(struct char_data * ch, struct char_data * killer);
d1498 3
a1500 3
          if (ch->groupmaster) {
            temp = (100 * GET_HIT(ch->groupmaster)) / MAX(1, GET_MAX_HIT(ch->groupmaster));
            cur += sprintf(cur, "%s &0(%s&0)", PERS(ch->groupmaster, ch),
d1512 2
a1513 2
          if (ch->groupmaster)
            cur += sprintf(cur, "%s", PERS(ch->groupmaster, ch));
d3178 4
@


1.119
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.118 2008/03/17 15:31:27 myc Exp myc $
d58 1
d3181 4
@


1.118
log
@Shutdown reboot will exit with a normal status code now, and go
through normal shutdown routines (like memory checks).
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.117 2008/03/08 22:29:06 myc Exp myc $
d154 1
a154 1
void affect_update(void);	/* In spells.c */
d276 2
d372 4
a375 2
      if (!PLR_FLAGGED(d->character, PLR_DELETED))
        REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING | PLR_MAILING);
d1082 1
a1082 1
	  affect_update();
d1315 1
a1315 1
  struct affected_type *aff;
d1324 1
a1324 1
  color = (PRF_FLAGGED(ch, PRF_COLOR_1 | PRF_COLOR_2) ? 1 : 0);
d1422 4
a1425 4
          for (aff = ch->affected; aff; aff = aff->next)
            if (aff->duration >= 0 && (!aff->next || aff->next->type != aff->type)) {
              if (color && AFF_FLAGGED(ch, AFF_DETECT_MAGIC)) {
                if (aff->duration <= 1)
d1427 1
a1427 1
                else if (aff->duration <= 3)
d1431 3
a1433 3
                             skills[aff->type].name,
                             aff->next ? " " : "");
              if (color && AFF_FLAGGED(ch, AFF_DETECT_MAGIC))
d2062 1
a2062 1
		  if (ISNEWL(*ptr))
d2151 1
a2151 1
	      while (ISNEWL(*nl_pos))
d2157 1
a2157 1
		if (ISNEWL(*ptr))
d2250 1
a2250 1
                  if (IS_FIGHTING(d->character)) {
d3180 4
@


1.117
log
@Moving shapechange and chant to the cooldown systems.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.116 2008/03/07 21:21:57 myc Exp myc $
d492 1
a492 1
      if (circle_reboot) {
d494 2
a495 3
	exit(52);			/* what's so great about HHGTTG, anyhow? */
      }
      log("Normal termination of game.");
d3176 3
@


1.116
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.115 2008/03/06 05:11:51 myc Exp myc $
a147 1
void chant_update(void);
a1082 5
          /* Don't be fooled by the word chant. This is also
             used as a time out for shapechange as well. So
             please keep this in mind when changing anything
             in this function. Zantir 2/20/01 */
          chant_update();
a2875 22
/* This function is used by chant and shapechange. Please keep this
   in mind when changing things in this function. Zantir 2/20/01 */
void chant_update(void)
{
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next) {
    if (STATE(d) != CON_PLAYING || !d->character)
      continue;
    if (d->original && GET_LEVEL(d->original) < LVL_IMMORT &&
        (IS_GOOD(d->character) || IS_EVIL(d->character))) {
      send_to_char("You betray your true nature and lose control of the shapechange.\r\n", d->character);
      do_shapechange(d->character, "me", 0, 1);
      continue;
    }
    if (d->character->player_specials->chant > 0)
      d->character->player_specials->chant--;
    else
      d->character->player_specials->chant = 0;
  }
}

d3177 5
@


1.115
log
@Combined the 'saved' and 'unsaved' portions of the char_specials and
player_specials structures by moving all fields of each saved structure
to its parent structure.  Also combined the skills array from the
player and mob structures since they are identical.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.114 2008/03/06 04:34:38 myc Exp myc $
a87 1
void update_skill_usages();
a818 1
      struct char_data *t_ch = NULL;
a1031 40
	for (d = descriptor_list; d; d = d->next) {
	  
	  if (d->character && d->connected == CON_PLAYING) {
	    t_ch = d->character;
	    
	    
	    if (t_ch->char_specials.action_delays[ACT_DELAY_BASH])
	      --(t_ch->char_specials.action_delays[ACT_DELAY_BASH]);
	    
	    if (t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID])
	      --(t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]);
	    
	    /* paladin/anti innates */
	    if (t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT])
	      --(t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]);
	    
	    if (t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS])
	      --(t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS]);
	    
	    if (t_ch->char_specials.action_delays[ACT_DELAY_BERSERK])
	      --t_ch->char_specials.action_delays[ACT_DELAY_BERSERK];
	    
	    if (t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL])
	      --t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL];
	    
	    if ((t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0) ||
		(t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0) ||
		(t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0) ||
		(t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0)) {
	      (void) DisarmCheck(t_ch);
	    }
	    if (t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT] > 0) {
	      --t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT];
	    }
	    /* ACT_DELAY_DISARM handled in perform_violence() */
	  }
	}
	
	
	
a1051 3
      if (!(pulse % (PASSES_PER_SEC / 2)))
	update_skill_usages(); 
      
a3202 22
 
void update_skill_usage(struct char_data* ch) 
{
   int skill; 
   for (skill = 401; skill < 401 + MAX_SKILL_TIMERS; skill++) {
      if (SKILL_DELAY(ch, skill)) 
         SKILL_DELAY(ch, skill)--; 
   }
}


void update_skill_usages()
{
   struct descriptor_data* d; 

   for (d = descriptor_list; d; d = d->next) {
      if (d->character && d->character->player_specials) {
         update_skill_usage(d->character); 
      }
   }
}

d3205 6
@


1.114
log
@Added a PULSE_AUTOSAVE define that regulates how often autosaves occur.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.113 2008/03/05 05:21:56 myc Exp myc $
d2942 2
a2943 2
    if (d->character->player_specials->saved.chant > 0)
      d->character->player_specials->saved.chant--;
d2945 1
a2945 1
      d->character->player_specials->saved.chant = 0;
d3272 3
@


1.113
log
@Removed some debug logs lines from hotboot.  Bank coins are ints instead
of longs now.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.112 2008/03/05 03:03:54 myc Exp myc $
d1141 1
a1141 1
      if (auto_save && !(pulse % (60 * PASSES_PER_SEC))) {	/* 1 minute */
d3272 4
@


1.112
log
@Ascii pfiles change the way players are loaded.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.111 2008/02/24 17:31:13 myc Exp myc $
a388 1
log("OKAY SO FAR");
a389 1
log("STILL OKAY");
a390 1
log("HMMMM");
a391 1
log("GOING STRONG");
d1503 1
a1503 1
          cur += sprintf(cur, "&0%ld&6&8p&0 %ld&3&8g&0 %lds %ld&3c&0", 
d1634 1
a1634 1
          cur += sprintf(cur, "%ld", GET_BANK_PLAT(ch));
d1637 1
a1637 1
          cur += sprintf(cur, "%ld", GET_BANK_GOLD(ch));
d1640 1
a1640 1
          cur += sprintf(cur, "%ld", GET_BANK_SILVER(ch));
d1643 1
a1643 1
          cur += sprintf(cur, "%ld", GET_BANK_COPPER(ch));
d3272 3
@


1.111
log
@Added a TO_OLC flag to act() to allow messages to be sent to people
while in OLC if they have OLCComm toggled on.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.110 2008/02/24 06:31:41 myc Exp myc $
d57 1
a317 1
  struct char_file_u tmp_store;
d371 1
a371 3
    if ((player_i = load_char(name, &tmp_store)) >= 0) {
      store_to_char(&tmp_store, d->character);
      GET_PFILEPOS(d->character) = player_i;
d389 1
d391 1
d393 1
d395 1
d3276 4
@


1.110
log
@The world command will now show many hotboots have ocurred since the
last shutdown.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.109 2008/02/16 20:26:04 myc Exp myc $
a2950 5
#ifndef SENDOK
#define SENDOK(ch) ((ch)->desc && (AWAKE(ch) || sleep) && \
		    !PLR_FLAGGED((ch), PLR_WRITING))
#endif

d2955 1
a2955 2
   static int sleep;
   int in_room, i;
d2959 2
a2960 2
   if (!(dg_act_check = !(type & DG_NO_TRIG)))
      type &= ~DG_NO_TRIG;
d2969 2
d2973 6
a2978 3
   if ((sleep = (type & TO_SLEEP)))
      type &= ~TO_SLEEP;
    
d3274 4
@


1.109
log
@Adding zmalloc, a lightweight memory debugger that wraps all malloc
and free calls, keeping track of your memory expenditures.  To be
effective, however, we have to free the database and a lot of other
stuff at program termination, so adding a lot of functions to do all
of that.  Also adding some more prompt codes.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.108 2008/02/09 18:29:11 myc Exp myc $
d117 1
a117 1
bool fHotBoot = FALSE;          /* Are we doing a hotboot? */
d224 1
a224 1
      fHotBoot = TRUE;
d339 2
a340 1
  fscanf(fp, "%ld\n", &boot_time);
d415 1
a415 1
      if (!fHotBoot) {
d447 1
a447 1
      if (fHotBoot)
d3275 7
@


1.108
log
@No need for the name_timeout eventfunc here.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.107 2008/02/09 07:05:37 myc Exp myc $
d54 3
d147 2
d173 5
a179 3
/* Local functions */
void chant_update(void);

d204 4
a278 2
    log("Done.");
    exit(0);
d284 24
a1508 1
        case 'O':
d1523 5
a1528 1
        case 'T':
d1543 23
d1796 1
a1796 1
  
d1854 13
d3274 3
@


1.107
log
@Copyover is now renamed to hotboot.  Fixed the color codes in the
hotboot messages.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.106 2008/02/09 04:27:47 myc Exp myc $
a84 1
EVENTFUNC(name_timeout);
d3202 4
@


1.106
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.105 2008/02/09 03:04:23 myc Exp myc $
d115 1
a115 1
bool fCopyOver;                 /* Are we booting in copyover mode? */
d213 2
a214 2
    case 'C': /* -C<socket number> recover from copyover, this is the control socket */
      fCopyOver = TRUE;
d280 1
a280 1
void copyover_recover()
d293 1
a293 1
  log("Copyover recovery initiated.");
d295 1
a295 1
  fp = fopen(COPYOVER_FILE, "r");
d298 2
a299 2
    perror("copyover_recover:fopen");
    log("Copyover (hotboot) file not found.  Exiting.\r\n");
d304 1
a304 1
  unlink(COPYOVER_FILE);
d354 4
a357 1
      write_to_descriptor(desc, "\r\n&2&8Hotboot recovery complete.&0\r\n");
d382 1
a382 1
      if (!fCopyOver) {
d414 2
a415 2
      if (fCopyOver)
        copyover_recover();
d3203 3
@


1.105
log
@Adding the 'copyover' command, which allows you to do a hot-boot
without disconnecting anybody.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.104 2008/02/06 21:53:53 myc Exp myc $
d53 1
d3200 4
@


1.104
log
@Make the format arg to act() const.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.103 2008/02/02 04:27:55 myc Exp myc $
d114 4
d142 2
a192 1
  int port;
d212 4
d258 1
a258 1
    if (chdir(dir) < 0) {
d260 12
a271 4
      perror("Fatal error changing to data directory");
      exit(1);
    }
    sprintf(buf, "Using %s as data directory.", dir);
d273 2
d276 81
a356 8
    if (scheck) {
      boot_world();
      log("Done.");
      exit(0);
    } else {
      sprintf(buf, "Running game on port %d.", port);
      log(buf);
      init_game(port);
a357 2
    
    return 0;
d359 3
a361 2
  
  
a365 1
      int mother_desc;
d378 4
a381 2
      log("Opening mother connection.");
      mother_desc = init_socket(port);
d409 3
d1798 19
a1822 1
    static int last_desc = 0;	/* last descriptor number */
d1890 1
a1890 13
    /* initialize descriptor data */
    newd->descriptor = desc;
    newd->connected = CON_QANSI;
    newd->idle_tics = 0;
    newd->wait = 1;
    newd->output = newd->small_outbuf;
    newd->bufspace = SMALL_BUFSIZE - 1;
    newd->next = descriptor_list;
    newd->login_time = time(0);
    
    if (++last_desc == 1000)
      last_desc = 1;
    newd->desc_num = last_desc;
d1893 1
d3199 3
@


1.103
log
@Adding time triggers (they execute at a given mud time each day).
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.102 2008/01/30 19:20:57 myc Exp myc $
d2779 1
a2779 1
void act(char *str, int hide_invisible, struct char_data *ch, struct obj_data *obj, const void *vict_obj, int type)
d3097 3
@


1.102
log
@Removing the loopy gravity code from here.  It's now an event.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.101 2008/01/29 21:02:31 myc Exp myc $
d1004 1
d1009 1
a1009 1
	update_ships();/*_update();*/
d3097 3
@


1.101
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.100 2008/01/29 16:51:12 myc Exp myc $
a136 2
void do_gravity_check(void);
void do_falling_damage(struct char_data *ch, float dist_fell);
a960 3
      if (!(pulse % (PASSES_PER_SEC / 2))) 		/* 1/2 second */
	do_gravity_check(); 
      
a3071 65
/* falling_yell - when you first start falling, your yell of surprise is heard
 * in the surrounding rooms. */

void falling_yell(struct char_data *ch) {
   int door, was_in, other_room, backdir, i;
   char *dirstr;

   was_in = ch->in_room;

   for (door = 0; door < NUM_OF_DIRS; door++) {
      if (CAN_GO (ch, door)) {
         /* Make sure there is an actual destination room */
         if ((other_room = world[was_in].dir_option[door]->to_room) != NOWHERE) {

            /* other_room will get a scream.
             * If it has an exit back to this room, use that direction as where
             * the scream "came from". Otherwise, use the opposite of the direction
             * going to other_room. */
            backdir = -1;

            /* does the destination room have an exit pointing back? */
            if (world[other_room].dir_option[rev_dir[door]])
               /* does that exit point back to this room? */
               if (world[other_room].dir_option[rev_dir[door]]->to_room == was_in)
                  backdir = rev_dir[door];

            /* No exit pointing directly back?  Search for any exit pointing back. */
            if (backdir == -1) {
               for (i = 0; i < NUM_OF_DIRS; i++)
                  if (world[other_room].dir_option[i] && world[other_room].dir_option[i]->to_room == was_in) {
                     backdir = i;
                     break;
                  }
            }

            /* Couldn't find any exits back. But since *this* room does have an exit going
             * to that room, we *will* send the sound. */
            if (backdir == -1)
               backdir = rev_dir[door];

            if (backdir == 5)
               dirstr = "below";
            else if (backdir == 4)
               continue; /* No yell - you'll receive "<person> falls screaming from above" */
            else {
               sprintf(buf2, "the %s", dirs[backdir]);
               dirstr = buf2;
            }

            sprintf(buf, "You hear a %s %s from %s, which quickly fades.",
                  number(0, 10) < 5 ? "surprised" : "sudden",
                  number(0, 10) < 6 ? "shriek" : "yelp", dirstr);

            ch->in_room = other_room;
            act(buf, FALSE, ch, 0, 0, TO_ROOM);
            ch->in_room = was_in;
         }
      }
   }
}

 /*  This function scans every room of the mud and checks for IN_FLIGHT */
 /*  once IN_FLIGHT rooms are found, every non flying obj, PC, NPC */
 /*  falls to the earth and takes damage according to size and number */
 /*  of rooms fallen.  This also takes into account landing in water. */
a3072 267
void do_gravity_check(void)
{
  struct obj_data *i, *j;
  struct char_data *ch = 0;
  int was_in, zn, rn, rrn, k, screwed, dest_room;
  int riding = FALSE, ridden_by = FALSE, flying = FALSE;
  char gravbuf[MAX_STRING_LENGTH];

  /*  Cycle through each zone */
     
  for (zn = 0; zn <= top_of_zone_table; zn++) {
    if (zone_table[zn].top) {
      /*  Cycle through each room in zone */
      for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) {
        if (real_room(rn) != NOWHERE) {
          rrn = real_room(rn);
          if (world[rrn].sector_type == SECT_FLYING) {
          /*  start the gravity check for objects */
          i = world[rrn].contents;
          while (i) {
            /*  check each object */
            if ((j = i->next_content)) {
              if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
                  (strcmp(j->description,i->description)==0)) ||
                  ((j->item_number==i->item_number) && (i->item_number!=NOTHING)))
              {
                i = j;
                continue;
              }
            }

            /*  make it fall */
            screwed = FALSE;
            while (!screwed && SECT(i->in_room) == SECT_FLYING && !IS_OBJ_SPELL_AFF(i, AFF_FLYING) 
                && i->obj_flags.type_flag != ITEM_PORTAL) {
              if (CAN_GO(i, DOWN)) {
                /*  display to people in room object is falling from */
                act("$p &1&bplummets&0 &2downward!&0",FALSE,0,i,0,TO_ROOM);

                was_in = i->in_room;
                dest_room = world[was_in].dir_option[DOWN]->to_room;

                /* display to people object falls through */
                for (ch = world[dest_room].people;
                    ch != NULL; ch = ch->next_in_room)
                  act("$p &1&bfalls from above.&0",FALSE,ch,i,0,TO_CHAR);

                if (SECT(dest_room) != SECT_FLYING) {
                  /* time to land */
                  screwed = TRUE;
                  if (IS_SPLASHY(dest_room)) {
                    for (ch = world[dest_room].people; 
                        ch != NULL; ch = ch->next_in_room)
                      act("$p &1&blands with a loud&0 &1SPLASH!&0",FALSE,ch,i,0,TO_CHAR);
                  } else {
                    /* land on solid ground */
                    act("$p &1&blands with a dull&0 &1THUD!&0",FALSE,0,i,0,TO_ROOM);
                  }
                }
              } else {
                /* No Down exit! */
                sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit",
                      world[i->in_room].number);
                log(gravbuf);
                screwed = TRUE;
              }
              obj_from_room(i);
              obj_to_room(i, dest_room);
            }
            i = j;
          }
            
            /*  end of object gravity check */
            /*  start the gravity check for characters */
            
          for (ch = world[rrn].people; ch != NULL; ch = ch->next_in_room) {
            k = 0;
            flying = 0;
            riding = 0;
            ridden_by = 0;
            /*if (GET_POS(ch) == POS_FLYING) flying = 1;*/
            if (IS_AFFECTED(ch, AFF_FLYING) || GET_LEVEL(ch) >= LVL_IMMORT)  flying = 1;
           
           /* If either mount or mountee is flying then don't fall */
           /* otherwise unmount and prepare to fall... */
           
           if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING)
           {
             riding = 1;
             if ( IS_AFFECTED(RIDING(ch), AFF_FLYING))
           /*if ((GET_POS(RIDING(ch)) == POS_FLYING))*/
             { flying = 1; }
           }
           if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) 
           {
             ridden_by = 1;
             
             if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) 
          /* if (GET_POS(RIDDEN_BY(ch)) == POS_FLYING) */
               { flying = 1; }
           }
           if (riding && !flying) dismount_char(ch);
           if (ridden_by && !flying) dismount_char(RIDDEN_BY(ch));
           
           /* Make them fall */
           
           screwed = FALSE;
           while (SECT(ch->in_room) == SECT_FLYING && 
          /*      (GET_POS(ch) != POS_FLYING) && */
           /*     (GET_POS(ch) != POS_FIGHTING) && */
               !flying && 
               !screwed) {
             
             if(CAN_GO(ch, DOWN)) {
               k++;
               
               was_in = ch->in_room;
               
               /*  Message to room fall started in */
               
               if (k == 1) {
             if (IS_AFFECTED2(ch, AFF2_LEVITATE)) {
                   act("&1&bYou find yourself in midair and begin descending.&0\r\n"
                      , FALSE, ch, 0, 0, TO_CHAR);
                   act("&1&b$n finds $mself in midair and begins descending.&0"
                      , FALSE, ch, 0, 0, TO_ROOM);
             } else {
                   act("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n"
                      , FALSE, ch, 0, 0, TO_CHAR);
                   act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0"
                      , FALSE, ch, 0, 0, TO_ROOM);
                if (!AFF2_FLAGGED(ch, AFF2_SILENCE))
                  falling_yell(ch);
             }
               }
               
               char_from_room(ch);
               char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
               
               /*  Message to rooms falling through */
               
               /* David Endre 3/8/99 Send different message if they are a monk with safefall */
               /* send_to_char("&2DOWN!&0\r\n", ch); */
           if (IS_AFFECTED2(ch, AFF2_LEVITATE)) {
             act("&2You float slowly downward.&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
                 act("&2$n floats slowly down from above.&0", FALSE, ch, 0, 0, TO_ROOM);
           } else if (GET_SKILL(ch, SKILL_SAFEFALL) == 0) {
                 act("&2DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
                 act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
               } else {
                 act("&2You fall gracefully DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
                 act("&2$n gracefully falls from above.&0", FALSE, ch, 0, 0, TO_ROOM);
               }
               if (ch->desc != NULL)
                 look_at_room(ch, 0);
               
               if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
                 do_falling_damage(ch, k);
               }
             } else {
               
               /* No Down exit! */
               
               sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit", world[ch->in_room].number);
               log(gravbuf);
               screwed = TRUE;
             }
           }
            }
          }
        }
      }
       }
     }
     return;
   }
 
 
void do_falling_damage(struct char_data *ch, float dist_fell)
{
   /* Levitation protects from damage */
   if (IS_AFFECTED2(ch, AFF2_LEVITATE)) {
      if((SECT(ch->in_room) == SECT_WATER_SWIM || 
            SECT(ch->in_room) == SECT_WATER_NOSWIM || 
            SECT(ch->in_room) == SECT_OCEAN)) { 
         act("\r\nYou come to rest above the surface of the water.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n comes to rest above the surface of the water.", FALSE, ch, 0, 0, TO_ROOM);
      } else {
         act("\r\nYou come to rest just above the ground.", FALSE, ch ,0, 0, TO_CHAR);
         act("$n's descent ends just above the ground.", FALSE, ch, 0, 0, TO_ROOM);
      }
      return;

   /* Are we landing in water? It hurts MUCH less... */
   /* If we have safe fall skill, then we take no damage
      for five rooms, partially for 5-15 and full at 15 David Endre 3/8/99 */
   } else if ((SECT(ch->in_room) == SECT_WATER_SWIM || 
         SECT(ch->in_room) == SECT_WATER_NOSWIM || 
         SECT(ch->in_room) == SECT_OCEAN)) { 
      act("\r\nYou land with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_CHAR);
      act("$n lands with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
      if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
         if (dist_fell <= 5)
            GET_HIT(ch) -= 0;
         else if (dist_fell < 15)
            GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch)) * (dist_fell/15));
         else
            GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
      } else
         GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
      update_pos(ch);
   } else {
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
      if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell <=5) {
         GET_POS(ch) = POS_STANDING;
         GET_POS1(ch) = POS1_STANDING;
         act("\r\nYou tuck and roll, performing a beautiful landing!", FALSE, ch ,0, 0, TO_CHAR);
         act("$n tucks and rolls, performing a beautiful landing!", FALSE, ch, 0, 0, TO_ROOM);
      } else if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell < 15) {
         act("\r\nYou gracefully land without taking too much damage.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n gracefully lands without taking too much damage.", FALSE, ch, 0, 0, TO_ROOM);
      } else {
         act("\r\nYou land with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_CHAR);
         act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
      }
      if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
         if (dist_fell <= 5)
            GET_HIT(ch) -= 0;
         else if (dist_fell < 15)
            GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch)) * (dist_fell/15));
         else
            GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
      } else
         GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
      update_pos(ch);
   }
   switch (GET_POS(ch)) {
      case POS_MORTALLYW:
         act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
         send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
         break;
      case POS_INCAP:
         act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
         send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
         break;
      case POS_STUNNED:
         act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
         send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
         break;
      case POS_DEAD:
         act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You are dead!  Sorry...\r\n", ch);
         sprintf(buf2, "%s killed by falling at %s", GET_NAME(ch), world[ch->in_room].name);
         mudlog(buf2, BRF, 0, TRUE);
         die(ch, NULL);
         break;
      default:
         break;
   }
   alter_hit(ch, 0, TRUE);
   update_pos(ch);
}


d3096 4
@


1.100
log
@Moving skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.99 2008/01/27 21:09:12 myc Exp myc $
d52 1
a72 1
/* extern FILE *player_fl; */
d78 1
a78 11
extern struct index_data *obj_index;
extern char *race_abbrevs[];
extern char *size_abbervs[];
extern int rev_dir[];
extern char *dirs[];

extern struct room_data *world;	/* In db.c */
extern int top_of_world;	/* In db.c */
extern int top_of_zone_table;
extern struct time_info_data time_info;		/* In db.c */
extern char help[];
d3433 3
@


1.99
log
@Took out the spell circle codes from prompt and adding rage.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.98 2008/01/26 14:26:31 jps Exp myc $
d1363 1
a1363 1
                             skillnames[aff->type],
d2793 1
a2793 1
void act(char *str, int hide_invisible, struct char_data *ch, struct obj_data *obj, void *vict_obj, int type)
d3443 3
@


1.98
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.97 2008/01/25 21:05:45 myc Exp jps $
a1247 1
  extern int spells_of_circle[(LVL_IMPL + 1)][(NUM_SPELL_CIRCLES + 1)];
a1290 6
   * 4    Last two chars were %s; next one is a control number (for number 
   *      of spells memmed in a particular circle).
   * 5    Last two chars were %s; next one is a control number (for 
   *      remaining spell slots in a particular circle).
   * 6    Last two chars were %s; next one is a control number (for total 
   *      spell slots in a particular circle).
a1422 4
        case 's':
          /* Spells currently memmed in a circle. */
          expecting = 4;
          break;
d1424 1
a1424 6
          /* Spell slots remaining in a circle. */
          expecting = 5;
          break;
        case 'S':
          /* Spell slots total in a circle. */
          expecting = 6;
a1504 27
    else if (expecting == 4 || expecting == 5 || expecting == 6) {
      /* Is there a better way to turn a char digit into an int? */
      if (*raw > '0' && *raw <= '9')
        temp = *raw - '0';
      else if (*raw >= 'a' && *raw <= 'e')
        /* make 'a' worth 10, 'b' worth 11, etc. */
        temp = *raw - 'a' + 10;
      else if (*raw >= 'A' && *raw <= 'E')
        /* make 'A' worth 10, 'B' worth 11, etc. */
        temp = *raw - 'A' + 10;
      else
        temp = 0;
      /* Temp now contains the circle number, or 0 for invalid. */
      if (temp && !IS_NPC(ch)) {
        if (expecting == 4)
          /* do spells memmed. */
          temp = GET_MEMMED(temp);
        else if (expecting == 5)
          /* do spell slots remaining. */
          temp = spells_of_circle[(int)GET_LEVEL(ch)][temp] - (int) GET_MEMMED(temp);
        else if (expecting == 6)
          /* do total spell slots. */
          temp = spells_of_circle[(int)GET_LEVEL(ch)][temp];
        cur += sprintf(cur, "%d", temp);
      }
      expecting = 0;
    }
d3443 3
@


1.97
log
@Added attack() as a macro alias for hit() with fewer arguments.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.96 2008/01/15 06:51:47 myc Exp $
d51 1
a1250 1
  extern char *spells[];
d1370 1
a1370 1
                             spells[aff->type],
d3486 3
@


1.96
log
@Made a change to exp_bar; it now accepts a sub-gradient size.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.95 2008/01/10 05:39:43 myc Exp myc $
d2185 1
a2185 1
                    hit(attacker, d->character, TYPE_UNDEFINED);
d3486 3
@


1.95
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.94 2008/01/09 04:14:19 jps Exp myc $
d1249 1
a1249 1
  extern char *exp_bar(struct char_data *ch, int length, int gradations, bool color);
d1352 1
a1352 1
          cur += sprintf(cur, "%s", exp_bar(ch, 20, 20, color));
d3486 4
@


1.94
log
@Remove spell mem and scribe funcs now that that's handled by events.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.93 2008/01/05 05:37:04 jps Exp jps $
d3458 1
a3458 1
   alter_hit(ch, 0, 1);
d3486 3
@


1.93
log
@Changed name of function save_char() to save_player(). Because it
only operates on players.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.92 2008/01/04 04:30:47 jps Exp jps $
a82 2
extern void update_spell_mem(void);
extern void update_spell_scribe(void);
a992 1
	update_spell_mem();
a1001 1
        update_spell_scribe();      
d3486 4
@


1.92
log
@Made spellcasting into an event.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.91 2007/12/25 05:21:49 jps Exp jps $
d2218 1
a2218 1
		  save_char(d->character);
d2270 1
a2270 1
                    save_char(d->character);
d3490 3
d3511 1
a3511 1
 * allows you to output a const string without casting it.  save_char()
@


1.91
log
@Remove comments about trouble with obj_to_room - now alleviated due to
improved event code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.90 2007/12/20 23:10:39 myc Exp jps $
a162 1
void update_casting(void);
a1001 1
	update_casting();
d3490 4
@


1.90
log
@Adding some new prompt control codes:
  i/I  hiddenness
  a/A  alignment
  n    current char's name
  N    if switched, original char's name, otherwise current
  e    exp TNL in bar form
  E    exp progress message
  l/L  list of active spells
Changed speech_report to just send_to_char instead of buffering it.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.89 2007/12/19 20:45:06 myc Exp myc $
a3241 3
                /* Cannot place the object in the room yet, because obj_to_room()
                 * will destroy it if it sinks in water - but we still need the
                 * object for sending of messages. */
a3267 6
              /* Ok to move the object to the room now.
               * We have ASSUMED that obj_to_room() will only destroy
               * the object if it sinks in a water room. For now, that's true.
               * If in the future we have lava rooms that burn objects up,
               * and this code doesn't get modified to take that into account,
               * say hello to crashing! */
d3492 11
@


1.89
log
@Added const modifiers to the char arguments to write_to_output,
send_to_char, send_to_zone, send_to_room, and parse_color, which
allows you to output a const string without casting it.  save_char()
no longer requires a save room (which wasn't being used anyway).
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.88 2007/11/28 09:52:19 jps Exp myc $
d1252 1
d1254 3
d1340 42
d2642 1
a2642 1
void speech_report(char *buf, struct char_data *ch, struct char_data *tch)
d2645 1
d2672 4
a2675 1
      strcat(buf, "&5&bYou have an acute case of laryngitis.&0\r\n");
d2677 4
a2680 1
      strcat(buf, "&5Your throat feels a little sore.&0\r\n");
d3501 6
@


1.88
log
@Clean up do_gravity_check() a bit, and hopefully avoid an intermittent
crash bug that would strike when a falling object ended up sinking
in water.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.87 2007/11/18 16:51:55 myc Exp jps $
d146 1
a146 1
char *parse_color(char *txt, struct descriptor_data *t);
d1657 1
a1657 1
  void write_to_output(char *txt, struct descriptor_data *t)
d2174 1
a2174 1
		  save_char(d->character, NOWHERE);
d2226 1
a2226 1
                    save_char(d->character, NOWHERE);
d2417 1
a2417 1
	  void send_to_char(char *messg, struct char_data *ch)
d2423 1
a2423 1
void send_to_zone(char *messg, int zone_num, int skip_room, int min_position)
d2440 1
a2440 1
	  void send_to_all(char *messg)
d2469 1
a2469 1
void send_to_room(char *messg, int room)
d2898 1
a2898 1
 char *parse_color(char *txt, struct descriptor_data *t) {
d3448 5
@


1.87
log
@Adding OBSERVATORY behavior to send_to_room.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.86 2007/10/23 20:20:22 myc Exp myc $
a3143 1

d3149 9
a3157 10
 /*  --Fingon */
 
 
 void do_gravity_check(void)
   {
     struct obj_data *i, *j;
     struct char_data *ch = 0;
     int was_in, zn, rn, rrn, k, screwed;
     int riding = FALSE, ridden_by = FALSE, flying = FALSE;
     char gravbuf[MAX_STRING_LENGTH];
d3159 120
a3278 160
     /*  Cycle through each zone */
     
     for (zn = 0; zn <= top_of_zone_table; zn++) 
     {
       if (zone_table[zn].top) 
       {
	 /*  Cycle through each room in zone */
	 for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) 
	 {
	   if (real_room(rn) != NOWHERE) 
	   {	
	     rrn = real_room(rn);
	     if (world[rrn].sector_type == SECT_FLYING) 
	   {
	       
	     /*  start the gravity check for objects */
	       
	     i = world[rrn].contents;
	     while(i) 
	     {
	       /*  check each object */
	       if ((j=i->next_content)) 
	       {
		 if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
			(strcmp(j->description,i->description)==0)) ||
		       ((j->item_number==i->item_number) && (i->item_number!=NOTHING)))
		 {
		   i = j;
		   continue;
		 }
	       }
		 
	       /*  make it fall */
		 
	       screwed = FALSE;
	       while (SECT(i->in_room) == SECT_FLYING && !IS_OBJ_SPELL_AFF(i, AFF_FLYING) 
		   && i->obj_flags.type_flag != ITEM_PORTAL && !screwed) 
	       {
		 if(CAN_GO(i, DOWN)) 
		 {
		     
		     /*  display to people in room object is falling from */
		     
		     act("$p &1&bplummets&0 &2downward!&0",FALSE,0,i,0,TO_ROOM);
		     was_in = i->in_room;
		     
		     /* display to people object falls through */
		     
		     for (ch = world[EXIT(i, DOWN)->to_room].people; 
			  ch != NULL; ch = ch->next_in_room)
		       act("$p &1&bfalls from above.&0",FALSE,ch,i,0,TO_CHAR);
		     
		     if (SECT(EXIT(i, DOWN)->to_room) != SECT_FLYING) {
		       
				/*  time to land */
		       
		       if((SECT(EXIT(i, DOWN)->to_room) == SECT_WATER_SWIM || 
			   SECT(EXIT(i, DOWN)->to_room) == SECT_WATER_NOSWIM || 
			   SECT(EXIT(i, DOWN)->to_room) == SECT_OCEAN)) { 
			 for (ch = world[EXIT(i, DOWN)->to_room].people; 
			      ch != NULL; ch = ch->next_in_room)
			   act("$p &1&blands with a loud&0 &1SPLASH!&0",FALSE,ch,i,0,TO_CHAR);
			 if (!IS_OBJ_STAT(i, ITEM_FLOAT)) {
			   
			   /* Sink it! */
			   
			   for (ch = world[EXIT(i, DOWN)->to_room].people; 
				ch != NULL; ch = ch->next_in_room)
			     act("$p &4&bsinks like a rock.&0",FALSE,ch,i,0,TO_CHAR);
			   obj_from_room(i);
			   screwed = TRUE;
			 } else {
			   
			   /* object floats so put it in the water */
			   
			   obj_from_room(i);
			   obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
			 }
		       } else {
			 
			 /* land on solid ground */
			 
			 obj_from_room(i);
			 obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
			 act("$p &1&blands with a dull&0 &1THUD!&0",FALSE,0,i,0,TO_ROOM);
		       }
		     } else {
		       
				/* keep falling */
		       
		       obj_from_room(i);
		       obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
		     }
		     
		   } else {
		     
		     /* No Down exit! */
		     
		     sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit", world[i->in_room].number);
		     log(gravbuf);
		     screwed = TRUE;
		   }
		 }
		 i = i->next_content;
	       }
	       
	       /*  end of object gravity check */
	       /*  start the gravity check for players/mobs  */
	       /*  check each ch */
	       
	     /* NOTE - Used aff_flying checks to bring back zones air zones
              * like doom, etc... and allow combat while flying. 
              * An alternative hack would be to check for multiple things such
	      * as is mob and aff_flying as well as pos checks, etc  */
	       for (ch = world[rrn].people; ch != NULL; ch = ch->next_in_room) {
		 k = 0;
		 flying = 0;
		 riding = 0;
		 ridden_by = 0;
		 /*if (GET_POS(ch) == POS_FLYING) flying = 1;*/
		 if (IS_AFFECTED(ch, AFF_FLYING) || GET_LEVEL(ch) >= LVL_IMMORT)  flying = 1;
		 
		 /* If either mount or mountee is flying then don't fall */
		 /* otherwise unmount and prepare to fall... */
		 
		 if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING)
		 {
		   riding = 1;
		   if ( IS_AFFECTED(RIDING(ch), AFF_FLYING))
		 /*if ((GET_POS(RIDING(ch)) == POS_FLYING))*/
		   { flying = 1; }
		 }
		 if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) 
		 {
		   ridden_by = 1;
		   
		   if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) 
		/* if (GET_POS(RIDDEN_BY(ch)) == POS_FLYING) */
		     { flying = 1; }
		 }
		 if (riding && !flying) dismount_char(ch);
		 if (ridden_by && !flying) dismount_char(RIDDEN_BY(ch));
		 
		 /* Make them fall */
		 
		 screwed = FALSE;
		 while (SECT(ch->in_room) == SECT_FLYING && 
		/*      (GET_POS(ch) != POS_FLYING) && */
		 /*     (GET_POS(ch) != POS_FIGHTING) && */
			!flying && 
			!screwed) {
		   
		   if(CAN_GO(ch, DOWN)) {
		     k++;
		     
		     was_in = ch->in_room;
		     
		     /*  Message to room fall started in */
		     
		     if (k == 1) {
d3280 4
a3283 4
		         act("&1&bYou find yourself in midair and begin descending.&0\r\n"
			       , FALSE, ch, 0, 0, TO_CHAR);
		         act("&1&b$n finds $mself in midair and begins descending.&0"
			       , FALSE, ch, 0, 0, TO_ROOM);
d3285 4
a3288 4
		         act("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n"
			       , FALSE, ch, 0, 0, TO_CHAR);
		         act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0"
			       , FALSE, ch, 0, 0, TO_ROOM);
d3292 9
a3300 9
		     }
		     
		     char_from_room(ch);
		     char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
		     
		     /*  Message to rooms falling through */
		     
		     /* David Endre 3/8/99 Send different message if they are a monk with safefall */
		     /* send_to_char("&2DOWN!&0\r\n", ch); */
d3303 1
a3303 1
		       act("&2$n floats slowly down from above.&0", FALSE, ch, 0, 0, TO_ROOM);
d3305 25
a3329 25
		       act("&2DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
		       act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
		     } else {
		       act("&2You fall gracefully DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
		       act("&2$n gracefully falls from above.&0", FALSE, ch, 0, 0, TO_ROOM);
		     }
		     if (ch->desc != NULL)
		       look_at_room(ch, 0);
		     
		     if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
		       do_falling_damage(ch, k);
		     }
		   } else {
		     
		     /* No Down exit! */
		     
		     sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit", world[ch->in_room].number);
		     log(gravbuf);
		     screwed = TRUE;
		   }
		 }
	       }
	     }
	   }
	 }
d3448 3
@


1.86
log
@Modify the casting command handler to allow for use of the pager
during casting (for informative commands).
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.85 2007/10/02 02:52:27 myc Exp myc $
d2469 26
a2494 9
	  void send_to_room(char *messg, int room)
	    {
	      struct char_data *i;
	      
	      if (messg)
		for (i = world[room].people; i; i = i->next_in_room)
		  if (i->desc)
		    SEND_TO_Q(messg, i->desc);
	    }
d3490 4
@


1.85
log
@Fixed idle timer to work for shapechanged druids.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.84 2007/09/15 15:36:48 myc Exp myc $
d1562 1
a1562 2
  if (!d || d->showstr_count || d->str || STATE(d) != CON_PLAYING || 
      !d->character || !CASTING(d->character))
d1565 12
d1590 1
a1590 1
  if (!cmd_info[cmd].cast)
d3473 3
@


1.84
log
@Removed defunct ITEM_ bitvector flags.  They are duplicating AFF_ flags.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.83 2007/09/04 06:49:19 myc Exp myc $
d833 4
a836 1
	      d->character->char_specials.timer = 0;
a1575 3
  sprintf(buf, "casting command: %s (%d)", cmd_info[cmd].command, cmd);
  log(buf);

a2737 5
  struct char_data *wch;
  struct char_data *player;
  struct char_data *ch;
  int playing = 0, deadweight = 0;
  int c_maxhit, c_hit, c_maxmove, c_move, m_maxhit, m_maxmove;
d2740 1
a2740 1
    if (d->connected && playing)
d2742 4
a2745 1
    if (!d->connected && deadweight)
a2746 52
    if (!d->connected) {
      if (d->original)
        if (IS_NPC(d->character) && GET_LEVEL(d->character) < 100) {
          wch = d->character;
        } else {   
          wch = d->original;
        }
      else if (!(wch = d->character))
        continue;
      
       /* This is for shapechange...if a players
          strays from neutrality then they will
          transform back to their natural state */
      ch = wch;

      if (ch->desc && ch->desc->original &&
          GET_LEVEL(ch->desc->original) < 100) {
        if ((GET_ALIGNMENT(ch) > 349 || GET_ALIGNMENT(ch) < -349) && GET_LEVEL(ch) < 100) {
          if (ch->desc->original->desc)
            close_socket(ch->desc->original->desc);
          player = ch->desc->original;
          send_to_char("You betray your true nature and lose control of the shapechange.\r\n", ch);
          act("You quickly morph back to your original self.",FALSE,ch,0,NULL,TO_CHAR);
          act("$n&0 contorts wildly as it reforms into $N.",FALSE,ch,0,player, TO_ROOM);
          c_maxhit = ch->points.max_hit;
          c_hit    = ch->points.hit;
          c_maxmove = ch->points.max_move;
          c_move    = ch->points.move;
          m_maxhit = GET_MAX_HIT(player);
          m_maxmove = GET_MAX_MOVE(player);
          GET_HIT(player) = (int)((1-((c_maxhit - c_hit)/(double)(c_maxhit)))*(double)(m_maxhit));
          GET_MOVE(player) = (int)((1-((c_maxmove - c_move)/(double)(c_maxmove)))*(double)(m_maxmove));
          GET_ALIGNMENT(player) = GET_ALIGNMENT(ch);
          ch->desc->character = ch->desc->original;
          ch->desc->original = NULL;
          ch->desc->character->desc = ch->desc;
          ch->desc = NULL;
          char_from_room(player);
          char_to_room(player, ch->in_room);
          extract_char(ch);
          if (GET_LEVEL(player) < 101)
            player->player_specials->saved.chant = 5;
          else
            player->player_specials->saved.chant = 0;
          return;
        }
      }

      if (wch->player_specials->saved.chant > 0)
  	wch->player_specials->saved.chant--;
      else
  	wch->player_specials->saved.chant = 0;
d2748 4
d3462 3
@


1.83
log
@IN_ZONE macro is now an rnum.  Changed weather function calls.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.82 2007/08/27 21:18:00 myc Exp myc $
d3218 1
a3218 1
	       while (SECT(i->in_room) == SECT_FLYING && !IS_OBJ_SPELL_AFF(i, ITEM_FLY) 
d3512 3
@


1.82
log
@You can now queue up commands while casting as well as abort midcast.
Casting commands such as look and abort are caught and interpreted
before the input is normally queued up by the game loop.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.81 2007/08/22 18:01:46 jps Exp myc $
d1010 2
a1011 1
	  update_weather_and_time(1);
d2412 1
a2412 1
void send_to_zone(char *messg, int zone_vnum, int skip_room, int min_position)
d2424 1
a2424 1
            (IN_ZONE(i->character) == zone_vnum))
d2439 1
a2439 1
	  void send_to_outdoor(char *messg, int zonenum)
d2449 3
a2451 1
		      OUTSIDE(i->character) && (IN_ZONE(i->character) == zonenum) && (STATE(i) == CON_PLAYING))
d3512 5
@


1.81
log
@Reduce the beeping for autoboot warnings. Add warnings at 30, 10,
and 5 seconds.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.80 2007/08/19 18:34:39 jps Exp jps $
d1541 45
d1588 1
a1588 1
  void write_to_q(char *txt, struct txt_q *queue, int aliased)
d2016 10
a2025 3
	      
	      if (!failed_subst)
		write_to_q(tmp, &t->input, 0);
d3509 4
@


1.80
log
@Don't send falling_yell to the room below.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.79 2007/08/17 02:23:36 jps Exp jps $
d68 1
a68 1
extern int manual_restrict;
d236 1
d592 22
d616 1
a616 1
   sprintf(buf, "\007\007&1&b*&3&bATTENTION&1&b*&0  The mud will &7&bREBOOT&0 in &6&b%d minute%s&0  &1&b*&3&bATTENTION&1&b*&0\r\n",
d632 1
a632 3
      if (manual_restrict) {
         log("Login restriction left in place because it was set manually.");
      } else {
d634 1
d643 1
a643 1
   int minutes_till;
a658 1
         reboot_prepped++;
a661 1
         reboot_prepped++;
d663 1
a666 2
         reboot_warning = 1;
         last_reboot_warning = minutes_till;
d668 7
a674 2

         if (minutes_till < 3 && restrict < LVL_IMMORT) {
d677 1
d680 10
d2241 1
d3457 3
@


1.79
log
@Don't let the mud sleep while it's in the automatic reboot warning phase.
Otherwise you would have to have someone logged in for it to reboot.
Generalized some autobooting code.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.78 2007/08/14 20:13:57 jps Exp jps $
d3057 1
a3057 1
               dirstr = "above"; /* sure, whatever */
d3421 5
@


1.78
log
@The mud will automatically reboot after a randomized period of time,
though powerful deities can delay or prevent this.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.77 2007/08/14 10:44:05 jps Exp jps $
d68 1
d598 21
d643 2
a644 2
   } else if ((reboot_pulse - global_pulse) / (PASSES_PER_SEC * 60) <= reboot_warning_minutes) {
      minutes_till = (reboot_pulse - global_pulse) / (PASSES_PER_SEC * 60) + 1;
d687 2
a688 2
	/* Sleep if we don't have any connections */
	if (descriptor_list == NULL) {
d3421 4
@


1.77
log
@Add functions to keep track of how much players have been communicating
and to squelch them with "laryngitis" if they spam too much.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.76 2007/08/03 22:00:11 myc Exp jps $
d97 6
d288 3
d323 6
d563 73
a635 1
  
d946 1
a946 1
      if (!(pulse % PASSES_PER_SEC))
d948 2
d3399 4
@


1.76
log
@act() now supports observatories: a room marked observatory that is
adjacent to an arena room will see all to_notvict and to_room act
calls to the arena room.
Also changed perform_act so it returns immediately if the 'to' target
doesn't have a descriptor.  This should save some CPU cycles.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.75 2007/07/25 00:38:03 jps Exp myc $
d110 1
a110 1
unsigned long dg_global_pulse = 0; /* number of pulses since game start */
d821 1
a821 1
      dg_global_pulse++;
d2273 146
d3310 7
@


1.75
log
@Give send_to_zone a room to skip, and make it use virtual zone number.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.74 2007/07/24 23:34:00 jps Exp jps $
d2282 3
d2382 1
a2382 2
   if (to->desc)
      SEND_TO_Q(CAP(lbuf), to->desc);
d2467 1
d2501 1
a2501 1
   if ((ch)) {
d2503 1
a2503 1
         to = world[ch->in_room].people;
d2512 1
a2512 1
            to = world[obj->in_room].people;
d2528 2
a2529 2
    
   for (; to; to = to->next_in_room)
d2533 22
d3164 3
@


1.74
log
@Add a parameter min_position to send_to_zone()
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.73 2007/05/28 06:59:42 jps Exp jps $
d2212 1
a2212 1
void send_to_zone(char *messg, int zone_rnum, int min_position)
d2223 2
a2224 1
            (world[IN_ROOM(i->character)].zone == zone_rnum))
a2238 2
#define GET_ZONE(ch)  (zone_table[world[IN_ROOM(ch)].zone].number)
	  
d2249 1
a2249 1
		      OUTSIDE(i->character) && (GET_ZONE(i->character) == zonenum) && (STATE(i) == CON_PLAYING))
d3139 3
@


1.73
log
@Removed extra space from end of prompt. Added %- code so that
people whose clients give them trouble with trailing spaces
can still add one.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.72 2007/05/24 07:28:34 jps Exp jps $
d2212 14
a2225 13
	  void send_to_zone(char *messg, int zone_rnum)
	    {
	      struct descriptor_data *i;
	      
	      if (!messg || !*messg)
		return;
	      
	      for (i = descriptor_list; i; i = i->next)
		if (!i->connected && i->character && AWAKE(i->character) &&
		    (IN_ROOM(i->character) != NOWHERE) &&
		    (world[IN_ROOM(i->character)].zone == zone_rnum))
		  SEND_TO_Q(messg, i);
	    }
d3140 5
@


1.72
log
@Transmit a surprised yell to surrounding rooms when someone starts to fall.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.71 2007/04/18 01:02:17 myc Exp jps $
d1113 1
a1113 1
    sprintf(prompt, "%s&0 ", raw); 
d1172 1
a1172 1
/* NO LONGER USING m/M for mana!  So we're going to use it for money below.
d1268 3
d1362 1
a1362 1
  sprintf(cur, "&0 ");
d3139 3
@


1.71
log
@Added some new codes to the prompt parser and added some NPC checks so
mobs can't use player specific ones.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.70 2007/04/18 00:05:59 myc Exp myc $
d79 2
d2729 62
d2977 2
d3136 4
@


1.70
log
@Prompt parser has been totally rewritten so it won't print garbage
characters anymore.  Also, some new features were added.  Giving the
prompt command back to mortals.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.69 2006/11/20 19:52:04 jps Exp myc $
d1098 1
a1098 1
  int expecting, color, perc, pre_length = 0;
d1100 1
d1122 12
a1133 10
  if (GET_INVIS_LEV(ch) > 0)
    pre_length += sprintf(cur + pre_length, "<wizi %03d> ",
            GET_INVIS_LEV(ch));
  if (PRF_FLAGGED(ch, PRF_AFK))
    pre_length += sprintf(cur + pre_length, "<AFK> ");
  /* If any flags above, insert newline. */
  if(pre_length) {
    pre_length += sprintf(cur + pre_length, "\r\n");
    /* Advance cursor. */
    cur += pre_length;
d1140 8
a1147 2
   * 2    Last two chars were %h; next one is a control code.
   * 3    Last two chars were %c; next one is a control code.
d1194 1
a1194 1
        case 'm':
d1200 1
a1200 1
        case 'M':
d1210 1
a1210 1
            perc = (100 * GET_HIT(vict)) / MAX(1, GET_MAX_HIT(vict));
d1212 7
a1218 7
                    perc >= 100 ? "&2Excellent" :
                    perc >= 88 ? "&3scratches" :
                    perc >= 75 ? "&3&bsmall wounds" :
                    perc >= 50 ? "&5&bfew wounds" :
                    perc >= 30 ? "&5nasty wounds" :
                    perc >= 15 ? "&1&bpretty hurt" :
                    perc >= 0 ? "&1awful condition" :
d1226 1
a1226 1
            perc = (100 * GET_HIT(tank)) / MAX(1, GET_MAX_HIT(tank));
d1228 7
a1234 7
                    perc >= 100 ? "&2Excellent" :
                    perc >= 88 ? "&3scratches" :
                    perc >= 75 ? "&3&bsmall wounds" :
                    perc >= 50 ? "&5&bfew wounds" :
                    perc >= 30 ? "&5nasty wounds" :
                    perc >= 15 ? "&1&bpretty hurt" :
                    perc >= 0 ? "&1awful condition" :
d1238 12
d1252 1
d1275 1
a1275 1
          perc = (100 * GET_HIT(ch)) / MAX(1, GET_MAX_HIT(ch));
d1280 1
a1280 1
          perc = (100 * GET_MANA(ch)) / MAX(1, GET_MAX_MANA(ch));
d1285 1
a1285 1
          perc = (100 * GET_MOVE(ch)) / MAX(1, GET_MAX_MOVE(ch));
d1294 1
a1294 1
        cur += sprintf(cur, "%d%%", perc);
d1326 27
@


1.69
log
@Levitate prevents falling damage
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.68 2006/11/14 22:47:10 jps Exp jps $
d1094 63
a1156 25
  char *prompt_str(struct char_data *ch) {
    struct char_data *vict = FIGHTING(ch);  
    static char pbuf[MAX_STRING_LENGTH];  
    char *str = GET_PROMPT(ch);
    struct char_data *tank;
    int perc, color;  
    char *cp, *tmp;
    char i[256];
    
    if (!str || !*str)
      str = "&0FieryMUD&0: Set your prompt (see 'help prompt')>";
    
    color = (PRF_FLAGGED(ch, PRF_COLOR_1 | PRF_COLOR_2) ? 1 : 0);
    
    if (!strchr(str, '%'))
      return str;
    
    cp = pbuf;
    
    for (;;) {
      if (*str == '%') {
        switch (*(++str)) {
        case 'h': 
          sprintf(i, "%d", GET_HIT(ch));
          tmp = i;
d1158 2
a1159 3
        case 'H': 
          sprintf(i, "%d", GET_MAX_HIT(ch));
          tmp = i;
d1161 3
a1163 3
        case 'm': 
          sprintf(i, "%d", GET_MANA(ch));
          tmp = i;
d1165 2
a1166 3
        case 'M': 
          sprintf(i, "%d", GET_MAX_MANA(ch));
          tmp = i;
d1168 3
a1170 3
        case 'v': 
          sprintf(i, "%d", GET_MOVE(ch));
          tmp = i;
d1173 1
a1173 2
          sprintf(i, "%d", GET_MAX_MOVE(ch));
          tmp = i;
d1175 1
d1177 19
a1195 18
        case 'p': 
          str++;
          switch (LOWER(*str)) {
          case 'h':
            perc = (100 * GET_HIT(ch)) / MAX(1, GET_MAX_HIT(ch));
            break;
          case 'm':
            perc = (100 * GET_MANA(ch)) / MAX(1, GET_MAX_MANA(ch));
            break;
          case 'v':
            perc = (100 * GET_MOVE(ch)) / MAX(1, GET_MAX_MOVE(ch));
            break;
          default :
            perc = 0;
            break;
          }
          sprintf(i, "%d%%", perc);
          tmp = i;
d1197 1
d1199 1
a1199 1
	case 'o': /* opponent*/
d1201 10
a1210 13
            perc = (100*GET_HIT(vict)) / MAX(1, GET_MAX_HIT(vict));
            sprintf(i, "%s &0(%s&0)&0", PERS(vict, ch),
		    (perc >= 100 ? "&2Excellent" :
		     perc >= 88 ? "&3scratches" :
                     perc >= 75 ? "&3&bsmall wounds" :
                     perc >= 50 ? "&5&bfew wounds" :
		     perc >= 30 ? "&5nasty wounds" :
		     perc >= 15 ? "&1&bpretty hurt" :
		     perc >= 0 ? "&1awful condition" : "&1bleeding awfully"));
            tmp = i;
          } else {
            str++;
            continue;
d1213 1
a1213 8
        case 'g': 
          sprintf(i, "%d", GET_GOLD(ch));
          tmp = i;
          break;
        case 'G': 
          sprintf(i, "%ld", GET_BANK_GOLD(ch));
          tmp = i;
          break;
d1215 1
a1215 1
	case 't': /* tank*/
d1217 22
a1238 18
            /* silly div by zero fix --Fingon */
            if (GET_HIT(tank) > 0)
              perc = (100*GET_HIT(tank)) / GET_MAX_HIT(tank);
            else
              perc = 0;
            sprintf(i, "%s &0(&0%s&0)&0", PERS(tank, ch),
		    (perc >= 99 ? "&2Excellent" :
		     perc >= 88 ? "&3scratches" :
                     perc >= 75 ? "&3&bsmall wounds" :
                     perc >= 50 ? "&5&bfew wounds" :
		     perc >= 30 ? "&5nasty wounds" :
		     perc >= 15 ? "&1&bpretty hurt" :
		     perc >= 0 ? "&1awful condition" : "&0&1&bbleeding awfully&0"));
	    
	    tmp = i;
          } else {
            str++;
            continue;
a1240 2
	  
          
d1242 1
a1242 1
          tmp = "\r\n";
d1245 53
a1297 3
          *(cp++) = '%';
          str++;
          continue;
d1299 2
a1300 4
	  
        default :
          str++;
          continue;
d1302 1
a1302 7
        }
        
        while ((*cp = *(tmp++)))
          cp++;
        str++;
      } else if (!(*(cp++) = *(str++)))
        break;
d1304 2
a1305 5
    
    *cp = '\0';
    
    strcat(pbuf, " &0");
    return pbuf;
d1307 7
a1317 3
      char pbuf[25];
      bool linesent=FALSE;

d1332 1
a1332 17
	/* Spanky new Afk and wizinvis code by cmc 10/6/99 */
	if (GET_INVIS_LEV(d->character) > 0) {
	  sprintf(pbuf,"%s<wizi %03d>",
		  linesent?" ":"",
		  GET_INVIS_LEV(d->character));
	  write_to_descriptor(d->descriptor, pbuf);
	  linesent=TRUE;
	}

	if (PRF_FLAGGED(d->character, PRF_AFK)) {
	  sprintf(pbuf,"%s<AFK>", linesent?" ":"");
	  write_to_descriptor(d->descriptor, pbuf);
	  linesent=TRUE;
	}

	if (linesent)
	  write_to_descriptor(d->descriptor, "\r\n");
a1333 1
	write_to_descriptor(d->descriptor, ptemp);
a1337 23
	/*  
	    char prompt[MAX_INPUT_LENGTH];
	    
	    *prompt = '\0';
	    
	    if (GET_INVIS_LEV(d->character))
	    sprintf(prompt, "i%d ", GET_INVIS_LEV(d->character));
	    
	    if (PRF_FLAGGED(d->character, PRF_DISPHP))
	    sprintf(prompt, "%s%dH ", prompt, GET_HIT(d->character));
	    
	    if (GET_MAX_MANA(tch) != 0)
	    if GET_MAX_MANA(tch) > 0)
	    if (GET_MANA(tch) > 0)
	    if (PRF_FLAGGED(d->character, PRF_DISPMANA))
	    sprintf(prompt, "%s%dM ", prompt, GET_MANA(d->character));
	    
	    if (PRF_FLAGGED(d->character, PRF_DISPMOVE))
	    sprintf(prompt, "%s%dV ", prompt, GET_MOVE(d->character));
	    
	    strcat(prompt, "> ");
	    write_to_descriptor(d->descriptor, prompt);
	*/
d3021 3
@


1.68
log
@Make sure imms don't fall in flight rooms.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.67 2006/11/14 21:30:44 jps Exp jps $
d2821 11
a2831 5
		       act("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n"
			   , FALSE, ch, 0, 0, TO_CHAR);
	 /* send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch); */
		       act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0"
			   , FALSE, ch, 0, 0, TO_ROOM);
d2841 4
a2844 1
		     if (GET_SKILL(ch, SKILL_SAFEFALL) == 0) {
d2876 40
a2915 29
 void do_falling_damage(struct char_data *ch, float dist_fell)
   {
     
     /* Are we landing in water? It hurts MUCH less... */
     /* If we have safe fall skill, then we take no damage
	for five rooms, partially for 5-15 and full at 15 David Endre 3/8/99 */
     
     if((SECT(ch->in_room) == SECT_WATER_SWIM || 
	 SECT(ch->in_room) == SECT_WATER_NOSWIM || 
	 SECT(ch->in_room) == SECT_OCEAN)) { 
       act("\r\nYou land with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_CHAR);
       act("$n lands with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_ROOM);
       GET_POS(ch) = POS_SITTING;
       GET_POS1(ch) = POS1_SITTING;
       if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
	 if (dist_fell <= 5)
	   GET_HIT(ch) -= 0;
	 else if (dist_fell < 15)
	   GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch)) * (dist_fell/15));
	 else
	   GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
       } else
	 GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
       update_pos(ch);
     } else {
       GET_POS(ch) = POS_SITTING;
       GET_POS1(ch) = POS1_SITTING;
       if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell <=5) {
	 GET_POS(ch) = POS_STANDING;
d2917 42
a2958 45
	 act("\r\nYou tuck and roll, performing a beautiful landing!", FALSE, ch ,0, 0, TO_CHAR);
	 act("$n tucks and rolls, performing a beautiful landing!", FALSE, ch, 0, 0, TO_ROOM);
       } else if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell < 15) {
	 act("\r\nYou gracefully land without taking too much damage.", FALSE, ch, 0, 0, TO_CHAR);
	 act("$n gracefully lands without taking too much damage.", FALSE, ch, 0, 0, TO_ROOM);
       } else {
	 act("\r\nYou land with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_CHAR);
	 act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
       }
       if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
	 if (dist_fell <= 5)
	   GET_HIT(ch) -= 0;
	 else if (dist_fell < 15)
	   GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch)) * (dist_fell/15));
	 else
	   GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
       } else
	 GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
       update_pos(ch);
     }
     switch (GET_POS(ch)) {
     case POS_MORTALLYW:
       act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
       send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
       break;
     case POS_INCAP:
       act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
       send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
       break;
     case POS_STUNNED:
       act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
       send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
       break;
     case POS_DEAD:
       act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
       send_to_char("You are dead!  Sorry...\r\n", ch);
       sprintf(buf2, "%s killed by falling at %s", GET_NAME(ch), world[ch->in_room].name);
       mudlog(buf2, BRF, 0, TRUE);
       die(ch, NULL);
       break;
     default:
       break;
     }
     alter_hit(ch, 0, 1);
     update_pos(ch);
d2960 3
d2965 6
a2970 19








 void update_skill_usage(struct char_data* ch) 
   {
     int skill; 
     for (skill = 401; skill < 401 + MAX_SKILL_TIMERS; 
	  skill++) {
       
       if (SKILL_DELAY(ch, skill)) 
	 SKILL_DELAY(ch, skill)--; 
     };


d2972 1
a2973 10
 void update_skill_usages()
   {
     struct descriptor_data* d; 

     for (d = descriptor_list; d; d = d->next) {
       if (d->character && d->character->player_specials) {
	 update_skill_usage(d->character); 
       };
     };
     
d2975 3
d2979 4
d2984 1
d2988 3
@


1.67
log
@Stop invis'd gods from being seen by lower level imms as they
disconnect from the main menu.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.66 2006/11/13 15:54:22 jps Exp jps $
d2781 1
a2781 1
		 if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;
d2982 4
@


1.66
log
@Fix implementation of hide_informative parameter to act(), when
the target is TO_VICT.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.65 2006/11/13 02:51:02 jps Exp jps $
d1883 6
a1888 3
		  sprintf(buf, "Losing player: %s.",
			  GET_NAME(d->character) ? GET_NAME(d->character) : "<null>");
		  mudlog(buf, CMP, LVL_IMMORT, TRUE);
d2982 4
@


1.65
log
@Fix illegal pointer access.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.64 2006/11/10 21:00:26 jps Exp jps $
d2372 3
a2374 7
  {
    struct char_data *to = NULL;
    static int sleep;
    
    if (!str) {
      return;
    } 
d2376 1
d2378 1
a2378 1
    if (!(dg_act_check = !(type & DG_NO_TRIG))) {
d2380 9
a2388 9
    }
    /*
     * Warning: the following TO_SLEEP code is a hack.
     * 
     * I wanted to be able to tell act to deliver a message regardless of sleep
     * without adding an additional argument.  TO_SLEEP is 128 (a single bit
     * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
     * command.  It's not legal to combine TO_x's with each other otherwise.
     */
d2390 1
a2390 2
    /* check if TO_SLEEP is there, and remove it if it is. */
    if ((sleep = (type & TO_SLEEP))) {
a2391 1
    }
d2393 1
a2393 1
    if (type == TO_CHAR) {
d2395 1
a2395 1
	perform_act(str, ch, obj, vict_obj, ch);
d2397 6
a2402 12
    }
    if (type == TO_VICT) {
      if ((to = (struct char_data *) vict_obj) && SENDOK(to)) {
	if (to == NULL)  /*  Uncommented on 3/21/99 by David Endre */
	  return;       /*  Why the hell would Hubis comment */
	if (!to)         /*  these four line out? */
	  return;       /*  Beats the hell outta me. */
	/* if a tree falls in the forest... Banyal cut on some bandwidth */ 
	 /*   / * and lets kill soem bugs while we here Banyal* / */
	 /*  if (to->desc && (IS_NPC(to) || !to->player_specials->ignored || */
	 /*  (to->player_specials->ignored != ch)) && ((to != ch)))  */
	perform_act(str, ch, obj, vict_obj, to);
d2405 2
a2406 2
    }
    /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */
d2408 1
a2408 1
    if ((ch)) {
d2410 1
a2410 1
	to = world[ch->in_room].people;
d2412 3
a2414 3
	sprintf(buf, "SYSERR:comm.c:act(): ch->in_room = -1, %s", GET_NAME(ch));
	log(buf);
	return;
d2416 1
a2416 1
    } else if ((obj != NULL)) {
d2418 7
a2424 7
	if ((obj->in_room) != 0) {
	  to = world[obj->in_room].people;
	} else {
	  sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
	  log(buf);
	  return;
	}
d2426 3
a2428 3
	sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
	log(buf);
	return;
d2430 1
a2430 1
    } else {
d2434 1
a2434 1
    }
d2436 1
a2436 1
    for (; to; to = to->next_in_room)
d2438 3
a2440 3
	  (to != ch) && (type == TO_ROOM || (to != vict_obj)))
	perform_act(str, ch, obj, vict_obj, to);
  }
d2979 3
@


1.64
log
@Update act() to accept $U, $u and some other format codes.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.63 2006/04/01 21:46:23 rls Exp jps $
d1886 1
a1887 1
                  d->character->desc = NULL;
d2990 3
@


1.63
log
@Modified gravity to allow arial combat.  Simplistic hack really...
using aff_flying as the check rather than pos_flying (logically)
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.62 2004/11/11 23:02:23 rsd Exp $
d2183 95
a2277 60
	  
	  /* higher-level communication: the act() function */
	  void perform_act(char *orig, struct char_data *ch, struct obj_data *obj,
			   void *vict_obj, struct char_data *to)
	    {
  register char *i = NULL, *buf;
  static char lbuf[MAX_STRING_LENGTH];

  buf = lbuf;

  for (;;) {
    if (*orig == '$') {
      switch (*(++orig)) {
      case 'n':
        i = PERS(ch, to);
        break;
      case 'N':
        CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
        break;
      case 'm':
        i = HMHR(ch);
        break;
      case 'M':
        CHECK_NULL(vict_obj, HMHR((struct char_data *) vict_obj));
        break;
      case 's':
        i = HSHR(ch);
        break;
      case 'S':
        CHECK_NULL(vict_obj, HSHR((struct char_data *) vict_obj));
        break;
      case 'e':
        i = HSSH(ch);
        break;
      case 'E':
        CHECK_NULL(vict_obj, HSSH((struct char_data *) vict_obj));
        break;
      case 'o':
        CHECK_NULL(obj, OBJN(obj, to));
        break;
      case 'O':
        CHECK_NULL(vict_obj, OBJN((struct obj_data *) vict_obj, to));
        break;
      case 'p':
        CHECK_NULL(obj, OBJS(obj, to));
        break;
      case 'P':
        CHECK_NULL(vict_obj, OBJS((struct obj_data *) vict_obj, to));
        break;
      case 'a':
        CHECK_NULL(obj, SANA(obj));
        break;
      case 'A':
        CHECK_NULL(vict_obj, SANA((struct obj_data *) vict_obj));
        break;
      case 'T':
        CHECK_NULL(vict_obj, (char *) vict_obj);
        break;
      case 't':
        CHECK_NULL(obj, (char *) obj);
d2279 3
a2281 12
      case 'F':
        CHECK_NULL(vict_obj, fname((char *) vict_obj));
        break;
      case '$':
        i = "$";
        break;
      default:
        log("SYSERR: Illegal $-code to act():");
        strcpy(buf1, "SYSERR: ");
        strcat(buf1, orig);
        log(buf1);
        break;
d2283 5
a2287 6
      while ((*buf = *(i++)))
        buf++;
      orig++;
    } else if (!(*(buf++) = *(orig++)))
      break;
  }
d2289 2
a2290 5
  *(--buf) = '\r';
  *(++buf) = '\n';
  *(++buf) = '\0';
  if (to->desc)
     SEND_TO_Q(CAP(lbuf), to->desc);
d2990 4
@


1.62
log
@Added additional char stars for the Banning message to
the descriptor output because the original message was
to large for the compiler to not complain about
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.61 2003/04/16 02:00:22 jjl Exp $
d2649 4
a2652 3
     for (zn = 0; zn <= top_of_zone_table; zn++) {
       if (zone_table[zn].top) {
	 
d2654 4
a2657 3
	 
	 for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) {
	   if (real_room(rn) != NOWHERE) {	
d2659 2
a2660 1
	     if (world[rrn].sector_type == SECT_FLYING) {
d2662 1
a2662 1
	       /*  start the gravity check for objects */
d2664 7
a2670 7
	       i = world[rrn].contents;
	       while(i) {
		 
		 /*  check each object */
		 
		 if ((j=i->next_content)) {
		   if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
d2672 4
a2675 4
		       ((j->item_number==i->item_number) && (i->item_number!=NOTHING))) {
		     i = j;
		     continue;
		   }
d2677 1
d2679 1
a2679 1
		 /*  make it fall */
d2681 6
a2686 6
		 screwed = FALSE;
		 while (SECT(i->in_room) == SECT_FLYING && 
			!IS_OBJ_SPELL_AFF(i, ITEM_FLY) &&
			i->obj_flags.type_flag != ITEM_PORTAL &&
			!screwed) {
		   if(CAN_GO(i, DOWN)) {
d2757 4
d2766 2
a2767 2
		 if (GET_POS(ch) == POS_FLYING) flying = 1;
		 /*if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;*/
d2772 2
a2773 1
		 if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING) {
d2775 3
a2777 4
		   if (GET_POS(RIDING(ch)) == POS_FLYING) {
		     /*if (IS_AFFECTED(RIDING(ch), AFF_FLYING)) {*/
		     flying = 1;
		   }
d2779 2
a2780 1
		 if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) {
d2783 3
a2785 4
		   /*if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) {*/
		   if (GET_POS(RIDDEN_BY(ch)) == POS_FLYING) {
		     flying = 1;
		   }
d2794 2
a2795 1
			(GET_POS(ch) != POS_FLYING) && 
d2968 5
@


1.61
log
@Added skill timers for Zzur.  They don't save to file, so they were a
quickie.
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.60 2002/09/13 02:32:10 jjl Exp $
d1442 2
d1488 2
d2959 4
@


1.60
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: comm.c,v 1.59 2002/08/29 17:29:03 rsd Exp $
d91 1
d831 3
d2917 36
d2955 3
@


1.59
log
@added a check for CON_ISPELL_BOOT for a password checking
state to be kicked offline if idle to long.
@
text
@d1 3
a3 1
// $Id: comm.c,v 1.58 2002/04/17 22:41:06 dce Exp $
d310 1
a310 1
#endif // NO_MAPS
d2375 4
a2378 4
	if (to == NULL) // Uncommented on 3/21/99 by David Endre
	  return;      // Why the hell would Hubis comment
	if (!to)        // these four line out?
	  return;      // Beats the hell outta me.
d2380 3
a2382 3
	//  /* and lets kill soem bugs while we here Banyal*/
	// if (to->desc && (IS_NPC(to) || !to->player_specials->ignored ||
	// (to->player_specials->ignored != ch)) && ((to != ch))) 
d2913 250
a3162 244
// $Log: comm.c,v $
// Revision 1.58  2002/04/17 22:41:06  dce
// Added attacker = null; to prevent shapechanged players
// from crashing the mud.
//
// Revision 1.57  2001/12/09 14:08:32  dce
// Had to add the d->character check for the shapechange thing
// in close_socket.
//
// Revision 1.56  2001/12/07 02:09:56  dce
// Linkdead players will now lose exp when they die.
// Linkdead shapechanged players will now shapechange
// to their original form before linking out.
//
// Revision 1.55  2001/05/17 02:55:38  dce
// Fixed crash bug with menu timeout.
//
// Revision 1.54  2001/05/17 02:45:49  dce
// Fixed a crash bug around saving a character at check_idle_passwords
//
// Revision 1.53  2001/05/13 16:15:58  dce
// Fixed a bug where somethings wouldn't save when a player
// died and exitied menu option 0 rather than menu option 1.
//
// Revision 1.52  2001/05/03 01:26:16  dce
// Players now timeout at the menu screen.
//
// Revision 1.51  2001/03/14 19:04:59  rsd
// made the default for ooc ON again.
//
// Revision 1.50  2001/03/09 03:05:21  dce
// Fixed it so that immortals do not get booted out of shapechanged
// form no matter what their alignment is.
//
// Revision 1.49  2001/03/06 03:10:18  dce
// Fixed a bug where players awaiting a name approval could
// cut their link and then crash the mud.
//
// Revision 1.48  2001/03/04 17:33:19  dce
// Fixed the falling problem where players would not
// gain hp after falling. Also fixed the problem where
// players could cast while sitting after falling.
//
// Revision 1.47  2001/03/03 18:08:20  dce
// Minor fix for shapechange
//
// Revision 1.46  2001/02/24 16:47:31  dce
// Changes made for shapechange. Shapechange uses the chant
// variable to limit its use.
//
// Revision 1.45  2001/01/23 01:51:46  rsd
// turned off occ by detault
//
// Revision 1.44  2000/11/28 01:36:34  mtp
// remveove last vestiges of mobprgos (damn these things get around)
//
// Revision 1.43  2000/11/28 01:19:01  mtp
// remove process_events() (replaced dg_event code with events.c code)
// removed mobprog references
//
// Revision 1.42  2000/11/20 19:43:45  rsd
// added back rlog messages from prior to the $log$ string.
//
// Revision 1.41  2000/11/15 22:55:01  rsd
// changed a perror() to a log()
//
// Revision 1.40  2000/04/14 00:47:00  rsd
// Added some spanky code to send banned players a message about
// being banned, also added something to the log message to make
// it bloody obvious someone banned tried to connect...
//
// Revision 1.39  2000/04/02 02:38:23  rsd
// Added the comment header while I was browsing for information.
// I also fixed bracket problems in the social section and re-tabbed
// that part of the function.
//
// Revision 1.38  2000/03/20 04:28:47  rsd
// added comments regarding my_signal(SIGUSR1, reread_wizlists)
//
// Revision 1.37  2000/02/14 05:13:23  jimmy
// Fixed hupsig signal to not exit the instant it received a SIGHUP.
// The mud now shuts down cleanly.
//
// Revision 1.36  1999/11/28 22:55:42  cso
// *** empty log message ***
//
// Revision 1.35  1999/10/06 17:53:01  rsd
// Added afk to the beginning of the prompt and cmc added
// wizinvis and afk into the prompt properly.
//
// Revision 1.34  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.33  1999/08/12 18:21:47  dce
// Potential lock out bug.
// Mud times out connections waiting at ANSI prompt.
//
// Revision 1.32  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.31  1999/07/26 03:49:00  jimmy
// added debug to help with pfile problems
//
// Revision 1.30  1999/07/09 22:30:27  jimmy
// Attempt to control the spiraling of memory.  Added a free() to the
// prompt code in comm.c to free memory allocated by parse_color().
// made a global structure dummy_mob and malloc'ed it for mobs
// to share as their player_specials to cut memory.
// gurlaek
//
// Revision 1.29  1999/07/09 13:57:00  mud
// Changed missed reference to HUBIS to Fiery
//
// Revision 1.28  1999/07/09 02:59:46  jimmy
// doh, forgot to recompile after commenting. Stupid parse error.
//
// Revision 1.27  1999/07/09 02:38:50  jimmy
// rewrote parse_color() to fix silly overflows due to an estimation of the
// length of the converted ansi string.  The function now does not malloc
// until the string has been converted and is in it's final form.
// --gurlaek 7/8/1999
//
// Revision 1.26  1999/07/02 21:58:04  jimmy
// Highely modified worship.c/h to change from many small functions that
// were passes as (void *) to 4 large functions that use switch().  This
// was done to remove the warnings produced by the -pedantic compiler flag.
// divine_intervention was also commented out for now in comm.c because we
// don't currently use it anyway. --Gurlaek 7/2/1999
//
// Revision 1.25  1999/06/11 16:56:55  jimmy
// date: 1999/06/11 16:56:55;  author: jimmy;  state: Exp;  lines: +1 -1
// Ok, fixed do_quit to check for fighting and also not crash when mortally
// wounded.  This was done in die() by checking for killer=NULL.
// since no one killed you if you quit while morted the die code
// didn't know how to deal with a NULL killer.
// --Gurlaek 6/11/1999
//
// Revision 1.24  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to 
// clarify their behavior to the compiler.  The name approval code was also 
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the 
// xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
// --Gurlaek 6/10/1999
//
// Revision 1.23  1999/04/23 23:27:10  jimmy
// Fixed warnings/errors associated with the addition of the pendantic compiler flag
// yeeeeehaaawwww.  --gurlaek
//
// Revision 1.22  1999/04/23 21:35:11  jimmy
// fixed typecast of int i to work with the accept() function
// in  new_descriptor().
// -- Gurlaek
//
// Revision 1.21  1999/04/16 20:50:34  dce
// Attempt to fix parse_color bug
//
// Revision 1.20  1999/04/10 06:04:52  dce
// Testing
//
// Revision 1.19  1999/04/10 05:53:40  jen
// sigh
//
// Revision 1.18  1999/04/10 05:13:48  jen
// Revisions w/ debug info
//
// Revision 1.17  1999/04/10 05:05:58  jen
// Revision for testing #1
//
// Revision 1.16  1999/04/09 23:19:49  jen
// An attempt to fix a core dump when perform_act handles
// i = "someone"; I think more drastic measures may be needed
// but this is a first shot.
//
// Revision 1.15  1999/04/05 19:37:55  jen
// Redone cap code... using toupper fn instead of CAP macro
//
// Revision 1.14  1999/04/05 19:01:05  jen
// Commented out the car needscap :p
//
// Revision 1.13  1999/04/05 18:55:46  jen
// Backed out the capitalization code until
// I can figure out why it's crashing sometimes.
//
// Revision 1.12  1999/04/02 17:07:06  jen
// Fixes the problem with mobs telling you stuff (or conceivably any
// instance where an 'act' string is parsed with a $n for a mob at
// the beginning - i.e. '$n tells you') ... it capitalizes the first
// char of the mob name in that instance only.
// 
// Selina
//
// Revision 1.11  1999/03/26 19:47:10  jen
// Added a mortal gossip channel with 103+ godly control
//
// Revision 1.10  1999/03/21 21:18:12  dce
// Fixed a Hubis crash bug.
//
// Revision 1.9  1999/03/12 19:44:42  jimmy
// Updated debug messages in comm.c and handler.c to include
// more useful info, as well as adding an abort where exit
// used to be in order to get a core.
// fingon
//
// Revision 1.8  1999/03/08 20:22:35  dce
// Adds the skill safefall for monks.
//
// Revision 1.7  1999/03/06 23:51:54  dce
// Add's chant songs, and can only chant once every four hours
//
// Revision 1.6  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
//
// Revision 1.5  1999/02/24 22:59:35  jimmy
// Fixed gravity code to handle IN_FLIGHT rooms with no down exits.
// Also added fix for air rooms over water as well as semantics
// for splashing and sinking.
// fingon
//
// Revision 1.4  1999/02/07 06:46:21  jimmy
// fixed silly div by zero in the prompt code
// fingon
//
// Revision 1.3  1999/01/30 19:42:27  mud
// Indented entire file
//
// Revision 1.2  1999/01/29 05:42:00  jimmy
// ixed AFF_FLYING to GET_POS(ch) == POS_FLYING for gravity
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.58
log
@Added attacker = null; to prevent shapechanged players
from crashing the mud.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.57 2001/12/09 14:08:32 dce Exp $
a161 1
#ifndef CIRCLE_WINDOWS
d164 1
a164 1
#endif 
d1907 2
a1908 1
                    && STATE(d) != CON_QANSI && STATE(d) != CON_MENU)
d1910 1
d2912 4
@


1.57
log
@Had to add the d->character check for the shapechange thing
in close_socket.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.56 2001/12/07 02:09:56 dce Exp $
d1831 1
d2911 4
@


1.56
log
@Linkdead players will now lose exp when they die.
Linkdead shapechanged players will now shapechange
to their original form before linking out.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.55 2001/05/17 02:55:38 dce Exp $
d1830 9
a1838 4
              if(d->character->desc && d->character->desc->original) {
                if (IS_FIGHTING(d->character)) {
                  attacker = d->character->char_specials.fighting;
                  stop_fighting(d->character);
a1839 3
                do_shapechange(d->character, "me", 0, 1); 
                if (attacker)
                  hit(attacker, d->character, TYPE_UNDEFINED);
d2910 5
@


1.55
log
@Fixed crash bug with menu timeout.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.54 2001/05/17 02:45:49 dce Exp $
d90 1
d1813 1
d1827 12
d2908 3
@


1.54
log
@Fixed a crash bug around saving a character at check_idle_passwords
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.53 2001/05/13 16:15:58 dce Exp $
d1897 1
a1897 1
                  if (d->character)
d2894 3
@


1.53
log
@Fixed a bug where somethings wouldn't save when a player
died and exitied menu option 0 rather than menu option 1.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.52 2001/05/03 01:26:16 dce Exp $
d1897 2
a1898 1
                  save_char(d->character, NOWHERE);
d2894 4
@


1.52
log
@Players now timeout at the menu screen.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.51 2001/03/14 19:04:59 rsd Exp $
d1897 1
d2893 3
@


1.51
log
@made the default for ooc ON again.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.50 2001/03/09 03:05:21 dce Exp $
d1890 2
a1891 1
		if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME && STATE(d) != CON_QANSI)
d2892 3
@


1.50
log
@Fixed it so that immortals do not get booted out of shapechanged
form no matter what their alignment is.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.49 2001/03/06 03:10:18 dce Exp $
d110 1
a110 1
int gossip_channel_active = 0;	/* Flag for turning on or off gossip for the whole MUD */
d2891 4
@


1.49
log
@Fixed a bug where players awaiting a name approval could
cut their link and then crash the mud.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.48 2001/03/04 17:33:19 dce Exp $
d2271 2
a2272 1
      if (ch->desc && ch->desc->original) {
d2891 4
@


1.48
log
@Fixed the falling problem where players would not
gain hp after falling. Also fixed the problem where
players could cast while sitting after falling.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.47 2001/03/03 18:08:20 dce Exp $
d89 1
d1861 1
d2890 5
@


1.47
log
@Minor fix for shapechange
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.46 2001/02/24 16:47:31 dce Exp $
d2823 1
d2836 1
d2839 1
d2883 2
d2888 3
@


1.46
log
@Changes made for shapechange. Shapechange uses the chant
variable to limit its use.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.45 2001/01/23 01:51:46 rsd Exp $
d2295 2
d2883 4
@


1.45
log
@turned off occ by detault
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.44 2000/11/28 01:36:34 mtp Exp $
d860 4
d2238 2
d2244 2
d2247 1
d2255 6
a2260 2
      if (d->original)   
        wch = d->original;
d2264 35
d2881 3
@


1.44
log
@remveove last vestiges of mobprgos (damn these things get around)
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.43 2000/11/28 01:19:01 mtp Exp mtp $
d109 1
a109 1
int gossip_channel_active = 1;	/* Flag for turning on or off gossip for the whole MUD */
d2833 3
@


1.43
log
@remove process_events() (replaced dg_event code with events.c code)
removed mobprog references
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.42 2000/11/20 19:43:45 rsd Exp $
a153 1
extern void mprog_act_trigger(char *buf, struct char_data *mob, struct char_data *ch, struct obj_data *obj, void *vo);
d2833 4
@


1.42
log
@added back rlog messages from prior to the $log$ string.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.41 2000/11/15 22:55:01 rsd Exp $
a103 1
bool MOBTrigger = TRUE;		/* for MOBProgs	*/
a814 1
      void process_events(void);
a817 2
      process_events();
      
a2232 3
  if (MOBTrigger)
     mprog_act_trigger(lbuf, to, ch, obj, vict_obj);

a2271 1
      MOBTrigger = TRUE;
a2295 1
      MOBTrigger = TRUE;
a2309 1
      MOBTrigger = TRUE;
a2345 1
    MOBTrigger = TRUE;
d2834 3
@


1.41
log
@changed a perror() to a log()
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.40 2000/04/14 00:47:00 rsd Exp $
a2842 12
 
 
 
 








d2845 3
d2874 151
@


1.40
log
@Added some spanky code to send banned players a message about
being banned, also added something to the log message to make
it bloody obvious someone banned tried to connect...
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.39 2000/04/02 02:38:23 rsd Exp $
d1635 1
a1635 1
		    perror("process_input: about to lose connection");
d2857 5
@


1.39
log
@Added the comment header while I was browsing for information.
I also fixed bracket problems in the social section and re-tabbed
that part of the function.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.38 2000/03/20 04:28:47 rsd Exp $
d1435 2
a1436 1
    
d1479 3
d1483 1
a1483 1
      sprintf(buf2, "Connection attempt denied from [%s]", newd->host);
d2857 5
@


1.38
log
@added comments regarding my_signal(SIGUSR1, reread_wizlists)
@
text
@d1 3
a3 3
// $Id: comm.c,v 1.37 2000/02/14 05:13:23 jimmy Exp $
 /***************************************************************************
 *   File: comm.c                                        Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d2269 85
a2353 96
void act(char *str, int hide_invisible, struct char_data *ch,
	  struct obj_data *obj, void *vict_obj, int type)
   {
     struct char_data *to = NULL;
     static int sleep;
     
     if (!str) {
       MOBTrigger = TRUE;
       return;
     } 
     
     
     if (!(dg_act_check = !(type & DG_NO_TRIG)))
       type &= ~DG_NO_TRIG;
     
     /*
      * Warning: the following TO_SLEEP code is a hack.
      * 
      * I wanted to be able to tell act to deliver a message regardless of sleep
      * without adding an additional argument.  TO_SLEEP is 128 (a single bit
      * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
      * command.  It's not legal to combine TO_x's with each other otherwise.
      */
     
     /* check if TO_SLEEP is there, and remove it if it is. */
     if ((sleep = (type & TO_SLEEP)))
       type &= ~TO_SLEEP;
     
     
     if (type == TO_CHAR) {
       if (ch && SENDOK(ch))
	 perform_act(str, ch, obj, vict_obj, ch);
       MOBTrigger = TRUE;
       return;
     }
     if (type == TO_VICT) {
       if ((to = (struct char_data *) vict_obj) && SENDOK(to)) {
	  if (to == NULL) // Uncommented on 3/21/99 by David Endre
	     return;      // Why the hell would Hubis comment
	  if (!to)        // these four line out?
	     return;      // Beats the hell outta me.
            /* if a tree falls in the forest... Banyal cut on some bandwidth */ 
	 //  /* and lets kill soem bugs while we here Banyal*/
	 // if (to->desc && (IS_NPC(to) || !to->player_specials->ignored ||
	 // (to->player_specials->ignored != ch)) && ((to != ch))) 
	 perform_act(str, ch, obj, vict_obj, to);
       }
       MOBTrigger = TRUE;
       return;
       
     }
     /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */
     
     if ((ch))
       {
	 if ((ch->in_room != NOWHERE))
	   to = world[ch->in_room].people;
	 else {
	   sprintf(buf, "SYSERR:comm.c:act(): ch->in_room = -1, %s", GET_NAME(ch));
	   log(buf);
	   return;
	 }
       } 
     else if ((obj != NULL))
       {
	 if ((obj->in_room != NOWHERE))
	   { 
	     if ((obj->in_room) != 0) 
	       to = world[obj->in_room].people;
	     else
	       {
		 sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
		 log(buf);
		 return;
	       }
	   }
	 else
	   {/*if here then NO ch and obj->in_room = NOWHERE*/
	     sprintf(buf, "SYSERR:comm.c:act(): obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
	     log(buf);
	     return;
	   }
       } 
     else 
       {
	 /* no obj or ch */
	 log("SYSERR:comm.c:act(): NULL char and object pointer");
	 return;
       }
     
     for (; to; to = to->next_in_room)
       if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
	   (to != ch) && (type == TO_ROOM || (to != vict_obj)))
	 perform_act(str, ch, obj, vict_obj, to);
     MOBTrigger = TRUE;
   }
d2724 1
a2724 1
				/*				send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch); */
d2853 3
@


1.37
log
@Fixed hupsig signal to not exit the instant it received a SIGHUP.
The mud now shuts down cleanly.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.36 1999/11/28 22:55:42 cso Exp $
d2021 4
d2862 4
@


1.36
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.35 1999/10/06 17:53:01 rsd Exp $
d1973 1
a1973 2
	      exit(0);			/* perhaps something more elegant should
					 * substituted */
d2858 3
@


1.35
log
@Added afk to the beginning of the prompt and cmc added
wizinvis and afk into the prompt properly.
@
text
@d1 1
a1 1
// $Id: comm.c,v 1.34 1999/09/05 07:00:39 jimmy Exp $
d548 1
a548 1
   * output and sending it out to players, and calling "heartbeat" functions
d2859 4
@


1.34
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d1234 4
a1237 1
      
d1245 1
a1245 1
      }
d1250 19
d1284 1
a1284 1
	 
d1298 1
d1301 1
a1301 1
  
d2858 4
a2861 1
// $Log$
@


1.33
log
@Potential lock out bug.
Mud times out connections waiting at ANSI prompt.
@
text
@d1 1
d2835 1
@


1.32
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d1859 1
a1859 1
		if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME)
@


1.31
log
@added debug to help with pfile problems
@
text
@d65 1
a65 1
extern FILE *player_fl;
d325 1
a325 1
      fclose(player_fl);
a813 1
      extern int top_of_p_table;
d860 1
a860 1
	  fflush(player_fl);
a877 5

      if(!(pulse % (60 * PASSES_PER_SEC))) {     /* 1 minute */
	sprintf(buf, "TOP_OF_P_TABLE: %d", top_of_p_table);
	log(buf);
      }
@


1.30
log
@Attempt to control the spiraling of memory.  Added a free() to the
prompt code in comm.c to free memory allocated by parse_color().
made a global structure dummy_mob and malloc'ed it for mobs
to share as their player_specials to cut memory.
gurlaek
@
text
@d814 2
a815 1
      
d879 5
@


1.29
log
@Changed missed reference to HUBIS to Fiery
@
text
@d1232 1
a1232 2
      char prompt[MAX_INPUT_LENGTH];
      
d1245 13
a1257 2
	write_to_descriptor(d->descriptor,parse_color(prompt_str(d->character),d));
	/*  char prompt[MAX_INPUT_LENGTH];
d1259 2
a1260 1
	 *prompt = '\0';
d1262 12
a1273 17
	 if (GET_INVIS_LEV(d->character))
	 sprintf(prompt, "i%d ", GET_INVIS_LEV(d->character));
	 
	 if (PRF_FLAGGED(d->character, PRF_DISPHP))
	 sprintf(prompt, "%s%dH ", prompt, GET_HIT(d->character));
	 
	 if (GET_MAX_MANA(tch) != 0)
	 if GET_MAX_MANA(tch) > 0)
	 if (GET_MANA(tch) > 0)
	 if (PRF_FLAGGED(d->character, PRF_DISPMANA))
	 sprintf(prompt, "%s%dM ", prompt, GET_MANA(d->character));
	 
	 if (PRF_FLAGGED(d->character, PRF_DISPMOVE))
	 sprintf(prompt, "%s%dV ", prompt, GET_MOVE(d->character));
	 
	 strcat(prompt, "> ");
	 write_to_descriptor(d->descriptor, prompt);*/
d2348 4
a2351 3
 /* Completely rewritten by gurlaek 7/8/1999 to fix overflows */
 /* due to estimation of the malloc'ed strlen                 */

@


1.28
log
@doh, forgot to recompile after commenting. Stupid parse error.
@
text
@d1095 1
a1095 1
      str = "&0Hubis MUD&0: Set your prompt (see 'help prompt')>";
d1418 1
a1418 1
      write_to_descriptor(desc, "Sorry, Hubis is full right now... please try again later!\r\n");
@


1.27
log
@rewrote parse_color() to fix silly overflows due to an estimation of the
length of the converted ansi string.  The function now does not malloc
until the string has been converted and is in it's final form.
--gurlaek 7/8/1999
@
text
@d2359 1
a2359 1
     `if((strlen(CCNRM(t->character, C_NRM)) + strlen(new_txt)) < MAX_STRING_LENGTH)
d2371 5
a2375 1
	 new_txt[strlen(new_txt)] = txt[i]; 
@


1.26
log
@Highely modified worship.c/h to change from many small functions that
were passes as (void *) to 4 large functions that use switch().  This
was done to remove the warnings produced by the -pedantic compiler flag.
divine_intervention was also commented out for now in comm.c because we
don't currently use it anyway. --Gurlaek 7/2/1999
@
text
@d1 1
a1 1
/***************************************************************************
d2342 168
a2509 13
 
 char *parse_color(char *txt, struct descriptor_data *t)
   {
     char *new_txt;
     char *toret = '\0';
     register int i, j = 0;
     
     i = count_chars(txt, '&'); /* count how many control-chars there
				   are in the string */
     
     if(!t) {
       log("Error in parse_color, no one to send the message to!");
       return toret;
d2511 5
a2515 11
     
     new_txt = malloc(i * 5 + strlen(txt) + 5); /* no ansi-escape code is larger
						   than 5 bytes so a 5 * times
						   the '&' appears + strlen(txt)
						   + 1 character big buffer
						   should be enough */
     /* This fixes that ANNOYING color bleeding from prompt! -Nechtrous */
     if(t->character) {
       strcpy(new_txt + j, CCNRM(t->character, C_NRM));
       if(clr(t->character, C_NRM))
	 j += 4;
a2516 114
     /* the parser.. Huge but fast */
     for(i = 0; txt[i]; i++)
       {
	 if(txt[i] == '&')
	   {
	     i++;
	     if(!(t->character)) {
	       new_txt[j] = txt[i]; j++;
	     }
	     else
	       switch(txt[i])
		 {
		 case '0' : strcpy(new_txt + j, CCNRM(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 4;
		   break;
		 case '1' : strcpy(new_txt + j, CCRED(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '2' : strcpy(new_txt + j, CCGRN(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '3' : strcpy(new_txt + j, CCYEL(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '4' : strcpy(new_txt + j, CCBLU(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '5' : strcpy(new_txt + j, CCMAG(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '6' : strcpy(new_txt + j, CCCYN(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '7' : strcpy(new_txt + j, CCWHT(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '8' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 4;
		   break;
		 case '9' : strcpy(new_txt + j, CCBLK(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'u' : strcpy(new_txt + j, CCUND(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 4;
		   break;
		 case 'd' : strcpy(new_txt + j, CCDAR(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 4;
		   break;
		 case 'b' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 4;
		   break;
		   
		 case 'R' : strcpy(new_txt + j, CCBRED(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'G' : strcpy(new_txt + j, CCBGRN(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'Y' : strcpy(new_txt + j, CCBYEL(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'B' : strcpy(new_txt + j, CCBBLU(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'M' : strcpy(new_txt + j, CCBMAG(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'C' : strcpy(new_txt + j, CCBCYN(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'W' : strcpy(new_txt + j, CCBWHT(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case 'S' : strcpy(new_txt + j, CCBBLK(t->character, C_NRM));
		   if(clr(t->character, C_NRM))
		     j += 5;
		   break;
		 case '&' : new_txt[j] = txt[i]; j++; break;
		   
		 default:  break;
		 }
	     
	   }
	 else
	   {
	     new_txt[j] = txt[i]; j++;
	   }
       }
     
     new_txt[j] = '\0'; /* terminate the string */
     toret = strdup(new_txt); /* create a new string with no eventual memoryloss */
     free(new_txt); /* free the old buffer */
     
     return toret; /* the colorized buffer */
d2518 7
@


1.25
log
@Ok, fixed do_quit to check for fighting and also not crash when mortally
wounded.  This was done in die() by checking for killer=NULL.
since no one killed you if you quit while morted the die code
didn't know how to deal with a NULL killer.
--Gurlaek 6/11/1999
@
text
@d833 3
a835 2
      if (!(pulse % (60 * PASSES_PER_SEC)))		/* 1 minute */
	divine_intervention();
@


1.24
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d2761 1
a2761 1
       die(ch, ch);
@


1.23
log
@Fixed warnings/errors associated with the addition of the pendantic compiler flag
yeeeeehaaawwww.  --gurlaek
@
text
@d719 1
a719 1
	  if (FD_ISSET(d->descriptor, &output_set) && *(d->output))
d724 1
a1930 1
	      extern int num_invalid;
a1935 1
	      num_invalid = 0;
@


1.22
log
@fixed typecast of int i to work with the accept() function
in  new_descriptor().
-- Gurlaek
@
text
@d12 3
a14 1

d1395 1
a1395 1
    int i;
d1404 1
a1404 1
    if ((desc = accept(s, (struct sockaddr *) &peer, &(int)i)) == INVALID_SOCKET) {
d2765 1
@


1.21
log
@FAttempt to fix parse_color bug
@
text
@d1402 1
a1402 1
    if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
@


1.20
log
@Testing
@
text
@d2344 1
a2344 1
     char *toret;
d2350 4
@


1.19
log
@sigh
@
text
@d2115 2
a2116 8
	      register char *i = NULL, *buf;
	      static char lbuf[MAX_STRING_LENGTH];
	      struct char_data *dg_victim = NULL;
	      struct obj_data *dg_target = NULL; 
	      char *dg_arg = NULL;
	      char spare[40];
	      int sptr = 0;
	      int needscap = 0;
d2118 1
a2118 1
	      buf = lbuf;
d2120 70
a2189 3
	      
	      for (;;) 
		{
d2191 7
a2197 6
		if (*orig == '&')
		  {	  
		    sptr--;
		    sptr--;
		  }
		sptr++;		
d2199 1
a2200 203
		if (*orig == '$') 
		{

		  /* This ensures that a mob's name is capitalized if it's first in an action; */
		  /*   i.e. '$n tells you' - Selina, 4-2-99 */
		  if (sptr < 2)
		    needscap = 1;
		  else
		    needscap = 0;

		    switch (*(++orig)) 
		      {
		      case 'n':
			if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
			{
			  if (needscap)
			    i = "Someone";
			  else
			    i = "someone";
			  break;
			}	
			if (IS_NPC(ch)) 
			  {					
			    if (needscap)
			    {
			      i = PERS(ch, to);
			      // i[0] = toupper(i[0]);
			      i = CAP(PERS(ch, to));
			    }
			    else
			      i = PERS(ch, to);
			    break;
			  }	
			if (GET_LEVEL(to) >= LVL_IMMORT) 
			  {
			    i = PERS(ch, to);
			    break;
			  }	   /*rest of code is mortal only*/
			if (GET_RACE_ALIGN(ch) == (GET_RACE_ALIGN(to) & (!PRF_FLAGGED(ch, PRF_NONAME))))			
			  {
			    i = PERS(ch, to);
			    if (sptr == 1)
			      ;/*		i = CAP(i);
				*/}else 
				  {
				    if ((GET_LEVEL(ch) > 70) & ((!PRF_FLAGGED(ch, PRF_NONAME))))		
				      i = PERS(ch, to);	
				    else 
				      {
					if (CAN_SEE(to, ch) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))) 
					  {
					    if (sptr == 1) 
					      {
						if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
						  sprintf(spare, "An %s", RACE_ABBR(ch));	
						else
						  sprintf(spare, "A %s", RACE_ABBR(ch));
						i = spare;
					      } else {			
						if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
						  sprintf(spare, "an %s", RACE_ABBR(ch));
						else
						  sprintf(spare, "a %s", RACE_ABBR(ch));			
						i = spare;
					      }
					  }
					else
					  if ((sptr) == 1)		
					    i = "Someone";
					  else
					    i = "someone";
				      }	
				  }	  /*i = PERS(ch, to);	*/break;
			
			
		      case 'N':
			if (IS_NPC(to)) {
			  CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
			  break;
			}
			if (IS_NPC((struct char_data *) vict_obj)) {
			  CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
			  dg_victim = (struct char_data *) vict_obj;
			  break;
			}
			
			if (GET_LEVEL(to) >= LVL_IMMORT) {
			  CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
			  dg_victim = (struct char_data *) vict_obj;
			  break;
			}	
			
			/*rest of code is mortal only...Buru!!!*/
			
			if (GET_RACE_ALIGN((struct char_data *) vict_obj) == (GET_RACE_ALIGN(to) &
									      !PRF_FLAGGED(((struct char_data *) vict_obj), PRF_NONAME))) {
			  CHECK_NULL(vict_obj, PERS(((struct char_data *) vict_obj), to));
			  dg_victim = (struct char_data *) vict_obj;
			} else {
			  if (CAN_SEE(ch, (struct char_data *) vict_obj) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))) {
			    if ((sptr) == 1) {
			      if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE(to) == RACE_ORC)){
				sprintf(spare, "An %s", RACE_ABBR((struct char_data *) vict_obj));
				dg_victim = (struct char_data *) vict_obj;
			      }else
				sprintf(spare, "A %s", RACE_ABBR((struct char_data *) vict_obj));
			      dg_victim = (struct char_data *) vict_obj;
			      i = spare;  
			    } else {
			      if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE((struct char_data *) vict_obj) == RACE_ORC)){
				sprintf(spare, "an %s", RACE_ABBR((struct char_data *) vict_obj));
				dg_victim = (struct char_data *) vict_obj;
			      }else
				sprintf(spare, "a %s", RACE_ABBR((struct char_data *) vict_obj));
			      dg_victim = (struct char_data *) vict_obj;
			      i = spare; 
			    }
			  }
			  else
			    i = "someone";
			}	  	  
			/*	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
			 */break;
		      case 'm':
			i = HMHR(ch);
			break;
		      case 'M':
			CHECK_NULL(vict_obj, HMHR((struct char_data *) vict_obj));
			dg_victim = (struct char_data *) vict_obj;
			break;
		      case 's':
			i = HSHR(ch);
			break;
		      case 'S':
			CHECK_NULL(vict_obj, HSHR((struct char_data *) vict_obj));
			dg_victim = (struct char_data *) vict_obj;
			break;
		      case 'e':
			i = HSSH(ch);
			break;
		      case 'E':
			CHECK_NULL(vict_obj, HSSH((struct char_data *) vict_obj));
			dg_victim = (struct char_data *) vict_obj;
			break;
		      case 'o':
			CHECK_NULL(obj, OBJN(obj, to));
			break;
		      case 'O':
			CHECK_NULL(vict_obj, OBJN((struct obj_data *) vict_obj, to));
			dg_target = (struct obj_data *) vict_obj;
			break;
		      case 'p':
			CHECK_NULL(obj, OBJS(obj, to));
			break;
		      case 'P':
			CHECK_NULL(vict_obj, OBJS((struct obj_data *) vict_obj, to));
			dg_target = (struct obj_data *) vict_obj;
			break;
		      case 'a':
			CHECK_NULL(obj, SANA(obj));
			break;
		      case 'A':
			CHECK_NULL(vict_obj, SANA((struct obj_data *) vict_obj));
			dg_target = (struct obj_data *) vict_obj;
			break;
		      case 'T':
			CHECK_NULL(vict_obj, (char *) vict_obj);
			dg_arg = (char *) vict_obj;
			break;
		      case 'F':
			CHECK_NULL(vict_obj, fname((char *) vict_obj));
			break;
		      case '$':
			i = "$";
			break;
		      default:
			log("SYSERR: Illegal $-code to act():");
			strcpy(buf1, "SYSERR: ");
			strcat(buf1, orig);
			log(buf1);
			break;
		      }
		    while ((*buf = *(i++)))
		      buf++;
		    orig++;
		  } else if (!(*(buf++) = *(orig++)))
		    break;
		}
	      
	      *(--buf) = '\r';
	      *(++buf) = '\n';
	      *(++buf) = '\0';
	      
	      if (to->desc){
		SEND_TO_Q("&0", to->desc);
		SEND_TO_Q(CAP(lbuf), to->desc);
	      }
	      if ((IS_NPC(to) && dg_act_check) && (to != ch))
		act_mtrigger(to, lbuf, ch, dg_victim, obj, dg_target, dg_arg);
	      if (MOBTrigger)
		mprog_act_trigger(lbuf, to, ch, obj, vict_obj);
	    }
	  
a2262 3
{
	 sprintf(buf, "DEBUG: Call to perform_act from %s to %s (if(ch && SENDER(ch))", GET_NAME(ch), GET_NAME(ch));
	 log(buf);
a2263 1
}
a2276 5

	 sprintf(buf, "DEBUG: Call to perform_act from %s to %s (after Banyal's REMs)", GET_NAME(ch), GET_NAME(to));
	 log(buf);


a2324 4
{
	 sprintf(buf, "DEBUG: Call to perform_act from %s to %s (3rd time down)", GET_NAME(ch), GET_NAME(to));
	 log(buf);

d2326 1
a2326 2
} 
    MOBTrigger = TRUE;
@


1.18
log
@Revisions w/ debug info
@
text
@d2474 1
a2474 1

d2479 2
a2480 1
     MOBTrigger = TRUE;
@


1.17
log
@Revision for testing #1
@
text
@d2403 3
d2407 1
d2421 5
d2474 4
@


1.16
log
@An attempt to fix a core dump when perform_act handles
i = "someone"; I think more drastic measures may be needed
but this is a first shot.
@
text
@d2164 2
a2165 2
			      i[0] = toupper(i[0]);
			     // i = CAP(PERS(ch, to));
@


1.15
log
@Redone cap code... using toupper fn instead of CAP macro
@
text
@a2129 7
		/* This ensures that a mob's name is capitalized if it's first in an action; */
		/*   i.e. '$n tells you' - Selina, 4-2-99 */
		if (*orig == '$' && sptr < 2)
		  needscap = 1;
		else
		  needscap = 0;

d2139 9
a2147 1
		  {			
d2152 4
a2155 1
			  {
d2157 2
a2158 2
			    break;
			  }	
@


1.14
log
@Commented out the car needscap :p
@
text
@d2122 1
a2122 1
//	      int needscap = 0;
d2132 4
a2135 4
//		if (*orig == '$' && sptr < 2)
//		  needscap = 1;
//		else
//		  needscap = 0;
d2157 7
a2163 4
/* This is commented out for now for crashing problems... Selina 4-5 */
//			    if (needscap)
//			      i = CAP(PERS(ch, to));
//			    else
@


1.13
log
@Backed out the capitalization code until
I can figure out why it's crashing sometimes.
@
text
@d2122 1
a2122 1
	      int needscap = 0;
@


1.12
log
@Fixes the problem with mobs telling you stuff (or conceivably any
instance where an 'act' string is parsed with a $n for a mob at
the beginning - i.e. '$n tells you') ... it capitalizes the first
char of the mob name in that instance only.

Selina
@
text
@d2132 4
a2135 4
		if (*orig == '$' && sptr < 2)
		  needscap = 1;
		else
		  needscap = 0;
d2157 4
a2160 3
			    if (needscap)
			      i = CAP(PERS(ch, to));
			    else
@


1.11
log
@Added a mortal gossip channel with 103+ godly control
@
text
@d2122 2
d2125 1
a2125 1
	      
d2128 10
a2137 1
		{		if (*orig == '&')
d2143 2
d2157 5
a2161 2
			    i = PERS(ch, to);
			    /*i = CAP(PERS(ch, to));*/					break;				
d2362 3
a2364 1
 void act(char *str, int hide_invisible, struct char_data *ch,
@


1.10
log
@Fixed a Hubis crash bug.
@
text
@d105 1
@


1.9
log
@Updated debug messages in comm.c and handler.c to include
more useful info, as well as adding an abort where exit
used to be in order to get a core.
fingon
@
text
@d2381 6
a2386 5
       if ((to = (struct char_data *) vict_obj) && SENDOK(to)) 
	 //  if (to == NULL)
	 //  return;
	 //  if (!to)
	 //  return;  /* if a tree falls in the forest... Banyal cut on some bandwidth */ 
d2391 1
@


1.8
log
@Adds the skill safefall for monks.
@
text
@d2332 1
a2332 1

d2345 46
a2390 83
	  void act(char *str, int hide_invisible, struct char_data *ch,
		   struct obj_data *obj, void *vict_obj, int type)
	    {
	      struct char_data *to = NULL;
	      static int sleep;
	      
	      if (!str) {
		MOBTrigger = TRUE;
		return;
	      } 
	      
	      
	      if (!(dg_act_check = !(type & DG_NO_TRIG)))
		type &= ~DG_NO_TRIG;
	      
	      /*
	       * Warning: the following TO_SLEEP code is a hack.
	       * 
	       * I wanted to be able to tell act to deliver a message regardless of sleep
	       * without adding an additional argument.  TO_SLEEP is 128 (a single bit
	       * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
	       * command.  It's not legal to combine TO_x's with each other otherwise.
	       */
	      
	      /* check if TO_SLEEP is there, and remove it if it is. */
	      if ((sleep = (type & TO_SLEEP)))
		type &= ~TO_SLEEP;
	      
	      
	      if (type == TO_CHAR) {
		if (ch && SENDOK(ch))
		  perform_act(str, ch, obj, vict_obj, ch);
		MOBTrigger = TRUE;
		return;
	      }
	      if (type == TO_VICT) {
		if ((to = (struct char_data *) vict_obj) && SENDOK(to)) 
		  //  if (to == NULL)
		  //  return;
		  //  if (!to)
		  //  return;  /* if a tree falls in the forest... Banyal cut on some bandwidth */ 
		  //  /* and lets kill soem bugs while we here Banyal*/
		  // if (to->desc && (IS_NPC(to) || !to->player_specials->ignored ||
		  // (to->player_specials->ignored != ch)) && ((to != ch))) 
		  perform_act(str, ch, obj, vict_obj, to);
		MOBTrigger = TRUE;
		return;
		
	      }
	      /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */
	      
	      if ((ch))
		{
		  if ((ch->in_room != NOWHERE))
		    to = world[ch->in_room].people;
		  else 
		    log("SYSERR: no valid target to act()!");
		} 
	      else if ((obj != NULL))
		{
		  if ((obj->in_room != NOWHERE))
		    { 
		      if ((obj->in_room) != 0) 
			to = world[obj->in_room].people;
		      else
			{
			  log("SYSERR: no valid target to act()!");
			  sprintf(buf, "Error in ACT, obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
			  mudlog(buf, CMP, LVL_GOD, FALSE);
			  return;
			}
		    }
		  else
		    {/*if here then NO ch and NO obj ==>error*/
		      log("SYSERR: no valid target to act()!");
		      sprintf(buf, "Error in ACT, obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
		      mudlog(buf, CMP, LVL_GOD, FALSE);
		      return;
		    }
		} 
   else 
     {
       log("SYSERR: no valid target to act()!");
d2392 1
d2394 261
a2654 223
	      
	      for (; to; to = to->next_in_room)
		if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
		    (to != ch) && (type == TO_ROOM || (to != vict_obj)))
		  perform_act(str, ch, obj, vict_obj, to);
	      MOBTrigger = TRUE;
	    }
	  
	  
	  int count_chars(char *txt, char character)
	    {
	      int i, cnt = 0;
	      
	      for(i = 0; txt[i]; i++)
		if(txt[i] == character)
		  cnt++;
	      
	      return cnt;
	    }
	  
	  char *parse_color(char *txt, struct descriptor_data *t)
	    {
	      char *new_txt;
	      char *toret;
	      register int i, j = 0;
	      
	      i = count_chars(txt, '&'); /* count how many control-chars there
					    are in the string */
	      
	      
	      new_txt = malloc(i * 5 + strlen(txt) + 5); /* no ansi-escape code is larger
							    than 5 bytes so a 5 * times
							    the '&' appears + strlen(txt)
							    + 1 character big buffer
							    should be enough */
	      /* This fixes that ANNOYING color bleeding from prompt! -Nechtrous */
	      if(t->character) {
		strcpy(new_txt + j, CCNRM(t->character, C_NRM));
		if(clr(t->character, C_NRM))
		  j += 4;
	      }
	      /* the parser.. Huge but fast */
	      for(i = 0; txt[i]; i++)
		{
		  if(txt[i] == '&')
		    {
		      i++;
		      if(!(t->character)) {
			new_txt[j] = txt[i]; j++;
		      }
		      else
			switch(txt[i])
			  {
			  case '0' : strcpy(new_txt + j, CCNRM(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 4;
			    break;
			  case '1' : strcpy(new_txt + j, CCRED(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '2' : strcpy(new_txt + j, CCGRN(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '3' : strcpy(new_txt + j, CCYEL(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '4' : strcpy(new_txt + j, CCBLU(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '5' : strcpy(new_txt + j, CCMAG(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '6' : strcpy(new_txt + j, CCCYN(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '7' : strcpy(new_txt + j, CCWHT(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '8' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 4;
			    break;
			  case '9' : strcpy(new_txt + j, CCBLK(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'u' : strcpy(new_txt + j, CCUND(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 4;
			    break;
			  case 'd' : strcpy(new_txt + j, CCDAR(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 4;
			    break;
			  case 'b' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 4;
			    break;
			    
			  case 'R' : strcpy(new_txt + j, CCBRED(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'G' : strcpy(new_txt + j, CCBGRN(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'Y' : strcpy(new_txt + j, CCBYEL(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'B' : strcpy(new_txt + j, CCBBLU(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'M' : strcpy(new_txt + j, CCBMAG(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'C' : strcpy(new_txt + j, CCBCYN(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'W' : strcpy(new_txt + j, CCBWHT(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case 'S' : strcpy(new_txt + j, CCBBLK(t->character, C_NRM));
			    if(clr(t->character, C_NRM))
			      j += 5;
			    break;
			  case '&' : new_txt[j] = txt[i]; j++; break;
			    
			  default:  break;
			  }
		      
		    }
		  else
		    {
		      new_txt[j] = txt[i]; j++;
		    }
		}
	      
	      new_txt[j] = '\0'; /* terminate the string */
	      toret = strdup(new_txt); /* create a new string with no eventual memoryloss */
	      free(new_txt); /* free the old buffer */
	      
	      return toret; /* the colorized buffer */
	    }
	  
	  /*  This function scans every room of the mud and checks for IN_FLIGHT */
	  /*  once IN_FLIGHT rooms are found, every non flying obj, PC, NPC */
	  /*  falls to the earth and takes damage according to size and number */
	  /*  of rooms fallen.  This also takes into account landing in water. */
	  
	  /*  --Fingon */
	  
	  
	  void do_gravity_check(void)
	    {
	      struct obj_data *i, *j;
	      struct char_data *ch = 0;
	      int was_in, zn, rn, rrn, k, screwed;
	      int riding = FALSE, ridden_by = FALSE, flying = FALSE;
	      char gravbuf[MAX_STRING_LENGTH];
	      
	      /*  Cycle through each zone */
	      
	      for (zn = 0; zn <= top_of_zone_table; zn++) {
		if (zone_table[zn].top) {
		  
		  /*  Cycle through each room in zone */
		  
		  for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) {
		    if (real_room(rn) != NOWHERE) {	
		      rrn = real_room(rn);
		      if (world[rrn].sector_type == SECT_FLYING) {
			
			/*  start the gravity check for objects */
			
			i = world[rrn].contents;
			while(i) {
			  
			  /*  check each object */
			  
			  if ((j=i->next_content)) {
			    if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
				 (strcmp(j->description,i->description)==0)) ||
				((j->item_number==i->item_number) && (i->item_number!=NOTHING))) {
			      i = j;
			      continue;
			    }
			  }

			  /*  make it fall */

			  screwed = FALSE;
			  while (SECT(i->in_room) == SECT_FLYING && 
				 !IS_OBJ_SPELL_AFF(i, ITEM_FLY) &&
				 i->obj_flags.type_flag != ITEM_PORTAL &&
				 !screwed) {
			    if(CAN_GO(i, DOWN)) {

			      /*  display to people in room object is falling from */

			      act("$p &1&bplummets&0 &2downward!&0",FALSE,0,i,0,TO_ROOM);
			      was_in = i->in_room;

			      /* display to people object falls through */

			      for (ch = world[EXIT(i, DOWN)->to_room].people; 
				   ch != NULL; ch = ch->next_in_room)
				act("$p &1&bfalls from above.&0",FALSE,ch,i,0,TO_CHAR);

			      if (SECT(EXIT(i, DOWN)->to_room) != SECT_FLYING) {

d2656 33
a2688 33

				if((SECT(EXIT(i, DOWN)->to_room) == SECT_WATER_SWIM || 
				    SECT(EXIT(i, DOWN)->to_room) == SECT_WATER_NOSWIM || 
				    SECT(EXIT(i, DOWN)->to_room) == SECT_OCEAN)) { 
				  for (ch = world[EXIT(i, DOWN)->to_room].people; 
				       ch != NULL; ch = ch->next_in_room)
				    act("$p &1&blands with a loud&0 &1SPLASH!&0",FALSE,ch,i,0,TO_CHAR);
				  if (!IS_OBJ_STAT(i, ITEM_FLOAT)) {

				    /* Sink it! */

				    for (ch = world[EXIT(i, DOWN)->to_room].people; 
					 ch != NULL; ch = ch->next_in_room)
				      act("$p &4&bsinks like a rock.&0",FALSE,ch,i,0,TO_CHAR);
				    obj_from_room(i);
				    screwed = TRUE;
				  } else {

				    /* object floats so put it in the water */

				    obj_from_room(i);
				    obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
				  }
				} else {

				  /* land on solid ground */

				  obj_from_room(i);
				  obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
				  act("$p &1&blands with a dull&0 &1THUD!&0",FALSE,0,i,0,TO_ROOM);
				}
			      } else {

d2690 186
a2876 5
				obj_from_room(i);
				obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
			      }
			     
			    } else {
a2877 1
			      /* No Down exit! */
a2878 80
                              sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit", world[i->in_room].number);
                              log(gravbuf);
			      screwed = TRUE;
			    }
			  }
			  i = i->next_content;
			}
			
			/*  end of object gravity check */
			/*  start the gravity check for players/mobs  */
			/*  check each ch */
			
			for (ch = world[rrn].people; ch != NULL; ch = ch->next_in_room) {
			  k = 0;
			  flying = 0;
			  riding = 0;
			  ridden_by = 0;
			  if (GET_POS(ch) == POS_FLYING) flying = 1;
			  /*if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;*/
			  
			  /* If either mount or mountee is flying then don't fall */
			  /* otherwise unmount and prepare to fall... */
			  
			  if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING) {
			    riding = 1;
			    if (GET_POS(RIDING(ch)) == POS_FLYING) {
			      /*if (IS_AFFECTED(RIDING(ch), AFF_FLYING)) {*/
			      flying = 1;
			    }
			  }
			  if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) {
			    ridden_by = 1;
			    
			    /*if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) {*/
			    if (GET_POS(RIDDEN_BY(ch)) == POS_FLYING) {
			      flying = 1;
			    }
			  }
			  if (riding && !flying) dismount_char(ch);
			  if (ridden_by && !flying) dismount_char(RIDDEN_BY(ch));
			  
			  /* Make them fall */

			  screwed = FALSE;
			  while (SECT(ch->in_room) == SECT_FLYING && 
				 (GET_POS(ch) != POS_FLYING) && 
				 !flying && 
				 !screwed) {

			    if(CAN_GO(ch, DOWN)) {
			      k++;
			      
			      was_in = ch->in_room;
			    
			      /*  Message to room fall started in */
			    
			      if (k == 1) {
				act("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n"
				    , FALSE, ch, 0, 0, TO_CHAR);
				/*				send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch); */
				act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0"
				    , FALSE, ch, 0, 0, TO_ROOM);
			      }
			    
			      char_from_room(ch);
			      char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
			    
			      /*  Message to rooms falling through */
			    
                              /* David Endre 3/8/99 Send different message if they are a monk with safefall */
			      /* send_to_char("&2DOWN!&0\r\n", ch); */
                              if (GET_SKILL(ch, SKILL_SAFEFALL) == 0) {
			        act("&2DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
			        act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
			      } else {
				act("&2You fall gracefully DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
				act("&2$n gracefully falls from above.&0", FALSE, ch, 0, 0, TO_ROOM);
			      }
			      if (ch->desc != NULL)
				look_at_room(ch, 0);
a2879 4
			      if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
				do_falling_damage(ch, k);
			      }
			    } else {
a2880 1
			      /* No Down exit! */
a2881 17
			      sprintf(gravbuf, "GRAVITY: Room %d: IN_FLIGHT with no DOWN exit", world[ch->in_room].number);
                              log(gravbuf);
			      screwed = TRUE;
			    }
			  }
			}
		      }
		    }
		  }
		}
	      }
	      return;
	    }
	  
	  
	  void do_falling_damage(struct char_data *ch, float dist_fell)
	    {
a2882 3
	      /* Are we landing in water? It hurts MUCH less... */
              /* If we have safe fall skill, then we take no damage
                 for five rooms, partially for 5-15 and full at 15 David Endre 3/8/99 */
a2883 65
	      if((SECT(ch->in_room) == SECT_WATER_SWIM || 
		  SECT(ch->in_room) == SECT_WATER_NOSWIM || 
		  SECT(ch->in_room) == SECT_OCEAN)) { 
		act("\r\nYou land with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_CHAR);
		act("$n lands with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_ROOM);
		GET_POS(ch) = POS_SITTING;
                if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
		   if (dist_fell <= 5)
		      GET_HIT(ch) -= 0;
                   else if (dist_fell < 15)
   		      GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch)) * (dist_fell/15));
   		   else
		      GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
		} else
   		   GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
		update_pos(ch);
	      } else {
		GET_POS(ch) = POS_SITTING;
		if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell <=5) {
		   GET_POS(ch) = POS_STANDING;
		   act("\r\nYou tuck and roll, performing a beautiful landing!", FALSE, ch ,0, 0, TO_CHAR);
		   act("$n tucks and rolls, performing a beautiful landing!", FALSE, ch, 0, 0, TO_ROOM);
		} else if (GET_SKILL(ch, SKILL_SAFEFALL) > 0 && dist_fell < 15) {
		   act("\r\nYou gracefully land without taking too much damage.", FALSE, ch, 0, 0, TO_CHAR);
		   act("$n gracefully lands without taking too much damage.", FALSE, ch, 0, 0, TO_ROOM);
		} else {
		   act("\r\nYou land with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_CHAR);
		   act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
		}
                if (GET_SKILL(ch, SKILL_SAFEFALL) > 0) {
		   if (dist_fell <= 5)
		      GET_HIT(ch) -= 0;
                   else if (dist_fell < 15)
   		      GET_HIT(ch) -= ((((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch)) * (dist_fell/15));
   		   else
		      GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
		} else
		   GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
		update_pos(ch);
	      }
	      switch (GET_POS(ch)) {
	      case POS_MORTALLYW:
		act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
		send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
		break;
	      case POS_INCAP:
		act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
		send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
		break;
	      case POS_STUNNED:
		act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
		send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
		break;
	      case POS_DEAD:
		act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
		send_to_char("You are dead!  Sorry...\r\n", ch);
		sprintf(buf2, "%s killed by falling at %s", GET_NAME(ch), world[ch->in_room].name);
		mudlog(buf2, BRF, 0, TRUE);
		die(ch, ch);
		break;
	      default:
	      }
	    }
	  
	  
@


1.7
log
@Add's chant songs, and can only chant once every four hours
@
text
@d43 1
d2766 1
d2768 7
a2774 2
			      act("&2DOWN!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
			      act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
d2804 2
d2810 1
a2810 1
		act("You land with a tremendous &4SPLASH&2!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
d2813 9
a2821 1
		GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/200) * GET_MAX_HIT(ch);
a2823 2
		act("You land with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
		act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
d2825 20
a2844 1
		GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
@


1.6
log
@Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
and take 20 seconds to scribe each page.  This will be more dynamic when the
SCRIBE skill is introduced.  --Fingon.
@
text
@d160 2
a161 1

d856 1
d2315 25
@


1.5
log
@Fixed gravity code to handle IN_FLIGHT rooms with no down exits.
Also added fix for air rooms over water as well as semantics
for splashing and sinking.
fingon
@
text
@d73 1
d845 3
@


1.4
log
@fixed silly div by zero in the prompt code
fingon
@
text
@d2558 1
a2558 1
	  /*  of rooms fallen.   */
d2566 2
a2567 2
	      struct char_data *ch;
	      int was_in, zn, rn, rrn, k;
d2598 4
d2604 49
a2652 12
				 i->obj_flags.type_flag != ITEM_PORTAL) {
			    
			    /*  make it fall */
			    
			    was_in = i->in_room;
			    
			    /*  display to people in room object is falling from */
			    
			    for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
			      if (CAN_SEE_OBJ(ch, i)) {
				sprintf(gravbuf, "%s &1&bplummets&0 &2downward!&0\n", i->short_description);
				send_to_char(gravbuf, ch);
d2654 5
a2658 2
				sprintf(gravbuf, "Something &1&bwhizzes&0 &2downward!&0\n");
				send_to_char(gravbuf, ch);
d2660 8
a2667 28
			    }
			    obj_from_room(i);
			    obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);
			    
			    /*  display to people in room object is falling through/to */
			    
			    for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
			      if (CAN_SEE_OBJ(ch, i)) {
				sprintf(gravbuf, "&1&b%s falls from above.&0\n", i->short_description);
				send_to_char(gravbuf, ch);
			      } else {
				sprintf(gravbuf, "&1&bSomething whizzes past you.&0\n");
				send_to_char(gravbuf, ch);
			      }
			    }
			    
			    /*  time to land */
			    
			    if (SECT(i->in_room) != SECT_FLYING) {
			      for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
				if (CAN_SEE_OBJ(ch, i)) {
				  sprintf(gravbuf, "&1&b%s lands with a dull&0 &1THUD!&0\n", i->short_description);
				  send_to_char(gravbuf, ch);
				} else {
				  sprintf(gravbuf, "&1&bSomething lands with a dull&0 &1THUD!&0\n");
				  send_to_char(gravbuf, ch);
				}
			      }  
d2707 21
a2727 4
			  
			  /*	      while (SECT(ch->in_room) == SECT_FLYING && !IS_AFFECTED(ch, AFF_FLYING) && !flying) {*/
			  while (SECT(ch->in_room) == SECT_FLYING && (GET_POS(ch) != POS_FLYING) && !flying) {
			    k++;
d2729 2
a2730 1
			    was_in = ch->in_room;
d2732 1
a2732 1
			    /*  Message to room fall started in */
d2734 16
a2749 17
			    if (k == 1) {
			      send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch);
			      act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0", FALSE, ch, 0, 0, TO_ROOM);
			    }
			    
			    char_from_room(ch);
			    char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
			    if (ch->desc != NULL)
			      look_at_room(ch, 0);
			    
			    /*  Message to rooms falling through */
			    
			    send_to_char("&2DOWN!&0\r\n", ch);
			    act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
			    
			    if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
			      do_falling_damage(ch, k);
a2752 4
			
			
			
			
d2764 18
a2781 5
	      send_to_char("You land with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", ch);
	      act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
	      GET_POS(ch) = POS_SITTING;
	      GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
	      update_pos(ch);
@


1.3
log
@Indented entire file
@
text
@d1168 5
a1172 1
            perc = (100*GET_HIT(tank)) / GET_MAX_HIT(tank);
@


1.2
log
@fixed AFF_fFLYING to GET_POS9(ch) == POS_FLYING for gravity
@
text
@d1 9
a9 9
/* ************************************************************************
*   File: comm.c                                        Part of CircleMUD *
*  Usage: Communication, socket handling, main(), central game loop       *
*                                                                        *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d56 1
a56 1
 
d161 3
a163 3
/* *********************************************************************
*  main game loop and related stuff                                    *
********************************************************************* */
d171 1
a171 1

d185 1
a185 1

d188 1
a188 1

d242 1
a242 1
  if (chdir(dir) < 0) {
d244 4
a247 12
    perror("Fatal error changing to data directory");
    exit(1);
  }
  sprintf(buf, "Using %s as data directory.", dir);
  log(buf);

  if (scheck) {
    boot_world();
    log("Done.");
    exit(0);
  } else {
    sprintf(buf, "Running game on port %d.", port);
d249 12
a260 1
    init_game(port);
d262 2
d265 4
a268 9
  return 0;
}



/* Init sockets, run game, and cleanup sockets */
void init_game(int port)
{
  int mother_desc;
d270 2
a271 2
  int rowcounter, colcounter, vnum_read;
  FILE* mapfile;
d273 12
a284 12
  srandom(time(0));

  log("Finding player limit.");
  max_players = get_max_players();

  log("Opening mother connection.");
  mother_desc = init_socket(port);

  event_init();

  boot_db();

d286 2
a287 2
  log("Signal trapping.");
  signal_setup();
d289 1
a289 1

d291 9
a299 9
  log("Loading Surface Map. ");
  mapfile = fopen("world/surface.map", "r");
  for (rowcounter = 0; rowcounter < MAP_ROWS; rowcounter++) {
    for (colcounter = 0; colcounter < MAP_COLS; colcounter++) {
      fscanf(mapfile, "%d", &vnum_read);
        mapnums[rowcounter][colcounter] = real_room(vnum_read);
    }
  }
  fclose(mapfile);
d301 3
a303 3

  log("Entering game loop.");

d305 1
a305 1
  ispell_init();
d307 3
a309 3

  game_loop(mother_desc);

d311 1
a311 1
  ispell_done();
d313 38
a350 30

  log("Closing all sockets.");
  while (descriptor_list)
    close_socket(descriptor_list);

  CLOSE_SOCKET(mother_desc);
  fclose(player_fl);

   if (circle_reboot != 2 && olc_save_list) { /* Don't save zones. */
    struct olc_save_info *entry, *next_entry;
    for (entry = olc_save_list; entry; entry = next_entry) {
      next_entry = entry->next;
      if (entry->type < 0 || entry->type > 4) {
        sprintf(buf, "OLC: Illegal save type %d!", entry->type);
        log(buf);
      } else if (entry->zone < 0) {
        sprintf(buf, "OLC: Illegal save zone %d!", entry->zone);
        log(buf);
      } else {
        sprintf(buf, "OLC: Reboot saving %s for zone %d.",
		save_info_msg[(int)entry->type], entry->zone);
        log(buf);
        switch (entry->type) {
        case OLC_SAVE_ROOM: redit_save_to_disk(entry->zone); break;
        case OLC_SAVE_OBJ:  oedit_save_to_disk(entry->zone); break;
        case OLC_SAVE_MOB:  medit_save_to_disk(entry->zone); break;
        case OLC_SAVE_ZONE: zedit_save_to_disk(entry->zone); break;
        case OLC_SAVE_SHOP: sedit_save_to_disk(entry->zone); break;
        default:      log("Unexpected olc_save_list->type"); break;
        }
d352 1
d354 2
a355 20
  }
 

  if (circle_reboot) {
    log("Rebooting.");
    exit(52);			/* what's so great about HHGTTG, anyhow? */
  }
  log("Normal termination of game.");
}



/*
 * init_socket sets up the mother descriptor - creates the socket, sets
 * its options up, binds it, and listens.
 */
int init_socket(int port)
{
  int s, opt;
  struct sockaddr_in sa;
d358 2
a359 8
   * Should the first argument to socket() be AF_INET or PF_INET?  I don't
   * know, take your pick.  PF_INET seems to be more widely adopted, and
   * Comer (_Internetworking with TCP/IP_) even makes a point to say that
   * people erroneously use AF_INET with socket() when they should be using
   * PF_INET.  However, the man pages of some systems indicate that AF_INET
   * is correct; some such as ConvexOS even say that you can use either one.
   * All implementations I've seen define AF_INET and PF_INET to be the same
   * number anyway, so ths point is (hopefully) moot.
d361 16
a376 1

d378 21
a398 21
  {
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);

    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
      log("WinSock not available!\n");
      exit(1);
    }
    if ((wsaData.iMaxSockets - 4) < max_players) {
      max_players = wsaData.iMaxSockets - 4;
    }
    sprintf(buf, "Max players set to %d", max_players);
    log(buf);

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {
      fprintf(stderr, "Error opening network connection: Winsock err #%d\n", WSAGetLastError());
      exit(1);
    }
  }
d400 4
a403 4
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Error creating socket");
    exit(1);
  }
d405 1
a405 1

d407 5
a411 5
  opt = LARGE_BUFSIZE + GARBAGE_SPACE;
  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt SNDBUF");
    exit(1);
  }
d413 1
a413 1

d415 5
a419 5
  opt = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt)) < 0) {
    perror("setsockopt REUSEADDR");
    exit(1);
  }
d421 1
a421 1

d423 24
a446 8
  {
    struct linger ld;

    ld.l_onoff = 0;
    ld.l_linger = 0;
    if (setsockopt(s, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld)) < 0) {
      perror("setsockopt LINGER");
      exit(1);
d448 4
a451 20
  }
#endif

  sa.sin_family = AF_INET;
  sa.sin_port = htons(port);
  sa.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    perror("bind");
    CLOSE_SOCKET(s);
    exit(1);
  }
  nonblock(s);
  listen(s, 5);
  return s;
}


int get_max_players(void)
{
d453 1
a453 1
  return MAX_PLAYERS;
d455 8
a462 8

  int max_descs = 0;
  char *method;

/*
 * First, we'll try using getrlimit/setrlimit.  This will probably work
 * on most systems.
 */
d467 15
a481 15
  {
    struct rlimit limit;

    /* find the limit of file descs */
    method = "rlimit";
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling getrlimit");
      exit(1);
    }
    /* set the current to the maximum */
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("calling setrlimit");
      exit(1);
    }
d483 4
a486 4
    if (limit.rlim_max == RLIM_INFINITY)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else
      max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
d488 1
a488 1
    max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
d490 2
a491 2
  }

d496 3
a498 3
  method = "OPEN_MAX";
  max_descs = OPEN_MAX;		/* Uh oh.. rlimit didn't work, but we have
				 * OPEN_MAX */
d500 17
a516 9
  /*
   * Okay, you don't have getrlimit() and you don't have OPEN_MAX.  Time to
   * use the POSIX sysconf() function.  (See Stevens' _Advanced Programming
   * in the UNIX Environment_).
   */
  method = "POSIX sysconf";
  errno = 0;
  if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
    if (errno == 0)
a517 8
    else {
      perror("Error calling sysconf");
      exit(1);
    }
  }
#else
  /* if everything has failed, we'll just take a guess */
  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
d519 13
a531 13

  /* now calculate max _players_ based on max descs */
  max_descs = MIN(MAX_PLAYERS, max_descs - NUM_RESERVED_DESCS);

  if (max_descs <= 0) {
    sprintf(buf, "Non-positive max player limit!  (Set at %d using %s).",
	    max_descs, method);
    log(buf);
    exit(1);
  }
  sprintf(buf, "Setting player limit to %d using %s.", max_descs, method);
  log(buf);
  return max_descs;
d533 27
a559 44
}



/*
 * game_loop contains the main loop which drives the entire MUD.  It
 * cycles once every 0.10 seconds and is responsible for accepting new
 * new connections, polling existing connections for input, dequeueing
 * output and sending it out to players, and calling "heartbeat" functions
 * such as mobile_activity().
 */
void game_loop(int mother_desc)
{
  fd_set input_set, output_set, exc_set, null_set;
  struct char_data *t_ch = NULL;
  struct timeval last_time, before_sleep, opt_time, process_time, now, timeout;
  char comm[MAX_INPUT_LENGTH];
  struct descriptor_data *d, *next_d;
  int missed_pulses, maxdesc, aliased;

  /* initialize various time values */
  null_time.tv_sec = 0;
  null_time.tv_usec = 0;
  opt_time.tv_usec = OPT_USEC;
  opt_time.tv_sec = 0;
  FD_ZERO(&null_set);

  gettimeofday(&last_time, (struct timezone *) 0);

  /* The Main Loop.  The Big Cheese.  The Top Dog.  The Head Honcho.  The.. */
  while (!circle_shutdown) {

    /* Sleep if we don't have any connections */
    if (descriptor_list == NULL) {
      log("No connections.  Going to sleep.");
      FD_ZERO(&input_set);
      FD_SET(mother_desc, &input_set);
      if (select(mother_desc + 1, &input_set, (fd_set *) 0, (fd_set *) 0, NULL) < 0) {
	if (errno == EINTR)
	  log("Waking up to process signal.");
	else
	  perror("Select coma");
      } else
	log("New connection.  Waking up.");
d561 26
a586 9
    }
    /* Set up the input, output, and exception sets for select(). */
    FD_ZERO(&input_set);
    FD_ZERO(&output_set);
    FD_ZERO(&exc_set);
    FD_SET(mother_desc, &input_set);

    maxdesc = mother_desc;
    for (d = descriptor_list; d; d = d->next) {
d588 2
a589 2
      if (d->descriptor > maxdesc)
	maxdesc = d->descriptor;
d591 37
a627 37
      FD_SET(d->descriptor, &input_set);
      FD_SET(d->descriptor, &output_set);
      FD_SET(d->descriptor, &exc_set);
    }

    /*
     * At this point, we have completed all input, output and heartbeat
     * activity from the previous iteration, so we have to put ourselves
     * to sleep until the next 0.1 second tick.  The first step is to
     * calculate how long we took processing the previous iteration.
     */
    
    gettimeofday(&before_sleep, (struct timezone *) 0); /* current time */
    process_time = timediff(before_sleep, last_time);

    /*
     * If we were asleep for more than one pass, count missed pulses and sleep
     * until we're resynchronized with the next upcoming pulse.
     */
    if (process_time.tv_sec == 0 && process_time.tv_usec < OPT_USEC) {
      missed_pulses = 0;
    } else {
      missed_pulses = process_time.tv_sec * PASSES_PER_SEC;
      missed_pulses += process_time.tv_usec / OPT_USEC;
      process_time.tv_sec = 0;
      process_time.tv_usec = process_time.tv_usec % OPT_USEC;
    }

    /* Calculate the time we should wake up */
    last_time = timeadd(before_sleep, timediff(opt_time, process_time));

    /* Now keep sleeping until that time has come */
    gettimeofday(&now, (struct timezone *) 0);
    timeout = timediff(last_time, now);

    /* go to sleep */
    do {
d629 1
a629 1
      Sleep(timeout.tv_sec * 1000 + timeout.tv_usec / 1000);
d631 36
a666 4
      if (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &timeout) < 0) {
	if (errno != EINTR) {
	  perror("Select sleep");
	  exit(1);
d668 39
a706 47
      }
#endif /* CIRCLE_WINDOWS */
      gettimeofday(&now, (struct timezone *) 0);
      timeout = timediff(last_time, now);
    } while (timeout.tv_usec || timeout.tv_sec);

    /* poll (without blocking) for new input, output, and exceptions */
    if (select(maxdesc + 1, &input_set, &output_set, &exc_set, &null_time) < 0) {
      perror("Select poll");
      return;
    }
    /* If there are new connections waiting, accept them. */
    if (FD_ISSET(mother_desc, &input_set))
      new_descriptor(mother_desc);

    /* kick out the freaky folks in the exception set */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &exc_set)) {
	FD_CLR(d->descriptor, &input_set);
	FD_CLR(d->descriptor, &output_set);
	close_socket(d);
      }
    }

    /* process descriptors with input pending */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &input_set))
	if (process_input(d) < 0)
	  close_socket(d);
    }

    /* process commands we just read from process_input */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;

      if ((--(d->wait) <= 0) && get_from_q(&d->input, comm, &aliased)) {
	if (d->character) {
	  /* reset the idle timer & pull char back from void if necessary */
	  d->character->char_specials.timer = 0;
	  if (!d->connected && GET_WAS_IN(d->character) != NOWHERE) {
	    if (d->character->in_room != NOWHERE)
	      char_from_room(d->character);
	    char_to_room(d->character, GET_WAS_IN(d->character));
	    GET_WAS_IN(d->character) = NOWHERE;
	    act("$n has returned.", TRUE, d->character, 0, 0, TO_ROOM);
d709 22
a730 14
	d->wait = 1;
	d->prompt_mode = 1;


	 /* reversed these top 2 if checks so that you can use the page_string */
 	 /* function in the editor */
 	if (d->showstr_count)	/* reading something w/ pager     */
  	  show_string(d, comm);
 	else if (d->str)		/* writing boards, mail, etc.     */
 	  string_add(d, comm);
	else if (d->connected != CON_PLAYING)	/* in menus, etc. */
	  nanny(d, comm);
	else {			/* else: we're playing normally */
	  if (aliased)		/* to prevent recursive aliases */
a731 3
	  else {
	    if (perform_alias(d, comm))		/* run it through aliasing system */
	      get_from_q(&d->input, comm, &aliased);
a732 2
	  SEND_TO_Q("\r\n",d);
	  command_interpreter(d->character, comm);	/* send it to interpreter */
d734 65
d801 62
a862 23

    /* send queued output out to the operating system (ultimately to user) */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &output_set) && *(d->output))
	if (process_output(d) < 0)
	  close_socket(d);
	else
	  d->prompt_mode = 1;
    }

    /* kick out folks in the CON_CLOSE state */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (STATE(d) == CON_CLOSE)
	close_socket(d);
    }

    /* give each descriptor an appropriate prompt */
    for (d = descriptor_list; d; d = d->next) {
      if (d->prompt_mode) {
	make_prompt(d);
	d->prompt_mode = 0;
d864 2
d867 29
a895 58

    /*
     * Now, we execute as many pulses as necessary--just one if we haven't
     * missed any pulses, or make up for lost time if we missed a few
     * pulses by sleeping for too long.
     */
    missed_pulses++;

    if (missed_pulses <= 0) {
      log("SYSERR: MISSED_PULSES IS NONPOSITIVE!!!");
      missed_pulses = 1;
    }

    /* If we missed more than 30 seconds worth of pulses, forget it */
    if (missed_pulses > (30 * PASSES_PER_SEC)) {
      log("Warning: Missed more than 30 seconds worth of pulses");
      missed_pulses = 30 * PASSES_PER_SEC;
    }

    /* Now execute the heartbeat functions */
    while (missed_pulses--)
      heartbeat(++pulse);

	for (d = descriptor_list; d; d = d->next) {

	if (d->character && d->connected == CON_PLAYING) {
	  t_ch = d->character;


	  if (t_ch->char_specials.action_delays[ACT_DELAY_BASH])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_BASH]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]);

          /* paladin/anti innates */
	  if (t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS])
	    --(t_ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS]);

	  if (t_ch->char_specials.action_delays[ACT_DELAY_BERSERK])
	    --t_ch->char_specials.action_delays[ACT_DELAY_BERSERK];

	  if (t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL])
	    --t_ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL];

	  if ((t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0) ||
	      (t_ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0)) {
	    (void) DisarmCheck(t_ch);
	  }
	  if (t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT] > 0) {
	    --t_ch->char_specials.action_delays[ACT_DELAY_HEADBUTT];
	  }
	  /* ACT_DELAY_DISARM handled in perform_violence() */
d897 8
d906 1
a906 42

   

    /* Update tics for deadlock protection (UNIX only) */
    tics++;
  }
}


void heartbeat(int pulse)
{
  static int mins_since_crashsave = 0;
  void process_events(void);

  dg_global_pulse++;

  process_events();

  if (!(pulse % PULSE_DG_SCRIPT))
    script_trigger_check();

  event_process();

  if (!(pulse % (PASSES_PER_SEC / 2))) 		/* 1/2 second */
    do_gravity_check(); 

  if (!(pulse % PULSE_ZONE))
    zone_update();

  if (!(pulse % (15 * PASSES_PER_SEC)))		/* 15 seconds */
    check_idle_passwords();

  if (!(pulse % (60 * PASSES_PER_SEC)))		/* 1 minute */
    divine_intervention();

  if (!(pulse % PULSE_MOBILE))
    mobile_activity();

  if (!(pulse % PULSE_VIOLENCE)){
    perform_violence();
	update_spell_mem();
    mobile_spec_activity();
d908 13
a920 58
  }

  if (!(pulse % (PULSE_VIOLENCE/2))) {
	perform_mob_violence();
	update_casting();
  }

  if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC))) 
  { 
    update_weather_and_time(1);
    affect_update();
    point_update();
    fflush(player_fl);
	casting_gain();
  }

  /* move the ships as appropriate */
    if(!(pulse % (400)))
	  update_ships();/*_update();*/

  if (auto_save && !(pulse % (60 * PASSES_PER_SEC))) {	/* 1 minute */
    if (++mins_since_crashsave >= autosave_time) {
      mins_since_crashsave = 0;
      Crash_save_all();
      House_save_all();
    }
  }
  if (!(pulse % (5 * 60 * PASSES_PER_SEC)))	/* 5 minutes */
    record_usage();
}


/* ******************************************************************
*  general utility stuff (for local use)                            *
****************************************************************** */

/*
 *  new code to calculate time differences, which works on systems
 *  for which tv_usec is unsigned (and thus comparisons for something
 *  being < 0 fail).  Based on code submitted by ss@@sirocco.cup.hp.com.
 */

/*
 * code to return the time difference between a and b (a-b).
 * always returns a nonnegative value (floors at 0).
 */
struct timeval timediff(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  if (a.tv_sec < b.tv_sec)
    return null_time;
  else if (a.tv_sec == b.tv_sec) {
    if (a.tv_usec < b.tv_usec)
      return null_time;
    else {
      rslt.tv_sec = 0;
      rslt.tv_usec = a.tv_usec - b.tv_usec;
d923 18
a940 44
  } else {			/* a->tv_sec > b->tv_sec */
    rslt.tv_sec = a.tv_sec - b.tv_sec;
    if (a.tv_usec < b.tv_usec) {
      rslt.tv_usec = a.tv_usec + 1000000 - b.tv_usec;
      rslt.tv_sec--;
    } else
      rslt.tv_usec = a.tv_usec - b.tv_usec;
    return rslt;
  }
}

/* add 2 timevals */
struct timeval timeadd(struct timeval a, struct timeval b)
{
  struct timeval rslt;

  rslt.tv_sec = a.tv_sec + b.tv_sec;
  rslt.tv_usec = a.tv_usec + b.tv_usec;

  while (rslt.tv_usec >= 1000000) {
    rslt.tv_usec -= 1000000;
    rslt.tv_sec++;
  }

  return rslt;
}


void record_usage(void)
{
  int sockets_connected = 0, sockets_playing = 0;
  struct descriptor_data *d;
  char buf[256];

  for (d = descriptor_list; d; d = d->next) {
    sockets_connected++;
    if (!d->connected)
      sockets_playing++;
  }

  sprintf(buf, "nusage: %-3d sockets connected, %-3d sockets playing",
	  sockets_connected, sockets_playing);
  log(buf);

d942 8
a949 8
  {
    struct rusage ru;

    getrusage(0, &ru);
    sprintf(buf, "rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
	    ru.ru_utime.tv_sec, ru.ru_stime.tv_sec, ru.ru_maxrss);
    log(buf);
  }
d951 40
a990 40

}



/*
 * Turn off echoing (specific to telnet client)
 */
void echo_off(struct descriptor_data *d)
{
  char off_string[] =
  {
    (char) IAC,
    (char) WILL,
    (char) TELOPT_ECHO,
    (char) 0,
  };

  SEND_TO_Q(off_string, d);
}


/*
 * Turn on echoing (specific to telnet client)
 */
void echo_on(struct descriptor_data *d)
{
  char on_string[] =
  {
    (char) IAC,
    (char) WONT,
    (char) TELOPT_ECHO,
    (char) TELOPT_NAOFFD,
    (char) TELOPT_NAOCRD,
    (char) 0,
  };

  SEND_TO_Q(on_string, d);
}
 
d992 3
a994 3
   Thanks to Krimson DIKUMUD for this code.
   currently siteless MUD.
*/
d1005 2
a1006 2
 
    
d1028 1
a1028 1
  
d1031 1
a1031 1
  
d1040 1
a1040 1
            
d1050 1
a1050 1
            
d1062 1
a1062 1
  	cp++;
d1074 1
a1074 1
   struct char_data *vict = FIGHTING(ch);  
d1081 1
a1081 1
   
d1084 1
a1084 1
  
d1086 1
a1086 1
      
d1144 2
a1145 2
                 (perc >= 100 ? "&2Excellent" :
					 perc >= 88 ? "&3scratches" :
d1148 3
a1150 3
					 perc >= 30 ? "&5nasty wounds" :
					 perc >= 15 ? "&1&bpretty hurt" :
					 perc >= 0 ? "&1awful condition" : "&1bleeding awfully"));
d1166 1
a1166 1
		case 't': /* tank*/
d1170 2
a1171 2
				(perc >= 99 ? "&2Excellent" :
					 perc >= 88 ? "&3scratches" :
d1174 5
a1178 5
					 perc >= 30 ? "&5nasty wounds" :
					 perc >= 15 ? "&1&bpretty hurt" :
					 perc >= 0 ? "&1awful condition" : "&0&1&bbleeding awfully&0"));
		 
			tmp = i;
d1184 1
a1184 1

d1194 1
a1194 1
        
d1213 247
a1459 5

void make_prompt(struct descriptor_data *d)
{
  char prompt[MAX_INPUT_LENGTH];

a1460 65
    /* reversed these top 2 if checks so that page_string() would work in */
    /* the editor */
    if (d->showstr_count) {
    sprintf(prompt,
	    "\r[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
	    d->showstr_page, d->showstr_count);
    write_to_descriptor(d->descriptor, prompt);
     }
    else if (d->str)
      write_to_descriptor(d->descriptor, "] ");
    else if (!d->connected) {
	  write_to_descriptor(d->descriptor,parse_color(prompt_str(d->character),d));
  /*  char prompt[MAX_INPUT_LENGTH];

    *prompt = '\0';

    if (GET_INVIS_LEV(d->character))
      sprintf(prompt, "i%d ", GET_INVIS_LEV(d->character));

    if (PRF_FLAGGED(d->character, PRF_DISPHP))
      sprintf(prompt, "%s%dH ", prompt, GET_HIT(d->character));

    if (GET_MAX_MANA(tch) != 0)
     if GET_MAX_MANA(tch) > 0)
     if (GET_MANA(tch) > 0)
    if (PRF_FLAGGED(d->character, PRF_DISPMANA))
      sprintf(prompt, "%s%dM ", prompt, GET_MANA(d->character));

    if (PRF_FLAGGED(d->character, PRF_DISPMOVE))
      sprintf(prompt, "%s%dV ", prompt, GET_MOVE(d->character));

    strcat(prompt, "> ");
    write_to_descriptor(d->descriptor, prompt);*/
  }
}


void write_to_q(char *txt, struct txt_q *queue, int aliased)
{
  struct txt_block *new;

  CREATE(new, struct txt_block, 1);
  CREATE(new->text, char, strlen(txt) + 1);
  strcpy(new->text, txt);
  new->aliased = aliased;

  /* queue empty? */
  if (!queue->head) {
    new->next = NULL;
    queue->head = queue->tail = new;
  } else {
    queue->tail->next = new;
    queue->tail = new;
    new->next = NULL;
  }
}



int get_from_q(struct txt_q *queue, char *dest, int *aliased)
{
  struct txt_block *tmp;

  /* queue empty? */
  if (!queue->head)
a1461 22

  tmp = queue->head;
  strcpy(dest, queue->head->text);
  *aliased = queue->head->aliased;
  queue->head = queue->head->next;

  free(tmp->text);
  free(tmp);

  return 1;
}



/* Empty the queues before closing connection */
void flush_queues(struct descriptor_data *d)
{
  int dummy;

  if (d->large_outbuf) {
    d->large_outbuf->next = bufpool;
    bufpool = d->large_outbuf;
d1463 112
a1574 222
  while (get_from_q(&d->input, buf2, &dummy));
}

/* Add a new string to a player's output queue */

void write_to_output(char *txt, struct descriptor_data *t)
{
  int size;
  char *new_txt;

  new_txt = parse_color(txt, t);

  size = strlen(new_txt);

  /* if we're in the overflow state already, ignore this new output */
  if (t->bufptr < 0)
    return;

  /* if we have enough space, just write to buffer and that's it! */
  if (t->bufspace >= size) {
    strcpy(t->output + t->bufptr, new_txt);
    t->bufspace -= size;
    t->bufptr += size;
    free(new_txt);
    return;
  }
  /*
   * If we're already using the large buffer, or if even the large buffer
   * is too small to handle this new text, chuck the text and switch to the
   * overflow state.
   */
  if (t->large_outbuf || ((size + strlen(t->output)) > LARGE_BUFSIZE)) {
    t->bufptr = -1;
    buf_overflows++;
    free(new_txt);
    return;
  }
  buf_switches++;

  /* if the pool has a buffer in it, grab it */
  if (bufpool != NULL) {
    t->large_outbuf = bufpool;
    bufpool = bufpool->next;
  } else {                      /* else create a new one */
    CREATE(t->large_outbuf, struct txt_block, 1);
    CREATE(t->large_outbuf->text, char, LARGE_BUFSIZE);
    buf_largecount++;
  }

  strcpy(t->large_outbuf->text, t->output);     /* copy to big buffer */
  t->output = t->large_outbuf->text;    /* make big buffer primary */
  strcat(t->output, new_txt);   /* now add new text */

  /* calculate how much space is left in the buffer */
  t->bufspace = LARGE_BUFSIZE - 1 - strlen(t->output);

  /* set the pointer for the next write */
  t->bufptr = strlen(t->output);

  free(new_txt);
}



/* ******************************************************************
*  socket handling                                                  *
****************************************************************** */


int new_descriptor(int s) {
  socket_t desc;
  int sockets_connected = 0;
  unsigned long addr;
  int i;
  static int last_desc = 0;	/* last descriptor number */
  struct descriptor_data *newd;
  struct sockaddr_in peer;
  struct hostent *from;
  extern char *ANSI;

  /* accept the new connection */
  i = sizeof(peer);
  if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
    perror("accept");
    return -1;
  }
  /* keep it from blocking */
  nonblock(desc);

  /* make sure we have room for it */
  for (newd = descriptor_list; newd; newd = newd->next)
    sockets_connected++;

  if (sockets_connected >= max_players) {
    write_to_descriptor(desc, "Sorry, Hubis is full right now... please try again later!\r\n");
    CLOSE_SOCKET(desc);
    return 0;
  }
  /* create a new descriptor */
  CREATE(newd, struct descriptor_data, 1);
  memset((char *) newd, 0, sizeof(struct descriptor_data));

  /* find the sitename */
  if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
				      sizeof(peer.sin_addr), AF_INET))) {

    /* resolution failed */
    if (!nameserver_is_slow)
      perror("gethostbyaddr");

    /* find the numeric site address */
    addr = ntohl(peer.sin_addr.s_addr);
    sprintf(newd->host, "%03u.%03u.%03u.%03u", (int) ((addr & 0xFF000000) >> 24),
     (int) ((addr & 0x00FF0000) >> 16), (int) ((addr & 0x0000FF00) >> 8),
	    (int) ((addr & 0x000000FF)));
  } else {
    strncpy(newd->host, from->h_name, HOST_LENGTH);
    *(newd->host + HOST_LENGTH) = '\0';
  }

  /* determine if the site is banned */
  if (isbanned(newd->host) == BAN_ALL) {
    CLOSE_SOCKET(desc);
    sprintf(buf2, "Connection attempt denied from [%s]", newd->host);
    mudlog(buf2, CMP, LVL_GOD, TRUE);
    free(newd);
    return 0;
  }
#if 0
  /* Log new connections - probably unnecessary, but you may want it */
  sprintf(buf2, "New connection from [%s]", newd->host);
  mudlog(buf2, CMP, LVL_GOD, FALSE);
#endif

  /* initialize descriptor data */
  newd->descriptor = desc;
  newd->connected = CON_QANSI;
  newd->idle_tics = 0;
  newd->wait = 1;
  newd->output = newd->small_outbuf;
  newd->bufspace = SMALL_BUFSIZE - 1;
  newd->next = descriptor_list;
  newd->login_time = time(0);

  if (++last_desc == 1000)
    last_desc = 1;
  newd->desc_num = last_desc;

  /* prepend to list */
  descriptor_list = newd;

  SEND_TO_Q(ANSI, newd);

  return 0;
}



int process_output(struct descriptor_data *t)
{
  static char i[LARGE_BUFSIZE + GARBAGE_SPACE];
  static int result;

  /* we may need this \r\n for later -- see below */
  strcpy(i, "\r\n");

  /* now, append the 'real' output */
  strcpy(i + 2, t->output);

  /* if we're in the overflow state, notify the user */
  if (t->bufptr < 0)
    strcat(i, "**OVERFLOW**");

  /* add the extra CRLF if the person isn't in compact mode */
  if (!t->connected && t->character && !PRF_FLAGGED(t->character, PRF_COMPACT))
    strcat(i + 2, "\r\n");

  /*
   * now, send the output.  If this is an 'interruption', use the prepended
   * CRLF, otherwise send the straight output sans CRLF.
   */
  if (!t->prompt_mode)		/* && !t->connected) */
    result = write_to_descriptor(t->descriptor, i);
  else
    result = write_to_descriptor(t->descriptor, i + 2);

  /* handle snooping: prepend "% " and send to snooper */
  if (t->snoop_by) {
    SEND_TO_Q("% ", t->snoop_by);
    SEND_TO_Q(t->output, t->snoop_by);
    SEND_TO_Q("%%", t->snoop_by);
  }
  /*
   * if we were using a large buffer, put the large buffer on the buffer pool
   * and switch back to the small one
   */
  if (t->large_outbuf) {
    t->large_outbuf->next = bufpool;
    bufpool = t->large_outbuf;
    t->large_outbuf = NULL;
    t->output = t->small_outbuf;
  }
  /* reset total bufspace back to that of a small buffer */
  t->bufspace = SMALL_BUFSIZE - 1;
  t->bufptr = 0;
  *(t->output) = '\0';

  return result;
}



int write_to_descriptor(socket_t desc, char *txt)
{
  int total, bytes_written;

  total = strlen(txt);

  do {
#ifdef CIRCLE_WINDOWS
    if ((bytes_written = send(desc, txt, total, 0)) < 0) {
      if (WSAGetLastError() == WSAEWOULDBLOCK)
d1576 1
a1576 1
    if ((bytes_written = write(desc, txt, total)) < 0) {
d1578 2
a1579 2
      if (errno == EWOULDBLOCK)
	errno = EAGAIN;
d1581 1
a1581 1
      if (errno == EAGAIN)
d1583 32
a1614 77
	log("process_output: socket write would block, about to close");
      else
	perror("Write to socket");
      return -1;
    } else {
      txt += bytes_written;
      total -= bytes_written;
    }
  } while (total > 0);

  return 0;
}


/*
 * ASSUMPTION: There will be no newlines in the raw input buffer when this
 * function is called.  We must maintain that before returning.
 */
int process_input(struct descriptor_data *t)
{
  int buf_length, bytes_read, space_left, failed_subst;
  char *ptr, *read_point, *write_point, *nl_pos = NULL;
  char tmp[MAX_INPUT_LENGTH + 8];

  /* first, find the point where we left off reading data */
  buf_length = strlen(t->inbuf);
  read_point = t->inbuf + buf_length;
  space_left = MAX_RAW_INPUT_LENGTH - buf_length - 1;

  do {
    if (space_left <= 0) {
      log("process_input: about to close connection: input overflow");
      return -1;
    }
#ifdef CIRCLE_WINDOWS
    if ((bytes_read = recv(t->descriptor, read_point, space_left, 0)) < 0) {
      if (WSAGetLastError() != WSAEWOULDBLOCK) {
#else
    if ((bytes_read = read(t->descriptor, read_point, space_left)) < 0) {
#ifdef EWOULDBLOCK
      if (errno == EWOULDBLOCK)
	errno = EAGAIN;
#endif /* EWOULDBLOCK */
      if (errno != EAGAIN) {
#endif /* CIRCLE_WINDOWS */
	perror("process_input: about to lose connection");
	return -1;		/* some error condition was encountered on
				 * read */
      } else
	return 0;		/* the read would have blocked: just means no
				 * data there but everything's okay */
    } else if (bytes_read == 0) {
      log("EOF on socket read (connection broken by peer)");
      return -1;
    }
    /* at this point, we know we got some data from the read */

    *(read_point + bytes_read) = '\0';	/* terminate the string */

    /* search for a newline in the data we just read */
    for (ptr = read_point; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
	nl_pos = ptr;

    read_point += bytes_read;
    space_left -= bytes_read;

/*
 * on some systems such as AIX, POSIX-standard nonblocking I/O is broken,
 * causing the MUD to hang when it encounters input not terminated by a
 * newline.  This was causing hangs at the Password: prompt, for example.
 * I attempt to compensate by always returning after the _first_ read, instead
 * of looping forever until a read returns -1.  This simulates non-blocking
 * I/O because the result is we never call read unless we know from select()
 * that data is ready (process_input is only called if select indicates that
 * this descriptor is in the read set).  JE 2/23/95.
 */
d1616 1
a1616 1
  } while (nl_pos == NULL);
d1618 4
a1621 4
  } while (0);

  if (nl_pos == NULL)
    return 0;
d1623 237
a1859 237

  /*
   * okay, at this point we have at least one newline in the string; now we
   * can copy the formatted data to a new array for further processing.
   */

  read_point = t->inbuf;

  while (nl_pos != NULL) {
    write_point = tmp;
    space_left = MAX_INPUT_LENGTH - 1;

    for (ptr = read_point; (space_left > 0) && (ptr < nl_pos); ptr++) {
      if (*ptr == '\b') {	/* handle backspacing */
	if (write_point > tmp) {
	  if (*(--write_point) == '$') {
	    write_point--;
	    space_left += 2;
	  } else
	    space_left++;
	}
      } else if (isascii(*ptr) && isprint(*ptr)) {
	if ((*(write_point++) = *ptr) == '$') {		/* copy one character */
	  *(write_point++) = '$';	/* if it's a $, double it */
	  space_left -= 2;
	} else
	  space_left--;
      }
    }

    *write_point = '\0';

    if ((space_left <= 0) && (ptr < nl_pos)) {
      char buffer[MAX_INPUT_LENGTH + 64];

      sprintf(buffer, "Line too long.  Truncated to:\r\n%s\r\n", tmp);
      if (write_to_descriptor(t->descriptor, buffer) < 0)
	return -1;
    }
    if (t->snoop_by) {
      SEND_TO_Q("% ", t->snoop_by);
      SEND_TO_Q(tmp, t->snoop_by);
      SEND_TO_Q("\r\n", t->snoop_by);
    }
    failed_subst = 0;

    if (*tmp == '!')
      strcpy(tmp, t->last_input);
    else if (*tmp == '^') {
      if (!(failed_subst = perform_subst(t, t->last_input, tmp)))
	strcpy(t->last_input, tmp);
    } else
      strcpy(t->last_input, tmp);

    if (!failed_subst)
      write_to_q(tmp, &t->input, 0);

    /* find the end of this line */
    while (ISNEWL(*nl_pos))
      nl_pos++;

    /* see if there's another newline in the input buffer */
    read_point = ptr = nl_pos;
    for (nl_pos = NULL; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
	nl_pos = ptr;
  }

  /* now move the rest of the buffer up to the beginning for the next pass */
  write_point = t->inbuf;
  while (*read_point)
    *(write_point++) = *(read_point++);
  *write_point = '\0';

  return 1;
}



/*
 * perform substitution for the '^..^' csh-esque syntax
 * orig is the orig string (i.e. the one being modified.
 * subst contains the substition string, i.e. "^telm^tell"
 */
int perform_subst(struct descriptor_data *t, char *orig, char *subst)
{
  char new[MAX_INPUT_LENGTH + 5];

  char *first, *second, *strpos;

  /*
   * first is the position of the beginning of the first string (the one
   * to be replaced
   */
  first = subst + 1;

  /* now find the second '^' */
  if (!(second = strchr(first, '^'))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return 1;
  }
  /* terminate "first" at the position of the '^' and make 'second' point
   * to the beginning of the second string */
  *(second++) = '\0';

  /* now, see if the contents of the first string appear in the original */
  if (!(strpos = strstr(orig, first))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return 1;
  }
  /* now, we construct the new string for output. */

  /* first, everything in the original, up to the string to be replaced */
  strncpy(new, orig, (strpos - orig));
  new[(strpos - orig)] = '\0';

  /* now, the replacement string */
  strncat(new, second, (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* now, if there's anything left in the original after the string to
   * replaced, copy that too. */
  if (((strpos - orig) + strlen(first)) < strlen(orig))
    strncat(new, strpos + strlen(first), (MAX_INPUT_LENGTH - strlen(new) - 1));

  /* terminate the string in case of an overflow from strncat */
  new[MAX_INPUT_LENGTH - 1] = '\0';
  strcpy(subst, new);

  return 0;
}



void close_socket(struct descriptor_data *d)
{
  char buf[128];
  struct descriptor_data *temp;
  long target_idnum = -1;

  CLOSE_SOCKET(d->descriptor);
  flush_queues(d);

  /* Forget snooping */
  if (d->snooping)
    d->snooping->snoop_by = NULL;

  if (d->snoop_by) {
    SEND_TO_Q("Your victim is no longer among us.\r\n", d->snoop_by);
    d->snoop_by->snooping = NULL;
  }

   
  /*. Kill any OLC stuff .*/
  switch(d->connected)
  { case CON_OEDIT:
    case CON_REDIT:
    case CON_ZEDIT:
    case CON_MEDIT:
    case CON_SEDIT:
	case CON_TRIGEDIT:
      cleanup_olc(d, CLEANUP_ALL);
    default:
      break;
  }
 
  if (d->character) {
    target_idnum = GET_IDNUM(d->character);
    /*
     * Plug memory leak, from Eric Green.
     */
    if (PLR_FLAGGED(d->character, PLR_MAILING) && d->str) {
      if (*(d->str))
        free(*(d->str));
      free(d->str);
    }
    if (d->connected == CON_PLAYING) {
      save_char(d->character, NOWHERE);
      act("$n has lost $s link.", TRUE, d->character, 0, 0, TO_ROOM);
      sprintf(buf, "Closing link to: %s.", GET_NAME(d->character));
      mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
      d->character->desc = NULL;
    } else {/*markquit*/
      sprintf(buf, "Losing player: %s.",
	      GET_NAME(d->character) ? GET_NAME(d->character) : "<null>");
      mudlog(buf, CMP, LVL_IMMORT, TRUE);
      free_char(d->character);
    }
  } else
    mudlog("Losing descriptor without char.", CMP, LVL_IMMORT, TRUE);

  /* JE 2/22/95 -- part of my unending quest to make switch stable */
  if (d->original && d->original->desc)
    d->original->desc = NULL;

  REMOVE_FROM_LIST(d, descriptor_list, next);

  if (d->showstr_head)
    free(d->showstr_head);
  if (d->showstr_count)
    free(d->showstr_vector);
  if (d->storage)
	  free(d->storage);

  free(d);
}



void check_idle_passwords(void)
{
  struct descriptor_data *d, *next_d;

  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME)
      continue;
    if (!d->idle_tics) {
      d->idle_tics++;
      continue;
    } else {
      echo_on(d);
      SEND_TO_Q("\r\nTimed out... goodbye.\r\n", d);
      STATE(d) = CON_CLOSE;
    }
  }
}



/*
 * I tried to universally convert Circle over to POSIX compliance, but
 * alas, some systems are still straggling behind and don't have all the
 * appropriate defines.  In particular, NeXT 2.x defines O_NDELAY but not
 * O_NONBLOCK.  Krusty old NeXT machines!  (Thanks to Michael Jones for
 * this and various other NeXT fixes.)
 */

d1861 9
a1869 9

void nonblock(socket_t s)
{
  long val;

  val = 1;
  ioctlsocket(s, FIONBIO, &val);
}

d1871 1
a1871 1

d1875 73
a1947 73

void nonblock(socket_t s)
{
  int flags;

  flags = fcntl(s, F_GETFL, 0);
  flags |= O_NONBLOCK;
  if (fcntl(s, F_SETFL, flags) < 0) {
    perror("Fatal error executing nonblock (comm.c)");
    exit(1);
  }
}


/* ******************************************************************
*  signal-handling functions (formerly signals.c)                   *
****************************************************************** */


RETSIGTYPE checkpointing()
{
  if (!tics) {
    log("SYSERR: CHECKPOINT shutdown: tics not updated");
    abort();
  } else
    tics = 0;
}


RETSIGTYPE reread_wizlists()
{
  void reboot_wizlists(void);

  mudlog("Signal received - rereading wizlists.", CMP, LVL_IMMORT, TRUE);
  reboot_wizlists();
}


RETSIGTYPE unrestrict_game()
{
  extern struct ban_list_element *ban_list;
  extern int num_invalid;

  mudlog("Received SIGUSR2 - completely unrestricting game (emergent)",
	 BRF, LVL_IMMORT, TRUE);
  ban_list = NULL;
  restrict = 0;
  num_invalid = 0;
}


RETSIGTYPE hupsig()
{
  log("Received SIGHUP, SIGINT, or SIGTERM.  Shutting down...");
  exit(0);			/* perhaps something more elegant should
				 * substituted */
}


/*
 * This is an implementation of signal() using sigaction() for portability.
 * (sigaction() is POSIX; signal() is not.)  Taken from Stevens' _Advanced
 * Programming in the UNIX Environment_.  We are specifying that all system
 * calls _not_ be automatically restarted for uniformity, because BSD systems
 * do not restart select(), even if SA_RESTART is used.
 *
 * Note that NeXT 2.x is not POSIX and does not have sigaction; therefore,
 * I just define it to be the old signal.  If your system doesn't have
 * sigaction either, you can use the same fix.
 *
 * SunOS Release 4.0.2 (sun386) needs this too, according to Tim Aldric.
 */

d1951 7
a1957 7
sigfunc *my_signal(int signo, sigfunc * func)
{
  struct sigaction act, oact;

  act.sa_handler = func;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
d1959 1
a1959 1
  act.sa_flags |= SA_INTERRUPT;	/* SunOS */
d1961 6
a1966 6

  if (sigaction(signo, &act, &oact) < 0)
    return SIG_ERR;

  return oact.sa_handler;
}
d1968 4
a1971 4


void signal_setup(void)
{
d1973 1
a1973 1
  struct itimerval itime;
d1975 16
a1990 16
  struct timeval interval;

  /* user signal 1: reread wizlists.  Used by autowiz system. */
  my_signal(SIGUSR1, reread_wizlists);

  /*
   * user signal 2: unrestrict game.  Used for emergencies if you lock
   * yourself out of the MUD somehow.  (Duh...)
   */
  my_signal(SIGUSR2, unrestrict_game);

  /*
   * set up the deadlock-protection so that the MUD aborts itself if it gets
   * caught in an infinite loop for more than 3 minutes.  Doesn't work with
   * OS/2.
   */
d1992 15
a2006 15
  interval.tv_sec = 180;
  interval.tv_usec = 0;
  itime.it_interval = interval;
  itime.it_value = interval;
  setitimer(ITIMER_VIRTUAL, &itime, NULL);
  my_signal(SIGVTALRM, checkpointing);
#endif

  /* just to be on the safe side: */
  my_signal(SIGHUP, hupsig);
  my_signal(SIGINT, hupsig);
  my_signal(SIGTERM, hupsig);
  my_signal(SIGPIPE, SIG_IGN);
  my_signal(SIGALRM, SIG_IGN);

d2009 1
a2009 1
  my_signal(SIGABRT, hupsig);
d2012 1
a2012 1
  my_signal(SIGFPE, hupsig);
d2015 1
a2015 1
  my_signal(SIGILL, hupsig);
d2018 1
a2018 1
  my_signal(SIGSEGV, hupsig);
d2021 3
a2023 3

}

d2025 37
a2061 37


/* ****************************************************************
*       Public routines for system-to-player-communication        *
**************************************************************** */

void send_to_char(char *messg, struct char_data *ch)
{
  if (ch->desc && messg)
    SEND_TO_Q(messg, ch->desc);
}

void send_to_zone(char *messg, int zone_rnum)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && i->character && AWAKE(i->character) &&
        (IN_ROOM(i->character) != NOWHERE) &&
(world[IN_ROOM(i->character)].zone == zone_rnum))
      SEND_TO_Q(messg, i);
}


void send_to_all(char *messg)
{
  struct descriptor_data *i;

  if (messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected)
	SEND_TO_Q(messg, i);
}

d2063 32
a2094 32

void send_to_outdoor(char *messg, int zonenum)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
  {
    if (!i->connected && i->character && AWAKE(i->character) &&
	OUTSIDE(i->character) && (GET_ZONE(i->character) == zonenum) && (STATE(i) == CON_PLAYING))
      SEND_TO_Q(messg, i);
  }
}



void send_to_room(char *messg, int room)
{
  struct char_data *i;

  if (messg)
    for (i = world[room].people; i; i = i->next_in_room)
      if (i->desc)
	SEND_TO_Q(messg, i->desc);
}



char *ACTNULL = "<NULL>";

d2097 22
a2118 22


/* higher-level communication: the act() function */
void perform_act(char *orig, struct char_data *ch, struct obj_data *obj,
		 void *vict_obj, struct char_data *to)
{
  register char *i = NULL, *buf;
  static char lbuf[MAX_STRING_LENGTH];
  struct char_data *dg_victim = NULL;
  struct obj_data *dg_target = NULL; 
  char *dg_arg = NULL;
  char spare[40];
  int sptr = 0;
  buf = lbuf;


	for (;;) 
	{		if (*orig == '&')
		{	  
			sptr--;
			sptr--;
		}
d2121 116
a2236 87
		{			
			switch (*(++orig)) 
			{
			case 'n':
				if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
				{
					i = "someone";
					break;
				}	
				if (IS_NPC(ch)) 
				{					
					i = PERS(ch, to);
/*i = CAP(PERS(ch, to));*/					break;				
				}	
				if (GET_LEVEL(to) >= LVL_IMMORT) 
				{
					i = PERS(ch, to);
					break;
				}	   /*rest of code is mortal only*/
if (GET_RACE_ALIGN(ch) == (GET_RACE_ALIGN(to) & (!PRF_FLAGGED(ch, PRF_NONAME))))			
	{
		i = PERS(ch, to);
		if (sptr == 1)
	;/*		i = CAP(i);
	*/}else 
	{
	if ((GET_LEVEL(ch) > 70) & ((!PRF_FLAGGED(ch, PRF_NONAME))))		
		i = PERS(ch, to);	
	else 
	{
	if (CAN_SEE(to, ch) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))) 
	{
		if (sptr == 1) 
		{
			if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
				sprintf(spare, "An %s", RACE_ABBR(ch));	
			else
				sprintf(spare, "A %s", RACE_ABBR(ch));
			i = spare;
  		} else {			
	if ((GET_RACE(ch) == RACE_OGRE) || (GET_RACE(ch) == RACE_ORC))
		 sprintf(spare, "an %s", RACE_ABBR(ch));
			 else
		sprintf(spare, "a %s", RACE_ABBR(ch));			
		i = spare;
 		}
	}
	else
	if ((sptr) == 1)		
		i = "Someone";
	else
		i = "someone";
	}	
}	  /*i = PERS(ch, to);	*/break;


      case 'N':
if (IS_NPC(to)) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
break;
}
if (IS_NPC((struct char_data *) vict_obj)) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	dg_victim = (struct char_data *) vict_obj;
break;
	  }

if (GET_LEVEL(to) >= LVL_IMMORT) {
	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	dg_victim = (struct char_data *) vict_obj;
break;
}	

   /*rest of code is mortal only...Buru!!!*/

if (GET_RACE_ALIGN((struct char_data *) vict_obj) == (GET_RACE_ALIGN(to) &
!PRF_FLAGGED(((struct char_data *) vict_obj), PRF_NONAME))) {
CHECK_NULL(vict_obj, PERS(((struct char_data *) vict_obj), to));
dg_victim = (struct char_data *) vict_obj;
} else {
	if (CAN_SEE(ch, (struct char_data *) vict_obj) && (!ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))) {
		if ((sptr) == 1) {
			if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE(to) == RACE_ORC)){
			 sprintf(spare, "An %s", RACE_ABBR((struct char_data *) vict_obj));
			 dg_victim = (struct char_data *) vict_obj;
			}else
			sprintf(spare, "A %s", RACE_ABBR((struct char_data *) vict_obj));
d2238 6
a2243 7
			i = spare;  
		} else {
			if ((GET_RACE((struct char_data *) vict_obj) == RACE_OGRE) || (GET_RACE((struct char_data *) vict_obj) == RACE_ORC)){
			 sprintf(spare, "an %s", RACE_ABBR((struct char_data *) vict_obj));
			 dg_victim = (struct char_data *) vict_obj;
			}else
			sprintf(spare, "a %s", RACE_ABBR((struct char_data *) vict_obj));
d2245 44
a2288 1
			i = spare; 
d2290 15
a2304 86
	}
	else
		i = "someone";
}	  	  
	  /*	CHECK_NULL(vict_obj, PERS((struct char_data *) vict_obj, to));
	*/break;
      case 'm':
	i = HMHR(ch);
	break;
      case 'M':
	CHECK_NULL(vict_obj, HMHR((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 's':
	i = HSHR(ch);
	break;
      case 'S':
	CHECK_NULL(vict_obj, HSHR((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 'e':
	i = HSSH(ch);
	break;
      case 'E':
	CHECK_NULL(vict_obj, HSSH((struct char_data *) vict_obj));
	dg_victim = (struct char_data *) vict_obj;
	break;
      case 'o':
	CHECK_NULL(obj, OBJN(obj, to));
	break;
      case 'O':
	CHECK_NULL(vict_obj, OBJN((struct obj_data *) vict_obj, to));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'p':
	CHECK_NULL(obj, OBJS(obj, to));
	break;
      case 'P':
	CHECK_NULL(vict_obj, OBJS((struct obj_data *) vict_obj, to));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'a':
	CHECK_NULL(obj, SANA(obj));
	break;
      case 'A':
	CHECK_NULL(vict_obj, SANA((struct obj_data *) vict_obj));
	dg_target = (struct obj_data *) vict_obj;
	break;
      case 'T':
	CHECK_NULL(vict_obj, (char *) vict_obj);
	dg_arg = (char *) vict_obj;
	break;
      case 'F':
	CHECK_NULL(vict_obj, fname((char *) vict_obj));
	break;
      case '$':
	i = "$";
	break;
      default:
	log("SYSERR: Illegal $-code to act():");
	strcpy(buf1, "SYSERR: ");
	strcat(buf1, orig);
	log(buf1);
	break;
      }
	  while ((*buf = *(i++)))
	buf++;
      orig++;
    } else if (!(*(buf++) = *(orig++)))
      break;
  }

  *(--buf) = '\r';
  *(++buf) = '\n';
  *(++buf) = '\0';

  if (to->desc){
   SEND_TO_Q("&0", to->desc);
   SEND_TO_Q(CAP(lbuf), to->desc);
  }
  if ((IS_NPC(to) && dg_act_check) && (to != ch))
    act_mtrigger(to, lbuf, ch, dg_victim, obj, dg_target, dg_arg);
  if (MOBTrigger)
    mprog_act_trigger(lbuf, to, ch, obj, vict_obj);
}

d2309 47
a2355 290
void act(char *str, int hide_invisible, struct char_data *ch,
	 struct obj_data *obj, void *vict_obj, int type)
{
  struct char_data *to = NULL;
  static int sleep;

 if (!str) {
     MOBTrigger = TRUE;
    return;
  } 

 
  if (!(dg_act_check = !(type & DG_NO_TRIG)))
    type &= ~DG_NO_TRIG;

  /*
   * Warning: the following TO_SLEEP code is a hack.
   * 
   * I wanted to be able to tell act to deliver a message regardless of sleep
   * without adding an additional argument.  TO_SLEEP is 128 (a single bit
   * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
   * command.  It's not legal to combine TO_x's with each other otherwise.
   */

  /* check if TO_SLEEP is there, and remove it if it is. */
  if ((sleep = (type & TO_SLEEP)))
    type &= ~TO_SLEEP;


  if (type == TO_CHAR) {
    if (ch && SENDOK(ch))
      perform_act(str, ch, obj, vict_obj, ch);
	MOBTrigger = TRUE;
    return;
  }
  if (type == TO_VICT) {
    if ((to = (struct char_data *) vict_obj) && SENDOK(to)) 
  //  if (to == NULL)
  //  return;
  //  if (!to)
  //  return;  /* if a tree falls in the forest... Banyal cut on some bandwidth */ 
  //  /* and lets kill soem bugs while we here Banyal*/
  // if (to->desc && (IS_NPC(to) || !to->player_specials->ignored ||
 // (to->player_specials->ignored != ch)) && ((to != ch))) 
     perform_act(str, ch, obj, vict_obj, to);
	MOBTrigger = TRUE;
    return;
   
  }
  /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */

   if ((ch))
   {
      if ((ch->in_room != NOWHERE))
         to = world[ch->in_room].people;
      else 
         log("SYSERR: no valid target to act()!");
   } 
   else if ((obj != NULL))
   {
      if ((obj->in_room != NOWHERE))
      { 
         if ((obj->in_room) != 0) 
            to = world[obj->in_room].people;
         else
         {
            log("SYSERR: no valid target to act()!");
            sprintf(buf, "Error in ACT, obj->in_room = 0, %s, %d", obj->name, GET_OBJ_VNUM(obj));
            mudlog(buf, CMP, LVL_GOD, FALSE);
            return;
         }
      }
      else
      {/*if here then NO ch and NO obj ==>error*/
         log("SYSERR: no valid target to act()!");
         sprintf(buf, "Error in ACT, obj->in_room = -1, %s, %d", obj->name, GET_OBJ_VNUM(obj));
         mudlog(buf, CMP, LVL_GOD, FALSE);
         return;
      }
   } 
   else 
   {
      log("SYSERR: no valid target to act()!");
      return;
   }

  for (; to; to = to->next_in_room)
    if (SENDOK(to) && !(hide_invisible && ch && !CAN_SEE(to, ch)) &&
	(to != ch) && (type == TO_ROOM || (to != vict_obj)))
      perform_act(str, ch, obj, vict_obj, to);
  MOBTrigger = TRUE;
}


int count_chars(char *txt, char character)
{
   int i, cnt = 0;

   for(i = 0; txt[i]; i++)
      if(txt[i] == character)
         cnt++;

   return cnt;
}

char *parse_color(char *txt, struct descriptor_data *t)
{
   char *new_txt;
   char *toret;
   register int i, j = 0;

   i = count_chars(txt, '&'); /* count how many control-chars there
                                 are in the string */


   new_txt = malloc(i * 5 + strlen(txt) + 5); /* no ansi-escape code is larger
                                                 than 5 bytes so a 5 * times
                                                 the '&' appears + strlen(txt)
                                                 + 1 character big buffer
                                                 should be enough */
   /* This fixes that ANNOYING color bleeding from prompt! -Nechtrous */
   if(t->character) {
     strcpy(new_txt + j, CCNRM(t->character, C_NRM));
     if(clr(t->character, C_NRM))
       j += 4;
   }
   /* the parser.. Huge but fast */
   for(i = 0; txt[i]; i++)
   {
      if(txt[i] == '&')
      {
         i++;
         if(!(t->character)) {
            new_txt[j] = txt[i]; j++;
 	 }
         else
         switch(txt[i])
         {
            case '0' : strcpy(new_txt + j, CCNRM(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case '1' : strcpy(new_txt + j, CCRED(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '2' : strcpy(new_txt + j, CCGRN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '3' : strcpy(new_txt + j, CCYEL(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '4' : strcpy(new_txt + j, CCBLU(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '5' : strcpy(new_txt + j, CCMAG(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '6' : strcpy(new_txt + j, CCCYN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '7' : strcpy(new_txt + j, CCWHT(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '8' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case '9' : strcpy(new_txt + j, CCBLK(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'u' : strcpy(new_txt + j, CCUND(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case 'd' : strcpy(new_txt + j, CCDAR(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;
            case 'b' : strcpy(new_txt + j, CCBLD(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 4;
            break;

            case 'R' : strcpy(new_txt + j, CCBRED(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'G' : strcpy(new_txt + j, CCBGRN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'Y' : strcpy(new_txt + j, CCBYEL(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'B' : strcpy(new_txt + j, CCBBLU(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'M' : strcpy(new_txt + j, CCBMAG(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'C' : strcpy(new_txt + j, CCBCYN(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'W' : strcpy(new_txt + j, CCBWHT(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case 'S' : strcpy(new_txt + j, CCBBLK(t->character, C_NRM));
            if(clr(t->character, C_NRM))
               j += 5;
            break;
            case '&' : new_txt[j] = txt[i]; j++; break;

            default:  break;
         }

      }
      else
      {
         new_txt[j] = txt[i]; j++;
      }
   }

   new_txt[j] = '\0'; /* terminate the string */
   toret = strdup(new_txt); /* create a new string with no eventual memoryloss */
   free(new_txt); /* free the old buffer */

   return toret; /* the colorized buffer */
}

/*  This function scans every room of the mud and checks for IN_FLIGHT */
/*  once IN_FLIGHT rooms are found, every non flying obj, PC, NPC */
/*  falls to the earth and takes damage according to size and number */
/*  of rooms fallen.   */

/*  --Fingon */


void do_gravity_check(void)
{
  struct obj_data *i, *j;
  struct char_data *ch;
  int was_in, zn, rn, rrn, k;
  int riding = FALSE, ridden_by = FALSE, flying = FALSE;
  char gravbuf[MAX_STRING_LENGTH];

  /*  Cycle through each zone */

  for (zn = 0; zn <= top_of_zone_table; zn++) {
    if (zone_table[zn].top) {

      /*  Cycle through each room in zone */

      for (rn = (zone_table[zn].number * 100); rn <= zone_table[zn].top; rn++) {
	if (real_room(rn) != NOWHERE) {	
	  rrn = real_room(rn);
          if (world[rrn].sector_type == SECT_FLYING) {

	    /*  start the gravity check for objects */

	    i = world[rrn].contents;
            while(i) {

	      /*  check each object */

	      if ((j=i->next_content)) {
                if (((j->item_number==NOTHING) && (i->item_number==NOTHING) &&
                  (strcmp(j->description,i->description)==0)) ||
                  ((j->item_number==i->item_number) && (i->item_number!=NOTHING))) {
                  i = j;
                  continue;
                }
              }
	      while (SECT(i->in_room) == SECT_FLYING && 
                     !IS_OBJ_SPELL_AFF(i, ITEM_FLY) &&
                      i->obj_flags.type_flag != ITEM_PORTAL) {

		/*  make it fall */
a2356 66
	    	was_in = i->in_room;

		/*  display to people in room object is falling from */

                for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
		  if (CAN_SEE_OBJ(ch, i)) {
   		    sprintf(gravbuf, "%s &1&bplummets&0 &2downward!&0\n", i->short_description);
		    send_to_char(gravbuf, ch);
		  } else {
                    sprintf(gravbuf, "Something &1&bwhizzes&0 &2downward!&0\n");
                    send_to_char(gravbuf, ch);
                  }
                }
		obj_from_room(i);
		obj_to_room(i, world[was_in].dir_option[DOWN]->to_room);

		/*  display to people in room object is falling through/to */

                for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
                  if (CAN_SEE_OBJ(ch, i)) {
  	  	    sprintf(gravbuf, "&1&b%s falls from above.&0\n", i->short_description);
                    send_to_char(gravbuf, ch);
                  } else {
                    sprintf(gravbuf, "&1&bSomething whizzes past you.&0\n");
                    send_to_char(gravbuf, ch);
                  }
                }

		/*  time to land */

                if (SECT(i->in_room) != SECT_FLYING) {
                  for (ch = world[i->in_room].people; ch != NULL; ch = ch->next_in_room) {
                    if (CAN_SEE_OBJ(ch, i)) {
    	              sprintf(gravbuf, "&1&b%s lands with a dull&0 &1THUD!&0\n", i->short_description);
                      send_to_char(gravbuf, ch);
                    } else {
                      sprintf(gravbuf, "&1&bSomething lands with a dull&0 &1THUD!&0\n");
                      send_to_char(gravbuf, ch);
                    }
                  }  
                }
              }
	      i = i->next_content;
	    }

	    /*  end of object gravity check */
	    /*  start the gravity check for players/mobs  */
	    /*  check each ch */

	    for (ch = world[rrn].people; ch != NULL; ch = ch->next_in_room) {
	      k = 0;
	      flying = 0;
	      riding = 0;
	      ridden_by = 0;
	      if (GET_POS(ch) == POS_FLYING) flying = 1;
	      /*if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;*/

	      /* If either mount or mountee is flying then don't fall */
	      /* otherwise unmount and prepare to fall... */

	      if (RIDING(ch) && SECT(ch->in_room) == SECT_FLYING) {
		riding = 1;
	        if (GET_POS(RIDING(ch)) == POS_FLYING) {
		/*if (IS_AFFECTED(RIDING(ch), AFF_FLYING)) {*/
		  flying = 1;
		}
d2358 76
a2433 7
	      if (RIDDEN_BY(ch) && SECT(ch->in_room) == SECT_FLYING) {
		ridden_by = 1;

		/*if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) {*/
	        if (GET_POS(RIDDEN_BY(ch)) == POS_FLYING) {
		  flying = 1;
		}
d2435 107
a2541 16
	      if (riding && !flying) dismount_char(ch);
	      if (ridden_by && !flying) dismount_char(RIDDEN_BY(ch));

	      /* Make them fall */

/*	      while (SECT(ch->in_room) == SECT_FLYING && !IS_AFFECTED(ch, AFF_FLYING) && !flying) {*/
	      while (SECT(ch->in_room) == SECT_FLYING && (GET_POS(ch) != POS_FLYING) && !flying) {
		k++;

		was_in = ch->in_room;

		/*  Message to room fall started in */

		if (k == 1) {
		  send_to_char("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n", ch);
		  act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0", FALSE, ch, 0, 0, TO_ROOM);
d2543 172
a2714 13

		char_from_room(ch);
		char_to_room(ch, world[was_in].dir_option[DOWN]->to_room);
		if (ch->desc != NULL)
		  look_at_room(ch, 0);

		/*  Message to rooms falling through */
		
		send_to_char("&2DOWN!&0\r\n", ch);
		act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);

		if (SECT(ch->in_room) != SECT_FLYING && GET_LEVEL(ch) < LVL_IMMORT) {
		  do_falling_damage(ch, k);
d2717 33
d2751 2
a2752 43




          }
	}
      }
    }
  }
  return;
}


void do_falling_damage(struct char_data *ch, float dist_fell)
{
  send_to_char("You land with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", ch);
  act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
  GET_POS(ch) = POS_SITTING;
  GET_HIT(ch) -= ((dist_fell * (GET_SIZE(ch) + 1))/50) * GET_MAX_HIT(ch);
  update_pos(ch);
  switch (GET_POS(ch)) {
  case POS_MORTALLYW:
    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
    break;
  case POS_INCAP:
    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    break;
  case POS_STUNNED:
    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    break;
  case POS_DEAD:
    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You are dead!  Sorry...\r\n", ch);
    sprintf(buf2, "%s killed by falling at %s", GET_NAME(ch), world[ch->in_room].name);
    mudlog(buf2, BRF, 0, TRUE);
    die(ch, ch);
    break;
  default:
  }
}
@


1.1
log
@Initial revision
@
text
@d2654 2
a2655 2

	      if (IS_AFFECTED(ch, AFF_FLYING))  flying = 1;
d2662 2
a2663 1
		if (IS_AFFECTED(RIDING(ch), AFF_FLYING)) {
d2669 3
a2671 1
		if (IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING)) {
d2680 2
a2681 1
	      while (SECT(ch->in_room) == SECT_FLYING && !IS_AFFECTED(ch, AFF_FLYING) && !flying) {
@
