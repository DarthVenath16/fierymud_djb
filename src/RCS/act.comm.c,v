head	1.71;
access;
symbols;
locks; strict;
comment	@ * @;


1.71
date	2009.07.16.04.17.47;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.20.23.55.13;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.09.20.09.56;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.27.04.18.00;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2008.09.14.19.47.01;	author jps;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.13.16.35.24;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.02.03.00.59;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.31.21.04.46;	author myc;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.30.20.42.50;	author myc;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.16.23.04.03;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2008.08.16.08.22.41;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2008.08.14.23.02.11;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2008.05.11.05.41.31;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.21.15.01.17;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.10.20.30.03;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.09.06.19.44;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.15.06.49.52;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.25.06.47.25;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.19.20.35.22;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.18.06.01.41;	author myc;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.14.10.43.36;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.13.19.21.22;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.11.02.08.32;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.22.18.54.10;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.20.22.24.17;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.15.04.30.38;	author jjl;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.11.03.13.29;	author dce;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.30.23.34.50;	author dce;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.24.15.43.31;	author dce;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.23.01.50.11;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.13.21.07.08;	author dce;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.28.00.41.25;	author mtp;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.19.03.05.28;	author rsd;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.14.00.04.43;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.11.01.39.51;	author mtp;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.14.01.16.58;	author rsd;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.22.23.30.46;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	99.11.20.22.22.21;	author rsd;	state Exp;
branches;
next	1.15;

1.15
date	99.09.09.03.47.26;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.09.03.23.04.14;	author mtp;	state Exp;
branches;
next	1.12;

1.12
date	99.08.18.22.41.04;	author mtp;	state Exp;
branches;
next	1.11;

1.11
date	99.08.13.21.38.00;	author mtp;	state Exp;
branches;
next	1.10;

1.10
date	99.08.09.22.34.31;	author mtp;	state Exp;
branches;
next	1.9;

1.9
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	99.04.16.15.17.13;	author jen;	state Exp;
branches;
next	1.7;

1.7
date	99.04.08.19.14.26;	author jen;	state Exp;
branches;
next	1.6;

1.6
date	99.03.30.21.51.01;	author jen;	state Exp;
branches;
next	1.5;

1.5
date	99.03.30.19.09.56;	author jen;	state Exp;
branches;
next	1.4;

1.4
date	99.03.26.19.44.35;	author jen;	state Exp;
branches;
next	1.3;

1.3
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.03.23.28.47;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.29;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.comm.c                                    Part of CircleMUD *
 *  Usage: Player-level communication commands                             *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "screen.h"
#include "dg_scripts.h"
#include "clan.h"

/* extern variables */
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern void mprog_speech_trigger(char *txt, struct char_data *mob);
void improve_lang(struct char_data *ch, struct char_data *tch, int skill);

void garble_text(char *string, int percent)
{
  char letters[] = "aeiousthpwxyz";
  int i;

  for (i = 0; i < strlen(string); ++i)
    if (isalpha(string[i]) && number(0, 1) && number(0, 100) > percent)
      string[i] = letters[number(0, 12)];
}

ACMD (do_ctell)
{
  struct descriptor_data *i;
  int minlev=1, c=0;
  char level_string[6]="\0\0\0\0\0\0";
  skip_spaces (&argument);
  /*
   * The syntax of ctell for imms is different then for morts
   * mort: ctell <bla bla bla>    imms: ctell <clan_num> <bla bla bla>
   * Imms cannot actually see ctells but they can send them
   */

  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) >= LVL_CLAN_GOD){
    half_chop(argument, buf, argument);
    if (is_number(buf))
      c = atoi(buf);
    else {
      send_to_char("You must specify a clan number.\r\n",ch);
      return;
    }
    if ((c < 0) || (c > num_of_clans)){
      send_to_char ("There is no clan with that number.\r\n", ch);
      return;
    }
    else
      c = clan[c].id;
    /*
      while ((*argument != ' ') && (*argument != '\0'))
      argument++;
      while (*argument == ' ') argument++;
    */
  }
  else
    if((c=GET_CLAN(ch))==0 || GET_CLAN_RANK(ch)==0) {
      send_to_char ("You're not part of a clan.\r\n", ch);
      return;
    }

  skip_spaces (&argument);
  if (!*argument){
    send_to_char ("What do you want to tell your clan?\r\n", ch);
    return;
  }

  if (*argument == '#'){
    argument++;
    minlev = atoi (argument);
    if (minlev > clan[c].ranks && GET_LEVEL(ch) < LVL_IMMORT){
      send_to_char ("No one has a clan rank high enough to hear you!\r\n", ch);
      return;
    }
    while (*argument != ' ') argument++;
    while (*argument == ' ') argument++;
    sprintf (level_string, "(%d)", minlev);
  }

  if (PRF_FLAGGED(ch,PRF_NOREPEAT))
    sprintf (buf1, OK);
  else
    if (GET_LEVEL(ch) >= LVL_IMMORT)
      sprintf (buf1, "&5You tell %s&0&5%s, '&b%s&0&5'&0\r\n",clan[find_clan_by_id(c)].name,level_string, argument);
    else
      sprintf (buf1, "&5You tell your clan%s, '&b%s&0&5'&0\r\n",level_string, argument);
  send_to_char (buf1, ch);

  for (i = descriptor_list; i; i=i->next){
    if (!(i->character))
      continue;
    if (GET_LEVEL(i->character) >= LVL_CLAN_GOD && ch != i->character
	&& (i->character->clan_snoop == -1 || i->character->clan_snoop == find_clan_by_id(c))){
      sprintf(buf, "&5%s tells &0%s&0&5, '&b%s&0&5'&0\r\n",
	      GET_NAME(ch), clan[find_clan_by_id(c)].name, argument);
      send_to_char(buf, i->character);
    }
    if (i->character->player_specials->saved.clan == c){
      if (i->character->player_specials->saved.clan_rank >= minlev){
	if (strcmp (i->character->player.name, ch->player.name)){
	  sprintf (buf, "&5%s tells your clan%s, '&b%s&0&5'&0\r\n",
		   (((IS_AFFECTED(ch, AFF_INVISIBLE)) &&
		     (!IS_AFFECTED(i->character, AFF_DETECT_INVIS))) ?
		    "Someone" : ch->player.name), level_string, argument);
	  send_to_char (buf, i->character);
	}
      }
    }
  }
  return;
}

ACMD(do_say)
{
  extern char *languages[];
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
  int ofs = 190;              /* offset - should be first language */
  struct char_data *tch;

  skip_spaces(&argument);

  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
    return;
  }
  if (!*argument){
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
    return;
  }


  else {

    if(GET_LEVEL(ch) < LVL_IMMORT)
      if(strchr(argument, '&'))  {
	send_to_char("No ampersand sign allowed in input.", ch);
	return;
      }
    strcpy(ibuf, argument);     /* save real message */
#ifdef LANGUAGES
    if (!IS_NPC(ch))
      garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif

    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
      if (tch != ch && AWAKE(tch) && tch->desc) {

	strcpy(obuf, ibuf);     /* preserve the first garble */
#ifdef LANGUAGES
	if (!IS_NPC(ch))
	  garble_text(obuf, GET_SKILL(tch, SPEAKING(ch)));
#endif

	if ((GET_SKILL(tch, SPEAKING(ch)) < 1) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) &&
	    (GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says, '%s'",  obuf);
	else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says in %s, '%s'", languages[(SPEAKING(ch) - ofs)], obuf);
	else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says in %s, '%s'", languages[(SPEAKING(ch) - ofs)], argument);
	else
	  sprintf(buf, "$n says, '%s'", argument);
	MOBTrigger = FALSE;
#ifdef LANGUAGES
	improve_lang(tch, ch, SPEAKING(ch));
	improve_lang(ch, ch, SPEAKING(ch));
#endif
	act(buf, TRUE, ch, 0, tch, TO_VICT|DG_NO_TRIG);
      }
    }

    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      if (!IS_NPC(ch)){
	sprintf(buf, "You say in %s, '%s'", languages[(SPEAKING(ch)- ofs)], argument);
	act(buf, TRUE, ch, 0, 0, TO_CHAR);}else{
	  sprintf(buf, "You say, '%s'", argument);
	  act(buf, FALSE, ch, 0, argument, TO_CHAR);}
    }
    mprog_speech_trigger(argument, ch);
    /* trigger check */
    speech_mtrigger(ch, argument);
    speech_wtrigger(ch, argument);
  }
}

ACMD(do_gsay)
{
  struct char_data *k;struct group_type *f;
  skip_spaces(&argument);

  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.", ch);
      return;
    }

  if (!IS_AFFECTED(ch, AFF_GROUP))
    {
      send_to_char("But you are not the member of a group!\r\n", ch);
      return;	}
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
    return;
  }

  if (!*argument)
    send_to_char("Yes, but WHAT do you want to group-say?\r\n", ch);
  else
    {
      if (ch->groupmaster)
	k = ch->groupmaster;
      else
	k = ch;
      sprintf(buf, "&0&2$n tells the group, '&0&b&2%s&0&2'&0", argument);
      if (IS_AFFECTED(k, AFF_GROUP) && (k != ch))
	act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
      for (f = k->groupees; f; f = f->next)
	if (IS_AFFECTED(f->groupee, AFF_GROUP) &&
	    (f->groupee != ch))
	  act(buf, FALSE, ch, 0, f->groupee, TO_VICT | TO_SLEEP);
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else
	{
	  sprintf(buf, "&0&2You group say, '&0&b&2%s&0&2'&0", argument);
	  act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);		}	}
}


ACMD(do_msay)
{
  struct char_data *k = NULL;
  struct mgroup_type *f; struct group_type *g;

  skip_spaces(&argument);

  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.", ch);
      return;
    }
  if (!IS_AFFECTED(ch, AFF_GROUP))
    {
      send_to_char("But you are not even a member of a normal group!\r\n", ch);
      return;
    }
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
    return;
  }

  if (!*argument)
    send_to_char("Yes, but WHAT do you want to major group-say?\r\n", ch);
  else
    {
      if (ch->mgroupmaster)
	k = ch->mgroupmaster;
      else
	{
	  if (ch->mgroupees)/*mgroup master*/
	    k = ch;
	  else
	    {
	      if (ch->groupmaster)
		if (ch->groupmaster->mgroupmaster)
		  k = ch->groupmaster->mgroupmaster;
		else if (ch->groupmaster->mgroupees)
		  k = ch->groupmaster;
		else
		  {send_to_char("You are not in a major group.\r\n", ch);
		  return;
		  }}
	}

      sprintf(buf, "&0&1$n tells the major group, '&0&1&b%s&0&1'&0", argument);
      if (IS_AFFECTED(k, AFF_GROUP) && (k != ch))
	act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
      for (f = k->mgroupees; f; f = f->next)
	{

	  if (IS_AFFECTED2(f->mgroupee, AFF2_MGROUP) && (f->mgroupee != ch))
	    {
	      act(buf, FALSE, ch, 0, f->mgroupee, TO_VICT | TO_SLEEP);
				/*loop through this guys normal groupee's*/
	      for (g=f->mgroupee->groupees;g;g=g->next)
		{
		  if (IS_AFFECTED(g->groupee, AFF_GROUP))
		    act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
		}
	    }
	}
      /*loop through leaders group*/
      for (g=k->groupees;g;g=g->next)
	{
	  if ((IS_AFFECTED(g->groupee, AFF_GROUP)) && (g->groupee != ch))
	    act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
	}

      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else
	{
	  sprintf(buf, "&0&1You major group say, '&0&1&b%s&0&1'&0", argument);
	  act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
	}
    }
}

void perform_tell(struct char_data *ch, struct char_data *vict, char *arg)
{
  extern char *languages[];
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
  int ofs = 190;              /* offset - should be first language */

  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(arg, '&'))  {
      send_to_char("No ampersand sign allowed in input.", ch);
      return;
    }

  send_to_char(CCWHT(vict, C_NRM), vict);

  strcpy(ibuf, arg);     /* save real tell */
#ifdef LANGUAGES
  if (!IS_NPC(ch))
    garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif
  strcpy(obuf, ibuf);
#ifdef LANGUAGES
  if (!IS_NPC(ch))
    garble_text(obuf, GET_SKILL(vict, SPEAKING(ch)));
#endif
  if (!IS_NPC(ch) && GET_LEVEL(ch) < LVL_GOD) {
    sprintf(buf, "&0&b&8$n tells you in %s, '%s'&0", languages[(SPEAKING(ch) - ofs)], obuf);
#ifdef LANGUAGES
    improve_lang(vict, ch, SPEAKING(ch));
    improve_lang(ch, ch, SPEAKING(ch));
#endif
  }
  else
    sprintf(buf, "&0&b&8$n tells you, '%s'&0", arg);
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);
  send_to_char(CCWHT(vict, C_NRM), vict);

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    send_to_char(CCWHT(ch, C_CMP), ch);
    sprintf(buf, "&0&b&8You tell $N, '%s'&0", arg);

    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    send_to_char(CCNRM(ch, C_CMP), ch);
  }

  GET_LAST_TELL(vict) = GET_IDNUM(ch);
}


ACMD(do_tell)
{
  struct char_data *vict;

  half_chop(argument, buf, buf2);


  if (!*buf || !*buf2)
    send_to_char("Who do you wish to tell what??\r\n", ch);
  else if (!(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (ch == vict)
    send_to_char("You try to tell yourself something.\r\n", ch);
  else if ((((GET_RACE_ALIGN(ch)) + (GET_RACE_ALIGN(vict))) == 1)&&((GET_LEVEL(vict)<LVL_GOD)&&(GET_LEVEL(ch)<LVL_GOD)))
    send_to_char(NOPERSON, ch);
  else if (PRF_FLAGGED(ch, PRF_NOTELL))
    send_to_char("You can't tell other people while you have notell on.\r\n", ch);
  else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    send_to_char("The walls seem to absorb your words.\r\n", ch);
  else if (!IS_NPC(vict) && !vict->desc)	/* linkless */
    act("No one here by that name.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
    act("$E's writing a message right now; try again later.",
	FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PRF_FLAGGED(vict, PRF_NOTELL) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
    act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if ((vict->player_specials->ignored == ch)) {
    act("$N is ignoring you at the moment.  No dice.", FALSE, ch, 0, vict, TO_CHAR);
  } else
    perform_tell(ch, vict, buf2);
}

ACMD(do_reply)
{
  struct char_data *tch = character_list;

  skip_spaces(&argument);

  if (GET_LAST_TELL(ch) == NOBODY)
    send_to_char("You have no-one to reply to!\r\n", ch);
  else if (!*argument)
    send_to_char("What is your reply?\r\n", ch);
  else {
    /*
     * Make sure the person you're replying to is still playing by searching
     * for them.  Note, now last tell is stored as player IDnum instead of
     * a pointer, which is much better because it's safer, plus will still
     * work if someone logs out and back in again.
     */

    while (tch != NULL && GET_IDNUM(tch) != GET_LAST_TELL(ch))
      tch = tch->next;

    if (tch == NULL)
      send_to_char("They are no longer playing.\r\n", ch);
    else
      perform_tell(ch, tch, argument);
  }
}

ACMD(do_spec_comm)
{
  struct char_data *vict;
  char *action_sing, *action_plur, *action_others;
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];

  if (subcmd == SCMD_WHISPER) {
    action_sing = "whisper to";
    action_plur = "whispers to";
    action_others = "$n whispers something to $N.";
  } else {
    action_sing = "ask";
    action_plur = "asks";
    action_others = "$n asks $N a question.";
  }

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2) {
    sprintf(buf, "Whom do you want to %s.. and what??\r\n", action_sing);
    send_to_char(buf, ch);
  } else if (!(vict = get_char_room_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (vict == ch)
    send_to_char("You can't get your mouth close enough to your ear...\r\n", ch);
  else {
    strcpy(ibuf, buf2);     /* save real tell */
#ifdef LANGUAGES
    if (!IS_NPC(ch))
      garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif
    strcpy(obuf, ibuf);
#ifdef LANGUAGES
    garble_text(obuf, GET_SKILL(vict, SPEAKING(ch)));
    improve_lang(vict, ch, SPEAKING(ch));
    improve_lang(ch, ch, SPEAKING(ch));
#endif
    sprintf(buf, "$n %s you, '%s'", action_plur, obuf);
    act(buf, FALSE, ch, 0, vict, TO_VICT);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "You %s %s, '%s'\r\n", action_sing, GET_NAME(vict), buf2);
      act(buf, FALSE, ch, 0, 0, TO_CHAR);
    }
    act(action_others, FALSE, ch, 0, vict, TO_NOTVICT);
  }
}

#define MAX_NOTE_LENGTH 1000	/* arbitrary */

ACMD(do_write)
{
  struct obj_data *paper = 0, *pen = 0;
  char *papername, *penname;

  papername = buf1;
  penname = buf2;

  two_arguments(argument, papername, penname);

  if (!ch->desc)
    return;

  if (!*papername) {		/* nothing was delivered */
    send_to_char("Write?  With what?  ON what?  What are you trying to do?!?\r\n", ch);
    return;
  }
  if (*penname) {		/* there were two arguments */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      sprintf(buf, "You have no %s.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (!(pen = get_obj_in_list_vis(ch, penname, ch->carrying))) {
      sprintf(buf, "You have no %s.\r\n", penname);
      send_to_char(buf, ch);
      return;
    }
  } else {		/* there was one arg.. let's see what we can find */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      sprintf(buf, "There is no %s in your inventory.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(paper) == ITEM_PEN) {	/* oops, a pen.. */
      pen = paper;
      paper = 0;
    } else if (GET_OBJ_TYPE(paper) != ITEM_NOTE) {
      send_to_char("That thing has nothing to do with writing.\r\n", ch);
      return;
    }
    /* One object was found.. now for the other one. */
    if (!GET_EQ(ch, WEAR_HOLD)) {
      sprintf(buf, "You can't write with %s %s alone.\r\n", AN(papername),
	      papername);
      send_to_char(buf, ch);
      return;
    }
    if (!CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD))) {
      send_to_char("The stuff in your hand is invisible!  Yeech!!\r\n", ch);
      return;
    }
    if (pen)
      paper = GET_EQ(ch, WEAR_HOLD);
    else
      pen = GET_EQ(ch, WEAR_HOLD);
  }


  /* ok.. now let's see what kind of stuff we've found */
  if (GET_OBJ_TYPE(pen) != ITEM_PEN)
    act("$p is no good for writing with.", FALSE, ch, pen, 0, TO_CHAR);
  else if (GET_OBJ_TYPE(paper) != ITEM_NOTE)
    act("You can't write on $p.", FALSE, ch, paper, 0, TO_CHAR);
  else if (paper->action_description)
    send_to_char("There's something written on it already.\r\n", ch);
  else {
    /* we can write - hooray! */
    /* send_to_char("Write your note.  End with '@@' on a new line.\r\n", ch);*/
    /* this is the PERFECT code example of how to set up:
     * a) the text editor with a message already loaed
     * b) the abort buffer if the player aborts the message
     */
    ch->desc->backstr = NULL;
    /*ch->desc->backstr == NULL this was what it was, hurm banyal*/
    send_to_char("Write your note.  (/s saves /h for help)\r\n", ch);
    /* ok, here we check for a message ALREADY on the paper */
    if (paper->action_description) {
      /* we str_dup the original text to the descriptors->backstr */
      ch->desc->backstr = str_dup(paper->action_description);
      /* send to the player what was on the paper (cause this is already */
      /* loaded into the editor) */
      send_to_char(paper->action_description, ch);
    }
    act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
    /* assign the descriptor's->str the value of the pointer to the text */
    /* pointer so that we can reallocate as needed (hopefully that made */
    /* sense :>) */
    ch->desc->str = &paper->action_description;
    ch->desc->max_str = MAX_NOTE_LENGTH;
  }
}

ACMD(do_page)
{
  struct descriptor_data *d;
  struct char_data *vict;

  half_chop(argument, arg, buf2);

  if (IS_NPC(ch))
    send_to_char("Monsters can't page.. go away.\r\n", ch);
  else if (!*arg)
    send_to_char("Whom do you wish to page?\r\n", ch);
  else {
    sprintf(buf, "\007\007*%s* %s\r\n", GET_NAME(ch), buf2);
    if (!str_cmp(arg, "all")) {
      if (GET_LEVEL(ch) > LVL_GOD) {
	for (d = descriptor_list; d; d = d->next)
	  if (!d->connected && d->character)
	    act(buf, FALSE, ch, 0, d->character, TO_VICT);
      } else
	send_to_char("You will never be godly enough to do that!\r\n", ch);
      return;
    }
    if ((vict = get_char_vis(ch, arg)) != NULL) {
      act(buf, FALSE, ch, 0, vict, TO_VICT);
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
      return;
    } else
      send_to_char("There is no such person in the game!\r\n", ch);
  }
}


/**********************************************************************
 * generalized communication func, originally by Fred C. Merkel (Torg) *
 *********************************************************************/

ACMD(do_gen_comm)
{
  extern int level_can_shout;
  extern int holler_move_cost;
  struct descriptor_data *i;
  char color_on[24];

  /* Array of flags which must _not_ be set in order for comm to be heard */
  static int channels[] = {
    0,
    PRF_DEAF,
    PRF_NOGOSS,
    PRF_NOAUCT,
    PRF_NOGRATZ,
    0
  };

  /*
   * com_msgs: [0] Message if you can't perform the action because of noshout
   *           [1] name of the action
   *           [2] message if you're not on the channel
   *           [3] a color string.
   */
  static char *com_msgs[][4] = {
    {"You cannot holler!!\r\n",
     "holler",
     "",
     KYEL},

    {"You cannot shout!!\r\n",
     "shout",
     "Turn off your noshout flag first!\r\n",
     KYEL},

    {"You cannot gossip!!\r\n",
     "gossip",
     "You aren't even on the channel!\r\n",
     KYEL},

    {"You cannot auction!!\r\n",
     "auction",
     "You aren't even on the channel!\r\n",
     KMAG},

    {"You cannot congratulate!\r\n",
     "congrat",
     "You aren't even on the channel!\r\n",
     KGRN}
  };

  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("Your lips move, but no sound forms.\r\n", ch);
    return;
  }
  if (PLR_FLAGGED(ch, PLR_NOSHOUT)) {
    send_to_char(com_msgs[subcmd][0], ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) {
    send_to_char("The walls seem to absorb your words.\r\n", ch);
    return;
  }
  /* level_can_shout defined in config.c */
  if (GET_LEVEL(ch) < level_can_shout) {
    sprintf(buf1, "You must be at least level %d before you can %s.\r\n",
	    level_can_shout, com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }
  /* make sure the char is on the channel */
  if (PRF_FLAGGED(ch, channels[subcmd])) {
    send_to_char(com_msgs[subcmd][2], ch);
    return;
  }
  /* skip leading spaces */
  skip_spaces(&argument);

  /* make sure that there is something there to say! */
  if (!*argument) {
    sprintf(buf1, "Yes, %s, fine, %s we must, but WHAT???\r\n",
	    com_msgs[subcmd][1], com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }
  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.", ch);
      return;
    }
  if (subcmd == SCMD_HOLLER) {
    if (GET_MOVE(ch) < holler_move_cost) {
      send_to_char("You're too exhausted to holler.\r\n", ch);
      return;
    } else
      alter_move(ch, holler_move_cost);
  }
  /* set up the color on code */
  strcpy(color_on, com_msgs[subcmd][3]);

  /* first, set up strings to be given to the communicator */
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    if (COLOR_LEV(ch) >= C_CMP)
      sprintf(buf1, "%sYou %s, '%s'%s", color_on, com_msgs[subcmd][1],
	      argument, KNRM);
    else
      sprintf(buf1, "You %s, '%s'", com_msgs[subcmd][1], argument);
    act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
  }

  sprintf(buf, "$n %ss, '%s'", com_msgs[subcmd][1], argument);

  /* now send all the strings out */
  for (i = descriptor_list; i; i = i->next) {
    if (!i->connected && i != ch->desc && i->character &&
	!PRF_FLAGGED(i->character, channels[subcmd]) &&
	!PLR_FLAGGED(i->character, PLR_WRITING) &&
	!ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {

      if (subcmd == SCMD_SHOUT &&
	  ((world[ch->in_room].zone != world[i->character->in_room].zone) ||
	   GET_POS(i->character) < POS_RESTING))
	continue;

      if (COLOR_LEV(i->character) >= C_NRM)
	send_to_char(color_on, i->character);
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);
      if (COLOR_LEV(i->character) >= C_NRM)
	send_to_char(KNRM, i->character);
    }
  }
}

ACMD(do_qcomm)
{
  struct descriptor_data *i;

  if (!PRF_FLAGGED(ch, PRF_QUEST)) {
    send_to_char("You aren't even part of the quest!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "%s?  Yes, fine, %s we must, but WHAT??\r\n", CMD_NAME,
	    CMD_NAME);
    CAP(buf);
    send_to_char(buf, ch);
  } else {
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      if (subcmd == SCMD_QSAY) {
        if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
	  send_to_char("Your lips move, but no sound forms\r\n", ch);
	  return;
	}
	sprintf(buf, "You quest-say, '%s'", argument);
      }
      else
	strcpy(buf, argument);
      act(buf, FALSE, ch, 0, argument, TO_CHAR);
    }

    if (subcmd == SCMD_QSAY) {
      if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
	send_to_char("Your lips move, but no sound forms\r\n", ch);
	return;
      }
      sprintf(buf, "$n quest-says, '%s'", argument);
    }
    else
      strcpy(buf, argument);

    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i != ch->desc &&
	  PRF_FLAGGED(i->character, PRF_QUEST))
	act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP);
  }
}

void improve_lang(struct char_data *ch, struct char_data *tch, int skill)
{
  /*  extern char *spells[];*/
  extern char *languages[];
  int percent = GET_ISKILL(ch, skill);
  int newpercent;
  int ofs = 190;
  char skillbuf[MAX_STRING_LENGTH];

  if (number(1, 200) > GET_WIS(ch) + GET_INT(ch))
    return;
  if (percent >= 970 || percent <= 0)
    return;
  newpercent = number(10, 30);
  percent += newpercent;
  SET_SKILL(ch, skill, percent);
  sprintf(skillbuf, "You feel your knowledge in %s language improving.\r\n", languages[(SPEAKING(tch) - ofs)]);
  send_to_char(skillbuf, ch);
}
@


1.71
log
@Negative drunkenness ("off") was causing numbers to always be
scrambled.
@
text
@/***************************************************************************
 * $Id: act.comm.c,v 1.70 2009/06/20 23:55:13 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: act.comm.c                                     Part of FieryMUD *
 *  Usage: Player-level communication commands                             *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "screen.h"
#include "dg_scripts.h"
#include "clan.h"
#include "math.h"
#include "regen.h"
#include "modify.h"
#include "constants.h"
#include "act.h"
#include "editor.h"
#include "board.h"

/* extern variables */
extern int gossip_channel_active;



void garble_text(char *string, int percent)
{
  char letters[] = "aeiousthpwxyz";
  int i, len = strlen(string);

  for (i = 0; i < len; ++i)
    if (isalpha(string[i]) && number(0, 1) && number(0, 100) > percent)
      string[i] = letters[number(0, 12)];
}

/*
 * Drunk structure and releated code to slur a players speech
 * if they are drunk. Zantir 3/23/01
 */

char *drunken_speech(char *string, int drunkenness)
{
  const struct {
    int min_drunk_level;
    int replacement_count;
    char *replacements[10];
  } drunk_letters['z' - 'a' + 1] = { /* # of letters in alphabet */
    { 3, 9, { "a", "a", "A", "aa", "ah", "Ah", "ao", "aw", "ahhhh" } },
    { 8, 5, { "b", "b", "B", "B", "vb" } },
    { 3, 5, { "c", "C", "cj", "sj", "zj" } },
    { 5, 2, { "d", "D" } },
    { 3, 3, { "e", "eh", "E" } },
    { 4, 5, { "f", "ff", "fff", "fFf", "F" } },
    { 8, 2, { "g", "G" } },
    { 9, 6, { "h", "hh", "hhh", "Hhh", "HhH", "H" } },
    { 7, 6, { "i", "Iii", "ii", "iI", "Ii", "I" } },
    { 9, 5, { "j", "jj", "Jj", "jJ", "J" } },
    { 7, 2, { "k", "K" } },
    { 3, 2, { "l", "L" } },
    { 5, 8, { "m", "mm", "mmm", "mmmm", "mmmmm", "MmM", "mM", "M" } },
    { 6, 6, { "n", "nn", "Nn", "nnn", "nNn", "N" } },
    { 3, 6, { "o", "ooo", "ao", "aOoo", "Ooo", "ooOo" } },
    { 3, 2, { "p", "P" } },
    { 5, 5, { "q", "Q", "ku", "ququ", "kukeleku" } },
    { 4, 2, { "r", "R" } },
    { 2, 5, { "ss", "zzZzssZ", "ZSssS", "sSzzsss", "sSss" } },
    { 5, 2, { "t", "T" } },
    { 3, 6, { "u", "uh", "Uh", "Uhuhhuh", "uhU", "uhhu" } },
    { 4, 2, { "v", "V" } },
    { 4, 2, { "w", "W" } },
    { 5, 6, { "x", "X", "ks", "iks", "kz", "xz" } },
    { 3, 2, { "y", "Y" } },
    { 2, 8, { "z", "ZzzZz", "Zzz", "szz", "sZZz", "ZSz", "zZ", "Z" } }
  };

  static char drunkbuf[4000];      /* this should be enough (?) */
  char temp;
  char *pos = drunkbuf;

  if (drunkenness > 0) {
    do {
      temp = toupper(*string);
      if (isdigit(*string))
        *(pos++) = '0' + number(0, 9);
      else if (isalpha(temp) && drunkenness > drunk_letters[temp - 'A'].min_drunk_level) {
        strcpy(pos, drunk_letters[temp - 'A'].replacements
                    [number(0, drunk_letters[temp - 'A'].replacement_count - 1)]);
        pos += strlen(pos);
      }
      else
        *(pos++) = *string;
    } while (*(string++));
    return drunkbuf;
  }

  return string; /* character is not drunk, just return the string */
}




void afk_message(struct char_data *ch, struct char_data *vict) {
  if (PRF_FLAGGED(vict, PRF_AFK)) {
    act("$N is AFK right now, but received your message.", TRUE, ch, 0, vict, TO_CHAR);
    cprintf(vict, "You received the previous message while AFK.\r\n");
  }
}

ACMD(do_desc)
{
   int maxlen, maxlines;

   if (IS_NPC(ch)) {
      cprintf(ch, "You can't change your description, silly-head!\r\n");
      return;
   }

   maxlen = GET_LEVEL(ch) < LVL_IMMORT ? PLAYER_DESC_LENGTH : IMMORT_DESC_LENGTH;
   maxlines = GET_LEVEL(ch) < LVL_IMMORT ? PLAYER_DESC_LINES : IMMORT_DESC_LINES;

   if (GET_STANCE(ch) > STANCE_SLEEPING)
      act("$n appears rather introspective.", TRUE, ch, 0, 0, TO_ROOM);

   editor_init(ch->desc, &ch->player.description, maxlen);
   editor_set_begin_string(ch->desc,
         "Enter the text you'd like others to see when they look at you "
         "(limit %d lines).\r\n", maxlines);
   editor_set_max_lines(ch->desc, maxlines);
}

ACMD(do_say)
{
  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    cprintf(ch, "You lips move, but no sound forms.\r\n");
    return;
  }
  if (!*argument) {
    cprintf(ch, "Yes, but WHAT do you want to say?\r\n");
    return;
  }

  if (!speech_ok(ch, 0))
    return;

  if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)
    argument = strip_ansi(argument);

  argument = drunken_speech(argument, GET_COND(ch, DRUNK));

  act("You say, '$T@@0'", FALSE, ch, 0, argument, TO_CHAR | TO_OLC);
  act("$n says, '$T@@0'", FALSE, ch, 0, argument, TO_ROOM | TO_OLC);

  /* trigger check */
  speech_mtrigger(ch, argument);
  speech_wtrigger(ch, argument);
}

ACMD(do_gsay)
{
  struct char_data *k;
  struct group_type *f;
  skip_spaces(&argument);

  if (!ch->group_master && !ch->groupees) {
    cprintf(ch, "But you are not the member of a group!\r\n");
    return;
  }
  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    cprintf(ch, "You lips move, but no sound forms.\r\n");
    return;
  }

  if (!*argument) {
    cprintf(ch, "Yes, but WHAT do you want to group-say?\r\n");
    return;
  }

  if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)
    argument = strip_ansi(argument);

  argument = drunken_speech(argument, GET_COND(ch, DRUNK));
  if (ch->group_master)
    k = ch->group_master;
  else
    k = ch;

  sprintf(buf, "@@g$n@@g tells the group, '&0%s@@g'@@0", argument);
  if (k != ch)
    act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP | TO_OLC);
  for (f = k->groupees; f; f = f->next)
    if (f->groupee != ch)
      act(buf, FALSE, ch, 0, f->groupee, TO_VICT | TO_SLEEP | TO_OLC);

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    cprintf(ch, "%s", OK);
  else {
    sprintf(buf, "@@gYou group say, '&0%s@@g'@@0", argument);
    act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP | TO_OLC);
  }
}


static void perform_tell(struct char_data *ch, struct char_data *vict, char *arg)
{
  if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)
    arg = strip_ansi(arg);

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    cprintf(ch, "%s", OK);
  else {
    sprintf(buf, "@@WYou tell $N@@W, '%s@@W'@@0", arg);
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  }

  if (vict->forward && !vict->desc)
    vict = vict->forward;

  sprintf(buf, "@@W$n@@W tells you, '%s@@W'@@0", arg);
  act(buf, FALSE, REAL_CHAR(ch), 0, vict, TO_VICT | TO_SLEEP | TO_OLC);

  GET_LAST_TELL(vict) = GET_IDNUM(REAL_CHAR(ch));
  afk_message(ch, vict);
  if (IS_MOB(vict))
    speech_to_mtrigger(ch, vict, arg);
}


ACMD(do_tell)
{
  struct char_data *vict;

  half_chop(argument, buf, buf2);


  if (!*buf || !*buf2)
    cprintf(ch, "Who do you wish to tell what??\r\n");
  else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, buf))))
    cprintf(ch, "%s", NOPERSON);
  else if (ch == vict)
    cprintf(ch, "You try to tell yourself something.\r\n");
  else if (PRF_FLAGGED(ch, PRF_NOTELL))
    cprintf(ch, "You can't tell other people while you have notell on.\r\n");
  else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF) && GET_LEVEL(ch) < LVL_IMMORT)
    cprintf(ch, "The walls seem to absorb your words.\r\n");
  else if (!IS_NPC(vict) && !vict->desc && (!vict->forward || !vict->forward->desc))	 /* linkless */
    act("No one here by that name.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  else if (PLR_FLAGGED(vict, PLR_WRITING) && !PRF_FLAGGED(vict, PRF_OLCCOMM))
    act("$E's writing a message right now; try again later.",
	FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  else if (vict->desc && EDITING(vict->desc) && !PRF_FLAGGED(vict, PRF_OLCCOMM))
    act("$E's writing a message right now; try again later.",
	FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  else if (((!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_NOTELL)) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF)) && (GET_LEVEL(ch) < LVL_IMMORT || (GET_LEVEL(vict) > LVL_IMMORT && GET_LEVEL(ch) < GET_LEVEL(vict))))
    act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC );
  else if (!IS_NPC(REAL_CHAR(vict)) &&
           REAL_CHAR(vict)->player_specials->ignored == REAL_CHAR(ch))
    act("$N is ignoring you at the moment.  No dice.", FALSE, ch, 0, REAL_CHAR(vict), TO_CHAR | TO_OLC);
  else {
    if (!speech_ok(ch, 0)) return;
    argument = drunken_speech(buf2, GET_COND(ch, DRUNK));
    perform_tell(ch, vict, argument);
  }
}

ACMD(do_reply)
{
  struct char_data *tch = character_list;

  skip_spaces(&argument);

  if (GET_LAST_TELL(ch) == NOBODY)
    cprintf(ch, "You have no-one to reply to!\r\n");
  else if (!*argument)
    cprintf(ch, "What is your reply?\r\n");
  else {
    /*
     * Make sure the person you're replying to is still playing by searching
     * for them.  Note, now last tell is stored as player IDnum instead of
     * a pointer, which is much better because it's safer, plus will still
     * work if someone logs out and back in again.
     */

    while (tch != NULL && GET_IDNUM(tch) != GET_LAST_TELL(ch))
      tch = tch->next;

    if (tch == NULL)
      cprintf(ch, "They are no longer playing.\r\n");
    else if (PRF_FLAGGED(tch, PRF_NOTELL) && GET_LEVEL(ch) < LVL_GOD)
      cprintf(ch, "That person is now not listening to tells.\r\n");
    else if (speech_ok(ch, 0)) {
      argument = drunken_speech(argument, GET_COND(ch, DRUNK));
      perform_tell(ch, tch, argument);
    }
  }
}

ACMD(do_spec_comm)
{
  struct char_data *vict;
  char *action_sing, *action_plur, *action_others;

  if (subcmd == SCMD_WHISPER) {
    action_sing = "whisper to";
    action_plur = "whispers to";
    action_others = "$n whispers something to $N.";
  } else {
    action_sing = "ask";
    action_plur = "asks";
    action_others = "$n asks $N a question.";
  }

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2)
    cprintf(ch, "Whom do you want to %s.. and what??\r\n", action_sing);
  else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, buf))))
    cprintf(ch, "%s", NOPERSON);
  else if (vict == ch)
    cprintf(ch, "You can't get your mouth close enough to your ear...\r\n");
  else if (PLR_FLAGGED(vict, PLR_WRITING) && !PRF_FLAGGED(vict, PRF_OLCCOMM))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  else if (vict->desc && EDITING(vict->desc) && !PRF_FLAGGED(vict, PRF_OLCCOMM))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP | TO_OLC);
  else {
    if (!speech_ok(ch, 0)) return;
    argument = drunken_speech(buf2, GET_COND(ch, DRUNK));
    sprintf(buf, "$n %s you, '%s@@0'", action_plur, argument);
    act(buf, FALSE, ch, 0, vict, TO_VICT | TO_OLC);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      cprintf(ch, "%s", OK);
    else {
      sprintf(buf, "You %s %s, '%s@@0'", action_sing, GET_NAME(vict), argument);
      act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_OLC);
    }
    act(action_others, FALSE, ch, 0, vict, TO_NOTVICT);
    afk_message(ch, vict);
    if (IS_MOB(vict))
      speech_to_mtrigger(ch, vict, argument);
  }
}

#define MAX_NOTE_LENGTH 1000	/* arbitrary */

ACMD(do_write)
{
  struct obj_data *surface, *implement;
  char *surface_name = buf1, *implement_name = buf2;
  struct char_data *dummy;

  if (!ch->desc)
    return;

  argument = one_argument(argument, surface_name);

  if (!*surface_name) {
    cprintf(ch, "Write?  With what?  On what?  What are you trying to do?\r\n");
    return;
  }

  generic_find(surface_name, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_OBJ_EQUIP,
               ch, &dummy, &surface);

  if (!surface) {
    cprintf(ch, "You can't find a %s to write on.\r\n", surface_name);
    return;
  }

  if (GET_OBJ_TYPE(surface) == ITEM_BOARD) {
    skip_spaces(&argument);
    write_message(ch, board(GET_OBJ_VAL(surface, VAL_BOARD_NUMBER)), argument);
    return;
  }

  one_argument(argument, implement_name);

  if (*implement_name) {
    generic_find(implement_name, FIND_OBJ_INV | FIND_OBJ_EQUIP,
                 ch, &dummy, &implement);
    if (!implement) {
      cprintf(ch, "You can't find a %s to write with.\r\n", implement_name);
      return;
    }
  }
  else if (GET_OBJ_TYPE(surface) == ITEM_NOTE) {
    /* No writing implement specified, see if the player has one */
    if (GET_EQ(ch, WEAR_HOLD) &&
        GET_OBJ_TYPE(GET_EQ(ch, WEAR_HOLD)) == ITEM_PEN)
      implement = GET_EQ(ch, WEAR_HOLD);
    else if (GET_EQ(ch, WEAR_HOLD2) &&
        GET_OBJ_TYPE(GET_EQ(ch, WEAR_HOLD2)) == ITEM_PEN)
      implement = GET_EQ(ch, WEAR_HOLD2);
    else
      for (implement = ch->carrying; implement; implement = implement->next_content)
        if (GET_OBJ_TYPE(implement) == ITEM_PEN)
          if (CAN_SEE_OBJ(ch, implement))
            break;
    if (!implement) {
      cprintf(ch, "You don't have anything to write with.\r\n");
      return;
    }
  }

  if (GET_OBJ_TYPE(implement) == ITEM_NOTE &&
      GET_OBJ_TYPE(surface) == ITEM_PEN) {
    /* swap */
    struct obj_data *temp = surface;
    surface = implement;
    implement = temp;
  }

  if (GET_OBJ_TYPE(surface) != ITEM_NOTE) {
    cprintf(ch, "You can't write on %s.\r\n", surface->short_description);
    return;
  }

  if (GET_OBJ_TYPE(implement) != ITEM_PEN) {
    cprintf(ch, "You can't write with %s.\r\n", implement->short_description);
    return;
  }

  /* we can write - hooray! */
  cprintf(ch, "Write your note.  (/s saves /h for help)\r\n");
  string_write(ch->desc, &surface->action_description, MAX_NOTE_LENGTH);
  act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
}

ACMD(do_page)
{
  struct descriptor_data *d;
  struct char_data *vict;

  half_chop(argument, arg, buf2);

  if (IS_NPC(ch))
    cprintf(ch, "Monsters can't page.. go away.\r\n");
  else if (!*arg)
    cprintf(ch, "Whom do you wish to page?\r\n");
  else {
    sprintf(buf, "\007\007*%s* %s\r\n", GET_NAME(ch), buf2);
    if (!str_cmp(arg, "all")) {
      if (GET_LEVEL(ch) > LVL_GOD) {
	for (d = descriptor_list; d; d = d->next)
	  if (!d->connected && d->character)
	    act(buf, FALSE, ch, 0, d->character, TO_VICT);
      } else
	cprintf(ch, "You will never be godly enough to do that!\r\n");
      return;
    }
    if ((vict = find_char_around_char(ch, find_vis_by_name(ch, arg))) != NULL) {
      act(buf, FALSE, ch, 0, vict, TO_VICT);
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	cprintf(ch, "%s", OK);
      else
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
      return;
    } else
      cprintf(ch, "There is no such person in the game!\r\n");
  }
}

ACMD(do_order)
{
   char name[100], message[256];
   char buf[256];
   bool found = FALSE, anyawake = FALSE;
   int org_room;
   struct char_data *vict;
   struct follow_type *k;

   half_chop(argument, name, message);

   if (!*name || !*message)
      send_to_char("Order who to do what?\r\n", ch);
   else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, name))) && !is_abbrev(name, "followers"))
      send_to_char("That person isn't here.\r\n", ch);
   else if (ch == vict)
      send_to_char("You obviously suffer from schizophrenia.\r\n", ch);
   else {
      /* modified to allow animateds to order - 321 */
      if (EFF_FLAGGED(ch, EFF_CHARM)) {
         send_to_char("Your superior would not approve of you giving orders.\r\n", ch);
         return;
      }
      if (vict) {
         act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);

         if (GET_STANCE(vict) < STANCE_RESTING) {
            sprintf(buf, "$N is %s and can't hear you.",
                  stance_types[GET_STANCE(vict)]);
            act(buf, FALSE, ch, 0, vict, TO_CHAR);
         } else {
            sprintf(buf, "$N orders you to '%s'", message);
            act(buf, FALSE, vict, 0, ch, TO_CHAR);
            if ((vict->master != ch) || !EFF_FLAGGED(vict, EFF_CHARM))
               act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
            else {
               send_to_char(OK, ch);
               command_interpreter(vict, message);
               WAIT_STATE(ch, PULSE_VIOLENCE / 2);
            }
         }
      } else {   /* This is order "followers" */
         act("$n calls out, '$T'.", FALSE, ch, 0, message, TO_ROOM);
         org_room = ch->in_room;
         for (k = ch->followers; k; k = k->next) {
            if (org_room == k->follower->in_room &&
                  EFF_FLAGGED(k->follower, EFF_CHARM)) {
               found = TRUE;
               if (GET_STANCE(k->follower) >= STANCE_RESTING) {
                  anyawake = TRUE;
                  command_interpreter(k->follower, message);
               }
            }
         }
         if (found) {
            if (anyawake) {
               WAIT_STATE(ch, PULSE_VIOLENCE / 2);
               send_to_char(OK, ch);
            } else {
               send_to_char("None of your subjects are awake.\r\n", ch);
            }
         } else
            send_to_char("Nobody here is a loyal subject of yours!\r\n", ch);
      }
   }
}


/**********************************************************************
 * generalized communication func, originally by Fred C. Merkel (Torg) *
 *********************************************************************/

ACMD(do_gen_comm)
{
  extern int level_can_shout;
  extern int holler_move_cost;
  struct descriptor_data *i;
  char color_on[24];
  bool shapechanged = FALSE;

  /* Array of flags which must _not_ be set in order for comm to be heard */
  static int channels[] = {
    0,
    PRF_DEAF,
    PRF_NOGOSS,
    0,
    0
  };

  /*
   * com_msgs: [0] Message if you can't perform the action because of noshout
   *           [1] name of the action
   *           [2] message if you're not on the channel
   *           [3] a color string.
   */
  static char *com_msgs[][4] = {
    {"You cannot holler!!\r\n",
     "holler",
     "",
     FYEL},

    {"You cannot shout!!\r\n",
     "shout",
     "Turn off your noshout flag first!\r\n",
     FYEL},

    {"You cannot gossip!!\r\n",
     "gossip",
     "You aren't even on the channel!\r\n",
     FYEL},

    {"You cannot congratulate!\r\n",
     "congrat",
     "You aren't even on the channel!\r\n",
     FGRN}
  };

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    cprintf(ch, "Your lips move, but no sound forms.\r\n");
    return;
  }
  if (PLR_FLAGGED(ch, PLR_NOSHOUT)) {
    cprintf(ch, "%s", com_msgs[subcmd][0]);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF) && GET_LEVEL(ch) < LVL_IMMORT) {
    cprintf(ch, "The walls seem to absorb your words.\r\n");
    return;
  }
  /* level_can_shout defined in config.c */
  if (GET_LEVEL(ch) < level_can_shout) {
    cprintf(ch, "You must be at least level %d before you can %s.\r\n",
	    level_can_shout, com_msgs[subcmd][1]);
    return;
  }

  /* make sure the char is on the channel */
  if (PRF_FLAGGED(ch, channels[subcmd])) {
    cprintf(ch, "%s", com_msgs[subcmd][2]);
    return;
  }


  /* This prevents gossiping when the channel is disabled... but allows gods */
  /*  to continue to do so... Selina, 3-26-99 */
  if (!gossip_channel_active && (GET_LEVEL(ch) < LVL_GOD) && (subcmd == SCMD_GOSSIP)) {
    cprintf(ch, "You try to gossip, but the heavens have disabled the channel for the time being.\r\n");
    return;
  }

  /* skip leading spaces */
  skip_spaces(&argument);

  /* make sure that there is something there to say! */
  if (!*argument) {
    cprintf(ch, "Yes, %s, fine, %s we must, but WHAT???\r\n",
	    com_msgs[subcmd][1], com_msgs[subcmd][1]);
    return;
  }
  if (subcmd == SCMD_HOLLER) {
    if ((int)GET_MOVE(ch) < holler_move_cost) {
      cprintf(ch, "You're too exhausted to holler.\r\n");
      return;
    } else
      alter_move(ch, holler_move_cost);
  }

  if (!speech_ok(ch, 0)) return;

  if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)
    argument = strip_ansi(argument);

  argument = drunken_speech(argument, GET_COND(ch, DRUNK));

  /* set up the color on code */
  strcpy(color_on, com_msgs[subcmd][3]);

  /* first, set up strings to be given to the communicator */
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    cprintf(ch, "%s", OK);
  else {
    if (COLOR_LEV(ch) >= C_CMP)
      sprintf(buf1, "%sYou %s, '%s%s%s'%s", color_on, com_msgs[subcmd][1],
	      argument, ANRM, color_on, ANRM);
    else
      sprintf(buf1, "You %s, '%s@@0'", com_msgs[subcmd][1], argument);
    act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP | TO_OLC);

  }

  sprintf(buf, "$n %ss, '%s'", com_msgs[subcmd][1], argument);

  /*
   * If the gossiper is shapechanged and this descriptor can see both
   * the shapechanged mob and the original druid, then use show
   * both names instead of just the actual gossiper.
   */
  if (subcmd == SCMD_GOSSIP && POSSESSED(ch) &&
      GET_LEVEL(POSSESSOR(ch)) < 100 &&
      GET_NAME(ch) && *GET_NAME(ch)) {
    shapechanged = TRUE;
    sprintf(buf1, "%c%s (%s) gossips, '%s'\r\n",
            UPPER(*GET_NAME(ch)), GET_NAME(ch) + 1,
            GET_NAME(POSSESSOR(ch)), argument);
  }

  /* now send all the strings out */
  for (i = descriptor_list; i; i = i->next) {
    if (!IS_PLAYING(i))
      continue;
    if (i == ch->desc || !i->character)
      continue;
    if (PRF_FLAGGED(i->character, channels[subcmd]))
      continue;
    if (ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF) &&
	GET_LEVEL(i->character) < LVL_IMMORT)
      continue;
    if (STATE(i) != CON_PLAYING || PLR_FLAGGED(i->character, PLR_WRITING) || PLR_FLAGGED(i->character, PLR_MAILING) || EDITING(i))
      if (!PRF_FLAGGED(i->character, PRF_OLCCOMM))
        continue;
    if (subcmd == SCMD_SHOUT &&
        (world[ch->in_room].zone != world[i->character->in_room].zone ||
         !AWAKE(i->character)))
      continue;

    if (COLOR_LEV(i->character) >= C_NRM)
      dprintf(i, "%s", color_on);

    /*
     * If the gossiper is shapechanged and this descriptor can see both
     * the shapechanged mob and the original druid, then use show
     * both names instead of just the actual gossiper.
     */
    if (shapechanged && CAN_SEE(i->character, ch) &&
        CAN_SEE(i->character, POSSESSOR(ch)))
      dprintf(i, "%s", buf1);
    else
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP | TO_OLC);

    if (COLOR_LEV(i->character) >= C_NRM)
      dprintf(i, "%s", ANRM);
  }
}

ACMD(do_qcomm)
{
  struct descriptor_data *i;

  if (!PRF_FLAGGED(ch, PRF_QUEST)) {
    cprintf(ch, "You aren't even part of the quest!\r\n");
    return;
  }
  skip_spaces(&argument);

  if (!*argument)
    cprintf(ch, "%c%s? Yes, fine %s we must, but WHAT??\r\n",
                 UPPER(*CMD_NAME), CMD_NAME, CMD_NAME);
  else if (speech_ok(ch, 0)) {
    argument = drunken_speech(argument, GET_COND(ch, DRUNK));

    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      cprintf(ch, "%s", OK);
    else {
      if (subcmd == SCMD_QSAY) {
        if (EFF_FLAGGED(ch, EFF_SILENCE)) {
	  cprintf(ch, "Your lips move, but no sound forms\r\n");
	  return;
	}
	sprintf(buf, "You quest-say, '%s@@0'", argument);
      }
      else
	strcpy(buf, argument);
      act(buf, FALSE, ch, 0, argument, TO_CHAR | TO_OLC | TO_SLEEP);
    }

    if (subcmd == SCMD_QSAY) {
      if (EFF_FLAGGED(ch, EFF_SILENCE)) {
	cprintf(ch, "Your lips move, but no sound forms\r\n");
	return;
      }
      sprintf(buf, "$n quest-says, '%s@@0'", argument);
    }
    else
      strcpy(buf, argument);

    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i != ch->desc &&
	  PRF_FLAGGED(i->character, PRF_QUEST))
	act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP | TO_OLC);
  }
}

ACMD(do_report)
{
  char rbuf[MAX_INPUT_LENGTH];

  one_argument(argument, arg);

  sprintf(rbuf, "%s%sI have %s%d%s (%d) hit and %s%d%s (%d) movement points.",
          subcmd != SCMD_GREPORT ? arg : "",
          subcmd != SCMD_GREPORT && *arg ? " " : "",
          status_string(GET_HIT(ch), GET_MAX_HIT(ch), STATUS_COLOR),
          GET_HIT(ch), ANRM, GET_MAX_HIT(ch),
          status_string(GET_MOVE(ch), GET_MAX_MOVE(ch), STATUS_COLOR),
          GET_MOVE(ch), ANRM, GET_MAX_MOVE(ch));

  if (subcmd == SCMD_GREPORT)
    do_gsay(ch, rbuf, 0, 0);
  else if (*arg)
    do_tell(ch, rbuf, 0, 0);
  else
    do_say(ch, rbuf, 0, 0);
}


/***************************************************************************
 * $Log: act.comm.c,v $
 * Revision 1.70  2009/06/20 23:55:13  myc
 * Clean up makedrunk and rename it drunken_speech.
 *
 * Revision 1.69  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.68  2009/02/21 03:30:16  myc
 * Modified write command to support new board system.
 *
 * Revision 1.67  2009/02/11 17:03:39  myc
 * Switching do_desc over to the new text editor.  Updating do_tell,
 * do_spec_comm, and do_gen_comm to handle new editor flag wherever
 * old WRITING flag was considered.
 *
 * Revision 1.66  2009/02/09 20:09:56  myc
 * Adding more color to report command.
 *
 * Revision 1.65  2008/09/27 04:18:00  jps
 * Fix greport color
 *
 * Revision 1.64  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.63  2008/09/14 19:47:01  jps
 * Fix bug in order.
 *
 * Revision 1.62  2008/09/13 16:35:24  jps
 * Moved do_order from fight.c. Unconscious followers can't be ordered.
 * You'll receive a message if you try to order one.
 *
 * Revision 1.61  2008/09/02 03:00:59  jps
 * Changed mob speech and ask triggers to respond to all speech.
 *
 * Revision 1.60  2008/08/31 21:04:46  myc
 * Terminate color on gossip.
 *
 * Revision 1.59  2008/08/30 20:42:50  myc
 * Ending all communication with a color reset.
 *
 * Revision 1.58  2008/08/16 23:04:03  jps
 * Added speech_ok() to comm.h.
 *
 * Revision 1.57  2008/08/16 08:22:41  jps
 * Added the 'desc' command and took player description-editing out of the pre-game menu.
 *
 * Revision 1.56  2008/08/14 23:02:11  myc
 * Replaced all send_to_char calls with cprintf.
 *
 * Revision 1.55  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.54  2008/05/11 05:41:31  jps
 * Using regen.h.
 *
 * Revision 1.53  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.52  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.51  2008/04/02 03:24:44  myc
 * Rewrote group code, and removed all major group code.
 *
 * Revision 1.50  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.49  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.48  2008/03/21 15:01:17  myc
 * Removed languages.
 *
 * Revision 1.47  2008/02/24 17:31:13  myc
 * Added a TO_OLC flag for act() so messages can be sent to people in
 * OLC if they have OLCComm toggled on.  You can now receive most types
 * of communication while in OLC if you have that toggled on.
 *
 * Revision 1.46  2008/02/10 20:30:03  myc
 * Add delete_doubledollar call to do_say so we don't get double
 * dollar signs in output.
 *
 * Revision 1.45  2008/02/09 06:19:44  jps
 * Add "nohints" toggle for whether you receive command suggestions
 * after entering a typo.
 *
 * Revision 1.44  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.43  2008/02/02 19:38:20  myc
 * Added string_write function to start the string editor more easily.
 *
 * Revision 1.42  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.41  2008/01/15 06:49:52  myc
 * When a mob had a trigger marked both ask and speech and the mob
 * was asked a question, that same trigger would be executed twice,
 * once as an ask trigger, and once as a speech trigger.  Fixed this
 * by going through the trigger list only once looking for ask or
 * speech triggers.  However, this isn't optimal--it should give
 * priority to ask triggers.
 *
 * Revision 1.40  2007/12/25 06:47:25  myc
 * Whoops, say wasn't showing the message to the room.
 *
 * Revision 1.39  2007/12/19 20:35:22  myc
 * Moved ctell from act.comm.c to clan.c.  Removed languages from say.
 *
 * Revision 1.38  2007/11/18 06:01:41  myc
 * Fixed clan tell bug that was reading past null bit.
 *
 * Revision 1.37  2007/10/02 02:52:27  myc
 * Druids can now send and receive tells while shapechanged.  This also
 * applies to switched immortals.  (The other party will see the player's
 * name instead of the shapechange's.)  Druids can also gossip while
 * shapechanged; it will show the druid's name as well as the shapechange.
 * Rewrote the report command to make use of gsay, msay, tell, and say,
 * instead of trying to reinvent the wheel.
 *
 * Revision 1.36  2007/08/14 10:43:36  jps
 * Add calls to speech_ok to many communication functions, so if you start
 * spamming a lot, you will get laryngitis.
 *
 * Revision 1.35  2007/08/03 22:00:11  myc
 * Say uses to_room when languages is off now, so the command works with
 * observatories.  Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.34  2007/07/13 19:21:22  jps
 * Fix crash bug where the leader of an ordinary group could bring
 * the mud down by using "msay" when not a member of a major group.
 *
 * Revision 1.33  2007/07/11 02:08:32  myc
 * Fixing a really bad memory corruption bug in makedrunk().
 *
 * Revision 1.32  2007/06/22 18:54:10  myc
 * Gods can send/hear tells/gossip/shouts in soundproof rooms.
 *
 * Revision 1.31  2006/11/20 22:24:17  jps
 * End the difficulties in interaction between evil and good player races.
 *
 * Revision 1.30  2006/11/13 15:54:22  jps
 * Fix widespread misuse of the hide_invisible parameter to act().
 *
 * Revision 1.29  2002/09/15 04:30:38  jjl
 * Gods can now reply to a player with no-tell.
 *
 * Revision 1.28  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.27  2002/01/11 03:13:29  dce
 * Cleaned up the file with lclint
 *
 * Revision 1.26  2001/03/30 23:34:50  dce
 * Out of character references have been removed per Zzur's
 * request.
 *
 * Revision 1.25  2001/03/24 15:43:31  dce
 * Players speech will be slurred when drunk.
 *
 * Revision 1.24  2001/01/23 01:50:11  rsd
 * made it so the afk messages don't make it through reply to
 * notell people.
 *
 * Revision 1.23  2001/01/13 21:07:08  dce
 * Changed do_tell to allow npcs to communicate to notell pcs.
 *
 * Revision 1.22  2000/11/28 00:41:25  mtp
 * removed mobprog references
 *
 * Revision 1.21  2000/11/19 03:05:28  rsd
 * Added back log messages from prior to the $log$ string
 * being added .
 *
 * Revision 1.20  2000/11/14 00:04:43  rsd
 * Added a check to do reply to check if a person is NOTELL.
 *
 * Revision 1.19  2000/11/11 01:39:51  mtp
 * added ask trigger for ask/whisper and aslso ask/whisper triggers speech trigger
 *
 * Revision 1.18  2000/10/14 01:16:58  rsd
 * put a check in do_gen_command to prevent animals from
 * gossiping etc..
 * /s
 * DOH
 *
 * Revision 1.17  2000/09/22 23:30:46  rsd
 * Altered the comment header to reflect that this is fiery
 * code now. Also deleted a silly comment near the top.
 *
 * Revision 1.16  1999/11/20 22:22:21  rsd
 * changed the output to the player when ooc is disabled.
 *
 * Revision 1.15  1999/09/09 03:47:26  mud
 * TESTTESTTEST
 *
 * Revision 1.14  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.13  1999/09/03 23:04:14  mtp
 * added IS_FIGTI check for write
 *
 * Revision 1.12  1999/08/18 22:41:04  mtp
 * added afk message for do_reply
 *
 * Revision 1.11  1999/08/13 21:38:00  mtp
 * make sure AFK message only happens on successful tell
 *
 * Revision 1.10  1999/08/09 22:34:31  mtp
 * Added response for tell/whisper/ask if victim is flagged AFK
 *
 * Revision 1.9  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
 * --Gurlaek 6/10/1999
 *
 * Revision 1.8  1999/04/16 15:17:13  jen
 * Changed do_tell so gods can tell notell players, but
 * still can't tell notell's higher than their level.
 * Selina
 *
 * Revision 1.7  1999/04/08 19:14:26  jen
 * OK, the gossip toggle was also getting shouts... fixed that
 *
 * Revision 1.6  1999/03/30 21:51:01  jen
 * Changed the message sent to characters when they gossip
 * to reflect that being a non-MUD-related channel; also made
 * the send-to-all message when a chr gossips less obnoxious.
 *
 * Revision 1.5  1999/03/30 19:09:56  jen
 * Changed the gossip messages a little... JEN II
 *
 * Revision 1.4  1999/03/26 19:44:35  jen
 * Added a mortal gossip channel with 103+ godly control
 *
 * Revision 1.3  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.2  1999/02/03 23:28:47  jimmy
 * changed symantics for gossip to "shouts from the heavens"
 *
 * Revision 1.1  1999/01/29 01:23:29  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.70
log
@Clean up makedrunk and rename it drunken_speech.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.69 2009/03/03 19:41:50 myc Exp myc $
d94 1
a94 1
  if (drunkenness) {
d797 3
@


1.69
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.68 2009/02/21 03:30:16 myc Exp myc $
d38 1
a38 2
/* Let's make drunkenness affect your speech - zantir 3/23/01 */
char *makedrunk(char *string, struct char_data *ch);
d50 66
d165 1
a165 1
  argument = makedrunk(argument, ch);
d198 1
a198 1
  argument = makedrunk(argument, ch);
d220 1
a220 1
void perform_tell(struct char_data *ch, struct char_data *vict, char *arg)
d277 1
a277 1
    argument = makedrunk(buf2, ch);
d308 1
a308 1
      argument = makedrunk(argument, ch);
d345 1
a345 1
    argument = makedrunk(buf2, ch);
d652 1
a652 1
  argument = makedrunk(argument, ch);
d738 1
a738 1
    argument = makedrunk(argument, ch);
a771 113
/*
 * Drunk structure and releated code to slur a players speech
 * if they are drunk. Zantir 3/23/01
 */
struct drunk_struct
{
        int     min_drunk_level;
        int     number_of_rep;
        char    *replacement[11];
};

char    *makedrunk(char *string ,struct char_data *ch);

char * makedrunk (char *string, struct char_data * ch)
{

/* This structure defines all changes for a character */
  struct drunk_struct drunk[] =
  {
    {3, 10,
      {"a", "a", "a", "A", "aa", "ah", "Ah", "ao", "aw", "oa", "ahhhh"}},
    {8, 5,
     {"b", "b", "b", "B", "B", "vb", "X", "X", "X", "X", "X"}},
    {3, 5,
     {"c", "c", "C", "cj", "sj", "zj", "X", "X", "X", "X", "X"}},
    {5, 2,
     {"d", "d", "D", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {3, 3,
     {"e", "e", "eh", "E", "X", "X", "X", "X", "X", "X", "X"}},
    {4, 5,
     {"f", "f", "ff", "fff", "fFf", "F", "X", "X", "X", "X", "X"}},
    {8, 2,
     {"g", "g", "G", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {9, 6,
     {"h", "h", "hh", "hhh", "Hhh", "HhH", "H", "X", "X", "X", "X"}},
    {7, 6,
     {"i", "i", "Iii", "ii", "iI", "Ii", "I", "X", "X", "X", "X"}},
    {9, 5,
     {"j", "j", "jj", "Jj", "jJ", "J", "X", "X", "X", "X", "X"}},
    {7, 2,
     {"k", "k", "K", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {3, 2,
     {"l", "l", "L", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {5, 8,
     {"m", "m", "mm", "mmm", "mmmm", "mmmmm", "MmM", "mM", "M", "X", "X"}},
    {6, 6,
     {"n", "n", "nn", "Nn", "nnn", "nNn", "N", "X", "X", "X", "X"}},
    {3, 6,
     {"o", "o", "ooo", "ao", "aOoo", "Ooo", "ooOo", "X", "X", "X", "X"}},
    {3, 2,
     {"p", "p", "P", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {5, 5,
     {"q", "q", "Q", "ku", "ququ", "kukeleku", "X", "X", "X", "X", "X"}},
    {4, 2,
     {"r", "r", "R", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {2, 5,
     {"s", "ss", "zzZzssZ", "ZSssS", "sSzzsss", "sSss", "X", "X", "X", "X", "X"}},
    {5, 2,
     {"t", "t", "T", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {3, 6,
     {"u", "u", "uh", "Uh", "Uhuhhuh", "uhU", "uhhu", "X", "X", "X", "X"}},
    {4, 2,
     {"v", "v", "V", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {4, 2,
     {"w", "w", "W", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {5, 6,
     {"x", "x", "X", "ks", "iks", "kz", "xz", "X", "X", "X", "X"}},
    {3, 2,
     {"y", "y", "Y", "X", "X", "X", "X", "X", "X", "X", "X"}},
    {2, 9,
     {"z", "z", "ZzzZz", "Zzz", "Zsszzsz", "szz", "sZZz", "ZSz", "zZ", "Z", "X"}}
  };

  static char buf[4000];      /* this should be enough (?) */
  char temp;
  int pos = 0;
  int randomnum;

  if(GET_COND(ch, DRUNK) > 0)  /* character is drunk */
  {
     do
     {
       temp = toupper(*string);
       if( (temp >= 'A') && (temp <= 'Z') )
       {
         if(GET_COND(ch, DRUNK) > drunk[(temp - 'A')].min_drunk_level)
         {
           randomnum = number(0, (drunk[(temp - 'A')].number_of_rep));
           strcpy(&buf[pos], drunk[(temp - 'A')].replacement[randomnum]);
           pos += strlen(drunk[(temp - 'A')].replacement[randomnum]);
         }
         else
           buf[pos++] = *string;
       }
       else
       {
         if ((temp >= '0') && (temp <= '9'))
         {
           temp = '0' + number(0, 9);
           buf[pos++] = temp;
         }
         else
           buf[pos++] = *string;
       }
     }while (*string++);

     buf[pos] = '\0';          /* Mark end of the string... */
     return(buf);
  }
  return (string); /* character is not drunk, just return the string */
}


d797 3
@


1.68
log
@Modified write command to support new board system.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.67 2009/02/11 17:03:39 myc Exp myc $
d189 1
a189 1
  else if (!(vict = get_char_vis(ch, buf)))
d268 1
a268 1
  else if (!(vict = get_char_room_vis(ch, buf)))
d403 1
a403 1
    if ((vict = get_char_vis(ch, arg)) != NULL) {
d428 1
a428 1
   else if (!(vict = get_char_room_vis(ch, name)) && !is_abbrev(name, "followers"))
d845 3
@


1.67
log
@Switching do_desc over to the new text editor.  Updating do_tell,
do_spec_comm, and do_gen_comm to handle new editor flag wherever
old WRITING flag was considered.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.66 2009/02/09 20:09:56 myc Exp myc $
d33 1
d300 3
a302 2
  struct obj_data *paper = 0, *pen = 0;
  char *papername, *penname;
d304 9
a312 2
  papername = buf1;
  penname = buf2;
d314 2
a315 1
  two_arguments(argument, papername, penname);
d317 2
a318 1
  if (!ch->desc)
d320 1
d322 3
a324 2
  if (!*papername) {		/* nothing was delivered */
    cprintf(ch, "Write?  With what?  ON what?  What are you trying to do?!?\r\n");
d327 8
a334 3
  if (*penname) {		/* there were two arguments */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      cprintf(ch, "You have no %s.\r\n", papername);
d337 16
a352 2
    if (!(pen = get_obj_in_list_vis(ch, penname, ch->carrying))) {
      cprintf(ch, "You have no %s.\r\n", penname);
a354 26
  } else {		/* there was one arg.. let's see what we can find */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      cprintf(ch, "There is no %s in your inventory.\r\n", papername);
      return;
    }
    if (GET_OBJ_TYPE(paper) == ITEM_PEN) {	/* oops, a pen.. */
      pen = paper;
      paper = 0;
    } else if (GET_OBJ_TYPE(paper) != ITEM_NOTE) {
      cprintf(ch, "That thing has nothing to do with writing.\r\n");
      return;
    }
    /* One object was found.. now for the other one. */
    if (!GET_EQ(ch, WEAR_HOLD)) {
      cprintf(ch, "You can't write with %s %s alone.\r\n", AN(papername),
	      papername);
      return;
    }
    if (!CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD))) {
      cprintf(ch, "The stuff in your hand is invisible!  Yeech!!\r\n");
      return;
    }
    if (pen)
      paper = GET_EQ(ch, WEAR_HOLD);
    else
      pen = GET_EQ(ch, WEAR_HOLD);
d357 12
d370 3
a372 10
  /* ok.. now let's see what kind of stuff we've found */
  if (GET_OBJ_TYPE(pen) != ITEM_PEN)
    act("$p is no good for writing with.", FALSE, ch, pen, 0, TO_CHAR);
  else if (GET_OBJ_TYPE(paper) != ITEM_NOTE)
    act("You can't write on $p.", FALSE, ch, paper, 0, TO_CHAR);
  else {
    /* we can write - hooray! */
    cprintf(ch, "Write your note.  (/s saves /h for help)\r\n");
    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH);
    act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
d374 5
d845 5
@


1.66
log
@Adding more color to report command.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.65 2008/09/27 04:18:00 jps Exp myc $
d32 1
a68 6
   cprintf(ch,
         "Enter the text you'd like others to see when they look at you (limit %d lines).\r\n",
         maxlines);
   cprintf(ch, "(/s saves; /h for help)\r\n");
   STATE(ch->desc) = CON_EXDESC;
   string_write_limit(ch->desc, &ch->player.description, maxlen, maxlines);
d71 6
d201 3
d274 3
d616 1
a616 1
    if (STATE(i) != CON_PLAYING || PLR_FLAGGED(i->character, PLR_WRITING) || PLR_FLAGGED(i->character, PLR_MAILING))
d829 3
@


1.65
log
@Fix greport color
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.64 2008/09/20 06:05:06 jps Exp jps $
d31 1
d804 3
a806 2
          arg, *arg ? " " : "",
          GET_HIT(ch) < GET_MAX_HIT(ch) * 0.2 ? AFRED : "",
d808 1
a808 1
          GET_MOVE(ch) < GET_MAX_MOVE(ch) * 0.2 ? AFRED : "",
d822 3
@


1.64
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.63 2008/09/14 19:47:01 jps Exp jps $
d136 1
a136 1
  sprintf(buf, "@@g$n@@g tells the group, '@@G%s@@g'@@0", argument);
d146 1
a146 1
    sprintf(buf, "@@gYou group say, '@@G%s@@g'@@0", argument);
d820 3
@


1.63
log
@Fix bug in order.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.62 2008/09/13 16:35:24 jps Exp jps $
d588 2
a589 2
  if (subcmd == SCMD_GOSSIP && ch->desc && ch->desc->original &&
      GET_LEVEL(ch->desc->original) < 100 &&
d594 1
a594 1
            GET_NAME(ch->desc->original), argument);
d625 1
a625 1
        CAN_SEE(i->character, ch->desc->original))
d820 3
@


1.62
log
@Moved do_order from fight.c. Unconscious followers can't be ordered.
You'll receive a message if you try to order one.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.61 2008/09/02 03:00:59 jps Exp jps $
d439 1
a439 1
               if (GET_STANCE(vict) >= STANCE_RESTING) {
d820 4
@


1.61
log
@Changed mob speech and ask triggers to respond to all speech.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.60 2008/08/31 21:04:46 myc Exp jps $
d30 1
d391 67
d820 3
@


1.60
log
@Terminate color on gossip.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.59 2008/08/30 20:42:50 myc Exp myc $
d41 1
a41 1
  
d80 1
a80 1
  
d89 1
a89 1
  
d97 1
a97 1
    
d111 1
a111 1
  
d120 1
a120 1
  
d128 1
a128 1
  
d162 1
a162 1
  
d168 1
a168 1
  
d171 2
d179 1
a179 1
  
d181 2
a182 2
  
  
d200 1
a200 1
  else if (!IS_NPC(REAL_CHAR(vict)) && 
d213 1
a213 1
  
d215 1
a215 1
  
d227 1
a227 1
    
d230 1
a230 1
    
d246 1
a246 1
  
d256 1
a256 1
  
d258 1
a258 1
  
a280 1
    /* waste of time to try for a PC!*/
d282 1
a282 1
      ask_speech_mtrigger(ch, vict, argument);
d292 1
a292 1
  
d295 1
a295 1
  
d297 1
a297 1
  
d300 1
a300 1
  
d341 2
a342 2
  
  
d360 1
a360 1
  
d362 1
a362 1
  
d402 1
a402 1
  
d411 1
a411 1
  
d423 1
a423 1
    
d428 1
a428 1
    
d433 1
a433 1
    
d439 1
a439 1
  
d475 1
a475 1
  
d499 1
a499 1
  
d516 2
a517 2
   * If the gossiper is shapechanged and this descriptor can see both 
   * the shapechanged mob and the original druid, then use show 
d525 1
a525 1
            UPPER(*GET_NAME(ch)), GET_NAME(ch) + 1, 
d552 2
a553 2
     * If the gossiper is shapechanged and this descriptor can see both 
     * the shapechanged mob and the original druid, then use show 
d570 1
a570 1
  
d576 1
a576 1
  
d597 1
a597 1
    
d607 1
a607 1
    
d625 1
a625 1
 
d630 1
a630 1
 
d687 1
a687 1
 
d692 1
a692 1
 
d720 1
a720 1
 
d725 1
a725 1
} 
d752 3
d937 3
a939 3
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to 
 * clarify their behavior to the compiler.  The name approval code was also 
d941 1
a941 1
 * array to a linked list to allow for on the fly adding of names to the 
@


1.59
log
@Ending all communication with a color reset.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.58 2008/08/16 23:04:03 jps Exp myc $
d504 2
a505 2
      sprintf(buf1, "%sYou %s, '%s%s%s'", color_on, com_msgs[subcmd][1],
	      argument, ANRM, color_on);
d751 3
@


1.58
log
@Added speech_ok() to comm.h.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.57 2008/08/16 08:22:41 jps Exp jps $
d98 2
a99 2
  act("You say, '$T'", FALSE, ch, 0, argument, TO_CHAR | TO_OLC);
  act("$n says, '$T'", FALSE, ch, 0, argument, TO_ROOM | TO_OLC);
d135 1
a135 1
  sprintf(buf, "&0&2$n tells the group, '&0&b&2%s&0&2'&0", argument);
d145 1
a145 1
    sprintf(buf, "&0&2You group say, '&0&b&2%s&0&2'&0", argument);
d159 1
a159 1
    sprintf(buf, "&0&8You tell $N, '%s'&0", arg);
d166 1
a166 1
  sprintf(buf, "&0&8$n tells you, '%s'&0", arg);
d269 1
a269 1
    sprintf(buf, "$n %s you, '%s'", action_plur, argument);
d274 1
a274 1
      sprintf(buf, "You %s %s, '%s'", action_sing, GET_NAME(vict), argument);
d504 2
a505 2
      sprintf(buf1, "%sYou %s, '%s'%s", color_on, com_msgs[subcmd][1],
	      argument, ANRM);
d507 1
a507 1
      sprintf(buf1, "You %s, '%s'", com_msgs[subcmd][1], argument);
d590 1
a590 1
	sprintf(buf, "You quest-say, '%s'", argument);
d602 1
a602 1
      sprintf(buf, "$n quest-says, '%s'", argument);
d751 3
@


1.57
log
@Added the 'desc' command and took player description-editing out of the pre-game menu.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.56 2008/08/14 23:02:11 myc Exp jps $
a35 1
int speech_ok(struct char_data *ch, int quiet);
d751 3
@


1.56
log
@Replaced all send_to_char calls with cprintf.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.55 2008/08/14 09:45:22 jps Exp myc $
d55 22
d752 3
@


1.55
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.54 2008/05/11 05:41:31 jps Exp jps $
d51 1
a51 1
    send_to_char("You received the previous message while AFK.\r\n", vict);
d61 1
a61 1
    send_to_char("You lips move, but no sound forms.\r\n", ch);
d65 1
a65 1
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
d92 1
a92 1
    send_to_char("But you are not the member of a group!\r\n", ch);
d96 1
a96 1
    send_to_char("You lips move, but no sound forms.\r\n", ch);
d101 1
a101 1
    send_to_char("Yes, but WHAT do you want to group-say?\r\n", ch);
d122 1
a122 1
    send_to_char(OK, ch);
d136 1
a136 1
    send_to_char(OK, ch);
d161 1
a161 1
    send_to_char("Who do you wish to tell what??\r\n", ch);
d163 1
a163 1
    send_to_char(NOPERSON, ch);
d165 1
a165 1
    send_to_char("You try to tell yourself something.\r\n", ch);
d167 1
a167 1
    send_to_char("You can't tell other people while you have notell on.\r\n", ch);
d169 1
a169 1
    send_to_char("The walls seem to absorb your words.\r\n", ch);
d194 1
a194 1
    send_to_char("You have no-one to reply to!\r\n", ch);
d196 1
a196 1
    send_to_char("What is your reply?\r\n", ch);
d208 7
a214 10
    if (tch == NULL) {
      send_to_char("They are no longer playing.\r\n", ch);
    } else {
      if (PRF_FLAGGED(tch, PRF_NOTELL) && GET_LEVEL(ch) < LVL_GOD) {
	send_to_char("That person is now not listening to tells.\r\n",ch);	
      } else { 
        if (!speech_ok(ch, 0)) return;
        argument = makedrunk(argument, ch);
	perform_tell(ch, tch, argument);
      }
d236 4
a239 5
  if (!*buf || !*buf2) {
    sprintf(buf, "Whom do you want to %s.. and what??\r\n", action_sing);
    send_to_char(buf, ch);
  } else if (!(vict = get_char_room_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
d241 1
a241 1
    send_to_char("You can't get your mouth close enough to your ear...\r\n", ch);
d251 1
a251 1
      send_to_char(OK, ch);
d280 1
a280 1
    send_to_char("Write?  With what?  ON what?  What are you trying to do?!?\r\n", ch);
d285 1
a285 2
      sprintf(buf, "You have no %s.\r\n", papername);
      send_to_char(buf, ch);
d289 1
a289 2
      sprintf(buf, "You have no %s.\r\n", penname);
      send_to_char(buf, ch);
d294 1
a294 2
      sprintf(buf, "There is no %s in your inventory.\r\n", papername);
      send_to_char(buf, ch);
d301 1
a301 1
      send_to_char("That thing has nothing to do with writing.\r\n", ch);
d306 1
a306 1
      sprintf(buf, "You can't write with %s %s alone.\r\n", AN(papername),
a307 1
      send_to_char(buf, ch);
d311 1
a311 1
      send_to_char("The stuff in your hand is invisible!  Yeech!!\r\n", ch);
d328 1
a328 1
    send_to_char("Write your note.  (/s saves /h for help)\r\n", ch);
d342 1
a342 1
    send_to_char("Monsters can't page.. go away.\r\n", ch);
d344 1
a344 1
    send_to_char("Whom do you wish to page?\r\n", ch);
d353 1
a353 1
	send_to_char("You will never be godly enough to do that!\r\n", ch);
d359 1
a359 1
	send_to_char(OK, ch);
d364 1
a364 1
      send_to_char("There is no such person in the game!\r\n", ch);
d419 1
a419 1
    send_to_char("Your lips move, but no sound forms.\r\n", ch);
d423 1
a423 1
    send_to_char(com_msgs[subcmd][0], ch);
d427 1
a427 1
    send_to_char("The walls seem to absorb your words.\r\n", ch);
d432 1
a432 1
    sprintf(buf1, "You must be at least level %d before you can %s.\r\n",
a433 1
    send_to_char(buf1, ch);
d439 1
a439 1
    send_to_char(com_msgs[subcmd][2], ch);
d447 1
a447 1
    send_to_char("You try to gossip, but the heavens have disabled the channel for the time being.\r\n", ch);
d456 1
a456 1
    sprintf(buf1, "Yes, %s, fine, %s we must, but WHAT???\r\n",
a457 1
    send_to_char(buf1, ch);
d462 1
a462 1
      send_to_char("You're too exhausted to holler.\r\n", ch);
d480 1
a480 1
    send_to_char(OK, ch);
d527 1
a527 1
      send_to_char(color_on, i->character);
d536 1
a536 1
      send_to_char(buf1, i->character);
d541 1
a541 1
      send_to_char(ANRM, i->character);
d550 1
a550 1
    send_to_char("You aren't even part of the quest!\r\n", ch);
d555 4
a558 7
  if (!*argument) {
    sprintf(buf, "%s?  Yes, fine, %s we must, but WHAT??\r\n", CMD_NAME,
	    CMD_NAME);
    CAP(buf);
    send_to_char(buf, ch);
  } else {
    if (!speech_ok(ch, 0)) return;
d562 1
a562 1
      send_to_char(OK, ch);
d565 2
a566 2
        if(EFF_FLAGGED(ch, EFF_SILENCE)) {
	  send_to_char("Your lips move, but no sound forms\r\n", ch);
d577 2
a578 2
      if(EFF_FLAGGED(ch, EFF_SILENCE)) {
	send_to_char("Your lips move, but no sound forms\r\n", ch);
d730 3
@


1.54
log
@Using regen.h.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.53 2008/04/07 03:02:54 jps Exp jps $
d29 1
d743 3
@


1.53
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.52 2008/04/03 02:02:05 myc Exp jps $
d28 1
d742 4
@


1.52
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.51 2008/04/02 03:24:44 myc Exp myc $
d531 1
a531 1
        GET_POS(i->character) < POS_RESTING))
d741 3
@


1.51
log
@Rewrote group code, and removed all major group code.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.50 2008/03/28 17:54:53 myc Exp myc $
a66 4
  if (GET_LEVEL(ch) < LVL_IMMORT && strchr(argument, '&'))  {
    send_to_char("No ampersand sign allowed in input.\r\n", ch);
    return;
  }
d70 3
a88 5
  if (GET_LEVEL(ch) < LVL_IMMORT && strchr(argument, '&')) {
    send_to_char("No ampersand sign allowed in input.\r\n", ch);
    return;
  }
  
d103 3
d130 2
a131 4
  if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT && strchr(arg, '&')) {
    send_to_char("No ampersand sign allowed in input.\r\n", ch);
    return;
  }
d406 1
a406 1
     KYEL},
d411 1
a411 1
     KYEL},
d416 1
a416 1
     KYEL},
d421 1
a421 1
     KGRN}
a467 5
  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.\r\n", ch);
      return;
    }
d478 3
d492 1
a492 1
	      argument, KNRM);
d549 1
a549 1
      send_to_char(KNRM, i->character);
d725 4
a728 4
          GET_HIT(ch) < GET_MAX_HIT(ch) * 0.2 ? KRED : "",
          GET_HIT(ch), KNRM, GET_MAX_HIT(ch),
          GET_MOVE(ch) < GET_MAX_MOVE(ch) * 0.2 ? KRED : "",
          GET_MOVE(ch), KNRM, GET_MAX_MOVE(ch));
d741 3
@


1.50
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.49 2008/03/22 03:22:38 myc Exp myc $
d86 2
a87 1
  struct char_data *k;struct group_type *f;
d95 1
a95 1
  if (!EFF_FLAGGED(ch, EFF_GROUP)) {
d110 2
a111 2
  if (ch->groupmaster)
    k = ch->groupmaster;
d116 1
a116 1
  if (EFF_FLAGGED(k, EFF_GROUP) && k != ch)
d119 1
a119 1
    if (EFF_FLAGGED(f->groupee, EFF_GROUP) && f->groupee != ch)
a130 78
ACMD(do_msay)
{
   struct char_data *k = NULL;
   struct mgroup_type *f; struct group_type *g;
   
   skip_spaces(&argument);
   
   if (GET_LEVEL(ch) < LVL_IMMORT && strchr(argument, '&')) {
      send_to_char("No ampersand sign allowed in input.\r\n", ch);
      return;
   }

   if (!EFF_FLAGGED(ch, EFF_GROUP)) {
      send_to_char("But you are not even a member of a normal group!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_SILENCE)) {
      send_to_char("You lips move, but no sound forms.\r\n", ch);
      return;
   }
   
   if (!*argument) {
      send_to_char("Yes, but WHAT do you want to major group-say?\r\n", ch);
      return;
   }

   argument = makedrunk(argument, ch);
   if (ch->mgroupmaster)
      k = ch->mgroupmaster;
   else if (ch->mgroupees)/*mgroup master*/
      k = ch;
   else if (ch->groupmaster) {
      if (ch->groupmaster->mgroupmaster)
         k = ch->groupmaster->mgroupmaster;
      else if (ch->groupmaster->mgroupees)
         k = ch->groupmaster;
      else {
         send_to_char("You are not in a major group.\r\n", ch);
         return;
      }
   } else {
      send_to_char("You are not in a major group.\r\n", ch);
      return;
   }
         
   sprintf(buf, "&0&1$n tells the major group, '&0&1&b%s&0&1'&0", argument);

   if (EFF_FLAGGED(k, EFF_GROUP) && (k != ch))
      act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP | TO_OLC);

   for (f = k->mgroupees; f; f = f->next) {

      if (EFF_FLAGGED(f->mgroupee, EFF_MAJOR_GROUP) && (f->mgroupee != ch)) {   
         act(buf, FALSE, ch, 0, f->mgroupee, TO_VICT | TO_SLEEP | TO_OLC);

         /*loop through this guys normal groupee's*/
         for (g=f->mgroupee->groupees;g;g=g->next) {
            if (EFF_FLAGGED(g->groupee, EFF_GROUP))
               act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP | TO_OLC);
         }
      }
   }

   /*loop through leaders group*/
   for (g = k->groupees; g; g = g->next) {
      if ((EFF_FLAGGED(g->groupee, EFF_GROUP)) && (g->groupee != ch))
         act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP | TO_OLC);
   }
         
   if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
   else {
      sprintf(buf, "&0&1You major group say, '&0&1&b%s&0&1'&0", argument);
      act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP | TO_OLC);
   }
}

a738 2
  else if (subcmd == SCMD_MREPORT)
    do_msay(ch, rbuf, 0, 0);
d748 4
@


1.49
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.48 2008/03/21 15:01:17 myc Exp myc $
d58 1
a58 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d94 1
a94 1
  if (!AFF_FLAGGED(ch, AFF_GROUP)) {
d98 1
a98 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d115 1
a115 1
  if (AFF_FLAGGED(k, AFF_GROUP) && k != ch)
d118 1
a118 1
    if (AFF_FLAGGED(f->groupee, AFF_GROUP) && f->groupee != ch)
d142 1
a142 1
   if (!IS_AFFECTED(ch, AFF_GROUP)) {
d147 1
a147 1
   if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d178 1
a178 1
   if (IS_AFFECTED(k, AFF_GROUP) && (k != ch))
d183 1
a183 1
      if (IS_AFFECTED2(f->mgroupee, AFF2_MGROUP) && (f->mgroupee != ch)) {   
d188 1
a188 1
            if (IS_AFFECTED(g->groupee, AFF_GROUP))
d196 1
a196 1
      if ((IS_AFFECTED(g->groupee, AFF_GROUP)) && (g->groupee != ch))
d506 1
a506 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d610 1
a610 1
    if (STATE(i) != CON_PLAYING || PLR_FLAGGED(i->character, PLR_WRITING | PLR_MAILING))
d660 1
a660 1
        if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d672 1
a672 1
      if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d827 6
@


1.48
log
@Removed languages.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.47 2008/02/24 17:31:13 myc Exp myc $
d417 1
a417 9
    /*
     * Here we check for a message ALREADY on the paper.  Show
     * it to the player since it's in the buffer.
     */
    if (paper->action_description)
      send_to_char(paper->action_description, ch);
    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH,
                 0, strdup(paper->action_description));

d827 3
@


1.47
log
@Added a TO_OLC flag for act() so messages can be sent to people in
OLC if they have OLCComm toggled on.  You can now receive most types
of communication while in OLC if you have that toggled on.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.46 2008/02/10 20:30:03 myc Exp myc $
a209 5
  extern char *languages[];
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
  int ofs = 190;              /* offset - should be first language */
  
d218 1
a218 3
    send_to_char(CCWHT(ch, C_CMP), ch);
    sprintf(buf, "&0&b&8You tell $N, '%s'&0", arg);
    
a219 1
    send_to_char(CCNRM(ch, C_CMP), ch);
d225 1
a225 21
  send_to_char(CCWHT(vict, C_NRM), vict);
  
  strcpy(ibuf, arg);     /* save real tell */
#ifdef LANGUAGES
  if (!IS_NPC(ch))
    garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif
  strcpy(obuf, ibuf);
#ifdef LANGUAGES
  if (!IS_NPC(ch))
    garble_text(obuf, GET_SKILL(vict, SPEAKING(ch)));
#endif
  if (!IS_NPC(ch) && GET_LEVEL(ch) < LVL_GOD) {
    sprintf(buf, "&0&b&8$n tells you in %s, '%s'&0", languages[(SPEAKING(ch) - ofs)], obuf);
#ifdef LANGUAGES
    improve_lang(vict, ch, SPEAKING(ch));
    improve_lang(ch, ch, SPEAKING(ch));
#endif
  }
  else
    sprintf(buf, "&0&b&8$n tells you, '%s'&0", arg);
a226 1
  send_to_char(CCWHT(vict, C_NRM), vict);
a305 2
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
d332 1
a332 12
    strcpy(ibuf, argument);     /* save real tell */
#ifdef LANGUAGES
    if (!IS_NPC(ch))
      garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif
    strcpy(obuf, ibuf);
#ifdef LANGUAGES
    garble_text(obuf, GET_SKILL(vict, SPEAKING(ch)));
    improve_lang(vict, ch, SPEAKING(ch));
    improve_lang(ch, ch, SPEAKING(ch));
#endif
    sprintf(buf, "$n %s you, '%s'", action_plur, obuf);
a695 20
void improve_lang(struct char_data *ch, struct char_data *tch, int skill)
{
  /*  extern char *spells[];*/
  extern char *languages[];
  sh_int percent = GET_ISKILL(ch, skill);
  int newpercent;
  int ofs = 190;
  char skillbuf[MAX_STRING_LENGTH];
  
  if (number(1, 200) > GET_WIS(ch) + GET_INT(ch))
    return;
  if (percent >= 970 || percent <= 0)
    return;
  newpercent = number(10, 30);
  percent += newpercent;
  SET_SKILL(ch, skill, percent);
  sprintf(skillbuf, "You feel your knowledge in %s language improving.\r\n", languages[(SPEAKING(tch) - ofs)]);
  send_to_char(skillbuf, ch);
}

d835 5
@


1.46
log
@Add delete_doubledollar call to do_say so we don't get double
dollar signs in output.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.45 2008/02/09 06:19:44 jps Exp myc $
d46 7
d76 2
a77 2
  act("You say, '$T'", FALSE, ch, 0, argument, TO_CHAR);
  act("$n says, '$T'", FALSE, ch, 0, argument, TO_ROOM);
d116 1
a116 1
    act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
d119 1
a119 1
      act(buf, FALSE, ch, 0, f->groupee, TO_VICT | TO_SLEEP);
d125 1
a125 1
    act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
d179 1
a179 1
      act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
d184 1
a184 1
         act(buf, FALSE, ch, 0, f->mgroupee, TO_VICT | TO_SLEEP);
d189 1
a189 1
               act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
d197 1
a197 1
         act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
d204 1
a204 1
      act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
d226 1
a226 1
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
d254 1
a254 1
  act(buf, FALSE, REAL_CHAR(ch), 0, vict, TO_VICT | TO_SLEEP);
d258 1
a258 4
  if (PRF_FLAGGED(vict, PRF_AFK)) {
    send_to_char("That person is AFK right now but received your message\r\n",ch);
    send_to_char("You received the previous message while AFK\r\n",vict);
  }
d280 2
a281 2
    act("No one here by that name.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
d283 1
a283 1
	FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
d285 1
a285 1
    act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
d288 1
a288 1
    act("$N is ignoring you at the moment.  No dice.", FALSE, ch, 0, REAL_CHAR(vict), TO_CHAR);
d357 3
d375 1
a375 1
    act(buf, FALSE, ch, 0, vict, TO_VICT);
d380 1
a380 1
      act(buf, FALSE, ch, 0, 0, TO_CHAR);
d383 1
a383 4
    if (PRF_FLAGGED(vict, PRF_AFK)) {
      send_to_char("That person is AFK right now but received your message\r\n",ch);
      send_to_char("You received the previous message while AFK\r\n",vict);
    }
d629 1
a629 1
    act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
d651 30
a680 24
    if (!i->connected && i != ch->desc && i->character &&
	!PRF_FLAGGED(i->character, channels[subcmd]) &&
	!PLR_FLAGGED(i->character, PLR_WRITING) &&
	(!ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF) ||
	GET_LEVEL(i->character) >= LVL_IMMORT)) {
      
      if (subcmd == SCMD_SHOUT &&
	  ((world[ch->in_room].zone != world[i->character->in_room].zone) ||
	   GET_POS(i->character) < POS_RESTING))
	continue;
      
      if (COLOR_LEV(i->character) >= C_NRM)
	send_to_char(color_on, i->character);

      /*
       * If the gossiper is shapechanged and this descriptor can see both 
       * the shapechanged mob and the original druid, then use show 
       * both names instead of just the actual gossiper.
       */
      if (shapechanged && CAN_SEE(i->character, ch) &&
          CAN_SEE(i->character, ch->desc->original))
        send_to_char(buf1, i->character);
      else
        act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);
d682 2
a683 3
      if (COLOR_LEV(i->character) >= C_NRM)
	send_to_char(KNRM, i->character);
    }
d718 1
a718 1
      act(buf, FALSE, ch, 0, argument, TO_CHAR);
d734 1
a734 1
	act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP);
d897 4
@


1.45
log
@Add "nohints" toggle for whether you receive command suggestions
after entering a typo.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.44 2008/02/09 04:27:47 myc Exp jps $
d49 1
d888 4
@


1.44
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.43 2008/02/02 19:38:20 myc Exp myc $
d519 1
a519 1
    PRF_NOGRATZ,
d887 3
@


1.43
log
@Added string_write function to start the string editor more easily.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.42 2008/01/29 21:02:31 myc Exp myc $
d27 1
d887 3
@


1.42
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.41 2008/01/15 06:49:52 myc Exp myc $
a393 4
  if (IS_FIGHTING(ch)) {
    send_to_char("You are finding it too hard to keep the pen on the paper...\n\r",ch);
    return;
  }
a449 2
  else if (paper->action_description)
    send_to_char("There's something written on it already.\r\n", ch);
d452 4
a455 4
    /* send_to_char("Write your note.  End with '@@' on a new line.\r\n", ch);*/
    /* this is the PERFECT code example of how to set up:
     * a) the text editor with a message already loaed
     * b) the abort buffer if the player aborts the message
d457 1
a457 9
    ch->desc->backstr = NULL;
    /*ch->desc->backstr == NULL this was what it was, hurm banyal*/
    send_to_char("Write your note.  (/s saves /h for help)\r\n", ch);
    /* ok, here we check for a message ALREADY on the paper */
    if (paper->action_description) {
      /* we str_dup the original text to the descriptors->backstr */
      ch->desc->backstr = str_dup(paper->action_description);
      /* send to the player what was on the paper (cause this is already */
      /* loaded into the editor) */
d459 3
a461 1
    }
a462 5
    /* assign the descriptor's->str the value of the pointer to the text */
    /* pointer so that we can reallocate as needed (hopefully that made */
    /* sense :>) */
    ch->desc->str = &paper->action_description;
    ch->desc->max_str = MAX_NOTE_LENGTH;
d886 4
@


1.41
log
@When a mob had a trigger marked both ask and speech and the mob
was asked a question, that same trigger would be executed twice,
once as an ask trigger, and once as a speech trigger.  Fixed this
by going through the trigger list only once looking for ask or
speech triggers.  However, this isn't optimal--it should give
priority to ask triggers.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.40 2007/12/25 06:47:25 myc Exp myc $
a28 4
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;

d903 8
@


1.40
log
@Whoops, say wasn't showing the message to the room.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.39 2007/12/19 20:35:22 myc Exp myc $
d374 1
a374 1
      sprintf(buf, "You %s %s, '%s'\r\n", action_sing, GET_NAME(vict), argument);
d384 1
a384 4
    {
    	ask_mtrigger(ch, vict, argument);
    	speech_mtrigger(ch, argument);
    }
d907 3
@


1.39
log
@Moved ctell from act.comm.c to clan.c.  Removed languages from say.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.38 2007/11/18 06:01:41 myc Exp myc $
d72 1
d910 3
@


1.38
log
@Fixed clan tell bug that was reading past null bit.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.37 2007/10/02 02:52:27 myc Exp myc $
a31 1
void improve_lang(struct char_data *ch, struct char_data *tch, int skill);
d42 1
a42 1
  int i;
d44 1
a44 1
  for (i = 0; i < (int)(strlen(string)); ++i)
d49 1
a49 1
ACMD (do_ctell)
d51 1
a51 9
  struct descriptor_data *i;
  int minlev=1, c=0;
  char level_string[12] = "";
  skip_spaces (&argument);
  /*
   * The syntax of ctell for imms is different then for morts
   * mort: ctell <bla bla bla>    imms: ctell <clan_num> <bla bla bla>
   * Imms cannot actually see ctells but they can send them
   */
d57 2
a58 30
  
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD){
    half_chop(argument, buf, argument);
    if (is_number(buf))
      c = atoi(buf);
    else {
      send_to_char("You must specify a clan number.\r\n",ch);
      return;
    }
    if ((c < 0) || (c > num_of_clans)){
      send_to_char ("There is no clan with that number.\r\n", ch);
      return;
    }
    else
      c = clan[c].id;
    /*
      while ((*argument != ' ') && (*argument != '\0'))
      argument++;
      while (*argument == ' ') argument++;
    */
  }
  else
    if((c=GET_CLAN(ch))==0 || GET_CLAN_RANK(ch)==0) {
      send_to_char ("You're not part of a clan.\r\n", ch);
      return;
    }
  
  skip_spaces (&argument);
  if (!*argument){
    send_to_char ("What do you want to tell your clan?\r\n", ch);
d62 2
a63 66
  if (*argument == '#'){
    ++argument;
    if (!*argument) {
      send_to_char("What minimum rank do you want to broadcast to?\r\n", ch);
      return;
    }
    minlev = atoi(argument);
    if (minlev > clan[c].ranks && GET_LEVEL(ch) < LVL_IMMORT) {
      send_to_char ("No one has a clan rank high enough to hear you!\r\n", ch);
      return;
    }
    while (*argument && *argument != ' ')
      ++argument;
    skip_spaces(&argument);
    sprintf(level_string, " (rank %d)", minlev);
  }
  
  argument = makedrunk(argument, ch);

  if (PRF_FLAGGED(ch,PRF_NOREPEAT))
    sprintf (buf1, OK);
  else
    if (GET_LEVEL(ch) >= LVL_IMMORT)
      sprintf (buf1, "&5You tell %s&0&5%s, '&b%s&0&5'&0\r\n",clan[find_clan_by_id(c)].name,level_string, argument);
    else
      sprintf (buf1, "&5You tell your clan%s, '&b%s&0&5'&0\r\n",level_string, argument);
  send_to_char (buf1, ch);
  
  for (i = descriptor_list; i; i=i->next){
    if (!(i->character))
      continue;
    if (GET_LEVEL(i->character) >= LVL_CLAN_GOD && ch != i->character 
	&& (i->character->clan_snoop == -1 || i->character->clan_snoop == find_clan_by_id(c))){
      sprintf(buf, "&5%s tells &0%s&0&5, '&b%s&0&5'&0\r\n",
	      GET_NAME(ch), clan[find_clan_by_id(c)].name, argument); 
      send_to_char(buf, i->character);
    }
    if ((int)(i->character->player_specials->saved.clan) == c){
      if ((int)(i->character->player_specials->saved.clan_rank) >= minlev){
	if (strcmp (i->character->player.name, ch->player.name)){
	  sprintf (buf, "&5%s tells your clan%s, '&b%s&0&5'&0\r\n",
		   (((IS_AFFECTED(ch, AFF_INVISIBLE)) &&
		     (!IS_AFFECTED(i->character, AFF_DETECT_INVIS))) ?
		    "Someone" : ch->player.name), level_string, argument);
	  send_to_char (buf, i->character);
	}
      }
    }
  }
  return;
}

ACMD(do_say)
{
  extern char *languages[];
  char ibuf[MAX_INPUT_LENGTH];
#ifdef LANGUAGES
  char obuf[MAX_INPUT_LENGTH];
  struct char_data *tch;
#endif
  int ofs = 190;              /* offset - should be first language */
  
  skip_spaces(&argument);
  
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
d66 1
a66 2
  if (!*argument){
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
d68 2
a69 4
  }
  
  
  else {
d71 1
a71 34
    if(GET_LEVEL(ch) < LVL_IMMORT)
      if(strchr(argument, '&'))  {
	send_to_char("No ampersand sign allowed in input.\r\n", ch);
	return;
      }
    if (!speech_ok(ch, 0)) return;
    argument = makedrunk(argument, ch);
    strcpy(ibuf, argument);     /* save real message */
#ifdef LANGUAGES
    if (!IS_NPC(ch))
      garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
    
    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
      if (tch != ch && AWAKE(tch) && tch->desc) {
	
	strcpy(obuf, ibuf);     /* preserve the first garble */
	if (!IS_NPC(ch))
	  garble_text(obuf, GET_SKILL(tch, SPEAKING(ch)));
	
	if ((GET_SKILL(tch, SPEAKING(ch)) < 1) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) &&
	    (GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says, '%s'",  obuf);
	else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says in %s, '%s'", languages[(SPEAKING(ch) - ofs)], obuf);
	else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	  sprintf(buf, "$n says in %s, '%s'", languages[(SPEAKING(ch) - ofs)], argument);
	else
	  sprintf(buf, "$n says, '%s'", argument);
	improve_lang(tch, ch, SPEAKING(ch));
	improve_lang(ch, ch, SPEAKING(ch));
	act(buf, FALSE, ch, 0, tch, TO_VICT|DG_NO_TRIG);
      }
    }
#endif
d73 3
a75 18
#ifndef LANGUAGES
    sprintf(buf, "$n says, '%s'", argument);
    act(buf, FALSE, ch, 0, 0, TO_ROOM | DG_NO_TRIG);
#endif
    
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      if (!IS_NPC(ch)){
	sprintf(buf, "You say in %s, '%s'", languages[(SPEAKING(ch)- ofs)], argument);
	act(buf, TRUE, ch, 0, 0, TO_CHAR);}else{
	  sprintf(buf, "You say, '%s'", argument);  
	  act(buf, FALSE, ch, 0, argument, TO_CHAR);}
    }
    /* trigger check */
    speech_mtrigger(ch, argument);
    speech_wtrigger(ch, argument);
  }
d909 3
@


1.37
log
@Druids can now send and receive tells while shapechanged.  This also
applies to switched immortals.  (The other party will see the player's
name instead of the shapechange's.)  Druids can also gossip while
shapechanged; it will show the druid's name as well as the shapechange.
Rewrote the report command to make use of gsay, msay, tell, and say,
instead of trying to reinvent the wheel.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.36 2007/08/14 10:43:36 jps Exp myc $
d54 1
a54 1
  char level_string[6]="\0";
d100 7
a106 3
    argument++;
    minlev = atoi (argument);
    if (minlev > clan[c].ranks && GET_LEVEL(ch) < LVL_IMMORT){
d110 4
a113 3
    while (*argument != ' ') argument++;
    while (*argument == ' ') argument++;
    sprintf (level_string, "(%d)", minlev);
d1061 8
@


1.36
log
@Add calls to speech_ok to many communication functions, so if you start
spamming a lot, you will get laryngitis.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.35 2007/08/03 22:00:11 myc Exp jps $
d230 4
a233 5
  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.\r\n", ch);
      return;
    }
d235 4
a238 4
  if (!IS_AFFECTED(ch, AFF_GROUP)) 
    {
      send_to_char("But you are not the member of a group!\r\n", ch);
      return;	}	
d244 1
a244 1
  if (!*argument)
d246 22
a267 20
  else 
    {
      argument = makedrunk(argument, ch);
      if (ch->groupmaster)
	k = ch->groupmaster;
      else
	k = ch;
      sprintf(buf, "&0&2$n tells the group, '&0&b&2%s&0&2'&0", argument);
      if (IS_AFFECTED(k, AFF_GROUP) && (k != ch))
	act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
      for (f = k->groupees; f; f = f->next)
	if (IS_AFFECTED(f->groupee, AFF_GROUP) &&
	    (f->groupee != ch))
	  act(buf, FALSE, ch, 0, f->groupee, TO_VICT | TO_SLEEP);	
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);		
      else 
	{
	  sprintf(buf, "&0&2You group say, '&0&b&2%s&0&2'&0", argument);
	  act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);		}	}
d356 14
a369 5
  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(arg, '&'))  {
      send_to_char("No ampersand sign allowed in input.\r\n", ch);
      return;
    }
d371 3
d395 1
a395 1
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);
d398 4
a401 8
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    send_to_char(CCWHT(ch, C_CMP), ch);
    sprintf(buf, "&0&b&8You tell $N, '%s'&0", arg);
    
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    send_to_char(CCNRM(ch, C_CMP), ch);
a402 2
  
  GET_LAST_TELL(vict) = GET_IDNUM(ch);
d423 1
a423 1
  else if (!IS_NPC(vict) && !vict->desc)	/* linkless */
d430 4
a433 3
  else if ((vict->player_specials->ignored == ch)) {
    act("$N is ignoring you at the moment.  No dice.", FALSE, ch, 0, vict, TO_CHAR);  
  } else  {
a436 5

    if (PRF_FLAGGED(vict, PRF_AFK)) {
      send_to_char("That person is AFK right now but received your message\r\n",ch);
      send_to_char("You received the previous message while AFK\r\n",vict);
    }
a470 4
      if (PRF_FLAGGED(tch, PRF_AFK) && !PRF_FLAGGED(tch, PRF_NOTELL)) {
	send_to_char("That person is AFK right now but received your message\r\n",ch);
	send_to_char("You received the previous message while AFK\r\n",tch);
      }
d551 1
a551 1
  (void)two_arguments(argument, papername, penname);
d681 1
d739 1
a739 6
  /* now now no animals gossiping etc.... */
  if (GET_SPECIES(ch) == SPECIES_ANIMAL) {
    sprintf(buf, "You can't gossip, yer an Aminal silly!");
    send_to_char(buf, ch);
    return;
  }
d797 14
a810 6
  /* this is a hack --Fingon */
  /* Changed the message to reflect ZZur's attitude toward gossiping :)  Selina */
  if(subcmd == SCMD_GOSSIP) {
    sprintf(buf, "$n gossips, '%s'", argument);
  } else {
    sprintf(buf, "$n %ss, '%s'", com_msgs[subcmd][1], argument);
d828 12
a839 1
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);
d1029 25
d1056 4
@


1.35
log
@Say uses to_room when languages is off now, so the command works with
observatories.  Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.34 2007/07/13 19:21:22 jps Exp myc $
d38 1
d175 1
d426 1
d464 1
d503 1
d782 2
d848 1
d1017 4
@


1.34
log
@Fix crash bug where the leader of an ordinary group could bring
the mud down by using "msay" when not a member of a major group.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.33 2007/07/11 02:08:32 myc Exp jps $
d149 1
d151 2
a153 1
  struct char_data *tch;
d171 1
a171 1
	send_to_char("No ampersand sign allowed in input.", ch);
a178 1
#endif
a183 1
#ifdef LANGUAGES
a185 1
#endif
a195 1
#ifdef LANGUAGES
a197 1
#endif
d201 6
d230 1
a230 1
      send_to_char("No ampersand sign allowed in input.", ch);
d276 1
a276 1
      send_to_char("No ampersand sign allowed in input.", ch);
d355 1
a355 1
      send_to_char("No ampersand sign allowed in input.", ch);
d766 1
a766 1
      send_to_char("No ampersand sign allowed in input.", ch);
d1009 4
@


1.33
log
@Fixing a really bad memory corruption bug in makedrunk().
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.32 2007/06/22 18:54:10 myc Exp myc $
d267 6
a272 7
  struct char_data *k = NULL;
  struct mgroup_type *f; struct group_type *g;
  
  skip_spaces(&argument);
  
  if(GET_LEVEL(ch) < LVL_IMMORT)
    if(strchr(argument, '&'))  {
d275 3
a277 3
    }
  if (!IS_AFFECTED(ch, AFF_GROUP)) 
    {
d280 61
a340 65
    }
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
    send_to_char("You lips move, but no sound forms.\r\n", ch);
    return;
  }
  
  if (!*argument)
    send_to_char("Yes, but WHAT do you want to major group-say?\r\n", ch);
  else 
    {
      argument = makedrunk(argument, ch);
      if (ch->mgroupmaster)
	k = ch->mgroupmaster;
      else
	{
	  if (ch->mgroupees)/*mgroup master*/
	    k = ch;
	  else
	    {
	      if (ch->groupmaster) {
		if (ch->groupmaster->mgroupmaster)
		  k = ch->groupmaster->mgroupmaster;
		else if (ch->groupmaster->mgroupees)
		  k = ch->groupmaster;
		else
		  {
		    send_to_char("You are not in a major group.\r\n", ch);
		    return;
		  }
	      }
	    }
	}
      
      sprintf(buf, "&0&1$n tells the major group, '&0&1&b%s&0&1'&0", argument);
      if (IS_AFFECTED(k, AFF_GROUP) && (k != ch))
	act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
      for (f = k->mgroupees; f; f = f->next)
	{
	  
	  if (IS_AFFECTED2(f->mgroupee, AFF2_MGROUP) && (f->mgroupee != ch))
	    {	
	      act(buf, FALSE, ch, 0, f->mgroupee, TO_VICT | TO_SLEEP);
				/*loop through this guys normal groupee's*/
	      for (g=f->mgroupee->groupees;g;g=g->next)
		{
		  if (IS_AFFECTED(g->groupee, AFF_GROUP))
		    act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
		}
	    }
	}
      /*loop through leaders group*/
      for (g=k->groupees;g;g=g->next)
	{
	  if ((IS_AFFECTED(g->groupee, AFF_GROUP)) && (g->groupee != ch))
	    act(buf, FALSE, ch, 0, g->groupee, TO_VICT | TO_SLEEP);
	}
      
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else 
	{
	  sprintf(buf, "&0&1You major group say, '&0&1&b%s&0&1'&0", argument);
	  act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
	}
    }
d1006 3
@


1.32
log
@Gods can send/hear tells/gossip/shouts in soundproof rooms.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.31 2006/11/20 22:24:17 jps Exp myc $
d970 1
a970 1
  char buf[4000];      /* this should be enough (?) */
d1004 1
a1004 2
     strcpy(string, buf);
     return(string);
d1011 3
@


1.31
log
@End the difficulties in interaction between evil and good player races.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.30 2006/11/13 15:54:22 jps Exp jps $
d414 1
a414 1
  else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
d421 1
a421 1
  else if (((PRF_FLAGGED(vict, PRF_NOTELL) && !IS_NPC(ch) && !IS_AFFECTED(ch, AFF_CHARM)) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF)) && (GET_LEVEL(ch) < LVL_IMMORT || (GET_LEVEL(ch) >= LVL_IMMORT && GET_LEVEL(ch) < GET_LEVEL(vict))))
d725 1
a725 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) {
d810 2
a811 1
	!ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {
d1012 3
@


1.30
log
@Fix widespread misuse of the hide_invisible parameter to act().
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.29 2002/09/15 04:30:38 jjl Exp jps $
a411 2
  else if ((((GET_RACE_ALIGN(ch)) + (GET_RACE_ALIGN(vict))) == 1)&&((GET_LEVEL(vict)<LVL_GOD)&&(GET_LEVEL(ch)<LVL_GOD)))
    send_to_char(NOPERSON, ch);
d1011 3
@


1.29
log
@Gods can now reply to a player with no-tell.
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.28 2002/09/13 02:32:10 jjl Exp $
d201 1
a201 1
	act(buf, TRUE, ch, 0, tch, TO_VICT|DG_NO_TRIG);
d1013 3
@


1.28
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.comm.c,v 1.27 2002/01/11 03:13:29 dce Exp $
d462 1
a462 1
      if (PRF_FLAGGED(tch, PRF_NOTELL)) {
d1013 3
@


1.27
log
@Cleaned up the file with lclint
@
text
@d1 3
a3 1
// $Id: act.comm.c,v 1.26 2001/03/30 23:34:50 dce Exp $
d1011 104
a1114 99
// $Log: act.comm.c,v $
// Revision 1.26  2001/03/30 23:34:50  dce
// Out of character references have been removed per Zzur's
// request.
//
// Revision 1.25  2001/03/24 15:43:31  dce
// Players speech will be slurred when drunk.
//
// Revision 1.24  2001/01/23 01:50:11  rsd
// made it so the afk messages don't make it through reply to
// notell people.
//
// Revision 1.23  2001/01/13 21:07:08  dce
// Changed do_tell to allow npcs to communicate to notell pcs.
//
// Revision 1.22  2000/11/28 00:41:25  mtp
// removed mobprog references
//
// Revision 1.21  2000/11/19 03:05:28  rsd
// Added back log messages from prior to the $log$ string
// being added .
//
// Revision 1.20  2000/11/14 00:04:43  rsd
// Added a check to do reply to check if a person is NOTELL.
//
// Revision 1.19  2000/11/11 01:39:51  mtp
// added ask trigger for ask/whisper and aslso ask/whisper triggers speech trigger
//
// Revision 1.18  2000/10/14 01:16:58  rsd
// put a check in do_gen_command to prevent animals from
// gossiping etc..
// /s
// DOH
//
// Revision 1.17  2000/09/22 23:30:46  rsd
// Altered the comment header to reflect that this is fiery
// code now. Also deleted a silly comment near the top.
//
// Revision 1.16  1999/11/20 22:22:21  rsd
// changed the output to the player when ooc is disabled.
//
// Revision 1.15  1999/09/09 03:47:26  mud
// TESTTESTTEST
//
// Revision 1.14  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.13  1999/09/03 23:04:14  mtp
// added IS_FIGTI check for write
//
// Revision 1.12  1999/08/18 22:41:04  mtp
// added afk message for do_reply
//
// Revision 1.11  1999/08/13 21:38:00  mtp
// make sure AFK message only happens on successful tell
//
// Revision 1.10  1999/08/09 22:34:31  mtp
// Added response for tell/whisper/ask if victim is flagged AFK
//
// Revision 1.9  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to 
// clarify their behavior to the compiler.  The name approval code was also 
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the 
// xnames list. This code compiles fine under both gcc RH5.2 and egcs RH6.0.
// --Gurlaek 6/10/1999
//
// Revision 1.8  1999/04/16 15:17:13  jen
// Changed do_tell so gods can tell notell players, but
// still can't tell notell's higher than their level.
// Selina
//
// Revision 1.7  1999/04/08 19:14:26  jen
// OK, the gossip toggle was also getting shouts... fixed that
//
// Revision 1.6  1999/03/30 21:51:01  jen
// Changed the message sent to characters when they gossip
// to reflect that being a non-MUD-related channel; also made
// the send-to-all message when a chr gossips less obnoxious.
//
// Revision 1.5  1999/03/30 19:09:56  jen
// Changed the gossip messages a little... JEN II
//
// Revision 1.4  1999/03/26 19:44:35  jen
// Added a mortal gossip channel with 103+ godly control
//
// Revision 1.3  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.2  1999/02/03 23:28:47  jimmy
// changed symantics for gossip to "shouts from the heavens"
//
// Revision 1.1  1999/01/29 01:23:29  mud
// Initial revision
//
@


1.26
log
@Out of character references have been removed per Zzur's
request.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.25 2001/03/24 15:43:31 dce Exp $
d42 1
a42 1
  for (i = 0; i < strlen(string); ++i)
d51 1
a51 1
  char level_string[6]="\0\0\0\0\0\0";
d128 2
a129 2
    if (i->character->player_specials->saved.clan == c){
      if (i->character->player_specials->saved.clan_rank >= minlev){
d549 1
a549 1
  two_arguments(argument, papername, penname);
d772 1
a772 1
    if (GET_MOVE(ch) < holler_move_cost) {
d880 1
a880 1
  int percent = GET_ISKILL(ch, skill);
d918 1
a918 1
     {"b", "b", "b", "B", "B", "vb"}},
d920 1
a920 1
     {"c", "c", "C", "cj", "sj", "zj"}},
d922 1
a922 1
     {"d", "d", "D"}},
d924 1
a924 1
     {"e", "e", "eh", "E"}},
d926 1
a926 1
     {"f", "f", "ff", "fff", "fFf", "F"}},
d928 1
a928 1
     {"g", "g", "G"}},
d930 1
a930 1
     {"h", "h", "hh", "hhh", "Hhh", "HhH", "H"}},
d932 1
a932 1
     {"i", "i", "Iii", "ii", "iI", "Ii", "I"}},
d934 1
a934 1
     {"j", "j", "jj", "Jj", "jJ", "J"}},
d936 1
a936 1
     {"k", "k", "K"}},
d938 1
a938 1
     {"l", "l", "L"}},
d940 1
a940 1
     {"m", "m", "mm", "mmm", "mmmm", "mmmmm", "MmM", "mM", "M"}},
d942 1
a942 1
     {"n", "n", "nn", "Nn", "nnn", "nNn", "N"}},
d944 1
a944 1
     {"o", "o", "ooo", "ao", "aOoo", "Ooo", "ooOo"}},
d946 1
a946 1
     {"p", "p", "P"}},
d948 1
a948 1
     {"q", "q", "Q", "ku", "ququ", "kukeleku"}},
d950 1
a950 1
     {"r", "r", "R"}},
d952 1
a952 1
     {"s", "ss", "zzZzssZ", "ZSssS", "sSzzsss", "sSss"}},
d954 1
a954 1
     {"t", "t", "T"}},
d956 1
a956 1
     {"u", "u", "uh", "Uh", "Uhuhhuh", "uhU", "uhhu"}},
d958 1
a958 1
     {"v", "v", "V"}},
d960 1
a960 1
     {"w", "w", "W"}},
d962 1
a962 1
     {"x", "x", "X", "ks", "iks", "kz", "xz"}},
d964 1
a964 1
     {"y", "y", "Y"}},
d966 1
a966 1
     {"z", "z", "ZzzZz", "Zzz", "Zsszzsz", "szz", "sZZz", "ZSz", "zZ", "Z"}}
d1010 4
@


1.25
log
@Players speech will be slurred when drunk.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.24 2001/01/23 01:50:11 rsd Exp $
d707 1
a707 1
     "gossip out-of-character",
a794 4
    if (subcmd == SCMD_GOSSIP) {
      sprintf(buf1, "NOTE: This channel is NOT for mud-related communications!");
      act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
    }
d800 1
a800 1
    sprintf(buf, "$n gossips OOC, '%s'", argument);
d1010 3
@


1.24
log
@made it so the afk messages don't make it through reply to
notell people.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.23 2001/01/13 21:07:08 dce Exp $
d34 2
d108 2
d170 1
d242 1
d289 1
d426 2
a427 1
    perform_tell(ch, vict, buf2);
d463 1
d501 2
a502 1
    strcpy(ibuf, buf2);     /* save real tell */
d518 1
a518 1
      sprintf(buf, "You %s %s, '%s'\r\n", action_sing, GET_NAME(vict), buf2);
d529 2
a530 2
    	ask_mtrigger(ch,vict, buf2);
    	speech_mtrigger(ch, buf2);
d778 3
d846 2
d900 112
a1011 1

d1014 4
@


1.23
log
@Changed do_tell to allow npcs to communicate to notell pcs.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.22 2000/11/28 00:41:25 mtp Exp $
d457 1
a457 1
      if (PRF_FLAGGED(tch, PRF_AFK)) {
d888 3
@


1.22
log
@removed mobprog references
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.21 2000/11/19 03:05:28 rsd Exp mtp $
d414 1
a414 1
  else if ((PRF_FLAGGED(vict, PRF_NOTELL) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF)) && (GET_LEVEL(ch) < LVL_IMMORT || (GET_LEVEL(ch) >= LVL_IMMORT && GET_LEVEL(ch) < GET_LEVEL(vict))))
d888 3
@


1.21
log
@Added back log messages from prior to the $log$ string
being added .
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.20 2000/11/14 00:04:43 rsd Exp $
a29 1
extern void mprog_speech_trigger(char *txt, struct char_data *mob);
a189 1
	MOBTrigger = FALSE;
a206 1
    mprog_speech_trigger(argument, ch);
d888 4
@


1.20
log
@Added a check to do reply to check if a person is NOTELL.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.19 2000/11/11 01:39:51 mtp Exp $
d891 3
d915 52
@


1.19
log
@added ask trigger for ask/whisper and aslso ask/whisper triggers speech trigger
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.18 2000/10/14 01:16:58 rsd Exp $
d452 1
a452 1
    if (tch == NULL)
d454 6
a459 2
    else  {
      perform_tell(ch, tch, argument);
d461 2
a462 2
        send_to_char("That person is AFK right now but received your message\r\n",ch);
        send_to_char("You received the previous message while AFK\r\n",tch);
d891 3
@


1.18
log
@put a check in do_gen_command to prevent animals from
gossiping etc..
/s
DOH
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.17 2000/09/22 23:30:46 rsd Exp $
d515 6
d887 6
@


1.17
log
@Altered the comment header to reflect that this is fiery
code now. Also deleted a silly comment near the top.
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.16 1999/11/20 22:22:21 rsd Exp $
d719 6
d881 4
@


1.16
log
@changed the output to the player when ooc is disabled.
@
text
@d1 3
a3 3
// $Id: act.comm.c,v 1.15 1999/09/09 03:47:26 mud Exp $
/* ************************************************************************
 *   File: act.comm.c                                    Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
a15 2
/* test comment */

d875 3
@


1.15
log
@TESTTESTTEST
@
text
@d1 1
a1 1
// $Id: act.comm.c,v 1.14 1999/09/05 07:00:39 jimmy Exp mud $
d729 1
a729 1
    send_to_char("You try to gossip, but the heavens have disallowed your unrealistic shout!\r\n", ch);
d875 3
@


1.14
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d14 1
a14 1

d874 4
a877 1
// $Log$
@


1.13
log
@added IS_FIGTING ch[4~[4~ check for write
@
text
@d1 1
d874 1
@


1.12
log
@added afk message for do_reply
@
text
@d527 4
@


1.11
log
@make sure AFK message only happens on successful tell
@
text
@d453 1
a453 1
    else
d455 5
@


1.10
log
@Added response for tell/whisper/ask if victim is flagged AFK
@
text
@d420 1
a420 1
  } else
d423 4
a426 3
  if (PRF_FLAGGED(vict, PRF_AFK)) {
    send_to_char("That person is AFK right now but received your message\r\n",ch);
    send_to_char("You received the previous message while AFK\r\n",vict);
@


1.9
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d422 5
d504 4
@


1.8
log
@Changed do_tell so gods can tell notell players, but
still can't tell notell's higher than their level.
Selina
@
text
@d293 1
a293 1
	      if (ch->groupmaster)
d299 6
a304 3
		  {send_to_char("You are not in a major group.\r\n", ch);
		  return;
		  }}
@


1.7
log
@OK, the gossip toggle was also getting shouts... fixed that
@
text
@d413 1
a413 1
  else if (PRF_FLAGGED(vict, PRF_NOTELL) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
@


1.6
log
@Changed the message sent to characters when they gossip
to reflect that being a non-MUD-related channel; also made
the send-to-all message when a chr gossips less obnoxious.
@
text
@d705 1
a705 1
  if (!gossip_channel_active && (GET_LEVEL(ch) < LVL_GOD)) {
@


1.5
log
@Changed the gossip messages a little... JEN II
@
text
@d745 5
d752 1
d755 1
a755 1
    sprintf(buf, "$n gossips out-of-character, '%s'", argument);
@


1.4
log
@Added a mortal gossip channel with 103+ godly control
@
text
@a746 1
  /* this is a hack --Fingon */
d749 1
a749 1
    sprintf(buf, "$n gossips completely out-of-character, '%s'", argument);
@


1.3
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d32 3
d667 1
a667 1
     "shout from the heavens",
d701 9
d748 1
d750 1
a750 1
    sprintf(buf, "$n shouts from the heavens, '%s'", argument);
@


1.2
log
@changed symantics for gossip to "shouts from the heavens"
@
text
@a641 1
    PRF_NOAUCT,
a666 5
    
    {"You cannot auction!!\r\n",
     "auction",
     "You aren't even on the channel!\r\n",
     KMAG},
@


1.1
log
@Initial revision
@
text
@d665 1
a665 1
     "gossip",
d740 8
a747 3
  
  sprintf(buf, "$n %ss, '%s'", com_msgs[subcmd][1], argument);
  
@
