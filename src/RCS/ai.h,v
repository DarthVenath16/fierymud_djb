head	1.16;
access;
symbols;
locks; strict;
comment	@ * @;


1.16
date	2008.08.31.20.54.28;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.29.17.34.31;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.12.19.08.14;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.17.22.52.59;	author jps;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.20.05.29.49;	author rsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.22.23.44.16;	author rsd;	state Exp;
branches;
next	1.4;

1.4
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.01.30.17.26.15;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.17.11.54;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/*AI.h*
*Written By Proky,
To be used with other mob AI files, all casting variables are within
this file and can be adjusted as needed
*/

extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];


/*function prototypes*/
bool check_sor_fight_status(struct char_data *ch);
bool aloud_skill(int i, int spellnum);
int try_cast(struct char_data * ch, struct char_data * victim, int spells_circle, int spellnum);
bool check_cler_fight_status(struct char_data *ch);
bool if_evil_in_group(struct char_data *victim);
bool if_good_in_group(struct char_data *victim);
int number_of_people_in_group(struct char_data *ch, struct char_data *victim);
bool can_summon(struct char_data *ch, struct char_data *victim);
bool is_tanking(struct char_data *ch);
void mob_heal_up(struct char_data *ch);
void sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void dragon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void demon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void sel_cleric_mob_spells(struct char_data * ch, struct char_data * victim);
void sel_thief_mob_spells(struct char_data *ch, struct char_data *victim);
void sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
void dragon_sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
void demon_sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
bool can_dim(struct char_data *ch, struct char_data *victim);
struct char_data *lowest_hp_in_group(struct char_data *ch, struct char_data *victim);
bool affected_by_aff(struct char_data *ch, int spell_number, int aff, int which);
bool check_weopeon_value(struct char_data *ch, struct obj_data *obj);
void mob_remove_weopon(struct char_data *ch, struct obj_data *obj, int where);
void perform_remove(struct char_data * ch, int pos);
void check_sor_status(struct char_data *ch);
void check_cler_status(struct char_data *ch);


/*general defines*/
#define SPELL_CIRCLE(spell)  (1 + ((int) ((spell_info[spell].min_level[(int)(GET_CLASS(ch))])/5)));
#define MOB_AGGR_TO_ALIGN (MOB_AGGR_EVIL | MOB_AGGR_NEUTRAL | MOB_AGGR_GOOD | MOB_AGGR_GOOD_ALIGN | MOB_AGGR_EVIL_ALIGN)



/*cleric's*/



#define NUMBER_CL_OFFENSE_CHECKS 1
#define NUMBER_OF_CL_CHECKS 4
#define NUMBER_CL_BAD_OFFENSE_CHECKS 1
#define NUMBER_CL_BAD_CHECKS 3
#define CLERIC_OFFENSE_NO 8
#define CLERIC_AREA_NO 3
#define CLERIC_HEAL_NO 5

extern const int cleric_heal[CLERIC_HEAL_NO];
extern const int cleric_area[CLERIC_AREA_NO];
extern const int cleric_offense[CLERIC_OFFENSE_NO];
extern const int cl_bad_spells_to_check[NUMBER_CL_BAD_CHECKS][4];
extern const int cl_spells_to_check[NUMBER_OF_CL_CHECKS][3];
/*sorcerer*/


#define NUMBER_SO_OFFENSE_CHECKS 2
#define NUMBER_OF_SO_CHECKS 9
#define SORCERER_OFFENSE_NO 6
#define SORCERER_AREA_NO 4

extern const int so_spells_to_check[NUMBER_OF_SO_CHECKS][3];
extern const int sorcerer_area[SORCERER_AREA_NO];
extern const int sorcerer_offense[SORCERER_OFFENSE_NO];
@


1.16
log
@Moved find_aggr_target, glorion_distraction, appraise_opponent, and is_aggr_to
to ai_utils.c from fight.c. Added will_assist. Incorporated the PROTECTOR
and PEACEKEEPER flags.
@
text
@/***************************************************************************
 * $Id: ai.h,v 1.15 2008/03/29 17:34:31 myc Exp jps $
 ***************************************************************************/
/***************************************************************************
 *   File: ai.h                                           Part of FieryMUD *
 *  Usage: To be used with other mob AI files, all casting variables are   *
 *         within this file and can be adjusted as needed.                 *
 * Author: Ben Horner (Proky of HubisMUD)                                  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 ***************************************************************************/

#include "skills.h"

struct spell_pair {
  int spell;
  int remover;
  int flag;
};

#define MOB_ASSISTER(ch) (!MOB_FLAGGED((ch), MOB_PEACEFUL) && \
      (MOB_FLAGGED((ch), MOB_HELPER) || MOB_FLAGGED((ch), MOB_PROTECTOR) || \
      MOB_FLAGGED((ch), MOB_PEACEKEEPER)))

/* Function prototypes in ai_utils.c */
bool try_cast(struct char_data * ch, struct char_data * victim, int spellnum);
bool evil_in_group(struct char_data *victim);
bool good_in_group(struct char_data *victim);
int group_size(struct char_data *ch);
bool is_tanking(struct char_data *ch);
bool mob_heal_up(struct char_data *ch);
struct char_data *weakest_attacker(struct char_data *ch, struct char_data *victim);
bool has_effect(struct char_data *ch, const struct spell_pair *effect);
bool check_weapon_value(struct char_data *ch, struct obj_data *obj);
void mob_remove_weapon(struct char_data *ch, struct obj_data *obj, int where);
void perform_remove(struct char_data *ch, int pos);
int appraise_item(struct char_data *ch, struct obj_data *obj);
bool will_assist(struct char_data *ch, struct char_data *vict);
struct char_data *find_aggr_target(struct char_data *ch);
void glorion_distraction(struct char_data *ch, struct char_data *glorion);
int appraise_opponent(struct char_data *ch, struct char_data *vict);
bool is_aggr_to(struct char_data *ch, struct char_data *tch);

/* Class AI functions */
bool sorcerer_ai_action(struct char_data * ch, struct char_data * victim);
bool cleric_ai_action(struct char_data * ch, struct char_data * victim);
bool rogue_ai_action(struct char_data *ch, struct char_data *victim);
bool warrior_ai_action(struct char_data * ch, struct char_data * victim);
bool mob_steal(struct char_data *ch);
bool mob_animate(struct char_data *ch);

/* Function prototypes in mobact.c */
bool check_sorcerer_status(struct char_data *ch);
bool check_cleric_status(struct char_data *ch);
bool dragonlike_attack(struct char_data *ch);
bool in_memory(struct char_data *ch, struct char_data *vict);


/***************************************************************************
 * $Log: ai.h,v $
 * Revision 1.15  2008/03/29 17:34:31  myc
 * No need for AGGR_TO_ALIGN.
 *
 * Revision 1.14  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.13  2008/02/23 01:03:54  myc
 * Getting rid of a duplicate macro.
 *
 * Revision 1.12  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.11  2008/01/13 23:06:04  myc
 * Added the appraise_item function.
 *
 * Revision 1.10  2008/01/12 23:13:20  myc
 * Cleaned up mobact.c some more and added some new mob actions.
 *
 * Revision 1.9  2008/01/12 19:08:14  myc
 * Rewrote a lot of mob AI functionality.
 *
 * Revision 1.8  2006/11/17 22:52:59  jps
 * Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
 *
 * Revision 1.7  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.6  2000/11/20 05:29:49  rsd
 * Added back rlog comments from prior to the addition
 * of the $log$ string.
 *
 * Revision 1.5  2000/09/22 23:44:16  rsd
 * Altered the comment header to indicate that this is
 * fierymud code now.
 *
 * Revision 1.4  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.3  1999/01/30 17:26:15  mud
 * Changed comment header to make sure proper credit was given
 * By: Ben Horner (Proky of HubisMUD)
 *
 * Revision 1.2  1999/01/30 17:11:54  mud
 * Indented entire file
 * Added a standard looking comment header at the
 * beginning of the file.
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.15
log
@No need for AGGR_TO_ALIGN.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.14 2008/03/28 17:54:53 myc Exp myc $
d23 4
d40 5
d58 2
d63 3
@


1.14
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.13 2008/02/23 01:03:54 myc Exp myc $
a49 4

/* General defines */
#define MOB_AGGR_TO_ALIGN (MOB_AGGR_EVIL | MOB_AGGR_NEUTRAL | MOB_AGGR_GOOD | MOB_AGGR_GOOD_RACE | MOB_AGGR_EVIL_RACE )

d52 4
@


1.13
log
@Getting rid of a duplicate macro.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.12 2008/01/26 14:26:31 jps Exp myc $
d20 1
a20 2
  int affect;
  char affect_type; /* AFF 1, 2, or 3 */
d31 1
a31 1
bool has_affection(struct char_data *ch, const struct spell_pair *affection);
d56 3
@


1.12
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.11 2008/01/13 23:06:04 myc Exp jps $
a52 1
#define SPELL_CIRCLE(spell)  (1 + ((int) ((skills[spell].min_level[(int)(GET_CLASS(ch))])/8))); 
d57 3
@


1.11
log
@Added the appraise_item function.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.10 2008/01/12 23:13:20 myc Exp myc $
d15 2
d53 1
a53 1
#define SPELL_CIRCLE(spell)  (1 + ((int) ((spell_info[spell].min_level[(int)(GET_CLASS(ch))])/8))); 
d58 3
@


1.10
log
@Cleaned up mobact.c some more and added some new mob actions.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.9 2008/01/12 19:08:14 myc Exp myc $
d34 1
d56 3
@


1.9
log
@Rewrote a lot of mob AI functionality.
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.8 2006/11/17 22:52:59 jps Exp myc $
a21 3
extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

d40 2
d55 3
@


1.8
log
@Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.7 2002/09/13 02:32:10 jjl Exp jps $
d15 7
d25 5
a29 11

/*function prototypes*/

bool check_sor_fight_status(struct char_data *ch); 
bool aloud_skill(int i, int spellnum); 
int try_cast(struct char_data * ch, struct char_data * victim, int spells_circle, int spellnum);
bool check_cler_fight_status(struct char_data *ch);
bool if_evil_in_group(struct char_data *victim);
bool if_good_in_group(struct char_data *victim);
int number_of_people_in_group(struct char_data *ch, struct char_data *victim);
bool can_summon(struct char_data *ch, struct char_data *victim);
d31 17
a47 18
void mob_heal_up(struct char_data *ch);
void sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void dragon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void demon_sel_mage_mob_spells(struct char_data * ch, struct char_data * victim);
void sel_cleric_mob_spells(struct char_data * ch, struct char_data * victim);
void sel_thief_mob_spells(struct char_data *ch, struct char_data *victim);
void sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
void dragon_sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
void demon_sel_warrior_mob_spells(struct char_data * ch, struct char_data * victim);
bool can_dim(struct char_data *ch, struct char_data *victim);
struct char_data *lowest_hp_in_group(struct char_data *ch, struct char_data *victim);
bool affected_by_aff(struct char_data *ch, int spell_number, int aff, int which);
bool check_weopeon_value(struct char_data *ch, struct obj_data *obj);
void mob_remove_weopon(struct char_data *ch, struct obj_data *obj, int where);
void perform_remove(struct char_data * ch, int pos);
void check_sor_status(struct char_data *ch);
void check_cler_status(struct char_data *ch);

a48 1
/*general defines*/
d50 2
a51 1
#define SPELL_CIRCLE(spell)  (1 + ((int) ((spell_info[spell].min_level[(int)(GET_CLASS(ch))])/5))); 
a53 28

/*cleric's*/

#define NUMBER_CL_OFFENSE_CHECKS 1
#define NUMBER_OF_CL_CHECKS 4
#define NUMBER_CL_BAD_OFFENSE_CHECKS 1
#define NUMBER_CL_BAD_CHECKS 3
#define CLERIC_OFFENSE_NO 8
#define CLERIC_AREA_NO 3
#define CLERIC_HEAL_NO 5

extern const int cleric_heal[CLERIC_HEAL_NO];
extern const int cleric_area[CLERIC_AREA_NO];
extern const int cleric_offense[CLERIC_OFFENSE_NO];
extern const int cl_bad_spells_to_check[NUMBER_CL_BAD_CHECKS][4];
extern const int cl_spells_to_check[NUMBER_OF_CL_CHECKS][3];


/*sorcerer*/

#define NUMBER_SO_OFFENSE_CHECKS 2
#define NUMBER_OF_SO_CHECKS 9
#define SORCERER_OFFENSE_NO 6
#define SORCERER_AREA_NO 4

extern const int so_spells_to_check[NUMBER_OF_SO_CHECKS][3];
extern const int sorcerer_area[SORCERER_AREA_NO];
extern const int sorcerer_offense[SORCERER_OFFENSE_NO];
d56 3
@


1.7
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: ai.h,v 1.6 2000/11/20 05:29:49 rsd Exp $
d52 1
a52 1
#define MOB_AGGR_TO_ALIGN (MOB_AGGR_EVIL | MOB_AGGR_NEUTRAL | MOB_AGGR_GOOD | MOB_AGGR_GOOD_ALIGN | MOB_AGGR_EVIL_ALIGN)
d84 3
@


1.6
log
@Added back rlog comments from prior to the addition
of the $log$ string.
@
text
@d1 3
a3 1
// $Id: ai.h,v 1.5 2000/09/22 23:44:16 rsd Exp $
d82 26
a107 20
// $Log: ai.h,v $
// Revision 1.5  2000/09/22 23:44:16  rsd
// Altered the comment header to indicate that this is
// fierymud code now.
//
// Revision 1.4  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.3  1999/01/30 17:26:15  mud
// Changed comment header to make sure proper credit was given
// By: Ben Horner (Proky of HubisMUD)
//
// Revision 1.2  1999/01/30 17:11:54  mud
// Indented entire file
// Added a standard looking comment header at the
// beginning of the file.
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.5
log
@Altered the comment header to indicate that this is
fierymud code now.
@
text
@d1 1
a1 1
// $Id: ai.h,v 1.4 1999/09/05 07:00:39 jimmy Exp $
d81 4
d87 12
@


1.4
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d3 1
a3 1
 *  File: ai.h                                            Part of FieryMUD *
d6 1
d8 3
a10 1
 * By: Ben Horner (Proky of HubisMUD)                                                                        *
d80 4
a83 1
// $Log$
@


1.3
log
@Changed comment header to make sure proper crdedit was given
By: Ben Horner (Proky of HubisMUD)
@
text
@d1 1
d77 1
@


1.2
log
@Indented entire file
Added a standard looking comment header at the
beginning of the file.
@
text
@d6 1
a6 1
 *                                                                         *
@


1.1
log
@Initial revision
@
text
@d1 7
a7 5
/*AI.h*
*Written By Proky,
To be used with other mob AI files, all casting variables are within
this file and can be adjusted as needed
*/
d14 1
d44 1
a48 1

a50 2


d64 2
a66 1

@
