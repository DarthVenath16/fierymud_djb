head	1.63;
access;
symbols;
locks; strict;
comment	@ * @;


1.63
date	2011.08.07.01.15.17;	author rsd;	state Exp;
branches;
next	1.62;

1.62
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.20.19.53.47;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.20.19.31.52;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.21.17.58.35;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.20.07.51.45;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.09.19.02.23;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.03.17.34.08;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.31.17.09.26;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.19.02.11.14;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.05.22.03.34;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.04.03.43.31;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.03.02.05.34;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.26.23.32.09;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.36;

1.36
date	2008.02.15.03.29.29;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.27.12.12.55;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.27.01.42.03;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.23.02.33.26;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.09.02.30.14;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.02.07.11.21;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.20.09.34.34;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.12.19.23.04;	author myc;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.03.23.59.43;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.24.22.59.55;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.24.22.49.05;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.24.22.10.58;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.24.03.35.11;	author jps;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.08.07.21.31;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.20.07.43.07;	author cjd;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.03.03.20.05;	author dce;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.24.19.26.06;	author dce;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.14.02.33.55;	author dce;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.13.01.57.29;	author dce;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.18.20.34.05;	author dce;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.08.01.31.05;	author dce;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.23.00.15.57;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.22.04.14.13;	author dce;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.16.03.13.27;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.16.03.10.47;	author dce;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.12.02.35.04;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.24.21.30.22;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.08.28.00.31.16;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.02.18.34;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: shop.c                                        Part of CircleMUD *
*  Usage: shopkeepers: loading config files, spec procs.                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/***
 * The entire shop rewrite for Circle 3.0 was done by Jeff Fink.  Thanks Jeff!
 ***/
#define __SHOP_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "shop.h"


/* External variables */
extern struct str_app_type str_app[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct char_data *mob_proto;
extern struct obj_data *obj_proto;
extern struct room_data *world;
extern struct time_info_data time_info;
extern char *item_types[];
extern char *extra_bits[];

/* Forward/External function declarations */
ACMD(do_tell);
ACMD(do_action);
ACMD(do_echo);
ACMD(do_say);
char *fname(char *namelist);
void sort_keeper_objs(struct char_data * keeper, int shop_nr);

/* Local variables */
struct shop_data *shop_index;
int top_shop = 0;
int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;


int is_ok_char(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  char buf[200];

  if (!(CAN_SEE(keeper, ch))) {
    do_say(keeper, MSG_NO_SEE_CHAR, cmd_say, 0);
    return (FALSE);
  }
  if (IS_GOD(ch))
    return (TRUE);

  if ((IS_GOOD(ch) && NOTRADE_GOOD(shop_nr)) ||
      (IS_EVIL(ch) && NOTRADE_EVIL(shop_nr)) ||
      (IS_NEUTRAL(ch) && NOTRADE_NEUTRAL(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_ALIGN);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  if (IS_NPC(ch))
    return (TRUE);

  if ((IS_MAGIC_USER(ch) && NOTRADE_MAGIC_USER(shop_nr)) ||
      (IS_CLERIC(ch) && NOTRADE_CLERIC(shop_nr)) ||
      (IS_THIEF(ch) && NOTRADE_THIEF(shop_nr)) ||
      (IS_WARRIOR(ch) && NOTRADE_WARRIOR(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_CLASS);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  return (TRUE);
}


int is_open(struct char_data * keeper, int shop_nr, int msg)
{
  char buf[200];

  *buf = 0;
  if (SHOP_OPEN1(shop_nr) > time_info.hours)
    strcpy(buf, MSG_NOT_OPEN_YET);
  else if (SHOP_CLOSE1(shop_nr) < time_info.hours)
    if (SHOP_OPEN2(shop_nr) > time_info.hours)
      strcpy(buf, MSG_NOT_REOPEN_YET);
    else if (SHOP_CLOSE2(shop_nr) < time_info.hours)
      strcpy(buf, MSG_CLOSED_FOR_DAY);

  if (!(*buf))
    return (TRUE);
  if (msg)
    do_say(keeper, buf, cmd_tell, 0);
  return (FALSE);
}


int is_ok(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  if (is_open(keeper, shop_nr, TRUE))
    return (is_ok_char(keeper, ch, shop_nr));
  else
    return (FALSE);
}


void push(struct stack_data * stack, int pushval)
{
  S_DATA(stack, S_LEN(stack)++) = pushval;
}


int top(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, S_LEN(stack) - 1));
  else
    return (NOTHING);
}


int pop(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, --S_LEN(stack)));
  else {
    log("Illegal expression in shop keyword list");
    return (0);
  }
}


void evaluate_operation(struct stack_data * ops, struct stack_data * vals)
{
  int oper;

  if ((oper = pop(ops)) == OPER_NOT)
    push(vals, !pop(vals));
  else if (oper == OPER_AND)
    push(vals, pop(vals) && pop(vals));
  else if (oper == OPER_OR)
    push(vals, pop(vals) || pop(vals));
}


int find_oper_num(char token)
{
  int index;

  for (index = 0; index <= MAX_OPER; index++)
    if (strchr(operator_str[index], token))
      return (index);
  return (NOTHING);
}


int evaluate_expression(struct obj_data * obj, char *expr)
{
  struct stack_data ops, vals;
  char *ptr, *end, name[200];
  int temp, index;

  if (!expr)
    return TRUE;

  if (!isalpha(*expr))
	return TRUE;

  ops.len = vals.len = 0;
  ptr = expr;
  while (*ptr) {
    if (isspace(*ptr))
      ptr++;
    else {
      if ((temp = find_oper_num(*ptr)) == NOTHING) {
	end = ptr;
	while (*ptr && !isspace(*ptr) && (find_oper_num(*ptr) == NOTHING))
	  ptr++;
	strncpy(name, end, ptr - end);
	name[ptr - end] = 0;
	for (index = 0; *extra_bits[index] != '\n'; index++)
	  if (!str_cmp(name, extra_bits[index])) {
	    push(&vals, IS_SET(GET_OBJ_EXTRA(obj), 1 << index));
	    break;
	  }
	if (*extra_bits[index] == '\n')
	  push(&vals, isname(name, obj->name));
      } else {
	if (temp != OPER_OPEN_PAREN)
	  while (top(&ops) > temp)
	    evaluate_operation(&ops, &vals);

	if (temp == OPER_CLOSE_PAREN) {
	  if ((temp = pop(&ops)) != OPER_OPEN_PAREN) {
	    log("Illegal parenthesis in shop keyword expression");
	    return (FALSE);
	  }
	} else
	  push(&ops, temp);
	ptr++;
      }
    }
  }
  while (top(&ops) != NOTHING)
    evaluate_operation(&ops, &vals);
  temp = pop(&vals);
  if (top(&vals) != NOTHING) {
    log("Extra operands left on shop keyword expression stack");
    return (FALSE);
  }
  return (temp);
}


int trade_with(struct obj_data * item, int shop_nr)
{
  int counter;

  if (GET_OBJ_COST(item) < 1)
    return (OBJECT_NOTOK);

  if (IS_OBJ_STAT(item, ITEM_NOSELL))
    return (OBJECT_NOTOK);

  for (counter = 0; SHOP_BUYTYPE(shop_nr, counter) != NOTHING; counter++)
    if (SHOP_BUYTYPE(shop_nr, counter) == GET_OBJ_TYPE(item))
      if ((GET_OBJ_VAL(item, 2) == 0) &&
	  ((GET_OBJ_TYPE(item) == ITEM_WAND) ||
	   (GET_OBJ_TYPE(item) == ITEM_STAFF)))
	return (OBJECT_DEAD);
      else if (evaluate_expression(item, SHOP_BUYWORD(shop_nr, counter)))
	return (OBJECT_OK);

  return (OBJECT_NOTOK);
}


int same_obj(struct obj_data * obj1, struct obj_data * obj2)
{
  int index;

  if (!obj1 || !obj2)
    return (obj1 == obj2);

  if (GET_OBJ_RNUM(obj1) != GET_OBJ_RNUM(obj2))
    return (FALSE);

  if (GET_OBJ_COST(obj1) != GET_OBJ_COST(obj2))
    return (FALSE);

  if (GET_OBJ_EXTRA(obj1) != GET_OBJ_EXTRA(obj2))
    return (FALSE);

  for (index = 0; index < MAX_OBJ_AFFECT; index++)
    if ((obj1->affected[index].location != obj2->affected[index].location) ||
	(obj1->affected[index].modifier != obj2->affected[index].modifier))
      return (FALSE);

  return (TRUE);
}


int shop_producing(struct obj_data * item, int shop_nr)
{
  int counter;

  if (GET_OBJ_RNUM(item) < 0)
    return (FALSE);
  for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
    if (same_obj(item, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
      return (TRUE);
  return (FALSE);
}


int transaction_amt(char *arg)
{
  int num;
  one_argument(arg, buf);
  if (*buf)
    if ((is_number(buf))) {
      num = atoi(buf);
	   if ((strlen(arg)) > 3)
		strcpy(arg, arg + strlen(buf) + 1);
	   else
		   num = 1;
      return (num);
    }
  return (1);
}

char *times_message(struct obj_data * obj, char *name, int num)
{
  static char buf[256];
  char *ptr;

  if (obj)
    strcpy(buf, obj->short_description);
  else {
    if ((ptr = strchr(name, '.')) == NULL)
      ptr = name;
    else
      ptr++;
    sprintf(buf, "%s %s", AN(ptr), ptr);
  }

  if (num > 1)
    sprintf(END_OF(buf), " (x %d)", num);
  return (buf);
}


struct obj_data *get_slide_obj_vis(struct char_data * ch, char *name,
				            struct obj_data * list)
{
  struct obj_data *i, *last_match = 0;
  int j, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp;

  strcpy(tmpname, name);
  tmp = tmpname;
  if (!(number = get_number(&tmp)))
    return (0);

  for (i = list, j = 1; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i) && !same_obj(last_match, i)) {
	if (j == number)
	  return (i);
	last_match = i;
	j++;
      }
  return (0);
}


struct obj_data *get_hash_obj_vis(struct char_data * ch, char *name,
				           struct obj_data * list)
{
  struct obj_data *loop, *last_obj = 0;
  int index;

  if ((is_number(name + 1)))
    index = atoi(name + 1);
  else
    return (0);

  for (loop = list; loop; loop = loop->next_content)
    if (CAN_SEE_OBJ(ch, loop) && (loop->obj_flags.cost > 0))
      if (!same_obj(last_obj, loop)) {
	if (--index == 0)
	  return (loop);
	last_obj = loop;
      }
  return (0);
}


struct obj_data *get_purchase_obj(struct char_data * ch, char *arg,
		            struct char_data * keeper, int shop_nr, int msg)
{
  char buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj;

	one_argument(arg, name);
  do {
	  if (is_number(name))
	  {
		strcpy(buf, name);
		strcpy(name, "#\0");
		strcat(name, buf);
	  }
    if (*name == '#')
      obj = get_hash_obj_vis(ch, name, keeper->carrying);
    else
      obj = get_slide_obj_vis(ch, name, keeper->carrying);
    if (!obj) {
      if (msg) {
	sprintf(buf, shop_index[shop_nr].no_such_item1, GET_NAME(ch));
	do_tell(keeper, buf, cmd_tell, 0);
      }
      return (0);
    }
    if (GET_OBJ_COST(obj) <= 0) {
      extract_obj(obj);
      obj = 0;
    }
  } while (!obj);
  return (obj);
}


int buy_price(struct obj_data * obj, int shop_nr)
{
  return ((int) (GET_OBJ_COST(obj) * SHOP_BUYPROFIT(shop_nr)));
}

long coin_count(struct char_data * ch)
{
	long amount;
/*All done in copper*/
	amount = (long)(1000*GET_PLAT(ch) + 200*GET_GOLD(ch) + 20*GET_SILVER(ch) + GET_COPPER(ch));
	return amount;
}
bool convert_next_coin(struct char_data * ch)
{

	if (GET_COPPER(ch) > 0)
		return TRUE;
	else if (GET_SILVER(ch) > 0)
	{
		GET_SILVER(ch)--;
		GET_COPPER(ch) = GET_COPPER(ch) + 20;
	}
	else if (GET_GOLD(ch) > 0)
	{
		GET_GOLD(ch)--;
	    GET_SILVER(ch) = GET_SILVER(ch) + 10;
	}
	else if (GET_PLAT(ch) > 0)
	{
		GET_PLAT(ch)--;
	    GET_GOLD(ch) = GET_GOLD(ch) + 5;
	}
	else
	{
		mudlog("Error in convert_next_coin, shop.c (PROKY)", CMP, LVL_GOD, FALSE);
		return FALSE;
	}
	return TRUE;
}



void apply_cost(int cost, struct char_data * ch)
{

	if (cost <=0)
		return;

	do
	{
		while (GET_COPPER(ch) > 0)
		{
			GET_COPPER(ch)--;
			cost--;
			if (cost <= 0)
				return;
		}

	} while (convert_next_coin(ch));

}

void shopping_buy(char *arg, struct char_data * ch,
		       struct char_data * keeper, int shop_nr)
{
  char tempstr[200], buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *last_obj = NULL;
  int copperamt = 0, buynum, bought = 0;
  bool amount = 0;int counter;
  if (!(is_ok(keeper, ch, shop_nr)))
  {
		send_to_char("I don't see a Shop Keeper Around!!", ch);
		return;/*return if not a keeper*/
  }
  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);


  if ((buynum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try selling me something.",
	    GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(*arg) && (!buynum)) {
    sprintf(buf, "%s What do you want to buy??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }

	  if (!(obj = get_purchase_obj(ch, arg, keeper, shop_nr, TRUE)))
		return;


  if (((long)buy_price(obj, shop_nr) > coin_count(ch)) && !IS_GOD(ch)) {
    sprintf(buf, shop_index[shop_nr].missing_cash2, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);

    switch (SHOP_BROKE_TEMPER(shop_nr)) {
    case 0:
      do_action(keeper, GET_NAME(ch), cmd_puke, 0);
      return;
    case 1:
      do_echo(keeper, "smokes on his joint.", cmd_emote, SCMD_EMOTE);
      return;
    default:
      return;
    }
  }
  if ((IS_CARRYING_N(ch) + 1 > CAN_CARRY_N(ch))) {
    sprintf(buf, "%s: You can't carry any more items.\n\r",
	    fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
    sprintf(buf, "%s: You can't carry that much weight.\n\r",
	    fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  while ((obj) && ((coin_count(ch) >= buy_price(obj, shop_nr)) || IS_GOD(ch))
	 && (IS_CARRYING_N(ch) < CAN_CARRY_N(ch)) && (bought < buynum)
	 && (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) <= CAN_CARRY_W(ch))) {
    bought++;
    /* Test if producing shop ! */
    if (shop_producing(obj, shop_nr))

	{
	for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
		if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
		{
		amount = SHOP_AMOUNT(shop_nr, counter);
		}

		if (!(amount))
			obj = read_object(GET_OBJ_RNUM(obj), REAL);
		else
		{obj_from_char(obj);
      SHOP_SORT(shop_nr)--;
		}
	}else {
      obj_from_char(obj);
      SHOP_SORT(shop_nr)--;
    }
    obj_to_char(obj, ch);

    copperamt += buy_price(obj, shop_nr);
    if (!IS_GOD(ch))
	{
	apply_cost(buy_price(obj, shop_nr), ch);
    }
	last_obj = obj;
	one_argument(arg, name);
    obj = get_purchase_obj(ch, name, keeper, shop_nr, FALSE);
    if (!same_obj(obj, last_obj))
      break;
  }

  if (bought < buynum) {
    if (!obj || !same_obj(last_obj, obj))
      sprintf(buf, "%s I only have %d to sell you.", GET_NAME(ch), bought);
    else if (GET_GOLD(ch) < buy_price(obj, shop_nr))
      sprintf(buf, "%s You can only afford %d.", GET_NAME(ch), bought);
    else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      sprintf(buf, "%s You can only hold %d.", GET_NAME(ch), bought);
    else if (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) > CAN_CARRY_W(ch))
      sprintf(buf, "%s You can only carry %d.", GET_NAME(ch), bought);
    else
      sprintf(buf, "%s Something screwy only gave you %d.", GET_NAME(ch),
	      bought);
    do_tell(keeper, buf, cmd_tell, 0);
  }
  if (!IS_GOD(ch))
    GET_GOLD(keeper) += copperamt;

  sprintf(tempstr, times_message(ch->carrying, 0, bought));
  sprintf(buf, "$n buys %s.", tempstr);
  act(buf, FALSE, ch, obj, 0, TO_ROOM);

  sprintf(buf, shop_index[shop_nr].message_buy, GET_NAME(ch), 0);
  do_tell(keeper, buf, cmd_tell, 0);
  sprintf(buf, "You now have %s.\n\r", tempstr);
  send_to_char(buf, ch);

  if (SHOP_USES_BANK(shop_nr))
    if (GET_GOLD(keeper) > MAX_OUTSIDE_BANK) {
      SHOP_BANK(shop_nr) += (GET_GOLD(keeper) - MAX_OUTSIDE_BANK);
      GET_GOLD(keeper) = MAX_OUTSIDE_BANK;
    }
}


struct obj_data *get_selling_obj(struct char_data * ch, char *name,
		            struct char_data * keeper, int shop_nr, int msg)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  int result;

  if (!(obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
    if (msg) {
      sprintf(buf, shop_index[shop_nr].no_such_item2, GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);
    }
    return (0);
  }
  if ((result = trade_with(obj, shop_nr)) == OBJECT_OK)
    return (obj);

  switch (result) {
  case OBJECT_NOTOK:
    sprintf(buf, shop_index[shop_nr].do_not_buy, GET_NAME(ch));
    break;
  case OBJECT_DEAD:
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_USED_WANDSTAFF);
    break;
  default:
    sprintf(buf, "Illegal return value of %d from trade_with() (shop.c)",
	    result);
    log(buf);
    sprintf(buf, "%s An error has occurred.", GET_NAME(ch));
    break;
  }
  if (msg)
    do_tell(keeper, buf, cmd_tell, 0);
  return (0);
}


int sell_price(struct char_data * ch, struct obj_data * obj, int shop_nr)
{
  return ((int) (GET_OBJ_COST(obj) * SHOP_SELLPROFIT(shop_nr)));
}


struct obj_data *slide_obj(struct obj_data * obj, struct char_data * keeper,
			            int shop_nr)
/*
   This function is a slight hack!  To make sure that duplicate items are
   only listed once on the "list", this function groups "identical"
   objects together on the shopkeeper's inventory list.  The hack involves
   knowing how the list is put together, and manipulating the order of
   the objects on the list.  (But since most of DIKU is not encapsulated,
   and information hiding is almost never used, it isn't that big a deal) -JF
*/
{
  struct obj_data *loop;
  int temp;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  /* Extract the object if it is identical to one produced */
  if (shop_producing(obj, shop_nr)) {
    temp = GET_OBJ_RNUM(obj);
    extract_obj(obj);
    return (&obj_proto[temp]);
  }
  SHOP_SORT(shop_nr)++;
  loop = keeper->carrying;
  obj_to_char(obj, keeper);
  keeper->carrying = loop;
  while (loop) {
    if (same_obj(obj, loop)) {
      obj->next_content = loop->next_content;
      loop->next_content = obj;
      return (obj);
    }
    loop = loop->next_content;
  }
  keeper->carrying = obj;
  return (obj);
}


void sort_keeper_objs(struct char_data * keeper, int shop_nr)
{
  struct obj_data *list = 0, *temp;

  while (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper)) {
    temp = keeper->carrying;
    obj_from_char(temp);
    temp->next_content = list;
    list = temp;
  }

  while (list) {
    temp = list;
    list = list->next_content;
    if ((shop_producing(temp, shop_nr)) &&
	!(get_obj_in_list_num(GET_OBJ_RNUM(temp), keeper->carrying))) {
      obj_to_char(temp, keeper);
      SHOP_SORT(shop_nr)++;
    } else
      (void) slide_obj(temp, keeper, shop_nr);
  }
}

void apply_getcash(struct char_data * ch, int cash)
{
	int temp, temp2, temp3, temp4 = 0;
	temp = ((int)(cash)/1000);
	temp2 = ((int)((int)(cash/200)-(temp*5)));
	temp3 = ((int)((((int)(cash/20))-(temp*50))-temp2*10));
	temp4 = ((int)((((cash)-(temp*1000))-(temp2*200))-(temp3*20)));
	GET_PLAT(ch) += temp;
	GET_GOLD(ch) += temp2;
	GET_SILVER(ch) += temp3;
	GET_COPPER(ch) =+ temp4;
}

void shopping_sell(char *arg, struct char_data * ch,
		        struct char_data * keeper, int shop_nr)
{
  char tempstr[200], buf[MAX_STRING_LENGTH], name[200];
  struct obj_data *obj, *tag = 0;
  int sellnum, sold = 0, goldamt = 0;

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if ((sellnum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try buying something.",
	    GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(*arg) || !(sellnum)) {
    sprintf(buf, "%s What do you want to sell??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;

  if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) < sell_price(ch, obj, shop_nr)) {
    sprintf(buf, shop_index[shop_nr].missing_cash1, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  while ((obj) && (GET_GOLD(keeper) + SHOP_BANK(shop_nr) >=
		   sell_price(ch, obj, shop_nr)) && (sold < sellnum)) {
    sold++;

    goldamt += sell_price(ch, obj, shop_nr);
    GET_GOLD(keeper) -= sell_price(ch, obj, shop_nr);

    obj_from_char(obj);
    tag = slide_obj(obj, keeper, shop_nr);
    obj = get_selling_obj(ch, name, keeper, shop_nr, FALSE);
  }

  if (sold < sellnum) {
    if (!obj)
      sprintf(buf, "%s You only have %d of those.", GET_NAME(ch), sold);
    else if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) <
	     sell_price(ch, obj, shop_nr))
      sprintf(buf, "%s I can only afford to buy %d of those.",
	      GET_NAME(ch), sold);
    else
      sprintf(buf, "%s Something really screwy made me buy %d.",
	      GET_NAME(ch), sold);

    do_tell(keeper, buf, cmd_tell, 0);
  }
  apply_getcash(ch, goldamt);
  strcpy(tempstr, times_message(0, name, sold));
  sprintf(buf, "$n sells %s.", tempstr);
  act(buf, FALSE, ch, obj, 0, TO_ROOM);

  sprintf(buf, shop_index[shop_nr].message_sell, GET_NAME(ch), 0);
  do_tell(keeper, buf, cmd_tell, 0);
  sprintf(buf, "The shopkeeper now has %s.\n\r", tempstr);
  send_to_char(buf, ch);

  if (GET_GOLD(keeper) < MIN_OUTSIDE_BANK) {
    goldamt = MIN(MAX_OUTSIDE_BANK - GET_GOLD(keeper), SHOP_BANK(shop_nr));
    SHOP_BANK(shop_nr) -= goldamt;
    GET_GOLD(keeper) += goldamt;
  }
}


void shopping_value(char *arg, struct char_data * ch,
		         struct char_data * keeper, int shop_nr)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  char name[MAX_INPUT_LENGTH];
int temp, temp2, temp3, temp4 = 0;
  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (!(*arg)) {
    sprintf(buf, "%s What do you want me to valuate??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;
temp = ((int)(buy_price(obj, shop_nr))/1000);
temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
sprintf(buf, "I'll give you &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c &0&7&bfor that!&0", temp, temp2, temp3, temp4);

  /*sprintf(buf, "%s I'll give you %d gold coins for that!", GET_NAME(ch),
	*/
  do_tell(keeper, buf, cmd_tell, 0);

  return;
}


char *list_object(struct obj_data * obj, int cnt, int index, int shop_nr)
{
  static char buf[256];
  char buf2[300], buf3[200];
  extern char *drinks[];
  int counter, amount = -1;
  int temp, temp2, temp3, temp4;

	if (shop_producing(obj, shop_nr))
	{
	for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
		if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
		{
		amount = SHOP_AMOUNT(shop_nr, counter);
		}
		if (amount)
			strcpy(buf2, "I have Specialy got ");
		else
			strcpy(buf2, "I have a few ");
	}else
		sprintf(buf2, "I have %d ", cnt);
	sprintf(buf, "%2d)%s", index, buf2);

  /* Compile object name and information */
  strcpy(buf3, obj->short_description);
  if ((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) && (GET_OBJ_VAL(obj, 1)))
    sprintf(END_OF(buf3), " of %s", drinks[GET_OBJ_VAL(obj, 2)]);

  /* FUTURE: */
  /* Add glow/hum/etc */

  if ((GET_OBJ_TYPE(obj) == ITEM_WAND) || (GET_OBJ_TYPE(obj) == ITEM_STAFF))
    if (GET_OBJ_VAL(obj, 2) < GET_OBJ_VAL(obj, 1))
      strcat(buf3, " (partially used)");
temp = ((int)(buy_price(obj, shop_nr))/1000);
temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
  sprintf(buf2, "%-40s &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", buf3, temp, temp2, temp3, temp4);
  strcat(buf, CAP(buf2));
  return (buf);
}


void shopping_list(char *arg, struct char_data * ch,
		        struct char_data * keeper, int shop_nr)
{
  char buf[MAX_STRING_LENGTH], name[200];
  struct obj_data *obj, *last_obj = 0;
  int cnt = 0, index = 0;
  int i;

 if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  one_argument(arg, name);
  sprintf(buf1, "&0&8%s tells you. 'I have the following items for sale.'&0\r\n", GET_NAME(keeper));
  strcpy(buf, buf1);
i = 0;
  for (obj = keeper->carrying; obj; obj = obj->next_content)/*go through all the objects*/
    i++;
  strcat(buf, "&\r\n");
  if (keeper->carrying)
    for (obj = keeper->carrying; obj; obj = obj->next_content)/*go through all the objects*/
      if (CAN_SEE_OBJ(ch, obj) && (obj->obj_flags.cost > 0))  /*only ones that cost*/
	  {
		if (!last_obj)
		{
			last_obj = obj;
			cnt = 1;
		}
		else if (same_obj(last_obj, obj))
			cnt++;
		else
		{
			index++;
			if (!(*name) || isname(name, last_obj->name))
			strcat(buf, list_object(last_obj, cnt, index, shop_nr));
			cnt = 1;
			last_obj = obj;
		}
	}
	index++;
  if (!last_obj)
    if (*name)
      strcpy(buf, "Presently, none of those are for sale.\n\r");
    else
      strcpy(buf, "Currently, there is nothing for sale.\n\r");
  else if (!(*name) || isname(name, last_obj->name))
    strcat(buf, list_object(last_obj, cnt, index, shop_nr));

  page_string(ch->desc, buf, 1);
}


int ok_shop_room(int shop_nr, int room)
{
  int index;

  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++)
    if (SHOP_ROOM(shop_nr, index) == room)
      return (TRUE);
  return (FALSE);
}


SPECIAL(shop_keeper)
{
  char argm[MAX_INPUT_LENGTH];
  struct char_data *keeper = (struct char_data *) me;
  int shop_nr;

  for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
    if (SHOP_KEEPER(shop_nr) == keeper->nr)
      break;

  if (shop_nr >= top_shop)
    return (FALSE);

  if (SHOP_FUNC(shop_nr))	/* Check secondary function */
    if ((SHOP_FUNC(shop_nr)) (ch, me, cmd, arg))
      return (TRUE);

  if (keeper == ch) {
    if (cmd)
      SHOP_SORT(shop_nr) = 0;	/* Safety in case "drop all" */
    return (FALSE);
  }
  if (!ok_shop_room(shop_nr, world[ch->in_room].number))
    return (0);

  if (!AWAKE(keeper))
    return (FALSE);

  if (CMD_IS("steal")) {
    sprintf(argm, "$N shouts '%s'", MSG_NO_STEAL_HERE);
    do_action(keeper, GET_NAME(ch), cmd_slap, 0);
    act(argm, FALSE, ch, 0, keeper, TO_CHAR);
    return (TRUE);
  }

  if (CMD_IS("buy")) {
    shopping_buy(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("sell")) {
    shopping_sell(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("value")) {
    shopping_value(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("list")) {
    shopping_list(argument, ch, keeper, shop_nr);
    return (TRUE);
  }
  return (FALSE);
}


int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim)
{
  char buf[200];
  int index;

  if (IS_NPC(victim) && (mob_index[GET_MOB_RNUM(victim)].func == shop_keeper))
    for (index = 0; index < top_shop; index++)
      if ((GET_MOB_RNUM(victim) == SHOP_KEEPER(index)) && !SHOP_KILL_CHARS(index)) {
	do_action(victim, GET_NAME(ch), cmd_slap, 0);
	sprintf(buf, "%s %s", GET_NAME(ch), MSG_CANT_KILL_KEEPER);
	do_tell(victim, buf, cmd_tell, 0);
	return (FALSE);
      }
  return (TRUE);
}


int add_to_list(struct shop_buy_data * list, int type, int *len, int *val, int *amount)
{
	if (type == LIST_PRODUCE)
		BUY_AMOUNT(list[*len]) = *amount;
  if (*val >= 0)
    if (*len < MAX_SHOP_OBJ) {
      if (type == LIST_PRODUCE)
	*val = real_object(*val);
      if (*val >= 0) {
	BUY_TYPE(list[*len]) = *val;
	BUY_WORD(list[(*len)++]) = 0;
      } else
	*val = 0;
      return (FALSE);
    } else
      return (TRUE);
  return (FALSE);
}

int end_read_list(struct shop_buy_data * list, int len, int error)
{
  if (error) {
    sprintf(buf, "Raise MAX_SHOP_OBJ constant in shop.h to %d", len + error);
    log(buf);
  }
  BUY_WORD(list[len]) = 0;
  BUY_AMOUNT(list[len]) = 0;
  BUY_TYPE(list[len++]) = NOTHING;
  return (len);
}


void read_line(FILE * shop_f, char *string, void *data)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, string, data)) {
    fprintf(stderr, "Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}
void read_double_line(FILE * shop_f, char *string, void *data, void *data2)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, string, data, data2)) {
    fprintf(stderr, "Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}

int read_list(FILE * shop_f, struct shop_buy_data * list, int new_format,
	          int max, int type)
{
  int count, temp, len = 0, error = 0;
  int amount = 0;
  if (new_format) {
    do {
	  amount = 0;/*defult amount set to 0*/
      read_double_line(shop_f, "%d %d", &temp, &amount);
	  error += add_to_list(list, type, &len, &temp, &amount);
    } while (temp >= 0);
  } else
    for (count = 0; count < max; count++) {
      read_line(shop_f, "%d", &temp);
	  error += add_to_list(list, type, &len, &temp, &amount);
    }
  return (end_read_list(list, len, error));
}


int read_type_list(FILE * shop_f, struct shop_buy_data * list,
		       int new_format, int max)
{
  int index, num, len = 0, error = 0, spare = -10;
  char *ptr;

  if (!new_format)
    return (read_list(shop_f, list, 0, max, LIST_TRADE));
  do {
    fgets(buf, MAX_STRING_LENGTH - 1, shop_f);
    if ((ptr = strchr(buf, ';')) != NULL)
      *ptr = 0;
    else
      *(END_OF(buf) - 1) = 0;
    for (index = 0, num = NOTHING; *item_types[index] != '\n'; index++)
      if (!strn_cmp(item_types[index], buf, strlen(item_types[index]))) {
	num = index;
	strcpy(buf, buf + strlen(item_types[index]));
	break;
      }
    ptr = buf;
    if (num == NOTHING) {
      sscanf(buf, "%d", &num);
      while (!isdigit(*ptr))
	ptr++;
      while (isdigit(*ptr))
	ptr++;
    }
    while (isspace(*ptr))
      ptr++;
    while (isspace(*(END_OF(ptr) - 1)))
      *(END_OF(ptr) - 1) = 0;
    error += add_to_list(list, LIST_TRADE, &len, &num, &spare);
    if (*ptr)
      BUY_WORD(list[len - 1]) = str_dup(ptr);
  } while (num >= 0);
  return (end_read_list(list, len, error));
}


void boot_the_shops(FILE * shop_f, char *filename, int rec_count)
{
  char *buf, buf2[150];
  int temp, count, new_format = 0;
  struct shop_buy_data list[MAX_SHOP_OBJ + 1];
  int done = 0;

  sprintf(buf2, "beginning of shop file %s", filename);

  while (!done) {
    buf = fread_string(shop_f, buf2);
    if (*buf == '#') {		/* New shop */
      sscanf(buf, "#%d\n", &temp);
      sprintf(buf2, "shop #%d in shop file %s", temp, filename);
      free(buf);		/* Plug memory leak! */
      if (!top_shop)
	CREATE(shop_index, struct shop_data, rec_count);

      SHOP_NUM(top_shop) = temp;
      temp = read_list(shop_f, list, new_format, MAX_PROD, LIST_PRODUCE);
      CREATE(shop_index[top_shop].producing, int, temp);
	  CREATE(shop_index[top_shop].amount, int, temp);
      for (count = 0; count < temp; count++) {
	SHOP_PRODUCT(top_shop, count) = BUY_TYPE(list[count]);
	SHOP_AMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);}
      read_line(shop_f, "%f", &SHOP_BUYPROFIT(top_shop));
      read_line(shop_f, "%f", &SHOP_SELLPROFIT(top_shop));

      temp = read_type_list(shop_f, list, new_format, MAX_TRADE);
      CREATE(shop_index[top_shop].type, struct shop_buy_data, temp);
      for (count = 0; count < temp; count++) {
	SHOP_BUYTYPE(top_shop, count) = BUY_TYPE(list[count]);
	SHOP_BUYAMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);
	SHOP_BUYWORD(top_shop, count) = BUY_WORD(list[count]);
      }

      shop_index[top_shop].no_such_item1 = fread_string(shop_f, buf2);
      shop_index[top_shop].no_such_item2 = fread_string(shop_f, buf2);
      shop_index[top_shop].do_not_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash1 = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash2 = fread_string(shop_f, buf2);
      shop_index[top_shop].message_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].message_sell = fread_string(shop_f, buf2);
      read_line(shop_f, "%d", &SHOP_BROKE_TEMPER(top_shop));
      read_line(shop_f, "%d", &SHOP_BITVECTOR(top_shop));
      read_line(shop_f, "%d", &SHOP_KEEPER(top_shop));

      SHOP_KEEPER(top_shop) = real_mobile(SHOP_KEEPER(top_shop));
      read_line(shop_f, "%d", &SHOP_TRADE_WITH(top_shop));

      temp = read_list(shop_f, list, new_format, 1, LIST_ROOM);
      CREATE(shop_index[top_shop].in_room, int, temp);
      for (count = 0; count < temp; count++)
	SHOP_ROOM(top_shop, count) = BUY_TYPE(list[count]);

      read_line(shop_f, "%d", &SHOP_OPEN1(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE1(top_shop));
      read_line(shop_f, "%d", &SHOP_OPEN2(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE2(top_shop));

      SHOP_BANK(top_shop) = 0;
      SHOP_SORT(top_shop) = 0;
      SHOP_FUNC(top_shop) = 0;
      top_shop++;
    } else {
      if (*buf == '$')		/* EOF */
	done = TRUE;
      else if (strstr(buf, VERSION3_TAG))	/* New format marker */
	new_format = 1;
      free(buf);		/* Plug memory leak! */
    }
  }
}


void assign_the_shopkeepers(void)
{
  int index;

  cmd_say = find_command("say");
  cmd_tell = find_command("tell");
  cmd_emote = find_command("emote");
  cmd_slap = find_command("slap");
  cmd_puke = find_command("puke");
  for (index = 0; index < top_shop; index++) {
	  if (SHOP_KEEPER(index) == NOBODY)
		  continue;
    if (mob_index[SHOP_KEEPER(index)].func)
      SHOP_FUNC(index) = mob_index[SHOP_KEEPER(index)].func;
    mob_index[SHOP_KEEPER(index)].func = shop_keeper;
  }
}


char *customer_string(int shop_nr, int detailed)
{
  int index, cnt = 1;
  static char buf[256];

  *buf = 0;
  for (index = 0; *trade_letters[index] != '\n'; index++, cnt *= 2)
    if (!(SHOP_TRADE_WITH(shop_nr) & cnt))
      if (detailed) {
	if (*buf)
	  strcat(buf, ", ");
	strcat(buf, trade_letters[index]);
      } else
	sprintf(END_OF(buf), "%c", *trade_letters[index]);
    else if (!detailed)
      strcat(buf, "_");

  return (buf);
}


void list_all_shops(struct char_data * ch)
{
  int shop_nr;

  strcpy(buf, "\n\r");
  for (shop_nr = 0; shop_nr < top_shop; shop_nr++) {
    if (!(shop_nr % 19)) {
      strcat(buf, " ##   Virtual   Where    Keeper    Buy   Sell   Customers\n\r");
      strcat(buf, "---------------------------------------------------------\n\r");
    }
    sprintf(buf2, "%3d   %6d   %6d    ", shop_nr + 1, SHOP_NUM(shop_nr),
	    SHOP_ROOM(shop_nr, 0));
    if (SHOP_KEEPER(shop_nr) < 0)
      strcpy(buf1, "<NONE>");
    else
      sprintf(buf1, "%6d", mob_index[SHOP_KEEPER(shop_nr)].virtual);
    sprintf(END_OF(buf2), "%s   %3.2f   %3.2f    ", buf1,
	    SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr));
    strcat(buf2, customer_string(shop_nr, FALSE));
    sprintf(END_OF(buf), "%s\n\r", buf2);
  }

  page_string(ch->desc, buf, 1);
}


void handle_detailed_list(char *buf, char *buf1, struct char_data * ch)
{
  if ((strlen(buf1) + strlen(buf) < 78) || (strlen(buf) < 20))
    strcat(buf, buf1);
  else {
    strcat(buf, "\n\r");
    send_to_char(buf, ch);
    sprintf(buf, "            %s", buf1);
  }
}


void list_detailed_shop(struct char_data * ch, int shop_nr)
{
  struct obj_data *obj;
  struct char_data *k;
  int index, temp;

  sprintf(buf, "Vnum:       [%5d], Rnum: [%5d]\n\r", SHOP_NUM(shop_nr),
	  shop_nr + 1);
  send_to_char(buf, ch);

  strcpy(buf, "Rooms:      ");
  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++) {
    if (index)
      strcat(buf, ", ");
    if ((temp = real_room(SHOP_ROOM(shop_nr, index))) != NOWHERE)
      sprintf(buf1, "%s (#%d)", world[temp].name, world[temp].number);
    else
      sprintf(buf1, "<UNKNOWN> (#%d)", SHOP_ROOM(shop_nr, index));
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Rooms:      None!\n\r", ch);
  else {
    strcat(buf, "\n\r");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Shopkeeper: ");
  if (SHOP_KEEPER(shop_nr) >= 0) {
    sprintf(END_OF(buf), "%s (#%d), Special Function: %s\n\r",
	    GET_NAME(&mob_proto[SHOP_KEEPER(shop_nr)]),
	mob_index[SHOP_KEEPER(shop_nr)].virtual, YESNO(SHOP_FUNC(shop_nr)));
    if ((k = get_char_num(SHOP_KEEPER(shop_nr)))) {
      send_to_char(buf, ch);
      sprintf(buf, "Coins:      [%9d], Bank: [%9d] (Total: %d)\n\r",
	 GET_GOLD(k), SHOP_BANK(shop_nr), GET_GOLD(k) + SHOP_BANK(shop_nr));
    }
  } else
    strcat(buf, "<NONE>\n\r");
  send_to_char(buf, ch);

  strcpy(buf1, customer_string(shop_nr, TRUE));
  sprintf(buf, "Customers:  %s\n\r", (*buf1) ? buf1 : "None");
  send_to_char(buf, ch);

  strcpy(buf, "Produces:   ");
  for (index = 0; SHOP_PRODUCT(shop_nr, index) != NOTHING; index++) {
    obj = &obj_proto[SHOP_PRODUCT(shop_nr, index)];
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d)", obj->short_description,
	    obj_index[SHOP_PRODUCT(shop_nr, index)].virtual);
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Produces:   Nothing!\n\r", ch);
  else {
    strcat(buf, "\n\r");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Buys:       ");
  for (index = 0; SHOP_BUYTYPE(shop_nr, index) != NOTHING; index++) {
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d) ", item_types[SHOP_BUYTYPE(shop_nr, index)],
	    SHOP_BUYTYPE(shop_nr, index));
    if (SHOP_BUYWORD(shop_nr, index))
      sprintf(END_OF(buf1), "[%s]", SHOP_BUYWORD(shop_nr, index));
    else
      strcat(buf1, "[all]");
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Buys:       Nothing!\n\r", ch);
  else {
    strcat(buf, "\n\r");
    send_to_char(buf, ch);
  }

  sprintf(buf, "Buy at:     [%4.2f], Sell at: [%4.2f], Open: [%d-%d, %d-%d]%s",
     SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr), SHOP_OPEN1(shop_nr),
   SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\n\r");

  send_to_char(buf, ch);

  sprintbit((long) SHOP_BITVECTOR(shop_nr), shop_bits, buf1);
  sprintf(buf, "Bits:       %s\n\r", buf1);
  send_to_char(buf, ch);
}


void show_shops(struct char_data * ch, char *arg)
{
  int shop_nr;

  if (!*arg)
    list_all_shops(ch);
  else {
    if (!str_cmp(arg, ".")) {
      for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
	if (ok_shop_room(shop_nr, world[ch->in_room].number))
	  break;

      if (shop_nr == top_shop) {
	send_to_char("This isn't a shop!\n\r", ch);
	return;
      }
    } else if (is_number(arg))
      shop_nr = atoi(arg) - 1;
    else
      shop_nr = -1;

    if ((shop_nr < 0) || (shop_nr >= top_shop)) {
      send_to_char("Illegal shop number.\n\r", ch);
      return;
    }
    list_detailed_shop(ch, shop_nr);
  }
}
@


1.63
log
@fixed -  warning: format not a string literal and no format arguments
@
text
@/***************************************************************************
 * $Id: shop.c,v 1.62 2011/08/06 15:22:51 rsd Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: shop.c                                         Part of FieryMUD *
 *  Usage: shopkeepers: loading config files, spec procs.                  *
 *     By: Jeff Fink                                                       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <math.h>

#define __SHOP_C__

#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "shop.h"
#include "class.h"
#include "constants.h"
#include "math.h"
#include "chars.h"
#include "screen.h"
#include "modify.h"
#include "limits.h"
#include "composition.h"
#include "specprocs.h"

/* Forward/External function declarations */
ACMD(do_tell);
ACMD(do_action);
ACMD(do_echo);
ACMD(do_say);
void sort_keeper_objs(struct char_data * keeper, int shop_nr);

/* Local variables */
struct shop_data *shop_index;
int top_shop = 0;
int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_snicker;


int is_ok_char(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  char buf[200];

  if (!(CAN_SEE(keeper, ch))) {
    do_say(keeper, MSG_NO_SEE_CHAR, cmd_say, 0);
    return (FALSE);
  }
  if (IS_GOD(ch))
    return (TRUE);

  if ((IS_GOOD(ch) && NOTRADE_GOOD(shop_nr)) ||
      (IS_EVIL(ch) && NOTRADE_EVIL(shop_nr)) ||
      (IS_NEUTRAL(ch) && NOTRADE_NEUTRAL(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_ALIGN);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  if (IS_NPC(ch))
    return (TRUE);

  if ((IS_MAGIC_USER(ch) && NOTRADE_MAGIC_USER(shop_nr)) ||
      (IS_CLERIC(ch) && NOTRADE_CLERIC(shop_nr)) ||
      (IS_ROGUE(ch) && NOTRADE_THIEF(shop_nr)) ||
      (IS_WARRIOR(ch) && NOTRADE_WARRIOR(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_CLASS);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  return (TRUE);
}


int is_open(struct char_data * keeper, int shop_nr, int msg)
{
  char buf[200];

  *buf = 0;
  if (SHOP_OPEN1(shop_nr) > time_info.hours)
    strcpy(buf, MSG_NOT_OPEN_YET);
  else if (SHOP_CLOSE1(shop_nr) < time_info.hours) {
    if (SHOP_OPEN2(shop_nr) > time_info.hours)
      strcpy(buf, MSG_NOT_REOPEN_YET);
    else if (SHOP_CLOSE2(shop_nr) < time_info.hours)
      strcpy(buf, MSG_CLOSED_FOR_DAY);
  }
  if (!(*buf))
    return (TRUE);
  if (msg)
    do_say(keeper, buf, cmd_tell, 0);
  return (FALSE);
}


int is_ok(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  if (is_open(keeper, shop_nr, TRUE))
    return (is_ok_char(keeper, ch, shop_nr));
  else
    return (FALSE);
}


void push(struct stack_data * stack, int pushval)
{
  S_DATA(stack, S_LEN(stack)++) = pushval;
}


int top(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, S_LEN(stack) - 1));
  else
    return (NOTHING);
}


int pop(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, --S_LEN(stack)));
  else {
    log("Illegal expression in shop keyword list");
    return (0);
  }
}


void evaluate_operation(struct stack_data * ops, struct stack_data * vals)
{
  int oper;

  if ((oper = pop(ops)) == OPER_NOT)
    push(vals, !pop(vals));
  else if (oper == OPER_AND)
    push(vals, pop(vals) && pop(vals));
  else if (oper == OPER_OR)
    push(vals, pop(vals) || pop(vals));
}


int find_oper_num(char token)
{
  int index;

  for (index = 0; index <= MAX_OPER; index++)
    if (strchr(operator_str[index], token))
      return (index);
  return (NOTHING);
}


int evaluate_expression(struct obj_data * obj, char *expr)
{
  struct stack_data ops, vals;
  char *ptr, *end, name[200];
  int temp, index;

  if (!expr)
    return TRUE;

  if (!isalpha(*expr))
    return TRUE;

  ops.len = vals.len = 0;
  ptr = expr;
  while (*ptr) {
    if (isspace(*ptr))
      ptr++;
    else {
      if ((temp = find_oper_num(*ptr)) == NOTHING) {
        end = ptr;
        while (*ptr && !isspace(*ptr) && (find_oper_num(*ptr) == NOTHING))
          ptr++;
        strncpy(name, end, ptr - end);
        name[ptr - end] = 0;
        for (index = 0; *extra_bits[index] != '\n'; index++)
          if (!str_cmp(name, extra_bits[index])) {
            push(&vals, OBJ_FLAGGED(obj, index));
            break;
          }
        if (*extra_bits[index] == '\n')
          push(&vals, isname(name, obj->name));
      } else {
        if (temp != OPER_OPEN_PAREN)
          while (top(&ops) > temp)
            evaluate_operation(&ops, &vals);

        if (temp == OPER_CLOSE_PAREN) {
          if ((temp = pop(&ops)) != OPER_OPEN_PAREN) {
            log("Illegal parenthesis in shop keyword expression");
            return (FALSE);
          }
        } else
          push(&ops, temp);
        ptr++;
      }
    }
  }
  while (top(&ops) != NOTHING)
    evaluate_operation(&ops, &vals);
  temp = pop(&vals);
  if (top(&vals) != NOTHING) {
    log("Extra operands left on shop keyword expression stack");
    return (FALSE);
  }
  return (temp);
}


/* trade_with()
 *
 * Determines whether an object is suitable for sale to the given shop.
 */
int trade_with(struct obj_data *item, int shop_nr)
{
  int counter;

  /* Free items are not desirable. */
  if (GET_OBJ_COST(item) < 1)
    return OBJECT_NOTOK;

  /* That !SELL flag is there for a reason... */
  if (OBJ_FLAGGED(item, ITEM_NOSELL))
    return OBJECT_NOTOK;

  /* We don't want this. */
  if (GET_OBJ_TYPE(item) == ITEM_KEY)
    return OBJECT_NOTOK;

  /* Go down the list of buytypes in the shop.  If any of them match
   * this object, it's considered validated.  Unless it's a dead staff/wand,
   * of course. */
  for (counter = 0; SHOP_BUYTYPE(shop_nr, counter) != NOTHING; counter++)
    if (SHOP_BUYTYPE(shop_nr, counter) == GET_OBJ_TYPE(item)) {
      if ((GET_OBJ_VAL(item, VAL_WAND_CHARGES_LEFT) == 0) &&
          ((GET_OBJ_TYPE(item) == ITEM_WAND) ||
           (GET_OBJ_TYPE(item) == ITEM_STAFF)))
        return OBJECT_DEAD;
      else if (evaluate_expression(item, SHOP_BUYWORD(shop_nr, counter)))
        return OBJECT_OK;
    }
  return OBJECT_NOTOK;
}


int same_obj(struct obj_data * obj1, struct obj_data * obj2)
{
  int index;

  if (!obj1 || !obj2)
    return (obj1 == obj2);

  if (GET_OBJ_RNUM(obj1) != GET_OBJ_RNUM(obj2))
    return (FALSE);

  if (GET_OBJ_COST(obj1) != GET_OBJ_COST(obj2))
    return (FALSE);

  if (!ALL_FLAGGED(GET_OBJ_FLAGS(obj1), GET_OBJ_FLAGS(obj2), NUM_ITEM_FLAGS))
    return (FALSE);

  for (index = 0; index < MAX_OBJ_APPLIES; index++)
    if ((obj1->applies[index].location != obj2->applies[index].location) ||
        (obj1->applies[index].modifier != obj2->applies[index].modifier))
      return (FALSE);

  return (TRUE);
}


int shop_producing(struct obj_data * item, int shop_nr)
{
  int counter;

  if (GET_OBJ_RNUM(item) < 0)
    return (FALSE);
  for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
    if (same_obj(item, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
      return (TRUE);
  return (FALSE);
}


int transaction_amt(char *arg)
{
  int num;
  one_argument(arg, buf);
  if (*buf)
    if ((is_number(buf))) {
      num = atoi(buf);
      if ((strlen(arg)) > 3)
        strcpy(arg, arg + strlen(buf) + 1);
      else
        num = 1;
      return (num);
    }
  return (1);
}

char *times_message(struct obj_data * obj, char *name, int num) {
   static char buf[256];
   char *ptr;

   if (obj)
      strcpy(buf, obj->short_description);
   else {
      if ((ptr = strchr(name, '.')) == NULL)
         ptr = name;
      else
         ptr++;
      strncpy(buf, ptr, 200);
      buf[199] = 0;
   }

   if (num > 1)
      sprintf(END_OF(buf), " (x %d)", num);
   return buf;
}


struct obj_data *get_slide_obj_vis(struct char_data * ch, char *name,
                                   struct obj_data * list)
{
  struct obj_data *i, *last_match = 0;
  int j, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp;

  strcpy(tmpname, name);
  tmp = tmpname;
  if (!(number = grab_number(&tmp)))
    return (0);

  for (i = list, j = 1; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i) && !same_obj(last_match, i)) {
        if (j == number)
          return (i);
        last_match = i;
        j++;
      }
  return (0);
}


struct obj_data *get_hash_obj_vis(struct char_data * ch, char *name,
                                  struct obj_data * list)
{
  struct obj_data *loop, *last_obj = 0;
  int index;

  if ((is_number(name + 1)))
    index = atoi(name + 1);
  else
    return (0);

  for (loop = list; loop; loop = loop->next_content)
    if (CAN_SEE_OBJ(ch, loop) && (loop->obj_flags.cost > 0))
      if (!same_obj(last_obj, loop)) {
        if (--index == 0)
          return (loop);
        last_obj = loop;
      }
  return (0);
}


struct obj_data *get_purchase_obj(struct char_data * ch, char *arg,
      struct char_data * keeper, int shop_nr, int msg)
{
   char buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
   struct obj_data *obj;

   one_argument(arg, name);
   do {
      if (is_number(name)) {
         strcpy(buf, name);
         strcpy(name, "#\0");
         strcat(name, buf);
      }
      if (*name == '#')
         obj = get_hash_obj_vis(ch, name, keeper->carrying);
      else
         obj = get_slide_obj_vis(ch, name, keeper->carrying);
      if (!obj) {
         if (msg) {
            sprintf(buf, shop_index[shop_nr].no_such_item1, GET_NAME(ch));
            do_tell(keeper, buf, cmd_tell, 0);
         }
         return (0);
      }
      if (GET_OBJ_COST(obj) <= 0) {
         extract_obj(obj);
         obj = 0;
      }
   } while (!obj);
   return (obj);
}

/* 1/16/01 David Endre - This code is used to count up how many of the
   same objects that the shopkeeper has. This then reduces how much
   a shopkeeper will pay for an object based on how many he already
   has or how much he will sell an object for. */

int do_count_objs(struct char_data *keeper, struct obj_data *last_obj)
{
  struct obj_data *obj;
  int cnt = 0;

  if (keeper->carrying)
    for (obj = keeper->carrying; obj; obj = obj->next_content)
      if (obj->obj_flags.cost > 0)
        if (same_obj(last_obj, obj))
          cnt++;

  return (cnt);
}

/* 1/21/01 - David Endre
   Added var and cha to the buy_price function. Var adds or subtracts the
   price of an object based on how many items a shopkeeper has. While cha
   compares the shopkeepers charisma to the players charisma and adjusts
   the price based on a comparison. Do not mess with these functions
   without talking to me, so I can explain them further. */

int buy_price(struct char_data *ch, struct char_data *keeper, struct obj_data * obj, int shop_nr)
{
  int cnt = 0, price = 0;
  float var = 0.0, cha = 0.0;

  cnt = do_count_objs(keeper, obj);
  var = (double)(1.0 - ((double)(cnt-1)*.007));
  if (var < .875) {
    var = .875;
  }
  cha = (double)(GET_AFFECTED_CHA(ch)/100.0);
  cha = (double)(((GET_AFFECTED_CHA(keeper)/100.0) - cha)/2.0);

  price = (int)(GET_OBJ_COST(obj) * SHOP_BUYPROFIT(shop_nr));
  price = (int)(price * var);
  price = (int)(price * (1+cha));

  if (price < 1) price = 1;

  return (price);
}

void apply_getcash(struct char_data * ch, int cash)
{
  GET_PLATINUM(ch) += PLATINUM_PART(cash);
  GET_GOLD(ch) += GOLD_PART(cash);
  GET_SILVER(ch) += SILVER_PART(cash);
  GET_COPPER(ch) += COPPER_PART(cash);
}

void adjust_cash(struct char_data *ch)
{
  int cash = GET_CASH(ch);
  GET_PLATINUM(ch) = PLATINUM_PART(cash);
  GET_GOLD(ch) = GOLD_PART(cash);
  GET_SILVER(ch) = SILVER_PART(cash);
  GET_COPPER(ch) = COPPER_PART(cash);
}

void apply_cost(int cost, struct char_data *ch)
{
  int haveP, haveG, haveS, haveC;

  if (cost <= 0 || cost > GET_CASH(ch)) {
    sprintf(buf, "ERR: %s being charged %d but doesn't have that much money",
          GET_NAME(ch), cost);
    mudlog(buf, BRF, LVL_GOD, TRUE);
    return;
  }

  /* Find out how much they have */
  haveP = GET_PLATINUM(ch);
  haveG = GET_GOLD(ch);
  haveS = GET_SILVER(ch);
  haveC = GET_COPPER(ch);

  /* Subtract what we need from what we have */
  haveC -= cost;

  /* Exchange the coins on down */
  while (haveC < 0) {
    haveS--;
    haveC += 10;
  }

  while (haveS < 0) {
    haveG--;
    haveS += 10;
  }

  while (haveG < 0) {
    haveP--;
    haveG += 10;
  }

  if (haveP < 0) {
    sprintf(buf, "SYSERR: %s being charged %d and ended up with negative platinum!",
          GET_NAME(ch), cost);
    mudlog(buf, BRF, LVL_GOD, TRUE);
    haveP = 0;
  }

  /* Give player new amount */
  GET_PLATINUM(ch) = haveP;
  GET_GOLD(ch) = haveG;
  GET_SILVER(ch) = haveS;
  GET_COPPER(ch) = haveC;

}

void shopping_buy(char *arg, struct char_data * ch,
                   struct char_data * keeper, int shop_nr)
{
   char tempstr[200], buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
   struct obj_data *obj, *last_obj = NULL;
   int copperamt = 0, buynum, bought = 0;
   bool amount = 0;int counter;

   if (!(is_ok(keeper, ch, shop_nr)))
      return; /* Isn't a shopkeeper */

   if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
      sort_keeper_objs(keeper, shop_nr);

   if ((buynum = transaction_amt(arg)) < 0) {
      sprintf(buf, "%s A negative amount?   Try selling me something.",
            GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);
      return;
   }

   /* Did buyer specify anything to buy? */
   if (!*arg) {
      sprintf(buf, "%s What do you want to buy?", GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);
      return;
   }

   /* Does shopkeeper have any of the desired item? */
   if (!(obj = get_purchase_obj(ch, arg, keeper, shop_nr, TRUE)))
      return;

   if (!RIGID(ch) && GET_LEVEL(ch) < LVL_IMMORT) {
      send_to_char("You can't handle solid objects in your condition.\r\n", ch);
      return;
   }

   /* Can the buyer afford the item? */
   if ((buy_price(ch, keeper, obj, shop_nr) > GET_CASH(ch)) && !IS_GOD(ch)) {
      sprintf(buf, shop_index[shop_nr].missing_cash2, GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);

      switch (SHOP_BROKE_TEMPER(shop_nr)) {
      case 0:
         do_action(keeper, GET_NAME(ch), cmd_snicker, 0);
         return;
      case 1:
         do_echo(keeper, "smokes on his joint.", cmd_emote, SCMD_EMOTE);
         return;
      default:
         return;
      }
   }

   if ((IS_CARRYING_N(ch) + 1 > CAN_CARRY_N(ch))) {
      sprintf(buf, "%s: You can't carry any more items.\r\n",
            fname(obj->name));
      send_to_char(buf, ch);
      return;
   }

   if (!ADDED_WEIGHT_OK(ch, obj)) {
      sprintf(buf, "%s: You can't carry that much weight.\r\n",
            fname(obj->name));
      send_to_char(buf, ch);
      return;
   }

   /* Loop over each purchased item */
   while ((obj) &&
         ((GET_CASH(ch) >= buy_price(ch, keeper, obj, shop_nr)) || GET_LEVEL(ch) >= LVL_IMMORT) &&
         (IS_CARRYING_N(ch) < CAN_CARRY_N(ch)) &&
         (bought < buynum) &&
         ADDED_WEIGHT_OK(ch, obj)) {

      bought++;

      /* Replenish items produced by the shop (permanent stock) */
      if (shop_producing(obj, shop_nr)) {
         for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
            if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)])) {
               amount = SHOP_AMOUNT(shop_nr, counter);
            }

         if (!(amount))
            obj = read_object(GET_OBJ_RNUM(obj), REAL);
         else {
            obj_from_char(obj);
            SHOP_SORT(shop_nr)--;
         }

      /* This item is not permanent stock */
      } else {
         obj_from_char(obj);
         SHOP_SORT(shop_nr)--;
      }

      obj_to_char(obj, ch);

      /* Give the money to the shopkeeper */
      copperamt += buy_price(ch, keeper, obj, shop_nr);

      /*
       * We should be charging the buyer BEFORE giving them the item, 
       * because buy_price changes its return value depending on how
       * many of the item the shopkeeper is holding.
       *
       * However, players have been taking advantage of this bug and
       * I want to catch them. -Lao
       */
      if (GET_LEVEL(ch) < LVL_IMMORT) {
         apply_cost(buy_price(ch, keeper, obj, shop_nr), ch);
      }

      last_obj = obj;
      one_argument(arg, name);
      obj = get_purchase_obj(ch, name, keeper, shop_nr, FALSE);
      if (!same_obj(obj, last_obj))
         break;
   } /* loop each purchased item */

   /* Give feedback to the buyer as to what was purchased */
   if (bought < buynum) {
      if (!obj || !same_obj(last_obj, obj))
         sprintf(buf, "%s I only have %d to sell you.", GET_NAME(ch), bought);
      else if (GET_CASH(ch) < buy_price(ch, keeper, obj, shop_nr))
         sprintf(buf, "%s You can only afford %d.", GET_NAME(ch), bought);
      else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
         sprintf(buf, "%s You can only hold %d.", GET_NAME(ch), bought);
      else if (!ADDED_WEIGHT_OK(ch, obj))
         sprintf(buf, "%s You can only carry %d.", GET_NAME(ch), bought);
      else
         sprintf(buf, "%s Something screwy only gave you %d.", GET_NAME(ch),
               bought);
      do_tell(keeper, buf, cmd_tell, 0);
   }

   if (GET_LEVEL(ch) < LVL_IMMORT)
      apply_getcash(keeper, copperamt);

   sprintf(tempstr, "%s", times_message(ch->carrying, 0, bought));
   sprintf(buf, "$n buys %s.", tempstr);
   act(buf, FALSE, ch, obj, 0, TO_ROOM);

   sprintf(buf, shop_index[shop_nr].message_buy, GET_NAME(ch), 0);
   do_tell(keeper, buf, cmd_tell, 0);
   sprintf(buf, "You now have %s.\r\n", tempstr);
   send_to_char(buf, ch);

   if (SHOP_USES_BANK(shop_nr))
      if (GET_CASH(keeper) > MAX_OUTSIDE_BANK) {
         SHOP_BANK(shop_nr) += (GET_CASH(keeper) - MAX_OUTSIDE_BANK);
         GET_PLATINUM(keeper) = 0;
         GET_GOLD(keeper) = 0;
         GET_SILVER(keeper) = 0;
         GET_COPPER(keeper) = 0;
         GET_COPPER(keeper) = MAX_OUTSIDE_BANK;
         adjust_cash(keeper);
      }
}


struct obj_data *get_selling_obj(struct char_data * ch, char *name,
                                 struct char_data * keeper, int shop_nr, int msg)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  int result;

  if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, name)))) {
    if (msg) {
      sprintf(buf, shop_index[shop_nr].no_such_item2, GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);
    }
    return (0);
  }
  if ((result = trade_with(obj, shop_nr)) == OBJECT_OK)
    return (obj);

  switch (result) {
  case OBJECT_NOTOK:
    sprintf(buf, shop_index[shop_nr].do_not_buy, GET_NAME(ch));
    break;
  case OBJECT_DEAD:
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_USED_WANDSTAFF);
    break;
  default:
    sprintf(buf, "Illegal return value of %d from trade_with() (shop.c)",
            result);
    log("%s",buf);
    sprintf(buf, "%s An error has occurred.", GET_NAME(ch));
    break;
  }
  if (msg)
    do_tell(keeper, buf, cmd_tell, 0);
  return (0);
}

/* 1/21/01 - David Endre
   Added var and cha to the sell_price function. Var adds or subtracts the
   price of an object based on how many items a shopkeeper has. While cha
   compares the shopkeepers charisma to the players charisma and adjusts
   the price based on a comparison. Do not mess with these functions
   without talking to me, so I can explain them further. */


int sell_price(struct char_data * ch, struct char_data * keeper,
               struct obj_data * obj, int shop_nr)
{
  int cnt = 0, price = 0;
  double power = 0.0, cha = 0.0;

  cnt = do_count_objs(keeper, obj);

  cha = (double)(GET_AFFECTED_CHA(ch)/100.0);
  cha = (double)((cha - (GET_AFFECTED_CHA(keeper)/100.0))/2.0);

  price = (int)(GET_OBJ_COST(obj) * SHOP_SELLPROFIT(shop_nr));
  power = pow((1.0/(cnt+1.0)),(1.0/10.0));
  price = (int)((double)(price) * power);
  price = (int)(price * (1+cha));


  if (price < 0)
    price = 0;

  return (price);
}


struct obj_data *slide_obj(struct obj_data * obj, struct char_data * keeper,
                           int shop_nr)
     /*
       This function is a slight hack!  To make sure that duplicate items are
       only listed once on the "list", this function groups "identical"
       objects together on the shopkeeper's inventory list.  The hack involves
       knowing how the list is put together, and manipulating the order of
       the objects on the list.  (But since most of DIKU is not encapsulated,
       and information hiding is almost never used, it isn't that big a deal) -JF
     */
{
  struct obj_data *loop;
  int temp;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  /* Extract the object if it is identical to one produced */
  if (shop_producing(obj, shop_nr)) {
    temp = GET_OBJ_RNUM(obj);
    extract_obj(obj);
    return (&obj_proto[temp]);
  }
  SHOP_SORT(shop_nr)++;
  loop = keeper->carrying;
  obj_to_char(obj, keeper);
  keeper->carrying = loop;
  while (loop) {
    if (same_obj(obj, loop)) {
      obj->next_content = loop->next_content;
      loop->next_content = obj;
      return (obj);
    }
    loop = loop->next_content;
  }
  keeper->carrying = obj;
  return (obj);
}


void sort_keeper_objs(struct char_data * keeper, int shop_nr)
{
  struct obj_data *list = 0, *temp;

  while (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper)) {
    temp = keeper->carrying;
    obj_from_char(temp);
    temp->next_content = list;
    list = temp;
  }

  while (list) {
    temp = list;
    list = list->next_content;
    if ((shop_producing(temp, shop_nr)) &&
        !(find_obj_in_list(keeper->carrying, find_by_rnum(GET_OBJ_RNUM(temp))))) {
      obj_to_char(temp, keeper);
      SHOP_SORT(shop_nr)++;
    } else
      (void) slide_obj(temp, keeper, shop_nr);
  }
}

void apply_removecash(struct char_data * ch, int cash)
{
  int c_tot = 0;

  c_tot = GET_CASH(ch);
  GET_PLATINUM(ch) = 0;
  GET_GOLD(ch) = 0;
  GET_SILVER(ch) = 0;
  GET_COPPER(ch) = c_tot;
  GET_COPPER(ch) -= cash;
  adjust_cash(ch);
}

void shopping_sell(char *arg, struct char_data * ch,
                   struct char_data * keeper, int shop_nr)
{
  char tempstr[200], buf[MAX_STRING_LENGTH], name[200], sdesc[200];
  struct obj_data *obj, *tag = 0;
  int sellnum, sold = 0, cashamt = 0, cnt = 0;

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if ((sellnum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try buying something.",
            GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(*arg) || !(sellnum)) {
    sprintf(buf, "%s What do you want to sell??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;

  if (OBJ_FLAGGED(obj, ITEM_NODROP)) {
    sprintf(buf, "You can't sell $p.  It's CURSED!");
    act(buf, FALSE, ch, obj, obj, TO_CHAR);
    return;
  }

  cnt = do_count_objs(keeper, obj);
  if (cnt >= 25) {
    sprintf(buf, "%s Sorry, I have %d of those in stock already.", GET_NAME(ch), cnt);
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }

  if (GET_CASH(keeper) + SHOP_BANK(shop_nr) < sell_price(ch, keeper, obj, shop_nr)) {
    sprintf(buf, shop_index[shop_nr].missing_cash1, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }

  /* Get a copy of the object's short description, since it may well
   * be freed in the following loop. (And make sure the string is
   * terminated.) */
  strncpy(sdesc, obj->short_description, 200);
  sdesc[199] = 0;

  while ((obj) && (GET_CASH(keeper) + SHOP_BANK(shop_nr) >=
                   sell_price(ch, keeper, obj, shop_nr)) && (sold < sellnum)
                   && (cnt < 25)) {
    sold++;
    cnt++;

    cashamt += sell_price(ch, keeper, obj, shop_nr);
    apply_removecash(keeper, sell_price(ch, keeper, obj, shop_nr));

    obj_from_char(obj);
    /* If obj was just removed from a player, it has started decomposing.
     * We don't want shopkeeper inventory to decompose, so override that: */
    stop_decomposing(obj);
    tag = slide_obj(obj, keeper, shop_nr);
    obj = get_selling_obj(ch, name, keeper, shop_nr, FALSE);
  }

  if (sold < sellnum) {
    if (!obj)
      sprintf(buf, "%s You only have %d of those.", GET_NAME(ch), sold);
    else if (GET_CASH(keeper) + SHOP_BANK(shop_nr) <
             sell_price(ch, keeper, obj, shop_nr))
      sprintf(buf, "%s I can only afford to buy %d of those.",
              GET_NAME(ch), sold);
    else if (cnt >= 25)
      sprintf(buf, "%s I will only buy %d of those.",
              GET_NAME(ch), sold);
    else
      sprintf(buf, "%s Something really screwy made me buy %d.",
              GET_NAME(ch), sold);

    do_tell(keeper, buf, cmd_tell, 0);
  }
  apply_getcash(ch, cashamt);
  strcpy(tempstr, times_message(0, sdesc, sold));
  sprintf(buf, "$n sells %s.", tempstr);
  act(buf, FALSE, ch, 0, 0, TO_ROOM);

  sprintf(buf, shop_index[shop_nr].message_sell, GET_NAME(ch), 0);
  do_tell(keeper, buf, cmd_tell, 0);
  if (cashamt == 0) {
    sprintf(buf, "The shopkeeper now has %s.\r\n", tempstr);
    send_to_char(buf, ch);
    sprintf(buf, "You walk away empty handed.\r\nYou feel guilty for pawning worthless garbage.\r\n");
  } else {
    sprintf(buf, "%s accepts %s and pays you &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c coins.\r\n",
          GET_NAME(keeper), tempstr,
          PLATINUM_PART(cashamt), GOLD_PART(cashamt),
          SILVER_PART(cashamt), COPPER_PART(cashamt));
   }
  send_to_char(buf, ch);

  if (GET_CASH(keeper) < MIN_OUTSIDE_BANK) {
    cashamt = MIN(MAX_OUTSIDE_BANK - GET_CASH(keeper), SHOP_BANK(shop_nr));
    SHOP_BANK(shop_nr) -= cashamt;
    apply_getcash(keeper, cashamt);
  }
}


void shopping_value(char *arg, struct char_data * ch,
                    struct char_data * keeper, int shop_nr)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  char name[MAX_INPUT_LENGTH];
  int bp;
  int cnt = 0;
  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (!(*arg)) {
    sprintf(buf, "%s What do you want me to evaluate??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;

  if (OBJ_FLAGGED(obj, ITEM_NODROP)) {
    sprintf(buf, "%s Sorry, I do not buy cursed items.", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }

  cnt = do_count_objs(keeper, obj);
  if (cnt >= 25) {
    sprintf(buf, "%s Sorry that's of no value to me, I already have %d of those.", GET_NAME(ch), cnt);
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }

  bp = ((int)(sell_price(ch, keeper, obj, shop_nr)));
  if (bp == 0)
    sprintf(buf, "%s You ought to pay me to take that off of your hands!", GET_NAME(ch));
  else
    sprintf(buf, "%s I'll give you %dp, %dg, %ds, %dc for that!", GET_NAME(ch),
            PLATINUM_PART(bp), GOLD_PART(bp), SILVER_PART(bp), COPPER_PART(bp));
  do_tell(keeper, buf, cmd_tell, 0);

  return;
}


char *list_object(struct char_data *keeper, struct obj_data * obj,
                  struct char_data *ch, int cnt, int index, int shop_nr)
{
  static char buf[256];
  char buf2[300], buf3[200];
  int bp;

  sprintf(buf, "%2d)  %3d  ", index, GET_OBJ_LEVEL(obj));

  /* Compile object name and information */
  strcpy(buf3, obj->short_description);
  if ((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) && (GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING)))
    sprintf(END_OF(buf3), " of %s", LIQ_NAME(GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID)));
  if (!shop_producing(obj, shop_nr))
    sprintf(END_OF(buf3), " (x%2d)", cnt);

  /* FUTURE: */
  /* Add glow/hum/etc */

  if ((GET_OBJ_TYPE(obj) == ITEM_WAND) || (GET_OBJ_TYPE(obj) == ITEM_STAFF))
    if (GET_OBJ_VAL(obj, VAL_WAND_CHARGES_LEFT) < GET_OBJ_VAL(obj, VAL_WAND_MAX_CHARGES))
      strcat(buf3, " (partially used)");
  bp = ((int)(buy_price(ch, keeper, obj, shop_nr)));
  sprintf(buf2, "%-48s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\r\n", strip_ansi(buf3),
          PLATINUM_PART(bp), GOLD_PART(bp), SILVER_PART(bp), COPPER_PART(bp));
  strcat(buf, buf2);
  return (buf);
}


void shopping_list(char *arg, struct char_data * ch,
                   struct char_data * keeper, int shop_nr)
{
  char name[200];
  struct obj_data *obj, *last_obj = 0;
  int cnt = 0, index = 0;
  bool any = FALSE;

  if (!IS_GOD(ch))
    if (!(is_ok(keeper, ch, shop_nr)))
      return;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);
  one_argument(arg, name);

  if (keeper->carrying)
    for (obj = keeper->carrying; obj; obj = obj->next_content)
      if ((!(*name) || isname(name, obj->name)) &&
            CAN_SEE_OBJ(ch, obj) && (obj->obj_flags.cost > 0)) {
        if (!any) {
          any = TRUE;
          pprintf(ch, " ##  Lvl  Item                                                   Cost\r\n");
          pprintf(ch, "---  ---  ------------------------------------------------  -------------\r\n");
        }
        if (!last_obj) {
          last_obj = obj;
          cnt = 1;
        } else if (same_obj(last_obj, obj))
          cnt++;
        else {
          index++;
          if (!(*name) || isname(name, last_obj->name))
            pprintf(ch, "%s", list_object(keeper, last_obj, ch, cnt, index, shop_nr));
          cnt = 1;
          last_obj = obj;
        }
      }

  index++;
  if (!any) {
    if (*name)
      pprintf(ch, "Presently, none of those are for sale.\r\n");
    else
      pprintf(ch, "Currently, there is nothing for sale.\r\n");
  } else if (!(*name) || isname(name, last_obj->name))
    pprintf(ch, "%s", list_object(keeper, last_obj, ch, cnt, index, shop_nr));

  start_paging(ch);
}


int ok_shop_room(int shop_nr, int room)
{
  int index;

  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++)
    if (SHOP_ROOM(shop_nr, index) == room)
      return (TRUE);
  return (FALSE);
}

int my_shop_nr(struct char_data *ch)
{
  int shop_nr;

  if (!IS_NPC(ch)) return -1;

  for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
    if (SHOP_KEEPER(shop_nr) == GET_MOB_RNUM(ch))
      return shop_nr;

  return -1;
}

/* give_shopkeeper_reject()
 *
 * Returns TRUE if it's a shopkeeper who doesn't want it.
 * Returns FALSE otherwise, and sends act() messages.
 */
bool give_shopkeeper_reject(
      struct char_data *ch,
      struct char_data *vict,
      struct obj_data *obj)
{
   int shop_nr;

   shop_nr = my_shop_nr(vict);
   if (shop_nr < 0)
      return FALSE;
   switch (trade_with(obj, shop_nr)) {
      case OBJECT_NOTOK:
         act("$N briskly refuses.", FALSE, ch, 0, vict, TO_CHAR);
         act("$N briskly refuses $p from $n.", TRUE, ch, obj, vict, TO_NOTVICT);
         act("You briskly refuse $p from $N.", FALSE, vict, obj, ch, TO_CHAR);
         return TRUE;
         break;
      case OBJECT_DEAD:
         act("$N stares at $p and shakes $S head.", FALSE, ch, obj, vict, TO_CHAR);
         act("$N glares at $n and refuses $p.", TRUE, ch, obj, vict, TO_NOTVICT);
         act("You glare at $N and refuse $p.", FALSE, vict, obj, ch, TO_CHAR);
         return TRUE;
         break;
   }
   return FALSE;
}

SPECIAL(shop_keeper)
{
  char argm[MAX_INPUT_LENGTH];
  struct char_data *keeper = (struct char_data *) me;
  int shop_nr;

  shop_nr = my_shop_nr(keeper);
  if (shop_nr < 0) return FALSE;

  if (SHOP_FUNC(shop_nr))        /* Check secondary function */
    if ((SHOP_FUNC(shop_nr)) (ch, me, cmd, arg))
      return (TRUE);

  if (keeper == ch) {
    if (cmd)
      SHOP_SORT(shop_nr) = 0;        /* Safety in case "drop all" */
    return (FALSE);
  }
  if (!ok_shop_room(shop_nr, world[ch->in_room].vnum))
    return (0);

  if (!AWAKE(keeper))
    return (FALSE);

  if (CMD_IS("steal")) {
    sprintf(argm, "$N shouts '%s'", MSG_NO_STEAL_HERE);
    do_action(keeper, GET_NAME(ch), cmd_slap, 0);
    act(argm, FALSE, ch, 0, keeper, TO_CHAR);
    return (TRUE);
  }

  if (CMD_IS("buy")) {
    shopping_buy(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("sell")) {
    shopping_sell(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("value")) {
    shopping_value(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("list")) {
    shopping_list(argument, ch, keeper, shop_nr);
    return (TRUE);
  }
  return (FALSE);
}


int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim)
{
  char buf[200];
  int index;

  if (IS_NPC(victim) && (mob_index[GET_MOB_RNUM(victim)].func == shop_keeper))
    for (index = 0; index < top_shop; index++)
      if ((GET_MOB_RNUM(victim) == SHOP_KEEPER(index)) && !SHOP_KILL_CHARS(index)) {
        do_action(victim, GET_NAME(ch), cmd_slap, 0);
        sprintf(buf, "%s %s", GET_NAME(ch), MSG_CANT_KILL_KEEPER);
        do_tell(victim, buf, cmd_tell, 0);
        return (FALSE);
      }
  return (TRUE);
}


int add_to_list(struct shop_buy_data * list, int type, int *len, int *val, int *amount)
{
  if (type == LIST_PRODUCE)
    BUY_AMOUNT(list[*len]) = *amount;
  if (*val >= 0) {
    if (*len < MAX_SHOP_OBJ) {
      if (type == LIST_PRODUCE)
        *val = real_object(*val);
      if (*val >= 0) {
        BUY_TYPE(list[*len]) = *val;
        BUY_WORD(list[(*len)++]) = 0;
      } else
        *val = 0;
      return (FALSE);
    } else
      return (TRUE);
  }
  return (FALSE);
}

int end_read_list(struct shop_buy_data * list, int len, int error)
{
  if (error) {
    sprintf(buf, "Raise MAX_SHOP_OBJ constant in shop.h to %d", len + error);
    log("%s",buf);
  }
  BUY_WORD(list[len]) = 0;
  BUY_AMOUNT(list[len]) = 0;
  BUY_TYPE(list[len++]) = NOTHING;
  return (len);
}

/* split into read_int_line and read_float_line by gurlaek 8/27/1999 */
void read_int_line(FILE * shop_f, int *data)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, "%d", data)) {
    fprintf(stderr, "Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}

void read_float_line(FILE * shop_f, float *data)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, "%f", data)) {
    fprintf(stderr, "Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}
/* removed the void *'s and replaced with ints -gurlaek 8/27/1999 */
void read_double_line(FILE * shop_f, int *data, int *data2)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, "%d %d", data, data2)) {
    fprintf(stderr, "Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}

int read_list(FILE * shop_f, struct shop_buy_data * list, int new_format,
              int max, int type)
{
  int count, temp, len = 0, error = 0;
  int amount = 0;
  if (new_format) {
    do {
      amount = 0;/*defult amount set to 0*/
      read_double_line(shop_f, &temp, &amount);
      error += add_to_list(list, type, &len, &temp, &amount);
    } while (temp >= 0);
  } else
    for (count = 0; count < max; count++) {
      read_int_line(shop_f, &temp);
      error += add_to_list(list, type, &len, &temp, &amount);
    }
  return (end_read_list(list, len, error));
}


int read_type_list(FILE * shop_f, struct shop_buy_data * list,
                   int new_format, int max)
{
  int index, num, len = 0, error = 0, spare = -10;
  char *ptr;

  if (!new_format)
    return (read_list(shop_f, list, 0, max, LIST_TRADE));
  do {
    fgets(buf, MAX_STRING_LENGTH - 1, shop_f);
    if ((ptr = strchr(buf, ';')) != NULL)
      *ptr = 0;
    else
      *(END_OF(buf) - 1) = 0;
    for (index = 0, num = NOTHING; index < NUM_ITEM_TYPES; ++index)
      if (!strn_cmp(item_types[index].name, buf, strlen(item_types[index].name))) {
        num = index;
        strcpy(buf, buf + strlen(item_types[index].name));
        break;
      }
    ptr = buf;
    if (num == NOTHING) {
      sscanf(buf, "%d", &num);
      while (!isdigit(*ptr))
        ptr++;
      while (isdigit(*ptr))
        ptr++;
    }
    while (isspace(*ptr))
      ptr++;
    while (isspace(*(END_OF(ptr) - 1)))
      *(END_OF(ptr) - 1) = 0;
    error += add_to_list(list, LIST_TRADE, &len, &num, &spare);
    if (*ptr)
      BUY_WORD(list[len - 1]) = strdup(ptr);
  } while (num >= 0);
  return (end_read_list(list, len, error));
}


void boot_the_shops(FILE * shop_f, char *filename, int rec_count)
{
  char *buf, buf2[150];
  int temp, count, new_format = 0;
  struct shop_buy_data list[MAX_SHOP_OBJ + 1];
  int done = 0;

  sprintf(buf2, "beginning of shop file %s", filename);

  while (!done) {
    buf = fread_string(shop_f, buf2);
    if (*buf == '#') {                /* New shop */
      sscanf(buf, "#%d\n", &temp);
      sprintf(buf2, "shop #%d in shop file %s", temp, filename);
      free(buf);                /* Plug memory leak! */
      if (!top_shop)
        CREATE(shop_index, struct shop_data, rec_count);

      SHOP_NUM(top_shop) = temp;
      temp = read_list(shop_f, list, new_format, MAX_PROD, LIST_PRODUCE);
      CREATE(shop_index[top_shop].producing, int, temp);
      CREATE(shop_index[top_shop].amount, int, temp);
      for (count = 0; count < temp; count++) {
        SHOP_PRODUCT(top_shop, count) = BUY_TYPE(list[count]);
        SHOP_AMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);}
      read_float_line(shop_f, &SHOP_BUYPROFIT(top_shop));
      read_float_line(shop_f, &SHOP_SELLPROFIT(top_shop));

      temp = read_type_list(shop_f, list, new_format, MAX_TRADE);
      CREATE(shop_index[top_shop].type, struct shop_buy_data, temp);
      for (count = 0; count < temp; count++) {
        SHOP_BUYTYPE(top_shop, count) = BUY_TYPE(list[count]);
        SHOP_BUYAMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);
        SHOP_BUYWORD(top_shop, count) = BUY_WORD(list[count]);
      }

      shop_index[top_shop].no_such_item1 = fread_string(shop_f, buf2);
      shop_index[top_shop].no_such_item2 = fread_string(shop_f, buf2);
      shop_index[top_shop].do_not_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash1 = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash2 = fread_string(shop_f, buf2);
      shop_index[top_shop].message_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].message_sell = fread_string(shop_f, buf2);
      read_int_line(shop_f, &SHOP_BROKE_TEMPER(top_shop));
      read_int_line(shop_f, &SHOP_BITVECTOR(top_shop));
      read_int_line(shop_f, &SHOP_KEEPER(top_shop));

      SHOP_KEEPER(top_shop) = real_mobile(SHOP_KEEPER(top_shop));
      read_int_line(shop_f, &SHOP_TRADE_WITH(top_shop));

      temp = read_list(shop_f, list, new_format, 1, LIST_ROOM);
      CREATE(shop_index[top_shop].in_room, int, temp);
      for (count = 0; count < temp; count++)
        SHOP_ROOM(top_shop, count) = BUY_TYPE(list[count]);

      read_int_line(shop_f, &SHOP_OPEN1(top_shop));
      read_int_line(shop_f, &SHOP_CLOSE1(top_shop));
      read_int_line(shop_f, &SHOP_OPEN2(top_shop));
      read_int_line(shop_f, &SHOP_CLOSE2(top_shop));

      SHOP_BANK(top_shop) = 0;
      SHOP_SORT(top_shop) = 0;
      SHOP_FUNC(top_shop) = 0;
      top_shop++;
    } else {
      if (*buf == '$')                /* EOF */
        done = TRUE;
      else if (strstr(buf, VERSION3_TAG))        /* New format marker */
        new_format = 1;
      free(buf);                /* Plug memory leak! */
    }
  }
}


void assign_the_shopkeepers(void)
{
  int index;

  cmd_say = find_command("say");
  cmd_tell = find_command("tell");
  cmd_emote = find_command("emote");
  cmd_slap = find_command("slap");
  cmd_snicker = find_command("snicker");
  for (index = 0; index < top_shop; index++) {
    if (SHOP_KEEPER(index) == NOBODY)
      continue;
    if (mob_index[SHOP_KEEPER(index)].func)
      SHOP_FUNC(index) = mob_index[SHOP_KEEPER(index)].func;
    mob_index[SHOP_KEEPER(index)].func = shop_keeper;
  }
}


char *customer_string(int shop_nr, int detailed)
{
  int index, cnt = 1;
  static char buf[256];

  *buf = 0;
  for (index = 0; *trade_letters[index] != '\n'; index++, cnt *= 2)
    if (!(SHOP_TRADE_WITH(shop_nr) & cnt))
      if (detailed) {
        if (*buf)
          strcat(buf, ", ");
        strcat(buf, trade_letters[index]);
      } else
        sprintf(END_OF(buf), "%c", *trade_letters[index]);
    else if (!detailed)
      strcat(buf, "_");

  return (buf);
}



void handle_detailed_list(char *buf, char *buf1, struct char_data * ch)
{
  if ((strlen(buf1) + strlen(buf) < 78) || (strlen(buf) < 20))
    strcat(buf, buf1);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    sprintf(buf, "            %s", buf1);
  }
}


void list_detailed_shop(struct char_data * ch, int shop_nr)
{
  struct obj_data *obj;
  struct char_data *k;
  int index, temp;

  sprintf(buf, "Vnum:       [%5d], Rnum: [%5d]\r\n", SHOP_NUM(shop_nr),
          shop_nr + 1);
  send_to_char(buf, ch);

  strcpy(buf, "Rooms:      ");
  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++) {
    if (index)
      strcat(buf, ", ");
    if ((temp = real_room(SHOP_ROOM(shop_nr, index))) != NOWHERE)
      sprintf(buf1, "%s (#%d)", world[temp].name, world[temp].vnum);
    else
      sprintf(buf1, "<UNKNOWN> (#%d)", SHOP_ROOM(shop_nr, index));
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Rooms:      None!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Shopkeeper: ");
  if (SHOP_KEEPER(shop_nr) >= 0) {
    sprintf(END_OF(buf), "%s (#%d), Special Function: %s\r\n",
            GET_NAME(&mob_proto[SHOP_KEEPER(shop_nr)]),
            mob_index[SHOP_KEEPER(shop_nr)].virtual, YESNO(SHOP_FUNC(shop_nr)));
    if ((k = find_char_in_world(find_by_rnum(SHOP_KEEPER(shop_nr))))) {
      send_to_char(buf, ch);
      sprintf(buf, "Coins:      [%9d], Bank: [%9d] (Total: %d)\r\n",
              GET_GOLD(k), SHOP_BANK(shop_nr), GET_GOLD(k) + SHOP_BANK(shop_nr));
    }
  } else
    strcat(buf, "<NONE>\r\n");
  send_to_char(buf, ch);

  strcpy(buf1, customer_string(shop_nr, TRUE));
  sprintf(buf, "Customers:  %s\r\n", (*buf1) ? buf1 : "None");
  send_to_char(buf, ch);

  strcpy(buf, "Produces:   ");
  for (index = 0; SHOP_PRODUCT(shop_nr, index) != NOTHING; index++) {
    obj = &obj_proto[SHOP_PRODUCT(shop_nr, index)];
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d)", obj->short_description,
            obj_index[SHOP_PRODUCT(shop_nr, index)].virtual);
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Produces:   Nothing!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Buys:       ");
  for (index = 0; SHOP_BUYTYPE(shop_nr, index) != NOTHING; index++) {
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d) ", item_types[SHOP_BUYTYPE(shop_nr, index)].name,
            SHOP_BUYTYPE(shop_nr, index));
    if (SHOP_BUYWORD(shop_nr, index))
      sprintf(END_OF(buf1), "[%s]", SHOP_BUYWORD(shop_nr, index));
    else
      strcat(buf1, "[all]");
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Buys:       Nothing!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  sprintf(buf, "Buy at:     [%4.2f], Sell at: [%4.2f], Open: [%d-%d, %d-%d]%s",
          SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr), SHOP_OPEN1(shop_nr),
          SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\r\n");

  send_to_char(buf, ch);

  sprintbit((long) SHOP_BITVECTOR(shop_nr), shop_bits, buf1);
  sprintf(buf, "Bits:       %s\r\n", buf1);
  send_to_char(buf, ch);
}

void do_stat_shop(struct char_data *ch, char *arg)
{
   int shop_nr, sh_virt;

   if (*arg) {
      if (isdigit(arg[0])) {
         sh_virt = atoi(arg);
         for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
            if (shop_index[shop_nr].virtual == sh_virt)
               break;
         if (shop_nr >= top_shop) {
            send_to_char("There is no such shop.\r\n", ch);
            return;
         }
      } else {
         send_to_char("That isn't a shop number!\r\n", ch);
         return;
      }
   } else {
      for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
         if (ok_shop_room(shop_nr, world[ch->in_room].vnum))
            break;
      if (shop_nr >= top_shop) {
         send_to_char("There's no shop here.\r\n", ch);
         return;
      }
   }
   list_detailed_shop(ch, shop_nr);
}

void list_shops(struct char_data *ch, int start, int end)
{
   int shop_nr, num = 0, room;
   bool any = FALSE;

   strcpy(buf, "\r\n");
   for (shop_nr = 0; shop_nr < top_shop; shop_nr++) {
      if (shop_index[shop_nr].virtual >= start && shop_index[shop_nr].virtual <= end) {
         if (!any || !(num % 19)) {
            any = TRUE;
            strcat(buf, " ##   Virtual   Keeper    Buy     Sell     Customers   Where\r\n");
            strcat(buf, "------------------------------------------------------------------------\r\n");
         }
         num++;
         room = real_room(SHOP_ROOM(shop_nr, 0));
         sprintf(buf2, "%3d  %6d    ", num, SHOP_NUM(shop_nr));
         if (SHOP_KEEPER(shop_nr) < 0)
            strcpy(buf1, "<NONE>");
         else
            sprintf(buf1, "%6d", mob_index[SHOP_KEEPER(shop_nr)].virtual);
         sprintf(END_OF(buf2), "%s     %3.2f    %3.2f     ", buf1,
               SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr));
         strcat(buf2, customer_string(shop_nr, FALSE));
         sprintf(END_OF(buf), "%s   %6d - %s\r\n", buf2, SHOP_ROOM(shop_nr, 0),
               room == NOWHERE ? "<NOWHERE>" : world[room].name
               );
      }
   }

   if (any)
      page_string(ch, buf);
   else
      send_to_char("No shops found.\r\n", ch);
}

int vnum_shop(char *searchname, struct char_data * ch)
{
   int nr, found = 0, room;

   for (nr = 0; nr < top_shop; nr++) {
      room = real_room(SHOP_ROOM(nr, 0));
      if (room != NOWHERE && isname(searchname, world[room].name)) {
         sprintf(buf, "%3d. [%5d] (%5d) %s\r\n", ++found, SHOP_NUM(nr), SHOP_ROOM(nr, 0),
               world[room].name);
         send_to_char(buf, ch);
      }
   }
   return found;
}

void show_shops(struct char_data * ch, char *arg)
{
   int shop_nr;

   if (!*arg) {
      list_shops(ch, 0, MAX_VNUM);
      return;
   }

   else {
    if (!str_cmp(arg, ".")) {
      for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
        if (ok_shop_room(shop_nr, world[ch->in_room].vnum))
          break;

      if (shop_nr == top_shop) {
        send_to_char("This isn't a shop!\r\n", ch);
        return;
      }
    } else if (is_number(arg))
      shop_nr = atoi(arg) - 1;
    else
      shop_nr = -1;

    if ((shop_nr < 0) || (shop_nr >= top_shop)) {
      send_to_char("Illegal shop number.\r\n", ch);
      return;
    }
    list_detailed_shop(ch, shop_nr);
  }
}

void destroy_shops(void) {
  ssize_t cnt, itr;

  if (!shop_index)
    return;

  for (cnt = 0; cnt <= top_shop; cnt++) {
    if (shop_index[cnt].no_such_item1)
      free(shop_index[cnt].no_such_item1);
    if (shop_index[cnt].no_such_item2)
      free(shop_index[cnt].no_such_item2);
    if (shop_index[cnt].missing_cash1)
      free(shop_index[cnt].missing_cash1);
    if (shop_index[cnt].missing_cash2)
      free(shop_index[cnt].missing_cash2);
    if (shop_index[cnt].do_not_buy)
      free(shop_index[cnt].do_not_buy);
    if (shop_index[cnt].message_buy)
      free(shop_index[cnt].message_buy);
    if (shop_index[cnt].message_sell)
      free(shop_index[cnt].message_sell);
    if (shop_index[cnt].in_room)
      free(shop_index[cnt].in_room);
    if (shop_index[cnt].producing)
      free(shop_index[cnt].producing);
    if (shop_index[cnt].amount)
      free(shop_index[cnt].amount);

    if (shop_index[cnt].type) {
      for (itr = 0; BUY_TYPE(shop_index[cnt].type[itr]) != NOTHING; ++itr)
        if (BUY_WORD(shop_index[cnt].type[itr]))
          free(BUY_WORD(shop_index[cnt].type[itr]));
      free(shop_index[cnt].type);
    }
  }

  free(shop_index);
  shop_index = NULL;
  top_shop = -1;
}


/***************************************************************************
 * $Log: shop.c,v $
 * Revision 1.62  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.61  2010/06/20 19:53:47  mud
 * Log to file errors we might want to see.
 *
 * Revision 1.59  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.58  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.57  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.56  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.55  2008/09/21 17:58:35  jps
 * Don't print the shop list header when none of a requested object is for sale.
 *
 * Revision 1.54  2008/09/20 07:51:45  jps
 * Don't charge immortals money in shops.
 *
 * Revision 1.53  2008/09/09 19:02:23  jps
 * Stop items that have been sold to shops from decomposing.
 *
 * Revision 1.52  2008/09/03 17:34:08  myc
 * Moved liquid information into a def struct array.
 *
 * Revision 1.51  2008/08/31 17:09:26  myc
 * Remove debug from shop system.
 *
 * Revision 1.50  2008/08/19 02:11:14  jps
 * Don't apply fluid/rigidity restrictions to immortals.
 *
 * Revision 1.49  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.48  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.47  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.46  2008/06/19 18:53:12  myc
 * Replaced the item_types array with a typedef struct array in objects.c.
 *
 * Revision 1.45  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.44  2008/06/05 02:07:43  myc
 * Changed object flags to use flagvectors.
 *
 * Revision 1.43  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.42  2008/04/05 22:03:34  jps
 * Ensure that players are never said to have a shop number.
 *
 * Revision 1.41  2008/04/04 03:43:31  jps
 * Add give_shopkeeper_reject(), which allows shopkeepers to refuse
 * to be given objects that they wouldn't sell.
 *
 * Revision 1.40  2008/04/03 02:05:34  myc
 * Depending on screen.h now.
 *
 * Revision 1.39  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.38  2008/03/26 23:32:09  jps
 * Prevent buying things when in a fluid state.
 *
 * Revision 1.37  2008/02/16 20:31:32  myc
 * Adding function to free shops at program termination.
 *
 * Revision 1.36  2008/02/15 03:29:29  jps
 * Was going to fix something, and tidied up some code, but it
 * seemed to have been fixed already and I didn't actually
 * change anything.
 *
 * Revision 1.35  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.34  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.33  2008/01/27 12:12:55  jps
 * Changed IS_THIEF macro to IS_ROGUE.
 *
 * Revision 1.32  2008/01/27 01:42:03  jps
 * Fix grammar when informing player of cursed objects.
 *
 * Revision 1.31  2008/01/23 02:33:26  jps
 * Make shopping bills come out of lower-denomination coins first.
 *
 * Revision 1.30  2008/01/09 02:30:14  jps
 * Use macro to get mob real number.
 *
 * Revision 1.29  2008/01/02 07:11:21  jps
 * Using class.h.
 *
 * Revision 1.28  2007/09/20 09:34:34  jps
 * Improve feedback when selling things.
 *
 * Revision 1.27  2007/09/12 19:23:04  myc
 * Shop keepers give correct response when 'buy' is typed without arguments.
 * Shop keepers won't throw up on you anymore.
 *
 * Revision 1.26  2007/09/03 23:59:43  jps
 * Added macro ADDED_WEIGHT_OK for testing whether a char can have an
 * object added to its inventory.  Avoids an integer overflow problem
 * that could occur if an object's weight was near maxint.
 *
 * Revision 1.25  2007/08/24 22:59:55  jps
 * Correctly state that none are for sale when "list <name>" doesn't
 * match any of the items for sale.
 *
 * Revision 1.24  2007/08/24 22:49:05  jps
 * Added function vnum_shop() for use with the "snum" command.
 *
 * Revision 1.23  2007/08/24 22:10:58  jps
 * Add commands "slist" and "sstat".
 *
 * Revision 1.22  2007/05/24 03:35:11  jps
 * Display an item's full name when selling, rather than just whatever
 * the seller typed.
 *
 * Revision 1.21  2006/11/08 07:21:31  jps
 * Minimum sell price for any item is now 1 copper.
 *
 * Revision 1.20  2006/07/20 07:43:07  cjd
 * Typo fixes.
 *
 * Revision 1.19  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.18  2001/05/03 03:20:05  dce
 * Shopkeepers will no longer buy cursed items.
 *
 * Revision 1.17  2001/03/24 19:26:06  dce
 * Object level shows up in the list command at shops.
 *
 * Revision 1.16  2001/03/14 02:33:55  dce
 * Shopkeepers will only buy 25 of the same object.
 *
 * Revision 1.15  2001/03/13 01:57:29  dce
 * Shopkeepers no longer say, 'I have ...'
 *
 * Revision 1.14  2001/02/18 20:34:05  dce
 * Invis gods can now do a list.
 * Also removed a bogus message.
 *
 * Revision 1.13  2001/02/08 01:31:05  dce
 * Striped the color from short item descriptions in the list
 * command. It was causing mis-aligned columns.
 *
 * Revision 1.12  2001/01/23 00:15:57  dce
 * Lengthed the display for list so that items align more correctly.
 * Changed the value from 40 to 47. You oculd maybe do 50, but it's
 * pushing the width of normal people's screens.
 *
 * Revision 1.11  2001/01/22 04:14:13  dce
 * Added a charisma check and an items count check to shopkeepers
 * Shopkeers will now adjust the price based on these factors.
 *
 * Revision 1.10  2001/01/16 03:13:27  dce
 * Fixed some typos
 *
 * Revision 1.9  2001/01/16 03:10:47  dce
 * Added message for 0 value items.
 *
 * Revision 1.8  2001/01/12 02:35:04  dce
 * Completely re-did the existing shop code and the way it handled
 * money. Previously it used just GET_GOLD and didn't take into
 * account silver, platinum or copper.
 *
 * Revision 1.7  2000/11/24 21:30:22  rsd
 * Altered comment header and added back rlog messages from
 * prior to the addition of the $log$ string.
 *
 * Revision 1.6  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.5  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most significant
 * changes were moving all the BREATH's to within normal spell range, and
 * fixing the way socials were allocated.  Too many small fixes to list them
 * all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.4  1999/08/28 00:31:16  mtp
 * typo in apply_getcash fixed now sell should work
 *
 * Revision 1.3  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.2  1999/02/02 02:18:34  mud
 * indented file
 * dos2unix
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.62
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.61 2010/06/20 19:53:47 mud Exp $
d670 1
a670 1
   sprintf(tempstr, times_message(ch->carrying, 0, bought));
d1054 1
a1054 1
            pprintf(ch, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
d1067 1
a1067 1
    pprintf(ch, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
d1685 3
@


1.61
log
@Log to file errors we might want to see.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.60 2010/06/20 19:31:52 mud Exp mud $
d719 1
a719 1
    log(buf);
d1217 1
a1217 1
    log(buf);
d1685 3
@


1.60
log
@Fix bug allowing players to purchase items such as gems for free
from shops.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.59 2009/03/09 20:36:00 myc Exp mud $
d486 1
a486 1
    mudlog(buf, BRF, LVL_GOD, FALSE);
a606 12
      /* Give the money to the shopkeeper */
      copperamt += buy_price(ch, keeper, obj, shop_nr);

      /*
       * Charge the buyer BEFORE giving them the item, because
       * buy_price changes its return value depending on how many
       * of the item the shopkeeper is holding.
       */
      if (GET_LEVEL(ch) < LVL_IMMORT) {
         apply_cost(buy_price(ch, keeper, obj, shop_nr), ch);
      }

d629 15
@


1.59
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.58 2009/03/09 04:33:20 jps Exp myc $
d607 12
a640 8
      /* Give the money to the shopkeeper */
      copperamt += buy_price(ch, keeper, obj, shop_nr);

      /* Charge the buyer */
      if (GET_LEVEL(ch) < LVL_IMMORT) {
         apply_cost(buy_price(ch, keeper, obj, shop_nr), ch);
      }

d1682 3
@


1.58
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.57 2009/03/08 21:43:27 jps Exp jps $
d464 4
a467 9
  int temp, temp2, temp3, temp4 = 0;
  temp = ((int)(cash)/1000);
  temp2 = ((int)((int)(cash/100)-(temp*10)));
  temp3 = ((int)((((int)(cash/10))-(temp*100))-temp2*10));
  temp4 = ((int)((((cash)-(temp*1000))-(temp2*100))-(temp3*10)));
  GET_PLAT(ch) += temp;
  GET_GOLD(ch) += temp2;
  GET_SILVER(ch) += temp3;
  GET_COPPER(ch) += temp4;
d472 5
a476 11
  int temp, temp2, temp3, temp4, cash = 0;

  cash = GET_CASH(ch);
  temp = ((int)(cash)/1000);
  temp2 = ((int)((int)(cash/100)-(temp*10)));
  temp3 = ((int)((((int)(cash/10))-(temp*100))-temp2*10));
  temp4 = ((int)((((cash)-(temp*1000))-(temp2*100))-(temp3*10)));
  GET_PLAT(ch) = temp;
  GET_GOLD(ch) = temp2;
  GET_SILVER(ch) = temp3;
  GET_COPPER(ch) = temp4;
d491 1
a491 1
  haveP = GET_PLAT(ch);
d523 1
a523 1
  GET_PLAT(ch) = haveP;
d675 1
a675 1
         GET_PLAT(keeper) = 0;
d821 1
a821 1
  GET_PLAT(ch) = 0;
d834 1
a834 1
  int sellnum, sold = 0, goldamt = 0, temp, temp2, temp3, temp4, cnt = 0;
d885 1
a885 1
    goldamt += sell_price(ch, keeper, obj, shop_nr);
d912 1
a912 1
  apply_getcash(ch, goldamt);
d919 1
a919 5
  temp = ((int)(goldamt)/1000);
  temp2 = ((int)((int)(goldamt/100)-(temp*10)));
  temp3 = ((int)((((int)(goldamt/10))-(temp*100))-temp2*10));
  temp4 = ((int)((((goldamt)-(temp*1000))-(temp2*100))-(temp3*10)));
  if (temp == 0 && temp2 == 0 && temp3 == 0 && temp4 == 0) {
d926 2
a927 1
          temp, temp2, temp3, temp4);
d932 3
a934 3
    goldamt = MIN(MAX_OUTSIDE_BANK - GET_CASH(keeper), SHOP_BANK(shop_nr));
    SHOP_BANK(shop_nr) -= goldamt;
    apply_getcash(keeper, goldamt);
d945 1
a945 1
  int bp, temp, temp2, temp3, temp4 = 0;
d973 1
a973 5
  temp = ((int)(bp)/1000);
  temp2 = ((int)((int)(bp/100)-(temp*10)));
  temp3 = ((int)((((int)(bp/10))-(temp*100))-temp2*10));
  temp4 = ((int)((((bp)-(temp*1000))-(temp2*100))-(temp3*10)));
  if (temp == 0 && temp2 == 0 && temp3 == 0 && temp4 == 0)
d976 2
a977 1
    sprintf(buf, "%s I'll give you %dp, %dg, %ds, %dc for that!", GET_NAME(ch), temp, temp2, temp3, temp4);
d989 1
a989 1
  int bp, temp, temp2, temp3, temp4;
d1007 2
a1008 5
  temp = ((int)(bp)/1000);
  temp2 = ((int)((int)(bp/100)-(temp*10)));
  temp3 = ((int)((((int)(bp/10))-(temp*100))-temp2*10));
  temp4 = ((int)((((bp)-(temp*1000))-(temp2*100))-(temp3*10)));
  sprintf(buf2, "%-48s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\r\n", strip_ansi(buf3), temp, temp2, temp3, temp4);
d1678 4
@


1.57
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.56 2009/03/03 19:43:44 myc Exp jps $
d38 1
d1698 3
@


1.56
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.55 2008/09/21 17:58:35 jps Exp myc $
d37 1
d1697 3
@


1.55
log
@Don't print the shop list header when none of a requested object is for sale.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.54 2008/09/20 07:51:45 jps Exp jps $
d343 1
a343 1
  if (!(number = get_number(&tmp)))
d701 1
a701 1
  if (!(obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
d817 1
a817 1
        !(get_obj_in_list_num(GET_OBJ_RNUM(temp), keeper->carrying))) {
d1481 1
a1481 1
    if ((k = get_char_num(SHOP_KEEPER(shop_nr)))) {
d1696 3
@


1.54
log
@Don't charge immortals money in shops.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.53 2008/09/09 19:02:23 jps Exp jps $
d1038 1
a1045 1

a1047 3
  pprintf(ch, " ##  Lvl  Item                                                   Cost\r\n");
  pprintf(ch, "---  ---  ------------------------------------------------  -------------\r\n");

d1052 5
d1072 1
a1072 1
  if (!last_obj)
d1077 1
a1077 1
  else if (!(*name) || isname(name, last_obj->name))
d1696 3
@


1.53
log
@Stop items that have been sold to shops from decomposing.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.52 2008/09/03 17:34:08 myc Exp jps $
d609 1
a609 1
         ((GET_CASH(ch) >= buy_price(ch, keeper, obj, shop_nr)) || IS_GOD(ch)) &&
d642 1
a642 1
      if (!IS_GOD(ch)) {
d669 1
a669 1
   if (!IS_GOD(ch))
d1694 3
@


1.52
log
@Moved liquid information into a def struct array.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.51 2008/08/31 17:09:26 myc Exp myc $
d36 1
d898 3
d1694 3
@


1.51
log
@Remove debug from shop system.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.50 2008/08/19 02:11:14 jps Exp myc $
d1007 1
a1007 1
    sprintf(END_OF(buf3), " of %s", drinks[GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID)]);
d1690 3
@


1.50
log
@Don't apply fluid/rigidity restrictions to immortals.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.49 2008/08/18 01:35:38 jps Exp jps $
a503 4
  sprintf(buf, "Cost: %d  Before:  %d P  %d G  %d S  %d C",
        cost, haveP, haveG, haveS, haveC);
  log(buf);

a522 4
  sprintf(buf, "Cost: %d  After:  %d P  %d G  %d S  %d C",
        cost, haveP, haveG, haveS, haveC);
  log(buf);

d1690 3
@


1.49
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.48 2008/08/15 03:59:08 jps Exp jps $
d578 1
a578 1
   if (!RIGID(ch)) {
d1698 3
@


1.48
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.47 2008/08/14 09:45:22 jps Exp jps $
d601 1
a601 1
      sprintf(buf, "%s: You can't carry any more items.\n\r",
d608 1
a608 1
      sprintf(buf, "%s: You can't carry that much weight.\n\r",
d685 1
a685 1
   sprintf(buf, "You now have %s.\n\r", tempstr);
d937 1
a937 1
    sprintf(buf, "The shopkeeper now has %s.\n\r", tempstr);
d1030 1
a1030 1
  sprintf(buf2, "%-48s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", strip_ansi(buf3), temp, temp2, temp3, temp4);
d1052 2
a1053 2
  pprintf(ch, " ##  Lvl  Item                                                   Cost\n\r");
  pprintf(ch, "---  ---  ------------------------------------------------  -------------\n\r");
d1076 1
a1076 1
      pprintf(ch, "Presently, none of those are for sale.\n\r");
d1078 1
a1078 1
      pprintf(ch, "Currently, there is nothing for sale.\n\r");
d1444 1
a1444 1
    strcat(buf, "\n\r");
d1457 1
a1457 1
  sprintf(buf, "Vnum:       [%5d], Rnum: [%5d]\n\r", SHOP_NUM(shop_nr),
d1472 1
a1472 1
    send_to_char("Rooms:      None!\n\r", ch);
d1474 1
a1474 1
    strcat(buf, "\n\r");
d1480 1
a1480 1
    sprintf(END_OF(buf), "%s (#%d), Special Function: %s\n\r",
d1485 1
a1485 1
      sprintf(buf, "Coins:      [%9d], Bank: [%9d] (Total: %d)\n\r",
d1489 1
a1489 1
    strcat(buf, "<NONE>\n\r");
d1493 1
a1493 1
  sprintf(buf, "Customers:  %s\n\r", (*buf1) ? buf1 : "None");
d1506 1
a1506 1
    send_to_char("Produces:   Nothing!\n\r", ch);
d1508 1
a1508 1
    strcat(buf, "\n\r");
d1525 1
a1525 1
    send_to_char("Buys:       Nothing!\n\r", ch);
d1527 1
a1527 1
    strcat(buf, "\n\r");
d1533 1
a1533 1
          SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\n\r");
d1538 1
a1538 1
  sprintf(buf, "Bits:       %s\n\r", buf1);
d1577 1
a1577 1
   strcpy(buf, "\n\r");
d1582 2
a1583 2
            strcat(buf, " ##   Virtual   Keeper    Buy     Sell     Customers   Where\n\r");
            strcat(buf, "------------------------------------------------------------------------\n\r");
d1595 1
a1595 1
         sprintf(END_OF(buf), "%s   %6d - %s\n\r", buf2, SHOP_ROOM(shop_nr, 0),
d1638 1
a1638 1
        send_to_char("This isn't a shop!\n\r", ch);
d1647 1
a1647 1
      send_to_char("Illegal shop number.\n\r", ch);
d1698 3
@


1.47
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.46 2008/06/19 18:53:12 myc Exp jps $
d1039 1
a1039 1
  char buf[MAX_STRING_LENGTH], name[200];
d1052 2
a1053 2
  strcpy(buf, " ##  Lvl  Item                                                   Cost\n\r");
  strcat(buf, "---  ---  ------------------------------------------------  -------------\n\r");
d1067 1
a1067 1
            strcat(buf, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
d1076 1
a1076 1
      strcpy(buf, "Presently, none of those are for sale.\n\r");
d1078 1
a1078 1
      strcpy(buf, "Currently, there is nothing for sale.\n\r");
d1080 1
a1080 1
    strcat(buf, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
d1082 1
a1082 1
  page_string(ch->desc, buf);
d1602 1
a1602 1
      page_string(ch->desc, buf);
d1698 3
@


1.46
log
@Replaced the item_types array with a typedef struct array in objects.c.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.45 2008/06/07 19:06:46 myc Exp myc $
a16 2
#define __SHOP_C__

d21 2
d35 1
d1082 1
a1082 1
  page_string(ch->desc, buf, 1);
d1602 1
a1602 1
      page_string(ch->desc, buf, 1);
d1698 3
@


1.45
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.44 2008/06/05 02:07:43 myc Exp myc $
d1296 2
a1297 2
    for (index = 0, num = NOTHING; *item_types[index] != '\n'; index++)
      if (!strn_cmp(item_types[index], buf, strlen(item_types[index]))) {
d1299 1
a1299 1
        strcpy(buf, buf + strlen(item_types[index]));
d1515 1
a1515 1
    sprintf(buf1, "%s (#%d) ", item_types[SHOP_BUYTYPE(shop_nr, index)],
d1697 3
@


1.44
log
@Changed object flags to use flagvectors.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.43 2008/05/18 05:39:59 jps Exp myc $
d245 1
a245 1
      if ((GET_OBJ_VAL(item, 2) == 0) &&
d1013 2
a1014 2
  if ((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) && (GET_OBJ_VAL(obj, 1)))
    sprintf(END_OF(buf3), " of %s", drinks[GET_OBJ_VAL(obj, 2)]);
d1022 1
a1022 1
    if (GET_OBJ_VAL(obj, 2) < GET_OBJ_VAL(obj, 1))
d1697 3
@


1.43
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.42 2008/04/05 22:03:34 jps Exp jps $
d188 1
a188 1
            push(&vals, IS_SET(GET_OBJ_EXTRA(obj), 1 << index));
d233 1
a233 1
  if (IS_OBJ_STAT(item, ITEM_NOSELL))
d269 1
a269 1
  if (GET_OBJ_EXTRA(obj1) != GET_OBJ_EXTRA(obj2))
d272 3
a274 3
  for (index = 0; index < MAX_OBJ_EFFECT; index++)
    if ((obj1->effects[index].location != obj2->effects[index].location) ||
        (obj1->effects[index].modifier != obj2->effects[index].modifier))
d869 1
a869 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d974 1
a974 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d1697 3
@


1.42
log
@Ensure that players are never said to have a shop number.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.41 2008/04/04 03:43:31 jps Exp jps $
d1158 1
a1158 1
  if (!ok_shop_room(shop_nr, world[ch->in_room].number))
d1465 1
a1465 1
      sprintf(buf1, "%s (#%d)", world[temp].name, world[temp].number);
d1561 1
a1561 1
         if (ok_shop_room(shop_nr, world[ch->in_room].number))
d1633 1
a1633 1
        if (ok_shop_room(shop_nr, world[ch->in_room].number))
d1697 3
@


1.41
log
@Add give_shopkeeper_reject(), which allows shopkeepers to refuse
to be given objects that they wouldn't sell.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.40 2008/04/03 02:05:34 myc Exp jps $
d1099 2
d1697 4
@


1.40
log
@Depending on screen.h now.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.39 2008/03/28 17:54:53 myc Exp myc $
d181 12
a192 12
	end = ptr;
	while (*ptr && !isspace(*ptr) && (find_oper_num(*ptr) == NOTHING))
	  ptr++;
	strncpy(name, end, ptr - end);
	name[ptr - end] = 0;
	for (index = 0; *extra_bits[index] != '\n'; index++)
	  if (!str_cmp(name, extra_bits[index])) {
	    push(&vals, IS_SET(GET_OBJ_EXTRA(obj), 1 << index));
	    break;
	  }
	if (*extra_bits[index] == '\n')
	  push(&vals, isname(name, obj->name));
d194 12
a205 12
	if (temp != OPER_OPEN_PAREN)
	  while (top(&ops) > temp)
	    evaluate_operation(&ops, &vals);
	
	if (temp == OPER_CLOSE_PAREN) {
	  if ((temp = pop(&ops)) != OPER_OPEN_PAREN) {
	    log("Illegal parenthesis in shop keyword expression");
	    return (FALSE);
	  }
	} else
	  push(&ops, temp);
	ptr++;
d220 5
a224 1
int trade_with(struct obj_data * item, int shop_nr)
d228 1
d230 1
a230 1
    return (OBJECT_NOTOK);
d232 1
d234 1
a234 1
    return (OBJECT_NOTOK);
d236 7
d246 3
a248 3
	  ((GET_OBJ_TYPE(item) == ITEM_WAND) ||
	   (GET_OBJ_TYPE(item) == ITEM_STAFF)))
	return (OBJECT_DEAD);
d250 1
a250 1
	return (OBJECT_OK);
d252 1
a252 1
  return (OBJECT_NOTOK);
d274 1
a274 1
	(obj1->effects[index].modifier != obj2->effects[index].modifier))
d302 1
a302 1
	strcpy(arg, arg + strlen(buf) + 1);
d304 1
a304 1
	num = 1;
d332 1
a332 1
				   struct obj_data * list)
d347 4
a350 4
	if (j == number)
	  return (i);
	last_match = i;
	j++;
d357 1
a357 1
				  struct obj_data * list)
d370 3
a372 3
	if (--index == 0)
	  return (loop);
	last_obj = loop;
d546 1
a546 1
		   struct char_data * keeper, int shop_nr)
d701 1
a701 1
				 struct char_data * keeper, int shop_nr, int msg)
d726 1
a726 1
	    result);
d769 1
a769 1
			   int shop_nr)
d823 1
a823 1
	!(get_obj_in_list_num(GET_OBJ_RNUM(temp), keeper->carrying))) {
d845 1
a845 1
		   struct char_data * keeper, int shop_nr)
d856 1
a856 1
	    GET_NAME(ch));
d895 1
a895 1
		   sell_price(ch, keeper, obj, shop_nr)) && (sold < sellnum)
d912 1
a912 1
	     sell_price(ch, keeper, obj, shop_nr))
d914 1
a914 1
	      GET_NAME(ch), sold);
d920 1
a920 1
	      GET_NAME(ch), sold);
d955 1
a955 1
		    struct char_data * keeper, int shop_nr)
d1036 1
a1036 1
		   struct char_data * keeper, int shop_nr)
d1095 42
d1144 2
a1145 6
  for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
    if (SHOP_KEEPER(shop_nr) == GET_MOB_RNUM(keeper))
      break;

  if (shop_nr >= top_shop)
    return (FALSE);
d1147 1
a1147 1
  if (SHOP_FUNC(shop_nr))	/* Check secondary function */
d1153 1
a1153 1
      SHOP_SORT(shop_nr) = 0;	/* Safety in case "drop all" */
d1194 4
a1197 4
	do_action(victim, GET_NAME(ch), cmd_slap, 0);
	sprintf(buf, "%s %s", GET_NAME(ch), MSG_CANT_KILL_KEEPER);
	do_tell(victim, buf, cmd_tell, 0);
	return (FALSE);
d1210 1
a1210 1
	*val = real_object(*val);
d1212 2
a1213 2
	BUY_TYPE(list[*len]) = *val;
	BUY_WORD(list[(*len)++]) = 0;
d1215 1
a1215 1
	*val = 0;
d1261 1
a1261 1
	      int max, int type)
d1281 1
a1281 1
		   int new_format, int max)
d1296 3
a1298 3
	num = index;
	strcpy(buf, buf + strlen(item_types[index]));
	break;
d1304 1
a1304 1
	ptr++;
d1306 1
a1306 1
	ptr++;
d1331 1
a1331 1
    if (*buf == '#') {		/* New shop */
d1334 1
a1334 1
      free(buf);		/* Plug memory leak! */
d1336 1
a1336 1
	CREATE(shop_index, struct shop_data, rec_count);
d1343 2
a1344 2
	SHOP_PRODUCT(top_shop, count) = BUY_TYPE(list[count]);
	SHOP_AMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);}
d1351 3
a1353 3
	SHOP_BUYTYPE(top_shop, count) = BUY_TYPE(list[count]);
	SHOP_BUYAMOUNT(top_shop, count) = BUY_AMOUNT(list[count]);
	SHOP_BUYWORD(top_shop, count) = BUY_WORD(list[count]);
d1373 1
a1373 1
	SHOP_ROOM(top_shop, count) = BUY_TYPE(list[count]);
d1385 5
a1389 5
      if (*buf == '$')		/* EOF */
	done = TRUE;
      else if (strstr(buf, VERSION3_TAG))	/* New format marker */
	new_format = 1;
      free(buf);		/* Plug memory leak! */
d1423 3
a1425 3
	if (*buf)
	  strcat(buf, ", ");
	strcat(buf, trade_letters[index]);
d1427 1
a1427 1
	sprintf(END_OF(buf), "%c", *trade_letters[index]);
d1455 1
a1455 1
	  shop_nr + 1);
d1478 2
a1479 2
	    GET_NAME(&mob_proto[SHOP_KEEPER(shop_nr)]),
	    mob_index[SHOP_KEEPER(shop_nr)].virtual, YESNO(SHOP_FUNC(shop_nr)));
d1483 1
a1483 1
	      GET_GOLD(k), SHOP_BANK(shop_nr), GET_GOLD(k) + SHOP_BANK(shop_nr));
d1499 1
a1499 1
	    obj_index[SHOP_PRODUCT(shop_nr, index)].virtual);
d1514 1
a1514 1
	    SHOP_BUYTYPE(shop_nr, index));
d1529 2
a1530 2
	  SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr), SHOP_OPEN1(shop_nr),
	  SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\n\r");
d1631 2
a1632 2
	if (ok_shop_room(shop_nr, world[ch->in_room].number))
	  break;
d1635 2
a1636 2
	send_to_char("This isn't a shop!\n\r", ch);
	return;
d1695 3
@


1.39
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.38 2008/03/26 23:32:09 jps Exp myc $
d34 1
d1644 4
@


1.38
log
@Prevent buying things when in a fluid state.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.37 2008/02/16 20:31:32 myc Exp jps $
d258 3
a260 3
  for (index = 0; index < MAX_OBJ_AFFECT; index++)
    if ((obj1->affected[index].location != obj2->affected[index].location) ||
	(obj1->affected[index].modifier != obj2->affected[index].modifier))
d1262 1
a1262 1
      BUY_WORD(list[len - 1]) = str_dup(ptr);
d1643 3
@


1.37
log
@Adding function to free shops at program termination.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.36 2008/02/15 03:29:29 jps Exp myc $
d33 1
d554 1
a554 1
      sprintf(buf, "%s What do you want to buy??", GET_NAME(ch));
d563 5
d1643 3
@


1.36
log
@Was going to fix something, and tidied up some code, but it
seemed to have been fixed already and I didn't actually
change anything.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.35 2008/02/09 04:27:47 myc Exp jps $
d1593 42
d1637 5
@


1.35
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.34 2008/01/29 21:02:31 myc Exp myc $
d50 1
a50 1
  
d57 1
a57 1
  
d67 1
a67 1
  
d83 1
a83 1
  
d92 1
a92 1
  }  
d139 1
a139 1
  
d152 1
a152 1
  
d165 1
a165 1
  
d168 1
a168 1
  
d171 1
a171 1
  
d221 1
a221 1
  
d224 1
a224 1
  
d227 1
a227 1
  
d236 1
a236 1
    }  
d244 1
a244 1
  
d247 1
a247 1
  
d250 1
a250 1
  
d253 1
a253 1
  
d256 1
a256 1
  
d261 1
a261 1
  
d269 1
a269 1
  
d271 1
a271 1
    return (FALSE);    
d309 1
a309 1
  
d323 1
a323 1
  
d328 1
a328 1
  
d346 1
a346 1
  
d351 1
a351 1
  
d364 1
a364 1
				  struct char_data * keeper, int shop_nr, int msg)
d366 20
a385 10
  char buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj;
  
  one_argument(arg, name);
  do {
    if (is_number(name))
      {
	strcpy(buf, name);
	strcpy(name, "#\0");
	strcat(name, buf);
d387 3
a389 8
    if (*name == '#')
      obj = get_hash_obj_vis(ch, name, keeper->carrying);
    else
      obj = get_slide_obj_vis(ch, name, keeper->carrying);
    if (!obj) {
      if (msg) {
	sprintf(buf, shop_index[shop_nr].no_such_item1, GET_NAME(ch));
	do_tell(keeper, buf, cmd_tell, 0);
d391 2
a392 8
      return (0);
    }
    if (GET_OBJ_COST(obj) <= 0) {
      extract_obj(obj);
      obj = 0;
    }
  } while (!obj);
  return (obj);
d531 1
a531 1
		  struct char_data * keeper, int shop_nr)
d533 27
a559 35
  char tempstr[200], buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *last_obj = NULL;
  int copperamt = 0, buynum, bought = 0;
  bool amount = 0;int counter;
  if (!(is_ok(keeper, ch, shop_nr)))
    {
      return; /* return if not a keeper */
    }
  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);
  
  
  if ((buynum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try selling me something.",
	    GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!*arg) {
    sprintf(buf, "%s What do you want to buy??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  
  if (!(obj = get_purchase_obj(ch, arg, keeper, shop_nr, TRUE)))
    return;
  
  
  if ((buy_price(ch, keeper, obj, shop_nr) > GET_CASH(ch)) && !IS_GOD(ch)) {
    sprintf(buf, shop_index[shop_nr].missing_cash2, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    
    switch (SHOP_BROKE_TEMPER(shop_nr)) {
    case 0:
      do_action(keeper, GET_NAME(ch), cmd_snicker, 0);
d561 22
a582 2
    case 1:
      do_echo(keeper, "smokes on his joint.", cmd_emote, SCMD_EMOTE);
d584 6
a589 1
    default:
d591 39
a629 37
    }
  }
  if ((IS_CARRYING_N(ch) + 1 > CAN_CARRY_N(ch))) {
    sprintf(buf, "%s: You can't carry any more items.\n\r",
	    fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  if (!ADDED_WEIGHT_OK(ch, obj)) {
    sprintf(buf, "%s: You can't carry that much weight.\n\r",
	    fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  while ((obj) && ((GET_CASH(ch) >= buy_price(ch, keeper, obj, shop_nr)) || IS_GOD(ch))
	 && (IS_CARRYING_N(ch) < CAN_CARRY_N(ch)) && (bought < buynum)
    && ADDED_WEIGHT_OK(ch, obj)) {
    bought++;
    /* Test if producing shop ! */
    if (shop_producing(obj, shop_nr))
      
      {
	for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
	  if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
	    {
	      amount = SHOP_AMOUNT(shop_nr, counter);
	    }	
	
	if (!(amount))
	  obj = read_object(GET_OBJ_RNUM(obj), REAL);
	else
	  {obj_from_char(obj);
	  SHOP_SORT(shop_nr)--;
	  }
      }else {
	obj_from_char(obj);
	SHOP_SORT(shop_nr)--;
a630 30
    obj_to_char(obj, ch);
    
    copperamt += buy_price(ch, keeper, obj, shop_nr);
    if (!IS_GOD(ch))
    {
      apply_cost(buy_price(ch, keeper, obj, shop_nr), ch);
    }
    last_obj = obj;
    one_argument(arg, name);
    obj = get_purchase_obj(ch, name, keeper, shop_nr, FALSE);
    if (!same_obj(obj, last_obj))
      break;
  }
  
  if (bought < buynum) {
    if (!obj || !same_obj(last_obj, obj))
      sprintf(buf, "%s I only have %d to sell you.", GET_NAME(ch), bought);
    else if (GET_GOLD(ch) < buy_price(ch, keeper, obj, shop_nr))
      sprintf(buf, "%s You can only afford %d.", GET_NAME(ch), bought);
    else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      sprintf(buf, "%s You can only hold %d.", GET_NAME(ch), bought);
    else if (!ADDED_WEIGHT_OK(ch, obj))
      sprintf(buf, "%s You can only carry %d.", GET_NAME(ch), bought);
    else
      sprintf(buf, "%s Something screwy only gave you %d.", GET_NAME(ch),
	      bought);
    do_tell(keeper, buf, cmd_tell, 0);
  }
  if (!IS_GOD(ch))
    apply_getcash(keeper, copperamt);
d632 45
a676 19
  sprintf(tempstr, times_message(ch->carrying, 0, bought));
  sprintf(buf, "$n buys %s.", tempstr);
  act(buf, FALSE, ch, obj, 0, TO_ROOM);
  
  sprintf(buf, shop_index[shop_nr].message_buy, GET_NAME(ch), 0);
  do_tell(keeper, buf, cmd_tell, 0);
  sprintf(buf, "You now have %s.\n\r", tempstr);
  send_to_char(buf, ch);
  
  if (SHOP_USES_BANK(shop_nr))
    if (GET_CASH(keeper) > MAX_OUTSIDE_BANK) {
      SHOP_BANK(shop_nr) += (GET_CASH(keeper) - MAX_OUTSIDE_BANK);
      GET_PLAT(keeper) = 0;
      GET_GOLD(keeper) = 0;
      GET_SILVER(keeper) = 0;
      GET_COPPER(keeper) = 0;
      GET_COPPER(keeper) = MAX_OUTSIDE_BANK;
      adjust_cash(keeper);
    }
d686 1
a686 1
  
d696 1
a696 1
  
d724 1
a724 1
int sell_price(struct char_data * ch, struct char_data * keeper, 
d761 1
a761 1
  
d764 1
a764 1
  
d791 1
a791 1
  
d798 1
a798 1
  
d830 1
a830 1
  
d833 1
a833 1
  
d848 1
a848 1
  
d853 1
a853 1
  } 
d860 1
a860 1
  }  
d879 1
a879 1
    
d882 1
a882 1
    
d887 1
a887 1
  
d901 1
a901 1
    
d925 1
a925 1
  
d944 1
a944 1
  
d965 1
a965 1
  }  
d977 1
a977 1
  
d988 1
a988 1
  
d990 1
a990 1
  
d997 1
a997 1
    
d1000 1
a1000 1
  
d1021 1
a1021 1
  
d1025 1
a1025 1
  
d1028 1
a1028 1
  
d1032 1
a1032 1
  strcat(buf, "---  ---  ------------------------------------------------  -------------\n\r"); 
d1060 1
a1060 1
  
d1068 1
a1068 1
  
d1081 1
a1081 1
  
d1085 1
a1085 1
  
d1088 1
a1088 1
  
d1092 1
a1092 1
  
d1100 1
a1100 1
  
d1103 1
a1103 1
  
d1110 1
a1110 1
  
d1132 1
a1132 1
  
d1227 1
a1227 1
  
d1268 1
a1268 1
  
d1270 1
a1270 1
  
d1279 1
a1279 1
      
d1289 1
a1289 1
      
d1297 1
a1297 1
      
d1311 1
a1311 1
      
d1321 1
a1321 1
      
d1340 1
a1340 1
  
d1360 1
a1360 1
  
d1372 1
a1372 1
  
d1395 1
a1395 1
  
d1399 1
a1399 1
  
d1416 1
a1416 1
  
d1430 1
a1430 1
  
d1434 1
a1434 1
  
d1450 1
a1450 1
  
d1469 1
a1469 1
  
d1473 1
a1473 1
  
d1475 1
a1475 1
  
d1549 1
a1549 1
  
d1575 1
a1575 1
      
d1584 1
a1584 1
    
d1595 3
d1711 1
a1711 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.34
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.33 2008/01/27 12:12:55 jps Exp myc $
d32 1
d1581 4
@


1.33
log
@Changed IS_THIEF macro to IS_ROGUE.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.32 2008/01/27 01:42:03 jps Exp jps $
d31 1
a31 11

/* External variables */
extern struct str_app_type str_app[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct char_data *mob_proto;
extern struct obj_data *obj_proto;
extern struct room_data *world;
extern struct time_info_data time_info;
extern char *item_types[];
extern char *extra_bits[];
a37 1
char *fname(char *namelist);
a971 1
  extern char *drinks[];
d1580 3
@


1.32
log
@Fix grammar when informing player of cursed objects.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.31 2008/01/23 02:33:26 jps Exp jps $
d80 1
a80 1
      (IS_THIEF(ch) && NOTRADE_THIEF(shop_nr)) ||
d1592 3
@


1.31
log
@Make shopping bills come out of lower-denomination coins first.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.30 2008/01/09 02:30:14 jps Exp jps $
d846 1
a846 1
    sprintf(buf, "You can't sell $p, it's CURSED!");
d1592 3
@


1.30
log
@Use macro to get mob real number.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.29 2008/01/02 07:11:21 jps Exp jps $
a483 1
  int needP, needG, needS, needC;
a484 2
  int tempP, tempG, tempS, tempC;
  int copper;
d486 4
a489 4
  if (cost <= 0)
    return;

  if (cost > GET_CASH(ch))
d491 1
a491 6

  /* Find out how much we need */
  needP = ((int)(cost)/1000);
  needG = ((int)((int)(cost/100)-(needP*10)));
  needS = ((int)((((int)(cost/10))-(needP*100))-(needG*10)));
  needC = ((int)((((cost)-(needP*1000))-(needG*100))-(needS*10)));
d499 4
d504 4
a507 12
  while (haveP > 0 && needP > 0)
  {
    haveP--;
    needP--;
  }
  while (haveG > 0 && needG > 0)
  {
    haveG--;
    needG--;
  }
  while (haveS > 0 && needS > 0)
  {
d509 1
a509 6
    needS--;
  }
  while (haveC > 0 && needC > 0)
  {
    haveC--;
    needC--;
d512 3
a514 35
  /* Convert what we still need */
  copper = 0;

  /* Start with Plat */
  while (needP > 0)
  {
    if (needP > 0 && haveG > 0 && copper < 1000)
    {
      while (haveG > 0 && copper < 1000)
      {
        copper += 100;
        haveG--;
      }
    }
    if (needP > 0 && haveS > 0 && copper < 1000)
    {
      while (haveS > 0 && copper < 1000)
      {
        copper += 10;
        haveS--;
      }
    }
    if (needP > 0 && haveC > 0 && copper < 1000)
    {
      while (haveC > 0 && copper < 1000)
      {
        copper += 1;
        haveC--;
      }
    }
    if (copper >= 1000)
    {
      copper -= 1000;
      needP--;
    }
d517 3
a519 32
  /* Do gold */
  while (needG > 0)
  {
    if (needG > 0 && haveS > 0 && copper < 100)
    {
      while (haveS > 0 && copper < 100)
      {
        copper += 10;
        haveS--;
      }
    }
    if (needG > 0 && haveC > 0 && copper < 100)
    {
      while (haveC > 0 && copper < 100)
      {
        copper += 1;
        haveC--;
      }
    }
    if (needG > 0 && haveP > 0 && copper < 100)
    {
      while (haveP > 0 && copper < 100)
      {
        copper += 1000;
        haveP--;
      }
    }
    if (copper >= 100)
    {
      copper -= 100;
      needG--;
    }
d522 9
a530 32
  /* Do silver */
  while (needS > 0)
  {
    if (needS > 0 && haveC > 0 && copper < 10)
    {
      while (haveC > 0 && copper < 10)
      {
        copper += 1;
        haveC--;
      }
    }
    if (needS > 0 && haveG > 0 && copper < 10)
    {
      while (haveG > 0 && copper < 10)
      {
        copper += 100;
        haveG--;
      }
    }
    if (needS > 0 && haveP > 0 && copper < 10)
    {
      while (haveP > 0 && copper < 10)
      {
        copper += 1000;
        haveP--;
      }
    }
    if (copper >= 10)
    {
      copper -= 10;
      needS--;
    }
a532 44
  /* Do copper */
  while (needC > 0)
  {
    if (needC > 0 && haveS > 0 && copper < 1)
    {
      while (haveS > 0 && copper < 1)
      {
        copper += 10;
        haveS--;
      }
    }
    if (needC > 0 && haveG > 0 && copper < 1)
    {
      while (haveG > 0 && copper < 1)
      {
        copper += 100;
        haveG--;
      }
    }
    if (needC > 0 && haveP > 0 && copper < 1)
    {
      while (haveP > 0 && copper < 1)
      {
        copper += 1000;
        haveP--;
      }
    }
    if (copper >= 1)
    {
      copper -= 1;
      needC--;
    }
  }

  /* Redistribute the left over copper */
  tempP = ((int)(copper)/1000);
  tempG = ((int)((int)(copper/100)-(tempP*10)));
  tempS = ((int)((((int)(copper/10))-(tempP*100))-(tempG*10)));
  tempC = ((int)((((copper)-(tempP*1000))-(tempG*100))-(tempS*10)));
  haveP += tempP;
  haveG += tempG;
  haveS += tempS;
  haveC += tempC;

d1592 3
@


1.29
log
@Using class.h.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.28 2007/09/20 09:34:34 jps Exp jps $
d1225 1
a1225 1
    if (SHOP_KEEPER(shop_nr) == keeper->nr)
d1737 3
@


1.28
log
@Improve feedback when selling things.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.27 2007/09/12 19:23:04 myc Exp jps $
d30 1
d1737 3
@


1.27
log
@Shop keepers give correct response when 'buy' is typed without arguments.
Shop keepers won't throw up on you anymore.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.26 2007/09/03 23:59:43 jps Exp myc $
a1050 2
  sprintf(buf, "The shopkeeper now has %s.\n\r", tempstr);
  send_to_char(buf, ch);
d1055 9
a1063 4
  if (temp == 0 && temp2 == 0 && temp3 == 0 && temp4 == 0)
    sprintf(buf, "You walk away empty handed.\r\nYou feel guilty for pawning worthless garbage on a shopkeeper.");
  else
    sprintf(buf, "You receive &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c coins from the transaction.\r\n", temp, temp2, temp3, temp4);
d1736 4
@


1.26
log
@Added macro ADDED_WEIGHT_OK for testing whether a char can have an
object added to its inventory.  Avoids an integer overflow problem
that could occur if an object's weight was near maxint.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.25 2007/08/24 22:59:55 jps Exp jps $
d53 1
a53 1
int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;
d706 1
a706 1
  if (!(*arg) && (!buynum)) {
d722 1
a722 1
      do_action(keeper, GET_NAME(ch), cmd_puke, 0);
d1483 1
a1483 1
  cmd_puke = find_command("puke");
d1733 5
@


1.25
log
@Correctly state that none are for sale when "list <name>" doesn't
match any of the items for sale.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.24 2007/08/24 22:49:05 jps Exp jps $
d737 1
a737 1
  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
d745 1
a745 1
	 && (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) <= CAN_CARRY_W(ch))) {
d788 1
a788 1
    else if (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) > CAN_CARRY_W(ch))
d1733 4
@


1.24
log
@Added function vnum_shop() for use with the "snum" command.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.23 2007/08/24 22:10:58 jps Exp jps $
d1174 16
a1189 14
      if (CAN_SEE_OBJ(ch, obj) && (obj->obj_flags.cost > 0)) {
         if (!last_obj) {
           last_obj = obj;
	   cnt = 1;
	 } else if (same_obj(last_obj, obj))
	    cnt++;
	 else {
	   index++;
	   if (!(*name) || isname(name, last_obj->name))
	     strcat(buf, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
	   cnt = 1;
	   last_obj = obj;
	 }
	}
d1733 3
@


1.23
log
@Add commands "slist" and "sstat".
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.22 2007/05/24 03:35:11 jps Exp jps $
d1682 14
d1731 3
@


1.22
log
@Display an item's full name when selling, rather than just whatever
the seller typed.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.21 2006/11/08 07:21:31 jps Exp jps $
a1512 25
void list_all_shops(struct char_data * ch)
{
  int shop_nr;
  
  strcpy(buf, "\n\r");
  for (shop_nr = 0; shop_nr < top_shop; shop_nr++) {
    if (!(shop_nr % 19)) {
      strcat(buf, " ##   Virtual   Where    Keeper    Buy   Sell   Customers\n\r");
      strcat(buf, "---------------------------------------------------------\n\r");
    }
    sprintf(buf2, "%3d   %6d   %6d    ", shop_nr + 1, SHOP_NUM(shop_nr),
	    SHOP_ROOM(shop_nr, 0));
    if (SHOP_KEEPER(shop_nr) < 0)
      strcpy(buf1, "<NONE>");
    else
      sprintf(buf1, "%6d", mob_index[SHOP_KEEPER(shop_nr)].virtual);
    sprintf(END_OF(buf2), "%s   %3.2f   %3.2f    ", buf1,
	    SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr));
    strcat(buf2, customer_string(shop_nr, FALSE));
    sprintf(END_OF(buf), "%s\n\r", buf2);
  }
  
  page_string(ch->desc, buf, 1);
}

d1617 65
d1685 8
a1692 5
  int shop_nr;
  
  if (!*arg)
    list_all_shops(ch);
  else {
d1717 4
@


1.21
log
@Minimum sell price for any item is now 1 copper.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.20 2006/07/20 07:43:07 cjd Exp jps $
d304 18
a321 18
char *times_message(struct obj_data * obj, char *name, int num)
{
  static char buf[256];
  char *ptr;
  
  if (obj)
    strcpy(buf, obj->short_description);
  else {
    if ((ptr = strchr(name, '.')) == NULL)
      ptr = name;
    else
      ptr++;
    sprintf(buf, "%s %s", AN(ptr), ptr);
  }
  
  if (num > 1)
    sprintf(END_OF(buf), " (x %d)", num);
  return (buf);
d797 1
a797 1
  
d967 1
a967 1
  char tempstr[200], buf[MAX_STRING_LENGTH], name[200];
d1008 6
d1045 1
a1045 1
  strcpy(tempstr, times_message(0, name, sold));
d1047 2
a1048 2
  act(buf, FALSE, ch, obj, 0, TO_ROOM);
  
d1674 3
@


1.20
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.19 2002/09/13 02:32:10 jjl Exp $
d448 2
d1668 3
@


1.19
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: shop.c,v 1.18 2001/05/03 03:20:05 dce Exp $
d988 1
a988 1
    sprintf(buf, "You can sell $p, it's CURSED!");
d1075 1
a1075 1
    sprintf(buf, "%s What do you want me to valuate??", GET_NAME(ch));
d1666 3
@


1.18
log
@Shopkeepers will no longer buy cursed items.
@
text
@d1 3
a3 1
// $Id: shop.c,v 1.17 2001/03/24 19:26:06 dce Exp $
d1664 76
a1739 71
// $Log: shop.c,v $
// Revision 1.17  2001/03/24 19:26:06  dce
// Object level shows up in the list command at shops.
//
// Revision 1.16  2001/03/14 02:33:55  dce
// Shopkeepers will only buy 25 of the same object.
//
// Revision 1.15  2001/03/13 01:57:29  dce
// Shopkeepers no longer say, 'I have ...'
//
// Revision 1.14  2001/02/18 20:34:05  dce
// Invis gods can now do a list.
// Also removed a bogus message.
//
// Revision 1.13  2001/02/08 01:31:05  dce
// Striped the color from short item descriptions in the list
// command. It was causing mis-aligned columns.
//
// Revision 1.12  2001/01/23 00:15:57  dce
// Lengthed the display for list so that items align more correctly.
// Changed the value from 40 to 47. You oculd maybe do 50, but it's
// pushing the width of normal people's screens.
//
// Revision 1.11  2001/01/22 04:14:13  dce
// Added a charisma check and an items count check to shopkeepers
// Shopkeers will now adjust the price based on these factors.
//
// Revision 1.10  2001/01/16 03:13:27  dce
// Fixed some typos
//
// Revision 1.9  2001/01/16 03:10:47  dce
// Added message for 0 value items.
//
// Revision 1.8  2001/01/12 02:35:04  dce
// Completely re-did the existing shop code and the way it handled
// money. Previously it used just GET_GOLD and didn't take into
// account silver, platinum or copper.
//
// Revision 1.7  2000/11/24 21:30:22  rsd
// Altered comment header and added back rlog messages from
// prior to the addition of the $log$ string.
//
// Revision 1.6  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.5  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most significant
// changes were moving all the BREATH's to within normal spell range, and
// fixing the way socials were allocated.  Too many small fixes to list them
// all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.4  1999/08/28 00:31:16  mtp
// typo in apply_getcash fixed now sell should work
//
// Revision 1.3  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.2  1999/02/02 02:18:34  mud
// indented file
// dos2unix
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.17
log
@Object level shows up in the list command at shops.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.16 2001/03/14 02:33:55 dce Exp $
d985 6
d1081 6
d1663 3
@


1.16
log
@Shopkeepers will only buy 25 of the same object.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.15 2001/03/13 01:57:29 dce Exp $
a1102 1
  int counter, amount = -1;
d1105 1
a1105 16
  if (shop_producing(obj, shop_nr))
    {
      for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
	if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
	  {
	    amount = SHOP_AMOUNT(shop_nr, counter);
	  }
      if (amount)
	strcpy(buf2, "I have Specialy got ");
      else
	strcpy(buf2, "I have ");
    }else
      sprintf(buf2, "I have ");
  sprintf(buf, "%2d) ", index);
/* Old code removed -- 3/12/01 Zantir */
/*  sprintf(buf, "%2d) %s", index, buf2); */
d1111 1
a1111 3
  if (shop_producing(obj, shop_nr))
    sprintf(END_OF(buf3), "       ");
  else
d1125 1
a1125 1
  sprintf(buf2, "%-47s &0&b&6%2d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", strip_ansi(buf3), temp, temp2, temp3, temp4);
a1136 1
  int i;
d1146 4
a1149 6
  sprintf(buf1, "&0&8%s tells you. 'I have the following items for sale.'&0\r\n", GET_NAME(keeper)); 
  strcpy(buf, buf1);
  i = 0;
  for (obj = keeper->carrying; obj; obj = obj->next_content)/*go through all the objects*/
    i++;
  strcat(buf, "&\r\n");
d1151 6
a1156 9
    for (obj = keeper->carrying; obj; obj = obj->next_content)/*go through all the objects*/
      if (CAN_SEE_OBJ(ch, obj) && (obj->obj_flags.cost > 0))  /*only ones that cost*/
	{
	  if (!last_obj) 
	    {
	      last_obj = obj;
	      cnt = 1;
	    } 
	  else if (same_obj(last_obj, obj))
d1158 7
a1164 8
	  else 
	    {
	      index++;
	      if (!(*name) || isname(name, last_obj->name))
		strcat(buf, list_object(keeper, last_obj, ch, cnt, index, shop_nr));
	      cnt = 1;
	      last_obj = obj;
	    }
d1651 3
@


1.15
log
@Shopkeepers no longer say, 'I have ...'
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.14 2001/02/18 20:34:05 dce Exp $
d965 1
a965 1
  int sellnum, sold = 0, goldamt = 0, temp, temp2, temp3, temp4;
d985 7
d997 1
d999 2
a1000 1
		   sell_price(ch, keeper, obj, shop_nr)) && (sold < sellnum)) {
d1002 1
d1019 3
d1062 1
d1074 8
a1081 1
  
d1676 3
@


1.14
log
@Invis gods can now do a list.
Also removed a bogus message.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.13 2001/02/08 01:31:05 dce Exp $
d1098 3
a1100 1
  sprintf(buf, "%2d) %s", index, buf2);
d1655 4
@


1.13
log
@Striped the color from short item descriptions in the list
command. It was causing mis-aligned columns.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.12 2001/01/23 00:15:57 dce Exp $
a689 1
      send_to_char("I don't see a Shop Keeper Around!!", ch);	
d1134 3
a1136 2
  if (!(is_ok(keeper, ch, shop_nr)))
    return;
d1653 4
@


1.12
log
@Lengthed the display for list so that items align more correctly.
Changed the value from 40 to 47. You oculd maybe do 50, but it's
pushing the width of normal people's screens.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.11 2001/01/22 04:14:13 dce Exp $
d1121 1
a1121 1
  sprintf(buf2, "%-47s &0&b&6%2d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", buf3, temp, temp2, temp3, temp4);
d1653 5
@


1.11
log
@Added a charisma check and an items count check to shopkeepers
Shopkeers will now adjust the price based on these factors.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.10 2001/01/16 03:13:27 dce Exp $
d1121 1
a1121 1
  sprintf(buf2, "%-40s &0&b&6%2d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", buf3, temp, temp2, temp3, temp4);
d1653 4
@


1.10
log
@Fixed some typos
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.9 2001/01/16 03:10:47 dce Exp $
d19 1
a28 1

d403 25
d429 1
a429 1
int buy_price(struct obj_data * obj, int shop_nr)
d431 16
a446 1
  return ((int) (GET_OBJ_COST(obj) * SHOP_BUYPROFIT(shop_nr)));
d713 1
a713 1
  if ((buy_price(obj, shop_nr) > GET_CASH(ch)) && !IS_GOD(ch)) {
d740 1
a740 1
  while ((obj) && ((GET_CASH(ch) >= buy_price(obj, shop_nr)) || IS_GOD(ch))
d766 1
a766 1
    copperamt += buy_price(obj, shop_nr);
d769 1
a769 1
      apply_cost(buy_price(obj, shop_nr), ch);
d781 1
a781 1
    else if (GET_GOLD(ch) < buy_price(obj, shop_nr))
d853 6
d860 3
a862 1
int sell_price(struct char_data * ch, struct obj_data * obj, int shop_nr)
d864 18
a881 1
  return ((int) (GET_OBJ_COST(obj) * SHOP_SELLPROFIT(shop_nr)));
d986 1
a986 1
  if (GET_CASH(keeper) + SHOP_BANK(shop_nr) < sell_price(ch, obj, shop_nr)) {
d992 1
a992 1
		   sell_price(ch, obj, shop_nr)) && (sold < sellnum)) {
d995 2
a996 2
    goldamt += sell_price(ch, obj, shop_nr);
    apply_removecash(keeper, sell_price(ch, obj, shop_nr));
d1007 1
a1007 1
	     sell_price(ch, obj, shop_nr))
d1062 1
a1062 1
  bp = ((int)(sell_price(ch, obj, shop_nr)));
d1077 2
a1078 1
char *list_object(struct obj_data * obj, int cnt, int index, int shop_nr)
d1116 1
a1116 1
  bp = ((int)(buy_price(obj, shop_nr)));
d1163 1
a1163 1
		strcat(buf, list_object(last_obj, cnt, index, shop_nr));
d1175 1
a1175 1
    strcat(buf, list_object(last_obj, cnt, index, shop_nr));
d1653 3
@


1.9
log
@Added message for 0 value items.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.8 2001/01/12 02:35:04 dce Exp $
d965 1
a965 1
    sprintf(buf, "You walk away empty handed.\r\nYou feel guilty for pawning worhtless garbage on a shopkeeper.");
d1587 3
@


1.8
log
@Completely re-did the existing shop code and the way it handled
money. Previously it used just GET_GOLD and didn't take into
account silver, platinum or copper.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.7 2000/11/24 21:30:22 rsd Exp $
d964 4
a967 1
  sprintf(buf, "You receive &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c coins from the transaction.\r\n", temp, temp2, temp3, temp4);
d1002 4
a1005 1
  sprintf(buf, "%s I'll give you %dp, %dg, %ds, %dc for that!", GET_NAME(ch), temp, temp2, temp3, temp4);
d1587 5
@


1.7
log
@Altered comment header and added back rlog messages from
prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: shop.c,v 1.6 1999/09/05 07:00:39 jimmy Exp $
d409 1
a409 1
long coin_count(struct char_data * ch)
d411 9
a419 4
  long amount;
  /*All done in copper*/
  amount = (long)(1000*GET_PLAT(ch) + 200*GET_GOLD(ch) + 20*GET_SILVER(ch) + GET_COPPER(ch));
  return amount;
d421 2
a422 1
bool convert_next_coin(struct char_data * ch)
d424 67
a490 4
  
  if (GET_COPPER(ch) > 0)
    return TRUE;
  else if (GET_SILVER(ch) > 0)
d492 5
a496 2
      GET_SILVER(ch)--;
      GET_COPPER(ch) = GET_COPPER(ch) + 20;
d498 1
a498 1
  else if (GET_GOLD(ch) > 0)
d500 5
a504 2
      GET_GOLD(ch)--;
      GET_SILVER(ch) = GET_SILVER(ch) + 10;
d506 1
a506 1
  else if (GET_PLAT(ch) > 0)
d508 5
a512 2
      GET_PLAT(ch)--;
      GET_GOLD(ch) = GET_GOLD(ch) + 5;
d514 1
a514 1
  else
d516 2
a517 2
      mudlog("Error in convert_next_coin, shop.c (PROKY)", CMP, LVL_GOD, FALSE);
      return FALSE;
d519 1
a519 2
  return TRUE;
}
d521 33
d555 33
d589 28
a616 7
void apply_cost(int cost, struct char_data * ch)
{
  
  if (cost <=0)
    return;
  
  do
d618 21
a638 10
      while (GET_COPPER(ch) > 0)
	{
	  GET_COPPER(ch)--;
	  cost--;
	  if (cost <= 0)
	    return;
	}
      
    } while (convert_next_coin(ch));
  
d651 1
a651 1
      return;/*return if not a keeper*/
d673 1
a673 1
  if (((long)buy_price(obj, shop_nr) > coin_count(ch)) && !IS_GOD(ch)) {
d700 1
a700 1
  while ((obj) && ((coin_count(ch) >= buy_price(obj, shop_nr)) || IS_GOD(ch))
d728 3
a730 3
      {
	apply_cost(buy_price(obj, shop_nr), ch);
      }
d753 1
a753 1
    GET_GOLD(keeper) += copperamt;
d765 8
a772 3
    if (GET_GOLD(keeper) > MAX_OUTSIDE_BANK) {
      SHOP_BANK(shop_nr) += (GET_GOLD(keeper) - MAX_OUTSIDE_BANK);
      GET_GOLD(keeper) = MAX_OUTSIDE_BANK;
d883 1
a883 1
void apply_getcash(struct char_data * ch, int cash)
d885 9
a893 9
  int temp, temp2, temp3, temp4 = 0;
  temp = ((int)(cash)/1000);
  temp2 = ((int)((int)(cash/200)-(temp*5)));
  temp3 = ((int)((((int)(cash/20))-(temp*50))-temp2*10));
  temp4 = ((int)((((cash)-(temp*1000))-(temp2*200))-(temp3*20)));
  GET_PLAT(ch) += temp;
  GET_GOLD(ch) += temp2;
  GET_SILVER(ch) += temp3;
  GET_COPPER(ch) =+ temp4;
d901 1
a901 1
  int sellnum, sold = 0, goldamt = 0;
d921 1
a921 1
  if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) < sell_price(ch, obj, shop_nr)) {
d926 1
a926 1
  while ((obj) && (GET_GOLD(keeper) + SHOP_BANK(shop_nr) >=
d931 1
a931 1
    GET_GOLD(keeper) -= sell_price(ch, obj, shop_nr);
d941 1
a941 1
    else if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) <
d960 6
d967 2
a968 2
  if (GET_GOLD(keeper) < MIN_OUTSIDE_BANK) {
    goldamt = MIN(MAX_OUTSIDE_BANK - GET_GOLD(keeper), SHOP_BANK(shop_nr));
d970 1
a970 1
    GET_GOLD(keeper) += goldamt;
d981 1
a981 1
  int temp, temp2, temp3, temp4 = 0;
a992 5
  temp = ((int)(buy_price(obj, shop_nr))/1000);
  temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
  temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
  temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
  sprintf(buf, "I'll give you &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c &0&7&bfor that!&0", temp, temp2, temp3, temp4);
d994 6
a999 2
  /*sprintf(buf, "%s I'll give you %d gold coins for that!", GET_NAME(ch),
   */
d1012 1
a1012 1
  int temp, temp2, temp3, temp4;
d1024 1
a1024 1
	strcpy(buf2, "I have a few ");
d1026 2
a1027 2
      sprintf(buf2, "I have %d ", cnt);
  sprintf(buf, "%2d)%s", index, buf2);
d1033 5
a1037 1
  
d1044 7
a1050 6
  temp = ((int)(buy_price(obj, shop_nr))/1000);
  temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
  temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
  temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
  sprintf(buf2, "%-40s &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r", buf3, temp, temp2, temp3, temp4);
  strcat(buf, CAP(buf2));
d1581 4
@


1.6
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d3 1
a3 1
 *   File: shop.c                                        Part of CircleMUD *
d5 1
d9 3
a11 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
a14 3
/***
 * The entire shop rewrite for Circle 3.0 was done by Jeff Fink.  Thanks Jeff!
 ***/
d1390 30
a1419 2

// $Log$
@


1.5
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d1 1
d1391 1
@


1.4
log
@typo in apply_getcash fixed now sell should work
@
text
@d712 1
a712 1
  GET_COPPER(ch) += temp4;
d1030 8
d1039 1
a1039 1
void read_line(FILE * shop_f, char *string, void *data)
d1041 1
a1041 1
  if (!get_line(shop_f, buf) || !sscanf(buf, string, data)) {
d1046 2
a1047 1
void read_double_line(FILE * shop_f, char *string, void *data, void *data2)
d1049 1
a1049 1
  if (!get_line(shop_f, buf) || !sscanf(buf, string, data, data2)) {
d1063 1
a1063 1
      read_double_line(shop_f, "%d %d", &temp, &amount);
d1068 1
a1068 1
      read_line(shop_f, "%d", &temp);
d1140 2
a1141 2
      read_line(shop_f, "%f", &SHOP_BUYPROFIT(top_shop));
      read_line(shop_f, "%f", &SHOP_SELLPROFIT(top_shop));
d1158 3
a1160 3
      read_line(shop_f, "%d", &SHOP_BROKE_TEMPER(top_shop));
      read_line(shop_f, "%d", &SHOP_BITVECTOR(top_shop));
      read_line(shop_f, "%d", &SHOP_KEEPER(top_shop));
d1163 1
a1163 1
      read_line(shop_f, "%d", &SHOP_TRADE_WITH(top_shop));
d1170 4
a1173 4
      read_line(shop_f, "%d", &SHOP_OPEN1(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE1(top_shop));
      read_line(shop_f, "%d", &SHOP_OPEN2(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE2(top_shop));
@


1.3
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d712 1
a712 1
  GET_COPPER(ch) =+ temp4;
@


1.2
log
@indented file
dos2unix
@
text
@d93 1
a93 1
  else if (SHOP_CLOSE1(shop_nr) < time_info.hours)
d98 1
a98 1
  
d235 1
a235 1
    if (SHOP_BUYTYPE(shop_nr, counter) == GET_OBJ_TYPE(item))
d242 1
a242 1
  
d1002 1
a1002 1
  if (*val >= 0)
d1014 1
@


1.1
log
@Initial revision
@
text
@d1 9
a9 9
/* ************************************************************************
*   File: shop.c                                        Part of CircleMUD *
*  Usage: shopkeepers: loading config files, spec procs.                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d56 1
a56 1

d63 1
a63 1

d73 1
a73 1

d89 1
a89 1

d98 1
a98 1

d145 1
a145 1

d158 1
a158 1

d171 1
a171 1

d174 1
a174 1

d176 2
a177 2
	return TRUE;

d201 1
a201 1

d227 1
a227 1

d230 1
a230 1

d233 1
a233 1

d242 1
a242 1

d250 1
a250 1

d253 1
a253 1

d256 1
a256 1

d259 1
a259 1

d262 1
a262 1

d267 1
a267 1

d275 1
a275 1

d292 4
a295 4
	   if ((strlen(arg)) > 3)
		strcpy(arg, arg + strlen(buf) + 1);
	   else
		   num = 1;
d305 1
a305 1

d315 1
a315 1

d323 1
a323 1
				            struct obj_data * list)
d329 1
a329 1

d334 1
a334 1

d348 1
a348 1
				           struct obj_data * list)
d352 1
a352 1

d357 1
a357 1

d370 1
a370 1
		            struct char_data * keeper, int shop_nr, int msg)
d374 2
a375 2
	 
	one_argument(arg, name);
d377 6
a382 6
	  if (is_number(name))
	  {
		strcpy(buf, name);
		strcpy(name, "#\0");
		strcat(name, buf);
	  }
d410 34
a443 34
	long amount;
/*All done in copper*/
	amount = (long)(1000*GET_PLAT(ch) + 200*GET_GOLD(ch) + 20*GET_SILVER(ch) + GET_COPPER(ch));
	return amount;
}
bool convert_next_coin(struct char_data * ch)
{

	if (GET_COPPER(ch) > 0)
		return TRUE;
	else if (GET_SILVER(ch) > 0)
	{
		GET_SILVER(ch)--;
		GET_COPPER(ch) = GET_COPPER(ch) + 20;
	}
	else if (GET_GOLD(ch) > 0)
	{
		GET_GOLD(ch)--;
	    GET_SILVER(ch) = GET_SILVER(ch) + 10;
	}
	else if (GET_PLAT(ch) > 0)
	{
		GET_PLAT(ch)--;
	    GET_GOLD(ch) = GET_GOLD(ch) + 5;
	}
	else
	{
		mudlog("Error in convert_next_coin, shop.c (PROKY)", CMP, LVL_GOD, FALSE);
		return FALSE;
	}
	return TRUE;
}


d447 16
a462 16

	if (cost <=0)
		return;

	do
	{
		while (GET_COPPER(ch) > 0)
		{
			GET_COPPER(ch)--;
			cost--;
			if (cost <= 0)
				return;
		}

	} while (convert_next_coin(ch));

d466 1
a466 1
		       struct char_data * keeper, int shop_nr)
d473 4
a476 4
  {
		send_to_char("I don't see a Shop Keeper Around!!", ch);	
		return;/*return if not a keeper*/
  }
d479 2
a480 2


d492 5
a496 5

	  if (!(obj = get_purchase_obj(ch, arg, keeper, shop_nr, TRUE)))
		return;

 
d500 1
a500 1

d530 2
a531 2
		
	{
d533 15
a547 15
		if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
		{
		amount = SHOP_AMOUNT(shop_nr, counter);
		}	
		
		if (!(amount))
			obj = read_object(GET_OBJ_RNUM(obj), REAL);
		else
		{obj_from_char(obj);
      SHOP_SORT(shop_nr)--;
		}
	}else {
      obj_from_char(obj);
      SHOP_SORT(shop_nr)--;
    }
d549 1
a549 1

d552 1
a552 1
	{
d554 3
a556 3
    }
	last_obj = obj;
	one_argument(arg, name);
d561 1
a561 1

d578 1
a578 1

d582 1
a582 1

d587 1
a587 1

d597 1
a597 1
		            struct char_data * keeper, int shop_nr, int msg)
d602 1
a602 1

d612 1
a612 1

d640 9
a648 9
			            int shop_nr)
/*
   This function is a slight hack!  To make sure that duplicate items are
   only listed once on the "list", this function groups "identical"
   objects together on the shopkeeper's inventory list.  The hack involves
   knowing how the list is put together, and manipulating the order of
   the objects on the list.  (But since most of DIKU is not encapsulated,
   and information hiding is almost never used, it isn't that big a deal) -JF
*/
d652 1
a652 1

d655 1
a655 1

d682 1
a682 1

d689 1
a689 1

d704 9
a712 9
	int temp, temp2, temp3, temp4 = 0;
	temp = ((int)(cash)/1000);
	temp2 = ((int)((int)(cash/200)-(temp*5)));
	temp3 = ((int)((((int)(cash/20))-(temp*50))-temp2*10));
	temp4 = ((int)((((cash)-(temp*1000))-(temp2*200))-(temp3*20)));
	GET_PLAT(ch) += temp;
	GET_GOLD(ch) += temp2;
	GET_SILVER(ch) += temp3;
	GET_COPPER(ch) =+ temp4;
d716 1
a716 1
		        struct char_data * keeper, int shop_nr)
d721 1
a721 1

d724 1
a724 1

d739 1
a739 1

d748 1
a748 1

d751 1
a751 1
	
d756 1
a756 1

d767 1
a767 1

d774 1
a774 1

d779 1
a779 1

d789 1
a789 1
		         struct char_data * keeper, int shop_nr)
d794 1
a794 1
int temp, temp2, temp3, temp4 = 0;
d797 1
a797 1

d806 6
a811 6
temp = ((int)(buy_price(obj, shop_nr))/1000);
temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
sprintf(buf, "I'll give you &0&b&6%d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c &0&7&bfor that!&0", temp, temp2, temp3, temp4);

d813 1
a813 1
	*/
d815 1
a815 1

d827 16
a842 16

	if (shop_producing(obj, shop_nr))
	{
	for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
		if (same_obj(obj, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
		{
		amount = SHOP_AMOUNT(shop_nr, counter);
		}
		if (amount)
			strcpy(buf2, "I have Specialy got ");
		else
			strcpy(buf2, "I have a few ");
	}else
		sprintf(buf2, "I have %d ", cnt);
	sprintf(buf, "%2d)%s", index, buf2);

d847 1
a847 1

d850 1
a850 1

d854 4
a857 4
temp = ((int)(buy_price(obj, shop_nr))/1000);
temp2 = ((int)((int)(buy_price(obj, shop_nr)/200)-(temp*5)));
temp3 = ((int)((((int)(buy_price(obj, shop_nr)/20))-(temp*50))-temp2*10));
temp4 = ((int)((((buy_price(obj, shop_nr))-(temp*1000))-(temp2*200))-(temp3*20)));
d865 1
a865 1
		        struct char_data * keeper, int shop_nr)
d871 2
a872 2

 if (!(is_ok(keeper, ch, shop_nr)))
d874 1
a874 1

d877 1
a877 1

d881 1
a881 1
i = 0;
d888 16
a903 16
	  {
		if (!last_obj) 
		{
			last_obj = obj;
			cnt = 1;
		} 
		else if (same_obj(last_obj, obj))
			cnt++;
		else 
		{
			index++;
			if (!(*name) || isname(name, last_obj->name))
			strcat(buf, list_object(last_obj, cnt, index, shop_nr));
			cnt = 1;
			last_obj = obj;
		}
d905 1
a905 1
	index++;
d913 1
a913 1

d921 1
a921 1

d934 1
a934 1

d938 1
a938 1

d941 1
a941 1

d945 1
a945 1

d953 1
a953 1

d956 1
a956 1

d963 1
a963 1

d985 1
a985 1

d1000 2
a1001 2
	if (type == LIST_PRODUCE)
		BUY_AMOUNT(list[*len]) = *amount;
d1046 1
a1046 1
	          int max, int type)
d1052 1
a1052 1
	  amount = 0;/*defult amount set to 0*/
d1054 1
a1054 1
	  error += add_to_list(list, type, &len, &temp, &amount);
d1059 1
a1059 1
	  error += add_to_list(list, type, &len, &temp, &amount);
d1066 1
a1066 1
		       int new_format, int max)
d1070 1
a1070 1

d1111 1
a1111 1

d1113 1
a1113 1

d1122 1
a1122 1

d1126 1
a1126 1
	  CREATE(shop_index[top_shop].amount, int, temp);
d1132 1
a1132 1

d1140 1
a1140 1

d1154 1
a1154 1

d1164 1
a1164 1

d1183 1
a1183 1

d1190 2
a1191 2
	  if (SHOP_KEEPER(index) == NOBODY)
		  continue;
d1203 1
a1203 1

d1215 1
a1215 1

d1223 1
a1223 1

d1241 1
a1241 1

d1263 1
a1263 1

d1267 1
a1267 1

d1284 1
a1284 1

d1289 1
a1289 1
	mob_index[SHOP_KEEPER(shop_nr)].virtual, YESNO(SHOP_FUNC(shop_nr)));
d1293 1
a1293 1
	 GET_GOLD(k), SHOP_BANK(shop_nr), GET_GOLD(k) + SHOP_BANK(shop_nr));
d1298 1
a1298 1

d1302 1
a1302 1

d1318 1
a1318 1

d1337 1
a1337 1

d1339 3
a1341 3
     SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr), SHOP_OPEN1(shop_nr),
   SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\n\r");

d1343 1
a1343 1

d1353 1
a1353 1

d1361 1
a1361 1

d1370 1
a1370 1

d1378 2
@
