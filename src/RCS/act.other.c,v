head	1.306;
access;
symbols;
locks; strict;
comment	@ * @;


1.306
date	2011.08.06.15.22.50;	author rsd;	state Exp;
branches;
next	1.305;

1.305
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.304;

1.304
date	2011.03.11.04.47.55;	author mud;	state Exp;
branches;
next	1.303;

1.303
date	2010.06.09.22.32.01;	author mud;	state Exp;
branches;
next	1.302;

1.302
date	2010.06.05.18.35.47;	author mud;	state Exp;
branches;
next	1.301;

1.301
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.300;

1.300
date	2009.07.17.01.19.01;	author myc;	state Exp;
branches;
next	1.299;

1.299
date	2009.07.17.00.48.17;	author myc;	state Exp;
branches;
next	1.298;

1.298
date	2009.06.10.18.27.43;	author myc;	state Exp;
branches;
next	1.297;

1.297
date	2009.06.09.21.48.21;	author myc;	state Exp;
branches;
next	1.296;

1.296
date	2009.06.09.05.30.58;	author myc;	state Exp;
branches;
next	1.295;

1.295
date	2009.03.20.15.38.53;	author jps;	state Exp;
branches;
next	1.294;

1.294
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.293;

1.293
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.292;

1.292
date	2009.03.16.22.15.05;	author jps;	state Exp;
branches;
next	1.291;

1.291
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.290;

1.290
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.289;

1.289
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.288;

1.288
date	2009.03.09.04.50.38;	author myc;	state Exp;
branches;
next	1.287;

1.287
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.286;

1.286
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.285;

1.285
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.284;

1.284
date	2009.03.07.22.29.13;	author jps;	state Exp;
branches;
next	1.283;

1.283
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.282;

1.282
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.281;

1.281
date	2009.02.05.17.23.39;	author myc;	state Exp;
branches;
next	1.280;

1.280
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.279;

1.279
date	2009.01.19.03.03.39;	author myc;	state Exp;
branches;
next	1.278;

1.278
date	2009.01.18.07.23.03;	author myc;	state Exp;
branches;
next	1.277;

1.277
date	2009.01.16.23.36.34;	author myc;	state Exp;
branches;
next	1.276;

1.276
date	2008.09.28.19.13.25;	author jps;	state Exp;
branches;
next	1.275;

1.275
date	2008.09.28.19.07.14;	author jps;	state Exp;
branches;
next	1.274;

1.274
date	2008.09.21.21.50.22;	author jps;	state Exp;
branches;
next	1.273;

1.273
date	2008.09.20.08.24.44;	author jps;	state Exp;
branches;
next	1.272;

1.272
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.271;

1.271
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.270;

1.270
date	2008.09.07.20.05.27;	author jps;	state Exp;
branches;
next	1.269;

1.269
date	2008.09.07.01.32.32;	author jps;	state Exp;
branches;
next	1.268;

1.268
date	2008.09.06.22.06.21;	author myc;	state Exp;
branches;
next	1.267;

1.267
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.266;

1.266
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.265;

1.265
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.264;

1.264
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.263;

1.263
date	2008.09.01.00.48.42;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2008.08.31.21.44.03;	author jps;	state Exp;
branches;
next	1.261;

1.261
date	2008.08.31.21.05.38;	author myc;	state Exp;
branches;
next	1.260;

1.260
date	2008.08.31.20.40.41;	author rbr;	state Exp;
branches;
next	1.259;

1.259
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.258;

1.258
date	2008.08.19.02.11.14;	author jps;	state Exp;
branches;
next	1.257;

1.257
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.256;

1.256
date	2008.08.16.23.04.03;	author jps;	state Exp;
branches;
next	1.255;

1.255
date	2008.08.15.03.51.35;	author myc;	state Exp;
branches;
next	1.254;

1.254
date	2008.07.27.05.29.43;	author jps;	state Exp;
branches;
next	1.253;

1.253
date	2008.07.18.17.25.34;	author jps;	state Exp;
branches;
next	1.252;

1.252
date	2008.06.21.06.59.38;	author jps;	state Exp;
branches;
next	1.251;

1.251
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.250;

1.250
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.249;

1.249
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.248;

1.248
date	2008.05.14.05.10.44;	author jps;	state Exp;
branches;
next	1.247;

1.247
date	2008.05.11.05.45.26;	author jps;	state Exp;
branches;
next	1.246;

1.246
date	2008.04.19.21.10.13;	author myc;	state Exp;
branches;
next	1.245;

1.245
date	2008.04.13.00.57.34;	author jps;	state Exp;
branches;
next	1.244;

1.244
date	2008.04.12.21.13.18;	author jps;	state Exp;
branches;
next	1.243;

1.243
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.242;

1.242
date	2008.04.05.18.07.09;	author myc;	state Exp;
branches;
next	1.241;

1.241
date	2008.04.05.16.49.07;	author myc;	state Exp;
branches;
next	1.240;

1.240
date	2008.04.05.15.30.38;	author myc;	state Exp;
branches;
next	1.239;

1.239
date	2008.04.05.05.04.24;	author myc;	state Exp;
branches;
next	1.238;

1.238
date	2008.04.05.03.30.55;	author jps;	state Exp;
branches;
next	1.237;

1.237
date	2008.04.04.22.19.06;	author jps;	state Exp;
branches;
next	1.236;

1.236
date	2008.04.04.20.37.42;	author myc;	state Exp;
branches;
next	1.235;

1.235
date	2008.04.03.17.37.21;	author jps;	state Exp;
branches;
next	1.234;

1.234
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.233;

1.233
date	2008.04.02.05.36.19;	author myc;	state Exp;
branches;
next	1.232;

1.232
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.231;

1.231
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.230;

1.230
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.229;

1.229
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.228;

1.228
date	2008.03.26.23.32.00;	author jps;	state Exp;
branches;
next	1.227;

1.227
date	2008.03.26.16.44.36;	author jps;	state Exp;
branches;
next	1.226;

1.226
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.225;

1.225
date	2008.03.19.18.29.59;	author myc;	state Exp;
branches;
next	1.224;

1.224
date	2008.03.19.04.32.14;	author myc;	state Exp;
branches;
next	1.223;

1.223
date	2008.03.17.15.31.27;	author myc;	state Exp;
branches;
next	1.222;

1.222
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.221;

1.221
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.220;

1.220
date	2008.03.08.22.29.06;	author myc;	state Exp;
branches;
next	1.219;

1.219
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.218;

1.218
date	2008.03.06.05.11.51;	author myc;	state Exp;
branches;
next	1.217;

1.217
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.216;

1.216
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.215;

1.215
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.214;

1.214
date	2008.02.11.21.04.01;	author myc;	state Exp;
branches;
next	1.213;

1.213
date	2008.02.10.20.28.42;	author jps;	state Exp;
branches;
next	1.212;

1.212
date	2008.02.10.20.19.19;	author jps;	state Exp;
branches;
next	1.211;

1.211
date	2008.02.10.19.43.38;	author jps;	state Exp;
branches;
next	1.210;

1.210
date	2008.02.09.21.57.13;	author myc;	state Exp;
branches;
next	1.209;

1.209
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.208;

1.208
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.207;

1.207
date	2008.02.09.06.19.44;	author jps;	state Exp;
branches;
next	1.206;

1.206
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.205;

1.205
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.204;

1.204
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.203;

1.203
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.202;

1.202
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.201;

1.201
date	2008.01.26.20.44.39;	author myc;	state Exp;
branches;
next	1.200;

1.200
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2008.01.26.12.30.19;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2008.01.23.14.13.54;	author jps;	state Exp;
branches;
next	1.197;

1.197
date	2008.01.23.05.13.37;	author jps;	state Exp;
branches;
next	1.196;

1.196
date	2008.01.10.06.46.53;	author myc;	state Exp;
branches;
next	1.195;

1.195
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.194;

1.194
date	2008.01.06.23.50.47;	author jps;	state Exp;
branches;
next	1.193;

1.193
date	2008.01.05.06.17.36;	author myc;	state Exp;
branches;
next	1.192;

1.192
date	2008.01.05.05.42.30;	author jps;	state Exp;
branches;
next	1.191;

1.191
date	2008.01.04.05.17.52;	author jps;	state Exp;
branches;
next	1.190;

1.190
date	2008.01.04.05.14.52;	author jps;	state Exp;
branches;
next	1.189;

1.189
date	2008.01.04.01.43.10;	author jps;	state Exp;
branches;
next	1.188;

1.188
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.187;

1.187
date	2008.01.01.03.05.20;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2007.12.21.07.52.11;	author myc;	state Exp;
branches;
next	1.184;

1.184
date	2007.12.20.23.09.03;	author myc;	state Exp;
branches;
next	1.183;

1.183
date	2007.12.20.17.18.21;	author myc;	state Exp;
branches;
next	1.182;

1.182
date	2007.12.19.20.36.16;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.180;

1.180
date	2007.10.27.18.15.10;	author myc;	state Exp;
branches;
next	1.179;

1.179
date	2007.10.12.20.32.22;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.177;

1.177
date	2007.10.09.02.38.00;	author myc;	state Exp;
branches;
next	1.176;

1.176
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.175;

1.175
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.173;

1.173
date	2007.09.12.22.23.04;	author myc;	state Exp;
branches;
next	1.172;

1.172
date	2007.09.11.19.44.48;	author myc;	state Exp;
branches;
next	1.171;

1.171
date	2007.09.11.19.41.51;	author myc;	state Exp;
branches;
next	1.170;

1.170
date	2007.09.11.16.34.24;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2007.09.03.23.59.43;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2007.09.03.22.44.09;	author jps;	state Exp;
branches;
next	1.167;

1.167
date	2007.08.27.21.18.00;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2007.08.26.01.55.41;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2007.08.18.21.23.40;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2007.08.16.11.52.47;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2007.08.14.10.43.11;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.160;

1.160
date	2007.08.05.01.50.16;	author myc;	state Exp;
branches;
next	1.159;

1.159
date	2007.08.04.21.13.10;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.157;

1.157
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.156;

1.156
date	2007.07.18.23.07.10;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2007.07.18.16.50.09;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2007.07.14.02.16.22;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2007.07.14.00.37.56;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2007.07.14.00.05.49;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2007.07.02.04.58.22;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2007.07.02.04.55.03;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2007.06.25.06.23.08;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2007.06.24.01.16.55;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2007.06.03.03.28.21;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2007.05.28.07.03.17;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2007.05.28.05.38.25;	author jps;	state Exp;
branches;
next	1.144;

1.144
date	2007.04.25.08.04.41;	author jps;	state Exp;
branches;
next	1.143;

1.143
date	2007.04.25.07.53.01;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2007.04.18.00.32.01;	author myc;	state Exp;
branches;
next	1.140;

1.140
date	2007.04.18.00.18.48;	author myc;	state Exp;
branches;
next	1.139;

1.139
date	2007.04.18.00.05.59;	author myc;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.11.14.24.00;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2007.04.11.14.15.28;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2007.04.11.09.57.55;	author jps;	state Exp;
branches;
next	1.135;

1.135
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.134;

1.134
date	2007.02.04.18.12.31;	author myc;	state Exp;
branches;
next	1.133;

1.133
date	2006.12.08.05.06.58;	author myc;	state Exp;
branches;
next	1.132;

1.132
date	2006.11.27.02.26.45;	author jps;	state Exp;
branches;
next	1.131;

1.131
date	2006.11.27.02.18.42;	author jps;	state Exp;
branches;
next	1.130;

1.130
date	2006.11.21.20.53.52;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2006.11.20.22.24.17;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2006.11.18.06.41.16;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2006.11.16.18.42.45;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2006.11.14.21.30.44;	author jps;	state Exp;
branches;
next	1.125;

1.125
date	2006.11.13.16.34.43;	author jps;	state Exp;
branches;
next	1.124;

1.124
date	2006.11.12.02.31.01;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2006.11.08.08.34.03;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2006.11.08.08.03.47;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2006.11.07.09.51.48;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2006.11.07.09.35.38;	author jps;	state Exp;
branches;
next	1.119;

1.119
date	2006.07.20.07.41.07;	author cjd;	state Exp;
branches;
next	1.118;

1.118
date	2006.04.28.21.14.02;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2006.04.28.08.37.02;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2006.04.28.01.41.12;	author rls;	state Exp;
branches;
next	1.115;

1.115
date	2006.04.28.01.26.58;	author rls;	state Exp;
branches;
next	1.114;

1.114
date	2006.04.28.00.27.33;	author rls;	state Exp;
branches;
next	1.113;

1.113
date	2005.06.16.02.07.07;	author cjd;	state Exp;
branches;
next	1.112;

1.112
date	2005.06.10.18.07.16;	author cjd;	state Exp;
branches;
next	1.111;

1.111
date	2005.06.09.21.59.17;	author cjd;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.30.18.34.16;	author rls;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.24.02.54.14;	author djb;	state Exp;
branches;
next	1.108;

1.108
date	2005.02.14.10.17.28;	author rls;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.14.02.35.29;	author djb;	state Exp;
branches;
next	1.106;

1.106
date	2004.11.15.01.03.37;	author rsd;	state Exp;
branches;
next	1.105;

1.105
date	2003.07.27.01.22.02;	author jjl;	state Exp;
branches;
next	1.104;

1.104
date	2003.07.15.02.32.04;	author jjl;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.28.03.08.09;	author jjl;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.25.04.52.22;	author jjl;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.25.03.32.34;	author jjl;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.25.03.28.16;	author jjl;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.25.02.21.03;	author jjl;	state Exp;
branches;
next	1.98;

1.98
date	2003.06.23.02.55.02;	author jjl;	state Exp;
branches;
next	1.97;

1.97
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.96;

1.96
date	2003.06.21.03.18.29;	author jjl;	state Exp;
branches;
next	1.95;

1.95
date	2003.06.21.01.01.08;	author jjl;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.03.01.05.17;	author jjl;	state Exp;
branches;
next	1.93;

1.93
date	2002.12.04.09.03.55;	author rls;	state Exp;
branches;
next	1.92;

1.92
date	2002.12.04.06.11.09;	author jjl;	state Exp;
branches;
next	1.91;

1.91
date	2002.11.30.19.39.38;	author jjl;	state Exp;
branches;
next	1.90;

1.90
date	2002.10.19.18.29.21;	author jjl;	state Exp;
branches;
next	1.89;

1.89
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.88;

1.88
date	2002.05.18.12.57.55;	author dce;	state Exp;
branches;
next	1.87;

1.87
date	2002.05.13.21.20.26;	author dce;	state Exp;
branches;
next	1.86;

1.86
date	2002.05.05.22.04.28;	author mpg;	state Exp;
branches;
next	1.85;

1.85
date	2002.04.26.21.36.30;	author mpg;	state Exp;
branches;
next	1.84;

1.84
date	2002.04.26.20.22.21;	author mpg;	state Exp;
branches;
next	1.83;

1.83
date	2002.04.26.18.54.28;	author mpg;	state Exp;
branches;
next	1.82;

1.82
date	2002.02.25.10.59.41;	author rls;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.07.02.09.56;	author dce;	state Exp;
branches;
next	1.80;

1.80
date	2001.11.15.19.52.48;	author rjd;	state Exp;
branches;
next	1.79;

1.79
date	2001.11.15.18.04.38;	author rjd;	state Exp;
branches;
next	1.78;

1.78
date	2001.10.17.21.04.05;	author rjd;	state Exp;
branches;
next	1.77;

1.77
date	2001.10.12.21.21.12;	author rjd;	state Exp;
branches;
next	1.76;

1.76
date	2001.04.06.00.58.41;	author dce;	state Exp;
branches;
next	1.75;

1.75
date	2001.04.02.23.31.21;	author dce;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.01.21.59.31;	author mtp;	state Exp;
branches;
next	1.73;

1.73
date	2001.03.25.00.44.46;	author dce;	state Exp;
branches;
next	1.72;

1.72
date	2001.03.13.20.52.09;	author dce;	state Exp;
branches;
next	1.71;

1.71
date	2001.03.07.01.45.18;	author dce;	state Exp;
branches;
next	1.70;

1.70
date	2001.03.04.17.33.19;	author dce;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.03.18.07.10;	author dce;	state Exp;
branches;
next	1.68;

1.68
date	2001.02.24.16.47.57;	author dce;	state Exp;
branches;
next	1.67;

1.67
date	2001.02.24.04.04.05;	author dce;	state Exp;
branches;
next	1.66;

1.66
date	2001.02.21.01.06.19;	author dce;	state Exp;
branches;
next	1.65;

1.65
date	2001.02.12.23.22.42;	author mtp;	state Exp;
branches;
next	1.64;

1.64
date	2001.02.11.22.29.39;	author rsd;	state Exp;
branches;
next	1.63;

1.63
date	2001.02.03.00.56.51;	author mtp;	state Exp;
branches;
next	1.62;

1.62
date	2001.02.01.02.36.21;	author dce;	state Exp;
branches;
next	1.61;

1.61
date	2001.01.16.00.33.56;	author mtp;	state Exp;
branches;
next	1.60;

1.60
date	2001.01.10.23.30.24;	author mtp;	state Exp;
branches;
next	1.59;

1.59
date	2000.11.26.10.03.57;	author jimmy;	state Exp;
branches;
next	1.58;

1.58
date	2000.11.20.04.21.41;	author rsd;	state Exp;
branches;
next	1.57;

1.57
date	2000.11.07.01.42.04;	author mtp;	state Exp;
branches;
next	1.56;

1.56
date	2000.10.25.23.43.54;	author rsd;	state Exp;
branches;
next	1.55;

1.55
date	2000.10.21.12.05.57;	author mtp;	state Exp;
branches;
next	1.54;

1.54
date	2000.10.19.01.54.08;	author mtp;	state Exp;
branches;
next	1.53;

1.53
date	2000.10.13.17.50.39;	author cmc;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.28.03.22.09;	author rsd;	state Exp;
branches;
next	1.51;

1.51
date	2000.06.04.03.59.07;	author rsd;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.21.23.55.59;	author rsd;	state Exp;
branches;
next	1.49;

1.49
date	2000.05.10.22.09.24;	author rsd;	state Exp;
branches;
next	1.48;

1.48
date	2000.04.22.22.30.04;	author rsd;	state Exp;
branches;
next	1.47;

1.47
date	2000.04.17.00.52.33;	author rsd;	state Exp;
branches;
next	1.46;

1.46
date	2000.03.08.11.14.42;	author cso;	state Exp;
branches;
next	1.45;

1.45
date	99.12.13.05.16.49;	author cso;	state Exp;
branches;
next	1.44;

1.44
date	99.11.28.22.44.48;	author cso;	state Exp;
branches;
next	1.43;

1.43
date	99.10.06.17.55.24;	author rsd;	state Exp;
branches;
next	1.42;

1.42
date	99.09.16.01.47.17;	author dce;	state Exp;
branches;
next	1.41;

1.41
date	99.09.14.00.27.17;	author dce;	state Exp;
branches;
next	1.40;

1.40
date	99.09.10.00.49.52;	author mtp;	state Exp;
branches;
next	1.39;

1.39
date	99.09.10.00.01.53;	author mtp;	state Exp;
branches;
next	1.38;

1.38
date	99.09.07.23.26.53;	author mtp;	state Exp;
branches;
next	1.37;

1.37
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.36;

1.36
date	99.09.05.05.04.43;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.09.03.23.22.50;	author mtp;	state Exp;
branches;
next	1.34;

1.34
date	99.09.03.23.06.54;	author mtp;	state Exp;
branches;
next	1.33;

1.33
date	99.08.13.15.31.01;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.31;

1.31
date	99.08.10.20.51.42;	author dce;	state Exp;
branches;
next	1.30;

1.30
date	99.08.09.22.37.11;	author mtp;	state Exp;
branches;
next	1.29;

1.29
date	99.07.24.21.01.37;	author dce;	state Exp;
branches;
next	1.28;

1.28
date	99.07.23.01.57.18;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	99.07.10.05.51.23;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	99.07.09.21.00.06;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.07.07.23.21.45;	author jimmy;	state Exp;
branches;
next	1.24;

1.24
date	99.07.07.15.46.44;	author jimmy;	state Exp;
branches;
next	1.23;

1.23
date	99.07.06.02.53.50;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	99.06.11.16.56.55;	author jimmy;	state Exp;
branches;
next	1.21;

1.21
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.05.26.01.50.28;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.05.04.19.41.51;	author dce;	state Exp;
branches;
next	1.18;

1.18
date	99.05.02.17.10.17;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.05.01.18.01.21;	author dce;	state Exp;
branches;
next	1.16;

1.16
date	99.04.29.19.02.04;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.04.23.01.51.22;	author jimmy;	state Exp;
branches;
next	1.14;

1.14
date	99.04.16.03.55.09;	author dce;	state Exp;
branches;
next	1.13;

1.13
date	99.03.30.18.59.31;	author jen;	state Exp;
branches;
next	1.12;

1.12
date	99.03.26.19.44.35;	author jen;	state Exp;
branches;
next	1.11;

1.11
date	99.03.08.21.09.52;	author dce;	state Exp;
branches;
next	1.10;

1.10
date	99.03.08.04.47.16;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.03.07.05.01.09;	author dce;	state Exp;
branches;
next	1.8;

1.8
date	99.03.06.23.51.54;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	99.03.05.20.02.36;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.22.30.30;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.02.20.18.41.36;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.17.27.25;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.03.22.54.08;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.other.c                                   Part of CircleMUD *
 *  Usage: Miscellaneous player-level commands                             *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include <sys/stat.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "house.h"
#include "events.h"
#include "dg_scripts.h"

/* extern variables */
extern struct str_app_type str_app[];
extern struct room_data *world;
/*extern struct camp_event;*/
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct room_data *world;
extern struct dex_skill_type dex_app_skill[];
extern struct spell_info_type spell_info[];
extern struct index_data *mob_index;
extern char *class_abbrevs[];
EVENTFUNC(camp_event);
void mount_summoning_thing(struct char_data *ch);
void add_follower(struct char_data * ch, struct char_data * leader);
void improve_skill(struct char_data *ch, int skill);

/* extern procedures */
SPECIAL(shop_keeper);


void stop_guarding(struct char_data *ch) {

  if(ch->guarding){
    if(ch->guarding->guarded_by == ch) {
      act("You stop guarding $N.", FALSE, ch,0,ch->guarding, TO_CHAR);
      act("$n stops guarding you.", TRUE, ch,0,ch->guarding, TO_VICT);
      ch->guarding->guarded_by = NULL;
      ch->guarding = NULL;
    }
    else {
      act("You stop guarding &N.",FALSE,ch,0,ch->guarding,TO_CHAR);
      ch->guarding = NULL;
    }
  }
}

ACMD(do_guard)
{
  struct char_data *vict;
  one_argument(argument, arg);

  if (!GET_SKILL(ch, SKILL_GUARD)) {
    send_to_char("You don't have the protective skill require to guard.\r\n",ch);
    return;
  }
  if (!arg || !*arg) {
    send_to_char("Guard who!?\r\n",ch);
    return;
  }
  if (is_abbrev(arg, "off")) {
    stop_guarding(ch);
    return;
  }
  if ((vict = get_char_room_vis(ch, arg)) == NULL || IS_NPC(vict)){
    send_to_char("That person is not here.\r\n",ch);
    return;
  }
  if(ch == vict) {
    send_to_char("Your always guarding yourself, hopefully.\r\n", ch);
    return;
  }
  if(vict->guarded_by)
    if(vict->guarded_by == ch) {
      send_to_char("You are already guarding that person.\r\n", ch);
      return;
    }
    else {
      send_to_char("Someone is already guarding that person.\r\n", ch);
      return;
    }
  if(ch->guarding) {
    if(ch->guarding == vict) {
      send_to_char("You are already guarding that person.\r\n", ch);
      return;
    }
    else
      stop_guarding(ch);
  }
  act("You start guarding $N.",FALSE,ch,0,vict,TO_CHAR);
  act("$n starts guarding you.",TRUE,ch,0,vict,TO_VICT);
  act("$n lays a protective eye on $N, guarding $M.",TRUE,ch,0,vict,TO_NOTVICT);
  ch->guarding = vict;
  vict->guarded_by = ch;
}

ACMD(do_subclass)
{
  void display_classes(struct descriptor_data *d, int select);

  if (!ch || IS_NPC(ch) || !ch->desc)
    return;
  display_classes(ch->desc, 0);
}

ACMD(do_quit)
{
  void die(struct char_data * ch, struct char_data * killer);
  void Crash_rentsave(struct char_data * ch, int cost);
  extern int free_rent;
  int save_room;
  struct descriptor_data *d, *next_d;
  if (IS_NPC(ch) || !ch->desc)
    return;

  if (subcmd != SCMD_QUIT && GET_LEVEL(ch) < LVL_IMMORT)
    send_to_char("You have to type quit--no less, to quit!\r\n", ch);
  else if (GET_POS(ch) == POS_FIGHTING)
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
  else if (GET_POS(ch) < POS_STUNNED) {
    send_to_char("You die before your time...\r\n", ch);
    die(ch, NULL);
  } else {
    if (!GET_INVIS_LEV(ch))
      act("$n has left the game.", TRUE, ch, 0, 0, TO_ROOM);
    sprintf(buf, "%s has quit the game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    send_to_char("Goodbye, friend.. Come back soon!\r\n", ch);

    /*
     * kill off all sockets connected to the same player as the one who is
     * trying to quit.  Helps to maintain sanity as well as prevent duping.
     */
    for (d = descriptor_list; d; d = next_d) {

      next_d = d->next;
      if (d == ch->desc)
        continue;
      if (d->character && (GET_IDNUM(d->character) == GET_IDNUM(ch)))
	{

	  close_socket(d);
	}
    }
    save_room = ch->in_room;
    if (free_rent)
      Crash_rentsave(ch, 0);

    save_char(ch, save_room);
    GET_LOADROOM(ch) = world[ch->in_room].number;
    extract_char(ch);   /*swapped banyal*/

    /* If someone is quitting in their house, let them load back here */
    if (ROOM_FLAGGED(save_room, ROOM_HOUSE))
      save_char(ch, save_room);

  }
}


ACMD(do_shapechange)
{
  int mob_vnum, r_num, location;
  struct char_data *mob, *player;

  one_argument(argument, arg);

  if (ch->desc && ch->desc->original && !GET_SKILL(ch->desc->original, SKILL_SHAPECHANGE)){
    send_to_char("You have no idea how to do that!", ch);
    return;
  }

  if (!IS_NPC(ch) && !GET_SKILL(ch, SKILL_SHAPECHANGE)) {
    send_to_char("You have no idea how to do that!", ch);
    return;
  }
  if (!*arg) {
    send_to_char("Shapechange to what?", ch);
    return;
  }
  if (ch->desc && ch->desc->original) {
    if (is_abbrev(arg, "me")) {

      if (ch->desc->original->desc)
	close_socket(ch->desc->original->desc);
      player = ch->desc->original;
      act("You quickly morph back to your original self.",FALSE,ch,0,NULL,TO_CHAR);
      act("$n&0 contorts wildly as it reforms into $N.",FALSE,ch,0,player, TO_ROOM);

      ch->desc->character = ch->desc->original;
      ch->desc->original = NULL;
      ch->desc->character->desc = ch->desc;
      ch->desc = NULL;
      char_from_room(player);
      char_to_room(player, ch->in_room);
      extract_char(ch);
      return;
    }
    else {
      send_to_char("You cannot shapechange from this form.", ch);
      return;
    }
  }
  if (is_abbrev(arg, "mammal"))
    mob_vnum = number(1000,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1000));
  else if (is_abbrev(arg, "bird"))
    mob_vnum = number(1010,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1010));
  else if (is_abbrev(arg, "reptile"))
    mob_vnum = number(1020,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1020));
  else {
    send_to_char("You can only be a mammal, bird, or reptile at this time.",ch);
    return;
  }

  if ((r_num = real_mobile(mob_vnum)) < 0) {
    send_to_char("You start to change, then feeling ill, slumping back to your normal form.", ch);
    return;
  }
  mob = read_mobile(r_num, REAL);

  act("The snap of bones reforming can be heard, as $n's form takes the shape of $N&0!", FALSE, ch, 0, mob, TO_ROOM);
  act("You transform into $N!", FALSE, ch, 0, mob, TO_CHAR);

  if ((location = real_room(0)) < 0) {
    send_to_char("There is a problem with the target room!", ch);
    return;
  }

  char_to_room(mob, ch->in_room);
  char_from_room(ch);
  char_to_room(ch, location);

  if (PRF_FLAGGED(ch, PRF_AUTOEXIT))
    SET_BIT(PRF_FLAGS(mob), PRF_AUTOEXIT);
  GET_PROMPT(mob) = str_dup(GET_PROMPT(ch));


  ch->desc->character = mob;
  ch->desc->original = ch;
  mob->desc = ch->desc;
  ch->desc = NULL;


}


ACMD(do_save)
{
  if (IS_NPC(ch) || !ch->desc)
    return;

  if (cmd) {
    sprintf(buf, "Saving %s.\r\n", GET_NAME(ch));
    send_to_char(buf, ch);
  }
  save_char(ch, NOWHERE);
  /*GET_LOADROOM(ch) = world[ch->in_room].number;*/
  Crash_crashsave(ch);
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE_CRASH))
    House_crashsave(world[ch->in_room].number);
}


/* generic function for commands which are normally overridden by
   special procedures - i.e., shop commands, mail commands, etc. */
ACMD(do_not_here)
{
  send_to_char("Sorry, but you cannot do that here!\r\n", ch);
}


ACMD(do_camp)
{
  struct camp_event *ce;

  /*if (GET_ACTION(ch)) {
    send_to_char("You are too busy to do this!\r\n", ch);
    return;
    }*/

  /* No crashes from funny guys ordering pets to camp...Banyal*/

  if (IS_NPC(ch) || !ch->desc)
    return;

  /*Lets restrict where we can camp i.e. no city water indoors...banyal*/
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (SECT(ch->in_room) == SECT_INSIDE) {
      send_to_char("&7You always pitch a tent indoors?&0\r\n", ch);
      return;
    }

    if (SECT(ch->in_room) == SECT_CITY) {
      send_to_char("&7Ye can't pitch a tent on the sidewalk fool.&0\r\n", ch);
      return;
    }

    if ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
        (SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
	(SECT(ch->in_room) == SECT_UNDERWATER)) {
      send_to_char("&7Go buy a floating tent and try again.&0\r\n", ch);
      return;
    }
  }
  if (SECT(ch->in_room) == SECT_FLYING) {
    send_to_char("&7You can't camp in mid-air.&0\r\n", ch);
    return;
  }


  if (GET_POS(ch) == POS_FIGHTING)
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
  else if (GET_POS(ch) < POS_STUNNED) {
    send_to_char("Its hard to set your tent up while dieing...\r\n", ch);
  } else {
    /* create and initialize the camp event */
    CREATE(ce, struct camp_event, 1);
    ce->ch = ch;
    ce->was_in = ch->in_room;
    if (GET_LEVEL(ch) >= LVL_IMMORT)
      GET_ACTION(ch) = event_create(camp_event, ce, 5);
    else
      GET_ACTION(ch) = event_create(camp_event, ce, 350);
    act("You start setting up camp.", FALSE, ch, NULL, NULL, TO_CHAR);
  }
}

EVENTFUNC(camp_event)
{
  struct camp_event *ce = (struct camp_event *) event_obj;
  struct char_data *ch = NULL;
  int was_in, now_in;
  void Crash_rentsave(struct char_data *ch, int cost);

  /* extract all the info from ce */
  ch = ce->ch;
  was_in = ce->was_in;
  now_in = ch->in_room;

  /* make sure we're supposed to be here, then clear it */
  if (!GET_ACTION(ch)){
    free(event_obj);
    return 0;
    GET_ACTION(ch) = NULL;
  }

  if (IS_NPC(ch) || !ch->desc) {
    free(event_obj);
    return 0;
  }

  if (GET_POS(ch) == POS_FIGHTING) {
    act("You decide now is not the best time for camping.", FALSE, ch, NULL,
	NULL, TO_CHAR);
    free(event_obj);
    return 0;
  }
  if (now_in != was_in) {
    act("You are no longer near where you began the campsite.", FALSE, ch,
	NULL, NULL, TO_CHAR);
    free(event_obj);
    return 0;
  }
  act("You complete your campsite, and leave this world for awhile.", FALSE,
      ch, NULL, NULL, TO_CHAR);
  if (!GET_INVIS_LEV(ch))
    act("$n rolls up his bedroll and tunes out the world.", TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf, "%s camped out", GET_NAME(ch));
  mudlog(buf, CMP, LVL_GOD, TRUE);
  Crash_rentsave(ch, 0);
  save_char(ch, now_in);
  GET_LOADROOM(ch) = world[ch->in_room].number;
  extract_char(ch);
  /* free(GET_ACTION(ch));
   */free(event_obj);
  return 0;
}

ACMD(do_unbind)
{
  int prob, percent;
  struct char_data *vict;
  char arg[MAX_INPUT_LENGTH];

  one_argument(argument, arg);

  if (!arg || !*arg) {
    if (!PLR_FLAGGED(ch, PLR_BOUND)){
      send_to_char("You are free as a bird!\r\n", ch);
      return;}
    prob = number(1, 70);
    percent = number(20, 101);
    if (prob > percent){
      send_to_char("You break free from your binds!\r\n", ch);
      act("$n breaks free from his binds", FALSE, ch, 0, 0, TO_ROOM);
      REMOVE_BIT(PLR_FLAGS(ch), PLR_BOUND);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      return;
    }else
      WAIT_STATE(ch, PULSE_VIOLENCE*3);
    return;
  }else{
    if (!(vict = get_char_room_vis(ch, arg))) {
      send_to_char("Unbind who?\r\n", ch);
      return;    }
    if (vict == ch){
      prob = number(20, 70);
      percent = number(1, 101);
      if (prob > percent){
	send_to_char("You break free from your binds!\r\n", ch);
	act("$n breaks free from his binds", FALSE, ch, 0, 0, TO_ROOM);
	REMOVE_BIT(PLR_FLAGS(ch), PLR_BOUND);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	return;
      }else
	WAIT_STATE(ch, PULSE_VIOLENCE*3);
      return;}
    REMOVE_BIT(PLR_FLAGS(vict), PLR_BOUND);
    WAIT_STATE(ch, PULSE_VIOLENCE);
    send_to_char("You are free of your binds.\r\n", vict);
  }
}

ACMD(do_bind)
{
  struct char_data *vict;
  extern struct dex_app_type dex_app[];
  struct obj_data *held = GET_EQ(ch, WEAR_HOLD);
  int prob, percent;


  one_argument(argument, arg);

  if(!arg)
    send_to_char("Bind who?", ch);
  else if (!(vict = get_char_vis(ch, arg)))
    send_to_char("There is no such player.\r\n", ch);
  else if(IS_NPC(vict))
    send_to_char("You can't do that to a mob!\r\n", ch);
  else if(GET_LEVEL(vict) > LVL_GOD)
    send_to_char("Hmmm...you'd better not.\r\n", ch);
  else if(!held)
    send_to_char("You must be holding a rope to tie someone up!\r\n", ch);
  else {

    if (ch == vict) {
      send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
      return;
    }      if (PLR_FLAGGED(vict, PLR_BOUND)) {
      send_to_char("Your victim is already tied up.\r\n", ch);
      return;
    }
    if(GET_OBJ_TYPE(held) != ITEM_ROPE){
      send_to_char("You must be holding a rope to tie someone up!\r\n", ch);
      return;
    }
    if(GET_SKILL(ch, SKILL_BIND) == 0){
      if(GET_POS(vict) > POS_STUNNED){
	send_to_char("Your not skilled enough to tie a conscious person\r\n", ch);
	return;
      }else{
	act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	SET_BIT(PLR_FLAGS(vict), PLR_BOUND);
	extract_obj(held);
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;
}
    }else{
      prob = number(1, 50);
      prob += GET_SKILL(ch, SKILL_BIND);
      prob += GET_LEVEL(ch);
      percent = number(50, 200);
      percent += dex_app[GET_DEX(vict)].defensive;
      percent += GET_LEVEL(vict);

      if(GET_POS(vict) < POS_SLEEPING)
	prob = percent + 1;

      if(prob > percent){
	act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	SET_BIT(PLR_FLAGS(vict), PLR_BOUND);
	extract_obj(held);
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	return;}else{
	  act("You tries to tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n tries to tie you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	  act("$n tries to tie up $N.", FALSE, ch, 0, vict, TO_ROOM);
	  return;
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	}
    }
  }
}

ACMD(do_abort)
{
  if(PLR_FLAGGED(ch, PLR_CASTING)){
    send_to_char("You abort your spell!\r\n", ch);
    REMOVE_BIT(PLR_FLAGS(ch), PLR_CASTING);
  }else
    send_to_char("Huh?!?", ch);
}


ACMD(do_sneak)
{
  struct affected_type af;
  byte percent;
  char sbuf[MAX_STRING_LENGTH];

  if (GET_SKILL(ch, SKILL_SNEAK) < 1){
    send_to_char("You better leave art to the thieves.\r\n", ch);
    return;
  }
  one_argument(argument, sbuf);
  if (*sbuf) {
    if (!str_cmp(sbuf, "off")) {
      if (affected_by_spell(ch, SKILL_SNEAK)) {
	affect_from_char(ch, SKILL_SNEAK);
	send_to_char("Ok, you quit trying to sneak.\r\n", ch);
	return;
      } else if (IS_AFFECTED(ch, AFF_SNEAK)) {
	send_to_char("You can't seem to quit.\r\n", ch);
	return;
      } else {
	send_to_char("You need to be sneaking before you can stop sneaking.\r\n", ch);
	return;
      }
    } else {
      send_to_char("Try \"sneak off\" to quit sneaking.\r\n", ch);
      return;
    }
    return;
  }
  if (RIDING(ch)) {
    send_to_char("While mounted? I don't think so...\r\n", ch);
    return;
  }

  send_to_char("Okay, you'll try to move silently for a while.\r\n", ch);
  WAIT_STATE(ch, PULSE_VIOLENCE + 2);
  if (IS_AFFECTED(ch, AFF_SNEAK))
    affect_from_char(ch, SKILL_SNEAK);

  percent = number(1, 101);	/* 101% is a complete failure */

  if (percent > GET_SKILL(ch, SKILL_SNEAK) + dex_app_skill[GET_DEX(ch)].sneak)
    return;

  af.type = SKILL_SNEAK;
  af.duration = GET_LEVEL(ch) / 2;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_SNEAK;
  affect_to_char(ch, &af);
  improve_skill(ch, SKILL_SNEAK);
}



ACMD(do_hide)
{
  byte percent;

  if (GET_SKILL(ch, SKILL_HIDE) < 1){          // was skill_sneak duh -Banyal
    send_to_char("You better leave art to the thieves.\r\n", ch);
    return;
  }

  if(IS_FIGHTING(ch)) {
    send_to_char("You can not hide in combat...\r\n", ch);
    return;
  }

  if (RIDING(ch)) {
    send_to_char("While mounted? I don't think so...\r\n", ch);
    return;
  }
  send_to_char("You attempt to hide yourself.\r\n", ch);

  if (IS_AFFECTED(ch, AFF_HIDE)) {
    send_to_char("You are already well hidden in the shadows...\r\n", ch);
    return;
  }
  percent = number(1, 101);	/* 101% is a complete failure */

  WAIT_STATE(ch, PULSE_VIOLENCE * 4);

  if (percent > GET_SKILL(ch, SKILL_HIDE) + dex_app_skill[GET_DEX(ch)].hide){
    improve_skill(ch, SKILL_HIDE);
    return;
  }
  SET_BIT(AFF_FLAGS(ch), AFF_HIDE);
  improve_skill(ch, SKILL_HIDE);
}




ACMD(do_steal)
{
  struct char_data *vict;
  struct obj_data *obj;
  char vict_name[MAX_INPUT_LENGTH], obj_name[MAX_INPUT_LENGTH];
  int percent, gold, eq_pos, pcsteal = 0, ohoh = 0;
  extern int pt_allowed;


  ACMD(do_gen_comm);

  argument = one_argument(argument, obj_name);
  one_argument(argument, vict_name);

  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("Steal what from who?\r\n", ch);
    return;
  } else if (vict == ch) {
    send_to_char("Come on now, that's rather stupid!\r\n", ch);
    return;
  }

  /* 101% is a complete failure */
  percent = number(1, 101) - dex_app_skill[GET_DEX(ch)].p_pocket;

  if (GET_POS(vict) < POS_SLEEPING)
    percent = -1;		/* ALWAYS SUCCESS */

  if (!pt_allowed && !IS_NPC(vict))
    pcsteal = 1;

  /* NO NO With Imp's and Shopkeepers, and if player thieving is not allowed  add || pcsteal || after imort to disable player steal
     banyal */
  if (GET_LEVEL(vict) >= LVL_IMMORT ||
      GET_MOB_SPEC(vict) == shop_keeper)
    percent = 101;		/* Failure */

  if (str_cmp(obj_name, "coins") && str_cmp(obj_name, "gold")) {

    /*a bug if player is blind he safe from steal*/
    if (!(obj = get_obj_in_list_vis(vict, obj_name, vict->carrying))) {

      for (eq_pos = 0; eq_pos < NUM_WEARS; eq_pos++)
	if (GET_EQ(vict, eq_pos) &&
	    (isname(obj_name, GET_EQ(vict, eq_pos)->name)) &&
	    CAN_SEE_OBJ(ch, GET_EQ(vict, eq_pos))) {
	  obj = GET_EQ(vict, eq_pos);
	  break;
	}
      if (!obj) {
	act("$E hasn't got that item.", FALSE, ch, 0, vict, TO_CHAR);
	return;
      } else {			/* It is equipment */
	if ((GET_POS(vict) > POS_STUNNED)) {
	  send_to_char("Steal the equipment now?  Impossible!\r\n", ch);
	  return;
	} else {
	  act("You unequip $p and steal it.", FALSE, ch, obj, 0, TO_CHAR);
	  act("$n steals $p from $N.", FALSE, ch, obj, vict, TO_NOTVICT);
	  obj_to_char(unequip_char(vict, eq_pos), ch);
	  improve_skill(ch, SKILL_STEAL);
	}
      }
    } else {			/* obj found in inventory */

      percent += GET_OBJ_WEIGHT(obj);	/* Make heavy harder */

      if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
	ohoh = TRUE;
	act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
	act("$n tried to steal something from you!", FALSE, ch, 0, vict, TO_VICT);
	act("$n tries to steal something from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      } else {			/* Steal the item */
	if ((IS_CARRYING_N(ch) + 1 < CAN_CARRY_N(ch))) {
	  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) < CAN_CARRY_W(ch)) {
	    obj_from_char(obj);
	    obj_to_char(obj, ch);
	    send_to_char("Got it!\r\n", ch);
	    improve_skill(ch, SKILL_STEAL);
	  }
	} else
	  send_to_char("You cannot carry that much.\r\n", ch);
      }
    }
  } else {			/* Steal some coins */
    if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
      ohoh = TRUE;
      act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
      act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to steal gold from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
    } else {
      /* Steal some gold coins */
      gold = (int) ((GET_GOLD(vict) * number(1, 10)) / 100);
      gold = MIN(1782, gold);
      if (gold > 0) {
	GET_GOLD(ch) += gold;
	GET_GOLD(vict) -= gold;
        if (gold > 1) {
	  sprintf(buf, "Bingo!  You got %d gold coins.\r\n", gold);
	  send_to_char(buf, ch);
	  improve_skill(ch, SKILL_STEAL);
	} else {
	  send_to_char("You manage to swipe a solitary gold coin.\r\n", ch);
	}
      } else {
	send_to_char("You couldn't get any gold...\r\n", ch);
      }
    }
  }

  if (ohoh && IS_NPC(vict) && AWAKE(vict))
    hit(vict, ch, TYPE_UNDEFINED);
}



ACMD(do_practice)
{
  void list_skills(struct char_data * ch);

  one_argument(argument, arg);

  if (*arg)
    send_to_char("You can only practice skills in your guild.\r\n", ch);
  else
    list_skills(ch);
}



ACMD(do_visible)
{
  void appear(struct char_data * ch);
  void perform_immort_vis(struct char_data *ch);

  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    perform_immort_vis(ch);
    return;
  }

  if IS_AFFECTED(ch, AFF_INVISIBLE) {
    appear(ch);
    send_to_char("You break the spell of invisibility.\r\n", ch);
  } else
    send_to_char("You are already visible.\r\n", ch);
}



ACMD(do_title)
{
  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (IS_NPC(ch))
    send_to_char("Your title is fine... go away.\r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_NOTITLE))
    send_to_char("You can't title yourself -- you shouldn't have abused it!\r\n", ch);
  else if (strstr(argument, "(") || strstr(argument, ")"))
    send_to_char("Titles can't contain the ( or ) characters.\r\n", ch);
  else if (strlen(argument) > MAX_TITLE_LENGTH) {
    sprintf(buf, "Sorry, titles can't be longer than %d characters.\r\n",
	    MAX_TITLE_LENGTH);
    send_to_char(buf, ch);
  } else {
    set_title(ch, argument);
    sprintf(buf, "Okay, you're now %s %s.\r\n", GET_NAME(ch), GET_TITLE(ch));
    send_to_char(buf, ch);
  }
}

int perform_group(struct char_data *ch, struct char_data *vict)
{
  if (IS_AFFECTED(vict, AFF_GROUP) || !CAN_SEE(ch, vict))
    return 0;

  SET_BIT(AFF_FLAGS(vict), AFF_GROUP);
  if (ch != vict)
    act("&0&2&b$N is now a member of your group.&0", FALSE, ch, 0, vict, TO_CHAR);
  act("&0&2&bYou are now a member of $n's group.&0", FALSE, ch, 0, vict, TO_VICT);
  act("&0&2&b$N is now a member of $n's group.&0", FALSE, ch, 0, vict, TO_NOTVICT);
  return 1;
}


void print_group(struct char_data *ch)
{
  struct char_data *k;
  struct group_type *f;
  char harm_color[20];
  int perc = 100;
  if (!IS_AFFECTED(ch, AFF_GROUP))
    send_to_char("&0&2&bBut you are not the member of a group!&0\r\n", ch);
  else {
    sprintf(buf, "%s&0&7&bYour group consists of:&0\r\n", CCUND(ch,C_NRM));
    send_to_char(buf, ch);

    k = (ch->groupmaster ? ch->groupmaster : ch);
    if (IS_AFFECTED(k, AFF_GROUP)) {
      perc = (100*GET_HIT(k)/GET_MAX_HIT(k));
      sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(k,C_NRM) : CCBBLK(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCNRM(ch,C_NRM) :
	       perc >= 70 ? CCBLD(ch,C_NRM) :
              perc >= 45 ? CCNRM(ch,C_NRM) :
	       perc >= 20 ? CCNRM(ch,C_NRM) :
	       perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCYEL(ch,C_SPR) :
	       perc >= 70 ? CCYEL(ch, C_NRM) :
	       perc >= 45 ? CCMAG(ch, C_NRM) :
	       perc >= 20 ? CCRED(ch, C_NRM) :
	       perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));



      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dM %3dv/%3dV] [%s] (&0&2&bHead of group&0)",
	      harm_color,
	      GET_NAME(k), harm_color,
	      GET_HIT(k), CCUND(k,C_NRM), GET_MAX_HIT(k), GET_MANA(k), GET_MOVE(k), GET_MAX_MOVE(k), CLASS_ABBR(k));
      act(buf, FALSE, ch, 0, k, TO_CHAR);
    }

    for (f = k->groupees; f; f = f->next) {
      if (!IS_AFFECTED(f->groupee, AFF_GROUP))
	continue;

      perc = (100*GET_HIT(f->groupee)/GET_MAX_HIT(f->groupee));
      sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(ch,C_NRM) : CCBBLK(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCNRM(ch,C_NRM) :
	       perc >= 70 ? CCBLD(ch,C_NRM) :
	       perc >= 45 ? CCNRM(ch,C_NRM) :
	       perc >= 20 ? CCNRM(ch,C_NRM) :
	       perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCYEL(ch,C_SPR) :
	       perc >= 70 ? CCYEL(ch, C_NRM) :
	       perc >= 45 ? CCMAG(ch, C_NRM) :
	       perc >= 20 ? CCRED(ch, C_NRM) :
	       perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));



      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dM %3dv/%3dV] [%s]",
	      harm_color,
	      GET_NAME(f->groupee), harm_color,
	      GET_HIT(f->groupee), CCUND(f->groupee,C_NRM), GET_MAX_HIT(f->groupee), GET_MANA(f->groupee), GET_MOVE(f->groupee), GET_MAX_MOVE(f->groupee), CLASS_ABBR(f->groupee));
      act(buf, FALSE, ch, 0, f->groupee, TO_CHAR);
    }
  }
}

/*print out mgroup info*/
void mprint_group(struct char_data *ch)
{
  struct char_data *k;
  struct mgroup_type *f;
  struct group_type *g;
  if (!(ch->groupmaster) && (!(IS_AFFECTED2(ch, AFF2_MGROUP))))
    {/*should be group master but not in a large mgroup*/
      send_to_char("Your group is not in a major group\r\n", ch);
      return;
    }
  if ((ch->groupmaster) && (!(IS_AFFECTED2(ch->groupmaster, AFF2_MGROUP))))
    {
      send_to_char("Your group is not part of a major group\r\n", ch);
      return;
    }

  if (!(IS_AFFECTED(ch, AFF_GROUP)))
    {
      send_to_char("&0&7&bYou are not a member of a group&0\r\n", ch);
      return;
    }

  if ((!(ch->groupmaster)) && (!(IS_AFFECTED2(ch, AFF2_MGROUP))))
    {
      send_to_char("&0&7&bYou are not a member of a major group&0\r\n", ch);
      return;
    }

  if (ch->groupmaster){
    if (!(IS_AFFECTED2(ch->groupmaster, AFF2_MGROUP)))
      {
	send_to_char("&0&2&bYour Group is not a member of a major group&0\r\n", ch);
	return;
      }

  }


  if (0)
    send_to_char("&0&1But you are not the member of a major group!&0\r\n", ch);
  else
    {
      sprintf(buf, "%s&0&1Your group consists of:&0\r\n", CCUND(ch,C_NRM));
      send_to_char(buf, ch);
      /*check wether this person is a mgroupee or mgroup master*/
      if ((!(ch->mgroupmaster)) && (!(ch->groupmaster))) /*is MASTER */
	k = ch;
      else if ((!(ch->mgroupmaster)) && ((ch->groupmaster))) /*normal groupee*/
	{
	  if (!(ch->groupmaster->mgroupmaster))
	    k = ch->groupmaster;/*if groupmaster is the MASTER*/
	  else
	    {
	      if ((ch->groupmaster->mgroupmaster))
		k = (ch->groupmaster->mgroupmaster);
	      else
		{
		  sprintf(buf,"Very Bad Assign in mgroup display, Exiting: caused by %s", GET_NAME(ch));
		  mudlog(buf, CMP, LVL_GOD, FALSE);
		}
	    }
	}
      else
	k = ch->mgroupmaster;
      if (IS_AFFECTED2(k, AFF2_MGROUP)) /*mgroup first in list*/
	{			sprintf(buf, "&0&1%-25s&0 [%3dV] [%s] (&1Head of major group&0)", GET_NAME(k), GET_MOVE(k), CLASS_ABBR(k));
	act(buf, FALSE, ch, 0, k, TO_CHAR);
	/*add the normal group member names*/

	for (g = k->groupees; g; g = g->next) /*normal group loop*/
	  {
	    if (!IS_AFFECTED(g->groupee, AFF_GROUP))
	      continue;
	    sprintf(buf, "     &0&2&b%-20s&0 [%3dV] [%s]", GET_NAME(g->groupee), GET_MOVE(g->groupee), CLASS_ABBR(g->groupee));
	    act(buf, FALSE, ch, 0, g->groupee, TO_CHAR);
	  }
	}


      for (f = k->mgroupees; f; f = f->next)
	{
	  if (!IS_AFFECTED2(f->mgroupee, AFF2_MGROUP))
	    continue;
	  sprintf(buf, "&0&1%-25s&0 [%3dV] [%s] (&2&bHead of minor group&0)", GET_NAME(f->mgroupee), GET_MOVE(f->mgroupee), CLASS_ABBR(f->mgroupee));
	  act(buf, FALSE, ch, 0, f->mgroupee, TO_CHAR);
	  for (g = f->mgroupee->groupees; g; g = g->next)
	    {
	      if (!IS_AFFECTED(g->groupee, AFF_GROUP))
		continue;
	      sprintf(buf, "     &0&2&b%-20s&0 [%3dV] [%s]", GET_NAME(g->groupee), GET_MOVE(g->groupee), CLASS_ABBR(g->groupee));
	      act(buf, FALSE, ch, 0, g->groupee, TO_CHAR);
	    }
	}
    }
}

#define GROUP 1
#define MGROUP 2
#define FOLL 3
ACMD(do_readlist)
{
  void readfoll(struct char_data *ch);
  void readlist(struct char_data *ch);
  void readmlist(struct char_data *ch);
  struct char_data *person = NULL;
  int list;
  argument = one_argument(argument, buf);

  switch(*buf)
    {
    case 'f':
      send_to_char("Listings of characters followers:\r\n", ch);
      list = FOLL;
      break;
    case 'g':
      send_to_char("Listings of characters group:\r\n", ch);
      list = GROUP;
      break;
    case 'm':
      send_to_char("Listings of characters major group members:\r\n", ch);
      list = MGROUP;
      break;
    default:
      send_to_char("Option supported try:\r\n", ch);
      send_to_char("f - followers list\r\n", ch);
      send_to_char("g - group list\r\n", ch);
      send_to_char("m - major group list\r\n", ch);
      return;
    }
  one_argument(argument, buf);
  if (*buf) /*(argument with it)*/
    {
      if (!(person = get_char_room_vis(ch, buf)))
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/
    }
  switch (list)
    {
    case FOLL:
      readfoll(person);
      break;
    case GROUP:
      readlist(person);
      break;
    case MGROUP:
      readmlist(person);
      break;
    default:
      send_to_char("Incorrect List Option\r\n", ch);
      return;
    }
}


ACMD(do_douse)
{
  struct char_data *vict;
  if(!ch)
    return;

  one_argument(argument, arg);

  vict=get_char_room_vis(ch,arg);
  if(!arg || !*arg || vict==ch) {
    if(!IS_AFFECTED2(ch, AFF2_ON_FIRE)) {
      send_to_char("Where's the fire?\r\n",ch);
      return;
    }
    else {
      if((GET_SKILL(ch, SKILL_DOUSE)-10) < number(0,100)){
        act("$n&0 rolls around on the ground frantically in an attempt to douse the flames consuming $s body.",FALSE,ch,0,0,TO_ROOM);
        act("You roll around on the ground trying to douse the flames engulfing your body!",FALSE,ch,0,0,TO_CHAR);
        improve_skill(ch, SKILL_DOUSE);
      }
      else {
        act("$n&0 rolls on the ground frantically, finally dousing the fire that was consuming $m.",FALSE,ch,0,0,TO_ROOM);
        act("You roll around on the ground, finally dousing the flames that were consuming you.",FALSE,ch,0,0,TO_CHAR);
        improve_skill(ch, SKILL_DOUSE);
	REMOVE_BIT(AFF2_FLAGS(ch),AFF2_ON_FIRE);
      }
    }
  }
  else {
    if(!vict){
      send_to_char("You don't see that person here.\r\n",ch);
      return;
    }
    if(!IS_AFFECTED2(vict, AFF2_ON_FIRE)){
      send_to_char("That person is not on fire.\r\n",ch);
      return;
    }
    if((GET_SKILL(ch, SKILL_DOUSE)-50) < number(0,100)){
      act("You frantically try to brush the flames from $N&0.",FALSE,ch,0,vict,TO_CHAR);
      act("$n&0 aids you, attempting to douse your flames.",FALSE,ch,0,vict,TO_VICT);
      act("$n&0 frantically attempts to brush the flames off $N&0.",FALSE,ch,0,vict,TO_NOTVICT);
      improve_skill(ch,SKILL_DOUSE);
    }
    else {
      act("You frantically try to brush the flames from $N&0. You finally put $M out!",FALSE,ch,0,vict,TO_CHAR);
      act("$n&0 aids you, finally putting your flames out!",FALSE,ch,0,vict,TO_VICT);
      act("$n&0 finally douses the flames that were consuming $N&0!",FALSE,ch,0,vict,TO_NOTVICT);
      improve_skill(ch,SKILL_DOUSE);
      REMOVE_BIT(AFF2_FLAGS(vict),AFF2_ON_FIRE);
    }
  }
  WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_disband)
{
  void stop_groupee(struct char_data *ch, bool hide);
  void die_mgroupee(struct char_data *ch);

  struct group_type *f, *g;
  /*ch is thus the actual leader*/



  if (ch->groupmaster || !(IS_AFFECTED(ch, AFF_GROUP))) {
    send_to_char("&0&7&bBut you lead no group!&0\r\n", ch);
    return;
  }
  if (IS_AFFECTED2(ch, AFF2_MGROUP))
    die_mgroupee(ch);

  sprintf(buf,"&0&2&b%s has disbanded his group&0\r\n", GET_NAME(ch));
  for (f = ch->groupees; f; f = g)
    {
      ch->groupees = f->next;
      g = f->next;

      REMOVE_BIT(AFF_FLAGS(f->groupee), AFF_GROUP);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch,
	  0, f->groupee, TO_VICT);
      send_to_char(buf, f->groupee);
      f->groupee->groupmaster = NULL;

      free(f);

    }
  send_to_char("&0&2&bYou disband the group&0\r\n", ch);
  ch->groupees = NULL;
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
  /*remove group flag of leader*/
}


ACMD(do_mdisband)
{
  void stop_mgroupee(struct char_data *ch, bool hide);
  struct mgroup_type *f, *g;
  /*ch is thus the actual leader*/
  if (ch->mgroupmaster || !(IS_AFFECTED2(ch, AFF2_MGROUP))) {
    send_to_char("&0&1But you lead no major group!&0\r\n", ch);
    return;
  }
  /*if he a member of a major group remove him from that*/
  sprintf(buf,"&0&1%s has disbanded his major group&0\r\n",
	  GET_NAME(ch));
  for (f = ch->mgroupees; f; f = g)
    {
      g = f->next;
      ch->mgroupees = f->next;
      act("&0&1You have been kicked out of $n's major group!&0", FALSE, ch, 0, f->mgroupee, TO_VICT);
      send_to_char(buf, f->mgroupee);
      f->mgroupee->mgroupmaster = NULL;
      REMOVE_BIT(AFF2_FLAGS(f->mgroupee), AFF2_MGROUP);
      free(f);


    }
  send_to_char("&0&1You disband the major group&0\r\n", ch);
  ch->mgroupees = NULL;
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);

  /*remove group flag of leader*/
}


ACMD(do_mgroup)
{
  struct char_data *newmgroupee;
  void stop_mgroupee(struct char_data *ch, bool hide);
  void add_mgroupee(struct char_data *ch, struct char_data *leader, bool hide);
  void die_mgroupee(struct char_data * ch);
  one_argument(argument, buf);

  /*do some removal*/
  if (!(IS_AFFECTED(ch, AFF_GROUP)))
    {/*check to see if in a normal group*/
      send_to_char("You are not even in a group!\r\n", ch);
      return;
    }

  if (*buf) /*(argument with it)*/
    {
      if (!(newmgroupee = get_char_vis(ch, buf)))
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/
    }
  else
    {
      if (!*buf)
	{
	  mprint_group(ch);
	  return;
	}
    }
  if (IS_NPC(newmgroupee))
    {
      send_to_char("Sorry he doesnt want to be major grouped\r\n", ch);
      return;
    }


  if (GET_RACE_ALIGN(newmgroupee) != GET_RACE_ALIGN(ch))
    {/*cant enrol someone of the other race align*/
      act("You can't enrol someone of that race align.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }

  if (!(IS_AFFECTED(newmgroupee, AFF_GROUP)))
    {/*check to see if in a normal group*/
      send_to_char("He is not even in a group!\r\n", ch);
      return;
    }
  if ((newmgroupee->groupees == NULL))
    {/*check to see if in a normal group*/
      send_to_char("He is not a group leader!\r\n", ch);
      return;
    }

  if ((newmgroupee->groupmaster))/*you must also be head of a group*/
    {
      if (ch != newmgroupee)
	{
	  act("You can not enroll a &0&1major group&0 member unless he the head of a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }

  if (newmgroupee == ch)
    {
      if ((IS_AFFECTED2(ch, AFF2_MGROUP)))
	{
	  /*remove character then*/
	  die_mgroupee(ch);
	  send_to_char("&0&1You remove yourself from the major group&0\r\n", ch);
	  return;
	}
    }

  if (ch->groupmaster)/*you must also be head of a group*/
    {
      act("You can not enroll a group member unless you are head of a &0&1major&0 group.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if (ch->mgroupmaster) /*cant enrol a group member if you are in a group!! and not boss*/
    {
      act("You can not enroll &0&1major&0 group members without being head of a &1major&0 group.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if ((newmgroupee->mgroupmaster) && (newmgroupee->mgroupmaster != ch))/*if person inanother group inform him*/
    {
      act("&0That person is already in a &1major&0 group.&0",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if (newmgroupee->mgroupees)
    {
      act("&0That person is leading a differnt &1major&0 group.&0",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;

    }

  if (ch->mgroupmaster == newmgroupee)
    {
      act("&0You cant group your own &1major&0 group master.&0", FALSE, ch, 0, newmgroupee, TO_CHAR);
      return;
    }


  if (newmgroupee->mgroupmaster == ch)
    {/*remove him from group then*/
      act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0",
	  FALSE, ch, 0, newmgroupee, TO_CHAR);
      act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, ch,
	  0, newmgroupee, TO_VICT);
      act("&0&1$N has been kicked out of $n's &0&1&bmajor&0 group.&0", FALSE, ch, 0,
	  newmgroupee, TO_NOTVICT);
      stop_mgroupee(newmgroupee, 0);
      return;
    }

  if ((CONSENT(newmgroupee) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
    {
      send_to_char("You do not have his consent.\r\n", ch);
      return;
    }
  SET_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
  add_mgroupee(newmgroupee, ch, 0);/*adds flag*/

}

ACMD(do_consent)
{
  struct char_data *target;
  one_argument(argument, buf);
  if (!*buf)
    {
      if (!CONSENT(ch))
	{
	  send_to_char("Consent?? you are not consented to anyone!\r\n", ch);
	  return;
	}
      else
	{
	  if (CAN_SEE(ch, CONSENT(ch)))
	    {
	      act("&0&7&b$n has revoked $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT);
	    }
	  send_to_char("&0&7&bYou revoke your consent.&0\r\n", ch);
	  CONSENT(ch) = NULL;
	  return;
	}
    }

  if (!(target = get_char_vis(ch, buf)))
    {
      send_to_char(NOPERSON, ch);
      return;
    }
  if (GET_LEVEL(ch) < LVL_IMMORT)
    if (GET_RACE_ALIGN(target) != GET_RACE_ALIGN(ch))
      {/*cant enrol someone of the other race align*/
	send_to_char(NOPERSON, ch);
	return;
      }

  if (target == ch)
    {
      send_to_char("Consent yourself?? Rolf I don't think so.\r\n", ch);
      return;
    }
  /*ok concent this person*/
  if ((!CONSENT(ch)))
    {
      CONSENT(ch) = target;
      if (CONSENT(ch) == target)
	{
	  act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
	  act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT);
	}
      else
	send_to_char("You may not consent that person.\r\n", ch);
    }
  else
    {
      act("&0&7&b$n has removed $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT);
      CONSENT(ch) = target;
      if (CONSENT(ch) == target)
	{
	  act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
	  act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT);
	}
      else
	send_to_char("You may not consent that person.\r\n", ch);
    }

}

/*bandage code written by Proky pretty straight forward*/
ACMD(do_bandage)
{
  struct char_data *victim;
  int percent, heal, diff;
  one_argument(argument, buf);
  if (!(*buf))
    {/*look for first person in room*/
      /*   for (victim = world[ch->in_room].people; victim; victim =
	   victim->next_in_room)
	   {
	   if (CAN_SEE(ch, victim))
	   if ((GET_HIT(victim) < GET_MAX_HIT(victim)) && (GET_POS(victim) <= POS_STUNNED))
	   {
	   break;
	   vict = TRUE;
	   }
	   }

	   if (!vict)
	   {
	   send_to_char("No-one here looking to sick\r\n", ch);
	   return;
	   }*/
      send_to_char("You must supply a name!!\r\n", ch);
      return;
    }
  if (!(victim = get_char_room_vis(ch, buf)))
    {
      send_to_char(NOPERSON, ch);
      return;
    }
  if ((GET_HIT(victim) >= 0) && (GET_POS(victim) >= POS_STUNNED))
    {
      act("&0&8$N looks in pretty good shape already!.&0", FALSE, ch, 0, victim, TO_CHAR);
      return;
    }
  percent = number(1, 80);
  diff = GET_SKILL(ch, SKILL_BANDAGE);
  if (diff <= 10)
    heal = 1;
  else if (diff <= 80)
    heal = 2;
  else
    heal = 3;
  if (diff > percent)
    {
      alter_hit(victim, (0 - heal), 1);
      act("&0&8You bandage $N.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&8$n&0&8 bandages $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    }
  else
    {
      alter_hit(victim, 1, 1);
      act("You fail to bandage $N properly.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&8$n fails an attempt to bandage $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    }
  update_pos(victim);
}


ACMD(do_group)
{
  struct char_data *newgroupee = NULL;
  void stop_groupee(struct char_data *ch, bool hide);
  void add_groupee(struct char_data *ch, struct char_data *leader, bool noisy);
  void die_groupee(struct char_data * ch);
  bool all = 0;
  int found = 0;
  struct follow_type *f;
  one_argument(argument, buf);


  if (*buf) /*(argument with it)*/
    {
      /*check for all command*/
      if (!str_cmp("all", buf))
	{
	  all = 1;
	}
      else if (!(newgroupee = get_char_room_vis(ch, buf)))
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/

    }
  else
    {
      if (!*buf)
	{
	  print_group(ch);
	  return;
	}
    }


  if (ch->groupmaster) /*cant enrol a group member if you are in a group!! and not boss*/
    {
      if (ch != newgroupee)
	{
	  act("You can not enroll group members without being head of a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if (all)
    {
      for (found = 0, f = ch->followers; f; f = f->next)
	{
	  if ((f->follower->groupmaster) && (f->follower->groupmaster != ch))
	    continue;
	  if ((!f->follower->groupmaster) && (IS_AFFECTED(f->follower, AFF_GROUP)))
	    continue;
	  if (IS_AFFECTED(f->follower, AFF_GROUP))
	    continue;
	  if (((GET_RACE_ALIGN(f->follower) != GET_RACE_ALIGN(ch))) && (!IS_NPC(f->follower)))
	    continue;
	  if ((CONSENT(f->follower) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
	    if (!(IS_NPC(f->follower) && (f->follower->master == ch)))
	      continue;
	  add_groupee(f->follower, ch, 1);
	  found++;
	}
      if (!found){
	send_to_char("Everyone following you is already in your group.\r\n", ch);
      }
      else
	SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
      return;
    }

  if ((ch == newgroupee) && (!(IS_AFFECTED(ch, AFF_GROUP))))
    {
      send_to_char("You are not a member of a group!\r\n", ch);
      return;
    }

  if ((GET_RACE_ALIGN(newgroupee) != GET_RACE_ALIGN(ch)) && (GET_LEVEL(ch) < LVL_IMMORT))
    {/*cant enrol someone of the other race align*/
      act("You can't enrol someone of that race align.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if ((newgroupee->groupmaster) && (newgroupee->groupmaster != ch))/*if person inanother group inform him*/
    {
      if (ch != newgroupee)
	{
	  act("That person is already in a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if ((!newgroupee->groupmaster) && (IS_AFFECTED(newgroupee, AFF_GROUP)))
    {
      if (ch != newgroupee)
	{
	  act("That person is leading a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if (ch->groupmaster == newgroupee)
    {
      act("You cant group your own group master.", FALSE, ch, 0, newgroupee, TO_CHAR);
      return;
    }

  if (ch == newgroupee)
    {
      die_groupee(ch);
      send_to_char("&0&2&bYou remove yourself from the group.&0\r\n", ch);
      return;
    }
  /*remove yourself from group*/

  /*last chance removeal of grouping people who are already in a group*/


  if (newgroupee->groupmaster == ch)
    {/*remove him from group then*/
      act("&0&2&b$N is no longer a member of your group.&0", FALSE, ch, 0,
	  newgroupee, TO_CHAR);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch, 0,
	  newgroupee, TO_VICT);
      act("&0&2&b$N has been kicked out of $n's group.&0", FALSE, ch, 0, newgroupee,
	  TO_NOTVICT);
      stop_groupee(newgroupee, 0);
      return;
    }

  /*handle followers that are npc's*/
  /*handle it within the concent handle*/


  if ((CONSENT(newgroupee) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
    {
      if (!(IS_NPC(newgroupee) && (newgroupee->master == ch)))/*created follower*/
	{
	  send_to_char("You do not have his consent.\r\n", ch);
	  return;
	}
    }
  if (IS_AFFECTED(newgroupee, AFF_GROUP))
    {
      send_to_char("That person is quite happy in his group.\r\n", ch);
      return;
    }
  SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
  add_groupee(newgroupee, ch, 1);/*adds flag*/

}

ACMD(do_grep)
{
  struct char_data *k = NULL;
  struct group_type *f;
  int perc = 100;
  if (!IS_AFFECTED(ch, AFF_GROUP))
	{
	  send_to_char("&0But you are not a member of any group!&0\r\n", ch);
	  return;
	}
  perc = (100*GET_HIT(ch)/GET_MAX_HIT(ch));
  sprintf(buf, "&0&2&b%s reports:&0 %s%s%d &0(%d) hits and %d (%d) movement points.&0\r\n",
	  GET_NAME(ch),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCNRM(ch,C_NRM) :
	   perc >= 70 ? CCBLD(ch,C_NRM) :
	   perc >= 45 ? CCNRM(ch,C_NRM) :
	   perc >= 20 ? CCNRM(ch,C_NRM) :
	   perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(k,C_NRM)),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCYEL(ch,C_NRM) :
	   perc >= 70 ? CCYEL(ch, C_NRM) :
	   perc >= 45 ? CCMAG(ch, C_NRM) :
	   perc >= 20 ? CCRED(ch, C_NRM) :
	   perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)), GET_HIT(ch), GET_MAX_HIT(ch),
	  GET_MOVE(ch), GET_MAX_MOVE(ch));
  CAP(buf);

  k = (ch->groupmaster ? ch->groupmaster : ch);

  for (f = k->groupees; f; f = f->next)
    {
      if ((IS_AFFECTED(f->groupee, AFF_GROUP)) && (ch != f->groupee))
	send_to_char(buf, f->groupee);
    }
  if (k != ch)
    send_to_char(buf, k);
  /*send to master*/
  sprintf(buf, "&0&2&bYou report:&0 %s%s%d &0(%d) hits and %d (%d) movement points.&0\r\n",
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCNRM(ch,C_NRM) :
	   perc >= 70 ? CCBLD(ch,C_NRM) :
	   perc >= 45 ? CCNRM(ch,C_NRM) :
	   perc >= 20 ? CCNRM(ch,C_NRM) :
	   perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(k,C_NRM)),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCYEL(ch,C_SPR) :
	   perc >= 70 ? CCYEL(ch, C_NRM) :
	   perc >= 45 ? CCMAG(ch, C_NRM) :
	   perc >= 20 ? CCRED(ch, C_NRM) :
	   perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)), GET_HIT(ch), GET_MAX_HIT(ch),
	  GET_MOVE(ch), GET_MAX_MOVE(ch));
  send_to_char(buf, ch);
}




ACMD(do_report)
{
  struct char_data *vict;

  one_argument(argument, arg);

  if (!*arg && !ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    { sprintf(buf, "%s says, 'I have %d (%d) hit and %d (%d) movement points",
	      GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
	      GET_MOVE(ch), GET_MAX_MOVE(ch));

    act(buf, FALSE, ch, 0, 0, TO_ROOM);}
  if (!*arg && PRF_FLAGGED(ch, PRF_NOREPEAT) && !ROOM_FLAGGED(ch->in_room,
							      ROOM_SOUNDPROOF)){
    send_to_char(OK, ch);}
  if (!*arg && !PRF_FLAGGED(ch, PRF_NOREPEAT) && !ROOM_FLAGGED(ch->in_room,
							       ROOM_SOUNDPROOF))
    { sprintf(buf, "You say, 'I have %d (%d) hit and %d (%d) movement points",
	      GET_HIT(ch), GET_MAX_HIT(ch),
	      GET_MOVE(ch), GET_MAX_MOVE(ch));

    act(buf, FALSE, ch, 0, 0, TO_CHAR);}

  if (!*arg && ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    {    send_to_char("The walls seem to absorb your words.\r\n", ch);
    }
  if (*arg){

    if (!(vict = get_char_vis(ch, arg))){
      send_to_char(NOPERSON, ch);}

    else if (ch == vict)
      send_to_char("Now that is just silly isn't it?\r\n", ch);
    else if (GET_RACE_ALIGN(ch) != GET_RACE_ALIGN(vict))
      send_to_char(NOPERSON, ch);
    else if (PRF_FLAGGED(ch, PRF_NOTELL))
      send_to_char("You can't report to other people while you have notell on.\r\n", ch);
    else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
      send_to_char("The walls seem to absorb your words.\r\n", ch);
    else if (!IS_NPC(vict) && !vict->desc)	/* linkless */
      act("No one here by that name.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if (PLR_FLAGGED(vict, PLR_WRITING))
      act("$E's writing a message right now; try again later.",
	  FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if (PRF_FLAGGED(vict, PRF_NOTELL) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
      act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if    ((GET_HIT(ch) > (GET_MAX_HIT(ch) * 0.2)) && !PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have %d (%d) hit and %d (%d) movement points.&0",
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, vict, 0, vict, TO_CHAR);


	sprintf(buf, "&0&b&8You tell $N, 'I have %d (%d) hit and %d (%d) movement points.&0",
		GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    else if    ((GET_HIT(ch) > (GET_MAX_HIT(ch) * 0.2)) && PRF_FLAGGED(ch,
								       PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have %d (%d) hit and %d (%d) movement points.&0",
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, vict, 0, vict, TO_CHAR);

	send_to_char(OK, ch);}

    else if    ((GET_HIT(ch) < (GET_MAX_HIT(ch) * 0.2)) && !PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, vict, 0, vict, TO_CHAR);


	sprintf(buf, "&0&b&8You tell $N, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    else if    ((GET_HIT(ch) < (GET_MAX_HIT(ch) * 0.2)) && PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));

	act(buf, FALSE, vict, 0, vict, TO_CHAR);

	send_to_char(OK, ch);}

  }
  return;
}


#define PLAT 0
#define GOLD 1
#define SILVER 2
#define COPPER 3

ACMD(do_split)
{
  int num, give, i;
  int amount = 0;
  struct char_data *k;
  struct group_type *f;
  int cash[4] = {0};
  int counter = 0;
  void split_coins(int coin_type, struct char_data *from, struct char_data *to, int give);
  if (IS_NPC(ch))
    return;
  if (!IS_AFFECTED(ch, AFF_GROUP))
    {
      send_to_char("&0But you are not a member of any group!&0\r\n", ch);
      return;
    }
  argument = one_argument(argument, arg);

  if (!*arg)
    {
      send_to_char("Split what?\r\n", ch);
      return;
    }


  if (is_number(arg))
    {
      amount = atoi(arg);
      while (is_number(arg))
	{
	  argument = one_argument(argument, arg);
	  if (!str_cmp("platinum", arg) || !str_cmp("p", arg))
	    cash[PLAT] = amount;
	  else if (!str_cmp("gold", arg) || !str_cmp("g", arg))
	    cash[GOLD] = amount;
	  else if (!str_cmp("silver", arg) || !str_cmp("s", arg))
	    cash[SILVER] = amount;
	  else if (!str_cmp("copper", arg) || !str_cmp("c", arg))
	    cash[COPPER] = amount;
	  else
	    {
	      send_to_char("That is not a coin type\r\n", ch);
	      return;
	    }
	  argument = one_argument(argument, arg);
	  if (!*arg)
	    break;
	  amount = atoi(arg);
	}
    }
  if ((cash[0] + cash[1] + cash[2] + cash[3]) <= 0)
    {
      send_to_char("No coins to split.\r\n", ch);
      return;
    }
  /*make sure he can afford it*/
  if ((cash[0] > GET_PLAT(ch)) || (cash[1] > GET_GOLD(ch)) || (cash[2] > GET_SILVER(ch)) || (cash[3] > GET_COPPER(ch)))
    {
      send_to_char("You can't afford that.\r\n", ch);
      return;
    }

  k = (ch->groupmaster ? ch->groupmaster : ch);

  counter = 1;
  for (f = k->groupees; f; f = f->next)
    if (CAN_SEE(ch, f->groupee))
      if (ch->in_room == f->groupee->in_room)
	counter++;
  act("&0&7&b$N splits some coins.&0", FALSE, ch, 0, ch, TO_ROOM);

  for (i = 0;i < 4; i++)
    {
      if (cash[i] >=1)
	{
	  give = 0;
	  num = 0;
	  num = cash[i] % counter;
	  give = (int)(cash[i]/counter);
	  for (f = k->groupees; f; f = f->next)
	    {
	      if ((IS_AFFECTED(f->groupee, AFF_GROUP)) && (ch != f->groupee))
		{
		  if (ch->in_room == f->groupee->in_room)
		    if (num > 0)
		      {/*give + leftover*/
			split_coins(i, ch, f->groupee, (give + 1));
		      }
		    else
		      {/*give*/
			split_coins(i, ch, f->groupee, give);
		      }
		  num--;
		}
	    }
	  if (k != ch)
	    split_coins(i, ch, k, give);
	}
    }
  send_to_char("&0&7&bYou split some coins with your group.&0\r\n", ch);
}


void split_coins(int coin_type, struct char_data *from, struct char_data *to, int give)
{
  switch (coin_type)
    {
    case PLAT:
      GET_PLAT(to) += (give);
      GET_PLAT(from) -= (give);
      sprintf(buf, "You recieve &b&6%d &0platinum coins.\r\n", give);
      break;
    case GOLD:
      GET_GOLD(to) += (give);
      GET_GOLD(from) -= (give);
      sprintf(buf, "You recieve &0&b&3%d &0gold coins.\r\n", give);
      break;
    case SILVER:
      GET_SILVER(to) += (give);
      GET_SILVER(from) -= (give);
      sprintf(buf, "You recieve %d silver coins.\r\n", give);
      break;
    case COPPER:
      GET_COPPER(to) += (give);
      GET_COPPER(from) -= (give);
      sprintf(buf, "You recieve &0&3%d &0copper coins.\r\n", give);
      break;
    default:
      mudlog("Error overflow in split cash.", NRM, LVL_GOD, FALSE);
      return;
    }
  send_to_char(buf, to);
}



ACMD(do_use)
{
  struct obj_data *mag_item;
  int equipped = 1;

  half_chop(argument, arg, buf);
  if (!*arg) {
    sprintf(buf2, "What do you want to %s?\r\n", CMD_NAME);
    send_to_char(buf2, ch);
    return;
  }
  mag_item = GET_EQ(ch, WEAR_HOLD);

  if (!mag_item || !isname(arg, mag_item->name)) {
    switch (subcmd) {
    case SCMD_RECITE:
    case SCMD_QUAFF:
      equipped = 0;
      if (!(mag_item = get_obj_in_list_vis(ch, arg, ch->carrying))) {
	sprintf(buf2, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf2, ch);
	return;
      }
      break;
    case SCMD_USE:
      sprintf(buf2, "You don't seem to be holding %s %s.\r\n", AN(arg), arg);
      send_to_char(buf2, ch);
      return;
      break;
    default:
      log("SYSERR: Unknown subcmd passed to do_use");
      return;
      break;
    }
  }
  switch (subcmd) {
  case SCMD_QUAFF:
    if (GET_OBJ_TYPE(mag_item) != ITEM_POTION) {
      send_to_char("You can only quaff potions.", ch);
      return;
    }
    break;
  case SCMD_RECITE:
    if (GET_OBJ_TYPE(mag_item) != ITEM_SCROLL) {
      send_to_char("You can only recite scrolls.", ch);
      return;
    }
    break;
  case SCMD_USE:
    if ((GET_OBJ_TYPE(mag_item) != ITEM_WAND) &&
	(GET_OBJ_TYPE(mag_item) != ITEM_STAFF)) {
      send_to_char("You can't seem to figure out how to use it.\r\n", ch);
      return;
    }
    break;
  }

  mag_objectmagic(ch, mag_item, buf);
}



ACMD(do_wimpy)
{
  int wimp_lev;

  one_argument(argument, arg);

  if (!*arg) {
    if (GET_WIMP_LEV(ch)) {
      sprintf(buf, "Your current wimp level is %d hit points.\r\n",
	      GET_WIMP_LEV(ch));
      send_to_char(buf, ch);
      return;
    } else {
      send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
      return;
    }
  }
  if (isdigit(*arg)) {
    if ((wimp_lev = atoi(arg))) {
      if (wimp_lev < 0)
	send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
      else if (wimp_lev > GET_MAX_HIT(ch))
	send_to_char("That doesn't make much sense, now does it?\r\n", ch);
      else if (wimp_lev > (GET_MAX_HIT(ch) >> 1))
	send_to_char("You can't set your wimp level above half your hit points.\r\n", ch);
      else {
	sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n",
		wimp_lev);
	send_to_char(buf, ch);
	GET_WIMP_LEV(ch) = wimp_lev;
      }
    } else {
      send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
      GET_WIMP_LEV(ch) = 0;
    }
  } else
    send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);

  return;

}


ACMD(do_display) {
  char arg[MAX_INPUT_LENGTH];
  int i, x;


  const char *def_prompts[][2] = {
    { "Stock Circle"		 , "&0%hhp %mmp %vmv>&0"
    },
    { "Colorized Standard Circle", "&1&b%h&0&1hp &5&b%m&0&5mp &2&b%v&0&2mv&0>"
    },
    { "Standard"		 , "&1&b%ph&0&1hp &6&b%pm&0&6mp &2&b%pv&0&2mv&0>"
    },
    { "Full Featured"		 ,
      "&6Opponent&0: &4&b%o &7&b/ &0&6Tank&0: &4&b%t%_&0&1%h&0(&1&b%H&0)"
      "hitp &6%m&0(&6&b%M&0)&7mana &2%v&0(&2&b%V&0)&7move&0>"
    },
    { "FULL Feature2" ,
      "&2&b<&0&2%hh&0(&2&b%HH&0) &1%MM &2%vv&0(&2&b%VV&0)&2&b>%_&0<%t&0>:<&0%o&0>"    },
    { "\n"                       , "\n"                                 }
  };

  one_argument(argument, arg);


  if (!arg || !*arg) {
    send_to_char("The following pre-set prompts are availible...\r\n", ch);
    for (i = 0; *def_prompts[i][0] != '\n'; i++) {
      sprintf(buf, "  %d. %-25s  %s\r\n", i, def_prompts[i][0], def_prompts[i][1]);
      strip_ansi(buf);
      send_to_char(buf, ch);
    }
    send_to_char("Usage: display <number>\r\n"
		 "To create your own prompt, use _prompt <str>_.\r\n", ch);
    return;
  } else if (!isdigit(*arg)) {
    send_to_char("Usage: display <number>\r\n", ch);
    send_to_char("Type _display_ without arguments for a list of preset prompts.\r\n", ch);
    return;
  }

  i = atoi(arg);

  if (i < 0) {
    send_to_char("The number cannot be negative.\r\n", ch);
    return;
  }

  for (x = 0; *def_prompts[x][0] != '\n'; x++);

  if (i >= x) {
    sprintf(buf, "The range for the prompt number is 0-%d.\r\n", x);
    send_to_char(buf, ch);
    return;
  }

  if (GET_PROMPT(ch))
    free(GET_PROMPT(ch));
  GET_PROMPT(ch) = str_dup(def_prompts[i][1]);

  sprintf(buf, "Set your prompt to the %s preset prompt.\r\n", def_prompts[i][0]);
  send_to_char(buf, ch);
}


ACMD(do_prompt) {
  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "Your prompt is currently: %s\r\n",
	    (GET_PROMPT(ch) ? strip_ansi(GET_PROMPT(ch)) : "n/a"));
    send_to_char(buf, ch);
    return;
  }

  delete_doubledollar(argument);

  if (GET_PROMPT(ch))
    free(GET_PROMPT(ch));
  GET_PROMPT(ch) = str_dup(argument);

  sprintf(buf, "Okay, set your prompt to: %s\r\n", GET_PROMPT(ch));
  send_to_char(buf, ch);
}


ACMD(do_gen_write)
{
  FILE *fl;
  char *tmp, *filename, buf[MAX_STRING_LENGTH];
  struct stat fbuf;
  extern int max_filesize;
  time_t ct;

  switch (subcmd) {
  case SCMD_BUG:
    filename = BUG_FILE;
    break;
  case SCMD_TYPO:
    filename = TYPO_FILE;
    break;
  case SCMD_IDEA:
    filename = IDEA_FILE;
    break;
  default:
    return;
  }

  ct = time(0);
  tmp = asctime(localtime(&ct));

  if (IS_NPC(ch)) {
    send_to_char("Monsters can't have ideas - Go away.\r\n", ch);
    return;
  }

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument) {
    send_to_char("That must be a mistake...\r\n", ch);
    return;
  }
  sprintf(buf, "%s %s: %s", GET_NAME(ch), CMD_NAME, argument);
  mudlog(buf, CMP, LVL_IMMORT, FALSE);

  if (stat(filename, &fbuf) < 0) {
    perror("Error statting file");
    return;
  }
  if (fbuf.st_size >= max_filesize) {
    send_to_char("Sorry, the file is full right now.. try again later.\r\n", ch);
    return;
  }
  if (!(fl = fopen(filename, "a"))) {
    perror("do_gen_write");
    send_to_char("Could not open the file.  Sorry.\r\n", ch);
    return;
  }
  fprintf(fl, "%-8s (%6.6s) [%5d] %s\n", GET_NAME(ch), (tmp + 4),
	  world[ch->in_room].number, argument);
  fclose(fl);
  send_to_char("Okay.  Thanks!\r\n", ch);
}


#define TOG_OFF 0
#define TOG_ON  1

#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))


ACMD(do_toggle)
{
  int l, i;
  int wimp_lev,page_length;
  long result = 0;
  extern int nameserver_is_slow;
  char field[MAX_INPUT_LENGTH];
  struct set_struct
  {
    char *cmd;
    char level;
    int bitvector;
  }
  fields[] = {
                /*00*/	{ "nosummon",		0,		PRF_SUMMONABLE},
		/*01*/	{ "nohassle", 	LVL_IMMORT, PRF_NOHASSLE},
		/*02*/	{ "brief",		0,			PRF_BRIEF},
		/*03*/	{ "compact", 	0,			PRF_COMPACT},
		/*04*/	{ "tell",		0,			PRF_NOTELL},
		/*05*/	{ "noauction", 	0,			PRF_NOAUCT},
		/*06*/	{ "noshout",	0,			PRF_DEAF},
		/*07*/	{ "nogossip", 	0,			PRF_NOGOSS},
		/*08*/	{ "nocongratz",	0,			PRF_NOGRATZ},
		/*09*/	{ "nowiz",	 	0,			PRF_NOWIZ},
		/*10*/	{ "quest", 		0,			PRF_QUEST},
		/*11*/	{ "room",		LVL_IMMORT,	PRF_ROOMFLAGS},
		/*12*/	{ "norepeat", 	0,			PRF_NOREPEAT},
		/*13*/	{ "holylight",	LVL_IMMORT,	PRF_HOLYLIGHT},
		/*14*/	{ "slowns", 	LVL_GRGOD,	0},
		/*15*/	{ "autoexit",	LVL_IMMORT, PRF_AUTOEXIT},
		/*16*/	{ "nopeti", 	LVL_IMMORT, PRF_NOPETI},
		/*17*/	{ "noname",		LVL_IMMORT, PRF_NONAME},
		/*18*/	{ "anon", 		10,			PRF_ANON},
                /*19*/	{ "showvnums",	LVL_IMMORT, PRF_SHOWVNUMS},
                /*20*/  { "wimpy",		0,			0},
                /*21*/  { "nicearea",	0,			PRF_NICEAREA},
                /*22*/  { "vicious",    0, PRF_VICIOUS},
                /*23*/  { "passive",    0, PRF_PASSIVE},
                /*24*/  { "pagelength", 0, 0},
                /*n*/	{ "\n",			0,			0}
  };
  char *tog_messages[][2] =
  {
    /*   {"You are now safe from summoning by other players.\r\n",
	 "You may now be summoned by other players.\r\n"}, */
    /*00*/	{".\r\n",
		 ".\r\n"},
		/*01*/   {"Nohassle disabled, mobs will attack you now.\r\n",
			  "Nohassle enabled, mobs will leave you alone now.\r\n"},
		/*02*/	{"Brief mode off.\r\n",
			 "Brief mode on.\r\n"},
		/*03*/	{"Compact mode off.\r\n",
			 "Compact mode on.\r\n"},
		/*04*/	{"You can now hear tells.\r\n",
			 "You are now deaf to tells.\r\n"},
		/*05*/	{"You can now hear auctions.\r\n",
			 "You are now deaf to auctions.\r\n"},
		/*06*/	{"You can now hear shouts.\r\n",
			 "You are now deaf to shouts.\r\n"},
		/*07*/	{"You can now hear gossip.\r\n",
			 "You are now deaf to gossip.\r\n"},
		/*08*/	{"You can now hear the congratulation messages.\r\n",
			 "You are now deaf to the congratulation messages.\r\n"},
		/*09*/	{"You can now hear the Wiz-channel.\r\n",
			 "You are now deaf to the Wiz-channel.\r\n"},
		/*10*/	{"You are no longer part of the Quest.\r\n",
			 "Okay, you are part of the Quest!\r\n"},
		/*11*/	{"You will no longer see the room flags.\r\n",
			 "You will now see the room flags.\r\n"},
		/*12*/	{"You will now have your communication repeated.\r\n",
			 "You will no longer have your communication repeated.\r\n"},
		/*13*/	{"HolyLight mode off.\r\n",
			 "HolyLight mode on.\r\n"},
		/*14*/	{"Nameserver_is_slow changed to NO; IP addresses will now be resolved.\r\n",
			 "Nameserver_is_slow changed to YES; sitenames will no longer be resolved.\r\n"},
		/*15*/	{"Autoexits disabled.\r\n",
			 "Autoexits enabled.\r\n"},
		/*16*/	{"You will now receive petitions from mortals!\r\n",
			 "You are now deaf to petitions!\r\n"},
		/*17*/	{"Mortals now see your name!\r\n",
			 "Mortals can no longer see your name!\r\n"},
		/*18*/  {"You are no longer Anonymous\r\n",
			 "You are now Anonymous\r\n"},
		/*19*/  {"You will no longer see vnums.\r\n",
			 "You will now see vnums.\r\n"},
		/*20*/  {"",
			 ""},
		/*21*/  {"Your area spells will now hit your race align in towns.\r\n",
			 "Your area spells won't hit your race align in towns.\r\n"},
		/*22*/  {"You feel nice and no longer vicious.\r\n",
			 "You will now kill mortally wounded victims.\r\n"},
		/*23*/  {"You will now auto-engage upon being offensively cast upon.\r\n",
			 "You will no longer auto-engage upon being offensively cast upon.\r\n"}
		,
		/*24*/  {"",
			 ""}};

  argument = one_argument(argument, field);



  if (!*field)
    {/*show player his fields*/
      send_to_char("Usage: tog <value>\r\n", ch);
      send_to_char("      &u&6Toggle&0				 &u&6Setting&0\r\n", ch);
      for (i = 0; *(fields[i].cmd) != '\n'; i++)
	if (fields[i].level < GET_LEVEL(ch))
	  {/*here if person has access to toggle*/
	    if (i == SCMD_WIMPY)
	      sprintf(buf, "     %s%s%-15s			%5s&0\r\n", ((GET_WIMP_LEV(ch)) ? QBLD : QNRM), QBLU, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
	    else if (i == SCMD_SLOWNS)
	      sprintf(buf, "     %s%s%-15s			%5s&0\r\n", ((nameserver_is_slow) ? QBLD : QNRM), QBLU, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
	    else
	      sprintf(buf, "     %s%s%-15s			%5s\r\n", (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QBLU, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	    send_to_char(buf, ch);
	  }
      return;
    }
  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;
  if (GET_LEVEL(ch) < fields[l].level)
    {
      send_to_char("You are not high enough level for that!\r\n", ch);
      return;
    }
  strcpy(buf, "Okay.");  /* can't use OK macro here 'cause of \r\n */

  if (IS_NPC(ch))
    return;

  switch (l)
    {
    case SCMD_NOSUMMON:
      send_to_char("Rolf, sorry no twink mud here hehe .. tog summon off rolf.\r\n", ch);
      break;
    case SCMD_SHOWVNUMS:
      result = PRF_TOG_CHK(ch, PRF_SHOWVNUMS);
      break;
    case SCMD_NOHASSLE:
      result = PRF_TOG_CHK(ch, PRF_NOHASSLE);
      break;
    case SCMD_BRIEF:
      result = PRF_TOG_CHK(ch, PRF_BRIEF);
      break;
    case SCMD_COMPACT:
      result = PRF_TOG_CHK(ch, PRF_COMPACT);
      break;
    case SCMD_NOTELL:
      result = PRF_TOG_CHK(ch, PRF_NOTELL);
      break;
    case SCMD_NOAUCTION:
      result = PRF_TOG_CHK(ch, PRF_NOAUCT);
      break;
    case SCMD_DEAF:
      result = PRF_TOG_CHK(ch, PRF_DEAF);
      break;
    case SCMD_NOGOSSIP:
      result = PRF_TOG_CHK(ch, PRF_NOGOSS);
      break;
    case SCMD_NOGRATZ:
      result = PRF_TOG_CHK(ch, PRF_NOGRATZ);
      break;
    case SCMD_NOWIZ:
      result = PRF_TOG_CHK(ch, PRF_NOWIZ);
      break;
    case SCMD_QUEST:
      result = PRF_TOG_CHK(ch, PRF_QUEST);
      break;
    case SCMD_ROOMFLAGS:
      result = PRF_TOG_CHK(ch, PRF_ROOMFLAGS);
      break;
    case SCMD_NOREPEAT:
      result = PRF_TOG_CHK(ch, PRF_NOREPEAT);
      break;
    case SCMD_HOLYLIGHT:
      result = PRF_TOG_CHK(ch, PRF_HOLYLIGHT);
      break;
    case SCMD_SLOWNS:
      result = (nameserver_is_slow = !nameserver_is_slow);
      break;
    case SCMD_AUTOEXIT:
      result = PRF_TOG_CHK(ch, PRF_AUTOEXIT);
      break;
    case SCMD_NOPETI:
      result = PRF_TOG_CHK(ch, PRF_NOPETI);
      break;
    case SCMD_NONAME:
      result = PRF_TOG_CHK(ch, PRF_NONAME);
      break;
    case SCMD_ANON:
      result = PRF_TOG_CHK(ch, PRF_ANON);
      break;
    case SCMD_WIMPY:

      one_argument(argument, arg);

      if (!*arg)
	{
	  if (GET_WIMP_LEV(ch))
	    {
	      sprintf(buf, "Your current wimp level is %d hit points.\r\n", GET_WIMP_LEV(ch));
	      send_to_char(buf, ch);
	      return;
	    }
	  else
	    {
	      send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
	      return;
	    }
	}
      if (isdigit(*arg))
	{
	  if ((wimp_lev = atoi(arg)))
	    {
	      if (wimp_lev < 0)
		send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
	      else if (wimp_lev > GET_MAX_HIT(ch))
		send_to_char("That doesn't make much sense, now does it?\r\n", ch);
	      else
		{
		  sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n", wimp_lev);
		  send_to_char(buf, ch);
		  GET_WIMP_LEV(ch) = wimp_lev;
		}
	    }
	  else
	    {
	      send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
	      GET_WIMP_LEV(ch) = 0;
	    }
	}
      else
	send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);
      break;
    case SCMD_NICEAREA:
      result = PRF_TOG_CHK(ch, PRF_NICEAREA);
      break;
    case SCMD_VICIOUS:
      result = PRF_TOG_CHK(ch, PRF_VICIOUS);
      break;
    case SCMD_PASSIVE:
      result = PRF_TOG_CHK(ch, PRF_PASSIVE);
      break;
    case SCMD_PAGELENGTH:

      one_argument(argument, arg);

      if (!*arg)
	{
	  if (ch->page_length)
	    {
	      sprintf(buf, "Your current page length is %d.\r\n", (ch->page_length));
	      send_to_char(buf, ch);
	      return;
	    }
	  else
	    {
	      send_to_char("You page length is not valid. Tell a god.\r\n", ch);
	      return;
	    }
	}
      if (isdigit(*arg))
	{
	  if ((page_length = atoi(arg)))
	    {
	      if (page_length < 1)
		send_to_char("Invalid page length.\r\n", ch);
	      else if (page_length > 50)
		send_to_char("Max page length is 50 right now.\r\n", ch);
	      else
		{
		  sprintf(buf, "Your new page length is %d lines.\r\n", page_length);
		  send_to_char(buf, ch);
		  ch->page_length = page_length;
		}
	    }
	  else
	    {
	      send_to_char("Page length restored to default (22 lines)\r\n", ch);
	      ch->page_length = 22;
	    }
	}
      else
	send_to_char("Specify at how many lines you want your page length to be.  (0 for default length)\r\n", ch);
      break;
    default:
      log("SYSERR: Unknown subcmd in do_gen_toggle");
      return;
      break;
    }

  if (result)
    send_to_char(tog_messages[l][TOG_ON], ch);
  else
    send_to_char(tog_messages[l][TOG_OFF], ch);
}

ACMD(do_peace)
{
  struct char_data *vict, *next_v;
  one_argument(argument, arg);
  if (!is_abbrev(arg, "off")) {
    act ("&7$n &4&bglows&0&7 with a &bbright white aura&0&7 as $e waves $s mighty hand!&0",
	 FALSE,ch,0,0,TO_ROOM);
    send_to_room("&7&bA peaceful feeling washes into the room, dousing all violence!&0\r\n",ch->in_room);
    for(vict=world[ch->in_room].people;vict;vict=next_v)
      {
	next_v=vict->next_in_room;
	if(FIGHTING(vict)) {
	  stop_fighting(vict);
	}
	/*REMOVE_BIT(MOB_FLAGS(vict), MOB_AGGRESSIVE);*/
      }
    SET_BIT(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
  }
  else {
    act ("&7$n &4&bglows&0&7 with a &1&bbright red aura&0&7 as $e waves $s mighty hand!&0",
	 FALSE,ch,0,0,TO_ROOM);
    send_to_room("&1&bThe peaceful feeling in the room subsides... You don't feel quite as safe anymore.&0\r\n",ch->in_room);
    REMOVE_BIT(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
  }
}

ACMD(do_petition) {

  struct char_data *i;
  extern struct char_data *character_list;

  skip_spaces(&argument);
  if (GET_LEVEL(ch) >= LVL_IMMORT)
    {send_to_char("Petition is for those wimpy mortals!\r\n", ch);
    return;
    }
  if (IS_NPC(ch)) {
    send_to_char("&0Mobs can't petition!!&0\r\n", ch);
    return;
  }
  if (!*argument){
    send_to_char("Yes, but WHAT do you want to petition?\r\n", ch);
  } else
    for (i = character_list;i; i = i->next){

      if(GET_LEVEL(i) >= LVL_IMMORT&&(!PRF_FLAGGED(i, PRF_NOPETI))){
	sprintf(buf, "&0&6%s&0&6 petitions, '&0&b&6%s&0&6'&0", GET_NAME(ch),
		argument);
	act(buf, FALSE, i, 0, i, TO_CHAR);
      }
    }{
    sprintf(buf, "&0&6You petition, '&0&b&6%s&0&6'&0", argument);
    send_to_char(buf, ch);
    return;
  }
}



// SUMMON_MOUNT

ACMD(do_summon_mount)
     // (struct char_data *ch, char *arg, int cmd)
{
  //  int sumtime;
  struct follow_type *fol;

  one_argument(argument, arg);

  if ((GET_CLASS(ch) != CLASS_PALADIN) && (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You have no idea what you are trying to accomplish.\r\n", ch);
    return;
  }

  for (fol = ch->followers; fol; fol = fol->next)
    if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
      send_to_char("You already have a mount!\r\n", ch);
      return;
    }
  if (GET_LEVEL(ch) < 25) {
    send_to_char("You are not yet deemed worthy of a mount (try gaining some more experience)\r\n", ch);
    return;
  }
  if (!IS_GOOD(ch) && !IS_NPC(ch) && (GET_CLASS(ch) == CLASS_PALADIN)) {
    send_to_char("Not even horses can stand your offensive presence!\r\n", ch);
    return;
  }
  if (!OUTSIDE(ch)) {
    send_to_char("Try again, OUTDOORS THIS TIME!\r\n", ch);
    return;
  }
  if (ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]) {
    send_to_char("You may only summon one mount per week!\r\n", ch);
    return;
  }
  ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT] = (7 * SECS_PER_MUD_DAY) * PASSES_PER_SEC;
  send_to_char("You begin calling for a mount..\r\n", ch);
  mount_summoning_thing(ch);
}


void
mount_summoning_thing(struct char_data *ch)
{
  struct char_data *mount = NULL;
  int factor, mob_num = 0;
  struct follow_type *fol;

  if (!ch || (ch->in_room == NOWHERE))	/* They died in the meantime. Events should have been pulled
					   for them, but why trust that */
    return;

  if (!OUTSIDE(ch)) {
    send_to_char("Try again, OUTDOORS THIS TIME!\r\n", ch);
    return;
  }
  if (!IS_GOOD(ch) && !IS_NPC(ch) && (GET_CLASS(ch) == CLASS_PALADIN)) {
    send_to_char("Not even horses can stand your offensive presence!\r\n", ch);
    return;
  }
  for (fol = ch->followers; fol; fol = fol->next)
    if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
      send_to_char("You already have a mount!\r\n", ch);
      return;
    }

  switch((int)GET_CLASS(ch))
    {
    case CLASS_PALADIN:
      mob_num = 45;
      break;
    case CLASS_ANTI_PALADIN:
      mob_num = 46;
      break;
    }
  mount = read_mobile(mob_num, VIRTUAL);

  if (!mount) {
    send_to_char("No mount could be found, please report this to a god.\r\n", ch);
    return;
  }

  char_to_room(mount, ch->in_room); // was -2

  act("$N answers your summons!", TRUE, ch, 0, mount, TO_CHAR);
  act("$N walks in, seemingly from nowhere, and nuzzles $n's face.", TRUE, ch, 0, mount, TO_ROOM);
  SET_BIT(AFF_FLAGS(mount), AFF_CHARM);
  SET_BIT(AFF_FLAGS(mount), AFF_TAMED);
  add_follower(mount, ch);

  /* now we modify the base mount, based on paladin's level and alignment */

  /* factor ranges from 0 to 25 (unlucky 351 align level 15 to lucky 1000 align level 50) */
  factor = BOUNDED(0, (GET_LEVEL(ch) - 18 + abs((GET_ALIGNMENT(ch) / 200)) + dice(2, 7)) / 2, 25);

  GET_LEVEL(mount) += factor;
  GET_MAX_HIT(mount) += (factor * 10);
  GET_HIT(mount) += (factor * 10);
  GET_MOVE(mount) += (int) (factor * 1.5);
}

// end SUMMON_MOUNT

// LAY_HANDS

ACMD(do_layhand)
     // (struct char_data *ch, char *argument, int cmd)
{
  int healing;
  struct char_data *vict = NULL;
  char Gbuf1[MAX_STRING_LENGTH];

  one_argument(argument, arg);

  if (IS_NPC(ch)) {
    send_to_char("You can't layhands!\n\r", ch);
    return;
  }
  if ((GET_CLASS(ch) != CLASS_PALADIN) &&(GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You don't have the ability to layhands.\n\r", ch);
    return;
  }

  if(!(*argument))
    {
      vict = ch;
    }

  one_argument(argument, Gbuf1);

  if (*Gbuf1) {
    if (!(vict = get_char_room_vis(ch, Gbuf1))) {
      send_to_char("I see no one by that name here!\n\r", ch);
      return;
    }
  }

  if (ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS])
    {
      send_to_char("You need some more rest before laying hand.\n\r", ch);
      return;
    }

  switch((int)GET_CLASS(ch))
    {
    case CLASS_PALADIN:
      if (ch->char_specials.fighting && (vict != ch)) {
	send_to_char("You can't layhands on others while fighting.\n\r", ch);
	return;
      }

      if (GET_HIT(vict) >= GET_MAX_HIT(vict)) {
	if (ch != vict) {
	  act("$N is not in need of your healing.", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n looks like $e's groping $N, then flushes bright red.", FALSE, ch, 0, vict, TO_NOTVICT);
	  act("$n fumbles with your clothes for a moment, then flushes bright red.",
	      FALSE, ch, 0, vict, TO_VICT);
	} else {
	  send_to_char("You look perfectly fine to me!\r\n", ch);
	}
	return;
      }
      if (ch != vict) {
	act("Your hands glow as you lay them on $N.", FALSE, ch, 0, vict, TO_CHAR);
	act("$n's hands glow as $e lays them on you.", FALSE, ch, 0, vict, TO_VICT);
	act("$n's hands glow as $e lays them on $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	send_to_char("You feel better!\n\r", vict);
      } else {
	act("Your hands glow as you layhands on yourself.", FALSE, ch, 0, 0, TO_CHAR);
	act("$n's hands glow as $e lays them on $s wounds.", FALSE, ch, 0, 0, TO_ROOM);
      }

      healing = MAX(0, MIN(GET_LEVEL(ch) * 20, GET_MAX_HIT(vict) - GET_HIT(vict)));

      if (IS_EVIL(vict)) {
	/* it works, sorta, but... */
	healing = MIN(healing, GET_HIT(ch) + 11);
	send_to_char("Your selfless act has it's price!\r\n", ch);
	act("As $N's wounds close, identical wounds appear on $n!", FALSE, ch, 0, vict, TO_ROOM);
	GET_HIT(ch) -= healing;  /* can kill paladin */
	alter_hit(ch, healing, 2);
	GET_ALIGNMENT(ch) = BOUNDED(-1000, GET_ALIGNMENT(ch) - 10, 1000);
	ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS] = (SECS_PER_MUD_DAY) * PASSES_PER_SEC;

	update_pos(ch);
      }
      /* Always use alter_hit ...Banyal*/
      alter_hit(vict, (-1 * healing), 1);
      /*  GET_HIT(vict) += healing;*/

      break;

    case CLASS_ANTI_PALADIN:
      if (!ch->char_specials.fighting && (vict != ch)) {
	send_to_char("You can layhands on others only while fighting.\n\r", ch);
	return;
      }

      if (IS_GOOD(vict))
	{
	  act("Your hands glow as you lay them on $N.", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n's hands glow as $e lays them on you.", FALSE, ch, 0, vict, TO_VICT);
	  act("$n's hands glow as $e lays them on $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	  send_to_char("You feel your life forces being drained!\n\r", vict);

	  /* this was * 20 dude this was way over powered a level 15 anti killed a 53
	     warrior with it Banyal*/
	  /* how is there a level 15 anti? it should do at LEAST the paladins hit points
	   * i'll compromise at * 10, and made it so it takes anti hits or lev*10,
	   * whichever is more.
	   */
/* Was _MY_ level 15 anti for test please        do not change again this is
being ABUSED so VERY badLY!!!!!!!!!!! _BANYAL_*/
    /* This is not board DnD you mustlook at abuse and layhands does not have tobe
atelats guys hitpoints a 50 anti with vit and eq can do 1000 damage
DUh I dont think so-Banyal */
	//  healing = MAX(0, MAX(GET_LEVEL(ch) * 10, GET_HIT(ch)));
           healing = BOUNDED(75, GET_HIT(ch) / 3, 200);
	  ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS] = (SECS_PER_MUD_DAY) * PASSES_PER_SEC;

	  /*always use alter_hit Banyal*/
	  alter_hit(vict, healing, 2);
	  /* GET_HIT(vict) -= healing; */
	}
      else
	send_to_char("Your evil only affects good...\r\n", ch);
      break;
    }
  update_pos(vict);
}
// end LAY_HANDS

// FIRST_AID

ACMD(do_first_aid)
     // (struct char_data *ch, char *arg, int cmd)
{
  int skl_lvl = 0;

  one_argument(argument, arg);

  if (IS_NPC(ch))
    return;

  skl_lvl = GET_SKILL(ch, SKILL_FIRST_AID);

  if (ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]) {
    send_to_char("You can only do this once per day..\n\r", ch);
    return;
  }

  send_to_char("You attempt to render first aid unto yourself..\n\r", ch);

  if ((number(1, 101) < skl_lvl) && (GET_HIT(ch) < GET_MAX_HIT(ch))) {
    GET_HIT(ch) += dice(GET_LEVEL(ch), 5);
    if (GET_HIT(ch) > GET_MAX_HIT(ch))
      GET_HIT(ch) = GET_MAX_HIT(ch);
  }

  improve_skill(ch, SKILL_FIRST_AID);

  ch->char_specials.action_delays[ACT_DELAY_FIRST_AID] = (SECS_PER_MUD_DAY * PASSES_PER_SEC);
}
// end FIRST_AID

ACMD(do_ignore)
{
  struct char_data *target;
  char arg[MAX_STRING_LENGTH], buf[MAX_STRING_LENGTH];

  if (IS_NPC(ch))
    return;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("You feel sociable and stop ignoring anyone\r\n", ch);
    ch->player_specials->ignored = NULL;
    return;
  }
  if ((target = get_char_vis(ch, arg)) == NULL) {
    send_to_char("No one by that name here..\r\n", ch);
    return;
  }
  if (GET_LEVEL(target) > 70) {
    send_to_char("No one by that name here..\r\n", ch);
    return;
  }
  if (IS_NPC(target)) {
    send_to_char("No one by that name here..\r\n", ch);
    return;
  }
  if (ch->player_specials->ignored) {
    sprintf(buf, "You stop ignoring %s.\r\n", GET_NAME(ch->player_specials->ignored));
    send_to_char(buf, ch);
  }
  sprintf(buf, "You now ignore %s.\r\n", GET_NAME(target));
  send_to_char(buf, ch);
  ch->player_specials->ignored = target;
}
@


1.306
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: act.other.c,v 1.305 2011/03/16 13:39:58 myc Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: act.other.c                                    Part of FieryMUD *
 *  Usage: Miscellaneous player-level commands                             *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include <sys/stat.h>
#include <math.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "casting.h"
#include "screen.h"
#include "house.h"
#include "events.h"
#include "dg_scripts.h"
#include "quest.h"
#include "class.h"
#include "skills.h"
#include "cooldowns.h"
#include "races.h"
#include "clan.h"
#include "math.h"
#include "players.h"
#include "constants.h"
#include "chars.h"
#include "pfiles.h"
#include "magic.h"
#include "regen.h"
#include "fight.h"
#include "movement.h"
#include "limits.h"
#include "composition.h"
#include "lifeforce.h"
#include "specprocs.h"
#include "money.h"

/* extern variables */
extern int max_group_difference;
extern int damage_amounts;

int remove_var(struct trig_var_data **var_list, char *name);
EVENTFUNC(camp_event);
void rem_memming(struct char_data *ch);
void summon_mount(struct char_data *ch, int mob_vnum, int base_hp, int base_mv);
void appear(struct char_data * ch);
void check_new_surroundings(struct char_data *ch, bool old_room_was_dark, bool tx_obvious);
void get_check_money(struct char_data * ch, struct obj_data * obj);
int roll_skill(struct char_data *ch, int skill);

/* extern procedures */
SPECIAL(shop_keeper);

void appear(struct char_data *ch)
{
   bool was_hidden;

   active_effect_from_char(ch, SPELL_INVISIBLE);
   active_effect_from_char(ch, SPELL_NATURES_EMBRACE);

   was_hidden = IS_HIDDEN(ch);

   REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
   REMOVE_FLAG(EFF_FLAGS(ch), EFF_CAMOUFLAGED);
   GET_HIDDENNESS(ch) = 0;

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (was_hidden) {
         act("$n steps out of the shadows.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You step out of the shadows.\r\n", ch);
      } else {
         act("$n snaps into visibility.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You fade back into view.\r\n", ch);
      }
   } else
      act ("You feel a strange presence as $n appears, seemingly from nowhere.",
         FALSE, ch, 0, 0, TO_ROOM);
}



void stop_guarding(struct char_data *ch) {

  if (ch->guarding){
    act("You stop guarding $N.", FALSE, ch, 0, ch->guarding, TO_CHAR);
    if (ch->guarding->guarded_by == ch) {
      act("$n stops guarding you.", TRUE, ch, 0, ch->guarding, TO_VICT);
      ch->guarding->guarded_by = NULL;
    }
    ch->guarding = NULL;
  }
  if (ch->guarded_by)
    stop_guarding(ch->guarded_by);
}

ACMD(do_guard)
{
  struct char_data *vict;

  one_argument(argument, arg);

  if (!GET_SKILL(ch, SKILL_GUARD)) {
    send_to_char("You don't have the protective skill require to guard.\r\n",ch);
    return;
  }

  if (!*arg) {
    if (ch->guarding)
      act("You are guarding $N.", FALSE, ch, 0, ch->guarding, TO_CHAR);
    else
      send_to_char("You are not guarding anyone.\r\n", ch);
    return;
  }

  if (!str_cmp(arg, "off"))
    vict = ch;
  else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
    send_to_char("That person is not here.\r\n", ch);
    return;
  }

  if (ch == vict) {
    if (ch->guarding)
      stop_guarding(ch);
    else
      send_to_char("You are not guarding anyone.\r\n", ch);
    return;
  }

  if (vict->guarded_by) {
    if (vict->guarded_by == ch)
      send_to_char("You are already guarding that person.\r\n", ch);
    else
      send_to_char("Someone else is already guarding that person.\r\n", ch);
    return;
  }

  if (ch->guarding) {
    if (ch->guarding == vict) {
      send_to_char("You are already guarding that person.\r\n", ch);
      return;
    }
    else
      stop_guarding(ch);
  }
  act("You start guarding $N.", FALSE, ch, 0, vict, TO_CHAR);
  act("$n starts guarding you.", TRUE, ch, 0, vict, TO_VICT);
  act("$n lays a protective eye on $N, guarding $M.", TRUE, ch, 0, vict, TO_NOTVICT);
  ch->guarding = vict;
  vict->guarded_by = ch;
}

ACMD(do_subclass)
{
  int rem_spell(struct char_data *ch, int spell);
  int subclass, anyvalid;
  struct quest_list *quest = NULL;
  struct mem_list *memorized, *last_mem;
  float old_exp;
  char *s;
  struct classdef *c;

  /* Ew */
  if (IS_NPC(ch)) {
    send_to_char("NPCs don't subclass.  Ha.\r\n", ch);
    return;
  }

  c = &(classes[(int)GET_CLASS(ch)]);

  /* If not a base class, then bail */
  if (c->is_subclass) {
    send_to_char("You can only subclass once!\r\n", ch);
    return;
  }

  /* If below minimum quest level, bail */
  if (GET_LEVEL(ch) < 10) {
    send_to_char("You need to be level 10 before you can subclass!\r\n", ch);
    return;
  }

  /* If above maximum quest level, bail */
  if (GET_LEVEL(ch) > c->max_subclass_level) {
    sprintf(buf, "You can no longer subclass, because you are over level %d.\r\n",
          c->max_subclass_level);
    send_to_char(buf, ch);
    return;
  }

  /* Figure out whether the player is on a subclass quest */
  if (ch->quests) {
    quest = ch->quests;
    while (quest && !(quest->quest_id & SUBCLASS_BIT))
      quest = quest->next;
    /* quest should now point to the player's subclass quest, if it exists */
  }

  /* If not on subclass quest, show the list of possible subclasses */
  if (!quest) {
    anyvalid = 0;
    for (subclass = 0; subclass < NUM_CLASSES; subclass++) {
      if (classes[subclass].active && classes[subclass].is_subclass &&
            classes[subclass].subclass_of == GET_CLASS(ch) &&
            class_ok_race[(int)GET_RACE(ch)][subclass]) {
        sprintf(buf, "  %s\r\n", classes[subclass].fmtname);
        if (!anyvalid) {
          send_to_char("You may choose from the following classes for your race:\r\n", ch);
          anyvalid = 1;
        }
        send_to_char(buf, ch);
      }
    }

    if (anyvalid) {
      sprintf(buf, "You have until level %d to subclass. See HELP SUBCLASS_%s for "
              "more information.\r\n", c->max_subclass_level, c->name);
      /* Capitalize the "SUBCLASS_class" bit */
      for (s = buf + 43; *s && *s != ' '; s++)
         *s = toupper(*s);
      send_to_char(buf, ch);
    } else
      send_to_char("There are no subclasses available to you.\r\n", ch);
    return;
  }

  /* Now we know the player has started the subclass quest. */

  /* Make sure the class --> subclass change is possible */
  subclass = parse_class(0, 0,
        get_quest_variable(ch,
           all_quests[
              real_quest(quest->quest_id)
           ].quest_name, "subclass_name"));
  if (subclass == CLASS_UNDEFINED) {
    sprintf(buf, "%s finished subclass quest \"%s\" with unknown target subclass \"%s\"",
           GET_NAME(ch), all_quests[real_quest(quest->quest_id)].quest_name,
           get_quest_variable(ch, all_quests[real_quest(quest->quest_id)].quest_name,
              "subclass_name"));
    log("%s",buf);
    send_to_char("There is an error in your subclass quest.  Ask a god to reset it.\r\n", ch);
    return;
  }

  /* If it is completed, subclass them */
  if (quest->stage == QUEST_SUCCESS) {
    /* Leveled percentage */
    old_exp = GET_EXP(ch) / (double) exp_next_level(GET_LEVEL(ch), GET_CLASS(ch));

    /* Clear spells the new class doesn't have */
    memorized = GET_SPELL_MEM(ch).list_head;
    while (memorized) {
      last_mem = memorized;
      memorized = memorized->next;
      if (skills[last_mem->spell].min_level[subclass] > GET_LEVEL(ch))
        rem_spell(ch, last_mem->spell);
    }

    /* Change class and exp */
    GET_CLASS(ch) = subclass;
    GET_EXP(ch) = (long) exp_next_level(GET_LEVEL(ch), GET_CLASS(ch)) * old_exp;

    /* Update class and race-related things */
    update_char(ch);

    /* Hubis crap */
    check_regen_rates(ch);

    cprintf(ch, "You have successfully subclassed as %s!\r\n",
            with_indefinite_article(CLASS_FULL(ch)));
    clan_notification(GET_CLAN(ch), ch, "%s has subclassed to %s!",
                      GET_NAME(ch), CLASS_FULL(ch));
    mprintf(L_STAT, LVL_GOD, "%s has subclassed to %s", GET_NAME(ch), CLASS_FULL(ch));
    return;
  }

  /* Now we know the player is on a subclass quest, but not completed */
  sprintf(buf, "You are on the way to becoming a %s\r\n",
        classes[(int) subclass].fmtname);
  send_to_char(buf, ch);
  sprintf(buf, "You have until level %d to complete your quest.\r\n",
        c->max_subclass_level);
  send_to_char(buf, ch);
}


ACMD(do_quit)
{
  int i;
  struct obj_data *money, *obj;
  one_argument(argument, arg);

  if (IS_NPC(ch) || !ch->desc) {
    send_to_char("You can't quit while shapechanged!\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    act("$n has left the game.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("Goodbye, friend.  Come back soon!\r\n", ch);
    remove_player_from_game(ch, QUIT_QUITIMM);
    return;
  }

  if (FIGHTING(ch)) {
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
    return;
  }

  if (subcmd != SCMD_QUIT) {
    send_to_char("For safety purposes, you must type out 'quit yes'.\r\n", ch);
    send_to_char("Note: You will lose &1&beverything&0 if you quit!  Camping or renting will save everything.\r\n", ch);
    return;
  }

  if (!*arg || str_cmp(arg, "yes")) {
    send_to_char("You must type 'quit yes' to leave this world.\r\n", ch);
    send_to_char("Note: You will lose &1&beverything&0 if you quit!  Camping or renting will save everything.\r\n", ch);
    return;
  }

  /* Ok, if we've made it this far it's ok to quit */

  if (GET_STANCE(ch) < STANCE_STUNNED) {
    send_to_char("You die before your time...\r\n", ch);
    act("$n quits the game, but is unable to fend off death...", TRUE, ch, 0, 0, TO_ROOM);
    act("$n is dead!  R.I.P.", TRUE, ch, 0, 0, TO_ROOM);
    die(ch, NULL);
    return;
  }

  act("$n has left the game.", TRUE, ch, 0, 0, TO_ROOM);

  sprintf(buf, "%s has quit the game.", GET_NAME(ch));
  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
  send_to_char("Goodbye, friend.  Come back soon!\r\n", ch);

  /* transfer objects to room */
  while (ch->carrying) {
    obj = ch->carrying;
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
  }

  /* transfer equipment to room */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_room(unequip_char(ch, i), ch->in_room);

  /* And money */
  money = create_money(GET_COINS(ch));
  obj_to_room(money, ch->in_room);
  GET_GOLD(ch) = 0;
  GET_PLATINUM(ch) = 0;
  GET_COPPER(ch) = 0;
  GET_SILVER(ch) = 0;

  remove_player_from_game(ch, QUIT_QUITMORT);
}

#define MAMMAL         (1 << 0)
#define BIRD           (1 << 1)
#define REPTILE        (1 << 2)
#define FISH           (1 << 3)

#define TANK           (1 << 4)
#define DAMAGER        (1 << 5)
#define TRAVEL         (1 << 6)
#define TRACKER        (1 << 7)

#define AQUATIC        (1 << 8)


#define MAX_SHAPECHANGE_SKILLS        5
#define SHAPE_VNUM_MIN 1000
#define SHAPE_VNUM_MAX 1038

const struct shapechange_data {
  char *name;
  int vnum;
  int type;
  int midlevel;
  int minhp;
  int maxhp;
  int minmv;
  int maxmv;
  int skills[MAX_SHAPECHANGE_SKILLS];
} creatures[] = {
  /*   NAME      VNUM            TYPE            LVL  -HP   +HP  -MV  +MV  SKILLS */
  /* ----------  ----  -----------------------   ---  ---  ----  ---  ---  ------------- */
  { "rabbit",    1000, MAMMAL | DAMAGER,          30,  80,  140, 200, 250, {SKILL_SWITCH} },
  { "rat",       1001, MAMMAL | DAMAGER,           8,  40,   60,  80, 120, {SKILL_HIDE} },
  { "bat",       1002, MAMMAL | TRAVEL,            8,  50,   75, 140, 180, {SKILL_VAMP_TOUCH} },
  { "horse",     1003, MAMMAL | TRAVEL,           25, 220,  260, 180, 300, {0} },
  { "badger",    1004, MAMMAL | TANK,             30, 120,  160, 140, 170, {SKILL_CLAW, SKILL_SWITCH} },
  { "wolf",      1005, MAMMAL | TRACKER,          35, 400,  480, 270, 320, {SKILL_CLAW, SKILL_TRACK} },
  { "panther",   1006, MAMMAL | DAMAGER,          40, 380,  450, 300, 350, {SKILL_SWITCH, SKILL_SNEAK, SKILL_HIDE} },
  { "bear",      1007, MAMMAL | TANK,             45, 640,  740, 140, 160, {SKILL_ROAR, SKILL_RESCUE, SKILL_CORNER} },
  { "cheetah",   1008, MAMMAL | DAMAGER,          45, 420,  500, 400, 480, {SKILL_SWITCH, SKILL_RETREAT, SKILL_SPRINGLEAP} },
  { "rhino",     1009, MAMMAL | TANK,             50, 860, 1040, 120, 150, {SKILL_BODYSLAM, SKILL_RESCUE, SKILL_SWITCH, SKILL_RETREAT, SKILL_DOORBASH} },
  { "sparrow",   1010, BIRD | TRAVEL,              4,  40,   60, 140, 180, {SKILL_PECK} },
  { "bluebird",  1011, BIRD | TRAVEL,              6,  40,   70, 150, 200, {SKILL_PECK} },
  { "robin",     1012, BIRD | TRAVEL,             10,  60,   80, 125, 160, {SKILL_PECK} },
  { "owl",       1013, BIRD | TRAVEL,             15,  80,  100, 140, 160, {SKILL_SNEAK} },
  { "raven",     1014, BIRD | TRAVEL,             20, 100,  120, 160, 180, {0} },
  { "hawk",      1015, BIRD | TRAVEL,             25, 160,  190, 190, 220, {SKILL_PECK} },
  { "falcon",    1016, BIRD | DAMAGER,            30, 150,  180, 200, 240, {SKILL_CLAW, SKILL_PECK} },
  { "buzzard",   1017, BIRD | TRACKER,            35, 240,  280, 140, 160, {SKILL_PECK, SKILL_TRACK} },
  { "eagle",     1018, BIRD | DAMAGER,            40, 320,  380, 260, 300, {SKILL_CLAW, SKILL_PECK} },
  { "ostrich",   1019, BIRD | DAMAGER,            45, 360,  460, 500, 650, {SKILL_PECK, SKILL_KICK} },
  { "snake",     1020, REPTILE | TRACKER,          2,  25,   35,  80, 100, {SKILL_TRACK} },
  { "lizard",    1021, REPTILE | DAMAGER,          6,  45,   55,  80, 120, {0} },
  { "chameleon", 1022, REPTILE | TANK,             8,  60,   75,  80, 140, {SKILL_HIDE, SKILL_SNEAK, SKILL_STEALTH} },
  { "asp",       1023, REPTILE | TRACKER,         20, 120,  160, 120, 160, {SKILL_TRACK} },
  { "tortoise",  1024, REPTILE | TANK,            30, 320,  360,  40,  70, {0} },
  { "cobra",     1025, REPTILE | DAMAGER,         40, 280,  320, 140, 160, {SKILL_HIDE, SKILL_SNEAK} },
  { "turtle",    1026, REPTILE | TANK | AQUATIC,  45, 440,  480,  60, 100, {0} },
  { "viper",     1027, REPTILE | DAMAGER,         50, 340,  420, 140, 180, {SKILL_HIDE, SKILL_SNEAK} },
  { "crocodile", 1028, REPTILE | TANK,            55, 720,  830,  60, 120, {SKILL_RESCUE, SKILL_GUARD, SKILL_SWITCH} },
  { "anaconda",  1029, REPTILE | TANK,            60, 945, 1025, 140, 160, {SKILL_RESCUE, SKILL_GUARD, SKILL_SWITCH, SKILL_CORNER} },
  { "piranah",   1030, FISH | DAMAGER | AQUATIC,   4,  25,   35, 100, 150, {0} },
  { "eel",       1031, FISH | DAMAGER | AQUATIC,   9,  90,  110,  80, 120, {SKILL_CORNER, SKILL_SNEAK, SKILL_ELECTRIFY} },
  { "swordfish", 1032, FISH | TRAVEL | AQUATIC,   15, 100,  120, 200, 250, {0} },
  { "stingray",  1033, FISH | TRACKER | AQUATIC,  20, 200,  230, 150, 180, {SKILL_TRACK, SKILL_CORNER, SKILL_SNEAK, SKILL_STEALTH} },
  { "manatee",   1034, MAMMAL | TANK | AQUATIC,   30, 400,  450,  80, 100, {SKILL_GUARD, SKILL_RESCUE} },
  { "lamprey",   1035, FISH | DAMAGER | AQUATIC,  30, 300,  320, 120, 200, {SKILL_HIDE, SKILL_SNEAK} },
  { "dolphin",   1036, MAMMAL | TRAVEL | AQUATIC, 42, 400,  430, 400, 500, {SKILL_SWITCH} },
  { "shark",     1037, FISH | TRACKER | AQUATIC,  50, 480,  500, 240, 290, {SKILL_TRACK, SKILL_BODYSLAM, SKILL_SWITCH} },
  { "orca",      1038, MAMMAL | TANK | AQUATIC,   60, 950, 1100, 150, 200, {SKILL_CORNER, SKILL_BODYSLAM, SKILL_GUARD, SKILL_RESCUE} },
  { "\n",           0, 0,                          0,   0,    0,   0,   0, {0} }
};


ACMD(do_shapechange)
{
  int index, type, class, desired_index = -1, i;
  struct char_data *mob, *player;
  struct obj_data *obj;

  if (IS_NPC(ch) ? (!ch->desc || !POSSESSOR(ch)) :
      !GET_SKILL(REAL_CHAR(ch), SKILL_SHAPECHANGE)) {
    send_to_char("You have no idea how to do that!\r\n", ch);
    return;
  }

  argument = any_one_arg(argument, arg);

  /* If already shapechanged, other rules apply. */
  if (POSSESSED(ch)) {
    if (!*arg) {
      if (ch->char_specials.timer == 0)
        sprintf(buf, "You have just recently taken the form of %s.\r\n",
                GET_NAME(ch));
      else if (ch->char_specials.timer == 1)
        sprintf(buf, "You have been in the form of %s for 1 hour.\r\n",
                GET_NAME(ch));
      else
        sprintf(buf, "You have been in the form of %s for %d hours.\r\n",
              GET_NAME(ch), ch->char_specials.timer);
      send_to_char(buf, ch);
    }
    else if (!is_abbrev(arg, "me"))
      send_to_char("You cannot shapechange to another animal from this form.\r\n", ch);
    else {
      if (POSSESSOR(ch)->desc)
        close_socket(POSSESSOR(ch)->desc);

      player = POSSESSOR(ch);

      send_to_char("You quickly morph back to your original self.\r\n", ch);
      act("$n&0 contorts wildly as it reforms into $N.", TRUE, ch, 0, player, TO_ROOM);

      /* Set the player's hit/maxhit ratio to the same as the mob's. */
      /* Avoid division by zero by just setting to maximum */
      if (GET_MAX_HIT(ch) == 0)
        GET_HIT(player) = GET_MAX_HIT(player);
      else
        GET_HIT(player) = (GET_HIT(ch) * GET_MAX_HIT(player)) / GET_MAX_HIT(ch);
      if (GET_MAX_MOVE(ch) == 0)
        GET_MOVE(player) = GET_MAX_MOVE(player);
      else
        GET_MOVE(player) = (GET_MOVE(ch) * GET_MAX_MOVE(player)) / GET_MAX_MOVE(ch);
      GET_ALIGNMENT(player) = GET_ALIGNMENT(ch);

      if (GET_LEVEL(player) < LVL_IMMORT) {
        i = GET_COOLDOWN(player, CD_SHAPECHANGE) / (1 MUD_HR);
        SET_COOLDOWN(player, CD_SHAPECHANGE,
                     MAX(1, MIN(i, 5)) MUD_HR);
      }

      player->desc = ch->desc;
      player->desc->original = NULL;
      player->desc->character = player;
      ch->desc = NULL;
      player->forward = NULL;


      char_from_room(player);
      char_to_room(player, ch->in_room);
      transfer_battle(ch, player);

      /* Transfer any objects or money the mob had to the player. */
      while (ch->carrying) {
        obj = ch->carrying;
        obj_from_char(obj);
        obj_to_char(obj, player);
      }
      for (i = 0; i < NUM_WEARS; ++i)
        if (GET_EQ(ch, i))
          obj_to_char(unequip_char(ch, i), player);
      GET_PLATINUM(player) += GET_PLATINUM(ch);
      GET_GOLD(player) += GET_GOLD(ch);
      GET_SILVER(player) += GET_SILVER(ch);
      GET_COPPER(player) += GET_COPPER(ch);

      extract_char(ch);
    }
    return;
  }

  if (GET_COOLDOWN(ch, CD_SHAPECHANGE) && GET_LEVEL(ch) < LVL_IMMORT) {
    i = GET_COOLDOWN(ch, CD_SHAPECHANGE) / (1 MUD_HR) + 1 ;
    if (i == 1)
      strcpy(buf1, "hour");
    else
      sprintf(buf1, "%d hours", i);
    sprintf(buf, "You are still drained from your last shapechange.\r\n"
                 "It will be another %s before you can change again.\r\n",
                 buf1);
    send_to_char(buf, ch);
    return;
  }

  if (!*arg) {
    send_to_char("Shapechange to what?\r\n", ch);
    return;
  }

  if (!str_cmp(arg, "me")) {
    send_to_char("You are already in your normal form.\r\n", ch);
    return;
  }

  /* Check alignment. */
  if (GET_LEVEL(ch) < LVL_GOD) {
    if (GET_ALIGNMENT(ch) >= 350) {
      send_to_char("Your good loyalties betray your nature, inhibiting a transformation.\r\n", ch);
      return;
    }
    else if (GET_ALIGNMENT(ch) <= -350) {
      send_to_char("Your evil loyalties betray your nature, inhibiting a transformation.\r\n", ch);
      return;
    }
  }

  /* Determine the desired shapechange type.  You can supply as many
   * keywords as you like. */
  i = type = class = 0;
  do {
    if (is_abbrev(arg, "mammal"))
      type |= MAMMAL;
    else if (is_abbrev(arg, "reptile"))
      type |= REPTILE;
    else if (is_abbrev(arg, "bird"))
      type |= BIRD;
    else if (is_abbrev(arg, "fish"))
      type |= FISH;
    else if (is_abbrev(arg, "tank"))
      class |= TANK;
    else if (is_abbrev(arg, "damager"))
      class |= DAMAGER;
    else if (is_abbrev(arg, "traveler"))
      class |= TRAVEL;
    else if (is_abbrev(arg, "tracker"))
      class |= TRACKER;
    else if (is_abbrev(arg, "aquatic"))
      type |= AQUATIC;
    else {
      for (desired_index = 0; *creatures[desired_index].name != '\n'; ++desired_index)
        if (is_abbrev(arg, creatures[desired_index].name)) {
          type = creatures[desired_index].type & (MAMMAL | REPTILE | BIRD | AQUATIC | FISH);
          class = creatures[desired_index].type & (TANK | DAMAGER | TRAVEL | TRACKER);
          i = 1;
          break;
        }
      if (*creatures[desired_index].name == '\n') {
        send_to_char("What kind of animal is that?\r\n", ch);
        return;
      }
    }
    argument = any_one_arg(argument, arg);
  }
  while (*argument && !i);

  if (IS_SET(type, AQUATIC | FISH) && !IS_WATER(ch->in_room) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You won't be able to turn into that here!\r\n", ch);
    return;
  }

  /* Determine which mob this player can actually shapechange into. */
  for (i = 0, index = -1; *creatures[i].name != '\n'; ++i) {
    /* Skip creatures of lower level than already picked creature. */
    if (index >= 0 && creatures[i].midlevel < creatures[index].midlevel)
      continue;
    /* Skip aquatic creatures if not in water room. */
    if (IS_SET(creatures[i].type, AQUATIC) && !IS_WATER(ch->in_room))
      continue;
    /* Skip creatures of the wrong type. */
    if (type && !IS_SET(creatures[i].type, type))
      continue;
    /* This is where the dice roll occurs.  It's some complicated
     * alignment and level calculation.  I dunno. */
    if (GET_LEVEL(ch) < LVL_GOD &&
          index >= 0 &&
          creatures[i].midlevel - 5 + number(0, abs(GET_ALIGNMENT(ch))) > GET_LEVEL(ch))
      continue;
    /* Skip creatures of the wrong class. */
    if (class && !IS_SET(creatures[i].type, class))
      continue;
    /* This is a match. */
    index = i;
    /* This creature was specifically requested.  Stop looking. */
    if (desired_index == i)
      break;
  }

  if (index < 0) {
    send_to_char("You don't know how to shapechange into that.\r\n", ch);
    return;
  }

  if (desired_index >= 0 && desired_index != index) {
     sprintf(buf, "You didn't feel quite up to changing into %s.\r\n",
           with_indefinite_article(creatures[desired_index].name));
     send_to_char(buf, ch);
  }

  /* Attempt to create the mobile. */
  if (!(mob = read_mobile(creatures[index].vnum, VIRTUAL))) {
    send_to_char("You start to change, then feel ill, and slump back to your normal form.\r\n", ch);
    sprintf(buf, "SYSERR: %s tried to shapechange into nonexistent "
            "mob prototype V#%d", GET_NAME(ch), creatures[index].vnum);
    mudlog(buf, BRF, LVL_GOD, TRUE);
    return;
  }

  act("The snap of bones reforming can be heard as $n takes the shape of $N&0!",
        FALSE, ch, 0, mob, TO_ROOM);
  act("You transform into $N!", FALSE, ch, 0, mob, TO_CHAR);

  /* This must be done before ch is removed from a room, because that would
   * clear ch's battle status. */
  transfer_battle(ch, mob);

  /* Shuffle characters around. */
  char_to_room(mob, ch->in_room);
  char_from_room(ch);
  char_to_room(ch, 0);

  /* Copy some preferences from the player to the mob. */
  GET_PROMPT(mob) = strdup(GET_PROMPT(ch));

  /* Set up level based on player level and alignment. */
  GET_LEVEL(mob) = creatures[index].midlevel +
      MAX(MAX(-5, MIN(5, GET_LEVEL(ch) - creatures[index].midlevel)),
          ((350 - abs(GET_ALIGNMENT(ch))) * 5) / 350);

  /* Set up mob's skills. First, turn off default mob skills that animals
   * shouldn't have.  Yes, it's a shame, since the mob classes set on
   * the mob prototypes won't mean much, but it's too much to manually
   * list all the skills we want to remove.  After clearing skills, turn
   * on animal skills. */
  memset(&mob->char_specials.skills, 0, sizeof(mob->char_specials.skills));
  SET_SKILL(mob, SKILL_DODGE, roll_skill(mob, SKILL_DODGE));
  SET_SKILL(mob, SKILL_DOUSE, roll_skill(mob, SKILL_DOUSE));
  for (i = 0; i < MAX_SHAPECHANGE_SKILLS; ++i)
    if (creatures[index].skills[i])
      SET_SKILL(mob, creatures[index].skills[i],
                roll_skill(mob, creatures[index].skills[i]));

  /* Scale hp/mv based on player's current/max ratios. */
  GET_MAX_HIT(mob) = number(creatures[index].minhp, creatures[index].maxhp);
  GET_MAX_MOVE(mob) = number(creatures[index].minmv, creatures[index].maxmv);
  if (GET_MAX_HIT(ch) == 0)
    GET_HIT(mob) = GET_MAX_HIT(mob);
  else
    GET_HIT(mob) = (GET_HIT(ch) * GET_MAX_HIT(mob)) / GET_MAX_HIT(ch);
  if (GET_MAX_MOVE(ch) == 0)
    GET_MOVE(mob) = GET_MAX_MOVE(mob);
  else
    GET_MOVE(mob) = (GET_MOVE(ch) * GET_MAX_MOVE(mob)) / GET_MAX_MOVE(ch);
  GET_ALIGNMENT(mob) = GET_ALIGNMENT(ch);
  hurt_char(mob, NULL, 0, TRUE);

  /* Add the player's name to the mob's namelist */
  GET_NAMELIST(mob) = strdupf("%s %s", GET_NAMELIST(mob), GET_NAME(ch));

  /* Set gender */
  GET_SEX(mob) = GET_SEX(ch);

  /* Move the descriptor. */
  ch->desc->character = mob;
  ch->desc->original = ch;
  mob->desc = ch->desc;
  ch->desc = NULL;
  ch->forward = mob;
}

bool creature_allowed_skill(struct char_data *ch, int skill)
{
   int i, j;

   if (!IS_NPC(ch) || GET_MOB_VNUM(ch) < SHAPE_VNUM_MIN ||
         GET_MOB_VNUM(ch) >SHAPE_VNUM_MAX)
      return FALSE;

   for (i = 0; creatures[i].vnum > 0; i++) {
      if (creatures[i].vnum == GET_MOB_VNUM(ch)) {
         for (j = 0; j < MAX_SHAPECHANGE_SKILLS; ++j)
            if (creatures[i].skills[j] == skill)
               return TRUE;
      }
   }

   return FALSE;
}

#undef MAMMAL
#undef BIRD
#undef REPTILE
#undef FISH

#undef TANK
#undef DAMAGER
#undef TRAVEL
#undef TRACKER

#undef AQUATIC

#undef MAX_SHAPECHANGE_SKILLS


ACMD(do_save)
{
  struct char_data *target = NULL;

   /*  Player save functionality for god types. */
   /*  The following section allows for gods to save players using the */
   /*  syntax: save <playername>, where <playername> is the player to */
   /*  be saved. This works on any character which has been brought */
   /*  online either by the player logging in or a god linkloading. */
  if (GET_LEVEL(ch) >= LVL_GOD) {
    one_argument(argument, arg);

    if (!strcmp(arg, "all")) {
      auto_save_all();
      cprintf(ch, "You have saved all players in the realm.\r\n");
      mprintf(L_STAT, MAX(GET_LEVEL(ch), GET_INVIS_LEV(ch)),
              "(GC) %s has saved all players in the realm.", GET_NAME(ch));
      return;
    }
    else if (*arg)
      /*  try to locate this player within the realm */
      target = find_char_around_char(ch, find_by_name(arg));
    else
      target = ch;
  }
  else
    target = ch;

  if (IS_NPC(ch) || !ch->desc)
    return;

  if (!target) {
    cprintf(ch, "No player by the name of %s is currently in the game.\r\n", arg);
    return;
  }

  if (IS_NPC(target)) {
    send_to_char("You can't save an NPC!\r\n", ch);
    return;
  }

  if (cmd) {
    if (ch == target)
      cprintf(ch, "Saving %s.\r\n", GET_NAME(ch));
    else
      cprintf(ch, "You have force-saved %s.\r\n", GET_NAME(target));
  }
  save_player(target);

  if (ch != target)
    mprintf(L_STAT, GET_LEVEL(ch), "(GC) %s has saved %s to file.", GET_NAME(ch), GET_NAME(target));
}


/* generic function for commands which are normally overridden by
   special procedures - i.e., shop commands, mail commands, etc. */
ACMD(do_not_here)
{
  if (CMD_IS("balance") || CMD_IS("deposit") || CMD_IS("withdraw") ||
      CMD_IS("dump") || CMD_IS("exchange"))
    send_to_char("Sorry, you can only do that in a bank!\r\n", ch);
  else if (CMD_IS("appear") || CMD_IS("disappear"))
    send_to_char(HUH, ch);
  else if (CMD_IS("mail") || CMD_IS("check") || CMD_IS("receive"))
    send_to_char("Sorry, you can only do that in a post office!\r\n", ch);
  else if (CMD_IS("list") || CMD_IS("value") || CMD_IS("buy") ||
           CMD_IS("sell"))
    send_to_char("Sorry, you can only do that in a shop!\r\n", ch);
  else if (CMD_IS("rent"))
    send_to_char("Sorry, you can only do that in an inn!\r\n", ch);
  else
    send_to_char("Sorry, but you cannot do that here!\r\n", ch);
}


ACMD(do_camp)
{
  struct camp_event *ce;

  if (FIGHTING(ch) || EVENT_FLAGGED(ch, EVENT_CAMP)) {
    send_to_char("You are too busy to do this!\r\n", ch);
    return;
  }

  if (IS_NPC(ch) || !ch->desc) {
    send_to_char("You can't camp while shapechanged!\r\n", ch);
    return;
  }

  /* Restrictions: can't camp inside, in a city, or in water. */
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (CH_INDOORS(ch)) {
      send_to_char("&7You always pitch a tent indoors?&0\r\n", ch);
      return;
    }

    if (SECT(ch->in_room) == SECT_CITY) {
      send_to_char("&7Ye can't pitch a tent on the sidewalk fool.&0\r\n", ch);
      return;
    }

    if ((SECT(ch->in_room) == SECT_SHALLOWS) ||
        (SECT(ch->in_room) == SECT_WATER) ||
        (SECT(ch->in_room) == SECT_UNDERWATER)) {
      send_to_char("&7Go buy a floating tent and try again.&0\r\n", ch);
      return;
      if (SECT(ch->in_room) == SECT_AIR) {
        send_to_char("&7You can't camp in mid-air.&0\r\n", ch);
        return;
      }
    }
    if (RIDING(ch)) {
      send_to_char("You'd better dismount first.\r\n", ch);
      return;
    }
  }


  if (GET_STANCE(ch) == STANCE_FIGHTING)
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
  else if (GET_STANCE(ch) < STANCE_STUNNED)
    send_to_char("It's hard to set your tent up while dying...\r\n", ch);
  else {
    /* create and initialize the camp event */
    CREATE(ce, struct camp_event, 1);
    ce->ch = ch;
    ce->was_in = ch->in_room;
    event_create(EVENT_CAMP, camp_event, ce, TRUE, &(ch->events),
                 GET_LEVEL(ch) >= LVL_IMMORT ? 5 : 350);
    SET_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
    act("You start setting up camp.", FALSE, ch, NULL, NULL, TO_CHAR);
    act("$n starts setting up camp.", TRUE, ch, 0, 0, TO_ROOM);
  }
}

EVENTFUNC(recall_event)
{
  struct recall_event_obj *re = (struct recall_event_obj *) event_obj;
  struct char_data *ch;
  bool wasdark;

  ch = re->ch;

  if (ch->in_room != re->from_room) {
    send_to_room("The magic of the scroll fizzles as its target has left.\r\n",
                 re->from_room);
    send_to_char("The magic of the scroll fizzles, as you left the area.\r\n",
                 ch);
    return EVENT_FINISHED;
  };

  if (IS_NPC(ch) || !ch->desc)
    return EVENT_FINISHED;

  send_to_char("You feel the scroll's energy start to envelop you.\r\n", ch);
  act("$N disappears in a bright flash.\r\n", FALSE, ch, 0, ch, TO_NOTVICT);
  wasdark = IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch);

  dismount_char(ch);
  char_from_room(ch);
  char_to_room(ch, re->room);
  act("$N appears in a bright flash of light.\r\n", FALSE, ch, 0, ch,
      TO_NOTVICT);

  check_new_surroundings(ch, wasdark, TRUE);

  return EVENT_FINISHED;
}


EVENTFUNC(camp_event)
{
  struct camp_event *ce = (struct camp_event *) event_obj;
  struct char_data *ch = NULL;
  int was_in, now_in;

  /* extract all the info from ce */
  ch = ce->ch;
  was_in = ce->was_in;
  now_in = ch->in_room;

  if (IS_NPC(ch) || !ch->desc) {
    REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
    return EVENT_FINISHED;
  }

  if (RIDING(ch)) {
    REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
    send_to_char("You can't camp while mounted!\r\n", ch);
    return EVENT_FINISHED;
  }

  if (FIGHTING(ch)) {
    act("You decide now is not the best time for camping.", FALSE, ch, NULL,
        NULL, TO_CHAR);
    REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
    return EVENT_FINISHED;
  }

  if (now_in != was_in) {
    act("You are no longer near where you began the campsite.", FALSE, ch,
        NULL, NULL, TO_CHAR);
    REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
    return EVENT_FINISHED;
  }

  /* Yeah, let's not try to update characters who are about to be free'd, eh */
  rem_memming(ch);

  /* So players don't get saved with the meditate flag and cause syserrs
     when they log back on. */
  if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
    act("$N ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("&8You stop meditating.\r\n&0", ch);
    REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
  }

  act("You complete your campsite, and leave this world for a while.", FALSE,
      ch, NULL, NULL, TO_CHAR);
  if (!GET_INVIS_LEV(ch))
    act("$n rolls up $s bedroll and tunes out the world.", TRUE, ch, 0, 0, TO_ROOM);

  sprintf(buf, "%s has camped in %s (%d).",
        GET_NAME(ch), world[ch->in_room].name, world[ch->in_room].vnum);

  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
  REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_CAMP);
  remove_player_from_game(ch, QUIT_CAMP);
  return EVENT_FINISHED;
}

ACMD(do_unbind)
{
  int prob, percent;
  struct char_data *vict;
  char arg[MAX_INPUT_LENGTH];

  one_argument(argument, arg);

  if (!*arg) {
    if (!PLR_FLAGGED(ch, PLR_BOUND)){
      send_to_char("You are free as a bird!\r\n", ch);
      return;}
    prob = number(1, 70);
    percent = number(20, 101);
    if (prob > percent){
      send_to_char("You break free from your binds!\r\n", ch);
      act("$n breaks free from his binds", FALSE, ch, 0, 0, TO_ROOM);
      REMOVE_FLAG(PLR_FLAGS(ch), PLR_BOUND);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      return;
    }else
      WAIT_STATE(ch, PULSE_VIOLENCE*3);
    return;
  }else{
    if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      send_to_char("Unbind who?\r\n", ch);
      return;    }
    if (vict == ch){
      prob = number(20, 70);
      percent = number(1, 101);
      if (prob > percent){
        send_to_char("You break free from your binds!\r\n", ch);
        act("$n breaks free from his binds", FALSE, ch, 0, 0, TO_ROOM);
        REMOVE_FLAG(PLR_FLAGS(ch), PLR_BOUND);
        WAIT_STATE(ch, PULSE_VIOLENCE);
        return;
      }else
        WAIT_STATE(ch, PULSE_VIOLENCE*3);
      return;}
    REMOVE_FLAG(PLR_FLAGS(vict), PLR_BOUND);
    WAIT_STATE(ch, PULSE_VIOLENCE);
    send_to_char("You are free of your binds.\r\n", vict);
  }
}

ACMD(do_bind)
{
  struct char_data *vict;
  struct obj_data *held = GET_EQ(ch, WEAR_HOLD);
  int prob, percent;

  /* disable this command it's broken and is being used to
     ruin the game for players RSD 2/11/2001 */
  send_to_char("Huh?!?\r\n",ch);
  return;

  if (FIGHTING(ch)) {
    send_to_char("You are too busy fighting to think about that right now!\r\n",ch);
    return;
  }

  one_argument(argument, arg);

  if(!*arg)
    send_to_char("Bind who?\r\n", ch);
  else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))))
    send_to_char("There is no such player.\r\n", ch);
  else if(IS_NPC(vict))
    send_to_char("You can't do that to a mob!\r\n", ch);
  else if(GET_LEVEL(vict) > LVL_GOD)
    send_to_char("Hmmm...you'd better not.\r\n", ch);
  else if(!held)
    send_to_char("You must be holding a rope to tie someone up!\r\n", ch);
  else {

    if (ch == vict) {
      send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
      return;
    }      if (PLR_FLAGGED(vict, PLR_BOUND)) {
      send_to_char("Your victim is already tied up.\r\n", ch);
      return;
    }
    if(GET_OBJ_TYPE(held) != ITEM_ROPE){
      send_to_char("You must be holding a rope to tie someone up!\r\n", ch);
      return;
    }
    if(GET_SKILL(ch, SKILL_BIND) == 0){
      if(GET_STANCE(vict) > STANCE_STUNNED){
        send_to_char("You aren't skilled enough to tie a conscious person\r\n", ch);
        return;
      }else{
        act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
        act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
        act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
        SET_FLAG(PLR_FLAGS(vict), PLR_BOUND);
        extract_obj(held);
        WAIT_STATE(ch, PULSE_VIOLENCE * 2);
        return;
}
    }else{
      prob = number(1, 50);
      prob += GET_SKILL(ch, SKILL_BIND);
      prob += GET_LEVEL(ch);
      percent = number(50, 200);
      percent += dex_app[GET_DEX(vict)].defensive;
      percent += GET_LEVEL(vict);

      if(GET_STANCE(vict) < STANCE_SLEEPING)
        prob = percent + 1;

      if(prob > percent){
        act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
        act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
        act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
        SET_FLAG(PLR_FLAGS(vict), PLR_BOUND);
        extract_obj(held);
        improve_skill(ch, SKILL_BIND);
        WAIT_STATE(ch, PULSE_VIOLENCE * 3);
        return;}else{
          act("You tries to tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
          act("$n tries to tie you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
          act("$n tries to tie up $N.", FALSE, ch, 0, vict, TO_ROOM);
          improve_skill(ch, SKILL_BIND);
          WAIT_STATE(ch, PULSE_VIOLENCE * 3);
          return;
        }
    }
  }
}

ACMD(do_abort)
{
  void abort_casting(struct char_data *ch);
  void flush_queues(struct descriptor_data *d);

  if (CASTING(ch)) {
    send_to_char("&8You abort your spell!&0\r\n", ch);
    abort_casting(ch);
    if (ch->desc)
      flush_queues(ch->desc);
  }
  else
    send_to_char("You're not even casting a spell right now.\r\n", ch);
}


ACMD(do_hide)
{
  long lower_bound, upper_bound;
  int skill;

  if (!GET_SKILL(ch, SKILL_HIDE)) {
    send_to_char("You'd better leave that art to the rogues.\r\n", ch);
    return;
  }

  if (RIDING(ch)) {
    send_to_char("While mounted? I don't think so...\r\n", ch);
    return;
  }

  if (IS_HIDDEN(ch))
    send_to_char("You try to find a better hiding spot.\r\n", ch);
  else
    send_to_char("You attempt to hide yourself.\r\n", ch);

  skill = GET_SKILL(ch, SKILL_HIDE);
  lower_bound = -0.0008 * pow(skill, 3) + 0.1668 * pow(skill, 2) - 3.225 * skill;
  upper_bound = skill * (3 * GET_DEX(ch) + GET_INT(ch)) / 40;
  GET_HIDDENNESS(ch) = number(lower_bound, upper_bound) + dex_app_skill[GET_DEX(ch)].hide;

  GET_HIDDENNESS(ch) = MAX(GET_HIDDENNESS(ch), 0);

  WAIT_STATE(ch, PULSE_VIOLENCE);

  improve_skill(ch, SKILL_HIDE);

  REMOVE_FLAG(EFF_FLAGS(ch), EFF_STEALTH);
  if (GET_SKILL(ch, SKILL_STEALTH)) {
    if (GET_HIDDENNESS(ch) && GET_SKILL(ch, SKILL_STEALTH) > number(0, 101))
      SET_FLAG(EFF_FLAGS(ch), EFF_STEALTH);
    improve_skill(ch, SKILL_STEALTH);
  }
}




ACMD(do_steal)
{
   struct char_data *vict;
   struct obj_data *obj;
   char vict_name[MAX_INPUT_LENGTH], obj_name[MAX_INPUT_LENGTH];
   int percent, eq_pos, ohoh = 0, coins[NUM_COIN_TYPES];
   int numcoins = 0;
   int lastcoin;

   ACMD(do_gen_comm);

   if (FIGHTING(ch)) {
      send_to_char("You can't steal while you are fighting!\r\n", ch);
      return;
   }
   if (GET_SKILL(ch, SKILL_STEAL) <= 0) {
      send_to_char("You don't know how to steal!\r\n", ch);
      return;
   }
   if (MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      send_to_char("Being an illusion, you can't steal things.\r\n", ch);
      return;
   }
   if (!RIGID(ch) && GET_LEVEL(ch) < LVL_IMMORT) {
      send_to_char("You can't handle objects in your condition.\r\n", ch);
      return;
   }

   argument = one_argument(argument, obj_name);
   one_argument(argument, vict_name);

   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, vict_name)))) {
      send_to_char("Steal what from who?\r\n", ch);
      return;
   } else if (vict == ch) {
      send_to_char("Come on now, that's rather stupid!\r\n", ch);
      return;
   }

   /* Player-stealing is only allowed during PK. */
   if (!attack_ok(ch, vict, FALSE)) {
      send_to_char("You can't steal from them!\r\n", ch);
      return;
   }
   if (ROOM_FLAGGED(vict->in_room, ROOM_ARENA)) {
      send_to_char("You can't steal in the arena!\r\n", ch);
      return;
   }

   /* 101% is a complete failure */
   percent = number(1, 101) - dex_app_skill[GET_DEX(ch)].p_pocket;
   if (!CAN_SEE(vict, ch))
      percent -= dex_app_skill[GET_DEX(ch)].p_pocket;

   /* Stealing from unconscious folks is always successful. */
   if (!AWAKE(vict))
      percent = -1;

   /* ... except that you cannot steal from immortals or shopkeepers. */
   if (GET_LEVEL(vict) >= LVL_IMMORT || GET_MOB_SPEC(vict) == shop_keeper)
      percent = 101+50;

   /* First check whether the thief wants to steal money */
   if (str_cmp(obj_name, "coins") && str_cmp(obj_name, "gold")) {

      /* If not money, look for an item in the victim's inventory */
      if (!(obj = find_obj_in_list(vict->carrying, find_vis_by_name(ch, obj_name)))) {

         /* If not an item in inventory, look for an equipped item */
         for (eq_pos = 0; eq_pos < NUM_WEARS; eq_pos++)
            if (GET_EQ(vict, eq_pos) &&
                  (isname(obj_name, GET_EQ(vict, eq_pos)->name)) &&
                  CAN_SEE_OBJ(ch, GET_EQ(vict, eq_pos))) {
               obj = GET_EQ(vict, eq_pos);
               break;
            }

            /* Thief is attempting to steal an equipped item. */

            if (!obj) {
               act("$E hasn't got that item.", FALSE, ch, 0, vict, TO_CHAR);
               return;
            } else {
               /* You cannot steal equipped items unless the victim is knocked out. */
               if (GET_STANCE(vict) > STANCE_STUNNED) {
                  send_to_char("Steal the equipment now?  Impossible!\r\n", ch);
                  return;
               } else if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
                  act("$p is too powerful for you to steal.", FALSE, ch, obj, 0, TO_CHAR);
                  return;
               } else {
                  /* You stole an equipped item from a helpless mob. */
                  act("You unequip $p and steal it.", FALSE, ch, obj, 0, TO_CHAR);
                  act("$n steals $p from $N.", FALSE, ch, obj, vict, TO_NOTVICT);
                  obj_to_char(unequip_char(vict, eq_pos), ch);
               }
            }
         } else {
            /* Steal an item from inventory */
            percent += GET_OBJ_WEIGHT(obj);   /* Make heavy harder */
            if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
               /* You failed. */
               ohoh = TRUE;
               act("Oops...", FALSE, ch, 0, 0, TO_CHAR);
               act("$n tried to steal something from you!", FALSE, ch, 0, vict, TO_VICT);
               act("$n tries to steal something from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
            } else if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
               act("$p is too powerful for you to steal.", FALSE, ch, obj, 0, TO_CHAR);
               return;
            } else {
               /* You succeeded. */
               if ((IS_CARRYING_N(ch) + 1 < CAN_CARRY_N(ch))) {
                  if (ADDED_WEIGHT_OK(ch, obj)) {
                     obj_from_char(obj);
                     obj_to_char(obj, ch);
                     send_to_char("Got it!\r\n", ch);
                     if (AWAKE(vict))
                        improve_skill(ch, SKILL_STEAL);
                     get_check_money(ch, obj);
                  }
               } else
                  send_to_char("You cannot carry that much.\r\n", ch);
            }
         }
      } else {
         /* Steal some coins */
         if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
            /* Failed attempt to steal some coins */
            ohoh = TRUE;
            act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
            act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, vict, TO_VICT);
            act("$n tries to steal coins from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
            improve_skill(ch, SKILL_STEAL);
         } else {
            /* Successful theft of coins */
            if ((coins[PLATINUM] = (GET_PLATINUM(vict) * number(1, 10)) / 100)) {
               lastcoin = PLATINUM;
               numcoins++;
            }
            if ((coins[GOLD] = (GET_GOLD(vict) * number(1, 10)) / 100)) {
               lastcoin = GOLD;
               numcoins++;
            }
            if ((coins[SILVER] = (GET_SILVER(vict) * number(1, 10)) / 100)) {
               lastcoin = SILVER;
               numcoins++;
            }
            if ((coins[COPPER] = (GET_COPPER(vict) * number(1, 10)) / 100)) {
               lastcoin = COPPER;
               numcoins++;
            }
            if (CASH_VALUE(coins) > 0) {
               GET_COPPER(ch) += coins[COPPER];
               GET_COPPER(vict) -= coins[COPPER];
               GET_SILVER(ch) += coins[SILVER];
               GET_SILVER(vict) -= coins[SILVER];
               GET_GOLD(ch) += coins[GOLD];
               GET_GOLD(vict) -= coins[GOLD];
               GET_PLATINUM(ch) += coins[PLATINUM];
               GET_PLATINUM(vict) -= coins[PLATINUM];
               statemoney(buf, coins);
               cprintf(ch, "Woohoo! You stole %s.\r\n", buf);
            } else {
               send_to_char("You couldn't get any coins...\r\n", ch);
            }
            if (AWAKE(vict))
               improve_skill(ch, SKILL_STEAL);
         }
      }

   if (ohoh && IS_NPC(vict) && AWAKE(vict))
      attack(vict, ch);
   WAIT_STATE(ch, PULSE_VIOLENCE / 2);
}



ACMD(do_level)
{
  extern char *exp_message(struct char_data *ch);
  extern ACMD(do_experience);

  one_argument(argument, arg);

  if (!*arg)
    do_experience(ch, argument, 0, 0);
  else if (!str_cmp(arg, "gain"))
    send_to_char("You can only do that in your guild.\r\n", ch);
  else
    send_to_char("Huh?!?\r\n", ch);
}


ACMD(do_visible)
{
   void perform_immort_vis(struct char_data *ch);

   if (GET_LEVEL(ch) >= LVL_IMMORT) {
      perform_immort_vis(ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_INVISIBLE) || IS_HIDDEN(ch) ||
       EFF_FLAGGED(ch, EFF_CAMOUFLAGED)) {
      appear(ch);
   } else {
      send_to_char("You are already visible.\r\n", ch);
   }
}



ACMD(do_title)
{
  int titles, which;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (IS_NPC(ch))
    send_to_char("Your title is fine... go away.\r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_NOTITLE))
    send_to_char("You can't title yourself -- you shouldn't have abused it!\r\n", ch);
  else if (GET_LEVEL(ch) >= LVL_IMMORT) {
    if (strlen(argument) > MAX_TITLE_LENGTH)
      cprintf(ch, "Sorry, titles can't be longer than %d characters.\r\n",
              MAX_TITLE_LENGTH);
    else {
      set_title(ch, argument);
      cprintf(ch, "Okay, you're now %s %s.\r\n", GET_NAME(ch), GET_TITLE(ch));
      save_player_char(ch);
    }
  }
  else if (!*argument) {
    titles = 0;
    if (GET_PERM_TITLES(ch))
      while (GET_PERM_TITLES(ch)[titles])
        ++titles;
    if (GET_CLAN(ch) && IS_CLAN_MEMBER(ch))
      ++titles;
    if (titles == 0) {
      send_to_char("You haven't earned any permanent titles!\r\n", ch);
      if (ch->player.title && *ch->player.title)
        send_to_char("Use 'title 0' to clear your current title.\r\n", ch);
    }
    else {
      titles = 0;
      cprintf(ch, "You have earned the following titles:\r\n"
                   "  0) <no title>\r\n");
      if (GET_PERM_TITLES(ch))
        while (GET_PERM_TITLES(ch)[titles]) {
          cprintf(ch, "  %d) %s\r\n", titles + 1,
                  GET_PERM_TITLES(ch)[titles]);
          ++titles;
        }
      if (GET_CLAN(ch) && IS_CLAN_MEMBER(ch))
        cprintf(ch, "  %d) %s %s\r\n", ++titles,
                GET_CLAN_TITLE(ch),
                GET_CLAN(ch)->abbreviation);
      cprintf(ch, "Use 'title <number>' to switch your title.\r\n");
    }
  }
  else if (!is_positive_integer(argument))
    send_to_char("Usage: title\r\n"
                 "       title <number>\r\n",
                 ch);
  else {
    int i;
    which = atoi(argument);
    titles = 0;
    if (which == 0)
      set_title(ch, NULL);
    if (GET_PERM_TITLES(ch))
      for (i = 0; GET_PERM_TITLES(ch)[i]; ++i)
        if (++titles == which) {
          set_title(ch, GET_PERM_TITLES(ch)[i]);
          break;
        }
    if (GET_CLAN(ch) && IS_CLAN_MEMBER(ch)) {
      if (++titles == which)
        clan_set_title(ch);
    }
    if (which > titles) {
      send_to_char("You don't have that many titles!\r\n", ch);
      return;
    }
    if (GET_TITLE(ch)) {
      sprintf(buf, "Okay, set your title to: %s\r\n", GET_TITLE(ch));
      send_to_char(buf, ch);
    }
    else
      send_to_char("Okay, cleared your title.\r\n", ch);
  }
}


ACMD(do_douse)
{
  bool success = FALSE;
  struct char_data *vict;
  struct obj_data *obj;

  if (!ch)
    return;

  if (argument && *argument) {
    one_argument(argument, arg);
    vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg));
  }
  else
    vict = ch;

  if (!vict) {
    send_to_char("You don't see that person here.\r\n",ch);
    return;
  }
  else if (!EFF_FLAGGED(vict, EFF_ON_FIRE)) {
    send_to_char("Where's the fire?\r\n", ch);
    return;
  }

  /* A fountain in the room guarantees success. */
  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) {
      success = TRUE;
      break;
    }

  /* There is a fountain here */
  if (success) {

    /* Dousing yourself with a fountain */
    if (ch == vict) {
      act("*SPLASH* $n leaps into $o, putting out the flames that were consuming $m.",
            FALSE, ch, obj, 0, TO_ROOM);
      act("*SPLASH* You leap into $o, dousing your flames!", FALSE, ch, obj, 0, TO_CHAR);

    /* Dousing someone else with a fountain */
    } else {
      act("You dunk $N into $o, putting $M out! *SPLASH* *GURGLE*",
            FALSE, ch, obj, vict, TO_CHAR);
      act("$n dunks you into $o, putting your flames out! *GURGLE*",
            FALSE, ch, obj, vict, TO_VICT);
      act("$n dunks $N into $o, dousing $S flames! *SPLASH* *GURGLE*",
            FALSE, ch, obj, vict, TO_NOTVICT);
    }
  }

  /* No fountain */

  /* Water room? */

  else if (IS_WATER(IN_ROOM(vict))) {
     if (ch == vict) {
      act("$n ducks under the surface of the water, putting out $s flames.",
            FALSE, ch, 0, 0, TO_ROOM);
      act("You duck under the surface of the water, dousing your flames.",
            FALSE, ch, obj, 0, TO_CHAR);
     } else {
       act("You push $N under the water, putting $M out! *SPLASH* *GURGLE*",
             FALSE, ch, 0, vict, TO_CHAR);
       act("$n pushes you under the water, putting your flames out! *GURGLE*",
             FALSE, ch, 0, vict, TO_VICT);
       act("$n pushes $N under the water, dousing $S flames! *SPLASH* *GURGLE*",
             FALSE, ch, 0, vict, TO_NOTVICT);
     }
     success = TRUE;
  }

  /* Splashy room?  E.g., swamp, beach */

  else if (IS_SPLASHY(IN_ROOM(vict)) || SECT(vict->in_room) == SECT_BEACH) {
     if (ch == vict) {
      act("$n rolls around in the water, quickly putting out $s flames.",
            FALSE, ch, 0, 0, TO_ROOM);
      act("You roll around in the water, quickly dousing your flames.",
            FALSE, ch, obj, 0, TO_CHAR);
     } else {
       act("You push $N down into the shallow water, putting $M out! *SPLASH* *GURGLE*",
             FALSE, ch, 0, vict, TO_CHAR);
       act("$n pushes you into the shallow water, putting your flames out! *GURGLE*",
             FALSE, ch, 0, vict, TO_VICT);
       act("$n pushes $N into the shallow water, dousing $S flames! *SPLASH* *GURGLE*",
             FALSE, ch, 0, vict, TO_NOTVICT);
     }
     success = TRUE;
  }

  /* No water available! */

  /* No water, trying to douse yourself */
  else if (ch == vict) {
    if (GET_SKILL(ch, SKILL_DOUSE) < number(0,100)) {
      act("$n&0 frantically rolls around on the ground, attempting to douse the flames consuming $s body.",
            TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You roll around on the ground, trying to douse the flames engulfing your body!\r\n",
            ch);
    }
    else {
      act("$n&0 rolls on the ground frantically, finally smothering the fire that was consuming $m.",
            TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You roll around on the ground, finally smothering your flames.\r\n",
            ch);
      success = TRUE;
    }
  }

  /* No water, trying to douse someone else */
  else if (GET_SKILL(ch, SKILL_DOUSE) - 40 < number(0,100)) {
    act("You frantically try to brush the flames from $N&0.",
          FALSE, ch, 0, vict, TO_CHAR);
    act("$n&0 aids you, attempting to douse your flames.",
          FALSE, ch, 0, vict, TO_VICT);
    act("$n&0 frantically attempts to brush the flames off $N&0.",
          FALSE, ch, 0, vict, TO_NOTVICT);
  }
  else {
    act("You frantically brush the flames from $N&0, finally extinguishing $M!",
          TRUE, ch, 0, vict, TO_CHAR);
    act("$n&0 aids you, finally putting your flames out!",
          FALSE, ch, 0, vict, TO_VICT);
    act("$n&0 finally douses the flames that were consuming $N&0!",
          FALSE, ch, 0, vict, TO_NOTVICT);
    success = TRUE;
  }

  if (success)
    REMOVE_FLAG(EFF_FLAGS(vict), EFF_ON_FIRE);
  improve_skill(ch, SKILL_DOUSE);
  WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_disband)
{
  if (!ch->groupees) {
    send_to_char("&0&7&bBut you lead no group!&0\r\n", ch);
    return;
  }

  disband_group(ch, TRUE, FALSE);
}


ACMD(do_consent)
{
   struct char_data *target;

   one_argument(argument, arg);

   if (!*arg) {
      if (!CONSENT(ch))
         send_to_char("You are not consented to anyone!\r\n", ch);
      else
         act("You are consented to $N.", TRUE, ch, 0, CONSENT(ch), TO_CHAR | TO_SLEEP);
      return;
   }

   if (!str_cmp(arg, "off"))
     target = ch; /* consent self to turn it off */
   else if (!(target = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
      send_to_char(NOPERSON, ch);
      return;
   }

   if (target == ch) {
      if (CONSENT(ch)) {
         act("&8$n&0&8 has revoked $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT | TO_SLEEP);
         send_to_char("&8You revoke your consent.&0\r\n", ch);
         CONSENT(ch) = NULL;
      }
      else
         send_to_char("You haven't given your consent to anyone.\r\n", ch);
      return;
   }

   if (CONSENT(ch) == target) {
      act("$N already has your consent.", FALSE, ch, 0, target, TO_CHAR | TO_SLEEP);
      return;
   }

   if (!speech_ok(ch, 1)) {
      send_to_char("Your sore throat somehow prevents you from doing this.\r\n", ch);
      return;
   }

   if (CONSENT(ch))
      act("&8$n&0&8 has removed $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT | TO_SLEEP);
   CONSENT(ch) = target;
   act("&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR | TO_SLEEP);
   act("&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT | TO_SLEEP);

}

ACMD(do_bandage)
{
  struct char_data *victim;

  one_argument(argument, arg);

  /* If no arg, bandage the first person in the room who needs it. */
  if (!*arg) {
    for (victim = world[ch->in_room].people; victim; victim = victim->next_in_room)
      if (CAN_SEE(ch, victim))
        if (GET_HIT(victim) < 0 || GET_STANCE(victim) < STANCE_STUNNED)
          break;
    if (!victim) {
      send_to_char("Nobody here looks like they need bandaging!\r\n", ch);
      return;
    }
  }
  else if (!(victim = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return;
  }
  if (GET_HIT(victim) >= 0 && GET_STANCE(victim) >= STANCE_STUNNED) {
    act("&8$N looks in pretty good shape already!&0", FALSE, ch, 0, victim, TO_CHAR);
    return;
  }

  if (GET_SKILL(ch, SKILL_BANDAGE) > number(1, 80)) {
    act("&0&8You bandage $N.&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&8$n&0&8 bandages $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    hurt_char(victim, NULL, MAX(-3, GET_SKILL(ch, SKILL_BANDAGE) / -10), TRUE);
  } else {
    act("You fail to bandage $N properly.", FALSE, ch, 0, victim, TO_CHAR);
    act("&8$n fails an attempt to bandage $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    if (DAMAGE_WILL_KILL(victim, 1)) {
      act ("Your bandaging was so appalling that $N died!&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&8$n kills $N with some dismal bandaging.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    }
    hurt_char(victim, NULL, 1, TRUE);
  }

  improve_skill(ch, SKILL_BANDAGE);
  if (GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE);
}

void make_group_report_line(struct char_data *ch, char *buffer) {
   int perc;
   char harm_color[20];

   perc = (100*GET_HIT(ch)/GET_MAX_HIT(ch));

   strcpy(harm_color,
         perc >= 100 ? CLR(ch, ANRM) :
         perc >= 88 ? CLR(ch, AFYEL) :
         perc >= 70 ? CLR(ch, AHYEL) :
         perc >= 45 ? CLR(ch, AFMAG) :
         perc >= 20 ? CLR(ch, AFRED) :
         perc >= 0 ? CLR(ch, AFRED) :
         CLR(ch, AFRED));

   sprintf(buffer, "%s%-15s &0[", harm_color, GET_NAME(ch));
   if (GET_HIT(ch) < 10)
      strcat(buffer, "   ");
   else if (GET_HIT(ch) < 100)
      strcat(buffer, "  ");
   else if (GET_HIT(ch) < 1000)
      strcat(buffer, " ");

   sprintf(buf2, "%s%d&0&8h&0/", harm_color, GET_HIT(ch));
   strcat(buffer, buf2);
   if (GET_MAX_HIT(ch) < 10)
      strcat(buffer, "   ");
   else if (GET_MAX_HIT(ch) < 100)
      strcat(buffer, "  ");
   else if (GET_MAX_HIT(ch) < 1000)
      strcat(buffer, " ");

   sprintf(buf2, "%s%d&0&8H&0  %3dv/%3dV] [%s]",
           CLR(ch, AUND), GET_MAX_HIT(ch), GET_MOVE(ch),
           GET_MAX_MOVE(ch), CLASS_ABBR(ch));
   strcat(buffer, buf2);
}

void print_group(struct char_data *ch)
{
   struct char_data *k;
   struct group_type *f;

   if (!ch->group_master && !ch->groupees)
     send_to_char("&2&8But you are not the member of a group!&0\r\n", ch);
   else {
      sprintf(buf, "%sYour group consists of:&0\r\n", CLR(ch, AUND));
      send_to_char(buf, ch);

      k = (ch->group_master ? ch->group_master : ch);
      if (CAN_SEE(ch, k)) {
         make_group_report_line(k, buf);
         strcat(buf, " (&0&2&bHead of group&0)\r\n");
         send_to_char(buf, ch);
      }

      for (f = k->groupees; f; f = f->next) {
         if (!CAN_SEE(ch,f->groupee))
            continue;

         make_group_report_line(f->groupee, buf);
         strcat(buf, "\r\n");
         send_to_char(buf, ch);
      }
   }
}

ACMD(do_group)
{
  struct char_data *tch;
  int level_diff;
  bool group_all = FALSE;

  one_argument(argument, arg);

  /* No argument, just asking for group info. */
  if (!*arg) {
    print_group(ch);
    return;
  }

  /* Only info is allowed while sleeping, not actual grouping. */
  if (!AWAKE(ch)) {
    send_to_char("In your dreams, or what?\r\n", ch);
    return;
  }

  if (!str_cmp("all", arg)) {
    group_all = TRUE;
    tch = NULL;
  }
  else if (!(tch = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return;
  }

  /* Attempt to remove yourself from your group. */
  if (ch == tch) {
    if (ch->group_master || ch->groupees)
      ungroup(ch, TRUE, FALSE);
    else
      send_to_char("&2&8You're not in a group!&0\r\n", ch);
    return;
  }

  /* You can't enroll someone if you're in a group and not the leader. */
  if (ch->group_master) {
    send_to_char("&2&8You cannot enroll group members without being head of a group.&0\r\n", ch);
    return;
  }

  if (group_all) {
    /* group all followers */
    bool found = FALSE;
    struct descriptor_data *d;
    struct char_data *gch;

    for (d = descriptor_list; d; d = d->next) {
      /* Check various reasons we should skip this player... */
      if (!IS_PLAYING(d)) {
         continue;
      }
      if (d->original) {
         gch = d->original;
      } else if (!(gch = d->character)) {
         continue;
      }
      if (!CAN_SEE(ch, gch)) {
         continue;
      }
      if (IS_GROUPED(gch)) {
         continue;
      }

      if (CONSENT(gch) != ch) {
        if (!(IS_NPC(gch) && gch->master == ch && EFF_FLAGGED(gch, EFF_CHARM))) {
           continue;
        }
      }

      level_diff = GET_LEVEL(ch) - GET_LEVEL(gch);

      if (max_group_difference && (level_diff > max_group_difference ||
          level_diff < -max_group_difference)) {
        sprintf(buf, "&2&8You cannot group %s, because the level difference is too great.\r\n"
                     "(The maximum allowable difference is currently %d.)&0\r\n",
                GET_NAME(gch), max_group_difference);
        send_to_char(buf, ch);
        continue;
      }

      add_groupee(ch, gch);
      found = TRUE;
    }

    if (!found)
      send_to_char("&2&8No one has consented you that is not already in a group.&0\r\n", ch);
    return;
  }

  if (tch->group_master && tch->group_master != ch) {
    send_to_char("&2&8That person is already in a group.&0\r\n", ch);
    return;
  }

  if (tch->groupees) {
    send_to_char("&2&8That person is leading a group.&0\r\n", ch);
    return;
  }

  /* Ok, if the target is in your group, remove them. */
  if (tch->group_master == ch) {
    ungroup(tch, TRUE, TRUE);
    return;
  }

  /* Check for consent unless it's a charmed follower */
  if (CONSENT(tch) != ch && GET_LEVEL(ch) < LVL_IMMORT) {
    if (!(IS_NPC(tch) && tch->master == ch && EFF_FLAGGED(tch, EFF_CHARM))) {
      act("&2&8You do not have $S consent.&0", TRUE, ch, NULL, tch, TO_CHAR);
      return;
    }
  }

  level_diff = GET_LEVEL(ch) - GET_LEVEL(tch);

  if (max_group_difference && (level_diff > max_group_difference ||
      level_diff < -max_group_difference)) {
    sprintf(buf, "&2&8You cannot group %s, because the level difference is too great.\r\n"
                 "(The maximum allowable difference is currently %d.)&0\r\n",
            GET_NAME(tch), max_group_difference);
    send_to_char(buf, ch);
    return;
  }

  add_groupee(ch, tch);
}


static void split_share(struct char_data *giver, struct char_data *receiver, int coins[])
{
  if (coins[PLATINUM] || coins[GOLD] || coins[SILVER] || coins[COPPER]) {
    statemoney(buf, coins);
    cprintf(receiver, "You %s %s.\r\n",
            giver == receiver ? "keep" : "receive", buf);
  }
  else
    send_to_char("You forego your share.\r\n", receiver);
  GET_PLATINUM(receiver) += coins[PLATINUM];
  GET_GOLD(receiver) += coins[GOLD];
  GET_SILVER(receiver) += coins[SILVER];
  GET_COPPER(receiver) += coins[COPPER];
  GET_PLATINUM(giver) -= coins[PLATINUM];
  GET_GOLD(giver) -= coins[GOLD];
  GET_SILVER(giver) -= coins[SILVER];
  GET_COPPER(giver) -= coins[COPPER];
}

void split_coins(struct char_data *ch, int coins[], unsigned int mode)
{
  int i, j, count, share[NUM_COIN_TYPES], remainder_start[NUM_COIN_TYPES];
  struct group_type *g;
  struct char_data *master;

  static struct char_data **members;
  static int max_members = 0;

  if (!max_members) {
     max_members = 16;
     CREATE(members, struct char_data *, max_members);
  }

  master = ch->group_master ? ch->group_master : ch;

  if (CAN_SEE(ch, master) && ch->in_room == master->in_room) {
    count = 1;
    members[0] = master;
  } else {
    count = 0;
  }

  for (g = master->groupees; g; g = g->next)
    if (CAN_SEE(ch, g->groupee) && ch->in_room == g->groupee->in_room) {
      if (count >= max_members) {
        max_members *= 2;
        RECREATE(members, struct char_data *, max_members);
      }
      members[count++] = g->groupee;
    }

  if (count == 1) {
    if (!IS_SET(mode, FAIL_SILENTLY))
      send_to_char("But you're the only one in your group here!\r\n", ch);
    return;
  }

  for (i = 0; i < NUM_COIN_TYPES; ++i) {
    share[i] = coins[i] / count;
    coins[i] -= share[i] * count;
    /* coins[i] now contains the remainder...but who gets it? */
    remainder_start[i] = number(0, count - 1);
  }

  /*
   * remainder_start[i] is the index of the 'first' group member who
   * gets an extra ith coin type.  If n = coins[i] is nonzero for a
   * particular i, then n group members, starting at the
   * remainder_start[i]th group member, will receive an extra coin.
   */

  send_to_char("&7&bYou split some coins with your group.&0\r\n", ch);
  act("&7&8$n splits some coins.&0", TRUE, ch, 0, 0, TO_ROOM);
  for (j = 0; j < count; ++j) {
    /*
     * A slight hack: for each coin type, if the current group
     * member i gets an extra coin, then add it to the share array,
     * split the coins, then remove it from the share array.  This
     * reduces split_share()'s complexity significantly.
     */
    for (i = 0; i < NUM_COIN_TYPES; ++i)
      if (coins[i] && ((j + count - remainder_start[i]) % count) < coins[i])
        ++share[i];

    split_share(ch, members[j], share);

    for (i = 0; i < NUM_COIN_TYPES; ++i)
      if (coins[i] && ((j + count - remainder_start[i]) % count) < coins[i])
        --share[i];
  }
}

ACMD(do_split)
{
  int coins[NUM_COIN_TYPES], i;

  if (IS_NPC(ch))
    return;

  if (!IS_GROUPED(ch)) {
    send_to_char("&2&8But you are not a member of any group!&0\r\n", ch);
    return;
  }

  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Split what?\r\n", ch);
    return;
  }

  if (!parse_money(&argument, coins)) {
    send_to_char("That's not a coin type.\r\n", ch);
    return;
  }

  if (!coins[PLATINUM] && !coins[GOLD] && !coins[SILVER] && !coins[COPPER]) {
    send_to_char("Split zero coins?  Done.\r\n", ch);
    return;
  }

  for (i = 0; i < NUM_COIN_TYPES; ++i)
    if (coins[i] > GET_COINS(ch)[i]) {
      cprintf(ch, "You don't have enough %s!\r\n", COIN_NAME(i));
      return;
    }

  split_coins(ch, coins, 0);
}


ACMD(do_use)
{
  struct obj_data *mag_item;
  int equipped = 1;

  half_chop(argument, arg, buf);
  if (!*arg) {
    sprintf(buf2, "What do you want to %s?\r\n", CMD_NAME);
    send_to_char(buf2, ch);
    return;
  }
  mag_item = GET_EQ(ch, WEAR_HOLD);

  if (!mag_item || !isname(arg, mag_item->name)) {
    switch (subcmd) {
    case SCMD_RECITE:
    case SCMD_QUAFF:
      equipped = 0;
      if (!(mag_item = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg)))) {
        cprintf(ch, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        return;
      }
      break;
    case SCMD_USE:
      /* Item isn't in first hand, now check the second. */
      mag_item = GET_EQ(ch, WEAR_HOLD2);
      if (!mag_item || !isname(arg, mag_item->name)) {
        cprintf(ch, "You don't seem to be holding %s %s.\r\n", AN(arg), arg);
        return;
      }
      break;
    default:
      log("SYSERR: Unknown subcmd passed to do_use");
      return;
      break;
    }
  }
  /* Do a level check -- Zantir 4/2/01 */
  if (GET_OBJ_LEVEL(mag_item) > GET_LEVEL(ch)) {
    send_to_char("That item is too powerful for you to use.\r\n", ch);
    return;
  }
  switch (subcmd) {
  case SCMD_QUAFF:
    if (GET_OBJ_TYPE(mag_item) != ITEM_POTION) {
      send_to_char("You can only quaff potions.\r\n", ch);
      return;
    }
    break;
  case SCMD_RECITE:
    if (GET_OBJ_TYPE(mag_item) != ITEM_SCROLL) {
      send_to_char("You can only recite scrolls.\r\n", ch);
      return;
    }
    break;
  case SCMD_USE:
    if ((GET_OBJ_TYPE(mag_item) != ITEM_WAND) &&
        (GET_OBJ_TYPE(mag_item) != ITEM_STAFF)) {
      send_to_char("You can't seem to figure out how to use it.\r\n", ch);
      return;
    }
    break;
  }

  mag_objectmagic(ch, mag_item, buf);
}



ACMD(do_wimpy)
{
  int wimp_lev;

  one_argument(argument, arg);

  if (!*arg) {
    if (GET_WIMP_LEV(ch)) {
      sprintf(buf, "Your current wimp level is %d hit points.\r\n",
              GET_WIMP_LEV(ch));
      send_to_char(buf, ch);
      return;
    } else {
      send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
      return;
    }
  }
  if (isdigit(*arg)) {
    if ((wimp_lev = atoi(arg))) {
      if (wimp_lev < 0)
        send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
      else if (wimp_lev > GET_MAX_HIT(ch))
        send_to_char("That doesn't make much sense, now does it?\r\n", ch);
      else if (wimp_lev > (GET_MAX_HIT(ch) >> 1))
        send_to_char("You can't set your wimp level above half your hit points.\r\n", ch);
      else {
        sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n",
                wimp_lev);
        send_to_char(buf, ch);
        GET_WIMP_LEV(ch) = wimp_lev;
      }
    } else {
      send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
      GET_WIMP_LEV(ch) = 0;
    }
  } else
    send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);

  return;

}


ACMD(do_display) {
  int i, x;

  one_argument(argument, arg);

  if (!*arg || !is_number(arg)) {
    send_to_char("The following pre-set prompts are availible...\r\n", ch);
    for (i = 0; default_prompts[i][0]; i++) {
      sprintf(buf, "%2d. %-20s %s\r\n", i,
              default_prompts[i][0], default_prompts[i][1]);
      send_to_char(buf, ch);
    }
    send_to_char("Usage: display <number>\r\n", ch);
    return;
  }

  i = atoi(arg);

  if (i < 0) {
    send_to_char("The number cannot be negative.\r\n", ch);
    return;
  }

  for (x = 0; default_prompts[x][0]; ++x);

  if (i >= x) {
    sprintf(buf, "The range for the prompt number is 0-%d.\r\n", x - 1);
    send_to_char(buf, ch);
    return;
  }

  if (GET_PROMPT(ch))
    free(GET_PROMPT(ch));

  GET_PROMPT(ch) = strdup(default_prompts[i][1]);
  sprintf(buf, "Set your prompt to the %s preset prompt.\r\n", default_prompts[i][0]);
  send_to_char(buf, ch);
}


ACMD(do_prompt)
{
  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "Your prompt is currently: %s\r\n",
            (GET_PROMPT(ch) ? escape_ansi(GET_PROMPT(ch)) : "n/a"));
    send_to_char(buf, ch);
    return;
  }

  delete_doubledollar(argument);

  if (GET_PROMPT(ch))
    free(GET_PROMPT(ch));

  GET_PROMPT(ch) = strdup(argument);

  sprintf(buf, "Okay, set your prompt to: %s\r\n", escape_ansi(argument));
  send_to_char(buf, ch);
}

const char *idea_types[] = {
   "bug",
   "typo",
   "idea",
   "note"
};

void send_to_mantis(struct char_data *ch, int category, const char *string)
{
  const char *cat;
  extern int make_count;

  if (!ch || !string || !*string)
    return;

  str_start(buf, sizeof(buf));

  str_catf(buf, "curl -s \"http://bug.fierymud.org/fiery_report.php?"
                      "plr=%s&room=%d&cat=%s&build=%d&msg=",
           GET_NAME(ch), CH_RVNUM(ch), idea_types[category], make_count);

  for (cat = string; *cat; ++cat)
    str_catf(buf, isalpha(*cat) ? "%c" : "%%%x", *cat);

  str_catf(buf, "\"");

  system(buf);
}

ACMD(do_gen_write)
{
   FILE *fl;
   char *filename, buf[MAX_STRING_LENGTH];
   struct stat fbuf;
   extern int max_filesize;
   time_t ct;

   ch = REAL_CHAR(ch);

   if (IS_NPC(ch)) {
      send_to_char("Monsters can't have ideas - go away.\r\n", ch);
      return;
   }

   skip_spaces(&argument);
   delete_doubledollar(argument);

   switch (subcmd) {
      case SCMD_NOTE:
         argument = one_argument(argument, arg);
         if (!*argument) {
            send_to_char("Usage: note <player> <text>\r\n", ch);
            return;
         }
         get_pfilename(arg, buf, NOTES_FILE);
         filename = buf;
         cprintf(ch, "%s\r\n", buf);
         break;
      case SCMD_BUG:
         filename = BUG_FILE;
         break;
      case SCMD_TYPO:
         filename = TYPO_FILE;
         break;
      case SCMD_IDEA:
         filename = IDEA_FILE;
         break;
      default:
         log("SYSERR: do_gen_write() received invalid subcmd");
         return;
   }

   if (!speech_ok(ch, TRUE)) {
      cprintf(ch, "You have been communicating too frequently recently.\r\n"
                  "Please idle momentarily and try to submit your %s again.\r\n",
              idea_types[subcmd]);
      return;
   }

   if (!*argument) {
      send_to_char("Please enter a message to go with that bug, idea, or typo.\r\n", ch);
      return;
   }

   mprintf(L_STAT, LVL_IMMORT, "%s by %s [%d]: %s",
         idea_types[subcmd], GET_NAME(ch), CH_RVNUM(ch), argument);

   if (stat(filename, &fbuf) >= 0 && fbuf.st_size >= max_filesize) {
      send_to_char("Sorry, the file is full right now.. try again later.\r\n", ch);
      return;
   }

   if (!(fl = fopen(filename, "a"))) {
      perror("do_gen_write");
      send_to_char("Could not open the file.  Sorry.\r\n", ch);
      return;
   }

   ct = time(0);
   strftime(buf1, 15, TIMEFMT_DATE, localtime(&ct));

   fprintf(fl, "%-8s (%11.11s) [%5d] %s\n", GET_NAME(ch), buf1,
      world[ch->in_room].vnum, argument);
   fclose(fl);
   send_to_char("Thanks for the bug, idea, or typo comment!\r\n", ch);

/*
 * If this is the production mud, send the bug/typo/idea to mantis
 */
#ifdef PRODUCTION
   switch (subcmd) {
      case SCMD_BUG:
      case SCMD_TYPO:
      case SCMD_IDEA:
        send_to_mantis(ch, subcmd, argument);
   }
#endif
}


ACMD(do_peace)
{
  struct char_data *vict, *next_v;
  one_argument(argument, arg);
  if (!is_abbrev(arg, "off")) {
    act("&7$n &4&bglows&0&7 with a &bbright white aura&0&7 as $e waves $s mighty hand!&0",
        FALSE, ch, 0, 0, TO_ROOM);
    send_to_room("&7&bA peaceful feeling washes into the room, dousing all violence!&0\r\n", ch->in_room);
    for (vict = world[ch->in_room].people; vict; vict = next_v) {
      next_v = vict->next_in_room;
      if (FIGHTING(vict))
        stop_fighting(vict);
    }
    SET_FLAG(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
  }
  else {
    act ("&7$n &4&bglows&0&7 with a &1&bbright red aura&0&7 as $e waves $s mighty hand!&0",
         FALSE,ch,0,0,TO_ROOM);
    send_to_room("&1&bThe peaceful feeling in the room subsides... You don't feel quite as safe anymore.&0\r\n",ch->in_room);
    REMOVE_FLAG(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
  }
}

ACMD(do_petition)
{
  struct descriptor_data *d;
  struct char_data *tch;

  if (!ch->desc)
    return;

  skip_spaces(&argument);
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("Petition is for those wimpy mortals!\r\n", ch);
    return;
  }
  if (!*argument) {
    send_to_char("Yes, but WHAT do you want to petition?\r\n", ch);
    return;
  }

  if (!speech_ok(ch, 0)) return;

  sprintf(buf, "&0&6You petition, '&b%s&0&6'&0\r\n", argument);
  send_to_char(buf, ch);

  sprintf(buf, "&0&6%s&0&6 petitions, '&b%s&0&6'&0\r\n",
          GET_NAME(REAL_CHAR(ch)), argument);

  for (d = descriptor_list; d; d = d->next) {
    if (!d->character)
      continue;
    tch = d->original ? d->original : d->character;
    if (PRF_FLAGGED(tch, PRF_NOPETI))
      continue;
    if (GET_LEVEL(tch) < LVL_IMMORT)
      continue;
    send_to_char(buf, d->character);
  }
}



/***************************************************************************
 * SUMMON_MOUNT
 ***************************************************************************/

ACMD(do_summon_mount)
{
  int i;
  struct follow_type *fol;

  struct mount_type {
    int min_level;
    int min_align;     /* absolute value */
    int hp_bonus;
    int mv_bonus;
    int pal_mob_vnum;
    int ant_mob_vnum;
  } mount_types[] = {
  /* lvl  align   hp   mv  pal  ant */
    {  0,     0,   0,   0,  48,  47 }, /* gelding  / mare       */
    { 30,   700,   0,   0,  49,  50 }, /* rouncy   / destrier   */
    { 60,   900,  50,  50,  45,  46 }, /* warhorse / nightmare  */
    { 90,  1000, 100, 100,  51,  52 }, /* courser  / shadowmare */
    { -1,    -1,   -1, -1,  -1,  -1 }
  };

  if (FIGHTING(ch)) {
    send_to_char("You can't concentrate enough while you are fighting.\r\n", ch);
    return;
  }

  if ((GET_CLASS(ch) != CLASS_PALADIN) && (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You have no idea what you are trying to accomplish.\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) < LVL_GOD) {
    for (fol = ch->followers; fol; fol = fol->next)
      if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
        send_to_char("You already have a mount!\r\n", ch);
        return;
      }
    if (GET_LEVEL(ch) < 15) {
      send_to_char("You are not yet deemed worthy of a mount (try gaining some more experience)\r\n", ch);
      return;
    }
    if (!IS_GOOD(ch) && !IS_NPC(ch) && (GET_CLASS(ch) == CLASS_PALADIN)) {
      send_to_char("Not even horses can stand your offensive presence!\r\n", ch);
      return;
    }
    if (CH_INDOORS(ch)) {
      send_to_char("Try again, OUTDOORS THIS TIME!\r\n", ch);
      return;
    }
    if (GET_COOLDOWN(ch, CD_SUMMON_MOUNT)) {
      i = GET_COOLDOWN(ch, CD_SUMMON_MOUNT) / (1 MUD_HR) + 1;
      if (i == 1)
        strcpy(buf1, "hour");
      else
        sprintf(buf1, "%d hours", i);
      cprintf(ch, "You must wait another %s before you can summon your mount.\r\n", buf1);
      return;
    }
  }

  send_to_char("You begin calling for a mount..\r\n", ch);

  for (i = 1; mount_types[i].min_level <= GET_LEVEL(ch) &&
          ((GET_CLASS(ch) == CLASS_PALADIN) ?
            (mount_types[i].min_align <= GET_ALIGNMENT(ch)) : /* Paladin */
            (-mount_types[i].min_align >= GET_ALIGNMENT(ch))) && /* Anti */
          mount_types[i].min_level > 0; i++);
  i--;
  if (GET_CLASS(ch) == CLASS_PALADIN)
    summon_mount(ch, mount_types[i].pal_mob_vnum,
            mount_types[i].hp_bonus + 2 * GET_LEVEL(ch),
            mount_types[i].mv_bonus + (GET_ALIGNMENT(ch) / 2) - 100);
  else
    summon_mount(ch, mount_types[i].ant_mob_vnum,
            mount_types[i].hp_bonus + 2 * GET_LEVEL(ch),
            mount_types[i].mv_bonus + 150 - (GET_ALIGNMENT(ch) / 4));
}


void summon_mount(struct char_data *ch, int mob_vnum, int base_hp, int base_mv)
{
  extern int ideal_mountlevel(struct char_data *ch);
  struct char_data *mount = NULL;

  if (!ch || (ch->in_room == NOWHERE))
     /* The summoner died in the meantime.  Its events should have been
      * pulled, but why trust that */
    return;

  mount = read_mobile(mob_vnum, VIRTUAL);

  if (!mount) {
    send_to_char("No mount could be found, please report this to a god.\r\n", ch);
    log("SYSERR: No mount found in summon_mount.");
    return;
  }

  char_to_room(mount, ch->in_room);  /*  was -2 */

  act("$N answers your summons!", TRUE, ch, 0, mount, TO_CHAR);
  act("$N walks in, seemingly from nowhere, and nuzzles $n's face.", TRUE, ch, 0, mount, TO_ROOM);
  SET_FLAG(EFF_FLAGS(mount), EFF_CHARM);
  SET_FLAG(EFF_FLAGS(mount), EFF_TAMED);
  SET_FLAG(MOB_FLAGS(mount), MOB_SUMMONED_MOUNT);
  add_follower(mount, ch);

  GET_LEVEL(mount) = 5;
  if (ideal_mountlevel(ch) < GET_LEVEL(mount))
     GET_LEVEL(mount) = MAX(0, ideal_mountlevel(ch));
  GET_MAX_HIT(mount) = MAX(10, base_hp + number(50, 100));
  GET_HIT(mount) = GET_MAX_HIT(mount);
  GET_MAX_MOVE(mount) = MAX(10, base_mv + number(0, 50));
  GET_MOVE(mount) = GET_MAX_MOVE(mount);
}

/***************************************************************************
 * end SUMMON_MOUNT
 ***************************************************************************/

/***************************************************************************
 * LAY_HANDS
 ***************************************************************************/

ACMD(do_layhand)
{
  struct char_data *vict;
  int dam = GET_DEX(ch) * GET_LEVEL(ch) / 10; /* Base damage/healing */

  /* Check for appropriate class */
  if (GET_CLASS(ch) != CLASS_PALADIN && GET_CLASS(ch) != CLASS_ANTI_PALADIN) {
    send_to_char("You don't have the ability to lay hands.\r\n", ch);
    return;
  }

  /* Make sure we haven't already used it for the day */
  if (GET_COOLDOWN(ch, CD_LAY_HANDS)) {
    send_to_char("You need more rest before laying hands again.\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  /*
   * Determine target.
   */
  if (*arg) {
    /* If a target was specified, attempt to use that. */
    if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      send_to_char(NOPERSON, ch);
      return;
    }
  }
  else {
    /* If no target was specified, default depending on class. */
    if (GET_CLASS(ch) == CLASS_PALADIN)
      vict = ch;
    else if (FIGHTING(ch)) /* Anti-paladin */
      vict = FIGHTING(ch);
    else {
      send_to_char("How about a target this time!?\r\n", ch);
      return;
    }
  }

  if (GET_CLASS(ch) == CLASS_PALADIN) {
    if (!IS_GOOD(ch)) {
      send_to_char("For your evil ways, your god has forsaken you!\r\n", ch);
      return;
    }

    /* Paladins heal all players, and good/neutral mobs, except undead. */
    if (IS_PC(vict) || (!IS_EVIL(vict) && GET_LIFEFORCE(vict) != LIFE_UNDEAD))
      dam = -1.5 * dam + number(0, 50);

    /* Paladins harm all evil mobs and undead, regardless of alignment. */
    else if (GET_LIFEFORCE(vict) == LIFE_UNDEAD)
      dam = 1.5 * dam + number(50, 150);
    else
      dam = 1.2 * dam + number(1, 50);
  }
  else { /* Anti-paladin */
    if (!IS_EVIL(ch)) {
      send_to_char("For your benevolent ways, your god has forsaken you!\r\n", ch);
      return;
    }

    /* Anti-paladins heal the undead, regardless of alignment. */
    if (GET_LIFEFORCE(vict) == LIFE_UNDEAD)
      dam = -1.5 * dam + number(1, 50);

    /* Anti-paladins have no effect on evils. */
    else if (IS_EVIL(vict)) {
      send_to_char("Your harmful touch has no affect on other evils.\r\n", ch);
      return;
    }

    /* Anti-paladins harm good and neutral mobs/players. */
    else
      dam = 1.2 * dam + number(1, 50);
  }

  damage(ch, vict, dam, SKILL_LAY_HANDS);

  if (GET_LEVEL(ch) < LVL_GOD)
    SET_COOLDOWN(ch, CD_LAY_HANDS, 4 MUD_HR);
}
/***************************************************************************
 * end LAY_HANDS
 ***************************************************************************/

/***************************************************************************
* CONTROL_UNDEAD
****************************************************************************/
/*
ACMD(do_control_undead)
{
  struct char_data *vict = NULL;
  char *to_vict = NULL, *to_room = NULL, *to_char = NULL;
  struct affected_type af;
  float control_duration = 0;

  if (GET_SKILL(ch, SKILL_CONTROL_UNDEAD) <= 0) {
    send_to_char("You don't know how to control undead!\r\n", ch);
    return;
  }

  if (FIGHTING(ch)) {
    send_to_char("You can't gain control the dead while fighting!\r\n",ch);
    return;
  }

  act("You attempt to gain control over the undead", FALSE, ch, 0, vict, TO_CHAR);

  for(vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
        if (!IS_NPC(vict)) {
                continue;
        } else {
                if (GET_LIFEFORCE(vict) == LIFE_UNDEAD) {
                        act("You focus your powers on controlling $N.",FALSE,ch,0,vict,TO_CHAR);

                            if (mag_savingthrow(vict, SAVING_SPELL)) {*/ /*test for not falling prey*/
                              /*to_char="$N resists your pitiful attempt to control $M.";
                            to_vict="&7&b$n tries to control you but fails!&0";
                            to_room="&7&b$n tries to control $N but nothing happens.&0";
                            act(to_char, FALSE, ch, 0, vict, TO_CHAR);
                            act(to_vict, FALSE, ch, 0, vict, TO_VICT);
                            act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
                        } else {
                            if (mag_savingthrow(vict, SAVING_SPELL)) { *//*test for getting scared*/
                                             /*to_char="$N starts to shake and gets very angry!";
                                    to_vict="&7&b$n tries to control you so you attack him!&0";
                                    to_room="&7&b$n tries to control $N, but $N becomes very angry!&0";
                                    act(to_char, FALSE, ch, 0, vict, TO_CHAR);
                                    act(to_vict, FALSE, ch, 0, vict, TO_VICT);
                                    act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
                                    SET_FLAG(MOB_FLAGS(vict), MOB_AGGRESSIVE);
                                    attack(vict, ch);
                            } else {
                                    to_char="$N starts to wither and falls under your control!";
                                    to_vict="&7&b$n gestures towards you and you feel your powers wither away!&0";
                                    to_room="&7&b$n gestures at $N and gains complete control over $M!&0";
                                    act(to_char, FALSE, ch, 0, vict, TO_CHAR);
                                    act(to_vict, FALSE, ch, 0, vict, TO_VICT);
                                    act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
                                        *//*set the mob as controlled (charmed) */
                                    /*control_duration = ((GET_LEVEL(ch) * 20) + (GET_SKILL(ch, SKILL_CONTROL_UNDEAD) * 2))/60;
                                    control_duration = 1;
                                    af.type = SKILL_CONTROL_UNDEAD;
                                    af.duration = control_duration;
                                    af.bitvector = 0;
                                    af.bitvector2 = 0;
                                    af.bitvector3 = EFF_CONTROLLED;
                                    af.modifier = 0;
                                    af.location = APPLY_NONE;
                                    affect_to_char(vict, &af);
                                    SET_FLAG(MOB_FLAGS(vict), MOB_CONTROLLED);
                                    af.type = SPELL_CHARM;
                                    af.duration = control_duration + 1;
                                    af.bitvector = EFF_CHARM;
                                    af.bitvector2 = 0;
                                    af.bitvector3 = 0;
                                    af.modifier = 0;
                                    af.location = APPLY_NONE;
                                    affect_to_char(vict, &af);
                                    add_follower(vict, ch);
                                    REMOVE_FLAG(MOB_FLAGS(vict), MOB_AGGRESSIVE);
                                    REMOVE_FLAG(MOB_FLAGS(vict), MOB_SPEC);
                            }
                        }
                }
        }
  }
  improve_skill(ch, SKILL_CONTROL_UNDEAD);

}*/

/***************************************************************************
* end CONTROL_UNDEAD
****************************************************************************/

/***************************************************************************
 * FIRST_AID
 ***************************************************************************/

#define LINTERP(min, pct, max) \
    ((min) + ((((max) - (min)) * pct) / 100.0))

ACMD(do_first_aid)
{
  double avg, dev, low, cap, heal;
  int orig_hp;

  if (FIGHTING(ch)) {
    send_to_char("You are too busy fighting to attend to yourself!\r\n",ch);
    return;
  }

  if (GET_COOLDOWN(ch, CD_FIRST_AID)) {
    send_to_char("You can only do this once per day.\r\n", ch);
    return;
  }

  if (GET_HIT(ch) >= GET_MAX_HIT(ch)) {
    send_to_char("You're already in pristine health!\r\n", ch);
    return;
  }

  avg = LINTERP(15.0, GET_SKILL(ch, SKILL_FIRST_AID), 45.0);
  dev = LINTERP( 3.0, GET_SKILL(ch, SKILL_FIRST_AID),  5.0);
  low = LINTERP(10.0, GET_SKILL(ch, SKILL_FIRST_AID), 35.0);
  cap = LINTERP(20.0, GET_SKILL(ch, SKILL_FIRST_AID), 50.0);

  heal = normal_random(avg, dev);
  if (heal < low) heal = low;
  if (heal > cap) heal = cap;

  orig_hp = GET_HIT(ch);
  GET_HIT(ch) += (GET_MAX_HIT(ch) * heal) / 100;
  if (GET_HIT(ch) > GET_MAX_HIT(ch))
    GET_HIT(ch) = GET_MAX_HIT(ch);

  cprintf(ch, "You attempt to render first aid unto yourself. "
              "(" AHGRN "%d" ANRM ")\r\n",
          GET_HIT(ch) - orig_hp);

  improve_skill(ch, SKILL_FIRST_AID);

  if (GET_LEVEL(ch) < LVL_IMMORT)
    SET_COOLDOWN(ch, CD_FIRST_AID, 24 MUD_HR);
}

/***************************************************************************
 * end FIRST_AID
 ***************************************************************************/

ACMD(do_ignore)
{
  struct char_data *target, *tch;
  char arg[MAX_STRING_LENGTH], buf[MAX_STRING_LENGTH];

  tch = REAL_CHAR(ch);

  if (IS_NPC(tch))
    return;

  one_argument(argument, arg);

  if (!*arg || is_abbrev(arg, "off")) {
    send_to_char("You feel sociable and stop ignoring anyone.\r\n", ch);
    tch->player_specials->ignored = NULL;
    return;
  }
  if (!(target = find_char_around_char(ch, find_vis_by_name(ch, arg))) || IS_NPC(target)) {
    send_to_char(NOPERSON, ch);
    return;
  }
  sprintf(buf, "You now ignore %s.\r\n", GET_NAME(target));
  send_to_char(buf, ch);
  tch->player_specials->ignored = target;
}

ACMD(do_point)
{
   int found;
   struct char_data *tch = NULL;
   struct obj_data *tobj = NULL;

   argument = one_argument(argument, arg);
   skip_spaces(&argument);

   if (!*arg) {
     send_to_char("Point at what?  Or whom?\r\n", ch);
     return;
   }

   if (!(found = generic_find(arg,
            FIND_OBJ_ROOM | FIND_CHAR_ROOM, ch, &tch, &tobj))) {
      send_to_char("Can't find that!\r\n", ch);
      return;
   }

   if (tobj) {
      act("You point at $p.", FALSE, ch, tobj, 0, TO_CHAR);
      act("$n points at $p.", TRUE, ch, tobj, 0, TO_ROOM);
      return;
   }

   if (!tch) {
      log("SYSERR: do_point had neither tch nor tobj");
      return;
   }

   if (tch == ch) {
      send_to_char("You point at yourself.\r\n", ch);
      act("$n points at $mself.", TRUE, ch, 0, 0, TO_ROOM);
      return;
   }

   if (GET_HIDDENNESS(tch) == 0) {
      act("You point at $N.", FALSE, ch, 0, tch, TO_CHAR);
      act("$n points at $N.", TRUE, ch, 0, tch, TO_NOTVICT);
      act("$n points at you.", FALSE, ch, 0, tch, TO_VICT);
   } else {
      GET_HIDDENNESS(tch) = 0;
      act("You point out $N's hiding place.", FALSE, ch, 0, tch, TO_CHAR);
      act("$n points out $N who was hiding here!", TRUE, ch, 0, tch, TO_NOTVICT);
      act("$n points out your hiding place!", TRUE, ch, 0, tch, TO_VICT);
   }
}

/***************************************************************************
 * $Log: act.other.c,v $
 * Revision 1.305  2011/03/16 13:39:58  myc
 * Fix all warnings for "the address of X will always evaluate to 'true'",
 * where X is a variable.
 *
 * Revision 1.304  2011/03/11 04:47:55  mud
 * Fix crash bug in shapechange that happens when a mob has
 * zero mv or hp and the player inhabiting the mob uses
 * 'shapechange me'.
 *
 * Revision 1.303  2010/06/09 22:32:01  mud
 * Moving toggle command and prf flags into prefs.[ch]
 *
 * Revision 1.302  2010/06/05 18:35:47  mud
 * Make pyre auto-target caster if sacrificial preference is
 * toggled on.
 *
 * Revision 1.301  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.300  2009/07/17 01:19:01  myc
 * Autosplit no longer gives an error message if no one else
 * is present.
 *
 * Revision 1.299  2009/07/17 00:48:17  myc
 * Implemented anon toggle privilege.
 *
 * Revision 1.298  2009/06/10 18:27:43  myc
 * When a druid shapechanges, add the druid's name as a keyword
 * to the shapechange's namelist.
 *
 * Revision 1.297  2009/06/09 21:48:21  myc
 * Broadcast a message to the clan when someone subclasses.
 *
 * Revision 1.296  2009/06/09 05:30:58  myc
 * The way clan titles are implemented has changed; title command
 * has been adjusted accordingly.  Also renamed the NoClanTell
 * toggle to NoClanComm to cover other clan communication.
 *
 * Revision 1.295  2009/03/20 15:38:53  jps
 * Fix message for stop guarding.
 *
 * Revision 1.294  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.293  2009/03/19 23:16:23  myc
 * parse_money now takes a char** and moves the pointer up to
 * just past any money phrase it parses.
 *
 * Revision 1.292  2009/03/16 22:15:05  jps
 * Don't let imms break up groups with a simple 'group <other-group-leader>'
 *
 * Revision 1.291  2009/03/09 21:43:50  myc
 * Make do_steal use statemoney.
 *
 * Revision 1.290  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.289  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.288  2009/03/09 04:50:38  myc
 * First aid now does a percentage of the max hit points, and is
 * always successful to some degree; uses a capped normal distribution.
 *
 * Revision 1.287  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.286  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.285  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.284  2009/03/07 22:29:13  jps
 * Use active_effect_from_char in aggro_remove_spells, so you get feedback
 * about those things being removed from you.
 *
 * Revision 1.283  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.282  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default; assert
 * L_NOFILE to prevent that.
 *
 * Revision 1.281  2009/02/05 17:23:39  myc
 * Make bug/typo/idea cause laryngitis.
 *
 * Revision 1.280  2009/01/19 09:25:23  myc
 * Changed summoned mount cooldown to count 12 hours from time
 * mount is lost.
 *
 * Revision 1.279  2009/01/19 03:03:39  myc
 * Allow guarding of NPCs.
 *
 * Revision 1.278  2009/01/18 07:23:03  myc
 * level command will show exp bar now too.
 *
 * Revision 1.277  2009/01/16 23:36:34  myc
 * Fix use of uninitialized variable in do_group().
 *
 * Revision 1.276  2008/09/28 19:13:25  jps
 * Send idea log messages to file.
 *
 * Revision 1.275  2008/09/28 19:07:14  jps
 * Adding -s to curl so its progress info doesn't go in syslog.
 * Changing the log message for gen_write.
 *
 * Revision 1.274  2008/09/21 21:50:22  jps
 * Call transfer_battle when shapechanging, so the "replacement" character
 * is embroiled in the conflict the same way the original was.
 *
 * Revision 1.273  2008/09/20 08:24:44  jps
 * Don't store potentially negative values in unsigned variables!!!!!!!!!1
 *
 * Revision 1.272  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.271  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.270  2008/09/07 20:05:27  jps
 * Renamed exp_to_level to exp_next_level to make it clearer what it means.
 *
 * Revision 1.269  2008/09/07 01:32:32  jps
 * Don't send a message to all when "save all" is entered.
 *
 * Revision 1.268  2008/09/06 22:06:21  myc
 * Fixed the naming of NoTell in toggle.
 *
 * Revision 1.267  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.266  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.265  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.264  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.263  2008/09/01 00:48:42  mud
 * Remove prototype which is imported from skills.h.
 *
 * Revision 1.262  2008/08/31 21:44:03  jps
 * Renamed StackObjs and StackMobs prefs to ExpandObjs and ExpandMobs.
 *
 * Revision 1.261  2008/08/31 21:05:38  myc
 * Abort command gives a useful message when not casting.
 *
 * Revision 1.260  2008/08/31 20:40:41  rbr
 * Changed do_group to be consent based instead of follow based
 *
 * Revision 1.259  2008/08/29 04:16:26  myc
 * Added toggles for stacking objects and stacking mobiles.
 *
 * Revision 1.258  2008/08/19 02:11:14  jps
 * Don't apply fluid/rigidity restrictions to immortals.
 *
 * Revision 1.257  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.256  2008/08/16 23:04:03  jps
 * Added speech_ok() to comm.h.
 *
 * Revision 1.255  2008/08/15 03:51:35  myc
 * Bugs/typos/ideas reported by players on the production MUD
 * get automatically sent to Mantis now.
 *
 * Revision 1.254  2008/07/27 05:29:43  jps
 * Using remove_player_from_game and save_player_char functions.
 *
 * Revision 1.253  2008/07/18 17:25:34  jps
 * Add room identification to camping syslog messages.
 *
 * Revision 1.252  2008/06/21 06:59:38  jps
 * In split_coins(), don't assume that the group leader is in the room.
 *
 * Revision 1.251  2008/06/05 02:07:43  myc
 * Rewrote rent-saving code to use ascii-format files.
 *
 * Revision 1.250  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.249  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.248  2008/05/14 05:10:44  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.247  2008/05/11 05:45:26  jps
 * alter_hit now takes the killer.  update_pos is removed.
 *
 * Revision 1.246  2008/04/19 21:10:13  myc
 * Removed some old unused sorting code.
 *
 * Revision 1.245  2008/04/13 00:57:34  jps
 * Added a toggle for auto-treasure looting.
 *
 * Revision 1.244  2008/04/12 21:13:18  jps
 * Using new header file magic.h.
 *
 * Revision 1.243  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.242  2008/04/05 18:07:09  myc
 * Re-implementing stealth for hide points.
 *
 * Revision 1.241  2008/04/05 16:49:07  myc
 * Oops, fixing autosplit/autoloot messages again?
 *
 * Revision 1.240  2008/04/05 15:30:38  myc
 * Slightly changing the split algorithm to more evenly distribute the
 * remainder coins.
 *
 * Revision 1.239  2008/04/05 05:04:24  myc
 * Fixed messages for autoloot/autosplit toggles.
 *
 * Revision 1.238  2008/04/05 03:30:55  jps
 * Remove the ability to see others' toggles from mortals.
 *
 * Revision 1.237  2008/04/04 22:19:06  jps
 * Put the right feedback messages with tog autoloot and tog autosplit.
 *
 * Revision 1.236  2008/04/04 20:37:42  myc
 * Made autoloot and autosplit level 0.
 *
 * Revision 1.235  2008/04/03 17:37:21  jps
 * Added autoinvis toggle for deities.
 *
 * Revision 1.234  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.233  2008/04/02 05:36:19  myc
 * Added the autosplit toggle and functionalized the split command.
 * Also added the autoloot toggle and removed the noname toggle.
 *
 * Revision 1.232  2008/04/02 04:55:59  myc
 * Redesigned the split command to randomly distribute extra monies.
 *
 * Revision 1.231  2008/04/02 03:24:44  myc
 * Rewrote group code and removed all major group code.
 *
 * Revision 1.230  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.229  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.228  2008/03/26 23:32:00  jps
 * Prevent stealing things when in a fluid state.
 *
 * Revision 1.227  2008/03/26 16:44:36  jps
 * Replaced all checks for undead race with checks for undead lifeforce.
 * Replaced the undead race with the plant race.
 *
 * Revision 1.226  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.225  2008/03/19 18:29:59  myc
 * Shapeshifted creatures inherit the sex from their original players.
 *
 * Revision 1.224  2008/03/19 04:32:14  myc
 * Fixed typo in do_quit.
 *
 * Revision 1.223  2008/03/17 15:31:27  myc
 * Remove the camp event flag when leaving the game for proper clean-up.
 *
 * Revision 1.222  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.221  2008/03/10 18:01:17  myc
 * Instead of taking off the berserk effect in multiple places, like
 * when camping, we'll do it when saving the player.
 *
 * Revision 1.220  2008/03/08 22:29:06  myc
 * Moving shapechange and chant to the cooldown system.
 *
 * Revision 1.219  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.218  2008/03/06 05:11:51  myc
 * Combined the 'saved' and 'unsaved' portions of the char_specials and
 * player_specials structures by moving all fields of each saved structure
 * to its parent structure.  Also combined the skills array from the
 * player and mob structures since they are identical.
 *
 * Revision 1.217  2008/03/05 05:21:56  myc
 * Got rid of old save_char_file_u declaration.
 *
 * Revision 1.216  2008/03/05 03:03:54  myc
 * Changed the spell memory structures.  Also new ascii pfiles are in,
 * so the do_save and do_title commands have been updated.
 * Also made the default prompts (that were in the do_display command)
 * constants in constants.c.
 *
 * Revision 1.215  2008/02/24 17:31:13  myc
 * Added an OLCComm toggle which allows you to receive communication
 * while in OLC.  Also a NoClanTell toggle for members of a clan.
 *
 * Revision 1.214  2008/02/11 21:04:01  myc
 * Make the do_not_here command placeholder for spec-procs give a little
 * more information on /why/ you cannot do that here.
 *
 * Revision 1.213  2008/02/10 20:28:42  jps
 * Use correct method of getting quest name
 *
 * Revision 1.212  2008/02/10 20:19:19  jps
 * Further quest numbering tweaks/fixes.
 *
 * Revision 1.211  2008/02/10 19:43:38  jps
 * Subclass quests now store the target subclass as a quest variable rather
 * than as 3 bits in the quest id.
 *
 * Revision 1.210  2008/02/09 21:57:13  myc
 * The hide command won't cause hide points to go negative anymore.
 *
 * Revision 1.209  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.
 *
 * Revision 1.208  2008/02/09 18:29:11  myc
 * The event code now handles freeing of event objects.  The camp
 * event now uses an event flag instead of storing the camp event
 * in a special field.
 *
 * Revision 1.207  2008/02/09 06:19:44  jps
 * Add "nohints" toggle for whether you receive command suggestions
 * after entering a typo.
 *
 * Revision 1.206  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.205  2008/02/02 19:38:20  myc
 * Adding 'permanent titles' to players, so they can switch between
 * any of the titles they've earned.
 *
 * Revision 1.204  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.203  2008/01/27 21:09:12  myc
 * Quitting or camping removes berserk status and all rage from a
 * character.  Replaced hit() references with TYPE_UNDEFINED with
 * attack().
 *
 * Revision 1.202  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.201  2008/01/26 20:44:39  myc
 * Fix crash bug because of uninitialized memory in do_shapechange.
 *
 * Revision 1.200  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.199  2008/01/26 12:30:19  jps
 * Use skills.h to import improve_skill().
 *
 * Revision 1.198  2008/01/23 14:13:54  jps
 * Added function creature_allowed_skill(), so the shapechanged critters
 * can have certain skills that override the question of whether a
 * non-humanoid should be allowed to have it.
 *
 * Revision 1.197  2008/01/23 05:13:37  jps
 * Add the point command, which is used to unhide someone you've spotted.
 *
 * Revision 1.196  2008/01/10 06:46:53  myc
 * Moved the messages for the lay hands skill into the messages file.
 * The new healing message in the message struct allows lay hands to
 * simply use damage() instead of copying its functionality.
 *
 * Revision 1.195  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.194  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.193  2008/01/05 06:17:36  myc
 * Fixing the valid prompt range for do_display.
 *
 * Revision 1.192  2008/01/05 05:42:30  jps
 * Changed name of save_char() to save_player().
 *
 * Revision 1.191  2008/01/04 05:17:52  jps
 * Provide some feedback when you don't get the shapechange
 * creature you requested.
 *
 * Revision 1.190  2008/01/04 05:14:52  jps
 * Exempt gods from align restrictions when shapechanging.
 *
 * Revision 1.189  2008/01/04 01:43:10  jps
 * Removed unused function do_practice.
 *
 * Revision 1.188  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.187  2008/01/01 03:05:20  jps
 * Add the year to timestamps on entries in ideas, bugs, typos, and notes.
 *
 * Revision 1.186  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.185  2007/12/21 07:52:11  myc
 * It is no longer possible to damage an immortal with lay hands.
 *
 * Revision 1.184  2007/12/20 23:09:03  myc
 * Updated do_level to use the new exp_message function that replaced
 * exp_mesg.  do_display now offers two new prompts; the old 'Complete'
 * is now 'Standard', and there are two new 'Complete' prompts.  Also
 * fixed a memory leak in do_display.
 *
 * Revision 1.183  2007/12/20 17:18:21  myc
 * You can no longer steal in the PK arena.
 *
 * Revision 1.182  2007/12/19 20:36:16  myc
 * save_char() no longer requires you to specify the save room (which
 * wasn't being used anyway).  Renamed the 'Cloaked' toggle to 'RoomVis'.
 *
 * Revision 1.181  2007/11/18 16:51:55  myc
 * Improve steal chance when hidden.
 *
 * Revision 1.180  2007/10/27 18:15:10  myc
 * Fixing hide calculation to use dex and int right.
 *
 * Revision 1.179  2007/10/12 20:32:22  jps
 * Apply laryngitis to petitioning.
 *
 * Revision 1.178  2007/10/11 20:14:48  myc
 * Removed all chant commands from here, and merged its functionality with
 * the magic system.  do_cast now covers the chant command via SCMD_CHANT.
 * The songs command is now in act.informative.c.  The actual chants are
 * in magic.c, except peace which is now a manual "spell".
 *
 * Revision 1.177  2007/10/09 02:38:00  myc
 * When a druid shapechanges back to their player form, any objects or
 * money the druid had is transfered to the player.
 *
 * Revision 1.176  2007/10/02 02:52:27  myc
 * Added a forward pointer on the char_data struct so we can check to see
 * who someone is shapeshifted/switched into.  Shapechanged druids will
 * be able to see how long they have been shapechanged/how long until they
 * can shapechange again.  The timer isn't a static 5 tics anymore;
 * instead it's variable based on the time spent shapechanged.  Fixed some
 * typos.  Added lag to steal command.  Moved do_grep and do_report to
 * act.comm.c.  Toggle command can now be used while shapechanged, and it
 * applies to the original player character.  Petition now goes to the
 * player's descriptor even when they are shapechanged.  Cleaned up
 * various other commands.
 *
 * Revision 1.175  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  AFF_HIDE, AFF_SNEAK, and ITEM_HIDDEN
 * are now unused.  Sneak chance is now calculated based on hiddenness.
 * do_sneak is gone, and do_hide has changed.  Also got rid of toggle
 * nonamebroadcast, and replaced it with toggle cloaked for imms, which
 * lets you appear visible to people in the room, but not everyone else.
 *
 * Revision 1.174  2007/09/15 15:36:48  myc
 * Natures embrace now sets camouflage bit, which lets you be hidden as long
 * as you are outside.
 *
 * Revision 1.173  2007/09/12 22:23:04  myc
 * Removed autoexit set from shapechange since it's set in db.c now.
 *
 * Revision 1.172  2007/09/11 19:44:48  myc
 * Gods can turn into aquatic creatures whereever they please.
 *
 * Revision 1.171  2007/09/11 19:41:51  myc
 * Renamed 'sting ray' as 'stingray'
 * /s
 *
 * Revision 1.170  2007/09/11 16:34:24  myc
 * Rewrote shapechange command, added 9 new aquatic mobs, and animal
 * types (damager, tank, travel, tracker).  Certain shapechange mobs now
 * also have special skills.
 *
 * Revision 1.169  2007/09/03 23:59:43  jps
 * Added macro ADDED_WEIGHT_OK for testing whether a char can have an
 * object added to its inventory.  Avoids an integer overflow problem
 * that could occur if an object's weight was near maxint.
 *
 * Revision 1.168  2007/09/03 22:44:09  jps
 * Fix douse message when a fountain is used.  Make douse automatically
 * successful when in a water room of any kind, or a swamp or beach room.
 *
 * Revision 1.167  2007/08/27 21:18:00  myc
 * You can now queue up commands while casting as well as abort midcast.
 * Casting commands such as look and abort are caught and interpreted
 * before the input is normally queued up by the game loop.
 *
 * Revision 1.166  2007/08/26 01:55:41  myc
 * Fire now does real damage.  All fire spells have a chance to catch the
 * victim on fire.  Mobs attempt to douse themselves.
 *
 * Revision 1.165  2007/08/18 21:23:40  jps
 * Remove a lot of redundant code from do_shapechange. Changed syntax so that
 * shapechange only takes one argument: class (mammal, bird, reptile) or
 * the name of the creature.
 *
 * Revision 1.164  2007/08/16 11:52:47  jps
 * Remove defunct do_old_subclass. The magic of RCS means you can find it
 * again if you REALLY want to.
 *
 * Revision 1.163  2007/08/14 22:43:07  myc
 * Adding 'stealth' skill as secondary effect for sneak.  Stealth
 * makes a person untrackable and invisible on 'who -z'.
 * Cleaned up hide code.
 *
 * Revision 1.162  2007/08/14 10:43:11  jps
 * Laryngitis will prevent you from consenting, because the consent command
 * is one way to pester people at a distance.
 *
 * Revision 1.161  2007/08/05 20:21:51  myc
 * Cleaned up bandage code.
 *
 * Revision 1.160  2007/08/05 01:50:16  myc
 * Follow, guard, and consent all follow similar usage patterns now.
 * <action> off/self/me stops whatever it is, <action> target starts
 * on the target, and <action> shows who is currently targeted.
 *
 * Revision 1.159  2007/08/04 21:13:10  myc
 * Cleaned up layhands code.
 *
 * Revision 1.158  2007/08/03 22:00:11  myc
 * Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.157  2007/08/03 03:51:44  myc
 * check_pk is now attack_ok, and covers many more cases than before,
 * including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
 * offensive attacks now use attack_ok to determine whether an attack is
 * allowed.
 *
 * Revision 1.156  2007/07/18 23:07:10  jps
 * do_consent will inform you when you're trying to consent the person
 * you've already consented, rather than un-consenting and reconsenting.
 *
 * Revision 1.155  2007/07/18 16:50:09  jps
 * Oops... forgot to free the event when someone camped, then
 * mounted something, then was stopped from camping. Ok, fixed.
 *
 * Revision 1.154  2007/07/14 02:16:22  jps
 * Make certain that the level of a summoned mount is low enough
 * that the summoner may easily ride it.
 *
 * Revision 1.153  2007/07/14 00:37:56  jps
 * Make characters save after changing their title.
 *
 * Revision 1.152  2007/07/14 00:05:49  jps
 * Allow grouping of your pets.
 *
 * Revision 1.151  2007/07/02 04:58:22  jps
 * Stop counting items in inventory at the *end* of the camp event.
 *
 * Revision 1.150  2007/07/02 04:55:03  jps
 * Made the steal skill only improve when the victim is awake.
 *
 * Revision 1.149  2007/06/25 06:23:08  jps
 * Prevent camping while mounted.
 *
 * Revision 1.148  2007/06/24 01:16:55  jps
 * Add spaces to the end of the predetermined prompts, now that the code
 * doesn't automatically add one.
 *
 * Revision 1.147  2007/06/03 03:28:21  jps
 * Fixed typo in "first aid".
 *
 * Revision 1.146  2007/05/28 07:03:17  jps
 * Cause prompt-set feedback to escape color codes.
 *
 * Revision 1.145  2007/05/28 05:38:25  jps
 * Setting up camp sends message to the room.
 *
 * Revision 1.144  2007/04/25 08:04:41  jps
 * Tell little rogues they'll need more experience to sneak.
 *
 * Revision 1.143  2007/04/25 07:53:01  jps
 * Allow 'visible' to properly terminate hiding.
 *
 * Revision 1.142  2007/04/19 00:53:54  jps
 * Create macros for stopping spellcasting.
 *
 * Revision 1.141  2007/04/18 00:32:01  myc
 * Camping now removes the meditate flag to prevent syserrs when chars
 * log back on.  Also, changed the way first aid rolls dice to save some
 * clock cycles - the average values are still the same.
 *
 * Revision 1.140  2007/04/18 00:18:48  myc
 * Rewrote 'subclass' command to hopefully be less buggy.  It at least has
 * better messages now.
 *
 * Revision 1.139  2007/04/18 00:05:59  myc
 * Prompt parser has been totally rewritten so it won't print garbage
 * characters anymore.  Also, some new features were added.  Giving the
 * prompt command back to mortals.
 *
 * Revision 1.138  2007/04/11 14:24:00  jps
 * Fix warning about function get_check_money.
 *
 * Revision 1.137  2007/04/11 14:15:28  jps
 * Give money piles proper keywords and make them dissolve when stolen.
 *
 * Revision 1.136  2007/04/11 09:57:55  jps
 * Fix formatting of stolen money string.
 *
 * Revision 1.135  2007/03/27 04:27:05  myc
 * Fixed typos in hide, steal, and toggle.  Revamped summon mount to offer
 * several different mounts based on alignment and level.  Lay hands will
 * heal an anti-paladin with vamp touch now.
 *
 * Revision 1.134  2007/02/04 18:12:31  myc
 * Page length now saves as a part of player specials.
 *
 * Revision 1.133  2006/12/08 05:06:58  myc
 * Removed coins enum from do_steal, now constants in structs.h.
 *
 * Revision 1.132  2006/11/27 02:26:45  jps
 * Let people see consent messages even when asleep.
 *
 * Revision 1.131  2006/11/27 02:18:42  jps
 * Let imms camp in air rooms.
 *
 * Revision 1.130  2006/11/21 20:53:52  jps
 * Align values in group printout
 *
 * Revision 1.129  2006/11/20 22:24:17  jps
 * End the difficulties in interaction between evil and good player races.
 *
 * Revision 1.128  2006/11/18 06:41:16  jps
 * Fixed typos when toggling anonymous.
 *
 * Revision 1.127  2006/11/16 18:42:45  jps
 * Awareness of new surroundings when magically tranported is related to
 * being asleep, blindness, etc.
 *
 * Revision 1.126  2006/11/14 21:30:44  jps
 * Stop invis'd gods from being seen by lower level imms as they camp
 *
 * Revision 1.125  2006/11/13 16:34:43  jps
 * You can't steal items over your level any more.
 * Blind mobs are no longer immune from stealing.
 *
 * Revision 1.124  2006/11/12 02:31:01  jps
 * You become unmounted when magically moved to another room.
 *
 * Revision 1.123  2006/11/08 08:34:03  jps
 * Fix gender of pronoun when trying to group someone without consent.
 *
 * Revision 1.122  2006/11/08 08:03:47  jps
 * Typo fix "You better leave art to the thieves." ->
 * "You'd better leave that art to the rogues."
 *
 * Revision 1.121  2006/11/07 09:51:48  jps
 * Allow wands and staves held in second hand to be used.
 *
 * Revision 1.120  2006/11/07 09:35:38  jps
 * Stop sending spurious "You petition, ''" when empty petition sent.
 *
 * Revision 1.119  2006/07/20 07:41:07  cjd
 * Typo fixes.
 *
 * Revision 1.118  2006/04/28 21:14:02  mud
 * Layhands patch, with silent damage so it isn't pulling from
 * messages file and shorter colorized messages.
 *
 * Revision 1.117  2006/04/28 08:37:02  mud
 * Made some quick changes for testing purposes but still can't
 * seem to find where layhands is going awry. - RLS
 *
 * Revision 1.116  2006/04/28 01:41:12  rls
 * Frog!  evil and !undead check for layhands... whee!
 *
 * Revision 1.115  2006/04/28 01:26:58  rls
 * More todo with layhands.
 *
 * Revision 1.114  2006/04/28 00:27:33  rls
 * Fix to layhands, bad argument checking and added
 * healing effect for antis laying undead... fun!
 *
 * Revision 1.113  2005/06/16 02:07:07  cjd
 * adjusted the minimum level to subclass from 5 to 10
 *
 * Revision 1.112  2005/06/10 18:07:16  cjd
 * oops, had to fix a PK check for pally's. also
 * included a fix for damage amounts shown in the
 * case of healing.
 *
 * Revision 1.111  2005/06/09 21:59:17  cjd
 * Fixed error where vict was not being defined before usage
 *
 * Revision 1.110  2005/03/30 18:34:16  rls
 * Added missing external declaration for pk_allowed
 *
 * Revision 1.109  2005/03/24 02:54:14  djb
 * Added PK checks for layhands.
 *
 * Revision 1.108  2005/02/14 10:17:28  rls
 * Fixed missing damage messages in layhands function, as well
 * made it to where anti's don't heal anything.  Still needs
 * to have pk / charmed mobs by PC safeguards in place.
 *
 * Revision 1.107  2005/02/14 02:35:29  djb
 * Changed the consent/group/mgroup functions to allow for good/evil race groups. Changed layhands around, and added layhands for anti-paladins.
 * Also added code for a new spell control_undead, but left it commented out for now so that I can finish it up later.
 *
 * Revision 1.106  2004/11/15 01:03:37  rsd
 * Added code from Acerite to add a save all option to save
 * every player online without a force all save.
 *
 * Revision 1.105  2003/07/27 01:22:02  jjl
 * A fix to prevent crashes caused by camping and then memorizing.
 *
 * Revision 1.104  2003/07/15 02:32:04  jjl
 * Fixed lay hands.
 *
 * Revision 1.103  2003/06/28 03:08:09  jjl
 * Added back messages for paladins, since they don't go through damage.  Added a no-argument check
 * .  Both for layhands that is
 *
 * Revision 1.102  2003/06/25 04:52:22  jjl
 * Updated lay hands to use skill messages.
 *
 * Revision 1.101  2003/06/25 03:32:34  jjl
 * *** empty log message ***
 *
 * Revision 1.100  2003/06/25 03:28:16  jjl
 * Fixed the delay on lay hands.  Got that was dumb.
 *
 * Revision 1.99  2003/06/25 02:21:03  jjl
 * Revised lay hands to not suck.
 *
 * Revision 1.98  2003/06/23 02:55:02  jjl
 * Added failure message to guard, moved the skill improvement.
 *
 * Revision 1.97  2003/06/23 01:47:09  jjl
 * Added a NOFOLLOW flag, and the "note" command, and show notes <player>
 *
 * Revision 1.96  2003/06/21 03:18:29  jjl
 * *** empty log message ***
 *
 * Revision 1.95  2003/06/21 01:01:08  jjl
 * Modified rogues.  Removed circle - backstab is now circlicious.  Updated
 * damage on backstab to give a little more pop.  Throatcut is now a once a day.
 *
 * Revision 1.94  2003/04/03 01:05:17  jjl
 * Changed the stun on hide, because it was like 16 seconds before.
 *
 * Revision 1.93  2002/12/04 09:03:55  rls
 * changed max_group_diff to an external call for max group level diff code
 *
 * Revision 1.92  2002/12/04 06:11:09  jjl
 * Well, that was dumb.  In group "all", it was checking to see if there was a
 * level difference as a prerequisite for checking the range.  It should have
 * been checking if the max range was nonzero instead.
 *
 * Revision 1.91  2002/11/30 19:39:38  jjl
 * Added the ability for GAME commands to have integer values, and added a
 * GROUPING game command, that allows you to set a maximum level difference
 * between group masters and potential groupees..
 *
 * Revision 1.90  2002/10/19 18:29:21  jjl
 * Recall spec procs.  This file has the event handler for it
 *
 * Revision 1.89  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.88  2002/05/18 12:57:55  dce
 * Fixed it so rhino's are a lower level...same problem
 * as anaconda's
 *
 * Revision 1.87  2002/05/13 21:20:26  dce
 * Fixed that anaconda problem where it would make you level 100.
 *
 * Revision 1.86  2002/05/05 22:04:28  mpg
 * modified "report" so you can no longer see (wiz)invizies names when they report
 *
 * Revision 1.85  2002/04/26 21:36:30  mpg
 * when grouped with wizesies, you no longer get info typing "group"
 * unless you've got their consent.
 *
 * Revision 1.84  2002/04/26 20:22:21  mpg
 * modified "chant" to work show correct gender in messages.
 *
 * Revision 1.83  2002/04/26 18:54:28  mpg
 * modified "group" so group info can be accessed while sleeping.
 * forming of groups etc. still restricted to POS_RESTING and up.
 * NB: while .
 *
 * Revision 1.82  2002/02/25 10:59:41  rls
 * Added apostrophe and punctuation to display string in do_report
 *
 * Revision 1.81  2001/12/07 02:09:56  dce
 * Linkdead players will now lose exp when they die.
 * Linkdead shapechanged players will now shapechange
 * to their original form before linking out.
 *
 * Revision 1.80  2001/11/15 19:52:48  rjd
 * Plural rules fixed for splitting coins.
 *
 * Revision 1.79  2001/11/15 18:04:38  rjd
 * Coin splitter message for the splitter corrected.
 *
 * Revision 1.78  2001/10/17 21:04:05  rjd
 * Tweaked "split" command so that splitter (giver) now sees how much of the
 * split currency (s)he kept. Also cleaned up the message to the receivers,
 * which had a spelling error (was "recieve", now is correctly "receive").
 *
 * Revision 1.77  2001/10/12 21:21:12  rjd
 * Extension of the "save" command: Gods can now type "save <playername>" to save a player
 * to file. This works on any player loaded into the game, whether by a player logging in
 * normally or a god linkloading the player.
 *
 * Revision 1.76  2001/04/06 00:58:41  dce
 * Subclassing should show in the syslog.
 *
 * Revision 1.75  2001/04/02 23:31:21  dce
 * Put a level restriction on potions and wands, etc...
 *
 * Revision 1.74  2001/04/01 21:59:31  mtp
 * changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
 *
 * Revision 1.73  2001/03/25 00:44:46  dce
 * Bug/Idea/Typo gives better output
 *
 * Revision 1.72  2001/03/13 20:52:09  dce
 * Made the summonable mounts more sane. No longer a level 70+
 * horse with 1500+ hps.
 *
 * Revision 1.71  2001/03/07 01:45:18  dce
 * Added checks so that players can not kill shapechanged players and
 * vise versa. Hopefully I didn't miss any...
 *
 * Revision 1.70  2001/03/04 17:33:19  dce
 * Shapechange does not ding you a hp.
 *
 * Revision 1.69  2001/03/03 18:07:10  dce
 * Gods should not fail specific shapechanges.
 *
 * Revision 1.68  2001/02/24 16:47:57  dce
 * Phase 3 of shapechange.
 *
 * Revision 1.67  2001/02/24 04:04:05  dce
 * Phase 2 of shapechange
 *
 * Revision 1.66  2001/02/21 01:06:19  dce
 * Phase 1 of the shapechange re-write
 *
 * Revision 1.65  2001/02/12 23:22:42  mtp
 * min level for subclass changed to 5
 *
 * Revision 1.64  2001/02/11 22:29:39  rsd
 * disabled the bind command
 *
 * Revision 1.63  2001/02/03 00:56:51  mtp
 * do a race check before starting subclass quest
 * also returing different codes so that calling procs can do something sensible
 * on failure
 *
 * Revision 1.62  2001/02/01 02:36:21  dce
 * Somone was sending a buf to a char without ever putting anything
 * in the buf...in the disband command. It is now fixed.
 *
 * Revision 1.61  2001/01/16 00:33:56  mtp
 * make sure spell/skill list is clean after subclass
 *
 * Revision 1.60  2001/01/10 23:30:24  mtp
 * cant camp with more than 50 items
 *
 * Revision 1.59  2000/11/26 10:03:57  jimmy
 * Fixed do_sneak.  The affectation was not being properly initilized.
 * Added init to 0 for aff2/aff3.  This fixes the do_stat_character
 * bug of a ch who's sneaking.
 *
 * Revision 1.58  2000/11/20 04:21:41  rsd
 * Added all i freaking zillion back rlog messages from
 * prior to the addition of the $log$ string. phew.
 *
 * Revision 1.57  2000/11/07 01:42:04  mtp
 * changes to do_subclass to use the subclass quest style
 * old method (using can_subclass_plyr saved as do_old_subclass in case it doesnt work)
 *
 * Revision 1.56  2000/10/25 23:43:54  rsd
 * Fixed the if_pkill check on psteal to allow
 * mobiles to steal from players, DOH.
 *
 * Revision 1.55  2000/10/21 12:05:57  mtp
 * improved subclass code, now looks for cvariable can_subclass_<name> = <subclass>
 * to allow a QM to be waiting for multiple potential finishers
 *
 * Revision 1.54  2000/10/19 01:54:08  mtp
 * added new subclass code, dependent on two variable (global set on mob) use_subclass and can_subclass, if the player
 * with name == can_subclass types subclass in the room with a teacher mob, and the value of use_subclass is valid for
 * that user, then they are subclassed.
 *
 * Revision 1.53  2000/10/13 17:50:39  cmc
 * re-instituted modified level command
 * required to re-implement "level gain"
 *
 * Revision 1.52  2000/09/28 03:22:09  rsd
 * made no gossip level 0
 *
 * Revision 1.51  2000/06/04 03:59:07  rsd
 * altered summon mount so the mounts increase in strength as
 * the pally's increase in level and align.
 * The algorythm could use some tweaking, I'm open to suggestion
 *
 * Revision 1.50  2000/05/21 23:55:59  rsd
 * Altered do_prompt to point mortals at the display command.
 *
 * Revision 1.49  2000/05/10 22:09:24  rsd
 * added a check to do_douse to check for fountains
 * in the room.  If there is a fountain in the room
 * the player automatically gets doused w/o any checks.
 * Cool eh? :)
 *
 * Revision 1.48  2000/04/22 22:30:04  rsd
 * Changed the comment header, also retabbed and braced sections of the code.
 * Altered toggle to show the numbers associated with wimpy and pagelength.
 * Also, toggle will return a message to the player if the toggle with a
 * bogus argument.
 *
 * Revision 1.47  2000/04/17 00:52:33  rsd
 * removed mana from do_display and made do prompt level 101
 * or higher.
 *
 * Revision 1.46  2000/03/08 11:14:42  cso
 * do_steal only checked for gold. made it check all 4 coin types.
 *
 * Revision 1.45  1999/12/13 05:16:49  cso
 * made do_steal check the pk_allowed game setting
 *
 * Revision 1.44  1999/11/28 22:44:48  cso
 * do_prompt: commented out a CREATE that was causing a mem leak
 *
 * Revision 1.43  1999/10/06 17:55:24  rsd
 * Removed the AFK code from the end of the prompt and moved
 * it to comm.c
 *
 * Revision 1.42  1999/09/16 01:47:17  dce
 * Song levels moved up.
 *
 * Revision 1.41  1999/09/14 00:27:17  dce
 * Monks hit and dam toned down.
 *
 * Revision 1.40  1999/09/10 00:49:52  mtp
 * an[4~[4~bandage can KILL now if done badly for too long
 *
 * Revision 1.39  1999/09/10 00:01:53  mtp
 * added a delay (for mortals) to bandage
 *
 * Revision 1.38  1999/09/07 23:26:53  mtp
 * removed mana from 'print_group' output
 *
 * Revision 1.37  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.36  1999/09/05 05:04:43  mud
 * reverted to previous version to remove compile errors until they can be fixed
 *
 * Revision 1.35  1999/09/03 23:22:50  mtp
 * remove mana from group output
 *
 * Revision 1.34  1999/09/03 23:06:54  mtp
 * added some IS_FIGHTING checks
 *
 * Revision 1.33  1999/08/13 15:31:01  dce
 * Allow camping to be seen in normal syslog.
 *
 * Revision 1.32  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.31  1999/08/10 20:51:42  dce
 * Qucik
 * Quick fix to a bug where players can get a free rippost
 * if they don't even have the skill.
 *
 * Revision 1.30  1999/08/09 22:37:11  mtp
 * Added <AFK> to players prompt if toggled AFK (includes changes of prompt)
 *
 * Revision 1.29  1999/07/24 21:01:37  dce
 * Sublass function
 *
 * Revision 1.28  1999/07/23 01:57:18  mud
 * fixed do gen toggle, thanks
 * fixed from printing double line at end, removed ooc and slowns
 * as well as case sensitivity. I'm so insensitive.
 *
 * Revision 1.27  1999/07/10 05:51:23  mud
 * Ok, removed the OOC from being a toggle, commented it out of
 * certain sections, and just cut it out of other parts of do_toggle.
 *
 * Revision 1.26  1999/07/09 21:00:06  mud
 * moved the ascii terminator in the toggle display and
 * added a header line above the cute format characters.
 *
 * Revision 1.25  1999/07/07 23:21:45  jimmy
 * Fixed do_group to check for consent of following npc's.  This was an
 * oversight on my part when fixing the command in the last ci.
 * gurlaek
 *
 * Revision 1.24  1999/07/07 15:46:44  jimmy
 * fixed the problems with trophys not being updated when in a group.
 * This was A bug created by my cut and pasting when i fixed the
 * void * function pointer warnings. All better now :)
 * --gurlaek 7/7/1999
 *
 * Revision 1.23  1999/07/06 02:53:50  mud
 * Completely reworked the toggle command to make it easier to
 * read.  It's now 3 columns of stuff instead of that blue
 * one line stuff that scrolled off the screen.
 * Gurlaek showed me how to do it.
 *
 * Revision 1.22  1999/06/11 16:56:55  jimmy
 * Ok, fixed do_quit to check for fighting and also not crash when mortally
 * wounded.  This was done in die() by checking for killer=NULL.
 * since no one killed you if you quit while morted the die code
 * didn't know how to deal with a NULL killer.
 * --Gurlaek 6/11/1999
 *
 * Revision 1.21  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.20  1999/05/26 01:50:28  mud
 * made summon mount level 15 instead of 25 in the
 * if (GET_LEVEL(ch) < XX) statement
 *
 * Revision 1.19  1999/05/04 19:41:51  dce
 * Fixed some typos
 *
 * Revision 1.18  1999/05/02 17:10:17  mud
 * made toggeling of autoexits level 0 as opposed to
 * LVL_IMMORT or whatever it was before.
 *
 * Revision 1.17  1999/05/01 18:01:21  dce
 * Allow players to drop all eq and quit.
 *
 * Revision 1.16  1999/04/29 19:02:04  mud
 * made anonymous level 50
 *
 * Revision 1.15  1999/04/23 01:51:22  jimmy
 * fixed camp crashbug.  This occured when someone type camp twice.
 * I added checks to EVENTFUNC(camp_event) to determine if someone was
 * already camping, and also NULLed freed pointers SCREAM!.  Seems to work
 * fine.  --Gurlaek.
 *
 * Revision 1.14  1999/04/16 03:55:09  dce
 * Removed some things temporarly until they can be fixed.
 *
 * Revision 1.13  1999/03/30 18:59:31  jen
 * Fixed a toggle bug... JEN II
 * Was allowing proper lvl players to toggle, but not displaying
 * anything except stuff available to ppl BELOW your lvl
 *
 * Revision 1.12  1999/03/26 19:44:35  jen
 * Added a mortal gossip channel with 103+ godly control
 *
 * Revision 1.11  1999/03/08 21:09:52  dce
 * Adjusts chant semantics
 *
 * Revision 1.10  1999/03/08 04:47:16 dce
 * Chant semantics added.
 *
 * Revision 1.9  1999/03/07 05:01:09  dce
 * Chant finishes and wearoff messages.
 *
 * Revision 1.8  1999/03/06 23:51:54  dce
 * Add's chant songs, and can only chant once every four hours
 *
 * Revision 1.7  1999/03/05 20:02:36  dce
 * Chant added to, and songs craeted
 *
 * Revision 1.6  1999/02/26 22:30:30  dce
 * Added skeleton for chant skill
 *
 * Revision 1.5  1999/02/20 18:41:36  dce
 * Adds improve_skill calls so that players can imprve their skills.
 *
 * Revision 1.4  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.3  1999/02/06 17:27:25  jimmy
 * God loadrooms now set permanently until changed.
 * if you drop link however you come back where you
 * dropped.
 *
 * Revision 1.2  1999/02/03 22:54:08  jimmy
 * removed some toggles from mortal chars
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial Revision
 *
 ***************************************************************************/
@


1.305
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.304 2011/03/11 04:47:55 mud Exp myc $
d256 1
a256 1
    log(buf);
d2839 4
@


1.304
log
@Fix crash bug in shapechange that happens when a mob has
zero mv or hp and the player inhabiting the mob uses
'shapechange me'.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.303 2010/06/09 22:32:01 mud Exp mud $
d998 1
a998 1
  if (!arg || !*arg) {
d1053 1
a1053 1
  if(!arg)
d2163 1
a2163 1
  if (!arg || !*arg || !is_number(arg)) {
d2839 5
@


1.303
log
@Moving toggle command and prf flags into prefs.[ch]
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.302 2010/06/05 18:35:47 mud Exp mud $
d490 9
a498 2
      GET_HIT(player) = (GET_HIT(ch) * GET_MAX_HIT(player)) / GET_MAX_HIT(ch);
      GET_MOVE(player) = (GET_MOVE(ch) * GET_MAX_MOVE(player)) / GET_MAX_MOVE(ch);
d700 8
a707 2
  GET_HIT(mob) = (GET_HIT(ch) * GET_MAX_HIT(mob)) / GET_MAX_HIT(ch);
  GET_MOVE(mob) = (GET_MOVE(ch) * GET_MAX_MOVE(mob)) / GET_MAX_MOVE(ch);
d2839 3
@


1.302
log
@Make pyre auto-target caster if sacrificial preference is
toggled on.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.301 2010/06/05 14:56:27 mud Exp mud $
a2326 339
#define TOG_OFF 0
#define TOG_ON  1

ACMD(do_toggle)
{
  int i = 0, column, wimp_lev, page_length;
  bool set;
  long result = 0;
  struct char_data *tch;

  struct set_struct
  {
    char *cmd;
    int level;
    int bitvector;
  }

  /**********************
    These match SCMD defines in interpreter.h, to add or
    remove a toggle you must also update the SCMD's in
    interpreter.h.
  *********************/

  fields[] = {
    { "NoSummon",   LVL_IMMORT, PRF_SUMMONABLE },
    { "NoHassle",   LVL_IMMORT, PRF_NOHASSLE },
    { "Brief",      0,          PRF_BRIEF },
    { "Compact",    0,          PRF_COMPACT },
    { "NoTell",     0,          PRF_NOTELL },
    { "AFK",        0,          PRF_AFK },
    { "NoShout",    0,          PRF_DEAF },
    { "NoGossip",   0,          PRF_NOGOSS },
    { "NoHints",    0,          PRF_NOHINTS },
    { "NoWiznet",   LVL_IMMORT, PRF_NOWIZ },
    { "Quest",      LVL_IMMORT, PRF_QUEST },
    { "RoomFlags",  LVL_IMMORT, PRF_ROOMFLAGS },
    { "NoRepeat",   0,          PRF_NOREPEAT },
    { "Holylight",  LVL_IMMORT, PRF_HOLYLIGHT },
    { "Autoexit",   0,          PRF_AUTOEXIT },
    { "NoPetition", LVL_IMMORT, PRF_NOPETI },
    { "AutoSplit",  0,          PRF_AUTOSPLIT },
    { "Anonymous",  50,         PRF_ANON },
    { "ShowVnums",  LVL_IMMORT, PRF_SHOWVNUMS },
    { "Wimpy",      0,          0 },
    { "NiceArea",   0,          PRF_NICEAREA },
    { "Vicious",    0,          PRF_VICIOUS },
    { "Passive",    0,          PRF_PASSIVE },
    { "PageLength", 0,          0 },
    { "NoFollow",   0,          PRF_NOFOLLOW },
    { "RoomVis",    LVL_IMMORT, PRF_ROOMVIS },
    { "NoClanComm", 0,          PRF_NOCLANCOMM },
    { "OLCComm",    LVL_IMMORT, PRF_OLCCOMM },
    { "LineNums",   0,          PRF_LINENUMS },
    { "AutoLoot",   0,          PRF_AUTOLOOT },
    { "AutoTreas",  0,          PRF_AUTOTREAS },
    { "AutoInvis",  LVL_IMMORT, 0 },
    { "ExpandObjs", 0,          PRF_EXPAND_OBJS },
    { "ExpandMobs", 0,          PRF_EXPAND_MOBS },
    { "Sacrificial",LVL_IMMORT, PRF_SACRIFICIAL },
    { "\n",         0,          0 },
    /* If you add another toggle, add a corresponding SCMD_ define in
     * interpreter.h, even if you don't intend to use it. */

  };
  char *tog_messages[][2] =
  {
        /*00*/ {"You are now safe from summoning by other players.\r\n",
                 "You may now be summoned by other players.\r\n"},
        /*01*/ {"Nohassle disabled, mobs will attack you now.\r\n",
                 "Nohassle enabled, mobs will leave you alone now.\r\n"},
        /*02*/ {"Brief mode off.\r\n",
                 "Brief mode on.\r\n"},
        /*03*/ {"Compact mode off.\r\n",
                 "Compact mode on.\r\n"},
        /*04*/ {"You can now hear tells.\r\n",
                 "You are now deaf to tells.\r\n"},
        /*05*/ {"You are no longer AFK.\r\n",
                 "You are now AFK.\r\n"},
        /*06*/ {"You can now hear shouts.\r\n",
                 "You are now deaf to shouts.\r\n"},
        /*07*/ {"You can now hear gossip.\r\n",
                 "You are now deaf to gossip.\r\n"},
        /*08*/ {"You will receive hints when you enter typos.\r\n",
                 "You will not receive any hints when entering typos.\r\n"},
        /*09*/ {"You can now hear the Wiz-channel.\r\n",
                 "You are now deaf to the Wiz-channel.\r\n"},
        /*10*/ {"You are no longer part of the Quest.\r\n",
                 "Okay, you are part of the Quest!\r\n"},
        /*11*/ {"You will no longer see the room flags.\r\n",
                 "You will now see the room flags.\r\n"},
        /*12*/ {"You will now have your communication repeated.\r\n",
                 "You will no longer have your communication repeated.\r\n"},
        /*13*/ {"HolyLight mode off.\r\n",
                 "HolyLight mode on.\r\n"},
        /*14*/ {"Autoexits disabled.\r\n",
                 "Autoexits enabled.\r\n"},
        /*15*/ {"You will now receive petitions from mortals!\r\n",
                 "You are now deaf to petitions!\r\n"},
        /*16*/ {"You will no longer automatically split coins from corpses.\r\n",
                 "You will now automatically split coins from corpses!\r\n"},
        /*17*/ {"You are no longer anonymous.\r\n",
                 "You are now anonymous.\r\n"},
        /*18*/ {"You will no longer see vnums.\r\n",
                 "You will now see vnums.\r\n"},
        /*19*/ {NULL,
                 NULL},
        /*20*/ {"Your area spells will now hit your race align in towns.\r\n",
                 "Your area spells won't hit your race align in towns.\r\n"},
        /*21*/ {"You feel nice and no longer vicious.\r\n",
                 "You will now kill mortally wounded victims.\r\n"},
        /*22*/ {"You will now auto-engage upon being offensively cast upon.\r\n",
                 "You will no longer auto-engage upon being offensively cast upon.\r\n"},
        /*23*/ {NULL,
                 NULL},
        /*24*/ {"You will now let anyone follow you.\r\n",
                 "You will now avoid attracting new followers.\r\n"},
        /*25*/ {"You will now only be seen by people who might normally see you.\r\n",
                 "You will now be seen by anyone in the same room as you.\r\n"},
        /*26*/ {"You will now hear clan communication.\r\n",
                 "You will no longer hear clan communication.\r\n"},
        /*27*/ {"You will no longer hear communication while in OLC.\r\n",
                 "You will now hear communication while in OLC.\r\n"},
        /*28*/ {"Line numbers will not be displayed when entering the string editor.\r\n",
                 "Line numbers will be displayed when entering the string editor.\r\n"},
        /*29*/ {"You will no longer automatically loot items from corpses.\r\n",
                 "You will now automatically loot items from corpses.\r\n"},
        /*30*/ {"You will no longer automatically loot treasure from corpses.\r\n",
                 "You will now automatically loot treasure from corpses.\r\n"},
        /*31*/ {NULL,
                 NULL},
        /*32*/ {"Objects will now stack in lists.\r\n",
                "Objects will no longer stack in lists.\r\n"},
        /*33*/ {"Mobiles will now stack in lists.\r\n",
                "Mobiles will no longer stack in lists.\r\n"},
        /*34*/ {"When you cast sacrificial spells, they may now auto-target you.\r\n",
                "When you cast sacrificial spells, they will no longer auto-target you.\r\n"},
  };

  argument = one_argument(argument, arg);
  tch = REAL_CHAR(ch);

  /*
   * First, see if the player wants to toggle something.
   */
  if (*arg)
    for (; *fields[i].cmd != '\n'; ++i)
      if (is_abbrev(arg, fields[i].cmd))
        if (GET_LEVEL(tch) >= fields[i].level ||
            (i == SCMD_ANON && PRV_FLAGGED(tch, PRV_ANON_TOGGLE)))
          if (i != SCMD_NOCLANCOMM || GET_CLAN(tch))
            break;

  if (!*arg || *fields[i].cmd == '\n') {
    /* Show a player his/her fields. */

    if (*arg) {
      if (GET_LEVEL(ch) < LVL_GOD || !(tch = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
        send_to_char("Toggle what!?\r\n", ch);
        return;
      }
      /* Handle switched/shapechanged players. */
      tch = REAL_CHAR(tch);
    }

    if (IS_NPC(tch)) {
      act("$N is an NPC.  They don't have toggles!", FALSE, ch, 0, tch, TO_CHAR);
      return;
    }

    strcpy(buf, "             FieryMUD TOGGLES!  (See HELP TOGGLE)\r\n"
                "===============================================================\r\n");
    for (column = i = 0; *fields[i].cmd != '\n'; ++i) {
      if (i != SCMD_ANON || !PRV_FLAGGED(tch, PRV_ANON_TOGGLE))
        if (fields[i].level > GET_LEVEL(tch))
          continue;
      if (i == SCMD_NOCLANCOMM && !GET_CLAN(tch))
        continue;

      set = FALSE;
      switch (i) {
        case SCMD_WIMPY:
          if ((set = (1 && GET_WIMP_LEV(tch))))
            sprintf(buf2, "%d", GET_WIMP_LEV(tch));
          else
            strcpy(buf2, "NO");
          break;
        case SCMD_PAGELENGTH:
          sprintf(buf2, "%d", GET_PAGE_LENGTH(tch));
          set = GET_PAGE_LENGTH(tch) != 22;
          break;
        case SCMD_AUTOINVIS:
          if (GET_AUTOINVIS(tch) == -1) {
             strcpy(buf2, "NO");
          } else {
             set = TRUE;
             sprintf(buf2, "%d", GET_AUTOINVIS(tch));
          }
          break;
        default:
          set = 1 && PRF_FLAGGED(tch, fields[i].bitvector);
          strcpy(buf2, YESNO(set));
          break;
      }
      sprintf(buf, "%s %s%11s  %5s&0 %s", buf, set ? QHWHT : QWHT,
              fields[i].cmd, buf2, column == 2 ? "\r\n" : "| ");
      if (++column >= 3)
        column = 0;
    }
    if (column)
      strcat(buf, "\r\n");
    strcat(buf, "===============================================================\r\n");
    send_to_char(buf, ch);
    return;
  }

  if (IS_NPC(tch))
    return;

  switch (i) {
    case SCMD_WIMPY:
      one_argument(argument, arg);
      if (!*arg) {
        if (GET_WIMP_LEV(tch)) {
          sprintf(buf, "Your current wimp level is %d hit points.\r\n", GET_WIMP_LEV(tch));
          send_to_char(buf, ch);
        } else
          send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
      }
      else if (isdigit(*arg)) {
        if ((wimp_lev = atoi(arg))) {
          if (wimp_lev < 0)
            send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
          else if (wimp_lev > GET_MAX_HIT(tch))
            send_to_char("That doesn't make much sense, now does it?\r\n", ch);
          else {
            sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n", wimp_lev);
            send_to_char(buf, tch);
            GET_WIMP_LEV(tch) = wimp_lev;
          }
        } else {
          send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
          GET_WIMP_LEV(tch) = 0;
        }
      } else
        send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);
      return;
    case SCMD_PAGELENGTH:
      one_argument(argument, arg);
      if (!*arg) {
        if (GET_PAGE_LENGTH(tch) > 0) {
          sprintf(buf, "Your current page length is %d.\r\n", GET_PAGE_LENGTH(tch));
          send_to_char(buf, ch);
        } else {
          send_to_char("Your page length is not valid.  Reset to 22.\r\n", ch);
          GET_PAGE_LENGTH(tch) = 22;
        }
      }
      else if (isdigit(*arg)) {
        if ((page_length = atoi(arg))) {
          if (page_length < 1)
            send_to_char("Invalid page length.\r\n", ch);
          else if (page_length > 50)
            send_to_char("Max page length is 50 right now.\r\n", ch);
          else {
            sprintf(buf, "Your new page length is %d lines.\r\n", page_length);
            send_to_char(buf, ch);
            GET_PAGE_LENGTH(tch) = page_length;
          }
        }
        else {
          send_to_char("Page length restored to default (22 lines).\r\n", ch);
          GET_PAGE_LENGTH(tch) = 22;
        }
      } else
        send_to_char("Specify at how many lines you want your page length to be.  (0 for default length)\r\n", ch);
      return;
    case SCMD_AUTOINVIS:
      any_one_arg(argument, arg);
      if (!*arg) {
         if (GET_AUTOINVIS(tch) == -1)
            send_to_char("Autoinvis is off.\r\n", ch);
         else if (GET_AUTOINVIS(tch) < -1 || GET_AUTOINVIS(tch) > GET_LEVEL(tch)) {
            sprintf(buf, "Your autoinvis is an invalid value: %d\r\n", GET_AUTOINVIS(tch));
            send_to_char(buf, ch);
         } else if (GET_AUTOINVIS(tch) == GET_LEVEL(tch)) {
            sprintf(buf, "Autoinvis is maxxed to &5&b%d&0.\r\n", GET_AUTOINVIS(tch));
            send_to_char(buf, ch);
         } else {
            sprintf(buf, "Autoinvis is set to &6&b%d&0.\r\n", GET_AUTOINVIS(tch));
            send_to_char(buf, ch);
         }
      } else {
         if (isdigit(*arg) || *arg == '-')
            i = atoi(arg);
         else if (!strncasecmp(arg, "off", 4))
            i = -1;
         else if (!strncasecmp(arg, "on", 3))
            i = GET_LEVEL(tch);
         else {
            send_to_char("Invalid input: autoinvis is a number between 0 and your level.\r\n", ch);
            send_to_char("You may also enter -1 or 'off' to disable it, or 'on' which will\r\n", ch);
            send_to_char("set it to the maximum value: your level.\r\n", ch);
            return;
         }

         if (GET_AUTOINVIS(tch) == i) {
            if (i == -1)
               send_to_char("Your autoinvis is already off.\r\n", ch);
            else if (i == GET_LEVEL(tch)) {
               sprintf(buf, "Your autoinvis is already maxxed to %d.\r\n", GET_AUTOINVIS(tch));
               send_to_char(buf, ch);
            } else {
               sprintf(buf, "Your autoinvis is already %d.\r\n", i);
               send_to_char(buf, ch);
            }
         } else if (i < -1 || i > GET_LEVEL(tch)) {
            send_to_char("Invalid input: autoinvis is a number between -1 and your level.\r\n", ch);
         } else {
            GET_AUTOINVIS(tch) = i;
            if (i == -1)
               send_to_char("Autoinvis off.\r\n", ch);
            else {
               sprintf(buf, "Your autoinvis is set to %d.\r\n", i);
               send_to_char(buf, ch);
            }
         }
      }
      return;
    default:
      result = PRF_TOG_CHK(tch, fields[i].bitvector);
      break;
    }

  if (result)
    send_to_char(tog_messages[i][TOG_ON], ch);
  else
    send_to_char(tog_messages[i][TOG_OFF], ch);
}

d2826 4
@


1.301
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.300 2009/07/17 01:19:01 myc Exp mud $
d2385 1
d2461 2
d3165 3
@


1.300
log
@Autosplit no longer gives an error message if no one else
is present.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.299 2009/07/17 00:48:17 myc Exp myc $
d36 1
d3162 4
@


1.299
log
@Implemented anon toggle privilege.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.298 2009/06/10 18:27:43 myc Exp myc $
d1920 1
a1920 1
void split_coins(struct char_data *ch, int coins[])
d1953 2
a1954 1
    send_to_char("But you're the only one in your group here!\r\n", ch);
d2028 1
a2028 1
  split_coins(ch, coins);
d3161 3
@


1.298
log
@When a druid shapechanges, add the druid's name as a keyword
to the shapechange's namelist.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.297 2009/06/09 21:48:21 myc Exp myc $
d2468 5
a2472 3
      if (GET_LEVEL(tch) >= fields[i].level && is_abbrev(arg, fields[i].cmd))
        if (i != SCMD_NOCLANCOMM || GET_CLAN(tch))
          break;
d2494 3
a2496 2
      if (fields[i].level > GET_LEVEL(tch))
        continue;
d3160 4
@


1.297
log
@Broadcast a message to the clan when someone subclasses.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.296 2009/06/09 05:30:58 myc Exp myc $
d697 3
d3157 3
@


1.296
log
@The way clan titles are implemented has changed; title command
has been adjusted accordingly.  Also renamed the NoClanTell
toggle to NoClanComm to cover other clan communication.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.295 2009/03/20 15:38:53 jps Exp myc $
d284 5
a288 5
    sprintf(buf, "You have successfully subclassed as %s!\r\n",
          with_indefinite_article(CLASS_FULL(ch)));
    send_to_char(buf, ch);
    sprintf(buf, "%s has subclassed to %s", GET_NAME(ch), CLASS_FULL(ch));
    mudlog(buf, BRF, LVL_GOD, TRUE);
d3154 5
@


1.295
log
@Fix message for stop guarding.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.294 2009/03/20 13:56:22 jps Exp jps $
a1374 2
  void clan_set_title(struct char_data *ch);

d1385 2
a1386 2
    if (strlen(argument) > MAX_TITLE_LENGTH) {
      sprintf(buf, "Sorry, titles can't be longer than %d characters.\r\n",
a1387 2
      send_to_char(buf, ch);
    }
d1390 1
a1390 2
      sprintf(buf, "Okay, you're now %s %s.\r\n", GET_NAME(ch), GET_TITLE(ch));
      send_to_char(buf, ch);
d1399 2
a1400 1
    if (GET_CLAN(ch) && IS_CLAN_MEMBER(ch)) ++titles;
d1408 1
a1408 1
      sprintf(buf, "You have earned the following titles:\r\n"
d1412 1
a1412 1
          sprintf(buf, "%s  %d) %s\r\n", buf, titles + 1,
d1416 5
a1420 8
      if (GET_CLAN(ch) && IS_CLAN_MEMBER(ch)) {
        if ((which = find_clan_by_id(GET_CLAN(ch))) >= 0)
          sprintf(buf, "%s  %d) %s %s\r\n", buf, ++titles,
                  clans[which].rank[GET_CLAN_RANK(ch) - 1],
                  clans[which].abbreviation);
      }
      strcat(buf, "Use 'title <number>' to switch your title.\r\n");
      send_to_char(buf, ch);
d2372 1
a2372 1
    { "NoClanTell", 0,          PRF_NOCTELL },
d2439 2
a2440 2
        /*26*/ {"You will now hear clan tell.\r\n",
                 "You will no longer hear clan tells.\r\n"},
d2466 1
a2466 1
        if (i != SCMD_NOCTELL || GET_CLAN(tch))
d2491 1
a2491 1
      if (i == SCMD_NOCTELL && !GET_CLAN(tch))
d3154 3
@


1.294
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.293 2009/03/19 23:16:23 myc Exp jps $
d100 1
a100 1
    act("You stop guarding &N.", FALSE, ch, 0, ch->guarding, TO_CHAR);
d3161 3
@


1.293
log
@parse_money now takes a char** and moves the pointer up to
just past any money phrase it parses.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.292 2009/03/16 22:15:05 jps Exp myc $
d2027 1
a2027 1
      cprintf(ch, "You don't have enough %s!\r\n", coin_names[i]);
d3161 4
@


1.292
log
@Don't let imms break up groups with a simple 'group <other-group-leader>'
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.291 2009/03/09 21:43:50 myc Exp jps $
d2015 1
a2015 1
  if (!parse_money(argument, coins)) {
d2027 1
a2027 2
      sprintf(buf, "You don't have enough %s!\r\n", coin_names[i]);
      send_to_char(buf, ch);
d3161 3
@


1.291
log
@Make do_steal use statemoney.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.290 2009/03/09 20:36:00 myc Exp myc $
d1872 1
a1872 4
    if (GET_LEVEL(ch) < LVL_IMMORT)
      send_to_char("&2&8That person is leading a group.&0\r\n", ch);
    else
      add_groupee(tch, ch);
d3162 3
@


1.290
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.289 2009/03/09 05:41:31 jps Exp myc $
d1166 2
a1167 4
   int percent, eq_pos, ohoh = 0;
   int copper, silver, gold, plat;
   char coinbuf[20];
   int hascoin = 0, numcoins = 0;
d1296 1
a1296 1
            if ((plat = (int) ((GET_PLATINUM(vict) * number(1, 10)) / 100))) {
d1300 1
a1300 1
            if ((gold = (int) ((GET_GOLD(vict) * number(1, 10)) / 100))) {
d1304 1
a1304 1
            if ((silver = (int) ((GET_SILVER(vict) * number(1, 10)) / 100))) {
d1308 1
a1308 1
            if ((copper = (int) ((GET_COPPER(vict) * number(1, 10)) / 100))) {
d1312 11
a1322 40
            if (copper + silver + gold + plat > 0) {
               GET_COPPER(ch) += copper;
               GET_COPPER(vict) -= copper;
               GET_SILVER(ch) += silver;
               GET_SILVER(vict) -= silver;
               GET_GOLD(ch) += gold;
               GET_GOLD(vict) -= gold;
               GET_PLATINUM(ch) += plat;
               GET_PLATINUM(vict) -= plat;
               strcpy(buf, "Woohoo! You stole ");
               if (plat) {
                  sprintf(coinbuf, "%d platinum", plat);
                  strcat(buf, coinbuf);
                  hascoin = 1;
               }
               if (gold) {
                  sprintf(coinbuf, "%s%s%d gold", (hascoin && (numcoins > 2)) ? ", " :
                     "", (hascoin && (lastcoin == GOLD)) ? " and " : "", gold);
                  strcat(buf, coinbuf);
                  hascoin = 1;
               }
               if (silver) {
                  sprintf(coinbuf, "%s%s%s%d silver",
                     (hascoin && (numcoins > 2)) ? ", " : "",
                     (lastcoin == SILVER && numcoins == 2) ? " " : "",
                     (hascoin && (lastcoin == SILVER)) ? "and " : "",
                     silver);
                  strcat(buf, coinbuf);
                  hascoin = 1;
               }
               if (copper) {
                  sprintf(coinbuf, "%s%s%s%d copper",
                     (hascoin && (numcoins > 2)) ? ", " : "",
                     numcoins == 2 ? " " : "",
                     (hascoin && (lastcoin == COPPER)) ? "and " : "",
                     copper);
                  strcat(buf, coinbuf);
               }
               strcat(buf, ".\r\n");
               send_to_char(buf, ch);
a1910 4
    if (giver == receiver)
      strcpy(buf, "You keep");
    else
      strcpy(buf, "You receive");
d1912 2
a1913 1
    strcat(buf, ".\r\n");
d1916 1
a1916 2
    strcpy(buf, "You forego your share.\r\n");
  send_to_char(buf, receiver);
d3165 3
@


1.289
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.288 2009/03/09 04:50:38 myc Exp jps $
d366 1
a366 1
  money = create_money(GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
d369 1
a369 1
  GET_PLAT(ch) = 0;
d519 1
a519 1
      GET_PLAT(player) += GET_PLAT(ch);
d1298 2
a1299 2
            if ((plat = (int) ((GET_PLAT(vict) * number(1, 10)) / 100))) {
               lastcoin = PLAT;
d1321 2
a1322 2
               GET_PLAT(ch) += plat;
               GET_PLAT(vict) -= plat;
d1941 1
a1941 1
  if (coins[PLAT] || coins[GOLD] || coins[SILVER] || coins[COPPER]) {
d1952 1
a1952 1
  GET_PLAT(receiver) += coins[PLAT];
d1956 1
a1956 1
  GET_PLAT(giver) -= coins[PLAT];
d2058 1
a2058 1
  if (!coins[PLAT] && !coins[GOLD] && !coins[SILVER] && !coins[COPPER]) {
d3200 3
@


1.288
log
@First aid now does a percentage of the max hit points, and is
always successful to some degree; uses a capped normal distribution.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.287 2009/03/09 04:33:20 jps Exp myc $
d51 1
d3200 4
@


1.287
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.286 2009/03/08 23:34:14 jps Exp jps $
d3071 3
d3076 3
d3089 22
a3110 1
  send_to_char("You attempt to render first aid unto yourself.\r\n", ch);
a3111 6
  if (number(1, 101) < GET_SKILL(ch, SKILL_FIRST_AID) &&
      GET_HIT(ch) < GET_MAX_HIT(ch)) {
    GET_HIT(ch) += dice(6, GET_LEVEL(ch) - 1);
    if (GET_HIT(ch) > GET_MAX_HIT(ch))
      GET_HIT(ch) = GET_MAX_HIT(ch);
  }
d3114 2
a3115 1
  SET_COOLDOWN(ch, CD_FIRST_AID, 24 MUD_HR);
d3199 4
@


1.286
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.285 2009/03/08 21:43:27 jps Exp jps $
d50 1
d3177 3
@


1.285
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.284 2009/03/07 22:29:13 jps Exp jps $
d28 1
a28 1
#include "spells.h"
d3176 3
@


1.284
log
@Use active_effect_from_char in aggro_remove_spells, so you get feedback
about those things being removed from you.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.283 2009/03/03 19:41:50 myc Exp jps $
d48 2
d3176 4
@


1.283
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.282 2009/02/21 03:30:16 myc Exp myc $
d69 2
a70 2
   effect_from_char(ch, SPELL_INVISIBLE);
   effect_from_char(ch, SPELL_NATURES_EMBRACE);
d3174 3
@


1.282
log
@Removed L_FILE flag--mprintf now logs to file by default; assert
L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.281 2009/02/05 17:23:39 myc Exp myc $
a57 1
struct obj_data *get_obj_in_list_vnum(int num, struct obj_data * list);
d128 1
a128 1
  else if (!(vict = get_char_room_vis(ch, arg))) {
d752 3
a754 4
      sprintf(buf, "You have saved all players in the realm.\r\n");
      send_to_char(buf, ch);
      sprintf(buf, "(GC) %s has saved all players in the realm.", GET_NAME(ch));
      mudlog(buf, BRF, MAX(GET_LEVEL(ch), GET_INVIS_LEV(ch)), TRUE);
d759 1
a759 1
      target = get_char(arg);
d770 1
a770 2
    sprintf(buf, "No player by the name of %s is currently in the game.\r\n", arg);
    send_to_char(buf, ch);
d781 1
a781 1
      sprintf(buf, "Saving %s.\r\n", GET_NAME(ch));
d783 1
a783 2
      sprintf(buf, "You have force-saved %s.\r\n", GET_NAME(target));
    send_to_char(buf, ch);
d787 2
a788 4
  if (ch != target) {
    sprintf(buf, "(GC) %s has saved %s to file.", GET_NAME(ch), GET_NAME(target));
    mudlog(buf, BRF, GET_LEVEL(ch), TRUE);
  }
d993 1
a993 1
    if (!(vict = get_char_room_vis(ch, arg))) {
d1034 1
a1034 1
  else if (!(vict = get_char_vis(ch, arg)))
d1190 1
a1190 1
   if (!(vict = get_char_room_vis(ch, vict_name))) {
d1225 1
a1225 1
      if (!(obj = get_obj_in_list_vis(ch, obj_name, vict->carrying))) {
d1502 1
a1502 1
    vict = get_char_room_vis(ch, arg);
d1654 1
a1654 1
   else if (!(target = get_char_vis(ch, arg))) {
d1705 1
a1705 1
  else if (!(victim = get_char_room_vis(ch, arg))) {
d1824 1
a1824 1
  else if (!(tch = get_char_vis(ch, arg))) {
d2088 2
a2089 3
      if (!(mag_item = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf2, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        send_to_char(buf2, ch);
d2097 1
a2097 2
        sprintf(buf2, "You don't seem to be holding %s %s.\r\n", AN(arg), arg);
        send_to_char(buf2, ch);
d2515 1
a2515 1
      if (GET_LEVEL(ch) < LVL_GOD || !(tch = get_char_vis(ch, arg))) {
d2911 1
a2911 1
    if (!(vict = get_char_room_vis(ch, arg))) {
d3114 1
a3114 1
  if (!(target = get_char_vis(ch, arg)) || IS_NPC(target)) {
d3174 4
@


1.281
log
@Make bug/typo/idea cause laryngitis.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.280 2009/01/19 09:25:23 myc Exp myc $
d2336 1
a2336 1
   mprintf(L_STAT | L_FILE, LVL_IMMORT, "%s by %s [%d]: %s",
d3182 3
@


1.280
log
@Changed summoned mount cooldown to count 12 hours from time
mount is lost.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.279 2009/01/19 03:03:39 myc Exp myc $
d2289 2
d2292 1
a2292 1
      send_to_char("Monsters can't have ideas - Go away.\r\n", ch);
d2324 7
d3182 4
@


1.279
log
@Allow guarding of NPCs.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.278 2009/01/18 07:23:03 myc Exp myc $
d2813 6
a2818 1
      send_to_char("You may only summon one mount per week!\r\n", ch);
a2820 1
    SET_COOLDOWN(ch, CD_SUMMON_MOUNT, 7 * 24 MUD_HR);
d2866 1
d3173 3
@


1.278
log
@level command will show exp bar now too.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.277 2009/01/16 23:36:34 myc Exp myc $
d96 4
a99 4
  if(ch->guarding){
    if(ch->guarding->guarded_by == ch) {
      act("You stop guarding $N.", FALSE, ch,0,ch->guarding, TO_CHAR);
      act("$n stops guarding you.", TRUE, ch,0,ch->guarding, TO_VICT);
a100 5
      ch->guarding = NULL;
    }
    else {
      act("You stop guarding &N.",FALSE,ch,0,ch->guarding,TO_CHAR);
      ch->guarding = NULL;
d102 1
d104 2
d129 2
a130 2
  else if ((vict = get_char_room_vis(ch, arg)) == NULL || IS_NPC(vict)){
    send_to_char("That person is not here.\r\n",ch);
d146 1
a146 1
      send_to_char("Someone is already guarding that person.\r\n", ch);
d3168 3
@


1.277
log
@Fix use of uninitialized variable in do_group().
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.276 2008/09/28 19:13:25 jps Exp myc $
d1376 1
d1380 6
a1385 10
  if (*arg) {
    if (!str_cmp(arg, "gain")) {
      send_to_char("You can only do that in your guild.\r\n", ch);
    } else {
      send_to_char("Huh?!?\r\n", ch);
    }
  } else {
    sprintf(buf, "%s\r\n", exp_message(ch));
    send_to_char(buf, ch);
  }
d3170 3
@


1.276
log
@Send idea log messages to file.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.275 2008/09/28 19:07:14 jps Exp jps $
d1831 1
a1831 1
  if (!str_cmp("all", arg))
d1833 2
d3173 3
@


1.275
log
@Adding -s to curl so its progress info doesn't go in syslog.
Changing the log message for gen_write.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.274 2008/09/21 21:50:22 jps Exp jps $
d2330 1
a2330 1
   mprintf(L_STAT, LVL_IMMORT, "%s by %s [%d]: %s",
d3171 4
@


1.274
log
@Call transfer_battle when shapechanging, so the "replacement" character
is embroiled in the conflict the same way the original was.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.273 2008/09/20 08:24:44 jps Exp jps $
d2255 7
a2269 7
  switch (category) {
    case SCMD_BUG:  cat = "bug";  break;
    case SCMD_TYPO: cat = "typo"; break;
    case SCMD_IDEA: cat = "idea"; break;
    default:                      return;
  }

d2272 1
a2272 1
  str_catf(buf, "curl \"http://bug.fierymud.org/fiery_report.php?"
d2274 1
a2274 2
           GET_NAME(ch), IN_ROOM(ch) == NOWHERE ? NOWHERE :
           world[IN_ROOM(ch)].vnum, cat, make_count);
a2283 1

d2301 1
a2301 1
      case SCMD_NOTES:
d2330 2
a2331 1
   mprintf(L_INFO, LVL_IMMORT, "%s %s: %s", GET_NAME(ch), CMD_NAME, argument);
d3171 4
@


1.273
log
@Don't store potentially negative values in unsigned variables!!!!!!!!!1
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.272 2008/09/20 06:05:06 jps Exp jps $
d504 1
d507 1
d658 4
d3172 3
@


1.272
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.271 2008/09/09 08:23:37 jps Exp jps $
d2864 1
a2864 1
     GET_LEVEL(mount) = ideal_mountlevel(ch);
d3166 3
@


1.271
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.270 2008/09/07 20:05:27 jps Exp jps $
d454 1
a454 1
  if (IS_NPC(ch) ? (!ch->desc || !ch->desc->original) :
d463 1
a463 1
  if (ch->desc && ch->desc->original) {
d479 2
a480 2
      if (ch->desc->original->desc)
        close_socket(ch->desc->original->desc);
d482 1
a482 1
      player = ch->desc->original;
d2841 3
a2843 2
  if (!ch || (ch->in_room == NOWHERE))        /* They died in the meantime. Events should have been pulled
                                           for them, but why trust that */
d3166 3
@


1.270
log
@Renamed exp_to_level to exp_next_level to make it clearer what it means.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.269 2008/09/07 01:32:32 jps Exp jps $
d831 1
a831 1
    if (SECT(ch->in_room) == SECT_INSIDE) {
d2806 1
a2806 1
    if (!OUTSIDE(ch)) {
d3165 3
@


1.269
log
@Don't send a message to all when "save all" is entered.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.268 2008/09/06 22:06:21 myc Exp jps $
a58 1
long exp_to_level(int, int);
d262 1
a262 1
    old_exp = GET_EXP(ch) / (double) exp_to_level(GET_LEVEL(ch), GET_CLASS(ch));
d275 1
a275 1
    GET_EXP(ch) = (long) exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) * old_exp;
d3165 3
@


1.268
log
@Fixed the naming of NoTell in toggle.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.267 2008/09/04 06:47:36 jps Exp myc $
a751 1
      send_to_all("Autosaving...\r\n");
d3166 3
@


1.267
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.266 2008/09/02 06:52:30 jps Exp jps $
d2391 1
a2391 1
    { "Tell",       0,          PRF_NOTELL },
d3167 3
@


1.266
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.265 2008/09/01 23:47:49 jps Exp jps $
d843 2
a844 2
    if ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
        (SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
d848 1
a848 1
      if (SECT(ch->in_room) == SECT_FLYING) {
d3167 3
@


1.265
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.264 2008/09/01 22:15:59 jps Exp jps $
d47 1
d3167 3
@


1.264
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.263 2008/09/01 00:48:42 mud Exp jps $
d46 1
a55 1
void add_follower(struct char_data * ch, struct char_data * leader);
a58 1
void dismount_char(struct char_data * ch);
d3166 3
@


1.263
log
@Remove prototype which is imported from skills.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.262 2008/08/31 21:44:03 jps Exp mud $
d304 2
d316 1
a316 1
    remove_player_from_game(ch, SAVE_QUITIMM);
d353 21
a373 1
  remove_player_from_game(ch, SAVE_QUITMORT);
d787 1
a787 1
  save_player(target, SAVE_FORCE);
d969 1
a969 1
  remove_player_from_game(ch, SAVE_CAMP);
d3167 3
@


1.262
log
@Renamed StackObjs and StackMobs prefs to ExpandObjs and ExpandMobs.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.261 2008/08/31 21:05:38 myc Exp jps $
a432 2
  int return_max_skill(struct char_data *ch, int skill);

d3145 3
@


1.261
log
@Abort command gives a useful message when not casting.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.260 2008/08/31 20:40:41 rbr Exp myc $
d2399 2
a2400 2
    { "StackObjs",  0,          PRF_STACK_OBJS },
    { "StackMobs",  0,          PRF_STACK_MOBS },
d2472 4
a2475 4
        /*32*/ {"Objects will no longer stack in lists.\r\n",
                "Objects will now stack in lists.\r\n"},
        /*33*/ {"Mobiles will no longer stack in lists.\r\n",
                "Mobiles will now stack in lists.\r\n"},
d3147 3
@


1.260
log
@Changed do_group to be consent based instead of follow based
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.259 2008/08/29 04:16:26 myc Exp $
d1089 1
a1089 1
    send_to_char("&8You abort your cast!&0\r\n", ch);
d1095 1
a1095 1
    send_to_char("Huh?!?\r\n", ch);
d3147 3
@


1.259
log
@Added toggles for stacking objects and stacking mobiles.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.258 2008/08/19 02:11:14 jps Exp myc $
d1809 1
a1809 1
  else if (!(tch = get_char_room_vis(ch, arg))) {
d1832 2
a1833 1
    struct follow_type *f;
d1835 19
a1853 10
    for (f = ch->followers; f; f = f->next) {
      tch = f->follower;
      /* Follower isn't in the same room. */
      if (tch->in_room != ch->in_room)
        continue;
      /* Follower is already in a group. */
      if (IS_GROUPED(tch))
        continue;
      if (CONSENT(tch) != ch && GET_LEVEL(ch) < LVL_IMMORT)
        if (!(IS_NPC(tch) && tch->master == ch && EFF_FLAGGED(tch, EFF_CHARM)))
d1855 2
d1858 1
a1858 1
      level_diff = GET_LEVEL(ch) - GET_LEVEL(tch);
d1864 1
a1864 1
                GET_NAME(tch), max_group_difference);
d1869 1
a1869 1
      add_groupee(ch, tch);
d1874 1
a1874 1
      send_to_char("&2&8No one here is following you and not already in a group.&0\r\n", ch);
d3147 3
@


1.258
log
@Don't apply fluid/rigidity restrictions to immortals.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.257 2008/08/18 01:35:38 jps Exp jps $
d2387 2
d2460 4
d3135 3
@


1.257
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.256 2008/08/16 23:04:03 jps Exp jps $
d1166 1
a1166 1
   if (!RIGID(ch)) {
d3129 3
@


1.256
log
@Added speech_ok() to comm.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.255 2008/08/15 03:51:35 myc Exp jps $
d1006 1
a1006 1
  send_to_char("Huh?!?\n\r",ch);
d1010 1
a1010 1
    send_to_char("You are too busy fighting to think about that right now!\n\r",ch);
d1155 1
a1155 1
      send_to_char("You can't steal while you are fighting!\n\r", ch);
d2946 1
a2946 1
    send_to_char("You can't gain control the dead while fighting!\n\r",ch);
d3026 1
a3026 1
    send_to_char("You are too busy fighting to attend to yourself!\n\r",ch);
d3031 1
a3031 1
    send_to_char("You can only do this once per day.\n\r", ch);
d3035 1
a3035 1
  send_to_char("You attempt to render first aid unto yourself.\n\r", ch);
d3129 3
@


1.255
log
@Bugs/typos/ideas reported by players on the production MUD
get automatically sent to Mantis now.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.254 2008/07/27 05:29:43 jps Exp myc $
a61 1
int speech_ok(struct char_data *ch, int quiet);
d3129 4
@


1.254
log
@Using remove_player_from_game and save_player_char functions.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.253 2008/07/18 17:25:34 jps Exp jps $
d2220 30
a2254 1
   char note_buf[MAX_STRING_LENGTH];
d2269 1
a2269 1
         argument = one_argument(argument, buf);
d2274 3
a2276 4
         get_pfilename(buf, note_buf , NOTES_FILE);
         filename = note_buf;
         send_to_char(note_buf, ch);
         send_to_char("\r\n", ch);
d2297 1
a2297 2
   sprintf(buf, "%s %s: %s", GET_NAME(ch), CMD_NAME, argument);
   mudlog(buf, CMP, LVL_IMMORT, FALSE);
d2300 1
a2300 2
      send_to_char("Sorry, the file is full right now.. try again later.\r\n",
         ch);
d2317 12
d3130 3
@


1.253
log
@Add room identification to camping syslog messages.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.252 2008/06/21 06:59:38 jps Exp jps $
a304 2
  extern int free_rent;
  struct descriptor_data *d, *next_d;
d312 4
a315 3
  if (subcmd == SCMD_QUIT && !*arg) {
    send_to_char("Are you sure you want to drop &1&beverything&0 and leave this world?\r\n", ch);
    send_to_char("If so type 'quit yes' otherwise use camp or rent.\r\n", ch);
d319 3
a321 6
  if (subcmd == SCMD_QUIT) {
    if (str_cmp(arg, "yes")) {
       send_to_char("You must type 'quit yes' to leave this world.\r\n", ch);
       send_to_char("Note: You will lose &1&beverything&0 if you quit! Camping or renting will save everything.\r\n", ch);
       return;
    }
d324 3
a326 4
  /* this is for the 'qui' command for immorts */
  if (subcmd != SCMD_QUIT && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You must type 'quit yes' to leave this world.\r\n", ch);
    send_to_char("Note: You will lose &1&beverything&0 if you quit! Camping or renting will save everything.\r\n", ch);
d329 4
a332 2
  if (FIGHTING(ch)) {
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
d340 1
a340 1
    act("$n quits the game but is unable to fend off death...", TRUE, ch, 0, 0, TO_ROOM);
d343 1
a343 1
    return; /* added this return so you don't get removed 2x KABOOM --gurlaek 6/11/1999 */
d346 2
a347 3
  if (!GET_INVIS_LEV(ch)) {
    act("$n has left the game.", TRUE, ch, 0, 0, TO_ROOM);
  }
d350 1
a350 1
  send_to_char("Goodbye, friend.. Come back soon!\r\n", ch);
d352 1
a352 33
  /*
   * kill off all sockets connected to the same player as the one who is
   * trying to quit.  Helps to maintain sanity as well as prevent duping.
   */
  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (d == ch->desc)
      continue;
    if (d->character && (GET_IDNUM(d->character) == GET_IDNUM(ch))) {
        close_socket(d);
    }
  }

  if (free_rent && GET_LEVEL(ch) >= 100)
    save_objects(ch, SAVE_RENT);
  else {
    GET_COPPER(ch) = 0;
    GET_SILVER(ch) = 0;
    GET_GOLD(ch) = 0;
    GET_PLAT(ch) = 0;
  }

  /* If someone is quitting in their house, let them load back here */
  /* This happens anyway
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE))
    GET_LOADROOM(ch) = world[ch->in_room].number;
   */

  GET_LOADROOM(ch) = world[ch->in_room].vnum;
  save_player(ch);
  save_quests(ch);

  extract_char(ch);   /*swapped banyal*/
d355 2
a356 2
#define MAMMAL        (1 << 0)
#define BIRD        (1 << 1)
d358 1
a358 1
#define FISH        (1 << 3)
d360 1
a360 1
#define TANK        (1 << 4)
d362 1
a362 1
#define TRAVEL        (1 << 6)
d730 1
a730 1
      crash_save_all(); /* calls save_player too */
d733 1
a733 1
      send_to_all("Autosaving.....\r\n");
d757 1
a757 1
    send_to_char("You can't save a NPC!\r\n", ch);
d765 1
a765 1
      sprintf(buf, "You have saved the player %s to file.\r\n", GET_NAME(target));
d768 1
a768 5
  save_player(target);
  save_objects(target, SAVE_CRASH);
  save_quests(target);
  if (ROOM_FLAGGED(target->in_room, ROOM_HOUSE_CRASH))
    House_crashsave(world[target->in_room].vnum);
a892 5
/*
  I tweaked this function by adding a check for GET_ACTION so you
  can't camp twice.  And also, NULLed GET_ACTION when the event
  terminates.  No more silly camp crashbug.  --Gurlaek.
*/
a897 1
  void Crash_rentsave(struct char_data *ch, int cost);
a948 4
  save_objects(ch, SAVE_RENT);
  save_quests(ch);
  if (GET_LEVEL(ch) < LVL_GOD)
    GET_LOADROOM(ch) = world[ch->in_room].vnum;
d950 1
a950 1
  extract_char(ch); /* calls save_player */
d1411 1
a1411 1
      save_player(ch);
d3092 3
@


1.252
log
@In split_coins(), don't assume that the group leader is in the room.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.251 2008/06/05 02:07:43 myc Exp jps $
d990 4
a993 1
  sprintf(buf, "%s has camped.", GET_NAME(ch));
d3142 3
@


1.251
log
@Rewrote rent-saving code to use ascii-format files.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.250 2008/05/18 20:16:11 jps Exp myc $
d1988 5
d1995 7
a2001 1
  count = 1;
d2003 7
a2009 2
    if (CAN_SEE(ch, g->groupee) && ch->in_room == g->groupee->in_room)
      ++count;
a2015 13
  if (count > max_members) {
    if (max_members)
      RECREATE(members, struct char_data *, count);
    else
      CREATE(members, struct char_data *, count);
    max_members = count;
  }

  members[(i = 0)] = master;
  for (g = master->groupees; g; g = g->next)
    if (CAN_SEE(ch, g->groupee) && ch->in_room == g->groupee->in_room)
      members[++i] = g->groupee;

d2025 2
a2026 2
   * gets an extra ith coin type.  If n = coins[i] is nonzero for a 
   * particular i, then n group members, starting at the 
d2036 1
a2036 1
     * split the coins, then remove it from the share array.  This 
d3139 3
@


1.250
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.249 2008/05/18 05:39:59 jps Exp jps $
a304 1
  void Crash_rentsave(struct char_data * ch, int cost);
d369 3
a371 3
  if (free_rent && GET_LEVEL(ch) >= 100) {
    Crash_rentsave(ch, 0);
  } else {
d386 1
d766 1
a766 1
      Crash_save_all(); /* calls save_player too */
d805 2
a806 1
  Crash_crashsave(target);
d992 2
a993 2
  Crash_rentsave(ch, 0);
  save_player(ch);
d997 1
a997 1
  extract_char(ch);
d3136 3
@


1.249
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.248 2008/05/14 05:10:44 jps Exp jps $
d45 1
d68 28
a1723 1
  void die(struct char_data * ch, struct char_data * killer);
d3135 3
@


1.248
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.247 2008/05/11 05:45:26 jps Exp jps $
d356 1
a356 1
  GET_LOADROOM(ch) = world[ch->in_room].number;
d778 1
a778 1
    House_crashsave(world[target->in_room].number);
d965 1
a965 1
    GET_LOADROOM(ch) = world[ch->in_room].number;
d2303 1
a2303 1
      world[ch->in_room].number, argument);
d3107 3
@


1.247
log
@alter_hit now takes the killer.  update_pos is removed.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.246 2008/04/19 21:10:13 myc Exp jps $
d677 1
a677 1
  alter_hit(mob, NULL, 0, TRUE);
a1720 1
    alter_hit(victim, NULL, MAX(-3, GET_SKILL(ch, SKILL_BANDAGE) / -10), TRUE);
d1723 1
d1731 1
a1731 1
    alter_hit(victim, NULL, 1, TRUE);
d3107 3
@


1.246
log
@Removed some old unused sorting code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.245 2008/04/13 00:57:34 jps Exp myc $
d44 1
d677 1
a677 1
  alter_hit(mob, 0, TRUE);
d1721 1
a1721 1
    alter_hit(victim, MAX(-3, GET_SKILL(ch, SKILL_BANDAGE) / -10), TRUE);
d1724 1
a1724 3
  }
  else {
    alter_hit(victim, 1, TRUE);
d1727 1
a1727 1
    if (GET_HIT(victim) <= HIT_DEAD) {
a1729 1
      die(victim, ch);
d1731 1
d1733 1
a1736 1
  update_pos(victim);
d3107 3
@


1.245
log
@Added a toggle for auto-treasure looting.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.244 2008/04/12 21:13:18 jps Exp jps $
a360 42
#define MAXN 100000
#define MAX_MOBS 29

int valid[MAX_MOBS];
int level[MAX_MOBS];

typedef int DType;
DType realx[MAXN];

void swap(int i, int j)
{
  DType t = level[i];
  DType r = valid[i];
  level[i] = level[j];
  valid[i] = valid[j];
  level[j] = t;
  valid[j] = r;
}

void sort(int l, int u)
{
  int i, j;
  DType t;
  if (l >= u)
    return;
  t = level[l];
  i = l;
  j = u+1;
  for (;;) {
    do i++;
    while (i <= u && level[i] < t);
      do j--;
      while (level[j] > t);
        if (i > j)
          break;
      swap(i, j);
  }
  swap(l, j);
  sort(l, j-1);
  sort(j+1, u);
}

d3108 3
@


1.244
log
@Using new header file magic.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.243 2008/04/07 03:02:54 jps Exp jps $
d2406 1
d2473 5
a2477 3
        /*29*/ {"You will no longer automatically loot corpses.\r\n",
                 "You will now automatically loot corpses!\r\n"},
        /*30*/ {NULL,
d3150 3
@


1.243
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.242 2008/04/05 18:07:09 myc Exp jps $
d43 1
a54 1
int mag_savingthrow(struct char_data *ch, int type);
d3147 4
@


1.242
log
@Re-implementing stealth for hide points.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.241 2008/04/05 16:49:07 myc Exp myc $
d312 1
a312 1
  if (GET_POS(ch) < POS_STUNNED) {
d892 1
a892 1
  if (GET_POS(ch) == POS_FIGHTING)
d894 2
a895 2
  else if (GET_POS(ch) < POS_STUNNED)
    send_to_char("Its hard to set your tent up while dying...\r\n", ch);
d1099 2
a1100 2
      if(GET_POS(vict) > POS_STUNNED){
        send_to_char("Your not skilled enough to tie a conscious person\r\n", ch);
d1119 1
a1119 1
      if(GET_POS(vict) < POS_SLEEPING)
d1257 1
a1257 1
   if (GET_POS(vict) < POS_SLEEPING)
d1286 1
a1286 1
               if ((GET_POS(vict) > POS_STUNNED)) {
d1745 1
a1745 1
        if (GET_HIT(victim) < 0 || GET_POS(victim) < POS_STUNNED)
d1756 1
a1756 1
  if (GET_HIT(victim) >= 0 && GET_POS(victim) >= POS_STUNNED) {
d3147 3
@


1.241
log
@Oops, fixing autosplit/autoloot messages again?
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.240 2008/04/05 15:30:38 myc Exp myc $
d1188 7
d3147 3
@


1.240
log
@Slightly changing the split algorithm to more evenly distribute the
remainder coins.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.239 2008/04/05 05:04:24 myc Exp myc $
d2385 1
a2385 1
    { "AutoLoot",   0,          PRF_AUTOLOOT },
d2398 1
a2398 1
    { "AutoSplit",  0,          PRF_AUTOSPLIT },
d2400 1
a2400 1
    { "\n",         0,          0},
d3140 4
@


1.239
log
@Fixed messages for autoloot/autosplit toggles.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.238 2008/04/05 03:30:55 jps Exp myc $
d1988 1
a1988 1
  int i, count, share[NUM_COIN_TYPES], lucky_recipient[NUM_COIN_TYPES], j;
d2024 1
a2024 1
    lucky_recipient[i] = number(0, count - 1);
d2027 7
d2036 1
a2036 1
  for (i = 0; i < count; ++i) {
d2039 3
a2041 4
     * member i is the lucky recipient for the remainder of
     * coin type j, then add it to the share array, split the
     * coins, then remove it from the share array.  This reduces
     * split_share()'s complexity significantly.
d2043 9
a2051 9
    for (j = 0; j < NUM_COIN_TYPES; ++j)
      if (lucky_recipient[j] == i)
        share[j] += coins[j];

    split_share(ch, members[i], share);

    for (j = 0; j < NUM_COIN_TYPES; ++j)
      if (lucky_recipient[j] == i)
        share[j] -= coins[j];
d3140 3
@


1.238
log
@Remove the ability to see others' toggles from mortals.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.237 2008/04/04 22:19:06 jps Exp jps $
d2379 1
a2379 1
    { "AutoSplit",  0,          PRF_AUTOSPLIT },
d2392 1
a2392 1
    { "AutoLoot",   0,          PRF_AUTOLOOT },
d3134 3
@


1.237
log
@Put the right feedback messages with tog autoloot and tog autosplit.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.236 2008/04/04 20:37:42 myc Exp jps $
d2481 1
a2481 1
      if (!(tch = get_char_vis(ch, arg))) {
d3134 3
@


1.236
log
@Made autoloot and autosplit level 0.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.235 2008/04/03 17:37:21 jps Exp myc $
d2433 2
a2434 2
        /*16*/ {"You will no longer automatically loot corpses.\r\n",
                 "You will now automatically loot corpses!\r\n"},
d2459 2
a2460 2
        /*29*/ {"You will no longer automatically split coins from corpses.\r\n",
                 "You will now automatically split coins from corpses!\r\n"},
d3134 3
@


1.235
log
@Added autoinvis toggle for deities.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.234 2008/04/03 02:02:05 myc Exp jps $
d2379 1
a2379 1
    { "AutoSplit",  LVL_IMMORT, PRF_AUTOSPLIT },
d2392 1
a2392 1
    { "AutoLoot",   LVL_IMMORT, PRF_AUTOLOOT },
d3134 3
@


1.234
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.233 2008/04/02 05:36:19 myc Exp myc $
d45 1
a45 1
extern int max_group_difference; 
d50 1
a50 1
void rem_memming(struct char_data *ch); 
d67 1
a67 1
  
d87 1
a87 1
  
d290 1
a290 1
  
d304 1
a304 1
  } 
d326 1
a326 1
  
d336 1
a336 1
	close_socket(d);
d347 2
a348 2
  }    
  
d357 1
a357 1
   
d403 4
a406 4
#define MAMMAL	(1 << 0)
#define BIRD	(1 << 1)
#define REPTILE	(1 << 2)
#define FISH	(1 << 3)
d408 4
a411 4
#define TANK	(1 << 4)
#define DAMAGER	(1 << 5)
#define TRAVEL	(1 << 6)
#define TRACKER	(1 << 7)
d413 1
a413 1
#define AQUATIC	(1 << 8)
d416 1
a416 1
#define MAX_SHAPECHANGE_SKILLS	5
d439 1
a439 1
  { "panther",   1006, MAMMAL | DAMAGER,          40, 380,  450, 300, 350, {SKILL_SWITCH, SKILL_SNEAK, SKILL_HIDE} }, 
d484 1
a484 1
  if (IS_NPC(ch) ? (!ch->desc || !ch->desc->original) : 
d528 1
a528 1
      player->desc = ch->desc; 
d531 1
a531 1
      ch->desc = NULL;      
d591 1
a591 1
  /* Determine the desired shapechange type.  You can supply as many 
d646 1
a646 1
    /* This is where the dice roll occurs.  It's some complicated 
d700 3
a702 3
   * shouldn't have.  Yes, it's a shame, since the mob classes set on 
   * the mob prototypes won't mean much, but it's too much to manually 
   * list all the skills we want to remove.  After clearing skills, turn 
d768 1
a768 1
  
d820 1
a820 1
  
d832 1
a832 1
  if (CMD_IS("balance") || CMD_IS("deposit") || CMD_IS("withdraw") || 
d839 1
a839 1
  else if (CMD_IS("list") || CMD_IS("value") || CMD_IS("buy") || 
d852 1
a852 1
  
d862 1
a862 1
  
d869 1
a869 1
    
d874 1
a874 1
    
d877 1
a877 1
	(SECT(ch->in_room) == SECT_UNDERWATER)) {
d890 3
a892 3
  
  
  if (GET_POS(ch) == POS_FIGHTING) 
d914 3
a916 3
  
  ch = re->ch; 
  
d919 1
a919 1
                 re->from_room); 
d921 1
a921 1
                 ch); 
d924 1
a924 1
  
d955 1
a955 1
  
d974 1
a974 1
	NULL, TO_CHAR);
d981 1
a981 1
	NULL, NULL, TO_CHAR);
d987 1
a987 1
  rem_memming(ch); 
d996 1
a996 1
  
d1017 1
a1017 1
  
d1019 1
a1019 1
  
d1037 1
a1037 1
      send_to_char("Unbind who?\r\n", ch); 
d1042 6
a1047 6
      if (prob > percent){   
	send_to_char("You break free from your binds!\r\n", ch);
	act("$n breaks free from his binds", FALSE, ch, 0, 0, TO_ROOM);
	REMOVE_FLAG(PLR_FLAGS(ch), PLR_BOUND);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	return;
d1049 1
a1049 1
	WAIT_STATE(ch, PULSE_VIOLENCE*3);
d1053 1
a1053 1
    send_to_char("You are free of your binds.\r\n", vict);  
d1072 1
a1072 1
  
d1074 1
a1074 1
  
d1086 1
a1086 1
    
d1100 2
a1101 2
	send_to_char("Your not skilled enough to tie a conscious person\r\n", ch);
	return;
d1103 8
a1110 8
	act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	SET_FLAG(PLR_FLAGS(vict), PLR_BOUND);
	extract_obj(held);
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;
} 
d1118 1
a1118 1
      
d1120 2
a1121 2
	prob = percent + 1;
      
d1123 5
a1127 5
	act("You tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	act("$n ties you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	act("$n ties up $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	SET_FLAG(PLR_FLAGS(vict), PLR_BOUND);
	extract_obj(held);
d1129 5
a1133 5
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	return;}else{
	  act("You tries to tie $N up.... What next?", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n tries to tie you up.... Hope he isnt the kinky type", FALSE, ch, 0, vict, TO_VICT);
	  act("$n tries to tie up $N.", FALSE, ch, 0, vict, TO_ROOM);
d1135 3
a1137 3
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	  return;
	}
d1167 1
a1167 1
  
d1186 1
a1186 1
  
d1393 1
a1393 1
  
d1447 1
a1447 1
  
d1556 1
a1556 1
  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content) 
d1664 1
a1664 1
}  
d1762 1
a1762 1
    act("&8$n fails an attempt to bandage $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT); 
d1807 1
a1807 1
   sprintf(buf2, "%s%d&0&8H&0  %3dv/%3dV] [%s]", 
d1826 1
a1826 1
         make_group_report_line(k, buf); 
d1830 1
a1830 1
    
d2014 1
a2014 1
  
d2062 1
a2062 1
  
d2067 1
a2067 1
  
d2093 1
a2093 1
  
d2101 1
a2101 1
  
d2108 3
a2110 3
	sprintf(buf2, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf2, ch);
	return;
d2148 1
a2148 1
	(GET_OBJ_TYPE(mag_item) != ITEM_STAFF)) {
d2154 1
a2154 1
  
d2163 1
a2163 1
  
d2165 1
a2165 1
  
d2169 1
a2169 1
	      GET_WIMP_LEV(ch));
d2180 1
a2180 1
	send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
d2182 1
a2182 1
	send_to_char("That doesn't make much sense, now does it?\r\n", ch);
d2184 1
a2184 1
	send_to_char("You can't set your wimp level above half your hit points.\r\n", ch);
d2186 4
a2189 4
	sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n",
		wimp_lev);
	send_to_char(buf, ch);
	GET_WIMP_LEV(ch) = wimp_lev;
d2197 1
a2197 1
  
d2199 1
a2199 1
  
d2205 1
a2205 1
  
d2207 1
a2207 1
    
d2218 1
a2218 1
  
d2220 1
a2220 1
  
d2225 1
a2225 1
  
d2227 1
a2227 1
  
d2233 1
a2233 1
  
d2235 2
a2236 2
    free(GET_PROMPT(ch));  
  
d2243 1
a2243 1
ACMD(do_prompt) 
d2246 1
a2246 1
  
d2249 1
a2249 1
	    (GET_PROMPT(ch) ? escape_ansi(GET_PROMPT(ch)) : "n/a"));
d2253 1
a2253 1
  
d2255 1
a2255 1
  
d2260 1
a2260 1
  
d2282 1
a2282 1
   
d2285 1
a2285 1
         argument = one_argument(argument, buf); 
d2290 5
a2294 5
         get_pfilename(buf, note_buf , NOTES_FILE); 
         filename = note_buf; 
         send_to_char(note_buf, ch); 
         send_to_char("\r\n", ch); 
         break; 
d2318 1
a2318 1
      send_to_char("Sorry, the file is full right now.. try again later.\r\n", 
d2349 1
a2349 1
  struct set_struct 
d2354 1
a2354 1
  } 
d2358 1
a2358 1
    remove a toggle you must also update the SCMD's in 
d2365 1
a2365 1
    { "Brief",	    0,          PRF_BRIEF },
d2367 1
a2367 1
    { "Tell",	    0,	        PRF_NOTELL },
d2369 1
a2369 1
    { "NoShout",    0,	        PRF_DEAF },
d2373 1
a2373 1
    { "Quest", 	    LVL_IMMORT, PRF_QUEST },
d2375 1
a2375 1
    { "NoRepeat",   0,	        PRF_NOREPEAT },  
d2378 1
a2378 1
    { "NoPetition", LVL_IMMORT, PRF_NOPETI },  
d2380 1
a2380 1
    { "Anonymous",  50,	        PRF_ANON },
d2382 2
a2383 2
    { "Wimpy",	    0,	        0 },
    { "NiceArea",   0,	        PRF_NICEAREA },
d2393 4
a2396 1
    { "\n",	    0,	        0},
d2399 1
a2399 1
  char *tog_messages[][2] = 
d2401 53
a2453 53
	/*00*/	{"You are now safe from summoning by other players.\r\n",
		 "You may now be summoned by other players.\r\n"},
	/*01*/	{"Nohassle disabled, mobs will attack you now.\r\n",			
		 "Nohassle enabled, mobs will leave you alone now.\r\n"},
	/*02*/	{"Brief mode off.\r\n",
		 "Brief mode on.\r\n"},
	/*03*/	{"Compact mode off.\r\n",
		 "Compact mode on.\r\n"},
	/*04*/	{"You can now hear tells.\r\n",
		 "You are now deaf to tells.\r\n"},
	/*05*/	{"You are no longer AFK.\r\n",
		 "You are now AFK.\r\n"},
	/*06*/	{"You can now hear shouts.\r\n",
		 "You are now deaf to shouts.\r\n"},
	/*07*/	{"You can now hear gossip.\r\n",
		 "You are now deaf to gossip.\r\n"},
	/*08*/	{"You will receive hints when you enter typos.\r\n",
		 "You will not receive any hints when entering typos.\r\n"},
	/*09*/	{"You can now hear the Wiz-channel.\r\n",
		 "You are now deaf to the Wiz-channel.\r\n"},
	/*10*/	{"You are no longer part of the Quest.\r\n",
		 "Okay, you are part of the Quest!\r\n"},
	/*11*/	{"You will no longer see the room flags.\r\n",
		 "You will now see the room flags.\r\n"},
	/*12*/	{"You will now have your communication repeated.\r\n",
		 "You will no longer have your communication repeated.\r\n"},
	/*13*/	{"HolyLight mode off.\r\n",
		 "HolyLight mode on.\r\n"},
	/*14*/	{"Autoexits disabled.\r\n",
		 "Autoexits enabled.\r\n"},
	/*15*/	{"You will now receive petitions from mortals!\r\n",
		 "You are now deaf to petitions!\r\n"},
	/*16*/	{"You will no longer automatically loot corpses.\r\n",
		 "You will now automatically loot corpses!\r\n"},
	/*17*/  {"You are no longer anonymous.\r\n",
		 "You are now anonymous.\r\n"},
	/*18*/  {"You will no longer see vnums.\r\n",
		 "You will now see vnums.\r\n"},
	/*19*/  {NULL,
		 NULL},
	/*20*/  {"Your area spells will now hit your race align in towns.\r\n",
		 "Your area spells won't hit your race align in towns.\r\n"},
	/*21*/  {"You feel nice and no longer vicious.\r\n",
		 "You will now kill mortally wounded victims.\r\n"},
	/*22*/	{"You will now auto-engage upon being offensively cast upon.\r\n",
		 "You will no longer auto-engage upon being offensively cast upon.\r\n"},
	/*23*/  {NULL,
		 NULL},
	/*24*/	{"You will now let anyone follow you.\r\n",
		 "You will now avoid attracting new followers.\r\n"},
	/*25*/	{"You will now only be seen by people who might normally see you.\r\n",
		 "You will now be seen by anyone in the same room as you.\r\n"},
        /*26*/  {"You will now hear clan tell.\r\n",
d2455 1
a2455 1
        /*27*/  {"You will no longer hear communication while in OLC.\r\n",
d2457 1
a2457 1
        /*28*/  {"Line numbers will not be displayed when entering the string editor.\r\n",
d2459 4
a2462 2
	/*29*/	{"You will no longer automatically split coins from corpses.\r\n",
		 "You will now automatically split coins from corpses!\r\n"},
a2464 1
  
d2512 9
a2520 1
          set = (GET_PAGE_LENGTH(tch) != 22);
d2523 1
a2523 1
          set = (1 && PRF_FLAGGED(tch, fields[i].bitvector));
d2546 5
a2550 5
	if (GET_WIMP_LEV(tch)) {
	  sprintf(buf, "Your current wimp level is %d hit points.\r\n", GET_WIMP_LEV(tch));
	  send_to_char(buf, ch);
	} else
	  send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
d2553 14
a2566 14
	if ((wimp_lev = atoi(arg))) {
	  if (wimp_lev < 0)
	    send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
	  else if (wimp_lev > GET_MAX_HIT(tch))
	    send_to_char("That doesn't make much sense, now does it?\r\n", ch);
	  else {
	    sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n", wimp_lev);
	    send_to_char(buf, tch);
	    GET_WIMP_LEV(tch) = wimp_lev;
	  }
	} else {
	  send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
	  GET_WIMP_LEV(tch) = 0;
	}
d2568 1
a2568 1
	send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);
d2573 5
a2577 5
	if (GET_PAGE_LENGTH(tch) > 0) {
	  sprintf(buf, "Your current page length is %d.\r\n", GET_PAGE_LENGTH(tch));
	  send_to_char(buf, ch);
	} else {
	  send_to_char("Your page length is not valid.  Reset to 22.\r\n", ch);
d2582 15
a2596 15
	if ((page_length = atoi(arg))) {
	  if (page_length < 1)
	    send_to_char("Invalid page length.\r\n", ch);
	  else if (page_length > 50)
	    send_to_char("Max page length is 50 right now.\r\n", ch);
	  else {
	    sprintf(buf, "Your new page length is %d lines.\r\n", page_length);
	    send_to_char(buf, ch);
	    GET_PAGE_LENGTH(tch) = page_length;
	  }
	} 
	else {
	  send_to_char("Page length restored to default (22 lines).\r\n", ch);
	  GET_PAGE_LENGTH(tch) = 22;
	}
d2598 53
a2650 1
	send_to_char("Specify at how many lines you want your page length to be.  (0 for default length)\r\n", ch);
d2656 1
a2656 1
  
d2669 1
a2669 1
	FALSE, ch, 0, 0, TO_ROOM);
d2680 1
a2680 1
	 FALSE,ch,0,0,TO_ROOM);
d2709 1
a2709 1
  sprintf(buf, "&0&6%s&0&6 petitions, '&b%s&0&6'&0\r\n", 
d2750 1
a2750 1
  
d2755 1
a2755 1
  
d2760 1
a2760 1
  
d2809 3
a2811 3
  
  if (!ch || (ch->in_room == NOWHERE))	/* They died in the meantime. Events should have been pulled
					   for them, but why trust that */
d2813 1
a2813 1
  
d2815 1
a2815 1
  
d2821 1
a2821 1
  
d2823 1
a2823 1
  
d2829 1
a2829 1
  
d2862 1
a2862 1
  } 
d2864 1
a2864 1
  one_argument(argument, arg);  
d2954 1
a2954 1
  
d2956 1
a2956 1
  
d2958 57
a3014 57
	if (!IS_NPC(vict)) {
		continue;
	} else {
		if (GET_LIFEFORCE(vict) == LIFE_UNDEAD) {
			act("You focus your powers on controlling $N.",FALSE,ch,0,vict,TO_CHAR);
			
    			if (mag_savingthrow(vict, SAVING_SPELL)) {*/ /*test for not falling prey*/
  			    /*to_char="$N resists your pitiful attempt to control $M.";
			    to_vict="&7&b$n tries to control you but fails!&0";
		            to_room="&7&b$n tries to control $N but nothing happens.&0";    
		            act(to_char, FALSE, ch, 0, vict, TO_CHAR);
		            act(to_vict, FALSE, ch, 0, vict, TO_VICT);
		            act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
		        } else {
			    if (mag_savingthrow(vict, SAVING_SPELL)) { *//*test for getting scared*/
	     		    	    /*to_char="$N starts to shake and gets very angry!";
				    to_vict="&7&b$n tries to control you so you attack him!&0";
			            to_room="&7&b$n tries to control $N, but $N becomes very angry!&0";    
			            act(to_char, FALSE, ch, 0, vict, TO_CHAR);
		        	    act(to_vict, FALSE, ch, 0, vict, TO_VICT);
			            act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
				    SET_FLAG(MOB_FLAGS(vict), MOB_AGGRESSIVE);
				    attack(vict, ch);
			    } else {
				    to_char="$N starts to wither and falls under your control!";
				    to_vict="&7&b$n gestures towards you and you feel your powers wither away!&0";
			            to_room="&7&b$n gestures at $N and gains complete control over $M!&0";    
			            act(to_char, FALSE, ch, 0, vict, TO_CHAR);
		        	    act(to_vict, FALSE, ch, 0, vict, TO_VICT);
			            act(to_room, TRUE, ch, 0, vict, TO_NOTVICT);
			    	    *//*set the mob as controlled (charmed) */
				    /*control_duration = ((GET_LEVEL(ch) * 20) + (GET_SKILL(ch, SKILL_CONTROL_UNDEAD) * 2))/60;
				    control_duration = 1;
				    af.type = SKILL_CONTROL_UNDEAD;
				    af.duration = control_duration;
				    af.bitvector = 0;
				    af.bitvector2 = 0;
				    af.bitvector3 = EFF_CONTROLLED;
				    af.modifier = 0;
				    af.location = APPLY_NONE;
				    affect_to_char(vict, &af);
				    SET_FLAG(MOB_FLAGS(vict), MOB_CONTROLLED);
				    af.type = SPELL_CHARM;
				    af.duration = control_duration + 1;
				    af.bitvector = EFF_CHARM;
				    af.bitvector2 = 0;
				    af.bitvector3 = 0;
				    af.modifier = 0;
				    af.location = APPLY_NONE;
				    affect_to_char(vict, &af);
				    add_follower(vict, ch);
				    REMOVE_FLAG(MOB_FLAGS(vict), MOB_AGGRESSIVE);
				    REMOVE_FLAG(MOB_FLAGS(vict), MOB_SPEC);
			    }
			}
		}
	}
d3039 1
a3039 1
  
d3041 1
a3041 1
  
d3066 1
a3066 1
  
d3068 1
a3068 1
  
d3134 3
d3887 1
a3887 1
 * Qucik 
d3906 1
a3906 1
 * Revision 1.26  1999/07/09 21:00:06  mud  
d3936 1
a3936 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.233
log
@Added the autosplit toggle and functionalized the split command.
Also added the autoloot toggle and removed the noname toggle.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.232 2008/04/02 04:55:59 myc Exp myc $
d1781 8
a1788 13
   sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(ch,C_NRM) : CCBBLK(ch,C_NRM)),
         (perc >= 100 ? CCNRM(ch, C_NRM) :
         perc >= 88 ? CCNRM(ch,C_NRM) :
         perc >= 70 ? CCBLD(ch,C_NRM) :
         perc >= 45 ? CCNRM(ch,C_NRM) :
         perc >= 20 ? CCNRM(ch,C_NRM) :
         perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
         (perc >= 100 ? CCNRM(ch, C_NRM) :
         perc >= 88 ? CCYEL(ch,C_SPR) :
         perc >= 70 ? CCYEL(ch, C_NRM) :
         perc >= 45 ? CCMAG(ch, C_NRM) :
         perc >= 20 ? CCRED(ch, C_NRM) :
         perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));
d1808 2
a1809 1
   CCUND(ch,C_NRM), GET_MAX_HIT(ch), GET_MOVE(ch), GET_MAX_MOVE(ch), CLASS_ABBR(ch));
d1821 1
a1821 1
      sprintf(buf, "%sYour group consists of:&0\r\n", CCUND(ch,C_NRM));
d2515 1
a2515 1
      sprintf(buf, "%s %s%s%11s  %5s&0 %s", buf, set ? QBLD : QNRM, QWHT,
d3070 4
@


1.232
log
@Redesigned the split command to randomly distribute extra monies.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.231 2008/04/02 03:24:44 myc Exp myc $
d1967 1
a1967 1
static void split_coins(struct char_data *giver, struct char_data *receiver, int coins[])
d1990 1
a1990 1
ACMD(do_split)
d1992 1
a1992 2
  int coins[NUM_COIN_TYPES], i, count, share[NUM_COIN_TYPES], 
      lucky_recipient[NUM_COIN_TYPES], j;
a1998 32
  if (IS_NPC(ch))
    return;

  if (!IS_GROUPED(ch)) {
    send_to_char("&2&8But you are not a member of any group!&0\r\n", ch);
    return;
  }

  skip_spaces(&argument);
  
  if (!*argument) {
    send_to_char("Split what?\r\n", ch);
    return;
  }
  
  if (!parse_money(argument, coins)) {
    send_to_char("That's not a coin type.\r\n", ch);
    return;
  }

  if (coins[PLAT] + coins[GOLD] + coins[SILVER] + coins[COPPER] <= 0) {
    send_to_char("Split zero coins?  Done.\r\n", ch);
    return;
  }

  for (i = 0; i < NUM_COIN_TYPES; ++i)
    if (coins[i] > GET_COINS(ch)[i]) {
      sprintf(buf, "You don't have enough %s!\r\n", coin_names[i]);
      send_to_char(buf, ch);
      return;
    }
  
d2039 1
a2039 1
     * split_coins()'s complexity significantly.
d2045 1
a2045 1
    split_coins(ch, members[i], share);
d2053 38
d2383 1
a2383 1
    { "NoName",	    LVL_IMMORT, PRF_NONAME },
d2396 1
d2434 2
a2435 2
	/*16*/	{"Mortals now see your name!\r\n",
		 "Mortals can no longer see your name!\r\n"},
d2460 2
d3074 3
@


1.231
log
@Rewrote group code and removed all major group code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.230 2008/03/30 17:30:38 jps Exp myc $
d1967 22
a1988 4
#define PLAT 0
#define GOLD 1
#define SILVER 2
#define COPPER 3
d1992 7
a1998 8
  int num, give, i, amt_kept;
  double amt_kept_pure = 0.0;
  int amount = 0;
  struct char_data *k;
  struct group_type *f;
  int cash[NUM_COIN_TYPES] = {0};
  int counter = 0;
  void split_coins(int coin_type, struct char_data *from, struct char_data *to, int give);
d2004 1
a2004 1
    send_to_char("&0But you are not a member of any group!&0\r\n", ch);
d2008 1
a2008 1
  argument = one_argument(argument, arg);	
d2010 4
a2013 5
  if (!*arg)
    {
      send_to_char("Split what?\r\n", ch);
      return;
    }
d2015 14
a2028 35
  
  if (is_number(arg)) 
    {
      amount = atoi(arg);
      while (is_number(arg))
	{
	  argument = one_argument(argument, arg);
	  if (!str_cmp("platinum", arg) || !str_cmp("p", arg)) 
	    cash[PLAT] = amount;
	  else if (!str_cmp("gold", arg) || !str_cmp("g", arg)) 
	    cash[GOLD] = amount;
	  else if (!str_cmp("silver", arg) || !str_cmp("s", arg)) 
	    cash[SILVER] = amount;
	  else if (!str_cmp("copper", arg) || !str_cmp("c", arg)) 
	    cash[COPPER] = amount;
	  else
	    {
	      send_to_char("That is not a coin type\r\n", ch);
	      return;
	    }
	  argument = one_argument(argument, arg);
	  if (!*arg)
	    break;
	  amount = atoi(arg);
	}
    }
  if ((cash[0] + cash[1] + cash[2] + cash[3]) <= 0)
    {
      send_to_char("No coins to split.\r\n", ch);
      return;
    }
  /*make sure he can afford it*/
  if ((cash[0] > GET_PLAT(ch)) || (cash[1] > GET_GOLD(ch)) || (cash[2] > GET_SILVER(ch)) || (cash[3] > GET_COPPER(ch)))
    {
      send_to_char("You can't afford that.\r\n", ch);
d2032 11
a2042 101
  k = (ch->group_master ? ch->group_master : ch);
  
  counter = 1;
  for (f = k->groupees; f; f = f->next)
    if (CAN_SEE(ch, f->groupee))	
      if (ch->in_room == f->groupee->in_room)	
	counter++;
  act("&0&7&b$N splits some coins.&0", FALSE, ch, 0, ch, TO_ROOM);
  
  for (i = 0;i < 4; i++)
    {
      if (cash[i] >=1)
	{
	  give = 0;
	  num = 0;
	  num = cash[i] % counter;
	  give = (int)(cash[i]/counter);
	  for (f = k->groupees; f; f = f->next)
	    {
	      if (IS_GROUPED(f->groupee) && ch != f->groupee)
		{

		  if (ch->in_room == f->groupee->in_room) {
		    if (num > 0)
		      {/*give + leftover*/
			split_coins(i, ch, f->groupee, (give + 1));	
		      }
		    else
		      {/*give*/
			split_coins(i, ch, f->groupee, give);
		      }
		  }
		  num--;
		}
	    }
	  if (k != ch)
	    split_coins(i, ch, k, give);
	}
    }
  send_to_char("&0&7&bYou split some coins with your group.&0\r\n", ch);
   /*  Demolitum (17 Oct 2001) - Show the splitter (giver) how much loot he got to keep. */
  for(i = 0; i < 4; i++)
    {
      if(cash[i] >= 1)
	{
	  num = cash[i] % counter;
	  amt_kept_pure = floor((cash[i] - 
                                ((ceil(cash[i]/counter)) * (counter - 1))));
	  amt_kept = (int)(amt_kept_pure);

	  if(num > 0)
	    amt_kept -= num;

	  if(amt_kept < 0)
	    amt_kept = 0;

	  switch(i)
	    {
	    case 0:
	      if(amt_kept == 0)
		strcpy(buf, "You forego your share of platinum.\r\n");
	      else if(amt_kept == 1)
		strcpy(buf, "You keep &b&61 &0platinum coin.\r\n");
              else
                sprintf(buf, "You keep &b&6%d &0platinum coins.\r\n", 
			amt_kept);
	      send_to_char(buf, ch);
	      break;
	    case 1:
	      if(amt_kept == 0)
		strcpy(buf, "You forego your share of gold.\r\n");
	      else if(amt_kept == 1)
		strcpy(buf, "You keep &0&b&31 &0gold coin.\r\n");
	      else
		sprintf(buf, "You keep &0&b&3%d &0gold coins.\r\n", amt_kept);
	      send_to_char(buf, ch);
	      break;
	    case 2:
	      if(amt_kept == 0)
		strcpy(buf, "You forego your share of silver.\r\n");
	      else if(amt_kept == 1)
		strcpy(buf, "You keep 1 silver coin.\r\n");
	      else
		sprintf(buf, "You keep %d silver coins.\r\n", amt_kept);
	      send_to_char(buf, ch);
	      break;
	    case 3:
	      if(amt_kept == 0)
		strcpy(buf, "You forego your share of copper.\r\n");
	      else if(amt_kept == 1)
		strcpy(buf, "You keep &0&31 &0copper coin.\r\n");
	      else
		sprintf(buf, "You keep &0&3%d &0copper coins.\r\n", amt_kept);
	      send_to_char(buf, ch);
	      break;
	    default:
	      break;
	    }
	}
    }
}
d2044 40
a2083 41
void split_coins(int coin_type, struct char_data *from, struct char_data *to, int give)
{
  switch (coin_type)
    {
    case PLAT:
      GET_PLAT(to) += (give);
      GET_PLAT(from) -= (give);
      if(give == 1)
	strcpy(buf, "You receive &b&61 &0platinum coin.\r\n");
      else
	sprintf(buf, "You receive &b&6%d &0platinum coins.\r\n", give);
      break;
    case GOLD:
      GET_GOLD(to) += (give);
      GET_GOLD(from) -= (give);
      if(give == 1)
	strcpy(buf, "You receive &0&b&31 gold coin.\r\n");
      else
	sprintf(buf, "You receive &0&b&3%d &0gold coins.\r\n", give);
      break;
    case SILVER:
      GET_SILVER(to) += (give);
      GET_SILVER(from) -= (give);
      if(give == 1)
	strcpy(buf, "You receive 1 silver coin.\r\n");
      else
	sprintf(buf, "You receive %d silver coins.\r\n", give);
      break;
    case COPPER:
      GET_COPPER(to) += (give);
      GET_COPPER(from) -= (give);
      if(give == 1)
	strcpy(buf, "You receive &0&31 &0copper coin.\r\n");
      else
	sprintf(buf, "You receive &0&3%d &0copper coins.\r\n", give);
      break;
    default:
      mudlog("Error overflow in split cash.", NRM, LVL_GOD, FALSE);
      return;
    }
  send_to_char(buf, to);
d3066 3
@


1.230
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.229 2008/03/28 17:54:53 myc Exp jps $
a274 1
  void die(struct char_data * ch, struct char_data * killer);
a1528 241
int perform_group(struct char_data *ch, struct char_data *vict)
{
  if (EFF_FLAGGED(vict, EFF_GROUP) || !CAN_SEE(ch, vict))
    return 0;
  
  SET_FLAG(EFF_FLAGS(vict), EFF_GROUP);
  if (ch != vict)
    act("&0&2&b$N is now a member of your group.&0", FALSE, ch, 0, vict, TO_CHAR);
  act("&0&2&bYou are now a member of $n's group.&0", FALSE, ch, 0, vict, TO_VICT);
  act("&0&2&b$N is now a member of $n's group.&0", FALSE, ch, 0, vict, TO_NOTVICT);
  return 1;
}

void make_group_report_line(struct char_data *ch, char *buffer) {
   int perc;
   char harm_color[20];

   perc = (100*GET_HIT(ch)/GET_MAX_HIT(ch));

   sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(ch,C_NRM) : CCBBLK(ch,C_NRM)),
         (perc >= 100 ? CCNRM(ch, C_NRM) :
         perc >= 88 ? CCNRM(ch,C_NRM) :
         perc >= 70 ? CCBLD(ch,C_NRM) :
         perc >= 45 ? CCNRM(ch,C_NRM) :
         perc >= 20 ? CCNRM(ch,C_NRM) :
         perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
         (perc >= 100 ? CCNRM(ch, C_NRM) :
         perc >= 88 ? CCYEL(ch,C_SPR) :
         perc >= 70 ? CCYEL(ch, C_NRM) :
         perc >= 45 ? CCMAG(ch, C_NRM) :
         perc >= 20 ? CCRED(ch, C_NRM) :
         perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));

   sprintf(buffer, "%s%-15s &0[", harm_color, GET_NAME(ch));
   if (GET_HIT(ch) < 10)
      strcat(buffer, "   ");
   else if (GET_HIT(ch) < 100)
      strcat(buffer, "  ");
   else if (GET_HIT(ch) < 1000)
      strcat(buffer, " ");

   sprintf(buf2, "%s%d&0&8h&0/", harm_color, GET_HIT(ch));
   strcat(buffer, buf2);
   if (GET_MAX_HIT(ch) < 10)
      strcat(buffer, "   ");
   else if (GET_MAX_HIT(ch) < 100)
      strcat(buffer, "  ");
   else if (GET_MAX_HIT(ch) < 1000)
      strcat(buffer, " ");

   sprintf(buf2, "%s%d&0&8H&0  %3dv/%3dV] [%s]", 
   CCUND(ch,C_NRM), GET_MAX_HIT(ch), GET_MOVE(ch), GET_MAX_MOVE(ch), CLASS_ABBR(ch));
   strcat(buffer, buf2);
}

void print_group(struct char_data *ch)
{
   struct char_data *k;
   struct group_type *f;

   if (!EFF_FLAGGED(ch, EFF_GROUP))
     send_to_char("&0&2&bBut you are not the member of a group!&0\r\n", ch);
   else {
      sprintf(buf, "%s&0&7&bYour group consists of:&0\r\n", CCUND(ch,C_NRM));
      send_to_char(buf, ch);

      k = (ch->groupmaster ? ch->groupmaster : ch);
      if (CAN_SEE(ch, k)) {
         make_group_report_line(k, buf); 
         strcat(buf, " (&0&2&bHead of group&0)\r\n");
         send_to_char(buf, ch);
      }
    
      for (f = k->groupees; f; f = f->next) {
         if (!EFF_FLAGGED(f->groupee, EFF_GROUP) || !CAN_SEE(ch,f->groupee))
            continue;

         make_group_report_line(f->groupee, buf);
         strcat(buf, "\r\n");
         send_to_char(buf, ch);
      }
   }
}

/*print out mgroup info*/
void mprint_group(struct char_data *ch)
{
  struct char_data *k;
  struct mgroup_type *f;
  struct group_type *g;
  if (!(ch->groupmaster) && (!(EFF_FLAGGED(ch, EFF_MAJOR_GROUP))))
    {/*should be group master but not in a large mgroup*/
      send_to_char("Your group is not in a major group\r\n", ch);
      return;
    }
  if ((ch->groupmaster) && (!(EFF_FLAGGED(ch->groupmaster, EFF_MAJOR_GROUP))))
    {
      send_to_char("Your group is not part of a major group\r\n", ch);
      return;
    }
  
  if (!(EFF_FLAGGED(ch, EFF_GROUP)))
    {
      send_to_char("&0&7&bYou are not a member of a group&0\r\n", ch);
      return;
    }
  
  if ((!(ch->groupmaster)) && (!(EFF_FLAGGED(ch, EFF_MAJOR_GROUP))))
    {
      send_to_char("&0&7&bYou are not a member of a major group&0\r\n", ch);
      return;
    }
  
  if (ch->groupmaster){
    if (!(EFF_FLAGGED(ch->groupmaster, EFF_MAJOR_GROUP)))
      {
	send_to_char("&0&2&bYour Group is not a member of a major group&0\r\n", ch);
	return;
      }
    
  }
  
  
  if (0)
    send_to_char("&0&1But you are not the member of a major group!&0\r\n", ch);
  else 
    {
      sprintf(buf, "%s&0&1Your group consists of:&0\r\n", CCUND(ch,C_NRM));
      send_to_char(buf, ch);
      /*check wether this person is a mgroupee or mgroup master*/
      if ((!(ch->mgroupmaster)) && (!(ch->groupmaster))) /*is MASTER */
	k = ch;
      else if ((!(ch->mgroupmaster)) && ((ch->groupmaster))) /*normal groupee*/
	{
	  if (!(ch->groupmaster->mgroupmaster))
	    k = ch->groupmaster;/*if groupmaster is the MASTER*/
	  else
	    {
	      if ((ch->groupmaster->mgroupmaster))
		k = (ch->groupmaster->mgroupmaster);
	      else
		{
		  sprintf(buf,"Very Bad Assign in mgroup display, Exiting: caused by %s", GET_NAME(ch));	
		  mudlog(buf, CMP, LVL_GOD, FALSE);
		}
	    }
	}
      else
	k = ch->mgroupmaster;
      if (EFF_FLAGGED(k, EFF_MAJOR_GROUP)) /*mgroup first in list*/
	{			sprintf(buf, "&0&1%-25s&0 [%3dV] [%s] (&1Head of major group&0)", GET_NAME(k), GET_MOVE(k), CLASS_ABBR(k));
	act(buf, FALSE, ch, 0, k, TO_CHAR);
	/*add the normal group member names*/
	
	for (g = k->groupees; g; g = g->next) /*normal group loop*/
	  {
	    if (!EFF_FLAGGED(g->groupee, EFF_GROUP))
	      continue;
	    sprintf(buf, "     &0&2&b%-20s&0 [%3dV] [%s]", GET_NAME(g->groupee), GET_MOVE(g->groupee), CLASS_ABBR(g->groupee));
	    act(buf, FALSE, ch, 0, g->groupee, TO_CHAR);
	  }
	}
      
      
      for (f = k->mgroupees; f; f = f->next) 
	{
	  if (!EFF_FLAGGED(f->mgroupee, EFF_MAJOR_GROUP))
	    continue;
	  sprintf(buf, "&0&1%-25s&0 [%3dV] [%s] (&2&bHead of minor group&0)", GET_NAME(f->mgroupee), GET_MOVE(f->mgroupee), CLASS_ABBR(f->mgroupee));
	  act(buf, FALSE, ch, 0, f->mgroupee, TO_CHAR);
	  for (g = f->mgroupee->groupees; g; g = g->next) 
	    {
	      if (!EFF_FLAGGED(g->groupee, EFF_GROUP))
		continue;
	      sprintf(buf, "     &0&2&b%-20s&0 [%3dV] [%s]", GET_NAME(g->groupee), GET_MOVE(g->groupee), CLASS_ABBR(g->groupee));
	      act(buf, FALSE, ch, 0, g->groupee, TO_CHAR);
	    }	
	}
    }
}

#define GROUP 1
#define MGROUP 2
#define FOLL 3
ACMD(do_readlist)
{
  void readfoll(struct char_data *ch);
  void readlist(struct char_data *ch);
  void readmlist(struct char_data *ch);
  struct char_data *person = NULL;
  int list;
  argument = one_argument(argument, buf);
  
  switch(*buf)
    {
    case 'f':
      send_to_char("Listings of characters followers:\r\n", ch);
      list = FOLL;
      break;
    case 'g':
      send_to_char("Listings of characters group:\r\n", ch);
      list = GROUP;
      break;
    case 'm':
      send_to_char("Listings of characters major group members:\r\n", ch);
      list = MGROUP;
      break;
    default:
      send_to_char("Option supported try:\r\n", ch);
      send_to_char("f - followers list\r\n", ch);
      send_to_char("g - group list\r\n", ch);
      send_to_char("m - major group list\r\n", ch);
      return;
    }
  one_argument(argument, buf);
  if (*buf) /*(argument with it)*/
    {	
      if (!(person = get_char_room_vis(ch, buf))) 
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/
    } 
  switch (list)
    {
    case FOLL:
      readfoll(person);
      break;
    case GROUP:
      readlist(person);
      break;
    case MGROUP:
      readmlist(person);
      break;
    default:
      send_to_char("Incorrect List Option\r\n", ch);
      return;
    }
}

d1668 1
a1668 7
  void stop_groupee(struct char_data *ch, bool hide);
  void die_mgroupee(struct char_data *ch);    
  
  struct group_type *f, *g;
  /*ch is thus the actual leader*/
 
  if (ch->groupmaster || !(EFF_FLAGGED(ch, EFF_GROUP))) {
a1671 21
  if (EFF_FLAGGED(ch, EFF_MAJOR_GROUP))
    die_mgroupee(ch);
  
  act("&0&2&b$n has disbanded $s group.&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
  for (f = ch->groupees; f; f = g) {
    ch->groupees = f->next;	
    g = f->next;
    
    REMOVE_FLAG(EFF_FLAGS(f->groupee), EFF_GROUP);
    act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch, 0, f->groupee, TO_VICT);
    f->groupee->groupmaster = NULL;
    
    free(f);
    
  }
  send_to_char("&0&2&bYou disband the group.&0\r\n", ch);
  ch->groupees = NULL;	
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_GROUP);
  /*remove group flag of leader*/
}

d1673 1
a1673 29
ACMD(do_mdisband)
{
  void stop_mgroupee(struct char_data *ch, bool hide);
  struct mgroup_type *f, *g;
  /*ch is thus the actual leader*/
  if (ch->mgroupmaster || !(EFF_FLAGGED(ch, EFF_MAJOR_GROUP))) {
    send_to_char("&0&1But you lead no major group!&0\r\n", ch);
    return;
  }
  /*if he a member of a major group remove him from that*/
  sprintf(buf,"&0&1%s has disbanded his major group.&0\r\n",
	  GET_NAME(ch));
  for (f = ch->mgroupees; f; f = g) 
    {
      g = f->next;
      ch->mgroupees = f->next;
      act("&0&1You have been kicked out of $n's major group!&0", FALSE, ch, 0, f->mgroupee, TO_VICT);
      send_to_char(buf, f->mgroupee);
      f->mgroupee->mgroupmaster = NULL;
      REMOVE_FLAG(EFF_FLAGS(f->mgroupee), EFF_MAJOR_GROUP);
      free(f);
      
      
    }
  send_to_char("&0&1You disband the major group.&0\r\n", ch);
  ch->mgroupees = NULL;
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
  
  /*remove group flag of leader*/
a1676 125
ACMD(do_mgroup)
{
  struct char_data *newmgroupee;
  void stop_mgroupee(struct char_data *ch, bool hide);
  void add_mgroupee(struct char_data *ch, struct char_data *leader, bool hide);
  void die_mgroupee(struct char_data * ch);
  one_argument(argument, buf);
  
  /*do some removal*/
  if (!(EFF_FLAGGED(ch, EFF_GROUP)))
    {/*check to see if in a normal group*/
      send_to_char("You are not even in a group!\r\n", ch);
      return;
    }
  
  if (*buf) /*(argument with it)*/
    {	
      if (!(newmgroupee = get_char_vis(ch, buf))) 
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/
    } 
  else 
    {
      if (!*buf) 
	{
	  mprint_group(ch);
	  return;
	}
    }
  if (IS_NPC(newmgroupee))
    {
      send_to_char("Sorry he doesnt want to be major grouped\r\n", ch);
      return;
    }   
  
  if (!(EFF_FLAGGED(newmgroupee, EFF_GROUP)))
    {/*check to see if in a normal group*/
      send_to_char("He is not even in a group!\r\n", ch);
      return;
    }
  if ((newmgroupee->groupees == NULL))
    {/*check to see if in a normal group*/
      send_to_char("He is not a group leader!\r\n", ch);
      return;
    }
  
  if ((newmgroupee->groupmaster))/*you must also be head of a group*/
    {
      if (ch != newmgroupee)
	{
	  act("You can not enroll a &0&1major group&0 member unless he the head of a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  
  if (newmgroupee == ch)
    {
      if ((EFF_FLAGGED(ch, EFF_MAJOR_GROUP)))
	{
	  /*remove character then*/
	  die_mgroupee(ch);
	  send_to_char("&0&1You remove yourself from the major group&0\r\n", ch);
	  return;
	}
    }
  
  if (ch->groupmaster)/*you must also be head of a group*/
    {
      act("You can not enroll a group member unless you are head of a &0&1major&0 group.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if (ch->mgroupmaster) /*cant enrol a group member if you are in a group!! and not boss*/
    {
      act("You can not enroll &0&1major&0 group members without being head of a &1major&0 group.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if ((newmgroupee->mgroupmaster) && (newmgroupee->mgroupmaster != ch))/*if person inanother group inform him*/
    {
      act("&0That person is already in a &1major&0 group.&0",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  if (newmgroupee->mgroupees)
    {
      act("&0That person is leading a differnt &1major&0 group.&0",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
      
    }
  
  if (ch->mgroupmaster == newmgroupee) 
    {
      act("&0You cant group your own &1major&0 group master.&0", FALSE, ch, 0, newmgroupee, TO_CHAR);
      return;
    }
  
  
  if (newmgroupee->mgroupmaster == ch) 
    {/*remove him from group then*/
      act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0",
	  FALSE, ch, 0, newmgroupee, TO_CHAR);
      act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, ch,
	  0, newmgroupee, TO_VICT);
      act("&0&1$N has been kicked out of $n's &0&1&bmajor&0 group.&0", FALSE, ch, 0,
	  newmgroupee, TO_NOTVICT);
      stop_mgroupee(newmgroupee, 0);
      return;
    } 
  
  if ((CONSENT(newmgroupee) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
    {
      act("You do not have $S consent.", TRUE, ch, NULL, newmgroupee, TO_CHAR);
      return;
    }
  SET_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
  add_mgroupee(newmgroupee, ch, 0);/*adds flag*/
  
}

a1726 2
/*bandage code written by Proky pretty straight forward*/
/* Rewritten by _lao_ to be more straightforward. */
d1775 5
d1781 37
a1817 1
ACMD(do_group)
d1819 19
a1837 9
   struct char_data *newgroupee = NULL;
   void stop_groupee(struct char_data *ch, bool hide);
   void add_groupee(struct char_data *ch, struct char_data *leader, bool noisy);
   void die_groupee(struct char_data * ch);
   bool all = 0;
   int found = 0;
   int foundbad = 0; 
   struct follow_type *f;   
   int level_diff; 
d1839 4
a1842 5
   one_argument(argument, buf);
  
   if (!*buf) { /*(no argument with it, just asking for group info)*/
      print_group(ch);
      return;
d1844 7
d1852 1
a1852 4
   if (GET_POS(ch) < POS_RESTING) { /*(only info while sleeping, not actual grouping)*/
      send_to_char("In your dreams, or what?\r\n",ch);
      return;
   }
d1854 5
a1858 7
   /*check for all command*/
   if (!str_cmp("all", buf)) {
      all = 1;
   } else if (!(newgroupee = get_char_room_vis(ch, buf))) {
      send_to_char(NOPERSON, ch);
      return;
   }
d1860 5
a1864 1
   /*see if ch in group or creating one*/
d1866 6
a1871 7
   if (ch->groupmaster) { /*cant enroll a group member if you are in a group!! and not boss*/
      if (ch != newgroupee) {
         act("You can not enroll group members without being head of a group.",
               FALSE, ch, 0, 0, TO_CHAR);
         return;
      }
   }
d1873 8
a1880 27
   if (all) {
      for (found = 0, f = ch->followers; f; f = f->next) {
         if ((f->follower->groupmaster) && (f->follower->groupmaster != ch))
            continue;
         if ((!f->follower->groupmaster) && (EFF_FLAGGED(f->follower, EFF_GROUP)))
            continue;
         if (EFF_FLAGGED(f->follower, EFF_GROUP))
            continue;
         if ((CONSENT(f->follower) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
            if (!(IS_NPC(f->follower) && (f->follower->master == ch)))
               continue;

         level_diff = GET_LEVEL(f->follower) - GET_LEVEL(ch); 

         if (max_group_difference && (level_diff > max_group_difference ||
               level_diff < -max_group_difference)) {
            char mgd_buf[1024]; 
            snprintf(mgd_buf, 1024,
                  "You cannot group %s because the level difference is too great (maximum of %i)\r\n",
                  GET_NAME(f->follower), max_group_difference); 
            send_to_char(mgd_buf, ch); 
            foundbad++; 
         } else {
            add_groupee(f->follower, ch, 1);
            found++;
         }
      }
d1882 5
a1886 7
      if (!found && !foundbad) {
         send_to_char("Everyone following you is already in your group.\r\n", ch);
      } else if (foundbad) {
      } else
         SET_FLAG(EFF_FLAGS(ch), EFF_GROUP);
      return;
   } /* if (all) */
d1888 4
a1891 4
   if ((ch == newgroupee) && (!(EFF_FLAGGED(ch, EFF_GROUP)))) {
      send_to_char("You are not a member of a group!\r\n", ch);
      return;
   }
d1893 21
a1913 6
   if ((newgroupee->groupmaster) && (newgroupee->groupmaster != ch)) {
      /*if person inanother group inform him*/
      if (ch != newgroupee) {
         act("That person is already in a group.",
               FALSE, ch, 0, 0, TO_CHAR);
         return;
a1914 1
   }
d1916 3
a1918 7
   if ((!newgroupee->groupmaster) && (EFF_FLAGGED(newgroupee, EFF_GROUP))) {
      if (ch != newgroupee) {
         act("That person is leading a group.",
               FALSE, ch, 0, 0, TO_CHAR);
         return;
      }
   }
d1920 4
a1923 4
   if (ch->groupmaster == newgroupee) {
      act("You can't group your own group master.", FALSE, ch, 0, newgroupee, TO_CHAR);
      return;
   }
d1925 4
a1928 20
   if (ch == newgroupee) {
      /*remove yourself from group*/
      die_groupee(ch);
      send_to_char("&0&2&bYou remove yourself from the group.&0\r\n", ch);
      return;
   }
  
   /*last chance removal of grouping people who are already in a group*/
  
   if (newgroupee->groupmaster == ch) {
      /*remove him from group then*/
      act("&0&2&b$N is no longer a member of your group.&0", FALSE, ch, 0,
            newgroupee, TO_CHAR);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch, 0,
            newgroupee, TO_VICT);
      act("&0&2&b$N has been kicked out of $n's group.&0", FALSE, ch, 0, newgroupee,
            TO_NOTVICT);   
      stop_groupee(newgroupee, 0);
      return;
   }
d1930 7
a1936 2
   /*handle followers that are NPCs*/
   /*handle it within the consent handle*/
d1938 5
a1942 6
   if ((CONSENT(newgroupee) != ch) && (GET_LEVEL(ch) < LVL_IMMORT)) {
      if (!(IS_NPC(newgroupee) && newgroupee->master == ch && EFF_FLAGGED(newgroupee, EFF_CHARM))) {
         act("You do not have $S consent.", TRUE, ch, NULL, newgroupee, TO_CHAR);
         return;
      }
   }
d1944 4
a1947 2
   if (EFF_FLAGGED(newgroupee, EFF_GROUP)) {   
      send_to_char("That person is quite happy in his group.\r\n", ch);
d1949 2
a1950 1
   }
d1952 1
a1952 1
   level_diff = GET_LEVEL(ch) - GET_LEVEL(newgroupee); 
d1954 8
a1961 10
   if (max_group_difference && (level_diff > max_group_difference ||
         level_diff < -max_group_difference)) {
      char mgd_buf[1024]; 

      snprintf(mgd_buf, 1024, "You cannot group %s, because the level "
            "difference is too great.  (Max allowable is currently %i).\r\n", 
            GET_NAME(newgroupee), max_group_difference); 
      send_to_char(mgd_buf, ch); 
      return; 
   }
d1963 1
a1963 2
   SET_FLAG(EFF_FLAGS(ch), EFF_GROUP);
   add_groupee(newgroupee, ch, 1);/*adds flag*/
d1982 1
d1985 6
a1990 5
  if (!EFF_FLAGGED(ch, EFF_GROUP)) 
    {
      send_to_char("&0But you are not a member of any group!&0\r\n", ch);
      return;
    }
d2037 1
a2037 1
  k = (ch->groupmaster ? ch->groupmaster : ch);
d2056 1
a2056 1
	      if ((EFF_FLAGGED(f->groupee, EFF_GROUP)) && (ch != f->groupee))
d3162 4
@


1.229
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.228 2008/03/26 23:32:00 jps Exp myc $
d42 1
d3552 4
@


1.228
log
@Prevent stealing things when in a fluid state.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.227 2008/03/26 16:44:36 jps Exp jps $
d692 1
a692 1
  GET_PROMPT(mob) = str_dup(GET_PROMPT(ch));
d994 1
a994 1
    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d1029 1
a1029 1
      REMOVE_BIT(PLR_FLAGS(ch), PLR_BOUND);
d1045 1
a1045 1
	REMOVE_BIT(PLR_FLAGS(ch), PLR_BOUND);
d1051 1
a1051 1
    REMOVE_BIT(PLR_FLAGS(vict), PLR_BOUND);
d1068 1
a1068 1
  if (IS_FIGHTING(ch)) {
d1106 1
a1106 1
	SET_BIT(PLR_FLAGS(vict), PLR_BOUND);
d1126 1
a1126 1
	SET_BIT(PLR_FLAGS(vict), PLR_BOUND);
d1214 1
a1214 1
   if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d1429 2
a1430 2
   if (AFF_FLAGGED(ch, AFF_INVISIBLE) || IS_HIDDEN(ch) ||
       AFF3_FLAGGED(ch, AFF3_CAMOUFLAGED)) {
d1531 1
a1531 1
  if (IS_AFFECTED(vict, AFF_GROUP) || !CAN_SEE(ch, vict))
d1534 1
a1534 1
  SET_BIT(AFF_FLAGS(vict), AFF_GROUP);
d1589 1
a1589 1
   if (!IS_AFFECTED(ch, AFF_GROUP))
d1603 1
a1603 1
         if (!IS_AFFECTED(f->groupee, AFF_GROUP) || !CAN_SEE(ch,f->groupee))
d1619 1
a1619 1
  if (!(ch->groupmaster) && (!(IS_AFFECTED2(ch, AFF2_MGROUP))))
d1624 1
a1624 1
  if ((ch->groupmaster) && (!(IS_AFFECTED2(ch->groupmaster, AFF2_MGROUP))))
d1630 1
a1630 1
  if (!(IS_AFFECTED(ch, AFF_GROUP)))
d1636 1
a1636 1
  if ((!(ch->groupmaster)) && (!(IS_AFFECTED2(ch, AFF2_MGROUP))))
d1643 1
a1643 1
    if (!(IS_AFFECTED2(ch->groupmaster, AFF2_MGROUP)))
d1678 1
a1678 1
      if (IS_AFFECTED2(k, AFF2_MGROUP)) /*mgroup first in list*/
d1685 1
a1685 1
	    if (!IS_AFFECTED(g->groupee, AFF_GROUP))
d1695 1
a1695 1
	  if (!IS_AFFECTED2(f->mgroupee, AFF2_MGROUP))
d1701 1
a1701 1
	      if (!IS_AFFECTED(g->groupee, AFF_GROUP))
d1791 1
a1791 1
  else if (!AFF2_FLAGGED(vict, AFF2_ON_FIRE)) {
d1902 1
a1902 1
    REMOVE_BIT(AFF2_FLAGS(vict), AFF2_ON_FIRE);
d1915 1
a1915 1
  if (ch->groupmaster || !(IS_AFFECTED(ch, AFF_GROUP))) {
d1919 1
a1919 1
  if (IS_AFFECTED2(ch, AFF2_MGROUP))
d1927 1
a1927 1
    REMOVE_BIT(AFF_FLAGS(f->groupee), AFF_GROUP);
d1936 1
a1936 1
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
d1946 1
a1946 1
  if (ch->mgroupmaster || !(IS_AFFECTED2(ch, AFF2_MGROUP))) {
d1960 1
a1960 1
      REMOVE_BIT(AFF2_FLAGS(f->mgroupee), AFF2_MGROUP);
d1967 1
a1967 1
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d1982 1
a1982 1
  if (!(IS_AFFECTED(ch, AFF_GROUP)))
d2011 1
a2011 1
  if (!(IS_AFFECTED(newmgroupee, AFF_GROUP)))
d2034 1
a2034 1
      if ((IS_AFFECTED2(ch, AFF2_MGROUP)))
d2093 1
a2093 1
  SET_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d2245 1
a2245 1
         if ((!f->follower->groupmaster) && (IS_AFFECTED(f->follower, AFF_GROUP)))
d2247 1
a2247 1
         if (IS_AFFECTED(f->follower, AFF_GROUP))
d2273 1
a2273 1
         SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
d2277 1
a2277 1
   if ((ch == newgroupee) && (!(IS_AFFECTED(ch, AFF_GROUP)))) {
d2291 1
a2291 1
   if ((!newgroupee->groupmaster) && (IS_AFFECTED(newgroupee, AFF_GROUP))) {
d2329 1
a2329 1
      if (!(IS_NPC(newgroupee) && newgroupee->master == ch && IS_AFFECTED(newgroupee, AFF_CHARM))) {
d2335 1
a2335 1
   if (IS_AFFECTED(newgroupee, AFF_GROUP)) {   
d2353 1
a2353 1
   SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
d2375 1
a2375 1
  if (!IS_AFFECTED(ch, AFF_GROUP)) 
d2445 1
a2445 1
	      if ((IS_AFFECTED(f->groupee, AFF_GROUP)) && (ch != f->groupee))
d2743 1
a2743 1
  GET_PROMPT(ch) = str_dup(argument);
a2825 3
#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))


d3093 1
a3093 1
    SET_BIT(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
d3099 1
a3099 1
    REMOVE_BIT(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL);
d3243 2
a3244 2
  SET_BIT(AFF_FLAGS(mount), AFF_CHARM);
  SET_BIT(AFF_FLAGS(mount), AFF_TAMED);
d3396 1
a3396 1
				    SET_BIT(MOB_FLAGS(vict), MOB_AGGRESSIVE);
d3412 1
a3412 1
				    af.bitvector3 = AFF3_CONTROLLED;
d3416 1
a3416 1
				    SET_BIT(MOB_FLAGS(vict), MOB_CONTROLLED);
d3419 1
a3419 1
				    af.bitvector = AFF_CHARM;
d3426 2
a3427 2
				    REMOVE_BIT(MOB_FLAGS(vict), MOB_AGGRESSIVE);
				    REMOVE_BIT(MOB_FLAGS(vict), MOB_SPEC);
d3551 3
@


1.227
log
@Replaced all checks for undead race with checks for undead lifeforce.
Replaced the undead race with the plant race.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.226 2008/03/22 03:22:38 myc Exp jps $
d41 1
d1218 4
d3554 4
@


1.226
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.225 2008/03/19 18:29:59 myc Exp myc $
d3310 1
a3310 1
    if (IS_PC(vict) || (!IS_EVIL(vict) && GET_RACE(vict) != RACE_UNDEAD))
d3314 1
a3314 1
    else if (GET_RACE(vict) == RACE_UNDEAD)
d3326 1
a3326 1
    if (GET_RACE(vict) == RACE_UNDEAD)
d3376 1
a3376 1
		if (GET_RACE(vict) == RACE_UNDEAD) {
d3549 6
@


1.225
log
@Shapeshifted creatures inherit the sex from their original players.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.224 2008/03/19 04:32:14 myc Exp myc $
d2873 1
d2935 2
d3549 3
@


1.224
log
@Fixed typo in do_quit.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.223 2008/03/17 15:31:27 myc Exp myc $
d719 3
d3546 3
@


1.223
log
@Remove the camp event flag when leaving the game for proper clean-up.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.222 2008/03/10 20:46:55 myc Exp myc $
d313 1
a313 1
    act("$n quits the game but is unable to fend of death...", TRUE, ch, 0, 0, TO_ROOM);
d3543 3
@


1.222
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.221 2008/03/10 18:01:17 myc Exp myc $
d1003 1
d3543 3
@


1.221
log
@Instead of taking off the berserk effect in multiple places, like
when camping, we'll do it when saving the player.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.220 2008/03/08 22:29:06 myc Exp myc $
d522 1
a522 1
        i = GET_COOLDOWN(player, CD_SHAPECHANGE) / (SECS_PER_MUD_HOUR RL_SEC);
d524 1
a524 1
                     MAX(1, MIN(i, 5)) * SECS_PER_MUD_HOUR RL_SEC);
d556 1
a556 1
    i = GET_COOLDOWN(ch, CD_SHAPECHANGE) / (SECS_PER_MUD_HOUR RL_SEC) + 1 ;
d3191 1
a3191 1
    SET_COOLDOWN(ch, CD_SUMMON_MOUNT, 7 * SECS_PER_MUD_DAY RL_SEC);
d3336 1
a3336 1
    SET_COOLDOWN(ch, CD_LAY_HANDS, 4 * SECS_PER_MUD_HOUR RL_SEC);
d3458 1
a3458 1
  SET_COOLDOWN(ch, CD_FIRST_AID, SECS_PER_MUD_DAY RL_SEC);
d3542 4
@


1.220
log
@Moving shapechange and chant to the cooldown system.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.219 2008/03/07 21:21:57 myc Exp myc $
a318 6
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
    affect_from_char(ch, SKILL_BERSERK);
    REMOVE_BIT(AFF_FLAGS(ch), AFF_BERSERK);
    GET_RAGE(ch) = 0;
  }

a981 6
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
    affect_from_char(ch, SKILL_BERSERK);
    REMOVE_BIT(AFF_FLAGS(ch), AFF_BERSERK);
    GET_RAGE(ch) = 0;
  }

d3542 3
@


1.219
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.218 2008/03/06 05:11:51 myc Exp myc $
d527 5
a531 3
      if (GET_LEVEL(player) < LVL_IMMORT)
        player->player_specials->chant =
                MAX(1, MIN(ch->char_specials.timer, 5));
d561 3
a563 5
  /* Note: I am using the chant varible since monks are the only ones
           that use it. Should a problem arise we can add a seperate
           variable for shapechange. Zantir */
  if (ch->player_specials->chant > 0 && GET_LEVEL(ch) < LVL_IMMORT) {
    if (ch->player_specials->chant == 1)
d566 1
a566 1
      sprintf(buf1, "%d hours", ch->player_specials->chant);
d3554 5
@


1.218
log
@Combined the 'saved' and 'unsaved' portions of the char_specials and
player_specials structures by moving all fields of each saved structure
to its parent structure.  Also combined the skills array from the
player and mob structures since they are identical.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.217 2008/03/05 05:21:56 myc Exp myc $
d3199 1
a3199 1
    if (ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]) {
d3203 1
a3203 1
    ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT] = (7 * SECS_PER_MUD_DAY) * PASSES_PER_SEC;
d3279 1
a3279 1
  if (SKILL_DELAY(ch, SKILL_LAY_HANDS)) {
d3348 1
a3348 1
    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_HOUR * 4;
d3455 1
a3455 1
  if (!IS_NPC(ch) && ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]) {
d3462 5
a3466 10
  if (!IS_NPC(ch)) {
    if (number(1, 101) < GET_SKILL(ch, SKILL_FIRST_AID) &&
        GET_HIT(ch) < GET_MAX_HIT(ch)) {
      GET_HIT(ch) += dice(6, GET_LEVEL(ch) - 1);
      if (GET_HIT(ch) > GET_MAX_HIT(ch))
        GET_HIT(ch) = GET_MAX_HIT(ch);
    }
    improve_skill(ch, SKILL_FIRST_AID);
  
    ch->char_specials.action_delays[ACT_DELAY_FIRST_AID] = (SECS_PER_MUD_DAY * PASSES_PER_SEC);
d3468 3
d3554 6
@


1.217
log
@Got rid of old save_char_file_u declaration.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.216 2008/03/05 03:03:54 myc Exp myc $
d528 1
a528 1
        player->player_specials->saved.chant =
d562 2
a563 2
  if (ch->player_specials->saved.chant > 0 && GET_LEVEL(ch) < LVL_IMMORT) {
    if (ch->player_specials->saved.chant == 1)
d566 1
a566 1
      sprintf(buf1, "%d hours", ch->player_specials->saved.chant);
d709 1
a709 1
  memset(&mob->mob_specials.skills, 0, sizeof(mob->mob_specials.skills));
d3556 3
@


1.216
log
@Changed the spell memory structures.  Also new ascii pfiles are in,
so the do_save and do_title commands have been updated.
Also made the default prompts (that were in the do_display command)
constants in constants.c.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.215 2008/02/24 17:31:13 myc Exp myc $
a62 1
extern void save_char_file_u(struct char_file_u st);
d3556 6
@


1.215
log
@Added an OLCComm toggle which allows you to receive communication
while in OLC.  Also a NoClanTell toggle for members of a clan.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.214 2008/02/11 21:04:01 myc Exp myc $
d39 2
d236 1
a236 1
    memorized = ch->spell_list;
d240 1
a240 1
      if (skills[last_mem->spell].min_level[subclass] == LVL_IMMORT)
d770 1
a770 3
  char plyr2save[30];
  char_data *char2save = NULL;
  struct char_file_u char2save_fu;
d777 2
a778 3
  if(GET_LEVEL(ch) >= LVL_GOD)
  {
    one_argument(argument, plyr2save);
d780 8
a787 38
    if (*plyr2save)  /*  if a player name has been specified */
    {
      plyr2save[0] = toupper(plyr2save[0]);
      /*save all players within the realm*/
      if(strcmp(plyr2save, "All") == 0) {
	Crash_save_all();
	sprintf(buf, "You have saved all players in the realm.\r\n");
	send_to_char(buf, ch);
	send_to_all("Autosaving.....\r\n");
	sprintf(buf, "(GC) %s has saved all players in the realm.", GET_NAME(ch));
	mudlog(buf, BRF, GET_LEVEL(ch), TRUE);
      } else {
 
	/*  try to locate this player within the realm */
	char2save = get_char(plyr2save);

	if(char2save != NULL)  /*  player is online */
	  {
	    /*  save this player */
	    save_player(char2save);
	    Crash_crashsave(char2save);
	    char_to_store(char2save, &char2save_fu);
	    save_char_file_u(char2save_fu);
	    if (ROOM_FLAGGED(char2save->in_room, ROOM_HOUSE_CRASH))
	      House_crashsave(world[char2save->in_room].number);
	    sprintf(buf, "You have saved the player %s to file.\r\n", plyr2save);
	    send_to_char(buf, ch);
	    sprintf(buf, "(GC) %s has saved %s to file.", GET_NAME(ch), plyr2save);
	    mudlog(buf, BRF, GET_LEVEL(ch), TRUE);
	  }
	else  /*  player is not online */
	  {
	    sprintf(buf, "No player by the name of %s is currently in the game.\r\n", plyr2save);
	    send_to_char(buf, ch);
	  }
	
	return;
      }
d789 5
a793 1
    /*  otherwise, process this as a normal save on the caller */
d795 2
d800 12
a811 1
  
d813 4
a816 1
    sprintf(buf, "Saving %s.\r\n", GET_NAME(ch));
d819 9
a827 5
  save_player(ch);
  /*GET_LOADROOM(ch) = world[ch->in_room].number;*/
  Crash_crashsave(ch);
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE_CRASH))
    House_crashsave(world[ch->in_room].number);
d1471 2
a1472 2
    for (which = 0; which < NUM_P_TITLES; ++which)
      if (GET_PTITLE(ch, which)[0] != '\0')
d1484 6
a1489 4
      for (which = 0; which < NUM_P_TITLES; ++which)
        if (*GET_PTITLE(ch, which))
          sprintf(buf, "%s  %d) %s\r\n", buf, ++titles,
                  ch->player_specials->saved.titles[which]);
d1510 2
a1511 2
    for (i = 0; i < NUM_P_TITLES; ++i)
      if (*GET_PTITLE(ch, i))
d1513 1
a1513 1
          set_title(ch, GET_PTITLE(ch, i));
d1515 1
a1515 1
      }
d1524 6
a1529 2
    sprintf(buf, "Okay, set your title to: %s\r\n", GET_TITLE(ch));
    send_to_char(buf, ch);
a2693 22
  const char *def_prompts[][2] = {
    { "Basic",
      "&0%hhp %vmv>&0 " },
    { "Colorized Basic",
      "&1&b%h&0&1hp &2&b%v&0&2mv&0> " },
    { "Basic Percentages",
      "&1&b%ph&0&1hp &2&b%pv&0&2mv&0> " },
    { "Full-Featured",
      "&6Opponent&0: &4&b%o &7&b/ &0&6Tank&0: &4&b%t%_&0&1%h&0(&1&b%H&0)"
      "hitp &2%v&0(&2&b%V&0)&7move&0> " },
    { "Standard",
      "&2&b<&0&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)&2&b>%_"
      "&0<%t&0>:<&0%o&0> " },
    { "Complete w/ Spells",
      "&2&b<&0&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)&2&b> "
      "<&0&2%aA %ih&2&b> <&0%l&2&b>%_&0<%t&0>:<&0%o&0> " },
    { "Complete w/ Exp",
      "&2&b<&0&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)&2&b> "
      "<&0&2%aA %ih&2&b> <&0%e&2&b>%_&0<%t&0>:<&0%o&0> " },
    { NULL, NULL }
  };
  
d2698 3
a2700 2
    for (i = 0; def_prompts[i][0]; i++) {
      sprintf(buf, "%2d. %-20s %s\r\n", i, def_prompts[i][0], def_prompts[i][1]);
d2714 1
a2714 1
  for (x = 0; def_prompts[x][0]; ++x);
d2725 2
a2726 2
  GET_PROMPT(ch) = str_dup(def_prompts[i][1]);
  sprintf(buf, "Set your prompt to the %s preset prompt.\r\n", def_prompts[i][0]);
d2778 1
a2778 1
         get_filename(buf, note_buf , NOTES_FILE); 
d3557 4
@


1.214
log
@Make the do_not_here command placeholder for spec-procs give a little
more information on /why/ you cannot do that here.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.213 2008/02/10 20:28:42 jps Exp myc $
d2876 29
a2904 27
    { "NoSummon",   LVL_IMMORT, PRF_SUMMONABLE},
    { "NoHassle",   LVL_IMMORT, PRF_NOHASSLE},  
    { "Brief",	    0,          PRF_BRIEF},
    { "Compact",    0,          PRF_COMPACT},  
    { "Tell",	    0,	        PRF_NOTELL},
    { "AFK",        0,          PRF_AFK},
    { "NoShout",    0,	        PRF_DEAF},
    { "NoGossip",   0,          PRF_NOGOSS},  
    { "NoHints",    0,          PRF_NOHINTS},
    { "NoWiznet",   LVL_IMMORT, PRF_NOWIZ},  
    { "Quest", 	    LVL_IMMORT, PRF_QUEST},  
    { "RoomFlags",  LVL_IMMORT, PRF_ROOMFLAGS},
    { "NoRepeat",   0,	        PRF_NOREPEAT},  
    { "Holylight",  LVL_IMMORT, PRF_HOLYLIGHT},
    { "Autoexit",   0,          PRF_AUTOEXIT},
    { "NoPetition", LVL_IMMORT, PRF_NOPETI},  
    { "NoName",	    LVL_IMMORT, PRF_NONAME},
    { "Anonymous",  50,	        PRF_ANON},  
    { "ShowVnums",  LVL_IMMORT, PRF_SHOWVNUMS},
    { "Wimpy",	    0,	        0},
    { "NiceArea",   0,	        PRF_NICEAREA},
    { "Vicious",    0,          PRF_VICIOUS},
    { "Passive",    0,          PRF_PASSIVE},
    { "PageLength", 0,          0},
    { "NoFollow",   0,          PRF_NOFOLLOW},
    { "RoomVis",    LVL_IMMORT, PRF_ROOMVIS},
    { "\n",	    0,	        0}
d2961 4
d2977 2
a2978 1
        break;
d3002 2
d3579 4
@


1.213
log
@Use correct method of getting quest name
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.212 2008/02/10 20:19:19 jps Exp jps $
d842 14
a855 1
  send_to_char("Sorry, but you cannot do that here!\r\n", ch);
d3570 3
@


1.212
log
@Further quest numbering tweaks/fixes.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.211 2008/02/10 19:43:38 jps Exp jps $
d215 3
a217 1
           all_quests[quest->quest_id & ~SUBCLASS_BIT].quest_name, "subclass_name"));
d220 2
a221 2
           GET_NAME(ch), all_quests[quest->quest_id & ~SUBCLASS_BIT].quest_name,
           get_quest_variable(ch, all_quests[quest->quest_id & ~SUBCLASS_BIT].quest_name,
d3557 3
@


1.211
log
@Subclass quests now store the target subclass as a quest variable rather
than as 3 bits in the quest id.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.210 2008/02/09 21:57:13 myc Exp jps $
d215 1
a215 1
           all_quests[quest->quest_id].quest_name, "subclass_name"));
d218 3
a220 2
           GET_NAME(ch), all_quests[quest->quest_id].quest_name,
           get_quest_variable(ch, all_quests[quest->quest_id].quest_name, "subclass_name"));
d3555 4
@


1.210
log
@The hide command won't cause hide points to go negative anymore.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.209 2008/02/09 21:07:50 myc Exp myc $
d213 8
a220 3
  subclass = (quest->quest_id & SUBCLASS_MASK) >> ARRAY_LOCN;
  if (subclass < 0 || subclass >= NUM_CLASSES) {
    log("Bad subclass index in do_subclass");
d3554 3
@


1.209
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.208 2008/02/09 18:29:11 myc Exp myc $
d1177 2
d3549 4
@


1.208
log
@The event code now handles freeing of event objects.  The camp
event now uses an event flag instead of storing the camp event
in a special field.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.207 2008/02/09 06:19:44 jps Exp myc $
d890 1
a890 1
    event_create(EVENT_CAMP, camp_event, ce, &(ch->events),
d3547 5
@


1.207
log
@Add "nohints" toggle for whether you receive command suggestions
after entering a typo.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.206 2008/02/09 04:27:47 myc Exp jps $
d842 1
a842 1
  if (FIGHTING(ch) || GET_ACTION(ch)) {
d869 4
a872 4
     if (SECT(ch->in_room) == SECT_FLYING) {
       send_to_char("&7You can't camp in mid-air.&0\r\n", ch);
       return;
     }
d883 1
a883 1
  else if (GET_POS(ch) < POS_STUNNED) {
d885 1
a885 1
  } else {
d890 3
a892 4
    if (GET_LEVEL(ch) >= LVL_IMMORT)
      GET_ACTION(ch) = event_create(EVENT_CAMP, camp_event, ce, &(ch->events), 5);
    else
      GET_ACTION(ch) = event_create(EVENT_CAMP, camp_event, ce, &(ch->events), 350);
d906 7
a912 9
  if (ch->in_room != re->from_room)
    {
     send_to_room("The magic of the scroll fizzles as"
		  " its target has left.\r\n", re->from_room); 
     send_to_char("The magic of the scroll fizzles, as you left the area.\r\n",
		  ch); 
     free(event_obj);
     return 0;
    };
d914 2
a915 4
  if (IS_NPC(ch) || !ch->desc) {
    free(event_obj);
    return 0;
  }
d917 2
a918 2
  send_to_char("You feel the scroll's energy start to envelop you.\r\n",ch);
  act("$N disappears in a bright flash.\r\n", FALSE, ch, 0, ch,TO_NOTVICT);
d929 1
a929 1
  return 0; 
d933 2
a934 1
/* I tweaked this function by adding a check for GET_ACTION so you
d949 1
a949 7
  
  /* make sure we're supposed to be here, then clear it */
  if (!GET_ACTION(ch)){
    free(event_obj);
    return 0;
  }
  
d951 2
a952 3
    free(event_obj);
    GET_ACTION(ch) = NULL;
    return 0;
d954 1
d956 1
a956 2
    free(event_obj);
    GET_ACTION(ch) = NULL;
d958 1
a958 1
    return 0;
d960 2
a961 1
  if(IS_FIGHTING(ch)) {
d964 2
a965 3
    free(event_obj);
    GET_ACTION(ch) = NULL;
    return 0;
d967 1
d971 2
a972 3
    free(event_obj);
    GET_ACTION(ch) = NULL;
    return 0;
a997 1
/*   mudlog(buf, NRM, LVL_GOD, TRUE); */
d1000 1
a1000 1
  if(GET_LEVEL(ch) < LVL_GOD)
a1001 5
  /* changed the order here so the event get's freed/nulled before
     ch is extracted --Gurlaek
  */
  free(event_obj);   
  GET_ACTION(ch) = NULL;
d1003 1
a1003 1
  return 0;
d3547 4
@


1.206
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.205 2008/02/02 19:38:20 myc Exp myc $
d2878 1
a2878 1
    { "NoCongratz", LVL_IMMORT,	PRF_NOGRATZ},
d2917 2
a2918 2
	/*08*/	{"You can now hear the congratulation messages.\r\n",
		 "You are now deaf to the congratulation messages.\r\n"},
d3564 3
@


1.205
log
@Adding 'permanent titles' to players, so they can switch between
any of the titles they've earned.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.204 2008/01/29 21:02:31 myc Exp myc $
d38 1
d3564 4
@


1.204
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.203 2008/01/27 21:09:12 myc Exp myc $
d37 1
d1445 4
d1456 67
a1522 5
  else if (strstr(argument, "(") || strstr(argument, ")"))
    send_to_char("Titles can't contain the ( or ) characters.\r\n", ch);
  else if (strlen(argument) > MAX_TITLE_LENGTH) {
    sprintf(buf, "Sorry, titles can't be longer than %d characters.\r\n",
	    MAX_TITLE_LENGTH);
a1523 5
  } else {
    set_title(ch, argument);
    sprintf(buf, "Okay, you're now %s %s.\r\n", GET_NAME(ch), GET_TITLE(ch));
    send_to_char(buf, ch);
    save_player(ch);
d3563 4
@


1.203
log
@Quitting or camping removes berserk status and all rage from a
character.  Replaced hit() references with TYPE_UNDEFINED with
attack().
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.202 2008/01/27 13:43:50 jps Exp myc $
a38 9
extern struct str_app_type str_app[];
extern struct room_data *world;

/*extern struct camp_event;*/
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct room_data *world;
extern struct dex_skill_type dex_app_skill[];
extern struct index_data *mob_index;
a1068 1
  extern struct dex_app_type dex_app[];
a3054 1
  extern struct descriptor_data *descriptor_list;
d3501 5
@


1.202
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.201 2008/01/26 20:44:39 myc Exp jps $
d302 1
a302 1
  if (IS_FIGHTING(ch)) {
d316 7
d993 6
d1408 1
a1408 1
      hit(vict, ch, TYPE_UNDEFINED);
d3356 1
a3356 1
				    hit(vict, ch, TYPE_UNDEFINED);				    
d3512 3
@


1.201
log
@Fix crash bug because of uninitialized memory in do_shapechange.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.200 2008/01/26 14:26:31 jps Exp myc $
d36 1
d3258 1
a3258 1
    if (IS_PC(vict) || (!IS_EVIL(vict) && GET_SPECIES(vict) != SPECIES_UNDEAD))
d3262 1
a3262 1
    else if (GET_SPECIES(vict) == SPECIES_UNDEAD)
d3274 1
a3274 1
    if (GET_SPECIES(vict) == SPECIES_UNDEAD)
d3324 1
a3324 1
		if (GET_SPECIES(vict) == SPECIES_UNDEAD) {
d3499 3
@


1.200
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.199 2008/01/26 12:30:19 jps Exp jps $
d473 1
a473 1
  int index, type, class, desired_index, i;
d662 1
a662 1
  if (desired_index && desired_index != index) {
d3498 3
@


1.199
log
@Use skills.h to import improve_skill().
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.198 2008/01/23 14:13:54 jps Exp jps $
a45 1
extern struct spell_info_type spell_info[];
d236 1
a236 1
      if (spell_info[last_mem->spell].min_level[subclass] == LVL_IMMORT)
d3498 3
@


1.198
log
@Added function creature_allowed_skill(), so the shapechanged critters
can have certain skills that override the question of whether a
non-humanoid should be allowed to have it.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.197 2008/01/23 05:13:37 jps Exp jps $
d35 1
a55 1
void improve_skill(struct char_data *ch, int skill);
d3499 5
@


1.197
log
@Add the point command, which is used to unhide someone you've spotted.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.196 2008/01/10 06:46:53 myc Exp jps $
d413 2
d724 19
d3499 3
@


1.196
log
@Moved the messages for the lay hands skill into the messages file.
The new healing message in the message struct allows lay hands to
simply use damage() instead of copying its functionality.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.195 2008/01/10 05:39:43 myc Exp myc $
d3427 49
d3478 5
@


1.195
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.194 2008/01/06 23:50:47 jps Exp myc $
a3191 1
  char *to_char, *to_vict, *to_room;
a3193 2
  extern void append_damage_amount(char *buf, const char *msg, int dam, int type);

d3237 1
a3237 2
    if (IS_PC(vict) || ((IS_GOOD(vict) || IS_NEUTRAL(vict)) && 
        GET_SPECIES(vict) != SPECIES_UNDEAD)) {
d3239 1
a3239 4
      to_char = "Your hands &7&bglow&0 as you lay them on $N.";
      to_vict = "The hands of $n &7&bglow&0 as $e lays them on YOU!";
      to_room = "The hands of $n &7&bglow&0 as $e lays them on $N.";
    }
d3241 4
a3244 9
    else {
      to_char = "You thrust your &7&bglowing&0 hands into $N, causing lots of pain!";
      to_vict = "$N thrusts $S &7&bglowing&0 hands into YOU, causing lots of pain!";
      to_room = "$n slaps $s &7&bglowing&0 hands into $N, causing lots of pain!";
      if (GET_SPECIES(vict) == SPECIES_UNDEAD)
        dam = 1.5 * dam + number(50, 150);
      else
        dam = 1.2 * dam + number(1, 50);
    }
d3253 1
a3253 4
    if (GET_SPECIES(vict) == SPECIES_UNDEAD) {
      to_char = "Your hands &1&bglow&0 as you lay them on $N.";
      to_vict = "The hands of $n &1&bglow&0 as $e lays them on YOU!";
      to_room = "The hands of $n &1&bglow&0 as $e lays them on $N.";
d3255 1
a3255 1
    }
d3261 1
d3263 1
a3263 4
    else {
      to_char = "You thrust your &1&bglowing&0 hands into $N, causing lots of pain!";
      to_vict = "$n slaps $s &1&bglowing&0 hands into YOU, causing lots of pain!"; 
      to_room = "$n slaps $s &1&bglowing&0 hands into $N, causing lots of pain!";
a3264 1
    }
d3267 1
a3267 38
  /* You can't damage an immortal! */
  if (!IS_NPC(vict) && GET_LEVEL(vict) >= LVL_IMMORT && dam > 0)
    dam = 0;

  /* If we're causing damage, make sure it's ok. (check PK, etc.) */
  if (dam >= 0 && !attack_ok(ch, vict, TRUE))
    return;
 
  append_damage_amount(buf, to_char, dam, TO_CHAR);
  act(buf, FALSE, ch, NULL, vict, TO_CHAR);
  if (vict != ch) {
    append_damage_amount(buf, to_vict, dam, TO_VICT);
    act(buf, FALSE, ch, NULL, vict, TO_VICT);
  }
  append_damage_amount(buf, to_room, dam, TO_NOTVICT);
  act(buf, FALSE, ch, NULL, vict, TO_NOTVICT);

  /* Cause damage. */
  if (dam >= 0) {
    /* If both the player and victim have no weapons, vamp touch */
    if (!GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD) &&
        !GET_EQ(vict, WEAR_WIELD) && !GET_EQ(vict, WEAR_2HWIELD)) {
      if (AFF3_FLAGGED(ch, AFF3_VAMP_TOUCH))
        alter_hit(ch, -dam, FALSE);
      else if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > number(0, 101))
        alter_hit(ch, -dam / 2, FALSE);
    }
    alter_hit(vict, dam, TRUE);
    /*
     * This is to display the correct messages when a player dies from
     * the alter_hit.
     */
    damage(ch, vict, dam, SKILL_LAY_HANDS); 
  }
  /* Cause healing. */
  else {
    damage(ch, vict, dam, SKILL_LAY_HANDS);
  }
d3429 4
@


1.194
log
@Added spells project and simulacrum, and MOB2_ILLUSORY flag.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.193 2008/01/05 06:17:36 myc Exp jps $
d712 1
a712 1
  alter_hit(mob, 0, 1);
d2090 1
a2090 1
    alter_hit(victim, MAX(-3, GET_SKILL(ch, SKILL_BANDAGE) / -10), 1);
d2095 1
a2095 1
    alter_hit(victim, 1, 2);
d3286 1
a3286 1
  if (!IS_NPC(vict) && GET_LEVEL(vict) >= LVL_IMMORT)
d3308 1
a3308 1
        alter_hit(ch, -dam, 1);
d3310 1
a3310 1
        alter_hit(ch, -dam / 2, 1);
d3312 1
a3312 1
    alter_hit(vict, dam, 2);
d3321 1
a3321 2
    alter_hit(vict, dam, 1);
    update_pos(vict);
d3484 3
@


1.193
log
@Fixing the valid prompt range for do_display.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.192 2008/01/05 05:42:30 jps Exp myc $
d1190 1
a1190 1
      send_to_char("You can't steal while you are fighting!\n\r",ch);
d1197 4
d3485 3
@


1.192
log
@Changed name of save_char() to save_player().
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.191 2008/01/04 05:17:52 jps Exp jps $
d2642 1
a2642 1
    sprintf(buf, "The range for the prompt number is 0-%d.\r\n", x);
d3481 3
@


1.191
log
@Provide some feedback when you don't get the shapechange
creature you requested.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.190 2008/01/04 05:14:52 jps Exp jps $
a57 1
int update_skills(struct char_data *ch);
d245 2
a246 2
    /* Update the skills */
    update_skills(ch);
d352 1
a352 1
  save_char(ch);
d771 1
a771 1
	    save_char(char2save);
d801 1
a801 1
  save_char(ch);
d984 1
a984 1
  save_char(ch);
d1433 1
a1433 1
    save_char(ch);
d3481 4
@


1.190
log
@Exempt gods from align restrictions when shapechanging.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.189 2008/01/04 01:43:10 jps Exp jps $
d662 6
d3482 3
@


1.189
log
@Removed unused function do_practice.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.188 2008/01/03 12:44:03 jps Exp jps $
d643 3
a645 1
    if (index >= 0 && creatures[i].midlevel - 5 + number(0, abs(GET_ALIGNMENT(ch))) > GET_LEVEL(ch))
d665 1
a665 1
    sprintf(buf, "SYSERR: %s tried to shapechange into nonexistant "
d3476 3
@


1.188
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.187 2008/01/01 03:05:20 jps Exp jps $
a1387 15

ACMD(do_practice)
{
  void list_skills(struct char_data * ch);
  
  one_argument(argument, arg);
  
  if (*arg)
    send_to_char("You can only practice skills in your guild.\r\n", ch);
  else
    list_skills(ch);
}



d3474 4
@


1.187
log
@Add the year to timestamps on entries in ideas, bugs, typos, and notes.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.186 2007/12/25 05:41:49 jps Exp jps $
d34 1
a46 5
extern char *class_abbrevs[];
extern int mage_subclasses[];
extern int warrior_subclasses[];
extern int rogue_subclasses[];
extern int cleric_subclasses[];
a145 2
  extern int class_ok_race[NUM_RACES][NUM_CLASSES];
  extern char *pc_class_types[];
d147 1
a147 2
  int max_subclass_lvl, subclass, subclass_count, array_ref;
  int *subclass_allowed;
d151 2
d160 2
d163 1
a163 4
  if (GET_CLASS(ch) != CLASS_WARRIOR &&
      GET_CLASS(ch) != CLASS_ROGUE &&
      GET_CLASS(ch) != CLASS_CLERIC &&
      GET_CLASS(ch) != CLASS_MAGIC_USER) {
a173 13
  switch (GET_CLASS(ch)) {
    case CLASS_WARRIOR:
    case CLASS_ROGUE:
      max_subclass_lvl = 25;
      break;
    case CLASS_MAGIC_USER:
    case CLASS_CLERIC:
      max_subclass_lvl = 45;
      break;
    default:
      log("Invalid character class in do_subclass");
  }

d175 3
a177 2
  if (GET_LEVEL(ch) > max_subclass_lvl) {
    sprintf(buf, "You can no longer subclass, because you are over level %d.\r\n", max_subclass_lvl);
d192 10
a201 24
    /* reuse the max variable */
    switch (GET_CLASS(ch)) {
      case CLASS_WARRIOR:
        subclass_allowed = warrior_subclasses;
        subclass_count = WARRIOR_SUBCLASSES;
        break;
      case CLASS_CLERIC:
        subclass_allowed = cleric_subclasses;
        subclass_count = CLERIC_SUBCLASSES;
        break;
      case CLASS_MAGIC_USER:
        subclass_allowed = mage_subclasses;
        subclass_count = MAGE_SUBCLASSES;
        break;
      case CLASS_ROGUE:
        subclass_allowed = rogue_subclasses;
        subclass_count = ROGUE_SUBCLASSES;
        break;
    }
    send_to_char("You may choose from the following classes for your race:\r\n", ch);
    array_ref = 0;
    for (subclass = 0; subclass < subclass_count; subclass++) {
      if (class_ok_race[(int) GET_RACE(ch)][subclass_allowed[subclass]]) {
        sprintf(buf, "  %s\r\n", pc_class_types[subclass_allowed[subclass]]);
a202 1
        array_ref = 1;
d205 2
a206 1
    if (array_ref) {
d208 4
a211 5
              "more information.\r\n", max_subclass_lvl,
              GET_CLASS(ch) == CLASS_WARRIOR ? "WARRIOR" :
              GET_CLASS(ch) == CLASS_CLERIC ? "CLERIC" :
              GET_CLASS(ch) == CLASS_MAGIC_USER ? "SORCERER" :
              GET_CLASS(ch) == CLASS_ROGUE ? "ROGUE" : "");
d213 2
a214 3
    }
    else
      send_to_char("  None!  Bummer.\r\n", ch);
a219 1

d221 2
a222 23
  array_ref = (quest->quest_id & SUBCLASS_MASK) >> ARRAY_LOCN;
  subclass = -1;
  if (array_ref >= 0) {
    switch (GET_CLASS(ch)) {
      case CLASS_MAGIC_USER:
        subclass = mage_subclasses[array_ref];
        break;
      case CLASS_WARRIOR:
        subclass = warrior_subclasses[array_ref];
        break;
      case CLASS_ROGUE:
        subclass = rogue_subclasses[array_ref];
        break;
      case CLASS_CLERIC:
        subclass = cleric_subclasses[array_ref];
        break;
      default:
        /* Fail quietly */
        subclass = -1;
        break;
    }
  }
  if (array_ref < 0 || subclass < 0) {
d252 2
a253 1
    sprintf(buf, "You have successfully subclassed as a %s\r\n", CLASS_FULL(ch));
d261 2
a262 1
  sprintf(buf, "You are on the way to becoming a %s\r\n", pc_class_types[(int) subclass]);
d264 2
a265 1
  sprintf(buf, "You have until level %d to complete your quest.\r\n", max_subclass_lvl);
d3489 3
@


1.186
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.185 2007/12/21 07:52:11 myc Exp jps $
d2742 63
a2804 51
  FILE *fl;
  char *tmp, *filename, buf[MAX_STRING_LENGTH];
  char note_buf[MAX_STRING_LENGTH];
  struct stat fbuf;
  extern int max_filesize;
  time_t ct;
  
  switch (subcmd) {
  case SCMD_NOTES:
    argument = one_argument(argument, buf); 
    get_filename(buf, note_buf , NOTES_FILE); 
    filename = note_buf; 
    send_to_char(note_buf, ch); 
    send_to_char("\r\n", ch); 
    break; 
  case SCMD_BUG:
    filename = BUG_FILE;
    break;
  case SCMD_TYPO:
    filename = TYPO_FILE;
    break;
  case SCMD_IDEA:
    filename = IDEA_FILE;
    break;
  default:
    return;
  }
  
  ct = time(0);
  tmp = asctime(localtime(&ct));
  
  if (IS_NPC(ch)) {
    send_to_char("Monsters can't have ideas - Go away.\r\n", ch);
    return;
  }
  
  skip_spaces(&argument);
  delete_doubledollar(argument);
  
  if (!*argument) {
    send_to_char("Please enter a message to go with that bug, idea, or typo.\r\n", ch);
    return;
  }
  sprintf(buf, "%s %s: %s", GET_NAME(ch), CMD_NAME, argument);
  mudlog(buf, CMP, LVL_IMMORT, FALSE);
  
  if (stat(filename, &fbuf) >= 0 && fbuf.st_size >= max_filesize) {
    send_to_char("Sorry, the file is full right now.. try again later.\r\n", 
		 ch);
    return;
  }
d2806 4
a2809 9
  if (!(fl = fopen(filename, "a"))) {
    perror("do_gen_write");
    send_to_char("Could not open the file.  Sorry.\r\n", ch);
    return;
  }
  fprintf(fl, "%-8s (%6.6s) [%5d] %s\n", GET_NAME(ch), (tmp + 4),
	  world[ch->in_room].number, argument);
  fclose(fl);
  send_to_char("Thanks for the bug, idea, or typo comment!\r\n", ch);
d3542 5
@


1.185
log
@It is no longer possible to damage an immortal with lay hands.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.184 2007/12/20 23:09:03 myc Exp myc $
d916 1
a916 1
      GET_ACTION(ch) = event_create(camp_event, ce, 5);
d918 1
a918 1
      GET_ACTION(ch) = event_create(camp_event, ce, 350);
d3535 3
@


1.184
log
@Updated do_level to use the new exp_message function that replaced
exp_mesg.  do_display now offers two new prompts; the old 'Complete'
is now 'Standard', and there are two new 'Complete' prompts.  Also
fixed a memory leak in do_display.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.183 2007/12/20 17:18:21 myc Exp myc $
d3335 4
d3535 6
@


1.183
log
@You can no longer steal in the PK arena.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.182 2007/12/19 20:36:16 myc Exp myc $
d1424 1
a1424 1
  extern char *exp_mesg(struct char_data *ch);
d1429 1
a1429 1
    if (!str_cmp(arg,"gain")) {
d1435 2
a1436 2
    sprintf(buf,"%s\r\n",exp_mesg(ch));
    send_to_char(buf,ch);
a2656 1
  char arg[MAX_INPUT_LENGTH];
a2658 1
  
d2660 7
a2666 7
    { "Basic"		 , "&0%hhp %vmv>&0 "
    },
    { "Colorized Basic"  , "&1&b%h&0&1hp &2&b%v&0&2mv&0> "
    },
    { "Standard"	 , "&1&b%ph&0&1hp &2&b%pv&0&2mv&0> "
    }, 
    { "Full-Featured"		 ,
d2668 11
a2678 5
      "hitp &2%v&0(&2&b%V&0)&7move&0> "
    },
    { "Complete" ,
      "&2&b<&0&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)&2&b>%_&0<%t&0>:<&0%o&0> "    },
    { "\n"                       , "\n"                                 }
d2682 2
a2683 3
  
  
  if (!arg || !*arg) {
d2685 2
a2686 3
    for (i = 0; *def_prompts[i][0] != '\n'; i++) {
      sprintf(buf, "  %d. %-25s  %s\r\n", i, def_prompts[i][0], def_prompts[i][1]);
      strip_ansi(buf);
a2690 4
  } else if (!isdigit(*arg)) {
    send_to_char("Usage: display <number>\r\n", ch);
    send_to_char("Type _display_ without arguments for a list of preset prompts.\r\n", ch);
    return;
d2700 1
a2700 1
  for (x = 0; *def_prompts[x][0] != '\n'; x++);
a2710 1
  CREATE(GET_PROMPT(ch), char, strlen(def_prompts[i][1]) + 1);
d3531 3
@


1.182
log
@save_char() no longer requires you to specify the save room (which
wasn't being used anyway).  Renamed the 'Cloaked' toggle to 'RoomVis'.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.181 2007/11/18 16:51:55 myc Exp myc $
d1260 4
d3534 4
@


1.181
log
@Improve steal chance when hidden.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.180 2007/10/27 18:15:10 myc Exp myc $
a327 1
  int save_room;
a389 1
  save_room = ch->in_room;
d399 6
d406 2
a407 6
  save_char(ch, save_room);
  
  /* If someone is quitting in their house, let them load back here */
  if (ROOM_FLAGGED(save_room, ROOM_HOUSE))
    save_char(ch, save_room);
  
d817 1
a817 1
	    save_char(char2save, NOWHERE);
d847 1
a847 1
  save_char(ch, NOWHERE);
d1030 1
a1030 1
  save_char(ch, now_in);
d1490 1
a1490 1
    save_char(ch, NOWHERE);
d2335 1
a2335 1
  int cash[4] = {0};
d2857 1
a2857 1
    { "Cloaked",    LVL_IMMORT, PRF_CLOAKED},
d3530 3
@


1.180
log
@Fixing hide calculation to use dex and int right.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.179 2007/10/12 20:32:22 jps Exp myc $
d311 1
a311 1
    mudlog(buf, BRF, LVL_BUILDER, TRUE);
d1263 2
d3530 3
@


1.179
log
@Apply laryngitis to petitioning.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.178 2007/10/11 20:14:48 myc Exp jps $
d1211 1
a1211 1
  upper_bound = 2000 * skill / (3 * GET_DEX(ch) + GET_INT(ch));
d1235 1
a1235 1
   if (IS_FIGHTING(ch)) {
d3528 3
@


1.178
log
@Removed all chant commands from here, and merged its functionality with
the magic system.  do_cast now covers the chant command via SCMD_CHANT.
The songs command is now in act.informative.c.  The actual chants are
in magic.c, except peace which is now a manual "spell".
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.177 2007/10/09 02:38:00 myc Exp myc $
d3093 2
d3528 6
@


1.177
log
@When a druid shapechanges back to their player form, any objects or
money the druid had is transfered to the player.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.176 2007/10/02 02:52:27 myc Exp myc $
a70 6
/* Local functions */
void chant_target(struct char_data *ch, int chantnum, int target_status, struct obj_data *tobj, struct char_data *tch);
void finish_chant(struct char_data *ch, int chantnum, struct obj_data *tobj, struct char_data *tch);
void do_songs(struct char_data *ch, int chantnum, struct obj_data *tobj, struct char_data *tch);
bool check_affected(struct char_data *ch, int chantnum, int skill);

a3523 434
struct monk {
  char *skl;
  int  level;
  int violent;
  int cumulative;
  int targets;
  byte class;
} field [] = {
  { "none",		0, 0, 0,	0, 		0},
  { "Regeneration",	15, 0, 0,	TAR_CHAR_ROOM | TAR_SELF_ONLY,	CLASS_MONK},
  { "Battle Hymn",	30, 0, 0,	TAR_CHAR_ROOM | TAR_SELF_ONLY,	CLASS_MONK},
  { "War Cry",		90, 0, 0,	TAR_CHAR_ROOM,	CLASS_MONK},
  { "Peace",		70, 0, 0,	TAR_CHAR_ROOM,	CLASS_MONK},
  { "\n",		0, 0, 0,	0,		0}
};

int MAX_CHANTS = 4;

ACMD(do_song)
{
  int index = 0, found = FALSE;
  *buf = '\0';

  if (GET_SKILL(ch, SKILL_CHANT) < 1) {
     send_to_char("Huh?!?\r\n", ch);
     return;
  }
  sprintf(buf, "You know the following songs:\r\n");
  while (*field[++index].skl != '\n') {
     if(GET_LEVEL(ch) >= field[index].level) {
       sprintf(buf, "%s  %s\r\n", buf, field[index].skl);
       found = TRUE;
     }
  }
  if (found == FALSE)
    sprintf(buf, "%s  None.\r\n", buf);
  send_to_char(buf, ch);
}
  
int find_chant_num(char *name)
{
  int index = 0, ok;
  char *temp, *temp2;
  char first[256], first2[256];

  while (*field[++index].skl != '\n')
  {  
      if (is_abbrev(name, field[index].skl))
        return index;

      ok = 1;
      temp = any_one_arg(field[index].skl, first);
      temp2 = any_one_arg(name, first2);
      while (*first && *first2 && ok) {
        if (!is_abbrev(first2, first))
          ok = 0;
        temp = any_one_arg(temp, first);
        temp2 = any_one_arg(temp2, first2);
      }

      if (ok && !*first2)
        return index;
  }
  
  return -1;
}

ACMD(do_chant)
{
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  char *s, *t, *misc= '\0';
  int chantnum = -1, i, target = 0;
  int target_status = TARGET_NULL;

  /* get: blank, chant name, target name */
  s = strtok(argument, "'");
      
  if(AFF2_FLAGGED(ch, AFF2_SILENCE))
    {
      send_to_char("Your lips move, but no song forms.\r\n", ch);
      return;
    }
      
 if(GET_POS1(ch) < POS1_STANDING)
    {
      send_to_char("You are too relaxed..\r\n", ch);
      return;
    }
     
  if (GET_SKILL(ch, SKILL_CHANT) == 0)
    {  
      send_to_char("You imitate a monk chanting...Monkey see, Monkey do.\r\n", ch);
      return;
    }

  if (ch->player_specials->saved.chant > 0)
  {
     send_to_char("You've already chanted once within the past 4 hours.\r\n", ch);
     return;
  } 
     
  if (s == NULL)
    {
      act("$n begins chanting in a deep voice.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You begin chanting in a deep voice.\r\n", ch);
      if (GET_LEVEL(ch) < 101)
        ch->player_specials->saved.chant = 4;
      improve_skill(ch, SKILL_CHANT);
      return;
    }
      
  s = strtok(NULL, "'");
  if (s == NULL)
    {
      send_to_char("Song names must be enclosed in the symbols: '\r\n", ch);
      return;
    }
     
  t = strtok(NULL, "\0");

  chantnum = find_chant_num(s);

  if ((chantnum < 0) || (chantnum > MAX_CHANTS))
    {
      send_to_char("Sing what?!?\r\n", ch);
      return;
    }
      
  if (IS_NPC(ch))
    { 
      if (GET_LEVEL(ch) < field[chantnum].level)
        {
          send_to_char("You have never heard of that song!\r\n", ch);
          return;
        }
  }  
else  
  {
    if (GET_LEVEL(ch) < field[chantnum].level)
      {
        send_to_char("You have never heard of that song!\r\n", ch);
        return;
  
      }
  }
     
  /* Find the target */
  if (t != NULL) {
    misc = str_dup(t);
    skip_spaces(&misc);
    one_argument(strcpy(arg, t), t);
    skip_spaces(&t);
  }
  if (IS_SET(field[chantnum].targets, TAR_IGNORE))
    {
      target = TRUE;
      target_status = TARGET_ALL_ROOM;
    } else if (t != NULL && *t)
      {
        if (!target && (IS_SET(field[chantnum].targets, TAR_CHAR_ROOM)))
          {
            if ((tch = get_char_room_vis(ch, t)) != NULL){
              target = TRUE;
              target_status = TARGET_IN_ROOM;
            }
          }
        if (!target && (IS_SET(field[chantnum].targets, TAR_CHAR_WORLD)))
          if ((tch = get_char_vis(ch, t))) {
            target = TRUE;
            target_status = TARGET_IN_WORLD;
          }
        if (!target && (IS_SET(field[chantnum].targets, TAR_OBJ_INV)))
          if ((tobj = get_obj_in_list_vis(ch, t, ch->carrying))) {
            target = TRUE;
            target_status = TARGET_IN_INV;
          }
        if (!target && (IS_SET(field[chantnum].targets, TAR_OBJ_EQUIP)))
          {
            for (i = 0; !target && i < NUM_WEARS; i++)
              if (GET_EQ(ch, i) && !str_cmp(t, GET_EQ(ch, i)->name))
                {
                  tobj = GET_EQ(ch, i);
                  target = TRUE;
                  target_status = TARGET_EQUIP;
                }
          }
        if (!target && (IS_SET(field[chantnum].targets, TAR_OBJ_ROOM)))  
          if ((tobj = get_obj_in_list_vis(ch, t, world[ch->in_room].contents))){
            target = TRUE;
            target_status = TARGET_IN_ROOM; 
          }
        if (!target && (IS_SET(field[chantnum].targets, TAR_OBJ_WORLD)))
          if ((tobj = get_obj_vis(ch, t))) {
            target = TRUE;
            target_status = TARGET_IN_WORLD;
          }
        
      } else
        {                       /* if target string is empty */
          if (!target && (IS_SET(field[chantnum].targets, TAR_FIGHT_SELF)))
            if (FIGHTING(ch) != NULL)
              {
                tch = ch;
                target = TRUE;
                target_status = TARGET_SELF;
              }
          if (!target && (IS_SET(field[chantnum].targets, TAR_FIGHT_VICT)))
            if (FIGHTING(ch) != NULL)
              {
                tch = FIGHTING(ch);
                target = TRUE;
                target_status = TARGET_FIGHTING;
              }
          /* if no target specified, and the spell isn't violent, default to self */
          if (!target && (IS_SET(field[chantnum].targets, TAR_CHAR_ROOM)) && !field[chantnum].violent)
            {
              tch = ch;
              target = TRUE;
              target_status = TARGET_SELF;
            }
          if (!target)
            {  
              sprintf(buf, "Chant your song to %s?\r\n", IS_SET(field[chantnum].targets, TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD) ? "what" : "whom");
              send_to_char(buf, ch);
              return;
            }  
        }
  if (!target) {
    send_to_char("Cannot find the target of your chant!\r\n", ch);
    return;  
  }
              
  if (target && field[chantnum].violent) {
    if (affected_by_spell(ch, SPELL_INVISIBLE) ||
        affected_by_spell(ch, SPELL_NATURES_EMBRACE))
      appear(ch);
    REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
    REMOVE_BIT(AFF3_FLAGS(ch), AFF3_CAMOUFLAGED);
    GET_HIDDENNESS(ch) = 0;
  }
   
  improve_skill(ch, SKILL_CHANT);
    
  chant_target(ch, chantnum, target_status, tobj, tch);
  if (GET_LEVEL(ch) < 101) {
    ch->player_specials->saved.chant = 4;
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
  }
}
    
void chant_target(struct char_data *ch, int chantnum, int target_status, struct obj_data *tobj, struct char_data *tch)
{
    int tar_invalid=FALSE, found = FALSE, i;
    struct obj_data *obj;

    if(tobj) { /* target is object */
      switch(target_status) {
        case TARGET_IN_ROOM:
           if(tobj->in_room != ch->in_room)  
             tar_invalid = TRUE;
           break;
        case TARGET_IN_WORLD:
           break;
        case TARGET_IN_INV:
           for(obj=ch->carrying;obj;obj=obj->next)
                if(tobj == obj)
                  found = TRUE;
              if(!found)
                tar_invalid=TRUE;
              break;
            case TARGET_EQUIP:
              for(i=0;i<NUM_WEARS;i++)
                if(tobj == ch->equipment[i])
                  found = TRUE;
              if(!found)
                tar_invalid=TRUE;
              break;
            default:
              log("SYSERR: Error in chant_target() at obj valid check.");
            }
            if(tar_invalid) {  
              send_to_char("You choke and grunt a raspy wail of pain.\r\n", ch);
              act("$n chokes on $s tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
              return;
            } 
          }
          if(tch) /* target is a char */   
            {
              switch(target_status) {
              case TARGET_IN_ROOM:
                if(tch->in_room != ch->in_room)
                  tar_invalid = TRUE;
                break;
              case TARGET_IN_WORLD:
                break;
              case TARGET_FIGHTING:
                if(!FIGHTING(ch) || tch != FIGHTING(ch))
                  tar_invalid = TRUE;
                break;
                /* added case for TARGET_SELF to prevent syserrors */
              case TARGET_SELF:
                break;
              default:
                log("SYSERR: Error in chant_target() at char valid check.");
              }
              if(tar_invalid) {
                send_to_char("You choke and grunt a raspy wail of pain.\r\n", ch);
                act("$n chokes on $s tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
                return;
              }
            }
                  
                
  finish_chant(ch, chantnum, tobj, tch);
}

void finish_chant(struct char_data *ch, int chantnum, struct obj_data *tobj, struct char_data *tch)
{
  if(IS_AFFECTED2(ch, AFF2_INSANITY) && !mag_savingthrow(ch, SAVING_PARA)){
    act("$n babbles a bit as a strand of drool drips down $s chin.",TRUE,ch,0,0, TO_ROOM);
    act("Your mind is not in any condition to chant a song.",FALSE,ch,0,0,TO_CHAR);
    act("&1$n&1 stops chanting abruptly!&0", TRUE, ch, 0, 0, TO_ROOM);
    return;
  }
    if (number(0, 101) > GET_SKILL(ch, SKILL_CHANT))
      {
            send_to_char("You choke and grunt a raspy wail of pain.\r\n", ch);
            act("$n chokes on $s tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
      } else {
          if (field[chantnum].violent && tch &&
              IS_NPC(tch) && !FIGHTING(tch))
            if(number(0, 4)) {
              hit(tch, ch, TYPE_UNDEFINED);
              remember(tch, ch);
            }
        do_songs(ch, chantnum, tobj, tch); 
     }

}

void do_songs(struct char_data *ch, int chantnum, struct obj_data *tobj, struct char_data *tch)
{
   struct affected_type af;
   struct char_data *i;

   act("$n begins chanting in a deep voice.", TRUE, ch, 0, 0, TO_ROOM);
   send_to_char("You begin chanting in a deep voice.\r\n", ch);

   switch (chantnum) {
      case 1: /* Regeneration */
        if (ch != tch) {
	   send_to_char("This song can only be used on yourself!\r\n", ch);
           return;
        }
        if (check_affected(ch, chantnum, SONG_REGENERATION) == TRUE)
           return;
	af.type = SONG_REGENERATION;
        af.duration = GET_LEVEL(ch)/2 + 3;
        af.modifier = GET_SKILL(ch, SKILL_CHANT)/2+10;
        af.location = APPLY_HIT_REGEN;
        af.bitvector = 0;
        af.bitvector2 = 0;
        af.bitvector3 = 0;
        affect_to_char(ch, &af);
	send_to_char("You feel your health improve.\r\n", ch);
        act("$n looks a little healthier.", FALSE, ch, 0, 0, TO_ROOM);
        break;
     case 2: /* Battle Hymn */
        if (check_affected(ch, chantnum, SONG_BATTLE_HYMN) == TRUE)
           return;
	af.type = SONG_BATTLE_HYMN;
        af.duration = GET_LEVEL(ch)/25 + 1;
        af.modifier = GET_LEVEL(ch)/25 + 1;
        af.location = APPLY_HITROLL;
        af.bitvector = 0;
        af.bitvector2 = 0;
        af.bitvector3 = 0;
        affect_to_char(ch, &af);
	af.type = SONG_BATTLE_HYMN;
        af.duration = GET_LEVEL(ch)/25 + 1;
        af.modifier = GET_LEVEL(ch)/25 + 1;
        af.location = APPLY_DAMROLL;
        af.bitvector = 0;
        af.bitvector2 = 0;
        af.bitvector3 = 0;
        affect_to_char(ch, &af);
	send_to_char("Your heart beats with the rage of your fallen brothers.\r\n", ch);
        act("$n's chest swells with courage!", FALSE, ch, 0, 0, TO_ROOM);
        break;
     case 3: /* War Cry */
        for(i = world[ch->in_room].people;i;i = i->next_in_room) {
           if (check_affected(i, chantnum, SONG_WAR_CRY) == FALSE) {
             af.type = SONG_WAR_CRY;
             af.duration = GET_LEVEL(ch)/25 + 1;
             af.modifier = GET_LEVEL(ch)/25 + 1;
             af.location = APPLY_HITROLL;
             af.bitvector = 0;
             af.bitvector2 = 0;
             af.bitvector3 = 0;
             affect_to_char(i, &af);
             af.type = SONG_WAR_CRY;
             af.duration = GET_LEVEL(ch)/25 + 1;
             af.modifier = GET_LEVEL(ch)/25 + 1;   
             af.location = APPLY_DAMROLL;
             af.bitvector = 0;
             af.bitvector2 = 0;
             af.bitvector3 = 0;
             affect_to_char(i, &af);
             act("You feel more determined than ever!", FALSE, ch, 0, i, TO_VICT);
             act("$n looks more determined than ever!", FALSE, i, 0, 0, TO_ROOM);
          }
        }
        break;
     case 4: /* Peace */
        for(i=world[ch->in_room].people;i;i=i->next_in_room) {
  	  if(FIGHTING(i)) {
	    stop_fighting(i);
	  }
        }
        act("A peaceful feeling washes into the room, dousing all violence!", FALSE, ch, 0, 0, TO_ROOM);
        send_to_char("You douse all violence!\r\n", ch);
        break;
   }
}

bool check_affected(struct char_data *ch, int chantnum, int skill)
{
   if(affected_by_spell(ch, skill) && (field[chantnum].cumulative == 0)) {
      send_to_char(NOEFFECT,ch);
      return TRUE;
   } else
      return FALSE;
}
d3526 4
@


1.176
log
@Added a forward pointer on the char_data struct so we can check to see
who someone is shapeshifted/switched into.  Shapechanged druids will
be able to see how long they have been shapechanged/how long until they
can shapechange again.  The timer isn't a static 5 tics anymore;
instead it's variable based on the time spent shapechanged.  Fixed some
typos.  Added lag to steal command.  Moved do_grep and do_report to
act.comm.c.  Toggle command can now be used while shapechanged, and it
applies to the original player character.  Petition now goes to the
player's descriptor even when they are shapechanged.  Cleaned up
various other commands.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.175 2007/09/20 21:20:43 myc Exp myc $
d534 1
d589 13
a601 1
      /* Transfer any objects the mob was holding to the player here. */
d3966 12
@


1.175
log
@Hide points and perception are in.  AFF_HIDE, AFF_SNEAK, and ITEM_HIDDEN
are now unused.  Sneak chance is now calculated based on hiddenness.
do_sneak is gone, and do_hide has changed.  Also got rid of toggle
nonamebroadcast, and replaced it with toggle cloaked for imms, which
lets you appear visible to people in the room, but not everyone else.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.174 2007/09/15 15:36:48 myc Exp myc $
d338 2
a339 1
  if (IS_NPC(ch) || !ch->desc)
d341 1
d538 1
a538 1
      !GET_SKILL(ORIG_CHAR(ch), SKILL_SHAPECHANGE)) {
a544 5
  if (!*arg) {
    send_to_char("Shapechange to what?\r\n", ch);
    return;
  }

d547 13
a559 1
    if (!is_abbrev(arg, "me"))
d575 9
a583 4
      ch->desc->character = ch->desc->original;
      ch->desc->original = NULL;
      ch->desc->character->desc = ch->desc;
      ch->desc = NULL;
a590 2
      if (GET_LEVEL(player) < LVL_IMMORT)
        player->player_specials->saved.chant = 5;      
a594 5
  if (!str_cmp(arg, "me")) {
    send_to_char("You are already in your normal form.\r\n", ch);
    return;
  }

d599 18
a616 1
    send_to_char("You are still drained from your last shapechange.\r\n", ch);
d758 1
d860 1
a860 1
  if (IS_FIGHTING(ch) || GET_ACTION(ch)) {
d865 2
a866 1
  if (IS_NPC(ch) || !ch->desc)
d868 1
d1250 1
a1250 1
      send_to_char("You can't steal from another player.\r\n", ch);
d1404 1
a2312 161
ACMD(do_grep)
{
  struct char_data *k = NULL;
  struct group_type *f;
  int perc = 100;
  if (!IS_AFFECTED(ch, AFF_GROUP)) 
	{
	  send_to_char("&0But you are not a member of any group!&0\r\n", ch);
	  return;
	}
  perc = (100*GET_HIT(ch)/GET_MAX_HIT(ch));
  sprintf(buf, "&0&2&b%s reports:&0 %s%s%d &0(%d) hits and %d (%d) movement points.&0\r\n",
	  GET_NAME(ch),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCNRM(ch,C_NRM) :
	   perc >= 70 ? CCBLD(ch,C_NRM) :
	   perc >= 45 ? CCNRM(ch,C_NRM) :
	   perc >= 20 ? CCNRM(ch,C_NRM) :
	   perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(k,C_NRM)),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCYEL(ch,C_NRM) :
	   perc >= 70 ? CCYEL(ch, C_NRM) :
	   perc >= 45 ? CCMAG(ch, C_NRM) :
	   perc >= 20 ? CCRED(ch, C_NRM) :
	   perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)), GET_HIT(ch), GET_MAX_HIT(ch),
	  GET_MOVE(ch), GET_MAX_MOVE(ch));
  CAP(buf);
  
  k = (ch->groupmaster ? ch->groupmaster : ch);
  
  for (f = k->groupees; f; f = f->next)
    {
      if ((IS_AFFECTED(f->groupee, AFF_GROUP)) && (ch != f->groupee))
	send_to_char(buf, f->groupee);
    }
  if (k != ch)
    send_to_char(buf, k);
  /*send to master*/
  sprintf(buf, "&0&2&bYou report:&0 %s%s%d &0(%d) hits and %d (%d) movement points.&0\r\n",
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCNRM(ch,C_NRM) :
	   perc >= 70 ? CCBLD(ch,C_NRM) :
	   perc >= 45 ? CCNRM(ch,C_NRM) :
	   perc >= 20 ? CCNRM(ch,C_NRM) :
	   perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(k,C_NRM)),
	  (perc >= 100 ? CCWHT(ch, C_NRM) :
	   perc >= 88 ? CCYEL(ch,C_SPR) :
	   perc >= 70 ? CCYEL(ch, C_NRM) :
	   perc >= 45 ? CCMAG(ch, C_NRM) :
	   perc >= 20 ? CCRED(ch, C_NRM) :
	   perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)), GET_HIT(ch), GET_MAX_HIT(ch),
	  GET_MOVE(ch), GET_MAX_MOVE(ch));
  send_to_char(buf, ch);
}




ACMD(do_report)
{
  struct char_data *vict;
  
  one_argument(argument, arg);
  
  if (!*arg && !ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) 
    {
      for (vict = world[ch->in_room].people ; vict ; vict = vict->next_in_room) {
        if (vict != ch && AWAKE(vict) && vict->desc) {
          sprintf(buf, "%s says, 'I have %d (%d) hit and %d (%d) movement points.'",
	      (CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone"), GET_HIT(ch), GET_MAX_HIT(ch),
	      GET_MOVE(ch), GET_MAX_MOVE(ch));
    
          act(buf, FALSE, vict, 0, vict, TO_CHAR);
        }
      }
    } 
  if (!*arg && PRF_FLAGGED(ch, PRF_NOREPEAT) && !ROOM_FLAGGED(ch->in_room, 
							      ROOM_SOUNDPROOF)){
    send_to_char(OK, ch);}
  if (!*arg && !PRF_FLAGGED(ch, PRF_NOREPEAT) && !ROOM_FLAGGED(ch->in_room, 
							       ROOM_SOUNDPROOF))
    { sprintf(buf, "You say, 'I have %d (%d) hit and %d (%d) movement points.'",
	      GET_HIT(ch), GET_MAX_HIT(ch),
	      GET_MOVE(ch), GET_MAX_MOVE(ch));
    
    act(buf, FALSE, ch, 0, 0, TO_CHAR);}
  
  if (!*arg && ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    {    send_to_char("The walls seem to absorb your words.\r\n", ch);
    }
  if (*arg){
    
    if (!(vict = get_char_vis(ch, arg))){
      send_to_char(NOPERSON, ch);}
    
    else if (ch == vict)
      send_to_char("Now that is just silly isn't it?\r\n", ch);
    else if (PRF_FLAGGED(ch, PRF_NOTELL))
      send_to_char("You can't report to other people while you have notell on.\r\n", ch);
    else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
      send_to_char("The walls seem to absorb your words.\r\n", ch);
    else if (!IS_NPC(vict) && !vict->desc)	/* linkless */
      act("No one here by that name.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if (PLR_FLAGGED(vict, PLR_WRITING))
      act("$E's writing a message right now; try again later.",
	  FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if (PRF_FLAGGED(vict, PRF_NOTELL) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
      act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else if    ((GET_HIT(ch) > (GET_MAX_HIT(ch) * 0.2)) && !PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have %d (%d) hit and %d (%d) movement points.&0",
		(CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone"), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, vict, 0, vict, TO_CHAR);
	
	
	sprintf(buf, "&0&b&8You tell $N, 'I have %d (%d) hit and %d (%d) movement points.&0",
		GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    else if    ((GET_HIT(ch) > (GET_MAX_HIT(ch) * 0.2)) && PRF_FLAGGED(ch, 
								       PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have %d (%d) hit and %d (%d) movement points.&0",
		(CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone"), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, vict, 0, vict, TO_CHAR);
	
	send_to_char(OK, ch);}
    
    else if    ((GET_HIT(ch) < (GET_MAX_HIT(ch) * 0.2)) && !PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		(CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone"), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, vict, 0, vict, TO_CHAR);
	
	
	sprintf(buf, "&0&b&8You tell $N, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    else if    ((GET_HIT(ch) < (GET_MAX_HIT(ch) * 0.2)) && PRF_FLAGGED(ch, PRF_NOREPEAT))
      {
	sprintf(buf, "&0&b&8%s tells you, 'I have &0&b&1%d&0&b&8 (%d) hit and %d (%d) movement points.&0",
		(CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone"), GET_HIT(ch), GET_MAX_HIT(ch),
		GET_MOVE(ch), GET_MAX_MOVE(ch));
	
	act(buf, FALSE, vict, 0, vict, TO_CHAR);
	
	send_to_char(OK, ch);}
    
  }
  return;
}

d2804 2
a2805 2
  int l, i, zcount;
  int wimp_lev,page_length;
d2807 1
a2808 2

  char field[MAX_INPUT_LENGTH];
d2823 2
a2824 2
    { "Nosummon",   LVL_IMMORT, PRF_SUMMONABLE},
    { "Nohassle",   LVL_IMMORT, PRF_NOHASSLE},  
d2828 5
a2832 5
    { "AFK"       , 0,          PRF_AFK},
    { "Noshout",    0,	        PRF_DEAF},
    { "Nogossip",   0,          PRF_NOGOSS},  
    { "Nocongratz", LVL_IMMORT,	PRF_NOGRATZ},
    { "Nowiz",	    LVL_IMMORT, PRF_NOWIZ},  
d2834 2
a2835 2
    { "Room",	    LVL_IMMORT, PRF_ROOMFLAGS},
    { "Norepeat",   0,	        PRF_NOREPEAT},  
d2838 2
a2839 2
    { "Nopetition", LVL_IMMORT, PRF_NOPETI},  
    { "Noname",	    LVL_IMMORT, PRF_NONAME},
d2843 1
a2843 1
    { "Nicearea",   0,	        PRF_NICEAREA},
d2846 1
a2846 1
    { "Pagelength", 0,          0},
d2854 52
a2905 55
    /*   {"You are now safe from summoning by other players.\r\n",
	 "You may now be summoned by other players.\r\n"}, */
    /*00*/	{".\r\n",							
		 ".\r\n"}, 
		/*01*/   {"Nohassle disabled, mobs will attack you now.\r\n",			
			  "Nohassle enabled, mobs will leave you alone now.\r\n"},
		/*02*/	{"Brief mode off.\r\n",
			 "Brief mode on.\r\n"},
		/*03*/	{"Compact mode off.\r\n",
			 "Compact mode on.\r\n"},
		/*04*/	{"You can now hear tells.\r\n",
			 "You are now deaf to tells.\r\n"},
		/*05*/	{"You are no longer AFK.\r\n",
			 "You are now AFK.\r\n"},
		/*06*/	{"You can now hear shouts.\r\n",
			 "You are now deaf to shouts.\r\n"},
		/*07*/	{"You can now hear gossip.\r\n",
			 "You are now deaf to gossip.\r\n"},
		/*08*/	{"You can now hear the congratulation messages.\r\n",
			 "You are now deaf to the congratulation messages.\r\n"},
		/*09*/	{"You can now hear the Wiz-channel.\r\n",
			 "You are now deaf to the Wiz-channel.\r\n"},
		/*10*/	{"You are no longer part of the Quest.\r\n",
			 "Okay, you are part of the Quest!\r\n"},
		/*11*/	{"You will no longer see the room flags.\r\n",
			 "You will now see the room flags.\r\n"},
		/*12*/	{"You will now have your communication repeated.\r\n",
			 "You will no longer have your communication repeated.\r\n"},
		/*13*/	{"HolyLight mode off.\r\n",
			 "HolyLight mode on.\r\n"},
		/*14*/	{"Autoexits disabled.\r\n",
			 "Autoexits enabled.\r\n"},
		/*15*/	{"You will now receive petitions from mortals!\r\n",
			 "You are now deaf to petitions!\r\n"},
		/*16*/	{"Mortals now see your name!\r\n",
			 "Mortals can no longer see your name!\r\n"},
		/*17*/  {"You are no longer anonymous.\r\n",
			 "You are now anonymous.\r\n"},
		/*18*/  {"You will no longer see vnums.\r\n",
			 "You will now see vnums.\r\n"},
		/*19*/  {"",
			 ""},
		/*20*/  {"Your area spells will now hit your race align in towns.\r\n",
			 "Your area spells won't hit your race align in towns.\r\n"},
		/*21*/  {"You feel nice and no longer vicious.\r\n",
			 "You will now kill mortally wounded victims.\r\n"},
                /*22*/  {"You will now auto-engage upon being offensively cast upon.\r\n",
			 "You will no longer auto-engage upon being offensively cast upon.\r\n"},
		/*23*/  {"",
			 ""},
		/*24*/	{"You will now let anyone follow you.\r\n",
			 "You will now avoid attracting new followers.\r\n"},
		/*25*/	{"You will now be seen by anyone.\r\n",
			 "You will now only be seen by people in the same room as you.\r\n"},

d2909 10
a2918 35
  argument = one_argument(argument, field);
  zcount = 0;
  
  
  if (!*field) 
    {/*show player his fields*/
      send_to_char("             FieryMUD TOGGLES!  (See HELP TOGGLE)\r\n", ch);
      send_to_char("==============================================================\r\n", ch);
      for (i = 0; *(fields[i].cmd) != '\n'; i++)
	if (fields[i].level <= GET_LEVEL(ch)) {/*here if person has access to toggle*/
	  
	  zcount++;
	  
	  if (i == SCMD_WIMPY) {
	    if (zcount == 1) {
	      if (GET_WIMP_LEV(ch))
		sprintf(buf2,"%d",GET_WIMP_LEV(ch));
	      else
		strcpy(buf2,"NO");
	      sprintf(buf, "%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    } 
	    if (zcount == 2) {
	      if (GET_WIMP_LEV(ch))
		sprintf(buf2,"%d",GET_WIMP_LEV(ch));
	      else
		strcpy(buf2,"NO");
	     sprintf(buf, "%s %s%s%11s  %5s&0 | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    }  
	    if (zcount == 3) {
              if (GET_WIMP_LEV(ch))
		sprintf(buf2,"%d",GET_WIMP_LEV(ch));
	      else
		strcpy(buf2,"NO");
	     sprintf(buf, "%s%s%s%11s  %5s&0\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    }
d2920 2
a2921 13
	  } else if (i == SCMD_PAGELENGTH) {
	    if (zcount == 1) {
	      sprintf(buf2,"%d", GET_PAGE_LENGTH(ch));
	      sprintf(buf, "%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    } 
	    if (zcount == 2) {
	      sprintf(buf2,"%d", GET_PAGE_LENGTH(ch));
	     sprintf(buf, "%s %s%s%11s  %5s&0 | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    }  
	    if (zcount == 3) {
	      sprintf(buf2,"%d", GET_PAGE_LENGTH(ch));
	     sprintf(buf, "%s%s%s%11s  %5s&0\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, buf2);
	    }
d2923 4
a2926 21
	  } else {
	    
	    if ( zcount == 1) {
	      sprintf(buf,"%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	    }
	    if ( zcount == 2) {
	      sprintf(buf,"%s %s%s%11s  %5s&0 | ",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	    }
	    if (zcount == 3) {
	      sprintf(buf,"%s%s%s%11s  %5s&0\r\n",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	    }		
	  }
	  
	  if (zcount == 3) {
	    send_to_char(buf, ch); 
	    zcount = 0;
	  }
	}	
      if (zcount < 3 && zcount != 0) {
	sprintf(buf,"%s\r\n", buf);
	send_to_char(buf, ch); 	      
d2928 6
a2933 1
      send_to_char("==============================================================\r\n", ch);
d2936 33
a2968 5
  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strn_cmp(field, fields[l].cmd, strlen(field)))
      break;
  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not high enough level for that!\r\n", ch);
d2972 1
a2972 1
  if (IS_NPC(ch))
d2975 1
a2975 56
  switch (l) 
    {
    case SCMD_SHOWVNUMS:
      result = PRF_TOG_CHK(ch, PRF_SHOWVNUMS);
      break;
    case SCMD_NOHASSLE:
      result = PRF_TOG_CHK(ch, PRF_NOHASSLE);
      break;
    case SCMD_BRIEF:
      result = PRF_TOG_CHK(ch, PRF_BRIEF);
      break;
    case SCMD_COMPACT:
      result = PRF_TOG_CHK(ch, PRF_COMPACT);
      break;
    case SCMD_NOTELL:
      result = PRF_TOG_CHK(ch, PRF_NOTELL);
      break;
    case SCMD_AFK:
      result = PRF_TOG_CHK(ch, PRF_AFK);
      break;
    case SCMD_DEAF:
      result = PRF_TOG_CHK(ch, PRF_DEAF);
      break;
    case SCMD_NOGOSSIP:
      result = PRF_TOG_CHK(ch, PRF_NOGOSS);
      break;
    case SCMD_NOGRATZ:
      result = PRF_TOG_CHK(ch, PRF_NOGRATZ);
      break;
    case SCMD_NOWIZ:
      result = PRF_TOG_CHK(ch, PRF_NOWIZ);
      break;
    case SCMD_QUEST:
      result = PRF_TOG_CHK(ch, PRF_QUEST);
      break;
    case SCMD_ROOMFLAGS:
      result = PRF_TOG_CHK(ch, PRF_ROOMFLAGS);
      break;
    case SCMD_NOREPEAT:
      result = PRF_TOG_CHK(ch, PRF_NOREPEAT);
      break;
    case SCMD_HOLYLIGHT:
      result = PRF_TOG_CHK(ch, PRF_HOLYLIGHT);
      break;
    case SCMD_AUTOEXIT:
      result = PRF_TOG_CHK(ch, PRF_AUTOEXIT);
      break;
    case SCMD_NOPETI:
      result = PRF_TOG_CHK(ch, PRF_NOPETI);
      break;
    case SCMD_NONAME:
      result = PRF_TOG_CHK(ch, PRF_NONAME);
      break;
    case SCMD_ANON:
      result = PRF_TOG_CHK(ch, PRF_ANON);
      break;
a2976 1
      
d2978 3
a2980 4
      
      if (!*arg)  {
	if (GET_WIMP_LEV(ch)) {
	  sprintf(buf, "Your current wimp level is %d hit points.\r\n", GET_WIMP_LEV(ch));
d2982 1
a2982 2
	  return;
	} else {
a2983 2
	  return;
	}
d2985 1
a2985 1
      if (isdigit(*arg)) {
d2989 1
a2989 1
	  else if (wimp_lev > GET_MAX_HIT(ch))
d2993 2
a2994 2
	    send_to_char(buf, ch);
	    GET_WIMP_LEV(ch) = wimp_lev;
d2998 1
a2998 1
	  GET_WIMP_LEV(ch) = 0;
d3002 1
a3002 16
      break;
    case SCMD_NICEAREA:
      result = PRF_TOG_CHK(ch, PRF_NICEAREA);
      break;
    case SCMD_VICIOUS:
      result = PRF_TOG_CHK(ch, PRF_VICIOUS);
      break;
    case SCMD_PASSIVE:
      result = PRF_TOG_CHK(ch, PRF_PASSIVE);
      break;
    case SCMD_NO_FOLLOW:
      result = PRF_TOG_CHK(ch, PRF_NOFOLLOW); 
      break; 
    case SCMD_CLOAKED:
      result = PRF_TOG_CHK(ch, PRF_CLOAKED);
      break;
a3003 1
      
a3004 1
      
d3006 2
a3007 2
	if (GET_PAGE_LENGTH(ch)) {
	  sprintf(buf, "Your current page length is %d.\r\n", GET_PAGE_LENGTH(ch));
a3008 1
	  return;
d3010 3
a3012 3
	  send_to_char("Your page length is not valid. Tell a god.\r\n", ch);
	  return;
	}
d3014 1
a3014 1
      if (isdigit(*arg)) {
d3023 1
a3023 1
	    GET_PAGE_LENGTH(ch) = page_length;
d3027 2
a3028 2
	  send_to_char("Page length restored to default (22 lines)\r\n", ch);
	  GET_PAGE_LENGTH(ch) = 22;
d3032 1
a3032 1
      break;
d3034 1
a3034 4
      send_to_char("Toggle what?!?\r\n", ch);
      /* Is this really necessary? the logging of bogus input on toggle attempts? */
      /*  log("SYSERR: Unknown subcmd in do_gen_toggle"); */
      return;
d3039 1
a3039 1
    send_to_char(tog_messages[l][TOG_ON], ch);
d3041 1
a3041 1
    send_to_char(tog_messages[l][TOG_OFF], ch);
d3049 8
a3056 11
    act ("&7$n &4&bglows&0&7 with a &bbright white aura&0&7 as $e waves $s mighty hand!&0",
	 FALSE,ch,0,0,TO_ROOM);
    send_to_room("&7&bA peaceful feeling washes into the room, dousing all violence!&0\r\n",ch->in_room);
    for(vict=world[ch->in_room].people;vict;vict=next_v)
      {
	next_v=vict->next_in_room;
	if(FIGHTING(vict)) {
	  stop_fighting(vict);
	}
	/*REMOVE_BIT(MOB_FLAGS(vict), MOB_AGGRESSIVE);*/        
      }
d3067 9
a3075 5
ACMD(do_petition) {
  
  struct char_data *i;
  extern struct char_data *character_list;
  
d3077 2
a3078 6
  if (GET_LEVEL(ch) >= LVL_IMMORT)
    {send_to_char("Petition is for those wimpy mortals!\r\n", ch);
    return;
    }
  if (IS_NPC(ch)) {
    send_to_char("&0Mobs can't petition!!&0\r\n", ch);
d3081 1
a3081 1
  if (!*argument){
d3084 17
a3100 12
  } else
    for (i = character_list;i; i = i->next){
      
      if(GET_LEVEL(i) >= LVL_IMMORT&&(!PRF_FLAGGED(i, PRF_NOPETI))){
	sprintf(buf, "&0&6%s&0&6 petitions, '&0&b&6%s&0&6'&0", GET_NAME(ch), 
		argument);
	act(buf, FALSE, i, 0, i, TO_CHAR);
      }
    }{
    sprintf(buf, "&0&6You petition, '&0&b&6%s&0&6'&0\r\n", argument);
    send_to_char(buf, ch);
    return;
d3131 2
a3132 2
  if(IS_FIGHTING(ch)) {
    send_to_char("You can't concentrate enough while you are fighting.\n\r",ch);
d3382 1
a3382 1
  if (IS_FIGHTING(ch)) {
a3460 1
      /*  (struct char_data *ch, char *arg, int cmd) */
d3462 1
a3462 3
  int skl_lvl = 0;
  
  if (IS_FIGHTING(ch)) {
d3466 2
a3467 8
  one_argument(argument, arg);
  
  if (IS_NPC(ch))
    return;
  
  skl_lvl = GET_SKILL(ch, SKILL_FIRST_AID);
  
  if (ch->char_specials.action_delays[ACT_DELAY_FIRST_AID]) {
d3474 10
a3483 4
  if ((number(1, 101) < skl_lvl) && (GET_HIT(ch) < GET_MAX_HIT(ch))) {
    GET_HIT(ch) += dice(6, GET_LEVEL(ch) - 1);
    if (GET_HIT(ch) > GET_MAX_HIT(ch))
      GET_HIT(ch) = GET_MAX_HIT(ch);
a3484 4
  
  improve_skill(ch, SKILL_FIRST_AID);
  
  ch->char_specials.action_delays[ACT_DELAY_FIRST_AID] = (SECS_PER_MUD_DAY * PASSES_PER_SEC);
d3486 1
d3493 1
a3493 1
  struct char_data *target;
d3495 4
a3498 2
  
  if (IS_NPC(ch))
d3503 3
a3505 3
  if (!*arg) {
    send_to_char("You feel sociable and stop ignoring anyone\r\n", ch);
    ch->player_specials->ignored = NULL;
d3508 2
a3509 2
  if ((target = get_char_vis(ch, arg)) == NULL) {
    send_to_char("No one by that name here..\r\n", ch);
a3511 12
  if (GET_LEVEL(target) > 70) {
    send_to_char("No one by that name here..\r\n", ch);
    return;
  }
  if (IS_NPC(target)) {
    send_to_char("No one by that name here..\r\n", ch);
    return;
  }
  if (ch->player_specials->ignored) {
    sprintf(buf, "You stop ignoring %s.\r\n", GET_NAME(ch->player_specials->ignored));
    send_to_char(buf, ch);
  }
d3514 1
a3514 1
  ch->player_specials->ignored = target;
d3953 7
@


1.174
log
@Natures embrace now sets camouflage bit, which lets you be hidden as long
as you are outside.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.173 2007/09/12 22:23:04 myc Exp myc $
d1155 1
a1155 1
ACMD(do_sneak)
d1157 2
a1158 55
  struct affected_type af;
  
  if (!GET_SKILL(ch, SKILL_SNEAK)) {
    if (GET_CLASS(ch) == CLASS_ROGUE)
      send_to_char("You'll need more experience before you can sneak effectively.\r\n", ch);
    else
      send_to_char("You'd better leave that art to the rogues.\r\n", ch);
    return;
  }
  one_argument(argument, arg);
  if (*arg) {
    if (!str_cmp(arg, "off")) {
      if (affected_by_spell(ch, SKILL_SNEAK)) {
	affect_from_char(ch, SKILL_SNEAK);
	send_to_char("Ok, you quit trying to sneak.\r\n", ch);
      }
      else if (AFF_FLAGGED(ch, AFF_SNEAK))
	send_to_char("You can't seem to quit.\r\n", ch);
      else
	send_to_char("You need to be sneaking before you can stop sneaking.\r\n", ch);
    }
    else
      send_to_char("Try \"sneak off\" to quit sneaking.\r\n", ch);
    return;
  }

  if (RIDING(ch)) {
    send_to_char("While mounted? I don't think so...\r\n", ch);
    return;
  }
  
  send_to_char("Okay, you'll try to move silently for a while.\r\n", ch);
  WAIT_STATE(ch, PULSE_VIOLENCE);

  if (AFF_FLAGGED(ch, AFF_SNEAK))
    affect_from_char(ch, SKILL_SNEAK);
  
  improve_skill(ch, SKILL_SNEAK);

  if (GET_SKILL(ch, SKILL_SNEAK) + dex_app_skill[GET_DEX(ch)].sneak < number(1, 101))
    return;

  af.type = SKILL_SNEAK;
  af.duration = GET_LEVEL(ch) / 2;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_SNEAK;
  af.bitvector2 = 0;
  af.bitvector3 = 0;

  if (GET_SKILL(ch, SKILL_STEALTH)) {
    if (GET_SKILL(ch, SKILL_STEALTH) >= number(1, 101))
      af.bitvector |= AFF_NOTRACK;
    improve_skill(ch, SKILL_STEALTH);
  }
a1159 9
  affect_to_char(ch, &af);
}



ACMD(do_hide)
{
  byte percent;
  
d1170 10
a1179 4
  send_to_char("You attempt to hide yourself.\r\n", ch);
  
  percent = number(1, 101);
  
a1181 3
  if (percent <= GET_SKILL(ch, SKILL_HIDE) + dex_app_skill[GET_DEX(ch)].hide)
    SET_BIT(AFF_FLAGS(ch), AFF_HIDE);

d1424 1
a1424 1
   if (AFF_FLAGGED(ch, AFF_HIDE | AFF_INVISIBLE) ||
d2981 2
a2982 1
    { "nofollow",   0,          PRF_NOFOLLOW},
d3040 2
a3041 2
		/*25*/	{"",
			 ""} 
d3232 3
d4003 2
a4004 1
    if (affected_by_spell(ch, SPELL_INVISIBLE))
d4006 3
a4008 3
    if (affected_by_spell(ch, SPELL_CONCEALMENT))
      appear(ch);
    REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE | AFF_HIDE);
d4205 4
@


1.173
log
@Removed autoexit set from shapechange since it's set in db.c now.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.172 2007/09/11 19:44:48 myc Exp myc $
d1483 2
a1484 1
   if (IS_AFFECTED(ch, AFF_INVISIBLE) || AFF_FLAGGED(ch, AFF_HIDE)) {
d4259 3
@


1.172
log
@Gods can turn into aquatic creatures whereever they please.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.171 2007/09/11 19:41:51 myc Exp myc $
a701 3
  /* Make sure autoexits is on.  All mobs share the dummy mob player 
   * specials, so this is actually setting it for all mobs. */
  SET_BIT(PRF_FLAGS(mob), PRF_AUTOEXIT);
d4258 3
@


1.171
log
@Renamed 'sting ray' as 'stingray'
/s
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.170 2007/09/11 16:34:24 myc Exp myc $
d647 1
a647 1
  if (IS_SET(type, AQUATIC | FISH) && !IS_WATER(ch->in_room)) {
d4261 4
@


1.170
log
@Rewrote shapechange command, added 9 new aquatic mobs, and animal
types (damager, tank, travel, tracker).  Certain shapechange mobs now
also have special skills.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.169 2007/09/03 23:59:43 jps Exp myc $
d518 1
a518 1
  { "ray",       1033, FISH | TRACKER | AQUATIC,  20, 200,  230, 150, 180, {SKILL_TRACK, SKILL_CORNER, SKILL_SNEAK, SKILL_STEALTH} },
d4261 5
@


1.169
log
@Added macro ADDED_WEIGHT_OK for testing whether a char can have an
object added to its inventory.  Avoids an integer overflow problem
that could occur if an object's weight was near maxint.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.168 2007/09/03 22:44:09 jps Exp jps $
d69 1
a69 1

d457 71
d530 1
a530 2
  int mob_vnum, r_num, location, leveldiff, i;
  int c_maxhit, c_hit, c_maxmove, c_move, m_maxhit, m_maxmove, c_align;
a531 59
  int mob_count, found = 0, rand, index = 0;
  char spec[50];
  double chan;

  double shpower; /* "shapechange power" - a measurement of how well you can
                     shapechange, based on alignment and level. The higher it
                     is, the higher level beast you can shapechange to. */

  char classchar; /* Char indicating the biological class desired - S, M, or R */

  struct sh_struct {
    char *cre;
    int vnum;
    char *type;
    int midlevel;
    int minhp;
    int maxhp;
    int minmv;
    int maxmv;
  } creatures[] = {
    /* If you add a new mobile to this list, it must be added
       before the '/n' line and you must increment the MAX_MOBS
       variable.
       
       M = Mammal, B = Bird, R = Reptile
                    VNUM   T   LV   -HP   +HP  -MV  +MV
                   -----   -   --  ----  ----  ---  ---          */
   { "rabbit",      1000, "M", 30,   80,  140, 200, 250},
   { "rat",         1001, "M",  8,   40,   60,  80, 120}, /* 1 */
   { "bat",         1002, "M",  8,   50,   75, 140, 180},
   { "horse",       1003, "M", 25,  220,  260, 180, 300},
   { "badger",      1004, "M", 30,  120,  160, 140, 170},
   { "wolf",        1005, "M", 35,  400,  480, 270, 320}, /* 5 */
   { "panther",     1006, "M", 40,  380,  450, 300, 350},
   { "bear",        1007, "M", 45,  640,  740, 140, 160},
   { "cheetah",     1008, "M", 45,  420,  500, 400, 480},
   { "rhino",       1009, "M", 50,  860, 1040, 120, 150},
   { "sparrow",     1010, "B",  4,   40,   60, 140, 180}, /* 10 */
   { "bluebird",    1011, "B",  6,   40,   70, 150, 200},
   { "robin",       1012, "B", 10,   60,   80, 125, 160},
   { "owl",         1013, "B", 15,   80,  100, 140, 160},
   { "raven",       1014, "B", 20,  100,  120, 160, 180},
   { "hawk",        1015, "B", 25,  160,  190, 190, 220}, /* 15 */
   { "falcon",      1016, "B", 30,  150,  180, 200, 240},
   { "buzzard",     1017, "B", 35,  240,  280, 140, 160},
   { "eagle",       1018, "B", 40,  320,  380, 260, 300},
   { "ostrich",     1019, "B", 45,  360,  460, 500, 650},
   { "snake",       1020, "R",  2,   25,   35,  80, 100}, /* 20 */
   { "lizard",      1021, "R",  6,   45,   55,  80, 120},
   { "chameleon",   1022, "R",  8,   60,   75,  80, 140},
   { "asp",         1023, "R", 20,  120,  160, 120, 160},
   { "tortoise",    1024, "R", 30,  320,  360,  40,  70},
   { "cobra",       1025, "R", 40,  280,  320, 140, 160}, /* 25 */
   { "turtle",      1026, "R", 45,  440,  480,  60, 100},
   { "viper",       1027, "R", 50,  340,  420, 140, 180},
   { "crocodile",   1028, "R", 55,  720,  830,  60, 120},
   { "anaconda",    1029, "R", 60,  945, 1025, 140, 160},
   { "\n",         00000, "0", 00, 0000, 0000, 000, 000}
  };
d533 1
a533 4
  if ((location = real_room(0)) < 0) {
    send_to_char("Your animal spirit declines.\r\n", ch);
    return;
  }
d535 2
a536 6
  if (ch->desc && ch->desc->original && !GET_SKILL(ch->desc->original, SKILL_SHAPECHANGE)){
    send_to_char("You have no idea how to do that!\r\n", ch);
    return;
  }
  
  if (!IS_NPC(ch) && !GET_SKILL(ch, SKILL_SHAPECHANGE)) {
d541 1
a541 5
  if (IS_FIGHTING(ch) && subcmd != 1) {
    send_to_char("You can't concentrate enough while fighting.\r\n",ch);
    return;
  }
  one_argument(argument, spec);
d543 1
a543 1
  if (!*spec) {
d547 2
d550 3
a552 2
    if (is_abbrev(spec, "me")) {
      
d555 1
a556 2
      act("You quickly morph back to your original self.",FALSE,ch,0,NULL,TO_CHAR);
      act("$n&0 contorts wildly as it reforms into $N.",FALSE,ch,0,player, TO_ROOM);
d558 6
a563 8
      c_maxhit = ch->points.max_hit;
      c_hit    = ch->points.hit;
      c_maxmove = ch->points.max_move;
      c_move    = ch->points.move;
      m_maxhit = GET_MAX_HIT(player);
      m_maxmove = GET_MAX_MOVE(player);
      GET_HIT(player) = (int)((1-((c_maxhit - c_hit)/(double)(c_maxhit)))*(double)(m_maxhit));
      GET_MOVE(player) = (int)((1-((c_maxmove - c_move)/(double)(c_maxmove)))*(double)(m_maxmove));
d570 1
d573 3
d577 2
a578 7
      if (GET_LEVEL(player) < LVL_IMMORT) {
        player->player_specials->saved.chant = 5;
      }
      return;
    } else {
      send_to_char("You cannot shapechange to another animal from this form.\r\n", ch);
      return;
d580 1
d583 3
a585 3
  if (!strcmp(spec, "me")) {
     send_to_char("You are already in your normal form.\r\n", ch);
     return;
a587 2
  /* Final determination as to whether this person is capable of shapechanging */

d590 3
a592 12
           variable for shapechange. Zantir */ 
  if (ch->player_specials->saved.chant > 0 && GET_LEVEL(ch) < LVL_IMMORT)
  {
     send_to_char("You are still drained from your last shapechange.\r\n", ch);
     return;
  } 

  if (GET_ALIGNMENT(ch) >= 350 && GET_LEVEL(ch) < 101) {
    send_to_char("Your good loyalties betray your nature, inhibiting a transformation.\r\n", ch);
    return;
  } else if (GET_ALIGNMENT(ch) <= -350 && GET_LEVEL(ch) < 101) {
    send_to_char("Your evil loyalties betray your nature, inhibiting a transformation.\r\n", ch);
d596 11
a606 1
   /* Shapechange is possible. Figure out what to change to, based on the request */
d608 38
a645 2
   mob_vnum = 0;
   mob_count = 0;
d647 4
a650 3
   /* Calculate your shapechange power */
   shpower = (double)((350 - abs(GET_ALIGNMENT(ch))) / 325.0) +
      (double)((GET_LEVEL(ch) - 75)/1000.0);
d652 29
a680 10
   if (is_abbrev(spec, "mammal")) {
      classchar = 'M';
   } else if (is_abbrev(spec, "bird")) {
      classchar = 'B';
   } else if (is_abbrev(spec, "reptile")) {
      classchar = 'R';
   } else {
      /* Shapechanger has requested a specific animal */
      classchar = '\0';
   }
d682 2
a683 53
   if (classchar == '\0') {
      /* Find a specifically-requested animal */
      for (i = 0; *(creatures[i].cre) != '\n'; i++) {
         if (!strcmp(spec, creatures[i].cre)) {
            if (GET_LEVEL(ch) >= (creatures[i].midlevel)) {
               rand = number(8, 10);
               chan = (double)(rand / 10.0);
               if (shpower >= chan || GET_LEVEL(ch) > 100) {
                  index = i;
                  found = 1;
               }
            }
            break;
         }
      }
      if (!found) {
         send_to_char("You don't know how to shapechange into that.\r\n", ch);
         return;
      }
      mob_vnum = creatures[index].vnum;
   } else {
      /* Choose (somewhat) randomly from the chosen class */
      for (i = 0; *(creatures[i].cre) != '\n'; i++) {
        rand = (int)(((350 - abs(GET_ALIGNMENT(ch))) / 350.0) * 5);
        if (GET_LEVEL(ch) >= (creatures[i].midlevel - 5 - number(0, rand))
              && creatures[i].type[0] == classchar) {
          mob_count++;
          valid[mob_count] = i;
          level[mob_count] = creatures[i].midlevel;
        }
      }
      sort(1, mob_count);
      rand = number(8, 10);
      chan = (double)(rand / 10.0);
      if (shpower >= chan) {
        if (mob_count > 0)
          index = valid[mob_count];
          mob_vnum = creatures[index].vnum;
      } else {
        rand = number(1, mob_count);
        if (mob_count > 0) {
          index = valid[rand];
          mob_vnum = creatures[index].vnum; 
       }
      }
    }
  
   /* Make sure a prototype actually exists for this mob.
    *
    * If this happens it's BAD - either the .mob file went missing,
    * or someone added a mob to the creatures[] array above without building it,
    * or something even more heinous occurred. */
  if ((r_num = real_mobile(mob_vnum)) < 0) {
d685 3
a687 3
    sprintf(buf, "Shapechange error: %s tried to change to nonexistent mob prototype %d",
          GET_NAME(ch), mob_vnum);
	 mudlog(buf, BRF, LVL_GOD, TRUE);
a690 3
  /* Create the mobile */
  mob = read_mobile(r_num, REAL);

d695 1
a695 1
  /* Shuffle the characters around */
d698 3
a700 5
  char_to_room(ch, location);
  
  /* Copy some preferences from the player to the mob */
  if (PRF_FLAGGED(ch, PRF_AUTOEXIT))
    SET_BIT(PRF_FLAGS(mob), PRF_AUTOEXIT);    
d702 21
d724 7
a730 17
  leveldiff = GET_LEVEL(ch) - creatures[index].midlevel;
  if (leveldiff > 5) {
    mob->player.level = (byte) (creatures[index].midlevel + 5);
  } else if (leveldiff < -5) {
    mob->player.level = (byte) (creatures[index].midlevel - 5);
  } else {
    rand = (int)(((350 - abs(GET_ALIGNMENT(ch))) / 350.0) * 5);
    mob->player.level = (byte) (creatures[index].midlevel + MAX(rand, leveldiff));
  }

  /* Prepare to set the mob's hp and mv to the same fraction of fullness
   * that the player did */
  c_maxhit = ch->points.max_hit;
  c_hit    = ch->points.hit;
  c_maxmove = ch->points.max_move;
  c_move    = ch->points.move;
  c_align = GET_ALIGNMENT(ch);  
d732 1
d737 11
d749 1
a749 7
  GET_MAX_HIT(mob) = number(creatures[index].minhp, creatures[index].maxhp);
  GET_MAX_MOVE(mob) = number(creatures[index].minmv, creatures[index].maxmv);
  m_maxhit = GET_MAX_HIT(mob);
  m_maxmove = GET_MAX_MOVE(mob);
  GET_HIT(mob) = (int)((1-((c_maxhit - c_hit)/(double)(c_maxhit)))*(double)(m_maxhit));
  GET_MOVE(mob) = (int)((1-((c_maxmove - c_move)/(double)(c_maxmove)))*(double)(m_maxmove));
  GET_ALIGNMENT(mob) = c_align;
d751 1
a751 2
  alter_hit(mob, 0, 1);
}
d4261 5
@


1.168
log
@Fix douse message when a fountain is used.  Make douse automatically
successful when in a water room of any kind, or a swamp or beach room.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.167 2007/08/27 21:18:00 myc Exp jps $
d1335 1
a1335 1
                  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) < CAN_CARRY_W(ch)) {
d4246 4
@


1.167
log
@You can now queue up commands while casting as well as abort midcast.
Casting commands such as look and abort are caught and interpreted
before the input is normally queued up by the game loop.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.166 2007/08/26 01:55:41 myc Exp myc $
d1777 69
a1845 8
  if (ch == vict) {
    if (success) {
      act("*SPLASH* $n leaps into the fountain, putting out the flames that were consuming $m.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("*SPLASH* You leap into the fountain, dousing the flames that were consuming you!", ch);
    }
    else if (GET_SKILL(ch, SKILL_DOUSE) < number(0,100)) {
      act("$n&0 frantically rolls around on the ground, attempting to douse the flames consuming $s body.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You roll around on the ground, trying to douse the flames engulfing your body!", ch);
d1848 4
a1851 2
      act("$n&0 rolls on the ground frantically, finally smothering the fire that was consuming $m.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You roll around on the ground, finally smothering the flames that were consuming you.", ch);
d1855 2
a1856 6
  else if (success) {
    act("You dunk $N into the fountain putting $M out! *SPLASH* *GURGLE*",FALSE,ch,0,vict,TO_CHAR);
    act("$n dunks you into the fountain putting your flames out! *GURGLE*",FALSE,ch,0,vict,TO_VICT);
    act("$n dunks $N into the fountain dousing the flames that were consuming $M! *SPLASH* *GURGLE*",FALSE,ch,0,vict,TO_NOTVICT);
  }
  /* Slightly more difficult to douse others. */
d1858 6
a1863 3
    act("You frantically try to brush the flames from $N&0.",FALSE,ch,0,vict,TO_CHAR);
    act("$n&0 aids you, attempting to douse your flames.",FALSE,ch,0,vict,TO_VICT);
    act("$n&0 frantically attempts to brush the flames off $N&0.",FALSE,ch,0,vict,TO_NOTVICT);
d1866 6
a1871 3
    act("You frantically brush the flames from $N&0, finally extinguishing $M!", TRUE, ch, 0, vict, TO_CHAR);
    act("$n&0 aids you, finally putting your flames out!", FALSE, ch, 0, vict, TO_VICT);
    act("$n&0 finally douses the flames that were consuming $N&0!", FALSE, ch, 0, vict, TO_NOTVICT);
d4246 5
@


1.166
log
@Fire now does real damage.  All fire spells have a chance to catch the
victim on fire.  Mobs attempt to douse themselves.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.165 2007/08/18 21:23:40 jps Exp myc $
d1130 1
d1132 2
a1133 1
  if (CASTING(ch))
d1135 3
d4181 4
@


1.165
log
@Remove a lot of redundant code from do_shapechange. Changed syntax so that
shapechange only takes one argument: class (mammal, bird, reptile) or
the name of the creature.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.164 2007/08/16 11:52:47 jps Exp jps $
d1742 1
a1742 1
  bool found_fountain = FALSE;
d1744 1
a1744 1
  struct obj_data *t_obj;
d1746 1
a1746 1
  if(!ch)
d1748 14
a1761 2
  if (IS_FIGHTING(ch)) {
    send_to_char("Worry about the battle before the fire!\n\r",ch);
d1764 6
a1769 4
  
  for(t_obj = world[ch->in_room].contents; t_obj && !found_fountain;t_obj = t_obj->next_content) {
    if (t_obj->obj_flags.type_flag == ITEM_FOUNTAIN ) {
      found_fountain = TRUE;
d1771 9
a1779 26
  }  
  one_argument(argument, arg);
  
  vict=get_char_room_vis(ch,arg);
  if(!arg || !*arg || vict==ch) {
    if(!IS_AFFECTED2(ch, AFF2_ON_FIRE)) {
      send_to_char("Where's the fire?\r\n",ch);
      return;
    } else {
      if( found_fountain == TRUE ) {
        act("*SPLASH* $n leaps into the fountain putting out the flames that were consuming $m.",FALSE,ch,0,0,TO_ROOM);
        act("*SPLASH* You leap into the fountain dousing the flames that were consuming you.",FALSE,ch,0,0,TO_CHAR);
        improve_skill(ch, SKILL_DOUSE);
	REMOVE_BIT(AFF2_FLAGS(ch),AFF2_ON_FIRE);
      } else {
	if((GET_SKILL(ch, SKILL_DOUSE)-10) < number(0,100)){
	  act("$n&0 rolls around on the ground frantically in an attempt to douse the flames consuming $s body.",FALSE,ch,0,0,TO_ROOM);
	  act("You roll around on the ground trying to douse the flames engulfing your body!",FALSE,ch,0,0,TO_CHAR);
	  improve_skill(ch, SKILL_DOUSE);
	} else {
	  act("$n&0 rolls on the ground frantically, finally dousing the fire that was consuming $m.",FALSE,ch,0,0,TO_ROOM);
	  act("You roll around on the ground, finally dousing the flames that were consuming you.",FALSE,ch,0,0,TO_CHAR);
	  improve_skill(ch, SKILL_DOUSE);
	  REMOVE_BIT(AFF2_FLAGS(ch),AFF2_ON_FIRE);
	}
      }
d1781 4
a1784 4
  } else {
    if(!vict){
      send_to_char("You don't see that person here.\r\n",ch);
      return;
d1786 22
a1807 25
    if(!IS_AFFECTED2(vict, AFF2_ON_FIRE)){
      send_to_char("That person is not on fire.\r\n",ch);
      return;
    }
    if( found_fountain == TRUE ) {
      act("You dunk $N into the fountain putting $M out! *SPLASH* *GURGLE*",FALSE,ch,0,vict,TO_CHAR);
      act("$n dunks you into the fountain putting your flames out! *GURGLE*",FALSE,ch,0,vict,TO_VICT);
      act("$n dunks $N into the fountain dousing the flames that were consuming $M! *SPLASH* *GURGLE*",FALSE,ch,0,vict,TO_NOTVICT);
      improve_skill(ch,SKILL_DOUSE);
      REMOVE_BIT(AFF2_FLAGS(vict),AFF2_ON_FIRE);    
    } else {
      if((GET_SKILL(ch, SKILL_DOUSE)-50) < number(0,100)){
	act("You frantically try to brush the flames from $N&0.",FALSE,ch,0,vict,TO_CHAR);
	act("$n&0 aids you, attempting to douse your flames.",FALSE,ch,0,vict,TO_VICT);
	act("$n&0 frantically attempts to brush the flames off $N&0.",FALSE,ch,0,vict,TO_NOTVICT);
	improve_skill(ch,SKILL_DOUSE);
      } else {
	act("You frantically try to brush the flames from $N&0. You finally put $M out!",FALSE,ch,0,vict,TO_CHAR);
	act("$n&0 aids you, finally putting your flames out!",FALSE,ch,0,vict,TO_VICT);
	act("$n&0 finally douses the flames that were consuming $N&0!",FALSE,ch,0,vict,TO_NOTVICT);
	improve_skill(ch,SKILL_DOUSE);
	REMOVE_BIT(AFF2_FLAGS(vict),AFF2_ON_FIRE);    
      }
    }    
  }  
d4176 5
@


1.164
log
@Remove defunct do_old_subclass. The magic of RCS means you can find it
again if you REALLY want to.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.163 2007/08/14 22:43:07 myc Exp jps $
d459 1
a459 1
  int mob_vnum, r_num, location, leveldiff, l;
d462 1
a462 1
  int mob_count, cnt, found = 0, rand, index = 0;
d464 7
a470 2
  char type[50];
  double perc, lvla, chan;
d522 5
d541 1
a541 1
  two_arguments(argument, spec, type);
d551 1
a551 1
	close_socket(ch->desc->original->desc);
d573 1
a573 1
      if (GET_LEVEL(player) < 101) {
a574 2
      } else {
        player->player_specials->saved.chant = 0;
d577 1
a577 2
    }
    else {
d583 7
d593 1
a593 1
  if (ch->player_specials->saved.chant > 0)
d607 1
a607 2
  mob_vnum = 0;
  mob_count = 0;
d609 17
a625 33
  if (is_abbrev(spec, "mammal")) {
    if (*type) {
      for (l = 0;*(creatures[l].cre) != '\n';l++) {
        if (!strncmp(type, creatures[l].cre, strlen(type)) &&
            is_abbrev(creatures[l].type, "M")) {
          if (GET_LEVEL(ch) >= (creatures[l].midlevel - 5 - number(0, rand))) {
            perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
            lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
            perc += lvla;
            rand = number(8,10);
            chan = (double)(rand/10.0);
            if (perc >= chan || GET_LEVEL(ch) > 100) {
              index = l;
              found = 1;
            }
          }
          break;
        }
      }
    }
    if (found == 1) {
      mob_vnum = creatures[index].vnum;
    } else {
      for (cnt=0;*(creatures[cnt].cre) != '\n';cnt++) {
        rand = (int)(((350 - abs(GET_ALIGNMENT(ch)))/350.0) * 5);
        if (GET_LEVEL(ch) >= (creatures[cnt].midlevel - 5 - number(0, rand))
            && is_abbrev(creatures[cnt].type, "M")) {
          mob_count++;
          valid[mob_count] = cnt;
          level[mob_count] = creatures[cnt].midlevel;
        }
      }
      sort(1, mob_count);
d627 11
a637 31
      perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
      lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
      perc += lvla;
      rand = number(8,10);
      chan = (double)(rand/10.0);
      if (perc >= chan) {
        if (mob_count > 0)
          index = valid[mob_count];
          mob_vnum = creatures[index].vnum;
      } else {
        rand = number(1, mob_count);
        if (mob_count > 0) {
          index = valid[rand];
          mob_vnum = creatures[index].vnum; 
       }
      }
    }
  } else if (is_abbrev(spec, "bird")) {
    if (*type) {
      for (l = 0;*(creatures[l].cre) != '\n';l++) {
        if (!strncmp(type, creatures[l].cre, strlen(type)) &&
            is_abbrev(creatures[l].type, "B")) {
          if (GET_LEVEL(ch) >= (creatures[l].midlevel - 5 - number(0, rand))) {
            perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
            lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
            perc += lvla;
            rand = number(8,10);
            chan = (double)(rand/10.0);
            if (perc >= chan || GET_LEVEL(ch) > 100) {
              index = l;
              found = 1;
d639 2
a640 3
          }
          break;
        }
d642 3
a644 50
    }
    if (found == 1) {
      mob_vnum = creatures[index].vnum;
    } else {
      for (cnt=0;*(creatures[cnt].cre) != '\n';cnt++) {
        rand = (int)(((350 - abs(GET_ALIGNMENT(ch)))/350.0) * 5);
        if (GET_LEVEL(ch) >= (creatures[cnt].midlevel - 5 - number(0, rand))
            && is_abbrev(creatures[cnt].type, "B")) {
          mob_count++;
          valid[mob_count] = cnt;
          level[mob_count] = creatures[cnt].midlevel;
        }
      }
      sort(1, mob_count);

      perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
      lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
      perc += lvla;
      rand = number(8,10);
      chan = (double)(rand/10.0);
      if (perc >= chan) {
        if (mob_count > 0)
          index = valid[mob_count];
          mob_vnum = creatures[index].vnum;
      } else {
        rand = number(1, mob_count);
        if (mob_count > 0) {
          index = valid[rand];
          mob_vnum = creatures[index].vnum; 
       }
      }
    }
  } else if (is_abbrev(spec, "reptile")) {
    if (*type) {
      for (l = 0;*(creatures[l].cre) != '\n';l++) {
        if (!strncmp(type, creatures[l].cre, strlen(type)) &&
            is_abbrev(creatures[l].type, "R")) {
          if (GET_LEVEL(ch) >= (creatures[l].midlevel - 5 - number(0, rand))) {
            perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
            lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
            perc += lvla;
            rand = number(8,10);
            chan = (double)(rand/10.0);
            if (perc >= chan || GET_LEVEL(ch) > 100) {
              index = l;
              found = 1;
            }
          }
          break;
        }
a645 2
    }
    if (found == 1) {
d647 6
a652 5
    } else {
      for (cnt=0;*(creatures[cnt].cre) != '\n';cnt++) {
        rand = (int)(((350 - abs(GET_ALIGNMENT(ch)))/350.0) * 5);
        if (GET_LEVEL(ch) >= (creatures[cnt].midlevel - 5 - number(0, rand))
            && is_abbrev(creatures[cnt].type, "R")) {
d654 2
a655 2
          valid[mob_count] = cnt;
          level[mob_count] = creatures[cnt].midlevel;
d659 3
a661 7

      perc = (double)((350 - abs(GET_ALIGNMENT(ch)))/325.0);
      lvla = (double)((GET_LEVEL(ch) - 75)/1000.0);
      perc += lvla;
      rand = number(8,10);
      chan = (double)(rand/10.0);
      if (perc >= chan) {
a672 4
  } else {
    send_to_char("You can only be a mammal, bird, or reptile at this time.\r\n",ch);
    return;
  }
d674 5
d680 4
a683 1
    send_to_char("You start to change, then feeling ill, slumping back to your normal form.\r\n", ch);
d686 2
d689 3
a691 2
  
  act("The snap of bones reforming can be heard, as $n's form takes the shape of $N&0!", FALSE, ch, 0, mob, TO_ROOM);
a692 16
  
  if ((location = real_room(0)) < 0) {
    send_to_char("There is a problem with the target room!\r\n", ch);
    return;
  }

  /* Here is where you add special effects to the mob that
     can not be directly set on the mobile. */
  switch (index) {
    case 0:
      break;
    case 1:
      break;
    default:
      break;
  }  
d694 1
d699 1
d710 1
a710 1
    rand = (int)(((350 - abs(GET_ALIGNMENT(ch)))/350.0) * 5);
d714 2
a721 3
  if (GET_LEVEL(ch) > 101)
    ch->player_specials->saved.chant = -1;

a735 1
  
d745 1
a745 1
   /*  Demolitum (12 Oct 2001) - Player save functionality for god types. */
d4182 4
@


1.163
log
@Adding 'stealth' skill as secondary effect for sneak.  Stealth
makes a person untrackable and invisible on 'who -z'.
Cleaned up hide code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.162 2007/08/14 10:43:11 jps Exp myc $
a327 106
ACMD(do_old_subclass)
{
  char_data *qm;
  struct trig_var_data *vlist;
  int subclass=0;
  int i;
  float oldpct;
  char var_to_find[35];	/* = can_subclass_<name of player>*/
  
  if (!ch || IS_NPC(ch) || !ch->desc)
    return;

  sprintf(var_to_find,"can_subclass_%c%s",LOWER(*(ch->player.name)),((ch->player.name)+1));
    /* 1 find a mob in the current room who has the TEACHER flag */
    for (qm = world[ch->in_room].people ; qm ; qm = qm->next_in_room)
    {
	    if(MOB_FLAGGED(qm,MOB_TEACHER))
	    {
		    /* 2 check for the global variable 'can_subclass' which should equal players name*/
		    for (vlist = (qm->script)->global_vars; vlist; vlist = vlist->next)
		    {
	                    /* 3 subclass is ok...this is based on current class, dont forget to unset can_subclass..*/
			    if (!strcmp(vlist->name,var_to_find))
		            {
				    for (i=0;i<NUM_CLASSES;i++)
				    {
					    if (!strncmp(strip_ansi(class_abbrevs[i]),vlist->value,strlen(strip_ansi(class_abbrevs[i]))))
					    {
				                subclass = i;	/* eg 4=PALADIN, 5=ANTIPAL etc)*/
						break;
					    }
				    }
			    }

                            break; /*no need to check other vars*/
		    }
		    /* if these vars dont actually exist is no biggy...*/
	            remove_var(&((qm->script)->global_vars),var_to_find);

		    if (subclass)
		    {
			    /* check the subclass requiredis valid for the user..though it really should be..*/
			    switch (GET_CLASS(ch))
			    {
				    case CLASS_MAGIC_USER:  for (i=0;i < MAGE_SUBCLASSES;i++)
				                              if (mage_subclasses[i] == subclass)
								      break;
					                    if (i == MAGE_SUBCLASSES || subclass == 0)
							    {
                                                              fprintf(stderr,"act.other.c:Bad value used for mage subclass destination class (%d)\n",subclass);
							      return;
							    }
							    break;
				    case CLASS_WARRIOR:     for (i=0;i < WARRIOR_SUBCLASSES;i++)
				                              if (warrior_subclasses[i] == subclass)
								      break;
					                    if (i == WARRIOR_SUBCLASSES || subclass == 0)
							    {
                                                              fprintf(stderr,"act.other.c:Bad value used for warrior subclass destination class (%d)\n",subclass);
							      return;
							    }
							    break;
				    case CLASS_ROGUE:       for (i=0;i < ROGUE_SUBCLASSES;i++)
				                              if (rogue_subclasses[i] == subclass)
								      break;
					                    if (i == ROGUE_SUBCLASSES || subclass == 0)
							    {
                                                              fprintf(stderr,"act.other.c:Bad value used for rogue subclass destination class (%d)\n",subclass);
							      return;
							    }
							    break;
				    case CLASS_CLERIC:      for (i=0;i < CLERIC_SUBCLASSES;i++)
				                              if (cleric_subclasses[i] == subclass)
								      break;
					                    if (i == CLERIC_SUBCLASSES || subclass == 0)
							    {
                                                              fprintf(stderr,"act.other.c:Bad value used for cleric subclass destination class (%d)\n",subclass);
							      return;
							    }
							    break;

			             default:               mudlog ("Bad value for character class in do_subclass",NRM,LVL_GOD,FALSE);
				                            break;
			    }

                            /* Get leveled percentage */
                            oldpct = GET_EXP(ch)/(double)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)));
  
                            /* Change the class */
                            GET_CLASS(ch) = subclass;
  
                            /* Fix the exp */
                            GET_EXP(ch) = (long)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) * oldpct);
  
                            /* Update the skills */
                            update_skills(ch);
  
                            /* This is from old hubis code, I guess it can stay */
                            check_regen_rates(ch);

			    send_to_char("You have successfully subclassed!\r\n",ch);
		    }
	    }
    }

}
d4267 5
@


1.162
log
@Laryngitis will prevent you from consenting, because the consent command
is one way to pester people at a distance.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.161 2007/08/05 20:21:51 myc Exp jps $
a1331 2
  byte percent;
  char sbuf[MAX_STRING_LENGTH];
d1333 5
a1337 2
  if (IS_FIGHTING(ch)) {
    send_to_char("You can't sneak while you are fighting!\n\r",ch);
d1340 3
a1342 10
  if (GET_SKILL(ch, SKILL_SNEAK) < 1){
     if (GET_CLASS(ch) == CLASS_ROGUE)
        send_to_char("You'll need more experience before you can sneak effectively.\r\n", ch);
     else
       send_to_char("You'd better leave that art to the rogues.\r\n", ch);
    return;
  }
  one_argument(argument, sbuf);
  if (*sbuf) {
    if (!str_cmp(sbuf, "off")) {
d1346 2
a1347 2
	return;
      } else if (IS_AFFECTED(ch, AFF_SNEAK)) {
d1349 1
a1349 2
	return;
      } else {
d1351 2
a1352 3
	return;
      }
    } else {
a1353 2
      return;
    }
d1356 1
d1363 3
a1365 2
  WAIT_STATE(ch, PULSE_VIOLENCE + 2);
  if (IS_AFFECTED(ch, AFF_SNEAK))
d1368 3
a1370 3
  percent = number(1, 101);	/* 101% is a complete failure */
  
  if (percent > GET_SKILL(ch, SKILL_SNEAK) + dex_app_skill[GET_DEX(ch)].sneak)
d1372 1
a1372 1
  
d1380 7
a1387 1
  improve_skill(ch, SKILL_SNEAK);
d1396 1
a1396 1
  if (GET_SKILL(ch, SKILL_HIDE) < 1){           /*  was skill_sneak duh -Banyal */
a1400 5
  if(IS_FIGHTING(ch)) {
    send_to_char("You cannot hide in combat...\r\n", ch);
    return;
  }
  
d1405 1
d1408 1
a1408 5
  if (IS_AFFECTED(ch, AFF_HIDE)) {
    send_to_char("You are already well hidden in the shadows...\r\n", ch);
    return;
  }
  percent = number(1, 101);	/* 101% is a complete failure */
d1412 3
a1414 5
  if (percent > GET_SKILL(ch, SKILL_HIDE) + dex_app_skill[GET_DEX(ch)].hide){
    improve_skill(ch, SKILL_HIDE);
    return;
  }
  SET_BIT(AFF_FLAGS(ch), AFF_HIDE);
d4373 4
@


1.161
log
@Cleaned up bandage code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.160 2007/08/05 01:50:16 myc Exp myc $
d68 1
a68 2

/* extern int gossip_channel_active; from when ooc was a toggle */
d2248 5
d4385 3
@


1.160
log
@Follow, guard, and consent all follow similar usage patterns now.
<action> off/self/me stops whatever it is, <action> target starts
on the target, and <action> shows who is currently targeted.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.159 2007/08/04 21:13:10 myc Exp myc $
d2258 1
a2262 1
  int percent, heal, diff;
d2264 19
a2282 2
  if (IS_FIGHTING(ch)) {
    send_to_char("Worry about the wounds you are getting first!\n\r",ch);
d2285 14
a2298 58
  one_argument(argument, buf);   
  if (!(*buf))
    {/*look for first person in room*/
      /*   for (victim = world[ch->in_room].people; victim; victim =
	   victim->next_in_room) 
	   {
	   if (CAN_SEE(ch, victim))
	   if ((GET_HIT(victim) < GET_MAX_HIT(victim)) && (GET_POS(victim) <= POS_STUNNED))
	   {
	   break;
	   vict = TRUE;
	   }
	   }
	   
	   if (!vict)
	   {
	   send_to_char("No-one here looking to sick\r\n", ch);
	   return;  
	   }*/
      send_to_char("You must supply a name!!\r\n", ch);
      return;
    }
  if (!(victim = get_char_room_vis(ch, buf))) 
    {
      send_to_char(NOPERSON, ch);
      return;
    }
  if ((GET_HIT(victim) >= 0) && (GET_POS(victim) >= POS_STUNNED))
    {
      act("&0&8$N looks in pretty good shape already!.&0", FALSE, ch, 0, victim, TO_CHAR);
      return;
    }
  percent = number(1, 80);
  diff = GET_SKILL(ch, SKILL_BANDAGE);
  if (diff <= 10)
    heal = 1;
  else if (diff <= 80)
    heal = 2;
  else
    heal = 3;
  if (diff > percent)
    {
      alter_hit(victim, (0 - heal), 1);
      act("&0&8You bandage $N.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&8$n&0&8 bandages $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    }
  else
    {
      alter_hit(victim, 1, 1);
      act("You fail to bandage $N properly.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&8$n fails an attempt to bandage $N&8's wounds.&0", FALSE, ch, 0, victim, TO_NOTVICT); 
      if (GET_HIT(victim) <= HIT_DEAD) {
        act ("Your bandaging was so appalling that $N died!&0",FALSE,ch,0,victim
,TO_CHAR);
        act("&8$n kills $N with some dismal bandaging.&0", FALSE, ch, 0, victim,
 TO_NOTVICT);
        die(victim,ch);  /*counts as a kill..*/
      }
d2300 1
d4381 5
@


1.159
log
@Cleaned up layhands code.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.158 2007/08/03 22:00:11 myc Exp myc $
a101 4
  if (IS_FIGHTING(ch)) {
    send_to_char("I think you should guard yourself for now\n\r",ch);
    return;
  }
d108 6
a113 2
  if (!arg || !*arg) {
    send_to_char("Guard who!?\r\n",ch);
d116 4
a119 5
  if (is_abbrev(arg, "off")) {
    stop_guarding(ch);
    return;
  }
  if ((vict = get_char_room_vis(ch, arg)) == NULL || IS_NPC(vict)){
d123 6
a128 2
  if(ch == vict) {
    send_to_char("Your always guarding yourself, hopefully.\r\n", ch);
d131 3
a133 2
  if(vict->guarded_by) {
    if(vict->guarded_by == ch) {
d135 1
a135 3
      return;
    }
    else {
d137 1
a137 2
      return;
    }
d139 3
a141 2
  if(ch->guarding) {
    if(ch->guarding == vict) {
d148 3
a150 3
  act("You start guarding $N.",FALSE,ch,0,vict,TO_CHAR);
  act("$n starts guarding you.",TRUE,ch,0,vict,TO_VICT);
  act("$n lays a protective eye on $N, guarding $M.",TRUE,ch,0,vict,TO_NOTVICT);
d2215 9
a2223 13
   one_argument(argument, buf);
   if (!*buf) {
      if (!CONSENT(ch)) {
         send_to_char("Consent?? you are not consented to anyone!\r\n", ch);
         return;
      } else {
         if (CAN_SEE(ch, CONSENT(ch))) {
            act("&0&7&b$n has revoked $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT | TO_SLEEP);
         }
         send_to_char("&0&7&bYou revoke your consent.&0\r\n", ch);
         CONSENT(ch) = NULL;
         return;
      }
d2226 3
a2228 1
   if (!(target = get_char_vis(ch, buf))) {
d2234 7
a2240 1
      send_to_char("Consent yourself?? Rolf I don't think so.\r\n", ch);
d2243 4
a2246 18
   /*ok concent this person*/
   if ((!CONSENT(ch))) {
      CONSENT(ch) = target;
      if (CONSENT(ch) == target) {
         act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR | TO_SLEEP);
         act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT | TO_SLEEP);
      } else
         send_to_char("You may not consent that person.\r\n", ch);
   } else if (CONSENT(ch) == target) {
      act("You are already consenting $M.", FALSE, ch, 0, target, TO_CHAR | TO_SLEEP);
   } else {
      act("&0&7&b$n has removed $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT | TO_SLEEP);
      CONSENT(ch) = target;	
      if (CONSENT(ch) == target) {
         act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR | TO_SLEEP);
         act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT | TO_SLEEP);
      } else
         send_to_char("You may not consent that person.\r\n", ch);
d2248 7
d4407 3
@


1.158
log
@Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.157 2007/08/03 03:51:44 myc Exp myc $
d3670 2
a3671 8
  char tch[MAX_STRING_LENGTH];
  char tnv[MAX_STRING_LENGTH];
  char tcv[MAX_STRING_LENGTH];
  char dam[MAX_STRING_LENGTH];
  int healing_to_victim = 0; 
  int harm_to_victim = 0; 
  int harm_to_char = 0;
  bool has_damage = FALSE;
d3673 5
a3677 6
  one_argument(argument, arg);  
  
  /* no mobs allowed */
  if (IS_NPC(ch)) 
  {
    send_to_char("Silly mobile, you can't lay hands!\r\n", ch);
d3681 3
a3683 4
  /* check for appropriate class */
  if ((GET_CLASS(ch) != CLASS_PALADIN) && (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) 
  {
    send_to_char("You don't have the ability to lay hands.\r\n", ch);
d3685 13
d3699 3
a3701 5
  
  /* No argument, target self if paladin, target fighting if anti or error message */
  if(!(*arg)) 
  {
    if (GET_CLASS(ch) == CLASS_PALADIN) 
d3703 5
a3707 11
    if (GET_CLASS(ch) == CLASS_ANTI_PALADIN) 
    {
      if (FIGHTING(ch)) 
      {
	vict = FIGHTING(ch);
      }
      else
      {
	send_to_char("How about a target this time!\r\n",ch); 
        return;
      }
d3711 3
a3713 5
  if (*arg) 
  {
    if (!(vict = get_char_room_vis(ch, arg))) 
    {
      send_to_char("I see no one by that name here!\r\n", ch);
a3715 4
  }
  
   if (GET_CLASS(ch) == CLASS_ANTI_PALADIN && !attack_ok(ch, vict, TRUE))
     return;
d3717 17
a3733 12
   /* Make sure we haven't already used it for the day */
  if (SKILL_DELAY(ch, SKILL_LAY_HANDS)) 
  {
    send_to_char("You need more rest before laying hands again.\r\n", ch);
    return;
  } 

  if (GET_CLASS(ch) == CLASS_PALADIN) 
  {
    if (!vict) 
    {
      vict = ch; 
d3735 5
a3739 5

    if (!IS_GOOD(ch)) 
    {
	send_to_char("For your evil ways, your god has forsaken you!\r\n",ch);
	return;
d3742 6
a3747 64
    if (IS_NPC(vict)) 
    {
      /* Paladin harms undead and evil mobs */
      if (GET_SPECIES(vict) == SPECIES_UNDEAD) 
      {
	/* Check for peaced rooms */
        if (!attack_ok(ch, vict, TRUE))
          return;
	harm_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(50,150));
	sprintf(tch, "You thrust your &7&bglowing&0 hands into $N, causing lots of pain!");
	sprintf(tnv, "$n slaps $s &7&bglowing&0 hands into $N, causing lots of pain!");
	sprintf(tcv, "$N thrusts $S &7&bglowing&0 hands into YOU, causing lots of pain!");
	has_damage = TRUE;
      }/* End NPC Undead */ 
      else 
      {
	/* Paladin heals good mobs */
	if(IS_GOOD(vict)||IS_NEUTRAL(vict)) 
	{
	  healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	  sprintf(tch, "Your hands &7&bglow&0 as you lay them on $N.");
	  sprintf(tnv, "The hands of $n &7&bglow&0 as $e lays them on $N.");
	  sprintf(tcv, "The hands of $n &7&bglow&0 as $e lays them on YOU!");
	  has_damage = FALSE;
	} /* End NPC Good */
	else 
	{
	  /* Check for peaced rooms */
          if (!attack_ok(ch, vict, TRUE))
            return;

	  harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	  sprintf(tch, "You thrust your &7&bglowing&0 hands into $N, causing lots of pain!");
	  sprintf(tnv, "$n slaps $s &7&bglowing&0 hands into $N, causing lots of pain!");
	  sprintf(tcv, "$n slaps $s &7&bglowing&0 hands into YOU, causing lots of pain!");
	  has_damage = TRUE;
	}/* End NPC Evil */
      } /* End NPC !Undead */
    }/* End NPC if */
    else 
    {
      if (vict != ch) 
      {
	healing_to_victim = GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(1,75);
	sprintf(tch, "Your hands &7&bglow&0 as you lay them on $N.");
  	sprintf(tnv, "The hands of $n &7&bglow&0 as $e lays them on $N.");
  	sprintf(tcv, "The hands of $n &7&bglow&0 as $e lays them on YOU!");
	has_damage = FALSE;
      } /* End PC !self */
      else 
      {
        healing_to_victim = GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(1,75);
	sprintf(tch, "Your hands &7&bglow&0 as you lay them on your wounds.");
	sprintf(tnv, "$n's hands &7&bglow&0 as $e lays them on $Mself.");
	has_damage = FALSE;
      } /* End PC Self */
    } /* End PC if */
  }/* End Paladin  Check*/
  else 
  {
    if (!IS_EVIL(ch)) 
    {
      send_to_char("For your benevolent ways, your god has forsaken you!\r\n",ch);
	return;
d3749 4
a3752 57

    if (IS_NPC(vict))
    {
      if (IS_EVIL(vict) && (GET_SPECIES(vict) != SPECIES_UNDEAD) ) 
      {
	send_to_char("Your harmful touch has no affect on other evils.\r\n",ch);
	return;
      } /* End Evil Check*/

      /* Anti CAN heal undead, because we all know harming cures undead!- RLS 20060427 */
      if (GET_SPECIES(vict) == SPECIES_UNDEAD) 
      {
	healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	sprintf(tch, "Your hands &1&bglow&0 as you lay them on $N.");
	sprintf(tnv, "The hands of $n &1&bglow&0 as $e lays them on $N.");
	sprintf(tcv, "The hands of $n &1&bglow&0 as $e lays them on YOU!");
        has_damage = FALSE;
      } /* End Undead Check*/
      else /* Harm everyone else not evil! */
      {
        if (!attack_ok(ch, vict, TRUE))
          return;

	harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	sprintf(tch, "You thrust your &1&bglowing&0 hands into $N, causing lots of pain!");
	sprintf(tnv, "$n slaps $s &1&bglowing&0 hands into $N, causing lots of pain!");
	sprintf(tcv, "$n slaps $s &1&bglowing&0 hands into YOU, causing lots of pain!");
	has_damage = TRUE;
      } 
    } /* End NPC Checks */
    else
    {
      if (IS_EVIL(vict)) 
      {
	send_to_char("Your harmful touch has no affect on other evil players!",ch);
	return;
      }

      if (!attack_ok(ch, vict, TRUE))
        return;

      harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
      sprintf(tch, "You thrust your &1&bglowing&0 hands into $N, causing lots of pain!");
      sprintf(tnv, "$n slaps $s &1&bglowing&0 hands into $N, causing lots of pain!");
      sprintf(tcv, "$n slaps $s &1&bglowing&0 hands into YOU, causing lots of pain!");
      has_damage = TRUE;
    } /* End PC Checks */
  } /* End Anti-Pali Checks */
 
  if (damage_amounts)
  {
    if (has_damage)
    {
      sprintf(dam, " (&1&b%d&0)", harm_to_victim);
      strcat(tch, dam);
      strcat(tnv, dam);
      strcat(tcv, dam);
d3754 6
a3759 6
    else
    {
      sprintf(dam, " (&3%d&0)", healing_to_victim);
      strcat(tch, dam);
      strcat(tnv, dam);
      strcat(tcv, dam);
d3763 9
a3771 10
  if (vict != ch) 
  {
    act(tch, FALSE, ch, NULL, vict, TO_CHAR);
    act(tcv, FALSE, ch, NULL, vict, TO_VICT);
    act(tnv, FALSE, ch, NULL, vict, TO_NOTVICT);
  }
  else 
  {
    act(tch, FALSE, ch, NULL, vict, TO_CHAR);
    act(tnv, FALSE, ch, NULL, vict, TO_NOTVICT);
d3773 2
d3776 2
a3777 5
  if (healing_to_victim) 
  { alter_hit(vict, -healing_to_victim, 1); }

  if (harm_to_victim) 
  { 
d3779 4
a3782 4
    if(!GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD) &&
            !GET_EQ(vict, WEAR_WIELD) && !GET_EQ(vict, WEAR_2HWIELD)) {
      if (IS_AFFECTED3(ch, AFF3_VAMP_TOUCH))
        alter_hit(ch, -harm_to_victim, 2);
d3784 1
a3784 1
        alter_hit(ch, -harm_to_victim / 2, 2);
d3786 11
a3796 3

    GET_HIT(vict) -= harm_to_victim;
    damage(ch, vict, 0, SKILL_LAY_HANDS); 
d3799 1
a3799 4
  if (harm_to_char) 
  { alter_hit(ch, harm_to_char, 2); }

  update_pos(vict);
d4408 3
@


1.157
log
@check_pk is now attack_ok, and covers many more cases than before,
including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
offensive attacks now use attack_ok to determine whether an attack is
allowed.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.156 2007/07/18 23:07:10 jps Exp myc $
d623 1
a623 1
    send_to_char("You have no idea how to do that!", ch);
d869 1
a869 1
    send_to_char("There is a problem with the target room!", ch);
d1251 1
a1251 1
    send_to_char("Bind who?", ch);
d1324 1
a1324 1
    send_to_char("Huh?!?", ch);
d4520 6
@


1.156
log
@do_consent will inform you when you're trying to consent the person
you've already consented, rather than un-consenting and reconsenting.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.155 2007/07/18 16:50:09 jps Exp jps $
a37 1
extern int pk_allowed; /* see Config.c */
d1319 5
a1323 4
   if (CASTING(ch)) {
    send_to_char("You abort your spell!\r\n", ch);
    STOP_CASTING(ch);
  }else
a1438 1
   extern int pk_allowed;
d1466 1
a1466 15
   if (!IS_NPC(ch) && !pk_allowed && !IS_NPC(vict)) {
      send_to_char("You can't steal from another player.\r\n", ch);
      return;
   }

   /* check for shapechanged players */
   if (!IS_NPC(ch) && !pk_allowed && vict->desc &&
      vict->desc->original && GET_LEVEL(vict->desc->original) < 100) {
      send_to_char("You can't steal from another player.\r\n", ch);
      return;
   }

   /* check for shapechanged players */
   if (!IS_NPC(vict) && !pk_allowed && ch->desc &&
         ch->desc->original && GET_LEVEL(ch->desc->original) < 100) {
d3723 2
a3724 15
   /*checks for pk --modified by Pergus 7/14/2002 */
   if(!IS_NPC(vict) && !pk_allowed && GET_CLASS(ch) == CLASS_ANTI_PALADIN) 
   {
      send_to_char("You cannot lay hands on another player!\r\n",ch);
      return;
   }

   /* check for shapechanged players */
   if(!IS_NPC(ch) && vict->desc && vict->desc->original 
    && GET_LEVEL(vict->desc->original) < 100 
    && !pk_allowed && GET_CLASS(ch) == CLASS_ANTI_PALADIN)
   {
      send_to_char("You cannot lay hands on another player!\r\n", ch);
      return;
   }
d3749 1
a3749 1
      if (GET_SPECIES(vict) == 12) 
d3752 2
a3753 5
	if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
	{
	  send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	  return;
	}
d3774 2
a3775 5
	  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
	  {
	    send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	    return;
	  }
d3814 1
a3814 1
      if (IS_EVIL(vict) && (GET_SPECIES(vict) != 12) ) 
d3821 1
a3821 1
      if (GET_SPECIES(vict) == 12) 
d3831 2
a3832 6
	/* Check for peaced rooms */
	if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
	{
	  send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	  return;
	}
d3849 2
a3850 6
      /* Check for peaced rooms */
      if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
      {
	send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	return;
      }
d3945 1
a3945 1
		if (GET_SPECIES(vict) == 12) {
d4520 4
@


1.155
log
@Oops... forgot to free the event when someone camped, then
mounted something, then was stopped from camping. Ok, fixed.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.154 2007/07/14 02:16:22 jps Exp jps $
d2260 2
d4562 4
@


1.154
log
@Make certain that the level of a summoned mount is low enough
that the summoner may easily ride it.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.153 2007/07/14 00:37:56 jps Exp jps $
d1136 2
d4560 4
@


1.153
log
@Make characters save after changing their title.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.152 2007/07/14 00:05:49 jps Exp jps $
d3638 1
d3662 2
d4558 3
@


1.152
log
@Allow grouping of your pets.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.151 2007/07/02 04:58:22 jps Exp jps $
d1709 1
d4555 3
@


1.151
log
@Stop counting items in inventory at the *end* of the camp event.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.150 2007/07/02 04:55:03 jps Exp jps $
d2347 9
a2355 9
  struct char_data *newgroupee = NULL;
  void stop_groupee(struct char_data *ch, bool hide);
  void add_groupee(struct char_data *ch, struct char_data *leader, bool noisy);
  void die_groupee(struct char_data * ch);
  bool all = 0;
  int found = 0;
  int foundbad = 0; 
  struct follow_type *f;	
  int level_diff; 
d2357 1
a2357 2
  one_argument(argument, buf);
  
d2359 1
a2359 2
  if (!*buf) /*(no argument with it, just asking for group info)*/
    {
d2362 3
a2364 3
    }
  else if (GET_POS(ch) < POS_RESTING) /*(only info while sleeping, not actual grouping)*/
    {
d2367 1
a2367 42
    }
  else
    {	
      /*check for all command*/
      if (!str_cmp("all", buf))
	{
	  all = 1;
	}
      else if (!(newgroupee = get_char_room_vis(ch, buf))) 
	{
	  send_to_char(NOPERSON, ch);
	  return;
	}
      /*see if ch in group or if he createing one*/
      
    } 
  
  
  if (ch->groupmaster) /*cant enrol a group member if you are in a group!! and not boss*/
    {
      if (ch != newgroupee)
	{
	  act("You can not enroll group members without being head of a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if (all) 
    {
      for (found = 0, f = ch->followers; f; f = f->next)
	{
	  if ((f->follower->groupmaster) && (f->follower->groupmaster != ch))
	    continue;
	  if ((!f->follower->groupmaster) && (IS_AFFECTED(f->follower, AFF_GROUP)))
	    continue;
	  if (IS_AFFECTED(f->follower, AFF_GROUP))
	    continue;
	  if ((CONSENT(f->follower) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
	    if (!(IS_NPC(f->follower) && (f->follower->master == ch)))
	      continue;
	  
	  level_diff = GET_LEVEL(f->follower) - GET_LEVEL(ch); 
d2369 7
a2375 15
	  if (max_group_difference && (level_diff > max_group_difference ||
			     level_diff < -max_group_difference)) {
	    char mgd_buf[1024]; 

	    snprintf(mgd_buf, 1024, "You cannot group %s because the level difference is to great (maximum of %i)\r\n", GET_NAME(f->follower), max_group_difference); 
	    send_to_char(mgd_buf, ch); 
	    foundbad++; 
	  }
	  else
	    {
	      
	      add_groupee(f->follower, ch, 1);
	      found++;
	    };
	}
d2377 1
d2379 5
a2383 2
      if (!found && !foundbad) {
	  send_to_char("Everyone following you is already in your group.\r\n", ch);
d2385 1
a2385 1
      else if (foundbad) {
d2387 26
d2414 6
a2419 2
      else
	SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
d2421 3
a2423 9
    }
  /* added by gurlaek to stop those funny guys typing group demon 2x */
  /* and crashing the mud. */
  if(IS_NPC(newgroupee) && CONSENT(newgroupee) != ch) {
    send_to_char("Yeah, you wish!\r\n", ch);
    return;
  }
  if ((ch == newgroupee) && (!(IS_AFFECTED(ch, AFF_GROUP))))
    {
d2426 20
a2445 22
    }
  
  if ((newgroupee->groupmaster) && (newgroupee->groupmaster != ch))/*if person inanother group inform him*/
    {
      if (ch != newgroupee)
	{
	  act("That person is already in a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if ((!newgroupee->groupmaster) && (IS_AFFECTED(newgroupee, AFF_GROUP)))
    {
      if (ch != newgroupee)
	{
	  act("That person is leading a group.",
	      FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
    }
  if (ch->groupmaster == newgroupee) 
    {
d2448 4
a2451 4
    }
  
  if (ch == newgroupee)
    {
d2455 1
a2455 4
    }
  /*remove yourself from group*/
  
  /*last chance removeal of grouping people who are already in a group*/
d2457 1
d2459 2
a2460 2
  if (newgroupee->groupmaster == ch) 
    {/*remove him from group then*/
d2462 1
a2462 1
	  newgroupee, TO_CHAR);
d2464 1
a2464 1
	  newgroupee, TO_VICT);
d2466 1
a2466 1
	  TO_NOTVICT);	
d2469 13
a2481 16
    } 
  
  /*handle followers that are npc's*/
  /*handle it within the concent handle*/
  
  
  if ((CONSENT(newgroupee) != ch) && (GET_LEVEL(ch) < LVL_IMMORT))
    {
      if (!(IS_NPC(newgroupee) && (newgroupee->master == ch)))/*created follower*/
	{
     act("You do not have $S consent.", TRUE, ch, NULL, newgroupee, TO_CHAR);
	  return;
	}
    }
  if (IS_AFFECTED(newgroupee, AFF_GROUP))
    {	
d2484 1
a2484 1
    }
d2486 1
a2486 1
  level_diff = GET_LEVEL(ch) - GET_LEVEL(newgroupee); 
d2488 10
a2497 10
  if (max_group_difference && (level_diff > max_group_difference ||
			       level_diff < -max_group_difference)) {
    char mgd_buf[1024]; 
    
    snprintf(mgd_buf, 1024, "You cannot group %s, because the level "
	     "difference is too great.  (Max allowable is currently %i).\r\n", 
	     GET_NAME(newgroupee), max_group_difference); 
    send_to_char(mgd_buf, ch); 
    return; 
  };
d2499 2
a2500 3
  SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
  add_groupee(newgroupee, ch, 1);/*adds flag*/
  
d4554 3
@


1.150
log
@Made the steal skill only improve when the victim is awake.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.149 2007/06/25 06:23:08 jps Exp jps $
a1115 2
  struct obj_data *carrying;
  int count=0;
a1152 13
  carrying = ch->carrying;
  while (carrying)
  {
	  carrying = carrying->next_content;
	  count++;
  }
  if(count > 50)
  {
    act("You can't camp with more than 50 items!\r\n",FALSE,ch,NULL,NULL,TO_CHAR);
    free(event_obj);
    GET_ACTION(ch)=NULL;
    return 0;
  }
d4585 3
@


1.149
log
@Prevent camping while mounted.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.148 2007/06/24 01:16:55 jps Exp jps $
a1513 2
      /*a bug if player is blind he safe from steal*/
      /*if (!(obj = get_obj_in_list_vis(vict, obj_name, vict->carrying))) { */
a1542 1
                  improve_skill(ch, SKILL_STEAL);
d1564 2
a1565 1
                     improve_skill(ch, SKILL_STEAL);
d1642 2
a1643 1
            improve_skill(ch, SKILL_STEAL);
d4600 3
@


1.148
log
@Add spaces to the end of the predetermined prompts, now that the code
doesn't automatically add one.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.147 2007/06/03 03:28:21 jps Exp jps $
d1044 4
d1137 4
a1140 2
  /* changed this to IS_FIGHTING --gurlaek */
  /*  if (GET_POS(ch) == POS_FIGHTING) {*/
d1168 1
a1168 1
  
d1180 1
a1180 1
  act("You complete your campsite, and leave this world for awhile.", FALSE,
d4601 4
@


1.147
log
@Fixed typo in "first aid".
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.146 2007/05/28 07:03:17 jps Exp jps $
d3041 1
a3041 1
    { "Basic"		 , "&0%hhp %vmv>&0"
d3043 1
a3043 1
    { "Colorized Basic"  , "&1&b%h&0&1hp &2&b%v&0&2mv&0>"
d3045 1
a3045 1
    { "Standard"	 , "&1&b%ph&0&1hp &2&b%pv&0&2mv&0>"
d3047 1
a3047 1
    { "Full Featured"		 ,
d3049 1
a3049 1
      "hitp &2%v&0(&2&b%V&0)&7move&0>"
d3052 1
a3052 1
      "&2&b<&0&2%hh&0(&2&b%HH&0) &2%vv&0(&2&b%VV&0)&2&b>%_&0<%t&0>:<&0%o&0>"    },
d4595 3
@


1.146
log
@Cause prompt-set feedback to escape color codes.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.145 2007/05/28 05:38:25 jps Exp jps $
d4104 1
a4104 1
    send_to_char("You can only do this once per day..\n\r", ch);
d4595 3
@


1.145
log
@Setting up camp sends message to the room.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.144 2007/04/25 08:04:41 jps Exp jps $
a3114 2
  /* CREATE is automagically performed by str_dup... memory leak! */
  /*  CREATE(GET_PROMPT(ch), char, strlen(argument) + 1);*/
d3117 1
a3117 2
  sprintf(buf, "Okay, set your prompt to: %s\r\n", argument);
  /*sprintf(buf, "Okay, set your prompt to: %s\r\n", GET_PROMPT(ch));*/
d4595 3
@


1.144
log
@Tell little rogues they'll need more experience to sneak.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.143 2007/04/25 07:53:01 jps Exp jps $
a1012 2
  struct obj_data *carrying;
  int count=0;
d1018 1
a1018 3
  
  /* No crashes from funny guys ordering pets to camp...Banyal*/
  
a1020 12
  carrying = ch->carrying;
  while (carrying)
  {
	  carrying = carrying->next_content;
	  count++;
  }
  if(count > 50)
  {
    sprintf(buf,"You can't camp with more than 50 items and you have %d!\r\n",count);
    send_to_char(buf,ch);
    return;
  }
d1022 1
a1022 1
  /*Lets restrict where we can camp i.e. no city water indoors...banyal*/
d1050 1
a1050 1
    send_to_char("Its hard to set your tent up while dieing...\r\n", ch);
d1061 1
d4598 3
@


1.143
log
@Allow 'visible' to properly terminate hiding.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.142 2007/04/19 00:53:54 jps Exp jps $
d1361 4
a1364 1
    send_to_char("You'd better leave that art to the rogues.\r\n", ch);
d4613 3
@


1.142
log
@Create macros for stopping spellcasting.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.141 2007/04/18 00:32:01 myc Exp jps $
d1696 12
a1707 12
  void perform_immort_vis(struct char_data *ch);
  
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    perform_immort_vis(ch);
    return;
  }
  
  if IS_AFFECTED(ch, AFF_INVISIBLE) {
    appear(ch);
    send_to_char("You break the spell of invisibility.\r\n", ch);
  } else
    send_to_char("You are already visible.\r\n", ch);
d4610 3
@


1.141
log
@Camping now removes the meditate flag to prevent syserrs when chars
log back on.  Also, changed the way first aid rolls dice to save some
clock cycles - the average values are still the same.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.140 2007/04/18 00:18:48 myc Exp myc $
d1342 1
a1342 1
  if(PLR_FLAGGED(ch, PLR_CASTING)){
d1344 1
a1344 1
    REMOVE_BIT(PLR_FLAGS(ch), PLR_CASTING);
d4610 5
@


1.140
log
@Rewrote 'subclass' command to hopefully be less buggy.  It at least has
better messages now.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.139 2007/04/18 00:05:59 myc Exp myc $
d1180 8
d4126 1
a4126 1
    GET_HIT(ch) += dice(GET_LEVEL(ch), 5);
d4610 4
@


1.139
log
@Prompt parser has been totally rewritten so it won't print garbage
characters anymore.  Also, some new features were added.  Giving the
prompt command back to mortals.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.138 2007/04/11 14:24:00 jps Exp myc $
d156 104
a259 19
	int rem_spell(struct char_data *ch, int spell);
	struct mem_list *memorized,*lastmem ;
	struct quest_list *qlist;
	int destclass,arrayref=-1;
	float oldpct;
	extern int class_ok_race[NUM_RACES][NUM_CLASSES];
	extern char *pc_class_types[];
	int * subclass_allowed;
	int max_subclasses;

	/* if class > base classes then bail*/
	if (GET_CLASS(ch) != CLASS_WARRIOR &&
			GET_CLASS(ch) != CLASS_ROGUE &&
			GET_CLASS(ch) != CLASS_CLERIC &&
			GET_CLASS(ch) != CLASS_MAGIC_USER)
	{
		send_to_char("You can only subclass once!\r\n",ch);
		return;
	}
d261 28
a288 49
	/* if ch->lev < min quest lev, message and return */
	if (GET_LEVEL(ch) < 10)
	{
		send_to_char("Go kill some more bugs, you are not skilled enough to subclass yet!\r\n",ch);
		return ;
	}
	/* if ch->lev > max quest lev, message and return */
	if ((GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_WARRIOR) ||
			(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_MAGIC_USER) ||
			(GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_ROGUE) ||
			(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_CLERIC))
	{
		send_to_char("You are too experienced to subclass now!\r\n",ch);
		return;
	}
	/* if ch->lev within quest range but not on quest, avail classes and return*/
	if (!ch->quests)
	{
		send_to_char("You may choose from the following classes for your race:\r\n",ch);
		switch(GET_CLASS(ch))
		{
			case CLASS_WARRIOR:	subclass_allowed = warrior_subclasses;
						max_subclasses = WARRIOR_SUBCLASSES;
						break;
			case CLASS_CLERIC:	subclass_allowed = cleric_subclasses;
						max_subclasses = CLERIC_SUBCLASSES;
						break;
						/* this is very confusing: dunno who named all the subclass
						 * stuff roguish when the base class is thief :-(
						 */
			case CLASS_ROGUE:	subclass_allowed = rogue_subclasses;
						max_subclasses = ROGUE_SUBCLASSES;
						break;
			case CLASS_MAGIC_USER:	subclass_allowed = mage_subclasses;
						max_subclasses = MAGE_SUBCLASSES;
						break;
			default:        	mudlog ("Bad value for character class in do_subclass",NRM,LVL_GOD,FALSE);
						break;
		}
		for (destclass = 0; destclass < max_subclasses; destclass++)
		{
			if (class_ok_race[(int)GET_RACE(ch)][(subclass_allowed[destclass])])
			{
				sprintf(buf,"%s\r\n",pc_class_types[(subclass_allowed[destclass])]);
				send_to_char(buf,ch);
			}
		}
		return;
	}
d290 4
a293 6
	qlist = ch->quests;
	/* only one subclass quest allowed so just search for first*/
	while (qlist && !(qlist->quest_id & SUBCLASS_BIT))
		qlist = qlist->next;
	if (!qlist)
		return;
d295 8
a302 29
	/* now be sure it has been completed */
	if (qlist->stage == QUEST_SUCCESS)
	{
		/* and finally make sure the class->subclass is possible*/
		destclass =-1;
		arrayref = ((qlist->quest_id & SUBCLASS_MASK) >> ARRAY_LOCN);
		if (arrayref > -1)
		{
			switch (GET_CLASS(ch))
			{
			/*
			 * in a subclass ID, bits 15-13 inclusive are the INDEX to the appropriate
			 * array (this is set in 'quest start' in dg_mobcmd.c)
			 */
				case CLASS_MAGIC_USER:	destclass = mage_subclasses[arrayref];
							break;
				case CLASS_CLERIC:	destclass = cleric_subclasses[arrayref];
							break;
				case CLASS_ROGUE:	destclass = rogue_subclasses[arrayref];
							break;
				case CLASS_WARRIOR:	destclass = warrior_subclasses[arrayref];
							break;
			/*
			 * if we have already subclassed and try this lets just fail quietly
			 */
				default:		destclass = -1 ;
							break;
			}
		}
d304 3
a306 19
		fprintf(stderr,"anding the id %X and the mask %X to get arrayref %X\n",qlist->quest_id,SUBCLASS_MASK,(qlist->quest_id & SUBCLASS_MASK));
		fprintf(stderr,"Incoming class %d, destclass %d\n",GET_CLASS(ch),destclass);
		if (destclass >= 0) /*at the moment 0 is mage, but who knows*/
		{
			/* if we got here, everything should be cushty..lets change class*/
			/* Get leveled percentage */
			oldpct = GET_EXP(ch)/(double)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)));

			/* lose any irrelevant memorized stuff*/
			memorized=ch->spell_list;
			while (memorized)
			{
				lastmem=memorized;
				memorized=memorized->next;
				if (spell_info[lastmem->spell].min_level[destclass] == LVL_IMMORT)
					rem_spell(ch,lastmem->spell);
			}
			/* Change the class */
			GET_CLASS(ch) = destclass;
d308 2
a309 2
			/* Fix the exp */
			GET_EXP(ch) = (long)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) * oldpct);
d311 2
a312 2
			/* Update the skills */
			update_skills(ch);
d314 6
a319 2
			/* This is from old hubis code, I guess it can stay */
			check_regen_rates(ch);
d321 5
a325 5
			send_to_char("You have successfully subclassed!\r\n",ch);
                        sprintf(buf,"%s has subclassed to a %s", GET_NAME(ch), CLASS_FULL(ch));
                        mudlog(buf, BRF, LVL_BUILDER, TRUE);
		}
	}
d327 1
d4602 5
@


1.138
log
@Fix warning about function get_check_money.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.137 2007/04/11 14:15:28 jps Exp jps $
a3074 5
  if (GET_LEVEL(ch) <= 100) {
    send_to_char("Type Display Instead!\r\n\r\nSEE HELP DISPLAY\r\n", ch);
    return;
  }
  
d3079 1
a3079 1
	    (GET_PROMPT(ch) ? strip_ansi(GET_PROMPT(ch)) : "n/a"));
d4572 3
@


1.137
log
@Give money piles proper keywords and make them dissolve when stolen.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.136 2007/04/11 09:57:55 jps Exp jps $
d68 1
d4577 3
@


1.136
log
@Fix formatting of stolen money string.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.135 2007/03/27 04:27:05 myc Exp jps $
d1535 1
d4576 3
@


1.135
log
@Fixed typos in hide, steal, and toggle.  Revamped summon mount to offer
several different mounts based on alignment and level.  Lay hands will
heal an anti-paladin with vamp touch now.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.134 2007/02/04 18:12:31 myc Exp myc $
d1583 1
a1583 1
                  sprintf(coinbuf, "%s%s%d gold", (hascoin && (numcoins > 2)) ? " ," :
d1589 5
a1593 2
                  sprintf(coinbuf, "%s%s%d silver", (hascoin && (numcoins > 2)) ? " ,"
                     : "", (hascoin && (lastcoin == SILVER)) ? " and " : "", silver);
d1598 5
a1602 2
                  sprintf(coinbuf, "%s%s%d copper", (hascoin && (numcoins > 2)) ? ", "
                     : "", (hascoin && (lastcoin == COPPER)) ? " and " : "", copper);
d4575 5
@


1.134
log
@Page length now saves as a part of player specials.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.133 2006/12/08 05:06:58 myc Exp myc $
d58 1
a58 1
void mount_summoning_thing(struct char_data *ch);
d1383 1
a1383 1
    send_to_char("You can not hide in combat...\r\n", ch);
d1521 1
a1521 1
               act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
d3474 1
a3474 1
	  send_to_char("You page length is not valid. Tell a god.\r\n", ch);
a3575 1
      /*  (struct char_data *ch, char *arg, int cmd) */
d3577 1
a3577 1
   /*   int sumtime; */
d3579 16
a3599 1
  one_argument(argument, arg);
d3606 20
a3625 3
  for (fol = ch->followers; fol; fol = fol->next)
    if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
      send_to_char("You already have a mount!\r\n", ch);
d3628 1
a3628 3
  if (GET_LEVEL(ch) < 15) {
    send_to_char("You are not yet deemed worthy of a mount (try gaining some more experience)\r\n", ch);
    return;
d3630 1
a3630 13
  if (!IS_GOOD(ch) && !IS_NPC(ch) && (GET_CLASS(ch) == CLASS_PALADIN)) {
    send_to_char("Not even horses can stand your offensive presence!\r\n", ch);
    return;
  }
  if (!OUTSIDE(ch)) {
    send_to_char("Try again, OUTDOORS THIS TIME!\r\n", ch);
    return;
  }
  if (ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]) {
    send_to_char("You may only summon one mount per week!\r\n", ch);
    return;
  }
  ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT] = (7 * SECS_PER_MUD_DAY) * PASSES_PER_SEC;
d3632 15
a3646 1
  mount_summoning_thing(ch);
d3650 1
a3650 2
void
mount_summoning_thing(struct char_data *ch)
a3652 2
  int factor, mob_num = 0;
  struct follow_type *fol;
d3658 1
a3658 24
  if (!OUTSIDE(ch)) {
    send_to_char("Try again, OUTDOORS THIS TIME!\r\n", ch);
    return;
  }
  if (!IS_GOOD(ch) && !IS_NPC(ch) && (GET_CLASS(ch) == CLASS_PALADIN)) {
    send_to_char("Not even horses can stand your offensive presence!\r\n", ch);
    return;
  }
  for (fol = ch->followers; fol; fol = fol->next)
    if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
      send_to_char("You already have a mount!\r\n", ch);
      return;
    }
  
  switch((int)GET_CLASS(ch))
    {
    case CLASS_PALADIN:
      mob_num = 45;
      break;
    case CLASS_ANTI_PALADIN:
      mob_num = 46;
      break;
    }
  mount = read_mobile(mob_num, VIRTUAL);
d3662 1
d3674 2
a3675 7
  /* now we modify the base mount, based on paladin's level and alignment */
  
  /* factor ranges from 0 to 70 */
  factor = BOUNDED (0, (GET_LEVEL(ch) + abs((GET_ALIGNMENT(ch) / 200)) - dice(1, 10)), 5);

  GET_LEVEL(mount) = factor;
  GET_MAX_HIT(mount) = number(100, 150);
d3677 1
a3677 1
  GET_MAX_MOVE(mount) = 400;
d3944 9
d4082 1
a4082 1
  send_to_char("You attempt to render first aid unto yourself..\n\r", ch);
d4569 3
@


1.133
log
@Removed coins enum from do_steal, now constants in structs.h.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.132 2006/11/27 02:26:45 jps Exp myc $
d3316 1
a3316 1
	      sprintf(buf2,"%d", (ch->page_length));
d3320 1
a3320 1
	      sprintf(buf2,"%d", (ch->page_length));
d3324 1
a3324 1
	      sprintf(buf2,"%d", (ch->page_length));
d3469 2
a3470 2
	if (ch->page_length) {
	  sprintf(buf, "Your current page length is %d.\r\n", (ch->page_length));
d3487 1
a3487 1
	    ch->page_length = page_length;
d3492 1
a3492 1
	  ch->page_length = 22;
d4559 3
@


1.132
log
@Let people see consent messages even when asleep.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.131 2006/11/27 02:18:42 jps Exp jps $
d1422 1
a1422 1
   enum { PLAT, GOLD, SILVER, COPPER } lastcoin;
d4559 3
@


1.131
log
@Let imms camp in air rooms.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.130 2006/11/21 20:53:52 jps Exp jps $
d2200 17
a2216 23
  struct char_data *target;
  one_argument(argument, buf);
  if (!*buf) 
    {
      if (!CONSENT(ch))
	{
	  send_to_char("Consent?? you are not consented to anyone!\r\n", ch);
	  return;
	}
      else
	{
	  if (CAN_SEE(ch, CONSENT(ch))) 
	    {
	      act("&0&7&b$n has revoked $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT);
	    }
	  send_to_char("&0&7&bYou revoke your consent.&0\r\n", ch);
	  CONSENT(ch) = NULL;
	  return;
	}
    }
  
  if (!(target = get_char_vis(ch, buf))) 
    {
d2219 3
a2221 4
    }
  
  if (target == ch)
    {
d2224 3
a2226 4
    }
  /*ok concent this person*/
  if ((!CONSENT(ch)))
    {
d2228 7
a2234 11
      if (CONSENT(ch) == target)
	{
	  act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
	  act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT);
	}
      else
	send_to_char("You may not consent that person.\r\n", ch);
    }
  else
    {
      act("&0&7&b$n has removed $s consent.&0", FALSE, ch, 0, CONSENT(ch), TO_VICT);
d2236 6
a2241 9
      if (CONSENT(ch) == target)
	{
	  act("&0&7&bYou give your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
	  act("&0&7&b$n has given you $s consent.&0", FALSE, ch, 0, target, TO_VICT);
	}
      else
	send_to_char("You may not consent that person.\r\n", ch);
    }
  
d4559 3
@


1.130
log
@Align values in group printout
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.129 2006/11/20 22:24:17 jps Exp jps $
d1024 4
a1029 4
  if (SECT(ch->in_room) == SECT_FLYING) {
    send_to_char("&7You can't camp in mid-air.&0\r\n", ch);
    return;
  }
d4574 3
@


1.129
log
@End the difficulties in interaction between evil and good player races.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.128 2006/11/18 06:41:16 jps Exp jps $
d1701 41
d1745 15
a1759 9
  struct char_data *k;
  struct group_type *f;
  char harm_color[20];
  int perc = 100;
  if (!IS_AFFECTED(ch, AFF_GROUP))
    send_to_char("&0&2&bBut you are not the member of a group!&0\r\n", ch);
  else {
    sprintf(buf, "%s&0&7&bYour group consists of:&0\r\n", CCUND(ch,C_NRM));
    send_to_char(buf, ch);
d1761 7
a1767 25
    k = (ch->groupmaster ? ch->groupmaster : ch);
    if (CAN_SEE(ch,k)) {
      if (IS_AFFECTED(k, AFF_GROUP)) {
        perc = (100*GET_HIT(k)/GET_MAX_HIT(k));
        sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(k,C_NRM) : CCBBLK(ch,C_NRM)),
	        (perc >= 100 ? CCNRM(ch, C_NRM) :
	         perc >= 88 ? CCNRM(ch,C_NRM) :
	         perc >= 70 ? CCBLD(ch,C_NRM) :
                perc >= 45 ? CCNRM(ch,C_NRM) :
	         perc >= 20 ? CCNRM(ch,C_NRM) :
	         perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
	        (perc >= 100 ? CCNRM(ch, C_NRM) :
	         perc >= 88 ? CCYEL(ch,C_SPR) :
	         perc >= 70 ? CCYEL(ch, C_NRM) :
	         perc >= 45 ? CCMAG(ch, C_NRM) :
	         perc >= 20 ? CCRED(ch, C_NRM) :
	         perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));
      
      
      
        sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dv/%3dV] [%s] (&0&2&bHead of group&0)\r\n", 
	        harm_color,
	        GET_NAME(k), harm_color,
	        GET_HIT(k), CCUND(k,C_NRM), GET_MAX_HIT(k), GET_MOVE(k), GET_MAX_MOVE(k), CLASS_ABBR(k));
          send_to_char(buf, ch);
d1769 1
a1769 30
    }
    
    for (f = k->groupees; f; f = f->next) {
      if (!IS_AFFECTED(f->groupee, AFF_GROUP) || !CAN_SEE(ch,f->groupee))
	continue;
      
      perc = (100*GET_HIT(f->groupee)/GET_MAX_HIT(f->groupee));
      sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(ch,C_NRM) : CCBBLK(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCNRM(ch,C_NRM) :
	       perc >= 70 ? CCBLD(ch,C_NRM) :
	       perc >= 45 ? CCNRM(ch,C_NRM) :
	       perc >= 20 ? CCNRM(ch,C_NRM) :
	       perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCYEL(ch,C_SPR) :
	       perc >= 70 ? CCYEL(ch, C_NRM) :
	       perc >= 45 ? CCMAG(ch, C_NRM) :
	       perc >= 20 ? CCRED(ch, C_NRM) :
	       perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));
      
      
      
      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dv/%3dV] [%s]\r\n", 
	      harm_color,
	      GET_NAME(f->groupee), harm_color,
	      GET_HIT(f->groupee), CCUND(f->groupee,C_NRM), GET_MAX_HIT(f->groupee), GET_MOVE(f->groupee), GET_MAX_MOVE(f->groupee), CLASS_ABBR(f->groupee));
        send_to_char(buf, ch);
    }
  }
d4574 3
@


1.128
log
@Fixed typos when toggling anonymous.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.127 2006/11/16 18:42:45 jps Exp jps $
a2110 9
  
  /* if (GET_RACE_ALIGN(newmgroupee) != GET_RACE_ALIGN(ch))
    {*/      /*cant enroll someone of the other race align*/
    /*  act("You can't enroll someone of that race align.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    REMOVED TO ALLOW EVIL/GOOD TO GROUP*/

a2225 6
  if (GET_LEVEL(ch) < LVL_IMMORT)
    /* if (GET_RACE_ALIGN(target) != GET_RACE_ALIGN(ch))
      {*//*cant enrol someone of the other race align*/
	/* send_to_char(NOPERSON, ch);
	return; */
     /* } REMOVED TO ALLOW EVIL/GOOD GROUPING*/
a2396 2
	  if (((GET_RACE_ALIGN(f->follower) != GET_RACE_ALIGN(ch))) && (!IS_NPC(f->follower)))
	    continue;
a2441 7
  /*if ((GET_RACE_ALIGN(newgroupee) != GET_RACE_ALIGN(ch)) && (GET_LEVEL(ch) < LVL_IMMORT))
    {*//*cant enrol someone of the other race align*/
      /*act("You can't enrol someone of that race align.",
	  FALSE, ch, 0, 0, TO_CHAR);
      return;
    } REMOVED TO ALLOW GOOD/EVIL GROUPS*/

a2621 2
    else if (GET_RACE_ALIGN(ch) != GET_RACE_ALIGN(vict))
      send_to_char(NOPERSON, ch);    
d4574 3
@


1.127
log
@Awareness of new surroundings when magically tranported is related to
being asleep, blindness, etc.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.126 2006/11/14 21:30:44 jps Exp jps $
d3297 2
a3298 2
		/*17*/  {"You are no longer Anonymous\r\n",
			 "You are now Anonymous\r\n"},
d4600 4
@


1.126
log
@Stop invis'd gods from being seen by lower level imms as they camp
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.125 2006/11/13 16:34:43 jps Exp jps $
d67 1
d1053 1
d1074 1
d1082 1
a1082 1
  look_at_room(ch,0);
d4600 3
@


1.125
log
@You can't steal items over your level any more.
Blind mobs are no longer immune from stealing.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.124 2006/11/12 02:31:01 jps Exp jps $
d1152 2
a1153 1
  mudlog(buf, NRM, LVL_GOD, TRUE);
d4597 4
@


1.124
log
@You become unmounted when magically moved to another room.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.123 2006/11/08 08:34:03 jps Exp jps $
d1410 31
a1440 21
  struct char_data *vict;
  struct obj_data *obj;
  char vict_name[MAX_INPUT_LENGTH], obj_name[MAX_INPUT_LENGTH];
  int percent, eq_pos,  ohoh = 0;
  int copper, silver, gold, plat;
  extern int pk_allowed;
  char coinbuf[20];
  int hascoin = 0, numcoins = 0;
  enum { PLAT, GOLD, SILVER, COPPER } lastcoin;
  
  
  ACMD(do_gen_comm);
  
  if (IS_FIGHTING(ch)) {
    send_to_char("You can't steal while you are fighting!\n\r",ch);
    return;
  }
  if (GET_SKILL(ch, SKILL_STEAL) <= 0) {
    send_to_char("You don't know how to steal!\r\n", ch);
    return;
  }
d1442 5
a1446 10
  argument = one_argument(argument, obj_name);
  one_argument(argument, vict_name);
  
  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("Steal what from who?\r\n", ch);
    return;
  } else if (vict == ch) {
    send_to_char("Come on now, that's rather stupid!\r\n", ch);
    return;
  }
d1448 2
a1449 7
  /* player-theiving goes off the pk_allowed game flag now. */
  if (!IS_NPC(ch) && !pk_allowed && !IS_NPC(vict)) {
    send_to_char("You can't steal from another player.\r\n", ch);
    return;
  }
  /* check for shapechanged players */
  if (!IS_NPC(ch) && !pk_allowed && vict->desc &&
d1451 38
a1488 9
    send_to_char("You can't steal from another player.\r\n", ch);
    return;
  }
  /* check for shapechanged players */
  if (!IS_NPC(vict) && !pk_allowed && ch->desc &&
      ch->desc->original && GET_LEVEL(ch->desc->original) < 100) {
    send_to_char("You can't steal from another player.\r\n", ch);
    return;
  }
d1490 1
a1490 5
  /* 101% is a complete failure */
  percent = number(1, 101) - dex_app_skill[GET_DEX(ch)].p_pocket;
  
  if (GET_POS(vict) < POS_SLEEPING)
    percent = -1;		/* ALWAYS SUCCESS */
d1492 44
a1535 115
  /* NO NO With Imp's and Shopkeepers, and if player thieving is not allowed  add || pcsteal || after imort to disable player steal 
     banyal */
  if (GET_LEVEL(vict) >= LVL_IMMORT ||
      GET_MOB_SPEC(vict) == shop_keeper)
    percent = 101+50;		/* Failure */
  
  if (str_cmp(obj_name, "coins") && str_cmp(obj_name, "gold")) {
    
    /*a bug if player is blind he safe from steal*/
    if (!(obj = get_obj_in_list_vis(vict, obj_name, vict->carrying))) {
      
      for (eq_pos = 0; eq_pos < NUM_WEARS; eq_pos++)
	if (GET_EQ(vict, eq_pos) &&
	    (isname(obj_name, GET_EQ(vict, eq_pos)->name)) &&
	    CAN_SEE_OBJ(ch, GET_EQ(vict, eq_pos))) {
	  obj = GET_EQ(vict, eq_pos);
	  break;
	}
      if (!obj) {
	act("$E hasn't got that item.", FALSE, ch, 0, vict, TO_CHAR);
	return;
      } else {			/* It is equipment */
	if ((GET_POS(vict) > POS_STUNNED)) {
	  send_to_char("Steal the equipment now?  Impossible!\r\n", ch);
	  return;
	} else {
	  act("You unequip $p and steal it.", FALSE, ch, obj, 0, TO_CHAR);
	  act("$n steals $p from $N.", FALSE, ch, obj, vict, TO_NOTVICT);
	  obj_to_char(unequip_char(vict, eq_pos), ch);
	  improve_skill(ch, SKILL_STEAL);
	}
      }
    } else {			/* obj found in inventory */
      
      percent += GET_OBJ_WEIGHT(obj);	/* Make heavy harder */
      
      if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
	ohoh = TRUE;
	act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
	act("$n tried to steal something from you!", FALSE, ch, 0, vict, TO_VICT);
	act("$n tries to steal something from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      } else {			/* Steal the item */
	if ((IS_CARRYING_N(ch) + 1 < CAN_CARRY_N(ch))) {
	  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) < CAN_CARRY_W(ch)) {
	    obj_from_char(obj);
	    obj_to_char(obj, ch);
	    send_to_char("Got it!\r\n", ch);
	    improve_skill(ch, SKILL_STEAL);
	  }
	} else
	  send_to_char("You cannot carry that much.\r\n", ch);
      }
    }
  } else {			/* Steal some coins */
    if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
      ohoh = TRUE;
      act("Oops..", FALSE, ch, 0, 0, TO_CHAR);
      act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to steal coins from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      improve_skill(ch, SKILL_STEAL);
    } else {
      /* Steal some gold coins */
      /* fixed for 4-coin system by 321 */
      if ((plat = (int) ((GET_PLAT(vict) * number(1, 10)) / 100))) {
	lastcoin = PLAT;
	numcoins++;
      }
      if ((gold = (int) ((GET_GOLD(vict) * number(1, 10)) / 100))) {
	lastcoin = GOLD;
	numcoins++;
      }
      if ((silver = (int) ((GET_SILVER(vict) * number(1, 10)) / 100))) {
	lastcoin = SILVER;
	numcoins++;
      }
      if ((copper = (int) ((GET_COPPER(vict) * number(1, 10)) / 100))) {
	lastcoin = COPPER;
	numcoins++;
      }
      if (copper + silver + gold + plat > 0) {
	GET_COPPER(ch) += copper;
	GET_COPPER(vict) -= copper;
	GET_SILVER(ch) += silver;
	GET_SILVER(vict) -= silver;
	GET_GOLD(ch) += gold;
	GET_GOLD(vict) -= gold;
	GET_PLAT(ch) += plat;
	GET_PLAT(vict) -= plat;
	strcpy(buf, "Woohoo! You stole ");
	if (plat) {
	  sprintf(coinbuf, "%d platinum", plat);
	  strcat(buf, coinbuf);
	  hascoin = 1;
	}
	if (gold) {
	  sprintf(coinbuf, "%s%s%d gold", (hascoin && (numcoins > 2)) ? " ," :
		  "", (hascoin && (lastcoin == GOLD)) ? " and " : "", gold);
	  strcat(buf, coinbuf);
	  hascoin = 1;
	}
	if (silver) {
	  sprintf(coinbuf, "%s%s%d silver", (hascoin && (numcoins > 2)) ? " ,"
		  : "", (hascoin && (lastcoin == SILVER)) ? " and " : "", 
		  silver);
	  strcat(buf, coinbuf);
	  hascoin = 1;
	}
	if (copper) {
	  sprintf(coinbuf, "%s%s%d copper", (hascoin && (numcoins > 2)) ? ", "
		  : "", (hascoin && (lastcoin == COPPER)) ? " and " : "", 
		  copper);
	  strcat(buf, coinbuf);
	}
	strcat(buf, ".\r\n");
	send_to_char(buf, ch);
d1537 65
a1601 1
	send_to_char("You couldn't get any coins...\r\n", ch);
a1602 3
      improve_skill(ch, SKILL_STEAL);
    }
  }
d1604 2
a1605 2
  if (ohoh && IS_NPC(vict) && AWAKE(vict))
    hit(vict, ch, TYPE_UNDEFINED);
d4596 3
@


1.123
log
@Fix gender of pronoun when trying to group someone without consent.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.122 2006/11/08 08:03:47 jps Exp jps $
d66 2
d1073 1
d4581 3
@


1.122
log
@Typo fix "You better leave art to the thieves." ->
"You'd better leave that art to the rogues."
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.121 2006/11/07 09:51:48 jps Exp jps $
d2177 1
a2177 1
      send_to_char("You do not have his consent.\r\n", ch);
d2499 1
a2499 1
	  send_to_char("You do not have his consent.\r\n", ch);
d4578 4
@


1.121
log
@Allow wands and staves held in second hand to be used.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.120 2006/11/07 09:35:38 jps Exp $
d1315 1
a1315 1
    send_to_char("You better leave art to the thieves.\r\n", ch);
d1371 1
a1371 1
    send_to_char("You better leave art to the thieves.\r\n", ch);
d4578 3
@


1.120
log
@Stop sending spurious "You petition, ''" when empty petition sent.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.119 2006/07/20 07:41:07 cjd Exp $
d2931 7
a2937 3
      sprintf(buf2, "You don't seem to be holding %s %s.\r\n", AN(arg), arg);
      send_to_char(buf2, ch);
      return;
d4578 3
@


1.119
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.118 2006/04/28 21:14:02 mud Exp $
d3568 1
d4574 3
@


1.118
log
@Layhands patch, with silent damage so it isn't pulling from
messages file and shorter colorized messages.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.117 2006/04/28 08:37:02 mud Exp $
d1147 1
a1147 1
    act("$n rolls up his bedroll and tunes out the world.", TRUE, ch, 0, 0, TO_ROOM);
d1573 1
a1573 1
		  : "", (hascoin && (lastcoin == COPPER)) ? "and " : "", 
d2000 1
a2000 1
  act("&0&2&b$n has disbanded $s group&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
d2012 1
a2012 1
  send_to_char("&0&2&bYou disband the group&0\r\n", ch);
d2029 1
a2029 1
  sprintf(buf,"&0&1%s has disbanded his major group&0\r\n",
d2043 1
a2043 1
  send_to_char("&0&1You disband the major group&0\r\n", ch);
d2595 1
a2595 1
          sprintf(buf, "%s says, 'I have %d (%d) hit and %d (%d) movement points",
d3853 1
a3853 1
	sprintf(tnv, "$n's hands &7&bglow&0 as $e lays them on $Sself.");
d4071 1
a4071 1
    send_to_char("You are to busy fighting to attend to yourself!\n\r",ch);
d4573 4
@


1.117
log
@Made some quick changes for testing purposes but still can't
seem to find where layhands is going awry. - RLS
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.116 2006/04/28 01:41:12 rls Exp $
a3773 7
   /* Check for peaced rooms */
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
   {
     send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
     return;
   }

d3799 6
a3804 1
	send_to_char("Mob is Undead... paladin harm touch kicking in!\r\n",ch);
d3806 3
a3808 3
	sprintf(tch, "You thrust your glowing white hands into $N, causing lots of pain!");
	sprintf(tnv, "$n slaps $s glowing white hands into $N, causing lots of pain!");
	sprintf(tcv, "$N thrusts $S glowing whitehands into YOU, causing lots of pain!");
d3817 3
a3819 3
	  sprintf(tch, "Your hands glow white as you lay them on $N.");
	  sprintf(tnv, "The hands of $n glow white as $e lays them on $N.");
	  sprintf(tcv, "The hands of $n glow white as $e lays them on YOU!");
d3824 7
d3832 3
a3834 3
	  sprintf(tch, "You thrust your glowing white hands into $N, causing lots of pain!");
	  sprintf(tnv, "$n slaps $s glowing white hands into $N, causing lots of pain!");
	  sprintf(tcv, "$n slaps $s glowing white hands into YOU, causing lots of pain!");
d3844 3
a3846 3
	sprintf(tch, "Your hands glow white as you lay them on $N.");
  	sprintf(tnv, "The hands of $n glow white as $e lays them on $N.");
  	sprintf(tcv, "The hands of $n glow white as $e lays them on YOU!");
d3852 2
a3853 2
	sprintf(tch, "Your hands glow white as you lay them on your wounds.");
	sprintf(tnv, "$n's hands glow white as $e lays them on $Sself.");
a3876 1
	send_to_char("Mob is Undead... anti paladin heal kicking in!\r\n",ch);
d3878 3
a3880 3
	sprintf(tch, "Your hands glow red as you lay them on $N.");
	sprintf(tnv, "The hands of $n glow red as $e lays them on $N.");
	sprintf(tcv, "The hands of $n glow red as $e lays them on YOU!");
d3885 7
d3893 3
a3895 3
	sprintf(tch, "You thrust your red glowing hands into $N, causing lots of pain!");
	sprintf(tnv, "$n slaps $s red glowing hands into $N, causing lots of pain!");
	sprintf(tcv, "$n slaps $s red glowing hands into YOU, causing lots of pain!");
d3907 7
d3915 3
a3917 3
      sprintf(tch, "You thrust your red glowing hands into $N, causing lots of pain!");
      sprintf(tnv, "$n slaps $s red glowing hands into $N, causing lots of pain!");
      sprintf(tcv, "$n slaps $s red glowing hands into YOU, causing lots of pain!");
d3921 2
a3922 3

 /* if (damage_amounts && (damage))*/
  if (has_damage)
d3924 14
a3937 11
    sprintf(dam, " (&1&b%d&0)", harm_to_victim);
    strcat(tch, dam);
    strcat(tnv, dam);
    strcat(tcv, dam);
  }
  else
  {
    sprintf(dam, " (&2%d&0)", healing_to_victim);
    strcat(tch, dam);
    strcat(tnv, dam);
    strcat(tcv, dam);
d3956 4
a3959 1
  { damage(ch, vict, harm_to_victim, SKILL_LAY_HANDS); }
d3965 1
a3965 1
  /*  SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_HOUR * 4; commented out while testing */
d4573 4
@


1.116
log
@Frog!  evil and !undead check for layhands... whee!
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.115 2006/04/28 01:26:58 rls Exp $
d335 1
a335 1
			    /* check the subclass required is valid for the user..though it really should be..*/
d3705 4
a3708 1
  char tch[MAX_STRING_LENGTH], tnv[MAX_STRING_LENGTH], tcv[MAX_STRING_LENGTH], dam[MAX_STRING_LENGTH];
d3719 1
a3719 1
    send_to_char("You can't lay hands!", ch);
d3726 1
a3726 1
    send_to_char("You don't have the ability to lay hands.", ch);
d3743 1
a3743 1
	send_to_char("How about a target this time!",ch); 
d3753 1
a3753 1
      send_to_char("I see no one by that name here!", ch);
d3761 1
a3761 1
      send_to_char("You can not lay hands on another player!",ch);
d3770 1
a3770 1
      send_to_char("You can not lay hands on another player!", ch);
d3774 8
d3784 1
a3784 1
    send_to_char("You need some more rest before laying hand.", ch);
d3797 1
a3797 1
	send_to_char("For your evil ways, your god has forsaken you!",ch);
d3802 3
d3806 11
a3816 2
	/* Paladin harms undead and evil mobs */
	if (GET_SPECIES(vict) == 12) 
d3818 6
a3823 12
  	  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
	  {
	    send_to_char("You feel ashamed for trying to disturb the peace of this room.",ch);
	    return;
	  }
	  
	  harm_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(50,150));
	  sprintf(tch, "You thrust your hands into $N, causing lots of pain!");
	  sprintf(tnv, "$n slaps $m hands into $N, causing lots of pain!");
	  sprintf(tcv, "$N thrusts $S hands into YOU, causing lots of pain!");
	  has_damage = TRUE;
	}/* End NPC Undead */ 
d3826 8
a3833 24
	  /* Paladin heals good mobs */
	  if(IS_GOOD(vict)||IS_NEUTRAL(vict)) 
	  {
	    sprintf(tch, "Your hands glow white as you lay them on $N.");
	    sprintf(tnv, "The hands of $n glow white as $e lays them on $N.");
	    sprintf(tcv, "The hands of $n glow white as $e lays them on YOU!");
	    healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	  } /* End NPC Good */
	  else 
	  {
	    if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
	    {
	      send_to_char("You feel ashamed for trying to disturb the peace of this room.",ch);
	      return;
	    }

	    sprintf(tch, "You thrust your hands into $N, causing lots of pain!");
	    sprintf(tnv, "$n slaps $s hands into $N, causing lots of pain!");
	    sprintf(tcv, "$n slaps $s hands into YOU, causing lots of pain!");
	    harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	    has_damage = TRUE;
	  }/* End NPC Evil */
	}
      }/* End NPC check */
d3842 2
a3843 1
      } 
d3846 1
d3849 4
a3852 4
        healing_to_victim = GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(1,75);
      }
    } 
  }/* End Pally Check*/
a3854 6
   if(!IS_NPC(vict) && !pk_allowed)
   {
        send_to_char("You can not lay hands on another player!",ch);
        return;
    }

d3857 1
a3857 1
	send_to_char("For your benevolent ways, your god has forsaken you!",ch);
d3861 1
a3861 1
    if (IS_EVIL(vict) && (GET_SPECIES(vict) != 12) ) 
d3863 5
a3867 3
      send_to_char("Your evil touch has no affect on other evils.",ch);
      return;
    } /* End Evil Check*/
d3869 20
a3888 2
    /* Anti CAN heal undead, because we all know harming cures undead!- RLS 20060427 */
    if (IS_NPC(vict) && (GET_SPECIES(vict) == 12)) 
d3890 6
a3895 10
      sprintf(tch, "Your hands glow red as you lay them on $N.");
      sprintf(tnv, "The hands of $n glow red as $e lays them on $N.");
      sprintf(tcv, "The hands of $n glow red as $e lays them on YOU!");
      healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
    } /* End Undead Check*/
    else 
    {
      sprintf(tch, "You thrust your hands into $N, causing lots of pain!");
      sprintf(tnv, "$n slaps $s hands into $N, causing lots of pain!");
      sprintf(tcv, "$n slaps $s hands into YOU, causing lots of pain!");
d3897 3
d3901 2
a3902 2
    }
  }
d3907 1
a3907 1
    sprintf(dam, " (&1&b%d&0)\r\n", harm_to_victim);
d3914 1
a3914 1
    sprintf(dam, " (&2%d&0)\r\n", healing_to_victim);
d3942 1
a3942 1
  SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_HOUR * 4;
d4550 3
@


1.115
log
@More todo with layhands.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.114 2006/04/28 00:27:33 rls Exp $
d3864 1
a3864 1
    if (IS_EVIL(vict)) 
d4534 3
@


1.114
log
@Fix to layhands, bad argument checking and added
healing effect for antis laying undead... fun!
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.113 2005/06/16 02:07:07 cjd Exp $
d3878 8
a3885 6
 
    sprintf(tch, "You thrust your hands into $N, causing lots of pain!");
    sprintf(tnv, "$n slaps $s hands into $N, causing lots of pain!");
    sprintf(tcv, "$n slaps $s hands into YOU, causing lots of pain!");
    harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
    has_damage = TRUE;
d4534 4
@


1.113
log
@adjusted the minimum level to subclass from 5 to 10
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.112 2005/06/10 18:07:16 cjd Exp $
d3710 2
d3713 1
a3713 1
  /*no mobs allowed*/
d3716 1
a3716 1
    send_to_char("You can't layhands!\n\r", ch);
d3720 4
a3723 3
  /* check for appropriate class and imm*/
  if ((GET_CLASS(ch) != CLASS_PALADIN) && (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You don't have the ability to layhands.\r\n", ch);
d3727 2
a3728 1
  if(!(*argument)) 
d3740 1
a3740 1
	send_to_char("How about a target this time!\r\n",ch); 
d3746 5
a3750 5
  one_argument(argument, arg);  

  if (*arg) {
    if (!(vict = get_char_room_vis(ch, arg))) {
      send_to_char("I see no one by that name here!\r\n", ch);
d3756 3
a3758 2
   if(!IS_NPC(vict) && !pk_allowed && GET_CLASS(ch) == CLASS_ANTI_PALADIN) {
      send_to_char("You can not layhands on another player!\r\n",ch);
d3763 5
a3767 2
   if(!IS_NPC(ch) && vict->desc && vict->desc->original && GET_LEVEL(vict->desc->original) < 100 && !pk_allowed && GET_CLASS(ch) == CLASS_ANTI_PALADIN){
      send_to_char("You can not layhands on another player!\r\n", ch);
d3771 3
a3773 2
  if (SKILL_DELAY(ch, SKILL_LAY_HANDS)) {
    send_to_char("You need some more rest before laying hand.\r\n", ch);
d3786 1
a3786 1
	send_to_char("You cannot summon the holy powers to achieve this act!\r\n",ch);
d3802 1
a3802 1
	  sprintf(tch, "You thrust your hands into $N, causing serious wounds!");
d3804 1
a3804 1
	  sprintf(tcv, "$N thrusts $S hands into YOU, causing serious wounds!");
d3812 3
a3814 3
	    sprintf(tch, "Your hands glow as you lay them on $N.");
	    sprintf(tnv, "The hands of $n glow as $e lays them on $N.");
	    sprintf(tcv, "The hands of $n glow as $e lays them on YOU!");
d3825 1
a3825 1
	    sprintf(tch, "You thrust your hands into $N, causing serious wounds!");
d3838 3
a3840 3
	sprintf(tch, "Your hands glow as you lay them on $N.");
  	sprintf(tnv, "The hands of $n glow as $e lays them on $N.");
  	sprintf(tcv, "The hands of $n glow as $e lays them on YOU!");
d3844 2
a3845 2
	sprintf(tch, "Your hands glow as you lay them on your wounds.");
	sprintf(tnv, "$n's hands glow as $e lays them on $Sself.");
d3852 3
a3854 2
   if(!IS_NPC(vict) && !pk_allowed){
        send_to_char("You can not layhands on another player!\r\n",ch);
d3860 1
a3860 1
	send_to_char("You cannot summon the evil powers to achieve this act!",ch);
d3870 1
a3870 1
    /* Anti can't heal and can't harm undead or evil, but CAN good! */
d3873 4
a3876 2
      send_to_char("Your evil touch has no affect on the undead.",ch);
      return;
d3879 1
a3879 1
    sprintf(tch, "You thrust your hands into $N, causing serious wounds!");
d4532 3
@


1.112
log
@oops, had to fix a PK check for pally's. also
included a fix for damage amounts shown in the
case of healing.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.111 2005/06/09 21:59:17 cjd Exp $
d173 1
a173 1
	if (GET_LEVEL(ch) < 5)
d4520 5
@


1.111
log
@Fixed error where vict was not being defined before usage
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.110 2005/03/30 18:34:16 rls Exp $
d3746 1
a3746 1
      send_to_char("I see no one by that name here!\n\r", ch);
d3752 1
a3752 1
   if(!IS_NPC(vict) && !pk_allowed) {
d3758 1
a3758 1
   if(!IS_NPC(ch) && vict->desc && vict->desc->original && GET_LEVEL(vict->desc->original) < 100 && !pk_allowed){
d3764 1
a3764 1
    send_to_char("You need some more rest before laying hand.\n\r", ch);
d3777 1
a3777 1
	send_to_char("You cannot summon the holy powers to achieve this act!\n\r",ch);
a3780 3
    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_HOUR * 4; 

    
d3801 1
a3801 1
	  if(IS_GOOD(vict)) 
a3846 1
    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_HOUR * 4; 
d3874 2
a3875 1
  if (damage_amounts && (damage))
d3884 1
a3884 1
    sprintf(dam, "\r\n");
d3892 3
a3894 3
    act(tch, TRUE,ch,0,vict,TO_CHAR);
    act(tnv, TRUE, ch, 0, vict, TO_VICT);
    act(tcv, TRUE, ch, 0, vict, TO_NOTVICT);
d3898 2
a3899 2
    act(tch, TRUE, ch, 0, vict, TO_CHAR);
    act(tnv, TRUE, ch, 0, vict, TO_NOTVICT);
d3912 1
d4520 3
@


1.110
log
@Added missing external declaration for pk_allowed
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.109 2005/03/24 02:54:14 djb Exp $
d3704 1
a3704 1
  struct char_data *vict = NULL;
d3711 1
d3718 3
a3720 3
  if ((GET_CLASS(ch) != CLASS_PALADIN) &&
      (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You don't have the ability to layhands.\n\r", ch);
a3723 14
  /* check for pk --modified by Pergus 7/14/2002 */
   if(!IS_NPC(vict) && !pk_allowed) {
     send_to_char("You can't cut a player's throat!\r\n", ch);
     return;
   }
 
   /* check for shapechanged players */
   if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
      GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
     send_to_char("You can't cut a player's throat!\r\n", ch);
     return;
   }
  
  
d3736 2
a3737 1
	vict = ch; 
d3751 12
d3846 4
d4522 3
@


1.109
log
@Added PK checks for layhands.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.108 2005/02/14 10:17:28 rls Exp djb $
d38 1
d4518 3
@


1.108
log
@Fixed missing damage messages in layhands function, as well
made it to where anti's don't heal anything.  Still needs
to have pk / charmed mobs by PC safeguards in place.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.107 2005/02/14 02:35:29 djb Exp $
d3722 14
d4517 5
@


1.107
log
@Changed the consent/group/mgroup functions to allow for good/evil race groups. Changed layhands around, and added layhands for anti-paladins.
Also added code for a new spell control_undead, but left it commented out for now so that I can finish it up later.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.106 2004/11/15 01:03:37 rsd Exp $
d3704 1
d3707 2
a3708 1
  int harm_to_char = 0; 
d3710 2
a3711 1
  if (IS_NPC(ch)) {
d3722 2
a3723 2

  if(!(*argument)) {
d3726 4
a3729 2
    if (GET_CLASS(ch) == CLASS_ANTI_PALADIN) {
      if (FIGHTING(ch)) {
d3731 3
a3733 1
      } else {
d3753 4
a3756 3
  if (GET_CLASS(ch) == CLASS_PALADIN) {

    if (!vict) {
d3760 2
a3761 1
    if (!IS_GOOD(ch)) {
d3766 1
a3766 1
    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_DAY; 
d3769 8
a3776 4
    if (IS_NPC(vict)) {
	if (GET_SPECIES(vict) == 12) {
	  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
	    send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
d3779 1
a3779 1
           
d3781 22
a3802 18
		  act("You thrust your hands into $N, causing serious wounds!\r", TRUE, ch, 0, vict, TO_CHAR);
		  act("$n slaps $m hands into $N, causing lots of pain!\r", TRUE, ch, 0, vict, TO_ROOM);
	} else {
	    if(IS_GOOD(vict)) {
		act("Your hands glow as you lay them on $N.\r\n", TRUE, ch, 0, vict, TO_CHAR);
	  	act("Your hands glow as you lay them on $N.\r\n", TRUE, ch, 0, vict, TO_ROOM);
	  	healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	    } else {
		if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
	    	  send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	          return;
	  	}
	  	act("You thrust your hands into $N, causing serious wounds!\r\n", TRUE, ch, 0, vict, TO_CHAR);
	  	act("$n slaps $m hands into $N, causing lots of pain!\r\n", TRUE, ch, 0, vict, TO_ROOM);
	  	harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	      }
	  }
	
d3804 12
a3815 2
    }  else {
      if (vict != ch) {
d3817 8
a3824 6
	act("Your hands glow as you lay them on $N.",TRUE,ch,0,vict,TO_CHAR);
	act("$n's hands glow as $e lays them on you.", TRUE, ch, 0, vict, TO_VICT);
	act("$n's hands glow as $e lays them on $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      } else {
	act("Your hands glow as you lay them on your wounds.", TRUE, ch, 0, vict, TO_CHAR);
	act("$n's hands glow as $e lays them on $Sself.", TRUE, ch, 0, vict, TO_NOTVICT);
a3826 1

d3828 4
d3833 3
a3835 8

  }
  else {

    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_DAY; 

    if (!IS_EVIL(ch)) {
	send_to_char("You cannot summon the evil powers to achieve this act!\n\r",ch);
d3839 5
a3843 14
    if (IS_NPC(vict)) {
	if (GET_SPECIES(vict) == 12) {
	  act("Your hands glow as you lay them on $N.\r\n", TRUE, ch, 0, vict, TO_CHAR);
	  act("Your hands glow as you lay them on $N.\r\n", TRUE, ch, 0, vict, TO_ROOM);
	  healing_to_victim = 1.5 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	} else {
	  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
	    send_to_char("You feel ashamed for trying to disturb the peace of this room.\r\n",ch);
	    return;
	  }
	  act("You thrust your hands into $N, causing serious wounds!\r\n", TRUE, ch, 0, vict, TO_CHAR);
	  act("$n slaps $m hands into $N, causing lots of pain!\r\n", TRUE, ch, 0, vict, TO_ROOM);
	  harm_to_victim = 1.2 * (GET_DEX(ch) * (GET_LEVEL(ch)/10)) + number(1,50);
	}
d3845 13
a3857 11
    }  else {
      if (vict != ch) {
	healing_to_victim = GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(1,75);
	act("Your hands glow as you lay them on $N.",TRUE,ch,0,vict,TO_CHAR);
	act("$n's hands glow as $e lays them on you.", TRUE, ch, 0, vict, TO_VICT);
	act("$n's hands glow as $e lays them on $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      } else {
	act("Your hands glow as you lay them on your wounds.", TRUE, ch, 0, vict, TO_CHAR);
	act("$n's hands glow as $e lays them on $Sself.", TRUE, ch, 0, vict, TO_NOTVICT);
        healing_to_victim = GET_DEX(ch) * (GET_LEVEL(ch)/10) + number(1,75);
      }
d3859 14
a3872 5
      /*if (IS_GOOD(vict) && !IS_NPC(vict)) {
	harm_to_char = healing_to_victim;
	send_to_char("Your selfless act has it's price!\r\n", ch);
      }*/
    } 
d3874 10
d3886 2
a3887 3
  if (healing_to_victim) {
    alter_hit(vict, -healing_to_victim, 1); 
  }
d3889 2
a3890 3
  if (harm_to_victim) {
    damage(ch, vict, harm_to_victim, SKILL_LAY_HANDS); 
  }
d3892 2
a3893 3
  if (harm_to_char) {
    alter_hit(ch, harm_to_char, 2); 
  }
d4503 4
@


1.106
log
@Added code from Acerite to add a save all option to save
every player online without a force all save.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.105 2003/07/27 01:22:02 jjl Exp $
d52 1
d2089 3
a2091 3
  if (GET_RACE_ALIGN(newmgroupee) != GET_RACE_ALIGN(ch))
    {/*cant enrol someone of the other race align*/
      act("You can't enrol someone of that race align.",
d2095 2
a2096 1
  
d2213 5
a2217 5
    if (GET_RACE_ALIGN(target) != GET_RACE_ALIGN(ch))
      {/*cant enrol someone of the other race align*/
	send_to_char(NOPERSON, ch);
	return;
      }
d2436 3
a2438 3
  if ((GET_RACE_ALIGN(newgroupee) != GET_RACE_ALIGN(ch)) && (GET_LEVEL(ch) < LVL_IMMORT))
    {/*cant enrol someone of the other race align*/
      act("You can't enrol someone of that race align.",
d2441 2
a2442 1
    }
d3707 1
a3707 1

d3719 1
d3744 1
a3744 1
  }  
a3746 1
    float percentage;
d3752 5
d3759 42
a3800 8
    if (vict != ch) {
      act("Your hands glow as you lay them on $N.", FALSE, ch, 0, vict, TO_CHAR);
      act("$n's hands glow as $e lays them on you.", FALSE, ch, 0, vict, TO_VICT);
      act("$n's hands glow as $e lays them on $N.", FALSE, ch, 0, vict, TO_NOTVICT);
    } else {
      act("Your hands glow as you lay them on your wounds.", FALSE, ch, 0, vict, TO_CHAR);
      act("$n's hands glow as $e lays them on $Sself.", FALSE, ch, 0, vict, TO_NOTVICT);
    }
a3801 12
    send_to_char("You feel better!\n\r", vict);
 
    percentage = GET_ALIGNMENT(ch) / 1000.0; 
    healing_to_victim = 
      MAX(1, (GET_MAX_HIT(vict) - GET_HIT(vict)) * percentage); 
    healing_to_victim = MIN(healing_to_victim, GET_MAX_HIT(ch) * 3); 

    if (IS_EVIL(vict)) {
      harm_to_char = healing_to_victim; 
      send_to_char("Your selfless act has it's price!\r\n", ch);
      GET_ALIGNMENT(ch) = BOUNDED(-1000, GET_ALIGNMENT(ch) - 100, 1000);
    }
d3805 4
a3808 5
    if (!vict) {
      if (FIGHTING(ch)) {
	vict = ch; 
      } else {
	send_to_char("Lay hands on yourself?  That's not healthy.\r\n", ch); 
a3809 1
      }
d3812 26
a3837 1
    SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_DAY; 
d3839 5
a3844 14
    
    if (!IS_EVIL(vict)) {
      float percentage; 
      
      percentage = GET_ALIGNMENT(ch) / -1000.0; 
      harm_to_victim = BOUNDED(75, GET_HIT(ch) * 3 * percentage, 3000); 
      if (harm_to_victim > GET_MAX_HIT(vict) + 9) {
	harm_to_victim = GET_MAX_HIT(vict) + 9; 
      }
    }
    else {
      send_to_char("Your evil has no effect on other evils...\r\n", ch);
      send_to_char("Being evil, you shrug off the attack.\r\n", vict);
    }
d3866 90
d4467 4
@


1.105
log
@A fix to prevent crashes caused by camping and then memorizing.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.104 2003/07/15 02:32:04 jjl Exp $
d912 4
a915 14

       /*  try to locate this player within the realm */
      char2save = get_char(plyr2save);

      if(char2save != NULL)  /*  player is online */
      {
	 /*  save this player */
	save_char(char2save, NOWHERE);
	Crash_crashsave(char2save);
	char_to_store(char2save, &char2save_fu);
	save_char_file_u(char2save_fu);
	if (ROOM_FLAGGED(char2save->in_room, ROOM_HOUSE_CRASH))
	  House_crashsave(world[char2save->in_room].number);
	sprintf(buf, "You have saved the player %s to file.\r\n", plyr2save);
d917 2
a918 1
	sprintf(buf, "(GC) %s has saved %s to file.", GET_NAME(ch), plyr2save);
d920 26
a946 7
      else  /*  player is not online */
      {
	sprintf(buf, "No player by the name of %s is currently in the game.\r\n", plyr2save);
	send_to_char(buf, ch);
      }
      
      return;
d948 1
a948 2

     /*  otherwise, process this as a normal save on the caller */
d4333 3
@


1.104
log
@Fixed lay hands.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.103 2003/06/28 03:08:09 jjl Exp $
d38 1
d55 1
d1130 3
d4324 3
@


1.103
log
@Added back messages for paladins, since they don't go through damage.  Added a no-argument check
.  Both for layhands that is
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.102 2003/06/25 04:52:22 jjl Exp $
d3790 1
a3790 1
    alter_hit(vict, healing_to_victim, 1); 
d4319 4
@


1.102
log
@Updated lay hands to use skill messages.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.101 2003/06/25 03:32:34 jjl Exp $
a3727 2
  SKILL_DELAY(ch, SKILL_LAY_HANDS) = SECS_PER_MUD_DAY; 

d3731 17
d3760 13
d4319 3
@


1.101
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.100 2003/06/25 03:28:16 jjl Exp jjl $
a3727 14
  if (ch != vict) {
    act("Your hands glow as you lay them on $N.", 
	FALSE, ch, 0, vict, TO_CHAR);
    act("$n's hands glow as $e lays them on you.", 
	FALSE, ch, 0, vict, TO_VICT);
    act("$n's hands glow as $e lays them on $N.", 
	FALSE, ch, 0, vict, TO_NOTVICT);
  } else {
    act("Your hands glow as you lay hands on yourself.", 
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n's hands glow as $e lays them on $s wounds.", 
	FALSE, ch, 0, 0, TO_ROOM);
  }

a3740 2
      act("As $N's wounds close, identical wounds appear on $n!",
	  FALSE, ch, 0, vict, TO_ROOM);	
d3746 1
a3746 1
    if (IS_GOOD(vict)) {
d3756 2
a3757 2
      send_to_char("Your evil only affects good...\r\n", ch);
      send_to_char("Not being good, you shrug off the attack.\r\n", vict);
d3766 1
a3766 4
    alter_hit(vict, harm_to_victim, 2); 
    if (!FIGHTING(vict)) {
      set_fighting(vict, ch); 
    }
d4291 3
@


1.100
log
@Fixed the delay on lay hands.  Got that was dumb.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.99 2003/06/25 02:21:03 jjl Exp jjl $
d3767 3
d3783 3
d4310 3
@


1.99
log
@Revised lay hands to not suck.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.98 2003/06/23 02:55:02 jjl Exp $
d3742 1
a3742 1
  SKILL_DELAY(ch, SKILL_LAY_HANDS) = 24; 
d4304 3
@


1.98
log
@Added failure message to guard, moved the skill improvement.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.97 2003/06/23 01:47:09 jjl Exp jjl $
a3684 1
      /*  (struct char_data *ch, char *argument, int cmd) */
a3685 1
  int healing;
d3687 4
a3690 8
  char Gbuf1[MAX_STRING_LENGTH];
  
  if (IS_FIGHTING(ch)) {
    send_to_char("You are too busy fighting to lay hands right now.\n\r",ch);
    return;
  }
  one_argument(argument, arg);
  
d3695 3
a3697 1
  if ((GET_CLASS(ch) != CLASS_PALADIN) &&(GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
d3702 2
a3703 2
  if(!(*argument))
    {
d3705 6
d3712 6
a3717 5
  
  one_argument(argument, Gbuf1);
  
  if (*Gbuf1) {
    if (!(vict = get_char_room_vis(ch, Gbuf1))) {
d3723 35
a3757 4
  if (ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS]) 
    {
      send_to_char("You need some more rest before laying hand.\n\r", ch);
      return;
d3759 5
a3763 8
  
  switch((int)GET_CLASS(ch))
    {
    case CLASS_PALADIN:
      if (ch->char_specials.fighting && (vict != ch)) {
	send_to_char("You can't layhands on others while fighting.\n\r", ch);
	return;
      }
d3765 6
a3770 76
      if (GET_HIT(vict) >= GET_MAX_HIT(vict)) {
	if (ch != vict) {
	  act("$N is not in need of your healing.", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n looks like $e's groping $N, then flushes bright red.", FALSE, ch, 0, vict, TO_NOTVICT);
	  act("$n fumbles with your clothes for a moment, then flushes bright red.",
	      FALSE, ch, 0, vict, TO_VICT);
	} else {
	  send_to_char("You look perfectly fine to me!\r\n", ch);
	}
	return;
      }
      if (ch != vict) {
	act("Your hands glow as you lay them on $N.", FALSE, ch, 0, vict, TO_CHAR);
	act("$n's hands glow as $e lays them on you.", FALSE, ch, 0, vict, TO_VICT);
	act("$n's hands glow as $e lays them on $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	send_to_char("You feel better!\n\r", vict);
      } else {
	act("Your hands glow as you layhands on yourself.", FALSE, ch, 0, 0, TO_CHAR);
	act("$n's hands glow as $e lays them on $s wounds.", FALSE, ch, 0, 0, TO_ROOM);
      }
      
      healing = MAX(0, MIN(GET_LEVEL(ch) * 20, GET_MAX_HIT(vict) - GET_HIT(vict)));
      
      if (IS_EVIL(vict)) {
	/* it works, sorta, but... */
	healing = MIN(healing, GET_HIT(ch) + 11);
	send_to_char("Your selfless act has it's price!\r\n", ch);
	act("As $N's wounds close, identical wounds appear on $n!", FALSE, ch, 0, vict, TO_ROOM);
	GET_HIT(ch) -= healing;  /* can kill paladin */
	alter_hit(ch, healing, 2);
	GET_ALIGNMENT(ch) = BOUNDED(-1000, GET_ALIGNMENT(ch) - 10, 1000);
	ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS] = (SECS_PER_MUD_DAY) * PASSES_PER_SEC;
	
	update_pos(ch);
      }
      /* Always use alter_hit ...Banyal*/
      alter_hit(vict, (-1 * healing), 1);
      /*  GET_HIT(vict) += healing;*/
      
      break;
      
    case CLASS_ANTI_PALADIN:
      if (!ch->char_specials.fighting && (vict != ch)) {
	send_to_char("You can layhands on others only while fighting.\n\r", ch);
	return;
      }
      
      if (IS_GOOD(vict))
	{
	  act("Your hands glow as you lay them on $N.", FALSE, ch, 0, vict, TO_CHAR);
	  act("$n's hands glow as $e lays them on you.", FALSE, ch, 0, vict, TO_VICT);
	  act("$n's hands glow as $e lays them on $N.", FALSE, ch, 0, vict, TO_NOTVICT);
	  send_to_char("You feel your life forces being drained!\n\r", vict);
	  
	  /* this was * 20 dude this was way over powered a level 15 anti killed a 53
	     warrior with it Banyal*/
	  /* how is there a level 15 anti? it should do at LEAST the paladins hit points 
	   * i'll compromise at * 10, and made it so it takes anti hits or lev*10,
	   * whichever is more.
	   */
/* Was _MY_ level 15 anti for test please        do not change again this is
being ABUSED so VERY badLY!!!!!!!!!!! _BANYAL_*/
    /* This is not board DnD you mustlook at abuse and layhands does not have tobe
atelats guys hitpoints a 50 anti with vit and eq can do 1000 damage
DUh I dont think so-Banyal */
	 /*   healing = MAX(0, MAX(GET_LEVEL(ch) * 10, GET_HIT(ch))); */
           healing = BOUNDED(75, GET_HIT(ch) / 3, 200);
	  ch->char_specials.action_delays[ACT_DELAY_LAY_HANDS] = (SECS_PER_MUD_DAY) * PASSES_PER_SEC;
	  
	  /*always use alter_hit Banyal*/
	  alter_hit(vict, healing, 2);
	  /* GET_HIT(vict) -= healing; */
	}
      else
	send_to_char("Your evil only affects good...\r\n", ch);
      break;
d3772 14
d4304 3
@


1.97
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.96 2003/06/21 03:18:29 jjl Exp $
a143 1
  improve_skill(ch, SKILL_GUARD);
d4329 3
@


1.96
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.95 2003/06/21 01:01:08 jjl Exp jjl $
d3098 1
d3104 7
d3142 3
a3144 6
  if (stat(filename, &fbuf) < 0) {
    perror("Error statting file");
    return;
  }
  if (fbuf.st_size >= max_filesize) {
    send_to_char("Sorry, the file is full right now.. try again later.\r\n", ch);
d3147 1
d3212 1
d3264 1
a3264 1
		/*22*/  {"You will now auto-engage upon being offensively cast upon.\r\n",
d3268 6
a3273 2
		/*24*/	{"",
			 ""}};
d3358 1
a3358 2
  strcpy(buf, "Okay.");  /* can't use OK macro here 'cause of \r\n */
  
d3361 1
a3361 1
  
a3363 3
    case SCMD_NOSUMMON:
      send_to_char("Rolf, sorry no twink mud here hehe .. tog summon off rolf.\r\n", ch);
      break;
d3459 3
d4330 3
@


1.95
log
@Modified rogues.  Removed circle - backstab is now circlicious.  Updated
damage on backstab to give a little more pop.  Throatcut is now a once a day.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.94 2003/04/03 01:05:17 jjl Exp $
d651 1
a651 1
     //     return;
d4320 4
@


1.94
log
@Changed the stun on hide, because it was like 16 seconds before.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.93 2002/12/04 09:03:55 rls Exp $
d556 7
a562 7
   { "horse",       1003, "M", 30,  220,  260, 180, 300},
   { "badger",      1004, "M", 40,  120,  160, 140, 170},
   { "wolf",        1005, "M", 50,  400,  480, 270, 320}, /* 5 */
   { "panther",     1006, "M", 60,  380,  450, 300, 350},
   { "bear",        1007, "M", 80,  640,  740, 140, 160},
   { "cheetah",     1008, "M", 80,  420,  500, 400, 480},
   { "rhino",       1009, "M", 90,  860, 1040, 120, 150},
d566 7
a572 7
   { "owl",         1013, "B", 20,   80,  100, 140, 160},
   { "raven",       1014, "B", 30,  100,  120, 160, 180},
   { "hawk",        1015, "B", 40,  160,  190, 190, 220}, /* 15 */
   { "falcon",      1016, "B", 50,  150,  180, 200, 240},
   { "buzzard",     1017, "B", 60,  240,  280, 140, 160},
   { "eagle",       1018, "B", 70,  320,  380, 260, 300},
   { "ostrich",     1019, "B", 80,  360,  460, 500, 650},
d577 6
a582 6
   { "tortoise",    1024, "R", 40,  320,  360,  40,  70},
   { "cobra",       1025, "R", 44,  280,  320, 140, 160}, /* 25 */
   { "turtle",      1026, "R", 60,  440,  480,  60, 100},
   { "viper",       1027, "R", 70,  340,  420, 140, 180},
   { "crocodile",   1028, "R", 85,  720,  830,  60, 120},
   { "anaconda",    1029, "R", 90,  945, 1025, 140, 160},
d651 1
a651 1
     return;
d4320 3
@


1.93
log
@changed max_group_diff to an external call for max group level diff code
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.92 2002/12/04 06:11:09 jjl Exp $
d1377 1
a1377 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 4);
d4320 3
@


1.92
log
@Well, that was dumb.  In group "all", it was checking to see if there was a
level difference as a prerequisite for checking the range.  It should have
been checking if the max range was nonzero instead.
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.91 2002/11/30 19:39:38 jjl Exp $
d50 1
a50 1
int max_group_difference; 
d4320 5
@


1.91
log
@Added the ability for GAME commands to have integer values, and added a
GROUPING game command, that allows you to set a maximum level difference
between group masters and potential groupees..
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.90 2002/10/19 18:29:21 jjl Exp $
d2382 1
a2382 1
	  if (level_diff && (level_diff > max_group_difference ||
d4320 5
@


1.90
log
@Recall spec procs.  This file has the event handler for it
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.89 2002/09/13 02:32:10 jjl Exp $
d50 1
d2321 1
d2323 2
d2379 17
a2395 2
	  add_groupee(f->follower, ch, 1);
	  found++;
d2397 7
a2403 2
      if (!found){
	send_to_char("Everyone following you is already in your group.\r\n", ch);
d2447 1
a2447 1
      act("You cant group your own group master.", FALSE, ch, 0, newgroupee, TO_CHAR);
d2491 14
d4320 3
@


1.89
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.other.c,v 1.88 2002/05/18 12:57:55 dce Exp $
d1032 37
d4282 3
@


1.88
log
@Fixed it so rhino's are a lower level...same problem
as anaconda's
@
text
@d1 3
a3 1
// $Id: act.other.c,v 1.87 2002/05/13 21:20:26 dce Exp $
d898 5
a902 5
  // Demolitum (12 Oct 2001) - Player save functionality for god types.
  // The following section allows for gods to save players using the
  // syntax: save <playername>, where <playername> is the player to
  // be saved. This works on any character which has been brought
  // online either by the player logging in or a god linkloading.
d907 1
a907 1
    if (*plyr2save) // if a player name has been specified
d911 1
a911 1
      // try to locate this player within the realm
d914 1
a914 1
      if(char2save != NULL) // player is online
d916 1
a916 1
	// save this player
d928 1
a928 1
      else // player is not online
d937 1
a937 1
    // otherwise, process this as a normal save on the caller
d1317 1
a1317 1
  if (GET_SKILL(ch, SKILL_HIDE) < 1){          // was skill_sneak duh -Banyal
d2707 1
a2707 1
  // Demolitum (17 Oct 2001) - Show the splitter (giver) how much loot he got to keep.
d3483 3
a3485 1
// SUMMON_MOUNT
d3488 1
a3488 1
     // (struct char_data *ch, char *arg, int cmd)
d3490 1
a3490 1
  //  int sumtime;
d3572 1
a3572 1
  char_to_room(mount, ch->in_room); // was -2
d3592 3
a3594 1
// end SUMMON_MOUNT
d3596 3
a3598 1
// LAY_HANDS
d3601 1
a3601 1
     // (struct char_data *ch, char *argument, int cmd)
d3715 1
a3715 1
	//  healing = MAX(0, MAX(GET_LEVEL(ch) * 10, GET_HIT(ch)));
d3729 3
a3731 1
// end LAY_HANDS
d3733 3
a3735 1
// FIRST_AID
d3738 1
a3738 1
     // (struct char_data *ch, char *arg, int cmd)
d3770 3
a3772 1
// end FIRST_AID
d4243 338
a4580 332
// $Log: act.other.c,v $
// Revision 1.87  2002/05/13 21:20:26  dce
// Fixed that anaconda problem where it would make you level 100.
//
// Revision 1.86  2002/05/05 22:04:28  mpg
// modified "report" so you can no longer see (wiz)invizies names when they report
//
// Revision 1.85  2002/04/26 21:36:30  mpg
// when grouped with wizesies, you no longer get info typing "group"
// unless you've got their consent.
//
// Revision 1.84  2002/04/26 20:22:21  mpg
// modified "chant" to work show correct gender in messages.
//
// Revision 1.83  2002/04/26 18:54:28  mpg
// modified "group" so group info can be accessed while sleeping.
// forming of groups etc. still restricted to POS_RESTING and up.
// NB: while .
//
// Revision 1.82  2002/02/25 10:59:41  rls
// Added apostrophe and punctuation to display string in do_report
//
// Revision 1.81  2001/12/07 02:09:56  dce
// Linkdead players will now lose exp when they die.
// Linkdead shapechanged players will now shapechange
// to their original form before linking out.
//
// Revision 1.80  2001/11/15 19:52:48  rjd
// Plural rules fixed for splitting coins.
//
// Revision 1.79  2001/11/15 18:04:38  rjd
// Coin splitter message for the splitter corrected.
//
// Revision 1.78  2001/10/17 21:04:05  rjd
// Tweaked "split" command so that splitter (giver) now sees how much of the
// split currency (s)he kept. Also cleaned up the message to the receivers,
// which had a spelling error (was "recieve", now is correctly "receive").
//
// Revision 1.77  2001/10/12 21:21:12  rjd
// Extension of the "save" command: Gods can now type "save <playername>" to save a player
// to file. This works on any player loaded into the game, whether by a player logging in
// normally or a god linkloading the player.
//
// Revision 1.76  2001/04/06 00:58:41  dce
// Subclassing should show in the syslog.
//
// Revision 1.75  2001/04/02 23:31:21  dce
// Put a level restriction on potions and wands, etc...
//
// Revision 1.74  2001/04/01 21:59:31  mtp
// changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
//
// Revision 1.73  2001/03/25 00:44:46  dce
// Bug/Idea/Typo gives better output
//
// Revision 1.72  2001/03/13 20:52:09  dce
// Made the summonable mounts more sane. No longer a level 70+
// horse with 1500+ hps.
//
// Revision 1.71  2001/03/07 01:45:18  dce
// Added checks so that players can not kill shapechanged players and
// vise versa. Hopefully I didn't miss any...
//
// Revision 1.70  2001/03/04 17:33:19  dce
// Shapechange does not ding you a hp.
//
// Revision 1.69  2001/03/03 18:07:10  dce
// Gods should not fail specific shapechanges.
//
// Revision 1.68  2001/02/24 16:47:57  dce
// Phase 3 of shapechange.
//
// Revision 1.67  2001/02/24 04:04:05  dce
// Phase 2 of shapechange
//
// Revision 1.66  2001/02/21 01:06:19  dce
// Phase 1 of the shapechange re-write
//
// Revision 1.65  2001/02/12 23:22:42  mtp
// min level for subclass changed to 5
//
// Revision 1.64  2001/02/11 22:29:39  rsd
// disabled the bind command
//
// Revision 1.63  2001/02/03 00:56:51  mtp
// do a race check before starting subclass quest
// also returing different codes so that calling procs can do something sensible
// on failure
//
// Revision 1.62  2001/02/01 02:36:21  dce
// Somone was sending a buf to a char without ever putting anything
// in the buf...in the disband command. It is now fixed.
//
// Revision 1.61  2001/01/16 00:33:56  mtp
// make sure spell/skill list is clean after subclass
//
// Revision 1.60  2001/01/10 23:30:24  mtp
// cant camp with more than 50 items
//
// Revision 1.59  2000/11/26 10:03:57  jimmy
// Fixed do_sneak.  The affectation was not being properly initilized.
// Added init to 0 for aff2/aff3.  This fixes the do_stat_character
// bug of a ch who's sneaking.
//
// Revision 1.58  2000/11/20 04:21:41  rsd
// Added all i freaking zillion back rlog messages from
// prior to the addition of the $log$ string. phew.
//
// Revision 1.57  2000/11/07 01:42:04  mtp
// changes to do_subclass to use the subclass quest style
// old method (using can_subclass_plyr saved as do_old_subclass in case it doesnt work)
//
// Revision 1.56  2000/10/25 23:43:54  rsd
// Fixed the if_pkill check on psteal to allow
// mobiles to steal from players, DOH.
//
// Revision 1.55  2000/10/21 12:05:57  mtp
// improved subclass code, now looks for cvariable can_subclass_<name> = <subclass>
// to allow a QM to be waiting for multiple potential finishers
//
// Revision 1.54  2000/10/19 01:54:08  mtp
// added new subclass code, dependent on two variable (global set on mob) use_subclass and can_subclass, if the player
// with name == can_subclass types subclass in the room with a teacher mob, and the value of use_subclass is valid for
// that user, then they are subclassed.
//
// Revision 1.53  2000/10/13 17:50:39  cmc
// re-instituted modified level command
// required to re-implement "level gain"
//
// Revision 1.52  2000/09/28 03:22:09  rsd
// made no gossip level 0
//
// Revision 1.51  2000/06/04 03:59:07  rsd
// altered summon mount so the mounts increase in strength as
// the pally's increase in level and align.
// The algorythm could use some tweaking, I'm open to suggestion
//
// Revision 1.50  2000/05/21 23:55:59  rsd
// Altered do_prompt to point mortals at the display command.
//
// Revision 1.49  2000/05/10 22:09:24  rsd
// added a check to do_douse to check for fountains
// in the room.  If there is a fountain in the room
// the player automatically gets doused w/o any checks.
// Cool eh? :)
//
// Revision 1.48  2000/04/22 22:30:04  rsd
// Changed the comment header, also retabbed and braced sections of the code.
// Altered toggle to show the numbers associated with wimpy and pagelength.
// Also, toggle will return a message to the player if the toggle with a
// bogus argument.
//
// Revision 1.47  2000/04/17 00:52:33  rsd
// removed mana from do_display and made do prompt level 101
// or higher.
//
// Revision 1.46  2000/03/08 11:14:42  cso
// do_steal only checked for gold. made it check all 4 coin types.
//
// Revision 1.45  1999/12/13 05:16:49  cso
// made do_steal check the pk_allowed game setting
//
// Revision 1.44  1999/11/28 22:44:48  cso
// do_prompt: commented out a CREATE that was causing a mem leak
//
// Revision 1.43  1999/10/06 17:55:24  rsd
// Removed the AFK code from the end of the prompt and moved
// it to comm.c
//
// Revision 1.42  1999/09/16 01:47:17  dce
// Song levels moved up.
//
// Revision 1.41  1999/09/14 00:27:17  dce
// Monks hit and dam toned down.
//
// Revision 1.40  1999/09/10 00:49:52  mtp
// an[4~[4~bandage can KILL now if done badly for too long
//
// Revision 1.39  1999/09/10 00:01:53  mtp
// added a delay (for mortals) to bandage
//
// Revision 1.38  1999/09/07 23:26:53  mtp
// removed mana from 'print_group' output
//
// Revision 1.37  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.36  1999/09/05 05:04:43  mud
// reverted to previous version to remove compile errors until they can be fixed
//
// Revision 1.35  1999/09/03 23:22:50  mtp
// remove mana from group output
//
// Revision 1.34  1999/09/03 23:06:54  mtp
// added some IS_FIGHTING checks
//
// Revision 1.33  1999/08/13 15:31:01  dce
// Allow camping to be seen in normal syslog.
//
// Revision 1.32  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.31  1999/08/10 20:51:42  dce
// Qucik 
// Quick fix to a bug where players can get a free rippost
// if they don't even have the skill.
//
// Revision 1.30  1999/08/09 22:37:11  mtp
// Added <AFK> to players prompt if toggled AFK (includes changes of prompt)
//
// Revision 1.29  1999/07/24 21:01:37  dce
// Sublass function
//
// Revision 1.28  1999/07/23 01:57:18  mud
// fixed do gen toggle, thanks
// fixed from printing double line at end, removed ooc and slowns
// as well as case sensitivity. I'm so insensitive.
//
// Revision 1.27  1999/07/10 05:51:23  mud
// Ok, removed the OOC from being a toggle, commented it out of
// certain sections, and just cut it out of other parts of do_toggle.
//
// Revision 1.26  1999/07/09 21:00:06  mud  
// moved the ascii terminator in the toggle display and
// added a header line above the cute format characters.
//
// Revision 1.25  1999/07/07 23:21:45  jimmy
// Fixed do_group to check for consent of following npc's.  This was an
// oversight on my part when fixing the command in the last ci.
// gurlaek
//
// Revision 1.24  1999/07/07 15:46:44  jimmy
// fixed the problems with trophys not being updated when in a group.
// This was A bug created by my cut and pasting when i fixed the
// void * function pointer warnings. All better now :)
// --gurlaek 7/7/1999
//
// Revision 1.23  1999/07/06 02:53:50  mud
// Completely reworked the toggle command to make it easier to
// read.  It's now 3 columns of stuff instead of that blue
// one line stuff that scrolled off the screen.
// Gurlaek showed me how to do it.
//
// Revision 1.22  1999/06/11 16:56:55  jimmy
// Ok, fixed do_quit to check for fighting and also not crash when mortally
// wounded.  This was done in die() by checking for killer=NULL.
// since no one killed you if you quit while morted the die code
// didn't know how to deal with a NULL killer.
// --Gurlaek 6/11/1999
//
// Revision 1.21  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.20  1999/05/26 01:50:28  mud
// made summon mount level 15 instead of 25 in the
// if (GET_LEVEL(ch) < XX) statement
//
// Revision 1.19  1999/05/04 19:41:51  dce
// Fixed some typos
//
// Revision 1.18  1999/05/02 17:10:17  mud
// made toggeling of autoexits level 0 as opposed to
// LVL_IMMORT or whatever it was before.
//
// Revision 1.17  1999/05/01 18:01:21  dce
// Allow players to drop all eq and quit.
//
// Revision 1.16  1999/04/29 19:02:04  mud
// made anonymous level 50
//
// Revision 1.15  1999/04/23 01:51:22  jimmy
// fixed camp crashbug.  This occured when someone type camp twice.
// I added checks to EVENTFUNC(camp_event) to determine if someone was
// already camping, and also NULLed freed pointers SCREAM!.  Seems to work
// fine.  --Gurlaek.
//
// Revision 1.14  1999/04/16 03:55:09  dce
// Removed some things temporarly until they can be fixed.
//
// Revision 1.13  1999/03/30 18:59:31  jen
// Fixed a toggle bug... JEN II
// Was allowing proper lvl players to toggle, but not displaying
// anything except stuff available to ppl BELOW your lvl
//
// Revision 1.12  1999/03/26 19:44:35  jen
// Added a mortal gossip channel with 103+ godly control
//
// Revision 1.11  1999/03/08 21:09:52  dce
// Adjusts chant semantics
//
// Revision 1.10  1999/03/08 04:47:16 dce
// Chant semantics added.
//
// Revision 1.9  1999/03/07 05:01:09  dce
// Chant finishes and wearoff messages.
//
// Revision 1.8  1999/03/06 23:51:54  dce
// Add's chant songs, and can only chant once every four hours
//
// Revision 1.7  1999/03/05 20:02:36  dce
// Chant added to, and songs craeted
//
// Revision 1.6  1999/02/26 22:30:30  dce
// Added skeleton for chant skill
//
// Revision 1.5  1999/02/20 18:41:36  dce
// Adds improve_skill calls so that players can imprve their skills.
//
// Revision 1.4  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.3  1999/02/06 17:27:25  jimmy
// God loadrooms now set permanently until changed.
// if you drop link however you come back where you
// dropped.
//
// Revision 1.2  1999/02/03 22:54:08  jimmy
// removed some toggles from mortal chars
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial Revision
//
@


1.87
log
@Fixed that anaconda problem where it would make you level 100.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.86 2002/05/05 22:04:28 mpg Exp $
d559 1
a559 1
   { "rhino",       1009, "M", 95,  860, 1040, 120, 150},
d4230 3
@


1.86
log
@modified "report" so you can no longer see (wiz)invizies names when they report
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.85 2002/04/26 21:36:30 mpg Exp $
d579 1
a579 1
   { "anaconda",    1029, "R", 95,  945, 1025, 140, 160},
d4230 3
@


1.85
log
@when grouped with wizesies, you no longer get info typing "group"
unless you've got their consent.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.84 2002/04/26 20:22:21 mpg Exp $
d2497 6
a2502 3
  if (!*arg && !ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    { sprintf(buf, "%s says, 'I have %d (%d) hit and %d (%d) movement points",
	      GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
d2505 3
a2507 1
    act(buf, FALSE, ch, 0, 0, TO_ROOM);
d2546 1
a2546 1
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
d2561 1
a2561 1
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
d2571 1
a2571 1
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
d2585 1
a2585 1
		GET_NAME(ch), GET_HIT(ch), GET_MAX_HIT(ch),
d4230 4
@


1.84
log
@modified "chant" to work show correct gender in messages.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.83 2002/04/26 18:54:28 mpg Exp $
d1638 16
a1653 15
    if (IS_AFFECTED(k, AFF_GROUP)) {
      perc = (100*GET_HIT(k)/GET_MAX_HIT(k));
      sprintf(harm_color, "%s%s%s", (perc >= 25 ? CCNRM(k,C_NRM) : CCBBLK(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCNRM(ch,C_NRM) :
	       perc >= 70 ? CCBLD(ch,C_NRM) :
              perc >= 45 ? CCNRM(ch,C_NRM) :
	       perc >= 20 ? CCNRM(ch,C_NRM) :
	       perc >= 0 ? CCBLD(ch,C_NRM) : CCBLD(ch,C_NRM)),
	      (perc >= 100 ? CCNRM(ch, C_NRM) :
	       perc >= 88 ? CCYEL(ch,C_SPR) :
	       perc >= 70 ? CCYEL(ch, C_NRM) :
	       perc >= 45 ? CCMAG(ch, C_NRM) :
	       perc >= 20 ? CCRED(ch, C_NRM) :
	       perc >= 0 ? CCRED(ch, C_NRM) : CCRED(ch, C_NRM)));
d1657 6
a1662 6
      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dv/%3dV] [%s] (&0&2&bHead of group&0)\r\n", 
	      harm_color,
	      GET_NAME(k), harm_color,
	      GET_HIT(k), CCUND(k,C_NRM), GET_MAX_HIT(k), GET_MOVE(k), GET_MAX_MOVE(k), CLASS_ABBR(k));
/*      act(buf, FALSE, ch, 0, k, TO_CHAR);*/
        send_to_char(buf, ch);
d1666 1
a1666 1
      if (!IS_AFFECTED(f->groupee, AFF_GROUP))
d1690 1
a1690 2
/*      act(buf, FALSE, ch, 0, f->groupee, TO_CHAR);*/
      send_to_char(buf, ch);
d4225 3
@


1.83
log
@modified "group" so group info can be accessed while sleeping.
forming of groups etc. still restricted to POS_RESTING and up.
NB: while .
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.82 2002/02/25 10:59:41 rls Exp $
d2502 2
a2503 1
    act(buf, FALSE, ch, 0, 0, TO_ROOM);} 
d3877 1
a3877 1
      send_to_char("You are to relaxed..\r\n", ch);
d4073 1
a4073 1
              act("$n chokes on his tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
d4098 1
a4098 1
                act("$n chokes on his tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
d4118 1
a4118 1
            act("$n chokes on his tears and coughs a raspy grunt.", TRUE, ch, 0, 0, TO_ROOM);
d4225 5
@


1.82
log
@Added apostrophe and punctuation to display string in do_report
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.81 2001/12/07 02:09:56 dce Exp $
d1656 1
a1656 1
      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dv/%3dV] [%s] (&0&2&bHead of group&0)", 
d1660 2
a1661 1
      act(buf, FALSE, ch, 0, k, TO_CHAR);
d1685 1
a1685 1
      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dv/%3dV] [%s]", 
d1689 2
a1690 1
      act(buf, FALSE, ch, 0, f->groupee, TO_CHAR);
d2285 11
a2295 1
  if (*buf) /*(argument with it)*/
a2309 8
  else 
    {
      if (!*buf) 
	{
	  print_group(ch);
	  return;
	}
    }
d4224 3
@


1.81
log
@Linkdead players will now lose exp when they die.
Linkdead shapechanged players will now shapechange
to their original form before linking out.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.80 2001/11/15 19:52:48 rjd Exp $
d2504 1
a2504 1
    { sprintf(buf, "You say, 'I have %d (%d) hit and %d (%d) movement points",
d4220 5
@


1.80
log
@Plural rules fixed for splitting coins.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.79 2001/11/15 18:04:38 rjd Exp $
d593 1
a593 1
  if (IS_FIGHTING(ch)) {
d4220 3
@


1.79
log
@Coin splitter message for the splitter corrected.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.78 2001/10/17 21:04:05 rjd Exp $
d2706 1
a2706 1
	    amt_kept--;
d2715 6
a2720 3
		strcpy(buf, "You give away &b&61 &0platinum coin, foregoing your share.\r\n");
	      else
		sprintf(buf, "You keep &b&6%d &0platinum coins.\r\n", amt_kept);
d2725 3
a2727 1
		strcpy(buf, "You give away &0&b&31 &0gold coin, foregoing your share.\r\n");
d2734 3
a2736 1
		strcpy(buf, "You give away 1 silver coin, foregoing your share.\r\n");
d2743 3
a2745 1
		strcpy(buf, "You give away &0&31 &0copper coin, foregoing your share.\r\n");
d2764 4
a2767 1
      sprintf(buf, "You receive &b&6%d &0platinum coins.\r\n", give);
d2772 4
a2775 1
      sprintf(buf, "You receive &0&b&3%d &0gold coins.\r\n", give);
d2780 4
a2783 1
      sprintf(buf, "You receive %d silver coins.\r\n", give);
d2788 4
a2791 1
      sprintf(buf, "You receive &0&3%d &0copper coins.\r\n", give);
d4220 3
@


1.78
log
@Tweaked "split" command so that splitter (giver) now sees how much of the
split currency (s)he kept. Also cleaned up the message to the receivers,
which had a spelling error (was "recieve", now is correctly "receive").
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.77 2001/10/12 21:21:12 rjd Exp $
d18 1
d2595 1
d2700 7
d2708 2
a2709 2
	  amt_kept = (int)(cash[i] - ((cash[i]/counter) * (counter - 1)));
	  amt_kept = (amt_kept == 1) ? 0 : amt_kept;
d4199 5
@


1.77
log
@Extension of the "save" command: Gods can now type "save <playername>" to save a player
to file. This works on any player loaded into the game, whether by a player logging in
normally or a god linkloading the player.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.76 2001/04/06 00:58:41 dce Exp $
d2593 1
a2593 1
  int num, give, i;
d2693 44
a2738 1

d2746 1
a2746 1
      sprintf(buf, "You recieve &b&6%d &0platinum coins.\r\n", give);
d2751 1
a2751 1
      sprintf(buf, "You recieve &0&b&3%d &0gold coins.\r\n", give);
d2756 1
a2756 1
      sprintf(buf, "You recieve %d silver coins.\r\n", give);
d2761 1
a2761 1
      sprintf(buf, "You recieve &0&3%d &0copper coins.\r\n", give);
d4190 5
@


1.76
log
@Subclassing should show in the syslog.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.75 2001/04/02 23:31:21 dce Exp $
d69 1
d891 46
d4147 3
@


1.75
log
@Put a level restriction on potions and wands, etc...
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.74 2001/04/01 21:59:31 mtp Exp $
d281 2
d4100 3
@


1.74
log
@changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.73 2001/03/25 00:44:46 dce Exp mtp $
d2715 5
d2723 1
a2723 1
      send_to_char("You can only quaff potions.", ch);
d2729 1
a2729 1
      send_to_char("You can only recite scrolls.", ch);
d4098 3
@


1.73
log
@Bug/Idea/Typo gives better output
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.72 2001/03/13 20:52:09 dce Exp $
d155 4
a158 1
	if (GET_CLASS(ch) > MAX_BASE_CLASS)
d173 1
a173 1
			(GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_THIEF) ||
d194 1
a194 1
			case CLASS_THIEF:	subclass_allowed = rogue_subclasses;
d239 1
a239 1
				case CLASS_THIEF:	destclass = rogue_subclasses[arrayref];
d346 1
a346 1
				    case CLASS_THIEF:       for (i=0;i < ROGUE_SUBCLASSES;i++)
d4093 3
@


1.72
log
@Made the summonable mounts more sane. No longer a level 70+
horse with 1500+ hps.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.71 2001/03/07 01:45:18 dce Exp $
d2911 1
a2911 1
    send_to_char("That must be a mistake...\r\n", ch);
d2933 1
a2933 1
  send_to_char("Okay.  Thanks!\r\n", ch);
d4090 4
@


1.71
log
@Added checks so that players can not kill shapechanged players and
vise versa. Hopefully I didn't miss any...
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.70 2001/03/04 17:33:19 dce Exp $
d3439 1
a3439 1
  factor = BOUNDED (0, (GET_LEVEL(ch) + abs((GET_ALIGNMENT(ch) / 200)) - dice(1, 10)), 70);
d3441 5
a3445 5
  GET_LEVEL(mount) += factor;
  GET_MAX_HIT(mount) += (factor * 10);
  GET_HIT(mount) += (factor * 10);
  GET_MAX_MOVE(mount) += (factor * 5);
  GET_MOVE(mount) += (int) (factor * 5);
d4090 4
@


1.70
log
@Shapechange does not ding you a hp.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.69 2001/03/03 18:07:10 dce Exp $
d1337 12
d4090 3
@


1.69
log
@Gods should not fail specific shapechanges.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.68 2001/02/24 16:47:57 dce Exp $
d878 1
a878 1
  alter_hit(mob, 1, 1);
d4078 3
@


1.68
log
@Phase 3 of shapechange.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.67 2001/02/24 04:04:05 dce Exp $
d622 1
a622 1
      if (GET_LEVEL(player) < 101)
d624 3
d666 1
a666 1
            if (perc >= chan) {
d717 1
a717 1
            if (perc >= chan) {
d768 1
a768 1
            if (perc >= chan) {
d862 3
a878 2

  improve_skill(ch, SKILL_SHAPECHANGE);  
d4078 3
@


1.67
log
@Phase 2 of shapechange
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.66 2001/02/21 01:06:19 dce Exp $
d519 1
a519 1
  int c_maxhit, c_hit, c_maxmove, c_move, m_maxhit, m_maxmove;
d613 1
d621 3
a623 1
      extract_char(ch); 
d632 10
a641 1
  if (GET_ALIGNMENT(ch) >= 350) {
d644 1
a644 1
  } else if (GET_ALIGNMENT(ch) <= -350) {
d823 12
a834 1
  
d857 2
a858 1
  
d870 1
d3746 2
a3747 1
      ch->player_specials->saved.chant = 4;
d3884 4
a3887 2
  ch->player_specials->saved.chant = 4;
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d4074 3
@


1.66
log
@Phase 1 of the shapechange re-write
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.63 2001/02/03 00:56:51 mtp Exp $
d550 1
a550 1
   { "bear",        1007, "M", 80,  540,  640, 140, 160},
d552 1
a552 1
   { "rhino",       1009, "M", 95,  710,  890, 120, 150},
d571 2
a572 2
   { "crocodile",   1028, "R", 85,  670,  780,  60, 120},
   { "anaconda",    1029, "R", 95,  820,  900, 140, 160},
d582 1
a582 1
    send_to_char("You have no idea how to do that!", ch);
d587 1
a587 1
    send_to_char("You can't concentrate enough while fighting.\n\r",ch);
d593 1
a593 1
    send_to_char("Shapechange to what?", ch);
d624 1
a624 1
      send_to_char("You cannot shapechange to another animal from this form.", ch);
d630 1
a630 1
    send_to_char("Your good loyalties betray your nature, inhibiting a transformation.", ch);
d633 1
a633 1
    send_to_char("Your evil loyalties betray your nature, inhibiting a transformation.", ch);
d794 1
a794 1
    send_to_char("You can only be a mammal, bird, or reptile at this time.",ch);
d799 1
a799 1
    send_to_char("You start to change, then feeling ill, slumping back to your normal form.", ch);
d840 2
a841 2
  GET_MAX_HIT(mob) = creatures[index].maxhp;
  GET_MAX_MOVE(mob) = creatures[index].maxmv;
d4046 3
@


1.65
log
@min level for subclass changed to 5
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.64 2001/02/11 22:29:39 rsd Exp mtp $
d474 41
d518 2
a519 1
  int mob_vnum, r_num, location;
d521 54
a574 3
  
  send_to_char("Due to abuse, this command is disabled until it can be fixed.\r\n", ch);
  return;
a575 6
  if (IS_FIGHTING(ch)) {
    send_to_char("You can't concenttrate enough while fighting.\n\r",ch);
    return;
  }
  one_argument(argument, arg);
  
d585 8
a592 1
  if (!*arg) {
d597 1
a597 1
    if (is_abbrev(arg, "me")) {
d604 10
a613 1
      
d624 1
a624 1
      send_to_char("You cannot shapechange from this form.", ch);
d628 166
a793 7
  if (is_abbrev(arg, "mammal")) 
    mob_vnum = number(1000,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1000));
  else if (is_abbrev(arg, "bird"))
    mob_vnum = number(1010,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1010));
  else if (is_abbrev(arg, "reptile"))
    mob_vnum = number(1020,((int)((GET_SKILL(ch, SKILL_SHAPECHANGE)-1)/10)+1020));
  else {
d819 15
a833 1
  
d840 9
d1082 1
a1082 1
  
d4046 3
@


1.64
log
@disabled the bind command
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.63 2001/02/03 00:56:51 mtp Exp $
d162 1
a162 1
	if (GET_LEVEL(ch) < 10)
d3761 3
@


1.63
log
@do a race check before starting subclass quest
also returing different codes so that calling procs can do something sensible
on failure
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.61 2001/01/16 00:33:56 mtp Exp $
d792 5
d3761 5
@


1.62
log
@Somone was sending a buf to a char without ever putting anything
in the buf...in the disband command. It is now fixed.
@
text
@d149 4
d154 23
d178 33
a210 1
		return ;
d236 1
a236 1
				case CLASS_ROGUE:	destclass = rogue_subclasses[arrayref];
d343 1
a343 1
				    case CLASS_ROGUE:       for (i=0;i < ROGUE_SUBCLASSES;i++)
d3756 4
@


1.61
log
@make sure spell/skill list is clean after subclass
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.60 2001/01/10 23:30:24 mtp Exp mtp $
a1506 1
    send_to_char(buf, f->groupee);
d3697 3
@


1.60
log
@cant camp with more than 50 items
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.59 2000/11/26 10:03:57 jimmy Exp $
d144 2
d197 9
d3698 3
@


1.59
log
@Fixed do_sneak.  The affectation was not being properly initilized.
Added init to 0 for aff2/aff3.  This fixes the do_stat_character
bug of a ch who's sneaking.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.58 2000/11/20 04:21:41 rsd Exp jimmy $
d527 2
d539 12
d601 2
d638 14
d3687 5
@


1.58
log
@Added all i freaking zillion back rlog messages from
prior to the addition of the $log$ string. phew.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.57 2000/11/07 01:42:04 mtp Exp $
d831 2
d3657 4
@


1.57
log
@changes to do_subclass to use the subclass quest style
old method (using can_subclass_plyr saved as do_old_subclass in case it doesnt work)
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.56 2000/10/25 23:43:54 rsd Exp $
d3655 4
d3733 145
@


1.56
log
@Fixed the if_pkill check on psteal to allow
mobiles to steal from players, DOH.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.55 2000/10/21 12:05:57 mtp Exp $
d30 1
d144 69
d3655 4
@


1.55
log
@improved subclass code, now looks for cvariable can_subclass_<name> = <subclass>
to allow a QM to be waiting for multiple potential finishers
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.54 2000/10/19 01:54:08 mtp Exp $
d842 1
a842 1
  if (!pk_allowed && !IS_NPC(vict)) {
d3585 4
@


1.54
log
@added new subclass code, dependent on two variable (global set on mob) use_subclass and can_subclass, if the player
with name == can_subclass types subclass in the room with a teacher mob, and the value of use_subclass is valid for
that user, then they are subclassed.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.53 2000/10/13 17:50:39 cmc Exp mtp $
d46 1
a56 1
int subclasser(struct char_data *ch, int original_class, int subclass, int minlev, int maxlev, int aless, int agreater);
a68 44
/* The subclass function - David Endre 7/20/99 */
int subclasser(struct char_data *ch, int original_class, int subclass, int minlev, int maxlev, int aless, int agreater)
  {
     double oldpct;
  
     /* Make sure that they are not already subclassed */
     if((int)GET_CLASS(ch) == subclass)
        return 1;
     /* Make sure that they are the correct base class */
     if((int)GET_CLASS(ch) != original_class)
        return 2;
     /* Check to make sure they are the proper level */
     if(GET_LEVEL(ch) < minlev)
        return 3;  
     /* Check to make sure they are the proper level */
     if(GET_LEVEL(ch) > maxlev)
        return 4;
     /* Make sure alignment is less than stated */
     if(GET_ALIGNMENT(ch) < aless)
        return 5;
     /* Make sure alignment is greater than stated */
     if(GET_ALIGNMENT(ch) > agreater)
        return 6;
  
     /* Let's subclass them */
  
     /* Get leveled percentage */
     oldpct = GET_EXP(ch)/(double)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)));
  
     /* Change the class */
     GET_CLASS(ch) = subclass;
  
     /* Fix the exp */
     GET_EXP(ch) = (long)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) * oldpct);
  
     /* Update the skills */
     update_skills(ch);
  
     /* This is from old hubis code, I guess it can stay */
     check_regen_rates(ch);
  
     return 100;
  }

a144 1
  int subclassok =0;
d146 3
a148 1
  int i,minlev,maxlev,aless,agreater;
d152 2
d163 1
a163 4
			    if (!strcmp(vlist->name,"can_subclass") && !strncmp(vlist->value,GET_NAME(ch),strlen(GET_NAME(ch))))
				    subclassok=1;

			    if (!strcmp(vlist->name,"use_subclass"))
d167 1
a167 1
					    if (!strcmp(strip_ansi(class_abbrevs[i]),vlist->value))
d175 1
d178 1
a178 5
	            remove_var(&((qm->script)->global_vars),"can_subclass");
		    remove_var(&((qm->script)->global_vars),"use_subclass");

		    if (subclass == 0)
			    return;
d180 1
a180 1
		    if (subclassok)
a181 2
			    minlev=10;
			    maxlev=25;
d226 16
a241 22
			    aless = -1000;
			    agreater = 1000;
			    if (subclass == CLASS_DIABOLIST || subclass == CLASS_NECROMANCER || subclass == CLASS_ANTI_PALADIN)
			    {
				    aless=-1000;
				    agreater=-650;
			    }
			    if (subclass == CLASS_PRIEST || subclass == CLASS_PALADIN)
			    {
				    aless=650;
				    agreater=1000;
			    }
			    switch(subclasser(ch,GET_CLASS(ch),subclass,minlev,maxlev,aless,agreater))
			    {
				    case 1:	mudlog("Player in subclass attempts to subclass!",NRM,LVL_GOD,FALSE); break;
				    case 2:	mudlog("Class of player != class of player???",NRM,LVL_GOD,FALSE);break;
				    case 3:	send_to_char("You don't have enough experience to subclass yet.",ch);break;
				    case 4:	send_to_char("You have missed the opportunity to subclass, your level is too high!",ch);break;
				    case 5:	send_to_char("You are not righteous enough to achieve this subclass!",ch);break;
				    case 6:	send_to_char("You are not evil enough to achieve this subclass!",ch);break;
				    case 100:	send_to_char("Congratulations, you have subclassed successfully!",ch);break;
			    }
d3585 5
@


1.53
log
@re-instituted modified level command
required to re-implement "level gain"
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.52 2000/09/28 03:22:09 rsd Exp $
d42 5
d56 1
a56 1
int subclasser(struct char_data *ch, int original_class, int subclass, int minlev, int maxlev, int aless, int agreater, int objnum, struct char_data *mobile);
d70 1
a70 2
int subclasser(struct char_data *ch, int original_class, int subclass, int minlev, int maxlev,
                 int aless, int agreater, int objnum, struct char_data *mobile)
a72 1
     struct obj_data *qobj;
a91 3
     /* Make sure the object is being carried */
     if(!(qobj = get_obj_in_list_vnum(objnum, ch->carrying)))
        return 7;
a93 5
     /* Get rid of the object and do sematics */
     act("You give $p to $N.",TRUE,ch,qobj,mobile,TO_CHAR);
     act("$n gives $p to $N.",TRUE,ch,qobj,mobile,TO_ROOM);
     obj_from_char(qobj);
     extract_obj(qobj);
d187 5
a191 1
  void display_classes(struct descriptor_data *d, int select);
d195 106
a300 1
  display_classes(ch->desc, 0);
d3640 4
@


1.52
log
@made no gossip level 0
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.51 2000/06/04 03:59:07 rsd Exp $
d932 20
d3536 3
@


1.51
log
@altered summon mount so the mounts increase in strength as
the pally's increase in level and align.
The algorythm could use some tweaking, I'm open to suggestion
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.50 2000/05/21 23:55:59 rsd Exp $
d2401 1
a2401 1
    { "Nogossip",   LVL_GOSSIP, PRF_NOGOSS},  
d3516 5
@


1.50
log
@Altered do_prompt to point mortals at the display command.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.49 2000/05/10 22:09:24 rsd Exp $
d2867 3
a2869 3
  /* factor ranges from 0 to 25 (unlucky 351 align level 15 to lucky 1000 align level 50) */
  factor = BOUNDED(0, (GET_LEVEL(ch) - 18 + abs((GET_ALIGNMENT(ch) / 200)) + dice(2, 7)) / 2, 25);
  
d2873 2
a2874 1
  GET_MOVE(mount) += (int) (factor * 1.5);
d3516 3
@


1.49
log
@added a check to do_douse to check for fountains
in the room.  If there is a fountain in the room
the player automatically gets doused w/o any checks.
Cool eh? :)
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.48 2000/04/22 22:30:04 rsd Exp $
d2278 1
a2278 1
    send_to_char("Huh?!?\r\n", ch);
d3515 6
@


1.48
log
@Changed the comment header, also retabbed and braced sections of the code.
Altered toggle to show the numbers associated with wimpy and pagelength.
Also, toggle will return a message to the player if the toggle with a
bogus argument.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.47 2000/04/17 00:52:33 rsd Exp $
d1228 1
d1230 2
a1233 1
  
d1238 6
d1251 4
a1254 10
    }
    else {
      if((GET_SKILL(ch, SKILL_DOUSE)-10) < number(0,100)){
        act("$n&0 rolls around on the ground frantically in an attempt to douse the flames consuming $s body.",FALSE,ch,0,0,TO_ROOM);
        act("You roll around on the ground trying to douse the flames engulfing your body!",FALSE,ch,0,0,TO_CHAR);
        improve_skill(ch, SKILL_DOUSE);
      }
      else {
        act("$n&0 rolls on the ground frantically, finally dousing the fire that was consuming $m.",FALSE,ch,0,0,TO_ROOM);
        act("You roll around on the ground, finally dousing the flames that were consuming you.",FALSE,ch,0,0,TO_CHAR);
d1257 11
d1270 1
a1270 2
  }
  else {
d1279 4
a1282 10
    if((GET_SKILL(ch, SKILL_DOUSE)-50) < number(0,100)){
      act("You frantically try to brush the flames from $N&0.",FALSE,ch,0,vict,TO_CHAR);
      act("$n&0 aids you, attempting to douse your flames.",FALSE,ch,0,vict,TO_VICT);
      act("$n&0 frantically attempts to brush the flames off $N&0.",FALSE,ch,0,vict,TO_NOTVICT);
      improve_skill(ch,SKILL_DOUSE);
    }
    else {
      act("You frantically try to brush the flames from $N&0. You finally put $M out!",FALSE,ch,0,vict,TO_CHAR);
      act("$n&0 aids you, finally putting your flames out!",FALSE,ch,0,vict,TO_VICT);
      act("$n&0 finally douses the flames that were consuming $N&0!",FALSE,ch,0,vict,TO_NOTVICT);
d1285 13
d1299 1
a1299 1
  }
d1301 1
a1301 1
}
d3515 6
@


1.47
log
@removed mana from do_display and made do prompt level 101
or higher.
@
text
@d1 3
a3 3
// $Id: act.other.c,v 1.46 2000/03/08 11:14:42 cso Exp $
/* ************************************************************************
 *   File: act.other.c                                   Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
d1291 1
a1291 3
  
  
  
d1299 13
a1311 15
  sprintf(buf,"&0&2&b%s has disbanded his group&0\r\n", GET_NAME(ch));
  for (f = ch->groupees; f; f = g) 
    {
      ch->groupees = f->next;	
      g = f->next;
      
      REMOVE_BIT(AFF_FLAGS(f->groupee), AFF_GROUP);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch,
	  0, f->groupee, TO_VICT);
      send_to_char(buf, f->groupee);
      f->groupee->groupmaster = NULL;
      
      free(f);
      
    }
d2467 25
a2491 27
	if (fields[i].level <= GET_LEVEL(ch))
	  {/*here if person has access to toggle*/
	    
	    zcount++;
	    
	    if (i == SCMD_WIMPY) {
	      if (zcount == 1) {
		sprintf(buf, "%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
	      } 
	      if (zcount == 2) {
		sprintf(buf, "%s %s%s%11s  %5s&0 | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
	      }  
	      if (zcount == 3) {
		sprintf(buf, "%s%s%s%11s  %5s&0\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
	      }
	      
	    } else {
	      
	      if ( zcount == 1) {
		sprintf(buf,"%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	      }
	      if ( zcount == 2) {
		sprintf(buf,"%s %s%s%11s  %5s&0 | ",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	      }
	      if (zcount == 3) {
		sprintf(buf,"%s%s%s%11s  %5s&0\r\n",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	      }		
d2494 9
d2504 8
a2511 2
	      send_to_char(buf, ch); 
	      zcount = 0;
d2513 13
a2525 1
	  }	
d2536 4
a2539 5
  if (GET_LEVEL(ch) < fields[l].level) 
    {
      send_to_char("You are not high enough level for that!\r\n", ch);
      return;
    }
d2608 24
a2631 13
      if (!*arg) 
	{
	  if (GET_WIMP_LEV(ch)) 
	    {
	      sprintf(buf, "Your current wimp level is %d hit points.\r\n", GET_WIMP_LEV(ch));
	      send_to_char(buf, ch);
	      return;
	    } 
	  else 
	    {
	      send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
	      return;
	    }
d2633 1
a2633 22
      if (isdigit(*arg)) 
	{
	  if ((wimp_lev = atoi(arg))) 
	    {
	      if (wimp_lev < 0)
		send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
	      else if (wimp_lev > GET_MAX_HIT(ch))
		send_to_char("That doesn't make much sense, now does it?\r\n", ch);
	      else 
		{
		  sprintf(buf, "Okay, you'll wimp out if you drop below %d hit points.\r\n", wimp_lev);
		  send_to_char(buf, ch);
		  GET_WIMP_LEV(ch) = wimp_lev;
		}
	    } 
	  else 
	    {
	      send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
	      GET_WIMP_LEV(ch) = 0;
	    }
	} 
      else
d2649 8
a2656 13
      if (!*arg) 
	{
	  if (ch->page_length) 
	    {
	      sprintf(buf, "Your current page length is %d.\r\n", (ch->page_length));
	      send_to_char(buf, ch);
	      return;
	    } 
	  else 
	    {
	      send_to_char("You page length is not valid. Tell a god.\r\n", ch);
	      return;
	    }
d2658 12
a2669 20
      if (isdigit(*arg)) 
	{
	  if ((page_length = atoi(arg))) 
	    {
	      if (page_length < 1)
		send_to_char("Invalid page length.\r\n", ch);
	      else if (page_length > 50)
		send_to_char("Max page length is 50 right now.\r\n", ch);
	      else 
		{
		  sprintf(buf, "Your new page length is %d lines.\r\n", page_length);
		  send_to_char(buf, ch);
		  ch->page_length = page_length;
		}
	    } 
	  else 
	    {
	      send_to_char("Page length restored to default (22 lines)\r\n", ch);
	      ch->page_length = 22;
	    }
d2671 5
a2675 1
      else
d2679 3
a2681 1
      log("SYSERR: Unknown subcmd in do_gen_toggle");
d3496 4
@


1.46
log
@do_steal only checked for gold. made it check all 4 coin types.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.45 1999/12/13 05:16:49 cso Exp $
d2200 1
a2200 1
    { "Stock Circle"		 , "&0%hhp %mmp %vmv>&0"
d2202 1
a2202 1
    { "Colorized Standard Circle", "&1&b%h&0&1hp &5&b%m&0&5mp &2&b%v&0&2mv&0>"
d2204 1
a2204 1
    { "Standard"		 , "&1&b%ph&0&1hp &6&b%pm&0&6mp &2&b%pv&0&2mv&0>"
d2208 1
a2208 1
      "hitp &6%m&0(&6&b%M&0)&7mana &2%v&0(&2&b%V&0)&7move&0>"
d2210 2
a2211 2
    { "FULL Feature2" ,
      "&2&b<&0&2%hh&0(&2&b%HH&0) &1%MM &2%vv&0(&2&b%VV&0)&2&b>%_&0<%t&0>:<&0%o&0>"    },
d2225 1
a2225 2
    send_to_char("Usage: display <number>\r\n"
		 "To create your own prompt, use _prompt <str>_.\r\n", ch);
d2258 7
a2264 1
ACMD(do_prompt) {
d3491 3
@


1.45
log
@made do_steal check the pk_allowed game setting
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.44 1999/11/28 22:44:48 cso Exp $
d760 2
a761 1
  int percent, gold, eq_pos,  ohoh = 0;
d763 3
d860 1
a860 1
      act("$n tries to steal gold from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
d864 22
a885 3
      gold = (int) ((GET_GOLD(vict) * number(1, 10)) / 100);
      gold = MIN(1782, gold);
      if (gold > 0) {
d888 26
a913 6
        if (gold > 1) {
	  sprintf(buf, "Bingo!  You got %d gold coins.\r\n", gold);
	  send_to_char(buf, ch);
	  improve_skill(ch, SKILL_STEAL);
	} else {
	  send_to_char("You manage to swipe a solitary gold coin.\r\n", ch);
d915 2
d918 1
a918 1
	send_to_char("You couldn't get any gold...\r\n", ch);
d920 1
d3486 3
@


1.44
log
@do_prompt: commented out a CREATE that was causing a mem leak
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.43 1999/10/06 17:55:24 rsd Exp $
d760 2
a761 2
  int percent, gold, eq_pos, pcsteal = 0, ohoh = 0;
  extern int pt_allowed;
d785 7
a791 1
  
d797 1
a797 4
  
  if (!pt_allowed && !IS_NPC(vict))
    pcsteal = 1;
  
d3440 3
@


1.43
log
@Removed the AFK code from the end of the prompt and moved
it to comm.c
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.42 1999/09/16 01:47:17 dce Exp $
d2225 2
a2226 1
  CREATE(GET_PROMPT(ch), char, strlen(argument) + 1);
d3437 4
@


1.42
log
@Song levels moved up.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.41 1999/09/14 00:27:17 dce Exp dce $
d2201 1
a2201 9
    free(GET_PROMPT(ch));

  if (PRF_FLAGGED(ch,PRF_AFK))
  {
    sprintf(buf,"%s <AFK>",def_prompts[i][1]);
    GET_PROMPT(ch) = str_dup(buf);
  }
  else
    GET_PROMPT(ch) = str_dup(def_prompts[i][1]);
d2203 2
d2225 2
a2226 7
  if (PRF_FLAGGED(ch,PRF_AFK))
  {
    sprintf(buf,"%s <AFK>",argument);
    GET_PROMPT(ch) = str_dup(buf);
  }
  else
    GET_PROMPT(ch) = str_dup(argument);
a2489 21
      /* modify prompt */
      if (PRF_FLAGGED(ch,PRF_AFK))
      {
        if (GET_PROMPT(ch))
        {
          sprintf(buf,"%s <AFK>",GET_PROMPT(ch));
          free(GET_PROMPT(ch));
          GET_PROMPT(ch) = str_dup(buf);
        }
      }
      else
      {
        if (GET_PROMPT(ch))
        {
          strncpy(buf,GET_PROMPT(ch),strlen(GET_PROMPT(ch)));
          /* this may screw up  if <AFK> is not last text in prompt..*/
          buf[strlen(GET_PROMPT(ch)) -6] = '\0';
          free(GET_PROMPT(ch));
          GET_PROMPT(ch) = str_dup(buf);
        }
      }
d3436 3
@


1.41
log
@Monks hit and dam toned down.
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.40 1999/09/10 00:49:52 mtp Exp $
d3046 4
a3049 4
  { "Regeneration",	1, 0, 0,	TAR_CHAR_ROOM | TAR_SELF_ONLY,	CLASS_MONK},
  { "Battle Hymn",	1, 0, 0,	TAR_CHAR_ROOM | TAR_SELF_ONLY,	CLASS_MONK},
  { "War Cry",		1, 0, 0,	TAR_CHAR_ROOM,	CLASS_MONK},
  { "Peace",		1, 0, 0,	TAR_CHAR_ROOM,	CLASS_MONK},
d3468 3
@


1.40
log
@an[4~[4~bandage can KILL now if done badly for too long
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.39 1999/09/10 00:01:53 mtp Exp mtp $
d3405 2
a3406 2
        af.duration = GET_LEVEL(ch)/9 + 1;
        af.modifier = GET_LEVEL(ch)/9 + 1;
d3413 2
a3414 2
        af.duration = GET_LEVEL(ch)/9 + 1;
        af.modifier = GET_LEVEL(ch)/9 + 1;
d3427 2
a3428 2
             af.duration = GET_LEVEL(ch)/20 + 1;
             af.modifier = GET_LEVEL(ch)/20 + 1;
d3435 2
a3436 2
             af.duration = GET_LEVEL(ch)/20 + 1;
             af.modifier = GET_LEVEL(ch)/20 + 1;   
d3468 3
@


1.39
log
@added a delay (for mortals) to bandage
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.38 1999/09/07 23:26:53 mtp Exp mtp $
d1507 1
d1566 7
d3468 3
@


1.38
log
@removed mana from 'print_group' output
@
text
@d1 1
a1 1
// $Id: act.other.c,v 1.37 1999/09/05 07:00:39 jimmy Exp mtp $
d1567 2
d3460 3
@


1.37
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d980 1
a980 1
      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dM %3dv/%3dV] [%s] (&0&2&bHead of group&0)", 
d983 1
a983 1
	      GET_HIT(k), CCUND(k,C_NRM), GET_MAX_HIT(k), GET_MANA(k), GET_MOVE(k), GET_MAX_MOVE(k), CLASS_ABBR(k));
d1008 1
a1008 1
      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dM %3dv/%3dV] [%s]", 
d1011 1
a1011 1
	      GET_HIT(f->groupee), CCUND(f->groupee,C_NRM), GET_MAX_HIT(f->groupee), GET_MANA(f->groupee), GET_MOVE(f->groupee), GET_MAX_MOVE(f->groupee), CLASS_ABBR(f->groupee));
d3457 4
a3460 1
// $Log$
@


1.36
log
@reverted to previous version to remove compile errors until they can be fixed
@
text
@d1 1
d3457 1
@


1.35
log
@remove mana from group output
@
text
@d979 1
a979 1
      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dv/%3dV] [%s] (&0&2&bHead of group&0)", 
d1007 1
a1007 1
      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dv/%3dV] [%s]", 
@


1.34
log
@added some IS_FIGHTING checks
@
text
@d979 1
a979 1
      sprintf(buf, "%s%-15s &0[%s%3d&0&8h&0/%s%3d&0&8H&0 %3dM %3dv/%3dV] [%s] (&0&2&bHead of group&0)", 
d1007 1
a1007 1
      sprintf(buf, "%s%-15s&0 [%s%3d&0&7&bh&0/%s%3d&0&7&bH&0 %3dM %3dv/%3dV] [%s]", 
@


1.33
log
@Allow camping to be seen in normal syslog.
@
text
@d134 5
d291 4
d406 1
a406 1
  if (GET_ACTION(ch)) {
d571 4
d661 4
d765 4
d1180 4
d1508 5
d2720 4
d2829 4
d2960 4
@


1.32
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d495 2
a496 2
  sprintf(buf, "%s camped out", GET_NAME(ch));
  mudlog(buf, CMP, LVL_GOD, TRUE);
@


1.31
log
@Qucik 
Qucick fix to a bug where players can get a free rippost
if they don't even have the skill.
@
text
@d104 1
a104 1
     GET_EXP(ch) = (int)(exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) * oldpct);
@


1.30
log
@Added <AFK> to players prompt if toggled AFK (includes changes of prompt)
@
text
@d748 5
@


1.29
log
@Sublass function
/
@
text
@d2156 8
a2163 1
  GET_PROMPT(ch) = str_dup(def_prompts[i][1]);
d2184 8
a2191 1
  GET_PROMPT(ch) = str_dup(argument);
d2193 2
a2194 1
  sprintf(buf, "Okay, set your prompt to: %s\r\n", GET_PROMPT(ch));
d2455 21
@


1.28
log
@fixed do gen toggle, thanks
fixed from printing double line at end, removed ooc and slowns
as well as case sensitivity. I'm so insensitive.
@
text
@d45 4
a48 1

d61 53
@


1.27
log
@Ok, removed the OOC from being a toggle, commented it out of
certain sections, and just cut it out of other parts of do_toggle.
@
text
@d2199 2
a2200 1
  extern int nameserver_is_slow;
d2205 1
a2205 1
    char level;
d2208 7
d2216 24
a2239 25
    { "nosummon",   LVL_IMMORT, PRF_SUMMONABLE},
    { "nohassle",   LVL_IMMORT, PRF_NOHASSLE},  
    { "brief",	    0,          PRF_BRIEF},
    { "compact",    0,          PRF_COMPACT},  
    { "tell",	    0,	        PRF_NOTELL},
    { "afk"       , 0,          PRF_AFK},
    { "noshout",    0,	        PRF_DEAF},
    { "nogossip",   LVL_GOSSIP, PRF_NOGOSS},  
    { "nocongratz", LVL_IMMORT,	PRF_NOGRATZ},
    { "nowiz",	    LVL_IMMORT, PRF_NOWIZ},  
    { "quest", 	    LVL_IMMORT, PRF_QUEST},  
    { "room",	    LVL_IMMORT, PRF_ROOMFLAGS},
    { "norepeat",   0,	        PRF_NOREPEAT},  
    { "holylight",  LVL_IMMORT, PRF_HOLYLIGHT},
    { "slowns",     LVL_GRGOD,  0},  
    { "autoexit",   0,          PRF_AUTOEXIT},
    { "nopeti",     LVL_IMMORT, PRF_NOPETI},  
    { "noname",	    LVL_IMMORT, PRF_NONAME},
    { "anon", 	    50,	        PRF_ANON},  
    { "showvnums",  LVL_IMMORT, PRF_SHOWVNUMS},
    { "wimpy",	    0,	        0},
    { "nicearea",   0,	        PRF_NICEAREA},
    { "vicious",    0,          PRF_VICIOUS},
    { "passive",    0,          PRF_PASSIVE},
    { "pagelength", 0,          0},
d2275 1
a2275 3
		/*14*/	{"Nameserver_is_slow changed to NO; IP addresses will now be resolved.\r\n",
			 "Nameserver_is_slow changed to YES; sitenames will no longer be resolved.\r\n"},
		/*15*/	{"Autoexits disabled.\r\n",
d2277 1
a2277 1
		/*16*/	{"You will now receive petitions from mortals!\r\n",
d2279 1
a2279 1
		/*17*/	{"Mortals now see your name!\r\n",
d2281 1
a2281 1
		/*18*/  {"You are no longer Anonymous\r\n",
d2283 1
a2283 1
		/*19*/  {"You will no longer see vnums.\r\n",
d2285 1
a2285 1
		/*20*/  {"",
d2287 1
a2287 1
		/*21*/  {"Your area spells will now hit your race align in towns.\r\n",
d2289 1
a2289 1
		/*22*/  {"You feel nice and no longer vicious.\r\n",
d2291 1
a2291 1
		/*23*/  {"You will now auto-engage upon being offensively cast upon.\r\n",
d2293 1
a2293 1
		/*24*/  {"",
d2295 1
a2295 1
		/*25*/	{"",
d2323 1
a2323 11

	    } else if (i == SCMD_SLOWNS) {
	      if (zcount == 1) {
		sprintf(buf, "%s%s%11s  %5s&0 |", (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
	      } 
	      if (zcount == 2) {
		sprintf(buf, "%s %s%s%11s  %5s&0 | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO")); 
	      }  
	      if (zcount == 3) {
		sprintf(buf, "%s%s%s%11s  %5s&0\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
	      }    
d2336 1
a2336 4
	    /*
sprintf(buf, "%s%s%-15s  %5s\r\n",
(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QBLU, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector))))); 
	    */
d2342 1
a2342 1
      if (zcount < 3) {
d2350 1
a2350 1
    if (!strncmp(field, fields[l].cmd, strlen(field)))
a2390 8

      /*  From when ooc was a toggle 
    case SCMD_OOC:
      gossip_channel_active = (gossip_channel_active + 1) % 2;
      result = gossip_channel_active;
      break;
      */

a2407 3
      break;
    case SCMD_SLOWNS:
      result = (nameserver_is_slow = !nameserver_is_slow);
@


1.26
log
@moved the ascii terminator in the toggle display and
added a header line above the cute format characters.
@
text
@d46 1
a46 1
extern int gossip_channel_active;
a2232 1
    { "ooc",        LVL_HEAD_B, 0},
d2290 2
a2291 2
		/*25*/	{"You have turned off the OOC (gossip) channel.\r\n",
			 "You have turned on the OOC (gossip) channel.\r\n"}};
d2318 1
a2318 12
	      
	      /* Added to allow for godly-control of Gossip --Selina 3-25-99 */
	    } else if (i == SCMD_OOC) {
	      if (zcount == 1) {
		sprintf(buf, "%s%s%11s  %5s&0 |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT,  fields[i].cmd, (gossip_channel_active ? "YES" : "NO"));
	      } 
	      if (zcount == 2) {
		sprintf(buf, "%s %s%s%11s  %5s&0 | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (gossip_channel_active ? "YES" : "NO"));
	      }  
	      if (zcount == 3) {
		sprintf(buf, "%s%s%s%11s  %5s&0\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd,  (gossip_channel_active ? "YES" : "NO"));
	      }
d2400 1
d2405 1
@


1.25
log
@Fixed do_group to check for consent of following npc's.  This was an
oversight on my part when fixing the command in the last ci.
gurlaek
@
text
@d2301 1
d2311 1
a2311 1
		sprintf(buf, "%s%s%11s&0  %5s |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
d2314 1
a2314 1
		sprintf(buf, "%s %s%s%11s&0  %5s | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
d2317 1
a2317 1
		sprintf(buf, "%s%s%s%11s&0  %5s\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));
d2323 1
a2323 1
		sprintf(buf, "%s%s%11s&0  %5s |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT,  fields[i].cmd, (gossip_channel_active ? "YES" : "NO"));
d2326 1
a2326 1
		sprintf(buf, "%s %s%s%11s&0  %5s | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (gossip_channel_active ? "YES" : "NO"));
d2329 1
a2329 1
		sprintf(buf, "%s%s%s%11s&0  %5s\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd,  (gossip_channel_active ? "YES" : "NO"));
d2333 1
a2333 1
		sprintf(buf, "%s%s%11s&0  %5s |", (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
d2336 1
a2336 1
		sprintf(buf, "%s %s%s%11s&0  %5s | ",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO")); 
d2339 1
a2339 1
		sprintf(buf, "%s%s%s%11s&0  %5s\r\n",buf,(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
d2344 1
a2344 1
		sprintf(buf,"%s%s%11s&0  %5s |",(PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
d2347 1
a2347 1
		sprintf(buf,"%s %s%s%11s&0  %5s | ",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
d2350 1
a2350 1
		sprintf(buf,"%s%s%s%11s&0  %5s\r\n",buf, (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QWHT, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
@


1.24
log
@fixed the problems with trophys not being updated when in a group.
This was A bug created by my cut and pasting when i fixed the
void * function pointer warnings. All better now :)
--gurlaek 7/7/1999
@
text
@d1551 2
a1552 2
  /* and crashing the mud. Why group NPC's anyway?                   */
  if(IS_NPC(newgroupee)) {
@


1.23
log
@Completely reworked the toggle command to make it easier to
read.  It's now 3 columns of stuff instead of that blue
one line stuff that scrolled off the screen.
Gurlaek showed me how to do it.
@
text
@d1550 6
a1555 1
  
@


1.22
log
@Ok, fixed do_quit to check for fighting and also not crash when mortally
wounded.  This was done in die() by checking for killer=NULL.
since no one killed you if you quit while morted the die code
didn't know how to deal with a NULL killer.
--Gurlaek 6/11/1999
@
text
@d2191 1
a2191 1
  int l, i;
d2291 1
a2291 1
  
d2296 1
a2296 2
      send_to_char("Usage: tog <value>\r\n", ch);
      send_to_char("      &u&6Toggle&0				 &u&6Setting&0\r\n", ch);			
d2300 55
a2354 12
	    if (i == SCMD_WIMPY)
	      sprintf(buf, "     %s%s%-15s			%5s&0\r\n", ((GET_WIMP_LEV(ch)) ? QBLD : QNRM), QBLU, fields[i].cmd, ((GET_WIMP_LEV(ch)) ? "YES" : "NO"));

            /* Added to allow for godly-control of Gossip --Selina 3-25-99 */
            else if (i == SCMD_OOC)
              sprintf(buf, "     %s%s%-15s			%5s&0\r\n", (gossip_channel_active ? QBLD : QNRM), QBLU, fields[i].cmd, (gossip_channel_active ? "YES" : "NO")); 

	    else if (i == SCMD_SLOWNS)
	      sprintf(buf, "     %s%s%-15s			%5s&0\r\n", ((nameserver_is_slow) ? QBLD : QNRM), QBLU, fields[i].cmd, ((nameserver_is_slow) ? "YES" : "NO"));
	    else
	      sprintf(buf, "     %s%s%-15s			%5s\r\n", (PRF_FLAGGED(ch, (fields[i].bitvector)) ? QBLD : QNRM), QBLU, fields[i].cmd, (YESNO(PRF_FLAGGED(ch, (fields[i].bitvector)))));
	    send_to_char(buf, ch);
d2356 5
@


1.21
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d161 7
a167 3
  if (subcmd != SCMD_QUIT && GET_LEVEL(ch) < LVL_IMMORT)
    send_to_char("You have to type quit--no less, to quit!\r\n", ch);
  else if (GET_POS(ch) == POS_FIGHTING)
d169 6
a174 1
  else if (GET_POS(ch) < POS_STUNNED) {
d176 2
d179 19
a197 21
  } else {
    if (!GET_INVIS_LEV(ch))
      act("$n has left the game.", TRUE, ch, 0, 0, TO_ROOM);
    sprintf(buf, "%s has quit the game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    send_to_char("Goodbye, friend.. Come back soon!\r\n", ch);
    
    /*
     * kill off all sockets connected to the same player as the one who is
     * trying to quit.  Helps to maintain sanity as well as prevent duping.
     */
    for (d = descriptor_list; d; d = next_d) {
      
      next_d = d->next;
      if (d == ch->desc)
        continue;
      if (d->character && (GET_IDNUM(d->character) == GET_IDNUM(ch)))
	{
	  
	  close_socket(d);
	}
d199 1
a199 9
    save_room = ch->in_room;
    if (free_rent && GET_LEVEL(ch) >= 100) {
      Crash_rentsave(ch, 0);
    } else {
      GET_COPPER(ch) = 0;
      GET_SILVER(ch) = 0;
      GET_GOLD(ch) = 0;
      GET_PLAT(ch) = 0;
    }    
d201 15
a215 1
    GET_LOADROOM(ch) = world[ch->in_room].number;
d217 2
a218 8
    
    /* If someone is quitting in their house, let them load back here */
    if (ROOM_FLAGGED(save_room, ROOM_HOUSE))
      save_char(ch, save_room);

    extract_char(ch);   /*swapped banyal*/
    
  }
@


1.20
log
@made summon mount level 15 instead of 25 in the
if (GET_LEVEL(ch) < XX) statement
@
text
@d100 1
a100 1
  if(vict->guarded_by)
d109 1
d1869 2
a1870 1
		  if (ch->in_room == f->groupee->in_room)	
d1879 1
@


1.19
log
@Fixed some typos
@
text
@d2569 1
a2569 1
  if (GET_LEVEL(ch) < 25) {
@


1.18
log
@made toggeling of autoexits level 0 as opposed to
LVL_IMMORT or whatever it was before.
@
text
@d2541 1
a2541 1
    sprintf(buf, "&0&6You petition, '&0&b&6%s&0&6'&0", argument);
@


1.17
log
@Allow players to drop all eq and quit.
@
text
@d2206 1
a2206 1
    { "autoexit",   LVL_IMMORT, PRF_AUTOEXIT},
@


1.16
log
@made anonymous level 50
@
text
@d141 2
d145 6
d152 8
d190 1
a190 1
    if (free_rent)
d192 8
a199 1
    
a200 2
    GET_LOADROOM(ch) = world[ch->in_room].number;
    extract_char(ch);   /*swapped banyal*/
d205 2
@


1.15
log
@fixed camp crashbug.  This occured when someone type camp twice.
I added checks to EVENTFUNC(camp_event) to determine if someone was
already camping, and also NULLed freed pointers SCREAM!.  Seems to work
fine.  --Gurlaek.
@
text
@d2186 1
a2186 1
    { "anon", 	    10,	        PRF_ANON},  
@


1.14
log
@Removed some things temporarly until they can be fixed.
@
text
@d308 1
a308 1
  /*if (GET_ACTION(ch)) {
d311 1
a311 1
    }*/
d359 4
a362 1

a378 1
    GET_ACTION(ch) = NULL; 
d383 1
d386 3
a388 2
  
  if (GET_POS(ch) == POS_FIGHTING) {
d392 1
d399 1
d412 5
a417 2
  /* free(GET_ACTION(ch));
   */free(event_obj);   
@


1.13
log
@Fixed a toggle bug... JEN II
Was allowing proper lvl players to toggle, but not displaying
anything except stuff available to ppl BELOW your lvl
@
text
@d194 3
@


1.12
log
@Added a mortal gossip channel with 103+ godly control
@
text
@d2252 1
a2252 1
	if (fields[i].level < GET_LEVEL(ch))
@


1.11
log
@Adjusts chant semantics
@
text
@d46 3
d2163 1
a2163 1
    { "nogossip",   LVL_IMMORT, PRF_NOGOSS},  
d2181 1
d2183 1
d2236 1
a2236 2
			 "You will no longer auto-engage upon being offensively cast upon.\r\n"}
		,
d2238 4
a2241 1
			 ""}};
d2256 5
d2311 6
@


1.10
log
@Chant semantics added.
@
text
@d2888 12
d2904 2
a2915 6
  if (ch->player_specials->saved.chant > 0)
  {
     send_to_char("You've already chanted once within the past 4 hours.\r\n", ch);
     return;
  }
 
a2943 6
  if (GET_SKILL(ch, SKILL_CHANT) == 0)
    {  
      send_to_char("You imitate a monk chanting...Monkey see, Monkey do.\r\n", ch);
      return;
    }
     
a3039 3
  act("$n begins chanting in a deep voice.", TRUE, ch, 0, 0, TO_ROOM);
  send_to_char("You begin chanting in a deep voice.\r\n", ch);

d3079 1
a3079 1
            }
d3139 3
@


1.9
log
@Chant finishes and wearoff messages.
@
text
@d2890 2
a2891 1
      send_to_char("Sing what where?\r\n", ch);
d3038 2
a3039 1
  act("$n starts chanting in a deep voice.", TRUE, ch, 0, 0, TO_ROOM);
d3077 2
a3078 2
              act("You stop chanting in the middle of the song!", FALSE, ch, 0, 0, TO_CHAR);
              act("$n stops chanting in the middle of the song!",FALSE, ch, 0, 0, TO_ROOM);
d3102 2
a3103 2
                act("You stop chanting in the middle of the song!", FALSE, ch, 0, 0, TO_CHAR);
                act("$n stops chanting in the middle of the song!",FALSE, ch, 0, 0, TO_ROOM);
d3122 2
a3123 2
            send_to_char("You lost your concentration!\r\n", ch);
            act("$n stops chanting abruptly!", TRUE, ch, 0, 0, TO_ROOM);
d3157 2
a3158 2
	send_to_char("Regen affect message to go here!\r\n", ch);
        act("To room message for Regen!", FALSE, ch, 0, 0, TO_ROOM);
d3179 2
a3180 2
	send_to_char("Battle Hymn affect message to go here!\r\n", ch);
        act("To room message for Battle Hymn!", FALSE, ch, 0, 0, TO_ROOM);
d3201 2
a3202 4
             if (i == ch)
                send_to_char("War Cry semantics to be added\r\n", ch);
             else
                act("$n's song fills you with war rage!", FALSE, ch, 0, i, TO_VICT);
a3209 4
            if (i != ch)
               act("$n's song helps you find peace with your enemy!", FALSE, ch, 0, i, TO_VICT);
            else
               send_to_char("Your song helps you find peace with your enemy.\r\n", ch);
d3212 2
a3213 1
        send_to_char("Peace semantics\r\n", ch);
@


1.8
log
@Add's chant songs, and can only chant once every four hours
@
text
@d50 1
a50 1

d2802 1
d2804 1
d2806 6
a2811 6
  { "none",		0,	0,	0},
  { "Regeneration",	1,	0,	TAR_CHAR_ROOM},
  { "Battle Hymn",	1,	0,	TAR_CHAR_ROOM},
  { "War Cry",		1,	0,	TAR_CHAR_ROOM},
  { "Peace",		1,	0,	TAR_CHAR_ROOM},
  { "\n",		0,	0,	0}
d2948 1
a2948 1
  if (field[chantnum].targets == TAR_IGNORE)
d2954 1
a2954 1
        if (!target && ((field[chantnum].targets == TAR_CHAR_ROOM)))
d2961 1
a2961 1
        if (!target && (field[chantnum].targets == TAR_CHAR_WORLD))
d2966 1
a2966 1
        if (!target && (field[chantnum].targets == TAR_OBJ_INV))
d2971 1
a2971 1
        if (!target && (field[chantnum].targets == TAR_OBJ_EQUIP))
d2981 1
a2981 1
        if (!target && (field[chantnum].targets == TAR_OBJ_ROOM))  
d2986 1
a2986 1
        if (!target && (field[chantnum].targets == TAR_OBJ_WORLD))
d2994 1
a2994 1
          if (!target && (field[chantnum].targets == TAR_FIGHT_SELF))
d3001 1
a3001 1
          if (!target && (field[chantnum].targets == TAR_FIGHT_VICT))
d3009 1
a3009 1
          if (!target && (field[chantnum].targets == TAR_CHAR_ROOM) && !field[chantnum].violent)
d3017 1
a3017 1
              sprintf(buf, "Chant your song to %s?\r\n", field[chantnum].targets == (TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD) ? "what" : "whom");
d3041 1
d3145 3
a3147 1
	af.type = SKILL_CHANT;
d3159 3
a3161 1
	af.type = SKILL_CHANT;
d3169 1
a3169 1
	af.type = SKILL_CHANT;
d3182 22
a3203 20
           af.type = SKILL_CHANT;
           af.duration = GET_LEVEL(ch)/20 + 1;
           af.modifier = GET_LEVEL(ch)/20 + 1;
           af.location = APPLY_HITROLL;
           af.bitvector = 0;
           af.bitvector2 = 0;
           af.bitvector3 = 0;
           affect_to_char(i, &af);
           af.type = SKILL_CHANT;
           af.duration = GET_LEVEL(ch)/20 + 1;
           af.modifier = GET_LEVEL(ch)/20 + 1;   
           af.location = APPLY_DAMROLL;
           af.bitvector = 0;
           af.bitvector2 = 0;
           af.bitvector3 = 0;
           affect_to_char(i, &af);
           if (i == ch)
              send_to_char("War Cry semantics to be added\r\n", ch);
           else
              act("$n's song fills you with war rage!", FALSE, ch, 0, i, TO_VICT);
d3213 1
a3213 1
               send_to_char("Hrmm, should you see this?\r\n", ch);
d3221 8
@


1.7
log
@Chant added to, and songs craeted
@
text
@d2805 4
a2808 4
  { "regeneration",	0,	0,	TAR_CHAR_ROOM},
  { "battle hymn",	0,	0,	TAR_CHAR_ROOM},
  { "war cry",		110,	0,	TAR_CHAR_ROOM},
  { "peace",		0,	0,	TAR_CHAR_ROOM},
d2898 7
a2904 1
      
d3038 1
d3134 1
d3148 1
a3148 1
        af.bitvector3 = AFF3_HIT_REGEN;
d3152 56
@


1.6
log
@Added skeleton for chant skill
@
text
@d44 6
d2805 1
a2805 1
  { "regeneration",	0,	0,	TAR_SELF_ONLY},
d2807 1
a2807 1
  { "war cry",		0,	0,	TAR_CHAR_ROOM},
d2813 21
a2879 8
  if (MOB_FLAGGED(ch, MOB_CASTING))
    return;
  
  if(PLR_FLAGGED(ch, PLR_CASTING))
    {
      send_to_char("But you are already chanting!\r\n",ch);
      return;
    }
d3030 2
d3034 113
@


1.5
log
@Adds improve_skill calls so that players can imprve their skills.
@
text
@d43 2
a759 1
  void appear(struct char_data * ch);
d2792 221
@


1.4
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d111 1
d259 2
a260 1
  
d506 1
d512 2
a514 1
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d660 1
a660 1
    percent = 101;		/* Failure */
d715 1
d1419 1
@


1.3
log
@God loadrooms now set permanently until changed.
if you drop link however you come back where you
dropoped.
@
text
@d2145 1
a2145 1
    { "noauction",  LVL_IMMORT,	PRF_NOAUCT},  
d2181 2
a2182 2
		/*05*/	{"You can now hear auctions.\r\n",
			 "You are now deaf to auctions.\r\n"},
d2277 2
a2278 2
    case SCMD_NOAUCTION:
      result = PRF_TOG_CHK(ch, PRF_NOAUCT);
@


1.2
log
@removed some toggles from mortal chars
@
text
@d388 2
a389 1
  GET_LOADROOM(ch) = world[ch->in_room].number;
@


1.1
log
@Initial revision
@
text
@d2139 26
a2164 26
                /*00*/	{ "nosummon",		0,		PRF_SUMMONABLE},
		/*01*/	{ "nohassle", 	LVL_IMMORT, PRF_NOHASSLE},  
		/*02*/	{ "brief",		0,			PRF_BRIEF},
		/*03*/	{ "compact", 	0,			PRF_COMPACT},  
		/*04*/	{ "tell",		0,			PRF_NOTELL},
		/*05*/	{ "noauction", 	0,			PRF_NOAUCT},  
		/*06*/	{ "noshout",	0,			PRF_DEAF},
		/*07*/	{ "nogossip", 	0,			PRF_NOGOSS},  
		/*08*/	{ "nocongratz",	0,			PRF_NOGRATZ},
		/*09*/	{ "nowiz",	 	0,			PRF_NOWIZ},  
		/*10*/	{ "quest", 		0,			PRF_QUEST},  
		/*11*/	{ "room",		LVL_IMMORT,	PRF_ROOMFLAGS},
		/*12*/	{ "norepeat", 	0,			PRF_NOREPEAT},  
		/*13*/	{ "holylight",	LVL_IMMORT,	PRF_HOLYLIGHT},
		/*14*/	{ "slowns", 	LVL_GRGOD,	0},  
		/*15*/	{ "autoexit",	LVL_IMMORT, PRF_AUTOEXIT},
		/*16*/	{ "nopeti", 	LVL_IMMORT, PRF_NOPETI},  
		/*17*/	{ "noname",		LVL_IMMORT, PRF_NONAME},
		/*18*/	{ "anon", 		10,			PRF_ANON},  
                /*19*/	{ "showvnums",	LVL_IMMORT, PRF_SHOWVNUMS},
                /*20*/  { "wimpy",		0,			0},
                /*21*/  { "nicearea",	0,			PRF_NICEAREA},
                /*22*/  { "vicious",    0, PRF_VICIOUS},
                /*23*/  { "passive",    0, PRF_PASSIVE},
                /*24*/  { "pagelength", 0, 0},
                /*n*/	{ "\n",			0,			0}
@
