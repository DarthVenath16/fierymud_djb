head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2011.08.18.00.13.14;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.27.22.14.35;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.17.07.59.42;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.07.09.34.47;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.02.03.00.59;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.24.02.37.01;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.15.04.56.53;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.21.19.31.59;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.09.02.08.16;	author jps;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.08.23.55.53;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.15.06.49.52;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.15.03.18.19;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.31.05.36.19;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.17.23.59.16;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.08.05.06.58;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.30.05.06.24;	author jps;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.22.01.47.05;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.04.37.33;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.11.12.03.42;	author mtp;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.11.01.39.05;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.01.21.02.39;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.02.05.15;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/**************************************************************************
*  File: triggers.c                                                       *
*                                                                         *
*  Usage: contains all the trigger functions for scripts.                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 23:32:08 $
*  $Revision: 3.9 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "olc.h"

extern struct index_data **trig_index;
extern struct room_data *world;
extern char *dirs[];



/* external functions from scripts.c */
void add_var(struct trig_var_data **var_list, char *name, char *value);
int script_driver(void *go, trig_data *trig, int type, int mode);
char *matching_quote(char *p);
char *str_str(char *cs, char *ct);


/* mob trigger types */
char *trig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "Act",
  "Death",
  "Greet",
  "Greet-All",
  "Entry",
  "Receive",
  "Fight",
  "HitPrcnt",
  "Bribe",
  "\n"
};


/* obj trigger types */
char *otrig_types[] = {
  "Global",
  "Random",
  "Command",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "Get",
  "Drop",
  "Give",
  "Wear",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "\n"
};


/* wld trigger types */
char *wtrig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "UNUSED",
  "UNUSED",
  "Enter",
  "Drop",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "\n"
};


/*
 *  General functions used by several triggers
 */


/*
 * Copy first phrase into first_arg, returns rest of string
 */
char *one_phrase(char *arg, char *first_arg)
{
    skip_spaces(&arg);

    if (!*arg)
	*first_arg = '\0';

    else if (*arg == '"')
    {
	char *p, c;

	p = matching_quote(arg);
	c = *p;
	*p = '\0';
	strcpy(first_arg, arg + 1);
	if (c == '\0')
	    return p;
	else
	    return p + 1;
    }

    else
    {
	char *s, *p;

	s = first_arg;
	p = arg;

	while (*p && !isspace(*p) && *p != '"')
	    *s++ = *p++;

	*s = '\0';
	return p;
    }

    return arg;
}


int is_substring(char *sub, char *string)
{
    char *s;

    if ((s = str_str(string, sub)))
    {
	int len = strlen(string);
	int sublen = strlen(sub);

	/* check front */
	if ((s == string || isspace(*(s - 1)) || ispunct(*(s - 1))) &&

	    /* check end */
	    ((s + sublen == string + len) || isspace(s[sublen]) ||
	     ispunct(s[sublen])))
	    return 1;
    }

    return 0;
}


/*
 * return 1 if str contains a word or phrase from wordlist.
 * phrases are in double quotes (").
 * if wrdlist is NULL, then return 1, if str is NULL, return 0.
 */
int word_check(char *str, char *wordlist)
{
    char words[MAX_INPUT_LENGTH], phrase[MAX_INPUT_LENGTH], *s;

    strcpy(words, wordlist);

    for (s = one_phrase(words, phrase); *phrase; s = one_phrase(s, phrase))
	if (is_substring(phrase, str))
	    return 1;

    return 0;
}



/*
 *  mob triggers
 */

void random_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_RANDOM) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RANDOM) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void bribe_mtrigger(char_data *ch, char_data *actor, int amount)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_BRIBE) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_BRIBE) && (amount >= GET_TRIG_NARG(t))) {

      sprintf(buf, "%d", amount);
      add_var(&GET_TRIG_VARS(t), "amount", buf);
      ADD_UID_VAR(buf, t, actor, "actor");
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int greet_mtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char_data *ch;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!SCRIPT_CHECK(ch, MTRIG_GREET | MTRIG_GREET_ALL) ||
	!AWAKE(ch) || FIGHTING(ch) || (ch == actor) ||
	AFF_FLAGGED(ch, AFF_CHARM))
      continue;

    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (((IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET) && CAN_SEE(ch, actor)) ||
	   IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) &&
	  !GET_TRIG_DEPTH(t) && (number(1, 100) <= GET_TRIG_NARG(t))) {
        add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]]);
	ADD_UID_VAR(buf, t, actor, "actor");
	return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
	break;
      }
    }
  }
  return 1;
}


int entry_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_ENTRY) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_ENTRY) && (number(1, 100) <= GET_TRIG_NARG(t))){
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
  return 1;
}


int command_mtrigger(char_data *actor, char *cmd, char *argument)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next) {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_COMMAND) && !AFF_FLAGGED(ch, AFF_CHARM)) {
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_COMMAND))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Command Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (!strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
	  ADD_UID_VAR(buf, t, actor, "actor");
	  skip_spaces(&argument);
	  add_var(&GET_TRIG_VARS(t), "arg", argument);

	  if (script_driver(ch, t, MOB_TRIGGER, TRIG_NEW))
	    return 1;
	}
      }
    }
  }

  return 0;
}


void speech_mtrigger(char_data *actor, char *str)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next)
  {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_SPEECH) && AWAKE(ch) &&
        !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_SPEECH))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Speech Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
             (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
          ADD_UID_VAR(buf, t, actor, "actor");
          add_var(&GET_TRIG_VARS(t), "speech", str);
          script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
          break;
        }
      }
  }
}


void act_mtrigger(char_data *ch, char *str, char_data *actor,
		  char_data *victim, obj_data *object,
		  obj_data *target, char *arg)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (SCRIPT_CHECK(ch, MTRIG_ACT) && !AFF_FLAGGED(ch, AFF_CHARM))
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next)  {
      if (!TRIGGER_CHECK(t, MTRIG_ACT))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Act Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }

      if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
           (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {

	if (actor)
	  ADD_UID_VAR(buf, t, actor, "actor");
	if (victim)
	  ADD_UID_VAR(buf, t, victim, "victim");
	if (object)
	  ADD_UID_VAR(buf, t, object, "object");
	if (target)
	  ADD_UID_VAR(buf, t, target, "target");
	if (arg) {
	  skip_spaces(&arg);
	  add_var(&GET_TRIG_VARS(t), "arg", arg);
	}
	script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
	break;
      }
    }
}


void fight_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_FIGHT) || !FIGHTING(ch) ||
      AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_FIGHT) &&
	(number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


void hitprcnt_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_HITPRCNT) || !FIGHTING(ch) ||
      AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_HITPRCNT) && GET_MAX_HIT(ch) &&
	(((GET_HIT(ch) * 100) / GET_MAX_HIT(ch)) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int receive_mtrigger(char_data *ch, char_data *actor, obj_data *obj)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_RECEIVE) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RECEIVE) &&
	(number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, obj, "object");
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int death_mtrigger(char_data *ch, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_DEATH) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_DEATH)) {

      if (actor)
	ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}



/*
 *  object triggers
 */

void random_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_RANDOM) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int get_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GET))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GET) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


/* checks for command trigger on specific object. assumes obj has cmd trig */
int cmd_otrig(obj_data *obj, char_data *actor, char *cmd,
	      char *argument, int type)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (obj && SCRIPT_CHECK(obj, OTRIG_COMMAND))
    for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, OTRIG_COMMAND))
        continue;

      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t))) {
        sprintf(buf,"SYSERR: O-Command Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }

      if (IS_SET(GET_TRIG_NARG(t), type) &&
          !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {

	ADD_UID_VAR(buf, t, actor, "actor");
	skip_spaces(&argument);
	add_var(&GET_TRIG_VARS(t), "arg", argument);

	if (script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW))
	  return 1;
      }
    }

  return 0;
}


int command_otrigger(char_data *actor, char *cmd, char *argument)
{
  obj_data *obj;
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    if (cmd_otrig(GET_EQ(actor, i), actor, cmd, argument, OCMD_EQUIP))
      return 1;

  for (obj = actor->carrying; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_INVEN))
      return 1;

  for (obj = world[IN_ROOM(actor)].contents; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_ROOM))
      return 1;

  return 0;
}


int wear_otrigger(obj_data *obj, char_data *actor, int where)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_WEAR))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_WEAR)) {
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int drop_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_DROP))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_DROP) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int give_otrigger(obj_data *obj, char_data *actor, char_data *victim)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GIVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GIVE) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, victim, "victim");
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}



/*
 *  world triggers
 */

void random_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RANDOM) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int enter_wtrigger(struct room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };

  if (!SCRIPT_CHECK(room, WTRIG_ENTER))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_ENTER) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]]);
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int command_wtrigger(char_data *actor, char *cmd, char *argument)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_COMMAND))
    return 0;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_COMMAND))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Command Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (!strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      skip_spaces(&argument);
      add_var(&GET_TRIG_VARS(t), "arg", argument);

      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 0;
}


void speech_wtrigger(char_data *actor, char *str)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_SPEECH))
    return;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_SPEECH))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Speech Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
         (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      add_var(&GET_TRIG_VARS(t), "speech", str);
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

int drop_wtrigger(obj_data *obj, char_data *actor)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DROP))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next)
    if (TRIGGER_CHECK(t, WTRIG_DROP) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, obj, "object");
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }

  return 1;
}
@


1.35
log
@Fix compiler warnings.
@
text
@/***************************************************************************
 * $Id: dg_triggers.c,v 1.34 2010/07/27 22:14:35 mud Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: dg_triggers.c                                  Part of FieryMUD *
 *  Usage: contains all the trigger functions for scripts.                 *
 *  $Author: mud $                                                         *
 *  $Date: 2010/07/27 22:14:35 $                                           *
 *  $Revision: 1.34 $                                                       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *                                                                         *
 *  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#define __DG_TRIGGERS_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "olc.h"
#include "constants.h"
#include "skills.h"
#include "math.h"
#include "directions.h"
#include "money.h"
#include "strings.h"

/* External variables */
extern const char *cmd_door[];


/* external functions from scripts.c */
void add_var(struct trig_var_data **var_list, const char *name, const char *value);
int script_driver(void *go_address, trig_data *trig, int type, int mode);


/* mob trigger types */
const char *trig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "Act",
  "Death",
  "Greet",
  "Greet-All",
  "Entry",
  "Receive",
  "Fight",
  "HitPrcnt",
  "Bribe",
  "SpeechTo*",
  "Load",
  "Cast",
  "Leave",
  "Door",
  "UNUSED",
  "Time",
  "\n"
};


/* obj trigger types */
const char *otrig_types[] = {
  "Global",
  "Random",
  "Command",
  "UNUSED",
  "UNUSED",
  "Timer",
  "Get",
  "Drop",
  "Give",
  "Wear",
  "UNUSED",
  "Remove",
  "UNUSED",
  "UNUSED",
  "Load",
  "Cast",
  "Leave",
  "UNUSED",
  "Consume",
  "Time",
  "\n"
};


/* wld trigger types */
const char *wtrig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "UNUSED",
  "Reset",
  "Preentry",
  "Drop",
  "Postentry",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "Cast",
  "Leave",
  "Door",
  "UNUSED",
  "Time",
  "\n"
};


/*
 *  General functions used by several triggers
 */

bool char_susceptible_to_triggers(struct char_data *ch)
{
   if (!ch || GET_INVIS_LEV(ch))
      return FALSE;
   else
      return TRUE;
}

int is_substring(char *sub, char *string)
{
  const char *s;

  if ((s = str_str(string, sub)))
    {
      int len = strlen(string);
      int sublen = strlen(sub);

      /* check front */
      if ((s == string || isspace(*(s - 1)) || ispunct(*(s - 1))) &&

          /* check end */
          ((s + sublen == string + len) || isspace(s[sublen]) ||
           ispunct(s[sublen])))
        return 1;
    }

  return 0;
}


/*
 * return 1 if str contains a word or phrase from wordlist.
 * phrases are in double quotes (").
 * if wrdlist is NULL, then return 1, if str is NULL, return 0.
 */
int word_check(char *str, char *wordlist)
{
  char words[MAX_INPUT_LENGTH], phrase[MAX_INPUT_LENGTH], *s;

  if (*wordlist == '*')
    return 1;

  strcpy(words, wordlist);

  for (s = delimited_arg(words, phrase, '"'); *phrase;
       s = delimited_arg(s, phrase, '"'))
    if (is_substring(phrase, str))
      return 1;

  return 0;
}



/*
 *  mob triggers
 */

/*
 * MOBILE RANDOM
 *
 * Checked every 13 seconds.  Treats each trigger's numeric argument as
 * a percentage chance to run each time it's checked.  Only one random
 * trigger will be executed.
 */
void random_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_RANDOM) ||
        !char_susceptible_to_triggers(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RANDOM) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

/*
 * MOBILE BRIBE
 *
 * Checked whenever coins are given to a mobile.  The bribe trigger only
 * executes if the total value of the coins is higher than the "raw
 * value" given by the trigger's numeric arg.  It expects a four-integer
 * array for platinum, gold, silver, and copper.  Only one bribe trigger
 * will be executed.
 */
void bribe_mtrigger(char_data *ch, char_data *actor, int coins[])
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int raw_value;
  int type;

  raw_value = 1000 * coins[PLATINUM] + 100 * coins[GOLD] +
               10 * coins[SILVER] + coins[COPPER];

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_BRIBE) ||
        !char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_BRIBE) && (raw_value >= GET_TRIG_NARG(t))) {
      sprintf(buf, "%d", raw_value);
      add_var(&GET_TRIG_VARS(t), "value", buf);
      for (type = 0; type < NUM_COIN_TYPES; ++type) {
        sprintf(buf, "%d", coins[type]);
        add_var(&GET_TRIG_VARS(t), COIN_NAME(type), buf);
      }
      ADD_UID_VAR(buf, t, actor, "actor");
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

/*
 * MOBILE GREET
 *
 * Checked whenever the actor enters a room from the given direction.
 * Each mobile can have multiple greet triggers, and all mobiles with
 * great triggers in the room will be checked.
 * Returns TRUE if the entry should be allowed and FALSE otherwise.
 * Quits immediately if either the mobile is extracted or the actor
 * is killed.
 */
int greet_mtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char_data *ch, *next_in_room;
  char buf[MAX_INPUT_LENGTH];
  int ret_val = TRUE;

  if (!char_susceptible_to_triggers(actor))
    return 1;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = next_in_room) {
      next_in_room = ch->next_in_room;
    if (!MOB_PERFORMS_SCRIPTS(ch) ||
        !SCRIPT_CHECK(ch, MTRIG_GREET | MTRIG_GREET_ALL) ||
        !AWAKE(ch) || FIGHTING(ch) || (ch == actor))
      continue;

    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (((IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET) && CAN_SEE(ch, actor)) ||
           IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) &&
          !GET_TRIG_DEPTH(t) && (number(1, 100) <= GET_TRIG_NARG(t))) {
        add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]]);
        ADD_UID_VAR(buf, t, actor, "actor");
        if (!script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW))
          ret_val = FALSE;
        if (!ch || DECEASED(actor))
          return FALSE;
      }
    }
  }
  return ret_val;
}


/*
 * MOBILE ENTRY
 *
 * Checked whenever ch attempts to enter a room with vnum destination.
 * Returns TRUE if the entry should be allowed and FALSE otherwise.
 */
int entry_mtrigger(char_data *ch, int destination)
{
  trig_data *t;

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_ENTRY) ||
        !char_susceptible_to_triggers(ch))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_ENTRY) && (number(1, 100) <= GET_TRIG_NARG(t))){
      sprintf(buf, "%d", destination);
      add_var(&GET_TRIG_VARS(t), "destination", buf);
      if (!script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW) || !ch)
        return FALSE;
    }
  }
  return TRUE;
}


/*
 * MOBILE COMMAND
 *
 * Checked whenever a command is typed.  Checks all mobiles in the room
 * for command triggers, and the first matching command trigger is used.
 * Command triggers with "*" for arguments match all commands.
 * Returns TRUE if the normal command action should be blocked, and
 * FALSE otherwise.
 */
int command_mtrigger(char_data *actor, char *cmd, char *argument)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor))
    return 0;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next) {
    ch_next = ch->next_in_room;

    if (MOB_PERFORMS_SCRIPTS(ch) && SCRIPT_CHECK(ch, MTRIG_COMMAND)) {
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_COMMAND))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf, "SYSERR: Command Trigger #%d has no text argument!",
                  GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_ATTENDANT, TRUE);
          continue;
        }

        if (*GET_TRIG_ARG(t) == '*' ||
            !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
          ADD_UID_VAR(buf, t, actor, "actor");
          skip_spaces(&argument);
          add_var(&GET_TRIG_VARS(t), "arg", argument);
          skip_spaces(&cmd);
          add_var(&GET_TRIG_VARS(t), "cmd", cmd);

          return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
        }
      }
    }
  }

  return 0;
}


void speech_mtrigger(char_data *actor, char *str)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor))
    return;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next)
  {
    ch_next = ch->next_in_room;

    if (MOB_PERFORMS_SCRIPTS(ch) &&
          (SCRIPT_CHECK(ch, MTRIG_SPEECH) || SCRIPT_CHECK(ch, MTRIG_SPEECHTO)) &&
        AWAKE(ch) && actor != ch)
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_SPEECH) && !TRIGGER_CHECK(t, MTRIG_SPEECHTO))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Speech Trigger #%d has no text argument!",
              GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_GOD, TRUE);
          continue;
        }

        if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
            (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
          ADD_UID_VAR(buf, t, actor, "actor");
          add_var(&GET_TRIG_VARS(t), "speech", str);
          script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
          break;
        }
      }
  }
}

/* ch is the vict from ask/whisper/tell, ie the mob */
void speech_to_mtrigger(char_data *actor, char_data *ch, char *str)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return;

  if (MOB_PERFORMS_SCRIPTS(ch) &&
      (SCRIPT_CHECK(ch, MTRIG_SPEECHTO) || SCRIPT_CHECK(ch, MTRIG_SPEECH)) &&
      AWAKE(ch) && actor != ch)
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, MTRIG_SPEECHTO) && !TRIGGER_CHECK(t, MTRIG_SPEECH))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Speech-to Trigger #%d has no text argument!",
                GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_GOD, TRUE);
        continue;
      }

      if ((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
          (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str))) {
        ADD_UID_VAR(buf, t, actor, "actor");
        add_var(&GET_TRIG_VARS(t), "speech", str);
        script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
        break;
      }
    }
}



void act_mtrigger(char_data *ch, char *str, char_data *actor,
                  char_data *victim, obj_data *object,
                  obj_data *target, char *arg)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor))
    return;

  if (MOB_PERFORMS_SCRIPTS(ch) && SCRIPT_CHECK(ch, MTRIG_ACT))
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next)  {
      if (!TRIGGER_CHECK(t, MTRIG_ACT))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Act Trigger #%d has no text argument!",
                GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_GOD, TRUE);
        continue;
      }

      if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
           (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {

        if (actor)
          ADD_UID_VAR(buf, t, actor, "actor");
        if (victim)
          ADD_UID_VAR(buf, t, victim, "victim");
        if (object)
          ADD_UID_VAR(buf, t, object, "object");
        if (target)
          ADD_UID_VAR(buf, t, target, "target");
        if (arg) {
          skip_spaces(&arg);
          add_var(&GET_TRIG_VARS(t), "arg", arg);
        }
        script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
        break;
      }
    }
}


void fight_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_FIGHT) ||
        !FIGHTING(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_FIGHT) &&
        (number(1, 100) <= GET_TRIG_NARG(t))){
      if (FIGHTING(ch))
        ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
      else
        add_var(&GET_TRIG_VARS(t), "actor", "nobody");
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


void hitprcnt_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_HITPRCNT) ||
        !FIGHTING(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_HITPRCNT) && GET_MAX_HIT(ch) &&
        (((GET_HIT(ch) * 100) / GET_MAX_HIT(ch)) <= GET_TRIG_NARG(t))) {

      if (FIGHTING(ch))
        ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
      else
        add_var(&GET_TRIG_VARS(t), "actor", "nobody");
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

int receive_mtrigger(char_data *ch, char_data *actor, obj_data *obj)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_RECEIVE) ||
        !char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (IS_SET(GET_TRIG_TYPE(t), MTRIG_RECEIVE)) {
      if (GET_TRIG_DEPTH(t)) {
        /* The receive trigger is currently executing */
        act("$N isn't ready to accept $p.", FALSE, actor, obj, ch, TO_CHAR);
        return 0;
      } else if (number(1, 100) <= GET_TRIG_NARG(t)) {
        ADD_UID_VAR(buf, t, actor, "actor");
        ADD_UID_VAR(buf, t, obj, "object");
        return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      }
    }
  }

  return 1;
}


int death_mtrigger(char_data *ch, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_DEATH) ||
        (actor && !char_susceptible_to_triggers(actor)) ||
        !char_susceptible_to_triggers(ch))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_DEATH)) {

      if (actor)
        ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void load_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_LOAD) || !char_susceptible_to_triggers(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_LOAD) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }

}


int cast_mtrigger(char_data *actor, char_data *ch, int spellnum)
{
  trig_data *t;

  if (ch == NULL)
    return 1;

  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_CAST) ||
      !char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return 1;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_CAST) &&
        number(1, 100) <= GET_TRIG_NARG(t)) {
      ADD_UID_VAR(buf, t, actor, "actor");
      sprintf(buf, "%d", spellnum);
      add_var(&GET_TRIG_VARS(t), "spellnum", buf);
      add_var(&GET_TRIG_VARS(t), "spell", skill_name(spellnum));
      return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int leave_mtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char_data *ch;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor))
    return 1;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_LEAVE) ||
        !AWAKE(ch) || FIGHTING(ch) || ch == actor)
      continue;

    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (TRIGGER_CHECK(t, MTRIG_LEAVE) && CAN_SEE(ch, actor) &&
          number(1, 100) <= GET_TRIG_NARG(t)) {
        if (dir >= 0 && dir < NUM_OF_DIRS)
          add_var(&GET_TRIG_VARS(t), "direction", dirs[dir]);
        else
          add_var(&GET_TRIG_VARS(t), "direction", "none");
        ADD_UID_VAR(buf, t, actor, "actor");
        return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      }
    }
  }
  return 1;
}


int door_mtrigger(char_data *actor, int subcmd, int dir)
{
  trig_data *t;
  char_data *ch;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor))
    return 1;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_DOOR) ||
        !AWAKE(ch) || FIGHTING(ch) || ch == actor ||
        !CAN_SEE(ch, actor))
      continue;

    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (TRIGGER_CHECK(t, MTRIG_DOOR) && number(1, 100) <= GET_TRIG_NARG(t)) {
        add_var(&GET_TRIG_VARS(t), "cmd", cmd_door[subcmd]);
        add_var(&GET_TRIG_VARS(t), "direction", dirs[dir]);
        ADD_UID_VAR(buf, t, actor, "actor");
        return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      }
    }
  }

  return 1;
}


void time_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  /* This trigger is called if the hour is the same as specified in Narg. */
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_TIME) ||
        !char_susceptible_to_triggers(ch))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_TIME) &&
        (time_info.hours == GET_TRIG_NARG(t))) {
      sprintf(buf, "%d", time_info.hours);
      add_var(&GET_TRIG_VARS(t), "time", buf);
      script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}



/*
 *  object triggers
 */

void random_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_RANDOM) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int timer_otrigger(struct obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_TIMER))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next)
    if (TRIGGER_CHECK(t, OTRIG_TIMER) &&
        number(1, 100) <= GET_TRIG_NARG(t))
      return script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);

  return 1;
}


int get_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GET) || !char_susceptible_to_triggers(actor))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GET) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      /* Don't allow a get to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) && obj);
    }
  }

  return 1;
}


/* checks for command trigger on specific object. assumes obj has cmd trig */
int cmd_otrig(obj_data *obj, char_data *actor, char *cmd,
              char *argument, int type)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (obj && SCRIPT_CHECK(obj, OTRIG_COMMAND))
    for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, OTRIG_COMMAND))
        continue;

      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t))) {
        sprintf(buf,"SYSERR: O-Command Trigger #%d has no text argument!",
                GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_GOD, TRUE);
        continue;
      }

      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (*GET_TRIG_ARG(t) == '*' ||
           !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd)))) {

        ADD_UID_VAR(buf, t, actor, "actor");
        skip_spaces(&argument);
        add_var(&GET_TRIG_VARS(t), "arg", argument);
        skip_spaces(&cmd);
        add_var(&GET_TRIG_VARS(t), "cmd", cmd);

        return script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
      }
    }

  return 0;
}


int command_otrigger(char_data *actor, char *cmd, char *argument)
{
  obj_data *obj;
  int i;

  if (!char_susceptible_to_triggers(actor))
    return 1;

  for (i = 0; i < NUM_WEARS; i++)
    if (cmd_otrig(GET_EQ(actor, i), actor, cmd, argument, OCMD_EQUIP))
      return 1;

  for (obj = actor->carrying; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_INVEN))
      return 1;

  for (obj = world[IN_ROOM(actor)].contents; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_ROOM))
      return 1;

  return 0;
}


int wear_otrigger(obj_data *obj, char_data *actor, int where)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_WEAR) || !char_susceptible_to_triggers(actor))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_WEAR)) {
      sprintf(buf,"%d",where);
      add_var(&GET_TRIG_VARS(t), "position", buf);
      ADD_UID_VAR(buf, t, actor, "actor");
      /* Don't allow a wear to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) && obj);
    }
  }

  return 1;
}


int drop_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !SCRIPT_CHECK(obj, OTRIG_DROP))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_DROP) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      /* Don't allow a drop to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) && obj);
    }
  }

  return 1;
}

int remove_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !SCRIPT_CHECK(obj, OTRIG_REMOVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_REMOVE) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      /* Don't allow a remove to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) && obj);
    }
  }

  return 1;
}


int give_otrigger(obj_data *obj, char_data *actor, char_data *victim)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !SCRIPT_CHECK(obj, OTRIG_GIVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GIVE) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, victim, "victim");
      /* Don't allow a give to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) &&
              obj && obj->carried_by == actor);
    }
  }

  return 1;
}


void load_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_LOAD))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_LOAD) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
      return;
    }
  }
}


int cast_otrigger(char_data *actor, obj_data *obj, int spellnum)
{
  trig_data *t;
  char buf[16];

  if (obj == NULL || !char_susceptible_to_triggers(actor))
    return 1;

  if (!SCRIPT_CHECK(obj, OTRIG_CAST))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_CAST) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      sprintf(buf, "%d", spellnum);
      add_var(&GET_TRIG_VARS(t), "spellnum", buf);
      add_var(&GET_TRIG_VARS(t), "spell", skill_name(spellnum));
      return script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int leave_otrigger(room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int final = 1;
  obj_data *obj, *obj_next;

  if (!char_susceptible_to_triggers(actor))
    return 1;

  for (obj = room->contents; obj; obj = obj_next) {
    obj_next = obj->next_content;
    if (!SCRIPT_CHECK(obj, OTRIG_LEAVE))
      continue;

    for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
      if (TRIGGER_CHECK(t, OTRIG_LEAVE) &&
          (number(1, 100) <= GET_TRIG_NARG(t))) {
        if (dir >=0 && dir < NUM_OF_DIRS)
          add_var(&GET_TRIG_VARS(t), "direction", dirs[dir]);
        else
          add_var(&GET_TRIG_VARS(t), "direction", "none");
        ADD_UID_VAR(buf, t, actor, "actor");
        if (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) == 0)
          final = 0;
      }
    }
  }

  return final;
}


int consume_otrigger(obj_data *obj, char_data *actor, int cmd)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !SCRIPT_CHECK(obj, OTRIG_CONSUME))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_CONSUME)) {
      ADD_UID_VAR(buf, t, actor, "actor");
      switch (cmd) {
      /*
       * This is kind of a hack, since eat, drink, and quaff
       * are subcommands of different commands.  However,
       * they are fortunately distinct numbers.
       */
      case SCMD_EAT: /* 0 */
        add_var(&GET_TRIG_VARS(t), "command", "eat");
        break;
      case SCMD_DRINK: /* 2 */
        add_var(&GET_TRIG_VARS(t), "command", "drink");
        break;
      case SCMD_QUAFF: /* 1 */
        add_var(&GET_TRIG_VARS(t), "command", "quaff");
        break;
      }
      /* Don't allow a consume to take place, if the object is purged. */
      return (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) && obj);
    }
  }

  return 1;
}

void time_otrigger(obj_data *obj)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_TIME))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_TIME) &&
        (time_info.hours == GET_TRIG_NARG(t))) {
      sprintf(buf, "%d", time_info.hours);
      add_var(&GET_TRIG_VARS(t), "time", buf);
      script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

/*
 *  world triggers
 */

void random_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RANDOM) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int preentry_wtrigger(struct room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };

  if (!SCRIPT_CHECK(room, WTRIG_PREENTRY) || !char_susceptible_to_triggers(actor))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_PREENTRY) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]]);
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

int postentry_wtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };
  struct room_data *room = &world[IN_ROOM(actor)];

  if (!SCRIPT_CHECK(room, WTRIG_POSTENTRY) || !char_susceptible_to_triggers(actor))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_POSTENTRY) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]]);
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


void reset_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RESET))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RESET) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int command_wtrigger(char_data *actor, char *cmd, char *argument)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_COMMAND) ||
        !char_susceptible_to_triggers(actor))
    return 0;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_COMMAND))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf, "SYSERR: W-Command Trigger #%d has no text argument!",
              GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      continue;
    }

    if (*GET_TRIG_ARG(t) == '*' ||
        !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      skip_spaces(&argument);
      add_var(&GET_TRIG_VARS(t), "arg", argument);
      skip_spaces(&cmd);
      add_var(&GET_TRIG_VARS(t), "cmd", cmd);
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 0;
}


void speech_wtrigger(char_data *actor, char *str)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_SPEECH) ||
        !char_susceptible_to_triggers(actor))
    return;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_SPEECH))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Speech Trigger #%d has no text argument!",
              GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      continue;
    }

    if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
        (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
      ADD_UID_VAR(buf, t, actor, "actor");
      add_var(&GET_TRIG_VARS(t), "speech", str);
      script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

int drop_wtrigger(obj_data *obj, char_data *actor)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int ret_val;

  if (!SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DROP) ||
       !char_susceptible_to_triggers(actor))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next)
    if (TRIGGER_CHECK(t, WTRIG_DROP) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, obj, "object");
      ret_val = script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
      if (obj->carried_by != actor)
        return 0;
      else
        return ret_val;
    }

  return 1;
}

int cast_wtrigger(char_data *actor, char_data *vict, obj_data *obj, int spellnum)
{
  room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_CAST) ||
        !char_susceptible_to_triggers(actor))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_CAST) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, actor, "actor");
      if (vict)
        ADD_UID_VAR(buf, t, vict, "victim");
      if (obj)
        ADD_UID_VAR(buf, t, obj, "object");
      sprintf(buf, "%d", spellnum);
      add_var(&GET_TRIG_VARS(t), "spellnum", buf);
      add_var(&GET_TRIG_VARS(t), "spell", skill_name(spellnum));
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

int leave_wtrigger(struct room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(room, WTRIG_LEAVE) || !char_susceptible_to_triggers(actor))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_LEAVE) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[dir]);
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

int door_wtrigger(char_data *actor, int subcmd, int dir)
{
  room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DOOR) ||
        !char_susceptible_to_triggers(actor))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_DOOR) &&
        (number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "cmd", cmd_door[subcmd]);
      add_var(&GET_TRIG_VARS(t), "direction", (char *)dirs[dir]);
      ADD_UID_VAR(buf, t, actor, "actor");
      return script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void time_wtrigger(struct room_data *room)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(room, WTRIG_TIME))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_TIME) &&
        (time_info.hours == GET_TRIG_NARG(t))) {
      sprintf(buf, "%d", time_info.hours);
      add_var(&GET_TRIG_VARS(t), "time", buf);
      script_driver(&room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


/***************************************************************************
 * $Log: dg_triggers.c,v $
 * Revision 1.34  2010/07/27 22:14:35  mud
 * Fix death triggers on mobs when not killed by player.
 *
 * Revision 1.33  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.32  2009/03/17 07:59:42  jps
 * Moved str_str to strings.c
 *
 * Revision 1.31  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.30  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.29  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.28  2009/03/07 09:34:47  jps
 * Changed name of room Entry trigger to Preentry. Added a Postentry room trigger type.
 *
 * Revision 1.27  2008/09/02 03:00:59  jps
 * Changed mob speech and ask triggers to respond to all speech.
 *
 * Revision 1.26  2008/08/24 02:37:01  myc
 * Fix function signature for reference to external function str_str.
 *
 * Revision 1.25  2008/08/15 04:56:53  jps
 * Exempt characters from triggers if they wouldn't be detectable.
 *
 * Revision 1.24  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.23  2008/03/21 19:31:59  jps
 * Prevent giving objects to mobs with running receive triggers.
 *
 * Revision 1.22  2008/03/09 02:08:16  jps
 * Fix logic in command_mtrigger.
 *
 * Revision 1.21  2008/03/08 23:55:53  jps
 * Use MOB_PERFORMS_SCRIPTS macro instead of checking for CHARM
 * affection.
 *
 * Revision 1.20  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.19  2008/02/02 04:27:55  myc
 * Changing the way script_driver works: you now pass it a pointer
 * to the pointer of what you want to run the script.  That is,
 * script_driver(&ch, ...) instead of script_driver(ch, ...).
 * Adding several new trigger types: cast, leave, door, time, load,
 * and consume.
 *
 * Revision 1.18  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.17  2008/01/15 06:49:52  myc
 * When a mob had a trigger marked both ask and speech and the mob
 * was asked a question, that same trigger would be executed twice,
 * once as an ask trigger, and once as a speech trigger.  Fixed this
 * by going through the trigger list only once looking for ask or
 * speech triggers.  However, this isn't optimal--it should give
 * priority to ask triggers.
 *
 * Revision 1.16  2008/01/15 03:18:19  myc
 * Changed bribe_mtrigger to accept an array instead of a pointer.
 *
 * Revision 1.15  2007/11/18 16:51:55  myc
 * Fixing LVL_BUILDER references.
 *
 * Revision 1.14  2007/10/04 16:20:24  myc
 * Added object timer trigger.
 *
 * Revision 1.13  2007/08/31 05:36:19  jps
 * Add variable "destination" to mob Entry trigger.
 *
 * Revision 1.12  2007/04/17 23:59:16  myc
 * New trigger type: Load.  It goes off any time a mobile is loaded, whether
 * it be god command, zone command, or trigger command.
 *
 * Revision 1.11  2006/12/08 05:06:58  myc
 * Bribe triggers now give proper amounts and variables.
 *
 * Revision 1.10  2006/11/30 05:06:24  jps
 * Add remove trigger for objects
 *
 * Revision 1.9  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.8  2000/11/22 01:47:05  mtp
 * allow command triggers to run the command on completeion
 *
 * Revision 1.7  2000/11/21 04:37:33  rsd
 * Altered the comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.6  2000/11/11 12:03:42  mtp
 * made function ask_mtrigger() void cos it doesnt return anything
 *
 * Revision 1.5  2000/11/11 01:39:05  mtp
 * added ASK trigger for mobs
 *
 * Revision 1.4  2000/02/01 21:02:39  mtp
 * added a %position% variable to object 'wear' trigger
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 02:05:15  mud
 * Added fiery stuff to the comment header
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.34
log
@Fix death triggers on mobs when not killed by player.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.33 2009/03/20 13:56:22 jps Exp mud $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/20 13:56:22 $                                           *
 *  $Revision: 1.33 $                                                       *
d979 1
a979 1
        if (script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW) == 0);
d1318 3
@


1.33
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.32 2009/03/17 07:59:42 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/17 07:59:42 $                                           *
 *  $Revision: 1.32 $                                                       *
d569 2
a570 1
        !char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
d1318 3
@


1.32
log
@Moved str_str to strings.c
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.31 2009/03/09 20:36:00 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2009/03/09 20:36:00 $                                           *
 *  $Revision: 1.31 $                                                       *
d243 1
a243 1
        add_var(&GET_TRIG_VARS(t), coin_names[type], buf);
d1317 3
@


1.31
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.30 2009/03/09 05:41:31 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/09 05:41:31 $                                           *
 *  $Revision: 1.30 $                                                       *
d39 1
a47 1
const char *str_str(const char *cs, const char *ct);
d1317 3
@


1.30
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.29 2009/03/09 04:33:20 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/09 04:33:20 $                                           *
 *  $Revision: 1.29 $                                                       *
d228 1
d230 1
a230 1
  raw_value = 1000 * coins[PLAT] + 100 * coins[GOLD] +
d241 4
a244 8
      sprintf(buf, "%d", coins[PLAT]);
      add_var(&GET_TRIG_VARS(t), "platinum", buf);
      sprintf(buf, "%d", coins[GOLD]);
      add_var(&GET_TRIG_VARS(t), "gold", buf);
      sprintf(buf, "%d", coins[SILVER]);
      add_var(&GET_TRIG_VARS(t), "silver", buf);
      sprintf(buf, "%d", coins[COPPER]);
      add_var(&GET_TRIG_VARS(t), "copper", buf);
d1317 3
@


1.29
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.28 2009/03/07 09:34:47 jps Exp jps $
d8 2
a9 2
 *  $Date: 2009/03/07 09:34:47 $                                           *
 *  $Revision: 1.28 $                                                       *
d38 1
d1320 4
@


1.28
log
@Changed name of room Entry trigger to Preentry. Added a Postentry room trigger type.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.27 2008/09/02 03:00:59 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/09/02 03:00:59 $                                           *
 *  $Revision: 1.27 $                                                       *
d37 1
d1319 3
@


1.27
log
@Changed mob speech and ask triggers to respond to all speech.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.26 2008/08/24 02:37:01 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/08/24 02:37:01 $                                           *
 *  $Revision: 1.26 $                                                       *
d108 1
a108 1
  "Enter",
d110 1
a110 1
  "UNUSED",
d1064 22
a1085 1
int enter_wtrigger(struct room_data *room, char_data *actor, int dir)
d1090 1
d1092 1
a1092 1
  if (!SCRIPT_CHECK(room, WTRIG_ENTER) || !char_susceptible_to_triggers(actor))
d1096 1
a1096 1
    if (TRIGGER_CHECK(t, WTRIG_ENTER) &&
d1318 3
@


1.26
log
@Fix function signature for reference to external function str_str.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.25 2008/08/15 04:56:53 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/08/15 04:56:53 $                                           *
 *  $Revision: 1.25 $                                                       *
d63 1
a63 1
  "Ask",
d149 5
a153 5
	
	  /* check end */
	  ((s + sublen == string + len) || isspace(s[sublen]) ||
	   ispunct(s[sublen])))
	return 1;
d282 2
a283 2
	   IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) &&
	  !GET_TRIG_DEPTH(t) && (number(1, 100) <= GET_TRIG_NARG(t))) {
d285 1
a285 1
	ADD_UID_VAR(buf, t, actor, "actor");
d351 1
a351 1
		  GET_TRIG_VNUM(t));
d355 1
a355 1
	
d358 3
a360 3
	  ADD_UID_VAR(buf, t, actor, "actor");
	  skip_spaces(&argument);
	  add_var(&GET_TRIG_VARS(t), "arg", argument);
d363 3
a365 3
	
	  return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
	}
d387 3
a389 2
    if (MOB_PERFORMS_SCRIPTS(ch) && SCRIPT_CHECK(ch, MTRIG_SPEECH) &&
        AWAKE(ch) && actor!=ch)
d391 1
a391 1
        if (!TRIGGER_CHECK(t, MTRIG_SPEECH))
d412 34
d448 2
a449 2
		  char_data *victim, obj_data *object,
		  obj_data *target, char *arg)
d464 1
a464 1
		GET_TRIG_VNUM(t));
d471 16
a486 16
	
	if (actor)
	  ADD_UID_VAR(buf, t, actor, "actor");
	if (victim)
	  ADD_UID_VAR(buf, t, victim, "victim");
	if (object)
	  ADD_UID_VAR(buf, t, object, "object");
	if (target)
	  ADD_UID_VAR(buf, t, target, "target");
	if (arg) {
	  skip_spaces(&arg);
	  add_var(&GET_TRIG_VARS(t), "arg", arg);
	}	
	script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
	break;
      }	
d525 1
a525 1
	(((GET_HIT(ch) * 100) / GET_MAX_HIT(ch)) <= GET_TRIG_NARG(t))) {
a536 68

/* ch is the vict from ask/whisper, ie the mob */
void ask_mtrigger(char_data *actor, char_data *ch, char *str)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return;

  if (MOB_PERFORMS_SCRIPTS(ch) && SCRIPT_CHECK(ch, MTRIG_ASK) && AWAKE(ch) &&
      actor!=ch)
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, MTRIG_ASK))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Ask Trigger #%d has no text argument!",
                GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_GOD, TRUE);
        continue;
      }

      if ((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
          (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str))) {
        ADD_UID_VAR(buf, t, actor, "actor");
        add_var(&GET_TRIG_VARS(t), "speech", str);
        script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
        break;
      }
    }
}


/* ch is the vict from ask/whisper, ie the mob */
void ask_speech_mtrigger(char_data *actor, char_data *ch, char *str)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!char_susceptible_to_triggers(actor) || !char_susceptible_to_triggers(ch))
    return;

  if (MOB_PERFORMS_SCRIPTS(ch) &&
      (SCRIPT_CHECK(ch, MTRIG_ASK) || SCRIPT_CHECK(ch, MTRIG_SPEECH)) &&
      AWAKE(ch) && actor!=ch)
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, MTRIG_ASK) && !TRIGGER_CHECK(t, MTRIG_SPEECH))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Ask/Speech Trigger #%d has no text argument!",
                GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_GOD, TRUE);
        continue;
      }

      if ((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
          (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str))) {
        ADD_UID_VAR(buf, t, actor, "actor");
        add_var(&GET_TRIG_VARS(t), "speech", str);
        script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
        break;
      }
    }
}


d577 1
a577 1
	ADD_UID_VAR(buf, t, actor, "actor");
d724 1
a724 1
	(number(1, 100) <= GET_TRIG_NARG(t))) {
d770 1
a770 1
	      char *argument, int type)
d783 1
a783 1
		GET_TRIG_VNUM(t));
d791 4
a794 4
	
	ADD_UID_VAR(buf, t, actor, "actor");
	skip_spaces(&argument);
	add_var(&GET_TRIG_VARS(t), "arg", argument);
d797 2
a798 2
	
	return script_driver(&obj, t, OBJ_TRIGGER, TRIG_NEW);
d1056 1
a1056 1
	(number(1, 100) <= GET_TRIG_NARG(t))) {
d1075 1
a1075 1
	(number(1, 100) <= GET_TRIG_NARG(t))) {
d1120 1
a1120 1
	      GET_TRIG_VNUM(t));
d1157 1
a1157 1
	      GET_TRIG_VNUM(t));
d1186 1
a1186 1
	(number(1, 100) <= GET_TRIG_NARG(t))) {	
d1195 1
a1195 1
    }	
d1296 3
@


1.25
log
@Exempt characters from triggers if they wouldn't be detectable.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.24 2008/04/07 03:02:54 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/07 03:02:54 $                                           *
 *  $Revision: 1.24 $                                                       *
d45 1
a45 1
char *str_str(char *cs, char *ct);
d140 1
a140 1
  char *s;
d1329 3
@


1.24
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.23 2008/03/21 19:31:59 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/21 19:31:59 $                                           *
 *  $Revision: 1.23 $                                                       *
d130 7
d199 2
a200 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_RANDOM))
d230 2
a231 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_BRIBE))
d270 3
d307 2
a308 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_ENTRY))
d338 3
d380 3
d419 3
d509 3
d542 3
d575 2
a576 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_RECEIVE))
d602 2
a603 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_DEATH))
d622 1
a622 1
  if (!SCRIPT_CHECK(ch, MTRIG_LOAD))
d643 2
a644 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_CAST))
d668 1
a668 1
  if (actor == NULL)
d698 3
d727 2
a728 1
  if (!MOB_PERFORMS_SCRIPTS(ch) || !SCRIPT_CHECK(ch, MTRIG_TIME))
d786 1
a786 1
  if (!SCRIPT_CHECK(obj, OTRIG_GET))
d844 3
d868 1
a868 1
  if (!SCRIPT_CHECK(obj, OTRIG_WEAR))
d890 1
a890 1
  if (!SCRIPT_CHECK(obj, OTRIG_DROP))
d909 1
a909 1
  if (!SCRIPT_CHECK(obj, OTRIG_REMOVE))
d929 1
a929 1
  if (!SCRIPT_CHECK(obj, OTRIG_GIVE))
d968 1
a968 1
  if (obj == NULL)
d996 3
d1027 1
a1027 1
  if (!SCRIPT_CHECK(obj, OTRIG_CONSUME))
d1103 1
a1103 1
  if (!SCRIPT_CHECK(room, WTRIG_ENTER))
d1142 2
a1143 1
  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_COMMAND))
d1179 2
a1180 1
  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_SPEECH))
d1212 2
a1213 1
  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DROP))
d1239 2
a1240 1
  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_CAST))
d1268 1
a1268 1
  if (!SCRIPT_CHECK(room, WTRIG_LEAVE))
d1289 2
a1290 1
  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DOOR))
d1329 4
@


1.23
log
@Prevent giving objects to mobs with running receive triggers.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.22 2008/03/09 02:08:16 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/09 02:08:16 $                                           *
 *  $Revision: 1.22 $                                                       *
d276 1
a276 1
        if (!ch || GET_POS(actor) == POS_DEAD)
d1283 3
@


1.22
log
@Fix logic in command_mtrigger.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.21 2008/03/08 23:55:53 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/03/08 23:55:53 $                                           *
 *  $Revision: 1.21 $                                                       *
d551 10
a560 6
    if (TRIGGER_CHECK(t, MTRIG_RECEIVE) &&
	(number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, actor, "actor");
      ADD_UID_VAR(buf, t, obj, "object");
      return script_driver(&ch, t, MOB_TRIGGER, TRIG_NEW);
d1283 3
@


1.21
log
@Use MOB_PERFORMS_SCRIPTS macro instead of checking for CHARM
affection.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.20 2008/02/09 04:27:47 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/02/09 04:27:47 $                                           *
 *  $Revision: 1.20 $                                                       *
d328 1
a328 1
    if (!MOB_PERFORMS_SCRIPTS(ch) || SCRIPT_CHECK(ch, MTRIG_COMMAND)) {
d1279 4
@


1.20
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.19 2008/02/02 04:27:55 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/02/02 04:27:55 $                                           *
 *  $Revision: 1.19 $                                                       *
d50 1
a50 1
  "Global", 
d134 1
a134 1
  
d139 1
a139 1
      
d142 1
a142 1
	  
d148 1
a148 1
  
d164 1
a164 1
  
d166 1
a166 1
  
d171 1
a171 1
  
d185 1
a185 1
 * a percentage chance to run each time it's checked.  Only one random 
d191 2
a192 2
  
  if (!SCRIPT_CHECK(ch, MTRIG_RANDOM) || AFF_FLAGGED(ch, AFF_CHARM))
d194 1
a194 1
  
d196 2
a197 2
    if (TRIGGER_CHECK(t, MTRIG_RANDOM) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
d208 1
a208 1
 * executes if the total value of the coins is higher than the "raw 
d222 1
a222 1
  if (!SCRIPT_CHECK(ch, MTRIG_BRIBE) || AFF_FLAGGED(ch, AFF_CHARM))
d224 1
a224 1
  
d249 1
a249 1
 * great triggers in the room will be checked. 
d260 1
a260 1
 
d262 4
a265 4
    next_in_room = ch->next_in_room;
    if (!SCRIPT_CHECK(ch, MTRIG_GREET | MTRIG_GREET_ALL) || 
	!AWAKE(ch) || FIGHTING(ch) || (ch == actor) || 
	AFF_FLAGGED(ch, AFF_CHARM))
d267 1
a267 1
    
d270 1
a270 1
	   IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) && 
d294 2
a295 2
  
  if (!SCRIPT_CHECK(ch, MTRIG_ENTRY) || AFF_FLAGGED(ch, AFF_CHARM))
d297 1
a297 1
  
d324 1
a324 1
  
d327 2
a328 2
    
    if (SCRIPT_CHECK(ch, MTRIG_COMMAND) && !AFF_FLAGGED(ch, AFF_CHARM)) {
d332 1
a332 1
        
d347 1
a347 1
	  
d356 1
a356 1
  
d363 1
a363 1
  
d367 3
a369 3
    
    if (SCRIPT_CHECK(ch, MTRIG_SPEECH) && AWAKE(ch) &&
        !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
d373 1
a373 1
	
d376 1
a376 1
		  GET_TRIG_VNUM(t));
d380 1
a380 1
	
d393 1
a393 1
void act_mtrigger(char_data *ch, char *str, char_data *actor, 
d399 2
a400 2
  
  if (SCRIPT_CHECK(ch, MTRIG_ACT) && !AFF_FLAGGED(ch, AFF_CHARM))
d404 1
a404 1
      
d411 1
a411 1
      
d426 1
a426 1
	}	  
d438 3
a440 3
  
  if (!SCRIPT_CHECK(ch, MTRIG_FIGHT) || !FIGHTING(ch) || 
      AFF_FLAGGED(ch, AFF_CHARM))
d442 1
a442 1
  
d445 1
a445 1
	(number(1, 100) <= GET_TRIG_NARG(t))){
d461 3
a463 3
  
  if (!SCRIPT_CHECK(ch, MTRIG_HITPRCNT) || !FIGHTING(ch) ||
      AFF_FLAGGED(ch, AFF_CHARM))
d465 1
a465 1
  
d487 2
a488 2
  if (SCRIPT_CHECK(ch, MTRIG_ASK) && AWAKE(ch) &&
      !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
d492 1
a492 1
	
d499 1
a499 1
	
d517 3
a519 2
  if ((SCRIPT_CHECK(ch, MTRIG_ASK) || SCRIPT_CHECK(ch, MTRIG_SPEECH)) && 
      AWAKE(ch) && !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
d530 1
a530 1
	
d546 2
a547 2
  
  if (!SCRIPT_CHECK(ch, MTRIG_RECEIVE) || AFF_FLAGGED(ch, AFF_CHARM))
d549 1
a549 1
  
d553 1
a553 1
      
d559 1
a559 1
  
d568 2
a569 2
  
  if (!SCRIPT_CHECK(ch, MTRIG_DEATH) || AFF_FLAGGED(ch, AFF_CHARM))
d571 1
a571 1
  
d574 1
a574 1
      
d580 1
a580 1
  
d609 1
a609 1
  if (!SCRIPT_CHECK(ch, MTRIG_CAST) || AFF_FLAGGED(ch, AFF_CHARM))
d637 2
a638 3
    if (!SCRIPT_CHECK(ch, MTRIG_LEAVE) ||
        !AWAKE(ch) || FIGHTING(ch) || (ch == actor) ||
        AFF_FLAGGED(ch, AFF_CHARM))
d664 3
a666 3
    if (!SCRIPT_CHECK(ch, MTRIG_DOOR) ||
        !AWAKE(ch) || FIGHTING(ch) || (ch == actor) ||
        AFF_FLAGGED(ch, AFF_CHARM) || !CAN_SEE(ch, actor))
d689 1
a689 1
  if (!SCRIPT_CHECK(ch, MTRIG_TIME) || AFF_FLAGGED(ch, AFF_CHARM))
d712 1
a712 1
  
d715 1
a715 1
  
d717 1
a717 1
    if (TRIGGER_CHECK(t, OTRIG_RANDOM) && 
d746 1
a746 1
  
d749 1
a749 1
  
d757 1
a757 1
  
d768 1
a768 1
  
d773 1
a773 1
      
d781 1
a781 1
      
d795 1
a795 1
  
d804 1
a804 1
  
d808 1
a808 1
  
d812 1
a812 1
  
d816 1
a816 1
  
d825 1
a825 1
  
d828 1
a828 1
  
d838 1
a838 1
  
d847 1
a847 1
  
d850 1
a850 1
  
d858 1
a858 1
  
d866 1
a866 1
  
d869 1
a869 1
  
d877 1
a877 1
  
d886 1
a886 1
  
d889 1
a889 1
  
d899 1
a899 1
  
d1038 1
a1038 1
  
d1041 1
a1041 1
  
d1057 1
a1057 1
  
d1060 1
a1060 1
  
d1062 1
a1062 1
    if (TRIGGER_CHECK(t, WTRIG_ENTER) && 
d1069 1
a1069 1
  
d1096 1
a1096 1
  
d1099 1
a1099 1
  
d1104 1
a1104 1
    
d1111 1
a1111 1
    
d1122 1
a1122 1
  
d1132 1
a1132 1
  
d1135 1
a1135 1
  
d1140 1
a1140 1
    
d1147 1
a1147 1
    
d1164 1
a1164 1
  
d1167 1
a1167 1
  
d1169 1
a1169 1
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) 
d1172 1
a1172 1
      
d1181 1
a1181 1
  
d1279 3
@


1.19
log
@Changing the way script_driver works: you now pass it a pointer
to the pointer of what you want to run the script.  That is,
script_driver(&ch, ...) instead of script_driver(ch, ...).
Adding several new trigger types: cast, leave, door, time, load,
and consume.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.18 2008/01/29 21:02:31 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/29 21:02:31 $                                           *
 *  $Revision: 1.18 $                                                       *
d36 1
a36 1

d1279 7
@


1.18
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.17 2008/01/15 06:49:52 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/15 06:49:52 $                                           *
 *  $Revision: 1.17 $                                                       *
d35 6
d44 1
a44 2
int script_driver(void *go, trig_data *trig, int type, int mode);
char *matching_quote(char *p);
d65 5
d90 3
d94 2
d107 1
a107 1
  "UNUSED",
d117 5
a130 42
/*
 * Copy first phrase into first_arg, returns rest of string
 */
char *one_phrase(char *arg, char *first_arg)
{
  skip_spaces(&arg);
  
  if (!*arg)
    *first_arg = '\0';
  
  else if (*arg == '"')
    {
      char *p, c;
      
      p = matching_quote(arg);
      c = *p;
      *p = '\0';
      strcpy(first_arg, arg + 1);
      if (c == '\0')
	return p;
      else
	return p + 1;
    }
  
  else
    {
      char *s, *p;
      
      s = first_arg;
      p = arg;
      
      while (*p && !isspace(*p) && *p != '"')
	*s++ = *p++;
      
      *s = '\0';
      return p;
    }
  
  return arg;
}


d161 3
d167 2
a168 1
  for (s = one_phrase(words, phrase); *phrase; s = one_phrase(s, phrase))
d181 7
d198 1
a198 1
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d204 9
a212 2
/* Expects a four integer array for plat, gold, silver, and copper
   - myc 5 Dec 2006 */
d238 1
a238 1
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d244 10
a253 1

d257 1
a257 1
  char_data *ch;
d259 1
a259 1
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };
d261 2
a262 1
  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
d274 4
a277 2
	return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
	break;
d281 1
a281 1
  return 1;
d285 6
d302 2
a303 1
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d306 1
a306 1
  return 1;
d310 9
d334 1
a334 1
          sprintf(buf,"SYSERR: Command Trigger #%d has no text argument!",
d340 2
a341 1
        if (!strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
d345 2
d348 1
a348 1
	  return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d382 1
a382 1
             (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
d385 1
a385 1
          script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d427 1
a427 1
	script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d446 5
a450 3
      
      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
	script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d469 6
a474 3
      
      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor")
	script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d504 1
a504 1
        script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d534 1
a534 1
        script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d555 1
a555 1
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d576 1
a576 1
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d593 1
a593 1
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d601 103
d719 1
a719 1
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d736 1
a736 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d753 2
a754 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d783 2
a784 1
          !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
d789 2
d792 1
a792 1
	return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d834 2
a835 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d854 2
a855 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d873 2
a874 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d894 3
a896 1
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
d904 126
d1045 1
a1045 1
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
d1066 1
a1066 1
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
d1074 17
d1106 1
a1106 1
      sprintf(buf,"SYSERR: W-Command Trigger #%d has no text argument!",
d1112 2
a1113 1
    if (!strn_cmp(GET_TRIG_ARG(t), cmd, strlen(cmd))) {
d1117 3
a1119 2
      
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
d1149 1
a1149 1
         (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
d1152 1
a1152 1
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
d1163 1
d1175 5
a1179 2
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
d1185 92
d1279 4
@


1.17
log
@When a mob had a trigger marked both ask and speech and the mob
was asked a question, that same trigger would be executed twice,
once as an ask trigger, and once as a speech trigger.  Fixed this
by going through the trigger list only once looking for ask or
speech triggers.  However, this isn't optimal--it should give
priority to ask triggers.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.16 2008/01/15 03:18:19 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/15 03:18:19 $                                           *
 *  $Revision: 1.16 $                                                       *
d21 2
d34 1
a34 6

extern struct index_data **trig_index;
extern struct room_data *world;
extern char *dirs[];


d37 1
a37 1
void add_var(struct trig_var_data **var_list, char *name, char *value);
d44 1
a44 1
char *trig_types[] = {
d65 1
a65 1
char *otrig_types[] = {
d86 1
a86 1
char *wtrig_types[] = {
d894 8
@


1.16
log
@Changed bribe_mtrigger to accept an array instead of a pointer.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.15 2007/11/18 16:51:55 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/11/18 16:51:55 $                                           *
 *  $Revision: 1.15 $                                                       *
d452 1
a452 1
/* ch is the vict from ask/whisper, ie the mob*/
d458 12
a469 5
    if (SCRIPT_CHECK(ch, MTRIG_ASK) && AWAKE(ch) &&
        !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_ASK))
          continue;
d471 29
a499 6
        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Ask Trigger #%d has no text argument!",
		  GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_GOD, TRUE);
          continue;
        }
d501 6
a506 7
        if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
             (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
          ADD_UID_VAR(buf, t, actor, "actor");
          add_var(&GET_TRIG_VARS(t), "speech", str);
          script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
          break;
        }
d508 1
d510 2
d897 3
@


1.15
log
@Fixing LVL_BUILDER references.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.14 2007/10/04 16:20:24 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/10/04 16:20:24 $                                           *
 *  $Revision: 1.14 $                                                       *
d220 1
a220 1
void bribe_mtrigger(char_data *ch, char_data *actor, int *cPtr)
d226 2
a227 2
  raw_value = 1000 * cPtr[PLAT] + 100 * cPtr[GOLD] +
               10 * cPtr[SILVER] + cPtr[COPPER];
d236 1
a236 1
      sprintf(buf, "%d", cPtr[PLAT]);
d238 1
a238 1
      sprintf(buf, "%d", cPtr[GOLD]);
d240 1
a240 1
      sprintf(buf, "%d", cPtr[SILVER]);
d242 1
a242 1
      sprintf(buf, "%d", cPtr[COPPER]);
d865 3
@


1.14
log
@Added object timer trigger.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.13 2007/08/31 05:36:19 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/08/31 05:36:19 $                                           *
 *  $Revision: 1.13 $                                                       *
d315 1
a315 1
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
d353 1
a353 1
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
d384 1
a384 1
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
d467 1
a467 1
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
d613 1
a613 1
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
d792 1
a792 1
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
d826 1
a826 1
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
d865 3
@


1.13
log
@Add variable "destination" to mob Entry trigger.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.12 2007/04/17 23:59:16 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/04/17 23:59:16 $                                           *
 *  $Revision: 1.12 $                                                       *
d74 1
a74 1
  "UNUSED",
d562 16
d865 3
@


1.12
log
@New trigger type: Load.  It goes off any time a mobile is loaded, whether
it be god command, zone command, or trigger command.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.11 2006/12/08 05:06:58 myc Exp myc $
d8 2
a9 2
 *  $Date: 2006/12/08 05:06:58 $                                           *
 *  $Revision: 1.11 $                                                       *
d280 1
a280 1
int entry_mtrigger(char_data *ch)
d289 2
a291 1
      break;
d849 4
@


1.11
log
@Bribe triggers now give proper amounts and variables.
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.10 2006/11/30 05:06:24 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2006/11/30 05:06:24 $                                           *
 *  $Revision: 1.10 $                                                       *
d62 1
d82 2
d103 2
d521 17
d848 3
@


1.10
log
@Add remove trigger for objects
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.9 2002/09/13 02:32:10 jjl Exp jps $
d7 3
a9 3
 *  $Author: jjl $                                                         *
 *  $Date: 2002/09/13 02:32:10 $                                           *
 *  $Revision: 1.9 $                                                       *
d213 3
a215 1
void bribe_mtrigger(char_data *ch, char_data *actor, int amount)
d219 5
a223 1
  
d228 11
a238 4
    if (TRIGGER_CHECK(t, MTRIG_BRIBE) && (amount >= GET_TRIG_NARG(t))) {
      
      sprintf(buf, "%d", amount);
      add_var(&GET_TRIG_VARS(t), "amount", buf); 
d826 3
@


1.9
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_triggers.c,v 1.8 2000/11/22 01:47:05 mtp Exp $
d7 3
a9 3
 *  $Author: mtp $                                                         *
 *  $Date: 2000/11/22 01:47:05 $                                           *
 *  $Revision: 1.8 $                                                       *
d79 1
a79 1
  "UNUSED",
d640 18
d813 3
@


1.8
log
@allow command triggers to run the command on completeion
@
text
@d1 3
a3 1
// $Id: dg_triggers.c,v 1.7 2000/11/21 04:37:33 rsd Exp $
d7 3
a9 3
 *  $Author: rsd $                                                         *
 *  $Date: 2000/11/21 04:37:33 $                                           *
 *  $Revision: 1.7 $                                                       *
d793 29
a821 24
// $Log: dg_triggers.c,v $
// Revision 1.7  2000/11/21 04:37:33  rsd
// Altered the comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.6  2000/11/11 12:03:42  mtp
// made function ask_mtrigger() void cos it doesnt return anything
//
// Revision 1.5  2000/11/11 01:39:05  mtp
// added ASK trigger for mobs
//
// Revision 1.4  2000/02/01 21:02:39  mtp
// added a %position% variable to object 'wear' trigger
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 02:05:15  mud
// Added fiery stuff to the comment header
// Indented file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.7
log
@Altered the comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: dg_triggers.c,v 1.6 2000/11/11 12:03:42 mtp Exp $
d5 3
a7 3
 *  $Author: mtp $                                                         *
 *  $Date: 2000/11/11 12:03:42 $                                           *
 *  $Revision: 1.6 $                                                       *
d303 1
a303 2
	  if (script_driver(ch, t, MOB_TRIGGER, TRIG_NEW))
	    return 1;
d570 1
a570 2
	if (script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW))
	  return 1;
d792 4
@


1.6
log
@made function ask_mtrigger() void cos it doesnt return anything
@
text
@d1 1
a1 1
// $Id: dg_triggers.c,v 1.5 2000/11/11 01:39:05 mtp Exp mtp $
d3 1
a3 2
 *  File: dg_triggers.c                               NOW Part of FieryMUD *
 *                                                                         *
d5 3
d11 4
a16 4
 *                                                                         *
 *  $Author: mtp $                                                         *
 *  $Date: 2000/11/11 01:39:05 $                                           *
 *  $Revision: 1.5 $                                                       *
a21 1

d794 3
d805 7
@


1.5
log
@added ASK trigger for mobs
@
text
@d1 1
a1 1
// $Id: dg_triggers.c,v 1.4 2000/02/01 21:02:39 mtp Exp $
d13 2
a14 2
 *  $Date: 2000/02/01 21:02:39 $                                           *
 *  $Revision: 1.4 $                                                       *
d432 1
a432 1
int ask_mtrigger(char_data *actor, char_data *ch, char *str)
d793 3
@


1.4
log
@added a %position% variable to object 'wear' trigger
@
text
@d1 1
a1 1
// $Id: dg_triggers.c,v 1.3 1999/09/05 07:00:39 jimmy Exp mtp $
d12 3
a14 3
 *  $Author: jimmy $                                                         *
 *  $Date: 1999/09/05 07:00:39 $                                           *
 *  $Revision: 1.3 $                                                       *
d58 1
d431 28
d793 3
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d12 3
a14 3
 *  $Author: mud $                                                         *
 *  $Date: 1999/01/31 02:05:15 $                                           *
 *  $Revision: 1.2 $                                                       *
d581 2
d763 4
a766 1
// $Log$
@


1.2
log
@Added fiery stuff to the comment header
Indented file
@
text
@d1 1
d13 2
a14 2
 *  $Date: 1999/01/29 01:23:30 $                                           *
 *  $Revision: 1.1 $                                                       *
d761 1
@


1.1
log
@Initial revision
@
text
@d1 14
a14 14
/**************************************************************************
*  File: triggers.c                                                       *
*                                                                         *
*  Usage: contains all the trigger functions for scripts.                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 23:32:08 $
*  $Revision: 3.9 $
**************************************************************************/
d109 6
a114 6
    skip_spaces(&arg);

    if (!*arg)
	*first_arg = '\0';

    else if (*arg == '"')
d116 10
a125 10
	char *p, c;

	p = matching_quote(arg);
	c = *p;
	*p = '\0';
	strcpy(first_arg, arg + 1);
	if (c == '\0')
	    return p;
	else
	    return p + 1;
d127 2
a128 2

    else
d130 10
a139 10
	char *s, *p;

	s = first_arg;
	p = arg;
	
	while (*p && !isspace(*p) && *p != '"')
	    *s++ = *p++;

	*s = '\0';
	return p;
d141 2
a142 2

    return arg;
d148 3
a150 3
    char *s;

    if ((s = str_str(string, sub)))
d152 10
a161 10
	int len = strlen(string);
	int sublen = strlen(sub);
	
	/* check front */
	if ((s == string || isspace(*(s - 1)) || ispunct(*(s - 1))) &&

	    /* check end */
	    ((s + sublen == string + len) || isspace(s[sublen]) ||
	     ispunct(s[sublen])))
	    return 1;
d163 2
a164 2

    return 0;
d175 10
a184 1
    char words[MAX_INPUT_LENGTH], phrase[MAX_INPUT_LENGTH], *s;
a185 5
    strcpy(words, wordlist);
    
    for (s = one_phrase(words, phrase); *phrase; s = one_phrase(s, phrase))
	if (is_substring(phrase, str))
	    return 1;
a186 4
    return 0;
}

	
d195 1
a195 1

d198 1
a198 1

d215 1
a215 1

d218 1
a218 1

d279 1
a279 1

d282 1
a282 1

d290 1
a290 1
            GET_TRIG_VNUM(t));
d294 1
a294 1

d316 1
a316 1

d320 1
a320 1

d326 1
a326 1

d329 1
a329 1
            GET_TRIG_VNUM(t));
d333 1
a333 1

d357 1
a357 1

d360 1
a360 1
          GET_TRIG_VNUM(t));
d364 1
a364 1

d399 1
a399 1

d401 1
a401 1
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d420 1
a420 1

d422 1
a422 1
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
d433 1
a433 1

d440 1
a440 1

d446 1
a446 1

d461 1
a461 1

d467 1
a467 1

d480 1
a480 1

d483 1
a483 1

d498 1
a498 1

d501 1
a501 1

d508 1
a508 1

d524 1
a524 1
 
d528 1
a528 1
          GET_TRIG_VNUM(t));
d532 1
a532 1
       
d544 1
a544 1

d553 1
a553 1

d561 1
a561 1

d565 1
a565 1

d574 1
a574 1

d577 1
a577 1

d584 1
a584 1

d593 1
a593 1

d596 1
a596 1

d603 1
a603 1

d612 1
a612 1

d615 1
a615 1

d623 1
a623 1

d636 1
a636 1

d639 1
a639 1

d655 1
a655 1

d658 1
a658 1

d667 1
a667 1

d677 1
a677 1

d680 1
a680 1

d685 1
a685 1

d688 1
a688 1
        GET_TRIG_VNUM(t));
d692 1
a692 1

d711 1
a711 1

d714 1
a714 1

d719 1
a719 1

d722 1
a722 1
        GET_TRIG_VNUM(t));
d726 1
a726 1

d742 1
a742 1

d745 1
a745 1

d756 1
a756 1

d759 1
@
