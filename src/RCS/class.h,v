head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.07.20.07.26;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.06.18.55;	author jps;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.21.17.26.46;	author jps;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.09.23.00.13;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.26.23.35.43;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.27.12.10.46;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.27.11.16.33;	author jps;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.27.09.42.37;	author jps;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.06.17.33.58;	author jps;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.06.05.36.59;	author jps;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.05.23.05.32;	author jps;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.05.22.00.06;	author jps;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.05.20.31.18;	author jps;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.05.05.41.25;	author jps;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.03.12.44.39;	author jps;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.02.07.12.14;	author jps;	state Exp;
branches;
next	;


desc
@Class defines and data structures.
@


1.21
log
@Passing advance_level an enum for which action it should take
rather than using a boolean in order to reduce confusion.
@
text
@/***************************************************************************
 * $Id: class.h,v 1.20 2009/03/09 20:36:00 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *  File: class.h                                         Part of FieryMUD *
 *  Usage: header file for class structures and constants                  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#ifndef __FIERY_CLASS_H
#define __FIERY_CLASS_H

#define CLASS_UNDEFINED    -1
#define CLASS_SORCERER      0
#define CLASS_CLERIC        1
#define CLASS_THIEF         2
#define CLASS_WARRIOR       3
#define CLASS_PALADIN       4
#define CLASS_ANTI_PALADIN  5
#define CLASS_RANGER        6
#define CLASS_DRUID         7
#define CLASS_SHAMAN        8
#define CLASS_ASSASSIN      9
#define CLASS_MERCENARY    10
#define CLASS_NECROMANCER  11
#define CLASS_CONJURER     12
#define CLASS_MONK         13
#define CLASS_BERSERKER    14
#define CLASS_PRIEST       15
#define CLASS_DIABOLIST    16
#define CLASS_MYSTIC       17
#define CLASS_ROGUE        18
#define CLASS_BARD         19
#define CLASS_PYROMANCER   20
#define CLASS_CRYOMANCER   21
#define CLASS_ILLUSIONIST  22
#define CLASS_HUNTER       23
#define CLASS_LAYMAN       24
/* NUM_CLASSES defined in chars.h */

#include "chars.h"

#define CLASS_DEFAULT CLASS_LAYMAN

/* How do class members get spells ready to cast? */
#define MEM_NONE     -1
#define MEMORIZE      0
#define PRAY          1

/* This defines the basic attributes of a class. */

struct classdef {
   char name[80];             /* The unadorned name (i.e., without colors) */
   char altname[80];          /* An alternative name for searching purposes: anti-paladin and antipaladin */
   char displayname[80];      /* The name with colors and strategic capitalization */
   char plainname[80];        /* The name with capitalization, but no colors */
   char fmtname[80];          /* The full name, formatted to take up 12 spaces */
   char abbrev[80];           /* The three-character abbreviation, with colors */
   char stars[40];            /* The two asterisks for maxed-out mortals, with colors */
   bool magical;              /* Do they cast spells? */
   int mem_mode;              /* Memorize or pray? */
   bool active;               /* Whether this class is available to mortals */
   bool is_subclass;          /* Is it a subclass of any other class? */
   int subclass_of;           /* The class that it's a subclass of */
   int max_subclass_level;    /* Highest level at which you can subclass (if base class) */
   int homeroom;              /* Room you'll start in.  Used in character creation only. */
   int statorder[NUM_STATS];  /* When generating a new character, which stats should be highest? */
   int saves[NUM_SAVES];      /* Class-related base saving throws */
   int hp_lev;                /* How many hit points gained per level */
   int thac0;                 /* How good you are at hitting people. Lower=better */
   int nowear_flag;           /* What ITEM_ flag will prevent wearing an object? */
   int hit_regen_factor;      /* Factor: 100 = normal regen */
   int mana_regen_factor;
   int mv_regen_factor;
   double exp_gain_factor;    /* Exp factor: 1 = normal exp needed to gain a level */

   /* The following values primarily adjust stats on mob prototypes.  See db.c. */
   int exp_factor;
   int hit_factor;
   int hd_factor;
   int dice_factor;
   int copper_factor;
   int ac_factor;

   int newbie_eq[20];         /* Objects given to new player characters (in addition to common newbie eq */


   /*
    * The following data members should come last in the struct so
    * that they can be omitted when classes are being defined.  Their
    * values are filled in init_classes at runtime.
    */

   /* List of permanent effect flags */
   flagvector effect_flags[FLAGVECTOR_SIZE(NUM_EFF_FLAGS)];
};

extern struct classdef classes[];
extern int class_ok_race[][NUM_CLASSES];

#define VALID_CLASSNUM(num) (num < NUM_CLASSES)
#define VALID_CLASS(ch) \
   VALID_CLASSNUM(GET_CLASS(ch))
#define CLASS_ABBR(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].abbrev : "--")
#define CLASS_FULL(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].displayname : "--")
#define CLASS_WIDE(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].fmtname : "--")
#define CLASS_STARS(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].stars: "**")
#define CLASS_NAME(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].name : "--")
#define CLASS_PLAINNAME(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].plainname : "--")
#define MEM_MODE(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].mem_mode : MEM_NONE)

#define HIT_REGEN_FACTOR(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].hit_regen_factor : 100)
#define MANA_REGEN_FACTOR(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].mana_regen_factor : 100)
#define MV_REGEN_FACTOR(ch) \
   (VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].mv_regen_factor : 100)
#define EXP_GAIN_FACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].exp_gain_factor : 1)

#define CLASS_EXPFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].exp_factor : 100)
#define CLASS_HITFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].hit_factor : 100)
#define CLASS_HDFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].hd_factor : 100)
#define CLASS_DICEFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].dice_factor : 100)
#define CLASS_COPPERFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].copper_factor : 100)
#define CLASS_ACFACTOR(cls) \
   (VALID_CLASSNUM(cls) ? classes[cls].ac_factor : 100)

#define IS_MAGIC_USER(ch) \
   (VALID_CLASS(ch) ? GET_CLASS(ch) == CLASS_SORCERER || \
    classes[(int)GET_CLASS(ch)].subclass_of == CLASS_SORCERER \
    : FALSE)
#define IS_CLERIC(ch) \
   (VALID_CLASS(ch) ? GET_CLASS(ch) == CLASS_CLERIC || \
    classes[(int)GET_CLASS(ch)].subclass_of == CLASS_CLERIC \
    : FALSE)
#define IS_ROGUE(ch) \
   (VALID_CLASS(ch) ? GET_CLASS(ch) == CLASS_ROGUE || \
    classes[(int)GET_CLASS(ch)].subclass_of == CLASS_ROGUE \
    : FALSE)
#define IS_WARRIOR(ch) \
   (VALID_CLASS(ch) ? GET_CLASS(ch) == CLASS_WARRIOR || \
    classes[(int)GET_CLASS(ch)].subclass_of == CLASS_WARRIOR \
    : FALSE)

/* Is this character prohibited from wearing this equipment due to a class
 * restriction?  Would return true if, for example, a warrior tried to wear
 * an object with the !WARRIOR wear flag. */
#define NOWEAR_CLASS(ch, obj) \
   (VALID_CLASS(ch) ? \
   classes[(int)GET_CLASS(ch)].nowear_flag && \
               OBJ_FLAGGED(obj, classes[(int)GET_CLASS(ch)].nowear_flag) : 0)

enum level_action {
  LEVEL_GAIN,
  LEVEL_LOSE
};

extern void init_classes(void);
extern void assign_class_skills(void);
extern int parse_class(struct char_data *ch, struct char_data *vict, char *arg);
extern int getbaseclass(int class);
extern void init_char_class(struct char_data *ch);
extern void update_char_class(struct char_data *ch);
extern void advance_level(struct char_data * ch, enum level_action);
extern void convert_class(struct char_data *ch, int newclass);
extern void roll_natural_abils(struct char_data *ch);
extern int return_max_skill(struct char_data *ch, int skill);
extern void give_newbie_eq(struct char_data *vict);

#endif

/***************************************************************************
 * $Log: class.h,v $
 * Revision 1.20  2009/03/09 20:36:00  myc
 * Added RCS ids.
 *
 ***************************************************************************/
@


1.20
log
@Added RCS ids.
@
text
@d2 1
a2 1
 * $Id: class.h,v $
d172 5
d183 1
a183 1
extern void advance_level(struct char_data * ch, bool gaining);
d193 3
@


1.19
log
@Added macro for getting a class's ** string.
@
text
@d2 3
d186 3
@


1.18
log
@Can't see that any purpose is served by returning MEM_NONE for NPCs
when you query MEM_MODE.
@
text
@d113 2
@


1.17
log
@Changed VALID_CLASSNUM comparison because the variable is now unsigned.
@
text
@d117 2
a118 2
#define MEM_MODE(ch) (IS_NPC(ch) ? MEM_NONE : \
   VALID_CLASS(ch) ? classes[(int)GET_CLASS(ch)].mem_mode : MEM_NONE)
@


1.16
log
@Added 'extern' to all the function declarations.
@
text
@d104 1
a104 1
#define VALID_CLASSNUM(num) (num >= 0 && num < NUM_CLASSES)
@


1.15
log
@Changing object flags to use flagvectors.
@
text
@d167 11
a177 11
void init_classes(void);
void assign_class_skills(void);
int parse_class(struct char_data *ch, struct char_data *vict, char *arg);
int getbaseclass(int class);
void init_char_class(struct char_data *ch);
void update_char_class(struct char_data *ch);
void advance_level(struct char_data * ch, bool gaining);
void convert_class(struct char_data *ch, int newclass);
void roll_natural_abils(struct char_data *ch);
int return_max_skill(struct char_data *ch, int skill);
void give_newbie_eq(struct char_data *vict);
@


1.14
log
@Info about permanent effects and race skills are stored in the
class/race structs now, but need to be initialized at runtime
by the init_races and init_classes functions.
@
text
@d165 1
a165 1
               IS_OBJ_STAT(obj, classes[(int)GET_CLASS(ch)].nowear_flag) : 0)
@


1.13
log
@Added regen and exp-cost factors, plus general class identification macros.
@
text
@d89 10
d167 1
@


1.12
log
@Added newbie_eq to struct classdef.
@
text
@d75 4
d110 9
d132 17
@


1.11
log
@Add layman class as the default class for mobs, so we don't have a -1-indexed
array of classes. Make the macros check for a valid class index and return
some default/failure value if not valid. Add several "factor" values which
are used when creating mob prototypes.
@
text
@d63 1
a63 1
   bool magical;              /* Sorcerer, cleric, their subclasses */
d83 2
d136 1
@


1.10
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@a15 1
/* PC classes */
d41 1
d46 2
d59 1
d75 8
d88 36
a123 7
#define CLASS_ABBR(ch) (IS_NPC(ch) ? "--" : classes[(int)GET_CLASS(ch)].abbrev)
#define CLASS_FULL(ch) (IS_NPC(ch) ? "--" : classes[(int)GET_CLASS(ch)].displayname)
#define CLASS_WIDE(ch) (IS_NPC(ch) ? "--" : classes[(int)GET_CLASS(ch)].fmtname)
#define CLASS_NAME(ch) (IS_NPC(ch) ? "--" : classes[(int)GET_CLASS(ch)].name)
#define MEM_MODE(ch) (IS_NPC(ch) ? MEM_NONE : classes[(int)GET_CLASS(ch)].mem_mode)
#define NOWEAR_CLASS(ch, obj) (classes[(int)GET_CLASS(ch)].nowear_flag && \
               IS_OBJ_STAT(obj, classes[(int)GET_CLASS(ch)].nowear_flag))
@


1.9
log
@Add thac0 to classdef.
@
text
@d20 1
a20 1
#define CLASS_THIEF         2 
d42 1
a42 1
#define NUM_CLASSES        24  /* This must be the number of classes!! */
d85 1
@


1.8
log
@Add macro NOWEAR_CLASS for equipment restriction.  Make advance_level
prototype more descriptive as to its parameters' purposes.
@
text
@d70 1
@


1.7
log
@Added hp per level value to classdef.
@
text
@d70 1
d81 2
d88 1
a88 1
void advance_level(struct char_data * ch, int state);
a91 1
void advance_level(struct char_data * ch, int state);
@


1.6
log
@Added saving throws to classdef. Moved some stuff to chars.[ch].
@
text
@d69 1
@


1.5
log
@Add definitions to order rolled stats by class.
@
text
@d17 1
a17 1
#define CLASS_UNDEFINED      -1
d44 2
d47 1
a47 1
#define MEM_NONE      -1
a50 9
/* Indexing of stats */
#define STAT_STR 0
#define STAT_DEX 1
#define STAT_CON 2
#define STAT_WIS 3
#define STAT_INT 4
#define STAT_CHA 5
#define NUM_STATS 6  /* Update this if adding a stat */

d68 1
a81 1
int roll_mob_skill(int level);
d84 1
a84 1
void advance_level(struct char_data * ch, int state); /* Does not belong here */
d87 2
@


1.4
log
@Add several functions for updating characters' skills and such.
@
text
@d44 1
d49 9
d74 1
d93 1
@


1.3
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d77 5
@


1.2
log
@Add classdef members magical and mem_mode. Move mem/pray constants
here, from spells.h.
@
text
@d62 2
a63 1
   int max_subclass_level;
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
#define CLASS_MAGIC_USER    0
d44 3
a46 4
#define WARRIOR_SUBCLASSES   4
#define CLERIC_SUBCLASSES    3
#define ROGUE_SUBCLASSES     3
#define MAGE_SUBCLASSES      3
d57 2
a64 1
/*
d66 2
d69 1
d72 5
a76 1
*/
@
