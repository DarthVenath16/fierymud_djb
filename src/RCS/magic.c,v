head	1.297;
access;
symbols;
locks; strict;
comment	@ * @;


1.297
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.296;

1.296
date	2010.06.05.18.58.47;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	2010.06.05.18.35.47;	author mud;	state Exp;
branches;
next	1.294;

1.294
date	2010.06.05.05.29.00;	author mud;	state Exp;
branches;
next	1.293;

1.293
date	2010.06.05.04.43.57;	author mud;	state Exp;
branches;
next	1.292;

1.292
date	2009.08.02.20.19.58;	author myc;	state Exp;
branches;
next	1.291;

1.291
date	2009.07.18.01.17.23;	author myc;	state Exp;
branches;
next	1.290;

1.290
date	2009.07.17.06.05.35;	author myc;	state Exp;
branches;
next	1.289;

1.289
date	2009.07.04.16.23.13;	author myc;	state Exp;
branches;
next	1.288;

1.288
date	2009.06.10.18.50.40;	author myc;	state Exp;
branches;
next	1.287;

1.287
date	2009.06.09.05.43.38;	author myc;	state Exp;
branches;
next	1.286;

1.286
date	2009.05.19.19.36.52;	author myc;	state Exp;
branches;
next	1.285;

1.285
date	2009.03.21.06.32.37;	author jps;	state Exp;
branches;
next	1.284;

1.284
date	2009.03.20.06.08.18;	author myc;	state Exp;
branches;
next	1.283;

1.283
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.282;

1.282
date	2009.03.15.22.31.24;	author jps;	state Exp;
branches;
next	1.281;

1.281
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.280;

1.280
date	2009.03.09.16.57.47;	author myc;	state Exp;
branches;
next	1.279;

1.279
date	2009.03.09.04.50.38;	author myc;	state Exp;
branches;
next	1.278;

1.278
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.277;

1.277
date	2009.03.09.03.26.34;	author jps;	state Exp;
branches;
next	1.276;

1.276
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.275;

1.275
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.274;

1.274
date	2009.03.07.22.31.20;	author jps;	state Exp;
branches;
next	1.273;

1.273
date	2009.03.07.20.46.28;	author jps;	state Exp;
branches;
next	1.272;

1.272
date	2009.03.07.11.24.26;	author jps;	state Exp;
branches;
next	1.271;

1.271
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.270;

1.270
date	2009.02.04.20.03.56;	author myc;	state Exp;
branches;
next	1.269;

1.269
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.268;

1.268
date	2009.01.19.08.42.29;	author myc;	state Exp;
branches;
next	1.267;

1.267
date	2009.01.18.06.52.37;	author myc;	state Exp;
branches;
next	1.266;

1.266
date	2008.11.09.03.47.57;	author myc;	state Exp;
branches;
next	1.265;

1.265
date	2008.09.29.00.03.13;	author jps;	state Exp;
branches;
next	1.264;

1.264
date	2008.09.21.21.04.20;	author jps;	state Exp;
branches;
next	1.263;

1.263
date	2008.09.21.20.46.36;	author jps;	state Exp;
branches;
next	1.262;

1.262
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.261;

1.261
date	2008.09.20.17.39.12;	author jps;	state Exp;
branches;
next	1.260;

1.260
date	2008.09.20.17.23.20;	author jps;	state Exp;
branches;
next	1.259;

1.259
date	2008.09.20.07.27.45;	author jps;	state Exp;
branches;
next	1.258;

1.258
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.257;

1.257
date	2008.09.16.17.06.32;	author rsd;	state Exp;
branches;
next	1.256;

1.256
date	2008.09.14.04.41.41;	author jps;	state Exp;
branches;
next	1.255;

1.255
date	2008.09.14.04.34.30;	author jps;	state Exp;
branches;
next	1.254;

1.254
date	2008.09.14.04.09.24;	author jps;	state Exp;
branches;
next	1.253;

1.253
date	2008.09.14.02.22.53;	author jps;	state Exp;
branches;
next	1.252;

1.252
date	2008.09.14.02.08.01;	author jps;	state Exp;
branches;
next	1.251;

1.251
date	2008.09.13.18.52.20;	author jps;	state Exp;
branches;
next	1.250;

1.250
date	2008.09.13.18.05.29;	author jps;	state Exp;
branches;
next	1.249;

1.249
date	2008.09.13.16.03.53;	author jps;	state Exp;
branches;
next	1.248;

1.248
date	2008.09.12.20.16.49;	author jps;	state Exp;
branches;
next	1.247;

1.247
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.246;

1.246
date	2008.09.07.01.28.17;	author jps;	state Exp;
branches;
next	1.245;

1.245
date	2008.09.05.21.52.56;	author myc;	state Exp;
branches;
next	1.244;

1.244
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.243;

1.243
date	2008.09.02.07.19.56;	author jps;	state Exp;
branches;
next	1.242;

1.242
date	2008.09.02.07.16.39;	author jps;	state Exp;
branches;
next	1.241;

1.241
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.240;

1.240
date	2008.08.31.06.51.00;	author myc;	state Exp;
branches;
next	1.239;

1.239
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.238;

1.238
date	2008.08.29.16.55.00;	author myc;	state Exp;
branches;
next	1.237;

1.237
date	2008.08.28.21.50.05;	author jps;	state Exp;
branches;
next	1.236;

1.236
date	2008.08.26.04.39.21;	author jps;	state Exp;
branches;
next	1.235;

1.235
date	2008.08.26.02.29.11;	author jps;	state Exp;
branches;
next	1.234;

1.234
date	2008.08.24.03.15.57;	author myc;	state Exp;
branches;
next	1.233;

1.233
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.232;

1.232
date	2008.08.17.20.24.45;	author jps;	state Exp;
branches;
next	1.231;

1.231
date	2008.08.17.06.39.47;	author jps;	state Exp;
branches;
next	1.230;

1.230
date	2008.08.10.19.34.37;	author jps;	state Exp;
branches;
next	1.229;

1.229
date	2008.08.10.01.58.49;	author jps;	state Exp;
branches;
next	1.228;

1.228
date	2008.08.09.20.35.57;	author jps;	state Exp;
branches;
next	1.227;

1.227
date	2008.08.03.19.31.44;	author myc;	state Exp;
branches;
next	1.226;

1.226
date	2008.06.21.07.04.21;	author jps;	state Exp;
branches;
next	1.225;

1.225
date	2008.06.13.18.43.29;	author jps;	state Exp;
branches;
next	1.224;

1.224
date	2008.06.11.22.24.43;	author jps;	state Exp;
branches;
next	1.223;

1.223
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.222;

1.222
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.221;

1.221
date	2008.05.19.06.16.40;	author jps;	state Exp;
branches;
next	1.220;

1.220
date	2008.05.19.05.49.08;	author jps;	state Exp;
branches;
next	1.219;

1.219
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.218;

1.218
date	2008.05.18.17.58.49;	author jps;	state Exp;
branches;
next	1.217;

1.217
date	2008.05.18.04.40.59;	author jps;	state Exp;
branches;
next	1.216;

1.216
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.215;

1.215
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.214;

1.214
date	2008.05.14.05.11.10;	author jps;	state Exp;
branches;
next	1.213;

1.213
date	2008.05.12.04.47.36;	author jps;	state Exp;
branches;
next	1.212;

1.212
date	2008.05.12.04.41.59;	author jps;	state Exp;
branches;
next	1.211;

1.211
date	2008.05.12.00.43.48;	author jps;	state Exp;
branches;
next	1.210;

1.210
date	2008.05.11.07.11.53;	author jps;	state Exp;
branches;
next	1.209;

1.209
date	2008.05.11.06.13.31;	author jps;	state Exp;
branches;
next	1.208;

1.208
date	2008.05.11.05.50.15;	author jps;	state Exp;
branches;
next	1.207;

1.207
date	2008.04.20.04.42.24;	author jps;	state Exp;
branches;
next	1.206;

1.206
date	2008.04.19.21.22.06;	author myc;	state Exp;
branches;
next	1.205;

1.205
date	2008.04.14.08.36.53;	author jps;	state Exp;
branches;
next	1.204;

1.204
date	2008.04.14.05.11.40;	author jps;	state Exp;
branches;
next	1.203;

1.203
date	2008.04.14.02.17.45;	author jps;	state Exp;
branches;
next	1.202;

1.202
date	2008.04.13.19.38.17;	author jps;	state Exp;
branches;
next	1.201;

1.201
date	2008.04.13.18.44.42;	author jps;	state Exp;
branches;
next	1.200;

1.200
date	2008.04.13.18.30.14;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2008.04.12.21.29.39;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2008.04.12.21.13.18;	author jps;	state Exp;
branches;
next	1.197;

1.197
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.196;

1.196
date	2008.04.06.04.58.31;	author jps;	state Exp;
branches;
next	1.195;

1.195
date	2008.04.05.17.10.57;	author jps;	state Exp;
branches;
next	1.194;

1.194
date	2008.04.05.16.32.24;	author jps;	state Exp;
branches;
next	1.193;

1.193
date	2008.04.05.04.50.39;	author jps;	state Exp;
branches;
next	1.192;

1.192
date	2008.04.04.21.32.42;	author jps;	state Exp;
branches;
next	1.191;

1.191
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.190;

1.190
date	2008.03.29.16.28.10;	author jps;	state Exp;
branches;
next	1.189;

1.189
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.188;

1.188
date	2008.03.27.17.40.52;	author jps;	state Exp;
branches;
next	1.187;

1.187
date	2008.03.27.17.30.17;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2008.03.26.23.12.19;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2008.03.26.22.01.10;	author jps;	state Exp;
branches;
next	1.184;

1.184
date	2008.03.26.19.16.17;	author jps;	state Exp;
branches;
next	1.183;

1.183
date	2008.03.26.19.09.27;	author jps;	state Exp;
branches;
next	1.182;

1.182
date	2008.03.26.18.15.59;	author jps;	state Exp;
branches;
next	1.181;

1.181
date	2008.03.26.16.44.36;	author jps;	state Exp;
branches;
next	1.180;

1.180
date	2008.03.24.08.42.04;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2008.03.23.18.42.39;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2008.03.22.16.42.45;	author jps;	state Exp;
branches;
next	1.177;

1.177
date	2008.03.22.16.27.57;	author jps;	state Exp;
branches;
next	1.176;

1.176
date	2008.03.11.02.53.09;	author jps;	state Exp;
branches;
next	1.175;

1.175
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2008.03.09.18.14.25;	author jps;	state Exp;
branches;
next	1.173;

1.173
date	2008.03.09.08.59.25;	author jps;	state Exp;
branches;
next	1.172;

1.172
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.171;

1.171
date	2008.03.09.04.02.08;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.168;

1.168
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2008.01.28.02.39.01;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2008.01.27.21.14.59;	author myc;	state Exp;
branches;
next	1.163;

1.163
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.162;

1.162
date	2008.01.27.12.12.55;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2008.01.27.02.37.03;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2008.01.27.00.18.12;	author jps;	state Exp;
branches;
next	1.158;

1.158
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.01.26.12.33.18;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.01.25.11.54.29;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.01.25.11.47.22;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.01.24.15.45.09;	author myc;	state Exp;
branches;
next	1.153;

1.153
date	2008.01.15.03.26.00;	author myc;	state Exp;
branches;
next	1.152;

1.152
date	2008.01.14.18.52.52;	author myc;	state Exp;
branches;
next	1.151;

1.151
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.13.03.19.53;	author myc;	state Exp;
branches;
next	1.149;

1.149
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.11.17.34.32;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.146;

1.146
date	2008.01.07.11.56.45;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.07.10.37.19;	author jps;	state Exp;
branches;
next	1.144;

1.144
date	2008.01.06.23.50.47;	author jps;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.06.20.38.00;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2008.01.05.05.44.19;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.01.01.07.32.56;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2008.01.01.05.08.34;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2007.12.26.08.08.09;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2007.11.28.10.19.39;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2007.11.20.20.08.15;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.134;

1.134
date	2007.10.27.21.49.34;	author myc;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.27.18.56.18;	author myc;	state Exp;
branches;
next	1.132;

1.132
date	2007.10.27.03.19.24;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2007.10.13.05.18.11;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2007.10.13.05.07.24;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.128;

1.128
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.127;

1.127
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.126;

1.126
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2007.09.20.09.48.06;	author jps;	state Exp;
branches;
next	1.124;

1.124
date	2007.09.20.09.16.32;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2007.09.11.16.34.24;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2007.09.09.01.20.14;	author jps;	state Exp;
branches;
next	1.119;

1.119
date	2007.09.07.01.37.09;	author jps;	state Exp;
branches;
next	1.118;

1.118
date	2007.09.04.06.49.19;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2007.09.03.23.49.40;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2007.09.03.21.21.17;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2007.09.02.22.54.55;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2007.08.30.08.51.25;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2007.08.29.01.22.18;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2007.08.28.20.17.29;	author myc;	state Exp;
branches;
next	1.111;

1.111
date	2007.08.26.21.49.10;	author jps;	state Exp;
branches;
next	1.110;

1.110
date	2007.08.26.21.10.27;	author jps;	state Exp;
branches;
next	1.109;

1.109
date	2007.08.26.19.51.43;	author jps;	state Exp;
branches;
next	1.108;

1.108
date	2007.08.26.01.55.41;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2007.08.23.00.32.24;	author jps;	state Exp;
branches;
next	1.106;

1.106
date	2007.08.15.20.47.06;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2007.08.02.04.19.32;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2007.08.02.01.04.10;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2007.08.02.00.23.53;	author myc;	state Exp;
branches;
next	1.100;

1.100
date	2007.07.25.00.38.03;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.19.15.05.34;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2007.07.15.17.16.12;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2007.07.04.02.21.58;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.24.22.45.31;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.16.00.15.49;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.24.06.06.16;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.12.21.59.07;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.12.20.02.03;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.11.21.03.12;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.11.20.13.28;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.26.03.57.09;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.25.07.18.05;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.19.07.03.14;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.85;

1.85
date	2007.04.17.23.58.43;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.17.23.38.03;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.11.14.26.06;	author jps;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.20.17.16.27;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.14.03.54.53;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2007.02.08.01.30.00;	author myc;	state Exp;
branches;
next	1.78;

1.78
date	2006.12.19.04.36.53;	author dce;	state Exp;
branches;
next	1.77;

1.77
date	2006.11.20.22.24.17;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2006.11.20.19.52.04;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.18.07.03.30;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.18.04.26.32;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2006.11.17.22.52.59;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2006.11.14.18.54.02;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2006.11.13.19.24.00;	author jps;	state Exp;
branches;
next	1.70;

1.70
date	2006.11.13.18.33.58;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.13.17.51.31;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.11.10.11.04;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.08.09.59.46;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.08.09.16.04;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.08.08.49.29;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.08.08.01.14;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.07.14.09.46;	author jps;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.06.17.38.19;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.20.07.34.53;	author cjd;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.30.00.51.18;	author rls;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.28.06.38.07;	author rsd;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.19.03.09.58;	author rsd;	state Exp;
branches;
next	1.57;

1.57
date	2004.11.13.10.45.48;	author rls;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.15.18.33.30;	author rsd;	state Exp;
branches;
next	1.55;

1.55
date	2003.08.21.02.36.16;	author jjl;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.20.15.04.56;	author rls;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.18.14.57.37;	author rls;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.23.02.55.47;	author jjl;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.14.02.16.08;	author jjl;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.15.04.27.11;	author jjl;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.16.23.22.41;	author rls;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.27.00.04.19;	author dce;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.26.05.05.05;	author rls;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.25.12.30.07;	author rls;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.25.11.18.40;	author rls;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.18.22.54.15;	author dce;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.07.16.11.04;	author dce;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.07.01.45.18;	author dce;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.22.20.35.18;	author rsd;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.15.18.52.33;	author rsd;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.14.20.11.39;	author rsd;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.13.22.26.52;	author rsd;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.05.03.05.08;	author rsd;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.29.04.16.24;	author rsd;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.28.20.37.15;	author jimmy;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.30.18.14.19;	author rsd;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.15.23.12.03;	author rsd;	state Exp;
branches;
next	1.31;

1.31
date	2000.04.14.00.55.49;	author rsd;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.09.22.32.24;	author rsd;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.08.08.41.23;	author rsd;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.05.06.35.34;	author rsd;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.02.02.39.39;	author rsd;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.31.23.46.37;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.31.00.16.10;	author rsd;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.30.05.45.54;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.29.06.29.50;	author rsd;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.27.08.06.06;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.26.23.48.37;	author rsd;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.26.07.21.20;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.25.21.36.13;	author rsd;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.24.23.49.35;	author rsd;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.24.05.24.39;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.19.20.38.18;	author rsd;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.18.06.08.38;	author rsd;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.05.00.15.34;	author rsd;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.04.08.32.25;	author rsd;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.26.02.17.21;	author rsd;	state Exp;
branches;
next	1.11;

1.11
date	99.12.08.21.21.59;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.11.29.01.32.51;	author cso;	state Exp;
branches;
next	1.9;

1.9
date	99.11.28.23.41.42;	author cso;	state Exp;
branches;
next	1.8;

1.8
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.03.07.05.01.09;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.02.13.19.37.12;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.02.11.16.44.23;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.10.02.38.58;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.16.35.11;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/*
************************************************************************
*   File: magic.c                                       Part of CircleMUD *
*  Usage: low-level functions for magic; spell template code              *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "spells.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *obj_index;
extern struct index_data *mob_index;
extern struct weather_data weather_info;
extern struct descriptor_data *descriptor_list;
extern struct zone_data *zone_table;
extern struct char_data *mob_proto;
extern int mini_mud;
extern int pk_allowed;
extern int sleep_allowed;
extern int summon_allowed;
extern int charm_allowed;
extern int roomaffect_allowed;

struct spell_dam spell_dam_info[MAX_SPELLS + 1];
extern struct default_mobile_stats *mob_defaults;
extern char weapon_verbs[];
extern int *max_ac_applys;
extern struct apply_mod_defaults *apmd;
int real_mobile(int);
void clearMemory(struct char_data * ch);
void act(char *str, int i, struct char_data * c, struct obj_data * o,
	      void *vict_obj, int j);

void damage(struct char_data * ch, struct char_data * victim,
	         int damage, int weapontype);
void reset_mob(struct char_data *mob, int caster_level, int i, int type,
    struct obj_data * obj);
void half_chop(char *string, char *arg1, char *arg2);
int is_abbrev(char *arg1, char *arg2);
void die(struct char_data * ch, struct char_data * killer);
bool is_grouped(struct char_data *ch, struct char_data *tch);
void weight_change_object(struct obj_data * obj, int weight);
void add_follower(struct char_data * ch, struct char_data * leader);
int dice(int number, int size);
extern struct spell_info_type spell_info[];


struct char_data *read_mobile(int, int);


bool protected_from_spell(struct char_data *ch, int spell)
{
  switch(spell_info[spell].damage_type) {
    case FIRE_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_FIRE))
	return TRUE;
      break;
    case COLD_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_COLD))
	return TRUE;
      break;
    case AIR_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_AIR))
	return TRUE;
      break;
    case EARTH_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_EARTH))
	return TRUE;
      break;
    default:
      return FALSE;
  }
  return FALSE;
}

/*
 * Saving throws for:
 * MCTW
 *   PARA, ROD, PETRI, BREATH, SPELL
 *     Levels 0-40
 */

const byte saving_throws[NUM_CLASSES][5][41] = {

  {				/* Mages */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

  {				/* Clerics */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 74, 73, 71, 70, 68, 65, 63, 60, 59,	/* 0 - 10 */
/* SPELL */	58, 56, 55, 54, 53, 51, 50, 49, 48, 47,		/* 11 - 20 */
		46, 45, 43, 41, 39, 37, 35, 34, 33, 32,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}		/* 31 - 40 */
  },

  {				/* Thieves */
		{90, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56,	/* 0 - 10 */
/* PARA */	55, 54, 53, 52, 51, 50, 49, 48, 47, 46,		/* 11 - 20 */
		45, 44, 43, 42, 41, 40, 39, 38, 37, 36,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 68, 66, 64, 62, 60, 58, 56, 54, 52,	/* 0 - 10 */
/* ROD */	50, 48, 46, 44, 42, 40, 38, 36, 34, 32,		/* 11 - 20 */
		30, 28, 26, 24, 22, 20, 18, 16, 14, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 59, 58, 58, 56, 55, 54, 53, 52, 51,	/* 0 - 10 */
/* PETRI */	50, 49, 48, 47, 46, 45, 44, 43, 42, 41,		/* 11 - 20 */
		40, 39, 38, 37, 36, 35, 34, 33, 32, 31,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71,	/* 0 - 10 */
/* BREATH */	70, 69, 68, 67, 66, 65, 64, 63, 62, 61,		/* 11 - 20 */
		60, 59, 58, 57, 56, 55, 54, 53, 52, 51,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 59, 57,	/* 0 - 10 */
/* SPELL */	55, 53, 51, 49, 47, 45, 43, 41, 39, 37,		/* 11 - 20 */
		35, 33, 31, 29, 27, 25, 23, 21, 19, 17,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}			/* 31 - 40 */
  },

  {				/* Warriors */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* PALADINS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

  {				/* ANTI-PALADINS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* RANGERS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* DRUIDS */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

  {				/* SHAMAN */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
		},

{				/* ASSASSINS */
		{90, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56,	/* 0 - 10 */
/* PARA */	55, 54, 53, 52, 51, 50, 49, 48, 47, 46,		/* 11 - 20 */
		45, 44, 43, 42, 41, 40, 39, 38, 37, 36,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 68, 66, 64, 62, 60, 58, 56, 54, 52,	/* 0 - 10 */
/* ROD */	50, 48, 46, 44, 42, 40, 38, 36, 34, 32,		/* 11 - 20 */
		30, 28, 26, 24, 22, 20, 18, 16, 14, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 59, 58, 58, 56, 55, 54, 53, 52, 51,	/* 0 - 10 */
/* PETRI */	50, 49, 48, 47, 46, 45, 44, 43, 42, 41,		/* 11 - 20 */
		40, 39, 38, 37, 36, 35, 34, 33, 32, 31,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71,	/* 0 - 10 */
/* BREATH */	70, 69, 68, 67, 66, 65, 64, 63, 62, 61,		/* 11 - 20 */
		60, 59, 58, 57, 56, 55, 54, 53, 52, 51,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 59, 57,	/* 0 - 10 */
/* SPELL */	55, 53, 51, 49, 47, 45, 43, 41, 39, 37,		/* 11 - 20 */
		35, 33, 31, 29, 27, 25, 23, 21, 19, 17,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}			/* 31 - 40 */
  },

{				/* MERCENARY */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

 {				/* NECRO */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

 {				/* CONJ */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  }

};


struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output) {

  /* check to see if char is guarded and roll for guarding affect */
  if (ch->casting.target_status != TARGET_ALL_ROOM
	&& victim->guarded_by
	&& get_char_room_vis(victim->guarded_by,GET_NAME(victim))==victim) {
    if(GET_ISKILL(victim->guarded_by, SKILL_GUARD) > number(1,1100)
	&& !CHECK_WAIT(victim->guarded_by)
	&& GET_POS(victim->guarded_by) >= POS_FIGHTING) {
      if(!gag_output) {
        act("$n jumps in front of $N, shielding $M from the assault.",FALSE,victim->guarded_by,0,victim, TO_NOTVICT);
        act("$n jumps in front of you, shielding you from the assault.",FALSE,victim->guarded_by,0,victim, TO_VICT);
        act("You jump in front of $N, shielding $M from the assault.",FALSE,victim->guarded_by,0,victim, TO_CHAR);
      }
      return victim->guarded_by;
    }
  }
  return victim;
}

int mag_savingthrow(struct char_data * ch, int type)
{
  int get_base_saves(struct char_data *ch, int type);
  int save;

  /* negative apply_saving_throw values make saving throws better! */
/* I uncommented the old saves and commented nech new ones to test Banyal
 * if (IS_NPC(ch))
 *   save = saving_throws[CLASS_WARRIOR][type][(int) GET_LEVEL(ch)];
 * else
 *   save = saving_throws[(int) GET_CLASS(ch)][type][(int) GET_LEVEL(ch)];
 */

  /* New save numbers by Nechtrous */
  save = get_base_saves(ch, type);

  /* save_applies removed by fingh 12/3/98 for testing
   *save += GET_SAVE(ch, type);
  */
/*
  switch(type) {
    case SAVING_PARA:
      sprintf(buf, "PARALYSIS");
      break;
    case SAVING_ROD:
      sprintf(buf, "ROD");
      break;
    case SAVING_BREATH:
      sprintf(buf, "BREATH");
      break;
    case SAVING_PETRI:
      sprintf(buf, "PETRIFICATION");
      break;
    case SAVING_SPELL:
      sprintf(buf, "SPELL");
      break;
    default:
      break;
  }
*/
  /* throwing a 0 is always a failure */
  if (MAX(1, save) < number(0, 99)) {
    return TRUE;
  }
  else{
    return FALSE;
  }
}

/*Decrease modifier is used to decrease stone_skins modifier by 1
Can be used by any affect really with minor code change
*/
void decrease_modifier(struct char_data * i)
{
struct affected_type *af;
struct affected_type *tmp;
	for (af = i->affected; af; af = tmp)
	{
		tmp = af->next;
		if (af->type == 52)/*number for stone skin*/
		{
			if (af->modifier > 1)
				af->modifier--;
			else
				affect_remove(i, af);/*remove bit*/
		}
	}


}

/* affect_update: called from comm.c (causes spells to wear off) */
void affect_update(void)
{
  extern struct raff_node *raff_list;
  struct raff_node *raff, *next_raff, *temp;
  static struct affected_type *af, *next;
  static struct char_data *i;
  extern char *spell_wear_off_msg[];

  for (i = character_list; i; i = i->next)
    for (af = i->affected; af; af = next) {
      next = af->next;
      if (af->duration >= 1)
	af->duration--;
      else if (af->duration == -1)	/* No action */
	af->duration = -1;	/* GODs only! unlimited */
      else {
	if ((af->type > 0) && (af->type <= MAX_SPELLS))
	  if (!af->next || (af->next->type != af->type) ||
	      (af->next->duration > 0))
	    if (*spell_wear_off_msg[af->type]) {
	      send_to_char(spell_wear_off_msg[af->type], i);
	      send_to_char("\r\n", i);
	    }
	affect_remove(i, af);
      }
    }
  for (raff = raff_list; raff; raff = next_raff) {
		next_raff = raff->next;

		raff->timer--;

		if (raff->timer <= 0) {
			/* this room affection has expired */
			if (ROOM_AFFECTED(raff->room, raff->affection)){
			send_to_room(spell_wear_off_msg[raff->spell],
				raff->room);
			send_to_room("\r\n", raff->room);}

			/* remove the affection */
			REMOVE_BIT(world[(int)raff->room].room_affections,
				raff->affection);
			REMOVE_FROM_LIST(raff, raff_list, next)
			free(raff);
		}
	}

}


/*
 *  mag_materials:
 *  Checks for up to 3 vnums (spell reagents) in the player's inventory.
 *
 * No spells implemented in Circle 3.0 use mag_materials, but you can use
 * it to implement your own spells which require ingredients (i.e., some
 * heal spell which requires a rare herb or some such.)
 */
int mag_materials(struct char_data * ch, int item0, int item1, int item2,
		      int extract, int verbose)
{
  struct obj_data *tobj;
  struct obj_data *obj0 = NULL, *obj1 = NULL, *obj2 = NULL;

  for (tobj = ch->carrying; tobj; tobj = tobj->next_content) {
    if ((item0 > 0) && (GET_OBJ_VNUM(tobj) == item0)) {
      obj0 = tobj;
      item0 = -1;
    } else if ((item1 > 0) && (GET_OBJ_VNUM(tobj) == item1)) {
      obj1 = tobj;
      item1 = -1;
    } else if ((item2 > 0) && (GET_OBJ_VNUM(tobj) == item2)) {
      obj2 = tobj;
      item2 = -1;
    }
  }
  if ((item0 > 0) || (item1 > 0) || (item2 > 0)) {
    if (verbose) {
      switch (number(0, 2)) {
      case 0:
	send_to_char("A wart sprouts on your nose.\r\n", ch);
	break;
      case 1:
	send_to_char("Your hair falls out in clumps.\r\n", ch);
	break;
      case 2:
	send_to_char("A huge corn develops on your big toe.\r\n", ch);
	break;
      }
    }
    return (FALSE);
  }
  if (extract) {
    if (item0 < 0) {
      obj_from_char(obj0);
      extract_obj(obj0);
    }
    if (item1 < 0) {
      obj_from_char(obj1);
      extract_obj(obj1);
    }
    if (item2 < 0) {
      obj_from_char(obj2);
      extract_obj(obj2);
    }
  }
  if (verbose) {
    send_to_char("A puff of smoke rises from your pack.\r\n", ch);
    act("A puff of smoke rises from $n's pack.", TRUE, ch, NULL, NULL, TO_ROOM);
  }
  return (TRUE);
}




/*
 * Every spell that does damage comes through here.  This calculates the
 * amount of damage, adds in any modifiers, determines what the saves are,
 * tests for save and calls damage().
 */

void mag_damage(int level, struct char_data * ch, struct char_data * victim,
		     int spellnum, int savetype)
{
  int is_mage = 0, is_cleric = 0;
  int dam = 0;

  if (victim == NULL || ch == NULL)
    return;

  is_mage = (GET_CLASS(ch) == CLASS_MAGIC_USER || GET_CLASS(ch) == CLASS_PYROMANCER ||
	     GET_CLASS(ch) == CLASS_CRYOMANCER || GET_CLASS(ch) == CLASS_NECROMANCER ||
	     GET_CLASS(ch) == CLASS_CONJURER || GET_CLASS(ch) == CLASS_ILLUSIONIST);
  is_cleric = (GET_CLASS(ch) == CLASS_CLERIC || GET_CLASS(ch) == CLASS_DIABOLIST ||
	       GET_CLASS(ch) == CLASS_DRUID || GET_CLASS(ch) == CLASS_PRIEST ||
	       GET_CLASS(ch) == CLASS_MYSTIC);

/*spell damage is now online, and is stored in array "spell_dam_info",
*******The defines are as such*******:
#define SD_SPELL(i) spell_dam_info[i].spell
#define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
#define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
#define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
#define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
#define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
#define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
#define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
#define SD_BONUS(i) spell_dam_info[i].max_bonus
#define SD_NPC_STATIC...
#define SD_PC_STATIC...

****General****
- If SD_INTERN_DAM(i) = FALSE then it will look for a internal switch
- Otherwise it will go through a loop using the values in the array spell_dam_info
- If you wish to have Differeng class Affects simply add a class and put in its factor
**results**
    pc vs pc - SD_PC_NO_DICE * SD_PC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/4)
    pc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    npc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    npc vs pc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    all npc vs x is also npc * SD_NPC_REDUCE_FACTOR
    Add Statics onto value
Proky
*/


    if (SD_INTERN_DAM(spellnum))
    {
        if (((!IS_NPC(ch))  && (!IS_NPC(victim))) ||
   (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))))
        {/*pc vs pc*/
            dam = dice(SD_PC_NO_DICE(spellnum), SD_PC_NO_FACE(spellnum)) + SD_PC_STATIC(spellnum);
            if (SD_USE_BONUS(spellnum))
dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/4)));
        else
	dam = dam + MIN(SD_BONUS(spellnum),
GET_LEVEL(ch)*SD_LVL_MULT(spellnum));

	}else
        {/*any other*/
           dam = dice(SD_NPC_NO_DICE(spellnum), SD_NPC_NO_FACE(spellnum)) + SD_NPC_STATIC(spellnum);
            if (SD_USE_BONUS(spellnum))
         dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/2)));
        else
dam = dam + MIN(SD_BONUS(spellnum),
GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
	}
        if (IS_NPC(ch))
        {/*reduce npc dam*/
           dam = (int)((SD_NPC_REDUCE_FACTOR(spellnum) * dam)/100);

        }
    }

/*effectivly anything following will copy over online damages*/
/*feel free to copy over what the online stuff will do*/






 switch (spellnum) {
    /* Mostly mages */

    case SPELL_EXORCISM:
      if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
        send_to_char("That spell only has effect on demonic entities.\r\n",ch);
        return;
      }
      if(GET_LEVEL(victim) < 40 && !mag_savingthrow(victim,SAVING_SPELL)
        && number(1,100) > 70) {
        act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
        act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
        if(FIGHTING(victim))
          stop_fighting(victim);
        extract_char(victim);
	return;
      }
	dam = 15 * GET_LEVEL(ch);
      break;
    case SPELL_LESSER_EXORCISM:
      if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
        send_to_char("That spell only has effect on demonic entities.\r\n",ch);
        return;
      }
      if(GET_LEVEL(victim) < 30 && !mag_savingthrow(victim,SAVING_SPELL)
        && number(1,100) > 50) {
        act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
        act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
        if(FIGHTING(victim))
          stop_fighting(victim);
        extract_char(victim);
	return;
      }
	dam = 10 * GET_LEVEL(ch);
      break;
    /* reason i put these breaths here is because prokys structure does not
	go above MAX_SPELLS. Nechtrous*/
    case SPELL_FIRE_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_FROST_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_GAS_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_LIGHTNING_BREATH:
        dam = dice(10,10)+350;
      break;
    case SPELL_ACID_BREATH:
        dam = dice(10,10)+200;
      break;

    case SPELL_UNHOLY_WORD:
      dam = dice(10,20) + (GET_LEVEL(ch)*2);
      break;
    case SPELL_HOLY_WORD:
      if (GET_CLASS(ch) == CLASS_PRIEST)
      dam = dice(15,30) + (GET_LEVEL(ch)*2);
      else
      dam = dice(10,20) + (GET_LEVEL(ch)*2);
      break;

    case SPELL_DISPEL_EVIL:
        if (IS_GOOD(victim)) {
            act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
            dam = 0;
        return;
        }
    break;
    case SPELL_DISPEL_GOOD:
        if (IS_EVIL(victim)) {
            act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
            dam = 0;
            return;
        }
    break;

  case SPELL_ENERGY_DRAIN:
    if (GET_LEVEL(victim) <= 2)
      dam = 100;
    break;

  case SPELL_DESTROY_UNDEAD:
     dam = dice(4, 50) + 30;
     if (GET_SPECIES(victim) != SPECIES_UNDEAD) {
       act("$N has far too much life for you to harm it!",
FALSE,ch,0,victim,TO_CHAR);
       dam=0;
       return;
     }
     break;
  case SPELL_VAMPIRIC_BREATH:
    if (GET_LEVEL(victim) <= 25)
        dam = 20;
	if (GET_LEVEL(ch) < 20)
        dam = dice(1, 20);
    GET_HIT(ch) = GET_HIT(ch) + dam;
    break;

    /* Area spells */
  case SPELL_EARTHQUAKE:
    ;/*put affect here some time*/
    break;
  }

/*switch through classes*/
    /*switch (GET_CLASS(ch))
    {
    case CLASS_MAGIC_USER:
        dam = dam;
    break;
    default:
        dam = (int)((95 * dam)/100);
        break;
    }
*/

  victim = check_guard(ch, victim, FALSE);

  if (ch!=victim && IS_NPC(victim) &&
      MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch) &&
       (GET_LEVEL(ch) < LVL_IMMORT))
    remember(victim, ch);

  /* 3/4 damage if player has protection from spell damage */
  if (protected_from_spell(victim, spellnum))
    dam = (int)(3*dam/4);

  /* divide damage by two if victim makes his saving throw */
  if (mag_savingthrow(victim, savetype))
    dam >>= 1;

  /* if HARNESS spell is active, do extra 2% per lvl of foe */
  if (IS_AFFECTED2(ch, AFF2_HARNESS)){
    dam += (int)(dam * (GET_LEVEL(victim)*0.02));
    act("&5&b$n&5&b executes $s spell with amazing force...&0", FALSE, ch,0,0,TO_ROOM);
    act("&5&bYou execute your spell with amazing force...&0",FALSE,ch,0,0,TO_CHAR);
    affect_from_char(ch, SPELL_HARNESS);
  }

  /* if flagged !heat and damage is fire, the spell fails*/
  if(IS_AFFECTED2(victim, AFF2_NEGATE_HEAT) && spell_info[spellnum].damage_type == FIRE_DAMAGE) {
    act("&6$n's&6 spell has no effect on $N.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    act("&6Your spell has no effect on $N!&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&6$n's&6 spell has no effect on you!&0", FALSE, ch, 0, victim, TO_VICT);
    return;
  }
  if(IS_AFFECTED2(victim, AFF2_NEGATE_COLD) && spell_info[spellnum].damage_type == COLD_DAMAGE) {
    act("&6$n's&6 spell has no effect on $N.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    act("&6Your spell has no effect on $N!&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&6$n's&6 spell has no effect on you!&0", FALSE, ch, 0, victim, TO_VICT);
    return;
  }
  /* and finally, inflict the damage */
  damage(ch, victim, dam, spellnum);
}


/*
 * Every spell that does an affect comes through here.  This determines
 * the effect, whether it is added or replacement, whether it is legal or
 * not, etc.
 *
 * affect_join(vict, aff, add_dur, avg_dur, add_mod, avg_mod, refresh)
 *
 * I added refresh so that spells can be refreshed before they run out.
 * NOTE: If accum_duration is set to TRUE, it will override refresh.
 * --Nechtrous
*/

#define MAX_SPELL_AFFECTS 8	/* change if more needed */

void mag_affects(int level, struct char_data * ch, struct char_data * victim,
		      int spellnum, int savetype)
{
  struct affected_type af[MAX_SPELL_AFFECTS];
  struct affected_type *aff=NULL;
  int is_mage = FALSE, is_cleric = FALSE;
  bool accum_affect = FALSE, accum_duration = FALSE, is_innate = FALSE,
	refresh=TRUE;
  char *to_vict = NULL, *to_room = NULL;
  int i;


  if (victim == NULL || ch == NULL)
    return;
  if((ch->casting.misc) && *(ch->casting.misc))
    half_chop(ch->casting.misc,buf,buf2);
  is_mage = (GET_CLASS(ch) == CLASS_MAGIC_USER);
  is_cleric = (GET_CLASS(ch) == CLASS_CLERIC);

  for (i = 0; i < MAX_SPELL_AFFECTS; i++) {
    af[i].type = spellnum;
    af[i].bitvector = 0;
    af[i].bitvector2 = 0;
    af[i].bitvector3 = 0;
    af[i].modifier = 0;
    af[i].location = APPLY_NONE;
  }

  switch (spellnum) {

  case SPELL_ICE_ARMOR:
    af[0].location = APPLY_AC;
    af[0].modifier = -15;
    af[0].duration = 24;

    to_vict="&4Your body is encased in layer of &7&bsolid ice.&0";
    to_room="&4$n's&4 body is encased in a layer of &7&bsolid ice.&0";
    break;

  case SPELL_NEGATE_HEAT:
    af[0].bitvector2 = AFF2_NEGATE_HEAT;
    af[0].duration = 6;
    refresh = FALSE;

    to_vict="&6Your body becomes impervious to all forms of heat!&0";
    to_room="&6$n&6's body shimmers a bit as all heat seems to evacuate $s body.&0";
    break;

  case SPELL_NEGATE_COLD:
    af[0].bitvector2 = AFF2_NEGATE_COLD;
    af[0].duration = 6;
    refresh = FALSE;

    to_vict="&4&bYour body becomes impervious to the cold!&0";
    to_room="&4$n&4's body glows &bblue&0&4 briefly.&0";
    break;

  case SPELL_WATERFORM:
    af[0].bitvector2 = AFF2_WATERFORM;
    af[0].duration = 6;
    refresh = FALSE;

    to_vict="&4&bYour body liquifies.&0";
    to_room="&4&b$n&4&b's body wavers a bit, slowly changing into a &0&4liquid&b state!&0";
    break;

  case SPELL_MIRAGE:
    af[0].location = APPLY_AC;
    af[0].modifier = -15;
    af[0].duration = 24;

    to_room="&1$n's&1 form begins to waver as a wave of heat blurs the air around $m.&0";
    to_vict="&1Your form begins to waver as a wave of heat blurs the air around you.&0";
    break;

  case SPELL_SMOKE:
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
      return;
    }

    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;

    to_room = "&9&b$n&9&b is blinded by $N's&9&b column of smoke!&0";
    to_vict = "&9You have been blinded by $N's&9&b column of smoke&0";
    break;


  case SPELL_GAIAS_CLOAK:
    if(!OUTSIDE(victim)) {
      send_to_char("There is not enough vegetation here.\r\n",ch);
      return;
    }
    af[0].location = APPLY_AC;
    af[0].modifier = -30;
    af[0].duration = 10;
    refresh = FALSE;
    to_room="&2A cyclone of leaves and sticks twirl around $n&2, guarding $s body.&0";
    to_vict="&2A cyclone of leaves and sticks twirl around you, guarding your body.&0";
    break;
  case SPELL_ENTANGLE:
    if(!OUTSIDE(victim)) {
      send_to_char("There is not enough vegetation here.\r\n",ch);
      return;
    }
    if(mag_savingthrow(victim, SAVING_PARA)) {
      return;
    }
   if(number(0, 100) > 50)
     return;
    if(number(0, 100) < 10) {
    refresh = FALSE;
    af[0].bitvector = AFF_MAJOR_PARA;
    af[0].duration = 3;
    to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
    to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
    break;
   }else
   refresh = FALSE;
    af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
    af[0].duration = 5;
    to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
    to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
    break;
  case SPELL_BARKSKIN:
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;
    to_vict="&3Your skin hardens to bark.&0";
    to_room="&3$n's&3 skin hardens to bark.&0";
    break;

  case SPELL_NIGHT_VISION:
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 24;
    to_vict="&9&bYour vision sharpens a bit.";
    break;

  case SPELL_DARK_PRESENCE:
    af[0].location = APPLY_DAMROLL;
    af[0].modifier = 2;
    af[0].duration = 15;

    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 15;
    to_vict="&9&bA dark presence fills your mind.&0";
    break;

  case SPELL_DEMONSKIN:
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;

    af[1].bitvector2 = AFF2_PROT_FIRE;
    af[1].duration = 24;
    to_vict="&1Your skin toughens into a dark red hide.&0";
    to_room="&1$n's&1 skin toughens into a dark red hide.&0";
    break;

  case SPELL_DISEASE:
    if(mag_savingthrow(victim, SAVING_SPELL))
      return;
    af[0].bitvector2 = AFF2_DISEASE;
    af[0].duration = 15;

    af[1].location = APPLY_CON;
    if(IS_NPC(victim))
    af[1].modifier = -3;
    else
    af[1].modifier = -20;
    af[1].duration = 15;

    af[2].location = APPLY_STR;
    if(IS_NPC(victim))
    af[2].modifier = -3;
    else
    af[2].modifier = -20;
    af[2].duration = 15;
    to_vict="&3A foul feeling overtakes you. You feel seriously ill!&0";
    to_room="&3$n&3 looks seriously ill!";
    break;

  case SPELL_INSANITY:
    if(mag_savingthrow(victim, SAVING_SPELL))
      return;
    af[0].bitvector2 = AFF2_INSANITY;
    af[0].duration = 5;

    af[1].location = APPLY_WIS;
    af[1].modifier = -50;
    af[1].duration = 5;
    to_vict="&5You go out of your &bMIND!&0";
    to_room="&5$n's&5 psyche snaps... A crazed gleam fills $s eyes.&0";
    break;

  case SPELL_DEMONIC_ASPECT:
    af[0].location = APPLY_HIT;
    af[0].modifier = GET_LEVEL(ch);
    af[0].duration = (int)(GET_LEVEL(ch) / 3);

    af[1].location = APPLY_STR;
    af[1].modifier = 10;
    af[1].duration = (int)(GET_LEVEL(ch) / 3);
    to_vict="&1Your body fills with a demonic strength.&0";
    to_room="&1$n's&1 body &bglows red&0&1 briefly and grows stronger.&0";
    break;

  case SPELL_DEMONIC_MUTATION:
    send_to_char("You cannot seem to grasp the nature of the demon.\r\n",ch);
    return;
    break;

  case SPELL_WINGS_OF_HELL:
    af[0].bitvector=AFF_FLYING;
    af[0].duration=(int)(GET_LEVEL(ch)/2);
    to_vict="&1&bHuge leathery &9bat-like&1 wings sprout from your back.&0";
    to_room="&1&bHuge leathery &9bat-like&1 wings sprout out of $n's&1&b back.&0";
    break;

  case SPELL_VITALITY:
    af[0].location = APPLY_HIT;
    af[0].modifier = MIN(4 * GET_LEVEL(ch), 255);
    af[0].duration = (int)(GET_LEVEL(ch) / 5);
    to_vict="&4&bYou feel vitalized!&0";
    break;

  case SPELL_WINGS_OF_HEAVEN:
    af[0].bitvector=AFF_FLYING;
    af[0].duration=(int)(GET_LEVEL(ch)/2);
    to_vict="&7&bBeautiful bright white wings unfurl behind you as you lift into the air.&0";
    to_room="&7&bBeautiful bright white wings unfurl from $n's&7&b back, lifting $m into the air.&0";
    break;

  case SPELL_SPEAK_IN_TONGUES:
    af[0].bitvector2=AFF2_TONGUES;
    af[0].duration = (int)(GET_LEVEL(ch)/2);
    to_vict="You feel ready to speak in any language.";
    break;

  case SPELL_ELEMENTAL_WARDING:
    if(is_abbrev(buf2,"fire")){
      af[0].bitvector2=AFF2_PROT_FIRE;
      to_vict="You are warded from &1fire&0.";
    }
    else if (is_abbrev(buf2,"cold")){
      af[0].bitvector2=AFF2_PROT_COLD;
      to_vict="You are warded from the &4cold&0.";
    }
    else if (is_abbrev(buf2,"air")){
      af[0].bitvector2=AFF2_PROT_AIR;
      to_vict="You are warded from &6&bair&0.";
    }
    else if (is_abbrev(buf2,"earth")){
      af[0].bitvector2=AFF2_PROT_EARTH;
      to_vict="You are warded from &3earth&0.";
    }
    else {
      send_to_char("What element do you want to ward against?\r\n",ch);
      return;
    }
    af[0].duration = GET_LEVEL(ch);
    to_room="&7&b$n&7&b glows briefly.&0";
    break;

  case SPELL_PRAYER:
    af[0].location = APPLY_SAVING_SPELL;
    af[0].modifier = -2;
    af[0].duration = (int)(GET_LEVEL(ch) / 3);

    af[1].location = APPLY_HIT;
    af[1].modifier = GET_LEVEL(ch);
    af[1].duration = (int)(GET_LEVEL(ch) / 3);
    to_vict="Your prayer is answered...\r\nYou feel full of life!";
    to_room="$n perks up, looking full of life.";
    break;

  case SPELL_MAGIC_TORCH:
    af[0].duration = 24;
    af[0].bitvector2 = AFF2_LIGHT;
    refresh = FALSE;
    to_vict="&1A magical flame bursts into focus, lighting the area.&0";
    to_room="&1A magical flame bursts into focus, lighting the area.&0";
    break;

  case SPELL_CIRCLE_OF_LIGHT:
    af[0].duration = GET_LEVEL(ch);
    af[0].bitvector2 = AFF2_LIGHT;
    refresh = FALSE;
    to_vict="&7&bA bright white circle of light begins hovering about your head.&0";
    to_room="&7&bA bright white circle of light appears over $n's&7&b head.";
    break;

  case SPELL_FEAR:
    if(mag_savingthrow(victim, SAVING_PARA))
      return;
    af[0].duration = 2;
    af[0].bitvector2 = AFF2_FEAR;
    to_vict="&9&bA rush of fear sweeps through your body!&0";
    to_room="&9&bA look of terror sweeps over $n&9&b's face!&0";
    break;

  case SPELL_HARNESS:
    if(!FIGHTING(ch) || FIGHTING(ch) != victim) {
      send_to_char("You are not fighting that person.\r\n", ch);
      return;
    }
    if(IS_AFFECTED2(ch, AFF2_HARNESS)) {
      send_to_char("You have already harnessed the energy!\r\n",ch);
      return;
    }
    af[0].duration = 2;
    af[0].bitvector2 = AFF2_HARNESS;
    refresh = FALSE;
    victim = ch;
    to_vict="&4&bYour veins begin to pulse with energy!&0";
    to_room="&4&b$n&4&b's veins bulge as a surge of energy rushes into $m!&0";
    break;

  case SPELL_MINOR_GLOBE:
    af[0].duration = 8;
    af[0].bitvector2 = AFF2_MINOR_GLOBE;
    refresh = FALSE;
    to_vict="&1A shimmering globe wraps around your body.&0";
    to_room="&1A shimmering globe wraps around $n&0&1's body.&0";
    break;

  case SPELL_MAJOR_GLOBE:
    af[0].duration = 8;
    af[0].bitvector2 = AFF2_MAJOR_GLOBE;
    refresh = FALSE;
    to_vict="&1&bA shimmering globe of force wraps around your body.&0";
    to_room="&1&bA shimmering globe of force wraps around $n&1&b's body.&0";
    break;

  case SPELL_COLDSHIELD:
    if(AFF2_FLAGGED(ch, AFF2_FIRESHIELD)) {
      send_to_char("The shield of fire around your body negates your spell.\r\n", ch);
      return;
    }
    af[0].duration = 4;
    af[0].bitvector2 = AFF2_COLDSHIELD;
    refresh = FALSE;
    to_vict="&4A jagged formation of i&bc&7e sh&4ard&0&4s form around you.&0";
    to_room="&4A jagged formation of i&bc&7e sh&4ard&0&4s form around $n&0&4.&0";
    break;

  case SPELL_FIRESHIELD:
    if(AFF2_FLAGGED(ch, AFF2_COLDSHIELD)) {
      send_to_char("The shield of ice around your body negates your spell.\r\n", ch);
      return;
    }
    af[0].duration = 4;
    af[0].bitvector2 = AFF2_FIRESHIELD;
    refresh = FALSE;
    to_vict="&1A burning shield if f&bi&3r&7e&0&1 explodes from your body!&0";
    to_room="&1A burning shield of f&bi&3r&7e&0&1 explodes from $n&0&1's body!&0";
    break;

  case SPELL_MINOR_PARALYSIS:
    if(mag_savingthrow(victim, SAVING_PARA))
      return;
    af[0].duration = (int)(GET_LEVEL(ch)/10);
    af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
    refresh = FALSE;
    to_vict="&7&bAll motion in your body grinds to a halt.&0";
    to_room="&7&bAll motion in $n&7&b's body grinds to a halt.&0";
    break;

  case SPELL_RAY_OF_ENFEEB:
    if(IS_AFFECTED3(victim, AFF3_RAY_OF_ENFEB))
     return;
    if(mag_savingthrow(victim, savetype))
      return;
    af[0].location = APPLY_STR;
    af[0].duration = (int)(GET_LEVEL(ch)/2);
    if(IS_NPC(victim))
    af[0].modifier = -1;
    else
    af[0].modifier = -20;
    af[0].bitvector3 = AFF3_RAY_OF_ENFEB;
    to_vict="You feel the strength flow out of your body.";
    to_room="$n turns pale and starts to sag.";
    break;

  case SPELL_LEVITATE:
    af[0].duration = (int)(GET_LEVEL(ch)/2);
    af[0].bitvector2 = AFF2_LEVITATE;
    to_vict="&6You float up in the air.&0";
    to_room="&6$n&0&6 floats up into the air.&0";
    break;

  case SPELL_CHILL_TOUCH:
    af[0].location = APPLY_STR;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 1;
    else
      af[0].duration = 4;
    af[0].modifier = -1;
    to_vict = "You feel your strength wither!";
    break;

  case SPELL_ARMOR:
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;
    to_vict = "You feel someone protecting you.";
    break;

  case SPELL_SILENCE:
    if (MOB_FLAGGED(victim,MOB_NOSILENCE) || mag_savingthrow(victim, savetype)) {
      send_to_char("You fail.\r\n", ch);
      return;
    }
    af[0].duration = (int)(GET_LEVEL(ch) / 10);
    af[0].bitvector2 = AFF2_SILENCE;
    to_vict = "&9&bYour throat begins to close, sealing off all chance of communication.&0";
    to_room = "&0$n&7 squeaks as all sound is squelched from $s throat.&0";

    break;

  case SPELL_SOULSHIELD:
    af[0].duration = (int)(GET_LEVEL(ch) / 5);
    af[0].bitvector2 = AFF2_SOULSHIELD;
    refresh = FALSE;
    if (GET_ALIGNMENT(ch) >= 500) {
      to_vict = "&3&bA bright golden aura surrounds your body!&0";
      to_room = "&3&bA bright golden aura surrounds $n's body!&0";
    }
    else if (GET_ALIGNMENT(ch) <= -500) {
      to_vict = "&1&bA &0&1dark red&b aura engulfs you!&0";
      to_room = "&1&bA &0&1dark red&b aura engulfs $n's body!&0";
    }
    else {
      to_vict = "A brief aura surrounds you, then fades.";
      to_room = "A brief aura surrounds $n, then fades.";
      return;
    }
    break;
  case SPELL_REDUCE:
  if(IS_AFFECTED3(victim, AFF3_ENLARGE))
   return;
  if(IS_NPC(victim))
   return;
    af[0].location = APPLY_SIZE;
    af[0].modifier = -1;
    af[0].duration = 3;
    af[0].bitvector3 = AFF3_REDUCE;

    af[1].location = APPLY_CON;
    af[1].modifier = -10;
    af[1].duration = 2;

    af[2].location = APPLY_STR;
    af[2].modifier = -10;
    af[2].duration = 2;

    refresh = TRUE;
    to_vict = "&1&bYour skin starts to itch as you reduce to twice your normal size&0";
    to_room = "&1&b$n's skin ripples as $e shrinks to twice $m normal size!&0";
    break;
  case SPELL_ENLARGE:
   if(IS_AFFECTED3(victim, AFF3_REDUCE))
   return;
   if(IS_NPC(victim))
   return;
    af[0].location = APPLY_SIZE;
    af[0].modifier = 1;
    af[0].duration = 3;
    af[0].bitvector3 = AFF3_ENLARGE;

    af[1].location = APPLY_CON;
    af[1].modifier = 10;
    af[1].duration = 2;

    af[2].location = APPLY_STR;
    af[2].modifier = 10;
    af[2].duration = 2;

    refresh = TRUE;
    to_vict = "&9&bYour skin starts to itch as you enlarge to twice your normal size!&0";
    to_room = "&9&b$n's skin ripples as $e enlarges to twice $m normal size!&0";
    break;
  case SPELL_STONE_SKIN:
    af[0].location = APPLY_NONE;
    af[0].modifier = 7 + (GET_LEVEL(ch) >> 4);
    af[0].duration = 2;
    af[0].bitvector = AFF_STONE_SKIN;
    refresh = FALSE;
    to_vict = "&9&bYou skin hardens and turns to stone!&0";
    to_room = "&9&b$n's skin hardens and turns to stone!&0";
    break;

  case SPELL_HASTE:
    af[0].duration = 5;
	af[0].bitvector = AFF_HASTE;
	to_vict = "&1You start to move with uncanny speed!&0";
	to_room = "&1$n starts to move with uncanny speed!&0";
	break;

  case SPELL_BLUR:
	  af[0].duration = 5;
	  af[0].bitvector = AFF_BLUR;
	  to_vict = "&7The world blurs as you start moving with unnatural speed&0";
	  to_room = "&7$n's image blurs in unnatural speed!&0";
	  break;

  case SPELL_COMPREHEND_LANG:
	  af[0].duration = 10;
	  af[0].bitvector = AFF_COMP_LANG;
	  to_vict = "&8You feel you knowledge of Hubis' languages improving!&0";
	  break;


  case SPELL_BLESS:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 2;
    af[0].duration = 6;

    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 6;

    to_vict = "You feel righteous.";
    break;

  case SPELL_SUNRAY:
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
      return;
    }

    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;

    to_room = "&9&b$n&9&b seems to be blinded!&0";
    to_vict = "&9You have been blinded!&0";
    break;

  case SPELL_BLINDNESS:
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
      send_to_char("You fail.\r\n", ch);
      return;
    }
    /* temp fix until saves fixed. Tired of people blinding guards.*/
    if(number(1,100) > 50) {
      if(IS_NPC(victim) && number(1,100) > 50 && !FIGHTING(victim))
        hit(victim,ch,TYPE_UNDEFINED);
      return;
    }
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;

    to_room = "&9&b$n&9&b seems to be blinded!&0";
    to_vict = "&9You have been blinded!&0";
    break;

  case SPELL_CURSE:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }

    af[0].location = APPLY_HITROLL;
    af[0].duration = 1 + (GET_LEVEL(ch) >> 1);
    af[0].modifier = -1;
    af[0].bitvector = AFF_CURSE;

    af[1].location = APPLY_DAMROLL;
    af[1].duration = 1 + (GET_LEVEL(ch) >> 1);
    af[1].modifier = -1;
    af[1].bitvector = AFF_CURSE;

    accum_affect = TRUE;
    to_room = "$n briefly glows red!";
    to_vict = "You feel very uncomfortable.";
    break;

  case SPELL_DETECT_ALIGN:
    af[0].duration = 12 + level;
    af[0].bitvector = AFF_DETECT_ALIGN;
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_DETECT_INVIS:
    af[0].duration = 12 + level;
    af[0].bitvector = AFF_DETECT_INVIS;
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_DETECT_MAGIC:
    af[0].duration = 12 + level;
    af[0].bitvector = AFF_DETECT_MAGIC;
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_INFRAVISION:
    af[0].duration = 12 + level;
    af[0].bitvector = AFF_INFRAVISION;
    to_vict = "Your eyes glow red.";
    to_room = "$n's eyes glow red.";
    break;

  case SPELL_INVISIBLE:
    if (!victim)
      victim = ch;

    af[0].duration = 12 + (GET_LEVEL(ch) >> 2);
    af[0].modifier = -40;
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
    to_vict = "You vanish.";
    to_room = "$n slowly fades out of existence.";
    break;

  case SPELL_CONCEALMENT:
    if (!victim)
      victim = ch;

    af[0].duration = 12 + (GET_LEVEL(ch) >> 2);
    af[0].modifier = -40;
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
    to_vict = "&9&bYou vanish.&0";
    to_room = "&9&b$n&9&b slowly fades out of existence.&0";
    break;

  case SPELL_POISON:
    if (mag_savingthrow(victim, SAVING_PARA)) {
      send_to_char(NOEFFECT, ch);
      return;
    }

    af[0].location = APPLY_STR;
    af[0].duration = GET_LEVEL(ch);
    af[0].modifier = -2;
    af[0].bitvector = AFF_POISON;
    to_vict = "You feel very sick.";
    to_room = "$n gets violently ill!";
    break;

  case SPELL_PROT_FROM_EVIL:
    af[0].duration = 24;
    af[0].bitvector = AFF_PROTECT_EVIL;
    to_vict = "You feel invulnerable!";
    break;

  case SPELL_SANCTUARY:
    af[0].duration = 4;
    af[0].bitvector = AFF_SANCTUARY;

    to_vict = "A white aura momentarily surrounds you.";
    to_room = "$n is surrounded by a white aura.";
    break;

  case SPELL_SLEEP:
    if (!sleep_allowed && !IS_NPC(ch) && !IS_NPC(victim))
      return;
    if (MOB_FLAGGED(victim, MOB_NOSLEEP))
      return;
    if (mag_savingthrow(victim, savetype))
      return;
    /* temp fix until saves fixed. Tired of people sleeping guards.*/
    if(number(1,100) > 50) {
      if(IS_NPC(victim) && number(1,100) > 50 && !FIGHTING(victim))
        hit(victim,ch,TYPE_UNDEFINED);
      return;
    }

    af[0].duration = 4 + (GET_LEVEL(ch) >> 2);
    af[0].bitvector = AFF_SLEEP;
    refresh = FALSE;

    if (GET_POS(victim) > POS_SLEEPING) {
      act("You feel very sleepy...  Zzzz......", FALSE, victim, 0, 0, TO_CHAR);
      act("$n goes to sleep.", TRUE, victim, 0, 0, TO_ROOM);
      GET_POS(victim) = POS_SLEEPING;
    }
    break;

  case SPELL_STRENGTH:
    af[0].location = APPLY_STR;
    af[0].duration = (GET_LEVEL(ch) >> 1) + 4;
    af[0].modifier = 1 + (level > 18);
    accum_affect = TRUE;
    to_vict = "You feel stronger!";
    break;

  case SPELL_INN_STRENGTH:
	af[0].location = APPLY_STR;
    af[0].duration = (GET_LEVEL(ch) >> 1) + 4;
    af[0].modifier = 1 + (level > 18);
    accum_affect = FALSE;
    to_vict = "You feel stronger!";
    break;

  case SPELL_SENSE_LIFE:
    to_vict = "Your feel your awareness improve.";
    af[0].duration = GET_LEVEL(ch);
    af[0].bitvector = AFF_SENSE_LIFE;
    break;

  case SPELL_WATERWALK:
    af[0].duration = 24;
    af[0].bitvector = AFF_WATERWALK;
    to_vict = "You feel webbing between your toes.";
    break;

  case SPELL_FLY:
    af[0].duration = GET_LEVEL(ch);
    af[0].bitvector = AFF_FLYING;
    to_vict = "&7You fly thru the air, free as a bird!&0";
    GET_POS(ch) = POS_FLYING;
    to_room = "&6&b$n lifts into the air.&0";
    break;

	case SPELL_FARSEE:
    af[0].duration = 12 + level;
    af[0].bitvector = AFF_FARSEE;
    to_vict = "Your sight improves dramatically.";
    to_room = "$n's pupils dilate rapidly for a second.";
    break;

  }

  /*
   * If this is a mob that has this affect set in its mob file, do not
   * perform the affect.  This prevents people from un-sancting mobs
   * by sancting them and waiting for it to fade, for example.
   */
   if (IS_NPC(victim) && (IS_AFFECTED(victim, af[0].bitvector|af[1].bitvector) ||
    IS_AFFECTED2(victim, af[0].bitvector|af[1].bitvector) || IS_AFFECTED3(victim, af[0].bitvector|af[1].bitvector)) &&
       !affected_by_spell(victim, spellnum)) {
	send_to_char(NOEFFECT, ch);
	return;
   }

  /*
   * If the victim is already affected by this spell, and the spell does
   * not have an accumulative effect, then fail the spell.
   */
  if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect||refresh)) {
    send_to_char(NOEFFECT, ch);
    return;
  }

   for (aff = victim->affected; aff && !is_innate; aff = aff->next) {
        if (spellnum == aff->type && aff->duration == -1)
          is_innate=TRUE;
    }

    if (affected_by_spell(victim,spellnum) && is_innate) {
      send_to_char(NOEFFECT, ch);
      return;
    }

  if(!affected_by_spell(victim,spellnum))
  {
  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);
  }

  for (i = 0; i < MAX_SPELL_AFFECTS; i++)
    if (af[i].bitvector || af[i].bitvector2 || af[i].bitvector3 || (af[i].location != APPLY_NONE))
      affect_join(victim, af+i, accum_duration, FALSE, accum_affect, FALSE, refresh);

  if (spellnum == SPELL_REMOVE_POISON)
    check_regen_rates(victim);	/* speed up regen rate immediately */
}


/*
 * This function is used to provide services to mag_groups.  This function
 * is the one you should change to add new group spells.
 */

void perform_mag_groups(int level, struct char_data * ch,
			struct char_data * tch, int spellnum, int savetype)
{
  switch (spellnum) {
    case SPELL_GROUP_HEAL:
    mag_points(level, ch, tch, SPELL_HEAL, savetype);
    break;
  case SPELL_GROUP_ARMOR:
    mag_affects(level, ch, tch, SPELL_ARMOR, savetype);
    break;
  case SPELL_GROUP_RECALL:
    spell_recall(level, ch, tch, NULL, savetype);
    break;
  }
}


/*
 * Every spell that affects the group should run through here
 * perform_mag_groups contains the switch statement to send us to the right
 * magic.
 *
 * group spells affect everyone grouped with the caster who is in the room,
 * caster last.
 *
 * To add new group spells, you shouldn't have to change anything in
 * mag_groups -- just add a new case to perform_mag_groups.
 */

void mag_groups(int level, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *next_tch;
  bool group = 0;

  if (ch == NULL)
    return;

  if (!IS_AFFECTED(ch, AFF_GROUP))
    return;
for (tch = world[ch->in_room].people; tch; tch = next_tch)
        {
                next_tch = tch->next_in_room;
                group = 0;
 if (tch->in_room != ch->in_room)
      continue;
if (ch == tch)
      continue;

                if (is_grouped(ch, tch))
                   perform_mag_groups(level, ch, tch, spellnum, savetype);
}
 /*           if (ch->master != NULL)
    k = ch->master;
  else
    k = ch;
  for (f = k->followers; f; f = f_next) {
    f_next = f->next;
    tch = f->follower;
    if (tch->in_room != ch->in_room)
      continue;
   // if (!IS_AFFECTED(tch, AFF_GROUP))
      continue;
    if (ch == tch)
      continue;
    if (is_grouped(ch, tch))
    perform_mag_groups(level, ch, tch, spellnum, savetype);
  }

  if ((k != ch) && IS_AFFECTED(k, AFF_GROUP))
    perform_mag_groups(level, ch, k, spellnum, savetype);       */
  perform_mag_groups(level, ch, ch, spellnum, savetype);
}


/*
 * mass spells affect every creature in the room except the caster.
 *
 * No spells of this class currently implemented as of Circle 3.0.
 */

void mag_masses(int level, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *tch_next;

  for (tch = world[ch->in_room].people; tch; tch = tch_next) {
    tch_next = tch->next_in_room;
    if (tch == ch)
      continue;

    switch (spellnum) {
    }
  }
}


/*
 * Every spell that affects an area (room) runs through here.  These are
 * generally offensive spells.  This calls mag_damage to do the actual
 * damage -- all spells listed here must also have a case in mag_damage()
 * in order for them to work.
 *
 *  area spells have limited targets within the room.
*/

void mag_areas(int level, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *next_tch;
  char *to_char = NULL;
  char *to_room = NULL;
  bool group = 0;
  int i, min_spell_level=NUM_SPELL_CIRCLES;
  if (ch == NULL)
    return;

  /*
   * to add spells to this fn, just add the message here plus an entry
   * in mag_damage for the damaging part of the spell.
   */
  switch (spellnum) {
  case SPELL_EARTHQUAKE:
    to_char = "&3You gesture and the earth begins to shake all around you!&0";
    to_room = "$n&3 gracefully gestures and the earth begins to shake violently!&0";
    break;
  case SPELL_FREEZING_WIND:
	  to_char = "&6&bYou release a &0&4chilling&6&b stream of air at your foes.&0";
	  to_room = "&6&b$n&6&b releases a &0&4chilling&6&b stream of air.&0";
          break;
  case SPELL_UNHOLY_WORD:
	  to_char = "&9&bYou invoke a word of unholy power!&0";
	  to_room = "&9&b$n &9&butters a word of unholy power!&0";
	  break;
  case SPELL_HOLY_WORD:
	  to_char = "&7&bYou invoke a word of holy power!&0";
	  to_room = "&7&b$n &7&butters a word of holy power!&0";
	  break;
  case SPELL_METEORSWARM:
	  to_char = "&1You conjure up a controlled shower of meteors to crush your foe!&0";
	  to_room = "$n&1 conjures a controlled shower of flaming meteors!&0";
	  break;
  case SPELL_ICE_SHARDS:
	  to_char = "&6&bYou conjure thousands of razor sharp ice shards to massacre your foe!&0";
	  to_room = "$n &6&bconjures thousands of razor sharp ice shards to massacre $s foe!&0";
	  break;
  case SPELL_ICE_STORM:
	  to_char = "&6&bYou crush your foes under a relentless ice storm!&0";
	  to_room = "$n&6&b crushes his foes under a relentless ice storm!&0";
	  break;
  case SPELL_INCENDIARY_NEBULA:
	  to_char  = "&0&2You cackle as your &bwave of gases&0 &2torches your enemies!&0";
	  to_room = "&0$n&2 cackles as his &bwave of gases&0&2 torches his enemies!&0";
	  break;
  case SPELL_CHAIN_LIGHTNING:
	  to_char = "&4&bYou send powerful bolts of lightning from your body...&0";
	  to_room = "&4&b$n&4&b sends powerful bolts of lightning $s his foes...&0";
	  break;
  case SPELL_HELLFIRE_BRIMSTONE:
	  to_char = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
	  to_room = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
	  break;
  case SPELL_FIRESTORM:
	  to_char = "You conjure a gout of flame to sweep through the area.";
	  to_room = "$n waves his hands as a gout of flame floods into the area.";
	  break;
}

  if (to_char != NULL)
    act(to_char, FALSE, ch, 0, 0, TO_CHAR);
  if (to_room != NULL)
    act(to_room, FALSE, ch, 0, 0, TO_ROOM);

  if ((spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(ch) >= 500) ||
      (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(ch) <= -500)) {
    act("&9&bYour word of power is the last thing you hear as your soul is ripped apart!&0", FALSE, ch, 0, 0, TO_CHAR);
    die(ch, ch);
    return;
  }
  if (spell_info[spellnum].violent)
    for(i=0;i<NUM_CLASSES;i++)
      if(spell_info[spellnum].min_circle[i] < 10)
        min_spell_level = MIN(min_spell_level, spell_info[spellnum].min_circle[i]);


	for (tch = world[ch->in_room].people; tch; tch = next_tch)
	{
		next_tch = tch->next_in_room;
		group = 0;


		if (is_grouped(ch, tch))
			continue;



    /*
     * The skips: 1: the caster
     *            2: immortals
     *            3: if no pk on this mud, skips over all players
     *            4: pets (charmed NPCs)
     * players can only hit players in CRIMEOK rooms 4) players can only hit
     * charmed mobs in CRIMEOK rooms
     */
		if (PRF_FLAGGED(ch, PRF_NICEAREA))
                if (!IS_NPC(tch))
		if ((zone_table[world[ch->in_room].zone].number == 147) ||
                   (zone_table[world[ch->in_room].zone].number == 320) ||
                     (zone_table[world[ch->in_room].zone].number == 305) ||
                          (zone_table[world[ch->in_room].zone].number == 250) ||
(zone_table[world[ch->in_room].zone].number == 257) ||
 (zone_table[world[ch->in_room].zone].number == 57))
 if (GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(tch))
continue;

    if (tch == ch)
      continue;
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (!roomaffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
      continue;
    /* WTF was this? remoevd by nech
    if (!IS_NPC(ch) && IS_NPC(tch))
      continue;
   */
/* mobs done area other mobs unless pets Banyal */
   if (IS_NPC(ch) && IS_NPC(tch) && !MOB_FLAGGED (ch, MOB_PET) &&
    !MOB_FLAGGED (tch, MOB_PET))
     continue;
     if (spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(tch) < 500)
       continue;
     if (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(tch) > -500)
       continue;
     if( spellnum!=SPELL_DISPEL_MAGIC &&
        ((IS_AFFECTED2(tch, AFF2_MINOR_GLOBE) && min_spell_level <= 3) ||
        (IS_AFFECTED2(tch, AFF2_MAJOR_GLOBE) && min_spell_level <= 6))){
       act("&1&bThe shimmering globe around your body flares as the spell flows around it.&0", FALSE, ch,0,tch,TO_VICT);
       act("&1&bThe shimmering globe around $N&1&b's body flares as your spell flows around it.&0", FALSE,ch,0,tch,TO_CHAR);
       act("&1&bThe shimmering globe around $N&1&b's body flares as $n&1&b's spell flows around it.&0",FALSE,ch,0,tch,TO_NOTVICT);
       continue;
     }


    mag_damage(GET_LEVEL(ch), ch, tch, spellnum, 1);
  }
}


/*
 *  Every spell which summons/gates/conjours a mob comes through here.
 *
 *  None of these spells are currently implemented in Circle 3.0; these
 *  were taken as examples from the JediMUD code.  Summons can be used
 *  for spells like clone, ariel servant, etc.
 */

static char *mag_summon_msgs[] = {
  "\r\n",
  "$n makes a strange magical gesture; you feel a strong breeze!\r\n",
  "$n animates a corpse!\r\n",
  "$N appears from a cloud of thick blue smoke!\r\n",
  "$N appears from a cloud of thick green smoke!\r\n",
  "$N appears from a cloud of thick red smoke!\r\n",
  "$N disappears in a thick black cloud!\r\n"
  "As $n makes a strange magical gesture, you feel a strong breeze.\r\n",
  "As $n makes a strange magical gesture, you feel a searing heat.\r\n",
  "As $n makes a strange magical gesture, you feel a sudden chill.\r\n",
  "As $n makes a strange magical gesture, you feel the dust swirl.\r\n",
  "$n magically divides!\r\n",
  "$n animates a corpse!\r\n",
  "&1$n summones the powers of a dracolich into the corpse!&0\r\n",
  "$n calls upon the powers of the elemental planes!\r\n",
  "&1$n summons the powers of the abyss and calls forth a demon!&0\r\n",
"&1$n summons forth $N and it doesn't look to impressed!&0\r\n"
};
static char *mag_summon_fail_msgs[] = {
  "\r\n",
  "There are no such creatures.\r\n",
  "Uh oh...\r\n",
  "Oh dear.\r\n",
  "&1&bOh shit!&0\r\n",
  "The elements resist!\r\n",
  "The corpse quivers, briefly.\r\n",
  "&7A corpse would help, dont you think?&0\r\n",
  "&7You can not control anymore dracoliches.&0\r\n",
  "&7You can not control anymore undead.&0\r\n",
  "&7You can not control anymore elementals.&0\r\n",
  "&7You can not control anymore demons.&0\r\n",
  "&7You can not clone yourself again.&0\r\n"
};

#define MOB_MONSUM_I		130
#define MOB_MONSUM_II		140
#define MOB_MONSUM_III		150
#define MOB_GATE_I		160
#define MOB_GATE_II		170
#define MOB_GATE_III		180
#define MOB_ELEMENTAL_BASE	110
#define MOB_CLONE		69
#define MOB_ZOMBIE		11
#define MOB_AERIALSERVANT	109
#define MOB_MENTAL     17
#define MOB_MENTAL2    21
#define MOB_MENTAL3    33
#define GET_SDESC(mob)   ((mob)->player.short_descr)
#define GET_LDESC(mob)     ((mob)->player.long_descr)


void mag_summons(int level, struct char_data * ch, struct obj_data * obj,
		      int spellnum, int savetype)
{
  struct char_data *mob = NULL;
  struct obj_data *tobj, *next_obj;
  struct follow_type *k;
  bool got_good = FALSE;
  int pfail = 0;
bool got_draco =  FALSE;
  int msg = 0, fmsg = 0;
  int num = 1;
  int a, i, b = 0, c, d;
int agro_num = 0;
  int org_room;
  int zom_num = 0;
  int mob_num = 0;
  int handle_corpse = 0;

	if (ch == NULL)
		return;/*if no character get out*/

	switch (spellnum)
	{
	case SPELL_ANIMATE_DEAD:
		/*PLEASE NOTE PLEASE NOTE PLEASE NOTE PLEASE NOTE*/
		/*THIS CODE WILL NEVER BE GOOD UNTIL THERE IS A SKILL RAISE UNDEAD,
		OR A SPELL SPHERE THAT CAN BE ADDED*/

		if ((obj == NULL) || (GET_OBJ_TYPE(obj) != ITEM_CONTAINER)
||	((GET_OBJ_VAL(obj, 3)) < 0))
		{
			act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
			return;
		}
/*worth of mobs:
	zombie, skeleton = 1;
	spectre = 3;
	wraith = 3;
	vampire = 5;
	lich = 5;
	*/
    if (CORPSE_LEVEL(obj) > (GET_LEVEL(ch) + 5))
    {
        send_to_char("Don't think you could handle that corpse.\r\n", ch);
        return;
    }
    d  = 0;

    if (CORPSE_LEVEL(obj)  >= 30)
        if ((mob_proto[GET_OBJ_MOB_FROM(obj)].player.race == SPECIES_DRAGON))
        {
			if (CORPSE_LEVEL(obj) < 50)
		    {
		        if (number(1, 101) >= 70)
                    got_draco = TRUE;
            }
            else
            {
                if (number(1, 101) >= 80)
                got_draco = TRUE;
            }
        }
    if (GET_LEVEL(ch) > LVL_GRGOD)
        if ((mob_proto[GET_OBJ_MOB_FROM(obj)].player.race == SPECIES_DRAGON))
            got_draco = TRUE;


    zom_num = (int)(GET_LEVEL(ch)/3);/*gives lvl21 = 7, lvl30 = 10, lvl50 = 16*/
	org_room = ch->in_room;
		/*c will = the number value of followers*/
	c = 0;

	for (k = ch->followers; k; k = k->next)
	{
	    if ((IS_AFFECTED(k->follower, AFF_CHARM)) && IS_NPC(k->follower))
		{				/* found = TRUE;*/
			switch(GET_MOB_VNUM(k->follower))
			{
			case MOB_ZOMBIE:
				c++;
				break;
			case (MOB_ZOMBIE +1):/*specture*/
				c=c+4;
				break;
			case (MOB_ZOMBIE +2):/*skeleton*/
				c++;
				break;
			case (MOB_ZOMBIE +3):/*vampire*/
				c=c+5;
				got_good = TRUE;
			    break;
			case (MOB_ZOMBIE +4):/*wraith*/
				c=c+3;
				got_good = TRUE;
				break;
		    case (MOB_ZOMBIE +5):/*lich*/
				c=c+5;
				got_good = TRUE;
				break;
			case (4):/*big draco*/
				d = d + 2;
				break;
			case (5):/*small draco*/
				d = d + 1;
				break;
			}

		    if (got_draco)
		    {
			    if (d >= 2)
                {
				    act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
				    return;
                }

		    }
		    else if((c >= zom_num) || ((got_good) && ((c + 5) >= zom_num)))
		    {/*basically that small equation stops people having two GOOD mobs then
		 getting a heap of small mobs*/
			    act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
			    return;
			}

		}
	}

/*	sprintf(buf, "number of c atm is %d \r\n", c);
	send_to_char(buf, ch);*/
	handle_corpse = 1;
	msg = 12;
	mob_num = MOB_ZOMBIE;

		/*ok here we handle what mob he going to get*/
		/*this has to do on level of corpse*/
		/*I am trusting at this point that the obj IS a corpse*/
		/*spectre 20 +
		  wraith 30 +
		  vampire 40 +
		  lich 50+*/
	i = 0;c = 0;b = 0;/*bonus holder*/
	if (CORPSE_LEVEL(obj) == 0)
	{
		pfail = 101;
		fmsg = 6;
		break;
	}
	if (CORPSE_LEVEL(obj) < 20)
	{/*zombie or skeleton*/
		a = number(0, 2);
		if (a != 2)
			mob_num = mob_num + 2;
        agro_num = 5;
    }
	else if (CORPSE_LEVEL(obj) < 30)
	{/*zombie, skeleton, spectre*/
		a = number(0, 9);
		if (GET_LEVEL(ch) > 30)
			a++;
		if (a >= 8)
			mob_num++;/*spectre*/
		else if(a > 6)
			mob_num = mob_num + 2;
        agro_num = 4;
	}else if (CORPSE_LEVEL(obj) < 40)
	{/*zombie, skeleton, spectre, wraith*/
		a = number(0, 20);
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
			/*if sorcerer corpse add to chance of wraith*/
			{
				i =  2;
			}
		if (GET_LEVEL(ch) > 30)
			i++;
		if (GET_LEVEL(ch) > 55)
			i++;
		if (GET_LEVEL(ch) > 60)
			i++;
		if ((a + i) >= 19)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 13)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 9)
			mob_num = mob_num + 2;/*skeleton*/
        agro_num = 3;
	}
	else if (CORPSE_LEVEL(obj) < 49)
	{/*zombie, skeleton, spectre, wraith, vampire*/
		a = number(0, 40);
		b = number(0, 40);

		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
				i = 2;
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
				c = 2;
		if (GET_LEVEL(ch) > 30)
		{
			c++;
			i++;
		}if (GET_LEVEL(ch) > 50)
		{
			c++;c++;
			i++;
		}if (GET_LEVEL(ch) > 60)
		{
			c++;c++;
			c++;
			i++;
		}
		if ((b + c) >= 37)
			mob_num = mob_num + 3;/*vampire*/
		else if ((a + i) > 38)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 30)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 15)
			mob_num = mob_num + 2;/*skeleton*/

        agro_num = 2;
	}
	else
	{
	    a = number(0, 40);
	   	b = number(0, 40);
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
				i = 2;
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
				c = 2;
		if (GET_LEVEL(ch) > 30)
		{
			c++;
			i++;
		}if (GET_LEVEL(ch) > 50)
		{
			c++;c++;
			i++;
		}if (GET_LEVEL(ch) > 60)
		{
			c++;c++;
			c++;
			i++;
		}
		if ((b + ((int)((c+i)/2))) >= 40)
			mob_num = mob_num + 5;/*lich*/
		else if ((b + c) >= 36)
			mob_num = mob_num + 3;/*vampire*/
		else if ((a + i) > 36)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 30)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 15)
			mob_num = mob_num + 2;/*skeleton*/
    agro_num = 1;
	}
    msg = 2;
/*ok if got draco drop whatever you got and make a draco*/
    if (got_draco)
    {
        if (CORPSE_LEVEL(obj) < 50)
        {
            mob_num = 5;
            agro_num = 5;
        }else
        {
            mob_num = 4;
            agro_num = 5;

        }
    msg = 12;
    }

    agro_num = (agro_num) + 2*(MAX(0, (CORPSE_LEVEL(obj) - GET_LEVEL(ch))));
	pfail = 4;
	fmsg = 3;
	break;
	case SPELL_CLONE: /*Banyal was here  */

		handle_corpse = 0;
		msg = 12;
		mob_num = 69;
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next)
		{
			if (org_room == k->follower->in_room)
			if ((IS_AFFECTED(k->follower, AFF_CHARM)) && (GET_MOB_VNUM(k->follower) == MOB_CLONE))
			{
			/* found = TRUE;*/
				c = (c + 1);
		/* if ((found) || (c = 3)) {*/
				if (c > 0)
				{
					act(mag_summon_fail_msgs[13], FALSE, ch, 0, 0, TO_CHAR);
					return;
				}
			}
		}

		mob = read_mobile(mob_num, VIRTUAL);



		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
		char_to_room(mob, ch->in_room);
		strcpy(GET_NAME(mob), GET_NAME(ch));
		strcpy(mob->player.short_descr, GET_NAME(ch)/*("%s stands here.", GET_NAME(ch))*/);
      /*tldesc = str_dup(buf, "%s stands here.", GET_NAME(ch));*/
		strcpy(mob->player.long_descr, GET_NAME(ch));
	  /*strcpy(mob->player.description, GET_NAME(ch));
	  strcpy(mob->player.species, GET_RACE(ch));*/ /*dammit need fixin later Banyal*/

	/*strcpy(mob->player.keyword, GET_NAME(ch));*/
		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry anything */

		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow the caster */
		send_to_char("&7You clone yourself into a magical servent&0.\r\n", ch);
              /* send a message to the caster saying that he succeeded */
		return;
		break;

	case SPELL_SUMMON_DRACOLICH:
	if ((GET_OBJ_TYPE(obj) != ITEM_CONTAINER) || (!GET_OBJ_VAL(obj, 3)))
		{
			act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
			return;
		}
	if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.race != SPECIES_DRAGON)
	{
		send_to_char("You need a better corpse then that for a dracolich!!\r\n", ch);
		return;
	}
    if (CORPSE_LEVEL(obj) < 50)
    {
	    send_to_char("yYou need a better corpse then that for a dracolich!!\r\n", ch);
        return;
    }
		zom_num = 1;

	if (GET_LEVEL(ch) >= 60)
		zom_num = 2;
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next)
		{
				if (IS_AFFECTED(k->follower, AFF_CHARM))
				{

					if ((GET_MOB_VNUM(k->follower) == 4) || (GET_MOB_VNUM(k->follower) == 6)
						|| (GET_MOB_VNUM(k->follower) == 5)|| (GET_MOB_VNUM(k->follower) == 7))
					c = (c + 1);




					if (c >= zom_num)
					{

act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
		}

		handle_corpse = 1;
		msg = 12; /* In an array above, you see the message
numbers. This
                 tells what message number to use */
		a = number(0, 400);
		mob_num = 0;
		if (a < 140)
			mob_num = 5;
		else if (a < 260)
			mob_num = 5;
		else if (a < 350)
			mob_num = 5;
		else if (a < 400)
			mob_num = 4;
		pfail = 3;
		send_to_char("&9&bThe dracolich roars to life!&0\r\n", ch);
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
		break;

	case SPELL_SUMMON_ELEMENTAL:
		handle_corpse = 0;
		d = GET_LEVEL(ch);
		if (d < 22)
			zom_num = 1;
		else if (d < 31)
			zom_num = 2;
		else if (d < 41)
			zom_num = 2;
		else if (d < 78)
			zom_num = 2; /* added for possible change for
game balence*/
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next)
		{
				if (IS_AFFECTED(k->follower, AFF_CHARM))
				{
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL)))
							c = (c + 1);
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL2)))
							c = (c + 1);
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL3)))
							c = (c + 1);

					if (c >= zom_num)
					{

act(mag_summon_fail_msgs[10], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
		}

		msg = 13;
		if ((GET_LEVEL(ch)) < 31)
		{
			agro_num = 7;
			mob_num = MOB_MENTAL;
		}
		else if ((GET_LEVEL(ch)) < 41)
		{
			agro_num = 6;
			mob_num = MOB_MENTAL2;
		}
		else if ((GET_LEVEL(ch)) < 58)
		{
			agro_num = 4;
			mob_num = MOB_MENTAL3;
		}
		else
		{
			agro_num = 3;
			mob_num = MOB_MENTAL3;
		}
		a = number(0, 400);
		if (a < 121)
			b = 0;
		else if (a < 241)
			b = 1;
		else if (a < 361)
			b = 2;
		else if (a < 400)
			b = 3;
	/*b = number(0, 3);*/
		while (b)
		{
			mob_num++;
			b--;
		}

		mob = read_mobile(mob_num, VIRTUAL);
		/*reset mob for characters level*/
		reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		char_to_room(mob, ch->in_room);

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */
if (number(0, 101) < agro_num)
		{
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{

		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		send_to_char("The elemental you summoned appears before you.\r\n", ch);
              /* send a message to the caster saying that he succeeded */
		return;
		break;

	case SPELL_SUMMON_DEMON:

		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next)
		{
				if (IS_AFFECTED(k->follower, AFF_CHARM))
				{
					for (i=0;i<=2;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + 25)))
							c = (c + 1);

					if (c > 0)
					{

act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
		}
   /* if ((found) || (c = 2)) {
	 act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
	 return;
	}*/

		handle_corpse = 0;

		msg = 14; /* In an array above, you see the message
numbers. This
                 tells what message number to use */

		a = number(0, 300);
		mob_num = 0;
		if (a < 151)
			mob_num = 27;
		else if (a < 251)
			mob_num = 26;
		else
			mob_num = 25;

		pfail = 8;
	agro_num = 7;
		send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch);
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		mob = read_mobile(mob_num, VIRTUAL);
	 reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
/*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/

		char_to_room(mob, ch->in_room);

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */
if (number(0, 101) < agro_num)
		{
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */

		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		return;

		break;

	case SPELL_SUMMON_GREATER_DEMON:
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next)
		{

				if (IS_AFFECTED(k->follower, AFF_CHARM))
				{

						for (i=0;i<=1;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + 29)))
							c = (c + 1);

					if (c > 0)
					{

act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
		}
   /* if ((found) || (c = 2)) {
	 act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
	 return;
	}*/
          agro_num = 3;
		handle_corpse = 0;

		msg = 14; /* In an array above, you see the message
numbers. This
                 tells what message number to use */

		a = number(0, 200);
		mob_num = 0;

		if (a < 151)
			mob_num = 30;
		else
			mob_num = 29;


		pfail = 4;

		send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch);
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		mob = read_mobile(mob_num, VIRTUAL);
	 reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
/*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/

		char_to_room(mob, ch->in_room);

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */

		if (number(0, 101) < agro_num)
		{
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
		}else
		{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		return;
		break;




		default:
		return;
	}

	if (IS_AFFECTED(ch, AFF_CHARM))
	{
		send_to_char("You are too giddy to have any followers!\r\n", ch);
		return;
	}
	if (number(0, 101) < pfail)
	{
			CORPSE_LEVEL(obj) = 0;
		send_to_char(mag_summon_fail_msgs[fmsg], ch);
		return;
	}
	for (i = 0; i < num; i++)
	{
		/*finding level of corpse*/
		mob = read_mobile(mob_num, VIRTUAL);

		/*reset mob for characters level*/
		reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, obj);
		char_to_room(mob, ch->in_room);
// VAMPIRS HAVE VAMP TOUCH YOU KNOW BANYAL
// So do dracos Banyal
if((mob_num == 14 || mob_num == 4 || mob_num == 5 || mob_num ==6 ||
 mob_num == 7))
SET_BIT(AFF3_FLAGS(mob), AFF3_VAMP_TOUCH);

	IS_CARRYING_W(mob) = 0;
		IS_CARRYING_N(mob) = 0;
if (number(0, 101) < agro_num)
{
act(mag_summon_msgs[16], FALSE, ch, 0, mob,TO_ROOM);
SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM);
		add_follower(mob, ch);
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
}	}
if (handle_corpse)
	{
for (tobj = obj->contains; tobj != NULL; tobj = tobj->next_content)
tobj->in_obj = obj;
		for (tobj = obj->contains; tobj; tobj = next_obj)
		{
			next_obj = tobj->next_content;
			obj_from_obj(tobj);
			obj_to_char(tobj, mob);
			if((GET_OBJ_TYPE(tobj) == ITEM_MONEY)){
			if ((GET_OBJ_VAL(tobj, 0)+GET_OBJ_VAL(tobj,
1)+GET_OBJ_VAL(tobj, 2)+GET_OBJ_VAL(tobj, 3)) > 0){
	  obj_from_char(tobj);
	  GET_PLAT(mob) += GET_OBJ_VAL(tobj, 0);
	GET_GOLD(mob) += GET_OBJ_VAL(tobj, 1);
	GET_SILVER(mob) += GET_OBJ_VAL(tobj, 2);
	GET_COPPER(mob) += GET_OBJ_VAL(tobj, 3);
	  extract_obj(tobj);}
	}
		}
		extract_obj(obj);
	}}


void mag_points(int level, struct char_data * ch, struct char_data * victim,
		     int spellnum, int savetype)
{
  int hit = 0;
  int move = 0;
  int hunger = 0;
  int thirst = 0;

  if (victim == NULL)
    return;

  switch (spellnum) {
  case SPELL_CURE_LIGHT:
    hit = dice(1, 8) + 1 + (level >> 2);
    send_to_char("You feel better.\r\n", victim);

    break;
  case SPELL_CURE_CRITIC:
    hit = dice(3, 8) + 3 + (level >> 2);
    send_to_char("You feel a lot better!\r\n", victim);
    break;
  case SPELL_CURE_SERIOUS:
    hit = dice(2, 8) + 2 + (level >> 2);
    send_to_char("You feel much better!\r\n", victim);
    break;
  case SPELL_HEAL:
    hit = 100 + dice(3, 8);
    send_to_char("A warm feeling floods your body.\r\n", victim);
    break;
   case SPELL_FULL_HEAL:
    hit = 300 + dice(3, 8);
    send_to_char("&7You been FULLY healed!&0\r\n", victim);
    break;
  case SPELL_VIGORIZE_LIGHT:
    move = dice(2, 8) + 3 + (level >> 2);
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_VIGORIZE_SERIOUS:
    move = dice(4, 8) + 3 + (level >> 2);
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_VIGORIZE_CRITIC:
    move = dice(6, 8) + 3 + (level >> 2);
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_NOURISHMENT:
    hunger = 24;
    thirst = 24;
    act("&2&b$n&2&b sprouts roots that dig deep beneath the soil, drawing sustenence.&0",TRUE,victim,0,0,TO_ROOM);
    act("&2&bYou sprouts roots that dig deep beneath the soil, drawing sustenence.&0",FALSE,victim,0,0,TO_CHAR);
    break;
  case SPELL_INVIGORATE:
    move = GET_MAX_MOVE(victim);
    send_to_char("You feel fully vigorized!\r\n", victim);
    break;
  }
  alter_hit(victim, -hit, 4);
  alter_move(victim, -move);
  gain_condition(victim, FULL, hunger);
  gain_condition(victim, THIRST, thirst);
}


void mag_unaffects(int level, struct char_data * ch, struct char_data * victim,
		        int spellnum, int type)
{
  int spell = 0;
  char *to_vict = NULL, *to_room = NULL;

  if (victim == NULL)
    return;

  switch (spellnum) {
  case SPELL_DOUSE:
    REMOVE_BIT(AFF2_FLAGS(victim), AFF2_ON_FIRE);
    send_to_char("You are doused with a magical liquid.\r\n",victim);
    return;
  case SPELL_SANE_MIND:
    spell = SPELL_INSANITY;
    if(IS_AFFECTED2(victim, AFF2_INSANITY)) {
      to_vict="Your mind comes back to reality.";
    }
    break;
  case SPELL_ENLARGE:
  if(!IS_AFFECTED3(victim, AFF3_REDUCE))
  return;
  spell = SPELL_REDUCE;
   if(IS_AFFECTED3(victim, AFF3_REDUCE)) {
    to_vict ="&8You return to your normal size.&0";
   }
   break;
  case SPELL_REDUCE:
  if(!IS_AFFECTED3(victim, AFF3_ENLARGE))
  return;
  spell = SPELL_ENLARGE;
   if(IS_AFFECTED3(victim, AFF3_ENLARGE)) {
    to_vict ="&8You return to your normal size.&0";
   }
   break;
  case SPELL_CURE_BLIND:
  case SPELL_HEAL:
  if(!IS_AFFECTED(victim, AFF_BLIND))
  return;
    spell = SPELL_BLINDNESS;
    if (IS_AFFECTED(victim, AFF_BLIND)){
    to_vict = "Your vision returns!";
    to_room = "There's a momentary gleam in $n's eyes.";
    }
    if (affected_by_spell(victim, SPELL_DISEASE)) {
      affect_from_char(victim, SPELL_DISEASE);
      act("Your disease has been cured.",FALSE,0,0,victim,TO_VICT);
    }
    break;
  case SPELL_FULL_HEAL:
   if(!IS_AFFECTED(victim, AFF_BLIND))
  return;
    spell = SPELL_BLINDNESS;
    if (IS_AFFECTED(victim, AFF_BLIND)){
    to_vict = "Your vision returns!";
    to_room = "There's a momentary gleam in $n's eyes.";
    }
    if (affected_by_spell(victim, SPELL_DISEASE)) {
      affect_from_char(victim, SPELL_DISEASE);
      act("Your disease has been cured.",FALSE,0,0,victim,TO_VICT);
    }
    break;
  case SPELL_REMOVE_POISON:
    spell = SPELL_POISON;
    to_vict = "A warm feeling runs through your body!";
    to_room = "$n looks better.";
    break;
  case SPELL_REMOVE_CURSE:
    spell = SPELL_CURSE;
    to_vict = "You don't feel so unlucky.";
    break;
  default:
    sprintf(buf, "SYSERR: unknown spellnum %d passed to mag_unaffects", spellnum);
    log(buf);
    return;
    break;
  }

  if (!affected_by_spell(victim, spell) && spellnum != SPELL_HEAL) {
    send_to_char(NOEFFECT, ch);
    return;
  }

  affect_from_char(victim, spell);
  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);

}


void mag_alter_objs(int level, struct char_data * ch, struct obj_data * obj,
		         int spellnum, int savetype)
{
  char *to_char = NULL;
  char *to_room = NULL;

  if (obj == NULL)
    return;

  switch (spellnum) {
    case SPELL_BLESS:
      if (!IS_OBJ_STAT(obj, ITEM_BLESS) &&
	  (GET_OBJ_WEIGHT(obj) <= 5 * GET_LEVEL(ch))) {
	SET_BIT(GET_OBJ_EXTRA(obj), ITEM_BLESS);
	to_char = "$p glows briefly.";
      }
      break;
    case SPELL_CONTINUAL_LIGHT:
     if (!IS_OBJ_STAT(obj, ITEM_CONT_LIGHT)) {
      SET_BIT(obj->obj_flags.extra_flags, ITEM_CONT_LIGHT);
      to_char = "$p glows briefly.";
    }
    break;
    case SPELL_CURSE:
      if (!IS_OBJ_STAT(obj, ITEM_NODROP)) {
	SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NODROP);
	if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
	  GET_OBJ_VAL(obj, 2)--;
	to_char = "$p briefly glows red.";
      }
      break;
    case SPELL_INVISIBLE:
      if (!IS_OBJ_STAT(obj, ITEM_NOINVIS | ITEM_INVISIBLE)) {
        SET_BIT(obj->obj_flags.extra_flags, ITEM_INVISIBLE);
        to_char = "$p vanishes.";
      }
      break;
    case SPELL_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && !GET_OBJ_VAL(obj, 3)) {
      GET_OBJ_VAL(obj, 3) = 1;
      to_char = "$p steams briefly.";
      }
      break;
    case SPELL_REMOVE_CURSE:
      if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
        REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
        if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
          GET_OBJ_VAL(obj, 2)++;
        to_char = "$p briefly glows blue.";
      }
      break;
    case SPELL_REMOVE_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && GET_OBJ_VAL(obj, 3)) {
        GET_OBJ_VAL(obj, 3) = 0;
        to_char = "$p steams briefly.";
      }
      break;
  }

  if (to_char == NULL)
    send_to_char(NOEFFECT, ch);
  else
    act(to_char, TRUE, ch, obj, 0, TO_CHAR);

  if (to_room != NULL)
    act(to_room, TRUE, ch, obj, 0, TO_ROOM);
  else if (to_char != NULL)
    act(to_char, TRUE, ch, obj, 0, TO_ROOM);

}



void mag_creations(int level, struct char_data * ch, int spellnum)
{
  char *to_char=NULL, *to_room=NULL;
  struct obj_data *tobj;
  int z;
  int give_char=0;
  if (ch == NULL)
    return;
  level = MAX(MIN(level, LVL_IMPL), 1);

  switch (spellnum) {
  case SPELL_CREATE_SPRING:
    z = 75;
    to_room="&4A fresh clear spring of water bursts through the ground here.&0";
    to_char="&4A fresh clear spring of water bursts through the ground here.&0";
    break;
  case SPELL_CREATE_FOOD:
    z = 10;
    give_char=1;
    to_room="$n creates $p.";
    to_char="You create $p.";
    break;
  default:
    send_to_char("Spell unimplemented, it would seem.\r\n", ch);
    return;
    break;
  }

  if (!(tobj = read_object(z, VIRTUAL))) {
    send_to_char("I seem to have goofed.\r\n", ch);
    sprintf(buf, "SYSERR: spell_creations, spell %d, obj %d: obj not found",
	    spellnum, z);
    log(buf);
    return;
  }
  if(give_char)
    obj_to_char(tobj, ch);
  else
    obj_to_room(tobj, ch->in_room);
  if(to_room)
    act(to_room, FALSE, ch, tobj, 0, TO_ROOM);
  if(to_char)
    act(to_char, FALSE, ch, tobj, 0, TO_CHAR);
}

void mag_room(int level, struct char_data * ch, int spellnum)
{
	long aff; /* what affection */
	int ticks; /* how many ticks this spell lasts */
	char *to_char = NULL;
	char *to_room = NULL;
	struct raff_node *raff;

	extern struct raff_node *raff_list;

	aff = ticks =0;

	if (ch == NULL)
		return;
	level = MAX(MIN(level, LVL_IMPL), 1);

	switch (spellnum) {
	case SPELL_WALL_OF_FOG:
		to_char = "You create a fog out of nowhere.";
		to_room = "$n creates a fog out of nowhere.";
		aff = RAFF_FOG;
		ticks = 1; /* this spell lasts one tick */
		break;
	case SPELL_DARKNESS:
		if (ROOM_AFFECTED(ch->in_room, RAFF_CONTINUAL_LIGHT)) {
		to_char = "You dispel the magical light.";
		to_room = "$n dispels the magical light.";
		REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_CONTINUAL_LIGHT);
		aff = 0;
		break;
		}else
		to_char = "You engulf the area in a magical darkness!";
		to_room = "$n engulfs the area in a magical darkness!";
		aff = RAFF_DARKNESS;
		ticks = 1;
		break;
	case SPELL_CONTINUAL_LIGHT:
		if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
		to_char = "&8Your magical light dispels the darkness.&0";
		to_room = "&8$n's magical light dispels the darkness.&0";
		REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_DARKNESS);
		aff = 0;
		break;
		}else
		to_char = "&8The room magically lights up!&0";
		to_room = "&8The room magically lights up!&0";
		aff = RAFF_CONTINUAL_LIGHT;
		ticks = 1;
		break;
	case SPELL_URBAN_RENEWAL:
		if(SECT(ch->in_room) == SECT_FOREST || ROOM_AFFECTED(ch->in_room, RAFF_FOREST)) {
		  send_to_char("There is already enough foliage here to constitute a forest.\r\n",ch);
		  return;
		}
		if(!OUTSIDE(ch) || SECT(ch->in_room) == SECT_INSIDE) {
		  send_to_char("This place is too enclosed to grow foliage.\r\n",ch);
		  return;
		}
		aff = RAFF_FOREST;
		ticks = GET_LEVEL(ch) / 10;
		to_char="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
		to_room="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
		break;
	case SPELL_CIRCLE_OF_FIRE:
		if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE)) {
		  send_to_char("The room is already on fire.\r\n",ch);
		  return;
		}
		if(SECT(ch->in_room) == SECT_WATER_SWIM ||
		   SECT(ch->in_room) == SECT_WATER_NOSWIM ||
		   SECT(ch->in_room) == SECT_OCEAN ||
		   SECT(ch->in_room) == SECT_UNDERWATER) {
		  send_to_char("Impossible. There is too much water here.\r\n",ch);
		  return;
		}
		aff = RAFF_CIRCLE_FIRE;
		ticks = 2;
		to_char="&1A ring of fire encircles the area.&0";
		to_room="&1A ring of fire encircles the area.&0";
		break;
	/* add more room spellscontinual here */

	default:
		sprintf(buf, "SYSERR: unknown spellnum %d "
		"passed to mag_unaffects", spellnum);
		log(buf);
		break;
	}

	/* create, initialize, and link a room-affection node */
	CREATE(raff, struct raff_node, 1);
	raff->room = ch->in_room;
	raff->timer = ticks;
	raff->affection = aff;
	raff->spell = spellnum;
	raff->next = raff_list;
	raff_list = raff;

	/* set the affection */
	if (aff != 0)
	SET_BIT(ROOM_AFFECTIONS(raff->room), aff);

	if (to_char == NULL)
		send_to_char(NOEFFECT, ch);
	else
		act(to_char, TRUE, ch, 0, 0, TO_CHAR);

	if (to_room != NULL)
		act(to_room, TRUE, ch, 0, 0, TO_ROOM);
	else if (to_char != NULL)
		act(to_char, TRUE, ch, 0, 0, TO_ROOM);
}
@


1.297
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: magic.c,v 1.296 2010/06/05 18:58:47 mud Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: magic.c                                        Part of FieryMUD *
 *  Usage: low-level functions for magic; spell template code              *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <math.h>
#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "casting.h"
#include "handler.h"
#include "db.h"
#include "events.h"
#include "races.h"
#include "skills.h"
#include "math.h"
#include "constants.h"
#include "chars.h"
#include "magic.h"
#include "regen.h"
#include "exits.h"
#include "fight.h"
#include "movement.h"
#include "limits.h"
#include "composition.h"
#include "lifeforce.h"
#include "charsize.h"
#include "damage.h"
#include "spells.h"
#include "directions.h"

extern int mini_mud;
extern int pk_allowed;
extern int sleep_allowed;
extern int summon_allowed;
extern int charm_allowed;
extern int roomeffect_allowed;

int real_mobile(int);

void half_chop(char *string, char *arg1, char *arg2);
int is_abbrev(char *arg1, char *arg2);
bool is_grouped(struct char_data *ch, struct char_data *tch);
void add_follower(struct char_data * ch, struct char_data * leader);
int dice(int number, int size);
int get_spell_duration(struct char_data *ch, int spellnum);
int get_vitality_hp_gain(struct char_data *ch, int spellnum);
char* get_vitality_vict_message(int spellnum);
bool check_armor_spells(struct char_data *ch, struct char_data *victim, int spellnum);

struct char_data *read_mobile(int, int);


/* See whether someone evades a spell entirely, for the following reasons:
 *
 * -- major/minor globe
 * -- elemental immunity
 * -- immortal victim
 */

bool evades_spell(struct char_data *caster, struct char_data *vict, int spellnum, int power)
{
   int sus;

   /* Non-violent spells don't need to be evaded. */
   if (!SINFO.violent)
     return FALSE;

   /* Dispel magic is a special case */
   if (spellnum == SPELL_DISPEL_MAGIC)
      return FALSE;

   /* Major/minor globe */
   if (EFF_FLAGGED(vict, EFF_MINOR_GLOBE) || EFF_FLAGGED(vict, EFF_MAJOR_GLOBE)) {

      /* Minor globe blocks circle 3 and below.  Major globe blocks 6 and down. */
      if ((EFF_FLAGGED(vict, EFF_MINOR_GLOBE) && SINFO.lowest_level <= CIRCLE_3) ||
          (EFF_FLAGGED(vict, EFF_MAJOR_GLOBE) && SINFO.lowest_level <= CIRCLE_6)) {
         act("&1&bThe shimmering globe around your body flares as the spell flows around it.&0",
               FALSE, caster, 0, vict, TO_VICT);
         act("&1&bThe shimmering globe around $N&1&b's body flares as your spell flows around it.&0",
               FALSE, caster, 0, vict, TO_CHAR);
         act("&1&bThe shimmering globe around $N&1&b's body flares as $n&1&b's spell flows around it.&0",
               FALSE, caster, 0, vict, TO_NOTVICT);
      return TRUE;
    }
  }

  if (skills[spellnum].damage_type == DAM_UNDEFINED)
    return FALSE;

  sus = susceptibility(vict, skills[spellnum].damage_type);

  /* If your susceptibility is Zero, we'll stop this thing right now, so
   * that immunity can block effects. */
  if (sus == 0) {
    if (caster == vict) {
      act("&6$n's&6 spell has no effect on $m.&0", FALSE, caster, 0, vict, TO_NOTVICT);
      act("&6Your spell has no effect on you.&0", FALSE, caster, 0, vict, TO_CHAR);
    } else {
      act("&6$n's&6 spell has no effect on $N.&0", FALSE, caster, 0, vict, TO_NOTVICT);
      act("&6Your spell has no effect on $N!&0", FALSE, caster, 0, vict, TO_CHAR);
      act("&6$n's&6 spell has no effect on you!&0", FALSE, caster, 0, vict, TO_VICT);
    }
    return TRUE;
  }

  /* Are you trying to harm or disable an immortal? */
  if (!IS_NPC(vict) && GET_LEVEL(vict) >= LVL_IMMORT) {
     /* This will cause the "You're trying to silence a god? Ha!" message
      * to be sent */
      if (!skill_message(0, caster, vict, spellnum, FALSE)) {
         /* There's no specific message for this spell - send generic
          * messages instead */
         /* to caster */
         act("$N ignores your feeble spell.", FALSE, caster, 0, vict, TO_CHAR);
         /* to victim */
         act("You ignore $n's feeble spell.", FALSE, caster, 0, vict, TO_VICT);
         /* to room */
         act("$N ignores $n's feeble spell.", FALSE, caster, 0, vict, TO_NOTVICT);
     }
     return TRUE;
  }

  if (skills[spellnum].routines & (MAG_DAMAGE | MAG_MANUAL))
    /* For spells that do actual damage, evasion will be checked during
     * the actual damage() call. */
    return FALSE;

  /* Stuff like word of command would fall into this category:
   *   has a damage type, but doesn't do physical damage */
  if (boolean_attack_evasion(vict, power, skills[spellnum].damage_type)) {
    act("&6$n's&6 spell passes over $N harmlessly.&0", FALSE, caster, 0, vict, TO_NOTVICT);
    act("&6Your spell passes over $N harmlessly!&0", FALSE, caster, 0, vict, TO_CHAR);
    act("&6$n's&6 spell passes over you harmlessly!&0", FALSE, caster, 0, vict, TO_VICT);
    set_fighting(vict, caster, FALSE);
    return TRUE;
  }

  return FALSE;
}


void abort_casting(struct char_data *ch)
{
   if (CASTING(ch)) {
      STOP_CASTING(ch);
      /* Don't say they stop chanting if they've been knocked
       * out or killed - it looks funny. */
      if (!AWAKE(ch)) return;
      act("You stop chanting abruptly!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops chanting abruptly!", FALSE, ch, 0, 0, TO_ROOM);
   }
}

struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output)
{
   if (!ch || !victim)
      return NULL;
   if (ch->casting.target_status != TARGET_ALL_ROOM
         && victim->guarded_by
         && victim->guarded_by->in_room == victim->in_room
         && CAN_SEE(victim->guarded_by, victim)
         && GET_SKILL(victim->guarded_by, SKILL_GUARD)
         && !CHECK_WAIT(victim->guarded_by)
         && GET_POS(victim->guarded_by) >= POS_STANDING
         && GET_STANCE(victim->guarded_by) >= STANCE_ALERT
         && attack_ok(ch, victim->guarded_by, FALSE)) {
      improve_skill (victim->guarded_by, SKILL_GUARD);
      if (GET_ISKILL(victim->guarded_by, SKILL_GUARD) > number(1, 1100)) {
         if (!gag_output) {
            act("$n jumps in front of $N, shielding $M from the assault.",
                  FALSE, victim->guarded_by, 0, victim, TO_NOTVICT);
            act("$n jumps in front of you, shielding you from the assault.",
                  FALSE, victim->guarded_by, 0, victim, TO_VICT);
            act("You jump in front of $N, shielding $M from the assault.",
                  FALSE, victim->guarded_by, 0, victim, TO_CHAR);
         }
         return victim->guarded_by;
      } else if (!gag_output) {
         act("$n tries to intercept the attack on $N, but isn't quick enough.",
               FALSE, victim->guarded_by, 0, victim, TO_NOTVICT);
         act("$n tries to shield you from the attack, but can't move fast enough.",
               FALSE, victim->guarded_by, 0, victim, TO_VICT);
         act("You try to block the attack on $N, but aren't quick enough.",
               FALSE, victim->guarded_by, 0, victim, TO_CHAR);
      }
   }
   return victim;
}

int mag_savingthrow(struct char_data * ch, int type)
{
  int get_base_saves(struct char_data *ch, int type);
  int save;

  /* negative save numbers is better! */

  /* get the base save */
  save = get_base_saves(ch, type);

  /* apply character's save modifiers */
  switch(type) {
    case SAVING_SPELL:
      save += GET_SAVE(ch, SAVING_SPELL);
      break;
    case SAVING_PARA:
      save += GET_SAVE(ch, SAVING_PARA);
      break;
    case SAVING_BREATH:
      save += GET_SAVE(ch, SAVING_BREATH);
      break;
    case SAVING_ROD:
      save += GET_SAVE(ch, SAVING_ROD);
      break;
    case SAVING_PETRI:
      save += GET_SAVE(ch, SAVING_PETRI);
  }

  /* throwing a 0 is always a failure */
  if (MAX(1, save) < number(0, 99))
    return TRUE;

  return FALSE;
}

/* Decrease modifier is used to decrease the modifiers for
 * stone skin and bone draw by 1
 *  Can be used by any effect really with minor code change
 */
void decrease_modifier(struct char_data * i, int spell)
{
  struct effect *eff, *tmp;

  for (eff = i->effects; eff; eff = tmp) {
    tmp = eff->next;
    if (eff->type == spell) {
      if (spell == SPELL_BONE_DRAW) {
        act("One of the bones locking you in place shatters under the attack!", FALSE, i, 0, 0, TO_CHAR);
        act("One of the bones locking $n in place shatters under the attack!", FALSE, i, 0, 0, TO_ROOM);
      }
      if (eff->modifier > 1)
        eff->modifier--;
      else
        active_effect_remove(i, eff); /*remove bit*/
      return;
    }
  }


}

/* effect_update: called from comm.c (causes spells to wear off) */
void effect_update(void)
{
  struct room_effect_node *reff, *next_reff, *temp;
  static struct effect *eff, *next;
  static struct char_data *i, *nexti;

  for (i = character_list; i; i = nexti) {
    nexti = i->next;
    for (eff = i->effects; eff; eff = next) {
      next = eff->next;
      if (eff->duration >= 1)
        eff->duration--;
      else if (eff->duration == -1)        /* No action */
        eff->duration = -1;        /* GODs only! unlimited */
      else
        active_effect_remove(i, eff);
    }
    /* if the mob was animated and now isn't, kill 'im. */
    if (MOB_FLAGGED(i, MOB_ANIMATED) && !EFF_FLAGGED(i, EFF_ANIMATED)) {
      act("$n freezes and falls twitching to the ground.", FALSE, i, 0, 0,
          TO_ROOM);
      die(i, NULL);
    }
    /* if the mob was an illusion and its magic ran out, get rid of it */
    if (MOB_FLAGGED(i, MOB_ILLUSORY) && !EFF_FLAGGED(i, EFF_ANIMATED)) {
      act("$n dissolves into tiny multicolored lights that float away.",
            TRUE, i, 0, 0, TO_ROOM);
      extract_char(i);
    }
  }
  for (reff = room_effect_list; reff; reff = next_reff) {
    next_reff = reff->next;

    reff->timer--;

    if (reff->timer <= 0) {
      /* this room effect has expired */
      if (ROOM_EFF_FLAGGED(reff->room, reff->effect) &&
          skills[reff->spell].wearoff) {
        send_to_room(skills[reff->spell].wearoff,
                     reff->room);
        send_to_room("\r\n", reff->room);
      }

      /* remove the effect */
      if (ROOM_EFF_FLAGGED(reff->room, ROOM_EFF_DARKNESS))
         world[(int)reff->room].light++;
      if (ROOM_EFF_FLAGGED(reff->room, ROOM_EFF_ILLUMINATION))
         world[(int)reff->room].light--;
      REMOVE_FLAG(world[(int)reff->room].room_effects,
                 reff->effect);
      REMOVE_FROM_LIST(reff, room_effect_list, next);
        free(reff);
    }
  }
}

void remove_char_spell(struct char_data *ch, int spellnum)
{
  static struct effect *eff, *next;

   for (eff = ch->effects; eff; eff = next) {
      next = eff->next;
      if (eff->type == spellnum)
         active_effect_remove(ch, eff);
   }
}

/*
 *  mag_materials:
 *  Checks for up to 3 vnums (spell reagents) in the player's inventory.
 *
 * No spells implemented in Circle 3.0 use mag_materials, but you can use
 * it to implement your own spells which require ingredients (i.e., some
 * heal spell which requires a rare herb or some such.)
 */
int mag_material(struct char_data * ch, int item0, int item1, int item2,
                      int extract, int verbose)
{
  struct obj_data *tobj;
  struct obj_data *obj0 = NULL, *obj1 = NULL, *obj2 = NULL;

  for (tobj = ch->carrying; tobj; tobj = tobj->next_content) {
    if ((item0 > 0) && (GET_OBJ_VNUM(tobj) == item0)) {
      obj0 = tobj;
      item0 = -1;
    } else if ((item1 > 0) && (GET_OBJ_VNUM(tobj) == item1)) {
      obj1 = tobj;
      item1 = -1;
    } else if ((item2 > 0) && (GET_OBJ_VNUM(tobj) == item2)) {
      obj2 = tobj;
      item2 = -1;
    }
  }
  if ((item0 > 0) || (item1 > 0) || (item2 > 0)) {
    if (verbose) {
      switch (number(0, 2)) {
      case 0:
        send_to_char("A wart sprouts on your nose.\r\n", ch);
        break;
      case 1:
        send_to_char("Your hair falls out in clumps.\r\n", ch);
        break;
      case 2:
        send_to_char("A huge corn develops on your big toe.\r\n", ch);
        break;
      }
    }
    return (FALSE);
  }
  if (extract) {
    if (item0 < 0) {
      obj_from_char(obj0);
      extract_obj(obj0);
    }
    if (item1 < 0) {
      obj_from_char(obj1);
      extract_obj(obj1);
    }
    if (item2 < 0) {
      obj_from_char(obj2);
      extract_obj(obj2);
    }
  }
  if (verbose) {
    send_to_char("A puff of smoke rises from your pack.\r\n", ch);
    act("A puff of smoke rises from $n's pack.", TRUE, ch, NULL, NULL, TO_ROOM);
  }
  return (TRUE);
}


/* A standardized calculation for single-target sorcerer spells.
 *
 * This is calibrated such that sorcerer damage will be 120-110%
 * as much as warrior damage at any given level.
 * It also depends on the casting times of these spells
 * being specific values. */
int sorcerer_single_target(struct char_data *ch, int spell, int power)
{
   int circle, minlevel;
   double exponent;

   if (!get_spell_assignment_circle(ch, spell, &circle, &minlevel)) {
      log("SYSERR: Cannot get circle/level of spell %d for %s", spell, GET_NAME(ch));
      return 1;
   }

   /*
       This makes the exponent 1.3 when a spell is first introduced, so its power
       rises along with levels pretty steadily.

       As the level gets farther and farther from the spell, however, the exponent
       shrinks, eventually getting down to 1.1.

       The results of this calculation are:

        * A newly-introduced spell will gain significant power as the caster's
          power (proficiency in that skill) increases.
        * Spells will always increase in power.  Even when you go from level 90
          to level 91, your power in 1st level "burning hands" will increase.
        * Low-level spells increase only minutely at higher levels. So you
          don't end up with "burning hands" doing 400 damage.

   */
   exponent = 1.2 + 0.3 * minlevel / 100.0 + (power - minlevel) *
      (0.004 * minlevel - 0.2) / 100.0;

   log("sorcerer_single_target: exponent =%0.2f power=%d minlevel=%d\n",
         exponent, power, minlevel);

   switch (circle) {
      case 1:
         return dice(4, 19) + pow(power, exponent);
      case 2:
         return dice(5, 16) + pow(power, exponent);
      case 3:
         return dice(4, 24) + pow(power, exponent);
      case 4:
         return dice(6, 20) + pow(power, exponent);
      case 5:
         return dice(8, 25) + pow(power, exponent);
      case 6:
         return dice(10, 24) + pow(power, exponent);
      case 7:
         return dice(15, 17) + pow(power, exponent);
      case 8:
         return dice(15, 18) + pow(power, exponent);
      default:
         /* Circle 9 */
         return dice(10, 35) + pow(power, exponent);
   }
}


/*
 * Every spell that does damage comes through here.  This calculates the
 * amount of damage, adds in any modifiers, determines what the saves are,
 * tests for save and calls damage().
 *
 * Return value: CAST_RESULT_ flags
 */

int mag_damage(int skill, struct char_data * ch, struct char_data * victim,
                int spellnum, int savetype)
{
  EVENTFUNC(battle_paralysis_handler);
  int dam = 0;
  int temp = 0;
  double dmod;
  int reduction = FALSE;
  int sus;
  int damage_spellnum = spellnum;

  if (victim == NULL || ch == NULL)
    return 0;

  sus = susceptibility(victim, skills[spellnum].damage_type);

  /* spell damage is now online, and is stored in array "spell_dam_info",
   *******The defines are as such*******:
   *  #define SD_SPELL(i) spell_dam_info[i].spell
   *  #define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
   *  #define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
   *  #define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
   *  #define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
   *  #define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
   *  #define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
   *  #define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
   *  #define SD_BONUS(i) spell_dam_info[i].max_bonus
   *  #define SD_NPC_STATIC...
   *  #define SD_PC_STATIC...
   *
   ****General****
   *  - If SD_INTERN_DAM(i) = FALSE then it will look for a internal switch
   *  - Otherwise it will go through a loop using the values in the array spell_dam_info
   *  - If you wish to have Differeng class Affects simply add a class and put in its factor
   **results**
   *  pc vs pc - SD_PC_NO_DICE * SD_PC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/4)
   *  pc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
   *  npc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
   *  npc vs pc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
   *  all npc vs x is also npc * SD_NPC_REDUCE_FACTOR
   *  Add Statics onto value
   * Proky
   */

  /* mag_damage spells have their own messages associated with the completion of the spell
     in the messages file in lib
  */

  if (SD_INTERN_DAM(spellnum)) {
    if ((!IS_NPC(ch) && !IS_NPC(victim)) ||
        EFF_FLAGGED(ch, EFF_CHARM)) {
      /* PC vs PC */
      dam = dice(SD_PC_NO_DICE(spellnum), SD_PC_NO_FACE(spellnum)) + SD_PC_STATIC(spellnum);

      if (SD_USE_BONUS(spellnum))
        dam += MIN(SD_BONUS(spellnum), skill / 4);
      else
        dam += MIN(SD_BONUS(spellnum), skill * SD_LVL_MULT(spellnum));
    } else {
      /* Not PC vs PC */
      dam = dice(SD_NPC_NO_DICE(spellnum), SD_NPC_NO_FACE(spellnum)) + SD_NPC_STATIC(spellnum);

      if (SD_USE_BONUS(spellnum))
        dam += MIN(SD_BONUS(spellnum), skill / 2);
      else
        dam += MIN(SD_BONUS(spellnum), skill * SD_LVL_MULT(spellnum));

      if (IS_NPC(ch))
        /* Reduce NPC damage */
        dam = (SD_NPC_REDUCE_FACTOR(spellnum) * dam) /100;
    }
  }

  /* Spells can pull dam from the online damage table and manipulate it to include the spell
     proficiency system.  Most damage spells will increase parabolicly as skill increases so
     that the base damage will seem to be the spells norm thoughout much of the skill range.
     If the caster eventually crosses a certain threshold of the skill then the damage seems to
     increase exponentially.  The algorythms are manipulated in such a way that at a 1000 skill
     the spell never does more than (Y) amount of damage. RSD 3/28/00 */


  switch (spellnum) {
     /* Single-target sorcerer spells */

     /* Note that these single-target sorcerer spells are well-balanced.
      * They are calibrated to warrior damage - see sorcerer_single_target().
      * Their damage must also be reduced for lower-level mobs.
      * The low-level missile spells are also balanced, even though they
      * don't use sorcerer_single target (magic missile, fire darts, ice darts).
      *
      * The remainder of the spells here need to be analyzed. */
     case SPELL_DECAY:
     case SPELL_BURNING_HANDS:
     case SPELL_DETONATION:
     case SPELL_CHILL_TOUCH:
     case SPELL_SHOCKING_GRASP:
     case SPELL_LIGHTNING_BOLT:
     case SPELL_NIGHTMARE:
     case SPELL_CONE_OF_COLD:
     case SPELL_POSITIVE_FIELD:
     case SPELL_FIREBALL:
     case SPELL_BIGBYS_CLENCHED_FIST:
     case SPELL_IRON_MAIDEN:
     case SPELL_FREEZE:
     case SPELL_ACID_BURST:
     case SPELL_DISINTEGRATE:
     case SPELL_ICEBALL:
        dam = sorcerer_single_target(ch, spellnum, skill);
        reduction = TRUE;
        break;
     case SPELL_MELT:
        /* Increased damage against metal, stone, and ice */
        dam = sorcerer_single_target(ch, spellnum, skill);
        switch (GET_COMPOSITION(ch)) {
        case COMP_METAL: case COMP_STONE: case COMP_ICE:
          dam *= 2;
          break;
        }
        reduction = TRUE;
        break;
     case SPELL_DISPEL_MAGIC:
        /* We don't want to hear about folks being immune to dispel magic,
         * because the spell might have been cast to remove spells from them.
         * So get out of here if the victim is immune. */
        if (sus == 0) return 0;
        dam = sorcerer_single_target(ch, spellnum, skill);
        reduction = TRUE;
        break;
     case SPELL_DISCORPORATE:
        if (MOB_FLAGGED(victim, MOB_ILLUSORY))
           /* Discorporate just annihilates illusory mobs */
           dam = 100 + GET_HIT(victim);
        else
           dam = sorcerer_single_target(ch, spellnum, skill) / 5;
        break;
     case SPELL_IMMOLATE:
        /* Immolate hits 5 times. */
        dam = sorcerer_single_target(ch, spellnum, skill) / 4;
        reduction = TRUE;
        break;
     case SPELL_PHOSPHORIC_EMBERS:
        /* hits 4 times. */
        dam = sorcerer_single_target(ch, spellnum, skill) / 3;
        reduction = TRUE;
        break;
     case SPELL_PYRE:
        /* hits 4 times, but charmies do half damage */
        dam = sorcerer_single_target(ch, spellnum, skill) / 3;
        if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
           dam *= 2;
        reduction = TRUE;
        break;
     case SPELL_PYRE_RECOIL:
        dam = sorcerer_single_target(ch, SPELL_PYRE, skill) / 6;
        /* use the SPELL_ON_FIRE damage message */
        damage_spellnum = SPELL_ON_FIRE;
        reduction = TRUE;
        break;
     case SPELL_FRACTURE:
        dam = sorcerer_single_target(ch, spellnum, skill) / 3;
        if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
          dam *= 2;
        break;
     case SPELL_FRACTURE_SHRAPNEL:
        dam = sorcerer_single_target(ch, SPELL_FRACTURE, skill) / 2;
        if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
          dam *= 2;
        break;

  case SPELL_MAGIC_MISSILE:
  case SPELL_ICE_DARTS:
    dam = dice(4, 21);
    reduction = TRUE;
    break;
  case SPELL_FIRE_DARTS:
    dam = dice(5, 18);
    reduction = TRUE;
    break;
  case SPELL_CAUSE_LIGHT:
    /* max dam 50 from max 4d4+2 online */
    dam += (pow(skill, 2) * 2) / 625;
    break;
  case SPELL_CAUSE_SERIOUS:
    /* max dam 80 from max 6d5+5 online */
    dam += (pow(skill, 2) * 9) / 2000;
    break;
  case SPELL_CAUSE_CRITIC:
    /* max dam 110 from max 8d6+9 online */
    dam += (pow(skill, 2) * 53) / 10000;
    break;
  case SPELL_HARM:
    /* max dam 170 from max 9d8+16 online */
    dam += (pow(skill, 2) * 41) / 5000;
    break;
  case SPELL_FULL_HARM:
    /* max dam 400 from max 18d10+20 online */
    dam += (pow(skill, 2) * 1) / 50;
    break;
  case SPELL_HELL_BOLT:
    /* max dam 110 from max 8d6+9 online, except alignment bonus! */
    dam += (pow(skill, 2) * 53) / 10000;
    dam *= GET_ALIGNMENT(victim) * 0.0007 + 0.8;
    break;
  case SPELL_DIVINE_BOLT:
    /* max dam 110 from max 8d6+9 online, except alignment bonus! */
    dam += (pow(skill, 2) * 53) / 10000;
    dam *= GET_ALIGNMENT(victim) * -0.0007 + 0.8;
    break;
  case SPELL_WRITHING_WEEDS:
    /* max dam 110 from max 8d6+9 online */
    dam += (pow(skill, 2) * 53) / 10000;
    break;
  case SPELL_FLAMESTRIKE:
    /* max dam 80 for neutral from max 8d9+8 online */
    if (IS_EVIL(ch)) {
      send_to_char("You are not holy enough to cast that spell!\r\n", ch);
      return 0;
    }
    dam *= (GET_ALIGNMENT(ch) * 0.0007) + 0.8;
    break;
  case SPELL_DISPEL_EVIL:
    if (IS_GOOD(victim)) {
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
      act("You leer at $n as $e attempts to dispel your evilness.",
          FALSE, ch, 0, victim, TO_VICT);
      act("$n tries to make the evil in Saint $N suffer.",
          TRUE, victim, 0, ch, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    else if (IS_NEUTRAL(victim)) {
      act("Yeah, right there fancy pants.  $U$N doesn't seem to care.",
          FALSE, ch, 0, victim, TO_CHAR);
      act("You don't seem to care that $N is attempting to dispel your evilness.",
          FALSE, ch, 0, victim, TO_VICT);
      act("$N doesn't care that $n is trying to make $S evilness suffer.",
          TRUE, victim, 0, ch, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    /* max dam 135 from max 10d5+15 online */
    dam += (pow(skill, 2) * 7) / 1000;
    if (GET_CLASS(ch) == CLASS_PRIEST) {
      if (GET_ALIGNMENT(ch) >= 750)
        dam *= 1.25;
      else
        dam *= 1.15;
    }
    else if (GET_ALIGNMENT(ch) >= 750)
      dam *= 1.1;
    break;
  case SPELL_DISPEL_GOOD:
    if (IS_EVIL(victim)) {
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
      act("You leer at $n as $e attempts to dispel your goodness.",
          FALSE, ch, 0, victim, TO_VICT);
      act("$N leers at $n as $e tries to rot $S goodness.",
          TRUE, victim, 0, ch, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    else if (IS_NEUTRAL(victim)) {
      act("Yeah, right there fancy pants.  $U$N doesn't seem to care.",
          FALSE, ch, 0, victim, TO_CHAR);
      act("You don't seem to care that $N is attempting to dispel your goodness.",
          FALSE, ch, 0, victim, TO_VICT);
      act("$N doesn't care that $n is trying to make $S goodness suffer.",
          TRUE, victim, 0, ch, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    /* max dam 135 from max 10d5+15 online */
    dam += (pow(skill, 2) * 7) / 1000;
    if (GET_CLASS(ch) == CLASS_DIABOLIST) {
      if (GET_ALIGNMENT(ch) <= -750)
        dam *= 1.25;
      else
        dam *= 1.15;
    }
    else if (GET_ALIGNMENT(ch) <= -750)
      dam *= 1.1;
    break;
  case SPELL_EARTHQUAKE:
    if (!QUAKABLE(CH_NROOM(victim)))
       return CAST_RESULT_CHARGE;
    /* max dam 125 from max 8d7+12 online */
    dam += (pow(skill, 2) * 13) / 2500;
    dam = sectors[CH_SECT(victim)].qdam_mod * dam / 100;
    temp = sectors[CH_SECT(victim)].fall_mod; /* Modifier for likelihood to be knocked down */
    if (GET_POS(victim) == POS_FLYING) {
      act("$N doesn't care that you are making the ground shake.",
          TRUE, ch, 0, victim, TO_CHAR);
      act("You don't seem to care that $n is attempting to knock you to the ground.",
          TRUE, ch, 0, victim, TO_VICT);
      act("$N doesn't seem to care that $n is shaking the ground.",
          TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    /* Do you fall down?  Levitate and high dex prevent it */
    if (!EFF_FLAGGED(victim, EFF_LEVITATE) &&
          number(1, 100) >= GET_DEX (victim) - temp) {
      GET_POS(victim) = POS_SITTING;
      GET_STANCE(victim) = STANCE_ALERT;
    }
    else {
      act("$N doesn't care that you are making the ground shake.",
          TRUE, ch, 0, victim, TO_CHAR);
      act("$n is unable to knock you to the ground.",
          TRUE, ch, 0, victim, TO_VICT);
      act("$N manages to keep $S footing.",
          TRUE, ch, 0, victim, TO_NOTVICT);
    }
    /* Levitate - cuts damage in half */
    if (EFF_FLAGGED(victim, EFF_LEVITATE))
       dam /= 2;
    break;
  case SPELL_COLOR_SPRAY:
    /* max dam 190 from 15d5+45 online */
    dam += (pow(skill, 2) * 1) / 200;
    break;
  case SPELL_FREEZING_WIND:
    /* As Freezing wind is an area effect spell it's initial base damage will be low and slow
       to increase like the other, however it's top will be low due to the existance of other
       ice based area effect spells. This spell will need some affect associated with it so it
       will be unique and worth casting instead of the other more poweful spells. RSD 4/2/00
       max dam 145 from 15d5+5 online */
    dam += (pow(skill, 2) * 3) / 500;
    break;
  case SPELL_DESTROY_UNDEAD:
    if (GET_LIFEFORCE(victim) != LIFE_UNDEAD) {
      act("$N has far too much life for you to harm it!",
          FALSE, ch, 0, victim, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }
    /* max dam 400 from 18d5+40 online */
    dam += (pow(skill, 2) * 27) / 1000;
    if (GET_CLASS(ch) == CLASS_PRIEST)
      dam *= 1.25;
    break;
  case SPELL_ICE_STORM:
    /* max dam 235 from 20d5+35 online */
    dam += (pow(skill, 2) * 1) / 100;
    if (GET_CLASS(ch) == CLASS_CRYOMANCER)
      dam *= 1.25;
    break;
  case SPELL_FIRESTORM:
    /* Mirror spell of ice storm */
    /* max dam 235 from 20d5+35 online */
    dam += (pow(skill, 2) * 1) / 100;
    if (GET_CLASS(ch) == CLASS_PYROMANCER)
      dam *= 1.25;
    break;
  case SPELL_UNHOLY_WORD:
    /* max dam 300 from 20d5+35 online */
    dam += (pow(skill, 2) * 33) / 2000;
    if (GET_CLASS(ch) == CLASS_DIABOLIST || GET_CLASS(ch) == CLASS_ANTI_PALADIN)
      dam *= 1.25;
    break;
  case SPELL_HOLY_WORD:
    /* max dam 300 from 20d5+35 online */
    dam += (pow(skill, 2) * 33) / 2000;
    if (GET_CLASS(ch) == CLASS_PRIEST || GET_CLASS(ch) == CLASS_PALADIN)
      dam *= 1.25;
    break;
  case SPELL_STYGIAN_ERUPTION:
    if (GET_ALIGNMENT(ch) >= -400) {
      send_to_char("You are not unholy enough to cast that spell!\r\n",ch);
      return CAST_RESULT_CHARGE;
    }
    /* max dam 176 from 12d5+36 online */
    dam += (pow(skill, 2) * 1) / 125;
    dam *= (GET_ALIGNMENT(ch) * -0.0022) - 0.7;
    break;
  case SPELL_DIVINE_RAY:
    /* This spell appears to be the goodie version of stygian eruption */
    /* max dam 176 from 12d5+36 online */
    dam += (pow(skill, 2) * 1) / 125;
    dam *= (GET_ALIGNMENT(ch) * 0.0022) - 0.7;
    break;
  case SPELL_LESSER_EXORCISM:
    if (GET_RACE(victim) != RACE_DEMON) {
      send_to_char("That spell only has effect on demonic creatures.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    if (GET_ALIGNMENT(ch) >= 990 && skill - GET_LEVEL(victim) > 30 &&
        !mag_savingthrow(victim, SAVING_SPELL) && number(1, 100) > 50) {
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",
          FALSE, ch, 0, victim, TO_CHAR);
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",
          FALSE, ch, 0, victim, TO_ROOM);
      if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) { /* illusions don't really banish */
        event_create(EVENT_EXTRACT, extract_event,
             victim, FALSE, &(victim->events), 0);
        GET_HIT(victim) = -50;
        GET_POS(victim) = POS_PRONE;
        GET_STANCE(victim) = STANCE_DEAD;
      }
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    if (GET_ALIGNMENT(ch) <= 400) {
      send_to_char("You are not holy enough to cast that spell!\r\n",ch);
      return CAST_RESULT_CHARGE;
    }
    /* This spell is meant to cause great concern to demonic forces so it'll be quite stout */
    /* max dam 700 from 50d5+50 online */
    dam += (pow(skill, 2) * 1) / 25;
    dam *= (GET_ALIGNMENT(ch) * 0.001) + 0.2;
    /* thought it was to good? Muahahaha!
       Now you lose some HP and MV for selling your soul to hurt the demons! */
    GET_HIT(ch) -= dam / 15;
    if (GET_MOVE(ch) > 25)
      GET_MOVE(ch) = MAX(20, GET_MOVE(ch) - (dam / 50));
    act("$n looks slightly diminished.", FALSE, ch, 0, 0, TO_ROOM);
    act("You lose some life in libation of your holy allegiance!",
        FALSE, ch, 0, 0, TO_CHAR);
    break;
  case SPELL_CALL_LIGHTNING:
    /* There needs to be some code referencing weather to make this spell
       only work when the weather is bad.  If this happens when we can jack
       the damage of the spell since it will be significantly more rare when
       it can be cast. RSD 4/4/00 */
    /* max dam 300 from 15d5+50 online */
    dam += (pow(skill, 2) * 7) / 400;
    break;
  case SPELL_SUNRAY:
    dam += (pow(skill, 2) * 7) / 400;
    break;
  case SPELL_HELLFIRE_BRIMSTONE:
    /* looks like area version of stygian eruption */
    if (GET_ALIGNMENT(ch) >= -400) {
      send_to_char("You are not unholy enough to cast that spell!\r\n",ch);
      return CAST_RESULT_CHARGE;
    }
    /* max dam 300 from 30d5+25 online */
    dam += (pow(skill, 2) * 1) / 180;
    dam *= (GET_ALIGNMENT(ch) * -0.0022) - 0.7;
    break;
  case SPELL_CHAIN_LIGHTNING:
    /* max dam 226 from 12d5+26 online */
    dam += (pow(skill, 2) * 7) / 500;
    break;
  case SPELL_EXORCISM:
    if (GET_RACE(victim) != RACE_DEMON) {
      send_to_char("That spell only has effect on demonic creatures.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    if (GET_ALIGNMENT(ch) >= 990 && skill - GET_LEVEL(victim) > 30 &&
        !mag_savingthrow(victim, SAVING_SPELL) && number(1, 100) > 50) {
      act("$N &7&blets out a massive &1howl&7 as $E is banished by $n's&7&b command.&0",
          FALSE, ch, 0, victim, TO_ROOM);
      act("$N &7&blets out a massive &1howl&7 as $E is banished by your holy might.&0",
          FALSE, ch, 0, victim, TO_CHAR);
      if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) { /* illusions don't really banish */
        event_create(EVENT_EXTRACT, extract_event,
             victim, FALSE, &(victim->events), 0);
        GET_HIT(victim) = -50;
        GET_POS(victim) = POS_PRONE;
        GET_STANCE(victim) = STANCE_DEAD;
      }
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    if (GET_ALIGNMENT(ch) <= 400) {
      send_to_char("You are not holy enough to cast that spell!\r\n",ch);
      return CAST_RESULT_CHARGE;
    }
    /* This spell is meant to cause great concern to demonic forces so it'll be quite stout */
    /* max dam 1200 from 50d10+50 online */
    dam = (pow(skill, 2) * 13) / 20;
    dam *= (GET_ALIGNMENT(ch) * 0.001) + 0.2;
    /* thought it was to good? Muahahaha!
       Now you lose some HP and MV for selling your soul to hurt the demons! */
    GET_HIT(ch) -= dam / 50;
    if (GET_MOVE(ch) > 45)
      GET_MOVE(ch) = MAX(45, GET_MOVE(ch) - (dam / 10));
    act("You lose some life in libation of your holy allegiance!",
        FALSE, ch, 0, victim, TO_CHAR);
    act("$n looks slightly diminished.", FALSE, ch, 0, victim, TO_ROOM);
    break;
  case SPELL_METEORSWARM:
    /* max dam 1200 from 50d10+50 online */
    dam += (pow(skill, 2) * 13) / 200;
    break;
  case SPELL_FLOOD:
    /* max dam 1200 from 50d10+50 online */
    dam += (pow(skill, 2) * 13) / 200;
    break;
  case SPELL_SUPERNOVA:
    /* max dam 2500 from 100d10+500 online */
    dam += (pow(skill, 2) * 1) / 10;
    break;
  case SPELL_ICE_SHARDS:
    /* max dam 2500 from 100d10+500 online */
    dam += (pow(skill, 2) * 1) / 10;
    break;
  case SPELL_SEVERANCE:
    dam += (pow(skill, 2) * 13) / 200;
    break;
  case SPELL_SOUL_REAVER:
    dam += (pow(skill, 2) * 13) / 199;
    break;
  case SPELL_VAMPIRIC_BREATH:
    dam += dice(2, skill + 10);
    if (skill >= 95)
      dam += number(0, 70);
    GET_HIT(ch) += dam;
    break;
  case SPELL_LIGHTNING_BREATH:
  case SPELL_FIRE_BREATH:
  case SPELL_FROST_BREATH:
  case SPELL_GAS_BREATH:
  case SPELL_ACID_BREATH:
    dam = skill + number(1, skill * 2);
    break;
  case SPELL_CIRCLE_OF_FIRE:
    dam = (skill / 2) + dice(2, 3);
    break;
  case SPELL_DEGENERATION:
    dam += dice(3, 40) + 300;
    break;
  case SPELL_MOONBEAM:
    dam += skill * 2 + number(20, 80);
    break;
  case SKILL_ELECTRIFY:
    dam = skill - number(0, 3);
    break;

  } /* <--- end mag_damage switch */

  /* For the balanced sorcerer spells, reduce damage from low-level NPCs. */
  if (reduction && IS_NPC(ch)) {
    dmod = 0.3 + pow((skill / 100.0), 2) * 0.7, 1;
    if (dmod < 0.3) dmod = 0.3;
    if (dmod > 1) dmod = 1;
    dam *= dmod;
    if (dam < 1) dam = 1;
  }

  victim = check_guard(ch, victim, FALSE);

  if (!attack_ok(ch, victim, TRUE))
    return CAST_RESULT_CHARGE;

  /* divide damage by two if victim makes his saving throw */
  if (mag_savingthrow(victim, savetype))
    dam >>= 1;

  /* if HARNESS spell is active, do extra 1% per lvl of foe */
  if (EFF_FLAGGED(ch, EFF_HARNESS)) {
    dam += (dam * GET_LEVEL(victim)) / 100;
    act("&5&b$n&5&b executes $s spell with amazing force...&0",
          FALSE, ch, 0, 0, TO_ROOM);
    act("&5&bYou execute your spell with amazing force...&0",
          FALSE, ch, 0, 0, TO_CHAR);
    effect_from_char(ch, SPELL_HARNESS);
  }

  /* Adjust the damage according to the susceptibility */
  dam = dam * sus / 100;

   if (sus > 119) {
      /* Cry out if you're highly vulnerable */
      if (number(1, 4) == 1)
         act("$n cries out in pain!",
               TRUE, victim, 0, 0, TO_ROOM);
   } else if (sus > 104) {
      /* Express pain if you're very vulnerable */
      if (number(1, 4) == 1)
         act("$n cringes with a pained look on $s face.",
               TRUE, victim, 0, 0, TO_ROOM);
   }

  /* and finally, inflict the damage */
  damage(ch, victim, dam, damage_spellnum);

  if (ALIVE(victim) && EFF_FLAGGED(victim, EFF_IMMOBILIZED) &&
      IS_SET(skills[spellnum].targets, TAR_DIRECT | TAR_CONTACT))
    decrease_modifier(victim, SPELL_BONE_DRAW);

  if (ALIVE(victim) && dam > 0 && GET_LEVEL(victim) < LVL_IMMORT
        && !MOB_FLAGGED(ch, MOB_ILLUSORY)) {

     /* Secondary effects: catch on fire, or freeze up. */

    /* If not protected from fire, chance to catch on fire. */
    if (skills[spellnum].damage_type == DAM_FIRE &&
          susceptibility(victim, DAM_FIRE) > 60 &&
          !EFF_FLAGGED(victim, EFF_ON_FIRE)) {
      temp = MAX(1, MIN(90, (3 + skill - GET_LEVEL(victim)) * susceptibility(victim, DAM_FIRE) / 100));
      if (temp > number(0, 100)) {
        SET_FLAG(EFF_FLAGS(victim), EFF_ON_FIRE);
        switch (number(1, 3)) {
          case 1:
            act("&1&8$n bursts into flame!&0", FALSE, victim, 0, 0, TO_ROOM);
            send_to_char("&1&8Your skin and clothes ignite into flame!&0\r\n", victim);
            break;
          case 2:
            sprintf(buf, "%s light%s", skills[spellnum].name,
               skills[spellnum].name[strlen(skills[spellnum].name) - 1] == 's' ? "" : "s");
            act("&1&8$n's $t you on fire!&0", FALSE, ch, (void*) buf, victim, TO_VICT);
            act("&1&8$n's $t $N on fire!&0", FALSE, ch, (void*) buf, victim,
                  TO_NOTVICT | TO_VICTROOM);
            act("&1&8Your $t $N on fire!&0", FALSE, ch, (void*) buf, victim, TO_CHAR);
            break;
          case 3:
            send_to_char("&1&8Flames spread across your body!&0\r\n", victim);
            act("&1&8Flames envelope $n!&0", FALSE, victim, 0, 0, TO_ROOM);
            break;
        }
      }
    }
    /* If not protected from cold, chance to freeze up. */
    if (skills[spellnum].damage_type == DAM_COLD &&
          !EFF_FLAGGED(victim, EFF_MINOR_PARALYSIS)) {
       /* The following calculation gives you about a 20/500 chance
        * of freezing a level 100 mob with your best cold spell. */
      temp = skill + skills[spellnum].min_level[(int) GET_CLASS(ch)];
      temp = temp * susceptibility(victim, DAM_COLD) / 100;
      temp = temp - 2 * GET_LEVEL(victim) + 20;
      if (temp > number(0, 500)) {
        WAIT_STATE(victim, MAX(3, PULSE_VIOLENCE * (skill - GET_LEVEL(victim)) / 20));
        act("&4&b$n&4&b freezes up!&0", TRUE, victim, 0, 0, TO_ROOM);
        send_to_char("&4&bYour joints stiffen as the frost penetrates you!&0\r\n", victim);
        STOP_CASTING(victim);
        event_create(EVENT_BATTLE_PARALYSIS, battle_paralysis_handler,
             mkgenericevent(ch, victim, 0), TRUE, &(victim->events), 0);
      }
    }
  }

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
} /* end mag_damage */


/*
 * Every spell that does an effect comes through here.  This determines
 * the effect, whether it is added or replacement, whether it is legal or
 * not, etc.
 *
 * effect_join(vict, aff, add_dur, avg_dur, add_mod, avg_mod, refresh)
 *
 * I added refresh so that spells can be refreshed before they run out.
 * NOTE: If accum_duration is set to TRUE, it will override refresh.
 *
 * Return value: CAST_RESULT_ flags.
 */

#define MAX_SPELL_EFFECTS 4        /* change if more needed */

int mag_affect(int skill, struct char_data * ch, struct char_data * victim,
                 int spellnum, int savetype, int casttype)
{
  struct effect eff[MAX_SPELL_EFFECTS];
  struct effect *effect = NULL;
  bool accum_effect = FALSE, accum_duration = FALSE, is_innate = FALSE,
    refresh = TRUE;
  char *to_vict = NULL, *to_room = NULL, *to_char = NULL;
  int i;

  if (victim == NULL || ch == NULL)
    return 0;
  if (MOB_FLAGGED(ch, MOB_ILLUSORY) && ch != victim)
     return 0;
  if (!check_fluid_spell_ok(ch, victim, spellnum, FALSE))
     return CAST_RESULT_CHARGE;
  if (ch->casting.misc && *ch->casting.misc)
    half_chop(ch->casting.misc, buf, buf2);

  memset(eff, 0, sizeof(eff));
  for (i = 0; i < MAX_SPELL_EFFECTS; i++)
    eff[i].type = spellnum;

  if (GET_LEVEL(victim) >= LVL_IMMORT && GET_LEVEL(ch) < GET_LEVEL(victim)) {
     act("Your spell is too weak to affect $N.", FALSE, ch, 0, victim, TO_CHAR);
     act("$n's spell has no effect on $N.", TRUE, ch, 0, victim, TO_NOTVICT);
     act("$n's spell has no effect on you.", FALSE, ch, 0, victim, TO_VICT);
     return CAST_RESULT_CHARGE;
  }

  switch (spellnum) {

  case SPELL_BARKSKIN:

    /* Check for other types of armor spells */
    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 7 + (skill / 9); /* max 18 */
    eff[0].duration = 5 + (skill / 10); /* max 15 */

    to_char = "&3$N's&3 skin hardens to bark.&0";
    to_vict = "&3Your skin hardens to bark.&0";
    to_room = "&3$N's&3 skin hardens to bark.&0";
    break;

  case SPELL_CONFUSION:
     /* Check for resistance due to high wis/dex.
      * Up to an additional 10% chance to evade. */
     i = (GET_DEX(victim) + GET_WIS(victim) - 100) / 10;
     if (i > number(1, 100)) {
        act("$n's eyes start to cross, but $e shakes it off.",
              TRUE, victim, 0, 0, TO_ROOM);
        send_to_char("Your eyes start to &5spin off&0 in different directions, but you manage\r\n", ch);
        send_to_char("to bring them back under control.\r\n", ch);
        return CAST_RESULT_CHARGE;
     }
     SET_FLAG(eff[0].flags, EFF_CONFUSION);
     eff[0].duration = 2 + skill / 40;
     to_vict = "&5You suddenly find it difficult to focus upon your foes.&0";
     to_room = "$N can't decide which way to cross $S eyes!";
     break;

  case SPELL_DARK_PRESENCE:

    if (!IS_EVIL(ch) && casttype == CAST_SPELL) {
      send_to_char("In your goodness, the dark gods have forsaken you!\r\n", ch);
      act("Nothing happens.  $U$n looks rather forlorn.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    if (affected_by_spell(victim, SPELL_BLESS)) {
      act("$N is already blessed by some other gods.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    /* Alignment Checks! */
    if (IS_GOOD(victim)) {
      act("You can't protect an evil ally if they are GOOD!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n tries to enrage your inner demon.\r\nSilly isn't $e?", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to enrage $N's inner demon.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_SAVING_SPELL;
    eff[0].modifier = -2 - (skill / 10);
    eff[0].duration = 10 + (skill / 7); /* 10-24 hrs */
    if (skill < 55) {
      to_char = "You summon allegiance from your dark gods to protect $N.";
      to_vict = "&9&bA dark presence fills your mind.&0";
      if (ch == victim)
         to_room = "$n seizes up in pain!\r\n"
            "$n crosses $s arms on $s chest, and is surrounded by a dark presence.";
      else
         to_room = "$n seizes up in pain!\r\n"
            "$n grabs $N, who is surrounded by a dark presence.";
    }
    else {
      eff[1].location = APPLY_DAMROLL;
      eff[1].modifier = 1 + (skill > 95);
      eff[1].duration = eff[0].duration;
      to_char = "You summon allegiance from your dark gods to protect and enrage $N.";
      to_vict = "&9&bA dark presence fills your mind and body!&0";
      if (ch == victim)
         to_room = "$n seizes up in pain!\r"
            "\n$n crosses $s arms on $s chest, and is enraged by a dark presence.";
      else
         to_room = "$n seizes up in pain!\r"
            "\n$n grabs $N, who is enraged by a dark presence.";
    }
    SET_FLAG(eff[2].flags, EFF_HEX);
    eff[2].duration = eff[0].duration;
    break;

  case SPELL_DEMONIC_ASPECT:
  case SPELL_DEMONIC_MUTATION:

    if (affected_by_spell(victim, SPELL_DEMONIC_ASPECT) ||
        affected_by_spell(victim, SPELL_DEMONIC_MUTATION)) {
      send_to_char("You're feeling pretty demonic already.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HIT;
    /* starts at (level / 5) and goes to (level / 1) */
    eff[0].modifier = skill / (1 + ((100 - skill) / 25));
    eff[0].duration = 5 + (skill / 20); /* max 10 */
    eff[1].location = APPLY_STR;
    eff[1].modifier = 5 + (skill / 14); /* max 12 */
    eff[1].duration = eff[0].duration;

    /* Modify hp by alignment */
    eff[0].modifier *= GET_ALIGNMENT(victim) / -1000.0;

    if (spellnum == SPELL_DEMONIC_ASPECT) {
      to_vict = "&1Your body fills with a demonic strength.&0";
      to_room = "&1$n's&1 body &bglows red&0&1 briefly and grows stronger.&0";
    }
    else if (spellnum == SPELL_DEMONIC_MUTATION) {
      eff[0].modifier *= 2.5;
      to_vict = "&1Your body fills with a demonic strength.&0";
      to_room = "&1$n's eyes flash &8red&0&1 as $e suddenly sprouts horns!&0";
    }
    break;

  case SPELL_DEMONSKIN:

    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    /* Alignement Check! */
    if (IS_GOOD(victim)) {
      act("You can't protect an evil ally if they are GOOD!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n tries to wrap you in demonic skin!\r\nSilly isn't $e?", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to wrap $N is a demonic skin of protection.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    else if (GET_ALIGNMENT(victim) > 0) {
      eff[0].location = APPLY_AC;
      eff[0].modifier = 8;
      eff[0].duration = 5;
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
    }
    else {
      eff[0].location = APPLY_AC;
      eff[0].modifier = 10 + (skill / 20);
      eff[0].duration = 10 + (skill / 50);
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
    }
    to_vict = "&1Your skin toughens into a dark red hide.&0";
    to_room = "&1$N's&1 skin toughens into a dark red hide.&0";
    break;

  case SPELL_ELEMENTAL_WARDING:

    if (is_abbrev(buf2, "fire")) {
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
      to_vict = "You are warded from &1fire&0.";
      to_char = "You protect $N from &1fire&0.";
    } else if (is_abbrev(buf2, "cold")) {
      SET_FLAG(eff[0].flags, EFF_PROT_COLD);
      to_vict = "You are warded from the &4cold&0.";
      to_char = "You protect $N from the &4cold&0.";
    } else if (is_abbrev(buf2, "air")) {
      SET_FLAG(eff[0].flags, EFF_PROT_AIR);
      to_vict = "You are warded from &6&bair&0.";
      to_char = "You protect $N from &6&bair&0.";
    } else if (is_abbrev(buf2, "earth")) {
      SET_FLAG(eff[0].flags, EFF_PROT_EARTH);
      to_vict = "You are warded from &3earth&0.";
      to_char = "You protect $N from &3earth&0.";
    } else {
      send_to_char("What element do you want to ward against?\r\n", ch);
      return 0;
    }

    eff[0].duration = 5 + (skill / 14); /* max 12 */
    to_room = "&7&b$N&7&b glows briefly.&0";
    break;

  case SPELL_DISEASE:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (mag_savingthrow(victim, SAVING_SPELL)) {
      act("You resist $n's foul incantation!", FALSE, ch, 0, victim, TO_VICT);
      act("$N holds $S breath avoiding $n's diseased air!", FALSE, ch, 0, victim, TO_NOTVICT);
      act("$N resists your disease!", TRUE, ch, 0, victim, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_CON;
    eff[0].modifier = -10 - (skill / 10);
    eff[0].duration = 5 + (skill / 10);
    SET_FLAG(eff[0].flags, EFF_DISEASE);
    eff[1].location = APPLY_STR;
    eff[1].modifier = eff[0].modifier;
    eff[1].duration = eff[0].duration;
    to_char = "Your diseased air infects $N!";
    to_vict = "&3You choke and gasp on $n's foul air as a sick feeling overtakes you.\r\n"
       "You feel seriously ill!&0";
    to_room = "&3$N&3 chokes and gasps on $n's foul air, $E looks seriously ill!";
    break;

  case SPELL_ENDURANCE:
  case SPELL_LESSER_ENDURANCE:
  case SPELL_GREATER_ENDURANCE:
  case SPELL_VITALITY:
  case SPELL_GREATER_VITALITY:
  case SPELL_DRAGONS_HEALTH:

    if (affected_by_spell(victim, SPELL_LESSER_ENDURANCE) ||
        affected_by_spell(victim, SPELL_ENDURANCE) ||
        affected_by_spell(victim, SPELL_GREATER_ENDURANCE) ||
        affected_by_spell(victim, SPELL_VITALITY) ||
        affected_by_spell(victim, SPELL_GREATER_VITALITY) ||
        affected_by_spell(victim, SPELL_DRAGONS_HEALTH)) {
      send_to_char("Nothing happens!\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HIT;
    eff[0].modifier = get_vitality_hp_gain(ch, spellnum);
    eff[0].duration = get_spell_duration(ch, spellnum);

    to_vict = get_vitality_vict_message(spellnum);
    to_room = "$N looks healthier than before!";
    to_char = "$N looks healthier than before!";
    break;

  case SPELL_WINGS_OF_HEAVEN:

    if (affected_by_spell(victim, SPELL_WINGS_OF_HELL)) {
      send_to_char("You already have something sticking out of your back.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_FLY);
    eff[0].duration = 10 + (skill / 5); /* max 30 */

    to_vict = "&7&bBeautiful bright white wings unfurl behind you as you lift into the air.&0";
    to_room = "&7&bBeautiful bright white wings unfurl from $n's&7&b back, lifting $m into the air.&0";
    if (AWAKE(victim)) {
      GET_STANCE(victim) = STANCE_ALERT;
      GET_POS(victim) = POS_FLYING;
    }
    break;

  case SPELL_ENTANGLE:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    /* A difficult spell to land with success */
    if (mag_savingthrow(victim, SAVING_PARA) ||
        skill - GET_LEVEL(victim) < number(0, 80)) {
      act("&2&bYour crop of ripe vines search in vain for $N.&0", FALSE,
            ch, 0, victim, TO_CHAR);
      act("&2&bA crop of ripe vines snakes along the ground, unable to locate you!&0",
            FALSE, ch, 0, victim, TO_VICT);
      act("&2&bA crop of ripe vines searches in vain for $N.&0",
            TRUE, ch, 0, victim, TO_NOTVICT);
      /* start combat for failure */
      if (!FIGHTING(victim)) {
        attack(victim, ch);
        remember(victim, ch);
      }
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    /* Chance for major para increases with higher skill. */
    if (skill >= 40 && number(0, 100) < 2 + (skill / 14)) {
      SET_FLAG(eff[0].flags, EFF_MAJOR_PARALYSIS);
      eff[0].duration = 2 + (skill > 95);
    }
    else {
      SET_FLAG(eff[0].flags, EFF_MINOR_PARALYSIS);
      eff[0].duration = 2 + (skill / 24);
    }
    to_char = "&2&bYour crop of thick branches and vines burst"
       " from the ground, partially entangling $N!&0";
    to_room = "&2&bA slew of thick branches and vines burst"
       " from the ground, partially entangling $N!&0";
    to_vict = "&2&bA slew of thick branches and vines burst"
       " from the ground, partially entangling you!&0";
    refresh = FALSE;
    break;

  case SPELL_FAMILIARITY:
     SET_FLAG(eff[0].flags, EFF_FAMILIARITY);
     eff[0].duration = skill / 5 + 4;
     to_vict = "&7&bAn aura of comfort and solidarity surrounds you.&0";
     to_room = "You know in your heart that $N is a steady friend, to be depended upon.";
     break;

  case SPELL_GAIAS_CLOAK:

    /* check for exclusion of other armor spells */
    if(check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 15 + (skill / 16); /* max 21 */
    eff[0].duration = 5 + (skill / 14); /* max 12 */

    refresh = FALSE;
    to_room = "&2A cyclone of leaves and sticks twirls around $n&2, guarding $s body.&0";
    to_vict = "&2A cyclone of leaves and sticks twirls around you, guarding your body.&0";
    break;

  case SPELL_GLORY:
     SET_FLAG(eff[0].flags, EFF_GLORY);
     eff[0].duration = 5 + skill / 20;
     eff[1].location = APPLY_CHA;
     eff[1].modifier = 50;
     eff[1].duration = eff[0].duration;
     to_vict = "&7&bYou stand tall in the light, a beacon of greatness.&0";
     to_room = "&7&b$N seems taller in the light, and appears like unto a god.&0";
     break;

  case SPELL_ICE_ARMOR:

    /* check for exclusion of other armor spells */
    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 5 + (skill / 14); /* max 12 */
    eff[0].duration = 5 + (skill / 20); /* max 10 */
    to_vict = "&4Your body is encased in layer of &7&bsolid ice.&0";
    to_room = "&4$n's&4 body is encased in a layer of &7&bsolid ice.&0";
    break;

  case SPELL_INSANITY:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (mag_savingthrow(victim, SAVING_SPELL)) {
      act("$N has too strong a will to drive insane!", FALSE, ch, 0, victim, TO_CHAR);
      act("Your strength of will protects you from an insane suggestion from $n... This time...",
            FALSE, ch, 0, victim, TO_VICT);
      act("$N resists going insane at $n's suggestion.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_INSANITY);
    eff[0].location = APPLY_WIS;
    eff[0].modifier = -50;
    eff[0].duration = 5;
    to_char = "You cause &5$N to snap... A crazed gleam fills $S eyes.&0";
    to_vict = "&5You go out of your &bMIND!&0";
    to_room = "&5$N's&5 psyche snaps... A crazed gleam fills $S eyes.&0";
    break;

  case SPELL_MESMERIZE:
    if (!AWAKE(victim)) {
       act("$n makes colorful illusions before $N's closed eyes.",
             FALSE, ch, 0, victim, TO_ROOM);
       act("$N is in no condition to notice your illusion.", FALSE,
             ch, 0, victim, TO_CHAR);
       return CAST_RESULT_CHARGE;
    }

    if (EFF_FLAGGED(victim, EFF_MESMERIZED)) {
       act("$n tries to get $N's attention, but it's no use.",
             TRUE, ch, 0, victim, TO_ROOM);
       act("$n seems to be trying to show you something, but you're busy.",
             FALSE, ch, 0, victim, TO_VICT);
       act("You weave a fascinating illusion, but $N is not paying attention.",
             FALSE, ch, 0, victim, TO_CHAR);
       return CAST_RESULT_CHARGE;
    }

    if (evades_spell(ch, victim, spellnum, skill))
       return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;

    to_room = "$n &0&5w&4e&5av&4es a &5mesme&4rizing pa&5ttern before &0$N's eyes.\r\n"
        "$U$N appears entranced, as if working out a puzzle of some kind.";
    to_vict = "$n shows you a truly fascinating puzzle.  You simply must work it out.";
    to_char = "You weave a mesmerizing pattern before $N, and $E seems\r\n"
        "to be utterly absorbed by it.";

    SET_FLAG(eff[0].flags, EFF_MESMERIZED);
    eff[0].duration = 2 + skill / 16; /* 2-8 hours */
    if (!IS_NPC(victim))
       eff[0].duration = 2; /* Players: just 2 hours. */
    remember(victim, ch); /* Victim will be angry about this */
    break;

  case SPELL_MIRAGE:

    /* Need a check to make sure no other conflicting armor spells can help as well */
    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 5 + (skill / 16); /* max 11 */
    eff[0].duration = 5 + (skill / 25); /* max 9 */
    to_room = "&1$n's&1 form begins to waver as a wave of heat blurs the air around $m.&0";
    to_vict = "&1Your form begins to waver as a wave of heat blurs the air around you.&0";
    break;

  case SPELL_NEGATE_COLD:

    SET_FLAG(eff[0].flags, EFF_NEGATE_COLD);
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict = "&4&bYour body becomes impervious to the cold!&0";
    to_room = "&4$n&4's is protected by a &3&bwarm&0&4-looking magical field.&0";
    break;

  case SPELL_NEGATE_HEAT:

    SET_FLAG(eff[0].flags, EFF_NEGATE_HEAT);
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict = "&6Your body becomes impervious to all forms of heat!&0";
    to_room = "&6$n&6 is surrounded by a frigid crystalline field.&0";
    break;

  case SPELL_NIGHT_VISION:

    if (affected_by_spell(victim, SPELL_INFRAVISION)) {
      if (ch == victim)
        act("You are already enchanted with enhanced vision.", FALSE, ch, 0, 0, TO_CHAR);
      else
        act("$N is already enchanted with enhanced vision.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, victim, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_ULTRAVISION);
    eff[0].duration = (skill / 21); /* max 4 */
    to_room = "$N's eyes glow a dim neon green.";
    to_vict = "&9&bYour vision sharpens a bit.";
    break;

  case SPELL_SMOKE:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {
      act("&9&b$n&9&b resists your&9&b column of smoke!&0", FALSE, ch, 0, 0, TO_CHAR);
      act("&9&bYou&9&b resist $n's&9&b column of smoke!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&9&b$N&9&b resists $n's&9&b column of smoke!&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    else if (mag_savingthrow(victim, savetype)) {
      eff[0].location = APPLY_HITROLL;
      eff[0].modifier = -1;
      eff[0].duration = 0;
      eff[1].location = APPLY_AC;
      eff[1].modifier = -10;
      eff[1].duration = 0;

      to_char = "You temporarily choke $N with your column of smoke.";
      to_vict = "&9You have been temporarily choked by $n's&9&b column of smoke!&0";
      to_room = "&9&b$N&9&b is slightly choked by $n's&9&b column of smoke!&0";
    }
    else {
      eff[0].location = APPLY_HITROLL;
      eff[0].modifier = -4;
      eff[0].duration = 2;
      SET_FLAG(eff[0].flags, EFF_BLIND);
      eff[1].location = APPLY_AC;
      eff[1].modifier = -40;
      eff[1].duration = 2;
      SET_FLAG(eff[1].flags, EFF_BLIND);

      to_room = "&9&b$N&9&b is blinded by $n's&9&b column of smoke!&0";
      to_vict = "&9You have been blinded by $n's&9&b column of smoke&0";
      to_char = "&9&b$N&9&b is blinded by your column of smoke!&0";
    }
    break;

  case SPELL_VAPORFORM:

    if (GET_COMPOSITION(victim) != COMP_FLESH) {
      send_to_char("Your body cannot sustain this change.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_COMPOSITION;
    eff[0].modifier = COMP_MIST;
    eff[0].duration = 2 + (skill / 25); /* max 6 */
    refresh = FALSE;
    to_vict = "&6&bYour body sublimates into a &7cloud &6of &7vapor&6.&0";
    to_room = "&6&b$N's body dematerializes into a translucent &7cloud &6of &7vapor&6!&0";
    break;

  case SPELL_WATERFORM:

    if (GET_COMPOSITION(victim) != COMP_FLESH) {
      send_to_char("Your body cannot sustain this change.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_COMPOSITION;
    eff[0].modifier = COMP_WATER;
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict="&4&bYour body liquifies.&0";
    to_room="&4&b$N&4&b's body wavers a bit, slowly changing into a &0&4liquid&b state!&0";
    break;

  case SPELL_WINGS_OF_HELL:

    if (affected_by_spell(victim, SPELL_WINGS_OF_HEAVEN)) {
      send_to_char("You already have something sticking out of your back.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_FLY);
    eff[0].duration = 10 + (skill / 5);

    to_vict = "&1&bHuge leathery &9bat-like&1 wings sprout from your back.&0";
    to_room = "&1&bHuge leathery &9bat-like&1 wings sprout out of $n's&1&b back.&0";
    if (AWAKE(victim)) {
      GET_STANCE(victim) = STANCE_ALERT;
      GET_POS(victim) = POS_FLYING;
    }
    break;

    /* --- SORTED --- */

  case SPELL_PRAYER:

    /* I think this may be demonic aspects counter part */
    eff[0].location = APPLY_HIT;
    /* starts at (level / 3) and goes to (level / 1) */
    eff[0].modifier = skill / (1 + ((100 - skill) / 30));
    eff[0].duration = 5 + (skill / 14); /* max 12 */
    eff[1].location = APPLY_SAVING_SPELL;
    eff[1].modifier = -5 - (skill / 14); /* max -12 */
    eff[1].duration = eff[0].duration;

    /* Modify hp by alignment */
    eff[0].modifier *= GET_ALIGNMENT(victim) / 1000.0;

    to_vict = "Your prayer is answered...\r\nYou feel full of life!";
    to_room = "$N perks up, looking full of life.";
    break;

  case SPELL_MAGIC_TORCH:

    SET_FLAG(eff[0].flags, EFF_LIGHT);
    eff[0].duration = 5 + (skill / 2); /* max 55 */
    refresh = FALSE;
    to_vict = "&1A magical flame bursts into focus, lighting the area.&0";
    to_room = "&1A magical flame bursts into focus, lighting the area.&0";
    break;

  case SPELL_CIRCLE_OF_LIGHT:

    SET_FLAG(eff[0].flags, EFF_LIGHT);
    eff[0].duration = 5 + (skill / 2); /* max 55 */
    refresh = FALSE;
    to_vict = "&7&bA bright white circle of light begins hovering about your head.&0";
    to_room = "&7&bA bright white circle of light appears over $N's&7&b head.";
    break;

  case SPELL_HARNESS:

    if (EFF_FLAGGED(victim, EFF_HARNESS)) {
      send_to_char("You have already harnessed your energy!\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_HARNESS);
    eff[0].duration = (skill >= 20); /* max 1 */
    refresh = FALSE;
    to_vict = "&4&bYour veins begin to pulse with energy!&0";
    to_room = "&4&b$N&4&b's veins bulge as a surge of energy rushes into $M!&0";
    break;

  case SPELL_MINOR_GLOBE:

    if (EFF_FLAGGED(victim, EFF_MAJOR_GLOBE)) {
      act("$N's globe of invulnerability resists your spell!", FALSE, ch, 0, victim, TO_CHAR);
      act("Your globe of invulnerability resists $n's spell.", FALSE, ch, 0, victim, TO_VICT);
      act("$n tries to add an additional globe of protection to $N.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_MINOR_GLOBE);
    eff[0].duration = skill / 20; /* max 5 */
    refresh = FALSE;
    to_char = "&1Your shimmering globe wraps around $N&0&1's body.&0";
    to_vict = "&1A shimmering globe wraps around your body.&0";
    to_room = "&1A shimmering globe wraps around $N&0&1's body.&0";
    break;

  case SPELL_MAJOR_GLOBE:

    if (EFF_FLAGGED(victim, EFF_MINOR_GLOBE)) {
      act("$N's minor globe of invulnerability resists your spell!", FALSE, ch, 0, victim, TO_CHAR);
      act("Your minor globe of invulnerability resists $n's spell.", FALSE, ch, 0, victim, TO_VICT);
      act("$n tries to add an additional globe of protection to $N.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_MAJOR_GLOBE);
    eff[0].duration = 4 + (skill / 20); /* max 9 */
    refresh = FALSE;
    to_char = "&1&bYour shimmering globe of force wraps around $N&1&b's body.&0";
    to_vict = "&1&bA shimmering globe of force wraps around your body.&0";
    to_room = "&1&bA shimmering globe of force wraps around $N&1&b's body.&0";
    break;

  case SPELL_COLDSHIELD:

    if (EFF_FLAGGED(ch, EFF_FIRESHIELD)) {
      cprintf(ch, "The shield of fire around %s body negates your spell.\r\n",
              ch == victim ? "your" : HSHR(victim));
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_COLDSHIELD);
    eff[0].duration = skill / 20; /* max 5 */
    refresh = FALSE;
    to_vict = "&4A jagged formation of i&bc&7e sh&4ard&0&4s forms around you.&0";
    to_room = "&4A jagged formation of i&bc&7e sh&4ard&0&4s forms around $N&0&4.&0";
    break;

  case SPELL_FIRESHIELD:

    if (EFF_FLAGGED(ch, EFF_COLDSHIELD)) {
      cprintf(ch, "The shield of ice around %s body negates your spell.\r\n",
              ch == victim ? "your" : HSHR(victim));
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_FIRESHIELD);
    eff[0].duration = skill / 20; /* max 5 */
    refresh = FALSE;
    to_vict = "&1A burning shield of f&bi&3r&7e&0&1 explodes from your body!&0";
    to_room = "&1A burning shield of f&bi&3r&7e&0&1 explodes from $N&0&1's body!&0";
    break;

  case SPELL_MINOR_PARALYSIS:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    /* Make success based on skill and saving throw -myc 17 Feb 2007 */
    if (mag_savingthrow(victim, SAVING_PARA) ||
       skill - GET_LEVEL(victim) < number(0, 70)) {
      act("&7&b$N resists your weak paralysis.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&7&b$n tries to paralize you but fails!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n squints at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);

      /* start combat for failure */
      if (!FIGHTING(victim)) {
        attack(victim, ch);
        remember(victim, ch);
      }

      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    SET_FLAG(eff[0].flags, EFF_MINOR_PARALYSIS);
    eff[0].duration = 2 + (skill / 15); /* max 8 */
    refresh = FALSE;
    to_char = "You paralyze $N! WooHoo!";
    to_vict = "&7&bAll motion in your body grinds to a halt.&0";
    to_room = "&7&bAll motion in $N&7&b's body grinds to a halt.&0";
    break;

  case SPELL_RAY_OF_ENFEEB:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (EFF_FLAGGED(victim, EFF_RAY_OF_ENFEEB)) {
      act("$N is already feeble enough dammit.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n seems to be looking at you funny.", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n squints at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    if (mag_savingthrow(victim, savetype)) {
      act("$N resists your feeble attempt!", FALSE, ch, 0, victim, TO_CHAR);
      act("$n tries to drain your strength, but you resist!", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n squints at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    eff[0].location = APPLY_STR;
    eff[0].duration = 8 + (skill / 20); /* max 13 */
    eff[0].modifier = -15 - (skill / 10); /* max -25 */
    SET_FLAG(eff[0].flags, EFF_RAY_OF_ENFEEB);
    to_vict = "You feel the strength flow out of your body.";
    to_room = "$N turns pale and starts to sag.";
    to_char = "$N turns pale and starts to sag.";
    break;

  case SPELL_LEVITATE:

    SET_FLAG(eff[0].flags, EFF_LEVITATE);
    eff[0].duration = 5 + (skill / 10);
    to_char = "&6$N&0&6 floats up into the air.&0";
    to_vict = "&6You float up into the air.&0";
    to_room = "&6$N&0&6 floats up into the air.&0";
    break;

  case SPELL_CHILL_TOUCH:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (mag_savingthrow(victim, savetype)) {
      act("$N resists your withering effect!", FALSE, ch, 0, victim, TO_CHAR);
      act("You resist $n's withering effects!", FALSE, ch, 0, victim, TO_VICT);
      act("$N resists $n's withering effect!", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    eff[0].location = APPLY_STR;
    eff[0].duration = 3 + (skill / 20); /* max 8 */
    eff[0].modifier = -5 - (skill / 10); /* max -15 */

    to_vict = "You feel your strength wither!";
    to_char = "$N is withered by your cold!";
    to_room = "$N withers slightly from $n's cold!";
    break;

  case SPELL_ARMOR:

    /* check for exclusion of other armor spells */
    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 10 + (skill / 20); /* max 15 */
    eff[0].duration = 10 + (skill / 50); /* max 12 */
    to_vict = "You feel someone protecting you.";
    to_room = "$n calls upon $s gods to protect $N.";
    break;

  case SPELL_SILENCE:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (MOB_FLAGGED(victim, MOB_NOSILENCE)) {
      send_to_char("You seem unable to silence this one.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    if (mag_savingthrow(victim, savetype)) {
      act("$N resists your pitiful attempt to silence $M.", FALSE, ch, 0, victim, TO_CHAR);
      act("&7&b$n tries to silence you but fails!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n squints at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    SET_FLAG(eff[0].flags, EFF_SILENCE);
    eff[0].duration = 2 + (skill / 15); /* max 8 */
    to_char = "You silence $N!";
    to_vict = "&9&bYour throat begins to close, sealing off all chance of communication.&0";
    to_room = "&0$N&7 squeaks as all sound is squelched from $S throat.&0";
    break;

  case SPELL_SOULSHIELD:

    SET_FLAG(eff[0].flags, EFF_SOULSHIELD);
    eff[0].duration = 2 + (skill / 10); /* max 12 */
    refresh = FALSE;

    if (IS_GOOD(victim)) {
      to_vict = "&3&bA bright golden aura surrounds your body!&0";
      to_room = "&3&bA bright golden aura surrounds $N's body!&0";
    }
    else if (IS_EVIL(victim)) {
      to_vict = "&1&bA &0&1dark red&b aura engulfs you!&0";
      to_room = "&1&bA &0&1dark red&b aura engulfs $N's body!&0";
    }
    else {
      act("A brief aura surrounds you, then fades.", FALSE, ch, 0, victim, TO_VICT);
      act("A brief aura surrounds $n, then fades.", TRUE, victim, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }
    break;

  case SPELL_REDUCE:

    if (IS_NPC(victim))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_SIZE;
    eff[0].modifier = -1;
    SET_FLAG(eff[0].flags, EFF_REDUCE);
    eff[0].duration = 1 + (skill / 40);

    eff[1].location = APPLY_CON;
    eff[1].modifier = -10;
    eff[1].duration = eff[0].duration;

    eff[2].location = APPLY_STR;
    eff[2].modifier = -10;
    eff[2].duration = eff[0].duration;

    refresh = TRUE;
    to_vict = "&1&bYour skin starts to itch as you reduce to half your normal size.&0";
    to_room = "&1&b$N's skin ripples as $E shrinks to half $S normal size!&0";
    break;

  case SPELL_ENLARGE:

    if (IS_NPC(victim))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_SIZE;
    eff[0].modifier = 1;
    SET_FLAG(eff[0].flags, EFF_ENLARGE);
    eff[0].duration = 1 + (skill / 40);

    eff[1].location = APPLY_CON;
    eff[1].modifier = 10;
    eff[1].duration = eff[0].duration;

    eff[2].location = APPLY_STR;
    eff[2].modifier = 10;
    eff[2].duration = eff[0].duration;

    refresh = TRUE;
    to_vict = "&9&bYour skin starts to itch as you enlarge to twice your normal size!&0";
    to_room = "&9&b$N's skin ripples as $E enlarges to twice $S normal size!&0";
    break;

  case SPELL_STONE_SKIN:

    /* what the hell does the modifier/location for this spell do? */
    /* It acts as a hit counter; it's decremented by decrease_modifier()
       everytime the victim is hit, and when it reaches 0, stone skin
       "wears off" before the duration is up. */

    eff[0].location = APPLY_NONE;
    eff[0].modifier = 7 + (skill / 16); /* max 13 */
    eff[0].duration = 2;
    SET_FLAG(eff[0].flags, EFF_STONE_SKIN);

    refresh = FALSE;
    to_char = "&9&b$N's skin hardens and turns to stone!&0";
    to_vict = "&9&bYour skin hardens and turns to stone!&0";
    to_room = "&9&b$N's skin hardens and turns to stone!&0";
    break;

  case SPELL_HASTE:

    SET_FLAG(eff[0].flags, EFF_HASTE);
    eff[0].duration = 2 + (skill / 21); /* max 6 */
    to_char = "&1$N starts to move with uncanny speed!&0";
    to_vict = "&1You start to move with uncanny speed!&0";
    to_room = "&1$N starts to move with uncanny speed!&0";
    break;

  case SPELL_BLUR:

    SET_FLAG(eff[0].flags, EFF_BLUR);
    eff[0].duration = 2 + (skill / 21); /* max 6 */
    to_vict = "&7The world seems to slow as you start moving with unnatural speed!&0";
    to_room = "&7$N's image blurs in unnatural speed!&0";
    break;

  case SPELL_BLESS:

    if (!IS_GOOD(ch) && casttype == CAST_SPELL) {
      send_to_char("The gods have forsaken you in your evilness!\r\n", ch);
      act("There is no effect.  $U$n adopts a dejected look.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    if (affected_by_spell(victim, SPELL_DARK_PRESENCE) ||
        affected_by_spell(victim, SPELL_DEMONSKIN) ||
        affected_by_spell(victim, SPELL_DEMONIC_ASPECT) ||
        affected_by_spell(victim, SPELL_DEMONIC_MUTATION) ||
        affected_by_spell(victim, SPELL_WINGS_OF_HELL)) {
      act("$N is already blessed by some dark gods.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    /* Alignment Checks! */
    if (IS_EVIL(victim)) {
      act("You can't bless evil people!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n tries to awaken your inner angel.\r\nSilly isn't $e?", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to awaken $N's inner angel.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = 1 + (skill >= 50);
    eff[0].duration = 10 + (skill / 7); /* 10-24 hrs */
    eff[1].location = APPLY_SAVING_SPELL;
    eff[1].modifier = -2 - (skill / 10);
    eff[1].duration = eff[0].duration;
    SET_FLAG(eff[2].flags, EFF_BLESS);
    eff[2].duration = eff[0].duration;
    to_char = "$N is inspired by your gods.";
    to_vict = "Your inner angel is inspired by $n.\r\nYou feel righteous.";
    to_room = "$N is inspired to do good by $n.";
    break;

  case SPELL_SUNRAY:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (MOB_FLAGGED(victim, MOB_NOBLIND)) {
      send_to_char("You seem unable to blind this creature.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    if (mag_savingthrow(victim, savetype)) {
      act("$N resists your pitiful attempt to blind $M.", FALSE, ch, 0, victim, TO_CHAR);
      act("&7&b$n tries to blind you but fails!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n directs the rays of the sun at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = -4;
    eff[0].duration = 2;
    SET_FLAG(eff[0].flags, EFF_BLIND);

    eff[1].location = APPLY_AC;
    eff[1].modifier = -40;
    eff[1].duration = 2;
    SET_FLAG(eff[1].flags, EFF_BLIND);

    to_char = "&9&bYou have blinded $N with your sunray!&0";
    to_room = "&9&b$N&9&b seems to be blinded!&0";
    to_vict = "&9&bYou have been blinded!&0";
    break;

  case SPELL_BLINDNESS:

    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (MOB_FLAGGED(victim, MOB_NOBLIND)) {
      send_to_char("You seem unable to blind this creature.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    if (mag_savingthrow(victim, savetype)) {
      act("$N resists your pitiful attempt to blind $M.", FALSE, ch, 0, victim, TO_CHAR);
      act("&7&b$n tries to blind you but fails!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n tries to blind $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = -4;
    eff[0].duration = 2;
    SET_FLAG(eff[0].flags, EFF_BLIND);

    eff[1].location = APPLY_AC;
    eff[1].modifier = -40;
    eff[1].duration = 2;
    SET_FLAG(eff[1].flags, EFF_BLIND);

    to_char = "&9&b$N&9&b is blinded by you!&0";
    to_room = "&9&b$N&9&b is blinded by $n!&0";
    to_vict = "&9&bYou have been blinded!&0";
    break;

  case SPELL_CURSE:

    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      act("&7&b$n tries to curse you but fails!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7&b$n squints at $N but nothing happens.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    eff[0].location = APPLY_HITROLL;
    eff[0].duration = 5 + (skill / 14); /* max 12 */
    eff[0].modifier = -1 - (skill / 50); /* max -3 */
    SET_FLAG(eff[0].flags, EFF_CURSE);
    eff[1].location = APPLY_DAMROLL;
    eff[1].duration = eff[0].duration;
    eff[1].modifier = eff[0].modifier;
    accum_effect = TRUE;
    to_char = "You curse $N! Muahahah!";
    to_room = "$N briefly glows red!";
    to_vict = "You feel very uncomfortable.";
    break;

  case SPELL_DETECT_ALIGN:

    SET_FLAG(eff[0].flags, EFF_DETECT_ALIGN);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_char = "$N can determine alignment.";
    to_room = "&7&b$N&7&b glows briefly.&0";
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_DETECT_INVIS:

    SET_FLAG(eff[0].flags, EFF_DETECT_INVIS);
    eff[0].location = APPLY_PERCEPTION;
    eff[0].modifier = 10;
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_DETECT_MAGIC:

    SET_FLAG(eff[0].flags, EFF_DETECT_MAGIC);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_DETECT_POISON:

    SET_FLAG(eff[0].flags, EFF_DETECT_POISON);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_vict = "Your eyes tingle.";
    break;

  case SPELL_INFRAVISION:

    if (affected_by_spell(victim, SPELL_NIGHT_VISION)) {
      if (victim == ch) {
        send_to_char("You are already enchanted with enhanced vision.\r\n", ch);
        act("$n looks a little overprotective.", TRUE, ch, 0, 0, TO_ROOM);
      } else {
        act("$N seems to be able to sort of see enough already.", FALSE, ch, 0, victim, TO_CHAR);
        act("You are already enchanted with enhanced vision.", FALSE, ch, 0, victim, TO_VICT);
        act("$n looks a little overprotective.", TRUE, ch, 0, victim, TO_NOTVICT);
      }
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_INFRAVISION);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_char = "$N's eyes glow red.";
    to_vict = "Your eyes glow red.";
    to_room = "$N's eyes glow red.";
    break;

  case SPELL_INVISIBLE:
  case SPELL_MASS_INVIS:
    eff[0].type = SPELL_INVISIBLE;
    eff[0].modifier = 40;
    eff[0].duration = 9 + (skill / 9); /* max 20 */
    eff[0].location = APPLY_AC;
    SET_FLAG(eff[0].flags, EFF_INVISIBLE);
    to_vict = "You vanish.";
    to_room = "$N slowly fades out of existence.";
    break;

  case SPELL_POISON:
  case SPELL_GAS_BREATH:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (GET_LEVEL(victim) >= LVL_IMMORT || damage_evasion(victim, 0, 0, DAM_POISON)) {
      act("$n is unaffected!", FALSE, victim, 0, 0, TO_ROOM);
      act("You are unaffected!", FALSE, victim, 0, 0, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }
    if (mag_savingthrow(victim, SAVING_PARA)) {
      if (spellnum != SPELL_GAS_BREATH) {
        /* No message is sent for dodging this part of a gas attack
         * because relevant messages have already been sent in the
         * mag_damage portion of the attack. */
        act("You dodge $n's attempt to prick you!", FALSE, ch, 0, victim, TO_VICT);
        act("$N dodges $n's attempt to prick $M.", TRUE, ch, 0, victim, TO_NOTVICT);
      }
      send_to_char(NOEFFECT, ch);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    eff[0].location = APPLY_STR;
    eff[0].modifier = (-2 - (skill / 4) - (skill / 20)) * susceptibility(victim, DAM_POISON) / 100; /* max -32 */
    SET_FLAG(eff[0].flags, EFF_POISON);
    eff[0].duration = 4 + (skill / 10); /* max 14 */
    eff[0].type = SPELL_POISON;
    to_vict = "You feel very sick.";
    to_room = "$N gets violently ill!";
    to_char = "$N gets violently ill!";
    break;

  case SPELL_PROT_FROM_EVIL:

    /* Alignment Check! */
    if (IS_EVIL(victim)) {
      act("You can't protect an ally if they are EVIL!", FALSE, ch, 0, victim, TO_CHAR);
      act("$n tries to protect you from evil!\r\nSilly isn't $e.", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to protect $N from evil.  DUH!", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_PROTECT_EVIL);
    eff[0].duration = 9 + (skill / 9); /* max 20 */
    to_vict = "You feel invulnerable!";
    to_char = "You surround $N with glyphs of holy warding.";
    break;

  case SPELL_SANCTUARY:

    /* reimplemented by RLS back in 2k2.  While no class actually has this
       spell, there are god granted or quest items that do.
     */

    eff[0].duration = 4;
    SET_FLAG(eff[0].flags, EFF_SANCTUARY);
    to_vict = "This spell doesn't exist.  Ask no questions.";
    to_room = "Absolutely nothing happens to $N.";
    break;

  case SPELL_SLEEP:
    if (!sleep_allowed && ((!IS_NPC(ch) &&
        ((!IS_NPC(victim) && ch != victim) ||
         /* victim is shapechanged? */
         (POSSESSED(victim) && GET_LEVEL(POSSESSOR(victim)) < 100))) ||
         /* ch is shapechanged? */
         (POSSESSED(ch) && GET_LEVEL(POSSESSOR(ch)) < 100))) {
      send_to_char("Use the 'nap' command instead!\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    /* Make it based on skill/saving throw -myc 17 Feb 2007 */
    if ((IS_NPC(victim) && MOB_FLAGGED(victim, MOB_NOSLEEP)) ||
        mag_savingthrow(victim, SAVING_PARA) ||
        skill - GET_LEVEL(victim) < number(0, 100)) {
      act("$n can sing all $e wants, you aren't going to sleep.", FALSE, ch, 0, victim, TO_VICT);
      act("$n tries to sing $N to sleep, but to no avail, uh oh.", TRUE, ch, 0, victim, TO_NOTVICT);
      send_to_char(NOEFFECT, ch);
      if (!FIGHTING(victim)) {
        attack(victim, ch);
        if(IS_NPC(victim))
          remember(victim, ch);
      }
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    SET_FLAG(eff[0].flags, EFF_SLEEP);
    eff[0].duration = 9 + (skill / 9); /* max 20 */
    refresh = FALSE;

    if (GET_STANCE(victim) > STANCE_SLEEPING) {
      act("You feel very sleepy...  Zzzz......", FALSE, victim, 0, 0, TO_CHAR);
      act("$n goes to sleep.", TRUE, victim, 0, 0, TO_ROOM);
      GET_STANCE(victim) = STANCE_SLEEPING;
      GET_POS(victim) = POS_PRONE;
    }
    break;

  case SPELL_STRENGTH:

    /* This is rather a hack of the intended nature of how the
       spell should work, but this is better than the way it was
       RSD 3/27/00 */

    eff[0].location = APPLY_STR;
    eff[0].modifier = 2 + (skill / 8); /* max 14 */
    eff[0].duration = 5 + (skill / 14); /* max 12 */
    to_room = "$N looks stronger!";
    to_vict = "You feel stronger!";
    break;

  case SPELL_INN_STRENGTH:
    eff[0].location = APPLY_STR;
    eff[0].duration = (skill >> 1) + 4;
    eff[0].modifier = 1 + (skill / 18); /* max 6 */
    accum_effect = FALSE;
    to_vict = "You feel stronger!";
    /* Innate strength usage shouldn't call for a skill improvement in a spell sphere */
    break;

  case SPELL_SENSE_LIFE:

    SET_FLAG(eff[0].flags, EFF_SENSE_LIFE);
    eff[0].duration = 17 + (skill / 3); /* max 50 */
    to_vict = "Your feel your awareness improve.";
    to_room = "$N seems more aware of $S surroundings.";
    break;

  case SPELL_WATERWALK:

    SET_FLAG(eff[0].flags, EFF_WATERWALK);
    eff[0].duration = 35 + (skill / 4); /* max 60 */
    to_room = "$N sprouts webbing between $S toes!";
    to_vict = "You feel webbing between your toes.";
    break;

  case SPELL_FLY:

    SET_FLAG(eff[0].flags, EFF_FLY);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    if (too_heavy_to_fly(victim)) {
       to_vict = "You feel somewhat lighter.";
       to_char = "$N remains earthbound.";
    } else {
       to_vict = "&7You fly through the air, as free as a bird!&0";
       to_room = "&6&b$N lifts into the air.&0";
       to_char = "&6&b$N lifts into the air.&0";
       if (AWAKE(victim)) {
         GET_POS(victim) = POS_FLYING;
         GET_STANCE(victim) = STANCE_ALERT;
       }
    }
    break;

  case SPELL_FARSEE:

    SET_FLAG(eff[0].flags, EFF_FARSEE);
    eff[0].duration = 5 + (skill / 10); /* max 15 */
    to_vict = "Your sight improves dramatically.";
    to_room = "$N's pupils dilate rapidly for a second.";
    break;

  case SPELL_BONE_ARMOR:

    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 10 + (skill / 6); /* max 25 */
    eff[0].duration = 8 + 2 * (skill / 5); /* max 48 */
    to_char="&3$N's&3 skin hardens into a bone carapace.&0";
    to_vict="&3Your skin hardens into a bone carapace.&0";
    to_room="&3$N's&3 skin hardens to a bone carapace.&0";
    break;

  case SPELL_REBUKE_UNDEAD:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (GET_LIFEFORCE(victim) != LIFE_UNDEAD) {
      act("$n seems confused as to your state of mortality.",
              FALSE, ch, 0, victim, TO_VICT);
      act("$n tries to rebuke $N's buried undead nature.  Must be buried too deep.",
              TRUE, ch, 0, victim, TO_ROOM);
      send_to_char("Your rebuke elicits nothing but a raised eyebrow.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    if (mag_savingthrow(victim, SAVING_SPELL)) {
      act("You stare blankly at $n as $e attempts to rebuke you.",
              FALSE, ch, 0, victim, TO_VICT);
      act("$N looks at $n blankly as $e calls down a spell of condemnation.",
              TRUE, ch, 0, victim, TO_NOTVICT);
      send_to_char("Your rebuke elicits nothing but a blank stare.\r\n", ch);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    eff[0].location = APPLY_STR;
    eff[1].location = APPLY_CON;
    eff[2].location = APPLY_AC;
    eff[0].modifier = eff[1].modifier = - skill / 5; /* Max -20 */
    eff[2].modifier = - skill / 5 * 2; /* Max 40 */
    eff[0].duration = eff[1].duration = eff[2].duration = skill / 10; /* Max 10 */
    to_char = "&5You shout a powerful rebuke at $N, forcing $M to cower in fear!&0";
    to_vict = "&5You catch a glimpse of $n's true power and cower in fear!&0";
    to_room = "&5$N cowers in fear as $n rebukes $M.&0";
    break;

  case SPELL_NATURES_GUIDANCE:
    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = eff[0].duration = (skill / 20) + 1;  /* range (1, 6) */
    /* Self only */
    to_vict = "You feel a higher power guiding your hands.";
    to_room = "$N calls on guidance from a higher power.";
    break;

  case SPELL_NATURES_EMBRACE:
    SET_FLAG(eff[0].flags, EFF_CAMOUFLAGED);
    eff[0].duration = (skill / 3) + 1; /* range (1, 34) */
    to_vict = "&9&8You phase into the landscape.&0";
    to_room = "&9&8$n&9&8 phases into the landscape.&0";
    break;

  case SPELL_MISDIRECTION:
    SET_FLAG(eff[0].flags, EFF_MISDIRECTION);
    eff[0].duration = 2 + skill / 4;
    to_vict = "You feel like a stack of little illusions all pointing in different directions.";
    break;

  case CHANT_REGENERATION:
    eff[0].location = APPLY_HIT_REGEN;
    eff[0].duration = skill / 2 + 3;
    eff[0].modifier = skill / 2 + 10;
    to_vict = "You feel your health improve.";
    to_room = "$n looks a little healthier.";
    break;

  case CHANT_BATTLE_HYMN:
    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = skill / 25 + 1;
    eff[0].duration = skill / 25 + 1;
    eff[1].location = APPLY_DAMROLL;
    eff[1].modifier = skill / 25 + 1;
    eff[1].duration = skill / 25 + 1;
    if (number(0, 1))
      to_vict = "Your heart beats with the rage of your fallen brothers.";
    else
      to_vict = "Your heart beats with the rage of your fallen sisters.";
    to_room = "$n's chest swells with courage!";
    break;

  case CHANT_WAR_CRY:
    eff[0].location = APPLY_HITROLL;
    eff[0].modifier = skill / 25 + 1;
    eff[0].duration = skill / 25 + 1;
    eff[1].location = APPLY_DAMROLL;
    eff[1].modifier = skill / 25 + 1;
    eff[1].duration = skill / 25 + 1;
    to_vict = "You feel more determined than ever!";
    to_room = "$N looks more determined than ever!";
    break;

  case CHANT_SHADOWS_SORROW_SONG:
    /*
     * no attack_ok check, since this is a mag_masses spell, and
     * mag_masses won't pass to mag_affect if it doesn't pass attack_ok
     */

    /* No chance to fail, since chanting already has a built-in failure.
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      send_to_char("&7&bShadows start to creep across your vision, but you resist them.&0", victim);
      act("&7&b$n sings $N a song of depression, but $E ignores it.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    */

    eff[0].location = APPLY_HITROLL;
    eff[0].duration = 5 + (skill / 14); /* max 12 */
    eff[0].modifier = -1 - (skill / 10); /* max -11 */
    accum_effect = TRUE;
    to_char = "You depress $N with a song of darkness and sorrow!";
    to_room = "A dark look clouds $N's visage as $n sings $M a song of sorrow.";
    to_vict = "$n's song of sorrow fills your mind with darkness and shadows.";
    break;

  case CHANT_ARIA_OF_DISSONANCE:

    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].duration = 5 + (skill / 30); /* max 8 */
    eff[0].modifier = - 10 - (skill / 2); /* max -60 */
    to_char = "Your song of dissonance confuses $N!";
    to_room = "$N winces as $n's dissonant song fills $S ears.";
    to_vict = "$n fills your ears with an aria of dissonance, causing confusion!";
    break;

  case CHANT_SONATA_OF_MALAISE:
    /*
     * no attack_ok check, since this is a MAG_MASSES spell, and
     * mag_masses checks attack_ok before calling mag_affect
     */
    eff[0].location = APPLY_SAVING_PARA;
    eff[1].location = APPLY_SAVING_ROD;
    eff[2].location = APPLY_SAVING_PETRI;
    eff[3].location = APPLY_SAVING_BREATH;
    eff[4].location = APPLY_SAVING_SPELL;
    /* same duration */
    eff[0].duration = eff[1].duration = eff[2].duration = eff[3].duration =
    eff[4].duration = 1 + (skill / 20); /* max 6 */
    eff[0].modifier = (skill / 7) + number(0, 6); /* max 20 */
    eff[1].modifier = (skill / 7) + number(0, 6); /* max 20 */
    eff[2].modifier = (skill / 7) + number(0, 6); /* max 20 */
    eff[3].modifier = (skill / 7) + number(0, 6); /* max 20 */
    eff[4].modifier = (skill / 7) + number(0, 6); /* max 20 */
    to_char = "You fill $N with a sense of malaise!";
    to_vict = "Malaise fills the air, hampering your movements!";
    to_room = "$N contorts $S face briefly in anger and fear.";
    break;

  case CHANT_SEED_OF_DESTRUCTION:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    /*
     * The modifier here makes the victim lose a percentage of
     * half their str and con based on the chanter's skill.
     */

    SET_FLAG(eff[0].flags, EFF_DISEASE);
    eff[0].location = APPLY_CON;
    eff[0].modifier = -(skill * GET_VIEWED_CON(victim) / 2) / 100;
    eff[0].duration = (skill / 20); /* max 5 */
    eff[1].location = APPLY_STR;
    eff[1].modifier = -(skill * GET_VIEWED_STR(victim) / 2) / 100;
    eff[1].duration = (skill / 20); /* max 5 */
    to_char = "You force $N down the path to destruction...";
    to_vict = "You feel your time in this world growing short...";
    to_room = "$n plants the seed of destruction in $N's mind.";
    break;

  case CHANT_SPIRIT_WOLF:
    SET_FLAG(eff[0].flags, EFF_SPIRIT_WOLF);
    eff[0].duration = (skill / 20); /* max 5 */
    to_vict = "You feel a wolf-like fury come over you.";
    to_room = "$n seems to take on a fearsome, wolf-like demeanor.";
    break;

  case CHANT_SPIRIT_BEAR:
    SET_FLAG(eff[0].flags, EFF_SPIRIT_BEAR);
    eff[0].duration = (skill / 20); /* max 5 */
    to_vict = "The spirit of the bear consumes your body.";
    to_room = "$n shifts $s weight, seeming heavier and more dangerous.";
    break;

  case CHANT_INTERMINABLE_WRATH:
    SET_FLAG(eff[0].flags, EFF_WRATH);
    eff[0].duration = (skill / 20); /* max 5 */
    to_vict = "A feeling of unforgiving wrath fills you.";
    to_room = "$n bristles with anger.";
    break;

  case SPELL_SPINECHILLER:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (mag_savingthrow(victim, SAVING_PARA) ||
        skill - GET_LEVEL(victim) < number(0, 70)) {
      act("$N resists your neuroparalysis.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n tries to scramble your nerves, but fails!", FALSE, ch, 0, victim, TO_VICT);
      act("$n grabs onto $N and squeezes.", TRUE, ch, 0, victim, TO_ROOM);

      /* start combat for failure */
      if (!FIGHTING(victim)) {
        attack(victim, ch);
        remember(victim, ch);
      }

      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    SET_FLAG(eff[0].flags, EFF_MINOR_PARALYSIS);
    eff[0].duration = 2 + (skill / 15); /* max 8 */
    refresh = FALSE;
    to_char = "You grab $N and scramble $S nerves!";
    to_vict = "Tingles run up and down your spine as $n scrambles your nerves!";
    to_room = "$N gasps for breath as $n scrambles $S nerves!";
    break;

  case SPELL_BONE_DRAW:
    if (EFF_FLAGGED(victim, EFF_IMMOBILIZED)) {
      act("$n is already immobilized!", FALSE, ch, 0, victim, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }

    if (evades_spell(ch, victim, spellnum, skill))
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;

    to_char = "You conjure four magical bones to lock $N in place!";
    to_vict = "$n conjures four magical bones which bind your legs!";
    to_room = "$n conjures four magical bones that lock around $N's legs!";

    SET_FLAG(eff[0].flags, EFF_IMMOBILIZED);
    eff[0].location = APPLY_NONE;
    eff[0].modifier = 4;
    eff[0].duration = 1 + skill / 25; /* 1-5 hours */
    if (!IS_NPC(victim))
      eff[0].duration = 1;
    remember(victim, ch);
    break;

  } /* <--- end of switch of spells */

  /*
   * If this is a mob that has this effect set in its mob file, do not
   * perform the affect.  This prevents people from un-sancting mobs
   * by sancting them and waiting for it to fade, for example.
   */
   if (IS_NPC(victim) && !affected_by_spell(victim, spellnum))
     for (i = 0; i < MAX_SPELL_EFFECTS; ++i)
       if (ANY_FLAGGED(EFF_FLAGS(victim), eff[i].flags, NUM_EFF_FLAGS)) {
         send_to_char(NOEFFECT, ch);
         return CAST_RESULT_CHARGE;
       }

   /*
    * If the victim is already affected by this spell, and the spell does
    * not have a cumulative effect, then fail the spell.
    */
   if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_effect||refresh)) {
     send_to_char(NOEFFECT, ch);
     return CAST_RESULT_CHARGE;
   }

   for (effect = victim->effects; effect && !is_innate; effect = effect->next) {
     if (spellnum == effect->type && effect->duration == -1)
       is_innate = TRUE;
   }

   if (affected_by_spell(victim,spellnum) && is_innate) {
     send_to_char(NOEFFECT, ch);
     return CAST_RESULT_CHARGE;
   }

   /* act() for the message buffers in mag_affect() */

   if (!affected_by_spell(victim,spellnum))
     {
         /* Suppress this message when you are casting the spell on yourself. */
         if (to_char != NULL && ch != victim)
           act(to_char, FALSE, ch, 0, victim, TO_CHAR);
         if (to_vict != NULL)
           act(to_vict, FALSE, ch, 0, victim, TO_VICT);
         if (to_room != NULL) {
           act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
           if (to_char == NULL && ch != victim)
             act(to_room, FALSE, ch, 0, victim, TO_CHAR);
         }
     }

   for (i = 0; i < MAX_SPELL_EFFECTS; i++)
      if (HAS_FLAGS(eff[i].flags, NUM_EFF_FLAGS) || eff[i].location != APPLY_NONE) {
         effect_join(victim, eff + i, accum_duration, FALSE, accum_effect, FALSE, refresh);
         if (CASTING(victim)) {
            if (IS_FLAGGED(eff[i].flags, EFF_SILENCE)) {
               STOP_CASTING(victim);
               act("Your spell collapses.", FALSE, victim, 0, 0, TO_CHAR);
               act("$n continues silently moving $s lips for a moment before giving up.",
                   FALSE, victim, 0, 0, TO_ROOM);
            }
            else if (IS_FLAGGED(eff[i].flags, EFF_MINOR_PARALYSIS) ||
                     IS_FLAGGED(eff[i].flags, EFF_MAJOR_PARALYSIS) ||
                     IS_FLAGGED(eff[i].flags, EFF_MESMERIZED))
               /* Just silently stop the casting for paralysis */
               STOP_CASTING(victim);
         }
         if ((IS_FLAGGED(eff[i].flags, EFF_MINOR_PARALYSIS) ||
             IS_FLAGGED(eff[i].flags, EFF_MAJOR_PARALYSIS) ||
             IS_FLAGGED(eff[i].flags, EFF_MESMERIZED))) {
            if (FIGHTING(victim))
              stop_fighting(victim);
            stop_attackers(victim);
         }
      }
   return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}


/*
 * This function is used to provide services to mag_group.  This function
 * is the one you should change to add new group spells.
 */

void perform_mag_group(int skill, struct char_data * ch,
                        struct char_data * tch, int spellnum, int savetype)
{
  switch (spellnum) {
  case SPELL_GROUP_HEAL:
    mag_point(skill, ch, tch, SPELL_HEAL, savetype);
    mag_unaffect(skill, ch, tch, SPELL_HEAL, savetype);
    break;
  case SPELL_GROUP_ARMOR:
    mag_affect(skill, ch, tch, SPELL_ARMOR, savetype, CAST_SPELL);
    break;
  case SPELL_GROUP_RECALL:
    spell_recall(spellnum, skill, ch, tch, NULL, savetype);
    break;
  case SPELL_DIVINE_ESSENCE:
    mag_affect(skill, ch, tch, SPELL_GREATER_ENDURANCE, savetype, CAST_SPELL);
    mag_affect(skill, ch, tch, SPELL_BLESS, savetype, CAST_SPELL);
    break;
  case SPELL_INVIGORATE:
    mag_point(skill, ch, tch, SPELL_INVIGORATE, savetype);
    break;
  case CHANT_WAR_CRY:
    mag_affect(skill, ch, tch, CHANT_WAR_CRY, savetype, CAST_SPELL);
    break;
  }
}


/*
 * Every spell that affects the group should run through here
 * perform_mag_group contains the switch statement to send us to the right
 * magic.
 *
 * group spells affect everyone grouped with the caster who is in the room,
 * caster last.
 *
 * To add new group spells, you shouldn't have to change anything in
 * mag_groups -- just add a new case to perform_mag_group.
 * You can add a message to the switch in mag_groups though.
 *
 * Return value: CAST_RESULT_ flags
 */

int mag_group(int skill, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *next_tch;
  char *to_room, *to_char;

  if (ch == NULL)
    return 0;

  if (!IS_GROUPED(ch))
    return CAST_RESULT_CHARGE;

  switch (spellnum) {
  case SPELL_DIVINE_ESSENCE:
    to_room = "&3&b$n&3&b invokes $s deity's divine essence to fill the area!&0";
    to_char = "&3&bYou invoke your deity's divine essence!&0\r\n";
    break;
  default:
    to_room = NULL;
    to_char = NULL;
  }
  if (to_room)
    act(to_room, TRUE, ch, 0, 0, TO_ROOM);
  if (to_char)
    send_to_char(to_char, ch);


  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    /* I suppose it's possible a heal could kill someone. */
    next_tch = tch->next_in_room;

    if (tch->in_room != ch->in_room)
     continue;

    if (ch != tch && is_grouped(ch, tch))
      perform_mag_group(skill, ch, tch, spellnum, savetype);
  }

  /* Always hit the caster last for spells like group recall, which
     will otherwise fail if the caster leaves the room partway
     through the spell */
  perform_mag_group(skill, ch, ch, spellnum, savetype);

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}


/*
 * Mass spells affect every creature in the room except the caster.
 * These are often offensive spells.  This calls mag_affect to do the
 * actual affection -- all spells listed here must also have a case in
 * mag_affect() in order for them to work.
 */

int mag_mass(int skill, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *tch_next;
  bool found = FALSE;

  if (ch == NULL)
    return 0;

  if (ch->in_room == NOWHERE)
    return CAST_RESULT_CHARGE;

  for (tch = world[ch->in_room].people; tch; tch = tch_next) {
    tch_next = tch->next_in_room;

    if (SINFO.violent) {
      if (tch == ch)
        continue;
      if (!mass_attack_ok(ch, tch, FALSE))
        continue;
      if (is_grouped(ch, tch))
        continue;
    }

    found = TRUE;
    mag_affect(skill, ch, tch, spellnum, savetype, CAST_SPELL);

    /*
     * If this is a violent spell, and the victim isn't already fighting
     * someone, then make it attack the caster.
     */
    if (SINFO.violent && !FIGHTING(tch))
      set_fighting(tch, ch, FALSE);
  }

  /* No skill improvement if there weren't any valid targets in the room. */
  if (!found)
    return CAST_RESULT_CHARGE;

  return CAST_RESULT_IMPROVE | CAST_RESULT_CHARGE;
}


int mag_bulk_objs(int skill, struct char_data *ch, int spellnum, int savetype)
{
  struct obj_data *tobj, *tobj_next;
  bool found = FALSE;

  if (ch == NULL)
    return 0;

  if (ch->in_room == NOWHERE)
    return CAST_RESULT_CHARGE;

  for (tobj = world[ch->in_room].contents; tobj; tobj = tobj_next) {
    tobj_next = tobj->next_content;

    found = TRUE;
    mag_alter_obj(skill, ch, tobj, spellnum, savetype);
  }

  /* No skill improvement if there weren't any valid targets. */
  if (!found)
    return CAST_RESULT_CHARGE;
  return CAST_RESULT_IMPROVE | CAST_RESULT_CHARGE;
}

/*
 * Every spell that affects an area (room) runs through here.  These are
 * generally offensive spells.  This calls mag_damage to do the actual
 * damage -- all spells listed here must also have a case in mag_damage()
 * in order for them to work.
 *
 *  area spells have limited targets within the room.
 *
 * Return value: CAST_RESULT_ flags
 */

int mag_area(int skill, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *next_tch;
  char *to_char = NULL;
  char *to_room = NULL;
  bool found = FALSE;

  if (ch == NULL)
    return 0;

  if (ch->in_room == NOWHERE)
    return CAST_RESULT_CHARGE;

  /*
   * to add spells to this fn, just add the message here plus an entry
   * in mag_damage for the damaging part of the spell.
   */
  switch (spellnum) {
  case SPELL_CHAIN_LIGHTNING:
    to_char = "&4&bYou send powerful bolts of lightning from your body...&0";
    to_room = "&4&b$n&4&b sends powerful bolts of lightning into $s foes...&0";
    break;
  case SPELL_CREMATE:
    to_char = "&1&8You raise up a huge conflaguration in the area.&0";
    to_room = "&1&8$n summons a huge conflagration burning through the area.&0";
    break;
  case SPELL_EARTHQUAKE:
    switch (SECT(IN_ROOM(ch))) {
      case SECT_SHALLOWS:
      case SECT_WATER:
      case SECT_UNDERWATER:
      case SECT_AIR:
      case SECT_AIRPLANE:
      case SECT_ASTRALPLANE:
      case SECT_AVERNUS:
        act("Quake the earth? What earth? There's no ground here anywhere.", FALSE, ch, 0, 0, TO_CHAR);
        act("$n hunches over and grunts loudly!", TRUE, ch, 0, 0, TO_ROOM);
        return CAST_RESULT_CHARGE;
    }
    to_char = "&3You gesture and the earth begins to shake all around you!&0";
    to_room = "$n&3 gracefully gestures and the earth begins to shake violently!&0";
    send_to_zone("&3The ground &1rumbles&3 and shakes!&0\r\n",
          IN_ZONE_VNUM(ch), IN_ROOM(ch), STANCE_SLEEPING);
    break;
  case SKILL_ELECTRIFY:
    to_char = "&4&8You send out electricity in all directions...&0";
    to_room = "&4&8$n&4&8 sends out electricity in all directions...&0";
    break;
  case SPELL_FIRESTORM:
    to_char = "You conjure a gout of flame to sweep through the area.";
    to_room = "$n waves his hands as a gout of flame floods into the area.";
    break;
  case SPELL_FREEZING_WIND:
    to_char = "&6&bYou release a &0&4chilling&6&b stream of air at your foes.&0";
    to_room = "&6&b$n&6&b releases a &0&4chilling&6&b stream of air.&0";
    break;
  case SPELL_ICE_SHARDS:
    to_char = "&6&bYou conjure thousands of razor sharp ice shards to massacre your foe!&0";
    to_room = "$n &6&bconjures thousands of razor sharp ice shards to massacre $s foe!&0";
    break;
  case SPELL_HELLFIRE_BRIMSTONE:
    to_char = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
    to_room = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
    break;
  case SPELL_HOLY_WORD:
    to_char = "&7&bYou invoke a word of holy power!&0";
    to_room = "&7&b$n &7&butters a word of holy power!&0";
    break;
  case SPELL_ICE_STORM:
    to_char = "&6&bYou crush your foes under a relentless ice storm!&0";
    to_room = "$n&6&b crushes $s foes under a relentless ice storm!&0";
    break;
  case SPELL_INCENDIARY_NEBULA:
    to_char  = "&0&2You cackle as your &bwave of gases&0 &2torches your enemies!&0";
    to_room = "&0$n&2 cackles as his &bwave of gases&0&2 torches his enemies!&0";
    break;
  case SPELL_METEORSWARM:
    to_char = "&1You conjure up a controlled shower of meteors to crush your foes!&0";
    to_room = "$n&1 conjures a controlled shower of flaming meteors!&0";
    break;
  case SPELL_SEVERANCE:
    to_char = "&7You lay a fell glow upon the surroundings, revealing the &bsilver cords&0&7 of all present.&0";
    to_room = "&7$n&0&7 spreads a &6fell glow&7 upon the surroundsings, revealing the &bsilver cords&0 of all present.&0";
    break;
  case SPELL_SOUL_REAVER:
    to_char = "&5You shape an awesome vision of calamity for all...&0";
    to_room = "&5$n&0&5 warps all reality into something deadly sinister...&0";
    break;
  case SPELL_SUPERNOVA:
    to_char = "&1You release a &bconflagration&0&1 of f&3&bi&1r&0&1e, laying waste to all that surrounds you.&0";
    to_room = "&1&b$n&1&b EXPLODES,&0&1 releasing a &bconflagration&0&1 of f&3&bi&1r&0&1e that lays waste to the entire area!&0";
    break;
  case SPELL_UNHOLY_WORD:
    to_char = "&9&bYou invoke a word of unholy power!&0";
    to_room = "&9&b$n &9&butters a word of unholy power!&0";
    break;
  }

  if (to_char != NULL)
    act(to_char, FALSE, ch, 0, 0, TO_CHAR);
  if (to_room != NULL)
    act(to_room, FALSE, ch, 0, 0, TO_ROOM);

  if ((spellnum == SPELL_UNHOLY_WORD && IS_GOOD(ch)) ||
      (spellnum == SPELL_HOLY_WORD && IS_EVIL(ch))) {
    act("&9&bYour word of power is the last thing you hear as your soul is ripped apart!&0", FALSE, ch, 0, 0, TO_CHAR);
    die(ch, ch);
    return CAST_RESULT_CHARGE;
  }

  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;
    /* Standard room attack check */
    if (!area_attack_target(ch, tch))
       continue;
    if (spellnum == SPELL_UNHOLY_WORD && !IS_GOOD(tch))
      continue;
    if (spellnum == SPELL_HOLY_WORD && !IS_EVIL(tch))
      continue;

    found = TRUE;
    mag_damage(skill, ch, tch, spellnum, savetype);
  }
  /* No skill improvement if there weren't any valid targets. */
  if (!found)
    return CAST_RESULT_CHARGE;
  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}


/* a few helpers for mag_summons */

enum undead_type { MOB_ZOMBIE, MOB_SKELETON, MOB_SPECTRE,
                   MOB_WRAITH, MOB_LICH };

/* mod_for_undead_type takes a mob and modifies its stats/skills/etc as
 * as appropriate for an undead of the specified type */
void mod_for_undead_type(struct char_data *mob, enum undead_type type)
{
  if (!mob)
    return;

  GET_LIFEFORCE(mob) = LIFE_UNDEAD;
  GET_ALIGNMENT(mob) = -1000;
  GET_RACE_ALIGN(mob) = RACE_ALIGN_EVIL;
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGRESSIVE);
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGR_EVIL);
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGR_GOOD);
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGR_NEUTRAL);
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGR_EVIL_RACE);
  REMOVE_FLAG(MOB_FLAGS(mob), MOB_AGGR_GOOD_RACE);
  SET_FLAG(MOB_FLAGS(mob), MOB_ANIMATED);

  switch(type) {
  case MOB_ZOMBIE:
    GET_COMPOSITION(mob) = COMP_FLESH;
    GET_CLASS(mob) = CLASS_WARRIOR;
    GET_HITROLL(mob) *= 1.1;
    GET_DAMROLL(mob) *= 1.1;
    GET_MAX_HIT(mob) *= 1.1;
    GET_MAX_MOVE(mob) *= 1.1;
    GET_AC(mob) -= 10;
    GET_NATURAL_STR(mob) *= 1.2;
    GET_NATURAL_INT(mob) *= 0.5;
    GET_NATURAL_WIS(mob) *= 0.75;
    GET_NATURAL_DEX(mob) *= 0.75;
    GET_NATURAL_CON(mob) *= 1.2;
    GET_NATURAL_CHA(mob) *= 0.5;
    break;
  case MOB_SKELETON:
    GET_COMPOSITION(mob) = COMP_BONE;
    GET_CLASS(mob) = CLASS_WARRIOR;
    GET_HITROLL(mob) *= 1.2;
    GET_DAMROLL(mob) *= 1.2;
    GET_MAX_HIT(mob) *= 1.2;
    GET_MAX_MOVE(mob) *= 1.2;
    GET_AC(mob) -= 15;
    GET_NATURAL_STR(mob) *= 1.2;
    GET_NATURAL_INT(mob) *= 0.75;
    GET_NATURAL_WIS(mob) *= 0.9;
    GET_NATURAL_DEX(mob) *= 1.0;
    GET_NATURAL_CON(mob) *= 1.2;
    GET_NATURAL_CHA(mob) *= 0.75;
    break;
  case MOB_SPECTRE:
    GET_COMPOSITION(mob) = COMP_ETHER;
    GET_CLASS(mob) = CLASS_ASSASSIN;
    GET_HITROLL(mob) *= 1.4;
    GET_DAMROLL(mob) *= 1.4;
    GET_MAX_HIT(mob) *= 1.4;
    GET_MAX_MOVE(mob) *= 1.4;
    GET_AC(mob) -= 20;
    GET_NATURAL_STR(mob) *= 1.2;
    GET_NATURAL_INT(mob) *= 1.0;
    GET_NATURAL_WIS(mob) *= 1.0;
    GET_NATURAL_DEX(mob) *= 1.2;
    GET_NATURAL_CON(mob) *= 1.2;
    GET_NATURAL_CHA(mob) *= 1.0;
    break;
  case MOB_WRAITH:
    GET_COMPOSITION(mob) = COMP_ETHER;
    GET_CLASS(mob) = CLASS_SORCERER;
    GET_HITROLL(mob) *= 1.6;
    GET_DAMROLL(mob) *= 1.6;
    GET_MAX_HIT(mob) *= 1.6;
    GET_MAX_MOVE(mob) *= 1.6;
    GET_AC(mob) -= 30;
    GET_NATURAL_STR(mob) *= 1.3;
    GET_NATURAL_INT(mob) *= 1.3;
    GET_NATURAL_WIS(mob) *= 1.3;
    GET_NATURAL_DEX(mob) *= 1.3;
    GET_NATURAL_CON(mob) *= 1.3;
    GET_NATURAL_CHA(mob) *= 1.3;
    break;
  case MOB_LICH:
    GET_COMPOSITION(mob) = COMP_FLESH;
    GET_CLASS(mob) = CLASS_NECROMANCER;
    GET_HITROLL(mob) *= 2;
    GET_DAMROLL(mob) *= 2;
    GET_MAX_HIT(mob) *= 2;
    GET_MAX_MOVE(mob) *= 2;
    GET_AC(mob) -= 50;
    GET_NATURAL_STR(mob) *= 1.5;
    GET_NATURAL_INT(mob) *= 1.5;
    GET_NATURAL_WIS(mob) *= 1.5;
    GET_NATURAL_DEX(mob) *= 1.5;
    GET_NATURAL_CON(mob) *= 1.5;
    GET_NATURAL_CHA(mob) *= 1.5;
    break;
  }
  if (GET_NATURAL_STR(mob) > 100)
    GET_NATURAL_STR(mob) = 100;
  if (GET_NATURAL_INT(mob) > 100)
    GET_NATURAL_INT(mob) = 100;
  if (GET_NATURAL_WIS(mob) > 100)
    GET_NATURAL_WIS(mob) = 100;
  if (GET_NATURAL_DEX(mob) > 100)
    GET_NATURAL_DEX(mob) = 100;
  if (GET_NATURAL_CON(mob) > 100)
    GET_NATURAL_CON(mob) = 100;
  if (GET_NATURAL_CHA(mob) > 100)
    GET_NATURAL_CHA(mob) = 100;
}

/* mod_for_lvldiff takes a mob that is being summoned/raised/etc by ch and
 * modifies its stats appropriately (up for higher-level ch, down for
 * lower-level ch). if ch or mob is NULL, it returns without effect. */
void mod_for_lvldiff(struct char_data *mob, struct char_data *ch)
{
  float mult;

  if (!mob || !ch)
    return;

  mult = (float)GET_LEVEL(ch) / (float)GET_LEVEL(mob);
  if (mult > 2.0)
    mult = 2.0;

  GET_MAX_HIT(mob) *= mult;
  GET_MAX_MOVE(mob) *= mult;
}

/* new fn create_undead() added to help separate the logic of creating the
 * critter from that of actually summoning the thing -- 321 */
/* orig is the original (living) mob.
 * caster is the caster of the animate spell to tell us how to modify the
 *   new mob's stats, or NULL to skip modifying undead stats */
struct char_data *create_undead(struct char_data *orig,
      struct char_data *caster, bool ISPC)
{
  char short_buf[160], long_buf[160], alias_buf[160];
  struct char_data *new_mob, *next_mob;
  enum undead_type new_mob_type;

  extern struct player_special_data dummy_mob;
  extern void roll_natural_abils(struct char_data *);
  extern void assign_triggers(void *, int);

  if ((GET_LEVEL(orig) > 94) && IS_MAGIC_USER(orig) && !number(0, 250))
    new_mob_type = MOB_LICH;
  else if ((GET_LEVEL(orig) > 40) && IS_MAGIC_USER(orig) && !number(0, 6))
    new_mob_type = MOB_WRAITH;
  else if ((GET_LEVEL(orig) > 25) && IS_ROGUE(orig) && !number(0, 4))
    new_mob_type = MOB_SPECTRE;
  else if (!number(0, 2))
    new_mob_type = MOB_SKELETON;
  else
    new_mob_type = MOB_ZOMBIE;

  new_mob = create_char();

  next_mob = new_mob->next; /* it's about to get overwritten */
  *new_mob = *orig;
  new_mob->next = next_mob; /* put it back */
  new_mob->player_specials = &dummy_mob;

  /* make sure it has no money in case the proto does */
  GET_PLATINUM(new_mob) = 0;
  GET_GOLD(new_mob) = 0;
  GET_SILVER(new_mob) = 0;
  GET_COPPER(new_mob) = 0;

  if (ISPC)
  {
    sprintf(short_buf, "a rotting, fetid zombie");
    sprintf(long_buf, "A rotting, fetid zombie lurches here.");
    sprintf(alias_buf, "zombie animate dead");
  }
  else
  {
    switch(new_mob_type)
    {
    case MOB_ZOMBIE:
      sprintf(short_buf, "the zombie of %s", GET_NAME(orig));
      sprintf(long_buf, "The zombie of %s lurches here.", GET_NAME(orig));
      sprintf(alias_buf, "zombie %s", GET_NAMELIST(orig));
      break;
    case MOB_SKELETON:
      sprintf(short_buf, "the skeleton of %s", GET_NAME(orig));
      sprintf(long_buf, "The skeleton of %s stands creaking at attention.",
              GET_NAME(orig));
      sprintf(alias_buf, "skeleton %s", GET_NAMELIST(orig));
      break;
    case MOB_SPECTRE:
      strcpy(short_buf, "a spectre");
      strcpy(long_buf, "A spectre lurks in the corner here.");
      strcpy(alias_buf, "spectre");
      break;
    case MOB_WRAITH:
      strcpy(short_buf, "a wraith");
      strcpy(long_buf, "A wraith floats above the ground moaning.");
      strcpy(alias_buf, "wraith");
      break;
    case MOB_LICH:
      strcpy(short_buf, "a lich");
      strcpy(long_buf, "A lich glares around the room sneering maliciously.");
      strcpy(alias_buf, "lich");
      break;
    }
  }

  strcat(long_buf, "\r\n");
  GET_NAME(new_mob) = strdup(short_buf);
  new_mob->player.long_descr = strdup(long_buf);
  GET_NAMELIST(new_mob) = strdup(alias_buf);

  roll_natural_abils(new_mob);

  /* this bit's taken straight out of read_mobile. i'm assuming it's good
   * *gulp* */
  new_mob->actual_abils = new_mob->natural_abils;

  scale_attribs(new_mob);

  /* Set up skills, innates, etc. */
  update_char(new_mob);

  /* New Points Gen to make for lower values = to around 2x the caster's */
  new_mob->points.max_hit = ( (caster->points.max_hit * 21) / 10 );

  mod_for_undead_type(new_mob, new_mob_type);
  mod_for_lvldiff(new_mob, caster);

  new_mob->points.move = new_mob->points.max_move;
  new_mob->points.hit = new_mob->points.max_hit;

  new_mob->player.time.birth = time(0);
  new_mob->player.time.played = 0;
  new_mob->player.time.logon = time(0);

  assign_triggers(new_mob, 0);
  /* no more exp for killing your raised dead */
  GET_EXP(new_mob) = 0;
  SET_FLAG(MOB_FLAGS(new_mob), MOB_NOSCRIPT);  /* Prevent specprocs and triggers */

  return new_mob;
}

/* new fn ch_can_control_mob added as a helper to mag_summons to determine if
 * ch can successfully summon and control a mob. returns CONTROL_YES if ch
 * can summon and control mob, CONTROL_NO if ch can't control it, and
 * CONTROL_HELLNO if ch couldn't even control it under the /best/ of
 * circumstances - 321 */

enum { CONTROL_HELLNO, CONTROL_NO, CONTROL_YES };

#define ATTRIB_MULT(attr)   ((float)(attr) / 250.0 + 0.8)
#define GET_CONTROL_VAL(ch) ((float)(GET_LEVEL(ch)) * \
                             (ATTRIB_MULT(GET_INT(ch))) * \
                             (ATTRIB_MULT(GET_WIS(ch))) * \
                             (ATTRIB_MULT(GET_CHA(ch))))

#define MAX_PETS            8

int ch_can_control_mob(struct char_data *ch, struct char_data *mob)
{
  int max_single_control, max_total_control, current_control = 0;
  struct follow_type *foll;
  int num_pets = 0;

  if (GET_LEVEL(ch) >= LVL_IMMORT)
    return CONTROL_YES;

  max_single_control = (LVL_IMMORT - GET_LEVEL(ch)) / 2 + GET_LEVEL(ch);
  if (GET_LEVEL(ch) * 2 < max_single_control)
    max_single_control = GET_LEVEL(ch) * 2;
  if (GET_CONTROL_VAL(mob) > max_single_control)
    return CONTROL_HELLNO;

  max_total_control = GET_CONTROL_VAL(ch);
  for (foll = ch->followers; foll; foll = foll->next)
    if (EFF_FLAGGED(foll->follower, EFF_CHARM)) {
      current_control += GET_CONTROL_VAL(foll->follower);
      num_pets++;
    }
  if ((current_control + GET_CONTROL_VAL(mob) > max_total_control) ||
      (num_pets >= MAX_PETS))
    return CONTROL_NO;

  return CONTROL_YES;
}

struct char_data *load_summoned_mob(int vnum, int destroom)
{
   struct char_data *mob;
   int r_num;
   if ((r_num = real_mobile(vnum)) < 0) {
      sprintf(buf, "SYSERR: tried to summon mob with nonexistent vnum %d",
            vnum);
      log("%s",buf);
      return NULL;
   }
   mob = read_mobile(r_num, REAL);
   char_to_room(mob, destroom);
   GET_EXP(mob) = 0;
   GET_PLATINUM(mob) = 0;
   GET_GOLD(mob) = 0;
   GET_SILVER(mob) = 0;
   GET_COPPER(mob) = 0;

   REMOVE_FLAG(MOB_FLAGS(mob), MOB_HELPER);
   REMOVE_FLAG(MOB_FLAGS(mob), MOB_NOSUMMON);
   REMOVE_FLAG(MOB_FLAGS(mob), MOB_PEACEFUL);
   REMOVE_FLAG(MOB_FLAGS(mob), MOB_PEACEKEEPER);
   REMOVE_FLAG(MOB_FLAGS(mob), MOB_PROTECTOR);
   return mob;
}

struct char_data *duplicate_char(struct char_data *model, int destroom)
{
   struct char_data *new_mob;

   if (GET_MOB_VNUM(model) > 0)
      new_mob = load_summoned_mob(GET_MOB_VNUM(model), destroom);
   else
      new_mob = load_summoned_mob(1, destroom);
   if (!new_mob) return 0;

   new_mob->natural_abils = model->natural_abils;
   new_mob->actual_abils = model->actual_abils;
   new_mob->affected_abils = model->affected_abils;
   new_mob->points = model->points;

   /* struct char_player_data */
   if (model->player.namelist)
      new_mob->player.namelist = strdup(model->player.namelist);

   if (model->player.short_descr)
      new_mob->player.short_descr = strdup(model->player.short_descr);
   if (model->player.long_descr)
      new_mob->player.long_descr = strdup(model->player.long_descr);

   if (!IS_NPC(model)) {
      new_mob->mob_specials.default_pos = 127;
   }
   if (model->player.description)
      new_mob->player.description = strdup(model->player.description);
   if (model->player.title) {
      new_mob->player.title = strdup(model->player.title);
   }
   new_mob->player.sex = model->player.sex;
   new_mob->player.class = model->player.class;
   new_mob->player.race = model->player.race;
   new_mob->player.race_align = model->player.race_align;
   new_mob->player.level = model->player.level;
   GET_HOMEROOM(new_mob) = GET_HOMEROOM(model);
   new_mob->player.time = model->player.time;
   new_mob->player.composition = model->player.composition;
   new_mob->player.lifeforce = model->player.lifeforce;

   /* mod_size and affected_size are set like this because the duplicate
    * will not have the spells or equipment that would place a value in mod_size. */
   new_mob->player.affected_size = model->player.natural_size;
   new_mob->player.mod_size = 0;
   new_mob->player.natural_size = model->player.natural_size;
   new_mob->player.base_size = model->player.base_size;
   new_mob->player.base_weight = model->player.base_weight;
   new_mob->player.base_height = model->player.base_height;
   reset_height_weight(new_mob);
   /* END struct char_player_data */

   /* struct char_special_data */
   GET_POS(new_mob) = GET_POS(model);
   GET_STANCE(new_mob) = GET_STANCE(model);
   /* Set default pos to something impossible so that the position-description
    * will always be tacked on */
   GET_DEFAULT_POS(new_mob) = -1;
   new_mob->char_specials.alignment = model->char_specials.alignment;
   COPY_FLAGS(MOB_FLAGS(new_mob), MOB_FLAGS(model), NUM_MOB_FLAGS);
   new_mob->char_specials.perception = model->char_specials.perception;
   new_mob->char_specials.hiddenness = model->char_specials.hiddenness;
   /* TODO: saving throw and skills */
   /* END struct char_special_data */

   /* struct mob_special_data */
   new_mob->mob_specials = model->mob_specials;
   new_mob->mob_specials.memory = NULL;
   /* END struct mob_special_data */

   REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_SPEC);

   return new_mob;
}

struct char_data *copyplayer(struct char_data *ch, struct char_data *model)
{
   struct char_data *new_mob;

   new_mob = duplicate_char(model, ch->in_room);
   if (!new_mob) return 0;

   CLEAR_FLAGS(MOB_FLAGS(new_mob), NUM_MOB_FLAGS);
   SET_FLAG(MOB_FLAGS(new_mob), MOB_ISNPC);
   SET_FLAG(MOB_FLAGS(new_mob), MOB_SCAVENGER);
   SET_FLAG(MOB_FLAGS(new_mob), MOB_MEMORY);

   return new_mob;
}

/* Transform a character into a phantasm.
 * This is intended for a mob that's being created as a phantasm.
 *
 * In other words, NOT to take some physical creature and suddenly make it
 * illusory - that would entail its objects falling to the ground and stuff.
 * And it really wouldn't fit any scenarios very well. */
void phantasm_transform(struct char_data *ch, struct char_data *model, int life_hours)
{
   struct effect effect;

   SET_FLAG(MOB_FLAGS(ch), MOB_ILLUSORY);   /* Make it an illusion */

   /* Make it expire */
   if (life_hours > 0) {
      memset(&effect, 0, sizeof(effect));
      effect.type = SPELL_PHANTASM;
      effect.duration = life_hours;
      SET_FLAG(effect.flags, EFF_ANIMATED);
      effect_to_char(ch, &effect);
   }

   /* Phantasms have no objects and thus no money. */
   GET_PLATINUM(ch) = 0;
   GET_GOLD(ch) = 0;
   GET_SILVER(ch) = 0;
   GET_COPPER(ch) = 0;

   /* Having no soul, phantasms cannot exude auras of good or evil. */
   GET_ALIGNMENT(ch) = 0;

   /* The phantasm copies its model's current state, even if that state was
    * modified by magic.  Illusion-creating spells don't worry about the
    * underlying cause - they just make a copy. */
   if (model) {
      /* So the copy's height, weight, and size all come from the
       * model's affected values. */
      ch->player.weight = model->player.weight;
      ch->player.height = model->player.height;
      ch->player.affected_size = model->player.affected_size;
      ch->player.mod_size = 0;
      ch->player.natural_size = model->player.affected_size;
      ch->player.base_size = model->player.base_size;
      ch->player.base_weight = model->player.base_weight;
      ch->player.base_height = model->player.base_height;
   }
}

struct char_data *summon_phantasm(struct char_data *ch, int vnum, int life_hours)
{
   struct char_data *new_mob;

   if (!(new_mob = load_summoned_mob(vnum, ch->in_room)))
      return NULL;

   phantasm_transform(new_mob, NULL, life_hours);
   SET_FLAG(MOB_FLAGS(new_mob), MOB_NOSCRIPT);  /* Prevent specprocs and triggers */

   return new_mob;
}

/*
 * Every spell which summons/gates/conjours a mob comes through here.
 *
 * Return value: CAST_RESULT_ flags.
 */

int mag_summon(int skill, struct char_data *ch, struct char_data *vict,
      struct obj_data *obj,
      int spellnum, int savetype)
{
  int orig_mob_rnum;
  struct char_data *new_mob;
  int success, duration;
  struct effect eff;
  struct obj_data *temp_obj, *next_obj;
  float base_duration, preserve_mult;

  /* PROJECT */
  int pvnum;
  int phantasm_mobs[] = {
     8016,   /*  0. ant              */
     3506,   /*  1. mouse            */
     1020,   /*  2. garter snake     */
     5414,   /*  3. lesser shade     */
     8605,   /*  4. sparrow          */
     1688,   /*  5. rabbit           */
     8807,   /*  6. cat              */
     17205,  /*  7. the familiar     */
     8803,   /*  8. cow              */
     4308,   /*  9. ceiling monkey   */
     30215,  /* 10. snow troll       */
     12504,  /* 11. gnome            */
     23732   /* 12. tiny mist beast  */
  };
  int num_phantasm_mobs = 13;

  if (!ch)
    return 0;

  if (EFF_FLAGGED(ch, EFF_CHARM) && !MOB_FLAGGED(ch, MOB_ANIMATED)) {
    send_to_char("You are too giddy to have any followers!\r\n", ch);
    return CAST_RESULT_CHARGE;
  }

  switch (spellnum) {
  case SPELL_ANIMATE_DEAD:
    /* first make sure it's a corpse */
    if (!obj || !IS_CORPSE(obj)) {
      send_to_char("A corpse would help, don't you think?\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    /* if it was a pc corpse, fail automatically (for now at least) */
    if (IS_PLR_CORPSE(obj)) {
      if (!pk_allowed) {
        send_to_char("Raising PC corpses is not currently allowed.\r\n", ch);
        return CAST_RESULT_CHARGE;
      }
    } else if ((GET_OBJ_VAL(obj, VAL_CONTAINER_CORPSE) == CORPSE_NPC_NORAISE) || /* unraisable */
               ((orig_mob_rnum = GET_OBJ_MOB_FROM(obj)) == NOBODY)) {
      send_to_char("That corpse is much too decayed to raise.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    /* make the mob. */
    if (!IS_PLR_CORPSE(obj))
      new_mob = create_undead(mob_proto + orig_mob_rnum, ch, FALSE);
    else
        new_mob = create_undead(mob_proto, ch, TRUE);

    char_to_room(new_mob, ch->in_room);

    /* can we control it? */
    success = ch_can_control_mob(ch, new_mob);
    if (success == CONTROL_HELLNO) {
      act("You begin to raise $N beyond your power, but you stop the spell "
          "in time.", FALSE, ch, 0, new_mob, TO_CHAR);
      act("$n begins to raise $N beyond $s power, but $e stops the spell "
          "in time.", FALSE, ch, 0, new_mob, TO_ROOM);
      extract_char(new_mob);
      GET_OBJ_VAL(obj, VAL_CONTAINER_CORPSE) = CORPSE_NPC_NORAISE; /* mark it unraisable */
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    /* anim duration will depend on success later */
    base_duration = (((float)skill - 20.0) / 5.0 + 5.0) * 3.0;
    preserve_mult = (float)GET_OBJ_DECOMP(obj) / 300.0 + 1.0;
    if (preserve_mult > 2.0)
      preserve_mult = 2.0;

    /* make perma-stoned mobs twitch faster*/
    if (EFF_FLAGGED(new_mob, EFF_STONE_SKIN))
      base_duration /= 6.0;

    /* set it as animated */
    memset(&eff, 0, sizeof(eff));
    eff.type = SPELL_ANIMATE_DEAD;
    eff.duration =  (int)(base_duration * preserve_mult);
    SET_FLAG(eff.flags, EFF_ANIMATED);
    eff.modifier = 0;
    eff.location = APPLY_NONE;
    effect_to_char(new_mob, &eff);

    if (success == CONTROL_YES) { /* controlled it */
      act("You raise $N.", FALSE, ch, 0, new_mob, TO_CHAR);
      act("$n raises $N.", FALSE, ch, 0, new_mob, TO_ROOM);
      eff.type = SPELL_CHARM;
      eff.duration =  (int)(base_duration * preserve_mult) + 1;
      SET_FLAG(eff.flags, EFF_CHARM);
      eff.modifier = 0;
      eff.location = APPLY_NONE;
      effect_to_char(new_mob, &eff);
      add_follower(new_mob, ch);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGRESSIVE);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_SPEC);
    } else { /* not able to control it */
      act("You raise $N, and $E doesn't seem too happy about it.", FALSE, ch,
          0, new_mob, TO_CHAR);
      act("$n raises $N, and $E doesn't seem too happy about it.", FALSE, ch,
          0, new_mob, TO_ROOM);
      /* we want it aggressive, but not against anything in particular */
      SET_FLAG(MOB_FLAGS(new_mob), MOB_AGGRESSIVE);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGR_EVIL);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGR_GOOD);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGR_NEUTRAL);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGR_EVIL_RACE);
      REMOVE_FLAG(MOB_FLAGS(new_mob), MOB_AGGR_GOOD_RACE);

      attack(new_mob, ch);
    }

    /* move corpse possessions to mob */
    for (temp_obj = obj->contains; temp_obj; temp_obj = next_obj) {
      next_obj = temp_obj->next_content;
      obj_from_obj(temp_obj);
      if (GET_OBJ_TYPE(temp_obj) == ITEM_MONEY) {
        GET_PLATINUM(new_mob) += GET_OBJ_VAL(temp_obj, VAL_MONEY_PLATINUM);
        GET_GOLD(new_mob) += GET_OBJ_VAL(temp_obj, VAL_MONEY_GOLD);
        GET_SILVER(new_mob) += GET_OBJ_VAL(temp_obj, VAL_MONEY_SILVER);
        GET_COPPER(new_mob) += GET_OBJ_VAL(temp_obj, VAL_MONEY_COPPER);
        extract_obj(temp_obj);
      } else
        obj_to_char(temp_obj, new_mob);
    }

    /* destroy the corpse */
    extract_obj(obj);

    return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
  case SPELL_PHANTASM:

    /* Decide how long it will live */
    duration = 2 + skill / 5;

    /* Choose one of our available mobs */
    pvnum = phantasm_mobs[number(0, num_phantasm_mobs - 1)];
    if (real_mobile(pvnum) < 0)
       pvnum = 9001; /* Test mob = earle's doppelganger */

    /* Load it up */
    new_mob = summon_phantasm(ch, pvnum, duration);
    if (new_mob == NULL) {
       act("The spell fizzles.", FALSE, 0, 0, 0, TO_ROOM);
       send_to_char("The spell fizzles.\r\n", ch);
       return 0;
    }

    /* Feedback */
    act("From scattered motes of light, $n coalesces.", TRUE,
          new_mob, 0, 0, TO_ROOM);
    return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;

  case SPELL_SIMULACRUM:
  /* Simulacrum is like the phantasm spell, except it duplicates an
   * existing creature. */
    if (!vict) {
       send_to_char("Who did you want to duplicate?\r\n", ch);
       return 0;
    }
    if (GET_LEVEL(vict) > skill) {
       act("$N is far too powerful!", FALSE, ch, 0, vict, TO_CHAR);
       return CAST_RESULT_CHARGE;
    }

    /* Decide how long the phantasm will last */
    duration = 3 + skill / 4;
    pvnum = GET_MOB_VNUM(vict);

    /* Load it up */
    if (pvnum < 0 || real_mobile(pvnum) < 0) {

       /* Apparently we're making an illusory copy of a player. */
       if (!IS_NPC(vict)) {
          new_mob = copyplayer(ch, vict);
          if (new_mob == NULL) {
            act("The spell fizzles.", FALSE, 0, 0, 0, TO_ROOM);
            send_to_char("The spell fizzles.\r\n", ch);
            return 0;
          }
       } else {
         send_to_char("Sadly, that's impossible.\r\n", ch);
         return 0;
       }
       phantasm_transform(new_mob, vict, duration);

       /* Set this so aggro mobs will still attack it, even though
        * it technically isn't a player. */
       SET_FLAG(MOB_FLAGS(new_mob), MOB_PLAYER_PHANTASM);
    } else {
      /* Making an illusory copy of an NPC. */
      new_mob = duplicate_char(vict, ch->in_room);
      if (!new_mob) {
        act("The spell fizzles.", FALSE, 0, 0, 0, TO_ROOM);
        send_to_char("The spell fizzles.\r\n", ch);
        return 0;
      }
      phantasm_transform(new_mob, vict, duration);
    }
    SET_FLAG(MOB_FLAGS(new_mob), MOB_NOSCRIPT);  /* Prevent specprocs and triggers */
    /* Feedback */
    act("From scattered motes of light, $n coalesces.", TRUE,
          new_mob, 0, 0, TO_ROOM);
    return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
  case SPELL_SUMMON_ELEMENTAL:
  default:
    return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
  }
  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}

/* mag_point
 *
 * Performs healing magic on characters.
 *
 * Return value: CAST_RESULT_ flags
 */

int mag_point(int skill, struct char_data * ch, struct char_data * victim,
      int spellnum, int savetype)
{
  int hit = 0;
  int move = 0;
  int hunger = 0;
  int thirst = 0;
  int hide = 0;
  int multiplier = 0;
  int sus;

  if (victim == NULL)
    return 0;

  sus = susceptibility(victim, skills[spellnum].damage_type);

  multiplier = 2 + (skill / 24); /* max 6 */

  switch (spellnum) {
  case SPELL_CURE_LIGHT:
    hit = dice(2, 8) + 1;
    send_to_char("You feel better.\r\n", victim);
    break;
  case SPELL_CURE_CRITIC:
    hit = dice(6, 8) + 3;
    send_to_char("You feel a lot better!\r\n", victim);
    break;
  case SPELL_CURE_SERIOUS:
    hit = dice(4, 8) + 2;
    send_to_char("You feel much better!\r\n", victim);
    break;
  case SPELL_HEAL:
    hit = dice(50, 2);
    send_to_char("A warm feeling floods your body.\r\n", victim);
    break;
  case SPELL_FULL_HEAL:
    hit = dice(100, 2) + 30;
    send_to_char("&7You have been FULLY healed!&0\r\n", victim);
    break;
  case SPELL_VIGORIZE_LIGHT:
    move = dice(3, 8) + 5;
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_VIGORIZE_SERIOUS:
    move = dice(5, 8) + 5;
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_VIGORIZE_CRITIC:
    move = dice(7, 8) + 5;
    send_to_char("You feel vigorized!\r\n", victim);
    break;
  case SPELL_NOURISHMENT:
    switch (SECT(victim->in_room)) {
         case SECT_FIELD:
         case SECT_FOREST:
         case SECT_HILLS:
         case SECT_MOUNTAIN:
         case SECT_ROAD:
         case SECT_GRASSLANDS:
         case SECT_SWAMP:
         case SECT_BEACH:
            hunger = 24;
            thirst = 24;
            act("&2&b$n&2&b sprouts roots that dig deep beneath the soil, drawing sustenence.&0",
                  TRUE, victim, 0, 0, TO_ROOM);
            act("&2&bYou sprout roots that dig deep beneath the soil, drawing sustenence.&0",
                  FALSE, victim, 0, 0, TO_CHAR);
            break;
         default:
            act("&2$n&2 sends forth roots in a vain attempt to gain sustenance.&0",
                  TRUE, victim, 0, 0, TO_ROOM);
            switch (SECT(victim->in_room)) {
               case SECT_SHALLOWS:
               case SECT_WATER:
               case SECT_UNDERWATER:
                  thirst = 24;
                  act("&2You send out roots which quickly become waterlogged.  They draw moisture but no nutrients.&0",
                        FALSE, victim, 0, 0, TO_CHAR);
                  break;
               case SECT_AIR:
                  act("&2Your roots flail briefly in the air, unable to grow without soil.&0",
                        FALSE, victim, 0, 0, TO_CHAR);
                  break;
               default:
                  act("&2You send out roots, but they are unable to penetrate to the life-giving soil.&0",
                        FALSE, victim, 0, 0, TO_CHAR);
            }
    }
    break;
  case SPELL_INVIGORATE:
    move = GET_MAX_MOVE(victim);
    send_to_char("You feel fully vigorized!\r\n", victim);
    break;
  case SPELL_NATURES_EMBRACE:
    hide = skill * 5;
    break;
  case SPELL_CONCEALMENT:
    send_to_char("&9&bYou vanish.&0\r\n", victim);
    act("&9&b$N&9&b slowly fades out of existence.&0", TRUE, ch, 0, victim, TO_ROOM);
    hide = skill * 4;
    break;
  default:
    log("SYSERR:magic.c:mag_point():invalid spell");
    return CAST_RESULT_CHARGE;
  }

  hit = hit * sus / 100;
  move = move * sus / 100;
  hunger = hunger * sus / 100;
  thirst = thirst * sus / 100;
  hide = hide * sus / 100;

  if (hit)
    hurt_char(victim, ch, -hit * multiplier, TRUE);
  if (move)
    alter_move(victim, -move * multiplier);
  if (hunger)
    gain_condition(victim, FULL, hunger);
  if (thirst)
    gain_condition(victim, THIRST, thirst);
  if (hide)
    GET_HIDDENNESS(victim) = MIN(GET_HIDDENNESS(victim) + hide, 1000);

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}

/* mag_unaffect
 *
 * Return value: CAST_RESULT_ flags.
 */

int mag_unaffect(int skill, struct char_data * ch, struct char_data * victim,
                   int spellnum, int type)
{
  int spell = 0;
  char *to_vict = NULL, *to_room = NULL;

  if (victim == NULL)
    return 0;

  switch (spellnum) {
  case SPELL_EXTINGUISH:
    REMOVE_FLAG(EFF_FLAGS(victim), EFF_ON_FIRE);
    send_to_char("You are doused with a magical liquid.\r\n",victim);
    return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
  case SPELL_SANE_MIND:
    spell = SPELL_INSANITY;
    to_vict = "Your mind comes back to reality.";
    break;
  case SPELL_ENLARGE:
    if (!EFF_FLAGGED(victim, EFF_REDUCE))
      return CAST_RESULT_CHARGE;
    spell = SPELL_REDUCE;
    to_vict = "&8You return to your normal size.&0";
    break;
  case SPELL_REDUCE:
    if (!EFF_FLAGGED(victim, EFF_ENLARGE))
      return CAST_RESULT_CHARGE;
    spell = SPELL_ENLARGE;
    to_vict = "&8You return to your normal size.&0";
    break;
  case SPELL_CURE_BLIND:
  case SPELL_HEAL:
  case SPELL_FULL_HEAL:
    if (EFF_FLAGGED(victim, EFF_BLIND)) {
      to_vict = "Your vision returns!";
      to_room = "There's a momentary gleam in $n's eyes.";
      if (affected_by_spell(victim, SPELL_BLINDNESS))
        spell = SPELL_BLINDNESS; /* Remove blindness below */
      if (affected_by_spell(victim, SKILL_EYE_GOUGE)) {
        if (spell) /* If already removing a spell, remove eye gouge now */
          effect_from_char(victim, spell);
        spell = SKILL_EYE_GOUGE;
      }
      if (affected_by_spell(victim, SPELL_SUNRAY)) {
        if
 (spell) /* If already removing a spell, remove sunray now */
          effect_from_char(victim, spell);
        spell = SPELL_SUNRAY;
      }
    }
    if ((spellnum == SPELL_HEAL || spellnum == SPELL_FULL_HEAL) &&
            affected_by_spell(victim, SPELL_DISEASE)) {
      effect_from_char(victim, SPELL_DISEASE);
      send_to_char("Your disease has been cured.\r\n", victim);
    }
    break;
  case SPELL_REMOVE_POISON:
    spell = SPELL_POISON;
    to_vict = "A warm feeling runs through your body!";
    to_room = "$n looks better.";
    break;
  case SPELL_REMOVE_CURSE:
    spell = SPELL_CURSE;
    to_vict = "You don't feel so unlucky.";
    break;
  default:
    sprintf(buf, "SYSERR: unknown spellnum %d passed to mag_unaffect", spellnum);
    log("%s",buf);
    return CAST_RESULT_CHARGE;
  }

  if (!affected_by_spell(victim, spell) && spellnum != SPELL_HEAL && spellnum != SPELL_FULL_HEAL) {
    send_to_char(NOEFFECT, ch);
    return CAST_RESULT_CHARGE;
  }

  effect_from_char(victim, spell);
  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);

  if (spellnum == SPELL_REMOVE_POISON)
    check_regen_rates(victim);        /* speed up regen rate immediately */

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}


/* Return value: CAST_RESULT_ flags.
 */
int mag_alter_obj(int skill, struct char_data *ch, struct obj_data *obj,
      int spellnum, int savetype)
{
  char *to_char = NULL;
  char *to_room = NULL;
  int i;
  int result = CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;

  /* Set post_modify to TRUE if you want to send messages first, then
   * modify the object. You must add a case to the second switch
   * statement to actualy make the modification(s). */
  bool post_modify = FALSE;

  if (obj == NULL)
    return 0;

  switch (spellnum) {
  case SPELL_DARK_PRESENCE:
     /* Skip all checks if godly */
     if (GET_LEVEL(ch) > LVL_IMMORT) {
       if (OBJ_EFF_FLAGGED(obj, EFF_HEX)) {
         to_char = "It's already hexed.";
       } else {
         SET_FLAG(GET_OBJ_EFF_FLAGS(obj), EFF_HEX);
         SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_ANTI_GOOD);
         to_char = "$p is imbued with a dark aura.";
       }
       break;
     }

     for (i = 0; i < MAX_OBJ_APPLIES; i++) {
        if (obj->applies[i].location) {
           /* This signifies that an effect was found - see below */
           i = -1;
           break;
        }
     }

    result = CAST_RESULT_CHARGE;

    if (GET_OBJ_TYPE(obj) != ITEM_WEAPON) {
        to_char = "This spell is only effective on weapons.";
        result = 0;

       /* Too high level? */
    } else if (GET_OBJ_LEVEL(obj) > skill)
       to_char = "$p is too powerful for you to hex.";

       /* Too heavy */
    else if (GET_OBJ_WEIGHT(obj) > 5 * skill)
       to_char = "$p is too large for you to hex.";

       /* Some sort of impurity (or already hexed) */
    else if (OBJ_FLAGGED(obj, ITEM_GLOW) ||
        OBJ_FLAGGED(obj, ITEM_HUM) ||
        OBJ_FLAGGED(obj, ITEM_INVISIBLE) ||
        OBJ_FLAGGED(obj, ITEM_MAGIC) ||
        OBJ_FLAGGED(obj, ITEM_NODROP) ||
        OBJ_FLAGGED(obj, ITEM_ANTI_EVIL))
       to_char = "$p doesn't seem receptive to the malediction.";

      /* Already has magical effects */
    else if (HAS_FLAGS(GET_OBJ_EFF_FLAGS(obj), NUM_EFF_FLAGS) ||
          i < 0 /* see obj->affected check, above */
          )
       to_char = "The hex is repelled from $p.";
    else {
      SET_FLAG(GET_OBJ_EFF_FLAGS(obj), EFF_HEX);
      SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_ANTI_GOOD);
      to_char = "$p is imbued with a dark aura.";
      result = CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    break;
  case SPELL_BLESS:
     /* Skip all checks if godly */
     if (GET_LEVEL(ch) > LVL_IMMORT) {
       if (OBJ_EFF_FLAGGED(obj, EFF_BLESS)) {
         to_char = "It's already blessed.";
       } else {
         SET_FLAG(GET_OBJ_EFF_FLAGS(obj), EFF_BLESS);
         SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_ANTI_EVIL);
         to_char = "$p glows briefly.";
       }
       break;
     }

     result = CAST_RESULT_CHARGE;

     for (i = 0; i < MAX_OBJ_APPLIES; i++) {
        if (obj->applies[i].location) {
           /* This signifies that an effect was found - see below */
           i = -1;
           break;
        }
     }

    if (GET_OBJ_TYPE(obj) != ITEM_WEAPON) {
        to_char = "This spell is only effective on weapons.";
        result = 0;

       /* Too high level? */
    } else if (GET_OBJ_LEVEL(obj) > skill)
       to_char = "$p is too powerful for you to bless.";

       /* Too heavy */
    else if (GET_OBJ_WEIGHT(obj) > 5 * skill)
       to_char = "$p is too large for you to bless.";

       /* Some sort of impurity (or already blessed) */
    else if (OBJ_FLAGGED(obj, ITEM_GLOW) ||
        OBJ_FLAGGED(obj, ITEM_HUM) ||
        OBJ_FLAGGED(obj, ITEM_INVISIBLE) ||
        OBJ_FLAGGED(obj, ITEM_MAGIC) ||
        OBJ_FLAGGED(obj, ITEM_NODROP) ||
        OBJ_FLAGGED(obj, ITEM_ANTI_GOOD))
       to_char = "$p doesn't seem receptive to the blessing.";

      /* Already has magical effects */
    else if (HAS_FLAGS(GET_OBJ_EFF_FLAGS(obj), NUM_EFF_FLAGS) ||
          i < 0 /* see obj->affected check, above */
          )
       to_char = "The blessing is repelled from $p.";
    else {
      SET_FLAG(GET_OBJ_EFF_FLAGS(obj), EFF_BLESS);
      SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_ANTI_EVIL);
      to_char = "$p glows briefly.";
      result = CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }
    break;
  case SPELL_CURSE:
    if (!OBJ_FLAGGED(obj, ITEM_NODROP)) {
      SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_NODROP);
      if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
        GET_OBJ_VAL(obj, VAL_WEAPON_DICE_SIZE)--;
      to_char = "$p briefly glows red.";
    }
    break;
  case SPELL_INVISIBLE:
  case SPELL_MASS_INVIS:
    if (!OBJ_FLAGGED(obj, ITEM_NOINVIS) && !OBJ_FLAGGED(obj, ITEM_INVISIBLE)) {
      post_modify = TRUE;
      to_char = "$p vanishes.";
    }
    break;
  case SPELL_POISON:
    if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && !IS_POISONED(obj)) {
      GET_OBJ_VAL(obj, VAL_FOOD_POISONED) = TRUE;
      to_char = "$p steams briefly.";
    }
    break;
  case SPELL_REMOVE_CURSE:
    if (OBJ_FLAGGED(obj, ITEM_NODROP)) {
      REMOVE_FLAG(GET_OBJ_FLAGS(obj), ITEM_NODROP);
      if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
        GET_OBJ_VAL(obj, VAL_WEAPON_DICE_SIZE)++;
      to_char = "$p briefly glows blue.";
    }
    break;
  case SPELL_REMOVE_POISON:
    if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && IS_POISONED(obj)) {
      GET_OBJ_VAL(obj, VAL_FOOD_POISONED) = FALSE;
      to_char = "$p steams briefly.";
    }
    break;
  }

  if (to_char == NULL)
    send_to_char(NOEFFECT, ch);
  else
    act(to_char, TRUE, ch, obj, 0, TO_CHAR);

  if (to_room != NULL)
    act(to_room, TRUE, ch, obj, 0, TO_ROOM);
  else if (to_char != NULL)
    act(to_char, TRUE, ch, obj, 0, TO_ROOM);

  if (post_modify)
  switch(spellnum) {
    case SPELL_INVISIBLE:
    case SPELL_MASS_INVIS:
       SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_INVISIBLE);
       break;
  }

  return result;
}

#define WAYBREAD_OBJ_1 18508
#define WAYBREAD_OBJ_2 10

int mag_creation(int skill, struct char_data * ch, int spellnum)
{
  char *to_char=NULL, *to_room=NULL;
  struct obj_data *tobj;
  int z, zplus;
  int give_char=0;
  if (ch == NULL)
    return 0;

  switch (spellnum) {
  case SPELL_CREATE_SPRING:
    switch (SECT(IN_ROOM(ch))) {
      case SECT_SHALLOWS:
      case SECT_WATER:
      case SECT_UNDERWATER:
      case SECT_AIR:
        cprintf(ch, "Nothing happens.\r\n");
        act("$n completes $s spell, but nothing happens.", TRUE, ch, 0, 0, TO_ROOM);
        return CAST_RESULT_CHARGE;
        break;
    }
    z = 75;
    to_room = "&4A fresh clear spring of water bursts through the ground here.&0";
    to_char = "&4A fresh clear spring of water bursts through the ground here.&0";
    break;
  case SPELL_CREATE_FOOD:
    /* Select an item from 100.obj. There are 50 items, 10 for each create-fooding class. */

    /* First determine the base vnum by class */
    z = 120; /* For clerics, also for default */
    if (GET_CLASS(ch) == CLASS_PALADIN)
       z = 110;
    else if (GET_CLASS(ch) == CLASS_PRIEST)
       z = 100;
    else if (GET_CLASS(ch) == CLASS_ANTI_PALADIN)
       z = 130;
    else if (GET_CLASS(ch) == CLASS_DRUID)
       z = 140;

    zplus = skill / 16 +
       ((random() % 1000) * (random() % 1000) * 5 * ((random() % 10) < 5 ? 1 : -1)) / 1000000;

    if (zplus < 0) zplus = 0;
    if (zplus > 9) zplus = 9;
    z += zplus;

    /* Do our best to ensure we have an actual object */

    if (real_object(z) < 0) {
       if (real_object(WAYBREAD_OBJ_1) >= 0)
          z = WAYBREAD_OBJ_1;
       else
          z = WAYBREAD_OBJ_2;
    }

    give_char = 1;
    to_room = "$n creates $p.";
    to_char = "You create $p.";
    break;
  default:
    send_to_char("Spell unimplemented, it would seem.\r\n", ch);
    return 0;
  }

  if (!(tobj = read_object(z, VIRTUAL))) {
    send_to_char("I seem to have goofed.\r\n", ch);
    sprintf(buf, "SYSERR: spell_creations, spell %d, obj %d: obj not found",
            spellnum, z);
    log("%s",buf);
    return 0;
  }
  if (give_char)
    obj_to_char(tobj, ch);
  else
    obj_to_room(tobj, ch->in_room);
  if (to_room)
    act(to_room, FALSE, ch, tobj, 0, TO_ROOM);
  if (to_char)
    act(to_char, FALSE, ch, tobj, 0, TO_CHAR);

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}

int mag_room(int skill, struct char_data * ch, int spellnum)
{
  int eff; /* what effect */
  int ticks; /* how many ticks this spell lasts */
  char *to_char = NULL;
  char *to_room = NULL;
  struct room_effect_node *reff;

  ticks = 0;
  eff = -1;

  if (ch == NULL)
    return 0;

  switch (spellnum) {
  case SPELL_WALL_OF_FOG:
    to_char = "You create a fog out of nowhere.";
    to_room = "$n creates a fog out of nowhere.";
    eff = ROOM_EFF_FOG;
    ticks = 1; /* this spell lasts one tick */
    break;
  case SPELL_URBAN_RENEWAL:
    if(SECT(ch->in_room) == SECT_FOREST || ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_FOREST)) {
      send_to_char("There is already enough foliage here to constitute a forest.\r\n",ch);
      return CAST_RESULT_CHARGE;
    }
    eff = ROOM_EFF_FOREST;
    ticks = skill / 10;
    to_char = "&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
    to_room = "&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
    break;
  case SPELL_CIRCLE_OF_FIRE:
    if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_CIRCLE_FIRE)) {
      send_to_char("The room is already on fire.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    if(SECT(ch->in_room) == SECT_SHALLOWS ||
       SECT(ch->in_room) == SECT_WATER ||
       SECT(ch->in_room) == SECT_UNDERWATER) {
      send_to_char("Impossible. There is too much water here.\r\n", ch);
      return CAST_RESULT_CHARGE;
    }
    eff = ROOM_EFF_CIRCLE_FIRE;
    ticks = 2;
    to_char="&1A ring of fire encircles the area.&0";
    to_room="&1A ring of fire encircles the area.&0";
    improve_skill(ch, skills[SPELL_CIRCLE_OF_FIRE].sphere);
    break;

    /* add more room spells continual here */

  default:
    sprintf(buf, "SYSERR: unknown spellnum %d "
            "passed to mag_unaffect", spellnum);
    log("%s",buf);
    return CAST_RESULT_CHARGE;
  }

  /* create, initialize, and link a room-affection node */
  CREATE(reff, struct room_effect_node, 1);
  reff->room = ch->in_room;
  reff->timer = ticks;
  reff->effect = eff;
  reff->spell = spellnum;
  reff->next = room_effect_list;
  room_effect_list = reff;

  /* set the affection */
  if (eff != -1)
    SET_FLAG(ROOM_EFFECTS(reff->room), eff);

  if (to_char == NULL)
    send_to_char(NOEFFECT, ch);
  else
    act(to_char, TRUE, ch, 0, 0, TO_CHAR);

  if (to_room != NULL)
    act(to_room, TRUE, ch, 0, 0, TO_ROOM);
  else if (to_char != NULL)
    act(to_char, TRUE, ch, 0, 0, TO_ROOM);

  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
}

/* Add spells to the case statement here to make a spell's duration skill
   related the spell system automagically adds 1 to this so values start at 0
   Note that adding the default 1 added to a 0 will make the spell wear off
   when the next TICK (currently 75 secs) expires no matter how close it is.
   This gives the affect of nearly instantaneous expiration of the spell.
   */
int get_spell_duration(struct char_data *ch, int spellnum) {
  int skill;
  int duration;

  skill = GET_SKILL(ch, skills[spellnum].sphere);
  duration = 0;


  switch(spellnum)
  {
  case (SPELL_LESSER_ENDURANCE):
    duration = skill / 30;
    if (duration == 0) duration = 2;
    break;

  case (SPELL_ENDURANCE):
  case (SPELL_VITALITY):
    duration = skill / 20;
    if (duration == 0 && skill > 0) duration = 2;
    if (skill > 95)  duration = 5;
    break;

  case (SPELL_DRAGONS_HEALTH):
    duration = skill / 10;
    break;

  case (SPELL_GREATER_ENDURANCE):
  case (SPELL_GREATER_VITALITY):
    duration = skill / 15;
    if (skill > 95)  duration = 7;
    break;

  default:
    log("SYSERR:magic.c:get_spell_duration(): Unknown spell");
  }

  return duration;
}



char* get_vitality_vict_message(int spellnum) {
  int index;
  char* victim_messages[] =
    {
      "&4&bYou feel you can endure significant pain!&0",
        "&4&bYou feel you can endure a bit more pain!&0",
        "&4&bYou feel you can endure more pain!&0",
        "&4&bYou feel vitalized!&0",
        "&4&bYou feel greatly vitalized!&0",
        "&4&bYou feel the blood of dragons surge through your veins!&0"
        };

  index = 0;

  if (spellnum == 70) {
    index = 0;
  }
  else
    {
      index = spellnum - SPELL_LESSER_ENDURANCE + 1;
    };

  /* Greater Endurance, Lesser E, E, Vit, Greater Vit, Dragon's health */

  return victim_messages[index];
}

int get_vitality_hp_gain(struct char_data *ch, int spellnum) {
  int skill;
  int hp;

  skill = GET_SKILL(ch, skills[spellnum].sphere);
  hp = 0;


  switch(spellnum)
  {
  case (SPELL_LESSER_ENDURANCE):
    hp = (pow(skill, 2) / 80) + 25;
    break;

  case (SPELL_ENDURANCE):
    hp = (pow(skill, 2) / 60) + 40;
    break;


  case (SPELL_GREATER_ENDURANCE):
    hp = (pow(skill, 2) / 40) + 50;
    break;

  case (SPELL_VITALITY):
    hp = (pow(skill, 2) / 35) + 75;
    break;


  case (SPELL_GREATER_VITALITY):
    hp = (pow(skill, 2) / 30) + 75;
    break;

  case (SPELL_DRAGONS_HEALTH):
    hp = (pow(skill, 2) / 20) + 90;
    break;

  default:
    log("SYSERR:magic.c:get_vitality_hp_gain(): Unknown spell");
  }

  /* I don't like nice even numbers.  Add some randomness into it. */
  hp -= number(2,10);

  return hp;

}


/*
 * Function to standardize checking for armor spells.
 * Check it at the beginning of any armor spell and immediately return
 * if it returns 1.
 */
bool affected_by_armor_spells(struct char_data *victim) {
  return affected_by_spell(victim, SPELL_ARMOR) ||
         affected_by_spell(victim, SPELL_BARKSKIN) ||
         affected_by_spell(victim, SPELL_BONE_ARMOR) ||
         affected_by_spell(victim, SPELL_DEMONSKIN) ||
         affected_by_spell(victim, SPELL_GAIAS_CLOAK) ||
         affected_by_spell(victim, SPELL_ICE_ARMOR) ||
         affected_by_spell(victim, SPELL_MIRAGE);

}

bool spell_suitable_for_fluid_characters(int spellnum)
{
   switch (spellnum) {
      case SPELL_BARKSKIN:
      case SPELL_BONE_ARMOR:
      case SPELL_DEMONSKIN:
      case SPELL_GAIAS_CLOAK:
      case SPELL_ICE_ARMOR:
      case SPELL_STONE_SKIN:
      case SPELL_COLDSHIELD:
         return FALSE;
   }
   return TRUE;
}

bool check_fluid_spell_ok(struct char_data *ch, struct char_data *victim, int spellnum, bool quiet)
{
   if (!victim) return FALSE;
   if (RIGID(victim) || GET_LEVEL(victim) >= LVL_IMMORT) return TRUE;
   if (!spell_suitable_for_fluid_characters(spellnum)) {
      if (!quiet) {
         cprintf(victim,
               "The spell is unable to take hold in your substance.\r\n");
         if (ch && ch != victim)
            act("The spell is unable to alter $N's substance.",
                  FALSE, ch, 0, victim, TO_CHAR);
      }
      return FALSE;
   }
   return TRUE;
}

void remove_unsuitable_spells(struct char_data *ch)
{
   struct effect *eff, *next;

   if (!RIGID(ch)) {
      for (eff = ch->effects; eff; eff = next) {
         next = eff->next;
         if (!spell_suitable_for_fluid_characters(eff->type))
            active_effect_remove(ch, eff);
      }
   }
}

bool check_armor_spells(struct char_data *ch, struct char_data *victim, int spellnum) {
  if (affected_by_armor_spells(victim)) {
    if (ch == victim) {
      act("You seem to be protected enough already!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, 0, TO_ROOM);
    }
    else {
      act("$N seem to be protected enough already!", FALSE, ch, 0, victim, TO_CHAR);
      act("You seem to be protected enough already!", FALSE, ch, 0, victim, TO_VICT);
      act("$n looks a little overprotective.", TRUE, ch, 0, victim, TO_NOTVICT);
    }
    return TRUE;
  }
  return FALSE;
}

void destroy_opposite_wall(struct obj_data *wall)
{
  void decay_object(struct obj_data *obj);
  int room, dir;
  struct obj_data *next;

  /* Not in a room? */
  if ((room = wall->in_room) == NOWHERE)
    return;

  dir = GET_OBJ_VAL(wall, VAL_WALL_DIRECTION);

  /* Invalid direction? */
  if (dir < 0 || dir >= NUM_OF_DIRS)
    return;

  /* No exit in that direction? */
  if (!world[room].exits[dir] ||
      EXIT_NDEST(world[room].exits[dir]) == NOWHERE)
    return;

  /* Go through the objects in the other room. */
  for (wall = world[world[room].exits[dir]->to_room].contents; wall;
       wall = next) {
    next = wall->next_content;
    dir = GET_OBJ_VAL(wall, VAL_WALL_DIRECTION);
    /* If the object is a wall, has a valid direction, and points back to
     * the original room, kill it. */
    if (GET_OBJ_TYPE(wall) == ITEM_WALL &&
        dir >= 0 && dir < NUM_OF_DIRS &&
        world[wall->in_room].exits[dir] &&
        world[wall->in_room].exits[dir]->to_room == room)
      decay_object(wall);
  }
}

/* Returns TRUE if something was seen. */
bool look_at_magic_wall(struct char_data *ch, int dir, bool sees_next_room)
{
   struct obj_data *wall;
   room_num next_room;

   for (wall = world[ch->in_room].contents; wall; wall = wall->next_content) {
      if (GET_OBJ_TYPE(wall) == ITEM_WALL && GET_OBJ_VAL(wall, VAL_WALL_DIRECTION) == dir) {
         sprintf(buf, "%s &0is standing here.\r\n", wall->short_description);
         CAP(buf);
         send_to_char(buf, ch);
         return TRUE;
      }
   }

   if (sees_next_room) {
      next_room = world[ch->in_room].exits[dir]->to_room;

      if (next_room != NOWHERE) {
         for (wall = world[next_room].contents; wall; wall = wall->next_content)
            if (GET_OBJ_TYPE(wall) == ITEM_WALL &&
                  world[next_room].exits[GET_OBJ_VAL(wall, VAL_WALL_DIRECTION)]->to_room == ch->in_room) {
               sprintf(buf, "You see %s&0 a short distance away.\r\n",
                     wall->short_description);
               send_to_char(buf, ch);
               return TRUE;
            }
      }
   }

   return FALSE;
}

struct obj_data *find_wall_dir(int rnum, int dir)
{
   struct obj_data *wall;

   for (wall = world[rnum].contents; wall; wall = wall->next_content)
      if (GET_OBJ_TYPE(wall) == ITEM_WALL && GET_OBJ_VAL(wall, VAL_WALL_DIRECTION) == dir)
         return wall;
   return NULL;
}

/* Returns TRUE if you were stopped by a magic wall. */
bool wall_block_check(struct char_data *actor, struct char_data *motivator, int dir)
{
   struct obj_data *wall;

   if (GET_LEVEL(actor) >= LVL_GOD) return FALSE;
   if ((wall = find_wall_dir(actor->in_room, dir)) != NULL) {
      /* Found a wall; you'll be blocked. */

      /* See if a wall of ice will put out anyone's flames. */
      if (GET_OBJ_VAL(wall, VAL_WALL_SPELL) == SPELL_WALL_OF_ICE && EFF_FLAGGED(motivator, EFF_ON_FIRE)) {
         act("$n&0 spreads $mself out on $p&0 and with a &8&bsizzle&0, $s flames are put out.",
               FALSE, motivator, wall, 0, TO_ROOM);
         act("You spread yourself out on $p&0 and your flames go out in a &8&bsizzle of steam&0.",
               FALSE, motivator, wall, 0, TO_CHAR);
         REMOVE_FLAG(EFF_FLAGS(motivator), EFF_ON_FIRE);
      } else if (GET_OBJ_VAL(wall, VAL_WALL_SPELL) == SPELL_WALL_OF_ICE && EFF_FLAGGED(actor, EFF_ON_FIRE)) {
         act("$n&0 spreads $mself out on $p&0 and with a &8&bsizzle&0, $s flames are put out.",
               FALSE, actor, wall, 0, TO_ROOM);
         act("You spread yourself out on $p&0 and your flames go out in a &8&bsizzle of steam&0.",
               FALSE, actor, wall, 0, TO_CHAR);
         REMOVE_FLAG(EFF_FLAGS(actor), EFF_ON_FIRE);

      /* No flames being put out.  Is this a mounted situation? */
      } else if (actor && motivator && actor != motivator && RIDING(actor) == motivator) {
         act("You rode $N right into $p!", FALSE, actor, wall, motivator, TO_CHAR);
         act("Bump!  $n rides $N into $p.", FALSE, actor, wall, motivator, TO_ROOM);

      /* Just your standard walk-into-a-wall. */
      } else {
         act("Oof.  You bump into $p.", FALSE, actor, wall, 0, TO_CHAR);
         act("$n bumps into $p.", FALSE, actor, wall, 0, TO_ROOM);
      }
      return TRUE;
   }
   return FALSE;
}

/* Returns TRUE if you ran into a wall. */
bool wall_charge_check(struct char_data *ch, int dir)
{
   struct obj_data *wall;
   int dam, chance;

   if ((wall = find_wall_dir(ch->in_room, dir)) == NULL)
      return FALSE;

   /* Found a wall for you to run into! */

   /* If walls were being damaged, this one should get hurt now.
    * It might also show visible cracking or even be destroyed. */

   act("You CHARGE at $p&0 and crash right into it!", FALSE, ch, wall, 0, TO_CHAR);
   act("$n &0CHARGES at $p&0 and crashes into it headfirst!", FALSE, ch, wall, 0, TO_ROOM);

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      /* You're going to get hurt... */

      chance = number(0, 101);
      dam = ((chance / 10) * (GET_LEVEL(ch) / 10)) + GET_LEVEL(ch);
      /* But you won't die... */
      if (GET_HIT(ch) - dam < -5)
          dam = GET_HIT(ch) + 5;
      hurt_char(ch, NULL, dam, TRUE);
      /* You fell to a sitting position (unless you were knocked out) */
      if (GET_POS(ch) >= POS_STANDING)
         alter_pos(ch, POS_SITTING, STANCE_ALERT);
      WAIT_STATE(ch, PULSE_VIOLENCE * 3);
   }

   /* Would like to send messages to the other room that the wall's in, but
    * we'd have to check each person to see if they were awake, can see the
    * wall, ... maybe send a message about sound if they can't see but are
    * awake, etc. */

   return TRUE;
}

int get_fireshield_damage(struct char_data *attacker, struct char_data *victim, int dam)
{
   if (EFF_FLAGGED(attacker, EFF_MAJOR_GLOBE))
      act ("&1&bThe globe around your body absorbs the burning flames!&0",
         FALSE, attacker, 0, 0, TO_CHAR);
   else {
      int amount = MIN((GET_LEVEL(victim) / 2 +
            number(1, GET_LEVEL(victim) / 10)),
            dam / 3 + number(1, 1 + GET_LEVEL(victim) / 10));
      amount = dam_suscept_adjust(victim, attacker, NULL, amount, DAM_FIRE);
      if (amount > 0) {
         act("&1Your limbs are seared by $N&0&1's shield of flames.&0 (&1&8$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_CHAR);
         act("&1$n&0&1's limbs are seared by your shield of flames.&0 (&3$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_VICT);
         act("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0 (&4$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_NOTVICT);
      }
      return amount;
   }

   return 0;
}

int get_coldshield_damage(struct char_data *attacker, struct char_data *victim, int dam)
{
   if (EFF_FLAGGED(attacker, EFF_MAJOR_GLOBE))
      act("&4&bThe globe around your body absorbs the killing ice!&0",
            FALSE, attacker, 0, 0, TO_CHAR);
   else {
      int amount = MIN((GET_LEVEL(victim) / 2 +
            number(1, 1 + GET_LEVEL(victim) / 10)),
            dam / 3 + number(1, 1 + GET_LEVEL(victim) / 10));
      amount = dam_suscept_adjust(victim, attacker, NULL, amount, DAM_COLD);
      if (amount > 0) {
         act("&4You are impaled on $N&0&4's shield of ice.&0 (&1&8$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_CHAR);
         act("&4$n&0&4 is impaled on your shield of ice.&0 (&3$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_VICT);
         act("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0 (&4$i&0)",
               FALSE, attacker, (void *) amount, victim, TO_NOTVICT);
      }
      return amount;
   }

   return 0;
}

int get_soulshield_damage(struct char_data *attacker, struct char_data *victim, int dam)
{
   if (
         (IS_GOOD(attacker) && IS_EVIL(victim))
         ||
         (IS_EVIL(attacker) && IS_GOOD(victim))
      ) {
      int amount = MIN(2 * GET_LEVEL(victim) / 5 +
            number(1, 1 + GET_LEVEL(victim) / 10),
            3 * dam / 16 + number(1, 1 + GET_LEVEL(victim) / 10));
      amount = dam_suscept_adjust(victim, attacker, NULL, amount, DAM_ALIGN);
      if (amount > 0) {
         act("&7&b$n's soul suffers upon contact with your aura.&0 (&3$i&0)",
               TRUE, attacker, (void *) amount, victim, TO_VICT);
         act("&7&bYour soul suffers upon contact with $N's aura.&0 (&1&8$i&0)",
               TRUE, attacker, (void *) amount, victim, TO_CHAR);
         act("&7&b$n's soul suffers upon contact with $N's aura.&0 (&4$i&0)",
               TRUE, attacker, (void *) amount, victim, TO_NOTVICT);
      }
      return amount;
   }

   return 0;
}

int defensive_spell_damage(struct char_data *attacker, struct char_data *victim, int dam)
{
   int shdam = 0;

   if (EFF_FLAGGED(victim, EFF_FIRESHIELD))
      shdam += get_fireshield_damage(attacker, victim, dam);
   if (EFF_FLAGGED(victim, EFF_COLDSHIELD))
      shdam += get_coldshield_damage(attacker, victim, dam);
   if (EFF_FLAGGED(victim, EFF_SOULSHIELD))
      shdam += get_soulshield_damage(attacker, victim, dam);

   return shdam;
}

/***************************************************************************
 * $Log: magic.c,v $
 * Revision 1.296  2010/06/05 18:58:47  mud
 * Rebalance pyre self damage.
 *
 * Revision 1.295  2010/06/05 18:35:47  mud
 * Make pyre auto-target caster if sacrificial preference is
 * toggled on.
 *
 * Revision 1.294  2010/06/05 05:29:00  mud
 * Typo in full heal message.
 *
 * Revision 1.293  2010/06/05 04:43:57  mud
 * Replacing ocean sector type with cave.
 *
 * Revision 1.292  2009/08/02 20:19:58  myc
 * Adding pyre and fracture spells.
 *
 * Revision 1.291  2009/07/18 01:17:23  myc
 * Adding decay, iron maiden, spinechiller, and bone draw spells
 * for necromancer.
 *
 * Revision 1.290  2009/07/17 06:05:35  myc
 * Make waterwalk last a long time.
 *
 * Revision 1.289  2009/07/04 16:23:13  myc
 * Soulshield, holy word, and unholy word now use regular alignment
 * checks instead of arbitrary 500 and -500 values.
 *
 * Revision 1.288  2009/06/10 18:50:40  myc
 * Reduce the amount of damage breath attacks do.
 *
 * Revision 1.287  2009/06/09 05:43:38  myc
 * Changing a printf to a real log call.
 *
 * Revision 1.286  2009/05/19 19:36:52  myc
 * Fix typo in chain lightning.
 *
 * Revision 1.285  2009/03/21 06:32:37  jps
 * Make phosphoric embers manual spell
 *
 * Revision 1.284  2009/03/20 06:08:18  myc
 * Adding detonation, phosphoric embers, positive field, and acid
 * burst and single-target offensive pyromancer spells.  Increased
 * melt's power vs metal, stone, and ice.  Made soul tap a damage-
 * over-time version of energy drain.
 *
 * Revision 1.283  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.282  2009/03/15 22:31:24  jps
 * Make cold/fire/soulshield damage adjust for susceptibility
 *
 * Revision 1.281  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.280  2009/03/09 16:57:47  myc
 * Added detect poison effect.
 *
 * Revision 1.279  2009/03/09 04:50:38  myc
 * Fix typo (missing newline) in divine essence.
 *
 * Revision 1.278  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.277  2009/03/09 03:26:34  jps
 * Moved individual spell definitions to spell.c and spell.h.
 *
 * Revision 1.276  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.275  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.274  2009/03/07 22:31:20  jps
 * Make the victim's set-on-fire message go to the victim's room with
 * the TO_VICTROOM act flag, since the perpetrator might be in another room.
 *
 * Revision 1.273  2009/03/07 20:46:28  jps
 * Add bold to messages colored with &9 - they can be invisible otherwise
 *
 * Revision 1.272  2009/03/07 11:24:26  jps
 * Fix wall of fog spell.
 *
 * Revision 1.271  2009/03/03 19:43:44  myc
 * Always apply group spells to the caster last so spells like
 * group recall still work.
 *
 * Revision 1.270  2009/02/04 20:03:56  myc
 * Disallow guard skill if it would result in PK.
 *
 * Revision 1.269  2009/01/19 09:25:23  myc
 * Removed MOB_PET flag.
 *
 * Revision 1.268  2009/01/19 08:42:29  myc
 * Add damage numbers to coldshield/fireshield/soulshield.
 *
 * Revision 1.267  2009/01/18 06:52:37  myc
 * Fix typo (capitalize a sentence in act()).
 *
 * Revision 1.266  2008/11/09 03:47:57  myc
 * Cut duration on poison and ray of enfeeblement.
 *
 * Revision 1.265  2008/09/29 00:03:13  jps
 * Moved weight_change_object to objects.c/h.
 *
 * Revision 1.264  2008/09/21 21:04:20  jps
 * Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
 *
 * Revision 1.263  2008/09/21 20:46:36  jps
 * Removing unused variable
 *
 * Revision 1.262  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.261  2008/09/20 17:39:12  jps
 * Fix typos in bone armor messages.
 *
 * Revision 1.260  2008/09/20 17:23:20  jps
 * Fix rigidity check with certain spells.
 *
 * Revision 1.259  2008/09/20 07:27:45  jps
 * set_fighting takes a 3rd parameter, reciprocate, which will set the attackee fighting
 * the attacker if true.
 *
 * Revision 1.258  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.257  2008/09/16 17:06:32  rsd
 * Made the damage bonus based on class for firestorm the
 * class of pyromancer instead of cryomancer..
 *
 * Revision 1.256  2008/09/14 04:41:41  jps
 * Don't allow mortal spells to affect imms.
 *
 * Revision 1.255  2008/09/14 04:34:30  jps
 * Set folks fighting even if the initial attack was completely ineffective.
 *
 * Revision 1.254  2008/09/14 04:09:24  jps
 * Take certain act flags off summoned mobs, such as peaceful and protector.
 *
 * Revision 1.253  2008/09/14 02:22:53  jps
 * Expand the suitability-for-fluid-chars check to be used for all mag_effect spells.
 *
 * Revision 1.252  2008/09/14 02:08:01  jps
 * Use standardized area attack targetting
 *
 * Revision 1.251  2008/09/13 18:52:20  jps
 * Removing unused variables
 *
 * Revision 1.250  2008/09/13 18:05:29  jps
 * Added functions to remove spells from characters when necessary.
 *
 * Revision 1.249  2008/09/13 16:03:53  jps
 * Fix check_armor_spells
 *
 * Revision 1.248  2008/09/12 20:16:49  jps
 * Make it impossible to cast certain armor spells onto characters who are in a fluid state.
 *
 * Revision 1.247  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.246  2008/09/07 01:28:17  jps
 * Don't automatically start flying if your load is too heavy.
 *
 * Revision 1.245  2008/09/05 21:52:56  myc
 * Fix typo in elemental warding.
 *
 * Revision 1.244  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.243  2008/09/02 07:19:56  jps
 * Using limits.h.
 *
 * Revision 1.242  2008/09/02 07:16:39  jps
 * Changing object TIMER to DECOMP where appropriate.
 *
 * Revision 1.241  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.240  2008/08/31 06:51:00  myc
 * Reverse sign on modifiers for APPLY_AC so they follow the same scheme as
 * AC applies on equipment.
 *
 * Revision 1.239  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.238  2008/08/29 16:55:00  myc
 * Fixed messages for many self-only spells so they make sense even if
 * cast on someone else.
 *
 * Revision 1.237  2008/08/28 21:50:05  jps
 * Prevent "create spring" from working in watery or air rooms.
 *
 * Revision 1.236  2008/08/26 04:39:21  jps
 * Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
 *
 * Revision 1.235  2008/08/26 02:29:11  jps
 * Change phantasm mob list
 *
 * Revision 1.234  2008/08/24 03:15:57  myc
 * Make evades_spell absolutely fail when the skill's damage type
 * is 'undefined', not 'slashing'.
 *
 * Revision 1.233  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.232  2008/08/17 20:24:45  jps
 * Add wall_charge_check, for doorbash toward a wall.
 *
 * Revision 1.231  2008/08/17 06:39:47  jps
 * Fix grammar of cloak of gaia.
 *
 * Revision 1.230  2008/08/10 19:34:37  jps
 * Calibrated sorcerer_single_target spells to the level at which the spell
 * was assigned to the caster.
 *
 * Revision 1.229  2008/08/10 01:58:49  jps
 * Added spells severance and soul reaver for illusionists.
 *
 * Revision 1.228  2008/08/09 20:35:57  jps
 * Changed sense life so that it has a chance of detecting the presence and movement
 * of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
 *
 * Revision 1.227  2008/08/03 19:31:44  myc
 * Fixing heatwave/cone of cold.
 *
 * Revision 1.226  2008/06/21 07:04:21  jps
 * Don't allow setting-on-fire of folks with a low susceptibility to fire damage.
 *
 * Revision 1.225  2008/06/13 18:43:29  jps
 * Handle spell evasion differently for dispel magic, since it has other
 * purposes then simply doing harm.
 *
 * Revision 1.224  2008/06/11 22:24:43  jps
 * Cancel spellcasting when you become "frozen up" due to cold attacks.
 *
 * Revision 1.223  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.222  2008/06/05 02:07:43  myc
 * Changed object flags to use flagvectors.
 *
 * Revision 1.221  2008/05/19 06:16:40  jps
 * Only mesmerize players for 2 hours.
 * Stop people who are fighting someone who gets mesmerized.
 *
 * Revision 1.220  2008/05/19 05:49:08  jps
 * Add mesmerize to mag_affect.
 *
 * Revision 1.219  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.218  2008/05/18 17:58:49  jps
 * Adding familiarity to mag_affect.
 *
 * Revision 1.217  2008/05/18 04:40:59  jps
 * Make is to people without detect invis can identify the
 * object that's being made invisible.
 *
 * Revision 1.216  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.215  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.214  2008/05/14 05:11:10  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.213  2008/05/12 04:47:36  jps
 * Require evilness to cast dark presence, and goodness to cast bless.
 *
 * Revision 1.212  2008/05/12 04:41:59  jps
 * Make discorporate destroy illusory mobs.
 *
 * Revision 1.211  2008/05/12 00:43:48  jps
 * Add nightmare and discorporate spells to mag_damage.
 *
 * Revision 1.210  2008/05/11 07:11:53  jps
 * Calling active_effect_remove so as to standardize what happens when
 * an effect goes away.
 *
 * Revision 1.209  2008/05/11 06:13:31  jps
 * Adding defensive_spell_damage(), which calculates damage to attackers
 * due to spells like fireshield, and sends messages.
 *
 * Revision 1.208  2008/05/11 05:50:15  jps
 * alter_hit() now takes the killer.
 *
 * Revision 1.207  2008/04/20 04:42:24  jps
 * Don't send dodging messages when you resist the long-term
 * effects of gas breath.
 *
 * Revision 1.206  2008/04/19 21:22:06  myc
 * Missing break in mag_damage.
 *
 * Revision 1.205  2008/04/14 08:36:53  jps
 * Updated call to ASPELL, since it now includes the spell number.
 *
 * Revision 1.204  2008/04/14 05:11:40  jps
 * Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
 * to fly - not that the characer is actually flying.
 *
 * Revision 1.203  2008/04/14 02:17:45  jps
 * Adding glory to mag_affect().
 *
 * Revision 1.202  2008/04/13 19:38:17  jps
 * Reduced the length of confusion.
 *
 * Revision 1.201  2008/04/13 18:44:42  jps
 * Fix confusion-application message.
 *
 * Revision 1.200  2008/04/13 18:30:14  jps
 * Add confusion spell to mag_affect().
 *
 * Revision 1.199  2008/04/12 21:29:39  jps
 * Adding special case to evades_spell for dispel magic.
 *
 * Revision 1.198  2008/04/12 21:13:18  jps
 * Using new header file magic.h.
 *
 * Revision 1.197  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.196  2008/04/06 04:58:31  jps
 * Change catching-on-fire and freezing-up to use susceptibility.
 *
 * Revision 1.195  2008/04/05 17:10:57  jps
 * Fix message formatting for enlarge/reduce spells.
 *
 * Revision 1.194  2008/04/05 16:32:24  jps
 * Better feedback for spells that fail to inflict any damage, except that
 * dispel magic won't cause such a message.
 *
 * Revision 1.193  2008/04/05 04:50:39  jps
 * Except MAG_MANUAL spells from boolean spell evasion.
 *
 * Revision 1.192  2008/04/04 21:32:42  jps
 * Un-break area attack spells.
 *
 * Revision 1.191  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.
 *
 * Revision 1.190  2008/03/29 16:28:10  jps
 * Update evades_spell() to use power, and to check differently if the spell
 * is one that doesn't do damage.
 *
 * Revision 1.189  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.188  2008/03/27 17:40:52  jps
 * Don't allow blessing evil characters.  Lengthen the duration
 * of bless and dark presence to 10-24 hours.
 *
 * Revision 1.187  2008/03/27 17:30:17  jps
 * Dark presence now sets AFF3_HEX. It also places it on objects.
 * A hexed weapon will become !GOOD and a blessed weapon will
 * become !EVIL.
 *
 * Revision 1.186  2008/03/26 23:12:19  jps
 * Changed the waterform and vaporform spells to change your composition
 * rather than setting flags.
 *
 * Revision 1.185  2008/03/26 22:01:10  jps
 * Adding mag_damage for dispel magic, like a 3rd circle spell.
 *
 * Revision 1.184  2008/03/26 19:16:17  jps
 * Fix susceptibility check - the VICTIM not the attacker!
 * Also move damage reduction past harness check so that all of
 * the damage is subject to reduction.
 *
 * Revision 1.183  2008/03/26 19:09:27  jps
 * Change the bless spell so that it's very picky about what can
 * be blessed. Essentially, it has to be devoid of enchantments
 * and be rather plain. It can't be !GOOD or too high level
 * compared to the casting power.
 *
 * Revision 1.182  2008/03/26 18:15:59  jps
 * Adding a BLESS effect to a creature who gets bless cast on it.
 *
 * Revision 1.181  2008/03/26 16:44:36  jps
 * Replaced all checks for undead race with checks for undead lifeforce.
 * Replaced the undead race with the plant race.
 *
 * Revision 1.180  2008/03/24 08:42:04  jps
 * Removing protected_from_spell() and immune_from_spell().
 * Changing the way undead servants are generated, since the race
 * of undead is soon to be no more.
 * Taking into account composition-susceptibility to magical
 * damage.
 *
 * Revision 1.179  2008/03/23 18:42:39  jps
 * Using the new damage types defined in chars.h.
 *
 * Revision 1.178  2008/03/22 16:42:45  jps
 * Fix to_room messages for dark presence.
 *
 * Revision 1.177  2008/03/22 16:27:57  jps
 * Correctly copy sizes in duplicate_char.
 * Phantasms will copy the *current* size of a model (if any), disregarding
 * the fact that the model might have had its size modified by magic.
 * Phantasms will be neutral, because they have no souls and cannot be
 * good or evil.
 *
 * Revision 1.176  2008/03/11 02:53:09  jps
 * Update duplicate_char for size-tracking variables.
 *
 * Revision 1.175  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.174  2008/03/09 18:14:25  jps
 * Add spell effects for misdirection spell.
 *
 * Revision 1.173  2008/03/09 08:59:25  jps
 * Remove fear from mag_affects.
 *
 * Revision 1.172  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.171  2008/03/09 04:02:08  jps
 * Fix up mob summoning and phantasms a lot. Player phantasms don't work
 * quite right yet.
 *
 * Revision 1.170  2008/02/23 01:03:54  myc
 * Removed the lowest_circle in the skillinfo struct.  Use lowest_level
 * instead.
 *
 * Revision 1.169  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.  And instead of creating
 * an event obj for extract events, we'll just pass the victim in.
 *
 * Revision 1.168  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.167  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.166  2008/01/29 16:51:12  myc
 * Moving skill names to the skilldef struct.
 *
 * Revision 1.165  2008/01/28 02:39:01  jps
 * Use extract event for exorcisms.
 *
 * Revision 1.164  2008/01/27 21:14:59  myc
 * Replace hit() with attack().  Adding berserker chants.
 *
 * Revision 1.163  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.162  2008/01/27 12:12:55  jps
 * Changed IS_THIEF macro to IS_ROGUE.
 *
 * Revision 1.161  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.160  2008/01/27 02:37:03  jps
 * Lower breath damage a bit.
 *
 * Revision 1.159  2008/01/27 00:18:12  jps
 * Make breath damage appropriate to the level of the mob. No more level
 * 3 demons doing 300 damage!!!
 *
 * Revision 1.158  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.157  2008/01/26 12:33:18  jps
 * Use skills.h to import improve_skill().
 *
 * Revision 1.156  2008/01/25 11:54:29  jps
 * Add a newline to the long description of raised undead creatures.
 *
 * Revision 1.155  2008/01/25 11:47:22  jps
 * Fix grammar in negate heat spell message.
 *
 * Revision 1.154  2008/01/24 15:45:09  myc
 * Fixed a typo in magic.c
 *
 * Revision 1.153  2008/01/15 03:26:00  myc
 * Fixing a typo in sleep spell.
 *
 * Revision 1.152  2008/01/14 18:52:52  myc
 * Auto-set the violent flag on a spell if the spell has the
 * MAG_DAMAGE routine.  Fix soul tap to not assign the effect
 * if the attack cannot occur.  Fix evades_spell to only go
 * off for violent spells.
 *
 * Revision 1.151  2008/01/13 23:06:04  myc
 * Changed the skills struct to store lowest_level and lowest_circle
 * data for each spell, thus making it unnecessary to calculate the
 * minimum spell circle for a spell everytime it goes through the
 * evades_spell function.
 *
 * Revision 1.150  2008/01/13 03:19:53  myc
 * Fixed a bug in check_guard.  Split check_armor_spells into
 * check_armor_spells and affected_by_armor_spells.
 *
 * Revision 1.149  2008/01/12 23:13:20  myc
 * Renamed clearMemory clear_memory.
 *
 * Revision 1.148  2008/01/11 17:34:32  myc
 * Fixing a typo in sanctuary spell message.
 *
 * Revision 1.147  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.146  2008/01/07 11:56:45  jps
 * Make sure illusory mobs have no cash. Don't use puff for player
 * template, as she has a spec proc. Make sure player illusions
 * are not sentinel. Set their long desc (not that it's likely
 * to be seen).
 *
 * Revision 1.145  2008/01/07 10:37:19  jps
 * Change spell name "project" to "phantasm". Allow simulacrom to
 * make copies of players.
 *
 * Revision 1.144  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.143  2008/01/06 20:38:00  jps
 * Remove unused saving throw tables.
 *
 * Revision 1.142  2008/01/05 05:44:19  jps
 * Using update_char() for created mobs.
 *
 * Revision 1.141  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.140  2008/01/01 07:32:56  jps
 * Made cold-spell freeze-ups into an event so that it can set
 * paralysis which won't be removed immediately after it is set.
 *
 * Revision 1.139  2008/01/01 05:08:34  jps
 * Stop area spells from harming things it shouldn't.
 *
 * Revision 1.138  2007/12/26 08:08:09  jps
 * Fix formatting of caster's feedback for "conceal".
 *
 * Revision 1.137  2007/11/28 10:19:39  jps
 * Reduce damage from low-level NPC sorcerers.
 *
 * Revision 1.136  2007/11/20 20:08:15  myc
 * Fixing more spells that weren't using online damage.
 *
 * Revision 1.135  2007/11/18 16:51:55  myc
 * Making mag_masses not hit your own pet.  Fixing some damage spells that
 * were doing less damage because they weren't using online damage.
 *
 * Revision 1.134  2007/10/27 21:49:34  myc
 * Fixed a bug in mass invis
 *
 * Revision 1.133  2007/10/27 18:56:18  myc
 * Typo in disease spell.
 *
 * Revision 1.132  2007/10/27 03:19:24  myc
 * Fixed a bug with war cry spewing garbage messages.
 *
 * Revision 1.131  2007/10/13 05:18:11  myc
 * Whoa immolate hits 5 times, and was doing insane damage with the new
 * sorcerer spell damage calculations.
 * Now it's not.
 *
 * Revision 1.130  2007/10/13 05:07:24  myc
 * Added new monk chants.
 *
 * Revision 1.129  2007/10/11 20:14:48  myc
 * Monk chants are now implemented as magic spells, and use spell wearoffs
 * instead of song wearoffs.  Removed the spell wearoff messages array;
 * spell wearoff messages are now defined for each spell in the spello
 * call in spell_parser.c
 *
 * Revision 1.128  2007/10/04 16:20:24  myc
 * Replaced magic_wall_destruction with destroy_opposite_wall, which calls
 * decay_object in limits.c to actually decay the object.
 *
 * Revision 1.127  2007/10/02 02:52:27  myc
 * A player casting mag_damage spells at another player will no longer
 * improve in skill.  Sense life applies the bit instead of a perception
 * bonus again.  (The perception is dynamically computed in db.c in
 * update_stats.)
 *
 * Revision 1.126  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Concealment now gives you hide
 * points, sense life gives you perception, natures embrance gives
 * you hide points and camo, and made mag_points support hide points.
 *
 * Revision 1.125  2007/09/20 09:48:06  jps
 * Don't allow energy draining of undead.
 *
 * Revision 1.124  2007/09/20 09:16:32  jps
 * Improve grammer in lights-on-fire message
 *
 * Revision 1.123  2007/09/15 15:36:48  myc
 * Nature's embrace now sets camouflage bit, which lets you be hidden as
 * long as you are outside.  Cleaned up affect-handling code a lot.  It
 * didn't properly handle bitvectors 1, 2, and 3.  Now it does.
 * Invigorate is now a group spell.
 *
 * Revision 1.122  2007/09/15 05:03:46  myc
 * Implementing MOB2_NOPOISON flag.
 *
 * Revision 1.121  2007/09/11 16:34:24  myc
 * Added electrify skill for use by druid's electric eel.
 *
 * Revision 1.120  2007/09/09 01:20:14  jps
 * The result of casting a spell is no longer just TRUE or FALSE,
 * but two possible bits combined: charge and/or improve. If
 * CAST_RESULT_CHARGE is returned, the spell was used and the caster
 * will be charged (have the spell erased from memory).  If
 * CAST_RESULT_IMPROVE is returned, the caster may improve in that
 * sphere of magic.
 * At the same time, casters will now correctly be charged for
 * spells that are cast on objects.
 *
 * Revision 1.119  2007/09/07 01:37:09  jps
 * Standardized the damage done by single-target sorcery spells.
 *
 * Revision 1.118  2007/09/04 06:49:19  myc
 * Changed spells that cannot be cast indoors to use the new TAR_OUTDOORS
 * bit, meaning the character's spell memory won't be charged when they
 * cast such a spell indoors.  (The check comes at command-interpretation
 * time.)
 *
 * Revision 1.117  2007/09/03 23:49:40  jps
 * Add mass_attack_ok() so that you could kill your own pet specifically,
 * but your area spells will not harm it.
 *
 * Revision 1.116  2007/09/03 21:21:17  jps
 * Magic wall updates: seen when looking in a direction; will block movement
 * sensibly, taking into account mounts; wall of ice can be used to douse
 * your flames; expiration message varies depending on what kind of
 * magic wall it is.
 *
 * Revision 1.115  2007/09/02 22:54:55  jps
 * Minor typo fixes.
 *
 * Revision 1.114  2007/08/30 08:51:25  jps
 * Generalize spell evasion (globe, elemental immunity, immortal) to area spells.
 *
 * Revision 1.113  2007/08/29 01:22:18  jps
 * Check for null target in check_guard.
 *
 * Revision 1.112  2007/08/28 20:17:29  myc
 * Gods won't catch on fire anymore.  The caster of an affection spell will
 * now see the to_room message if there is no to_char message and the caster
 * is not the victim.
 *
 * Revision 1.111  2007/08/26 21:49:10  jps
 * Don't say that someone stops chanting if they've been knocked out
 * or killed.
 *
 * Revision 1.110  2007/08/26 21:10:27  jps
 * Provide a caster feedback message for the poison spell.
 *
 * Revision 1.109  2007/08/26 19:51:43  jps
 * Fix ray of enfeeblement resisted-spell message.
 *
 * Revision 1.108  2007/08/26 01:55:41  myc
 * Fire now does real damage.  All fire spells have a chance to catch the
 * victim on fire.  Mobs attempt to douse themselves.
 *
 * Revision 1.107  2007/08/23 00:32:24  jps
 * All four elemental immunities are in effect. An elemental
 * resistance (such as PROT-FIRE) will mean 12.5% extra damage
 * from the opposing element (fire-water, air-earth). An elemental
 * immunity will cause 25% extra damage from the opposing element.
 *
 * Revision 1.106  2007/08/15 20:47:06  myc
 * Fly will now only automatically set you to POS_FLYING if you are awake.
 *
 * Revision 1.105  2007/08/03 22:00:11  myc
 * Fixed some \r\n typoes in send_to_chars.
 *
 * Revision 1.104  2007/08/03 03:51:44  myc
 * check_pk is now attack_ok, and covers many more cases than before,
 * including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
 * offensive attacks now use attack_ok to determine whether an attack is
 * allowed.
 *
 * Revision 1.103  2007/08/02 04:19:32  jps
 * Added "moonbeam" spell for Druids.
 * Stop people from fighting when they become paralyzed.
 *
 * Revision 1.102  2007/08/02 01:04:10  myc
 * check_pk() now works for all PK cases.  Moved from magic.c to fight.c
 *
 * Revision 1.101  2007/08/02 00:23:53  myc
 * Standardized magic check-PK function.  Cut out a LOT of unnecessary magic
 * code and cleaned up the whole system in general.  Magic casts are now
 * guaranteed to use sphere skills rather than level.  Almost all magic
 * functions like mag_damage or even manual spells return a boolean now:
 * TRUE if the cast deserves a skill improvement, FALSE if it doesn't.
 * This return value is ignored for object magic (wands, etc.).
 *
 * Revision 1.100  2007/07/25 00:38:03  jps
 * Earthquake will send a message about shaking to the entire zone.
 *
 * Revision 1.99  2007/07/19 15:05:34  jps
 * Minor typo fixes
 *
 * Revision 1.98  2007/07/15 17:16:12  jps
 * Add IS_POISONED macro.
 *
 * Revision 1.97  2007/07/04 02:21:58  myc
 * Removing coldshield affect from ice armor spell.  Increased duration on
 * magic torch and circle of light.  Renamed douse spell to extinguish.
 *
 * Revision 1.96  2007/06/24 22:45:31  myc
 * Making chill touch improve skill always instead of sometimes.
 *
 * Revision 1.95  2007/06/16 00:15:49  myc
 * Three spells for necromancers: soul tap, rebuke undead,
 * and degeneration.  One spell for rangers: natures guidance.
 *
 * Revision 1.94  2007/05/24 06:06:16  jps
 * Stop sending 'Nothing seems to happen.' when full heal is cast.
 *
 * Revision 1.93  2007/05/12 21:59:07  myc
 * Fixed the bug where random constants were sent_to_char when skill
 * affections wore off.
 *
 * Revision 1.92  2007/05/12 20:02:03  myc
 * Demonic aspect and mutation shouldn't stack.
 *
 * Revision 1.91  2007/05/11 21:03:12  myc
 * New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
 * complicated skill.  :P  Fixed cure blind's logic, and made it support
 * eye gouge too.
 *
 * Revision 1.90  2007/05/11 20:13:28  myc
 * Vaporform is a new circle 13 spell for cryomancers.  It significantly
 * increases the caster's chance of dodging a hit.  It is a quest spell.
 *
 * Revision 1.89  2007/04/26 03:57:09  myc
 * Got rid of sunray's double skill improvement haxness.
 *
 * Revision 1.88  2007/04/25 07:18:05  jps
 * Fix feedback for casting bless/dark presence on one who is already
 * oppositely blessed.  Make bless impossible if you have any of several
 * evil spells on you.  Make batwings/wings of heaven exclusive.
 *
 * Revision 1.87  2007/04/19 07:03:14  myc
 * Renamed RAY_OF_ENFEB as RAY_OF_ENFEEB.  Implemented demonic mutation
 * as a more powerful version of demonic aspect.  Made it so players
 * can cast offensive affection spells on themselves.
 *
 * Revision 1.86  2007/04/19 00:53:54  jps
 * Create macros for stopping spellcasting, and terminate spellcasting
 * when you become paralyzed.
 *
 * Revision 1.85  2007/04/17 23:58:43  jps
 * Stop sending extra message to caster when writhing weeds fails due to being cast outside.
 *
 * Revision 1.84  2007/04/17 23:38:03  myc
 * Introducing the new improved color spray!  It's now an area spell that
 * causes various effects based on caster skill.
 *
 * Revision 1.83  2007/04/11 14:26:06  jps
 * Spell of nourishment will only work in certain terrains.
 *
 * Revision 1.82  2007/03/27 04:27:05  myc
 * Harness from 2% to 1% extra damage per level.  Forgot a check in ice armor
 * for coldshield last time.  Group heal has the same effects as heal (curing
 * blindness).  Permastoned mobs twitch faster.  Cure blind cures sunray.
 *
 * Revision 1.81  2007/02/20 17:16:27  myc
 * Consolidated armor spell checks into check_armor_spells() function, which
 * is called at the beginning of all armor spells.  Changed success rates for
 * entangle, minor paralysis, and sleep.  Cleaned up entangle spell a bit.
 * Sleep spell checks for shapeshifted players.
 *
 * Revision 1.80  2007/02/14 03:54:53  myc
 * Save applies now make a difference.  Reduced damage exorcism causes to caster.
 * Fixed bug with improving skill preventing other unrelated things from occuring.
 * Ice armor now has coldshield affect.  Entangle, minor paralysis, and sleep
 * no longer make the mob attack for successes.  Added combust and cremate spells.
 *
 * Revision 1.79  2007/02/08 01:30:00  myc
 * Circle of fire does damage based on level now.
 *
 * Revision 1.78  2006/12/19 04:36:53  dce
 * Modified Supernova to mimic Ice Shards.
 *
 * Revision 1.77  2006/11/20 22:24:17  jps
 * End the difficulties in interaction between evil and good player races.
 *
 * Revision 1.76  2006/11/20 19:52:04  jps
 * Levitate halves earthquake damage.  Fixed feedback messages when
 * casting levitate and ray of enfeeblement.
 *
 * Revision 1.75  2006/11/18 07:03:30  jps
 * Minor typo fixes
 *
 * Revision 1.74  2006/11/18 04:26:32  jps
 * Renamed continual light spell to illumination, and it only works on
 * LIGHT items (still rooms too).
 *
 * Revision 1.73  2006/11/17 22:52:59  jps
 * Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
 *
 * Revision 1.72  2006/11/14 18:54:02  jps
 * Fly spell now produces feedback to caster when cast on someone else.
 *
 * Revision 1.71  2006/11/13 19:24:00  jps
 * "animate dead" is in sphere of death, and improves.
 *
 * Revision 1.70  2006/11/13 18:33:58  jps
 * Fix major/minor globe interaction, and add feedback for the caster.
 *
 * Revision 1.69  2006/11/13 17:51:31  jps
 * Guard will improve normally.  Also there are messages for failed
 * guard attempts.
 *
 * Revision 1.68  2006/11/11 10:11:04  jps
 * Create food now chooses from 50 food objects (10 for each food
 * creating class), based on caster proficiency and luck.
 *
 * Revision 1.67  2006/11/08 09:59:46  jps
 * Added caster feedback message for "protection from evil".
 *
 * Revision 1.66  2006/11/08 09:16:04  jps
 * Fixed some loose-lose typos.
 *
 * Revision 1.65  2006/11/08 08:49:29  jps
 * Fix missing punctuation in missed poison spell message.
 *
 * Revision 1.64  2006/11/08 08:01:14  jps
 * Typo fix "You sprouts roots" -> "You sprout roots"
 *
 * Revision 1.63  2006/11/07 14:09:46  jps
 * If you are silenced in the middle of casting your own spell, that
 * spell fails.
 *
 * Revision 1.62  2006/11/06 17:38:19  jps
 * affect spells cast on self will no longer send two messages to the caster
 *
 * Revision 1.61  2006/07/20 07:34:53  cjd
 * Typo fixes.
 *
 * Revision 1.60  2006/05/30 00:51:18  rls
 * modified poison affects to be a bit more potent
 *
 * Revision 1.59  2004/11/28 06:38:07  rsd
 * Changed the healing multiplies back to half what they were
 * and doubled the number of dice in each healing spell.
 *
 * Revision 1.58  2004/11/19 03:09:58  rsd
 * Doubled healing output for the heal spells again.
 *
 * Revision 1.57  2004/11/13 10:45:48  rls
 * Fixed crashie bug with remove curse scroll... or so it seems.
 *
 * Revision 1.56  2004/10/15 18:33:30  rsd
 * Ok, something odd happened with this, I added a buncha
 * checks to the creation of undead to remove the aggressive
 * flags to prevent necros from killing off players.
 * Bad necro's the odd thing is that I fixed a typo while
 * having the file checed out in another directory and did
 * a make.  It's almost as though it checked in my changes and
 * updated the file on me automatically.  weirdness... .
 *
 * Revision 1.55  2003/08/21 02:36:16  jjl
 * Zzur said to double the healing power.  So I did.
 *
 * Revision 1.54  2003/06/20 15:04:56  rls
 * Capped energy drain at 6x caster's hp... 1 hp gain thereafter.
 *
 * Revision 1.53  2003/06/18 14:57:37  rls
 * Added a boolean to create_undead to check for PC corpses being raised
 * Allowed for PC corpse raising only when PK is enabled
 * Toned down the HP in create_undead to that of 2x the caster.
 *
 * Revision 1.52  2002/10/23 02:55:47  jjl
 * D'oh.  Fixed some test code I had in that was breaking necros.
 *
 * Revision 1.51  2002/10/14 02:16:08  jjl
 * An update to turn vitality into a set of 6 spells, lesser endurance,
 * endurance, greater endurance, vitality, greater vitality, and dragon's
 * health.  Greater endurance is what vitality was.  The rest are scaled
 * appropriately.    The higher end may need scaled down, or may not.
 *
 * Revision 1.50  2002/09/15 04:27:11  jjl
 * Fixed sundry typos in messages, added stone skin wear off message, wings of heaven/hell make you fly now.
 *
 * Revision 1.49  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.48  2002/07/16 23:22:41  rls
 * added in new necro spell, bone armor
 *
 * Revision 1.47  2002/03/27 00:04:19  dce
 * *** empty log message ***
 *
 * Revision 1.45  2002/02/25 12:30:07  rls
 * *** empty log message ***
 *
 * Revision 1.44  2002/02/25 11:18:40  rls
 * Adj to_char msg for AFF_BLIND to ...blinded by you!
 *
 * Revision 1.43  2002/02/18 22:54:15  dce
 * When casting fly, the caster would be the one who's position
 * was set to fly. I changed it to the vicitim. So from
 * GET_POS(ch) to GET_POS(victim).
 *
 * Revision 1.42  2001/12/07 16:11:04  dce
 * Fix the heal spells so you can not get your hp's above max.
 *
 * Revision 1.41  2001/03/07 01:45:18  dce
 * Added checks so that players can not kill shapechanged players and
 * vise versa. Hopefully I didn't miss any...
 *
 * Revision 1.40  2000/11/22 20:35:18  rsd
 * Added back rlog messages from prior to the addition of
 * the $log$ string.
 *
 * Revision 1.39  2000/11/15 18:52:33  rsd
 * Magic users can no longer cast energy drain upon themselves
 * to gain hitpoints..
 *
 * Revision 1.38  2000/11/14 20:11:39  rsd
 * Added a pk check for the -str affect on chill touch.
 *
 * Revision 1.37  2000/10/13 22:26:52  rsd
 * altered the power of chain lightning
 *
 * Revision 1.36  2000/10/05 03:05:08  rsd
 * Altered almost every spell to redo the way skills were
 * accessed in the spells by objects and not casters to
 * use the level of the object to determine power and
 * not allow an object to cause a players proficiency to increase
 * by using its spell.
 *
 * Revision 1.35  2000/09/29 04:16:24  rsd
 * Altered every spell in mag_affects to use the new skill
 * checking code that checks if a player is casting or uses
 * an item spell.  This should restore potions and scrolls
 * et al to normal use.
 *
 * Revision 1.34  2000/09/28 20:37:15  jimmy
 * added fix to mag_affects that checks to see weather a spell is
 * being cast or if it's an affect from an object.  Objects will
 * get their skill based on the level of the object.  I.E pc/npc's
 * who don't have SPELL_ARMOR skill can quaff an armor potion
 * and get affected by an armor spell of the level of the potion.
 * All other mag_XXX functions can be migrated to join suit.
 * jbk
 *
 * Revision 1.33  2000/04/30 18:14:19  rsd
 * bless no longer has an alignement check, it does have a dark
 * presence check though, and dark presence has a bless check.
 *
 * Revision 1.32  2000/04/15 23:12:03  rsd
 * fixed damage algorythm for flood and meteorswarm added
 * iceshards and supernova...
 *
 * Revision 1.31  2000/04/14 00:55:49  rsd
 * altered a few spells
 *
 * Revision 1.30  2000/04/09 22:32:24  rsd
 * altered a buncha act buffers to try to get the spell messaging
 * done properly.  Also altered the order of ch and victim in
 * the catch all buffers for the order changed in the act()'s
 * for mag_affects().
 *
 * Revision 1.29  2000/04/08 08:41:23  rsd
 * altered prayer to have float math to return expected values.
 * altered shocking grasp to actually reference the proper
 * sphere to calculate damage, also made it to the 2nd power
 * instead of the typoed 7th. Changed about a kabillion act()
 * statements to make more sense I hope.
 *
 * Revision 1.28  2000/04/05 06:35:34  rsd
 * added 1 kabillion more spells into the spell system.
 * lalala.
 *
 * Revision 1.27  2000/04/02 02:39:39  rsd
 * changed the to_room act in most spells to be TO_NOTVICT as
 * I think was the intent in most cases.  Also added and
 * integrated the spell system up through all 4th circle
 * spells.
 *
 * Revision 1.26  2000/03/31 23:46:37  rsd
 * integrated more spells into the skill system with improve
 * skill calls. Also comeplted more spells. in mag_damage().
 *
 * Revision 1.25  2000/03/31 00:16:10  rsd
 * added a few variables to mag_damage() to make the use of the
 * spell system doable. Also changed how damage was assigned
 * to be proper for the intent for the first few spells.
 * Note that spells are becomeing significantly more potent,
 * maybe to much so, ptesting will get it figured out. This should
 * get all spells up through 3rd circle into the spell system.
 *
 * Revision 1.24  2000/03/30 05:45:54  rsd
 * added mag_damage spells, all first and second circle spells of all
 * classes are in the spell system now.
 * sync
 *
 * Revision 1.23  2000/03/29 06:29:50  rsd
 * Many mag affects spells had returns out for various reasons.
 * The messages associated with the returns were buffered but
 * never sent by the act()'s at the end of the function. Each
 * buffer for player messaging before a return now has an act
 * assicated with it.  I hope it's done correctly.
 *
 * Revision 1.22  2000/03/27 08:06:06  rsd
 * completed hosing with all the spells in mag_affectc()
 * except stone skin.
 *
 * Revision 1.21  2000/03/26 23:48:37  rsd
 * completed more of the mag_affects() spells.
 *
 * Revision 1.20  2000/03/26 07:21:20  rsd
 * Added an improve_skill() call to every mag_affects() spell case in
 * the switch, each spell has a base improve_skill() call just before
 * the break in their case.  Some have more than one instance of the
 * call............
 * Added appropriate to_vict, to_room, and to_char messages for the
 * first half of spells in mag_affects().
 * Removed the defines for af[0].element that I had put in mag_affects()
 * a few days ago.  I realized that there was af[i].element going on
 * so to just have the defines for af[0] was a bit silly. I removed the
 * use of the defines I had coded for barkskin, dark presence, armor,
 * bless, and demonskin......
 * Added alignment checks and restrictions on Demonskin, Dark Presence,
 * and bless.........
 * Worked though about the first half of the spells in mag_affects()
 * and integrated the spell proficiency system.  This was rather easy
 * compared to the pther mag() type spells as most of the mag_affects()
 * spells have very simple affects to manipulate.  There were a few
 * instances of spells where we want more special things to occur,
 * and some instances of confusion, but it's all commented. I admit
 * some of the things I did were goat sacrificing HACKS that may not
 * work. More work later....
 *
 * Revision 1.19  2000/03/25 21:36:13  rsd
 * Altered to use spell proficiencies:
 * chill touch
 * Barkskin
 * nightvision
 * dark presence
 * Also added a missing skill check for demonskin.
 *
 * Revision 1.18  2000/03/24 23:49:35  rsd
 * Altered bless and demonskin to use the spell prof system.
 *
 * Revision 1.17  2000/03/24 05:24:39  rsd
 * changed armor to use sphere of prot as skill proficiency.
 * Also declared some variables at the beginning of mag_affects()
 * to facilitate the use of skills in spells.
 *
 * Revision 1.16  2000/03/19 20:38:18  rsd
 * added brackes to the if statements of SD_INTERN_DAM and
 * tabbed it out.
 *
 * Revision 1.15  2000/03/18 06:08:38  rsd
 * Changed the overall duration of vitality as well as the ranges
 * at which the durations increase. Put some comments in about what
 * a default duration of 0 means to the players. Added an extern -
 * extern void improve_skill(struct char_data *ch, int skill);
 * This was done so skill improvemts could be called for spell usage
 * like with the ones added for vitality.
 *
 * Revision 1.14  2000/03/05 00:15:34  rsd
 * Er, had a buncha returns though the functioning parts of
 * Dispel good and evil, so it was returning out of mag_damage
 * after it listed the damage hehe silly me.
 *
 * Revision 1.13  2000/03/04 08:32:25  rsd
 * Altered DISPEL_GOOD DISPEL_EVIL and VAMPIRIC_BREATH
 * to be somewhat functional, more so than they were
 * before.  Although the dispells don't seem to call
 * their proper messages.
 * /s
 *
 * Revision 1.12  2000/02/26 02:17:21  rsd
 * Oooook, fixed healing proficiency cheks to actually include the 96
 * percentile by adding a = after the > in >96 grumbmle.
 *
 * Revision 1.11  1999/12/08 21:21:59  jimmy
 * added checks for spell proficiencies all healing spells and vitality.
 *
 * Revision 1.10  1999/11/29 01:32:51  cso
 * made chill touch decrease strength a little more
 *
 * Revision 1.9  1999/11/28 23:41:42  cso
 * affect_update: added check to kill animated mobs when the animate wears off
 * new fn: mod_for_undead_type: modify a mob's stats based on what undead type
 *  it is. used by create_undead
 * new fn: mod_for_lvldiff: modify a mob's stats based on the level difference
 *  between it and the necro that raised it. used by create_undead
 * new fn: create_undead: create an undead mob. used by mag_summons for
 *
 *  animate dead
 * new fn: ch_can_control_mob: check to see if a necro can control the undead
 *  he just raised. used by mag_summons for animate dead
 * removed unused mag_summons_msgs
 * removed unused mag_summon_fail_msgs
 * removed unused defines form MOB_ZOMBIE, MOB_MONSUM_I, etc
 * rewrote mag_summons from scratch
 *
 * Revision 1.8  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.7  1999/03/07 05:01:09  dce
 * Chant finishes and wearoff messages.
 *
 * Revision 1.6  1999/02/13 19:37:12  dce
 * Rewrote Continual Light and Darkness to be manual spells to meet our needs.
 *
 * Revision 1.5  1999/02/11 16:44:23  dce
 * When casting minor creation, light objects come lit.
 *
 * Revision 1.4  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.3  1999/02/10 02:38:58  dce
 * Fixes some of continual light.
 *
 * Revision 1.2  1999/01/31 16:35:11  mud
 * Indented entire file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.296
log
@Rebalance pyre self damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.295 2010/06/05 18:35:47 mud Exp $
d3272 1
a3272 1
      log(buf);
d3877 1
a3877 1
    log(buf);
d4163 1
a4163 1
    log(buf);
d4232 1
a4232 1
    log(buf);
d4707 3
@


1.295
log
@Make pyre auto-target caster if sacrificial preference is
toggled on.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.294 2010/06/05 05:29:00 mud Exp mud $
d622 1
a622 3
        dam = sorcerer_single_target(ch, spellnum, skill) / 6;
        if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
           dam *= 2;
d4707 4
@


1.294
log
@Typo in full heal message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.293 2010/06/05 04:43:57 mud Exp mud $
a616 5
        /* Hack to use a different damage message for pyre self-damage */
        if (ch == victim || ch == victim->master) {
          dam /= 2;
          damage_spellnum = SPELL_ON_FIRE;
        }
d618 9
a626 1
          dam *= 2;
d4709 3
@


1.293
log
@Replacing ocean sector type with cave.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.292 2009/08/02 20:19:58 myc Exp mud $
d3715 1
a3715 1
    send_to_char("&7You been FULLY healed!&0\r\n", victim);
d4706 3
@


1.292
log
@Adding pyre and fracture spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.291 2009/07/18 01:17:23 myc Exp myc $
a2873 1
      case SECT_OCEAN:
a3752 1
               case SECT_OCEAN:
a4214 1
       SECT(ch->in_room) == SECT_OCEAN ||
d4706 3
@


1.291
log
@Adding decay, iron maiden, spinechiller, and bone draw spells
for necromancer.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.290 2009/07/17 06:05:35 myc Exp myc $
d478 1
d610 1
a610 1
        /* Phosphoric embers hits 4 times. */
d614 22
d1036 1
a1036 1
  damage(ch, victim, dam, spellnum);
d4709 4
@


1.290
log
@Make waterwalk last a long time.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.289 2009/07/04 16:23:13 myc Exp myc $
d239 5
a243 4
/*Decrease modifier is used to decrease stone_skins modifier by 1
  Can be used by any effect really with minor code change
*/
void decrease_modifier(struct char_data * i)
d247 12
a258 13
  for (eff = i->effects; eff; eff = tmp)
    {
      tmp = eff->next;
      if (eff->type == SPELL_STONE_SKIN)
        {
          if (eff->modifier > 1)
            eff->modifier--;
          else
            {
              effect_remove(i, eff);/*remove bit*/
              send_to_char("&3&dYour skin softens and returns to normal.&0\r\n", i);
            }
        }
d260 1
d559 1
d570 1
d1015 4
d2516 48
d4686 3
@


1.289
log
@Soulshield, holy word, and unholy word now use regular alignment
checks instead of arbitrary 500 and -500 values.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.288 2009/06/10 18:50:40 myc Exp myc $
d2278 1
a2278 1
    eff[0].duration = 12 + (skill / 8); /* max 24 */
d4631 4
@


1.288
log
@Reduce the amount of damage breath attacks do.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.287 2009/06/09 05:43:38 myc Exp myc $
d1863 1
a1863 1
    if (GET_ALIGNMENT(victim) >= 500) {
d1867 1
a1867 1
    else if (GET_ALIGNMENT(victim) <= -500) {
d2868 2
a2869 2
  if ((spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(ch) >= 500) ||
      (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(ch) <= -500)) {
d2880 1
a2880 1
    if (spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(tch) < 500)
d2882 1
a2882 1
    if (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(tch) > -500)
d4593 1
a4593 1
         (GET_ALIGNMENT(attacker) >= 500 && GET_ALIGNMENT(victim) <= -500)
d4595 1
a4595 1
         (GET_ALIGNMENT(attacker) <= -500 && GET_ALIGNMENT (victim) >= 500)
d4631 3
@


1.287
log
@Changing a printf to a real log call.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.286 2009/05/19 19:36:52 myc Exp myc $
d949 1
a949 1
    dam = 1 * skill + number(1, skill * 4);
d4631 3
@


1.286
log
@Fix typo in chain lightning.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.285 2009/03/21 06:32:37 jps Exp myc $
d409 1
a409 2
      sprintf(buf, "SYSERR: Cannot get circle/level of spell %d for %s", spell, GET_NAME(ch));
      log(buf);
d433 1
a433 1
   printf("sorcerer_single_target: exponent =%0.2f power=%d minlevel=%d\n",
d4631 3
@


1.285
log
@Make phosphoric embers manual spell
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.284 2009/03/20 06:08:18 myc Exp jps $
d2785 1
a2785 1
    to_room = "&4&b$n&4&b sends powerful bolts of lightning $s his foes...&0";
d4632 3
@


1.284
log
@Adding detonation, phosphoric embers, positive field, and acid
burst and single-target offensive pyromancer spells.  Increased
melt's power vs metal, stone, and ice.  Made soul tap a damage-
over-time version of energy drain.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.283 2009/03/16 19:17:52 jps Exp myc $
d434 3
d4632 6
@


1.283
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.282 2009/03/15 22:31:24 jps Exp jps $
d557 1
d563 1
a563 1
     case SPELL_HEATWAVE:
d567 1
a567 2
     case SPELL_MELT:
     case SPELL_COMBUST:
d573 10
d596 2
a597 1
        /* fall through */
d600 6
a605 1
        dam = sorcerer_single_target(ch, spellnum, skill) / 5;
a951 10
  case SPELL_SOUL_TAP:
    if (GET_LIFEFORCE(victim) == LIFE_UNDEAD || GET_LIFEFORCE(victim) == LIFE_MAGIC) {
      act("$N has no soul to tap!", FALSE, ch, 0, victim, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }
    dam += number(15, 50) + 300;
    /* Add a regen effect to the CASTER. */
    if (attack_ok(ch, victim, FALSE))
      mag_affect(skill, ch, ch, SPELL_SOUL_TAP, savetype, CAST_SPELL);
    break;
d983 1
a983 1
  if (EFF_FLAGGED(ch, EFF_HARNESS)){
a2350 19
  case SPELL_SOUL_TAP:

    /* This is a secondary effect called by the soul tap case in
     * mag_damage, because the effect is applied to the caster,
     * not the victim. */

    /* Don't allow more than 5 casts of this. */
    {
      struct effect *eff;
      for (eff = victim->effects; eff; eff = eff->next)
        if (eff->type == SPELL_SOUL_TAP && eff->modifier >= skill / 2)
          return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HIT_REGEN;
    eff[0].modifier = eff[0].duration = skill / 10; /* Max 10 */
    accum_effect = TRUE;
    break;

d4629 3
@


1.282
log
@Make cold/fire/soulshield damage adjust for susceptibility
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.281 2009/03/09 20:36:00 myc Exp jps $
d3261 1
a3261 1
   GET_HOME(new_mob) = GET_HOME(model);
d4642 3
@


1.281
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.280 2009/03/09 16:57:47 myc Exp myc $
d4562 9
a4570 6
      act("&1Your limbs are seared by $N&0&1's shield of flames.&0 (&1&8$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_CHAR);
      act("&1$n&0&1's limbs are seared by your shield of flames.&0 (&3$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_VICT);
      act("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0 (&4$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_NOTVICT);
d4580 2
a4581 1
      act("&4&bThe globe around your body absorbs the killing ice!&0", FALSE, attacker, 0, 0, TO_CHAR);
d4586 9
a4594 6
      act("&4You are impaled on $N&0&4's shield of ice.&0 (&1&8$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_CHAR);
      act("&4$n&0&4 is impaled on your shield of ice.&0 (&3$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_VICT);
      act("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0 (&4$i&0)",
            FALSE, attacker, (void *) amount, victim, TO_NOTVICT);
d4603 5
a4607 1
   if (GET_ALIGNMENT(attacker) >= 500 && GET_ALIGNMENT(victim) <= -500) {
d4611 9
a4619 18
      act("&7&b$n's soul suffers upon contact with your aura.&0 (&3$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_VICT);
      act("&7&bYour soul suffers upon contact with $N's aura.&0 (&1&8$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_CHAR);
      act("&7&b$n's soul suffers upon contact with $N's aura.&0 (&4$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_NOTVICT);
   }

   if (GET_ALIGNMENT(attacker) <= -500 && GET_ALIGNMENT (victim) >= 500) {
      int amount = MIN(2 * GET_LEVEL(victim) / 5 +
            number(1, 1 + GET_LEVEL(victim) / 10),
            3 * dam / 16 + number(1, 1 + GET_LEVEL(victim) / 10));
      act("&7&b$n's soul suffers upon contact with your aura.&0 (&3$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_VICT);
      act("&7&bYour soul suffers upon contact with $N's aura.&0 (&1&8$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_CHAR);
      act("&7&b$n's soul suffers upon contact with $N's aura.&0 (&4$i&0)",
            TRUE, attacker, (void *) amount, victim, TO_NOTVICT);
d4642 3
@


1.280
log
@Added detect poison effect.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.279 2009/03/09 04:50:38 myc Exp myc $
d3073 1
a3073 1
  GET_PLAT(new_mob) = 0;
d3211 1
a3211 1
   GET_PLAT(mob) = 0;
d3337 1
a3337 1
   GET_PLAT(ch) = 0;
d3511 1
a3511 1
        GET_PLAT(new_mob) += GET_OBJ_VAL(temp_obj, VAL_MONEY_PLATINUM);
d4640 3
@


1.279
log
@Fix typo (missing newline) in divine essence.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.278 2009/03/09 04:33:20 jps Exp myc $
d2102 7
d4640 3
@


1.278
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.277 2009/03/09 03:26:34 jps Exp jps $
d2652 1
a2652 1
    to_char = "&3&bYou invoke your deity's divine essence!&0";
d4633 4
@


1.277
log
@Moved individual spell definitions to spell.c and spell.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.276 2009/03/08 23:34:14 jps Exp jps $
d42 1
d4633 3
@


1.276
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.275 2009/03/08 21:43:27 jps Exp jps $
d41 1
d4632 3
@


1.275
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.274 2009/03/07 22:31:20 jps Exp jps $
d22 1
a22 1
#include "spells.h"
d4631 3
@


1.274
log
@Make the victim's set-on-fire message go to the victim's room with
the TO_VICTROOM act flag, since the perpetrator might be in another room.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.273 2009/03/07 20:46:28 jps Exp jps $
d37 4
d4631 4
@


1.273
log
@Add bold to messages colored with &9 - they can be invisible otherwise
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.272 2009/03/07 11:24:26 jps Exp jps $
d1019 2
a1020 1
            act("&1&8$n's $t $N on fire!&0", FALSE, ch, (void*) buf, victim, TO_NOTVICT);
d4627 3
@


1.272
log
@Fix wall of fog spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.271 2009/03/03 19:43:44 myc Exp jps $
d2008 1
a2008 1
    to_char = "&9You have blinded $N with your sunray!&0";
d2010 1
a2010 1
    to_vict = "&9You have been blinded!&0";
d2042 1
a2042 1
    to_vict = "&9You have been blinded!&0";
d4626 3
@


1.271
log
@Always apply group spells to the caster last so spells like
group recall still work.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.270 2009/02/04 20:03:56 myc Exp myc $
d4106 2
a4107 1
  eff = ticks =0;
d4167 1
a4167 1
  if (eff != 0)
d4626 4
@


1.270
log
@Disallow guard skill if it would result in PK.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.269 2009/01/19 09:25:23 myc Exp myc $
d2664 1
a2664 1
    if (ch == tch || is_grouped(ch, tch))
d2667 6
d4625 3
@


1.269
log
@Removed MOB_PET flag.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.268 2009/01/19 08:42:29 myc Exp myc $
d173 2
a174 1
         && GET_STANCE(victim->guarded_by) >= STANCE_ALERT) {
d4619 3
@


1.268
log
@Add damage numbers to coldshield/fireshield/soulshield.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.267 2009/01/18 06:52:37 myc Exp myc $
d508 1
a508 1
        EFF_FLAGGED(ch, EFF_CHARM) || MOB_FLAGGED(ch, MOB_PET)) {
d4618 3
@


1.267
log
@Fix typo (capitalize a sentence in act()).
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.266 2008/11/09 03:47:57 myc Exp myc $
d4537 2
a4538 7
      act("&1Your limbs are seared by $N&0&1's shield of flames.&0",
            FALSE, attacker, 0, victim, TO_CHAR);
      act("&1$n&0&1's limbs are seared by your shield of flames.&0",
            FALSE, attacker, 0, victim, TO_VICT);
      act("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0",
            FALSE, attacker, 0, victim, TO_NOTVICT);
      return MIN((GET_LEVEL(victim) / 2 + number(1, GET_LEVEL(victim) / 10)),
d4540 7
d4557 2
a4558 7
      act("&4You are impaled on $N&0&4's shield of ice.&0",
            FALSE, attacker, 0, victim, TO_CHAR);
      act("&4$n&0&4 is impaled on your shield of ice.&0",
            FALSE, attacker, 0, victim, TO_VICT);
      act("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0",
            FALSE, attacker, 0, victim, TO_NOTVICT);
      return MIN((GET_LEVEL(victim) / 2 + number(1, 1 + GET_LEVEL(victim) / 10)),
d4560 7
d4575 2
a4576 7
      act("&7&b$n's soul suffers upon contact with your aura.&0",
            TRUE, attacker, 0, victim, TO_VICT);
      act("&7&bYour soul suffers upon contact with $N's aura.&0",
            TRUE, attacker, 0, victim, TO_CHAR);
      act("&7&b$n's soul suffers upon contact with $N's aura.&0",
            TRUE, attacker, 0, victim, TO_NOTVICT);
      return MIN(2 * GET_LEVEL(victim) / 5 + number(1, 1 + GET_LEVEL(victim) / 10),
d4578 6
d4587 10
a4596 8
      act("&7&b$n's soul suffers upon contact with your aura.&0",
            TRUE, attacker, 0, victim, TO_VICT);
      act("&7&bYour soul suffers upon contact with $N's aura.&0",
            TRUE, attacker, 0, victim, TO_CHAR);
      act("&7&b$n's soul suffers upon contact with $N's aura.&0",
            TRUE, attacker, 0, victim, TO_NOTVICT);
      return MIN(2 * GET_LEVEL(victim) / 5 + number(1, 1 + GET_LEVEL(victim) / 10),
         3 * dam / 16 + number(1, 1 + GET_LEVEL(victim) / 10));
d4618 3
@


1.266
log
@Cut duration on poison and ray of enfeeblement.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.265 2008/09/29 00:03:13 jps Exp myc $
d647 1
a647 1
      act("Yeah, right there fancy pants.  $N doesn't seem to care.",
d676 1
a676 1
      act("Yeah, right there fancy pants.  $N doesn't seem to care.",
d4611 3
@


1.265
log
@Moved weight_change_object to objects.c/h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.264 2008/09/21 21:04:20 jps Exp jps $
d1769 1
a1769 1
    eff[0].duration = 8 + (skill / 12); /* max 20 */
d2149 1
a2149 1
    eff[0].duration = 4 + (skill / 3); /* max 37 */
d4611 3
@


1.264
log
@Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.263 2008/09/21 20:46:36 jps Exp jps $
a49 1
void weight_change_object(struct obj_data * obj, int weight);
d4611 3
@


1.263
log
@Removing unused variable
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.262 2008/09/21 20:40:40 jps Exp jps $
d938 1
a938 1
      mag_affect(skill, ch, ch, SPELL_SOUL_TAP, savetype);
d1068 1
a1068 1
                 int spellnum, int savetype)
d1133 1
a1133 1
    if (!IS_EVIL(ch)) {
d1946 1
a1946 1
    if (!IS_GOOD(ch)) {
d2597 1
a2597 1
    mag_affect(skill, ch, tch, SPELL_ARMOR, savetype);
d2603 2
a2604 2
    mag_affect(skill, ch, tch, SPELL_GREATER_ENDURANCE, savetype);
    mag_affect(skill, ch, tch, SPELL_BLESS, savetype);
d2610 1
a2610 1
    mag_affect(skill, ch, tch, CHANT_WAR_CRY, savetype);
d2702 1
a2702 1
    mag_affect(skill, ch, tch, spellnum, savetype);
d4612 3
@


1.262
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.261 2008/09/20 17:39:12 jps Exp jps $
a1074 1
  struct char_data *tch;
d4612 4
@


1.261
log
@Fix typos in bone armor messages.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.260 2008/09/20 17:23:20 jps Exp jps $
d2577 1
a2577 3
            for (tch = CH_ROOM(victim)->people; tch; tch = tch->next_in_room)
              if (FIGHTING(tch) == victim)
                stop_fighting(tch);
d4613 3
@


1.260
log
@Fix rigidity check with certain spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.259 2008/09/20 07:27:45 jps Exp jps $
d2297 2
a2298 2
    to_vict="&3Your skin hardens into bone carapace.&0";
    to_room="&3$N's&3 skin hardens to bone carapace.&0";
d4615 3
@


1.259
log
@set_fighting takes a 3rd parameter, reciprocate, which will set the attackee fighting
the attacker if true.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.258 2008/09/20 06:05:06 jps Exp jps $
d1100 15
d1132 206
d1422 20
d1508 17
d1575 1
a1575 1
    to_room = "&6&b$n's body dematerializes into a translucent &7cloud &6of &7vapor&6!&0";
d1590 1
a1590 184
    to_room="&4&b$n&4&b's body wavers a bit, slowly changing into a &0&4liquid&b state!&0";
    break;

    /* --- SORTED --- */

  case SPELL_BARKSKIN:

    /* Check for other types of armor spells */
    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    eff[0].location = APPLY_AC;
    eff[0].modifier = 7 + (skill / 9); /* max 18 */
    eff[0].duration = 5 + (skill / 10); /* max 15 */

    to_char = "&3$N's&3 skin hardens to bark.&0";
    to_vict = "&3Your skin hardens to bark.&0";
    to_room = "&3$N's&3 skin hardens to bark.&0";
    break;

  case SPELL_NIGHT_VISION:

    if (affected_by_spell(victim, SPELL_INFRAVISION)) {
      if (ch == victim)
        act("You are already enchanted with enhanced vision.", FALSE, ch, 0, 0, TO_CHAR);
      else
        act("$N is already enchanted with enhanced vision.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, victim, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_ULTRAVISION);
    eff[0].duration = (skill / 21); /* max 4 */
    to_room = "$N's eyes glow a dim neon green!";
    to_vict = "&9&bYour vision sharpens a bit.";
    break;

  case SPELL_DARK_PRESENCE:

    if (!IS_EVIL(ch)) {
      send_to_char("In your goodness, the dark gods have forsaken you!\r\n", ch);
      act("Nothing happens.  $U$n looks rather forlorn.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    if (affected_by_spell(victim, SPELL_BLESS)) {
      act("$N is already blessed by some other gods.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n looks a little overprotective.", TRUE, ch, 0, 0, TO_ROOM);
      return CAST_RESULT_CHARGE;
    }

    /* Alignment Checks! */
    if (IS_GOOD(victim)) {
      act("You can't protect an evil ally if they are GOOD!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n tries to enrage your inner demon.\r\nSilly isn't $e?", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to enrage $N's inner demon.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_SAVING_SPELL;
    eff[0].modifier = -2 - (skill / 10);
    eff[0].duration = 10 + (skill / 7); /* 10-24 hrs */
    if (skill < 55) {
      to_char = "You summon allegiance from your dark gods to protect $N.";
      to_vict = "&9&bA dark presence fills your mind.&0";
      if (ch == victim)
         to_room = "$n seizes up in pain!\r\n$n crosses $s arms on $s chest, and is surrounded by a dark presence.";
      else
         to_room = "$n seizes up in pain!\r\n$n grabs $N, who is surrounded by a dark presence.";
    }
    else {
      eff[1].location = APPLY_DAMROLL;
      eff[1].modifier = 1 + (skill > 95);
      eff[1].duration = eff[0].duration;
      to_char = "You summon allegiance from your dark gods to protect and enrage $N.";
      to_vict = "&9&bA dark presence fills your mind and body!&0";
      if (ch == victim)
         to_room = "$n seizes up in pain!\r\n$n crosses $s arms on $s chest, and is enraged by a dark presence.";
      else
         to_room = "$n seizes up in pain!\r\n$n grabs $N, who is enraged by a dark presence.";
    }
    SET_FLAG(eff[2].flags, EFF_HEX);
    eff[2].duration = eff[0].duration;
    break;

  case SPELL_DEMONSKIN:

    if (check_armor_spells(ch, victim, spellnum))
      return CAST_RESULT_CHARGE;

    /* Alignement Check! */
    if (IS_GOOD(victim)) {
      act("You can't protect an evil ally if they are GOOD!", FALSE, ch, 0, 0, TO_CHAR);
      act("$n tries to wrap you in demonic skin!\r\nSilly isn't $e?", FALSE, ch, 0, victim, TO_VICT);
      act("$n fails to wrap $N is a demonic skin of protection.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }
    else if (GET_ALIGNMENT(victim) > 0) {
      eff[0].location = APPLY_AC;
      eff[0].modifier = 8;
      eff[0].duration = 5;
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
    }
    else {
      eff[0].location = APPLY_AC;
      eff[0].modifier = 10 + (skill / 20);
      eff[0].duration = 10 + (skill / 50);
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
    }
    to_vict = "&1Your skin toughens into a dark red hide.&0";
    to_room = "&1$N's&1 skin toughens into a dark red hide.&0";
    break;

  case SPELL_DISEASE:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (mag_savingthrow(victim, SAVING_SPELL)) {
      act("You resist $n's foul incantation!", FALSE, ch, 0, victim, TO_VICT);
      act("$N holds $S breath avoiding $n's diseased air!", FALSE, ch, 0, victim, TO_NOTVICT);
      act("$N resists your disease!", TRUE, ch, 0, victim, TO_CHAR);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_CON;
    eff[0].modifier = -10 - (skill / 10);
    eff[0].duration = 5 + (skill / 10);
    SET_FLAG(eff[0].flags, EFF_DISEASE);
    eff[1].location = APPLY_STR;
    eff[1].modifier = eff[0].modifier;
    eff[1].duration = eff[0].duration;
    to_char = "Your diseased air infects $N!";
    to_vict = "&3You choke and gasp on $n's foul air as a sick feeling overtakes you. You feel seriously ill!&0";
    to_room = "&3$N&3 chokes and gasps on $n's foul air, $E looks seriously ill!";
    break;

  case SPELL_INSANITY:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;
    if (mag_savingthrow(victim, SAVING_SPELL)) {
      act("$N has too strong a will to drive insane!", FALSE, ch, 0, victim, TO_CHAR);
      act("Your strength of will protects you from an insane suggestion from $n... This time...", FALSE, ch, 0, victim, TO_VICT);
      act("$N resists going insane at $n's suggestion.", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_INSANITY);
    eff[0].location = APPLY_WIS;
    eff[0].modifier = -50;
    eff[0].duration = 5;
    to_char = "You cause &5$N to snap... A crazed gleam fills $S eyes.&0";
    to_vict = "&5You go out of your &bMIND!&0";
    to_room = "&5$N's&5 psyche snaps... A crazed gleam fills $S eyes.&0";
    break;

  case SPELL_DEMONIC_ASPECT:
  case SPELL_DEMONIC_MUTATION:

    if (affected_by_spell(victim, SPELL_DEMONIC_ASPECT) ||
        affected_by_spell(victim, SPELL_DEMONIC_MUTATION)) {
      send_to_char("You're feeling pretty demonic already.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HIT;
    /* starts at (level / 5) and goes to (level / 1) */
    eff[0].modifier = skill / (1 + ((100 - skill) / 25));
    eff[0].duration = 5 + (skill / 20); /* max 10 */
    eff[1].location = APPLY_STR;
    eff[1].modifier = 5 + (skill / 14); /* max 12 */
    eff[1].duration = eff[0].duration;

    /* Modify hp by alignment */
    eff[0].modifier *= GET_ALIGNMENT(victim) / -1000.0;

    if (spellnum == SPELL_DEMONIC_ASPECT) {
      to_vict = "&1Your body fills with a demonic strength.&0";
      to_room = "&1$n's&1 body &bglows red&0&1 briefly and grows stronger.&0";
    }
    else if (spellnum == SPELL_DEMONIC_MUTATION) {
      eff[0].modifier *= 2.5;
      to_vict = "&1Your body fills with a demonic strength.&0";
      to_room = "&1$n's eyes flash &8red&0&1 as $e suddenly sprouts horns!&0";
    }
d1611 1
a1611 70
  case SPELL_LESSER_ENDURANCE:
  case SPELL_ENDURANCE:
  case SPELL_GREATER_ENDURANCE:
  case SPELL_VITALITY:
  case SPELL_GREATER_VITALITY:
  case SPELL_DRAGONS_HEALTH:

    if (affected_by_spell(victim, SPELL_LESSER_ENDURANCE) ||
        affected_by_spell(victim, SPELL_ENDURANCE) ||
        affected_by_spell(victim, SPELL_GREATER_ENDURANCE) ||
        affected_by_spell(victim, SPELL_VITALITY) ||
        affected_by_spell(victim, SPELL_GREATER_VITALITY) ||
        affected_by_spell(victim, SPELL_DRAGONS_HEALTH)) {
      send_to_char("Nothing happens!\r\n", ch);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_HIT;
    eff[0].modifier = get_vitality_hp_gain(ch, spellnum);
    eff[0].duration = get_spell_duration(ch, spellnum);

    to_vict = get_vitality_vict_message(spellnum);
    to_room = "$N looks healthier than before!";
    to_char = "$N looks healthier than before!";
    break;

  case SPELL_WINGS_OF_HEAVEN:

    if (affected_by_spell(victim, SPELL_WINGS_OF_HELL)) {
      send_to_char("You already have something sticking out of your back.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    SET_FLAG(eff[0].flags, EFF_FLY);
    eff[0].duration = 10 + (skill / 5); /* max 30 */

    to_vict = "&7&bBeautiful bright white wings unfurl behind you as you lift into the air.&0";
    to_room = "&7&bBeautiful bright white wings unfurl from $n's&7&b back, lifting $m into the air.&0";
    if (AWAKE(victim)) {
      GET_STANCE(victim) = STANCE_ALERT;
      GET_POS(victim) = POS_FLYING;
    }
    break;

  case SPELL_ELEMENTAL_WARDING:

    if (is_abbrev(buf2, "fire")) {
      SET_FLAG(eff[0].flags, EFF_PROT_FIRE);
      to_vict = "You are warded from &1fire&0.";
      to_char = "You protect $N from &1fire&0.";
    } else if (is_abbrev(buf2, "cold")) {
      SET_FLAG(eff[0].flags, EFF_PROT_COLD);
      to_vict = "You are warded from the &4cold&0.";
      to_char = "You protect $N from the &4cold&0.";
    } else if (is_abbrev(buf2, "air")) {
      SET_FLAG(eff[0].flags, EFF_PROT_AIR);
      to_vict = "You are warded from &6&bair&0.";
      to_char = "You protect $N from &6&bair&0.";
    } else if (is_abbrev(buf2, "earth")) {
      SET_FLAG(eff[0].flags, EFF_PROT_EARTH);
      to_vict = "You are warded from &3earth&0.";
      to_char = "You protect $N from &3earth&0.";
    } else {
      send_to_char("What element do you want to ward against?\r\n", ch);
      return 0;
    }

    eff[0].duration = 5 + (skill / 14); /* max 12 */
    to_room = "&7&b$N&7&b glows briefly.&0";
    break;
d4334 2
a4335 1
   if (RIGID(ch)) return TRUE;
d4338 5
a4342 7
         if (victim) {
            cprintf(victim,
                  "The spell is unable to take hold in your substance.\r\n");
            if (ch)
               act("The is unable to alter $N's substance.",
                     FALSE, ch, 0, victim, TO_CHAR);
         }
d4615 4
@


1.258
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.257 2008/09/16 17:06:32 rsd Exp jps $
d143 1
a143 1
    set_fighting(vict, caster);
d2703 1
a2703 1
     * someone, then make them attack the caster.
d2706 1
a2706 1
      set_fighting(tch, ch);
d4610 3
@


1.257
log
@Made the damage bonus based on class for firestorm the
class of pyromancer instead of cryomancer..
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.256 2008/09/14 04:41:41 jps Exp $
d2184 1
a2184 2
         (victim->desc && victim->desc->original &&
          GET_LEVEL(victim->desc->original) < 100))) ||
d2186 1
a2186 2
         (ch->desc && ch->desc->original &&
          GET_LEVEL(ch->desc->original) < 100))) {
d4610 4
@


1.256
log
@Don't allow mortal spells to affect imms.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.255 2008/09/14 04:34:30 jps Exp jps $
d763 1
a763 1
    if (GET_CLASS(ch) == CLASS_CRYOMANCER)
d4612 3
@


1.255
log
@Set folks fighting even if the initial attack was completely ineffective.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.254 2008/09/14 04:09:24 jps Exp jps $
d1091 7
d4612 3
@


1.254
log
@Take certain act flags off summoned mobs, such as peaceful and protector.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.253 2008/09/14 02:22:53 jps Exp jps $
d143 1
d4605 3
@


1.253
log
@Expand the suitability-for-fluid-chars check to be used for all mag_effect spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.252 2008/09/14 02:08:01 jps Exp jps $
d3186 6
d4604 3
@


1.252
log
@Use standardized area attack targetting
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.251 2008/09/13 18:52:20 jps Exp jps $
d1081 2
d4314 1
a4314 1
bool check_fluid_armorability(struct char_data *ch, struct char_data *victim, int spellnum, bool quiet)
d4316 1
a4345 2
  if (!check_fluid_armorability(ch, victim, spellnum, FALSE))
    return FALSE;
d4598 3
@


1.251
log
@Removing unused variables
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.250 2008/09/13 18:05:29 jps Exp jps $
d2857 2
a2858 5
    if (tch == ch)
      continue;
    if (is_grouped(ch, tch))
      continue;
    if (!roomeffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
a2859 6
    if (!mass_attack_ok(ch, tch, FALSE))
      continue;
    /* Mobs don't hit other mobs, unless they'repets */
    if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
        !MOB_FLAGGED(tch, MOB_PET))
      continue;
d4597 3
@


1.250
log
@Added functions to remove spells from characters when necessary.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.249 2008/09/13 16:03:53 jps Exp jps $
a317 1
  static struct char_data *i, *nexti;
d4606 3
@


1.249
log
@Fix check_armor_spells
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.248 2008/09/12 20:16:49 jps Exp jps $
d313 1
d315 10
d4307 1
a4307 1
bool check_fluid_armorability(struct char_data *ch, struct char_data *victim, int spellnum, bool quiet)
d4317 15
a4331 8
         if (!quiet) {
            if (victim) {
               cprintf(victim,
                     "The spell is unable to take hold in your substance.\r\n");
               if (ch)
                  act("The is unable to alter $N's substance.",
                        FALSE, ch, 0, victim, TO_CHAR);
            }
d4333 2
a4334 2
         return FALSE;
         break;
d4339 13
d4607 3
@


1.248
log
@Make it impossible to cast certain armor spells onto characters who are in a fluid state.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.247 2008/09/09 08:23:37 jps Exp jps $
d56 1
a56 1
bool check_armor_spells(struct char_data *ch, struct char_data *victim);
d1146 1
a1146 1
    if(check_armor_spells(ch, victim))
d1171 1
a1171 1
    if (check_armor_spells(ch, victim))
d1219 1
a1219 1
    if (check_armor_spells(ch, victim))
d1320 1
a1320 1
    if (check_armor_spells(ch, victim))
d1399 1
a1399 1
    if (check_armor_spells(ch, victim))
d1784 1
a1784 1
    if (check_armor_spells(ch, victim))
d2266 1
a2266 1
    if (check_armor_spells(ch, victim))
d4576 3
@


1.247
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.246 2008/09/07 01:28:17 jps Exp jps $
d4296 28
a4323 1
bool check_armor_spells(struct char_data *ch, struct char_data *victim) {
d4576 3
@


1.246
log
@Don't automatically start flying if your load is too heavy.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.245 2008/09/05 21:52:56 myc Exp jps $
d686 2
d690 2
a691 35
    switch (world[victim->in_room].sector_type) {
      case SECT_CITY:
      case SECT_FIELD:
      case SECT_ROAD:
      case SECT_BEACH:
      case SECT_FIREPLANE:
      case SECT_EARTHPLANE:
      case SECT_ETHEREALPLANE:
      case SECT_GRASSLANDS:
        temp = 5;
        break;
      case SECT_FOREST:
      case SECT_RUINS:
      case SECT_SWAMP:
      case SECT_HILLS:
      case SECT_UNDERDARK:
        temp = 10;
        dam *= 1.25;
        break;
      case SECT_MOUNTAIN:
        temp = 20;
        dam *= 1.15;
        break;
      case SECT_INSIDE:
      case SECT_SHALLOWS:
      case SECT_WATER:
      case SECT_UNDERWATER:
      case SECT_AIR:
      case SECT_OCEAN:
      case SECT_ASTRALPLANE:
      case SECT_AIRPLANE:
      case SECT_AVERNUS:
      default:
        return CAST_RESULT_CHARGE;
    }
d4549 3
@


1.245
log
@Fix typo in elemental warding.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.244 2008/09/04 06:47:36 jps Exp myc $
d2273 11
a2283 6
    to_vict = "&7You fly through the air, as free as a bird!&0";
    to_room = "&6&b$N lifts into the air.&0";
    to_char = "&6&b$N lifts into the air.&0";
    if (AWAKE(victim)) {
      GET_POS(victim) = POS_FLYING;
      GET_STANCE(victim) = STANCE_ALERT;
d4580 3
@


1.244
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.243 2008/09/02 07:19:56 jps Exp jps $
d1596 1
a1596 1
      to_char = "You protect $n from &1fire&0.";
d1600 1
a1600 1
      to_char = "You protect $n from the &4cold&0.";
d1604 1
a1604 1
      to_char = "You protect $n from &6&bair&0.";
d1608 1
a1608 1
      to_char = "You protect $n from &3earth&0.";
d1611 1
a1611 1
      return CAST_RESULT_CHARGE;
d4575 3
@


1.243
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.242 2008/09/02 07:16:39 jps Exp jps $
d695 1
a695 1
      case SECT_EATHREALPLANE:
d712 2
a713 2
      case SECT_WATER_SWIM:
      case SECT_WATER_NOSWIM:
d715 1
a715 1
      case SECT_FLYING:
d2788 2
a2789 2
      case SECT_WATER_SWIM:
      case SECT_WATER_NOSWIM:
d2791 1
a2791 1
      case SECT_FLYING:
d3672 2
a3673 2
               case SECT_WATER_SWIM:
               case SECT_WATER_NOSWIM:
d3680 1
a3680 1
               case SECT_FLYING:
d4029 2
a4030 2
      case SECT_WATER_SWIM:
      case SECT_WATER_NOSWIM:
d4032 1
a4032 1
      case SECT_FLYING:
d4135 2
a4136 2
    if(SECT(ch->in_room) == SECT_WATER_SWIM ||
       SECT(ch->in_room) == SECT_WATER_NOSWIM ||
d4575 3
@


1.242
log
@Changing object TIMER to DECOMP where appropriate.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.241 2008/09/01 23:47:49 jps Exp jps $
d36 1
d4575 3
@


1.241
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.240 2008/08/31 06:51:00 myc Exp jps $
d3448 1
a3448 1
    preserve_mult = (float)GET_OBJ_TIMER(obj) / 300.0 + 1.0;
d4574 3
@


1.240
log
@Reverse sign on modifiers for APPLY_AC so they follow the same scheme as
AC applies on equipment.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.239 2008/08/29 19:18:05 myc Exp myc $
d35 1
d4574 4
@


1.239
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.238 2008/08/29 16:55:00 myc Exp myc $
d1179 1
a1179 1
    eff[0].modifier = -15 - (skill / 16); /* max -21 */
d1204 1
a1204 1
    eff[0].modifier = -5 - (skill / 14); /* max -12 */
d1252 1
a1252 1
    eff[0].modifier = -5 - (skill / 16); /* max -11 */
d1291 1
a1291 1
      eff[1].modifier = 10;
d1304 1
a1304 1
      eff[1].modifier = 40;
d1353 1
a1353 1
    eff[0].modifier = -7 - (skill / 9); /* max -18 */
d1440 1
a1440 1
      eff[0].modifier = -8;
d1446 1
a1446 1
      eff[0].modifier = -10 - (skill / 20);
d1817 1
a1817 1
    eff[0].modifier = -10 - (skill / 20); /* max -15 */
d2008 1
a2008 1
    eff[1].modifier = 40;
d2040 1
a2040 1
    eff[1].modifier = 40;
d2123 1
a2123 1
    eff[0].modifier = -40;
d2294 1
a2294 1
    eff[0].modifier = -10 - (skill / 6); /* max -25 */
d2325 1
a2325 1
    eff[2].modifier = skill / 5 * 2; /* Max 40 */
d2436 1
a2436 1
    eff[0].modifier = 10 + (skill / 2); /* max 60: positive is bad */
d4573 4
@


1.238
log
@Fixed messages for many self-only spells so they make sense even if
cast on someone else.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.237 2008/08/28 21:50:05 jps Exp myc $
d3118 1
a3118 1
  new_mob->viewed_abils = new_mob->natural_abils;
d3221 1
a3221 1
   new_mob->viewed_abils = model->viewed_abils;
d4573 4
@


1.237
log
@Prevent "create spring" from working in watery or air rooms.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.236 2008/08/26 04:39:21 jps Exp jps $
d1364 4
a1367 1
      act("You are already enchanted with enhanced vision.", FALSE, ch, 0, 0, TO_CHAR);
d1530 1
a1530 1
      send_to_char("You already have something sticking out of your back.\r\n", ch);
d1574 1
a1574 1
      send_to_char("You already have something sticking out of your back.\r\n", ch);
d1655 1
a1655 1
      send_to_char("You have already harnessed your energy!\r\n", ch);
d1703 2
a1704 1
      send_to_char("The shield of fire around your body negates your spell.\r\n", ch);
d1718 2
a1719 1
      send_to_char("The shield of ice around your body negates your spell.\r\n", ch);
d1852 1
a1852 1
    if (GET_ALIGNMENT(ch) >= 500) {
d1856 1
a1856 1
    else if (GET_ALIGNMENT(ch) <= -500) {
d1861 2
a1862 2
      act("A brief aura surrounds you, then fades.", FALSE, ch, 0, victim, TO_CHAR);
      act("A brief aura surrounds $N, then fades.", TRUE, ch, 0, victim, TO_ROOM);
d4573 3
@


1.236
log
@Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.235 2008/08/26 02:29:11 jps Exp jps $
d4021 10
d4568 3
@


1.235
log
@Change phantasm mob list
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.234 2008/08/24 03:15:57 myc Exp jps $
d2795 2
a2796 1
    send_to_zone("&3The ground &1rumbles&3 and shakes!&0\r\n", IN_ZONE(ch), IN_ROOM(ch), STANCE_SLEEPING);
d4558 3
@


1.234
log
@Make evades_spell absolutely fail when the skill's damage type
is 'undefined', not 'slashing'.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.233 2008/08/18 01:35:38 jps Exp myc $
a3372 1
  /* ant, mouse, sparrow, rabbit, cat, snow troll, gnome, swamp troll */
d3374 16
a3389 2
  int phantasm_mobs[] = { 8016, 3506, 8605, 1688, 8807, 30215, 12504, 50219 };
  int num_phantasm_mobs = 8;
d4557 4
@


1.233
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.232 2008/08/17 20:24:45 jps Exp jps $
d94 1
a94 1
  if (!skills[spellnum].damage_type)
d4544 3
@


1.232
log
@Add wall_charge_check, for doorbash toward a wall.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.231 2008/08/17 06:39:47 jps Exp jps $
d3390 1
a3390 1
      send_to_char("A corpse would help, don't you think?\n\r", ch);
d4544 3
@


1.231
log
@Fix grammar of cloak of gaia.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.230 2008/08/10 19:34:37 jps Exp jps $
d4376 10
d4392 2
d4395 18
a4412 3
   for (wall = world[actor->in_room].contents; wall; wall = wall->next_content) {
      if (GET_OBJ_TYPE(wall) == ITEM_WALL && GET_OBJ_VAL(wall, VAL_WALL_DIRECTION) == dir) {
         /* Found a wall; you'll be blocked. */
d4414 4
a4417 25
         /* See if a wall of ice will put out anyone's flames. */
         if (GET_OBJ_VAL(wall, VAL_WALL_SPELL) == SPELL_WALL_OF_ICE && EFF_FLAGGED(motivator, EFF_ON_FIRE)) {
            act("$n&0 spreads $mself out on $p&0 and with a &8&bsizzle&0, $s flames are put out.",
                  FALSE, motivator, wall, 0, TO_ROOM);
            act("You spread yourself out on $p&0 and your flames go out in a &8&bsizzle of steam&0.",
                  FALSE, motivator, wall, 0, TO_CHAR);
            REMOVE_FLAG(EFF_FLAGS(motivator), EFF_ON_FIRE);
         } else if (GET_OBJ_VAL(wall, VAL_WALL_SPELL) == SPELL_WALL_OF_ICE && EFF_FLAGGED(actor, EFF_ON_FIRE)) {
            act("$n&0 spreads $mself out on $p&0 and with a &8&bsizzle&0, $s flames are put out.",
                  FALSE, actor, wall, 0, TO_ROOM);
            act("You spread yourself out on $p&0 and your flames go out in a &8&bsizzle of steam&0.",
                  FALSE, actor, wall, 0, TO_CHAR);
            REMOVE_FLAG(EFF_FLAGS(actor), EFF_ON_FIRE);

         /* No flames being put out.  Is this a mounted situation? */
         } else if (actor && motivator && actor != motivator && RIDING(actor) == motivator) {
            act("You rode $N right into $p!", FALSE, actor, wall, motivator, TO_CHAR);
            act("Bump!  $n rides $N into $p.", FALSE, actor, wall, motivator, TO_ROOM);

         /* Just your standard walk-into-a-wall. */
         } else {
            act("Oof.  You bump into $p.", FALSE, actor, wall, 0, TO_CHAR);
            act("$n bumps into $p.", FALSE, actor, wall, 0, TO_ROOM);
         }
         return TRUE;
d4419 1
d4424 40
d4544 3
@


1.230
log
@Calibrated sorcerer_single_target spells to the level at which the spell
was assigned to the caster.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.229 2008/08/10 01:58:49 jps Exp jps $
d1183 2
a1184 2
    to_room = "&2A cyclone of leaves and sticks twirl around $n&2, guarding $s body.&0";
    to_vict = "&2A cyclone of leaves and sticks twirl around you, guarding your body.&0";
d4497 4
@


1.229
log
@Added spells severance and soul reaver for illusionists.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.228 2008/08/09 20:35:57 jps Exp jps $
d384 1
a384 1
int sorcerer_single_target(int skill, int circle, int minlevel)
d386 1
d389 6
d412 1
a412 1
   exponent = 1.2 + 0.3 * minlevel / 100.0 + (skill - minlevel) *
d417 1
a417 1
         return dice(4, 19) + pow(skill, exponent);
d419 1
a419 1
         return dice(5, 16) + pow(skill, exponent);
d421 1
a421 1
         return dice(4, 24) + pow(skill, exponent);
d423 1
a423 1
         return dice(6, 20) + pow(skill, exponent);
d425 1
a425 1
         return dice(8, 25) + pow(skill, exponent);
d427 1
a427 1
         return dice(10, 24) + pow(skill, exponent);
d429 1
a429 1
         return dice(15, 17) + pow(skill, exponent);
d431 1
a431 1
         return dice(15, 18) + pow(skill, exponent);
d434 1
a434 1
         return dice(10, 35) + pow(skill, exponent);
a537 3
        dam = sorcerer_single_target(skill, 1, 1);
        reduction = TRUE;
        break;
d539 13
a551 1
        dam = sorcerer_single_target(skill, 2, 9);
d559 1
a559 10
        dam = sorcerer_single_target(skill, 3, 17);
        reduction = TRUE;
        break;
     case SPELL_SHOCKING_GRASP:
        dam = sorcerer_single_target(skill, 3, 17);
        reduction = TRUE;
        break;
     case SPELL_LIGHTNING_BOLT:
     case SPELL_NIGHTMARE:
        dam = sorcerer_single_target(skill, 4, 25);
a567 21
     case SPELL_CONE_OF_COLD:
     case SPELL_HEATWAVE:
        dam = sorcerer_single_target(skill, 5, 33);
        reduction = TRUE;
        break;
     case SPELL_FIREBALL:
        dam = sorcerer_single_target(skill, 6, 41);
        reduction = TRUE;
        break;
     case SPELL_BIGBYS_CLENCHED_FIST:
     case SPELL_FREEZE:
     case SPELL_MELT:
        dam = sorcerer_single_target(skill, 7, 49);
        reduction = TRUE;
        break;
     case SPELL_COMBUST:
        dam = sorcerer_single_target(skill, 8, 57);
        reduction = TRUE;
        break;
     case SPELL_DISINTEGRATE:
     case SPELL_ICEBALL:
d569 2
a570 4
        dam = sorcerer_single_target(skill, 9, 65);
        /* Immolate hits 5 times! */
        if (spellnum == SPELL_IMMOLATE)
           dam /= 5;
d4497 3
@


1.228
log
@Changed sense life so that it has a chance of detecting the presence and movement
of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.227 2008/08/03 19:31:44 myc Exp jps $
d942 6
d2787 8
d2813 8
d2825 7
a2831 3
  case SPELL_UNHOLY_WORD:
    to_char = "&9&bYou invoke a word of unholy power!&0";
    to_room = "&9&b$n &9&butters a word of unholy power!&0";
a2836 12
  case SPELL_METEORSWARM:
    to_char = "&1You conjure up a controlled shower of meteors to crush your foes!&0";
    to_room = "$n&1 conjures a controlled shower of flaming meteors!&0";
    break;
  case SPELL_ICE_SHARDS:
    to_char = "&6&bYou conjure thousands of razor sharp ice shards to massacre your foe!&0";
    to_room = "$n &6&bconjures thousands of razor sharp ice shards to massacre $s foe!&0";
    break;
  case SPELL_SUPERNOVA:
    to_char = "&1You release a &bconflagration&0&1 of f&3&bi&1r&0&1e, laying waste to all that surrounds you.&0";
    to_room = "&1&b$n&1&b EXPLODES,&0&1 releasing a &bconflagration&0&1 of f&3&bi&1r&0&1e that lays waste to the entire area!&0";
    break;
d2845 3
a2847 3
  case SPELL_CHAIN_LIGHTNING:
    to_char = "&4&bYou send powerful bolts of lightning from your body...&0";
    to_room = "&4&b$n&4&b sends powerful bolts of lightning $s his foes...&0";
d2849 7
a2855 3
  case SPELL_HELLFIRE_BRIMSTONE:
    to_char = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
    to_room = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
d2857 3
a2859 3
  case SPELL_FIRESTORM:
    to_char = "You conjure a gout of flame to sweep through the area.";
    to_room = "$n waves his hands as a gout of flame floods into the area.";
d2861 3
a2863 7
  case SPELL_CREMATE:
    to_char = "&1&8You raise up a huge conflaguration in the area.&0";
    to_room = "&1&8$n summons a huge conflagration burning through the area.&0";
    break;
  case SKILL_ELECTRIFY:
    to_char = "&4&8You send out electricity in all directions...&0";
    to_room = "&4&8$n&4&8 sends out electricity in all directions...&0";
d4513 4
@


1.227
log
@Fixing heatwave/cone of cold.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.226 2008/06/21 07:04:21 jps Exp myc $
d2259 1
a2259 1
    eff[0].duration = 5 + (skill / 10); /* max 15 */
d4499 3
@


1.226
log
@Don't allow setting-on-fire of folks with a low susceptibility to fire damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.225 2008/06/13 18:43:29 jps Exp jps $
a554 2
     case SPELL_CONE_OF_COLD:
     case SPELL_HEATWAVE:
d556 1
a556 1
        if (!MOB_FLAGGED(victim, MOB_ILLUSORY))
d560 4
a563 1
           dam = sorcerer_single_target(skill, 5, 33);
d4499 3
@


1.225
log
@Handle spell evasion differently for dispel magic, since it has other
purposes then simply doing harm.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.224 2008/06/11 22:24:43 jps Exp jps $
d1032 1
d4498 4
@


1.224
log
@Cancel spellcasting when you become "frozen up" due to cold attacks.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.223 2008/06/07 19:06:46 myc Exp jps $
d74 2
a75 2
   /* Dispel magic doesn't want to be evaded if you've consented */
   if (spellnum == SPELL_DISPEL_MAGIC && CONSENT(vict) == caster)
d79 1
a79 2
   if ((EFF_FLAGGED(vict, EFF_MINOR_GLOBE) || EFF_FLAGGED(vict, EFF_MAJOR_GLOBE)) &&
      spellnum != SPELL_DISPEL_MAGIC) {
d102 1
a102 6
    if (spellnum == SPELL_DISPEL_MAGIC);
       /* This is a special case where you intended to cast the spell for
        * the purpose of dispelling spell effects.  So the fact that it
        * has done no damage is no great newsflash.  We will send no
        * message. */
    else if (caster == vict) {
d539 4
d4497 3
@


1.223
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.222 2008/06/05 02:07:43 myc Exp myc $
d1069 1
d4499 3
@


1.222
log
@Changed object flags to use flagvectors.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.221 2008/05/19 06:16:40 jps Exp myc $
d3401 1
a3401 1
    } else if ((GET_OBJ_VAL(obj, 3) == CORPSE_NPC_NORAISE) || /* unraisable */
d3423 1
a3423 1
      GET_OBJ_VAL(obj, 3) = CORPSE_NPC_NORAISE; /* mark it unraisable */
d3479 4
a3482 4
        GET_PLAT(new_mob) += GET_OBJ_VAL(temp_obj, 0);
        GET_GOLD(new_mob) += GET_OBJ_VAL(temp_obj, 1);
        GET_SILVER(new_mob) += GET_OBJ_VAL(temp_obj, 2);
        GET_COPPER(new_mob) += GET_OBJ_VAL(temp_obj, 3);
d3936 1
a3936 1
        GET_OBJ_VAL(obj, 2)--;
d3951 1
a3951 1
      IS_POISONED(obj) = TRUE;
d3959 1
a3959 1
        GET_OBJ_VAL(obj, 2)++;
d3967 1
a3967 1
      IS_POISONED(obj) = FALSE;
d4318 1
a4318 1
  dir = GET_OBJ_VAL(wall, 0);
d4333 1
d4337 3
a4339 3
        GET_OBJ_VAL(wall, 0) >= 0 && GET_OBJ_VAL(wall, 0) < NUM_OF_DIRS &&
        world[wall->in_room].exits[GET_OBJ_VAL(wall, 0)] &&
        world[wall->in_room].exits[GET_OBJ_VAL(wall, 0)]->to_room == room)
d4351 1
a4351 1
      if (GET_OBJ_TYPE(wall) == ITEM_WALL && GET_OBJ_VAL(wall, 0) == dir) {
d4365 1
a4365 1
                  world[next_room].exits[GET_OBJ_VAL(wall, 0)]->to_room == ch->in_room) {
d4385 1
a4385 1
      if (GET_OBJ_TYPE(wall) == ITEM_WALL && GET_OBJ_VAL(wall, 0) == dir) {
d4389 1
a4389 1
         if (GET_OBJ_VAL(wall, 3) == SPELL_WALL_OF_ICE && EFF_FLAGGED(motivator, EFF_ON_FIRE)) {
d4395 1
a4395 1
         } else if (GET_OBJ_VAL(wall, 3) == SPELL_WALL_OF_ICE && EFF_FLAGGED(actor, EFF_ON_FIRE)) {
d4498 3
@


1.221
log
@Only mesmerize players for 2 hours.
Stop people who are fighting someone who gets mesmerized.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.220 2008/05/19 05:49:08 jps Exp jps $
d3827 1
a3827 1
         SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_GOOD);
d3833 2
a3834 2
     for (i = 0; i < MAX_OBJ_EFFECT; i++) {
        if (obj->effects[i].location) {
d3856 6
a3861 6
    else if (IS_OBJ_STAT(obj, ITEM_GLOW) ||
        IS_OBJ_STAT(obj, ITEM_HUM) ||
        IS_OBJ_STAT(obj, ITEM_INVISIBLE) ||
        IS_OBJ_STAT(obj, ITEM_MAGIC) ||
        IS_OBJ_STAT(obj, ITEM_NODROP) ||
        IS_OBJ_STAT(obj, ITEM_ANTI_EVIL))
d3871 1
a3871 1
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_GOOD);
d3883 1
a3883 1
         SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_EVIL);
d3891 2
a3892 2
     for (i = 0; i < MAX_OBJ_EFFECT; i++) {
        if (obj->effects[i].location) {
d3912 6
a3917 6
    else if (IS_OBJ_STAT(obj, ITEM_GLOW) ||
        IS_OBJ_STAT(obj, ITEM_HUM) ||
        IS_OBJ_STAT(obj, ITEM_INVISIBLE) ||
        IS_OBJ_STAT(obj, ITEM_MAGIC) ||
        IS_OBJ_STAT(obj, ITEM_NODROP) ||
        IS_OBJ_STAT(obj, ITEM_ANTI_GOOD))
d3927 1
a3927 1
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_EVIL);
d3933 2
a3934 2
    if (!IS_OBJ_STAT(obj, ITEM_NODROP)) {
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NODROP);
d3942 1
a3942 1
    if (!IS_OBJ_STAT(obj, ITEM_NOINVIS | ITEM_INVISIBLE)) {
d3956 2
a3957 2
    if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
      REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
d3987 1
a3987 1
       SET_BIT(obj->obj_flags.extra_flags, ITEM_INVISIBLE);
d4497 4
@


1.220
log
@Add mesmerize to mag_affect.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.219 2008/05/18 20:16:11 jps Exp jps $
d1102 1
d1249 2
d2578 7
a2584 2
             IS_FLAGGED(eff[i].flags, EFF_MESMERIZED)) && FIGHTING(victim))
            stop_fighting(victim);
a2585 2


d4497 3
@


1.219
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.218 2008/05/18 17:58:49 jps Exp jps $
d1218 33
d2568 2
a2569 1
                     IS_FLAGGED(eff[i].flags, EFF_MAJOR_PARALYSIS))
d2574 2
a2575 1
             IS_FLAGGED(eff[i].flags, EFF_MAJOR_PARALYSIS)) && FIGHTING(victim))
d4491 3
@


1.218
log
@Adding familiarity to mag_affect.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.217 2008/05/18 04:40:59 jps Exp jps $
d34 1
d4456 3
@


1.217
log
@Make is to people without detect invis can identify the
object that's being made invisible.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.216 2008/05/17 22:03:01 jps Exp jps $
d1133 47
a1179 1
  case SPELL_ICE_ARMOR:
d1182 1
a1182 1
    if (check_armor_spells(ch, victim))
d1186 6
a1191 4
    eff[0].modifier = -5 - (skill / 14); /* max -12 */
    eff[0].duration = 5 + (skill / 20); /* max 10 */
    to_vict = "&4Your body is encased in layer of &7&bsolid ice.&0";
    to_room = "&4$n's&4 body is encased in a layer of &7&bsolid ice.&0";
d1204 1
a1204 1
  case SPELL_NEGATE_HEAT:
d1206 2
a1207 20
    SET_FLAG(eff[0].flags, EFF_NEGATE_HEAT);
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict = "&6Your body becomes impervious to all forms of heat!&0";
    to_room = "&6$n&6 is surrounded by a frigid crystalline field.&0";
    break;

  case SPELL_NEGATE_COLD:

    SET_FLAG(eff[0].flags, EFF_NEGATE_COLD);
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict = "&4&bYour body becomes impervious to the cold!&0";
    to_room = "&4$n&4's is protected by a &3&bwarm&0&4-looking magical field.&0";
    break;

  case SPELL_WATERFORM:

    if (GET_COMPOSITION(victim) != COMP_FLESH) {
      send_to_char("Your body cannot sustain this change.\r\n", victim);
a1208 1
    }
d1210 5
a1214 21
    eff[0].location = APPLY_COMPOSITION;
    eff[0].modifier = COMP_WATER;
    eff[0].duration = 2 + (skill / 20); /* max 7 */
    refresh = FALSE;
    to_vict="&4&bYour body liquifies.&0";
    to_room="&4&b$n&4&b's body wavers a bit, slowly changing into a &0&4liquid&b state!&0";
    break;

  case SPELL_VAPORFORM:

    if (GET_COMPOSITION(victim) != COMP_FLESH) {
      send_to_char("Your body cannot sustain this change.\r\n", victim);
      return CAST_RESULT_CHARGE;
    }

    eff[0].location = APPLY_COMPOSITION;
    eff[0].modifier = COMP_MIST;
    eff[0].duration = 2 + (skill / 25); /* max 6 */
    refresh = FALSE;
    to_vict = "&6&bYour body sublimates into a &7cloud &6of &7vapor&6.&0";
    to_room = "&6&b$n's body dematerializes into a translucent &7cloud &6of &7vapor&6!&0";
d1230 18
d1286 1
a1286 1
  case SPELL_GAIAS_CLOAK:
d1288 2
a1289 2
    /* check for exclusion of other armor spells */
    if(check_armor_spells(ch, victim))
d1291 1
d1293 3
a1295 4
    eff[0].location = APPLY_AC;
    eff[0].modifier = -15 - (skill / 16); /* max -21 */
    eff[0].duration = 5 + (skill / 14); /* max 12 */

d1297 2
a1298 2
    to_room = "&2A cyclone of leaves and sticks twirl around $n&2, guarding $s body.&0";
    to_vict = "&2A cyclone of leaves and sticks twirl around you, guarding your body.&0";
d1301 4
a1304 2
  case SPELL_ENTANGLE:
    if (!attack_ok(ch, victim, TRUE))
a1305 13

    /* A difficult spell to land with success */
    if (mag_savingthrow(victim, SAVING_PARA) ||
        skill - GET_LEVEL(victim) < number(0, 80)) {
      act("&2&bYour crop of ripe vines search in vain for $N.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&2&bA crop of ripe vines snakes along the ground unable to locate you!&0", FALSE, ch, 0, victim, TO_VICT);
      act("&2&bA crop of ripe vines searches in vain for $N.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      /* start combat for failure */
      if (!FIGHTING(victim)) {
        attack(victim, ch);
        remember(victim, ch);
      }
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
d1308 3
a1310 12
    /* Chance for major para increases with higher skill. */
    if (skill >= 40 && number(0, 100) < 2 + (skill / 14)) {
      SET_FLAG(eff[0].flags, EFF_MAJOR_PARALYSIS);
      eff[0].duration = 2 + (skill > 95);
    }
    else {
      SET_FLAG(eff[0].flags, EFF_MINOR_PARALYSIS);
      eff[0].duration = 2 + (skill / 24);
    }
    to_char = "&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
    to_room = "&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
    to_vict = "&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
d1312 2
d1316 2
d2490 1
a2490 1
    * not have an accumulative effect, then fail the spell.
d4455 4
@


1.216
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.215 2008/05/17 04:32:25 jps Exp jps $
d3746 2
a3747 2
int mag_alter_obj(int skill, struct char_data * ch, struct obj_data * obj,
                    int spellnum, int savetype)
d3754 5
d3886 1
a3886 1
      SET_BIT(obj->obj_flags.extra_flags, ITEM_INVISIBLE);
d3926 8
d4440 3
@


1.215
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.214 2008/05/14 05:11:10 jps Exp jps $
d4256 1
a4256 1
      EXIT_DEST(world[room].exits[dir]) == NOWHERE)
d4427 3
@


1.214
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.213 2008/05/12 04:47:36 jps Exp jps $
d33 1
d4255 2
a4256 2
  if (!world[room].dir_option[dir] ||
      world[room].dir_option[dir]->to_room == NOWHERE)
d4260 1
a4260 1
  for (wall = world[world[room].dir_option[dir]->to_room].contents; wall;
d4267 2
a4268 2
        world[wall->in_room].dir_option[GET_OBJ_VAL(wall, 0)] &&
        world[wall->in_room].dir_option[GET_OBJ_VAL(wall, 0)]->to_room == room)
d4289 1
a4289 1
      next_room = world[ch->in_room].dir_option[dir]->to_room;
d4294 1
a4294 1
                  world[next_room].dir_option[GET_OBJ_VAL(wall, 0)]->to_room == ch->in_room) {
d4427 3
@


1.213
log
@Require evilness to cast dark presence, and goodness to cast bless.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.212 2008/05/12 04:41:59 jps Exp jps $
d3636 1
a3636 1
    alter_hit(victim, ch, -hit * multiplier, TRUE);
d4426 3
@


1.212
log
@Make discorporate destroy illusory mobs.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.211 2008/05/12 00:43:48 jps Exp jps $
d1333 6
d1901 6
d4426 3
@


1.211
log
@Add nightmare and discorporate spells to mag_damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.210 2008/05/11 07:11:53 jps Exp jps $
d558 5
a562 1
        dam = sorcerer_single_target(skill, 5, 33);
d4414 3
@


1.210
log
@Calling active_effect_remove so as to standardize what happens when
an effect goes away.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.209 2008/05/11 06:13:31 jps Exp jps $
d121 1
a121 1
      if (!skill_message(0, caster, vict, spellnum)) {
d551 1
d557 1
d4410 4
@


1.209
log
@Adding defensive_spell_damage(), which calculates damage to attackers
due to spells like fireshield, and sends messages.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.208 2008/05/11 05:50:15 jps Exp jps $
d274 2
a275 10
      else {
        if (eff->type > 0 && eff->type <= TOP_SKILL)
          if (!eff->next || eff->next->type != eff->type ||
              eff->next->duration > 0)
            if (skills[eff->type].wearoff) {
              send_to_char(skills[eff->type].wearoff, i);
              send_to_char("\r\n", i);
            }
        effect_remove(i, eff);
      }
d4408 4
@


1.208
log
@alter_hit() now takes the killer.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.207 2008/04/20 04:42:24 jps Exp jps $
d4336 77
d4416 3
@


1.207
log
@Don't send dodging messages when you resist the long-term
effects of gas breath.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.206 2008/04/19 21:22:06 myc Exp jps $
d32 1
d3512 3
a3514 1
int mag_point(int skill, struct char_data * ch, struct char_data * victim, int spellnum, int savetype) {
d3626 1
a3626 1
    alter_hit(victim, -hit * multiplier, TRUE);
d4339 4
@


1.206
log
@Missing break in mag_damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.205 2008/04/14 08:36:53 jps Exp myc $
d2081 7
a2087 2
      act("You dodge $n's attempt to prick you!", FALSE, ch, 0, victim, TO_VICT);
      act("$N dodges $n's attempt to prick $M.", TRUE, ch, 0, victim, TO_NOTVICT);
d4336 3
@


1.205
log
@Updated call to ASPELL, since it now includes the spell number.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.204 2008/04/14 05:11:40 jps Exp jps $
d598 1
d4331 3
@


1.204
log
@Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
to fly - not that the characer is actually flying.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.203 2008/04/14 02:17:45 jps Exp jps $
d2532 1
a2532 1
    spell_recall(skill, ch, tch, NULL, savetype);
d4330 4
@


1.203
log
@Adding glory to mag_affect().
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.202 2008/04/13 19:38:17 jps Exp jps $
d1481 1
a1481 1
    SET_FLAG(eff[0].flags, EFF_FLYING);
d1525 1
a1525 1
    SET_FLAG(eff[0].flags, EFF_FLYING);
d2203 1
a2203 1
    SET_FLAG(eff[0].flags, EFF_FLYING);
d2205 1
a2205 1
    to_vict = "&7You fly through the air, free as a bird!&0";
d4330 3
@


1.202
log
@Reduced the length of confusion.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.201 2008/04/13 18:44:42 jps Exp jps $
d1145 10
d4330 3
@


1.201
log
@Fix confusion-application message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.200 2008/04/13 18:30:14 jps Exp jps $
d1127 1
a1127 1
     eff[0].duration = 2 + skill / 20;
d4320 3
@


1.200
log
@Add confusion spell to mag_affect().
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.199 2008/04/12 21:29:39 jps Exp jps $
d1129 1
a1129 1
     to_room = "$n can't seem to decide which way to focus $s eyes!";
d4320 3
@


1.199
log
@Adding special case to evades_spell for dispel magic.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.198 2008/04/12 21:13:18 jps Exp jps $
d1115 17
d4320 3
@


1.198
log
@Using new header file magic.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.197 2008/04/07 03:02:54 jps Exp jps $
d71 4
d227 1
a227 1
  if (MAX(1, save) < number(0, 99)) {
d229 2
a230 4
  }
  else{
    return FALSE;
  }
d4303 3
@


1.197
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.196 2008/04/06 04:58:31 jps Exp jps $
d31 1
d4301 4
@


1.196
log
@Change catching-on-fire and freezing-up to use susceptibility.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.195 2008/04/05 17:10:57 jps Exp jps $
d152 1
a152 1
      if (GET_POS(ch) <= POS_INCAP) return;
d168 2
a169 1
         && GET_POS(victim->guarded_by) >= POS_FIGHTING) {
d746 1
a746 1
      GET_STANCE(victim) = STANCE_PRONE;
d838 2
a839 1
        GET_POS(victim) = POS_DEAD;
d900 2
a901 1
        GET_POS(victim) = POS_DEAD;
d1022 1
a1022 1
  if (GET_POS(victim) > POS_DEAD && dam > 0 && GET_LEVEL(victim) < LVL_IMMORT
d1456 2
a1457 1
    if (AWAKE(victim))
d1459 1
d1500 2
a1501 1
    if (AWAKE(victim))
d1503 1
d2125 1
a2125 1
    if (GET_POS(victim) > POS_SLEEPING) {
d2128 2
a2129 1
      GET_POS(victim) = POS_SLEEPING;
d2178 1
a2178 1
    if (AWAKE(victim))
d2180 2
d2691 1
a2691 1
    send_to_zone("&3The ground &1rumbles&3 and shakes!&0\r\n", IN_ZONE(ch), IN_ROOM(ch), POS_SLEEPING);
d4300 3
@


1.195
log
@Fix message formatting for enlarge/reduce spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.194 2008/04/05 16:32:24 jps Exp jps $
d1021 4
a1024 1
    /* If not protected from fire, chance to catch on fere. */
d1026 3
a1028 11
        !EFF_FLAGGED(victim, EFF_ON_FIRE) &&
        !EFF_FLAGGED(victim, EFF_PROT_FIRE) &&
        !EFF_FLAGGED(victim, EFF_NEGATE_HEAT) &&
        !EFF_FLAGGED(victim, EFF_COLDSHIELD)) {
      temp = skill;
      /* Better chance for higher-level spells. */
      temp += skills[spellnum].min_level[(int) GET_CLASS(ch)];
      /* Making your spell save helps not catch on fire. */
      if (mag_savingthrow(victim, SAVING_SPELL))
        temp -= number(GET_LEVEL(victim), 100);
      if (temp > number(0, 200)) {
d1050 7
a1056 11
    if (skills[spellnum].damage_type == DAM_WATER &&
        !EFF_FLAGGED(victim, EFF_PROT_COLD) &&
        !EFF_FLAGGED(victim, EFF_NEGATE_COLD) &&
        !EFF_FLAGGED(victim, EFF_FIRESHIELD) &&
        !MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      temp = skill;
      /* Better chance for higher-level spells. */
      temp += skills[spellnum].min_level[(int) GET_CLASS(ch)];
      /* Making your spell save helps not get frozen. */
      if (mag_savingthrow(victim, SAVING_SPELL))
        temp -= number(GET_LEVEL(victim), 100);
d1058 1
a1058 1
        WAIT_STATE(victim, PULSE_VIOLENCE * (skill - GET_LEVEL(victim)) / 20);
d4290 3
@


1.194
log
@Better feedback for spells that fail to inflict any damage, except that
dispel magic won't cause such a message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.193 2008/04/05 04:50:39 jps Exp jps $
d1804 1
a1804 1
    to_room = "&1&b$n's skin ripples as $e shrinks to half $s normal size!&0";
d1827 1
a1827 1
    to_room = "&9&b$n's skin ripples as $e enlarges to twice $s normal size!&0";
d4299 4
@


1.193
log
@Except MAG_MANUAL spells from boolean spell evasion.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.192 2008/04/04 21:32:42 jps Exp jps $
d95 13
a107 3
    act("&6$n's&6 spell has no effect on $N.&0", FALSE, caster, 0, vict, TO_NOTVICT);
    act("&6Your spell has no effect on $N!&0", FALSE, caster, 0, vict, TO_CHAR);
    act("&6$n's&6 spell has no effect on you!&0", FALSE, caster, 0, vict, TO_VICT);
d4299 3
@


1.192
log
@Un-break area attack spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.191 2008/04/02 03:24:44 myc Exp jps $
d118 1
a118 1
  if (skills[spellnum].routines & MAG_DAMAGE)
d4289 3
@


1.191
log
@Rewrote group code and removed major group code.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.190 2008/03/29 16:28:10 jps Exp myc $
a2765 2
    if (evades_spell(ch, tch, spellnum, skill))
      continue;
d4289 3
@


1.190
log
@Update evades_spell() to use power, and to check differently if the spell
is one that doesn't do damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.189 2008/03/28 17:54:53 myc Exp jps $
a42 1
void die(struct char_data * ch, struct char_data * killer);
d2530 1
a2530 1
  if (!EFF_FLAGGED(ch, EFF_GROUP))
d4291 4
@


1.189
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.188 2008/03/27 17:40:52 jps Exp myc $
d63 1
a63 1
bool evades_spell(struct char_data *caster, struct char_data *vict, int spellnum)
d88 3
d93 2
a94 4
  /* Elemental immunity: nothing bad happens to ya */
  /* This is checked here, rather than in mag_damage(), so that immunity will
   * also block effects. For example, !HEAT will prevent you from receiving
   * the strength drain of "chill touch". But mere PROT_HEAT will not. */
a101 9
  /* Elemental protection: 5% chance of escaping everything
   * (damage AND side-effects) */
  if (sus < 76 && number(1, 20) == 1) {
    act("&6$n's&6 spell passes over $N harmlessly.&0", FALSE, caster, 0, vict, TO_NOTVICT);
    act("&6Your spell passes over $N harmlessly!&0", FALSE, caster, 0, vict, TO_CHAR);
    act("&6$n's&6 spell passes over you harmlessly!&0", FALSE, caster, 0, vict, TO_VICT);
    return TRUE;
  }

d118 15
d2767 1
a2767 1
    if (evades_spell(ch, tch, spellnum))
d4292 4
@


1.188
log
@Don't allow blessing evil characters.  Lengthen the duration
of bless and dark presence to 10-24 hours.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.187 2008/03/27 17:30:17 jps Exp jps $
d37 1
a37 1
extern int roomaffect_allowed;
d72 1
a72 1
   if (AFF2_FLAGGED(vict, AFF2_MINOR_GLOBE | AFF2_MAJOR_GLOBE) &&
d76 2
a77 2
      if ((AFF2_FLAGGED(vict, AFF2_MINOR_GLOBE) && SINFO.lowest_level <= CIRCLE_3) ||
          (AFF2_FLAGGED(vict, AFF2_MAJOR_GLOBE) && SINFO.lowest_level <= CIRCLE_6)) {
d214 1
a214 1
  Can be used by any affect really with minor code change
d218 3
a220 3
  struct affected_type *af;
  struct affected_type *tmp;
  for (af = i->affected; af; af = tmp)
d222 2
a223 2
      tmp = af->next;
      if (af->type == 52)/*number for stone skin*/
d225 2
a226 2
          if (af->modifier > 1)
            af->modifier--;
d229 1
a229 1
              affect_remove(i, af);/*remove bit*/
d231 1
a231 1
            };
d238 2
a239 2
/* affect_update: called from comm.c (causes spells to wear off) */
void affect_update(void)
d241 2
a242 2
  struct raff_node *raff, *next_raff, *temp;
  static struct affected_type *af, *next;
d247 6
a252 6
    for (af = i->affected; af; af = next) {
      next = af->next;
      if (af->duration >= 1)
        af->duration--;
      else if (af->duration == -1)        /* No action */
        af->duration = -1;        /* GODs only! unlimited */
d254 5
a258 5
        if (af->type > 0 && af->type <= TOP_SKILL)
          if (!af->next || af->next->type != af->type ||
              af->next->duration > 0)
            if (skills[af->type].wearoff) {
              send_to_char(skills[af->type].wearoff, i);
d261 1
a261 1
        affect_remove(i, af);
d265 1
a265 1
    if (MOB_FLAGGED(i, MOB_ANIMATED) && !IS_AFFECTED3(i, AFF3_ANIMATED)) {
d271 1
a271 1
    if (MOB2_FLAGGED(i, MOB2_ILLUSORY) && !IS_AFFECTED3(i, AFF3_ANIMATED)) {
d277 2
a278 2
  for (raff = raff_list; raff; raff = next_raff) {
    next_raff = raff->next;
d280 1
a280 1
    raff->timer--;
d282 7
a288 7
    if (raff->timer <= 0) {
      /* this room affection has expired */
      if (ROOM_AFFECTED(raff->room, raff->affection) &&
          skills[raff->spell].wearoff) {
        send_to_room(skills[raff->spell].wearoff,
                     raff->room);
        send_to_room("\r\n", raff->room);
d291 9
a299 9
      /* remove the affection */
      if (ROOM_AFFECTED(raff->room, RAFF_DARKNESS))
         world[(int)raff->room].light++;
      if (ROOM_AFFECTED(raff->room, RAFF_ILLUMINATION))
         world[(int)raff->room].light--;
      REMOVE_BIT(world[(int)raff->room].room_affections,
                 raff->affection);
      REMOVE_FROM_LIST(raff, raff_list, next)
        free(raff);
d313 1
a313 1
int mag_materials(struct char_data * ch, int item0, int item1, int item2,
d480 1
a480 1
        AFF_FLAGGED(ch, AFF_CHARM) || MOB_FLAGGED(ch, MOB_PET)) {
d726 1
a726 1
    if (!AFF2_FLAGGED(victim, AFF2_LEVITATE) &&
d740 1
a740 1
    if (IS_AFFECTED2(victim, AFF2_LEVITATE))
d748 1
a748 1
    /* As Freezing wind is an area affect spell it's initial base damage will be low and slow
d750 1
a750 1
       ice based area affect spells. This spell will need some affect associated with it so it
d817 1
a817 1
      if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY)) { /* illusions don't really banish */
d878 1
a878 1
      if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY)) { /* illusions don't really banish */
d943 1
a943 1
      mag_affects(skill, ch, ch, SPELL_SOUL_TAP, savetype);
d976 1
a976 1
  if (IS_AFFECTED2(ch, AFF2_HARNESS)){
d982 1
a982 1
    affect_from_char(ch, SPELL_HARNESS);
d1004 1
a1004 1
        && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d1007 4
a1010 1
        !AFF2_FLAGGED(victim, AFF2_ON_FIRE | AFF2_PROT_FIRE | AFF2_NEGATE_HEAT | AFF2_COLDSHIELD)) {
d1018 1
a1018 1
        SET_BIT(AFF2_FLAGS(victim), AFF2_ON_FIRE);
d1040 4
a1043 2
        !AFF2_FLAGGED(victim, AFF2_PROT_COLD | AFF2_NEGATE_COLD | AFF2_FIRESHIELD)
        && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d1065 1
a1065 1
 * Every spell that does an affect comes through here.  This determines
d1069 1
a1069 1
 * affect_join(vict, aff, add_dur, avg_dur, add_mod, avg_mod, refresh)
d1077 1
a1077 1
#define MAX_SPELL_AFFECTS 8        /* change if more needed */
d1079 1
a1079 1
int mag_affects(int skill, struct char_data * ch, struct char_data * victim,
d1082 3
a1084 3
  struct affected_type af[MAX_SPELL_AFFECTS];
  struct affected_type *aff=NULL;
  bool accum_affect = FALSE, accum_duration = FALSE, is_innate = FALSE,
d1091 1
a1091 1
  if (MOB2_FLAGGED(ch, MOB2_ILLUSORY) && ch != victim)
d1093 2
a1094 2
  if((ch->casting.misc) && *(ch->casting.misc))
    half_chop(ch->casting.misc,buf,buf2);
d1096 3
a1098 8
  for (i = 0; i < MAX_SPELL_AFFECTS; i++) {
    af[i].type = spellnum;
    af[i].bitvector = 0;
    af[i].bitvector2 = 0;
    af[i].bitvector3 = 0;
    af[i].modifier = 0;
    af[i].location = APPLY_NONE;
  }
d1108 3
a1110 3
    af[0].location = APPLY_AC;
    af[0].modifier = -5 - (skill / 14); /* max -12 */
    af[0].duration = 5 + (skill / 20); /* max 10 */
d1117 2
a1118 2
    af[0].bitvector2 = AFF2_NEGATE_HEAT;
    af[0].duration = 2 + (skill / 20); /* max 7 */
d1126 2
a1127 2
    af[0].bitvector2 = AFF2_NEGATE_COLD;
    af[0].duration = 2 + (skill / 20); /* max 7 */
d1140 3
a1142 3
    af[0].location = APPLY_COMPOSITION;
    af[0].modifier = COMP_WATER;
    af[0].duration = 2 + (skill / 20); /* max 7 */
d1155 3
a1157 3
    af[0].location = APPLY_COMPOSITION;
    af[0].modifier = COMP_MIST;
    af[0].duration = 2 + (skill / 25); /* max 6 */
d1169 3
a1171 3
    af[0].location = APPLY_AC;
    af[0].modifier = -5 - (skill / 16); /* max -11 */
    af[0].duration = 5 + (skill / 25); /* max 9 */
d1187 6
a1192 6
      af[0].location = APPLY_HITROLL;
      af[0].modifier = -1;
      af[0].duration = 0;
      af[1].location = APPLY_AC;
      af[1].modifier = 10;
      af[1].duration = 0;
d1199 8
a1206 8
      af[0].location = APPLY_HITROLL;
      af[0].modifier = -4;
      af[0].duration = 2;
      af[0].bitvector = AFF_BLIND;
      af[1].location = APPLY_AC;
      af[1].modifier = 40;
      af[1].duration = 2;
      af[1].bitvector = AFF_BLIND;
d1220 3
a1222 3
    af[0].location = APPLY_AC;
    af[0].modifier = -15 - (skill / 16); /* max -21 */
    af[0].duration = 5 + (skill / 14); /* max 12 */
d1249 2
a1250 2
      af[0].bitvector = AFF_MAJOR_PARA;
      af[0].duration = 2 + (skill > 95);
d1253 2
a1254 2
      af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
      af[0].duration = 2 + (skill / 24);
d1268 3
a1270 3
    af[0].location = APPLY_AC;
    af[0].modifier = -7 - (skill / 9); /* max -18 */
    af[0].duration = 5 + (skill / 10); /* max 15 */
d1285 2
a1286 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = (skill / 21); /* max 4 */
d1307 3
a1309 3
    af[0].location = APPLY_SAVING_SPELL;
    af[0].modifier = -2 - (skill / 10);
    af[0].duration = 10 + (skill / 7); /* 10-24 hrs */
d1319 3
a1321 3
      af[1].location = APPLY_DAMROLL;
      af[1].modifier = 1 + (skill > 95);
      af[1].duration = af[0].duration;
d1329 2
a1330 2
    af[2].bitvector3 = AFF3_HEX;
    af[2].duration = af[0].duration;
d1346 4
a1349 4
      af[0].location = APPLY_AC;
      af[0].modifier = -8;
      af[0].duration = 5;
      af[0].bitvector2 = AFF2_PROT_FIRE;
d1352 4
a1355 4
      af[0].location = APPLY_AC;
      af[0].modifier = -10 - (skill / 20);
      af[0].duration = 10 + (skill / 50);
      af[0].bitvector2 = AFF2_PROT_FIRE;
d1372 7
a1378 7
    af[0].location = APPLY_CON;
    af[0].modifier = -10 - (skill / 10);
    af[0].duration = 5 + (skill / 10);
    af[0].bitvector2 = AFF2_DISEASE;
    af[1].location = APPLY_STR;
    af[1].modifier = af[0].modifier;
    af[1].duration = af[0].duration;
d1394 4
a1397 4
    af[0].bitvector2 = AFF2_INSANITY;
    af[0].location = APPLY_WIS;
    af[0].modifier = -50;
    af[0].duration = 5;
d1412 1
a1412 1
    af[0].location = APPLY_HIT;
d1414 5
a1418 5
    af[0].modifier = skill / (1 + ((100 - skill) / 25));
    af[0].duration = 5 + (skill / 20); /* max 10 */
    af[1].location = APPLY_STR;
    af[1].modifier = 5 + (skill / 14); /* max 12 */
    af[1].duration = af[0].duration;
d1421 1
a1421 1
    af[0].modifier *= GET_ALIGNMENT(victim) / -1000.0;
d1428 1
a1428 1
      af[0].modifier *= 2.5;
d1441 2
a1442 2
    af[0].bitvector = AFF_FLYING;
    af[0].duration = 10 + (skill / 5);
d1467 3
a1469 3
    af[0].location = APPLY_HIT;
    af[0].modifier = get_vitality_hp_gain(ch, spellnum);
    af[0].duration = get_spell_duration(ch, spellnum);
d1483 2
a1484 2
    af[0].bitvector = AFF_FLYING;
    af[0].duration = 10 + (skill / 5); /* max 30 */
a1491 8
  case SPELL_SPEAK_IN_TONGUES:

    af[0].bitvector2 = AFF2_TONGUES;
    af[0].duration = 10 + (skill / 5); /* max 30 */
    to_vict = "You feel ready to speak in any language.";
    to_room = "$n's head glowls for a moment.";
    break;

d1495 1
a1495 1
      af[0].bitvector2 = AFF2_PROT_FIRE;
d1499 1
a1499 1
      af[0].bitvector2 = AFF2_PROT_COLD;
d1503 1
a1503 1
      af[0].bitvector2 = AFF2_PROT_AIR;
d1507 1
a1507 1
      af[0].bitvector2 = AFF2_PROT_EARTH;
d1515 1
a1515 1
    af[0].duration = 5 + (skill / 14); /* max 12 */
d1522 1
a1522 1
    af[0].location = APPLY_HIT;
d1524 5
a1528 5
    af[0].modifier = skill / (1 + ((100 - skill) / 30));
    af[0].duration = 5 + (skill / 14); /* max 12 */
    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -5 - (skill / 14); /* max -12 */
    af[1].duration = af[0].duration;
d1531 1
a1531 1
    af[0].modifier *= GET_ALIGNMENT(victim) / 1000.0;
d1539 2
a1540 2
    af[0].bitvector2 = AFF2_LIGHT;
    af[0].duration = 5 + (skill / 2); /* max 55 */
d1548 2
a1549 2
    af[0].bitvector2 = AFF2_LIGHT;
    af[0].duration = 5 + (skill / 2); /* max 55 */
d1557 1
a1557 1
    if (AFF2_FLAGGED(victim, AFF2_HARNESS)) {
d1562 2
a1563 2
    af[0].bitvector2 = AFF2_HARNESS;
    af[0].duration = (skill >= 20); /* max 1 */
d1571 1
a1571 1
    if (AFF2_FLAGGED(victim, AFF2_MAJOR_GLOBE)) {
d1578 2
a1579 2
    af[0].bitvector2 = AFF2_MINOR_GLOBE;
    af[0].duration = skill / 20; /* max 5 */
d1588 1
a1588 1
    if (AFF2_FLAGGED(victim, AFF2_MINOR_GLOBE)) {
d1595 2
a1596 2
    af[0].bitvector2 = AFF2_MAJOR_GLOBE;
    af[0].duration = 4 + (skill / 20); /* max 9 */
d1605 1
a1605 1
    if (AFF2_FLAGGED(ch, AFF2_FIRESHIELD)) {
d1610 2
a1611 2
    af[0].bitvector2 = AFF2_COLDSHIELD;
    af[0].duration = skill / 20; /* max 5 */
d1619 1
a1619 1
    if (AFF2_FLAGGED(ch, AFF2_COLDSHIELD)) {
d1624 2
a1625 2
    af[0].bitvector2 = AFF2_FIRESHIELD;
    af[0].duration = skill / 20; /* max 5 */
d1650 2
a1651 2
    af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
    af[0].duration = 2 + (skill / 15); /* max 8 */
d1661 1
a1661 1
    if (AFF3_FLAGGED(victim, AFF3_RAY_OF_ENFEEB)) {
d1674 4
a1677 4
    af[0].location = APPLY_STR;
    af[0].duration = 8 + (skill / 12); /* max 20 */
    af[0].modifier = -15 - (skill / 10); /* max -25 */
    af[0].bitvector3 = AFF3_RAY_OF_ENFEEB;
d1685 2
a1686 2
    af[0].bitvector2 = AFF2_LEVITATE;
    af[0].duration = 5 + (skill / 10);
d1702 3
a1704 3
    af[0].location = APPLY_STR;
    af[0].duration = 3 + (skill / 20); /* max 8 */
    af[0].modifier = -5 - (skill / 10); /* max -15 */
d1717 3
a1719 3
    af[0].location = APPLY_AC;
    af[0].modifier = -10 - (skill / 20); /* max -15 */
    af[0].duration = 10 + (skill / 50); /* max 12 */
d1740 2
a1741 2
    af[0].bitvector2 = AFF2_SILENCE;
    af[0].duration = 2 + (skill / 15); /* max 8 */
d1749 2
a1750 2
    af[0].bitvector2 = AFF2_SOULSHIELD;
    af[0].duration = 2 + (skill / 10); /* max 12 */
d1773 12
a1784 12
    af[0].location = APPLY_SIZE;
    af[0].modifier = -1;
    af[0].bitvector3 = AFF3_REDUCE;
    af[0].duration = 1 + (skill / 40);

    af[1].location = APPLY_CON;
    af[1].modifier = -10;
    af[1].duration = af[0].duration;

    af[2].location = APPLY_STR;
    af[2].modifier = -10;
    af[2].duration = af[0].duration;
d1796 12
a1807 12
    af[0].location = APPLY_SIZE;
    af[0].modifier = 1;
    af[0].bitvector3 = AFF3_ENLARGE;
    af[0].duration = 1 + (skill / 40);

    af[1].location = APPLY_CON;
    af[1].modifier = 10;
    af[1].duration = af[0].duration;

    af[2].location = APPLY_STR;
    af[2].modifier = 10;
    af[2].duration = af[0].duration;
d1821 4
a1824 4
    af[0].location = APPLY_NONE;
    af[0].modifier = 7 + (skill / 16); /* max 13 */
    af[0].duration = 2;
    af[0].bitvector = AFF_STONE_SKIN;
d1834 2
a1835 2
    af[0].bitvector = AFF_HASTE;
    af[0].duration = 2 + (skill / 21); /* max 6 */
d1843 2
a1844 2
    af[0].bitvector = AFF_BLUR;
    af[0].duration = 2 + (skill / 21); /* max 6 */
a1848 8
  case SPELL_COMPREHEND_LANG:

    af[0].bitvector = AFF_COMP_LANG;
    af[0].duration = 5 + (skill / 10); /* max 15 */
    to_room = "&7&b$N&7&b glows briefly.&0";
    to_vict = "&8You feel your knowledge of Ethilien's languages improving!&0";
    break;

d1869 8
a1876 8
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 1 + (skill >= 50);
    af[0].duration = 10 + (skill / 7); /* 10-24 hrs */
    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -2 - (skill / 10);
    af[1].duration = af[0].duration;
    af[2].bitvector3 = AFF3_BLESS;
    af[2].duration = af[0].duration;
d1897 9
a1905 9
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;
d1929 9
a1937 9
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;
d1956 8
a1963 8
    af[0].location = APPLY_HITROLL;
    af[0].duration = 5 + (skill / 14); /* max 12 */
    af[0].modifier = -1 - (skill / 50); /* max -3 */
    af[0].bitvector = AFF_CURSE;
    af[1].location = APPLY_DAMROLL;
    af[1].duration = af[0].duration;
    af[1].modifier = af[0].modifier;
    accum_affect = TRUE;
d1971 2
a1972 2
    af[0].bitvector = AFF_DETECT_ALIGN;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d1980 4
a1983 4
    af[0].bitvector = AFF_DETECT_INVIS;
    af[0].location = APPLY_PERCEPTION;
    af[0].modifier = 10;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d1989 2
a1990 2
    af[0].bitvector = AFF_DETECT_MAGIC;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d2008 2
a2009 2
    af[0].bitvector = AFF_INFRAVISION;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d2017 5
a2021 5
    af[0].type = SPELL_INVISIBLE;
    af[0].modifier = -40;
    af[0].duration = 9 + (skill / 9); /* max 20 */
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
d2041 5
a2045 5
    af[0].location = APPLY_STR;
    af[0].modifier = (-2 - (skill / 4) - (skill / 20)) * susceptibility(victim, DAM_POISON) / 100; /* max -32 */
    af[0].bitvector = AFF_POISON;
    af[0].duration = 4 + (skill / 3); /* max 37 */
    af[0].type = SPELL_POISON;
d2061 2
a2062 2
    af[0].bitvector = AFF_PROTECT_EVIL;
    af[0].duration = 9 + (skill / 9); /* max 20 */
d2073 2
a2074 2
    af[0].duration = 4;
    af[0].bitvector = AFF_SANCTUARY;
d2107 2
a2108 2
    af[0].bitvector = AFF_SLEEP;
    af[0].duration = 9 + (skill / 9); /* max 20 */
d2124 3
a2126 3
    af[0].location = APPLY_STR;
    af[0].modifier = 2 + (skill / 8); /* max 14 */
    af[0].duration = 5 + (skill / 14); /* max 12 */
d2132 4
a2135 4
    af[0].location = APPLY_STR;
    af[0].duration = (skill >> 1) + 4;
    af[0].modifier = 1 + (skill / 18); /* max 6 */
    accum_affect = FALSE;
d2142 2
a2143 2
    af[0].bitvector = AFF_SENSE_LIFE;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d2150 2
a2151 2
    af[0].bitvector = AFF_WATERWALK;
    af[0].duration = 12 + (skill / 8); /* max 24 */
d2158 2
a2159 2
    af[0].bitvector = AFF_FLYING;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d2169 2
a2170 2
    af[0].bitvector = AFF_FARSEE;
    af[0].duration = 5 + (skill / 10); /* max 15 */
d2180 3
a2182 3
    af[0].location = APPLY_AC;
    af[0].modifier = -10 - (skill / 6); /* max -25 */
    af[0].duration = 8 + 2 * (skill / 5); /* max 48 */
d2208 6
a2213 6
    af[0].location = APPLY_STR;
    af[1].location = APPLY_CON;
    af[2].location = APPLY_AC;
    af[0].modifier = af[1].modifier = - skill / 5; /* Max -20 */
    af[2].modifier = skill / 5 * 2; /* Max 40 */
    af[0].duration = af[1].duration = af[2].duration = skill / 10; /* Max 10 */
d2222 1
a2222 1
     * mag_damage, because the affection is applied to the caster,
d2227 3
a2229 3
      struct affected_type *af;
      for (af = victim->affected; af; af = af->next)
        if (af->type == SPELL_SOUL_TAP && af->modifier >= skill / 2)
d2233 3
a2235 3
    af[0].location = APPLY_HIT_REGEN;
    af[0].modifier = af[0].duration = skill / 10; /* Max 10 */
    accum_affect = TRUE;
d2239 2
a2240 2
    af[0].location = APPLY_HITROLL;
    af[0].modifier = af[0].duration = (skill / 20) + 1;  /* range (1, 6) */
d2247 2
a2248 2
    af[0].bitvector3 = AFF3_CAMOUFLAGED;
    af[0].duration = (skill / 3) + 1; /* range (1, 34) */
d2254 2
a2255 2
    af[0].bitvector3 = AFF3_MISDIRECTION;
    af[0].duration = 2 + skill / 4;
d2260 3
a2262 3
    af[0].location = APPLY_HIT_REGEN;
    af[0].duration = skill / 2 + 3;
    af[0].modifier = skill / 2 + 10;
d2268 6
a2273 6
    af[0].location = APPLY_HITROLL;
    af[0].modifier = skill / 25 + 1;
    af[0].duration = skill / 25 + 1;
    af[1].location = APPLY_DAMROLL;
    af[1].modifier = skill / 25 + 1;
    af[1].duration = skill / 25 + 1;
d2282 6
a2287 6
    af[0].location = APPLY_HITROLL;
    af[0].modifier = skill / 25 + 1;
    af[0].duration = skill / 25 + 1;
    af[1].location = APPLY_DAMROLL;
    af[1].modifier = skill / 25 + 1;
    af[1].duration = skill / 25 + 1;
d2295 1
a2295 1
     * mag_masses won't pass to mag_affects if it doesn't pass attack_ok
d2307 4
a2310 4
    af[0].location = APPLY_HITROLL;
    af[0].duration = 5 + (skill / 14); /* max 12 */
    af[0].modifier = -1 - (skill / 10); /* max -11 */
    accum_affect = TRUE;
d2321 3
a2323 3
    af[0].location = APPLY_AC;
    af[0].duration = 5 + (skill / 30); /* max 8 */
    af[0].modifier = 10 + (skill / 2); /* max 60: positive is bad */
d2332 1
a2332 1
     * mag_masses checks attack_ok before calling mag_affects
d2334 5
a2338 5
    af[0].location = APPLY_SAVING_PARA;
    af[1].location = APPLY_SAVING_ROD;
    af[2].location = APPLY_SAVING_PETRI;
    af[3].location = APPLY_SAVING_BREATH;
    af[4].location = APPLY_SAVING_SPELL;
d2340 7
a2346 7
    af[0].duration = af[1].duration = af[2].duration = af[3].duration =
    af[4].duration = 1 + (skill / 20); /* max 6 */
    af[0].modifier = (skill / 7) + number(0, 6); /* max 20 */
    af[1].modifier = (skill / 7) + number(0, 6); /* max 20 */
    af[2].modifier = (skill / 7) + number(0, 6); /* max 20 */
    af[3].modifier = (skill / 7) + number(0, 6); /* max 20 */
    af[4].modifier = (skill / 7) + number(0, 6); /* max 20 */
d2361 7
a2367 7
    af[0].bitvector2 = AFF2_DISEASE;
    af[0].location = APPLY_CON;
    af[0].modifier = -(skill * GET_VIEWED_CON(victim) / 2) / 100;
    af[0].duration = (skill / 20); /* max 5 */
    af[1].location = APPLY_STR;
    af[1].modifier = -(skill * GET_VIEWED_STR(victim) / 2) / 100;
    af[1].duration = (skill / 20); /* max 5 */
d2374 2
a2375 2
    af[0].bitvector3 = AFF3_SPIRIT_WOLF;
    af[0].duration = (skill / 20); /* max 5 */
d2381 2
a2382 2
    af[0].bitvector3 = AFF3_SPIRIT_BEAR;
    af[0].duration = (skill / 20); /* max 5 */
d2388 2
a2389 2
    af[0].bitvector3 = AFF3_WRATH;
    af[0].duration = (skill / 20); /* max 5 */
d2397 1
a2397 1
   * If this is a mob that has this affect set in its mob file, do not
d2402 2
a2403 4
     for (i = 0; i < MAX_SPELL_AFFECTS; ++i)
       if (AFF_FLAGGED(victim, af[i].bitvector) ||
           AFF2_FLAGGED(victim, af[i].bitvector2) ||
           AFF3_FLAGGED(victim, af[i].bitvector3)) {
d2412 1
a2412 1
   if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect||refresh)) {
d2417 3
a2419 3
   for (aff = victim->affected; aff && !is_innate; aff = aff->next) {
     if (spellnum == aff->type && aff->duration == -1)
       is_innate=TRUE;
d2427 1
a2427 1
   /* act() for the message buffers in mag_affects() */
d2429 1
a2429 1
   if(!affected_by_spell(victim,spellnum))
d2443 19
a2461 3
   for (i = 0; i < MAX_SPELL_AFFECTS; i++)
     if (af[i].bitvector || af[i].bitvector2 || af[i].bitvector3 || (af[i].location != APPLY_NONE))
       affect_join(victim, af+i, accum_duration, FALSE, accum_affect, FALSE, refresh);
a2463 16
   if (CASTING(victim)) {
      if (af[0].bitvector2 == AFF2_SILENCE) {
         STOP_CASTING(victim);
         act("Your spell collapses.", FALSE, victim, 0, 0, TO_CHAR);
         act("$n continues silently moving $s lips for a moment before giving up.",
               FALSE, victim, 0, 0, TO_ROOM);
      } else if (af[0].bitvector2 == AFF2_MINOR_PARALYSIS ||
            af[0].bitvector == AFF_MAJOR_PARA) {
         /* Just silently stop the casting for paralysis */
         STOP_CASTING(victim);
      }
   }
   if ((af[0].bitvector2 == AFF2_MINOR_PARALYSIS || af[0].bitvector == AFF_MAJOR_PARA)
         && IS_FIGHTING(victim)) {
      stop_fighting(victim);
   }
d2469 1
a2469 1
 * This function is used to provide services to mag_groups.  This function
d2473 1
a2473 1
void perform_mag_groups(int skill, struct char_data * ch,
d2478 2
a2479 2
    mag_points(skill, ch, tch, SPELL_HEAL, savetype);
    mag_unaffects(skill, ch, tch, SPELL_HEAL, savetype);
d2482 1
a2482 1
    mag_affects(skill, ch, tch, SPELL_ARMOR, savetype);
d2488 2
a2489 2
    mag_affects(skill, ch, tch, SPELL_GREATER_ENDURANCE, savetype);
    mag_affects(skill, ch, tch, SPELL_BLESS, savetype);
d2492 1
a2492 1
    mag_points(skill, ch, tch, SPELL_INVIGORATE, savetype);
d2495 1
a2495 1
    mag_affects(skill, ch, tch, CHANT_WAR_CRY, savetype);
d2503 1
a2503 1
 * perform_mag_groups contains the switch statement to send us to the right
d2510 1
a2510 1
 * mag_groups -- just add a new case to perform_mag_groups.
d2516 1
a2516 1
int mag_groups(int skill, struct char_data * ch, int spellnum, int savetype)
d2524 1
a2524 1
  if (!AFF_FLAGGED(ch, AFF_GROUP))
d2550 1
a2550 1
      perform_mag_groups(skill, ch, tch, spellnum, savetype);
d2558 1
a2558 1
 * These are often offensive spells.  This calls mag_affects to do the
d2560 1
a2560 1
 * mag_affects() in order for them to work.
d2563 1
a2563 1
int mag_masses(int skill, struct char_data * ch, int spellnum, int savetype)
d2587 1
a2587 1
    mag_affects(skill, ch, tch, spellnum, savetype);
d2620 1
a2620 1
    mag_alter_objs(skill, ch, tobj, spellnum, savetype);
d2640 1
a2640 1
int mag_areas(int skill, struct char_data * ch, int spellnum, int savetype)
d2748 1
a2748 1
    if (!roomaffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
d2788 7
a2794 7
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_EVIL);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_GOOD);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_NEUTRAL);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_EVIL_RACE);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_GOOD_RACE);
  SET_BIT(MOB_FLAGS(mob), MOB_ANIMATED);
d3016 1
a3016 1
  SET_BIT(MOB2_FLAGS(new_mob), MOB2_NOSCRIPT);  /* Prevent specprocs and triggers */
d3054 1
a3054 1
    if (IS_AFFECTED(foll->follower, AFF_CHARM)) {
d3145 1
a3145 1
   new_mob->char_specials.act = model->char_specials.act;
d3156 1
a3156 1
   REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SPEC);
d3168 4
a3171 4
   MOB_FLAGS(new_mob) = 0;
   SET_BIT(MOB_FLAGS(new_mob), MOB_ISNPC);
   SET_BIT(MOB_FLAGS(new_mob), MOB_SCAVENGER);
   SET_BIT(MOB_FLAGS(new_mob), MOB_MEMORY);
d3184 1
a3184 1
   struct affected_type effect;
d3186 1
a3186 1
   SET_BIT(MOB2_FLAGS(ch), MOB2_ILLUSORY);   /* Make it an illusion */
d3190 1
d3193 2
a3194 6
      effect.bitvector = 0;
      effect.bitvector2 = 0;
      effect.bitvector3 = AFF3_ANIMATED;
      effect.modifier = 0;
      effect.location = APPLY_NONE;
      affect_to_char(ch, &effect);
d3231 1
a3231 1
   SET_BIT(MOB2_FLAGS(new_mob), MOB2_NOSCRIPT);  /* Prevent specprocs and triggers */
d3242 1
a3242 1
int mag_summons(int skill, struct char_data *ch, struct char_data *vict,
d3249 1
a3249 1
  struct affected_type af;
d3262 1
a3262 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && !MOB_FLAGGED(ch, MOB_ANIMATED)) {
d3314 1
a3314 1
    if(IS_AFFECTED(new_mob, AFF_STONE_SKIN))
d3318 7
a3324 8
    af.type = SPELL_ANIMATE_DEAD;
    af.duration =  (int)(base_duration * preserve_mult);
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_ANIMATED;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(new_mob, &af);
d3329 6
a3334 8
      af.type = SPELL_CHARM;
      af.duration =  (int)(base_duration * preserve_mult) + 1;
      af.bitvector = AFF_CHARM;
      af.bitvector2 = 0;
      af.bitvector3 = 0;
      af.modifier = 0;
      af.location = APPLY_NONE;
      affect_to_char(new_mob, &af);
d3336 2
a3337 2
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGRESSIVE);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SPEC);
d3344 6
a3349 6
      SET_BIT(MOB_FLAGS(new_mob), MOB_AGGRESSIVE);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_EVIL);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_GOOD);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_NEUTRAL);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_EVIL_RACE);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_GOOD_RACE);
d3430 1
a3430 1
       SET_BIT(MOB2_FLAGS(new_mob), MOB2_PLAYER_PHANTASM);
d3441 1
a3441 1
    SET_BIT(MOB2_FLAGS(new_mob), MOB2_NOSCRIPT);  /* Prevent specprocs and triggers */
d3453 1
a3453 1
/* mag_points
d3460 1
a3460 1
int mag_points(int skill, struct char_data * ch, struct char_data * victim, int spellnum, int savetype) {
d3561 1
a3561 1
    log("SYSERR:magic.c:mag_points():invalid spell");
d3585 1
a3585 1
/* mag_unaffects
d3590 1
a3590 1
int mag_unaffects(int skill, struct char_data * ch, struct char_data * victim,
d3601 1
a3601 1
    REMOVE_BIT(AFF2_FLAGS(victim), AFF2_ON_FIRE);
d3609 1
a3609 1
    if (!AFF3_FLAGGED(victim, AFF3_REDUCE))
d3615 1
a3615 1
    if (!AFF3_FLAGGED(victim, AFF3_ENLARGE))
d3623 1
a3623 1
    if (AFF_FLAGGED(victim, AFF_BLIND)) {
d3630 1
a3630 1
          affect_from_char(victim, spell);
d3634 3
a3636 2
        if (spell) /* If already removing a spell, remove sunray now */
          affect_from_char(victim, spell);
d3642 1
a3642 1
      affect_from_char(victim, SPELL_DISEASE);
d3656 1
a3656 1
    sprintf(buf, "SYSERR: unknown spellnum %d passed to mag_unaffects", spellnum);
d3666 1
a3666 1
  affect_from_char(victim, spell);
d3681 1
a3681 1
int mag_alter_objs(int skill, struct char_data * ch, struct obj_data * obj,
d3696 1
a3696 1
       if (GET_OBJ_SPELL3(obj) & AFF3_HEX) {
d3699 1
a3699 1
         SET_BIT(GET_OBJ_SPELL3(obj), AFF3_HEX);
d3706 2
a3707 2
     for (i = 0; i < MAX_OBJ_AFFECT; i++) {
        if (obj->affected[i].location) {
d3738 1
a3738 4
    else if (
          GET_OBJ_SPELL(obj) ||
          GET_OBJ_SPELL2(obj) ||
          GET_OBJ_SPELL3(obj) ||
d3743 1
a3743 1
      SET_BIT(GET_OBJ_SPELL3(obj), AFF3_HEX);
d3752 1
a3752 1
       if (GET_OBJ_SPELL3(obj) & AFF3_BLESS) {
d3755 1
a3755 1
         SET_BIT(GET_OBJ_SPELL3(obj), AFF3_BLESS);
d3764 2
a3765 2
     for (i = 0; i < MAX_OBJ_AFFECT; i++) {
        if (obj->affected[i].location) {
d3794 1
a3794 4
    else if (
          GET_OBJ_SPELL(obj) ||
          GET_OBJ_SPELL2(obj) ||
          GET_OBJ_SPELL3(obj) ||
d3799 1
a3799 1
      SET_BIT(GET_OBJ_SPELL3(obj), AFF3_BLESS);
d3862 1
a3862 1
int mag_creations(int skill, struct char_data * ch, int spellnum)
d3937 1
a3937 1
  long aff; /* what affection */
d3941 1
a3941 1
  struct raff_node *raff;
d3943 1
a3943 1
  aff = ticks =0;
d3952 1
a3952 1
    aff = RAFF_FOG;
d3956 1
a3956 1
    if(SECT(ch->in_room) == SECT_FOREST || ROOM_AFFECTED(ch->in_room, RAFF_FOREST)) {
d3960 1
a3960 1
    aff = RAFF_FOREST;
d3966 1
a3966 1
    if (ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE)) {
d3977 1
a3977 1
    aff = RAFF_CIRCLE_FIRE;
d3988 1
a3988 1
            "passed to mag_unaffects", spellnum);
d3994 7
a4000 7
  CREATE(raff, struct raff_node, 1);
  raff->room = ch->in_room;
  raff->timer = ticks;
  raff->affection = aff;
  raff->spell = spellnum;
  raff->next = raff_list;
  raff_list = raff;
d4003 2
a4004 2
  if (aff != 0)
    SET_BIT(ROOM_AFFECTIONS(raff->room), aff);
d4253 1
a4253 1
         if (GET_OBJ_VAL(wall, 3) == SPELL_WALL_OF_ICE && AFF2_FLAGGED(motivator, AFF2_ON_FIRE)) {
d4258 2
a4259 2
            REMOVE_BIT(AFF2_FLAGS(motivator), AFF2_ON_FIRE);
         } else if (GET_OBJ_VAL(wall, 3) == SPELL_WALL_OF_ICE && AFF2_FLAGGED(actor, AFF2_ON_FIRE)) {
d4264 1
a4264 1
            REMOVE_BIT(AFF2_FLAGS(actor), AFF2_ON_FIRE);
d4285 4
@


1.187
log
@Dark presence now sets AFF3_HEX. It also places it on objects.
A hexed weapon will become !GOOD and a blessed weapon will
become !EVIL.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.186 2008/03/26 23:12:19 jps Exp jps $
d1309 1
a1309 1
    af[0].duration = 5 + (skill / 14);
d1877 8
d1887 1
a1887 1
    af[0].duration = 5 + (skill / 14); /* max 12 */
d4314 5
@


1.186
log
@Changed the waterform and vaporform spells to change your composition
rather than setting flags.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.185 2008/03/26 22:01:10 jps Exp jps $
a304 1

d1329 2
d3702 1
d3708 59
d3770 1
a3770 1
       if (IS_OBJ_STAT(obj, ITEM_BLESS)) {
d3773 2
a3774 1
         SET_BIT(GET_OBJ_EXTRA(obj), ITEM_BLESS);
d3780 2
d3790 4
d3795 1
a3795 1
    if (GET_OBJ_LEVEL(obj) > skill)
d3803 1
a3803 2
    else if (IS_OBJ_STAT(obj, ITEM_BLESS) ||
        IS_OBJ_STAT(obj, ITEM_GLOW) ||
d3820 2
a3821 1
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_BLESS);
d3823 1
d3877 1
a3877 1
  return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
d4306 4
@


1.185
log
@Adding mag_damage for dispel magic, like a 3rd circle spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.184 2008/03/26 19:16:17 jps Exp jps $
d1136 2
a1137 2
    if (AFF3_FLAGGED(victim, AFF3_VAPORFORM)) {
      send_to_char("Your body is already in a vapory form!\r\n", victim);
d1141 2
a1142 1
    af[0].bitvector2 = AFF2_WATERFORM;
d1151 2
a1152 2
    if (AFF2_FLAGGED(victim, AFF2_WATERFORM)) {
      send_to_char("Your body is already in a watery form!\r\n", victim);
d1156 2
a1157 3
    af[0].bitvector3 = AFF3_VAPORFORM;
    af[0].location = APPLY_AC;
    af[0].modifier = -10 * (skill / 20); /* max -50 */
d4237 3
@


1.184
log
@Fix susceptibility check - the VICTIM not the attacker!
Also move damage reduction past harness check so that all of
the damage is subject to reduction.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.183 2008/03/26 19:09:27 jps Exp jps $
d530 4
d4237 5
@


1.183
log
@Change the bless spell so that it's very picky about what can
be blessed. Essentially, it has to be devoid of enchantments
and be rather plain. It can't be !GOOD or too high level
compared to the casting power.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.182 2008/03/26 18:15:59 jps Exp jps $
d445 1
a445 1
  sus = susceptibility(ch, skills[spellnum].damage_type);
a967 3
  /* Adjust the damage according to the susceptibility */
  dam = dam * sus / 100;

d982 3
d4233 6
@


1.182
log
@Adding a BLESS effect to a creature who gets bless cast on it.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.181 2008/03/26 16:44:36 jps Exp jps $
d1878 1
a1878 1
    af[2].bitvector2 = AFF3_BLESS;
d3696 1
d3703 46
a3748 2
    if (!IS_OBJ_STAT(obj, ITEM_BLESS) &&
        (GET_OBJ_WEIGHT(obj) <= 5 * skill)) {
d4233 3
@


1.181
log
@Replaced all checks for undead race with checks for undead lifeforce.
Replaced the undead race with the plant race.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.180 2008/03/24 08:42:04 jps Exp jps $
d1878 2
d2033 1
a2033 1
    if (GET_LEVEL(victim) >= LVL_IMMORT || damage_evasion(victim, DAM_POISON)) {
d4188 4
@


1.180
log
@Removing protected_from_spell() and immune_from_spell().
Changing the way undead servants are generated, since the race
of undead is soon to be no more.
Taking into account composition-susceptibility to magical
damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.179 2008/03/23 18:42:39 jps Exp jps $
d753 1
a753 1
    if (GET_RACE(victim) != RACE_UNDEAD) {
d933 1
a933 1
    if (GET_RACE(victim) == RACE_UNDEAD) {
d2193 1
a2193 1
    if (GET_RACE(victim) != RACE_UNDEAD) {
d4186 7
@


1.179
log
@Using the new damage types defined in chars.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.178 2008/03/22 16:42:45 jps Exp jps $
a55 51
bool protected_from_spell(struct char_data *ch, int spell)
{
  switch(skills[spell].damage_type) {
  case DAM_FIRE:
    if(AFF2_FLAGGED(ch, AFF2_PROT_FIRE))
      return TRUE;
    break;
  case DAM_WATER:
    if(AFF2_FLAGGED(ch, AFF2_PROT_COLD))
      return TRUE;
    break;
  case DAM_AIR:
    if(AFF2_FLAGGED(ch, AFF2_PROT_AIR))
      return TRUE;
    break;
  case DAM_EARTH:
    if(AFF2_FLAGGED(ch, AFF2_PROT_EARTH))
      return TRUE;
    break;
  default:
    return FALSE;
  }
  return FALSE;
}

bool immune_from_spell(struct char_data *ch, int spell)
{
  switch(skills[spell].damage_type) {
  case DAM_FIRE:
    if (AFF2_FLAGGED(ch, AFF2_NEGATE_HEAT))
      return TRUE;
    break;
  case DAM_WATER:
    if (AFF2_FLAGGED(ch, AFF2_NEGATE_COLD))
      return TRUE;
    break;
  case DAM_AIR:
    if (AFF2_FLAGGED(ch, AFF2_NEGATE_AIR))
      return TRUE;
    break;
  case DAM_EARTH:
    if (AFF2_FLAGGED(ch, AFF2_NEGATE_EARTH))
      return TRUE;
    break;
  default:
    return FALSE;
  }
  return FALSE;
}


d65 2
d88 2
d94 1
a94 1
  if (immune_from_spell(vict, spellnum)) {
d103 1
a103 1
  if (protected_from_spell(vict, spellnum) && number(1, 20) == 1) {
d130 2
a131 1
void abort_casting(struct char_data *ch) {
d142 2
a143 1
struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output) {
d440 1
d445 1
d968 2
a969 3
  /* 3/4 damage if player has protection from spell damage */
  if (protected_from_spell(victim, spellnum))
    dam -= dam >> 2;
d985 2
a986 17
   /* Cause extra damage if you have an opposing resistance */
   if (
         (skills[spellnum].damage_type == DAM_FIRE &&
         AFF2_FLAGGED(victim, AFF2_PROT_COLD))
            ||
         (skills[spellnum].damage_type == DAM_WATER &&
         AFF2_FLAGGED(victim, AFF2_PROT_FIRE))
            ||
         ((skills[spellnum].damage_type == DAM_AIR ||
          skills[spellnum].damage_type == DAM_AIR)
         &&
         AFF2_FLAGGED(victim, AFF2_PROT_EARTH))
            ||
         (skills[spellnum].damage_type == DAM_EARTH &&
         AFF2_FLAGGED(victim, AFF2_PROT_AIR))
      ) {
      dam += dam / 8; /* 1/8 extra pain for you */
d988 1
a988 1
         act("$n cringes with a pained look on $s face.",
d990 2
a991 18
   }
   /* Cause worse extra damage if you have an opposing immunity */
   if (
         (skills[spellnum].damage_type == DAM_FIRE &&
         AFF2_FLAGGED(victim, AFF2_NEGATE_COLD))
            ||
         (skills[spellnum].damage_type == DAM_WATER &&
         AFF2_FLAGGED(victim, AFF2_NEGATE_HEAT))
            ||
         ((skills[spellnum].damage_type == DAM_AIR ||
          skills[spellnum].damage_type == DAM_AIR)
         &&
         AFF2_FLAGGED(victim, AFF2_NEGATE_EARTH))
            ||
         (skills[spellnum].damage_type == DAM_EARTH &&
         AFF2_FLAGGED(victim, AFF2_NEGATE_AIR))
      ) {
      dam += dam / 4; /* 1/4 extra pain for you */
d993 1
a993 1
         act("$n cries out in pain!",
d2031 6
a2036 3
    if (GET_LEVEL(victim) >= LVL_IMMORT ||
        mag_savingthrow(victim, SAVING_PARA) ||
        MOB2_FLAGGED(victim, MOB2_NOPOISON)) {
d2043 1
a2043 1
    af[0].modifier = -2 - (skill / 4) - (skill / 20); /* max -32 */
d2782 1
a2782 1
 * as appropriate for an undead of the specified type - 321 */
d2788 1
a2788 1
  GET_RACE(mob) = RACE_UNDEAD;
a2790 1
  /* Removing all agg flafs from raised critters for the time being - RSD */
d2801 1
d2816 1
d2831 1
d2846 1
d2861 1
d3127 2
d3476 1
d3481 2
d3574 6
a3579 1
  /* don't execute these if no changes --Gurlaek 12/7/1999 */
d4186 3
@


1.178
log
@Fix to_room messages for dark presence.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.177 2008/03/22 16:27:57 jps Exp jps $
d30 1
d59 1
a59 1
  case FIRE_DAMAGE:
d63 1
a63 1
  case COLD_DAMAGE:
d67 1
a67 2
  case AIR_DAMAGE:
  case SHOCK_DAMAGE:
d71 1
a71 1
  case EARTH_DAMAGE:
d84 1
a84 1
  case FIRE_DAMAGE:
d88 1
a88 1
  case COLD_DAMAGE:
d92 1
a92 2
  case AIR_DAMAGE:
  case SHOCK_DAMAGE:
d96 1
a96 1
  case EARTH_DAMAGE:
d1031 1
a1031 1
         (skills[spellnum].damage_type == FIRE_DAMAGE &&
d1034 1
a1034 1
         (skills[spellnum].damage_type == COLD_DAMAGE &&
d1037 2
a1038 2
         ((skills[spellnum].damage_type == AIR_DAMAGE ||
          skills[spellnum].damage_type == SHOCK_DAMAGE)
d1042 1
a1042 1
         (skills[spellnum].damage_type == EARTH_DAMAGE &&
d1052 1
a1052 1
         (skills[spellnum].damage_type == FIRE_DAMAGE &&
d1055 1
a1055 1
         (skills[spellnum].damage_type == COLD_DAMAGE &&
d1058 2
a1059 2
         ((skills[spellnum].damage_type == AIR_DAMAGE ||
          skills[spellnum].damage_type == SHOCK_DAMAGE)
d1063 1
a1063 1
         (skills[spellnum].damage_type == EARTH_DAMAGE &&
d1078 1
a1078 1
    if (skills[spellnum].damage_type == FIRE_DAMAGE &&
d1108 1
a1108 1
    if (skills[spellnum].damage_type == COLD_DAMAGE &&
d4244 3
@


1.177
log
@Correctly copy sizes in duplicate_char.
Phantasms will copy the *current* size of a model (if any), disregarding
the fact that the model might have had its size modified by magic.
Phantasms will be neutral, because they have no souls and cannot be
good or evil.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.176 2008/03/11 02:53:09 jps Exp jps $
d1386 4
a1389 1
      to_room = "$n seizes up in pain!\r\n $n grabs $N who is surrounded by a dark presence.";
d1397 4
a1400 1
      to_room = "$n seizes up in pain!\r\n $n grabs $N who is enraged by a dark presence.";
d4245 7
@


1.176
log
@Update duplicate_char for size-tracking variables.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.175 2008/03/10 20:46:55 myc Exp jps $
d3190 6
a3195 2
   new_mob->player.weight = model->player.weight;
   new_mob->player.height = model->player.height;
d3199 1
a3199 1
   new_mob->player.natural_size = model->player.natural_size;
d3246 1
a3246 1
void phantasm_transform(struct char_data *ch, int life_hours)
d3269 19
d3297 1
a3297 1
   phantasm_transform(new_mob, life_hours);
d3496 1
a3496 1
       phantasm_transform(new_mob, duration);
d3509 1
a3509 1
      phantasm_transform(new_mob, duration);
d4239 3
@


1.175
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.174 2008/03/09 18:14:25 jps Exp myc $
d3192 4
a3195 1
   new_mob->player.size = model->player.size;
d4216 3
@


1.174
log
@Add spell effects for misdirection spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.173 2008/03/09 08:59:25 jps Exp jps $
d770 1
a770 1
      GET_POS1(victim) = POS1_PRONE;
d3188 1
a3188 1
   new_mob->player.hometown = model->player.hometown;
d3196 2
a3197 2
   new_mob->char_specials.position = model->char_specials.position;
   new_mob->char_specials.position1 = model->char_specials.position1;
a3199 1
   GET_POS(new_mob) = GET_POS(model);
d4213 3
@


1.173
log
@Remove fear from mag_affects.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.172 2008/03/09 06:38:37 jps Exp jps $
d2321 6
d4214 3
@


1.172
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.171 2008/03/09 04:02:08 jps Exp jps $
a1149 1

a1627 23
  case SPELL_FEAR:
    if (!attack_ok(ch, victim, TRUE))
      return CAST_RESULT_CHARGE;

    if (mag_savingthrow(victim, SAVING_PARA)) {
      act("$N has to strong a will to scare!", FALSE, ch, 0, victim, TO_CHAR);
      act("Your strength of will protects you from a fearful suggestion from $n... This time...", FALSE, ch, 0, victim, TO_VICT);
      act("$N isn't scared of $n. Nyah!", TRUE, ch, 0, victim, TO_NOTVICT);
      return CAST_RESULT_CHARGE | CAST_RESULT_IMPROVE;
    }

    af[0].bitvector2 = AFF2_FEAR;
    af[0].duration = skill / 27; /* max 3 */
    if (skill > 40) {
      af[1].location = APPLY_DAMROLL;
      af[1].modifier = skill / -33; /* max -3 */
      af[1].duration = af[0].duration;
    }
    to_char = "You scare the bejeezus outta $N! Muahahaha!";
    to_vict = "&9&bA rush of fear sweeps through your body!&0";
    to_room = "$n sneaks up on $N and &9&ba look of terror sweeps over $S&9&b face!&0\r\n$n throws back $s head and cackles with insane glee!";
    break;

d4208 5
@


1.171
log
@Fix up mob summoning and phantasms a lot. Player phantasms don't work
quite right yet.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.170 2008/02/23 01:03:54 myc Exp jps $
d3042 1
a3042 1
      sprintf(alias_buf, "zombie %s", orig->player.name);
d3048 1
a3048 1
      sprintf(alias_buf, "skeleton %s", orig->player.name);
d3069 1
a3069 1
  GET_SHORT(new_mob) = strdup(short_buf);
d3071 1
a3071 1
  new_mob->player.name = strdup(alias_buf);
d3185 9
a3193 17
   if (model->player.name)
      new_mob->player.name = strdup(model->player.name);
   if (IS_NPC(model)) {
      if (model->player.short_descr)
         new_mob->player.short_descr = strdup(model->player.short_descr);
      if (model->player.long_descr)
         new_mob->player.long_descr = strdup(model->player.long_descr);
   } else {
      if (model->player.name)
         new_mob->player.short_descr = strdup(model->player.name);
      /* See act.informative.c, list_one_char() */
      sprintf(buf, "&0%s%s%s &0&8(&0%s&0&8)&0 &9&8(&0%s&0&9&8)&0",
         model->player.name,
         GET_TITLE(model) ? " " : "",
         GET_TITLE(model) ? GET_TITLE(model) : "",
         RACE_ABBR(model), SIZE_DESC(model));
      new_mob->player.long_descr = strdup(buf);
d3244 1
a3244 4

   new_mob->player.short_descr = str_dup(buf);

   REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SENTINEL);
d3246 2
d4232 4
@


1.170
log
@Removed the lowest_circle in the skillinfo struct.  Use lowest_level
instead.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.169 2008/02/09 21:07:50 myc Exp myc $
d29 1
d2994 2
a2995 1
struct char_data *create_undead(struct char_data *orig,        struct char_data *caster, bool ISPC)
d3001 1
a3001 1
  extern struct player_special_data *dummy_mob;
d3021 1
a3021 1
  new_mob->player_specials = dummy_mob;
d3100 1
d3149 1
a3149 1
struct char_data *load_pet(struct char_data *ch, int vnum)
d3154 2
a3155 2
      sprintf(buf, "SYSERR: %s tried to summon mob with nonexistent vnum %d",
            GET_NAME(ch), vnum);
d3160 1
a3160 1
   char_to_room(mob, ch->in_room);
d3169 1
a3169 1
struct char_data *copyplayer(struct char_data *ch, struct char_data *model)
d3173 4
a3176 1
   new_mob = load_pet(ch, 2); /* Not puff (#1). Don't want a mob with a specproc. */
d3179 30
a3208 2
   GET_RACE(new_mob) = GET_RACE(model);
   GET_SIZE(new_mob) = GET_SIZE(model);
d3219 3
a3221 4
   new_mob->natural_abils = model->natural_abils;
   new_mob->viewed_abils = model->viewed_abils;
   new_mob->affected_abils = model->affected_abils;
   new_mob->points = model->points;
a3223 6
   new_mob->mob_specials = model->mob_specials;
   if (new_mob->player_specials && model->player_specials)
      *(new_mob->player_specials) = *(model->player_specials);
   sprintf(buf, "%s stands here looking strangely... absent.\r\n", GET_NAME(model));
   new_mob->player.long_descr = strdup(buf);

d3228 13
d3242 30
a3271 2
   if (model->player.name)
      new_mob->player.name = strdup(model->player.name);
d3273 10
a3282 2
   if (model->player.title) {
      new_mob->player.title = strdup(model->player.title);
a3283 1
   new_mob->player.short_descr = strdup(new_mob->player.name);
d3285 16
a3300 3
   if (model->player.description)
      new_mob->player.description = strdup(model->player.description);
   REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SENTINEL);
d3445 4
d3453 1
d3455 1
a3455 1
    new_mob = load_pet(ch, pvnum);
d3461 2
a3462 14
    /* Make it an illusion, and make sure it expires */
    SET_BIT(MOB2_FLAGS(new_mob), MOB2_ILLUSORY);
    SET_BIT(AFF_FLAGS(new_mob), AFF_CHARM); /* So it won't execute triggers! */
    duration = 2 + skill / 5;
    /* set it as animated */
    af.type = SPELL_ANIMATE_DEAD;
    af.duration = duration;
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_ANIMATED;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(new_mob, &af);
    REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SPEC);
d3466 1
d3468 2
d3473 1
a3473 1
     }
d3478 3
d3482 1
d3485 2
d3489 5
d3498 4
d3504 8
a3511 1
      new_mob = load_pet(ch, pvnum);
d3513 2
a3514 19
    if (new_mob == NULL) {
       act("The spell fizzles.", FALSE, 0, 0, 0, TO_ROOM);
       send_to_char("The spell fizzles.\r\n", ch);
       return 0;
    }
    /* Make it an illusion, and make sure it expires */
    SET_BIT(MOB2_FLAGS(new_mob), MOB2_ILLUSORY);
    SET_BIT(AFF_FLAGS(new_mob), AFF_CHARM); /* So it won't execute triggers! */
    duration = 3 + skill / 4;
    /* set it as animated */
    af.type = SPELL_ANIMATE_DEAD;
    af.duration = duration;
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_ANIMATED;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(new_mob, &af);
    REMOVE_BIT(MOB_FLAGS(new_mob), MOB_SPEC);
d4241 4
@


1.169
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.  And instead of creating
an event obj for extract events, we'll just pass the victim in.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.168 2008/02/09 04:27:47 myc Exp myc $
d125 2
a126 2
      if ((AFF2_FLAGGED(vict, AFF2_MINOR_GLOBE) && SINFO.lowest_circle <= 3) ||
          (AFF2_FLAGGED(vict, AFF2_MAJOR_GLOBE) && SINFO.lowest_circle <= 6)) {
d4152 5
@


1.168
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.167 2008/01/29 21:02:31 myc Exp myc $
d859 1
a859 1
             mkgenericevent(victim, 0, 0), &(victim->events), 0);
d920 1
a920 1
             mkgenericevent(victim, 0, 0), &(victim->events), 0);
d1122 1
a1122 1
             mkgenericevent(ch, victim, 0), &(victim->events), 0);
d4152 3
@


1.167
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.166 2008/01/29 16:51:12 myc Exp myc $
d28 1
d4152 4
@


1.166
log
@Moving skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.165 2008/01/28 02:39:01 jps Exp myc $
a28 8
extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *obj_index;
extern struct index_data *mob_index;
extern struct descriptor_data *descriptor_list;
extern struct zone_data *zone_table;
extern struct char_data *mob_proto;
a35 5
struct spell_dam spell_dam_info[MAX_SPELLS + 1];
extern struct default_mobile_stats *mob_defaults;
extern char weapon_verbs[];
extern int *max_ac_applys;
extern struct apply_mod_defaults *apmd;
a284 1
  extern struct raff_node *raff_list;
a3808 2
  extern struct raff_node *raff_list;

d4151 3
@


1.165
log
@Use extract event for exorcisms.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.164 2008/01/27 21:14:59 myc Exp jps $
a49 2
void act(char *str, int i, struct char_data * c, struct obj_data * o,
         void *vict_obj, int j);
d1107 2
a1108 2
            sprintf(buf, "%s light%s", skillnames[spellnum],
               skillnames[spellnum][strlen(skillnames[spellnum]) - 1] == 's' ? "" : "s");
d4167 3
@


1.164
log
@Replace hit() with attack().  Adding berserker chants.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.163 2008/01/27 13:43:50 jps Exp myc $
d872 6
a877 2
      if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY)) /* illusions don't really banish */
        extract_char(victim);
d929 1
a929 1
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",
d931 1
a931 1
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",
d933 6
a938 2
      if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY)) /* illusions don't really banish */
        extract_char(victim);
d4169 3
@


1.163
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.162 2008/01/27 12:12:55 jps Exp jps $
d1321 1
a1321 1
        hit(victim, ch, TYPE_UNDEFINED);
d1746 1
a1746 1
        hit(victim, ch, TYPE_UNDEFINED);
d2198 1
a2198 1
        hit(victim, ch, TYPE_UNDEFINED);
d2465 21
d3342 1
a3342 1
      hit(new_mob, ch, TYPE_UNDEFINED);
d4161 3
@


1.162
log
@Changed IS_THIEF macro to IS_ROGUE.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.161 2008/01/27 09:45:41 jps Exp jps $
d811 1
a811 1
    if (GET_SPECIES(victim) != SPECIES_UNDEAD) {
d862 1
a862 1
    if (GET_SPECIES(victim) != SPECIES_DEMON) {
d919 1
a919 1
    if (GET_SPECIES(victim) != SPECIES_DEMON) {
d983 1
a983 1
    if (GET_SPECIES(victim) == SPECIES_UNDEAD) {
d2290 1
a2290 1
    if (GET_SPECIES(victim) != SPECIES_UNDEAD) {
d2858 1
a2858 1
  GET_SPECIES(mob) = SPECIES_UNDEAD;
a2986 1
  extern void scale_attribs(struct char_data *);
d4140 3
@


1.161
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.160 2008/01/27 02:37:03 jps Exp jps $
d2994 1
a2994 1
  else if ((GET_LEVEL(orig) > 25) && IS_THIEF(orig) && !number(0, 4))
d4141 4
@


1.160
log
@Lower breath damage a bit.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.159 2008/01/27 00:18:12 jps Exp jps $
a52 2
void reset_mob(struct char_data *mob, int caster_level, int i, int type,
               struct obj_data * obj);
d2872 1
a2872 1
    GET_CLASS(mob) = MCLASS_WARRIOR;
d2886 1
a2886 1
    GET_CLASS(mob) = MCLASS_WARRIOR;
d2900 1
a2900 1
    GET_CLASS(mob) = MCLASS_ASSASSIN;
d2914 1
a2914 1
    GET_CLASS(mob) = MCLASS_SORCERER;
d2928 1
a2928 1
    GET_CLASS(mob) = MCLASS_NECROMANCER;
d4141 3
@


1.159
log
@Make breath damage appropriate to the level of the mob. No more level
3 demons doing 300 damage!!!
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.158 2008/01/26 14:26:31 jps Exp jps $
d979 1
a979 1
    dam = 2 * skill + number(1, skill * 4);
d4143 4
@


1.158
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.157 2008/01/26 12:33:18 jps Exp jps $
a974 2
    dam -= 100;
    /* fall through */
d979 1
a979 1
    dam += dice(10, 10) + 250;
d4143 3
@


1.157
log
@Use skills.h to import improve_skill().
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.156 2008/01/25 11:54:29 jps Exp jps $
a61 2
extern struct spell_info_type spell_info[];
extern char *spells[];
d72 1
a72 1
  switch(spell_info[spell].damage_type) {
d98 1
a98 1
  switch(spell_info[spell].damage_type) {
d319 2
a320 2
            if (spell_info[af->type].wearoff) {
              send_to_char(spell_info[af->type].wearoff, i);
d347 2
a348 2
          spell_info[raff->spell].wearoff) {
        send_to_room(spell_info[raff->spell].wearoff,
d1042 1
a1042 1
         (spell_info[spellnum].damage_type == FIRE_DAMAGE &&
d1045 1
a1045 1
         (spell_info[spellnum].damage_type == COLD_DAMAGE &&
d1048 2
a1049 2
         ((spell_info[spellnum].damage_type == AIR_DAMAGE ||
          spell_info[spellnum].damage_type == SHOCK_DAMAGE)
d1053 1
a1053 1
         (spell_info[spellnum].damage_type == EARTH_DAMAGE &&
d1063 1
a1063 1
         (spell_info[spellnum].damage_type == FIRE_DAMAGE &&
d1066 1
a1066 1
         (spell_info[spellnum].damage_type == COLD_DAMAGE &&
d1069 2
a1070 2
         ((spell_info[spellnum].damage_type == AIR_DAMAGE ||
          spell_info[spellnum].damage_type == SHOCK_DAMAGE)
d1074 1
a1074 1
         (spell_info[spellnum].damage_type == EARTH_DAMAGE &&
d1089 1
a1089 1
    if (spell_info[spellnum].damage_type == FIRE_DAMAGE &&
d1093 1
a1093 1
      temp += spell_info[spellnum].min_level[(int) GET_CLASS(ch)];
d1105 2
a1106 2
            sprintf(buf, "%s light%s", spells[spellnum],
               spells[spellnum][strlen(spells[spellnum]) - 1] == 's' ? "" : "s");
d1119 1
a1119 1
    if (spell_info[spellnum].damage_type == COLD_DAMAGE &&
d1124 1
a1124 1
      temp += spell_info[spellnum].min_level[(int) GET_CLASS(ch)];
d3841 1
a3841 1
    improve_skill(ch, spell_info[SPELL_CIRCLE_OF_FIRE].sphere);
d3889 1
a3889 1
  skill = GET_SKILL(ch, spell_info[spellnum].sphere);
d3957 1
a3957 1
  skill = GET_SKILL(ch, spell_info[spellnum].sphere);
d4145 3
d4167 1
a4167 1
 * Changed the spell_info struct to store lowest_level and lowest_circle
@


1.156
log
@Add a newline to the long description of raised undead creatures.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.155 2008/01/25 11:47:22 jps Exp jps $
d27 1
a48 1
extern void improve_skill(struct char_data *ch, int skill);
d4147 3
@


1.155
log
@Fix grammar in negate heat spell message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.154 2008/01/24 15:45:09 myc Exp jps $
d3059 1
d4147 3
@


1.154
log
@Fixed a typo in magic.c
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.153 2008/01/15 03:26:00 myc Exp myc $
d53 1
a53 1
void reset_mob(struct char_data *mob, int caster_level, int i, int type, 
d153 1
a153 1
  }   
d210 1
a210 1
         && victim->guarded_by 
d283 1
a283 1
  for (af = i->affected; af; af = tmp) 
d289 1
a289 1
            af->modifier--;        
d297 2
a298 2
  
  
d343 1
a343 1
    
d345 1
a345 1
    
d354 1
a354 1
      
d366 1
a366 1
  
d383 1
a383 1
  
d447 1
a447 1
      
d450 1
a450 1
           
d452 1
a452 1
           
d509 1
a509 1
  /* spell damage is now online, and is stored in array "spell_dam_info", 
d540 1
a540 1
  
d546 1
a546 1
      
d554 1
a554 1
      
d565 1
a565 1
  
d567 1
a567 1
     proficiency system.  Most damage spells will increase parabolicly as skill increases so 
d571 1
a571 1
     the spell never does more than (Y) amount of damage. RSD 3/28/00 */ 
d628 1
a628 1
        
d658 1
a658 1
    /* max dam 110 from max 8d6+9 online, except alignment bonus! */   
d663 1
a663 1
    /* max dam 110 from max 8d6+9 online, except alignment bonus! */   
d736 1
a736 1
    break;    
d749 1
a749 1
        temp = 5; 
d774 1
a774 1
    }    
d781 1
a781 1
          TRUE, ch, 0, victim, TO_NOTVICT);     
d783 1
a783 1
    } 
d870 1
a870 1
    if (GET_ALIGNMENT(ch) >= 990 && skill - GET_LEVEL(victim) > 30 && 
d950 1
a950 1
    act("You lose some life in libation of your holy allegiance!", 
d1019 2
a1020 2
  victim = check_guard(ch, victim, FALSE);  
  
d1025 1
a1025 1
  if (protected_from_spell(victim, spellnum)) 
d1027 1
a1027 1
  
d1165 1
a1165 1
  bool accum_affect = FALSE, accum_duration = FALSE, is_innate = FALSE, 
d1175 2
a1176 2
    half_chop(ch->casting.misc,buf,buf2); 
  
d1187 1
a1187 1
    
d1200 1
a1200 1
    
d1207 1
a1207 1
    to_room = "&6$n&6's body shimmers a bit as all heat seems to evacuate $s body.&0";
d1209 1
a1209 1
    
d1216 1
a1216 1
    to_room = "&4$n&4's body glows &bblue&0&4 briefly.&0";
d1218 1
a1218 1
    
d1232 1
a1232 1
    
d1248 1
a1248 1
    
d1261 1
a1261 1
    
d1266 1
a1266 1
    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {      
d1269 1
a1269 1
      act("&9&b$N&9&b resists $n's&9&b column of smoke!&0", TRUE, ch, 0, victim, TO_NOTVICT);     
d1275 1
a1275 1
      af[0].duration = 0;     
d1278 2
a1279 2
      af[1].duration = 0;     
      
d1299 1
a1299 1
    
d1353 1
a1353 1
      
d1362 1
a1362 1
    
d1397 1
a1397 1
      to_char = "You summon allegiance from your dark gods to protect $N."; 
d1410 1
a1410 1
    
d1412 1
a1412 1
    
d1438 1
a1438 1
    
d1461 1
a1461 1
    
d1480 1
a1480 1
    
d1527 1
a1527 1
    
d1535 5
a1539 5
    if (affected_by_spell(victim, SPELL_LESSER_ENDURANCE) || 
        affected_by_spell(victim, SPELL_ENDURANCE) || 
        affected_by_spell(victim, SPELL_GREATER_ENDURANCE) || 
        affected_by_spell(victim, SPELL_VITALITY) || 
        affected_by_spell(victim, SPELL_GREATER_VITALITY) || 
d1546 1
a1546 1
    af[0].modifier = get_vitality_hp_gain(ch, spellnum); 
d1549 1
a1549 1
    to_vict = get_vitality_vict_message(spellnum); 
d1567 1
a1567 1
      GET_POS(victim) = POS_FLYING; 
d1569 1
a1569 1
    
d1577 1
a1577 1
    
d1600 1
a1600 1
    
d1604 1
a1604 1
    
d1622 1
a1622 1
    
d1631 1
a1631 1
    
d1640 1
a1640 1
    
d1663 1
a1663 1
    
d1694 1
a1694 1
    
d1711 1
a1711 1
    
d1725 1
a1725 1
    
d1764 2
a1765 2
    to_room = "&7&bAll motion in $N&7&b's body grinds to a halt.&0";    
    break; 
d1791 1
a1791 1
    
d1800 1
a1800 1
    
d1832 1
a1832 1
    
d1851 1
a1851 1
    to_char = "You silence $N!";    
d1855 1
a1855 1
    
d1874 1
a1874 1
    } 
d1886 1
a1886 1
    
d1890 1
a1890 1
    
d1896 1
a1896 1
    to_vict = "&1&bYour skin starts to itch as you reduce to half your normal size.&0"; 
d1909 1
a1909 1
    
d1913 1
a1913 1
    
d1923 1
a1923 1
  case SPELL_STONE_SKIN: 
d1949 1
a1949 1
    
d1957 1
a1957 1
    
d1965 1
a1965 1
    
d1986 1
a1986 1
    to_room = "$N is inspired to do good by $n.";    
d1988 1
a1988 1
    
d2003 1
a2003 1
    
d2013 1
a2013 1
    
d2018 1
a2018 1
    
d2027 1
a2027 1
    } 
d2035 1
a2035 1
    
d2040 1
a2040 1
    
d2045 1
a2045 1
    
d2050 1
a2050 1
    
d2075 1
a2075 1
    
d2084 1
a2084 1
    
d2093 1
a2093 1
    
d2100 1
a2100 1
    
d2154 1
a2154 1
    
d2164 1
a2164 1
    
d2182 1
a2182 1
    
d2214 1
a2214 1
    
d2221 1
a2221 1
    
d2224 1
a2224 1
    /* This is rather a hack of the intended nature of how the 
d2234 1
a2234 1
    
d2243 1
a2243 1
    
d2251 1
a2251 1
    
d2259 1
a2259 1
    
d2270 1
a2270 1
    
d2283 1
a2283 1
      
d2392 1
a2392 1
     * no attack_ok check, since this is a mag_masses spell, and 
d2421 1
a2421 1
    af[0].modifier = 10 + (skill / 2); /* max 60: positive is bad */ 
d2429 1
a2429 1
     * no attack_ok check, since this is a MAG_MASSES spell, and 
d2472 1
a2472 1
  
d2486 1
a2486 1
   
d2495 1
a2495 1
   
d2500 1
a2500 1
   
d2505 1
a2505 1
   
d2521 1
a2521 1
   
d2525 1
a2525 1
   
d2599 1
a2599 1
  
d2602 1
a2602 1
  
d2649 1
a2649 1
  
d2669 1
a2669 1
     * If this is a violent spell, and the victim isn't already fighting 
d2691 1
a2691 1
  
d2748 1
a2748 1
        act("$n hunches over and grunts loudly!", TRUE, ch, 0, 0, TO_ROOM);     
d2765 1
a2765 1
    to_room = "&7&b$n &7&butters a word of holy power!&0";  
d2808 1
a2808 1
  
d2813 1
a2813 1
  
d2854 1
a2854 1
enum undead_type { MOB_ZOMBIE, MOB_SKELETON, MOB_SPECTRE, 
d2963 1
a2963 1
 * modifies its stats appropriately (up for higher-level ch, down for 
d2982 1
a2982 1
/* orig is the original (living) mob. 
d3006 1
a3006 1
  
d3037 1
a3037 1
      sprintf(long_buf, "The skeleton of %s stands creaking at attention.", 
d3065 1
a3065 1
  /* this bit's taken straight out of read_mobile. i'm assuming it's good 
d3075 1
a3075 1
  new_mob->points.max_hit = ( (caster->points.max_hit * 21) / 10 );    
d3097 1
a3097 1
 * CONTROL_HELLNO if ch couldn't even control it under the /best/ of 
d3292 1
a3292 1
    af.duration =  (int)(base_duration * preserve_mult); 
d3304 1
a3304 1
      af.duration =  (int)(base_duration * preserve_mult) + 1; 
d3329 1
a3329 1
    
d3562 1
a3562 1
  
d3565 1
a3565 1
  
d3606 1
a3606 1
    if ((spellnum == SPELL_HEAL || spellnum == SPELL_FULL_HEAL) && 
d3626 1
a3626 1
  
d3631 1
a3631 1
  
d3639 1
a3639 1
    check_regen_rates(victim);        /* speed up regen rate immediately */  
d3652 1
a3652 1
  
d3655 1
a3655 1
  
d3709 1
a3709 1
  
d3714 1
a3714 1
  
d3729 1
a3729 1
  
d3774 1
a3774 1
  
d3801 1
a3801 1
  
d3803 1
a3803 1
  
d3805 1
a3805 1
  
d3808 1
a3808 1
  
d3846 1
a3846 1
    
d3848 1
a3848 1
    sprintf(buf, "SYSERR: unknown spellnum %d " 
d3853 1
a3853 1
  
d3862 1
a3862 1
  
d3866 1
a3866 1
  
d3871 1
a3871 1
  
d3880 1
a3880 1
/* Add spells to the case statement here to make a spell's duration skill 
d3882 3
a3884 3
   Note that adding the default 1 added to a 0 will make the spell wear off 
   when the next TICK (currently 75 secs) expires no matter how close it is.  
   This gives the affect of nearly instantaneous expiration of the spell. 
d3890 2
a3891 2
  skill = GET_SKILL(ch, spell_info[spellnum].sphere); 
  duration = 0; 
d3894 1
a3894 1
  switch(spellnum) 
d3897 2
a3898 2
    duration = skill / 30; 
    if (duration == 0) duration = 2; 
d3900 1
a3900 1
    
d3904 2
a3905 2
    if (duration == 0 && skill > 0) duration = 2; 
    if (skill > 95)  duration = 5; 
d3907 1
a3907 1
    
d3909 2
a3910 2
    duration = skill / 10; 
    break; 
d3915 1
a3915 1
    if (skill > 95)  duration = 7; 
d3929 1
a3929 1
  char* victim_messages[] = 
d3939 1
a3939 1
  index = 0; 
d3942 1
a3942 1
    index = 0; 
d3946 1
a3946 1
      index = spellnum - SPELL_LESSER_ENDURANCE + 1; 
d3951 1
a3951 1
  return victim_messages[index]; 
d3956 1
a3956 1
  int hp; 
d3958 2
a3959 2
  skill = GET_SKILL(ch, spell_info[spellnum].sphere); 
  hp = 0; 
d3962 1
a3962 1
  switch(spellnum) 
d3967 1
a3967 1
    
d3975 1
a3975 1
    break; 
d3980 1
a3980 1
    
d3987 2
a3988 2
    hp = (pow(skill, 2) / 20) + 90; 
    break; 
d3995 1
a3995 1
  hp -= number(2,10);  
d3997 1
a3997 1
  return hp; 
d4051 1
a4051 1
  if (!world[room].dir_option[dir] || 
d4056 1
a4056 1
  for (wall = world[world[room].dir_option[dir]->to_room].contents; wall; 
d4146 3
@


1.153
log
@Fixing a typo in sleep spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.152 2008/01/14 18:52:52 myc Exp myc $
d3529 2
a3530 2
    act("&9&b$N&9&b slowly fades out of existence.&0", TRUE, ch, 0, 0, TO_ROOM);
    hide = skill * 8;
d4146 3
@


1.152
log
@Auto-set the violent flag on a spell if the spell has the
MAG_DAMAGE routine.  Fix soul tap to not assign the effect
if the attack cannot occur.  Fix evades_spell to only go
off for violent spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.151 2008/01/13 23:06:04 myc Exp myc $
d2192 1
a2192 1
      send_to_char("Use the 'nap' command instead!", ch);
d4146 6
@


1.151
log
@Changed the spell_info struct to store lowest_level and lowest_circle
data for each spell, thus making it unnecessary to calculate the
minimum spell circle for a spell everytime it goes through the
evades_spell function.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.150 2008/01/13 03:19:53 myc Exp myc $
d102 1
a102 1
    if(AFF2_FLAGGED(ch, AFF2_NEGATE_HEAT))
d106 1
a106 1
    if(AFF2_FLAGGED(ch, AFF2_NEGATE_COLD))
d111 1
a111 1
    if(AFF2_FLAGGED(ch, AFF2_NEGATE_AIR))
d115 1
a115 1
    if(AFF2_FLAGGED(ch, AFF2_NEGATE_EARTH))
d134 4
d139 1
a139 1
   if (SINFO.violent && AFF2_FLAGGED(vict, AFF2_MINOR_GLOBE | AFF2_MAJOR_GLOBE) &&
d176 1
a176 4
  if ( (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE)) &&
        !IS_NPC(vict) &&
        GET_LEVEL(vict) >= LVL_IMMORT
     ) {
d995 2
a996 1
    mag_affects(skill, ch, ch, SPELL_SOUL_TAP, savetype);
d4146 6
@


1.150
log
@Fixed a bug in check_guard.  Split check_armor_spells into
check_armor_spells and affected_by_armor_spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.149 2008/01/12 23:13:20 myc Exp myc $
a133 2
   int i, min_spell_level = NUM_SPELL_CIRCLES;

a137 5
      /* Find the minimum spell circle for the spell being cast right now. */
      for (i = 0; i < NUM_CLASSES; ++i)
        if (SINFO.min_circle[i] < 10)
          min_spell_level = MIN(min_spell_level, SINFO.min_circle[i]);

d139 2
a140 2
      if ((AFF2_FLAGGED(vict, AFF2_MINOR_GLOBE) && min_spell_level <= 3) ||
          (AFF2_FLAGGED(vict, AFF2_MAJOR_GLOBE) && min_spell_level <= 6)) {
a2722 1
  int i, min_spell_level=NUM_SPELL_CIRCLES;
a2818 5
  if (spell_info[spellnum].violent)
    for (i=0; i<NUM_CLASSES; ++i) 
      if (spell_info[spellnum].min_circle[i] < 10)
        min_spell_level = MIN(min_spell_level, spell_info[spellnum].min_circle[i]);
  
d4144 4
@


1.149
log
@Renamed clearMemory clear_memory.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.148 2008/01/11 17:34:32 myc Exp myc $
d67 1
a67 1
int check_armor_spells(struct char_data *ch, struct char_data *victim);
d213 3
a215 2
   if (!ch || !victim) return NULL;
   if (ch->casting.target_status != TARGET_ALL_ROOM 
d217 2
a218 1
         && get_char_room_vis(victim->guarded_by, GET_NAME(victim)) == victim
d232 2
a233 2
      return victim->guarded_by;
      } else {
d4018 14
a4031 9
int check_armor_spells(struct char_data *ch, struct char_data *victim) {
  if(affected_by_spell(victim, SPELL_ARMOR) ||
      affected_by_spell(victim, SPELL_BARKSKIN) ||
      affected_by_spell(victim, SPELL_BONE_ARMOR) ||
      affected_by_spell(victim, SPELL_DEMONSKIN) ||
      affected_by_spell(victim, SPELL_GAIAS_CLOAK) ||
      affected_by_spell(victim, SPELL_ICE_ARMOR) ||
      affected_by_spell(victim, SPELL_MIRAGE)) {
    if(ch == victim) {
d4040 1
a4040 1
    return 1;
d4042 1
a4042 1
  return 0;
d4157 3
@


1.148
log
@Fixing a typo in sanctuary spell message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.147 2008/01/10 05:39:43 myc Exp myc $
a49 1
void clearMemory(struct char_data * ch);
d4150 3
@


1.147
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.146 2008/01/07 11:56:45 jps Exp myc $
d2184 1
a2184 1
    to_room = "Absolutely nothing happens to $n.";
d4151 4
@


1.146
log
@Make sure illusory mobs have no cash. Don't use puff for player
template, as she has a spec proc. Make sure player illusions
are not sentinel. Set their long desc (not that it's likely
to be seen).
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.145 2008/01/07 10:37:19 jps Exp jps $
a53 2
void damage(struct char_data * ch, struct char_data * victim,
            int damage, int weapontype);
d3549 1
a3549 1
    alter_hit(victim, -hit * multiplier, 1);
d4151 6
@


1.145
log
@Change spell name "project" to "phantasm". Allow simulacrom to
make copies of players.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.144 2008/01/06 23:50:47 jps Exp jps $
d3162 5
d3174 1
a3174 1
   new_mob = load_pet(ch, 1); /* Puff :) */
d3198 2
d3216 1
d3399 1
a3408 1
      /* Load it up */
d4153 4
@


1.144
log
@Added spells project and simulacrum, and MOB2_ILLUSORY flag.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.143 2008/01/06 20:38:00 jps Exp jps $
d3165 48
d3233 2
a3234 2
  int project_mobs[] = { 8016, 3506, 8605, 1688, 8807, 30215, 12504, 50219 };
  int num_project_mobs = 8;
d3352 1
a3352 1
  case SPELL_PROJECT:
d3354 1
a3354 1
    pvnum = project_mobs[number(0, num_project_mobs - 1)];
d3392 10
a3401 3
       /* I'd like to make illusions of players, but maybe later. */
       send_to_char("Sadly, that's impossible.\r\n", ch);
       return 0;
a3402 2
    /* Load it up */
    new_mob = load_pet(ch, pvnum);
d4145 3
@


1.143
log
@Remove unused saving throw tables.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.142 2008/01/05 05:44:19 jps Exp jps $
d52 1
a52 1
	 void *vict_obj, int j);
d55 1
a55 1
	    int damage, int weapontype);
d57 1
a57 1
	       struct obj_data * obj);
d294 9
a302 9
	{
	  if (af->modifier > 1)
	    af->modifier--;	
	  else
	    {
	      affect_remove(i, af);/*remove bit*/
	      send_to_char("&3&dYour skin softens and returns to normal.&0\r\n", i);
	    };
	}
d321 3
a323 3
	af->duration--;
      else if (af->duration == -1)	/* No action */
	af->duration = -1;	/* GODs only! unlimited */
d325 6
a330 6
	if (af->type > 0 && af->type <= TOP_SKILL)
	  if (!af->next || af->next->type != af->type ||
	      af->next->duration > 0)
	    if (spell_info[af->type].wearoff) {
	      send_to_char(spell_info[af->type].wearoff, i);
	      send_to_char("\r\n", i);
d332 1
a332 1
	affect_remove(i, af);
d338 1
a338 1
	  TO_ROOM);
d341 6
d357 3
a359 3
	send_to_room(spell_info[raff->spell].wearoff,
		     raff->room);
	send_to_room("\r\n", raff->room);
d368 1
a368 1
		 raff->affection);
d370 1
a370 1
	free(raff);
d386 1
a386 1
		      int extract, int verbose)
d407 2
a408 2
	send_to_char("A wart sprouts on your nose.\r\n", ch);
	break;
d410 2
a411 2
	send_to_char("Your hair falls out in clumps.\r\n", ch);
	break;
d413 2
a414 2
	send_to_char("A huge corn develops on your big toe.\r\n", ch);
	break;
d504 1
a504 1
		int spellnum, int savetype)
d555 1
a555 1
	dam += MIN(SD_BONUS(spellnum), skill / 4);
d557 1
a557 1
	dam += MIN(SD_BONUS(spellnum), skill * SD_LVL_MULT(spellnum));
d563 1
a563 1
	dam += MIN(SD_BONUS(spellnum), skill / 2);
d565 1
a565 1
	dam += MIN(SD_BONUS(spellnum), skill * SD_LVL_MULT(spellnum));
d569 1
a569 1
	dam = (SD_NPC_REDUCE_FACTOR(spellnum) * dam) /100;
d883 2
a884 1
      extract_char(victim);
d940 2
a941 1
      extract_char(victim);
d1094 2
a1095 1
  if (GET_POS(victim) > POS_DEAD && dam > 0 && GET_LEVEL(victim) < LVL_IMMORT) {
d1128 2
a1129 1
        !AFF2_FLAGGED(victim, AFF2_PROT_COLD | AFF2_NEGATE_COLD | AFF2_FIRESHIELD)) {
d1163 1
a1163 1
#define MAX_SPELL_AFFECTS 8	/* change if more needed */
d1166 1
a1166 1
		 int spellnum, int savetype)
d1178 2
d1542 5
a1546 5
	affected_by_spell(victim, SPELL_ENDURANCE) || 
	affected_by_spell(victim, SPELL_GREATER_ENDURANCE) || 
	affected_by_spell(victim, SPELL_VITALITY) || 
	affected_by_spell(victim, SPELL_GREATER_VITALITY) || 
	affected_by_spell(victim, SPELL_DRAGONS_HEALTH)) {
d2559 1
a2559 1
			struct char_data * tch, int spellnum, int savetype)
d2867 1
a2867 1
		   MOB_WRAITH, MOB_LICH };
d2997 1
a2997 1
struct char_data *create_undead(struct char_data *orig,	struct char_data *caster, bool ISPC)
d3050 1
a3050 1
	      GET_NAME(orig));
d3150 15
d3171 3
a3173 2
int mag_summons(int skill, struct char_data *ch, struct obj_data *obj,
		 int spellnum, int savetype)
a3174 1
  /* variables for SPELL_ANIMATE_DEAD */
d3177 1
a3177 1
  int success;
d3182 6
d3205 4
a3208 6
    if (IS_PLR_CORPSE(obj)) 
    {
      if (!pk_allowed)
      {
	send_to_char("Raising PC corpses is not currently allowed.\r\n", ch);
	return CAST_RESULT_CHARGE;
d3210 2
a3211 4
    } 
    else if ((GET_OBJ_VAL(obj, 3) == CORPSE_NPC_NORAISE) || /* unraisable */
	       ((orig_mob_rnum = GET_OBJ_MOB_FROM(obj)) == NOBODY)) 
    {
d3220 1
a3220 1
	new_mob = create_undead(mob_proto, ch, TRUE);
d3228 1
a3228 1
	  "in time.", FALSE, ch, 0, new_mob, TO_CHAR);
d3230 1
a3230 1
	  "in time.", FALSE, ch, 0, new_mob, TO_ROOM);
d3272 1
a3272 1
	  0, new_mob, TO_CHAR);
d3274 1
a3274 1
	  0, new_mob, TO_ROOM);
d3291 5
a3295 5
	GET_PLAT(new_mob) += GET_OBJ_VAL(temp_obj, 0);
	GET_GOLD(new_mob) += GET_OBJ_VAL(temp_obj, 1);
	GET_SILVER(new_mob) += GET_OBJ_VAL(temp_obj, 2);
	GET_COPPER(new_mob) += GET_OBJ_VAL(temp_obj, 3);
	extract_obj(temp_obj);
d3297 1
a3297 1
	obj_to_char(temp_obj, new_mob);
d3303 69
d3509 1
a3509 1
		   int spellnum, int type)
d3590 1
a3590 1
    check_regen_rates(victim);	/* speed up regen rate immediately */  
d3599 1
a3599 1
		    int spellnum, int savetype)
d3610 1
a3610 1
	(GET_OBJ_WEIGHT(obj) <= 5 * skill)) {
d3619 1
a3619 1
	GET_OBJ_VAL(obj, 2)--;
d3642 1
a3642 1
	GET_OBJ_VAL(obj, 2)++;
d3729 1
a3729 1
	    spellnum, z);
d3800 1
a3800 1
	    "passed to mag_unaffects", spellnum);
d3883 6
a3888 6
	"&4&bYou feel you can endure a bit more pain!&0",
	"&4&bYou feel you can endure more pain!&0",
	"&4&bYou feel vitalized!&0",
	"&4&bYou feel greatly vitalized!&0",
	"&4&bYou feel the blood of dragons surge through your veins!&0"
	};
d4092 3
@


1.142
log
@Using update_char() for created mobs.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.141 2008/01/04 01:53:26 jps Exp jps $
a202 351
/*
 * Saving throws for:
 * MCTW
 *   PARA, ROD, PETRI, BREATH, SPELL
 *     Levels 0-40
 */

const byte saving_throws[NUM_CLASSES][5][41] = {

  {				/* Mages */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

  {				/* Clerics */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 74, 73, 71, 70, 68, 65, 63, 60, 59,	/* 0 - 10 */
/* SPELL */	58, 56, 55, 54, 53, 51, 50, 49, 48, 47,		/* 11 - 20 */
		46, 45, 43, 41, 39, 37, 35, 34, 33, 32,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}		/* 31 - 40 */
  },

  {				/* Thieves */
		{90, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56,	/* 0 - 10 */
/* PARA */	55, 54, 53, 52, 51, 50, 49, 48, 47, 46,		/* 11 - 20 */
		45, 44, 43, 42, 41, 40, 39, 38, 37, 36,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 68, 66, 64, 62, 60, 58, 56, 54, 52,	/* 0 - 10 */
/* ROD */	50, 48, 46, 44, 42, 40, 38, 36, 34, 32,		/* 11 - 20 */
		30, 28, 26, 24, 22, 20, 18, 16, 14, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 59, 58, 58, 56, 55, 54, 53, 52, 51,	/* 0 - 10 */
/* PETRI */	50, 49, 48, 47, 46, 45, 44, 43, 42, 41,		/* 11 - 20 */
		40, 39, 38, 37, 36, 35, 34, 33, 32, 31,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71,	/* 0 - 10 */
/* BREATH */	70, 69, 68, 67, 66, 65, 64, 63, 62, 61,		/* 11 - 20 */
		60, 59, 58, 57, 56, 55, 54, 53, 52, 51,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 59, 57,	/* 0 - 10 */
/* SPELL */	55, 53, 51, 49, 47, 45, 43, 41, 39, 37,		/* 11 - 20 */
		35, 33, 31, 29, 27, 25, 23, 21, 19, 17,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}			/* 31 - 40 */
  },

  {				/* Warriors */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* PALADINS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

  {				/* ANTI-PALADINS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* RANGERS */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

{				/* DRUIDS */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

  {				/* SHAMAN */
		{90, 50, 59, 48, 46, 45, 43, 40, 37, 35, 34,	/* 0 - 10 */
/* PARA */	33, 31, 30, 29, 27, 26, 25, 24, 23, 22,		/* 11 - 20 */
		21, 20, 18, 15, 14, 12, 10, 9, 8, 7,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 69, 68, 66, 65, 63, 60, 57, 55, 54,	/* 0 - 10 */
/* ROD */	53, 51, 50, 49, 47, 46, 45, 44, 43, 42,		/* 11 - 20 */
		41, 40, 38, 35, 34, 32, 30, 29, 28, 27,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 64, 63, 61, 60, 58, 55, 53, 50, 49,	/* 0 - 10 */
/* PETRI */	48, 46, 45, 44, 43, 41, 40, 39, 38, 37,		/* 11 - 20 */
		36, 35, 33, 31, 29, 27, 25, 24, 23, 22,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 76, 75, 73, 70, 67, 65, 64,	/* 0 - 10 */
/* BREATH */	63, 61, 60, 59, 57, 56, 55, 54, 53, 52,		/* 11 - 20 */
		51, 50, 48, 45, 44, 42, 40, 39, 38, 37,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
		},

{				/* ASSASSINS */
		{90, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56,	/* 0 - 10 */
/* PARA */	55, 54, 53, 52, 51, 50, 49, 48, 47, 46,		/* 11 - 20 */
		45, 44, 43, 42, 41, 40, 39, 38, 37, 36,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 70, 68, 66, 64, 62, 60, 58, 56, 54, 52,	/* 0 - 10 */
/* ROD */	50, 48, 46, 44, 42, 40, 38, 36, 34, 32,		/* 11 - 20 */
		30, 28, 26, 24, 22, 20, 18, 16, 14, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 59, 58, 58, 56, 55, 54, 53, 52, 51,	/* 0 - 10 */
/* PETRI */	50, 49, 48, 47, 46, 45, 44, 43, 42, 41,		/* 11 - 20 */
		40, 39, 38, 37, 36, 35, 34, 33, 32, 31,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71,	/* 0 - 10 */
/* BREATH */	70, 69, 68, 67, 66, 65, 64, 63, 62, 61,		/* 11 - 20 */
		60, 59, 58, 57, 56, 55, 54, 53, 52, 51,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 59, 57,	/* 0 - 10 */
/* SPELL */	55, 53, 51, 49, 47, 45, 43, 41, 39, 37,		/* 11 - 20 */
		35, 33, 31, 29, 27, 25, 23, 21, 19, 17,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0}			/* 31 - 40 */
  },

{				/* MERCENARY */
		{90, 70, 68, 67, 65, 62, 58, 55, 53, 52, 50,	/* 0 - 10 */
/* PARA */	47, 43, 40, 38, 37, 35, 32, 28, 25, 24,		/* 11 - 20 */
		23, 22, 20, 19, 17, 16, 15, 14, 13, 12,		/* 21 - 30 */
		11, 10, 9, 8, 7, 6, 5, 4, 3, 2},		/* 31 - 40 */

		{90, 80, 78, 77, 75, 72, 68, 65, 63, 62, 60,	/* 0 - 10 */
/* ROD */	57, 53, 50, 48, 47, 45, 42, 38, 35, 34,		/* 11 - 20 */
		33, 32, 30, 29, 27, 26, 25, 24, 23, 22,		/* 21 - 30 */
		20, 18, 16, 14, 12, 10, 8, 6, 5, 4},		/* 31 - 40 */

		{90, 75, 73, 72, 70, 67, 63, 60, 58, 57, 55,	/* 0 - 10 */
/* PETRI */	52, 48, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 75, 70, 65, 63, 62, 60,	/* 0 - 10 */
/* BREATH */	55, 50, 45, 43, 42, 40, 37, 33, 30, 29,		/* 11 - 20 */
		28, 26, 25, 24, 23, 21, 20, 19, 18, 17,		/* 21 - 30 */
		16, 15, 14, 13, 12, 11, 10, 9, 8, 7},		/* 31 - 40 */

		{90, 85, 83, 82, 80, 77, 73, 70, 68, 67, 65,	/* 0 - 10 */
/* SPELL */	62, 58, 55, 53, 52, 50, 47, 43, 40, 39,		/* 11 - 20 */
		38, 36, 35, 34, 33, 31, 30, 29, 28, 27,		/* 21 - 30 */
		25, 23, 21, 19, 17, 15, 13, 11, 9, 7}		/* 31 - 40 */
  },

 {				/* NECRO */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  },

 {				/* CONJ */
		{90, 70, 69, 68, 67, 66, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* PARA */	57, 55, 54, 53, 53, 52, 51, 50, 48, 46,		/* 11 - 20 */
		45, 44, 42, 40, 38, 36, 34, 32, 30, 28,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 55, 53, 51, 49, 47, 45, 43, 41, 40, 39,	/* 0 - 10 */
/* ROD */	37, 35, 33, 31, 30, 29, 27, 25, 23, 21,		/* 11 - 20 */
		20, 19, 17, 15, 14, 13, 12, 11, 10, 9,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 65, 63, 61, 59, 57, 55, 53, 51, 50, 49,	/* 0 - 10 */
/* PETRI */	47, 45, 43, 41, 40, 39, 37, 35, 33, 31,		/* 11 - 20 */
		30, 29, 27, 25, 23, 21, 19, 17, 15, 13,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 75, 73, 71, 69, 67, 65, 63, 61, 60, 59,	/* 0 - 10 */
/* BREATH */	57, 55, 53, 51, 50, 49, 47, 45, 43, 41,		/* 11 - 20 */
		40, 39, 37, 35, 33, 31, 29, 27, 25, 23,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */

		{90, 60, 58, 56, 54, 52, 50, 48, 46, 45, 44,	/* 0 - 10 */
/* SPELL */	42, 40, 38, 36, 35, 34, 32, 30, 28, 26,		/* 11 - 20 */
		25, 24, 22, 20, 18, 16, 14, 12, 10, 8,		/* 21 - 30 */
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0},			/* 31 - 40 */
  }

};
d3994 3
@


1.141
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.140 2008/01/01 07:32:56 jps Exp jps $
a3344 2
  extern void set_skills(struct char_data *); 
  extern void update_skills(struct char_data *);
d3421 3
a3423 2
  set_skills(new_mob);
  update_skills(new_mob);
d4345 4
@


1.140
log
@Made cold-spell freeze-ups into an event so that it can set
paralysis which won't be removed immediately after it is set.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.139 2008/01/01 05:08:34 jps Exp jps $
d26 1
d4346 4
@


1.139
log
@Stop area spells from harming things it shouldn't.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.138 2007/12/26 08:08:09 jps Exp jps $
d25 1
d850 1
d1480 2
d4345 3
@


1.138
log
@Fix formatting of caster's feedback for "conceal".
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.137 2007/11/28 10:19:39 jps Exp jps $
d3173 3
a3175 1
    if (!roomaffect_allowed && !mass_attack_ok(ch, tch, FALSE))
d4341 3
@


1.137
log
@Reduce damage from low-level NPC sorcerers.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.136 2007/11/20 20:08:15 myc Exp jps $
d3726 1
a3726 1
    send_to_char("&9&bYou vanish.&0", victim);
d4339 3
@


1.136
log
@Fixing more spells that weren't using online damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.135 2007/11/18 16:51:55 myc Exp myc $
d851 2
d925 8
d935 1
d939 1
d943 1
d947 1
d952 1
d956 1
d962 1
d966 1
d975 1
d981 1
d985 1
d1355 10
a1364 1
  
d4339 3
@


1.135
log
@Making mag_masses not hit your own pet.  Fixing some damage spells that
were doing less damage because they weren't using online damage.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.134 2007/10/27 21:49:34 myc Exp myc $
d1140 1
a1140 27
    dam = (pow(skill, 2) * 3) / 500;
    break;
  case SPELL_ENERGY_DRAIN:
    if (ch == victim) {
      act("Draining yourself?  My, aren't we funny today...",
          FALSE, ch, 0, 0, TO_CHAR);
      act("$n grabs $mself by the skull and wiggles in pain!",
          TRUE, ch, 0, 0, TO_ROOM);
      GET_HIT(ch) *= 0.75;
      return CAST_RESULT_CHARGE;
    }

    if (GET_SPECIES(victim) == SPECIES_UNDEAD) {
       send_to_char("Your spell draws upon emptiness.\r\n", ch);
       return CAST_RESULT_CHARGE;
    }

    dam += dice(2, skill + 10);
    if (skill >= 95)
      dam += number(0, 70);
    dam += (dam * skill) / 180;

    if (GET_HIT(ch) < 6 * GET_MAX_HIT(ch))
      GET_HIT(ch) += dam;
    else
      GET_HIT(ch) += 1;

d1149 1
a1149 1
    dam = (pow(skill, 2) * 27) / 1000;
d1155 1
a1155 1
    dam = (pow(skill, 2) * 1) / 100;
d1162 1
a1162 1
    dam = (pow(skill, 2) * 1) / 100;
d4309 4
@


1.134
log
@Fixed a bug in mass invis
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.133 2007/10/27 18:56:18 myc Exp myc $
a958 47
#if 0
        /* The following recently superseded by sorcerer_single_target() */
  case SPELL_BURNING_HANDS:
    /* max dam 65 from 5d4+2 online */
    dam += (pow(skill, 2) * 43) / 10000;
    break;
  case SPELL_CHILL_TOUCH:
    /* max dam 90 from 6d6+5 online */
    dam += (pow(skill, 2) * 49) / 10000;
    break;
  case SPELL_COMBUST:
    break;
  case SPELL_SHOCKING_GRASP:
    /* max dam 125 from max 8d7+9 online */
    dam += (pow(skill, 2) * 7) / 1000;
    break;
  case SPELL_LIGHTNING_BOLT:
    /* max dam 166 from 12d5+26 online */
    dam += (pow(skill, 2) * 1) / 125;
    break;
  case SPELL_FIREBALL:
    /* max dam 176 from 12d5+36 online */
    dam += (pow(skill, 2) * 1) / 125;
    if (GET_CLASS(ch) == CLASS_PYROMANCER)
      dam *= 1.25;
    break;
  case SPELL_CONE_OF_COLD:
    /* max dam 180 from 12d5+40 online */
    dam += (pow(skill, 2) * 1) / 125;
    if (GET_CLASS(ch) == CLASS_CRYOMANCER)
      dam *= 1.25;
    break;
  case SPELL_HEATWAVE:
    /* max dam 200 from 20d5+30 online */
    dam += (pow(skill, 2) * 7) / 1000;
    break;
  case SPELL_BIGBYS_CLENCHED_FIST:
    /* max dam 450 from 25d10+25 online damage to NPC's */
    /* This spells damage to PC component is less */
    dam += (pow(skill, 2) * 7) / 400;
    break;
  case SPELL_ICEBALL:
    /* max dam 400 from 20d10+25 online */
    dam += (pow(skill, 2) * 7) / 400;
    break;
#endif

d1055 1
a1055 1
    dam = (pow(skill, 2) * 7) / 1000;
d1194 1
a1194 1
    dam = (pow(skill, 2) * 33) / 2000;
d1200 1
a1200 1
    dam = (pow(skill, 2) * 33) / 2000;
d2995 1
a2995 1
      if (!attack_ok(ch, tch, FALSE))
d4335 3
@


1.133
log
@Typo in disease spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.132 2007/10/27 03:19:24 myc Exp myc $
d2507 1
d3038 9
a3046 4
    if (tch == ch)
      continue;
    if (SINFO.violent && !attack_ok(ch, tch, FALSE))
      continue;
d4382 3
@


1.132
log
@Fixed a bug with war cry spewing garbage messages.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.131 2007/10/13 05:18:11 myc Exp myc $
d1827 3
a1829 3
      act("You resist $n's foul incantation!", FALSE, ch, 0, victim, TO_CHAR);
      act("$N holds $S breath avoiding $n's diseased air!", FALSE, ch, 0, victim, TO_VICT);
      act("$N resists your disease!", TRUE, ch, 0, victim, TO_NOTVICT);
d4376 3
@


1.131
log
@Whoa immolate hits 5 times, and was doing insane damage with the new
sorcerer spell damage calculations.
Now it's not.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.130 2007/10/13 05:07:24 myc Exp myc $
d2769 1
a2769 1
    to_room = "$n looks more determined than ever!";
d2993 3
d2997 4
a3000 2
  act(to_room, TRUE, ch, 0, 0, TO_ROOM);
  send_to_char(to_char, ch);
d3004 1
a3004 1
    /* I suppose it's possible a heal could skill someone. */
d4376 5
@


1.130
log
@Added new monk chants.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.129 2007/10/11 20:14:48 myc Exp myc $
d954 3
d4371 3
@


1.129
log
@Monk chants are now implemented as magic spells, and use spell wearoffs
instead of song wearoffs.  Removed the spell wearoff messages array;
spell wearoff messages are now defined for each spell in the spello
call in spell_parser.c
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.128 2007/10/04 16:20:24 myc Exp myc $
d2503 1
d2769 81
d3010 4
a3013 3
 * mass spells affect every creature in the room except the caster.
 *
 * No spells of this class currently implemented as of Circle 3.0.
d3016 1
a3016 1
void mag_masses(int skill, struct char_data * ch, int spellnum, int savetype)
d3019 4
d3024 3
d3031 12
a3042 3
    
    switch (spellnum) {
    }
d3044 6
d3053 24
d3093 1
a3093 1
  bool group = 0;
d3099 3
a3195 1
  
d3198 2
a3199 2
    group = 0;
      
a3201 3
      
    if (tch == ch)
      continue;
d3215 1
d3218 3
d3900 1
d4368 6
@


1.128
log
@Replaced magic_wall_destruction with destroy_opposite_wall, which calls
decay_object in limits.c to actually decay the object.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.127 2007/10/02 02:52:27 myc Exp myc $
a663 2
  extern char *spell_wear_off_msg[];
  extern char *song_wear_off_msg[];  
d674 5
a678 5
	if ((af->type > 0) && (af->type <= MAX_SPELLS))
	  if (!af->next || (af->next->type != af->type) ||
	      (af->next->duration > 0))
	    if (*spell_wear_off_msg[af->type]) {
	      send_to_char(spell_wear_off_msg[af->type], i);
a680 8
        /* 600 is where monk songs start */
        if ((af->type >= 600) && (af->type <= MAX_SKILLS))
          if (!af->next || (af->next->type != af->type) ||
	      (af->next->duration > 0))
	    if (*song_wear_off_msg[af->type-599]) {
              send_to_char(song_wear_off_msg[af->type-599], i);
              send_to_char("\r\n", i);
            }
d698 3
a700 2
      if (ROOM_AFFECTED(raff->room, raff->affection)){
	send_to_room(spell_wear_off_msg[raff->spell],
d702 2
a703 1
	send_to_room("\r\n", raff->room);}
d2735 33
d2870 3
d4235 4
@


1.127
log
@A player casting mag_damage spells at another player will no longer
improve in skill.  Sense life applies the bit instead of a perception
bonus again.  (The perception is dynamically computed in db.c in
update_stats.)
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.126 2007/09/20 21:20:43 myc Exp myc $
d4095 1
a4095 1
void magic_wall_destruction(struct obj_data *wall, room_num room)
d4097 3
a4099 1
   room_num next_room;
d4101 3
a4103 13
   /* Choose a message based on the material of the wall.
    * We determine the material from the spell that caused it, for now.
    * At some time in the future, objects may have their materials
    * identified more explicitly. */

   switch (GET_OBJ_VAL(wall, 3)) {
      case (SPELL_WALL_OF_ICE):
         sprintf(buf, "%s &7&bshatters&0 into small, &4quickly-melting&0 shards.\r\n",
               wall->short_description);
         break;
      default:
         sprintf(buf, "%s&9&b crumbles to dust...\r\n", wall->short_description);
   }
d4105 1
a4105 2
   CAP(buf);
   send_to_room(buf, room);
d4107 3
a4109 1
   next_room = world[room].dir_option[GET_OBJ_VAL(wall, 0)]->to_room;
d4111 4
a4114 1
   extract_obj(wall);
d4116 12
a4127 7
   if (next_room != NOWHERE) {
      for (wall = world[next_room].contents; wall; wall = wall->next_content)
         if (GET_OBJ_TYPE(wall) == ITEM_WALL &&
               world[next_room].dir_option[GET_OBJ_VAL(wall, 0)]->to_room == room) {
            magic_wall_destruction(wall, next_room);
         }
   }
d4207 6
@


1.126
log
@Hide points and perception are in.  Concealment now gives you hide
points, sense life gives you perception, natures embrance gives
you hide points and camo, and made mag_points support hide points.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.125 2007/09/20 09:48:06 jps Exp myc $
d1415 3
d1478 1
a1478 1
 
d2632 1
a2632 2
    af[0].location = APPLY_PERCEPTION;
    af[0].modifier = skill * 3; /* max 300 */
d4206 5
@


1.125
log
@Don't allow energy draining of undead.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.124 2007/09/20 09:16:32 jps Exp jps $
d2473 2
a2515 10
  case SPELL_CONCEALMENT:

    af[0].modifier = -40;
    af[0].duration = 9 + (skill / 9); /* max 20 */
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
    to_vict = "&9&bYou vanish.&0";
    to_room = "&9&b$N&9&b slowly fades out of existence.&0";
    break;
    
d2629 2
a2630 1
    af[0].bitvector = AFF_SENSE_LIFE;
d2735 2
a2736 3
    af[0].bitvector = AFF_SNEAK | AFF_HIDE;
    af[1].bitvector3 = AFF3_CAMOUFLAGED;
    af[0].duration = af[1].duration = (skill / 3) + 1; /* range (1, 34) */
d3505 1
d3589 8
d3611 2
d4204 3
@


1.124
log
@Improve grammer in lights-on-fire message
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.123 2007/09/15 15:36:48 myc Exp jps $
d1201 6
a1206 1
      return FALSE;
d4201 3
@


1.123
log
@Nature's embrace now sets camouflage bit, which lets you be hidden as
long as you are outside.  Cleaned up affect-handling code a lot.  It
didn't properly handle bitvectors 1, 2, and 3.  Now it does.
Invigorate is now a group spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.122 2007/09/15 05:03:46 myc Exp myc $
d1475 1
a1475 1
    /* If not protected from fire, chance to catch on fire. */
d1488 1
a1488 1
            act("&1&8$n bursts into flame!&0", TRUE, victim, 0, 0, TO_ROOM);
d1492 5
a1496 3
            act("&1&8$n's $t lights you on fire!&0", TRUE, ch, (void*) spells[spellnum], victim, TO_VICT);
            act("&1&8$n's $t lights $N on fire!&0", TRUE, ch, (void*) spells[spellnum], victim, TO_NOTVICT);
            act("&1&8Your $t lights $N on fire!&0", TRUE, ch, (void*) spells[spellnum], victim, TO_CHAR);
d1500 1
a1500 1
            act("&1&8Flames envelope $n!&0", TRUE, victim, 0, 0, TO_ROOM);
d4196 6
@


1.122
log
@Implementing MOB2_NOPOISON flag.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.121 2007/09/11 16:34:24 myc Exp myc $
a856 1
  int is_mage = 0, is_cleric = 0;
a862 8
  is_mage = (GET_CLASS(ch) == CLASS_MAGIC_USER || GET_CLASS(ch) == CLASS_PYROMANCER ||
	     GET_CLASS(ch) == CLASS_CRYOMANCER || GET_CLASS(ch) == CLASS_NECROMANCER ||
	     GET_CLASS(ch) == CLASS_CONJURER || GET_CLASS(ch) == CLASS_ILLUSIONIST);
  is_cleric = (GET_CLASS(ch) == CLASS_CLERIC || GET_CLASS(ch) == CLASS_DIABOLIST ||
	       GET_CLASS(ch) == CLASS_DRUID || GET_CLASS(ch) == CLASS_PRIEST ||
	       GET_CLASS(ch) == CLASS_MYSTIC);


a1544 1
  int is_mage = FALSE, is_cleric = FALSE;
a1553 2
  is_mage = (GET_CLASS(ch) == CLASS_MAGIC_USER);
  is_cleric = (GET_CLASS(ch) == CLASS_CLERIC);
d2734 8
d2749 8
a2756 6
   if (IS_NPC(victim) && (IS_AFFECTED(victim, af[0].bitvector|af[1].bitvector) ||
    IS_AFFECTED2(victim, af[0].bitvector|af[1].bitvector) || IS_AFFECTED3(victim, af[0].bitvector|af[1].bitvector)) &&
       !affected_by_spell(victim, spellnum)) {
     send_to_char(NOEFFECT, ch);
     return CAST_RESULT_CHARGE;
   }
d2841 3
d2858 1
d2866 1
a2866 1
  bool group = 0;
d2876 2
a2877 2
    act("&3&b$n&3&b invokes $s deity's divine essence to fill the room!&0", FALSE, ch, 0, 0, TO_ROOM);
    act("&3&bYou invoke your deity's divine essence!&0", FALSE, ch, 0, 0, TO_CHAR);
d2880 3
d2885 1
d2887 1
a2887 1
    group = 0;
a2889 2
    if (ch == tch)
      continue;    
d2891 1
a2891 1
    if (is_grouped(ch, tch))
a2893 1
  perform_mag_groups(skill, ch, ch, spellnum, savetype);
d4194 3
@


1.121
log
@Added electrify skill for use by druid's electric eel.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.120 2007/09/09 01:20:14 jps Exp myc $
d2533 3
a2535 1
    if (GET_LEVEL(victim) >= LVL_IMMORT || mag_savingthrow(victim, SAVING_PARA)) {
d4191 3
@


1.120
log
@The result of casting a spell is no longer just TRUE or FALSE,
but two possible bits combined: charge and/or improve. If
CAST_RESULT_CHARGE is returned, the spell was used and the caster
will be charged (have the spell erased from memory).  If
CAST_RESULT_IMPROVE is returned, the caster may improve in that
sphere of magic.
At the same time, casters will now correctly be charged for
spells that are cast on objects.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.119 2007/09/07 01:37:09 jps Exp jps $
d1411 3
d3007 4
d3042 3
a3044 3
    /* mobs done area other mobs unless pets Banyal */
    if (IS_NPC(ch) && IS_NPC(tch) && !MOB_FLAGGED (ch, MOB_PET) &&
        !MOB_FLAGGED (tch, MOB_PET))
d4189 10
@


1.119
log
@Standardized the damage done by single-target sorcery spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.118 2007/09/04 06:49:19 myc Exp jps $
d850 2
d854 1
a854 1
bool mag_damage(int skill, struct char_data * ch, struct char_data * victim,
d862 1
a862 1
    return FALSE;
d1064 1
a1064 1
      return FALSE;
d1075 1
a1075 1
      return FALSE;
d1084 1
a1084 1
      return FALSE;
d1104 1
a1104 1
      return FALSE;
d1113 1
a1113 1
      return FALSE;
d1162 1
a1162 1
        return FALSE;
d1171 1
a1171 1
      return TRUE;
d1228 1
a1228 1
      return FALSE;
d1263 1
a1263 1
      return FALSE;
d1278 1
a1278 1
      return FALSE;
d1287 1
a1287 1
      return TRUE;
d1291 1
a1291 1
      return FALSE;
d1321 1
a1321 1
      return FALSE;
d1334 1
a1334 1
      return FALSE;
d1343 1
a1343 1
      return TRUE;
d1347 1
a1347 1
      return FALSE;
d1399 1
a1399 1
      return FALSE;
d1526 1
a1526 1
  return TRUE;
d1539 2
a1540 1
 * --Nechtrous 
d1545 1
a1545 1
bool mag_affects(int skill, struct char_data * ch, struct char_data * victim,
d1558 1
a1558 1
    return FALSE;
d1579 1
a1579 1
      return FALSE;
d1610 1
a1610 1
      return FALSE;
d1624 1
a1624 1
      return FALSE;
d1640 1
a1640 1
      return FALSE;
d1651 1
a1651 1
      return FALSE;
d1657 1
a1657 1
      return FALSE;
d1691 1
a1691 1
      return FALSE;
d1704 1
a1704 1
      return FALSE;
d1717 1
a1717 1
      return TRUE;
d1739 1
a1739 1
      return FALSE;
d1755 1
a1755 1
      return FALSE;
d1769 1
a1769 1
      return FALSE;
d1777 1
a1777 1
      return FALSE;
d1801 1
a1801 1
      return FALSE;
d1808 1
a1808 1
      return FALSE;
d1828 1
a1828 1
      return FALSE;
d1834 1
a1834 1
      return FALSE;
d1851 1
a1851 1
      return FALSE;
d1856 1
a1856 1
      return FALSE;
d1874 1
a1874 1
      return FALSE;
d1903 1
a1903 1
      return FALSE;
d1929 1
a1929 1
      return FALSE;
d1945 1
a1945 1
      return FALSE;
d1985 1
a1985 1
      return FALSE;
d2030 1
a2030 1
      return FALSE;
d2036 1
a2036 1
      return TRUE;
d2055 1
a2055 1
      return FALSE;
d2071 1
a2071 1
      return FALSE;
d2088 1
a2088 1
      return FALSE;
d2103 1
a2103 1
      return FALSE;
d2117 1
a2117 1
      return FALSE;
d2129 1
a2129 1
      return FALSE;
d2143 1
a2143 1
      return TRUE;
d2156 1
a2156 1
      return FALSE;
d2161 1
a2161 1
      return FALSE;
d2167 1
a2167 1
      return TRUE;
d2190 1
a2190 1
      return FALSE;
d2195 1
a2195 1
      return TRUE;
d2211 1
a2211 1
      return FALSE;
d2222 1
a2222 1
      return FALSE;
d2226 1
a2226 1
      return FALSE;
d2233 1
a2233 1
      return TRUE;
d2260 1
a2260 1
      return FALSE;
d2267 1
a2267 1
      return FALSE;
d2290 1
a2290 1
      return FALSE;
d2362 1
a2362 1
      return FALSE;
d2378 1
a2378 1
      return FALSE;
d2382 1
a2382 1
      return FALSE;
d2388 1
a2388 1
      return TRUE;
d2409 1
a2409 1
      return FALSE;
d2413 1
a2413 1
      return FALSE;
d2420 1
a2420 1
      return TRUE;
d2441 1
a2441 1
      return FALSE;
d2447 1
a2447 1
      return TRUE;
d2497 1
a2497 1
      return FALSE;
d2529 1
a2529 1
      return FALSE;
d2534 1
a2534 1
      return TRUE;
d2553 1
a2553 1
      return FALSE;
d2584 1
a2584 1
      return FALSE;
d2599 1
a2599 1
      return TRUE;
d2673 1
a2673 1
      return FALSE;
d2685 1
a2685 1
      return FALSE;
d2693 1
a2693 1
      return FALSE;
d2701 1
a2701 1
      return TRUE;
d2725 1
a2725 1
          return FALSE;
d2752 1
a2752 1
     return FALSE;
d2761 1
a2761 1
     return FALSE;
d2771 1
a2771 1
     return FALSE;
d2811 1
a2811 1
   return TRUE;
d2852 2
d2856 1
a2856 1
bool mag_groups(int skill, struct char_data * ch, int spellnum, int savetype)
d2862 1
a2862 1
    return FALSE;
d2865 1
a2865 1
    return FALSE;
d2886 1
a2886 1
  return TRUE;
d2918 2
d2922 1
a2922 1
bool mag_areas(int skill, struct char_data * ch, int spellnum, int savetype)
d2931 1
a2931 1
    return FALSE;
d2950 1
a2950 1
        return FALSE;
d3015 1
a3015 1
    return FALSE;
d3048 1
a3048 1
  return TRUE;
d3340 1
a3340 1
 *  Every spell which summons/gates/conjours a mob comes through here.
d3342 1
a3342 3
 *  None of these spells are currently implemented in Circle 3.0; these
 *  were taken as examples from the JediMUD code.  Summons can be used
 *  for spells like clone, ariel servant, etc.
d3345 1
a3345 4
/* whereas the old mag_summons did some stuff general to all summon spells,
 * there really /isn't/ anything common to all summon spells anymore, so i'm
 * just going to switch and handle them completely separately. -321 */
bool mag_summons(int skill, struct char_data *ch, struct obj_data *obj,
d3357 1
a3357 1
    return FALSE;
d3361 1
a3361 1
    return FALSE;
d3369 1
a3369 1
      return FALSE;
d3378 1
a3378 1
	return FALSE;
d3385 1
a3385 1
      return FALSE;
d3405 1
a3405 1
      return TRUE;
d3477 1
a3477 1
    return TRUE;
d3479 1
a3479 1
  return TRUE;
d3482 8
a3489 1
bool mag_points(int skill, struct char_data * ch, struct char_data * victim, int spellnum, int savetype) {
d3497 1
a3497 1
    return FALSE;
d3579 1
a3579 1
    return FALSE;
d3592 1
a3592 1
  return TRUE;
d3595 4
d3600 1
a3600 1
bool mag_unaffects(int skill, struct char_data * ch, struct char_data * victim,
d3607 1
a3607 1
    return FALSE;
d3613 1
a3613 1
    return TRUE;
d3620 1
a3620 1
      return FALSE;
d3626 1
a3626 1
      return FALSE;
d3667 1
a3667 1
    return FALSE;
d3672 1
a3672 1
    return FALSE;
d3684 1
a3684 1
  return TRUE;
d3688 3
a3690 1
bool mag_alter_objs(int skill, struct char_data * ch, struct obj_data * obj,
d3697 1
a3697 1
    return FALSE;
d3757 1
a3757 1
  return (to_char == NULL);
d3763 1
a3763 1
bool mag_creations(int skill, struct char_data * ch, int spellnum)
d3770 1
a3770 1
    return FALSE;
d3814 1
a3814 1
    return FALSE;
d3822 1
a3822 1
    return FALSE;
d3833 1
a3833 1
  return TRUE;
d3836 1
a3836 1
bool mag_room(int skill, struct char_data * ch, int spellnum)
d3849 1
a3849 1
    return FALSE;
d3861 1
a3861 1
      return FALSE;
d3871 1
a3871 1
      return FALSE;
d3878 1
a3878 1
      return FALSE;
d3893 1
a3893 1
    return FALSE;
d3919 1
a3919 1
  return TRUE;
d3927 1
a3927 1
   RSD 03/17/00 */
d4182 3
@


1.118
log
@Changed spells that cannot be cast indoors to use the new TAR_OUTDOORS
bit, meaning the character's spell memory won't be charged when they
cast such a spell indoors.  (The check comes at command-interpretation
time.)
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.117 2007/09/03 23:49:40 jps Exp myc $
d792 52
d937 80
d1018 6
a1043 8
  case SPELL_BURNING_HANDS:
    /* max dam 65 from 5d4+2 online */
    dam += (pow(skill, 2) * 43) / 10000;
    break;
  case SPELL_CHILL_TOUCH:
    /* max dam 90 from 6d6+5 online */
    dam += (pow(skill, 2) * 49) / 10000;
    break;
a1057 6
  case SPELL_COMBUST:
    break;
  case SPELL_SHOCKING_GRASP:
    /* max dam 125 from max 8d7+9 online */
    dam += (pow(skill, 2) * 7) / 1000;
    break;
a1188 10
  case SPELL_LIGHTNING_BOLT:
    /* max dam 166 from 12d5+26 online */
    dam += (pow(skill, 2) * 1) / 125;
    break;
  case SPELL_FIREBALL:
    /* max dam 176 from 12d5+36 online */
    dam += (pow(skill, 2) * 1) / 125;
    if (GET_CLASS(ch) == CLASS_PYROMANCER)
      dam *= 1.25;
    break;
a1192 10
  case SPELL_CONE_OF_COLD:
    /* max dam 180 from 12d5+40 online */
    dam += (pow(skill, 2) * 1) / 125;
    if (GET_CLASS(ch) == CLASS_CRYOMANCER)
      dam *= 1.25;
    break;
  case SPELL_HEATWAVE:
    /* max dam 200 from 20d5+30 online */
    dam += (pow(skill, 2) * 7) / 1000;
    break;
a1314 5
  case SPELL_BIGBYS_CLENCHED_FIST:
    /* max dam 450 from 25d10+25 online damage to NPC's */
    /* This spells damage to PC component is less */
    dam += (pow(skill, 2) * 7) / 400;
    break;
a1375 4
  case SPELL_ICEBALL:
    /* max dam 400 from 20d10+25 online */
    dam += (pow(skill, 2) * 7) / 400;
    break;
d4167 6
@


1.117
log
@Add mass_attack_ok() so that you could kill your own pet specifically,
but your area spells will not harm it.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.116 2007/09/03 21:21:17 jps Exp jps $
a30 1
extern struct weather_data weather_info;
a924 5
    if (!OUTSIDE(victim)) {
      send_to_char("This area is too enclosed to grow any plants!\r\n", ch);
      act("&9&b$n&9&b leans over with a spade trying to get some grass to grow.&0", FALSE, ch, 0, 0, TO_ROOM);
      return FALSE;
    }
a1200 8
    if (!OUTSIDE(ch) || SECT(IN_ROOM(ch)) == SECT_UNDERWATER ||
        SECT(IN_ROOM(ch)) == SECT_UNDERDARK ||
        SECT(IN_ROOM(ch)) == SECT_AVERNUS) {
      send_to_char("There's no sky visible here!\r\n", ch);
      act("$n rubs $s socks on the carpet, looking for sparks.",
          TRUE, ch, 0, victim, TO_ROOM);     
      return FALSE;
    }    
a1594 5
    if (!OUTSIDE(victim)) {
      send_to_char("There is not enough vegetation here.\r\n",ch);
      return FALSE;
    }

a1607 5
    if (!OUTSIDE(victim)) {
      send_to_char("There is not enough vegetation here.\r\n",ch);
      return FALSE;
    }

d2310 3
a2317 3
    if (!attack_ok(ch, victim, TRUE))
      return FALSE;

a2836 5
    if (!OUTSIDE(ch)) {
      act("What?! Are you crazy casting that INSIDE?!", FALSE, ch, 0, 0, TO_CHAR);
      act("The ground shakes violently!\r\n$n barely changes $s mind in time to not kill you all.", TRUE, ch, 0, 0, TO_ROOM);     
      return FALSE;
    }
a3752 4
    if (!OUTSIDE(ch) || SECT(ch->in_room) == SECT_INSIDE) {
      send_to_char("This place is too enclosed to grow foliage.\r\n",ch);
      return FALSE;
    }
d4072 4
@


1.116
log
@Magic wall updates: seen when looking in a direction; will block movement
sensibly, taking into account mounts; wall of ice can be used to douse
your flames; expiration message varies depending on what kind of
magic wall it is.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.115 2007/09/02 22:54:55 jps Exp jps $
d2960 1
a2960 1
    if (!roomaffect_allowed && !attack_ok(ch, tch, FALSE))
d4105 6
@


1.115
log
@Minor typo fixes.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.114 2007/08/30 08:51:25 jps Exp jps $
d3994 109
d4105 3
@


1.114
log
@Generalize spell evasion (globe, elemental immunity, immortal) to area spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.113 2007/08/29 01:22:18 jps Exp jps $
d2896 1
a2896 1
    to_char = "&1You conjure up a controlled shower of meteors to crush your foe!&0";
d3996 3
@


1.113
log
@Check for null target in check_guard.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.112 2007/08/28 20:17:29 myc Exp jps $
d126 76
d2970 1
a2970 5
    if (((AFF2_FLAGGED(tch, AFF2_MINOR_GLOBE) && min_spell_level <= 3) ||
	 (AFF2_FLAGGED(tch, AFF2_MAJOR_GLOBE) && min_spell_level <= 6))) {
      act("&1&bThe shimmering globe around your body flares as the spell flows around it.&0", FALSE, ch,0,tch,TO_VICT);
      act("&1&bThe shimmering globe around $N&1&b's body flares as your spell flows around it.&0", FALSE,ch,0,tch,TO_CHAR);
      act("&1&bThe shimmering globe around $N&1&b's body flares as $n&1&b's spell flows around it.&0",FALSE,ch,0,tch,TO_NOTVICT);
a2971 1
    }
d3996 3
@


1.112
log
@Gods won't catch on fire anymore.  The caster of an affection spell will
now see the to_room message if there is no to_char message and the caster
is not the victim.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.111 2007/08/26 21:49:10 jps Exp myc $
d490 1
d3925 5
@


1.111
log
@Don't say that someone stops chanting if they've been knocked out
or killed.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.110 2007/08/26 21:10:27 jps Exp jps $
d1320 1
a1320 1
  if (GET_POS(victim) > POS_DEAD && dam > 0) {
d1335 1
a1335 1
            send_to_char("&1&8Your skin and clothes ignite into flame!&0", victim);
d1343 1
a1343 1
            send_to_char("&1&8Flames spread across your body!&0", victim);
d1361 1
a1361 1
        send_to_char("&4&bYour joints stiffen as the frost penetrates you!&0", victim);
d2628 9
a2636 6
	 if (to_char != NULL && ch != victim)
	   act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	 if (to_vict != NULL)
	   act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	 if (to_room != NULL)
	   act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d3924 4
@


1.110
log
@Provide a caster feedback message for the poison spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.109 2007/08/26 19:51:43 jps Exp jps $
d481 3
d3921 3
@


1.109
log
@Fix ray of enfeeblement resisted-spell message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.108 2007/08/26 01:55:41 myc Exp jps $
d2376 1
a2376 1
    if (mag_savingthrow(victim, SAVING_PARA)) {
d2389 1
d3918 3
@


1.108
log
@Fire now does real damage.  All fire spells have a chance to catch the
victim on fire.  Mobs attempt to douse themselves.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.107 2007/08/23 00:32:24 jps Exp myc $
d2010 2
a2011 2
      act("$n tries to drain your strength but you resist!", FALSE, ch, 0, victim, TO_CHAR);
      act("$N resists your feeble attempt!", FALSE, ch, 0, victim, TO_VICT);
d3917 4
@


1.107
log
@All four elemental immunities are in effect. An elemental
resistance (such as PROT-FIRE) will mean 12.5% extra damage
from the opposing element (fire-water, air-earth). An elemental
immunity will cause 25% extra damage from the opposing element.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.106 2007/08/15 20:47:06 myc Exp jps $
d65 1
d1317 46
d2373 1
d2386 1
d3917 6
@


1.106
log
@Fly will now only automatically set you to POS_FLYING if you are awake.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.105 2007/08/03 22:00:11 myc Exp myc $
d85 1
d99 26
d778 1
a778 1
	dam += MIN(SD_BONUS(spellnum), GET_LEVEL(ch) / 4);
d780 1
a780 1
	dam += MIN(SD_BONUS(spellnum), GET_LEVEL(ch) * SD_LVL_MULT(spellnum));
d786 1
a786 1
	dam += MIN(SD_BONUS(spellnum), GET_LEVEL(ch) / 2);
d788 1
a788 1
	dam += MIN(SD_BONUS(spellnum), GET_LEVEL(ch) * SD_LVL_MULT(spellnum));
d1032 2
a1033 2
    dam += dice(2, GET_LEVEL(ch) + 10);
    if (GET_LEVEL(ch) >= 95)
d1215 2
a1216 2
    dam += dice(2, GET_LEVEL(ch) + 10);
    if (GET_LEVEL(ch) >= 95)
d1263 4
a1266 2
    act("&5&b$n&5&b executes $s spell with amazing force...&0", FALSE, ch,0,0,TO_ROOM);
    act("&5&bYou execute your spell with amazing force...&0",FALSE,ch,0,0,TO_CHAR);
d1269 43
a1311 15
  
  /* if flagged !heat and damage is fire, the spell fails*/
  if (AFF2_FLAGGED(victim, AFF2_NEGATE_HEAT) && spell_info[spellnum].damage_type == FIRE_DAMAGE) {
    act("&6$n's&6 spell has no effect on $N.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    act("&6Your spell has no effect on $N!&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&6$n's&6 spell has no effect on you!&0", FALSE, ch, 0, victim, TO_VICT);
    return TRUE;
  }
  if (AFF2_FLAGGED(victim, AFF2_NEGATE_COLD) && spell_info[spellnum].damage_type == COLD_DAMAGE) {
    act("&6$n's&6 spell has no effect on $N.&0", FALSE, ch, 0, victim, TO_NOTVICT);
    act("&6Your spell has no effect on $N!&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&6$n's&6 spell has no effect on you!&0", FALSE, ch, 0, victim, TO_VICT);
    return TRUE;
  }
  
d1678 1
a1678 1
    af[0].modifier = GET_LEVEL(ch) / (1 + ((100 - skill) / 25));
d1796 1
a1796 1
    af[0].modifier = GET_LEVEL(ch) / (1 + ((100 - skill) / 30));
d2424 1
a2424 1
    af[0].duration = (GET_LEVEL(ch) >> 1) + 4;
d2428 1
a2428 1
    /* Innate streength usage shouldn't call for a skill improvement in a spell sphere */
d3213 1
a3213 1
    base_duration = (((float)GET_LEVEL(ch) - 20.0) / 5.0 + 5.0) * 3.0;
d3493 1
a3493 1
	(GET_OBJ_WEIGHT(obj) <= 5 * GET_LEVEL(ch))) {
d3659 1
a3659 1
    ticks = GET_LEVEL(ch) / 10;
d3868 3
@


1.105
log
@Fixed some \r\n typoes in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.104 2007/08/03 03:51:44 myc Exp myc $
d1653 2
a1654 1
    GET_POS(victim) = POS_FLYING;
d1695 2
a1696 1
    GET_POS(victim) = POS_FLYING; 
d2397 2
a2398 1
    GET_POS(victim) = POS_FLYING;
d3811 3
@


1.104
log
@check_pk is now attack_ok, and covers many more cases than before,
including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
offensive attacks now use attack_ok to determine whether an attack is
allowed.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.103 2007/08/02 04:19:32 jps Exp myc $
d2121 1
a2121 1
      send_to_char("You seem unable to blind this creature.", ch);
d2149 1
a2149 1
      send_to_char("You seem unable to blind this creature.", ch);
d3808 6
@


1.103
log
@Added "moonbeam" spell for Druids.
Stop people from fighting when they become paralyzed.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.102 2007/08/02 01:04:10 myc Exp jps $
d1382 1
a1382 1
    if (check_pk(ch, victim))
d1440 1
a1440 1
    if (check_pk(ch, victim))
d1569 1
a1569 1
    if (check_pk(ch, victim))
d1592 1
a1592 1
    if (check_pk(ch, victim))
d1769 1
a1769 1
    if (check_pk(ch, victim))
d1868 1
a1868 1
    if (!check_pk(ch, victim))
d1895 1
a1895 1
    if (check_pk(ch, victim))
d1929 1
a1929 1
    if (check_pk(ch, victim))
d1961 1
a1961 1
    if (check_pk(ch, victim))
d2117 1
a2117 1
    if (check_pk(ch, victim))
d2153 1
a2153 1
    if (check_pk(ch, victim))
d2180 1
a2180 1
    if (check_pk(ch, victim))
d2267 1
a2267 1
    if (check_pk(ch, victim))
d2420 1
a2420 1
    if (check_pk(ch, victim))
d2767 1
a2767 3
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (!roomaffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
d3808 4
@


1.102
log
@check_pk() now works for all PK cases.  Moved from magic.c to fight.c
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.101 2007/08/02 00:23:53 myc Exp myc $
d1217 3
d1595 1
a1595 1
      act("$N has to strong a will to drive insane!", FALSE, ch, 0, victim, TO_CHAR);
d1597 1
a1597 1
      act("$N resists going insane at $n's beckon.", TRUE, ch, 0, victim, TO_NOTVICT);
d1868 1
a1868 1
    if (check_pk(ch, victim))
d2540 4
d3810 3
@


1.101
log
@Standardized magic check-PK function.  Cut out a LOT of unnecessary magic
code and cleaned up the whole system in general.  Magic casts are now
guaranteed to use sphere skills rather than level.  Almost all magic
functions like mag_damage or even manual spells return a boolean now:
TRUE if the cast deserves a skill improvement, FALSE if it doesn't.
This return value is ignored for object magic (wands, etc.).
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.100 2007/07/25 00:38:03 jps Exp myc $
a72 28
/*
 * This function determines whether ch attacking victim would be 
 * considered PK.  This does not consider the case where ch is a
 * shapechanged caster, because players cannot currently turn into
 * NPC casters.
 * This function overrides the general purpose check_pk function in
 * fight.c
 */
bool check_pk(struct char_data *ch, struct char_data *victim) {
  /*
   * It's disallowed PK if:
   *   neither party is a NPC
   *   pk is off
   *   the attacker is not the victim
   * OR
   *   the victim is a shapechanged player
   */
  if (!IS_NPC(ch) && !pk_allowed &&
      ((!IS_NPC(victim) && ch != victim) ||
       (victim->desc && victim->desc->original && 
        GET_LEVEL(victim->desc->original) < LVL_IMMORT))) {
    send_to_char("Player killing is not allowed!\r\n", ch);
    return TRUE;
  }

  return FALSE;
}

d3803 8
@


1.100
log
@Earthquake will send a message about shaking to the entire zone.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.99 2007/07/19 15:05:34 jps Exp jps $
d73 28
d721 1
a721 1
void mag_damage(int level, struct char_data * ch, struct char_data * victim,
d726 1
a726 13
  int new_dam = 0;
  float dam_mult = 1;
  
  int quake_dex_modifier = 0; /* This is to modify the dex roll depending on environment */
  int quake_dam_modifier = 1;
  bool imp_skill = FALSE;

  /* Declarations to use the skill system to vary spell results RSD 3/25/00 */
  int skill; 
  char broken[80] = "A wart sprouts on your nose! eeek! This spell is broken contact a god!\r\n";
  char *to_vict = NULL;
  char *to_room = NULL;
  char *to_char = NULL;
d729 1
a729 1
    return;
d740 27
a766 27
/*spell damage is now online, and is stored in array "spell_dam_info", 
 *******The defines are as such*******:
 *  #define SD_SPELL(i) spell_dam_info[i].spell
 *  #define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
 *  #define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
 *  #define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
 *  #define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
 *  #define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
 *  #define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
 *  #define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
 *  #define SD_BONUS(i) spell_dam_info[i].max_bonus
 *  #define SD_NPC_STATIC...
 *  #define SD_PC_STATIC...
 *
 ****General****
 *  - If SD_INTERN_DAM(i) = FALSE then it will look for a internal switch
 *  - Otherwise it will go through a loop using the values in the array spell_dam_info
 *  - If you wish to have Differeng class Affects simply add a class and put in its factor
 **results**
 *  pc vs pc - SD_PC_NO_DICE * SD_PC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/4)
 *  pc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
 *  npc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
 *  npc vs pc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
 *  all npc vs x is also npc * SD_NPC_REDUCE_FACTOR
 *  Add Statics onto value
 * Proky
 */
d773 3
a775 4
    
    if (((!IS_NPC(ch))  && (!IS_NPC(victim))) || (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))) {
      
      /*pc vs pc*/
d778 4
a781 5
      if (SD_USE_BONUS(spellnum)) {             
	dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/4)));
      } else {
	dam = dam + MIN(SD_BONUS(spellnum), GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
      }
d783 1
a783 2
      
      /*any other*/
d786 4
a789 5
      if (SD_USE_BONUS(spellnum)) {
	dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/2)));
      } else {
	dam = dam + MIN(SD_BONUS(spellnum), GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
      }
d791 3
a793 5
      if (IS_NPC(ch)) {

	/*reduce npc dam*/
	dam = (int)((SD_NPC_REDUCE_FACTOR(spellnum) * dam)/100);
      }
a795 2
  /*effectivly anything following will copy over online damages*/
  /*feel free to copy over what the online stuff will do*/  
a804 14
  /* Copied this snippit from above the switch in mag_affects in the hopes of making
     items that call upon spells from mag_damage use the items level and not a skill
     level of a player - RSD 9/29/2000 */ 
  /* Gurlaek 9/28/2000 */
  if( ch->casting.spell != spellnum ) {
    /* the spell is actually being called from an item so that item's */
    /* level will be used instead of the skill of the caster          */
    skill = level;
  } else {
    /* the spell is being cast so the skill will be that of the */
    /* caster's appropriate sphere for that spell               */
    skill = GET_SKILL(ch, spell_info[spellnum].sphere);    
  }

d809 1
a809 3
    new_dam = ((pow(skill, 2) * 2) / 625) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d812 2
a813 4
     /* max dam 80 from max 6d5+5 online */
    new_dam = ((pow(skill, 2) * 9) / 2000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d817 1
a817 3
    new_dam = ((pow(skill, 2) * 53) / 10000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d821 1
a821 3
    new_dam = ((pow(skill, 2) * 41) / 5000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d825 1
a825 3
    new_dam = ((pow(skill, 2) * 1) / 50) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d829 1
a829 3
    new_dam = ((pow(skill, 2) * 43) / 10000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d833 1
a833 3
    new_dam = ((pow(skill, 2) * 49) / 10000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d837 2
a838 25
    new_dam = ((pow(skill, 2) * 53) / 10000) + dam;
    if (GET_ALIGNMENT(victim) <= -750) {
      dam_mult = .25;
    } else if (GET_ALIGNMENT(victim) > -750 && GET_ALIGNMENT(victim) <= -500) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(victim) > -500 && GET_ALIGNMENT(victim) <= -350) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(victim) > -350 && GET_ALIGNMENT(victim) <= 0) {
      dam_mult = .95;
    } else if (GET_ALIGNMENT(victim) > 0 && GET_ALIGNMENT(victim) <= 350) {
      dam_mult = 1;
    } else if (GET_ALIGNMENT(victim) > 350 && GET_ALIGNMENT(victim) <= 500) {
      dam_mult = 1.15;
    } else if (GET_ALIGNMENT(victim) > 500 && GET_ALIGNMENT(victim) <= 750) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(victim) > 750) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_HELL_BOLT with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    dam = (int)(new_dam * dam_mult);
    imp_skill = TRUE;    
d842 2
a843 25
    new_dam = ((pow(skill, 2) * 53) / 10000) + dam;
    if (GET_ALIGNMENT(victim) <= -750) {
      dam_mult = 1.5;
    } else if (GET_ALIGNMENT(victim) > -750 && GET_ALIGNMENT(victim) <= -500) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(victim) > -500 && GET_ALIGNMENT(victim) <= -350) {
      dam_mult = 1.15;
    } else if (GET_ALIGNMENT(victim) > -350 && GET_ALIGNMENT(victim) <= 0) {
      dam_mult = 1;
    } else if (GET_ALIGNMENT(victim) > 0 && GET_ALIGNMENT(victim) <= 350) {
      dam_mult = .95;
    } else if (GET_ALIGNMENT(victim) > 350 && GET_ALIGNMENT(victim) <= 500) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(victim) > 500 && GET_ALIGNMENT(victim) <= 750) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(victim) > 750) {
      dam_mult = .25;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_DIVINE_BOLT with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    dam = (int)(new_dam * dam_mult);
    imp_skill = TRUE;    
d846 4
a849 5
    if(!OUTSIDE(victim)) {
      send_to_char("This area is too enclosed to grow any plants!\r\n",ch);
      to_room = "&9&b$N&9&b leans over with a spade trying to get some grass to grow.&0";
      act(to_room, TRUE, ch, 0, 0, TO_ROOM);
      return;
d852 1
a852 3
    new_dam = ((pow(skill, 2) * 53) / 10000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
a854 1
    imp_skill = TRUE;
d858 1
a858 3
    new_dam = ((pow(skill, 2) * 7) / 1000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d862 3
a864 19
    if (GET_ALIGNMENT(ch) <= -350) {
      send_to_char("You are not holy enough to cast that spell!\r\n",ch);
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) > -350 && GET_ALIGNMENT(ch) <= 0) {
      dam_mult = .2;
    } else if (GET_ALIGNMENT(ch) > 0 && GET_ALIGNMENT(ch) <= 350) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(ch) > 350 && GET_ALIGNMENT(ch) <= 500) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(ch) > 500 && GET_ALIGNMENT(ch) <= 750) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(ch) > 750) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_FLAMESTRIKE with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
d866 1
a866 2
    dam = (dam * dam_mult);
    imp_skill = TRUE;
d870 26
a895 34
      to_char = "The gods protect $N.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_vict = "You leer at $N as $E attempts to dispel your evil.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "$N tries to make the evil in Saint $n suffer.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
      dam = 0;
      return;
    } else if (IS_NEUTRAL(victim)) {
      to_char = "Yea right there fancy pants. $N doesn't seem to care.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_vict = "You don't seem to care that $N is attempting to dispel your evil.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "$n doesn't care that $N is trying to make $s evil suffer.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
      dam = 0;
      return;
    } else if (IS_EVIL(victim)) {
      /* max dam 135 from max 10d5+15 online */
      if (GET_CLASS(ch) == CLASS_PRIEST) {
	if (GET_ALIGNMENT(ch) >= 350 && GET_ALIGNMENT(ch) < 749) {
	  dam_mult = 1.15;
	} else if (GET_ALIGNMENT(ch) >= 750) { 
	  dam_mult = 1.25;
	}		  
      } else if (GET_ALIGNMENT(ch) >= 350 && GET_ALIGNMENT(ch) < 749) {
	dam_mult = 1;
      } else if (GET_ALIGNMENT(ch) >= 750 ) { 
	dam_mult = 1.1;
      }      
    }
    new_dam = ((pow(skill, 2) * 7) / 1000) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
d899 23
a921 30
      to_char = "The gods protect $N.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_vict = "You leer at $N as $E attempts to dispel your good.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "$n leers at $N as $E tries to rot $s good.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
      dam = 0;
      return;
    } else if (IS_NEUTRAL(victim)) {
      to_char = "Yea right there fancy pants. $N doesn't seem to care.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_vict = "You don't seem to care that $N is attempting to dispel your good.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "$n doesn't care that $N is trying to make $s goodness suffer.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
      dam = 0;
      return;
    } else if (IS_GOOD(victim)) {
      /* max dam 135 from max 10d5+15 online */
      if (GET_CLASS(ch) == CLASS_DIABOLIST) {	
	if (GET_ALIGNMENT(ch) <= -350 && GET_ALIGNMENT(ch) > -749) {
	  dam_mult = 1.15;	  
	} else if (GET_ALIGNMENT(ch) <= -750) { 
	  dam_mult = 1.25;
	}		  
      } else if (GET_ALIGNMENT(ch) <= -350 && GET_ALIGNMENT(ch) > -749) {
	dam_mult = 1;	
      } else if (GET_ALIGNMENT(ch) <= -750 ) { 
	dam_mult = 1.1;
      }
d923 2
a924 3
    new_dam = ((pow(skill, 2) * 7) / 1000) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
d927 2
d930 33
a962 40
    case SECT_CITY:
    case SECT_FIELD:
    case SECT_ROAD:
    case SECT_BEACH:
    case SECT_FIREPLANE:
    case SECT_EARTHPLANE:
    case SECT_EATHREALPLANE:
    case SECT_GRASSLANDS:
      quake_dex_modifier = 5; 
      quake_dam_modifier = 1;
      break;
    case SECT_FOREST:
    case SECT_RUINS:
    case SECT_SWAMP:
    case SECT_HILLS:
    case SECT_UNDERDARK:
      quake_dex_modifier = 10;
      quake_dam_modifier = 1.25;
      break;
    case SECT_MOUNTAIN:
      quake_dex_modifier = 20;
      quake_dam_modifier = 1.5;
      break;
    case SECT_INSIDE:
      dam = 0;      
      return;
    case SECT_WATER_SWIM:
    case SECT_WATER_NOSWIM:
    case SECT_UNDERWATER:
    case SECT_FLYING:
    case SECT_OCEAN:
    case SECT_ASTRALPLANE:
    case SECT_AIRPLANE:
    case SECT_AVERNUS:
      dam = 0;
      return;
    default:
      quake_dex_modifier = 0;  
      quake_dam_modifier = 1;      
      break;      
d965 7
a971 8
      to_char = "$N doesn't care that you are making the ground shake.";
      act(to_char, TRUE, ch, 0, victim, TO_CHAR);
      to_vict = "You don't seem to care that $N is attempting to knock you to the ground.";
      act(to_vict, TRUE, victim, 0, ch, TO_CHAR);
      to_room = "$n doesn't care that $N is shaking the ground.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
      dam = 0;
      return;
d974 2
a975 2
    if (!IS_AFFECTED2(victim, AFF2_LEVITATE) &&
          number(1, 100) >= (GET_DEX (victim) - quake_dex_modifier)) {
a977 7
    } else {
      to_char = "$N doesn't care that you are making the ground shake.";
      act(to_char, TRUE, ch, 0, victim, TO_CHAR);
      to_vict = "$N is unable to knock you to the ground.";
      act(to_vict, TRUE, victim, 0, ch, TO_CHAR);
      to_room = "$n manages to keep $s feet.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
d979 8
a986 4
    /* max dam 125 from max 8d7+12 online */
    new_dam = ((pow(skill, 2) * 13) / 2500) + dam;
    dam = (new_dam * quake_dam_modifier);

d993 1
a993 3
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
    dam = new_dam;
    imp_skill = TRUE;
a995 5
    if (GET_CLASS(ch) == CLASS_PYROMANCER) {
      dam_mult = 1.25;
    } else {
      dam_mult = 1;
    }
d997 3
a999 3
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
a1001 4
    /* This spell will be a special case spell that can cause damage as well as affect the
       victim with different affects based on how they save versus the different colored 
       rays in the spray. We can determine what these are at a later date, for now I'm 
       just going to integrate it into the spell proficiency system. RSD 4/1/00 */
d1003 1
a1003 3
    new_dam = ((pow(skill, 2) * 1) / 200) + dam;
    dam = new_dam;
    imp_skill = FALSE;
a1005 5
    if (GET_CLASS(ch) == CLASS_CRYOMANCER) {
      dam_mult = 1.25;
    } else {
      dam_mult = 1;
    }
d1007 3
a1009 3
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
d1013 1
a1013 3
    new_dam = ((pow(skill, 2) * 7) / 1000) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d1021 1
a1021 3
    new_dam = ((pow(skill, 2) * 3) / 500) + dam;
    dam = new_dam;
    /* Improve skill in area section */
d1025 7
a1031 40
      act("Draining yourself? My aren't we funny today....", FALSE,ch,0,victim,TO_CHAR);
      act("$n grabs $mself by the skull and wiggles in pain!", TRUE, ch, 0, victim, TO_NOTVICT);
      GET_HIT(ch) = ((float)GET_HIT(ch) * .75);
      /* No skill advancement */
      return;
    } else {
      /* This is a fairly brutal spell, so I'm going to use the Vamp Breath damage table here to
	 give different level stuff a fighting chance versus the spell. I'm also going to make 
	 the dam_mult dependent on proficiency so it can become more potent. RSD 4/2/00 */
      if (GET_LEVEL(ch) < 20)
	new_dam = dice(1, 20);
      if (GET_LEVEL(victim) >= 20 && GET_LEVEL(victim) < 40)
	new_dam = dice(2, 35);
      if (GET_LEVEL(victim) >= 40 && GET_LEVEL(victim) < 60)
	new_dam = dice(2, 50);
      if (GET_LEVEL(victim) >= 60 && GET_LEVEL(victim) < 80)
	new_dam = dice(2, 70);
      if (GET_LEVEL(victim) >= 80 && GET_LEVEL(victim) < 95)
	new_dam = dice(2, 100);
      if (GET_LEVEL(victim) >= 95 && GET_LEVEL(victim) < 99) {
	new_dam = dice(3, 90);
      }
      skill = GET_SKILL(ch, spell_info[SPELL_ENERGY_DRAIN].sphere);    
      /* Determine spell elements based on proficiency RSD 4/2/00 */
      if (skill > 0 && skill < 20) {
	dam_mult = 1;
      } else if (skill >= 20 && skill < 40) {
	dam_mult = 1.1;
      } else if (skill >= 40 && skill < 70) {
	dam_mult = 1.25;
      } else if (skill >= 70 && skill < 85) {
	dam_mult = 1.4;
      } else if (skill >= 85) {
	dam_mult = 1.5;
      } else {
	sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_ENERGY_DRAIN with 0 SKILL.", GET_NAME(ch));      
	log(buf);
	send_to_char(broken, ch);
	return;
      }
d1033 4
a1036 1
      dam = (new_dam * dam_mult);
d1038 4
a1041 4
      if ( GET_HIT(ch) < (GET_MAX_HIT(ch) * 6) )
	GET_HIT(ch) = GET_HIT(ch) + dam;
      else
        GET_HIT(ch) = GET_HIT(ch) + 1;
d1043 1
a1043 3
      imp_skill = TRUE;
      break;
    }
d1046 3
a1048 8
      act("$N has far too much life for you to harm it!", FALSE,ch,0,victim,TO_CHAR);
      dam=0;
      return;
    }
    if (GET_CLASS(ch) == CLASS_PRIEST) {
      dam_mult = 1.25;
    } else {
      dam_mult = 1;
d1051 3
a1053 3
    new_dam = ((pow(skill, 2) * 27) / 1000) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
a1055 5
    if (GET_CLASS(ch) == CLASS_CRYOMANCER) {
      dam_mult = 1.25;
    } else {
      dam_mult = 1;
    }
d1057 3
a1059 3
    new_dam = ((pow(skill, 2) * 1) / 100) + dam;
    dam = (new_dam * dam_mult);
    /* Improve skill in area section */
a1062 1
    dam_mult = 1.25;
d1064 3
a1066 3
    new_dam = ((pow(skill, 2) * 1) / 100) + dam;
    dam = (new_dam * dam_mult);
    /* Improve skill in area section */
a1068 5
    if (GET_CLASS(ch) == CLASS_DIABOLIST || GET_CLASS(ch) == CLASS_ANTI_PALADIN) {
      dam_mult=1.25;
    } else {
      dam_mult=1;      
    }
d1070 3
a1072 3
    new_dam = ((pow(skill, 2) * 33) / 2000) + dam;
    dam = (new_dam * dam_mult);
    /* Improve skill in area section */
a1074 5
    if (GET_CLASS(ch) == CLASS_PRIEST || GET_CLASS(ch) == CLASS_PALADIN) {
      dam_mult=1.25;
    } else {
      dam_mult=1;      
    }
d1076 3
a1078 3
    new_dam = ((pow(skill, 2) * 33) / 2000) + dam;
    dam = (new_dam * dam_mult);
    /* Improve skill in area section */
d1083 1
a1083 17
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) < -400 && GET_ALIGNMENT(ch) >= -550) {
      dam_mult = .2;
    } else if (GET_ALIGNMENT(ch) < -550 && GET_ALIGNMENT(ch) >= -750) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(ch) < -750 && GET_ALIGNMENT(ch) >= -900) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(ch) < -900 && GET_ALIGNMENT(ch) >= -999) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(ch) < -999) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_STYGIAN_ERUPTION with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
d1086 2
a1087 3
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
a1090 20
    if (GET_ALIGNMENT(ch) <= 400) {
      send_to_char("You are not holy enough to cast that spell!\r\n",ch);
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) > 400 && GET_ALIGNMENT(ch) <= 500) {
      dam_mult = .2;
    } else if (GET_ALIGNMENT(ch) > 500 && GET_ALIGNMENT(ch) <= 650) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(ch) > 650 && GET_ALIGNMENT(ch) <= 750) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(ch) > 750 && GET_ALIGNMENT(ch) <= 995) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(ch) > 995) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_DIVINE_RAY with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1092 2
a1093 3
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
    dam = (new_dam * dam_mult);
    imp_skill = TRUE;
d1096 10
a1105 9
    if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
      send_to_char("That spell only has effect on demonic creatures.\r\n",ch);
      return;
    }
    if(GET_ALIGNMENT(ch) >= 990 && (GET_SKILL(ch, spell_info[SPELL_LESSER_EXORCISM].sphere - GET_LEVEL(victim) > 30 && !mag_savingthrow(victim,SAVING_SPELL) && number(1,100) > 50))) {
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
      if(FIGHTING(victim))
	stop_fighting(victim);
d1107 1
a1107 1
      return;
d1111 1
a1111 17
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) > 400 && GET_ALIGNMENT(ch) <= 500) {
      dam_mult = .6;
    } else if (GET_ALIGNMENT(ch) > 500 && GET_ALIGNMENT(ch) <= 650) {
      dam_mult = .7;
    } else if (GET_ALIGNMENT(ch) > 650 && GET_ALIGNMENT(ch) <= 750) {
      dam_mult = .85;
    } else if (GET_ALIGNMENT(ch) > 750 && GET_ALIGNMENT(ch) <= 990) {
      dam_mult = 1;
    } else if (GET_ALIGNMENT(ch) > 990) {
      dam_mult = 1.25;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_LESSER_EXORCISM with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
d1115 2
a1116 2
    new_dam = ((pow(skill, 2) * 1) / 25) + dam;
    dam = (new_dam * dam_mult);
d1119 6
a1124 7
    GET_HIT(ch) = GET_HIT(ch) - (dam/15);
    if (GET_MOVE(ch) > 25) {
      GET_MOVE(ch) = MAX(20, GET_MOVE(ch) - (dam/10));
    }
    act("$n looks slightly diminished.",FALSE,ch,0,victim,TO_ROOM);
    act("You lose some life in libation of your holy allegiance!",FALSE,ch,0,victim,TO_CHAR);
    imp_skill = TRUE;
d1127 7
a1133 10
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS) || (world[victim->in_room].sector_type == SECT_INSIDE) \
	|| (world[victim->in_room].sector_type == SECT_UNDERWATER) \
	|| (world[victim->in_room].sector_type == SECT_UNDERDARK) \
	|| (world[victim->in_room].sector_type == SECT_AVERNUS)) {
      to_char = "There's no sky visible here?!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n rubs $s socks on the carpet looking for sparks.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);     
      dam = 0;      
      return;
d1140 1
a1140 3
    new_dam = ((pow(skill, 2) * 7) / 400) + dam;
    dam = new_dam;   
    imp_skill = TRUE;
d1143 1
a1143 3
    new_dam = ((pow(skill, 2) * 7) / 400) + dam;
    dam = new_dam;   
    imp_skill = TRUE;
d1145 1
a1145 1
  case  SPELL_BIGBYS_CLENCHED_FIST:
d1148 1
a1148 3
    new_dam = ((pow(skill, 2) * 7) / 400) + dam;
    dam = new_dam;   
    imp_skill = TRUE;
d1154 1
a1154 17
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) < -400 && GET_ALIGNMENT(ch) >= -550) {
      dam_mult = .2;
    } else if (GET_ALIGNMENT(ch) < -550 && GET_ALIGNMENT(ch) >= -750) {
      dam_mult = .5;
    } else if (GET_ALIGNMENT(ch) < -750 && GET_ALIGNMENT(ch) >= -900) {
      dam_mult = .75;
    } else if (GET_ALIGNMENT(ch) < -900 && GET_ALIGNMENT(ch) >= -999) {
      dam_mult = 1.25;
    } else if (GET_ALIGNMENT(ch) < -999) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_HELLFIRE_BRIMSTONE with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
d1157 2
a1158 3
    new_dam = ((pow(skill, 2) * 1) / 180) + dam;
    dam = (new_dam * dam_mult);
    /* Improve skill in area section */
d1162 1
a1162 3
    new_dam = ((pow(skill, 2) * 7) / 500) + dam;
    dam = new_dam;
    /* Improve skill in area section */
d1165 10
a1174 9
    if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
      send_to_char("That spell only has effect on demonic creatures.\r\n",ch);
      return;
    }
    if(GET_ALIGNMENT(ch) >= 990 && (GET_SKILL(ch, spell_info[SPELL_EXORCISM].sphere - GET_LEVEL(victim) > 30 && !mag_savingthrow(victim,SAVING_SPELL) && number(1,100) > 50))) {
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
      if(FIGHTING(victim))
	stop_fighting(victim);
d1176 1
a1176 1
      return;
d1180 1
a1180 17
      dam = 0;
      return;
    } else if (GET_ALIGNMENT(ch) > 400 && GET_ALIGNMENT(ch) <= 500) {
      dam_mult = .6;
    } else if (GET_ALIGNMENT(ch) > 500 && GET_ALIGNMENT(ch) <= 650) {
      dam_mult = .7;
    } else if (GET_ALIGNMENT(ch) > 650 && GET_ALIGNMENT(ch) <= 750) {
      dam_mult = .85;
    } else if (GET_ALIGNMENT(ch) > 750 && GET_ALIGNMENT(ch) <= 990) {
      dam_mult = 1;
    } else if (GET_ALIGNMENT(ch) > 990) {
      dam_mult = 1.25;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_EXORCISM with Undefined Alignment.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
d1184 2
a1185 2
    new_dam = ((pow(skill, 2) * 13) / 20) + dam;
    dam = (new_dam * dam_mult);
d1188 6
a1193 7
    GET_HIT(ch) = GET_HIT(ch) - (dam/50);
    if (GET_MOVE(ch) > 45) {
      GET_MOVE(ch) = MAX(45, GET_MOVE(ch) - (dam/10));
    }
    act("$n looks slightly diminished.",FALSE,ch,0,victim,TO_ROOM);
    act("You lose some life in libation of your holy allegiance!",FALSE,ch,0,victim,TO_CHAR);
    imp_skill = TRUE;
d1197 1
a1197 5
    new_dam = ((pow(skill, 2) * 13) / 200) + dam;
    dam = new_dam;
/*      sprintf(buf,"Damage from meteorswarm %d", dam); */
/*      log(buf); */
    /* Improve skill in the area section */
d1201 1
a1201 3
    new_dam = ((pow(skill, 2) * 13) / 200) + dam;
    dam = new_dam;
    /* Improve skill in the area section */
d1205 1
a1205 3
    new_dam = ((pow(skill, 2) * 1) / 10) + dam;
    dam = new_dam;
    /* Improve skill in manual section spells.c */
d1209 1
a1209 3
    new_dam = ((pow(skill, 2) * 1) / 10) + dam;
    dam = new_dam;
    /* Improve skill in manual section spells.c */
d1213 1
a1213 3
    new_dam = ((pow(skill, 2) * 7) / 400) + dam;
    dam = new_dam;
    imp_skill = TRUE;
d1216 4
a1219 13
    if (GET_LEVEL(ch) < 20)
      dam = dice(1, 20);
    if (GET_LEVEL(victim) >= 20 && GET_LEVEL(victim) < 40)
      dam = dice(2, 35);
    if (GET_LEVEL(victim) >= 40 && GET_LEVEL(victim) < 60)
      dam = dice(2, 50);
    if (GET_LEVEL(victim) >= 60 && GET_LEVEL(victim) < 80)
      dam = dice(2, 70);
    if (GET_LEVEL(victim) >= 80 && GET_LEVEL(victim) < 95)
      dam = dice(2, 100);
    if (GET_LEVEL(victim) >= 95 && GET_LEVEL(victim) < 99)
      dam = dice(3, 90);
    GET_HIT(ch) = GET_HIT(ch) + dam;
d1221 3
a1223 2
    /* reason i put these breaths here is because prokys structure does not
       go above MAX_SPELLS. Nechtrous*/
a1224 2
    dam = dice(10,10)+250;
    break;
a1225 2
    dam = dice(10,10)+250;
    break;
a1226 5
    dam = dice(10,10)+250;
    break;
  case SPELL_LIGHTNING_BREATH:
    dam = dice(10,10)+350;
    break;
d1228 1
a1228 1
    dam = dice(10,10)+200;
d1231 1
a1231 1
    dam = (level / 2) + dice(2, 3);
d1236 1
a1236 1
      return;
d1238 1
a1238 1
    dam = number(15, 50) + 300;
d1243 1
a1243 1
    dam = dice(3, 40) + 300;
a1245 1
    /* Area spells */
a1247 4
  /* improve skill for casting spells only not using potions etc.. */
  if( ch->casting.spell == spellnum && imp_skill )
    improve_skill(ch, spell_info[spellnum].sphere);
  
a1249 5
  if (ch!=victim && IS_NPC(victim) && 
      MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch) &&
      (GET_LEVEL(ch) < LVL_IMMORT))
    remember(victim, ch);
  
d1260 1
a1260 1
    dam += (int)(dam * (GET_LEVEL(victim)*0.01));
d1267 1
a1267 1
  if(IS_AFFECTED2(victim, AFF2_NEGATE_HEAT) && spell_info[spellnum].damage_type == FIRE_DAMAGE) {
d1271 1
a1271 1
    return;
d1273 1
a1273 1
  if(IS_AFFECTED2(victim, AFF2_NEGATE_COLD) && spell_info[spellnum].damage_type == COLD_DAMAGE) {
d1277 1
a1277 1
    return;
d1284 1
d1302 1
a1302 1
void mag_affects(int level, struct char_data * ch, struct char_data * victim,
d1310 1
a1310 1
    refresh = TRUE, imp_skill = FALSE;
a1313 7

  /* Declarations to use the skill system to vary spell results RSD 3/22/00 */
  int skill;
  int skill_diff;
  int num_roll;
  char broken[80] = "A wart sprouts on your nose! eeek! This spell is broken contact a god!\r\n";
  
d1315 1
a1315 1
    return;
a1329 11
  /* Gurlaek 9/28/2000 */
  if( ch->casting.spell != spellnum ) {
    /* the spell is actually being called from an item so that item's */
    /* level will be used instead of the skill of the caster          */
    skill = level;
  } else {
    /* the spell is being cast so the skill will be that of the */
    /* caster's appropriate sphere for that spell               */
    skill = GET_SKILL(ch, spell_info[spellnum].sphere);    
  }
  
d1335 2
a1336 2
    if(check_armor_spells(ch, victim))
      return;
d1338 5
a1342 29
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_AC;
      af[0].modifier = -5;
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_AC;
      af[0].modifier = -8;
      af[0].duration = 5;
    } else if (skill >= 40 && skill < 75) {
      af[0].location = APPLY_AC;
      af[0].modifier = -10;
      af[0].duration = 8;
    } else if (skill >= 75 && skill < 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -12;
      af[0].duration = 8;
    } else if (skill >= 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -12;
      af[0].duration = 10;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_ICE_ARMOR with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_vict="&4Your body is encased in layer of &7&bsolid ice.&0";
    to_room="&4$n's&4 body is encased in a layer of &7&bsolid ice.&0";
    imp_skill = TRUE;
d1347 5
a1351 25
    if (skill > 0 && skill < 20) {
      af[0].bitvector2 = AFF2_NEGATE_HEAT;
      af[0].duration = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_NEGATE_HEAT;
      af[0].duration = 3;
    } else if (skill >= 40 && skill < 75) {
      af[0].bitvector2 = AFF2_NEGATE_HEAT;
      af[0].duration = 4;
    } else if (skill >= 75 && skill < 95) {
      af[0].bitvector2 = AFF2_NEGATE_HEAT;
      af[0].duration = 5;
    } else if (skill >= 95) {
      af[0].bitvector2 = AFF2_NEGATE_HEAT;
      af[0].duration = 6;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_NEGATE_HEAT with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    refresh = FALSE;    
    to_vict="&6Your body becomes impervious to all forms of heat!&0";
    to_room="&6$n&6's body shimmers a bit as all heat seems to evacuate $s body.&0";
    imp_skill = TRUE;
d1356 2
a1357 21
    if (skill > 0 && skill < 20) {
      af[0].bitvector2 = AFF2_NEGATE_COLD;
      af[0].duration = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_NEGATE_COLD;
      af[0].duration = 3;
    } else if (skill >= 40 && skill < 75) {
      af[0].bitvector2 = AFF2_NEGATE_COLD;
      af[0].duration = 4;
    } else if (skill >= 75 && skill < 95) {
      af[0].bitvector2 = AFF2_NEGATE_COLD;
      af[0].duration = 5;
    } else if (skill >= 95) {
      af[0].bitvector2 = AFF2_NEGATE_COLD;
      af[0].duration = 6;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_NEGATE_COLD with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1359 2
a1360 3
    to_vict="&4&bYour body becomes impervious to the cold!&0";
    to_room="&4$n&4's body glows &bblue&0&4 briefly.&0";
    imp_skill = TRUE;
d1365 1
a1365 2
    if (IS_AFFECTED3(victim, AFF3_VAPORFORM)) {
      /* self-only spell */
d1367 1
a1367 1
      return;
d1370 2
a1371 21
    if (skill > 0 && skill < 20) {
      af[0].bitvector2 = AFF2_WATERFORM;
      af[0].duration = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_WATERFORM;
      af[0].duration = 3;
    } else if (skill >= 40 && skill < 75) {
      af[0].bitvector2 = AFF2_WATERFORM;
      af[0].duration = 4;
    } else if (skill >= 75 && skill < 95) {
      af[0].bitvector2 = AFF2_WATERFORM;
      af[0].duration = 5;
    } else if (skill >= 95) {
      af[0].bitvector2 = AFF2_WATERFORM;
      af[0].duration = 6;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_WATERFORM with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
a1374 1
    imp_skill = TRUE;
d1379 1
a1379 2
    if (IS_AFFECTED2(victim, AFF2_WATERFORM)) {
      /* self-only spell */
d1381 1
a1381 1
      return;
d1384 4
a1387 31
    if (skill > 0 && skill < 20) {
      af[0].bitvector3 = AFF3_VAPORFORM;
      af[0].location = APPLY_AC;
      af[0].modifier = -10;
      af[0].duration = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector3 = AFF3_VAPORFORM;
      af[0].location = APPLY_AC;
      af[0].modifier = -20;
      af[0].duration = 3;
    } else if (skill >= 40 && skill < 75) {
      af[0].bitvector3 = AFF3_VAPORFORM;
      af[0].location = APPLY_AC;
      af[0].modifier = -30;
      af[0].duration = 4;
    } else if (skill >= 75 && skill < 95) {
      af[0].bitvector3 = AFF3_VAPORFORM;
      af[0].location = APPLY_AC;
      af[0].modifier = -40;
      af[0].duration = 5;
    } else if (skill >= 95) {
      af[0].bitvector3 = AFF3_VAPORFORM;
      af[0].location = APPLY_AC;
      af[0].modifier = -50;
      af[0].duration = 6;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_WATERFORM with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1389 2
a1390 4
    /* self only spell */
    to_vict="&6&bYour body sublimates into a &7cloud &6of &7vapor&6.&0";
    to_room="&6&b$n's body dematerializes into a translucent &7cloud &6of &7vapor&6!&0";
    imp_skill = TRUE;
d1396 2
a1397 2
    if(check_armor_spells(ch, victim))
      return;
d1399 5
a1403 29
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_AC;
      af[0].modifier = -5;
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_AC;
      af[0].modifier = -7;
      af[0].duration = 5;
    } else if (skill >= 40 && skill < 75) {
      af[0].location = APPLY_AC;
      af[0].modifier = -7;
      af[0].duration = 7;
    } else if (skill >= 75 && skill < 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -9;
      af[0].duration = 7;
    } else if (skill >= 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -11;
      af[0].duration = 9;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_MIRAGE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_room="&1$n's&1 form begins to waver as a wave of heat blurs the air around $m.&0";
    to_vict="&1Your form begins to waver as a wave of heat blurs the air around you.&0";
    imp_skill = TRUE;
d1407 8
a1414 10
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
d1416 1
a1416 9
    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {      
      to_char = "&9&b$n&9&b resists your&9&b column of smoke!&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_vict = "&9&bYou&9&b resist $n's&9&b column of smoke!&0";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      to_room = "&9&b$N&9&b resists $n's&9&b column of smoke!&0";
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);     
      return;
    } else if (mag_savingthrow(victim, savetype)) {
d1419 1
a1419 6
      af[0].duration = 0;
      /* af[0].bitvector = AFF_BLIND; */
      /* Don't want blindness affect on saved spell so I'm leaving it out. */

      /* Zero Duration lasts from 0 to 75 (tick length) seconds */
      
a1423 4
      /* Question:  What is to prevent this spell from being cast repeatedly
	 causing the modifiers for the locations to become cummulative?
	 RSD
      */
a1424 1
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
a1425 1
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);      
d1427 15
a1441 21
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT); 
      imp_skill = TRUE;
      return;
    }  
    
    /* No skill check for proficiency, if you get this off, you get it off */
    
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4;
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;
    
    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;
    
    to_room = "&9&b$N&9&b is blinded by $n's&9&b column of smoke!&0";
    to_vict = "&9You have been blinded by $n's&9&b column of smoke&0";
    to_char = "&9&b$N&9&b is blinded by your column of smoke!&0";
    imp_skill = TRUE;
d1448 1
a1448 1
      return;
d1450 1
a1450 1
    if(!OUTSIDE(victim)) {
d1452 1
a1452 1
      return;
d1455 4
a1458 26
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_AC;
      af[0].modifier = -15;
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_AC;
      af[0].modifier = -15;
      af[0].duration = 7;
    } else if (skill >= 40 && skill < 75) {
      af[0].location = APPLY_AC;
      af[0].modifier = -18;
      af[0].duration = 7;
    } else if (skill >= 75 && skill < 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -20;
      af[0].duration = 10;
    } else if (skill >= 95) {
      af[0].location = APPLY_AC;
      af[0].modifier = -21;
      af[0].duration = 12;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_GAIAS_CLOAK with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1460 2
a1461 3
    to_room="&2A cyclone of leaves and sticks twirl around $n&2, guarding $s body.&0";
    to_vict="&2A cyclone of leaves and sticks twirl around you, guarding your body.&0";
    imp_skill = TRUE;
d1465 4
a1468 19
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL)) {
      send_to_char("A flash of white light fills the room, dispelling your "
                   "violent magic!\r\n", ch);
      act("White light from no particular source suddenly fills the room, "
          "then vanishes.", FALSE, ch, 0, 0, TO_ROOM);
      return;
    }
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if(!OUTSIDE(victim)) {
d1470 1
a1470 1
      return;
d1472 1
d1474 1
a1474 1
    if(mag_savingthrow(victim, SAVING_PARA) ||
d1476 5
a1480 11
      to_char="&2&bYour crop of ripe vines search in vain for $N.&0";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_vict="&2&bA crop of ripe vines snakes along the ground unable to locate you!&0";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      to_room="&2&bA crop of ripe vines searches in vain for $N.&0";
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);

      improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);

      /* start combat if failure */
      if(!FIGHTING(victim)) {
d1484 2
d1487 4
a1490 1
      return;
d1492 1
a1492 2

    if (skill > 0 && skill < 20) {
d1494 5
a1498 37
      af[0].duration = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
      af[0].duration = 3;
    } else if (skill >= 40 && skill < 75) {
      if(number(0, 100) < 2) {
	af[0].bitvector = AFF_MAJOR_PARA;
	af[0].duration = 2;
      } else {
	af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
	af[0].duration = 4;
      }
    } else if (skill >= 75 && skill < 95) {
      if(number(0, 100) < 7) {
	af[0].bitvector = AFF_MAJOR_PARA;
	af[0].duration = 2;
      } else {
	af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
	af[0].duration = 5;
      }      
    } else if (skill >= 95) {
      if(number(0, 100) < 10) {
	af[0].bitvector = AFF_MAJOR_PARA;
	af[0].duration = 3;
      } else {
	af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
	af[0].duration = 6;
      }
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_ENTANGLE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
    to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
    to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
a1499 1
    imp_skill = TRUE;
d1504 3
a1506 10
    /* No super Monks! */
    if (GET_CLASS(victim) == CLASS_MONK) {
      af[0].location = APPLY_AC;
      af[0].modifier = 5;
      af[0].duration = 2;
      to_char="&3$n's&3 skin resists your bark and corrodes!&0";
      to_vict="&3Your skin resists the bark and burns! OUCH OUCH OUCH!&0";
      to_room="&3$n's&3 skin resists $N's bark and corrodes!&0";      
      /* NO IMPROVE SKILL CALL */
      break;
d1508 7
a1514 37
      /* Check for other types of armor spells */
    } else if (check_armor_spells(ch, victim))
      return;
    else {
      
      /* Determine spell elements based on proficiency RSD 3/25/00 */
      if (skill > 0 && skill < 20) {
	af[0].location = APPLY_AC;
	af[0].modifier = -7;
	af[0].duration = 5;
      } else if (skill >= 20 && skill < 35) {
	af[0].location = APPLY_AC;
	af[0].modifier = -9;
	af[0].duration = 7;
      } else if (skill >= 35 && skill < 50) {
	af[0].location = APPLY_AC;
	af[0].modifier = -12;
	af[0].duration = 10;
      } else if (skill >= 50 && skill < 85) {
	af[0].location = APPLY_AC;
	af[0].modifier = -16;
	af[0].duration = 14;
      } else if (skill >= 85) {
	af[0].location = APPLY_AC;
	af[0].modifier = -18;
	af[0].duration = 15;
      } else {
	sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_BARKSKIN with 0 SKILL.", GET_NAME(ch));      
	log(buf);
	send_to_char(broken, ch);
	return;
      }
    }
    to_char="&3$N's&3 skin hardens to bark.&0";
    to_vict="&3Your skin hardens to bark.&0";
    to_room="&3$N's&3 skin hardens to bark.&0";
    imp_skill = TRUE;
d1519 10
a1528 35
    if ((affected_by_spell(victim, SPELL_INFRAVISION))) {
      to_char = "You are already enchanted with enhanced vision.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n looks a little overprotective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/25/00 */
    if (skill > 0 && skill < 20) {
      /* Nearly instant wearing off, this is intentional */
      af[0].bitvector2 = AFF2_ULTRAVISION;
      af[0].duration = 0;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_ULTRAVISION;
      af[0].duration = 1;
    } else if (skill >= 40 && skill < 70) {
      af[0].bitvector2 = AFF2_ULTRAVISION;
      af[0].duration = 2;
    } else if (skill >= 70 && skill < 85) {
      af[0].bitvector2 = AFF2_ULTRAVISION;
      af[0].duration = 3;
    } else if (skill >= 85) {
      af[0].bitvector2 = AFF2_ULTRAVISION;
      af[0].duration = 4; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_NIGHT_VISION with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_room="$N's eyes glow a dim neon green!";
    to_vict="&9&bYour vision sharpens a bit.";
    imp_skill = TRUE;
d1534 28
a1561 68
      to_char = "$N is already blessed by some other gods.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_room = "$n looks a little overprotective.";
      act(to_room, TRUE, ch, 0, 0, TO_ROOM);
      /* No improve skill check */
      return;
    }
    /* Alignement Checks! */
    if (GET_ALIGNMENT(victim) >= 350) {
      to_char="You can't protect an evil ally if they are GOOD!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_vict="$n tries to enrage your inner demon.\r\nSilly isn't $e?";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      to_room="$n fails to enrage $N's inner demon.";
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
    } else
      
    /* Determine spell elements based on proficiency RSD 3/25/00 */
    if (skill > 0 && skill < 20) {
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -1;
      af[1].duration = 5;
      to_char="You summon allegiance from your dark gods to protect $N."; 
      to_vict="&9&bA dark presence fills your mind.&0";
      to_room="$n siezes up in pain!\r\n $n grabs $N who is surrounded by a dark presence.";
    } else if (skill >= 20 && skill < 55) {
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -1;
      af[1].duration = 8;
      to_char="You summon allegiance from your dark gods to protect $N."; 
      to_vict="&9&bA dark presence fills your mind.&0";
      to_room="$n siezes up in pain!\r\n $n grabs $N who is surrounded by a dark presence.";
    } else if (skill >= 55 && skill < 75) {
      af[0].location = APPLY_DAMROLL;
      af[0].modifier = 1;
      af[0].duration = 8;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -2;
      af[1].duration = 8;
      to_char="You summon allegiance from your dark gods to protect and enrage $N."; 
      to_vict="&9&bA dark presence fills your mind and body!&0";
      to_room="$n siezes up in pain!\r\n $n grabs $N who is enraged by a dark presence.";      
    } else if (skill >= 75 && skill < 95) {
      af[0].location = APPLY_DAMROLL;
      af[0].modifier = 1;
      af[0].duration = 12;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -2;
      af[1].duration = 12;
      to_char="You summon allegiance from your dark gods to protect and enrage $N."; 
      to_vict="&9&bA dark presence fills your mind and body!&0";
      to_room="$n siezes up in pain!\r\n $n grabs $N who is enraged by a dark presence.";
    } else if (skill >= 95) {
      af[0].location = APPLY_DAMROLL;
      af[0].modifier = 2;
      af[0].duration = 12;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -2;
      af[1].duration = 12;
      to_char="You summon allegiance from your dark gods to protect and enrage $N."; 
      to_vict="&9&bA dark presence fills your mind and body!&0";
      to_room="$n siezes up in pain!\r\n $n grabs $N who is enraged by a dark presence.";
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DARK_PRESENCE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
a1562 1
    imp_skill = TRUE;
d1568 1
a1568 1
      return;
d1571 7
a1577 9
    if (GET_ALIGNMENT(victim) >= 350) {
      to_char="You can't protect an evil ally if they are GOOD!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_vict="$n tries to wrap you in demonic skin!\r\nSilly isn't $e?";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      to_room="$n fails to wrap $N is a demonic skin of protection.";  
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
    } else if (GET_ALIGNMENT(victim) > 0 && GET_ALIGNMENT(victim) < 350) {
d1581 7
a1587 28
      af[1].bitvector2 = AFF2_PROT_FIRE;
      af[1].duration = 5;
    } else {
      
      /* Determine spell elements based on proficiency RSD 3/24/00 */
      if (skill > 0 && skill < 35) {
	af[0].location = APPLY_AC;
	af[0].modifier = -10;
	af[0].duration = 10;
	af[1].bitvector2 = AFF2_PROT_FIRE;
	af[1].duration = 10;      
      } else if (skill >= 35 && skill < 81) {
	af[0].location = APPLY_AC;
	af[0].modifier = -12;
	af[0].duration = 12;
	af[1].bitvector2 = AFF2_PROT_FIRE;
	af[1].duration = 12;
      } else if (skill >= 81) {
	af[0].location = APPLY_AC;
	af[0].modifier = -15;
	af[0].duration = 12;
	af[1].duration = 12;
      } else {
	sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DEMONSKIN with 0 SKILL.", GET_NAME(ch));      
	log(buf);
	send_to_char(broken, ch);
	return;      
      }
d1589 2
a1590 3
    to_vict="&1Your skin toughens into a dark red hide.&0";
    to_room="&1$N's&1 skin toughens into a dark red hide.&0";
    imp_skill = TRUE;
d1594 20
a1613 81
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if(mag_savingthrow(victim, SAVING_SPELL)) {
      to_vict="You resist $n's foul incantation!";
      to_room="$N holds $S breath avoiding $n's diseased air!";
      to_char="$N resists your disease!";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      imp_skill = TRUE;
      return;
    } /* Heh, removed if(NPC) logic to modify NPC attribs that were
	 still on the 18 scale even though PC's were on the 100 scale.
	 Gurlaek is still the man RSD 3/26/00
       */

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].bitvector2 = AFF2_DISEASE;
      af[0].duration = 5;    
      af[1].location = APPLY_CON;
      af[1].modifier = -10;
      af[1].duration = 5;    
      af[2].location = APPLY_STR;
      af[2].modifier = -5;
      af[2].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_DISEASE;
      af[0].duration = 8;    
      af[1].location = APPLY_CON;
      af[1].modifier = -12;
      af[1].duration = 8;    
      af[2].location = APPLY_STR;
      af[2].modifier = -12;
      af[2].duration = 8;
    } else if (skill >= 40 && skill < 70) {
      af[0].bitvector2 = AFF2_DISEASE;
      af[0].duration = 10;    
      af[1].location = APPLY_CON;
      af[1].modifier = -15;
      af[1].duration = 10;    
      af[2].location = APPLY_STR;
      af[2].modifier = -15;
      af[2].duration = 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].bitvector2 = AFF2_DISEASE;
      af[0].duration = 12;    
      af[1].location = APPLY_CON;
      af[1].modifier = -17;
      af[1].duration = 12;    
      af[2].location = APPLY_STR;
      af[2].modifier = -17;
      af[2].duration = 12;
    } else if (skill >= 85) {
      af[0].bitvector2 = AFF2_DISEASE;
      af[0].duration = 15;    
      af[1].location = APPLY_CON;
      af[1].modifier = -20;
      af[1].duration = 15;    
      af[2].location = APPLY_STR;
      af[2].modifier = -20;
      af[2].duration = 15;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DISEASE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_char="Your diseased air infects $N!";
    to_vict="&3You choke and gasp on $n's foul air as a sick feeling overtakes you. You feel seriously ill!&0";
    to_room="&3$N&3 chokes and gasps on $n's foul air, $E looks seriously ill!";
    imp_skill = TRUE;
d1617 7
a1623 20
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if(mag_savingthrow(victim, SAVING_SPELL)) {
      to_char="$N has to strong a will to drive insane!";
      to_vict="Your strength of will protects you from an insane suggestion from $n... This time...";
      to_room="$N resists going insane at $n's beckon.";      
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      improve_skill(ch, spell_info[SPELL_INSANITY].sphere);
      return;
d1625 1
a1625 1
    /* If you get this one off, you get it off, NO PROFICIENCY CHECKS */
d1627 6
a1632 8
    af[0].duration = 5;    
    af[1].location = APPLY_WIS;
    af[1].modifier = -50;
    af[1].duration = 5;
    to_char="You cause &5$N to snap... A crazed gleam fills $S eyes.&0";
    to_vict="&5You go out of your &bMIND!&0";
    to_room="&5$N's&5 psyche snaps... A crazed gleam fills $S eyes.&0";
    imp_skill = TRUE;
d1641 1
a1641 1
      return;
d1644 7
a1650 48
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      /* Making very light apply_hit affect so as not to cause huge advantage with vit */
      af[0].location = APPLY_HIT;
      af[0].modifier = (int)(GET_LEVEL(ch) / 5); /* Seems a nice variable algorythm that causes a weak vit */
      af[0].duration = 5;
      
      af[1].location = APPLY_STR;
      af[1].modifier = 5;
      af[1].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_HIT;
      af[0].modifier = (int)(GET_LEVEL(ch) / 4);
      af[0].duration = 6;
      
      af[1].location = APPLY_STR;
      af[1].modifier = 5;
      af[1].duration = 6;
    } else if (skill >= 40 && skill < 70) {
      af[0].location = APPLY_HIT;
      af[0].modifier = (int)(GET_LEVEL(ch) / 3);
      af[0].duration = 6;
      
      af[1].location = APPLY_STR;
      af[1].modifier = 8;
      af[1].duration = 6;
    } else if (skill >= 70 && skill < 85) {
      af[0].location = APPLY_HIT;
      af[0].modifier = (int)(GET_LEVEL(ch) / 2);
      af[0].duration = 8;
      
      af[1].location = APPLY_STR;
      af[1].modifier = 10;
      af[1].duration = 8;
    } else if (skill >= 85) {
      af[0].location = APPLY_HIT;
      af[0].modifier = (int)(GET_LEVEL(ch));
      af[0].duration = 10;
      
      af[1].location = APPLY_STR;
      af[1].modifier = 12;
      af[1].duration = 10;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DEMONIC_ASPECT with 0 SKILL.", GET_NAME(ch));
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1653 1
a1653 1
    af[0].modifier = (float) af[0].modifier * ((float) GET_ALIGNMENT(victim) / -1000.0);
a1654 1
    /* Self only spell */
d1656 2
a1657 2
      to_vict="&1Your body fills with a demonic strength.&0";
      to_room="&1$n's&1 body &bglows red&0&1 briefly and grows stronger.&0";
d1660 3
a1662 3
      af[0].modifier = (float) af[0].modifier * 2.5;
      to_vict="&1Your body fills with a demonic strength.&0";
      to_room="&1$n's eyes flash &8red&0&1 as $e suddenly sprouts horns!&0";
a1663 1
    imp_skill = TRUE;
d1669 2
a1670 2
         send_to_char("You already have something sticking out of your back.\r\n", ch);
         return;
d1673 6
a1678 27
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 10;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 15;
    } else if (skill >= 40 && skill < 70) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 20;
    } else if (skill >= 70 && skill < 85) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 25;
    } else if (skill >= 85) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 30; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_WINGS_OF_HELL with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    /* Self only spell */
    to_vict="&1&bHuge leathery &9bat-like&1 wings sprout from your back.&0";
    to_room="&1&bHuge leathery &9bat-like&1 wings sprout out of $n's&1&b back.&0";
    GET_POS(victim) = POS_FLYING; 
    imp_skill = TRUE;
d1688 9
a1696 11

    if ((affected_by_spell(victim, SPELL_LESSER_ENDURANCE)) || 	
	(affected_by_spell(victim, SPELL_ENDURANCE)) || 
	(affected_by_spell(victim, SPELL_GREATER_ENDURANCE)) || 
	(affected_by_spell(victim, SPELL_VITALITY)) || 
	(affected_by_spell(victim, SPELL_GREATER_VITALITY)) || 
	(affected_by_spell(victim, SPELL_DRAGONS_HEALTH)))
      {
	      act("Nothing happens!\r\n", FALSE, ch, 0, victim, TO_CHAR);
	      return; 
      };
d1702 4
a1705 9
    to_vict=get_vitality_vict_message(spellnum); 
    to_room="$N looks healthier than before!";
    to_char="$N looks healthier than before!";

    /* Improve skill calls - RSD 3/17/00 */

    imp_skill = TRUE;
    
    /* 20 percent chance of protection chance getting called */
a1706 11
    /* 
       First off, it's in the sphere of enchanting, and second, 
       this, coupled with the imp_skill line above gives double
       improvement, which seems silly to me.  I'm cutting it 
       for now. 

   if(number(1,100) > 80) { 
      improve_skill(ch, spell_info[spellnum].sphere);
	}
    */
    break;
d1710 2
a1711 2
         send_to_char("You already have something sticking out of your back.\r\n", ch);
         return;
d1714 5
a1718 25
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 10;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 15;
    } else if (skill >= 40 && skill < 70) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 20;
    } else if (skill >= 70 && skill < 85) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 25;
    } else if (skill >= 85) {
      af[0].bitvector=AFF_FLYING;
      af[0].duration= 30; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_WINGS_OF_HEAVEN with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    /* Self only spell */
    to_vict="&7&bBeautiful bright white wings unfurl behind you as you lift into the air.&0";
    to_room="&7&bBeautiful bright white wings unfurl from $n's&7&b back, lifting $m into the air.&0";
a1719 1
    imp_skill = TRUE;
d1724 4
a1727 22
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 10;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 15;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 20;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 25;
    } else if (skill >= 85) {
      af[0].duration= 30; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_SPEAK_IN_TONGUES with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    af[0].bitvector2=AFF2_TONGUES;
    /* Self only spell */
    to_vict="You feel ready to speak in any language.";
    to_room="$n's head glowls for a moment.";
    imp_skill = TRUE;
d1732 16
a1747 16
    if(is_abbrev(buf2,"fire")) {
      af[0].bitvector2=AFF2_PROT_FIRE;
      to_vict="You are warded from &1fire&0.";
      to_char="You protect $n from &1fire&0.";
    } else if (is_abbrev(buf2,"cold")) {
      af[0].bitvector2=AFF2_PROT_COLD;
      to_vict="You are warded from the &4cold&0.";
      to_char="You protect $n from the &4cold&0.";
    } else if (is_abbrev(buf2,"air")) {
      af[0].bitvector2=AFF2_PROT_AIR;
      to_vict="You are warded from &6&bair&0.";
      to_char="You protect $n from &6&bair&0.";
    } else if (is_abbrev(buf2,"earth")) {
      af[0].bitvector2=AFF2_PROT_EARTH;
      to_vict="You are warded from &3earth&0.";
      to_char="You protect $n from &3earth&0.";
d1749 2
a1750 2
      send_to_char("What element do you want to ward against?\r\n",ch);
      return;
d1753 2
a1754 19
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 9;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_ELEMENTAL_WARDING with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_room="&7&b$N&7&b glows briefly.&0";
    imp_skill = TRUE;
d1760 10
a1769 1
    /* This is a self only spell */
d1771 2
a1772 51
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_SAVING_SPELL;
      af[0].modifier = -1;
      af[0].duration = 5;
      
      af[1].location = APPLY_HIT;
      /* If they aren't saintly then they get a percentage of what they should */
      af[1].modifier = (int)((GET_LEVEL(ch) / 3) * (GET_ALIGNMENT(ch) / (float)1000));
      af[1].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_SAVING_SPELL;
      af[0].modifier = -1;
      af[0].duration = 5;
      
      af[1].location = APPLY_HIT;
      af[1].modifier = (int)((GET_LEVEL(ch) / 2) * (GET_ALIGNMENT(ch) / (float)1000));
      af[1].duration = 5;      
    } else if (skill >= 40 && skill < 70) {
      af[0].location = APPLY_SAVING_SPELL;
      af[0].modifier = -2;
      af[0].duration = 7;
      
      af[1].location = APPLY_HIT;
      af[1].modifier = (int)((GET_LEVEL(ch) / 2) * (GET_ALIGNMENT(ch) / (float)1000));
      af[1].duration = 7;
    } else if (skill >= 70 && skill < 85) {
      af[0].location = APPLY_SAVING_SPELL;
      af[0].modifier = -2;
      af[0].duration = 9;
      
      af[1].location = APPLY_HIT;
      af[1].modifier = (int)(GET_LEVEL(ch) * (GET_ALIGNMENT(ch) / (float)1000));  
      af[1].duration = 9;
    } else if (skill >= 85) {
      af[0].location = APPLY_SAVING_SPELL;
      af[0].modifier = -2;
      af[0].duration = 12;
      
      af[1].location = APPLY_HIT;
      af[1].modifier = (int)(GET_LEVEL(ch) * (GET_ALIGNMENT(ch) / (float)1000));
      af[1].duration = 12;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_PRAYER with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_vict="Your prayer is answered...\r\nYou feel full of life!";
    to_room="$N perks up, looking full of life.";
    imp_skill = TRUE;
a1776 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 15;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 30;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 50;
    } else if (skill >= 85) {
      af[0].duration = 60;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_MAGIC_TORCH with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1778 1
d1780 2
a1781 3
    to_vict="&1A magical flame bursts into focus, lighting the area.&0";
    to_room="&1A magical flame bursts into focus, lighting the area.&0";
    imp_skill = TRUE;
a1785 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 15;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 30;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 50;
    } else if (skill >= 85) {
      af[0].duration = 60;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_CIRCLE_OF_LIGHT with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1787 1
d1789 2
a1790 3
    to_vict="&7&bA bright white circle of light begins hovering about your head.&0";
    to_room="&7&bA bright white circle of light appears over $N's&7&b head.";
    imp_skill = TRUE;
d1794 2
a1795 32
     if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if(mag_savingthrow(victim, SAVING_PARA)) {
      to_char="$N has to strong a will to scare!";
      to_vict="Your strength of will protects you from a fearful suggestion from $n... This time...";
      to_room="$N isn't scared of $n. Nyah!";      
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      imp_skill = TRUE;
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].bitvector2 = AFF2_FEAR;
      af[0].duration= 0;
    } else if (skill >= 20 && skill < 40) {
      af[0].bitvector2 = AFF2_FEAR;
      af[0].duration= 1;
    } else if (skill >= 40 && skill < 70) {
      af[0].bitvector2 = AFF2_FEAR;
      af[0].duration= 2;
d1797 6
a1802 6
      af[1].location = APPLY_DAMROLL;
      af[1].modifier = -1;
      af[1].duration = 2;
    } else if (skill >= 70 && skill < 85) {
      af[0].bitvector2 = AFF2_FEAR;
      af[0].duration= 2;
d1804 3
d1808 6
a1813 19
      af[1].modifier = -2;
      af[1].duration = 2;
    } else if (skill >= 85) {
      af[0].bitvector2 = AFF2_FEAR;
      af[0].duration= 3; 

      af[1].location = APPLY_DAMROLL;
      af[1].modifier = -3;
      af[1].duration = 3;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_FEAR with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    to_char="You scare the bejeezus outta $N! Muahahaha!";
    to_vict="&9&bA rush of fear sweeps through your body!&0";
    to_room="$n sneaks up on $N and &9&ba look of terror sweeps over $S&9&b face!&0\r\n$n throws back $s head and cackles with insane glee!";
    imp_skill = TRUE;
d1818 3
a1820 3
    if(IS_AFFECTED2(ch, AFF2_HARNESS)) {
      send_to_char("You have already harnessed your energy!\r\n",ch);
      return;
a1822 10
    if (skill > 0 && skill < 20) {
      af[0].duration= 0;
    } else if (skill >= 20) {
      af[0].duration= 1;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_HARNESS with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1824 1
d1826 2
a1827 4
    victim = ch;
    to_vict="&4&bYour veins begin to pulse with energy!&0";
    to_room="&4&b$n&4&b's veins bulge as a surge of energy rushes into $m!&0";
    imp_skill = TRUE;
d1832 5
a1836 27
    if(AFF2_FLAGGED(victim, AFF2_MAJOR_GLOBE)) {
      to_char = "$N's globe of invulnerability resists your spell!";
      to_vict = "Your globe of invulnerability resists $n's spell.";
      to_room = "$n tries to add an additional globe of protection to $N.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      /* NO IMPROVE SKILL CALL */
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 1;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 2;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 3;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 4;
    } else if (skill >= 85) {
      af[0].duration= 5; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_MINOR_GLOBE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d1838 1
d1840 1
a1844 1
    imp_skill = TRUE;
d1849 5
a1853 27
    if(AFF2_FLAGGED(victim, AFF2_MINOR_GLOBE)) {
      to_char = "$N's minor globe of invulnerability resists your spell!";
      to_vict = "Your minor globe of invulnerability resists $n's spell.";
      to_room = "$n tries to add an additional globe of protection to $N.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      /* NO IMPROVE SKILL CALL */
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 4;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 5;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 7;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 8;
    } else if (skill >= 85) {
      af[0].duration= 9; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_MAJOR_GLOBE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d1855 1
d1857 1
a1861 1
    imp_skill = TRUE;
d1866 1
a1866 1
    if(AFF2_FLAGGED(ch, AFF2_FIRESHIELD)) {
d1868 1
a1868 1
      return;
a1870 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 1;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 2;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 3;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 4;
    } else if (skill >= 85) {
      af[0].duration= 5; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_COLDSHIELD with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1872 1
d1874 2
a1875 3
    to_vict="&4A jagged formation of i&bc&7e sh&4ard&0&4s forms around you.&0";
    to_room="&4A jagged formation of i&bc&7e sh&4ard&0&4s forms around $N&0&4.&0";
    imp_skill = TRUE;
d1880 1
a1880 1
    if(AFF2_FLAGGED(ch, AFF2_COLDSHIELD)) {
d1882 1
a1882 1
      return;
a1884 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 1;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 2;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 3;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 4;
    } else if (skill >= 85) {
      af[0].duration= 5; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_FIRESHIELD with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1886 1
d1888 2
a1889 3
    to_vict="&1A burning shield of f&bi&3r&7e&0&1 explodes from your body!&0";
    to_room="&1A burning shield of f&bi&3r&7e&0&1 explodes from $N&0&1's body!&0";
    imp_skill = TRUE;
d1893 2
a1894 18
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL)) {
      send_to_char("A flash of white light fills the room, dispelling your "
                   "violent magic!\r\n", ch);
      act("White light from no particular source suddenly fills the room, "
          "then vanishes.", FALSE, ch, 0, 0, TO_ROOM);
      return;
    }
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
d1896 1
a1896 1
    if(mag_savingthrow(victim, SAVING_PARA) ||
d1898 3
a1900 6
      to_char="&7&b$N resists your weak paralysis.&0";
      to_vict="&7&b$n tries to paralize you but fails!&0";
      to_room="&7&b$n squints at $N but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d1902 2
a1903 4
      improve_skill(ch, spell_info[SPELL_MINOR_PARALYSIS].sphere);

      /* start combat if failure */
      if(!FIGHTING(victim)) {
d1907 2
a1908 2
     
      return;
a1910 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 3;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 5;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 7;
    } else if (skill >= 85) {
      af[0].duration= 8; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_MINOR_PARALYSIS with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1912 1
d1914 3
a1916 4
    to_char="You paralyze $N! WooHoo!";
    to_vict="&7&bAll motion in your body grinds to a halt.&0";
    to_room="&7&bAll motion in $N&7&b's body grinds to a halt.&0";    
    imp_skill = TRUE;
d1920 13
a1932 58
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if(IS_AFFECTED3(victim, AFF3_RAY_OF_ENFEEB)) {
      to_char="$N is already feeble enough dammit.";
      to_vict="$n seems to be looking at you funny.";
      to_room="&7&b$n squints at $N but nothing happens.&0"; 
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      /* NO IMPROVE SKILL CALL */
      return;
    }
    if(mag_savingthrow(victim, savetype)) {
      to_vict="$n tries to drain your strength but you resist!";
      to_char="$N resists your feeble attempt!";
      to_room="&7&b$n squints at $N but nothing happens.&0";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      imp_skill = TRUE;
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_STR;
      af[0].duration = 8;
      af[0].modifier = -15;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_STR;
      af[0].duration = 10;
      af[0].modifier = -20;
    } else if (skill >= 40 && skill < 70) {
      af[0].location = APPLY_STR;
      af[0].duration = 12;
      af[0].modifier = -20;
    } else if (skill >= 70 && skill < 85) {
      af[0].location = APPLY_STR;
      af[0].duration = 15;
      af[0].modifier = -20;
    } else if (skill >= 85) {
      af[0].location = APPLY_STR;
      af[0].duration = 20;
      af[0].modifier = -25; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_RAY_OF_ENFEEB with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d1934 4
a1941 1
    imp_skill = TRUE;
a1945 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 8;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_LEVITATE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d1947 1
a1950 1
    imp_skill = TRUE;
d1954 7
a1960 2
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      return;
a1961 16
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    if (mag_savingthrow(victim, savetype)) {
      to_vict = "You resist $n's withering effects!";	
      to_char = "$N resists your withering effect!";
      to_room = "$N resists $n's withering effect!";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
    } else {
d1963 4
a1966 25
      /* Determine spell elements based on skill at protection RSD 3/25/00 */
      
      if (skill > 0 && skill < 35) {	
	af[0].location = APPLY_STR;
	af[0].duration = 3;
	af[0].modifier = -5;		
      } else if (skill >= 35 && skill < 50) {
	af[0].location = APPLY_STR;
	af[0].duration = 5;
	af[0].modifier = -10;		
      } else if (skill >= 50 && skill < 85) {
	af[0].location = APPLY_STR;
	af[0].duration = 5;
	af[0].modifier = -12;	
      } else if (skill >= 85) {
	af[0].location = APPLY_STR;
	af[0].duration = 8;
	af[0].modifier = -15;		
      } else {
	sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_CHILL_TOUCH with 0 SKILL.", GET_NAME(ch));      
	log(buf);
	send_to_char(broken, ch);
	return;
      }
    }
a1969 1
    /* No improve skill, do it in mag_damage */
d1975 2
a1976 2
    if(check_armor_spells(ch, victim))
      return;
d1978 3
a1980 19
    /* Determine spell elements based on skill at protection RSD 3/22/00 */
    if (skill > 0 && skill < 35) {
      af[0].location = APPLY_AC;
      af[0].modifier = -10;
      af[0].duration = 10;
    } else if (skill >= 35 && skill < 81) {
      af[0].location = APPLY_AC;
      af[0].modifier = -12;
      af[0].duration = 12;
    } else if (skill >= 81) {
      af[0].location = APPLY_AC;
      af[0].modifier = -15;
      af[0].duration = 12;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_ARMOR with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
a1982 2

    imp_skill = TRUE;
d1986 6
a1991 10
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
a1992 1
    /* this spell needs to be changed so it's a room affect not a mobile/player affect */
a1993 4
    if (MOB_FLAGGED(victim,MOB_NOSILENCE)) {
      send_to_char("You seem unable to silence this one.\r\n", ch);
      return;
    }    
d1995 6
a2000 27
      to_char="$N resists your pitiful attempt to silence $M.";
      to_vict="&7&b$n tries to silence you but fails!&0";
      to_room="&7&b$n squints at $N but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      improve_skill(ch, spell_info[SPELL_SILENCE].sphere);
      return;
    }

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 4;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 5;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 7;
    } else if (skill >= 85) {
      af[0].duration= 8; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_SILENCE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }    
d2002 2
a2003 1
    to_char="You silence $N!";    
a2005 1
    imp_skill = TRUE;
a2009 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 4;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 8;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 10;
    } else if (skill >= 85) {
      af[0].duration= 12; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_SOULSHIELD with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    } 
d2011 1
d2023 3
a2025 5
      to_vict = "A brief aura surrounds you, then fades.";
      to_room = "A brief aura surrounds $N, then fades.";
      act(to_vict, FALSE, ch, 0, victim, TO_CHAR);
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      return;
a2026 1
    imp_skill = TRUE;
d2031 2
a2032 30
    /* self only spell */
    if(IS_AFFECTED3(victim, AFF3_ENLARGE)) {
      to_char="That won't work, you were already enlarged.";
      to_room = "&1&b$n looks slightly confused about $s place in the world.&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      return;
    }
    if(IS_NPC(victim))
      return;

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 40) {
      af[0].duration = 1;
      af[1].duration = 1;
      af[2].duration = 1;
    } else if (skill >= 40 && skill < 85) {
      af[0].duration = 2;
      af[1].duration = 2;
      af[2].duration = 2;
    } else if (skill >= 85) {
      af[0].duration = 3;
      af[1].duration = 3;
      af[2].duration = 3;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_REDUCE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    } 
d2037 1
d2041 1
d2045 1
a2049 1
    imp_skill = TRUE;
d2054 3
a2056 29
    if(IS_AFFECTED3(victim, AFF3_REDUCE)) {
      to_char="That won't work, you were already reduced.";
      to_room = "&1&b$n looks slightly confused about $s place in the world.&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      return;
    }
    if(IS_NPC(victim))
      return;

    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 40) {
      af[0].duration = 1;
      af[1].duration = 1;
      af[2].duration = 1;
    } else if (skill >= 40 && skill < 85) {
      af[0].duration = 2;
      af[1].duration = 2;
      af[2].duration = 2;
    } else if (skill >= 85) {
      af[0].duration = 3;
      af[1].duration = 3;
      af[2].duration = 3;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_ENLARGE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    } 
d2060 2
a2061 1
   
d2064 1
d2068 2
a2069 1
 
a2072 1
    imp_skill = TRUE;
a2074 1

d2083 1
a2083 1
    af[0].modifier = 7 + (GET_LEVEL(ch) >> 4);
a2090 1
    imp_skill = TRUE;
a2094 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 3;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 4;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 5;
    } else if (skill >= 85) {
      af[0].duration= 6; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_HASTE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2096 1
a2099 1
    imp_skill = TRUE;
a2103 13
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 40) {
      af[0].duration= 2;
    } else if (skill >= 40 && skill < 85) {
      af[0].duration= 4;
    } else if (skill >= 85) {
      af[0].duration= 6; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_BLUR with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2105 1
a2107 1
    imp_skill = TRUE;
a2111 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_COMPREHEND_LANG with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2113 2
a2114 1
    to_room="&7&b$N&7&b glows briefly.&0";
a2115 1
    imp_skill = TRUE;
d2121 7
a2127 11
         affected_by_spell(victim, SPELL_DEMONSKIN) ||
         affected_by_spell(victim, SPELL_DEMONIC_ASPECT) ||
         affected_by_spell(victim, SPELL_DEMONIC_MUTATION) ||
         affected_by_spell(victim, SPELL_WINGS_OF_HELL)
          ) {
      to_char = "$N is already blessed by some dark gods.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      to_room = "$n looks a little overprotective.";
      act(to_room, TRUE, ch, 0, 0, TO_ROOM);
      /* No improve skill check */
      return;
d2130 6
a2135 35
    /* Determine spell elements based on skill at protection RSD 3/22/00 */
    if (skill > 0 && skill < 35) {
      af[0].location = APPLY_HITROLL;
      af[0].modifier = 1;
      af[0].duration = 5;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -1;
      af[1].duration = 5;
    } else if (skill >= 35 && skill < 50) {
      af[0].location = APPLY_HITROLL;
      af[0].modifier = 1;
      af[0].duration = 8;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -1;
      af[1].duration = 8;
    } else if (skill >= 50 && skill < 81) {
      af[0].location = APPLY_HITROLL;
      af[0].modifier = 2;
      af[0].duration = 8;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -2;
      af[1].duration = 8;
    } else if (skill >= 81) {
      af[0].location = APPLY_HITROLL;
      af[0].modifier = 2;
      af[0].duration = 12;
      af[1].location = APPLY_SAVING_SPELL;
      af[1].modifier = -2;
      af[1].duration = 12;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_BLESS with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }    
a2138 1
    imp_skill = TRUE;
d2142 6
a2147 21
    /* Don't blind them if they're already dead! */
    /* Sometimes sunray kills the mob and then blinds them. */
    if (GET_POS(victim) == POS_DEAD)
      return;

    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* This needs to be made into a clerical area affect spell */

    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {
      to_char = "You seem unable to blind this creature.";
      return;
d2150 4
a2153 7
      to_char="$N resists your pitiful attempt to blind $M.";
      to_vict="&7&b$n tries to blind you but fails!&0";
      to_room="&7&b$n directs the rays of the sun at $N but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
a2155 2
    /* No skills proficiency check, if you get it off you get it off */

a2168 1
    /* no skill improvement, we'll do that in mag_damage */
d2173 3
a2175 3
    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {
      to_char = "You seem unable to blind this creature.";
      return;
d2178 3
a2180 11
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
d2182 4
a2185 8
      to_char="$N resists your pitiful attempt to blind $M.";
      to_vict="&7&b$n tries to blind you but fails!&0";
      to_room="&7&b$n tries to blind $N but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      improve_skill(ch, spell_info[SPELL_BLINDNESS].sphere);
      return;
a2187 2
    /* No skills proficiency check, if you get it off you get it off */
    
a2200 1
    imp_skill = TRUE;
d2205 3
d2210 3
a2212 17
      to_vict="&7&b$n tries to curse you but fails!&0";
      to_room="&7&b$n squints at $N but nothing happens.&0";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      improve_skill(ch, spell_info[SPELL_CURSE].sphere);
      return;
    }
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
d2215 7
a2221 77
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_HITROLL;
      af[0].duration = 5;
      af[0].modifier = -1;
      af[0].bitvector = AFF_CURSE;
      
      af[1].location = APPLY_DAMROLL;
      af[1].duration = 5;
      af[1].modifier = -1;
      af[1].bitvector = AFF_CURSE;

      af[2].location = APPLY_SAVING_SPELL;
      af[2].modifier = -1;
      af[2].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].location = APPLY_HITROLL;
      af[0].duration = 7;
      af[0].modifier = -2;
      af[0].bitvector = AFF_CURSE;
      
      af[1].location = APPLY_DAMROLL;
      af[1].duration = 7;
      af[1].modifier = -2;
      af[1].bitvector = AFF_CURSE;

      af[2].location = APPLY_SAVING_SPELL;
      af[2].modifier = -2;
      af[2].duration = 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].location = APPLY_HITROLL;
      af[0].duration = 9;
      af[0].modifier = -2;
      af[0].bitvector = AFF_CURSE;
      
      af[1].location = APPLY_DAMROLL;
      af[1].duration = 9;
      af[1].modifier = -2;
      af[1].bitvector = AFF_CURSE;

      af[2].location = APPLY_SAVING_SPELL;
      af[2].modifier = -2;
      af[2].duration = 9;
    } else if (skill >= 70 && skill < 85) {
      af[0].location = APPLY_HITROLL;
      af[0].duration = 10;
      af[0].modifier = -3;
      af[0].bitvector = AFF_CURSE;
      
      af[1].location = APPLY_DAMROLL;
      af[1].duration = 10;
      af[1].modifier = -3;
      af[1].bitvector = AFF_CURSE;

      af[2].location = APPLY_SAVING_SPELL;
      af[2].modifier = -3;
      af[2].duration = 10;
    } else if (skill >= 85) {
      af[0].location = APPLY_HITROLL;
      af[0].duration = 12;
      af[0].modifier = -3;
      af[0].bitvector = AFF_CURSE;
      
      af[1].location = APPLY_DAMROLL;
      af[1].duration = 12;
      af[1].modifier = -3;
      af[1].bitvector = AFF_CURSE;

      af[2].location = APPLY_SAVING_SPELL;
      af[2].modifier = -3;
      af[2].duration = 12;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_CURSE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
a2225 1
    imp_skill = TRUE;
a2229 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DETECT_ALIGN with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2231 1
d2233 1
a2233 1
    to_room="&7&b$N&7&b glows briefly.&0";
a2234 1
    imp_skill = TRUE;
a2238 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DETECT_INVIS with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2240 1
a2241 1
    imp_skill = TRUE;
a2245 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DETECT_MAGIC with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2247 1
a2248 1
    imp_skill = TRUE;
d2253 4
a2256 6
    if ((affected_by_spell(victim, SPELL_NIGHT_VISION))) {
      if (victim) {
	to_char = "You are already enchanted with enhanced vision.";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	to_room = "$n looks a little overprotective.";
	act(to_room, TRUE, ch, 0, victim, TO_ROOM);
d2258 3
a2260 6
	to_char = "$N seems to be able to sort of see enough already.";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	to_vict = "You are already enchanted with enhanced vision.";
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	to_room = "$n looks a little overprotective.";
	act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d2262 1
a2262 2
      /* No improve skill check */
      return;
a2264 17
    /* Determine spell elements based on proficiency RSD 3/25/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 9;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 12;
    } else if (skill >= 85) {
      af[0].duration = 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_INFRAVISION with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2266 1
a2269 1
    imp_skill = TRUE;
a2272 21
    if (!victim) {
      victim = ch;
    }

    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 9;
   } else if (skill >= 20 && skill < 40) {
      af[0].duration = 11;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 13;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 15;
    } else if (skill >= 85) {
      af[0].duration = 20; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_INVISIBLE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2274 1
a2278 1
    imp_skill = TRUE;
a2282 20
    if (!victim) {
      victim = ch;
    }
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 9;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 11;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 13;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 15;
    } else if (skill >= 85) {
      af[0].duration = 20; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_CONCEALMENT with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2284 1
a2288 1
    imp_skill = TRUE;
d2292 2
a2293 11
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
d2295 2
a2296 4
      to_vict = "You dodge $n's attempt to prick you!";
      to_room = "$N dodges $n's attempt to prick $M.";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d2298 1
a2298 24
      improve_skill(ch, spell_info[SPELL_POISON].sphere);
      return;
    }
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 4;
      af[0].modifier = -2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 8;
      af[0].modifier = -4;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 16;
      af[0].modifier = -8;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 24;
      af[0].modifier = -16;
    } else if (skill >= 85) {
      af[0].duration = 36;
      af[0].modifier = -32;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_POISON with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d2301 1
d2303 1
a2305 1
    imp_skill = TRUE;
d2310 6
a2315 27
    /* Alignement Check! */
    if (GET_ALIGNMENT(victim) <= 350) {
      to_char="You can't protect an ally if they are EVIL!";
      to_vict="$n tries to protect you from evil!\r\nSilly isn't $e.";
      to_room="$n fails to protect $N from evil. DUH";  
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
    }
    
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 9;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 11;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 13;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 15;
    } else if (skill >= 85) {
      af[0].duration = 20; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_PROT_FROM_EVIL with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d2317 1
d2319 1
a2321 1
    imp_skill = TRUE;
d2332 2
a2333 2
    to_vict = "This spell doesn't exist. Ask no questions.";
    to_room = "Absolutly nothing happen to $n.";
d2337 8
a2344 8
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_PEACEFUL)) {
      send_to_char("A flash of white light fills the room, dispelling your "
                   "violent magic!\r\n", ch);
      act("White light from no particular source suddenly fills the room, "
          "then vanishes.", FALSE, ch, 0, 0, TO_ROOM);
      return;
    }
    if (!sleep_allowed && !IS_NPC(ch) && !IS_NPC(victim) && (ch != victim)) {
d2346 1
a2346 8
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) < 100 &&
        !IS_NPC(ch) && !sleep_allowed) {
      send_to_char("Use the 'nap' command instead!\r\n",ch);
      return;
d2348 1
d2353 2
a2354 4
      to_vict = "$n can sing all $e wants, you aren't going to sleep.";
      to_room = "$n tries to sing $N to sleep, but to no avail, uh oh.";
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d2356 1
a2356 2
      improve_skill(ch, spell_info[SPELL_SLEEP].sphere);
      if(!FIGHTING(victim)) {
d2361 1
a2361 1
      return;
a2363 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 9;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 11;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 13;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 15;
    } else if (skill >= 85) {
      af[0].duration = 20; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_SLEEP with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2365 1
a2372 1
    imp_skill = TRUE;
a2380 22
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration = 5;
      af[0].modifier = 2;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration = 7;
      af[0].modifier = 6;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration = 9;
      af[0].modifier = 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration = 10;
      af[0].modifier = 12;
    } else if (skill >= 85) {
      af[0].duration = 12;
      af[0].modifier = 14;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_STRENGTH with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2382 2
a2383 1
    /*    accum_affect = TRUE; */
a2385 1
    imp_skill = TRUE;
d2391 1
a2391 1
    af[0].modifier = 1 + (level > 18);
a2398 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_SENSE_LIFE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2400 1
a2402 1
    imp_skill = TRUE;
a2406 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 12;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 14;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 17;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 20;
    } else if (skill >= 85) {
      af[0].duration= 24; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_WATERWALK with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2408 1
a2410 1
    imp_skill = TRUE;
a2414 17
    /* Determine spell elements based on proficiency RSD 3/26/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 8;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_FLY with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2416 1
a2417 1
    GET_POS(victim) = POS_FLYING;
d2420 1
a2420 1
    imp_skill = TRUE;
a2424 17
    /* Determine spell elements based on proficiency RSD 3/27/00 */
    if (skill > 0 && skill < 20) {
      af[0].duration= 5;
    } else if (skill >= 20 && skill < 40) {
      af[0].duration= 7;
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 10;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 12;
    } else if (skill >= 85) {
      af[0].duration= 15; 
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_FARSEE with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2426 1
a2428 1
    imp_skill = TRUE;
a2430 52
    /*  case SPELL_UNHOLY_WORD: */
  case SPELL_HOLY_WORD:
    sprintf(buf,"HOLY/UNHOLY AFFECT PART");
    log(buf);
    if (mag_savingthrow(victim, savetype)) {
      to_vict = "You resist most of $n's word of power.";	
      to_char = "$N resists your word of power's side affects.";
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      /* no skill improve for save on this part */
      return;
    } else {                      /* holy and unholy should be same sphere */

      /* Determine spell elements based on skill at protection RSD 4/2/00 */      
      num_roll = number(1,100);
      skill_diff = ((GET_WIS(victim)-20) + (GET_LEVEL(victim) - skill));      
      if (num_roll <= skill_diff) {
	to_vict = "You resist most of $n's word of power.";	
	to_char = "$N resists your word of power's side affects.";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	/* no skill improve for save on this part */	
	return;
	/* If they fail the hell outta the roll then they are paralyzed! */
      } else if ((num_roll - skill_diff) > (40 + GET_SAVE(victim, SAVING_PARA))) { /* Let their paralysis saves help/hurt them */
	/* minor paralysis and blindness */
	af[0].location = APPLY_HITROLL;
	af[0].modifier = -4;
	af[0].duration = 2;
	af[0].bitvector = AFF_BLIND;
	af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
	af[1].location = APPLY_AC;
	af[1].modifier = 40;
	af[1].duration = 2;
	af[1].bitvector = AFF_BLIND;
	to_char = "&9&b$N&9&b is blinded and paralyzed by you!&0";
	to_room = "&9&b$N&9&b is blinded by $n!&0\r\n&9&b$N&9&b is stopped in $S tracks by $n!&0";
	to_vict = "&9You have been blinded and paralyzed by $n's mighty word of power!&0";
      } else { /* Just Blindness */
	af[0].location = APPLY_HITROLL;
	af[0].modifier = -4;
	af[0].duration = 2;
	af[0].bitvector = AFF_BLIND;
	af[1].location = APPLY_AC;
	af[1].modifier = 40;
	af[1].duration = 2;
	af[1].bitvector = AFF_BLIND;
	to_char = "&9&b$N&9&b is blinded by you!&0";
	to_room = "&9&b$N&9&b is blinded by $n!&0";
	to_vict = "&9You have been blinded by $n's mighty word of power!&0";
      }
    }
d2433 2
a2434 2
    if(check_armor_spells(ch, victim))
      return;
d2436 3
a2438 27
    /* Determine spell elements based on proficiency RSD 3/25/00 */
    if (skill > 0 && skill < 20) {
      af[0].location = APPLY_AC;
      af[0].modifier = -10;
      af[0].duration = 8;
    } else if (skill >= 20 && skill < 35) {
      af[0].location = APPLY_AC;
      af[0].modifier = -12;
      af[0].duration = 10;
    } else if (skill >= 35 && skill < 50) {
      af[0].location = APPLY_AC;
      af[0].modifier = -15;
      af[0].duration = 15;
    } else if (skill >= 50 && skill < 85) {
      af[0].location = APPLY_AC;
      af[0].modifier = -20;
      af[0].duration = 20;
    } else if (skill >= 85) {
      af[0].location = APPLY_AC;
      af[0].modifier = -25;
      af[0].duration = 48;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_BONE_ARMOR with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
d2442 1
a2442 1
    imp_skill = TRUE;
a2443 2
    /* Improve skill in area section */
    break;
d2445 3
a2447 11
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0) && (ch != victim)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
    /* Check shapechanged */
    if (victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) <100 &&
        !IS_NPC(ch) && (pk_allowed == 0)) {
      send_to_char("Pkill isn't allowed!\r\n",ch);
      return;
    }
d2454 1
a2454 2
      improve_skill(ch, spell_info[spellnum].sphere);
      return;
d2462 1
a2462 2
      improve_skill(ch, spell_info[spellnum].sphere);
      return;
d2470 3
a2472 4
    to_char="&5You shout a powerful rebuke at $N, forcing $M to cower in fear!&0";
    to_vict="&5You catch a glimpse of $n's true power and cower in fear!&0";
    to_room="&5$N cowers in fear as $n rebukes $M.&0";
    imp_skill = TRUE;
d2486 1
a2486 1
          return;
a2496 1
    imp_skill = TRUE;
a2503 4
  if( ch->casting.spell == spellnum && imp_skill ) {
    improve_skill(ch, spell_info[spellnum].sphere);   
  }

d2513 1
a2513 1
     return;
d2522 1
a2522 1
     return;
d2532 1
a2532 1
     return;
a2551 2
   if (spellnum == SPELL_REMOVE_POISON)
     check_regen_rates(victim);	/* speed up regen rate immediately */
d2565 1
d2574 1
a2574 1
void perform_mag_groups(int level, struct char_data * ch,
d2579 2
a2580 2
    mag_points(level, ch, tch, SPELL_HEAL, savetype);
    mag_unaffects(level, ch, tch, SPELL_HEAL, savetype);
d2583 1
a2583 1
    mag_affects(level, ch, tch, SPELL_ARMOR, savetype);
d2586 5
a2590 1
    spell_recall(level, ch, tch, NULL, savetype);
d2608 1
a2608 1
void mag_groups(int level, struct char_data * ch, int spellnum, int savetype)
d2614 1
a2614 1
    return;
d2616 23
a2638 34
  if (!IS_AFFECTED(ch, AFF_GROUP))
    return;
  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;
      if (tch->in_room != ch->in_room)
	continue;
      if (ch == tch)
	continue;    
      
      if (is_grouped(ch, tch))
	perform_mag_groups(level, ch, tch, spellnum, savetype);
    }
  /*           if (ch->master != NULL)
	       k = ch->master;
	       else
	       k = ch;
	       for (f = k->followers; f; f = f_next) {
	       f_next = f->next;
	       tch = f->follower;
	       if (tch->in_room != ch->in_room)
	       continue;
	        / *  if (!IS_AFFECTED(tch, AFF_GROUP)) * /
	       continue;
	       if (ch == tch)
	       continue;
	       if (is_grouped(ch, tch))   
	       perform_mag_groups(level, ch, tch, spellnum, savetype);
	       }
	       
	       if ((k != ch) && IS_AFFECTED(k, AFF_GROUP))
	       perform_mag_groups(level, ch, k, spellnum, savetype);       */
  perform_mag_groups(level, ch, ch, spellnum, savetype);
d2648 1
a2648 1
void mag_masses(int level, struct char_data * ch, int spellnum, int savetype)
d2672 1
a2672 1
void mag_areas(int level, struct char_data * ch, int spellnum, int savetype)
a2678 1
  int dam = 0;
d2681 2
a2682 1
    return;  
d2689 17
a2705 18
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS) || (world[ch->in_room].sector_type == SECT_INSIDE)) {
      to_char = "What?! Are you crazy casting that INSIDE?!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "The ground shakes violently!\r\n$n barely changes $s mind in time to not kill you all.";
      act(to_room, TRUE, ch, 0, 0, TO_ROOM);     
      dam = 0;      
      return;
    }
    if ((world[ch->in_room].sector_type == SECT_WATER_SWIM) || (world[ch->in_room].sector_type == SECT_WATER_NOSWIM) \
	|| (world[ch->in_room].sector_type == SECT_UNDERWATER) || (world[ch->in_room].sector_type == SECT_FLYING) \
	|| (world[ch->in_room].sector_type == SECT_OCEAN) || (world[ch->in_room].sector_type == SECT_ASTRALPLANE) \
	|| (world[ch->in_room].sector_type == SECT_AIRPLANE) || (world[ch->in_room].sector_type == SECT_AVERNUS)) { 
      to_char = "Quake the earth? What earth? There's no ground here anywhere.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n hunches over and grunts loudly!";
      act(to_room, TRUE, ch, 0, 0, TO_ROOM);     
      dam = 0;
      return;
d2709 1
a2709 4
    send_to_zone(
          "&3The ground &1rumbles&3 and shakes!&0\r\n", IN_ZONE(ch), IN_ROOM(ch),
            POS_SLEEPING);
    improve_skill(ch, spell_info[SPELL_EARTHQUAKE].sphere);
a2713 1
    improve_skill(ch, spell_info[SPELL_FREEZING_WIND].sphere);
a2717 1
    improve_skill(ch, spell_info[SPELL_UNHOLY_WORD].sphere);
a2721 1
    improve_skill(ch, spell_info[SPELL_HOLY_WORD].sphere);
a2725 1
    improve_skill(ch, spell_info[SPELL_METEORSWARM].sphere);
a2729 1
    improve_skill(ch, spell_info[SPELL_ICE_SHARDS].sphere);
a2733 1
    improve_skill(ch, spell_info[SPELL_SUPERNOVA].sphere);
a2737 1
    improve_skill(ch, spell_info[SPELL_ICE_STORM].sphere);
a2741 1
    improve_skill(ch, spell_info[SPELL_INCENDIARY_NEBULA].sphere);
a2745 1
    improve_skill(ch, spell_info[SPELL_CHAIN_LIGHTNING].sphere);
a2749 1
    improve_skill(ch, spell_info[SPELL_HELLFIRE_BRIMSTONE].sphere);
a2753 1
    improve_skill(ch, spell_info[SPELL_FIRESTORM].sphere);
a2757 1
    improve_skill(ch, spell_info[SPELL_CREMATE].sphere);
d2770 3
a2772 2
    return;
  }   
d2774 2
a2775 2
    for(i=0;i<NUM_CLASSES;i++) 
      if(spell_info[spellnum].min_circle[i] < 10)
d2779 3
a2781 4
  for (tch = world[ch->in_room].people; tch; tch = next_tch) 
    {
      next_tch = tch->next_in_room;
      group = 0;
d2783 2
d2786 20
a2805 36
      if (is_grouped(ch, tch))
	continue;
      
      
      
      /*
       * The skips: 1: the caster
       *            2: immortals
       *            3: if no pk on this mud, skips over all players
       *            4: pets (charmed NPCs)
       */ 
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      if (!roomaffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
	continue;
      /* mobs done area other mobs unless pets Banyal */
      if (IS_NPC(ch) && IS_NPC(tch) && !MOB_FLAGGED (ch, MOB_PET) &&
	  !MOB_FLAGGED (tch, MOB_PET))
	continue;
      if (spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(tch) < 500)
	continue;
      if (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(tch) > -500)
	continue;
      if( spellnum!=SPELL_DISPEL_MAGIC && 
	  ((IS_AFFECTED2(tch, AFF2_MINOR_GLOBE) && min_spell_level <= 3) ||
	   (IS_AFFECTED2(tch, AFF2_MAJOR_GLOBE) && min_spell_level <= 6))){
	act("&1&bThe shimmering globe around your body flares as the spell flows around it.&0", FALSE, ch,0,tch,TO_VICT);
	act("&1&bThe shimmering globe around $N&1&b's body flares as your spell flows around it.&0", FALSE,ch,0,tch,TO_CHAR);
	act("&1&bThe shimmering globe around $N&1&b's body flares as $n&1&b's spell flows around it.&0",FALSE,ch,0,tch,TO_NOTVICT);
	continue;
      }
      
      
      mag_damage(GET_LEVEL(ch), ch, tch, spellnum, 1);
d2807 4
d3112 1
a3112 1
void mag_summons(int level, struct char_data *ch, struct obj_data *obj,
d3124 1
a3124 1
    return;
d3126 1
a3126 1
  if (IS_AFFECTED(ch, AFF_CHARM) && !MOB_FLAGGED(ch, MOB_ANIMATED)) {
d3128 1
a3128 1
    return;
d3136 1
a3136 1
      return;
d3145 1
a3145 1
	return;
d3152 1
a3152 1
      return;
a3161 1
    improve_skill(ch, spell_info[spellnum].sphere);
d3172 1
a3172 1
      return;
d3244 3
a3246 2
    return;
  };
d3249 1
a3249 1
void mag_points(int level, struct char_data * ch, struct char_data * victim, int spellnum, int savetype) {
d3254 1
a3254 4
  int skill = 0;
  float heal_mult = 0;

  extern void improve_skill(struct char_data *ch, int skill);
d3257 1
a3257 18
    return;

  /* Copied this snippit from above the switch in mag_affects in the hopes of making
     items that call upon spells from mag_points use the items level and not a skill
     level of a player - RSD 10/1/2000 */ 
  /* Gurlaek 9/28/2000 */
  if( ch->casting.spell != spellnum ) {
    /* the spell is actually being called from an item so that item's */
    /* level will be used instead of the skill of the caster          */
    skill = level;
  } else {
    /* the spell is being cast so the skill will be that of the */
    /* caster's appropriate sphere for that spell               */
    skill = GET_SKILL(ch, spell_info[spellnum].sphere);    
  }

  /* Healing spells now use the associated skill for healing damage --gurlaek 12/7/1999 
     skill = GET_SKILL(ch, SKILL_SPHERE_HEALING); */
d3259 1
a3259 15
  /* get the proper multiplier */
  if(skill > 0 && skill <= 20) {
    heal_mult = 2;
  } else if(skill >= 21 && skill <= 40) {
    heal_mult = 3;
  } else if(skill >= 41 && skill <= 80) {
    heal_mult = 4;
  } else if(skill >= 81 && skill <= 95) {
    heal_mult = 5;
  } else if(skill >= 96) {
    heal_mult = 6;
  } else {
    log("SYSERR:magic.c:mag_points(): attempt to cast spell with 0 SKILL");
    return;
  }
a3261 1

d3263 1
a3263 1
    hit = (float)(dice(2, 8) + 1) * heal_mult;
d3267 1
a3267 1
    hit = (float)(dice(6, 8) + 3) * heal_mult;
d3271 1
a3271 1
    hit = (float)(dice(4, 8) + 2) * heal_mult;
d3275 1
a3275 1
    hit = ((float)dice(50, 2) * heal_mult) + 20;
d3279 1
a3279 1
    hit = ((float) dice(100, 2) * heal_mult) + 175;
d3283 1
a3283 1
    move = (float)(dice(3, 8) + 5) * heal_mult;
d3287 1
a3287 1
    move = (float)(dice(5, 8) + 5) * heal_mult;
d3291 1
a3291 1
    move = (float)(dice(7, 8) + 5) * heal_mult;
d3339 1
a3339 6
    return;
  }

  /* improve skill for casting spells only not using potions etc.. */
  if( ch->casting.spell == spellnum) {
    improve_skill(ch, spell_info[spellnum].sphere);
d3343 5
a3347 5
  if(hit)
    alter_hit(victim, -hit, 1);
  if(move)
    alter_move(victim, -move);
  if(hunger)
d3349 1
a3349 1
  if(thirst)
d3351 2
d3356 1
a3356 1
void mag_unaffects(int level, struct char_data * ch, struct char_data * victim,
d3363 1
a3363 1
    return;
d3369 1
a3369 1
    return;
d3372 1
a3372 1
    to_vict="Your mind comes back to reality.";
d3375 2
a3376 2
    if(!IS_AFFECTED3(victim, AFF3_REDUCE))
      return;
d3378 1
a3378 1
    to_vict ="&8You return to your normal size.&0";
d3381 2
a3382 2
    if(!IS_AFFECTED3(victim, AFF3_ENLARGE))
      return;
d3384 1
a3384 1
    to_vict ="&8You return to your normal size.&0";
d3389 1
a3389 1
    if (IS_AFFECTED(victim, AFF_BLIND)) {
a3414 1
    improve_skill(ch, spell_info[SPELL_REMOVE_POISON].sphere);
a3418 1
    improve_skill(ch, spell_info[SPELL_REMOVE_CURSE].sphere);
d3423 1
a3423 2
    return;
    break;
d3428 1
a3428 1
    return;
d3436 5
a3440 1
  
d3444 1
a3444 1
void mag_alter_objs(int level, struct char_data * ch, struct obj_data * obj,
d3451 1
a3451 1
    return;
a3459 1
    improve_skill(ch, spell_info[SPELL_BLESS].sphere);
a3467 1
    improve_skill(ch, spell_info[SPELL_CURSE].sphere);
a3473 1
    improve_skill(ch, spell_info[SPELL_INVISIBLE].sphere);
a3481 1
    improve_skill(ch, spell_info[SPELL_POISON].sphere);    
d3483 1
a3483 1
    case SPELL_REMOVE_CURSE:
d3485 1
a3485 1
    REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
a3489 1
    improve_skill(ch, spell_info[SPELL_REMOVE_CURSE].sphere);
a3497 1
    improve_skill(ch, spell_info[SPELL_REMOVE_POISON].sphere);
d3511 1
d3517 1
a3517 1
void mag_creations(int level, struct char_data * ch, int spellnum)
d3524 1
a3524 2
    return;
  level = MAX(MIN(level, LVL_IMPL), 1);
d3529 2
a3530 3
    to_room="&4A fresh clear spring of water bursts through the ground here.&0";
    to_char="&4A fresh clear spring of water bursts through the ground here.&0";
    improve_skill(ch, spell_info[SPELL_CREATE_SPRING].sphere);
d3546 1
a3546 1
    zplus = GET_SKILL(ch, spell_info[spellnum].sphere) / 16 +
d3562 3
a3564 4
    give_char=1;
    to_room="$n creates $p.";
    to_char="You create $p.";
    improve_skill(ch, spell_info[SPELL_CREATE_FOOD].sphere);
d3568 1
a3568 2
    return;
    break;
d3576 1
a3576 1
    return;
d3578 1
a3578 1
  if(give_char)
d3582 1
a3582 1
  if(to_room)
d3584 1
a3584 1
  if(to_char)
d3586 2
d3590 1
a3590 1
void mag_room(int level, struct char_data * ch, int spellnum)
d3603 1
a3603 2
    return;
  level = MAX(MIN(level, LVL_IMPL), 1);
a3610 1
    improve_skill(ch, spell_info[SPELL_WALL_OF_FOG].sphere);
d3615 1
a3615 1
      return;
d3617 1
a3617 1
    if(!OUTSIDE(ch) || SECT(ch->in_room) == SECT_INSIDE) {
d3619 1
a3619 1
      return;
d3623 2
a3624 3
    to_char="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
    to_room="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
    improve_skill(ch, spell_info[SPELL_URBAN_RENEWAL].sphere);
d3627 3
a3629 3
    if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE)) {
      send_to_char("The room is already on fire.\r\n",ch);
      return;
d3635 2
a3636 2
      send_to_char("Impossible. There is too much water here.\r\n",ch);
      return;
d3644 2
a3645 1
    /* add more room spellscontinual here */
d3651 1
a3651 1
    break;
d3676 2
d3831 3
@


1.99
log
@Minor typo fixes
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.98 2007/07/15 17:16:12 jps Exp jps $
d4667 3
d5858 3
@


1.98
log
@Add IS_POISONED macro.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.97 2007/07/04 02:21:58 myc Exp jps $
d2140 1
a2140 1
      to_room = "$n looks a little over protective.";
d2179 1
a2179 1
      to_room = "$n looks a little over protective.";
d3547 1
a3547 1
      to_room = "$n looks a little over protective.";
d3879 1
a3879 1
	to_room = "$n looks a little over protective.";
d3886 1
a3886 1
	to_room = "$n looks a little over protective.";
d5841 1
a5841 1
      act("$n looks a little over protective.", TRUE, ch, 0, 0, TO_ROOM);
d5846 1
a5846 1
      act("$n looks a little over protective.", TRUE, ch, 0, victim, TO_NOTVICT);
d5855 3
@


1.97
log
@Removing coldshield affect from ice armor spell.  Increased duration on
magic torch and circle of light.  Renamed douse spell to extinguish.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.96 2007/06/24 22:45:31 myc Exp myc $
d5498 2
a5499 2
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && !GET_OBJ_VAL(obj, 3)) {
      GET_OBJ_VAL(obj, 3) = 1;
d5516 2
a5517 2
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && GET_OBJ_VAL(obj, 3)) {
      GET_OBJ_VAL(obj, 3) = 0;
d5855 4
@


1.96
log
@Making chill touch improve skill always instead of sometimes.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.95 2007/06/16 00:15:49 myc Exp myc $
d577 1
a577 1
        if ((af->type > 600) && (af->type <= MAX_SKILLS))
d1578 1
a1578 1
    dam = (int)(3*dam/4);
a1680 13
    /* check for fireshield */
    if(AFF2_FLAGGED(ch, AFF2_FIRESHIELD)) {
      send_to_char("The shield of fire negates your spell.\r\n", ch);
      return;
    }
    if(AFF2_FLAGGED(ch, AFF2_COLDSHIELD)) {
      send_to_char("You seem to be protected enough already!\r\n", ch);
      to_room = "$n looks a little over protective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
      return;
    }

a1706 1
    af[0].bitvector2 = AFF2_COLDSHIELD;
d2741 1
a2741 1
      af[0].duration= 5;
d2743 1
a2743 1
      af[0].duration= 7;
d2745 1
a2745 1
      af[0].duration= 9;
d2747 1
a2747 1
      af[0].duration= 12;
d2749 1
a2749 1
      af[0].duration= 15; 
d2767 1
a2767 1
      af[0].duration= 5;
d2769 1
a2769 1
      af[0].duration= 7;
d2771 1
a2771 1
      af[0].duration= 9;
d2773 1
a2773 1
      af[0].duration= 12;
d2775 1
a2775 1
      af[0].duration= 15; 
a2959 11
    /* check for ice armor, which also gives coldshield affect */
    if (affected_by_spell(victim, SPELL_ICE_ARMOR)) {
      to_char = "You seem to be protected enough already!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n looks a little over protective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
      return;
    }


d5384 1
a5384 1
  case SPELL_DOUSE:
d5855 3
@


1.95
log
@Three spells for necromancers: soul tap, rebuke undead,
and degeneration.  One spell for rangers: natures guidance.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.94 2007/05/24 06:06:16 jps Exp myc $
d853 1
a853 1
    /* No improve skill call, it's done in mag_affects() for this spell RSD 3/30/00 */
a3215 1
      improve_skill(ch, spell_info[SPELL_CHILL_TOUCH].sphere);      
d3247 1
a3247 1
    imp_skill = TRUE;
d5880 4
@


1.94
log
@Stop sending 'Nothing seems to happen.' when full heal is cast.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.93 2007/05/12 21:59:07 myc Exp jps $
d1549 13
a1561 1
    
d4403 70
a4472 1
    
d4538 1
a4538 1
         /* Just silenly stop the casting for paralysis */
d5416 1
a5416 4
    if(IS_AFFECTED2(victim, AFF2_INSANITY)) {
      to_vict="Your mind comes back to reality.";
    }
    improve_skill(ch, spell_info[SPELL_SANE_MIND].sphere);
d5422 1
a5422 3
    if(IS_AFFECTED3(victim, AFF3_REDUCE)) {
      to_vict ="&8You return to your normal size.&0";
    }
d5428 1
a5428 3
    if(IS_AFFECTED3(victim, AFF3_ENLARGE)) {
      to_vict ="&8You return to your normal size.&0";
    }
d5881 3
@


1.93
log
@Fixed the bug where random constants were sent_to_char when skill
affections wore off.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.92 2007/05/12 20:02:03 myc Exp myc $
d5399 1
a5399 1
  if (!affected_by_spell(victim, spell) && spellnum != SPELL_HEAL) {
d5807 4
@


1.92
log
@Demonic aspect and mutation shouldn't stack.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.91 2007/05/11 21:03:12 myc Exp myc $
d576 2
a577 1
        if ((af->type > MAX_SPELLS) && (af->type <= MAX_SKILLS))
d5807 3
@


1.91
log
@New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
complicated skill.  :P  Fixed cure blind's logic, and made it support
eye gouge too.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.90 2007/05/11 20:13:28 myc Exp $
d2423 6
d5806 5
@


1.90
log
@Vaporform is a new circle 13 spell for cryomancers.  It significantly
increases the caster's chance of dodging a hit.  It is a quest spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.89 2007/04/26 03:57:09 myc Exp myc $
a5350 13
    if(!IS_AFFECTED(victim, AFF_BLIND))
      return;
    spell = SPELL_BLINDNESS;
    if (IS_AFFECTED(victim, AFF_BLIND)){
      affect_from_char(victim, SPELL_SUNRAY);
      to_vict = "Your vision returns!";
      to_room = "There's a momentary gleam in $n's eyes.";
    }
    if (affected_by_spell(victim, SPELL_DISEASE)) {
      affect_from_char(victim, SPELL_DISEASE);
      act("Your disease has been cured.",FALSE,0,0,victim,TO_VICT);
    }
    break;
d5352 1
a5352 5
    if(!IS_AFFECTED(victim, AFF_BLIND))
      return;
    spell = SPELL_BLINDNESS;
    if (IS_AFFECTED(victim, AFF_BLIND)){
      affect_from_char(victim, SPELL_SUNRAY);
d5355 12
d5368 2
a5369 1
    if (affected_by_spell(victim, SPELL_DISEASE)) {
d5371 1
a5371 1
      act("Your disease has been cured.",FALSE,0,0,victim,TO_VICT);
d5800 4
@


1.89
log
@Got rid of sunray's double skill improvement haxness.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.88 2007/04/25 07:18:05 jps Exp myc $
d1773 6
d1806 46
d5804 3
@


1.88
log
@Fix feedback for casting bless/dark presence on one who is already
oppositely blessed.  Make bless impossible if you have any of several
evil spells on you.  Make batwings/wings of heaven exclusive.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.87 2007/04/19 07:03:14 myc Exp jps $
a3578 1
      improve_skill(ch, spell_info[SPELL_SUNRAY].sphere);
d3597 1
a3597 1
    imp_skill = TRUE;
d5752 5
@


1.87
log
@Renamed RAY_OF_ENFEB as RAY_OF_ENFEEB.  Implemented demonic mutation
as a more powerful version of demonic aspect.  Made it so players
can cast offensive affection spells on themselves.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.86 2007/04/19 00:53:54 jps Exp myc $
d2127 1
a2127 1
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d2438 4
a2441 1
    /* Need check to make sure victim isn't already flying, unless this is done elsewhere */
d2518 4
a2521 1
    /* Need check to make sure victim isn't already flying, unless this is done elsewhere */
d3494 6
a3499 1
    if (affected_by_spell(victim, SPELL_DARK_PRESENCE)) {
d3501 1
a3501 1
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d5753 5
@


1.86
log
@Create macros for stopping spellcasting, and terminate spellcasting
when you become paralyzed.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.85 2007/04/17 23:58:43 jps Exp jps $
d1838 1
a1838 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d1953 1
a1953 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d2251 1
a2251 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d2335 1
a2335 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d2369 1
a2369 11

    /* Alignement Check! */
    if (GET_ALIGNMENT(victim) >= 350) {
      to_char="$N doesn't seem to have an inner demon.";
      to_vict="$n tries to inflict a demon upon you.\r\nSilly isn't $e.";
      to_room="$n fails to make $N more of a demon.";  
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      return;
    }
d2414 1
a2414 1
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DEMONIC_ASPECT with 0 SKILL.", GET_NAME(ch));      
d2419 4
d2424 9
a2432 2
    to_vict="&1Your body fills with a demonic strength.&0";
    to_room="&1$n's&1 body &bglows red&0&1 briefly and grows stronger.&0";
a2434 2
    
  case SPELL_DEMONIC_MUTATION:
a2435 7
    /* Yeap an incomplete spell */

    send_to_char("You cannot seem to grasp the nature of the demon.\r\nP.S. This spell isn't active so don't pray it.",ch);
    return;
    imp_skill = TRUE;
    break;
    
d2727 1
a2727 1
     if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d2971 1
a2971 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3029 1
a3029 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3040 1
a3040 1
    if(IS_AFFECTED3(victim, AFF3_RAY_OF_ENFEB)) {
d3088 1
a3088 1
    af[0].bitvector3 = AFF3_RAY_OF_ENFEB;
d3122 1
a3122 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3206 1
a3206 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3544 1
a3544 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3597 1
a3597 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3648 1
a3648 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d3923 1
a3923 1
    if (!IS_NPC(victim) && !IS_NPC(ch) && (pk_allowed == 0)) {
d4028 1
a4028 1
    if (!sleep_allowed && !IS_NPC(ch) && !IS_NPC(victim)) {
d4035 1
a4035 1
        !IS_NPC(ch) && (pk_allowed == 0)) {
d5742 4
@


1.85
log
@Stop sending extra message to caster when writhing weeds fails due to being cast outside.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.84 2007/04/17 23:38:03 myc Exp jps $
d450 7
d4388 3
a4390 8
   if (af[0].bitvector2 == AFF2_SILENCE) {
      /* stop victim spellcasting */

      if(PLR_FLAGGED(victim, PLR_CASTING) || MOB_FLAGGED(victim, MOB_CASTING)) {
         if (IS_NPC(victim))
            REMOVE_BIT(MOB_FLAGS(victim), MOB_CASTING);
         else
            REMOVE_BIT(PLR_FLAGS(victim), PLR_CASTING);
d4392 6
a4397 1
         act("$n continues silently moving $s lips for a moment before giving up.", FALSE, victim, 0, 0, TO_ROOM);
d5750 3
@


1.84
log
@Introducing the new improved color spray!  It's now an area spell that
causes various effects based on caster skill.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.83 2007/04/11 14:26:06 jps Exp myc $
d907 1
a907 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d5743 4
@


1.83
log
@Spell of nourishment will only work in certain terrains.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.82 2007/03/27 04:27:05 myc Exp jps $
d1122 1
a1122 1
    imp_skill = TRUE;
d1382 5
d5743 3
@


1.82
log
@Harness from 2% to 1% extra damage per level.  Forgot a check in ice armor
for coldshield last time.  Group heal has the same effects as heal (curing
blindness).  Permastoned mobs twitch faster.  Cure blind cures sunray.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.81 2007/02/20 17:16:27 myc Exp myc $
d5182 37
a5218 4
    hunger = 24;
    thirst = 24;
    act("&2&b$n&2&b sprouts roots that dig deep beneath the soil, drawing sustenence.&0",TRUE,victim,0,0,TO_ROOM);
    act("&2&bYou sprout roots that dig deep beneath the soil, drawing sustenence.&0",FALSE,victim,0,0,TO_CHAR);
d5738 5
@


1.81
log
@Consolidated armor spell checks into check_armor_spells() function, which
is called at the beginning of all armor spells.  Changed success rates for
entangle, minor paralysis, and sleep.  Cleaned up entangle spell a bit.
Sleep spell checks for shapeshifted players.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.80 2007/02/14 03:54:53 myc Exp myc $
d1559 1
a1559 1
  /* if HARNESS spell is active, do extra 2% per lvl of foe */
d1561 1
a1561 1
    dam += (int)(dam * (GET_LEVEL(victim)*0.02));
d1661 7
d2894 1
a2894 1
    if ((affected_by_spell(victim, SPELL_ICE_ARMOR))) {
d3535 5
d4402 1
d5034 4
d5256 1
d5270 1
d5705 6
@


1.80
log
@Save applies now make a difference.  Reduced damage exorcism causes to caster.
Fixed bug with improving skill preventing other unrelated things from occuring.
Ice armor now has coldshield affect.  Entangle, minor paralysis, and sleep
no longer make the mob attack for successes.  Added combust and cremate spells.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.79 2007/02/08 01:30:00 myc Exp myc $
d68 1
d1653 1
a1653 10
    if ((affected_by_spell(victim, SPELL_ARMOR)) || \
        (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	(affected_by_spell(victim, SPELL_MIRAGE)) || \
        (affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || \
        (affected_by_spell(victim, SPELL_COLDSHIELD))) {      
      to_char = "$N seems to be protected enough already!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n looks a little over protective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
a1654 1
    }
d1784 1
a1784 8
    
    if ((affected_by_spell(victim, SPELL_ICE_ARMOR)) || \
	(affected_by_spell(victim, SPELL_BARKSKIN)) || (affected_by_spell(victim, SPELL_GAIAS_CLOAK))) {
      to_char = "You seem to be protected enough already!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n looks a little over protective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
a1785 1
    }
d1884 3
a1886 8
    
    if ((affected_by_spell(victim, SPELL_ARMOR)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	(affected_by_spell(victim, SPELL_MIRAGE)) || (affected_by_spell(victim,SPELL_BARKSKIN))) {
      to_char = "You seem to be protected enough already!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$n looks a little over protective.";
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      /* No improve skill check */
d1888 1
a1888 2
    }
    
d1950 2
a1951 1
    if(mag_savingthrow(victim, SAVING_PARA) || number(0, 100) > 50) {
a1969 5
    /* Necessary to include all of spell through the break in each skill range check
       in order to fascilitate additional chances at a Major Paralysis at higher skill
       ranges.  No clue if I've done this correctly with the number() function. RSD 3/26/00
    */
    
a1970 1
      refresh = FALSE;
a1972 5
      to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
      to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
      to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
      imp_skill = TRUE;
      break;
a1973 1
      refresh = FALSE;
a1975 5
      to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
      to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
      to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
      imp_skill = TRUE;
      break;
d1977 1
a1977 2
      if(number(0, 100) < 2) { /* Is this number() the same one referenced at the top of the spell? RSD */
	refresh = FALSE;
a1979 4
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
	break;
a1980 1
	refresh = FALSE;
a1982 5
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
	imp_skill = TRUE;
	break;
d1985 1
a1985 2
      if(number(0, 100) < 7) { /* Is this number() the same one referenced at the top of the spell? RSD */
	refresh = FALSE;
a1987 4
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
	break;
a1988 1
	refresh = FALSE;
a1990 5
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
	imp_skill = TRUE;
	break;
d1993 1
a1993 2
      if(number(0, 100) < 10) { /* Is this number() the same one referenced at the top of the spell? RSD */
	refresh = FALSE;
a1995 4
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
	break;
a1996 1
	refresh = FALSE;
a1998 5
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $N!&0";
	to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
	imp_skill = TRUE;
	break;
d2006 6
d2027 1
a2027 17
    } else if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	       (affected_by_spell(victim, SPELL_MIRAGE)) || (affected_by_spell(victim,SPELL_BARKSKIN))) {

      if (victim) {
	to_char = "You seem to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      } else {
	to_char = "$N seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	to_vict = "You seem to be protected enough already!";
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      }
      /* No improve skill check */
d2029 1
a2029 1
    } else {
d2181 1
a2181 16
    if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_ARMOR)) || \
	(affected_by_spell(victim,SPELL_BARKSKIN)) || (affected_by_spell(victim, SPELL_ICE_ARMOR))) {
      if (victim) {
	to_char = "You seem to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      } else {
	to_char = "$N seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	to_vict = "You seem to be protected enough already!";
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      }
      /* No improve skill check */
a2182 1
    }
a2779 5
    /* Someone needs to look into what AFF2_HARNESS does so a help text
       can be made, is this like energy drain?  Looks like it's referenced
       in mag_damage() to cause extra damage on offensive spells.
     */

d2971 3
a2973 1
    if(mag_savingthrow(victim, SAVING_PARA)) {
a3163 2
   
    /* needs check for demonskin, if demonskinned should return w/o suceess */
d3165 2
a3166 16
    if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	(affected_by_spell(victim,SPELL_ICE_ARMOR))) {
      if (victim) {
	to_char = "You seem to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      } else {
	to_char = "$N seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	to_vict = "You seem to be protected enough already!";
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      }
      /* No improve skill check */
d3168 1
a3168 1
    }
d3387 3
d4012 9
a4020 1
    if (!sleep_allowed && !IS_NPC(ch) && !IS_NPC(victim))
d4022 2
d4025 2
a4026 1
        mag_savingthrow(victim, SAVING_PARA) || number(0, 100) < GET_LEVEL(victim)) {
d4269 1
a4269 17
    if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	       (affected_by_spell(victim, SPELL_MIRAGE)) || (affected_by_spell(victim,SPELL_BARKSKIN))) {

      if (victim) {
	to_char = "You seem to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_ROOM);
      } else {
	to_char = "$N seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, victim, TO_CHAR);
	to_vict = "You seem to be protected enough already!";
	act(to_vict, FALSE, ch, 0, victim, TO_VICT);
	to_room = "$n looks a little over protective.";
	act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
      }
      /* No improve skill check */
d4271 22
d4294 4
a4297 28
      
      /* Determine spell elements based on proficiency RSD 3/25/00 */
      if (skill > 0 && skill < 20) {
	af[0].location = APPLY_AC;
	af[0].modifier = -10;
	af[0].duration = 8;
      } else if (skill >= 20 && skill < 35) {
	af[0].location = APPLY_AC;
	af[0].modifier = -12;
	af[0].duration = 10;
      } else if (skill >= 35 && skill < 50) {
	af[0].location = APPLY_AC;
	af[0].modifier = -15;
	af[0].duration = 15;
      } else if (skill >= 50 && skill < 85) {
	af[0].location = APPLY_AC;
	af[0].modifier = -20;
	af[0].duration = 20;
      } else if (skill >= 85) {
	af[0].location = APPLY_AC;
	af[0].modifier = -25;
	af[0].duration = 48;
      } else {
	sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_BONE_ARMOR with 0 SKILL.", GET_NAME(ch));      
	log(buf);
	send_to_char(broken, ch);
	return;
      }
a4302 2
    break;
    
d5657 27
d5686 6
@


1.79
log
@Circle of fire does damage based on level now.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.78 2006/12/19 04:36:53 dce Exp myc $
d484 4
a487 10
  
  /* negative apply_saving_throw values make saving throws better! */
  /* I uncommented the old saves and commented nech new ones to test Banyal
   * if (IS_NPC(ch)) 
   *   save = saving_throws[CLASS_WARRIOR][type][(int) GET_LEVEL(ch)];
   * else
   *   save = saving_throws[(int) GET_CLASS(ch)][type][(int) GET_LEVEL(ch)];
   */
  
  /* New save numbers by Nechtrous */
d489 6
a494 6
  
  /* save_applies removed by fingh 12/3/98 for testing
   *save += GET_SAVE(ch, type);
   */
  /*
    switch(type) {
d496 5
a500 2
    sprintf(buf, "PARALYSIS");
    break;
d502 2
a503 5
    sprintf(buf, "ROD");
    break;
    case SAVING_BREATH:
    sprintf(buf, "BREATH");
    break;
d505 3
a507 9
    sprintf(buf, "PETRIFICATION");
    break;
    case SAVING_SPELL:
    sprintf(buf, "SPELL");
    break;
    default:
    break;
    }
  */
d705 1
a705 1
  
d914 3
d1352 3
a1354 3
    GET_HIT(ch) = GET_HIT(ch) - (dam/10);
    if (GET_MOVE(ch) > 45) {
      GET_MOVE(ch) = MAX(45, GET_MOVE(ch) - (dam/10));
d1460 1
a1460 1
    GET_HIT(ch) = GET_HIT(ch) - (dam/10);
d1540 2
a1541 14
  if( ch->casting.spell == spellnum && imp_skill ) {
    improve_skill(ch, spell_info[spellnum].sphere);  

  /*switch through classes*/
  /*switch (GET_CLASS(ch))
    {
    case CLASS_MAGIC_USER:
    dam = dam;
    break;
    default:
    dam = (int)((95 * dam)/100);
    break;
    }
  */
d1557 1
a1557 1
  
a1580 1
  }
d1651 7
a1657 5
    /* need some check for exclusion of other armor spells */

    if ((affected_by_spell(victim, SPELL_ARMOR)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
	(affected_by_spell(victim, SPELL_MIRAGE)) || (affected_by_spell(victim, SPELL_GAIAS_CLOAK))) {      
      to_char = "You seem to be protected enough already!";
d1664 6
a1669 7
    
    /* The goal with this spell was to create a weak armor
       affect with a very weak coldshield affect as well.
       The coldshieldesque component will need to be addressed
       at a later date. Like when someone who knows how to
       code can look at it. RSD 3/25/00
    */
d1697 1
d1950 7
a1956 1

d1980 9
a1988 1
      imp_skill = TRUE;
d2090 1
a2090 1
      return;
a2882 4
    if(!FIGHTING(ch) || FIGHTING(ch) != victim) {
      send_to_char("You are not fighting that person.\r\n", ch);
      return;
    }
d2884 1
a2884 1
      send_to_char("You have already harnessed the energy!\r\n",ch);
a2887 1
    /* Determine spell elements based on proficiency RSD 3/26/00 */
d2890 1
a2890 1
    } else if (skill >= 20 && skill < 40) {
a2891 6
    } else if (skill >= 40 && skill < 70) {
      af[0].duration= 2;
    } else if (skill >= 70 && skill < 85) {
      af[0].duration= 2;
    } else if (skill >= 85) {
      af[0].duration= 2; 
d2989 11
d3056 7
d3075 1
a3075 1
      to_char="&$N resists your weak paralysis.";
d3081 9
a3089 1
      imp_skill = TRUE;
d4119 7
a4125 1

d4128 2
a4129 5
    if (MOB_FLAGGED(victim, MOB_NOSLEEP))
      to_char = "You can't seem to put this one to sleep.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      return;
    if (mag_savingthrow(victim, savetype))
d4136 5
a4141 9
    /* temp fix until saves fixed. Tired of people sleeping guards.*/
    if(number(1,100) > 50) {
      if(IS_NPC(victim) && number(1,100) > 50 && !FIGHTING(victim))
        hit(victim,ch,TYPE_UNDEFINED);
      return;
      /* I think the Hubis boys added this 'fix'. We need to address sleep
	 and how it works in combat, and how it works when initiating combat.
	 We should also make common guard type mobiles wake sleeping mobiles
	 they are allied with. RSD 3/27/00 */
d4706 5
d5782 3
@


1.78
log
@Modified Supernova to mimic Ice Shards.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.77 2006/11/20 22:24:17 jps Exp $
d1541 3
a1543 1
    
d5769 3
@


1.77
log
@End the difficulties in interaction between evil and good player races.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.76 2006/11/20 19:52:04 jps Exp jps $
d4666 5
d5767 3
@


1.76
log
@Levitate halves earthquake damage.  Fixed feedback messages when
casting levitate and ray of enfeeblement.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.75 2006/11/18 07:03:30 jps Exp jps $
a4725 2
       * players can only hit players in CRIMEOK rooms 4) players can only hit
       * charmed mobs in CRIMEOK rooms
a4726 11
      if (PRF_FLAGGED(ch, PRF_NICEAREA))
	if (!IS_NPC(tch))
	  if ((zone_table[world[ch->in_room].zone].number == 147) ||
	      (zone_table[world[ch->in_room].zone].number == 320) ||
	      (zone_table[world[ch->in_room].zone].number == 305) ||
	      (zone_table[world[ch->in_room].zone].number == 250) ||
	      (zone_table[world[ch->in_room].zone].number == 257) || 
	      (zone_table[world[ch->in_room].zone].number == 57))
	    if (GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(tch))
	      continue;
      
a4732 4
      /* WTF was this? remoevd by nech
	 if (!IS_NPC(ch) && IS_NPC(tch))
	 continue;
      */
d5762 4
@


1.75
log
@Minor typo fixes
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.74 2006/11/18 04:26:32 jps Exp jps $
d1084 3
a1086 1
    if (number(1, 100) >= (GET_DEX (victim) - quake_dex_modifier)) {
d1100 4
d3168 3
a3170 2
    to_vict="You feel the strength flow out of your body.";
    to_room="$N turns pale and starts to sag.";
d3194 3
a3196 2
    to_vict="&6You float up in the air.&0";
    to_room="&6$N&0&6 floats up into the air.&0";
d5779 3
@


1.74
log
@Renamed continual light spell to illumination, and it only works on
LIGHT items (still rooms too).
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.73 2006/11/17 22:52:59 jps Exp jps $
d3540 1
a3540 1
    to_vict = "&7The world blurs as you start moving with unnatural speed&0";
d5771 4
@


1.73
log
@Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.72 2006/11/14 18:54:02 jps Exp jps $
d612 1
a612 1
      if (ROOM_AFFECTED(raff->room, RAFF_CONTINUAL_LIGHT))
d5771 3
@


1.72
log
@Fly spell now produces feedback to caster when cast on someone else.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.71 2006/11/13 19:24:00 jps Exp jps $
d4785 2
a4786 2
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_EVIL_ALIGN);
  REMOVE_BIT(MOB_FLAGS(mob), MOB_AGGR_GOOD_ALIGN);
d5167 2
a5168 2
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_EVIL_ALIGN);
      REMOVE_BIT(MOB_FLAGS(new_mob), MOB_AGGR_GOOD_ALIGN);
d5771 3
@


1.71
log
@"animate dead" is in sphere of death, and improves.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.70 2006/11/13 18:33:58 jps Exp jps $
d4268 1
a4268 1
    to_vict = "&7You fly thru the air, free as a bird!&0";
d4271 1
d5771 3
@


1.70
log
@Fix major/minor globe interaction, and add feedback for the caster.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.69 2006/11/13 17:51:31 jps Exp jps $
d5112 1
d5770 3
@


1.69
log
@Guard will improve normally.  Also there are messages for failed
guard attempts.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.68 2006/11/11 10:11:04 jps Exp jps $
d2917 1
a2917 1
    if(AFF2_FLAGGED(ch, AFF2_MAJOR_GLOBE)) {
d2947 3
a2949 2
    to_vict="&1A shimmering globe wraps around your body.&0";
    to_room="&1A shimmering globe wraps around $N&0&1's body.&0";
d2955 1
a2955 1
    if(AFF2_FLAGGED(ch, AFF2_MINOR_GLOBE)) {
d2985 3
a2987 2
    to_vict="&1&bA shimmering globe of force wraps around your body.&0";
    to_room="&1&bA shimmering globe of force wraps around $N&1&b's body.&0";
d5769 4
@


1.68
log
@Create food now chooses from 50 food objects (10 for each food
creating class), based on caster proficiency and luck.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.67 2006/11/08 09:59:46 jps Exp $
d451 24
a474 12
  
  /* check to see if char is guarded and roll for guarding affect */
  if (ch->casting.target_status != TARGET_ALL_ROOM 
      && victim->guarded_by 
      && get_char_room_vis(victim->guarded_by,GET_NAME(victim))==victim) {
    if(GET_ISKILL(victim->guarded_by, SKILL_GUARD) > number(1,1100) 
       && !CHECK_WAIT(victim->guarded_by) 
       && GET_POS(victim->guarded_by) >= POS_FIGHTING) {
      if(!gag_output) {
        act("$n jumps in front of $N, shielding $M from the assault.",FALSE,victim->guarded_by,0,victim, TO_NOTVICT);
        act("$n jumps in front of you, shielding you from the assault.",FALSE,victim->guarded_by,0,victim, TO_VICT);
        act("You jump in front of $N, shielding $M from the assault.",FALSE,victim->guarded_by,0,victim, TO_CHAR);
d476 2
a477 4
      return victim->guarded_by;
    }
  }
  return victim;
d5767 4
@


1.67
log
@Added caster feedback message for "protection from evil".
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.66 2006/11/08 09:16:04 jps Exp jps $
d5465 2
a5466 1

d5472 1
a5472 1
  int z;
d5486 29
a5514 1
    z = 10;
d5757 3
@


1.66
log
@Fixed some loose-lose typos.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.65 2006/11/08 08:49:29 jps Exp jps $
d4071 1
d5728 3
@


1.65
log
@Fix missing punctuation in missed poison spell message.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.64 2006/11/08 08:01:14 jps Exp jps $
d1344 1
a1344 1
       Now you loose some HP and MV for selling your soul to hurt the demons! */
d1350 1
a1350 1
    act("You loose some life in libation of your holy allegiance!",FALSE,ch,0,victim,TO_CHAR);
d1452 1
a1452 1
       Now you loose some HP and MV for selling your soul to hurt the demons! */
d1458 1
a1458 1
    act("You loose some life in libation of your holy allegiance!",FALSE,ch,0,victim,TO_CHAR);
d5727 3
@


1.64
log
@Typo fix "You sprouts roots" -> "You sprout roots"
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.63 2006/11/07 14:09:46 jps Exp jps $
d4003 1
a4003 1
      to_room = "$N dodges $n's attempt to prick $M";
d5727 3
@


1.63
log
@If you are silenced in the middle of casting your own spell, that
spell fails.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.62 2006/11/06 17:38:19 jps Exp jps $
d5265 1
a5265 1
    act("&2&bYou sprouts roots that dig deep beneath the soil, drawing sustenence.&0",FALSE,victim,0,0,TO_CHAR);
d5727 4
@


1.62
log
@affect spells cast on self will no longer send two messages to the caster
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.61 2006/07/20 07:34:53 cjd Exp $
d4454 13
d5727 3
@


1.61
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.60 2006/05/30 00:51:18 rls Exp $
d4439 2
a4440 1
	 if (to_char != NULL)
d5714 3
@


1.60
log
@modified poison affects to be a bit more potent
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.59 2004/11/28 06:38:07 rsd Exp $
d906 1
a906 1
      send_to_char("This area is to enclosed to grow any plants!\r\n",ch);
d908 1
a908 1
      act(to_room, TRUE, ch, 0, victim, TO_ROOM);
d2568 2
a2569 2
    to_room="$n looks healthier than before!";
    to_char="$n looks healthier than before!";
d3005 2
a3006 2
    to_vict="&4A jagged formation of i&bc&7e sh&4ard&0&4s form around you.&0";
    to_room="&4A jagged formation of i&bc&7e sh&4ard&0&4s form around $N&0&4.&0";
d3036 1
a3036 1
    to_vict="&1A burning shield if f&bi&3r&7e&0&1 explodes from your body!&0";
d3192 3
a3194 3
      to_vict = "You resist $n's withering affects!";	
      to_char = "$N resists your withering affect!";
      to_room = "$N resists $n's withering affect!";
d3417 1
a3417 1
    to_vict = "&1&bYour skin starts to itch as you reduce to half your normal size&0"; 
d3554 1
a3554 1
    to_vict = "&8You feel you knowledge of Fiery's languages improving!&0";
d4632 1
a4632 1
    to_room = "$n&6&b crushes his foes under a relentless ice storm!&0";
d5713 3
@


1.59
log
@Changed the healing multiplies back to half what they were
and doubled the number of dice in each healing spell.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.58 2004/11/19 03:09:58 rsd Exp $
d3937 1
a3937 1
    } else if (skill >= 20 && skill < 40) {
d4012 1
a4012 1
      af[0].duration = 5;
d4015 1
a4015 1
      af[0].duration = 7;
d4018 1
a4018 1
      af[0].duration = 9;
d4021 2
a4022 2
      af[0].duration = 10;
      af[0].modifier = -12;
d4024 2
a4025 2
      af[0].duration = 12;
      af[0].modifier = -14;
d4076 2
a4077 4
    /* This spell won't ever exist for mortals so it won't reference the
       skill system at all, If you see mobiles with this affected upon them
       remove it.  RSD 3/25/00
       Leave the spell it's handy to test with.
d5713 4
@


1.58
log
@Doubled healing output for the heal spells again.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.57 2004/11/13 10:45:48 rls Exp $
d5201 1
a5201 1
    heal_mult = 4;
d5203 1
a5203 1
    heal_mult = 6;
d5205 1
a5205 1
    heal_mult = 8;
d5207 1
a5207 1
    heal_mult = 10;
d5209 1
a5209 1
    heal_mult = 12;
d5218 1
a5218 1
    hit = (float)(dice(1, 8) + 1) * heal_mult;
d5222 1
a5222 1
    hit = (float)(dice(3, 8) + 3) * heal_mult;
d5226 1
a5226 1
    hit = (float)(dice(2, 8) + 2) * heal_mult;
d5230 1
a5230 1
    hit = ((float)dice(25,2) * heal_mult) + 20;
d5234 1
a5234 1
    hit = ((float) dice(50, 2) * heal_mult) + 175;
d5238 1
a5238 1
    move = (float)(dice(1, 8) + 5) * heal_mult;
d5242 1
a5242 1
    move = (float)(dice(2, 8) + 5) * heal_mult;
d5246 1
a5246 1
    move = (float)(dice(3, 8) + 5) * heal_mult;
d5715 3
@


1.57
log
@Fixed crashie bug with remove curse scroll... or so it seems.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.56 2004/10/15 18:33:30 rsd Exp $
d5201 1
a5201 1
    heal_mult = 2;
d5203 1
a5203 1
    heal_mult = 3;
d5205 1
a5205 1
    heal_mult = 4;
d5207 1
a5207 1
    heal_mult = 5;
d5209 1
a5209 1
    heal_mult = 6;
d5715 3
@


1.56
log
@Ok, something odd happened with this, I added a buncha
checks to the creation of undead to remove the aggressive
flags to prevent necros from killing off players.
Bad necro's the odd thing is that I fixed a typo while
having the file checed out in another directory and did
a make.  It's almost as though it checked in my changes and
updated the file on me automatically.  weirdness... .
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.55 2003/08/21 02:36:16 jjl Exp $
d5420 1
a5420 1
  case SPELL_REMOVE_CURSE:
d5422 1
a5422 1
      REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
d5439 1
a5439 1
  
d5715 9
@


1.55
log
@Zzur said to double the healing power.  So I did.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.54 2003/06/20 15:04:56 rls Exp $
d4754 5
d4760 1
d5715 3
@


1.54
log
@Capped energy drain at 6x caster's hp... 1 hp gain thereafter.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.53 2003/06/18 14:57:37 rls Exp $
d5195 1
a5195 1
    heal_mult = 1;
d5197 1
a5197 1
    heal_mult = 1.5;
d5199 1
a5199 1
    heal_mult = 2;
d5201 1
a5201 1
    heal_mult = 2.5;
d5203 1
a5203 1
    heal_mult = 3;
d5709 3
@


1.53
log
@Added a boolean to create_undead to check for PC corpses being raised
Allowed for PC corpse raising only when PK is enabled
Toned down the HP in create_undead to that of 2x the caster.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.52 2002/10/23 02:55:47 jjl Exp $
d1185 1
d1187 6
a1192 1
      GET_HIT(ch) = GET_HIT(ch) + dam;
d4957 1
a4957 1
  new_mob->points.max_hit = (caster->points.max_hit * 21) / 10;    
d5709 5
@


1.52
log
@D'oh.  Fixed some test code I had in that was breaking necros.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.51 2002/10/14 02:16:08 jjl Exp $
d4860 1
a4860 2
struct char_data *create_undead(struct char_data *orig, 
				struct char_data *caster)
d4897 37
a4933 27
  switch(new_mob_type) {
  case MOB_ZOMBIE:
    sprintf(short_buf, "the zombie of %s", GET_NAME(orig));
    sprintf(long_buf, "The zombie of %s lurches here.", GET_NAME(orig));
    sprintf(alias_buf, "zombie %s", orig->player.name);
    break;
  case MOB_SKELETON:
    sprintf(short_buf, "the skeleton of %s", GET_NAME(orig));
    sprintf(long_buf, "The skeleton of %s stands creaking at attention.", 
	    GET_NAME(orig));
    sprintf(alias_buf, "skeleton %s", orig->player.name);
    break;
  case MOB_SPECTRE:
    strcpy(short_buf, "a spectre");
    strcpy(long_buf, "A spectre lurks in the corner here.");
    strcpy(alias_buf, "spectre");
    break;
  case MOB_WRAITH:
    strcpy(short_buf, "a wraith");
    strcpy(long_buf, "A wraith floats above the ground moaning.");
    strcpy(alias_buf, "wraith");
    break;
  case MOB_LICH:
    strcpy(short_buf, "a lich");
    strcpy(long_buf, "A lich glares around the room sneering maliciously.");
    strcpy(alias_buf, "lich");
    break;
d4935 1
d4950 2
a4951 6
  /* this one too *bigger gulp* */
  if (!new_mob->points.max_hit)
    new_mob->points.max_hit = MAX(0, MIN(32000, dice(new_mob->points.hit, new_mob->points.mana) + GET_EX_MAIN_HP(new_mob) + new_mob->points.move));
  else
    new_mob->points.max_hit = number(new_mob->points.hit, 
				     new_mob->points.mana);    
d4964 2
d5053 11
a5063 5
    if (IS_PLR_CORPSE(obj)) {
      send_to_char("Raising PC corpses is not currently allowed.\r\n", ch);
      return;
    } else if ((GET_OBJ_VAL(obj, 3) == CORPSE_NPC_NORAISE) || /* unraisable */
	       ((orig_mob_rnum = GET_OBJ_MOB_FROM(obj)) == NOBODY)) {
d5069 5
a5073 1
    new_mob = create_undead(mob_proto + orig_mob_rnum, ch);
d5703 3
@


1.51
log
@An update to turn vitality into a set of 6 spells, lesser endurance,
endurance, greater endurance, vitality, greater vitality, and dragon's
health.  Greater endurance is what vitality was.  The rest are scaled
appropriately.    The higher end may need scaled down, or may not.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.50 2002/09/15 04:27:11 jjl Exp $
d5078 1
a5078 1
    af.duration = 1;  /* (int)(base_duration * preserve_mult); */
d5090 1
a5090 2
      af.duration = 2; 
      /* (int)(base_duration * preserve_mult) + 1; */ /* (for now) */
d5685 6
@


1.50
log
@Fixed sundry typos in messages, added stone skin wear off message, wings of heaven/hell make you fly now.
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.49 2002/09/13 02:32:10 jjl Exp $
d66 2
d2538 3
d2542 15
a2556 1
    
d2558 4
a2561 3
    af[0].modifier = (pow(skill, 2) / 40) + 50;
    af[0].duration = get_spell_duration(ch, SPELL_VITALITY);
    to_vict="&4&bYou feel vitalized!&0";
d2571 10
a2580 3
    if(number(1,100) > 80) { 
      improve_skill(ch, SKILL_SPHERE_PROT);
    }
a2581 1
    
d5078 1
a5078 1
    af.duration = (int)(base_duration * preserve_mult);
d5090 2
a5091 1
      af.duration = (int)(base_duration * preserve_mult) + 1; /* (for now) */
d5562 6
a5567 5
/* Add spells to the case statement here to make a spell's duration skill related */
/* the spell system automagically adds 1 to this so values start at 0             */
/* Note that adding the default 1 added to a 0 will make the spell wear off when  *
 * the next TICK (currently 75 secs) expires no matter how close it is.  This     *
 * gives the affect of nearly instantaneous expiration of the spell. RSD 03/17/00 */
d5570 5
d5576 8
a5583 1
  switch(spellnum) {
d5585 13
a5597 10
    skill = GET_SKILL(ch, SKILL_SPHERE_PROT);
    if(skill > 0 && skill <= 40) {
      return 2;
    } else if (skill >= 41 && skill <= 60) {
      return 3;
    } else if (skill >= 61 && skill <= 94) {
      return 4;
    } else if (skill > 95) {
      return 5;
    }
d5599 1
d5603 78
a5680 1
  return 0;
d5686 3
@


1.49
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: magic.c,v 1.48 2002/07/16 23:22:41 rls Exp $
d532 4
a535 1
	    affect_remove(i, af);/*remove bit*/
d2532 1
d2585 1
d3385 2
a3386 2
    to_vict = "&1&bYour skin starts to itch as you reduce to twice your normal size&0"; 
    to_room = "&1&b$n's skin ripples as $e shrinks to twice $s normal size!&0";
d3449 1
a3449 1
    to_vict = "&9&bYou skin hardens and turns to stone!&0";
d5565 3
@


1.48
log
@added in new necro spell, bone armor
@
text
@d1 3
a3 1
// $Id: magic.c,v 1.47 2002/03/27 00:04:19 dce Exp $
d4486 1
a4486 1
	       // if (!IS_AFFECTED(tch, AFF_GROUP))
d5558 243
a5800 238
// $Log: magic.c,v $
// Revision 1.47  2002/03/27 00:04:19  dce
// *** empty log message ***
//
// Revision 1.45  2002/02/25 12:30:07  rls
// *** empty log message ***
//
// Revision 1.44  2002/02/25 11:18:40  rls
// Adj to_char msg for AFF_BLIND to ...blinded by you!
//
// Revision 1.43  2002/02/18 22:54:15  dce
// When casting fly, the caster would be the one who's position
// was set to fly. I changed it to the vicitim. So from
// GET_POS(ch) to GET_POS(victim).
//
// Revision 1.42  2001/12/07 16:11:04  dce
// Fix the heal spells so you can not get your hp's above max.
//
// Revision 1.41  2001/03/07 01:45:18  dce
// Added checks so that players can not kill shapechanged players and
// vise versa. Hopefully I didn't miss any...
//
// Revision 1.40  2000/11/22 20:35:18  rsd
// Added back rlog messages from prior to the addition of
// the $log$ string.
//
// Revision 1.39  2000/11/15 18:52:33  rsd
// Magic users can no longer cast energy drain upon themselves
// to gain hitpoints..
//
// Revision 1.38  2000/11/14 20:11:39  rsd
// Added a pk check for the -str affect on chill touch.
//
// Revision 1.37  2000/10/13 22:26:52  rsd
// altered the power of chain lightning
//
// Revision 1.36  2000/10/05 03:05:08  rsd
// Altered almost every spell to redo the way skills were
// accessed in the spells by objects and not casters to
// use the level of the object to determine power and
// not allow an object to cause a players proficiency to increase
// by using its spell.
//
// Revision 1.35  2000/09/29 04:16:24  rsd
// Altered every spell in mag_affects to use the new skill
// checking code that checks if a player is casting or uses
// an item spell.  This should restore potions and scrolls
// et al to normal use.
//
// Revision 1.34  2000/09/28 20:37:15  jimmy
// added fix to mag_affects that checks to see weather a spell is
// being cast or if it's an affect from an object.  Objects will
// get their skill based on the level of the object.  I.E pc/npc's
// who don't have SPELL_ARMOR skill can quaff an armor potion
// and get affected by an armor spell of the level of the potion.
// All other mag_XXX functions can be migrated to join suit.
// jbk
//
// Revision 1.33  2000/04/30 18:14:19  rsd
// bless no longer has an alignement check, it does have a dark
// presence check though, and dark presence has a bless check.
//
// Revision 1.32  2000/04/15 23:12:03  rsd
// fixed damage algorythm for flood and meteorswarm added
// iceshards and supernova...
//
// Revision 1.31  2000/04/14 00:55:49  rsd
// altered a few spells
//
// Revision 1.30  2000/04/09 22:32:24  rsd
// altered a buncha act buffers to try to get the spell messaging
// done properly.  Also altered the order of ch and victim in
// the catch all buffers for the order changed in the act()'s
// for mag_affects().
//
// Revision 1.29  2000/04/08 08:41:23  rsd
// altered prayer to have float math to return expected values.
// altered shocking grasp to actually reference the proper
// sphere to calculate damage, also made it to the 2nd power
// instead of the typoed 7th. Changed about a kabillion act()
// statements to make more sense I hope.
//
// Revision 1.28  2000/04/05 06:35:34  rsd
// added 1 kabillion more spells into the spell system.
// lalala.
//
// Revision 1.27  2000/04/02 02:39:39  rsd
// changed the to_room act in most spells to be TO_NOTVICT as
// I think was the intent in most cases.  Also added and
// integrated the spell system up through all 4th circle
// spells.
//
// Revision 1.26  2000/03/31 23:46:37  rsd
// integrated more spells into the skill system with improve
// skill calls. Also comeplted more spells. in mag_damage().
//
// Revision 1.25  2000/03/31 00:16:10  rsd
// added a few variables to mag_damage() to make the use of the
// spell system doable. Also changed how damage was assigned
// to be proper for the intent for the first few spells.
// Note that spells are becomeing significantly more potent,
// maybe to much so, ptesting will get it figured out. This should
// get all spells up through 3rd circle into the spell system.
//
// Revision 1.24  2000/03/30 05:45:54  rsd
// added mag_damage spells, all first and second circle spells of all
// classes are in the spell system now.
// sync
//
// Revision 1.23  2000/03/29 06:29:50  rsd
// Many mag affects spells had returns out for various reasons.
// The messages associated with the returns were buffered but
// never sent by the act()'s at the end of the function. Each
// buffer for player messaging before a return now has an act
// assicated with it.  I hope it's done correctly.
//
// Revision 1.22  2000/03/27 08:06:06  rsd
// completed hosing with all the spells in mag_affectc()
// except stone skin.
//
// Revision 1.21  2000/03/26 23:48:37  rsd
// completed more of the mag_affects() spells.
//
// Revision 1.20  2000/03/26 07:21:20  rsd
// Added an improve_skill() call to every mag_affects() spell case in
// the switch, each spell has a base improve_skill() call just before
// the break in their case.  Some have more than one instance of the
// call............
// Added appropriate to_vict, to_room, and to_char messages for the
// first half of spells in mag_affects().
// Removed the defines for af[0].element that I had put in mag_affects()
// a few days ago.  I realized that there was af[i].element going on
// so to just have the defines for af[0] was a bit silly. I removed the
// use of the defines I had coded for barkskin, dark presence, armor,
// bless, and demonskin......
// Added alignment checks and restrictions on Demonskin, Dark Presence,
// and bless.........
// Worked though about the first half of the spells in mag_affects()
// and integrated the spell proficiency system.  This was rather easy
// compared to the pther mag() type spells as most of the mag_affects()
// spells have very simple affects to manipulate.  There were a few
// instances of spells where we want more special things to occur,
// and some instances of confusion, but it's all commented. I admit
// some of the things I did were goat sacrificing HACKS that may not
// work. More work later....
//
// Revision 1.19  2000/03/25 21:36:13  rsd
// Altered to use spell proficiencies:
// chill touch
// Barkskin
// nightvision
// dark presence
// Also added a missing skill check for demonskin.
//
// Revision 1.18  2000/03/24 23:49:35  rsd
// Altered bless and demonskin to use the spell prof system.
//
// Revision 1.17  2000/03/24 05:24:39  rsd
// changed armor to use sphere of prot as skill proficiency.
// Also declared some variables at the beginning of mag_affects()
// to facilitate the use of skills in spells.
//
// Revision 1.16  2000/03/19 20:38:18  rsd
// added brackes to the if statements of SD_INTERN_DAM and
// tabbed it out.
//
// Revision 1.15  2000/03/18 06:08:38  rsd
// Changed the overall duration of vitality as well as the ranges
// at which the durations increase. Put some comments in about what
// a default duration of 0 means to the players. Added an extern -
// extern void improve_skill(struct char_data *ch, int skill);
// This was done so skill improvemts could be called for spell usage
// like with the ones added for vitality.
//
// Revision 1.14  2000/03/05 00:15:34  rsd
// Er, had a buncha returns though the functioning parts of
// Dispel good and evil, so it was returning out of mag_damage
// after it listed the damage hehe silly me.
//
// Revision 1.13  2000/03/04 08:32:25  rsd
// Altered DISPEL_GOOD DISPEL_EVIL and VAMPIRIC_BREATH
// to be somewhat functional, more so than they were
// before.  Although the dispells don't seem to call
// their proper messages.
// /s
//
// Revision 1.12  2000/02/26 02:17:21  rsd
// Oooook, fixed healing proficiency cheks to actually include the 96
// percentile by adding a = after the > in >96 grumbmle.
//
// Revision 1.11  1999/12/08 21:21:59  jimmy
// added checks for spell proficiencies all healing spells and vitality.
//
// Revision 1.10  1999/11/29 01:32:51  cso
// made chill touch decrease strength a little more
//
// Revision 1.9  1999/11/28 23:41:42  cso
// affect_update: added check to kill animated mobs when the animate wears off
// new fn: mod_for_undead_type: modify a mob's stats based on what undead type
//  it is. used by create_undead
// new fn: mod_for_lvldiff: modify a mob's stats based on the level difference
//  between it and the necro that raised it. used by create_undead
// new fn: create_undead: create an undead mob. used by mag_summons for
//
//  animate dead
// new fn: ch_can_control_mob: check to see if a necro can control the undead
//  he just raised. used by mag_summons for animate dead
// removed unused mag_summons_msgs
// removed unused mag_summon_fail_msgs
// removed unused defines form MOB_ZOMBIE, MOB_MONSUM_I, etc
// rewrote mag_summons from scratch
//
// Revision 1.8  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.7  1999/03/07 05:01:09  dce
// Chant finishes and wearoff messages.
//
// Revision 1.6  1999/02/13 19:37:12  dce
// Rewrote Continual Light and Darkness to be manual spells to meet our needs.
//
// Revision 1.5  1999/02/11 16:44:23  dce
// When casting minor creation, light objects come lit.
//
// Revision 1.4  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.3  1999/02/10 02:38:58  dce
// Fixes some of continual light.
//
// Revision 1.2  1999/01/31 16:35:11  mud
// Indented entire file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.47
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.45 2002/02/25 12:30:07 rls Exp $
d4301 57
d5557 3
@


1.46
log
@Commented barkskin supermonks message, as monks get stoneskin, armor, etc
@
text
@d2056 1
a2056 1
    /* No super Monks!  - monks get stoneskin, etc.. commented by RLS 
d2064 1
a2064 1
      * NO IMPROVE SKILL CALL *
d2067 2
a2068 2
      * Check for other types of armor spells *
      } else*/ if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
@


1.45
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.44 2002/02/25 11:18:40 rls Exp $
d2056 1
a2056 1
    /* No super Monks! */
d2064 1
a2064 1
      /* NO IMPROVE SKILL CALL */
d2067 2
a2068 2
      /* Check for other types of armor spells */
    } else if ((affected_by_spell(victim, SPELL_GAIAS_CLOAK)) || (affected_by_spell(victim, SPELL_DEMONSKIN)) || \
d5500 3
@


1.44
log
@Adj to_char msg for AFF_BLIND to ...blinded by you!
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.43 2002/02/18 22:54:15 dce Exp $
d3659 1
a3659 1
    to_char = "&9&b$N&9&b is blinded! by you!&0";
d5500 3
@


1.43
log
@When casting fly, the caster would be the one who's position
was set to fly. I changed it to the vicitim. So from
GET_POS(ch) to GET_POS(victim).
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.42 2001/12/07 16:11:04 dce Exp $
d4296 1
a4296 1
	to_char = "&9&b$N&9&b is blinded! by you!&0";
d5500 5
@


1.42
log
@Fix the heal spells so you can not get your hp's above max.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.41 2001/03/07 01:45:18 dce Exp $
d4219 1
a4219 1
    GET_POS(ch) = POS_FLYING;
d5500 3
@


1.41
log
@Added checks so that players can not kill shapechanged players and
vise versa. Hopefully I didn't miss any...
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.40 2000/11/22 20:35:18 rsd Exp $
d5151 1
a5151 1
    alter_hit(victim, -hit, 4);
d5500 4
@


1.40
log
@Added back rlog messages from prior to the addition of
the $log$ string.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.39 2000/11/15 18:52:33 rsd Exp $
d1829 7
d1944 7
d2309 7
d2393 7
d2767 7
d3007 7
d3055 7
d3145 7
d3246 7
d3576 7
d3629 7
d3680 7
d3955 7
d5500 4
@


1.39
log
@Magic users can no longer cast energy drain upon themselves
to gain hitpoints..
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.38 2000/11/14 20:11:39 rsd Exp $
d5409 4
d5597 23
@


1.38
log
@Added a pk check for the -str affect on chill touch.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.37 2000/10/13 22:26:52 rsd Exp $
d1137 45
a1181 15
    /* This is a fairly brutal spell, so I'm going to use the Vamp Breath damage table here to
       give different level stuff a fighting chance versus the spell. I'm also going to make 
       the dam_mult dependent on proficiency so it can become more potent. RSD 4/2/00 */
    if (GET_LEVEL(ch) < 20)
      new_dam = dice(1, 20);
    if (GET_LEVEL(victim) >= 20 && GET_LEVEL(victim) < 40)
      new_dam = dice(2, 35);
    if (GET_LEVEL(victim) >= 40 && GET_LEVEL(victim) < 60)
      new_dam = dice(2, 50);
    if (GET_LEVEL(victim) >= 60 && GET_LEVEL(victim) < 80)
      new_dam = dice(2, 70);
    if (GET_LEVEL(victim) >= 80 && GET_LEVEL(victim) < 95)
      new_dam = dice(2, 100);
    if (GET_LEVEL(victim) >= 95 && GET_LEVEL(victim) < 99) {
      new_dam = dice(3, 90);
a1182 22
    skill = GET_SKILL(ch, spell_info[SPELL_NIGHT_VISION].sphere);    
    /* Determine spell elements based on proficiency RSD 4/2/00 */
    if (skill > 0 && skill < 20) {
      dam_mult = 1;
    } else if (skill >= 20 && skill < 40) {
      dam_mult = 1.1;
    } else if (skill >= 40 && skill < 70) {
      dam_mult = 1.25;
    } else if (skill >= 70 && skill < 85) {
      dam_mult = 1.4;
    } else if (skill >= 85) {
      dam_mult = 1.5;
    } else {
      sprintf(buf,"SYSERR:magic.c:mag_damage(): %s attemped to cast SPELL_ENERGY_DRAIN with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
    }
    dam = (new_dam * dam_mult);
    GET_HIT(ch) = GET_HIT(ch) + dam;
    imp_skill = TRUE;
    break;
d5409 3
@


1.37
log
@altered the power of chain lightning
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.36 2000/10/05 03:05:08 rsd Exp $
d3085 3
a3087 1

d5401 3
@


1.36
log
@Altered almost every spell to redo the way skills were
accessed in the spells by objects and not casters to
use the level of the object to determine power and
not allow an object to cause a players proficiency to increase
by using its spell.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.35 2000/09/29 04:16:24 rsd Exp $
d1388 2
a1389 2
    /* max dam 166 from 12d5+26 online */
    new_dam = ((pow(skill, 2) * 1) / 125) + dam;
d5399 7
@


1.35
log
@Altered every spell in mag_affects to use the new skill
checking code that checks if a player is casting or uses
an item spell.  This should restore potions and scrolls
et al to normal use.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.34 2000/09/28 20:37:15 jimmy Exp $
d689 1
a689 1
  
d782 15
d801 1
a801 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CAUSE_LIGHT].sphere), 2) * 2) / 625) + dam;
d803 1
a803 1
    improve_skill(ch, spell_info[SPELL_CAUSE_LIGHT].sphere);
d807 1
a807 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CAUSE_SERIOUS].sphere), 2) * 9) / 2000) + dam;
d809 1
a809 1
    improve_skill(ch, spell_info[SPELL_CAUSE_SERIOUS].sphere);
d813 1
a813 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CAUSE_CRITIC].sphere), 2) * 53) / 10000) + dam;
d815 1
a815 1
    improve_skill(ch, spell_info[SPELL_CAUSE_CRITIC].sphere);
d819 1
a819 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_HARM].sphere), 2) * 41) / 5000) + dam;
d821 1
a821 1
    improve_skill(ch, spell_info[SPELL_HARM].sphere);
d825 1
a825 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FULL_HARM].sphere), 2) * 1) / 50) + dam;
d827 1
a827 1
    improve_skill(ch, spell_info[SPELL_FULL_HARM].sphere);
d831 1
a831 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_BURNING_HANDS].sphere), 2) * 43) / 10000) + dam;
d833 1
a833 1
    improve_skill(ch, spell_info[SPELL_BURNING_HANDS].sphere);
d837 1
a837 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CHILL_TOUCH].sphere), 2) * 49) / 10000) + dam;
d843 1
a843 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_HELL_BOLT].sphere), 2) * 53) / 10000) + dam;
d867 1
a867 1
    improve_skill(ch, spell_info[SPELL_HELL_BOLT].sphere);    
d871 1
a871 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_DIVINE_BOLT].sphere), 2) * 53) / 10000) + dam;
d895 1
a895 1
    improve_skill(ch, spell_info[SPELL_DIVINE_BOLT].sphere);    
d905 1
a905 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_WRITHING_WEEDS].sphere), 2) * 53) / 10000) + dam;
d907 1
a907 1
    improve_skill(ch, spell_info[SPELL_WRITHING_WEEDS].sphere);
d911 1
a911 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_SHOCKING_GRASP].sphere), 2) * 7) / 1000) + dam;
d913 1
a913 1
    improve_skill(ch, spell_info[SPELL_SHOCKING_GRASP].sphere);
d938 1
a938 1
    improve_skill(ch, spell_info[SPELL_FLAMESTRIKE].sphere);
d973 1
a973 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_DISPEL_EVIL].sphere), 2) * 7) / 1000) + dam;
d975 1
a975 1
    improve_skill(ch, spell_info[SPELL_DISPEL_EVIL].sphere);
d1010 1
a1010 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_DISPEL_GOOD].sphere), 2) * 7) / 1000) + dam;
d1012 1
a1012 1
    improve_skill(ch, spell_info[SPELL_DISPEL_GOOD].sphere);
d1079 1
a1079 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_EARTHQUAKE].sphere), 2) * 13) / 2500) + dam;
d1084 1
a1084 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_LIGHTNING_BOLT].sphere), 2) * 1) / 125) + dam;
d1086 1
a1086 1
    improve_skill(ch, spell_info[SPELL_LIGHTNING_BOLT].sphere);
d1095 1
a1095 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FIREBALL].sphere), 2) * 1) / 125) + dam;
d1097 1
a1097 1
    improve_skill(ch, spell_info[SPELL_FIREBALL].sphere);
d1105 1
a1105 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_COLOR_SPRAY].sphere), 2) * 1) / 200) + dam;
d1107 1
a1107 1
    improve_skill(ch, spell_info[SPELL_COLOR_SPRAY].sphere);
d1116 1
a1116 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CONE_OF_COLD].sphere), 2) * 1) / 125) + dam;
d1118 1
a1118 1
    improve_skill(ch, spell_info[SPELL_CONE_OF_COLD].sphere);
d1122 1
a1122 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_COLOR_SPRAY].sphere), 2) * 7) / 1000) + dam;
d1124 1
a1124 1
    improve_skill(ch, spell_info[SPELL_HEATWAVE].sphere);
d1132 1
a1132 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FREEZING_WIND].sphere), 2) * 3) / 500) + dam;
d1173 1
a1173 1
    improve_skill(ch, spell_info[SPELL_ENERGY_DRAIN].sphere);
d1187 1
a1187 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_DESTROY_UNDEAD].sphere), 2) * 27) / 1000) + dam;
d1189 1
a1189 1
    improve_skill(ch, spell_info[SPELL_DESTROY_UNDEAD].sphere);
d1198 1
a1198 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_ICE_STORM].sphere), 2) * 1) / 100) + dam;
d1206 1
a1206 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FIRESTORM].sphere), 2) * 1) / 100) + dam;
d1217 1
a1217 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_UNHOLY_WORD].sphere), 2) * 33) / 2000) + dam;
d1228 1
a1228 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_HOLY_WORD].sphere), 2) * 33) / 2000) + dam;
d1254 1
a1254 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_STYGIAN_ERUPTION].sphere), 2) * 1) / 125) + dam;
d1256 1
a1256 1
    improve_skill(ch, spell_info[SPELL_STYGIAN_ERUPTION].sphere);
d1281 1
a1281 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_DIVINE_RAY].sphere), 2) * 1) / 125) + dam;
d1283 1
a1283 1
    improve_skill(ch, spell_info[SPELL_DIVINE_RAY].sphere);
d1320 1
a1320 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_LESSER_EXORCISM].sphere), 2) * 1) / 25) + dam;
d1330 1
a1330 1
    improve_skill(ch, spell_info[SPELL_LESSER_EXORCISM].sphere);
d1349 1
a1349 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CALL_LIGHTNING].sphere), 2) * 7) / 400) + dam;
d1351 1
a1351 1
    improve_skill(ch, spell_info[SPELL_CALL_LIGHTNING].sphere);
d1356 1
a1356 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_BIGBYS_CLENCHED_FIST].sphere), 2) * 7) / 400) + dam;
d1358 1
a1358 1
    improve_skill(ch, spell_info[SPELL_BIGBYS_CLENCHED_FIST].sphere);
d1383 1
a1383 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_HELLFIRE_BRIMSTONE].sphere), 2) * 1) / 180) + dam;
d1389 1
a1389 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_CHAIN_LIGHTNING].sphere), 2) * 1) / 125) + dam;
d1428 1
a1428 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_EXORCISM].sphere), 2) * 13) / 20) + dam;
d1438 1
a1438 1
    improve_skill(ch, spell_info[SPELL_EXORCISM].sphere);
d1442 1
a1442 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_METEORSWARM].sphere), 2) * 13) / 200) + dam;
d1450 1
a1450 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FLOOD].sphere), 2) * 13) / 200) + dam;
d1456 1
a1456 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_SUPERNOVA].sphere), 2) * 1) / 10) + dam;
d1462 1
a1462 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_ICE_SHARDS].sphere), 2) * 1) / 10) + dam;
d1468 1
a1468 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_ICEBALL].sphere), 2) * 7) / 400) + dam;
d1470 1
a1470 1
    improve_skill(ch, spell_info[SPELL_ICEBALL].sphere);
d1507 1
a1507 1
  }
d1509 4
d1561 3
d1566 2
a1567 1
}
d4953 3
a4955 2
  int skill;
  float heal_mult;
d4961 16
a4976 2
  /* Healing spells now use the associated skill for healing damage --gurlaek 12/7/1999 */
  skill = GET_SKILL(ch, SKILL_SPHERE_HEALING);
d4995 1
d5043 4
a5046 1
  improve_skill(ch, SKILL_SPHERE_HEALING);
d5399 6
@


1.34
log
@added fix to mag_affects that checks to see weather a spell is
being cast or if it's an affect from an object.  Objects will
get their skill based on the level of the object.  I.E pc/npc's
who don't have SPELL_ARMOR skill can quaff an armor potion
and get affected by an armor spell of the level of the potion.
All other mag_XXX functions can be migrated to join suit.
jbk
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.33 2000/04/30 18:14:19 rsd Exp $
d1629 1
a1629 2
    
    skill = GET_SKILL(ch, spell_info[SPELL_ICE_ARMOR].sphere);
d1658 1
a1658 1
    improve_skill(ch, spell_info[SPELL_ICE_ARMOR].sphere);
a1662 1
    skill = GET_SKILL(ch, spell_info[SPELL_NEGATE_HEAT].sphere);
d1687 1
a1687 1
    improve_skill(ch, spell_info[SPELL_NEGATE_HEAT].sphere);
a1691 1
    skill = GET_SKILL(ch, spell_info[SPELL_NEGATE_COLD].sphere);
d1716 1
a1716 1
    improve_skill(ch, spell_info[SPELL_NEGATE_COLD].sphere);    
a1720 1
    skill = GET_SKILL(ch, spell_info[SPELL_WATERFORM].sphere);
d1745 1
a1745 1
    improve_skill(ch, spell_info[SPELL_WATERFORM].sphere);    
a1761 1
    skill = GET_SKILL(ch, spell_info[SPELL_MIRAGE].sphere);
d1790 1
a1790 1
    improve_skill(ch, spell_info[SPELL_MIRAGE].sphere);
d1829 1
a1829 1
      improve_skill(ch, spell_info[SPELL_SMOKE].sphere);
d1848 1
a1848 1
    improve_skill(ch, spell_info[SPELL_SMOKE].sphere);
a1852 2
    /* oh yea, need an existing armor type spell check that might conflict with this one */

d1867 1
a1867 1
    skill = GET_SKILL(ch, spell_info[SPELL_GAIAS_CLOAK].sphere);
d1897 1
a1897 1
    improve_skill(ch, spell_info[SPELL_GAIAS_CLOAK].sphere);
d1918 1
a1918 1
      improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);      
a1926 1
    skill = GET_SKILL(ch, spell_info[SPELL_ENTANGLE].sphere);
d1934 1
a1934 1
      improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);
d1943 1
a1943 1
      improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);
d1961 1
a1961 1
	improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);
d1980 1
a1980 1
	improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);
d1999 1
a1999 1
	improve_skill(ch, spell_info[SPELL_ENTANGLE].sphere);
a2042 3
      
      skill = GET_SKILL(ch, spell_info[SPELL_BARKSKIN].sphere);

d2074 1
a2074 1
    improve_skill(ch, spell_info[SPELL_BARKSKIN].sphere);
d2087 1
a2087 1
    skill = GET_SKILL(ch, spell_info[SPELL_NIGHT_VISION].sphere);    
d2113 1
a2113 1
    improve_skill(ch, spell_info[SPELL_NIGHT_VISION].sphere);
a2136 1
      skill = GET_SKILL(ch, spell_info[SPELL_DARK_PRESENCE].sphere);    
d2188 1
a2188 1
    improve_skill(ch, spell_info[SPELL_DARK_PRESENCE].sphere);
a2192 2
    /* Needs check for armor, if armored it should return w/o success */
    
d2216 1
a2216 1
      to_vict="$n tries to wrap you in demonic skin!\r\nSilly isn't $e.";
a2228 1
      skill = GET_SKILL(ch, spell_info[SPELL_DEMONSKIN].sphere);    
d2256 1
a2256 1
    improve_skill(ch, spell_info[SPELL_DEMONSKIN].sphere);
d2271 1
a2271 1
      improve_skill(ch, spell_info[SPELL_DISEASE].sphere);
a2277 1
    skill = GET_SKILL(ch, spell_info[SPELL_DISEASE].sphere);    
d2333 1
a2333 1
    improve_skill(ch, spell_info[SPELL_DISEASE].sphere);
d2360 1
a2360 1
    improve_skill(ch, spell_info[SPELL_INSANITY].sphere);
d2375 1
a2375 1
    skill = GET_SKILL(ch, spell_info[SPELL_DEMONIC_ASPECT].sphere);    
d2427 1
a2427 1
    improve_skill(ch, spell_info[SPELL_DEMONIC_ASPECT].sphere);
d2436 1
a2436 1
    improve_skill(ch, spell_info[SPELL_DEMONIC_MUTATION].sphere);    
a2442 1
    skill = GET_SKILL(ch, spell_info[SPELL_WINGS_OF_HELL].sphere);    
d2468 1
a2468 1
    improve_skill(ch, spell_info[SPELL_WINGS_OF_HELL].sphere);
d2472 1
a2472 1
    ;
d2474 1
a2474 1
    af[0].modifier = ((pow(GET_SKILL(ch, spell_info[SPELL_VITALITY].sphere), 2)) / 40) + 50;
d2482 1
a2482 1
    improve_skill(ch, spell_info[SPELL_VITALITY].sphere);
a2488 5
    
/*      if(!IS_NPC(ch)) { */
/*        sprintf(buf, "hitpoints: %d duration: %d", af[0].modifier, af[0].duration); */
/*        log(buf); */
/*      } */
a2494 1
    skill = GET_SKILL(ch, spell_info[SPELL_WINGS_OF_HEAVEN].sphere);    
d2520 1
a2520 1
    improve_skill(ch, spell_info[SPELL_WINGS_OF_HEAVEN].sphere); 
a2524 1
    skill = GET_SKILL(ch, spell_info[SPELL_SPEAK_IN_TONGUES].sphere);    
d2546 1
a2546 1
    improve_skill(ch, spell_info[SPELL_SPEAK_IN_TONGUES].sphere);
a2571 1
    skill = GET_SKILL(ch, spell_info[SPELL_ELEMENTAL_WARDING].sphere);    
d2590 1
a2590 1
    improve_skill(ch, spell_info[SPELL_ELEMENTAL_WARDING].sphere);     
d2597 1
a2597 1
    skill = GET_SKILL(ch, spell_info[SPELL_PRAYER].sphere);    
d2648 1
a2648 1
    improve_skill(ch, spell_info[SPELL_PRAYER].sphere);
a2652 1
    skill = GET_SKILL(ch, spell_info[SPELL_MAGIC_TORCH].sphere);    
d2674 1
a2674 1
    improve_skill(ch, spell_info[SPELL_MAGIC_TORCH].sphere);    
a2678 1
    skill = GET_SKILL(ch, spell_info[SPELL_CIRCLE_OF_LIGHT].sphere);    
d2700 1
a2700 1
    improve_skill(ch, spell_info[SPELL_CIRCLE_OF_LIGHT].sphere);
d2715 1
a2715 1
      improve_skill(ch, spell_info[SPELL_FEAR].sphere);      
d2718 1
a2718 1
    skill = GET_SKILL(ch, spell_info[SPELL_FEAR].sphere);    
d2756 1
a2756 1
    improve_skill(ch, spell_info[SPELL_FEAR].sphere);
d2774 1
a2774 1
    skill = GET_SKILL(ch, spell_info[SPELL_HARNESS].sphere);    
d2797 1
a2797 1
    improve_skill(ch, spell_info[SPELL_HARNESS].sphere);
a2812 1
    skill = GET_SKILL(ch, spell_info[SPELL_MINOR_GLOBE].sphere);    
d2834 1
a2834 1
    improve_skill(ch, spell_info[SPELL_MINOR_GLOBE].sphere);
d2849 1
a2849 1
    skill = GET_SKILL(ch, spell_info[SPELL_MAJOR_GLOBE].sphere);    
d2871 1
a2871 1
    improve_skill(ch, spell_info[SPELL_MAJOR_GLOBE].sphere);
d2880 1
a2880 1
    skill = GET_SKILL(ch, spell_info[SPELL_COLDSHIELD].sphere);    
d2902 1
a2902 1
    improve_skill(ch, spell_info[SPELL_COLDSHIELD].sphere);
d2911 1
a2911 1
    skill = GET_SKILL(ch, spell_info[SPELL_FIRESHIELD].sphere);    
d2933 1
a2933 1
    improve_skill(ch, spell_info[SPELL_FIRESHIELD].sphere);
d2948 1
a2948 1
      improve_skill(ch, spell_info[SPELL_MINOR_PARALYSIS].sphere);
a2951 1
    skill = GET_SKILL(ch, spell_info[SPELL_MINOR_PARALYSIS].sphere);    
d2974 1
a2974 1
    improve_skill(ch, spell_info[SPELL_MINOR_PARALYSIS].sphere);
d2999 1
a2999 1
      improve_skill(ch, spell_info[SPELL_RAY_OF_ENFEEB].sphere);
d3002 1
a3002 1
    skill = GET_SKILL(ch, spell_info[SPELL_RAY_OF_ENFEEB].sphere);    
d3033 1
a3033 1
    improve_skill(ch, spell_info[SPELL_RAY_OF_ENFEEB].sphere);
a3037 1
    skill = GET_SKILL(ch, spell_info[SPELL_LEVITATE].sphere);    
d3058 1
a3058 1
    improve_skill(ch, spell_info[SPELL_LEVITATE].sphere);
a3073 1
      skill = GET_SKILL(ch, spell_info[SPELL_CHILL_TOUCH].sphere);    
d3102 1
a3102 1
    improve_skill(ch, spell_info[SPELL_CHILL_TOUCH].sphere);
d3173 1
a3173 1
    skill = GET_SKILL(ch, spell_info[SPELL_SILENCE].sphere);    
d3195 1
a3195 1
    improve_skill(ch, spell_info[SPELL_SILENCE].sphere);
a3199 1
    skill = GET_SKILL(ch, spell_info[SPELL_SOULSHIELD].sphere);    
d3235 1
a3235 1
    improve_skill(ch, spell_info[SPELL_SOULSHIELD].sphere);
a3250 1
    skill = GET_SKILL(ch, spell_info[SPELL_REDUCE].sphere);    
d3284 1
a3284 1
    improve_skill(ch, spell_info[SPELL_REDUCE].sphere);
a3298 1
    skill = GET_SKILL(ch, spell_info[SPELL_ENLARGE].sphere);    
d3331 1
a3331 1
    improve_skill(ch, spell_info[SPELL_ENLARGE].sphere); 
d3348 1
a3348 1
    improve_skill(ch, spell_info[SPELL_STONE_SKIN].sphere);    
a3352 1
    skill = GET_SKILL(ch, spell_info[SPELL_HASTE].sphere);    
d3374 1
a3374 1
    improve_skill(ch, spell_info[SPELL_HASTE].sphere);
a3378 1
    skill = GET_SKILL(ch, spell_info[SPELL_BLUR].sphere);    
d3395 1
a3395 1
    improve_skill(ch, spell_info[SPELL_BLUR].sphere);
a3399 1
    skill = GET_SKILL(ch, spell_info[SPELL_COMPREHEND_LANG].sphere);    
d3420 1
a3420 1
    improve_skill(ch, spell_info[SPELL_COMPREHEND_LANG].sphere);
d3433 1
a3433 1
    skill = GET_SKILL(ch, spell_info[SPELL_BLESS].sphere);    
d3472 1
a3472 1
    improve_skill(ch, spell_info[SPELL_BLESS].sphere);    
d3512 1
a3512 1
    improve_skill(ch, spell_info[SPELL_SUNRAY].sphere);
d3552 1
a3552 1
    improve_skill(ch, spell_info[SPELL_BLINDNESS].sphere);
d3570 1
a3570 1
    skill = GET_SKILL(ch, spell_info[SPELL_CURSE].sphere);    
d3652 1
a3652 1
    improve_skill(ch, spell_info[SPELL_CURSE].sphere);
a3656 1
    skill = GET_SKILL(ch, spell_info[SPELL_DETECT_ALIGN].sphere);    
d3678 1
a3678 1
    improve_skill(ch, spell_info[SPELL_DETECT_ALIGN].sphere);
a3682 1
    skill = GET_SKILL(ch, spell_info[SPELL_DETECT_INVIS].sphere);    
d3702 1
a3702 1
    improve_skill(ch, spell_info[SPELL_DETECT_INVIS].sphere);
a3706 1
    skill = GET_SKILL(ch, spell_info[SPELL_DETECT_MAGIC].sphere);    
d3726 1
a3726 1
    improve_skill(ch, spell_info[SPELL_DETECT_MAGIC].sphere);
d3748 1
a3748 1
    skill = GET_SKILL(ch, spell_info[SPELL_INFRAVISION].sphere);    
d3770 1
a3770 1
    improve_skill(ch, spell_info[SPELL_INFRAVISION].sphere);
d3777 1
a3777 1
    skill = GET_SKILL(ch, spell_info[SPELL_INVISIBLE].sphere);    
d3800 1
a3800 1
    improve_skill(ch, spell_info[SPELL_INVISIBLE].sphere);
a3807 1
    skill = GET_SKILL(ch, spell_info[SPELL_CONCEALMENT].sphere);    
d3830 1
a3830 1
    improve_skill(ch, spell_info[SPELL_CONCEALMENT].sphere);
a3846 1
    skill = GET_SKILL(ch, spell_info[SPELL_POISON].sphere);    
d3873 1
a3873 1
    improve_skill(ch, spell_info[SPELL_POISON].sphere);
a3888 1
    skill = GET_SKILL(ch, spell_info[SPELL_PROT_FROM_EVIL].sphere);    
d3908 1
a3908 1
    improve_skill(ch, spell_info[SPELL_PROT_FROM_EVIL].sphere);
a3951 1
    skill = GET_SKILL(ch, spell_info[SPELL_SLEEP].sphere);    
d3977 1
a3977 1
    improve_skill(ch, spell_info[SPELL_SLEEP].sphere);
a3985 1
    skill = GET_SKILL(ch, spell_info[SPELL_STRENGTH].sphere);    
d4012 1
a4012 1
    improve_skill(ch, spell_info[SPELL_STRENGTH].sphere);    
a4025 1
    skill = GET_SKILL(ch, spell_info[SPELL_SENSE_LIFE].sphere);    
d4046 1
a4046 1
    improve_skill(ch, spell_info[SPELL_SENSE_LIFE].sphere);    
a4050 1
    skill = GET_SKILL(ch, spell_info[SPELL_WATERWALK].sphere);    
d4071 1
a4071 1
    improve_skill(ch, spell_info[SPELL_WATERWALK].sphere);
a4075 1
    skill = GET_SKILL(ch, spell_info[SPELL_FLY].sphere);    
d4097 1
a4097 1
    improve_skill(ch, spell_info[SPELL_FLY].sphere);
a4101 1
    skill = GET_SKILL(ch, spell_info[SPELL_FARSEE].sphere);    
d4122 1
a4122 1
    improve_skill(ch, spell_info[SPELL_FARSEE].sphere);
d4137 1
a4137 1
      skill = GET_SKILL(ch, spell_info[SPELL_UNHOLY_WORD].sphere);    
d5357 9
@


1.33
log
@bless no longer has an alignement check, it does have a dark
presence check though, and dark presence has a bless check.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.32 2000/04/15 23:12:03 rsd Exp $
d1569 1
a1569 1
    refresh=TRUE;
d1596 11
a1606 5
  /*
    	 act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	 act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
    	 act(to_room, TRUE, victim, 0, ch, TO_ROOM);
  */
a3157 2

    skill = GET_SKILL(ch, spell_info[SPELL_ARMOR].sphere);    
d3179 2
a3180 1
    improve_skill(ch, spell_info[SPELL_ARMOR].sphere);   
d4231 4
d5406 4
@


1.32
log
@fixed damage algorythm for flood and meteorswarm added
iceshards and supernova...
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.31 2000/04/14 00:55:49 rsd Exp $
a2121 2
    
    /* Need a bless check to exclude this spell and bless at the same time */
d2123 8
d3457 6
a3462 10
    /* Need a Dark Presence check so both spells can't be on the same player */

    /* Alignement Checks! */
    if (GET_ALIGNMENT(victim) <= 350) {
      to_char="You can't protect a good ally if they are EVIL!";
      to_vict="$n tries to inspire your inner angel.\r\nSilly isn't $e.";
      to_room="$n fails to inspire $N's inner angel. DUH!";  
      act(to_char, FALSE, ch, 0, victim, TO_CHAR);
      act(to_vict, FALSE, ch, 0, victim, TO_VICT);
      act(to_room, TRUE, ch, 0, victim, TO_NOTVICT);
d3464 2
a3465 3
    } else
      
      skill = GET_SKILL(ch, spell_info[SPELL_BLESS].sphere);    
d5397 4
@


1.31
log
@altered a few spells
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.30 2000/04/09 22:32:24 rsd Exp $
d1427 1
a1427 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_METEORSWARM].sphere), 2) * 1) / 125) + dam;
d1429 2
d1435 1
a1435 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_FLOOD].sphere), 2) * 1) / 125) + dam;
d1439 12
d5396 3
@


1.30
log
@altered a buncha act buffers to try to get the spell messaging
done properly.  Also altered the order of ch and victim in
the catch all buffers for the order changed in the act()'s
for mag_affects().
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.29 2000/04/08 08:41:23 rsd Exp $
a23 2


d896 1
a896 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_SHOCKING_GRASP].sphere), 2) * 3) / 100) + dam;
d1431 6
d5382 6
@


1.29
log
@altered prayer to have float math to return expected values.
altered shocking grasp to actually reference the proper
sphere to calculate damage, also made it to the 2nd power
instead of the typoed 7th. Changed about a kabillion act()
statements to make more sense I hope.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.28 2000/04/05 06:35:34 rsd Exp $
d709 3
a711 1
  
a1553 1
  
d1826 2
a1827 2
    to_room = "&9&b$n&9&b is blinded by $N's&9&b column of smoke!&0";
    to_vict = "&9You have been blinded by $N's&9&b column of smoke&0";
d1916 1
a1916 1
      to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
d1925 1
a1925 1
      to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
d1935 1
a1935 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
d1943 1
a1943 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
d1954 1
a1954 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
d1962 1
a1962 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
d1973 1
a1973 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
d1981 1
a1981 1
	to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
d2060 1
a2060 1
    to_room="&3$n's&3 skin hardens to bark.&0";
d2126 1
a2126 1
      to_room="$N siezes up in pain!\r\n $N grabs $n who is surrounded by a dark presence.";
d2133 1
a2133 1
      to_room="$N siezes up in pain!\r\n $N grabs $n who is surrounded by a dark presence.";
d2143 1
a2143 1
      to_room="$N siezes up in pain!\r\n $N grabs $n who is enraged by a dark presence.";      
d2153 1
a2153 1
      to_room="$N siezes up in pain!\r\n $N grabs $n who is enraged by a dark presence.";
d2163 1
a2163 1
      to_room="$N siezes up in pain!\r\n $N grabs $n who is enraged by a dark presence.";
d2240 1
a2240 1
    to_room="&1$n's&1 skin toughens into a dark red hide.&0";
d2317 2
a2318 2
    to_vict="&3You choke and gasp on $N's foul air as a sick feeling overtakes you. You feel seriously ill!&0";
    to_room="&3$n&3 chokes and gasps on $N's foul air, $e looks seriously ill!";
d2345 1
a2345 1
    to_room="&5$n's&5 psyche snaps... A crazed gleam fills $s eyes.&0";
d2420 1
a2420 1
    send_to_char("You cannot seem to grasp the nature of the demon.\r\n",ch);
d2584 1
a2584 1
    to_room="&7&b$n&7&b glows briefly.&0";
d2642 1
a2642 1
    to_room="$n perks up, looking full of life.";
d2696 1
a2696 1
    to_room="&7&bA bright white circle of light appears over $n's&7&b head.";
d2752 1
a2752 1
    to_room="$N sneaks up on $n and &9&ba look of terror sweeps over $s&9&b face!&0\r\n$N throws back $S head and cackles with insane glee!";
d2831 1
a2831 1
    to_room="&1A shimmering globe wraps around $n&0&1's body.&0";
d2868 1
a2868 1
    to_room="&1&bA shimmering globe of force wraps around $n&1&b's body.&0";
d2899 1
a2899 1
    to_room="&4A jagged formation of i&bc&7e sh&4ard&0&4s form around $n&0&4.&0";
d2930 1
a2930 1
    to_room="&1A burning shield of f&bi&3r&7e&0&1 explodes from $n&0&1's body!&0";
d2972 1
a2972 1
    to_room="&7&bAll motion in $n&7&b's body grinds to a halt.&0";    
d3031 1
a3031 1
    to_room="$n turns pale and starts to sag.";
d3057 1
a3057 1
    to_room="&6$n&0&6 floats up into the air.&0";
d3101 2
a3102 2
    to_char = "$n is withered by your cold!";
    to_room = "$n withers slightly from $N's cold!";
d3150 1
a3150 1
    to_room = "$N calls upon $S gods to protect $n.";
d3196 1
a3196 1
    to_room = "&0$n&7 squeaks as all sound is squelched from $s throat.&0";
d3225 1
a3225 1
      to_room = "&3&bA bright golden aura surrounds $n's body!&0";
d3229 1
a3229 1
      to_room = "&1&bA &0&1dark red&b aura engulfs $n's body!&0";
d3233 1
a3233 1
      to_room = "A brief aura surrounds $n, then fades.";
d3287 1
a3287 1
    to_room = "&1&b$n's skin ripples as $e shrinks to twice $m normal size!&0";
d3335 1
a3335 1
    to_room = "&9&b$n's skin ripples as $e enlarges to twice $m normal size!&0";
d3352 1
a3352 1
    to_room = "&9&b$n's skin hardens and turns to stone!&0";
d3379 1
a3379 1
    to_room = "&1$n starts to move with uncanny speed!&0";
d3401 1
a3401 1
    to_room = "&7$n's image blurs in unnatural speed!&0";
d3426 1
a3426 1
    to_room="&7&b$n&7&b glows briefly.&0";
d3483 2
a3484 2
    to_vict = "Your inner angel is inspired by $N.\r\nYou feel righteous.";
    to_room = "$n is inspired to do good by $N.";    
d3523 1
a3523 1
    to_room = "&9&b$n&9&b seems to be blinded!&0";
d3563 1
a3563 1
    to_room = "&9&b$n&9&b is blinded by $N!&0";
d3663 1
a3663 1
    to_room = "$n briefly glows red!";
d3690 1
a3690 1
    to_room="&7&b$n&7&b glows briefly.&0";
d3785 1
a3785 1
    to_room = "$n's eyes glow red.";
d3815 1
a3815 1
    to_room = "$n slowly fades out of existence.";
d3846 1
a3846 1
    to_room = "&9&b$n&9&b slowly fades out of existence.&0";
d3890 1
a3890 1
    to_room = "$n gets violently ill!";
d4031 1
a4031 1
    to_room = "$n looks stronger!";
d4067 1
a4067 1
    to_room = "$n seems more aware of $s surroundings.";
d4092 1
a4092 1
    to_room = "$n sprouts webbing between $s toes!";
d4120 1
a4120 1
    to_room = "&6&b$n lifts into the air.&0";
d4146 1
a4146 1
    to_room = "$n's pupils dilate rapidly for a second.";
d4150 1
a4150 1
  case SPELL_UNHOLY_WORD:
d4152 2
d4185 3
a4187 3
	to_char = "&9&b$n&9&b is blinded and paralyzed by you!&0";
	to_room = "&9&b$n&9&b is blinded by $N!&0\r\n&9&b$n&9&b is stopped in $s tracks by $N!&0";
	to_vict = "&9You have been blinded and paralyzed by $N's mighty word of power!&0";
d4197 3
a4199 3
	to_char = "&9&b$n&9&b is blinded! by you!&0";
	to_room = "&9&b$n&9&b is blinded by $N!&0";
	to_vict = "&9You have been blinded by $N's mighty word of power!&0";
d4242 6
a4247 6
       if (to_char != NULL)
	 act(to_char, FALSE, ch, 0, victim, TO_CHAR);
       if (to_vict != NULL)
	 act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
       if (to_room != NULL)
	 act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d5378 7
@


1.28
log
@added 1 kabillion more spells into the spell system.
lalala.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.27 2000/04/02 02:39:39 rsd Exp $
d886 1
a886 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d896 1
a896 1
    new_dam = ((pow(GET_SKILL(ch, spell_info[SPELL_WRITHING_WEEDS].sphere), 7) * 1000) / 10000) + dam;
d927 2
a928 2
      to_char = "The gods protect $n.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d937 1
a937 1
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d964 2
a965 2
      to_char = "The gods protect $n.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d968 1
a968 1
      to_room = "$n leers at $N as $M tries to rot $e good.";
d974 1
a974 1
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
a999 8
    if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS)) {
      to_char = "What?! Are you crazy casting that INSIDE?!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "The ground shakes violently!\r\n$N barely changes $E mind in time to not kill you all.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
      dam = 0;      
      return;
    }    
d1016 1
a1024 4
      to_char = "What?! Are you crazy casting that INSIDE?!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "The ground shakes violently!\r\n$N barely changes $E mind in time to not kill you all.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
a1031 1
    case SECT_UNDERDARK:
a1034 4
      to_char = "Quake the earth? What earth? There's no ground here anywhere.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_room = "$N hunches over and grunts loudly!";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1043 2
a1044 2
      to_char = "$n doesn't care that you are making the ground shake.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d1046 1
a1046 1
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
d1056 2
a1057 2
      to_char = "$n doesn't care that you are making the ground shake.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d1059 2
a1060 2
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "$n manages to keep $e feet.";
d1324 2
a1325 2
      to_room = "$N rubs $S socks on the carpet looking for sparks.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1552 1
d1592 2
a1593 2
      to_room = "$N looks a little over protective.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1735 2
a1736 2
      to_room = "$N looks a little over protective.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1781 4
a1784 4
      to_vict = "&9&bYou&9&b resist $N's&9&b column of smoke!&0";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room = "&9&b$n&9&b resists $N's&9&b column of smoke!&0";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);     
d1803 6
a1808 6
      to_char = "You temporarily choke $n with your column of smoke.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      to_vict = "&9You have been temporarily choked by $N's&9&b column of smoke!&0";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);      
      to_room = "&9&b$n&9&b is slightly choked by $N's&9&b column of smoke!&0";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT); 
d1827 1
a1827 1
    to_char = "&9&b$n&9&b is blinded by your column of smoke!&0";
d1839 2
a1840 2
      to_room = "$N looks a little over protective.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1894 2
a1895 2
      to_char="&2&bYour crop of ripe vines search in vain for $n.&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d1897 3
a1899 3
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room="&2&bA crop of ripe vines searches in vain for $n.&0";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d1914 1
a1914 1
      to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $n!&0";
d1923 1
a1923 1
      to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $n!&0";
d1933 1
a1933 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $n!&0";
d1941 1
a1941 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $n!&0";
d1952 1
a1952 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $n!&0";
d1960 1
a1960 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $n!&0";
d1971 1
a1971 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, entangling $n!&0";
d1979 1
a1979 1
	to_char="&2&bYour crop of thick branches and vines burst from the ground, partially entangling $n!&0";
d2012 2
a2013 2
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2015 2
a2016 2
	to_char = "$n seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d2018 3
a2020 3
	act(to_vict, FALSE, victim, 0, ch, TO_VICT);
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2057 1
a2057 1
    to_char="&3$n's&3 skin hardens to bark.&0";
d2068 2
a2069 2
      to_room = "$N looks a little over protective.";
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2110 4
a2113 4
      to_vict="$N tries to enrage your inner demon.\r\nSilly isn't $E.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room="$N fails to enrage $n's inner demon.";
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2123 1
a2123 1
      to_char="You summon allegiance from your dark gods to protect $n."; 
d2130 1
a2130 1
      to_char="You summon allegiance from your dark gods to protect $n."; 
d2140 1
a2140 1
      to_char="You summon allegiance from your dark gods to protect and enrage $n."; 
d2150 1
a2150 1
      to_char="You summon allegiance from your dark gods to protect and enrage $n."; 
d2160 1
a2160 1
      to_char="You summon allegiance from your dark gods to protect and enrage $n."; 
d2181 2
a2182 2
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2184 2
a2185 2
	to_char = "$n seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d2187 3
a2189 3
	act(to_vict, FALSE, victim, 0, ch, TO_VICT);
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2199 4
a2202 4
      to_vict="$N tries to wrap you in demonic skin!\r\nSilly isn't $E.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      to_room="$N fails to wrap $n is a demonic skin of protection.";  
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2249 6
a2254 6
      to_vict="You resist $N's foul incantation!";
      to_room="$n holds $e breath avoiding $N's diseased air!";
      to_char="$n resists your disease!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2315 1
a2315 1
    to_char="Your diseased air infects $n!";
d2327 6
a2332 6
      to_char="$n has to strong a will to drive insane!";
      to_vict="Your strength of will protects you from an insane suggestion from $N... This time...";
      to_room="$n resists going insane at $N beckon.";      
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2342 1
a2342 1
    to_char="You cause &5$n to snap... A crazed gleam fills $s eyes.&0";
d2352 6
a2357 6
      to_char="$n doesn't seem to have an inner demon.";
      to_vict="$N tries to inflict a demon upon you.\r\nSilly isn't $E.";
      to_room="$N fails to make $n more of a demon.";  
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2600 1
a2600 1
      af[1].modifier = (int)((GET_LEVEL(ch) / 3) * (GET_ALIGNMENT(ch) / 1000));
d2608 1
a2608 1
      af[1].modifier = (int)((GET_LEVEL(ch) / 2) * (GET_ALIGNMENT(ch) / 1000));
d2616 1
a2616 1
      af[1].modifier = (int)((GET_LEVEL(ch) / 2) * (GET_ALIGNMENT(ch) / 1000));
d2624 1
a2624 1
      af[1].modifier = (int)(GET_LEVEL(ch) * (GET_ALIGNMENT(ch) / 1000));  
d2632 1
a2632 1
      af[1].modifier = (int)(GET_LEVEL(ch) * (GET_ALIGNMENT(ch) / 1000));
d2705 6
a2710 6
      to_char="$n has to strong a will to scare!";
      to_vict="Your strength of will protects you from a fearful suggestion from $N... This time...";
      to_room="$n isn't scared of $N. Nyah!";      
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2751 1
a2751 1
    to_room="$N sneaks up on $n and &9&ba look of terror sweeps over $n&9&b's face!&0\r\n$N throws back $S head and cackles with insane glee!";
d2799 6
a2804 6
      to_char = "$n's globe of invulnerability resists your spell!";
      to_vict = "Your globe of invulnerability resists $N's spell.";
      to_room = "$N tries to add an additional globe of protection to $n.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2837 6
a2842 6
      to_char = "$n's minor globe of invulnerability resists your spell!";
      to_vict = "Your minor globe of invulnerability resists $N's spell.";
      to_room = "$N tries to add an additional globe of protection to $n.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2939 6
a2944 6
      to_char="&n resists your weak paralysis.";
      to_vict="&7&b$N tries to paralize you but fails!&0";
      to_room="&7&b$N squints at $n but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2969 1
a2969 1
    to_char="You paralyze $n! WooHoo!";
d2981 6
a2986 6
      to_char="&n is already feeble enough dammit.";
      to_vict="$N seems to be looking at you funny.";
      to_room="&7&b$N squints at $n but nothing happens.&0"; 
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d2991 6
a2996 6
      to_vict="$N tries to drain your strength but you resist!";
      to_char="&n resists your feeble attempt!";
      to_room="&7&b$N squints at $n but nothing happens.&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3063 6
a3068 6
      to_vict = "You resist $N's withering affects!";	
      to_char = "$n resists your withering affect!";
      to_room = "$n resists $N's withering affect!";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3115 1
a3115 1
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3117 2
a3118 2
	to_char = "$n seems to be protected enough already!";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d3120 3
a3122 3
	act(to_vict, FALSE, victim, 0, ch, TO_VICT);
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3149 1
a3149 1
    to_room = "$N calls upon $E gods to protect $n.";
d3165 6
a3170 6
      to_char="$n resists your pitiful attempt to silence $s.";
      to_vict="&7&b$N tries to silence you but fails!&0";
      to_room="&7&b$N squints at $n but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3193 1
a3193 1
    to_char="You silence $n!";    
d3233 2
a3234 2
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3245 1
a3245 1
      to_room = "&1&b$n looks slightly confused about his place in the world.&0";
d3247 1
a3247 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3294 1
a3294 1
      to_room = "&1&b$n looks slightly confused about his place in the world.&0";
d3296 1
a3296 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3349 1
a3349 1
    to_char = "&9&b$n's skin hardens and turns to stone!&0";
d3376 1
a3376 1
    to_char = "&1$n starts to move with uncanny speed!&0";
d3437 5
a3441 5
      to_vict="$N tries to inspire your inner angel.\r\nSilly isn't $E.";
      to_room="$N fails to inspire $n's inner angel. DUH!";  
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3481 1
a3481 1
    to_char = "$n is inspired by your gods.";
d3499 6
a3504 6
      to_char="$n resists your pitiful attempt to blind $s.";
      to_vict="&7&b$N tries to blind you but fails!&0";
      to_room="&7&b$N directs the rays of the sun at $n but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3521 1
a3521 1
    to_char = "&9You have blinded $n with your sunray!&0";
d3539 6
a3544 6
      to_char="$n resists your pitiful attempt to blind $s.";
      to_vict="&7&b$N tries to blind you but fails!&0";
      to_room="&7&b$N tries to blind $n but nothing happens.&0";    
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3561 1
a3561 1
    to_char = "&9&b$n&9&b is blinded! by you!&0";
d3571 4
a3574 5
      to_vict="&7&b$N tries to curse you but fails!&0";
      to_room="&7&b$N squints at $n but nothing happens.&0";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3661 1
a3661 1
    to_char = "You curse $n! Muahahah!";
d3688 1
a3688 1
    to_char = "$n can determine alignment.";
d3750 2
a3751 2
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3753 2
a3754 2
	to_char = "$n seems to be able to sort of see enough already.";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d3756 3
a3758 3
	act(to_vict, FALSE, victim, 0, ch, TO_VICT);
	to_room = "$N looks a little over protective.";
	act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3782 1
a3782 1
    to_char = "$n's eyes glow red.";
d3855 4
a3858 4
      to_vict = "You dodge $N's attempt to prick you!";
      to_room = "$n dodges $N's attempt to prick $m";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3898 5
a3902 5
      to_vict="$N tries to protect you from evil!\r\nSilly isn't $E.";
      to_room="$N fails to protect $n from evil. DUH";  
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d3952 4
a3955 4
      to_vict = "$N can sing all $E wants, you aren't going to sleep.";
      to_room = "$N tries to sing $n to sleep, but to no avail, uh oh.";
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
      act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d4066 1
a4066 1
    to_room = "$n seems more aware of $e surroundings.";
d4091 1
a4091 1
    to_room = "$n sprouts webbing between $e toes!";
d4152 4
a4155 4
      to_vict = "You resist most of $N's word of power.";	
      to_char = "$n resists your word of power's side affects.";
      act(to_char, FALSE, ch, 0, 0, TO_CHAR);
      act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
d4164 4
a4167 4
	to_vict = "You resist most of $N's word of power.";	
	to_char = "$n resists your word of power's side affects.";
	act(to_char, FALSE, ch, 0, 0, TO_CHAR);
	act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
d4235 2
d4244 1
a4244 1
	 act(to_room, TRUE, victim, 0, ch, TO_NOTVICT);
d4372 1
d4382 19
d5375 4
@


1.27
log
@changed the to_room act in most spells to be TO_NOTVICT as
I think was the intent in most cases.  Also added and
integrated the spell system up through all 4th circle
spells.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.26 2000/03/31 23:46:37 rsd Exp $
d24 2
d693 2
a694 2
  /* Declarations to use the skill system to vary spell results RSD 3/25/00 
     int skill; */
d900 25
d1100 37
d1138 37
a1174 2
    if (GET_LEVEL(victim) <= 2)
      dam = 100;
a1176 1
    dam = dice(4, 50) + 30;
d1182 103
a1284 15
    break;   
  case SPELL_VAMPIRIC_BREATH:
    if (GET_LEVEL(ch) < 20)
      dam = dice(1, 20);
    if (GET_LEVEL(victim) >= 20 && GET_LEVEL(victim) < 40)
      dam = dice(2, 35);
    if (GET_LEVEL(victim) >= 40 && GET_LEVEL(victim) < 60)
      dam = dice(2, 50);
    if (GET_LEVEL(victim) >= 60 && GET_LEVEL(victim) < 80)
      dam = dice(2, 70);
    if (GET_LEVEL(victim) >= 80 && GET_LEVEL(victim) < 95)
      dam = dice(2, 100);
    if (GET_LEVEL(victim) >= 95 && GET_LEVEL(victim) < 99)
      dam = dice(3, 90);
    GET_HIT(ch) = GET_HIT(ch) + dam;
d1286 1
a1286 1
  case SPELL_EXORCISM:
d1288 1
a1288 1
      send_to_char("That spell only has effect on demonic entities.\r\n",ch);
d1291 1
a1291 2
    if(GET_LEVEL(victim) < 40 && !mag_savingthrow(victim,SAVING_SPELL)
       && number(1,100) > 70) {
d1299 88
a1386 1
    dam = 15 * GET_LEVEL(ch);
d1388 7
a1394 1
  case SPELL_LESSER_EXORCISM:
d1396 1
a1396 1
      send_to_char("That spell only has effect on demonic entities.\r\n",ch);
d1399 1
a1399 2
    if(GET_LEVEL(victim) < 30 && !mag_savingthrow(victim,SAVING_SPELL)
       && number(1,100) > 50) {
d1407 60
a1466 1
    dam = 10 * GET_LEVEL(ch);
a1485 9
  case SPELL_UNHOLY_WORD:
    dam = dice(10,20) + (GET_LEVEL(ch)*2);
    break;
  case SPELL_HOLY_WORD:
    if (GET_CLASS(ch) == CLASS_PRIEST)
      dam = dice(15,30) + (GET_LEVEL(ch)*2);
    else
      dam = dice(10,20) + (GET_LEVEL(ch)*2);
    break;
d1569 1
d1572 2
d1789 4
d1898 5
d2259 4
a2262 1

d2337 4
a2340 1

d2715 4
d2949 4
a2952 1

d2991 4
a2994 1

d3169 4
a3172 1

d3503 4
a3506 1

d3547 5
d3594 4
d3866 4
d3960 1
d4164 53
d4218 1
a4218 1
  }
d5049 1
d5369 6
@


1.26
log
@integrated more spells into the skill system with improve
skill calls. Also comeplted more spells. in mag_damage().
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.25 2000/03/31 00:16:10 rsd Exp $
d685 1
a685 1
  float dam_mult = 0;
d905 1
a905 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d914 1
a914 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d919 1
a919 1
      if (GET_CLASS(ch) == CLASS_PRIEST) {	
d942 1
a942 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d951 1
a951 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1037 1
a1037 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1050 1
a1050 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1056 17
d1465 1
a1465 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);     
d1489 1
a1489 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM); 
d1575 1
a1575 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1696 1
a1696 1
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1789 1
a1789 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1865 1
a1865 1
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1878 1
a1878 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d1927 1
a1927 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2002 1
a2002 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2027 1
a2027 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2376 1
a2376 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2415 1
a2415 1
    to_char="You scare the bejeezus outta $n! Muahahaha!";
d2470 1
a2470 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2508 1
a2508 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2607 1
a2607 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2646 1
a2646 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2656 1
a2656 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2728 1
a2728 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2782 1
a2782 1
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d2827 1
a2827 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3098 1
a3098 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3158 1
a3158 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3193 1
a3193 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3224 1
a3224 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3404 1
a3404 1
	act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3500 1
a3500 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3544 1
a3544 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3596 1
a3596 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d3826 1
a3826 1
	 act(to_char, FALSE, ch, 0, 0, TO_CHAR);
d3830 1
a3830 1
	 act(to_room, TRUE, victim, 0, ch, TO_ROOM);
d4940 4
@


1.25
log
@added a few variables to mag_damage() to make the use of the
spell system doable. Also changed how damage was assigned
to be proper for the intent for the first few spells.
Note that spells are becomeing significantly more potent,
maybe to much so, ptesting will get it figured out. This should
get all spells up through 3rd circle into the spell system.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.24 2000/03/30 05:45:54 rsd Exp $
d686 4
d694 1
a694 1
  //  char *to_vict = NULL;
d696 1
a696 1
  //  char *to_char = NULL;
d822 1
a822 1
    improve_skill(ch, spell_info[SPELL_CHILL_TOUCH].sphere);
a897 60
  case SPELL_EXORCISM:
    if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
      send_to_char("That spell only has effect on demonic entities.\r\n",ch);
      return;
    }
    if(GET_LEVEL(victim) < 40 && !mag_savingthrow(victim,SAVING_SPELL)
       && number(1,100) > 70) {
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
      if(FIGHTING(victim))
	stop_fighting(victim);
      extract_char(victim);
      return;
    }
    dam = 15 * GET_LEVEL(ch);
    break;
  case SPELL_LESSER_EXORCISM:
    if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
      send_to_char("That spell only has effect on demonic entities.\r\n",ch);
      return;
    }
    if(GET_LEVEL(victim) < 30 && !mag_savingthrow(victim,SAVING_SPELL)
       && number(1,100) > 50) {
      act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
      act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
      if(FIGHTING(victim))
	stop_fighting(victim);
      extract_char(victim);
      return;
    }
    dam = 10 * GET_LEVEL(ch);
    break;
    /* reason i put these breaths here is because prokys structure does not
       go above MAX_SPELLS. Nechtrous*/
  case SPELL_FIRE_BREATH:
    dam = dice(10,10)+250;
    break;
  case SPELL_FROST_BREATH:
    dam = dice(10,10)+250;
    break;
  case SPELL_GAS_BREATH:
    dam = dice(10,10)+250;
    break;
  case SPELL_LIGHTNING_BREATH:
    dam = dice(10,10)+350;
    break;
  case SPELL_ACID_BREATH:
    dam = dice(10,10)+200;
    break;
    
  case SPELL_UNHOLY_WORD:
    dam = dice(10,20) + (GET_LEVEL(ch)*2);
    break;
  case SPELL_HOLY_WORD:
    if (GET_CLASS(ch) == CLASS_PRIEST)
      dam = dice(15,30) + (GET_LEVEL(ch)*2);
    else
      dam = dice(10,20) + (GET_LEVEL(ch)*2);
    break;
    
d900 6
a905 1
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
d909 6
a914 1
      act("Yea right there fancy pants. $N doesn't seem to care.", FALSE, ch, 0, victim, TO_CHAR);
d918 1
d921 1
a921 1
	  dam = dice(4,10);
d923 1
a923 1
	  dam = dice(5,10);
d926 1
a926 1
	dam = dice(3,10);
d928 1
a928 1
	dam = dice(4,10);
d931 3
d937 6
a942 1
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
d946 6
a951 1
      act("Yea right there fancy pants. $N doesn't seem to care.", FALSE, ch, 0, victim, TO_CHAR);
d955 1
d958 1
a958 2
	  dam = dice(4,10);
	  
d960 1
a960 2
	  dam = dice(5,10);
	  
d963 1
a963 2
	dam = dice(3,10);
	
d965 1
a965 2
	dam = dice(4,10);
	
d968 87
a1055 1
    
a1059 1
    
d1063 1
a1063 2
      act("$N has far too much life for you to harm it!",
	  FALSE,ch,0,victim,TO_CHAR);
d1083 59
a1143 3
  case SPELL_EARTHQUAKE:
    ;/*put affect here some time*/
    break;
d1448 1
a1448 1
      act(to_room, TRUE, victim, 0, ch, TO_ROOM);      
d3952 1
d3957 1
d3962 1
d3967 1
d3972 1
d3977 1
d3982 1
d3987 1
d3992 1
d3997 1
d4002 1
d4652 1
d4657 1
d4696 1
d4705 1
d4712 1
d4721 1
d4730 1
d4739 1
d4772 1
d4779 1
d4826 1
d4841 1
d4859 1
d4923 8
@


1.24
log
@added mag_damage spells, all first and second circle spells of all
classes are in the spell system now.
sync
@
text
@d1 1
a1 1
/ $Id: magic.c,v 1.23 2000/03/29 06:29:50 rsd Exp $
d685 1
d688 1
a688 1
  int skill;
d690 4
a693 1
  */
d781 1
a781 1
    new_dam = dam;
d787 1
a787 1
    new_dam = dam;
d793 1
a793 1
    new_dam = dam;                              /* Nothing like a prime number ^^ to show your raw calculations */
d799 1
a799 1
    new_dam = dam;
d805 1
a805 1
    new_dam = dam;
d809 1
a809 1
    / max dam 65 from 5d4+2 online */
d811 1
a811 1
    new_dam = dam;
d815 1
a815 1
    / max dam 90 from 6d6+5 online */
d817 1
a817 1
    new_dam = dam;
d820 74
d4794 5
@


1.23
log
@Many mag affects spells had returns out for various reasons.
The messages associated with the returns were buffered but
never sent by the act()'s at the end of the function. Each
buffer for player messaging before a return now has an act
assicated with it.  I hope it's done correctly.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.22 2000/03/27 08:06:06 rsd Exp $
d684 2
a685 1
  
d727 4
a730 1
  
d765 7
a771 1
  
d773 43
a815 2
    /* Mostly mages */
    
d4716 7
@


1.22
log
@completed hosing with all the spells in mag_affectc()
except stone skin.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.21 2000/03/26 23:48:37 rsd Exp $
d1010 6
a1015 1
  
d1023 3
a1025 2
	(affected_by_spell(victim, SPELL_MIRAGE)) || (affected_by_spell(victim, SPELL_GAIAS_CLOAK))) {
      to_char = "$n seems to be protected enough already!";
d1027 1
d1167 2
a1168 1
      to_char = "$n seems to be protected enough already!";
d1170 1
d1208 5
a1212 1
    if (MOB_FLAGGED(victim,MOB_NOBLIND)) {
d1214 1
d1233 2
a1234 2
      
      to_room = "&9&b$n&9&b is choked by $N's&9&b column of smoke!&0";
d1236 3
a1238 1
      to_char = "You temporarily choke $n with your column of smoke.";
d1267 2
a1268 1
      to_char = "$n seems to be protected enough already!";
d1270 1
d1320 3
d1324 1
a1324 1
      to_vict="&2&bA crop of ripe vines snakes along the ground unable to locate you!&0";
d1433 14
a1446 2
      to_char = "$n seems to be protected enough already!";
      to_room = "$N looks a little over protective.";
d1491 2
a1492 1
      to_char = "$n seems to be able to sort of see enough already!";
d1494 1
d1534 1
d1536 3
a1538 1
      to_room="$N fails to enrage $n's inner demon.";  
d1603 13
a1615 2
      to_char = "$n seems to be protected enough already!";
      to_room = "$N looks a little over protective.";
d1623 1
d1625 1
d1627 1
d1674 3
d1749 3
d1771 1
d1774 3
d2123 3
d2214 6
a2219 1
      to_char = "$n's Globe of invulnerability resists your spell!";
d2253 5
d2354 3
d2391 1
d2393 3
d2403 3
d2475 3
d2520 13
a2532 2
      to_char = "$n seems to be protected enough already!";
      to_room = "$N looks a little over protective.";
d2574 3
d2639 2
d2652 2
d2701 2
d2845 3
d2905 3
d2940 3
d2971 3
d3142 13
a3154 2
      to_char = "$n seems to be able to sort of see enough already!";
      to_room = "$N looks a little over protective.";
d3248 2
d3291 3
d3339 1
d3344 2
d3574 2
d4665 4
@


1.21
log
@completed more of the mag_affects() spells.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.20 2000/03/26 07:21:20 rsd Exp $
d1017 8
d1030 2
a1031 2
     */

d1158 8
d1248 8
d1408 8
d1418 1
d1457 6
a1462 3
    /* Need a check for casted infra vision to exclude night viz working 
       However this should work on top of innate infra */

d1563 9
a1571 1
    /* Alignement Checks! */
d2278 1
a2278 1
      to_room="&7&b$N sqints at $n but nothing happens.&0";    
d2313 1
a2313 1
      to_room="&7&b$N sqints at $n but nothing happens.&0"; 
d2320 1
a2320 1
      to_room="&7&b$N sqints at $n but nothing happens.&0";
d2430 8
d2474 1
a2474 1
      to_room="&7&b$N sqints at $n but nothing happens.&0";    
d2848 2
a2849 1
  case SPELL_CURSE: /* Zzur's working mark */
d2852 3
d2857 54
a2910 5
    
    af[0].location = APPLY_HITROLL;
    af[0].duration = 1 + (GET_LEVEL(ch) >> 1);
    af[0].modifier = -1;
    af[0].bitvector = AFF_CURSE;
d2912 13
a2924 4
    af[1].location = APPLY_DAMROLL;
    af[1].duration = 1 + (GET_LEVEL(ch) >> 1);
    af[1].modifier = -1;
    af[1].bitvector = AFF_CURSE;
d2926 9
d2936 1
d2943 19
a2961 1
    af[0].duration = 12 + level;
d2963 2
d2970 19
a2988 1
    af[0].duration = 12 + level;
d2995 19
a3013 1
    af[0].duration = 12 + level;
d3021 24
a3044 3
    /* Need check to make sure Innate Ultravision and innate infra aren't already present */

    af[0].duration = 12 + level;
d3046 1
d3053 1
a3053 1
    if (!victim)
d3055 19
a3073 2
    
    af[0].duration = 12 + (GET_LEVEL(ch) >> 2);
d3084 1
a3084 1
    if (!victim)
d3086 19
a3104 2
    
    af[0].duration = 12 + (GET_LEVEL(ch) >> 2);
d3115 2
d3118 24
a3143 1
    
a3144 2
    af[0].duration = GET_LEVEL(ch);
    af[0].modifier = -2;
d3152 27
a3178 1
    af[0].duration = 24;
d3189 1
d3202 1
d3205 4
d3215 23
a3238 2
    
    af[0].duration = 4 + (GET_LEVEL(ch) >> 2);
d3251 28
d3280 2
a3281 3
    af[0].duration = (GET_LEVEL(ch) >> 1) + 4;
    af[0].modifier = 1 + (level > 18);
    accum_affect = TRUE;
d3296 20
d3317 1
a3317 2
    af[0].duration = GET_LEVEL(ch);
    af[0].bitvector = AFF_SENSE_LIFE;
d3322 19
a3340 1
    af[0].duration = 24;
d3342 1
d3348 19
a3366 1
    af[0].duration = GET_LEVEL(ch);
d3375 19
a3393 1
    af[0].duration = 12 + level;
d4524 3
@


1.20
log
@Added an improve_skill() call to every mag_affects() spell case in
the switch, each spell has a base improve_skill() call just before
the break in their case.  Some have more than one instance of the
call............
Added appropriate to_vict, to_room, and to_char messages for the
first half of spells in mag_affects().
Removed the defines for af[0].element that I had put in mag_affects()
a few days ago.  I realized that there was af[i].element going on
so to just have the defines for af[0] was a bit silly. I removed the
use of the defines I had coded for barkskin, dark presence, armor,
bless, and demonskin......
Added alignment checks and restrictions on Demonskin, Dark Presence,
and bless.........
Worked though about the first half of the spells in mag_affects()
and integrated the spell proficiency system.  This was rather easy
compared to the pther mag() type spells as most of the mag_affects()
spells have very simple affects to manipulate.  There were a few
instances of spells where we want more special things to occur,
and some instances of confusion, but it's all commented. I admit
some of the things I did were goat sacrificing HACKS that may not
work. More work later....
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.19 2000/03/25 21:36:13 rsd Exp $
d1388 1
a1388 1
      /* Determine spell elements based on skill at protection RSD 3/25/00 */
d1428 1
a1428 1
    /* Determine spell elements based on skill at protection RSD 3/25/00 */
d1469 1
a1469 1
    /* Determine spell elements based on skill at protection RSD 3/25/00 */
d1542 1
a1542 1
      /* Determine spell elements based on skill at protection RSD 3/24/00 */
d1586 1
a1586 1
    /* Determine spell elements based on skill at protection RSD 3/26/00 */
d1659 1
d1665 58
a1722 8
  case SPELL_DEMONIC_ASPECT: /* Zzur's working mark */
    af[0].location = APPLY_HIT;
    af[0].modifier = GET_LEVEL(ch);
    af[0].duration = (int)(GET_LEVEL(ch) / 3);
    
    af[1].location = APPLY_STR;
    af[1].modifier = 10;
    af[1].duration = (int)(GET_LEVEL(ch) / 3);
d1729 3
d1738 27
a1764 2
    af[0].bitvector=AFF_FLYING;
    af[0].duration=(int)(GET_LEVEL(ch)/2);
d1776 2
d1789 4
a1792 4
    if(!IS_NPC(ch)) {
      sprintf(buf, "hitpoints: %d duration: %d", af[0].modifier, af[0].duration);
      log(buf);
    }
d1796 27
a1822 2
    af[0].bitvector=AFF_FLYING;
    af[0].duration=(int)(GET_LEVEL(ch)/2);
d1829 19
d1849 1
a1849 1
    af[0].duration = (int)(GET_LEVEL(ch)/2);
d1851 1
d1856 2
a1857 1
    if(is_abbrev(buf2,"fire")){
d1860 2
a1861 2
    }
    else if (is_abbrev(buf2,"cold")){
d1864 2
a1865 2
    }
    else if (is_abbrev(buf2,"air")){
d1868 2
a1869 2
    }
    else if (is_abbrev(buf2,"earth")){
d1872 4
d1877 17
a1893 2
    else {
      send_to_char("What element do you want to ward against?\r\n",ch);
a1895 1
    af[0].duration = GET_LEVEL(ch);
d1901 52
a1952 7
    af[0].location = APPLY_SAVING_SPELL;
    af[0].modifier = -2;
    af[0].duration = (int)(GET_LEVEL(ch) / 3);
    
    af[1].location = APPLY_HIT;
    af[1].modifier = GET_LEVEL(ch);
    af[1].duration = (int)(GET_LEVEL(ch) / 3);
d1959 19
a1977 1
    af[0].duration = 24;
d1986 19
a2004 1
    af[0].duration = GET_LEVEL(ch);
d2013 5
a2017 1
    if(mag_savingthrow(victim, SAVING_PARA))
d2019 37
a2055 2
    af[0].duration = 2;
    af[0].bitvector2 = AFF2_FEAR;
d2057 1
a2057 1
    to_room="&9&bA look of terror sweeps over $n&9&b's face!&0";
d2062 6
d2076 18
a2093 1
    af[0].duration = 2;
d2103 25
a2127 1
    af[0].duration = 8;
d2136 24
a2159 1
    af[0].duration = 8;
d2168 1
d2173 18
a2190 1
    af[0].duration = 4;
d2199 1
d2204 18
a2221 1
    af[0].duration = 4;
d2230 25
a2254 1
    if(mag_savingthrow(victim, SAVING_PARA)) 
d2256 1
a2256 1
    af[0].duration = (int)(GET_LEVEL(ch)/10);
d2259 1
d2266 5
a2270 1
    if(IS_AFFECTED3(victim, AFF3_RAY_OF_ENFEB))
d2272 6
a2277 1
    if(mag_savingthrow(victim, savetype)) 
d2279 18
a2296 5
    af[0].location = APPLY_STR;
    af[0].duration = (int)(GET_LEVEL(ch)/2);
    if(IS_NPC(victim))
      af[0].modifier = -1;
    else
d2298 10
d2315 19
a2333 1
    af[0].duration = (int)(GET_LEVEL(ch)/2);
d2412 12
a2423 2
    if (MOB_FLAGGED(victim,MOB_NOSILENCE) || mag_savingthrow(victim, savetype)) {
      send_to_char("You fail.\r\n", ch);
d2426 18
a2443 1
    af[0].duration = (int)(GET_LEVEL(ch) / 10);
d2445 1
d2452 19
a2470 1
    af[0].duration = (int)(GET_LEVEL(ch) / 5);
d2473 1
d2491 5
a2495 1
    if(IS_AFFECTED3(victim, AFF3_ENLARGE))
d2497 1
d2500 22
a2523 1
    af[0].duration = 3;
a2527 1
    af[1].duration = 2;
a2530 1
    af[2].duration = 2;
d2539 4
a2542 1
    if(IS_AFFECTED3(victim, AFF3_REDUCE))
d2544 1
d2547 21
a2569 1
    af[0].duration = 3;
a2573 1
    af[1].duration = 2;
a2576 1
    af[2].duration = 2;
d2584 5
a2588 1
  case SPELL_STONE_SKIN:
d2593 1
d2595 1
d2602 19
a2620 1
    af[0].duration = 5;
d2622 1
d2629 15
a2643 1
    af[0].duration = 5;
d2651 19
a2669 1
    af[0].duration = 10;
d2671 1
d2731 12
a2742 1
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
d2746 2
d2758 1
d2765 3
a2767 2
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
      send_to_char("You fail.\r\n", ch);
d2770 5
a2774 4
    /* temp fix until saves fixed. Tired of people blinding guards.*/
    if(number(1,100) > 50) {
      if(IS_NPC(victim) && number(1,100) > 50 && !FIGHTING(victim))
        hit(victim,ch,TYPE_UNDEFINED);
d2777 3
d2790 2
a2791 1
    to_room = "&9&b$n&9&b seems to be blinded!&0";
d2796 1
a2796 1
  case SPELL_CURSE:
d4111 23
@


1.19
log
@Altered to use spell proficiencies:
chill touch
Barkskin
nightvision
dark presence
Also added a missing skill check for demonskin.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.18 2000/03/24 23:49:35 rsd Exp $
a982 4
#define LOCATION  af[0].location
#define MODIFIER  af[0].modifier
#define DURATION  af[0].duration

d1014 37
a1050 4
    af[0].location = APPLY_AC;
    af[0].modifier = -15;
    af[0].duration = 24;
    
d1053 1
d1057 24
a1080 4
    af[0].bitvector2 = AFF2_NEGATE_HEAT;
    af[0].duration = 6;
    refresh = FALSE;
    
d1083 1
d1087 23
a1109 2
    af[0].bitvector2 = AFF2_NEGATE_COLD;
    af[0].duration = 6;
a1110 1
    
d1113 1
d1117 23
a1139 2
    af[0].bitvector2 = AFF2_WATERFORM;
    af[0].duration = 6;
a1140 1
    
d1143 1
d1147 2
a1148 3
    af[0].location = APPLY_AC;
    af[0].modifier = -15;
    af[0].duration = 24;
d1150 27
d1179 1
d1183 25
a1207 1
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || mag_savingthrow(victim, savetype)) {
d1209 3
a1211 1
    }
d1217 1
a1217 1

d1222 1
a1222 1

d1225 2
d1228 1
a1228 2


d1230 3
d1237 27
a1263 3
    af[0].location = APPLY_AC;
    af[0].modifier = -30;
    af[0].duration = 10;
d1267 1
d1269 1
d1275 6
a1280 1
    if(mag_savingthrow(victim, SAVING_PARA)) {
d1283 17
a1299 3
    if(number(0, 100) > 50)
     return;
    if(number(0, 100) < 10) {
d1301 1
a1301 1
      af[0].bitvector = AFF_MAJOR_PARA;
d1303 4
a1306 2
      to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
      to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
d1308 63
a1370 7
    }else
      refresh = FALSE;
    af[0].bitvector2 = AFF2_MINOR_PARALYSIS;
    af[0].duration = 5;
    to_room="&2&bA slew of thick branches and vines burst from the ground, partially entangling $n!&0";
    to_vict="&2&bA slew of thick branches and vines burst from the ground, partially entangling you!&0";
    break;
d1373 2
d1376 3
a1378 3
      LOCATION = APPLY_AC;
      MODIFIER = 5;
      DURATION = 2;     
d1386 2
a1387 1
      skill = GET_SKILL(ch, SKILL_SPHERE_PROT);    
d1390 3
a1392 3
	LOCATION = APPLY_AC;
	MODIFIER = -7;
	DURATION = 5;
d1394 3
a1396 3
	LOCATION = APPLY_AC;
	MODIFIER = -9;
	DURATION = 7;
d1398 3
a1400 3
	LOCATION = APPLY_AC;
	MODIFIER = -12;
	DURATION = 10;
d1402 3
a1404 3
	LOCATION = APPLY_AC;
	MODIFIER = -16;
	DURATION = 14;
d1406 3
a1408 3
	LOCATION = APPLY_AC;
	MODIFIER = -18;
	DURATION = 15;
d1419 1
a1419 1
    improve_skill(ch, SKILL_SPHERE_PROT);
d1427 1
a1427 1
    skill = GET_SKILL(ch, SKILL_SPHERE_ENCHANT);    
d1431 2
a1432 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 0;
d1434 2
a1435 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 1;
d1437 2
a1438 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 2;
d1440 2
a1441 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 3;
d1443 2
a1444 2
    af[0].bitvector2 = AFF2_ULTRAVISION;
    af[0].duration = 4; 
d1453 1
a1453 1
    improve_skill(ch, SKILL_SPHERE_ENCHANT);
d1459 10
a1468 2
    
    skill = GET_SKILL(ch, SKILL_SPHERE_PROT);    
d1485 3
a1487 3
      LOCATION = APPLY_DAMROLL;
      MODIFIER = 1;
      DURATION = 8; 
d1495 3
a1497 3
      LOCATION = APPLY_DAMROLL;
      MODIFIER = 1;
      DURATION = 12;
d1505 3
a1507 3
      LOCATION = APPLY_DAMROLL;
      MODIFIER = 2;
      DURATION = 12;
d1520 1
a1520 1
    improve_skill(ch, SKILL_SPHERE_PROT);
d1527 10
a1536 6
    skill = GET_SKILL(ch, SKILL_SPHERE_PROT);    
    /* Determine spell elements based on skill at protection RSD 3/24/00 */
    if (skill > 0 && skill < 35) {
      LOCATION = APPLY_AC;
      MODIFIER = -10;
      DURATION = 10;      
d1538 1
a1538 13
      af[1].duration = 10;      
    } else if (skill >= 35 && skill < 81) {
      LOCATION = APPLY_AC;
      MODIFIER = -12;
      DURATION = 12;
      af[1].bitvector2 = AFF2_PROT_FIRE;
      af[1].duration = 12;
    } else if (skill >= 81) {
      LOCATION = APPLY_AC;
      MODIFIER = -15;
      DURATION = 12;
      af[1].bitvector2 = AFF2_PROT_FIRE;
      af[1].duration = 12;
d1540 26
a1565 4
      sprintf(buf,"SYSERR:magic.c:mag_affects(): %s attemped to cast SPELL_DEMONSKIN with 0 SKILL.", GET_NAME(ch));      
      log(buf);
      send_to_char(broken, ch);
      return;
d1569 1
a1569 1
    improve_skill(ch, SKILL_SPHERE_PROT);
d1573 54
a1626 9
    if(mag_savingthrow(victim, SAVING_SPELL))
      return;
    af[0].bitvector2 = AFF2_DISEASE;
    af[0].duration = 15;
    
    af[1].location = APPLY_CON;
    if(IS_NPC(victim))
      af[1].modifier = -3;
    else
d1628 2
a1629 6
    af[1].duration = 15;
    
    af[2].location = APPLY_STR;
    if(IS_NPC(victim))  
      af[2].modifier = -3;
    else
d1631 11
a1641 3
    af[2].duration = 15;
    to_vict="&3A foul feeling overtakes you. You feel seriously ill!&0";
    to_room="&3$n&3 looks seriously ill!";
d1645 6
a1650 1
    if(mag_savingthrow(victim, SAVING_SPELL))
d1652 2
d1655 1
a1655 2
    af[0].duration = 5;
    
d1661 1
d1664 1
a1664 1
  case SPELL_DEMONIC_ASPECT:
d1674 1
d1680 1
d1688 1
d1694 1
a1694 1
    af[0].modifier = ((pow(GET_SKILL(ch, SKILL_SPHERE_ENCHANT), 2)) / 40) + 50;
d1700 1
a1700 1
    improve_skill(ch, SKILL_SPHERE_HEALING);
d1719 1
d1726 1
d1752 1
d1765 1
d1774 1
d1783 1
d1793 1
d1811 1
d1820 1
d1829 1
d1842 1
d1855 1
d1866 1
d1883 1
d1891 1
d1900 1
a1900 1
      improve_skill(ch, SKILL_SPHERE_WATER);      
d1904 1
a1904 1
      skill = GET_SKILL(ch, SKILL_SPHERE_WATER);    
d1933 1
a1933 1
    improve_skill(ch, SKILL_SPHERE_WATER);
d1940 1
a1940 1
    skill = GET_SKILL(ch, SKILL_SPHERE_PROT);    
d1943 3
a1945 3
      LOCATION = APPLY_AC;
      MODIFIER = -10;
      DURATION = 10;
d1947 3
a1949 3
      LOCATION = APPLY_AC;
      MODIFIER = -12;
      DURATION = 12;
d1951 3
a1953 3
      LOCATION = APPLY_AC;
      MODIFIER = -15;
      DURATION = 12;
d1962 1
a1962 1
    improve_skill(ch, SKILL_SPHERE_PROT);   
d1974 1
d1994 1
d1996 1
d2018 1
d2020 1
d2042 3
a2044 1
    break; 
d2053 1
d2061 1
d2069 1
d2076 1
a2078 1
    
d2083 9
a2091 1
    skill = GET_SKILL(ch, SKILL_SPHERE_PROT);    
d2094 3
a2096 3
      LOCATION = APPLY_HITROLL;;
      MODIFIER = 1;
      DURATION = 5;
d2099 1
a2099 1
      af[1].duration = 6;
d2101 3
a2103 3
      LOCATION = APPLY_HITROLL;;
      MODIFIER = 1;
      DURATION = 8;
d2108 3
a2110 3
      LOCATION = APPLY_HITROLL;;
      MODIFIER = 2;
      DURATION = 8;
d2115 3
a2117 3
      LOCATION = APPLY_HITROLL;;
      MODIFIER = 2;
      DURATION = 12;
d2127 4
a2130 4
    to_char = "$n is assisted by your gods.";
    to_vict = "You feel righteous.";
    to_room = "$n is assisted by $N's gods.";    
    improve_skill(ch, SKILL_SPHERE_PROT);    
d2150 1
d2176 1
d2198 1
d2205 1
d2212 1
d2219 1
d2223 3
d2230 1
d2243 1
d2247 1
d2257 1
d2272 1
d2279 1
d2283 6
a2290 1
    
d2318 1
d2327 1
d2336 1
d2343 1
d2350 1
d2359 1
d2367 1
d3494 8
@


1.18
log
@Altered bless and demonskin to use the spell prof system.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.17 2000/03/24 05:24:39 rsd Exp $
d685 4
d1118 1
d1120 41
a1160 3
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;
d1163 1
d1167 20
d1188 8
a1195 1
    af[0].duration = 24;
d1197 1
a1200 3
    af[0].location = APPLY_DAMROLL;
    af[0].modifier = 2;
    af[0].duration = 15;
d1202 55
a1256 4
    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 15;
    to_vict="&9&bA dark presence fills your mind.&0";
d1260 1
a1260 1

d1291 1
d1543 35
a1577 8
    af[0].location = APPLY_STR;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 1;
    else
      af[0].duration = 4;
    af[0].modifier = -(GET_LEVEL(ch) / 3);
    if (af[0].modifier < -10)
      af[0].modifier = -10;
d1579 3
d1583 1
a1583 1
    
d1718 3
d1756 1
a1756 2
    }
    
d1760 1
d2139 1
d2141 1
a2141 2
    return;
  
d3097 3
@


1.17
log
@changed armor to use sphere of prot as skill proficiency.
Also declared some variables at the beginning of mag_affects()
to facilitate the use of skills in spells.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.16 2000/03/19 20:38:18 rsd Exp $
d3 1
a3 1
 *   File: magic.c                                       Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
a13 1

a23 1

d978 5
d988 1
a988 1
  char *to_vict = NULL, *to_room = NULL;
d991 1
a991 4
  /* Integers to use the skill system oto vary spell results RSD 3/22/00 */

  int modifier = 0;
  int duration = 0;
a992 1

d1140 2
a1141 3
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;
d1143 26
a1168 2
    af[1].bitvector2 = AFF2_PROT_FIRE;
    af[1].duration = 24;
d1434 3
d1440 3
a1442 2
      modifier = -10;
      duration = 10;
d1444 3
a1446 2
      modifier = -12;
      duration = 12;
d1448 3
a1450 2
      modifier = -15;
      duration = 12;
a1456 3
    af[0].location = APPLY_AC; 
    af[0].modifier = modifier;
    af[0].duration = duration;
d1562 1
a1562 1
    to_vict = "&8You feel you knowledge of Hubis' languages improving!&0";
d1567 36
a1602 7
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 2;
    af[0].duration = 6;

    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 6;
d1604 1
d1606 1
d2943 5
@


1.16
log
@added brackes to the if statements of SD_INTERN_DAM and
tabbed it out.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.15 2000/03/18 06:08:38 rsd Exp $
d985 8
d1410 20
a1429 3
    af[0].location = APPLY_AC;
    af[0].modifier = -20;
    af[0].duration = 24;
d1431 2
a1443 1
    
d1689 2
a1690 2
    to_vict = "A white aura momentarily surrounds you.";
    to_room = "$n is surrounded by a white aura.";
d2885 4
@


1.15
log
@Changed the overall duration of vitality as well as the ranges
at which the durations increase. Put some comments in about what
a default duration of 0 means to the players. Added an extern -
extern void improve_skill(struct char_data *ch, int skill);
This was done so skill improvemts could be called for spell usage
like with the ones added for vitality.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.14 2000/03/05 00:15:34 rsd Exp $
d724 28
a751 26
  if (SD_INTERN_DAM(spellnum))
    {
      if (((!IS_NPC(ch))  && (!IS_NPC(victim))) || 
	  (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))))
        {/*pc vs pc*/
	  dam = dice(SD_PC_NO_DICE(spellnum), SD_PC_NO_FACE(spellnum)) + SD_PC_STATIC(spellnum);
	  if (SD_USE_BONUS(spellnum))                
	    dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/4)));
	  else
	    dam = dam + MIN(SD_BONUS(spellnum),
			    GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
	  
	}else
	  {/*any other*/
	    dam = dice(SD_NPC_NO_DICE(spellnum), SD_NPC_NO_FACE(spellnum)) + SD_NPC_STATIC(spellnum);
            if (SD_USE_BONUS(spellnum))
	      dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/2)));
	    else
	      dam = dam + MIN(SD_BONUS(spellnum),
			      GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
	  }
      if (IS_NPC(ch))
        {/*reduce npc dam*/
	  dam = (int)((SD_NPC_REDUCE_FACTOR(spellnum) * dam)/100);
	  
        }
d753 1
a753 1
  
d757 1
a757 1

d837 6
a842 6
	  } else if (GET_ALIGNMENT(ch) >= 350 && GET_ALIGNMENT(ch) < 749) {
	      dam = dice(3,10);
	  } else if (GET_ALIGNMENT(ch) >= 750 ) { 
	      dam = dice(4,10);
	    }      
	  }
d857 1
a857 1

d860 1
a860 1

d862 7
a868 7
	  } else if (GET_ALIGNMENT(ch) <= -350 && GET_ALIGNMENT(ch) > -749) {
	      dam = dice(3,10);

	    } else if (GET_ALIGNMENT(ch) <= -750 ) { 
	      dam = dice(4,10);

	    }
d2859 8
@


1.14
log
@Er, had a buncha returns though the functioning parts of
Dispel good and evil, so it was returning out of mag_damage
after it listed the damage hehe silly me.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.13 2000/03/04 08:32:25 rsd Exp $
d45 1
d1205 10
d2830 3
d2838 1
a2838 1
    skill = GET_SKILL(ch, SKILL_SPHERE_ENCHANT);
a2839 4
      return 0;
    } else if (skill >= 41 && skill <= 80) {
      return 1;
    } else if (skill >= 81 && skill <= 95) {
d2841 4
d2846 1
a2846 1
      return 3;
d2857 5
@


1.13
log
@Altered DISPEL_GOOD DISPEL_EVIL and VAMPIRIC_BREATH
to be somewhat functional, more so than they were
before.  Although the dispells don't seem to call
their proper messages.
/s
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.12 2000/02/26 02:17:21 rsd Exp $
a830 1
	  return;
a832 1
	  return;
a835 1
	      return;
a837 1
	      return;
d847 1
d854 1
a854 1
	  return;
d857 1
a857 1
	  return;
d861 1
a861 1
	      return;
d864 1
a864 1
	      return;
d2843 7
@


1.12
log
@Oooook, fixed healing proficiency cheks to actually include the 96
percentile by adding a = after the > in >96 grumbmle.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.11 1999/12/08 21:21:59 jimmy Exp $
d823 21
a843 1
    }
d850 19
a886 2
    if (GET_LEVEL(victim) <= 25)
      dam = 20;
d889 10
d2846 4
@


1.11
log
@added checks for spell proficiencies all healing spells and vitality.
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.10 1999/11/29 01:32:51 cso Exp $
d2408 1
a2408 1
  } else if(skill > 96) {
d2799 3
@


1.10
log
@made chill touch decrease strength a little more
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.9 1999/11/28 23:41:42 cso Exp cso $
d15 1
a15 1

d23 1
d62 1
a62 1

a938 1
  
d1155 1
d1157 2
a1158 2
    af[0].modifier = MIN(4 * GET_LEVEL(ch), 255);
    af[0].duration = (int)(GET_LEVEL(ch) / 5);
d1160 5
d2384 1
a2384 3
void mag_points(int level, struct char_data * ch, struct char_data * victim,
		int spellnum, int savetype)
{
d2389 4
a2392 1
  
d2395 20
a2414 1
  
d2417 1
a2417 1
    hit = dice(1, 8) + 1 + (level >> 2);
a2418 1
    
d2421 1
a2421 1
    hit = dice(3, 8) + 3 + (level >> 2);
d2425 1
a2425 1
    hit = dice(2, 8) + 2 + (level >> 2);
d2429 1
a2429 1
    hit = 100 + dice(3, 8);
d2433 1
a2433 1
    hit = 300 + dice(3, 8);
d2437 1
a2437 1
    move = dice(2, 8) + 3 + (level >> 2);
d2441 1
a2441 1
    move = dice(4, 8) + 3 + (level >> 2);
d2445 1
a2445 1
    move = dice(6, 8) + 3 + (level >> 2);
d2458 3
d2462 12
a2473 4
  alter_hit(victim, -hit, 4);
  alter_move(victim, -move);
  gain_condition(victim, FULL, hunger);
  gain_condition(victim, THIRST, thirst);
d2773 25
d2799 3
@


1.9
log
@affect_update: added check to kill animated mobs when the animate wears off
new fn: mod_for_undead_type: modify a mob's stats based on what undead type
 it is. used by create_undead
new fn: mod_for_lvldiff: modify a mob's stats based on the level difference
 between it and the necro that raised it. used by create_undead
new fn: create_undead: create an undead mob. used by mag_summons for

 animate dead
new fn: ch_can_control_mob: check to see if a necro can control the undead
 he just raised. used by mag_summons for animate dead
removed unused mag_summons_msgs
removed unused mag_summon_fail_msgs
removed unused defines form MOB_ZOMBIE, MOB_MONSUM_I, etc
rewrote mag_summons from scratch
@
text
@d1 1
a1 1
// $Id: magic.c,v 1.8 1999/09/05 07:00:39 jimmy Exp $
d1332 3
a1334 1
    af[0].modifier = -1;
d2738 16
@


1.8
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d541 1
a541 1
  static struct char_data *i;
d545 2
a546 1
  for (i = character_list; i; i = i->next)
d571 7
d1970 273
d2251 13
a2263 34
static char *mag_summon_msgs[] = {
  "\r\n",
  "$n makes a strange magical gesture; you feel a strong breeze!\r\n",
  "$n animates a corpse!\r\n",
  "$N appears from a cloud of thick blue smoke!\r\n",
  "$N appears from a cloud of thick green smoke!\r\n",
  "$N appears from a cloud of thick red smoke!\r\n",
  "$N disappears in a thick black cloud!\r\n"
  "As $n makes a strange magical gesture, you feel a strong breeze.\r\n",
  "As $n makes a strange magical gesture, you feel a searing heat.\r\n",
  "As $n makes a strange magical gesture, you feel a sudden chill.\r\n",
  "As $n makes a strange magical gesture, you feel the dust swirl.\r\n",
  "$n magically divides!\r\n",
  "$n animates a corpse!\r\n",
  "&1$n summones the powers of a dracolich into the corpse!&0\r\n",
  "$n calls upon the powers of the elemental planes!\r\n",
  "&1$n summons the powers of the abyss and calls forth a demon!&0\r\n",
  "&1$n summons forth $N and it doesn't look to impressed!&0\r\n"
};
static char *mag_summon_fail_msgs[] = {
  "\r\n",
  "There are no such creatures.\r\n",
  "Uh oh...\r\n",
  "Oh dear.\r\n",
  "&1&bOh shit!&0\r\n",
  "The elements resist!\r\n",
  "The corpse quivers, briefly.\r\n",
  "&7A corpse would help, dont you think?&0\r\n",
  "&7You can not control anymore dracoliches.&0\r\n",
  "&7You can not control anymore undead.&0\r\n",
  "&7You can not control anymore elementals.&0\r\n",
  "&7You can not control anymore demons.&0\r\n",
  "&7You can not clone yourself again.&0\r\n"
};
d2265 2
a2266 15
#define MOB_MONSUM_I		130
#define MOB_MONSUM_II		140
#define MOB_MONSUM_III		150
#define MOB_GATE_I		160
#define MOB_GATE_II		170
#define MOB_GATE_III		180
#define MOB_ELEMENTAL_BASE	110
#define MOB_CLONE		69
#define MOB_ZOMBIE		11
#define MOB_AERIALSERVANT	109
#define MOB_MENTAL     17
#define MOB_MENTAL2    21
#define MOB_MENTAL3    33
#define GET_SDESC(mob)   ((mob)->player.short_descr)
/*#define GET_LDESC(mob)     ((mob)->player.long_descr)*/
d2268 4
d2273 92
a2364 654
void mag_summons(int level, struct char_data * ch, struct obj_data * obj,
		 int spellnum, int savetype)
{
  struct char_data *mob = NULL;
  struct obj_data *tobj, *next_obj;
  struct follow_type *k;
  bool got_good = FALSE;
  int pfail = 0;
  bool got_draco =  FALSE;
  int msg = 0, fmsg = 0;
  int num = 1;
  int a, i, b = 0, c, d;
  int agro_num = 0;
  int org_room;
  int zom_num = 0;
  int mob_num = 0;
  int handle_corpse = 0;
  
  if (ch == NULL)
    return;/*if no character get out*/
  
  switch (spellnum) 
    {
    case SPELL_ANIMATE_DEAD:
      /*PLEASE NOTE PLEASE NOTE PLEASE NOTE PLEASE NOTE*/
      /*THIS CODE WILL NEVER BE GOOD UNTIL THERE IS A SKILL RAISE UNDEAD,
	OR A SPELL SPHERE THAT CAN BE ADDED*/
      
      if ((obj == NULL) || (GET_OBJ_TYPE(obj) != ITEM_CONTAINER) 
	  ||	((GET_OBJ_VAL(obj, 3)) < 0)) 
	{
	  act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
			return;
	}
      /*worth of mobs:
	zombie, skeleton = 1;
	spectre = 3;
	wraith = 3;
	vampire = 5;
	lich = 5;
      */
      if (CORPSE_LEVEL(obj) > (GET_LEVEL(ch) + 5))
	{
	  send_to_char("Don't think you could handle that corpse.\r\n", ch);
	  return;
	}
      d  = 0;
      
      if (CORPSE_LEVEL(obj)  >= 30)
        if ((mob_proto[GET_OBJ_MOB_FROM(obj)].player.race == SPECIES_DRAGON))
	  {
	    if (CORPSE_LEVEL(obj) < 50)
	      {
		if (number(1, 101) >= 70)                                        
		  got_draco = TRUE;		
	      }
            else
	      {
                if (number(1, 101) >= 80)
		  got_draco = TRUE;
	      }                
	  }
      if (GET_LEVEL(ch) > LVL_GRGOD)
        if ((mob_proto[GET_OBJ_MOB_FROM(obj)].player.race == SPECIES_DRAGON))
	  got_draco = TRUE;
      
      
      zom_num = (int)(GET_LEVEL(ch)/3);/*gives lvl21 = 7, lvl30 = 10, lvl50 = 16*/
      org_room = ch->in_room;
      /*c will = the number value of followers*/
      c = 0;
      
      for (k = ch->followers; k; k = k->next)		
	{	
	  if ((IS_AFFECTED(k->follower, AFF_CHARM)) && IS_NPC(k->follower)) 
	    {				/* found = TRUE;*/
	      switch(GET_MOB_VNUM(k->follower))
		{
		case MOB_ZOMBIE:
		  c++;
		  break;
		case (MOB_ZOMBIE +1):/*specture*/
		  c=c+4;
		  break;
		case (MOB_ZOMBIE +2):/*skeleton*/
		  c++;
		  break;
		case (MOB_ZOMBIE +3):/*vampire*/
		  c=c+5;
		  got_good = TRUE;
		  break;
		case (MOB_ZOMBIE +4):/*wraith*/
		  c=c+3;
		  got_good = TRUE;
		  break;
		case (MOB_ZOMBIE +5):/*lich*/
		  c=c+5;
		  got_good = TRUE;
		  break;
		case (4):/*big draco*/
		  d = d + 2;
		  break;
		case (5):/*small draco*/
		  d = d + 1;
		  break;
		}
	      
	      if (got_draco)
		{
		  if (d >= 2)
		    {
		      act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
		      return;
		    }
		  
		}
	      else if((c >= zom_num) || ((got_good) && ((c + 5) >= zom_num))) 
		{/*basically that small equation stops people having two GOOD mobs then
		   getting a heap of small mobs*/
		  act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
		  return;
		}
	      
	    }
	}
      
      /*	sprintf(buf, "number of c atm is %d \r\n", c);
		send_to_char(buf, ch);*/
      handle_corpse = 1;
      msg = 12;
      mob_num = MOB_ZOMBIE;
      
      /*ok here we handle what mob he going to get*/
      /*this has to do on level of corpse*/
      /*I am trusting at this point that the obj IS a corpse*/
      /*spectre 20 +
	wraith 30 +
	vampire 40 +
	lich 50+*/
      i = 0;c = 0;b = 0;/*bonus holder*/	
      if (CORPSE_LEVEL(obj) == 0)
	{
	  pfail = 101;
	  fmsg = 6;
	  break;
	}
      if (CORPSE_LEVEL(obj) < 20)
	{/*zombie or skeleton*/
	  a = number(0, 2);
	  if (a != 2)
	    mob_num = mob_num + 2;
	  agro_num = 5;		
	}
      else if (CORPSE_LEVEL(obj) < 30)
	{/*zombie, skeleton, spectre*/
	  a = number(0, 9);
	  if (GET_LEVEL(ch) > 30)
	    a++;
	  if (a >= 8)
	    mob_num++;/*spectre*/
	  else if(a > 6)
	    mob_num = mob_num + 2;
	  agro_num = 4;	
	}else if (CORPSE_LEVEL(obj) < 40)
	  {/*zombie, skeleton, spectre, wraith*/
	    a = number(0, 20);
	    if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
	      if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
		/*if sorcerer corpse add to chance of wraith*/
		{
		  i =  2;
		}
	    if (GET_LEVEL(ch) > 30)
	      i++;
	    if (GET_LEVEL(ch) > 55)
	      i++;
	    if (GET_LEVEL(ch) > 60)
	      i++;
	    if ((a + i) >= 19)
	      mob_num = mob_num + 4;/*wraith*/
	    else if (a > 13)
	      mob_num = mob_num + 1;/*spectre*/
	    else if (a > 9)
	      mob_num = mob_num + 2;/*skeleton*/
	    agro_num = 3;
	  }
      else if (CORPSE_LEVEL(obj) < 49)
	{/*zombie, skeleton, spectre, wraith, vampire*/
	  a = number(0, 40);
	  b = number(0, 40);
	  
	  if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
	    if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
	      i = 2;
	  if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
	    if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
	      c = 2;
	  if (GET_LEVEL(ch) > 30)
	    {
	      c++;
	      i++;
	    }if (GET_LEVEL(ch) > 50)
	      {
		c++;c++;
		i++;
	      }if (GET_LEVEL(ch) > 60)
		{
		  c++;c++;
		  c++;
		  i++;
		}
	  if ((b + c) >= 37)
	    mob_num = mob_num + 3;/*vampire*/
	  else if ((a + i) > 38)
	    mob_num = mob_num + 4;/*wraith*/
	  else if (a > 30)
	    mob_num = mob_num + 1;/*spectre*/
	  else if (a > 15)
	    mob_num = mob_num + 2;/*skeleton*/
	  
	  agro_num = 2;
	}
      else
	{
	  a = number(0, 40);
	  b = number(0, 40);
	  if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
	    if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
	      i = 2;
	  if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
	    if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
	      c = 2;
	  if (GET_LEVEL(ch) > 30)
	    {
	      c++;
	      i++;
	    }if (GET_LEVEL(ch) > 50)
	      {
		c++;c++;
		i++;
	      }if (GET_LEVEL(ch) > 60)
		{
		  c++;c++;
		  c++;
		  i++;
		}
	  if ((b + ((int)((c+i)/2))) >= 40)
	    mob_num = mob_num + 5;/*lich*/
	  else if ((b + c) >= 36)
	    mob_num = mob_num + 3;/*vampire*/
	  else if ((a + i) > 36)
	    mob_num = mob_num + 4;/*wraith*/
	  else if (a > 30)
	    mob_num = mob_num + 1;/*spectre*/
	  else if (a > 15)
	    mob_num = mob_num + 2;/*skeleton*/
	  agro_num = 1;
	}
      msg = 2;
      /*ok if got draco drop whatever you got and make a draco*/
      if (got_draco)
	{
	  if (CORPSE_LEVEL(obj) < 50)
	    {
	      mob_num = 5;
	      agro_num = 5;
	    }else
	      {
		mob_num = 4;
		agro_num = 5;
		
	      }
	  msg = 12;
	}
		
      agro_num = (agro_num) + 2*(MAX(0, (CORPSE_LEVEL(obj) - GET_LEVEL(ch))));
      pfail = 4;
      fmsg = 3;
      break;
    case SPELL_CLONE: /*Banyal was here  */
      
      handle_corpse = 0; 
      msg = 12;
      mob_num = 69;
      org_room = ch->in_room;
      c = 0;
      for (k = ch->followers; k; k = k->next) 
	{
	  if (org_room == k->follower->in_room)
	    if ((IS_AFFECTED(k->follower, AFF_CHARM)) && (GET_MOB_VNUM(k->follower) == MOB_CLONE)) 
			{
			  /* found = TRUE;*/
			  c = (c + 1);
			  /* if ((found) || (c = 3)) {*/
			  if (c > 0) 
			    {
			      act(mag_summon_fail_msgs[13], FALSE, ch, 0, 0, TO_CHAR);
			      return;
			    }
			}
	}
      
      mob = read_mobile(mob_num, VIRTUAL);
      
      
      
      act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
      char_to_room(mob, ch->in_room);
      strcpy(GET_NAME(mob), GET_NAME(ch));
      strcpy(mob->player.short_descr, GET_NAME(ch)/*("%s stands here.", GET_NAME(ch))*/);
      /*tldesc = str_dup(buf, "%s stands here.", GET_NAME(ch));*/
      strcpy(GET_LDESC(mob), GET_NAME(ch));
      /*strcpy(mob->player.description, GET_NAME(ch));
	strcpy(mob->player.species, GET_RACE(ch));*/ /*dammit need fixin later Banyal*/
      
      /*strcpy(mob->player.keyword, GET_NAME(ch));*/
      IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't carrying anything */
      
      IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry anything */
      
      SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take the caster's
					     orders */
      add_follower(mob, ch); /* Actually make the mob follow the caster */
      send_to_char("&7You clone yourself into a magical servent&0.\r\n", ch); 
      /* send a message to the caster saying that he succeeded */
      return;
      break;
      
    case SPELL_SUMMON_DRACOLICH: 
      if ((GET_OBJ_TYPE(obj) != ITEM_CONTAINER) || (!GET_OBJ_VAL(obj, 3))) 
	{
	  act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
	  return;
	}
      if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.race != SPECIES_DRAGON)
	{
	  send_to_char("You need a better corpse then that for a dracolich!!\r\n", ch);
	  return;
	}
      if (CORPSE_LEVEL(obj) < 50)
	{
	  send_to_char("yYou need a better corpse then that for a dracolich!!\r\n", ch);
	  return;
	}
      zom_num = 1;
      
      if (GET_LEVEL(ch) >= 60)
	zom_num = 2;
      org_room = ch->in_room;
      c = 0;
      for (k = ch->followers; k; k = k->next) 
	{
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) 
	    {
	      
	      if ((GET_MOB_VNUM(k->follower) == 4) || (GET_MOB_VNUM(k->follower) == 6)
		  || (GET_MOB_VNUM(k->follower) == 5)|| (GET_MOB_VNUM(k->follower) == 7))
		c = (c + 1);
	      
	      
	      
	      
	      if (c >= zom_num) 
		{
		  
		  act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
		  return;
		}
	    }
	}
      
      handle_corpse = 1; 
      msg = 12; /* In an array above, you see the message
		   numbers. This 
		   tells what message number to use */
      a = number(0, 400);
      mob_num = 0;
      if (a < 140) 
	mob_num = 5;
      else if (a < 260)
	mob_num = 5;
      else if (a < 350)
	mob_num = 5;
      else if (a < 400)
	mob_num = 4;
      pfail = 3;
      send_to_char("&9&bThe dracolich roars to life!&0\r\n", ch); 
      /* send a message to the caster saying that he succeeded */
      act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
      break;
      
    case SPELL_SUMMON_ELEMENTAL:
      handle_corpse = 0; 
      d = GET_LEVEL(ch);
      if (d < 22)
	zom_num = 1;
      else if (d < 31)
	zom_num = 2;
      else if (d < 41)
	zom_num = 2;
      else if (d < 78)
	zom_num = 2; /* added for possible change for
			game balence*/
      org_room = ch->in_room;
      c = 0;
      for (k = ch->followers; k; k = k->next) 
	{
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) 
	    {
	      for (i=0;i<=3;i++)
		if
		  ((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL)))
		  c = (c + 1);
	      for (i=0;i<=3;i++)
		if
		  ((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL2)))
		  c = (c + 1);
	      for (i=0;i<=3;i++)
		if
		  ((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL3)))
		  c = (c + 1);
	      
	      if (c >= zom_num) 
		{
		  
		  act(mag_summon_fail_msgs[10], FALSE, ch, 0, 0, TO_CHAR);
		  return;
		}
	    }
	}
      
      msg = 13;
      if ((GET_LEVEL(ch)) < 31) 
	{
	  agro_num = 7;
	  mob_num = MOB_MENTAL;
	}
      else if ((GET_LEVEL(ch)) < 41)
	{
	  agro_num = 6;
	  mob_num = MOB_MENTAL2;
	}
      else if ((GET_LEVEL(ch)) < 58)
	{
	  agro_num = 4;
	  mob_num = MOB_MENTAL3;
	}
      else
	{
	  agro_num = 3;
	  mob_num = MOB_MENTAL3;
	}
      a = number(0, 400);
      if (a < 121) 
	b = 0;
      else if (a < 241)
	b = 1;
      else if (a < 361)
	b = 2;
      else if (a < 400)
	b = 3;
      /*b = number(0, 3);*/
      while (b)
	{
	  mob_num++;
	  b--;
	}
      
      mob = read_mobile(mob_num, VIRTUAL); 
      /*reset mob for characters level*/
      reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
      act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
      
      char_to_room(mob, ch->in_room);  
      
      IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
				 carrying anything */
      
      IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
				 anything */
      if (number(0, 101) < agro_num)
	{
	  act(mag_summon_msgs[16], FALSE, ch, 0, mob,
	      TO_ROOM);
	  SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
	}else{
	  
	  SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
						 the caster's
						 orders */
	  add_follower(mob, ch); /* Actually make the mob follow
				    the caster */
	}
      send_to_char("The elemental you summoned appears before you.\r\n", ch); 
      /* send a message to the caster saying that he succeeded */
      return;
      break;
      
    case SPELL_SUMMON_DEMON: 
      
      org_room = ch->in_room;
      c = 0;
      for (k = ch->followers; k; k = k->next) 
	{
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) 
	    {
	      for (i=0;i<=2;i++)
		if
		  ((GET_MOB_VNUM(k->follower) == (i + 25)))
		  c = (c + 1);
	      
	      if (c > 0) 
		{
		  
		  act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
		  return;
		}
	    }
	}
      /* if ((found) || (c = 2)) {
	 act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
	 return;
	 }*/
      
      handle_corpse = 0; 
      
      msg = 14; /* In an array above, you see the message
		   numbers. This 
		   tells what message number to use */
      
      a = number(0, 300);
      mob_num = 0;
      if (a < 151) 
	mob_num = 27;
      else if (a < 251)
	mob_num = 26;
      else
	mob_num = 25;
      
      pfail = 8;
      agro_num = 7;
      send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch); 
      /* send a message to the caster saying that he succeeded */
      act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
      
      mob = read_mobile(mob_num, VIRTUAL);
      reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
      /*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/
      
      char_to_room(mob, ch->in_room);  
      
      IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
				 carrying anything */
      
      IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
				 anything */
      if (number(0, 101) < agro_num)
	{
	  act(mag_summon_msgs[16], FALSE, ch, 0, mob,
	      TO_ROOM);
	  SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
	}else{
	  SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
						 the caster's
						 orders */
	  
	  add_follower(mob, ch); /* Actually make the mob follow
				    the caster */
	}
      return;
      
      break;
      
    case SPELL_SUMMON_GREATER_DEMON: 
      org_room = ch->in_room;
      c = 0;
      for (k = ch->followers; k; k = k->next) 
	{
	  
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) 
	    {
	      
	      for (i=0;i<=1;i++)
		if
		  ((GET_MOB_VNUM(k->follower) == (i + 29)))
		  c = (c + 1);
	      
	      if (c > 0) 
		{
		  
		  act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
		  return;
		}
	    }
	}
      /* if ((found) || (c = 2)) {
	 act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
	 return;
	 }*/
      agro_num = 3;
      handle_corpse = 0; 
      
      msg = 14; /* In an array above, you see the message
		   numbers. This 
		   tells what message number to use */
      
      a = number(0, 200);
      mob_num = 0;
      
      if (a < 151) 
	mob_num = 30;
      else
	mob_num = 29;
      
      
      pfail = 4;
      
      send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch); 
      /* send a message to the caster saying that he succeeded */
      act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
      
      mob = read_mobile(mob_num, VIRTUAL);
      reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
      /*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/
      
      char_to_room(mob, ch->in_room);  
      
      IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
				 carrying anything */
      
      IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
				 anything */
      
      if (number(0, 101) < agro_num)
	{
	  act(mag_summon_msgs[16], FALSE, ch, 0, mob,
	      TO_ROOM);
	  SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
	}else
	  {
	    SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
						   the caster's
						   orders */
	    add_follower(mob, ch); /* Actually make the mob follow
				      the caster */
	  }
      return;
      break;
      
      
      
      
    default:
      return;
a2365 59
  
  if (IS_AFFECTED(ch, AFF_CHARM)) 
    {
      send_to_char("You are too giddy to have any followers!\r\n", ch);
      return;
    }
  if (number(0, 101) < pfail) 
    {
      CORPSE_LEVEL(obj) = 0;
      send_to_char(mag_summon_fail_msgs[fmsg], ch);
      return;
    }
  for (i = 0; i < num; i++) 
    {
      /*finding level of corpse*/
      mob = read_mobile(mob_num, VIRTUAL);
      
      /*reset mob for characters level*/
      reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, obj);
      char_to_room(mob, ch->in_room);
      // VAMPIRS HAVE VAMP TOUCH YOU KNOW BANYAL
      // So do dracos Banyal
      if((mob_num == 14 || mob_num == 4 || mob_num == 5 || mob_num ==6 ||
	  mob_num == 7))
	SET_BIT(AFF3_FLAGS(mob), AFF3_VAMP_TOUCH);
      
      IS_CARRYING_W(mob) = 0;
      IS_CARRYING_N(mob) = 0;
      if (number(0, 101) < agro_num)		
	{
	  act(mag_summon_msgs[16], FALSE, ch, 0, mob,TO_ROOM);
	  SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
	}else{
	  SET_BIT(AFF_FLAGS(mob), AFF_CHARM);
	  add_follower(mob, ch);
	  act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
	}	}
  if (handle_corpse) 
    {
      for (tobj = obj->contains; tobj != NULL; tobj = tobj->next_content)
	tobj->in_obj = obj;
      for (tobj = obj->contains; tobj; tobj = next_obj) 
	{
	  next_obj = tobj->next_content;
	  obj_from_obj(tobj);
	  obj_to_char(tobj, mob);
	  if((GET_OBJ_TYPE(tobj) == ITEM_MONEY)){
	    if ((GET_OBJ_VAL(tobj, 0)+GET_OBJ_VAL(tobj,
						  1)+GET_OBJ_VAL(tobj, 2)+GET_OBJ_VAL(tobj, 3)) > 0){
	      obj_from_char(tobj);
	      GET_PLAT(mob) += GET_OBJ_VAL(tobj, 0);
	      GET_GOLD(mob) += GET_OBJ_VAL(tobj, 1);
	      GET_SILVER(mob) += GET_OBJ_VAL(tobj, 2);
	      GET_COPPER(mob) += GET_OBJ_VAL(tobj, 3);
	      extract_obj(tobj);}
	  }
	}
      extract_obj(obj);
    }}
d2367 8
d2735 4
a2738 1
// $Log$
@


1.7
log
@Chant finishes and wearoff messages.
@
text
@d1 1
d3097 1
@


1.6
log
@Rewrote Continual Light and Darkness to be manual spells to meet our needs.
@
text
@d542 2
a543 1
  
d558 8
a565 1
	    }
@


1.5
log
@When casting minor creation, light objects come lit.
@
text
@a2901 8
  case SPELL_CONTINUAL_LIGHT:
    if (!IS_OBJ_STAT(obj, ITEM_CONT_LIGHT)) {
      SET_BIT(obj->obj_flags.extra_flags, ITEM_CONT_LIGHT);
      /* David Endre 2/9/99 - Fix for Conitnual Light spell...makes it work! */
      world[ch->in_room].light++;
      to_char = "$p glows briefly.";
    }
    break;
a3022 30
    break;
  case SPELL_DARKNESS:
    if (ROOM_AFFECTED(ch->in_room, RAFF_CONTINUAL_LIGHT)) {
      to_char = "You dispel the magical light.";
      to_room = "$n dispels the magical light.";
      REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_CONTINUAL_LIGHT);
      aff = 0;
      world[ch->in_room].light--;
      break;
    }else
      to_char = "You engulf the area in a magical darkness!";
    to_room = "$n engulfs the area in a magical darkness!";
    aff = RAFF_DARKNESS;
    world[ch->in_room].light--;
    ticks = 1;
    break;
  case SPELL_CONTINUAL_LIGHT:
    if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
      to_char = "&8Your magical light dispels the darkness.&0";
      to_room = "&8$n's magical light dispels the darkness.&0";
      REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_DARKNESS);
      aff = 0;
      world[ch->in_room].light++;
      break;
    }else
      to_char = "&8The room magically lights up!&0";
    to_room = "&8The room magically lights up!&0";
    aff = RAFF_CONTINUAL_LIGHT;
    world[ch->in_room].light++;
    ticks = 1;
@


1.4
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d574 4
d3038 1
d3044 1
d3053 1
d3059 1
@


1.3
log
@Fixes some of continual light.
@
text
@d2006 1
a2006 1
#define GET_LDESC(mob)     ((mob)->player.long_descr)
d2320 1
a2320 1
      strcpy(mob->player.long_descr, GET_NAME(ch));
@


1.2
log
@Indented entire file
@
text
@d2901 2
@


1.1
log
@Initial revision
@
text
@d1 9
a9 10
/*
************************************************************************
*   File: magic.c                                       Part of CircleMUD *
*  Usage: low-level functions for magic; spell template code              *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d46 1
a46 1
	      void *vict_obj, int j);
d49 1
a49 1
	         int damage, int weapontype);
d51 1
a51 1
    struct obj_data * obj);
d68 18
a85 18
    case FIRE_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_FIRE))
	return TRUE;
      break;
    case COLD_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_COLD))
	return TRUE;
      break;
    case AIR_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_AIR))
	return TRUE;
      break;
    case EARTH_DAMAGE:
      if(AFF2_FLAGGED(ch, AFF2_PROT_EARTH))
	return TRUE;
      break;
    default:
      return FALSE;
d444 1
a444 1

d447 2
a448 2
	&& victim->guarded_by 
	&& get_char_room_vis(victim->guarded_by,GET_NAME(victim))==victim) {
d450 2
a451 2
	&& !CHECK_WAIT(victim->guarded_by) 
	&& GET_POS(victim->guarded_by) >= POS_FIGHTING) {
d467 1
a467 1

d469 7
a475 7
/* I uncommented the old saves and commented nech new ones to test Banyal
 * if (IS_NPC(ch)) 
 *   save = saving_throws[CLASS_WARRIOR][type][(int) GET_LEVEL(ch)];
 * else
 *   save = saving_throws[(int) GET_CLASS(ch)][type][(int) GET_LEVEL(ch)];
 */

d481 3
a483 3
  */
/*
  switch(type) {
d485 2
a486 2
      sprintf(buf, "PARALYSIS");
      break;
d488 2
a489 2
      sprintf(buf, "ROD");
      break;
d491 2
a492 2
      sprintf(buf, "BREATH");
      break;
d494 2
a495 2
      sprintf(buf, "PETRIFICATION");
      break;
d497 2
a498 2
      sprintf(buf, "SPELL");
      break;
d500 3
a502 3
      break;
  }
*/
d513 1
a513 1
Can be used by any affect really with minor code change
d517 6
a522 3
struct affected_type *af;
struct affected_type *tmp;
	for (af = i->affected; af; af = tmp) 
d524 4
a527 8
		tmp = af->next;
		if (af->type == 52)/*number for stone skin*/
		{
			if (af->modifier > 1)
				af->modifier--;	
			else
				affect_remove(i, af);/*remove bit*/
		}
d529 3
a531 2


d542 1
a542 1

d562 19
a580 19
		next_raff = raff->next;

		raff->timer--;

		if (raff->timer <= 0) {
			/* this room affection has expired */
			if (ROOM_AFFECTED(raff->room, raff->affection)){
			send_to_room(spell_wear_off_msg[raff->spell],
				raff->room);
			send_to_room("\r\n", raff->room);}

			/* remove the affection */
			REMOVE_BIT(world[(int)raff->room].room_affections,
				raff->affection);
			REMOVE_FROM_LIST(raff, raff_list, next)
			free(raff);
		}
	}

d597 1
a597 1

d657 1
a657 1
		     int spellnum, int savetype)
d661 1
a661 1

d664 1
a664 1

d671 1
a671 1

d673 29
a701 29
*******The defines are as such*******:
#define SD_SPELL(i) spell_dam_info[i].spell
#define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
#define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
#define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
#define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
#define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
#define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
#define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
#define SD_BONUS(i) spell_dam_info[i].max_bonus
#define SD_NPC_STATIC...
#define SD_PC_STATIC...

****General****
- If SD_INTERN_DAM(i) = FALSE then it will look for a internal switch
- Otherwise it will go through a loop using the values in the array spell_dam_info
- If you wish to have Differeng class Affects simply add a class and put in its factor
**results**
    pc vs pc - SD_PC_NO_DICE * SD_PC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/4)
    pc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    npc vs npc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    npc vs pc - SD_NPC_NO_DICE * SD_NPC_NO_FACE + (if using bonus) MIN(SD_USE_BONUS, (int)lvl/2)
    all npc vs x is also npc * SD_NPC_REDUCE_FACTOR
    Add Statics onto value
Proky
*/


    if (SD_INTERN_DAM(spellnum))
d703 2
a704 2
        if (((!IS_NPC(ch))  && (!IS_NPC(victim))) || 
   (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))))
d706 7
a712 7
            dam = dice(SD_PC_NO_DICE(spellnum), SD_PC_NO_FACE(spellnum)) + SD_PC_STATIC(spellnum);
            if (SD_USE_BONUS(spellnum))                
dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/4)));
        else
	dam = dam + MIN(SD_BONUS(spellnum),
GET_LEVEL(ch)*SD_LVL_MULT(spellnum));

d714 2
a715 2
        {/*any other*/
           dam = dice(SD_NPC_NO_DICE(spellnum), SD_NPC_NO_FACE(spellnum)) + SD_NPC_STATIC(spellnum);
d717 6
a722 6
         dam = dam + MIN(SD_BONUS(spellnum), ((int) (GET_LEVEL(ch)/2)));
        else
dam = dam + MIN(SD_BONUS(spellnum),
GET_LEVEL(ch)*SD_LVL_MULT(spellnum));
	}
        if (IS_NPC(ch))
d724 2
a725 2
           dam = (int)((SD_NPC_REDUCE_FACTOR(spellnum) * dam)/100);

d728 4
d733 1
a733 9
/*effectivly anything following will copy over online damages*/
/*feel free to copy over what the online stuff will do*/  






 switch (spellnum) {
d735 33
a767 33

    case SPELL_EXORCISM:
      if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
        send_to_char("That spell only has effect on demonic entities.\r\n",ch);
        return;
      }
      if(GET_LEVEL(victim) < 40 && !mag_savingthrow(victim,SAVING_SPELL)
        && number(1,100) > 70) {
        act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
        act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
        if(FIGHTING(victim))
          stop_fighting(victim);
        extract_char(victim);
	return;
      }
	dam = 15 * GET_LEVEL(ch);
      break;
    case SPELL_LESSER_EXORCISM:
      if(!IS_NPC(victim) || GET_SPECIES(victim) != SPECIES_DEMON) {
        send_to_char("That spell only has effect on demonic entities.\r\n",ch);
        return;
      }
      if(GET_LEVEL(victim) < 30 && !mag_savingthrow(victim,SAVING_SPELL)
        && number(1,100) > 50) {
        act("$N &7&blets out a massive howl as $E is banished by $n's&7&b command.&0",FALSE,ch,0,victim,TO_ROOM);
        act("$N &7&blets out a massive howl as $E is banished by your holy might.&0",FALSE,ch,0,victim,TO_CHAR);
        if(FIGHTING(victim))
          stop_fighting(victim);
        extract_char(victim);
	return;
      }
	dam = 10 * GET_LEVEL(ch);
      break;
d769 22
a790 22
	go above MAX_SPELLS. Nechtrous*/
    case SPELL_FIRE_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_FROST_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_GAS_BREATH:
        dam = dice(10,10)+250;
      break;
    case SPELL_LIGHTNING_BREATH:
        dam = dice(10,10)+350;
      break;
    case SPELL_ACID_BREATH:
        dam = dice(10,10)+200;
      break;

    case SPELL_UNHOLY_WORD:
      dam = dice(10,20) + (GET_LEVEL(ch)*2);
      break;
    case SPELL_HOLY_WORD:
      if (GET_CLASS(ch) == CLASS_PRIEST)
d792 1
a792 1
      else
a793 8
      break;

    case SPELL_DISPEL_EVIL:
        if (IS_GOOD(victim)) {
            act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
            dam = 0;
        return;
        }
d795 14
a808 6
    case SPELL_DISPEL_GOOD:
        if (IS_EVIL(victim)) {
            act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
            dam = 0;
            return;
        }
d810 1
a810 1

d815 1
a815 1

d817 8
a824 8
     dam = dice(4, 50) + 30;
     if (GET_SPECIES(victim) != SPECIES_UNDEAD) {
       act("$N has far too much life for you to harm it!",
FALSE,ch,0,victim,TO_CHAR);
       dam=0;
       return;
     }
     break;   
d827 3
a829 3
        dam = 20;
	if (GET_LEVEL(ch) < 20)
        dam = dice(1, 20);
d832 1
a832 1

d838 3
a840 3

/*switch through classes*/
    /*switch (GET_CLASS(ch))
d843 1
a843 1
        dam = dam;
d846 2
a847 2
        dam = (int)((95 * dam)/100);
        break;
d849 2
a850 2
*/

d852 1
a852 1

d855 1
a855 1
       (GET_LEVEL(ch) < LVL_IMMORT))
d857 1
a857 1

d861 1
a861 1

d865 1
a865 1

d873 1
a873 1

d902 1
a902 1
*/
d907 1
a907 1
		      int spellnum, int savetype)
d913 1
a913 1
	refresh=TRUE;
d917 1
a917 1

d924 1
a924 1

d933 1
a933 1

d935 1
a935 1

d944 1
a944 1

d949 1
a949 1

d953 1
a953 1

d958 1
a958 1

d962 1
a962 1

d967 1
a967 1

d971 1
a971 1

d976 1
a976 1

d980 1
a980 1

d985 1
a985 1

d1021 1
a1021 1
   if(number(0, 100) > 50)
d1024 8
a1031 8
    refresh = FALSE;
    af[0].bitvector = AFF_MAJOR_PARA;
    af[0].duration = 3;
    to_room="&2&bA slew of thick branches and vines burst from the ground, entangling $n!&0";
    to_vict="&2&bA slew of thick branches and vines burst from the ground, entangling you!&0";
    break;
   }else
   refresh = FALSE;
d1044 1
a1044 1

d1061 1
a1061 1

d1066 1
a1066 1

d1072 1
a1072 1

d1078 1
a1078 1

d1081 1
a1081 1
    af[1].modifier = -3;
d1083 1
a1083 1
    af[1].modifier = -20;
d1085 1
a1085 1
 
d1088 1
a1088 1
    af[2].modifier = -3;
d1090 1
a1090 1
    af[2].modifier = -20;
d1095 1
a1095 1

d1101 1
a1101 1

d1108 1
a1108 1

d1113 1
a1113 1
   
d1120 1
a1120 1

d1125 1
a1125 1

d1132 1
a1132 1

d1139 1
a1139 1

d1146 1
a1146 1

d1152 1
a1152 1

d1177 1
a1177 1

d1182 1
a1182 1

d1189 1
a1189 1

d1197 1
a1197 1

d1205 1
a1205 1

d1214 1
a1214 1

d1239 1
a1239 1

d1247 1
a1247 1

d1259 1
a1259 1

d1284 1
a1284 1
     return;
d1290 1
a1290 1
    af[0].modifier = -1;
d1292 1
a1292 1
    af[0].modifier = -20;
d1297 1
a1297 1

d1304 1
a1304 1

d1314 1
a1314 1

d1321 1
a1321 1

d1331 1
a1331 1

d1333 1
a1333 1

d1353 4
a1356 4
  if(IS_AFFECTED3(victim, AFF3_ENLARGE))
   return;
  if(IS_NPC(victim))
   return;
d1361 1
a1361 1

d1375 4
a1378 4
   if(IS_AFFECTED3(victim, AFF3_REDUCE))
   return;
   if(IS_NPC(victim))
   return;
d1408 5
a1412 5
	af[0].bitvector = AFF_HASTE;
	to_vict = "&1You start to move with uncanny speed!&0";
	to_room = "&1$n starts to move with uncanny speed!&0";
	break;

d1414 6
a1419 6
	  af[0].duration = 5;
	  af[0].bitvector = AFF_BLUR;
	  to_vict = "&7The world blurs as you start moving with unnatural speed&0";
	  to_room = "&7$n's image blurs in unnatural speed!&0";
	  break;

d1421 6
a1426 6
	  af[0].duration = 10;
	  af[0].bitvector = AFF_COMP_LANG;
	  to_vict = "&8You feel you knowledge of Hubis' languages improving!&0";
	  break;


d1435 1
a1435 1

d1438 1
a1438 1

d1443 1
a1443 1

d1453 1
a1453 1

d1457 1
a1457 1

d1473 1
a1473 1

d1478 1
a1478 1

d1482 1
a1482 1

d1488 1
a1488 1

d1503 1
a1503 1

d1509 1
a1509 1

d1515 1
a1515 1

d1521 1
a1521 1

d1532 1
a1532 1

d1544 1
a1544 1

d1552 1
a1552 1

d1558 1
a1558 1

d1566 1
a1566 1

d1576 1
a1576 1

d1580 1
a1580 1

d1594 1
a1594 1

d1598 1
a1598 1

d1605 1
a1605 1

d1613 1
a1613 1

d1615 1
a1615 1
	af[0].location = APPLY_STR;
d1621 1
a1621 1

d1627 1
a1627 1
	
d1633 1
a1633 1

d1641 2
a1642 2

	case SPELL_FARSEE:
d1648 1
a1648 1

d1650 1
a1650 1

d1659 2
a1660 2
	send_to_char(NOEFFECT, ch);
	return;
d1662 10
a1671 10

  /*
   * If the victim is already affected by this spell, and the spell does
   * not have an accumulative effect, then fail the spell.
   */
  if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect||refresh)) {
    send_to_char(NOEFFECT, ch);
    return;
  }

d1673 23
a1695 23
        if (spellnum == aff->type && aff->duration == -1)
          is_innate=TRUE;
    }

    if (affected_by_spell(victim,spellnum) && is_innate) {
      send_to_char(NOEFFECT, ch);
      return;
    }

  if(!affected_by_spell(victim,spellnum))
  {
  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);
  }

  for (i = 0; i < MAX_SPELL_AFFECTS; i++)
    if (af[i].bitvector || af[i].bitvector2 || af[i].bitvector3 || (af[i].location != APPLY_NONE))
      affect_join(victim, af+i, accum_duration, FALSE, accum_affect, FALSE, refresh);

  if (spellnum == SPELL_REMOVE_POISON)
    check_regen_rates(victim);	/* speed up regen rate immediately */
d1708 1
a1708 1
    case SPELL_GROUP_HEAL:
d1737 1
a1737 1

d1740 1
a1740 1

d1743 31
a1773 31
for (tch = world[ch->in_room].people; tch; tch = next_tch)
        {
                next_tch = tch->next_in_room;
                group = 0;
 if (tch->in_room != ch->in_room)
      continue;
if (ch == tch)
      continue;    
       
                if (is_grouped(ch, tch))
                   perform_mag_groups(level, ch, tch, spellnum, savetype);
}
 /*           if (ch->master != NULL)
    k = ch->master;
  else
    k = ch;
  for (f = k->followers; f; f = f_next) {
    f_next = f->next;
    tch = f->follower;
    if (tch->in_room != ch->in_room)
      continue;
   // if (!IS_AFFECTED(tch, AFF_GROUP))
      continue;
    if (ch == tch)
      continue;
    if (is_grouped(ch, tch))   
    perform_mag_groups(level, ch, tch, spellnum, savetype);
  }

  if ((k != ch) && IS_AFFECTED(k, AFF_GROUP))
    perform_mag_groups(level, ch, k, spellnum, savetype);       */
d1787 1
a1787 1

d1792 1
a1792 1

d1806 1
a1806 1
*/
d1817 1
a1817 1

d1828 3
a1830 3
	  to_char = "&6&bYou release a &0&4chilling&6&b stream of air at your foes.&0";
	  to_room = "&6&b$n&6&b releases a &0&4chilling&6&b stream of air.&0";
          break;
d1832 3
a1834 3
	  to_char = "&9&bYou invoke a word of unholy power!&0";
	  to_room = "&9&b$n &9&butters a word of unholy power!&0";
	  break;
d1836 3
a1838 3
	  to_char = "&7&bYou invoke a word of holy power!&0";
	  to_room = "&7&b$n &7&butters a word of holy power!&0";  
	  break;
d1840 3
a1842 3
	  to_char = "&1You conjure up a controlled shower of meteors to crush your foe!&0";
	  to_room = "$n&1 conjures a controlled shower of flaming meteors!&0";
	  break;
d1844 3
a1846 3
	  to_char = "&6&bYou conjure thousands of razor sharp ice shards to massacre your foe!&0";
	  to_room = "$n &6&bconjures thousands of razor sharp ice shards to massacre $s foe!&0";
	  break;
d1848 3
a1850 3
	  to_char = "&6&bYou crush your foes under a relentless ice storm!&0";
	  to_room = "$n&6&b crushes his foes under a relentless ice storm!&0";
	  break;
d1852 3
a1854 3
	  to_char  = "&0&2You cackle as your &bwave of gases&0 &2torches your enemies!&0";
	  to_room = "&0$n&2 cackles as his &bwave of gases&0&2 torches his enemies!&0";
	  break;
d1856 3
a1858 3
	  to_char = "&4&bYou send powerful bolts of lightning from your body...&0";
	  to_room = "&4&b$n&4&b sends powerful bolts of lightning $s his foes...&0";
	  break;
d1860 3
a1862 3
	  to_char = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
	  to_room = "&1A large hole opens in the &3earth&1 nearby spouting a gout of &bhellfire&0&1 and &9&bbrimstone!&0";
	  break;
d1864 5
a1868 5
	  to_char = "You conjure a gout of flame to sweep through the area.";
	  to_room = "$n waves his hands as a gout of flame floods into the area.";
	  break;
}

d1873 1
a1873 1

d1884 62
a1945 62


	for (tch = world[ch->in_room].people; tch; tch = next_tch) 
	{
		next_tch = tch->next_in_room;
		group = 0;

	
		if (is_grouped(ch, tch))
			continue;
				


    /*
     * The skips: 1: the caster
     *            2: immortals
     *            3: if no pk on this mud, skips over all players
     *            4: pets (charmed NPCs)
     * players can only hit players in CRIMEOK rooms 4) players can only hit
     * charmed mobs in CRIMEOK rooms
     */ 
		if (PRF_FLAGGED(ch, PRF_NICEAREA))
                if (!IS_NPC(tch))
		if ((zone_table[world[ch->in_room].zone].number == 147) ||
                   (zone_table[world[ch->in_room].zone].number == 320) ||
                     (zone_table[world[ch->in_room].zone].number == 305) ||
                          (zone_table[world[ch->in_room].zone].number == 250) ||
(zone_table[world[ch->in_room].zone].number == 257) || 
 (zone_table[world[ch->in_room].zone].number == 57))
 if (GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(tch))
continue;

    if (tch == ch)
      continue;
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (!roomaffect_allowed && !IS_NPC(ch) && !IS_NPC(tch))
      continue;
    /* WTF was this? remoevd by nech
    if (!IS_NPC(ch) && IS_NPC(tch))
      continue;
   */
/* mobs done area other mobs unless pets Banyal */
   if (IS_NPC(ch) && IS_NPC(tch) && !MOB_FLAGGED (ch, MOB_PET) &&
    !MOB_FLAGGED (tch, MOB_PET))
     continue;
     if (spellnum == SPELL_UNHOLY_WORD && GET_ALIGNMENT(tch) < 500)
       continue;
     if (spellnum == SPELL_HOLY_WORD && GET_ALIGNMENT(tch) > -500)
       continue;
     if( spellnum!=SPELL_DISPEL_MAGIC && 
        ((IS_AFFECTED2(tch, AFF2_MINOR_GLOBE) && min_spell_level <= 3) ||
        (IS_AFFECTED2(tch, AFF2_MAJOR_GLOBE) && min_spell_level <= 6))){
       act("&1&bThe shimmering globe around your body flares as the spell flows around it.&0", FALSE, ch,0,tch,TO_VICT);
       act("&1&bThe shimmering globe around $N&1&b's body flares as your spell flows around it.&0", FALSE,ch,0,tch,TO_CHAR);
       act("&1&bThe shimmering globe around $N&1&b's body flares as $n&1&b's spell flows around it.&0",FALSE,ch,0,tch,TO_NOTVICT);
       continue;
     }


    mag_damage(GET_LEVEL(ch), ch, tch, spellnum, 1);
  }
d1974 1
a1974 1
"&1$n summons forth $N and it doesn't look to impressed!&0\r\n"
d2010 1
a2010 1
		      int spellnum, int savetype)
d2017 1
a2017 1
bool got_draco =  FALSE;
d2021 1
a2021 1
int agro_num = 0;
d2026 13
a2038 5

	if (ch == NULL)
		return;/*if no character get out*/

	switch (spellnum) 
d2040 1
a2040 9
	case SPELL_ANIMATE_DEAD:
		/*PLEASE NOTE PLEASE NOTE PLEASE NOTE PLEASE NOTE*/
		/*THIS CODE WILL NEVER BE GOOD UNTIL THERE IS A SKILL RAISE UNDEAD,
		OR A SPELL SPHERE THAT CAN BE ADDED*/

		if ((obj == NULL) || (GET_OBJ_TYPE(obj) != ITEM_CONTAINER) 
||	((GET_OBJ_VAL(obj, 3)) < 0)) 
		{
			act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
d2042 2
a2043 2
		}
/*worth of mobs:
d2049 9
a2057 9
	*/
    if (CORPSE_LEVEL(obj) > (GET_LEVEL(ch) + 5))
    {
        send_to_char("Don't think you could handle that corpse.\r\n", ch);
        return;
    }
    d  = 0;

    if (CORPSE_LEVEL(obj)  >= 30)
d2059 6
a2064 6
        {
			if (CORPSE_LEVEL(obj) < 50)
		    {
		        if (number(1, 101) >= 70)                                        
                    got_draco = TRUE;		
            }
d2066 1
a2066 1
            {
d2068 4
a2071 4
                got_draco = TRUE;
            }                
        }
    if (GET_LEVEL(ch) > LVL_GRGOD)
d2073 9
a2081 9
            got_draco = TRUE;


    zom_num = (int)(GET_LEVEL(ch)/3);/*gives lvl21 = 7, lvl30 = 10, lvl50 = 16*/
	org_room = ch->in_room;
		/*c will = the number value of followers*/
	c = 0;

	for (k = ch->followers; k; k = k->next)		
d2083 36
a2118 34
	    if ((IS_AFFECTED(k->follower, AFF_CHARM)) && IS_NPC(k->follower)) 
		{				/* found = TRUE;*/
			switch(GET_MOB_VNUM(k->follower))
			{
			case MOB_ZOMBIE:
				c++;
				break;
			case (MOB_ZOMBIE +1):/*specture*/
				c=c+4;
				break;
			case (MOB_ZOMBIE +2):/*skeleton*/
				c++;
				break;
			case (MOB_ZOMBIE +3):/*vampire*/
				c=c+5;
				got_good = TRUE;
			    break;
			case (MOB_ZOMBIE +4):/*wraith*/
				c=c+3;
				got_good = TRUE;
				break;
		    case (MOB_ZOMBIE +5):/*lich*/
				c=c+5;
				got_good = TRUE;
				break;
			case (4):/*big draco*/
				d = d + 2;
				break;
			case (5):/*small draco*/
				d = d + 1;
				break;
			}
					
		    if (got_draco)
d2120 2
a2121 6
			    if (d >= 2)
                {
				    act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
				    return;
                }

d2123 7
a2129 7
		    else if((c >= zom_num) || ((got_good) && ((c + 5) >= zom_num))) 
		    {/*basically that small equation stops people having two GOOD mobs then
		 getting a heap of small mobs*/
			    act(mag_summon_fail_msgs[9], FALSE, ch, 0, 0, TO_CHAR);
			    return;
			}

d2131 2
d2134 20
a2153 20

/*	sprintf(buf, "number of c atm is %d \r\n", c);
	send_to_char(buf, ch);*/
	handle_corpse = 1;
	msg = 12;
	mob_num = MOB_ZOMBIE;

		/*ok here we handle what mob he going to get*/
		/*this has to do on level of corpse*/
		/*I am trusting at this point that the obj IS a corpse*/
		/*spectre 20 +
		  wraith 30 +
		  vampire 40 +
		  lich 50+*/
	i = 0;c = 0;b = 0;/*bonus holder*/	
	if (CORPSE_LEVEL(obj) == 0)
	{
		pfail = 101;
		fmsg = 6;
		break;
d2155 1
a2155 1
	if (CORPSE_LEVEL(obj) < 20)
d2157 6
a2162 6
		a = number(0, 2);
		if (a != 2)
			mob_num = mob_num + 2;
        agro_num = 5;		
    }
	else if (CORPSE_LEVEL(obj) < 30)
d2164 8
a2171 8
		a = number(0, 9);
		if (GET_LEVEL(ch) > 30)
			a++;
		if (a >= 8)
			mob_num++;/*spectre*/
		else if(a > 6)
			mob_num = mob_num + 2;
        agro_num = 4;	
d2173 93
a2265 21
	{/*zombie, skeleton, spectre, wraith*/
		a = number(0, 20);
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
			/*if sorcerer corpse add to chance of wraith*/
			{
				i =  2;
			}
		if (GET_LEVEL(ch) > 30)
			i++;
		if (GET_LEVEL(ch) > 55)
			i++;
		if (GET_LEVEL(ch) > 60)
			i++;
		if ((a + i) >= 19)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 13)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 9)
			mob_num = mob_num + 2;/*skeleton*/
        agro_num = 3;
d2267 12
a2278 4
	else if (CORPSE_LEVEL(obj) < 49)
	{/*zombie, skeleton, spectre, wraith, vampire*/
		a = number(0, 40);
		b = number(0, 40);
d2280 3
a2282 83
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
				i = 2;
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
				c = 2;
		if (GET_LEVEL(ch) > 30)
		{
			c++;
			i++;
		}if (GET_LEVEL(ch) > 50)
		{
			c++;c++;
			i++;
		}if (GET_LEVEL(ch) > 60)
		{
			c++;c++;
			c++;
			i++;
		}
		if ((b + c) >= 37)
			mob_num = mob_num + 3;/*vampire*/
		else if ((a + i) > 38)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 30)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 15)
			mob_num = mob_num + 2;/*skeleton*/

        agro_num = 2;
	}
	else
	{
	    a = number(0, 40);
	   	b = number(0, 40);
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_MAGIC_USER)
				i = 2;
		if (GET_OBJ_MOB_FROM(obj))/*make sure not pc corpse*/
			if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.class == CLASS_WARRIOR)
				c = 2;
		if (GET_LEVEL(ch) > 30)
		{
			c++;
			i++;
		}if (GET_LEVEL(ch) > 50)
		{
			c++;c++;
			i++;
		}if (GET_LEVEL(ch) > 60)
		{
			c++;c++;
			c++;
			i++;
		}
		if ((b + ((int)((c+i)/2))) >= 40)
			mob_num = mob_num + 5;/*lich*/
		else if ((b + c) >= 36)
			mob_num = mob_num + 3;/*vampire*/
		else if ((a + i) > 36)
			mob_num = mob_num + 4;/*wraith*/
		else if (a > 30)
			mob_num = mob_num + 1;/*spectre*/
		else if (a > 15)
			mob_num = mob_num + 2;/*skeleton*/
    agro_num = 1;
	}
    msg = 2;
/*ok if got draco drop whatever you got and make a draco*/
    if (got_draco)
    {
        if (CORPSE_LEVEL(obj) < 50)
        {
            mob_num = 5;
            agro_num = 5;
        }else
        {
            mob_num = 4;
            agro_num = 5;

        }
    msg = 12;
    }
d2284 15
a2298 15
    agro_num = (agro_num) + 2*(MAX(0, (CORPSE_LEVEL(obj) - GET_LEVEL(ch))));
	pfail = 4;
	fmsg = 3;
	break;
	case SPELL_CLONE: /*Banyal was here  */
	  
		handle_corpse = 0; 
		msg = 12;
		mob_num = 69;
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next) 
		{
			if (org_room == k->follower->in_room)
			if ((IS_AFFECTED(k->follower, AFF_CHARM)) && (GET_MOB_VNUM(k->follower) == MOB_CLONE)) 
d2300 8
a2307 8
			/* found = TRUE;*/
				c = (c + 1);
		/* if ((found) || (c = 3)) {*/
				if (c > 0) 
				{
					act(mag_summon_fail_msgs[13], FALSE, ch, 0, 0, TO_CHAR);
					return;
				}
d2309 10
a2318 10
		}

		mob = read_mobile(mob_num, VIRTUAL);
	
		

		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
		char_to_room(mob, ch->in_room);
		strcpy(GET_NAME(mob), GET_NAME(ch));
		strcpy(mob->player.short_descr, GET_NAME(ch)/*("%s stands here.", GET_NAME(ch))*/);
d2320 29
a2348 24
		strcpy(mob->player.long_descr, GET_NAME(ch));
	  /*strcpy(mob->player.description, GET_NAME(ch));
	  strcpy(mob->player.species, GET_RACE(ch));*/ /*dammit need fixin later Banyal*/
	
	/*strcpy(mob->player.keyword, GET_NAME(ch));*/
		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry anything */

		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow the caster */
		send_to_char("&7You clone yourself into a magical servent&0.\r\n", ch); 
              /* send a message to the caster saying that he succeeded */
		return;
		break;
	
	case SPELL_SUMMON_DRACOLICH: 
	if ((GET_OBJ_TYPE(obj) != ITEM_CONTAINER) || (!GET_OBJ_VAL(obj, 3))) 
		{
			act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
			return;
		}
	if (mob_proto[GET_OBJ_MOB_FROM(obj)].player.race != SPECIES_DRAGON)
d2350 2
a2351 2
		send_to_char("You need a better corpse then that for a dracolich!!\r\n", ch);
		return;
d2353 19
a2371 12
    if (CORPSE_LEVEL(obj) < 50)
    {
	    send_to_char("yYou need a better corpse then that for a dracolich!!\r\n", ch);
        return;
    }
		zom_num = 1;

	if (GET_LEVEL(ch) >= 60)
		zom_num = 2;
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next) 
d2373 3
a2375 17
				if (IS_AFFECTED(k->follower, AFF_CHARM)) 
				{

					if ((GET_MOB_VNUM(k->follower) == 4) || (GET_MOB_VNUM(k->follower) == 6)
						|| (GET_MOB_VNUM(k->follower) == 5)|| (GET_MOB_VNUM(k->follower) == 7))
					c = (c + 1);
				
					
					
						
					if (c >= zom_num) 
					{

act(mag_summon_fail_msgs[8], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
d2377 55
a2431 36
            
		handle_corpse = 1; 
		msg = 12; /* In an array above, you see the message
numbers. This 
                 tells what message number to use */
		a = number(0, 400);
		mob_num = 0;
		if (a < 140) 
			mob_num = 5;
		else if (a < 260)
			mob_num = 5;
		else if (a < 350)
			mob_num = 5;
		else if (a < 400)
			mob_num = 4;
		pfail = 3;
		send_to_char("&9&bThe dracolich roars to life!&0\r\n", ch); 
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
		break;

	case SPELL_SUMMON_ELEMENTAL:
		handle_corpse = 0; 
		d = GET_LEVEL(ch);
		if (d < 22)
			zom_num = 1;
		else if (d < 31)
			zom_num = 2;
		else if (d < 41)
			zom_num = 2;
		else if (d < 78)
			zom_num = 2; /* added for possible change for
game balence*/
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next) 
d2433 3
a2435 22
				if (IS_AFFECTED(k->follower, AFF_CHARM)) 
				{
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL)))
							c = (c + 1);
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL2)))
							c = (c + 1);
					for (i=0;i<=3;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + MOB_MENTAL3)))
							c = (c + 1);
	
					if (c >= zom_num) 
					{

act(mag_summon_fail_msgs[10], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
d2437 84
a2520 3

		msg = 13;
		if ((GET_LEVEL(ch)) < 31) 
d2522 3
a2524 2
			agro_num = 7;
			mob_num = MOB_MENTAL;
d2526 3
a2528 83
		else if ((GET_LEVEL(ch)) < 41)
		{
			agro_num = 6;
			mob_num = MOB_MENTAL2;
		}
		else if ((GET_LEVEL(ch)) < 58)
		{
			agro_num = 4;
			mob_num = MOB_MENTAL3;
		}
		else
		{
			agro_num = 3;
			mob_num = MOB_MENTAL3;
		}
		a = number(0, 400);
		if (a < 121) 
			b = 0;
		else if (a < 241)
			b = 1;
		else if (a < 361)
			b = 2;
		else if (a < 400)
			b = 3;
	/*b = number(0, 3);*/
		while (b)
		{
			mob_num++;
			b--;
		}
		
		mob = read_mobile(mob_num, VIRTUAL); 
		/*reset mob for characters level*/
		reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		char_to_room(mob, ch->in_room);  

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */
if (number(0, 101) < agro_num)
		{
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{

		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		send_to_char("The elemental you summoned appears before you.\r\n", ch); 
              /* send a message to the caster saying that he succeeded */
		return;
		break;
	
	case SPELL_SUMMON_DEMON: 
   
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next) 
		{
				if (IS_AFFECTED(k->follower, AFF_CHARM)) 
				{
					for (i=0;i<=2;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + 25)))
							c = (c + 1);

					if (c > 0) 
					{

act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
		}
   /* if ((found) || (c = 2)) {
d2531 66
a2596 35
	}*/
          
		handle_corpse = 0; 

		msg = 14; /* In an array above, you see the message
numbers. This 
                 tells what message number to use */

		a = number(0, 300);
		mob_num = 0;
		if (a < 151) 
			mob_num = 27;
		else if (a < 251)
			mob_num = 26;
		else
			mob_num = 25;

		pfail = 8;
	agro_num = 7;
		send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch); 
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		mob = read_mobile(mob_num, VIRTUAL);
	 reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
/*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/

		char_to_room(mob, ch->in_room);  

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */
if (number(0, 101) < agro_num)
d2598 3
a2600 36
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */

		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		return;
   
		break;

	case SPELL_SUMMON_GREATER_DEMON: 
		org_room = ch->in_room;
		c = 0;
		for (k = ch->followers; k; k = k->next) 
		{

				if (IS_AFFECTED(k->follower, AFF_CHARM)) 
				{

						for (i=0;i<=1;i++)
						if
((GET_MOB_VNUM(k->follower) == (i + 29)))
							c = (c + 1);

					if (c > 0) 
					{

act(mag_summon_fail_msgs[11], FALSE, ch, 0, 0, TO_CHAR);
						return;
					}
				}
d2602 3
a2604 1
   /* if ((found) || (c = 2)) {
d2607 36
a2642 59
	}*/
          agro_num = 3;
		handle_corpse = 0; 

		msg = 14; /* In an array above, you see the message
numbers. This 
                 tells what message number to use */

		a = number(0, 200);
		mob_num = 0;

		if (a < 151) 
			mob_num = 30;
		else
			mob_num = 29;


		pfail = 4;

		send_to_char("&1&bIn a Burst of flames a demon appears before you!&0\r\n", ch); 
              /* send a message to the caster saying that he succeeded */
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);

		mob = read_mobile(mob_num, VIRTUAL);
	 reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, NULL);
/*	act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);*/

		char_to_room(mob, ch->in_room);  

		IS_CARRYING_W(mob) = 0; /* Makes sure the mob isn't
carrying anything */

		IS_CARRYING_N(mob) = 0; /* Makes sure the mob can't carry
anything */
	
		if (number(0, 101) < agro_num)
		{
			act(mag_summon_msgs[16], FALSE, ch, 0, mob,
TO_ROOM);
			SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
		}else
		{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM); /* Makes the mob take
the caster's
                                           orders */
		add_follower(mob, ch); /* Actually make the mob follow
the caster */
			}
		return;
		break;



	  
		default:
		return;
	}

	if (IS_AFFECTED(ch, AFF_CHARM)) 
d2644 49
a2692 4
		send_to_char("You are too giddy to have any followers!\r\n", ch);
		return;
	}
	if (number(0, 101) < pfail) 
d2694 12
a2705 5
			CORPSE_LEVEL(obj) = 0;
		send_to_char(mag_summon_fail_msgs[fmsg], ch);
		return;
	}
	for (i = 0; i < num; i++) 
d2707 13
a2719 41
		/*finding level of corpse*/
		mob = read_mobile(mob_num, VIRTUAL);
		
		/*reset mob for characters level*/
		reset_mob(mob, GET_LEVEL(ch), mob_num, spellnum, obj);
		char_to_room(mob, ch->in_room);
// VAMPIRS HAVE VAMP TOUCH YOU KNOW BANYAL
// So do dracos Banyal
if((mob_num == 14 || mob_num == 4 || mob_num == 5 || mob_num ==6 ||
 mob_num == 7))
SET_BIT(AFF3_FLAGS(mob), AFF3_VAMP_TOUCH);
		
	IS_CARRYING_W(mob) = 0;
		IS_CARRYING_N(mob) = 0;
if (number(0, 101) < agro_num)		
{
act(mag_summon_msgs[16], FALSE, ch, 0, mob,TO_ROOM);
SET_BIT(MOB_FLAGS(mob), MOB_AGGRESSIVE);
}else{
		SET_BIT(AFF_FLAGS(mob), AFF_CHARM);
		add_follower(mob, ch);
		act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
}	}
if (handle_corpse) 
	{
for (tobj = obj->contains; tobj != NULL; tobj = tobj->next_content)
tobj->in_obj = obj;
		for (tobj = obj->contains; tobj; tobj = next_obj) 
		{
			next_obj = tobj->next_content;
			obj_from_obj(tobj);
			obj_to_char(tobj, mob);
			if((GET_OBJ_TYPE(tobj) == ITEM_MONEY)){
			if ((GET_OBJ_VAL(tobj, 0)+GET_OBJ_VAL(tobj,
1)+GET_OBJ_VAL(tobj, 2)+GET_OBJ_VAL(tobj, 3)) > 0){
	  obj_from_char(tobj);
	  GET_PLAT(mob) += GET_OBJ_VAL(tobj, 0);
	GET_GOLD(mob) += GET_OBJ_VAL(tobj, 1);
	GET_SILVER(mob) += GET_OBJ_VAL(tobj, 2);
	GET_COPPER(mob) += GET_OBJ_VAL(tobj, 3);
	  extract_obj(tobj);}
d2721 2
a2722 3
		}
		extract_obj(obj);
	}}
d2726 1
a2726 1
		     int spellnum, int savetype)
d2732 1
a2732 1

d2735 1
a2735 1

d2740 1
a2740 1

d2754 1
a2754 1
   case SPELL_FULL_HEAL:
d2789 1
a2789 1
		        int spellnum, int type)
d2793 1
a2793 1

d2796 1
a2796 1

d2809 7
a2815 7
  if(!IS_AFFECTED3(victim, AFF3_REDUCE))
  return;
  spell = SPELL_REDUCE;
   if(IS_AFFECTED3(victim, AFF3_REDUCE)) {
    to_vict ="&8You return to your normal size.&0";
   }
   break;
d2817 7
a2823 7
  if(!IS_AFFECTED3(victim, AFF3_ENLARGE))
  return;
  spell = SPELL_ENLARGE;
   if(IS_AFFECTED3(victim, AFF3_ENLARGE)) {
    to_vict ="&8You return to your normal size.&0";
   }
   break;
d2826 2
a2827 2
  if(!IS_AFFECTED(victim, AFF_BLIND))
  return;
d2830 2
a2831 2
    to_vict = "Your vision returns!";
    to_room = "There's a momentary gleam in $n's eyes.";
d2839 2
a2840 2
   if(!IS_AFFECTED(victim, AFF_BLIND))
  return;
d2843 2
a2844 2
    to_vict = "Your vision returns!";
    to_room = "There's a momentary gleam in $n's eyes.";
d2866 1
a2866 1

d2871 1
a2871 1

d2877 1
a2877 1

d2882 1
a2882 1
		         int spellnum, int savetype)
d2886 1
a2886 1

d2889 1
a2889 1

d2891 9
a2899 9
    case SPELL_BLESS:
      if (!IS_OBJ_STAT(obj, ITEM_BLESS) &&
	  (GET_OBJ_WEIGHT(obj) <= 5 * GET_LEVEL(ch))) {
	SET_BIT(GET_OBJ_EXTRA(obj), ITEM_BLESS);
	to_char = "$p glows briefly.";
      }
      break;
    case SPELL_CONTINUAL_LIGHT:
     if (!IS_OBJ_STAT(obj, ITEM_CONT_LIGHT)) {
d2904 16
a2919 16
    case SPELL_CURSE:
      if (!IS_OBJ_STAT(obj, ITEM_NODROP)) {
	SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NODROP);
	if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
	  GET_OBJ_VAL(obj, 2)--;
	to_char = "$p briefly glows red.";
      }
      break;
    case SPELL_INVISIBLE:
      if (!IS_OBJ_STAT(obj, ITEM_NOINVIS | ITEM_INVISIBLE)) {
        SET_BIT(obj->obj_flags.extra_flags, ITEM_INVISIBLE);
        to_char = "$p vanishes.";
      }
      break;
    case SPELL_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
d2924 12
a2935 12
      }
      break;
    case SPELL_REMOVE_CURSE:
      if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
        REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
        if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
          GET_OBJ_VAL(obj, 2)++;
        to_char = "$p briefly glows blue.";
      }
      break;
    case SPELL_REMOVE_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
d2938 4
a2941 4
        GET_OBJ_VAL(obj, 3) = 0;
        to_char = "$p steams briefly.";
      }
      break;
d2943 1
a2943 1

d2948 1
a2948 1

d2953 1
a2953 1

d2967 1
a2967 1

d2985 1
a2985 1

d3005 109
a3113 109
	long aff; /* what affection */
	int ticks; /* how many ticks this spell lasts */
	char *to_char = NULL;
	char *to_room = NULL;
	struct raff_node *raff;

	extern struct raff_node *raff_list;

	aff = ticks =0;

	if (ch == NULL)
		return;
	level = MAX(MIN(level, LVL_IMPL), 1);

	switch (spellnum) {
	case SPELL_WALL_OF_FOG:
		to_char = "You create a fog out of nowhere.";
		to_room = "$n creates a fog out of nowhere.";
		aff = RAFF_FOG;
		ticks = 1; /* this spell lasts one tick */
		break;
	case SPELL_DARKNESS:
		if (ROOM_AFFECTED(ch->in_room, RAFF_CONTINUAL_LIGHT)) {
		to_char = "You dispel the magical light.";
		to_room = "$n dispels the magical light.";
		REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_CONTINUAL_LIGHT);
		aff = 0;
		break;
		}else
		to_char = "You engulf the area in a magical darkness!";
		to_room = "$n engulfs the area in a magical darkness!";
		aff = RAFF_DARKNESS;
		ticks = 1;
		break;
	case SPELL_CONTINUAL_LIGHT:
		if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
		to_char = "&8Your magical light dispels the darkness.&0";
		to_room = "&8$n's magical light dispels the darkness.&0";
		REMOVE_BIT(ROOM_AFFECTIONS(ch->in_room), RAFF_DARKNESS);
		aff = 0;
		break;
		}else
		to_char = "&8The room magically lights up!&0";
		to_room = "&8The room magically lights up!&0";
		aff = RAFF_CONTINUAL_LIGHT;
		ticks = 1;
		break;
	case SPELL_URBAN_RENEWAL:
		if(SECT(ch->in_room) == SECT_FOREST || ROOM_AFFECTED(ch->in_room, RAFF_FOREST)) {
		  send_to_char("There is already enough foliage here to constitute a forest.\r\n",ch);
		  return;
		}
		if(!OUTSIDE(ch) || SECT(ch->in_room) == SECT_INSIDE) {
		  send_to_char("This place is too enclosed to grow foliage.\r\n",ch);
		  return;
		}
		aff = RAFF_FOREST;
		ticks = GET_LEVEL(ch) / 10;
		to_char="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
		to_room="&2&bThick vines and shrubs sprout out of the ground and cover the whole area in thick foliage.&0";
		break;
	case SPELL_CIRCLE_OF_FIRE:
		if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE)) {
		  send_to_char("The room is already on fire.\r\n",ch);
		  return;
		}
		if(SECT(ch->in_room) == SECT_WATER_SWIM ||
		   SECT(ch->in_room) == SECT_WATER_NOSWIM ||
		   SECT(ch->in_room) == SECT_OCEAN ||
		   SECT(ch->in_room) == SECT_UNDERWATER) {
		  send_to_char("Impossible. There is too much water here.\r\n",ch);
		  return;
		}
		aff = RAFF_CIRCLE_FIRE;
		ticks = 2;
		to_char="&1A ring of fire encircles the area.&0";
		to_room="&1A ring of fire encircles the area.&0";
		break;
	/* add more room spellscontinual here */

	default:
		sprintf(buf, "SYSERR: unknown spellnum %d " 
		"passed to mag_unaffects", spellnum);
		log(buf);
		break;
	}

	/* create, initialize, and link a room-affection node */
	CREATE(raff, struct raff_node, 1);
	raff->room = ch->in_room;
	raff->timer = ticks;
	raff->affection = aff;
	raff->spell = spellnum;
	raff->next = raff_list;
	raff_list = raff;

	/* set the affection */
	if (aff != 0)
	SET_BIT(ROOM_AFFECTIONS(raff->room), aff);

	if (to_char == NULL)
		send_to_char(NOEFFECT, ch);
	else
		act(to_char, TRUE, ch, 0, 0, TO_CHAR);

	if (to_room != NULL)
		act(to_room, TRUE, ch, 0, 0, TO_ROOM);
	else if (to_char != NULL)
		act(to_char, TRUE, ch, 0, 0, TO_ROOM);
@
