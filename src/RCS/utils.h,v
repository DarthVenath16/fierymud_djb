head	1.180;
access;
symbols;
locks; strict;
comment	@ * @;


1.180
date	2009.07.17.01.19.01;	author myc;	state Exp;
branches;
next	1.179;

1.179
date	2009.06.10.02.27.14;	author myc;	state Exp;
branches;
next	1.178;

1.178
date	2009.06.09.05.51.38;	author myc;	state Exp;
branches;
next	1.177;

1.177
date	2009.03.20.23.02.59;	author myc;	state Exp;
branches;
next	1.176;

1.176
date	2009.03.20.14.25.58;	author jps;	state Exp;
branches;
next	1.175;

1.175
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.174;

1.174
date	2009.03.13.04.40.10;	author jps;	state Exp;
branches;
next	1.173;

1.173
date	2009.03.13.04.21.41;	author jps;	state Exp;
branches;
next	1.172;

1.172
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.171;

1.171
date	2009.03.09.05.51.25;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2009.03.09.03.33.03;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2009.03.07.11.13.30;	author jps;	state Exp;
branches;
next	1.167;

1.167
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2008.09.26.18.37.59;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2008.09.25.04.47.49;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.162;

1.162
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2008.09.21.04.54.23;	author myc;	state Exp;
branches;
next	1.160;

1.160
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.158;

1.158
date	2008.09.07.20.05.55;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.09.07.18.45.15;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.09.07.07.20.12;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.07.01.28.48;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.09.06.19.10.31;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2008.09.03.17.34.08;	author myc;	state Exp;
branches;
next	1.151;

1.151
date	2008.09.02.06.50.25;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2008.09.01.18.29.38;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2008.09.01.00.01.44;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2008.08.30.04.13.45;	author myc;	state Exp;
branches;
next	1.145;

1.145
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.142;

1.142
date	2008.08.26.04.39.21;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.08.25.00.20.33;	author myc;	state Exp;
branches;
next	1.140;

1.140
date	2008.08.14.23.10.35;	author myc;	state Exp;
branches;
next	1.139;

1.139
date	2008.08.09.20.35.57;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2008.07.15.17.55.06;	author myc;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.18.04.42.09;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.04.19.21.11.22;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2008.04.13.19.38.05;	author jps;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.128;

1.128
date	2008.04.03.17.33.57;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.02.19.31.02;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.123;

1.123
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2008.03.23.00.25.02;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2008.03.22.19.08.19;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2008.03.21.21.36.02;	author jps;	state Exp;
branches;
next	1.119;

1.119
date	2008.03.21.15.01.17;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.03.17.15.31.27;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.16.00.19.11;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2008.03.11.19.50.55;	author myc;	state Exp;
branches;
next	1.115;

1.115
date	2008.03.11.02.13.05;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2008.03.10.20.49.47;	author myc;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.10.19.55.37;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2008.03.09.18.14.50;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.110;

1.110
date	2008.03.08.23.55.21;	author jps;	state Exp;
branches;
next	1.109;

1.109
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2008.03.06.05.11.51;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2008.03.06.04.35.02;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.100;

1.100
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2008.02.09.07.05.37;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2008.02.09.03.06.17;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2008.02.07.01.46.14;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.30.19.20.57;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2008.01.27.12.11.58;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.27.02.25.25;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.25.21.12.04;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.15.06.51.47;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.15.03.18.19;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.14.21.28.21;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.13.03.19.53;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.09.10.08.33;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.09.08.33.38;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.09.04.13.59;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.09.02.29.33;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.09.01.51.25;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.05.21.55.09;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.05.05.39.03;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.03.12.45.43;	author jps;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.25.06.37.05;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.20.23.13.03;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.19.20.58.40;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.27.03.18.58;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.25.20.41.13;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.28.20.49.35;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.12.19.23.04;	author myc;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.04.06.49.19;	author myc;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.03.23.59.43;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.16.11.53.39;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.04.22.20.20;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.02.01.04.10;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.31.23.44.36;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2007.07.25.00.38.03;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.19.21.59.36;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.18.18.29.55;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.15.17.16.12;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.19.04.50.18;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.18.00.05.59;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.04.13.31.02;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.04.18.12.31;	author myc;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.27.02.07.05;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.26.08.31.17;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.18.09.08.15;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.18.07.22.34;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.18.04.26.32;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.11.16.13.08;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.11.19.17.21;	author cmc;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.16.02.05.41;	author jjl;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.07.15.42.12;	author dce;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.08.17.13.10;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.24.05.12.01;	author dce;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.25.02.33.15;	author rsd;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.18.04.29.39;	author rsd;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.22.22.45.04;	author rsd;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.24.01.07.44;	author dce;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.31.00.26.25;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	99.11.29.00.13.41;	author cso;	state Exp;
branches;
next	1.24;

1.24
date	99.10.30.16.16.48;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	99.09.16.01.15.11;	author dce;	state Exp;
branches;
next	1.22;

1.22
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.21;

1.21
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.20;

1.20
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	99.08.08.19.37.25;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.08.07.23.51.29;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.07.24.20.50.18;	author dce;	state Exp;
branches;
next	1.16;

1.16
date	99.07.06.19.57.05;	author jimmy;	state Exp;
branches;
next	1.15;

1.15
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.14;

1.14
date	99.06.21.19.47.11;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.05.04.17.19.33;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.03.24.23.43.16;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.02.12.20.53.28;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.02.11.16.44.23;	author dce;	state Exp;
branches;
next	1.8;

1.8
date	99.02.10.22.27.54;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.08.23.01.47;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.06.00.40.36;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.05.07.47.42;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.04.18.08.43;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.08.21.13;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.32;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: utils.h                                       Part of CircleMUD *
*  Usage: header file: utility macros and prototypes of utility funcs     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


/* external declarations and prototypes **********************************/

extern struct weather_data weather_info;
extern HEMISPHERE Hemispheres[NUM_HEMISPHERES];
extern struct zone_data *zone_table;
#undef log

#ifdef CIRCLE_WINDOWS
#define log(x) basic_mud_log(x)
#endif

/* public functions in utils.c */
char	*str_dup(const char *source);
bool    event_target_valid(void *target);
int con_aff(struct char_data *ch);
void con_bonus_level(struct char_data *ch);
int	str_cmp(char *arg1, char *arg2);
int	strn_cmp(char *arg1, char *arg2, int n);
void	log(char *str);
int	touch(char *path);
int NumAttackers(struct char_data *ch);
bool statsave(struct char_data *ch, int stat, int mod);
int STAT_INDEX(int v);
bool are_together(struct char_data *ch1, struct char_data *ch2);
bool has_help(struct char_data *ch);
int BOUNDED(int a, int b, int c);
int exp_group_bonus(int inexp);
int exp_highlevel_bonus(int inexp, int lvldiff);
void	mudlog(char *str, char type, int level, byte file);
void	log_death_trap(struct char_data *ch);
int	number(int from, int to);
int	dice(int number, int size);
void	sprintbit(long vektor, char *names[], char *result);
void	sprinttype(int type, char *names[], char *result);
int	get_line(FILE *fl, char *buf);
int	get_filename(char *orig_name, char *filename, int mode);
struct time_info_data age(struct char_data *ch);
int	num_pc_in_room(struct room_data *room);
int     replace_str(char **string, char *pattern, char *replacement, int rep_all, int max_size);
void    format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen);
char   *stripcr(char *dest, const char *src);
char *strip_ansi(char *the_string);
bool SanityCheck(struct char_data *ch, const char *calling);
int load_modifier(struct char_data *ch);
const char *movewords(struct char_data *ch, int cmd, int room, int leaving);
/*sphere shit*/
#define SPHERE(ch, i) ((ch)->player_specials->saved.spheres[i])

#define FIRE    1
#define WATER   2
#define AIR     3
#define EARTH   4
#define GENERIC 5
#define HEALING 6

/* undefine MAX and MIN so that our functions are used instead */
#ifdef MAX
#undef MAX
#endif

#ifdef MIN
#undef MIN
#endif

int MAX(int a, int b);
int MIN(int a, int b);

/* in magic.c */
bool	circle_follow(struct char_data *ch, struct char_data * victim);

/* in act.informative.c */
void	look_at_room(struct char_data *ch, int mode);

/* in act.movmement.c */
int	do_simple_move(struct char_data *ch, int dir, int following);
int	perform_move(struct char_data *ch, int dir, int following);

/* in limits.c */
int	mana_limit(struct char_data *ch);
int	hit_limit(struct char_data *ch);
int	move_limit(struct char_data *ch);
int	mana_gain(struct char_data *ch);
int	hit_gain(struct char_data *ch);
int	move_gain(struct char_data *ch);
/*void	advance_level(struct char_data *ch);*/
void    advance_level(struct char_data *ch, int);
void	set_title(struct char_data *ch, char *title);
void	gain_exp(struct char_data *ch, int gain);
void	gain_exp_regardless(struct char_data *ch, int gain);
void	gain_condition(struct char_data *ch, int condition, int value);
void	check_idling(struct char_data *ch);
void	point_update(void);
void	update_pos(struct char_data *victim);
void	special_update(struct char_data * ch);
void el_passage(struct char_data * ch);



/* various constants *****************************************************/


/* defines for mudlog() */
#define OFF	0
#define BRF	1
#define NRM	2
#define CMP	3

/* get_filename() */
#define CRASH_FILE	0
#define ETEXT_FILE	1

/* breadth-first searching */
#define BFS_ERROR		-1
#define BFS_ALREADY_THERE	-2
#define BFS_NO_PATH		-3


/* mud-life time */
#define SECS_PER_MUD_HOUR	75
#define SECS_PER_MUD_DAY	(24*SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH	(35*SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR	(17*SECS_PER_MUD_MONTH)

/* real-life time (remember Real Life?) */
#define SECS_PER_REAL_MIN	60
#define SECS_PER_REAL_HOUR	(60*SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY	(24*SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR	(365*SECS_PER_REAL_DAY)

#define CORPSE_LEVEL(corpse)   ((corpse)->obj_flags.cost_per_day)
#define IS_CORPSE(obj) \
   (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && GET_OBJ_VAL((obj), 3) == 1)

#define LOOP_THRU_PEOPLE(IN_ROOM, PLAYER) \
for ((IN_ROOM) = world[(PLAYER)->in_room].people; (IN_ROOM) != NULL; (IN_ROOM) = (IN_ROOM)->next_in_room)


/* string utils **********************************************************/


#define YESNO(a) ((a) ? "YES" : "NO")
#define ONOFF(a) ((a) ? "ON" : "OFF")

/*#define LOWER(c)   (((c)>='A'  && (c) <= 'Z') ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (((c)>='a'  && (c) <= 'z') ? ((c)+('A'-'a')) : (c) )*/

/* IS_UPPER and IS_LOWER added by dkoepke */
#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')

#define LOWER(c)   (IS_UPPER(c) ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (IS_LOWER(c) ? ((c)+('A'-'a')) : (c))

#define ISNEWL(ch) ((ch) == '\n' || (ch) == '\r')
#define IF_STR(st) ((st) ? (st) : "\0")
#define CAP(st)  (*(st) = UPPER(*(st)), st)

#define AN(string) (strchr("aeiouAEIOU", *string) ? "an" : "a")


/* memory utils **********************************************************/


#define CREATE(result, type, number)  do {\
	if (!((result) = (type *) calloc ((number), sizeof(type))))\
		{ perror("malloc failure"); abort(); } } while(0)

#define RECREATE(result,type,number) do {\
  if (!((result) = (type *) realloc ((result), sizeof(type) * (number))))\
		{ perror("realloc failure"); abort(); } } while(0)

/*
 * the source previously used the same code in many places to remove an item
 * from a list: if it's the list head, change the head, else traverse the
 * list looking for the item before the one to be removed.  Now, we have a
 * macro to do this.  To use, just make sure that there is a variable 'temp'
 * declared as the same type as the list to be manipulated.  BTW, this is
 * a great application for C++ templates but, alas, this is not C++.  Maybe
 * CircleMUD 4.0 will be...
 */
#define REMOVE_FROM_LIST(item, head, next)	\
   if ((item) == (head))		\
      head = (item)->next;		\
   else {				\
      temp = head;			\
      while (temp && (temp->next != (item))) \
	 temp = temp->next;		\
      if (temp)				\
         temp->next = (item)->next;	\
   }					\


/* basic bitvector utils *************************************************/


#define IS_SET(flag,bit)  ((flag) & (bit))
#define SET_BIT(var,bit)  ((var) |= (bit))
#define REMOVE_BIT(var,bit)  ((var) &= ~(bit))
#define TOGGLE_BIT(var,bit) ((var) = (var) ^ (bit))

#define MOB_FLAGS(ch) ((ch)->char_specials.saved.act)
#define PLR_FLAGS(ch) ((ch)->char_specials.saved.act)
#define PRF_FLAGS(ch) ((ch)->player_specials->saved.pref)
#define AFF_FLAGS(ch) ((ch)->char_specials.saved.affected_by)
#define AFF2_FLAGS(ch) ((ch)->char_specials.saved.affected_by2)
#define AFF3_FLAGS(ch) ((ch)->char_specials.saved.affected_by3)
#define ROOM_FLAGS(loc) (world[(loc)].room_flags)
#define ROOM_AFFECTIONS(loc)    (world[(loc)].room_affections)
#define ROOM_AFFECTED(loc, aff) (IS_SET(ROOM_AFFECTIONS(loc), (aff)))

#define GET_CIRCLE(s) spell_info[(s)].min_circle[(int)GET_CLASS(ch)]
#define GET_MEMMED_CIRCLE(s) ch->spells_memmed_circle[GET_CIRCLE(s)]
#define GET_MEMMED(c) ch->spells_memmed_circle[c]
#define CIRCLE_ABBR(s) circle_abbrev[GET_CIRCLE(s)]

#define GET_DIETY(ch) ((ch)->player_specials->saved.diety)
#define IS_NPC(ch)  (IS_SET(MOB_FLAGS(ch), MOB_ISNPC))
#define IS_MOB(ch)  (IS_NPC(ch) && ((ch)->nr >-1))

#define MOB_FLAGGED(ch, flag) (IS_NPC(ch) && IS_SET(MOB_FLAGS(ch), (flag)))
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag)))
#define AFF_FLAGGED(ch, flag) (IS_SET(AFF_FLAGS(ch), (flag)))
#define AFF2_FLAGGED(ch, flag) (IS_SET(AFF2_FLAGS(ch), (flag)))
#define AFF3_FLAGGED(ch, flag) (IS_SET(AFF3_FLAGS(ch), (flag)))

#define PRF_FLAGGED(ch, flag) (IS_SET(PRF_FLAGS(ch), (flag)))
#define ROOM_FLAGGED(loc, flag) (IS_SET(ROOM_FLAGS(loc), (flag)))

/* IS_AFFECTED for backwards compatibility */
#define IS_AFFECTED(ch, skill) (AFF_FLAGGED((ch), (skill)))
#define IS_AFFECTED2(ch, skill) (AFF2_FLAGGED((ch), (skill)))
#define IS_AFFECTED3(ch, skill) (AFF3_FLAGGED((ch), (skill)))

#define PLR_TOG_CHK(ch,flag) ((TOGGLE_BIT(PLR_FLAGS(ch), (flag))) & (flag))
#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))


#define OBJ_INDEX_LIMIT(i)   (obj_index[i].object_limit)

/* room utils ************************************************************/


#define SECT(room)	(world[(room)].sector_type)

#define IS_DARK(room)  ( !world[room].light && \
                         ((ROOM_FLAGGED(room, ROOM_DARK) || \
                     ROOM_AFFECTED(room, RAFF_DARKNESS)) || \
                          ( ( SECT(room) != SECT_INSIDE && \
                              SECT(room) != SECT_CITY)  && \
(Hemispheres[zone_table[world[room].zone].hemisphere].sunlight == SUN_SET || \
 Hemispheres[zone_table[world[room].zone].hemisphere].sunlight == SUN_DARK) ) ))

#define IS_LIGHT(room)  (!IS_DARK(room) || \
                         ROOM_AFFECTED(room, RAFF_CONTINUAL_LIGHT))

#define GET_ROOM_SPEC(room) ((room) >= 0 ? world[(room)].func : NULL)

/* char utils ************************************************************/


#define IN_ROOM(ch)	((ch)->in_room)
#define GET_WAS_IN(ch)	((ch)->was_in_room)
#define GET_AGE(ch)     (age(ch).year)

#define GET_NAME(ch)    (IS_NPC(ch) ? \
			 (ch)->player.short_descr : (ch)->player.name)
#define GET_TITLE(ch)   ((ch)->player.title)
#define GET_LEVEL(ch)   ((ch)->player.level)
#define GET_PASSWD(ch)	((ch)->player.passwd)
#define GET_PROMPT(ch)	((ch)->player.prompt)
#define GET_PFILEPOS(ch)((ch)->pfilepos)

/*
 * I wonder if this definition of GET_REAL_LEVEL should be the definition
 * of GET_LEVEL?  JE
 */
#define GET_REAL_LEVEL(ch) \
   (ch->desc && ch->desc->original ? GET_LEVEL(ch->desc->original) : \
    GET_LEVEL(ch))

#define GET_SPECIES(ch) ((ch)->player.race)
#define GET_CLASS(ch)   ((ch)->player.class)
#define GET_RACE(ch)    ((ch)->player.race)
#define GET_RACE_ALIGN(ch)  ((ch)->player.race_align)
#define GET_HOME(ch)	((ch)->player.hometown)
#define GET_HEIGHT(ch)	((ch)->player.height)
#define GET_WEIGHT(ch)	((ch)->player.weight)
#define GET_SEX(ch)	((ch)->player.sex)
#define GET_SIZE(ch) ((ch)->player.size)


/*#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)*/

/*These set macros for all stat values*/
#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_STR_VIEW(ch) ((ch)->view_abils.str)
#define GET_STR_VAFF(ch) ((ch)->vaff_abils.str)
#define GET_RSTR(ch)     ((ch)->real_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_ADD_VIEW(ch) ((ch)->view_abils.str_add)
#define GET_ADD_VAFF(ch) ((ch)->vaff_abils.str_add)
#define GET_RADD(ch)     ((ch)->real_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_DEX_VIEW(ch) ((ch)->view_abils.dex)
#define GET_DEX_VAFF(ch) ((ch)->vaff_abils.dex)
#define GET_RDEX(ch)     ((ch)->real_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_RINT(ch)     ((ch)->real_abils.intel)
#define GET_INT_VIEW(ch) ((ch)->view_abils.intel)
#define GET_INT_VAFF(ch) ((ch)->vaff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_WIS_VIEW(ch) ((ch)->view_abils.wis)
#define GET_WIS_VAFF(ch) ((ch)->vaff_abils.wis)
#define GET_RWIS(ch)     ((ch)->real_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CON_VIEW(ch) ((ch)->view_abils.con)
#define GET_CON_VAFF(ch) ((ch)->vaff_abils.con)
#define GET_RCON(ch)     ((ch)->real_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)
#define GET_CHA_VIEW(ch) ((ch)->view_abils.cha)
#define GET_CHA_VAFF(ch) ((ch)->vaff_abils.cha)
#define GET_RCHA(ch)     ((ch)->real_abils.cha)
#define GET_RCHA(ch)     ((ch)->real_abils.cha)


#define GET_EX_EXP(ch) ((ch)->mob_specials.ex_exp)
/*
#define GET_EXP(ch)	 	(IS_NPC(ch) ? ((ch)->mob_specials.ex_exp) : ((ch)->points.exp))
*/
#define GET_EXP(ch)  ((ch)->points.exp)

#define GET_EX_AC(ch)     ((ch)->mob_specials.ex_armor)
#define GET_AC(ch)        ((ch)->points.armor)
#define GET_HIT(ch)	  ((ch)->points.hit)
#define GET_MAX_HIT(ch)	  ((ch)->points.max_hit)
#define GET_EX_HIT(ch)  ((ch)->mob_specials.ex_hit)
#define GET_EX_MAX_HIT(ch)  ((ch)->mob_specials.ex_max_hit)
#define GET_EX_MAIN_HP(ch)  ((ch)->mob_specials.ex_main_hp)
#define GET_EX_GOLD(ch)   ((ch)->mob_specials.ex_gold)
#define GET_EX_PLAT(ch)     ((ch)->mob_specials.ex_plat)

#define GET_MOVE(ch)	  ((ch)->points.move)
#define GET_MAX_MOVE(ch)  ((ch)->points.max_move)
#define GET_MANA(ch)	  ((ch)->points.mana)
#define GET_EX_MANA(ch)  ((ch)->mob_specials.ex_mana)


#define GET_EX_MAX_MANA(ch)  ((ch)->mob_specials.ex_max_mana)
#define GET_MAX_MANA(ch)  ((ch)->points.max_mana)
#define GET_BANK_GOLD(ch) ((ch)->points.coins.bank_gold)
#define GET_BANK_PLAT(ch) ((ch)->points.coins.bank_plat)
#define GET_BANK_SILVER(ch) ((ch)->points.coins.bank_silver)
#define GET_BANK_COPPER(ch) ((ch)->points.coins.bank_copper)
#define GET_PLAT(ch)      ((ch)->points.coins.plat)
#define GET_GOLD(ch)	  ((ch)->points.coins.gold)
#define GET_SILVER(ch)    ((ch)->points.coins.silver)
#define GET_COPPER(ch)    ((ch)->points.coins.copper)
#define GET_CASH(ch) (GET_PLAT(ch)*1000+GET_GOLD(ch)*100+GET_SILVER(ch)*10+GET_COPPER(ch))
#define GET_LASTLEVEL(ch)	((ch)->player_specials->saved.lastlevel)
#define GET_NATHPS(ch)    ((ch)->player_specials->saved.nathps)

#define GET_HITROLL(ch)	  ((ch)->points.hitroll)
#define GET_DAMROLL(ch)   ((ch)->points.damroll)

#define GET_POS(ch)	  ((ch)->char_specials.position)
#define GET_POS1(ch)	  ((ch)->char_specials.position1)

#define GET_IDNUM(ch)	  ((ch)->char_specials.saved.idnum)
#define GET_ID(x)         ((x)->id)
#define IS_CARRYING_W(ch) ((ch)->char_specials.carry_weight)
#define CONSENT(ch) ((ch)->char_specials.consented)
#define IS_CARRYING_N(ch) ((ch)->char_specials.carry_items)
#define FIGHTING(ch)	  ((ch)->char_specials.fighting)
#define HUNTING(ch)	  ((ch)->char_specials.hunting)
#define RIDING(ch)	  ((ch)->char_specials.riding)
#define RIDDEN_BY(ch)	  ((ch)->char_specials.ridden_by)
#define GET_SAVE(ch, i)	  ((ch)->char_specials.saved.apply_saving_throw[i])
#define GET_ALIGNMENT(ch) ((ch)->char_specials.saved.alignment)

#define GET_COND(ch, i)		((ch)->player_specials->saved.conditions[(i)])
#define GET_INNT(ch, i)     ((ch)->player_specials->saved.innatetime[(i)])
#define GET_LOADROOM(ch)	((ch)->player_specials->saved.load_room)
#define GET_PRACTICES(ch)	((ch)->player_specials->saved.spells_to_learn)
#define GET_INVIS_LEV(ch)	((ch)->player_specials->saved.invis_level)
#define GET_WIMP_LEV(ch)	((ch)->player_specials->saved.wimp_level)
#define GET_FREEZE_LEV(ch)	((ch)->player_specials->saved.freeze_level)
#define GET_BAD_PWS(ch)		((ch)->player_specials->saved.bad_pws)
#define GET_TALK(ch, i)		((ch)->player_specials->saved.talks[i])
#define POOFIN(ch)		((ch)->player_specials->poofin)
#define POOFOUT(ch)		((ch)->player_specials->poofout)
#define GET_LAST_OLC_TARG(ch)	((ch)->player_specials->last_olc_targ)
#define GET_LAST_OLC_MODE(ch)	((ch)->player_specials->last_olc_mode)
#define GET_ALIASES(ch)		((ch)->player_specials->aliases)
#define GET_LAST_TELL(ch)	((ch)->player_specials->last_tell)
#define GET_ROLL(ch, id)		((ch)->player_specials->roll[id])
#define SPEAKING(ch)     ((ch)->player_specials->saved.speaking)

/*#define GET_SKILL(ch, i)	((ch)->player_specials->saved.skills[i])
#define SET_SKILL(ch, i, pct)	{ (ch)->player_specials->saved.skills[i] = pct; }
*/
#define SET_MSKILL(ch, a, pct)  (ch.mob_specials.skills[a] = pct)
#define GET_MSKILL(ch, a)  ((ch)->mob_specials.skills[a])
#define GET_SKILL(ch, a)	(IS_NPC(ch) ? ((ch)->mob_specials.skills[a]) : ((ch)->player_specials->saved.skills[a]) / 10)
#define SET_SKILL(ch, i, pct)  { (ch)->player_specials->saved.skills[i] = pct;}
#define GET_ISKILL(ch, a)	(IS_NPC(ch) ? ((ch)->mob_specials.skills[a]) :((ch)->player_specials->saved.skills[a]))

#define GET_EQ(ch, i)		((ch)->equipment[i])

#define GET_POINTS_EVENT(ch, i) ((ch)->points_event[i])
#define GET_DAMAGE_EVENTS(ch)   ((ch)->damage_events)
#define GET_ACTION(ch) ((ch)->camp_event)
#define GET_TRACK_EVENTS(ch) ((ch)->track_delayed_event)
#define OUTDOOR_SNEAK(ch) \
 ((GET_RACE(ch) == RACE_ELF) \
 && ((world[(ch)->in_room].sector_type >= SECT_FIELD) && \
 ((world[(ch)->in_room].sector_type <= SECT_MOUNTAIN) || \
  (world[(ch)->in_room].sector_type == SECT_GRASSLANDS))))

#define GET_MOB_SPEC(ch) (IS_MOB(ch) ? (mob_index[(ch->nr)].func) : NULL)
#define GET_MOB_RNUM(mob)	((mob)->nr)
#define GET_MOB_VNUM(mob)	(IS_MOB(mob) ? \
				 mob_index[GET_MOB_RNUM(mob)].virtual : -1)

#define GET_MOB_WAIT(ch)	((ch)->mob_specials.wait_state)
#define GET_DEFAULT_POS(ch)	((ch)->mob_specials.default_pos)
#define MEMORY(ch)		((ch)->mob_specials.memory)


#define GET_FRAG(ch)        ((ch)->player_specials->saved.frag)
#define GET_TROPHY(ch, i)  ((ch)->player_specials->saved.trophy[i])
#define GET_TRTOP(ch)   ((ch)->player_specials->saved.top)



#define STRENGTH_APPLY_INDEX(ch) \
        ( ((GET_ADD(ch)==0) || (GET_STR(ch) != 18)) ? GET_STR(ch) :\
          (GET_ADD(ch) <= 50) ? 26 :( \
          (GET_ADD(ch) <= 75) ? 27 :( \
          (GET_ADD(ch) <= 90) ? 28 :( \
          (GET_ADD(ch) <= 99) ? 29 :  30 ) ) )                   \
        )

#define CAN_CARRY_W(ch) (str_app[STRENGTH_APPLY_INDEX(ch)].carry_w)
#define CAN_CARRY_N(ch) (5 + (GET_DEX(ch) >> 1) + (GET_LEVEL(ch) >> 1))
#define CURRENT_LOAD(ch) ( (int)(((float)IS_CARRYING_W(ch) / (float)CAN_CARRY_W(ch)) * 10) )
#define AWAKE(ch) (GET_POS(ch) > POS_SLEEPING)
#define CAN_SEE_IN_DARK(ch) \
   ((PRF_FLAGGED(ch, PRF_HOLYLIGHT) || AFF2_FLAGGED(ch, AFF2_ULTRAVISION) \
    || IS_MOB(ch)  \
    || IS_NPC(ch)) && !ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
  /* I changed this to stop abuse! Banyal needs removed when mobs are foxed*/
#define IS_GOOD(ch)    (GET_ALIGNMENT(ch) >= 350)
#define IS_EVIL(ch)    (GET_ALIGNMENT(ch) <= -350)
#define IS_NEUTRAL(ch) (!IS_GOOD(ch) && !IS_EVIL(ch))


/* descriptor-based utils ************************************************/
/*next four added by proky for mob casting*/
#define GET_MEM_STATE(ch, circle)   ((ch)->mob_specials.mem_state[circle - 1])
#define GET_MEM_MEMED(ch, circle)	((ch)->mob_specials.mem_memed[circle - 1])
#define SET_MEM_STATE(ch, circle, pct)   ((ch)->mob_specials.mem_state[circle - 1])	 = pct
#define SET_MEM_MEMED(ch, circle, pct)	((ch)->mob_specials.mem_memed[circle - 1]) 	 = pct


#define WAIT_STATE(ch, cycle) { \
	if ((ch)->desc) (ch)->desc->wait = (cycle); \
	else if (IS_NPC(ch)) GET_MOB_WAIT(ch) = (cycle); }

#define CHECK_WAIT(ch)	(((ch)->desc) ? ((ch)->desc->wait > 1) : 0)
#define STATE(d)	((d)->connected)


/* object utils **********************************************************/


#define GET_OBJ_TYPE(obj)	((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)	((obj)->obj_flags.cost)
#define GET_OBJ_RENT(obj)	((obj)->obj_flags.cost_per_day)
#define GET_OBJ_EXTRA(obj)	((obj)->obj_flags.extra_flags)
#define GET_OBJ_WEAR(obj)	((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)	((obj)->obj_flags.value[(val)])
#define GET_OBJ_WEIGHT(obj)	((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)	((obj)->obj_flags.timer)
#define GET_OBJ_MOB_FROM(obj) ((obj)->mob_from)
#define GET_OBJ_RNUM(obj)	((obj)->item_number)
#define GET_OBJ_VNUM(obj)	(GET_OBJ_RNUM(obj) >= 0 ? \
				 obj_index[GET_OBJ_RNUM(obj)].virtual : -1)
#define IS_OBJ_STAT(obj,stat)	(IS_SET((obj)->obj_flags.extra_flags,stat))
#define IS_OBJ_SPELL_AFF(obj,stat)	(IS_SET((obj)->obj_flags.spell_flags,stat))
#define IS_OBJ_SPELL_AFF2(obj,stat)      (IS_SET((obj)->obj_flags.spell_flags2,stat))
#define IS_OBJ_SPELL_AFF3(obj,stat)      (IS_SET((obj)->obj_flags.spell_flags3,stat))
#define GET_OBJ_SPELL(obj)    ((obj)->obj_flags.spell_flags)
#define GET_OBJ_SPELL2(obj)   ((obj)->obj_flags.spell_flags2)
#define GET_OBJ_SPELL3(obj)   ((obj)->obj_flags.spell_flags3)
#define GET_OBJ_SPELL(obj)	((obj)->obj_flags.spell_flags)
#define GET_OBJ_COMPONENT(obj) ((obj)->spell_component)
#define GET_OBJ_LIMITATION(obj) ((obj)->object_limitation)
#define OBJ_LIMIT(id) (obj_limit[id])
#define GET_OBJ_SPEC(obj) ((obj)->item_number >= 0 ? \
	(obj_index[(obj)->item_number].func) : NULL)

#define CAN_WEAR(obj, part) (IS_SET((obj)->obj_flags.wear_flags, (part)))

#define IS_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                        GET_OBJ_VAL((obj), 3) == 1)

/* compound utilities and other macros **********************************/


#define HSHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "his":"her") :"its")
#define HSSH(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "he" :"she") : "it")
#define HMHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "him":"her") : "it")

#define ANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "An" : "A")
#define SANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "an" : "a")


/* Various macros building up to CAN_SEE */

#define LIGHT_OK(sub)	(!IS_AFFECTED(sub, AFF_BLIND) && \
   (IS_LIGHT((sub)->in_room) || IS_AFFECTED2((sub), AFF2_ULTRAVISION) || \
 IS_MOB(sub) || (ROOM_AFFECTED((sub)->in_room, RAFF_CONTINUAL_LIGHT))))

#define INVIS_OK(sub, obj) \
 ((!IS_AFFECTED((obj),AFF_INVISIBLE) || IS_AFFECTED(sub,AFF_DETECT_INVIS)) && \
 (!IS_AFFECTED((obj), AFF_HIDE) || IS_AFFECTED(sub, AFF_SENSE_LIFE)))

#define MORT_CAN_SEE(sub, obj) (LIGHT_OK(sub) && INVIS_OK(sub, obj))
#define MOB_CAN_SEE(sub, obj)  (INVIS_OK(sub, obj))

#define IMM_CAN_SEE(sub, obj) \
   (MORT_CAN_SEE(sub, obj) || PRF_FLAGGED(sub, PRF_HOLYLIGHT))

#define SELF(sub, obj)  ((sub) == (obj))

/* Can subject see character "obj"? */
#define CAN_SEE(sub, obj) ((SELF(sub, obj)) || \
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && IMM_CAN_SEE(sub, obj)) || \
  ((GET_LEVEL(obj) >= LVL_IMMORT) && (CONSENT(obj) == sub)) )
/* End of CAN_SEE */

/* Can MOB subject see character "obj"? */
#define MCAN_SEE(sub, obj) ((SELF(sub, obj)) || \
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && INVIS_OK(sub, obj)) || \
  ((GET_LEVEL(obj) >= LVL_IMMORT) && (CONSENT(obj) == sub)) )
/* End of MCAN_SEE */

#define INVIS_OK_OBJ(sub, obj) \
  (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || IS_AFFECTED((sub), AFF_DETECT_INVIS))

#define HIDDEN_OK_OBJ(sub, obj) (!IS_OBJ_STAT((obj), ITEM_HIDDEN))

#define MORT_CAN_SEE_OBJ(sub, obj) (LIGHT_OK(sub) && INVIS_OK_OBJ(sub, obj) \
        &&      HIDDEN_OK_OBJ(sub, obj))

#define SENDOK(ch) ((ch)->desc && (AWAKE(ch) || sleep) && \
 		    !PLR_FLAGGED((ch), PLR_WRITING))

#define CAN_SEE_OBJ(sub, obj) \
   (MORT_CAN_SEE_OBJ(sub, obj) || PRF_FLAGGED((sub), PRF_HOLYLIGHT))

#define CAN_CARRY_OBJ(ch,obj)  \
   (((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) <= CAN_CARRY_W(ch)) &&   \
    ((IS_CARRYING_N(ch) + 1) <= CAN_CARRY_N(ch)))

#define CAN_GET_OBJ(ch, obj)   \
   (CAN_WEAR((obj), ITEM_WEAR_TAKE) && CAN_CARRY_OBJ((ch),(obj)) && \
    CAN_SEE_OBJ((ch),(obj)))


#define PERS(ch, vict)   (CAN_SEE(vict, ch) ? GET_NAME(ch) : "someone")

#define OBJS(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
	(obj)->short_description  : "something")

#define OBJN(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
	fname((obj)->name) : "something")


#define EXIT(ch, door)  (world[(ch)->in_room].dir_option[door])

#define CAN_GO(ch, door) (EXIT(ch,door) && \
			 (EXIT(ch,door)->to_room != NOWHERE) && \
			 !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED))


#define CLASS_ABBR(ch) (IS_NPC(ch) ? "--" : class_abbrevs[(int)GET_CLASS(ch)])
#define CLASS_FULL(ch) (IS_NPC(ch) ? "--" : pc_class_types[(int)GET_CLASS(ch)])
#define RACE_ABBR(ch)  (IS_NPC(ch) ? "--" : race_abbrevs[(int)GET_RACE(ch)])

#define RACE_TARG(ch)  (IS_NPC(ch) ? "--" : race_target[(int)GET_RACE(ch)])


#define SIZE_ABBR(ch)  (IS_NPC(ch) ? "--" : size_abbrevs[(int)GET_SIZE(ch)])


#define RACE_ALIGN_ABBR(ch) race_align_abbrevs[(int )GET_RACE_ALIGN(ch)]

#define IS_FIGHTING(ch) ((ch->char_specials.fighting)? 1: 0)

#define IS_MAGIC_USER(ch)	(!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_MAGIC_USER) || \
				(GET_CLASS(ch) == CLASS_PYROMANCER) || \
				(GET_CLASS(ch) == CLASS_CRYOMANCER) || \
				(GET_CLASS(ch) == CLASS_ILLUSIONIST)))
#define IS_CLERIC(ch)		(!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_CLERIC) || \
				(GET_CLASS(ch) == CLASS_DIABOLIST) || \
				(GET_CLASS(ch) == CLASS_PRIEST) || \
				(GET_CLASS(ch) == CLASS_MYSTIC)))
#define IS_THIEF(ch)		(!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_THIEF) || \
				(GET_CLASS(ch) == CLASS_ROGUE)))
#define IS_WARRIOR(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_WARRIOR))
#define IS_PALADIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_PALADIN))
#define IS_ANTI_PALADIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_ANTI_PALADIN))
#define IS_RANGER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_RANGER))
#define IS_DRUID(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_DRUID))
#define IS_SHAMAN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_SHAMAN))
#define IS_ASSASSIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_ASSASSIN))
#define IS_MERCENARY(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_MERCENARY))
#define IS_NECROMANCER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_NECROMANCER))
#define IS_CONJURER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_CONJURER))

#define OUTSIDE(ch) (!ROOM_FLAGGED((ch)->in_room, ROOM_INDOORS))


/* OS compatibility ******************************************************/


/* there could be some strange OS which doesn't have NULL... */
#ifndef NULL
#define NULL (void *)0
#endif

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE  (!FALSE)
#endif

/* defines for fseek */
#ifndef SEEK_SET
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2
#endif

#if defined(NOCRYPT) || !defined(HAVE_CRYPT)
#define CRYPT(a,b) (a)
#else
#define CRYPT(a,b) ((char *) crypt((a),(b)))
#endif

/*			STATS FOR RACES
 CHANGE THESE TO DIRECTLY EFFECT MAXIMUM STATS*/
#define ORC_STR 18
#define ORC_CON 18
#define ORC_WIS 18
#define ORC_INT 18
#define ORC_DEX 18
#define ORC_CHA 18
#define HUMAN_STR 18
#define HUMAN_CON 18
#define HUMAN_WIS 18
#define HUMAN_INT 18
#define HUMAN_DEX 18
#define HUMAN_CHA 18
#define HALF_ELF_STR 17
#define HALF_ELF_CON 18
#define HALF_ELF_WIS 18
#define HALF_ELF_INT 19
#define HALF_ELF_DEX 19
#define HALF_ELF_CHA 17
#define ELF_STR 16
#define ELF_CON 16
#define ELF_WIS 21
#define ELF_INT 22
#define ELF_DEX 20
#define ELF_CHA 20
#define DWARF_STR 21
#define DWARF_CON 21
#define DWARF_WIS 18
#define DWARF_INT 16
#define DWARF_DEX 19
#define DWARF_CHA 18
#define DUERGAR_STR 21
#define DUERGAR_CON 21
#define DUERGAR_WIS 18
#define DUERGAR_INT 17
#define DUERGAR_DEX 19
#define DUERGAR_CHA 16
#define BARBARIAN_STR 22
#define BARBARIAN_CON 22
#define BARBARIAN_WIS 16
#define BARBARIAN_INT 16
#define BARBARIAN_DEX 17
#define BARBARIAN_CHA 17
#define TROLL_STR 23
#define TROLL_CON 23
#define TROLL_WIS 14
#define TROLL_INT 14
#define TROLL_DEX 18
#define TROLL_CHA 16
#define OGRE_STR 24
#define OGRE_CON 28
#define OGRE_WIS 15
#define OGRE_INT 13
#define OGRE_DEX 16
#define OGRE_CHA 15
#define HALFLING_STR 17
#define HALFLING_CON 16
#define HALFLING_WIS 20
#define HALFLING_INT 20
#define HALFLING_DEX 24
#define HALFLING_CHA 19
#define DROW_ELF_STR 16
#define DROW_ELF_CON 16
#define DROW_ELF_WIS 20
#define DROW_ELF_INT 22
#define DROW_ELF_DEX 20
#define DROW_ELF_CHA 18
#define GNOME_STR 16
#define GNOME_CON 17
#define GNOME_WIS 21
#define GNOME_INT 22
#define GNOME_DEX 19
#define GNOME_CHA 19


#define SD_LVL_MULT(i) spell_dam_info[i].lvl_mult
#define SD_SPELL(i) spell_dam_info[i].spell
#define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
#define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
#define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
#define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
#define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
#define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
#define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
#define SD_BONUS(i) spell_dam_info[i].max_bonus
#define SD_NPC_STATIC(i) spell_dam_info[i].npc_static
#define SD_PC_STATIC(i) spell_dam_info[i].pc_static
#define SD_NOTE(i) spell_dam_info[i].note
#define SPELL_DAM_FILE "misc/spell_dams" /*for spell dams*/


#define ALONE(ch)  (!(ch) || ((ch)->in_room == NOWHERE) || \
		    (((ch)->next_in_room == NULL) && (world[(ch)->in_room].people == (ch))))
@


1.180
log
@Autosplit no longer gives an error message if no one else
is present.
@
text
@/***************************************************************************
 * $Id: utils.h,v 1.179 2009/06/10 02:27:14 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: utils.h                                        Part of FieryMUD *
 *  Usage: header file: utility macros and prototypes of utility funcs     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#ifndef __FIERY_UTILS_H
#define __FIERY_UTILS_H

#include "strings.h"
#include "text.h"
#include "rooms.h"
#include <math.h>
#include "money.h"

/* external declarations and prototypes **********************************/

extern struct zone_data *zone_table;
extern struct index_data *obj_index;

/* This should be in weather.h, but IS_DARK uses hemisphere data, so we 
 * need it here. */
extern struct hemisphere_data hemispheres[NUM_HEMISPHERES];

#define log log_printf
#define mprintf mudlog_printf

/* deprecated functions */
void mudlog(const char *str, unsigned char type, int level, byte file);

/* public functions in utils.c */
void perform_random_gem_drop(struct char_data *);
bool event_target_valid(struct char_data *ch);
int con_aff(struct char_data *ch);
int static_ac(int dex);
void log(const char *str, ...) __attribute__ ((format (printf, 1, 2)));
int touch(const char *path);
void mudlog_printf(int severity, int level, const char *str, ...) __attribute__ ((format (printf, 3, 4))) ;
const char *sprint_log_severity(int severity);
int parse_log_severity(const char *severity);
void log_death_trap(struct char_data *ch);
int get_line(FILE *fl, char *buf);
struct time_info_data age(struct char_data *ch);
int num_pc_in_room(struct room_data *room);
int load_modifier(struct char_data *ch);
const char *movewords(struct char_data *ch, int cmd, int room, int leaving);
void build_count(void);
int monk_weight_penalty(struct char_data *ch);
int find_zone(int num);
int parse_obj_name(struct char_data *ch, char *arg, char *objname, int numobjs, void *objects, int objsize);
void init_flagvectors();
long exp_next_level(int level, int class);
void init_exp_table(void);

void sort(void algorithm(int[], int, int(int a, int b)),
          int array[], int count, int comparator(int, int));
void bubblesort(int array[], int count, int comparator(int a, int b));
void insertsort(int array[], int count, int comparator(int a, int b));
void quicksort(int array[], int count, int comparator(int a, int b));
void optquicksort(int array[], int count, int comparator(int a, int b));

void update_pos(struct char_data *victim);

int yesno_result(char *answer);
#define YESNO_NONE  0    /* just pressed enter (probably wanted default) */
#define YESNO_OTHER 1    /* typed something, but not starting with y or n */
#define YESNO_YES   2    /* entered something starting with y or Y */
#define YESNO_NO    3    /* entered something starting with n or N */

char *statelength(int inches);
char *stateweight(float pounds);
char *format_apply(int apply, int amount);
void drop_core(struct char_data *ch, const char *desc);


/* various constants *****************************************************/

/* generic multi-purpose flag constants */
#define FAIL_SILENTLY       (1 << 0)


/* defines for mudlog() */
#define OFF   0
#define BRF   1
#define NRM   2
#define CMP   3

/* severity defines for mprintf(): gaps for future additions */
#define L_CRIT       70 /* serious errors (data corruption, need reboot) */
#define L_ERROR      60 /* other non-fatal errors: something's broke */
#define L_WARN       50 /* warnings: stuff is still working */
#define L_STAT       40 /* mud status: players login, deaths, etc */
#define L_DEBUG      30 /* coding debug/script errors */
#define L_INFO       20 /* monotonous info: zone resets, etc */
#define L_TRACE      10 /* trace info: hard core debug maybe? */
#define L_NOFILE     (1 << 7)

/* breadth-first searching */
#define BFS_ERROR      -1
#define BFS_ALREADY_THERE   -2
#define BFS_NO_PATH      -3


/* mud-life time */
#define HOURS_PER_DAY       24
#define DAYS_PER_WEEK       7
#define WEEKS_PER_MONTH     5
#define DAYS_PER_MONTH      (DAYS_PER_WEEK * WEEKS_PER_MONTH)
#define MONTHS_PER_YEAR     16
#define WEEKS_PER_YEAR      (WEEKS_PER_MONTH * MONTHS_PER_YEAR)
#define DAYS_PER_YEAR       (DAYS_PER_MONTH * DAYS_PER_MONTH)
#define SECS_PER_MUD_HOUR   75
#define SECS_PER_MUD_DAY    (HOURS_PER_DAY * SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH  (DAYS_PER_MONTH * SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR   (MONTHS_PER_YEAR * SECS_PER_MUD_MONTH)


/* real-life time (remember Real Life?) */
#define SECS_PER_REAL_MIN   60
#define SECS_PER_REAL_HOUR  (60 * SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY   (24 * SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR  (365 * SECS_PER_REAL_DAY)

/* string utils **********************************************************/

#define YESNO(a)       ((a) ? "YES" : "NO")
#define ONOFF(a)       ((a) ? "ON" : "OFF")

/* IS_UPPER and IS_LOWER added by dkoepke */
#define IS_UPPER(c)    ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c)    ((c) >= 'a' && (c) <= 'z')
 
#define LOWER(c)       (IS_UPPER(c) ? ((c)+('a'-'A')) : (c))
#define UPPER(c)       (IS_LOWER(c) ? ((c)+('A'-'a')) : (c))
  
#define IS_NEWLINE(ch) ((ch) == '\n' || (ch) == '\r') 
#define CAP(st)        (cap_by_color(st))

#define AN(string)     (strchr("aeiouAEIOU", *string) ? "an" : "a")

/* memory utils **********************************************************/


#define CREATE(result, type, number)  do {\
   if (!((result) = (type *) calloc ((number), sizeof(type))))\
      { perror("malloc failure"); abort(); } } while(0)

#define RECREATE(result,type,number) do {\
  if (!((result) = (type *) realloc ((result), sizeof(type) * (number))))\
      { perror("realloc failure"); abort(); } } while(0)

/*
 * A macro to remove an item from a list: if it's the list head, change the head, 
 * else traverse the list looking for the item before the one to be removed.
 * To use, just make sure that there is a variable 'temp' declared as the same
 * type as the list to be manipulated.
 */
#define REMOVE_FROM_LIST(item, head, next) do {\
   if ((item) == (head)) \
      head = (item)->next; \
   else { \
      temp = head; \
      while (temp && (temp->next != (item))) \
    temp = temp->next; \
      if (temp) \
         temp->next = (item)->next; \
   } \
} while (0)

#define LOOP_THRU_PEOPLE(IN_ROOM, PLAYER) \
for ((IN_ROOM) = world[(PLAYER)->in_room].people; (IN_ROOM) != NULL; (IN_ROOM) = (IN_ROOM)->next_in_room)

/* basic bitvector utils *************************************************/

#define IS_SET(flag,bit)         ((flag) & (bit))
#define SET_BIT(var,bit)         ((var) |= (bit))
#define REMOVE_BIT(var,bit)      ((var) &= ~(bit))
#define TOGGLE_BIT(var,bit)      ((var) = (var) ^ (bit))

/* extended bitvector utils */
#define FIELD(x)                 ((int) (x) / FLAGBLOCK_SIZE)
#define FLAG(x)                  (1 << ((x) % FLAGBLOCK_SIZE))
#define IS_FLAGGED(field, flag)  (((field)[FIELD(flag)] & FLAG(flag)) ? 1 : 0)
#define SET_FLAG(field, flag)    ((field)[FIELD(flag)] |= FLAG(flag))
#define REMOVE_FLAG(field, flag) ((field)[FIELD(flag)] &= ~FLAG(flag))
#define TOGGLE_FLAG(field, flag) ((field)[FIELD(flag)] ^= FLAG(flag))
bool ALL_FLAGGED(const flagvector field[], const flagvector flags[], const int num_flags);
bool ANY_FLAGGED(const flagvector field[], const flagvector flags[], const int num_flags);
void SET_FLAGS(flagvector field[], const flagvector flags[], const int num_flags);
void REMOVE_FLAGS(flagvector field[], const flagvector flags[], const int num_flags);
void TOGGLE_FLAGS(flagvector field[], const flagvector flags[], const int num_flags);
void COPY_FLAGS(flagvector field[], const flagvector flags[], const int num_flags);
extern flagvector *ALL_FLAGS;
#define HAS_FLAGS(field, num_flags)   (ANY_FLAGGED((field), ALL_FLAGS, (num_flags)))
#define CLEAR_FLAGS(field, num_flags) (REMOVE_FLAGS((field), ALL_FLAGS, (num_flags)))

/* Event flags */
#define GET_EVENTS(o)              ((o)->events)
#define GET_EVENT_FLAGS(o)         ((o)->event_flags)
#define EVENT_FLAGGED(o, flag)     IS_FLAGGED(GET_EVENT_FLAGS(o), (flag))

#define MOB_FLAGS(ch)              ((ch)->char_specials.act)
#define PLR_FLAGS(ch)              ((ch)->char_specials.act)
#define PRF_FLAGS(ch)              ((ch)->player_specials->pref)
#define PRV_FLAGS(ch)              ((ch)->player_specials->privileges)
#define EFF_FLAGS(ch)              ((ch)->char_specials.effects)
#define ROOM_FLAGS(loc)            (world[(loc)].room_flags)
#define ROOM_EFFECTS(loc)          (world[(loc)].room_effects)

#define IS_NPC(ch)                 IS_FLAGGED(MOB_FLAGS(ch), MOB_ISNPC)
#define IS_MOB(ch)                 (IS_NPC(ch) && ((ch)->mob_specials.nr > -1))
#define POSSESSED(ch)              ((ch)->desc && (ch)->desc->original)
#define POSSESSOR(ch)              ((ch)->desc && (ch)->desc->original ? (ch)->desc->original : NULL)
#define REAL_CHAR(ch)              ((ch)->desc && (ch)->desc->original ? (ch)->desc->original : (ch))
#define FORWARD(ch)                ((ch)->forward ? (ch)->forward : (ch))
#define IS_PC(ch)                  (!IS_NPC(REAL_CHAR(ch)))
/* PLAYERALLY - true for a player, or a player's pet */
#define PLAYERALLY(ch) (IS_PC(ch) || \
      (EFF_FLAGGED(ch, EFF_CHARM) && (ch)->master && IS_PC((ch)->master)))

/* MORTALALLY - same as PLAYERALLY except that the involved player
 * must be mortal for it to return true */
#define MORTALALLY(ch) ( \
      (!IS_NPC(REAL_CHAR(ch)) && GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT) || \
      (EFF_FLAGGED(ch, EFF_CHARM) && (ch)->master && \
         (!IS_NPC(REAL_CHAR(ch)) && GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)))

#define MOB_FLAGGED(ch, flag)      (IS_NPC(ch) && IS_FLAGGED(MOB_FLAGS(ch), (flag)))
#define PLR_FLAGGED(ch, flag)      (!IS_NPC(ch) && IS_FLAGGED(PLR_FLAGS(ch), (flag)))
#define PRF_FLAGGED(ch, flag)      IS_FLAGGED(PRF_FLAGS(REAL_CHAR(ch)), (flag))
#define PRV_FLAGGED(ch, flag)      IS_FLAGGED(PRV_FLAGS(REAL_CHAR(ch)), (flag))
#define EFF_FLAGGED(ch, flag)      IS_FLAGGED(EFF_FLAGS(ch), (flag))
#define ROOM_FLAGGED(loc, flag)    IS_FLAGGED(ROOM_FLAGS(loc), (flag))
#define ROOM_EFF_FLAGGED(loc, eff) IS_FLAGGED(ROOM_EFFECTS(loc), (eff))

#define AGGR_TO_PLAYERS(ch) (\
   MOB_FLAGGED((ch), MOB_AGGR_EVIL) || \
   MOB_FLAGGED((ch), MOB_AGGR_GOOD) || \
   MOB_FLAGGED((ch), MOB_AGGR_NEUTRAL) || \
   MOB_FLAGGED((ch), MOB_AGGR_EVIL_RACE) || \
   MOB_FLAGGED((ch), MOB_AGGR_GOOD_RACE))
#define PLR_TOG_CHK(ch, flag)      (TOGGLE_FLAG(PLR_FLAGS(ch), (flag)) & FLAG(flag))
#define PRF_TOG_CHK(ch, flag)      (TOGGLE_FLAG(PRF_FLAGS(ch), (flag)) & FLAG(flag))
#define PRV_TOG_CHK(ch, flag)      (TOGGLE_FLAG(PRV_FLAGS(ch), (flag)) & FLAG(flag))
#define CONFUSED(ch)               EFF_FLAGGED(ch, EFF_CONFUSION)

/* Mob performs scripts?  (specprocs and triggers)
 * - is an NPC
 * - doesn't have !script flag
 * - isn't charmed
 */
#define MOB_PERFORMS_SCRIPTS(ch) (IS_NPC(ch) && \
      !MOB_FLAGGED(ch, MOB_NOSCRIPT) && \
         !EFF_FLAGGED(ch, EFF_CHARM))

#define MEMMING(ch)                EVENT_FLAGGED((ch), EVENT_MEM)

/* char utils ************************************************************/

/* Identifier accessors */
#define GET_PFILEPOS(ch)    ((ch)->pfilepos)
#define GET_NAMELIST(ch)    ((ch)->player.namelist)
#define GET_NAME(ch)        ((ch)->player.short_descr)
#define GET_SHORT(ch)       ((ch)->player.short_descr)
#define GET_TITLE(ch)       ((ch)->player.title)
#define GET_WIZ_TITLE(ch)   ((ch)->player_specials->wiz_title)
#define GET_PERM_TITLES(ch) ((ch)->player_specials->perm_titles)
#define GET_LDESC(ch)       ((ch)->player.long_descr)

/* General accessors */
#define IN_ROOM(ch)         ((ch)->in_room)
#define IN_ROOM_VNUM(ch)    (IN_ROOM(ch) > NOWHERE && IN_ROOM(ch) < top_of_world ? \
      world[IN_ROOM(ch)].vnum : NOWHERE)
#define IN_ZONE_RNUM(ch)    (world[IN_ROOM(ch)].zone)
#define IN_ZONE_VNUM(ch)    (zone_table[IN_ZONE_RNUM(ch)].number)
#define GET_WAS_IN(ch)      ((ch)->was_in_room)
#define GET_LEVEL(ch)       ((ch)->player.level)
#define GET_LIFEFORCE(ch)   ((ch)->player.lifeforce)
#define GET_COMPOSITION(ch) ((ch)->player.composition)
#define GET_SIZE(ch)        ((ch)->player.affected_size)
#define GET_AGE(ch)         (age(ch).year)
#define GET_CLASS(ch)       ((ch)->player.class)
#define GET_HEIGHT(ch)      ((ch)->player.height)
#define GET_WEIGHT(ch)      ((ch)->player.weight)
#define GET_SEX(ch)         ((ch)->player.sex)
#define GET_EXP(ch)         ((ch)->points.exp) 
#define GET_MOVE(ch)       ((ch)->points.move)
#define GET_MAX_MOVE(ch)    ((ch)->points.max_move)
#define GET_MANA(ch)       ((ch)->points.mana)
#define GET_MAX_MANA(ch)    ((ch)->points.max_mana)
#define GET_COINS(ch)       ((ch)->points.coins)
#define GET_PURSE_COINS(ch, coin) (GET_COINS(ch)[coin])
#define GET_PLATINUM(ch)    (GET_COINS(ch)[PLAT])
#define GET_GOLD(ch)        (GET_COINS(ch)[GOLD])
#define GET_SILVER(ch)      (GET_COINS(ch)[SILVER])
#define GET_COPPER(ch)      (GET_COINS(ch)[COPPER])
#define GET_BANK_COINS(ch)  ((ch)->points.bank)
#define GET_ACCOUNT_COINS(ch, coin) (GET_BANK_COINS(ch)[coin])
#define GET_BANK_PLATINUM(ch)   (GET_BANK_COINS(ch)[PLAT])
#define GET_BANK_GOLD(ch)   (GET_BANK_COINS(ch)[GOLD])
#define GET_BANK_SILVER(ch) (GET_BANK_COINS(ch)[SILVER])
#define GET_BANK_COPPER(ch) (GET_BANK_COINS(ch)[COPPER])
#define GET_CASH(ch)        (GET_PLATINUM(ch) * 1000 + \
                             GET_GOLD(ch) * 100 + \
                             GET_SILVER(ch) * 10 + \
                             GET_COPPER(ch))
#define GET_AC(ch)          ((ch)->points.armor)
#define GET_HIT(ch)         ((ch)->points.hit)
#define GET_MAX_HIT(ch)     ((ch)->points.max_hit)
#define GET_BASE_HIT(ch)    ((ch)->player_specials->base_hit)
#define GET_BASE_HITROLL(ch)((ch)->points.base_hitroll)
#define GET_HITROLL(ch)     ((ch)->points.hitroll)
#define GET_BASE_DAMROLL(ch)((ch)->points.base_damroll)
#define GET_DAMROLL(ch)     ((ch)->points.damroll)

#define GET_POS(ch)       ((ch)->char_specials.position)
#define GET_STANCE(ch)       ((ch)->char_specials.stance)
#define AWAKE(ch)           (GET_STANCE(ch) > STANCE_SLEEPING)
#define SLEEPING(ch)        (GET_STANCE(ch) == STANCE_SLEEPING)
#define SITTING(ch)         (GET_POS(ch) == POS_SITTING)
#define STANDING(ch)        (GET_POS(ch) == POS_STANDING)
#define FLYING(ch)          (GET_POS(ch) == POS_FLYING)
#define ALIVE(ch)           (GET_STANCE(ch) != STANCE_DEAD)
#define DECEASED(ch)        (!(ALIVE(ch)))

#define GET_QUIT_REASON(ch) ((ch)->char_specials.quit_reason)
#define GET_PERCEPTION(ch)  ((ch)->char_specials.perception)
#define GET_HIDDENNESS(ch)  ((ch)->char_specials.hiddenness)
#define IS_HIDDEN(ch)       (GET_HIDDENNESS(ch) > 0)
#define GET_IDNUM(ch)       ((ch)->char_specials.idnum)
#define GET_ID(x)           ((x)->id)
#define GET_SAVE(ch, i)     ((ch)->char_specials.apply_saving_throw[(i)])
#define GET_RAGE(ch)        ((ch)->char_specials.rage)
#define IS_ANGRY(ch)        ((ch)->char_specials.rage >= RAGE_ANGRY)
#define CAN_SEE_IN_DARK(ch) \
   (PRF_FLAGGED(ch, PRF_HOLYLIGHT) || EFF_FLAGGED(ch, EFF_ULTRAVISION) \
    || IS_MOB(ch))
#define GET_ALIGNMENT(ch)   ((ch)->char_specials.alignment)
#define IS_GOOD(ch)         (GET_ALIGNMENT(ch) >= 350)
#define IS_EVIL(ch)         (GET_ALIGNMENT(ch) <= -350)
#define IS_NEUTRAL(ch)      (!IS_GOOD(ch) && !IS_EVIL(ch))
#define IS_VICIOUS(ch)      (IS_NPC(ch) ? !MOB_FLAGGED((ch), MOB_NOVICIOUS) : PRF_FLAGGED((ch), PRF_VICIOUS))
#define GET_SKILL(ch, a)    ((ch)->char_specials.skills[(a)] / 10)
#define SET_SKILL(ch, a, p) ((ch)->char_specials.skills[(a)] = (p))
#define GET_ISKILL(ch, a)   ((ch)->char_specials.skills[(a)])
#define OUTDOOR_SNEAK(ch) \
 ((GET_RACE(ch) == RACE_ELF) \
 && ((world[(ch)->in_room].sector_type >= SECT_FIELD) && \
 ((world[(ch)->in_room].sector_type <= SECT_MOUNTAIN) || \
  (world[(ch)->in_room].sector_type == SECT_GRASSLANDS))))
#define IS_STARSTAR(ch)     ((GET_LEVEL(ch) == 99 && GET_EXP(ch) >= \
                             (exp_next_level(99, GET_CLASS(ch)) - 1)))



#define IS_CARRYING_W(ch)   ((ch)->char_specials.carry_weight)
/* There's room for improvement here.  The FLY spell could have an effectiveness
 * that depends on the power of the casting, and determines how much weight
 * can be lifted. */
#define MAXIMUM_FLIGHT_LOAD(ch) (950 * CAN_CARRY_W(ch) / 1000)
#define ADDED_WEIGHT_OK(ch, obj) ( \
      (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(ch) <= CAN_CARRY_W(ch)) && \
      (GET_OBJ_WEIGHT(obj) <= CAN_CARRY_W(ch)))
#define ADDED_WEIGHT_REFUSED(ch, obj) ( \
      (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(ch) > MAXIMUM_FLIGHT_LOAD(ch)))
#define IS_CARRYING_N(ch)   ((ch)->char_specials.carry_items)
#define CAN_CARRY_W(ch)     (str_app[GET_STR(ch)].carry_w)
#define CAN_CARRY_N(ch)     (5 + (GET_DEX(ch) >> 1) + (GET_LEVEL(ch) >> 1))
#define CURRENT_LOAD(ch)    (IS_CARRYING_W(ch) >= CAN_CARRY_W(ch) ? 100 : \
      (int)((IS_CARRYING_W(ch) * 10) / CAN_CARRY_W(ch)))
#define CAN_CARRY_OBJ(ch,obj)  \
   (((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) <= CAN_CARRY_W(ch)) &&   \
    ((IS_CARRYING_N(ch) + 1) <= CAN_CARRY_N(ch)))
#define CAN_GET_OBJ(ch, obj)   \
   (CAN_WEAR((obj), ITEM_WEAR_TAKE) && CAN_CARRY_OBJ((ch),(obj)) && \
    CAN_SEE_OBJ((ch),(obj)) && GET_OBJ_LEVEL(obj) <= GET_LEVEL(ch))


#define GET_EQ(ch, i)       ((ch)->equipment[i])
#define CONSENT(ch)         ((ch)->char_specials.consented)

/* FIGHTING is intentionally a READ-ONLY macro.
 * Call set_battling() and stop_battling() if you need to modify this.
 * See fight.h. */
#define FIGHTING(ch) (1 ? (ch)->target : 0)

#define HUNTING(ch)         ((ch)->char_specials.hunting)
#define RIDING(ch)          ((ch)->char_specials.riding)      
#define RIDDEN_BY(ch)       ((ch)->char_specials.ridden_by)   
#define IS_CORNERED(ch)     ((ch)->cornered_by && \
                             CAN_SEE((ch)->cornered_by, ch) && \
                             FIGHTING((ch)->cornered_by) == (ch) && \
                             (ch)->in_room == (ch)->cornered_by->in_room)
#define IS_GROUPED(ch)      ((ch)->group_master || (ch)->groupees)

#define VIEWED_ABIL(ch, abil)(LIMIT(MIN_ABILITY_VALUE, GET_ACTUAL_##abil(ch), MAX_ABILITY_VALUE))

#define GET_AFFECTED_STR(ch) ((ch)->affected_abils.str)
#define GET_VIEWED_STR(ch)   VIEWED_ABIL(ch, STR)
#define GET_ACTUAL_STR(ch)   ((ch)->actual_abils.str)
#define GET_NATURAL_STR(ch)  ((ch)->natural_abils.str)
#define GET_STR(ch)          GET_AFFECTED_STR(ch)

#define GET_AFFECTED_INT(ch) ((ch)->affected_abils.intel)
#define GET_VIEWED_INT(ch)   VIEWED_ABIL(ch, INT)
#define GET_ACTUAL_INT(ch)   ((ch)->actual_abils.intel)
#define GET_NATURAL_INT(ch)  ((ch)->natural_abils.intel)
#define GET_INT(ch)          GET_AFFECTED_INT(ch)

#define GET_AFFECTED_WIS(ch) ((ch)->affected_abils.wis)
#define GET_VIEWED_WIS(ch)   VIEWED_ABIL(ch, WIS)
#define GET_ACTUAL_WIS(ch)   ((ch)->actual_abils.wis)
#define GET_NATURAL_WIS(ch)  ((ch)->natural_abils.wis)
#define GET_WIS(ch)          GET_AFFECTED_WIS(ch)

#define GET_AFFECTED_DEX(ch) ((ch)->affected_abils.dex)
#define GET_VIEWED_DEX(ch)   VIEWED_ABIL(ch, DEX)
#define GET_ACTUAL_DEX(ch)   ((ch)->actual_abils.dex)
#define GET_NATURAL_DEX(ch)  ((ch)->natural_abils.dex)
#define GET_DEX(ch)          GET_AFFECTED_DEX(ch)

#define GET_AFFECTED_CON(ch) ((ch)->affected_abils.con)
#define GET_VIEWED_CON(ch)   VIEWED_ABIL(ch, CON)
#define GET_ACTUAL_CON(ch)   ((ch)->actual_abils.con)
#define GET_NATURAL_CON(ch)  ((ch)->natural_abils.con)
#define GET_CON(ch)          GET_AFFECTED_CON(ch)

#define GET_AFFECTED_CHA(ch) ((ch)->affected_abils.cha)
#define GET_VIEWED_CHA(ch)   VIEWED_ABIL(ch, CHA)
#define GET_ACTUAL_CHA(ch)   ((ch)->actual_abils.cha)
#define GET_NATURAL_CHA(ch)  ((ch)->natural_abils.cha)
#define GET_CHA(ch)          GET_AFFECTED_CHA(ch)


/* Player accessors */
#define GET_PAGE_LENGTH(ch) ((ch)->player_specials->page_length)
#define GET_PASSWD(ch)      ((ch)->player.passwd)
#define GET_PROMPT(ch)      ((ch)->player.prompt)
#define GET_HOMEROOM(ch)        ((ch)->player.homeroom)
#define GET_LASTLEVEL(ch)   ((ch)->player_specials->lastlevel)
#define GET_COND(ch, i)       ((ch)->player_specials->conditions[(i)])
#define IS_HUNGRY(ch)       (GET_COND((ch), FULL) == 0)
#define IS_THIRSTY(ch)      (GET_COND((ch), THIRST) == 0)
#define IS_DRUNK(ch)        (GET_COND((ch), DRUNK) > 0)
#define GET_LOADROOM(ch)    ((ch)->player_specials->load_room)
#define GET_SAVEROOM(ch)    ((ch)->player_specials->save_room)
#define GET_AUTOINVIS(ch)   ((ch)->player_specials->autoinvis_level)
#define GET_INVIS_LEV(ch)   ((ch)->player_specials->invis_level)
#define GET_WIMP_LEV(ch)    ((ch)->player_specials->wimp_level)
#define GET_AGGR_LEV(ch)    ((ch)->player_specials->aggressive)
#define GET_FREEZE_LEV(ch)  ((ch)->player_specials->freeze_level)
#define GET_BAD_PWS(ch)     ((ch)->player_specials->bad_pws)
#define GET_TALK(ch, i)     ((ch)->player_specials->talks[i])
#define GET_LOG_VIEW(ch)    ((ch)->player_specials->log_view)
#define GET_POOFIN(ch)      ((ch)->player_specials->poofin)
#define GET_POOFOUT(ch)     ((ch)->player_specials->poofout)
#define GET_LAST_OLC_TARG(ch) ((ch)->player_specials->last_olc_targ)
#define GET_LAST_OLC_MODE(ch) ((ch)->player_specials->last_olc_mode)
#define GET_ALIASES(ch)     ((ch)->player_specials->aliases)
#define GET_LAST_TELL(ch)   ((ch)->player_specials->last_tell)
#define GET_ROLL(ch, id)    ((ch)->player_specials->roll[id])
#define GET_HOST(ch)        ((ch)->player_specials->host)
#define GET_SPELL_MEM(ch)   ((ch)->spell_memory)
#define GET_GRANT_CACHE(ch)  ((ch)->player_specials->grant_cache)
#define GET_REVOKE_CACHE(ch) ((ch)->player_specials->revoke_cache)
#define GET_GRANTS(ch)      ((ch)->player_specials->grants)
#define GET_REVOKES(ch)     ((ch)->player_specials->revokes)
#define GET_GRANT_GROUPS(ch)((ch)->player_specials->grant_groups)
#define GET_REVOKE_GROUPS(ch) ((ch)->player_specials->revoke_groups)


/* Mob accessors */
#define GET_EX_HIT(ch)      ((ch)->mob_specials.ex_hit)
#define GET_EX_MAX_HIT(ch)  ((ch)->mob_specials.ex_max_hit)
#define GET_EX_MAIN_HP(ch)  ((ch)->mob_specials.ex_main_hp)
#define GET_EX_GOLD(ch)     ((ch)->mob_specials.ex_gold)
#define GET_EX_PLATINUM(ch)     ((ch)->mob_specials.ex_platinum)
#define GET_EX_EXP(ch)      ((ch)->mob_specials.ex_exp)
#define GET_EX_AC(ch)       ((ch)->mob_specials.ex_armor)
#define GET_EX_MANA(ch)     ((ch)->mob_specials.ex_mana)
#define GET_EX_MAX_MANA(ch) ((ch)->mob_specials.ex_max_mana)
#define GET_MOB_RNUM(mob)   ((mob)->mob_specials.nr)
#define GET_MOB_SPEC(ch)    (IS_MOB(ch) ? (mob_index[GET_MOB_RNUM(ch)].func) : NULL)
#define GET_MOB_VNUM(mob)   (IS_MOB(mob) ? \
             mob_index[GET_MOB_RNUM(mob)].virtual : -1)
#define GET_MOB_WAIT(ch)    ((ch)->mob_specials.wait_state)
#define GET_DEFAULT_POS(ch) ((ch)->mob_specials.default_pos)
#define MEMORY(ch)          ((ch)->mob_specials.memory)
#define GET_MOB_SPLBANK(ch, circle) \
    ((ch)->mob_specials.spell_bank[(circle)])
#define GET_MOB_SPLMEM_TIME(ch) \
    ((ch)->mob_specials.spell_mem_time)


/* descriptor-based utils ************************************************/

#define WAIT_STATE(ch, cycle) do { \
   if ((ch)->desc) \
   if (GET_LEVEL(ch) > LVL_IMMORT) \
      (ch)->desc->wait = 0; \
   else \
      (ch)->desc->wait = (cycle); \
   else if (IS_NPC(ch)) GET_MOB_WAIT(ch) = (cycle); } while (0)

#define CHECK_WAIT(ch) \
   (IS_NPC(ch) ? GET_MOB_WAIT(ch) : (((ch)->desc) ? ((ch)->desc->wait > 1) : 0))

#define STATE(d)   ((d)->connected)
#define IS_PLAYING(d)   (STATE(d) == CON_TRIGEDIT || STATE(d) == CON_REDIT || \
                         STATE(d) == CON_MEDIT || STATE(d) == CON_OEDIT || \
                         STATE(d) == CON_ZEDIT || STATE(d) == CON_SEDIT || \
                         STATE(d) == CON_SDEDIT || STATE(d) == CON_PLAYING || \
                         STATE(d) == CON_HEDIT)
#define EDITING(d) ((d)->editor)

/* compound utilities and other macros **********************************/

#define HSHR(ch)   (GET_SEX(ch) ? (GET_SEX(ch) == SEX_MALE ? "his":"her") : "its")
#define HSSH(ch)   (GET_SEX(ch) ? (GET_SEX(ch) == SEX_MALE ? "he" :"she") : "it")
#define HMHR(ch)   (GET_SEX(ch) ? (GET_SEX(ch) == SEX_MALE ? "him":"her") : "it")
#define HISHER(ch) HSHR(ch)
#define HESHE(ch)  HSSH(ch)
#define HIMHER(ch) HMHR(ch)


#define ANA(obj)   (strchr("aeiouyAEIOUY", *(obj)->name) ? "An" : "A")
#define SANA(obj)  (strchr("aeiouyAEIOUY", *(obj)->name) ? "an" : "a")

#define SENDOK(ch) ((ch)->desc && (AWAKE(ch) || sleep) && \
           ((!PLR_FLAGGED((ch), PLR_WRITING) && !EDITING((ch)->desc)) || \
                     (olc && PRF_FLAGGED((ch), PRF_OLCCOMM))))


/* Various macros building up to CAN_SEE */

#define LIGHT_OK(sub)   (!EFF_FLAGGED(sub, EFF_BLIND) && \
   (IS_NPC(sub) || IS_LIGHT((sub)->in_room) || \
    EFF_FLAGGED((sub), EFF_ULTRAVISION)))

#define INVIS_OK(sub, obj) \
 ((!EFF_FLAGGED((obj), EFF_INVISIBLE) || EFF_FLAGGED(sub, EFF_DETECT_INVIS)) && \
 (GET_HIDDENNESS(obj) <= GET_PERCEPTION(sub) ))

#define MORT_CAN_SEE(sub, obj) (LIGHT_OK(sub) && INVIS_OK(sub, obj))

#define IMM_CAN_SEE(sub, obj) \
   (MORT_CAN_SEE(sub, obj) || PRF_FLAGGED(sub, PRF_HOLYLIGHT))

#define SELF(sub, obj)  ((sub) == (obj))

#define IMM_VIS_OK(sub, obj) \
  ((GET_LEVEL(obj) >= LVL_IMMORT) && ((CONSENT(obj) == sub) || \
   (PRF_FLAGGED((obj), PRF_ROOMVIS) && IN_ROOM(sub) == IN_ROOM(obj))))

/* Can subject see character "obj"? */
#define CAN_SEE(sub, obj) ((SELF(sub, obj)) || \
 ((GET_LEVEL(REAL_CHAR(sub)) >= GET_INVIS_LEV(obj)) && IMM_CAN_SEE(sub, obj)) || \
  IMM_VIS_OK(sub, obj))

#define CAN_SEE_BY_INFRA(sub, obj) ((SELF(sub, obj)) || \
 ((GET_LEVEL(REAL_CHAR(sub)) >= GET_INVIS_LEV(obj)) && \
   (( (!EFF_FLAGGED(sub, EFF_BLIND) && EFF_FLAGGED(sub, EFF_INFRAVISION)) \
  && INVIS_OK(sub, obj)) || PRF_FLAGGED(sub, PRF_HOLYLIGHT)) ) || \
  IMM_VIS_OK(sub, obj))

/* End of CAN_SEE */

#define CAN_SEE_MOVING(sub, obj) (CAN_SEE(sub, obj) && \
      (!EFF_FLAGGED(obj, EFF_MISDIRECTING) || PRF_FLAGGED(sub, PRF_HOLYLIGHT)))
#define SEES_THROUGH_MISDIRECTION(sub, obj) \
      (GET_LEVEL(sub) >= LVL_IMMORT && GET_LEVEL(sub) >= GET_LEVEL(obj))

#define PERS(ch, vict)   (CAN_SEE((vict), (ch)) ? GET_NAME(ch) : "someone")

#define ALONE(ch)  (!(ch) || ((ch)->in_room == NOWHERE) || \
          (((ch)->next_in_room == NULL) && (world[(ch)->in_room].people == (ch))))

/* OS compatibility ******************************************************/

/* there could be some strange OS which doesn't have NULL... */
#ifndef NULL
  #define NULL (void *)0
#endif

#if !defined(FALSE)
  #define FALSE 0
#endif

#if !defined(TRUE)
 #define TRUE  (!FALSE)
#endif

/* defines for fseek */
#ifndef SEEK_SET
  #define SEEK_SET   0
  #define SEEK_CUR   1
  #define SEEK_END   2
#endif

#if defined(NOCRYPT) || !defined(HAVE_CRYPT)
  #define CRYPT(a,b) (a)
#else
  #define CRYPT(a,b) ((char *) crypt((a),(b)))
#endif


#define SD_LVL_MULT(i) spell_dam_info[i].lvl_mult
#define SD_SPELL(i) spell_dam_info[i].spell
#define SD_INTERN_DAM(i) spell_dam_info[i].intern_dam
#define SD_NPC_NO_DICE(i) spell_dam_info[i].npc_no_dice
#define SD_NPC_NO_FACE(i) spell_dam_info[i].npc_no_face
#define SD_PC_NO_DICE(i) spell_dam_info[i].pc_no_dice
#define SD_PC_NO_FACE(i) spell_dam_info[i].pc_no_face
#define SD_NPC_REDUCE_FACTOR(i) spell_dam_info[i].npc_reduce_factor
#define SD_USE_BONUS(i) spell_dam_info[i].use_bonus
#define SD_BONUS(i) spell_dam_info[i].max_bonus
#define SD_NPC_STATIC(i) spell_dam_info[i].npc_static
#define SD_PC_STATIC(i) spell_dam_info[i].pc_static
#define SD_NOTE(i) spell_dam_info[i].note
#define SPELL_DAM_FILE "misc/spell_dams" /*for spell dams*/

/* Format strings for strftime */
#define TIMEFMT_LOG "%a %d %b %Y %H:%M:%S"   /* 24 characters */
#define TIMEFMT_DATE "%b %d %Y"              /* 11 characters */

#endif

/***************************************************************************
 * $Log: utils.h,v $
 * Revision 1.179  2009/06/10 02:27:14  myc
 * Replace a magic 100 with the correct LVL_IMMORT.
 *
 * Revision 1.178  2009/06/09 05:51:38  myc
 * Changing cap_by_color so CAP() still returns the string in
 * question, but doesn't require a comma sequence.  Adding
 * accessor macros for privilege flags and character forwarding.
 *
 * Revision 1.177  2009/03/20 23:02:59  myc
 * Remove text editor connection state.
 *
 * Revision 1.176  2009/03/20 14:25:58  jps
 * Added macros for getting coin amounts from characters.
 *
 * Revision 1.175  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.174  2009/03/13 04:40:10  jps
 * Fix up some money macros.
 *
 * Revision 1.173  2009/03/13 04:21:41  jps
 * Update coin macros
 *
 * Revision 1.171  2009/03/09 05:51:25  jps
 * Moved some money-related functions from utils to money
 *
 * Revision 1.170  2009/03/09 03:33:03  myc
 * Split off string functions from this file into strings.c
 *
 * Revision 1.169  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.168  2009/03/07 11:13:30  jps
 * Updated seeing/darkness macros
 *
 * Revision 1.167  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default;
 * assert L_NOFILE to prevent that.
 *
 * Revision 1.166  2009/02/11 17:03:39  myc
 * Add smash_tilde(), which removes tildes from the end of lines.
 * Make str_ functions take const formats.  Check EDITING(d)
 * in SENDOK().
 *
 * Revision 1.165  2008/09/26 18:37:59  jps
 * Make FIGHTING a read-only macro.
 *
 * Revision 1.164  2008/09/25 04:47:49  jps
 * Add drop_core() function, to drop the mud's core without terminating.
 *
 * Revision 1.163  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.162  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.161  2008/09/21 04:54:23  myc
 * Added grant caches to the player structure to make can_use_command
 * take less execution time.
 *
 * Revision 1.160  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.159  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.158  2008/09/07 20:05:55  jps
 * Fixed IS_STARSTAR to correctly look at the exp for level 100.
 *
 * Revision 1.157  2008/09/07 18:45:15  jps
 * Added briefmoney function for printing the top two coins of a money
 * value in a given number of spaces. With color.
 *
 * Revision 1.156  2008/09/07 07:20:12  jps
 * Added MORTALALLY macro.
 *
 * Revision 1.155  2008/09/07 01:28:48  jps
 * Define maximum flight load. Also you can't be given enough weight to make
 * you fall from flying.
 *
 * Revision 1.154  2008/09/06 19:10:31  jps
 * Add PLAYERALLY macro.
 *
 * Revision 1.153  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.152  2008/09/03 17:34:08  myc
 * Moved liquid information into a def struct array.
 *
 * Revision 1.151  2008/09/02 06:50:25  jps
 * Moving some function prototypes to limits.h. Some other ones weren't used
 * anywhere so I deleted them.
 *
 * Revision 1.150  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.149  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.148  2008/09/01 18:29:38  jps
 * consolidating cooldown code in skills.c/h
 *
 * Revision 1.147  2008/09/01 00:01:44  jps
 * Added AGGR_TO_PLAYERS macro.
 *
 * Revision 1.146  2008/08/30 04:13:45  myc
 * Replaced the exp_to_level monstrosity with a lookup table that gets
 * populated at boot time.
 *
 * Revision 1.145  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.144  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.143  2008/08/29 04:16:26  myc
 * Rewrote str_start/str_cat/str_catf and added several more
 * functions.  Also made it support up to 50 simultaneous
 * references to separate buffers.
 *
 * Revision 1.142  2008/08/26 04:39:21  jps
 * Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
 *
 * Revision 1.141  2008/08/25 00:20:33  myc
 * Changed the way mobs memorize spells.
 *
 * Revision 1.140  2008/08/14 23:10:35  myc
 * Added vararg functionality to log() and mudlog().  mprintf() is
 * the new vararg mudlog().  The old non-vararg mudlog() is still
 * available.  Added graduated log severity to the mudlog.
 *
 * Revision 1.139  2008/08/09 20:35:57  jps
 * Changed sense life so that it has a chance of detecting the presence and movement
 * of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
 *
 * Revision 1.138  2008/07/15 17:55:06  myc
 * Added accessor macros for grants and grant groups on the
 * player structure.
 *
 * Revision 1.137  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.136  2008/06/05 02:07:43  myc
 * Replaced strip_cr with filter_chars/strip_chars.  Removed the
 * cost_per_day and spell component fields from the object
 * structure.  Changed object flags to use flagvectors.
 *
 * Revision 1.135  2008/05/18 04:42:09  jps
 * Code formatting change
 *
 * Revision 1.134  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.133  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.132  2008/04/19 21:11:22  myc
 * Added some general-purpose integer array sorting functions.
 * Right now, we've got bubble sort, insertion sort, quicksort,
 * and some apparently-optimized quicksort I found on Google :)
 *
 * Revision 1.131  2008/04/13 19:38:05  jps
 * Added macro for CONFUSED(ch).
 *
 * Revision 1.130  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.129  2008/04/04 06:12:52  myc
 * Removed justice and dieites/worship code.
 *
 * Revision 1.128  2008/04/03 17:33:57  jps
 * Added GET_AUTOINVIS macro.
 *
 * Revision 1.127  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.126  2008/04/02 19:31:02  myc
 * Added str_catf functions and used them in do_stat functions.
 *
 * Revision 1.125  2008/04/02 04:55:59  myc
 * Added a parse money function.
 *
 * Revision 1.124  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.
 *
 * Revision 1.123  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.122  2008/03/23 00:25:02  jps
 * Add a function to format applies, since it's done in at least
 * three places in the server.
 *
 * Revision 1.121  2008/03/22 19:08:19  jps
 * Added parse_obj_name as a generalized object identifier.
 * Added macros to get a character's life force and composition.
 *
 * Revision 1.120  2008/03/21 21:36:02  jps
 * Add functions without_article and pluralize, for modifying
 * nouns and noun phrases.
 *
 * Revision 1.119  2008/03/21 15:01:17  myc
 * Removed languages.
 *
 * Revision 1.118  2008/03/17 15:31:27  myc
 * Fix WAIT_STATE macro so it can be used properly as a single statement.
 *
 * Revision 1.117  2008/03/16 00:19:11  jps
 * Moved GET_TROPHY macro to trophy.h.
 *
 * Revision 1.116  2008/03/11 19:50:55  myc
 * Changed the way allowed olc zones are saved on an immortal from
 * a fixed number of slots to a variable-length linked list.  Also
 * got rid of practice points.
 *
 * Revision 1.115  2008/03/11 02:13:05  jps
 * Moving size macro to chars.h.
 *
 * Revision 1.114  2008/03/10 20:49:47  myc
 * Renamed POS1 to 'stance'.  Renamed hometown to homeroom.
 *
 * Revision 1.113  2008/03/10 19:55:37  jps
 * Made a struct for sizes with name, height, and weight.  Save base height
 * weight and size so they stay the same over size changes.
 *
 * Revision 1.112  2008/03/09 18:14:50  jps
 * Added defs for CAN_SEE_MOVING and SEES_THROUGH_MISDIRECTION.
 *
 * Revision 1.111  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.110  2008/03/08 23:55:21  jps
 * Added MOB_PERFORMS_SCRIPTS macro, which determines whether a mob can
 * do specprocs or triggers.
 *
 * Revision 1.109  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.108  2008/03/06 05:11:51  myc
 * Combined the 'saved' and 'unsaved' portions of the char_specials and
 * player_specials structures by moving all fields of each saved structure
 * to its parent structure.  Also combined the skills array from the
 * player and mob structures since they are identical.
 *
 * Revision 1.107  2008/03/06 04:35:02  myc
 * Moved the IS_VICIOUS macro here from structs.h.
 *
 * Revision 1.106  2008/03/05 05:21:56  myc
 * Made bank coins into ints instead of longs.
 *
 * Revision 1.105  2008/03/05 03:03:54  myc
 * Added sprintascii function.  Moved get_filename to players.c.  Got
 * rid of BOUNDED.  Added strip_cr and trim_spaces.
 *
 * Revision 1.104  2008/02/24 17:31:13  myc
 * Added a TO_OLC flag to act() to allow messages to be sent to
 * people while in OLC if they have OLCComm toggled on.
 *
 * Revision 1.103  2008/02/23 01:03:54  myc
 * Moving some spell circle and memorization functions from here to
 * spells.h.
 *
 * Revision 1.102  2008/02/16 20:31:32  myc
 * Commented out str_dup to help disambiguate memory leaks.
 *
 * Revision 1.101  2008/02/09 21:07:50  myc
 * Memming uses event flag instead of plr flag now.
 *
 * Revision 1.100  2008/02/09 18:29:11  myc
 * Camping and tracking now use event flags instead of having
 * their own event fields on the char_data struct..
 *
 * Revision 1.99  2008/02/09 07:05:37  myc
 * Adding an IS_PLAYING macro, which returns true if a descriptor
 * is playing or is in an OLC-type editor.
 *
 * Revision 1.98  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.97  2008/02/09 03:06:17  myc
 * Moving mathematical functions to math.c, and including math.h
 * everywhere utils.h is included.
 *
 * Revision 1.96  2008/02/07 01:46:14  myc
 * Removing the size abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
 * which points to the sizes array.
 *
 * Revision 1.95  2008/02/06 21:53:53  myc
 * Adding a function to count color characters in a string (useful
 * for changing string widths in sprintf statements).
 *
 * Revision 1.94  2008/02/02 19:38:20  myc
 * Adding a levenshtein distance calculator for use by the
 * interpreter.  Also added a macro for accessing permanent
 * player titles.
 *
 * Revision 1.93  2008/01/30 19:20:57  myc
 * Adding support for the array bitvectors from newer versions of
 * Circle.  However, unlike stock circle, they are named FLAGs instead
 * of BIT_ARs.  So we have IS_FLAGGED instead of IS_SET, SET_FLAG for
 * SET_BIT, REMOVE_FLAG instead of REMOVE_BIT, and TOGGLE_FLAG instead
 * of TOGGLE_BIT.  The new event flags use these array bitvectors.
 *
 * Revision 1.92  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.91  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.90  2008/01/27 12:11:58  jps
 * Fix the CHECK_WAIT macro. Learn to write macros!
 * Moved some IS_CLASS macros to class.h, deleted some unused ones.
 *
 * Revision 1.89  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.88  2008/01/27 02:25:25  jps
 * Adjust CHECK_WAIT for mobs.
 *
 * Revision 1.87  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.86  2008/01/25 21:12:04  myc
 * Renamed monk_weight_pen to monk_weight_penalty.
 *
 * Revision 1.85  2008/01/17 01:29:10  myc
 * I'm pretty sure the mud only has 16 months...
 *
 * Revision 1.84  2008/01/15 06:51:47  myc
 * Added paranthesis to REAL_CHAR to make sure nothing goes awry.
 *
 * Revision 1.83  2008/01/15 03:18:19  myc
 * Changed SENSE_LIFE to its former function (showing any hidden mobs)
 * instead of adding some amount to perception.  That way it doesn't
 * apply to objects.
 *
 * Revision 1.82  2008/01/14 21:28:21  myc
 * Added GET_AGGR_LEV macro.
 *
 * Revision 1.81  2008/01/13 23:06:04  myc
 * Updated CAN_GET_OBJ macro to check the object's level.
 *
 * Revision 1.80  2008/01/13 03:19:53  myc
 * Removed GET_MSKILL and SET_MSKILL macros.
 *
 * Revision 1.79  2008/01/09 10:08:33  jps
 * Added CAN_SEE_BY_INFRA macro.
 *
 * Revision 1.78  2008/01/09 08:33:38  jps
 * Add functions to format strings for printin lengths and weights.
 *
 * Revision 1.77  2008/01/09 04:13:59  jps
 * New macro MEMMING for players who are memorizing.
 *
 * Revision 1.76  2008/01/09 02:29:33  jps
 * Modify GET_MOB_RNUM, real num moved to mob_specials.
 *
 * Revision 1.75  2008/01/09 01:51:25  jps
 * Get rid of obsolete defs for points and damage events.
 *
 * Revision 1.74  2008/01/05 21:55:09  jps
 * Added circular-dependency prevention defs.
 *
 * Revision 1.73  2008/01/05 05:39:03  jps
 * Removing function prototype advance_level() which is in class.c, not utils.c.
 *
 * Revision 1.72  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.71  2008/01/03 12:45:43  jps
 * New string function with_indefinite_article.
 * Renamed CLASS_MAGIC_USER to CLASS_SORCERER.
 *
 * Revision 1.70  2007/12/25 06:37:05  jps
 * Fix CURRENT_LOAD for highly loaded people (e.g., approaching max int).
 *
 * Revision 1.69  2007/12/20 23:13:03  myc
 * Cleaned up the CURRENT_LOAD macro.
 *
 * Revision 1.68  2007/12/19 20:58:40  myc
 * Renamed CLOAKED toggle to ROOMVIS.  Added const modifiers to str_cmp,
 * strn_cmp, log, touch, and mudlog.
 *
 * Revision 1.67  2007/10/27 03:18:58  myc
 * Fixed bug in CAN_SEE so mobs can see without lights.  Removed MCAN_SEE
 * since it does the same thing as CAN_SEE.
 *
 * Revision 1.66  2007/10/25 20:41:13  myc
 * Added WEAPON_AVERAGE macro and fixed typo in IS_WEAPON_BLUDGEONING.
 *
 * Revision 1.65  2007/10/02 02:52:27  myc
 * Renamed ORIG_CHAR as REAL_CHAR.  PRF_FLAGGED now uses REAL_CHAR,
 * so the preferences on the original player are always checked, even
 * when someone is switched or shapechanged.
 *
 * Revision 1.64  2007/09/28 20:49:35  myc
 * Added find_zone prototype.  Fixing a bug in HIDDEN_OK_OBJ that was
 * preventing objects from being seen.
 *
 * Revision 1.63  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Rewrote CAN_SEE and CAN_SEE_OBJ
 * to handle this.  Also added cloaked toggle so people in the room can
 * see you even when everyone else can't (due to wizinvis).  Got rid of
 * all those racial stat defines and moved them to an array in db.c.
 *
 * Revision 1.62  2007/09/15 05:03:46  myc
 * Added MOB2 flags, which are saved as an espec in the mob files. The
 * MOB2_FLAGS and MOB2_FLAGGED macros are now available.
 *
 * Revision 1.61  2007/09/12 19:23:04  myc
 * Fix to IS_DARK to make city rooms always lit.
 *
 * Revision 1.60  2007/09/04 06:49:19  myc
 * Cleaned up IS_DARK macro.
 * IN_ZONE is now an rnum.
 *
 * Revision 1.59  2007/09/03 23:59:43  jps
 * Added macro ADDED_WEIGHT_OK for testing whether a char can have an
 * object added to its inventory.  Avoids an integer overflow problem
 * that could occur if an object's weight was near maxint.
 *
 * Revision 1.58  2007/08/16 11:53:39  jps
 * Remove various defunct specprocs.
 *
 * Revision 1.57  2007/08/14 22:43:07  myc
 * Adding conceal, corner, shadow, and stealth skills.
 *
 * Revision 1.56  2007/08/04 22:20:20  jps
 * Added some macros for rooms - IS_WATER, IS_SPLASHY
 *
 * Revision 1.55  2007/08/02 01:04:10  myc
 * check_pk() now works for all PK cases.  Moved from magic.c to fight.c
 *
 * Revision 1.54  2007/07/31 23:44:36  jps
 * New macros IS_HUNGRY, IS_THIRSTY, IS_DRUNK.
 *
 * Revision 1.53  2007/07/25 00:38:03  jps
 * Add macro IN_ZONE, like IN_ROOM only zonier.
 *
 * Revision 1.52  2007/07/19 21:59:36  jps
 * Add utility function next_line.
 *
 * Revision 1.51  2007/07/18 18:29:55  jps
 * Allow SIZE_ABBR to use GET_SIZE for NPCs.
 *
 * Revision 1.50  2007/07/15 17:16:12  jps
 * Add IS_POISONED macro, and moved HIGHLY_VISIBLE macro to utils.h
 *
 * Revision 1.49  2007/04/19 04:50:18  myc
 * Created macros for checking weapon types.
 *
 * Revision 1.48  2007/04/18 00:05:59  myc
 * Prompt parser has been totally rewritten so it won't print garbage
 * characters anymore.  Also, some new features were added.  Giving the
 * prompt command back to mortals.
 *
 * Revision 1.47  2007/04/04 13:31:02  jps
 * Add year to log timestamps and other dates.
 *
 * Revision 1.46  2007/03/27 04:27:05  myc
 * Changed spellings of innate timer macro.
 *
 * Revision 1.45  2007/02/04 18:12:31  myc
 * Page length now saves as a part of player specials.
 *
 * Revision 1.44  2006/11/27 02:07:05  jps
 * Allow "look in" to work like "look at" for ALL gate-spell objects.
 *
 * Revision 1.43  2006/11/26 08:31:17  jps
 * Added function yesno_result to standardize handling of nanny's
 * yes/no questions (in interpreter.c).
 *
 * Revision 1.42  2006/11/18 09:08:15  jps
 * Add function statemoney to pretty-print coins
 *
 * Revision 1.41  2006/11/18 07:22:34  jps
 * Add isplural function
 *
 * Revision 1.40  2006/11/18 04:26:32  jps
 * Renamed continual light spell to illumination, and it only works on
 * LIGHT items (still rooms too).
 *
 * Revision 1.39  2006/11/11 16:13:08  jps
 * Fix CAP so it correctly capitalizes strings with color codes at the beginning.
 *
 * Revision 1.38  2004/11/11 19:17:21  cmc
 * added prototype for perform_random_gem_drop()
 * warning message for fight.c no longer generated
 *
 * Revision 1.37  2003/06/23 01:47:09  jjl
 * Added a NOFOLLOW flag, and the "note" command, and show notes <player>
 *
 * Revision 1.36  2003/04/16 02:05:41  jjl
 * SKILL_DELAY addition.
 *
 * Revision 1.35  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.34  2001/12/07 15:42:12  dce
 * Fixed a duplicate entry.
 *
 * Revision 1.33  2001/04/08 17:13:10  dce
 * Added an alwayslit flag that makes a room lit no matter
 * of the sector or room type...
 *
 * Revision 1.32  2001/03/24 05:12:01  dce
 * Objects will now accept a level through olc and upon
 * booting the objects. The level code for the players will
 * follow.
 *
 * Revision 1.31  2000/11/25 02:33:15  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.30  2000/10/27 00:34:45  mtp
 * extra define for saving quests info
 *
 * Revision 1.29  2000/05/18 04:29:39  rsd
 * altered some of the racial balances of attributes.
 * Halflevs were less charismatic than humans? boggle
 *
 * Revision 1.28  2000/04/22 22:45:04  rsd
 * fixed comment header while browsing the file
 *
 * Revision 1.27  2000/02/24 01:07:44  dce
 * Gods no longer have a WAIT_STATE time. It is set to 0.
 *
 * Revision 1.26  2000/01/31 00:26:25  rsd
 * altered the define for PLR_CORPSE to make it so corpses
 * get defined properly.
 *
 * Revision 1.25  1999/11/29 00:13:41  cso
 * added define for GET_SHORT (from dg_scripts)
 * added defines for corpse types (CORPSE_PC, _NPC, _NPC_NORAISE)
 * changed define of IS_PLR_CORPSE
 * changed define of IS_MAGIC_USER to check for npc m-u
 * changed define of IS_THIEF to check for npc thief
 *
 * Revision 1.24  1999/10/30 16:16:48  rsd
 * Jimmy coded alignment restrictions for Paladins and exp
 * altered the definition of gain_exp() to include a check
 * for the victim.
 *
 * Revision 1.23  1999/09/16 01:15:11  dce
 * Weight restrictions for monks...-hitroll, -damroll + ac
 *
 * Revision 1.22  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.21  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.20  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.19  1999/08/08 19:37:25  mud
 * heh, well added additional check to the IS_PLR_CORPSE
 * macro to make doubly sure the item in question was in
 * fact a corpse and not any object with the second byte
 * set to 1. *whistle*
 *
 * Revision 1.18  1999/08/07 23:51:29  mud
 * removed some double defines of IS_CORPSE and added the
 * define for IS_PLR_CORPSE to reference the exiding
 * container structure.
 *
 * Revision 1.17  1999/07/24 20:50:18  dce
 * Exchange command for banks added.
 *
 * Revision 1.16  1999/07/06 19:57:05  jimmy
 * This is a Mass check-in of the new skill/spell/language assignment system.
 * This New system combines the assignment of skill/spell/language for
 * both mobs and PCs.  LOts of code was touched and many errors were fixed.
 * MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
 * MObs now get random skill/spell/language levels baseed on their race/class/level
 * that exactly align with PC's.  PC's no longer have to rent to use skills gained
 * by leveling or when first creating a char.  Languages no longer reset to defaults
 * when a PC levels.  Discovered that languages have been defined right in the middle
 * of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
 * the mob files to compensate for the 13 to -1 class change.
 * --gurlaek 7/6/1999
 *
 * Revision 1.15  1999/06/30 18:25:04  jimmy
 * >> This is a major conversion from the 18 point attribute system to the
 * >> 100 point attribute system.  A few of the major changes are:
 * >> All attributes are now on a scale from 0-100
 * >> Everyone views attribs the same but, the attribs for one race
 * >>   may be differeent for that of another even if they are the
 * >>   same number.
 * >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * >> Mobs now have individual random attributes based on race/class.
 * >> The STR_ADD attrib has been completely removed.
 * >> All bonus tables for attribs in constants.c have been replaced by
 * >>   algorithims that closely duplicate the tables except on a 100 scale.
 * >> Some minor changes:
 * >> Race selection at char creation can now be toggled by using
 * >>   <world races off>
 * >> Lots of cleanup done to affected areas of code.
 * >> Setting attributes for mobs in the .mob file no longer functions
 * >>   but is still in the code for later use.
 * >> We now have a spare attribut structure in the pfile because the new
 * >>   system only used three instead of four.
 * >> --gurlaek 6/30/1999
 *
 * Revision 1.14  1999/06/21 19:47:11  jimmy
 * Changed PLR_FLAGGED to do a ? between IS_NPC and IS_SET instead of an &&
 * This was done to prevent the crashes caused by mobs losing the
 * player_special=dummy_mob allocation.  --Gurlaek
 *
 * Revision 1.13  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.12  1999/05/04 17:19:33  dce
 * Name accept system...version one...original code by Fingh, fixed up to work
 * by Zantir.
 *
 * Revision 1.11  1999/03/24 23:43:16  jimmy
 * Working on quest spells.  Still in progress.  HOwever, skills[] array now has a flag
 * quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
 * learn from any sorcerer type teacher
 * fingon
 *
 * Revision 1.10  1999/02/12 20:53:28  dce
 * Now only Sect_City & Room_Indoors will be lit, all other types
 * of Room_indoors and Sect's will be dark.
 *
 * Revision 1.9  1999/02/11 16:44:23  dce
 * Fixes IS_DARK macro.
 *
 * Revision 1.8  1999/02/10 22:27:54  jimmy
 * Added do_wiztitle
 *
 * Revision 1.7  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.6  1999/02/08 23:01:47  jimmy
 * Fixed mortally wounded bug.  Mortally wounded
 * victims now die when they read -11.  Also,
 * no more "attempt to damage corpse"
 * fingon
 *
 * Revision 1.5  1999/02/06 00:40:36  jimmy
 * Major change to incorporate aliases into the pfile
 * moved alias structure from interpreter.h to structs.h
 * heavily modified alias code in interpreter.c
 * Jimmy Kincaid AKA fingon
 *
 * Revision 1.4  1999/02/05 07:47:42  jimmy
 * Added Poofs to the playerfile as well as 4 extra strings for
 * future use.  fingon
 *
 * Revision 1.3  1999/02/04 18:08:43  mud
 * indented comment header
 * dos2unix
 *
 * Revision 1.2  1999/02/01 08:21:13  jimmy
 * improved build counter
 *
 * Revision 1.1  1999/01/29 01:23:32  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.179
log
@Replace a magic 100 with the correct LVL_IMMORT.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.178 2009/06/09 05:51:38 myc Exp myc $
d87 3
d639 3
@


1.178
log
@Changing cap_by_color so CAP() still returns the string in
question, but doesn't require a comma sequence.  Adding
accessor macros for privilege flags and character forwarding.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.177 2009/03/20 23:02:59 myc Exp myc $
d505 1
a505 1
   if (GET_LEVEL(ch) > 100) \
d636 5
@


1.177
log
@Remove text editor connection state.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.176 2009/03/20 14:25:58 jps Exp myc $
d20 1
d143 1
a143 1
#define CAP(st)        (cap_by_color(st), st)
d189 1
a189 1
#define IS_FLAGGED(field, flag)  ((field)[FIELD(flag)] & FLAG(flag))
d211 1
d221 1
d237 1
d248 3
a250 2
#define PLR_TOG_CHK(ch,flag)       (TOGGLE_FLAG(PLR_FLAGS(ch), (flag)) & FLAG(flag))
#define PRF_TOG_CHK(ch,flag)       (TOGGLE_FLAG(PRF_FLAGS(ch), (flag)) & FLAG(flag))
d519 1
a519 1
                         STATE(d) == CON_HEDIT || STATE(d) == CON_CLAN_DESC_EDIT)
d636 3
@


1.176
log
@Added macros for getting coin amounts from characters.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.175 2009/03/16 19:17:52 jps Exp jps $
d514 1
a514 2
                         STATE(d) == CON_HEDIT || STATE(d) == CON_CLAN_DESC_EDIT || \
                         STATE(d) == CON_TEXTED)
d631 3
@


1.175
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.174 2009/03/13 04:40:10 jps Exp jps $
d293 1
d299 1
d632 3
@


1.174
log
@Fix up some money macros.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.173 2009/03/13 04:21:41 jps Exp jps $
d438 1
a438 1
#define GET_HOME(ch)        ((ch)->player.homeroom)
d630 3
@


1.173
log
@Update coin macros
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.171 2009/03/09 05:51:25 jps Exp $
d22 1
d293 1
a293 1
#define GET_PLAT(ch)        (GET_COINS(ch)[PLAT])
d298 1
a298 1
#define GET_BANK_PLAT(ch)   (GET_BANK_COINS(ch)[PLAT])
d302 1
a302 1
#define GET_CASH(ch)        (GET_PLAT(ch) * 1000 + \
d476 1
a476 1
#define GET_EX_PLAT(ch)     ((ch)->mob_specials.ex_plat)
d630 3
@


1.172
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.171 2009/03/09 05:51:25 jps Exp myc $
d287 1
a287 1
#define GET_MOVE(ch)        ((ch)->points.move)
d289 1
a289 1
#define GET_MANA(ch)        ((ch)->points.mana)
d292 1
a292 1
#define GET_PLATINUM(ch)    (GET_COINS(ch)[PLATINUM])
a295 1
#define GET_CASH(ch)        (CASH_VALUE(GET_COINS(ch)))
d297 1
a297 2
#define GET_BANK_PLATINUM(ch) \
                            (GET_BANK_COINS(ch)[PLATINUM])
d301 4
d314 2
a315 2
#define GET_POS(ch)         ((ch)->char_specials.position)
#define GET_STANCE(ch)      ((ch)->char_specials.stance)
d475 1
a475 1
#define GET_EX_PLATINUM(ch) ((ch)->mob_specials.ex_platinum)
@


1.171
log
@Moved some money-related functions from utils to money
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.170 2009/03/09 03:33:03 myc Exp jps $
d287 1
a287 1
#define GET_MOVE(ch)       ((ch)->points.move)
d289 1
a289 1
#define GET_MANA(ch)       ((ch)->points.mana)
d292 1
a292 1
#define GET_PLAT(ch)        (GET_COINS(ch)[PLAT])
d296 1
d298 2
a299 1
#define GET_BANK_PLAT(ch)   (GET_BANK_COINS(ch)[PLAT])
a302 4
#define GET_CASH(ch)        (GET_PLAT(ch) * 1000 + \
                             GET_GOLD(ch) * 100 + \
                             GET_SILVER(ch) * 10 + \
                             GET_COPPER(ch))
d312 2
a313 2
#define GET_POS(ch)       ((ch)->char_specials.position)
#define GET_STANCE(ch)       ((ch)->char_specials.stance)
d473 1
a473 1
#define GET_EX_PLAT(ch)     ((ch)->mob_specials.ex_plat)
d627 3
@


1.170
log
@Split off string functions from this file into strings.c
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.169 2009/03/08 21:43:27 jps Exp myc $
a69 3
void statemoney(char *buf, int coins[]);
bool parse_money(char *money, int coins[]);
void briefmoney(char *buf, int spaces, int amt);
d629 3
@


1.169
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.168 2009/03/07 11:13:30 jps Exp jps $
d19 1
a38 1
void cap_by_color(char *s);
a42 2
int str_cmp(const char *arg1, const char *arg2);
int strn_cmp(const char *arg1, const char *arg2, int n);
a48 4
void sprintbit(long vektor, const char *names[], char *result);
void sprintflag(char *result, flagvector flags[], int num_flags, const char *names[]);
void sprinttype(int type, const char *names[], char *result);
int sprintascii(char *out, flagvector bits);
a51 3
int replace_str(char **string, const char *pattern, const char *replacement, int rep_all, int max_size);
void format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen);
char *stripcr(char *dest, const char *src);
a55 1
char *next_line(char **src);
a56 1
int levenshtein_distance(const char *s1, const char *s2);
a61 14
void trim_spaces(char *buffer);
char *strip_chars(char *str, const char *chars);
char *filter_chars(char *buf, register const char *src, const char *chars);
void smash_tilde(char *str);

typedef struct str_token * str_token;
str_token str_start(char *buf, size_t max_size);
void str_cat(char *buf, const char *str);
void strn_cat(char *buf, const char *str, size_t size);
void str_catf(char *buf, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
void strn_catf(char *buf, size_t size, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
char *str_end(char *buf);
size_t str_space(char *buf);

a69 1
bool isplural(char *namelist);
a79 3
char *with_indefinite_article(const char *s);
const char *without_article(const char *s);
const char *pluralize(const char *s);
d632 3
@


1.168
log
@Updated seeing/darkness macros
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.167 2009/02/21 03:30:16 myc Exp jps $
d312 1
d661 3
@


1.167
log
@Removed L_FILE flag--mprintf now logs to file by default;
assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.166 2009/02/11 17:03:39 myc Exp myc $
d365 2
a366 3
   ((PRF_FLAGGED(ch, PRF_HOLYLIGHT) || EFF_FLAGGED(ch, EFF_ULTRAVISION) \
    || IS_MOB(ch)  \
    || IS_NPC(ch)) && !ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS))
d568 1
a568 2
    EFF_FLAGGED((sub), EFF_ULTRAVISION) || \
    ROOM_EFF_FLAGGED((sub)->in_room, ROOM_EFF_ILLUMINATION)))
d660 4
@


1.166
log
@Add smash_tilde(), which removes tildes from the end of lines.
Make str_ functions take const formats.  Check EDITING(d)
in SENDOK().
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.165 2008/09/26 18:37:59 jps Exp myc $
d126 1
a126 1
#define L_ERR        60 /* other non-fatal errors: something's broke */
d129 1
a129 1
#define L_DBUG       30 /* coding debug/script errors */
d131 2
a132 2
#define L_FINE       10 /* trace info: hard core debug maybe? */
#define L_FILE       (1 << 7)
d662 5
@


1.165
log
@Make FIGHTING a read-only macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.164 2008/09/25 04:47:49 jps Exp jps $
d76 1
d80 4
a83 4
void str_cat(char *buf, char *str);
void strn_cat(char *buf, char *str, size_t size);
void str_catf(char *buf, char *format, ...) __attribute__ ((format (printf, 2, 3)));
void strn_catf(char *buf, size_t size, char *format, ...) __attribute__ ((format (printf, 3, 4)));
d545 1
d561 1
a561 1
           (!PLR_FLAGGED((ch), PLR_WRITING) || \
d662 3
@


1.164
log
@Add drop_core() function, to drop the mud's core without terminating.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.163 2008/09/22 02:09:17 jps Exp jps $
d410 6
a415 1
#define FIGHTING(ch)        ((ch)->target)
d660 3
@


1.163
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.162 2008/09/21 20:40:40 jps Exp jps $
d111 1
d655 4
@


1.162
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.161 2008/09/21 04:54:23 myc Exp jps $
d20 1
d109 1
a109 1
char *stateweight(int pounds);
d398 1
a398 1
      (IS_CARRYING_W(ch) * 10) / CAN_CARRY_W(ch))
d654 4
@


1.161
log
@Added grant caches to the player structure to make can_use_command
take less execution time.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.160 2008/09/20 06:05:06 jps Exp myc $
d408 1
a408 1
#define FIGHTING(ch)        ((ch)->char_specials.fighting)
d653 4
@


1.160
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.159 2008/09/09 08:23:37 jps Exp jps $
d486 2
d489 1
a489 1
#define GET_UNGRANTS(ch)    ((ch)->player_specials->ungrants)
d491 1
a491 1
#define GET_UNGRANT_GROUPS(ch) ((ch)->player_specials->ungrant_groups)
d653 3
@


1.159
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.158 2008/09/07 20:05:55 jps Exp jps $
d244 2
d651 3
@


1.158
log
@Fixed IS_STARSTAR to correctly look at the exp for level 100.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.157 2008/09/07 18:45:15 jps Exp jps $
a284 31
/* room utils ************************************************************/


#define SECT(room)   (world[(room)].sector_type)
#define SUN(room)   (hemispheres[zone_table[world[room].zone].hemisphere].sunlight)
#define IS_DARK(room)   ( \
   (world[room].light < 1 || ROOM_EFF_FLAGGED(room, ROOM_EFF_DARKNESS)) && \
          !ROOM_FLAGGED(room, ROOM_ALWAYSLIT) && \
                         SECT(room) != SECT_CITY && \
          (ROOM_FLAGGED(room, ROOM_DARK) || \
           SECT(room) == SECT_INSIDE || \
           ROOM_FLAGGED(room, ROOM_INDOORS) || \
           SUN(room) == SUN_SET || \
           SUN(room) == SUN_DARK))

#define IS_LIGHT(room)  (!IS_DARK(room) || \
                         ROOM_EFF_FLAGGED(room, ROOM_EFF_ILLUMINATION))

#define IS_WATER(room) \
   (SECT(room) == SECT_SHALLOWS || SECT(room) == SECT_WATER || \
   SECT(room) == SECT_UNDERWATER || SECT(room) == SECT_OCEAN)

#define IS_SPLASHY(room) \
   (SECT(room) == SECT_SHALLOWS || SECT(room) == SECT_WATER || \
   SECT(room) == SECT_OCEAN || SECT(room) == SECT_SWAMP)

#define IS_FOREST(room) \
   (SECT(room) == SECT_FOREST || ROOM_EFF_FLAGGED(room, ROOM_EFF_FOREST))

#define GET_ROOM_SPEC(room) ((room) >= 0 ? world[(room)].func : NULL)

a286 1

a593 2
#define OUTSIDE(ch) (!ROOM_FLAGGED((ch)->in_room, ROOM_INDOORS))

d649 3
@


1.157
log
@Added briefmoney function for printing the top two coins of a money
value in a given number of spaces. With color.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.156 2008/09/07 07:20:12 jps Exp jps $
d69 1
a69 1
long exp_to_level(int level, int class);
d409 1
a409 1
                             (exp_to_level(100, GET_CLASS(ch)) - 1)))
d683 4
@


1.156
log
@Added MORTALALLY macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.155 2008/09/07 01:28:48 jps Exp jps $
d96 1
d683 3
@


1.155
log
@Define maximum flight load. Also you can't be given enough weight to make
you fall from flying.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.154 2008/09/06 19:10:31 jps Exp jps $
d245 1
d249 7
d682 4
@


1.154
log
@Add PLAYERALLY macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.153 2008/09/04 06:47:36 jps Exp jps $
d405 4
d412 2
d674 3
@


1.153
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.152 2008/09/03 17:34:08 myc Exp jps $
d245 2
d668 3
@


1.152
log
@Moved liquid information into a def struct array.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.151 2008/09/02 06:50:25 jps Exp myc $
d293 1
a293 1
   (SECT(room) == SECT_WATER_SWIM || SECT(room) == SECT_WATER_NOSWIM || \
d297 1
a297 1
   (SECT(room) == SECT_WATER_SWIM || SECT(room) == SECT_WATER_NOSWIM || \
d666 3
@


1.151
log
@Moving some function prototypes to limits.h. Some other ones weren't used
anywhere so I deleted them.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.150 2008/09/01 23:47:49 jps Exp jps $
d137 7
d145 4
a148 3
#define SECS_PER_MUD_DAY   (24 * SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH   (35 * SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR   (16 * SECS_PER_MUD_MONTH)
d152 3
a154 3
#define SECS_PER_REAL_HOUR   (60*SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY   (24*SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR   (365*SECS_PER_REAL_DAY)
d666 4
@


1.150
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.149 2008/09/01 22:15:59 jps Exp jps $
a91 14

/* in limits.c */
int mana_limit(struct char_data *ch);
int hit_limit(struct char_data *ch);
int move_limit(struct char_data *ch);
int mana_gain(struct char_data *ch);
int hit_gain(struct char_data *ch);
int move_gain(struct char_data *ch);
void set_title(struct char_data *ch, char *title);
void gain_exp(struct char_data *ch, struct char_data *vict, long gain);
void gain_exp_regardless(struct char_data *ch, long gain);
void gain_condition(struct char_data *ch, int condition, int value);
void check_idling(struct char_data *ch);
void point_update(void);
d658 3
@


1.149
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.148 2008/09/01 18:29:38 jps Exp jps $
a65 4
bool is_grouped(struct char_data *ch, struct char_data *tch);
void add_groupee(struct char_data *master, struct char_data *groupee);
void disband_group(struct char_data *master, bool verbose, bool forceful);
void ungroup(struct char_data *ch, bool verbose, bool forceful);
a75 1

a92 4
/* in act.movmement.c */
int do_simple_move(struct char_data *ch, int dir, int following);
int perform_move(struct char_data *ch, int dir, int following, bool misdirection);

d672 3
@


1.148
log
@consolidating cooldown code in skills.c/h
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.147 2008/09/01 00:01:44 jps Exp jps $
d335 2
d386 1
d496 1
d681 3
@


1.147
log
@Added AGGR_TO_PLAYERS macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.146 2008/08/30 04:13:45 myc Exp jps $
a403 3
#define GET_COOLDOWN(ch, i) ((ch)->char_specials.cooldowns[(i)])
/* defined in skills.c */
void SET_COOLDOWN(struct char_data *ch, int type, int amount);
d677 3
@


1.146
log
@Replaced the exp_to_level monstrosity with a lookup table that gets
populated at boot time.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.145 2008/08/30 01:31:51 myc Exp myc $
d268 6
d680 4
@


1.145
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.144 2008/08/29 19:18:05 myc Exp myc $
d74 1
d674 6
@


1.144
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.143 2008/08/29 04:16:26 myc Exp myc $
d41 1
a41 1
void con_bonus_level(struct char_data *ch);
d359 2
a360 2
#define GET_HIT(ch)       ((ch)->points.hit)
#define GET_MAX_HIT(ch)       ((ch)->points.max_hit)
d362 3
a364 1
#define GET_HITROLL(ch)       ((ch)->points.hitroll)
d673 4
@


1.143
log
@Rewrote str_start/str_cat/str_catf and added several more
functions.  Also made it support up to 50 simultaneous
references to separate buffers.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.142 2008/08/26 04:39:21 jps Exp myc $
d437 2
d440 2
a441 1
#define GET_VIEWED_STR(ch)   ((ch)->viewed_abils.str)
d444 1
d446 2
a447 1
#define GET_VIEWED_INT(ch)   ((ch)->viewed_abils.intel)
d450 1
d452 2
a453 1
#define GET_VIEWED_WIS(ch)   ((ch)->viewed_abils.wis)
d456 1
d458 2
a459 1
#define GET_VIEWED_DEX(ch)   ((ch)->viewed_abils.dex)
d462 1
d464 2
a465 1
#define GET_VIEWED_CON(ch)   ((ch)->viewed_abils.con)
d468 1
d470 2
a471 1
#define GET_VIEWED_CHA(ch)   ((ch)->viewed_abils.cha)
d671 5
@


1.142
log
@Changed IN_ZONE to IN_ZONE_RNUM or IN_ZONE_VNUM and fixed zone_printf.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.141 2008/08/25 00:20:33 myc Exp jps $
d73 1
d79 3
a81 1
void str_start(char *buf, size_t max_size);
d83 1
d85 3
a87 1
char *str_end(char *pos);
a96 3
/* in act.informative.c */
void look_at_room(struct char_data *ch, int mode);

d403 4
d658 3
@


1.141
log
@Changed the way mobs memorize spells.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.140 2008/08/14 23:10:35 myc Exp myc $
d325 3
a327 2
#define IN_ZONE(ch)         (world[IN_ROOM(ch)].zone)
#define GET_WAS_IN(ch)       ((ch)->was_in_room)
d651 3
@


1.140
log
@Added vararg functionality to log() and mudlog().  mprintf() is
the new vararg mudlog().  The old non-vararg mudlog() is still
available.  Added graduated log severity to the mudlog.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.139 2008/08/09 20:35:57 jps Exp myc $
d506 4
a509 5
/* mob casting */
#define GET_MEM_STATE(ch, circle)       ((ch)->mob_specials.mem_state[(circle) - 1])
#define GET_MEM_MEMED(ch, circle)       ((ch)->mob_specials.mem_memed[(circle) - 1])
#define SET_MEM_STATE(ch, circle, pct)  (GET_MEM_STATE((ch), (circle)) = (pct))
#define SET_MEM_MEMED(ch, circle, pct)   (GET_MEM_MEMED((ch), (circle)) = (pct))
d650 5
@


1.139
log
@Changed sense life so that it has a chance of detecting the presence and movement
of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.138 2008/07/15 17:55:06 myc Exp jps $
d30 5
a34 2
#undef log
#define log(x) basic_mud_log(x)
d44 1
a44 1
void log(const char *str);
d46 3
a48 1
void mudlog(const char *str, char type, int level, byte file);
d139 10
d473 1
d651 4
@


1.138
log
@Added accessor macros for grants and grant groups on the
player structure.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.137 2008/06/07 19:06:46 myc Exp myc $
d545 1
a545 1
 (GET_HIDDENNESS(obj) <= GET_PERCEPTION(sub) || EFF_FLAGGED(sub, EFF_SENSE_LIFE)))
d635 4
@


1.137
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.136 2008/06/05 02:07:43 myc Exp myc $
d467 5
d635 3
@


1.136
log
@Replaced strip_cr with filter_chars/strip_chars.  Removed the
cost_per_day and spell component fields from the object
structure.  Changed object flags to use flagvectors.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.135 2008/05/18 04:42:09 jps Exp myc $
d394 7
a512 55
/* object utils **********************************************************/

#define GET_OBJ_LEVEL(obj)      ((obj)->obj_flags.level)
#define GET_OBJ_TYPE(obj)       ((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)       ((obj)->obj_flags.cost)
#define GET_OBJ_FLAGS(obj)      ((obj)->obj_flags.extra_flags)
#define GET_OBJ_WEAR(obj)       ((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)   ((obj)->obj_flags.value[(val)].number)
#define GET_OBJ_WEIGHT(obj)     ((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)      ((obj)->obj_flags.timer)
#define GET_OBJ_HIDDENNESS(obj) ((obj)->obj_flags.hiddenness)
#define GET_OBJ_MOB_FROM(obj)   ((obj)->mob_from)
#define GET_OBJ_RNUM(obj)       ((obj)->item_number)
#define GET_OBJ_VNUM(obj)       (GET_OBJ_RNUM(obj) >= 0 ? \
                                 obj_index[GET_OBJ_RNUM(obj)].virtual : -1)
#define GET_OBJ_EFF_FLAGS(obj)  ((obj)->obj_flags.effect_flags)
#define OBJ_FLAGGED(obj, flag)  (IS_FLAGGED(GET_OBJ_FLAGS(obj), (flag)))
#define OBJ_EFF_FLAGGED(obj, f) (IS_FLAGGED(GET_OBJ_EFF_FLAGS(obj), (f)))
#define GET_OBJ_SPEC(obj)       ((obj)->item_number >= 0 ? \
                                (obj_index[(obj)->item_number].func) : NULL)
#define WEAPON_AVERAGE(obj)   (((GET_OBJ_VAL(obj, 2) + 1) / 2.0) * GET_OBJ_VAL(obj, 1))

#define IS_WEAPON_PIERCING(obj)    ((GET_OBJ_VAL(obj, 3) == TYPE_PIERCE - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_STING - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_STAB - TYPE_HIT))
#define IS_WEAPON_SLASHING(obj)    ((GET_OBJ_VAL(obj, 3) == TYPE_SLASH - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_CLAW - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_WHIP - TYPE_HIT))
#define IS_WEAPON_BLUDGEONING(obj) ((GET_OBJ_VAL(obj, 3) == TYPE_BLUDGEON - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_MAUL - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_POUND - TYPE_HIT) || \
                                    (GET_OBJ_VAL(obj, 3) == TYPE_CRUSH - TYPE_HIT))

#define CAN_WEAR(obj, part)     (IS_SET((obj)->obj_flags.wear_flags, (part)))
#define IS_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                (GET_OBJ_VAL((obj), 3)))
#define CORPSE_PC           1
#define CORPSE_NPC          2
#define CORPSE_NPC_NORAISE  3
#define IS_PLR_CORPSE(obj) \
   ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (GET_OBJ_VAL((obj), 3) == CORPSE_PC)) 

#define IS_VIEWABLE_GATE(obj) (GET_OBJ_VNUM(obj) == HEAVENSGATE_OBJ || \
      GET_OBJ_VNUM(obj) == MOONWELL_OBJ || \
      GET_OBJ_VNUM(obj) == HELLGATE_OBJ)

/* Manipulation of highly visible objects draws attention. Even invisible
 * beings will be noticed if they mess with such things. For example, you
 * couldn't drag a giant treasure chest out of a room without being noticed. */
#define HIGHLY_VISIBLE(obj)   (GET_OBJ_WEIGHT(obj) > 6 || \
      (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL((obj), 0) == 1) || \
      OBJ_FLAGGED((obj), ITEM_GLOW))

#define IS_POISONED(obj)      GET_OBJ_VAL((obj), 3)

a570 21
#define INVIS_OK_OBJ(sub, obj) \
  (!OBJ_FLAGGED((obj), ITEM_INVISIBLE) || EFF_FLAGGED((sub), EFF_DETECT_INVIS))

#define HIDDEN_OK_OBJ(sub, obj) \
  (GET_OBJ_HIDDENNESS(obj) <= GET_PERCEPTION(sub) || (obj)->last_to_hold == (sub))

#define MORT_CAN_SEE_OBJ(sub, obj) (LIGHT_OK(sub) && INVIS_OK_OBJ(sub, obj) && \
  HIDDEN_OK_OBJ(sub, obj))

#define CAN_SEE_OBJ(sub, obj) \
   (MORT_CAN_SEE_OBJ(sub, obj) || PRF_FLAGGED((sub), PRF_HOLYLIGHT))

#define CAN_CARRY_OBJ(ch,obj)  \
   (((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) <= CAN_CARRY_W(ch)) &&   \
    ((IS_CARRYING_N(ch) + 1) <= CAN_CARRY_N(ch)))

#define CAN_GET_OBJ(ch, obj)   \
   (CAN_WEAR((obj), ITEM_WEAR_TAKE) && CAN_CARRY_OBJ((ch),(obj)) && \
    CAN_SEE_OBJ((ch),(obj)) && GET_OBJ_LEVEL(obj) <= GET_LEVEL(ch))


a572 6
#define OBJS(obj, vict)  (CAN_SEE_OBJ((vict), (obj)) ? \
   (obj)->short_description  : "something")

#define OBJN(obj, vict)  (CAN_SEE_OBJ((vict), (obj)) ? \
   fname((obj)->name) : "something")

d630 5
@


1.135
log
@Code formatting change
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.134 2008/05/17 22:03:01 jps Exp jps $
a65 2
void strip_cr(char *buffer);
void trim_spaces(char *buffer);
d69 4
d508 9
a516 10
#define GET_OBJ_LEVEL(obj)      ((obj)->obj_flags.level_obj)
#define GET_OBJ_TYPE(obj)   ((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)   ((obj)->obj_flags.cost)
#define GET_OBJ_RENT(obj)   ((obj)->obj_flags.cost_per_day)
#define GET_OBJ_EXTRA(obj)   ((obj)->obj_flags.extra_flags)
#define GET_OBJ_WEAR(obj)   ((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)   ((obj)->obj_flags.value[(val)])
#define GET_OBJ_WEIGHT(obj)   ((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)   ((obj)->obj_flags.timer)
#define GET_OBJ_HIDDENNESS(obj)   ((obj)->obj_flags.hiddenness)
d518 5
a522 4
#define GET_OBJ_RNUM(obj)   ((obj)->item_number)
#define GET_OBJ_VNUM(obj)   (GET_OBJ_RNUM(obj) >= 0 ? \
             obj_index[GET_OBJ_RNUM(obj)].virtual : -1)
#define IS_OBJ_STAT(obj, stat)  (IS_SET((obj)->obj_flags.extra_flags, (stat)))
a523 2
#define GET_OBJ_EFF_FLAGS(obj)  ((obj)->obj_flags.effect_flags)
#define GET_OBJ_COMPONENT(obj)  ((obj)->spell_component)
a541 1
#define CORPSE_LEVEL(corpse)    ((corpse)->obj_flags.cost_per_day) 
d557 1
a557 1
      IS_OBJ_STAT((obj), ITEM_GLOW))
d620 1
a620 1
  (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || EFF_FLAGGED((sub), EFF_DETECT_INVIS))
d705 3
@


1.134
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.133 2008/05/17 04:32:25 jps Exp jps $
d127 4
a130 4
#define OFF	0
#define BRF	1
#define NRM	2
#define CMP	3
d133 3
a135 3
#define BFS_ERROR		-1
#define BFS_ALREADY_THERE	-2
#define BFS_NO_PATH		-3
d139 4
a142 4
#define SECS_PER_MUD_HOUR	75
#define SECS_PER_MUD_DAY	(24 * SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH	(35 * SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR	(16 * SECS_PER_MUD_MONTH)
d145 4
a148 4
#define SECS_PER_REAL_MIN	60
#define SECS_PER_REAL_HOUR	(60*SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY	(24*SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR	(365*SECS_PER_REAL_DAY)
d171 2
a172 2
	if (!((result) = (type *) calloc ((number), sizeof(type))))\
		{ perror("malloc failure"); abort(); } } while(0)
d176 1
a176 1
		{ perror("realloc failure"); abort(); } } while(0)
d190 1
a190 1
	 temp = temp->next; \
d237 1
a237 1
#define REAL_CHAR(ch)	           ((ch)->desc && (ch)->desc->original ? (ch)->desc->original : (ch))
d265 5
a269 5
#define SECT(room)	(world[(room)].sector_type)
#define SUN(room)	(hemispheres[zone_table[world[room].zone].hemisphere].sunlight)
#define IS_DARK(room)	((world[room].light < 1 || \
			  ROOM_EFF_FLAGGED(room, ROOM_EFF_DARKNESS)) && \
			 !ROOM_FLAGGED(room, ROOM_ALWAYSLIT) && \
d271 5
a275 5
			 (ROOM_FLAGGED(room, ROOM_DARK) || \
			  SECT(room) == SECT_INSIDE || \
			  ROOM_FLAGGED(room, ROOM_INDOORS) || \
			  SUN(room) == SUN_SET || \
			  SUN(room) == SUN_DARK))
d309 1
a309 1
#define GET_WAS_IN(ch)	    ((ch)->was_in_room)
d319 1
a319 1
#define GET_MOVE(ch)	    ((ch)->points.move)
d321 1
a321 1
#define GET_MANA(ch)	    ((ch)->points.mana)
d338 2
a339 2
#define GET_HIT(ch)	    ((ch)->points.hit)
#define GET_MAX_HIT(ch)	    ((ch)->points.max_hit)
d341 1
a341 1
#define GET_HITROLL(ch)	    ((ch)->points.hitroll)
d344 2
a345 2
#define GET_POS(ch)	    ((ch)->char_specials.position)
#define GET_STANCE(ch)	    ((ch)->char_specials.stance)
d357 1
a357 1
#define GET_IDNUM(ch)	    ((ch)->char_specials.idnum)
d397 2
a398 2
#define RIDING(ch)          ((ch)->char_specials.riding)		
#define RIDDEN_BY(ch)       ((ch)->char_specials.ridden_by)	
d437 1
a437 1
#define GET_COND(ch, i)	    ((ch)->player_specials->conditions[(i)])
d472 1
a472 1
				 mob_index[GET_MOB_RNUM(mob)].virtual : -1)
d480 1
a480 1
#define SET_MEM_MEMED(ch, circle, pct)	(GET_MEM_MEMED((ch), (circle)) = (pct))
d486 6
a491 6
	if ((ch)->desc) \
	if (GET_LEVEL(ch) > 100) \
		(ch)->desc->wait = 0; \
	else \
		(ch)->desc->wait = (cycle); \
	else if (IS_NPC(ch)) GET_MOB_WAIT(ch) = (cycle); } while (0)
d496 1
a496 1
#define STATE(d)	((d)->connected)
d507 9
a515 9
#define GET_OBJ_TYPE(obj)	((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)	((obj)->obj_flags.cost)
#define GET_OBJ_RENT(obj)	((obj)->obj_flags.cost_per_day)
#define GET_OBJ_EXTRA(obj)	((obj)->obj_flags.extra_flags)
#define GET_OBJ_WEAR(obj)	((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)	((obj)->obj_flags.value[(val)])
#define GET_OBJ_WEIGHT(obj)	((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)	((obj)->obj_flags.timer)
#define GET_OBJ_HIDDENNESS(obj)	((obj)->obj_flags.hiddenness)
d517 3
a519 3
#define GET_OBJ_RNUM(obj)	((obj)->item_number)
#define GET_OBJ_VNUM(obj)	(GET_OBJ_RNUM(obj) >= 0 ? \
				 obj_index[GET_OBJ_RNUM(obj)].virtual : -1)
d526 1
a526 1
#define WEAPON_AVERAGE(obj)	(((GET_OBJ_VAL(obj, 2) + 1) / 2.0) * GET_OBJ_VAL(obj, 1))
d576 1
a576 1
 		    (!PLR_FLAGGED((ch), PLR_WRITING) || \
d582 1
a582 1
#define LIGHT_OK(sub)	(!EFF_FLAGGED(sub, EFF_BLIND) && \
d644 1
a644 1
	(obj)->short_description  : "something")
d647 1
a647 1
	fname((obj)->name) : "something")
d652 1
a652 1
		    (((ch)->next_in_room == NULL) && (world[(ch)->in_room].people == (ch))))
d671 3
a673 3
  #define SEEK_SET	0
  #define SEEK_CUR	1
  #define SEEK_END	2
d706 3
@


1.133
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.132 2008/04/19 21:11:22 myc Exp jps $
d19 2
d706 3
@


1.132
log
@Added some general-purpose integer array sorting functions.
Right now, we've got bubble sort, insertion sort, quicksort,
and some apparently-optimized quicksort I found on Google :)
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.131 2008/04/13 19:38:05 jps Exp myc $
a290 6
#define EXIT(ch, door)  (world[(ch)->in_room].dir_option[door])

#define CAN_GO(ch, door) (EXIT(ch,door) && \
			 (EXIT(ch,door)->to_room != NOWHERE) && \
			 !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED))

d704 5
@


1.131
log
@Added macro for CONFUSED(ch).
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.130 2008/04/07 03:02:54 jps Exp jps $
d74 8
d710 3
@


1.130
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.129 2008/04/04 06:12:52 myc Exp jps $
d239 1
d702 4
@


1.129
log
@Removed justice and dieites/worship code.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.128 2008/04/03 17:33:57 jps Exp myc $
d341 7
a347 2
#define AWAKE(ch)           (GET_POS(ch) > POS_SLEEPING)
#define ALIVE_POS(ch)       (GET_POS(ch) > POS_DEAD || GET_POS(ch) <= POS_FLYING)
d701 3
@


1.128
log
@Added GET_AUTOINVIS macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.127 2008/04/03 02:02:05 myc Exp jps $
a430 1
#define GET_DIETY(ch)       ((ch)->player_specials->diety)
d696 3
@


1.127
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.126 2008/04/02 19:31:02 myc Exp myc $
d433 1
d697 3
@


1.126
log
@Added str_catf functions and used them in do_stat functions.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.125 2008/04/02 04:55:59 myc Exp myc $
a52 2
char *strip_ansi(char *the_string);
char *escape_ansi(char *the_string);
a63 1
int count_color_chars(const char *string);
d696 3
@


1.125
log
@Added a parse money function.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.124 2008/04/02 03:24:44 myc Exp myc $
d72 5
d699 3
@


1.124
log
@Rewrote group code and removed major group code.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.123 2008/03/28 17:54:53 myc Exp myc $
d94 2
a95 1
void statemoney(char *buf, int *cptr);
d316 10
a325 8
#define GET_PLAT(ch)        ((ch)->points.coins.plat)
#define GET_GOLD(ch)	    ((ch)->points.coins.gold)
#define GET_SILVER(ch)      ((ch)->points.coins.silver)
#define GET_COPPER(ch)      ((ch)->points.coins.copper)
#define GET_BANK_GOLD(ch)   ((ch)->points.bank.gold)
#define GET_BANK_PLAT(ch)   ((ch)->points.bank.plat)
#define GET_BANK_SILVER(ch) ((ch)->points.bank.silver)
#define GET_BANK_COPPER(ch) ((ch)->points.bank.copper)
d694 3
@


1.123
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.122 2008/03/23 00:25:02 jps Exp myc $
a40 2
long exp_group_bonus(long inexp);
long exp_highlevel_bonus(long inexp, int lvldiff);
d62 3
d388 1
d691 4
@


1.122
log
@Add a function to format applies, since it's done in at least
three places in the server.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.121 2008/03/22 19:08:19 jps Exp jps $
a28 2

/* #ifdef CIRCLE_WINDOWS */
a29 1
/* #endif */
d34 1
a34 4
/* char	*str_dup(const char *source); */
#define str_dup strdup
/*bool    event_target_valid(void *target);*/
bool    event_target_valid(struct char_data *ch);
d37 4
a40 4
int	str_cmp(const char *arg1, const char *arg2);
int	strn_cmp(const char *arg1, const char *arg2, int n);
void	log(const char *str);
int	touch(const char *path);
d43 7
a49 6
void	mudlog(const char *str, char type, int level, byte file);
void	log_death_trap(struct char_data *ch);
void	sprintbit(long vektor, const char *names[], char *result);
void	sprinttype(int type, const char *names[], char *result);
int     sprintascii(char *out, bitvector_t bits);
int	get_line(FILE *fl, char *buf);
d51 4
a54 4
int	num_pc_in_room(struct room_data *room);
int     replace_str(char **string, const char *pattern, const char *replacement, int rep_all, int max_size);
void    format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen);
char   *stripcr(char *dest, const char *src);
d62 6
a67 6
int	find_zone(int num);
bool    is_grouped(struct char_data *ch, struct char_data *tch);
int     levenshtein_distance(const char *s1, const char *s2);
int     count_color_chars(const char *string);
void    strip_cr(char *buffer);
void    trim_spaces(char *buffer);
d69 1
a69 4


/* in magic.c */
bool	circle_follow(struct char_data *ch, struct char_data * victim);
d72 1
a72 1
void	look_at_room(struct char_data *ch, int mode);
d75 2
a76 2
int	do_simple_move(struct char_data *ch, int dir, int following);
int	perform_move(struct char_data *ch, int dir, int following, bool misdirection);
d79 13
a91 13
int	mana_limit(struct char_data *ch);
int	hit_limit(struct char_data *ch);
int	move_limit(struct char_data *ch);
int	mana_gain(struct char_data *ch);
int	hit_gain(struct char_data *ch);
int	move_gain(struct char_data *ch);
void	set_title(struct char_data *ch, char *title);
void	gain_exp(struct char_data *ch, struct char_data *vict, long gain);
void	gain_exp_regardless(struct char_data *ch, long gain);
void	gain_condition(struct char_data *ch, int condition, int value);
void	check_idling(struct char_data *ch);
void	point_update(void);
void	update_pos(struct char_data *victim);
a135 7



#define LOOP_THRU_PEOPLE(IN_ROOM, PLAYER) \
for ((IN_ROOM) = world[(PLAYER)->in_room].people; (IN_ROOM) != NULL; (IN_ROOM) = (IN_ROOM)->next_in_room)


d138 2
a139 6

#define YESNO(a) ((a) ? "YES" : "NO")
#define ONOFF(a) ((a) ? "ON" : "OFF")

/*#define LOWER(c)   (((c)>='A'  && (c) <= 'Z') ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (((c)>='a'  && (c) <= 'z') ? ((c)+('A'-'a')) : (c) )*/
d142 2
a143 2
#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')
d145 2
a146 2
#define LOWER(c)   (IS_UPPER(c) ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (IS_LOWER(c) ? ((c)+('A'-'a')) : (c))
d148 2
a149 6
#define ISNEWL(ch) ((ch) == '\n' || (ch) == '\r') 
#define IF_STR(st) ((st) ? (st) : "\0")
/* #define CAP(st)  (*(st) = UPPER(*(st)), st) */
#define CAP(st) (cap_by_color(st), st)

#define AN(string) (strchr("aeiouAEIOU", *string) ? "an" : "a")
d151 1
d165 4
a168 7
 * the source previously used the same code in many places to remove an item
 * from a list: if it's the list head, change the head, else traverse the
 * list looking for the item before the one to be removed.  Now, we have a
 * macro to do this.  To use, just make sure that there is a variable 'temp'
 * declared as the same type as the list to be manipulated.  BTW, this is
 * a great application for C++ templates but, alas, this is not C++.  Maybe
 * CircleMUD 4.0 will be...
d170 5
a174 5
#define REMOVE_FROM_LIST(item, head, next)	\
   if ((item) == (head))		\
      head = (item)->next;		\
   else {				\
      temp = head;			\
d176 5
a180 4
	 temp = temp->next;		\
      if (temp)				\
         temp->next = (item)->next;	\
   }					\
d182 2
d187 4
a190 5

#define IS_SET(flag,bit)  ((flag) & (bit))
#define SET_BIT(var,bit)  ((var) |= (bit))
#define REMOVE_BIT(var,bit)  ((var) &= ~(bit))
#define TOGGLE_BIT(var,bit) ((var) = (var) ^ (bit))
d193 2
a194 2
#define FIELD(x)                 ((int) (x) / 32)
#define FLAG(x)                  (1 << ((x) % 32))
d199 9
d210 22
a231 18
#define GET_EVENTS(o)            ((o)->events)
#define GET_EVENT_FLAGS(o)       ((o)->event_flags)
#define EVENT_FLAGGED(o, flag)   IS_FLAGGED(GET_EVENT_FLAGS(o), (flag))

#define MOB_FLAGS(ch) ((ch)->char_specials.act)
#define MOB2_FLAGS(ch) ((ch)->mob_specials.mob2_flags)
#define PLR_FLAGS(ch) ((ch)->char_specials.act)
#define PRF_FLAGS(ch) ((ch)->player_specials->pref)
#define AFF_FLAGS(ch) ((ch)->char_specials.affected_by)
#define AFF2_FLAGS(ch) ((ch)->char_specials.affected_by2)
#define AFF3_FLAGS(ch) ((ch)->char_specials.affected_by3)
#define ROOM_FLAGS(loc) (world[(loc)].room_flags)
#define ROOM_AFFECTIONS(loc)    (world[(loc)].room_affections)
#define ROOM_AFFECTED(loc, aff) (IS_SET(ROOM_AFFECTIONS(loc), (aff)))

#define GET_DIETY(ch) ((ch)->player_specials->diety)
#define IS_NPC(ch)  (IS_SET(MOB_FLAGS(ch), MOB_ISNPC))
#define IS_MOB(ch)  (IS_NPC(ch) && ((ch)->mob_specials.nr >-1))
d233 2
a234 5
#define REAL_CHAR(ch)	((ch)->desc && (ch)->desc->original ? (ch)->desc->original : (ch))
#define IS_PC(ch)	(!IS_NPC(REAL_CHAR(ch)))

#define MOB_FLAGGED(ch, flag) (IS_NPC(ch) && IS_SET(MOB_FLAGS(ch), (flag)))
#define MOB2_FLAGGED(ch, flag) (IS_NPC(ch) && IS_SET(MOB2_FLAGS(ch), (flag)))
d242 2
a243 16
      !IS_SET(MOB2_FLAGS(ch), MOB2_NOSCRIPT) && \
         !(IS_SET(AFF_FLAGS(ch), AFF_CHARM)))

/*#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) ? IS_SET(PLR_FLAGS(ch), (flag)) : 0)*/
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag)))
#define AFF_FLAGGED(ch, flag) (IS_SET(AFF_FLAGS(ch), (flag)))
#define AFF2_FLAGGED(ch, flag) (IS_SET(AFF2_FLAGS(ch), (flag)))
#define AFF3_FLAGGED(ch, flag) (IS_SET(AFF3_FLAGS(ch), (flag)))

#define PRF_FLAGGED(ch, flag) (IS_SET(PRF_FLAGS(REAL_CHAR(ch)), (flag)))
#define ROOM_FLAGGED(loc, flag) (IS_SET(ROOM_FLAGS(loc), (flag)))

/* IS_AFFECTED for backwards compatibility */
#define IS_AFFECTED(ch, skill) (AFF_FLAGGED((ch), (skill)))
#define IS_AFFECTED2(ch, skill) (AFF2_FLAGGED((ch), (skill)))
#define IS_AFFECTED3(ch, skill) (AFF3_FLAGGED((ch), (skill)))
d245 1
a245 5
#define PLR_TOG_CHK(ch,flag) ((TOGGLE_BIT(PLR_FLAGS(ch), (flag))) & (flag))
#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))

#define MEMMING(ch) (EVENT_FLAGGED((ch), (EVENT_MEM)))
#define OBJ_INDEX_LIMIT(i)   (obj_index[i].object_limit)
a250 1

a251 1

d253 1
a253 1
			  ROOM_AFFECTED(room, RAFF_DARKNESS)) && \
d263 1
a263 1
                         ROOM_AFFECTED(room, RAFF_ILLUMINATION))
d274 1
a274 1
   (SECT(room) == SECT_FOREST || ROOM_AFFECTED(room, RAFF_FOREST))
d278 1
a278 1
/* char utils ************************************************************/
d280 3
d284 1
a284 2
#define IN_ROOM(ch)	((ch)->in_room)
#define IN_ZONE(ch)     (world[IN_ROOM(ch)].zone)
a285 2
#define GET_WAS_IN(ch)	((ch)->was_in_room)
#define GET_AGE(ch)     (age(ch).year)
d287 2
d294 7
a300 1
#define GET_PAGE_LENGTH(ch) ((ch)->player_specials->page_length)
a301 2
#define GET_PASSWD(ch)      ((ch)->player.passwd)
#define GET_PROMPT(ch)      ((ch)->player.prompt)
d304 72
a375 2
#define GET_PFILEPOS(ch)    ((ch)->pfilepos)
#define GET_PERM_TITLES(ch) ((ch)->player_specials->perm_titles)
d377 10
a386 13
/*
 * I wonder if this definition of GET_REAL_LEVEL should be the definition
 * of GET_LEVEL?  JE
 */
#define GET_REAL_LEVEL(ch) \
   (ch->desc && ch->desc->original ? GET_LEVEL(ch->desc->original) : \
    GET_LEVEL(ch))

#define GET_CLASS(ch)   ((ch)->player.class)
#define GET_HOME(ch)	((ch)->player.homeroom)
#define GET_HEIGHT(ch)	((ch)->player.height)
#define GET_WEIGHT(ch)	((ch)->player.weight)
#define GET_SEX(ch)	((ch)->player.sex)
a387 1
/*These set macros for all stat values*/
d413 31
a443 12
#define GET_EX_EXP(ch) ((ch)->mob_specials.ex_exp)
/*
#define GET_EXP(ch)	 	(IS_NPC(ch) ? ((ch)->mob_specials.ex_exp) : ((ch)->points.exp)) 
*/
#define GET_EXP(ch)  ((ch)->points.exp) 

#define GET_EX_AC(ch)     ((ch)->mob_specials.ex_armor)
#define GET_AC(ch)        ((ch)->points.armor)
#define GET_HIT(ch)	  ((ch)->points.hit)
#define GET_MAX_HIT(ch)	  ((ch)->points.max_hit)
#define GET_BASE_HIT(ch)  ((ch)->player_specials->base_hit)
#define GET_EX_HIT(ch)  ((ch)->mob_specials.ex_hit)
d446 1
a446 1
#define GET_EX_GOLD(ch)   ((ch)->mob_specials.ex_gold)
d448 7
a454 83

#define GET_MOVE(ch)	  ((ch)->points.move)
#define GET_MAX_MOVE(ch)  ((ch)->points.max_move)
#define GET_MANA(ch)	  ((ch)->points.mana)
#define GET_EX_MANA(ch)  ((ch)->mob_specials.ex_mana)


#define GET_EX_MAX_MANA(ch)  ((ch)->mob_specials.ex_max_mana)
#define GET_MAX_MANA(ch)  ((ch)->points.max_mana)
#define GET_BANK_GOLD(ch) ((ch)->points.bank.gold)
#define GET_BANK_PLAT(ch) ((ch)->points.bank.plat)
#define GET_BANK_SILVER(ch) ((ch)->points.bank.silver)
#define GET_BANK_COPPER(ch) ((ch)->points.bank.copper)
#define GET_PLAT(ch)      ((ch)->points.coins.plat)
#define GET_GOLD(ch)	  ((ch)->points.coins.gold)
#define GET_SILVER(ch)    ((ch)->points.coins.silver)
#define GET_COPPER(ch)    ((ch)->points.coins.copper)
#define GET_CASH(ch) (GET_PLAT(ch)*1000+GET_GOLD(ch)*100+GET_SILVER(ch)*10+GET_COPPER(ch))
#define GET_LASTLEVEL(ch)	((ch)->player_specials->lastlevel)

#define GET_HITROLL(ch)	  ((ch)->points.hitroll)
#define GET_DAMROLL(ch)   ((ch)->points.damroll)

#define GET_POS(ch)	  ((ch)->char_specials.position)
#define GET_STANCE(ch)	  ((ch)->char_specials.stance)
#define ALIVE_POS(ch)     (GET_POS(ch) > POS_DEAD || GET_POS(ch) <= POS_FLYING)
#define GET_PERCEPTION(ch) ((ch)->char_specials.perception)
#define GET_HIDDENNESS(ch) ((ch)->char_specials.hiddenness)
#define IS_HIDDEN(ch)     (GET_HIDDENNESS(ch) > 0)
#define GET_IDNUM(ch)	  ((ch)->char_specials.idnum)
#define GET_ID(x)         ((x)->id)
#define IS_CARRYING_W(ch) ((ch)->char_specials.carry_weight)
#define ADDED_WEIGHT_OK(ch,obj) ( \
      (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(ch) <= CAN_CARRY_W(ch)) && \
      (GET_OBJ_WEIGHT(obj) <= CAN_CARRY_W(ch)))
#define CONSENT(ch) ((ch)->char_specials.consented)
#define IS_CARRYING_N(ch) ((ch)->char_specials.carry_items)
#define FIGHTING(ch)	  ((ch)->char_specials.fighting)
#define HUNTING(ch)	  ((ch)->char_specials.hunting)
#define RIDING(ch)	  ((ch)->char_specials.riding)		
#define RIDDEN_BY(ch)	  ((ch)->char_specials.ridden_by)	
#define GET_SAVE(ch, i)	  ((ch)->char_specials.apply_saving_throw[i])
#define GET_ALIGNMENT(ch) ((ch)->char_specials.alignment)
#define GET_RAGE(ch)      ((ch)->char_specials.rage)
#define IS_ANGRY(ch)      ((ch)->char_specials.rage >= RAGE_ANGRY)

#define GET_COND(ch, i)		((ch)->player_specials->conditions[(i)])
#define IS_HUNGRY(ch) (GET_COND((ch), FULL) == 0)
#define IS_THIRSTY(ch) (GET_COND((ch), THIRST) == 0)
#define IS_DRUNK(ch) (GET_COND((ch), DRUNK) > 0)

#define GET_LOADROOM(ch)	((ch)->player_specials->load_room)
#define GET_INVIS_LEV(ch)	((ch)->player_specials->invis_level)
#define GET_WIMP_LEV(ch)	((ch)->player_specials->wimp_level)
#define GET_AGGR_LEV(ch)        ((ch)->player_specials->aggressive)
#define GET_FREEZE_LEV(ch)	((ch)->player_specials->freeze_level)
#define GET_BAD_PWS(ch)		((ch)->player_specials->bad_pws)
#define GET_TALK(ch, i)		((ch)->player_specials->talks[i])
#define GET_POOFIN(ch)		((ch)->player_specials->poofin)
#define GET_POOFOUT(ch)		((ch)->player_specials->poofout)
#define GET_LAST_OLC_TARG(ch)	((ch)->player_specials->last_olc_targ)
#define GET_LAST_OLC_MODE(ch)	((ch)->player_specials->last_olc_mode)
#define GET_ALIASES(ch)		((ch)->player_specials->aliases)
#define GET_LAST_TELL(ch)	((ch)->player_specials->last_tell)
#define GET_ROLL(ch, id)	((ch)->player_specials->roll[id])
#define GET_HOST(ch)		((ch)->player_specials->host)
#define GET_SKILL(ch, a)	((ch)->char_specials.skills[(a)] / 10)
#define SET_SKILL(ch, i, pct)   ((ch)->char_specials.skills[(i)] = (pct))
#define GET_ISKILL(ch, a)	((ch)->char_specials.skills[(a)])
#define GET_COOLDOWN(ch, i)	((ch)->char_specials.cooldowns[(i)])
/* defined in skills.c */
void SET_COOLDOWN(struct char_data *ch, int type, int amount);
#define GET_EQ(ch, i)		((ch)->equipment[i])

#define OUTDOOR_SNEAK(ch) \
 ((GET_RACE(ch) == RACE_ELF) \
 && ((world[(ch)->in_room].sector_type >= SECT_FIELD) && \
 ((world[(ch)->in_room].sector_type <= SECT_MOUNTAIN) || \
  (world[(ch)->in_room].sector_type == SECT_GRASSLANDS))))

#define GET_MOB_RNUM(mob) ((mob)->mob_specials.nr)
#define GET_MOB_SPEC(ch) (IS_MOB(ch) ? (mob_index[GET_MOB_RNUM(ch)].func) : NULL)
#define GET_MOB_VNUM(mob)	(IS_MOB(mob) ? \
d456 8
a463 26

#define GET_MOB_WAIT(ch)	((ch)->mob_specials.wait_state)
#define GET_DEFAULT_POS(ch)	((ch)->mob_specials.default_pos)
#define MEMORY(ch)		((ch)->mob_specials.memory)


#define GET_LDESC(ch) ((ch)->player.long_descr)
#define GET_SPELL_MEM(ch)	((ch)->spell_memory)

/* fixed by gurlaek to work with the 100 point attrib system 6/24/1999 */
#define STRENGTH_APPLY_INDEX(ch) GET_STR(ch)
#define CAN_CARRY_W(ch) (str_app[GET_STR(ch)].carry_w)
#define CAN_CARRY_N(ch) (5 + (GET_DEX(ch) >> 1) + (GET_LEVEL(ch) >> 1))
#define CURRENT_LOAD(ch) (IS_CARRYING_W(ch) >= CAN_CARRY_W(ch) ? 100 : \
      (IS_CARRYING_W(ch) * 10) / CAN_CARRY_W(ch))
#define AWAKE(ch) (GET_POS(ch) > POS_SLEEPING)
#define CAN_SEE_IN_DARK(ch) \
   ((PRF_FLAGGED(ch, PRF_HOLYLIGHT) || AFF2_FLAGGED(ch, AFF2_ULTRAVISION) \
    || IS_MOB(ch)  \
    || IS_NPC(ch)) && !ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
/* I changed this to stop abuse! Banyal needs removed when mobs are foxed*/
#define IS_GOOD(ch)    (GET_ALIGNMENT(ch) >= 350)
#define IS_EVIL(ch)    (GET_ALIGNMENT(ch) <= -350)
#define IS_NEUTRAL(ch) (!IS_GOOD(ch) && !IS_EVIL(ch))

#define IS_VICIOUS(ch) (IS_NPC(ch) ? !MOB_FLAGGED((ch), MOB_NOVICIOUS) : PRF_FLAGGED((ch), PRF_VICIOUS))
a466 6
/*next four added by proky for mob casting*/
#define GET_MEM_STATE(ch, circle)   ((ch)->mob_specials.mem_state[circle - 1])
#define GET_MEM_MEMED(ch, circle)	((ch)->mob_specials.mem_memed[circle - 1])
#define SET_MEM_STATE(ch, circle, pct)   ((ch)->mob_specials.mem_state[circle - 1])	 = pct
#define SET_MEM_MEMED(ch, circle, pct)	((ch)->mob_specials.mem_memed[circle - 1]) 	 = pct

d478 1
a479 1

d499 1
a499 1
#define GET_OBJ_MOB_FROM(obj) ((obj)->mob_from)
d503 6
a508 12
#define IS_OBJ_STAT(obj,stat)	(IS_SET((obj)->obj_flags.extra_flags,stat))
#define IS_OBJ_SPELL_AFF(obj,stat)	(IS_SET((obj)->obj_flags.spell_flags,stat))
#define IS_OBJ_SPELL_AFF2(obj,stat)      (IS_SET((obj)->obj_flags.spell_flags2,stat))
#define IS_OBJ_SPELL_AFF3(obj,stat)      (IS_SET((obj)->obj_flags.spell_flags3,stat))
#define GET_OBJ_SPELL(obj)    ((obj)->obj_flags.spell_flags)
#define GET_OBJ_SPELL2(obj)   ((obj)->obj_flags.spell_flags2)
#define GET_OBJ_SPELL3(obj)   ((obj)->obj_flags.spell_flags3)
#define GET_OBJ_COMPONENT(obj) ((obj)->spell_component)
#define GET_OBJ_LIMITATION(obj) ((obj)->object_limitation)
#define OBJ_LIMIT(id) (obj_limit[id])
#define GET_OBJ_SPEC(obj) ((obj)->item_number >= 0 ? \
	(obj_index[(obj)->item_number].func) : NULL)
d522 4
a525 5
#define CAN_WEAR(obj, part) (IS_SET((obj)->obj_flags.wear_flags, (part)))

#define CORPSE_LEVEL(corpse)   ((corpse)->obj_flags.cost_per_day) 
#define IS_CORPSE(obj)      (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                        (GET_OBJ_VAL((obj), 3)))
d539 1
a539 1
#define HIGHLY_VISIBLE(obj) (GET_OBJ_WEIGHT(obj) > 6 || \
d543 1
a543 1
#define IS_POISONED(obj) GET_OBJ_VAL((obj), 3)
d547 6
a552 7

#define HSHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "his":"her") :"its")
#define HSSH(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "he" :"she") : "it")
#define HMHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "him":"her") : "it")

#define ANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "An" : "A")
#define SANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "an" : "a")
d555 2
d565 1
a565 1
#define LIGHT_OK(sub)	(!AFF_FLAGGED(sub, AFF_BLIND) && \
d567 2
a568 2
    AFF2_FLAGGED((sub), AFF2_ULTRAVISION) || \
    ROOM_AFFECTED((sub)->in_room, RAFF_ILLUMINATION)))
d571 2
a572 2
 ((!AFF_FLAGGED((obj),AFF_INVISIBLE) || AFF_FLAGGED(sub, AFF_DETECT_INVIS)) && \
 (GET_HIDDENNESS(obj) <= GET_PERCEPTION(sub) || AFF_FLAGGED(sub, AFF_SENSE_LIFE)))
d587 1
a587 1
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && IMM_CAN_SEE(sub, obj)) || \
d591 2
a592 2
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && \
   (( (!AFF_FLAGGED(sub, AFF_BLIND) && AFF_FLAGGED(sub, AFF_INFRAVISION)) \
d599 1
a599 1
      (!AFF3_FLAGGED(obj, AFF3_MISDIRECTING) || PRF_FLAGGED(sub, PRF_HOLYLIGHT)))
d604 1
a604 1
  (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || AFF_FLAGGED((sub), AFF_DETECT_INVIS))
d624 1
a624 1
#define PERS(ch, vict)   (CAN_SEE(vict, ch) ? GET_NAME(ch) : "someone")
d626 1
a626 1
#define OBJS(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
d629 1
a629 1
#define OBJN(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
a631 16

#define EXIT(ch, door)  (world[(ch)->in_room].dir_option[door])

#define CAN_GO(ch, door) (EXIT(ch,door) && \
			 (EXIT(ch,door)->to_room != NOWHERE) && \
			 !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED))


#define IS_FIGHTING(ch) ((ch->char_specials.fighting)? 1: 0)

#define IS_CORNERED(ch)   ((ch)->cornered_by && \
                           CAN_SEE((ch)->cornered_by, ch) && \
                           FIGHTING((ch)->cornered_by) == (ch) && \
                           (ch)->in_room == (ch)->cornered_by->in_room)


d634 2
a638 1

d641 1
a641 1
#define NULL (void *)0
d645 1
a645 1
#define FALSE 0
d649 1
a649 1
#define TRUE  (!FALSE)
d654 3
a656 3
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2
d660 1
a660 1
#define CRYPT(a,b) (a)
d662 1
a662 1
#define CRYPT(a,b) ((char *) crypt((a),(b)))
a680 4

#define ALONE(ch)  (!(ch) || ((ch)->in_room == NOWHERE) || \
		    (((ch)->next_in_room == NULL) && (world[(ch)->in_room].people == (ch))))

d689 4
@


1.121
log
@Added parse_obj_name as a generalized object identifier.
Added macros to get a character's life force and composition.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.120 2008/03/21 21:36:02 jps Exp jps $
d114 1
d756 4
@


1.120
log
@Add functions without_article and pluralize, for modifying
nouns and noun phrases.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.119 2008/03/21 15:01:17 myc Exp jps $
d73 2
d328 2
d755 4
@


1.119
log
@Removed languages.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.118 2008/03/17 15:31:27 myc Exp myc $
d108 2
d751 3
@


1.118
log
@Fix WAIT_STATE macro so it can be used properly as a single statement.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.117 2008/03/16 00:19:11 jps Exp myc $
a448 1
#define SPEAKING(ch)            ((ch)->player_specials->speaking)
d749 3
@


1.117
log
@Moved GET_TROPHY macro to trophy.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.116 2008/03/11 19:50:55 myc Exp jps $
d504 1
a504 1
#define WAIT_STATE(ch, cycle) { \
d510 1
a510 1
	else if (IS_NPC(ch)) GET_MOB_WAIT(ch) = (cycle); }
d750 3
@


1.116
log
@Changed the way allowed olc zones are saved on an immortal from
a fixed number of slots to a variable-length linked list.  Also
got rid of practice points.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.115 2008/03/11 02:13:05 jps Exp myc $
a473 1
#define GET_TROPHY(ch)	((ch)->player_specials->trophy)
d750 5
@


1.115
log
@Moving size macro to chars.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.114 2008/03/10 20:49:47 myc Exp jps $
d315 5
a319 7
#define GET_NAMELIST(ch) (ch)->player.namelist
#define GET_NAME(ch)    (ch)->player.short_descr
/* #define GET_NAME(ch)    (IS_NPC(ch) ? \
			 (ch)->player.short_descr : GET_PC_NAME(ch)) */
#define GET_SHORT(ch)    ((ch)->player.short_descr)
#define GET_TITLE(ch)   ((ch)->player.title)
#define GET_WIZ_TITLE(ch) ((ch)->player_specials->wiz_title)
d321 5
a325 5
#define GET_LEVEL(ch)   ((ch)->player.level)
#define GET_PASSWD(ch)	((ch)->player.passwd)
#define GET_PROMPT(ch)	((ch)->player.prompt)
#define GET_PFILEPOS(ch)((ch)->pfilepos)
#define GET_PERM_TITLES(ch)  ((ch)->player_specials->perm_titles)
a433 1
#define GET_INNATE_TIMER(ch, i) ((ch)->player_specials->innatetime[(i)])
a434 1
#define GET_PRACTICES(ch)	((ch)->player_specials->spells_to_learn)
d751 3
@


1.114
log
@Renamed POS1 to 'stance'.  Renamed hometown to homeroom.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.113 2008/03/10 19:55:37 jps Exp myc $
a341 1
#define GET_SIZE(ch) ((ch)->player.size)
d755 3
@


1.113
log
@Made a struct for sizes with name, height, and weight.  Save base height
weight and size so they stay the same over size changes.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.112 2008/03/09 18:14:50 jps Exp jps $
d338 1
a338 1
#define GET_HOME(ch)	((ch)->player.hometown)
d410 1
a410 1
#define GET_POS1(ch)	  ((ch)->char_specials.position1)
d756 4
@


1.112
log
@Added defs for CAN_SEE_MOVING and SEES_THROUGH_MISDIRECTION.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.111 2008/03/09 06:38:37 jps Exp jps $
a687 3
#define SIZE_DESC(ch)  (sizes[(int) GET_SIZE(ch) + 1])


d756 3
@


1.111
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.110 2008/03/08 23:55:21 jps Exp jps $
d82 1
a82 1
int	perform_move(struct char_data *ch, int dir, int following);
d646 4
d759 5
@


1.110
log
@Added MOB_PERFORMS_SCRIPTS macro, which determines whether a mob can
do specprocs or triggers.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.109 2008/03/07 21:21:57 myc Exp jps $
d315 4
a318 3
#define GET_PC_NAME(ch)	((ch)->player.name)
#define GET_NAME(ch)    (IS_NPC(ch) ? \
			 (ch)->player.short_descr : GET_PC_NAME(ch))
d755 4
@


1.109
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.108 2008/03/06 05:11:51 myc Exp myc $
d243 10
d754 5
@


1.108
log
@Combined the 'saved' and 'unsaved' portions of the char_specials and
player_specials structures by moving all fields of each saved structure
to its parent structure.  Also combined the skills array from the
player and mob structures since they are identical.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.107 2008/03/06 04:35:02 myc Exp myc $
d445 1
a445 1
#define SET_SKILL(ch, i, pct)   ((ch)->char_specials.skills[(i)] = pct)
d447 3
a449 1

a517 5

#define SKILL_DELAY(ch, i)  ((ch)->player_specials->last_skill_use[i - (MAX_SPELLS + 1)])



d744 6
@


1.107
log
@Moved the IS_VICIOUS macro here from structs.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.106 2008/03/05 05:21:56 myc Exp myc $
a73 10
/*sphere shit*/
#define SPHERE(ch, i) ((ch)->player_specials->saved.spheres[i])

#define FIRE    1
#define WATER   2
#define AIR     3
#define EARTH   4
#define GENERIC 5
#define HEALING 6

d223 1
a223 1
#define MOB_FLAGS(ch) ((ch)->char_specials.saved.act)
d225 5
a229 5
#define PLR_FLAGS(ch) ((ch)->char_specials.saved.act)
#define PRF_FLAGS(ch) ((ch)->player_specials->saved.pref)
#define AFF_FLAGS(ch) ((ch)->char_specials.saved.affected_by)
#define AFF2_FLAGS(ch) ((ch)->char_specials.saved.affected_by2)
#define AFF3_FLAGS(ch) ((ch)->char_specials.saved.affected_by3)
d234 1
a234 1
#define GET_DIETY(ch) ((ch)->player_specials->saved.diety)
d310 2
a311 2
#define GET_WIZ_TITLE(ch) ((ch)->player_specials->saved.wiz_title)
#define GET_PAGE_LENGTH(ch) ((ch)->player_specials->saved.page_length)
d316 1
a316 1
#define GET_PERM_TITLES(ch)  ((ch)->player_specials->saved.perm_titles)
d369 1
a369 1
#define GET_BASE_HIT(ch)  ((ch)->player_specials->saved.base_hit)
d393 1
a393 1
#define GET_LASTLEVEL(ch)	((ch)->player_specials->saved.lastlevel)
d404 1
a404 1
#define GET_IDNUM(ch)	  ((ch)->char_specials.saved.idnum)
d416 2
a417 2
#define GET_SAVE(ch, i)	  ((ch)->char_specials.saved.apply_saving_throw[i])
#define GET_ALIGNMENT(ch) ((ch)->char_specials.saved.alignment)
d421 1
a421 1
#define GET_COND(ch, i)		((ch)->player_specials->saved.conditions[(i)])
d426 11
a436 11
#define GET_INNATE_TIMER(ch, i) ((ch)->player_specials->saved.innatetime[(i)])
#define GET_LOADROOM(ch)	((ch)->player_specials->saved.load_room)
#define GET_PRACTICES(ch)	((ch)->player_specials->saved.spells_to_learn)
#define GET_INVIS_LEV(ch)	((ch)->player_specials->saved.invis_level)
#define GET_WIMP_LEV(ch)	((ch)->player_specials->saved.wimp_level)
#define GET_AGGR_LEV(ch)        ((ch)->player_specials->saved.aggressive)
#define GET_FREEZE_LEV(ch)	((ch)->player_specials->saved.freeze_level)
#define GET_BAD_PWS(ch)		((ch)->player_specials->saved.bad_pws)
#define GET_TALK(ch, i)		((ch)->player_specials->saved.talks[i])
#define GET_POOFIN(ch)		((ch)->player_specials->saved.poofin)
#define GET_POOFOUT(ch)		((ch)->player_specials->saved.poofout)
d439 1
a439 1
#define GET_ALIASES(ch)		((ch)->player_specials->saved.aliases)
d442 5
a446 5
#define GET_HOST(ch)		((ch)->player_specials->saved.host)
#define SPEAKING(ch)     ((ch)->player_specials->saved.speaking)
#define GET_SKILL(ch, a)	(IS_NPC(ch) ? ((ch)->mob_specials.skills[a])/10 : ((ch)->player_specials->saved.skills[a])/10)
#define SET_SKILL(ch, i, pct)  ( IS_NPC(ch) ? ((ch)->mob_specials.skills[i] = pct) : ((ch)->player_specials->saved.skills[i] = pct) )
#define GET_ISKILL(ch, a)	(IS_NPC(ch) ? ((ch)->mob_specials.skills[a]) :((ch)->player_specials->saved.skills[a]))
d466 1
a466 2
#define GET_FRAG(ch)        ((ch)->player_specials->saved.frag)
#define GET_TROPHY(ch)	((ch)->player_specials->saved.trophy)
d747 3
@


1.106
log
@Made bank coins into ints instead of longs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.105 2008/03/05 03:03:54 myc Exp myc $
d497 2
d758 3
@


1.105
log
@Added sprintascii function.  Moved get_filename to players.c.  Got
rid of BOUNDED.  Added strip_cr and trim_spaces.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.104 2008/02/24 17:31:13 myc Exp myc $
d394 4
a397 4
#define GET_BANK_GOLD(ch) ((ch)->points.coins.bank_gold)
#define GET_BANK_PLAT(ch) ((ch)->points.coins.bank_plat)
#define GET_BANK_SILVER(ch) ((ch)->points.coins.bank_silver)
#define GET_BANK_COPPER(ch) ((ch)->points.coins.bank_copper)
d756 4
@


1.104
log
@Added a TO_OLC flag to act() to allow messages to be sent to
people while in OLC if they have OLCComm toggled on.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.103 2008/02/23 01:03:54 myc Exp myc $
a46 1
int BOUNDED(int a, int b, int c);
d53 1
a54 2
int	get_filename(char *orig_name, char *filename, int mode);
char	*get_fname(char *orig_name, int mode);
d71 2
a130 7
/* get_filename() */
#define CRASH_FILE	0
#define ETEXT_FILE	1
#define PLR_FILE        2
#define QUEST_FILE	3
#define NOTES_FILE      4 

d315 1
d317 1
a317 1
			 (ch)->player.short_descr : (ch)->player.name)
d320 1
a320 1
#define GET_WIZTITLE(ch) ((ch)->player_specials->saved.wiz_title)
d326 1
a326 1
#define GET_PTITLE(ch, n)  ((ch)->player_specials->saved.titles[(n)])
d379 1
a403 1
#define GET_NATHPS(ch)    ((ch)->player_specials->saved.nathps)
d445 2
a446 2
#define POOFIN(ch)		((ch)->player_specials->saved.poofin)
#define POOFOUT(ch)		((ch)->player_specials->saved.poofout)
d449 1
a449 3
#define GET_ALIAS_NUM(ch, i)	((ch)->player_specials->saved.aliases[i].alias)
#define GET_ALIAS_TYPE(ch, i)   ((ch)->player_specials->saved.aliases[i].type)
#define GET_ALIAS_REPL(ch, i)   ((ch)->player_specials->saved.aliases[i].replacement)
d451 2
a452 1
#define GET_ROLL(ch, id)		((ch)->player_specials->roll[id])
d477 3
a479 3
#define GET_TROPHY(ch, i)  ((ch)->player_specials->saved.trophy[i])
#define GET_TRTOP(ch)   ((ch)->player_specials->saved.top)
#define GET_LDESC(ch) (IS_NPC(ch) ? (ch)->player.long_descr : (ch)->player_specials->saved.long_descr)
d756 4
@


1.103
log
@Moving some spell circle and memorization functions from here to
spells.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.102 2008/02/16 20:31:32 myc Exp myc $
d615 2
a616 1
 		    !PLR_FLAGGED((ch), PLR_WRITING))
d763 4
@


1.102
log
@Commented out str_dup to help disambiguate memory leaks.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.101 2008/02/09 21:07:50 myc Exp myc $
a250 6
#define GET_CIRCLE(s) skills[(s)].min_circle[(int)GET_CLASS(ch)]
#define GET_MEMMED_CIRCLE(s) ch->spells_memmed_circle[GET_CIRCLE(s)]
#define GET_MEMMED(c) ch->spells_memmed_circle[c]
#define CIRCLE_ABBR(s) circle_abbrev[GET_CIRCLE(s)]
#define IS_QUEST_SPELL(s) skills[(s)].quest

d762 3
@


1.101
log
@Memming uses event flag instead of plr flag now.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.100 2008/02/09 18:29:11 myc Exp myc $
d37 2
a38 1
char	*str_dup(const char *source);
a197 5
/* This should make things a bit more sane.  Gurlaek 6/8/1999 */
#define FREE(pntr) if(pntr) { \
    free(pntr);pntr = NULL; } else { \
    log("SYSERR: function attempting to free previously freed pointer..."); }

d768 3
@


1.100
log
@Camping and tracking now use event flags instead of having
their own event fields on the char_data struct..
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.99 2008/02/09 07:05:37 myc Exp myc $
d287 1
a287 1
#define MEMMING(ch) (PLR_FLAGGED((ch), (PLR_MEMMING)))
d772 4
@


1.99
log
@Adding an IS_PLAYING macro, which returns true if a descriptor
is playing or is in an OLC-type editor.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.98 2008/02/09 04:27:47 myc Exp myc $
a476 2
#define GET_ACTION(ch) ((ch)->camp_event)
#define GET_TRACK_EVENTS(ch) ((ch)->track_delayed_event)
d772 4
@


1.98
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.97 2008/02/09 03:06:17 myc Exp myc $
d537 8
d547 2
d774 3
@


1.97
log
@Moving mathematical functions to math.c, and including math.h
everywhere utils.h is included.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.96 2008/02/07 01:46:14 myc Exp myc $
a18 2
#include "math.h"

d764 4
@


1.96
log
@Removing the size abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
which points to the sizes array.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.95 2008/02/06 21:53:53 myc Exp myc $
d19 2
a52 2
int	number(int from, int to);
int	dice(int number, int size);
a84 12
/* undefine MAX and MIN so that our functions are used instead */
#ifdef MAX
#undef MAX
#endif

#ifdef MIN
#undef MIN
#endif

int MAX(int a, int b);
int MIN(int a, int b);

d766 4
@


1.95
log
@Adding a function to count color characters in a string (useful
for changing string widths in sprintf statements).
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.94 2008/02/02 19:38:20 myc Exp myc $
d707 1
a707 2
/* #define SIZE_ABBR(ch)  (IS_NPC(ch) ? "--" : size_abbrevs[(int)GET_SIZE(ch)]) */
#define SIZE_ABBR(ch)  (size_abbrevs[(int)GET_SIZE(ch)])
d778 4
@


1.94
log
@Adding a levenshtein distance calculator for use by the
interpreter.  Also added a macro for accessing permanent
player titles.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.93 2008/01/30 19:20:57 myc Exp myc $
d73 1
d779 5
@


1.93
log
@Adding support for the array bitvectors from newer versions of
Circle.  However, unlike stock circle, they are named FLAGs instead
of BIT_ARs.  So we have IS_FLAGGED instead of IS_SET, SET_FLAG for
SET_BIT, REMOVE_FLAG instead of REMOVE_BIT, and TOGGLE_FLAG instead
of TOGGLE_BIT.  The new event flags use these array bitvectors.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.92 2008/01/29 21:02:31 myc Exp myc $
d72 1
d355 1
d778 7
@


1.92
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.91 2008/01/27 13:43:50 jps Exp myc $
d243 13
d776 4
@


1.91
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.90 2008/01/27 12:11:58 jps Exp jps $
d53 2
a54 2
void	sprintbit(long vektor, char *names[], char *result);
void	sprinttype(int type, char *names[], char *result);
d60 1
a60 1
int     replace_str(char **string, char *pattern, char *replacement, int rep_all, int max_size);
d763 3
@


1.90
log
@Fix the CHECK_WAIT macro. Learn to write macros!
Moved some IS_CLASS macros to class.h, deleted some unused ones.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.89 2008/01/27 09:45:41 jps Exp jps $
a349 1
#define GET_SPECIES(ch) ((ch)->player.race)
a350 2
#define GET_RACE(ch)    ((ch)->player.race)
#define GET_RACE_ALIGN(ch)  ((ch)->player.race_align)
d763 4
@


1.89
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.88 2008/01/27 02:25:25 jps Exp jps $
d535 1
a535 1
   IS_NPC(ch) ? GET_MOB_WAIT(ch) : (((ch)->desc) ? ((ch)->desc->wait > 1) : 0)
a704 39
#define IS_MAGIC_USER(ch)	((!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_SORCERER) || \
				(GET_CLASS(ch) == CLASS_PYROMANCER) || \
				(GET_CLASS(ch) == CLASS_CRYOMANCER) || \
				(GET_CLASS(ch) == CLASS_ILLUSIONIST))) || \
                                (IS_NPC(ch) && \
                                ((GET_CLASS(ch) == CLASS_SORCERER) || \
                                (GET_CLASS(ch) == CLASS_NECROMANCER) || \
                                (GET_CLASS(ch) == CLASS_CONJURER))))
#define IS_CLERIC(ch)		(!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_CLERIC) || \
				(GET_CLASS(ch) == CLASS_DIABOLIST) || \
				(GET_CLASS(ch) == CLASS_PRIEST) || \
				(GET_CLASS(ch) == CLASS_MYSTIC)))
#define IS_THIEF(ch)		((!IS_NPC(ch) && \
				((GET_CLASS(ch) == CLASS_THIEF) || \
				(GET_CLASS(ch) == CLASS_ROGUE))) || \
                                (IS_NPC(ch) && \
                                ((GET_CLASS(ch) == CLASS_THIEF))))
#define IS_WARRIOR(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_WARRIOR))
#define IS_PALADIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_PALADIN))
#define IS_ANTI_PALADIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_ANTI_PALADIN))
#define IS_RANGER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_RANGER))
#define IS_DRUID(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_DRUID))
#define IS_SHAMAN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_SHAMAN))
#define IS_ASSASSIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_ASSASSIN))
#define IS_MERCENARY(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_MERCENARY))
#define IS_NECROMANCER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_NECROMANCER))
#define IS_CONJURER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_CONJURER))
d766 4
@


1.88
log
@Adjust CHECK_WAIT for mobs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.87 2008/01/26 14:26:31 jps Exp jps $
d711 3
a713 3
                                ((GET_CLASS(ch) == MCLASS_SORCERER) || \
                                (GET_CLASS(ch) == MCLASS_NECROMANCER) || \
                                (GET_CLASS(ch) == MCLASS_CONJURER))))
d723 1
a723 1
                                ((GET_CLASS(ch) == MCLASS_THIEF))))
d805 3
@


1.87
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.86 2008/01/25 21:12:04 myc Exp jps $
d534 2
a535 1
#define CHECK_WAIT(ch)	(((ch)->desc) ? ((ch)->desc->wait > 1) : 0)
d805 3
@


1.86
log
@Renamed monk_weight_pen to monk_weight_penalty.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.85 2008/01/17 01:29:10 myc Exp $
d254 1
a254 1
#define GET_CIRCLE(s) spell_info[(s)].min_circle[(int)GET_CLASS(ch)]
d258 1
a258 1
#define IS_QUEST_SPELL(s) spell_info[(s)].quest
d804 3
d1114 1
a1114 1
 * Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
@


1.85
log
@I'm pretty sure the mud only has 16 months...
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.84 2008/01/15 06:51:47 myc Exp myc $
d68 1
a68 1
int monk_weight_pen(struct char_data *ch);
d427 1
d445 2
d804 3
@


1.84
log
@Added paranthesis to REAL_CHAR to make sure nothing goes awry.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.83 2008/01/15 03:18:19 myc Exp myc $
d157 3
a159 3
#define SECS_PER_MUD_DAY	(24*SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH	(35*SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR	(17*SECS_PER_MUD_MONTH)
d801 3
@


1.83
log
@Changed SENSE_LIFE to its former function (showing any hidden mobs)
instead of adding some amount to perception.  That way it doesn't
apply to objects.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.82 2008/01/14 21:28:21 myc Exp myc $
d264 1
a264 1
#define REAL_CHAR(ch)	(ch->desc && ch->desc->original ? ch->desc->original : ch)
d801 5
@


1.82
log
@Added GET_AGGR_LEV macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.81 2008/01/13 23:06:04 myc Exp myc $
d626 1
a626 1
 (GET_HIDDENNESS(obj) <= GET_PERCEPTION(sub)))
d801 3
@


1.81
log
@Updated CAN_GET_OBJ macro to check the object's level.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.80 2008/01/13 03:19:53 myc Exp myc $
a45 5
int NumAttackers(struct char_data *ch);
bool statsave(struct char_data *ch, int stat, int mod);
int STAT_INDEX(int v);
bool are_together(struct char_data *ch1, struct char_data *ch2);
bool has_help(struct char_data *ch);
a64 1
bool SanityCheck(struct char_data *ch, const char *calling);
d71 2
d455 1
d801 3
@


1.80
log
@Removed GET_MSKILL and SET_MSKILL macros.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.79 2008/01/09 10:08:33 jps Exp myc $
d674 1
a674 1
    CAN_SEE_OBJ((ch),(obj)))
d804 3
@


1.79
log
@Added CAN_SEE_BY_INFRA macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.78 2008/01/09 08:33:38 jps Exp jps $
a471 2
/*#define SET_MSKILL(ch, a, pct)  (ch.mob_specials.skills[a] = pct)*/
#define GET_MSKILL(ch, a)  GET_SKILL(ch, a)
d804 3
@


1.78
log
@Add functions to format strings for printin lengths and weights.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.77 2008/01/09 04:13:59 jps Exp jps $
d649 6
d806 3
@


1.77
log
@New macro MEMMING for players who are memorizing.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.76 2008/01/09 02:29:33 jps Exp jps $
d133 2
d800 3
@


1.76
log
@Modify GET_MOB_RNUM, real num moved to mob_specials.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.75 2008/01/09 01:51:25 jps Exp jps $
d288 1
a288 1

d798 3
@


1.75
log
@Get rid of obsolete defs for points and damage events.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.74 2008/01/05 21:55:09 jps Exp jps $
d264 1
a264 1
#define IS_MOB(ch)  (IS_NPC(ch) && ((ch)->nr >-1))
d486 2
a487 2
#define GET_MOB_SPEC(ch) (IS_MOB(ch) ? (mob_index[(ch->nr)].func) : NULL)
#define GET_MOB_RNUM(mob)	((mob)->nr)
d798 3
@


1.74
log
@Added circular-dependency prevention defs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.73 2008/01/05 05:39:03 jps Exp jps $
a477 2
#define GET_POINTS_EVENT(ch, i) ((ch)->points_event[i])
#define GET_DAMAGE_EVENTS(ch)   ((ch)->damage_events)
d798 3
@


1.73
log
@Removing function prototype advance_level() which is in class.c, not utils.c.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.72 2008/01/04 01:53:26 jps Exp jps $
d16 3
d796 2
d800 3
@


1.72
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.71 2008/01/03 12:45:43 jps Exp jps $
a112 2
/*void	advance_level(struct char_data *ch);*/
void    advance_level(struct char_data *ch, int); 
d795 4
@


1.71
log
@New string function with_indefinite_article.
Renamed CLASS_MAGIC_USER to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.70 2007/12/25 06:37:05 jps Exp jps $
a687 7
/* #define CLASS_ABBR(ch) (IS_NPC(ch) ? "--" : class_abbrevs[(int)GET_CLASS(ch)])
#define CLASS_FULL(ch) (IS_NPC(ch) ? "--" : pc_class_types[(int)GET_CLASS(ch)]) */
#define RACE_ABBR(ch)  (IS_NPC(ch) ? "--" : race_abbrevs[(int)GET_RACE(ch)])

#define RACE_TARG(ch)  (IS_NPC(ch) ? "--" : race_target[(int)GET_RACE(ch)])


a691 2
#define RACE_ALIGN_ABBR(ch) race_align_abbrevs[(int )GET_RACE_ALIGN(ch)]

d797 4
@


1.70
log
@Fix CURRENT_LOAD for highly loaded people (e.g., approaching max int).
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.69 2007/12/20 23:13:03 myc Exp jps $
d131 1
d688 2
a689 2
#define CLASS_ABBR(ch) (IS_NPC(ch) ? "--" : class_abbrevs[(int)GET_CLASS(ch)])
#define CLASS_FULL(ch) (IS_NPC(ch) ? "--" : pc_class_types[(int)GET_CLASS(ch)])
d709 1
a709 1
				((GET_CLASS(ch) == CLASS_MAGIC_USER) || \
d806 3
@


1.69
log
@Cleaned up the CURRENT_LOAD macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.68 2007/12/19 20:58:40 myc Exp myc $
d505 2
a506 1
#define CURRENT_LOAD(ch) ((IS_CARRYING_W(ch) * 10) / CAN_CARRY_W(ch))
d805 3
@


1.68
log
@Renamed CLOAKED toggle to ROOMVIS.  Added const modifiers to str_cmp,
strn_cmp, log, touch, and mudlog.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.67 2007/10/27 03:18:58 myc Exp myc $
d505 1
a505 1
#define CURRENT_LOAD(ch) ( (int)(((float)IS_CARRYING_W(ch) / (float)CAN_CARRY_W(ch)) * 10) )
d804 4
@


1.67
log
@Fixed bug in CAN_SEE so mobs can see without lights.  Removed MCAN_SEE
since it does the same thing as CAN_SEE.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.66 2007/10/25 20:41:13 myc Exp myc $
d39 4
a42 4
int	str_cmp(char *arg1, char *arg2);
int	strn_cmp(char *arg1, char *arg2, int n);
void	log(char *str);
int	touch(char *path);
d51 1
a51 1
void	mudlog(char *str, char type, int level, byte file);
d639 1
a639 1
   (PRF_FLAGGED((obj), PRF_CLOAKED) && IN_ROOM(sub) == IN_ROOM(obj))))
d804 4
@


1.66
log
@Added WEAPON_AVERAGE macro and fixed typo in IS_WEAPON_BLUDGEONING.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.65 2007/10/02 02:52:27 myc Exp myc $
d622 3
a624 2
   (IS_LIGHT((sub)->in_room) || AFF2_FLAGGED((sub), AFF2_ULTRAVISION) || \
   ROOM_AFFECTED((sub)->in_room, RAFF_ILLUMINATION)))
a645 5
/* Can MOB subject see character "obj"?  Ignores light. */
#define MCAN_SEE(sub, obj) ((SELF(sub, obj)) || \
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && INVIS_OK(sub, obj) && \
  !AFF_FLAGGED(sub, AFF_BLIND)) || IMM_VIS_OK(sub, obj))

d804 3
@


1.65
log
@Renamed ORIG_CHAR as REAL_CHAR.  PRF_FLAGGED now uses REAL_CHAR,
so the preferences on the original player are always checked, even
when someone is switched or shapechanged.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.64 2007/09/28 20:49:35 myc Exp myc $
d566 1
d574 1
a574 1
#define IS_WEAPON_BLUDGEONING(obj) ((GET_OBJ_VAL(obj, 3) == TYPE_BLUDGEONING - TYPE_HIT) || \
d647 2
a648 2
 ((GET_REAL_LEVEL(sub) >= GET_INVIS_LEV(obj)) && INVIS_OK(sub, obj)) || \
  IMM_VIS_OK(sub, obj))
d808 5
@


1.64
log
@Added find_zone prototype.  Fixing a bug in HIDDEN_OK_OBJ that was
preventing objects from being seen.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.63 2007/09/20 21:20:43 myc Exp myc $
d264 2
a265 2
#define ORIG_CHAR(ch)	(ch->desc && ch->desc->original ? ch->desc->original : ch)
#define IS_PC(ch)	(!IS_NPC(ORIG_CHAR(ch)))
d275 1
a275 1
#define PRF_FLAGGED(ch, flag) (IS_SET(PRF_FLAGS(ch), (flag)))
d807 4
@


1.63
log
@Hide points and perception are in.  Rewrote CAN_SEE and CAN_SEE_OBJ
to handle this.  Also added cloaked toggle so people in the room can
see you even when everyone else can't (due to wizinvis).  Got rid of
all those racial stat defines and moved them to an array in db.c.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.62 2007/09/15 05:03:46 myc Exp myc $
d73 1
a73 1

d656 1
a656 1
  (GET_OBJ_HIDDENNESS(obj) < GET_PERCEPTION(sub) || (obj)->last_to_hold == (sub))
d807 6
@


1.62
log
@Added MOB2 flags, which are saved as an espec in the mob files. The
MOB2_FLAGS and MOB2_FLAGGED macros are now available.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.61 2007/09/12 19:23:04 myc Exp myc $
d427 3
a429 1

d549 1
d613 5
d620 3
a622 3
#define LIGHT_OK(sub)	(!IS_AFFECTED(sub, AFF_BLIND) && \
   (IS_LIGHT((sub)->in_room) || IS_AFFECTED2((sub), AFF2_ULTRAVISION) || \
 IS_MOB(sub) || (ROOM_AFFECTED((sub)->in_room, RAFF_ILLUMINATION))))
d625 2
a626 2
 ((!IS_AFFECTED((obj),AFF_INVISIBLE) || IS_AFFECTED(sub,AFF_DETECT_INVIS)) && \
 (!IS_AFFECTED((obj), AFF_HIDE) || IS_AFFECTED(sub, AFF_SENSE_LIFE)))
a628 1
#define MOB_CAN_SEE(sub, obj)  (INVIS_OK(sub, obj))
d635 4
d642 1
a642 2
  ((GET_LEVEL(obj) >= LVL_IMMORT) && (CONSENT(obj) == sub)) )
/* End of CAN_SEE */
d644 1
a644 1
/* Can MOB subject see character "obj"? */
d647 4
a650 2
  ((GET_LEVEL(obj) >= LVL_IMMORT) && (CONSENT(obj) == sub)) )
/* End of MCAN_SEE */
d653 1
a653 3
  (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || IS_AFFECTED((sub), AFF_DETECT_INVIS))

#define HIDDEN_OK_OBJ(sub, obj) (!IS_OBJ_STAT((obj), ITEM_HIDDEN))
d655 2
a656 2
#define MORT_CAN_SEE_OBJ(sub, obj) (LIGHT_OK(sub) && INVIS_OK_OBJ(sub, obj) \
        &&      HIDDEN_OK_OBJ(sub, obj))
d658 2
a659 2
#define SENDOK(ch) ((ch)->desc && (AWAKE(ch) || sleep) && \
 		    !PLR_FLAGGED((ch), PLR_WRITING))
a780 126
/* STATS FOR RACES 
 CHANGE THESE TO DIRECTLY EFFECT MAXIMUM RACIAL STATS*/
/* these have been converted to scale for the 100 point system as follows*/
/* (oldval * 100)/25.  25 was the max value used so it was considered to be */
/* the max on the 18 point scale. So (18 * 100)/25 = 72 */
#define ORC_STR       72
#define ORC_CON       72
#define ORC_WIS       72
#define ORC_INT       72
#define ORC_DEX       72
#define ORC_CHA       72
#define HUMAN_STR     72
#define HUMAN_CON     72
#define HUMAN_WIS     72
#define HUMAN_INT     72
#define HUMAN_DEX     72
#define HUMAN_CHA     72
#define HALF_ELF_STR  68
#define HALF_ELF_CON  68
#define HALF_ELF_WIS  76
#define HALF_ELF_INT  76
#define HALF_ELF_DEX  76
#define HALF_ELF_CHA  78
#define ELF_STR       64
#define ELF_CON       64
#define ELF_WIS       84
#define ELF_INT       88
#define ELF_DEX       80
#define ELF_CHA       80
#define DWARF_STR     84
#define DWARF_CON     84
#define DWARF_WIS     86
#define DWARF_INT     64
#define DWARF_DEX     76
#define DWARF_CHA     68
#define DUERGAR_STR   84
#define DUERGAR_CON   84
#define DUERGAR_WIS   72
#define DUERGAR_INT   68
#define DUERGAR_DEX   76
#define DUERGAR_CHA   64
#define BARBARIAN_STR 88
#define BARBARIAN_CON 88
#define BARBARIAN_WIS 60
#define BARBARIAN_INT 60
#define BARBARIAN_DEX 68
#define BARBARIAN_CHA 64
#define TROLL_STR     92
#define TROLL_CON     92
#define TROLL_WIS     56
#define TROLL_INT     56
#define TROLL_DEX     72
#define TROLL_CHA     64
#define OGRE_STR      96
#define OGRE_CON     100
#define OGRE_WIS      60
#define OGRE_INT      52
#define OGRE_DEX      64
#define OGRE_CHA      60
#define HALFLING_STR  68
#define HALFLING_CON  64
#define HALFLING_WIS  80
#define HALFLING_INT  80
#define HALFLING_DEX  96
#define HALFLING_CHA  76
#define DROW_ELF_STR  64
#define DROW_ELF_CON  64
#define DROW_ELF_WIS  80
#define DROW_ELF_INT  88
#define DROW_ELF_DEX  80
#define DROW_ELF_CHA  72
#define GNOME_STR     64
#define GNOME_CON     68
#define GNOME_WIS     84
#define GNOME_INT     88
#define GNOME_DEX     76
#define GNOME_CHA     76
#define UNDEAD_STR    80
#define UNDEAD_CON    64
#define UNDEAD_WIS    72
#define UNDEAD_INT    72
#define UNDEAD_DEX    80
#define UNDEAD_CHA    64
#define HUMANOID_STR  72
#define HUMANOID_CON  72
#define HUMANOID_WIS  72
#define HUMANOID_INT  72
#define HUMANOID_DEX  72
#define HUMANOID_CHA  72
#define ANIMAL_STR    72
#define ANIMAL_CON    72
#define ANIMAL_WIS    72
#define ANIMAL_INT    72
#define ANIMAL_DEX    72
#define ANIMAL_CHA    72
#define DRAGON_STR    100
#define DRAGON_CON    72
#define DRAGON_WIS    72
#define DRAGON_INT    100
#define DRAGON_DEX    72
#define DRAGON_CHA    100
#define GIANT_STR     100
#define GIANT_CON     80
#define GIANT_WIS     64
#define GIANT_INT     44
#define GIANT_DEX     72
#define GIANT_CHA     72
#define OTHER_STR     72
#define OTHER_CON     72
#define OTHER_WIS     72
#define OTHER_INT     72
#define OTHER_DEX     72
#define OTHER_CHA     72
#define GOBLIN_STR    76
#define GOBLIN_CON    84
#define GOBLIN_WIS    72
#define GOBLIN_INT    64
#define GOBLIN_DEX    72
#define GOBLIN_CHA    64
#define DEMON_STR     80
#define DEMON_CON     58
#define DEMON_WIS     68
#define DEMON_INT     68
#define DEMON_DEX     100
#define DEMON_CHA     58

d807 4
@


1.61
log
@Fix to IS_DARK to make city rooms always lit.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.60 2007/09/04 06:49:19 myc Exp myc $
d244 1
d268 1
d923 3
@


1.60
log
@Cleaned up IS_DARK macro.
IN_ZONE is now an rnum.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.59 2007/09/03 23:59:43 jps Exp myc $
d297 1
d300 1
a300 2
			  (ROOM_FLAGGED(room, ROOM_INDOORS) && \
			   SECT(room) != SECT_CITY) || \
d921 4
@


1.59
log
@Added macro ADDED_WEIGHT_OK for testing whether a char can have an
object added to its inventory.  Avoids an integer overflow problem
that could occur if an object's weight was near maxint.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.58 2007/08/16 11:53:39 jps Exp jps $
a17 2
extern struct weather_data weather_info;
extern HEMISPHERE Hemispheres[NUM_HEMISPHERES];
d20 5
d292 11
a302 9
#define IS_DARK(room)  ( ((world[room].light < 1) && (!ROOM_FLAGGED(room, ROOM_ALWAYSLIT))) && \
                         ((ROOM_FLAGGED(room, ROOM_DARK) || \
                           ROOM_AFFECTED(room, RAFF_DARKNESS)) || \
                           ((ROOM_FLAGGED(room, ROOM_INDOORS)) && \
                           (SECT(room) != SECT_CITY)) || \
                          ( ( SECT(room) != SECT_INSIDE && \
                              SECT(room) != SECT_CITY)  && \
(Hemispheres[zone_table[world[room].zone].hemisphere].sunlight == SUN_SET || \
 Hemispheres[zone_table[world[room].zone].hemisphere].sunlight == SUN_DARK) ) ))
d324 1
a324 1
#define IN_ZONE(ch)  (zone_table[world[IN_ROOM(ch)].zone].number)
d921 5
@


1.58
log
@Remove various defunct specprocs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.57 2007/08/14 22:43:07 myc Exp jps $
d424 3
d916 3
@


1.57
log
@Adding conceal, corner, shadow, and stealth skills.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.56 2007/08/04 22:20:20 jps Exp myc $
a118 2
void	special_update(struct char_data * ch);
void el_passage(struct char_data * ch);
d913 3
@


1.56
log
@Added some macros for rooms - IS_WATER, IS_SPLASHY
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.55 2007/08/02 01:04:10 myc Exp jps $
d310 4
a313 1
   SECT(room) == SECT_UNDERWATER || SECT(room) == SECT_SWAMP)
d686 5
d915 3
@


1.55
log
@check_pk() now works for all PK cases.  Moved from magic.c to fight.c
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.54 2007/07/31 23:44:36 jps Exp myc $
d304 8
d907 3
@


1.54
log
@New macros IS_HUNGRY, IS_THIRSTY, IS_DRUNK.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.53 2007/07/25 00:38:03 jps Exp jps $
d262 3
d899 3
@


1.53
log
@Add macro IN_ZONE, like IN_ROOM only zonier.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.52 2007/07/19 21:59:36 jps Exp jps $
d422 4
d896 3
@


1.52
log
@Add utility function next_line.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.51 2007/07/18 18:29:55 jps Exp jps $
d307 2
d892 3
@


1.51
log
@Allow SIZE_ABBR to use GET_SIZE for NPCs.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.50 2007/07/15 17:16:12 jps Exp jps $
d21 1
d69 2
d890 3
@


1.50
log
@Add IS_POISONED macro, and moved HIGHLY_VISIBLE macro to utils.h
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.49 2007/04/19 04:50:18 myc Exp jps $
d655 2
a656 1
#define SIZE_ABBR(ch)  (IS_NPC(ch) ? "--" : size_abbrevs[(int)GET_SIZE(ch)])
d887 3
@


1.49
log
@Created macros for checking weapon types.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.48 2007/04/18 00:05:59 myc Exp myc $
d559 9
d886 3
@


1.48
log
@Prompt parser has been totally rewritten so it won't print garbage
characters anymore.  Also, some new features were added.  Giving the
prompt command back to mortals.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.47 2007/04/04 13:31:02 jps Exp myc $
d533 11
d877 5
@


1.47
log
@Add year to log timestamps and other dates.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.46 2007/03/27 04:27:05 myc Exp jps $
d62 1
d866 3
@


1.46
log
@Changed spellings of innate timer macro.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.45 2007/02/04 18:12:31 myc Exp myc $
d859 4
d865 3
@


1.45
log
@Page length now saves as a part of player specials.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.44 2006/11/27 02:07:05 jps Exp myc $
d416 1
a416 1
#define GET_INNT(ch, i)     ((ch)->player_specials->saved.innatetime[(i)])
d861 3
@


1.44
log
@Allow "look in" to work like "look at" for ALL gate-spell objects.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.43 2006/11/26 08:31:17 jps Exp jps $
d311 1
d861 3
@


1.43
log
@Added function yesno_result to standardize handling of nanny's
yes/no questions (in interpreter.c).
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.42 2006/11/18 09:08:15 jps Exp jps $
d542 4
d860 4
@


1.42
log
@Add function statemoney to pretty-print coins
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.41 2006/11/18 07:22:34 jps Exp jps $
d120 6
d856 3
@


1.41
log
@Add isplural function
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.40 2006/11/18 04:26:32 jps Exp jps $
d118 1
d850 3
@


1.40
log
@Renamed continual light spell to illumination, and it only works on
LIGHT items (still rooms too).
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.39 2006/11/11 16:13:08 jps Exp jps $
d117 1
d849 4
@


1.39
log
@Fix CAP so it correctly capitalizes strings with color codes at the beginning.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.38 2004/11/11 19:17:21 cmc Exp jps $
d287 1
a287 1
                         ROOM_AFFECTED(room, RAFF_CONTINUAL_LIGHT))
d549 1
a549 1
 IS_MOB(sub) || (ROOM_AFFECTED((sub)->in_room, RAFF_CONTINUAL_LIGHT))))
d848 3
@


1.38
log
@added prototype for perform_random_gem_drop()
warning message for fight.c no longer generated
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.37 2003/06/23 01:47:09 jjl Exp cmc $
d28 1
d179 2
a180 1
#define CAP(st)  (*(st) = UPPER(*(st)), st)
d848 4
@


1.37
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.36 2003/04/16 02:05:41 jjl Exp $
d28 1
d846 3
@


1.36
log
@SKILL_DELAY addition.
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.35 2002/09/13 02:32:10 jjl Exp $
d132 1
d845 3
@


1.35
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: utils.h,v 1.34 2001/12/07 15:42:12 dce Exp $
d489 1
d844 3
@


1.34
log
@Fixed a duplicate entry.
@
text
@d1 3
a3 1
// $Id: utils.h,v 1.33 2001/04/08 17:13:10 dce Exp $
d841 182
a1022 177
// $Log: utils.h,v $
// Revision 1.33  2001/04/08 17:13:10  dce
// Added an alwayslit flag that makes a room lit no matter
// of the sector or room type...
//
// Revision 1.32  2001/03/24 05:12:01  dce
// Objects will now accept a level through olc and upon
// booting the objects. The level code for the players will
// follow.
//
// Revision 1.31  2000/11/25 02:33:15  rsd
// Altered comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.30  2000/10/27 00:34:45  mtp
// extra define for saving quests info
//
// Revision 1.29  2000/05/18 04:29:39  rsd
// altered some of the racial balances of attributes.
// Halflevs were less charismatic than humans? boggle
//
// Revision 1.28  2000/04/22 22:45:04  rsd
// fixed comment header while browsing the file
//
// Revision 1.27  2000/02/24 01:07:44  dce
// Gods no longer have a WAIT_STATE time. It is set to 0.
//
// Revision 1.26  2000/01/31 00:26:25  rsd
// altered the define for PLR_CORPSE to make it so corpses
// get defined properly.
//
// Revision 1.25  1999/11/29 00:13:41  cso
// added define for GET_SHORT (from dg_scripts)
// added defines for corpse types (CORPSE_PC, _NPC, _NPC_NORAISE)
// changed define of IS_PLR_CORPSE
// changed define of IS_MAGIC_USER to check for npc m-u
// changed define of IS_THIEF to check for npc thief
//
// Revision 1.24  1999/10/30 16:16:48  rsd
// Jimmy coded alignment restrictions for Paladins and exp
// altered the definition of gain_exp() to include a check
// for the victim.
//
// Revision 1.23  1999/09/16 01:15:11  dce
// Weight restrictions for monks...-hitroll, -damroll + ac
//
// Revision 1.22  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.21  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.20  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.19  1999/08/08 19:37:25  mud
// heh, well added additional check to the IS_PLR_CORPSE
// macro to make doubly sure the item in question was in
// fact a corpse and not any object with the second byte
// set to 1. *whistle*
//
// Revision 1.18  1999/08/07 23:51:29  mud
// removed some double defines of IS_CORPSE and added the
// define for IS_PLR_CORPSE to reference the exiding
// container structure.
//
// Revision 1.17  1999/07/24 20:50:18  dce
// Exchange command for banks added.
//
// Revision 1.16  1999/07/06 19:57:05  jimmy
// This is a Mass check-in of the new skill/spell/language assignment system.
// This New system combines the assignment of skill/spell/language for
// both mobs and PCs.  LOts of code was touched and many errors were fixed.
// MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
// MObs now get random skill/spell/language levels baseed on their race/class/level
// that exactly align with PC's.  PC's no longer have to rent to use skills gained
// by leveling or when first creating a char.  Languages no longer reset to defaults
// when a PC levels.  Discovered that languages have been defined right in the middle
// of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
// the mob files to compensate for the 13 to -1 class change.
// --gurlaek 7/6/1999
//
// Revision 1.15  1999/06/30 18:25:04  jimmy
// >> This is a major conversion from the 18 point attribute system to the
// >> 100 point attribute system.  A few of the major changes are:
// >> All attributes are now on a scale from 0-100
// >> Everyone views attribs the same but, the attribs for one race
// >>   may be differeent for that of another even if they are the
// >>   same number.
// >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
// >> Mobs now have individual random attributes based on race/class.
// >> The STR_ADD attrib has been completely removed.
// >> All bonus tables for attribs in constants.c have been replaced by
// >>   algorithims that closely duplicate the tables except on a 100 scale.
// >> Some minor changes:
// >> Race selection at char creation can now be toggled by using
// >>   <world races off>
// >> Lots of cleanup done to affected areas of code.
// >> Setting attributes for mobs in the .mob file no longer functions
// >>   but is still in the code for later use.
// >> We now have a spare attribut structure in the pfile because the new
// >>   system only used three instead of four.
// >> --gurlaek 6/30/1999
//
// Revision 1.14  1999/06/21 19:47:11  jimmy
// Changed PLR_FLAGGED to do a ? between IS_NPC and IS_SET instead of an &&
// This was done to prevent the crashes caused by mobs losing the
// player_special=dummy_mob allocation.  --Gurlaek
//
// Revision 1.13  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.12  1999/05/04 17:19:33  dce
// Name accept system...version one...original code by Fingh, fixed up to work
// by Zantir.
//
// Revision 1.11  1999/03/24 23:43:16  jimmy
// Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
// quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
// learn from any sorcerer type teacher
// fingon
//
// Revision 1.10  1999/02/12 20:53:28  dce
// Now only Sect_City & Room_Indoors will be lit, all other types
// of Room_indoors and Sect's will be dark.
//
// Revision 1.9  1999/02/11 16:44:23  dce
// Fixes IS_DARK macro.
//
// Revision 1.8  1999/02/10 22:27:54  jimmy
// Added do_wiztitle
//
// Revision 1.7  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.6  1999/02/08 23:01:47  jimmy
// Fixed mortally wounded bug.  Mortally wounded
// victims now die when they read -11.  Also,
// no more "attempt to damage corpse"
// fingon
//
// Revision 1.5  1999/02/06 00:40:36  jimmy
// Major change to incorporate aliases into the pfile
// moved alias structure from interpreter.h to structs.h
// heavily modified alias code in interpreter.c
// Jimmy Kincaid AKA fingon
//
// Revision 1.4  1999/02/05 07:47:42  jimmy
// Added Poofs to the playerfile as well as 4 extra strings for
// future use.  fingon
//
// Revision 1.3  1999/02/04 18:08:43  mud
// indented comment header
// dos2unix
//
// Revision 1.2  1999/02/01 08:21:13  jimmy
// improved build counter
//
// Revision 1.1  1999/01/29 01:23:32  mud
// Initial revision
//
@


1.33
log
@Added an alwayslit flag that makes a room lit no matter
of the sector or room type...
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.32 2001/03/24 05:12:01 dce Exp $
a509 1
#define GET_OBJ_SPELL(obj)	((obj)->obj_flags.spell_flags)
d840 4
@


1.32
log
@Objects will now accept a level through olc and upon
booting the objects. The level code for the players will
follow.
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.31 2000/11/25 02:33:15 rsd Exp $
d270 1
a270 1
#define IS_DARK(room)  ( (world[room].light < 1) && \
d272 3
a274 3
                     ROOM_AFFECTED(room, RAFF_DARKNESS)) || \
                         ((ROOM_FLAGGED(room, ROOM_INDOORS)) && \
                          (SECT(room) != SECT_CITY)) || \
d841 5
@


1.31
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.30 2000/10/27 00:34:45 mtp Exp $
d490 1
a490 1

d841 4
@


1.30
log
@extra define for saving quests info
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.29 2000/05/18 04:29:39 rsd Exp $
a13 1

a839 1

d841 3
d875 128
@


1.29
log
@altered some of the racial balances of attributes.
Halflevs were less charismatic than humans? boggle
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.28 2000/04/22 22:45:04 rsd Exp $
d130 1
d843 4
@


1.28
log
@fixed comment header while browsing the file
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.27 2000/02/24 01:07:44 dce Exp $
d712 2
a713 2
#define HALF_ELF_CON  72
#define HALF_ELF_WIS  72
d716 1
a716 1
#define HALF_ELF_CHA  68
d725 1
a725 1
#define DWARF_WIS     72
d728 1
a728 1
#define DWARF_CHA     72
d737 2
a738 2
#define BARBARIAN_WIS 64
#define BARBARIAN_INT 64
d740 1
a740 1
#define BARBARIAN_CHA 68
d842 3
@


1.27
log
@Gods no longer have a WAIT_STATE time. It is set to 0.
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.26 2000/01/31 00:26:25 rsd Exp $
d3 1
a3 1
 *   File: utils.h                                       Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d842 3
@


1.26
log
@altered the define for PLR_CORPSE to make it so corpses
get defined properly.
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.25 1999/11/29 00:13:41 cso Exp $
d475 5
a479 1
	if ((ch)->desc) (ch)->desc->wait = (cycle); \
d840 4
@


1.25
log
@added define for GET_SHORT (from dg_scripts)
added defines for corpse types (CORPSE_PC, _NPC, _NPC_NORAISE)
changed define of IS_PLR_CORPSE
changed define of IS_MAGIC_USER to check for npc m-u
changed define of IS_THIEF to check for npc thief
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.24 1999/10/30 16:16:48 rsd Exp $
d520 1
a520 1
   ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (GET_OBJ_VAL((obj), 1)) && (GET_OBJ_VAL((obj), 3) == CORPSE_PC)) 
d836 7
@


1.24
log
@Jimmy coded alignment restrictions for Paladins and exp
altered the definition of gain_exp() to include a check
for the victim.
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.23 1999/09/16 01:15:11 dce Exp $
d292 1
d516 3
d520 1
a520 1
   ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (GET_OBJ_VAL((obj), 1)) && (GET_OBJ_VAL((obj), 3))) 
d616 1
a616 1
#define IS_MAGIC_USER(ch)	(!IS_NPC(ch) && \
d620 5
a624 1
				(GET_CLASS(ch) == CLASS_ILLUSIONIST)))
d630 1
a630 1
#define IS_THIEF(ch)		(!IS_NPC(ch) && \
d632 3
a634 1
				(GET_CLASS(ch) == CLASS_ROGUE)))
d836 5
@


1.23
log
@Weight restrictions for monks...-hitroll, -damroll + ac
@
text
@d1 1
a1 1
// $Id: utils.h,v 1.22 1999/09/05 07:00:39 jimmy Exp $
d104 1
a104 1
void	gain_exp(struct char_data *ch, long gain);
d826 3
@


1.22
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d61 1
d825 4
a828 1
// $Log$
@


1.21
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d1 1
d824 1
@


1.20
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d39 2
a40 2
int exp_group_bonus(int inexp);
int exp_highlevel_bonus(int inexp, int lvldiff);
d102 2
a103 2
void	gain_exp(struct char_data *ch, int gain);
void	gain_exp_regardless(struct char_data *ch, int gain);
@


1.19
log
@heh, well added additional check to the IS_PLR_CORPSE
macro to make doubly sure the item in question was in
fact a corpse and not any object with the second byte
set to 1. *whistle*
@
text
@d125 1
@


1.18
log
@removed some double defines of IS_CORPSE and added the
define for IS_PLR_CORPSE to reference the exiding
container structure.
@
text
@d513 1
a513 1
   (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && (GET_OBJ_VAL((obj), 1)))
@


1.17
log
@Exchange command for banks added.
@
text
@d144 2
a145 3
#define CORPSE_LEVEL(corpse)   ((corpse)->obj_flags.cost_per_day) 
#define IS_CORPSE(obj) \
   (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && GET_OBJ_VAL((obj), 3) == 1)
d509 5
a513 2
#define IS_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                        GET_OBJ_VAL((obj), 3) == 1)
@


1.16
log
@This is a Mass check-in of the new skill/spell/language assignment system.
This New system combines the assignment of skill/spell/language for
both mobs and PCs.  LOts of code was touched and many errors were fixed.
MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
MObs now get random skill/spell/language levels baseed on their race/class/level
that exactly align with PC's.  PC's no longer have to rent to use skills gained
by leveling or when first creating a char.  Languages no longer reset to defaults
when a PC levels.  Discovered that languages have been defined right in the middle
of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
the mob files to compensate for the 13 to -1 class change.
--gurlaek 7/6/1999
@
text
@d19 1
a19 1
#ifdef CIRCLE_WINDOWS
d21 1
a21 1
#endif
@


1.15
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@d241 2
a242 5
/* somehow mobs are loosing their ch->player_specials=&dummy_mob allocation */
/* I added the '?' to the next line to help stop the crashes while we try   */
/* to fix the problem.  The old line is underneath.   --Gurlaek 6/21/1999   */
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) ? IS_SET(PLR_FLAGS(ch), (flag)) : 0)
/* #define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag))) */
d414 4
a417 8

/*#define GET_SKILL(ch, i)	((ch)->player_specials->saved.skills[i])
#define SET_SKILL(ch, i, pct)	{ (ch)->player_specials->saved.skills[i] = pct; }
*/
#define SET_MSKILL(ch, a, pct)  (ch.mob_specials.skills[a] = pct)
#define GET_MSKILL(ch, a)  ((ch)->mob_specials.skills[a]) 
#define GET_SKILL(ch, a)	(IS_NPC(ch) ? ((ch)->mob_specials.skills[a]) : ((ch)->player_specials->saved.skills[a]) / 10)
#define SET_SKILL(ch, i, pct)  { (ch)->player_specials->saved.skills[i] = pct;}
@


1.14
log
@Changed PLR_FLAGGED to do a ? between IS_NPC and IS_SET instead of an &&
This was done to prevent the crashes caused by mobs losing the
player_special=dummy_mob allocation.  --Gurlaek
@
text
@a317 9

/*#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)*/

d319 24
a342 30
#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_STR_VIEW(ch) ((ch)->view_abils.str)
#define GET_STR_VAFF(ch) ((ch)->vaff_abils.str)
#define GET_RSTR(ch)     ((ch)->real_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_ADD_VIEW(ch) ((ch)->view_abils.str_add)
#define GET_ADD_VAFF(ch) ((ch)->vaff_abils.str_add)
#define GET_RADD(ch)     ((ch)->real_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_DEX_VIEW(ch) ((ch)->view_abils.dex)
#define GET_DEX_VAFF(ch) ((ch)->vaff_abils.dex)
#define GET_RDEX(ch)     ((ch)->real_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_RINT(ch)     ((ch)->real_abils.intel)
#define GET_INT_VIEW(ch) ((ch)->view_abils.intel)
#define GET_INT_VAFF(ch) ((ch)->vaff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_WIS_VIEW(ch) ((ch)->view_abils.wis)
#define GET_WIS_VAFF(ch) ((ch)->vaff_abils.wis)
#define GET_RWIS(ch)     ((ch)->real_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CON_VIEW(ch) ((ch)->view_abils.con)
#define GET_CON_VAFF(ch) ((ch)->vaff_abils.con)
#define GET_RCON(ch)     ((ch)->real_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)
#define GET_CHA_VIEW(ch) ((ch)->view_abils.cha)
#define GET_CHA_VAFF(ch) ((ch)->vaff_abils.cha)
#define GET_RCHA(ch)     ((ch)->real_abils.cha)
#define GET_RCHA(ch)     ((ch)->real_abils.cha)

d454 3
a456 11


#define STRENGTH_APPLY_INDEX(ch) \
        ( ((GET_ADD(ch)==0) || (GET_STR(ch) != 18)) ? GET_STR(ch) :\
          (GET_ADD(ch) <= 50) ? 26 :( \
          (GET_ADD(ch) <= 75) ? 27 :( \
          (GET_ADD(ch) <= 90) ? 28 :( \
          (GET_ADD(ch) <= 99) ? 29 :  30 ) ) )                   \
        )

#define CAN_CARRY_W(ch) (str_app[STRENGTH_APPLY_INDEX(ch)].carry_w)
d680 125
a804 74
/*			STATS FOR RACES 
 CHANGE THESE TO DIRECTLY EFFECT MAXIMUM STATS*/
#define ORC_STR 18
#define ORC_CON 18
#define ORC_WIS 18
#define ORC_INT 18
#define ORC_DEX 18
#define ORC_CHA 18
#define HUMAN_STR 18
#define HUMAN_CON 18
#define HUMAN_WIS 18
#define HUMAN_INT 18
#define HUMAN_DEX 18
#define HUMAN_CHA 18
#define HALF_ELF_STR 17
#define HALF_ELF_CON 18
#define HALF_ELF_WIS 18
#define HALF_ELF_INT 19
#define HALF_ELF_DEX 19
#define HALF_ELF_CHA 17
#define ELF_STR 16
#define ELF_CON 16
#define ELF_WIS 21
#define ELF_INT 22
#define ELF_DEX 20
#define ELF_CHA 20
#define DWARF_STR 21
#define DWARF_CON 21
#define DWARF_WIS 18
#define DWARF_INT 16
#define DWARF_DEX 19
#define DWARF_CHA 18
#define DUERGAR_STR 21
#define DUERGAR_CON 21
#define DUERGAR_WIS 18
#define DUERGAR_INT 17
#define DUERGAR_DEX 19
#define DUERGAR_CHA 16
#define BARBARIAN_STR 22
#define BARBARIAN_CON 22
#define BARBARIAN_WIS 16
#define BARBARIAN_INT 16
#define BARBARIAN_DEX 17
#define BARBARIAN_CHA 17
#define TROLL_STR 23
#define TROLL_CON 23
#define TROLL_WIS 14
#define TROLL_INT 14
#define TROLL_DEX 18
#define TROLL_CHA 16
#define OGRE_STR 24
#define OGRE_CON 28
#define OGRE_WIS 15
#define OGRE_INT 13
#define OGRE_DEX 16
#define OGRE_CHA 15
#define HALFLING_STR 17
#define HALFLING_CON 16
#define HALFLING_WIS 20
#define HALFLING_INT 20
#define HALFLING_DEX 24
#define HALFLING_CHA 19
#define DROW_ELF_STR 16
#define DROW_ELF_CON 16
#define DROW_ELF_WIS 20
#define DROW_ELF_INT 22
#define DROW_ELF_DEX 20
#define DROW_ELF_CHA 18
#define GNOME_STR 16
#define GNOME_CON 17
#define GNOME_WIS 21
#define GNOME_INT 22
#define GNOME_DEX 19
#define GNOME_CHA 19
@


1.13
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d241 5
a245 1
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag)))
@


1.12
log
@Name accept system...version one...original code by Fingh, fixed up to work
by Zantir.
@
text
@d186 5
@


1.11
log
@Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
learn from any sorcerer type teacher
fingon
l.
@
text
@d49 1
@


1.10
log
@Now only Sect_City & Room_Indoors will be lit, all other types
of Room_indoors and Sect's will be dark.
@
text
@d228 1
@


1.9
log
@Fixes IS_DARK macro.
@
text
@d261 2
@


1.8
log
@Added do_wiztitle
@
text
@d258 1
a258 1
#define IS_DARK(room)  ( !world[room].light && \
d455 1
@


1.7
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d281 1
@


1.6
log
@Fixed mortally wounded bug.  Mortally wounded
victims now die when they read -11.  Also,
no more "attempt to damage corpse"
fingon
@
text
@d453 1
a453 1

d472 1
a472 1
  /* I changed this to stop abuse! Banyal needs removed when mobs are foxed*/
@


1.5
log
@Major change to incorporate aliases into the pfile
moved alias structure from interpreter.h to structs.h
heavily modified alias code in interpreter.c
Jimmy Kincaid AKA fingon
@
text
@d25 2
a26 1
bool    event_target_valid(void *target);
@


1.4
log
@Added Poofs to the playerfile as well as 4 extra strings for
future use.  fingon
@
text
@d411 3
a413 1
#define GET_ALIASES(ch)		((ch)->player_specials->aliases)
@


1.3
log
@indented comment header
dos2unix
@
text
@d407 2
a408 2
#define POOFIN(ch)		((ch)->player_specials->poofin)
#define POOFOUT(ch)		((ch)->player_specials->poofout)
@


1.2
log
@improved build conterounter
@
text
@d1 9
a9 10

/* ************************************************************************
*   File: utils.h                                       Part of CircleMUD *
*  Usage: header file: utility macros and prototypes of utility funcs     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d779 2
@


1.1
log
@Initial revision
@
text
@d58 1
@
