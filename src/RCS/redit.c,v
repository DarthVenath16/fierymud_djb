head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.20.20.19.51;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.21.07.10.46;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.19.02.38.15;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.19.02.34.16;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.10.06.53.55;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.11.23.04.34;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.06.53.17;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.04.01.24.37;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.15.21.16.12;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.13.00.45.27;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.24.21.17.12;	author rsd;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.18.20.59.23;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.18.06.57.20;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.14.11.12.40;	author mtp;	state Exp;
branches;
next	1.5;

1.5
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	99.04.07.01.20.18;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.04.26.53;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - redit.c 		                                          *
*    				                                          *
*  Copyright 1996 Harvey Gilpin.                                          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*. Original author: Levork .*/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "olc.h"
#include "dg_olc.h"

/*------------------------------------------------------------------------*/
/*. External data .*/

extern int      top_of_world;
extern struct room_data *world;
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;
extern char *room_bits[];
extern char *sector_types[];
extern char *exit_bits[];
extern struct zone_data *zone_table;
extern int r_mortal_start_room;
extern int r_immort_start_room;
extern int r_frozen_start_room;
extern int mortal_start_room;
extern int immort_start_room;
extern int frozen_start_room;
extern int top_of_zone_table;
extern struct descriptor_data *descriptor_list;

/*------------------------------------------------------------------------*/
/* function protos */

void redit_disp_extradesc_menu(struct descriptor_data *d);
void redit_disp_exit_menu(struct descriptor_data *d);
void redit_disp_exit_flag_menu(struct descriptor_data *d);
void redit_disp_flag_menu(struct descriptor_data *d);
void redit_disp_sector_menu(struct descriptor_data *d);
void redit_disp_menu(struct descriptor_data *d);
void redit_parse(struct descriptor_data *d, char *arg);
void redit_setup_new(struct descriptor_data *d);
void redit_setup_existing(struct descriptor_data *d, int real_num);
void redit_save_to_disk(int zone);
void redit_save_internally(struct descriptor_data *d);
void free_room(struct room_data *room);

/*------------------------------------------------------------------------*/

#define  W_EXIT(room, num) (world[(room)].dir_option[(num)])

/*------------------------------------------------------------------------*\
  Utils and exported functions.
\*------------------------------------------------------------------------*/

void redit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_ROOM(d), struct room_data, 1);

  OLC_ROOM(d)->name = str_dup("An unfinished room");
  OLC_ROOM(d)->description = str_dup("You are in an unfinished room.\r\n");
  redit_disp_menu(d);
  OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void redit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct room_data *room;
  struct trig_proto_list *proto, *fproto;
  int counter;


  /*
   * Build a copy of the room for editing.
   */
  CREATE(room, struct room_data, 1);

  *room = world[real_num];
  /*
   * Allocate space for all strings.
   */
  room->name = str_dup(world[real_num].name ? world[real_num].name : "undefined");
  if (world[real_num].description)
    room->description = str_dup(world[real_num].description);
  room->description = str_dup(world[real_num].description ?
			world[real_num].description : "undefined\r\n");
  /*
   * Exits - We allocate only if necessary.
   */
  for (counter = 0; counter < NUM_OF_DIRS; counter++) {
    if (world[real_num].dir_option[counter]) {
      CREATE(room->dir_option[counter], struct room_direction_data, 1);

      /*
       * Copy the numbers over.
       */
      *room->dir_option[counter] = *world[real_num].dir_option[counter];
      /*
       * Allocate the strings.
       */
      room->dir_option[counter]->general_description =
		(world[real_num].dir_option[counter]->general_description ?
		str_dup(world[real_num].dir_option[counter]->general_description)
		: NULL);
      room->dir_option[counter]->keyword =
		(world[real_num].dir_option[counter]->keyword ?
		str_dup(world[real_num].dir_option[counter]->keyword) : NULL);
    }
  }

  /*
   * Extra descriptions, if necessary.
   */
  if (world[real_num].ex_description) {
    struct extra_descr_data *this, *temp, *temp2;
    CREATE(temp, struct extra_descr_data, 1);

    room->ex_description = temp;
    for (this = world[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword ? str_dup(this->keyword) : NULL);
      temp->description = (this->description ? str_dup(this->description) : NULL);
      if (this->next) {
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
      } else
        temp->next = NULL;
    }
  }

  if (SCRIPT(&world[real_num]))
    script_copy(room, &world[real_num], WLD_TRIGGER);
  proto = world[real_num].proto_script;
  while (proto) {
    CREATE(fproto, struct trig_proto_list, 1);
    fproto->vnum = proto->vnum;
    if (room->proto_script==NULL)
      room->proto_script = fproto;
    proto = proto->next;
    fproto = fproto->next; /* NULL */
  }

  /*. Attatch room copy to players descriptor .*/
  OLC_ROOM(d) = room;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = WLD_TRIGGER;
  dg_olc_script_copy(d);
  redit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

#define ZCMD (zone_table[zone].cmd[cmd_no])

void redit_save_internally(struct descriptor_data *d)
{
  int i, j, room_num, found = 0, zone, cmd_no;
  struct room_data *new_world;
  struct char_data *temp_ch;
  struct obj_data *temp_obj;
  struct descriptor_data *dsc;

  room_num = real_room(OLC_NUM(d));
  /*
   * Room exists: move contents over then free and replace it.
   */
  if (room_num > 0) {
    OLC_ROOM(d)->contents = world[room_num].contents;
    OLC_ROOM(d)->people = world[room_num].people;
    free_room(world + room_num);
    world[room_num] = *OLC_ROOM(d);
	world[room_num].proto_script = OLC_SCRIPT(d);
  } else {			/* Room doesn't exist, hafta add it. */
    CREATE(new_world, struct room_data, top_of_world + 2);

	/*
     * Count through world tables.
     */
    for (i = 0; i <= top_of_world; i++) {
      if (!found) {
	/*
	 * Is this the place?
	 */
	if (world[i].number > OLC_NUM(d)) {
	  found = TRUE;
   	  new_world[i] = *(OLC_ROOM(d));
	  new_world[i].number = OLC_NUM(d);
	  new_world[i].func = NULL;
	  new_world[i].proto_script = OLC_SCRIPT(d);
   	  room_num = i;

	  /*
	   * Copy from world to new_world + 1.
	   */
	  new_world[i + 1] = world[i];

	  /*
	   * People in this room must have their numbers moved up one.
	   */
	  for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	    if (temp_ch->in_room != NOWHERE)
	      temp_ch->in_room = i + 1;

	  /* move objects */
	  for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	    if (temp_obj->in_room != NOWHERE)
	      temp_obj->in_room = i + 1;
        } else	/* Not yet placed, copy straight over. */
	  new_world[i] = world[i];
        } else {		/* Already been found. */
	/*
	 * People in this room must have their in_rooms moved.
	 */
	for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	  if (temp_ch->in_room != NOWHERE)
	    temp_ch->in_room = i + 1;
	/*
	 * Move objects too.
	 */
	for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	  if (temp_obj->in_room != -1)
	    temp_obj->in_room = i + 1;

        new_world[i + 1] = world[i];
      }
    }
    if (!found) {	/* Still not found, insert at top of table. */
      new_world[i] = *(OLC_ROOM(d));
      new_world[i].number = OLC_NUM(d);
      new_world[i].func = NULL;
	  new_world[i].proto_script = OLC_SCRIPT(d);
      room_num = i;
    }

    /* copy world table over */
    free(world);
    world = new_world;
    top_of_world++;

    /*. Update zone table .*/
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
   switch (ZCMD.command) {
	case 'M':
	case 'O':
	  if (ZCMD.arg3 >= room_num)
	    ZCMD.arg3++;
	  break;
	case 'D':
	case 'R':
	  if (ZCMD.arg1 >= room_num)
	    ZCMD.arg1++;
	case 'G':
	case 'P':
	case 'E':
	case '*':
	  break;
	default:
	  mudlog("SYSERR: OLC: redit_save_internally: Unknown comand", BRF, LVL_BUILDER, TRUE);
	}
    /* update load rooms, to fix creeping load room problem */
    if (room_num <= r_mortal_start_room)
      r_mortal_start_room++;
    if (room_num <= r_immort_start_room)
      r_immort_start_room++;
    if (room_num <= r_frozen_start_room)
      r_frozen_start_room++;

    /*. Update world exits .*/
    for (i = 0; i < top_of_world + 1; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
        if (W_EXIT(i, j))
	  if (W_EXIT(i, j)->to_room >= room_num)
	    W_EXIT(i, j)->to_room++;
	/*
     * Update any rooms being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_REDIT)
	for (j = 0; j < NUM_OF_DIRS; j++)
	  if (OLC_ROOM(dsc)->dir_option[j])
	    if (OLC_ROOM(dsc)->dir_option[j]->to_room >= room_num)
	      OLC_ROOM(dsc)->dir_option[j]->to_room++;

  }
  assign_triggers(&world[room_num], WLD_TRIGGER);
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_ROOM);
}


/*------------------------------------------------------------------------*/

void redit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct room_data *room;
  struct extra_descr_data *ex_desc;

  sprintf(buf, "%s/%d.new", WLD_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open room file!", BRF, LVL_BUILDER, TRUE);
    return;
  }
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_room(counter)) >= 0) {
      room = (world + realcounter);

      /*. Remove the '\r\n' sequences from description .*/
      strcpy(buf1, room->description ? room->description : "Empty");
      strip_string(buf1);

      /*
       * Forget making a buffer, lets just write the thing now.
       */
      fprintf(fp, "#%d\n%s~\n%s~\n%d %d %d\n", counter,
	      room->name ? room->name : "undefined", buf1,
	      zone_table[room->zone].number,
	      room->room_flags, room->sector_type);

      /*
       * Handle exits.
       */
      for (counter2 = 0; counter2 < NUM_OF_DIRS; counter2++) {
	if (room->dir_option[counter2]) {
	  int temp_door_flag;

	  /*
	   * Again, strip out the garbage.
	   */
	  if (room->dir_option[counter2]->general_description) {
	    strcpy(buf1, room->dir_option[counter2]->general_description);
	    strip_string(buf1);
	  } else
	    *buf1 = 0;

	  /*
	   * Figure out door flag.
	   */
	  if (IS_SET(room->dir_option[counter2]->exit_info, EX_ISDOOR)) {
	    if (IS_SET(room->dir_option[counter2]->exit_info, EX_PICKPROOF))
	      temp_door_flag = 2;
	    else
	      temp_door_flag = 1;
	  } else
	      temp_door_flag = 0;

          /*
	   * Check for keywords.
	   */
	  if (room->dir_option[counter2]->keyword)
	    strcpy(buf2, room->dir_option[counter2]->keyword);
	  else
	    *buf2 = '\0';

	  /*
	   * Ok, now wrote output to file.
	   */
	  fprintf(fp, "D%d\n%s~\n%s~\n%d %d %d\n", counter2, buf1, buf2,
		  temp_door_flag, room->dir_option[counter2]->key,
		  world[room->dir_option[counter2]->to_room].number);
	}
      }
      /*
       * Home straight, just deal with extra descriptions.
       */
      if (room->ex_description) {
	for (ex_desc = room->ex_description; ex_desc; ex_desc = ex_desc->next) {
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n%s~\n%s~\n", ex_desc->keyword, buf1);
	}
      }
      fprintf(fp, "S\n");
	  script_save_to_disk(fp, room, WLD_TRIGGER);
    }
  }
  /* write final line and close */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.wld", WLD_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_ROOM);
}

/*------------------------------------------------------------------------*/

void free_room(struct room_data *room)
{
  int i;
  struct extra_descr_data *this, *next;

  if (room->name)
    free(room->name);
  if (room->description)
    free(room->description);

  /*
   * Free exits.
   */
  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (room->dir_option[i]) {
      if (room->dir_option[i]->general_description)
	free(room->dir_option[i]->general_description);
      if (room->dir_option[i]->keyword)
        free(room->dir_option[i]->keyword);
    }
    free(room->dir_option[i]);
  }

    /*
   * Free extra descriptions.
   */
  for (this = room->ex_description; this; this = next) {
    next = this->next;
    if (this->keyword)
      free(this->keyword);
    if (this->description)
      free(this->description);
    free(this);
  }
}

/**************************************************************************
 Menu functions
 **************************************************************************/

/*
 * For extra descriptions.
 */
void redit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  ".[H.[J"
#endif
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: ",

	  grn, nrm, yel, extra_desc->keyword ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, extra_desc->description ? extra_desc->description : "<NONE>",
	  grn, nrm
	  );

  strcat(buf, !extra_desc->next ? "<NOT SET>\r\n" : "Set.\r\n");
  strcat(buf, "Enter choice (0 to quit) : ");
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXTRADESC_MENU;
}

/*
 * For exits.
 */
void redit_disp_exit_menu(struct descriptor_data *d)
{
  /*
   * if exit doesn't exist, alloc/create it
   */
  if (!OLC_EXIT(d))
    CREATE(OLC_EXIT(d), struct room_direction_data, 1);

  /* weird door handling! */
  if (IS_SET(OLC_EXIT(d)->exit_info, EX_ISDOOR)) {
    if (IS_SET(OLC_EXIT(d)->exit_info, EX_PICKPROOF))
      strcpy(buf2, "Pickproof");
    else
      strcpy(buf2, "Is a door");
  } else
    strcpy(buf2, "No door");

  get_char_cols(d->character);
   sprintf(buf,
#if defined(CLEAR_SCREEN)
	  ".[H.[J"
#endif
	  "%s1%s) Exit to     : %s%d\r\n"
	  "%s2%s) Description :-\r\n%s%s\r\n"
	  "%s3%s) Door name   : %s%s\r\n"
	  "%s4%s) Key         : %s%d\r\n"
	  "%s5%s) Door flags  : %s%s\r\n"
	  "%s6%s) Purge exit.\r\n"
	  "Enter choice, 0 to quit : ",

	  grn, nrm, cyn, world[OLC_EXIT(d)->to_room].number,
	  grn, nrm, yel, OLC_EXIT(d)->general_description ? OLC_EXIT(d)->general_description : "<NONE>",
	  grn, nrm, yel, OLC_EXIT(d)->keyword ? OLC_EXIT(d)->keyword : "<NONE>",
	  grn, nrm, cyn, OLC_EXIT(d)->key,
	  grn, nrm, cyn, buf2, grn, nrm
	  );

  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXIT_MENU;
}

/*
 * For exit flags.
 */
void redit_disp_exit_flag_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
    sprintf(buf, "%s0%s) No door\r\n"
	  "%s1%s) Closeable door\r\n"
	  "%s2%s) Pickproof\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
}

/*
 * For room flags.
 */
void redit_disp_flag_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ROOM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		room_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(OLC_ROOM(d)->room_flags, room_bits, buf1);
   sprintf(buf, "\r\nRoom flags: %s%s%s\r\n"
	  "Enter room flags, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_FLAGS;
}

/*
 * For sector type.
 */
void redit_disp_sector_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ROOM_SECTORS; counter++) {
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		sector_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter sector type : ", d->character);
  OLC_MODE(d) = REDIT_SECTOR;
}

/*
 * The main menu.
 */
void redit_disp_menu(struct descriptor_data *d)
{
  struct room_data *room;

  get_char_cols(d->character);
  room = OLC_ROOM(d);

  sprintbit((long)room->room_flags, room_bits, buf1);
  sprinttype(room->sector_type, sector_types, buf2);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  ".[H.[J"
#endif
	  "-- Room number : [%s%d%s]  	Room zone: [%s%d%s]\r\n"
	  "%s1%s) Name        : %s%s\r\n"
	  "%s2%s) Description :\r\n%s%s"
	  "%s3%s) Room flags  : %s%s\r\n"
	  "%s4%s) Sector type : %s%s\r\n"
	  "%s5%s) Exit north  : %s%d\r\n"
	  "%s6%s) Exit east   : %s%d\r\n"
	  "%s7%s) Exit south  : %s%d\r\n"
	  "%s8%s) Exit west   : %s%d\r\n"
	  "%s9%s) Exit up     : %s%d\r\n"
	  "%sA%s) Exit down   : %s%d\r\n"
	  "%sF%s) Extra descriptions menu\r\n"
	  "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  cyn, OLC_NUM(d), nrm,
	  cyn, zone_table[OLC_ZNUM(d)].number, nrm,
	  grn, nrm, yel, room->name,
	  grn, nrm, yel, room->description,
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2,
	  grn, nrm, cyn, room->dir_option[NORTH] ?
	  world[room->dir_option[NORTH]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[EAST] ?
	  world[room->dir_option[EAST]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[SOUTH] ?
	  world[room->dir_option[SOUTH]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[WEST] ?
	  world[room->dir_option[WEST]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[UP] ?
	  world[room->dir_option[UP]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[DOWN] ?
	  world[room->dir_option[DOWN]->to_room].number : -1,
	  grn, nrm,
      grn, nrm, cyn, room->proto_script?"Set.":"Not Set.",
      grn, nrm
	  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = REDIT_MAIN_MENU;
}



/**************************************************************************
  The main loop
 **************************************************************************/

void redit_parse(struct descriptor_data *d, char *arg)
{
  extern struct room_data *world;
  int number;

  switch (OLC_MODE(d)) {
  case REDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      redit_save_internally(d);
      sprintf(buf, "OLC: %s edits room %d.", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /*
       * Do NOT free strings! Just the room structure.
       */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Room saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /* free everything up, including strings etc */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this room internally? : ", d->character);
      break;
    }
    return;

  case REDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
     if (OLC_VAL(d)) { /* Something has been modified. */
	send_to_char("Do you wish to save this room internally? : ", d->character);
	OLC_MODE(d) = REDIT_CONFIRM_SAVESTRING;
      } else
        cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter room name:-\r\n] ", d->character);
      OLC_MODE(d) = REDIT_NAME;
      break;
    case '2':
      OLC_MODE(d) = REDIT_DESC;
#if defined(CLEAR_SCREEN)
      SEND_TO_Q("\x1B[H\x1B[J", d);
#endif
      SEND_TO_Q("Enter room description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_ROOM(d)->description) {
	SEND_TO_Q(OLC_ROOM(d)->description, d);
	d->backstr = str_dup(OLC_ROOM(d)->description);
      }
      d->str = &OLC_ROOM(d)->description;
      d->max_str = MAX_ROOM_DESC;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '3':
      redit_disp_flag_menu(d);
      break;
    case '4':
      redit_disp_sector_menu(d);
      break;
    case '5':
      OLC_VAL(d) = NORTH;
      redit_disp_exit_menu(d);
      break;
    case '6':
      OLC_VAL(d) = EAST;
      redit_disp_exit_menu(d);
      break;
    case '7':
      OLC_VAL(d) = SOUTH;
      redit_disp_exit_menu(d);
      break;
    case '8':
      OLC_VAL(d) = WEST;
      redit_disp_exit_menu(d);
      break;
    case '9':
      OLC_VAL(d) = UP;
      redit_disp_exit_menu(d);
      break;
    case 'a':
    case 'A':
      OLC_VAL(d) = DOWN;
      redit_disp_exit_menu(d);
      break;
    case 'b':
    case 'B':
      OLC_VAL(d) = FUP;
      redit_disp_exit_menu(d);
      break;
    case 'c':
    case 'C':
      OLC_VAL(d) = FDOWN;
      redit_disp_exit_menu(d);
      break;

    case 'f':
    case 'F':
      /* if extra desc doesn't exist . */
      if (!OLC_ROOM(d)->ex_description) {
	CREATE(OLC_ROOM(d)->ex_description, struct extra_descr_data, 1);
	OLC_ROOM(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_ROOM(d)->ex_description;
      redit_disp_extradesc_menu(d);
      break;
	case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
    default:
      send_to_char("Invalid choice!", d->character);
      redit_disp_menu(d);
      break;
    }
    return;


  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
  case REDIT_NAME:
    if (OLC_ROOM(d)->name)
      free(OLC_ROOM(d)->name);
    if (strlen(arg) > MAX_ROOM_NAME)
       arg[MAX_ROOM_NAME - 1] = '\0';
    OLC_ROOM(d)->name = str_dup((arg && *arg) ? arg : "undefined");
    break;
  case REDIT_DESC:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached REDIT_DESC case in parse_redit", BRF, LVL_BUILDER, TRUE);
    break;

  case REDIT_FLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ROOM_FLAGS)) {
      send_to_char("That is not a valid choice!\r\n", d->character);
      redit_disp_flag_menu(d);
    } else if (number == 0)
	break;
    else {
      /*
       * Toggle the bit.
       */
      TOGGLE_BIT(OLC_ROOM(d)->room_flags, 1 << (number - 1));
      redit_disp_flag_menu(d);

    }
    return;

  case REDIT_SECTOR:
    number = atoi(arg);
    if (number < 0 || number >= NUM_ROOM_SECTORS) {
      send_to_char("Invalid choice!", d->character);
      redit_disp_sector_menu(d);
      return;
    } else
      OLC_ROOM(d)->sector_type = number;
    break;

  case REDIT_EXIT_MENU:
    switch (*arg) {
    case '0':
      break;
    case '1':
      OLC_MODE(d) = REDIT_EXIT_NUMBER;
      send_to_char("Exit to room number : ", d->character);
      return;
    case '2':
      OLC_MODE(d) = REDIT_EXIT_DESCRIPTION;
       SEND_TO_Q("Enter exit description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_EXIT(d)->general_description) {
	SEND_TO_Q(OLC_EXIT(d)->general_description, d);
	d->backstr = str_dup(OLC_EXIT(d)->general_description);
      }
      d->str = &OLC_EXIT(d)->general_description;
      d->max_str = MAX_EXIT_DESC;
      d->mail_to = 0;
      return;
    case '3':
      OLC_MODE(d) = REDIT_EXIT_KEYWORD;
      send_to_char("Enter keywords : ", d->character);
      return;
    case '4':
      OLC_MODE(d) = REDIT_EXIT_KEY;
      send_to_char("Enter key number : ", d->character);
      return;
    case '5':
      redit_disp_exit_flag_menu(d);
      OLC_MODE(d) = REDIT_EXIT_DOORFLAGS;
      return;
    case '6':
      /* delete exit */
      if (OLC_EXIT(d)->keyword)
	free(OLC_EXIT(d)->keyword);
      if (OLC_EXIT(d)->general_description)
	free(OLC_EXIT(d)->general_description);
      if (OLC_EXIT(d))
	free(OLC_EXIT(d));
      OLC_EXIT(d) = NULL;
      break;
    default:
      send_to_char("Try again : ", d->character);
      return;
    }
    break;

  case REDIT_EXIT_NUMBER:
   if ((number = atoi(arg)) != -1)
      if ((number = real_room(number)) < 0) {
	send_to_char("That room does not exist, try again : ", d->character);
	return;
      }
    OLC_EXIT(d)->to_room = number;
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DESCRIPTION:
    /* we should NEVER get here */
    mudlog("SYSERR: Reached REDIT_EXIT_DESC case in parse_redit",BRF, LVL_BUILDER, TRUE);
    break;

  case REDIT_EXIT_KEYWORD:
    if (OLC_EXIT(d)->keyword)
      free(OLC_EXIT(d)->keyword);
   OLC_EXIT(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_KEY:
    OLC_EXIT(d)->key = atoi(arg);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DOORFLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > 2)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      redit_disp_exit_flag_menu(d);
    } else {
     /*
       * Doors are a bit idiotic, don't you think? :) I agree.
       */
      OLC_EXIT(d)->exit_info = (number == 0 ? 0 :
				(number == 1 ? EX_ISDOOR :
				(number == 2 ? EX_ISDOOR | EX_PICKPROOF : 0)));
      /*
       * Jump back to the menu system.
       */
      redit_disp_exit_menu(d);
    }
    return;

  case REDIT_EXTRADESC_KEY:
    OLC_DESC(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
    redit_disp_extradesc_menu(d);
    return;

  case REDIT_EXTRADESC_MENU:
    switch ((number = atoi(arg))) {
    case 0:
     {
/*
	 * If something got left out, delete the extra description
	 * when backing out to the menu.
	 */
	if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	  struct extra_descr_data **tmp_desc;

	  if (OLC_DESC(d)->keyword)
	    free(OLC_DESC(d)->keyword);
	  if (OLC_DESC(d)->description)
	    free(OLC_DESC(d)->description);

	/*
	   * Clean up pointers.
	   */
	  for (tmp_desc = &(OLC_ROOM(d)->ex_description); *tmp_desc;
	       tmp_desc = &((*tmp_desc)->next))
	    if (*tmp_desc == OLC_DESC(d)) {
	      *tmp_desc = NULL;
	      break;
	    }
	  free(OLC_DESC(d));
	}
      }
      break;
    case 1:
      OLC_MODE(d) = REDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces : ", d->character);
      return;
    case 2:
      OLC_MODE(d) = REDIT_EXTRADESC_DESCRIPTION;
	 SEND_TO_Q("Enter extra description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      return;

    case 3:
      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	send_to_char("You can't edit the next extra desc without completing this one.\r\n", d->character);
	redit_disp_extradesc_menu(d);
      } else {
	struct extra_descr_data *new_extra;

	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {
	  /* make new extra, attach at end */
	  CREATE(new_extra, struct extra_descr_data, 1);
	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = new_extra;
	}
	redit_disp_extradesc_menu(d);
      }
      return;
    }
    break;

  default:
    /* we should never get here */
    mudlog("SYSERR: Reached default case in parse_redit",BRF, LVL_BUILDER, TRUE);
    break;
  }
  /*. If we get this far, something has be changed .*/
  OLC_VAL(d) = 1;
  redit_disp_menu(d);
}
@


1.35
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: redit.c,v 1.34 2009/03/20 20:19:51 myc Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: redit.c                                        Part of FieryMUD *
 *  Usage:                                                                 *
 *     By: Harvey Gilpin of TwyliteMud                                     *
 * Original author: Levork                                                 *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  Copyright 1996 Harvey Gilpin.                                          *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"
#include "dg_olc.h"
#include "constants.h"
#include "math.h"
#include "exits.h"
#include "modify.h"
#include "directions.h"

/*------------------------------------------------------------------------*/
/*. External data .*/

extern int r_mortal_start_room;
extern int r_immort_start_room;
extern int r_frozen_start_room;
extern int mortal_start_room;
extern int immort_start_room;
extern int frozen_start_room;

/*------------------------------------------------------------------------*/
/* function protos */

void redit_disp_extradesc_menu(struct descriptor_data *d);
void redit_disp_exit_menu(struct descriptor_data *d);
void redit_disp_exit_flag_menu(struct descriptor_data *d);
void redit_disp_flag_menu(struct descriptor_data *d);
void redit_disp_sector_menu(struct descriptor_data *d);
void redit_disp_menu(struct descriptor_data *d);
void redit_parse(struct descriptor_data *d, char *arg);
void redit_setup_new(struct descriptor_data *d);
void redit_setup_existing(struct descriptor_data *d, int real_num);
void redit_save_to_disk(int zone);
void redit_save_internally(struct descriptor_data *d);
void free_room(struct room_data *room);

/*------------------------------------------------------------------------*/

#define  W_EXIT(room, num) (world[(room)].exits[(num)])

/*------------------------------------------------------------------------*\
  Utils and exported functions.
\*------------------------------------------------------------------------*/

void redit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_ROOM(d), struct room_data, 1);

  OLC_ITEM_TYPE(d) = WLD_TRIGGER;
  OLC_ROOM(d)->name = strdup("An unfinished room");
  OLC_ROOM(d)->description = strdup("You are in an unfinished room.\r\n");
  redit_disp_menu(d);
  OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void redit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct room_data *room;
  int counter;


  /*
   * Build a copy of the room for editing.
   */
  CREATE(room, struct room_data, 1);

  *room = world[real_num];
  /*
   * Allocate space for all strings.
   */
  room->name = strdup(world[real_num].name ? world[real_num].name : "undefined");
  room->description = strdup(world[real_num].description ?
                              world[real_num].description : "undefined\r\n");
  /*
   * Exits - We allocate only if necessary.
   */
  for (counter = 0; counter < NUM_OF_DIRS; counter++) {
    if (world[real_num].exits[counter]) {
      room->exits[counter] = create_exit(NOWHERE);
      /*
       * Copy the numbers over.
       */
      *room->exits[counter] = *world[real_num].exits[counter];
      /*
       * Allocate the strings.
       */
      room->exits[counter]->general_description =
        (world[real_num].exits[counter]->general_description ?
         strdup(world[real_num].exits[counter]->general_description)
         : NULL);
      room->exits[counter]->keyword =
        (world[real_num].exits[counter]->keyword ?
         strdup(world[real_num].exits[counter]->keyword) : NULL);
    }
  }

  /*
   * Extra descriptions, if necessary.
   */
  if (world[real_num].ex_description) {
    struct extra_descr_data *this, *temp, *temp2;
    CREATE(temp, struct extra_descr_data, 1);

    room->ex_description = temp;
    for (this = world[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword ? strdup(this->keyword) : NULL);
      temp->description = (this->description ? strdup(this->description) : NULL);
      if (this->next) {
        CREATE(temp2, struct extra_descr_data, 1);
        temp->next = temp2;
        temp = temp2;
      } else
        temp->next = NULL;
    }
  }

  /*. Attatch room copy to players descriptor .*/
  OLC_ROOM(d) = room;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = WLD_TRIGGER;
  dg_olc_script_copy(d);
  redit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

#define ZCMD (zone_table[zone].cmd[cmd_no])

void redit_save_internally(struct descriptor_data *d)
{
  int i, j, room_num, found = 0, zone, cmd_no;
  struct room_data *new_world;
  struct char_data *temp_ch;
  struct obj_data *temp_obj;
  struct descriptor_data *dsc;

  room_num = real_room(OLC_NUM(d));
  /*
   * Room exists: move contents over then free and replace it.
   */
  if (room_num > 0) {
    OLC_ROOM(d)->contents = world[room_num].contents;
    OLC_ROOM(d)->people = world[room_num].people;
    free_room(world + room_num);
    if (SCRIPT(&world[room_num]))
      extract_script(SCRIPT(&world[room_num]));
    if (world[room_num].proto_script &&
        world[room_num].proto_script != OLC_SCRIPT(d))
      free_proto_script(&world[room_num].proto_script);
    world[room_num] = *OLC_ROOM(d);
    SCRIPT(&world[room_num]) = NULL;
    world[room_num].proto_script = OLC_SCRIPT(d);
    assign_triggers(&world[room_num], WLD_TRIGGER);
  } else {                        /* Room doesn't exist, hafta add it. */

    /*
     * First, drop any room triggers/scripts.  A necessary evil
     * to prevent crashes.
     */
    for (i = 0; i <= top_of_world; ++i)
      if (SCRIPT(&world[i])) {
        extract_script(SCRIPT(&world[i]));
        SCRIPT(&world[i]) = NULL;
      }

    CREATE(new_world, struct room_data, top_of_world + 2);

    /*
     * Count through world tables.
     */
    for (i = 0; i <= top_of_world; i++) {
      if (!found) {
        /*
         * Is this the place?
         */
        if (world[i].vnum > OLC_NUM(d)) {
          found = TRUE;
             new_world[i] = *(OLC_ROOM(d));
          new_world[i].vnum = OLC_NUM(d);
          new_world[i].func = NULL;
          new_world[i].proto_script = OLC_SCRIPT(d);
             room_num = i;

          /*
           * Copy from world to new_world + 1.
           */
          new_world[i + 1] = world[i];

          /*
           * People in this room must have their numbers moved up one.
           */
          for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
            if (temp_ch->in_room != NOWHERE)
              temp_ch->in_room = i + 1;

          /* move objects */
          for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
            if (temp_obj->in_room != NOWHERE)
              temp_obj->in_room = i + 1;
        } else        /* Not yet placed, copy straight over. */
          new_world[i] = world[i];
      } else {                /* Already been found. */
        /*
         * People in this room must have their in_rooms moved.
         */
        for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
          if (temp_ch->in_room != NOWHERE)
            temp_ch->in_room = i + 1;
        /*
         * Move objects too.
         */
        for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
          if (temp_obj->in_room != -1)
            temp_obj->in_room = i + 1;

        new_world[i + 1] = world[i];
      }
    }
    if (!found) {        /* Still not found, insert at top of table. */
      new_world[i] = *(OLC_ROOM(d));
      new_world[i].vnum = OLC_NUM(d);
      new_world[i].func = NULL;
      new_world[i].proto_script = OLC_SCRIPT(d);
      room_num = i;
    }

    /* copy world table over */
    free(world);
    world = new_world;
    top_of_world++;

    /* Now reattach triggers. */
    for (i = 0; i <= top_of_world; ++i)
      assign_triggers(&world[i], WLD_TRIGGER);

    /*. Update zone table .*/
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
        switch (ZCMD.command) {
        case 'M':
        case 'O':
          if (ZCMD.arg3 >= room_num)
            ZCMD.arg3++;
          break;
        case 'D':
        case 'R':
          if (ZCMD.arg1 >= room_num)
            ZCMD.arg1++;
        case 'G':
        case 'P':
        case 'E':
        case '*':
          break;
        default:
          sprintf(buf,"SYSERR:redit.c:redit_save_internally(): Unknown command: %d in zone %s.",
                  ZCMD.command, zone_table[zone].name);
          log("%s",buf);
          mudlog(buf, BRF, LVL_GOD, TRUE);
        }
    /* update load rooms, to fix creeping load room problem */
    if (room_num <= r_mortal_start_room)
      r_mortal_start_room++;
    if (room_num <= r_immort_start_room)
      r_immort_start_room++;
    if (room_num <= r_frozen_start_room)
      r_frozen_start_room++;

    /*. Update world exits .*/
    for (i = 0; i < top_of_world + 1; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
        if (W_EXIT(i, j))
          if (W_EXIT(i, j)->to_room >= room_num)
            W_EXIT(i, j)->to_room++;
    /*
     * Update any rooms being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_REDIT)
        for (j = 0; j < NUM_OF_DIRS; j++)
          if (OLC_ROOM(dsc)->exits[j])
            if (OLC_ROOM(dsc)->exits[j]->to_room >= room_num)
              OLC_ROOM(dsc)->exits[j]->to_room++;

  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_ROOM);
}


/*------------------------------------------------------------------------*/

void redit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct room_data *room;
  struct extra_descr_data *ex_desc;

  sprintf(buf, "%s/%d.new", WLD_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open room file!", BRF, LVL_GOD, TRUE);
    return;
  }
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_room(counter)) >= 0) {
      room = (world + realcounter);

      /*. Remove the '\r\n' sequences from description .*/
      strcpy(buf1, room->description ? room->description : "Empty");
      strip_string(buf1);

      /*
       * Forget making a buffer, lets just write the thing now.
       */
      fprintf(fp, "#%d\n%s~\n%s~\n%d %ld %d\n", counter,
              room->name ? room->name : "undefined", buf1,
              zone_table[room->zone].number,
              room->room_flags[0], room->sector_type);

      /*
       * Handle exits.
       */
      for (counter2 = 0; counter2 < NUM_OF_DIRS; counter2++) {
        if (room->exits[counter2]) {
          int temp_door_flag;

          /*
           * Again, strip out the garbage.
           */
          if (room->exits[counter2]->general_description) {
            strcpy(buf1, room->exits[counter2]->general_description);
            strip_string(buf1);
          } else
            *buf1 = 0;

          /*
           * Figure out door flag.
           */
          if (IS_SET(room->exits[counter2]->exit_info, EX_ISDOOR)) {
            if (IS_SET(room->exits[counter2]->exit_info, EX_PICKPROOF))
              temp_door_flag = 2;
            else
              temp_door_flag = 1;
          } else if (IS_SET(room->exits[counter2]->exit_info, EX_DESCRIPT)) {
            temp_door_flag = 3;
            room->exits[counter2]->to_room = -1;
            room->exits[counter2]->key = -1;
          } else
            temp_door_flag = 0;

          /*
           * Check for keywords.
           */
          if (room->exits[counter2]->keyword)
            strcpy(buf2, room->exits[counter2]->keyword);
          else
            *buf2 = '\0';

          /*
           * Ok, now wrote output to file.
           */
          fprintf(fp, "D%d\n%s~\n%s~\n%d %d %d\n", counter2, buf1, buf2,
                  temp_door_flag, room->exits[counter2]->key,
                  room->exits[counter2]->to_room == -1 ? -1 :
                     world[room->exits[counter2]->to_room].vnum);
        }
      }
      /*
       * Home straight, just deal with extra descriptions.
       */
      if (room->ex_description) {
        for (ex_desc = room->ex_description; ex_desc; ex_desc = ex_desc->next) {
          strcpy(buf1, ex_desc->description);
          strip_string(buf1);
          fprintf(fp, "E\n%s~\n%s~\n", ex_desc->keyword, buf1);
        }
      }
      fprintf(fp, "S\n");
      script_save_to_disk(fp, room, WLD_TRIGGER);
    }
  }
  /* write final line and close */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.wld", WLD_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_ROOM);
}

/*------------------------------------------------------------------------*/

void free_room(struct room_data *room)
{
  int i;
  struct extra_descr_data *this, *next;

  if (room->name)
    free(room->name);
  if (room->description)
    free(room->description);

  /*
   * Free exits.
   */
  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (room->exits[i]) {
      if (room->exits[i]->general_description)
        free(room->exits[i]->general_description);
      if (room->exits[i]->keyword)
        free(room->exits[i]->keyword);
      free(room->exits[i]);
    }
  }

  /*
   * Free extra descriptions.
   */
  for (this = room->ex_description; this; this = next) {
    next = this->next;
    if (this->keyword)
      free(this->keyword);
    if (this->description)
      free(this->description);
    free(this);
  }
}

/**************************************************************************
 *                       Menu functions                                   *
 **************************************************************************/

/*
 * For extra descriptions.
 */
void redit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
          ".[H.[J"
#endif
          "%s1%s) Keyword: %s%s\r\n"
          "%s2%s) Description:\r\n%s%s\r\n"
          "%s3%s) Goto next description: ",

          grn, nrm, yel, extra_desc->keyword ? extra_desc->keyword : "<NONE>",
          grn, nrm, yel, extra_desc->description ? extra_desc->description : "<NONE>",
          grn, nrm
          );

  strcat(buf, !extra_desc->next ? "<NOT SET>\r\n" : "Set.\r\n");
  strcat(buf, "Enter choice (0 to quit) : ");
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXTRADESC_MENU;
}

/*
 * For exits.
 */
void redit_disp_exit_menu(struct descriptor_data *d)
{
  /*
   * if exit doesn't exist, alloc/create it
   */
  if (!OLC_EXIT(d)) {
    OLC_EXIT(d) = create_exit(NOWHERE);
  }

  *buf2 = '\0';
  /* weird door handling! */
  if (IS_SET(OLC_EXIT(d)->exit_info, EX_DESCRIPT))
    strcat(buf2, "Description only ");
  if (IS_SET(OLC_EXIT(d)->exit_info, EX_ISDOOR)) {
    if (IS_SET(OLC_EXIT(d)->exit_info, EX_PICKPROOF))
      strcat(buf2, "Pickproof");
    else
      strcat(buf2, "Is a door");
  } else
    strcat(buf2, "No door");

  get_char_cols(d->character);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
          ".[H.[J"
#endif
          "%s1%s) Exit to     : %s%d\r\n"
          "%s2%s) Description :-\r\n%s%s\r\n"
          "%s3%s) Door name   : %s%s\r\n"
          "%s4%s) Key         : %s%d\r\n"
          "%s5%s) Door flags  : %s%s\r\n"
          "%s6%s) Purge exit.\r\n"
          "Enter choice, 0 to quit : ",

          grn, nrm, cyn, OLC_EXIT(d)->to_room == NOWHERE ? -1 : world[OLC_EXIT(d)->to_room].vnum,
          grn, nrm, yel, OLC_EXIT(d)->general_description ? OLC_EXIT(d)->general_description : "<NONE>",
          grn, nrm, yel, OLC_EXIT(d)->keyword ? OLC_EXIT(d)->keyword : "<NONE>",
          grn, nrm, cyn, OLC_EXIT(d)->key,
          grn, nrm, cyn, buf2, grn, nrm
          );

  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXIT_MENU;
}

/*
 * For exit flags.
 */
void redit_disp_exit_flag_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintf(buf, "%s0%s) No door\r\n"
          "%s1%s) Closeable door\r\n"
          "%s2%s) Pickproof\r\n"
          "%s3%s) Description\r\n"
          "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
}

/*
 * For room flags.
 */
#define FLAG_INDEX        ((NUM_ROOM_FLAGS / columns + 1) * j + i)
void redit_disp_flag_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= NUM_ROOM_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (FLAG_INDEX < NUM_ROOM_FLAGS)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, FLAG_INDEX + 1, nrm, room_bits[FLAG_INDEX]);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintflag(buf1, OLC_ROOM(d)->room_flags, NUM_ROOM_FLAGS, room_bits);
  sprintf(buf, "\r\nRoom flags: %s%s%s\r\n"
          "Enter room flags, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_FLAGS;
}
#undef FLAG_INDEX

/*
 * For sector type.
 */
#define TYPE_INDEX        ((NUM_SECTORS / columns + 1) * j + i)
void redit_disp_sector_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i < NUM_SECTORS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (TYPE_INDEX < NUM_SECTORS)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, TYPE_INDEX + 1, nrm, sectors[TYPE_INDEX].name);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  send_to_char("\r\nEnter sector type, 0 to cancel : ", d->character);
  OLC_MODE(d) = REDIT_SECTOR;
}
#undef TYPE_INDEX

/*
 * The main menu.
 */
void redit_disp_menu(struct descriptor_data *d)
{
  struct room_data *room;

  get_char_cols(d->character);
  room = OLC_ROOM(d);

  sprintflag(buf1, room->room_flags, NUM_ROOM_FLAGS, room_bits);
  sprintf(buf2, "%s", sectors[room->sector_type].name);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
          ".[H.[J"
#endif
          "-- Room: '&5%s&0'  vnum: [&2%5d&0]\r\n"
          "%s1%s) Name        : %s%s\r\n"
          "%s2%s) Description :\r\n%s%s"
          "%s3%s) Room flags  : %s%s\r\n"
          "%s4%s) Sector type : %s%s\r\n",
          room->name, OLC_NUM(d),
          grn, nrm, yel, room->name,
          grn, nrm, yel, room->description,
          grn, nrm, cyn, buf1,
          grn, nrm, cyn, buf2);

  sprintf(buf, "%s%s5%s) Exit north  : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[NORTH]));

  sprintf(buf, "%s%s6%s) Exit east   : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[EAST]));
  sprintf(buf, "%s%s7%s) Exit south  : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[SOUTH]));
  sprintf(buf, "%s%s8%s) Exit west   : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[WEST]));
  sprintf(buf, "%s%s9%s) Exit up     : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[UP]));
  sprintf(buf, "%s%sA%s) Exit down   : %s%s\r\n", buf,
          grn, nrm, cyn, exit_dest_desc(room->exits[DOWN]));

  sprintf(buf, "%s%sF%s) Extra descriptions menu\r\n"
          "%sS%s) Script      : %s%s\r\n"
          "%sQ%s) Quit\r\n"
          "Enter choice : ", buf,

          grn, nrm,
          grn, nrm, cyn, room->proto_script?"Set.":"Not Set.",
          grn, nrm
          );
  send_to_char(buf, d->character);

  OLC_MODE(d) = REDIT_MAIN_MENU;
}



/**************************************************************************
 *                        The main loop                                   *
 **************************************************************************/

void redit_parse(struct descriptor_data *d, char *arg)
{
  int number;

  switch (OLC_MODE(d)) {
  case REDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      redit_save_internally(d);
      sprintf(buf, "OLC: %s edits room %d.", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
      /*
       * Do NOT free strings! Just the room structure.
       */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Room saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /* free everything up, including strings etc */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this room internally? : ", d->character);
      break;
    }
    return;

  case REDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) { /* Something has been modified. */
        send_to_char("Do you wish to save this room internally? : ", d->character);
        OLC_MODE(d) = REDIT_CONFIRM_SAVESTRING;
      } else
        cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter room name:-\r\n] ", d->character);
      OLC_MODE(d) = REDIT_NAME;
      break;
    case '2':
      OLC_MODE(d) = REDIT_DESC;
#if defined(CLEAR_SCREEN)
      write_to_output("\x1B[H\x1B[J", d);
#endif
      write_to_output("Enter room description: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_ROOM(d)->description, MAX_ROOM_DESC);
      OLC_VAL(d) = 1;
      break;
    case '3':
      redit_disp_flag_menu(d);
      break;
    case '4':
      redit_disp_sector_menu(d);
      break;
    case '5':
      OLC_VAL(d) = NORTH;
      redit_disp_exit_menu(d);
      break;
    case '6':
      OLC_VAL(d) = EAST;
      redit_disp_exit_menu(d);
      break;
    case '7':
      OLC_VAL(d) = SOUTH;
      redit_disp_exit_menu(d);
      break;
    case '8':
      OLC_VAL(d) = WEST;
      redit_disp_exit_menu(d);
      break;
    case '9':
      OLC_VAL(d) = UP;
      redit_disp_exit_menu(d);
      break;
    case 'a':
    case 'A':
      OLC_VAL(d) = DOWN;
      redit_disp_exit_menu(d);
      break;

    case 'f':
    case 'F':
      /* if extra desc doesn't exist . */
      if (!OLC_ROOM(d)->ex_description) {
        CREATE(OLC_ROOM(d)->ex_description, struct extra_descr_data, 1);
        OLC_ROOM(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_ROOM(d)->ex_description;
      redit_disp_extradesc_menu(d);
      break;
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      redit_disp_menu(d);
      break;
    }
    return;


  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
  case REDIT_NAME:
    if (OLC_ROOM(d)->name)
      free(OLC_ROOM(d)->name);
    if (strlen(arg) > MAX_ROOM_NAME)
      arg[MAX_ROOM_NAME - 1] = '\0';
    OLC_ROOM(d)->name = strdup((arg && *arg) ? arg : "undefined");
    break;
  case REDIT_DESC:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached REDIT_DESC case in parse_redit", BRF, LVL_GOD, TRUE);
    break;

  case REDIT_FLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ROOM_FLAGS)) {
      send_to_char("That is not a valid choice!\r\n", d->character);
      redit_disp_flag_menu(d);
    } else if (number == 0)
      break;
    else {
      /*
       * Toggle the bit.
       */
      TOGGLE_FLAG(OLC_ROOM(d)->room_flags, number - 1);
      redit_disp_flag_menu(d);

    }
    return;

  case REDIT_SECTOR:
    number = atoi(arg);
    if (number < 0 || number > NUM_SECTORS) {
      send_to_char("Invalid choice!\r\n", d->character);
      redit_disp_sector_menu(d);
      return;
    } else if (number != 0)
      OLC_ROOM(d)->sector_type = number - 1;
    break;

  case REDIT_EXIT_MENU:
    switch (*arg) {
    case '0':
      break;
    case '1':
      OLC_MODE(d) = REDIT_EXIT_NUMBER;
      send_to_char("Exit to room number : ", d->character);
      return;
    case '2':
      OLC_MODE(d) = REDIT_EXIT_DESCRIPTION;
      write_to_output("Enter exit description: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_EXIT(d)->general_description, MAX_EXIT_DESC);
      return;
    case '3':
      OLC_MODE(d) = REDIT_EXIT_KEYWORD;
      send_to_char("Enter keywords : ", d->character);
      return;
    case '4':
      OLC_MODE(d) = REDIT_EXIT_KEY;
      send_to_char("Enter key number : ", d->character);
      return;
    case '5':
      redit_disp_exit_flag_menu(d);
      OLC_MODE(d) = REDIT_EXIT_DOORFLAGS;
      return;
    case '6':
      /* delete exit */
      if (OLC_EXIT(d)->keyword)
        free(OLC_EXIT(d)->keyword);
      if (OLC_EXIT(d)->general_description)
        free(OLC_EXIT(d)->general_description);
      if (OLC_EXIT(d))
        free(OLC_EXIT(d));
      OLC_EXIT(d) = NULL;
      break;
    default:
      send_to_char("Try again : ", d->character);
      return;
    }
    break;

  case REDIT_EXIT_NUMBER:
    if ((number = atoi(arg)) != -1)
      if ((number = real_room(number)) < 0) {
        send_to_char("That room does not exist.  Try again : ", d->character);
        return;
      }
      OLC_EXIT(d)->to_room = number;
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DESCRIPTION:
    /* we should NEVER get here */
    mudlog("SYSERR: Reached REDIT_EXIT_DESC case in parse_redit",BRF, LVL_GOD, TRUE);
    break;

  case REDIT_EXIT_KEYWORD:
    if (OLC_EXIT(d)->keyword)
      free(OLC_EXIT(d)->keyword);
    OLC_EXIT(d)->keyword = ((arg && *arg) ? strdup(arg) : NULL);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_KEY:
    OLC_EXIT(d)->key = atoi(arg);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DOORFLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > 3)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      redit_disp_exit_flag_menu(d);
    } else {
      /*
       * Doors are a bit idiotic, don't you think? :) I agree.
       */
      if (number == 1)
        OLC_EXIT(d)->exit_info = EX_ISDOOR;
      else if (number == 2)
        OLC_EXIT(d)->exit_info = EX_ISDOOR | EX_PICKPROOF;
      else if (number == 3)
        OLC_EXIT(d)->exit_info = EX_DESCRIPT;
      else
        OLC_EXIT(d)->exit_info = 0;


   /*   OLC_EXIT(d)->exit_info = (number == 0 ? 0 :
                                (number == 1 ? EX_ISDOOR :
                                 (number == 2 ? EX_ISDOOR | EX_PICKPROOF :
                                  (number == 3 ? EX_DESCRIPT : 0)))); */
      /*
       * Jump back to the menu system.
       */
      redit_disp_exit_menu(d);
    }
    return;

  case REDIT_EXTRADESC_KEY:
    OLC_DESC(d)->keyword = ((arg && *arg) ? strdup(arg) : NULL);
    redit_disp_extradesc_menu(d);
    return;

  case REDIT_EXTRADESC_MENU:
    switch ((number = atoi(arg))) {
    case 0:
      {
        /*
         * If something got left out, delete the extra description
         * when backing out to the menu.
         */
        if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
          struct extra_descr_data **tmp_desc;

          if (OLC_DESC(d)->keyword)
            free(OLC_DESC(d)->keyword);
          if (OLC_DESC(d)->description)
            free(OLC_DESC(d)->description);

          /*
           * Clean up pointers.
           */
          for (tmp_desc = &(OLC_ROOM(d)->ex_description); *tmp_desc;
               tmp_desc = &((*tmp_desc)->next))
            if (*tmp_desc == OLC_DESC(d)) {
              *tmp_desc = NULL;
              break;
            }
          free(OLC_DESC(d));
        }
      }
      break;
    case 1:
      OLC_MODE(d) = REDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces : ", d->character);
      return;
    case 2:
      OLC_MODE(d) = REDIT_EXTRADESC_DESCRIPTION;
      write_to_output("Enter extra description: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_DESC(d)->description, MAX_DESC_LENGTH);
      return;

    case 3:
      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
        send_to_char("You can't edit the next extra desc without completing this one.\r\n", d->character);
        redit_disp_extradesc_menu(d);
      } else {
        struct extra_descr_data *new_extra;

        if (OLC_DESC(d)->next)
          OLC_DESC(d) = OLC_DESC(d)->next;
        else {
          /* make new extra, attach at end */
          CREATE(new_extra, struct extra_descr_data, 1);
          OLC_DESC(d)->next = new_extra;
          OLC_DESC(d) = new_extra;
        }
        redit_disp_extradesc_menu(d);
      }
      return;
    }
    break;

  default:
    /* we should never get here */
    mudlog("SYSERR: Reached default case in parse_redit",BRF, LVL_GOD, TRUE);
    break;
  }
  /*. If we get this far, something has be changed .*/
  OLC_VAL(d) = 1;
  redit_disp_menu(d);
}

/***************************************************************************
 * $Log: redit.c,v $
 * Revision 1.34  2009/03/20 20:19:51  myc
 * Removing dependency upon old board system.
 *
 * Revision 1.33  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.32  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.31  2008/08/21 07:10:46  jps
 * Changed the way redit sees exit destinations. It's more informative and less crashy.
 *
 * Revision 1.30  2008/08/19 02:38:15  jps
 * Fix the next bug in room saving...
 *
 * Revision 1.29  2008/08/19 02:34:16  jps
 * Stop crashing when saving description exits.
 *
 * Revision 1.28  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.27  2008/08/10 06:53:55  jps
 * Stop crashing when editing exits in brand new rooms?
 *
 * Revision 1.26  2008/06/11 23:04:34  jps
 * Changed room editing menu a bit
 *
 * Revision 1.25  2008/05/19 06:53:17  jps
 * Got rid of fup and fdown directions.
 *
 * Revision 1.24  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.23  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.22  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.21  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.20  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.19  2008/03/17 16:22:42  myc
 * Fixed handling of proto scripts in OLC, which was causing a crash.
 * Also fixed some memory leaks associated with scripts and OLC.
 * How this got by for so long, I don't know.
 *
 * Revision 1.18  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.17  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.16  2007/11/18 16:51:55  myc
 * Fixing LVL_BUILDER references.
 *
 * Revision 1.15  2007/09/15 05:03:46  myc
 * Implemented a new loop method for some of the menus so that items in
 * the menus get listed column-major instead of by rows.  This applies to
 * the sector and flag menus.
 *
 * Revision 1.14  2007/08/04 01:24:37  myc
 * When saving a new room in redit, all room triggers in the world are now
 * dropped and reloaded (all trigger execution thus stops).  Although
 * inconvenient, this is a necessary evil in order to prevent event-related
 * crashes.
 *
 * Revision 1.13  2007/08/03 22:00:11  myc
 * Fixed some \r\n typoes in send_to_chars.
 *
 * Revision 1.12  2007/07/15 21:16:12  myc
 * No more crash when you edit a script on a new object or room.
 *
 * Revision 1.11  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.10  2001/03/13 00:45:27  dce
 * Keys default to -1 as requested by builders.
 *
 * Revision 1.9  2000/11/24 21:17:12  rsd
 * Altered comment header and added back rlog messgaes from
 * prior to the addition of the $log$ string.
 *
 * Revision 1.8  2000/11/18 20:59:23  jimmy
 * Added sane debug to redit_save_internally
 *
 * Revision 1.7  2000/11/18 06:57:20  rsd
 * changed the comment header and tried to add some
 * sensible debug to redit_save_internal.
 *
 * Revision 1.6  2000/10/14 11:12:40  mtp
 * fixed the olc triggers editting in medit/oedit/redit
 *
 * Revision 1.5  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.4  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.3  1999/04/07 01:20:18  dce
 * Allows extra descriptions on no exits.
 *
 * Revision 1.2  1999/02/01 04:26:53  mud
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.34
log
@Removing dependency upon old board system.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.33 2009/03/09 04:33:20 jps Exp myc $
d278 1
a278 1
          log(buf);
d991 3
@


1.33
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.32 2008/09/09 08:23:37 jps Exp jps $
a21 1
#include "boards.h"
d955 1
a955 1
      string_write(d, &OLC_DESC(d)->description, MAX_MESSAGE_LENGTH);
d991 4
@


1.32
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.31 2008/08/21 07:10:46 jps Exp jps $
d29 1
d992 3
@


1.31
log
@Changed the way redit sees exit destinations. It's more informative and less crashy.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.30 2008/08/19 02:38:15 jps Exp jps $
d580 1
a580 1
#define TYPE_INDEX        ((NUM_ROOM_SECTORS / columns + 1) * j + i)
d590 1
a590 1
  for (i = 0; i < NUM_ROOM_SECTORS / columns; ++i) {
d593 1
a593 1
      if (TYPE_INDEX < NUM_ROOM_SECTORS)
d595 1
a595 1
                grn, TYPE_INDEX + 1, nrm, sector_types[TYPE_INDEX]);
d615 1
a615 1
  sprinttype(room->sector_type, sector_types, buf2);
d808 1
a808 1
    if (number < 0 || number > NUM_ROOM_SECTORS) {
d991 3
@


1.30
log
@Fix the next bug in room saving...
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.29 2008/08/19 02:34:16 jps Exp jps $
d624 1
a624 12
          "%s4%s) Sector type : %s%s\r\n"
          "%s5%s) Exit north  : %s%d\r\n"
          "%s6%s) Exit east   : %s%d\r\n"
          "%s7%s) Exit south  : %s%d\r\n"
          "%s8%s) Exit west   : %s%d\r\n"
          "%s9%s) Exit up     : %s%d\r\n"
          "%sA%s) Exit down   : %s%d\r\n"
          "%sF%s) Extra descriptions menu\r\n"
          "%sS%s) Script      : %s%s\r\n"
          "%sQ%s) Quit\r\n"
          "Enter choice : ",

d629 21
a649 13
          grn, nrm, cyn, buf2,
          grn, nrm, cyn, room->exits[NORTH] ?
          world[room->exits[NORTH]->to_room].vnum : -1,
          grn, nrm, cyn, room->exits[EAST] ?
          world[room->exits[EAST]->to_room].vnum : -1,
          grn, nrm, cyn, room->exits[SOUTH] ?
          world[room->exits[SOUTH]->to_room].vnum : -1,
          grn, nrm, cyn, room->exits[WEST] ?
          world[room->exits[WEST]->to_room].vnum : -1,
          grn, nrm, cyn, room->exits[UP] ?
          world[room->exits[UP]->to_room].vnum : -1,
          grn, nrm, cyn, room->exits[DOWN] ?
          world[room->exits[DOWN]->to_room].vnum : -1,
d991 3
@


1.29
log
@Stop crashing when saving description exits.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.28 2008/08/14 09:45:22 jps Exp jps $
d385 2
a386 1
                  world[room->exits[counter2]->to_room].vnum);
d994 3
@


1.28
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.27 2008/08/10 06:53:55 jps Exp jps $
d367 1
a367 1
            world[room->exits[counter2]->to_room].vnum= -1;
d993 3
@


1.27
log
@Stop crashing when editing exits in brand new rooms?
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.26 2008/06/11 23:04:34 jps Exp jps $
d28 1
d993 3
@


1.26
log
@Changed room editing menu a bit
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.25 2008/05/19 06:53:17 jps Exp jps $
d519 1
a519 1
          grn, nrm, cyn, world[OLC_EXIT(d)->to_room].vnum,
d992 3
@


1.25
log
@Got rid of fup and fdown directions.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.24 2008/05/18 05:18:06 jps Exp jps $
d618 1
a618 1
          "-- Room number : [%s%d%s]          Room zone: [%s%d%s]\r\n"
d634 1
a634 2
          cyn, OLC_NUM(d), nrm,
          cyn, zone_table[OLC_ZNUM(d)].number, nrm,
d992 3
@


1.24
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.23 2008/05/17 04:32:25 jps Exp jps $
a749 10
    case 'b':
    case 'B':
      OLC_VAL(d) = FUP;
      redit_disp_exit_menu(d);
      break;
    case 'c':
    case 'C':
      OLC_VAL(d) = FDOWN;
      redit_disp_exit_menu(d);
      break;
d862 1
a862 1
        send_to_char("That room does not exist, try again : ", d->character);
d993 4
@


1.23
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.22 2008/04/05 05:05:42 myc Exp jps $
d66 1
a66 1
  
d77 1
a77 1
{ 
d80 2
a81 2
  
  
d86 1
a86 1
  
d93 1
a93 1
			      world[real_num].description : "undefined\r\n");
d108 3
a110 3
	(world[real_num].exits[counter]->general_description ?
	 strdup(world[real_num].exits[counter]->general_description)
	 : NULL);
d112 2
a113 2
	(world[real_num].exits[counter]->keyword ?
	 strdup(world[real_num].exits[counter]->keyword) : NULL);
d116 1
a116 1
  
d123 1
a123 1
    
d129 3
a131 3
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
d136 1
a136 1
  
d146 1
a146 1
      
d150 1
a150 1
{ 
d156 1
a156 1
  
d174 2
a175 2
  } else {			/* Room doesn't exist, hafta add it. */
    
d193 43
a235 43
	/*
	 * Is this the place? 
	 */
	if (world[i].number > OLC_NUM(d)) {
	  found = TRUE;
   	  new_world[i] = *(OLC_ROOM(d));
	  new_world[i].number = OLC_NUM(d);
	  new_world[i].func = NULL;
	  new_world[i].proto_script = OLC_SCRIPT(d);
   	  room_num = i;
	  
	  /*
	   * Copy from world to new_world + 1.
	   */
	  new_world[i + 1] = world[i];
	  
	  /*
	   * People in this room must have their numbers moved up one.
	   */
	  for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	    if (temp_ch->in_room != NOWHERE)
	      temp_ch->in_room = i + 1;
	  
	  /* move objects */
	  for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	    if (temp_obj->in_room != NOWHERE)
	      temp_obj->in_room = i + 1;
        } else	/* Not yet placed, copy straight over. */
	  new_world[i] = world[i];
      } else {		/* Already been found. */
	/*
	 * People in this room must have their in_rooms moved.
	 */
	for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	  if (temp_ch->in_room != NOWHERE)
	    temp_ch->in_room = i + 1;
	/*
	 * Move objects too.
	 */
	for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	  if (temp_obj->in_room != -1)
	    temp_obj->in_room = i + 1;
	
d239 1
a239 1
    if (!found) {	/* Still not found, insert at top of table. */
d241 1
a241 1
      new_world[i].number = OLC_NUM(d);
d246 1
a246 1
    
d251 1
a251 1
    
d259 21
a279 21
	switch (ZCMD.command) {
	case 'M':
	case 'O':
	  if (ZCMD.arg3 >= room_num)
	    ZCMD.arg3++;
	  break;
	case 'D':
	case 'R':
	  if (ZCMD.arg1 >= room_num)
	    ZCMD.arg1++;
	case 'G':
	case 'P':
	case 'E':
	case '*':
	  break;
	default:
	  sprintf(buf,"SYSERR:redit.c:redit_save_internally(): Unknown command: %d in zone %s.", 
		  ZCMD.command, zone_table[zone].name);
	  log(buf);
	  mudlog(buf, BRF, LVL_GOD, TRUE);
	}
d287 1
a287 1
    
d292 2
a293 2
	  if (W_EXIT(i, j)->to_room >= room_num)
	    W_EXIT(i, j)->to_room++;
d299 5
a303 5
	for (j = 0; j < NUM_OF_DIRS; j++)
	  if (OLC_ROOM(dsc)->exits[j])
	    if (OLC_ROOM(dsc)->exits[j]->to_room >= room_num)
	      OLC_ROOM(dsc)->exits[j]->to_room++;
    
d317 1
a317 1
  
d327 1
a327 1
      
d331 1
a331 1
      
d336 4
a339 4
	      room->name ? room->name : "undefined", buf1,
	      zone_table[room->zone].number,
	      room->room_flags[0], room->sector_type);
      
d344 21
a364 21
	if (room->exits[counter2]) {
	  int temp_door_flag;
	  
	  /*
	   * Again, strip out the garbage.
	   */
	  if (room->exits[counter2]->general_description) {
	    strcpy(buf1, room->exits[counter2]->general_description);
	    strip_string(buf1);
	  } else
	    *buf1 = 0;
	  
	  /*
	   * Figure out door flag. 
	   */
	  if (IS_SET(room->exits[counter2]->exit_info, EX_ISDOOR)) {
	    if (IS_SET(room->exits[counter2]->exit_info, EX_PICKPROOF))
	      temp_door_flag = 2;
	    else
	      temp_door_flag = 1;
	  } else if (IS_SET(room->exits[counter2]->exit_info, EX_DESCRIPT)) {
d366 1
a366 1
            world[room->exits[counter2]->to_room].number = -1;
d369 2
a370 2
	    temp_door_flag = 0;
	  
d372 14
a385 14
	   * Check for keywords.
	   */
	  if (room->exits[counter2]->keyword)
	    strcpy(buf2, room->exits[counter2]->keyword);
	  else
	    *buf2 = '\0';
	  
	  /*
	   * Ok, now wrote output to file.
	   */
	  fprintf(fp, "D%d\n%s~\n%s~\n%d %d %d\n", counter2, buf1, buf2,
		  temp_door_flag, room->exits[counter2]->key,
		  world[room->exits[counter2]->to_room].number);
	}
d391 5
a395 5
	for (ex_desc = room->ex_description; ex_desc; ex_desc = ex_desc->next) {
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n%s~\n%s~\n", ex_desc->keyword, buf1);
	}
d410 1
a410 1
  
d417 1
a417 1
{ 
d420 1
a420 1
  
d425 1
a425 1
  
d432 1
a432 1
	free(room->exits[i]->general_description);
d438 1
a438 1
  
d462 1
a462 1
  
d465 1
a465 1
	  ".[H.[J"
d467 9
a475 9
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: ",
	  
	  grn, nrm, yel, extra_desc->keyword ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, extra_desc->description ? extra_desc->description : "<NONE>",
	  grn, nrm
	  );
  
d509 1
a509 1
	  ".[H.[J"
d511 15
a525 15
	  "%s1%s) Exit to     : %s%d\r\n"
	  "%s2%s) Description :-\r\n%s%s\r\n"
	  "%s3%s) Door name   : %s%s\r\n"
	  "%s4%s) Key         : %s%d\r\n"
	  "%s5%s) Door flags  : %s%s\r\n"
	  "%s6%s) Purge exit.\r\n"
	  "Enter choice, 0 to quit : ",
	  
	  grn, nrm, cyn, world[OLC_EXIT(d)->to_room].number,
	  grn, nrm, yel, OLC_EXIT(d)->general_description ? OLC_EXIT(d)->general_description : "<NONE>",
	  grn, nrm, yel, OLC_EXIT(d)->keyword ? OLC_EXIT(d)->keyword : "<NONE>",
	  grn, nrm, cyn, OLC_EXIT(d)->key,
	  grn, nrm, cyn, buf2, grn, nrm
	  );
  
d537 4
a540 4
	  "%s1%s) Closeable door\r\n"
	  "%s2%s) Pickproof\r\n"
	  "%s3%s) Description\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
d547 1
a547 1
#define FLAG_INDEX	((NUM_ROOM_FLAGS / columns + 1) * j + i)
d552 1
a552 1
  
d565 1
a565 1
  }  
d569 1
a569 1
	  "Enter room flags, 0 to quit : ", cyn, buf1, nrm);
d578 1
a578 1
#define TYPE_INDEX	((NUM_ROOM_SECTORS / columns + 1) * j + i)
d583 1
a583 1
  
d608 1
a608 1
  
d611 1
a611 1
  
d616 1
a616 1
	  ".[H.[J"
d618 38
a655 38
	  "-- Room number : [%s%d%s]  	Room zone: [%s%d%s]\r\n"
	  "%s1%s) Name        : %s%s\r\n"
	  "%s2%s) Description :\r\n%s%s"
	  "%s3%s) Room flags  : %s%s\r\n"
	  "%s4%s) Sector type : %s%s\r\n"
	  "%s5%s) Exit north  : %s%d\r\n"
	  "%s6%s) Exit east   : %s%d\r\n"
	  "%s7%s) Exit south  : %s%d\r\n"
	  "%s8%s) Exit west   : %s%d\r\n"
	  "%s9%s) Exit up     : %s%d\r\n"
	  "%sA%s) Exit down   : %s%d\r\n"
	  "%sF%s) Extra descriptions menu\r\n"
	  "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",
	  
	  cyn, OLC_NUM(d), nrm,
	  cyn, zone_table[OLC_ZNUM(d)].number, nrm,
	  grn, nrm, yel, room->name,
	  grn, nrm, yel, room->description,
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2,
	  grn, nrm, cyn, room->exits[NORTH] ?
	  world[room->exits[NORTH]->to_room].number : -1,
	  grn, nrm, cyn, room->exits[EAST] ?
	  world[room->exits[EAST]->to_room].number : -1,
	  grn, nrm, cyn, room->exits[SOUTH] ?
	  world[room->exits[SOUTH]->to_room].number : -1,
	  grn, nrm, cyn, room->exits[WEST] ?
	  world[room->exits[WEST]->to_room].number : -1,
	  grn, nrm, cyn, room->exits[UP] ?
	  world[room->exits[UP]->to_room].number : -1,
	  grn, nrm, cyn, room->exits[DOWN] ?
	  world[room->exits[DOWN]->to_room].number : -1,
	  grn, nrm, 
	  grn, nrm, cyn, room->proto_script?"Set.":"Not Set.",
	  grn, nrm
	  );
d657 1
a657 1
  
d670 1
a670 1
  
d680 1
a680 1
       * Do NOT free strings! Just the room structure. 
d695 1
a695 1
    
d701 2
a702 2
	send_to_char("Do you wish to save this room internally? : ", d->character);
	OLC_MODE(d) = REDIT_CONFIRM_SAVESTRING;
d760 1
a760 1
      
d765 2
a766 2
	CREATE(OLC_ROOM(d)->ex_description, struct extra_descr_data, 1);
	OLC_ROOM(d)->ex_description->next = NULL;
d782 2
a783 2
    
    
d800 1
a800 1
    
d814 1
a814 1
      
d817 1
a817 1
    
d827 1
a827 1
    
d856 1
a856 1
	free(OLC_EXIT(d)->keyword);
d858 1
a858 1
	free(OLC_EXIT(d)->general_description);
d860 1
a860 1
	free(OLC_EXIT(d));
d868 1
a868 1
    
d870 1
a870 1
    if ((number = atoi(arg)) != -1) 
d872 2
a873 2
	send_to_char("That room does not exist, try again : ", d->character);
	return;
d878 1
a878 1
    
d883 1
a883 1
    
d890 1
a890 1
    
d895 1
a895 1
    
d906 1
a906 1
	OLC_EXIT(d)->exit_info = EX_ISDOOR;
d908 1
a908 1
	OLC_EXIT(d)->exit_info = EX_ISDOOR | EX_PICKPROOF;
d910 1
a910 1
	OLC_EXIT(d)->exit_info = EX_DESCRIPT;
d912 1
a912 1
	OLC_EXIT(d)->exit_info = 0;
d916 2
a917 2
				(number == 1 ? EX_ISDOOR :
				 (number == 2 ? EX_ISDOOR | EX_PICKPROOF : 
d925 1
a925 1
    
d930 1
a930 1
    
d935 23
a957 23
	/*
	 * If something got left out, delete the extra description
	 * when backing out to the menu.
	 */
	if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	  struct extra_descr_data **tmp_desc;
	  
	  if (OLC_DESC(d)->keyword)
	    free(OLC_DESC(d)->keyword);
	  if (OLC_DESC(d)->description)
	    free(OLC_DESC(d)->description);
	  
	  /*
	   * Clean up pointers.
	   */
	  for (tmp_desc = &(OLC_ROOM(d)->ex_description); *tmp_desc;
	       tmp_desc = &((*tmp_desc)->next))
	    if (*tmp_desc == OLC_DESC(d)) {
	      *tmp_desc = NULL;
	      break;
	    }
	  free(OLC_DESC(d));
	}
d969 1
a969 1
      
d972 2
a973 2
	send_to_char("You can't edit the next extra desc without completing this one.\r\n", d->character);
	redit_disp_extradesc_menu(d);
d975 11
a985 11
	struct extra_descr_data *new_extra;
	
	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {
	  /* make new extra, attach at end */
	  CREATE(new_extra, struct extra_descr_data, 1);
	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = new_extra;
	}
	redit_disp_extradesc_menu(d);
d990 1
a990 1
    
d1003 3
d1076 1
a1076 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.22
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.21 2008/03/28 17:54:53 myc Exp myc $
d27 1
d57 1
a57 1
#define  W_EXIT(room, num) (world[(room)].dir_option[(num)])
d98 2
a99 2
    if (world[real_num].dir_option[counter]) {
      CREATE(room->dir_option[counter], struct room_direction_data, 1);
d103 1
a103 1
      *room->dir_option[counter] = *world[real_num].dir_option[counter];
d107 3
a109 3
      room->dir_option[counter]->general_description =
	(world[real_num].dir_option[counter]->general_description ?
	 strdup(world[real_num].dir_option[counter]->general_description)
d111 3
a113 3
      room->dir_option[counter]->keyword =
	(world[real_num].dir_option[counter]->keyword ?
	 strdup(world[real_num].dir_option[counter]->keyword) : NULL);
d300 3
a302 3
	  if (OLC_ROOM(dsc)->dir_option[j])
	    if (OLC_ROOM(dsc)->dir_option[j]->to_room >= room_num)
	      OLC_ROOM(dsc)->dir_option[j]->to_room++;
d344 1
a344 1
	if (room->dir_option[counter2]) {
d350 2
a351 2
	  if (room->dir_option[counter2]->general_description) {
	    strcpy(buf1, room->dir_option[counter2]->general_description);
d359 2
a360 2
	  if (IS_SET(room->dir_option[counter2]->exit_info, EX_ISDOOR)) {
	    if (IS_SET(room->dir_option[counter2]->exit_info, EX_PICKPROOF))
d364 1
a364 1
	  } else if (IS_SET(room->dir_option[counter2]->exit_info, EX_DESCRIPT)) {
d366 2
a367 2
            world[room->dir_option[counter2]->to_room].number = -1;
            room->dir_option[counter2]->key = -1;
d374 2
a375 2
	  if (room->dir_option[counter2]->keyword)
	    strcpy(buf2, room->dir_option[counter2]->keyword);
d383 2
a384 2
		  temp_door_flag, room->dir_option[counter2]->key,
		  world[room->dir_option[counter2]->to_room].number);
d430 6
a435 6
    if (room->dir_option[i]) {
      if (room->dir_option[i]->general_description)
	free(room->dir_option[i]->general_description);
      if (room->dir_option[i]->keyword)
        free(room->dir_option[i]->keyword);
      free(room->dir_option[i]);
d488 1
a488 1
   * if exit doesn't exist, alloc/create it 
d491 1
a491 2
    CREATE(OLC_EXIT(d), struct room_direction_data, 1);
    OLC_EXIT(d)->key = -1;    
d494 1
a494 1
  *buf2 = '\0';  
d640 12
a651 12
	  grn, nrm, cyn, room->dir_option[NORTH] ?
	  world[room->dir_option[NORTH]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[EAST] ?
	  world[room->dir_option[EAST]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[SOUTH] ?
	  world[room->dir_option[SOUTH]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[WEST] ?
	  world[room->dir_option[WEST]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[UP] ?
	  world[room->dir_option[UP]->to_room].number : -1,
	  grn, nrm, cyn, room->dir_option[DOWN] ?
	  world[room->dir_option[DOWN]->to_room].number : -1,
d1003 3
@


1.21
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.20 2008/03/22 03:22:38 myc Exp myc $
d713 1
a713 1
      SEND_TO_Q("\x1B[H\x1B[J", d);
d715 1
a715 1
      SEND_TO_Q("Enter room description: (/s saves /h for help)\r\n\r\n", d);
d838 1
a838 1
      SEND_TO_Q("Enter exit description: (/s saves /h for help)\r\n\r\n", d);
d966 1
a966 1
      SEND_TO_Q("Enter extra description: (/s saves /h for help)\r\n\r\n", d);
d1003 4
@


1.20
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.19 2008/03/17 16:22:42 myc Exp myc $
d67 2
a68 2
  OLC_ROOM(d)->name = str_dup("An unfinished room");
  OLC_ROOM(d)->description = str_dup("You are in an unfinished room.\r\n");
d90 2
a91 2
  room->name = str_dup(world[real_num].name ? world[real_num].name : "undefined");
  room->description = str_dup(world[real_num].description ?
d108 1
a108 1
	 str_dup(world[real_num].dir_option[counter]->general_description)
d112 1
a112 1
	 str_dup(world[real_num].dir_option[counter]->keyword) : NULL);
d125 2
a126 2
      temp->keyword = (this->keyword ? str_dup(this->keyword) : NULL);
      temp->description = (this->description ? str_dup(this->description) : NULL);
d334 1
a334 1
      fprintf(fp, "#%d\n%s~\n%s~\n%d %d %d\n", counter,
d337 1
a337 1
	      room->room_flags, room->sector_type);
d567 1
a567 1
  sprintbit(OLC_ROOM(d)->room_flags, room_bits, buf1);
d612 1
a612 1
  sprintbit((long)room->room_flags, room_bits, buf1);
d792 1
a792 1
    OLC_ROOM(d)->name = str_dup((arg && *arg) ? arg : "undefined");
d812 1
a812 1
      TOGGLE_BIT(OLC_ROOM(d)->room_flags, 1 << (number - 1));
d887 1
a887 1
    OLC_EXIT(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
d927 1
a927 1
    OLC_DESC(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
d1003 6
@


1.19
log
@Fixed handling of proto scripts in OLC, which was causing a crash.
Also fixed some memory leaks associated with scripts and OLC.
How this got by for so long, I don't know.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.18 2008/02/09 04:27:47 myc Exp myc $
d716 1
a716 8
      d->backstr = NULL;
      if (OLC_ROOM(d)->description) {
	SEND_TO_Q(OLC_ROOM(d)->description, d);
	d->backstr = str_dup(OLC_ROOM(d)->description);
      }
      d->str = &OLC_ROOM(d)->description;
      d->max_str = MAX_ROOM_DESC;
      d->mail_to = 0;
d839 1
a839 8
      d->backstr = NULL;
      if (OLC_EXIT(d)->general_description) {
	SEND_TO_Q(OLC_EXIT(d)->general_description, d);
	d->backstr = str_dup(OLC_EXIT(d)->general_description);
      }
      d->str = &OLC_EXIT(d)->general_description;
      d->max_str = MAX_EXIT_DESC;
      d->mail_to = 0;
d967 1
a967 8
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
d1003 5
@


1.18
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.17 2008/01/29 21:02:31 myc Exp myc $
a77 1
  struct trig_proto_list *proto, *fproto;
a90 2
  if (world[real_num].description)
    room->description = str_dup(world[real_num].description);
a135 12
  if (SCRIPT(&world[real_num]))
    script_copy(room, &world[real_num], WLD_TRIGGER);
  proto = world[real_num].proto_script;
  while (proto) {
    CREATE(fproto, struct trig_proto_list, 1);
    fproto->vnum = proto->vnum;
    if (room->proto_script==NULL)
      room->proto_script = fproto;
    proto = proto->next;
    fproto = fproto->next; /* NULL */
  }
  
d164 5
d170 1
d172 1
d180 1
a180 1
      if (SCRIPT(&world[i]))
d182 2
a303 1
  assign_triggers(&world[room_num], WLD_TRIGGER);
d434 1
a435 1
    free(room->dir_option[i]);
a780 2
      OLC_SCRIPT(d) = OLC_ROOM(d)->proto_script;
      OLC_ROOM(d)->proto_script=(struct trig_proto_list *)NULL;
d1024 3
@


1.17
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.16 2007/11/18 16:51:55 myc Exp myc $
d26 1
d1033 4
@


1.16
log
@Fixing LVL_BUILDER references.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.15 2007/09/15 05:03:46 myc Exp myc $
d25 1
a29 8
extern int      top_of_world;
extern struct room_data *world;
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;
extern char *room_bits[];
extern char *sector_types[];
extern char *exit_bits[];
extern struct zone_data *zone_table;
a35 2
extern int top_of_zone_table;
extern struct descriptor_data *descriptor_list;
d1032 3
@


1.15
log
@Implemented a new loop method for some of the menus so that items in
the menus get listed column-major instead of by rows.  This applies to
the sector and flag menus.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.14 2007/08/04 01:24:37 myc Exp myc $
d291 1
a291 1
	  mudlog(buf, BRF, LVL_BUILDER, TRUE);
d334 1
a334 1
    mudlog("SYSERR: OLC: Cannot open room file!", BRF, LVL_BUILDER, TRUE);
d693 1
a693 1
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
d822 1
a822 1
    mudlog("SYSERR: Reached REDIT_DESC case in parse_redit", BRF, LVL_BUILDER, TRUE);
d912 1
a912 1
    mudlog("SYSERR: Reached REDIT_EXIT_DESC case in parse_redit",BRF, LVL_BUILDER, TRUE);
d1031 1
a1031 1
    mudlog("SYSERR: Reached default case in parse_redit",BRF, LVL_BUILDER, TRUE);
d1041 5
@


1.14
log
@When saving a new room in redit, all room triggers in the world are now
dropped and reloaded (all trigger execution thus stops).  Although
inconvenient, this is a necessary evil in order to prevent event-related
crashes.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.13 2007/08/03 22:00:11 myc Exp myc $
d562 1
d565 2
a566 1
  int counter, columns = 0;
d572 10
a581 5
  for (counter = 0; counter < NUM_ROOM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
	    room_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
d588 1
d593 1
d596 2
a597 1
  int counter, columns = 0;
d602 8
a609 4
  for (counter = 0; counter < NUM_ROOM_SECTORS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
	    sector_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d611 2
a612 1
  send_to_char("\r\nEnter sector type : ", d->character);
d615 1
d844 1
a844 1
    if (number < 0 || number >= NUM_ROOM_SECTORS) {
d848 2
a849 2
    } else 
      OLC_ROOM(d)->sector_type = number;
d1041 6
@


1.13
log
@Fixed some \r\n typoes in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.12 2007/07/15 21:16:12 myc Exp myc $
d190 9
d200 1
a200 1
    
d265 4
d1025 3
@


1.12
log
@No more crash when you edit a script on a new object or room.
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.11 2002/09/13 02:32:10 jjl Exp myc $
d772 1
a772 1
      send_to_char("Invalid choice!", d->character);
d816 1
a816 1
      send_to_char("Invalid choice!", d->character);
d1012 3
@


1.11
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: redit.c,v 1.10 2001/03/13 00:45:27 dce Exp $
d74 1
d1012 3
@


1.10
log
@Keys default to -1 as requested by builders.
@
text
@d1 3
a3 1
// $Id: redit.c,v 1.9 2000/11/24 21:17:12 rsd Exp $
d1009 41
a1049 36
// $Log: redit.c,v $
// Revision 1.9  2000/11/24 21:17:12  rsd
// Altered comment header and added back rlog messgaes from
// prior to the addition of the $log$ string.
//
// Revision 1.8  2000/11/18 20:59:23  jimmy
// Added sane debug to redit_save_internally
//
// Revision 1.7  2000/11/18 06:57:20  rsd
// changed the comment header and tried to add some
// sensible debug to redit_save_internal.
//
// Revision 1.6  2000/10/14 11:12:40  mtp
// fixed the olc triggers editting in medit/oedit/redit
//
// Revision 1.5  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.4  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.3  1999/04/07 01:20:18  dce
// Allows extra descriptions on no exits.
//
// Revision 1.2  1999/02/01 04:26:53  mud
// Indented file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.9
log
@Altered comment header and added back rlog messgaes from
prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: redit.c,v 1.8 2000/11/18 20:59:23 jimmy Exp $
d488 1
a488 1
  if (!OLC_EXIT(d))
d490 2
d1008 4
@


1.8
log
@Added sane debug to redit_save_internally
@
text
@d1 1
a1 1
// $Id: redit.c,v 1.7 2000/11/18 06:57:20 rsd Exp $
d4 1
a4 1
 *  Usage: OASIS OLC -                                                     *
d1006 3
d1018 18
@


1.7
log
@changed the comment header and tried to add some
sensible debug to redit_save_internal.
@
text
@d1 1
a1 1
// $Id: redit.c,v 1.6 2000/10/14 11:12:40 mtp Exp $
d272 2
a273 2
	  sprintf(buf,"SYSERR: OLC: redit_save_internally: Unknown command: %d in zone %d", 
		  ZCMD.command, zone);
d275 1
a275 1
	  mudlog("SYSERR: OLC: redit_save_internally: Unknown comand", BRF, LVL_BUILDER, TRUE);
d1006 4
@


1.6
log
@fixed the olc triggers editting in medit/oedit/redit
@
text
@d1 10
a10 6
// $Id: redit.c,v 1.5 1999/09/05 07:00:39 jimmy Exp $
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
 *    				                                          *
 *  OasisOLC - redit.c 		                                          *
 *    				                                          *
d12 1
a12 2
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*. Original author: Levork .*/
d272 3
d1006 3
@


1.5
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d756 2
d999 4
a1002 1
// $Log$
@


1.4
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1 1
d997 1
@


1.3
log
@Allows extra descriptions on no exits.
@
text
@a642 1
  extern struct room_data *world;
@


1.2
log
@Indented file
@
text
@a102 1
      
d355 5
a359 1
	  } else
d483 2
a484 1
  
d486 2
d490 1
a490 1
      strcpy(buf2, "Pickproof");
d492 1
a492 1
      strcpy(buf2, "Is a door");
d494 2
a495 2
    strcpy(buf2, "No door");
  
d529 2
a530 1
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
d859 1
a859 1
    if ((number = atoi(arg)) != -1)
d864 1
a864 1
    OLC_EXIT(d)->to_room = number;
d887 1
a887 1
    if ((number < 0) || (number > 2)) {
d894 11
a904 1
      OLC_EXIT(d)->exit_info = (number == 0 ? 0 :
d906 2
a907 1
				 (number == 2 ? EX_ISDOOR | EX_PICKPROOF : 0)));
@


1.1
log
@Initial revision
@
text
@d2 5
a6 5
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - redit.c 		                                          *
*    				                                          *
*  Copyright 1996 Harvey Gilpin.                                          *
d67 1
a67 1

d87 1
a87 1

d96 1
a96 1
			world[real_num].description : "undefined\r\n");
d103 1
a103 1

d112 3
a114 3
		(world[real_num].dir_option[counter]->general_description ?
		str_dup(world[real_num].dir_option[counter]->general_description)
		: NULL);
d116 2
a117 2
		(world[real_num].dir_option[counter]->keyword ?
		str_dup(world[real_num].dir_option[counter]->keyword) : NULL);
d120 1
a120 1
 
d127 1
a127 1

d140 1
a140 1
 
d152 1
a152 1

d172 1
a172 1

d182 1
a182 1
	world[room_num].proto_script = OLC_SCRIPT(d);
d185 2
a186 2

	/*
d201 1
a201 1

d206 1
a206 1

d213 1
a213 1

d220 1
a220 1
        } else {		/* Already been found. */
d233 1
a233 1

d241 1
a241 1
	  new_world[i].proto_script = OLC_SCRIPT(d);
d244 1
a244 1

d249 1
a249 1

d253 1
a253 1
   switch (ZCMD.command) {
d278 1
a278 1

d285 1
a285 1
	/*
d294 1
a294 1

d309 1
a309 1

d319 1
a319 1

d323 1
a323 1

d331 1
a331 1

d338 1
a338 1

d347 1
a347 1

d357 2
a358 2
	      temp_door_flag = 0;

d366 1
a366 1

d386 1
a386 1
	  script_save_to_disk(fp, room, WLD_TRIGGER);
d398 1
a398 1

d408 1
a408 1

d413 1
a413 1

d426 2
a427 2

    /*
d441 1
a441 1
 Menu functions 
d450 1
a450 1

d458 1
a458 1

d463 1
a463 1

d480 1
a480 1

d489 1
a489 1

d491 1
a491 1
   sprintf(buf,
d502 1
a502 1

d509 1
a509 1

d520 1
a520 1
    sprintf(buf, "%s0%s) No door\r\n"
d533 1
a533 1

d535 1
a535 1
  #if defined(CLEAR_SCREEN)
d537 1
a537 1
  #endif
d540 1
a540 1
		room_bits[counter], !(++columns % 2) ? "\r\n" : "");
d544 1
a544 1
   sprintf(buf, "\r\nRoom flags: %s%s%s\r\n"
d556 2
a557 2

  #if defined(CLEAR_SCREEN)
d559 1
a559 1
  #endif
d561 2
a562 2
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		sector_types[counter], !(++columns % 2) ? "\r\n" : "");
d575 1
a575 1

d578 1
a578 1

d600 1
a600 1

d620 2
a621 2
      grn, nrm, cyn, room->proto_script?"Set.":"Not Set.",
      grn, nrm
d624 1
a624 1

d631 1
a631 1
  The main loop
d638 1
a638 1

d663 1
a663 1

d668 1
a668 1
     if (OLC_VAL(d)) { /* Something has been modified. */
d735 1
a735 1

d746 1
a746 1
	case 's':
d757 2
a758 2

	
d766 1
a766 1
       arg[MAX_ROOM_NAME - 1] = '\0';
d775 1
a775 1

d782 1
a782 1
	break;
d789 1
a789 1
    
d792 1
a792 1

d802 1
a802 1

d813 1
a813 1
       SEND_TO_Q("Enter exit description: (/s saves /h for help)\r\n\r\n", d);
d850 1
a850 1

d852 1
a852 1
   if ((number = atoi(arg)) != -1)
d860 1
a860 1

d865 1
a865 1

d869 1
a869 1
   OLC_EXIT(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
d872 1
a872 1

d877 1
a877 1

d884 1
a884 1
     /*
d889 1
a889 1
				(number == 2 ? EX_ISDOOR | EX_PICKPROOF : 0)));
d896 1
a896 1

d901 1
a901 1

d905 2
a906 2
     {
/*
d912 1
a912 1

d917 2
a918 2

	/*
d937 1
a937 1
	 SEND_TO_Q("Enter extra description: (/s saves /h for help)\r\n\r\n", d);
d947 1
a947 1

d954 1
a954 1

d968 1
a968 1

@
