head	1.32;
access;
symbols;
locks; strict;
comment	@ * @;


1.32
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.24.19.29.11;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.20.05.03.13;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.09.23.00.13;	author myc;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.12.02.50.25;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.11.05.52.25;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.10.16.19.50;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.26.23.36.32;	author myc;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.13.01.42.18;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.06.19.48.52;	author jps;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.05.18.06.53;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.05.03.46.10;	author jps;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.29.16.26.57;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.27.00.21.07;	author jps;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.26.22.57.53;	author jps;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.26.18.11.36;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.25.21.59.57;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.25.05.30.41;	author jps;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.24.08.43.29;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.23.19.46.29;	author jps;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.23.18.41.20;	author jps;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.23.00.25.57;	author jps;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.22.20.26.37;	author jps;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.22.19.57.28;	author jps;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.22.19.10.10;	author jps;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.11.02.56.32;	author jps;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.27.09.39.47;	author jps;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.05.22.01.22;	author jps;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.05.21.53.39;	author jps;	state Exp;
branches;
next	;


desc
@Character (mob/player) header file.
@


1.32
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@/***************************************************************************
 *  File: chars.h                                         Part of FieryMUD *
 *  Usage: header file for character structures and constants              *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#ifndef __FIERY_CHARS_H
#define __FIERY_CHARS_H

#define NUM_CLASSES 25

/* Indexing of stats */
#define STAT_STR  0
#define STAT_DEX  1
#define STAT_CON  2
#define STAT_WIS  3
#define STAT_INT  4
#define STAT_CHA  5
#define NUM_STATS 6  /* Update this if adding a stat */

/* Saving throws */
#define SAVING_PARA   0
#define SAVING_ROD    1
#define SAVING_PETRI  2
#define SAVING_BREATH 3
#define SAVING_SPELL  4
#define NUM_SAVES     5

/* Extreme values for stats */
#define MIN_AC        (-100)
#define MAX_AC        100
#define MIN_DAMROLL   (-40)
#define MIN_HITROLL   (-40)
#define MAX_DAMROLL   40
#define MAX_HITROLL   40
#define MIN_ALIGNMENT (-1000)
#define MAX_ALIGNMENT (1000)

extern int class_ok_race[][NUM_CLASSES];
extern const char *stats_display;

extern int get_base_saves(struct char_data *ch, int type);
extern void roll_natural_abils(struct char_data *ch);
extern int roll_mob_skill(int level);
extern int roll_skill(struct char_data *ch, int skill);

extern struct obj_data *equipped_weapon(struct char_data *ch);
/* Whether you evade a simple yes-or-no attack, like sleep or word of command */
extern bool boolean_attack_evasion(struct char_data *ch, int power, int dtype);
extern int dam_suscept_adjust(struct char_data *ch, struct char_data *victim,
      struct obj_data *weapon, int dam, int dtype);
extern bool damage_evasion(struct char_data *ch, struct char_data *attacker,
      struct obj_data *weapon, int dtype);
#define EVASIONCLR "&6"

#define DAMVERB1(ch) (damtypes[COMPOSITION_DAM(ch)].verb1st)
#define DAMVERB2(ch) (damtypes[COMPOSITION_DAM(ch)].verb2nd)

#define SOLIDCHAR(ch) (RIGID(ch) && !MOB_FLAGGED((ch), MOB_ILLUSORY))

extern void composition_check(struct char_data *ch);
extern int susceptibility(struct char_data *ch, int dtype);
extern const char *align_color(int align);
extern void critical_stance_message(struct char_data *ch);
extern void alter_pos(struct char_data *ch, int newpos, int newstance);
extern void hp_pos_check(struct char_data *ch, struct char_data *attacker, int dam);

#endif

/***************************************************************************
 * $Log: chars.h,v $
 * Revision 1.31  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.30  2008/08/24 19:29:11  jps
 * Apply damage susceptibility reductions to the various physical attack skills.
 *
 * Revision 1.29  2008/08/20 05:03:13  jps
 * Removed the damage type 'magic'.
 *
 * Revision 1.28  2008/06/09 23:00:13  myc
 * Added 'extern' to all the function declarations.
 *
 * Revision 1.27  2008/05/12 02:50:25  jps
 * Add VALID_DAMTYPE
 *
 * Revision 1.26  2008/05/11 05:52:25  jps
 * Added some function prototypes.
 *
 * Revision 1.25  2008/05/10 16:19:50  jps
 * Made EVASIONCLR globally available.
 *
 * Revision 1.24  2008/04/26 23:36:32  myc
 * Added align_color function.
 *
 * Revision 1.23  2008/04/13 01:42:18  jps
 * Adding composition_check() function.
 *
 * Revision 1.22  2008/04/06 19:48:52  jps
 * Add an adjective to compositions.
 *
 * Revision 1.21  2008/04/05 18:06:53  jps
 * Add an action word to damtypes.
 *
 * Revision 1.20  2008/04/05 03:46:10  jps
 * Add a "mass noun" string to composition definitions.
 *
 * Revision 1.19  2008/03/29 16:26:57  jps
 * Add an evasion check exclusively for non-damaging attack spells.
 *
 * Revision 1.18  2008/03/27 00:21:07  jps
 * Add some verbs to damage types.
 *
 * Revision 1.17  2008/03/26 22:57:53  jps
 * Add a rigid field to compositions.
 *
 * Revision 1.16  2008/03/26 18:11:36  jps
 * Passing attacker and weapon into damage_evasion() so that when you
 * attack an ethereal mob with a blessed weapon (or self), it will
 * be vulnerable.
 *
 * Revision 1.15  2008/03/25 21:59:57  jps
 * Removing earth and air damage. Added shock, cold, and mental. Changed
 * iron composition to mental. Added lava and plant.
 * Added a default damage depending on composition.
 *
 * Revision 1.14  2008/03/25 05:30:41  jps
 * Adding weapon_damtype(), equipped_weapon(), and physical_damtype() functions.
 *
 * Revision 1.13  2008/03/24 08:43:29  jps
 * Adding prototypes for damage_evasion(), skill_to_dtype(), and
 * damage_evasion_message().
 *
 * Revision 1.12  2008/03/23 19:46:29  jps
 * Added compositions stone and bone.
 *
 * Revision 1.11  2008/03/23 18:41:20  jps
 * New damage defines (old ones in spells.h are now obsolete). Added damage
 * susceptibilities to struct lifedef and struct compdef.
 *
 * Revision 1.10  2008/03/23 00:25:57  jps
 * Add base composition so it can be temporarily changed with an apply.
 *
 * Revision 1.9  2008/03/22 20:26:37  jps
 * Add functions to convert life force and composition.
 * Rename ethereal to ether - compositions should be nouns.
 *
 * Revision 1.8  2008/03/22 19:57:28  jps
 * Added some macros for lifeforce and compositions.
 *
 * Revision 1.7  2008/03/22 19:10:10  jps
 * Added lists of lifeforce and composition definitions.
 *
 * Revision 1.6  2008/03/11 02:56:32  jps
 * Add size-releated defs and functions.
 *
 * Revision 1.5  2008/01/27 09:39:47  jps
 * Added "Layman" class as the default, unskilled class for mobiles.
 * I did it because the old default class, "Nothin", occupied the -1
 * index position in an array. -1-indexed arrays????? No!
 *
 * Revision 1.4  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.3  2008/01/25 21:05:45  myc
 * Removed the barehand_mult and backstab_mult functions.  This
 * functionality is contained within the hit function now.  Besides,
 * barehand_mult was poorly named, as it isn't multiplied, but rather
 * added.
 *
 * Revision 1.2  2008/01/05 22:01:22  jps
 * Add stat indices
 *
 ***************************************************************************/
@


1.31
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@a52 64
#define SIZE_UNDEFINED  -1
#define SIZE_TINY        0
#define SIZE_SMALL       1
#define SIZE_MEDIUM      2
#define SIZE_LARGE       3
#define SIZE_HUGE        4
#define SIZE_GIANT       5
#define SIZE_GARGANTUAN  6
#define SIZE_COLOSSAL    7
#define SIZE_TITANIC     8
#define SIZE_MOUNTAINOUS 9
#define NUM_SIZES 10
struct sizedef {
   char *name;
   char *color;
   int weight_min;
   int weight_max;
   int height_min;
   int height_max;
};
extern struct sizedef sizes[];
extern int parse_size(struct char_data *ch, char *arg);

/* When adding a damage type, keep in mind that the susceptibility may vary
 * by composition and/or life force.  Consider adding a field to one or
 * both of those structs.
 *
 * Also add a case statement to the susceptibility() function.
 * The default vulnerability for any damage type is 100.
 */
#define DAM_UNDEFINED       -1
#define DAM_SLASH            0
#define DAM_PIERCE           1
#define DAM_CRUSH            2
#define DAM_SHOCK            3
#define DAM_FIRE             4
#define DAM_WATER            5
#define DAM_COLD             6
#define DAM_ACID             7
#define DAM_POISON           8
#define DAM_HEAL             9
#define DAM_ALIGN           10
#define DAM_DISPEL          11
#define DAM_DISCORPORATE    12
#define DAM_MENTAL          13
#define NUM_DAMTYPES        14  /* keep updated */
struct damdef {
   char *name;
   char *color;
   char *verb1st;
   char *verb2nd;
   char *action;
};

#define VALID_DAMTYPE(d) (d >= 0 && d < NUM_DAMTYPES)

extern struct damdef damtypes[];
extern int parse_damtype(struct char_data *ch, char *arg);
extern bool damage_evasion(struct char_data *ch, struct char_data *attacker,
      struct obj_data *weapon, int dtype);
extern int skill_to_dtype(int skill);
extern void damage_evasion_message(struct char_data *ch, struct char_data *vict,
      struct obj_data *weapon, int dtype);
extern int weapon_damtype(struct obj_data *obj);
a53 1
extern int physical_damtype(struct char_data *ch);
d58 2
a61 90

#define LIFE_UNDEFINED      -1
#define LIFE_LIFE            0 /* normal folks */
#define LIFE_UNDEAD          1
#define LIFE_MAGIC           2 /* golems */
#define LIFE_CELESTIAL       3 /* angels */
#define LIFE_DEMONIC         4
#define LIFE_ELEMENTAL       5
#define NUM_LIFEFORCES       6 /* keep updated */

/* This struct exists so that additional attributes may be added to
 * each lifedef in the future.  At the same time, having an array
 * of structs will allow parse_lifeforce() to simply call parse_obj_name(). */
struct lifedef {
   char *name;
   char *color;
   int sus_heal;
   int sus_discorporate;
   int sus_dispel;
   int sus_mental;
};
extern struct lifedef lifeforces[];
extern int parse_lifeforce(struct char_data *ch, char *arg);
extern void convert_lifeforce(struct char_data *ch, int newlifeforce);
#define VALID_LIFEFORCENUM(num) ((num) >= 0 && (num) < NUM_LIFEFORCES)
#define VALID_LIFEFORCE(ch) (VALID_LIFEFORCENUM(GET_LIFEFORCE(ch)))
#define LIFEFORCE_NAME(ch) (VALID_LIFEFORCE(ch) ? \
      lifeforces[GET_LIFEFORCE(ch)].name : "<INVALID LIFEFORCE>")
#define LIFEFORCE_COLOR(ch) (VALID_LIFEFORCE(ch) ? \
      lifeforces[GET_LIFEFORCE(ch)].color : "")

#define COMP_UNDEFINED      -1
#define COMP_FLESH           0
#define COMP_EARTH           1
#define COMP_AIR             2
#define COMP_FIRE            3
#define COMP_WATER           4
#define COMP_ICE             5
#define COMP_MIST            6
#define COMP_ETHER           7   /* Having no physical incorporation: nil */
#define COMP_METAL           8
#define COMP_STONE           9  /* Like earth, but tougher */
#define COMP_BONE           10  /* Like flesh, but... */
#define COMP_LAVA           11
#define COMP_PLANT          12
#define NUM_COMPOSITIONS    13 /* keep updated */

/* This struct exists so that additional attributes may be added to
 * each compdef in the future.  At the same time, having an array
 * of structs will allow parse_composition() to simply call parse_obj_name(). */
struct compdef {
   char *name;
   char *massnoun;
   char *adjective;
   char *color;
   int default_dtype;
   bool rigid;  /* Helps determine whether physical attacks will "pass through" or "bounce off" */
   int sus_slash;
   int sus_pierce;
   int sus_crush;
   int sus_shock;
   int sus_fire;
   int sus_water;
   int sus_cold;
   int sus_acid;
   int sus_poison;
};
extern struct compdef compositions[];
extern int parse_composition(struct char_data *ch, char *arg);
extern void convert_composition(struct char_data *ch, int newcomposition);
extern void set_base_composition(struct char_data *ch, int newcomposition);
extern void list_olc_compositions(struct char_data *ch);
extern void composition_check(struct char_data *ch);
#define BASE_COMPOSITION(ch) ((ch)->player.base_composition)
#define VALID_COMPOSITIONNUM(num) ((num) >= 0 && (num) < NUM_COMPOSITIONS)
#define VALID_COMPOSITION(ch) (VALID_COMPOSITIONNUM(GET_COMPOSITION(ch)))
#define COMPOSITION_NAME(ch) (VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].name : "<INVALID COMPOSITION>")
#define COMPOSITION_MASS(ch) (VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].massnoun : "<INVALID COMPOSITION>")
#define COMPOSITION_COLOR(ch) (MOB_FLAGGED((ch), MOB_ILLUSORY) ? \
      "&5" : VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].color : "")
#define COMPOSITION_DAM(ch) (VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].default_dtype : DAM_CRUSH)
#define COMPOSITION_ADJECTIVE(ch) (MOB_FLAGGED((ch), MOB_ILLUSORY) ? \
      "illusory" : VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].adjective : "existential")
#define RIGID(ch) (VALID_COMPOSITION(ch) ? \
      compositions[GET_COMPOSITION(ch)].rigid : TRUE)
a64 9
#define GET_SIZE(ch) ((ch)->player.affected_size)
#define VALID_SIZENUM(num) ((num) >= 0 && (num) < NUM_SIZES)
#define VALID_SIZE(ch) (VALID_SIZENUM(GET_SIZE(ch)))
#define SIZENAME(i) (sizes[i].name)
#define SIZE_DESC(ch) \
   (VALID_SIZE(ch) ? sizes[GET_SIZE(ch)].name : "<INVALID SIZE>")
#define SIZE_COLOR(ch) \
   (VALID_SIZE(ch) ? sizes[GET_SIZE(ch)].color : "")

d67 1
a67 6
extern void reset_height_weight(struct char_data *ch);
extern void set_base_size(struct char_data *ch, int newsize);
extern void change_natural_size(struct char_data *ch, int newsize);
extern void adjust_size(struct char_data *ch, int delta);
extern void show_sizes(struct char_data *ch);

d78 6
@


1.30
log
@Apply damage susceptibility reductions to the various physical attack skills.
@
text
@d35 10
d245 3
@


1.29
log
@Removed the damage type 'magic'.
@
text
@d104 2
a105 1
extern void damage_evasion_message(struct char_data *ch, struct char_data *vict, struct obj_data *weapon, int dtype);
d111 2
d235 3
@


1.28
log
@Added 'extern' to all the function declarations.
@
text
@d83 6
a88 7
#define DAM_MAGIC            9
#define DAM_HEAL            10
#define DAM_ALIGN           11
#define DAM_DISPEL          12
#define DAM_DISCORPORATE    13
#define DAM_MENTAL          14
#define NUM_DAMTYPES        15  /* keep updated */
a177 1
   int sus_magic;
d232 3
@


1.27
log
@Add VALID_DAMTYPE
@
text
@d38 4
a41 4
int get_base_saves(struct char_data *ch, int type);
void roll_natural_abils(struct char_data *ch);
int roll_mob_skill(int level);
int roll_skill(struct char_data *ch, int skill);
d64 1
a64 1
int parse_size(struct char_data *ch, char *arg);
d101 2
a102 2
int parse_damtype(struct char_data *ch, char *arg);
bool damage_evasion(struct char_data *ch, struct char_data *attacker,
d104 5
a108 5
int skill_to_dtype(int skill);
void damage_evasion_message(struct char_data *ch, struct char_data *vict, struct obj_data *weapon, int dtype);
int weapon_damtype(struct obj_data *obj);
struct obj_data *equipped_weapon(struct char_data *ch);
int physical_damtype(struct char_data *ch);
d110 1
a110 1
bool boolean_attack_evasion(struct char_data *ch, int power, int dtype);
d135 2
a136 2
int parse_lifeforce(struct char_data *ch, char *arg);
void convert_lifeforce(struct char_data *ch, int newlifeforce);
d182 5
a186 5
int parse_composition(struct char_data *ch, char *arg);
void convert_composition(struct char_data *ch, int newcomposition);
void set_base_composition(struct char_data *ch, int newcomposition);
void list_olc_compositions(struct char_data *ch);
void composition_check(struct char_data *ch);
d218 11
a228 11
void reset_height_weight(struct char_data *ch);
void set_base_size(struct char_data *ch, int newsize);
void change_natural_size(struct char_data *ch, int newsize);
void adjust_size(struct char_data *ch, int delta);
void show_sizes(struct char_data *ch);

int susceptibility(struct char_data *ch, int dtype);
const char *align_color(int align);
void critical_stance_message(struct char_data *ch);
void alter_pos(struct char_data *ch, int newpos, int newstance);
void hp_pos_check(struct char_data *ch, struct char_data *attacker, int dam);
d234 3
@


1.26
log
@Added some function prototypes.
@
text
@d97 3
d234 3
@


1.25
log
@Made EVASIONCLR globally available.
@
text
@d223 3
d231 3
@


1.24
log
@Added align_color function.
@
text
@d108 2
d228 3
@


1.23
log
@Adding composition_check() function.
@
text
@d220 1
a220 1

d226 3
@


1.22
log
@Add an adjective to compositions.
@
text
@d181 1
d226 3
@


1.21
log
@Add an action word to damtypes.
@
text
@d161 1
d188 2
a189 1
#define COMPOSITION_COLOR(ch) (VALID_COMPOSITION(ch) ? \
d193 3
d210 2
d225 3
@


1.20
log
@Add a "mass noun" string to composition definitions.
@
text
@d95 1
d218 3
@


1.19
log
@Add an evasion check exclusively for non-damaging attack spells.
@
text
@d159 1
d184 2
d217 3
@


1.18
log
@Add some verbs to damage types.
@
text
@d105 2
d214 3
@


1.17
log
@Add a rigid field to compositions.
@
text
@d93 2
d187 2
d212 3
@


1.16
log
@Passing attacker and weapon into damage_evasion() so that when you
attack an ethereal mob with a blessed weapon (or self), it will
be vulnerable.
@
text
@d157 1
d183 2
d208 5
@


1.15
log
@Removing earth and air damage. Added shock, cold, and mental. Changed
iron composition to mental. Added lava and plant.
Added a default damage depending on composition.
@
text
@d96 2
a97 1
bool damage_evasion(struct char_data *ch, int dtype);
d205 5
@


1.14
log
@Adding weapon_damtype(), equipped_weapon(), and physical_damtype() functions.
@
text
@d77 4
a80 4
#define DAM_EARTH            3
#define DAM_AIR              4
#define DAM_FIRE             5
#define DAM_WATER            6
d88 2
a89 1
#define NUM_DAMTYPES        14  /* keep updated */
d121 1
d142 1
a142 1
#define COMP_IRON            8
d145 3
a147 1
#define NUM_COMPOSITIONS    11 /* keep updated */
d155 1
d159 1
a159 2
   int sus_earth;
   int sus_air;
d162 1
d179 2
d204 3
@


1.13
log
@Adding prototypes for damage_evasion(), skill_to_dtype(), and
damage_evasion_message().
@
text
@d98 3
d197 4
@


1.12
log
@Added compositions stone and bone.
@
text
@d95 3
d194 3
@


1.11
log
@New damage defines (old ones in spells.h are now obsolete). Added damage
susceptibilities to struct lifedef and struct compdef.
@
text
@d135 3
a137 1
#define NUM_COMPOSITIONS     9 /* keep updated */
d191 4
@


1.10
log
@Add base composition so it can be temporarily changed with an apply.
@
text
@d66 30
d111 3
d143 10
d182 2
d189 3
@


1.9
log
@Add functions to convert life force and composition.
Rename ethereal to ether - compositions should be nouns.
@
text
@d114 3
d144 4
@


1.8
log
@Added some macros for lifeforce and compositions.
@
text
@d84 1
d100 1
a100 1
#define COMP_ETHEREAL        7   /* Having no physical incorporation: nil */
d113 1
d141 3
@


1.7
log
@Added lists of lifeforce and composition definitions.
@
text
@d64 1
d67 1
a67 1
#define LIFE_LIFE            0
d69 2
a70 2
#define LIFE_MAGIC           2
#define LIFE_CELESTIAL       3
d74 4
d80 1
d83 7
d102 4
d108 1
d111 7
a127 1
int parse_size(struct char_data *ch, char *arg);
d139 3
@


1.6
log
@Add size-releated defs and functions.
@
text
@d65 29
d115 3
@


1.5
log
@Added "Layman" class as the default, unskilled class for mobiles.
I did it because the old default class, "Nothin", occupied the -1
index position in an array. -1-indexed arrays????? No!
@
text
@d43 39
d86 5
@


1.4
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d16 1
a16 1
#define NUM_CLASSES 24
d47 3
@


1.3
log
@Removed the barehand_mult and backstab_mult functions.  This
functionality is contained within the hit function now.  Besides,
barehand_mult was poorly named, as it isn't multiplied, but rather
added.
@
text
@d16 1
a16 1
#include "class.h"
a34 1

d47 6
@


1.2
log
@Add stat indices
@
text
@a42 2
int barehand_mult(int level);
int backstab_mult(int level);
d48 3
@


1.1
log
@Initial revision
@
text
@d18 9
d48 3
@
