head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.09.03.25.36;	author jps;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.20.04.25.18;	author rsd;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.02.02.37.19;	author rsd;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: act.social.c                                  Part of CircleMUD *
*  Usage: Functions to handle socials                                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"

/* extern variables */
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct room_data *world;

/* extern functions */
char *fread_action(FILE * fl, int nr);

/* local globals */
static int list_top = -1;

struct social_messg {
  int act_nr;
  int hide;
  int min_victim_position;	/* Position of victim */

  /* No argument was supplied */
  char *char_no_arg;
  char *others_no_arg;

  /* An argument was there, and a victim was found */
  char *char_found;		/* if NULL, read no further, ignore args */
  char *others_found;
  char *vict_found;

  /* An argument was there, but no victim was found */
  char *not_found;

  /* The victim turned out to be the character */
  char *char_auto;
  char *others_auto;
}           *soc_mess_list = NULL;



int find_action(int cmd)
{
  int bot, top, mid;

  bot = 0;
  top = list_top;

  if (top < 0)
    return (-1);

  for (;;) {
    mid = (bot + top) >> 1;

    if (soc_mess_list[mid].act_nr == cmd)
      return (mid);
    if (bot >= top)
      return (-1);

    if (soc_mess_list[mid].act_nr > cmd)
      top = --mid;
    else
      bot = ++mid;
  }
}



ACMD(do_action)
{
  int act_nr;
  struct social_messg *action;
  struct char_data *vict;

  if ((act_nr = find_action(cmd)) < 0) {
    send_to_char("That action is not supported.\r\n", ch);
    return;
  }
  action = &soc_mess_list[act_nr];

  if (action->char_found)
    one_argument(argument, buf);
  else
    *buf = '\0';

  if (!*buf) {
    send_to_char(action->char_no_arg, ch);
    send_to_char("\r\n", ch);
    act(action->others_no_arg, action->hide, ch, 0, 0, TO_ROOM);
    return;
  }
  if (!(vict = get_char_room_vis(ch, buf))) {
    send_to_char(action->not_found, ch);
    send_to_char("\r\n", ch);
  } else if (vict == ch) {
    send_to_char(action->char_auto, ch);
    send_to_char("\r\n", ch);
    act(action->others_auto, action->hide, ch, 0, 0, TO_ROOM);
  } else {
    if (GET_POS(vict) < action->min_victim_position)
      act("$N is not in a proper position for that.",
	  FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else {
      act(action->char_found, 0, ch, 0, vict, TO_CHAR | TO_SLEEP);
      act(action->others_found, action->hide, ch, 0, vict, TO_NOTVICT);
      act(action->vict_found, action->hide, ch, 0, vict, TO_VICT);
    }
  }
}



ACMD(do_insult)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (*arg) {
    if (!(victim = get_char_room_vis(ch, arg)))
      send_to_char("Can't hear you!\r\n", ch);
    else {
      if (victim != ch) {
	sprintf(buf, "You insult %s.\r\n", GET_NAME(victim));
	send_to_char(buf, ch);

	switch (number(0, 2)) {
	case 0:
	  if (GET_SEX(ch) == SEX_MALE) {
	    if (GET_SEX(victim) == SEX_MALE)
	      act("$n accuses you of fighting like a woman!", FALSE, ch, 0, victim, TO_VICT);
	    else
	      act("$n says that women can't fight.", FALSE, ch, 0, victim, TO_VICT);
	  } else {		/* Ch == Woman */
	    if (GET_SEX(victim) == SEX_MALE)
	      act("$n accuses you of having the smallest... (brain?)",
		  FALSE, ch, 0, victim, TO_VICT);
	    else
	      act("$n tells you that you'd lose a beauty contest against a troll.",
		  FALSE, ch, 0, victim, TO_VICT);
	  }
	  break;
	case 1:
	  act("$n calls your mother a bitch!", FALSE, ch, 0, victim, TO_VICT);
	  break;
	default:
	  act("$n tells you to get lost!", FALSE, ch, 0, victim, TO_VICT);
	  break;
	}			/* end switch */

	act("$n insults $N.", TRUE, ch, 0, victim, TO_NOTVICT);
      } else {			/* ch == victim */
	send_to_char("You feel insulted.\r\n", ch);
      }
    }
  } else
    send_to_char("I'm sure you don't want to insult *everybody*...\r\n", ch);
}


char *fread_action(FILE * fl, int nr)
{
  char buf[MAX_STRING_LENGTH], *rslt;

  fgets(buf, MAX_STRING_LENGTH, fl);
  if (feof(fl)) {
    fprintf(stderr, "fread_action - unexpected EOF near action #%d", nr);
    exit(1);
  }
  if (*buf == '#')
    return (NULL);
  else {
    *(buf + strlen(buf) - 1) = '\0';
    CREATE(rslt, char, strlen(buf) + 1);
    strcpy(rslt, buf);
    return (rslt);
  }
}


void boot_social_messages(void)
{
  FILE *fl;
  int nr, i, hide, min_pos, curr_soc = -1;
  char next_soc[100];
  struct social_messg temp;
  extern struct command_info cmd_info[];

  /* open social file */
  if (!(fl = fopen(SOCMESS_FILE, "r"))) {
    sprintf(buf, "Can't open socials file '%s'", SOCMESS_FILE);
    perror(buf);
    exit(1);
  }
  /* count socials & allocate space */
  for (nr = 0; *cmd_info[nr].command != '\n'; nr++)
    if (cmd_info[nr].command_pointer == do_action)
      list_top++;

  CREATE(soc_mess_list, struct social_messg, list_top + 1);

  /* now read 'em */
  for (;;) {
    fscanf(fl, " %s ", next_soc);
    if (*next_soc == '$')
      break;
    if ((nr = find_command(next_soc)) < 0) {
      sprintf(buf, "Unknown social '%s' in social file", next_soc);
      log(buf);
    }
    if (fscanf(fl, " %d %d \n", &hide, &min_pos) != 2) {
      fprintf(stderr, "Format error in social file near social '%s'\n",
	      next_soc);
      exit(1);
    }
    /* read the stuff */
    curr_soc++;
    soc_mess_list[curr_soc].act_nr = nr;
    soc_mess_list[curr_soc].hide = hide;
    soc_mess_list[curr_soc].min_victim_position = min_pos;

    soc_mess_list[curr_soc].char_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_found = fread_action(fl, nr);

    /* if no char_found, the rest is to be ignored */
    if (!soc_mess_list[curr_soc].char_found)
      continue;

    soc_mess_list[curr_soc].others_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].vict_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].not_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_auto = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_auto = fread_action(fl, nr);
  }

  /* close file & set top */
  fclose(fl);
  list_top = curr_soc;

  /* now, sort 'em */
  for (curr_soc = 0; curr_soc < list_top; curr_soc++) {
    min_pos = curr_soc;
    for (i = curr_soc + 1; i <= list_top; i++)
      if (soc_mess_list[i].act_nr < soc_mess_list[min_pos].act_nr)
	min_pos = i;
    if (curr_soc != min_pos) {
      temp = soc_mess_list[curr_soc];
      soc_mess_list[curr_soc] = soc_mess_list[min_pos];
      soc_mess_list[min_pos] = temp;
    }
  }
}
@


1.13
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: act.social.c,v 1.12 2009/03/09 03:25:36 jps Exp $
 ***************************************************************************/
/**************************************************************************
*   File: act.social.c                                   Part of FieryMUD *
*  Usage: Functions to handle socials                                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
*  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
*  of the Johns Hopkins University                                        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "math.h"

/* extern variables */

/* extern functions */
char *fread_action(FILE * fl, int nr);

/* local globals */
static int list_top = -1;

/* gawd this is a hack, someone please fix it! */
#define MAX_SOCIALS 200

struct social_messg {
  int act_nr;
  int hide;
  int min_victim_position;	/* Position of victim */

  /* No argument was supplied */
  char *char_no_arg;
  char *others_no_arg;

  /* An argument was there, and a victim was found */
  char *char_found;		/* if NULL, read no further, ignore args */
  char *others_found;
  char *vict_found;

  /* An argument was there, but no victim was found */
  char *not_found;

  /* The victim turned out to be the character */
  char *char_auto;
  char *others_auto;
} *soc_mess_list[MAX_SOCIALS];



int find_action(int cmd)
{
  int bot, top, mid;

  bot = 0;
  top = list_top;

  if (top < 0)
    return (-1);

  for (;;) {
    mid = (bot + top) >> 1;

    if (soc_mess_list[mid]->act_nr == cmd)
      return (mid);
    if (bot >= top)
      return (-1);

    if (soc_mess_list[mid]->act_nr > cmd)
      top = --mid;
    else
      bot = ++mid;
  }
}



ACMD(do_action)
{
  int act_nr;
  struct social_messg *action;
  struct char_data *vict;

  if ((act_nr = find_action(cmd)) < 0) {
    send_to_char("That action is not supported.\r\n", ch);
    return;
  }
  action = soc_mess_list[act_nr];

  if (action->char_found)
    one_argument(argument, buf);
  else
    *buf = '\0';

  if (!*buf) {
    send_to_char(action->char_no_arg, ch);
    send_to_char("\r\n", ch);
    act(action->others_no_arg, action->hide, ch, 0, 0, TO_ROOM);
    return;
  }
  if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, buf)))) {
    send_to_char(action->not_found, ch);
    send_to_char("\r\n", ch);
  } else if (vict == ch) {
    send_to_char(action->char_auto, ch);
    send_to_char("\r\n", ch);
    act(action->others_auto, action->hide, ch, 0, 0, TO_ROOM);
  } else {
    if (GET_POS(vict) < action->min_victim_position)
      act("$N is not in a proper position for that.",
	  FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else {
      act(action->char_found, 0, ch, 0, vict, TO_CHAR | TO_SLEEP);
      act(action->others_found, action->hide, ch, 0, vict, TO_NOTVICT);
      act(action->vict_found, action->hide, ch, 0, vict, TO_VICT);
    }
  }
}



ACMD(do_insult)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (*arg) {
    if (!(victim = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))))
      send_to_char("Can't hear you!\r\n", ch);
    else {
      if (victim != ch) {
	sprintf(buf, "You insult %s.\r\n", GET_NAME(victim));
	send_to_char(buf, ch);

	switch (number(0, 2)) {
	case 0:
	  if (GET_SEX(ch) == SEX_MALE) {
	    if (GET_SEX(victim) == SEX_MALE)
	      act("$n accuses you of fighting like a woman!", FALSE, ch, 0, victim, TO_VICT);
	    else
	      act("$n says that women can't fight.", FALSE, ch, 0, victim, TO_VICT);
	  } else {		/* Ch == Woman */
	    if (GET_SEX(victim) == SEX_MALE)
	      act("$n accuses you of having the smallest... (brain?)",
		  FALSE, ch, 0, victim, TO_VICT);
	    else
	      act("$n tells you that you'd lose a beauty contest against a troll.",
		  FALSE, ch, 0, victim, TO_VICT);
	  }
	  break;
	case 1:
	  act("$n calls your mother a bitch!", FALSE, ch, 0, victim, TO_VICT);
	  break;
	default:
	  act("$n tells you to get lost!", FALSE, ch, 0, victim, TO_VICT);
	  break;
	}			/* end switch */

	act("$n insults $N.", TRUE, ch, 0, victim, TO_NOTVICT);
      } else {			/* ch == victim */
	send_to_char("You feel insulted.\r\n", ch);
      }
    }
  } else
    send_to_char("I'm sure you don't want to insult *everybody*...\r\n", ch);
}


char *fread_action(FILE * fl, int nr)
{
  char buf[MAX_STRING_LENGTH], *rslt;

  fgets(buf, MAX_STRING_LENGTH, fl);
  if (feof(fl)) {
    fprintf(stderr, "fread_action - unexpected EOF near action #%d", nr);
    exit(1);
  }
  if (*buf == '#')
    return (NULL);
  else {
    *(buf + strlen(buf) - 1) = '\0';
    CREATE(rslt, char, strlen(buf) + 1);
    strcpy(rslt, buf);
    return (rslt);
  }
}


void boot_social_messages(void)
{
  FILE *fl;
  int nr, i, hide, min_pos, curr_soc = -1;
  char next_soc[100];
  struct social_messg *temp;

  /* open social file */
  if (!(fl = fopen(SOCMESS_FILE, "r"))) {
    sprintf(buf, "Can't open socials file '%s'", SOCMESS_FILE);
    perror(buf);
    exit(1);
  }
  /* count socials & allocate space */
  for (nr = 0; *cmd_info[nr].command != '\n'; nr++)
    if (cmd_info[nr].command_pointer == do_action) {
      list_top++;
    }

  /* now read 'em */
  for (;;) {
    fscanf(fl, " %s ", next_soc);
    if (*next_soc == '$')
      break;
    if ((nr = find_command(next_soc)) < 0) {
      sprintf(buf, "Unknown social '%s' in social file", next_soc);
      log("%s",buf);
    }
    if (fscanf(fl, " %d %d \n", &hide, &min_pos) != 2) {
      fprintf(stderr, "Format error in social file near social '%s'\n",
	      next_soc);
      exit(1);
    }
    /* read the stuff */
    curr_soc++;
    CREATE(soc_mess_list[curr_soc], struct social_messg, 1);
    soc_mess_list[curr_soc]->act_nr = nr;
    soc_mess_list[curr_soc]->hide = hide;
    soc_mess_list[curr_soc]->min_victim_position = min_pos;

    soc_mess_list[curr_soc]->char_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc]->others_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc]->char_found = fread_action(fl, nr);

    /* if no char_found, the rest is to be ignored */
    if (!soc_mess_list[curr_soc]->char_found)
      continue;

    soc_mess_list[curr_soc]->others_found = fread_action(fl, nr);
    soc_mess_list[curr_soc]->vict_found = fread_action(fl, nr);
    soc_mess_list[curr_soc]->not_found = fread_action(fl, nr);
    soc_mess_list[curr_soc]->char_auto = fread_action(fl, nr);
    soc_mess_list[curr_soc]->others_auto = fread_action(fl, nr);
  }

  /* close file & set top */
  fclose(fl);
  list_top = curr_soc;

  /* now, sort 'em */
  for (curr_soc = 0; curr_soc < list_top; curr_soc++) {
    min_pos = curr_soc;
    for (i = curr_soc + 1; i <= list_top; i++)
      if (soc_mess_list[i]->act_nr < soc_mess_list[min_pos]->act_nr)
	min_pos = i;
    if (curr_soc != min_pos) {
      temp = soc_mess_list[curr_soc];
      soc_mess_list[curr_soc] = soc_mess_list[min_pos];
      soc_mess_list[min_pos] = temp;
    }
  }
}

void free_action(struct social_messg *mess)  {
  if (mess->char_no_arg) free(mess->char_no_arg);
  if (mess->others_no_arg) free(mess->others_no_arg);
  if (mess->char_found) free(mess->char_found);
  if (mess->others_found) free(mess->others_found);
  if (mess->vict_found) free(mess->vict_found);
  if (mess->not_found) free(mess->not_found);
  if (mess->char_auto) free(mess->char_auto);
  if (mess->others_auto) free(mess->others_auto);
  memset(mess, 0, sizeof(struct social_messg));
}

void free_social_messages() {
  struct social_messg *mess;
  int i;

  for (i = 0; i <= list_top; i++)  {
    mess = soc_mess_list[i];
    free_action(mess);
    free(mess);
  }
}


/***************************************************************************
 * $Log: act.social.c,v $
 * Revision 1.12  2009/03/09 03:25:36  jps
 * Remove inclusion of casting.h
 *
 * Revision 1.11  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.10  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.9  2008/02/16 20:26:04  myc
 * Adding functions to free socials at program termination.
 *
 * Revision 1.8  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.7  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.6  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.5  2000/11/20 04:25:18  rsd
 * added back rlog messages from prior to the addition of
 * the $log$ string.
 *
 * Revision 1.4  2000/04/02 02:37:19  rsd
 * changed the comment header while I was browsing the file for
 * information.
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most significant
 * changes were moving all the BREATH's to within normal spell range, and
 * fixing the way socials were allocated.  Too many small fixes to list them
 * all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.12
log
@Remove inclusion of casting.h
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.11 2009/03/08 23:34:14 jps Exp jps $
d227 1
a227 1
      log(buf);
d300 3
@


1.11
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.10 2009/03/03 19:41:50 myc Exp jps $
a24 1
#include "casting.h"
d300 3
@


1.10
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.9 2008/02/16 20:26:04 myc Exp myc $
d25 1
a25 1
#include "spells.h"
d301 3
@


1.9
log
@Adding functions to free socials at program termination.
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.8 2008/02/09 04:27:47 myc Exp myc $
d113 1
a113 1
  if (!(vict = get_char_room_vis(ch, buf))) {
d141 1
a141 1
    if (!(victim = get_char_room_vis(ch, arg)))
d301 3
@


1.8
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.7 2008/01/29 21:02:31 myc Exp myc $
d274 25
d301 3
@


1.7
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.6 2002/09/13 02:32:10 jjl Exp myc $
d26 1
d276 4
@


1.6
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.social.c,v 1.5 2000/11/20 04:25:18 rsd Exp $
a27 3
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct room_data *world;
a206 1
  extern struct command_info cmd_info[];
d275 3
@


1.5
log
@added back rlog messages from prior to the addition of
the $log$ string.
@
text
@d1 3
a3 1
// $Id: act.social.c,v 1.4 2000/04/02 02:37:19 rsd Exp $
d277 24
a300 18
// $Log: act.social.c,v $
// Revision 1.4  2000/04/02 02:37:19  rsd
// changed the comment header while I was browsing the file for
// information.
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most significant
// changes were moving all the BREATH's to within normal spell range, and
// fixing the way socials were allocated.  Too many small fixes to list them
// all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.4
log
@changed the comment header while I was browsing the file for
information.
@
text
@d1 1
a1 1
// $Id: act.social.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d276 4
d282 10
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 3
a3 3
// $Id$
/* ************************************************************************
*   File: act.social.c                                  Part of CircleMUD *
d8 3
a10 1
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
************************************************************************ */
a16 1

d275 4
a278 1
// $Log$
@


1.2
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d1 1
d274 1
@


1.1
log
@Initial revision
@
text
@d34 3
d57 1
a57 1
}           *soc_mess_list = NULL;
d74 1
a74 1
    if (soc_mess_list[mid].act_nr == cmd)
d79 1
a79 1
    if (soc_mess_list[mid].act_nr > cmd)
d98 1
a98 1
  action = &soc_mess_list[act_nr];
d205 1
a205 1
  struct social_messg temp;
d216 1
a216 1
    if (cmd_info[nr].command_pointer == do_action)
d218 1
a218 2

  CREATE(soc_mess_list, struct social_messg, list_top + 1);
d236 8
a243 7
    soc_mess_list[curr_soc].act_nr = nr;
    soc_mess_list[curr_soc].hide = hide;
    soc_mess_list[curr_soc].min_victim_position = min_pos;

    soc_mess_list[curr_soc].char_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_found = fread_action(fl, nr);
d246 1
a246 1
    if (!soc_mess_list[curr_soc].char_found)
d249 5
a253 5
    soc_mess_list[curr_soc].others_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].vict_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].not_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_auto = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_auto = fread_action(fl, nr);
d264 1
a264 1
      if (soc_mess_list[i].act_nr < soc_mess_list[min_pos].act_nr)
@
