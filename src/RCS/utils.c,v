head	1.130;
access;
symbols;
locks; strict;
comment	@ * @;


1.130
date	2010.06.20.19.53.47;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.10.02.27.14;	author myc;	state Exp;
branches;
next	1.128;

1.128
date	2009.06.09.05.51.26;	author myc;	state Exp;
branches;
next	1.127;

1.127
date	2009.03.09.05.51.25;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.125;

1.125
date	2009.03.09.03.33.03;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.09.25.04.47.49;	author jps;	state Exp;
branches;
next	1.118;

1.118
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.117;

1.117
date	2008.09.21.21.21.29;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2008.09.07.20.06.13;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2008.09.07.18.45.15;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2008.08.31.04.17.55;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2008.08.30.04.13.45;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.16.21.33.01;	author jps;	state Exp;
branches;
next	1.107;

1.107
date	2008.08.14.23.10.35;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.08.03.21.32.32;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.21.17.26.33;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2008.04.19.21.11.22;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2008.04.02.19.31.02;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.29.21.14.37;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2008.03.29.17.34.55;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.03.26.22.22.56;	author jps;	state Exp;
branches;
next	1.91;

1.91
date	2008.03.26.16.44.36;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.23.00.25.23;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2008.03.22.21.24.25;	author jps;	state Exp;
branches;
next	1.88;

1.88
date	2008.03.22.19.50.24;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.22.19.08.58;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.21.21.59.31;	author jps;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.21.21.36.02;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.11.02.57.16;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2008.03.10.20.49.47;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.08.18.55.20;	author jps;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.77;

1.77
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.09.03.06.17;	author myc;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.27.12.11.45;	author jps;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.25.21.11.52;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.15.03.18.19;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.09.08.34.36;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.03.12.46.20;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2007.12.25.20.31.54;	author jps;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.25.20.28.57;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.25.05.49.58;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.20.03.04.11;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.19.20.57.58;	author myc;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.22.23.33.23;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.11.20.35.06;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.21.01.20.19;	author myc;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.03.22.53.54;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.04.14.40.35;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.19.21.59.20;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.14.04.18.11;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.02.04.40.05;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.02.04.22.32;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.24.02.51.44;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.29.00.36.03;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.11.19.34.15;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.18.00.05.59;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.04.13.31.02;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.26.08.31.17;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.18.09.08.15;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.18.07.22.34;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.13.02.48.27;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.11.16.13.08;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.08.09.16.40;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.08.05.29.11;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.07.18.02.05;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.20.07.39.31;	author cjd;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.04.02.11.30;	author jjl;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.02.17.42.50;	author jjl;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.01.07.27.54;	author jjl;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.13.01.07.34;	author dce;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.23.04.05.43;	author dce;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.25.02.33.15;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.22.22.44.10;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	99.09.16.01.15.11;	author dce;	state Exp;
branches;
next	1.18;

1.18
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.17;

1.17
date	99.09.04.18.46.52;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.08.14.02.43.10;	author dce;	state Exp;
branches;
next	1.15;

1.15
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.14;

1.14
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.06.14.21.41.16;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.06.11.17.18.40;	author jimmy;	state Exp;
branches;
next	1.11;

1.11
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	99.05.04.17.19.33;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.05.02.20.29.30;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	99.05.02.20.25.51;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	99.04.21.04.05.04;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.04.08.03.59.20;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.03.25.20.18.18;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.06.02.06.21;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.03.21.03.25;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.08.20.33;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.32;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: utils.c                                       Part of CircleMUD *
*  Usage: various internal functions of a utility nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "screen.h"
#include "spells.h"
#include "handler.h"
#include "weather.h"
#include "db.h"

extern struct time_data time_info;
extern struct char_data *character_list;
extern struct room_data *world;
extern struct str_app_type str_app[];

  /* this is just a rough layout of the exp needed for a ch
     to level. recommend you change the modifier, and also
     the 4000 to something that suits you better.        */

double fexp[10] = {7.5, 8.0, 8.4, 8.8, 9.2,
                  9.7, 10.2, 10.7, 11.3, 12.0};
long exp_to_level(level, class)
{
long exp = 0;
int xfactor = 100;

if (level <= 0)
return exp;

if (level < 30)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((160.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 40)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((190.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 45)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((195.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 50)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((200.0 + (level - 5.0)) /level))) + (long)(level) * 12000);
else if (level < 64)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((270.0 + (level - 5.0)) /level))) + (long)(level) * 13000);
else if (level < 100) {
exp = (long) ((level+21) * 1000000);
/* exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* (fexp[level - 61])) + (long)(level) * 10000); */
} else
exp = (long) ((level+21) * 1000000);
/*
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* (15.0)) + (long)(level) * 10000);
*/

/*class exp converter*/
/*make sure you dont set anything past 300 for the xfactor*/
   switch (class)
   {
   case CLASS_MAGIC_USER:
	   xfactor = 110;
	   break;
   case CLASS_NECROMANCER:
	   xfactor = 115;
	   break;
   case CLASS_RANGER:
	   xfactor = 105;
	   break;
   case CLASS_WARRIOR:
        xfactor = 105;
            break;
   default:
	   xfactor = 100;
	   break;
   }
   if (level >= 50)
       xfactor = 130;
  if (level >= 51)
       xfactor = 140;
  if (level >= 52)
       xfactor = 195;
  if (level >= 99)
       xfactor = 240;
   if (level >= 100)
	   xfactor = 300;

   exp = (long) ((double)(xfactor/100.0) * (double)exp);


    return exp;
  }


int exp_group_bonus(int inexp)
{/*small function to offer bonus from grouping*/
	return (int)((130*inexp)/100);
}

int exp_highlevel_bonus(int inexp, int lvldiff)
{/*small function to offer those who kill higher levels more returns*/

	return (int)(((100 + ((int)(lvldiff*1.5))) * inexp)/100);
}


/* creates a random number in interval [from;to] */
int number(int from, int to)
{
  /* error checking in case people call number() incorrectly */
  if (from > to) {
    int tmp = from;
    from = to;
    to = tmp;
  }

  return ((random() % (to - from + 1)) + from);
}


/* simulates dice roll */
int dice(int number, int size)
{
  int sum = 0;

  if (size <= 0 || number <= 0)
    return 0;

  while (number-- > 0)
    sum += ((random() % size) + 1);

  return sum;
}


int MIN(int a, int b)
{
  return a < b ? a : b;
}


int MAX(int a, int b)
{
  return a > b ? a : b;
}



/* Create a duplicate of a string */
char *str_dup(const char *source)
{
  char *new;

  CREATE(new, char, strlen(source) + 1);
  return (strcpy(new, source));
}



/* str_cmp: a case-insensitive version of strcmp */
/* returns: 0 if equal, 1 if arg1 > arg2, -1 if arg1 < arg2  */
/* scan 'till found different or end of both                 */
int str_cmp(char *arg1, char *arg2)
{
  int chk, i;

  for (i = 0; *(arg1 + i) || *(arg2 + i); i++)
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i))))
      if (chk < 0)
	return (-1);
      else
	return (1);
  return (0);
}


/* strn_cmp: a case-insensitive version of strncmp */
/* returns: 0 if equal, 1 if arg1 > arg2, -1 if arg1 < arg2  */
/* scan 'till found different, end of both, or n reached     */
int strn_cmp(char *arg1, char *arg2, int n)
{
  int chk, i;

  for (i = 0; (*(arg1 + i) || *(arg2 + i)) && (n > 0); i++, n--)
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i))))
      if (chk < 0)
	return (-1);
      else
	return (1);

  return (0);
}


/* log a death trap hit */
void log_death_trap(struct char_data * ch)
{
  char buf[150];
  extern struct room_data *world;

  sprintf(buf, "%s hit death trap #%d (%s)", GET_NAME(ch),
	  world[ch->in_room].number, world[ch->in_room].name);
  mudlog(buf, BRF, LVL_IMMORT, TRUE);
}


/* writes a string to the log */
void log(char *str)
{
  time_t ct;
  char *tmstr;

  ct = time(0);
  tmstr = asctime(localtime(&ct));
  *(tmstr + strlen(tmstr) - 1) = '\0';
  fprintf(stderr, "%-19.19s :: %s\n", tmstr, str);
}


/* the "touch" command, essentially. */
int touch(char *path)
{
  FILE *fl;

  if (!(fl = fopen(path, "a"))) {
    perror(path);
    return -1;
  } else {
    fclose(fl);
    return 0;
  }
}


/*
 * mudlog -- log mud messages to a file & to online imm's syslogs
 * based on syslog by Fen Jul 3, 1992
 */
void mudlog(char *str, char type, int level, byte file)
{
  char buf[MAX_STRING_LENGTH];
  extern struct descriptor_data *descriptor_list;
  struct descriptor_data *i;
  char *tmp, tp;
  time_t ct;

  ct = time(0);
  tmp = asctime(localtime(&ct));

  if (file)
    fprintf(stderr, "%-19.19s :: %s\n", tmp, str);
  if (level < 0)
    return;

  sprintf(buf, "[ %s ]\r\n", str);

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING)) {
      tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
	    (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));

      if ((GET_LEVEL(i->character) >= level) && (tp >= type)) {
	send_to_char(CCGRN(i->character, C_NRM), i->character);
	send_to_char(buf, i->character);
	send_to_char(CCNRM(i->character, C_NRM), i->character);
      }
    }
}



void sprintbit(long bitvector, char *names[], char *result)
{
  long nr;

  *result = '\0';

  if (bitvector < 0) {
    strcpy(result, "<INVALID BITVECTOR>");
    return;
  }
  for (nr = 0; bitvector; bitvector >>= 1) {
    if (IS_SET(bitvector, 1)) {
      if (*names[nr] != '\n') {
	strcat(result, names[nr]);
	strcat(result, " ");
      } else
	strcat(result, "UNDEFINED ");
    }
    if (*names[nr] != '\n')
      nr++;
  }

  if (!*result)
    strcpy(result, "NOBITS ");
}

int number_of_groupees(struct char_data *ch)
{/*counts the number of groupees in this persons group and returns it*/
    int tot_members = 0;
    struct char_data *k;
    struct char_data *m;
    struct group_type *f;
    struct mgroup_type *g;
    k = (ch->groupmaster ? ch->groupmaster : ch);
    /*k now is the group master*/

  if (!(IS_AFFECTED(k, AFF_GROUP)))
  {
  		mudlog("In group exp give and leader not grouped?", NRM, LVL_GOD, FALSE);
		return 0;
  }

  if (IS_AFFECTED2(k, AFF2_MGROUP))
  {
	  m = (k->mgroupmaster ? k->mgroupmaster : k);
	  if (m->in_room == ch->in_room)
		    tot_members = 1;/*m now is major group master*/
	  for(f=m->groupees;f;f=f->next)
		    if (f->groupee->in_room == ch->in_room)
		        tot_members++;/*major group masters group*/
	  for (g = m->mgroupees;g;g=g->next)
	  {
		if (g->mgroupee->in_room == ch->in_room)
		    tot_members++;
		    for (f=g->mgroupee->groupees;f;f=f->next)
			    if (f->groupee->in_room == ch->in_room)
			        tot_members++;
	  }
  }
  else
  {/*just group count*/
	  if (k->in_room == ch->in_room)
		tot_members = 1;
	  for(f=k->groupees;f;f=f->next)
		  if (f->groupee->in_room == ch->in_room)
			tot_members++;
  }
    return tot_members;

}

void sprinttype(int type, char *names[], char *result)
{
  int nr = 0;

  while (type && *names[nr] != '\n') {
    type--;
    nr++;
  }

  if (*names[nr] != '\n')
    strcpy(result, names[nr]);
  else
    strcpy(result, "UNDEFINED");
}


/* Calculate the REAL time passed over the last t2-t1 centuries (secs) */
struct time_info_data real_time_passed(time_t t2, time_t t1)
{
  long secs;
  struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_REAL_HOUR) % 24;	/* 0..23 hours */
  secs -= SECS_PER_REAL_HOUR * now.hours;

  now.day = (secs / SECS_PER_REAL_DAY);	/* 0..34 days  */
  secs -= SECS_PER_REAL_DAY * now.day;

  now.month = -1;
  now.year = -1;

  return now;
}



/* Calculate the MUD time passed over the last t2-t1 centuries (secs) */
struct time_info_data mud_time_passed(time_t t2, time_t t1)
{
  long secs;
  struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_MUD_HOUR) % 24;	/* 0..23 hours */
  secs -= SECS_PER_MUD_HOUR * now.hours;

  now.day = (secs / SECS_PER_MUD_DAY) % 35;	/* 0..34 days  */
  secs -= SECS_PER_MUD_DAY * now.day;

  now.month = (secs / SECS_PER_MUD_MONTH) % 17;	/* 0..16 months */
  secs -= SECS_PER_MUD_MONTH * now.month;

  now.year = (secs / SECS_PER_MUD_YEAR);	/* 0..XX? years */

  return now;
}



struct time_info_data age(struct char_data * ch)
{
  struct time_info_data player_age;

  player_age = mud_time_passed(time(0), ch->player.time.birth);

  player_age.year += 17;	/* All players start at 17 */

  return player_age;
}


/* Check if making CH follow VICTIM will create an illegal */
/* Follow "Loop/circle"                                    */
bool circle_follow(struct char_data * ch, struct char_data * victim)
{
  struct char_data *k;

  for (k = victim; k; k = k->master) {
    if (k == ch)
      return TRUE;
  }

  return FALSE;
}



/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  assert(ch->master);

  if (IS_AFFECTED(ch, AFF_CHARM)) {
    act("You realize that $N is a jerk!", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n realizes that $N is a jerk!", FALSE, ch, 0, ch->master, TO_NOTVICT);
    act("$n hates your guts!", FALSE, ch, 0, ch->master, TO_VICT);
    if (affected_by_spell(ch, SPELL_CHARM))
      affect_from_char(ch, SPELL_CHARM);
  } else {
    act("You stop following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n stops following $N.", TRUE, ch, 0, ch->master, TO_NOTVICT);
    act("$n stops following you.", TRUE, ch, 0, ch->master, TO_VICT);
  }

  if (ch->master->followers->follower == ch) {	/* Head of follower-list? */
    k = ch->master->followers;
    ch->master->followers = k->next;
    free(k);
  } else {			/* locate follower who is not head of list */
    for (k = ch->master->followers; k->next->follower != ch; k = k->next);

    j = k->next;
    k->next = j->next;
    free(j);
  }

  ch->master = NULL;
  REMOVE_BIT(AFF_FLAGS(ch), AFF_CHARM);
}



/* Called when a character that follows/is followed dies */
void die_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master)
    stop_follower(ch);

  for (k = ch->followers; k; k = j) {
    j = k->next;
    stop_follower(k->follower);
  }
}

void readlist(struct char_data *ch)
{
	struct group_type *f;
	char buf[100];
	int counter = 0;

		for(f = ch->groupees;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&2&bgroup&0 :conter %d, name %s", counter, GET_NAME(f->groupee));
		act(buf, TRUE, ch, 0, 0, TO_ROOM);
	}
}
void readfoll(struct char_data *ch)
{
	struct follow_type *f;
	char buf[80];
	int counter = 0;

		for(f = ch->followers;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&2&bfollower&0 :conter %d, name %s", counter, GET_NAME(f->follower));
		act(buf, TRUE, ch, 0, 0, TO_ROOM);
	}
}
void readmlist(struct char_data *ch)
{
	struct mgroup_type *f;
	char buf[100];
	int counter = 0;

	for(f = ch->mgroupees;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&1mgroup &0:conter %d, name %s:", counter, GET_NAME(f->mgroupee));
		act(buf, TRUE, ch, 0, 0, TO_ROOM);

	}
}
/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_groupee(struct char_data * ch, bool hide)
{
	void die_mgroupee(struct char_data * ch);
	struct group_type *j, *k;
	char buf[50];
	struct char_data *l;
	int counter = 0;
	bool last_member = 0;
	assert(ch->groupmaster);

	l = ch->groupmaster;
	for(k = l->groupees;k;k=k->next)
		counter++;
	if (counter == 1)
		last_member = 1;
	if (ch->groupmaster->groupees->groupee == ch) {	/* Head of follower-list? */
		k = ch->groupmaster->groupees;
		ch->groupmaster->groupees = k->next;
		if (counter == 1)
			send_to_char("&2&bYour group is disbanded.&0\r\n", ch);
sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(k);
	}
	else
	{			/* locate follower who is not head of list */
		for (k = ch->groupmaster->groupees; k->next->groupee != ch; k = k->next);
		j = k->next;
		k->next = j->next;
		sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(j);
	}
	ch->groupmaster = NULL;
	REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
	if (last_member)
	{
	/*if last member remove his group from mgroup*/
		if ((IS_AFFECTED2(l, AFF2_MGROUP)))
			die_mgroupee(l);
		REMOVE_BIT(AFF_FLAGS(l), AFF_GROUP);
		l->groupees = NULL;
		send_to_char("&0&2&bYour group the disbanded.&0\r\n", l);
	}

}

bool is_grouped(struct char_data *ch, struct char_data *tch)
{
	struct char_data *k;
	struct char_data *l = NULL;
	if (IS_AFFECTED(ch, AFF_GROUP))
	{/*k = casters group leader*/
		k = (ch->groupmaster ? ch->groupmaster : ch);
		if (IS_AFFECTED(tch, AFF_GROUP))
		{
			l = (tch->groupmaster ? tch->groupmaster : tch);
			if (l == k)
{
				return TRUE;/*handles if in same group*/
		}}

		if (IS_AFFECTED2(k, AFF2_MGROUP))
		{/*m = casters his major group master*/
if ((l->mgroupmaster ? l->mgroupmaster : l) == (k->mgroupmaster ? k->mgroupmaster : k))
{
				return TRUE;/*handles if in mgroup*/
}		}
	}

	return FALSE;
}


/* Called when a character that follows/is followed dies */
void die_groupee(struct char_data * ch)
{
 struct mgroup_type *f;
 struct group_type *k;
 struct char_data *l;
 int counter = 0;
 bool was_mgroup_leader = 0;
 bool was_mgroupee = 0;
 void die_mgroupee(struct char_data *ch);
 void add_mgroupee(struct char_data *ch, struct char_data *mgroupleader, bool hide);
 void stop_mgroupee(struct char_data *ch, bool hide);
/*Both major group flags and group flags are handled here in this function*/
/*removal via death or often link loss*/

if (ch->groupmaster)/*If character has a group master pretty simple leaves here*/
{		/*however this does disband group if group less than 1 groupee*/

act("&0&2&b$N is no longer a member of your group.&0", FALSE, ch->groupmaster, 0, ch, TO_CHAR);
act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_VICT);
act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_NOTVICT);

		stop_groupee(ch, 0);
		return;
	}

	for (k = ch->groupees;k;k = k->next)
		counter++;/*counter counts  how many people in group*/
	k = ch->groupees;
    if (!(k->groupee))
    {
        return;
    }
	l = k->groupee;
	if ((IS_AFFECTED2(ch, AFF2_MGROUP)))
	{
		if (!ch->mgroupmaster)
			was_mgroup_leader = 1;
		else
			was_mgroupee = 1;
	}/*if effected by major group what rank was the character*/
	if (counter == 1)
	{
act("&0&2&b$N is no longer a member of your group.&0", FALSE, l, 0, ch, TO_CHAR);
act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_VICT);
act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_NOTVICT);

	}
	stop_groupee(l, 1);
	if (counter == 1)
	{
				return;
	}
	SET_BIT(AFF_FLAGS(l), AFF_GROUP);
	l->groupmaster = NULL;
	send_to_char("&0&2&bYou have become the group leader&0\r\n", l);
	l->groupees = ch->groupees;
	for (k = l->groupees;k;k = k->next)
	{
		k->groupee->groupmaster = l;
		act("&0&2&bYou have a new group leader $N.&0", FALSE, k->groupee, 0, l, TO_CHAR);
	}

	REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
	ch->groupees = NULL;

	if (was_mgroup_leader)
	{
		SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
		l->mgroupmaster = NULL;
		send_to_char("&0&1You have become the major group leader&0\r\n", l);
		l->mgroupees = ch->mgroupees;
		for (f = l->mgroupees;f;f = f->next)
		{
				f->mgroupee->mgroupmaster = l;
	act("&0&1You have a new major group leader $N.&0", FALSE, f->mgroupee, 0, l, TO_CHAR);
		}
		REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
		ch->mgroupees = NULL;
		return;
	}
	if (was_mgroupee)
	{
		add_mgroupee(l, ch->mgroupmaster, 1);
		die_mgroupee(ch);
		return;
	}

}
void die_consentee_clean(struct char_data *ch)
{/*aim is to search through character list and check if he been consented
 if so clean it up*/
	static struct char_data *i;
	extern struct char_data *character_list;

	for (i = character_list; i; i = i->next)
	{
		if (CONSENT(i) == ch)
		{
			mudlog("Freeing consneted person", NRM, LVL_GOD, FALSE);
			send_to_char("&0&7&bThe person you have concented has quit the game.&0\r\n", i);
			CONSENT(i) = NULL;
		}
	}
}
void die_consentee(struct char_data *ch)
{
	struct char_data *target;
return;
	if (CONSENT(ch))
	{
		if (!(CAN_SEE(ch, CONSENT(ch))))
		{
			CONSENT(ch) = NULL;
			return;
		}
		else
		{
			if (target == CONSENT(ch))
			{
				act("&0&7&bYou revoke your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
				act("&0&7&bYou loose $n's consent.&0", FALSE, ch, 0, target, TO_VICT);
				CONSENT(ch) = NULL;
				return;
			}
		}
	}
	CONSENT(ch) = NULL;
}
void add_groupee(struct char_data *ch, struct char_data * groupleader, bool noisy)
{
	struct group_type *k;
	SET_BIT(AFF_FLAGS(ch), AFF_GROUP);
	assert(!ch->groupmaster);
	ch->groupmaster = groupleader;

	CREATE(k, struct group_type, 1);
	k->groupee = ch;
	k->next = groupleader->groupees;
	groupleader->groupees = k;
	if (noisy)
	{
		act("&0&2&bYou have been accepted into $N's group.&0", FALSE, ch, 0, groupleader, TO_CHAR);
		act("&0&2&bYou accept $n into your group.&0", TRUE, ch, 0, groupleader, TO_VICT);
	act("&0&2&b$n has joined $N's group.&0", TRUE, ch, 0, groupleader,
TO_NOTVICT);

	}
}


/*This is the mgroup code structure*/
void stop_mgroupee(struct char_data * ch, bool hide)
{
	struct group_type *a;
	struct mgroup_type *j, *k;
	struct char_data *l;
	char buf[100];
	int counter = 0;
	bool last_member = 0;
	assert(ch->mgroupmaster);
/*check to see if just one person left is so dispand group at end*/
	l = ch->mgroupmaster;
	for(k = l->mgroupees;k;k=k->next)
		counter++;
	if (counter == 1)
		last_member = 1;
	if (ch->mgroupmaster->mgroupees->mgroupee == ch)
	{	/* Head of follower-list? */
		k = ch->mgroupmaster->mgroupees;
		ch->mgroupmaster->mgroupees = k->next;
		if (counter == 1)
		{
			for (a = l->groupees;a;a=a->next)
			{
				send_to_char("&0&1Your Major Group has been disbanded\r\n", a->groupee);

			}
		}
		sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(k);
	}
	else
	{			/* locate follower who is not head of list */
		for (k = ch->mgroupmaster->mgroupees; k->next->mgroupee != ch; k = k->next);
		j = k->next;
		k->next = j->next;
		sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(j);
	}
	ch->mgroupmaster = NULL;
	REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
/*if that was last on list lets disband this dude*/
	if (last_member)
	{
		REMOVE_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
		l->mgroupees = NULL;
		send_to_char("&0&1Your disband the major group.&0\r\n", l);
	}
}



/* Called when a character that follows/is followed dies */
void die_mgroupee(struct char_data * ch)
{
  struct mgroup_type *k;
  struct group_type *f;
  struct char_data *l;char buf[50];
  int counter = 0;
  if (ch->mgroupmaster)
  {

	  act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, ch->mgroupmaster, 0, ch, TO_CHAR);
	act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, ch->mgroupmaster, 0, ch, TO_VICT);
	act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
FALSE, ch->mgroupmaster, 0, ch, TO_NOTVICT);

 stop_mgroupee(ch, 0);
	  return;
  }
/*handle the death of a group leader*/
sprintf(buf,"in die mgroupee rare");
		mudlog(buf, CMP, LVL_GOD, FALSE);

  for (k=ch->mgroupees;k;k=k->next)
		counter++;
	k = ch->mgroupees;
	l = k->mgroupee;
if (counter == 1)
{
	act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, k->mgroupee, 0, ch, TO_CHAR);
	act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, k->mgroupee, 0, ch, TO_VICT);
	act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
FALSE, k->mgroupee, 0, ch, TO_NOTVICT);

}
	stop_mgroupee(k->mgroupee, 1);
	if (counter ==1)
	{
			return;
	}
		SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
	l->mgroupmaster = NULL;/*all mgroup leaders must have a null mgroupmaster*/
	send_to_char("&0&1You have become the new &1major&0&1 group leader&0\r\n", l);
	l->mgroupees = ch->mgroupees;
    for(f = l->groupees;f;f=f->next)
	{
		act("&0&2&bYour group has a new &0&1Major&0&1 group leader&0&2&b $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
	}
	for (k = ch->mgroupees; k; k = k->next)
	{
		k->mgroupee->mgroupmaster = l;
		act("&0&1You have a new major group leader $N.&0", FALSE, k->mgroupee, 0, l, TO_CHAR);
		for (f = ch->groupees; f; f=f->next)
		{
		act("&0&1Your group has a new major group leader $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
		}
	}

  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
  ch->mgroupees = NULL;
}

void add_mgroupee(struct char_data *ch, struct char_data * mgroupleader, bool hide)
{
	struct mgroup_type *k;

	if (IS_AFFECTED2(ch, AFF2_MGROUP))
    return;

	SET_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
	assert(!ch->groupmaster);
	ch->mgroupmaster = mgroupleader;
	CREATE(k, struct mgroup_type, 1);
	k->mgroupee = ch;
	k->next = mgroupleader->mgroupees;
	mgroupleader->mgroupees = k;
	if (!hide)
	{
	act("&0&1You have been accepted into $N's major group.&0", FALSE, ch, 0, mgroupleader, TO_CHAR);
	act("&0&1You accept $n into your major group.&0", TRUE, ch, 0, mgroupleader, TO_VICT);
	act("&0&1$n has joined $N's major group.&0", TRUE, ch, 0,
mgroupleader, TO_NOTVICT);

	}
}



/* Do NOT call this before having checked if a circle of followers */
/* will arise. CH will follow leader                               */
void add_follower(struct char_data * ch, struct char_data * leader)
{
  struct follow_type *k;

  assert(!ch->master);

  ch->master = leader;

  CREATE(k, struct follow_type, 1);

  k->follower = ch;
  k->next = leader->followers;
  leader->followers = k;

  act("You now follow $N.", FALSE, ch, 0, leader, TO_CHAR);
  if (CAN_SEE(leader, ch))
    act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
  act("$n starts to follow $N.", TRUE, ch, 0, leader, TO_NOTVICT);
}

/*
 * get_line reads the next non-blank line off of the input stream.
 * The newline character is removed from the input.  Lines which begin
 * with '*' are considered to be comments.
 *
 * Returns the number of lines advanced in the file.
 */
int get_line(FILE * fl, char *buf)
{
  char temp[256];
  int lines = 0;

  do {
    lines++;
    fgets(temp, 256, fl);
    if (*temp)
      temp[strlen(temp) - 1] = '\0';
  } while (!feof(fl) && (*temp == '*' || !*temp));

  if (feof(fl))
    return 0;
  else {
    strcpy(buf, temp);
    return lines;
  }
}


int get_filename(char *orig_name, char *filename, int mode)
{
  char *prefix, *middle, *suffix, *ptr, name[64];

  switch (mode) {
  case CRASH_FILE:
    prefix = "plrobjs";
    suffix = "objs";
    break;
  case ETEXT_FILE:
    prefix = "plrtext";
    suffix = "text";
    break;
  default:
    return 0;
    break;
  }

  if (!*orig_name)
    return 0;

  strcpy(name, orig_name);
  for (ptr = name; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  switch (LOWER(*name)) {
  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':
    middle = "A-E";
    break;
  case 'f':  case 'g':  case 'h':  case 'i':  case 'j':
    middle = "F-J";
    break;
  case 'k':  case 'l':  case 'm':  case 'n':  case 'o':
    middle = "K-O";
    break;
  case 'p':  case 'q':  case 'r':  case 's':  case 't':
    middle = "P-T";
    break;
  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':  case 'z':
    middle = "U-Z";
    break;
  default:
    middle = "ZZZ";
    break;
  }

  sprintf(filename, "%s/%s/%s.%s", prefix, middle, name, suffix);
  return 1;
}


int num_pc_in_room(struct room_data *room)
{
  int i = 0;
  struct char_data *ch;

  for (ch = room->people; ch != NULL; ch = ch->next_in_room)
    if (!IS_NPC(ch))
      i++;

  return i;
}

struct char_data *is_playing(char *vict_name)
{
  extern struct descriptor_data *descriptor_list;
  struct descriptor_data *i, *next_i;
  for (i = descriptor_list; i; i = next_i) {
    next_i = i->next;
    if(i->connected == CON_PLAYING && !strcmp(i->character->player.name,CAP(vict_name)))
      return i->character;
  }
  return NULL;
}

  /* string manipulation fucntion originally by Darren Wilson */
  /* (wilson@@shark.cc.cc.ca.us) improved and bug fixed by Chris (zero@@cnw.com) */
  /* completely re-written again by M. Scott 10/15/96 (scottm@@workcommn.net), */
  /* substitute appearances of 'pattern' with 'replacement' in string */
  /* and return the # of replacements */
  int replace_str(char **string, char *pattern, char *replacement, int rep_all,
  		int max_size) {
     char *replace_buffer = NULL;
     char *flow, *jetsam, temp;
     int len, i;

     if ((int)((strlen(*string) - strlen(pattern)) + strlen(replacement)) > max_size)
       return -1;

     CREATE(replace_buffer, char, max_size);
     i = 0;
     jetsam = *string;
     flow = *string;
     *replace_buffer = '\0';
     if (rep_all) {
        while ((flow = (char *)strstr(flow, pattern)) != NULL) {
  	 i++;
  	 temp = *flow;
  	 *flow = '\0';
  	 if ((int)((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement))) > max_size) {
  	    i = -1;
  	    break;
  	 }
  	 strcat(replace_buffer, jetsam);
  	 strcat(replace_buffer, replacement);
  	 *flow = temp;
  	 flow += strlen(pattern);
  	 jetsam = flow;
        }
        strcat(replace_buffer, jetsam);
     }
     else {
        if ((flow = (char *)strstr(*string, pattern)) != NULL) {
  	 i++;
  	 flow += strlen(pattern);
  	 len = ((char *)flow - (char *)*string) - strlen(pattern);

  	 strncpy(replace_buffer, *string, len);
  	 strcat(replace_buffer, replacement);
  	 strcat(replace_buffer, flow);
        }
     }
     if (i == 0) return 0;
     if (i > 0) {
        RECREATE(*string, char, strlen(replace_buffer) + 3);
        strcpy(*string, replace_buffer);
     }
     free(replace_buffer);
     return i;
  }


  /* re-formats message type formatted char * */
  /* (for strings edited with d->str) (mostly olc and mail)     */
  void format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen) {
     int total_chars, cap_next = TRUE, cap_next_next = FALSE;
     char *flow, *start = NULL, temp;
     /* warning: do not edit messages with max_str's of over this value */
     char formated[MAX_STRING_LENGTH];

     flow   = *ptr_string;
     if (!flow) return;

     if (IS_SET(mode, FORMAT_INDENT)) {
        strcpy(formated, "   ");
        total_chars = 3;
     }
     else {
        *formated = '\0';
        total_chars = 0;
     }

     while (*flow != '\0') {
        while ((*flow == '\n') ||
  	     (*flow == '\r') ||
  	     (*flow == '\f') ||
  	     (*flow == '\t') ||
  	     (*flow == '\v') ||
  	     (*flow == ' ')) flow++;

        if (*flow != '\0') {

  	 start = flow++;
  	 while ((*flow != '\0') &&
  		(*flow != '\n') &&
  		(*flow != '\r') &&
  		(*flow != '\f') &&
   		(*flow != '\t') &&
  		(*flow != '\v') &&
  		(*flow != ' ') &&
  		(*flow != '.') &&
  		(*flow != '?') &&
  		(*flow != '!')) flow++;

  	 if (cap_next_next) {
  	    cap_next_next = FALSE;
  	    cap_next = TRUE;
  	 }

  	 /* this is so that if we stopped on a sentance .. we move off the sentance delim. */
  	 while ((*flow == '.') || (*flow == '!') || (*flow == '?')) {
  	    cap_next_next = TRUE;
  	    flow++;
  	 }

  	 temp = *flow;
  	 *flow = '\0';

  	 if ((total_chars + strlen(start) + 1) > 79) {
  	    strcat(formated, "\r\n");
   	    total_chars = 0;
  	 }

  	 if (!cap_next) {
  	    if (total_chars > 0) {
  	       strcat(formated, " ");
  	       total_chars++;
 	    }
  	 }
  	 else {
  	    cap_next = FALSE;
  	    *start = UPPER(*start);
  	 }

  	 total_chars += strlen(start);
  	 strcat(formated, start);

  	 *flow = temp;
        }

        if (cap_next_next) {
  	 if ((total_chars + 3) > 79) {
  	    strcat(formated, "\r\n");
  	    total_chars = 0;
  	 }
  	 else {
  	    strcat(formated, "  ");
  	    total_chars += 2;
  	 }
        }
     }
     strcat(formated, "\r\n");

     if ((int)(strlen(formated)) > maxlen) formated[maxlen] = '\0';
     RECREATE(*ptr_string, char, MIN(maxlen, strlen(formated)+3));
     strcpy(*ptr_string, formated);
  }

   /* strips \r's from line */
 char *stripcr(char *dest, const char *src) {
    int i, length;
    char *temp;

    if (!dest || !src) return NULL;
    temp = &dest[0];
    length = strlen(src);
    for (i = 0; *src && (i < length); i++, src++)
      if (*src != '\r') *(temp++) = *src;
    *temp = '\0';
    return dest;
 }

char *strip_ansi(char *the_string){
  register char *i = NULL, *buf;
  static char zbuf[MAX_STRING_LENGTH];

  buf = zbuf;

  for(;;) {
    if(*the_string == '&') {
      switch (*(++the_string)) {
        default:
          i = "";
          break;
      }
      while ((*buf = *(i++)))
        buf++;
      the_string++;
    }
    else if (!(*(buf++) = *(the_string++)))
      break;
  }

  *(++buf) = '\0';
  return zbuf;
}

int NumAttackers(struct char_data *ch)
{
  struct char_data *tch;
  int total = 0;

  if (!SanityCheck(ch, "NumAttackers"))
    return -1;

  if (ALONE(ch))
    return 0;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
    if (tch->char_specials.fighting && (tch->char_specials.fighting == ch))
      total++;

  return total;
}

bool SanityCheck(struct char_data *ch, const char *calling)
{
  if (!ch) {

    return FALSE;
}

  if (ch->in_room == -1)
    return FALSE;

  return TRUE;
}
#define NEWSHIT 1
#ifdef NEWSHIT
bool statsave(struct char_data *ch, int stat, int mod)
{
  int save_num;

  if (!SanityCheck(ch, "statsave"))
    return FALSE;

  /* change this when adding other stats
  if ((stat != APPLY_AGI) && (stat != APPLY_INT))
    return FALSE;*/

  switch (stat) {

    case APPLY_DEX:

 save_num = STAT_INDEX(GET_DEX(ch)) + mod;

    if (IS_AFFECTED(ch, AFF_HASTE))
      save_num *= 2;

    /*if (IS_AFFECTED2(ch, AFF2_SLOW))
      save_num /= 2;*/

    /* those heavy loaded folks are less than nimble eh? */
    if (IS_CARRYING_W(ch) > 299)
      save_num -= 5;
    else if (IS_CARRYING_W(ch) > 199)
      save_num -= 3;
    else if (IS_CARRYING_W(ch) > 99)
      save_num -= 1;

    /* and let us penalize for being off balance eh?
    if (IS_AFFECTED2(ch, AFF2_STUNNED))
      save_num -= 5;*/

    save_num += GET_POS(ch) - 3;

    /* there are a few bonuses */
    if (IS_AFFECTED(ch, AFF_FLYING) || IS_AFFECTED2(ch, AFF2_LEVITATE))
      save_num += 3;

    break;
  case APPLY_INT:
    save_num = STAT_INDEX(GET_INT(ch)) + mod;

    break;
  case APPLY_WIS:
    save_num = STAT_INDEX(GET_WIS(ch)) + mod;

    break;
  case APPLY_STR:
    save_num = STAT_INDEX(GET_STR(ch)) + mod;

    break;
  case APPLY_CON:
    save_num = STAT_INDEX(GET_CON(ch)) + mod;

    break;
  default:
    return FALSE;
    break;
  }

  return (number(1, 20) < BOUNDED(1, save_num, 20));
}

int STAT_INDEX(int v)
{
  if (v < 1)
    return 0;
  else if (v < 10)
    return 1;
  else if (v < 16)
    return 2;
  else if (v < 22)
    return 3;
  else if (v < 28)
    return 4;
  else if (v < 34)
    return 5;
  else if (v < 40)
    return 6;
  else if (v < 46)
    return 7;
  else if (v < 51)
    return 8;
  else if (v < 56)
    return 9;
  else if (v < 62)
    return 10;
  else if (v < 68)
    return 11;
  else if (v < 74)
    return 12;
  else if (v < 80)
    return 13;
  else if (v < 86)
    return 14;
  else if (v < 92)
    return 15;
  else if (v < 101)
    return 16;

  return ((v - 101) / 12 + 17);
}
bool are_together(struct char_data *ch1, struct char_data *ch2)
{
 struct follow_type *k1, *k2;
 if (!ch1 || !ch2)
    return (FALSE);
  k1 = ch1->followers;
  k2 = ch2->followers;

  if ((ch1 == k2->follower) || (ch2 == k1->follower))
    return (TRUE);
  else if (ch1->followers && (ch1->followers == ch2->followers))
    return (TRUE);

  return (FALSE);
}

bool has_help(struct char_data *ch)
{		/* Function to enhance NPC interpretations*/
  struct char_data *tmp = NULL;

  if (!ch)
    return (FALSE);

  for (tmp = world[ch->in_room].people; tmp; tmp = tmp->next_in_room) {
    if (tmp == ch)
      continue;
    if (are_together(ch, tmp))
      return (TRUE);
  }
  return (FALSE);
}
#endif


/* A easy, much easier way to Min(max( cuts lenth Banyal*/
int BOUNDED(int a, int b, int c)
{
  return (MIN(MAX(a, b), c));
}

int load_modifier(struct char_data * ch)
{
  int p, ccw;

  if (GET_LEVEL(ch) > 50)
    return 0;

  ccw = CAN_CARRY_W(ch);
  if (ccw < 1) {
    /* really light and/or wimpy NPCs */
    if (IS_CARRYING_W(ch) > 0)
      return 300;
    else
      return 0;
  }
  p = 100 - MAX(0, ((ccw - IS_CARRYING_W(ch)) * 100) / ccw);
  if (p < 20)
    return 25;
  if (p < 40)
    return 50;
  if (p < 65)
    return 100;
  if (p < 85)
    return 150;
  if (p < 95)
    return 200;
  return 300;
}



const char *movewords(struct char_data *ch, int cmd, int room, int leaving)
{
  if (GET_POS(ch) == POS_FLYING)
    return (leaving ? "flies" : "flies in");

  if ((IS_AFFECTED2(ch, AFF2_LEVITATE) && ((cmd == 4) || (cmd == 5))))
    return (leaving ? "floats" : "floats in");

  if ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
		(SECT(ch->in_room) == SECT_UNDERWATER) ||
		(SECT(ch->in_room) == SECT_WATER_NOSWIM)) {

  if (SECT(ch->in_room) == SECT_UNDERWATER)
  if (IS_AFFECTED2(ch, AFF2_WATERBREATH))
      return (leaving ? "swims" : "swims in");

   if (SECT(ch->in_room) == SECT_WATER_SWIM)
      return (leaving ? "swims" : "swims in");

    if (SECT(ch->in_room) == SECT_WATER_NOSWIM)
      return (leaving ? "floats" : "floats in");

    return (leaving ? "thrashes" : "thrashes in");
  }

  if ((load_modifier(ch) > 199) || (GET_COND(ch, DRUNK) > 6))
    return (leaving ? "staggers" : "staggers in");

  if (((IS_AFFECTED(ch, AFF_BLIND)) ||
       (IS_DARK(room) &&
	!IS_AFFECTED(ch, AFF_INFRAVISION))))
    return(leaving ? "stumbles" : "stumbles in");

  if (IS_AFFECTED(ch, AFF_SNEAK) || OUTDOOR_SNEAK(ch))
    return (leaving ? "sneaks" : "sneaks in");

  if (GET_POS1(ch) == POS1_PRONE)
    return (leaving ? "slithers" : "slithers in");

  if (GET_POS1(ch) == POS1_KNEELING)
    return (leaving ? "crawls" : "crawls in");

  switch (GET_RACE(ch)) {
  case SPECIES_GIANT:
  case RACE_OGRE:
    return (leaving ? "lumbers" : "lumbers in");

  /*case RACE_W_ELEMENTAL:
    return (leaving ? "flows" : "flows in");

  case RACE_A_ELEMENTAL:
  case RACE_POSSESSED:
    return (leaving ? "flies" : "flies in");

  case RACE_INSECT:
  case RACE_PARASITE:
    return (leaving ? "skitters" : "skitters in");

  case RACE_ARACHNID:
    return (leaving ? "scuttles" : "scuttles in");

  case RACE_SLIME:
    return (leaving ? "oozes" : "oozes in");

  case RACE_ILLITHID:*/
  case RACE_DUERGAR:
    return (leaving ? "skulks" : "skulks in");

  /*case RACE_CANINE:
  case RACE_CARNIVORE:*/
  case RACE_TROLL:
    return (leaving ? "prowls" : "prowls in");

  /*case RACE_BIRD:
  case RACE_FAERIE:
  case RACE_RAPTOR:
    return (leaving ? "flutters" : "flutters in");

  case RACE_GHOST:
  case RACE_SPIRIT:
    return (leaving ? "glides" : "glides in");

  case RACE_FELINE:
    return (leaving ? "stalks" : "stalks in");

  case RACE_FISH:
    return (leaving ? "flops" : "flops in");  *//* swims handled above */

 /* case RACE_CENTAUR:
  case RACE_HERBIVORE:
  case RACE_HORSE:
    return (leaving ? "walks" : "walks in");

  case RACE_ANGEL:
  case RACE_DEMON:
  case RACE_DEVIL:
  case RACE_HIGH_UNDEAD:
  case RACE_LYCANTH:
  case RACE_VAMPIRE:
    return (leaving ? "strides" : "strides in");

  case RACE_NAGA:
  case RACE_SNAKE:
    return (leaving ? "slithers" : "slithers in");
*/
  case SPECIES_DRAGON:
  /*case RACE_DRAGONKIN:*/
    return (leaving ? "stomps" : "stomps in");
/*
  case RACE_F_ELEMENTAL:
    return (leaving ? "blazes" : "blazes in");*/

  case SPECIES_DEMON:
    return (leaving ? "stalks" : "stalks in");

  case SPECIES_UNDEAD:
    return (leaving ? "shambles" : "shambles in");

  }

  return (leaving ? "leaves" : "enters");
}

void stop_ignoring_me(struct char_data *ch)
{
  struct char_data *tc, *next_tc = NULL;

  for (tc = character_list; tc; tc = next_tc) {
    if (tc->player_specials->ignored == ch) {
      send_to_char("The person you are ignoring has just quit the game.\r\n", tc);
      tc->player_specials->ignored = NULL;
    }
  }
}
@


1.130
log
@Log to file errors we might want to see.
@
text
@/***************************************************************************
 * $Id: utils.c,v 1.129 2009/06/10 02:27:14 myc Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: utils.c                                        Part of FieryMUD *
 *  Usage: various internal functions of a utility nature                  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <sys/stat.h> /* For stat() */

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "screen.h"
#include "casting.h"
#include "handler.h"
#include "weather.h"
#include "db.h"
#include "events.h"
#include "races.h"
#include "skills.h"
#include "math.h"
#include "interpreter.h"
#include "constants.h"
#include "pfiles.h"
#include "composition.h"
#include "lifeforce.h"
#include "money.h"

int monk_weight_penalty(struct char_data *ch)
{
  if (!IS_NPC(ch) && GET_CLASS(ch) == CLASS_MONK && GET_LEVEL(ch) >= 20) {
    int limit = CAN_CARRY_W(ch) * (0.8 + (GET_STR(ch) / 1000.0));

    if (IS_CARRYING_W(ch) < limit)
      return 0;

    return (IS_CARRYING_W(ch) - limit) / 10;
  }
  else
    return 0;
}


static int exp_table[LVL_IMPL + 1];

void init_exp_table(void)
{
  long exp, last_exp;
  int lvl, i;

  const struct {
    int level;
    int static_add;
    int level_mod;
    int multiplier;
  } eval[] = {
    {   0,   44000,  8,  12500 },
    {  17,  144000, 16,  17500 },
    {  25,  284000, 24,  22500 },
    {  33,  464000, 32,  25000 },
    {  49,  864000, 48,  30000 },
    {  90, 2094000, 89,  60000 },
    {  92, 2214000, 91,  70000 },
    {  95, 2424000, 94,  80000 },
    {  96, 2504000, 95,  90000 },
    {  98, 2684000, 97, 100000 },
    { 999,       0,  0,      0 }
  };

  last_exp = 0;

  for (lvl = 0; lvl <= LVL_IMPL; ++lvl) {

    if (lvl < 9)
      exp = ((lvl * lvl) + lvl) / 2 * 5500;

    else if (lvl < 99) { /*(lvl <= LVL_IMMORT) { */
      for (i = 0; lvl >= eval[i].level; ++i);
      --i;
      exp = eval[i].static_add;
      exp += (lvl - eval[i].level_mod) * eval[i].multiplier;
      exp += last_exp;
    }

    else if (lvl == 99) {
      for (i = 0; lvl >= eval[i].level; ++i);
      --i;
      exp = eval[i].static_add;
      exp += (lvl - eval[i].level_mod) * eval[i].multiplier;

      for (i = 0; lvl + 1 >= eval[i].level; ++i);
      --i;
      exp += eval[i].static_add;
      exp += (lvl + 1 - eval[i].level_mod) * eval[i].multiplier;

      exp += last_exp;
    }

    else
      exp = 300000001 + 2 * (lvl - LVL_IMMORT - 1);

    exp_table[lvl] = exp;
    last_exp = exp;
  }
}


long exp_next_level(int level, int class)
{
  double gain_factor;

  if (level > LVL_IMPL || level < 0) {
    log("SYSERR: Requesting exp for invalid level %d!", level);
    return 0;
  }

  /* God levels should all be the same for any class */
  if (level >= LVL_IMMORT)
    gain_factor = 1;
  else
    gain_factor = EXP_GAIN_FACTOR(class);

  return exp_table[level] * gain_factor;
}


/* log a death trap hit */
void log_death_trap(struct char_data * ch)
{
  mprintf(L_STAT, LVL_IMMORT, "%s hit death trap #%d (%s)", GET_NAME(ch),
          world[IN_ROOM(ch)].vnum, world[IN_ROOM(ch)].name);
}


/* writes a string to the log */
void log(const char *str, ...)
{
  char timestr[32];
  time_t ct;
  va_list args;

  static unsigned int vcount = 0;
  static unsigned int scount = 0;

  ct = time(0);
  strftime(timestr, 32, TIMEFMT_LOG, localtime(&ct));
  fprintf(stderr, "%-24.24s :: ", timestr);
  if (strchr(str, '%')) {
    va_start(args, str);
    vfprintf(stderr, str, args);
    va_end(args);
    ++vcount;
  }
  else {
    fputs(str, stderr);
    ++scount;
  }
  fputs("\n", stderr);
 
  /* TODO: check this debug data and determine if the split
   * for static strings is necessary
   */
  if ((vcount + scount) % 100 == 0)
    fprintf(stderr, "DEBUG :: log :: vprintf calls - %u, fputs calls - %u\n",
            vcount, scount);
}


/* the "touch" command, essentially. */
int touch(const char *path)
{
  FILE *fl;

  if (!(fl = fopen(path, "a"))) {
    perror(path);
    return -1;
  } else {
    fclose(fl);
    return 0;
  }
}


/*
 * mudlog -- log mud messages to a file & to online imm's syslogs
 * based on syslog by Fen Jul 3, 1992
 */
void mudlog(const char *str, unsigned char type, int level, byte file)
{
  switch (type) {
    case OFF: type = L_CRIT; break; 
    case BRF: type = L_WARN; break;
    case NRM: type = L_STAT; break;
    case CMP: type = L_DEBUG; break;
  }
  if (!file)
    type |= L_NOFILE;
  mudlog_printf(type, level, "%s", str);
}

void mudlog_printf(int severity, int level, const char *str, ...)
{
  static char buf[MAX_STRING_LENGTH], timestr[32];
  struct descriptor_data *i;
  time_t ct;
  va_list args;
  size_t slen;

  ct = time(0);
  strftime(timestr, 32, TIMEFMT_LOG, localtime(&ct));

  va_start(args, str);
  slen = vsnprintf(buf + 2, sizeof(buf) - 2, str, args);
  va_end(args);
  if (slen >= sizeof(buf) - 7)
    slen = sizeof(buf) - 8;

  if (!IS_SET(severity, L_NOFILE))
    fprintf(stderr, "%-24.24s :: %s\n", timestr, buf + 2);
  /* Drop the L_NOFILE bit if it was set */
  REMOVE_BIT(severity, L_NOFILE);
  if (level < 0 || level > LVL_IMPL)
    return;

  /* Make it "[ buf ]" */
  buf[0] = '[';
  buf[1] = ' ';
  strcpy(buf + slen + 2, " ]\r\n");

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING) && !EDITING(i))
      if (GET_LEVEL(i->character) >= level &&
          GET_LOG_VIEW(i->character) <= severity)
        string_to_output(i, buf);
}

const char *sprint_log_severity(int severity)
{
  REMOVE_BIT(severity, L_NOFILE);

  return log_severities[LIMIT(0, (severity - 1) / 10, 6)];
}

int parse_log_severity(const char *severity)
{
   int sev = search_block(severity, log_severities, FALSE);
   if (sev >= 0)
      return (sev + 1) * 10;
   else
      return sev;
}


flagvector *ALL_FLAGS = NULL;

void init_flagvectors() {
  const int num_flags[] = {
    NUM_EFF_FLAGS,
    NUM_MOB_FLAGS,
    NUM_PLR_FLAGS,
    NUM_PRF_FLAGS,
    NUM_PRV_FLAGS,
    NUM_ITEM_FLAGS,
    NUM_ITEM_WEAR_FLAGS,
    NUM_ROOM_FLAGS,
    NUM_ROOM_EFF_FLAGS,
    NUM_ITEM_FLAGS,
    MAX_EVENT,
  };
  int i, max = 0;

  for (i = 0; i < sizeof(num_flags) / sizeof(int); ++i)
    max = MAX(max, num_flags[i]);

  if (ALL_FLAGS)
    free(ALL_FLAGS);
  CREATE(ALL_FLAGS, flagvector, FLAGVECTOR_SIZE(max));
  for (i = 0; i < FLAGVECTOR_SIZE(max); ++i)
    ALL_FLAGS[i] = ~0;

  if (sizeof(flagvector) != 4) {
    log("SYSERR: WARNING! Flagvector type size isn't the expected 4 bytes!");
    log("SYSERR: WARNING! You may have to fix a lot of things...");
    log("SYSERR: WARNING! This may cause problems with player and world files especially.");
  }
}

bool ALL_FLAGGED(const flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    if (flags[i] && !IS_SET(field[i], flags[i]))
      return FALSE;
  return TRUE;
}

bool ANY_FLAGGED(const flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    if (IS_SET(field[i], flags[i]))
      return TRUE;
  return FALSE;
}

void SET_FLAGS(flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    SET_BIT(field[i], flags[i]);
}

void REMOVE_FLAGS(flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    REMOVE_BIT(field[i], flags[i]);
}

void TOGGLE_FLAGS(flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    TOGGLE_BIT(field[i], flags[i]);
}

void COPY_FLAGS(flagvector field[], const flagvector flags[], const int num_flags)
{
  int i;
  for (i = 0; i < FLAGVECTOR_SIZE(num_flags); ++i)
    field[i] = flags[i];
}


/* Calculate the REAL time passed over the last t2-t1 centuries (secs) */
struct time_info_data real_time_passed(time_t t2, time_t t1)
{
  long secs;
  struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_REAL_HOUR) % 24;        /* 0..23 hours */
  secs -= SECS_PER_REAL_HOUR * now.hours;

  now.day = (secs / SECS_PER_REAL_DAY);        /* 0..34 days  */
  secs -= SECS_PER_REAL_DAY * now.day;

  now.month = -1;
  now.year = -1;

  return now;
}



/* Calculate the MUD time passed over the last t2-t1 centuries (secs) */
struct time_info_data mud_time_passed(time_t t2, time_t t1)
{
  long secs;
  struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_MUD_HOUR) % 24;        /* 0..23 hours */
  secs -= SECS_PER_MUD_HOUR * now.hours;

  now.day = (secs / SECS_PER_MUD_DAY) % 35;        /* 0..34 days  */
  secs -= SECS_PER_MUD_DAY * now.day;

  now.month = (secs / SECS_PER_MUD_MONTH) % 17;        /* 0..16 months */
  secs -= SECS_PER_MUD_MONTH * now.month;

  now.year = (secs / SECS_PER_MUD_YEAR);        /* 0..XX? years */

  return now;
}



struct time_info_data age(struct char_data * ch)
{
  struct time_info_data player_age;

  player_age = mud_time_passed(time(0), ch->player.time.birth);

  player_age.year += 17;        /* All players start at 17 */

  return player_age;
}


EVENTFUNC(mobquit_event)
{
   struct char_data *ch = (struct char_data *)event_obj;

   /* Critter is going to leave the game now */

   /* Send a message to those nearby */
   if (GET_POS(ch) < POS_SITTING)
      act("With a heroic effort, $n drags $mself to $s feet and runs off.",
            TRUE, ch, 0, 0, TO_ROOM);
   else
      act("$n turns and moves off, disappearing swiftly into the distance.",
            TRUE, ch, 0, 0, TO_ROOM);

   /* Destroy all of its items (else extract_char() will dump them
    * on the ground) */
   extract_objects(ch);

   /* And finally get rid of this critter. */
   extract_char(ch);
   return EVENT_FINISHED;
}

EVENTFUNC(autodouse_event)
{
   struct char_data *ch = (struct char_data *) event_obj;

   if (EFF_FLAGGED(ch, EFF_ON_FIRE)) {
      act("$n's flames go out with a hiss as $e enters the water.",
            FALSE, ch, 0, 0, TO_ROOM);
      act("Your flames quickly go out as you enter the water.",
            FALSE, ch, 0, 0, TO_CHAR);
      REMOVE_FLAG(EFF_FLAGS(ch), EFF_ON_FIRE);
   }

   return EVENT_FINISHED;
}



void die_consentee_clean(struct char_data *ch)
{
/*aim is to search through character list and check if he been consented
   if so clean it up*/
  static struct char_data *i;

  for (i = character_list; i; i = i->next) {
    if (CONSENT(i) == ch) {
      send_to_char("&0&7&bThe person you consented to has left the game.&0\r\n", i);
      CONSENT(i) = NULL;
    }
  }
}

/*
 * get_line reads the next non-blank line off of the input stream.
 * The newline character is removed from the input.  Lines which begin
 * with '*' are considered to be comments.
 *
 * Returns the number of lines advanced in the file.
 */
int get_line(FILE * fl, char *buf)
{
  char temp[256];
  int lines = 0;

  temp[0] = 0; /* Otherwise, reading a 0-length file could lead to errors. */

  do {
    lines++;
    fgets(temp, 256, fl);
    if (*temp) {
      temp[strlen(temp) - 1] = '\0';
    }
  } while (!feof(fl) && (*temp == '*' || !*temp));

  if (feof(fl))
    return 0;
  else {
    strcpy(buf, temp);
    return lines;
  }
}

int num_pc_in_room(struct room_data *room)
{
  int i = 0;
  struct char_data *ch;

  for (ch = room->people; ch != NULL; ch = ch->next_in_room)
    if (!IS_NPC(ch))
      i++;

  return i;
}

struct char_data *is_playing(char *vict_name)
{
  struct descriptor_data *i;
  for (i = descriptor_list; i; i = i->next)
    if (i->connected == CON_PLAYING) {
      if (!str_cmp(GET_NAME(i->character), vict_name))
        return i->character;
      else if (i->original && !str_cmp(GET_NAME(i->original), vict_name))
        return i->original;
    }
  return NULL;
}


int load_modifier(struct char_data * ch)
{
  int p, ccw;

  if (GET_LEVEL(ch) > 50)
    return 0;

  ccw = CAN_CARRY_W(ch);
  if (ccw < 1) {
    /* really light and/or wimpy NPCs */
    if (IS_CARRYING_W(ch) > 0)
      return 300;
    else
      return 0;
  }
  p = 100 - MAX(0, ((ccw - IS_CARRYING_W(ch)) * 100) / ccw);
  if (p < 20)
    return 25;
  if (p < 40)
    return 50;
  if (p < 65)
    return 100;
  if (p < 85)
    return 150;
  if (p < 95)
    return 200;
  return 300;
}



const char *movewords(struct char_data *ch, int dir, int room, int leaving)
{
  if (GET_POS(ch) == POS_FLYING)
    return (leaving ? "flies" : "flies in");

  if (EFF_FLAGGED(ch, EFF_LEVITATE) && (dir == DOWN || dir == UP))
    return (leaving ? "floats" : "floats in");

  if (IS_WATER(ch->in_room)) {
    if (SECT(ch->in_room) == SECT_UNDERWATER)
      if (EFF_FLAGGED(ch, EFF_WATERBREATH))
        return (leaving ? "swims" : "swims in");

    if (SECT(ch->in_room) == SECT_SHALLOWS)
      return (leaving ? "swims" : "swims in");

    if (SECT(ch->in_room) == SECT_WATER)
      return (leaving ? "floats" : "floats in");

    return (leaving ? "thrashes" : "thrashes in");
  }

  if (load_modifier(ch) > 199)
    return (leaving ? "trudges" : "trudges in");

  if (!IS_NPC(ch) && GET_COND(ch, DRUNK) > 6)
    return (leaving ? "staggers" : "staggers in");

  if (EFF_FLAGGED(ch, EFF_BLIND) ||
     (IS_DARK(room) && !EFF_FLAGGED(ch, EFF_INFRAVISION)))
    if (!PRF_FLAGGED(ch, PRF_HOLYLIGHT))
      return (leaving ? "stumbles" : "stumbles in");

  if (IS_HIDDEN(ch) || OUTDOOR_SNEAK(ch) || EFF_FLAGGED(ch, EFF_SNEAK))
    return (leaving ? "sneaks" : "sneaks in");

  if (GET_POS(ch) == POS_PRONE)
    return (leaving ? "slithers" : "slithers in");

  if (GET_POS(ch) == POS_KNEELING || GET_POS(ch) == POS_SITTING)
    return (leaving ? "crawls" : "crawls in");

  if (GET_LIFEFORCE(ch) == LIFE_UNDEAD)
    return (leaving ? "shambles" : "shambles in");

  if (leaving) {
    if (VALID_RACE(ch) && races[GET_RACE(ch)].leave_verb)
      return races[GET_RACE(ch)].leave_verb;
    else
      return "leaves";
  } else {
    if (VALID_RACE(ch) && races[GET_RACE(ch)].enter_verb)
      return races[GET_RACE(ch)].enter_verb;
    else
      return "enters";
  }
}

void build_count() {
  FILE *fd;
  extern int make_count;
  if ((fd = fopen(MAKE_COUNT, "r"))) {
    fscanf(fd, "%d", &make_count);
    fclose(fd);
  }
}

int  pick_random_gem_drop(struct char_data *ch) {

  int slot;
  int phase;
  int roll;

  int armor_vnums[] = {

    55300,     55301,     55302,    55304,     55305,     55306,
    55308,     55309,     55310,    55312,     55313,     55314,
    55316,     55317,     55318,    55320,     55321,     55322,
    55324,     55325,     55326,    55328,     55329,     55330,
    55331,     55332,     55333,    55334,     55335,     55336,

    55337,     55338,     55339,    55340,     55341,     55342,
    55343,     55344,     55345,    55346,     55347,     55348,
    55349,     55350,     55351,    55352,     55353,     55354,
    55355,     55356,     55357,    55358,     55359,     55360,
    55361,     55362,     55363,    55364,     55365,     55366,

    55367,     55368,     55369,    55370,     55371,     55372,
    55373,     55374,     55375,    55376,     55377,     55378,

    55379,     55380,     55381,    55382,     55383,
  };

  int leg_gem_vnums[][2] = {
    { 55586, 55589 },
    { 55649, 55659 },
    { 55726, 55736 }
  };

  int common_gem_vnums[][2] = {
    { 55566, 55569 }, { 55570, 55573 }, { 55574, 55577 }, { 55578, 55581 },
    { 55582, 55585 }, { 55594, 55604 }, { 55605, 55615 }, { 55616, 55626 },
    { 55627, 55637 }, { 55638, 55648 }, { 55671, 55681 }, { 55682, 55693 },
    { 55693, 55703 }, { 55704, 55714 }, { 55715, 55725 }
  };

  if (!IS_NPC(ch) || ch->desc || GET_LEVEL(ch) > 60)
    return 0;

  if (number(1, 100) > 7)
    return 0;

  slot = GET_LEVEL(ch) / 4;
  phase = GET_LEVEL(ch) / 20;

  roll = number(1, 100);

  /* You win the shiny prize!  The shiny prize is rusted decayed armor. */
  if (roll > 98) {

    int item = 4 - number(1, 7) + GET_LEVEL(ch);

    if (item < 0) item = 0;
    if (item > 63) item = 63;

    return armor_vnums[item];
  }

  roll = number(1, 100);

  if (roll < 30) {
    slot--;
  } else if (roll < 80) {
  } else if (roll < 95) {
    slot++;
  }
  else {
    /* If we're in the highest section of a phase, there's a chance of leg gems. */
    if (slot % 5 == 4) {
      return number(leg_gem_vnums[phase][0], leg_gem_vnums[phase][1]);
    }

    slot++; slot++;
  }

  if (slot < 0) slot = 0;
  if (slot > 14) slot = 14;

  return number(common_gem_vnums[slot][0], common_gem_vnums[slot][1]);

}



void perform_random_gem_drop(struct char_data *ch) {
  int vnum = pick_random_gem_drop(ch);
  int rnum;
  struct obj_data* od;

  if (!vnum)
    return;

  rnum = real_object(vnum);

  if (rnum < 0) {
    sprintf(buf, "SYSERR: Can't perform random gem drop - no object with vnum %d", vnum);
    mudlog(buf, NRM, LVL_IMMORT, TRUE);
    return;
  }

  od = read_object(rnum, REAL);

  if (!od) {
    sprintf(buf, "RGD Error: Could not read object (vnum %d)!", vnum);
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
    return;
  }

  obj_to_char(od, ch);
}


int yesno_result(char *answer) {
   if (!answer || !(*answer))
      return YESNO_NONE;
   else if (answer[0] == 'y' || answer[0] == 'Y')
      return YESNO_YES;
   else if (answer[0] == 'n' || answer[0] == 'N')
      return YESNO_NO;
   else
      return YESNO_OTHER;
}

/* Given a vnum, find out its zone's index into the zone table. */
int find_zone(int num) {
   int i;

   for (i = 0; zone_table[i].number != num && i <= top_of_zone_table; i++);
   if (i <= top_of_zone_table)
      return i;
   return -1;
}


/* Given an IP address string, produce a string representation of it,
 * with decimal octets (e.g., 255.255.255.255), without leading zeros.
 *
 * Returns 0 on success or 1 if the address is invalid.
 */

int normalize_ip_address(char *in, char *out)
{
   int octets[4];
   int octet = 0;
   char *inx = in;
   int octval = 0;

   while (*inx && octet < 4) {
      switch (*inx) {
         case '.':
            if (octval > 255) {
               /* Invalid value */
               return 1;
            }
            octets[octet++] = octval;
            octval = 0;
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            octval = octval * 10 + (int)(*inx - '0');
            break;
         default:
            /* Invalid character */
            return 1;
      }
      inx++;
   }
   if (octval > 255 || octet != 3) {
      /* Invalid value or incorrect number of octets */
      return 1;
   }
   octets[octet] = octval;
   sprintf(out, "%d.%d.%d.%d", octets[0], octets[1], octets[2], octets[3]);
   return 0;
}


char *statelength(int inches)
{
   static char res0[400];
   static char res1[400];
   static int resptr = 0;
   char *res = res0;

   if (resptr == 0) {
      resptr = 1;
      res = res1;
   } else {
      resptr = 0;
      res = res0;
   }

   if (inches < 12)
      sprintf(res, "%d inch%s", inches,
            inches == 1 ? "" : "es");
   else if (inches < 1200 && inches % 12)
      sprintf(res, "%d %s, %d inch%s", inches / 12,
            inches / 12 == 1 ? "foot" : "feet",
            inches % 12,
            inches % 12 == 1 ? "" : "es");
   else
      sprintf(res, "%d %s", inches / 12,
            inches / 12 == 1 ? "foot" : "feet");

   return res;
}

char *stateweight(float pounds)
{
   static char res0[400];
   static char res1[400];
   static int resptr = 0;
   char *res = res0;
   int len;

   if (resptr == 0) {
      resptr = 1;
      res = res1;
   } else {
      resptr = 0;
      res = res0;
   }

   if (pounds < 2000)
      sprintf(res, "%.2f pound%s", pounds,
            pounds == 1 ? "" : "s");
   else if (pounds < 2100)
      sprintf(res, "1 ton");
   else {
      sprintf(res, "%0.1f", pounds / 2000.0);
      /* Lop off trailing ".0" */
      len = strlen(res);
      if (len > 2 && res[len - 1] == '0' && res[len - 2] == '.')
         res[len - 2] = '\0';
      strcat(res, " tons");
   }

   return res;
}


/* parse_obj_name()
 *
 * This function is used to translate a string into a constant.
 *
 * Whenever you have an array of structs, and the first element of the struct
 * is a string that's the name of the object, this function can be used to
 * find out which struct in the array has a given name.
 *
 * Example: size = parse_obj_name(ch, arg, "size", NUM_SIZES, sizes, sizeof(struct sizedef));
 *
 *    ch          Optional.  A character who has typed something to be identified and may need feedback.
 *    arg         The string to identify
 *    objname     What kind of thing we're identifying.  Only needed if ch is not NULL.
 *    numobjs     How many kinds of this thing exist?
 *    objects     The array of structs.
 *    objsize     The size of the structs.
 */

struct objdef {
   char *name;
};

#define OBJNAME(i) (((struct objdef *)((char *)(objects) + objsize * i))->name)

int parse_obj_name(struct char_data *ch, char *arg, char *objname, int numobjs, void *objects, int objsize)
{
   int i, answer = -1, best = -1;

   if (!*arg){
      if (ch) {
         sprintf(buf, "What %s?\r\n", objname);
         send_to_char(buf, ch);
      }
      return -1;
   }

   if (isdigit(arg[0])) {
      answer = atoi(arg);
      if (answer < 0 || answer >= numobjs)
         answer = -1;
   } else for (i = 0; i < numobjs; i++) {
      if (!strncasecmp(arg, OBJNAME(i), strlen(arg))) {
         if (!strcasecmp(arg, OBJNAME(i))) {
            answer = i;
            break;
         }
         if (best == -1)
            best = i;
      } else if (is_abbrev(arg, OBJNAME(i))) {
         if (best == -1)
         best = i;
      }
   }

   if (answer == -1) answer = best;
   if (answer == -1) {
      if (ch) {
         sprintf(buf, "There is no such %s.\r\n", objname);
         send_to_char(buf, ch);
      }
   }
   return answer;
}

char *format_apply(int apply, int modifier)
{
   static char f[MAX_STRING_LENGTH];

   if (apply == APPLY_COMPOSITION) {
      if (modifier >= 0 && modifier < NUM_COMPOSITIONS)
         sprintf(f, "COMPOSITION set to %s%s&0",
               compositions[modifier].color, compositions[modifier].name);
      else
         sprintf(f, "&3&bInvalid Composition!&0");
   } else if (apply > 0) {
      sprinttype(apply, apply_types, buf2);
      sprintf(f, "%+d to %s", modifier, buf2);
   } else {
      sprintf(f, "None.");
   }
   return f;
}


/* Sort functions */

void sort(void algorithm(int[], int, int(int a, int b)),
          int array[], int count, int comparator(int, int))
{
  algorithm(array, count, comparator);
}

int natural_order(int a, int b)
{
  return (a > b ? 1 : (a < b ? -1 : 0));
}

void bubblesort(int array[], int count, int comparator(int a, int b))
{
  int i, t;
  bool swap;

  do {
    swap = FALSE;
    --count;
    for (i = 0; i < count; ++i)
      if (comparator(array[i], array[i + 1]) > 0) {
        t = array[i];
        array[i] = array[i + 1];
        array[i + 1] = t;
        swap = TRUE;
      }
  } while (swap);
}


void insertsort(int array[], int count, int comparator(int, int))
{
  int i, value, j;

  for (i = 1; i < count; ++i) {
    value = array[i];
    j = i - 1;
    for (j = i - 1; j >= 0 && comparator(array[j], value) > 0; --j)
      array[j + 1] = array[j];
    array[j + 1] = value;
  }
}


static void do_quicksort(int array[], int start, int end, int comparator(int a, int b))
{
  if (end > start + 1) {
    int pivot = array[start],
        left = start + 1,
        right = end,
        temp;
    while (left < right) {
      if (comparator(array[left], pivot) <= 0)
        ++left;
      else {
        --right;
        temp = array[left];
        array[left] = array[right];
        array[right] = temp;
      }
    }
    --left;
    temp = array[left];
    array[left] = array[start];
    array[start] = temp;
    do_quicksort(array, start, left, comparator);
    do_quicksort(array, right, end, comparator);
  }
}

void quicksort(int array[], int count, int comparator(int a, int b))
{
  do_quicksort(array, 0, count, comparator);
}

void optquicksort(int array[], int count, int comparator(int a, int b))
{
  #define  MAX_LEVELS  1000

  int pivot, start[MAX_LEVELS], end[MAX_LEVELS], i = 0, L, R;

  start[0] = 0; end[0] = count;
  while (i >= 0) {
    L = start[i];
    R = end[i] - 1;
    if (L < R) {
      pivot = array[L];
      if (i == MAX_LEVELS - 1)
        return /* FALSE */;
      while (L < R) {
        while (comparator(array[R], pivot) >= 0 && L < R)
          R--;
        if (L < R)
          array[L++] = array[R];
        while (comparator(array[L], pivot) <= 0 && L < R)
          L++;
        if (L < R)
          array[R--] = array[L];
      }
      array[L] = pivot;
      start[i + 1] = L + 1;
      end[i + 1] = end[i];
      end[i++] = L;
    }
    else
      --i;
  }
  return /* TRUE */;

  #undef MAX_LEVELS
}

void drop_core(struct char_data *ch, const char *desc)
{
   static int corenum = 0;
   char initcorename[MAX_STRING_LENGTH];
   char corename[MAX_STRING_LENGTH];
   struct stat finfo;
   bool dropped = FALSE;

   pid_t child = fork();

   if (child == 0) {
      abort();
   } else {
      if (desc && *desc) {
         sprintf(corename, "core-%s-%d.%d", desc, corenum, getpid());
      } else {
         sprintf(corename, "core-%d.%d", corenum, getpid());
      }
      corenum++;
      waitpid(child, 0, 0);
      sprintf(initcorename, "core.%d", child);
      if (stat(initcorename, &finfo) == 0) {
         rename(initcorename, corename);
         dropped = TRUE;
      } else if (stat("core", &finfo) == 0) {
         rename("core", corename);
         dropped = TRUE;
      } else {
         log("SYSERR: Could not find core file named %s or %s",
               initcorename, "core");
      }
      if (ch) {
         if (dropped) {
            cprintf(ch, "The core was dumped to %s\r\n", corename);
         } else {
            cprintf(ch, "Sorry, the core dump failed!\r\n");
         }
      }
   }
}

/***************************************************************************
 * $Log: utils.c,v $
 * Revision 1.129  2009/06/10 02:27:14  myc
 * Added an optimization to log which checks to see if the message
 * to be printed has any %'s before attempting to vfprintf.  This
 * can save some time, but to see whether it's really worth it,
 * we're going to count the number of times each branch is used and
 * log it.
 *
 * Revision 1.128  2009/06/09 05:51:26  myc
 * Adding NUM_PRV_FLAGS to the init_flagvectors array.
 *
 * Revision 1.127  2009/03/09 05:51:25  jps
 * Moved some money-related functions from utils to money
 *
 * Revision 1.126  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.125  2009/03/09 03:33:03  myc
 * Split off string functions from this file into strings.c
 *
 * Revision 1.124  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.123  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.122  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default;
 * assert L_NOFILE to prevent that.
 *
 * Revision 1.121  2009/02/11 17:03:39  myc
 * Add smash_tilde(), which removes tildes from the end of lines.
 * Make str_ functions take const formats.  Check EDITING(d)
 * where PLR_WRITING is checked in mudlog.
 *
 * Revision 1.120  2009/01/17 00:28:02  myc
 * Fix possible use of uninitialized variable.
 *
 * Revision 1.119  2008/09/25 04:47:49  jps
 * Add drop_core() function, to drop the mud's core without terminating.
 *
 * Revision 1.118  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.117  2008/09/21 21:21:29  jps
 * Remove debugging printf.
 *
 * Revision 1.116  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.115  2008/09/07 20:06:13  jps
 * Changed the exp needed for level 100 so that it's the same as the amount
 * we've always been requiring due to a bug.
 *
 * Revision 1.114  2008/09/07 18:45:15  jps
 * Added briefmoney function for printing the top two coins of a money
 * value in a given number of spaces. With color.
 *
 * Revision 1.113  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.112  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.111  2008/08/31 04:17:55  myc
 * Fix exp for level 100.
 *
 * Revision 1.110  2008/08/30 04:13:45  myc
 * Replaced the exp_to_level monstrosity with a lookup table that gets
 * populated at boot time.
 *
 * Revision 1.109  2008/08/29 04:16:26  myc
 * Get rid of the trailing space in sprintflag.
 *
 * Revision 1.108  2008/08/16 21:33:01  jps
 * Allow a negative return value if you pass an invalid syslog severity.
 *
 * Revision 1.107  2008/08/14 23:10:35  myc
 * Added vararg functionality to log() and mudlog().  mprintf() is
 * the new vararg mudlog().  The old non-vararg mudlog() is still
 * available.  Added graduated log severity to the mudlog.
 *
 * Revision 1.106  2008/08/03 21:32:32  jps
 * Stop generating a log entry every time someone leaves the game when
 * someone was consented to that person.
 *
 * Revision 1.105  2008/06/21 17:26:33  jps
 * Moved movement strings into race definitions.
 *
 * Revision 1.104  2008/06/05 02:07:43  myc
 * Replaced strip_cr with filter_chars/strip_chars.
 *
 * Revision 1.103  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.102  2008/04/19 21:11:22  myc
 * Added some general-purpose integer array sorting functions.
 * Right now, we've got bubble sort, insertion sort, quicksort,
 * and some apparently-optimized quicksort I found on Google :)
 *
 * Revision 1.101  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.100  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.99  2008/04/02 19:31:02  myc
 * Added str_catf functions and used them in do_stat functions.
 *
 * Revision 1.98  2008/04/02 04:55:59  myc
 * Added a parse money function.
 *
 * Revision 1.97  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.
 *
 * Revision 1.96  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.95  2008/03/29 21:14:37  myc
 * Fix not-very-potential memory leak.
 *
 * Revision 1.94  2008/03/29 17:34:55  myc
 * Autodouse event memory leak.
 *
 * Revision 1.93  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.92  2008/03/26 22:22:56  jps
 * Better error checking/reporting in perform_random_gem_drop.
 *
 * Revision 1.91  2008/03/26 16:44:36  jps
 * Replaced all checks for undead race with checks for undead lifeforce.
 * Replaced the undead race with the plant race.
 *
 * Revision 1.90  2008/03/23 00:25:23  jps
 * Add a function to format applies, since it's done in at least
 * three places in the server.
 *
 * Revision 1.89  2008/03/22 21:24:25  jps
 * Some code formatting.
 *
 * Revision 1.88  2008/03/22 19:50:24  myc
 * Added strnlen implementation.
 *
 * Revision 1.87  2008/03/22 19:08:58  jps
 * Added parse_obj_name() function, which is a generalized function
 * for identifying structs.
 *
 * Revision 1.86  2008/03/21 21:59:31  jps
 * Add some more methods of pluralizing.
 *
 * Revision 1.85  2008/03/21 21:36:02  jps
 * Add functions without_article and pluralize, for modifying
 * nouns and noun phrases.
 *
 * Revision 1.84  2008/03/11 02:57:16  jps
 * Change state_weight and state_length to allow single-reentrancy.
 * Also, the ".0" on the end of a "tons" statement is suppressed.
 *
 * Revision 1.83  2008/03/10 20:49:47  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.82  2008/03/08 18:55:20  jps
 * Fix strip_cr
 *
 * Revision 1.81  2008/03/05 03:03:54  myc
 * Added sprintascii function.  Moved get_filename to players.c.  Got
 * rid of BOUNDED.  Added strip_cr and trim_spaces.
 *
 * Revision 1.80  2008/02/16 20:31:32  myc
 * Commented out str_dup to help disambiguate memory leaks.
 *
 * Revision 1.79  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not..
 *
 * Revision 1.78  2008/02/09 18:29:11  myc
 * The event code now takes care of freeing event objects.
 *
 * Revision 1.77  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.76  2008/02/09 03:06:17  myc
 * Moving mathematical functions to math.c.
 *
 * Revision 1.75  2008/02/06 21:53:53  myc
 * Slight bug in the levenshtein_distance function.
 *
 * Revision 1.74  2008/02/02 19:38:20  myc
 * Added a levenshtein distance calculator for use by the interpreter.
 * Also adding a count_color_chars function.
 *
 * Revision 1.73  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.72  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.71  2008/01/27 12:11:45  jps
 * Use exp factor from class.c.
 *
 * Revision 1.70  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.69  2008/01/25 21:11:52  myc
 * Renamed monk_weight_pen to monk_weight_penalty.
 *
 * Revision 1.68  2008/01/15 03:18:19  myc
 * Changed statemoney to accept an array instead of a pointer.
 *
 * Revision 1.67  2008/01/13 23:06:04  myc
 * Removed some unused functions: number_of_groupees (use group_size
 * instead), NumAttackers, SanityCheck, statsave, STAT_INDEX,
 * are_together (use is_grouped), and has_help.  Also cleaned up
 * movewords a bunch.
 *
 * Revision 1.66  2008/01/09 08:34:36  jps
 * Add functions to format strings for printin lengths and weights.
 *
 * Revision 1.65  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.64  2008/01/03 12:46:20  jps
 * New string function with_indefinite_article.
 * Renamed CLASS_MAGIC_USER to CLASS_SORCERER.
 *
 * Revision 1.63  2007/12/25 20:31:54  jps
 * Also make exp_group_bonus() not overflow.
 *
 * Revision 1.62  2007/12/25 20:28:57  jps
 * Change exp_highlevel_bonus() not to overflow with large values.
 *
 * Revision 1.61  2007/12/25 05:49:58  jps
 * event_target_valid() is of no further use in many places.
 * Actually, it sucks hard, but it's better than nothing in some
 * other places (such as fight.c).
 *
 * Revision 1.60  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.59  2007/12/20 03:04:11  jps
 * Fix ip formatting func.
 *
 * Revision 1.58  2007/12/19 20:57:58  myc
 * Added const modifiers to str_cmp, strn_cmp, log, touch, and mudlog.
 * Made is_playing check descriptor->original too.
 *
 * Revision 1.57  2007/11/22 23:33:23  jps
 * Added normalize_ip_address function.
 *
 * Revision 1.56  2007/10/11 20:35:06  myc
 * Since monks got nerfed a long time ago, decreasing the exp to level.
 *
 * Revision 1.55  2007/10/02 02:52:27  myc
 * Added AFF_SNEAK back in, so changed movewords.  Got rid of
 * stop_ignoring_me.  There's no way to check who you are ignoring now.
 *
 * Revision 1.54  2007/09/21 01:20:19  myc
 * Fixing escape_ansi's behavior with &&.
 *
 * Revision 1.53  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Changing movewords to handle this.
 *
 * Revision 1.52  2007/09/03 22:53:54  jps
 * Make a person's flames go out automatically if they enter a water room.
 *
 * Revision 1.51  2007/08/14 22:43:07  myc
 * Adding conceal, corner, shadow, and stealth skills.
 *
 * Revision 1.50  2007/08/04 14:40:35  myc
 * sprintbit couldn't handle the 32nd bit previously, because of an infinite
 * loop bug.  Now it's fine.
 *
 * Revision 1.49  2007/07/19 21:59:20  jps
 * Add utility funciton next_line.
 *
 * Revision 1.48  2007/07/14 04:18:11  jps
 * Pets (i.e., charmed mobs that were not charmed by a spell) will now
 * quit the game when attacked by their master, or when their master
 * leaves the game. The main reason is to keep powerful summoned
 * mounts out of the hands of other players, but it will also cut
 * back on clutter from ordinary mounts and pets.
 *
 * Revision 1.47  2007/07/02 04:40:05  jps
 * Fix off-by-one-crash-causing bug in format_text.
 *
 * Revision 1.46  2007/07/02 04:22:32  jps
 * Fix str_replace so you can't cause segfaults by increasing buffers
 * by one byte with /r command. And removed a minor memory leak.
 *
 * Revision 1.45  2007/06/24 02:51:44  jps
 * Add function startsvowel.
 *
 * Revision 1.44  2007/05/29 00:36:03  jps
 * Make a utility function find_zone, to find a zone's entry in the zone
 * table, from a vnum.
 *
 * Revision 1.43  2007/05/11 19:34:15  myc
 * Modified the quest command functions so they are thin wrappers for
 * perform_quest() in quest.c.  Error handling and messages should be
 * much better now.  Advance and rewind now accept another argument
 * specifying how many stages to advance or rewind.
 *
 * Revision 1.42  2007/04/18 00:05:59  myc
 * Prompt parser has been totally rewritten so it won't print garbage
 * characters anymore.  Also, some new features were added.  Giving the
 * prompt command back to mortals.
 *
 * Revision 1.41  2007/04/04 13:31:02  jps
 * Add year to log timestamps and other dates.
 *
 * Revision 1.40  2007/03/27 04:27:05  myc
 * Fixed crash bug in is_grouped...major group should be better behaved
 * now.
 *
 * Revision 1.39  2006/11/26 08:31:17  jps
 * Added function yesno_result to standardize handling of nanny's
 * yes/no questions (in interpreter.c).
 *
 * Revision 1.38  2006/11/18 09:08:15  jps
 * Add function statemoney to pretty-print coins
 *
 * Revision 1.37  2006/11/18 07:22:34  jps
 * Add isplural function
 *
 * Revision 1.36  2006/11/13 15:54:22  jps
 * Fix widespread misuse of the hide_invisible parameter to act().
 *
 * Revision 1.35  2006/11/13 02:48:27  jps
 * Fix pointer bug when reading a 0-length file.
 *
 * Revision 1.34  2006/11/11 16:13:08  jps
 * Fix CAP so it correctly capitalizes strings with color codes at the beginning.
 *
 * Revision 1.33  2006/11/08 09:16:40  jps
 * Fixed missing punctuation in "You have become new leader" messages
 *
 * Revision 1.32  2006/11/08 05:29:11  jps
 * Better code for trimming the end of formatted descs.
 *
 * Revision 1.31  2006/11/07 18:02:05  jps
 * Stop extra blank lines from appearing after /f or /fi formatting.
 *
 * Revision 1.30  2006/07/20 07:39:31  cjd
 * Typo fixes.
 *
 * Revision 1.29  2003/08/04 02:11:30  jjl
 * Enabled random gem drop on production.
 *
 * Revision 1.28  2003/08/02 17:42:50  jjl
 * Added a random gem drop for mobs under level 60, for Zzur's insano-quest.
 *
 * Revision 1.27  2003/06/23 01:47:09  jjl
 * Added a NOFOLLOW flag, and the "note" command, and show notes <player>
 *
 * Revision 1.26  2003/02/01 07:27:54  jjl
 * Bout time.  This should fix (at least part) of the necro / zombie crash
 * bug.  Sooooomeone used a 50 char buffer to store 80 character strings.
 * *sigh*
 *
 * Revision 1.25  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.24  2001/03/13 01:07:34  dce
 * Fixed some typos.
 *
 * Revision 1.23  2001/01/23 04:05:43  dce
 * Fixed a crash bug in the stop_groupee function. Someone put a mud
 * log before the free statement. And because the GET_NAME(ch) is no
 * longer valid it was causing a crash. So it was the mudlog fuction
 * sending nulls, that made it look like the free(k) was the problem
 * this was also a problem for multiple groupees. Both are fixed.
 *
 * Revision 1.22  2000/11/25 02:33:15  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.21  2000/10/27 00:34:45  mtp
 * extra define for saving quests info
 *
 * Revision 1.20  2000/04/22 22:44:10  rsd
 * fixed comment header. retabbed and braced sections of the code.
 * Also fixed grammital error in disband.
 *
 * Revision 1.19  1999/09/16 01:15:11  dce
 * Weight restrictions for monks...-hitroll, -damroll + ac
 *
 * Revision 1.18  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.17  1999/09/04 18:46:52  jimmy
 * More small but important bug fixes found with insure.  These are all runtime fixes.
 *
 * Revision 1.16  1999/08/14 02:43:10  dce
 * ** is one level up from 99
 *
 * Revision 1.15  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.14  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.13  1999/06/14 21:41:16  mud
 * fixed the monk XP multiplier to 2.5 where it should be. This was overwritten by someone
 * who checked in changes between version 1.09 and 1.10 without diffing.
 * --gurlaek 6/14/1999
 *
 * Revision 1.12  1999/06/11 17:18:40  jimmy
 * removed a really stupid log message that was spamming the syslog
 *
 * Revision 1.11  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.10  1999/05/04 17:19:33  dce
 * Name accept system...version one...original code by Fingh, fixed up to work
 * by Zantir.
 *
 * Revision 1.9  1999/05/02 20:29:30  mud
 * Ok, moved monks to an exp-factor of 2.5 in a compromise
 * with zantir grumble
 *
 * Revision 1.8  1999/05/02 20:25:51  mud
 * made the exp-factor 3.0 for the overpowered monks
 * take it back down when monks are balanced.
 *
 * Revision 1.7  1999/04/21 04:05:04  dce
 * New Exp system.
 * Exp_fix.c is the converter.
 *
 * Revision 1.6  1999/04/08 03:59:20  dce
 * Fixed a crash bug
 *
 * Revision 1.5  1999/03/25 20:18:18  jimmy
 * Added IS_NPC check to DRUNK code in movewards()
 * fingon
 *
 * Revision 1.4  1999/02/06 02:06:21  jimmy
 * I have no idea why, but a debug statment log(name)
 * actually makes this work.  Hmmmm.  Can't pfile wipe
 * without it.
 * --Fingon
 *
 * Revision 1.3  1999/02/03 21:03:25  mud
 * dos2unix
 * Indented file
 *
 * Revision 1.2  1999/02/01 08:20:33  jimmy
 * improved build counter
 *
 * Revision 1.1  1999/01/29 01:23:32  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.129
log
@Added an optimization to log which checks to see if the message
to be printed has any %'s before attempting to vfprintf.  This
can save some time, but to see whether it's really worth it,
we're going to count the number of times each branch is used and
log it.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.128 2009/06/09 05:51:26 myc Exp myc $
d710 1
a710 1
    mudlog(buf, NRM, LVL_IMMORT, FALSE);
d1104 7
@


1.128
log
@Adding NUM_PRV_FLAGS to the init_flagvectors array.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.127 2009/03/09 05:51:25 jps Exp myc $
d152 3
d158 18
a175 4
  va_start(args, str);
  vfprintf(stderr, str, args);
  va_end(args);
  fprintf(stderr, "\n");
d1104 3
@


1.127
log
@Moved some money-related functions from utils to money
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.126 2009/03/09 05:41:31 jps Exp jps $
d255 2
d1087 3
@


1.126
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.125 2009/03/09 03:33:03 myc Exp jps $
a706 143
void statemoney(char *buf, int coins[]) {
   int ctypes = 0, ctype2 = 0, amount = 0, i;

   for (i = 0; i < 4; i++) {
      if (coins[i]) {
         amount += coins[i];
         ctypes++;
         if (ctypes == 2)
            ctype2 = i;
      }
   }

   if (coins[PLAT]) {
      sprintf(buf, "%s &0&b&6%d &0platinum&0", buf, coins[0]);
      if (ctypes == 2)
         sprintf(buf, "%s and", buf);
      else if (ctypes > 2)
         sprintf(buf, "%s,", buf);
   }
   if (coins[GOLD]) {
      sprintf(buf, "%s &0&b&3%d &0gold&0", buf, coins[1]);
      if (ctypes == 2 && ctype2 != 1)
         sprintf(buf, "%s and", buf);
      else if (ctypes == 4 || (ctypes ==3 && ctype2 == 2) )
         sprintf(buf, "%s,", buf);
      else if (ctypes == 3)
         sprintf(buf, "%s, and", buf);
   }
   if (coins[SILVER]) {
      sprintf(buf, "%s %d silver", buf, coins[2]);
      if (ctypes == 2 && ctype2 != 2)
         sprintf(buf, "%s and", buf);
      else if (ctypes == 4 || (ctypes == 3 && ctype2 == 2))
         sprintf(buf, "%s, and", buf);
   }
   if (coins[COPPER])
      sprintf(buf, "%s &0&3%d&0 copper", buf, coins[3]);
   if (amount > 1)
      strcat(buf, " coins");
   else
      strcat(buf, " coin");
}

void briefmoneyelement(char *buf, int cointype, int amount)
{
   switch (cointype) {
      case PLAT:
         sprintf(buf, "%s&6&b%dp&0", buf, amount);
         break;
      case GOLD:
         sprintf(buf, "%s&3&b%dg&0", buf, amount);
         break;
      case SILVER:
         sprintf(buf, "%s&7&b%ds&0", buf, amount);
         break;
      case COPPER:
         sprintf(buf, "%s&3%dc&0", buf, amount);
         break;
      default:
         sprintf(buf, "%s&5%d?&0", buf, amount);
         break;
   }
}

/* Prints a string about some money, in the requested number of spaces,
 * using at most two types of coin. */
void briefmoney(char *buf, int spaces, int amt) {
   bool topset = FALSE;
   bool lowset = FALSE;
   int toptype = 0, topval = 0, topchars = 0,
       lowtype = 0, lowval = 0, lowchars = 0;
   int i, maxval = 9;
   int coins[4];

   /* Limit the number of digits so that there's 1 spot left over for a
    * coin-type designator (p, g, s, or c) */
   for (i = 0; i < spaces - 1; i++) {
      maxval = maxval * 10 + 9;
   }

   coins[PLAT] = amt / 1000;
   coins[GOLD] = (amt % 1000) / 100;
   coins[SILVER] = (amt % 100) / 10;
   coins[COPPER] = amt % 10;

   for (i = 0; i < 4; i++) {
      if (coins[i]) {
         if (!topset) {
            topset = TRUE;
            toptype = i;
            topval = coins[i];
            topchars = sprintf(buf, "%d", topval); /* count digits */
         } else if (!lowset) {
            lowset = TRUE;
            lowtype = i;
            lowval = coins[i];
            lowchars = sprintf(buf, "%d", lowval); /* count digits */
         }
      }
   }

   /* If the top coin type and low coin type can't fit within the requested
    * space, only the top will be used */
   if (lowset && lowchars + topchars > spaces - 2)
      lowset = FALSE;

   *buf = '\0';

   if (topset) {
      briefmoneyelement(buf, toptype, topval > maxval ? maxval : topval);
      if (lowset)
         briefmoneyelement(buf, lowtype, lowval);
   } else {
      sprintf(buf, "0");
   }
}

bool parse_money(char *money, int coins[])
{
  char arg[MAX_INPUT_LENGTH];
  int amount, type;

  coins[PLAT] = 0;
  coins[GOLD] = 0;
  coins[SILVER] = 0;
  coins[COPPER] = 0;

  skip_spaces(&money);

  while (*money) {
    money = any_one_arg(money, arg);
    if (!is_number(arg))
      return FALSE; /* Not a number! */
    amount = atoi(arg);
    money = any_one_arg(money, arg);
    if ((type = search_block(arg, coin_names, FALSE)) < 0)
      return FALSE;
    coins[type] += amount;
  }

  return TRUE;
}

d1085 3
@


1.125
log
@Split off string functions from this file into strings.c
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.124 2009/03/08 23:34:14 jps Exp myc $
d37 1
d1228 3
@


1.124
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.123 2009/03/08 21:43:27 jps Exp jps $
a135 54
/* str_cmp: a case-insensitive version of strcmp */
/* returns: 0 if equal, 1 if arg1 > arg2, -1 if arg1 < arg2  */
/* scan 'till found different or end of both                 */
int str_cmp(const char *arg1, const char *arg2)
{
  int chk, i;

  for (i = 0; *(arg1 + i) || *(arg2 + i); i++)
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i)))) {
      if (chk < 0)
        return (-1);
      else
        return (1);
    }
  return (0);
}


/* strn_cmp: a case-insensitive version of strncmp */
/* returns: 0 if equal, 1 if arg1 > arg2, -1 if arg1 < arg2  */
/* scan 'till found different, end of both, or n reached     */
int strn_cmp(const char *arg1, const char *arg2, int n)
{
  int chk, i;

  for (i = 0; (*(arg1 + i) || *(arg2 + i)) && (n > 0); i++, n--)
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i)))) {
      if (chk < 0)
        return (-1);
      else
        return (1);
    }
  return (0);
}

#ifndef strnlen
size_t strnlen(register const char *str, register size_t maxlen)
{
  const char *end = (const char *) memchr(str, '\0', maxlen);
  return end ? end - str : maxlen;
}
#endif


void smash_tilde(char *str)
{
  /* Erase any _line ending_ tildes inserted in the editor.  The load 
   * mechanism can't handle those yet. -Welcor */
  char *p = str;
  for (; *p; p++)
    if (*p == '~' && (*(p+1)=='\r' || *(p+1)=='\n' || *(p+1)=='\0'))
      *p=' ';
}

a244 81
void sprintbit(long bitvector, const char *names[], char *result)
{
  long nr, i;
  char *orig_pos = result;

  /* Assuming 8 bits to a byte... */
  for (i = 0, nr = 0; (i < sizeof(bitvector) * 8) && bitvector; ++i) {
    if (IS_SET(bitvector, (1 << i))) {
      if (*names[nr] != '\n')
        strcpy(result, names[nr]);
      else
        strcpy(result, "UNDEFINED");
      result += strlen(result);
      *(result++) = ' ';
    }
    if (*names[nr] != '\n')
      ++nr;
  }

  if (orig_pos == result)
    strcpy(result, "NO BITS");
  else
    *result = '\0'; /* Nul terminate */
}

void sprinttype(int type, const char *names[], char *result)
{
  int nr = 0;

  while (type && *names[nr] != '\n') {
    type--;
    nr++;
  }

  if (*names[nr] != '\n')
    strcpy(result, names[nr]);
  else
    strcpy(result, "UNDEFINED");
}

void sprintflag(char *result, flagvector flags[], int num_flags, const char *names[])
{
  int i, nr = 0;
  char *orig_pos = result;

  for (i = 0; i < num_flags; ++i) {
    if (IS_FLAGGED(flags, i)) {
      if (*names[nr] != '\n')
        strcpy(result, names[nr]);
      else
        strcpy(result, "UNDEFINED");
      result += strlen(result);
      *(result++) = ' ';
    }
    if (*names[nr] != '\n')
      ++nr;
  }

  if (orig_pos == result)
    strcpy(result, "NO FLAGS");
  else
    *(result - 1) = '\0'; /* Nul terminate */
}

int sprintascii(char *out, flagvector bits)
{
  int i, j = 0;
  /* 32 bits, don't just add letters to try to get more unless flagvector is also as large. */
  char *flags = "abcdefghijklmnopqrstuvwxyzABCDEF";

  for (i = 0; flags[i]; ++i)
    if (bits & (1 << i))
      out[j++] = flags[i];

  if (j == 0) /* Didn't write anything. */
    out[j++] = '0';

  /* Nul terminate the output string. */
  out[j++] = '\0';
  return j;
}
a491 189
/* substitute appearances of 'pattern' with 'replacement' in string */
/* and return the # of replacements or -1 if none were made
 * due to lack of space */
int replace_str(char **string, const char *pattern, const char *replacement,
                int rep_all, int max_size) {
  char *replace_buffer = NULL;
  char *flow, *jetsam, temp;
  int len, i;

  if ((int)((strlen(*string) - strlen(pattern)) + strlen(replacement)) >= max_size)
    return -1;

  CREATE(replace_buffer, char, max_size + 1);
  i = 0;
  jetsam = *string;
  flow = *string;
  *replace_buffer = '\0';
  if (rep_all) {
    while ((flow = (char *)strstr(flow, pattern)) != NULL) {
      if ((int)((strlen(replace_buffer) + strlen(jetsam) - strlen(pattern) + strlen(replacement))) > max_size) {
         i = -1;
         break;
      }
      i++;
      temp = *flow;
      *flow = '\0';
      strcat(replace_buffer, jetsam);
      strcat(replace_buffer, replacement);
      *flow = temp;
      flow += strlen(pattern);
      jetsam = flow;
    }
    strcat(replace_buffer, jetsam);
  } else {
    if ((flow = (char *)strstr(*string, pattern)) != NULL) {
      i++;
      flow += strlen(pattern);
      len = ((char *)flow - (char *)*string) - strlen(pattern);

      strncpy(replace_buffer, *string, len);
      strcat(replace_buffer, replacement);
      strcat(replace_buffer, flow);
    }
  }
  if (i > 0) {
    RECREATE(*string, char, strlen(replace_buffer) + 3);
    strcpy(*string, replace_buffer);
  }
  free(replace_buffer);
  return i;
}


/* re-formats message type formatted char * */
/* (for strings edited with d->str) (mostly olc and mail)     */
void format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen) {
  int total_chars, cap_next = TRUE, cap_next_next = FALSE;
  char *flow, *start = NULL, temp;
  /* warning: do not edit messages with max_str's of over this value */
  char formated[MAX_STRING_LENGTH];

  flow   = *ptr_string;
  if (!flow) return;

  if (IS_SET(mode, FORMAT_INDENT)) {
    strcpy(formated, "   ");
    total_chars = 3;
  }
  else {
    *formated = '\0';
    total_chars = 0;
  }

  while (*flow != '\0') {
    while ((*flow == '\n') ||
           (*flow == '\r') ||
           (*flow == '\f') ||
           (*flow == '\t') ||
           (*flow == '\v') ||
           (*flow == ' ')) flow++;

    if (*flow != '\0') {

      start = flow++;
      while ((*flow != '\0') &&
             (*flow != '\n') &&
             (*flow != '\r') &&
             (*flow != '\f') &&
             (*flow != '\t') &&
             (*flow != '\v') &&
             (*flow != ' ') &&
             (*flow != '.') &&
             (*flow != '?') &&
             (*flow != '!')) flow++;

      if (cap_next_next) {
        cap_next_next = FALSE;
        cap_next = TRUE;
      }

      /* this is so that if we stopped on a sentance .. we move off the sentance delim. */
      while ((*flow == '.') || (*flow == '!') || (*flow == '?')) {
        cap_next_next = TRUE;
        flow++;
      }

      temp = *flow;
      *flow = '\0';

      if ((total_chars + strlen(start) + 1) > 79) {
        strcat(formated, "\r\n");
        total_chars = 0;
      }

      if (!cap_next) {
        if (total_chars > 0) {
          strcat(formated, " ");
          total_chars++;
        }
      }
      else {
        cap_next = FALSE;
        *start = UPPER(*start);
      }

      total_chars += strlen(start);
      strcat(formated, start);

      *flow = temp;
    }

    if (cap_next_next) {
      if ((total_chars + 3) > 79) {
        strcat(formated, "\r\n");
        total_chars = 0;
      }
      else {
        strcat(formated, "  ");
        total_chars += 2;
      }
    }
  }

  /* Trim trailing spaces, + possible extraneous newline. */
  flow = formated + strlen(formated) - 1;
  while (flow > formated && isspace(*flow))
     *(flow--) = 0;

  strcat(formated, "\r\n");

  if ((int)(strlen(formated)) > maxlen) formated[maxlen] = '\0';
  RECREATE(*ptr_string, char, MIN(maxlen + 1, strlen(formated)+3));
  strcpy(*ptr_string, formated);
}

/* strips \r's from line */
char *stripcr(char *dest, const char *src) {
  int i, length;
  char *temp;

  if (!dest || !src) return NULL;
  temp = &dest[0];
  length = strlen(src);
  for (i = 0; *src && (i < length); i++, src++)
    if (*src != '\r') *(temp++) = *src;
  *temp = '\0';
  return dest;
}

/* Returns a duplicate of the next line of text in src, up to the
 * newline.  Moves src to the beginning of the line after that.
 * Returns NULL if there is no more text. */
char *next_line(char **src) {
   char *l, *s = *src;
   int len = 0;

   if (!*s) return NULL;

   for (len = 0; *s && *s != '\r' && *s != '\n'; s++, len++);

   l = (char *)malloc(len + 1);
   memcpy(l, *src, len);
   l[len] = '\0';

   while (*s && (*s == '\r' || *s == '\n')) s++;
   *src = s;

   return l;
}
a704 20
void cap_by_color(char *s) {
   char *b = s;

   while (*b && (*b == CREL || *b == CABS))
      b += 2;

   if (*b) *b = UPPER(*b);
}

bool isplural(char *namelist)
{
   register char *point;

   for (point = namelist; *point && *point != ' '; point++);

   if (point == namelist || *(point - 1) != 's')
      return FALSE;

   return TRUE;
}
a869 19
int startsvowel(const char *s) {
   const char *t;

   for (t = s; *s;) {
      if (*s == CREL || *s == CABS) {
         s++;
         if (*s == '\0')
            return 0;
         s++;
      } else if (*s == 'A' || *s == 'a' || *s == 'E' || *s == 'e' ||
            *s == 'I' || *s == 'i' || *s == 'O' || *s == 'o' ||
            *s == 'U' || *s == 'u')
         return 1;
      else
         return 0;
   }
   return 0;

}
a921 241
/* Return a string that has the given string, with "a " or "an " prepended,
 * depending on whether the given string starts with a vowel.
 *
 * This is intended for short strings like names, which is why we use a
 * somewhat small buffer.  The returned value should be used immediately
 * and not modified, as it's a static buffer here.  If the passed string
 * is too long for the static buffer, the returned string will be truncated.
 *
 * We employ some hackery so that you can use it up to THREE (count 'em)
 * times within the same *printf() call.  That's all you get.
 */

char *with_indefinite_article(const char *s)
{
   static char iabuf1[MAX_STRING_LENGTH];
   static char iabuf2[MAX_STRING_LENGTH];
   static char iabuf3[MAX_STRING_LENGTH];
   static int lastbuf;

   const char *t;
   char *u, *ret, fcbuf[2];
   bool isvowel = FALSE;

   /* Choose the static buffer to be used. */
   if (lastbuf < 0 || lastbuf > 1)
      lastbuf = 0;
   else
      lastbuf++;

   /* Find the first alphabetical character in the string, skipping
    * ansi codes.  Even though it will skip over spaces here, you should
    * not pass a string with any leading spaces, because the result will
    * have too many. */
   t = s;
   while (*t && !isalpha(*t)) {
      if (*t == CREL || *t == CABS) {
         t++;
         if (!*t)
            break;
      }
      t++;
   }

   /* Create a string of length one to pass to strstr(). */
   if (*t) {
      fcbuf[0] = *t;
      fcbuf[1] = '\0';
      if (strstr("AEIOUaeiou", fcbuf))
         isvowel = TRUE;
   }

   /* Construct the returned string.  Start with the article + a space. */
   switch (lastbuf) {
      case 0:
         u = iabuf1;
         break;
      case 1:
         u = iabuf2;
         break;
      default:
         u = iabuf3;
   }
   ret = u;
   *u++ = 'a';
   if (isvowel)
      *u++ = 'n';
   *u++ = ' ';

   /* Append the provided string to the returned string. */
   t = s;
   while (*t && u - ret < MAX_STRING_LENGTH - 1)
      *u++ = *t++;
   *u = '\0';

   return ret;
}

/* without_article()
 *
 * Returns a string which matches the given string, except that any
 * leading article has been removed.
 */

const char *without_article(const char *s)
{
   /* - end this list with "\n"
    * - each entry must have a trailing space
    * - if an entry is the same as the start of another entry,
    *   then the longer one must come first (e.g., "a pair " must
    *   come before "a ").
    */
   const char *articles[] = {
      "a pair ",
      "a ",
      "an ",
      "some ",
      "the ",
      "\n"
   };

   int i;

   for (i = 0; articles[i][0] != '\n'; i++) {
      if (!strncmp(articles[i], s, strlen(articles[i]))) {
         return s + strlen(articles[i]);
      }
   }
   return s;
}

#define IS_LETTER(c) (isalpha(c))
#define IS_VOWEL(c) (tolower(c) == 'a' || tolower(c) == 'e' || \
      tolower(c) == 'i' || tolower(c) == 'o' || \
      tolower(c) == 'u')
#define IS_CONSONANT(c) (IS_LETTER(c) && !IS_VOWEL(c))

/* Create a plural of a single word.
 * You could pass an entire phrase if you wanted.
 * This function will only look at the last word in the string.
 */
const char *word_pluralize(const char *s)
{
   static char plbuf[MAX_STRING_LENGTH];

   char *u = plbuf;
   int len, newlen;

   /* Apply comon rules */

   len = strlen(s);
   /* We will need to add up to 2 characters on the end */
   newlen = MIN(MAX_STRING_LENGTH - 3, len);
   strncpy(u, without_article(s), newlen);
   u[newlen] = '\0';
   len = strlen(u);

   /* Single character: add 's (and avoid errors with u[len - 2] below) */
   if (len < 2) {
      u[len] = '\'';
      u[len + 1] = 's';
      u[len + 2] = '\0';
      return u;
   }

   /* Ending in ez or iz: add zes */
   if ((u[len - 2] == 'e' || u[len - 2] == 'i') && u[len - 1] == 'z') {
      u[len] = 'z';
      u[len + 1] = 'e';
      u[len + 2] = 's';
      u[len + 3] = '\0';
      return u;
   }

   /* Ending in: x, z (except ez or iz, handled above), sh, ss, ch, <C>o, <C>y: add es */
   if (u[len - 1] == 'x' ||
         u[len - 1] == 'z' ||
         (u[len - 2] == 's' && u[len - 1] == 'h') ||
         (u[len - 2] == 's' && u[len - 1] == 's') ||
         (u[len - 2] == 'c' && u[len - 1] == 'h') ||
         (IS_CONSONANT(u[len - 2]) && u[len - 1] == 'o') ||
         (IS_CONSONANT(u[len - 2]) && u[len - 1] == 'y')
         ) {
      u[len] = 'e';
      u[len + 1] = 's';
      u[len + 2] = '\0';
      if (u[len - 1] == 'y') u[len - 1] = 'i'; /* -y = -ies */
      return u;
   }

   /* Other: add s */
   u[len] = 's';
   u[len + 1] = '\0';
   return u;
}

const char *pluralize(const char *s)
{
   static char plbuf1[MAX_STRING_LENGTH];
   static char plbuf2[MAX_STRING_LENGTH];
   static char plbuf3[MAX_STRING_LENGTH];
   static int lastbuf;

   char *u;
   const char *word;
   int i, spaces, spacepos[2], newlen;

   /* Choose the static buffer to be used. */
   if (lastbuf < 0 || lastbuf > 1)
      lastbuf = 0;
   else
      lastbuf++;

   switch (lastbuf) {
      case 0:
         u = plbuf1;
         break;
      case 1:
         u = plbuf2;
         break;
      default:
         u = plbuf3;
   }

   /* Begin analyzing the given string */

   /* First deal with "some" */
   if (!strncmp("some ", s, strlen("some "))) {
      sprintf(u, "quantities of %s", s + strlen("some "));
      return u;
   }

   /* Then look for "<article> <name> OF <...>" */
   spaces = 0;
   for (i = 0; i < MAX_STRING_LENGTH && spaces < 2 && s[i]; i++) {
      if (s[i] == ' ') {
         spacepos[spaces] = i;
         spaces++;
      }
   }
   if (spaces == 2 &&
         s[i - 1] == ' ' &&
         s[i] == 'o' && s[i + 1] == 'f' &&
         s[i + 2] == ' ') {
      /* We have <article> <name> OF */
      /* Such as "a handful of sand" */
      strncpy(u, s + spacepos[0] + 1, spacepos[1] - spacepos[0] - 1); /* "handful" */
      u[spacepos[1] - spacepos[0] - 1] = '\0';
      word = word_pluralize(u); /* "handfuls" */
      sprintf(u, "%s %s", word, s + spacepos[1] + 1); /* "handfuls of sand" */
      return u;
      /* "a ring of fire" -> "rings of fire" */
   }

   /* Finally just apply common rules */
   word = word_pluralize(s);
   newlen = MIN(MAX_STRING_LENGTH - 1, strlen(word));
   strncpy(u, word, newlen);
   u[newlen] = '\0';
   return u;
}

a985 54
int levenshtein_distance(const char *s1, const char *s2)
{
  int s1_len = strlen(s1), s2_len = strlen(s2);
  int **d, i, j;

  CREATE(d, int *, s1_len + 1);

  for (i = 0; i <= s1_len; ++i) {
    CREATE(d[i], int, s2_len + 1);
    d[i][0] = i;
  }

  for (j = 0; j <= s2_len; ++j)
    d[0][j] = j;

  for (i = 1; i <= s1_len; ++i)
    for (j = 1; j <= s2_len; ++j)
      d[i][j] = MIN(d[i - 1][j] + 1, MIN(d[i][j - 1] + 1,
      d[i - 1][j - 1] + ((s1[i - 1] == s2[j - 1]) ? 0 : 1)));

  i = d[s1_len][s2_len];

  for (j = 0; j <= s1_len; ++j)
    free(d[j]);
  free(d);

  return i;
}

/*
 * This trims spaces in place, shifting the string to the left if necessary.
 */
void trim_spaces(char *buffer)
{
  char *pos;

  if (!buffer)
    return;

  /* Trim leading spaces */
  if (isspace(*buffer)) {
    char *wpos = buffer;
    pos = buffer;
    while (isspace(*pos)) ++pos;
    while (*pos) *(wpos++) = *(pos++);
    *wpos = '\0';
  }

  /* Trim trailing spaces */
  pos = buffer + strlen(buffer) - 1;
  while (pos > buffer && isspace(*pos))
    *(pos--) = '\0';
}

a1069 188
char *strip_chars(char *str, const char *chars)
{
  return filter_chars(str, str, chars);
}

char *filter_chars(char *buf, register const char *src, const char *chars)
{
  register char *dest = buf;

  while ((*dest = *src)) {
    if (!strchr(chars, *dest))
      ++dest;
    ++src;
  }

  return buf;
}

#define MAX_STR_TOKENS   50
#define STR_HASH_BUCKETS 32
#define VALID_STR_TOKEN(tok) ((tok) >= 0 && (tok) < 50)
static struct str_token {
  char *buf;
  char *pos;
  size_t size;
  str_token next_in_hash;
} str_data[MAX_STR_TOKENS];
static int next_str_token = 0;
static str_token str_hash[STR_HASH_BUCKETS] = { NULL };
#define STR_HASH(addr)   (((int) (addr)) % STR_HASH_BUCKETS)
#define SPACE_USED(tok)  ((tok)->pos - (tok)->buf + 1)
#define SPACE_LEFT(tok)  ((tok)->size - SPACE_USED(tok))

static void kill_str_token(char *buf)
{
  str_token x, tok;
  for (x = str_hash[STR_HASH(buf)]; x; x = x->next_in_hash) {
    if (x->buf == buf) {
      if (x == str_hash[STR_HASH(buf)])
        str_hash[STR_HASH(buf)] = x->next_in_hash;
      else
        for (tok = str_hash[STR_HASH(buf)]; tok && tok->next_in_hash; tok = tok->next_in_hash)
          if (tok->next_in_hash == x)
            tok->next_in_hash = x->next_in_hash;
      break;
    }
  }
}

static str_token new_str_token(char *buf, size_t max_size)
{
  str_token tok;
  str_token new_token = &str_data[(next_str_token++) % MAX_STR_TOKENS];

  kill_str_token(buf);
  kill_str_token(new_token->buf);

  new_token->buf = buf;
  new_token->pos = buf;
  new_token->size = max_size;
  new_token->next_in_hash = NULL;

  for (tok = str_hash[STR_HASH(buf)]; tok && tok->next_in_hash; tok = tok->next_in_hash);
  if (tok)
    tok->next_in_hash = new_token;
  else
    str_hash[STR_HASH(buf)] = new_token;

  return new_token;
}

static str_token find_str_token(char *buf)
{
  str_token tok;
  for (tok = str_hash[STR_HASH(buf)]; tok; tok = tok->next_in_hash)
    if (tok->buf == buf)
      return tok;
  return NULL;
}

static void str_update(str_token token)
{
  if (*token->pos)
    token->pos += strlen(token->pos);
}

str_token str_start(char *buf, size_t max_size)
{
  *buf = '\0';
  return new_str_token(buf, max_size);
}

size_t str_space(char *buf)
{
  str_token token = find_str_token(buf);
  str_update(token);
  return token ? SPACE_LEFT(token) : 0;
}

void str_cat(char *buf, const char *str)
{
  str_token token = find_str_token(buf);

  if (token) {
    str_update(token);
    if (SPACE_LEFT(token) > 0) {
      /* Using strncat because strncpy is stupid */
      strncat(token->pos, str, SPACE_LEFT(token));
      str_update(token);
    }
  }
  else
    strcat(buf, str);
}

void strn_cat(char *buf, const char *str, size_t size)
{
  str_token token = find_str_token(buf);

  if (token) {
    str_update(token);
    if (SPACE_LEFT(token) > 0) {
      /* Using strncat because strncpy is stupid */
      strncat(token->pos, str, MIN(SPACE_LEFT(token), size));
      str_update(token);
    }
  }
  else
    strncat(buf, str, size);
}

void str_catf(char *buf, const char *format, ...)
{
  va_list args;
  str_token token = find_str_token(buf);
  int size;

  va_start(args, format);

  if (token) {
    str_update(token);
    if (SPACE_LEFT(token) > 0) {
      size = vsnprintf(token->pos, SPACE_LEFT(token), format, args);
      token->pos += (size > SPACE_LEFT(token) ? SPACE_LEFT(token) : size);
    }
  }
  else {
    buf += strlen(buf);
    vsprintf(buf, format, args);
  }

  va_end(args);
}

void strn_catf(char *buf, size_t size, const char *format, ...)
{
  va_list args;
  str_token token = find_str_token(buf);
  int printed;

  va_start(args, format);

  if (token) {
    str_update(token);
    size = MIN(SPACE_LEFT(token), size);
    if (size > 0) {
      printed = vsnprintf(token->pos, size, format, args);
      token->pos += (printed > size ? size : printed);
    }
  }
  else {
    buf += strlen(buf);
    vsnprintf(buf, size, format, args);
  }

  va_end(args);
}

char *str_end(char *buf)
{
  str_token token = find_str_token(buf);
  if (!token)
    return buf + strlen(buf);
  str_update(token);
  return token->pos;
}


d1227 3
@


1.123
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.122 2009/02/21 03:30:16 myc Exp jps $
d24 1
a24 1
#include "spells.h"
d2073 3
@


1.122
log
@Removed L_FILE flag--mprintf now logs to file by default;
assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.121 2009/02/11 17:03:39 myc Exp myc $
d35 2
a36 1

d2073 4
@


1.121
log
@Add smash_tilde(), which removes tildes from the end of lines.
Make str_ functions take const formats.  Check EDITING(d)
where PLR_WRITING is checked in mudlog.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.120 2009/01/17 00:28:02 myc Exp myc $
d192 1
a192 2
  mprintf(L_STAT | L_FILE, LVL_IMMORT,
          "%s hit death trap #%d (%s)", GET_NAME(ch),
d239 1
a239 1
    case CMP: type = L_DBUG; break;
d241 2
a242 2
  if (file)
    type |= L_FILE;
d263 1
a263 1
  if (IS_SET(severity, L_FILE))
d265 2
a266 2
  /* Drop the L_FILE bit if it was set */
  REMOVE_BIT(severity, L_FILE);
d284 1
a284 1
  REMOVE_BIT(severity, L_FILE);
d2072 5
@


1.120
log
@Fix possible use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.119 2008/09/25 04:47:49 jps Exp myc $
d179 10
d277 1
a277 1
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING))
d1827 1
a1827 1
void str_cat(char *buf, char *str)
d1843 1
a1843 1
void strn_cat(char *buf, char *str, size_t size)
d1859 1
a1859 1
void str_catf(char *buf, char *format, ...)
d1882 1
a1882 1
void strn_catf(char *buf, size_t size, char *format, ...)
d2073 3
@


1.119
log
@Add drop_core() function, to drop the mud's core without terminating.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.118 2008/09/22 02:09:17 jps Exp jps $
d1109 2
a1110 1
   int toptype, topval, topchars, lowtype, lowval, lowchars;
d2063 3
@


1.118
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.117 2008/09/21 21:21:29 jps Exp jps $
d18 1
d2019 41
d2062 4
@


1.117
log
@Remove debugging printf.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.116 2008/09/21 20:40:40 jps Exp jps $
d1544 1
a1544 1
char *stateweight(int pounds)
d1561 1
a1561 1
      sprintf(res, "%d pound%s", pounds,
d2020 3
@


1.116
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.115 2008/09/07 20:06:13 jps Exp jps $
d996 1
a996 2
  printf("perform_random_gem_drop (%s)\n", GET_NAME(ch));
  if (!vnum) {
a997 1
  }
d2020 4
@


1.115
log
@Changed the exp needed for level 100 so that it's the same as the amount
we've always been requiring due to a bug.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.114 2008/09/07 18:45:15 jps Exp jps $
d996 1
d2022 4
@


1.114
log
@Added briefmoney function for printing the top two coins of a money
value in a given number of spaces. With color.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.113 2008/09/04 06:47:36 jps Exp jps $
d84 1
a84 1
    else if (lvl <= LVL_IMMORT) {
d92 14
d115 1
a115 1
long exp_to_level(int level, int class)
d125 1
a125 1
  if (level > LVL_IMMORT)
d2021 4
@


1.113
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.112 2008/09/01 23:47:49 jps Exp jps $
d1069 73
d2007 3
@


1.112
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.111 2008/08/31 04:17:55 myc Exp jps $
d836 1
a836 1
    if (SECT(ch->in_room) == SECT_WATER_SWIM)
d839 1
a839 1
    if (SECT(ch->in_room) == SECT_WATER_NOSWIM)
d1934 3
@


1.111
log
@Fix exp for level 100.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.110 2008/08/30 04:13:45 myc Exp myc $
a531 218
/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_follower(struct char_data * ch, int violent)
{
  struct follow_type *j, *k;

  assert(ch->master);

  if (EFF_FLAGGED(ch, EFF_CHARM)) {
     if (DECEASED(ch))
        send_to_char("A wave of sorrow nearly overcomes you.\r\n", ch->master);
     else if (violent) {
       act("You realize that $N is a jerk!", FALSE, ch, 0, ch->master, TO_CHAR);
       act("$n realizes that $N is a jerk!", FALSE, ch, 0, ch->master, TO_NOTVICT);
       act("$n hates your guts!", FALSE, ch, 0, ch->master, TO_VICT);
     }
    if (affected_by_spell(ch, SPELL_CHARM))
      effect_from_char(ch, SPELL_CHARM);

  } else if (EFF_FLAGGED(ch, EFF_SHADOWING)) {
    act("You stop shadowing $N.", TRUE, ch, 0, ch->master, TO_CHAR);
  } else {
    act("You stop following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n stops following $N.", TRUE, ch, 0, ch->master, TO_NOTVICT);
    act("$n stops following you.", TRUE, ch, 0, ch->master, TO_VICT);
  }

  if (ch->master->followers->follower == ch) {        /* Head of follower-list? */
    k = ch->master->followers;
    ch->master->followers = k->next;
    free(k);
  } else {                        /* locate follower who is not head of list */
    for (k = ch->master->followers; k->next->follower != ch; k = k->next);

    j = k->next;
    k->next = j->next;
    free(j);
  }

  if (EFF_FLAGGED(ch, EFF_CHARM)) {
     REMOVE_FLAG(EFF_FLAGS(ch), EFF_CHARM);

     /* The following is necessary to prevent the sharing of summoned mounts.
      * If the mob were not removed from the game at this point, a paladin
      * could attack his mount, then flee from the fight, and when he left
      * the game the mount would remain. So we remove it now. Fighting your
      * summoned mount is irrelevant anyway (you get no xp). */

     if (IS_NPC(ch))
        event_create(EVENT_MOB_QUIT, mobquit_event, ch, FALSE,
              &(ch->events), 3 RL_SEC);
  }

  REMOVE_FLAG(EFF_FLAGS(ch), EFF_SHADOWING);
  ch->master = NULL;
}



/* Called when a character that follows/is followed dies */
void die_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master)
    stop_follower(ch, 0);

  for (k = ch->followers; k; k = j) {
    j = k->next;
    stop_follower(k->follower, 0);
  }
}

void add_groupee(struct char_data *master, struct char_data *groupee)
{
  struct group_type *g;

  if (IS_GROUPED(groupee))
    return;

  act("&2&8You accept $N &2&8into your group.&0",
      FALSE, master, 0, groupee, TO_CHAR);
  act("&2&8You have been accepted into $n&2&8's group.&0",
      FALSE, master, 0, groupee, TO_VICT);
  for (g = master->groupees; g; g = g->next)
    act("&2&8$N &2&8has joined your group.&0",
        TRUE, g->groupee, 0, groupee, TO_CHAR);

  CREATE(g, struct group_type, 1);
  g->groupee = groupee;
  g->next = master->groupees;
  master->groupees = g;
  groupee->group_master = master;
}

void disband_group(struct char_data *master, bool verbose, bool forceful)
{
  struct group_type *g;

  assert (master->groupees);

  if (verbose)
    send_to_char(forceful ? "&2&8The group has been disbanded.&0\r\n" :
                            "&2&8You disband the group.&0\r\n", master);

  while (master->groupees) {
    g = master->groupees;
    g->groupee->group_master = NULL;
    master->groupees = g->next;
    if (verbose)
      act(forceful ? "&2&8The group has been disbanded.&0\r\n" :
                     "&2&8$n &2&8has disbanded the group.&0\r\n",
          FALSE, master, 0, g->groupee, TO_VICT);
    free(g);
  }
}

void ungroup(struct char_data *ch, bool verbose, bool forceful)
{
  /* Character is a group leader... */
  if (ch->groupees) {

    /* Only one other group member? Disband. */
    if (!ch->groupees->next)
      disband_group(ch, verbose, FALSE);

    /* Otherwise promote first group member to new leader. */
    else {
      struct group_type *g;
      struct char_data *new_master = ch->groupees->groupee;

      if (verbose) {
        send_to_char("&2&8You're no longer leading your group.&0\r\n", ch);
        send_to_char("&2&8You're now leading the group!&0\r\n", new_master);
      }

      /* Move groupees to new master. */
      new_master->groupees = ch->groupees->next;
      new_master->group_master = NULL;
      for (g = new_master->groupees; g; g = g->next) {
        g->groupee->group_master = new_master;
        if (verbose)
          act("&2&8$n &2&8is now leading your group!&0",
              TRUE, new_master, 0, g->groupee, TO_VICT);
      }

      free(ch->groupees);
      ch->groupees = NULL;
    }
  }

  /* Character is a group member */
  else if (ch->group_master) {

    /* Only one other group member? Disband. */
    if (!ch->group_master->groupees->next) {
      if (verbose) {
        act(forceful ? "&2&8You remove $N from the group.&0" :
                       "&2&8$N has left the group.&0",
            FALSE, ch->group_master, 0, ch, TO_CHAR);
        act(forceful ? "&2&8$n has removed you from the group.&0" :
                       "&2&8You have left your group!&0",
            FALSE, ch->group_master, 0, ch, TO_VICT);
      }
      disband_group(ch->group_master, verbose, TRUE);
    }

    /* Otherwise remove this character from group list */
    else {
      struct char_data *master = ch->group_master;
      struct group_type *g, dummy, *found;

      dummy.next = master->groupees;

      for (g = &dummy; g && g->next; ) {
        if (g->next->groupee == ch) {
          found = g->next;
          g->next = found->next;
          free(found);
          continue;
        }
        if (verbose)
          act(forceful ? "&2&8$n &2&8has been kicked out of your group!&0" :
                         "&2&8$n &2&8has left your group!&0",
              TRUE, ch, 0, g->next->groupee, TO_VICT);
        g = g->next;
      }

      master->groupees = dummy.next;
      ch->group_master = NULL;

      if (verbose) {
        act(forceful ? "&2&8You have been kicked out of your group.&0" :
                       "&2&8You have left your group!&0",
            FALSE, ch, 0, 0, TO_CHAR);
        act(forceful ? "&2&8You have kicked $n &2&8out of your group.&0" :
                       "&2&8$n &2&8has left your group!&0",
            FALSE, ch, 0, master, TO_VICT);
      }
    }
  }
  else
    assert (FALSE);
}

bool is_grouped(struct char_data *ch, struct char_data *tch)
{
  struct char_data *k, *l;

  /* k is ch's group leader */
  k = ch->group_master ? ch->group_master : ch;

  /* l is tch's group leader */
  l = tch->group_master ? tch->group_master : tch;

  return (l == k); /* same group master? */
}

a546 23
/* Do NOT call this before having checked if a circle of followers */
/* will arise. CH will follow leader                               */
void add_follower(struct char_data * ch, struct char_data * leader)
{
  struct follow_type *k;

  assert(!ch->master);

  ch->master = leader;

  CREATE(k, struct follow_type, 1);

  k->follower = ch;
  k->next = leader->followers;
  leader->followers = k;

  if (!EFF_FLAGGED(ch, EFF_SHADOWING)) {
    act("You now follow $N.", FALSE, ch, 0, leader, TO_CHAR);
    act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
    act("$n starts to follow $N.", TRUE, ch, 0, leader, TO_NOTVICT);
  }
}

d1934 3
@


1.110
log
@Replaced the exp_to_level monstrosity with a lookup table that gets
populated at boot time.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.109 2008/08/29 04:16:26 myc Exp myc $
d65 10
a74 10
    {  17,  100000, 16,  17500 },
    {  25,  140000, 24,  22500 },
    {  33,  180000, 32,  25000 },
    {  49,  400000, 48,  30000 },
    {  90, 1230000, 89,  60000 },
    {  92,  120000, 91,  70000 },
    {  95,  210000, 94,  80000 },
    {  96,   80000, 95,  90000 },
    {  98,  180000, 97, 100000 },
    { 101,       0,  0,      0 }
d85 4
a88 3
      for (i = exp = 0; lvl >= eval[i].level; ++i)
        exp += eval[i].static_add;
      exp += (lvl - eval[i - 1].level_mod) * eval[i - 1].multiplier;
d110 2
a111 2
  /* Immortal levels should all be the same for any class */
  if (level >= LVL_IMMORT)
d2175 4
@


1.109
log
@Get rid of the trailing space in sprintflag.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.108 2008/08/16 21:33:01 jps Exp myc $
a49 3
  /* this is just a rough layout of the exp needed for a ch
     to level. recommend you change the modifier, and also
     the 4000 to something that suits you better.        */
d51 1
a51 9
long sumit(int level, int increase, double xfactor)
{
  long sum=0;
  int i;

  for(i=1;i<=level;i++)
    sum += i;

  sum *= increase;
d53 1
a53 6
  return ((long)((double)(sum)*xfactor));
}

double fexp[10] = {7.5, 8.0, 8.4, 8.8, 9.2,
                   9.7, 10.2, 10.7, 11.3, 12.0};
long exp_to_level(level, class)
d55 2
a56 2
  long exp = 0;
  double xfactor = 1;
d58 18
a75 1
  xfactor = EXP_GAIN_FACTOR(class);
d77 1
a77 2
  if (level >= 100)
    xfactor = 1;
d79 1
a79 2
  if (level <= 0)
    exp = 0;
d81 2
a82 2
  else if (level < 9)
    exp = (long) sumit(level, 5500, xfactor);
d84 6
a89 2
  else if (level < 17)
    exp = (long) (xfactor*(8*5500) + ((level-8) * 12500 * xfactor) + exp_to_level(level-1, class));
d91 2
a92 2
  else if (level < 25)
    exp = (long) (xfactor*(8*5500 + 8*12500) + ((level-16) * 17500 * xfactor) + exp_to_level(level-1, class));
d94 4
a97 2
  else if (level < 33)
    exp = (long) (xfactor*(8*5500 + 8*12500 + 8*17500) + ((level-24) * 22500 * xfactor) + exp_to_level(level-1, class));
a98 2
  else if (level < 49)
    exp = (long) (xfactor*(8*5500 + 8*12500 + 8*17500 + 8*22500) + ((level-32) * 25000 * xfactor) + exp_to_level(level-1, class));
d100 3
a102 2
  else if (level < 90)
    exp = (long) (xfactor*(8*5500 + 8*12500 + 8*17500 + 8*22500 + 16*25000)+((level-48) * 30000 * xfactor) + exp_to_level(level-1, class));
d104 4
a107 32
  else if (level < 92)
    exp = (long) (xfactor*(8*5500+8*12500+8*17500+8*22500+16*25000+41*30000)+((level-89) * 60000 * xfactor) + exp_to_level(level-1, class));

  else if (level < 95)
    exp = (long) (xfactor*(8*5500+8*12500+8*17500+8*22500+16*25000+41*30000+2*60000)+((level-91) * 70000 * xfactor) + exp_to_level(level-1, class));

  else if (level < 96)
    exp = (long) (xfactor*(8*5500+8*12500+8*17500+8*22500+16*25000+41*30000+2*60000+3*70000)+((level-94) * 80000 * xfactor) + exp_to_level(level-1, class));

  else if (level < 98)
    exp = (long) (xfactor*(8*5500+8*12500+8*17500+8*22500+16*25000+41*30000+2*60000+3*70000+1*80000)+((level-95) * 90000 * xfactor) + exp_to_level(level-1, class));

  else if (level <= 100)
    exp = (long) (xfactor*(8*5500+8*12500+8*17500+8*22500+16*25000+41*30000+2*60000+3*70000+1*80000+2*90000)+((level-97) * 100000 * xfactor) + exp_to_level(level-1, class));

/*  else if (level == 100)
    exp = 299999999; */

  else if (level == 101)
    exp = 300000001;

  else if (level == 102)
    exp = 300000003;

  else if (level == 103)
    exp = 300000005;

  else if (level == 104)
    exp = 300000007;

  else if (level == 105)
    exp = 300000009;
d109 3
d113 1
a113 1
    exp = (long) (exp_to_level(100, class) + (level - 100)*1);
d115 1
a115 4

   /*  exp = (long) (xfactor * (double)exp); */

  return exp;
d2174 3
@


1.108
log
@Allow a negative return value if you pass an invalid syslog severity.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.107 2008/08/14 23:10:35 myc Exp jps $
d358 1
a358 1
    *result = '\0'; /* Nul terminate */
d1912 52
d1965 8
a1972 3
static char *_str_buf = NULL;
static char *_str_pos = NULL;
static size_t _str_size = 0;
d1974 1
a1974 1
static void str_update()
d1976 2
a1977 2
  if (*_str_pos)
    _str_pos += strlen(_str_pos);
d1980 1
a1980 1
void str_start(char *buf, size_t max_size)
a1981 3
  _str_buf = buf;
  _str_pos = buf;
  _str_size = max_size;
d1983 8
d1995 9
a2003 5
  /* TODO: implement str_size in a fashion like strncat */
  if (buf == _str_buf) {
    str_update();
    while ((*_str_pos = *str))
      ++_str_pos, ++str;
d2009 16
d2028 2
d2033 6
a2038 3
  if (buf == _str_buf) {
    str_update();
    _str_pos += vsprintf(_str_pos, format, args);
d2048 24
d2074 2
a2075 1
  if (buf != _str_buf)
d2077 2
a2078 2
  str_update();
  return _str_pos;
d2198 3
@


1.107
log
@Added vararg functionality to log() and mudlog().  mprintf() is
the new vararg mudlog().  The old non-vararg mudlog() is still
available.  Added graduated log severity to the mudlog.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.106 2008/08/03 21:32:32 jps Exp myc $
d290 5
a294 1
  return (search_block(severity, log_severities, FALSE) + 1) * 10;
d2086 5
@


1.106
log
@Stop generating a log entry every time someone leaves the game when
someone was consented to that person.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.105 2008/06/21 17:26:33 jps Exp jps $
d190 3
a192 5
  char buf[MAX_INPUT_LENGTH];

  sprintf(buf, "%s hit death trap #%d (%s)", GET_NAME(ch),
          world[ch->in_room].vnum, world[ch->in_room].name);
  mudlog(buf, BRF, LVL_IMMORT, TRUE);
d197 1
a197 1
void log(const char *str)
d201 1
d205 5
a209 1
  fprintf(stderr, "%-24.24s :: %s\n", timestr, str);
d232 14
a245 1
void mudlog(const char *str, char type, int level, byte file)
d247 1
a247 1
  char buf[MAX_STRING_LENGTH], timestr[32];
a248 1
  char tp;
d250 2
d256 11
a266 3
  if (file)
    fprintf(stderr, "%-24.24s :: %s\n", timestr, str);
  if (level < 0)
d269 4
a272 1
  sprintf(buf, "[ %s ]\r\n", str);
d275 9
a283 3
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING)) {
      tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
            (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
d285 1
a285 3
      if ((GET_LEVEL(i->character) >= level) && (tp >= type))
        send_to_char(buf, i->character);
    }
d288 4
a291 1

d2082 4
@


1.105
log
@Moved movement strings into race definitions.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.104 2008/06/05 02:07:43 myc Exp jps $
d741 4
a744 8
  for (i = character_list; i; i = i->next)
    {
      if (CONSENT(i) == ch)
        {
          mudlog("Freeing consented person", NRM, LVL_GOD, FALSE);
          send_to_char("&0&7&bThe person you have consented has quit the game.&0\r\n", i);
          CONSENT(i) = NULL;
        }
d746 1
d2047 3
@


1.104
log
@Replaced strip_cr with filter_chars/strip_chars.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.103 2008/05/18 05:39:59 jps Exp myc $
d1096 10
a1105 16
  switch (GET_RACE(ch)) {
  case RACE_GIANT:
  case RACE_OGRE:
    return (leaving ? "lumbers" : "lumbers in");

  case RACE_DUERGAR:
    return (leaving ? "skulks" : "skulks in");

  case RACE_TROLL:
    return (leaving ? "prowls" : "prowls in");

  case RACE_DRAGON:
    return (leaving ? "stomps" : "stomps in");

  case RACE_DEMON:
    return (leaving ? "stalks" : "stalks in");
a1106 2

  return (leaving ? "leaves" : "enters");
d2050 3
@


1.103
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.102 2008/04/19 21:11:22 myc Exp jps $
a479 1
   int i;
d493 1
a493 4
   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i))
         Crash_extract_objs(GET_EQ(ch, i));
   Crash_extract_objs(ch->carrying);
d1758 1
a1758 18
 * This strips carraige returns in place.
 */
void strip_cr(char *buffer)
{
  char *rpos, *wpos;

  if (buffer == NULL)
    return;

  for (rpos = buffer, wpos = buffer; *rpos; ++rpos)
    if (*rpos != '\r')
      *(wpos++) = *rpos;

  *wpos = '\0';
}

/*
 * This trims spaces in place.
d1866 19
d2058 3
@


1.102
log
@Added some general-purpose integer array sorting functions.
Right now, we've got bubble sort, insertion sort, quicksort,
and some apparently-optimized quicksort I found on Google :)
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.101 2008/04/07 03:02:54 jps Exp myc $
d68 1
a68 1
		   9.7, 10.2, 10.7, 11.3, 12.0};
d153 1
a153 1
	return (-1);
d155 1
a155 1
	return (1);
d171 1
a171 1
	return (-1);
d173 1
a173 1
	return (1);
d193 1
a193 1
	  world[ch->in_room].number, world[ch->in_room].name);
d249 1
a249 1
	    (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
d252 1
a252 1
	send_to_char(buf, i->character);
d269 1
a269 1
	strcpy(result, "UNDEFINED");
d427 1
a427 1
  now.hours = (secs / SECS_PER_REAL_HOUR) % 24;	/* 0..23 hours */
d430 1
a430 1
  now.day = (secs / SECS_PER_REAL_DAY);	/* 0..34 days  */
d449 1
a449 1
  now.hours = (secs / SECS_PER_MUD_HOUR) % 24;	/* 0..23 hours */
d452 1
a452 1
  now.day = (secs / SECS_PER_MUD_DAY) % 35;	/* 0..34 days  */
d455 1
a455 1
  now.month = (secs / SECS_PER_MUD_MONTH) % 17;	/* 0..16 months */
d458 1
a458 1
  now.year = (secs / SECS_PER_MUD_YEAR);	/* 0..XX? years */
d471 1
a471 1
  player_age.year += 17;	/* All players start at 17 */
d547 1
a547 1
  if (ch->master->followers->follower == ch) {	/* Head of follower-list? */
d551 1
a551 1
  } else {			/* locate follower who is not head of list */
d748 5
a752 5
	{
	  mudlog("Freeing consented person", NRM, LVL_GOD, FALSE);
	  send_to_char("&0&7&bThe person you have consented has quit the game.&0\r\n", i);
	  CONSENT(i) = NULL;
	}
d909 5
a913 5
	   (*flow == '\r') ||
	   (*flow == '\f') ||
	   (*flow == '\t') ||
	   (*flow == '\v') ||
	   (*flow == ' ')) flow++;
d919 9
a927 9
	     (*flow != '\n') &&
	     (*flow != '\r') &&
	     (*flow != '\f') &&
	     (*flow != '\t') &&
	     (*flow != '\v') &&
	     (*flow != ' ') &&
	     (*flow != '.') &&
	     (*flow != '?') &&
	     (*flow != '!')) flow++;
d930 2
a931 2
	cap_next_next = FALSE;
	cap_next = TRUE;
d936 2
a937 2
	cap_next_next = TRUE;
	flow++;
d944 2
a945 2
	strcat(formated, "\r\n");
	total_chars = 0;
d949 4
a952 4
	if (total_chars > 0) {
	  strcat(formated, " ");
	  total_chars++;
	}
d955 2
a956 2
	cap_next = FALSE;
	*start = UPPER(*start);
d967 2
a968 2
	strcat(formated, "\r\n");
	total_chars = 0;
d971 2
a972 2
	strcat(formated, "  ");
	total_chars += 2;
d1066 1
a1066 1
	return (leaving ? "swims" : "swims in");
d2043 1
a2043 1
          array[R--] = array[L]; 
d2060 5
@


1.101
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.100 2008/04/03 02:02:05 myc Exp jps $
d1943 115
d2060 4
@


1.100
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.99 2008/04/02 19:31:02 myc Exp myc $
d485 1
a485 1
   if (GET_POS(ch) < POS_RESTING)
d529 1
a529 1
     if (GET_POS(ch) == POS_DEAD)
d1091 1
a1091 1
  if (GET_STANCE(ch) == STANCE_PRONE)
d1094 1
a1094 1
  if (GET_STANCE(ch) == STANCE_KNEELING)
d1945 3
@


1.99
log
@Added str_catf functions and used them in do_stat functions.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.98 2008/04/02 04:55:59 myc Exp myc $
d251 1
a251 2
      if ((GET_LEVEL(i->character) >= level) && (tp >= type)) {
	send_to_char(CCGRN(i->character, C_NRM), i->character);
a252 2
	send_to_char(CCNRM(i->character, C_NRM), i->character);
      }
a1023 57
char *strip_ansi(char *the_string){
  register char *i = NULL, *buf;
  static char zbuf[MAX_STRING_LENGTH];

  buf = zbuf;

  for(;;) {
    if(*the_string == '&') {
      switch (*(++the_string)) {
      case '&':
        i = "&";
        break;
      default:
	i = "";
	break;
      }
      while ((*buf = *(i++)))
        buf++;
      the_string++;
    }
    else if (!(*(buf++) = *(the_string++)))
      break;
  }

  *(++buf) = '\0';
  return zbuf;
}

char *escape_ansi(char *the_string){
  register char *i = NULL, *buf;
  static char zbuf[MAX_STRING_LENGTH];

  buf = zbuf;

  for (;;) {
    if (*the_string == '&') {
      switch (*(++the_string)) {
      case '&':
        i = "&&&";
        break;
      default:
	i = "&&";
	break;
      }
      while ((*buf = *(i++)))
        buf++;
      *(buf++) = *(the_string++);
    }
    else if (!(*(buf++) = *(the_string++)))
      break;
  }

  *(++buf) = '\0';
  return zbuf;
}


d1248 1
a1248 1
   while (*b && *b == '&')
d1360 1
a1360 1
      if (*s == '&') {
d1462 1
a1462 1
      if (*t == '&') {
a1760 19
int count_color_chars(const char *string)
{
  int num = 0;

  if (!string || !*string)
    return 0;

  for (; *string; ++string) {
    if (*string == '&') {
      ++string;
      ++num;
      if (*string != '&')
        ++num;
    }
  }

  return num;
}

d1945 3
@


1.98
log
@Added a parse money function.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.97 2008/04/02 03:24:44 myc Exp myc $
d1965 57
d2024 3
@


1.97
log
@Rewrote group code and removed major group code.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.96 2008/03/30 17:30:38 jps Exp myc $
d1369 26
d1967 3
@


1.96
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.95 2008/03/29 21:14:37 myc Exp jps $
a142 24
long exp_group_bonus(long inexp)
{/*small function to offer bonus from grouping*/
  return 1.3 * inexp;
}

long exp_highlevel_bonus(long inexp, int lvldiff)
{/*small function to offer those who kill higher levels more returns*/

  return ((100 + lvldiff * 1.5) / 100) * inexp;
}


/* Create a duplicate of a string */
/*
char *str_dup(const char *source)
{
  char *new;

  CREATE(new, char, strlen(source) + 1);
  return (strcpy(new, source));
}
*/


d596 1
a596 1
void readlist(struct char_data *ch)
d598 12
a609 3
  struct group_type *f;
  char buf[100];
  int counter = 0;
d611 5
a615 6
  for(f = ch->groupees;f;f=f->next)
    {
      counter++;
      sprintf(buf,"&0&2&bgroup&0 :conter %d, name %s", counter, GET_NAME(f->groupee));	
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
    }
a616 5
void readfoll(struct char_data *ch)
{
  struct follow_type *f;
  char buf[80];
  int counter = 0;
d618 1
a618 8
  for(f = ch->followers;f;f=f->next)
    {
      counter++;
      sprintf(buf,"&0&2&bfollower&0 :conter %d, name %s", counter, GET_NAME(f->follower));	
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
    }
}
void readmlist(struct char_data *ch)
d620 1
a620 3
  struct mgroup_type *f;
  char buf[100];
  int counter = 0;
d622 1
a622 14
  for(f = ch->mgroupees;f;f=f->next)
    {
      counter++;
      sprintf(buf,"&0&1mgroup &0:conter %d, name %s:", counter, GET_NAME(f->mgroupee));	
      act(buf, TRUE, ch, 0, 0, TO_ROOM);

    }
}
/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_groupee(struct char_data * ch, bool hide)
{
  void die_mgroupee(struct char_data * ch);
  struct group_type *j, *k;
d624 3
a626 1
  /* Good god no. Anyhow.  This was set to a char[50].  Guess what...
d628 9
a636 38
     Group Member: the zombie of the druidic guard Freed by the zombie of the
          druidic guard

     is more than 50 characters. Guess what this does?  Yup yup. It corrupts
     the stack, and winds up causing the mud to crash when, yep, you guessed
     it, zombies die.  All in all, it's one of the ugliest crash bugs I've
     seen in my time here.  I can't guarantee it's done crashing - there may
     be more.  But this at least fixed one of them.

  */

  char buf[1025];

  struct char_data *l;
  int counter = 0;
  bool last_member = 0;
  assert(ch->groupmaster);

  l = ch->groupmaster;
  for(k = l->groupees;k;k=k->next)
    counter++;
  if (counter == 1)
    last_member = 1;
  if (ch->groupmaster->groupees->groupee == ch) {	/* Head of follower-list? */
    sprintf(buf,"Group Member: %s Freed by %s", GET_NAME(ch), GET_NAME(l));	
    mudlog(buf, CMP, LVL_GOD, FALSE);
    k = ch->groupmaster->groupees;
    ch->groupmaster->groupees = k->next;
    if (counter == 1)
      send_to_char("&2&bYour group is disbanded.&0\r\n", ch);
    free(k);
  } else {			/* locate follower who is not head of list */
    sprintf(buf,"Group Member: %s Freed by %s", GET_NAME(ch), GET_NAME(l));	
    mudlog(buf, CMP, LVL_GOD, FALSE);
    for (k = ch->groupmaster->groupees; k->next->groupee != ch; k = k->next);
    j = k->next;
    k->next = j->next;
    free(j);
a637 11
  ch->groupmaster = NULL;
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_GROUP);
  if (last_member) {
    /*if last member remove his group from mgroup*/
    if ((EFF_FLAGGED(l, EFF_MAJOR_GROUP)))
      die_mgroupee(l);
    REMOVE_FLAG(EFF_FLAGS(l), EFF_GROUP);
    l->groupees = NULL;
    send_to_char("&0&2&bYour group is disbanded.&0\r\n", l);
  }

d640 1
a640 1
bool is_grouped(struct char_data *ch, struct char_data *tch)
d642 2
a643 1
  struct char_data *k, *l = NULL;
d645 3
a647 1
  if (EFF_FLAGGED(ch, EFF_GROUP)) {
d649 9
a657 2
    /* k is ch's group leader */
    k = (ch->groupmaster ? ch->groupmaster : ch);
d659 8
a666 13
    if (EFF_FLAGGED(tch, EFF_GROUP)) {
      /* l is tch's group leader */
      l = (tch->groupmaster ? tch->groupmaster : tch);
      if (l == k)
        return TRUE;	/* same group */

      if (EFF_FLAGGED(k, EFF_MAJOR_GROUP) && EFF_FLAGGED(l, EFF_MAJOR_GROUP)) {
        /* k is old k's major group leader */
        /* l is old l's major group leader */
        k = (k->mgroupmaster ? k->mgroupmaster : k);
        l = (l->mgroupmaster ? l->mgroupmaster : l);
        if (l == k)
          return TRUE;	/* same major group */
d668 3
d674 2
a675 2
  return FALSE;
}
d677 12
d690 20
a709 21
/* Called when a character that follows/is followed dies */
void die_groupee(struct char_data * ch)
{
  struct mgroup_type *f;
  struct group_type *k;
  struct char_data *l;
  int counter = 0;
  bool was_mgroup_leader = 0;
  bool was_mgroupee = 0;
  void die_mgroupee(struct char_data *ch);
  void add_mgroupee(struct char_data *ch, struct char_data *mgroupleader, bool hide);
  void stop_mgroupee(struct char_data *ch, bool hide);
  /*Both major group flags and group flags are handled here in this function*/
  /*removal via death or often link loss*/

  if (ch->groupmaster)/*If character has a group master pretty simple leaves here*/
    {		/*however this does disband group if group less than 1 groupee*/

      act("&0&2&b$N is no longer a member of your group.&0", FALSE, ch->groupmaster, 0, ch, TO_CHAR);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_VICT);
      act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_NOTVICT);
d711 2
a712 3
      stop_groupee(ch, 0);
      return;
    }
d714 8
a721 6
  for (k = ch->groupees;k;k = k->next)
    counter++;/*counter counts  how many people in group*/
  k = ch->groupees;
  if (!(k->groupee))
    {
      return;
d723 4
a726 13
  l = k->groupee;
  if ((EFF_FLAGGED(ch, EFF_MAJOR_GROUP)))
    {
      if (!ch->mgroupmaster)
	was_mgroup_leader = 1;
      else
	was_mgroupee = 1;
    }/*if effected by major group what rank was the character*/
  if (counter == 1)
    {
      act("&0&2&b$N is no longer a member of your group.&0", FALSE, l, 0, ch, TO_CHAR);
      act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_VICT);
      act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_NOTVICT);
d728 3
a730 15
    }
  stop_groupee(l, 1);
  if (counter == 1)
    {
      return;
    }
  SET_FLAG(EFF_FLAGS(l), EFF_GROUP);
  l->groupmaster = NULL;
  send_to_char("&0&2&bYou have become the group leader.&0\r\n", l);
  l->groupees = ch->groupees;
  for (k = l->groupees;k;k = k->next)
    {
      k->groupee->groupmaster = l;
      act("&0&2&bYou have a new group leader $N.&0", FALSE, k->groupee, 0, l, TO_CHAR);
    }
d732 2
a733 2
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_GROUP);
  ch->groupees = NULL;
d735 2
a736 21
  if (was_mgroup_leader)
    {
      SET_FLAG(EFF_FLAGS(l), EFF_MAJOR_GROUP);
      l->mgroupmaster = NULL;
      send_to_char("&0&1You have become the major group leader.&0\r\n", l);
      l->mgroupees = ch->mgroupees;
      for (f = l->mgroupees;f;f = f->next)
	{
	  f->mgroupee->mgroupmaster = l;
	  act("&0&1You have a new major group leader $N.&0", FALSE, f->mgroupee, 0, l, TO_CHAR);
	}
      REMOVE_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
      ch->mgroupees = NULL;
      return;
    }
  if (was_mgroupee)
    {
      add_mgroupee(l, ch->mgroupmaster, 1);
      die_mgroupee(ch);
      return;
    }
d738 1
d740 2
d743 2
a744 1
{/*aim is to search through character list and check if he been consented
a757 186
void die_consentee(struct char_data *ch)
{
  struct char_data *target;
  return;
  if (CONSENT(ch))
    {
      if (!(CAN_SEE(ch, CONSENT(ch))))
	{
	  CONSENT(ch) = NULL;
	  return;
	}
      else
	{
	  if (target == CONSENT(ch))
	    {
	      act("&0&7&bYou revoke your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
	      act("&0&7&bYou lose $n's consent.&0", FALSE, ch, 0, target, TO_VICT);
	      CONSENT(ch) = NULL;
	      return;
	    }
	}
    }
  CONSENT(ch) = NULL;
}
void add_groupee(struct char_data *ch, struct char_data * groupleader, bool noisy)
{
  struct group_type *k;
  SET_FLAG(EFF_FLAGS(ch), EFF_GROUP);	
  assert(!ch->groupmaster);
  ch->groupmaster = groupleader;

  CREATE(k, struct group_type, 1);
  k->groupee = ch;
  k->next = groupleader->groupees;
  groupleader->groupees = k;
  if (noisy)
    {
      act("&0&2&bYou have been accepted into $N's group.&0", FALSE, ch, 0, groupleader, TO_CHAR);
      act("&0&2&bYou accept $n into your group.&0", FALSE, ch, 0, groupleader, TO_VICT);
      act("&0&2&b$n has joined $N's group.&0", TRUE, ch, 0, groupleader,
	  TO_NOTVICT);

    }
}


/*This is the mgroup code structure*/
void stop_mgroupee(struct char_data * ch, bool hide)
{
  struct group_type *a;
  struct mgroup_type *j, *k;
  struct char_data *l;	
  char buf[100];
  int counter = 0;
  bool last_member = 0;
  assert(ch->mgroupmaster);
  /*check to see if just one person left is so dispand group at end*/
  l = ch->mgroupmaster;
  for(k = l->mgroupees;k;k=k->next)
    counter++;
  if (counter == 1)
    last_member = 1;
  if (ch->mgroupmaster->mgroupees->mgroupee == ch)
    {	/* Head of follower-list? */
      k = ch->mgroupmaster->mgroupees;
      ch->mgroupmaster->mgroupees = k->next;
      if (counter == 1)
	{
	  for (a = l->groupees;a;a=a->next)
	    {
	      send_to_char("&0&1Your Major Group has been disbanded\r\n", a->groupee);
	
	    }
	}
      sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
      mudlog(buf, CMP, LVL_GOD, FALSE);
      free(k);
    }
  else
    {			/* locate follower who is not head of list */
      for (k = ch->mgroupmaster->mgroupees; k->next->mgroupee != ch; k = k->next);
      j = k->next;
      k->next = j->next;
      sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
      mudlog(buf, CMP, LVL_GOD, FALSE);
      free(j);
    }
  ch->mgroupmaster = NULL;
  REMOVE_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
  /*if that was last on list lets disband this dude*/
  if (last_member)
    {
      REMOVE_FLAG(EFF_FLAGS(l), EFF_MAJOR_GROUP);
      l->mgroupees = NULL;
      send_to_char("&0&1Your disband the major group.&0\r\n", l);
    }
}



/* Called when a character that follows/is followed dies */
void die_mgroupee(struct char_data * ch)
{
  struct mgroup_type *k;
  struct group_type *f;
  struct char_data *l;char buf[50];
  int counter = 0;
  if (ch->mgroupmaster)
    {

      act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, ch->mgroupmaster, 0, ch, TO_CHAR);
      act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, ch->mgroupmaster, 0, ch, TO_VICT);
      act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
	  FALSE, ch->mgroupmaster, 0, ch, TO_NOTVICT);

      stop_mgroupee(ch, 0);
      return;
    }
  /*handle the death of a group leader*/
  sprintf(buf,"in die mgroupee rare");	
  mudlog(buf, CMP, LVL_GOD, FALSE);

  for (k=ch->mgroupees;k;k=k->next)
    counter++;	
  k = ch->mgroupees;
  l = k->mgroupee;
  if (counter == 1)
    {
      act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, k->mgroupee, 0, ch, TO_CHAR);
      act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, k->mgroupee, 0, ch, TO_VICT);
      act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
	  FALSE, k->mgroupee, 0, ch, TO_NOTVICT);

    }
  stop_mgroupee(k->mgroupee, 1);
  if (counter ==1)
    {
      return;
    }
  SET_FLAG(EFF_FLAGS(l), EFF_MAJOR_GROUP);
  l->mgroupmaster = NULL;/*all mgroup leaders must have a null mgroupmaster*/
  send_to_char("&0&1You have become the new &1major&0&1 group leader&0.\r\n", l);
  l->mgroupees = ch->mgroupees;
  for(f = l->groupees;f;f=f->next)
    {
      act("&0&2&bYour group has a new &0&1Major&0&1 group leader&0&2&b $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
    }
  for (k = ch->mgroupees; k; k = k->next)
    {
      k->mgroupee->mgroupmaster = l;
      act("&0&1You have a new major group leader $N.&0", FALSE, k->mgroupee, 0, l, TO_CHAR);
      for (f = ch->groupees; f; f=f->next)
	{
	  act("&0&1Your group has a new major group leader $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
	}
    }

  REMOVE_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);
  ch->mgroupees = NULL;
}

void add_mgroupee(struct char_data *ch, struct char_data * mgroupleader, bool hide)
{
  struct mgroup_type *k;

  if (EFF_FLAGGED(ch, EFF_MAJOR_GROUP))
    return;

  SET_FLAG(EFF_FLAGS(ch), EFF_MAJOR_GROUP);	
  assert(!ch->groupmaster);
  ch->mgroupmaster = mgroupleader;
  CREATE(k, struct mgroup_type, 1);
  k->mgroupee = ch;
  k->next = mgroupleader->mgroupees;
  mgroupleader->mgroupees = k;
  if (!hide)
    {
      act("&0&1You have been accepted into $N's major group.&0", FALSE, ch, 0, mgroupleader, TO_CHAR);
      act("&0&1You accept $n into your major group.&0", FALSE, ch, 0, mgroupleader, TO_VICT);
      act("&0&1$n has joined $N's major group.&0", TRUE, ch, 0,
	  mgroupleader, TO_NOTVICT);

    }
}


d1941 4
@


1.95
log
@Fix not-very-potential memory leak.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.94 2008/03/29 17:34:55 myc Exp myc $
d33 1
a34 5
void Crash_extract_objs(struct obj_data * obj);

/* This function is used to calculate the hitroll a monk
   should lose due to carrying too much. Note: this function
   returns a positive value! David Endre 9/16/99 */
d2224 3
@


1.94
log
@Autodouse event memory leak.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.93 2008/03/28 17:54:53 myc Exp myc $
d371 1
a371 1
flagvector *ALL_FLAGS;
d390 2
d2228 3
@


1.93
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.92 2008/03/26 22:22:56 jps Exp myc $
d535 1
a535 1
   struct char_data *ch = ((struct generic_event_data *)event_obj)->ch;
d2226 4
@


1.92
log
@Better error checking/reporting in perform_random_gem_drop.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.91 2008/03/26 16:44:36 jps Exp jps $
d292 1
a292 2

  *result = '\0';
d298 1
a298 1
        sprintf(result, "%s%s ", result, names[nr]);
d300 3
a302 1
	strcat(result, "UNDEFINED ");
d308 4
a311 2
  if (!*result)
    strcpy(result, "NOBITS ");
d329 25
a353 1
int sprintascii(char *out, bitvector_t bits)
d356 1
a356 1
  /* 32 bits, don't just add letters to try to get more unless your bitvector_t is also as large. */
d371 76
a505 14
/* Check if making CH follow VICTIM will create an illegal */
/* Follow "Loop/circle"                                    */
bool circle_follow(struct char_data * ch, struct char_data * victim)
{
  struct char_data *k;

  for (k = victim; k; k = k->master) {
    if (k == ch)
      return TRUE;
  }

  return FALSE;
}

d537 1
a537 1
   if (AFF2_FLAGGED(ch, AFF2_ON_FIRE)) {
d542 1
a542 1
      REMOVE_BIT(AFF2_FLAGS(ch), AFF2_ON_FIRE);
d557 1
a557 1
  if (IS_AFFECTED(ch, AFF_CHARM)) {
d566 1
a566 1
      affect_from_char(ch, SPELL_CHARM);
d568 1
a568 1
  } else if (AFF3_FLAGGED(ch, AFF3_SHADOWING)) {
d588 2
a589 2
  if (IS_AFFECTED(ch, AFF_CHARM)) {
     REMOVE_BIT(AFF_FLAGS(ch), AFF_CHARM);
d602 1
a602 1
  REMOVE_BIT(AFF3_FLAGS(ch), AFF3_SHADOWING);
d711 1
a711 1
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
d714 1
a714 1
    if ((IS_AFFECTED2(l, AFF2_MGROUP)))
d716 1
a716 1
    REMOVE_BIT(AFF_FLAGS(l), AFF_GROUP);
d727 1
a727 1
  if (AFF_FLAGGED(ch, AFF_GROUP)) {
d732 1
a732 1
    if (AFF_FLAGGED(tch, AFF_GROUP)) {
d738 1
a738 1
      if (AFF2_FLAGGED(k, AFF2_MGROUP) && AFF2_FLAGGED(l, AFF2_MGROUP)) {
d787 1
a787 1
  if ((IS_AFFECTED2(ch, AFF2_MGROUP)))
d806 1
a806 1
  SET_BIT(AFF_FLAGS(l), AFF_GROUP);
d816 1
a816 1
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
d821 1
a821 1
      SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
d830 1
a830 1
      REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d884 1
a884 1
  SET_BIT(AFF_FLAGS(ch), AFF_GROUP);	
d945 1
a945 1
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d949 1
a949 1
      REMOVE_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
d996 1
a996 1
  SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
d1014 1
a1014 1
  REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
d1022 1
a1022 1
  if (IS_AFFECTED2(ch, AFF2_MGROUP))
d1025 1
a1025 1
  SET_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);	
d1060 1
a1060 1
  if (!AFF3_FLAGGED(ch, AFF3_SHADOWING)) {
d1405 1
a1405 1
  if (AFF2_FLAGGED(ch, AFF2_LEVITATE) && (dir == DOWN || dir == UP))
d1410 1
a1410 1
      if (AFF2_FLAGGED(ch, AFF2_WATERBREATH))
d1428 2
a1429 2
  if (AFF_FLAGGED(ch, AFF_BLIND) ||
     (IS_DARK(room) && !AFF_FLAGGED(ch, AFF_INFRAVISION)))
d1433 1
a1433 1
  if (IS_HIDDEN(ch) || OUTDOOR_SNEAK(ch) || AFF_FLAGGED(ch, AFF_SNEAK))
d2226 3
@


1.91
log
@Replaced all checks for undead race with checks for undead lifeforce.
Replaced the undead race with the plant race.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.90 2008/03/23 00:25:23 jps Exp jps $
d1484 3
a1486 4
  if (!rnum) {
    char erbf[255];
    sprintf(erbf, "RGD Error:  No such object (vnum %d)!", vnum);
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
d1493 1
a1493 2
    char erbf[255];
    sprintf(erbf, "RGD Error: Could not read object (vnum %d)!", vnum);
d2137 4
@


1.90
log
@Add a function to format applies, since it's done in at least
three places in the server.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.89 2008/03/22 21:24:25 jps Exp jps $
d1353 3
a1371 4

  case RACE_UNDEAD:
    return (leaving ? "shambles" : "shambles in");

d2139 4
@


1.89
log
@Some code formatting.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.88 2008/03/22 19:50:24 myc Exp jps $
d32 1
d2119 18
d2140 3
@


1.88
log
@Added strnlen implementation.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.87 2008/03/22 19:08:58 jps Exp myc $
d2094 5
a2098 12
      } else for (i = 0; i < numobjs; i++) {
         if (!strncasecmp(arg, OBJNAME(i), strlen(arg))) {
            if (!strcasecmp(arg, OBJNAME(i))) {
               answer = i;
               break;
            }
            if (best == -1)
               best = i;
            } else if (is_abbrev(arg, OBJNAME(i))) {
               if (best == -1)
               best = i;
            }
d2100 7
d2108 5
a2112 6
         if (answer == -1) answer = best;
         if (answer == -1) {
         if (ch) {
            sprintf(buf, "There is no such %s.\r\n", objname);
            send_to_char(buf, ch);
         }
d2114 1
d2121 3
@


1.87
log
@Added parse_obj_name() function, which is a generalized function
for identifying structs.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.86 2008/03/21 21:59:31 jps Exp jps $
d205 8
d2121 4
@


1.86
log
@Add some more methods of pluralizing.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.85 2008/03/21 21:36:02 jps Exp jps $
d31 1
d52 1
a52 1
  
d120 1
a120 1
  
d123 1
a123 1
  
d126 1
a126 1
  
d129 1
a129 1
  
d132 1
a132 1
  
d139 1
a139 1
  
d141 1
a141 1
  
d163 1
a163 1
  
d176 1
a176 1
  
d194 1
a194 1
  
d201 1
a201 1
    }  
d210 1
a210 1
  
d233 1
a233 1
  
d254 1
a254 1
  
d257 1
a257 1
  
d262 1
a262 1
  
d264 1
a264 1
  
d269 1
a269 1
      
d305 1
a305 1
  
d310 1
a310 1
  
d341 1
a341 1
  
d343 1
a343 1
  
d346 1
a346 1
  
d349 1
a349 1
  
d352 1
a352 1
  
d363 1
a363 1
  
d365 1
a365 1
  
d368 1
a368 1
  
d371 1
a371 1
  
d374 1
a374 1
  
d376 1
a376 1
  
d385 1
a385 1
  
d387 1
a387 1
  
d389 1
a389 1
  
d399 1
a399 1
  
d404 1
a404 1
  
d456 1
a456 1
  
d458 1
a458 1
  
d477 1
a477 1
  
d484 1
a484 1
    
d503 1
a503 1
  
d514 1
a514 1
  
d517 1
a517 1
  
d529 1
a529 1
  
d542 1
a542 1
  
d555 1
a555 1
  
d561 1
a561 1
      
d576 1
a576 1
     is more than 50 characters. Guess what this does?  Yup yup. It corrupts 
d578 1
a578 1
     it, zombies die.  All in all, it's one of the ugliest crash bugs I've 
d580 1
a580 1
     be more.  But this at least fixed one of them. 
d590 1
a590 1
  
d622 1
a622 1
  
d669 1
a669 1
  
d672 1
a672 1
      
d676 1
a676 1
      
d680 1
a680 1
  
d685 1
a685 1
    {  
d701 1
a701 1
      
d717 1
a717 1
  
d720 1
a720 1
  
d742 1
a742 1
  
d748 1
a748 1
  
d765 1
a765 1
      if (!(CAN_SEE(ch, CONSENT(ch)))) 
d789 1
a789 1
  
d800 1
a800 1
      
d821 1
a821 1
  if (ch->mgroupmaster->mgroupees->mgroupee == ch) 
d830 1
a830 1
	      
d834 1
a834 1
      mudlog(buf, CMP, LVL_GOD, FALSE); 
d836 2
a837 2
    } 
  else 
d868 1
a868 1
      
d873 1
a873 1
      
d880 1
a880 1
  
d891 1
a891 1
      
d906 1
a906 1
  for (k = ch->mgroupees; k; k = k->next) 
d915 1
a915 1
  
d923 1
a923 1
  
d926 1
a926 1
  
d940 1
a940 1
      
d951 1
a951 1
  
d953 1
a953 1
  
d955 1
a955 1
  
d957 1
a957 1
  
d961 1
a961 1
  
d980 1
a980 1
  
d990 1
a990 1
  
d1003 1
a1003 1
  
d1007 1
a1007 1
  
d1032 1
a1032 1
  
d1035 1
a1035 1
  
d1060 1
a1060 1
      flow += strlen(pattern);  
d1062 1
a1062 1
      
d1084 1
a1084 1
  
d1087 1
a1087 1
  
d1095 2
a1096 2
  } 
  
d1104 1
a1104 1
    
d1106 1
a1106 1
      
d1118 1
a1118 1
      
d1123 1
a1123 1
      
d1129 1
a1129 1
      
d1132 1
a1132 1
      
d1137 1
a1137 1
      
d1148 1
a1148 1
      
d1151 1
a1151 1
      
d1154 1
a1154 1
    
d1167 1
a1167 1
  /* Trim trailing spaces, + possible extraneous newline. */ 
d1173 1
a1173 1
  
d1183 1
a1183 1
  
d1217 1
a1217 1
  
d1219 1
a1219 1
  
d1228 1
a1228 1
	break; 
d1237 1
a1237 1
  
d1245 1
a1245 1
  
d1247 1
a1247 1
  
d1256 1
a1256 1
	break; 
d1265 1
a1265 1
  
d1274 1
a1274 1
  
d1277 1
a1277 1
  
d1306 1
a1306 1
  
d1309 1
a1309 1
  
d1314 1
a1314 1
    
d1317 1
a1317 1
    
d1320 1
a1320 1
    
d1323 1
a1323 1
  
d1329 1
a1329 1
  
d1334 1
a1334 1
  
d1337 1
a1337 1
  
d1340 1
a1340 1
  
d1343 1
a1343 1
  
d1348 1
a1348 1
    
d1351 1
a1351 1
    
d1354 1
a1354 1
    
d1357 1
a1357 1
    
d1360 1
a1360 1
    
d1363 1
a1363 1
    
d1365 1
a1365 1
  
d1380 3
a1382 3
  int slot; 
  int phase; 
  int roll; 
d1386 2
a1387 2
    55300,     55301,     55302,    55304,     55305,     55306, 
    55308,     55309,     55310,    55312,     55313,     55314, 
d1401 1
a1401 1
    55379,     55380,     55381,    55382,     55383,    
d1405 2
a1406 2
    { 55586, 55589 }, 
    { 55649, 55659 }, 
d1411 3
a1413 3
    { 55566, 55569 }, { 55570, 55573 }, { 55574, 55577 }, { 55578, 55581 },     
    { 55582, 55585 }, { 55594, 55604 }, { 55605, 55615 }, { 55616, 55626 }, 
    { 55627, 55637 }, { 55638, 55648 }, { 55671, 55681 }, { 55682, 55693 }, 
d1417 4
a1420 1
  if (!IS_NPC(ch) || ch->desc || GET_LEVEL(ch) > 60) 
d1422 7
a1428 10
    
  if (number(1, 100) > 7) 
    return 0; 

  slot = GET_LEVEL(ch) / 4; 
  phase = GET_LEVEL(ch) / 20; 

  roll = number(1, 100); 
 
  /* You win the shiny prize!  The shiny prize is rusted decayed armor. */ 
d1431 4
a1434 4
    int item = 4 - number(1, 7) + GET_LEVEL(ch); 
    
    if (item < 0) item = 0; 
    if (item > 63) item = 63; 
d1438 3
a1440 3
 
  roll = number(1, 100); 
  
d1442 1
a1442 1
    slot--; 
d1445 1
a1445 1
    slot++; 
d1448 1
a1448 1
    /* If we're in the highest section of a phase, there's a chance of leg gems. */ 
d1450 1
a1450 1
      return number(leg_gem_vnums[phase][0], leg_gem_vnums[phase][1]); 
a1451 3
    
    slot++; slot++;  
  }         
d1453 5
a1457 2
  if (slot < 0) slot = 0; 
  if (slot > 14) slot = 14; 
d1459 1
a1459 1
  return number(common_gem_vnums[slot][0], common_gem_vnums[slot][1]); 
d1466 3
a1468 3
  int vnum = pick_random_gem_drop(ch); 
  int rnum; 
  struct obj_data* od; 
d1471 1
a1471 1
    return; 
d1474 1
a1474 1
  rnum = real_object(vnum); 
d1477 2
a1478 2
    char erbf[255]; 
    sprintf(erbf, "RGD Error:  No such object (vnum %d)!", vnum); 
d1480 1
a1480 1
    return; 
d1483 1
a1483 1
  od = read_object(rnum, REAL); 
d1486 2
a1487 2
    char erbf[255]; 
    sprintf(erbf, "RGD Error: Could not read object (vnum %d)!", vnum); 
d1489 1
a1489 1
    return; 
d1492 1
a1492 1
  obj_to_char(od, ch); 
d1550 1
a1550 1
   }      
d2046 64
d2113 3
d2389 1
a2389 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.85
log
@Add functions without_article and pluralize, for modifying
nouns and noun phrases.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.84 2008/03/11 02:57:16 jps Exp jps $
d1786 18
a1803 1
   /* Ending in: x, sh, ss, ch, <C>o, <C>y: add es */
d1805 1
d2048 4
@


1.84
log
@Change state_weight and state_length to allow single-reentrancy.
Also, the ".0" on the end of a "tons" statement is suppressed.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.83 2008/03/10 20:49:47 myc Exp jps $
a1648 1
#define IABUFSIZ 200
d1662 5
a1666 4
char *with_indefinite_article(const char *s) {
   static char iabuf1[IABUFSIZ];
   static char iabuf2[IABUFSIZ];
   static char iabuf3[IABUFSIZ];
d1720 1
a1720 1
   while (*t && u - ret < IABUFSIZ - 1)
d1727 146
d2030 4
@


1.83
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.82 2008/03/08 18:55:20 jps Exp myc $
d1729 12
a1740 1
   static char res[400];
d1759 13
a1771 1
   static char res[400];
d1778 8
a1785 2
   else
      sprintf(res, "%0.1f tons", pounds / 2000.0);
d1884 3
@


1.82
log
@Fix strip_cr
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.81 2008/03/05 03:03:54 myc Exp jps $
d1337 1
a1337 1
  if (GET_POS1(ch) == POS1_PRONE)
d1340 1
a1340 1
  if (GET_POS1(ch) == POS1_KNEELING)
d1855 3
@


1.81
log
@Added sprintascii function.  Moved get_filename to players.c.  Got
rid of BOUNDED.  Added strip_cr and trim_spaces.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.80 2008/02/16 20:31:32 myc Exp myc $
d1820 3
a1822 3
  for (rpos = buffer, wpos = buffer; rpos; ++rpos)
    if ((*wpos = *(rpos++)) != '\r')
      ++wpos;
d1824 1
a1824 1
  wpos = '\0';
d1855 4
@


1.80
log
@Commented out str_dup to help disambiguate memory leaks.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.79 2008/02/09 21:07:50 myc Exp myc $
d316 18
a997 61
/* modified by gurlaek 8/8/1999 to split up player files */
int get_filename(char *name, char *filename, int mode) {
  char plr_name[MAX_NAME_LENGTH + 1];

  if (!*name)
    return 0;

  strcpy(plr_name, name);
  plr_name[0] = toupper(plr_name[0]);

  switch (mode) {
  case CRASH_FILE:
    sprintf(filename, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".objs");
    break;
  case QUEST_FILE:
    sprintf(filename, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".quest");
    break;
  case ETEXT_FILE:
    sprintf(filename, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".text");
    break;
  case PLR_FILE:
    sprintf(filename, "%s/%c/%s", PLR_PREFIX, plr_name[0], plr_name);
    break;
  case NOTES_FILE:
    sprintf(filename, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".notes"); 
    break; 
  default:
    return 0;
  }
  return 1;
}

/* modified by gurlaek 8/8/1999 to split up player files */
char *get_fname(char *name, int mode) {
  char plr_name[MAX_NAME_LENGTH + 1];

  buf[0] = '\0';

  if (!*name)
    return 0;
  
  strcpy(plr_name, name);
  plr_name[0] = toupper(plr_name[0]);

  switch (mode) {
  case CRASH_FILE:
    sprintf(buf, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".objs");
    break;
  case ETEXT_FILE:
    sprintf(buf, "%s/%c/%s%s", PLR_PREFIX, plr_name[0], plr_name, ".text");
    break;
  case PLR_FILE:
    sprintf(buf, "%s/%c/%s", PLR_PREFIX, plr_name[0], plr_name);
    break;
  default:
    return 0;
  }
  return buf;
}


d1222 3
a1269 6
/* A easy, much easier way to Min(max( cuts lenth Banyal*/
int BOUNDED(int a, int b, int c)
{
  return (MIN(MAX(a, b), c));
}

d1810 43
d1855 3
@


1.79
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not..
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.78 2008/02/09 18:29:11 myc Exp myc $
d158 1
d166 1
a166 1

d1858 4
@


1.78
log
@The event code now takes care of freeing event objects.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.77 2008/02/09 04:27:47 myc Exp myc $
d390 1
a390 1
   struct char_data *ch = ((struct generic_event_data *)event_obj)->ch;
d392 1
d480 2
a481 2
        event_create(EVENT_MOB_QUIT, mobquit_event,
              mkgenericevent(ch, 0, 0), &(ch->events), 3 RL_SEC);
d1857 3
@


1.77
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.76 2008/02/09 03:06:17 myc Exp myc $
d411 1
a411 1
   return 0;
d426 1
a426 1
   return 0;
d1856 3
@


1.76
log
@Moving mathematical functions to math.c.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.75 2008/02/06 21:53:53 myc Exp myc $
d30 1
d1856 3
@


1.75
log
@Slight bug in the levenshtein_distance function.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.74 2008/02/02 19:38:20 myc Exp myc $
a155 42
/* creates a random number in interval [from;to] */
int number(int from, int to)
{
  /* error checking in case people call number() incorrectly */
  if (from > to) {
    int tmp = from;
    from = to;
    to = tmp;
  }
  
  return ((random() % (to - from + 1)) + from);
}


/* simulates dice roll */
int dice(int number, int size)
{
  int sum = 0;
  
  if (size <= 0 || number <= 0)
    return 0;
  
  while (number-- > 0)
    sum += ((random() % size) + 1);
  
  return sum;
}


int MIN(int a, int b)
{
  return a < b ? a : b;
}


int MAX(int a, int b)
{
  return a > b ? a : b;
}



d1855 3
@


1.74
log
@Added a levenshtein distance calculator for use by the interpreter.
Also adding a count_color_chars function.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.73 2008/01/29 21:02:31 myc Exp myc $
d1859 1
a1859 1
  for (j = 0; j < s2_len; ++j)
d1897 4
@


1.73
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.72 2008/01/27 13:43:50 jps Exp myc $
d1847 48
d1897 4
@


1.72
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.71 2008/01/27 12:11:45 jps Exp jps $
a32 6
extern struct time_data time_info;
extern struct char_data *character_list;
extern struct room_data *world;
extern struct str_app_type str_app[];
extern int top_of_zone_table;

a248 1
  extern struct room_data *world;
a289 1
  extern struct descriptor_data *descriptor_list;
d319 1
a319 1
void sprintbit(long bitvector, char *names[], char *result)
d341 1
a341 1
void sprinttype(int type, char *names[], char *result)
a767 1
  extern struct char_data *character_list;
a1093 1
  extern struct descriptor_data *descriptor_list;
d1108 2
a1109 2
int replace_str(char **string, char *pattern, char *replacement, int rep_all,
  		int max_size) {
d1849 3
@


1.71
log
@Use exp factor from class.c.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.70 2008/01/26 14:26:31 jps Exp jps $
d1439 1
a1439 1
  case SPECIES_GIANT:
d1449 1
a1449 1
  case SPECIES_DRAGON:
d1452 1
a1452 1
  case SPECIES_DEMON:
d1455 1
a1455 1
  case SPECIES_UNDEAD:
d1859 3
@


1.70
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.69 2008/01/25 21:11:52 myc Exp jps $
d76 1
a76 1
long exp_to_level(level, class)  
d80 2
a81 45
  
  /*class exp converter*/
  /*make sure you dont set anything past 300 for the xfactor*/
  switch (class)
  {
    case CLASS_CLERIC:
    case CLASS_THIEF:
    case CLASS_PALADIN:
    case CLASS_ANTI_PALADIN:
    case CLASS_DRUID:
    case CLASS_SHAMAN:
    case CLASS_ASSASSIN:
    case CLASS_MERCENARY:
    case CLASS_CONJURER:
    case CLASS_BERSERKER:
    case CLASS_PRIEST:
    case CLASS_DIABOLIST:
    case CLASS_MYSTIC:
    case CLASS_ROGUE:
    case CLASS_BARD:
    case CLASS_PYROMANCER:
    case CLASS_CRYOMANCER:
    case CLASS_ILLUSIONIST:
    case CLASS_HUNTER:
      xfactor = 1;
      break;
    case CLASS_SORCERER:
      xfactor = 1.2;
      break;
    case CLASS_NECROMANCER:
      xfactor = 1.3;
      break;
    case CLASS_RANGER:
      xfactor = 1.15;
      break;
    case CLASS_WARRIOR:
      xfactor = 1.1;
      break;
    case CLASS_MONK:
      xfactor = 1.5;
      break;
    default:
      xfactor = 1;
      break;
  }
d88 1
a88 1
  
d1859 3
@


1.69
log
@Renamed monk_weight_pen to monk_weight_penalty.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.68 2008/01/15 03:18:19 myc Exp $
d29 1
d1902 3
@


1.68
log
@Changed statemoney to accept an array instead of a pointer.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.67 2008/01/13 23:06:04 myc Exp myc $
d42 1
a42 1
int monk_weight_pen(struct char_data *ch)
d44 2
a45 2
  int lim = 0;
  int pct = 0;
d47 2
a48 6
  if(IS_NPC(ch))
     return 0;
  if(GET_CLASS(ch) != CLASS_MONK)
    return 0;
  if(GET_LEVEL(ch) < 20)
    return 0;  
d50 3
a52 4
  pct = 20 - GET_STR(ch)/10;  
  lim = (int)((double)(CAN_CARRY_W(ch)) * (1-(double)(pct/100.0)));

  if(lim >= IS_CARRYING_W(ch))
a53 2

  return ((int)((IS_CARRYING_W(ch)-lim)/10));
d1901 3
@


1.67
log
@Removed some unused functions: number_of_groupees (use group_size
instead), NumAttackers, SanityCheck, statsave, STAT_INDEX,
are_together (use is_grouped), and has_help.  Also cleaned up
movewords a bunch.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.66 2008/01/09 08:34:36 jps Exp myc $
d1659 1
a1659 1
void statemoney(char *buf, int cptr[]) {
d1663 2
a1664 2
      if (cptr[i]) {
         amount += cptr[i];
d1671 2
a1672 2
   if (cptr[PLAT]) {
      sprintf(buf, "%s &0&b&6%d &0platinum&0", buf, cptr[0]);
d1678 2
a1679 2
   if (cptr[GOLD]) {
      sprintf(buf, "%s &0&b&3%d &0gold&0", buf, cptr[1]);
d1687 2
a1688 2
   if (cptr[SILVER]) {
      sprintf(buf, "%s %d silver", buf, cptr[2]);
d1694 2
a1695 2
   if (cptr[COPPER])
      sprintf(buf, "%s &0&3%d&0 copper", buf, cptr[3]);
d1908 6
@


1.66
log
@Add functions to format strings for printin lengths and weights.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.65 2008/01/04 01:53:26 jps Exp jps $
a397 45
int number_of_groupees(struct char_data *ch)
{/*counts the number of groupees in this persons group and returns it*/
  int tot_members = 0;
  struct char_data *k;
  struct char_data *m;
  struct group_type *f;
  struct mgroup_type *g;
  k = (ch->groupmaster ? ch->groupmaster : ch);
  /*k now is the group master*/
  
  if (!(IS_AFFECTED(k, AFF_GROUP)))
    {
      mudlog("In group exp give and leader not grouped?", NRM, LVL_GOD, FALSE);
      return 0;
    }
  
  if (IS_AFFECTED2(k, AFF2_MGROUP))
    {
      m = (k->mgroupmaster ? k->mgroupmaster : k);
      if (m->in_room == ch->in_room)
	tot_members = 1;/*m now is major group master*/
      for(f=m->groupees;f;f=f->next)
	if (f->groupee->in_room == ch->in_room)
	  tot_members++;/*major group masters group*/
      for (g = m->mgroupees;g;g=g->next)
	{
	  if (g->mgroupee->in_room == ch->in_room)
	    tot_members++;
	  for (f=g->mgroupee->groupees;f;f=f->next)
	    if (f->groupee->in_room == ch->in_room)  
	      tot_members++;
	}
    }
  else
    {/*just group count*/
      if (k->in_room == ch->in_room)
	tot_members = 1;
      for(f=k->groupees;f;f=f->next)
	if (f->groupee->in_room == ch->in_room)
	  tot_members++;
    }
  return tot_members;
  
}

d706 1
a706 1
  if (IS_AFFECTED(ch, AFF_GROUP)) {
d711 1
a711 1
    if (IS_AFFECTED(tch, AFF_GROUP)) {
d717 1
a717 1
      if (IS_AFFECTED2(k, AFF2_MGROUP) && IS_AFFECTED2(l, AFF2_MGROUP)) {
a1406 177
int NumAttackers(struct char_data *ch)
{
  struct char_data *tch;
  int total = 0;
  
  if (!SanityCheck(ch, "NumAttackers"))
    return -1;
  
  if (ALONE(ch))
    return 0;
  
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
/***************************************************************************
 *    if (tch == tch->next_in_room) {
 *      log("Uh oh, infinite loop bug! Utils.c - NumAttackers!");
 *      return 0;
 *    }
 ***************************************************************************/
    if (tch->char_specials.fighting && (tch->char_specials.fighting == ch))
      total++;
  } 

  return total;
}

bool SanityCheck(struct char_data *ch, const char *calling)
{
  if (!ch) {
    
    return FALSE;
  }
  
  if (ch->in_room == -1) 
    return FALSE;
  
  return TRUE;
}
#define NEWSHIT 1
#ifdef NEWSHIT
bool statsave(struct char_data *ch, int stat, int mod)
{
  int save_num;
  
  if (!SanityCheck(ch, "statsave"))
    return FALSE;
  
  /* change this when adding other stats 
     if ((stat != APPLY_AGI) && (stat != APPLY_INT))
     return FALSE;*/
  
  switch (stat) {
    
  case APPLY_DEX:
    
    save_num = STAT_INDEX(GET_DEX(ch)) + mod;
    
    if (IS_AFFECTED(ch, AFF_HASTE))
      save_num *= 2;
    
    /*if (IS_AFFECTED2(ch, AFF2_SLOW))
      save_num /= 2;*/
    
    /* those heavy loaded folks are less than nimble eh? */
    if (IS_CARRYING_W(ch) > 299)
      save_num -= 5;
    else if (IS_CARRYING_W(ch) > 199)
      save_num -= 3;
    else if (IS_CARRYING_W(ch) > 99)
      save_num -= 1;
    
    /* and let us penalize for being off balance eh? 
       if (IS_AFFECTED2(ch, AFF2_STUNNED))
       save_num -= 5;*/
    
    save_num += GET_POS(ch) - 3;
    
    /* there are a few bonuses */
    if (IS_AFFECTED(ch, AFF_FLYING) || IS_AFFECTED2(ch, AFF2_LEVITATE))
      save_num += 3;
    
    break;
  case APPLY_INT:
    save_num = STAT_INDEX(GET_INT(ch)) + mod;
    
    break;
  case APPLY_WIS:
    save_num = STAT_INDEX(GET_WIS(ch)) + mod;
    
    break;
  case APPLY_STR:
    save_num = STAT_INDEX(GET_STR(ch)) + mod;
    
    break;
  case APPLY_CON:
    save_num = STAT_INDEX(GET_CON(ch)) + mod;
    
    break;
  default:
    return FALSE;
    break;
  }
  
  return (number(1, 20) < BOUNDED(1, save_num, 20));
}

int STAT_INDEX(int v)
{
  if (v < 1)
    return 0;
  else if (v < 10)
    return 1;
  else if (v < 16)
    return 2;
  else if (v < 22)
    return 3;
  else if (v < 28)
    return 4;
  else if (v < 34)
    return 5;
  else if (v < 40)
    return 6;
  else if (v < 46)
    return 7;
  else if (v < 51)
    return 8;
  else if (v < 56)
    return 9;
  else if (v < 62)
    return 10;
  else if (v < 68)
    return 11;
  else if (v < 74)
    return 12;
  else if (v < 80)
    return 13;
  else if (v < 86)
    return 14;
  else if (v < 92)
    return 15;
  else if (v < 101)
    return 16;
  
  return ((v - 101) / 12 + 17);
}
bool are_together(struct char_data *ch1, struct char_data *ch2)
{
  struct follow_type *k1, *k2;
  if (!ch1 || !ch2)
    return (FALSE);
  k1 = ch1->followers;
  k2 = ch2->followers;
  
  if ((ch1 == k2->follower) || (ch2 == k1->follower))
    return (TRUE);
  else if (ch1->followers && (ch1->followers == ch2->followers))
    return (TRUE);
  
  return (FALSE);
}

bool has_help(struct char_data *ch)
{		/* Function to enhance NPC interpretations*/
  struct char_data *tmp = NULL;
  
  if (!ch)
    return (FALSE);
  
  for (tmp = world[ch->in_room].people; tmp; tmp = tmp->next_in_room) {
    if (tmp == ch)
      continue;
    if (are_together(ch, tmp))
      return (TRUE);
  }
  return (FALSE);
}
#endif

d1445 1
a1445 1
const char *movewords(struct char_data *ch, int cmd, int room, int leaving)
d1450 1
a1450 1
  if ((IS_AFFECTED2(ch, AFF2_LEVITATE) && ((cmd == 4) || (cmd == 5))))
d1453 1
a1453 4
  if ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
      (SECT(ch->in_room) == SECT_UNDERWATER) ||
      (SECT(ch->in_room) == SECT_WATER_NOSWIM)) {
    
d1455 1
a1455 1
      if (IS_AFFECTED2(ch, AFF2_WATERBREATH))
d1467 1
a1467 1
  if ((load_modifier(ch) > 199))
d1470 2
a1471 5
  /* added NPC check to stop crashes.  -Fingon */
  if(!IS_NPC(ch)) {
    if ((GET_COND(ch, DRUNK) > 6))
      return (leaving ? "staggers" : "staggers in");
  }
d1473 4
a1476 4
  if (((IS_AFFECTED(ch, AFF_BLIND)) ||
       (IS_DARK(room) &&
	!IS_AFFECTED(ch, AFF_INFRAVISION))))
    return(leaving ? "stumbles" : "stumbles in");
a1491 19
    /*case RACE_W_ELEMENTAL:
     * return (leaving ? "flows" : "flows in");
     *
     *case RACE_A_ELEMENTAL:
     *case RACE_POSSESSED:
     *return (leaving ? "flies" : "flies in");
     *
     *case RACE_INSECT:
     *case RACE_PARASITE:
     * return (leaving ? "skitters" : "skitters in");
     *
     *case RACE_ARACHNID:
     *return (leaving ? "scuttles" : "scuttles in");
     *
     *case RACE_SLIME:
     *return (leaving ? "oozes" : "oozes in");
     *
     *case RACE_ILLITHID:
     */
a1494 2
    /*case RACE_CANINE:
      case RACE_CARNIVORE:*/
a1497 32
    /*case RACE_BIRD:
      case RACE_FAERIE:
      case RACE_RAPTOR:
      return (leaving ? "flutters" : "flutters in");
      
      case RACE_GHOST:
      case RACE_SPIRIT:
      return (leaving ? "glides" : "glides in");
      
      case RACE_FELINE:
      return (leaving ? "stalks" : "stalks in");
      
      case RACE_FISH:
      return (leaving ? "flops" : "flops in");   / *  swims handled above * / 
    
       case RACE_CENTAUR:
       case RACE_HERBIVORE:
       case RACE_HORSE:
       return (leaving ? "walks" : "walks in");
       
       case RACE_ANGEL:
       case RACE_DEMON:
       case RACE_DEVIL:
       case RACE_HIGH_UNDEAD:
       case RACE_LYCANTH:
       case RACE_VAMPIRE:
       return (leaving ? "strides" : "strides in");
       
       case RACE_NAGA:
       case RACE_SNAKE:
       return (leaving ? "slithers" : "slithers in");
    */
a1498 1
    /*case RACE_DRAGONKIN:*/
a1499 3
    /*
      case RACE_F_ELEMENTAL:
      return (leaving ? "blazes" : "blazes in");*/
d1659 1
a1659 1
void statemoney(char *buf, int *cptr) {
d1671 1
a1671 1
   if (cptr[0]) {
d1678 1
a1678 1
   if (cptr[1]) {
d1687 1
a1687 1
   if (cptr[2]) {
d1694 1
a1694 1
   if (cptr[3])
d1908 3
@


1.65
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.64 2008/01/03 12:46:20 jps Exp jps $
d2156 35
d2193 4
@


1.64
log
@New string function with_indefinite_article.
Renamed CLASS_MAGIC_USER to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.63 2007/12/25 20:31:54 jps Exp jps $
d28 1
d2158 4
@


1.63
log
@Also make exp_group_bonus() not overflow.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.62 2007/12/25 20:28:57 jps Exp jps $
d111 1
a111 1
    case CLASS_MAGIC_USER:
d2077 78
d2157 3
@


1.62
log
@Change exp_highlevel_bonus() not to overflow with large values.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.61 2007/12/25 05:49:58 jps Exp jps $
d200 1
a200 1
  return (long)((130*inexp)/(long)100);
d2079 3
@


1.61
log
@event_target_valid() is of no further use in many places.
Actually, it sucks hard, but it's better than nothing in some
other places (such as fight.c).
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.60 2007/12/25 05:41:49 jps Exp jps $
d205 2
a206 2
  
  return (long)(((100 + ((long)(lvldiff*1.5))) * inexp)/(long)100);
d2079 5
@


1.60
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.59 2007/12/20 03:04:11 jps Exp jps $
d534 1
d536 7
a542 10
   if (event_target_valid(ch)) {
      /* Critter is going to leave the game now */

      /* Send a message to those nearby */
      if (GET_POS(ch) < POS_RESTING)
         act("With a heroic effort, $n drags $mself to $s feet and runs off.",
               TRUE, ch, 0, 0, TO_ROOM);
      else
         act("$n turns and moves off, disappearing swiftly into the distance.",
               TRUE, ch, 0, 0, TO_ROOM);
d544 6
a549 6
      /* Destroy all of its items (else extract_char() will dump them
       * on the ground) */
      for (i = 0; i < NUM_WEARS; i++)
         if (GET_EQ(ch, i))
            Crash_extract_objs(GET_EQ(ch, i));
      Crash_extract_objs(ch->carrying);
d551 2
a552 3
      /* And finally get rid of this critter. */
      extract_char(ch);
   }
d2079 5
@


1.59
log
@Fix ip formatting func.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.58 2007/12/19 20:57:58 myc Exp jps $
d532 1
a532 1
   struct char_data *ch = (struct char_data *)event_obj;
d561 1
a561 1
   struct char_data *ch = (struct char_data *)event_obj;
d624 2
a625 1
        event_create(mobquit_event, ch, 3 RL_SEC);
d2082 3
@


1.58
log
@Added const modifiers to str_cmp, strn_cmp, log, touch, and mudlog.
Made is_playing check descriptor->original too.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.57 2007/11/22 23:33:23 jps Exp myc $
d2070 2
a2071 2
   if (octval > 255) {
      /* Invalid value */
a2074 4
   if (octet != 3) {
      /* Incorrect number of octets */
      return 1;
   }
d2081 4
@


1.57
log
@Added normalize_ip_address function.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.56 2007/10/11 20:35:06 myc Exp jps $
d266 1
a266 1
int str_cmp(char *arg1, char *arg2)
d284 1
a284 1
int strn_cmp(char *arg1, char *arg2, int n)
d312 1
a312 1
void log(char *str)
d324 1
a324 1
int touch(char *path)
d342 1
a342 1
void mudlog(char *str, char type, int level, byte file)
d1199 8
a1206 6
  struct descriptor_data *i, *next_i;
  for (i = descriptor_list; i; i = next_i) {
    next_i = i->next;
    if(i->connected == CON_PLAYING && !strcmp(i->character->player.name,CAP(vict_name)))
      return i->character;
  }
d2085 3
@


1.56
log
@Since monks got nerfed a long time ago, decreasing the exp to level.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.55 2007/10/02 02:52:27 myc Exp myc $
d2027 54
d2083 3
@


1.55
log
@Added AFF_SNEAK back in, so changed movewords.  Got rid of
stop_ignoring_me.  There's no way to check who you are ignoring now.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.54 2007/09/21 01:20:19 myc Exp myc $
d124 1
a124 1
      xfactor = 2.5;
d2029 4
@


1.54
log
@Fixing escape_ansi's behavior with &&.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.53 2007/09/20 21:20:43 myc Exp myc $
d876 1
a876 1
	{	
d1705 1
a1705 1
  if (IS_HIDDEN(ch) || OUTDOOR_SNEAK(ch))
a1795 14
void stop_ignoring_me(struct char_data *ch)
{
  struct char_data *tc, *next_tc = NULL;
  
  for (tc = character_list; tc; tc = next_tc) {
    if (tc->player_specials) {
      if (tc->player_specials->ignored == ch) {
        send_to_char("The person you are ignoring has just quit the game.\r\n", tc);
        tc->player_specials->ignored = NULL;
      }
    }
  }
}

d1799 1
a1799 1
  if((fd=fopen(MAKE_COUNT, "r"))) {
d2029 3
@


1.53
log
@Hide points and perception are in.  Changing movewords to handle this.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.52 2007/09/03 22:53:54 jps Exp myc $
d1429 2
a1430 2
  for(;;) {
    if(*the_string == '&') {
d1432 3
d2043 3
@


1.52
log
@Make a person's flames go out automatically if they enter a water room.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.51 2007/08/14 22:43:07 myc Exp jps $
d1702 1
a1702 1
  if (IS_AFFECTED(ch, AFF_SNEAK) || OUTDOOR_SNEAK(ch))
d2040 3
@


1.51
log
@Adding conceal, corner, shadow, and stealth skills.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.50 2007/08/04 14:40:35 myc Exp myc $
d559 15
d2040 3
@


1.50
log
@sprintbit couldn't handle the 32nd bit previously, because of an infinite
loop bug.  Now it's fine.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.49 2007/07/19 21:59:20 jps Exp myc $
d579 2
d612 1
d1071 5
a1075 3
  act("You now follow $N.", FALSE, ch, 0, leader, TO_CHAR);
  act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
  act("$n starts to follow $N.", TRUE, ch, 0, leader, TO_NOTVICT);
d2025 4
@


1.49
log
@Add utility funciton next_line.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.48 2007/07/14 04:18:11 jps Exp jps $
d377 2
a378 2
  long nr;
  
d380 7
a386 11
  
  if (bitvector < 0) {
    strcpy(result, "<INVALID BITVECTOR>");
    return;
  }
  for (nr = 0; bitvector; bitvector >>= 1) {
    if (IS_SET(bitvector, 1)) {
      if (*names[nr] != '\n') {
	strcat(result, names[nr]);
	strcat(result, " ");
      } else
d390 1
a390 1
      nr++;
d392 1
a392 1
  
d2020 3
@


1.48
log
@Pets (i.e., charmed mobs that were not charmed by a spell) will now
quit the game when attacked by their master, or when their master
leaves the game. The main reason is to keep powerful summoned
mounts out of the hands of other players, but it will also cut
back on clutter from ordinary mounts and pets.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.47 2007/07/02 04:40:05 jps Exp jps $
d1361 21
d2024 7
@


1.47
log
@Fix off-by-one-crash-causing bug in format_text.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.46 2007/07/02 04:22:32 jps Exp jps $
d27 3
d534 28
d566 1
a566 1
void stop_follower(struct char_data * ch)
d573 7
a579 3
    act("You realize that $N is a jerk!", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n realizes that $N is a jerk!", FALSE, ch, 0, ch->master, TO_NOTVICT);
    act("$n hates your guts!", FALSE, ch, 0, ch->master, TO_VICT);
d582 1
d600 13
a614 1
  REMOVE_BIT(AFF_FLAGS(ch), AFF_CHARM);
d625 1
a625 1
    stop_follower(ch);
d629 1
a629 1
    stop_follower(k->follower);
d2003 3
@


1.46
log
@Fix str_replace so you can't cause segfaults by increasing buffers
by one byte with /r command. And removed a minor memory leak.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.45 2007/06/24 02:51:44 jps Exp jps $
d1295 1
a1295 1
  RECREATE(*ptr_string, char, MIN(maxlen, strlen(formated)+3));
d1955 4
@


1.45
log
@Add function startsvowel.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.44 2007/05/29 00:36:03 jps Exp jps $
a1143 3
/* string manipulation fucntion originally by Darren Wilson */
/* (wilson@@shark.cc.cc.ca.us) improved and bug fixed by Chris (zero@@cnw.com) */
/* completely re-written again by M. Scott 10/15/96 (scottm@@workcommn.net), */
d1145 2
a1146 1
/* and return the # of replacements */
d1153 1
a1153 1
  if ((int)((strlen(*string) - strlen(pattern)) + strlen(replacement)) > max_size)
d1156 1
a1156 1
  CREATE(replace_buffer, char, max_size);
d1163 4
a1169 4
      if ((int)((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement))) > max_size) {
	i = -1;
	break;
      }
d1177 1
a1177 2
  }
  else {
a1187 1
  if (i == 0) return 0;
d1955 3
@


1.44
log
@Make a utility function find_zone, to find a zone's entry in the zone
table, from a vnum.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.43 2007/05/11 19:34:15 myc Exp jps $
d1937 20
d1959 4
@


1.43
log
@Modified the quest command functions so they are thin wrappers for
perform_quest() in quest.c.  Error handling and messages should be
much better now.  Advance and rewind now accept another argument
specifying how many stages to advance or rewind.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.42 2007/04/18 00:05:59 myc Exp myc $
d32 1
d1927 10
d1939 6
@


1.42
log
@Prompt parser has been totally rewritten so it won't print garbage
characters anymore.  Also, some new features were added.  Giving the
prompt command back to mortals.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.41 2007/04/04 13:31:02 jps Exp myc $
d298 1
a298 1
  char buf[150];
d310 1
d314 2
a315 2
  strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_LOG, localtime(&ct));
  fprintf(stderr, "%-24.24s :: %s\n", buf1, str);
d340 1
a340 1
  char buf[MAX_STRING_LENGTH];
d347 1
a347 1
  strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_LOG, localtime(&ct));
d350 1
a350 1
    fprintf(stderr, "%-24.24s :: %s\n", buf1, str);
d1928 5
@


1.41
log
@Add year to log timestamps and other dates.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.40 2007/03/27 04:27:05 myc Exp jps $
d1340 25
d1927 3
@


1.40
log
@Fixed crash bug in is_grouped...major group should be better behaved
now.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.39 2006/11/26 08:31:17 jps Exp myc $
d311 1
a311 2
  char *tmstr;
  
d313 2
a314 3
  tmstr = asctime(localtime(&ct));
  *(tmstr + strlen(tmstr) - 1) = '\0';
  fprintf(stderr, "%-19.19s :: %s\n", tmstr, str);
d342 1
a342 1
  char *tmp, tp;
d346 1
a346 1
  tmp = asctime(localtime(&ct));
d349 1
a349 1
    fprintf(stderr, "%-19.19s :: %s\n", tmp, str);
d1902 4
@


1.39
log
@Added function yesno_result to standardize handling of nanny's
yes/no questions (in interpreter.c).
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.38 2006/11/18 09:08:15 jps Exp jps $
d688 21
a708 19
  struct char_data *k;
  struct char_data *l = NULL;
  if (IS_AFFECTED(ch, AFF_GROUP))
    {/*k = casters group leader*/
      k = (ch->groupmaster ? ch->groupmaster : ch);
      if (IS_AFFECTED(tch, AFF_GROUP))
	{
	  l = (tch->groupmaster ? tch->groupmaster : tch);
	  if (l == k)
	    {
	      return TRUE;/*handles if in same group*/
	    }}
      
      if (IS_AFFECTED2(k, AFF2_MGROUP))
	{/*m = casters his major group master*/
	  if ((l->mgroupmaster ? l->mgroupmaster : l) == (k->mgroupmaster ? k->mgroupmaster : k))
	    {
	      return TRUE;/*handles if in mgroup*/
	    }		}
d710 2
a711 1
  
d1904 4
@


1.38
log
@Add function statemoney to pretty-print coins
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.37 2006/11/18 07:22:34 jps Exp jps $
d1888 11
d1901 3
@


1.37
log
@Add isplural function
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.36 2006/11/13 15:54:22 jps Exp jps $
d1845 2
d1848 39
d1890 3
@


1.36
log
@Fix widespread misuse of the hide_invisible parameter to act().
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.35 2006/11/13 02:48:27 jps Exp jps $
d1833 12
d1849 3
@


1.35
log
@Fix pointer bug when reading a 0-length file.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.34 2006/11/11 16:13:08 jps Exp jps $
d856 1
a856 1
      act("&0&2&bYou accept $n into your group.&0", TRUE, ch, 0, groupleader, TO_VICT);
d996 1
a996 1
      act("&0&1You accept $n into your major group.&0", TRUE, ch, 0, mgroupleader, TO_VICT);
d1022 1
a1022 2
  if (CAN_SEE(leader, ch))
    act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
d1837 3
@


1.34
log
@Fix CAP so it correctly capitalizes strings with color codes at the beginning.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.33 2006/11/08 09:16:40 jps Exp jps $
d1039 2
d1838 3
@


1.33
log
@Fixed missing punctuation in "You have become new leader" messages
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.32 2006/11/08 05:29:11 jps Exp jps $
d1823 2
d1826 5
d1836 3
@


1.32
log
@Better code for trimming the end of formatted descs.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.31 2006/11/07 18:02:05 jps Exp $
d768 1
a768 1
  send_to_char("&0&2&bYou have become the group leader&0\r\n", l);
d783 1
a783 1
      send_to_char("&0&1You have become the major group leader&0\r\n", l);
d834 1
a834 1
	      act("&0&7&bYou loose $n's consent.&0", FALSE, ch, 0, target, TO_VICT);
d959 1
a959 1
  send_to_char("&0&1You have become the new &1major&0&1 group leader&0\r\n", l);
d1829 3
@


1.31
log
@Stop extra blank lines from appearing after /f or /fi formatting.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.30 2006/07/20 07:39:31 cjd Exp jps $
d1286 2
a1287 1
  /* Trim trailing spaces, otherwise they will mess up descs. */
d1289 3
a1291 4
  while (flow > formated && flow[0] == ' ') {
     flow[0] = 0;
     flow--;
  }
d1829 3
@


1.30
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.29 2003/08/04 02:11:30 jjl Exp $
d1286 6
d1829 3
@


1.29
log
@Enabled random gem drop on production.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.28 2003/08/02 17:42:50 jjl Exp jjl $
d813 1
a813 1
	  send_to_char("&0&7&bThe person you have concented has quit the game.&0\r\n", i);
d1823 3
@


1.28
log
@Added a random gem drop for mobs under level 60, for Zzur's insano-quest.
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.27 2003/06/23 01:47:09 jjl Exp $
a1738 5

#ifdef PRODUCTION
  return 0; 
#endif

d1823 3
@


1.27
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.26 2003/02/01 07:27:54 jjl Exp $
d1700 126
d1828 3
@


1.26
log
@Bout time.  This should fix (at least part) of the necro / zombie crash
bug.  Sooooomeone used a 50 char buffer to store 80 character strings.
*sigh*
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.25 2002/09/13 02:32:10 jjl Exp jjl $
d1078 3
d1702 5
@


1.25
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: utils.c,v 1.24 2001/03/13 01:07:34 dce Exp $
d631 16
a646 1
  char buf[50];
d1699 3
@


1.24
log
@Fixed some typos.
@
text
@d1 3
a3 1
// $Id: utils.c,v 1.23 2001/01/23 04:05:43 dce Exp $
d188 1
a188 1
  // exp = (long) (xfactor * (double)exp);
d1326 6
a1331 4
//    if (tch == tch->next_in_room) {
//      log("Uh oh, infinite loop bug! Utils.c - NumAttackers!");
//      return 0;
//    }
d1622 1
a1622 1
      return (leaving ? "flops" : "flops in");  *//* swims handled above */
d1624 1
a1624 1
    /* case RACE_CENTAUR:
d1682 106
a1787 101
// $Log: utils.c,v $
// Revision 1.23  2001/01/23 04:05:43  dce
// Fixed a crash bug in the stop_groupee function. Someone put a mud
// log before the free statement. And because the GET_NAME(ch) is no
// longer valid it was causing a crash. So it was the mudlog fuction
// sending nulls, that made it look like the free(k) was the problem
// this was also a problem for multiple groupees. Both are fixed.
//
// Revision 1.22  2000/11/25 02:33:15  rsd
// Altered comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.21  2000/10/27 00:34:45  mtp
// extra define for saving quests info
//
// Revision 1.20  2000/04/22 22:44:10  rsd
// fixed comment header. retabbed and braced sections of the code.
// Also fixed grammital error in disband.
//
// Revision 1.19  1999/09/16 01:15:11  dce
// Weight restrictions for monks...-hitroll, -damroll + ac
//
// Revision 1.18  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.17  1999/09/04 18:46:52  jimmy
// More small but important bug fixes found with insure.  These are all runtime fixes.
//
// Revision 1.16  1999/08/14 02:43:10  dce
// ** is one level up from 99
//
// Revision 1.15  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.14  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.13  1999/06/14 21:41:16  mud
// fixed the monk XP multiplier to 2.5 where it should be. This was overwritten by someone
// who checked in changes between version 1.09 and 1.10 without diffing.
// --gurlaek 6/14/1999
//
// Revision 1.12  1999/06/11 17:18:40  jimmy
// removed a really stupid log message that was spamming the syslog
//
// Revision 1.11  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.10  1999/05/04 17:19:33  dce
// Name accept system...version one...original code by Fingh, fixed up to work
// by Zantir.
//
// Revision 1.9  1999/05/02 20:29:30  mud
// Ok, moved monks to an exp-factor of 2.5 in a compromise
// with zantir grumble
//
// Revision 1.8  1999/05/02 20:25:51  mud
// made the exp-factor 3.0 for the overpowered monks
// take it back down when monks are balanced.
//
// Revision 1.7  1999/04/21 04:05:04  dce
// New Exp system.
// Exp_fix.c is the converter.
//
// Revision 1.6  1999/04/08 03:59:20  dce
// Fixed a crash bug
//
// Revision 1.5  1999/03/25 20:18:18  jimmy
// Added IS_NPC check to DRUNK code in movewards()
// fingon
//
// Revision 1.4  1999/02/06 02:06:21  jimmy
// I have no idea why, but a debug statment log(name)
// actually makes this work.  Hmmmm.  Can't pfile wipe
// without it.
// --Fingon
//
// Revision 1.3  1999/02/03 21:03:25  mud
// dos2unix
// Indented file
//
// Revision 1.2  1999/02/01 08:20:33  jimmy
// improved build counter
//
// Revision 1.1  1999/01/29 01:23:32  mud
// Initial revision
//
@


1.23
log
@Fixed a crash bug in the stop_groupee function. Someone put a mud
log before the free statement. And because the GET_NAME(ch) is no
longer valid it was causing a crash. So it was the mudlog fuction
sending nulls, that made it look like the free(k) was the problem
this was also a problem for multiple groupees. Both are fixed.
@
text
@d1 1
a1 1
// $Id: utils.c,v 1.22 2000/11/25 02:33:15 rsd Exp $
d795 1
a795 1
	  mudlog("Freeing consneted person", NRM, LVL_GOD, FALSE);
d1679 7
@


1.22
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: utils.c,v 1.21 2000/10/27 00:34:45 mtp Exp $
d641 2
a646 2
    sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
    mudlog(buf, CMP, LVL_GOD, FALSE);
d649 2
a653 2
    sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
    mudlog(buf, CMP, LVL_GOD, FALSE);
d1679 4
@


1.21
log
@extra define for saving quests info
@
text
@d1 1
a1 1
// $Id: utils.c,v 1.20 2000/04/22 22:44:10 rsd Exp $
d1679 3
d1691 76
@


1.20
log
@fixed comment header. retabbed and braced sections of the code.
Also fixed grammital error in disband.
@
text
@d1 1
a1 1
// $Id: utils.c,v 1.19 1999/09/16 01:15:11 dce Exp $
d1052 3
d1679 4
@


1.19
log
@Weight restrictions for monks...-hitroll, -damroll + ac
@
text
@d1 1
a1 1
// $Id: utils.c,v 1.18 1999/09/05 07:00:39 jimmy Exp $
d3 1
a3 1
 *   File: utils.c                                       Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d648 8
a655 10
  } 
  else 
    {			/* locate follower who is not head of list */
      for (k = ch->groupmaster->groupees; k->next->groupee != ch; k = k->next);
      j = k->next;
      k->next = j->next;
      sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
      mudlog(buf, CMP, LVL_GOD, FALSE);
      free(j);
    }
d658 8
a665 9
  if (last_member)
    {
      /*if last member remove his group from mgroup*/
      if ((IS_AFFECTED2(l, AFF2_MGROUP)))
	die_mgroupee(l);
      REMOVE_BIT(AFF_FLAGS(l), AFF_GROUP);
      l->groupees = NULL;
      send_to_char("&0&2&bYour group the disbanded.&0\r\n", l);
    }
d1676 3
@


1.18
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d28 25
d1676 4
a1679 1
// $Log$
@


1.17
log
@More small but important bug fixes found with insure.  These are all runtime fixes.
@
text
@d1 1
d1651 1
@


1.16
log
@** is one level up from 99
@
text
@d1000 1
a1000 1
    if (*temp)
d1002 1
@


1.15
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d133 1
a133 1
  else if (level <= 99)
d136 2
a137 2
  else if (level == 100)
    exp = 299999999;
@


1.14
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d133 1
a133 1
  else if (level < 99)
d164 1
a164 1
int exp_group_bonus(int inexp)
d166 1
a166 1
  return (int)((130*inexp)/100);
d169 1
a169 1
int exp_highlevel_bonus(int inexp, int lvldiff)
d172 1
a172 1
  return (int)(((100 + ((int)(lvldiff*1.5))) * inexp)/100);
@


1.13
log
@fixed the monk XP multiplier to 2.5 where it should be. This was overwritten by someone
who checked in changes between version 1.09 and 1.10 without diffing.
--gurlaek 6/14/1999
@
text
@d1012 9
a1021 4
int get_filename(char *orig_name, char *filename, int mode)
{
  char *prefix, *middle, *suffix, *ptr, name[64];
  
d1024 1
a1024 2
    prefix = "plrobjs";
    suffix = "objs";
d1027 4
a1030 2
    prefix = "plrtext";
    suffix = "text";
a1033 30
    break;
  }
  
  if (!*orig_name)
    return 0;
  
  strcpy(name, orig_name);
  /*log(name); Goddam this was hard to find --Gurlaek*/
  for (ptr = name; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  switch (LOWER(*name)) {
  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':
    middle = "A-E";
    break;
  case 'f':  case 'g':  case 'h':  case 'i':  case 'j':
    middle = "F-J";
    break;
  case 'k':  case 'l':  case 'm':  case 'n':  case 'o':
    middle = "K-O";
    break;
  case 'p':  case 'q':  case 'r':  case 's':  case 't':
    middle = "P-T";
    break;
  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':  case 'z':
    middle = "U-Z";
    break;
  default:
    middle = "ZZZ";
    break;
a1034 2

  sprintf(filename, "%s/%s/%s.%s", prefix, middle, name, suffix);
d1038 8
a1045 3
char *get_fname(char *orig_name, int mode)
{
  char *prefix, *middle, *suffix, *ptr, name[64];
d1047 2
a1048 1
  *buf = '\0';
d1052 1
a1052 2
    prefix = "plrobjs";
    suffix = "objs";
d1055 4
a1058 2
    prefix = "plrtext";
    suffix = "text";
a1061 31
    break;
  }
  
  if (!*orig_name)
    return 0;
  
  strcpy(name, orig_name);
  log(name);

  for (ptr = name; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  switch (LOWER(*name)) {
  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':
    middle = "A-E";
    break;
  case 'f':  case 'g':  case 'h':  case 'i':  case 'j':
    middle = "F-J";
    break;
  case 'k':  case 'l':  case 'm':  case 'n':  case 'o':
    middle = "K-O";
    break;
  case 'p':  case 'q':  case 'r':  case 's':  case 't':
    middle = "P-T";
    break;
  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':  case 'z':
    middle = "U-Z";
    break;
  default:
    middle = "ZZZ";
    break;
a1062 8

  log(name);

  sprintf(buf, "plrobjs/%s/%s.objs", middle, name);

  log("File name is");
  log(buf);

d1065 1
@


1.12
log
@removed a really stupid log message that was spamming the syslog
@
text
@a64 1
    case CLASS_MONK:
d88 3
@


1.11
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1033 1
a1033 1
  log(name);
@


1.10
log
@Name accept system...version one...original code by Fingh, fixed up to work
by Zantir.
@
text
@d235 1
a235 1
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i))))
d240 1
d253 1
a253 1
    if ((chk = LOWER(*(arg1 + i)) - LOWER(*(arg2 + i))))
d258 1
a258 1
  
@


1.9
log
@Ok, moved monks to an exp-factor of 2.5 in a compromise
with zantir grumble
@
text
@d65 1
a89 3
    case CLASS_MONK:
      xfactor = 2.5;
      break;
d1061 59
@


1.8
log
@made the exp-factor 3.0 for the overpowered monks
take it back down when monks are balanced.
@
text
@d90 1
a90 1
      xfactor = 3.0;
@


1.7
log
@New Exp system.
Exp_fix.c is the converter.
@
text
@a64 1
    case CLASS_MONK:
d88 3
@


1.6
log
@Fixed a crash bug
@
text
@d32 13
d50 1
a50 34
  int xfactor = 100;
  
  if (level <= 0)
    return exp;
  
  if (level < 30)
    exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
			 * ((double)((160.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
  else if (level < 40)
    exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
			 * ((double)((190.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
  else if (level < 45)
    exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
			 * ((double)((195.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
  else if (level < 50)
    exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
			 * ((double)((200.0 + (level - 5.0)) /level))) + (long)(level) * 12000);
  else if (level < 64)
    exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
			 * ((double)((270.0 + (level - 5.0)) /level))) + (long)(level) * 13000);
  else if (level < 100) {
    exp = (long) ((level+21) * 1000000); 

    /* exp = (long) ((long)((long)level * (long)level * (long)level * (long)level 
     * (fexp[level - 61])) + (long)(level) * 10000); 
     */

  } else
    exp = (long) ((level+21) * 1000000);

  /*
   *exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
   * (15.0)) + (long)(level) * 10000);
   */
d55 23
a77 1
    {
d79 1
a79 1
      xfactor = 110;
d82 1
a82 1
      xfactor = 115;
d85 1
a85 1
      xfactor = 105;
d88 1
a88 1
      xfactor = 105;
d91 1
a91 1
      xfactor = 100;
d93 2
a94 9
    }
  if (level >= 50)
    xfactor = 130;  
  if (level >= 51)
    xfactor = 140;
  if (level >= 52)
    xfactor = 195;
  if (level >= 99)
    xfactor = 240;
d96 43
a138 1
    xfactor = 300;
d140 2
a141 1
  exp = (long) ((double)(xfactor/100.0) * (double)exp);
d143 14
d1289 5
a1293 1
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
d1296 2
a1297 1
  
@


1.5
log
@Added IS_NPC check to DRUNK code in movewards()
fingon
@
text
@d1569 5
a1573 3
    if (tc->player_specials->ignored == ch) {
      send_to_char("The person you are ignoring has just quit the game.\r\n", tc);
      tc->player_specials->ignored = NULL;
@


1.4
log
@I have no idea why, but a debug statment log(name)
actually makes this work.  Hmmmm.  Can't pfile wipe
without it.
--Fingon
@
text
@d1459 8
a1466 2
  if ((load_modifier(ch) > 199) || (GET_COND(ch, DRUNK) > 6))
    return (leaving ? "staggers" : "staggers in");
@


1.3
log
@dos2unix
Indented file
@
text
@d980 1
@


1.2
log
@improved build counter
@
text
@d1 9
a9 9
/* ************************************************************************
*   File: utils.c                                       Part of CircleMUD *
*  Usage: various internal functions of a utility nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d33 1
a33 1
                  9.7, 10.2, 10.7, 11.3, 12.0};
d36 58
a93 54
long exp = 0;
int xfactor = 100;

if (level <= 0)
return exp;

if (level < 30)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((160.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 40)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((190.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 45)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((195.0 + (level - 20.0)) /level))) + (long)(level) * 10000);
else if (level < 50)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((200.0 + (level - 5.0)) /level))) + (long)(level) * 12000);
else if (level < 64)
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* ((double)((270.0 + (level - 5.0)) /level))) + (long)(level) * 13000);
else if (level < 100) {
exp = (long) ((level+21) * 1000000); 
/* exp = (long) ((long)((long)level * (long)level * (long)level * (long)level 
* (fexp[level - 61])) + (long)(level) * 10000); */
} else
exp = (long) ((level+21) * 1000000);
/*
exp = (long) ((long)((long)level * (long)level * (long)level * (long)level
* (15.0)) + (long)(level) * 10000);
*/

/*class exp converter*/
/*make sure you dont set anything past 300 for the xfactor*/
   switch (class)
   {
   case CLASS_MAGIC_USER:
	   xfactor = 110;
	   break;
   case CLASS_NECROMANCER:
	   xfactor = 115;
	   break;
   case CLASS_RANGER:
	   xfactor = 105;
	   break;
   case CLASS_WARRIOR:
        xfactor = 105;
            break;
   default:
	   xfactor = 100;
	   break;
   }
   if (level >= 50)
       xfactor = 130;  
d95 1
a95 1
       xfactor = 140;
d97 1
a97 1
       xfactor = 195;
d99 9
a107 9
       xfactor = 240;
   if (level >= 100)
	   xfactor = 300;

   exp = (long) ((double)(xfactor/100.0) * (double)exp);


    return exp;
  }
d112 1
a112 1
	return (int)((130*inexp)/100);
d117 2
a118 2

	return (int)(((100 + ((int)(lvldiff*1.5))) * inexp)/100);
d131 1
a131 1

d140 1
a140 1

d143 1
a143 1

d146 1
a146 1

d168 1
a168 1

d181 1
a181 1

d198 1
a198 1

d205 1
a205 1

d215 1
a215 1

d227 1
a227 1

d239 1
a239 1

d261 1
a261 1

d264 1
a264 1

d269 1
a269 1

d271 1
a271 1

d276 1
a276 1

d290 1
a290 1

d292 1
a292 1

d308 1
a308 1

d315 8
a322 8
    int tot_members = 0;
    struct char_data *k;
    struct char_data *m;
    struct group_type *f;
    struct mgroup_type *g;
    k = (ch->groupmaster ? ch->groupmaster : ch);
    /*k now is the group master*/

d324 5
a328 5
  {
  		mudlog("In group exp give and leader not grouped?", NRM, LVL_GOD, FALSE);
		return 0;
  }

d330 16
a345 16
  {
	  m = (k->mgroupmaster ? k->mgroupmaster : k);
	  if (m->in_room == ch->in_room)
		    tot_members = 1;/*m now is major group master*/
	  for(f=m->groupees;f;f=f->next)
		    if (f->groupee->in_room == ch->in_room)
		        tot_members++;/*major group masters group*/
	  for (g = m->mgroupees;g;g=g->next)
	  {
		if (g->mgroupee->in_room == ch->in_room)
		    tot_members++;
		    for (f=g->mgroupee->groupees;f;f=f->next)
			    if (f->groupee->in_room == ch->in_room)  
			        tot_members++;
	  }
  }
d347 9
a355 9
  {/*just group count*/
	  if (k->in_room == ch->in_room)
		tot_members = 1;
	  for(f=k->groupees;f;f=f->next)
		  if (f->groupee->in_room == ch->in_room)
			tot_members++;
  }
    return tot_members;

d361 1
a361 1

d366 1
a366 1

d379 1
a379 1

d381 1
a381 1

d384 1
a384 1

d387 1
a387 1

d390 1
a390 1

d401 1
a401 1

d403 1
a403 1

d406 1
a406 1

d409 1
a409 1

d412 1
a412 1

d414 1
a414 1

d423 1
a423 1

d425 1
a425 1

d427 1
a427 1

d437 1
a437 1

d442 1
a442 1

d453 1
a453 1

d455 1
a455 1

d467 1
a467 1

d474 1
a474 1

d479 1
a479 1

d490 1
a490 1

d493 1
a493 1

d502 10
a511 10
	struct group_type *f;
	char buf[100];
	int counter = 0;
	
		for(f = ch->groupees;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&2&bgroup&0 :conter %d, name %s", counter, GET_NAME(f->groupee));	
		act(buf, TRUE, ch, 0, 0, TO_ROOM);
	}
d515 10
a524 10
	struct follow_type *f;
	char buf[80];
	int counter = 0;
	
		for(f = ch->followers;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&2&bfollower&0 :conter %d, name %s", counter, GET_NAME(f->follower));	
		act(buf, TRUE, ch, 0, 0, TO_ROOM);
	}
d528 11
a538 11
	struct mgroup_type *f;
	char buf[100];
	int counter = 0;
		
	for(f = ch->mgroupees;f;f=f->next)
	{
		counter++;
		sprintf(buf,"&0&1mgroup &0:conter %d, name %s:", counter, GET_NAME(f->mgroupee));	
		act(buf, TRUE, ch, 0, 0, TO_ROOM);
	
	}
d544 43
a586 43
	void die_mgroupee(struct char_data * ch);
	struct group_type *j, *k;
	char buf[50];
	struct char_data *l;
	int counter = 0;
	bool last_member = 0;
	assert(ch->groupmaster);

	l = ch->groupmaster;
	for(k = l->groupees;k;k=k->next)
		counter++;
	if (counter == 1)
		last_member = 1;
	if (ch->groupmaster->groupees->groupee == ch) {	/* Head of follower-list? */
		k = ch->groupmaster->groupees;
		ch->groupmaster->groupees = k->next;
		if (counter == 1)
			send_to_char("&2&bYour group is disbanded.&0\r\n", ch);
sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(k);
	} 
	else 
	{			/* locate follower who is not head of list */
		for (k = ch->groupmaster->groupees; k->next->groupee != ch; k = k->next);
		j = k->next;
		k->next = j->next;
		sprintf(buf,"Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(j);
	}
	ch->groupmaster = NULL;
	REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
	if (last_member)
	{
	/*if last member remove his group from mgroup*/
		if ((IS_AFFECTED2(l, AFF2_MGROUP)))
			die_mgroupee(l);
		REMOVE_BIT(AFF_FLAGS(l), AFF_GROUP);
		l->groupees = NULL;
		send_to_char("&0&2&bYour group the disbanded.&0\r\n", l);
	}

d591 22
a612 22
	struct char_data *k;
	struct char_data *l = NULL;
	if (IS_AFFECTED(ch, AFF_GROUP))
	{/*k = casters group leader*/
		k = (ch->groupmaster ? ch->groupmaster : ch);
		if (IS_AFFECTED(tch, AFF_GROUP))
		{
			l = (tch->groupmaster ? tch->groupmaster : tch);
			if (l == k)
{
				return TRUE;/*handles if in same group*/
		}}

		if (IS_AFFECTED2(k, AFF2_MGROUP))
		{/*m = casters his major group master*/
if ((l->mgroupmaster ? l->mgroupmaster : l) == (k->mgroupmaster ? k->mgroupmaster : k))
{
				return TRUE;/*handles if in mgroup*/
}		}
	}
                      
	return FALSE;
d619 27
a645 27
 struct mgroup_type *f;
 struct group_type *k;
 struct char_data *l;
 int counter = 0;
 bool was_mgroup_leader = 0;
 bool was_mgroupee = 0;
 void die_mgroupee(struct char_data *ch);
 void add_mgroupee(struct char_data *ch, struct char_data *mgroupleader, bool hide);
 void stop_mgroupee(struct char_data *ch, bool hide);
/*Both major group flags and group flags are handled here in this function*/
/*removal via death or often link loss*/
	
if (ch->groupmaster)/*If character has a group master pretty simple leaves here*/
{		/*however this does disband group if group less than 1 groupee*/
		
act("&0&2&b$N is no longer a member of your group.&0", FALSE, ch->groupmaster, 0, ch, TO_CHAR);
act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_VICT);
act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, ch->groupmaster, 0, ch, TO_NOTVICT);

		stop_groupee(ch, 0);
		return;
	}

	for (k = ch->groupees;k;k = k->next)
		counter++;/*counter counts  how many people in group*/
	k = ch->groupees;
    if (!(k->groupee))
d647 1
a647 1
        return;
d649 40
a688 9
	l = k->groupee;
	if ((IS_AFFECTED2(ch, AFF2_MGROUP)))
	{
		if (!ch->mgroupmaster)
			was_mgroup_leader = 1;
		else
			was_mgroupee = 1;
	}/*if effected by major group what rank was the character*/
	if (counter == 1)
d690 2
a691 4
act("&0&2&b$N is no longer a member of your group.&0", FALSE, l, 0, ch, TO_CHAR);
act("&0&2&bYou have been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_VICT);
act("&0&2&b$N has been kicked out of $n's group!&0", FALSE, l, 0, ch, TO_NOTVICT);

d693 11
a703 40
	stop_groupee(l, 1);
	if (counter == 1)
	{
				return;
	}
	SET_BIT(AFF_FLAGS(l), AFF_GROUP);
	l->groupmaster = NULL;
	send_to_char("&0&2&bYou have become the group leader&0\r\n", l);
	l->groupees = ch->groupees;
	for (k = l->groupees;k;k = k->next)
	{
		k->groupee->groupmaster = l;
		act("&0&2&bYou have a new group leader $N.&0", FALSE, k->groupee, 0, l, TO_CHAR);
	}

	REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
	ch->groupees = NULL;

	if (was_mgroup_leader)
	{
		SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
		l->mgroupmaster = NULL;
		send_to_char("&0&1You have become the major group leader&0\r\n", l);
		l->mgroupees = ch->mgroupees;
		for (f = l->mgroupees;f;f = f->next)
		{
				f->mgroupee->mgroupmaster = l;
	act("&0&1You have a new major group leader $N.&0", FALSE, f->mgroupee, 0, l, TO_CHAR);
		}
		REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
		ch->mgroupees = NULL;
		return;
	}
	if (was_mgroupee)
	{
		add_mgroupee(l, ch->mgroupmaster, 1);
		die_mgroupee(ch);
		return;
	}

d707 11
a717 12
 if so clean it up*/
	static struct char_data *i;
	extern struct char_data *character_list;

	for (i = character_list; i; i = i->next)
	{
		if (CONSENT(i) == ch)
		{	
			mudlog("Freeing consneted person", NRM, LVL_GOD, FALSE);
			send_to_char("&0&7&bThe person you have concented has quit the game.&0\r\n", i);
			CONSENT(i) = NULL;
		}
d719 1
d723 10
a732 3
	struct char_data *target;
return;
	if (CONSENT(ch))
d734 7
a740 15
		if (!(CAN_SEE(ch, CONSENT(ch)))) 
		{
			CONSENT(ch) = NULL;
			return;
		}
		else
		{
			if (target == CONSENT(ch))
			{
				act("&0&7&bYou revoke your consent to $N.&0", FALSE, ch, 0, target, TO_CHAR);
				act("&0&7&bYou loose $n's consent.&0", FALSE, ch, 0, target, TO_VICT);
				CONSENT(ch) = NULL;
				return;
			}
		}
d742 2
a743 1
	CONSENT(ch) = NULL;
d747 17
a763 17
	struct group_type *k;
	SET_BIT(AFF_FLAGS(ch), AFF_GROUP);	
	assert(!ch->groupmaster);
	ch->groupmaster = groupleader;
	
	CREATE(k, struct group_type, 1);
	k->groupee = ch;
	k->next = groupleader->groupees;
	groupleader->groupees = k;
	if (noisy)
	{
		act("&0&2&bYou have been accepted into $N's group.&0", FALSE, ch, 0, groupleader, TO_CHAR);
		act("&0&2&bYou accept $n into your group.&0", TRUE, ch, 0, groupleader, TO_VICT);
	act("&0&2&b$n has joined $N's group.&0", TRUE, ch, 0, groupleader,
TO_NOTVICT);

	}
d770 18
a787 42
	struct group_type *a;
	struct mgroup_type *j, *k;
	struct char_data *l;	
	char buf[100];
	int counter = 0;
	bool last_member = 0;
	assert(ch->mgroupmaster);
/*check to see if just one person left is so dispand group at end*/
	l = ch->mgroupmaster;
	for(k = l->mgroupees;k;k=k->next)
		counter++;
	if (counter == 1)
		last_member = 1;
	if (ch->mgroupmaster->mgroupees->mgroupee == ch) 
	{	/* Head of follower-list? */
		k = ch->mgroupmaster->mgroupees;
		ch->mgroupmaster->mgroupees = k->next;
		if (counter == 1)
		{
			for (a = l->groupees;a;a=a->next)
			{
				send_to_char("&0&1Your Major Group has been disbanded\r\n", a->groupee);

			}
		}
		sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
		mudlog(buf, CMP, LVL_GOD, FALSE); 
		free(k);
	} 
	else 
	{			/* locate follower who is not head of list */
		for (k = ch->mgroupmaster->mgroupees; k->next->mgroupee != ch; k = k->next);
		j = k->next;
		k->next = j->next;
		sprintf(buf,"Major Group Member:%s Freed by %s", GET_NAME(ch), GET_NAME(l));	
		mudlog(buf, CMP, LVL_GOD, FALSE);
		free(j);
	}
	ch->mgroupmaster = NULL;
	REMOVE_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);
/*if that was last on list lets disband this dude*/
	if (last_member)
d789 28
a816 4
		REMOVE_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
		l->mgroupees = NULL;
		send_to_char("&0&1Your disband the major group.&0\r\n", l);
	}
d829 13
a841 13
  {
	 
	  act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, ch->mgroupmaster, 0, ch, TO_CHAR);
	act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, ch->mgroupmaster, 0, ch, TO_VICT);
	act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
FALSE, ch->mgroupmaster, 0, ch, TO_NOTVICT);

 stop_mgroupee(ch, 0);
	  return;
  }
/*handle the death of a group leader*/
sprintf(buf,"in die mgroupee rare");	
		mudlog(buf, CMP, LVL_GOD, FALSE);
d844 29
a872 13
		counter++;	
	k = ch->mgroupees;
	l = k->mgroupee;
if (counter == 1)
{
	act("&0&1$N is no longer a member of your &bmajor&0&1 group.&0", FALSE, k->mgroupee, 0, ch, TO_CHAR);
	act("&0&1You have been kicked out of $n's &bmajor&0&1 group!&0", FALSE, k->mgroupee, 0, ch, TO_VICT);
	act("&0&1$N has been kicked out of $n's &bmajor&0&1 group!&0",
FALSE, k->mgroupee, 0, ch, TO_NOTVICT);

}
	stop_mgroupee(k->mgroupee, 1);
	if (counter ==1)
d874 1
a874 1
			return;
d876 2
a877 18
		SET_BIT(AFF2_FLAGS(l), AFF2_MGROUP);
	l->mgroupmaster = NULL;/*all mgroup leaders must have a null mgroupmaster*/
	send_to_char("&0&1You have become the new &1major&0&1 group leader&0\r\n", l);
	l->mgroupees = ch->mgroupees;
    for(f = l->groupees;f;f=f->next)
	{
		act("&0&2&bYour group has a new &0&1Major&0&1 group leader&0&2&b $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
	}
	for (k = ch->mgroupees; k; k = k->next) 
	{
		k->mgroupee->mgroupmaster = l;
		act("&0&1You have a new major group leader $N.&0", FALSE, k->mgroupee, 0, l, TO_CHAR);
		for (f = ch->groupees; f; f=f->next)
		{
		act("&0&1Your group has a new major group leader $N.&0", FALSE, f->groupee, 0, l, TO_CHAR);
		}
	}
   
d884 3
a886 3
	struct mgroup_type *k;

	if (IS_AFFECTED2(ch, AFF2_MGROUP))
d888 16
a903 16

	SET_BIT(AFF2_FLAGS(ch), AFF2_MGROUP);	
	assert(!ch->groupmaster);
	ch->mgroupmaster = mgroupleader;
	CREATE(k, struct mgroup_type, 1);
	k->mgroupee = ch;
	k->next = mgroupleader->mgroupees;
	mgroupleader->mgroupees = k;
	if (!hide)
	{
	act("&0&1You have been accepted into $N's major group.&0", FALSE, ch, 0, mgroupleader, TO_CHAR);
	act("&0&1You accept $n into your major group.&0", TRUE, ch, 0, mgroupleader, TO_VICT);
	act("&0&1$n has joined $N's major group.&0", TRUE, ch, 0,
mgroupleader, TO_NOTVICT);

	}
d913 1
a913 1

d915 1
a915 1

d917 1
a917 1

d919 1
a919 1

d923 1
a923 1

d941 1
a941 1

d948 1
a948 1

d961 1
a961 1

d975 1
a975 1

d978 1
a978 1

d1013 1
a1013 1

d1017 1
a1017 1

d1033 6
a1038 6
  /* string manipulation fucntion originally by Darren Wilson */
  /* (wilson@@shark.cc.cc.ca.us) improved and bug fixed by Chris (zero@@cnw.com) */
  /* completely re-written again by M. Scott 10/15/96 (scottm@@workcommn.net), */
  /* substitute appearances of 'pattern' with 'replacement' in string */
  /* and return the # of replacements */
  int replace_str(char **string, char *pattern, char *replacement, int rep_all,
d1040 6
a1045 159
     char *replace_buffer = NULL;
     char *flow, *jetsam, temp;
     int len, i;
    
     if ((int)((strlen(*string) - strlen(pattern)) + strlen(replacement)) > max_size)
       return -1;
     
     CREATE(replace_buffer, char, max_size);
     i = 0;
     jetsam = *string;
     flow = *string;
     *replace_buffer = '\0';
     if (rep_all) {
        while ((flow = (char *)strstr(flow, pattern)) != NULL) {
  	 i++;
  	 temp = *flow;
  	 *flow = '\0';
  	 if ((int)((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement))) > max_size) {
  	    i = -1;
  	    break;
  	 }
  	 strcat(replace_buffer, jetsam);
  	 strcat(replace_buffer, replacement);
  	 *flow = temp;
  	 flow += strlen(pattern);
  	 jetsam = flow;
        }
        strcat(replace_buffer, jetsam);
     }
     else {
        if ((flow = (char *)strstr(*string, pattern)) != NULL) {
  	 i++;
  	 flow += strlen(pattern);  
  	 len = ((char *)flow - (char *)*string) - strlen(pattern);
     
  	 strncpy(replace_buffer, *string, len);
  	 strcat(replace_buffer, replacement);
  	 strcat(replace_buffer, flow);
        }
     }
     if (i == 0) return 0;
     if (i > 0) {
        RECREATE(*string, char, strlen(replace_buffer) + 3);
        strcpy(*string, replace_buffer);
     }
     free(replace_buffer);
     return i;
  }
  
  
  /* re-formats message type formatted char * */
  /* (for strings edited with d->str) (mostly olc and mail)     */
  void format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen) {
     int total_chars, cap_next = TRUE, cap_next_next = FALSE;
     char *flow, *start = NULL, temp;
     /* warning: do not edit messages with max_str's of over this value */
     char formated[MAX_STRING_LENGTH];
     
     flow   = *ptr_string;
     if (!flow) return;
  
     if (IS_SET(mode, FORMAT_INDENT)) {
        strcpy(formated, "   ");
        total_chars = 3;
     }
     else {
        *formated = '\0';
        total_chars = 0;
     } 
  
     while (*flow != '\0') {
        while ((*flow == '\n') ||
  	     (*flow == '\r') ||
  	     (*flow == '\f') ||
  	     (*flow == '\t') ||
  	     (*flow == '\v') ||
  	     (*flow == ' ')) flow++;
  
        if (*flow != '\0') {
  
  	 start = flow++;
  	 while ((*flow != '\0') &&
  		(*flow != '\n') &&
  		(*flow != '\r') &&
  		(*flow != '\f') &&
   		(*flow != '\t') &&
  		(*flow != '\v') &&
  		(*flow != ' ') &&
  		(*flow != '.') &&
  		(*flow != '?') &&
  		(*flow != '!')) flow++;
  
  	 if (cap_next_next) {
  	    cap_next_next = FALSE;
  	    cap_next = TRUE;
  	 }
  
  	 /* this is so that if we stopped on a sentance .. we move off the sentance delim. */
  	 while ((*flow == '.') || (*flow == '!') || (*flow == '?')) {
  	    cap_next_next = TRUE;
  	    flow++;
  	 }
  	 
  	 temp = *flow;
  	 *flow = '\0';
  
  	 if ((total_chars + strlen(start) + 1) > 79) {
  	    strcat(formated, "\r\n");
   	    total_chars = 0;
  	 }
  
  	 if (!cap_next) {
  	    if (total_chars > 0) {
  	       strcat(formated, " ");
  	       total_chars++;
 	    }
  	 }
  	 else {
  	    cap_next = FALSE;
  	    *start = UPPER(*start);
  	 }
  
  	 total_chars += strlen(start);
  	 strcat(formated, start);
  
  	 *flow = temp;
        }
  
        if (cap_next_next) {
  	 if ((total_chars + 3) > 79) {
  	    strcat(formated, "\r\n");
  	    total_chars = 0;
  	 }
  	 else {
  	    strcat(formated, "  ");
  	    total_chars += 2;
  	 }
        }
     }
     strcat(formated, "\r\n");
  
     if ((int)(strlen(formated)) > maxlen) formated[maxlen] = '\0';
     RECREATE(*ptr_string, char, MIN(maxlen, strlen(formated)+3));
     strcpy(*ptr_string, formated);
  }

   /* strips \r's from line */
 char *stripcr(char *dest, const char *src) {
    int i, length;
    char *temp;
 
    if (!dest || !src) return NULL;
    temp = &dest[0];
    length = strlen(src);
    for (i = 0; *src && (i < length); i++, src++)
      if (*src != '\r') *(temp++) = *src;
    *temp = '\0';
    return dest;
 }
d1047 153
d1209 3
a1211 3
        default:
          i = "";
          break; 
d1220 1
a1220 1
          
d1229 1
a1229 1

d1232 1
a1232 1

d1235 1
a1235 1

d1239 1
a1239 1

d1246 1
a1246 1
     
d1248 1
a1248 1
}
d1260 1
a1260 1

d1263 1
a1263 1

d1265 3
a1267 3
  if ((stat != APPLY_AGI) && (stat != APPLY_INT))
    return FALSE;*/

d1269 5
a1273 5
  
    case APPLY_DEX:

 save_num = STAT_INDEX(GET_DEX(ch)) + mod;

d1276 1
a1276 1

d1279 1
a1279 1

d1287 1
a1287 1

d1289 3
a1291 3
    if (IS_AFFECTED2(ch, AFF2_STUNNED))
      save_num -= 5;*/

d1293 1
a1293 1

d1297 1
a1297 1

d1301 1
a1301 1

d1305 1
a1305 1

d1309 1
a1309 1

d1313 1
a1313 1

d1319 1
a1319 1

d1359 1
a1359 1

d1364 2
a1365 2
 struct follow_type *k1, *k2;
 if (!ch1 || !ch2)
d1369 1
a1369 1
 
d1374 1
a1374 1

d1381 1
a1381 1

d1384 1
a1384 1

d1405 1
a1405 1

d1408 1
a1408 1

d1437 1
a1437 1

d1442 8
a1449 5
		(SECT(ch->in_room) == SECT_UNDERWATER) ||
		(SECT(ch->in_room) == SECT_WATER_NOSWIM)) {

  if (SECT(ch->in_room) == SECT_UNDERWATER)
  if (IS_AFFECTED2(ch, AFF2_WATERBREATH))
d1451 1
a1451 4

   if (SECT(ch->in_room) == SECT_WATER_SWIM)
      return (leaving ? "swims" : "swims in");

d1454 1
a1454 1
      
d1457 1
a1457 1

d1460 1
a1460 1
    
d1465 1
a1465 1

d1468 1
a1468 1

d1471 1
a1471 1

d1474 1
a1474 1

d1479 20
a1498 19

  /*case RACE_W_ELEMENTAL:
    return (leaving ? "flows" : "flows in");

  case RACE_A_ELEMENTAL:
  case RACE_POSSESSED:
    return (leaving ? "flies" : "flies in");

  case RACE_INSECT:
  case RACE_PARASITE:
    return (leaving ? "skitters" : "skitters in");

  case RACE_ARACHNID:
    return (leaving ? "scuttles" : "scuttles in");

  case RACE_SLIME:
    return (leaving ? "oozes" : "oozes in");

  case RACE_ILLITHID:*/
d1501 3
a1503 3

  /*case RACE_CANINE:
  case RACE_CARNIVORE:*/
d1506 33
a1538 33

  /*case RACE_BIRD:
  case RACE_FAERIE:
  case RACE_RAPTOR:
    return (leaving ? "flutters" : "flutters in");
    
  case RACE_GHOST:
  case RACE_SPIRIT:
    return (leaving ? "glides" : "glides in");

  case RACE_FELINE:
    return (leaving ? "stalks" : "stalks in");

  case RACE_FISH:
    return (leaving ? "flops" : "flops in");  *//* swims handled above */

 /* case RACE_CENTAUR:
  case RACE_HERBIVORE:
  case RACE_HORSE:
    return (leaving ? "walks" : "walks in");

  case RACE_ANGEL:
  case RACE_DEMON:
  case RACE_DEVIL:
  case RACE_HIGH_UNDEAD:
  case RACE_LYCANTH:
  case RACE_VAMPIRE:
    return (leaving ? "strides" : "strides in");

  case RACE_NAGA:
  case RACE_SNAKE:
    return (leaving ? "slithers" : "slithers in");
*/
d1540 1
a1540 1
  /*case RACE_DRAGONKIN:*/
d1542 4
a1545 4
/*
  case RACE_F_ELEMENTAL:
    return (leaving ? "blazes" : "blazes in");*/

d1548 1
a1548 1

d1551 1
a1551 1

d1553 1
a1553 1

d1560 1
a1560 1

d1577 1
@


1.1
log
@Initial revision
@
text
@d1564 8
@
