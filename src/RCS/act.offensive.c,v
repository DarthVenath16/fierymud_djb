head	1.225;
access;
symbols;
locks; strict;
comment	@ * @;


1.225
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	2010.06.05.05.26.58;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2009.08.02.20.19.00;	author myc;	state Exp;
branches;
next	1.222;

1.222
date	2009.07.18.01.17.23;	author myc;	state Exp;
branches;
next	1.221;

1.221
date	2009.06.11.13.36.05;	author myc;	state Exp;
branches;
next	1.220;

1.220
date	2009.03.20.06.08.18;	author myc;	state Exp;
branches;
next	1.219;

1.219
date	2009.03.15.23.18.08;	author jps;	state Exp;
branches;
next	1.218;

1.218
date	2009.03.15.23.00.15;	author jps;	state Exp;
branches;
next	1.217;

1.217
date	2009.03.15.22.39.42;	author jps;	state Exp;
branches;
next	1.216;

1.216
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.215;

1.215
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.214;

1.214
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.213;

1.213
date	2009.03.07.22.28.08;	author jps;	state Exp;
branches;
next	1.212;

1.212
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.211;

1.211
date	2009.02.18.19.48.08;	author myc;	state Exp;
branches;
next	1.210;

1.210
date	2009.01.25.02.53.33;	author myc;	state Exp;
branches;
next	1.209;

1.209
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.208;

1.208
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.207;

1.207
date	2008.09.27.03.54.47;	author jps;	state Exp;
branches;
next	1.206;

1.206
date	2008.09.27.03.52.23;	author jps;	state Exp;
branches;
next	1.205;

1.205
date	2008.09.27.03.48.20;	author jps;	state Exp;
branches;
next	1.204;

1.204
date	2008.09.24.17.00.15;	author myc;	state Exp;
branches;
next	1.203;

1.203
date	2008.09.21.21.04.20;	author jps;	state Exp;
branches;
next	1.202;

1.202
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.201;

1.201
date	2008.09.20.07.27.45;	author jps;	state Exp;
branches;
next	1.200;

1.200
date	2008.09.14.04.34.30;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2008.09.14.03.49.32;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2008.09.14.02.08.01;	author jps;	state Exp;
branches;
next	1.197;

1.197
date	2008.09.14.01.47.58;	author jps;	state Exp;
branches;
next	1.196;

1.196
date	2008.09.13.16.34.44;	author jps;	state Exp;
branches;
next	1.195;

1.195
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.194;

1.194
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.193;

1.193
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.192;

1.192
date	2008.08.24.19.29.11;	author jps;	state Exp;
branches;
next	1.191;

1.191
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.190;

1.190
date	2008.08.10.03.10.26;	author jps;	state Exp;
branches;
next	1.189;

1.189
date	2008.08.09.18.16.21;	author jps;	state Exp;
branches;
next	1.188;

1.188
date	2008.07.27.06.39.18;	author jps;	state Exp;
branches;
next	1.187;

1.187
date	2008.07.13.17.23.08;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2008.06.21.17.29.43;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2008.06.21.06.30.43;	author jps;	state Exp;
branches;
next	1.184;

1.184
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.183;

1.183
date	2008.05.25.21.00.22;	author myc;	state Exp;
branches;
next	1.182;

1.182
date	2008.05.25.18.09.47;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2008.05.18.20.46.02;	author jps;	state Exp;
branches;
next	1.180;

1.180
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2008.05.18.02.33.56;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.177;

1.177
date	2008.05.14.05.31.37;	author jps;	state Exp;
branches;
next	1.176;

1.176
date	2008.05.14.05.11.42;	author jps;	state Exp;
branches;
next	1.175;

1.175
date	2008.05.11.05.56.04;	author jps;	state Exp;
branches;
next	1.174;

1.174
date	2008.05.10.16.20.08;	author jps;	state Exp;
branches;
next	1.173;

1.173
date	2008.04.14.02.32.31;	author jps;	state Exp;
branches;
next	1.172;

1.172
date	2008.04.13.20.53.50;	author jps;	state Exp;
branches;
next	1.171;

1.171
date	2008.04.12.21.13.18;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.169;

1.169
date	2008.04.05.05.04.24;	author myc;	state Exp;
branches;
next	1.168;

1.168
date	2008.04.04.21.42.28;	author jps;	state Exp;
branches;
next	1.167;

1.167
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2008.04.02.19.42.15;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.164;

1.164
date	2008.03.30.16.04.21;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2008.03.27.22.34.44;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2008.03.26.18.14.55;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2008.03.25.21.58.59;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2008.03.25.05.31.28;	author jps;	state Exp;
branches;
next	1.158;

1.158
date	2008.03.25.04.50.08;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.03.24.08.07.01;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.03.19.18.43.58;	author myc;	state Exp;
branches;
next	1.155;

1.155
date	2008.03.18.06.16.29;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.03.17.15.31.27;	author myc;	state Exp;
branches;
next	1.153;

1.153
date	2008.03.11.19.50.55;	author myc;	state Exp;
branches;
next	1.152;

1.152
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.151;

1.151
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.150;

1.150
date	2008.03.09.18.11.05;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.03.08.23.31.30;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.02.11.21.04.01;	author myc;	state Exp;
branches;
next	1.146;

1.146
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.145;

1.145
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.29.18.01.02;	author myc;	state Exp;
branches;
next	1.142;

1.142
date	2008.01.29.01.43.45;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.140;

1.140
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2008.01.27.00.46.29;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2008.01.27.00.43.14;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2008.01.26.12.28.05;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2008.01.23.16.42.06;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2008.01.23.05.31.50;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2008.01.23.04.45.43;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.01.22.15.11.38;	author jps;	state Exp;
branches;
next	1.131;

1.131
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2008.01.09.07.26.49;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.127;

1.127
date	2007.10.25.20.38.33;	author myc;	state Exp;
branches;
next	1.126;

1.126
date	2007.10.20.19.01.41;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2007.10.13.20.12.49;	author myc;	state Exp;
branches;
next	1.123;

1.123
date	2007.10.09.02.42.34;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.121;

1.121
date	2007.09.30.19.54.11;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2007.09.12.19.28.56;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2007.09.11.16.34.24;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2007.09.08.22.04.32;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2007.09.02.22.54.55;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2007.08.23.01.34.36;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2007.08.22.22.46.37;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2007.08.17.03.49.24;	author myc;	state Exp;
branches;
next	1.112;

1.112
date	2007.08.16.10.38.50;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2007.08.15.20.47.23;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2007.08.05.22.19.17;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2007.08.04.22.26.11;	author jps;	state Exp;
branches;
next	1.106;

1.106
date	2007.08.04.21.44.20;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2007.08.04.14.40.35;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2007.07.31.08.40.00;	author jps;	state Exp;
branches;
next	1.101;

1.101
date	2007.07.31.00.43.00;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2007.07.24.01.24.55;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.18.23.54.07;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2007.07.18.21.02.51;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2007.07.18.17.07.56;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.02.22.23.26;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.28.06.17.58;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.28.06.14.31;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.21.01.45.15;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.21.00.14.08;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.17.22.21.23;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.11.22.01.22;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.19.04.50.18;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.18.00.24.25;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2007.03.31.14.45.00;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.27.19.55.25;	author dce;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.27.15.47.50;	author dce;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.20.03.56.36;	author dce;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.06.04.16.44;	author dce;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.19.19.57.57;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.24.05.07.40;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2006.11.20.06.44.26;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2006.11.18.21.00.28;	author jps;	state Exp;
branches;
next	1.76;

1.76
date	2006.11.14.19.14.38;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.08.09.16.04;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.08.07.55.17;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2006.11.07.14.14.52;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.20.07.43.48;	author cjd;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.26.18.46.24;	author rls;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.26.04.28.30;	author rls;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.20.17.55.30;	author rls;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.11.15.29.57;	author rls;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.11.15.25.25;	author rls;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.20.16.18.11;	author cjd;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.05.04.43.22;	author jwk;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.02.22.19.52;	author cjd;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.18.03.12.53;	author rls;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.28.01.00.17;	author jjl;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.23.03.21.44;	author jjl;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.23.02.08.10;	author jjl;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.21.03.43.03;	author jjl;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.21.01.16.28;	author jjl;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.21.01.01.08;	author jjl;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.18.14.55.36;	author rls;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.16.02.00.22;	author jjl;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.04.08.19.06;	author jjl;	state Exp;
branches;
next	1.53;

1.53
date	2002.12.28.21.56.30;	author jjl;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.04.08.02.40;	author rls;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.02.03.19.21;	author rls;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.30.22.50.32;	author rls;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.24.04.44.55;	author rls;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.24.04.39.50;	author rls;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.21.02.38.38;	author jjl;	state Exp;
branches;
next	1.46;

1.46
date	2002.09.15.04.32.47;	author jjl;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.16.19.30.58;	author rls;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.30.13.09.05;	author dce;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.20.02.32.53;	author rls;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.19.02.06.30;	author dce;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.18.02.25.07;	author dce;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.07.00.48.47;	author dce;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.13.00.37.50;	author dce;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.12.02.45.03;	author dce;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.10.22.36.49;	author dce;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.07.03.34.48;	author dce;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.10.21.04.02;	author rjd;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.13.16.15.58;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.12.13.56.20;	author dce;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.10.18.45.33;	author dce;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.07.01.45.18;	author dce;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.04.17.50.23;	author dce;	state Exp;
branches;
next	1.28;

1.28
date	2000.12.06.00.08.55;	author mtp;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.20.03.55.57;	author rsd;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.22.22.26.58;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.17.00.50.54;	author rsd;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.26.21.13.19;	author cso;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.25.03.15.30;	author cso;	state Exp;
branches;
next	1.22;

1.22
date	99.12.06.20.18.25;	author cso;	state Exp;
branches;
next	1.21;

1.21
date	99.11.28.22.41.16;	author cso;	state Exp;
branches;
next	1.20;

1.20
date	99.10.30.15.18.41;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	99.09.16.01.43.06;	author dce;	state Exp;
branches;
next	1.18;

1.18
date	99.09.16.01.15.11;	author dce;	state Exp;
branches;
next	1.17;

1.17
date	99.09.08.07.06.03;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.09.08.00.10.52;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.14;

1.14
date	99.09.03.23.02.40;	author mtp;	state Exp;
branches;
next	1.13;

1.13
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.12;

1.12
date	99.07.22.17.43.59;	author jimmy;	state Exp;
branches;
next	1.11;

1.11
date	99.07.15.03.41.31;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.03.27.34;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.07.14.19.24.03;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.04.03.18.59.22;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.04.03.18.54.17;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.03.21.21.49.37;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.03.10.00.03.37;	author dce;	state Exp;
branches;
next	1.3;

1.3
date	99.03.08.23.24.48;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.02.20.18.41.36;	author dce;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.offensive.c                               Part of HubisMUD  *
 *  Usage: player-level commands of an offensive nature                    *
 *                                                                         *
 *                                                                         *
 *  HubisMUD is based on DikuMUD, Copyright (C) 1990, 1991.                *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"

/* extern variables */
extern struct room_data *world;
extern struct dex_skill_type dex_app_skill[];
extern struct descriptor_data *descriptor_list;
extern struct room_data *world;
extern int pk_allowed;
extern int summon_allowed;
extern int charm_allowed;
extern int sleep_allowed;

/* extern functions */
ACMD(do_return);
bool is_aggr_to(struct char_data *ch,struct char_data *target);
void improve_skill(struct char_data *ch, int skill);
void hit2(struct char_data * ch, struct char_data * victim, int type);
void raw_kill(struct char_data * ch, struct char_data * killer);
struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output);
void make_corpse(struct char_data * ch);
bool is_grouped(struct char_data *ch, struct char_data *tch);
int mag_savingthrow(struct char_data * ch, int type);
void quickdeath(struct char_data *victim, struct char_data *ch);
void die(struct char_data * ch, struct char_data * killer);
int mem_inMemory(struct char_data *ch, struct char_data *vict);
void Forgive_The_Basterd(struct char_data *ch);

ACMD(do_breath)
{
  ACMD(do_action);
  struct char_data *tch, *next_tch;
  int breath=0,group, message;
  extern char *breath_messages[];

  if(!ch)
    return;
  if(GET_SKILL(ch, SKILL_BREATH) < 1) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }

  one_argument(argument,arg);

  if(is_abbrev(arg, "lightning"))
    breath = SPELL_LIGHTNING_BREATH;
  if(is_abbrev(arg, "fire"))
    breath = SPELL_FIRE_BREATH;
  if(is_abbrev(arg, "gas"))
    breath = SPELL_GAS_BREATH;
  if(is_abbrev(arg, "frost"))
    breath = SPELL_FROST_BREATH;
  if(is_abbrev(arg, "acid"))
    breath = SPELL_ACID_BREATH;
  if(!breath)
    breath = number(SPELL_FIRE_BREATH,SPELL_LIGHTNING_BREATH);

  message = ((breath-651)*2)-2; /* hehe, well it works anyway :P */

  act(breath_messages[message],FALSE,ch,0,0,TO_CHAR);
  act(breath_messages[message+1],FALSE,ch,0,0,TO_ROOM);

  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;

      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      call_magic(ch, tch, 0, breath, GET_LEVEL(ch), CAST_BREATH);
    }
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
}

ACMD(do_roar)
{
  struct char_data *tch, *next_tch;
  int group;
  ACMD(do_flee);
  ACMD(do_action);

  if(!ch)
    return;
  if(GET_SKILL(ch, SKILL_ROAR) < 1) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }

  act("&9&b$n&9&b makes your soul quake with a vicious &1ROOOOOAAAAAARRRRRR!&0",FALSE, ch,0,0,TO_ROOM);
  act("&9&bYou take a deep breath and release a vicious &1ROOOOOAAAAARRRRRR!&0",FALSE, ch,0,0,TO_CHAR);

  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;

      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      if (mag_savingthrow(tch, SAVING_PARA))
	continue;
      else {
	if(GET_DEX_VAFF(tch)-15 < number(0,100) && GET_POS(tch) >= POS_FIGHTING) {
	  act("In your paniced rush to flee, you trip!",FALSE,tch,0,0,TO_CHAR);
	  act("In $n's paniced rush to flee, $e trips!",FALSE,tch,0,0,TO_ROOM);
	  GET_POS(tch) = POS_SITTING;
	  GET_POS1(tch) = POS_SITTING;
	  WAIT_STATE(tch,PULSE_VIOLENCE*2);
	  mag_affects(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
	}
	else {
	  do_flee(tch, NULL, 0, 0);
	}
      }
    }
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
}

ACMD(do_sweep)
{
  struct char_data *tch, *next_tch;
  int group;
  ACMD(do_flee);

  if(!ch)
    return;
  if(GET_SKILL(ch, SKILL_SWEEP) < 1) {
    send_to_char("Huh?!?\r\n", ch);
    return;
  }
  act("&2$n&2 sweeps with $s enormous tail!&0",FALSE, ch,0,0,TO_ROOM);
  act("&2You sweep with your enormous tail!&0",FALSE, ch,0,0,TO_CHAR);
  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;

      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      if ((GET_DEX_VAFF(tch)-15) > number(0,100) || GET_POS(tch) < POS_FIGHTING)
	continue;
      else {
	act("&3You are slammed full blast by $N's&3 tail!&0",FALSE,tch,0,ch,TO_CHAR);
	act("&3$n&3 is slammed to the ground by a mighty tail sweep!&0",FALSE,tch,0,0,TO_ROOM);
	GET_POS(tch) = POS_SITTING;
	GET_POS1(tch) = POS_SITTING;
	WAIT_STATE(tch, PULSE_VIOLENCE*2);
      }
    }
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
}

ACMD(do_assist)
{
  struct char_data *helpee, *opponent;

  if (FIGHTING(ch)) {
    send_to_char("You're already fighting!\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Whom do you wish to assist?\r\n", ch);
  else if (!(helpee = get_char_room_vis(ch, arg)))
    send_to_char(NOPERSON, ch);
  else if (helpee == ch)
    send_to_char("You can't help yourself any more than this!\r\n", ch);
  else {
    for (opponent = world[ch->in_room].people;
	 opponent && (FIGHTING(opponent) != helpee);
	 opponent = opponent->next_in_room)
      ;

    if (!opponent)
      act("But nobody is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (!CAN_SEE(ch, opponent))
      act("You can't see who is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (!pk_allowed && !IS_NPC(opponent))	/* prevent accidental pkill */
      act("Use 'murder' if you really want to attack $N.", FALSE,
	  ch, 0, opponent, TO_CHAR);
    else {
      act("You assist $N&0 heroically.",FALSE,ch,0,helpee,TO_CHAR);
      act("$n&0 assists you!", 0, ch, 0, helpee, TO_VICT);
      act("$n&0 heroically assists $N.", FALSE, ch, 0, helpee, TO_NOTVICT);
      hit(ch, opponent, TYPE_UNDEFINED);
    }
  }
}

ACMD(do_disengage)
{
  if(!FIGHTING(ch)) {
    send_to_char("You are not fighting anyone.",ch);
    return;
  }

  if(FIGHTING(FIGHTING(ch)) == ch) {
    send_to_char("Now way! You are fighting for your life!", ch);
    return;
  }

  stop_fighting(ch);
  send_to_char("You disengage from combat.", ch);
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}


ACMD(do_hit)
{
  struct char_data *vict;

  one_argument(argument, arg);

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    sprintf(buf, "&8It is just to damn dark!&0");
    send_to_char(buf, ch);
    return;
  }
if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
}

  if (!*arg)
    send_to_char("Hit who?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, arg)))
    send_to_char("They don't seem to be here.\r\n", ch);
  else if (vict == ch) {
    send_to_char("You hit yourself...OUCH!.\r\n", ch);
    act("$n hits $mself, and says OUCH!", FALSE, ch, 0, vict, TO_ROOM);
  } else if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master == vict))
    act("$N is just such a good friend, you simply can't hit $M.", FALSE, ch, 0, vict, TO_CHAR);
  else {
    if (!pk_allowed) {
      if (!IS_NPC(vict) && !IS_NPC(ch) && (subcmd != SCMD_MURDER)) {
	send_to_char("Use 'murder' to hit another player.\r\n", ch);
	return;
      }
      if (IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(vict))
	return;			/* you can't order a charmed pet to attack a
				 * player */
    }     /*All new for switch skill Banyal*/
    /*if(GET_POS(ch) < POS_STANDING) {
      send_to_char("&7Maybe you should get to your feet first?&0", ch);
      return;
      }else*/ if(FIGHTING(ch) == NULL) {
	hit(ch, vict, TYPE_UNDEFINED);
	WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	WAIT_STATE(vict, PULSE_VIOLENCE);
	return;
      }else if(vict == FIGHTING(ch)) {
	send_to_char("&7Your doing the best you can!&0", ch);
	return;
      }else if(GET_SKILL(ch, SKILL_SWITCH) > 0)
	if(number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
	  act("&8$n tries to switch opponents, though becomes confused!&0",
	      FALSE, ch, 0, vict, TO_ROOM);
	  send_to_char("&8You try to switch opponents and become confused&0",
		       ch);
	  stop_fighting(ch);
	  WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	  return;
	}else{
	  stop_fighting(ch);
	  hit(ch, vict, TYPE_UNDEFINED);
	  act("&8$n switches opponents!&0", FALSE, ch, 0, vict, TO_ROOM);
	  send_to_char("&8You switch opponents!&0", ch);
	  WAIT_STATE(ch, PULSE_VIOLENCE);
	  return;
	}
      else
	act("&8$n tries to switch opponents, though becomes confused!&0",
	    FALSE, ch, 0, vict, TO_ROOM);
    send_to_char("&8You try to switch opponents and become confused&0",
		 ch);
    stop_fighting(ch);
    WAIT_STATE(ch, PULSE_VIOLENCE + 2);
    return;
  }
}



ACMD(do_kill)
{
  struct char_data *vict;

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    sprintf(buf, "&8It is just to damn dark!&0");
    send_to_char(buf, ch);
    return;
  }

  if ((GET_LEVEL(ch) < LVL_GOD) || IS_NPC(ch)) {
    do_hit(ch, argument, cmd, subcmd);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Kill who?\r\n", ch);
  } else {
    if (!(vict = get_char_room_vis(ch, arg)))
      send_to_char("They aren't here.\r\n", ch);
    else if (ch == vict)
      send_to_char("Your mother would be so sad.. :(\r\n", ch);
    else if (GET_LEVEL(vict) == LVL_IMPL)
      send_to_char("&1You dare NOT do that!&0", ch);
    else{
      act("You chop $M to pieces!  Ah!  The blood!", FALSE, ch, 0, vict, TO_CHAR);
      act("$N chops you to pieces!", FALSE, vict, 0, ch, TO_CHAR);
      act("$n brutally slays $N!", FALSE, ch, 0, vict, TO_NOTVICT);
      raw_kill(vict, ch);
    }
  }
}

/* Instant kill is a automated skill.. its a chance in backstab to do em
   inhard ie instant kill Banyal */
bool instantkill(struct char_data *ch, struct char_data *victim)
{
  int chance = 0;

if(!victim || !ch || ch == victim || ch == NULL || victim == NULL)
  return FALSE;

  if (IS_NPC(ch) ||
      !GET_SKILL(ch, SKILL_INSTANT_KILL) ||
      (GET_POS(victim) == POS_DEAD) || (ch->in_room != victim->in_room)
      || (GET_LEVEL(victim) > LVL_IMMORT))
    return FALSE;

  if (number(1, 101) > GET_SKILL(ch, SKILL_INSTANT_KILL))
    return FALSE;

  chance = MAX(10, (430 - (GET_LEVEL(ch) * 7) + GET_LEVEL(victim) - (!AWAKE(victim) ? 50 : 0)));


  if (number(1, chance) == 13) {
    improve_skill(ch, SKILL_INSTANT_KILL);
    quickdeath(victim, ch);
    ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL] = 1000;
    return TRUE;
  }
  return FALSE;
}
				/* instant_kill */
/*NEW SLOW PAINFULL DEATH Banyal */
/*Stock code did no allow for a pc/npc to die w/o a killer
  this clased with toggle vicous poisened etc so here is a
  slow painfull death*/

void slow_death(struct char_data *victim)
{
  struct char_data *real_char;
  struct mem_list *cur;
  //  register struct char_data *k;
  //  extern struct char_data *character_list;
  int i;

  if (GET_LEVEL(victim) >= LVL_IMMORT) {
    GET_POS(victim) = POS_STANDING;
    alter_hit(victim, -20, 1);
    return;}

  act("&8With a soft groan, $n slips off into the cold sleep of death&0",
      TRUE, victim, 0, 0, TO_ROOM);
  act("&8$n is dead! R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
  if (AWAKE(victim)) {
    act("&8You feel yourself slipping away and falling into the abyss.&0",
	FALSE, victim, 0, 0,TO_CHAR);
    send_to_char("&0&8Your life fades away ....\r\n", victim);
  }

  /*check for switch. Original char loses exp*/
  if (victim->desc && victim->desc->original)
    gain_exp(victim->desc->original, -(GET_EXP(victim->desc->original) >> 1));
  else
    gain_exp(victim, -(GET_EXP(victim) >> 1));

  if (IS_AFFECTED2(victim, AFF2_ON_FIRE))
    REMOVE_BIT(AFF2_FLAGS(victim), AFF2_ON_FIRE);
  if (!IS_NPC(victim)) {
    REMOVE_BIT(PLR_FLAGS(victim), PLR_KILLER | PLR_THIEF);
    GET_COND(victim, THIRST) = 24;
    GET_COND(victim, FULL) = 24;
    GET_COND(victim, DRUNK) = 0;}



  /*check for switched victim*/
  if (victim->desc && victim->desc->original) {
    real_char = victim->desc->original;
    char_from_room(real_char);
    char_to_room(real_char, victim->in_room);
  }
  else
    real_char = victim;

  if (FIGHTING(victim))
    stop_fighting(victim);

  while (victim->affected)
    affect_remove(victim, victim->affected);
  while (real_char->affected)
    affect_remove(real_char, real_char->affected);

  /* this guy died ..zero the mem_list */
  if(victim->spell_list)
    {
      cur = victim->spell_list;

      for(i = 0; i < victim->num_spells; i++)
	{
	  cur->can_cast = 0;
	  cur = cur->next;
	}
      victim->num_memmed = 0;
      victim->mem_status = FALSE;
    }

  Forgive_The_Basterd(victim);

  if(PLR_FLAGGED(victim, PLR_CASTING)){
    if (IS_NPC(victim))
      REMOVE_BIT(MOB_FLAGS(victim), MOB_CASTING);
    REMOVE_BIT(PLR_FLAGS(victim),
	       PLR_CASTING);
    act("You stop chanting abruptly!", FALSE, victim, 0, 0, TO_CHAR);
    act("$n stops chanting abruptly!",FALSE, victim, 0, 0,
	TO_ROOM);
  }

  if(GET_LEVEL(real_char) < LVL_IMMORT) {
    make_corpse(real_char);
    extract_char(victim);
    if (victim != real_char)
      extract_char(real_char);
    if (!IS_NPC(real_char))         /* If killed dont save in room he died
				       in */
      GET_LOADROOM(real_char) = GET_HOME(real_char);
  }else if(victim != real_char) {
    do_return(real_char, "", 0, 0);
    extract_char(victim);
  }
}

/* NEW fucntion!! this allows for a quick death in mid stride that looks
   right to onlookers Banyal */
void quickdeath(struct char_data *victim, struct char_data *ch)
{

  if (GET_LEVEL(victim) >= LVL_IMMORT)
    return;

  die(victim, ch);

  act("&8$n is dead! R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
  if (AWAKE(victim))
    act("&8You feel yourself falling to the ground.&0", FALSE, victim, 0, 0,
	TO_CHAR);
  act("&8Your soul leaves your body in the cold sleep of death...&0",  FALSE,
      victim, 0, 0, TO_CHAR);

}

/*New backstab now sets victim with skill aware for a short period of time
  to help stop spamming this command to kill high mobs Banyal*/
ACMD(do_backstab)
{
  struct char_data *vict;
  struct affected_type af;
  int percent, prob, percent2, prob2;

  if (GET_SKILL(ch, SKILL_BACKSTAB) < 1) {
    send_to_char("You dont know how.\r\n", ch);
    return;
  }
  one_argument(argument, buf);

  if (!(vict = get_char_room_vis(ch, buf))) {
    send_to_char("Backstab who?\r\n", ch);
    return;
  }
  if (vict == ch) {
    send_to_char("How can you sneak up on yourself?\r\n", ch);
    return;
  }
  if (FIGHTING(ch)) {
    send_to_char("You can not seem to sneak up behind the person you fighting!\r\n",
		 ch);
    return;
  }
if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing!\r\n", ch);
return;
}

  /*
    if (GET_RACE(ch) == RACE_TROLL || GET_RACE(ch) == RACE_OGRE) {
    send_to_char("Smirk. I don't believe you could sneak behind anything to stab it.\r\n", ch);
    return;
    }
    * removed by Nechtrous */

  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
    return;
  }
  if (FIGHTING(vict) && (GET_SKILL(ch, SKILL_BACKSTAB) < 50)) {
    send_to_char("Your skill isn't high enough to backstab a fighting person..\r\n", ch);
    return;
  }

  if (MOB_FLAGGED(vict, MOB_AWARE) && (GET_SKILL(ch, SKILL_BACKSTAB) < 90) &&
      CAN_SEE(ch, vict)) {
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    return;
  }

  percent = number(1, 101);	/* 101% is a complete failure */
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
    percent = 150;  /*silent failure*/

  prob = GET_SKILL(ch, SKILL_BACKSTAB);
  if (!CAN_SEE(vict, ch))
    prob += GET_SKILL(ch, SKILL_BACKSTAB) / 2;

  if (!instantkill(ch, vict)) {
    if (AWAKE(vict) && (percent > prob)){
      hit(ch, vict, TYPE_UNDEFINED);
      improve_skill(ch, SKILL_BACKSTAB);
    }else{
      hit(ch, vict, SKILL_BACKSTAB);
      improve_skill(ch, SKILL_BACKSTAB);
    }
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);

    if (GET_CLASS(ch) == CLASS_ASSASSIN) {
      if (!GET_EQ(ch, WEAR_WIELD2))
	return;
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT)
	return;

      percent2 = number(1, 101);	 /* 101% is a complete failure */
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
	percent2 = 150;  /*silent failure*/

      prob2 = GET_SKILL(ch, SKILL_BACKSTAB);
      if (!CAN_SEE(vict, ch))
	prob2 += GET_SKILL(ch, SKILL_BACKSTAB) / 2;

      if (AWAKE(vict) && (percent2 > prob2)){
	hit(ch, vict, TYPE_UNDEFINED);
	improve_skill(ch, SKILL_BACKSTAB);
      }else{
	hit2(ch, vict, SKILL_2BACK);
	improve_skill(ch, SKILL_BACKSTAB);
      }
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    }
  }
  if(!IS_AFFECTED3(vict, AFF3_AWARE)) {
    af.type = SKILL_AWARE;
    af.duration = 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_AWARE;
    affect_to_char(vict, &af);
  }
}

ACMD(do_circle)
{
  struct char_data *vict;
  int percent, prob;

  if (GET_SKILL(ch, SKILL_CIRCLE) < 1) {
    send_to_char("You dont know how.\r\n", ch);
    return;
  }

  /* removed by nechtrous - circle should only be while fighting. No targeting.
     one_argument(argument, buf);

     if (!(vict = get_char_room_vis(ch, buf))) {
     send_to_char("Circle who?\r\n", ch);
     return;
     }
     if (vict == ch) {
     send_to_char("How can you sneak up on yourself?\r\n", ch);
     return;
     }
  */
  if (!(vict=FIGHTING(ch))) {
    send_to_char("You have to be engaged to pull that off!", ch);
    return;
  }
  if (FIGHTING(FIGHTING(ch)) == ch) {
    send_to_char("You cannot seem to get behind your foe.", ch);
    return;
  }

  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
    return;
  }

  if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict)) {
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(ch, vict, TYPE_UNDEFINED);
    return;
  }

  percent = number(1, 500);	/* Prob for circle should never be near 100% */
  prob = GET_SKILL(ch, SKILL_CIRCLE);
  if (!CAN_SEE(vict, ch))
    prob += GET_SKILL(ch, SKILL_CIRCLE) / 2;

  if (AWAKE(vict) && (percent > prob)){
    hit(ch, vict, TYPE_UNDEFINED);
    improve_skill(ch, SKILL_CIRCLE);
  }else{
    hit(ch, vict, SKILL_BACKSTAB);
    improve_skill(ch, SKILL_CIRCLE);
  }
  /* Circle should only yeild 1 attack - nechtrous
     if (GET_CLASS(ch) == CLASS_ASSASSIN) {
     if (!GET_EQ(ch, WEAR_WIELD2))
     return;
     if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT)
     return;

     percent2 = number(1, 200);
     prob2 = GET_SKILL(ch, SKILL_CIRCLE);
     if (!CAN_SEE(vict, ch))
     prob2 += GET_SKILL(ch, SKILL_CIRCLE) / 2;

     if (AWAKE(vict) && (percent2 > prob2)){
     hit2(ch, vict, TYPE_UNDEFINED);
     improve_skill(ch, SKILL_CIRCLE);
     }else{
     hit2(ch, vict, SKILL_BACKSTAB);
     improve_skill(ch, SKILL_CIRCLE);}}
  */
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);

}


ACMD(do_order)
{
  char name[100], message[256];
  char buf[256];
  bool found = FALSE;
  int org_room;
  struct char_data *vict;
  struct follow_type *k;

  half_chop(argument, name, message);

  if (!*name || !*message)
    send_to_char("Order who to do what?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, name)) && !is_abbrev(name, "followers"))
    send_to_char("That person isn't here.\r\n", ch);
  else if (ch == vict)
    send_to_char("You obviously suffer from skitzofrenia.\r\n", ch);

  else {
    if (IS_AFFECTED(ch, AFF_CHARM)) {
      send_to_char("Your superior would not aprove of you giving orders.\r\n", ch);
      return;
    }
    if (vict) {
      sprintf(buf, "$N orders you to '%s'", message);
      act(buf, FALSE, vict, 0, ch, TO_CHAR);
      act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);

      if ((vict->master != ch) || !IS_AFFECTED(vict, AFF_CHARM))
	act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
      else {
	send_to_char(OK, ch);
	command_interpreter(vict, message);
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      }
    } else {			/* This is order "followers" */
      sprintf(buf, "$n issues the order '%s'.", message);
      act(buf, FALSE, ch, 0, vict, TO_ROOM);

      org_room = ch->in_room;

      for (k = ch->followers; k; k = k->next) {
	if (org_room == k->follower->in_room)
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) {
	    found = TRUE;
	    command_interpreter(k->follower, message);
	  }
      }
      if (found){
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	send_to_char(OK, ch);
      }else
	send_to_char("Nobody here is a loyal subject of yours!\r\n", ch);
    }
  }
}

ACMD(do_flee)
{
  int i, attempt;
  extern char *dirs[];

  if (!SanityCheck(ch, "do_flee - 1"))
    return;
  if (IS_NPC(ch))
    if (GET_MOB_WAIT(ch) > 0)
      return;
  if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
    return;

  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
    send_to_char("Its a bit to late for that.\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of fleeing!\r\n", ch);
    return;
    break;
  case POS_SITTING:
  case POS_RESTING:
    act("Looking paniced, $n scrambles madly to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You scramble madly to your feet!\r\n", ch);
    act("&8$n scrambles madly to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    return;
    break;
  case POS_STANDING:
  case POS_FIGHTING:

    if ((IS_NPC(ch) && GET_MOB_WAIT(ch)) || (!IS_NPC(ch) && CHECK_WAIT(ch))) {
      send_to_char("You cannot flee yet!\r\n", ch);
      return;
    }


    for (i = 0; i < 6; i++) {
      attempt = number(0, NUM_OF_DIRS - 1);	/* Select a random
						   direction */

      if (CAN_GO(ch, attempt) &&
	  !IS_SET(ROOM_FLAGS(EXIT(ch, attempt)->to_room), ROOM_DEATH)) {
	act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
	if (do_simple_move(ch, attempt, TRUE)) {
	  sprintf(buf, "&0You panic and flee %s!&0", dirs[attempt]);
	  send_to_char(buf, ch);
	  if (FIGHTING(ch)) {
	    if (FIGHTING(FIGHTING(ch)) == ch){
	      stop_fighting(FIGHTING(ch));
	      stop_fighting(ch);
	    }

	  }
	} else {
	  act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
	}
	return;
      }
    }
    send_to_char("PANIC!  You couldn't escape!\r\n", ch);
    break;
  }
}


ACMD(do_bash)
{
  struct char_data *vict;
  int percent, prob;

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    sprintf(buf, "&8It is just to damn dark!&0");
    send_to_char(buf, ch);
    return;
  }

  if (ch->char_specials.action_delays[ACT_DELAY_BASH] > 0) {
    send_to_char("&8You haven't reoriented yourself yet enough for another bash!\r\n", ch);
    return;
  }

if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
}

  one_argument(argument, arg);

  if (GET_SKILL(ch, SKILL_BASH) == 0 ) {
    send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
    return;
  }
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Bash who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  if(!CAN_SEE(ch, vict)) {
    send_to_char("Bash who?!?\r\n", ch);
    return;
  }
  if (vict == ch->guarding) {
    send_to_char("You cannot do that while you are guarding them.\r\n",ch);
    return;
  }
  if (!(IS_NPC(ch))) {
    if (!GET_EQ(ch, WEAR_SHIELD) && !GET_EQ(ch, WEAR_2HWIELD)) {
      send_to_char("You need to wear a shield to make it a success, but go on try then!\r\n", ch);
      prob = (int)(GET_SKILL(ch, SKILL_BASH) / 4);
    }
    else if (GET_EQ(ch, WEAR_2HWIELD)){
      prob = GET_SKILL(ch, SKILL_BASH)/ 2;
    }
    else
      prob = GET_SKILL(ch, SKILL_BASH);
  }
  else
    prob = GET_SKILL(ch, SKILL_BASH);
  percent = number(1, 101);	/* 101% is a complete failure */

  if((GET_CLASS(ch) == CLASS_PALADIN || CLASS_ANTI_PALADIN) &&
     (GET_EQ(ch, WEAR_2HWIELD)))
    prob += 20;

  vict = check_guard(ch, vict, FALSE);
  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101;
  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
    percent = 101;

  if (GET_SIZE(ch) < GET_SIZE(vict)) {
    if ((GET_SIZE(vict) - GET_SIZE(ch)) > 1) {
      send_to_char("&7&bYou fall over as you try to bash someone so large&0", ch);
      act("&7&b$n BOUNCES off $N, as $e tries to bash $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n BOUNCES off you as $e tries to bash your much larger size&0", FALSE, ch, 0, vict, TO_VICT);
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
      return;
    }
  } else { /* I changes this to 2 down 1  up Banyal*/
    if ((GET_SIZE(ch) - GET_SIZE(vict)) > 2) {
      send_to_char("&7&bYou fall over as you try to bash someone with such small size&0", ch);
      act("&7&b$n trips over $N, as $e tries to bash $N's much smaller size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n trips over you as $e tries to bash your much smaller size&0", FALSE, ch, 0, vict, TO_VICT);
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
      return;
    }
  }



  if (percent > prob) {
    damage(ch, vict, 0, SKILL_BASH);
    GET_POS(ch) = POS_SITTING;
    if (!(IS_NPC(ch)))
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
  } else {
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BASH);
    if (IS_NPC(vict) || GET_LEVEL(vict) < LVL_IMMORT){
      GET_POS(vict) = POS_SITTING;
      WAIT_STATE(vict, PULSE_VIOLENCE * 3);
      if (!(IS_NPC(ch)))
	ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
      if(PLR_FLAGGED(vict, PLR_CASTING) || MOB_FLAGGED(vict,
						       MOB_CASTING)){
	if (IS_NPC(vict))
	  REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
      }
    }
  }

  WAIT_STATE(ch, PULSE_VIOLENCE * 4);
  improve_skill(ch, SKILL_BASH);
  update_pos(ch);
}/*hurm*/

ACMD(do_bodyslam)
{
  struct char_data *vict;
  int percent, prob;

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    sprintf(buf, "&8It is just to damn dark!&0");
    send_to_char(buf, ch);
    return;
  }
  if (!IS_NPC(ch)) {
    if(GET_RACE(ch) == RACE_GNOME || GET_RACE(ch) == RACE_HUMAN ||
       GET_RACE(ch) == RACE_ORC || GET_RACE(ch) == RACE_DWARF ||
       GET_RACE(ch) == RACE_HALF_ELF || GET_RACE(ch) == RACE_ELF ||
       GET_RACE(ch) == RACE_DROW_ELF|| GET_RACE(ch) == RACE_HALFLING ||
       GET_RACE(ch) == RACE_DUERGAR){
      send_to_char("You have no idea how....", ch);
      return;
    }
  }

  one_argument(argument, arg);

  if (FIGHTING(ch)) {
    send_to_char("You cant bodyslam in combat....", ch);
    return;
  }  if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("Bodyslam who?\r\n", ch);
    return;    }

  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  if (vict == ch->guarding) {
    send_to_char("You cannot do that while you are guarding them.\r\n",ch);
    return;
  }

  vict = check_guard(ch, vict, FALSE);
  prob = number(1, 100);
  prob += GET_LEVEL(ch);
  prob += GET_HITROLL(ch);
  percent = number(1, 101);
  percent += GET_SKILL(vict, SKILL_DODGE);
  percent += GET_LEVEL(vict);


  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = prob + 1;
  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
    percent = prob + 1;

  if (GET_SIZE(ch) < GET_SIZE(vict)) {
    if ((GET_SIZE(vict) - GET_SIZE(ch)) > 3) {
      send_to_char("&7&bYou fall over as you try to bodyslam someone so large&0", ch);
      act("&7&b$n BOUNCES off $N, as $e tries to bodyslam $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n BOUNCES off you as $e tries to bodyslam your much larger size&0", FALSE, ch, 0, vict, TO_VICT);
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      return;
    }
  } else {
    if ((GET_SIZE(ch) - GET_SIZE(vict)) > 3) {
      send_to_char("&7&bYou fall over as you try to bash someone with such small size&0", ch);
      act("&7&b$n trips over $N, as $e tries to bodyslam $N's much smaller size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n trips over you as $e tries to bodyslam your much smaller size&0", FALSE, ch, 0, vict, TO_VICT);
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      return;
    }
  }



  if (percent > prob) {
    damage(ch, vict, 0, SKILL_BODYSLAM);
    GET_POS(ch) = POS_SITTING;
  } else {
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BODYSLAM);
    if (IS_NPC(vict) || GET_LEVEL(vict) < LVL_IMMORT){
      GET_POS(vict) = POS_SITTING;
      WAIT_STATE(vict, PULSE_VIOLENCE * 4);
      if(PLR_FLAGGED(vict, PLR_CASTING)){
	if (IS_NPC(vict))
	  REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
      }
    }
  }

  WAIT_STATE(ch, PULSE_VIOLENCE * 4);
  /*  improve_skill(ch, SKILL_BASH);*/

}



ACMD(do_rescue)
{
  struct char_data *vict, *tmp_ch;
  int percent, prob;

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("Whom do you want to rescue?\r\n", ch);
    return;
  }
  if (vict == ch) {
    send_to_char("What about fleeing instead?\r\n", ch);
    return;
  }
  if (FIGHTING(ch) == vict) {
    send_to_char("How can you rescue someone you are trying to kill?\r\n", ch);
    return;
  }
  for (tmp_ch = world[ch->in_room].people; tmp_ch &&
	 (FIGHTING(tmp_ch) != vict); tmp_ch = tmp_ch->next_in_room);

  if (!tmp_ch) {
    act("But nobody is fighting $M!", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (GET_SKILL(ch, SKILL_RESCUE) == 0)
    send_to_char("But only true warriors can do this!", ch);
  else {
    percent = number(1, 101);	/* 101% is a complete failure */
    prob = GET_SKILL(ch, SKILL_RESCUE);

    if (percent > prob) {
      send_to_char("You fail the rescue!\r\n", ch);
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      return;
    }
    send_to_char("Banzai!  To the rescue...\r\n", ch);
    act("You are rescued by $N, you are confused!", FALSE, vict, 0, ch, TO_CHAR);
    act("$n heroically rescues $N!", FALSE, ch, 0, vict, TO_NOTVICT);

    if (FIGHTING(vict) == tmp_ch)
      stop_fighting(vict);
    if (FIGHTING(tmp_ch))
      stop_fighting(tmp_ch);
    if (FIGHTING(ch))
      stop_fighting(ch);

    set_fighting(ch, tmp_ch);
    set_fighting(tmp_ch, ch);

    WAIT_STATE(vict, 2 * PULSE_VIOLENCE);
  }

  improve_skill(ch, SKILL_RESCUE);

}


ACMD(do_kick)
{
  struct char_data *vict;
  int percent, prob;

  if (GET_SKILL(ch, SKILL_KICK) == 0) {
    send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Kick who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  /* Kicking re orients you for bash Banyal */
  ch->char_specials.action_delays[ACT_DELAY_BASH] = 0;

  percent = ((10 - (GET_AC(vict) / 10)) << 1) + number(1, 101);
  prob = GET_SKILL(ch, SKILL_KICK);
  if (percent > prob) {
    damage(ch, vict, 0, SKILL_KICK);
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  } else
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_KICK);
  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  if (IS_NPC(ch))	{

    WAIT_STATE(ch, PULSE_VIOLENCE * 2);}
  improve_skill(ch, SKILL_KICK);

}

ACMD(do_springleap)
{
  struct char_data *vict;
  int percent, prob;

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
    {
      sprintf(buf, "&8It is too dark!&0");
      send_to_char(buf, ch);
      return;
    }

  if (GET_CLASS(ch) != CLASS_RANGER)
    {
      send_to_char("&0You'd better leave all the martial arts to fighters.&0\r\n", ch);
      return;
    }

  if (GET_POS(ch) > POS_SITTING)
    {
      send_to_char("&0You must sit down first!&0\r\n", ch);
      return;
    }
  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg)))
    {
      if (FIGHTING(ch))
	{
	  vict = FIGHTING(ch);
	}
      else
	{
	  send_to_char("&0Springleap who?&0\r\n", ch);
	  return;
	}
    }
  if (vict == ch)
    {
      send_to_char("&0Aren't we funny today...&0\r\n", ch);
      return;
    }

  percent = ((10 - (GET_AC(vict) / 10)) << 1) + number(1, 72);

  prob = GET_SKILL(ch, SKILL_SPRINGLEAP);

  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
    percent = 101;
  if (GET_POS(ch) > POS_SLEEPING)
    {
      if ((GET_POS(vict) < POS_FIGHTING) && (prob < 80))
	percent = 101;
      if (percent > prob)
	{
	  GET_POS(ch) = POS_SITTING;
	  act("&0&6You try to take $N down but you spring over his head!&0", FALSE, ch, 0, vict, TO_CHAR);
	  act("&0&6$N springs from the ground at you but soars over your head!&0", FALSE, vict, 0, ch, TO_CHAR);
	  act("&0&6$N springs from the ground at $n but misses by a mile!&0", FALSE, vict, 0, ch, TO_NOTVICT);
	  damage(ch, vict, 0, SKILL_SPRINGLEAP);
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	  improve_skill(ch, SKILL_SPRINGLEAP);

	  return;
	}
      if (percent > (prob - (prob * 0.2)))
	{
	  GET_POS(vict) = POS_SITTING;
	  GET_POS(ch) = POS_SITTING;
	  act("&0&6You manage to take $N down but also &bfall down yourself!&0", FALSE, ch, 0, vict, TO_CHAR);
	  act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0", FALSE, vict, 0, ch, TO_CHAR);
	  act("&0&6$N springs from the ground knocking $n down and &bfalls in the process!&0", FALSE, vict, 0, ch, TO_NOTVICT);
	  damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	  WAIT_STATE(vict, PULSE_VIOLENCE * 3);
	  improve_skill(ch, SKILL_SPRINGLEAP);
	  if(PLR_FLAGGED(vict, PLR_CASTING))
	    {
	      if (IS_NPC(vict))
		REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	      REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	      act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	      act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	    }

	  return;
	}
      else
	GET_POS(vict) = POS_SITTING;

      GET_POS(ch) = POS_STANDING;
      act("&0&b&8You spring from the ground knocking $N off balance.&0", FALSE, ch, 0, vict, TO_CHAR);
      act("&0&b&8$N springs from the ground and knocks you down!&0", FALSE, vict, 0, ch, TO_CHAR);
      act("&0&b&8$N springs from the ground knocking $n down!&0", FALSE, vict, 0, ch, TO_NOTVICT);
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      WAIT_STATE(vict, PULSE_VIOLENCE * 3);
      improve_skill(ch, SKILL_SPRINGLEAP);
      if(PLR_FLAGGED(vict, PLR_CASTING))
	{
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
      return;
    }
} /* end springleap */


ACMD(do_throatcut)
     /* Buru 4/12/97 */
{
  struct char_data *vict;
  struct affected_type af;
  int percent, prob;
  if (!(GET_LEVEL(ch) >= LVL_IMMORT)) {
    if (GET_SKILL(ch, SKILL_THROATCUT) == 0) {
      send_to_char("I don't think so!!\r\n", ch);
      return;
    }}
  one_argument(argument, buf);
  percent = number(0,101);
  prob = percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));

  if (GET_LEVEL(ch) >= LVL_IMMORT)
    prob = 100;

  if (prob > 100){
    prob = 100;}

  if ((!(vict = get_char_room_vis(ch, buf)))&& (!(vict == ch))) {
    send_to_char("Cut whos throat?\r\n", ch);
    return;
  }
  if (vict == ch) {
    send_to_char("Hey, life's not that bad!\r\n", ch);
    return;
  }
  if (GET_POS(vict)<=POS_SLEEPING){
    prob = 10 + percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));}
  if (GET_SKILL(ch, SKILL_THROATCUT) == 0) {
    send_to_char("You aren't skilled enough!\r\n", ch);
    return;
  }

  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("&0You need to wield a weapon to make it a success.&0\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("&0Only piercing weapons can be used for throat cutting.&0\r\n", ch);
    return;
  }
  if (ch != vict && ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("&0You feel ashamed trying to disturb the peace of this room.&0\r\n", ch);
    return;
  }
  if (FIGHTING(vict)) {
    send_to_char("&0You can't cut the throat of a fighting person -- they're too alert!&0\r\n", ch);
    return;
  }
  if ((!IS_NPC(vict))&&(GET_LEVEL(vict) == LVL_GOD)){
    {sprintf(buf, "&0$N laughs out loud at your miserable attempt!&0");
    act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    {sprintf(buf, "&0$N just tried to cut your throat. &0&6How cute!&0");
    act(buf, FALSE, vict, 0, ch, TO_CHAR);}
    return;}
  if((GET_SPECIES(vict) == 4)||(GET_SPECIES(vict) == 5)){
    send_to_char("It is far too difficult to cut their throat!\r\n", ch);
    return;}
  if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict)) {
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    return;
  }
  /*sucks you get tense when some tries to cut your throat! Banyal */
  af.type = SKILL_AWARE;
  af.duration = 1;
  af.modifier = 0;
  af.bitvector = 0;
  af.bitvector2 = 0;
  af.bitvector3 = AFF3_AWARE;
  affect_to_char(vict, &af);

  /* PC -> PC ATTACKS */
  if (!IS_NPC(vict)){
    if (GET_LEVEL(ch) < 50){
      if ((prob > 60) && (prob < 92)){
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	return;}
      if ((prob > 91) && (prob < 97)){

	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}
      if ((prob > 96) && (prob < 101)){
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;}
      if (prob < 61){
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	{GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));}
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	return;}
    }

    if (GET_LEVEL(ch) > 49){
      if ((prob > 30) && (prob < 70)){
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}

	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}
      if ((prob > 69) && (prob < 91)){
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
	return;}
      if ((prob > 90) && (prob <= 101)){
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;	}
      if (prob < 31){
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  {GET_HIT(ch) = (GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3)));}}

	WAIT_STATE(ch, PULSE_VIOLENCE * 2);	return;}}}
  /* PC -> MOB ATTACKS */
  if (IS_NPC(vict)){
    if (GET_LEVEL(ch) < 50){
      if ((prob > 80) && (prob < 95)){
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}

	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}
      if ((prob > 94) && (prob < 99)){

	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}
      if ((prob > 98) && (prob < 101)){
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;}
      if (prob < 81){
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	{GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));}
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	return;}
    }

    if (GET_LEVEL(ch) > 49){
      if ((prob > 50) && (prob < 85)){
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}

	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
	return;}
      if ((prob > 84) && (prob < 95)){
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
	return;}
      if ((prob > 94) && (prob <= 101)){
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM);
	}
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;	}
      if (prob < 51){
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  {GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3));}}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}}}


}



void do_disarm(struct char_data *ch, char *arg, int cmd)
{
  /* Local Macros */

#define DISARM_MOVEMENT         10

  int pos, percent, rnd_num, skl_bonus;
  char Gbuf2[MAX_STRING_LENGTH];
  char ply_name[MAX_INPUT_LENGTH];
  char obj_name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *ch_obj;		/* Object to disarm */
  struct char_data *tar, *aff_who = NULL;	/* Target */
  struct affected_type af, *af_ptr;
  float disarm_difficulty[NUM_WEARS] =
  {0, 0, 0, 0, 0,
   0, 0, 0, 0, 0,
   0, 0, 0, 0, 0,
   1, 1, 0, 0, 0,		/* PRIMARY/SECONDARY */
   0, 0, 0, 0, 0,
   0, 0};
  bool disarm_prim = TRUE, done;
  /* extern struct dex_app_type dex_app[];*/

  /* Executable Section */

  if (IS_NPC(ch) || GET_SKILL(ch, SKILL_DISARM) == 0) {
    send_to_char("You don't know how to disarm.\r\n", ch);
    return;
  }
  /* Get NAME and OBJ */

  arg = one_argument(arg, ply_name);
  if (*ply_name == '\0') {
    send_to_char("Disarm who?\r\n", ch);
    return;
  }
  one_argument(arg, obj_name);
  if (*obj_name == '\0') {
    send_to_char("Disarm what?\r\n", ch);
    return;
  }
  /* Check the basic requirements, such as that can see victim  */
  /* and can see victim's weapon.                               */

  /* disarmer must be wielding a weapon. */
  if (!(ch_obj = GET_EQ(ch, WEAR_WIELD))) {
    if (!(ch_obj = GET_EQ(ch, WEAR_WIELD2))) {
      send_to_char("You must be wielding some kind of weapon.\n\r", ch);
      return;
    } else {
      disarm_prim = FALSE;
    }
  }
  if (!(tar = get_char_room_vis(ch, ply_name))) {
    send_to_char("That creature isn't present.\n\r", ch);
    return;
  }
  if (tar == ch) {
    send_to_char("Be serious... use remove to disarm yourself.\r\n", ch);
    return;
  }
  if (GET_MOVE(ch) < DISARM_MOVEMENT) {
    act("You don't have the energy to do that.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (!IS_FIGHTING(ch) || ch->char_specials.fighting != tar) {
    act("You must in engage combat with $N before $e can be disarmed.", FALSE, ch, 0, tar, TO_CHAR);
    return;
  }
  for (obj = NULL, pos = 0; pos < NUM_WEARS; pos++) {
    if ((obj = tar->equipment[pos]) &&	/* Using something there */
	isname(obj_name, obj->name) &&	/* Same name */
	CAN_SEE_OBJ(ch, obj))	/* Can see it */
      break;
  }

  if (obj == NULL) {
    act("You can't seem to find it on $N.", FALSE, ch, 0, tar, TO_CHAR);
    return;
  }
  if (IS_AFFECTED(ch, AFF_FUMBLING_PRIM) ||
      IS_AFFECTED(ch, AFF_FUMBLING_SECOND)) {
    act("Impossible!  You're already fumbling for your own weapon.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (GET_OBJ_TYPE(obj) != ITEM_WEAPON /*&&
					 obj->type != ITEM_FIREWEAPON*/) {
    act("You can only disarm weapons.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  /* OK, now that we have found the victim and the object to disarm     */
  /* Determine whether a successful attempt or not by using player's    */
  /* dexterity, his learnability at this skill, and level difference    */

  percent = GET_SKILL(ch, SKILL_DISARM) +	/* max of 90 */
    dex_app_skill[GET_DEX(ch)].p_pocket +	/* max of 30 (avg of 15) */
    (GET_LEVEL(ch) - GET_LEVEL(tar));	/* max of 49 (avg of 10?) */
  /* total= 169 */

  /* thus far, only weapons can be disarmed, and so no penalty is incurred */
  /* later, if held items or helmets, etc can be disarmed since they're somewhat */
  /* more difficult (ie. helmet is secured on head), a fraction of percent is taken */
  /* to reflect this. */
  percent = (int) (percent * disarm_difficulty[pos]);

  /* 1 - 35 extra %-age pts to account for superlative dex or xp diff */
  skl_bonus = (int) ((percent - 69) / 2);

  if (skl_bonus > 0)
    percent += skl_bonus;

  percent = MAX(1, percent);

  /* has char tried to disarm within delay period?  if so, penalize them */
  if (ch->char_specials.action_delays[ACT_DELAY_DISARM])
    rnd_num -= 30;		/* 30% pts */

  rnd_num = number(1, percent);

  /* A is person disarming.  B is being disarmed

     Percent chance of following to happen:

     5% (1 -> 5)    -- A drops weapon in miserably failed disarm attempt.
     20% (6 -> 25)   -- A fumbles his primary (secondary) weapon in failed disarm attempt.
     50% (26 -> 75)  -- Nothing happens.
     20% (76 -> 95)  -- A forces B to fumble weapon.
     5% (96 -> 100) -- A forces weapon from B's grips.

  */

  /* if char tries to disarm again within 1->3 rds of violence, chance of success cut by a ~1/5 */
  ch->char_specials.action_delays[ACT_DELAY_DISARM] = number(1, 3);

  if (rnd_num <= 5) {
    act("$n fails $s disarming manuveur so badly, $e drops $s own weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("In a vain attempt, $n tries to disarm you, but instead, drops $s weapon.", FALSE, ch, 0, tar, TO_VICT);
    act("You fail miserably in your attempt to disarm $N.", FALSE, ch, 0, tar, TO_CHAR);

    obj = ch_obj;
    aff_who = ch;
  } else if (rnd_num <= 25) {
    act("$n failingly attempts a complex disarming technique on $N.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$e begins to fumble $s own weapon, loosing complete control over it.", FALSE, ch, 0, 0, TO_NOTVICT);
    act("$n starts to fumble $s weapon in a vain attempt to disarm you.", FALSE, ch, 0, tar, TO_VICT);
    act("You make a grave error in judgement, and loose control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);

    aff_who = ch;
  } else if (rnd_num >= 26 && rnd_num <= 75) {
    act("$n tries to disarm $N, but $E neutralizes $s attempt.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("You neutralize $n's attempt to disarm you!", FALSE, ch, 0, tar, TO_VICT);
    act("Your disarming manuveur had no effect on $N.", FALSE, ch, 0, tar, TO_CHAR);
  } else if (rnd_num <= 95) {
    act("$n causes $N to fumble for $S weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$n causes you to fumble for your weapon.", FALSE, ch, 0, tar, TO_VICT);
    act("You cause $N to fumble for $S weapon.", FALSE, ch, 0, tar, TO_CHAR);

    aff_who = tar;
  } else {
    act("$n successfully knocks $N's weapon from his grips!", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$n forces your weapon out of your hands with a fancy disarming manuveur.", FALSE, ch, 0, tar, TO_VICT);
    act("You make a great effort, and send $N's weapon crashing to the floor.", FALSE, ch, 0, tar, TO_CHAR);

    aff_who = tar;
  }

  /* handle cases where either A or B looses hold of weapon */
  if (rnd_num <= 5 || rnd_num >= 96) {
    sprintf(Gbuf2, "%s lands on the floor.", obj->short_description);
    act(Gbuf2, FALSE, aff_who, 0, 0, TO_ROOM);
    act(Gbuf2, FALSE, aff_who, 0, 0, TO_CHAR);

    improve_skill(ch, SKILL_DISARM);

    /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
    /* mutliple times, the delay count must be cumulative.  this count is decremented */
    /* in perform_violence(). */
    if (IS_NPC(aff_who)) {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = MOB_DROPPED_WEAP_DELAY;
      } else {
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = MOB_DROPPED_WEAP_DELAY;
      }
    } else {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = PC_DROPPED_WEAP_DELAY;
      } else {
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = PC_DROPPED_WEAP_DELAY;
      }
    }

    /* pc/mob trying to re-claim their weapon cannot defend themselves very well */
    /* only one skill type needed since whether this afect goes with prim or secondary */
    /* can be determined by examining the bitvectors */
    af.type = SKILL_DISARM_DROPPED_WEAP;
    af.duration = 10;		/* makes no difference.  when action_delay[] == 0, it's erased */
    af.modifier = 40;
    af.location = APPLY_AC;
    if (disarm_prim) {
      af.bitvector = AFF_DROPPED_PRIM;

      if (IS_AFFECTED(aff_who, AFF_FUMBLING_PRIM)) {
	for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	  if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	      af_ptr->bitvector & AFF_FUMBLING_PRIM) {
	    affect_remove(aff_who, af_ptr);
	    done = TRUE;
	  }
	}
      }
    } else {
      af.bitvector = AFF_DROPPED_SECOND;

      if (IS_AFFECTED(aff_who, AFF_FUMBLING_SECOND)) {
	for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	  if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	      af_ptr->bitvector & AFF_FUMBLING_SECOND) {
	    affect_remove(aff_who, af_ptr);
	    done = TRUE;
	  }
	}
      }
    }

    affect_to_char(aff_who, &af);

    /* items ONLY have this set when a MOB is successfuly disarmed */
    /* the item lays on the ground with this bit set, so when someone */
    /* attempts to get it, do_get() can handle it appropriately */
    SET_BIT(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED);

    /* we must remember who last held this item, so the MOB scanning for its */
    /* disarmed item knows THAT is it. */
    obj->last_to_hold = aff_who;

    /* now put item in room's list of objects.  since this is an aggressive */
    /* action, the disarmer will become visisble. */
    if (!ch->equipment[pos]) {
      send_to_char("Bug in disarm.\r\n", ch);
      return;
    }
    obj_to_room(unequip_char(aff_who, pos), aff_who->in_room);
  } else if (rnd_num <= 25 || rnd_num >= 76) {
    /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
    /* mutliple times, the delay count must be cumulative.  this count is decremented */
    /* in perform_violence(). */
    if (IS_NPC(aff_who)) {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = MOB_FUMBLING_DELAY;
      } else {
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = MOB_FUMBLING_DELAY;
      }
    } else {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = PC_FUMBLING_DELAY;
      } else {
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = PC_FUMBLING_DELAY;
      }
    }

    /* pc/mob trying to re-claim their weapon cannot attack themselves very well */
    af.type = SKILL_DISARM_FUMBLING_WEAP;
    af.duration = 10;
    af.modifier = -10;
    af.location = APPLY_HITROLL;
    if (disarm_prim) {
      af.bitvector = AFF_FUMBLING_PRIM;

      for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	    af_ptr->bitvector & AFF_FUMBLING_PRIM) {
	  affect_remove(aff_who, af_ptr);
	  done = TRUE;
	}
      }
    } else {
      af.bitvector = AFF_FUMBLING_SECOND;

      for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	    af_ptr->bitvector & AFF_FUMBLING_SECOND) {
	  affect_remove(aff_who, af_ptr);
	  done = TRUE;
	}
      }
    }

    affect_to_char(aff_who, &af);
  }
  /*DISARM_MOVEMENT = 0 - DISARM_MOVEMENT;*/
  alter_move(ch, -DISARM_MOVEMENT);

  return;

#undef DISARM_MOVEMENT
}

ACMD(do_hitall)
{
  struct char_data  *mob;
  struct char_data  *next_mob;
  byte percent;
  int count, hit_all = 0;

  one_argument(argument, arg);

  if (!SanityCheck(ch, "do_hitall"))
    return;

  if (!GET_SKILL(ch, SKILL_HITALL)) {
    send_to_char("You don't know how to.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("&0You feel ashamed trying to disturb the peace of this room.&0\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE)){
    send_to_char("Sorry, it's too cramped here for nasty maneuvers!\r\n", ch);
    return;
  }
  /* Find out whether to hit "all" or just aggressive monsters */

  if (!str_cmp(arg, "all"))
    hit_all = 1;

  /* Hit all aggressive monsters in room */

  count = 0;
  percent = number(1, 131);

  if (GET_SKILL(ch, SKILL_HITALL) >= percent)
    {
      for (mob = world[ch->in_room].people; mob; mob = next_mob)
	{
	  next_mob = mob->next_in_room;

	  if (ch == mob)
	    continue;

	  if (IS_AFFECTED(mob, AFF_CHARM) && is_grouped(mob, ch))
	    continue;

	  if (!hit_all)
	    {
	      if (!(is_aggr_to(mob, ch) || (IS_FIGHTING(mob) && (FIGHTING(ch) == ch))))
		continue;
	    }

	  hit(ch, mob, TYPE_UNDEFINED);

	  count++;
	} /* end for() */
    } /* end if(get_skill) */
  improve_skill(ch, SKILL_HITALL);
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}
@


1.225
log
@Moving cooldowns to their own file.
@
text
@/***************************************************************************
 * $Id: act.offensive.c,v 1.224 2010/06/05 05:26:58 mud Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: act.offensive.c                               Part of FieryMUD  *
 *  Usage: player-level commands of an offensive nature                    *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on HubisMUD Copyright (C) 1997, 1998.                *
 *  HubisMUD is based on DikuMUD, Copyright (C) 1990, 1991.                *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "casting.h"
#include "screen.h"
#include "races.h"
#include "skills.h"
#include "cooldowns.h"
#include "constants.h"
#include "math.h"
#include "events.h"
#include "chars.h"
#include "magic.h"
#include "regen.h"
#include "fight.h"
#include "movement.h"
#include "damage.h"
#include "directions.h"

/* extern variables */
extern int pk_allowed;
extern int summon_allowed;
extern int charm_allowed;
extern int sleep_allowed;
extern int damage_amounts;

/* extern functions */
ACMD(do_return);
struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output);
bool is_grouped(struct char_data *ch, struct char_data *tch);
void quickdeath(struct char_data *victim, struct char_data *ch);
void abort_casting(struct char_data *ch);
void appear(struct char_data *ch);


void aggro_lose_spells(struct char_data *ch)
{
   if (!EFF_FLAGGED(ch, EFF_REMOTE_AGGR)) {
      if (affected_by_spell(ch, SPELL_INVISIBLE) ||
            affected_by_spell(ch, SPELL_NATURES_EMBRACE))
         appear(ch);
      REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
      REMOVE_FLAG(EFF_FLAGS(ch), EFF_CAMOUFLAGED);
      if (EFF_FLAGGED(ch, EFF_GLORY))
         effect_from_char(ch, SPELL_GLORY);
      GET_HIDDENNESS(ch) = 0;
   }
}

bool switch_ok(struct char_data *ch)
{
   if (GET_SKILL(ch, SKILL_SWITCH) <= 0) {
      act("You are already busy fighting with $N.", FALSE,
            ch, 0, FIGHTING(ch), TO_CHAR);
      return FALSE;
   }

   if (number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
      act("&8$n tries to switch opponents, but becomes confused!&0", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("&8You try to switch opponents and become confused.&0\r\n", ch);
      stop_fighting(ch);
      improve_skill_offensively(ch, FIGHTING(ch), SKILL_SWITCH);
      return FALSE;
   }

   stop_fighting(ch);
   act("&8$n switches opponents!&0", FALSE, ch, 0, 0, TO_ROOM);
   send_to_char("&8You switch opponents!&0\r\n", ch);
   improve_skill_offensively(ch, FIGHTING(ch), SKILL_SWITCH);
   return TRUE;
}

const struct breath_type {
   const char *name;
   const int spell;
   char *to_char;
   char *to_room;
} breath_info[] = {
   { "fire", SPELL_FIRE_BREATH,
      "&1You snort and &bf&3i&7r&1e&0&1 shoots out of your nostrils!&0\r\n",
      "&1$n&1 snorts and a gout of &bf&3i&7r&1e&0&1 shoots out of $s nostrils!&0" },
   { "gas", SPELL_GAS_BREATH,
      "&2You heave and a &bnoxious gas&0&2 rolls rapidly out of your nostrils!&0\r\n",
      "&2$n&2 rumbles and a &bnoxious gas&0&2 rolls out of $s nostrils!&0" },
   { "frost", SPELL_FROST_BREATH,
      "&7&bYou shiver as a shaft of &0&4f&br&7o&4s&0&4t&7&b leaps from your mouth!&0\r\n",
      "&7&b$n&7&b shivers as a shaft of &0&4f&br&7o&4s&0&4t&7&b leaps from $s mouth!&0" },
   { "acid", SPELL_ACID_BREATH,
      "&9&bYou stomach heaves as a wash of &2&ba&0&2ci&bd&9 leaps from your mouth!&0\r\n",
      "&9&b$n&9&b looks pained as a wash of &2&ba&0&2ci&2&bd&9 leaps from $s mouth!&0" },
   { "lightning", SPELL_LIGHTNING_BREATH,
      "&4You open your mouth and bolts of &blightning&0&4 shoot out!&0\r\n",
      "&4$n&4 opens $s mouth and bolts of &blightning&0&4 shoot out!&0" },
   { NULL, 0, NULL, NULL },
};

struct char_data *random_attack_target(struct char_data *ch,
      struct char_data *target, bool verbose)
{
   struct char_data *chosen = NULL;
   struct char_data *i;
   int count = 0;

   for (i = world[ch->in_room].people; i; i = i->next_in_room) {
      if (i != ch && CAN_SEE(ch, i) && attack_ok(ch, i, FALSE)) {
         if (chosen == NULL || number(0, count) == 0)
            chosen = i;
         count++;
      }
   }

   if (!chosen) chosen = target;

   if (verbose && chosen != target) {
      act("&5You got confused and attacked $N&0&5 instead!&0",
            FALSE, ch, 0, chosen, TO_CHAR);
      act("&5$n&0&5 got confused and attacked $N&0&5!&0",
            TRUE, ch, 0, chosen, TO_NOTVICT);
      act("&5$n&0&5 gets confused and attacks YOU!&0",
            TRUE, ch, 0, chosen, TO_VICT);
   }

   return chosen;
}

ACMD(do_breathe)
{
   ACMD(do_action);
   struct char_data *tch, *next_tch;
   int type;
   bool realvictims = FALSE;

   if (!ch || ch->in_room == NOWHERE)
      return;

   /* Don't allow reanimated undead to do this - justification:
    * you need actual life to generate poison gas! */
   if (GET_SKILL(ch, SKILL_BREATHE) < 1 || EFF_FLAGGED(ch, EFF_CHARM)) {
      send_to_char("You huff and puff but to no avail.\r\n", ch);
      act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
      return;
   }

   one_argument(argument, arg);

   for (type = 0; breath_info[type].name; ++type)
      if (is_abbrev(arg, breath_info[type].name))
         break;

   if (!breath_info[type].name) {
      send_to_char("Usage: breathe <fire / gas / frost / acid / lightning>\r\n", ch);
      return;
   }

   send_to_char(breath_info[type].to_char, ch);
   act(breath_info[type].to_room, FALSE, ch, 0, 0, TO_ROOM);

   for (tch = world[ch->in_room].people; tch; tch = next_tch) {
      next_tch = tch->next_in_room;

      if (tch == ch)
         continue;
      if (is_grouped(ch, tch))
         continue;
      if (!mass_attack_ok(ch, tch, FALSE))
         continue;
      if (PRF_FLAGGED(tch, PRF_NOHASSLE))
         continue;
      /* Mobs don't hit other mobs, unless they're pets */
      if (!IS_PC(ch) && !IS_PC(tch) && !PLAYERALLY(ch) && !PLAYERALLY(tch))
         continue;
      call_magic(ch, tch, 0, breath_info[type].spell, GET_LEVEL(ch), CAST_BREATH);
      if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
          realvictims = TRUE;
   }

   if (realvictims)
      improve_skill(ch, SKILL_BREATHE);
   if (GET_LEVEL(ch) < LVL_IMMORT)
      WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_roar)
{
   struct char_data *tch, *next_tch;
   bool realvictims = FALSE;
   ACMD(do_flee);
   ACMD(do_action);

   if (!ch || ch->in_room == NOWHERE)
      return;

   if (subcmd == SCMD_HOWL) {
      if (!GET_SKILL(ch, SKILL_BATTLE_HOWL) ||
            !EFF_FLAGGED(ch, EFF_SPIRIT_WOLF) ||
            !EFF_FLAGGED(ch, EFF_BERSERK)) {
         if (SUN(IN_ROOM(ch)) == SUN_DARK && CH_OUTSIDE(ch)) {
            send_to_char("You form an O with your mouth and howl at the moon.\r\n", ch);
            act("$n starts howling at the moon.   Eerie.", FALSE, ch, 0, 0, TO_ROOM);
         }
         else {
            send_to_char("You howl madly, making a fool of yourself.\r\n", ch);
            act("$n howls madly, looking like a fool.", FALSE, ch, 0, 0, TO_ROOM);
         }
         return;
      }
   }
   else if (!GET_SKILL(ch, SKILL_ROAR) || EFF_FLAGGED(ch, EFF_CHARM)) {
      do_action(ch, argument, cmd, subcmd);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_SILENCE)) {
      act("$n opens $s mouth wide and lets out a little cough.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You take a deep breath and release a vicious cough!\r\n", ch);
      return;
   }

   if (subcmd == SCMD_HOWL) {
      act("$n opens his mouth and a &1&8demonic &0&1howl&0 echoes out!", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You let out a demonic battle howl, striking fear into your enemies!\r\n", ch);
   }
   else {
      act("&9&b$n&9&b makes your soul quake with a vicious &1ROOOOOAAAAAARRRRRR!&0", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("&9&bYou take a deep breath and release a vicious &1ROOOOOAAAAARRRRRR!&0\r\n", ch);
   }

   for (tch = world[ch->in_room].people; tch; tch = next_tch) {
      next_tch = tch->next_in_room;

      if (tch == ch)
         continue;
      if (GET_STANCE(tch) < STANCE_SLEEPING)
         continue;
      /* Mobs don't fear other mobs, unless they're pets. */
      if (!IS_PC(ch) && !IS_PC(tch) && !PLAYERALLY(ch) && !PLAYERALLY(tch))
         continue;
      if (is_grouped(ch, tch))
         continue;
      if (!attack_ok(ch, tch, FALSE))
         continue;
      if (mag_savingthrow(tch, SAVING_PARA))
         continue;
      if (PRF_FLAGGED(tch, PRF_NOHASSLE))
         continue;
      /* Twice as hard to roar at a sentinel mob. */
      if (MOB_FLAGGED(tch, MOB_SENTINEL) && mag_savingthrow(tch, SAVING_PARA))
         continue;
      if (MOB_FLAGGED(tch, MOB_AWARE) || MOB_FLAGGED(tch, MOB_NOSUMMON))
         continue;

      mag_affect(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA, CAST_BREATH);

      if (SLEEPING(tch)) {
         if (number(0, 1)) {
            sprintf(buf, "A loud %s jolts you from your slumber!\r\n",
                        subcmd == SCMD_HOWL ? "OOOOAAAOAOOHHH howl" : "ROAAARRRRRR");
            send_to_char(buf, tch);
            act("$n jumps up dazedly, awakened by the noise!", TRUE, tch, 0, 0, TO_ROOM);
            GET_POS(tch) = POS_SITTING;
            GET_STANCE(tch) = STANCE_ALERT;
            WAIT_STATE(tch, PULSE_VIOLENCE);
         }
      }
      else if (GET_DEX(tch) - 15 < number(0, 100) && GET_POS(tch) >= POS_STANDING) {
         send_to_char("In your panicked rush to flee, you trip!\r\n", tch);
         act("In a panicked rush to flee, $n trips!", FALSE, tch, 0, 0, TO_ROOM);
         GET_POS(tch) = POS_SITTING;
         GET_STANCE(tch) = STANCE_ALERT;
         WAIT_STATE(tch, PULSE_VIOLENCE);
      }
      else
         do_flee(tch, NULL, 0, 0);
      if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
         realvictims = TRUE;
   }

   if (realvictims) {
      if (subcmd == SCMD_HOWL)
         improve_skill(ch, SKILL_BATTLE_HOWL);
      else
         improve_skill(ch, SKILL_ROAR);
   }

   WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_sweep)
{
   struct char_data *tch, *next_tch;
   bool realvictims = FALSE;
   ACMD(do_flee);

   if (!ch || ch->in_room == NOWHERE)
      return;

   if (GET_SKILL(ch, SKILL_SWEEP) < 1 || EFF_FLAGGED(ch, EFF_CHARM)) {
      send_to_char("Huh?!?\r\n", ch);
      return;
   }

   act("&2$n&2 sweeps with $s enormous tail!&0", FALSE, ch, 0, 0, TO_ROOM);
   send_to_char("&2You sweep with your enormous tail!&0\r\n", ch);

   for (tch = world[ch->in_room].people; tch; tch = next_tch) {
      next_tch = tch->next_in_room;

      if (tch == ch)
         continue;
      /* Mobs don't sweep other mobs, unless they're pets. */
      if (!IS_PC(ch) && !IS_PC(tch) && !PLAYERALLY(ch) && !PLAYERALLY(tch))
         continue;
      if (is_grouped(ch, tch))
         continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
         continue;
      if (GET_VIEWED_DEX(tch) - 15 > number(0, 100) || GET_STANCE(tch) < STANCE_FIGHTING)
         continue;
      if (!attack_ok(ch, tch, FALSE))
         continue;
      if (PRF_FLAGGED(tch, PRF_NOHASSLE))
         continue;
      if (damage_evasion(tch, ch, 0, DAM_CRUSH)) {
         act(EVASIONCLR "$N's" EVASIONCLR " tail passes right through you.&0",
                  FALSE, tch, 0, ch, TO_CHAR);
         act(EVASIONCLR "$N's" EVASIONCLR " tail passes harmlessly through $n.&0",
                  FALSE, tch, 0, 0, TO_ROOM);
         set_fighting(tch, ch, TRUE);
         continue;
      }

      act("&3You are slammed to the ground by $N's&3 tail!&0",
            FALSE, tch, 0, ch, TO_CHAR);
      act("&3$n&3 is slammed to the ground by a mighty tail sweep!&0",
            FALSE, tch, 0, 0, TO_ROOM);
      GET_POS(tch) = POS_SITTING;
      GET_STANCE(tch) = STANCE_ALERT;
      WAIT_STATE(tch, PULSE_VIOLENCE);
      if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
          realvictims = TRUE;
   }

   if (realvictims)
       improve_skill(ch, SKILL_SWEEP);
   if (GET_LEVEL(ch) < LVL_IMMORT)
      WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_assist)
{
   struct char_data *helpee, *opponent;

   one_argument(argument, arg);

   if (FIGHTING(ch))
      send_to_char("You're already fighting!\r\n", ch);
   else if (!*arg)
      send_to_char("Whom do you wish to assist?\r\n", ch);
   else if (!(helpee = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))))
      send_to_char(NOPERSON, ch);
   else if (helpee == ch)
      send_to_char("Usually, you assist someone else.\r\n", ch);
   else {
      for (opponent = world[ch->in_room].people;
            opponent && (FIGHTING(opponent) != helpee);
            opponent = opponent->next_in_room)
         ;

      if (!opponent)
         act("But nobody is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
      else if (!CAN_SEE(ch, opponent))
         act("You can't see who is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
      else if (attack_ok(ch, opponent, TRUE)) {
         act("You assist $N&0 heroically.", FALSE, ch, 0, helpee, TO_CHAR);
         act("$n&0 assists you!", 0, ch, 0, helpee, TO_VICT);
         act("$n&0 heroically assists $N.", FALSE, ch, 0, helpee, TO_NOTVICT);
         if (CONFUSED(ch))
             opponent = random_attack_target(ch, opponent, TRUE);
         attack(ch, opponent);
      }
   }
}

ACMD(do_disengage)
{
   ACMD(do_abort);

   if (CASTING(ch)) {
      do_abort(ch, argument, 0, 0);
      return;
   }

   if (!FIGHTING(ch)) {
      send_to_char("You are not fighting anyone.\r\n",ch);
      return;
   }

   if (FIGHTING(FIGHTING(ch)) == ch) {
      send_to_char("No way! You are fighting for your life!\r\n", ch);
      return;
   }

   stop_fighting(ch);
   send_to_char("You disengage from combat.\r\n", ch);
   WAIT_STATE(ch, PULSE_VIOLENCE);
}


ACMD(do_hit)
{
   struct char_data *vict;

   one_argument(argument, arg);

   if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS))
      send_to_char("&8It is just too dark!&0", ch);
   else if (EFF_FLAGGED(ch, EFF_BLIND))
      send_to_char("You can't see a thing!\r\n", ch);
   else if (!*arg)
      send_to_char("Hit who?\r\n", ch);
   else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))))
      send_to_char("They don't seem to be here.\r\n", ch);
   else if (vict == ch) {
      send_to_char("You hit yourself...OUCH!.\r\n", ch);
      act("$n hits $mself, and says OUCH!", FALSE, ch, 0, vict, TO_ROOM);
   }
   else if (EFF_FLAGGED(ch, EFF_CHARM) && (ch->master == vict))
      act("$N is just such a good friend, you simply can't hit $M.", FALSE, ch, 0, vict, TO_CHAR);
   else if (attack_ok(ch, vict, TRUE)) {
      if (vict == FIGHTING(ch)) {
         send_to_char("&7You're doing the best you can!&0\r\n", ch);
         return;
      }
      else if (!FIGHTING(ch) || switch_ok(ch)) {
         if (CONFUSED(ch))
             vict = random_attack_target(ch, vict, TRUE);
         attack(ch, vict);
      }
      WAIT_STATE(ch, PULSE_VIOLENCE);
   }
}



ACMD(do_kill)
{
   struct char_data *vict;

   if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
      send_to_char("&8It is just too damn dark!&0", ch);
      return;
   }
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
      send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
      return;
   }

   if ((GET_LEVEL(ch) < LVL_GOD) || IS_NPC(ch)) {
      do_hit(ch, argument, cmd, subcmd);
      return;
   }
   one_argument(argument, arg);

   if (!*arg) {
      send_to_char("Kill who?\r\n", ch);
   } else {
      if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))))
         send_to_char("They aren't here.\r\n", ch);
      else if (ch == vict)
         send_to_char("Your mother would be so sad.. :(\r\n", ch);
      else if (GET_LEVEL(vict) == LVL_IMPL)
         send_to_char("&1You dare NOT do that!&0", ch);
      else{
         act("You chop $M to pieces!   Ah!   The blood!", FALSE, ch, 0, vict, TO_CHAR);
         act("$N chops you to pieces!", FALSE, vict, 0, ch, TO_CHAR);
         act("$n brutally slays $N!", FALSE, ch, 0, vict, TO_NOTVICT);
         die(vict, ch);
      }
   }
}

/* I've made this a higher end functionality of backstab instead of some 'tarded skill that rarely works - RLS 02/12/05*/
bool instantkill(struct char_data *ch, struct char_data *victim)
{
   int chance = 0;

   if (!victim || !ch || ch == victim || ch == NULL || victim == NULL)
      return FALSE;

   /* No more instant kills until the timer runs out */
   if (GET_COOLDOWN(ch, CD_INSTANT_KILL))
      return FALSE;

   if (IS_NPC(ch) ||
         !GET_SKILL(ch, SKILL_INSTANT_KILL) ||
         DECEASED(victim) ||
         (ch->in_room != victim->in_room) ||
         (GET_LEVEL(victim) > LVL_IMMORT))
      return FALSE;

   improve_skill_offensively(ch, victim, SKILL_INSTANT_KILL);
   if (number(1, 101) > GET_SKILL(ch, SKILL_INSTANT_KILL))
      return FALSE;

   /*chance is now checking DEX and shouldn't happen as often*/
   chance = 1000 - (GET_SKILL(ch, SKILL_INSTANT_KILL) - (100 - GET_DEX(ch)) -
            (GET_LEVEL(victim) * 10)) / 10;

   if (!AWAKE(victim))
      chance = 0; /* der.. can you say coup de grace? */

   if (number(1, 1000) >= chance) {
      quickdeath(victim, ch);
      SET_COOLDOWN(ch, CD_INSTANT_KILL, (120 - (GET_LEVEL(ch))) * PULSE_COOLDOWN);
      return TRUE;
   }
   return FALSE;
}



void slow_death(struct char_data *victim)
{
   if (!victim) {
      mudlog("Attempting to use slow_death on a NULL character!", BRF, LVL_GOD, TRUE);
      log("Attempting to use slow_death on a NULL character!");
      return;
   }

   if (victim->attackers) {
      /* Someone is fighting this person, so don't die just yet! */
      GET_HIT(victim) = HIT_MORTALLYW;
      hp_pos_check(victim, NULL, 0);
      return;
   }

   act("&8With a soft groan, $n slips off into the cold sleep of death.&0",
         TRUE, victim, 0, 0, TO_ROOM);
   act("&8$n is dead!   R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
   if (AWAKE(victim)) {
      act("&8You feel yourself slipping away and falling into the abyss.&0",
            FALSE, victim, 0, 0,TO_CHAR);
      send_to_char("&0&8Your life fades away ....\r\n", victim);
   }

   die(victim, NULL);
}

void quickdeath(struct char_data *victim, struct char_data *ch)
{
   if (GET_LEVEL(victim) >= LVL_IMMORT ||
            (ch && MOB_FLAGGED(ch, MOB_ILLUSORY)))
      return;

   send_to_char("You deliver the killing blow.\r\n", ch);
   act("$n's strike upon $N is faster than the eye can see.", TRUE, ch,
            0, victim, TO_NOTVICT);
   send_to_char("You feel a sharp sting, and all goes black.\r\n", victim);

   hurt_char(victim, ch, GET_MAX_HIT(victim) + 20, FALSE);
}

ACMD(do_backstab) {
   struct char_data *vict, *tch;
   struct effect eff;
   int percent, prob, percent2, prob2;
   struct obj_data *weapon;

   if (GET_COOLDOWN(ch, CD_BACKSTAB)) {
      send_to_char("Give yourself a chance to get back into position!\r\n", ch);
      return;
   }

   if (GET_SKILL(ch, SKILL_BACKSTAB) < 1) {
      send_to_char("You don't know how.\r\n", ch);
      return;
   }

   one_argument(argument, buf);

   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, buf)))) {
      if (!FIGHTING(ch)) {
         send_to_char("Backstab who?\r\n", ch);
         return;
      } else {
         vict = FIGHTING(ch);
      }
   }

   if (vict == ch) {
      send_to_char("How can you sneak up on yourself?\r\n", ch);
      return;
   }

   if (!attack_ok(ch, vict, TRUE))
      return;

   /* You can backstab as long as you're not the tank */
   for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
      if (FIGHTING(tch) == ch) {
         if (FIGHTING(ch) == tch)
            act("$N's facing the wrong way!\r\n", FALSE, ch, 0, tch, TO_CHAR);
         else if (FIGHTING(ch))
            act("You're too busy fighting $N to backstab anyone!",
                  FALSE, ch, 0, FIGHTING(ch), TO_CHAR);
         else
            act("$N is coming in for the attack - you cannot backstab $M now.",
                  FALSE, ch, 0, tch, TO_CHAR);
         return;
      }
   }

   if (EFF_FLAGGED(ch, EFF_BLIND)) {
      send_to_char("You can't see a thing!\r\n", ch);
      return;
   }

   /* Got a weapon? Any weapon? */
   weapon = GET_EQ(ch, WEAR_WIELD);
   if (!weapon)
      weapon = GET_EQ(ch, WEAR_WIELD2);
   if (!weapon)
      weapon = GET_EQ(ch, WEAR_2HWIELD);

   if (!weapon) {
     send_to_char("Backstab with what, your fist?\r\n", ch);
     return;
   }

   /* If wielding something unsuitable in first hand, use weapon in second hand */
   if (!IS_WEAPON_PIERCING(weapon) && GET_EQ(ch, WEAR_WIELD2))
      weapon = GET_EQ(ch, WEAR_WIELD2);

   if (!IS_WEAPON_PIERCING(weapon)) {
      send_to_char("Piercing weapons must be used to backstab.\r\n", ch);
      return;
   }

   if (CONFUSED(ch))
      vict = random_attack_target(ch, vict, TRUE);

   if (damage_evasion(vict, ch, weapon, DAM_PIERCE)) {
      damage_evasion_message(ch, vict, weapon, DAM_PIERCE);
      set_fighting(vict, ch, TRUE);
      return;
   }

   /* Illusionists can't backstab someone who is in battle. */
   if (GET_CLASS(ch) == CLASS_ILLUSIONIST && FIGHTING(vict)) {
      send_to_char("You can't sneak up on someone who's fighting!\r\n", ch);
      return;
   }

   /* If the mob is flagged aware, is not sleeping, and is not currently
      fighting, then you can not backstab the mob */
   if (MOB_FLAGGED(vict, MOB_AWARE) && AWAKE(vict) && !FIGHTING(vict) &&
         !EFF_FLAGGED(vict, EFF_MINOR_PARALYSIS) &&
         !EFF_FLAGGED(vict, EFF_MAJOR_PARALYSIS)) {
      act("You notice $N sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
      act("$e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
      act("$n notices $N sneaking up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);
      attack(vict, ch);
      return;
   }

   /* 50% chance the mob is aware, even in combat */
   if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict) &&
         !EFF_FLAGGED(vict, EFF_MINOR_PARALYSIS) &&
         !EFF_FLAGGED(vict, EFF_MAJOR_PARALYSIS) &&
         FIGHTING(vict) &&
         number(1, GET_LEVEL(vict)) > GET_SKILL(ch, SKILL_BACKSTAB) / 2) {
      act("You notice $N trying to sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
      act("You failed - $e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
      act("$n notices $N trying to sneak up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);

      attack(vict, ch);

      WAIT_STATE(ch, PULSE_VIOLENCE);
      SET_COOLDOWN(ch, CD_BACKSTAB, 6 * PULSE_COOLDOWN);

      if (!EFF_FLAGGED(vict, EFF_AWARE)) {
         memset(&eff, 0, sizeof(eff));
         eff.type = SKILL_AWARE;
         eff.duration = 2;
         eff.modifier = 0;
         eff.location = APPLY_NONE;
         SET_FLAG(eff.flags, EFF_AWARE);
         effect_to_char(vict, &eff);
      }
      return;
   }

   percent = number(1, 101);        /* 101% is a complete failure */

   if (EFF_FLAGGED(vict, EFF_AWARE) && AWAKE(vict) && !FIGHTING(vict))
      percent = 150;  /*silent failure*/

   if (EFF_FLAGGED(vict, EFF_AWARE) && FIGHTING(vict))
      percent += number(1, 10);  /* It's a little harder to backstab a mob you've already backstabed */

   prob = MIN(97, GET_SKILL(ch, SKILL_BACKSTAB) - GET_LEVEL(vict) + 90);

   if (!CAN_SEE(vict, ch))
      prob += GET_SKILL(ch, SKILL_BACKSTAB) / 2;  /* add blindfighting skill */

   if (instantkill(ch, vict))
      return;

   if (AWAKE(vict) && (percent > prob)) {
      /* Backstab failed */
      act("$N tried to backstab you, but you moved away in time!", FALSE, vict, 0, ch, TO_CHAR);
      act("You failed to backstab $n, but manage to take a swing at $m!", FALSE, vict, 0, ch, TO_VICT);
      act("$N tried to backstab $n, but missed and managed to take a swing instead!", FALSE, vict, 0, ch, TO_NOTVICT);
      hit(ch, vict, weapon == GET_EQ(ch, WEAR_WIELD2) ?
          SKILL_DUAL_WIELD : TYPE_UNDEFINED);
   } else {
      /* Backstab succeeded */
      hit(ch, vict, weapon == GET_EQ(ch, WEAR_WIELD2) ?
          SKILL_2BACK : SKILL_BACKSTAB);
   }
   improve_skill_offensively(ch, vict, SKILL_BACKSTAB);

   WAIT_STATE(ch, PULSE_VIOLENCE);
   /* 6 seconds == 1.5 combat rounds.*/
   SET_COOLDOWN(ch, CD_BACKSTAB, 6 * PULSE_COOLDOWN);

   if (DECEASED(vict))
      return;

   /* Make the victim aware for a while */
   if (!EFF_FLAGGED(vict, EFF_AWARE)) {
      memset(&eff, 0, sizeof(eff));
      eff.type = SKILL_AWARE;
      eff.duration = 2;
      eff.modifier = 0;
      eff.location = APPLY_NONE;
      SET_FLAG(eff.flags, EFF_AWARE);
      effect_to_char(vict, &eff);
   }

   /* Assassins may perform a dual backstab. */
   if (GET_CLASS(ch) != CLASS_ASSASSIN)
      return;

   /* But only if wielding two piercing weapons */
   if (!GET_EQ(ch, WEAR_WIELD2) || weapon == GET_EQ(ch, WEAR_WIELD2) ||
         !IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD2)))
      return;

   percent2 = number(1, 101);  /* 101% is a complete failure */

   if (EFF_FLAGGED(vict, EFF_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
      percent2 = 150;  /*silent failure*/
   }

   if (EFF_FLAGGED(vict, EFF_AWARE) && FIGHTING(vict))
      percent2 += number(1, 10);  /* It's a little harder to backstab a mob you've already backstabed */

   prob2 = GET_SKILL(ch, SKILL_BACKSTAB);

   /* Bonus points if the backstabee can't see the backstaber */
   if (!CAN_SEE(vict, ch)) {
      prob2 += GET_SKILL(ch, SKILL_BACKSTAB) / 2;
   }

   if (AWAKE(vict) && (percent2 > prob2)) {
      /* Backstab failed */
      attack(ch, vict);
   } else {
      /* Backstab succeeded */
      hit(ch, vict, SKILL_2BACK);
   }
   improve_skill_offensively(ch, vict, SKILL_BACKSTAB);
}

ACMD(do_flee)
{
   int i, attempt;

   if (!ch || ch->in_room == NOWHERE)
      return;

   /* Don't show this message for sleeping and below */
   if (GET_STANCE(ch) > STANCE_SLEEPING && (IS_NPC(ch) ? GET_MOB_WAIT(ch) : CHECK_WAIT(ch))) {
      send_to_char("You cannot flee yet!\r\n", ch);
      return;
   }

   if (FIGHTING(ch) && EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too angry to leave this fight!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS)) {
      cprintf(ch, "You can't move!\r\n");
      return;
   }

   switch (GET_STANCE(ch)) {
   case STANCE_DEAD:
   case STANCE_MORT:
   case STANCE_INCAP:
   case STANCE_STUNNED:
      send_to_char("It's a bit too late for that.\r\n", ch);
      break;
   case STANCE_SLEEPING:
      send_to_char("You dream of fleeing!\r\n", ch);
      break;
   default:
      switch (GET_POS(ch)) {
         case POS_PRONE:
         case POS_SITTING:
         case POS_KNEELING:
            abort_casting(ch);
            act("Looking panicked, $n scrambles madly to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
            send_to_char("You scramble madly to your feet!\r\n", ch);
            GET_POS(ch) = POS_STANDING;
            GET_STANCE(ch) = STANCE_ALERT;
            if (IS_NPC(ch))
                 WAIT_STATE(ch, PULSE_VIOLENCE * 2);
            break;
         default:
            if (IS_CORNERED(ch)) {
                 act("$n tries to flee, but is unable to escape from $N!",
                          TRUE, ch, 0, ch->cornered_by, TO_NOTVICT);
                 act("$n tries to flee, but is unable to escape from you!",
                          TRUE, ch, 0, ch->cornered_by, TO_VICT);
                 act("PANIC!   You couldn't escape from $N!",
                          TRUE, ch, 0, ch->cornered_by, TO_CHAR);
                 return;
            }
            for (i = 0; i < 6; i++) {   /* Make 6 attempts */
               attempt = number(0, NUM_OF_DIRS - 1); /* Select a random direction */

               if (CAN_GO(ch, attempt) &&
                     !ROOM_FLAGGED(CH_NDEST(ch, attempt), ROOM_DEATH)) {
                  abort_casting(ch);
                  act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
                  if (do_simple_move(ch, attempt, TRUE)) {
                     sprintf(buf, "&0You panic and flee %s!&0\r\n", dirs[attempt]);
                     send_to_char(buf, ch);
                  } else
                     act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
                  return;
               }
            }
            /* All 6 attempts failed! */
            act("$n tries to flee, but PANICS instead!", TRUE, ch, 0, 0, TO_ROOM);
            send_to_char("PANIC!   You couldn't escape!\r\n", ch);
      }
   }
}

ACMD(do_retreat)
{
   int dir, to_room;
   struct char_data *vict;

   if (!ch || !argument)
      return;

   if (!GET_SKILL(ch, SKILL_RETREAT)) {
      send_to_char("Try flee instead!\r\n", ch);
      return;
   }

   if (!FIGHTING(ch)) {
      send_to_char("You're not fighting anyone!\r\n", ch);
      return;
   }

   one_argument(argument, arg);

   if (!*arg) {
      send_to_char("Retreat where!?\r\n", ch);
      return;
   }

   dir = searchblock(arg, dirs, FALSE);

   if (dir < 0 || !CH_DEST(ch, dir)) {
      send_to_char("You can't retreat that way!\r\n", ch);
      return;
   }

   /*
   for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
      if (FIGHTING(tch) == ch) {
         send_to_char("&8You cannot retreat while tanking!&0\r\n", ch);
         return;
      }
   */

   vict = FIGHTING(ch);

   /* Successful retreat? */
   if (GET_SKILL(ch, SKILL_RETREAT) > number(0, 81) && CAN_GO(ch, dir) &&
         !ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_DEATH) &&
         do_simple_move(ch, dir, TRUE)) {

      /* Send message back to original room. */
      sprintf(buf, "$n carefully retreats from combat, leaving %s.", dirs[dir]);
      to_room = ch->in_room;
      ch->in_room = vict->in_room;
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
      ch->in_room = to_room;

      sprintf(buf, "\r\nYou skillfully retreat %s.\r\n", dirs[dir]);
      send_to_char(buf, ch);
   }
   /* If fighting a mob that can switch, maybe get attacked. */
   else if (IS_NPC(FIGHTING(ch)) && FIGHTING(FIGHTING(ch)) != ch &&
                GET_SKILL(FIGHTING(ch), SKILL_SWITCH) &&
                GET_SKILL(FIGHTING(ch), SKILL_SWITCH) > number(1, 101)) {
      stop_fighting(FIGHTING(ch));
      act("$n fails to retreat, catching $N's attention!", TRUE, ch, 0, FIGHTING(ch), TO_NOTVICT);
      act("You notice $n trying to escape and attack $m!", FALSE, ch, 0, FIGHTING(ch), TO_VICT);
      send_to_char("You fail to retreat, and catch the attention of your opponent!\r\n", ch);
      attack(FIGHTING(ch), ch);
   }
   else {
      act("$n stumbles and trips as $e fails to retreat!", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You stumble and trip as you try to retreat!\r\n", ch);
      if (GET_LEVEL(ch) < LVL_GOD) {
         GET_POS(ch) = POS_SITTING;
         GET_STANCE(ch) = STANCE_ALERT;
      }
   }

   improve_skill_offensively(ch, vict, SKILL_RETREAT);
   WAIT_STATE(ch, PULSE_VIOLENCE);
}


ACMD(do_gretreat)
{
   int dir, opponents, was_in, to_room;
   struct char_data *tch;
   struct follow_type *k, *next_k;
   bool realopponents = FALSE;

   if (!ch || !argument)
      return;

   if (!GET_SKILL(ch, SKILL_GROUP_RETREAT)) {
      send_to_char("Try flee instead!\r\n", ch);
      return;
   }

   if (!FIGHTING(ch)) {
      send_to_char("You're not fighting anyone!\r\n", ch);
      return;
   }

   argument = one_argument(argument, arg);

   if (!*arg) {
      send_to_char("Retreat where!?\r\n", ch);
      return;
   }

   dir = searchblock(arg, dirs, FALSE);

   if (dir < 0 || !CH_DEST(ch, dir)) {
      send_to_char("You can't retreat that way!\r\n", ch);
      return;
   }

   was_in = IN_ROOM(ch);

   opponents = 0;
   for (tch = ch->attackers; tch; tch = tch->next_attacker) {
      ++opponents;
      if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
         realopponents = TRUE;
   }

   /*
    * Can the followers see the leader before it leaves?
    */
   for (k = ch->followers; k; k = k->next)
      k->can_see_master = CAN_SEE(k->follower, ch);

   if (!opponents)
      send_to_char("You must be tanking to successfully lead your group in retreat!\r\n", ch);
   else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) < opponents * number(20, 24))
      send_to_char("There are too many opponents to retreat from!\r\n", ch);

   /* Successful retreat? */
   else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) > number(0, 81) &&
         !ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_DEATH) &&
         CAN_GO(ch, dir) && do_simple_move(ch, dir, TRUE)) {
      /* Echo line back to the original room. */
      sprintf(buf, "$n carefully retreats from combat, leading $s group %s.", dirs[dir]);

      to_room = ch->in_room;
      ch->in_room = was_in;
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
      ch->in_room = to_room;
      sprintf(buf, "\r\nYou skillfully lead your group %s.\r\n", dirs[dir]);
      send_to_char(buf, ch);

      for (k = ch->followers; k; k = next_k) {
         next_k = k->next;
         if (k->follower->in_room == was_in &&
               GET_STANCE(k->follower) >= STANCE_ALERT &&
               k->can_see_master) {
            abort_casting(k->follower);
            act("You follow $N.", FALSE, k->follower, 0, ch, TO_CHAR);
            perform_move(k->follower, dir, 1, FALSE);
         }
      }
   }
   else {
      act("$n stumbles and trips as $e fails to retreat!", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You stumble and trip as you try to retreat!\r\n", ch);
      if (GET_LEVEL(ch) < LVL_GOD) {
         GET_POS(ch) = POS_SITTING;
         GET_STANCE(ch) = STANCE_ALERT;
      }
   }

   if (realopponents)
      improve_skill(ch, SKILL_GROUP_RETREAT);
   WAIT_STATE(ch, PULSE_VIOLENCE);
}



ACMD(do_bash)
{
   struct char_data *vict;
   int percent, prob, skill, rounds;

   switch (subcmd) {
   case SCMD_BODYSLAM:
      skill = SKILL_BODYSLAM;
      break;
   case SCMD_MAUL:
      skill = SKILL_MAUL;
      break;
   case SCMD_BASH:
   default:
      skill = SKILL_BASH;
      break;
   }

   if (!GET_SKILL(ch, skill)) {
      send_to_char("You're not really sure how...\r\n", ch);
      return;
   }

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
         send_to_char("&8It's just too dark!&0", ch);
         return;
      }

      if (EFF_FLAGGED(ch, EFF_BLIND)) {
         send_to_char("You can't see a thing!\r\n", ch);
         return;
      }

      if (skill == SKILL_BODYSLAM && FIGHTING(ch)) {
         send_to_char("You can't bodyslam in combat...\r\n", ch);
         return;
      }

      if (GET_COOLDOWN(ch, CD_BASH)) {
         sprintf(buf, "You haven't reoriented yourself for another %s yet!\r\n",
               skills[skill].name);
         send_to_char(buf, ch);
         return;
      }
   }

   one_argument(argument, arg);

   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      vict = FIGHTING(ch);
      if (!vict || IN_ROOM(ch) != IN_ROOM(vict) || !CAN_SEE(ch, vict)) {
         sprintf(buf, "%s who?\r\n", skills[skill].name);
         send_to_char(CAP(buf), ch);
         return;
      }
   }

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (skill == SKILL_MAUL &&
            (!EFF_FLAGGED(ch, EFF_BERSERK) || !EFF_FLAGGED(ch, EFF_SPIRIT_BEAR))) {
         act("You're not angry enough to tear $M limb from limb.\r\n",
               FALSE, ch, 0, vict, TO_CHAR);
         return;
      }
   }

   if (vict == ch) {
      send_to_char("Aren't we funny today...\r\n", ch);
      return;
   }
   if (vict == ch->guarding) {
      act("You can't do that while you are guarding $M.",
            FALSE, ch, 0, vict, TO_CHAR);
      return;
   }

   /* check for pk/pets/shapeshifts */
   if (!attack_ok(ch, vict, TRUE))
      return;
   vict = check_guard(ch, vict, FALSE);
   if (!attack_ok(ch, vict, TRUE))
      return;

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   if (GET_POS(vict) <= POS_SITTING) {
      act("$E has already been knocked down.", FALSE, ch, 0, vict, TO_CHAR);
      return;
   }

   prob = GET_SKILL(ch, skill);
   percent = number(1, 101); /* 101 is a complete failure */
   switch (skill) {
   case SKILL_BODYSLAM:
      prob = number(1, 100); /* bodyslam uses random num instead of skill */
      prob += GET_LEVEL(ch);
      prob += GET_HITROLL(ch) - monk_weight_penalty(ch);
      percent += GET_SKILL(vict, SKILL_DODGE);
      percent += GET_LEVEL(vict);
      rounds = 3;
      break;
   case SKILL_BASH:
      if (GET_EQ(ch, WEAR_2HWIELD)) /* 2H wield precludes a shield */
         prob /= 2;
      else if (!GET_EQ(ch, WEAR_SHIELD))
         prob /= 10; /* no shield or 2h weapon: 10% skill */
      rounds = 2;
      break;
   case SKILL_MAUL:
   default:
      rounds = 2;
      break;
   }

   if (GET_LEVEL(vict) >= LVL_IMMORT)
      percent = prob + 1; /* insta-fail */

   if ((prob > percent || MOB_FLAGGED(vict, MOB_NOBASH)) &&
            damage_evasion(vict, ch, 0, DAM_CRUSH)) {
      act(EVASIONCLR "You charge right through $N&7&b!&0",
               FALSE, ch, 0, vict, TO_CHAR);
      act(EVASIONCLR "$n" EVASIONCLR " charges right through $N" EVASIONCLR "!&0",
               FALSE, ch, 0, vict, TO_NOTVICT);
      act(EVASIONCLR "$n" EVASIONCLR " charges right through you!&0",
               FALSE, ch, 0, vict, TO_VICT);
      send_to_char("You fall down!\r\n", ch);
      act("$n falls down!", FALSE, ch, 0, 0, TO_ROOM);
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
      set_fighting(vict, ch, FALSE);
      return;
   }

   /* NO BASH - you fail. */
   if (MOB_FLAGGED(vict, MOB_NOBASH)) {
      act("You &3&bslam&0 into $N, but $E seems quite unmoved.",
            FALSE, ch, 0, vict, TO_CHAR);
      act("$n &3&bslams&0 into $N, who seems as solid as a rock!",
            FALSE, ch, 0, vict, TO_NOTVICT);
      act("$n &3&bslams&0 into you, attempting to knock you down.",
            FALSE, ch, 0, vict, TO_VICT);
      /* A pause... but you don't fall down. */
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      set_fighting(vict, ch, FALSE);
      return;
   }

   if (GET_SIZE(vict) - GET_SIZE(ch) > 1) {
      sprintf(buf, "&7&bYou fall over as you try to %s someone so large!&0\r\n", skills[skill].name);
      send_to_char(buf, ch);
      act("&7&b$n BOUNCES off $N, as $e tries to $t $N's much larger size.&0",
            FALSE, ch, (void *) skills[skill].name, vict, TO_NOTVICT);
      act("&7&b$n BOUNCES off you as $e tries to $t your much larger size.&0",
            FALSE, ch, (void *) skills[skill].name, vict, TO_VICT);
      percent = prob + 1; /* insta-fail */
   }
   else if (GET_SIZE(ch) - GET_SIZE(vict) > 2) {
      sprintf(buf, "&7&bYou fall over as you try to %s someone with such small size.&0\r\n", skills[skill].name);
      send_to_char(buf, ch);
      act("&7&b$n trips over $N, as $e tries to $t $N's much smaller size.&0",
            FALSE, ch, (void *) skills[skill].name, vict, TO_NOTVICT);
      act("&7&b$n trips over you as $e tries to $t your much smaller size.&0",
            FALSE, ch, (void *) skills[skill].name, vict, TO_VICT);
      percent = prob + 1; /* insta-fail */
   }

   if (prob > percent) { /* Success! */
      WAIT_STATE(vict, PULSE_VIOLENCE * rounds);
      damage(ch, vict,
            dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH),
            skill);
      if (GET_POS(vict) > POS_SITTING)
        alter_pos(vict, POS_SITTING, STANCE_ALERT);
   } else {
      if (skill == SKILL_BASH && !GET_EQ(ch, WEAR_SHIELD))
         send_to_char("You need to wear a shield to make it a success!\r\n", ch);
      /* damage comes before alter_pos here. If alter_pos came first, then if
       * the fight was started by this action, you might be in a sitting
       * position when the fight began, which would make you automatically
       * stand. We don't want that. */
      damage(ch, vict, 0, skill);
      alter_pos(ch, POS_SITTING, STANCE_ALERT);
   }

   WAIT_STATE(ch, PULSE_VIOLENCE * 2);
   SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE * 2);
   improve_skill_offensively(ch, vict, skill);
}



ACMD(do_rescue)
{
   struct char_data *vict, *attacker, *c;
   int percent, prob, num;

   one_argument(argument, arg);

   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      send_to_char("Whom do you want to rescue?\r\n", ch);
      return;
   }
   if (vict == ch) {
      send_to_char("What about fleeing instead?\r\n", ch);
      return;
   }
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
      send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
      return;
   }
   if (FIGHTING(ch) == vict) {
      send_to_char("How can you rescue someone you are trying to kill?\r\n", ch);
      return;
   }
   if (!vict->attackers) {
      act("But nobody is fighting $M!", FALSE, ch, 0, vict, TO_CHAR);
      return;
   }
   if (GET_SKILL(ch, SKILL_RESCUE) == 0) {
      send_to_char("But only true warriors can do this!\r\n", ch);
      return;
   }

   /* Choose a random attacker from those fighting vict */
   attacker = vict->attackers;
   num = 1;
   for (c = attacker->next_attacker; c; c = c->next_attacker) {
      num++;
      if (number(1, num) == 1)
         attacker = c;
   }

   percent = number(1, 101);            /* 101% is a complete failure */
   prob = GET_SKILL(ch, SKILL_RESCUE);

   if (percent > prob) {
      send_to_char("You fail the rescue!\r\n", ch);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      improve_skill_offensively(ch, attacker, SKILL_RESCUE);
      return;
   }
   send_to_char("Banzai!   To the rescue...\r\n", ch);
   act("You are rescued by $N, you are confused!", FALSE, vict, 0, ch, TO_CHAR);
   act("$n heroically rescues $N!", FALSE, ch, 0, vict, TO_NOTVICT);

   if (FIGHTING(vict) == attacker)
      stop_fighting(vict);
   stop_fighting(attacker);
   if (FIGHTING(ch))
      stop_fighting(ch);

   set_fighting(ch, attacker, TRUE);

   WAIT_STATE(ch, PULSE_VIOLENCE);
   WAIT_STATE(vict, PULSE_VIOLENCE + 2);

   improve_skill_offensively(ch, attacker, SKILL_RESCUE);
}


ACMD(do_kick)
{
   struct char_data *vict;
   int percent, prob;

   if (GET_SKILL(ch, SKILL_KICK) == 0) {
      send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
      return;
   }


   one_argument(argument, arg);

   if ( !(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))) )
   {
      if (FIGHTING(ch))
      {
         vict = FIGHTING(ch);
      }
      else
      {
         send_to_char("Kick who?\r\n", ch);
         return;
      }
   }
   if (vict == ch) {
      send_to_char("Aren't we funny today...\r\n", ch);
      return;
   }

   if (!attack_ok(ch, vict, TRUE))
      return;

   if (EFF_FLAGGED(ch, EFF_IMMOBILIZED)) {
      send_to_char("You can't lift your legs!\r\n", ch);
      return;
   }

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   /* Need to see whether this player is fighting already. Kick should not
       allow for the player to switch without a switch probability being
       calculated into the mix. (DEMOLITUM) */
   WAIT_STATE(ch, PULSE_VIOLENCE);
   if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
      return;

   percent = ((10 - ((GET_AC(vict)+(monk_weight_penalty(vict)*5)) / 10)) << 1) + number(1, 101);
   prob = GET_SKILL(ch, SKILL_KICK);
   if (percent > prob) {
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      damage(ch, vict, 0, SKILL_KICK);
   } else {
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      if (damage_evasion(vict, ch, 0, DAM_CRUSH)) {
          act(EVASIONCLR "Your foot passes harmlessly through $N" EVASIONCLR "!&0",
                   FALSE, ch, 0, vict, TO_CHAR);
          act(EVASIONCLR "$n&7&b sends $s foot whistling right through $N" EVASIONCLR ".&0",
                   FALSE, ch, 0, vict, TO_NOTVICT);
          act(EVASIONCLR "$n" EVASIONCLR
                   " tries to kick you, but $s foot passes through you harmlessly.&0",
                   FALSE, ch, 0, vict, TO_VICT);
          set_fighting(vict, ch, TRUE);
          return;
      }
      damage(ch, vict,
            dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH),
            SKILL_KICK);
   }
   improve_skill_offensively(ch, vict, SKILL_KICK);
}


ACMD(do_eye_gouge)
{
   struct char_data *vict;
   int percent, prob;
   struct effect eff;

   if (GET_SKILL(ch, SKILL_EYE_GOUGE) == 0) {
      send_to_char("You would do such a despicable act!?   Horrible!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BLIND)) {
      send_to_char("It's going to be hard to gouge someone's eyes out if you can't even see.\r\n", ch);
      return;
   }

   one_argument(argument, arg);


   if (!*arg) {
      if (FIGHTING(ch))
         vict = FIGHTING(ch);
      else {
         send_to_char("Whose eyes do you want to gouge out?\r\n", ch);
         return;
      }
   } else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
       send_to_char("Nobody here by that name.\r\n", ch);
       return;
   }

   if (FIGHTING(ch) && FIGHTING(ch) != vict) {
      send_to_char("You need to be facing each other for this to work.\r\n", ch);
      return;
   }

   if (vict == ch) {
      send_to_char("That would make life difficult, wouldn't it?\r\n", ch);
      return;
   }

   /* check pk/pets/shapeshifts */
   if (!attack_ok(ch, vict, TRUE))
      return;

   if (GET_COOLDOWN(ch, CD_EYE_GOUGE)) {
      send_to_char("You aren't able to find an opening yet!\r\n", ch);
      return;
   }

   if (GET_LEVEL(ch) < LVL_GOD)
      SET_COOLDOWN(ch, CD_EYE_GOUGE, 3 * PULSE_VIOLENCE);

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   percent = number(1, 101);
   prob = GET_SKILL(ch, SKILL_EYE_GOUGE);
   WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
   if (percent > prob && AWAKE(vict))
      damage(ch, vict, 0, SKILL_EYE_GOUGE); /* Miss message */
   else if (damage_evasion(vict, ch, 0, DAM_PIERCE)) {
      act(EVASIONCLR "Your thumbs poke harmlessly at $N" EVASIONCLR
               ".   If $E even has eyes.",
               FALSE, ch, 0, vict, TO_CHAR);
      act(EVASIONCLR "$n" EVASIONCLR " tries poking at $N's eyes, but nothing seems to happen.",
               FALSE, ch, 0, vict, TO_NOTVICT);
      act(EVASIONCLR "$n" EVASIONCLR " pokes fruitlessly at you with $s thumbs.",
               FALSE, ch, 0, vict, TO_VICT);
      set_fighting(vict, ch, TRUE);
      return;
   } else if (GET_LEVEL(vict) >= LVL_IMMORT && GET_LEVEL(vict) > GET_LEVEL(ch)) {
      act("Ouch!   You hurt your thumbs trying to poke out $N's eyes!",
               FALSE, ch, 0, vict, TO_CHAR);
      act("$n tries poking out $N's eyes - what a laugh!",
               FALSE, ch, 0, vict, TO_NOTVICT);
      act("$n pokes harmlessly at your eyes with $s thumbs.",
               FALSE, ch, 0, vict, TO_VICT);
      return;
   } else {
      if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !EFF_FLAGGED(vict, EFF_BLIND)) {
         memset(&eff, 0, sizeof(eff));
         eff.type = SKILL_EYE_GOUGE;
         eff.duration = 1;
         eff.modifier = -2 - GET_SKILL(ch, SKILL_EYE_GOUGE) / 10;
         eff.location = APPLY_HITROLL;
         SET_FLAG(eff.flags, EFF_BLIND);
         effect_to_char(vict, &eff);
      }
      damage(ch, vict,
            dam_suscept_adjust(ch, vict, 0,
               (GET_SKILL(ch, SKILL_EYE_GOUGE) + percent) / 4, DAM_PIERCE),
            SKILL_EYE_GOUGE);
   }

   if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !EFF_FLAGGED(vict, EFF_BLIND))
      improve_skill_offensively(ch, vict, SKILL_EYE_GOUGE);
}


ACMD(do_springleap)
{
   struct char_data *vict;
   int percent, prob, dmg;

   if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS) && !CAN_SEE_IN_DARK(ch)) {
      send_to_char("&8It is too dark!&0", ch);
      return;
   }

   if (!GET_SKILL(ch, SKILL_SPRINGLEAP))   {
      send_to_char("You'd better leave all the martial arts to monks.\r\n", ch);
      return;
   }

   if (GET_POS(ch) > POS_SITTING) {
      send_to_char("You can't spring from that position, try sitting!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_IMMOBILIZED)) {
      send_to_char("You can't lift your legs!\r\n", ch);
      return;
   }

   one_argument(argument, arg);

   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      if (FIGHTING(ch))
         vict = FIGHTING(ch);
      else {
         send_to_char("&0Spring-leap whom?&0\r\n", ch);
         return;
      }
   }

   if (vict == ch)   {
      send_to_char("That might hurt too much...\r\n", ch);
      return;
   }

   /* check pk/pets/shapeshifts */
   if (!attack_ok(ch, vict, TRUE))
      return;

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   percent = number(6, 77) - (GET_AC(vict) + (5 * monk_weight_penalty(vict))) / 20;

   prob = GET_SKILL(ch, SKILL_SPRINGLEAP);

   if (GET_POS(vict) <= POS_SITTING)
      percent = 101;

   if (GET_STANCE(vict) < STANCE_FIGHTING)
      prob -= 20;

   if (percent > prob) {
      act("&0&6You try to take $N down but you spring over $S head!&0",
            FALSE, ch, 0, vict, TO_CHAR);
      act("&0&6$N springs from the ground at you but soars over your head!&0",
            FALSE, vict, 0, ch, TO_CHAR);
      act("&0&6$N springs from the ground at $n but misses by a mile!&0",
            FALSE, vict, 0, ch, TO_NOTVICT);
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      damage(ch, vict, 0, SKILL_SPRINGLEAP);
      if (AWAKE(ch)) {
         GET_POS(ch) = POS_SITTING;
         GET_STANCE(ch) = STANCE_ALERT;
      }
   }
   else if (damage_evasion(vict, ch, 0, DAM_CRUSH)) {
      act(EVASIONCLR "You hurtle right through $N" EVASIONCLR
               " and land in a heap on the other side!",
               FALSE, ch, 0, vict, TO_CHAR);
      act(EVASIONCLR "$n" EVASIONCLR " leaps at $N" EVASIONCLR
               " but flies right on through!",
               FALSE, ch, 0, vict, TO_NOTVICT);
      act(EVASIONCLR "$n" EVASIONCLR
               " comes flying at you, but just passes through and hits the ground.",
               FALSE, ch, 0, vict, TO_VICT);
      /* You fall */
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
      set_fighting(vict, ch, FALSE);
      return;
   } else if (percent > 0.95 * prob) {
      dmg = dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH);
      act("&0&6You manage to take $N down but also &bfall down yourself!&0 (&3$i&0)",
               FALSE, ch, (void *) dmg, vict, TO_CHAR);
      act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0 (&1&8$i&0)",
               FALSE, vict, (void *) dmg, ch, TO_CHAR);
      act("&0&6$N springs from the ground, knocking $n down and &bfalling in the process!&0 (&4$i&0)",
               FALSE, vict, (void *) dmg, ch, TO_NOTVICT);
      WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
      WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
      damage(ch, vict, dmg, SKILL_SPRINGLEAP);
      if (AWAKE(vict) && IN_ROOM(ch) == IN_ROOM(vict)) {
         abort_casting(vict);
         GET_POS(vict) = POS_SITTING;
         GET_STANCE(vict) = STANCE_ALERT;
      }
      if (AWAKE(ch)) {
         GET_POS(ch) = POS_SITTING;
         GET_STANCE(ch) = STANCE_ALERT;
      }
   }
   else {
      dmg = dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH);
      act("&0&b&8You spring from the ground, knocking $N off balance.&0 (&1&8$i&0)",
               FALSE, ch, (void *) dmg, vict, TO_CHAR);
      act("&0&b&8$N springs from the ground and knocks you down!&0 (&3$i&0)",
               FALSE, vict, (void *) dmg, ch, TO_CHAR);
      act("&0&b&8$N springs from the ground, knocking $n down!&0 (&4$i&0)",
               FALSE, vict, (void *) dmg, ch, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
      damage(ch, vict, dmg, SKILL_SPRINGLEAP);
      if (AWAKE(vict) && IN_ROOM(ch) == IN_ROOM(vict)) {
         abort_casting(vict);
         GET_POS(vict) = POS_SITTING;
         GET_STANCE(vict) = STANCE_ALERT;
      }
      if (AWAKE(ch)) {
         GET_POS(ch) = POS_STANDING;
         GET_STANCE(ch) = FIGHTING(ch) ? STANCE_FIGHTING : STANCE_ALERT;
      }
   }

   improve_skill_offensively(ch, vict, SKILL_SPRINGLEAP);
} /* end springleap */

/* Throatcutting weapons: slashing, one-handed. */
#define WEAPON_CAN_THROATCUT(obj) \
   (IS_WEAPON_SLASHING(obj) && CAN_WEAR(obj, ITEM_WEAR_WIELD))
#define THROATCUT_DAMAGE DAM_SLASH

ACMD(do_throatcut)
{
   struct char_data *vict;
   struct effect eff;
   struct obj_data *weapon;
   int random, chance, percent, dam, expReduction, position;
   char buf1[255];
   char buf2[255];
   char buf3[255];
   char stop_buf1[255];
   char stop_buf2[255];
   bool skipcast = FALSE;

   if (GET_COOLDOWN(ch, CD_THROATCUT)) {
      send_to_char("You've drawn too much attention to yourself to throatcut now!\r\n", ch);
      return;
   }

   random = dice(1,6);

   if ((GET_LEVEL(ch) < LVL_IMMORT) && (GET_SKILL(ch, SKILL_THROATCUT) == 0)){
      send_to_char("You aren't skilled enough!\r\n", ch);
      return;
   }

   if (FIGHTING(ch)){
      send_to_char("You can't be stealthy enough to do this while fighting!\r\n",ch);
      return;
   }

   if (RIDING(ch)){
      send_to_char("Cut someone's throat while riding???   I don't think so!\r\n",ch);
      return;
   }

   one_argument(argument, buf);

   if ((!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, buf)))) && (!(vict == ch))) {
      send_to_char("Cut whose throat?\r\n", ch);
      return;
   }

   if (vict == ch){
      send_to_char("Hey, life's not that bad!\r\n", ch);
      return;
   }

   /* Got a weapon? Any weapon? */
   weapon = GET_EQ(ch, WEAR_WIELD);
   position = WEAR_WIELD;
   if (!weapon) {
       weapon = GET_EQ(ch, WEAR_WIELD2);
       position = WEAR_WIELD2;
    }
   if (!weapon) {
       weapon = GET_EQ(ch, WEAR_2HWIELD);
       position = WEAR_2HWIELD;
    }

   if (!weapon) {
      send_to_char("&0You need a one-handed slashing weapon to cut throats.&0\r\n", ch);
      return;
   }

   /* If wielding something unsuitable in first hand, use weapon in second hand */
   if (!WEAPON_CAN_THROATCUT(weapon) && GET_EQ(ch, WEAR_WIELD2)) {
      weapon = GET_EQ(ch, WEAR_WIELD2);
   }

   if (!WEAPON_CAN_THROATCUT(weapon)) {
      send_to_char("&0You need a one-handed slashing weapon to cut throats.&0\r\n", ch);
      return;
   }

   if (FIGHTING(vict)) {
      send_to_char("&0You can't cut the throat of a fighting person -- they're too alert!&0\r\n", ch);
      return;
   }

   if (!attack_ok(ch, vict, TRUE))
      return;

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   /* Can't throatcut dragons, nor mobs that are twice your size */
   if (GET_RACE(vict) == RACE_DRAGON)
   {
       send_to_char("Cut the throat... of a dragon... RIGHT!!!!!\r\n", ch);
       return;
   }
   else if ((GET_SIZE(vict) > GET_SIZE(ch) + 2) || (GET_SIZE(vict) < GET_SIZE(ch) - 2))
   {
      send_to_char("Maybe if you were close to the same size it would work!!\r\n", ch);
      return;
   }

   SET_COOLDOWN(ch, CD_THROATCUT, 3 MUD_HR);


   percent = dice(1,100);

   if ((MOB_FLAGGED(vict, MOB_AWARE) || EFF_FLAGGED(vict, EFF_AWARE)) &&
         AWAKE(vict) &&
         !EFF_FLAGGED(vict, EFF_MINOR_PARALYSIS) &&
         !EFF_FLAGGED(vict, EFF_MAJOR_PARALYSIS))
   {
      act("You notice $N sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
      act("$e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
      act("$n notices $N sneaking up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);
      attack(vict, ch);
      return;
   }

   chance = GET_SKILL(ch, SKILL_THROATCUT) - GET_LEVEL(vict) + 90;

 if (GET_LEVEL(ch) >= LVL_IMMORT)
      chance += 1000;

 if (!AWAKE(vict))
    chance += 1000; /* sleeping should always be a coup de grace */

   if (!CAN_SEE(vict, ch))
      chance += 15;

   switch(world[vict->in_room].sector_type)
   {
   case SECT_CITY:          chance += 15; break;
   case SECT_FIELD:         chance -= 10; break;
   case SECT_ROAD:          chance -=  5; break;
   case SECT_BEACH:         chance -= 10; break;
   case SECT_GRASSLANDS:    chance -= 10; break;
   case SECT_FOREST:        chance -= 15; break;
   case SECT_RUINS:         chance +=  5; break;
   case SECT_SWAMP:         chance -= 20; break;
   case SECT_SHALLOWS:      chance -= 50; break;
   case SECT_WATER:         chance -= 75; break;
   case SECT_AIR:           chance += 20; break;
   default:                 chance +=  0; break;
   }

   if ((!IS_NPC(vict)) && (GET_LEVEL(vict) >= LVL_IMMORT))
   {
      act("$N laughs out loud at your miserable attempt!&0", FALSE, ch, 0, vict, TO_CHAR);
      act("$n just tried to cut your throat. &0&6How cute!&0", FALSE, ch, 0, vict, TO_VICT);
      return;
   }

    /* you get tense when someone tries to cut your throat! */
   memset(&eff, 0, sizeof(eff));
   eff.type = SKILL_AWARE;
   eff.duration = 5;
   eff.modifier = 0;
   eff.location = APPLY_NONE;
   SET_FLAG(eff.flags, EFF_AWARE);
   effect_to_char(vict, &eff);

   if (chance > 95)
      {
         random = 7;
         chance = 95;
      }

   /* The moment of excitement! */
   if ( percent < chance )
   {
       if (damage_evasion(vict, ch, weapon, THROATCUT_DAMAGE)) {
            damage_evasion_message(ch, vict, weapon, THROATCUT_DAMAGE);
            set_fighting(vict, ch, TRUE);
            return;
       }
       /* Switch for dam %.   1 & 6: really goods, 2 & 5: decent, 3 & 4: common shaving nicks, 7 mega, 8 miss penalty */
       switch(random)
       {
          case 1:
          case 6:
             dam = (GET_MAX_HIT(vict) * 3) / 4;
             expReduction = (GET_EXP(vict) * 3) /4; /* rip same % exp from the mob... since they're doing less work! */

             sprintf(buf1, "&1&bYou nearly sever the head of $N with %s.&0", weapon->short_description);
             sprintf(buf2,   "&1&b$n nearly severs your head with %s!&0" , weapon->short_description);
             sprintf(buf3,   "&1&b$n nearly severs the head of $N with %s!&0", weapon->short_description);
             sprintf(stop_buf1, "Your profuse bleeding interrupts your chanting!");
             sprintf(stop_buf2, "$n stops chanting abruptly!");
             break;
          case 2:
          case 5:
             dam = GET_MAX_HIT(vict) / 4;
             expReduction = GET_EXP(vict) / 4; /* rip same % exp from the mob... since they're doing less work! */

             sprintf(buf1, "&1&bBlood splatters all over you as you cut into $N with %s.&0", weapon->short_description);
             sprintf(buf2, "&1&bBlood splatters all over $n as $e cuts into you with %s!&0", weapon->short_description);
             sprintf(buf3, "&1&bBlood splatters all over $n as $e dices $N with %s!&0", weapon->short_description);
             sprintf(stop_buf1, "Your chanting is interrupted by your coughing up blood!");
             sprintf(stop_buf2, "$n stops chanting abruptly!");
             break;
            case 3:
            case 4:
               dam = GET_MAX_HIT(vict) / 8;
               expReduction = GET_EXP(vict) / 8; /* rip same % exp from the mob... since they're doing less work! */

               sprintf( buf1,   "&1&b$N gasps as you slice into $S throat with %s.&0", weapon->short_description);
               sprintf(buf2,   "&1&bYou gasp with fear as $n slices into your throat with %s!&0", weapon->short_description);
               sprintf(buf3,   "&1&b$N looks horrified as $n slices into $S throat with %s!&0", weapon->short_description);
             sprintf(stop_buf1, "Your gasp abruptly interrupts your chanting!");
             sprintf(stop_buf2, "$n stops chanting abruptly!");
               break;
         case 7:
             dam = (GET_MAX_HIT(vict) * 9) / 10;
             expReduction = (GET_EXP(vict) * 9) / 10; /* rip same % exp from the mob... since they're doing less work! */

               sprintf(buf1,   "&1&bBlood spews everywhere as you nearly incapacitate $N with %s.&0", weapon->short_description);
               sprintf(buf2,   "&1&bBlood spews everywhere as $n nearly incapacitates you with %s!&0", weapon->short_description);
               sprintf(buf3,   "&1&bBlood spews everywhere as $n nearly incapacitates $N with %s!&0", weapon->short_description);
               sprintf(stop_buf1, "Your chanting is interrupted by your gurgling of blood!");
               sprintf(stop_buf2, "$n stops chanting abruptly!");
             break;
         default:
             dam = expReduction = 0;
             break;
         }
   }
   else
   {
      dam = 0;
      skipcast = TRUE;
      expReduction = 0; /* rip same % exp from the mob... since they're doing less work! */

      /* If we want silent misses for non-critical misses.. remove the act txt */
      sprintf(buf1, "&3&b$N jumps back before you have a chance to even get close!&0");
      sprintf(buf2, "&3&b$n just tried to cut your throat!&0");
      sprintf(buf3, "&3&b$n misses $N with $s throat cut!&0");
   }


   if (IS_NPC(vict))
      GET_EXP(vict) = MAX(1, GET_EXP(vict) - expReduction); /* make sure we don't have negative exp gain for ch */

   if (damage_amounts)
   {
      if (dam <=0)
         sprintf(buf, " (&1%d&0)", dam);
      else
         sprintf(buf, " (&3%d&0)", dam);

      strcat(buf1,buf);
      act(buf1, FALSE, ch, NULL, vict, TO_CHAR);

      strcat(buf2,buf);
      act(buf2, FALSE, ch, NULL, vict, TO_VICT);

      strcat(buf3,buf);
      act(buf3, FALSE, ch, NULL, vict, TO_NOTVICT);
   }
   else
   {
      act(buf1, FALSE, ch, NULL, vict, TO_CHAR);
      act(buf2, FALSE, ch, NULL, vict, TO_VICT);
      act(buf3, FALSE, ch, NULL, vict, TO_NOTVICT);
   }

   if (dam > 0) {
      memset(&eff, 0, sizeof(eff));
      eff.type = SKILL_THROATCUT;
      eff.duration = 2;
      eff.modifier = 0;
      eff.location = APPLY_NONE;
      SET_FLAG(eff.flags, EFF_HURT_THROAT);
      effect_to_char(vict, &eff);
   }

   GET_HIT(vict) -= dam;
   damage(ch, vict, 0, SKILL_THROATCUT);

   improve_skill_offensively(ch, vict, SKILL_THROATCUT);

   if (!skipcast && CASTING(vict)) {
         STOP_CASTING(vict);
         act(stop_buf1, FALSE, vict, 0, 0, TO_CHAR);
         act(stop_buf2, FALSE, vict, 0, 0, TO_ROOM);
   }
}

ACMD(do_disarm)
{
   int pos, ch_pos, chance, rnd_num, skl_bonus, move_cost;
   struct obj_data *obj, *ch_obj;                /* Object to disarm */
   struct char_data *tch, *vict = NULL;        /* Target */
   bool disarm_prim = TRUE;

   if (GET_SKILL(ch, SKILL_DISARM) == 0) {
      send_to_char("You don't know how to disarm.\r\n", ch);
      return;
   }

   /* Make sure we're fighting someone who'll be disarmed */
   if (!FIGHTING(ch)) {
      send_to_char("You can only disarm someone who you're fighting.\r\n", ch);
      return;
   }

   tch = FIGHTING(ch);

   /* Fighting yourself? Unlikely... but anyway: */
   if (ch == tch) {
      send_to_char("Try 'remove' instead.\r\n", ch);
      return;
   }

   move_cost = 11 - GET_SKILL(ch, SKILL_DISARM) / 6;

   /* Need mv to perform disarm */
   if (GET_MOVE(ch) < move_cost) {
      send_to_char("You don't have the energy to do that.\r\n", ch);
      return;
   }

   if (GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) ||
       GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY)) {
      send_to_char("Impossible!  You're already fumbling for your own weapon.\r\n", ch);
      return;
   }

   /* Can't disarm them if you can't see them */
   if (!CAN_SEE(ch, tch)) {
      send_to_char("It's pretty hard to disarm someone you can't even see...\r\n", ch);
      return;
   }

   /* Make sure disarmer is wielding a weapon. - might want to reconsider this later : Pergus */
   if ((ch_obj = GET_EQ(ch, WEAR_WIELD))) {
      ch_pos = WEAR_WIELD;
   } else if ((ch_obj = GET_EQ(ch, WEAR_2HWIELD))) {
      ch_pos = WEAR_2HWIELD;
   } else if ((ch_obj = GET_EQ(ch, WEAR_WIELD2))) {
      ch_pos = WEAR_WIELD2;
      disarm_prim = FALSE;
   } else {
      send_to_char("You must be wielding some kind of weapon.\r\n", ch);
      return;
   }

   /* Determine what item is to be wrested away */

   one_argument(argument, arg);
   if (!*arg) {
      /* Nothing specified: look for primary, then secondary weapon */
      if ((obj = GET_EQ(tch, WEAR_WIELD))) {
         pos = WEAR_WIELD;
      } else if ((obj = GET_EQ(tch, WEAR_WIELD2))) {
         pos = WEAR_WIELD2;
      } else if ((obj = GET_EQ(tch, WEAR_2HWIELD))) {
         pos = WEAR_2HWIELD;
      } else {
         act("$N isn't even wielding a weapon!", FALSE, ch, 0, tch, TO_CHAR);
         return;
      }
   } else if ((obj = GET_EQ(tch, WEAR_WIELD)) &&
         isname(arg, obj->name) &&    /* Same name */
         CAN_SEE_OBJ(ch, obj)) {          /* Can see it */
      pos = WEAR_WIELD;
   } else if ((obj = GET_EQ(tch, WEAR_WIELD2)) &&
         isname(arg, obj->name) &&    /* Same name */
         CAN_SEE_OBJ(ch, obj)) {          /* Can see it */
      pos = WEAR_WIELD2;
   } else if ((obj = GET_EQ(tch, WEAR_2HWIELD)) &&
         isname(arg, obj->name) &&    /* Same name */
         CAN_SEE_OBJ(ch, obj)) {          /* Can see it */
      pos = WEAR_2HWIELD;
   } else {
      act("$N doesn't seem to be wielding any such thing.", FALSE, ch, 0, tch, TO_CHAR);
      return;
   }

   /* Unlikely, but but just in case: */
   if (GET_OBJ_TYPE(obj) != ITEM_WEAPON) {
      send_to_char("You can only disarm weapons.\r\n", ch);
      return;
   }

   if (CONFUSED(ch)) {
      send_to_char("You're way too addle-headed to disarm anyone.\r\n", ch);
      return;
   }

   /* The attempt may take place! */


   /* Calculate the outcome, based on:
    *
    * - disarm skill
    * - dexterity
    * - level difference
    */

   chance = GET_SKILL(ch, SKILL_DISARM) +
      dex_app_skill[GET_DEX(ch)].p_pocket +
      (GET_LEVEL(ch) - GET_LEVEL(tch));

   /* 1 - 35 extra points to account for superlative dex or xp diff */
   skl_bonus = (int) ((chance - 69) / 2);

   if (skl_bonus > 0)
      chance += skl_bonus;

   chance = MAX(1, chance);

   /* has char tried to disarm within delay period?  if so, penalize them */
   if (GET_COOLDOWN(ch, CD_DISARM))
      chance -= 30;  /* 30% pts */

   rnd_num = number(1, chance);

   /*  ** Outcomes **

      A is the person disarming, and B is being disarmed:

      1-5    -- A drops weapon in miserably failed disarm attempt.
      6-25   -- A fumbles his weapon in failed disarm attempt.
      26-75  -- Nothing happens.
      76-95  -- A forces B to fumble weapon.
      96+    -- A knocks B's weapon to the ground.

   */

   /* if char tries to disarm again within 1->3 rds of violence, chance of success cut by a ~1/5 */
   SET_COOLDOWN(ch, CD_DISARM, number(1, 3) * PULSE_VIOLENCE);

   if (rnd_num <= 5) {
      act("$n fails $s disarming manuveur so badly, $e drops $s own weapon.", FALSE, ch, 0, tch, TO_NOTVICT);
      act("$n tries to disarm but drops $s weapon!", FALSE, ch, 0, tch, TO_VICT);
      act("You try to disarm $N but drop your $o instead!", FALSE, ch, ch_obj, tch, TO_CHAR);

      pos = ch_pos;
      obj = ch_obj;
      vict = ch;
   } else if (rnd_num <= 25) {
      act("$n flubs an attempt at disarming $N.", FALSE, ch, 0, tch, TO_NOTVICT);
      act("$e fumbles $s own weapon.", FALSE, ch, 0, 0, TO_NOTVICT);
      act("$n fumbles $s weapon while trying to disarm you.", FALSE, ch, 0, tch, TO_VICT);
      act("Oops!  You fumbled your $o!", FALSE, ch, ch_obj, 0, TO_CHAR);

      pos = ch_pos;
      obj = ch_obj;
      vict = ch;
   } else if (rnd_num >= 26 && rnd_num <= 75) {
      act("$n tries to disarm $N, but $E keeps a firm grip on $S weapon.", FALSE, ch, 0, tch, TO_NOTVICT);
      act("$n tries to disarm you, but you maintain your weapon.", FALSE, ch, 0, tch, TO_VICT);
      act("You try to disarm $N, but $E keeps hold of $S weapon.", FALSE, ch, 0, tch, TO_CHAR);
   } else if (rnd_num <= 95) {
      act("$n causes $N to fumble $S weapon.", FALSE, ch, 0, tch, TO_NOTVICT);
      act("$n causes you to fumble your weapon.", FALSE, ch, 0, tch, TO_VICT);
      act("You cause $N to fumble $S weapon.", FALSE, ch, 0, tch, TO_CHAR);

      vict = tch;
   } else {
      act("$n successfully knocks $N's weapon from $S grip!", FALSE, ch, 0, tch, TO_NOTVICT);
      act("$n forces $p out of your hands with a fancy disarming maneuver.", FALSE, ch, obj, tch, TO_VICT);
      if (CH_OUTSIDE(tch)) {
         act("You send $N's weapon crashing to the ground.", FALSE, ch, 0, tch, TO_CHAR);
      } else {
         act("You send $N's weapon crashing to the floor.", FALSE, ch, 0, tch, TO_CHAR);
      }

      vict = tch;
   }

   improve_skill_offensively(ch, tch, SKILL_DISARM);

   /* handle cases where either A or B loses hold of weapon */
   if (rnd_num <= 5 || rnd_num >= 96) {
      if ((OBJ_FLAGGED(obj, ITEM_NODROP))) { /* Cursed? */
         obj_to_char(unequip_char(vict, pos), vict);
         act("&3&b$p&3&b magically returns to your&0 &B&3inventory!&0",
               TRUE, vict, obj, NULL, TO_CHAR);
         act("&3&b$p&3&b magically returns to $s&0 &B&3inventory!&0",
               TRUE, vict, obj, NULL, TO_ROOM);
      } else {
         obj_to_room(unequip_char(vict, pos), vict->in_room);
         sprintf(buf, "%s lands on the %s.", obj->short_description,
               CH_OUTSIDE(vict) ? "ground" : "floor");
         act(buf, FALSE, vict, 0, 0, TO_ROOM);
         act(buf, FALSE, vict, 0, 0, TO_CHAR);
      }
      /* Move secondary hand weapon to primary hand. */
      if (pos == WEAR_WIELD && GET_EQ(vict, WEAR_WIELD2))
         equip_char(vict, unequip_char(vict, WEAR_WIELD2), WEAR_WIELD);

      /* delay is in units of "passes".  since a mob/pc can be disarmed */
      /* mutliple times, the delay count must be cumulative.  this count is decremented */
      /* in perform_violence(). */
      if (disarm_prim) {
         SET_COOLDOWN(vict, CD_DROPPED_PRIMARY, 2 * PULSE_VIOLENCE);
      } else {
         SET_COOLDOWN(vict, CD_DROPPED_SECONDARY, 2 * PULSE_VIOLENCE);
      }

      /* items ONLY have this set when a MOB is successfuly disarmed */
      /* the item lies on the ground with this bit set, so when someone */
      /* attempts to get it, do_get() can handle it appropriately */
      SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_WAS_DISARMED);

      /* we must remember who last held this item, so the MOB scanning for its */
      /* disarmed item knows THAT is it. */
      obj->last_to_hold = vict;

  } else if (rnd_num <= 25 || rnd_num >= 76) {
      obj_to_char(unequip_char(vict, pos), vict);

      /* Move secondary hand weapon to primary hand. */
      if (pos == WEAR_WIELD && GET_EQ(vict, WEAR_WIELD2))
         equip_char(vict, unequip_char(vict, WEAR_WIELD2), WEAR_WIELD);

      /* delay is in units of "passes".  since a mob/pc can be disarmed */
      /* mutliple times, the delay count must be cumulative.  this count is decremented */
      /* in perform_violence(). */
      if (disarm_prim) {
         SET_COOLDOWN(vict, CD_FUMBLING_PRIMARY, 2 * PULSE_VIOLENCE);
      } else {
         SET_COOLDOWN(vict, CD_FUMBLING_SECONDARY, 2 * PULSE_VIOLENCE);
      }

   }

   if (GET_LEVEL(ch) < LVL_IMMORT)
      alter_move(ch, move_cost);
   WAIT_STATE(ch, PULSE_VIOLENCE + 2);
}

ACMD(do_hitall)
{
   struct char_data *mob, *next_mob;
   byte percent;
   bool hit_all = FALSE, realvictims = FALSE, success = FALSE;

   if (!ch || ch->in_room == NOWHERE)
      return;

   if (subcmd == SCMD_TANTRUM) {
      if (!GET_SKILL(ch, SKILL_TANTRUM)) {
         send_to_char("You throw a hissy-fit, hoping someone will notice you.\r\n", ch);
         act("$n sobs to $mself loudly, soliciting attention.", TRUE, ch, 0, 0, TO_ROOM);
         return;
      }
      if (!EFF_FLAGGED(ch, EFF_BERSERK)) {
         send_to_char("You're not feeling quite up to throwing a tantrum right now.\r\n", ch);
         return;
      }
   }
   else if (!GET_SKILL(ch, SKILL_HITALL)) {
      send_to_char("You don't know how to.\r\n", ch);
      return;
   }
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
      send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
      return;
   }
   if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE)){
      send_to_char("Sorry, it's too cramped here for nasty maneuvers!\r\n", ch);
      return;
   }

   /* Find out whether to hit "all" or just aggressive monsters */
   one_argument(argument, arg);
   if (!str_cmp(arg, "all") || subcmd == SCMD_TANTRUM)
      hit_all = 1;

   /* Hit all aggressive monsters in room */

   percent = number(1, 131);
   WAIT_STATE(ch, PULSE_VIOLENCE);

   if (subcmd == SCMD_TANTRUM) {
      act("$n flings $s limbs around wildly, swiping at everything nearby!", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You throw an incensed tantrum, attacking all nearby!\r\n", ch);
      if (GET_SKILL(ch, SKILL_TANTRUM) >= percent)
         success = TRUE;
   }
   else {
      act("$n makes a concerted circular attack at everything nearby!", FALSE, ch, 0, 0, TO_NOTVICT);
      send_to_char("You spin in a circle, attempting to hit everything within range.\r\n", ch);
      if (GET_SKILL(ch, SKILL_HITALL) >= percent)
         success = TRUE;
   }


   for (mob = world[ch->in_room].people; mob; mob = next_mob) {
      next_mob = mob->next_in_room;

      /* Basic area attack check */
      if (!area_attack_target(ch, mob))
         continue;

      /* If I just entered plain "hitall", don't attack bystanders who aren't aggro to me */
      if (!battling_my_group(ch, mob) && !hit_all && !is_aggr_to(mob, ch))
         continue;

      if (!MOB_FLAGGED(mob, MOB_ILLUSORY))
         realvictims = TRUE;

      if (success) {
         if (damage_evasion(mob, ch, 0, physical_damtype(ch))) {
            damage_evasion_message(ch, mob, equipped_weapon(ch), physical_damtype(ch));
            set_fighting(mob, ch, TRUE);
         } else if (subcmd == SCMD_TANTRUM && number(0, 1))
            hit(ch, mob, SKILL_BAREHAND);
         else
            attack(ch, mob);
      }
   }

   if (realvictims)
      improve_skill(ch, subcmd == SCMD_TANTRUM ? SKILL_TANTRUM : SKILL_HITALL);
}

ACMD(do_corner)
{
   struct char_data *vict;
   int chance;

   if (!GET_SKILL(ch, SKILL_CORNER)) {
      send_to_char("You aren't skilled enough to corner an opponent!\r\n", ch);
      return;
   }

   one_argument(argument, arg);

   /* You can only corner the person you're fighting. */
   if (!*arg && FIGHTING(ch))
      vict = FIGHTING(ch);
   else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))) || vict != FIGHTING(ch)) {
      send_to_char("You have to be fighting someone to corner them!\r\n", ch);
      return;
   }

   if (CONFUSED(ch)) {
      send_to_char("You're far too confused to corner anyone.\r\n", ch);
      return;
   }

   if (ch->cornering) {
      if (ch->cornering->cornered_by == ch)
         ch->cornering->cornered_by = NULL;
      ch->cornering = NULL;
   }

   chance = GET_SKILL(ch, SKILL_CORNER);
   chance += 3 * dex_app[GET_DEX(ch)].reaction;
   chance += 10 * (GET_SIZE(ch) - GET_SIZE(vict));
   chance += (GET_LEVEL(ch) - GET_LEVEL(vict)) / 2;
   if (!CAN_SEE(vict, ch))
      chance *= 2;

   if (chance > number(1, 101)) {
      act("You stand in $N's way, cornering $M!", FALSE, ch, 0, vict, TO_CHAR);
      act("$n stands in your way, cornering you!", FALSE, ch, 0, vict, TO_VICT);
      act("$n stands in $N's way, cornering $M!", TRUE, ch, 0, vict, TO_NOTVICT);
      ch->cornering = vict;
      vict->cornered_by = ch;
   }
   else
      act("You attempt to corner $N, but $E evades you!", FALSE, ch, 0, vict, TO_CHAR);

   WAIT_STATE(ch, PULSE_VIOLENCE);
   improve_skill_offensively(ch, vict, SKILL_CORNER);
}


ACMD(do_peck)
{
   struct char_data *vict;
   int dam;

   if (!ch)
      return;

   if (GET_SKILL(ch, SKILL_PECK) <= 0) {
      send_to_char("How do you expect to do that?\r\n", ch);
      return;
   }

   one_argument(argument, arg);
   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      if (FIGHTING(ch))
         vict = FIGHTING(ch);
      else {
         send_to_char("Peck whom?\r\n", ch);
         return;
      }
   }
   if (ch == vict) {
      send_to_char("Ouch, that hurts!\r\n", ch);
      return;
   }

   /* Is this attack allowed? */
   if (!attack_ok(ch, vict, TRUE))
      return;

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   WAIT_STATE(ch, PULSE_VIOLENCE);

   /* If attacking someone else, check switch skill. */
   if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
      return;

   /* Determine the damage amount.   0 is a miss. */
   if (number(0, 101) > GET_SKILL(ch, SKILL_PECK))
      dam = 0;
   else if (damage_evasion(vict, ch, 0, DAM_PIERCE)) {
       damage_evasion_message(ch, vict, 0, DAM_PIERCE);
       set_fighting(vict, ch, TRUE);
       return;
   } else
      dam = number(GET_SKILL(ch, SKILL_PECK), GET_LEVEL(ch));

   damage(ch, vict,
         dam_suscept_adjust(ch, vict, 0, dam, DAM_PIERCE),
         SKILL_PECK);
   improve_skill_offensively(ch, vict, SKILL_PECK);
}

ACMD(do_claw)
{
   struct char_data *vict;
   int dam;

   if (!ch)
      return;

   if (GET_SKILL(ch, SKILL_CLAW) <= 0) {
      send_to_char("Grow some longer fingernails first!\r\n", ch);
      return;
   }

   one_argument(argument, arg);
   if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      if (FIGHTING(ch))
         vict = FIGHTING(ch);
      else {
         send_to_char("Claw whom?\r\n", ch);
         return;
      }
   }
   if (ch == vict) {
      send_to_char("Ouch, that hurts!\r\n", ch);
      return;
   }

   /* Can we allow this attack to occur? */
   if (!attack_ok(ch, vict, TRUE))
      return;

   if (CONFUSED(ch))
       vict = random_attack_target(ch, vict, TRUE);

   WAIT_STATE(ch, PULSE_VIOLENCE);

   /* If attacking someone else, check skill in switch. */
   if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
      return;

   /* Determine damage amount. */
   if (number(0, 101) > GET_SKILL(ch, SKILL_CLAW))
      dam = 0;
   else if (damage_evasion(vict, ch, 0, DAM_SLASH)) {
       damage_evasion_message(ch, vict, 0, DAM_SLASH);
       set_fighting(vict, ch, TRUE);
       return;
   } else
      dam = number(GET_SKILL(ch, SKILL_CLAW), GET_LEVEL(ch));

   damage(ch, vict,
         dam_suscept_adjust(ch, vict, 0, dam, DAM_SLASH),
         SKILL_CLAW);
   improve_skill_offensively(ch, vict, SKILL_CLAW);
}

ACMD(do_electrify)
{
   if (!ch || ch->in_room == NOWHERE)
      return;

   if (GET_SKILL(ch, SKILL_ELECTRIFY) <= 0) {
      send_to_char("Good luck with that one!\r\n", ch);
      return;
   }

   if (GET_SKILL(ch, SKILL_ELECTRIFY) > number(0, 101))
      mag_area(GET_SKILL(ch, SKILL_ELECTRIFY), ch, SKILL_ELECTRIFY, SAVING_BREATH);
   else {
      if (IS_WATER(ch->in_room))
         send_to_char("The water around you sizzles, but you are unable to gather any power...\r\n", ch);
      else
         send_to_char("The air around you crackles, but you are unable to gather any power...\r\n", ch);
      act("A quick spike of electricity runs across $n's skin.", TRUE, ch, 0, 0, TO_ROOM);
   }

   improve_skill(ch, SKILL_ELECTRIFY);
   WAIT_STATE(ch, PULSE_VIOLENCE);
}


void start_berserking(struct char_data *ch) {
   struct effect eff;

   memset(&eff, 0, sizeof(eff));
   eff.type = SKILL_BERSERK;
   eff.duration = 1000; /* arbitrarily long time */
   eff.modifier = 0;
   eff.location = APPLY_NONE;
   SET_FLAG(eff.flags, EFF_BERSERK);
   effect_to_char(ch, &eff);
   check_regen_rates(ch);
}

void stop_berserking(struct char_data *ch) {
   effect_from_char(ch, SKILL_BERSERK);
   effect_from_char(ch, CHANT_SPIRIT_WOLF);
   effect_from_char(ch, CHANT_SPIRIT_BEAR);
   effect_from_char(ch, CHANT_INTERMINABLE_WRATH);
   GET_RAGE(ch) = 0;
}

ACMD(do_berserk)
{
   if (!GET_SKILL(ch, SKILL_BERSERK)) {
      send_to_char("You flail your arms about, acting like a crazy person.\r\n", ch);
      act("$n goes berserk, thrashing about the area.", FALSE, ch, 0, 0, TO_ROOM);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're already out of control!\r\n", ch);
      return;
   }

   if (GET_RAGE(ch) < RAGE_ANGRY) {
      send_to_char("You're not angry enough yet!\r\n", ch);
      return;
   }

   send_to_char("You feel your blood begin to boil, and your self-control starts to slip...\r\n", ch);
   act("$n's eyes flash and anger clouds $s face.", TRUE, ch, 0, 0, TO_ROOM);

   start_berserking(ch);
}


/*
 * Be careful when calling do_stomp manually (i.e., not from the command
 * interpreter.   If the cmd number is wrong, and the command gets passed
 * to do_action, the game may crash.
 */
ACMD(do_stomp)
{
   struct char_data *tch, *next_tch;
   bool real_victims = FALSE;

   extern ACMD(do_action);

   if (!GET_SKILL(ch, SKILL_GROUND_SHAKER) ||
         !EFF_FLAGGED(ch, EFF_SPIRIT_BEAR) ||
         !EFF_FLAGGED(ch, EFF_BERSERK)) {
      do_action(ch, argument, cmd, subcmd);
      return;
   }

   if (CH_INDOORS(ch)) {
      send_to_char("You MUST be crazy, trying to do that in here!\r\n", ch);
      return;
   }

   if (!QUAKABLE(IN_ROOM(ch))) {
      send_to_char("There's no ground to stomp on here!\r\n", ch);
      return;
   }

   send_to_char("&8&3You stomp one foot on the ground heavily, shaking the earth!&0\r\n", ch);
   act("&8&3$n crashes a foot into the ground, causing it to crack around $m...&0", TRUE, ch, 0, 0, TO_ROOM);

   for (tch = world[IN_ROOM(ch)].people; tch; tch = next_tch) {
      next_tch = tch->next_in_room;

      /* Basic area attack check */
      if (!area_attack_target(ch, tch))
         continue;

      /* Can't harm flying folks with this skill */
      if (GET_POS(tch) == POS_FLYING)
         continue;

      if (!damage_evasion(tch, ch, 0, DAM_CRUSH)) {
          if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
             real_victims = TRUE;

          if (GET_DEX(tch) < number(0, 100))
             damage(ch, tch,
                   dam_suscept_adjust(ch, tch, 0,
                      number(50, GET_SKILL(ch, SKILL_GROUND_SHAKER)),
                      DAM_CRUSH),
                   SKILL_GROUND_SHAKER);
          else if (GET_STR(tch) < number(0, 100)) {
             if (GET_POS(tch) > POS_SITTING) {
                damage(ch, tch, 0, SKILL_GROUND_SHAKER);
                if (IN_ROOM(ch) == IN_ROOM(tch))
                   alter_pos(tch, POS_KNEELING, STANCE_ALERT);
                WAIT_STATE(ch, PULSE_VIOLENCE);
             }
          }
      } else {
         set_fighting(tch, ch, TRUE);
      }
   }

   if (real_victims)
      improve_skill(ch, SKILL_GROUND_SHAKER);
   WAIT_STATE(ch, PULSE_VIOLENCE * 3);
}

/***************************************************************************
 * $Log: act.offensive.c,v $
 * Revision 1.224  2010/06/05 05:26:58  mud
 * Fix damage colors on springleap.
 *
 * Revision 1.223  2009/08/02 20:19:00  myc
 * Eye gouge now applies a -hr modifier.
 *
 * Revision 1.222  2009/07/18 01:17:23  myc
 * Immobilized characters can't kick or springleap.
 *
 * Revision 1.221  2009/06/11 13:36:05  myc
 * When throatcut is successful, apply an injured throat effect
 * which hinders the victim's casting ability.
 *
 * Revision 1.220  2009/03/20 06:08:18  myc
 * Make stomp and ground shaker only work in rooms where earthquake
 * works.
 *
 * Revision 1.219  2009/03/15 23:18:08  jps
 * Make it so you need a one-handed slashing weapon to throatcut.
 *
 * Revision 1.218  2009/03/15 23:00:15  jps
 * Add damage amounts to springleap messages.
 *
 * Revision 1.217  2009/03/15 22:39:42  jps
 * Paralyzed folks can't dodge backstabs and throatcuts
 *
 * Revision 1.216  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.215  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.214  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.213  2009/03/07 22:28:08  jps
 * Add effect flag remote_aggr, which keeps your aggressive action from
 * removing things like invis. Useful for those spells that keep on hurting.
 *
 * Revision 1.212  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.211  2009/02/18 19:48:08  myc
 * Swap order of damage and alter_pos; should fix bash bug...
 *
 * Revision 1.210  2009/01/25 02:53:33  myc
 * Fix typo in springleap.
 *
 * Revision 1.209  2009/01/19 09:25:23  myc
 * Removed MOB_PET flag.
 *
 * Revision 1.208  2009/01/17 00:28:02  myc
 * Fix use of uninitialized variables in do_bash and do_throatcut.
 *
 * Revision 1.207  2008/09/27 03:54:47  jps
 * Fix variable initialization in group retreat.
 *
 * Revision 1.206  2008/09/27 03:52:23  jps
 * Debug code in group retreat.
 *
 * Revision 1.205  2008/09/27 03:48:20  jps
 * Cause followers to participate in group retreat.
 *
 * Revision 1.204  2008/09/24 17:00:15  myc
 * Fix typo in peace message for kick.
 *
 * Revision 1.203  2008/09/21 21:04:20  jps
 * Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
 *
 * Revision 1.202  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.201  2008/09/20 07:27:45  jps
 * set_fighting takes a 3rd parameter, reciprocate, which will set the attackee fighting
 * the attacker if true.
 *
 * Revision 1.200  2008/09/14 04:34:30  jps
 * Set folks fighting even if the initial attack was completely ineffective.
 *
 * Revision 1.199  2008/09/14 03:49:32  jps
 * Don't allow fleeing when paralyzed
 *
 * Revision 1.198  2008/09/14 02:08:01  jps
 * Use standardized area attack targetting
 *
 * Revision 1.197  2008/09/14 01:47:58  jps
 * hitall will tend to include folks who are in battle with your group.
 * It will not include nohassle folks (unless they're already involved).
 *
 * Revision 1.196  2008/09/13 16:34:44  jps
 * Moved do_order to act.comm.c.
 *
 * Revision 1.195  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.194  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.193  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.192  2008/08/24 19:29:11  jps
 * Apply damage susceptibility reductions to the various physical attack skills.
 *
 * Revision 1.191  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.190  2008/08/10 03:10:26  jps
 * Don't allow illusionists to backstab someone who is already in battle.
 *
 * Revision 1.189  2008/08/09 18:16:21  jps
 * Got rid of weapon-slinging.
 *
 * Revision 1.188  2008/07/27 06:39:18  jps
 * Make sure random_attack_target doesn't return NULL.
 *
 * Revision 1.187  2008/07/13 17:23:08  jps
 * When you go to bash a creature who's already on the ground, you
 * get notified of that. Instead of falling down yourself. Also, when
 * you try to bash a no-bash creature, you will get a notification
 * of that. You won't fall down, but you will be lagged.
 *
 * Revision 1.186  2008/06/21 17:29:43  jps
 * Typo fixes.
 *
 * Revision 1.185  2008/06/21 06:30:43  jps
 * Typo and formatting fixes.
 *
 * Revision 1.184  2008/06/05 02:07:43  myc
 * Fixed two bugs in do_roar.  Changing objet flags to use flagvectors.
 *
 * Revision 1.183  2008/05/25 21:00:22  myc
 * Fix tantrum/hitall to improve skill.
 *
 * Revision 1.182  2008/05/25 18:09:47  myc
 * Roar message missing newline.
 *
 * Revision 1.181  2008/05/18 20:46:02  jps
 * Cause GLORY to be removed when you're offensive, just like invis.
 *
 * Revision 1.180  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.179  2008/05/18 02:33:56  jps
 * Provide feedback when you attempt to switch without the skill.
 *
 * Revision 1.178  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.177  2008/05/14 05:31:37  jps
 * Change "assist self" message.
 *
 * Revision 1.176  2008/05/14 05:11:42  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.175  2008/05/11 05:56:04  jps
 * Changed slow_death. Calling alter_pos for position changes.
 *
 * Revision 1.174  2008/05/10 16:20:08  jps
 * Used EVASIONCLR for many evasion messages.
 * Fixed evading kicks.
 *
 * Revision 1.173  2008/04/14 02:32:31  jps
 * Consolidate the loss of hiddenness when being violent into a single
 * function.  It also removes glory.
 *
 * Revision 1.172  2008/04/13 20:53:50  jps
 * When you're confused, your offensive acts will tend to be
 * directed to random targets.
 *
 * Revision 1.171  2008/04/12 21:13:18  jps
 * Using new header file magic.h.
 *
 * Revision 1.170  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.169  2008/04/05 05:04:24  myc
 * Turned off slow_death log message.
 *
 * Revision 1.168  2008/04/04 21:42:28  jps
 * Make imms immune to gouging.
 *
 * Revision 1.167  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.166  2008/04/02 19:42:15  myc
 * Disarm move cost varies with skill now.
 *
 * Revision 1.165  2008/04/02 03:24:44  myc
 * Cleaned up death code.  Increased bash lag.
 *
 * Revision 1.164  2008/03/30 16:04:21  jps
 * Cancel other events when you're about to die.  This may prevent
 * those 'double deaths' from recurring.
 *
 * Revision 1.163  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.162  2008/03/27 22:34:44  jps
 * Return backstab cooldown to 6 seconds.
 *
 * Revision 1.161  2008/03/26 18:14:55  jps
 * Passing attacker and weapon into damage_evasion() so that
 * ethereal creatures may be vulnerable to blessed physical
 * attacks.
 *
 * Revision 1.160  2008/03/25 21:58:59  jps
 * Replaced dam_earth with dam_crush.
 *
 * Revision 1.159  2008/03/25 05:31:28  jps
 * Including chars.h.
 *
 * Revision 1.158  2008/03/25 04:50:08  jps
 * Do immunity checks for the appropriate type of damage in these
 * various skills.
 *
 * Revision 1.157  2008/03/24 08:07:01  jps
 * Use CD_ constants when setting cooldowns for backstab and gouge.
 *
 * Revision 1.156  2008/03/19 18:43:58  myc
 * Added newlines to the bash messages for too big/small.  Fixed hitall
 * and tantrum to not hit when attack_ok returns false.
 *
 * Revision 1.155  2008/03/18 06:16:29  jps
 * Removing unused function prototypes.
 *
 * Revision 1.154  2008/03/17 15:31:27  myc
 * Lowered cooldown for throatcut to about what it was before.
 *
 * Revision 1.153  2008/03/11 19:50:55  myc
 * Make maul and ground shaker require spirit of the bear, battle howl
 * require spirit of the wolf, and tantrum have a random chance to hit
 * with a weapon.
 *
 * Revision 1.152  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.151  2008/03/10 18:01:17  myc
 * Added new berserker skills: battle howl, maul, tantrum, and ground shaker.
 * Battle howl is a subcommand of roar, maul is a subcommand of bash, and
 * tantrum is a subcommand of hitall.  Also made bodyslam a subcommand of
 * bash.
 *
 * Revision 1.150  2008/03/09 18:11:05  jps
 * perform_move may be misdirected now.
 *
 * Revision 1.149  2008/03/08 23:31:30  jps
 * Stop using ANIMATED flag as a synonym for CHARM
 *
 * Revision 1.148  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.147  2008/02/11 21:04:01  myc
 * Make the breath command skip other mobs if cast by a mob (like area
 * spells).
 *
 * Revision 1.146  2008/02/09 21:07:50  myc
 * Removing plr/mob casting flags and using an event flag instead.
 *
 * Revision 1.145  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.144  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.143  2008/01/29 18:01:02  myc
 * Gods won't flee when roared at if they have nohassle on.
 *
 * Revision 1.142  2008/01/29 01:43:45  jps
 * Adjust failure-to-flee message.
 *
 * Revision 1.141  2008/01/27 21:09:12  myc
 * Initial implementation of berserk.  Prevent fleeing while berserking.
 *
 * Revision 1.140  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.139  2008/01/27 00:46:29  jps
 * Allow breath attacks, unless reanimated.
 *
 * Revision 1.138  2008/01/27 00:43:14  jps
 * Stop redirecting "breathe" command to do_action.  There is no
 * such social.
 *
 * Revision 1.137  2008/01/26 12:28:05  jps
 * Using improve_skill_offensively() so that your skills won't improve
 * if used against illusions.
 *
 * Revision 1.136  2008/01/25 21:05:45  myc
 * Added attack() as a macro alias for hit() with fewer arguments.
 * hit2() no longer exists, so updated do_backstab() to compensate.
 * Renamed monk_weight_pen() to monk_weight_penalty().
 *
 * Revision 1.135  2008/01/23 16:42:06  jps
 * Changed the duration of gouge-blindness to 2-4 hours.
 *
 * Revision 1.134  2008/01/23 05:31:50  jps
 * Allow xp gain for instant kill.
 *
 * Revision 1.133  2008/01/23 04:45:43  jps
 * Use alter_hit to kill people with quickdeath.  Add some messages
 * about instant kill.  Use the delay from instant kill to prevent
 * another instant kill.
 *
 * Revision 1.132  2008/01/22 15:11:38  jps
 * Stopped quickdeath() from sending messages after the kill, thus
 * crashing the mud.
 *
 * Revision 1.131  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.130  2008/01/09 07:26:49  jps
 * Better can't-backstab feedback when you're fighting.
 *
 * Revision 1.129  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.128  2007/11/18 16:51:55  myc
 * Fixing instakill to improve skill even if it fails.
 *
 * Revision 1.127  2007/10/25 20:38:33  myc
 * Make SENTINEL mobs more difficult to scare with roar.
 *
 * Revision 1.126  2007/10/20 19:01:41  myc
 * Fixed a typo.
 *
 * Revision 1.125  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.124  2007/10/13 20:12:49  myc
 * Roar now wakes up sleeping people.
 *
 * Revision 1.123  2007/10/09 02:42:34  myc
 * Roar command shouldn't work on you if you're sleeping or incapacitated.
 *
 * Revision 1.122  2007/10/02 02:52:27  myc
 * Disengage now works as abort when casting.
 *
 * Revision 1.121  2007/09/30 19:54:11  myc
 * Make roar skill not usable in peaced rooms.
 *
 * Revision 1.120  2007/09/15 05:03:46  myc
 * AFF_DROPPED_PRIM and AFF_DROPPED_SECOND were incorrectly marked as
 * Aff 1 flags.  They should have been Aff 2 flags.
 *
 * Revision 1.119  2007/09/12 19:28:56  myc
 * Allow springleap for POS_RESTING.
 *
 * Revision 1.118  2007/09/11 16:34:24  myc
 * Moved switch skill logic into switch_ok function.
 * Cleaned up code for breathe command.
 * Cleaned up code for roar and sweep.
 * Added peck, claw, and electrify skills for use by druid shapechanges.
 *
 * Revision 1.116  2007/09/02 22:54:55  jps
 * Minor typo fixes.
 *
 * Revision 1.115  2007/08/23 01:34:36  jps
 * Changed target-not-here message for eye gouge. Also made
 * it not miss for incapacitated victims.
 *
 * Revision 1.114  2007/08/22 22:46:37  jps
 * Flee attempts accidentally reduced from 6 to 1, making it
 * really hard to flee: fixed.
 *
 * Revision 1.113  2007/08/17 03:49:24  myc
 * Messages for retreat/group retreat were being sent to wrong room (after
 * the character had already moved).  Also fixed typo in springleap.
 *
 * Revision 1.112  2007/08/16 10:38:50  jps
 * Check whether someone can bodyslam by defining which races CAN bodyslam,
 * rather than which CAN'T. The previous method would have granted it to
 * any new races by default.
 *
 * Revision 1.111  2007/08/15 20:47:23  myc
 * Corner skill takes level into account now.
 *
 * Revision 1.110  2007/08/14 22:43:07  myc
 * Adding 'corner' skill, which lets you prevent your opponent from
 * fleeing.
 *
 * Revision 1.109  2007/08/05 22:19:17  myc
 * Fixed up springleap skill for monks.
 *
 * Revision 1.108  2007/08/05 20:21:51  myc
 * Added retreat and group retreat skills.
 * Fixed bug in disarm.
 *
 * Revision 1.107  2007/08/04 22:26:11  jps
 * Make sure there's a room message when someone tries to flee but fails.
 *
 * Revision 1.106  2007/08/04 21:44:20  jps
 * Make gouge damage dependent on proficiency in the skill.
 *
 * Revision 1.105  2007/08/04 14:40:35  myc
 * Bug in flee sending too many messages.
 *
 * Revision 1.104  2007/08/03 22:00:11  myc
 * Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.103  2007/08/03 03:51:44  myc
 * check_pk is now attack_ok, and covers many more cases than before,
 * including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
 * offensive attacks now use attack_ok to determine whether an attack is
 * allowed.
 *
 * Revision 1.102  2007/07/31 08:40:00  jps
 * Fix near-miss backstab with weapon in off hand. Also fix probability
 * of backstabbing so it depends on skill vs. victim level, rather
 * than merely skill.
 *
 * Revision 1.101  2007/07/31 00:43:00  jps
 * Fix typos in throat cut.
 *
 * Revision 1.100  2007/07/24 01:24:55  myc
 * Eye gouge no longer improves on blinded or noblind mobs.
 *
 * Revision 1.99  2007/07/18 23:54:07  jps
 * Messages will reflect the actual weapon used when someone backstabs
 * with a piercing weapon in their off hand.
 *
 * Revision 1.98  2007/07/18 21:02:51  jps
 * You can now disarm while wielding a two-handed weapon. You can also
 * disarm someone who is wielding a two-handed weapon. The feedback
 * for fumbling a cursed weapon while attempting to disarm someone
 * is fixed.
 *
 * Revision 1.97  2007/07/18 17:07:56  jps
 * Fix feedback for fumbling your cursed weapon when trying to disarm someone.
 *
 * Revision 1.96  2007/06/02 22:23:26  jps
 * Fix unequipping of weapon when slinging during throatcut.
 *
 * Revision 1.95  2007/05/28 06:17:58  jps
 * Weapon goes to inventory when slung/retained due to curse.
 *
 * Revision 1.94  2007/05/28 06:14:31  jps
 * Fix weapon tossing during throatcut. Allow backstabbing or throat cut with
 * piercing weapons that are wielded secondary or two-handed.
 *
 * Revision 1.93  2007/05/21 01:45:15  myc
 * Fixed throatcut for piercing weapons.
 *
 * Revision 1.92  2007/05/21 00:14:08  myc
 * Fixing backstab to work with piercing weapons only.
 *
 * Revision 1.91  2007/05/17 22:21:23  myc
 * Replaced several static-string to_char act()s with send_to_char()s.
 * Fixed newline issues with several more send_to_char()s.
 *
 * Revision 1.90  2007/05/11 22:01:22  myc
 * New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
 * complicated skill.  :P  Fixed cure blind's logic, and made it support
 * eye gouge too.
 *
 * Revision 1.89  2007/04/19 04:50:18  myc
 * Created macros for checking weapon types.
 *
 * Revision 1.88  2007/04/19 00:53:54  jps
 * Create macros for stopping spellcasting.
 *
 * Revision 1.87  2007/04/18 00:24:25  myc
 * Roar doesn't work when you're silenced now.
 *
 * Revision 1.86  2007/03/31 14:45:00  myc
 * Another try and making backstab not crash the mud.  Moved the check
 * to see if the mob is dead above the aware affection.
 *
 * Revision 1.85  2007/03/27 04:27:05  myc
 * Fixed a typo in do_kill.  Prevented backstab from attempting a second
 * backstab if the first killed the victim.  Fixed typo in bash.  Fixed
 * shapechange test in kick.  Made hitall all not hit followers.
 *
 * Revision 1.84  2007/01/27 19:55:25  dce
 * Missed a typo in backstab.
 *
 * Revision 1.83  2007/01/27 15:47:50  dce
 * Updated failed message for backstab.
 *
 * Revision 1.82  2007/01/20 03:56:36  dce
 * Moved aff3 for backstab.
 *
 * Revision 1.81  2007/01/06 04:16:44  dce
 * Modified backstab to take into account the aware flag
 * and aff3_aware flags...making it more difficult to
 * backstab if they exist.
 *
 * Revision 1.80  2006/12/19 19:57:57  myc
 * Mobs dying from suffering in slow_death() now are set back to mortally
 * wounded, so they can be attacked by players, so the players get the exp.
 *
 * Revision 1.79  2006/11/24 05:07:40  jps
 * Fix bash so mobs can bash players
 *
 * Revision 1.78  2006/11/20 06:44:26  jps
 * Fix creatures dying of bloodloss as you're fighting them.
 *
 * Revision 1.77  2006/11/18 21:00:28  jps
 * Reworked disarm skill and disarmed-weapon retrieval.
 *
 * Revision 1.76  2006/11/14 19:14:38  jps
 * Fix bug so players really can't bash players.
 *
 * Revision 1.75  2006/11/08 09:16:04  jps
 * Fixed some loose-lose typos.
 *
 * Revision 1.74  2006/11/08 07:55:17  jps
 * Change verbal instances of "breath" to "breathe"
 *
 * Revision 1.73  2006/11/07 14:14:52  jps
 * It is now impossible to throatcut AWARE mobs. Also if you throatcut
 * an ordinary mob, it properly gets its temporary AWAREness.
 *
 * Revision 1.72  2006/07/20 07:43:48  cjd
 * Typo fixes.
 *
 * Revision 1.71  2006/04/26 18:46:24  rls
 * *** empty log message ***
 *
 * Revision 1.70  2006/04/26 04:28:30  rls
 * Throatcut error
 *
 * Revision 1.69  2006/04/20 17:55:30  rls
 * Adjusted awareness for TC and Backstab.
 *
 * Revision 1.68  2006/04/11 15:29:57  rls
 * Forgot right level value for immortal in shapechange check for breath.
 *
 * Revision 1.67  2006/04/11 15:25:25  rls
 * tagged breath with shapechanged and mortal check
 *
 * Revision 1.66  2005/08/20 16:18:11  cjd
 * instantkill was still to frequent, reworked it again to make
 * it happen less often.
 *
 * Revision 1.65  2005/08/05 04:43:22  jwk
 * Fixed the Breath problem... apparently whomever coded it didn't realize
 * arrays always start with 0 not 1... fixed it so the messages line up
 *
 * Revision 1.64  2005/08/02 22:19:52  cjd
 * adjsuted instantkill so that it doesn't happen as often. also added
 * a check for DEX into it and made the delay reduce based on the PC's
 * level.
 *
 * Revision 1.63  2005/02/18 03:12:53  rls
 * Fixed crash bug w/ breath and no args or invalid arg.
 * Now displays appropriate syntax on failure.
 * Modifications to backstab/throat/instakill.
 *
 * Revision 1.62  2003/06/28 01:00:17  jjl
 * Added a bit of delay to backstab.
 *
 * Revision 1.61  2003/06/23 03:21:44  jjl
 * Updated backstab to ignore AWARE if the mob is fighting,
 * Allowing you to backstab effectively in combat.
 *
 * Revision 1.60  2003/06/23 02:08:10  jjl
 * Removed level check for circle like backstabbing
 *
 * Revision 1.59  2003/06/21 03:43:03  jjl
 * *** empty log message ***
 *
 * Revision 1.58  2003/06/21 01:16:28  jjl
 * Changed delay - felt way too long.
 *
 * Revision 1.57  2003/06/21 01:01:08  jjl
 * Modified rogues.  Removed circle - backstab is now circlicious.  Updated
 * damage on backstab to give a little more pop.  Throatcut is now a once a day.
 *
 * Revision 1.56  2003/06/18 14:55:36  rls
 * Added is_npc check to throat so PC victims aren't losing levels upon being throated with pk on.
 *
 * Revision 1.55  2003/04/16 02:00:22  jjl
 * Added skill timers for Zzur.  They don't save to file, so they were a
 * quickie.
 *
 * Revision 1.54  2003/01/04 08:19:06  jjl
 * Fixed up bash and kick; they should behave a little more like Pergy intended now.
 *
 * Revision 1.53  2002/12/28 21:56:30  jjl
 * Added delay for punk-mobs standing up and fleeing
 *
 * Revision 1.52  2002/12/04 08:02:40  rls
 * Fixed kick so switched imms and pk toggled charmies could kick
 *
 * Revision 1.51  2002/12/02 03:19:21  rls
 * commented out testing message in throatcut
 *
 * Revision 1.50  2002/11/30 22:50:32  rls
 * Throatcut update
 *
 * Revision 1.49  2002/11/24 04:44:55  rls
 * Forgot to comment out testing message... whoopsies
 *
 * Revision 1.48  2002/11/24 04:39:50  rls
 * Rewrite of Throatcut to perferm more often, but with less effectiveness and exp hinderance.
 *
 * Revision 1.47  2002/09/21 02:38:38  jjl
 * Quickie fix to make necros not be able to order dragon skeletons to breathe.
 *
 * Revision 1.46  2002/09/15 04:32:47  jjl
 * hitall with no arguments should now actually hit everything fighting you on a success
 *
 * Revision 1.45  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.44  2002/07/16 19:30:58  rls
 * *** empty log message ***
 *
 * Revision 1.43  2002/03/30 13:09:05  dce
 * Added a pluse violence to the rescuer so you couldn't
 * do 50 rescues at once. You should only be able to do
 * one a round.
 *
 * Revision 1.42  2002/02/20 02:32:53  rls
 * Fixed "You switch opponents" line for success and "You are doing the best
 * can" msg when killing same opponent.
 *
 * Revision 1.41  2002/02/19 02:06:30  dce
 * Added a carriage return to 'You panic and flee' message.
 *
 * Revision 1.40  2002/02/18 02:25:07  dce
 * Moved the POS calls in bash and bodyslam to occur after
 * the damage calls. Also made size failed bashes and bodyslams
 * cause battle to begin.
 *
 * Revision 1.39  2002/02/07 00:48:47  dce
 * Modified the bash code so Paladins and Anti-Paladins do not
 * get the 20% bonus when trying to bash if they do not have
 * a shield.
 *
 * Revision 1.38  2001/12/13 00:37:50  dce
 * In an attempt to fix the blob bug I modified bash and bodyslam
 * I added GET_POS1() = POS1_SITTING and I added an update_pos
 * for the victim.
 *
 * Revision 1.37  2001/12/12 02:45:03  dce
 * Fixed Throatcut so it doesn't cause so much damage
 * for a failed attempt.
 *
 * Revision 1.36  2001/12/10 22:36:49  dce
 * Fixed throatcut from adding hitting points to a player
 * when failing a throatcut
 *
 * Revision 1.35  2001/12/07 03:34:48  dce
 * Toned down throatcut. Wasn't check to see if mobs were aware.
 * Success was too easy, because everything was based on Hubis's
 * 36 levels or whatever.
 *
 * Revision 1.34  2001/10/10 21:04:02  rjd
 * Kick command is checked against the switch skill if a person attempts to kick while already fighting.
 *
 * Revision 1.33  2001/05/13 16:15:58  dce
 * Fixed a bug where somethings wouldn't save when a player
 * died and exitied menu option 0 rather than menu option 1.
 * Fixed a bug in slow death...it was a null pointer type
 * of deal.
 *
 * Revision 1.32  2001/05/12 13:56:20  dce
 * Adjusted backstab so that players now at least have a chance
 * of getting a backstab. The old chance was based on Hubis's
 * level scheme and therefore making it impossible to backstab
 * once you passed level 50.
 *
 * Revision 1.31  2001/03/10 18:45:33  dce
 * Changed do_return function to pass a subcommand of 1.
 * This way I can make it so players can't use the return command.
 *
 * Revision 1.30  2001/03/07 01:45:18  dce
 * Added checks so that players can not kill shapechanged players and
 * vise versa. Hopefully I didn't miss any...
 *
 * Revision 1.29  2001/03/04 17:50:23  dce
 * Added a bunch of checks to prevey skills for being used in
 * peaceful rooms.
 *
 * Revision 1.28  2000/12/06 00:08:55  mtp
 * fixed throatcut?
 *
 * Revision 1.27  2000/11/20 03:55:57  rsd
 * added back rlog messages from prior to the addition of
 * the $log$ string.
 *
 * Revision 1.26  2000/04/22 22:26:58  rsd
 * put return newline in combat switch messages, was reported
 * in bug file.
 *
 * Revision 1.25  2000/04/17 00:50:54  rsd
 * altered comment header.  Added hack to send info to players
 * who backstab because a successful backstab isn't calling
 * the lines out of the message file for some reason.
 * Retabbed and braced do_backstab as well
 *
 * Revision 1.24  2000/03/26 21:13:19  cso
 * made teh messages for do_circle a bit clearer
 *
 * Revision 1.23  2000/02/25 03:15:30  cso
 * fixed numerous typos relating to peaceful rooms and backstab.
 *
 * Revision 1.22  1999/12/06 20:18:25  cso
 * Fixed some typos.. "panicked" instead of "paniced", "You're doing"
 * instead of "Your doing".
 *
 * Revision 1.21  1999/11/28 22:41:16  cso
 * fixed misspelled schizophrenia
 * do_order: animated mobs can now order
 * cahnged wait state on order
 *
 * Revision 1.20  1999/10/30 15:18:41  rsd
 * Jimmy coded up new paladin alignment restriction code for
 * exp, I altered gain_exp to add reference to the victim for
 * alignment checks.
 *
 * Revision 1.19  1999/09/16 01:43:06  dce
 * *** empty log message ***
 *
 * Revision 1.18  1999/09/16 01:15:11  dce
 * Weight restrictions for monks...-hitroll, -damroll + ac
 *
 * Revision 1.17  1999/09/08 07:06:03  jimmy
 * More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
 * with blood and killing
 * --gurlaek
 *
 * Revision 1.16  1999/09/08 00:10:52  mtp
 * alter_move _removes_ moves, fixed do_disarm to remove 10 moves
 *
 * Revision 1.15  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.14  1999/09/03 23:02:40  mtp
 * added IS_FIGHTING check to throatcut
 *
 * Revision 1.13  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most
 * significant changes were moving all the BREATH's to within normal spell
 * range, and fixing the way socials were allocated.  Too many small fixes
 * to list them all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.12  1999/07/22 17:43:59  jimmy
 * Reduced all skill stun times by 1/2.  this is to compensate a little for
 * increasing the combat rounds by 2*.
 * --gurlaek
 *
 * Revision 1.11  1999/07/15 03:41:31  jimmy
 * Doh!
 *
 * Revision 1.10  1999/07/15 03:27:34  jimmy
 * Mob casters can not hit while casting.
 * Updated spell cast times to be more realistic
 * changed combat to 4 seconds per round.
 * Removed do_order semantics that told the order to onlookers.
 *
 * Revision 1.9  1999/07/14 19:24:03  jimmy
 * The combat system was enhanced/improved in the following ways:  Mobs
 * can no longer flee while bashed or sitting.  Fleeing causes casters to
 * stop casting.  You can now flee while flying.  pk checks were added to
 * bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
 * fixes. spellcasting for mobs is now very similar to PC spellcasting.
 * MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
 * Mobs no longer improve skills.  Bash now requires mobs to have a shield
 * just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
 * --gurlaek
 *
 * Revision 1.8  1999/06/30 18:25:04  jimmy
 * >> This is a major conversion from the 18 point attribute system to the
 * >> 100 point attribute system.  A few of the major changes are:
 * >> All attributes are now on a scale from 0-100
 * >> Everyone views attribs the same but, the attribs for one race
 * >>   may be differeent for that of another even if they are the
 * >>   same number.
 * >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * >> Mobs now have individual random attributes based on race/class.
 * >> The STR_ADD attrib has been completely removed.
 * >> All bonus tables for attribs in constants.c have been replaced by
 * >>   algorithims that closely duplicate the tables except on a 100 scale.
 * >> Some minor changes:
 * >> Race selection at char creation can now be toggled by using
 * >>   <world races off>
 * >> Lots of cleanup done to affected areas of code.
 * >> Setting attributes for mobs in the .mob file no longer functions
 * >>   but is still in the code for later use.
 * >> We now have a spare attribut structure in the pfile because the new
 * >>   system only used three instead of four.
 * >> --gurlaek 6/30/1999
 *
 * Revision 1.7  1999/04/03 18:59:22  dce
 * Debug to see if feeble attempt works.
 *
 * Revision 1.6  1999/04/03 18:54:17  dce
 * Feeble attempt to stop slow death crashes.
 *
 * Revision 1.5  1999/03/21 21:49:37  dce
 * Disallows pkilling.
 *
 * Revision 1.4  1999/03/10 00:03:37  dce
 * Monk semantics for dodge/parry/ripost/attack
 *
 * Revision 1.3  1999/03/08 23:24:48  dce
 * Added Springleap for monks
 *
 * Revision 1.2  1999/02/20 18:41:36  dce
 * Adds improve_skill calls so that players can imprve their skills.
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.224
log
@Fix damage colors on springleap.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.223 2009/08/02 20:19:00 myc Exp mud $
d26 1
d2548 3
@


1.223
log
@Eye gouge now applies a -hr modifier.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.222 2009/07/18 01:17:23 myc Exp myc $
d1574 1
a1574 1
      act("&0&6You manage to take $N down but also &bfall down yourself!&0 (&1&8$i&0)",
d1576 1
a1576 1
      act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0 (&3$i&0)",
d2547 3
@


1.222
log
@Immobilized characters can't kick or springleap.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.221 2009/06/11 13:36:05 myc Exp myc $
d1467 3
a1469 3
         eff.duration = 2 + GET_SKILL(ch, SKILL_EYE_GOUGE) / 48;
         eff.modifier = 0;
         eff.location = APPLY_NONE;
d1475 1
a1475 1
               (GET_SKILL(ch, SKILL_EYE_GOUGE) + percent) >> 2, DAM_PIERCE),
d2547 3
@


1.221
log
@When throatcut is successful, apply an injured throat effect
which hinders the victim's casting ability.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.220 2009/03/20 06:08:18 myc Exp myc $
d1343 5
d1504 5
d2547 4
@


1.220
log
@Make stomp and ground shaker only work in rooms where earthquake
works.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.219 2009/03/15 23:18:08 jps Exp myc $
d1874 10
a1893 1
   return;
d2537 4
@


1.219
log
@Make it so you need a one-handed slashing weapon to throatcut.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.218 2009/03/15 23:00:15 jps Exp jps $
d2479 5
d2528 3
@


1.218
log
@Add damage amounts to springleap messages.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.217 2009/03/15 22:39:42 jps Exp jps $
d1608 4
d1673 1
a1673 1
      send_to_char("&0You need to wield a weapon to cut throats!&0\r\n", ch);
d1678 3
a1680 2
   if (!IS_WEAPON_PIERCING(weapon) && GET_EQ(ch, WEAR_WIELD2))
       weapon = GET_EQ(ch, WEAR_WIELD2);
d1682 2
a1683 2
   if (!IS_WEAPON_PIERCING(weapon)) {
      send_to_char("&0Only piercing weapons can be used for throat cutting.&0\r\n", ch);
d1776 1
a1776 4
   /*   sprintf(buf, "&7&bYour roll: %d, your skill (chance): %d, and your random: %d, victim->level: %d.&0", percent, chance, random, GET_LEVEL(vict));
   act(buf, FALSE, ch, 0, vict, TO_CHAR); */

      /* The moment of excitement! */
d1779 2
a1780 2
       if (damage_evasion(vict, ch, weapon, DAM_PIERCE)) {
            damage_evasion_message(ch, vict, weapon, DAM_PIERCE);
d2523 3
@


1.217
log
@Paralyzed folks can't dodge backstabs and throatcuts
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.216 2009/03/09 04:33:20 jps Exp jps $
d1482 1
a1482 1
   int percent, prob;
d1484 1
a1484 1
   if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
d1533 6
a1538 3
      act("&0&6You try to take $N down but you spring over $S head!&0", FALSE, ch, 0, vict, TO_CHAR);
      act("&0&6$N springs from the ground at you but soars over your head!&0", FALSE, vict, 0, ch, TO_CHAR);
      act("&0&6$N springs from the ground at $n but misses by a mile!&0", FALSE, vict, 0, ch, TO_NOTVICT);
d1563 7
a1569 6
      act("&0&6You manage to take $N down but also &bfall down yourself!&0",
               FALSE, ch, 0, vict, TO_CHAR);
      act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0",
               FALSE, vict, 0, ch, TO_CHAR);
      act("&0&6$N springs from the ground, knocking $n down and &bfalling in the process!&0",
               FALSE, vict, 0, ch, TO_NOTVICT);
d1572 1
a1572 3
      damage(ch, vict,
            dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH),
            SKILL_SPRINGLEAP);
d1584 7
a1590 6
      act("&0&b&8You spring from the ground, knocking $N off balance.&0",
               FALSE, ch, 0, vict, TO_CHAR);
      act("&0&b&8$N springs from the ground and knocks you down!&0",
               FALSE, vict, 0, ch, TO_CHAR);
      act("&0&b&8$N springs from the ground, knocking $n down!&0",
               FALSE, vict, 0, ch, TO_NOTVICT);
d1593 1
a1593 3
      damage(ch, vict,
            dam_suscept_adjust(ch, vict, 0, GET_LEVEL(ch) >> 1, DAM_CRUSH),
            SKILL_SPRINGLEAP);
d1669 1
a1669 1
      send_to_char("&0You need to wield a weapon to make it a success.&0\r\n", ch);
d2521 3
@


1.216
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.215 2009/03/08 23:34:14 jps Exp jps $
d673 3
a675 1
   if (MOB_FLAGGED(vict, MOB_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
d685 2
d1709 4
a1712 1
   if ((MOB_FLAGGED(vict, MOB_AWARE) || EFF_FLAGGED(vict, EFF_AWARE)) && AWAKE(vict))
d2520 4
@


1.215
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.214 2009/03/08 21:43:27 jps Exp jps $
d35 1
d2513 3
@


1.214
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.213 2009/03/07 22:28:08 jps Exp jps $
d22 1
a22 1
#include "spells.h"
d2512 3
@


1.213
log
@Add effect flag remote_aggr, which keeps your aggressive action from
removing things like invis. Useful for those spells that keep on hurting.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.212 2009/03/03 19:41:50 myc Exp jps $
d34 1
d2512 4
@


1.212
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.211 2009/02/18 19:48:08 myc Exp myc $
d53 10
a62 8
   if (affected_by_spell(ch, SPELL_INVISIBLE) ||
         affected_by_spell(ch, SPELL_NATURES_EMBRACE))
      appear(ch);
   REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
   REMOVE_FLAG(EFF_FLAGS(ch), EFF_CAMOUFLAGED);
   if (EFF_FLAGGED(ch, EFF_GLORY))
      effect_from_char(ch, SPELL_GLORY);
   GET_HIDDENNESS(ch) = 0;
d2511 3
@


1.211
log
@Swap order of damage and alter_pos; should fix bash bug...
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.210 2009/01/25 02:53:33 myc Exp myc $
d372 1
a372 1
   else if (!(helpee = get_char_room_vis(ch, arg)))
d434 1
a434 1
   else if (!(vict = get_char_room_vis(ch, arg)))
d480 1
a480 1
      if (!(vict = get_char_room_vis(ch, arg)))
d594 1
a594 1
   if (!(vict = get_char_room_vis(ch, buf)))  {
d1088 1
a1088 1
   if (!(vict = get_char_room_vis(ch, arg))) {
d1240 1
a1240 1
   if (!(vict = get_char_room_vis(ch, arg))) {
d1315 1
a1315 1
   if ( !(vict = get_char_room_vis(ch, arg)) )
d1397 1
a1397 1
   } else if (!(vict = get_char_room_vis(ch, arg))) {
d1493 1
a1493 1
   if (!(vict = get_char_room_vis(ch, arg))) {
d1637 1
a1637 1
   if ((!(vict = get_char_room_vis(ch, buf)))&& (!(vict == ch))){
d2220 1
a2220 1
   else if (!(vict = get_char_room_vis(ch, arg)) || vict != FIGHTING(ch)) {
d2272 1
a2272 1
   if (!(vict = get_char_room_vis(ch, arg))) {
d2328 1
a2328 1
   if (!(vict = get_char_room_vis(ch, arg))) {
d2509 3
@


1.210
log
@Fix typo in springleap.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.209 2009/01/19 09:25:23 myc Exp myc $
a1209 1
      alter_pos(vict, POS_SITTING, STANCE_ALERT);
d1213 2
d2509 3
@


1.209
log
@Removed MOB_PET flag.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.208 2009/01/17 00:28:02 myc Exp myc $
d1524 1
a1524 1
      act("&0&6You try to take $N down but you spring over his head!&0", FALSE, ch, 0, vict, TO_CHAR);
d2508 3
@


1.208
log
@Fix use of uninitialized variables in do_bash and do_throatcut.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.207 2008/09/27 03:54:47 jps Exp myc $
d183 1
a183 2
      if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
            !MOB_FLAGGED(tch, MOB_PET))
d249 1
a249 2
      if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
            !MOB_FLAGGED(tch, MOB_PET))
d324 1
a324 2
      if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
            !MOB_FLAGGED(tch, MOB_PET))
d2508 3
@


1.207
log
@Fix variable initialization in group retreat.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.206 2008/09/27 03:52:23 jps Exp jps $
a1080 7
      if (skill == SKILL_MAUL &&
            (!EFF_FLAGGED(ch, EFF_BERSERK) || !EFF_FLAGGED(ch, EFF_SPIRIT_BEAR))) {
         act("You're not angry enough to tear $M limb from limb.\r\n",
               FALSE, ch, 0, vict, TO_CHAR);
         return;
      }

d1100 9
d1607 1
a1607 1
   int random, chance, percent, dam, newExp, position;
d1778 1
a1778 1
             newExp = (GET_EXP(vict) * 3) /4; /* rip same % exp from the mob... since they're doing less work! */
d1789 1
a1789 1
             newExp = GET_EXP(vict) / 4; /* rip same % exp from the mob... since they're doing less work! */
d1800 1
a1800 1
               newExp = GET_EXP(vict) / 8; /* rip same % exp from the mob... since they're doing less work! */
d1810 1
a1810 1
             newExp = (GET_EXP(vict) * 9) / 10; /* rip same % exp from the mob... since they're doing less work! */
d1818 3
a1820 1
            default: break;
d1827 1
a1827 1
      newExp = 0; /* rip same % exp from the mob... since they're doing less work! */
d1837 1
a1837 1
      GET_EXP(vict) = MAX(1, GET_EXP(vict) - newExp); /* make sure we don't have negative exp gain for ch */
d2511 3
@


1.206
log
@Debug code in group retreat.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.205 2008/09/27 03:48:20 jps Exp jps $
d952 1
a952 1
   bool realopponents;
d983 1
d998 1
a998 3
   else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) < opponents * number(20, 24)) {
      cprintf(ch, "Your skill is %d and there are %d opponent\r\n",
            GET_SKILL(ch, SKILL_GROUP_RETREAT), opponents);
a999 1
   }
d2507 3
@


1.205
log
@Cause followers to participate in group retreat.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.204 2008/09/24 17:00:15 myc Exp jps $
d997 3
a999 1
   else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) < opponents * number(20, 24))
d1001 1
d2509 3
@


1.204
log
@Fix typo in peace message for kick.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.203 2008/09/21 21:04:20 jps Exp myc $
d981 1
a981 1
   was_in = ch->in_room;
d983 5
a987 6
   for (tch = world[was_in].people; tch; tch = tch->next_in_room)
      if (FIGHTING(tch) == ch) {
         ++opponents;
         if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
             realopponents = TRUE;
      }
d990 1
a990 1
    * Can the followers see the leader before he leaves?
d1006 1
a1010 1

d1017 2
a1018 3
               GET_STANCE(k->follower) >= STANCE_FIGHTING &&
               k->can_see_master && (!FIGHTING(k->follower) ||
               FIGHTING(FIGHTING(k->follower)) == ch)) {
d2506 3
@


1.203
log
@Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.202 2008/09/21 20:40:40 jps Exp jps $
d2143 1
a2143 1
      send_to_char("You feel ashamed trying to disturb the peace of this room.r\n", ch);
d2508 3
@


1.202
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.201 2008/09/20 07:27:45 jps Exp jps $
d267 1
a267 1
      mag_affect(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
d2508 4
@


1.201
log
@set_fighting takes a 3rd parameter, reciprocate, which will set the attackee fighting
the attacker if true.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.200 2008/09/14 04:34:30 jps Exp jps $
a539 2
   struct char_data *person;

d546 6
a551 10
   /* Don't let a mob die in the middle of combat. */
   /* Check everyone in the room to see if they're in combat with this creature */
   for (person = world[victim->in_room].people; person; person = person->next_in_room)
       if (person->char_specials.fighting == victim && person != victim) {
            /* Aaaaand let the mob stick around to be killed! */
            /* (Set it back to mortally wounded) */
            GET_HIT(victim) = HIT_MORTALLYW;
            hp_pos_check(victim, NULL, 0);
            return;
       }
a853 5
                     if (FIGHTING(ch)) {
                        if (FIGHTING(FIGHTING(ch)) == ch)
                           stop_fighting(FIGHTING(ch));
                        stop_fighting(ch);
                     }
a911 2
      if (vict && FIGHTING(vict) == ch)
         stop_fighting(vict);
a1004 2
      stop_fighting(ch);

a1020 1
            stop_fighting(k->follower);
d1236 2
a1237 2
   struct char_data *vict, *tmp_ch;
   int percent, prob;
d1257 1
a1257 4
   for (tmp_ch = world[ch->in_room].people; tmp_ch &&
             (FIGHTING(tmp_ch) != vict); tmp_ch = tmp_ch->next_in_room);

   if (!tmp_ch) {
d1261 1
a1261 1
   if (GET_SKILL(ch, SKILL_RESCUE) == 0)
d1263 2
a1264 3
   else {
      percent = number(1, 101);            /* 101% is a complete failure */
      prob = GET_SKILL(ch, SKILL_RESCUE);
d1266 8
a1273 16
      if (percent > prob) {
         send_to_char("You fail the rescue!\r\n", ch);
         WAIT_STATE(ch, PULSE_VIOLENCE);
         improve_skill_offensively(ch, tmp_ch, SKILL_RESCUE);
         return;
      }
      send_to_char("Banzai!   To the rescue...\r\n", ch);
      act("You are rescued by $N, you are confused!", FALSE, vict, 0, ch, TO_CHAR);
      act("$n heroically rescues $N!", FALSE, ch, 0, vict, TO_NOTVICT);

      if (FIGHTING(vict) == tmp_ch)
         stop_fighting(vict);
      if (FIGHTING(tmp_ch))
         stop_fighting(tmp_ch);
      if (FIGHTING(ch))
         stop_fighting(ch);
d1275 2
a1276 1
      set_fighting(ch, tmp_ch, TRUE);
d1278 2
d1281 6
a1286 1
      WAIT_STATE(vict, PULSE_VIOLENCE + 2);
d1288 7
a1294 1
   }
d1296 2
a1297 1
   improve_skill_offensively(ch, tmp_ch, SKILL_RESCUE);
d1299 1
d2508 4
@


1.200
log
@Set folks fighting even if the initial attack was completely ineffective.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.199 2008/09/14 03:49:32 jps Exp jps $
d344 1
a344 1
         set_fighting(tch, ch);
d666 1
a666 1
      set_fighting(vict, ch);
d1189 1
a1189 1
      set_fighting(vict, ch);
d1203 1
a1203 1
      set_fighting(vict, ch);
d1303 1
a1303 2
      set_fighting(ch, tmp_ch);
      set_fighting(tmp_ch, ch);
d1373 1
a1373 1
          set_fighting(vict, ch);
d1453 1
a1453 1
      set_fighting(vict, ch);
d1562 1
a1562 1
      set_fighting(vict, ch);
d1780 1
a1780 1
            set_fighting(vict, ch);
d2204 1
a2204 1
            set_fighting(mob, ch);
d2314 1
a2314 1
       set_fighting(vict, ch);
d2370 1
a2370 1
       set_fighting(vict, ch);
d2509 1
a2509 1
         set_fighting(tch, ch);
d2520 3
@


1.199
log
@Don't allow fleeing when paralyzed
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.198 2008/09/14 02:08:01 jps Exp jps $
d344 1
d666 1
d1189 1
d1374 1
d1454 1
d1563 1
d1781 1
d2203 1
a2203 1
         if (damage_evasion(mob, ch, 0, physical_damtype(ch)))
d2205 2
a2206 1
         else if (subcmd == SCMD_TANTRUM && number(0, 1))
d2315 1
d2371 1
d2509 2
d2521 3
@


1.198
log
@Use standardized area attack targetting
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.197 2008/09/14 01:47:58 jps Exp jps $
d810 5
d2509 3
@


1.197
log
@hitall will tend to include folks who are in battle with your group.
It will not include nohassle folks (unless they're already involved).
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.196 2008/09/13 16:34:44 jps Exp jps $
a791 6
ACMD(do_circle)
{
   send_to_char("This command has been removed - just backstab while you're not tanking! \r\n", ch);
}


d2179 2
a2180 10
      /* Skip self */
      if (ch == mob)
         continue;

      /* Skip anyone grouped with ch */
      if (is_grouped(mob, ch))
         continue;

      /* Skip mobs following */
      if (mob->master == ch)
d2183 2
a2184 1
      if (!attack_ok(ch, mob, FALSE))
a2186 7
      if (!battling_my_group(ch, mob)) {
         if (!hit_all && !is_aggr_to(mob, ch))
            continue;
         if (PRF_FLAGGED(mob, PRF_NOHASSLE))
            continue;
      }

d2468 2
a2469 7
      if (tch == ch)
         continue;
      if (is_grouped(ch, tch))
         continue;
      if (!attack_ok(ch, tch, FALSE))
         continue;
      if (PRF_FLAGGED(tch, PRF_NOHASSLE))
d2471 2
d2504 4
@


1.196
log
@Moved do_order to act.comm.c.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.195 2008/09/09 08:23:37 jps Exp jps $
d2200 6
a2205 2
      if (!hit_all && !is_aggr_to(mob, ch) && FIGHTING(mob) != ch)
         continue;
d2527 3
@


1.195
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.194 2008/09/04 06:47:36 jps Exp jps $
a797 55
ACMD(do_order)
{
   char name[100], message[256];
   char buf[256];
   bool found = FALSE;
   int org_room;
   struct char_data *vict;
   struct follow_type *k;

   half_chop(argument, name, message);

   if (!*name || !*message)
      send_to_char("Order who to do what?\r\n", ch);
   else if (!(vict = get_char_room_vis(ch, name)) && !is_abbrev(name, "followers"))
      send_to_char("That person isn't here.\r\n", ch);
   else if (ch == vict)
      send_to_char("You obviously suffer from schizophrenia.\r\n", ch);

   else {
      /* modified to allow animateds to order - 321 */
      if (EFF_FLAGGED(ch, EFF_CHARM)) {
         send_to_char("Your superior would not approve of you giving orders.\r\n", ch);
         return;
      }
      if (vict) {
         sprintf(buf, "$N orders you to '%s'", message);
         act(buf, FALSE, vict, 0, ch, TO_CHAR);
         act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);

         if ((vict->master != ch) || !EFF_FLAGGED(vict, EFF_CHARM))
            act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
         else {
            send_to_char(OK, ch);
            command_interpreter(vict, message);
            WAIT_STATE(ch, PULSE_VIOLENCE / 2);
         }
      } else {   /* This is order "followers" */
         act("$n calls out, '$T'.", FALSE, ch, 0, message, TO_ROOM);
         org_room = ch->in_room;
         for (k = ch->followers; k; k = k->next) {
            if (org_room == k->follower->in_room &&
                  EFF_FLAGGED(k->follower, EFF_CHARM)) {
               found = TRUE;
               command_interpreter(k->follower, message);
            }
         }
         if (found) {
            WAIT_STATE(ch, PULSE_VIOLENCE / 2);
            send_to_char(OK, ch);
         } else
            send_to_char("Nobody here is a loyal subject of yours!\r\n", ch);
      }
   }
}

d2523 3
@


1.194
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.193 2008/09/01 23:47:49 jps Exp jps $
d211 1
a211 1
         if (SUN(IN_ROOM(ch)) == SUN_DARK && OUTSIDE(ch)) {
d2109 1
a2109 1
      if (OUTSIDE(tch)) {
d2131 1
a2131 1
               OUTSIDE(vict) ? "ground" : "floor");
d2528 1
a2528 1
   if (!OUTSIDE(ch)) {
d2578 3
@


1.193
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.192 2008/08/24 19:29:11 jps Exp jps $
d1787 4
a1790 4
   case SECT_CITY:             chance += 15; break;
   case SECT_FIELD:            chance -= 10; break;
   case SECT_ROAD:             chance -=   5; break;
   case SECT_BEACH:            chance -= 10; break;
d1792 7
a1798 7
   case SECT_FOREST:          chance -= 15; break;
   case SECT_RUINS:            chance +=   5; break;
   case SECT_SWAMP:            chance -= 20; break;
   case SECT_WATER_SWIM:    chance -= 50; break;
   case SECT_WATER_NOSWIM: chance -= 75; break;
   case SECT_FLYING:          chance += 20; break;
   default:                        chance +=   0; break;
d2578 3
@


1.192
log
@Apply damage susceptibility reductions to the various physical attack skills.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.191 2008/08/18 01:35:38 jps Exp jps $
d33 1
d2578 3
@


1.191
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.190 2008/08/10 03:10:26 jps Exp jps $
d1281 3
a1283 1
      damage(ch, vict, GET_LEVEL(ch) >> 1, skill);
d1428 3
a1430 1
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_KICK);
d1524 4
a1527 1
      damage(ch, vict, (GET_SKILL(ch, SKILL_EYE_GOUGE) + percent) >> 2, SKILL_EYE_GOUGE);
d1623 3
a1625 1
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
d1645 3
a1647 1
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
d2376 3
a2378 1
   damage(ch, vict, dam, SKILL_PECK);
a2379 1

d2431 3
a2433 1
   damage(ch, vict, dam, SKILL_CLAW);
d2554 5
a2558 1
             damage(ch, tch, number(50, GET_SKILL(ch, SKILL_GROUND_SHAKER)), SKILL_GROUND_SHAKER);
d2577 3
@


1.190
log
@Don't allow illusionists to backstab someone who is already in battle.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.189 2008/08/09 18:16:21 jps Exp jps $
d445 1
a445 1
         send_to_char("&7You're doing the best you can!&0\n\r", ch);
d1678 1
a1678 1
      send_to_char("You can't be stealthy enough to do this while fighting!\n\r",ch);
d1683 1
a1683 1
      send_to_char("Cut someone's throat while riding???   I don't think so!\n\r",ch);
d1977 1
a1977 1
      send_to_char("You must be wielding some kind of weapon.\n\r", ch);
d2559 3
@


1.189
log
@Got rid of weapon-slinging.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.188 2008/07/27 06:39:18 jps Exp jps $
d667 6
d2559 3
@


1.188
log
@Make sure random_attack_target doesn't return NULL.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.187 2008/07/13 17:23:08 jps Exp jps $
d1657 1
a1657 1
   bool sling = FALSE, skipcast = FALSE;
a1863 12
   else if ((percent > chance) && (dice(1,100) < 11))
   {
      dam = 0;
      sling = TRUE;
      skipcast = TRUE;
      newExp = 0; /* rip same % exp from the mob... since they're doing less work! */

      sprintf(buf1, "&3&bMidway, you trip and fall which sends %s flying from your hand.&0", weapon->short_description);
      sprintf(buf2, "&3&b$n trips and falls, losing %s in a botched attempt on your life!&0", weapon->short_description);
      sprintf(buf3, "&3&b$n trips and falls, losing %s while trying to kill $N!&0", weapon->short_description);

   }
a1905 23
    if (sling) {
         if (position == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD2)) {
             struct obj_data* temp;
             unequip_char(ch,WEAR_WIELD);
             temp = unequip_char(ch, WEAR_WIELD2);
             if (temp != NULL) {
                  equip_char(ch, temp, WEAR_WIELD);
             }
         } else {
             unequip_char(ch, position);
         }
         if (OBJ_FLAGGED(weapon, ITEM_NODROP)) { /* Cursed? */
             act("&3&bYour&0 $o &3&bmagically returns to your&0 &B&3inventory!&0",
                      TRUE, ch, weapon, NULL, TO_CHAR);
             act("$n's &0 $o&3&b magically returns to $s&0 &B&3inventory!&0",
                      TRUE, ch, weapon, NULL, TO_ROOM);
             obj_to_char(weapon, ch);
         } else {
             /* place the weapon in the room */
             obj_to_room(weapon, ch->in_room);
         }
    }

d2553 3
@


1.187
log
@When you go to bash a creature who's already on the ground, you
get notified of that. Instead of falling down yourself. Also, when
you try to bash a no-bash creature, you will get a notification
of that. You won't fall down, but you will be lagged.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.186 2008/06/21 17:29:43 jps Exp jps $
d124 2
d2588 6
@


1.186
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.185 2008/06/21 06:30:43 jps Exp jps $
d1174 2
a1175 1
      send_to_char("You cannot do that while you are guarding them.\r\n",ch);
d1189 5
a1217 4
   if (MOB_FLAGGED(vict, MOB_NOBASH))
      percent = prob + 1; /* insta-fail */
   if (GET_POS(vict) <= POS_SITTING)
      percent = prob + 1; /* insta-fail */
d1221 2
a1222 1
   if (prob > percent && damage_evasion(vict, ch, 0, DAM_CRUSH)) {
d1237 14
d1277 5
a1282 1
      damage(ch, vict, 0, skill);
d2586 3
@


1.185
log
@Typo and formatting fixes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.184 2008/06/05 02:07:43 myc Exp jps $
d1145 2
a1146 1
         send_to_char("You're not angry enough to tear them limb from limb.\r\n", ch);
d1151 2
a1152 1
         sprintf(buf, "You haven't reoriented yourself for another %s yet!\r\n", skills[skill].name);
d1207 1
d1222 1
a1222 1
      act(EVASIONCLR "$n&" EVASIONCLR " charges right through $N" EVASIONCLR "!&0",
d1224 1
a1224 1
      act(EVASIONCLR "$n&" EVASIONCLR " charges right through you!&0",
d1253 1
a1253 1
   if (prob > percent) {
d1257 1
a1257 2
   }
   else {
d2565 3
@


1.184
log
@Fixed two bugs in do_roar.  Changing objet flags to use flagvectors.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.183 2008/05/25 21:00:22 myc Exp myc $
d344 4
a347 2
      act("&3You are slammed to the ground by $N's&3 tail!&0", FALSE, tch, 0, ch, TO_CHAR);
      act("&3$n&3 is slammed to the ground by a mighty tail sweep!&0", FALSE, tch, 0, 0, TO_ROOM);
d386 1
a386 1
         act("You assist $N&0 heroically.",FALSE,ch,0,helpee,TO_CHAR);
d810 1
a810 1
         send_to_char("Your superior would not aprove of you giving orders.\r\n", ch);
d825 2
a826 8
      } else {                                    /* This is order "followers" */

         /* Altered until intelligence and level checks are coded. RSD 7/14/99
          *   sprintf(buf, "$n issues the order '%s'.", message);
          * act(buf, FALSE, ch, 0, vict, TO_ROOM);
          */
            act("$n gives an order.", FALSE, ch, 0, 0, TO_ROOM);

a827 1

d829 5
a833 5
            if (org_room == k->follower->in_room)
               if (EFF_FLAGGED(k->follower, EFF_CHARM)) {
                  found = TRUE;
                  command_interpreter(k->follower, message);
               }
d835 1
a835 1
         if (found){
d838 1
a838 1
         }else
d2563 3
@


1.183
log
@Fix tantrum/hitall to improve skill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.182 2008/05/25 18:09:47 myc Exp myc $
d208 1
a208 1
         if (SUN(IN_ROOM(ch)) == SUN_DARK) {
d261 2
d1909 1
a1909 1
         if (IS_OBJ_STAT(weapon, ITEM_NODROP)) { /* Cursed? */
d2119 1
a2119 1
      if ((IS_OBJ_STAT(obj, ITEM_NODROP))) { /* Cursed? */
d2148 1
a2148 1
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_WAS_DISARMED);
d2568 3
@


1.182
log
@Roar message missing newline.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.181 2008/05/18 20:46:02 jps Exp myc $
d2179 1
a2179 1
   bool hit_all = FALSE, realvictims = FALSE;
d2221 2
a2222 2
      if (GET_SKILL(ch, SKILL_TANTRUM) < percent)
         return;
d2227 2
a2228 2
      if (GET_SKILL(ch, SKILL_HITALL) < percent)
         return;
d2253 2
a2254 5
      if (damage_evasion(mob, ch, 0, physical_damtype(ch))) {
               damage_evasion_message(ch, mob, equipped_weapon(ch), physical_damtype(ch));
      } else {
         if (!MOB_FLAGGED(mob, MOB_ILLUSORY))
            realvictims = TRUE;
d2256 4
a2259 1
         if (subcmd == SCMD_TANTRUM && number(0, 1))
d2267 1
a2267 1
      improve_skill(ch, SKILL_HITALL);
d2566 3
@


1.181
log
@Cause GLORY to be removed when you're offensive, just like invis.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.180 2008/05/18 20:16:11 jps Exp jps $
d235 2
a236 2
      act("&9&b$n&9&b makes your soul quake with a vicious &1ROOOOOAAAAAARRRRRR!&0",FALSE, ch,0,0,TO_ROOM);
      send_to_char("&9&bYou take a deep breath and release a vicious &1ROOOOOAAAAARRRRRR!&0", ch);
d2566 3
@


1.180
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.179 2008/05/18 02:33:56 jps Exp jps $
d57 2
d2566 3
@


1.179
log
@Provide feedback when you attempt to switch without the skill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.178 2008/05/17 22:03:01 jps Exp jps $
d32 1
a42 1
bool is_aggr_to(struct char_data *ch,struct char_data *target);
d2564 3
@


1.178
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.177 2008/05/14 05:31:37 jps Exp jps $
d62 3
a64 1
   if (GET_SKILL(ch, SKILL_SWITCH) <= 0)
d66 1
d2564 3
@


1.177
log
@Change "assist self" message.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.176 2008/05/14 05:11:42 jps Exp jps $
d60 18
a77 17
bool switch_ok(struct char_data *ch) {
  if (GET_SKILL(ch, SKILL_SWITCH) <= 0)
    return FALSE;

  if (number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
    act("&8$n tries to switch opponents, but becomes confused!&0", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("&8You try to switch opponents and become confused.&0\r\n", ch);
    stop_fighting(ch);
    improve_skill_offensively(ch, FIGHTING(ch), SKILL_SWITCH);
    return FALSE;
  }

  stop_fighting(ch);
  act("&8$n switches opponents!&0", FALSE, ch, 0, 0, TO_ROOM);
  send_to_char("&8You switch opponents!&0\r\n", ch);
  improve_skill_offensively(ch, FIGHTING(ch), SKILL_SWITCH);
  return TRUE;
d81 4
a84 4
  const char *name;
  const int spell;
  char *to_char;
  char *to_room;
d86 16
a101 16
  { "fire", SPELL_FIRE_BREATH,
    "&1You snort and &bf&3i&7r&1e&0&1 shoots out of your nostrils!&0\r\n",
    "&1$n&1 snorts and a gout of &bf&3i&7r&1e&0&1 shoots out of $s nostrils!&0" },
  { "gas", SPELL_GAS_BREATH,
    "&2You heave and a &bnoxious gas&0&2 rolls rapidly out of your nostrils!&0\r\n",
    "&2$n&2 rumbles and a &bnoxious gas&0&2 rolls out of $s nostrils!&0" },
  { "frost", SPELL_FROST_BREATH,
    "&7&bYou shiver as a shaft of &0&4f&br&7o&4s&0&4t&7&b leaps from your mouth!&0\r\n",
    "&7&b$n&7&b shivers as a shaft of &0&4f&br&7o&4s&0&4t&7&b leaps from $s mouth!&0" },
  { "acid", SPELL_ACID_BREATH,
    "&9&bYou stomach heaves as a wash of &2&ba&0&2ci&bd&9 leaps from your mouth!&0\r\n",
    "&9&b$n&9&b looks pained as a wash of &2&ba&0&2ci&2&bd&9 leaps from $s mouth!&0" },
  { "lightning", SPELL_LIGHTNING_BREATH,
    "&4You open your mouth and bolts of &blightning&0&4 shoot out!&0\r\n",
    "&4$n&4 opens $s mouth and bolts of &blightning&0&4 shoot out!&0" },
  { NULL, 0, NULL, NULL },
d133 21
d155 4
a158 15
  ACMD(do_action);
  struct char_data *tch, *next_tch;
  int type;
  bool realvictims = FALSE;

  if (!ch || ch->in_room == NOWHERE)
    return;

  /* Don't allow reanimated undead to do this - justification:
   * you need actual life to generate poison gas! */
  if (GET_SKILL(ch, SKILL_BREATHE) < 1 || EFF_FLAGGED(ch, EFF_CHARM)) {
    send_to_char("You huff and puff but to no avail.\r\n", ch);
    act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
    return;
  }
d160 2
a161 1
  one_argument(argument, arg);
d163 19
a181 3
  for (type = 0; breath_info[type].name; ++type)
    if (is_abbrev(arg, breath_info[type].name))
      break;
d183 4
a186 32
  if (!breath_info[type].name) {
    send_to_char("Usage: breathe <fire / gas / frost / acid / lightning>\r\n", ch);
    return;
  }

  send_to_char(breath_info[type].to_char, ch);
  act(breath_info[type].to_room, FALSE, ch, 0, 0, TO_ROOM);

  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

    if (tch == ch)
      continue;
    if (is_grouped(ch, tch))
      continue;
    if (!mass_attack_ok(ch, tch, FALSE))
      continue;
    if (PRF_FLAGGED(tch, PRF_NOHASSLE))
      continue;
    /* Mobs don't hit other mobs, unless they're pets */
    if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
        !MOB_FLAGGED(tch, MOB_PET))
      continue;
    call_magic(ch, tch, 0, breath_info[type].spell, GET_LEVEL(ch), CAST_BREATH);
    if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
       realvictims = TRUE;
  }

  if (realvictims)
    improve_skill(ch, SKILL_BREATHE);
  if (GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE);
d191 21
a211 15
  struct char_data *tch, *next_tch;
  bool realvictims = FALSE;
  ACMD(do_flee);
  ACMD(do_action);

  if (!ch || ch->in_room == NOWHERE)
    return;

  if (subcmd == SCMD_HOWL) {
    if (!GET_SKILL(ch, SKILL_BATTLE_HOWL) ||
        !EFF_FLAGGED(ch, EFF_SPIRIT_WOLF) ||
        !EFF_FLAGGED(ch, EFF_BERSERK)) {
      if (SUN(IN_ROOM(ch)) == SUN_DARK) {
        send_to_char("You form an O with your mouth and howl at the moon.\r\n", ch);
        act("$n starts howling at the moon.  Eerie.", FALSE, ch, 0, 0, TO_ROOM);
d213 56
a268 3
      else {
        send_to_char("You howl madly, making a fool of yourself.\r\n", ch);
        act("$n howls madly, looking like a fool.", FALSE, ch, 0, 0, TO_ROOM);
d270 6
a275 57
      return;
    }
  }
  else if (!GET_SKILL(ch, SKILL_ROAR) || EFF_FLAGGED(ch, EFF_CHARM)) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    act("$n opens $s mouth wide and lets out a little cough.", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You take a deep breath and release a vicious cough!\r\n", ch);
    return;
  }

  if (subcmd == SCMD_HOWL) {
    act("$n opens his mouth and a &1&8demonic &0&1howl&0 echoes out!", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You let out a demonic battle howl, striking fear into your enemies!\r\n", ch);
  }
  else {
    act("&9&b$n&9&b makes your soul quake with a vicious &1ROOOOOAAAAAARRRRRR!&0",FALSE, ch,0,0,TO_ROOM);
    send_to_char("&9&bYou take a deep breath and release a vicious &1ROOOOOAAAAARRRRRR!&0", ch);
  }

  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

    if (tch == ch)
      continue;
    if (GET_STANCE(tch) < STANCE_SLEEPING)
      continue;
    /* Mobs don't fear other mobs, unless they're pets. */
    if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
        !MOB_FLAGGED(tch, MOB_PET))
      continue;
    if (is_grouped(ch, tch))
      continue;
    if (!attack_ok(ch, tch, FALSE))
      continue;
    if (mag_savingthrow(tch, SAVING_PARA))
      continue;
    if (PRF_FLAGGED(tch, PRF_NOHASSLE))
      continue;
    /* Twice as hard to roar at a sentinel mob. */
    if (MOB_FLAGGED(tch, MOB_SENTINEL) && mag_savingthrow(tch, SAVING_PARA))
      continue;

    mag_affect(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);

    if (SLEEPING(tch)) {
      if (number(0, 1)) {
        sprintf(buf, "A loud %s jolts you from your slumber!\r\n",
                subcmd == SCMD_HOWL ? "OOOOAAAOAOOHHH howl" : "ROAAARRRRRR");
        send_to_char(buf, tch);
        act("$n jumps up dazedly, awakened by the noise!", TRUE, tch, 0, 0, TO_ROOM);
        GET_POS(tch) = POS_SITTING;
        GET_STANCE(tch) = STANCE_ALERT;
        WAIT_STATE(tch, PULSE_VIOLENCE);
d277 12
a288 20
    }
    else if (GET_DEX(tch) - 15 < number(0, 100) && GET_POS(tch) >= POS_STANDING) {
      send_to_char("In your panicked rush to flee, you trip!\r\n", tch);
      act("In a panicked rush to flee, $n trips!", FALSE, tch, 0, 0, TO_ROOM);
      GET_POS(tch) = POS_SITTING;
      GET_STANCE(tch) = STANCE_ALERT;
      WAIT_STATE(tch, PULSE_VIOLENCE);
    }
    else
      do_flee(tch, NULL, 0, 0);
    if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
      realvictims = TRUE;
  }

  if (realvictims) {
    if (subcmd == SCMD_HOWL)
      improve_skill(ch, SKILL_BATTLE_HOWL);
    else
      improve_skill(ch, SKILL_ROAR);
  }
d290 1
a290 1
  WAIT_STATE(ch, PULSE_VIOLENCE);
d295 50
a344 41
  struct char_data *tch, *next_tch;
  bool realvictims = FALSE;
  ACMD(do_flee);

  if (!ch || ch->in_room == NOWHERE)
    return;

  if (GET_SKILL(ch, SKILL_SWEEP) < 1 || EFF_FLAGGED(ch, EFF_CHARM)) {
    send_to_char("Huh?!?\r\n", ch);
    return;
  }

  act("&2$n&2 sweeps with $s enormous tail!&0", FALSE, ch, 0, 0, TO_ROOM);
  send_to_char("&2You sweep with your enormous tail!&0\r\n", ch);

  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

    if (tch == ch)
      continue;
    /* Mobs don't sweep other mobs, unless they're pets. */
    if (!IS_PC(ch) && !IS_PC(tch) && !MOB_FLAGGED(ch, MOB_PET) &&
        !MOB_FLAGGED(tch, MOB_PET))
      continue;
    if (is_grouped(ch, tch))
      continue;
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (GET_VIEWED_DEX(tch) - 15 > number(0, 100) || GET_STANCE(tch) < STANCE_FIGHTING)
      continue;
    if (!attack_ok(ch, tch, FALSE))
      continue;
    if (PRF_FLAGGED(tch, PRF_NOHASSLE))
      continue;
    if (damage_evasion(tch, ch, 0, DAM_CRUSH)) {
      act(EVASIONCLR "$N's" EVASIONCLR " tail passes right through you.&0",
            FALSE, tch, 0, ch, TO_CHAR);
      act(EVASIONCLR "$N's" EVASIONCLR " tail passes harmlessly through $n.&0",
            FALSE, tch, 0, 0, TO_ROOM);
      continue;
    }
d346 4
a349 13
    act("&3You are slammed to the ground by $N's&3 tail!&0", FALSE, tch, 0, ch, TO_CHAR);
    act("&3$n&3 is slammed to the ground by a mighty tail sweep!&0", FALSE, tch, 0, 0, TO_ROOM);
    GET_POS(tch) = POS_SITTING;
    GET_STANCE(tch) = STANCE_ALERT;
    WAIT_STATE(tch, PULSE_VIOLENCE);
    if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
       realvictims = TRUE;
  }

  if (realvictims)
     improve_skill(ch, SKILL_SWEEP);
  if (GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE);
d354 1
a354 1
  struct char_data *helpee, *opponent;
d356 1
a356 1
  one_argument(argument, arg);
d358 27
a384 27
  if (FIGHTING(ch))
    send_to_char("You're already fighting!\r\n", ch);
  else if (!*arg)
    send_to_char("Whom do you wish to assist?\r\n", ch);
  else if (!(helpee = get_char_room_vis(ch, arg)))
    send_to_char(NOPERSON, ch);
  else if (helpee == ch)
    send_to_char("Usually, you assist someone else.\r\n", ch);
  else {
    for (opponent = world[ch->in_room].people;
        opponent && (FIGHTING(opponent) != helpee);
        opponent = opponent->next_in_room)
      ;

    if (!opponent)
      act("But nobody is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (!CAN_SEE(ch, opponent))
      act("You can't see who is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (attack_ok(ch, opponent, TRUE)) {
      act("You assist $N&0 heroically.",FALSE,ch,0,helpee,TO_CHAR);
      act("$n&0 assists you!", 0, ch, 0, helpee, TO_VICT);
      act("$n&0 heroically assists $N.", FALSE, ch, 0, helpee, TO_NOTVICT);
      if (CONFUSED(ch))
         opponent = random_attack_target(ch, opponent, TRUE);
      attack(ch, opponent);
    }
  }
d389 11
a399 1
  ACMD(do_abort);
d401 8
a408 18
  if (CASTING(ch)) {
    do_abort(ch, argument, 0, 0);
    return;
  }

  if (!FIGHTING(ch)) {
    send_to_char("You are not fighting anyone.\r\n",ch);
    return;
  }

  if (FIGHTING(FIGHTING(ch)) == ch) {
    send_to_char("No way! You are fighting for your life!\r\n", ch);
    return;
  }

  stop_fighting(ch);
  send_to_char("You disengage from combat.\r\n", ch);
  WAIT_STATE(ch, PULSE_VIOLENCE);
d414 1
a414 1
  struct char_data *vict;
d416 1
a416 1
  one_argument(argument, arg);
d418 26
a443 26
  if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS))
    send_to_char("&8It is just too dark!&0", ch);
  else if (EFF_FLAGGED(ch, EFF_BLIND))
    send_to_char("You can't see a thing!\r\n", ch);
  else if (!*arg)
    send_to_char("Hit who?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, arg)))
    send_to_char("They don't seem to be here.\r\n", ch);
  else if (vict == ch) {
    send_to_char("You hit yourself...OUCH!.\r\n", ch);
    act("$n hits $mself, and says OUCH!", FALSE, ch, 0, vict, TO_ROOM);
  }
  else if (EFF_FLAGGED(ch, EFF_CHARM) && (ch->master == vict))
    act("$N is just such a good friend, you simply can't hit $M.", FALSE, ch, 0, vict, TO_CHAR);
  else if (attack_ok(ch, vict, TRUE)) {
    if (vict == FIGHTING(ch)) {
      send_to_char("&7You're doing the best you can!&0\n\r", ch);
      return;
    }
    else if (!FIGHTING(ch) || switch_ok(ch)) {
      if (CONFUSED(ch))
         vict = random_attack_target(ch, vict, TRUE);
      attack(ch, vict);
    }
    WAIT_STATE(ch, PULSE_VIOLENCE);
  }
d450 16
a465 1
  struct char_data *vict;
d467 16
a482 31
  if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
    send_to_char("&8It is just too damn dark!&0", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }

  if ((GET_LEVEL(ch) < LVL_GOD) || IS_NPC(ch)) {
    do_hit(ch, argument, cmd, subcmd);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Kill who?\r\n", ch);
  } else {
    if (!(vict = get_char_room_vis(ch, arg)))
      send_to_char("They aren't here.\r\n", ch);
    else if (ch == vict)
      send_to_char("Your mother would be so sad.. :(\r\n", ch);
    else if (GET_LEVEL(vict) == LVL_IMPL)
      send_to_char("&1You dare NOT do that!&0", ch);
    else{
      act("You chop $M to pieces!  Ah!  The blood!", FALSE, ch, 0, vict, TO_CHAR);
      act("$N chops you to pieces!", FALSE, vict, 0, ch, TO_CHAR);
      act("$n brutally slays $N!", FALSE, ch, 0, vict, TO_NOTVICT);
      die(vict, ch);
    }
  }
d488 1
a488 1
  int chance = 0;
d490 2
a491 2
  if (!victim || !ch || ch == victim || ch == NULL || victim == NULL)
    return FALSE;
d493 28
a520 28
  /* No more instant kills until the timer runs out */
  if (GET_COOLDOWN(ch, CD_INSTANT_KILL))
    return FALSE;

  if (IS_NPC(ch) ||
      !GET_SKILL(ch, SKILL_INSTANT_KILL) ||
      DECEASED(victim) ||
      (ch->in_room != victim->in_room) ||
      (GET_LEVEL(victim) > LVL_IMMORT))
    return FALSE;

  improve_skill_offensively(ch, victim, SKILL_INSTANT_KILL);
  if (number(1, 101) > GET_SKILL(ch, SKILL_INSTANT_KILL))
    return FALSE;

  /*chance is now checking DEX and shouldn't happen as often*/
  chance = 1000 - (GET_SKILL(ch, SKILL_INSTANT_KILL) - (100 - GET_DEX(ch)) -
        (GET_LEVEL(victim) * 10)) / 10;

  if (!AWAKE(victim))
    chance = 0; /* der.. can you say coup de grace? */

  if (number(1, 1000) >= chance) {
    quickdeath(victim, ch);
    SET_COOLDOWN(ch, CD_INSTANT_KILL, (120 - (GET_LEVEL(ch))) * PULSE_COOLDOWN);
    return TRUE;
  }
  return FALSE;
d527 18
a544 1
  struct char_data *person;
d546 8
a553 25
  if (!victim) {
    mudlog("Attempting to use slow_death on a NULL character!", BRF, LVL_GOD, TRUE);
    log("Attempting to use slow_death on a NULL character!");
    return;
  }

  /* Don't let a mob die in the middle of combat. */
  /* Check everyone in the room to see if they're in combat with this creature */
  for (person = world[victim->in_room].people; person; person = person->next_in_room)
     if (person->char_specials.fighting == victim && person != victim) {
        /* Aaaaand let the mob stick around to be killed! */
        /* (Set it back to mortally wounded) */
        GET_HIT(victim) = HIT_MORTALLYW;
        hp_pos_check(victim, NULL, 0);
        return;
     }

  act("&8With a soft groan, $n slips off into the cold sleep of death.&0",
      TRUE, victim, 0, 0, TO_ROOM);
  act("&8$n is dead!  R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
  if (AWAKE(victim)) {
    act("&8You feel yourself slipping away and falling into the abyss.&0",
        FALSE, victim, 0, 0,TO_CHAR);
    send_to_char("&0&8Your life fades away ....\r\n", victim);
  }
d555 1
a555 1
  die(victim, NULL);
d560 3
a562 8
  if (GET_LEVEL(victim) >= LVL_IMMORT ||
        (ch && MOB_FLAGGED(ch, MOB_ILLUSORY)))
    return;

  send_to_char("You deliver the killing blow.\r\n", ch);
  act("$n's strike upon $N is faster than the eye can see.", TRUE, ch,
        0, victim, TO_NOTVICT);
  send_to_char("You feel a sharp sting, and all goes black.\r\n", victim);
d564 6
a569 1
  hurt_char(victim, ch, GET_MAX_HIT(victim) + 20, FALSE);
d691 1
a691 1
   percent = number(1, 101);	/* 101% is a complete failure */
d776 1
a776 1
  send_to_char("This command has been removed - just backstab while you're not tanking! \r\n", ch);
d782 35
a816 26
  char name[100], message[256];
  char buf[256];
  bool found = FALSE;
  int org_room;
  struct char_data *vict;
  struct follow_type *k;

  half_chop(argument, name, message);

  if (!*name || !*message)
    send_to_char("Order who to do what?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, name)) && !is_abbrev(name, "followers"))
    send_to_char("That person isn't here.\r\n", ch);
  else if (ch == vict)
    send_to_char("You obviously suffer from schizophrenia.\r\n", ch);

  else {
    /* modified to allow animateds to order - 321 */
    if (EFF_FLAGGED(ch, EFF_CHARM)) {
      send_to_char("Your superior would not aprove of you giving orders.\r\n", ch);
      return;
    }
    if (vict) {
      sprintf(buf, "$N orders you to '%s'", message);
      act(buf, FALSE, vict, 0, ch, TO_CHAR);
      act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);
d818 22
a839 31
      if ((vict->master != ch) || !EFF_FLAGGED(vict, EFF_CHARM))
	act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
      else {
	send_to_char(OK, ch);
	command_interpreter(vict, message);
	WAIT_STATE(ch, PULSE_VIOLENCE / 2);
      }
    } else {			/* This is order "followers" */

      /* Altered until intelligence and level checks are coded. RSD 7/14/99
       *  sprintf(buf, "$n issues the order '%s'.", message);
       * act(buf, FALSE, ch, 0, vict, TO_ROOM);
       */
	act("$n gives an order.", FALSE, ch, 0, 0, TO_ROOM);

      org_room = ch->in_room;

      for (k = ch->followers; k; k = k->next) {
	if (org_room == k->follower->in_room)
	  if (EFF_FLAGGED(k->follower, EFF_CHARM)) {
	    found = TRUE;
	    command_interpreter(k->follower, message);
	  }
      }
      if (found){
	WAIT_STATE(ch, PULSE_VIOLENCE / 2);
	send_to_char(OK, ch);
      }else
	send_to_char("Nobody here is a loyal subject of yours!\r\n", ch);
    }
  }
d844 4
a847 1
  int i, attempt;
d849 5
a853 2
  if (!ch || ch->in_room == NOWHERE)
    return;
d855 4
a858 46
  /* Don't show this message for sleeping and below */
  if (GET_STANCE(ch) > STANCE_SLEEPING && (IS_NPC(ch) ? GET_MOB_WAIT(ch) : CHECK_WAIT(ch))) {
    send_to_char("You cannot flee yet!\r\n", ch);
    return;
  }

  if (FIGHTING(ch) && EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too angry to leave this fight!\r\n", ch);
    return;
  }

  switch (GET_STANCE(ch)) {
  case STANCE_DEAD:
  case STANCE_MORT:
  case STANCE_INCAP:
  case STANCE_STUNNED:
    send_to_char("It's a bit too late for that.\r\n", ch);
    break;
  case STANCE_SLEEPING:
    send_to_char("You dream of fleeing!\r\n", ch);
    break;
  default:
    switch (GET_POS(ch)) {
       case POS_PRONE:
       case POS_SITTING:
       case POS_KNEELING:
         abort_casting(ch);
         act("Looking panicked, $n scrambles madly to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
         send_to_char("You scramble madly to your feet!\r\n", ch);
         GET_POS(ch) = POS_STANDING;
         GET_STANCE(ch) = STANCE_ALERT;
         if (IS_NPC(ch))
            WAIT_STATE(ch, PULSE_VIOLENCE * 2);
         break;
       default:
         if (IS_CORNERED(ch)) {
            act("$n tries to flee, but is unable to escape from $N!",
                  TRUE, ch, 0, ch->cornered_by, TO_NOTVICT);
            act("$n tries to flee, but is unable to escape from you!",
                  TRUE, ch, 0, ch->cornered_by, TO_VICT);
            act("PANIC!  You couldn't escape from $N!",
                  TRUE, ch, 0, ch->cornered_by, TO_CHAR);
            return;
         }
         for (i = 0; i < 6; i++) {    /* Make 6 attempts */
            attempt = number(0, NUM_OF_DIRS - 1);	/* Select a random direction */
d860 15
a874 2
         if (CAN_GO(ch, attempt) &&
               !ROOM_FLAGGED(EXIT(ch, attempt)->to_room, ROOM_DEATH)) {
d876 35
a910 8
            act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
            if (do_simple_move(ch, attempt, TRUE)) {
               sprintf(buf, "&0You panic and flee %s!&0\r\n", dirs[attempt]);
               send_to_char(buf, ch);
               if (FIGHTING(ch)) {
                  if (FIGHTING(FIGHTING(ch)) == ch)
                     stop_fighting(FIGHTING(ch));
                  stop_fighting(ch);
d912 4
a915 4
            } else
               act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
            return;
         }
d917 1
a917 5
      /* All 6 attempts failed! */
      act("$n tries to flee, but PANICS instead!", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("PANIC!  You couldn't escape!\r\n", ch);
    }
  }
d922 2
a923 2
  int dir, to_room;
  struct char_data *vict;
d925 2
a926 2
  if (!ch || !argument)
    return;
d928 2
a929 28
  if (!GET_SKILL(ch, SKILL_RETREAT)) {
    send_to_char("Try flee instead!\r\n", ch);
    return;
  }

  if (!FIGHTING(ch)) {
    send_to_char("You're not fighting anyone!\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Retreat where!?\r\n", ch);
    return;
  }

  dir = searchblock(arg, dirs, FALSE);

  if (dir < 0 || !EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) {
    send_to_char("You can't retreat that way!\r\n", ch);
    return;
  }

  /*
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
    if (FIGHTING(tch) == ch) {
      send_to_char("&8You cannot retreat while tanking!&0\r\n", ch);
d931 1
a931 2
    }
  */
d933 4
a936 1
  vict = FIGHTING(ch);
d938 1
a938 35
  /* Successful retreat? */
  if (GET_SKILL(ch, SKILL_RETREAT) > number(0, 81) && CAN_GO(ch, dir) &&
      !ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_DEATH) &&
      do_simple_move(ch, dir, TRUE)) {
    if (vict && FIGHTING(vict) == ch)
      stop_fighting(vict);

    /* Send message back to original room. */
    sprintf(buf, "$n carefully retreats from combat, leaving %s.", dirs[dir]);
    to_room = ch->in_room;
    ch->in_room = vict->in_room;
    act(buf, TRUE, ch, 0, 0, TO_ROOM);
    ch->in_room = to_room;

    sprintf(buf, "\r\nYou skillfully retreat %s.\r\n", dirs[dir]);
    send_to_char(buf, ch);
  }
  /* If fighting a mob that can switch, maybe get attacked. */
  else if (IS_NPC(FIGHTING(ch)) && FIGHTING(FIGHTING(ch)) != ch &&
           GET_SKILL(FIGHTING(ch), SKILL_SWITCH) &&
           GET_SKILL(FIGHTING(ch), SKILL_SWITCH) > number(1, 101)) {
    stop_fighting(FIGHTING(ch));
    act("$n fails to retreat, catching $N's attention!", TRUE, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("You notice $n trying to escape and attack $m!", FALSE, ch, 0, FIGHTING(ch), TO_VICT);
    send_to_char("You fail to retreat, and catch the attention of your opponent!\r\n", ch);
    attack(FIGHTING(ch), ch);
  }
  else {
    act("$n stumbles and trips as $e fails to retreat!", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You stumble and trip as you try to retreat!\r\n", ch);
    if (GET_LEVEL(ch) < LVL_GOD) {
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
    }
  }
d940 4
a943 3
  improve_skill_offensively(ch, vict, SKILL_RETREAT);
  WAIT_STATE(ch, PULSE_VIOLENCE);
}
d945 1
d947 4
a950 42
ACMD(do_gretreat)
{
  int dir, opponents, was_in, to_room;
  struct char_data *tch;
  struct follow_type *k, *next_k;
  bool realopponents;

  if (!ch || !argument)
    return;

  if (!GET_SKILL(ch, SKILL_GROUP_RETREAT)) {
    send_to_char("Try flee instead!\r\n", ch);
    return;
  }

  if (!FIGHTING(ch)) {
    send_to_char("You're not fighting anyone!\r\n", ch);
    return;
  }

  argument = one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Retreat where!?\r\n", ch);
    return;
  }

  dir = searchblock(arg, dirs, FALSE);

  if (dir < 0 || !EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) {
    send_to_char("You can't retreat that way!\r\n", ch);
    return;
  }

  was_in = ch->in_room;

  for (tch = world[was_in].people; tch; tch = tch->next_in_room)
    if (FIGHTING(tch) == ch) {
      ++opponents;
      if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
         realopponents = TRUE;
    }
d952 6
a957 2
  /*
   * Can the followers see the leader before he leaves?
a958 2
  for (k = ch->followers; k; k = k->next)
    k->can_see_master = CAN_SEE(k->follower, ch);
d960 35
a994 31
  if (!opponents)
    send_to_char("You must be tanking to successfully lead your group in retreat!\r\n", ch);
  else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) < opponents * number(20, 24))
    send_to_char("There are too many opponents to retreat from!\r\n", ch);

  /* Successful retreat? */
  else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) > number(0, 81) &&
      !ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_DEATH) &&
      CAN_GO(ch, dir) && do_simple_move(ch, dir, TRUE)) {
    stop_fighting(ch);

    /* Echo line back to the original room. */
    sprintf(buf, "$n carefully retreats from combat, leading $s group %s.", dirs[dir]);
    to_room = ch->in_room;
    ch->in_room = was_in;
    act(buf, TRUE, ch, 0, 0, TO_ROOM);
    ch->in_room = to_room;

    sprintf(buf, "\r\nYou skillfully lead your group %s.\r\n", dirs[dir]);
    send_to_char(buf, ch);

    for (k = ch->followers; k; k = next_k) {
      next_k = k->next;
      if (k->follower->in_room == was_in &&
          GET_STANCE(k->follower) >= STANCE_FIGHTING &&
          k->can_see_master && (!FIGHTING(k->follower) ||
          FIGHTING(FIGHTING(k->follower)) == ch)) {
        stop_fighting(k->follower);
        abort_casting(k->follower);
        act("You follow $N.", FALSE, k->follower, 0, ch, TO_CHAR);
        perform_move(k->follower, dir, 1, FALSE);
d996 1
a996 10
    }
  }
  else {
    act("$n stumbles and trips as $e fails to retreat!", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You stumble and trip as you try to retreat!\r\n", ch);
    if (GET_LEVEL(ch) < LVL_GOD) {
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
    }
  }
d998 2
a999 3
  if (realopponents)
    improve_skill(ch, SKILL_GROUP_RETREAT);
  WAIT_STATE(ch, PULSE_VIOLENCE);
d1003 1
a1003 2

ACMD(do_bash)
d1005 4
a1008 2
  struct char_data *vict;
  int percent, prob, skill, rounds;
d1010 1
a1010 21
  switch (subcmd) {
  case SCMD_BODYSLAM:
    skill = SKILL_BODYSLAM;
    break;
  case SCMD_MAUL:
    skill = SKILL_MAUL;
    break;
  case SCMD_BASH:
  default:
    skill = SKILL_BASH;
    break;
  }

  if (!GET_SKILL(ch, skill)) {
    send_to_char("You're not really sure how...\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
      send_to_char("&8It's just too dark!&0", ch);
a1011 1
    }
d1013 2
a1014 2
    if (EFF_FLAGGED(ch, EFF_BLIND)) {
      send_to_char("You can't see a thing!\r\n", ch);
d1016 1
a1016 1
    }
d1018 2
a1019 2
    if (skill == SKILL_BODYSLAM && FIGHTING(ch)) {
      send_to_char("You can't bodyslam in combat...\r\n", ch);
d1021 1
a1021 1
    }
d1023 1
a1023 5
    if (skill == SKILL_MAUL &&
        (!EFF_FLAGGED(ch, EFF_BERSERK) || !EFF_FLAGGED(ch, EFF_SPIRIT_BEAR))) {
      send_to_char("You're not angry enough to tear them limb from limb.\r\n", ch);
      return;
    }
d1025 2
a1026 3
    if (GET_COOLDOWN(ch, CD_BASH)) {
      sprintf(buf, "You haven't reoriented yourself for another %s yet!\r\n", skills[skill].name);
      send_to_char(buf, ch);
d1028 1
a1028 2
    }
  }
d1030 1
a1030 1
  one_argument(argument, arg);
d1032 2
a1033 5
  if (!(vict = get_char_room_vis(ch, arg))) {
    vict = FIGHTING(ch);
    if (!vict || IN_ROOM(ch) != IN_ROOM(vict) || !CAN_SEE(ch, vict)) {
      sprintf(buf, "%s who?\r\n", skills[skill].name);
      send_to_char(CAP(buf), ch);
d1035 1
a1035 102
    }
  }

  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  if (vict == ch->guarding) {
    send_to_char("You cannot do that while you are guarding them.\r\n",ch);
    return;
  }

  /* check for pk/pets/shapeshifts */
  if (!attack_ok(ch, vict, TRUE))
    return;
  vict = check_guard(ch, vict, FALSE);
  if (!attack_ok(ch, vict, TRUE))
    return;

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  prob = GET_SKILL(ch, skill);
  percent = number(1, 101); /* 101 is a complete failure */
  switch (skill) {
  case SKILL_BODYSLAM:
    prob = number(1, 100); /* bodyslam uses random num instead of skill */
    prob += GET_LEVEL(ch);
    prob += GET_HITROLL(ch) - monk_weight_penalty(ch);
    percent += GET_SKILL(vict, SKILL_DODGE);
    percent += GET_LEVEL(vict);
    rounds = 3;
    break;
  case SKILL_BASH:
    if (GET_EQ(ch, WEAR_2HWIELD)) /* 2H wield precludes a shield */
      prob /= 2;
    else if (!GET_EQ(ch, WEAR_SHIELD))
      prob /= 10; /* no shield or 2h weapon: 10% skill */
    rounds = 2;
    break;
  case SKILL_MAUL:
    rounds = 2;
    break;
  }

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = prob + 1; /* insta-fail */
  if (GET_POS(vict) <= POS_SITTING)
    percent = prob + 1; /* insta-fail */
  if (GET_LEVEL(vict) >= LVL_IMMORT)
    percent = prob + 1; /* insta-fail */

  if (prob > percent && damage_evasion(vict, ch, 0, DAM_CRUSH)) {
    act(EVASIONCLR "You charge right through $N&7&b!&0",
          FALSE, ch, 0, vict, TO_CHAR);
    act(EVASIONCLR "$n&" EVASIONCLR " charges right through $N" EVASIONCLR "!&0",
          FALSE, ch, 0, vict, TO_NOTVICT);
    act(EVASIONCLR "$n&" EVASIONCLR " charges right through you!&0",
          FALSE, ch, 0, vict, TO_VICT);
    send_to_char("You fall down!\r\n", ch);
    act("$n falls down!", FALSE, ch, 0, 0, TO_ROOM);
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_ALERT;
    return;
  }

  if (GET_SIZE(vict) - GET_SIZE(ch) > 1) {
    sprintf(buf, "&7&bYou fall over as you try to %s someone so large!&0\r\n", skills[skill].name);
    send_to_char(buf, ch);
    act("&7&b$n BOUNCES off $N, as $e tries to $t $N's much larger size.&0",
        FALSE, ch, (void *) skills[skill].name, vict, TO_NOTVICT);
    act("&7&b$n BOUNCES off you as $e tries to $t your much larger size.&0",
        FALSE, ch, (void *) skills[skill].name, vict, TO_VICT);
    percent = prob + 1; /* insta-fail */
  }
  else if (GET_SIZE(ch) - GET_SIZE(vict) > 2) {
    sprintf(buf, "&7&bYou fall over as you try to %s someone with such small size.&0\r\n", skills[skill].name);
    send_to_char(buf, ch);
    act("&7&b$n trips over $N, as $e tries to $t $N's much smaller size.&0",
        FALSE, ch, (void *) skills[skill].name, vict, TO_NOTVICT);
    act("&7&b$n trips over you as $e tries to $t your much smaller size.&0",
        FALSE, ch, (void *) skills[skill].name, vict, TO_VICT);
    percent = prob + 1; /* insta-fail */
  }

  if (prob > percent) {
    WAIT_STATE(vict, PULSE_VIOLENCE * rounds);
    alter_pos(vict, POS_SITTING, STANCE_ALERT);
    damage(ch, vict, GET_LEVEL(ch) >> 1, skill);
  }
  else {
    if (skill == SKILL_BASH && !GET_EQ(ch, WEAR_SHIELD))
      send_to_char("You need to wear a shield to make it a success!\r\n", ch);
    alter_pos(ch, POS_SITTING, STANCE_ALERT);
    damage(ch, vict, 0, skill);
  }

  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
  SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE * 2);
  improve_skill_offensively(ch, vict, skill);
}
d1037 1
d1039 6
d1046 5
a1050 35
ACMD(do_rescue)
{
  struct char_data *vict, *tmp_ch;
  int percent, prob;

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("Whom do you want to rescue?\r\n", ch);
    return;
  }
  if (vict == ch) {
    send_to_char("What about fleeing instead?\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  if (FIGHTING(ch) == vict) {
    send_to_char("How can you rescue someone you are trying to kill?\r\n", ch);
    return;
  }
  for (tmp_ch = world[ch->in_room].people; tmp_ch &&
	 (FIGHTING(tmp_ch) != vict); tmp_ch = tmp_ch->next_in_room);

  if (!tmp_ch) {
    act("But nobody is fighting $M!", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (GET_SKILL(ch, SKILL_RESCUE) == 0)
    send_to_char("But only true warriors can do this!\r\n", ch);
  else {
    percent = number(1, 101);	/* 101% is a complete failure */
    prob = GET_SKILL(ch, SKILL_RESCUE);
d1052 9
a1060 15
    if (percent > prob) {
      send_to_char("You fail the rescue!\r\n", ch);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      improve_skill_offensively(ch, tmp_ch, SKILL_RESCUE);
      return;
    }
    send_to_char("Banzai!  To the rescue...\r\n", ch);
    act("You are rescued by $N, you are confused!", FALSE, vict, 0, ch, TO_CHAR);
    act("$n heroically rescues $N!", FALSE, ch, 0, vict, TO_NOTVICT);

    if (FIGHTING(vict) == tmp_ch)
      stop_fighting(vict);
    if (FIGHTING(tmp_ch))
      stop_fighting(tmp_ch);
    if (FIGHTING(ch))
d1063 6
a1068 2
    set_fighting(ch, tmp_ch);
    set_fighting(tmp_ch, ch);
d1070 2
a1071 2
    WAIT_STATE(ch, PULSE_VIOLENCE);
    WAIT_STATE(vict, PULSE_VIOLENCE + 2);
d1073 21
a1093 1
  }
d1095 4
a1098 1
  improve_skill_offensively(ch, tmp_ch, SKILL_RESCUE);
a1099 1
}
d1102 1
a1102 1
ACMD(do_kick)
d1104 2
a1105 7
  struct char_data *vict;
  int percent, prob;

  if (GET_SKILL(ch, SKILL_KICK) == 0) {
    send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
    return;
  }
d1107 12
d1120 2
a1121 11
  one_argument(argument, arg);

  if ( !(vict = get_char_room_vis(ch, arg)) )
  {
    if (FIGHTING(ch))
    {
      vict = FIGHTING(ch);
    }
    else
    {
      send_to_char("Kick who?\r\n", ch);
d1123 1
a1123 41
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }

  if (!attack_ok(ch, vict, TRUE))
    return;

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  /* Need to see whether this player is fighting already. Kick should not
     allow for the player to switch without a switch probability being
     calculated into the mix. (DEMOLITUM) */
  WAIT_STATE(ch, PULSE_VIOLENCE);
  if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
    return;

  percent = ((10 - ((GET_AC(vict)+(monk_weight_penalty(vict)*5)) / 10)) << 1) + number(1, 101);
  prob = GET_SKILL(ch, SKILL_KICK);	
  if (percent > prob) {
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    damage(ch, vict, 0, SKILL_KICK);
  } else {
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    if (damage_evasion(vict, ch, 0, DAM_CRUSH)) {
       act(EVASIONCLR "Your foot passes harmlessly through $N" EVASIONCLR "!&0",
             FALSE, ch, 0, vict, TO_CHAR);
       act(EVASIONCLR "$n&7&b sends $s foot whistling right through $N" EVASIONCLR ".&0",
             FALSE, ch, 0, vict, TO_NOTVICT);
       act(EVASIONCLR "$n" EVASIONCLR
             " tries to kick you, but $s foot passes through you harmlessly.&0",
             FALSE, ch, 0, vict, TO_VICT);
       return;
    }
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_KICK);
  }
  improve_skill_offensively(ch, vict, SKILL_KICK);
}
d1125 5
d1131 4
a1134 5
ACMD(do_eye_gouge)
{
  struct char_data *vict;
  int percent, prob;
  struct effect eff;
d1136 4
a1139 4
  if (GET_SKILL(ch, SKILL_EYE_GOUGE) == 0) {
    send_to_char("You would do such a despicable act!?  Horrible!\r\n", ch);
    return;
  }
d1141 5
a1145 4
  if (EFF_FLAGGED(ch, EFF_BLIND)) {
    send_to_char("It's going to be hard to gouge someone's eyes out if you can't even see.\r\n", ch);
    return;
  }
d1147 6
a1152 1
  one_argument(argument, arg);
d1154 1
d1156 1
a1156 2
  if (!*arg) {
    if (FIGHTING(ch))
d1158 13
a1170 2
    else {
      send_to_char("Whose eyes do you want to gouge out?\r\n", ch);
d1172 1
a1172 5
    }
  } else if (!(vict = get_char_room_vis(ch, arg))) {
     send_to_char("Nobody here by that name.\r\n", ch);
     return;
  }
d1174 315
a1488 59
  if (FIGHTING(ch) && FIGHTING(ch) != vict) {
    send_to_char("You need to be facing each other for this to work.\r\n", ch);
    return;
  }

  if (vict == ch) {
    send_to_char("That would make life difficult, wouldn't it?\r\n", ch);
    return;
  }

  /* check pk/pets/shapeshifts */
  if (!attack_ok(ch, vict, TRUE))
    return;

  if (GET_COOLDOWN(ch, CD_EYE_GOUGE)) {
    send_to_char("You aren't able to find an opening yet!\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) < LVL_GOD)
    SET_COOLDOWN(ch, CD_EYE_GOUGE, 3 * PULSE_VIOLENCE);

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  percent = number(1, 101);
  prob = GET_SKILL(ch, SKILL_EYE_GOUGE);
  WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
  if (percent > prob && AWAKE(vict))
    damage(ch, vict, 0, SKILL_EYE_GOUGE); /* Miss message */
  else if (damage_evasion(vict, ch, 0, DAM_PIERCE)) {
    act(EVASIONCLR "Your thumbs poke harmlessly at $N" EVASIONCLR
          ".  If $E even has eyes.",
          FALSE, ch, 0, vict, TO_CHAR);
    act(EVASIONCLR "$n" EVASIONCLR " tries poking at $N's eyes, but nothing seems to happen.",
          FALSE, ch, 0, vict, TO_NOTVICT);
    act(EVASIONCLR "$n" EVASIONCLR " pokes fruitlessly at you with $s thumbs.",
          FALSE, ch, 0, vict, TO_VICT);
    return;
  } else if (GET_LEVEL(vict) >= LVL_IMMORT && GET_LEVEL(vict) > GET_LEVEL(ch)) {
    act("Ouch!  You hurt your thumbs trying to poke out $N's eyes!",
          FALSE, ch, 0, vict, TO_CHAR);
    act("$n tries poking out $N's eyes - what a laugh!",
          FALSE, ch, 0, vict, TO_NOTVICT);
    act("$n pokes harmlessly at your eyes with $s thumbs.",
          FALSE, ch, 0, vict, TO_VICT);
    return;
  } else {
    if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !EFF_FLAGGED(vict, EFF_BLIND)) {
      memset(&eff, 0, sizeof(eff));
      eff.type = SKILL_EYE_GOUGE;
      eff.duration = 2 + GET_SKILL(ch, SKILL_EYE_GOUGE) / 48;
      eff.modifier = 0;
      eff.location = APPLY_NONE;
      SET_FLAG(eff.flags, EFF_BLIND);
      effect_to_char(vict, &eff);
    }
    damage(ch, vict, (GET_SKILL(ch, SKILL_EYE_GOUGE) + percent) >> 2, SKILL_EYE_GOUGE);
  }
d1490 2
a1491 2
  if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !EFF_FLAGGED(vict, EFF_BLIND))
    improve_skill_offensively(ch, vict, SKILL_EYE_GOUGE);
d1497 2
a1498 2
  struct char_data *vict;
  int percent, prob;
d1500 4
a1503 14
  if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_DARKNESS)) {
    send_to_char("&8It is too dark!&0", ch);
    return;
  }

  if (!GET_SKILL(ch, SKILL_SPRINGLEAP))  {
    send_to_char("You'd better leave all the martial arts to monks.\r\n", ch);
    return;
  }

  if (GET_POS(ch) > POS_SITTING) {
    send_to_char("You can't spring from that position, try sitting!\r\n", ch);
    return;
  }
d1505 4
a1508 1
  one_argument(argument, arg);
d1510 2
a1511 5
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch))
      vict = FIGHTING(ch);
    else {
      send_to_char("&0Spring-leap whom?&0\r\n", ch);
d1513 1
a1513 2
    }
  }
d1515 1
a1515 4
  if (vict == ch)  {
    send_to_char("That might hurt too much...\r\n", ch);
    return;
  }
d1517 8
a1524 3
  /* check pk/pets/shapeshifts */
  if (!attack_ok(ch, vict, TRUE))
    return;
d1526 4
a1529 2
  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);
d1531 6
a1536 1
  percent = number(6, 77) - (GET_AC(vict) + (5 * monk_weight_penalty(vict))) / 20;
d1538 1
a1538 1
  prob = GET_SKILL(ch, SKILL_SPRINGLEAP);
d1540 1
a1540 2
  if (GET_POS(vict) <= POS_SITTING)
    percent = 101;
d1542 2
a1543 2
  if (GET_STANCE(vict) < STANCE_FIGHTING)
    prob -= 20;
d1545 26
a1570 7
  if (percent > prob) {
    act("&0&6You try to take $N down but you spring over his head!&0", FALSE, ch, 0, vict, TO_CHAR);
    act("&0&6$N springs from the ground at you but soars over your head!&0", FALSE, vict, 0, ch, TO_CHAR);
    act("&0&6$N springs from the ground at $n but misses by a mile!&0", FALSE, vict, 0, ch, TO_NOTVICT);
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    damage(ch, vict, 0, SKILL_SPRINGLEAP);
    if (AWAKE(ch)) {
d1573 41
a1613 57
    }
  }
  else if (damage_evasion(vict, ch, 0, DAM_CRUSH)) {
    act(EVASIONCLR "You hurtle right through $N" EVASIONCLR
          " and land in a heap on the other side!",
          FALSE, ch, 0, vict, TO_CHAR);
    act(EVASIONCLR "$n" EVASIONCLR " leaps at $N" EVASIONCLR
          " but flies right on through!",
          FALSE, ch, 0, vict, TO_NOTVICT);
    act(EVASIONCLR "$n" EVASIONCLR
          " comes flying at you, but just passes through and hits the ground.",
          FALSE, ch, 0, vict, TO_VICT);
    /* You fall */
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_ALERT;
    return;
  } else if (percent > 0.95 * prob) {
    act("&0&6You manage to take $N down but also &bfall down yourself!&0",
          FALSE, ch, 0, vict, TO_CHAR);
    act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0",
          FALSE, vict, 0, ch, TO_CHAR);
    act("&0&6$N springs from the ground, knocking $n down and &bfalling in the process!&0",
          FALSE, vict, 0, ch, TO_NOTVICT);
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
    if (AWAKE(vict) && IN_ROOM(ch) == IN_ROOM(vict)) {
      abort_casting(vict);
      GET_POS(vict) = POS_SITTING;
      GET_STANCE(vict) = STANCE_ALERT;
    }
    if (AWAKE(ch)) {
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
    }
  }
  else {
    act("&0&b&8You spring from the ground, knocking $N off balance.&0",
          FALSE, ch, 0, vict, TO_CHAR);
    act("&0&b&8$N springs from the ground and knocks you down!&0",
          FALSE, vict, 0, ch, TO_CHAR);
    act("&0&b&8$N springs from the ground, knocking $n down!&0",
          FALSE, vict, 0, ch, TO_NOTVICT);
    WAIT_STATE(ch, PULSE_VIOLENCE);
    WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
    if (AWAKE(vict) && IN_ROOM(ch) == IN_ROOM(vict)) {
      abort_casting(vict);
      GET_POS(vict) = POS_SITTING;
      GET_STANCE(vict) = STANCE_ALERT;
    }
    if (AWAKE(ch)) {
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = FIGHTING(ch) ? STANCE_FIGHTING : STANCE_ALERT;
    }
  }
d1615 1
a1615 1
  improve_skill_offensively(ch, vict, SKILL_SPRINGLEAP);
d1621 107
a1727 107
  struct char_data *vict;
  struct effect eff;
  struct obj_data *weapon;
  int random, chance, percent, dam, newExp, position;
  char buf1[255];
  char buf2[255];
  char buf3[255];
  char stop_buf1[255];
  char stop_buf2[255];
  bool sling = FALSE, skipcast = FALSE;

  if (GET_COOLDOWN(ch, CD_THROATCUT)) {
    send_to_char("You've drawn too much attention to yourself to throatcut now!\r\n", ch);
    return;
  }

  random = dice(1,6);

  if ((GET_LEVEL(ch) < LVL_IMMORT) && (GET_SKILL(ch, SKILL_THROATCUT) == 0)){
    send_to_char("You aren't skilled enough!\r\n", ch);
    return;
  }

  if (FIGHTING(ch)){
    send_to_char("You can't be stealthy enough to do this while fighting!\n\r",ch);
    return;
  }

  if (RIDING(ch)){
    send_to_char("Cut someone's throat while riding???  I don't think so!\n\r",ch);
    return;
  }

  one_argument(argument, buf);

  if ((!(vict = get_char_room_vis(ch, buf)))&& (!(vict == ch))){
    send_to_char("Cut whose throat?\r\n", ch);
    return;
  }

  if (vict == ch){
    send_to_char("Hey, life's not that bad!\r\n", ch);
    return;
  }

  /* Got a weapon? Any weapon? */
  weapon = GET_EQ(ch, WEAR_WIELD);
  position = WEAR_WIELD;
  if (!weapon) {
     weapon = GET_EQ(ch, WEAR_WIELD2);
     position = WEAR_WIELD2;
   }
  if (!weapon) {
     weapon = GET_EQ(ch, WEAR_2HWIELD);
     position = WEAR_2HWIELD;
   }

  if (!weapon) {
    send_to_char("&0You need to wield a weapon to make it a success.&0\r\n", ch);
    return;
  }

  /* If wielding something unsuitable in first hand, use weapon in second hand */
  if (!IS_WEAPON_PIERCING(weapon) && GET_EQ(ch, WEAR_WIELD2))
     weapon = GET_EQ(ch, WEAR_WIELD2);

  if (!IS_WEAPON_PIERCING(weapon)) {
    send_to_char("&0Only piercing weapons can be used for throat cutting.&0\r\n", ch);
    return;
  }

  if (FIGHTING(vict)) {
    send_to_char("&0You can't cut the throat of a fighting person -- they're too alert!&0\r\n", ch);
    return;
  }

  if (!attack_ok(ch, vict, TRUE))
    return;

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  /* Can't throatcut dragons, nor mobs that are twice your size */
  if (GET_RACE(vict) == RACE_DRAGON)
  {
     send_to_char("Cut the throat... of a dragon... RIGHT!!!!!\r\n", ch);
     return;
  }
  else if ((GET_SIZE(vict) > GET_SIZE(ch) + 2) || (GET_SIZE(vict) < GET_SIZE(ch) - 2))
  {
    send_to_char("Maybe if you were close to the same size it would work!!\r\n", ch);
    return;
  }

  SET_COOLDOWN(ch, CD_THROATCUT, 3 MUD_HR);


  percent = dice(1,100);

  if ((MOB_FLAGGED(vict, MOB_AWARE) || EFF_FLAGGED(vict, EFF_AWARE)) && AWAKE(vict))
  {
    act("You notice $N sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N sneaking up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    attack(vict, ch);
    return;
  }
d1729 1
a1729 1
  chance = GET_SKILL(ch, SKILL_THROATCUT) - GET_LEVEL(vict) + 90;
d1732 1
a1732 1
    chance += 1000;
d1735 4
a1738 1
   chance += 1000; /* sleeping should always be a coup de grace */
d1740 22
a1761 2
  if (!CAN_SEE(vict, ch))
    chance += 15;
d1763 14
a1776 37
  switch(world[vict->in_room].sector_type)
  {
  case SECT_CITY:         chance += 15; break;
  case SECT_FIELD:        chance -= 10; break;
  case SECT_ROAD:         chance -=  5; break;
  case SECT_BEACH:        chance -= 10; break;
  case SECT_GRASSLANDS:   chance -= 10; break;
  case SECT_FOREST:       chance -= 15; break;
  case SECT_RUINS:        chance +=  5; break;
  case SECT_SWAMP:        chance -= 20; break;
  case SECT_WATER_SWIM:   chance -= 50; break;
  case SECT_WATER_NOSWIM: chance -= 75; break;
  case SECT_FLYING:       chance += 20; break;
  default:                chance +=  0; break;
  }

  if ((!IS_NPC(vict)) && (GET_LEVEL(vict) >= LVL_IMMORT))
  {
    act("$N laughs out loud at your miserable attempt!&0", FALSE, ch, 0, vict, TO_CHAR);
    act("$n just tried to cut your throat. &0&6How cute!&0", FALSE, ch, 0, vict, TO_VICT);
    return;
  }

   /* you get tense when someone tries to cut your throat! */
  memset(&eff, 0, sizeof(eff));
  eff.type = SKILL_AWARE;
  eff.duration = 5;
  eff.modifier = 0;
  eff.location = APPLY_NONE;
  SET_FLAG(eff.flags, EFF_AWARE);
  effect_to_char(vict, &eff);

  if (chance > 95)
    {
      random = 7;
      chance = 95;
    }
d1778 2
a1779 2
  /*  sprintf(buf, "&7&bYour roll: %d, your skill (chance): %d, and your random: %d, victim->level: %d.&0", percent, chance, random, GET_LEVEL(vict));
  act(buf, FALSE, ch, 0, vict, TO_CHAR); */
d1781 54
a1834 117
    /* The moment of excitement! */
  if ( percent < chance )
  {
     if (damage_evasion(vict, ch, weapon, DAM_PIERCE)) {
        damage_evasion_message(ch, vict, weapon, DAM_PIERCE);
        return;
     }
     /* Switch for dam %.  1 & 6: really goods, 2 & 5: decent, 3 & 4: common shaving nicks, 7 mega, 8 miss penalty */
     switch(random)
     {
       case 1:
       case 6:
	 dam = (GET_MAX_HIT(vict) * 3) / 4;
	 newExp = (GET_EXP(vict) * 3) /4; /* rip same % exp from the mob... since they're doing less work! */

	 sprintf(buf1, "&1&bYou nearly sever the head of $N with %s.&0", weapon->short_description);
	 sprintf(buf2,  "&1&b$n nearly severs your head with %s!&0" , weapon->short_description);
	 sprintf(buf3,  "&1&b$n nearly severs the head of $N with %s!&0", weapon->short_description);
	 sprintf(stop_buf1, "Your profuse bleeding interrupts your chanting!");
	 sprintf(stop_buf2, "$n stops chanting abruptly!");
	 break;
       case 2:
       case 5:
	 dam = GET_MAX_HIT(vict) / 4;
	 newExp = GET_EXP(vict) / 4; /* rip same % exp from the mob... since they're doing less work! */

	 sprintf(buf1, "&1&bBlood splatters all over you as you cut into $N with %s.&0", weapon->short_description);
	 sprintf(buf2, "&1&bBlood splatters all over $n as $e cuts into you with %s!&0", weapon->short_description);
	 sprintf(buf3, "&1&bBlood splatters all over $n as $e dices $N with %s!&0", weapon->short_description);
	 sprintf(stop_buf1, "Your chanting is interrupted by your coughing up blood!");
	 sprintf(stop_buf2, "$n stops chanting abruptly!");
	 break;
        case 3:
	case 4:
          dam = GET_MAX_HIT(vict) / 8;
	  newExp = GET_EXP(vict) / 8; /* rip same % exp from the mob... since they're doing less work! */

	  sprintf( buf1,  "&1&b$N gasps as you slice into $S throat with %s.&0", weapon->short_description);
          sprintf(buf2,  "&1&bYou gasp with fear as $n slices into your throat with %s!&0", weapon->short_description);
          sprintf(buf3,  "&1&b$N looks horrified as $n slices into $S throat with %s!&0", weapon->short_description);
	 sprintf(stop_buf1, "Your gasp abruptly interrupts your chanting!");
	 sprintf(stop_buf2, "$n stops chanting abruptly!");
	  break;
      case 7:
	 dam = (GET_MAX_HIT(vict) * 9) / 10;
	 newExp = (GET_EXP(vict) * 9) / 10; /* rip same % exp from the mob... since they're doing less work! */

	  sprintf(buf1,  "&1&bBlood spews everywhere as you nearly incapacitate $N with %s.&0", weapon->short_description);
	  sprintf(buf2,  "&1&bBlood spews everywhere as $n nearly incapacitates you with %s!&0", weapon->short_description);
          sprintf(buf3,  "&1&bBlood spews everywhere as $n nearly incapacitates $N with %s!&0", weapon->short_description);
	  sprintf(stop_buf1, "Your chanting is interrupted by your gurgling of blood!");
	  sprintf(stop_buf2, "$n stops chanting abruptly!");
	 break;
	default: break;
      }
  }
  else if ((percent > chance) && (dice(1,100) < 11))
  {
    dam = 0;
    sling = TRUE;
    skipcast = TRUE;
    newExp = 0; /* rip same % exp from the mob... since they're doing less work! */

    sprintf(buf1, "&3&bMidway, you trip and fall which sends %s flying from your hand.&0", weapon->short_description);
    sprintf(buf2, "&3&b$n trips and falls, losing %s in a botched attempt on your life!&0", weapon->short_description);
    sprintf(buf3, "&3&b$n trips and falls, losing %s while trying to kill $N!&0", weapon->short_description);

  }
  else
  {
    dam = 0;
    skipcast = TRUE;
    newExp = 0; /* rip same % exp from the mob... since they're doing less work! */

    /* If we want silent misses for non-critical misses.. remove the act txt */
    sprintf(buf1, "&3&b$N jumps back before you have a chance to even get close!&0");
    sprintf(buf2, "&3&b$n just tried to cut your throat!&0");
    sprintf(buf3, "&3&b$n misses $N with $s throat cut!&0");
  }


  if (IS_NPC(vict))
    GET_EXP(vict) = MAX(1, GET_EXP(vict) - newExp); /* make sure we don't have negative exp gain for ch */

  if (damage_amounts)
  {
    if (dam <=0)
      sprintf(buf, " (&1%d&0)", dam);
    else
      sprintf(buf, " (&3%d&0)", dam);

    strcat(buf1,buf);
    act(buf1, FALSE, ch, NULL, vict, TO_CHAR);

    strcat(buf2,buf);
    act(buf2, FALSE, ch, NULL, vict, TO_VICT);

    strcat(buf3,buf);
    act(buf3, FALSE, ch, NULL, vict, TO_NOTVICT);
  }
  else
  {
    act(buf1, FALSE, ch, NULL, vict, TO_CHAR);
    act(buf2, FALSE, ch, NULL, vict, TO_VICT);
    act(buf3, FALSE, ch, NULL, vict, TO_NOTVICT);
  }

  GET_HIT(vict) -= dam;
  damage(ch, vict, 0, SKILL_THROATCUT);

   if (sling) {
      if (position == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD2)) {
         struct obj_data* temp;
         unequip_char(ch,WEAR_WIELD);
         temp = unequip_char(ch, WEAR_WIELD2);
         if (temp != NULL) {
            equip_char(ch, temp, WEAR_WIELD);
a1835 13
      } else {
         unequip_char(ch, position);
      }
      if (IS_OBJ_STAT(weapon, ITEM_NODROP)) { /* Cursed? */
         act("&3&bYour&0 $o &3&bmagically returns to your&0 &B&3inventory!&0",
               TRUE, ch, weapon, NULL, TO_CHAR);
         act("$n's &0 $o&3&b magically returns to $s&0 &B&3inventory!&0",
               TRUE, ch, weapon, NULL, TO_ROOM);
         obj_to_char(weapon, ch);
      } else {
         /* place the weapon in the room */
         obj_to_room(weapon, ch->in_room);
      }
d1837 37
d1875 2
a1876 1
  improve_skill_offensively(ch, vict, SKILL_THROATCUT);
d1878 44
a1921 6
  if (!skipcast && CASTING(vict)) {
      STOP_CASTING(vict);
      act(stop_buf1, FALSE, vict, 0, 0, TO_CHAR);
      act(stop_buf2, FALSE, vict, 0, 0, TO_ROOM);
  }
  return;
d1927 2
a1928 2
   struct obj_data *obj, *ch_obj;		/* Object to disarm */
   struct char_data *tch, *vict = NULL;	/* Target */
d2172 24
a2195 11
  struct char_data *mob, *next_mob;
  byte percent;
  bool hit_all = FALSE, realvictims = FALSE;

  if (!ch || ch->in_room == NOWHERE)
    return;

  if (subcmd == SCMD_TANTRUM) {
    if (!GET_SKILL(ch, SKILL_TANTRUM)) {
      send_to_char("You throw a hissy-fit, hoping someone will notice you.\r\n", ch);
      act("$n sobs to $mself loudly, soliciting attention.", TRUE, ch, 0, 0, TO_ROOM);
d2197 3
a2199 3
    }
    if (!EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're not feeling quite up to throwing a tantrum right now.\r\n", ch);
d2201 52
a2252 65
    }
  }
  else if (!GET_SKILL(ch, SKILL_HITALL)) {
    send_to_char("You don't know how to.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE)){
    send_to_char("Sorry, it's too cramped here for nasty maneuvers!\r\n", ch);
    return;
  }

  /* Find out whether to hit "all" or just aggressive monsters */
  one_argument(argument, arg);
  if (!str_cmp(arg, "all") || subcmd == SCMD_TANTRUM)
    hit_all = 1;

  /* Hit all aggressive monsters in room */

  percent = number(1, 131);
  WAIT_STATE(ch, PULSE_VIOLENCE);

  if (subcmd == SCMD_TANTRUM) {
    act("$n flings $s limbs around wildly, swiping at everything nearby!", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You throw an incensed tantrum, attacking all nearby!\r\n", ch);
    if (GET_SKILL(ch, SKILL_TANTRUM) < percent)
      return;
  }
  else {
    act("$n makes a concerted circular attack at everything nearby!", FALSE, ch, 0, 0, TO_NOTVICT);
    send_to_char("You spin in a circle, attempting to hit everything within range.\r\n", ch);
    if (GET_SKILL(ch, SKILL_HITALL) < percent)
      return;
  }


  for (mob = world[ch->in_room].people; mob; mob = next_mob) {
    next_mob = mob->next_in_room;

    /* Skip self */
    if (ch == mob)
      continue;
	
    /* Skip anyone grouped with ch */
    if (is_grouped(mob, ch))
      continue;

    /* Skip mobs following */
    if (mob->master == ch)
      continue;
	
    if (!attack_ok(ch, mob, FALSE))
      continue;

    if (!hit_all && !is_aggr_to(mob, ch) && FIGHTING(mob) != ch)
      continue;

    if (damage_evasion(mob, ch, 0, physical_damtype(ch))) {
          damage_evasion_message(ch, mob, equipped_weapon(ch), physical_damtype(ch));
    } else {
      if (!MOB_FLAGGED(mob, MOB_ILLUSORY))
        realvictims = TRUE;
d2254 6
a2259 6
      if (subcmd == SCMD_TANTRUM && number(0, 1))
        hit(ch, mob, SKILL_BAREHAND);
      else
        attack(ch, mob);
    }
  }
d2261 2
a2262 2
  if (realvictims)
    improve_skill(ch, SKILL_HITALL);
d2267 2
a2268 2
  struct char_data *vict;
  int chance;
d2270 4
a2273 42
  if (!GET_SKILL(ch, SKILL_CORNER)) {
    send_to_char("You aren't skilled enough to corner an opponent!\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  /* You can only corner the person you're fighting. */
  if (!*arg && FIGHTING(ch))
    vict = FIGHTING(ch);
  else if (!(vict = get_char_room_vis(ch, arg)) || vict != FIGHTING(ch)) {
    send_to_char("You have to be fighting someone to corner them!\r\n", ch);
    return;
  }

  if (CONFUSED(ch)) {
    send_to_char("You're far too confused to corner anyone.\r\n", ch);
    return;
  }

  if (ch->cornering) {
    if (ch->cornering->cornered_by == ch)
      ch->cornering->cornered_by = NULL;
    ch->cornering = NULL;
  }

  chance = GET_SKILL(ch, SKILL_CORNER);
  chance += 3 * dex_app[GET_DEX(ch)].reaction;
  chance += 10 * (GET_SIZE(ch) - GET_SIZE(vict));
  chance += (GET_LEVEL(ch) - GET_LEVEL(vict)) / 2;
  if (!CAN_SEE(vict, ch))
    chance *= 2;

  if (chance > number(1, 101)) {
    act("You stand in $N's way, cornering $M!", FALSE, ch, 0, vict, TO_CHAR);
    act("$n stands in your way, cornering you!", FALSE, ch, 0, vict, TO_VICT);
    act("$n stands in $N's way, cornering $M!", TRUE, ch, 0, vict, TO_NOTVICT);
    ch->cornering = vict;
    vict->cornered_by = ch;
  }
  else
    act("You attempt to corner $N, but $E evades you!", FALSE, ch, 0, vict, TO_CHAR);
d2275 40
a2314 2
  WAIT_STATE(ch, PULSE_VIOLENCE);
  improve_skill_offensively(ch, vict, SKILL_CORNER);
d2320 10
a2329 2
  struct char_data *vict;
  int dam;
d2331 17
a2347 2
  if (!ch)
    return;
d2349 7
a2355 11
  if (GET_SKILL(ch, SKILL_PECK) <= 0) {
    send_to_char("How do you expect to do that?\r\n", ch);
    return;
  }

  one_argument(argument, arg);
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch))
      vict = FIGHTING(ch);
    else {
      send_to_char("Peck whom?\r\n", ch);
a2356 28
    }
  }
  if (ch == vict) {
    send_to_char("Ouch, that hurts!\r\n", ch);
    return;
  }

  /* Is this attack allowed? */
  if (!attack_ok(ch, vict, TRUE))
    return;

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  WAIT_STATE(ch, PULSE_VIOLENCE);

  /* If attacking someone else, check switch skill. */
  if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
    return;

  /* Determine the damage amount.  0 is a miss. */
  if (number(0, 101) > GET_SKILL(ch, SKILL_PECK))
    dam = 0;
  else if (damage_evasion(vict, ch, 0, DAM_PIERCE)) {
     damage_evasion_message(ch, vict, 0, DAM_PIERCE);
     return;
  } else
    dam = number(GET_SKILL(ch, SKILL_PECK), GET_LEVEL(ch));
d2358 11
a2368 2
  damage(ch, vict, dam, SKILL_PECK);
  improve_skill_offensively(ch, vict, SKILL_PECK);
d2374 5
a2378 2
  struct char_data *vict;
  int dam;
d2380 4
a2383 2
  if (!ch)
    return;
d2385 25
a2409 11
  if (GET_SKILL(ch, SKILL_CLAW) <= 0) {
    send_to_char("Grow some longer fingernails first!\r\n", ch);
    return;
  }

  one_argument(argument, arg);
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch))
      vict = FIGHTING(ch);
    else {
      send_to_char("Claw whom?\r\n", ch);
a2410 28
    }
  }
  if (ch == vict) {
    send_to_char("Ouch, that hurts!\r\n", ch);
    return;
  }

  /* Can we allow this attack to occur? */
  if (!attack_ok(ch, vict, TRUE))
    return;

  if (CONFUSED(ch))
     vict = random_attack_target(ch, vict, TRUE);

  WAIT_STATE(ch, PULSE_VIOLENCE);

  /* If attacking someone else, check skill in switch. */
  if (FIGHTING(ch) && FIGHTING(ch) != vict && !switch_ok(ch))
    return;

  /* Determine damage amount. */
  if (number(0, 101) > GET_SKILL(ch, SKILL_CLAW))
    dam = 0;
  else if (damage_evasion(vict, ch, 0, DAM_SLASH)) {
     damage_evasion_message(ch, vict, 0, DAM_SLASH);
     return;
  } else
    dam = number(GET_SKILL(ch, SKILL_CLAW), GET_LEVEL(ch));
d2412 11
a2422 2
  damage(ch, vict, dam, SKILL_CLAW);
  improve_skill_offensively(ch, vict, SKILL_CLAW);
d2427 2
a2428 2
  if (!ch || ch->in_room == NOWHERE)
    return;
d2430 4
a2433 14
  if (GET_SKILL(ch, SKILL_ELECTRIFY) <= 0) {
    send_to_char("Good luck with that one!\r\n", ch);
    return;
  }

  if (GET_SKILL(ch, SKILL_ELECTRIFY) > number(0, 101))
    mag_area(GET_SKILL(ch, SKILL_ELECTRIFY), ch, SKILL_ELECTRIFY, SAVING_BREATH);
  else {
    if (IS_WATER(ch->in_room))
      send_to_char("The water around you sizzles, but you are unable to gather any power...\r\n", ch);
    else
      send_to_char("The air around you crackles, but you are unable to gather any power...\r\n", ch);
    act("A quick spike of electricity runs across $n's skin.", TRUE, ch, 0, 0, TO_ROOM);
  }
d2435 12
a2446 2
  improve_skill(ch, SKILL_ELECTRIFY);
  WAIT_STATE(ch, PULSE_VIOLENCE);
d2451 1
a2451 1
  struct effect eff;
d2453 8
a2460 8
  memset(&eff, 0, sizeof(eff));
  eff.type = SKILL_BERSERK;
  eff.duration = 1000; /* arbitrarily long time */
  eff.modifier = 0;
  eff.location = APPLY_NONE;
  SET_FLAG(eff.flags, EFF_BERSERK);
  effect_to_char(ch, &eff);
  check_regen_rates(ch);
d2464 5
a2468 5
  effect_from_char(ch, SKILL_BERSERK);
  effect_from_char(ch, CHANT_SPIRIT_WOLF);
  effect_from_char(ch, CHANT_SPIRIT_BEAR);
  effect_from_char(ch, CHANT_INTERMINABLE_WRATH);
  GET_RAGE(ch) = 0;
d2473 15
a2487 15
  if (!GET_SKILL(ch, SKILL_BERSERK)) {
    send_to_char("You flail your arms about, acting like a crazy person.\r\n", ch);
    act("$n goes berserk, thrashing about the area.", FALSE, ch, 0, 0, TO_ROOM);
    return;
  }

  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're already out of control!\r\n", ch);
    return;
  }

  if (GET_RAGE(ch) < RAGE_ANGRY) {
    send_to_char("You're not angry enough yet!\r\n", ch);
    return;
  }
d2489 2
a2490 2
  send_to_char("You feel your blood begin to boil, and your self-control starts to slip...\r\n", ch);
  act("$n's eyes flash and anger clouds $s face.", TRUE, ch, 0, 0, TO_ROOM);
d2492 1
a2492 1
  start_berserking(ch);
d2498 1
a2498 1
 * interpreter.  If the cmd number is wrong, and the command gets passed
d2503 2
a2504 2
  struct char_data *tch, *next_tch;
  bool real_victims = FALSE;
d2506 1
a2506 1
  extern ACMD(do_action);
d2508 45
a2552 45
  if (!GET_SKILL(ch, SKILL_GROUND_SHAKER) ||
      !EFF_FLAGGED(ch, EFF_SPIRIT_BEAR) ||
      !EFF_FLAGGED(ch, EFF_BERSERK)) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }

  if (!OUTSIDE(ch)) {
    send_to_char("You MUST be crazy, trying to do that in here!\r\n", ch);
    return;
  }

  send_to_char("&8&3You stomp one foot on the ground heavily, shaking the earth!&0\r\n", ch);
  act("&8&3$n crashes a foot into the ground, causing it to crack around $m...&0", TRUE, ch, 0, 0, TO_ROOM);

  for (tch = world[IN_ROOM(ch)].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

    if (tch == ch)
      continue;
    if (is_grouped(ch, tch))
      continue;
    if (!attack_ok(ch, tch, FALSE))
      continue;
    if (PRF_FLAGGED(tch, PRF_NOHASSLE))
      continue;
    if (GET_POS(tch) == POS_FLYING)
      continue;

    if (!damage_evasion(tch, ch, 0, DAM_CRUSH)) {
       if (!MOB_FLAGGED(tch, MOB_ILLUSORY))
         real_victims = TRUE;

       if (GET_DEX(tch) < number(0, 100))
         damage(ch, tch, number(50, GET_SKILL(ch, SKILL_GROUND_SHAKER)), SKILL_GROUND_SHAKER);
       else if (GET_STR(tch) < number(0, 100)) {
         if (GET_POS(tch) > POS_SITTING) {
           damage(ch, tch, 0, SKILL_GROUND_SHAKER);
           if (IN_ROOM(ch) == IN_ROOM(tch))
             alter_pos(tch, POS_KNEELING, STANCE_ALERT);
           WAIT_STATE(ch, PULSE_VIOLENCE);
         }
       }
    }
  }
d2554 3
a2556 3
  if (real_victims)
    improve_skill(ch, SKILL_GROUND_SHAKER);
  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d2561 3
@


1.176
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.175 2008/05/11 05:56:04 jps Exp jps $
d365 1
a365 1
    send_to_char("You can't help yourself any more than this!\r\n", ch);
d2561 3
@


1.175
log
@Changed slow_death. Calling alter_pos for position changes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.174 2008/05/10 16:20:08 jps Exp jps $
d569 1
a569 1
  alter_hit(victim, ch, GET_MAX_HIT(victim) + 20, FALSE);
d2561 3
@


1.174
log
@Used EVASIONCLR for many evasion messages.
Fixed evading kicks.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.173 2008/04/14 02:32:31 jps Exp jps $
d31 1
a524 4
/*NEW SLOW PAINFULL DEATH Banyal */
/*Stock code did not allow for a pc/npc to die w/o a killer
  this clashed with toggle vicious poisened etc so here is a
  slow painfull death*/
d529 1
a529 1
  if ((!victim) || (victim == NULL)) {
d542 1
a542 1
        update_pos(victim);
a559 2
  void disburse_kill_exp(struct char_data *ch, struct char_data *victim);

d569 1
a569 5
  alter_hit(victim, GET_MAX_HIT(victim) + 20, FALSE);
  act("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
  send_to_char("You are dead!\r\n", victim);
  disburse_kill_exp(ch, victim);
  die(victim, ch);
d1250 1
a1251 7
    /* Victim might flee */
    if (IN_ROOM(ch) == IN_ROOM(vict)) {
      GET_POS(vict) = POS_SITTING;
      GET_STANCE(vict) = STANCE_ALERT;
      abort_casting(vict);
      update_pos(vict);
    }
d1256 1
a1257 2
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_ALERT;
a1262 1
  update_pos(ch);
d1903 4
a1906 2
         act("&3&bYour&0 $o &3&bmagically returns to your&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_CHAR);
         act("$n's &0 $o&3&b magically returns to $s&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_ROOM);
a1913 1
  update_pos(vict);
d1916 1
a1916 1
  if(!skipcast && CASTING(vict)) {
d2546 2
a2547 6
           if (IN_ROOM(ch) == IN_ROOM(tch)) {
             GET_POS(tch) = POS_KNEELING;
             GET_STANCE(tch) = STANCE_ALERT;
             abort_casting(tch);
             update_pos(tch);
           }
d2561 4
@


1.173
log
@Consolidate the loss of hiddenness when being violent into a single
function.  It also removes glory.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.172 2008/04/13 20:53:50 jps Exp jps $
d328 5
a332 1
    if (damage_evasion(tch, ch, 0, DAM_CRUSH))
d334 1
d1224 6
a1229 3
    act("&7&bYou charge right through $N&7&b!&0", FALSE, ch, 0, vict, TO_CHAR);
    act("&7&b$n&7&b charges right through $N&7&b!&0", FALSE, ch, 0, vict, TO_NOTVICT);
    act("&7&b$n&7&b charges right through you!&0", FALSE, ch, 0, vict, TO_VICT);
d1396 4
d1401 1
a1401 1
       act("&7&bYour foot passes harmlessly through $N&7&b!&0",
d1403 1
a1403 1
       act("&7&b$n&7&b sends $s foot whistling right through $N&7&b.&0",
d1405 2
a1406 1
       act("&7&b$n&7&b tries to kick you, but $s foot passes through you harmlessly.&0",
a1409 4
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
    damage(ch, vict, 0, SKILL_KICK);
  } else {
    WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
d1478 2
a1479 1
    act("Your thumbs poke harmlessly at $N.  If $E even has eyes.",
d1481 1
a1481 1
    act("$n tries poking at $N's eyes, but nothing seems to happen.",
d1483 1
a1483 1
    act("$n pokes fruitlessly at you with $s thumbs.",
d1577 2
a1578 1
    act("You hurtle right through $N and land in a heap on the other side!",
d1580 2
a1581 1
    act("$n leaps at $N but flies right on through!",
d1583 2
a1584 1
    act("$n comes flying at you, but just passes through and hits the ground.",
d1592 6
a1597 3
    act("&0&6You manage to take $N down but also &bfall down yourself!&0", FALSE, ch, 0, vict, TO_CHAR);
    act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0", FALSE, vict, 0, ch, TO_CHAR);
    act("&0&6$N springs from the ground, knocking $n down and &bfalling in the process!&0", FALSE, vict, 0, ch, TO_NOTVICT);
d1612 6
a1617 3
    act("&0&b&8You spring from the ground, knocking $N off balance.&0", FALSE, ch, 0, vict, TO_CHAR);
    act("&0&b&8$N springs from the ground and knocks you down!&0", FALSE, vict, 0, ch, TO_CHAR);
    act("&0&b&8$N springs from the ground, knocking $n down!&0", FALSE, vict, 0, ch, TO_NOTVICT);
d2581 4
@


1.172
log
@When you're confused, your offensive acts will tend to be
directed to random targets.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.171 2008/04/12 21:13:18 jps Exp jps $
d46 1
d49 10
d2562 4
@


1.171
log
@Using new header file magic.h.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.170 2008/04/07 03:02:54 jps Exp jps $
d91 27
d363 2
d420 3
a422 1
    else if (!FIGHTING(ch) || switch_ok(ch))
d424 1
d641 3
d1174 3
d1364 3
d1449 3
d1531 3
d1687 3
d2007 4
d2271 5
d2335 3
d2389 3
d2551 3
@


1.170
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.169 2008/04/05 05:04:24 myc Exp jps $
d30 1
a43 1
int mag_savingthrow(struct char_data * ch, int type);
d2486 4
@


1.169
log
@Turned off slow_death log message.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.168 2008/04/04 21:42:28 jps Exp myc $
d200 1
a200 1
    if (GET_POS(tch) < POS_SLEEPING)
d220 1
a220 1
    if (GET_POS(tch) == POS_SLEEPING) {
d227 1
a227 1
        GET_STANCE(tch) = STANCE_SITTING;
d231 1
a231 1
    else if (GET_DEX(tch) - 15 < number(0, 100) && GET_POS(tch) >= POS_FIGHTING) {
d235 1
a235 1
      GET_STANCE(tch) = STANCE_SITTING;
d284 1
a284 1
    if (GET_VIEWED_DEX(tch) - 15 > number(0, 100) || GET_POS(tch) < POS_FIGHTING)
d296 1
a296 1
    GET_STANCE(tch) = STANCE_SITTING;
d450 1
a450 1
      (GET_POS(victim) == POS_DEAD) ||
d683 1
a683 1
   if (GET_POS(vict) == POS_DEAD)
d808 1
a808 1
  if (GET_POS(ch) > POS_SLEEPING && (IS_NPC(ch) ? GET_MOB_WAIT(ch) : CHECK_WAIT(ch))) {
d818 5
a822 5
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
  case POS_STUNNED:
d825 1
a825 1
  case POS_SLEEPING:
d828 42
a869 36
  case POS_SITTING:
  case POS_RESTING:
    abort_casting(ch);
    act("Looking panicked, $n scrambles madly to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You scramble madly to your feet!\r\n", ch);
    GET_POS(ch) = POS_STANDING;
    if (IS_NPC(ch))
       WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    break;
  case POS_STANDING:
  case POS_FIGHTING:
  case POS_FLYING:
    if (IS_CORNERED(ch)) {
      act("$n tries to flee, but is unable to escape from $N!", TRUE, ch, 0, ch->cornered_by, TO_NOTVICT);
      act("$n tries to flee, but is unable to escape from you!", TRUE, ch, 0, ch->cornered_by, TO_VICT);
      act("PANIC!  You couldn't escape from $N!", TRUE, ch, 0, ch->cornered_by, TO_CHAR);
      return;
    }
    for (i = 0; i < 6; i++) {    /* Make 6 attempts */
      attempt = number(0, NUM_OF_DIRS - 1);	/* Select a random direction */

      if (CAN_GO(ch, attempt) &&
          !ROOM_FLAGGED(EXIT(ch, attempt)->to_room, ROOM_DEATH)) {
        abort_casting(ch);
        act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
        if (do_simple_move(ch, attempt, TRUE)) {
          sprintf(buf, "&0You panic and flee %s!&0\r\n", dirs[attempt]);
          send_to_char(buf, ch);
          if (FIGHTING(ch)) {
            if (FIGHTING(FIGHTING(ch)) == ch)
              stop_fighting(FIGHTING(ch));
            stop_fighting(ch);
          }
        } else
          act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
        return;
d871 3
a874 6
    /* All 6 attempts failed! */
    act("$n tries to flee, but PANICS instead!", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("PANIC!  You couldn't escape!\r\n", ch);
    break;
  default:
    log("SYSERR:act.offensive.c:do_flee:Unknown position.");
d952 1
a952 1
      GET_STANCE(ch) = STANCE_SITTING;
d1034 1
a1034 1
          GET_POS(k->follower) >= POS_FIGHTING &&
d1049 1
a1049 1
      GET_STANCE(ch) = STANCE_SITTING;
d1164 1
a1164 1
  if (GET_STANCE(vict) != STANCE_STANDING || GET_POS(vict) <= POS_SITTING)
d1177 1
a1177 1
    GET_STANCE(ch) = STANCE_SITTING;
d1206 1
a1206 1
      GET_STANCE(vict) = STANCE_SITTING;
d1216 1
a1216 1
    GET_STANCE(ch) = STANCE_SITTING;
d1411 1
a1411 1
  if (percent > prob && GET_POS(vict) > POS_SLEEPING)
d1491 1
a1491 1
  if (GET_STANCE(vict) <= STANCE_RESTING || GET_POS(vict) <= POS_SITTING)
d1494 1
a1494 1
  if (GET_POS(vict) < POS_FIGHTING)
d1505 1
a1505 1
      GET_STANCE(ch) = STANCE_SITTING;
d1518 1
a1518 1
    GET_STANCE(ch) = STANCE_SITTING;
d1530 1
a1530 1
      GET_STANCE(vict) = STANCE_SITTING;
d1534 1
a1534 1
      GET_STANCE(ch) = STANCE_SITTING;
d1547 1
a1547 1
      GET_STANCE(vict) = STANCE_SITTING;
d1550 2
a1551 2
      GET_POS(ch) = FIGHTING(ch) ? POS_FIGHTING : POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
d1671 1
a1671 1
 if (GET_POS(vict)<=POS_SLEEPING)
d2465 1
a2465 1
         if (GET_POS(tch) > POS_SITTING && GET_STANCE(tch) > STANCE_KNEELING) {
d2468 2
a2469 2
             GET_POS(tch) = POS_SITTING;
             GET_STANCE(tch) = STANCE_KNEELING;
d2486 3
@


1.168
log
@Make imms immune to gouging.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.167 2008/04/03 02:02:05 myc Exp jps $
a489 7
  if (GET_POS(victim) == POS_DEAD) {
     sprintf(buf, "ATTN: %s is experiencing slow_death, but is already dead.",
           GET_NAME(victim));
     mudlog(buf, BRF, LVL_GOD, FALSE);
     return;
  }

a490 1

d2483 3
@


1.167
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.166 2008/04/02 19:42:15 myc Exp myc $
d1426 8
d2491 3
@


1.166
log
@Disarm move cost varies with skill now.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.165 2008/04/02 03:24:44 myc Exp myc $
d202 4
d276 4
d2483 3
@


1.165
log
@Cleaned up death code.  Increased bash lag.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.164 2008/03/30 16:04:21 jps Exp myc $
d1851 1
a1851 4

#define DISARM_MOVEMENT		10

   int pos, ch_pos, chance, rnd_num, skl_bonus;
d1875 2
d1878 1
a1878 1
   if (GET_MOVE(ch) < DISARM_MOVEMENT) {
d2087 1
a2087 1
      alter_move(ch, DISARM_MOVEMENT);
a2088 2

#undef DISARM_MOVEMENT
d2475 3
@


1.164
log
@Cancel other events when you're about to die.  This may prevent
those 'double deaths' from recurring.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.163 2008/03/28 17:54:53 myc Exp jps $
a44 1
void die(struct char_data * ch, struct char_data * killer);
a500 6
  if (GET_LEVEL(victim) >= LVL_IMMORT) {
    GET_POS(victim) = POS_STANDING;
    alter_hit(victim, -20, TRUE);
    return;
  }

a509 15
  /*check for switch. Original char loses exp*/
  if (victim->desc && victim->desc->original)
    gain_exp(victim->desc->original, NULL, -(GET_EXP(victim->desc->original) >> 1));
  else
    gain_exp(victim, NULL, -(GET_EXP(victim) >> 1));

  if (EFF_FLAGGED(victim, EFF_ON_FIRE))
    REMOVE_FLAG(EFF_FLAGS(victim), EFF_ON_FIRE);
  if (!IS_NPC(victim)) {
    REMOVE_FLAG(PLR_FLAGS(victim), PLR_KILLER);
    REMOVE_FLAG(PLR_FLAGS(victim), PLR_THIEF);
    GET_COND(victim, THIRST) = 24;
    GET_COND(victim, FULL) = 24;
    GET_COND(victim, DRUNK) = 0;}

d515 1
a515 1
  void receive_kill_credit(struct char_data *ch, struct char_data *vict);
d529 1
a529 1
  receive_kill_credit(ch, victim);
d1060 1
a1060 1
  int percent, prob, skill;
d1145 1
d1152 1
d1155 1
d1198 1
a1198 1
    WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
d2478 4
@


1.163
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.162 2008/03/27 22:34:44 jps Exp myc $
d483 7
d2497 4
@


1.162
log
@Return backstab cooldown to 6 seconds.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.161 2008/03/26 18:14:55 jps Exp jps $
d105 1
a105 1
  if (GET_SKILL(ch, SKILL_BREATHE) < 1 || IS_AFFECTED(ch, AFF_CHARM)) {
d141 1
a141 1
    if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
d163 2
a164 2
        !AFF3_FLAGGED(ch, AFF3_SPIRIT_WOLF) ||
        !AFF_FLAGGED(ch, AFF_BERSERK)) {
d176 1
a176 1
  else if (!GET_SKILL(ch, SKILL_ROAR) || AFF_FLAGGED(ch, AFF_CHARM)) {
d181 1
a181 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d215 1
a215 1
    mag_affects(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
d237 1
a237 1
    if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
d260 1
a260 1
  if (GET_SKILL(ch, SKILL_SWEEP) < 1 || IS_AFFECTED(ch, AFF_CHARM)) {
d291 1
a291 1
    if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
d365 1
a365 1
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS))
d367 1
a367 1
  else if (AFF_FLAGGED(ch, AFF_BLIND))
d377 1
a377 1
  else if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master == vict))
d396 1
a396 1
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
d516 2
a517 2
  if (IS_AFFECTED2(victim, AFF2_ON_FIRE))
    REMOVE_BIT(AFF2_FLAGS(victim), AFF2_ON_FIRE);
d519 2
a520 1
    REMOVE_BIT(PLR_FLAGS(victim), PLR_KILLER | PLR_THIEF);
d533 1
a533 1
        (ch && MOB2_FLAGGED(ch, MOB2_ILLUSORY)))
d550 1
a550 1
   struct affected_type af;
d598 1
a598 1
   if (AFF_FLAGGED(ch, AFF_BLIND)) {
d652 8
a659 9
      if (!AFF3_FLAGGED(vict, AFF3_AWARE)) {
         af.type = SKILL_AWARE;
         af.duration = 2;
         af.modifier = 0;
         af.location = APPLY_NONE;
         af.bitvector = 0;
         af.bitvector2 = 0;
         af.bitvector3 = AFF3_AWARE;
         affect_to_char(vict, &af);
d666 1
a666 1
   if (AFF3_FLAGGED(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict))
d669 1
a669 1
   if (AFF3_FLAGGED(vict, AFF3_AWARE) && FIGHTING(vict))
d702 8
a709 9
   if (!AFF3_FLAGGED(vict, AFF3_AWARE)) {
      af.type = SKILL_AWARE;
      af.duration = 2;
      af.modifier = 0;
      af.location = APPLY_NONE;
      af.bitvector = 0;
      af.bitvector2 = 0;
      af.bitvector3 = AFF3_AWARE;
      affect_to_char(vict, &af);
d723 1
a723 1
   if (AFF3_FLAGGED(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
d727 1
a727 1
   if (IS_AFFECTED3(vict, AFF3_AWARE) && FIGHTING(vict))
d773 1
a773 1
    if (IS_AFFECTED(ch, AFF_CHARM)) {
d782 1
a782 1
      if ((vict->master != ch) || !IS_AFFECTED(vict, AFF_CHARM))
d801 1
a801 1
	  if (IS_AFFECTED(k->follower, AFF_CHARM)) {
d828 1
a828 1
  if (FIGHTING(ch) && AFF_FLAGGED(ch, AFF_BERSERK)) {
d865 1
a865 1
          !IS_SET(ROOM_FLAGS(EXIT(ch, attempt)->to_room), ROOM_DEATH)) {
d1012 1
a1012 1
      if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
d1096 1
a1096 1
    if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
d1101 1
a1101 1
    if (AFF_FLAGGED(ch, AFF_BLIND)) {
d1112 1
a1112 1
        (!AFF_FLAGGED(ch, AFF_BERSERK) || !AFF3_FLAGGED(ch, AFF3_SPIRIT_BEAR))) {
d1368 1
a1368 1
  struct affected_type af;
d1375 1
a1375 1
  if (AFF_FLAGGED(ch, AFF_BLIND)) {
d1431 8
a1438 9
    if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !IS_AFFECTED(vict, AFF_BLIND)) {
      af.type = SKILL_EYE_GOUGE;
      af.duration = 2 + GET_SKILL(ch, SKILL_EYE_GOUGE) / 48;
      af.modifier = 0;
      af.location = APPLY_NONE;
      af.bitvector = AFF_BLIND;
      af.bitvector2 = 0;
      af.bitvector3 = 0;
      affect_to_char(vict, &af);
d1443 1
a1443 1
  if (!MOB_FLAGGED(vict, MOB_NOBLIND) && !AFF_FLAGGED(vict, AFF_BLIND))
d1453 1
a1453 1
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
d1563 1
a1563 1
  struct affected_type af;
d1585 1
a1585 1
  if (IS_FIGHTING(ch)){
d1658 1
a1658 1
  if ((MOB_FLAGGED(vict, MOB_AWARE) || IS_AFFECTED3(vict, AFF3_AWARE)) && AWAKE(vict))
d1702 7
a1708 8
  af.type = SKILL_AWARE;
  af.duration = 5;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = 0;
  af.bitvector2 = 0;
  af.bitvector3 = AFF3_AWARE;
  affect_to_char(vict, &af);
d2121 1
a2121 1
    if (!AFF_FLAGGED(ch, AFF_BERSERK)) {
d2187 1
a2187 1
      if (!MOB2_FLAGGED(mob, MOB2_ILLUSORY))
d2361 1
a2361 1
    mag_areas(GET_SKILL(ch, SKILL_ELECTRIFY), ch, SKILL_ELECTRIFY, SAVING_BREATH);
d2376 1
a2376 1
  struct affected_type af;
d2378 7
a2384 8
  af.type = SKILL_BERSERK;
  af.duration = 1000; /* arbitrarily long time */
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_BERSERK;
  af.bitvector2 = 0;
  af.bitvector3 = 0;
  affect_to_char(ch, &af);
d2389 4
a2392 4
  affect_from_char(ch, SKILL_BERSERK);
  affect_from_char(ch, CHANT_SPIRIT_WOLF);
  affect_from_char(ch, CHANT_SPIRIT_BEAR);
  affect_from_char(ch, CHANT_INTERMINABLE_WRATH);
d2404 1
a2404 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
d2434 2
a2435 2
      !AFF3_FLAGGED(ch, AFF3_SPIRIT_BEAR) ||
      !AFF_FLAGGED(ch, AFF_BERSERK)) {
d2463 1
a2463 1
       if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
d2490 3
@


1.161
log
@Passing attacker and weapon into damage_evasion() so that
ethereal creatures may be vulnerable to blessed physical
attacks.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.160 2008/03/25 21:58:59 jps Exp jps $
d649 1
a649 1
      SET_COOLDOWN(ch, CD_BACKSTAB, 12 * PULSE_COOLDOWN);
d695 2
a696 2
   /* 12 seconds == 3 combat rounds.*/
   SET_COOLDOWN(ch, CD_BACKSTAB, PULSE_COOLDOWN * 12);
d2494 5
@


1.160
log
@Replaced dam_earth with dam_crush.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.159 2008/03/25 05:31:28 jps Exp jps $
d283 1
a283 1
    if (damage_evasion(tch, DAM_CRUSH))
d623 1
a623 1
   if (damage_evasion(vict, DAM_PIERCE)) {
d1179 1
a1179 1
  if (prob > percent && damage_evasion(vict, DAM_CRUSH)) {
d1346 1
a1346 1
    if (damage_evasion(vict, DAM_CRUSH)) {
d1423 1
a1423 1
  else if (damage_evasion(vict, DAM_PIERCE)) {
d1511 1
a1511 1
  else if (damage_evasion(vict, DAM_CRUSH)) {
d1725 1
a1725 1
     if (damage_evasion(vict, DAM_PIERCE)) {
d2187 1
a2187 1
    if (damage_evasion(mob, physical_damtype(ch))) {
d2292 1
a2292 1
  else if (damage_evasion(vict, DAM_PIERCE)) {
d2343 1
a2343 1
  else if (damage_evasion(vict, DAM_SLASH)) {
d2466 1
a2466 1
    if (!damage_evasion(tch, DAM_CRUSH)) {
d2494 3
@


1.159
log
@Including chars.h.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.158 2008/03/25 04:50:08 jps Exp jps $
d2466 1
a2466 1
    if (!damage_evasion(tch, DAM_EARTH)) {
d2494 3
@


1.158
log
@Do immunity checks for the appropriate type of damage in these
various skills.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.157 2008/03/24 08:07:01 jps Exp jps $
d29 1
d2494 4
@


1.157
log
@Use CD_ constants when setting cooldowns for backstab and gouge.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.156 2008/03/19 18:43:58 myc Exp jps $
d282 2
d622 5
d1178 12
d1345 9
d1422 9
a1430 1
  else {
d1510 13
a1522 1
  else if (percent > 0.95 * prob) {
d1702 1
a1702 1
   /*sucks you get tense when someone tries to cut your throat! Banyal */
d1724 4
d2186 11
a2196 7
    if (!MOB2_FLAGGED(mob, MOB2_ILLUSORY))
      realvictims = TRUE;

    if (subcmd == SCMD_TANTRUM && number(0, 1))
      hit(ch, mob, SKILL_BAREHAND);
    else
      attack(ch, mob);
d2291 4
a2294 1
  else
d2342 4
a2345 1
  else
d2465 18
a2482 16
    if (!MOB2_FLAGGED(tch, MOB2_ILLUSORY))
      real_victims = TRUE;

    if (GET_DEX(tch) < number(0, 100))
      damage(ch, tch, number(50, GET_SKILL(ch, SKILL_GROUND_SHAKER)), SKILL_GROUND_SHAKER);
    else if (GET_STR(tch) < number(0, 100)) {
      if (GET_POS(tch) > POS_SITTING && GET_STANCE(tch) > STANCE_KNEELING) {
        damage(ch, tch, 0, SKILL_GROUND_SHAKER);
        if (IN_ROOM(ch) == IN_ROOM(tch)) {
          GET_POS(tch) = POS_SITTING;
          GET_STANCE(tch) = STANCE_KNEELING;
          abort_casting(tch);
          update_pos(tch);
        }
        WAIT_STATE(ch, PULSE_VIOLENCE);
      }
d2493 3
@


1.156
log
@Added newlines to the bash messages for too big/small.  Fixed hitall
and tantrum to not hit when attack_ok returns false.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.155 2008/03/18 06:16:29 jps Exp myc $
d688 1
a688 1
   SET_COOLDOWN(ch, SKILL_BACKSTAB, PULSE_COOLDOWN * 12);
d1387 1
a1387 1
    SET_COOLDOWN(ch, SKILL_EYE_GOUGE, 3 * PULSE_VIOLENCE);
d2429 4
@


1.155
log
@Removing unused function prototypes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.154 2008/03/17 15:31:27 myc Exp jps $
d1172 1
a1172 1
    sprintf(buf, "&7&bYou fall over as you try to %s someone so large!&0", skills[skill].name);
d1181 1
a1181 1
    sprintf(buf, "&7&bYou fall over as you try to %s someone with such small size.&0", skills[skill].name);
d2128 3
d2429 3
@


1.154
log
@Lowered cooldown for throatcut to about what it was before.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.153 2008/03/11 19:50:55 myc Exp myc $
a39 1
void hit2(struct char_data * ch, struct char_data * victim, int type);
a40 1
void make_corpse(struct char_data * ch);
a44 1
int mem_inMemory(struct char_data *ch, struct char_data *vict);
d2426 3
@


1.153
log
@Make maul and ground shaker require spirit of the bear, battle howl
require spirit of the wolf, and tantrum have a random chance to hit
with a weapon.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.152 2008/03/10 20:46:55 myc Exp myc $
d1609 1
a1609 1
  SET_COOLDOWN(ch, CD_THROATCUT, 5 MUD_HR);
d2429 5
@


1.152
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.151 2008/03/10 18:01:17 myc Exp myc $
d164 3
a166 1
    if (!GET_SKILL(ch, SKILL_BATTLE_HOWL) || !AFF_FLAGGED(ch, AFF_BERSERK)) {
d1107 2
a1108 1
    if (skill == SKILL_MAUL && !AFF_FLAGGED(ch, AFF_BERSERK)) {
d2137 1
a2137 1
    if (subcmd == SCMD_TANTRUM)
d2374 3
a2376 1
  if (!GET_SKILL(ch, SKILL_GROUND_SHAKER) || !AFF_FLAGGED(ch, AFF_BERSERK)) {
d2429 3
@


1.151
log
@Added new berserker skills: battle howl, maul, tantrum, and ground shaker.
Battle howl is a subcommand of roar, maul is a subcommand of bash, and
tantrum is a subcommand of hitall.  Also made bodyslam a subcommand of
bash.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.150 2008/03/09 18:11:05 jps Exp myc $
d224 1
a224 1
        GET_POS1(tch) = POS1_SITTING;
d232 1
a232 1
      GET_POS1(tch) = POS1_SITTING;
d287 1
a287 1
    GET_POS1(tch) = POS_SITTING;
d958 1
a958 1
      GET_POS1(ch) = POS1_SITTING;
d1055 1
a1055 1
      GET_POS1(ch) = POS1_SITTING;
d1166 1
a1166 1
  if (GET_POS1(vict) != POS1_STANDING || GET_POS(vict) <= POS_SITTING)
d1196 1
a1196 1
      GET_POS1(vict) = POS1_SITTING;
d1206 1
a1206 1
    GET_POS1(ch) = POS1_SITTING;
d1457 1
a1457 1
  if (GET_POS1(vict) <= POS1_RESTING || GET_POS(vict) <= POS_SITTING)
d1471 1
a1471 1
      GET_POS1(ch) = POS1_SITTING;
d1484 1
a1484 1
      GET_POS1(vict) = POS1_SITTING;
d1488 1
a1488 1
      GET_POS1(ch) = POS1_SITTING;
d1501 1
a1501 1
      GET_POS1(vict) = POS1_SITTING;
d1505 1
a1505 1
      GET_POS1(ch) = POS_STANDING;
d1606 1
a1606 1
  SET_COOLDOWN(ch, CD_THROATCUT, 5 * SECS_PER_MUD_HOUR RL_SEC);
d2404 1
a2404 1
      if (GET_POS(tch) > POS_SITTING && GET_POS1(tch) > POS1_KNEELING) {
d2408 1
a2408 1
          GET_POS1(tch) = POS1_KNEELING;
d2424 6
@


1.150
log
@perform_move may be misdirected now.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.149 2008/03/08 23:31:30 jps Exp jps $
d163 14
a176 1
  if (GET_SKILL(ch, SKILL_ROAR) < 1 || AFF_FLAGGED(ch, AFF_CHARM)) {
d187 8
a194 2
  act("&9&b$n&9&b makes your soul quake with a vicious &1ROOOOOAAAAAARRRRRR!&0",FALSE, ch,0,0,TO_ROOM);
  act("&9&bYou take a deep breath and release a vicious &1ROOOOOAAAAARRRRRR!&0",FALSE, ch,0,0,TO_CHAR);
d215 2
d219 3
a221 1
        send_to_char("A loud ROAAARRRRRR jolts you from your slumber!\r\n", tch);
a225 1
        mag_affects(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
a233 1
      mag_affects(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
d238 1
a238 1
       realvictims = TRUE;
d241 6
a246 2
  if (realvictims)
    improve_skill(ch, SKILL_ROAR);
d248 1
a248 2
  if (GET_LEVEL(ch) < LVL_IMMORT)
    WAIT_STATE(ch, PULSE_VIOLENCE);
d1065 1
a1065 3
/* Fixed by gurlaek 7/13/1999.  Note: The damage() call must come    */
/* last in the function after POSITION and WAIT have been updated    */
/* otherwise when damage() calls do_flee() it get's screwed hardcore */
d1069 1
a1069 1
  int percent, prob;
d1071 11
a1081 9
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    send_to_char("&8It is just too dark!&0", ch);
    return;
  }

  /* check for previous bash attempt */
  if (GET_COOLDOWN(ch, CD_BASH)) {
    send_to_char("&8You haven't reoriented yourself yet enough for another bash!\r\n", ch);
    return;
d1084 2
a1085 2
  if (AFF_FLAGGED(ch, AFF_BLIND)) {
    send_to_char("You cant see a thing!\r\n", ch);
d1089 3
a1091 11
  one_argument(argument, arg);

  if (GET_SKILL(ch, SKILL_BASH) == 0 ) {
    send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
    return;
  }
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Bash who?\r\n", ch);
a1093 13
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  if (!CAN_SEE(ch, vict)) {
    send_to_char("Bash who?!?\r\n", ch);
    return;
  }
  if (vict == ch->guarding) {
    send_to_char("You cannot do that while you are guarding them.\r\n",ch);
    return;
  }
d1095 2
a1096 44
  if (!attack_ok(ch, vict, TRUE))
    return;

  /* NPC's now get same bash skill as chars -gurlaek 7/11/1999 */
  if (!GET_EQ(ch, WEAR_SHIELD) && !GET_EQ(ch, WEAR_2HWIELD)) {
    send_to_char("You need to wear a shield to make it a success but go ahead and try anyway!\r\n", ch);
    prob = (int)(GET_SKILL(ch, SKILL_BASH) / 10);
  }
  else if (GET_EQ(ch, WEAR_2HWIELD)){
    prob = GET_SKILL(ch, SKILL_BASH)/ 2;
  }
  else
    prob = GET_SKILL(ch, SKILL_BASH);

  percent = number(1, 101); /* 101% is a complete failure */

  /* paladin/anti-paladin get a 20% bash bonus */
  if((GET_CLASS(ch) == CLASS_PALADIN || CLASS_ANTI_PALADIN) &&
     (GET_EQ(ch, WEAR_2HWIELD) && (GET_EQ(ch, WEAR_SHIELD)))) {
    if(prob + 20 < 100)
      prob += 20;
    else
      prob = 100;
  }

  vict = check_guard(ch, vict, FALSE);

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101+20;
  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
    percent = 101+20;

  /* lets be realistic and check relative sizes */
  if (GET_SIZE(ch) < GET_SIZE(vict)) {
    if ((GET_SIZE(vict) - GET_SIZE(ch)) > 1) {
      send_to_char("&7&bYou fall over as you try to bash someone so large.&0", ch);
      act("&7&b$n BOUNCES off $N, as $e tries to bash $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n BOUNCES off you as $e tries to bash your much larger size.&0", FALSE, ch, 0, vict, TO_VICT);
      WAIT_STATE(ch, PULSE_VIOLENCE);  /* lag basher 2 rounds */
      SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE);
      /* damage basher DON'T MOVE!!! */
      damage(ch, vict, 0, SKILL_BASH);
      GET_POS(ch) = POS_SITTING; /* sit down basher */
      GET_POS1(ch) = POS1_SITTING;
d1099 3
a1101 11
  } else { /* I changes this to 2 down 1  up Banyal*/
    if ((GET_SIZE(ch) - GET_SIZE(vict)) > 2) {
      send_to_char("&7&bYou fall over as you try to bash someone with such small size.&0\r\n", ch);
      act("&7&b$n trips over $N, as $e tries to bash $N's much smaller size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n trips over you as $e tries to bash your much smaller size.&0", FALSE, ch, 0, vict, TO_VICT);
      WAIT_STATE(ch, PULSE_VIOLENCE); /* lag basher 2 rounds */
      SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE);
      /* damage basher DON'T MOVE!!! */
      damage(ch, vict, 0, SKILL_BASH);
      GET_POS(ch) = POS_SITTING; /* sit down basher */
      GET_POS1(ch) = POS1_SITTING;
a1103 1
  }
d1105 3
a1107 30
  if (percent > prob) { /* failed bash */
    /* lag basher 4 rounds for bash */
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    /* delay basher */
    SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE);
    /* damage basher DON'T MOVE!!! */
    damage(ch, vict, 0, SKILL_BASH);
    /* sit down basher */
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
  } else { /* ok successful bash! */

    /* ok players can now bash each other */
    if (GET_LEVEL(vict) < LVL_IMMORT || IS_NPC(vict)) {
      /* lag basher 4 rounds for bash */
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      /* lag bashee 3 rounds for being bashed */
      WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
      /* delay basher */
      SET_COOLDOWN(ch, CD_BASH, PULSE_VIOLENCE);
      /* damage basher DON'T MOVE!!! */
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BASH);
      /* -1 = dead, 0 = miss */
      if (IN_ROOM(ch) == IN_ROOM(vict)) {
        /* sit down bashee */
        GET_POS(vict) = POS_SITTING;
        GET_POS1(vict) = POS1_SITTING;
      }
      abort_casting(vict);
      update_pos(vict);
a1108 10
  }
  improve_skill_offensively(ch, vict, SKILL_BASH);
  update_pos(ch);
}

/* see note for do_bash before changing */
ACMD(do_bodyslam)
{
  struct char_data *vict;
  int percent, prob;
d1110 3
a1112 3
   if (!IS_NPC(ch) && !(GET_RACE(ch) == RACE_OGRE ||
         GET_RACE(ch) == RACE_TROLL || GET_RACE(ch) == RACE_BARBARIAN)) {
      send_to_char("You have no idea how...\r\n", ch);
d1114 1
a1114 5
   }

  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    send_to_char("&8It's just too dark!&0", ch);
    return;
a1118 4
  if (FIGHTING(ch)) {
    send_to_char("You can't bodyslam in combat...\r\n", ch);
    return;
  }
d1120 6
a1125 2
    send_to_char("Bodyslam who?\r\n", ch);
    return;
a1139 1

d1141 2
a1142 6
  prob = number(1, 100);
  prob += GET_LEVEL(ch);
  prob += GET_HITROLL(ch) - monk_weight_penalty(ch);
  percent = number(1, 101);
  percent += GET_SKILL(vict, SKILL_DODGE);
  percent += GET_LEVEL(vict);
d1144 19
d1165 23
a1187 28
    percent = prob + 1;
  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
    percent = prob + 1;

  if (GET_SIZE(ch) < GET_SIZE(vict)) {
    if ((GET_SIZE(vict) - GET_SIZE(ch)) > 3) {
      send_to_char("&7&bYou fall over as you try to bodyslam someone so large&0", ch);
      act("&7&b$n BOUNCES off $N, as $e tries to bodyslam $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n BOUNCES off you as $e tries to bodyslam your much larger size&0", FALSE, ch, 0, vict, TO_VICT);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      /* DON'T move damage() call */
      damage(ch, vict, 0, SKILL_BODYSLAM);
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
      return;
    }
  } else {
    if ((GET_SIZE(ch) - GET_SIZE(vict)) > 3) {
      send_to_char("&7&bYou fall over as you try to bash someone with such small size.&0", ch);
      act("&7&b$n trips over $N, as $e tries to bodyslam $N's much smaller size.&0", FALSE, ch, 0, vict, TO_NOTVICT);
      act("&7&b$n trips over you as $e tries to bodyslam your much smaller size.&0", FALSE, ch, 0, vict, TO_VICT);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      /* DON'T move damage() call */
      damage(ch, vict, 0, SKILL_BODYSLAM);
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
      return;
    }
d1190 5
a1194 12
  if (percent > prob) {
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    /* DON'T move damage() call */
    damage(ch, vict, 0, SKILL_BODYSLAM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
  } else {
    if (IS_NPC(vict) || GET_LEVEL(vict) < LVL_IMMORT){
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      WAIT_STATE(vict, PULSE_VIOLENCE * 2);
      /* DON'T move damage() call */
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BODYSLAM);
d1201 11
a1211 1
  improve_skill_offensively(ch, vict, SKILL_BODYSLAM);
d2058 1
a2058 2
  struct char_data  *mob;
  struct char_data  *next_mob;
d2060 1
a2060 2
  int count, hit_all = 0;
  bool realvictims = FALSE;
d2065 12
a2076 3
  one_argument(argument, arg);

  if (!GET_SKILL(ch, SKILL_HITALL)) {
d2088 1
d2090 2
a2091 2

  if (!str_cmp(arg, "all"))
d2096 16
a2111 2
  act("$n makes a concerted circular attack at everything nearby!", FALSE, ch, 0, 0, TO_NOTVICT);
  send_to_char("You spin in a circle, attempting to hit everything within range.\r\n", ch);
d2113 2
a2114 2
  count = 0;
  percent = number(1, 131);
d2116 3
a2118 5
  if (GET_SKILL(ch, SKILL_HITALL) >= percent)
    {
      for (mob = world[ch->in_room].people; mob; mob = next_mob)
	{
	  next_mob = mob->next_in_room;
d2120 7
a2126 3
          /* Skip self */
	  if (ch == mob)
	    continue;
d2128 14
a2141 23
          /* Skip anyone grouped with ch */
	  if (is_grouped(mob, ch))
	    continue;

          /* Skip mobs following */
          if (mob->master == ch)
            continue;
	
	  if (!hit_all)
	    {
	      if (!(is_aggr_to(mob, ch) || (IS_FIGHTING(mob) && (FIGHTING(mob) == ch))))
		continue;
	    }
	
     if (!MOB2_FLAGGED(mob, MOB2_ILLUSORY))
        realvictims = TRUE;
	  attack(ch, mob);
	
	  count++;
	} /* end for() */
    } /* end if(get_skill) */
  if (realvictims) improve_skill(ch, SKILL_HITALL);
  WAIT_STATE(ch, PULSE_VIOLENCE);
d2359 57
d2417 4
d2424 3
@


1.149
log
@Stop using ANIMATED flag as a synonym for CHARM
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.148 2008/03/07 21:21:57 myc Exp jps $
d1022 1
a1022 1
        perform_move(k->follower, dir, 1);
d2425 3
@


1.148
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.147 2008/02/11 21:04:01 myc Exp myc $
d107 1
a107 2
  if (GET_SKILL(ch, SKILL_BREATHE) < 1 ||
      MOB_FLAGGED(ch, MOB_ANIMATED)) {
d163 1
a163 2
  if (GET_SKILL(ch, SKILL_ROAR) < 1 ||
      MOB_FLAGGED(ch, MOB_ANIMATED) || AFF_FLAGGED(ch, AFF_CHARM)) {
d236 1
a236 2
  if (GET_SKILL(ch, SKILL_SWEEP) < 1 ||
      MOB_FLAGGED(ch, MOB_ANIMATED) || IS_AFFECTED(ch, AFF_CHARM)) {
d743 1
a743 1
    if (IS_AFFECTED(ch, AFF_CHARM) && !MOB_FLAGGED(ch, MOB_ANIMATED)) {
d2425 5
@


1.147
log
@Make the breath command skip other mobs if cast by a mob (like area
spells).
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.146 2008/02/09 21:07:50 myc Exp myc $
d415 1
a415 1
  if (ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL])
d436 1
a436 2
  if (number(1, 1000) >= chance)
  {
d438 1
a438 1
    ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL] = (1200 - (GET_LEVEL(ch) * 10));/*delay reduces as level increases*/
d530 1
a530 1
   if (SKILL_DELAY(ch, SKILL_BACKSTAB)) {
d621 1
a621 1
      SKILL_DELAY(ch, SKILL_BACKSTAB) = 12;  /* 12 seconds == 3 combat rounds.*/
d667 2
a668 1
   SKILL_DELAY(ch, SKILL_BACKSTAB) = 12;  /* 12 seconds == 3 combat rounds.*/
d1058 1
a1058 1
  if (ch->char_specials.action_delays[ACT_DELAY_BASH] > 0) {
d1134 1
a1134 1
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75; /* delay basher */
d1147 1
a1147 1
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75; /* delay basher */
d1160 1
a1160 1
    ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
d1175 1
a1175 1
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
a1402 2
  /* Kicking re orients you for bash Banyal */
  ch->char_specials.action_delays[ACT_DELAY_BASH] = 0;
d1461 1
a1461 1
  if (SKILL_DELAY(ch, SKILL_EYE_GOUGE)) {
d1467 1
a1467 1
    SKILL_DELAY(ch, SKILL_EYE_GOUGE) = 3 * 4; /* 3 rounds * 4 secs per round */
d1606 1
a1606 1
  if (SKILL_DELAY(ch, SKILL_THROATCUT)) {
d1686 1
a1686 1
  SKILL_DELAY(ch, SKILL_THROATCUT) = SECS_PER_MUD_HOUR * 5;
d1891 1
a1891 1
void do_disarm(struct char_data *ch, char *arg, int cmd)
a1896 2
   char Gbuf2[MAX_STRING_LENGTH];
   char obj_name[MAX_INPUT_LENGTH];
d1898 2
a1899 3
   struct char_data *tar, *aff_who = NULL;	/* Target */
   struct affected_type af, *af_ptr;
   bool disarm_prim = TRUE, done;
d1901 1
a1901 1
   if (IS_NPC(ch) || GET_SKILL(ch, SKILL_DISARM) == 0) {
d1907 1
a1907 1
   if (!(tar = FIGHTING(ch))) {
d1912 2
d1915 1
a1915 1
   if (ch == tar) {
d1922 1
a1922 1
      act("You don't have the energy to do that.", FALSE, ch, 0, 0, TO_CHAR);
d1926 2
a1927 2
   if (IS_AFFECTED(ch, AFF_FUMBLING_PRIM) ||
         IS_AFFECTED(ch, AFF_FUMBLING_SECOND)) {
d1933 1
a1933 1
   if (!CAN_SEE(ch, tar)) {
d1953 2
a1954 3
   one_argument(arg, obj_name);
   if (*obj_name == '\0') {

d1956 1
a1956 1
      if ((obj = GET_EQ(tar, WEAR_WIELD))) {
d1958 1
a1958 1
      } else if ((obj = GET_EQ(tar, WEAR_WIELD2))) {
d1960 1
a1960 1
      } else if ((obj = GET_EQ(tar, WEAR_2HWIELD))) {
d1963 1
a1963 1
         act("$N isn't even wielding a weapon!", FALSE, ch, 0, tar, TO_CHAR);
d1966 2
a1967 2
   } else if ((obj = GET_EQ(tar, WEAR_WIELD)) &&
         isname(obj_name, obj->name) &&    /* Same name */
d1970 2
a1971 2
   } else if ((obj = GET_EQ(tar, WEAR_WIELD2)) &&
         isname(obj_name, obj->name) &&    /* Same name */
d1974 2
a1975 2
   } else if ((obj = GET_EQ(tar, WEAR_2HWIELD)) &&
         isname(obj_name, obj->name) &&    /* Same name */
d1979 1
a1979 1
      act("$N doesn't seem to be wielding any such thing.", FALSE, ch, 0, tar, TO_CHAR);
d2002 1
a2002 1
      (GET_LEVEL(ch) - GET_LEVEL(tar));
d2013 1
a2013 1
   if (ch->char_specials.action_delays[ACT_DELAY_DISARM])
d2031 1
a2031 1
   ch->char_specials.action_delays[ACT_DELAY_DISARM] = number(1, 3);
d2034 3
a2036 3
      act("$n fails $s disarming manuveur so badly, $e drops $s own weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
      act("$n tries to disarm but drops $s weapon!", FALSE, ch, 0, tar, TO_VICT);
      act("You try to disarm $N but drop your $o instead!", FALSE, ch, ch_obj, tar, TO_CHAR);
d2040 1
a2040 1
      aff_who = ch;
d2042 1
a2042 1
      act("$n flubs an attempt at disarming $N.", FALSE, ch, 0, tar, TO_NOTVICT);
d2044 1
a2044 1
      act("$n fumbles $s weapon while trying to disarm you.", FALSE, ch, 0, tar, TO_VICT);
d2049 1
a2049 1
      aff_who = ch;
d2051 3
a2053 3
      act("$n tries to disarm $N, but $E keeps a firm grip on $S weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
      act("$n tries to disarm you, but you maintain your weapon.", FALSE, ch, 0, tar, TO_VICT);
      act("You try to disarm $N, but $E keeps hold of $S weapon.", FALSE, ch, 0, tar, TO_CHAR);
d2055 3
a2057 3
      act("$n causes $N to fumble $S weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
      act("$n causes you to fumble your weapon.", FALSE, ch, 0, tar, TO_VICT);
      act("You cause $N to fumble $S weapon.", FALSE, ch, 0, tar, TO_CHAR);
d2059 1
a2059 1
      aff_who = tar;
d2061 4
a2064 4
      act("$n successfully knocks $N's weapon from $S grip!", FALSE, ch, 0, tar, TO_NOTVICT);
      act("$n forces $p out of your hands with a fancy disarming maneuver.", FALSE, ch, obj, tar, TO_VICT);
      if (OUTSIDE(tar)) {
         act("You send $N's weapon crashing to the ground.", FALSE, ch, 0, tar, TO_CHAR);
d2066 1
a2066 1
         act("You send $N's weapon crashing to the floor.", FALSE, ch, 0, tar, TO_CHAR);
d2069 1
a2069 1
      aff_who = tar;
d2072 1
a2072 2
   improve_skill_offensively(ch, tar, SKILL_DISARM);
   memset(&af, 0, sizeof(af));
d2077 1
a2077 1
         obj_to_char(unequip_char(aff_who, pos), aff_who);
d2079 1
a2079 1
               TRUE, aff_who, obj, NULL, TO_CHAR);
d2081 1
a2081 1
               TRUE, ch, obj, NULL, TO_ROOM);
d2083 5
a2087 5
         obj_to_room(unequip_char(aff_who, pos), aff_who->in_room);
         sprintf(Gbuf2, "%s lands on the %s.", obj->short_description,
               OUTSIDE(aff_who) ? "ground" : "floor");
         act(Gbuf2, FALSE, aff_who, 0, 0, TO_ROOM);
         act(Gbuf2, FALSE, aff_who, 0, 0, TO_CHAR);
d2090 2
a2091 2
      if (pos == WEAR_WIELD && GET_EQ(aff_who, WEAR_WIELD2))
         equip_char(aff_who, unequip_char(aff_who, WEAR_WIELD2), WEAR_WIELD);
d2093 1
a2093 1
      /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
a2095 21
      if (IS_NPC(aff_who)) {
         if (disarm_prim) {
            aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = MOB_DROPPED_WEAP_DELAY;
         } else {
            aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = MOB_DROPPED_WEAP_DELAY;
         }
      } else {
         if (disarm_prim) {
            aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = PC_DROPPED_WEAP_DELAY;
         } else {
            aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = PC_DROPPED_WEAP_DELAY;
         }
      }

      /* pc/mob trying to re-claim their weapon cannot defend themselves very well */
      /* only one skill type needed since whether this afect goes with prim or secondary */
      /* can be determined by examining the bitvectors */
      af.type = SKILL_DISARM_DROPPED_WEAP;
      af.duration = 10;		/* makes no difference.  when action_delay[] == 0, it's erased */
      af.modifier = 40;
      af.location = APPLY_AC;
d2097 1
a2097 11
         af.bitvector2 = AFF2_DROPPED_PRIM;

         if (IS_AFFECTED(aff_who, AFF_FUMBLING_PRIM)) {
            for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
               if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
                  af_ptr->bitvector & AFF_FUMBLING_PRIM) {
                  affect_remove(aff_who, af_ptr);
                  done = TRUE;
               }
            }
         }
d2099 1
a2099 11
         af.bitvector2 = AFF2_DROPPED_SECOND;

         if (IS_AFFECTED(aff_who, AFF_FUMBLING_SECOND)) {
            for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
               if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
                     af_ptr->bitvector & AFF_FUMBLING_SECOND) {
                  affect_remove(aff_who, af_ptr);
                  done = TRUE;
               }
            }
         }
a2100 1
      affect_to_char(aff_who, &af);
d2105 1
a2105 1
      SET_BIT(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED);
d2109 1
a2109 1
      obj->last_to_hold = aff_who;
d2112 1
a2112 1
      obj_to_char(unequip_char(aff_who, pos), aff_who);
d2115 2
a2116 2
      if (pos == WEAR_WIELD && GET_EQ(aff_who, WEAR_WIELD2))
         equip_char(aff_who, unequip_char(aff_who, WEAR_WIELD2), WEAR_WIELD);
d2118 1
a2118 1
      /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
a2120 19
      if (IS_NPC(aff_who)) {
         if (disarm_prim) {
            aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = MOB_FUMBLING_DELAY;
         } else {
            aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = MOB_FUMBLING_DELAY;
         }
      } else {
         if (disarm_prim) {
            aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = PC_FUMBLING_DELAY;
         } else {
            aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = PC_FUMBLING_DELAY;
         }
      }

      /* pc/mob trying to re-claim their weapon cannot attack very well */
      af.type = SKILL_DISARM_FUMBLING_WEAP;
      af.duration = 10;
      af.modifier = -10;
      af.location = APPLY_HITROLL;
d2122 1
a2122 9
         af.bitvector = AFF_FUMBLING_PRIM;

         for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
            if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
                  af_ptr->bitvector & AFF_FUMBLING_PRIM) {
               affect_remove(aff_who, af_ptr);
               done = TRUE;
            }
         }
d2124 1
a2124 9
         af.bitvector = AFF_FUMBLING_SECOND;

         for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
            if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
                  af_ptr->bitvector & AFF_FUMBLING_SECOND) {
               affect_remove(aff_who, af_ptr);
               done = TRUE;
            }
         }
a2126 1
      affect_to_char(aff_who, &af);
a2131 1
   return;
a2293 3
  /* Reset the bash delay, ala kick command. */
  ch->char_specials.action_delays[ACT_DELAY_BASH] = 0;

a2341 3
  /* Reset the bash delay (ala kick command). */
  ch->char_specials.action_delays[ACT_DELAY_BASH] = 0;

d2428 4
@


1.146
log
@Removing plr/mob casting flags and using an event flag instead.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.145 2008/02/09 04:27:47 myc Exp myc $
d135 1
a135 1
    if (!attack_ok(ch, tch, FALSE))
d139 4
d2518 3
@


1.145
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.144 2008/01/29 21:02:31 myc Exp myc $
d28 1
d2514 3
@


1.144
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.143 2008/01/29 18:01:02 myc Exp myc $
d27 1
d2513 4
@


1.143
log
@Gods won't flee when roared at if they have nohassle on.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.142 2008/01/29 01:43:45 jps Exp myc $
d26 1
a28 4
extern struct room_data *world;
extern struct dex_skill_type dex_app_skill[];
extern struct descriptor_data *descriptor_list;
extern struct room_data *world;
a33 5
extern char *spells[];
extern char *apply_types[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
a784 1
  extern char *dirs[];
a861 2
  extern char *dirs[];

a946 2
  extern char *dirs[];

a2291 2
  extern struct dex_app_type dex_app[];

d2512 3
@


1.142
log
@Adjust failure-to-flee message.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.141 2008/01/27 21:09:12 myc Exp jps $
d141 1
a141 1
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
d143 1
a143 1
    if (!attack_ok(ch, tch, FALSE))
d194 2
d262 2
d2527 3
@


1.141
log
@Initial implementation of berserk.  Prevent fleeing while berserking.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.140 2008/01/27 13:43:50 jps Exp myc $
d854 1
a854 1
    act("$n tries to flee but PANICS instead!", TRUE, ch, 0, 0, TO_ROOM);
d2523 3
@


1.140
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.139 2008/01/27 00:46:29 jps Exp jps $
d800 5
d2472 49
d2523 3
@


1.139
log
@Allow breath attacks, unless reanimated.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.138 2008/01/27 00:43:14 jps Exp jps $
d1675 1
a1675 1
  if (GET_SPECIES(vict) == SPECIES_DRAGON)
d2469 3
@


1.138
log
@Stop redirecting "breathe" command to do_action.  There is no
such social.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.137 2008/01/26 12:28:05 jps Exp jps $
d111 4
a114 9
  /* Check for player */
  if (!IS_NPC(ch) || (ch->desc && ch->desc->original &&
      GET_LEVEL(ch->desc->original) < 100)) {
    send_to_char("You huff and puff but to no avail.\r\n", ch);
    act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
    return;
  }

  if (MOB_FLAGGED(ch, MOB_ANIMATED) || AFF_FLAGGED(ch, AFF_CHARM)) {
d2469 4
@


1.137
log
@Using improve_skill_offensively() so that your skills won't improve
if used against illusions.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.136 2008/01/25 21:05:45 myc Exp jps $
d111 3
a113 8
  if (!IS_NPC(ch) && GET_SKILL(ch, SKILL_BREATHE) < 1) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }

  /* Check for shapechanged players */
  if (ch->desc && ch->desc->original &&
      GET_LEVEL(ch->desc->original) < 100) {
d2474 4
@


1.136
log
@Added attack() as a macro alias for hit() with fewer arguments.
hit2() no longer exists, so updated do_backstab() to compensate.
Renamed monk_weight_pen() to monk_weight_penalty().
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.135 2008/01/23 16:42:06 jps Exp $
d25 1
d46 1
a46 3
void improve_skill(struct char_data *ch, int skill);
void hit2(struct char_data * ch, struct char_data * victim, int type);     
void raw_kill(struct char_data * ch, struct char_data * killer);
d65 1
a65 1
    improve_skill(ch, SKILL_SWITCH);
d72 1
a72 1
  improve_skill(ch, SKILL_SWITCH);
d103 1
a103 1
  ACMD(do_action);  
d106 2
a107 1
 
d131 1
a131 1
  
d146 1
a146 1
      
d156 2
d160 2
a161 1
  improve_skill(ch, SKILL_BREATHE); 
d169 1
d172 1
a172 1
  
d190 1
a190 1
  
d193 1
a193 1
      
d226 1
a226 1
    else 
d228 2
d232 2
a233 1
  improve_skill(ch, SKILL_ROAR); 
d242 1
d244 1
a244 1
  
d259 1
a259 1
      
d276 2
d279 3
a281 1
  improve_skill(ch, SKILL_SWEEP); 
d289 1
a289 1
  
d291 1
a291 1
  
d302 2
a303 2
	 opponent && (FIGHTING(opponent) != helpee);
	 opponent = opponent->next_in_room)
d305 1
a305 1
    
d332 1
a332 1
  
d337 1
a337 1
  
d347 1
a347 1
  
d349 1
a349 1
  
d380 1
a380 1
  
d395 1
a395 1
  
d409 1
a409 1
      raw_kill(vict, ch);
d433 1
a433 1
  improve_skill(ch, SKILL_INSTANT_KILL);
d510 1
a510 1
  raw_kill(victim, NULL);
d540 2
a541 2
      send_to_char("Give yourself a chance to get back into position!\r\n", ch); 
      return; 
d556 1
a556 1
         vict = FIGHTING(ch); 
d568 1
a568 1
   /* You can backstab as long as you're not the tank */ 
d579 1
a579 1
         return; 
d582 1
a582 1
  
d587 1
a587 1
  
d621 1
a621 1
         FIGHTING(vict) && 
d644 1
a644 1
  
d652 1
a652 1
  
d657 1
a657 1
  
d673 1
a673 1
   improve_skill(ch, SKILL_BACKSTAB);
d703 1
a703 1
      
d712 1
a712 1
      
a720 1
      improve_skill(ch, SKILL_BACKSTAB);
a723 1
      improve_skill(ch, SKILL_BACKSTAB);
d725 1
d729 2
a730 2
{  
  send_to_char("This command has been removed - just backstab while you're not tanking! \r\n", ch); 
d742 1
a742 1
  
d744 1
a744 1
  
d751 1
a751 1
  
d762 1
a762 1
      
d772 1
a772 1
      /* Altered until intelligence and level checks are coded. RSD 7/14/99 
d779 1
a779 1
      
d827 1
a827 1
       WAIT_STATE(ch, PULSE_VIOLENCE * 2); 
d947 1
a947 1
  improve_skill(ch, SKILL_RETREAT);
d957 1
d991 1
a991 1
    if (FIGHTING(tch) == ch)
d993 3
d1009 1
a1009 1
  else if (GET_SKILL(ch, SKILL_GROUP_RETREAT) > number(0, 81) && 
d1046 2
a1047 1
  improve_skill(ch, SKILL_GROUP_RETREAT);
d1059 1
a1059 1
  
d1070 1
a1070 1
  
d1075 1
a1075 1
  
d1077 1
a1077 1
  
d1118 1
a1118 1
  
d1127 1
a1127 1
  
d1134 1
a1134 1
  
d1139 1
a1139 1
      act("&7&b$n BOUNCES off $N, as $e tries to bash $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);          
d1163 1
a1163 1
  
d1172 1
a1172 1
    GET_POS(ch) = POS_SITTING; 
d1196 1
a1196 1
  improve_skill(ch, SKILL_BASH); 
d1205 1
a1205 1
  
d1218 1
a1218 1
  
d1224 2
a1225 2
    send_to_char("Bodyslam who?\r\n", ch);     
    return;    
d1227 1
a1227 1
  
d1241 1
a1241 1
  vict = check_guard(ch, vict, FALSE);  
d1244 1
a1244 1
  prob += GET_HITROLL(ch) - monk_weight_penalty(ch); 
d1248 2
a1249 2
  
  
d1254 1
a1254 1
  
d1258 1
a1258 1
      act("&7&b$n BOUNCES off $N, as $e tries to bodyslam $N's much larger size.&0", FALSE, ch, 0, vict, TO_NOTVICT);          
d1280 1
a1280 1
  
d1285 1
a1285 1
    GET_POS(ch) = POS_SITTING; 
d1298 2
a1299 2
  }  
  improve_skill(ch, SKILL_BODYSLAM);
d1309 1
a1309 1
  
d1311 1
a1311 1
  
d1330 1
a1330 1
  
d1340 1
a1340 1
    
d1344 1
a1344 1
      improve_skill(ch, SKILL_RESCUE);
d1350 1
a1350 1
    
d1357 1
a1357 1
    
d1363 1
a1363 1
    
d1365 3
a1367 3
  
  improve_skill(ch, SKILL_RESCUE);
  
d1375 1
a1375 1
  
d1383 2
a1384 2
  
  if ( !(vict = get_char_room_vis(ch, arg)) ) 
d1386 1
a1386 1
    if (FIGHTING(ch)) 
d1389 2
a1390 2
    } 
    else 
d1422 1
a1422 1
  improve_skill(ch, SKILL_KICK); 
d1499 1
a1499 1
    improve_skill(ch, SKILL_EYE_GOUGE);
d1512 1
a1512 1
  
d1517 1
a1517 1
  
d1524 1
a1524 1
  
d1526 1
a1526 1
    if (FIGHTING(ch)) 
d1544 1
a1544 1
  
d1546 1
a1546 1
  
d1599 1
a1599 1
  improve_skill(ch, SKILL_SPRINGLEAP);
d1603 1
a1603 1
ACMD(do_throatcut) 
d1617 2
a1618 2
    send_to_char("You've drawn too much attention to yourself to throatcut now!\r\n", ch); 
    return; 
d1620 1
a1620 1
 
d1627 1
a1627 1
  
d1637 1
a1637 1
  
d1644 1
a1644 1
  
d1695 2
a1696 2
  
  SKILL_DELAY(ch, SKILL_THROATCUT) = SECS_PER_MUD_HOUR * 5; 
d1717 1
a1717 1
  
d1746 1
a1746 1
  af.duration = 5; 
d1762 1
a1762 1
  
d1778 1
a1778 1
	 sprintf(stop_buf2, "$n stops chanting abruptly!"); 
d1800 1
a1800 1
	 sprintf(stop_buf2, "$n stops chanting abruptly!"); 
d1810 1
a1810 1
	  sprintf(stop_buf2, "$n stops chanting abruptly!"); 
d1871 2
a1872 2
         struct obj_data* temp; 
         unequip_char(ch,WEAR_WIELD); 
d1875 1
a1875 1
            equip_char(ch, temp, WEAR_WIELD); 
d1878 1
a1878 1
         unequip_char(ch, position); 
d1891 2
a1892 2
  improve_skill(ch, SKILL_THROATCUT);
 
d1896 1
a1896 1
      act(stop_buf2, FALSE, vict, 0, 0, TO_ROOM); 
d2015 1
a2015 1
  
d2018 1
a2018 1
  
d2021 1
a2021 1
  
d2023 1
a2023 1
  
d2027 1
a2027 1
  
d2029 1
a2029 1
  
d2031 1
a2031 1
    
d2033 1
a2033 1
     
d2039 1
a2039 1
     
d2041 1
a2041 1
  
d2044 1
a2044 1
  
d2084 1
a2084 1
   improve_skill(ch, SKILL_DISARM);
d2234 2
a2235 1
  
d2240 1
a2240 1
  
d2254 1
a2254 1
  
d2257 1
a2257 1
  
d2261 1
a2261 1
  send_to_char("You spin in a circle, attempting to hit everything within range.\r\n", ch);  
d2265 1
a2265 1
  
d2268 1
a2268 1
      for (mob = world[ch->in_room].people; mob; mob = next_mob) 
d2271 1
a2271 1
	  
d2273 1
a2273 1
	  if (ch == mob) 
d2275 1
a2275 1
	  
d2283 1
a2283 1
	  
d2289 3
a2291 1
	  
d2293 1
a2293 1
	  
d2297 1
a2297 1
  improve_skill(ch, SKILL_HITALL);
d2347 1
a2347 1
  improve_skill(ch, SKILL_CORNER);
d2398 1
a2398 1
  improve_skill(ch, SKILL_PECK);
d2449 1
a2449 1
  improve_skill(ch, SKILL_CLAW);
d2479 5
d2929 3
a2931 3
 * code now compiles cleanly and boots cleanly with insure.  The most 
 * significant changes were moving all the BREATH's to within normal spell 
 * range, and fixing the way socials were allocated.  Too many small fixes 
@


1.135
log
@Changed the duration of gouge-blindness to 2-4 hours.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.134 2008/01/23 05:31:50 jps Exp jps $
d302 1
a302 1
      hit(ch, opponent, TYPE_UNDEFINED);
d357 2
a358 6
    else if (!FIGHTING(ch) || switch_ok(ch)) {
      if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
	hit(ch, vict, SKILL_BAREHAND);
      else
	hit(ch, vict, TYPE_UNDEFINED);
    }
d603 1
a603 1
      hit(vict, ch, TYPE_UNDEFINED);
d615 1
a615 1
      hit(vict, ch, TYPE_UNDEFINED);
d620 1
a620 1
      if (!IS_AFFECTED3(vict, AFF3_AWARE)) {
d654 2
a655 4
      if (weapon == GET_EQ(ch, WEAR_WIELD2))
         hit2(ch, vict, TYPE_UNDEFINED);
      else
         hit(ch, vict, TYPE_UNDEFINED);
d658 2
a659 4
      if (weapon == GET_EQ(ch, WEAR_WIELD2))
         hit2(ch, vict, SKILL_2BACK);
      else
         hit(ch, vict, SKILL_BACKSTAB);
d708 1
a708 1
      hit(ch, vict, TYPE_UNDEFINED);
d712 1
a712 1
      hit2(ch, vict, SKILL_2BACK);
d925 1
a925 6
    if (GET_SKILL(FIGHTING(ch), SKILL_BAREHAND) &&
        !GET_EQ(FIGHTING(ch), WEAR_WIELD) &&
        !GET_EQ(FIGHTING(ch), WEAR_2HWIELD))
      hit(FIGHTING(ch), ch, SKILL_BAREHAND);
    else
      hit(FIGHTING(ch), ch, TYPE_UNDEFINED);
d1228 1
a1228 1
  prob += GET_HITROLL(ch) - monk_weight_pen(ch); 
d1397 1
a1397 1
  percent = ((10 - ((GET_AC(vict)+(monk_weight_pen(vict)*5)) / 10)) << 1) + number(1, 101);
d1527 1
a1527 1
  percent = number(6, 77) - (GET_AC(vict) + (5 * monk_weight_pen(vict))) / 20;
d1690 1
a1690 1
    hit(vict, ch, TYPE_UNDEFINED);
d2273 1
a2273 1
	  hit(ch, mob, TYPE_UNDEFINED);
d2457 1
d2460 3
@


1.134
log
@Allow xp gain for instant kill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.133 2008/01/23 04:45:43 jps Exp jps $
d1484 1
a1484 1
      af.duration = 100;
d1504 1
a1504 1
  
d2472 3
@


1.133
log
@Use alter_hit to kill people with quickdeath.  Add some messages
about instant kill.  Use the delay from instant kill to prevent
another instant kill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.132 2008/01/22 15:11:38 jps Exp jps $
d430 2
a431 1
  chance = 1000 - (GET_SKILL(ch, SKILL_INSTANT_KILL) - (100 - GET_DEX(ch))  - (GET_LEVEL(victim) * 10)) / 10;
d436 1
a436 2

  if (number(1, 1000) >= chance || TRUE)
d507 2
d521 1
d2472 5
@


1.132
log
@Stopped quickdeath() from sending messages after the kill, thus
crashing the mud.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.131 2008/01/10 05:39:43 myc Exp jps $
d414 4
d420 2
a421 2
      (GET_POS(victim) == POS_DEAD) || 
      (ch->in_room != victim->in_room) || 
d424 1
a424 1
  
d436 1
a436 1
  if (number(1, 1000) >= chance) 
d453 2
a454 2
  struct char_data *person; 
  
d478 1
a478 1
  
d480 1
a480 1
      TRUE, victim, 0, 0, TO_ROOM);    
d484 1
a484 1
	FALSE, victim, 0, 0,TO_CHAR);                       
d487 1
a487 1
  
d493 1
a493 1
  
a504 1
/* Ung... no, I hate this, it must go.. .its gone, good bye. */
d507 2
a508 2
  
  if (GET_LEVEL(victim) >= LVL_IMMORT)
d510 9
a518 1
  
a519 10
  /* You can't be sending messages about this guy when he's dead! */
  /*
  
  act("&8$n is dead!  R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
  if (AWAKE(victim)) 
    act("&8You feel yourself falling to the ground.&0", FALSE, victim, 0, 0,
	TO_CHAR);
  act("&8Your soul leaves your body in the cold sleep of death...&0",  FALSE,
      victim, 0, 0, TO_CHAR);
  */
d539 1
a539 1
  
d2469 4
@


1.131
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.130 2008/01/09 07:26:49 jps Exp myc $
d509 2
d518 1
a518 1
  
d2468 4
@


1.130
log
@Better can't-backstab feedback when you're fighting.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.129 2008/01/04 01:53:26 jps Exp jps $
d471 3
a473 2
    alter_hit(victim, -20, 1);
    return;}
d2466 3
@


1.129
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.128 2007/11/18 16:51:55 myc Exp jps $
d556 8
a563 1
         send_to_char("Your victim is facing the wrong way!\r\n", ch); 
d2465 4
@


1.128
log
@Fixing instakill to improve skill even if it fails.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.127 2007/10/25 20:38:33 myc Exp myc $
d24 1
d2458 3
@


1.127
log
@Make SENTINEL mobs more difficult to scare with roar.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.126 2007/10/20 19:01:41 myc Exp myc $
d410 1
a410 1
  if(!victim || !ch || ch == victim || ch == NULL || victim == NULL)
d420 1
d428 1
a428 1
    chance = 1000; /* der.. can you say coup de grace? */
a429 1
  improve_skill(ch, SKILL_INSTANT_KILL);
d451 1
a451 1
    mudlog("Attempting to use slow_death on a NULL character!", BRF, LVL_BUILDER, TRUE);
d2457 3
@


1.126
log
@Fixed a typo.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.125 2007/10/17 17:18:04 myc Exp myc $
d199 3
d2457 3
@


1.125
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.124 2007/10/13 20:12:49 myc Exp myc $
d243 1
a243 1
  send_to_char("&2You sweep with your enormous tail!&0", ch);
d2454 4
@


1.124
log
@Roar now wakes up sleeping people.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.123 2007/10/09 02:42:34 myc Exp myc $
d873 1
a873 1
  dir = search_block(arg, dirs, FALSE);
d964 1
a964 1
  dir = search_block(arg, dirs, FALSE);
d2454 3
@


1.123
log
@Roar command shouldn't work on you if you're sleeping or incapacitated.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.122 2007/10/02 02:52:27 myc Exp myc $
d191 1
a191 1
    if (!AWAKE(tch))
d200 11
a210 1
    if (GET_DEX(tch) - 15 < number(0, 100) && GET_POS(tch) >= POS_FIGHTING) {
d214 2
a215 2
      GET_POS1(tch) = POS_SITTING;
      WAIT_STATE(tch,PULSE_VIOLENCE);
d1663 12
a1722 12
  /* Can't throatcut dragons, nor mobs that are twice your size */
  if (GET_SPECIES(vict) == SPECIES_DRAGON)
  {
     send_to_char("Cut the throat... of a dragon... RIGHT!!!!!\r\n", ch);
     return;
  }
  else if ((GET_SIZE(vict) > GET_SIZE(ch) + 2) || (GET_SIZE(vict) < GET_SIZE(ch) - 2))
  {
    send_to_char("Maybe if you were close to the same size it would work!!\r\n", ch);
    return;
  }
  
d2454 3
@


1.122
log
@Disengage now works as abort when casting.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.121 2007/09/30 19:54:11 myc Exp myc $
d191 2
d2444 3
@


1.121
log
@Make roar skill not usable in peaced rooms.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.120 2007/09/15 05:03:46 myc Exp myc $
d293 7
d2442 3
@


1.120
log
@AFF_DROPPED_PRIM and AFF_DROPPED_SECOND were incorrectly marked as
Aff 1 flags.  They should have been Aff 2 flags.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.119 2007/09/12 19:28:56 myc Exp myc $
d193 1
a193 1
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
d2435 4
@


1.119
log
@Allow springleap for POS_RESTING.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.118 2007/09/11 16:34:24 myc Exp myc $
d2091 1
a2091 1
         af.bitvector2 = AFF_DROPPED_PRIM;
d2103 1
a2103 1
         af.bitvector2 = AFF_DROPPED_SECOND;
d2435 3
@


1.118
log
@Moved switch skill logic into switch_ok function.
Cleaned up code for breathe command.
Cleaned up code for roar and sweep.
Added peck, claw, and electrify skills for use by druid shapechanges.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.116 2007/09/02 22:54:55 jps Exp $
d1474 1
a1474 1
    send_to_char("&0You'd better leave all the martial arts to monks.&0\r\n", ch);
d1478 2
a1479 2
  if (GET_POS(ch) != POS_SITTING) {
    send_to_char("&0You can't spring from that position, try sitting!&0\r\n", ch);
d1495 1
a1495 1
    send_to_char("&0That might hurt too much...&0\r\n", ch);
d2435 6
@


1.117
log
@Fix switch message grammaer
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.116 2007/09/02 22:54:55 jps Exp jps $
d57 43
d105 1
a105 2
  int breath=0,group, message;
  extern char *breath_messages[];
d107 1
a107 1
  if(!ch)
d110 1
a110 2
  if(!IS_NPC(ch) && GET_SKILL(ch, SKILL_BREATHE) < 1) 
  {
d115 7
a121 8
    /* Check for shapechanged players */
    if (ch->desc && ch->desc->original &&
	GET_LEVEL(ch->desc->original) < 100) 
    {
	send_to_char("You huff and puff but to no avail.\r\n", ch);
	act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
	return;
    }
d123 5
a127 8
    if (MOB_FLAGGED(ch, MOB_ANIMATED) || IS_AFFECTED(ch, AFF_CHARM))
      {
	send_to_char("You huff and puff but to no avail.\r\n", ch);
	act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
	return;
      }

    breath = SPELL_FIRE_BREATH;
d131 6
a136 28
  if(is_abbrev(arg, "fire")) 
  {
    breath = SPELL_FIRE_BREATH;
    message = 0;
  }
  else if(is_abbrev(arg, "gas")) 
  {
    breath = SPELL_GAS_BREATH;
    message = 2;
  }
  else if(is_abbrev(arg, "frost")) 
  {
    breath = SPELL_FROST_BREATH;
    message = 4;
  }
  else if(is_abbrev(arg, "acid")) 
  {
    breath = SPELL_ACID_BREATH;
    message = 6;
  }
  else if(is_abbrev(arg, "lightning")) 
  {
    breath = SPELL_LIGHTNING_BREATH;
    message = 8;
  }
  else
  {
    send_to_char("Usage: Breathe <Fire/Gas/Frost/Acid/Lightning>", ch);
d140 5
a144 7
  act(breath_messages[message],FALSE,ch,0,0,TO_CHAR);
  act(breath_messages[message+1],FALSE,ch,0,0,TO_ROOM);
  
  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;
d146 11
a156 8
      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      call_magic(ch, tch, 0, breath, GET_LEVEL(ch), CAST_BREATH);
    }
d158 1
a158 1
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
a164 1
  int group;
d168 1
a168 1
  if(!ch)
d170 3
a172 1
  if(GET_SKILL(ch, SKILL_ROAR) < 1) {
a175 3
  
  if (MOB_FLAGGED(ch, MOB_ANIMATED) || IS_AFFECTED(ch, AFF_CHARM))
    return; 
d177 1
a177 1
  if (IS_AFFECTED2(ch, AFF2_SILENCE)) {
d186 2
a187 4
  for (tch = world[ch->in_room].people; tch; tch = next_tch)
  {
      next_tch = tch->next_in_room;
      group = 0;
d189 19
a207 23
      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      if (mag_savingthrow(tch, SAVING_PARA))
	continue;
      else 
      {
	if(GET_DEX(tch)-15 < number(0,100) && GET_POS(tch) >= POS_FIGHTING) {
	  send_to_char("In your panicked rush to flee, you trip!\r\n", tch);
	  act("In a panicked rush to flee, $n trips!",FALSE,tch,0,0,TO_ROOM);
	  GET_POS(tch) = POS_SITTING;
	  GET_POS1(tch) = POS_SITTING;
	  WAIT_STATE(tch,PULSE_VIOLENCE);
	  mag_affects(GET_LEVEL(ch), ch, tch, SPELL_FEAR, SAVING_PARA);
	}
	else 
	{
	  do_flee(tch, NULL, 0, 0);
	}
      }
d212 1
a212 1
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
a218 1
  int group;
d221 1
a221 1
  if(!ch)
d223 3
a225 1
  if(GET_SKILL(ch, SKILL_SWEEP) < 1) {
d230 2
a231 3
  if (MOB_FLAGGED(ch, MOB_ANIMATED) || IS_AFFECTED(ch, AFF_CHARM))
    return; 

d233 2
a234 6
  act("&2$n&2 sweeps with $s enormous tail!&0",FALSE, ch,0,0,TO_ROOM);
  act("&2You sweep with your enormous tail!&0",FALSE, ch,0,0,TO_CHAR);
  for (tch = world[ch->in_room].people; tch; tch = next_tch)
    {
      next_tch = tch->next_in_room;
      group = 0;
d236 17
a252 16
      if (is_grouped(ch, tch))
	continue;
      if (tch == ch)
	continue;
      if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
	continue;
      if ((GET_VIEWED_DEX(tch)-15) > number(0,100) || GET_POS(tch) < POS_FIGHTING)
	continue;
      else {
	act("&3You are slammed to the ground by $N's&3 tail!&0",FALSE,tch,0,ch,TO_CHAR);
	act("&3$n&3 is slammed to the ground by a mighty tail sweep!&0",FALSE,tch,0,0,TO_ROOM);
	GET_POS(tch) = POS_SITTING;
	GET_POS1(tch) = POS_SITTING;
	WAIT_STATE(tch, PULSE_VIOLENCE);
      }
    }
d254 1
a254 1
  if(IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)
d330 5
a334 1
    if (!FIGHTING(ch)) {
d336 1
a336 1
	hit(ch,vict,SKILL_BAREHAND);
a338 2
      WAIT_STATE(ch, PULSE_VIOLENCE + 2);
      WAIT_STATE(vict, PULSE_VIOLENCE);
d340 1
a340 30
    else if (vict == FIGHTING(ch))
      send_to_char("&7You're doing the best you can!&0\n\r", ch);
    else if (GET_SKILL(ch, SKILL_SWITCH) > 0) {
      if (number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
	act("&8$n tries to switch opponents, but becomes confused!&0",
	    FALSE, ch, 0, vict, TO_ROOM);
	send_to_char("&8You try to switch opponents and become confused.&0\r\n",ch);
	stop_fighting(ch);
	improve_skill(ch, SKILL_SWITCH);
	WAIT_STATE(ch, PULSE_VIOLENCE + 2);
      }
      else {
	stop_fighting(ch);
	if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
	  hit(ch, vict, SKILL_BAREHAND);
	else
	  hit(ch, vict, TYPE_UNDEFINED);
	act("&8$n switches opponents!&0", FALSE, ch, 0, vict, TO_ROOM); 
	send_to_char("&8You switch opponents!&0\n\r", ch);
	improve_skill(ch, SKILL_SWITCH);
	WAIT_STATE(ch, PULSE_VIOLENCE);
      }
    }
    else {
      act("&8$n tries to switch opponents, though $e becomes confused!&0",
          FALSE, ch, 0, vict, TO_ROOM);
      send_to_char("&8You try to switch opponents and become confused.&0\r\n", ch);   
      stop_fighting(ch);
      WAIT_STATE(ch, PULSE_VIOLENCE + 2);
    }	
d1367 4
a1370 34
  if(FIGHTING(ch) != NULL)
  {
    if(vict != FIGHTING(ch)) /* if kick target is not the current advesary */
     {
       if(GET_SKILL(ch, SKILL_SWITCH) > 0) /* if this char has the switch skill */
       {
	 if(number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) /* char failed to switch */
         {
	   act("&8$n tries to switch opponents, but becomes confused!&0", FALSE, ch, 0, vict, TO_ROOM);
	   send_to_char("&8You try to switch opponents and become confused!&0\r\n", ch);
	   stop_fighting(ch);
	   improve_skill(ch, SKILL_SWITCH);
	   WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	   return;
	 }
	 else /* char successfully switched - show switch message and then execute kick block below */
	 {
	   act("&8$n switches opponents!&0\r\n", FALSE, ch, 0, vict, TO_ROOM);
	   send_to_char("&8You switch opponents!&0\r\n", ch);
	   improve_skill(ch, SKILL_SWITCH);
	   FIGHTING(ch) = vict; /* set the new target of aggression */
	 }
       }
       else /* this char doesn't have the switch skill */
       {
	 act("&8$n tries to switch opponents, but becomes confused!&0\r\n", FALSE, ch, 0, vict, TO_ROOM);
	 send_to_char("&8You try to switch opponents and become confused!&0\r\n", ch);
	 stop_fighting(ch);
	 WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	 return;
       }
     }
  }
  
d1519 4
a1522 2
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
d1531 9
a1539 5
    abort_casting(vict);
    GET_POS(vict) = POS_SITTING;
    GET_POS1(vict) = POS1_SITTING;
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
d1548 9
a1556 5
    abort_casting(vict);
    GET_POS(vict) = POS_SITTING;
    GET_POS1(vict) = POS1_SITTING;
    GET_POS(ch) = POS_FIGHTING;
    GET_POS1(ch) = POS_STANDING;
d2307 126
@


1.116
log
@Minor typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.115 2007/08/23 01:34:36 jps Exp jps $
d337 1
a337 1
	act("&8$n tries to switch opponents, though becomes confused!&0",
d1397 1
a1397 1
	   act("&8$n tries to switch opponents, though becomes confused!&0", FALSE, ch, 0, vict, TO_ROOM);
d1414 1
a1414 1
	 act("&8$n tries to switch opponents, though becomes confused!&0\r\n", FALSE, ch, 0, vict, TO_ROOM);
d2351 3
@


1.115
log
@Changed target-not-here message for eye gouge. Also made
it not miss for incapacitated victims.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.114 2007/08/22 22:46:37 jps Exp jps $
d241 1
a241 1
	act("&3You are slammed full blast by $N's&3 tail!&0",FALSE,tch,0,ch,TO_CHAR);
d2351 4
@


1.114
log
@Flee attempts accidentally reduced from 6 to 1, making it
really hard to flee: fixed.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.113 2007/08/17 03:49:24 myc Exp jps $
d1455 3
a1457 2
  
  if (!(vict = get_char_room_vis(ch, arg))) {
d1464 3
d1494 1
a1494 1
  if (percent > prob)
d2351 4
@


1.113
log
@Messages for retreat/group retreat were being sent to wrong room (after
the character had already moved).  Also fixed typo in springleap.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.112 2007/08/16 10:38:50 jps Exp myc $
a813 4
    for (i = 0; i < 6; i++)
      attempt = number(0, NUM_OF_DIRS - 1);	/* Select a random 
						   direction */
      
d820 17
a836 12
    else if (CAN_GO(ch, attempt) &&
        !IS_SET(ROOM_FLAGS(EXIT(ch, attempt)->to_room), ROOM_DEATH)) {
      abort_casting(ch);
      act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
      if (do_simple_move(ch, attempt, TRUE)) {
        sprintf(buf, "&0You panic and flee %s!&0\r\n", dirs[attempt]);
        send_to_char(buf, ch);
        if (FIGHTING(ch)) {
          if (FIGHTING(FIGHTING(ch)) == ch)
            stop_fighting(FIGHTING(ch));
          stop_fighting(ch);
        }
a838 4
      else
        act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
    } else {
       act("$n tries to flee but PANICS instead!", TRUE, ch, 0, 0, TO_ROOM);
d840 2
d2347 4
@


1.112
log
@Check whether someone can bodyslam by defining which races CAN bodyslam,
rather than which CAN'T. The previous method would have granted it to
any new races by default.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.111 2007/08/15 20:47:23 myc Exp jps $
d852 1
a852 1
  int dir;
d900 2
d903 2
d906 3
a908 1
    sprintf(buf, "You skillfully retreat %s.\r\n", dirs[dir]);
d942 1
a942 1
  int dir, opponents, was_in;
d997 5
a1001 1
    sprintf(buf, "$n carefully retreats from combat, leaving $s group %s.", dirs[dir]);
d1003 3
a1005 1
    sprintf(buf, "You skillfully lead your group %s.\r\n", dirs[dir]);
d1574 1
a1574 1
    act("&0&6$N springs from the ground knocking $n down and &bfalls in the process!&0", FALSE, vict, 0, ch, TO_NOTVICT);
d1585 1
a1585 1
    act("&0&b&8You spring from the ground knocking $N off balance.&0", FALSE, ch, 0, vict, TO_CHAR);
d1587 1
a1587 1
    act("&0&b&8$N springs from the ground knocking $n down!&0", FALSE, vict, 0, ch, TO_NOTVICT);
d2348 5
@


1.111
log
@Corner skill takes level into account now.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.110 2007/08/14 22:43:07 myc Exp myc $
d1177 6
d1184 1
a1184 1
    send_to_char("&8It is just to dark!&0", ch);
a1187 11
  if (!IS_NPC(ch)) {
    if(GET_RACE(ch) == RACE_GNOME || GET_RACE(ch) == RACE_HUMAN ||
       GET_RACE(ch) == RACE_ORC || GET_RACE(ch) == RACE_DWARF || 
       GET_RACE(ch) == RACE_HALF_ELF || GET_RACE(ch) == RACE_ELF ||
       GET_RACE(ch) == RACE_DROW_ELF|| GET_RACE(ch) == RACE_HALFLING || 
       GET_RACE(ch) == RACE_DUERGAR){
      send_to_char("You have no idea how...\r\n", ch);
      return;
    }
  }

d2336 3
@


1.110
log
@Adding 'corner' skill, which lets you prevent your opponent from
fleeing.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.109 2007/08/05 22:19:17 myc Exp myc $
d2321 1
d2341 4
@


1.109
log
@Fixed up springleap skill for monks.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.108 2007/08/05 20:21:51 myc Exp myc $
d818 7
a824 1
    if (CAN_GO(ch, attempt) &&
d2290 48
d2340 3
@


1.108
log
@Added retreat and group retreat skills.
Fixed bug in disarm.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.107 2007/08/04 22:26:11 jps Exp myc $
d1504 1
a1504 2
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) 
  {
d1509 1
a1509 2
  if (GET_SKILL(ch, SKILL_SPRINGLEAP) == 0) 
  {
d1514 1
a1514 2
  if (GET_POS(ch) != POS_SITTING)
  {
d1518 1
d1521 1
a1521 2
  if (!(vict = get_char_room_vis(ch, arg))) 
  {
a1522 1
    {
d1524 2
a1525 2
    } else {
      send_to_char("&0Springleap who?&0\r\n", ch);
d1529 2
a1530 2
  if (vict == ch) 
  {
d1539 1
a1539 1
  percent = ((10 - ((GET_AC(vict)+(monk_weight_pen(vict)*5)) / 10)) << 1) + number(1, 72);
d1543 1
a1543 1
  if((GET_POS1(vict) == POS1_KNEELING) || (GET_POS(vict) == POS_SITTING))
d1545 41
a1585 43
  if (GET_POS(ch) > POS_SLEEPING)
    {
      if ((GET_POS(vict) < POS_FIGHTING) && (prob < 80))
	percent = 101;
      if (percent > prob) 
	{
	  GET_POS(ch) = POS_SITTING;
	  act("&0&6You try to take $N down but you spring over his head!&0", FALSE, ch, 0, vict, TO_CHAR);
	  act("&0&6$N springs from the ground at you but soars over your head!&0", FALSE, vict, 0, ch, TO_CHAR);
	  act("&0&6$N springs from the ground at $n but misses by a mile!&0", FALSE, vict, 0, ch, TO_NOTVICT);
	  WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
	  damage(ch, vict, 0, SKILL_SPRINGLEAP);
	  improve_skill(ch, SKILL_SPRINGLEAP);
	  return;
	}
      if (percent > (prob - (prob * 0.2)))
	{ 
	  GET_POS(vict) = POS_SITTING;
	  GET_POS(ch) = POS_SITTING;
	  act("&0&6You manage to take $N down but also &bfall down yourself!&0", FALSE, ch, 0, vict, TO_CHAR);
	  act("&0&6$N springs from the ground and knocks you down - &bbut falls in the process!&0", FALSE, vict, 0, ch, TO_CHAR);
	  act("&0&6$N springs from the ground knocking $n down and &bfalls in the process!&0", FALSE, vict, 0, ch, TO_NOTVICT);
	  WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
	  WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
	  damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
	  improve_skill(ch, SKILL_SPRINGLEAP);
     abort_casting(vict);
	  return;
	}
      else
	GET_POS(vict) = POS_SITTING;
      
      GET_POS(ch) = POS_STANDING;
      act("&0&b&8You spring from the ground knocking $N off balance.&0", FALSE, ch, 0, vict, TO_CHAR);
      act("&0&b&8$N springs from the ground and knocks you down!&0", FALSE, vict, 0, ch, TO_CHAR);
      act("&0&b&8$N springs from the ground knocking $n down!&0", FALSE, vict, 0, ch, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      WAIT_STATE(vict, (PULSE_VIOLENCE * 3) / 2);
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
      improve_skill(ch, SKILL_SPRINGLEAP);
      abort_casting(vict);
      return;  
    }
d2286 4
@


1.107
log
@Make sure there's a room message when someone tries to flee but fails.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.106 2007/08/04 21:44:20 jps Exp jps $
d844 173
d1895 3
a1897 3
  
#define DISARM_MOVEMENT         10
  
d1912 1
a1912 1
   if (!IS_FIGHTING(ch) || !(tar = ch->char_specials.fighting)) {
d2094 3
d2161 4
d2292 3
@


1.106
log
@Make gouge damage dependent on proficiency in the skill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.105 2007/08/04 14:40:35 myc Exp jps $
d797 1
a797 1
    send_to_char("Its a bit to late for that.\r\n", ch);
d808 2
a809 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 2); 
d834 2
d2112 3
@


1.105
log
@Bug in flee sending too many messages.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.104 2007/08/03 22:00:11 myc Exp myc $
d1315 1
a1315 1
    damage(ch, vict, (GET_LEVEL(ch) + percent) >> 2, SKILL_EYE_GOUGE);
d2109 3
@


1.104
log
@Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.103 2007/08/03 03:51:44 myc Exp myc $
d829 1
d2109 3
@


1.103
log
@check_pk is now attack_ok, and covers many more cases than before,
including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
offensive attacks now use attack_ok to determine whether an attack is
allowed.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.102 2007/07/31 08:40:00 jps Exp myc $
d165 1
a165 1
    send_to_char("You take a deep breath and release a vicious cough!", ch);
d2108 6
@


1.102
log
@Fix near-miss backstab with weapon in off hand. Also fix probability
of backstabbing so it depends on skill vs. victim level, rather
than merely skill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.101 2007/07/31 00:43:00 jps Exp jps $
a53 1
void Forgive_The_Basterd(struct char_data *ch);
a256 8
  if (FIGHTING(ch)) {
    send_to_char("You're already fighting!\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
d259 3
a261 1
  if (!*arg)
d277 1
a277 9
    else if (!pk_allowed && !IS_NPC(opponent))	/* prevent accidental pkill */
      act("You cannot attack $N, $E's a player.", FALSE,
	  ch, 0, opponent, TO_CHAR);
    else if (!pk_allowed && opponent->desc && /* prevent shapechange */
             opponent->desc->original && 
             GET_LEVEL(opponent->desc->original) < 100)
      act("You cannot attack $N, $E's a player.", FALSE,
	  ch, 0, opponent, TO_CHAR);
    else {
d288 1
a288 1
  if(!FIGHTING(ch)) {
d293 1
a293 1
  if(FIGHTING(FIGHTING(ch)) == ch) {
d310 3
a312 6
  if (ROOM_AFFECTED(ch->in_room, RAFF_DARKNESS)) {
    sprintf(buf, "&8It is just too dark!&0");
    send_to_char(buf, ch);
    return;
  }
  if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
d314 1
a314 8
    return;
  } 
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }

  if (!*arg) {
d316 1
a316 1
  } else if (!(vict = get_char_room_vis(ch, arg))) {
d318 1
a318 1
  } else if (vict == ch) {
d321 2
a322 1
  } else if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master == vict)) {
d324 2
a325 38
  } else {
    if (!pk_allowed) {
      if (!IS_NPC(vict) && !IS_NPC(ch) && (subcmd != SCMD_MURDER)) {
	send_to_char("You can't kill another player.\r\n", ch);
	return;
      }
      if (!IS_NPC(vict) && !IS_NPC(ch)) {
	send_to_char("You can't kill another player.\r\n", ch);
	return;
      }
      /* Check for shapechanged players */
      if (ch->desc && ch->desc->original &&
          GET_LEVEL(ch->desc->original) < 100 &&
          !IS_NPC(vict) && (subcmd != SCMD_MURDER)) {
	send_to_char("You can't kill another player.\r\n", ch);
	return;
      }
      if (ch->desc && ch->desc->original &&
          GET_LEVEL(ch->desc->original) < 100 &&
          !IS_NPC(vict)) {
	send_to_char("You can't kill another player.\r\n", ch);
	return;
      }
      if (IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(vict)) {
	/* you can't order a charmed pet to attack a player */
	if(!IS_NPC(ch->master)) { /* moved here from above if statement to be sure ch->master exists */
	  send_to_char("Do it yourself wimp!\r\n", ch);
	  return;
	}
      }
    } /*All new for switch skill Banyal*/
    /*
      if(GET_POS(ch) < POS_STANDING) {
      send_to_char("&7Maybe you should get to your feet first?&0", ch);
      return;
      }else
    */ 
    if(FIGHTING(ch) == NULL) {
d332 2
a333 2
      return;	
    } else if(vict == FIGHTING(ch)) {
d335 2
a336 3
      return;
    } else if(GET_SKILL(ch, SKILL_SWITCH) > 0)
      if(number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
d343 2
a344 2
	return;
      } else {
d354 9
a362 10
	return;
      } else {
	act("&8$n tries to switch opponents, though $e becomes confused!&0",
	    FALSE, ch, 0, vict, TO_ROOM);
	send_to_char("&8You try to switch opponents and become confused.&0\r\n",
		     ch);   
	stop_fighting(ch);
	WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	return;
      }	
d373 1
a373 2
    sprintf(buf, "&8It is just too damn dark!&0");
    send_to_char(buf, ch);
d549 1
a549 2
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
      send_to_char("You feel ashamed to disturb the peace of this room.\r\n", ch);
a550 14
   }

   /* check for pk */
   if (!IS_NPC(vict) && !pk_allowed && !IS_NPC(ch)) {
      send_to_char("You can't backstab players!\r\n", ch);
      return;
   }

   /* check for shapechanged players */
   if (vict->desc && vict->desc->original &&
         GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
      send_to_char("You can't backstab players!\r\n", ch);
      return;
   }
d560 1
a560 2
   if ((IS_AFFECTED (ch, AFF_BLIND)) || 
         (affected_by_spell (ch, SPELL_BLINDNESS))) {
d624 1
a624 1
   if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict))
d627 1
a627 1
   if (IS_AFFECTED3(vict, AFF3_AWARE) && FIGHTING(vict))
d663 1
a663 1
   if (!IS_AFFECTED3(vict, AFF3_AWARE)) {
d685 1
a685 1
   if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
d783 1
a783 1
  if (!SanityCheck(ch, "do_flee - 1"))
a784 5
  if (IS_NPC(ch)) {
    if (GET_MOB_WAIT(ch) > 0) {
      return;
    }
  }  
d786 3
a788 1
  if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) 
d790 1
d804 1
d809 1
a809 1
    return; 
d813 1
a813 7
    if ((IS_NPC(ch) && GET_MOB_WAIT(ch)) || (!IS_NPC(ch) && CHECK_WAIT(ch))) {
      send_to_char("You cannot flee yet!\r\n", ch);
      return;
    }
    
    
    for (i = 0; i < 6; i++) {
d817 12
a828 18
      if (CAN_GO(ch, attempt) &&
	  !IS_SET(ROOM_FLAGS(EXIT(ch, attempt)->to_room), ROOM_DEATH)) {

   abort_casting(ch);
	act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
	if (do_simple_move(ch, attempt, TRUE)) {
	  sprintf(buf, "&0You panic and flee %s!&0\r\n", dirs[attempt]);
	  send_to_char(buf, ch);
	  if (FIGHTING(ch)) {
	    if (FIGHTING(FIGHTING(ch)) == ch){
	      stop_fighting(FIGHTING(ch));
	      stop_fighting(ch);
	    }
	  }
	} else {
	  act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
	}
	return;
d830 2
a837 1
  return;
d849 1
a849 6
    sprintf(buf, "&8It is just too dark!&0");
    send_to_char(buf, ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
d859 1
a859 1
  if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
d882 1
a882 1
  if(!CAN_SEE(ch, vict)) {
d891 1
a891 7
  if (
      /* player vs. player */
      (!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed && GET_LEVEL(ch) < LVL_IMMORT) ||
      /* charmie vs. player*/
      ((IS_NPC(ch) && !IS_NPC(vict) && (IS_AFFECTED(ch, AFF_CHARM) && (ch->master != NULL))) && !pk_allowed))
  {
    send_to_char("You can't bash players!\r\n", ch);
a892 1
  }
a893 6
  /* Check for shapechanged players */
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
    send_to_char("You can't bash players!\r\n", ch);
    return;
  }
d995 1
a995 6
    sprintf(buf, "&8It is just to dark!&0");
    send_to_char(buf, ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
d998 1
d1015 2
a1016 1
  }  if (!(vict = get_char_room_vis(ch, arg))) {
d1029 3
a1031 3
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
    send_to_char("You can't bodyslam players!\r\n", ch);
d1033 1
a1033 7
  }
  /* check for shapechanged players */
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
    send_to_char("You can't bodyslam players!\r\n", ch);
    return;
  }
a1174 5
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  
d1194 1
a1194 5
  /* check for pk -- modified by Pergus 7/14/2002 */
  if( (!IS_NPC(vict) && !pk_allowed && GET_LEVEL(ch) > LVL_IMMORT) /* PvP */
  ||   ((IS_NPC(ch) && !IS_NPC(vict) && (IS_AFFECTED(ch, AFF_CHARM) && (ch->master != NULL))) && !pk_allowed)) /* Charmies vs Player*/
  {
    send_to_char("Silly, you can't kick players!\r\n", ch);
a1195 10
  }

  /* check for shapechanged PvP */
  if (!pk_allowed && ((!IS_NPC(vict) && ch->desc && ch->desc->original && 
          GET_LEVEL(ch->desc->original) < LVL_IMMORT) || 
      (!IS_NPC(ch) && vict->desc && vict->desc->original && 
          GET_LEVEL(vict->desc->original) < LVL_IMMORT))) {
    send_to_char("You can't kick players!\r\n", ch);
    return;
  }
d1260 1
a1260 1
  if (IS_AFFECTED(ch, AFF_BLIND)) {
a1264 5
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  
d1286 2
a1287 5
  /* check for pk -- modified by Pergus 7/14/2002 */
  if( (!IS_NPC(vict) && !pk_allowed && GET_LEVEL(ch) > LVL_IMMORT) /* PvP */
  ||   ((IS_NPC(ch) && !IS_NPC(vict) && (IS_AFFECTED(ch, AFF_CHARM) && (ch->master != NULL))) && !pk_allowed)) /* Charmies vs Player*/
  {
    send_to_char("Silly, you can't gouge players eyes out!\r\n", ch);
a1288 10
  }

  /* check for shapechanged PvP */
  if (!pk_allowed && ((!IS_NPC(vict) && ch->desc && ch->desc->original && 
          GET_LEVEL(ch->desc->original) < LVL_IMMORT) || 
      (!IS_NPC(ch) && vict->desc && vict->desc->original && 
          GET_LEVEL(vict->desc->original) < LVL_IMMORT))) {
    send_to_char("You can't gouge players' eyes out!\r\n", ch);
    return;
  }
d1329 1
a1329 6
    sprintf(buf, "&8It is too dark!&0");
    send_to_char(buf, ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
d1361 3
a1363 3
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
    send_to_char("You can't springleap at players!\r\n", ch);
a1364 7
  }
    /* check for shapechanged players */
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
    send_to_char("You can't springleap at players!\r\n", ch);
    return;
  }
a1437 5
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)){
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  
d1496 1
a1496 3
  /* check for pk --modified by Pergus 7/14/2002 */
  if(!IS_NPC(vict) && !pk_allowed) {
    send_to_char("You can't cut a player's throat!\r\n", ch);
a1497 8
  }

  /* check for shapechanged players */
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
    send_to_char("You can't cut a player's throat!\r\n", ch);
    return;
  }
d2043 1
a2043 2
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
a2044 1
  }
a2047 3
  if (!SanityCheck(ch, "do_hitall"))
    return;
  
d2108 5
@


1.101
log
@Fix typos in throat cut.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.100 2007/07/24 01:24:55 myc Exp jps $
d677 2
a678 2
         FIGHTING(vict) && (number(1, (GET_SKILL(ch, SKILL_BACKSTAB)*1.25)) >= (((GET_LEVEL(ch) - GET_LEVEL(vict))/2) + 
         (GET_SKILL(ch, SKILL_BACKSTAB)/2) - (GET_SKILL(ch, SKILL_BACKSTAB)/10)))) {
d709 1
a709 1
   prob = GET_SKILL(ch, SKILL_BACKSTAB);
a718 1
      improve_skill(ch, SKILL_BACKSTAB);
d722 4
a725 1
      hit(ch, vict, TYPE_UNDEFINED);
a731 1
      improve_skill(ch, SKILL_BACKSTAB);
d733 1
a1602 1
  chance = GET_SKILL(ch, SKILL_THROATCUT);
d1695 2
a1705 2
  chance -= (GET_LEVEL(vict) - GET_LEVEL(ch));
  
d1722 1
a1722 1
  if ((!IS_NPC(vict)) && (GET_LEVEL(vict) == LVL_GOD))
d2295 3
@


1.100
log
@Eye gouge no longer improves on blinded or noblind mobs.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.99 2007/07/18 23:54:07 jps Exp myc $
d680 1
a680 1
      act("You failed, $e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
d1627 1
a1627 1
    send_to_char("Cut whos throat?\r\n", ch);
d2294 3
@


1.99
log
@Messages will reflect the actual weapon used when someone backstabs
with a piercing weapon in their off hand.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.98 2007/07/18 21:02:51 jps Exp jps $
d1469 3
a1471 1
  improve_skill(ch, SKILL_EYE_GOUGE);
d2294 4
@


1.98
log
@You can now disarm while wielding a two-handed weapon. You can also
disarm someone who is wielding a two-handed weapon. The feedback
for fumbling a cursed weapon while attempting to disarm someone
is fixed.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.97 2007/07/18 17:07:56 jps Exp jps $
d726 4
a729 1
      hit(ch, vict, SKILL_BACKSTAB);
d2292 6
@


1.97
log
@Fix feedback for fumbling your cursed weapon when trying to disarm someone.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.96 2007/06/02 22:23:26 jps Exp jps $
a1904 2
   /* extern struct dex_app_type dex_app[];*/
  
d1941 10
a1950 9
   ch_pos = WEAR_WIELD;
   if (!(ch_obj = GET_EQ(ch, WEAR_WIELD))) {
      if (!(ch_obj = GET_EQ(ch, WEAR_WIELD2))) {
         send_to_char("You must be wielding some kind of weapon.\n\r", ch);
         return;
      } else {
         ch_pos = WEAR_WIELD2;
         disarm_prim = FALSE;
      }
d1959 3
a1961 2
      pos = WEAR_WIELD;
      if (!(obj = GET_EQ(tar, pos))) {
d1963 5
a1967 4
         if (!(obj = GET_EQ(tar, pos))) {
            act("$N isn't even wielding a weapon!", FALSE, ch, 0, tar, TO_CHAR);
            return;
         }
d1977 4
d2289 3
@


1.96
log
@Fix unequipping of weapon when slinging during throatcut.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.95 2007/05/28 06:17:58 jps Exp jps $
d2077 1
a2077 1
         act("&3&b$o&3&b magically returns to your&0 &B&3inventory!&0",
d2079 1
a2079 1
         act("&3&b$o&3&b magically returns to $s&0 &B&3inventory!&0",
d2284 3
@


1.95
log
@Weapon goes to inventory when slung/retained due to curse.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.94 2007/05/28 06:14:31 jps Exp jps $
d1583 1
a1583 1
  int random, chance, percent, dam, newExp;
d1633 2
a1634 1
  if (!weapon)
d1636 3
a1638 1
  if (!weapon)
d1640 2
d1861 10
d2284 3
@


1.94
log
@Fix weapon tossing during throatcut. Allow backstabbing or throat cut with
piercing weapons that are wielded secondary or two-handed.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.93 2007/05/21 01:45:15 myc Exp jps $
a54 1
bool sling_weapon(struct char_data *ch, struct obj_data *weapon, int position);
d1859 1
d2269 4
@


1.93
log
@Fixed throatcut for piercing weapons.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.92 2007/05/21 00:14:08 myc Exp myc $
d581 10
a590 5
ACMD(do_backstab)
{
  struct char_data *vict, *tch;
  struct affected_type af;
  int percent, prob, percent2, prob2;
d592 4
a595 6
  /* Since circle was removed, backstab was allowed to be used multiple times
     during combat...therefore a skill delay was added to prevent spamming */
  if (SKILL_DELAY(ch, SKILL_BACKSTAB)) {
    send_to_char("Give yourself a chance to get back into position!\r\n", ch); 
    return; 
  }
d597 1
a597 5
  if (GET_SKILL(ch, SKILL_BACKSTAB) < 1) {
    send_to_char("You don't know how.\r\n", ch);
    return;
  }
  one_argument(argument, buf);
d599 11
a609 3
  if (!(vict = get_char_room_vis(ch, buf)))  {
    if (!FIGHTING(ch)) {
      send_to_char("Backstab who?\r\n", ch);
d611 1
a611 4
    } else {
      vict = FIGHTING(ch); 
    }
  }
d613 4
a616 4
  if (vict == ch) {
    send_to_char("How can you sneak up on yourself?\r\n", ch);
    return;
  }
d618 5
a622 4
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed to disturb the peace of this room.\r\n", ch);
    return;
  }
d624 6
a629 5
  /* check for pk --modified 7/14/2002 by Pergus */
  if(!IS_NPC(vict) && !pk_allowed && !IS_NPC(ch)) {
    send_to_char("You can't backstab players!\r\n", ch);
    return;
  }
d631 7
a637 14
  /* check for shapechanged players */
  if(vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
    send_to_char("You can't backstab players!\r\n", ch);
    return;
  }

  /* You can backstab as long as you're not the tank */ 
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (FIGHTING(tch) == ch) {
      send_to_char("Your victim is facing the wrong way!\r\n", ch); 
      return; 
    }
  }
d639 5
a643 5
  if ((IS_AFFECTED (ch, AFF_BLIND)) || 
      (affected_by_spell (ch, SPELL_BLINDNESS))) {
    send_to_char("You can't see a thing!\r\n", ch);
    return;
  }
d645 11
a655 4
  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("Backstab with what, your fist?\r\n", ch);
    return;
  }
d657 3
a659 4
  if (!IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD))) {
    send_to_char("Piercing weapons must be used to backstab.\r\n", ch);
    return;
  }
d661 4
a664 9
  /* If the mob is flagged aware, is not sleeping, and is not currently
     fighting, then you can not backstab the mob */
  if (MOB_FLAGGED(vict, MOB_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
    act("You notice $N sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N sneaking up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    return;
  }
d666 9
a674 7
  /* 50% chance the mob is aware, even in combat */
  if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict) &&
      FIGHTING(vict) && (number(1, (GET_SKILL(ch, SKILL_BACKSTAB)*1.25)) >= (((GET_LEVEL(ch) - GET_LEVEL(vict))/2) + 
      (GET_SKILL(ch, SKILL_BACKSTAB)/2) - (GET_SKILL(ch, SKILL_BACKSTAB)/10)))) {
    act("You notice $N trying to sneaking up on you!", FALSE, vict, 0, ch, TO_CHAR);
    act("You failed, $e notices you sneaking up on $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N trying to sneak up on $m!", FALSE, vict, 0, ch, TO_NOTVICT);
d676 7
a682 1
    hit(vict, ch, TYPE_UNDEFINED);
d684 1
a684 2
    WAIT_STATE(ch, PULSE_VIOLENCE);
    SKILL_DELAY(ch, SKILL_BACKSTAB) = 12;  /* 12 seconds == 3 combat rounds.*/
d686 2
a687 10
    if(!IS_AFFECTED3(vict, AFF3_AWARE)) {
      af.type = SKILL_AWARE;
      af.duration = 2;
      af.modifier = 0;
      af.location = APPLY_NONE;
      af.bitvector = 0;
      af.bitvector2 = 0;
      af.bitvector3 = AFF3_AWARE;
      affect_to_char(vict, &af);
    }
d689 12
a700 2
    return;
  }
d702 1
a702 1
  percent = number(1, 101);	/* 101% is a complete failure */
d704 2
a705 2
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict))
    percent = 150;  /*silent failure*/
d707 2
a708 2
  if (IS_AFFECTED3(vict, AFF3_AWARE) && FIGHTING(vict))
    percent += number(1, 10);  /* It's a little harder to backstab a mob you've already backstabed */
d710 1
a710 1
  prob = GET_SKILL(ch, SKILL_BACKSTAB);
d712 2
a713 2
  if (!CAN_SEE(vict, ch))
    prob += GET_SKILL(ch, SKILL_BACKSTAB) / 2;  /* add blindfighting skill */
d715 4
a718 2
  if (!instantkill(ch, vict)) {
    if (AWAKE(vict) && (percent > prob)) {
d725 1
a725 1
    } else {
d729 1
a729 1
    }
d731 2
a732 2
    WAIT_STATE(ch, PULSE_VIOLENCE);
    SKILL_DELAY(ch, SKILL_BACKSTAB) = 12;  /* 12 seconds == 3 combat rounds.*/
d734 1
a734 8
    /*
     * Crap out if the first backstab killed the victim!!!
     * You don't want to add the aware affection or indeed do anything
     * to a dead victim, because the char struct has already been 
     * freed by die() so there's a big chance of SEGFAULT!
     * -myc 3/31/2007
     */
    if (GET_POS(vict) == POS_DEAD)
d737 2
a738 1
    if(!IS_AFFECTED3(vict, AFF3_AWARE)) {
d747 1
a747 1
    }
d749 3
a751 3
    if (GET_CLASS(ch) == CLASS_ASSASSIN) {
      if (!GET_EQ(ch, WEAR_WIELD2))
	return;
d753 4
a756 2
      if (!IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD2)))
	return;
d758 1
a758 1
      percent2 = number(1, 101);	 /* 101% is a complete failure */
d760 6
a765 3
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
	percent2 = 150;  /*silent failure*/
      }
d767 1
a767 2
      if (IS_AFFECTED3(vict, AFF3_AWARE) && FIGHTING(vict))
        percent2 += number(1, 10);  /* It's a little harder to backstab a mob you've already backstabed */
d769 4
a772 20
      prob2 = GET_SKILL(ch, SKILL_BACKSTAB);
      
      /* Bonus points if the backstabee can't see the backstaber */
      if (!CAN_SEE(vict, ch)) {
	prob2 += GET_SKILL(ch, SKILL_BACKSTAB) / 2;
      }

      if (AWAKE(vict) && (percent2 > prob2)) {
        /* Backstab failed */
	hit(ch, vict, TYPE_UNDEFINED);
	improve_skill(ch, SKILL_BACKSTAB);
      } else {
        /* Backstab succeeded */
	hit2(ch, vict, SKILL_2BACK);
	improve_skill(ch, SKILL_BACKSTAB);
      }

      WAIT_STATE(ch, PULSE_VIOLENCE);
    }
  }
d774 9
d1583 1
d1590 1
a1590 1
  bool sling, skipcast = FALSE;
d1632 8
a1639 1
  if (!GET_EQ(ch, WEAR_WIELD)) {
d1644 5
a1648 1
  if (!IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD))) {
d1761 3
a1763 3
	 sprintf(buf1, "&1&bYou nearly sever the head of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	 sprintf(buf2,  "&1&b$n nearly severs your head with %s!&0" , GET_EQ(ch, WEAR_WIELD)->short_description);
	 sprintf(buf3,  "&1&b$n nearly severs the head of $N with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
d1772 3
a1774 3
	 sprintf(buf1, "&1&bBlood splatters all over you as you cut into $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	 sprintf(buf2, "&1&bBlood splatters all over $n as $e cuts into you with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	 sprintf(buf3, "&1&bBlood splatters all over $n as $e dices $N with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
d1783 3
a1785 3
	  sprintf( buf1,  "&1&b$N gasps as you slice into $S throat with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
          sprintf(buf2,  "&1&bYou gasp with fear as $n slices into your throat with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
          sprintf(buf3,  "&1&b$N looks horrified as $n slices into $S throat with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
d1793 3
a1795 3
	  sprintf(buf1,  "&1&bBlood spews everywhere as you nearly incapacitate $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	  sprintf(buf2,  "&1&bBlood spews everywhere as $n nearly incapacitates you with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
          sprintf(buf3,  "&1&bBlood spews everywhere as $n nearly incapacitates $N with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
d1809 4
a1812 3
    sprintf(buf1, "&3&bMidway, you trip and fall which sends %s flying from your hand.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
    sprintf(buf2, "&3&b$n trips and falls, losing %s in a botched attempt on your life!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
    sprintf(buf3, "&3&b$n trips and falls, losing %s while trying to kill $N!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
d1856 9
a1864 2
  if(sling)
     sling_weapon(ch, GET_EQ(ch, WEAR_WIELD), WEAR_WIELD);
d2269 3
@


1.92
log
@Fixing backstab to work with piercing weapons only.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.91 2007/05/17 22:21:23 myc Exp myc $
d1634 1
a1634 1
  if (IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD))) {
d2247 3
@


1.91
log
@Replaced several static-string to_char act()s with send_to_char()s.
Fixed newline issues with several more send_to_char()s.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.90 2007/05/11 22:01:22 myc Exp myc $
d651 1
a651 1
  if (IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD))) {
d745 1
a745 1
      if (!GET_EQ(ch, WEAR_WIELD2)) {
a746 1
      }
d748 1
a748 1
      if (IS_WEAPON_PIERCING(GET_EQ(ch, WEAR_WIELD2)))
d2247 4
@


1.90
log
@New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
complicated skill.  :P  Fixed cure blind's logic, and made it support
eye gouge too.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.89 2007/04/19 04:50:18 myc Exp myc $
d80 1
a80 1
	act("You huff and puff but to no avail.",FALSE,ch,0,0,TO_CHAR);
d87 1
a87 1
	act("You huff and puff but to no avail.",FALSE,ch,0,0,TO_CHAR);
d190 1
a190 1
	  act("In your panicked rush to flee, you trip!",FALSE,tch,0,0,TO_CHAR);
d305 1
a305 1
    send_to_char("You are not fighting anyone.",ch);
d310 1
a310 1
    send_to_char("Now way! You are fighting for your life!", ch);
d315 1
a315 1
  send_to_char("You disengage from combat.", ch);
d1113 1
a1113 1
      send_to_char("You have no idea how....", ch);
d1121 1
a1121 1
    send_to_char("You can't bodyslam in combat....", ch);
d1242 1
a1242 1
    send_to_char("But only true warriors can do this!", ch);
d1591 1
a1591 1
    send_to_char("You've drawn too much attention to yourself to throatcut now!", ch); 
d1896 1
a1896 1
      act("Impossible!  You're already fumbling for your own weapon.", FALSE, ch, 0, 0, TO_CHAR);
d1947 1
a1947 1
      act("You can only disarm weapons.", FALSE, ch, 0, 0, TO_CHAR);
d2208 1
a2208 1
  act("You spin in a circle, attempting to hit everything within range.", FALSE, ch, 0, 0, TO_CHAR);  
d2248 5
@


1.89
log
@Created macros for checking weapon types.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.88 2007/04/19 00:53:54 jps Exp myc $
d1380 90
d2248 3
@


1.88
log
@Create macros for stopping spellcasting.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.87 2007/04/18 00:24:25 myc Exp jps $
d651 1
a651 1
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
d749 1
a749 1
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT) {
a750 1
      }
d1545 1
a1545 1
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
d1661 1
a1661 1
	 sprintf(stop_buf1, "Your profuse bleeding interupts your chanting!");
d2158 3
@


1.87
log
@Roar doesn't work when you're silenced now.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.86 2007/03/31 14:45:00 myc Exp myc $
d56 1
d901 2
a902 12
	/* flee attempt forces casting to stop --gurlaek 7/14/1999 */
	if(IS_NPC(ch)) {
	  if (MOB_FLAGGED (ch, MOB_CASTING)) {
	    REMOVE_BIT(MOB_FLAGS(ch), MOB_CASTING);
	    act("You stop invoking abruptly!", FALSE, ch, 0, 0, TO_CHAR);
	    act("$n stops invoking abruptly!",FALSE, ch, 0, 0, TO_ROOM); 
	  }
	} else if (PLR_FLAGGED (ch, PLR_CASTING)) {
	  REMOVE_BIT(PLR_FLAGS(ch), PLR_CASTING);
	  act("You stop invoking abruptly!", FALSE, ch, 0, 0, TO_CHAR);
	  act("$n stops invoking abruptly!",FALSE, ch, 0, 0, TO_ROOM); 
	}	
d1085 1
a1085 10
      /* stop bashee spell casting */
      if(PLR_FLAGGED(vict, PLR_CASTING) 
	 || MOB_FLAGGED(vict, MOB_CASTING)) {
	if (IS_NPC(vict)) 
	  REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	else
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
      }
d1202 1
a1202 7
      if(PLR_FLAGGED(vict, PLR_CASTING)){
	if (IS_NPC(vict))
	  REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
      }
d1469 1
a1469 9
	  if(PLR_FLAGGED(vict, PLR_CASTING))
	    {
	      if (IS_NPC(vict))
		REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	      REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	      act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	      act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	    }
	  
d1483 1
a1483 8
      if(PLR_FLAGGED(vict, PLR_CASTING))
	{
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
d1684 1
a1684 1
	 sprintf(stop_buf1, "Your gasp abruptly interupts your chanting!");
d1759 4
a1762 8
  if(!skipcast && PLR_FLAGGED(vict, PLR_CASTING))
  {
    if (IS_NPC(vict))
      REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
    REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
    
    act(stop_buf1, FALSE, vict, 0, 0, TO_CHAR);
    act(stop_buf2, FALSE, vict, 0, 0, TO_ROOM); 
a1763 1

a1764 1

d2159 3
@


1.86
log
@Another try and making backstab not crash the mud.  Moved the check
to see if the mob is dead above the aware affection.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.85 2007/03/27 04:27:05 myc Exp myc $
d164 6
d2204 4
@


1.85
log
@Fixed a typo in do_kill.  Prevented backstab from attempting a second
backstab if the first killed the victim.  Fixed typo in bash.  Fixed
shapechange test in kick.  Made hitall all not hit followers.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.84 2007/01/27 19:55:25 dce Exp myc $
d716 10
a737 4
      /* Crap out if the first backstab killed the victim!!! */
      if (GET_POS(vict) == POS_DEAD)
        return;

d2198 5
@


1.84
log
@Missed a typo in backstab.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.83 2007/01/27 15:47:50 dce Exp $
d429 1
a429 1
    sprintf(buf, "&8It is just to damn dark!&0");
d728 4
d1041 1
a1041 1
      send_to_char("&7&bYou fall over as you try to bash someone with such small size.&0", ch);
d1334 4
a1337 4
  if(IS_NPC(ch) && vict->desc 
   && vict->desc->original 
   && GET_LEVEL(vict->desc->original) < 100 
   && !pk_allowed) {
d2163 1
d2167 2
a2168 1
	  if (IS_AFFECTED(mob, AFF_CHARM) && is_grouped(mob, ch))
d2170 4
d2175 1
a2175 1
	  if (!hit_all) 
d2192 3
@


1.83
log
@Updated failed message for backstab.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.82 2007/01/20 03:56:36 dce Exp $
d704 2
a705 2
      act("You failed to backstab $e, but manage to take a swing at $m!", FALSE, vict, 0, ch, TO_VICT);
      act("$N tried to backstab $n, but only managed to take a swing instead!", FALSE, vict, 0, ch, TO_NOTVICT);
d2182 3
@


1.82
log
@Moved aff3 for backstab.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.81 2007/01/06 04:16:44 dce Exp $
d703 3
d2182 3
@


1.81
log
@Modified backstab to take into account the aware flag
and aff3_aware flags...making it more difficult to
backstab if they exist.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.80 2006/12/19 19:57:57 myc Exp $
a658 11
  if(!IS_AFFECTED3(vict, AFF3_AWARE)) {
    af.type = SKILL_AWARE;
    af.duration = 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_AWARE;
    affect_to_char(vict, &af);
  }

d672 11
d713 11
d2179 5
@


1.80
log
@Mobs dying from suffering in slow_death() now are set back to mortally
wounded, so they can be attacked by players, so the players get the exp.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.79 2006/11/24 05:07:40 jps Exp myc $
a573 2
/*New backstab now sets victim with skill aware for a short period of time
  to help stop spamming this command to kill high mobs Banyal*/
d580 2
d593 1
a593 3
  if (!(vict = get_char_room_vis(ch, buf))) 
  {

d602 1
a602 2
  if (vict == ch) 
    {
d613 1
a613 2
  if(!IS_NPC(vict) && !pk_allowed && !IS_NPC(ch)) 
  {
d625 1
a625 1
  /* You can't backstab if you're getting hit. */ 
d643 1
d648 4
a651 4
  /* 50% chance the mob is aware, even in combat */
  if (MOB_FLAGGED(vict, MOB_AWARE) && (GET_SKILL(ch, SKILL_BACKSTAB) < 90) 
  &&  CAN_SEE(ch, vict) && !FIGHTING(vict) && (number(1,100) <= 50)) 
  {
d658 27
d690 3
d699 3
a701 10
  if (!instantkill(ch, vict)) 
  {
    if (AWAKE(vict) && (percent > prob))
    {
      /* These act statements are a complete hack, for some reason the 
	 function doesn't call the damage messages out of the messages
	 file upon success of a backstab that doesn't kill - RSD 4/16/99 */
      act("Suddenly $N stabs you in the back!", FALSE, vict, 0, ch, TO_CHAR);
      act("$n makes a strange sound as you place $p in $s back!", FALSE, vict, GET_EQ(ch, WEAR_WIELD), ch, TO_VICT);
      act("$n makes a strange sound as $N places $p in $s back, resulting in lots of blood!", FALSE, vict, GET_EQ(ch, WEAR_WIELD), ch, TO_NOTVICT);
d704 2
a705 3
    }
    else
    {
d713 2
a714 4
    if (GET_CLASS(ch) == CLASS_ASSASSIN) 
    {
      if (!GET_EQ(ch, WEAR_WIELD2)) 
      {
d718 1
a718 2
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT) 
      {
d724 1
a724 2
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict)) 
        {
d727 3
d733 2
a734 2
      if (!CAN_SEE(vict, ch)) 
        {
d738 2
a739 2
      if (AWAKE(vict) && (percent2 > prob2)) 
      {
d742 2
a743 3
      }
      else
      {
a751 11
  if(!IS_AFFECTED3(vict, AFF3_AWARE))
    {
    af.type = SKILL_AWARE;
    af.duration = 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = 0;
    af.bitvector2 = 0;
    af.bitvector3 = AFF3_AWARE;
    affect_to_char(vict, &af);
  }
d2168 4
@


1.79
log
@Fix bash so mobs can bash players
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.78 2006/11/20 06:44:26 jps Exp jps $
d517 1
a517 1
     if (person->char_specials.fighting == victim && person != victim)
d519 3
d523 1
d2162 3
@


1.78
log
@Fix creatures dying of bloodloss as you're fighting them.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.77 2006/11/18 21:00:28 jps Exp jps $
d954 1
a954 1
      (!IS_NPC(vict) && !pk_allowed && GET_LEVEL(ch) < LVL_IMMORT) ||
d2158 3
@


1.77
log
@Reworked disarm skill and disarmed-weapon retrieval.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.76 2006/11/14 19:14:38 jps Exp jps $
d57 1
d505 1
a505 5
  struct char_data *real_char; 
  struct mem_list *cur;
   /*   register struct char_data *k; */
   /*   extern struct char_data *character_list; */
  /* int i; */
d513 1
d515 5
a519 3
  /* moved this here because its friggin annoying to have a mob die on you mid combat! RLS 02/12/05*/
  if (FIGHTING(victim))
    return;
d526 1
a526 1
  act("&8With a soft groan, $n slips off into the cold sleep of death&0",
d528 1
a528 1
  act("&8$n is dead! R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
d548 2
a549 63
  
  
  
  /*check for switched victim*/
  if (victim->desc && victim->desc->original) {
    real_char = victim->desc->original;
    char_from_room(real_char);
    char_to_room(real_char, victim->in_room);
  }
  else
    real_char = victim;
  
  /*   if (FIGHTING(victim))
       stop_fighting(victim); moved this up some cause it was jacking players during combat on rare occasions.  RLS 2-12-05 */
  
  while (victim->affected)
    affect_remove(victim, victim->affected);
  while (real_char->affected)
    affect_remove(real_char, real_char->affected);
  
  /* this guy died ..zero the mem_list */
  if(victim->spell_list)
    {
      cur = victim->spell_list;
     
      while (cur) { 
/*    Zantir - 5/11/01 - The following line was here instead
      of the while I added. This is being done to fix a crash
      bug that is occuring on the cur->can_cast line. I was
      unable to duplicate the bug, so hopefully it will just
      stop happening now.
      for(i = 0; i < victim->num_spells; i++)
	{ */
	  cur->can_cast = 0;
	  cur = cur->next;
      }
      victim->num_memmed = 0;
      victim->mem_status = FALSE;
    }
  
  Forgive_The_Basterd(victim);
  
  if(PLR_FLAGGED(victim, PLR_CASTING)){
    if (IS_NPC(victim))
      REMOVE_BIT(MOB_FLAGS(victim), MOB_CASTING);
    REMOVE_BIT(PLR_FLAGS(victim),
	       PLR_CASTING);
    act("You stop chanting abruptly!", FALSE, victim, 0, 0, TO_CHAR);
    act("$n stops chanting abruptly!",FALSE, victim, 0, 0,
	TO_ROOM);
  }
  
  if(GET_LEVEL(real_char) < LVL_IMMORT) {
    make_corpse(real_char);
    extract_char(victim);
    if (victim != real_char)
      extract_char(real_char);
    if (!IS_NPC(real_char))         /* If killed dont save in room he died in */
      GET_LOADROOM(real_char) = GET_HOME(real_char);
  }else if(victim != real_char) {
    do_return(real_char, "", 0, 1);
    extract_char(victim);
  }
d561 1
a561 1
  act("&8$n is dead! R.I.P.&0", TRUE, victim, 0, 0, TO_ROOM);
d2158 3
@


1.76
log
@Fix bug so players really can't bash players.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.75 2006/11/08 09:16:04 jps Exp jps $
d23 1
d35 5
d1768 2
a1769 2
    sprintf(buf2, "&3&b$n trips and falls, loosing %s in a botched attempt on your life!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
    sprintf(buf3, "&3&b$n trips and falls, loosing %s while trying to kill $N!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
a1832 2


a1834 1
  /* Local Macros */
d1838 9
a1846 16
  int pos, percent, rnd_num, skl_bonus;
  char Gbuf2[MAX_STRING_LENGTH];
  char ply_name[MAX_INPUT_LENGTH];
  char obj_name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *ch_obj;		/* Object to disarm */
  struct char_data *tar, *aff_who = NULL;	/* Target */
  struct affected_type af, *af_ptr;
  float disarm_difficulty[NUM_WEARS] =
  {0, 0, 0, 0, 0,
   0, 0, 0, 0, 0,
   0, 0, 0, 0, 0,
   1, 1, 0, 0, 0,		/* PRIMARY/SECONDARY */
   0, 0, 0, 0, 0,
   0, 0};
  bool disarm_prim = TRUE, done;
  /* extern struct dex_app_type dex_app[];*/
d1848 73
a1920 7
  /* Executable Section */
  
  if (IS_NPC(ch) || GET_SKILL(ch, SKILL_DISARM) == 0) {
    send_to_char("You don't know how to disarm.\r\n", ch);
    return;
  }
  /* Get NAME and OBJ */
d1922 3
a1924 22
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  
  arg = one_argument(arg, ply_name);
  if (*ply_name == '\0') {
    send_to_char("Disarm who?\r\n", ch);
    return;
  }
  one_argument(arg, obj_name);
  if (*obj_name == '\0') {
    send_to_char("Disarm what?\r\n", ch);
    return;
  }
  /* Check the basic requirements, such as that can see victim  */
  /* and can see victim's weapon.                               */
  
  /* disarmer must be wielding a weapon. - might want to reconsider this later : Pergus */
  if (!(ch_obj = GET_EQ(ch, WEAR_WIELD))) {
    if (!(ch_obj = GET_EQ(ch, WEAR_WIELD2))) {
      send_to_char("You must be wielding some kind of weapon.\n\r", ch);
d1926 12
a1937 12
    } else {
      disarm_prim = FALSE;
    }
  } 
  if (!(tar = get_char_room_vis(ch, ply_name))) {
    send_to_char("That creature isn't present.\n\r", ch);
    return;
  }
  if (tar == ch) {
    send_to_char("Be serious... use remove to disarm yourself.\r\n", ch);
    return;
  }
d1939 3
a1941 14
  if (GET_MOVE(ch) < DISARM_MOVEMENT) {
    act("You don't have the energy to do that.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (!IS_FIGHTING(ch) || ch->char_specials.fighting != tar) {
    act("You must in engage combat with $N before $e can be disarmed.", FALSE, ch, 0, tar, TO_CHAR);
    return;
  }
  for (obj = NULL, pos = 0; pos < NUM_WEARS; pos++) {
    if ((obj = tar->equipment[pos]) &&	/* Using something there */
	isname(obj_name, obj->name) &&	/* Same name */
	CAN_SEE_OBJ(ch, obj))	/* Can see it */
      break;
  }
d1943 2
a1944 17
  if (obj == NULL) {
    act("You can't seem to find it on $N.", FALSE, ch, 0, tar, TO_CHAR);
    return;
  }
  if (IS_AFFECTED(ch, AFF_FUMBLING_PRIM) ||
      IS_AFFECTED(ch, AFF_FUMBLING_SECOND)) {
    act("Impossible!  You're already fumbling for your own weapon.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (GET_OBJ_TYPE(obj) != ITEM_WEAPON /*&&
					 obj->type != ITEM_FIREWEAPON*/) {
    act("You can only disarm weapons.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  /* OK, now that we have found the victim and the object to disarm     */
  /* Determine whether a successful attempt or not by using player's    */
  /* dexterity, his learnability at this skill, and level difference    */
d1946 2
a1947 4
  percent = GET_SKILL(ch, SKILL_DISARM) +	/* max of 90 */
    dex_app_skill[GET_DEX(ch)].p_pocket +	/* max of 30 (avg of 15) */
    (GET_LEVEL(ch) - GET_LEVEL(tar));	/* max of 49 (avg of 10?) */
  /* total= 169 */
d1949 1
a1949 5
  /* thus far, only weapons can be disarmed, and so no penalty is incurred */
  /* later, if held items or helmets, etc can be disarmed since they're somewhat */
  /* more difficult (ie. helmet is secured on head), a fraction of percent is taken */
  /* to reflect this. */
  percent = (int) (percent * disarm_difficulty[pos]);
d1951 3
a1953 2
  /* 1 - 35 extra %-age pts to account for superlative dex or xp diff */
  skl_bonus = (int) ((percent - 69) / 2);
d1955 1
a1955 2
  if (skl_bonus > 0)
    percent += skl_bonus;
d1957 3
a1959 11
  percent = MAX(1, percent);
  
  /* has char tried to disarm within delay period?  if so, penalize them */
  if (ch->char_specials.action_delays[ACT_DELAY_DISARM])
    rnd_num -= 30;		/* 30% pts */
  
  rnd_num = number(1, percent);
  
  /* A is person disarming.  B is being disarmed
     
     Percent chance of following to happen:
d1961 5
a1965 5
     5% (1 -> 5)    -- A drops weapon in miserably failed disarm attempt.
     20% (6 -> 25)   -- A fumbles his primary (secondary) weapon in failed disarm attempt.
     50% (26 -> 75)  -- Nothing happens.
     20% (76 -> 95)  -- A forces B to fumble weapon.
     5% (96 -> 100) -- A forces weapon from B's grips.
d1967 1
a1967 1
  */
d1969 2
a1970 2
  /* if char tries to disarm again within 1->3 rds of violence, chance of success cut by a ~1/5 */
  ch->char_specials.action_delays[ACT_DELAY_DISARM] = number(1, 3);
d1972 35
a2006 22
  if (rnd_num <= 5) {
    act("$n fails $s disarming manuveur so badly, $e drops $s own weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("In a vain attempt, $n tries to disarm you, but instead, drops $s weapon.", FALSE, ch, 0, tar, TO_VICT);
    act("You fail miserably in your attempt to disarm $N.", FALSE, ch, 0, tar, TO_CHAR);
    
    obj = ch_obj;
    aff_who = ch;
  } else if (rnd_num <= 25) {
    act("$n failingly attempts a complex disarming technique on $N.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$e begins to fumble $s own weapon, loosing complete control over it.", FALSE, ch, 0, 0, TO_NOTVICT);
    act("$n starts to fumble $s weapon in a vain attempt to disarm you.", FALSE, ch, 0, tar, TO_VICT);
    act("You make a grave error in judgement, and lose control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
    
    aff_who = ch;
  } else if (rnd_num >= 26 && rnd_num <= 75) {
    act("$n tries to disarm $N, but $E neutralizes $s attempt.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("You neutralize $n's attempt to disarm you!", FALSE, ch, 0, tar, TO_VICT);
    act("Your disarming manuveur had no effect on $N.", FALSE, ch, 0, tar, TO_CHAR);
  } else if (rnd_num <= 95) {
    act("$n causes $N to fumble for $S weapon.", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$n causes you to fumble for your weapon.", FALSE, ch, 0, tar, TO_VICT);
    act("You cause $N to fumble for $S weapon.", FALSE, ch, 0, tar, TO_CHAR);
d2008 2
a2009 8
    aff_who = tar;
  } else {
    act("$n successfully knocks $N's weapon from his grips!", FALSE, ch, 0, tar, TO_NOTVICT);
    act("$n forces your weapon out of your hands with a fancy disarming manuveur.", FALSE, ch, 0, tar, TO_VICT);
    act("You make a great effort, and send $N's weapon crashing to the floor.", FALSE, ch, 0, tar, TO_CHAR);

    aff_who = tar;
  }
d2011 2
a2012 1
  improve_skill(ch, SKILL_DISARM);
d2014 25
a2038 13
  /* handle cases where either A or B loses hold of weapon */
  if (rnd_num <= 5 || rnd_num >= 96) {
    sprintf(Gbuf2, "%s lands on the floor.", obj->short_description);
    act(Gbuf2, FALSE, aff_who, 0, 0, TO_ROOM);
    act(Gbuf2, FALSE, aff_who, 0, 0, TO_CHAR);
    
    
    /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
    /* mutliple times, the delay count must be cumulative.  this count is decremented */
    /* in perform_violence(). */
    if (IS_NPC(aff_who)) {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = MOB_DROPPED_WEAP_DELAY;
d2040 5
a2044 1
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = MOB_DROPPED_WEAP_DELAY;
d2046 8
a2053 1
    } else {
d2055 11
a2065 1
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = PC_DROPPED_WEAP_DELAY;
d2067 23
a2089 55
	aff_who->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = PC_DROPPED_WEAP_DELAY;
      }
    }
    
    /* pc/mob trying to re-claim their weapon cannot defend themselves very well */
    /* only one skill type needed since whether this afect goes with prim or secondary */
    /* can be determined by examining the bitvectors */
    af.type = SKILL_DISARM_DROPPED_WEAP;
    af.duration = 10;		/* makes no difference.  when action_delay[] == 0, it's erased */
    af.modifier = 40;
    af.location = APPLY_AC;
    if (disarm_prim) {
      af.bitvector = AFF_DROPPED_PRIM;
      
      if (IS_AFFECTED(aff_who, AFF_FUMBLING_PRIM)) {
	for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	  if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	      af_ptr->bitvector & AFF_FUMBLING_PRIM) {
	    affect_remove(aff_who, af_ptr);
	    done = TRUE;
	  }
	}
      }
    } else {
      af.bitvector = AFF_DROPPED_SECOND;
      
      if (IS_AFFECTED(aff_who, AFF_FUMBLING_SECOND)) {
	for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	  if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	      af_ptr->bitvector & AFF_FUMBLING_SECOND) {
	    affect_remove(aff_who, af_ptr);
	    done = TRUE;
	  }
	}
      }
    }
    
    affect_to_char(aff_who, &af);
    
    /* items ONLY have this set when a MOB is successfuly disarmed */
    /* the item lays on the ground with this bit set, so when someone */
    /* attempts to get it, do_get() can handle it appropriately */
    SET_BIT(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED);
    
    /* we must remember who last held this item, so the MOB scanning for its */
    /* disarmed item knows THAT is it. */
    obj->last_to_hold = aff_who;
    
    /* now put item in room's list of objects.  since this is an aggressive */
    /* action, the disarmer will become visisble. */
    if (!ch->equipment[pos]) {
      send_to_char("Bug in disarm.\r\n", ch);
      return;
    }
    obj_to_room(unequip_char(aff_who, pos), aff_who->in_room);
d2091 11
a2101 6
    /* delay is in units of "pulse violence".  since a mob/pc can be disarmed */
    /* mutliple times, the delay count must be cumulative.  this count is decremented */
    /* in perform_violence(). */
    if (IS_NPC(aff_who)) {
      if (disarm_prim) {
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = MOB_FUMBLING_DELAY;
d2103 5
a2107 1
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = MOB_FUMBLING_DELAY;
d2109 6
a2114 1
    } else {
d2116 9
a2124 1
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = PC_FUMBLING_DELAY;
d2126 19
a2144 38
	aff_who->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = PC_FUMBLING_DELAY;
      }
    }
    
    /* pc/mob trying to re-claim their weapon cannot attack themselves very well */
    af.type = SKILL_DISARM_FUMBLING_WEAP;
    af.duration = 10;
    af.modifier = -10;
    af.location = APPLY_HITROLL;
    if (disarm_prim) {
      af.bitvector = AFF_FUMBLING_PRIM;
      
      for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	    af_ptr->bitvector & AFF_FUMBLING_PRIM) {
	  affect_remove(aff_who, af_ptr);
	  done = TRUE;
	}
      }
    } else {
      af.bitvector = AFF_FUMBLING_SECOND;
      
      for (af_ptr = aff_who->affected, done = FALSE; !done && af_ptr; af_ptr = af_ptr->next) {
	if (af_ptr->type == SKILL_DISARM_FUMBLING_WEAP &&
	    af_ptr->bitvector & AFF_FUMBLING_SECOND) {
	  affect_remove(aff_who, af_ptr);
	  done = TRUE;
	}
      }
    }
    
    affect_to_char(aff_who, &af);
  }
  /*DISARM_MOVEMENT = 0 - DISARM_MOVEMENT;*/
  alter_move(ch, DISARM_MOVEMENT);
  
  return;
  
d2219 3
@


1.75
log
@Fixed some loose-lose typos.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.74 2006/11/08 07:55:17 jps Exp jps $
d1007 5
a1011 3
  /* check for pk -- modified by Pergus 7/14/2002 */
  if( (!IS_NPC(vict) && !pk_allowed && GET_LEVEL(ch) > LVL_IMMORT) /* PvP */
  ||   ((IS_NPC(ch) && !IS_NPC(vict) && (IS_AFFECTED(ch, AFF_CHARM) && (ch->master != NULL))) && !pk_allowed)) /* Charmies vs Player*/
d1013 1
a1013 1
    send_to_char("Silly, you can't kick players!\r\n", ch);
d2204 3
@


1.74
log
@Change verbal instances of "breath" to "breathe"
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.73 2006/11/07 14:14:52 jps Exp $
d1978 1
a1978 1
    act("You make a grave error in judgement, and loose control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
d2001 1
a2001 1
  /* handle cases where either A or B looses hold of weapon */
d2202 3
@


1.73
log
@It is now impossible to throatcut AWARE mobs. Also if you throatcut
an ordinary mob, it properly gets its temporary AWAREness.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.72 2006/07/20 07:43:48 cjd Exp jps $
d51 1
a51 1
ACMD(do_breath)
d62 1
a62 1
  if(!IS_NPC(ch) && GET_SKILL(ch, SKILL_BREATH) < 1) 
d115 1
a115 1
    send_to_char("Usage: Breath <Fire/Gas/Frost/Acid/Lightning>", ch);
d135 1
a135 1
  improve_skill(ch, SKILL_BREATH); 
d2202 4
@


1.72
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.71 2006/04/26 18:46:24 rls Exp $
d1626 1
a1626 1
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
d1685 1
a1685 1
  af.bitvector = APPLY_NONE;
d2202 3
@


1.71
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.70 2006/04/26 04:28:30 rls Exp $
d387 1
a387 1
	send_to_char("&8You try to switch opponents and become confused&0\r\n",ch);
d404 1
a404 1
	act("&8$n tries to switch opponents, though becomes confused!&0",
d406 1
a406 1
	send_to_char("&8You try to switch opponents and become confused&0\r\n",
d1053 1
a1053 1
      send_to_char("&7&bYou fall over as you try to bash someone so large&0", ch);
d1055 1
a1055 1
      act("&7&b$n BOUNCES off you as $e tries to bash your much larger size&0", FALSE, ch, 0, vict, TO_VICT);
d1066 1
a1066 1
      send_to_char("&7&bYou fall over as you try to bash someone with such small size&0", ch);
d1068 1
a1068 1
      act("&7&b$n trips over you as $e tries to bash your much smaller size&0", FALSE, ch, 0, vict, TO_VICT);
d1207 1
a1207 1
      send_to_char("&7&bYou fall over as you try to bash someone with such small size&0", ch);
d1209 1
a1209 1
      act("&7&b$n trips over you as $e tries to bodyslam your much smaller size&0", FALSE, ch, 0, vict, TO_VICT);
d1665 1
a1665 1
    act("$N just tried to cut your throat. &0&6How cute!&0", FALSE, ch, 0, vict, TO_VICT);
d2202 3
@


1.70
log
@Throatcut error
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.69 2006/04/20 17:55:30 rls Exp $
d1685 1
a1685 1
  af.bitvector = APPLY_none0;
d2202 3
@


1.69
log
@Adjusted awareness for TC and Backstab.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.68 2006/04/11 15:29:57 rls Exp $
d1681 1
a1681 1
   /*sucks you get tense when some tries to cut your throat! Banyal */
d1685 1
d2202 3
@


1.68
log
@Forgot right level value for immortal in shapechange check for breath.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.67 2006/04/11 15:25:25 rls Exp $
d702 4
a705 3

  if (MOB_FLAGGED(vict, MOB_AWARE) && (GET_SKILL(ch, SKILL_BACKSTAB) < 90) &&
      CAN_SEE(ch, vict) && !FIGHTING(vict)) {
a1602 5
  if (ch != vict && ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }

d1626 8
a1633 2
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict)) 
    chance -= chance; /* Near automatic failure... there is however still a chance with modifiers*/
d1639 1
a1639 1
   chance += 200; /* sleeping should always be a coup de grace */
d2201 3
@


1.67
log
@tagged breath with shapechanged and mortal check
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.66 2005/08/20 16:18:11 cjd Exp $
d70 1
a70 1
	GET_LEVEL(ch->desc->original)) 
d2199 3
@


1.66
log
@instantkill was still to frequent, reworked it again to make
it happen less often.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.65 2005/08/05 04:43:22 jwk Exp $
d68 15
a82 6
  if (MOB_FLAGGED(ch, MOB_ANIMATED) || IS_AFFECTED(ch, AFF_CHARM))
  {
    act("You huff and puff but to no avail.",FALSE,ch,0,0,TO_CHAR);
    act("$n huffs and puffs but to no avail.",FALSE,ch,0,0,TO_ROOM);
    return;
  }
d84 1
a84 1
  breath = SPELL_FIRE_BREATH;
d2199 4
@


1.65
log
@Fixed the Breath problem... apparently whomever coded it didn't realize
arrays always start with 0 not 1... fixed it so the messages line up
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.64 2005/08/02 22:19:52 cjd Exp jwk $
d465 1
a465 1
  chance = 1000 - ((GET_SKILL(ch, SKILL_INSTANT_KILL) * 10) - (100 - GET_DEX(ch))  - (100 - GET_LEVEL(victim))) / 10;
d2190 4
@


1.64
log
@adjsuted instantkill so that it doesn't happen as often. also added
a check for DEX into it and made the delay reduce based on the PC's
level.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.63 2005/02/18 03:12:53 rls Exp $
d82 1
a82 1
    message = 1;
d87 1
a87 1
    message = 3;
d92 1
a92 1
    message = 5;
d97 1
a97 1
    message = 7;
d102 1
a102 1
    message = 9;
d2190 5
@


1.63
log
@Fixed crash bug w/ breath and no args or invalid arg.
Now displays appropriate syntax on failure.
Modifications to backstab/throat/instakill.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.62 2003/06/28 01:00:17 jjl Exp $
d464 2
a465 2
  /* Cleaned this up... more. RLS 02/12/05 */
  chance = 1000 - ((GET_SKILL(ch, SKILL_INSTANT_KILL) * 7) - GET_LEVEL(victim))/5;
d475 1
a475 1
    ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL] = 1000;
d658 1
a658 1
  if(!IS_NPC(vict) && !pk_allowed) 
d2190 5
@


1.62
log
@Added a bit of delay to backstab.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.61 2003/06/23 03:21:44 jjl Exp $
d58 1
a58 1
  
d61 3
a63 1
  if(GET_SKILL(ch, SKILL_BREATH) < 1) {
d69 7
a75 1
    return; 
d77 1
d79 2
a80 3
  one_argument(argument,arg);
  
  if(is_abbrev(arg, "fire")) {
d84 2
a85 1
  if(is_abbrev(arg, "gas")) {
d89 2
a90 1
  if(is_abbrev(arg, "frost")) {
d94 2
a95 1
  if(is_abbrev(arg, "acid")) {
d99 2
a100 1
  if(is_abbrev(arg, "lightning")) {
d104 5
a109 6
  if(!breath)
    breath = number(SPELL_FIRE_BREATH,SPELL_LIGHTNING_BREATH);

  /* I left this in as an example how NOT TO CODE! -gurlaek 8/28/1999 */
  /* message = ((breath-651)*2)-2;  hehe, well it works anyway :P */
    
d152 1
a152 1
    {
d164 2
a165 1
      else {
d168 1
a168 1
	  act("In $n's panicked rush to flee, $e trips!",FALSE,tch,0,0,TO_ROOM);
d174 2
a175 1
	else {
d179 2
a180 1
    }
d182 1
d446 1
a446 2
/* Instant kill is a automated skill.. its a chance in backstab to do em
   inhard ie instant kill Banyal */
d456 3
a458 2
      (GET_POS(victim) == POS_DEAD) || (ch->in_room != victim->in_room)
      || (GET_LEVEL(victim) > LVL_IMMORT))
d464 6
a469 3
  /* Throw them a bone.  C'mon. The chances of this actually working are 
   * next to nothing.  Skills in this range about 5%, which means you have 
   * a 1 in 4000 chance per backstab. */ 
d472 2
a473 5
  /* Cleaned this up. */
  chance = 800 - (GET_LEVEL(ch) * 7) + GET_LEVEL(victim) - 
    ((!AWAKE(victim)) ? 50 : 0); 
  
  if (number(1, chance) == 13) {
d480 3
a482 1
				/* instant_kill */
a486 1

d501 5
d545 2
a546 2
  if (FIGHTING(victim))
    stop_fighting(victim);
d590 1
a590 2
    if (!IS_NPC(real_char))         /* If killed dont save in room he died
				       in */
d598 1
a598 2
/* NEW fucntion!! this allows for a quick death in mid stride that looks
   right to onlookers Banyal */
d635 2
a636 1
  if (!(vict = get_char_room_vis(ch, buf))) {
d645 3
a647 1
  if (vict == ch) {
d651 1
d653 1
a653 1
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
d656 1
d658 2
a659 1
  if(!IS_NPC(vict) && !pk_allowed) {
d663 1
d674 1
a674 1
      send_to_char("You're a little busy getting hit to backstab.\r\n", ch); 
d686 1
a686 1
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
d690 1
a690 1
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
d696 3
a698 3
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
d704 1
d709 1
d711 1
a711 1
    prob += GET_SKILL(ch, SKILL_BACKSTAB) / 2;
d713 4
a716 3
  if (!instantkill(ch, vict)) {
    if (AWAKE(vict) && (percent > prob)){
      hit(ch, vict, TYPE_UNDEFINED);
d721 2
a722 2
      act("$n makes a strange sound as you place something in $s back!", FALSE, vict, GET_EQ(ch, WEAR_WIELD), ch, TO_VICT);
      act("$N places something in the back of $n, resulting in some strange noises and some blood!", FALSE, vict, GET_EQ(ch, WEAR_WIELD), ch, TO_NOTVICT);
d724 4
a727 1
    }else{
d735 4
a738 2
    if (GET_CLASS(ch) == CLASS_ASSASSIN) {
      if (!GET_EQ(ch, WEAR_WIELD2)) {
d741 3
a743 1
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT) {
d746 1
d748 3
a750 1
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict) && !FIGHTING(vict)) {
d753 1
d755 3
a757 1
      if (!CAN_SEE(vict, ch)) {
d760 3
a762 1
      if (AWAKE(vict) && (percent2 > prob2)) {
d765 3
a767 1
      } else {
d771 1
d776 2
a777 1
  if(!IS_AFFECTED3(vict, AFF3_AWARE)) {
d791 1
a791 2
  send_to_char("This command has been removed - just backstab while you're not "
	       "tanking! \r\n", ch); 
d1625 1
a1625 1
    chance += 100;
d1628 1
a1628 1
    chance += 50;
d2154 4
a2157 1
  
d2190 3
@


1.61
log
@Updated backstab to ignore AWARE if the mob is fighting,
Allowing you to backstab effectively in combat.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.60 2003/06/23 02:08:10 jjl Exp $
d605 5
d699 1
d701 2
a702 1
    
d2140 4
@


1.60
log
@Removed level check for circle like backstabbing
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.59 2003/06/21 03:43:03 jjl Exp $
a604 8
  /* avoid rampant abuse*/ 
  if (SKILL_DELAY(ch, SKILL_BACKSTAB) > 0) {
    send_to_char("Backstabbing again now would draw too much attention to "
		 "yourself.\r\n", ch); 
    return;
  }
  SKILL_DELAY(ch, SKILL_BACKSTAB) = 3; 

d664 1
a664 1
      CAN_SEE(ch, vict)) {
d673 1
a673 1
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
d704 1
a704 1
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict)) {
d2133 3
@


1.59
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.58 2003/06/21 01:16:28 jjl Exp jjl $
a670 6
  /* this should keep lowbies from "Circle"ing. */
  if (FIGHTING(vict) && (GET_SKILL(ch, SKILL_BACKSTAB) < 50)) {
    send_to_char("Your skill isn't high enough to backstab a fighting person..\r\n", ch);
    return;
  }
  
d2141 3
@


1.58
log
@Changed delay - felt way too long.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.57 2003/06/21 01:01:08 jjl Exp jjl $
a1507 2
  SKILL_DELAY(ch, SKILL_THROATCUT) = SECS_PER_MUD_HOUR * 5; 

d1576 3
d2147 3
@


1.57
log
@Modified rogues.  Removed circle - backstab is now circlicious.  Updated
damage on backstab to give a little more pop.  Throatcut is now a once a day.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.56 2003/06/18 14:55:36 rls Exp $
d1508 1
a1508 1
  SKILL_DELAY(ch, SKILL_THROATCUT) = SECS_PER_MUD_DAY; 
d2146 4
@


1.56
log
@Added is_npc check to throat so PC victims aren't losing levels upon being throated with pk on.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.55 2003/04/16 02:00:22 jjl Exp $
d448 9
a456 3
  
  chance = MAX(30, (800 - (GET_LEVEL(ch) * 7) + GET_LEVEL(victim) - (!AWAKE(victim) ? 50 : 0)));
  
a458 1
    improve_skill(ch, SKILL_INSTANT_KILL);
d601 1
a601 1
  struct char_data *vict;
d604 9
a612 1
  
d620 7
a626 2
    send_to_char("Backstab who?\r\n", ch);
    return;
d647 7
a653 3
  if (FIGHTING(ch)) {
    send_to_char("You can not seem to sneak up behind the person you're fighting!\r\n", ch);
    return;
d655 3
a657 1
  if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
a661 7
  /*
    if (GET_RACE(ch) == RACE_TROLL || GET_RACE(ch) == RACE_OGRE) {
    send_to_char("Smirk. I don't believe you could sneak behind anything to stab it.\r\n", ch);
    return;
    }
    * removed by Nechtrous */
  
d670 2
d735 1
d749 3
a751 97
{
  struct char_data *vict;
  int percent, prob;
  struct obj_data *weapon;
  
  if (GET_SKILL(ch, SKILL_CIRCLE) < 1) {
    send_to_char("You dont know how.\r\n", ch);
    return;
  } 
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return;
  }
  
  /* removed by nechtrous - circle should only be while fighting. No targeting.
     one_argument(argument, buf);
     
     if (!(vict = get_char_room_vis(ch, buf))) {
     send_to_char("Circle who?\r\n", ch);
     return;
     }
     if (vict == ch) {
     send_to_char("How can you sneak up on yourself?\r\n", ch);
     return;
     }
  */
  if (!(vict=FIGHTING(ch))) {
    send_to_char("You have to be engaged to pull that off!", ch);
    return;
  }
  if (FIGHTING(FIGHTING(ch)) == ch) {
    act("$E's paying a little too much attention to you right now.", FALSE,  
	ch, NULL, vict, TO_CHAR);
    return;
  }
  
  if (!(weapon = GET_EQ(ch, WEAR_WIELD))) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(weapon, 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
    return;
  }
  
  if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict)) {
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(ch, vict, TYPE_UNDEFINED);
    return;
  }
  
  percent = number(1, 500);	/* Prob for circle should never be near 100% */
  prob = GET_SKILL(ch, SKILL_CIRCLE);
  if (!CAN_SEE(vict, ch))
    prob += GET_SKILL(ch, SKILL_CIRCLE) / 2;
  
  if (AWAKE(vict) && (percent > prob)){
    act("You notice $N trying to slip behind you!", FALSE, vict, 0, ch, 
	TO_CHAR);
    act("$e notices you trying to slip behind $m!", FALSE, vict, 0, ch, 
	TO_VICT);
    act("$n notices $N trying to slip behind $m!", FALSE, vict, 0, ch, 
	TO_NOTVICT);
    improve_skill(ch, SKILL_CIRCLE);
  }else{
    act("$N slips behind you and places $S $o in your back!", FALSE, vict, 
	weapon, ch, TO_CHAR);
    act("You slip behind $m and place your $o in $s back!", FALSE, vict, 
	weapon, ch, TO_VICT);
    act("$N slips behind $n and places $S $o in $s back!", FALSE, vict, 
	weapon, ch, TO_NOTVICT);
    hit(ch, vict, SKILL_BACKSTAB);
    improve_skill(ch, SKILL_CIRCLE);
  }
  /* Circle should only yeild 1 attack - nechtrous
     if (GET_CLASS(ch) == CLASS_ASSASSIN) {
     if (!GET_EQ(ch, WEAR_WIELD2)) 
     return;
     if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT)
     return;
     
     percent2 = number(1, 200);
     prob2 = GET_SKILL(ch, SKILL_CIRCLE);
     if (!CAN_SEE(vict, ch))
     prob2 += GET_SKILL(ch, SKILL_CIRCLE) / 2;
     
     if (AWAKE(vict) && (percent2 > prob2)){
     hit2(ch, vict, TYPE_UNDEFINED);
     improve_skill(ch, SKILL_CIRCLE);
     }else{
     hit2(ch, vict, SKILL_BACKSTAB);
     improve_skill(ch, SKILL_CIRCLE);}}
  */
  WAIT_STATE(ch, PULSE_VIOLENCE);
  
a1269 5
  if (SKILL_DELAY(ch, SKILL_KICK) > 0) {
    send_to_char("You can't kick again so soon.  Cuz that'd be lame and stuff.",ch); 
    return ; 
  };

a1274 2
  /* 4 second delay! */
  SKILL_DELAY(ch, SKILL_KICK) = 4; 
d1502 5
d1508 2
d2146 3
@


1.55
log
@Added skill timers for Zzur.  They don't save to file, so they were a
quickie.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.54 2003/01/04 08:19:06 jjl Exp $
a1736 2


d1797 2
a1798 1
  GET_EXP(vict) = MAX(1, GET_EXP(vict) - newExp); /* and make sure we don't have negative exp gains */
d2220 4
@


1.54
log
@Fixed up bash and kick; they should behave a little more like Pergy intended now.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.53 2002/12/28 21:56:30 jjl Exp $
d1344 5
d1353 4
d2221 3
@


1.53
log
@Added delay for punk-mobs standing up and fleeing
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.52 2002/12/04 08:02:40 rls Exp jjl $
d1030 1
d1032 2
a1033 1
  if(!IS_NPC(vict) && !pk_allowed) 
d1035 1
a1035 1
    send_to_char("You can't bash players!\r\n", ch);
d1038 1
d1374 1
a1374 1
  ||   ((IS_NPC(ch) && (IS_AFFECTED(ch, AFF_CHARM) && (ch->master != NULL))) && !pk_allowed)) /* Charmies vs Player*/
d2212 3
@


1.52
log
@Fixed kick so switched imms and pk toggled charmies could kick
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.51 2002/12/02 03:19:21 rls Exp $
d922 2
a923 1
    break;
d2209 3
@


1.51
log
@commented out testing message in throatcut
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.50 2002/11/30 22:50:32 rls Exp rls $
d1351 4
a1354 2
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
d1356 3
a1358 1
    } else {
d1369 2
a1370 1
  if(!IS_NPC(vict) && !pk_allowed) 
d1372 1
a1372 1
    send_to_char("You can't kick players!\r\n", ch);
d1375 6
a1380 3
  /* check for shapechanged players */
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
     GET_LEVEL(vict->desc->original) < 100 && !pk_allowed) {
d2208 3
@


1.50
log
@Throatcut update
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.49 2002/11/24 04:44:55 rls Exp $
d1697 2
a1698 2
  sprintf(buf, "&7&bYour roll: %d, your skill (chance): %d, and your random: %d, victim->level: %d.&0", percent, chance, random, GET_LEVEL(vict));
  act(buf, FALSE, ch, 0, vict, TO_CHAR);
d2200 3
@


1.49
log
@Forgot to comment out testing message... whoopsies
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.48 2002/11/24 04:39:50 rls Exp rls $
d1555 1
a1555 1
  int random, chance, skill, dam, newExp;
d1563 1
a1563 1
  skill = GET_SKILL(ch, SKILL_THROATCUT);
d1580 5
d1631 1
a1631 1
  chance = dice(1,100) - (GET_LEVEL(vict) - GET_LEVEL(ch));
d1644 2
d1691 1
a1691 1
  if (chance > 85)
d1694 1
a1694 1
      chance = 85;
d1697 2
a1698 2
  /*  sprintf(buf, "&7&bYour chance: %d, your skill: %d, and your random: %d, victim->level: %d.&0", chance, skill, random, GET_LEVEL(vict));
  act(buf, FALSE, ch, 0, vict, TO_CHAR); */
d1701 1
a1701 1
  if ( chance > skill )
d1754 1
a1754 1
  else if ((chance < 0) && (dice(1,100) < 11))
d2200 3
@


1.48
log
@Rewrite of Throatcut to perferm more often, but with less effectiveness and exp hinderance.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.47 2002/09/21 02:38:38 jjl Exp $
d1690 2
a1691 2
    sprintf(buf, "&7&bYour chance: %d, your skill: %d, and your random: %d, victim->level: %d.&0", chance, skill, random, GET_LEVEL(vict));
  act(buf, FALSE, ch, 0, vict, TO_CHAR); 
d2193 3
@


1.47
log
@Quickie fix to make necros not be able to order dragon skeletons to breathe.
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.46 2002/09/15 04:32:47 jjl Exp $
d33 1
d49 1
d1551 2
a1552 4
ACMD(do_throatcut) {
  /* Buru 4/12/97 */
  /* reformatted by Gurlaek 7/13/1999 Holy extra curly braces batman!!! */

d1555 10
a1564 1
  int percent, prob, p2;
d1566 1
a1566 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
d1571 3
a1573 5
  if (!(GET_LEVEL(ch) >= LVL_IMMORT)) {
    if (GET_SKILL(ch, SKILL_THROATCUT) == 0) {
      send_to_char("I don't think so!!\r\n", ch);
      return;
    }
d1576 1
a1576 1
  if (IS_FIGHTING(ch)) {
d1580 1
d1582 2
a1583 1
  if ((!(vict = get_char_room_vis(ch, buf)))&& (!(vict == ch))) {
d1587 2
a1588 1
  if (vict == ch) {
d1592 1
a1592 5
  if (GET_SKILL(ch, SKILL_THROATCUT) == 0) {
    send_to_char("You aren't skilled enough!\r\n", ch);
    return;
  }
  
d1597 1
d1602 1
d1607 1
d1612 1
d1618 1
d1626 1
a1626 2
  percent = number(0,101);
  p2 = percent;
d1629 4
a1632 1
    percent = -150; /* silent failure, just like backstab */
d1634 27
a1660 2
  if (GET_POS(vict)<=POS_SLEEPING) {
    prob = 10 + percent +((GET_SKILL(ch, SKILL_THROATCUT)/100)+(GET_LEVEL(ch)/10));
a1661 4
  prob = percent +((GET_SKILL(ch, SKILL_THROATCUT)/100)+(GET_LEVEL(ch)/10));
  
  if (GET_LEVEL(ch) >= LVL_IMMORT)
    prob = 100;
d1663 9
a1671 17
  if (prob > 100){
    prob = 100;}
  
  if ((!IS_NPC(vict))&&(GET_LEVEL(vict) == LVL_GOD)){
    {sprintf(buf, "&0$N laughs out loud at your miserable attempt!&0");
    act(buf, FALSE, ch, 0, vict, TO_CHAR);}
    {sprintf(buf, "&0$N just tried to cut your throat. &0&6How cute!&0");
    act(buf, FALSE, vict, 0, ch, TO_CHAR);}
    return;}
  if((GET_SPECIES(vict) == 4)||(GET_SPECIES(vict) == 5)){
    send_to_char("It is far too difficult to cut their throat!\r\n", ch);
    return;}
  if (MOB_FLAGGED(vict, MOB_AWARE) && CAN_SEE(ch, vict)) {
    act("You notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
d1674 2
a1675 1
  /*sucks you get tense when some tries to cut your throat! Banyal */
d1677 1
a1677 1
  af.duration = 2;
d1683 9
d1693 52
a1744 14
  /* PC -> PC ATTACKS */
  if (!IS_NPC(vict)) {
    if (GET_LEVEL(ch) < 50) {
      if ((prob > 60) && (prob < 92)) {
        improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);                
	damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);
	return;
a1745 126
      if ((prob > 91) && (prob < 97)) {
        improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	return;
      }
      if ((prob > 96) && (prob < 101)) {
        improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);                
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	if (GET_HIT(vict)>-1) {
	  GET_HIT(vict) = -1;
	  update_pos(vict);
	}
	return;
      }
      if (prob < 61) {
        improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
	damage(ch, vict, 0, SKILL_THROATCUT);
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(abs(p2)/5));
	return;
      }
    }
    if (GET_LEVEL(ch) > 49) {
      WAIT_STATE(ch, PULSE_VIOLENCE); 
      if ((prob > 30) && (prob < 70)) {
        improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);                
	damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);
        return;
      }
      if ((prob > 69) && (prob < 91)) {
	WAIT_STATE(ch, PULSE_VIOLENCE);
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/20))+((percent*2)/10), SKILL_THROATCUT);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	return;
      }
      if ((prob > 90) && (prob <= 101)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);                
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	if (GET_HIT(vict)>-1) {
	  GET_HIT(vict) = -1;
	  update_pos(vict);
	}
	return;	
      }
      if (prob < 31) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);                
	damage(ch, vict, 0, SKILL_THROATCUT);
	if(GET_LEVEL(ch) < LVL_IMMORT) {
	  GET_HIT(ch) = (GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(abs(p2)/3)));
	}
	return;
      }
    }
d1747 63
a1809 71
  /* PC -> MOB ATTACKS */
  if (IS_NPC(vict)) {
    if (GET_LEVEL(ch) < 50) {
      if ((prob > 80) && (prob < 95)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);
	return;
      }
      if ((prob > 94) && (prob < 99)) {
	
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);  
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	return;
      }
      if ((prob > 98) && (prob < 101)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	if (GET_HIT(vict)>-1) {
	  GET_HIT(vict) = -1;
	  update_pos(vict);
	}
	return;
      }
      if (prob < 81) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);  
	damage(ch, vict, 0, SKILL_THROATCUT);
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(abs(p2)/5));
	return;
      }
    }
d1811 2
a1812 70
    if (GET_LEVEL(ch) > 49) {
      if ((prob > 50) && (prob < 85)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);
	return;
      }
      if ((prob > 84) && (prob < 95)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/20))+((percent*2)/10), SKILL_THROATCUT);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	return;
      }
      if ((prob > 94) && (prob <= 101)) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	if(PLR_FLAGGED(vict, PLR_CASTING)) {
	  if (IS_NPC(vict))
	    REMOVE_BIT(MOB_FLAGS(vict), MOB_CASTING);
	  REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
	  act("You stop chanting abruptly!", FALSE, vict, 0, 0, TO_CHAR);
	  act("$n stops chanting abruptly!",FALSE, vict, 0, 0, TO_ROOM); 
	}
	if (GET_HIT(vict)>-1) {
	  GET_HIT(vict) = -1;
	  update_pos(vict);
	}
	return;
      }
      if (prob < 51) {
	improve_skill(ch, SKILL_THROATCUT);
	sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
	sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);
	sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);
	WAIT_STATE(ch, PULSE_VIOLENCE);
	damage(ch, vict, 0, SKILL_THROATCUT);
	if(GET_LEVEL(ch) < LVL_IMMORT) {
	  GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(abs(p2)/3));
	}
	return;
      }
    }
d1814 3
d2193 3
@


1.46
log
@hitall with no arguments should now actually hit everything fighting you on a success
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.45 2002/09/13 02:32:10 jjl Exp $
d51 1
d63 4
d132 3
d182 5
d2318 3
@


1.45
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.offensive.c,v 1.44 2002/07/16 19:30:58 rls Exp $
d2290 1
a2290 1
	      if (!(is_aggr_to(mob, ch) || (IS_FIGHTING(mob) && (FIGHTING(ch) == ch))))
d2305 3
@


1.44
log
@*** empty log message ***
@
text
@d1 3
a3 1
// $Id: act.offensive.c,v 1.43 2002/03/30 13:09:05 dce Exp $
d455 2
a456 2
  //  register struct char_data *k;
  //  extern struct char_data *character_list;
d2303 205
a2507 200
// $Log: act.offensive.c,v $
// Revision 1.43  2002/03/30 13:09:05  dce
// Added a pluse violence to the rescuer so you couldn't
// do 50 rescues at once. You should only be able to do
// one a round.
//
// Revision 1.42  2002/02/20 02:32:53  rls
// Fixed "You switch opponents" line for success and "You are doing the best
// can" msg when killing same opponent.
//
// Revision 1.41  2002/02/19 02:06:30  dce
// Added a carriage return to 'You panic and flee' message.
//
// Revision 1.40  2002/02/18 02:25:07  dce
// Moved the POS calls in bash and bodyslam to occur after
// the damage calls. Also made size failed bashes and bodyslams
// cause battle to begin.
//
// Revision 1.39  2002/02/07 00:48:47  dce
// Modified the bash code so Paladins and Anti-Paladins do not
// get the 20% bonus when trying to bash if they do not have
// a shield.
//
// Revision 1.38  2001/12/13 00:37:50  dce
// In an attempt to fix the blob bug I modified bash and bodyslam
// I added GET_POS1() = POS1_SITTING and I added an update_pos
// for the victim.
//
// Revision 1.37  2001/12/12 02:45:03  dce
// Fixed Throatcut so it doesn't cause so much damage
// for a failed attempt.
//
// Revision 1.36  2001/12/10 22:36:49  dce
// Fixed throatcut from adding hitting points to a player
// when failing a throatcut
//
// Revision 1.35  2001/12/07 03:34:48  dce
// Toned down throatcut. Wasn't check to see if mobs were aware.
// Success was too easy, because everything was based on Hubis's
// 36 levels or whatever.
//
// Revision 1.34  2001/10/10 21:04:02  rjd
// Kick command is checked against the switch skill if a person attempts to kick while already fighting.
//
// Revision 1.33  2001/05/13 16:15:58  dce
// Fixed a bug where somethings wouldn't save when a player
// died and exitied menu option 0 rather than menu option 1.
// Fixed a bug in slow death...it was a null pointer type
// of deal.
//
// Revision 1.32  2001/05/12 13:56:20  dce
// Adjusted backstab so that players now at least have a chance
// of getting a backstab. The old chance was based on Hubis's
// level scheme and therefore making it impossible to backstab
// once you passed level 50.
//
// Revision 1.31  2001/03/10 18:45:33  dce
// Changed do_return function to pass a subcommand of 1.
// This way I can make it so players can't use the return command.
//
// Revision 1.30  2001/03/07 01:45:18  dce
// Added checks so that players can not kill shapechanged players and
// vise versa. Hopefully I didn't miss any...
//
// Revision 1.29  2001/03/04 17:50:23  dce
// Added a bunch of checks to prevey skills for being used in
// peaceful rooms.
//
// Revision 1.28  2000/12/06 00:08:55  mtp
// fixed throatcut?
//
// Revision 1.27  2000/11/20 03:55:57  rsd
// added back rlog messages from prior to the addition of
// the $log$ string.
//
// Revision 1.26  2000/04/22 22:26:58  rsd
// put return newline in combat switch messages, was reported
// in bug file.
//
// Revision 1.25  2000/04/17 00:50:54  rsd
// altered comment header.  Added hack to send info to players
// who backstab because a successful backstab isn't calling
// the lines out of the message file for some reason.
// Retabbed and braced do_backstab as well
//
// Revision 1.24  2000/03/26 21:13:19  cso
// made teh messages for do_circle a bit clearer
//
// Revision 1.23  2000/02/25 03:15:30  cso
// fixed numerous typos relating to peaceful rooms and backstab.
//
// Revision 1.22  1999/12/06 20:18:25  cso
// Fixed some typos.. "panicked" instead of "paniced", "You're doing"
// instead of "Your doing".
//
// Revision 1.21  1999/11/28 22:41:16  cso
// fixed misspelled schizophrenia
// do_order: animated mobs can now order
// cahnged wait state on order
//
// Revision 1.20  1999/10/30 15:18:41  rsd
// Jimmy coded up new paladin alignment restriction code for
// exp, I altered gain_exp to add reference to the victim for
// alignment checks.
//
// Revision 1.19  1999/09/16 01:43:06  dce
// *** empty log message ***
//
// Revision 1.18  1999/09/16 01:15:11  dce
// Weight restrictions for monks...-hitroll, -damroll + ac
//
// Revision 1.17  1999/09/08 07:06:03  jimmy
// More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
// with blood and killing
// --gurlaek
//
// Revision 1.16  1999/09/08 00:10:52  mtp
// alter_move _removes_ moves, fixed do_disarm to remove 10 moves
//
// Revision 1.15  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.14  1999/09/03 23:02:40  mtp
// added IS_FIGHTING check to throatcut
//
// Revision 1.13  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most 
// significant changes were moving all the BREATH's to within normal spell 
// range, and fixing the way socials were allocated.  Too many small fixes 
// to list them all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.12  1999/07/22 17:43:59  jimmy
// Reduced all skill stun times by 1/2.  this is to compensate a little for
// increasing the combat rounds by 2*.
// --gurlaek
//
// Revision 1.11  1999/07/15 03:41:31  jimmy
// Doh!
//
// Revision 1.10  1999/07/15 03:27:34  jimmy
// Mob casters can not hit while casting.
// Updated spell cast times to be more realistic
// changed combat to 4 seconds per round.
// Removed do_order semantics that told the order to onlookers.
//
// Revision 1.9  1999/07/14 19:24:03  jimmy
// The combat system was enhanced/improved in the following ways:  Mobs
// can no longer flee while bashed or sitting.  Fleeing causes casters to
// stop casting.  You can now flee while flying.  pk checks were added to
// bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
// fixes. spellcasting for mobs is now very similar to PC spellcasting.
// MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
// Mobs no longer improve skills.  Bash now requires mobs to have a shield
// just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
// --gurlaek
//
// Revision 1.8  1999/06/30 18:25:04  jimmy
// >> This is a major conversion from the 18 point attribute system to the
// >> 100 point attribute system.  A few of the major changes are:
// >> All attributes are now on a scale from 0-100
// >> Everyone views attribs the same but, the attribs for one race
// >>   may be differeent for that of another even if they are the
// >>   same number.
// >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
// >> Mobs now have individual random attributes based on race/class.
// >> The STR_ADD attrib has been completely removed.
// >> All bonus tables for attribs in constants.c have been replaced by
// >>   algorithims that closely duplicate the tables except on a 100 scale.
// >> Some minor changes:
// >> Race selection at char creation can now be toggled by using
// >>   <world races off>
// >> Lots of cleanup done to affected areas of code.
// >> Setting attributes for mobs in the .mob file no longer functions
// >>   but is still in the code for later use.
// >> We now have a spare attribut structure in the pfile because the new
// >>   system only used three instead of four.
// >> --gurlaek 6/30/1999
//
// Revision 1.7  1999/04/03 18:59:22  dce
// Debug to see if feeble attempt works.
//
// Revision 1.6  1999/04/03 18:54:17  dce
// Feeble attempt to stop slow death crashes.
//
// Revision 1.5  1999/03/21 21:49:37  dce
// Disallows pkilling.
//
// Revision 1.4  1999/03/10 00:03:37  dce
// Monk semantics for dodge/parry/ripost/attack
//
// Revision 1.3  1999/03/08 23:24:48  dce
// Added Springleap for monks
//
// Revision 1.2  1999/02/20 18:41:36  dce
// Adds improve_skill calls so that players can imprve their skills.
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.43
log
@Added a pluse violence to the rescuer so you couldn't
do 50 rescues at once. You should only be able to do
one a round.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.42 2002/02/20 02:32:53 rls Exp $
d601 2
a602 2
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
d607 1
a607 1
  if(!IS_NPC(ch) && vict->desc && vict->desc->original &&
d966 1
a966 1
    sprintf(buf, "&8It is just to dark!&0");
d1012 3
a1014 2
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
d1026 1
a1026 1
    send_to_char("You need to wear a shield to make it a success, but go on try then!\r\n", ch);
d1346 4
a1349 2
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
d1588 2
a1589 2
  /* check for pk --gurlaek 7/11/1999 */
  if(!IS_NPC(ch) && !IS_NPC(vict) && !pk_allowed) {
d1980 1
a1980 1
  /* disarmer must be wielding a weapon. */
d1988 1
a1988 1
  }
d2302 5
@


1.42
log
@Fixed "You switch opponents" line for success and "You are doing the best
can" msg when killing same opponent.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.41 2002/02/19 02:06:30 dce Exp $
d1306 3
a1309 1
    WAIT_STATE(vict, PULSE_VIOLENCE);
d2299 4
@


1.41
log
@Added a carriage return to 'You panic and flee' message.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.40 2002/02/18 02:25:07 dce Exp $
d340 1
a340 1
      send_to_char("&7You're doing the best you can!&0", ch);
d358 1
a358 1
	send_to_char("&8You switch opponents!&0", ch);
d2297 3
@


1.40
log
@Moved the POS calls in bash and bodyslam to occur after
the damage calls. Also made size failed bashes and bodyslams
cause battle to begin.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.39 2002/02/07 00:48:47 dce Exp $
d935 1
a935 1
	  sprintf(buf, "&0You panic and flee %s!&0", dirs[attempt]);
d2297 5
@


1.39
log
@Modified the bash code so Paladins and Anti-Paladins do not
get the 20% bonus when trying to bash if they do not have
a shield.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.38 2001/12/13 00:37:50 dce Exp $
d1058 4
a1063 2
      WAIT_STATE(ch, PULSE_VIOLENCE);  /* lag basher 2 rounds */
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75; /* delay basher */
d1071 4
a1076 2
      WAIT_STATE(ch, PULSE_VIOLENCE); /* lag basher 2 rounds */
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75; /* delay basher */
a1081 3
    /* sit down basher */
    GET_POS(ch) = POS_SITTING; 
    GET_POS1(ch) = POS1_SITTING;
d1088 3
a1090 1

a1094 3
      /* sit down bashee */
      GET_POS(vict) = POS_SITTING;
      GET_POS1(vict) = POS1_SITTING;
d1103 6
d1200 3
a1204 1
      WAIT_STATE(ch, PULSE_VIOLENCE);
d1212 3
a1216 1
      WAIT_STATE(ch, PULSE_VIOLENCE);
d1222 3
a1226 2
    /* DON'T move damage() call */
    damage(ch, vict, 0, SKILL_BODYSLAM);
a1228 2
      GET_POS(vict) = POS_SITTING;
      GET_POS1(vict) = POS1_SITTING;
d1233 2
d2297 5
@


1.38
log
@In an attempt to fix the blob bug I modified bash and bodyslam
I added GET_POS1() = POS1_SITTING and I added an update_pos
for the victim.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.37 2001/12/12 02:45:03 dce Exp $
d1026 1
a1026 1
    prob = (int)(GET_SKILL(ch, SKILL_BASH) / 4);
d1038 1
a1038 1
     (GET_EQ(ch, WEAR_2HWIELD))) {
d2286 5
@


1.37
log
@Fixed Throatcut so it doesn't cause so much damage
for a failed attempt.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.36 2001/12/10 22:36:49 dce Exp $
d1059 1
d1070 1
d1080 1
d1094 1
d1113 1
d1195 1
d1205 1
d1213 1
d1219 1
d1231 1
d1233 1
a1233 2
  }
  
d1235 1
d2286 4
@


1.36
log
@Fixed throatcut from adding hitting points to a player
when failing a throatcut
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.35 2001/12/07 03:34:48 dce Exp $
d1514 1
a1514 1
  int percent, prob;
d1575 3
a1577 1
  if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
a1579 1

d1682 1
a1682 1
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(abs(percent)/5));
d1752 1
a1752 1
	  GET_HIT(ch) = (GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(abs(percent)/3)));
d1825 1
a1825 1
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(abs(percent)/5));
d1895 1
a1895 1
	  GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(abs(percent)/3));
d2276 4
@


1.35
log
@Toned down throatcut. Wasn't check to see if mobs were aware.
Success was too easy, because everything was based on Hubis's
36 levels or whatever.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.34 2001/10/10 21:04:02 rjd Exp $
d1681 1
a1681 1
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));
d1751 1
a1751 1
	  GET_HIT(ch) = (GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3)));
d1824 1
a1824 1
	GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));
d1894 1
a1894 1
	  GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3));
d2275 5
@


1.34
log
@Kick command is checked against the switch skill if a person attempts to kick while already fighting.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.33 2001/05/13 16:15:58 dce Exp $
d1574 5
d1580 1
a1580 1
    prob = 10 + percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));
d1582 1
a1582 2
  percent = number(0,101);
  prob = percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));
d1586 1
a1586 1
  
d1608 1
a1608 1
  af.duration = 1;
d1639 1
a1639 1
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);
d1657 1
d1695 1
d1697 1
a1698 1
      return;
d1700 1
a1700 1
	WAIT_STATE(ch, PULSE_VIOLENCE / 2);
d1708 1
a1708 1
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);
d1726 1
d1748 1
a1748 1
	WAIT_STATE(ch, PULSE_VIOLENCE);
d1782 1
a1782 1
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);
d1800 1
d1838 1
a1838 1
	WAIT_STATE(ch, PULSE_VIOLENCE / 2);
d1850 2
a1851 2
	WAIT_STATE(ch, PULSE_VIOLENCE / 2);
	damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);
d1869 1
d2275 3
@


1.33
log
@Fixed a bug where somethings wouldn't save when a player
died and exitied menu option 0 rather than menu option 1.
Fixed a bug in slow death...it was a null pointer type
of deal.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.32 2001/05/12 13:56:20 dce Exp $
d1334 37
d2266 6
@


1.32
log
@Adjusted backstab so that players now at least have a chance
of getting a backstab. The old chance was based on Hubis's
level scheme and therefore making it impossible to backstab
once you passed level 50.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.31 2001/03/10 18:45:33 dce Exp $
d455 1
a455 1
  int i;
d514 7
a520 1
      
d522 1
a522 1
	{
d525 1
a525 1
	}
d2229 6
@


1.31
log
@Changed do_return function to pass a subcommand of 1.
This way I can make it so players can't use the return command.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.30 2001/03/07 01:45:18 dce Exp $
d432 1
a432 1
  chance = MAX(10, (430 - (GET_LEVEL(ch) * 7) + GET_LEVEL(victim) - (!AWAKE(victim) ? 50 : 0)));
d2223 4
@


1.30
log
@Added checks so that players can not kill shapechanged players and
vise versa. Hopefully I didn't miss any...
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.29 2001/03/04 17:50:23 dce Exp $
d545 1
a545 1
    do_return(real_char, "", 0, 0);
d2223 4
@


1.29
log
@Added a bunch of checks to prevey skills for being used in
peaceful rooms.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.28 2000/12/06 00:08:55 mtp Exp $
d233 5
d304 13
d600 6
d1011 6
d1158 6
d1321 7
d1391 7
a1397 1
  
d1524 6
d2223 4
@


1.28
log
@fixed throatcut?
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.27 2000/11/20 03:55:57 rsd Exp mtp $
d208 4
d275 5
a279 1
  
d367 5
a371 1
  
d402 3
a404 3
if(!victim || !ch || ch == victim || ch == NULL || victim == NULL)
  return FALSE;
  
d573 4
d691 4
d940 4
d1090 4
d1203 4
d1261 4
d1310 4
d1423 5
d1827 5
d2108 5
d2168 3
@


1.27
log
@added back rlog messages from prior to the addition of
the $log$ string.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.26 2000/04/22 22:26:58 rsd Exp $
d1395 1
a1433 1
  one_argument(argument, buf);
d2113 4
@


1.26
log
@put return newline in combat switch messages, was reported
in bug file.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.25 2000/04/17 00:50:54 rsd Exp $
d2113 4
d2159 78
@


1.25
log
@altered comment header.  Added hack to send info to players
who backstab because a successful backstab isn't calling
the lines out of the message file for some reason.
Retabbed and braced do_backstab as well
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.24 2000/03/26 21:13:19 cso Exp $
d320 1
a320 1
	send_to_char("&8You try to switch opponents and become confused&0",ch);
d339 1
a339 1
	send_to_char("&8You try to switch opponents and become confused&0",
d2113 6
@


1.24
log
@made teh messages for do_circle a bit clearer
@
text
@d1 3
a3 3
// $Id: act.offensive.c,v 1.23 2000/02/25 03:15:30 cso Exp $
/* ************************************************************************
 *   File: act.offensive.c                               Part of HubisMUD  *
d6 2
a7 1
 *                                                                         *
d9 1
a9 1
 ************************************************************************ */
a13 1

d615 6
d629 1
a629 1
      if (!GET_EQ(ch, WEAR_WIELD2)) 
d631 2
a632 1
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD2), 3) != TYPE_PIERCE - TYPE_HIT)
d634 1
a634 1
      
d636 1
a636 1
      if (IS_AFFECTED3(vict, AFF3_AWARE) && AWAKE(vict))
d638 1
a638 1
      
d640 1
a640 1
      if (!CAN_SEE(vict, ch))
d642 2
a643 2
      
      if (AWAKE(vict) && (percent2 > prob2)){
d646 1
a646 1
      }else{
d2113 3
@


1.23
log
@fixed numerous typos relating to peaceful rooms and backstab.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.22 1999/12/06 20:18:25 cso Exp $
d662 1
d686 2
a687 1
    send_to_char("You cannot seem to get behind your foe.", ch);
d691 1
a691 1
  if (!GET_EQ(ch, WEAR_WIELD)) {
d695 1
a695 1
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
d714 6
a719 1
    hit(ch, vict, TYPE_UNDEFINED);
d722 6
d2106 3
@


1.22
log
@Fixed some typos.. "panicked" instead of "paniced", "You're doing"
instead of "Your doing".
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.21 1999/11/28 22:41:16 cso Exp $
d548 1
a548 1
    send_to_char("You dont know how.\r\n", ch);
d567 1
a567 1
    send_to_char("You can not seem to sneak up behind the person you fighting!\r\n", ch);
d571 1
a571 1
    send_to_char("You cant see a thing!\r\n", ch);
d1397 1
a1397 1
    send_to_char("&0You feel ashamed trying to disturb the peace of this room.&0\r\n", ch);
d2048 1
a2048 1
    send_to_char("&0You feel ashamed trying to disturb the peace of this room.&0\r\n", ch);
d2093 4
@


1.21
log
@fixed misspelled schizophrenia
do_order: animated mobs can now order
cahnged wait state on order
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.20 1999/10/30 15:18:41 rsd Exp $
d143 2
a144 2
	  act("In your paniced rush to flee, you trip!",FALSE,tch,0,0,TO_CHAR);
	  act("In $n's paniced rush to flee, $e trips!",FALSE,tch,0,0,TO_ROOM);
d314 1
a314 1
      send_to_char("&7Your doing the best you can!&0", ch);
d832 1
a832 1
    act("Looking paniced, $n scrambles madly to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
d2093 5
@


1.20
log
@Jimmy coded up new paladin alignment restriction code for
exp, I altered gain_exp to add reference to the victim for
alignment checks.
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.19 1999/09/16 01:43:06 dce Exp $
d758 1
a758 1
    send_to_char("You obviously suffer from skitzofrenia.\r\n", ch);
d761 2
a762 1
    if (IS_AFFECTED(ch, AFF_CHARM)) {
d776 1
a776 1
	WAIT_STATE(ch, PULSE_VIOLENCE);
d796 1
a796 1
	WAIT_STATE(ch, (PULSE_VIOLENCE * 3) / 2);
d2093 5
@


1.19
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.18 1999/09/16 01:15:11 dce Exp dce $
d449 1
a449 1
    gain_exp(victim->desc->original, -(GET_EXP(victim->desc->original) >> 1));
d451 1
a451 1
    gain_exp(victim, -(GET_EXP(victim) >> 1));
d2092 3
@


1.18
log
@Weight restrictions for monks...-hitroll, -damroll + ac
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.17 1999/09/08 07:06:03 jimmy Exp dce $
d1230 1
a1230 1
  percent = ((10 - ((GET_AC(vict)+(monk_weight_pen(vict)*5)) )/ 10)) << 1) + number(1, 101);
d2092 3
@


1.17
log
@More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
with blood and killing
--gurlaek
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.16 1999/09/08 00:10:52 mtp Exp $
d1082 1
a1082 1
  prob += GET_HITROLL(ch); 
d1230 1
a1230 1
  percent = ((10 - (GET_AC(vict) / 10)) << 1) + number(1, 101);
d1288 1
a1288 1
  percent = ((10 - (GET_AC(vict) / 10)) << 1) + number(1, 72);
d2092 5
@


1.16
log
@alter_move _removes_ moves, fixed do_disarm to remove 10 moves
@
text
@d1 1
a1 1
// $Id: act.offensive.c,v 1.15 1999/09/05 07:00:39 jimmy Exp mtp $
d263 1
a263 1
    sprintf(buf, "&8It is just to damn dark!&0");
d268 1
a268 1
    send_to_char("You cant see a thing!\r\n", ch);
d272 1
a272 1
  if (!*arg)
d274 1
a274 1
  else if (!(vict = get_char_room_vis(ch, arg)))
d276 1
a276 1
  else if (vict == ch) {
d279 1
a279 1
  } else if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master == vict))
d281 1
a281 1
  else {
d291 6
a296 4
      if (IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(vict)) {
        send_to_char("Do it yourself wimp!\r\n", ch);
	return;			/* you can't order a charmed pet to attack a
				 * player */
d298 3
a300 2
    }     /*All new for switch skill Banyal*/
    /*if(GET_POS(ch) < POS_STANDING) {
d303 26
a328 3
      }else*/ if(FIGHTING(ch) == NULL) {
        if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
	   hit(ch,vict,SKILL_BAREHAND);
d330 5
a334 6
	   hit(ch, vict, TYPE_UNDEFINED);
	WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	WAIT_STATE(vict, PULSE_VIOLENCE);
	return;	
      }else if(vict == FIGHTING(ch)) {
	send_to_char("&7Your doing the best you can!&0", ch);
d336 1
a336 23
      }else if(GET_SKILL(ch, SKILL_SWITCH) > 0)
	if(number(1, 101) > GET_SKILL(ch, SKILL_SWITCH)) {
	  act("&8$n tries to switch opponents, though becomes confused!&0",
	      FALSE, ch, 0, vict, TO_ROOM);
	  send_to_char("&8You try to switch opponents and become confused&0",
		       ch);
	  stop_fighting(ch);
          improve_skill(ch, SKILL_SWITCH);
	  WAIT_STATE(ch, PULSE_VIOLENCE + 2);
	  return;
	}else{
	  stop_fighting(ch);
          if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
	     hit(ch, vict, SKILL_BAREHAND);
	  else
	     hit(ch, vict, TYPE_UNDEFINED);
	  act("&8$n switches opponents!&0", FALSE, ch, 0, vict, TO_ROOM); 
	  send_to_char("&8You switch opponents!&0", ch);
          improve_skill(ch, SKILL_SWITCH);
	  WAIT_STATE(ch, PULSE_VIOLENCE);
	  return;
	}
      else {
d339 6
a344 6
    send_to_char("&8You try to switch opponents and become confused&0",
		 ch);   
    stop_fighting(ch);
    WAIT_STATE(ch, PULSE_VIOLENCE + 2);
    return;
   }	
d2092 3
@


1.15
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d2020 1
a2020 1
  alter_move(ch, -DISARM_MOVEMENT);
d2088 4
a2091 1
// $Log$
@


1.14
log
@added IS_FIGHTING check to throatcut
@
text
@d1 1
d2088 1
@


1.13
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d1366 4
@


1.12
log
@Reduced all skill stun times by 1/2.  this is to compensate a little for
increasing the combat rounds by 2*.
--gurlaek
@
text
@d62 1
a62 3
  if(is_abbrev(arg, "lightning"))
    breath = SPELL_LIGHTNING_BREATH;
  if(is_abbrev(arg, "fire"))
d64 3
a66 1
  if(is_abbrev(arg, "gas"))
d68 3
a70 1
  if(is_abbrev(arg, "frost"))
d72 3
a74 1
  if(is_abbrev(arg, "acid"))
d76 7
d85 4
a88 3
  
  message = ((breath-651)*2)-2; /* hehe, well it works anyway :P */
  
@


1.11
log
@Doh!
@
text
@d95 1
a95 1
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
d134 1
a134 1
	  WAIT_STATE(tch,PULSE_VIOLENCE*2);
d144 1
a144 1
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
d179 1
a179 1
	WAIT_STATE(tch, PULSE_VIOLENCE*2);
d184 1
a184 1
    WAIT_STATE(ch, PULSE_VIOLENCE*2);
d239 1
a239 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d604 1
a604 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d627 1
a627 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d721 1
a721 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d759 1
a759 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d779 1
a779 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d962 1
a962 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);  /* lag basher 2 rounds */
d972 1
a972 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2); /* lag basher 2 rounds */
d982 1
a982 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 4);
d995 1
a995 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 4);
d997 1
a997 1
      WAIT_STATE(vict, PULSE_VIOLENCE * 3);
d1083 1
a1083 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1092 1
a1092 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1104 2
a1105 2
      WAIT_STATE(ch, PULSE_VIOLENCE * 4);
      WAIT_STATE(vict, PULSE_VIOLENCE * 4);
d1157 1
a1157 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1175 1
a1175 1
    WAIT_STATE(vict, 2 * PULSE_VIOLENCE);
d1217 1
a1217 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d1220 1
a1220 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d1288 1
a1288 1
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d1300 2
a1301 2
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
	  WAIT_STATE(vict, PULSE_VIOLENCE * 3);
d1322 2
a1323 2
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      WAIT_STATE(vict, PULSE_VIOLENCE * 3);
d1438 1
a1438 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);                
d1450 1
a1450 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1490 1
a1490 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);
d1497 1
a1497 1
      WAIT_STATE(ch, PULSE_VIOLENCE * 2); 
d1510 1
a1510 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
d1557 1
a1557 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1577 1
a1577 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d1590 1
a1590 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);  
d1630 1
a1630 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);  
d1646 1
a1646 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
d1658 1
a1658 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
d1698 1
a1698 1
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d2068 1
a2068 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
@


1.10
log
@Mob casters can not hit while casting.
Updated spell cast times to be more realistic
changed combat to 4 seconds per round.
Removed do_order semantics that told the order to onlookers.
@
text
@d767 1
a767 1
	act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);
@


1.9
log
@The combat system was enhanced/improved in the following ways:  Mobs
can no longer flee while bashed or sitting.  Fleeing causes casters to
stop casting.  You can now flee while flying.  pk checks were added to
bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
fixes. spellcasting for mobs is now very similar to PC spellcasting.
MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
Mobs no longer improve skills.  Bash now requires mobs to have a shield
just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
--gurlaek
@
text
@d762 7
a768 3
      sprintf(buf, "$n issues the order '%s'.", message);
      act(buf, FALSE, ch, 0, vict, TO_ROOM);
      
@


1.8
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@d254 4
a257 4
if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
} 
d399 2
a400 2
/*Stock code did no allow for a pc/npc to die w/o a killer
  this clased with toggle vicous poisened etc so here is a
d545 5
d551 1
a551 2
    send_to_char("You can not seem to sneak up behind the person you fighting!\r\n", 
		 ch);
d555 1
a555 1
    send_to_char("You cant see a damn thing!\r\n", ch);
d787 1
a787 1
  
d790 2
a791 2
  if (IS_NPC(ch))
    if (GET_MOB_WAIT(ch) > 0)
d793 3
d798 1
a798 1
  
d803 1
a804 1
    return;
a807 1
    return;
a812 1
    act("&8$n scrambles madly to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
a813 1
    return;
d817 1
a817 1
    
d830 12
a850 1
	    
d860 2
d863 1
d866 3
a868 1

d875 1
a875 1
    sprintf(buf, "&8It is just to damn dark!&0");
d879 2
a880 1
  
d887 1
a887 1
    send_to_char("You cant see a damn thing\r\n", ch);
d917 12
a928 10
  if (!(IS_NPC(ch))) {
    if (!GET_EQ(ch, WEAR_SHIELD) && !GET_EQ(ch, WEAR_2HWIELD)) {
      send_to_char("You need to wear a shield to make it a success, but go on try then!\r\n", ch);
      prob = (int)(GET_SKILL(ch, SKILL_BASH) / 4);
    }
    else if (GET_EQ(ch, WEAR_2HWIELD)){
      prob = GET_SKILL(ch, SKILL_BASH)/ 2;
    }
    else
      prob = GET_SKILL(ch, SKILL_BASH);
d932 2
a933 1
  percent = number(1, 101);	/* 101% is a complete failure */
d935 1
d937 6
a942 2
     (GET_EQ(ch, WEAR_2HWIELD)))
    prob += 20;
d945 1
d951 1
d957 3
a959 3
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
d967 3
a969 3
      GET_POS(ch) = POS_SITTING;
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
d974 8
a981 3
  
  
  if (percent > prob) {
d983 6
a988 6
    GET_POS(ch) = POS_SITTING; 
    if (!(IS_NPC(ch)))
      ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
  } else {
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BASH);
    if (IS_NPC(vict) || GET_LEVEL(vict) < LVL_IMMORT){
d990 3
d994 7
a1000 4
      if (!(IS_NPC(ch)))
	ch->char_specials.action_delays[ACT_DELAY_BASH] = 75;
      if(PLR_FLAGGED(vict, PLR_CASTING) || MOB_FLAGGED(vict,
						       MOB_CASTING)){
d1003 2
a1004 1
	REMOVE_BIT(PLR_FLAGS(vict), PLR_CASTING);
a1009 2
  
  WAIT_STATE(ch, PULSE_VIOLENCE * 4);
d1012 1
a1012 1
}/*hurm*/
d1014 1
d1021 1
a1021 1
    sprintf(buf, "&8It is just to damn dark!&0");
d1035 1
a1035 1
  
d1043 2
a1044 1
    return;    }
d1054 5
a1058 1
  
a1092 2
  
  
d1094 2
a1096 1
    GET_POS(ch) = POS_SITTING; 
a1097 1
    damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_BODYSLAM);
d1100 1
d1102 2
a1113 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 4);
a1114 1
  
d1203 5
a1209 1
  
d1213 1
d1215 1
a1216 1
  } else {
a1217 4
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  }
  if (IS_NPC(ch)) {    
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
a1219 1
  
d1262 5
d1284 1
a1285 1
	  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
a1295 1
	  damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
d1298 1
a1317 1
      damage(ch, vict, GET_LEVEL(ch) >> 1, SKILL_SPRINGLEAP);
d1320 1
d1335 4
a1338 3
ACMD(do_throatcut)
     /* Buru 4/12/97 */
{
d1342 1
a1348 9
  one_argument(argument, buf);
  percent = number(0,101);
  prob = percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));
  
  if (GET_LEVEL(ch) >= LVL_IMMORT)
    prob = 100;
  
  if (prob > 100){
    prob = 100;}
a1357 2
  if (GET_POS(vict)<=POS_SLEEPING){
    prob = 10 + percent +((GET_SKILL(ch, SKILL_THROATCUT)/10)+(GET_LEVEL(ch)/10));}
d1379 19
d1424 3
a1426 3
  if (!IS_NPC(vict)){
    if (GET_LEVEL(ch) < 50){
      if ((prob > 60) && (prob < 92)){
d1428 6
a1433 7
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
d1435 4
a1438 2
	return;}
      if ((prob > 91) && (prob < 97)){
d1440 9
a1448 9
	
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1455 3
a1457 3
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);
	return;}
      if ((prob > 96) && (prob < 101)){
d1459 7
a1465 7
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1472 7
a1478 5
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;}
      if (prob < 61){
d1480 11
a1490 10
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	{GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));}
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);                
	return;}
d1492 3
a1494 3
    
    if (GET_LEVEL(ch) > 49){
      if ((prob > 30) && (prob < 70)){
d1496 20
a1515 20
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);                        
	return;}
      if ((prob > 69) && (prob < 91)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1522 11
a1532 11
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
	return;}
      if ((prob > 90) && (prob <= 101)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1539 23
a1561 17
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;	}
      if (prob < 31){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  {GET_HIT(ch) = (GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3)));}}
	
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);	return;}}}
d1563 10
a1572 12
  if (IS_NPC(vict)){
    if (GET_LEVEL(ch) < 50){
      if ((prob > 80) && (prob < 95)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	
d1574 4
a1577 2
	return;}
      if ((prob > 94) && (prob < 99)){
d1579 10
a1588 9
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1595 11
a1605 11
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);                        
	return;}
      if ((prob > 98) && (prob < 101)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1612 19
a1630 16
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;}
      if (prob < 81){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	{GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/(3))+1)*(percent/5));}
	WAIT_STATE(ch, PULSE_VIOLENCE * 3);             
	return;}
d1633 24
a1656 23
    if (GET_LEVEL(ch) > 49){
      if ((prob > 50) && (prob < 85)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0You barely cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0Your throat hurts as %s wielded by $N barely cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	
	{sprintf(buf, "&0$N barely cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, GET_DAMROLL(ch)+((percent*2)/10), SKILL_THROATCUT);}
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);                        
	return;}
      if ((prob > 84) && (prob < 95)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0You cut the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&8Your throat &0stings&b&8 as %s wielded by $N deeply cuts your throat!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N deeply cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, (GET_DAMROLL(ch)*(GET_LEVEL(ch)/10))+((percent*2)/10), SKILL_THROATCUT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1663 11
a1673 11
	WAIT_STATE(ch, PULSE_VIOLENCE * 1);
	return;}
      if ((prob > 94) && (prob <= 101)){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&9You sever the throat of $N with %s.&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0&b&9Your throat is severed as &0%s &0&b&9wielded by $N &0&b&9slices your &0&1jugular!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N &0&b&1severed&0 the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	if(PLR_FLAGGED(vict, PLR_CASTING)){
d1680 23
a1702 18
	if (GET_HIT(vict)>-1){
	  {GET_HIT(vict) = -1;}
	  {  update_pos(vict);}}
	return;	}
      if (prob < 51){
        improve_skill(ch, SKILL_THROATCUT);
	{sprintf(buf, "&0&b&8You cut your fingers!&0");
	act(buf, FALSE, ch, 0, vict, TO_CHAR);}
	{sprintf(buf, "&0$n just tried to cut your throat!&0");
	act(buf, FALSE, vict, 0, ch, TO_CHAR);}
	{sprintf(buf, "&0$N just tried to cut the throat of $n with %s!&0", GET_EQ(ch, WEAR_WIELD)->short_description);
	act(buf, FALSE, vict, 0, ch, TO_NOTVICT);}
	{damage(ch, vict, 0, SKILL_THROATCUT);}
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  {GET_HIT(ch) = GET_HIT(ch)-(((GET_DAMROLL(ch)/2)+1)*(percent/3));}}
	WAIT_STATE(ch, PULSE_VIOLENCE * 2);				
	return;}}}
  
d1768 1
@


1.7
log
@Debug to see if feeble attempt works.
@
text
@d129 1
a129 1
	if(GET_DEX_VAFF(tch)-15 < number(0,100) && GET_POS(tch) >= POS_FIGHTING) {
d172 1
a172 1
      if ((GET_DEX_VAFF(tch)-15) > number(0,100) || GET_POS(tch) < POS_FIGHTING)
@


1.6
log
@Feeble attempt to stop slow death crashes.
@
text
@d411 3
a413 1
  if ((!victim) || (victim == NULL))
d415 1
@


1.5
log
@Disallows pkilling.
@
text
@d411 3
@


1.4
log
@Monk semantics for dodge/parry/ripost/attack
@
text
@d214 1
a214 1
      act("Use 'murder' if you really want to attack $N.", FALSE,
d271 1
a271 1
	send_to_char("Use 'murder' to hit another player.\r\n", ch);
d274 6
a279 1
      if (IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(vict))
d282 1
@


1.3
log
@Added Springleap for monks
@
text
@d282 4
a285 1
	hit(ch, vict, TYPE_UNDEFINED);
d304 4
a307 1
	  hit(ch, vict, TYPE_UNDEFINED);
@


1.2
log
@Adds improve_skill calls so that players can imprve their skills.
@
text
@d1170 1
a1170 1
  if (GET_CLASS(ch) != CLASS_RANGER) 
d1172 1
a1172 1
    send_to_char("&0You'd better leave all the martial arts to fighters.&0\r\n", ch);
d1176 1
a1176 1
  if (GET_POS(ch) > POS_SITTING)
d1178 1
a1178 1
    send_to_char("&0You must sit down first!&0\r\n", ch);
d1195 1
a1195 1
    send_to_char("&0Aren't we funny today...&0\r\n", ch);
a1217 1
	  
@


1.1
log
@Initial revision
@
text
@d92 2
a93 1
    } 
d141 2
a142 1
    } 
d181 2
a182 1
    } 
d296 1
d304 1
d308 1
a308 1
      else
d315 2
a316 1
    return;	
d532 4
a535 4
if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing!\r\n", ch);
return;
}
d847 4
a850 4
if ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell (ch, SPELL_BLINDNESS))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
}
d899 1
a899 1
    percent = 101;
d901 1
a901 1
    percent = 101;
d979 1
a979 1
    send_to_char("You cant bodyslam in combat....", ch);
d1049 1
a1049 1
  /*  improve_skill(ch, SKILL_BASH);*/ 
d1090 1
d1147 1
a1147 1
  } else
d1149 5
a1153 4
  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  if (IS_NPC(ch))	{
    
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);}
d1164 5
a1168 5
    {
      sprintf(buf, "&8It is too dark!&0");
      send_to_char(buf, ch);
      return;
    }
d1171 4
a1174 4
    {
      send_to_char("&0You'd better leave all the martial arts to fighters.&0\r\n", ch);
      return;
    }
d1177 4
a1180 4
    {
      send_to_char("&0You must sit down first!&0\r\n", ch);
      return;
    }
d1184 2
d1187 4
a1190 9
      if (FIGHTING(ch)) 
	{
	  vict = FIGHTING(ch);
	} 
      else 
	{
	  send_to_char("&0Springleap who?&0\r\n", ch);
	  return;
	}
d1192 1
d1194 4
a1197 4
    {
      send_to_char("&0Aren't we funny today...&0\r\n", ch);
      return;
    }
d1277 2
a1278 1
    }}
d1349 1
d1360 1
d1379 1
d1398 1
d1413 1
d1425 1
d1443 1
d1462 1
d1478 1
d1491 1
d1509 1
d1528 1
d1543 1
d1555 1
d1573 1
d1592 1
a1604 1
  
d1775 2
a1782 1
    improve_skill(ch, SKILL_DISARM);
@
