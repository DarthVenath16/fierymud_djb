head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.17.07.59.42;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.04.05.14.16;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.16.14.21.04;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.05.16.26.57;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.02.07.16.00;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.24.02.37.01;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.14.20.38.42;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.21.00.42.30;	author rsd;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.26.15.03.40;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.22.23.24.49;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	99.11.28.23.03.02;	author cso;	state Exp;
branches;
next	1.5;

1.5
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.14.52.02;	author dce;	state Exp;
branches;
next	1.3;

1.3
date	99.04.22.01.44.49;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.21.40.33;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: corpse.c                                      Part of HubisMUD *
*  Usage: Handling of player corpses                                      *
*                                                                         *
*  Author : Nechtrous                                                     *
************************************************************************ */


/* Notes:

This file handles the corpse saving operation for the mud. Some current
points of interest are:
1. There are 2 main file structure that make up the corpse saving routine.
   One is the corpse control record file. This file is currently
   lib/etc/ccontrol. This file contains an index of all ACTIVE player
   corpses. The second is the numerous files dynamically created in
   lib/corpse/ directory. These files contain the object listings of
   the corpses.
2. There can only be a set number of player corpses allowed at a time.
   MAX_CORPSES in corpse_save.h is set to the current number. The higher it
   is set, the more amount of memory that is needed.
3. Currently all corpses will save when either the corpse passes through
   obj_to_room to update the vnum OR when the corpses passes through
   extract_obj in which case the corpse is deleted from disk. This event
   driven system is workable, however, if this system proves to cause
   any amount of lag under heavy strain a time based system may be used.
   This time based system would save all corpses every set amount of time.
   This would require the use of flagging much like house code.
4. When a corpse is created, it is inserted into memory and written to disk.
   The files produced are sequential numerical assignments. For example, the
   very 1st corpse created will be 0.corpse, the 2nd will be 1.corpse and so
   on. This system will continue until a time is reached that there are NO
   player corpses in the game, then the numerical system will start over.
   Keep in mind that the corpse control record is dynamic whereas the file
   names are sequential and will not fill gaps created.
5. Currently all corpses loaded off disk from crash will repopulate with
   the player inventory, having taken all of the items out of any
   containers. To retain the items assignment to particular containers
   would be a good project in the future.
*/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "corpse_save.h"

extern char *dirs[];
extern struct room_data *world;
extern int top_of_world;
extern const int rev_dir[];
extern struct index_data *obj_index;


struct obj_data *Obj_from_store(struct obj_file_elem object);
int Obj_to_store(struct obj_data * obj, FILE * fl);

struct corpse_control_rec corpse_control[MAX_CORPSES];
int num_of_corpses = 0;
int top_of_corpse_list=0;


/* Return a filename given a corpse index */
int Corpse_get_filename(int index, char *filename)
{
  if (index < 0)
    return 0;

  sprintf(filename, "corpse/%d.corpse", index);
  return 1;
}


/* Load all objects for a corpse */
int Corpse_load(int index, struct obj_data *corpse)
{
  FILE *fl;
  char fname[MAX_STRING_LENGTH];
  struct obj_file_elem object;

  if (!corpse) {
    log("SYSERR: Null object passed to Corpse_load.");
    return 0;
  }
  if (!Corpse_get_filename(index, fname)) {
    log("SYSERR: invalid index passed from Corpse_load.");
    return 0;
  }
  if (!(fl = fopen(fname, "r+b"))) {
    log("SYSERR: Corpse in control file not located on disk.");
    return 0;
  }
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("Reading corpse file: Corpse_load.");
      fclose(fl);
      return 0;
    }
    if (!feof(fl))
      obj_to_obj(Obj_from_store(object), corpse);
  }

  fclose(fl);

  return 1;
}


/* Save all objects for a corpse (recursiv, initial call must be followed
   by a call to Corpse_restore_weight)  Assumes file is open already. */
int Corpse_save(struct obj_data * obj, FILE * fp)
{
  struct obj_data *tmp;
  int result;

  if (obj) {
    Corpse_save(obj->contains, fp);
    Corpse_save(obj->next_content, fp);
    result = Obj_to_store(obj, fp);
    if (!result)
      return 0;

    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);
  }
  return 1;
}


/* restore weight of containers after Corpse_save has changed them for saving */
void Corpse_restore_weight(struct obj_data * obj)
{
  if (obj) {
    Corpse_restore_weight(obj->contains);
    Corpse_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
  }
}


/* Save all objects in a corpse */
void Corpse_crashsave(int index, struct obj_data *corpse)
{
  char buf[MAX_STRING_LENGTH];
  FILE *fp;

  if (!IS_CORPSE(corpse)) {
    log("SYSERR: Non-corpse object passed to Corpse_crashsave");
    return;
  }
  if (!Corpse_get_filename(index, buf)) {
    log("SYSERR: Invalid index passed from Corpse_crashsave");
    return;
  }
  if (!(fp = fopen(buf, "wb"))) {
    perror("SYSERR: Error saving corpse file");
    return;
  }
  if (!Corpse_save(corpse->contains, fp)) {
    fclose(fp);
    return;
  }
  fclose(fp);
  Corpse_restore_weight(corpse->contains);
}


/* Delete a corpse save file */
void Corpse_delete_file(int index)
{
  char buf[MAX_INPUT_LENGTH], fname[MAX_INPUT_LENGTH];
  FILE *fl;

  if (!Corpse_get_filename(index, fname)) {
    log("SYSERR: Invalid index passed from Corpse_delete_file");
    return;
  }
  if (!(fl = fopen(fname, "rb"))) {
    if (errno != ENOENT) {
      sprintf(buf, "SYSERR: Error deleting corpse file #%d. (1)", index);
      perror(buf);
    }
    return;
  }
  fclose(fl);
  if (unlink(fname) < 0) {
    sprintf(buf, "SYSERR: Error deleting corpse file #%d. (2)", index);
    perror(buf);
  }
}

/* find a corpse in the corpse control record */
int find_corpse(int index)
{
  int i;

  for (i = 0; i < num_of_corpses; i++)
    if (corpse_control[i].index == index)
      return i;

  return -1;
}



/* Save the corpse control information */
void Corpse_save_control(void)
{
  FILE *fl;

  if (!(fl = fopen(CCONTROL_FILE, "wb"))) {
    perror("SYSERR: Unable to open corpse control file");
    return;
  }
  /* write all the corpse control recs.*/
  fwrite(corpse_control, sizeof(struct corpse_control_rec), num_of_corpses, fl);

  fclose(fl);
}


/* call from boot_db - will load control recs, load corpses, load objs */
/* does sanity checks on vnums & removes invalid records */
void Corpse_boot(void)
{
  struct corpse_control_rec temp_corpse;
  sh_int real_corpse;
  struct obj_data *corpse;
  FILE *fl;
  extern int max_pc_corpse_time;

  memset((char *)corpse_control,0,sizeof(struct corpse_control_rec)*MAX_CORPSES);

  if (!(fl = fopen(CCONTROL_FILE, "rb"))) {
    log("Corpse control file does not exist.");
    return;
  }
  while (!feof(fl) && num_of_corpses < MAX_CORPSES) {
    fread(&temp_corpse, sizeof(struct corpse_control_rec), 1, fl);

    if (feof(fl))
      break;

    if ((real_corpse = real_room(temp_corpse.vnum)) < 0)
      continue;			/* this vnum doesn't exist -- skip */

    /* make the corpse */

    corpse = create_obj();

    corpse->item_number = NOTHING;
    corpse->in_room = NOWHERE;

    corpse->name = str_dup(temp_corpse.name);
    corpse->description = str_dup(temp_corpse.description);
    corpse->short_description = str_dup(temp_corpse.short_description);

    GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
    /*NO!!!!! GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE;*/
    GET_OBJ_EXTRA(corpse) = ITEM_NODONATE;
    GET_OBJ_VAL(corpse, 0) = 0;   /* You can't store stuff in a corpse */
    GET_OBJ_VAL(corpse, 1) = 1;   /* player corpse */
    GET_OBJ_VAL(corpse, 2) = temp_corpse.index;  /*index of corpse save file */
    GET_OBJ_VAL(corpse, 3) = 1;   /* corpse identifier */
    GET_OBJ_WEIGHT(corpse) = temp_corpse.weight;
    GET_OBJ_RENT(corpse) = 100000;
    GET_OBJ_TIMER(corpse) = max_pc_corpse_time;

    obj_to_room(corpse, real_corpse);
    corpse_control[num_of_corpses++] = temp_corpse;
    top_of_corpse_list = temp_corpse.index + 1;

    Corpse_load(temp_corpse.index, corpse);
  }

  fclose(fl);
  Corpse_save_control();
}

/* When a player dies, this function is called from make_corpse in fight.c */
void ccontrol_make_corpse(int vnum, struct obj_data *corpse)
{
  struct corpse_control_rec temp_corpse;
  sh_int real_corpse;

  if (num_of_corpses >= MAX_CORPSES) {
    log("SYSERR: Maximum number of corpses exceeded!");
    return;
  }

  if ((real_corpse = real_room(vnum)) < 0) {
    log("SYSERR: Corpse tried to load in an invalid room");
    return;
  }


  temp_corpse.index = GET_OBJ_VAL(corpse,2);
  temp_corpse.vnum = vnum;

  strcpy(temp_corpse.name, corpse->name);
  strcpy(temp_corpse.description, corpse->description);
  strcpy(temp_corpse.short_description, corpse->short_description);

  temp_corpse.weight = GET_OBJ_WEIGHT(corpse);

  corpse_control[num_of_corpses++] = temp_corpse;
  top_of_corpse_list++;

  Corpse_crashsave(temp_corpse.index, corpse);

  Corpse_save_control();
}


/* called from extract_obj when corpse rots or is otherwise removed from play */
void ccontrol_destroy_corpse(int index)
{
  int i, j;
  sh_int real_corpse;

  if ((i = find_corpse(index)) < 0)
    return;

  if ((real_corpse = real_room(corpse_control[i].vnum)) < 0)
    log("SYSERR: Corpse had invalid vnum!");

  Corpse_delete_file(corpse_control[i].index);

  for (j = i; j < num_of_corpses - 1; j++)
    corpse_control[j] = corpse_control[j + 1];

  num_of_corpses--;

  Corpse_save_control();
}


/* crash-save all the corpses */
/* may be useful later if corpses move to timed backup instead of event driven
   backup.
void Corpse_save_all(void)
{
  int i;
  sh_int real_corpse;

  for (i = 0; i < num_of_corpses; i++)
    if ((real_corpse = real_room(corpse_control[i].vnum)) != NOWHERE)
      if (IS_SET(ROOM_FLAGS(real_house), ROOM_HOUSE_CRASH))
	Corpse_crashsave(corpse_control[i].index);
}
*/
@


1.24
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: corpse_save.c,v 1.23 2009/03/17 07:59:42 jps Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: corpse_save.c                                 Part of FieryMUD  *
 *  Usage: Handling of player corpses                                      *
 * Author: Nechtrous, et al..                                              *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 ***************************************************************************/


/* Notes:

This file handles the corpse saving operation for the mud. Some current
points of interest are:
1. There are 2 main file structure that make up the corpse saving routine.
   One is the corpse control record file. This file is currently
   lib/etc/ccontrol. This file contains an index of all ACTIVE player
   corpses. The second is the numerous files dynamically created in
   lib/corpse/ directory. These files contain the object listings of
   the corpses.
2. There can only be a set number of player corpses allowed at a time.
   MAX_CORPSES in corpse_save.h is set to the current number. The higher it
   is set, the more amount of memory that is needed.
3. Currently all corpses will save when either the corpse passes through
   obj_to_room to update the vnum OR when the corpses passes through 
   extract_obj in which case the corpse is deleted from disk. This event
   driven system is workable, however, if this system proves to cause
   any amount of lag under heavy strain a time based system may be used.
   This time based system would save all corpses every set amount of time.
   This would require the use of flagging much like house code. 
4. When a corpse is created, it is inserted into memory and written to disk.
   The files produced are sequential numerical assignments. For example, the
   very 1st corpse created will be 0.corpse, the 2nd will be 1.corpse and so
   on. This system will continue until a time is reached that there are NO
   player corpses in the game, then the numerical system will start over.
   Keep in mind that the corpse control record is dynamic whereas the file
   names are sequential and will not fill gaps created.
5. Currently all corpses loaded off disk from crash will repopulate with
   the player inventory, having taken all of the items out of any 
   containers. To retain the items assignment to particular containers
   would be a good project in the future.
*/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "corpse_save.h"
#include "pfiles.h"
#include "math.h"
#include "limits.h"
#include "strings.h"

struct corpse_data {
  int id;
  struct obj_data *corpse;
  struct corpse_data *prev, *next;
};

static struct {
  struct corpse_data list;
  int count;
  bool allow_save;
} corpse_control;

#define SENTINEL                 (&corpse_control.list)

static void save_corpse_list(void);

int corpse_count(void)
{
  return corpse_control.count;
}

static void check_corpse_id(struct corpse_data *entry)
{

}

static void remove_entry(struct corpse_data *entry)
{
  entry->prev->next = entry->next;
  entry->next->prev = entry->prev;
  entry->prev = entry->next = NULL;
  free(entry);
  --corpse_control.count;
}


void free_corpse_list()
{
  while (SENTINEL->next != SENTINEL)
    remove_entry(SENTINEL->next);
}

void update_corpse(struct obj_data *corpse)
{
  save_corpse_list();
}

static int corpse_id(struct obj_data *corpse)
{
  int id = GET_OBJ_VAL(corpse, VAL_CORPSE_ID);
  return (id >= 0 ? id : -1);
}

/* Return a filename given a corpse id */
static bool get_corpse_filename(int id, char *filename)
{
  if (id < 0) {
    log("SYSERR(corpse_save.c): Corpse has id number < 0 no corpse loaded.");
    return FALSE;
  } else {
    sprintf(filename, "corpse/%d.corpse", id);
    return TRUE;
  }
}


/* Load all objects for a corpse */
static struct obj_data *load_corpse(int id)
{
  FILE *fl;
  char fname[MAX_STRING_LENGTH];
  struct obj_data *obj, *containers[MAX_CONTAINER_DEPTH + 1];
  int location, depth, i;
  extern int r_mortal_start_room;
  
  if (!get_corpse_filename(id, fname)) {
    log("SYSERR: invalid id passed from load_corpse.");
    return NULL;
  }
  if (!(fl = fopen(fname, "r"))) {
    log("SYSERR: Corpse in control file not located on disk.");
    return NULL;
  }

  get_line(fl, buf1);
  if (is_integer(buf1)) {
    depth = atoi(buf1);
    if ((depth = real_room(depth)) < 0) {
      sprintf(buf, "SYSERR: Unable to locate room %s for corpse %d", buf1, id);
      log("%s",buf);
      depth = r_mortal_start_room;
    }
  }
  else {
    sprintf(buf, "SYSERR: First line of corpse file not room vnum for corpse %d", id);
    log("%s",buf);
    if (strchr(buf1, ':'))
      rewind(fl);
    depth = r_mortal_start_room;
  }

  if (build_object(fl, &obj, &location)) {
    if (GET_OBJ_TYPE(obj) != ITEM_CONTAINER || !str_str(obj->name, "corpse")) {
      sprintf(buf, "SYSERR: First object '%s' loaded from corpse %d not corpse", obj->short_description, id);
      log("%s",buf);
      extract_obj(obj);
      return NULL;
    }
    containers[0] = obj;
    GET_OBJ_VAL(obj, VAL_CORPSE_ID) = id;
    GET_OBJ_VAL(obj, VAL_CONTAINER_CORPSE) = CORPSE_PC;
    obj_to_room(obj, depth);
  }
  else {
    sprintf(buf, "SYSERR: Unable to read in corpse data for corpse %d in load_corpse", id);
    log("%s",buf);
    return NULL;
  }

  while (!feof(fl)) {
    if (!build_object(fl, &obj, &location))
      break;
    depth = MAX(0, -location);
    for (i = MAX_CONTAINER_DEPTH - 1; i >= depth; --i)
      containers[i] = NULL;
    containers[depth] = obj;
    if (depth > 0)
      obj_to_obj(obj, containers[depth - 1]);
  }
  
  fclose(fl);

  /* Ensure that the items inside aren't marked for decomposition. */
  stop_decomposing(containers[0]);
  /* And mark the corpse itself as decomposing. */
  SET_FLAG(GET_OBJ_FLAGS(containers[0]), ITEM_DECOMP);

  
  return containers[0];
}


void save_corpse(struct obj_data *corpse)
{
  char buf[MAX_STRING_LENGTH];
  FILE *fp;
  int id;
  struct obj_data *temp;
  
  if (!IS_CORPSE(corpse)) {
    log("SYSERR: Non-corpse object passed to save_corpse");
    return;
  }
  if ((id = corpse_id(corpse)) < 0) {
    log("SYSERR: Invalid corpse id encountered in save_corpse");
    return;
  }
  if (!get_corpse_filename(id, buf)) {
    log("SYSERR: Invalid id passed from save_corpse");
    return;
  }
  if (!(fp = fopen(buf, "w"))) {
    perror("SYSERR: Error saving corpse file");
    return;
  }

  /* Corpse room vnum */
  fprintf(fp, "%d\n", corpse->in_room == NOWHERE ? NOWHERE :
          world[corpse->in_room].vnum);

  /*
   * Warning!  Hack:  write_objects writes out corpse->next_content.
   * But we don't want to write out other objects in the room where
   * the corpse is, so we'll temporarily set next_content to NULL.
   */
  temp = corpse->next_content;
  corpse->next_content = NULL;
  write_objects(corpse, fp, WEAR_INVENTORY);
  corpse->next_content = temp;

  fclose(fp);
}


/* Delete a corpse save file */
static void delete_corpse_file(int id)
{
  char buf[MAX_INPUT_LENGTH], fname[MAX_INPUT_LENGTH];
  FILE *fl;
  
  if (!get_corpse_filename(id, fname)) {
    log("SYSERR: Invalid id passed from delete_corpse_file");
    return;
  }
  if (!(fl = fopen(fname, "r"))) {
    sprintf(buf, "SYSERR: Error deleting corpse file %s.", fname);
    perror(buf);
    return;
  }
  fclose(fl);
  if (unlink(fname) < 0) {
    sprintf(buf, "SYSERR: Unable to unlink corpse file %s.", fname);
    perror(buf);
  }
}

/* find a corpse in the corpse control record */
static struct corpse_data *find_entry(int id)
{
  struct corpse_data *entry;

  for (entry = SENTINEL->next; entry != SENTINEL; entry = entry->next)
    if (entry->id == id)
      return entry;

  return NULL;
}



/* Save the corpse control information */
static void save_corpse_list(void)
{
  FILE *fl;
  struct corpse_data *entry;
  
  if (!(fl = fopen(CCONTROL_FILE, "w"))) {
    perror("SYSERR: Unable to open corpse control file");
    return;
  }

  for (entry = SENTINEL->next; entry != SENTINEL; entry = entry->next) {
    check_corpse_id(entry);
    fprintf(fl, "%d\n", entry->id);
  }

  fclose(fl);
}

/* 8/5/99 David Endre - Fix it so more than one corpse is saved over
   a reboot. The problem was the old code called obj_to_room which
   saves the ccontrol file and since only one corpse is in the world
   it saves that in the ccontrol file and never gets a chance to boot
   another corpse */

/* call from boot_db - will load control recs, load corpses, load objs */
/* does sanity checks on vnums & removes invalid records */
void boot_corpses(void)
{
  FILE *fl;
  int id;
  struct corpse_data *entry;
  struct obj_data *corpse;

  memset(&corpse_control, 0x0, sizeof(corpse_control));
  SENTINEL->next = SENTINEL->prev = SENTINEL;

  if (!(fl = fopen(CCONTROL_FILE, "rb"))) {
    log("Corpse control file does not exist.");
    return;
  }

  while (get_line(fl, buf)) {
    id = atoi(buf);

    if (!(corpse = load_corpse(id))) {
      sprintf(buf, "SYSERR: Unable to load corpse %d in corpse control list", id);
      log("%s",buf);
      continue;
    }

    CREATE(entry, struct corpse_data, 1);
    entry->id = id;
    entry->corpse = corpse;

    SENTINEL->prev->next = entry;
    entry->prev = SENTINEL->prev;
    SENTINEL->prev = entry;
    entry->next = SENTINEL;

    ++corpse_control.count;
  }
  fclose(fl);

  corpse_control.allow_save = TRUE;

  save_corpse_list();
}

/* When a player dies, this function is called from make_corpse in fight.c */
void register_corpse(struct obj_data *corpse)
{
  struct corpse_data *entry;

  if (GET_OBJ_VAL(corpse, VAL_CORPSE_ID)) {
    for (entry = SENTINEL->next; entry != SENTINEL; entry = entry->next)
      if (entry->corpse == corpse) {
        log("SYSERR: already registered corpse passed to register_corpse");
        return;
      }
  }

  GET_OBJ_VAL(corpse, VAL_CORPSE_ID) = SENTINEL->prev->id + 1;

  CREATE(entry, struct corpse_data, 1);
  entry->id = GET_OBJ_VAL(corpse, VAL_CORPSE_ID);
  entry->corpse = corpse;

  SENTINEL->prev->next = entry;
  entry->prev = SENTINEL->prev;
  SENTINEL->prev = entry;
  entry->next = SENTINEL;

  ++corpse_control.count;
  
  save_corpse(corpse);

  save_corpse_list();
}


/* called from extract_obj when corpse rots or is otherwise removed from play */
void destroy_corpse(struct obj_data *corpse)
{
  int id = corpse_id(corpse);
  struct corpse_data *entry = find_entry(id);

  if (entry) {
    remove_entry(entry);
    save_corpse_list();
    delete_corpse_file(id);
  }
}

void show_corpses(struct char_data *ch, char *argument)
{
  struct corpse_data *entry;

  if (corpse_control.count) {
    send_to_char("Id  Corpse              Level  Decomp  Location\r\n"
                 "-------------------------------------------------------------------\r\n",
                 ch);
    for (entry = SENTINEL->next; entry != SENTINEL; entry = entry->next) {
      if (!strn_cmp(entry->corpse->short_description, "the corpse of ", 14))
        strcpy(buf1, entry->corpse->short_description + 14);
      else
        strcpy(buf1, entry->corpse->name);
      if (entry->corpse->carried_by)
        sprintf(buf2, "carried by %s", GET_NAME(entry->corpse->carried_by));
      else if (entry->corpse->in_room != NOWHERE)
        sprintf(buf2, "%s @@L[&0%d@@L]&0", world[entry->corpse->in_room].name,
                world[entry->corpse->in_room].vnum);
      else if (entry->corpse->in_obj)
        sprintf(buf2, "in %s", entry->corpse->in_obj->short_description);
      else if (entry->corpse->worn_by)
        sprintf(buf2, "worn by %s", GET_NAME(entry->corpse->worn_by));
      else
        strcpy(buf2, "an unknown location");
      cprintf(ch, "%-4d%-20.20s%5d  %6d  %25s\r\n", entry->id,
              buf1, GET_OBJ_LEVEL(entry->corpse),
              GET_OBJ_DECOMP(entry->corpse), buf2);
    }
  }
  else
    send_to_char("There are no player corpses in the game.\r\n", ch);
}


/***************************************************************************
 * $Log: corpse_save.c,v $
 * Revision 1.23  2009/03/17 07:59:42  jps
 * Moved str_str to strings.c
 *
 * Revision 1.22  2009/03/04 05:14:16  myc
 * Fixed alignment in show corpse.
 *
 * Revision 1.21  2009/02/16 14:21:04  myc
 * Make sure corpses get the right decomp flags when loaded from file.
 *
 * Revision 1.20  2009/02/05 16:26:57  myc
 * Fix string cut-off on 'show corpse' screen.
 *
 * Revision 1.19  2008/09/02 07:16:00  mud
 * Changing object TIMER uses into DECOMP where appropriate
 *
 * Revision 1.18  2008/08/24 02:37:01  myc
 * Fix function signature for reference to external function str_str.
 *
 * Revision 1.17  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.16  2008/06/05 02:07:43  myc
 * Rewrote corpse saving and loading to use the ascii object files.
 *
 * Revision 1.15  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.14  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.13  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.12  2008/01/14 20:38:42  myc
 * Fix to save corpse level to corpse control file so that resurrect
 * will work properly on corpses booted from file.
 *
 * Revision 1.11  2007/10/04 16:20:24  myc
 * Transient item flag now makes things decay when they are on the ground.
 * Added this flag to corpses.
 *
 * Revision 1.10  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.9  2000/11/21 00:42:30  rsd
 * Added back rlog messages from prior to the addition of
 * the $log$ string.
 *
 * Revision 1.8  2000/09/26 15:03:40  jimmy
 * Fixed a couple of instances of bad index iteration: the ++ was
 * actually inside the [] of another variable, eeeeek!!!
 * Fixed a bug where the wrong index number was referenced that
 * was causing equipment not to load on corpses after a boot.
 *
 * Revision 1.7  2000/09/22 23:24:49  rsd
 * altered the comment header to reflect that it's fiery code
 * now. Also added a syserr message to be logged and mopped
 * up some spacing in the comments.  Wow I feel so useful
 *
 * Revision 1.6  1999/11/28 23:03:02  cso
 * reordered a little of corpse_load to make it look nicer. no functional
 * differences there.
 * changed the values on corpses, so modified corpse_boot to set up the pc
 * corpses correctly.
 *
 * Revision 1.5  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.4  1999/08/05 14:52:02  dce
 * Corpses now save correctly ove a reboot/crash!
 *
 * Revision 1.3  1999/04/22 01:44:49  dce
 * Debuging for corpse saving
 *
 * Revision 1.2  1999/01/30 21:40:33  mud
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.23
log
@Moved str_str to strings.c
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.22 2009/03/04 05:14:16 myc Exp jps $
d151 1
a151 1
      log(buf);
d157 1
a157 1
    log(buf);
d166 1
a166 1
      log(buf);
d177 1
a177 1
    log(buf);
d329 1
a329 1
      log(buf);
d432 3
@


1.22
log
@Fixed alignment in show corpse.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.21 2009/02/16 14:21:04 myc Exp myc $
d60 1
a76 1
extern const char *str_str(const char *cs, const char *ct);
d432 3
@


1.21
log
@Make sure corpses get the right decomp flags when loaded from file.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.20 2009/02/05 16:26:57 myc Exp myc $
d401 1
a401 1
    send_to_char("Id  Corpse               Level  Location                 Time Left\r\n"
d412 1
a412 2
        sprintf(buf2, "%s @@L[&0%d@@L]&0", 
world[entry->corpse->in_room].name,
d420 1
a420 1
      cprintf(ch, "%-4d%-21.21s%5d  %9d  %25s\r\n", entry->id,
d432 3
@


1.20
log
@Fix string cut-off on 'show corpse' screen.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.19 2008/09/02 07:16:00 mud Exp myc $
d59 1
d193 6
d433 3
@


1.19
log
@Changing object TIMER uses into DECOMP where appropriate
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.18 2008/08/24 02:37:01 myc Exp mud $
d405 2
a406 1
        sprintf(buf2, "%s @@L[@@0%d@@L]@@0", world[entry->corpse->in_room].name,
d414 1
a414 1
      sprintf(buf, "%-4d%-21.21s%-7d%-25.25s%d\r\n", entry->id,
d416 1
a416 2
              buf2, GET_OBJ_DECOMP(entry->corpse));
      send_to_char(buf, ch);
d426 3
@


1.18
log
@Fix function signature for reference to external function str_str.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.17 2008/06/07 19:06:46 myc Exp myc $
d415 1
a415 1
              buf2, GET_OBJ_TIMER(entry->corpse));
d426 3
@


1.17
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.16 2008/06/05 02:07:43 myc Exp myc $
d75 1
a75 1
extern char *str_str(char *cs, char *ct);
d426 3
@


1.16
log
@Rewrote corpse saving and loading to use the ascii object files.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.15 2008/03/30 17:30:38 jps Exp myc $
d110 1
a110 1
  int id = GET_OBJ_VAL(corpse, 2);
d170 2
a171 2
    GET_OBJ_VAL(obj, 2) = id;
    GET_OBJ_VAL(obj, 3) = CORPSE_PC;
d349 1
a349 1
  if (GET_OBJ_VAL(corpse, 2)) {
d357 1
a357 1
  GET_OBJ_VAL(corpse, 2) = SENTINEL->prev->id + 1;
d360 1
a360 1
  entry->id = GET_OBJ_VAL(corpse, 2);
d426 3
@


1.15
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.14 2008/03/28 17:54:53 myc Exp jps $
d58 1
d60 21
a80 1
int Obj_to_store(struct obj_data * obj, FILE * fl);
d82 13
a94 3
struct corpse_control_rec corpse_control[MAX_CORPSES];
int num_of_corpses = 0;
int top_of_corpse_list = 0;
d97 1
a97 2
/* Return a filename given a corpse index */
int Corpse_get_filename(int index, char *filename)
d99 21
a119 3
  if (index < 0) {
    log("SYSERR(corpse_save.c):Player has index number < 0 no corpse loaded.");
    return 0;
d121 2
a122 2
    sprintf(filename, "corpse/%d.corpse", index);
    return 1;
d128 1
a128 1
int Corpse_load(int index, struct obj_data *corpse)
d132 7
a138 9
  struct obj_file_elem object;
  
  if (!corpse) {
    log("SYSERR: Null object passed to Corpse_load.");
    return 0;
  }
  if (!Corpse_get_filename(index, fname)) {
    log("SYSERR: invalid index passed from Corpse_load.");
    return 0;
d140 1
a140 1
  if (!(fl = fopen(fname, "r+b"))) {
d142 1
a142 1
    return 0;
d144 8
a151 7
  while (!feof(fl)) {
    if (fread(&object, sizeof(struct obj_file_elem), 1, fl))
      obj_to_obj(Obj_from_store(object), corpse);
    else if (ferror(fl)) {
      perror("Reading corpse file: Corpse_load.");
      fclose(fl);
      return 0;
d154 7
a160 5
  
  fclose(fl);
  
  return 1;
}
d162 16
a177 17

/* Save all objects for a corpse (recursiv, initial call must be followed
   by a call to Corpse_restore_weight)  Assumes file is open already. */
int Corpse_save(struct obj_data * obj, FILE * fp)
{
  struct obj_data *tmp;
  int result;
  
  if (obj) {
    Corpse_save(obj->contains, fp);
    Corpse_save(obj->next_content, fp);
    result = Obj_to_store(obj, fp);
    if (!result)
      return 0;
    
    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);
a178 2
  return 1;
}
d180 9
a188 9

/* restore weight of containers after Corpse_save has changed them for saving */
void Corpse_restore_weight(struct obj_data * obj)
{
  if (obj) {
    Corpse_restore_weight(obj->contains);
    Corpse_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
d190 4
d197 1
a197 2
/* Save all objects in a corpse */
void Corpse_crashsave(int index, struct obj_data *corpse)
d201 2
d205 1
a205 1
    log("SYSERR: Non-corpse object passed to Corpse_crashsave");
d208 2
a209 2
  if (!Corpse_get_filename(index, buf)) {
    log("SYSERR: Invalid index passed from Corpse_crashsave");
d212 2
a213 2
  if (!(fp = fopen(buf, "wb"))) {
    perror("SYSERR: Error saving corpse file");
d216 2
a217 2
  if (!Corpse_save(corpse->contains, fp)) {
    fclose(fp);
d220 15
a235 1
  Corpse_restore_weight(corpse->contains);
d240 1
a240 1
void Corpse_delete_file(int index)
d245 2
a246 2
  if (!Corpse_get_filename(index, fname)) {
    log("SYSERR: Invalid index passed from Corpse_delete_file");    
d262 1
a262 1
int find_corpse(int index)
d264 7
a270 7
  int i;
  
  for (i = 0; i < num_of_corpses; i++)
    if (corpse_control[i].index == index)
      return i;
  
  return -1;
d276 1
a276 1
void Corpse_save_control(void)
d279 1
d281 1
a281 1
  if (!(fl = fopen(CCONTROL_FILE, "wb"))) {
d285 6
a290 3
  /* write all the corpse control recs.*/
  fwrite(corpse_control, sizeof(struct corpse_control_rec), num_of_corpses, fl);
  
d302 1
a302 1
void Corpse_boot(void)
d304 3
a306 2
  struct corpse_control_rec temp_corpse;
  sh_int real_corpse;
a307 5
  FILE *fl;
  int i;
  extern int max_pc_corpse_time;
  struct obj_data *corpse_list[MAX_CORPSES];
  sh_int room_num[MAX_CORPSES];
d309 2
a310 1
  memset((char *)corpse_control,0,sizeof(struct corpse_control_rec)*MAX_CORPSES);
d316 20
a335 46
  while (!feof(fl) && num_of_corpses < MAX_CORPSES) {
    fread(&temp_corpse, sizeof(struct corpse_control_rec), 1, fl);
   
    if (feof(fl))
      break;
    
    if ((real_corpse = real_room(temp_corpse.vnum)) < 0)
      continue;			/* this vnum doesn't exist -- skip */
    
    /* make the corpse */
    
    corpse = create_obj();
    
    corpse->item_number = NOTHING;
    corpse->in_room = NOWHERE;
    
    corpse->name = strdup(temp_corpse.name);
    corpse->description = strdup(temp_corpse.description);
    corpse->short_description = strdup(temp_corpse.short_description);
    
    GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
    /*NO!!!!! GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE;*/
    GET_OBJ_EXTRA(corpse) = (ITEM_NODONATE | ITEM_FLOAT | ITEM_TRANSIENT);
    /* someone had value 1 keeping track of whether it's a pc or npc corpse,
     * but value 1 on a container is open/closed. integrating pc corpse into
     * value 3. -321 */
    GET_OBJ_VAL(corpse, 0) = 0;                  /* You can't store stuff in a corpse */
    GET_OBJ_VAL(corpse, 1) = 0;                  /* not closable */
    GET_OBJ_VAL(corpse, 2) = temp_corpse.index;  /* index of corpse save file */
    GET_OBJ_VAL(corpse, 3) = CORPSE_PC;          /* corpse identifier/type */
    GET_OBJ_WEIGHT(corpse) = temp_corpse.weight;
    /* GET_OBJ_RENT(corpse) = 100000; */
    CORPSE_LEVEL(corpse) = temp_corpse.level;
    GET_OBJ_TIMER(corpse) = max_pc_corpse_time;
    
    /* obj_to_room(corpse, real_corpse); This was the problem line */
    room_num[num_of_corpses] = real_corpse;
    corpse_list[num_of_corpses] = corpse;

    corpse_control[num_of_corpses] = temp_corpse;
    /* the ++ was inside the previous set of [] throwing the index off  */
    /* very poor coding style and VERY hard to find --Gurlaek 9/26/2000 */
    num_of_corpses++;
    top_of_corpse_list = temp_corpse.index + 1;
    
    /* Corpse_load(temp_corpse.index, corpse); */
a336 1
  
d338 4
a341 10
  for( i = 0; i < num_of_corpses; i++ ) {
     obj_to_room(corpse_list[i], room_num[i]);
     if (i < top_of_corpse_list) {
       /* changed from i to corpse_control[i].index  */
       /* corpses should now load the proper objects */
       /* at boot  --Gurlaek 9/26/2000               */
       Corpse_load(corpse_control[i].index, corpse_list[i]);
     }
  }
  Corpse_save_control();
d345 1
a345 1
void ccontrol_make_corpse(int vnum, struct obj_data *corpse)
d347 8
a354 6
  struct corpse_control_rec temp_corpse;
  sh_int real_corpse;
  
  if (num_of_corpses >= MAX_CORPSES) {
    log("SYSERR: Maximum number of corpses exceeded!");
    return;
d356 13
d370 3
a372 25
  if ((real_corpse = real_room(vnum)) < 0) {
    log("SYSERR: Corpse tried to load in an invalid room");
    return;
  }
  
  
  temp_corpse.index = GET_OBJ_VAL(corpse,2);
  temp_corpse.vnum = vnum;
  
  strcpy(temp_corpse.name, corpse->name);
  strcpy(temp_corpse.description, corpse->description);
  strcpy(temp_corpse.short_description, corpse->short_description);
  
  temp_corpse.weight = GET_OBJ_WEIGHT(corpse);
  temp_corpse.level = CORPSE_LEVEL(corpse);
  
  corpse_control[num_of_corpses] = temp_corpse;
  /* the ++ was inside the previous set of [] throwing the index off  */
  /* very poor coding style and VERY hard to find --Gurlaek 9/26/2000 */
  num_of_corpses++;
  top_of_corpse_list++;
  
  Corpse_crashsave(temp_corpse.index, corpse);
  
  Corpse_save_control();
d377 1
a377 1
void ccontrol_destroy_corpse(int index)
d379 2
a380 10
  int i, j;
  sh_int real_corpse;
  
  if ((i = find_corpse(index)) < 0) {
    return;
  }
  
  if ((real_corpse = real_room(corpse_control[i].vnum)) < 0) {
    log("SYSERR: Corpse had invalid vnum!");
  }
d382 4
a385 4
  Corpse_delete_file(corpse_control[i].index);
  
  for (j = i; j < num_of_corpses - 1; j++) {
    corpse_control[j] = corpse_control[j + 1];
d387 1
d389 29
a417 6
  num_of_corpses--;

  /* reset the corpse index number when all corpses decompose   */
  /* --Gurlaek 9/26/2000                                        */
  if(num_of_corpses == 0) {
    top_of_corpse_list = 0;
d419 2
a420 2

  Corpse_save_control();
a423 18
/* crash-save all the corpses */
/* may be useful later if corpses move to timed backup instead of event driven
   backup.
   void Corpse_save_all(void)
   {
   int i;
   sh_int real_corpse;
   
   for (i = 0; i < num_of_corpses; i++)
   if ((real_corpse = real_room(corpse_control[i].vnum)) != NOWHERE)
   if (IS_SET(ROOM_FLAGS(real_house), ROOM_HOUSE_CRASH)) 
   Corpse_crashsave(corpse_control[i].index);
   }
*/




d426 4
@


1.14
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.13 2008/01/29 21:02:31 myc Exp myc $
d57 1
a58 1
struct obj_data *Obj_from_store(struct obj_file_elem object);
d402 4
@


1.13
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.12 2008/01/14 20:38:42 myc Exp myc $
d266 3
a268 3
    corpse->name = str_dup(temp_corpse.name);
    corpse->description = str_dup(temp_corpse.description);
    corpse->short_description = str_dup(temp_corpse.short_description);
d402 4
@


1.12
log
@Fix to save corpse level to corpse control file so that resurrect
will work properly on corpses booted from file.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.11 2007/10/04 16:20:24 myc Exp myc $
a57 7
extern char *dirs[];
extern struct room_data *world;
extern int top_of_world;
extern const int rev_dir[];
extern struct index_data *obj_index;


d402 4
@


1.11
log
@Transient item flag now makes things decay when they are on the ground.
Added this flag to corpses.
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.10 2002/09/13 02:32:10 jjl Exp myc $
d288 2
a289 1
    GET_OBJ_RENT(corpse) = 100000;
d343 1
d409 4
@


1.10
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: corpse_save.c,v 1.9 2000/11/21 00:42:30 rsd Exp $
d279 1
a279 1
    GET_OBJ_EXTRA(corpse) = ITEM_NODONATE;
d407 3
@


1.9
log
@Added back rlog messages from prior to the addition of
the $log$ string.
@
text
@d1 3
a3 1
// $Id: corpse_save.c,v 1.8 2000/09/26 15:03:40 jimmy Exp $
d405 39
a443 33
// $Log: corpse_save.c,v $
// Revision 1.8  2000/09/26 15:03:40  jimmy
// Fixed a couple of instances of bad index iteration: the ++ was
// actually inside the [] of another variable, eeeeek!!!
// Fixed a bug where the wrong index number was referenced that
// was causing equipment not to load on corpses after a boot.
//
// Revision 1.7  2000/09/22 23:24:49  rsd
// altered the comment header to reflect that it's fiery code
// now. Also added a syserr message to be logged and mopped
// up some spacing in the comments.  Wow I feel so useful
//
// Revision 1.6  1999/11/28 23:03:02  cso
// reordered a little of corpse_load to make it look nicer. no functional
// differences there.
// changed the values on corpses, so modified corpse_boot to set up the pc
// corpses correctly.
//
// Revision 1.5  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.4  1999/08/05 14:52:02  dce
// Corpses now save correctly ove a reboot/crash!
//
// Revision 1.3  1999/04/22 01:44:49  dce
// Debuging for corpse saving
//
// Revision 1.2  1999/01/30 21:40:33  mud
// Indented file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.8
log
@Fixed a couple of instances of bad index iteration: the ++ was
actually inside the [] of another variable, eeeeek!!!
Fixed a bug where the wrong index number was referenced that
was causing equipment not to load on corpses after a boot.
@
text
@d1 1
a1 1
// $Id: corpse_save.c,v 1.7 2000/09/22 23:24:49 rsd Exp $
d404 6
d423 12
@


1.7
log
@altered the comment header to reflect that it's fiery code
now. Also added a syserr message to be logged and mopped
up some spacing in the comments.  Wow I feel so useful
@
text
@d1 1
a1 1
// $Id: corpse_save.c,v 1.6 1999/11/28 23:03:02 cso Exp $
d68 1
a68 1
int top_of_corpse_list=0;
d189 3
a191 5
  if (!(fl = fopen(fname, "rb"))) {
    if (errno != ENOENT) {
      sprintf(buf, "SYSERR: Error deleting corpse file #%d. (1)", index);
      perror(buf);
    }
d196 1
a196 1
    sprintf(buf, "SYSERR: Error deleting corpse file #%d. (2)", index);
d293 4
a296 1
    corpse_control[num_of_corpses++] = temp_corpse;
d303 1
a303 1
  for(i=0;i<num_of_corpses;i++) {
d305 6
a310 2
     if (i<top_of_corpse_list)
        Corpse_load(i, corpse_list[i]);
d341 4
a344 1
  corpse_control[num_of_corpses++] = temp_corpse;
d359 1
a359 1
  if ((i = find_corpse(index)) < 0)
d361 1
d363 1
a363 1
  if ((real_corpse = real_room(corpse_control[i].vnum)) < 0)
d365 2
a366 1
  
d369 1
a369 1
  for (j = i; j < num_of_corpses - 1; j++)
d371 2
a372 1
  
d375 6
d404 5
@


1.6
log
@reordered a little of corpse_load to make it look nicer. no functional
differences there.
changed the values on corpses, so modified corpse_boot to set up the pc
corpses correctly.
@
text
@d1 1
a1 1
// $Id: corpse_save.c,v 1.5 1999/09/05 07:00:39 jimmy Exp $
d3 1
a3 1
 *   File: corpse.c                                      Part of HubisMUD  *
d5 1
d7 3
a9 1
 *  Author : Nechtrous                                                     *
d74 2
a75 1
  if (index < 0)
d77 4
a80 3
  
  sprintf(filename, "corpse/%d.corpse", index);
  return 1;
a111 1

d283 4
a286 4
    GET_OBJ_VAL(corpse, 0) = 0;   /* You can't store stuff in a corpse */
    GET_OBJ_VAL(corpse, 1) = 0;   /* not closable */
    GET_OBJ_VAL(corpse, 2) = temp_corpse.index;  /*index of corpse save file */
    GET_OBJ_VAL(corpse, 3) = CORPSE_PC;   /* corpse identifier/type */
a385 6






d387 6
@


1.5
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d99 3
a101 2
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
a105 2
    if (!feof(fl))
      obj_to_obj(Obj_from_store(object), corpse);
d107 1
d276 3
d280 1
a280 1
    GET_OBJ_VAL(corpse, 1) = 1;   /* player corpse */
d282 1
a282 1
    GET_OBJ_VAL(corpse, 3) = 1;   /* corpse identifier */
d388 4
a391 1
// $Log$
@


1.4
log
@Corpses now save correctly ove a reboot/crash!
@
text
@d1 1
d385 1
@


1.3
log
@Debuging for corpse saving
@
text
@a224 2
  log("Corpse saved...");
  mudlog("Corpse saved...", BRF, LVL_HEAD_B, TRUE);
d227 5
d241 1
d243 3
a245 1
  
d247 1
a247 1
  
d254 1
a254 1
    
d283 4
a286 1
    obj_to_room(corpse, real_corpse);
d290 1
a290 1
    Corpse_load(temp_corpse.index, corpse);
d294 5
a354 3

  log("Corpse decayed and has been deleted.");
  mudlog("Corpse decayed and has been deleted.",BRF,LVL_HEAD_B,TRUE);  
@


1.2
log
@Indented file
@
text
@d225 2
d341 4
a344 1
  
@


1.1
log
@Initial revision
@
text
@d1 6
a6 6
/* ************************************************************************
*   File: corpse.c                                      Part of HubisMUD *
*  Usage: Handling of player corpses                                      *
*                                                                         *
*  Author : Nechtrous                                                     *
************************************************************************ */
d72 1
a72 1

d84 1
a84 1

d107 1
a107 1

d109 1
a109 1

d120 1
a120 1

d127 1
a127 1

d152 1
a152 1

d179 1
a179 1

d202 1
a202 1

d206 1
a206 1

d216 1
a216 1

d223 1
a223 1

d237 1
a237 1

d239 1
a239 1

d246 1
a246 1

d249 1
a249 1

d252 1
a252 1

d254 1
a254 1

d256 1
a256 1

d259 1
a259 1

d263 1
a263 1

d274 1
a274 1

d278 1
a278 1

d281 1
a281 1

d291 1
a291 1

d296 1
a296 1

d301 2
a302 2


d305 1
a305 1

d309 1
a309 1

d311 1
a311 1

d314 1
a314 1

d316 1
a316 1

d326 1
a326 1

d329 1
a329 1

d332 1
a332 1

d334 1
a334 1

d337 1
a337 1

d339 1
a339 1

d347 20
a366 4
void Corpse_save_all(void)
{
  int i;
  sh_int real_corpse;
a367 6
  for (i = 0; i < num_of_corpses; i++)
    if ((real_corpse = real_room(corpse_control[i].vnum)) != NOWHERE)
      if (IS_SET(ROOM_FLAGS(real_house), ROOM_HOUSE_CRASH)) 
	Corpse_crashsave(corpse_control[i].index);
}
*/
@
