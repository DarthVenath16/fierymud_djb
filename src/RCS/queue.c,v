head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.24.21.17.12;	author rsd;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.03.44.59;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*  File: queue.c                                                          *
*                                                                         *
*  Usage: generic queue functions for building and using a priority queue *
*                                                                         *
*  Written by Eric Green (ejg3@@cornell.edu)                               *
*                                                                         *
*  Changes:                                                               *
*      3/6/98 ejg:  Moved defines and structs from queue.h.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "queue.h"


/* number of queues to use (reduces enqueue cost) */
#define NUM_EVENT_QUEUES   100

struct queue {
  struct q_element *head[NUM_EVENT_QUEUES], *tail[NUM_EVENT_QUEUES];
};

struct q_element {
  void *data;
  long key;
  struct q_element *prev, *next;
};


/* external variables */
extern unsigned long pulse;


/* returns a new, initialized queue */
struct queue *queue_init(void)
{
  struct queue *q;

  CREATE(q, struct queue, 1);

  return q;
}


/* add data into the priority queue q with key */
struct q_element *queue_enq(struct queue *q, void *data, long key)
{
  struct q_element *qe, *i;
  int bucket;

  CREATE(qe, struct q_element, 1);
  qe->data = data;
  qe->key = key;

  bucket = key % NUM_EVENT_QUEUES;   /* which queue does this go in */

  if (!q->head[bucket]) { /* queue is empty */
    q->head[bucket] = qe;
    q->tail[bucket] = qe;
  }

  else {
    for (i = q->tail[bucket]; i; i = i->prev) {

      if (i->key < key) { /* found insertion point */
	if (i == q->tail[bucket])
	  q->tail[bucket] = qe;
	else {
	  qe->next = i->next;
	  i->next->prev = qe;
	}

	qe->prev = i;
	i->next = qe;
	break;
      }
    }

    if (i == NULL) { /* insertion point is front of list */
      qe->next = q->head[bucket];
      q->head[bucket] = qe;
      qe->next->prev = qe;
    }
  }

  return qe;
}


/* remove queue element qe from the priority queue q */
void queue_deq(struct queue *q, struct q_element *qe)
{
  int i;

  assert(qe);

  i = qe->key % NUM_EVENT_QUEUES;

  if (qe->prev == NULL)
    q->head[i] = qe->next;
  else
    qe->prev->next = qe->next;

  if (qe->next == NULL)
    q->tail[i] = qe->prev;
  else
    qe->next->prev = qe->prev;

  free(qe);
}


/*
 * removes and returns the data of the
 * first element of the priority queue q
 */
void *queue_head(struct queue *q)
{
  void *data;
  int i;

  i = pulse % NUM_EVENT_QUEUES;

  if (!q->head[i])
    return NULL;

  data = q->head[i]->data;
  queue_deq(q, q->head[i]);
  return data;
}


/*
 * returns the key of the head element of the priority queue
 * if q is NULL, then return the largest unsigned number
 */
long queue_key(struct queue *q)
{
  int i;

  i = pulse % NUM_EVENT_QUEUES;

  if (q->head[i])
    return q->head[i]->key;
  else
    return LONG_MAX;
}


/* returns the key of queue element qe */
long queue_elmt_key(struct q_element *qe)
{
  return qe->key;
}


/* free q and contents */
void queue_free(struct queue *q)
{
  int i;
  struct q_element *qe, *next_qe;

  for (i = 0; i < NUM_EVENT_QUEUES; i++)
    for (qe = q->head[i]; qe; qe = next_qe) {
      next_qe = qe->next;
      free(qe);
    }

  free(q);
}
@


1.6
log
@Adding a little hack to queue_free to get rid of an event
memory leak at program termination.
@
text
@/***************************************************************************
 * $Id: queue.c,v 1.5 2002/09/13 02:32:10 jjl Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: queue.c                                       Part of FieryMUD  *
 *  Usage: generic queue functions for building and using a priority queue *
 *     By: Eric Green (ejg3@@cornell.edu)                                   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 ***************************************************************************/

/***************************************************************************
 *  Changes: 3/6/98 ejg:  Moved defines and structs from queue.h.          *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "queue.h"
#include "events.h"

/* number of queues to use (reduces enqueue cost) */
#define NUM_EVENT_QUEUES   100

struct queue {
  struct q_element *head[NUM_EVENT_QUEUES], *tail[NUM_EVENT_QUEUES];
};

struct q_element {
  void *data;
  long key;
  struct q_element *prev, *next;
};


/* external variables */
extern unsigned long pulse;


/* returns a new, initialized queue */
struct queue *queue_init(void)
{
  struct queue *q;
  
  CREATE(q, struct queue, 1);
  
  return q;
}


/* add data into the priority queue q with key */
struct q_element *queue_enq(struct queue *q, void *data, long key)
{
  struct q_element *qe, *i;
  int bucket;
  
  CREATE(qe, struct q_element, 1);
  qe->data = data;
  qe->key = key;
  
  bucket = key % NUM_EVENT_QUEUES;   /* which queue does this go in */
  
  if (!q->head[bucket]) { /* queue is empty */
    q->head[bucket] = qe;
    q->tail[bucket] = qe;
  }
  
  else {
    for (i = q->tail[bucket]; i; i = i->prev) {
      
      if (i->key < key) { /* found insertion point */
	if (i == q->tail[bucket])
	  q->tail[bucket] = qe;
	else {
	  qe->next = i->next;
	  i->next->prev = qe;
	}
	
	qe->prev = i;
	i->next = qe;
	break;
      }
    }
    
    if (i == NULL) { /* insertion point is front of list */
      qe->next = q->head[bucket];
      q->head[bucket] = qe;
      qe->next->prev = qe;
    }
  }
  
  return qe;
}


/* remove queue element qe from the priority queue q */
void queue_deq(struct queue *q, struct q_element *qe)
{
  int i;
  
  assert(qe);
  
  i = qe->key % NUM_EVENT_QUEUES;
  
  if (qe->prev == NULL)
    q->head[i] = qe->next;
  else
    qe->prev->next = qe->next;
  
  if (qe->next == NULL)
    q->tail[i] = qe->prev;
  else
    qe->next->prev = qe->prev;
  
  free(qe);
}


/*
 * removes and returns the data of the
 * first element of the priority queue q
 */
void *queue_head(struct queue *q)
{
  void *data;
  int i;
  
  i = pulse % NUM_EVENT_QUEUES;
  
  if (!q->head[i])
    return NULL;
  
  data = q->head[i]->data;
  queue_deq(q, q->head[i]);
  return data;
}


/*
 * returns the key of the head element of the priority queue
 * if q is NULL, then return the largest unsigned number
 */
long queue_key(struct queue *q)
{
  int i;
  
  i = pulse % NUM_EVENT_QUEUES;
  
  if (q->head[i])
    return q->head[i]->key;
  else
    return LONG_MAX;
}

/* returns the key of queue element qe */
long queue_elmt_key(struct q_element *qe)
{
  return qe->key;
}

/* free q and contents */
void queue_free(struct queue *q)
{
  int i;
  struct q_element *qe, *next_qe;
  struct event *event;
  
  for (i = 0; i < NUM_EVENT_QUEUES; i++)
    for (qe = q->head[i]; qe; qe = next_qe) {
      next_qe = qe->next;
      /*
       * This is okay for now, but if we ever were to use this queue
       * for something besides events, we'd be in trouble.
       */
      if ((event = (struct event *) qe->data) != NULL) {
        if (event->free_obj && event->event_obj)
          free(event->event_obj);
        free(event);
      }
      free(qe);
    }
  
  free(q);
}

/***************************************************************************
 * $Log: queue.c,v $
 * Revision 1.5  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.4  2000/11/24 21:17:12  rsd
 * Altered comment header and added back rlog messgaes from
 * prior to the addition of the $log$ string.
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/02/01 03:44:59  mud
 * dos2unix
 * Indented slightly
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.5
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: queue.c,v 1.4 2000/11/24 21:17:12 rsd Exp $
d24 1
d170 1
d175 9
d192 3
@


1.4
log
@Altered comment header and added back rlog messgaes from
prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: queue.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d179 17
a195 11
// $Log: queue.c,v $
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/02/01 03:44:59  mud
// dos2unix
// Indented slightly
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d3 1
a3 2
 *  File: queue.c                                                          *
 *                                                                         *
d5 1
d7 1
a7 1
 *  Written by Eric Green (ejg3@@cornell.edu)                               *
d9 5
a13 2
 *  Changes:                                                               *
 *      3/6/98 ejg:  Moved defines and structs from queue.h.               *
a18 1

a22 1

a155 1

a161 1

d176 12
a187 1
// $Log$
@


1.2
log
@dos2unix
Indented slightly
@
text
@d1 1
d177 1
@


1.1
log
@Initial revision
@
text
@d1 10
a10 10
/* ************************************************************************
*  File: queue.c                                                          *
*                                                                         *
*  Usage: generic queue functions for building and using a priority queue *
*                                                                         *
*  Written by Eric Green (ejg3@@cornell.edu)                               *
*                                                                         *
*  Changes:                                                               *
*      3/6/98 ejg:  Moved defines and structs from queue.h.               *
************************************************************************ */
d43 1
a43 1

d45 1
a45 1

d55 1
a55 1

d59 1
a59 1

d61 1
a61 1

d66 1
a66 1

d69 1
a69 1

d77 1
a77 1

d83 1
a83 1

d90 1
a90 1
 
d99 1
a99 1

d101 1
a101 1

d103 1
a103 1

d108 1
a108 1

d113 1
a113 1
    
d126 1
a126 1

d128 1
a128 1

d131 1
a131 1

d145 1
a145 1

d147 1
a147 1

d167 1
a167 1

d173 1
a173 1

@
