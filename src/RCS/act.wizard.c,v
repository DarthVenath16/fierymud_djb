head	1.337;
access;
symbols;
locks; strict;
comment	@ * @;


1.337
date	2011.08.18.00.12.11;	author myc;	state Exp;
branches;
next	1.336;

1.336
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.335;

1.335
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.334;

1.334
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.333;

1.333
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.332;

1.332
date	2009.06.09.05.32.10;	author myc;	state Exp;
branches;
next	1.331;

1.331
date	2009.06.02.02.45.40;	author myc;	state Exp;
branches;
next	1.330;

1.330
date	2009.03.20.23.02.59;	author myc;	state Exp;
branches;
next	1.329;

1.329
date	2009.03.16.19.17.43;	author jps;	state Exp;
branches;
next	1.328;

1.328
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.327;

1.327
date	2009.03.09.05.59.57;	author myc;	state Exp;
branches;
next	1.326;

1.326
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.325;

1.325
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.324;

1.324
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.323;

1.323
date	2009.02.17.01.50.08;	author myc;	state Exp;
branches;
next	1.322;

1.322
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.321;

1.321
date	2009.01.19.08.42.29;	author myc;	state Exp;
branches;
next	1.320;

1.320
date	2009.01.18.07.12.48;	author myc;	state Exp;
branches;
next	1.319;

1.319
date	2009.01.18.06.58.53;	author myc;	state Exp;
branches;
next	1.318;

1.318
date	2009.01.16.23.36.34;	author myc;	state Exp;
branches;
next	1.317;

1.317
date	2008.09.25.04.56.09;	author jps;	state Exp;
branches;
next	1.316;

1.316
date	2008.09.25.04.48.28;	author jps;	state Exp;
branches;
next	1.315;

1.315
date	2008.09.20.07.31.10;	author jps;	state Exp;
branches;
next	1.314;

1.314
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.313;

1.313
date	2008.09.07.20.05.27;	author jps;	state Exp;
branches;
next	1.312;

1.312
date	2008.09.07.05.46.43;	author jps;	state Exp;
branches;
next	1.311;

1.311
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.310;

1.310
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.309;

1.309
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.308;

1.308
date	2008.08.31.22.16.36;	author myc;	state Exp;
branches;
next	1.307;

1.307
date	2008.08.30.20.42.50;	author myc;	state Exp;
branches;
next	1.306;

1.306
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.305;

1.305
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.304;

1.304
date	2008.08.29.13.19.46;	author myc;	state Exp;
branches;
next	1.303;

1.303
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.302;

1.302
date	2008.08.26.03.58.13;	author jps;	state Exp;
branches;
next	1.301;

1.301
date	2008.08.24.03.32.32;	author myc;	state Exp;
branches;
next	1.300;

1.300
date	2008.08.23.21.36.22;	author myc;	state Exp;
branches;
next	1.299;

1.299
date	2008.08.17.20.16.24;	author jps;	state Exp;
branches;
next	1.298;

1.298
date	2008.08.16.23.03.43;	author jps;	state Exp;
branches;
next	1.297;

1.297
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.296;

1.296
date	2008.08.14.23.02.11;	author myc;	state Exp;
branches;
next	1.295;

1.295
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.294;

1.294
date	2008.07.27.05.27.12;	author jps;	state Exp;
branches;
next	1.293;

1.293
date	2008.07.26.21.34.09;	author jps;	state Exp;
branches;
next	1.292;

1.292
date	2008.07.13.19.04.52;	author jps;	state Exp;
branches;
next	1.291;

1.291
date	2008.07.13.18.49.11;	author jps;	state Exp;
branches;
next	1.290;

1.290
date	2008.07.13.17.52.11;	author jps;	state Exp;
branches;
next	1.289;

1.289
date	2008.06.21.08.53.09;	author myc;	state Exp;
branches;
next	1.288;

1.288
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.287;

1.287
date	2008.06.11.20.12.56;	author jps;	state Exp;
branches;
next	1.286;

1.286
date	2008.06.09.02.43.18;	author jps;	state Exp;
branches;
next	1.285;

1.285
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.284;

1.284
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.283;

1.283
date	2008.05.23.18.47.45;	author myc;	state Exp;
branches;
next	1.282;

1.282
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.281;

1.281
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.280;

1.280
date	2008.05.18.03.24.14;	author jps;	state Exp;
branches;
next	1.279;

1.279
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.278;

1.278
date	2008.05.14.05.12.06;	author jps;	state Exp;
branches;
next	1.277;

1.277
date	2008.05.11.05.46.20;	author jps;	state Exp;
branches;
next	1.276;

1.276
date	2008.04.26.23.35.21;	author myc;	state Exp;
branches;
next	1.275;

1.275
date	2008.04.20.17.49.43;	author jps;	state Exp;
branches;
next	1.274;

1.274
date	2008.04.19.17.57.55;	author myc;	state Exp;
branches;
next	1.273;

1.273
date	2008.04.10.02.01.01;	author jps;	state Exp;
branches;
next	1.272;

1.272
date	2008.04.05.17.53.24;	author jps;	state Exp;
branches;
next	1.271;

1.271
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.270;

1.270
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.269;

1.269
date	2008.04.03.17.36.09;	author jps;	state Exp;
branches;
next	1.268;

1.268
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.267;

1.267
date	2008.04.02.19.31.02;	author myc;	state Exp;
branches;
next	1.266;

1.266
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.265;

1.265
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.264;

1.264
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.263;

1.263
date	2008.03.27.23.15.59;	author jps;	state Exp;
branches;
next	1.262;

1.262
date	2008.03.27.22.57.37;	author jps;	state Exp;
branches;
next	1.261;

1.261
date	2008.03.25.22.01.16;	author jps;	state Exp;
branches;
next	1.260;

1.260
date	2008.03.24.03.58.45;	author jps;	state Exp;
branches;
next	1.259;

1.259
date	2008.03.23.18.40.35;	author jps;	state Exp;
branches;
next	1.258;

1.258
date	2008.03.23.00.27.01;	author jps;	state Exp;
branches;
next	1.257;

1.257
date	2008.03.22.20.25.31;	author jps;	state Exp;
branches;
next	1.256;

1.256
date	2008.03.22.19.57.59;	author jps;	state Exp;
branches;
next	1.255;

1.255
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.254;

1.254
date	2008.03.21.15.01.17;	author myc;	state Exp;
branches;
next	1.253;

1.253
date	2008.03.20.23.26.14;	author jps;	state Exp;
branches;
next	1.252;

1.252
date	2008.03.19.04.32.14;	author myc;	state Exp;
branches;
next	1.251;

1.251
date	2008.03.13.16.43.04;	author myc;	state Exp;
branches;
next	1.250;

1.250
date	2008.03.11.19.50.55;	author myc;	state Exp;
branches;
next	1.249;

1.249
date	2008.03.11.03.02.26;	author jps;	state Exp;
branches;
next	1.248;

1.248
date	2008.03.11.02.57.58;	author jps;	state Exp;
branches;
next	1.247;

1.247
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.246;

1.246
date	2008.03.10.19.55.37;	author jps;	state Exp;
branches;
next	1.245;

1.245
date	2008.03.10.18.18.32;	author myc;	state Exp;
branches;
next	1.244;

1.244
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.243;

1.243
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.242;

1.242
date	2008.03.08.23.48.03;	author jps;	state Exp;
branches;
next	1.241;

1.241
date	2008.03.08.23.20.06;	author myc;	state Exp;
branches;
next	1.240;

1.240
date	2008.03.08.22.29.06;	author myc;	state Exp;
branches;
next	1.239;

1.239
date	2008.03.08.20.18.09;	author jps;	state Exp;
branches;
next	1.238;

1.238
date	2008.03.06.05.11.51;	author myc;	state Exp;
branches;
next	1.237;

1.237
date	2008.03.05.16.18.20;	author myc;	state Exp;
branches;
next	1.236;

1.236
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.235;

1.235
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.234;

1.234
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.233;

1.233
date	2008.02.24.06.31.41;	author myc;	state Exp;
branches;
next	1.232;

1.232
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.231;

1.231
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.230;

1.230
date	2008.02.09.16.21.07;	author myc;	state Exp;
branches;
next	1.229;

1.229
date	2008.02.09.07.05.37;	author myc;	state Exp;
branches;
next	1.228;

1.228
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.09.03.04.23;	author myc;	state Exp;
branches;
next	1.226;

1.226
date	2008.02.08.13.43.55;	author jps;	state Exp;
branches;
next	1.225;

1.225
date	2008.02.07.01.46.14;	author myc;	state Exp;
branches;
next	1.224;

1.224
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.223;

1.223
date	2008.02.06.03.56.46;	author myc;	state Exp;
branches;
next	1.222;

1.222
date	2008.02.06.03.45.08;	author myc;	state Exp;
branches;
next	1.221;

1.221
date	2008.02.05.22.39.55;	author myc;	state Exp;
branches;
next	1.220;

1.220
date	2008.02.05.04.22.42;	author myc;	state Exp;
branches;
next	1.219;

1.219
date	2008.02.05.03.07.26;	author myc;	state Exp;
branches;
next	1.218;

1.218
date	2008.02.04.01.48.53;	author myc;	state Exp;
branches;
next	1.217;

1.217
date	2008.02.04.01.46.12;	author myc;	state Exp;
branches;
next	1.216;

1.216
date	2008.02.04.00.22.05;	author myc;	state Exp;
branches;
next	1.215;

1.215
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.214;

1.214
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.213;

1.213
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.212;

1.212
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.211;

1.211
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.210;

1.210
date	2008.01.27.11.16.14;	author jps;	state Exp;
branches;
next	1.209;

1.209
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.208;

1.208
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.207;

1.207
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.206;

1.206
date	2008.01.20.22.58.39;	author myc;	state Exp;
branches;
next	1.205;

1.205
date	2008.01.17.19.23.07;	author myc;	state Exp;
branches;
next	1.204;

1.204
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.203;

1.203
date	2008.01.14.20.38.42;	author myc;	state Exp;
branches;
next	1.202;

1.202
date	2008.01.10.23.11.51;	author myc;	state Exp;
branches;
next	1.201;

1.201
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.200;

1.200
date	2008.01.09.08.38.13;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2008.01.09.07.15.44;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2008.01.09.00.45.22;	author myc;	state Exp;
branches;
next	1.197;

1.197
date	2008.01.07.19.15.56;	author myc;	state Exp;
branches;
next	1.196;

1.196
date	2008.01.07.10.39.28;	author jps;	state Exp;
branches;
next	1.195;

1.195
date	2008.01.05.05.41.49;	author jps;	state Exp;
branches;
next	1.194;

1.194
date	2008.01.04.02.32.35;	author jps;	state Exp;
branches;
next	1.193;

1.193
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.192;

1.192
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.191;

1.191
date	2008.01.02.01.04.26;	author jps;	state Exp;
branches;
next	1.190;

1.190
date	2007.12.31.04.00.28;	author jps;	state Exp;
branches;
next	1.189;

1.189
date	2007.12.28.00.51.39;	author jps;	state Exp;
branches;
next	1.188;

1.188
date	2007.12.28.00.44.34;	author jps;	state Exp;
branches;
next	1.187;

1.187
date	2007.12.25.06.55.14;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2007.12.25.06.03.01;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.184;

1.184
date	2007.12.23.00.10.13;	author myc;	state Exp;
branches;
next	1.183;

1.183
date	2007.12.20.23.10.02;	author myc;	state Exp;
branches;
next	1.182;

1.182
date	2007.12.19.20.37.02;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2007.11.23.20.03.55;	author jps;	state Exp;
branches;
next	1.180;

1.180
date	2007.11.23.07.13.55;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2007.11.22.23.33.41;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.177;

1.177
date	2007.10.23.20.19.56;	author myc;	state Exp;
branches;
next	1.176;

1.176
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.175;

1.175
date	2007.10.15.01.50.23;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.173;

1.173
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.172;

1.172
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.171;

1.171
date	2007.09.28.20.49.35;	author myc;	state Exp;
branches;
next	1.170;

1.170
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2007.09.20.10.01.36;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2007.09.12.22.23.04;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2007.09.04.06.49.19;	author myc;	state Exp;
branches;
next	1.164;

1.164
date	2007.09.01.22.40.17;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2007.09.01.21.22.29;	author jps;	state Exp;
branches;
next	1.162;

1.162
date	2007.08.26.09.08.56;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2007.08.26.08.49.36;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2007.08.24.22.49.05;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2007.08.24.22.10.58;	author jps;	state Exp;
branches;
next	1.158;

1.158
date	2007.08.24.19.16.12;	author myc;	state Exp;
branches;
next	1.157;

1.157
date	2007.08.24.17.01.36;	author myc;	state Exp;
branches;
next	1.156;

1.156
date	2007.08.24.10.24.16;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2007.08.22.18.00.11;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2007.08.22.04.21.03;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2007.08.20.21.24.42;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2007.08.17.02.23.36;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2007.08.16.12.51.09;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2007.08.15.20.48.41;	author myc;	state Exp;
branches;
next	1.149;

1.149
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.148;

1.148
date	2007.08.14.20.13.45;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2007.08.14.10.44.40;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2007.08.08.20.09.42;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2007.08.05.01.49.45;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2007.08.04.03.24.30;	author myc;	state Exp;
branches;
next	1.142;

1.142
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.141;

1.141
date	2007.07.31.23.03.58;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2007.07.19.20.37.17;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2007.07.15.18.01.32;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2007.07.15.17.40.22;	author myc;	state Exp;
branches;
next	1.137;

1.137
date	2007.07.14.05.26.25;	author myc;	state Exp;
branches;
next	1.136;

1.136
date	2007.06.04.22.24.41;	author jps;	state Exp;
branches;
next	1.135;

1.135
date	2007.05.29.00.36.03;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2007.05.28.22.34.21;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2007.05.28.20.08.10;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2007.05.21.02.18.24;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2007.04.18.00.11.12;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2007.04.17.23.59.16;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2007.04.15.10.50.24;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2007.04.15.04.12.47;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2007.04.15.03.55.08;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2007.04.04.13.31.02;	author jps;	state Exp;
branches;
next	1.125;

1.125
date	2007.02.08.01.30.00;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2006.11.23.01.38.27;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2006.11.18.04.26.32;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2006.11.16.18.42.45;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2006.11.13.19.08.49;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.119;

1.119
date	2006.11.12.02.31.01;	author jps;	state Exp;
branches;
next	1.118;

1.118
date	2006.11.12.01.47.11;	author jps;	state Exp;
branches;
next	1.117;

1.117
date	2006.06.24.18.34.22;	author rsd;	state Exp;
branches;
next	1.116;

1.116
date	2006.05.08.15.55.08;	author cjd;	state Exp;
branches;
next	1.115;

1.115
date	2006.05.03.01.27.30;	author rsd;	state Exp;
branches;
next	1.114;

1.114
date	2006.04.09.22.37.31;	author rls;	state Exp;
branches;
next	1.113;

1.113
date	2006.04.09.01.00.00;	author rls;	state Exp;
branches;
next	1.112;

1.112
date	2005.12.31.21.26.04;	author dce;	state Exp;
branches;
next	1.111;

1.111
date	2005.12.31.20.39.22;	author dce;	state Exp;
branches;
next	1.110;

1.110
date	2005.07.27.03.07.08;	author jwk;	state Exp;
branches;
next	1.109;

1.109
date	2005.07.13.21.37.01;	author cjd;	state Exp;
branches;
next	1.108;

1.108
date	2005.06.26.03.39.37;	author cjd;	state Exp;
branches;
next	1.107;

1.107
date	2005.06.26.03.14.17;	author cjd;	state Exp;
branches;
next	1.106;

1.106
date	2004.11.11.23.12.48;	author rsd;	state Exp;
branches;
next	1.105;

1.105
date	2004.11.11.20.11.09;	author cmc;	state Exp;
branches;
next	1.104;

1.104
date	2004.11.01.04.12.01;	author jjl;	state Exp;
branches;
next	1.103;

1.103
date	2004.11.01.03.46.22;	author jjl;	state Exp;
branches;
next	1.102;

1.102
date	2004.11.01.01.14.26;	author rsd;	state Exp;
branches;
next	1.101;

1.101
date	2004.10.31.20.38.11;	author jjl;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.25.02.57.15;	author jjl;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.98;

1.98
date	2002.11.30.19.39.38;	author jjl;	state Exp;
branches;
next	1.97;

1.97
date	2002.09.14.00.12.50;	author dce;	state Exp;
branches;
next	1.96;

1.96
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.95;

1.95
date	2002.07.02.12.51.57;	author rls;	state Exp;
branches;
next	1.94;

1.94
date	2002.07.02.06.46.24;	author rls;	state Exp;
branches;
next	1.93;

1.93
date	2002.06.21.04.32.15;	author rls;	state Exp;
branches;
next	1.92;

1.92
date	2002.06.07.01.14.26;	author rls;	state Exp;
branches;
next	1.91;

1.91
date	2002.05.23.00.19.41;	author rls;	state Exp;
branches;
next	1.90;

1.90
date	2002.03.30.19.20.14;	author dce;	state Exp;
branches;
next	1.89;

1.89
date	2002.03.15.02.45.14;	author dce;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.25.09.48.42;	author rls;	state Exp;
branches;
next	1.87;

1.87
date	2001.10.22.01.35.58;	author dce;	state Exp;
branches;
next	1.86;

1.86
date	2001.04.08.17.23.46;	author dce;	state Exp;
branches;
next	1.85;

1.85
date	2001.04.07.17.02.30;	author dce;	state Exp;
branches;
next	1.84;

1.84
date	2001.04.02.03.18.41;	author dce;	state Exp;
branches;
next	1.83;

1.83
date	2001.03.31.22.17.56;	author dce;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.28.02.08.26;	author dce;	state Exp;
branches;
next	1.81;

1.81
date	2001.03.26.02.17.18;	author dce;	state Exp;
branches;
next	1.80;

1.80
date	2001.03.24.19.42.27;	author dce;	state Exp;
branches;
next	1.79;

1.79
date	2001.03.10.18.45.33;	author dce;	state Exp;
branches;
next	1.78;

1.78
date	2001.03.07.03.08.09;	author dce;	state Exp;
branches;
next	1.77;

1.77
date	2001.03.04.14.27.39;	author dce;	state Exp;
branches;
next	1.76;

1.76
date	2001.03.03.18.07.10;	author dce;	state Exp;
branches;
next	1.75;

1.75
date	2001.01.29.05.05.30;	author rsd;	state Exp;
branches;
next	1.74;

1.74
date	2000.11.28.00.46.32;	author mtp;	state Exp;
branches;
next	1.73;

1.73
date	2000.11.25.08.12.06;	author rsd;	state Exp;
branches;
next	1.72;

1.72
date	2000.11.20.05.02.57;	author rsd;	state Exp;
branches;
next	1.71;

1.71
date	2000.11.16.02.43.00;	author rsd;	state Exp;
branches;
next	1.70;

1.70
date	2000.11.11.00.04.36;	author mtp;	state Exp;
branches;
next	1.69;

1.69
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.68;

1.68
date	2000.11.03.05.37.17;	author jimmy;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.02.23.41.19;	author mtp;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.02.23.38.09;	author mtp;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.01.00.44.35;	author mtp;	state Exp;
branches;
next	1.64;

1.64
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.13.04.27.23;	author cmc;	state Exp;
branches;
next	1.62;

1.62
date	2000.09.14.00.54.08;	author rsd;	state Exp;
branches;
next	1.61;

1.61
date	2000.09.13.22.20.43;	author rsd;	state Exp;
branches;
next	1.60;

1.60
date	2000.09.13.21.06.28;	author rsd;	state Exp;
branches;
next	1.59;

1.59
date	2000.08.31.17.45.35;	author rsd;	state Exp;
branches;
next	1.58;

1.58
date	2000.04.26.23.33.56;	author rsd;	state Exp;
branches;
next	1.57;

1.57
date	2000.04.22.22.31.41;	author rsd;	state Exp;
branches;
next	1.56;

1.56
date	2000.04.14.19.09.35;	author rsd;	state Exp;
branches;
next	1.55;

1.55
date	2000.04.14.18.56.15;	author rsd;	state Exp;
branches;
next	1.54;

1.54
date	2000.04.14.18.52.26;	author rsd;	state Exp;
branches;
next	1.53;

1.53
date	2000.04.14.18.48.34;	author rsd;	state Exp;
branches;
next	1.52;

1.52
date	2000.02.25.02.42.00;	author rsd;	state Exp;
branches;
next	1.51;

1.51
date	2000.02.24.01.04.18;	author dce;	state Exp;
branches;
next	1.50;

1.50
date	2000.02.16.07.58.39;	author mtp;	state Exp;
branches;
next	1.49;

1.49
date	2000.02.16.07.16.12;	author rsd;	state Exp;
branches;
next	1.48;

1.48
date	2000.01.31.03.58.41;	author cso;	state Exp;
branches;
next	1.47;

1.47
date	2000.01.30.23.11.18;	author rsd;	state Exp;
branches;
next	1.46;

1.46
date	99.11.28.22.49.49;	author cso;	state Exp;
branches;
next	1.45;

1.45
date	99.10.30.15.21.06;	author rsd;	state Exp;
branches;
next	1.44;

1.44
date	99.10.04.21.39.18;	author rsd;	state Exp;
branches;
next	1.43;

1.43
date	99.09.16.01.15.11;	author dce;	state Exp;
branches;
next	1.42;

1.42
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.41;

1.41
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.40;

1.40
date	99.08.18.22.39.24;	author mtp;	state Exp;
branches;
next	1.39;

1.39
date	99.08.12.21.01.00;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.37;

1.37
date	99.08.12.06.15.03;	author mtp;	state Exp;
branches;
next	1.36;

1.36
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.35;

1.35
date	99.07.29.20.19.35;	author jimmy;	state Exp;
branches;
next	1.34;

1.34
date	99.07.26.00.20.59;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.07.24.23.27.13;	author jimmy;	state Exp;
branches;
next	1.32;

1.32
date	99.07.23.23.37.38;	author jimmy;	state Exp;
branches;
next	1.31;

1.31
date	99.07.22.17.43.59;	author jimmy;	state Exp;
branches;
next	1.30;

1.30
date	99.07.10.15.41.23;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	99.07.10.05.30.49;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	99.07.10.03.13.30;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	99.07.07.22.53.38;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	99.07.07.22.07.12;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.07.06.19.57.05;	author jimmy;	state Exp;
branches;
next	1.24;

1.24
date	99.06.30.18.11.09;	author jimmy;	state Exp;
branches;
next	1.23;

1.23
date	99.06.22.18.23.36;	author jimmy;	state Exp;
branches;
next	1.22;

1.22
date	99.06.18.21.56.51;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.06.18.17.25.42;	author jimmy;	state Exp;
branches;
next	1.20;

1.20
date	99.06.11.17.58.10;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	99.06.10.21.47.42;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.05.04.18.03.09;	author dce;	state Exp;
branches;
next	1.16;

1.16
date	99.05.04.17.19.33;	author dce;	state Exp;
branches;
next	1.15;

1.15
date	99.05.01.03.15.33;	author dce;	state Exp;
branches;
next	1.14;

1.14
date	99.04.20.22.40.38;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.03.13.19.42.28;	author jimmy;	state Exp;
branches;
next	1.12;

1.12
date	99.02.26.22.30.30;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.02.23.16.48.06;	author dce;	state Exp;
branches;
next	1.10;

1.10
date	99.02.19.01.58.44;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.02.12.16.25.09;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.02.10.22.21.42;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.02.06.17.49.29;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.06.00.40.36;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.05.07.47.42;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.02.02.41.42;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	99.02.01.08.12.46;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.19.26.45;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.wizard.c                                  Part of CircleMUD *
 *  Usage: Player-level god commands and other goodies                     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "screen.h"
#include "olc.h"
#include "dg_scripts.h"
#include "clan.h"
#include "worship.h"

/*   external vars  */
extern FILE *player_fl;
void garble_text(char *string, int percent);
void clear_skills(struct char_data *ch);
void set_skills(struct char_data *ch);
extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
extern struct room_data *world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct descriptor_data *descriptor_list;
extern struct title_type titles[NUM_CLASSES][LVL_IMPL + 1];
extern struct player_index_element *player_table;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct int_app_type int_app[];
extern struct wis_app_type wis_app[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern int restrict;
extern int top_of_world;
extern int top_of_mobt;
extern int top_of_objt;
extern int top_of_p_table;
extern int rev_dir[];
extern char *howgood(int percent);
extern int top_of_p_table;

extern int pk_allowed;
extern int sleep_allowed;
extern int charm_allowed;
extern int summon_allowed;
extern int roomaffect_allowed;
extern DI Dieties[];
int Valid_Name(char *newname);
int reserved_word(char *argument);

/* for objects */
extern char *item_types[];
extern char *wear_bits[];
extern char *extra_bits[];
extern char *container_bits[];
extern char *drinks[];

/* for rooms */
extern char *dirs[];
extern char *room_bits[];
extern char *exit_bits[];
extern char *sector_types[];

/* for chars */
extern char *spells[];
extern char *equipment_types[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern char *apply_types[];
extern char *pc_class_types[];
extern char *npc_class_types[];
extern char *action_bits[];
extern char *player_bits[];
extern char *preference_bits[];
extern char *position_types[];
extern char *connected_types[];
extern char *race_abbrevs[];
extern char *size_abbrevs[];
extern char *race_align_abbrevs[];
extern char *mspecies_types[];
extern char *mclass_types[];
extern char *race_align_abbrevs[];
int set_race_align(struct char_data *ch);
extern const struct str_app_type str_app[];
/* extern functions */
int vnum_object_zone(int zone, struct char_data *ch);
int vnum_mob_zone(int zone, struct char_data *ch);

ACMD(do_echo)
{
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
  struct char_data *tch;
  skip_spaces(&argument);


  if (!*argument)
    send_to_char("Yes.. but what?\r\n", ch);

  else {

    if(GET_LEVEL(ch) < LVL_IMMORT)
      if(strchr(argument, '&'))  {
	send_to_char("No ampersand sign allowed in input.", ch);
	return;
      }
    if (subcmd == SCMD_EMOTE){
      if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
	send_to_char("Your lips move, but no sound forms.\r\n", ch);
	return;
      }
      strcpy(ibuf, argument);     /* save real message */
#ifdef LANGUAGES
      if (!IS_NPC(ch))
	garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif

      for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
	if (tch != ch && AWAKE(tch) && tch->desc) {

	  strcpy(obuf, ibuf);     /* preserve the first garble */
#ifdef LANGUAGES
	  if (!IS_NPC(ch))
	    garble_text(obuf, GET_SKILL(tch, SPEAKING(ch)));
#endif

	  if ((GET_SKILL(tch, SPEAKING(ch)) < 1) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) &&
	      (GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0",  obuf);
	  else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0", obuf);
	  else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0", argument);
	  else
	    sprintf(buf, "$n %s&0", argument);
	  MOBTrigger = FALSE;
	  act(buf, TRUE, ch, 0, tch, TO_VICT);

	}
      }
    }else{
      strcpy(buf, argument);
      MOBTrigger = FALSE;
      act(buf, FALSE, ch, 0, 0, TO_ROOM);}
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      MOBTrigger = FALSE;
      strcpy(buf, argument);
      sprintf(buf2, "$n %s", buf);
      act(buf2, FALSE, ch, 0, 0, TO_CHAR);
    }
  }
}


ACMD(do_send)
{
  struct char_data *vict;

  half_chop(argument, arg, buf);

  if (!*arg) {
    send_to_char("Send what to who?\r\n", ch);
    return;
  }
  if (!(vict = get_char_vis(ch, arg))) {
    send_to_char(NOPERSON, ch);
    return;
  }
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char("Sent.\r\n", ch);
  else {
    sprintf(buf2, "You send '%s' to %s.\r\n", buf, GET_NAME(vict));
    send_to_char(buf2, ch);
  }
}

void perform_ptell(struct char_data *ch, struct char_data *vict, char *arg)
{
  struct descriptor_data *d;

  sprintf(buf, "&6$n responds to your petition, '&b%s&0&6'&0", arg);
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    sprintf(buf, "&6You respond to $N, '&b%s&0&6'&0", arg);
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  }
  sprintf(buf, "&6%s responds to %s's petition, '&b%s&0&6'&0\r\n",
	  GET_NAME(ch), GET_NAME(vict), arg);

  for (d = descriptor_list; d; d = d->next) {
    if ((!d->connected) && (GET_LEVEL(d->character) >= LVL_IMMORT) &&
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
        && (d != ch->desc)) {
      send_to_char(buf, d->character);
    }
  }
}

ACMD(do_ptell)
{
  struct char_data *vict;

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2)
    send_to_char("Who do you wish to ptell??\r\n", ch);
  else if (!(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (ch == vict)
    send_to_char("You need mental help. Try ptelling someone besides yourself.\r\n", ch);
  else if (!IS_NPC(vict) && !vict->desc)        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else
    perform_ptell(ch, vict, buf2);
}

ACMD(do_wworld)
{
  int number=0, zone=0, found=0, j, i;
  struct room_data *rm = &world[ch->in_room];

  two_arguments(argument, buf, buf2);

  if (!*buf) {
    send_to_char("Usage: wworld { obj | mob } [zone number]\r\n", ch);
    return;
  }
  if (*buf2 && isdigit(*buf2)) {
    found=1;
    if ((number = atoi(buf2)) < 0) {
      send_to_char("A NEGATIVE number??\r\n", ch);
      return;
    }
    for (j= number, i=0; zone_table[i].number != j && i <= top_of_zone_table; i++);
    if (i > top_of_zone_table) {
      send_to_char("That is not a valid zone.\r\n", ch);
      return;
    }
    else
      zone=i;
  } else zone = rm->zone;

  if (is_abbrev(buf, "obj")) {
    sprintf(buf2, "Object listing for zone #%d\r\n----------------------------\r\n",number);
    send_to_char(buf2,ch);
    vnum_object_zone(zone, ch);
  }
  else if (is_abbrev(buf, "mob")) {
    sprintf(buf2, "Mob listing for zone #%d\r\n-------------------------\r\n",number);
    send_to_char(buf2,ch);
    vnum_mob_zone(zone, ch);
  }
  else {
    send_to_char("Usage: world { obj | mob } [zone number]\r\n", ch);
  }
}



/* take a string, and return an rnum.. used for goto, at, etc.  -je 4/6/93 */
int find_target_room(struct char_data * ch, char *rawroomstr)
{
  int tmp;
  int location;
  struct char_data *target_mob;
  struct obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];

  one_argument(rawroomstr, roomstr);

  if (!*roomstr) {
    send_to_char("You must supply a room number or name.\r\n", ch);
    return NOWHERE;
  }
  if (isdigit(*roomstr) && !strchr(roomstr, '.')) {
    tmp = atoi(roomstr);
    if ((location = real_room(tmp)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return NOWHERE;
    }
  } else if ((target_mob = get_char_vis(ch, roomstr)))
    location = target_mob->in_room;
  else if ((target_obj = get_obj_vis(ch, roomstr))) {
    if (target_obj->in_room != NOWHERE)
      location = target_obj->in_room;
    else {
      send_to_char("That object is not available.\r\n", ch);
      return NOWHERE;
    }
  } else {
    send_to_char("No such creature or object around.\r\n", ch);
    return NOWHERE;
  }

  /* a location has been found -- if you're < GRGOD, check restrictions. */
  if (GET_LEVEL(ch) < LVL_GOD) {
    if (ROOM_FLAGGED(location, ROOM_GODROOM)) {
      send_to_char("You are not godly enough to use that room!\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room) {
      send_to_char("There's a private conversation going on in that room.\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_HOUSE) &&
	!House_can_enter(ch, world[location].number)) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return NOWHERE;
    }
  }
  return location;
}



ACMD(do_at)
{
  char command[MAX_INPUT_LENGTH];
  int location, original_loc;

  half_chop(argument, buf, command);
  if (!*buf) {
    send_to_char("You must supply a room number or a name.\r\n", ch);
    return;
  }

  if (!*command) {
    send_to_char("What do you want to do there?\r\n", ch);
    return;
  }

  if ((location = find_target_room(ch, buf)) < 0)
    return;

  /* a location has been found. */
  original_loc = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, location);
  command_interpreter(ch, command);

  /* check if the char is still there */
  if (ch->in_room == location) {
    char_from_room(ch);
    char_to_room(ch, original_loc);
  }
}


ACMD(do_goto)
{
  int location;

  if ((location = find_target_room(ch, argument)) < 0)
    return;

  if (POOFOUT(ch))
    sprintf(buf, "$n %s", POOFOUT(ch));
  else
    strcpy(buf, "$n disappears in a puff of smoke.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  char_from_room(ch);
  char_to_room(ch, location);

  if (POOFIN(ch))
    sprintf(buf, "$n %s", POOFIN(ch));
  else
    strcpy(buf, "$n appears with an ear-splitting bang.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
}

ACMD(do_listclass)
{
  extern char *class_display[NUM_CLASSES];
  int i;
  if(!ch)
    return;

  sprintf(buf, "Hubis Classes:\r\n==============\r\n");
  for(i=0;i<NUM_CLASSES;i++)
    sprintf(buf,"%s%s\r\n", buf, class_display[i]);
  page_string(ch->desc, buf, 1);
}

ACMD(do_linkload)
{
  struct char_data *victim = 0;
  struct char_file_u tmp_store;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Linkload who?\r\n", ch);
    return;
  }
  if (get_player_vis(ch, arg, 0)) {
    send_to_char("They are already connected!\r\n", ch);
    return;
  }
  CREATE(victim, struct char_data, 1);
  clear_char(victim);
  if (load_char(arg, &tmp_store) > -1) {
    store_to_char(&tmp_store, victim);
    if (GET_LEVEL(victim) <= GET_LEVEL(ch)) {
      sprintf(buf, "(GC) %s has link-loaded %s.", GET_NAME(ch),GET_NAME(victim));
      mudlog(buf, BRF, GET_LEVEL(ch) + 1, TRUE);
      Crash_load(victim);
      victim->next = character_list;
      character_list = victim;
      victim->desc = NULL;
      char_to_room(victim, IN_ROOM(ch));
      act("You linkload $N.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n linkloads $N.", FALSE, ch, 0, victim, TO_NOTVICT);
    } else {
      send_to_char("Sorry, you aren't high enough to link-load that char.\r\n", ch);
      free_char(victim);
    }
  } else {
    send_to_char("No such player exists.\r\n", ch);
    free(victim);
  }
  return;
}


ACMD(do_trans)
{
  struct descriptor_data *i;
  struct char_data *victim;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to transfer?\r\n", ch);
  else if (str_cmp("all", buf)) {
    if (!(victim = get_char_vis(ch, buf)))
      send_to_char(NOPERSON, ch);
    else if (victim == ch)
      send_to_char("That doesn't make much sense, does it?\r\n", ch);
    else {
      if ((GET_LEVEL(ch) < GET_LEVEL(victim)) && !IS_NPC(victim)) {
	send_to_char("Go transfer someone your own size.\r\n", ch);
	return;
      }
      act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, ch->in_room);
      act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
      act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
      look_at_room(victim, 0);
    }
  } else {			/* Trans All */
    if (GET_LEVEL(ch) < LVL_GRGOD) {
      send_to_char("I think not.\r\n", ch);
      return;
    }

    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->character && i->character != ch) {
	victim = i->character;
	if (GET_LEVEL(victim) >= GET_LEVEL(ch))
	  continue;
	act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
	char_from_room(victim);
	char_to_room(victim, ch->in_room);
	act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
	act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
	look_at_room(victim, 0);
      }
    send_to_char(OK, ch);
  }
}



ACMD(do_teleport)
{
  struct char_data *victim;
  int target;

  two_arguments(argument, buf, buf2);

  if (!*buf)
    send_to_char("Whom do you wish to teleport?\r\n", ch);
  else if (!(victim = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (victim == ch)
    send_to_char("Use 'goto' to teleport yourself.\r\n", ch);
  else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
    send_to_char("Maybe you shouldn't do that.\r\n", ch);
  else if (!*buf2)
    send_to_char("Where do you wish to send this person?\r\n", ch);
  else if ((target = find_target_room(ch, buf2)) >= 0) {
    send_to_char(OK, ch);
    act("$n disappears in a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    char_from_room(victim);
    char_to_room(victim, target);
    act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    act("$n has teleported you!", FALSE, ch, 0, (char *) victim, TO_VICT);
    look_at_room(victim, 0);
  }
}



ACMD(do_vnum)
{
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && !is_abbrev(buf, "obj"))) {
    send_to_char("Usage: vnum { obj | mob } <name>\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob"))
    if (!vnum_mobile(buf2, ch))
      send_to_char("No mobiles by that name.\r\n", ch);

  if (is_abbrev(buf, "obj"))
    if (!vnum_object(buf2, ch))
      send_to_char("No objects by that name.\r\n", ch);
}



void do_stat_room(struct char_data * ch)
{
  extern char *room_affections[];
  struct extra_descr_data *desc;
  struct room_data *rm = &world[ch->in_room];
  int i, found = 0;
  struct obj_data *j = 0;
  struct char_data *k = 0;

  sprintf(buf, "Room name: %s%s%s\r\n", CCCYN(ch, C_NRM), rm->name,
	  CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprinttype(rm->sector_type, sector_types, buf2);
  sprintf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
	  rm->zone, CCGRN(ch, C_NRM), rm->number, CCNRM(ch, C_NRM), ch->in_room, buf2);
  send_to_char(buf, ch);

  sprintbit((long) rm->room_flags, room_bits, buf2);
  sprintf(buf, "SpecProc: %s, Flags: %s\r\n",
	  (rm->func == NULL) ? "None" : "Exists", buf2);
  send_to_char(buf, ch);

  sprintbit((long) rm->room_affections, room_affections, buf2);
  sprintf(buf, "Room affections: %s\r\n", buf2);
  send_to_char(buf, ch);

  sprintf(buf, "Ambient Light : %d\r\n", rm->light);
  send_to_char(buf, ch);

  send_to_char("Description:\r\n", ch);
  if (rm->description)
    send_to_char(rm->description, ch);
  else
    send_to_char("  None.\r\n", ch);

  if (rm->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = rm->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  sprintf(buf, "Chars present:%s", CCYEL(ch, C_NRM));
  for (found = 0, k = rm->people; k; k = k->next_in_room) {
    if (!CAN_SEE(ch, k))
      continue;
    sprintf(buf2, "%s %s(%s)", found++ ? "," : "", GET_NAME(k),
	    (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (k->next_in_room)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  send_to_char(CCNRM(ch, C_NRM), ch);

  if (rm->contents) {
    sprintf(buf, "Contents:%s", CCGRN(ch, C_NRM));
    for (found = 0, j = rm->contents; j; j = j->next_content) {
      if (!CAN_SEE_OBJ(ch, j))
	continue;
      sprintf(buf2, "%s %s", found++ ? "," : "", j->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }
  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (rm->dir_option[i]) {
      if (rm->dir_option[i]->to_room == NOWHERE)
	sprintf(buf1, " %sNONE%s", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
      else
	sprintf(buf1, "%s%5d%s", CCCYN(ch, C_NRM),
		world[rm->dir_option[i]->to_room].number, CCNRM(ch, C_NRM));
      sprintbit(rm->dir_option[i]->exit_info, exit_bits, buf2);
      sprintf(buf, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n ",
	      CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
	      rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None",
	      buf2);
      send_to_char(buf, ch);
      if (rm->dir_option[i]->general_description)
	strcpy(buf, rm->dir_option[i]->general_description);
      else
	strcpy(buf, "  No exit description.\r\n");
      send_to_char(buf, ch);
    }
  }

  /* check the room for a script */
  do_sstat_room(ch);
}



void do_stat_object(struct char_data * ch, struct obj_data * j)
{
  int i, virtual, found;
  struct obj_data *j2;
  struct extra_descr_data *desc;

  virtual = GET_OBJ_VNUM(j);
  sprintf(buf, "Name: '%s%s%s', Aliases: %s\r\n", CCYEL(ch, C_NRM),
	  ((j->short_description) ? j->short_description : "<None>"),
	  CCNRM(ch, C_NRM), j->name);
  send_to_char(buf, ch);
  sprinttype(GET_OBJ_TYPE(j), item_types, buf1);
  if (GET_OBJ_RNUM(j) >= 0)
    strcpy(buf2, (obj_index[GET_OBJ_RNUM(j)].func ? "Exists" : "None"));
  else
    strcpy(buf2, "None");
  sprintf(buf, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s\r\n",
	  CCGRN(ch, C_NRM), virtual, CCNRM(ch, C_NRM), GET_OBJ_RNUM(j), buf1, buf2);
  send_to_char(buf, ch);
  sprintf(buf, "L-Des: %s\r\n", ((j->description) ? j->description : "None"));
  send_to_char(buf, ch);

  if (j->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = j->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  send_to_char("Can be worn on: ", ch);
  sprintbit(j->obj_flags.wear_flags, wear_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Set char bits : ", ch);
  sprintbit(j->obj_flags.bitvector, affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Extra flags   : ", ch);
  sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Spell Affects 1 : ", ch);
  sprintbit(GET_OBJ_SPELL(j), affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  send_to_char("Spell Affects 2 : ", ch);
  sprintbit(GET_OBJ_SPELL2(j), affected_bits2, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  send_to_char("Spell Affects 3 : ", ch);
  sprintbit(GET_OBJ_SPELL3(j), affected_bits3, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);


  sprintf(buf, "Weight: %d, Value: %d, Cost/day: %d, Timer: %d\r\n",
	  GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j), GET_OBJ_TIMER(j));
  send_to_char(buf, ch);

  strcpy(buf, "In room: ");
  if (j->in_room == NOWHERE)
    strcat(buf, "Nowhere");
  else {
    sprintf(buf2, "%d", world[j->in_room].number);
    strcat(buf, buf2);
  }
  strcat(buf, ", In object: ");
  strcat(buf, j->in_obj ? j->in_obj->short_description : "None");
  strcat(buf, ", Carried by: ");
  strcat(buf, j->carried_by ? GET_NAME(j->carried_by) : "Nobody");
  strcat(buf, ", Worn by: ");
  strcat(buf, j->worn_by ? GET_NAME(j->worn_by) : "Nobody");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  switch (GET_OBJ_TYPE(j)) {
  case ITEM_LIGHT:
    if (GET_OBJ_VAL(j, 2) == -1)
      strcpy(buf, "Hours left: Infinite");
    else
      sprintf(buf, "Hours left: [%d]", GET_OBJ_VAL(j, 2));
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    sprintf(buf, "Spells: (Level %d) %s, %s, %s", GET_OBJ_VAL(j, 0),
	    skill_name(GET_OBJ_VAL(j, 1)), skill_name(GET_OBJ_VAL(j, 2)),
	    skill_name(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    sprintf(buf, "Spell: %s at level %d, %d (of %d) charges remaining",
	    skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
	    GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_WEAPON:
    sprintf(buf, "Todam: %dd%d, Message type: %d",
	    GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  case ITEM_ARMOR:
    sprintf(buf, "AC-apply: [%d]", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_TRAP:
    sprintf(buf, "Spell: %d, - Hitpoints: %d",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_CONTAINER:
    if (!IS_CORPSE(j)) {
      sprintbit(GET_OBJ_VAL(j, 1), container_bits, buf2);
      sprintf(buf, "Weight capacity: %d, Lock Type: %s, Key Num: %d, Corpse: %s",
	      GET_OBJ_VAL(j, 0), buf2, GET_OBJ_VAL(j, 2),
	      YESNO(GET_OBJ_VAL(j, 3)));
    }
    else {
      sprintf(buf, "Weight capacity: %d, Player Corpse: %s, Index: %d, Corpse: %s",
	      GET_OBJ_VAL(j,0), YESNO(GET_OBJ_VAL(j,1)), GET_OBJ_VAL(j,2),
	      YESNO(GET_OBJ_VAL(j,3)));
    }
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    sprinttype(GET_OBJ_VAL(j, 2), drinks, buf2);
    sprintf(buf, "Capacity: %d, Contains: %d, Poisoned: %s, Liquid: %s",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), YESNO(GET_OBJ_VAL(j, 3)),
	    buf2);
    break;
  case ITEM_NOTE:
    sprintf(buf, "Tongue: %d", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_KEY:
    strcpy(buf, "");
    break;
  case ITEM_FOOD:
    sprintf(buf, "Makes full: %d, Poisoned: %s", GET_OBJ_VAL(j, 0),
	    YESNO(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_MONEY:
    sprintf(buf, "Coins: %d", GET_OBJ_VAL(j, 0));
    break;
  default:
    sprintf(buf, "Values 0-3: [%d] [%d] [%d] [%d]",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
	    GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  }
  send_to_char(strcat(buf, "\r\n"), ch);

  /*
   * I deleted the "equipment status" code from here because it seemed
   * more or less useless and just takes up valuable screen space.
   */

  if (j->contains) {
    sprintf(buf, "\r\nContents:%s", CCGRN(ch, C_NRM));
    for (found = 0, j2 = j->contains; j2; j2 = j2->next_content) {
      sprintf(buf2, "%s %s", found++ ? "," : "", j2->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j2->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }
  found = 0;
  send_to_char("Affections:", ch);
  for (i = 0; i < MAX_OBJ_AFFECT; i++)
    if (j->affected[i].modifier) {
      sprinttype(j->affected[i].location, apply_types, buf2);
      sprintf(buf, "%s %+d to %s", found++ ? "," : "",
	      j->affected[i].modifier, buf2);
      send_to_char(buf, ch);
    }
  if (!found)
    send_to_char(" None", ch);

  send_to_char("\r\n", ch);

  /* check the object for a script */
  do_sstat_object(ch, j);
}



void do_stat_character(struct char_data * ch, struct char_data * k/*, struct descriptor_data * d*/)
{
  int i, i2, found = 0;
  int a;
  struct group_type *g;
  struct mgroup_type *mg;
  struct obj_data *j;
  struct follow_type *fol;
  struct affected_type *aff;
  extern struct attack_hit_type attack_hit_text[];
  switch (GET_SEX(k)) {
  case SEX_NEUTRAL:    strcpy(buf, "NEUTRAL-SEX");   break;
  case SEX_MALE:       strcpy(buf, "MALE");          break;
  case SEX_FEMALE:     strcpy(buf, "FEMALE");        break;
  default:             strcpy(buf, "ILLEGAL-SEX!!"); break;
  }

  sprintf(buf2, " %s '%s'  IDNum: [%5ld], In room [%5d]\r\n",
	  (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
	  GET_NAME(k), GET_IDNUM(k), world[k->in_room].number);
  send_to_char(strcat(buf, buf2), ch);
  if (IS_MOB(k)) {
    sprintf(buf, "Alias: %s, VNum: [%5d], RNum: [%5ld]\r\n",
	    k->player.name, GET_MOB_VNUM(k), GET_MOB_RNUM(k));
    send_to_char(buf, ch);
  }
  sprintf(buf, "Title: %s\r\n", (k->player.title ? k->player.title : "<None>"));
  send_to_char(buf, ch);

  sprintf(buf, "Size: %s\r\n", SIZE_ABBR(k));
  send_to_char(buf, ch);

  sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : "<None>\r\n"));
  send_to_char(buf, ch);



  if (IS_NPC(k)) {
    sprintf(buf, "Species: %s, Race_align: %s\n\r", mspecies_types[(int)GET_SPECIES(k)], RACE_ALIGN_ABBR(k));
    send_to_char(buf, ch);
  }
  else  {
    sprintf(buf, "Species: %s, Race_align: %s, Deity: %s\n\r", RACE_ABBR(k),
	    RACE_ALIGN_ABBR(k),((GET_DIETY(ch)) ? "No Deity"
				:
				Dieties[(int)GET_DIETY(ch)].diety_name));
    send_to_char(buf,ch);
  }
  if (IS_NPC(k)) {
    strcpy(buf, "Monster Class: ");
    sprinttype(k->player.class, mclass_types, buf2);
  } else {
    strcpy(buf, "Class: ");
    sprinttype(k->player.class, pc_class_types, buf2);
  }
  strcat(buf, buf2);



  sprintf(buf2, ", Lev: [%s%2d%s], XP: [%s%7ld%s], Align: [%4d]\r\n",
	  CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
	  CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
	  GET_ALIGNMENT(k));
  strcat(buf, buf2);
  send_to_char(buf, ch);

  if (!IS_NPC(k)) {
    strcpy(buf1, (char *) asctime(localtime(&(k->player.time.birth))));
    strcpy(buf2, (char *) asctime(localtime(&(k->player.time.logon))));
    buf1[10] = buf2[10] = '\0';

    sprintf(buf, " Created: [%s], Last Logon: [%s], Played [%dh %dm], Age [%d]\r\n",
	    buf1, buf2, k->player.time.played / 3600,
	    ((k->player.time.played / 3600) % 60), age(k).year);
    send_to_char(buf, ch);

    sprintf(buf, "Frags[%4.2f], Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])", GET_FRAG(k),
	    k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
	    GET_PRACTICES(k), int_app[GET_INT(k)].learn,
	    wis_app[GET_WIS(k)].bonus);
    /*. Display OLC zone for immorts .*/
    if(GET_LEVEL(k) >= LVL_IMMORT)
      sprintf(buf, "%s,\r\n OLC[%d], OLC2[%d], OLC3[%d], OLC4[%d], OLC5[%d]", buf,
	      GET_OLC_ZONE(k), GET_OLC2_ZONE(k), GET_OLC3_ZONE(k), GET_OLC4_ZONE(k), GET_OLC5_ZONE(k));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }
  sprintf(buf, "Str:[%s%d(%d)/%d(%d)|%d(%d)/%d(%d)%s] Int:[%s%d/%d|%d/%d%s] \r\nWis:[%s%d/%d|%d/%d%s] "
	  "Dex:[%s%d/%d|%d/%d%s]\r\nCon:[%s%d/%d|%d/%d%s] Cha:[%s%d/%d|%d/%d%s]\r\n",
	  CCCYN(ch, C_NRM), GET_STR(k), GET_ADD(k), GET_RSTR(k), GET_RADD(k), GET_STR_VAFF(k), GET_ADD_VAFF(k), GET_STR_VIEW(k), GET_ADD_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_INT(k), GET_RINT(k), GET_INT_VAFF(k), GET_INT_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_WIS(k), GET_RWIS(k), GET_WIS_VAFF(k), GET_WIS_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_DEX(k), GET_RDEX(k), GET_DEX_VAFF(k), GET_DEX_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_CON(k), GET_RCON(k), GET_CON_VAFF(k), GET_CON_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_CHA(k), GET_RCHA(k), GET_CHA_VAFF(k), GET_CHA_VIEW(k), CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprintf(buf, "Hit p.:[%s%d/%d+%d%s]  Mana p.:[%s%d/%d+%d%s]  Move p.:[%s%d/%d+%d%s]\r\n",
	  CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprintf(buf, "Coins: [%dp / %dg / %ds / %dc]\r\nBank: [%ldp / %ldg / %lds / %ldc]\r\n",
	  GET_PLAT(k), GET_GOLD(k), GET_SILVER(k), GET_COPPER(k),
	  GET_BANK_PLAT(k), GET_BANK_GOLD(k), GET_BANK_SILVER(k), GET_BANK_COPPER(k));
  send_to_char(buf, ch);

  sprintf(buf, "AC: [%d/10], Hitroll: [%2d], Damroll: [%2d], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	  GET_AC(k), k->points.hitroll, k->points.damroll, GET_SAVE(k, 0),
	  GET_SAVE(k, 1), GET_SAVE(k, 2), GET_SAVE(k, 3), GET_SAVE(k, 4));
  send_to_char(buf, ch);

  sprinttype(GET_POS(k), position_types, buf2);
  sprintf(buf, "Pos: %s, Fighting: %s", buf2,
	  (FIGHTING(k) ? GET_NAME(FIGHTING(k)) : "Nobody"));

  if (IS_NPC(k)) {
    strcat(buf, ", Attack type: ");
    strcat(buf, attack_hit_text[k->mob_specials.attack_type].singular);
  }
  if (k->desc) {
    sprinttype(k->desc->connected, connected_types, buf2);
    strcat(buf, ", Connected: ");
    strcat(buf, buf2);
  }
  send_to_char(strcat(buf, "\r\n"), ch);

  strcpy(buf, "Default position: ");
  sprinttype((k->mob_specials.default_pos), position_types, buf2);
  strcat(buf, buf2);

  sprintf(buf2, ", Idle Timer (in tics) [%d]\r\n", k->char_specials.timer);
  strcat(buf, buf2);
  send_to_char(buf, ch);

  if (IS_NPC(k)) {
    sprintbit(MOB_FLAGS(k), action_bits, buf2);
    sprintf(buf, "NPC flags: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
  } else {
    sprintbit(PLR_FLAGS(k), player_bits, buf2);
    sprintf(buf, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(PRF_FLAGS(k), preference_bits, buf2);
    sprintf(buf, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
  }

  if (IS_MOB(k)) {
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d\r\n",
	    (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
	    k->mob_specials.damnodice, k->mob_specials.damsizedice);
    send_to_char(buf, ch);
  }
  sprintf(buf, "Max Carry: weight: %d, items: %d\r\n", CAN_CARRY_W(k), CAN_CARRY_N(k));
  sprintf(buf, "%sCarried: weight: %d, items: %d; ", buf,
	  IS_CARRYING_W(k), IS_CARRYING_N(k));

  for (i = 0, j = k->carrying; j; j = j->next_content, i++);
  sprintf(buf, "%sItems in: inventory: %d, ", buf, i);

  for (i = 0, i2 = 0; i < NUM_WEARS; i++)
    if (GET_EQ(k, i))
      i2++;
  sprintf(buf2, "eq: %d\r\n", i2);
  strcat(buf, buf2);
  send_to_char(buf, ch);

  sprintf(buf, "Hunger: %d, Thirst: %d, Drunk: %d\r\n",
	  GET_COND(k, FULL), GET_COND(k, THIRST), GET_COND(k, DRUNK));
  send_to_char(buf, ch);
  sprintf(buf, "Consented: %s", ((CONSENT(ch)) ? GET_NAME(CONSENT(ch)) : "<none>"));
  send_to_char(strcat(buf, ",\r\n"), ch);
  sprintf(buf, "Master is: %s, Followers are:",
	  ((k->master) ? GET_NAME(k->master) : "<none>"));

  for (fol = k->followers; fol; fol = fol->next) {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(fol->follower, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (fol->next)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  /*group lists*/
  sprintf(buf, "&0&2&bGroup Master&0 is: %s, &0&2&bgroupees are:&0",
	  ((k->groupmaster) ? GET_NAME(k->groupmaster) : "<none>"));

  for (g = k->groupees; g; g = g->next) {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(g->groupee, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (g->next)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);

  /*major group lists*/
  sprintf(buf, "&0&1Major Group Master&0 is: %s, &0&1major groupees are:&0",
	  ((k->mgroupmaster) ? GET_NAME(k->mgroupmaster) : "<none>"));

  for (mg = k->mgroupees; mg; mg = mg->next) {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(mg->mgroupee, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (mg->next)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }
  sprintf(buf, "%s\r\nGuarding : %s, Guarded_by : %s", buf,
	  k->guarding ? GET_NAME(k->guarding) : "<NULL>",
	  k->guarded_by ? GET_NAME(k->guarded_by) :"<NULL>");
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  /* Showing the bitvector */
  sprintbit(AFF_FLAGS(k), affected_bits, buf2);
  sprintf(buf, "AFF: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
  sprintbit(AFF2_FLAGS(k), affected_bits2, buf2);
  sprintf(buf, "AFF2: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
  sprintbit(AFF3_FLAGS(k), affected_bits3, buf2);
  sprintf(buf, "AFF3: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  if (IS_NPC(k))
    {
      send_to_char("Spells MEMMED:", ch);
      for (a = 0;a <= NUM_SPELL_CIRCLES - 4;a++)
	{
	  sprintf(buf, "%d/%d ", (GET_MEM_MEMED(k, a + 1)),
		  spells_of_circle[(int)GET_LEVEL(k)][(a + 1)]);
	  send_to_char(buf, ch);
	}
      send_to_char("\r\n", ch);
    }


  /* Routine to show what spells a char is affected by */
  if (k->affected) {
    for (aff = k->affected; aff; aff = aff->next) {
      *buf2 = '\0';
      if (aff->duration <  0)
        sprintf(buf, "SPL: (innate) %s%-21s%s ",
		CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));
      else
	sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
		CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));
      if (aff->modifier) {
	sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
	strcat(buf, buf2);
      }
      if (aff->bitvector) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector, affected_bits, buf2);
	strcat(buf, buf2);
      }
      if (aff->bitvector2) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector2, affected_bits2, buf2);
	strcat(buf, buf2);
      }
      if (aff->bitvector3) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector3, affected_bits3, buf2);
	strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch);
    }
  }
  /* check mobiles for a script */
  if (IS_NPC(k))
    do_sstat_character(ch, k);
}

ACMD(do_stat)
{
  struct char_data *victim = 0;
  struct obj_data *object = 0;
  struct char_file_u tmp_store;
  int tmp;

  half_chop(argument, buf1, buf2);

  if (!*buf1) {
    send_to_char("Stats on who or what?\r\n", ch);
    return;
  } else if (is_abbrev(buf1, "room")) {
    do_stat_room(ch);
  } else if (is_abbrev(buf1, "mob")) {
    if (!*buf2)
      send_to_char("Stats on which mobile?\r\n", ch);
    else {
      if ((victim = get_char_vis(ch, buf2)))
	do_stat_character(ch, victim);
      else
	send_to_char("No such mobile around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "player")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      if ((victim = get_player_vis(ch, buf2, 0)))
	do_stat_character(ch, victim);
      else
	send_to_char("No such player around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "file")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      if (load_char(buf2, &tmp_store) > -1) {
	store_to_char(&tmp_store, victim);
	if (GET_LEVEL(victim) > GET_LEVEL(ch))
	  send_to_char("Sorry, you can't do that.\r\n", ch);
	else
	  do_stat_character(ch, victim);
	free_char(victim);
      } else {
	send_to_char("There is no such player.\r\n", ch);
	free(victim);
      }
    }
  } else if (is_abbrev(buf1, "object")) {
    if (!*buf2)
      send_to_char("Stats on which object?\r\n", ch);
    else {
      if ((object = get_obj_vis(ch, buf2)))
	do_stat_object(ch, object);
      else
	send_to_char("No such object around.\r\n", ch);
    }
  } else {
    if ((object = get_object_in_equip_vis(ch, buf1, ch->equipment, &tmp)))
      do_stat_object(ch, object);
    else if ((object = get_obj_in_list_vis(ch, buf1, ch->carrying)))
      do_stat_object(ch, object);
    else if ((victim = get_char_room_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_in_list_vis(ch, buf1, world[ch->in_room].contents)))
      do_stat_object(ch, object);
    else if ((victim = get_char_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_vis(ch, buf1)))
      do_stat_object(ch, object);
    else
      send_to_char("Nothing around by that name.\r\n", ch);
  }
}


ACMD(do_shutdown)
{
  extern int circle_shutdown, circle_reboot;

  if (subcmd != SCMD_SHUTDOWN) {
    send_to_char("If you want to shut something down, say so!\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Shutting down.\r\n");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "reboot")) {
    /*do global save*/
    Crash_save_all();
    House_save_all();
    sprintf(buf, "(GC) Reboot by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Rebooting.. come back in a minute or two.\r\n"
 		"           ** ****** ****\r\n"
                "         ** ***     *****  **\r\n"
                "       ** **      *     ***  *\r\n"
                "       *    ** **   *   *  * **\r\n"
                "      *  ** * *          *     *\r\n"
                "      *  *    **            * * *\r\n"
                "     * * ** *     *   ******  *\r\n"
                "      *   * * **  ***     *  * *\r\n"
                "        *  *  * **********  *** *\r\n"
                "         *****   *     *   * * *\r\n"
                "                *   * *\r\n"
                "               *  * *  *\r\n"
                "              *  *  **  *\r\n"
                "              * **   * *\r\n"
                "                * * *\r\n"
                "                * *  **\r\n"
                "               **     ****\r\n"
                "              ***  * *    ****\r\n");
    touch("../.fastboot");
    circle_shutdown = circle_reboot = 1;
  } else if (!str_cmp(arg, "now")) {
    sprintf(buf, "(GC) Shutdown NOW by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Rebooting.. come back in a minute or two.\r\n"
 		"           ** ****** ****\r\n"
                "         ** ***     *****  **\r\n"
                "       ** **      *     ***  *\r\n"
                "       *    ** **   *   *  * **\r\n"
                "      *  ** * *          *     *\r\n"
                "      *  *    **            * * *\r\n"
                "     * * ** *     *   ******  *\r\n"
                "      *   * * **  ***     *  * *\r\n"
                "        *  *  * **********  *** *\r\n"
                "         *****   *     *   * * *\r\n"
                "                *   * *\r\n"
                "               *  * *  *\r\n"
                "              *  *  **  *\r\n"
                "              * **   * *\r\n"
                "                * * *\r\n"
                "                * *  **\r\n"
                "               **     ****\r\n"
                "              ***  * *    ****\r\n");
    circle_shutdown = 1;
    circle_reboot = 2;

  } else if (!str_cmp(arg, "die")) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Shutting down for maintenance.\r\n");
    touch("../.killscript");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "pause")) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Shutting down for maintenance.\r\n");
    touch("../pause");
    circle_shutdown = 1;
  } else
    send_to_char("Unknown shutdown option.\r\n", ch);
}


void stop_snooping(struct char_data * ch)
{
  if (!ch->desc->snooping)
    send_to_char("You aren't snooping anyone.\r\n", ch);
  else {
    send_to_char("You stop snooping.\r\n", ch);
    ch->desc->snooping->snoop_by = NULL;
    ch->desc->snooping = NULL;
  }
}


ACMD(do_snoop)
{
  struct char_data *victim, *tch;

  if (!ch->desc)
    return;

  one_argument(argument, arg);

  if (!*arg)
    stop_snooping(ch);
  else if (!(victim = get_char_vis(ch, arg)))
    send_to_char("No such person around.\r\n", ch);
  else if (!victim->desc)
    send_to_char("There's no link.. nothing to snoop.\r\n", ch);
  else if (victim == ch)
    stop_snooping(ch);
  else if (victim->desc->snoop_by)
    send_to_char("Busy already. \r\n", ch);
  else if (victim->desc->snooping == ch->desc)
    send_to_char("Don't be stupid.\r\n", ch);
  else {
    if (victim->desc->original)
      tch = victim->desc->original;
    else
      tch = victim;

    if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
      send_to_char("You can't.\r\n", ch);
      return;
    }
    send_to_char(OK, ch);

    if (ch->desc->snooping)
      ch->desc->snooping->snoop_by = NULL;

    ch->desc->snooping = victim->desc;
    victim->desc->snoop_by = ch->desc;
  }
}

ACMD(do_switch)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (ch->desc->original)
    send_to_char("You're already switched.\r\n", ch);
  else if (!*arg)
    send_to_char("Switch with who?\r\n", ch);
  else if (!(victim = get_char_vis(ch, arg)))
    send_to_char("No such character.\r\n", ch);
  else if (ch == victim)
    send_to_char("Hee hee... we are jolly funny today, eh?\r\n", ch);
  else if (victim->desc)
    send_to_char("You can't do that, the body is already in use!\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GRGOD) && !IS_NPC(victim))
    send_to_char("You aren't holy enough to use a mortal's body.\r\n", ch);
  else if ((GET_LEVEL(ch) < GET_LEVEL(victim)))
    send_to_char("You WISHED.\r\n",ch);
  else {
    send_to_char(OK, ch);

    ch->desc->character = victim;
    ch->desc->original = ch;

    victim->desc = ch->desc;
    ch->desc = NULL;
  }
}

ACMD(do_rename)
{
  int player_i;
  extern int top_of_p_table;
  extern struct player_index_element *player_table;
  struct char_file_u tmp_store;
  struct char_data *victim=NULL;
  char tmp_name[MAX_INPUT_LENGTH], arg1[MAX_INPUT_LENGTH],
    arg2[MAX_INPUT_LENGTH];
  extern struct char_data *is_playing(char *vict_name);
  extern save_char_file_u(struct char_file_u st);
  two_arguments(argument, arg1, arg2);

  if(!ch || IS_NPC(ch))
    return;

  if(!arg1 || !*arg1 || !arg2 || !*arg2){
    send_to_char("Usage: rename <player name> <new name>\r\n",ch);
    return;
  }

  if((victim=is_playing(arg1))) {
    if(GET_LEVEL(ch) <= GET_LEVEL(victim)) {
      send_to_char("You don't have permission to change that name.",ch);
      return;
    }
    if ((_parse_name(arg2, tmp_name)) || strlen(tmp_name) < 2 ||
	strlen(tmp_name) > MAX_NAME_LENGTH ||
	fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
      send_to_char("The new name is invalid.\r\n",ch);
      return;
    }
    if (!Valid_Name(tmp_name)) {
      send_to_char("The new name is invalid.\r\n",ch);
      return;
    }
    if ((player_i = load_char(tmp_name, &tmp_store)) > -1){
      send_to_char("There is already a player with that name.\r\n",ch);
      return;
    }
    sprintf(buf2,"&1&bYou have renamed &7%s&1 to &7%s&0\r\n",GET_NAME(victim),CAP(tmp_name));
    send_to_char(buf2, ch);
    sprintf(buf2, "%s has renamed %s to %s",GET_NAME(ch),GET_NAME(victim), tmp_name);
    mudlog(buf2,NRM,LVL_HEAD_C,TRUE);
    strcpy((player_table + GET_PFILEPOS(victim))->name,CAP(tmp_name));
    strcpy(victim->player.name, CAP(tmp_name));
    save_char(victim, NOWHERE);
    Crash_crashsave(victim);
    sprintf(buf2,"&1&b!!! You have been renamed to &7%s&1.&0\r\n",GET_NAME(victim));
    send_to_char(buf2, victim);
  }
  else {
    send_to_char("That players is not playing at the moment.\r\n",ch);
    /* possible rename if offline? this would be bad because player
       would not know how to log in again.*/
  }
}

ACMD(do_return)
{
  if (ch->desc && ch->desc->original) {
    send_to_char("You return to your original body.\r\n", ch);

    /* JE 2/22/95 */
    /* if someone switched into your original body, disconnect them */
    if (ch->desc->original->desc)
      close_socket(ch->desc->original->desc);

    ch->desc->character = ch->desc->original;
    ch->desc->original = NULL;

    ch->desc->character->desc = ch->desc;
    ch->desc = NULL;
  }
}



ACMD(do_load)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("Usage: load { obj | mob } <number>\r\n", ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, ch->in_room);

    act("$n makes a quaint, magical gesture with one hand.", TRUE, ch,
	0, 0, TO_ROOM);
    act("$n has created $N!", FALSE, ch, 0, mob, TO_ROOM);
    act("You create $N.", FALSE, ch, 0, mob, TO_CHAR);
    sprintf(buf, "(GC) %s loads mob,  %s", GET_NAME(ch), GET_NAME(mob));
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    /*obj_to_room(obj, ch->in_room);*/
    obj_to_char(obj, ch);
    act("$n makes a strange magical gesture.", TRUE, ch, 0, 0, TO_ROOM);
    act("$n has created $p!", FALSE, ch, obj, 0, TO_ROOM);
    act("You create $p.", FALSE, ch, obj, 0, TO_CHAR);
    sprintf(buf, "(GC) %s loads OBJ,  %s", GET_NAME(ch), (obj)->short_description);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}



ACMD(do_vstat)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("Usage: vstat { obj | mob } <number>\r\n", ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, 0);
    do_stat_character(ch, mob);
    extract_char(mob);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    do_stat_object(ch, obj);
    extract_obj(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}

ACMD(do_players)
{
  int i, count = 0;
  *buf = 0;

  for (i = 0; i <= top_of_p_table; i++) {
    sprintf(buf, "%s  %-20.20s", buf, (player_table + i)->name);
    count++;
    if (count == 3) {
      count = 0;
      strcat(buf, "\r\n");
    }
  }
  page_string(ch->desc, buf, 1);
}


/* clean a room of all mobiles and objects */
ACMD(do_purge)
{
  struct char_data *vict, *next_v;
  struct obj_data *obj, *next_o;

  one_argument(argument, buf);

  if (*buf) {			/* argument supplied. destroy single object
				 * or char */
    if ((vict = get_char_room_vis(ch, buf))) {
      if (!IS_NPC(vict) && (GET_LEVEL(ch) <= GET_LEVEL(vict)) && (GET_LEVEL(ch) >= LVL_HEAD_B)) {
	send_to_char("Fuuuuuuuuu!\r\n", ch);
	return;
      }
      act("$n disintegrates $N.", FALSE, ch, 0, vict, TO_NOTVICT);

      if (!IS_NPC(vict)) {
	sprintf(buf, "(GC) %s has purged %s.", GET_NAME(ch), GET_NAME(vict));
	mudlog(buf, BRF, LVL_GOD, TRUE);
	if (vict->desc) {
	  close_socket(vict->desc);
	  vict->desc = NULL;
	}
      }
      extract_char(vict);
    } else if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
      act("$n destroys $p.", FALSE, ch, obj, 0, TO_ROOM);
      extract_obj(obj);
    } else {
      send_to_char("Nothing here by that name.\r\n", ch);
      return;
    }

    send_to_char(OK, ch);
  } else {			/* no argument. clean out the room */
    act("$n gestures... You are surrounded by scorching flames!",
	FALSE, ch, 0, 0, TO_ROOM);
    send_to_room("The world seems a little cleaner.\r\n", ch->in_room);

    for (vict = world[ch->in_room].people; vict; vict = next_v) {
      next_v = vict->next_in_room;
      if (IS_NPC(vict))
	extract_char(vict);
    }

    for (obj = world[ch->in_room].contents; obj; obj = next_o) {
      next_o = obj->next_content;
      extract_obj(obj);
    }
  }
}

ACMD(do_advance)
{
  struct char_data *victim;
  char *name = arg, *level = buf2;
  int newlevel, oldlevel;
  void do_start(struct char_data *ch);
  long exp_to_level(int, int);
  void gain_exp(struct char_data * ch, int gain);

  two_arguments(argument, name, level);

  if (*name) {
    if (!(victim = get_char_vis(ch, name))) {
      send_to_char("That player is not here.\r\n", ch);
      return;
    }
  } else {
    send_to_char("Advance who?\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) <= GET_LEVEL(victim)) {
    send_to_char("Maybe that's not such a great idea.\r\n", ch);
    return;
  }
  if (IS_NPC(victim)) {
    send_to_char("NO!  Not on NPC's.\r\n", ch);
    return;
  }
  if (!*level || (newlevel = atoi(level)) <= 0) {
    send_to_char("That's not a level!\r\n", ch);
    return;
  }
  if (newlevel > LVL_IMPL) {
    sprintf(buf, "%d is the highest possible level.\r\n", LVL_IMPL);
    send_to_char(buf, ch);
    return;
  }


  if (newlevel > GET_LEVEL(ch)) {
    send_to_char("Yeah, right.\r\n", ch);
    return;
  }
  if (newlevel == GET_LEVEL(victim)) {
    send_to_char("They are already at that level.\r\n", ch);
    return;
  }
  oldlevel = GET_LEVEL(victim);
  if (newlevel < GET_LEVEL(victim)) {
    do_start(victim);
    send_to_char("&0&9&bYou are momentarily enveloped by darkness!&0\r\n"
		 "&0&9&bYou feel somewhat diminished.&0\r\n", victim);
  } else {
    act("$n makes some strange gestures.\r\n"
	"A strange feeling comes upon you,\r\n"
	"Like a giant hand, light comes down\r\n"
	"from above, grabbing your body, that\r\n"
	"begins to pulse with colored lights\r\n"
	"from inside.\r\n\r\n"
	"Your head seems to be filled with demons\r\n"
	"from another plane as your body dissolves\r\n"
	"to the elements of time and space itself.\r\n"
	"Suddenly a silent explosion of light\r\n"
	"snaps you back to reality.\r\n\r\n"
	"You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
  }

  send_to_char(OK, ch);

  sprintf(buf, "(GC) %s has advanced %s to level %d (from %d)",
	  GET_NAME(ch), GET_NAME(victim), newlevel, oldlevel);
  log(buf);

  gain_exp_regardless(victim, (exp_to_level((newlevel - 1), GET_CLASS(victim)) - GET_EXP(victim) + 1));
  save_char(victim, NOWHERE);
}




ACMD(do_restore)
{
  struct char_data *vict;
  int i;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to restore?\r\n", ch);
  else if (!(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else {
    GET_HIT(vict) = GET_MAX_HIT(vict);
    GET_MANA(vict) = GET_MAX_MANA(vict);
    GET_MOVE(vict) = GET_MAX_MOVE(vict);

    if ((GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_IMMORT)) {
      for (i = 1; i <= MAX_SKILLS; i++)
	SET_SKILL(vict, i, 1000);

      vict->aff_abils = vict->real_abils;
    }
    update_pos(vict);
    send_to_char(OK, ch);
    act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
  }
}


void perform_immort_vis(struct char_data *ch)
{
  void appear(struct char_data *ch);

  if (GET_INVIS_LEV(ch) == 0 && !IS_AFFECTED(ch, AFF_HIDE | AFF_INVISIBLE)) {
    send_to_char("You are already fully visible.\r\n", ch);
    return;
  }

  GET_INVIS_LEV(ch) = 0;
  appear(ch);
  send_to_char("You are now fully visible.\r\n", ch);
}


void perform_immort_invis(struct char_data *ch, int level)
{
  struct char_data *tch;

  if (IS_NPC(ch))
    return;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (tch == ch)
      continue;
    if (GET_LEVEL(tch) >= GET_INVIS_LEV(ch) && GET_LEVEL(tch) < level)
      act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0,
	  tch, TO_VICT);
    if (GET_LEVEL(tch) < GET_INVIS_LEV(ch) && GET_LEVEL(tch) >= level)
      act("You suddenly realize that $n is standing beside you.", FALSE, ch, 0,
	  tch, TO_VICT);
  }

  GET_INVIS_LEV(ch) = level;
  sprintf(buf, "Your invisibility level is %d.\r\n", level);
  send_to_char(buf, ch);
}


ACMD(do_invis)
{
  int level;

  if (IS_NPC(ch)) {
    send_to_char("You can't do that!\r\n", ch);
    return;
  }

  one_argument(argument, arg);
  if (!*arg) {
    if (GET_INVIS_LEV(ch) > 0)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, GET_LEVEL(ch));
  } else {
    level = atoi(arg);
    if (level > GET_LEVEL(ch))
      send_to_char("You can't go invisible above your own level.\r\n", ch);
    else if (level < 1)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, level);
  }
}


ACMD(do_gecho)
{
  struct descriptor_data *pt;

  skip_spaces(&argument);

  if (!*argument)
    send_to_char("That must be a mistake...\r\n", ch);
  else {
    sprintf(buf, "%s&0\r\n", argument);
    for (pt = descriptor_list; pt; pt = pt->next)
      if (!pt->connected && pt->character && pt->character != ch)
	send_to_char(buf, pt->character);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      send_to_char(buf, ch);
  }
}


ACMD(do_poofset)
{
  char **msg;

  switch (subcmd) {
  case SCMD_POOFIN:    msg = &(POOFIN(ch));    break;
  case SCMD_POOFOUT:   msg = &(POOFOUT(ch));   break;
  default:    return;    break;
  }

  skip_spaces(&argument);

  if (*msg)
    free(*msg);

  if (!*argument)
    *msg = NULL;
  else
    *msg = str_dup(argument);

  send_to_char(OK, ch);
}



ACMD(do_dc)
{
  struct descriptor_data *d;
  int num_to_dc;

  one_argument(argument, arg);
  if (!(num_to_dc = atoi(arg))) {
    send_to_char("Usage: DC <connection number> (type USERS for a list)\r\n", ch);
    return;
  }
  for (d = descriptor_list; d && d->desc_num != num_to_dc; d = d->next);

  if (!d) {
    send_to_char("No such connection.\r\n", ch);
    return;
  }
  if (d->character && GET_LEVEL(d->character) >= GET_LEVEL(ch)) {
    send_to_char("Umm.. maybe that's not such a good idea...\r\n", ch);
    return;
  }
  close_socket(d);
  sprintf(buf, "Connection #%d closed.\r\n", num_to_dc);
  send_to_char(buf, ch);
  sprintf(buf, "(GC) Connection closed by %s.", GET_NAME(ch));
  log(buf);
}



ACMD(do_wizlock)
{
  int value;
  char *when;

  one_argument(argument, arg);
  if (*arg) {
    value = atoi(arg);
    if (value < 0 || value > GET_LEVEL(ch)) {
      send_to_char("Invalid wizlock value.\r\n", ch);
      return;
    }
    restrict = value;
    when = "now";
  } else
    when = "currently";

  switch (restrict) {
  case 0:
    sprintf(buf, "The game is %s completely open.\r\n", when);
    break;
  case 1:
    sprintf(buf, "The game is %s closed to new players.\r\n", when);
    break;
  default:
    sprintf(buf, "Only level %d and above may enter the game %s.\r\n",
	    restrict, when);
    break;
  }
  send_to_char(buf, ch);
}


ACMD(do_date)
{
  char *tmstr;
  time_t mytime;
  int d, h, m;
  extern time_t boot_time;

  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
    mytime = boot_time;

  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  if (subcmd == SCMD_DATE)
    sprintf(buf, "Current machine time: %s\r\n", tmstr);
  else {
    mytime = time(0) - boot_time;
    d = mytime / 86400;
    h = (mytime / 3600) % 24;
    m = (mytime / 60) % 60;

    sprintf(buf, "Up since %s: %d day%s, %d:%02d\r\n", tmstr, d,
	    ((d == 1) ? "" : "s"), h, m);
  }

  send_to_char(buf, ch);
}



ACMD(do_last)
{
  struct char_file_u chdata;
  extern char *class_abbrevs[];

  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("For whom do you wish to search?\r\n", ch);
    return;
  }
  if (load_char(arg, &chdata) < 0) {
    send_to_char("There is no such player.\r\n", ch);
    return;
  }
  if ((chdata.level > GET_LEVEL(ch)) && (GET_LEVEL(ch) < LVL_HEAD_B)) {
    send_to_char("You are not sufficiently godly for that!\r\n", ch);
    return;
  }
  sprintf(buf, "[%5ld] [%2d %s] %-12s : %-18s : %-20s\r\n",
	  chdata.char_specials_saved.idnum, (int) chdata.level,
	  class_abbrevs[(int) chdata.class], chdata.name, chdata.host,
	  ctime(&chdata.last_logon));
  send_to_char(buf, ch);
}


ACMD(do_force)
{
  struct descriptor_data *i, *next_desc;
  struct char_data *vict, *next_force;
  char to_force[MAX_INPUT_LENGTH + 2];

  half_chop(argument, arg, to_force);

  sprintf(buf1, "$n has forced you to '%s'.", to_force);

  if (!*arg || !*to_force)
    send_to_char("Whom do you wish to force do what?\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GRGOD) || (str_cmp("all", arg) && str_cmp("room", arg))) {
    if (!(vict = get_char_vis(ch, arg)))
      send_to_char(NOPERSON, ch);
    else if (GET_LEVEL(ch) <= GET_LEVEL(vict))
      send_to_char("No, no, no!\r\n", ch);
    else {
      send_to_char(OK, ch);
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      sprintf(buf, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      command_interpreter(vict, to_force);
    }
  } else if (!str_cmp("room", arg)) {
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced room %d to %s", GET_NAME(ch), world[ch->in_room].number, to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (vict = world[ch->in_room].people; vict; vict = next_force) {
      next_force = vict->next_in_room;
      if (GET_LEVEL(vict) >= GET_LEVEL(ch))
	continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  } else { /* force all */
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced all to %s", GET_NAME(ch), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (i = descriptor_list; i; i = next_desc) {
      next_desc = i->next;

      if (i->connected || !(vict = i->character) || GET_LEVEL(vict) >= GET_LEVEL(ch))
	continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  }
}



ACMD(do_wiznet)
{
  struct descriptor_data *d;
  char emote = FALSE;
  char any = FALSE;
  int level = LVL_IMMORT;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument) {
    send_to_char("Usage: wiznet <text> | #<level> <text> | *<emotetext> |\r\n "
		 "       wiznet @@<level> *<emotetext> | wiz @@\r\n", ch);
    return;
  }
  switch (*argument) {
  case '*':
    emote = TRUE;
  case '#':
    one_argument(argument + 1, buf1);
    if (is_number(buf1)) {
      half_chop(argument+1, buf1, argument);
      level = MAX(atoi(buf1), LVL_IMMORT);
      if (level > GET_LEVEL(ch)) {
	send_to_char("You can't wizline above your own level.\r\n", ch);
	return;
      }
    } else if (emote)
      argument++;
    break;
  case '@@':
    for (d = descriptor_list; d; d = d->next) {
      if (!d->connected && GET_LEVEL(d->character) >= LVL_IMMORT &&
	  !PRF_FLAGGED(d->character, PRF_NOWIZ) &&
	  (CAN_SEE(ch, d->character) || GET_LEVEL(ch) == LVL_IMPL)) {
	if (!any) {
	  sprintf(buf1, "Gods online:\r\n");
	  any = TRUE;
	}
	sprintf(buf1, "%s  %s", buf1, GET_NAME(d->character));
	if (PLR_FLAGGED(d->character, PLR_WRITING))
	  sprintf(buf1, "%s (Writing)\r\n", buf1);
	else if (PLR_FLAGGED(d->character, PLR_MAILING))
	  sprintf(buf1, "%s (Writing mail)\r\n", buf1);
	else
	  sprintf(buf1, "%s\r\n", buf1);

      }
    }
    any = FALSE;
    for (d = descriptor_list; d; d = d->next) {
      if (!d->connected && GET_LEVEL(d->character) >= LVL_IMMORT &&
	  PRF_FLAGGED(d->character, PRF_NOWIZ) &&
	  CAN_SEE(ch, d->character)) {
	if (!any) {
	  sprintf(buf1, "%sGods offline:\r\n", buf1);
	  any = TRUE;
	}
	sprintf(buf1, "%s  %s\r\n", buf1, GET_NAME(d->character));
      }
    }
    send_to_char(buf1, ch);
    return;
    break;
  case '\\':
    ++argument;
    break;
  default:
    break;
  }
  if (PRF_FLAGGED(ch, PRF_NOWIZ)) {
    send_to_char("You are offline!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Don't bother the gods like that!\r\n", ch);
    return;
  }
  if (level > LVL_IMMORT) {
    sprintf(buf1, "&6%s: <%d> %s%s&0\r\n", GET_NAME(ch), level,
	    emote ? "<--- " : "", argument);
    sprintf(buf2, "&6Someone: <%d> %s%s&0\r\n", level, emote ? "<--- " : "",
	    argument);
  } else {
    sprintf(buf1, "&6%s: %s%s&0\r\n", GET_NAME(ch), emote ? "<--- " : "",
	    argument);
    sprintf(buf2, "&6Someone: %s%s&0\r\n", emote ? "<--- " : "", argument);
  }

  for (d = descriptor_list; d; d = d->next) {
    if ((!d->connected) && (GET_LEVEL(d->character) >= level) &&
	(!PRF_FLAGGED(d->character, PRF_NOWIZ)) &&
	(!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
	&& (d != ch->desc || !(PRF_FLAGGED(d->character, PRF_NOREPEAT)))) {
      if (CAN_SEE(d->character, ch))
	send_to_char(buf1, d->character);
      else
	send_to_char(buf2, d->character);
    }
  }

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
}



ACMD(do_zreset)
{
  void reset_zone(int zone, byte pop);

  int i, j;


  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("You must specify a zone.\r\n", ch);
    return;
  }
  if (*arg == '*') {
      if (GET_LEVEL(ch) <= LVL_HEAD_B)
	  return;
	  for (i = 0; i <= top_of_zone_table; i++)
      reset_zone(i, FALSE);
    send_to_char("Reset world.\r\n", ch);
    sprintf(buf, "(GC) %s reset entire world.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
    return;
  } else if (*arg == '.')
    i = world[ch->in_room].zone;
  else {
    j = atoi(arg);
    for (i = 0; i <= top_of_zone_table; i++)
      if (zone_table[i].number == j)
	break;
  }
  if ((GET_LEVEL(ch) < LVL_GRGOD) &&
      (!((zone_table[i].number == GET_OLC_ZONE(ch)) || (zone_table[i].number == GET_OLC2_ZONE(ch))
	  || (zone_table[i].number == GET_OLC3_ZONE(ch))  || (zone_table[i].number == GET_OLC4_ZONE(ch)) ||
	  (zone_table[i].number == GET_OLC5_ZONE(ch))))) {
   send_to_char("Testing testing !!are you clear to do this!! no I dont think so\r\n", ch);
  return;
  }
  if (i >= 0 && i <= top_of_zone_table) {
    reset_zone(i, FALSE);
    sprintf(buf, "Reset zone %d (#%d): %s.\r\n", i, zone_table[i].number,
	    zone_table[i].name);
    send_to_char(buf, ch);
    sprintf(buf, "(GC) %s reset zone %d (%s)", GET_NAME(ch), zone_table[i].number, zone_table[i].name);
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("Invalid zone number.\r\n", ch);
}


/*
 *  General fn for wizcommands of the sort: cmd <player>
 */

ACMD(do_wizutil)
{
  struct char_data *vict;
  long result;
  void roll_real_abils(struct char_data *ch);

  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Yes, but for whom?!?\r\n", ch);
  else if (!(vict = get_char_vis(ch, arg)))
    send_to_char("There is no such player.\r\n", ch);
  else if (IS_NPC(vict))
    send_to_char("You can't do that to a mob!\r\n", ch);
  else if (GET_LEVEL(vict) > GET_LEVEL(ch))
    send_to_char("Hmmm...you'd better not.\r\n", ch);
  else {
    switch (subcmd) {
    case SCMD_REROLL:
      send_to_char("Rerolled not functinal for now\r\n", ch);
break;
      /*sprintf(buf, "(GC) %s has rerolled %s.", GET_NAME(ch), GET_NAME(vict));
      log(buf);
      sprintf(buf, "New stats: Str %d/%d, Int %d, Wis %d, Dex %d, Con %d, Cha %d\r\n",
	      GET_STR(vict), GET_ADD(vict), GET_INT(vict), GET_WIS(vict),
	      GET_DEX(vict), GET_CON(vict), GET_CHA(vict));
      send_to_char(buf, ch);
      break;*/
    case SCMD_PARDON:
      if (!PLR_FLAGGED(vict, PLR_THIEF | PLR_KILLER)) {
	send_to_char("Your victim is not flagged.\r\n", ch);
	return;
      }
      REMOVE_BIT(PLR_FLAGS(vict), PLR_THIEF | PLR_KILLER);
      send_to_char("Pardoned.\r\n", ch);
      send_to_char("You have been pardoned by the Gods!\r\n", vict);
      sprintf(buf, "(GC) %s pardoned by %s", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_NOTITLE:
      result = PLR_TOG_CHK(vict, PLR_NOTITLE);
      sprintf(buf, "(GC) Notitle %s for %s by %s.", ONOFF(result),
	      GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case SCMD_SQUELCH:
      result = PLR_TOG_CHK(vict, PLR_NOSHOUT);
      sprintf(buf, "(GC) Squelch %s for %s by %s.", ONOFF(result),
	      GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case SCMD_FREEZE:
      if (ch == vict) {
	send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
	return;
      }
      if (PLR_FLAGGED(vict, PLR_FROZEN)) {
	send_to_char("Your victim is already pretty cold.\r\n", ch);
	return;
      }
      SET_BIT(PLR_FLAGS(vict), PLR_FROZEN);
      GET_FREEZE_LEV(vict) = GET_LEVEL(ch);
      send_to_char("A bitter wind suddenly rises and drains every erg of heat from your body!\r\nYou feel frozen!\r\n", vict);
      send_to_char("Frozen.\r\n", ch);
      act("A sudden cold wind conjured from nowhere freezes $n!", FALSE, vict, 0, 0, TO_ROOM);
      sprintf(buf, "(GC) %s frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_THAW:
      if (!PLR_FLAGGED(vict, PLR_FROZEN)) {
	send_to_char("Sorry, your victim is not morbidly encased in ice at the moment.\r\n", ch);
	return;
      }
      if (GET_FREEZE_LEV(vict) > GET_LEVEL(ch)) {
	sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n",
	   GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
	send_to_char(buf, ch);
	return;
      }
      sprintf(buf, "(GC) %s un-frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      REMOVE_BIT(PLR_FLAGS(vict), PLR_FROZEN);
      send_to_char("A fireball suddenly explodes in front of you, melting the ice!\r\nYou feel thawed.\r\n", vict);
      send_to_char("Thawed.\r\n", ch);
      act("A sudden fireball conjured from nowhere thaws $n!", FALSE, vict, 0, 0, TO_ROOM);
      break;
    case SCMD_UNAFFECT:
      if (vict->affected) {
	while (vict->affected)
	  affect_remove(vict, vict->affected);
	send_to_char("There is a brief flash of light!\r\n"
		     "You feel slightly different.\r\n", vict);
	send_to_char("All spells removed.\r\n", ch);
	check_regen_rates(vict);
      } else {
	send_to_char("Your victim does not have any affections!\r\n", ch);
	return;
      }
      break;
    default:
      log("SYSERR: Unknown subcmd passed to do_wizutil (act.wizard.c)");
      break;
    }
    save_char(vict, NOWHERE);
  }
}


/* single zone printing fn used by "show zone" so it's not repeated in the
   code 3 times ... -je, 4/6/93 */

void print_zone_to_buf(char *bufptr, int zone)
{
  sprintf(bufptr, "%s%3d %-30.30s Age: %3d; Reset: %3d (%1d); ZF:%d: Top: %5d\r\n",
	  bufptr, zone_table[zone].number, zone_table[zone].name,
	  zone_table[zone].age, zone_table[zone].lifespan,
	  zone_table[zone].reset_mode, zone_table[zone].zone_factor, zone_table[zone].top);
}


ACMD(do_show)
{
  struct char_file_u vbuf;
  int i, j, k, l, con;
  char self = 0;
  struct char_data *vict;
  struct obj_data *obj;
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH], birth[80];
  extern char *class_abbrevs[];
  extern char *genders[];
  extern int buf_switches, buf_largecount, buf_overflows;
  void show_shops(struct char_data * ch, char *value);
  void hcontrol_list_houses(struct char_data *ch);

  struct show_struct {
    char *cmd;
    char level;
  } fields[] = {
    { "nothing",	0  },				/* 0 */
    { "zones",		LVL_IMMORT },			/* 1 */
    { "player",		LVL_GOD },
    { "rent",		LVL_GOD },
    { "stats",		LVL_IMMORT },
    { "errors",		LVL_GRGOD },			/* 5 */
    { "death",		LVL_GOD },
    { "godrooms",	LVL_GOD },
    { "shops",		LVL_IMMORT },
    { "houses",		LVL_GOD },
    { "\n", 0 }
  };

  skip_spaces(&argument);

  if (!*argument) {
    strcpy(buf, "Show options:\r\n");
    for (j = 0, i = 1; fields[i].level; i++)
      if (fields[i].level <= GET_LEVEL(ch))
	sprintf(buf, "%s%-15s%s", buf, fields[i].cmd, (!(++j % 5) ? "\r\n" : ""));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }

  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  if (!strcmp(value, "."))
    self = 1;
  buf[0] = '\0';
  switch (l) {
  case 1:			/* zone */
    /* tightened up by JE 4/6/93 */
    if (self)
      print_zone_to_buf(buf, world[ch->in_room].zone);
    else if (*value && is_number(value)) {
      for (j = atoi(value), i = 0; zone_table[i].number != j && i <= top_of_zone_table; i++);
      if (i <= top_of_zone_table)
	print_zone_to_buf(buf, i);
      else {
	send_to_char("That is not a valid zone.\r\n", ch);
	return;
      }
    } else
      for (i = 0; i <= top_of_zone_table; i++)
	print_zone_to_buf(buf, i);
    send_to_char(buf, ch);
    break;
  case 2:			/* player */
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
      return;
    }

    if (load_char(value, &vbuf) < 0) {
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
    sprintf(buf, "Player: %-12s (%s) [%2d %s]\r\n", vbuf.name,
      genders[(int) vbuf.sex], vbuf.level, class_abbrevs[(int) vbuf.class]);
    sprintf(buf, "%sCoins held: [%dp / %dg / %ds / %dc]\r\nCoins banked: [%ldp / %ldg / %lds / %ldc]\r\n  Exp: %-8ld  Align: %-5d  Lessons: %-3d\r\n",	    buf, vbuf.points.coins.plat, vbuf.points.coins.gold, vbuf.points.coins.silver,
		vbuf.points.coins.copper, vbuf.points.coins.bank_plat, vbuf.points.coins.bank_gold,
		vbuf.points.coins.bank_silver, vbuf.points.coins.bank_copper, vbuf.points.exp,
	    vbuf.char_specials_saved.alignment,
	    vbuf.player_specials_saved.spells_to_learn);
    strcpy(birth, ctime(&vbuf.birth));
   sprintf(buf,
	    "%sStarted: %-20.16s  Last: %-20.16s  Played: %3dh %2dm\r\n",
	    buf, birth, ctime(&vbuf.last_logon), (int) (vbuf.played / 3600),
	    (int) (vbuf.played / 60 % 60));
    send_to_char(buf, ch);
    break;
  case 3:
    Crash_listrent(ch, value);
    break;
  case 4:
    i = 0;
    j = 0;
    k = 0;
    con = 0;
    for (vict = character_list; vict; vict = vict->next) {
      if (IS_NPC(vict))
	j++;
      else if (CAN_SEE(ch, vict)) {
	i++;
	if (vict->desc)
	  con++;
      }
    }
    for (obj = object_list; obj; obj = obj->next)
      k++;
    sprintf(buf, "Current stats:\r\n");
    sprintf(buf, "%s  %5d players in game  %5d connected\r\n", buf, i, con);
    sprintf(buf, "%s  %5d registered\r\n", buf, top_of_p_table + 1);
    sprintf(buf, "%s  %5d mobiles          %5d prototypes\r\n",
	    buf, j, top_of_mobt + 1);
    sprintf(buf, "%s  %5d objects          %5d prototypes\r\n",
	    buf, k, top_of_objt + 1);
    sprintf(buf, "%s  %5d rooms            %5d zones\r\n",
	    buf, top_of_world + 1, top_of_zone_table + 1);
    sprintf(buf, "%s  %5d large bufs\r\n", buf, buf_largecount);
    sprintf(buf, "%s  %5d buf switches     %5d overflows\r\n", buf,
	    buf_switches, buf_overflows);
    send_to_char(buf, ch);
    break;
  case 5:
    strcpy(buf, "Errant Rooms\r\n------------\r\n");
    for (i = 0, k = 0; i <= top_of_world; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
	if (world[i].dir_option[j] && world[i].dir_option[j]->to_room == 0)
	  sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, ++k, world[i].number,
		  world[i].name);
    send_to_char(buf, ch);
    break;
  case 6:
    strcpy(buf, "Death Traps\r\n-----------\r\n");
    for (i = 0, j = 0; i <= top_of_world; i++)
      if (IS_SET(ROOM_FLAGS(i), ROOM_DEATH))
	sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, ++j,
		world[i].number, world[i].name);
    send_to_char(buf, ch);
    break;
  case 7:
#define GOD_ROOMS_ZONE 2
    strcpy(buf, "Godrooms\r\n--------------------------\r\n");
    for (i = 0, j = 0; i < top_of_world; i++)
      if (world[i].zone == GOD_ROOMS_ZONE)
	sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, j++, world[i].number,
		world[i].name);
    send_to_char(buf, ch);
    break;
  case 8:
    show_shops(ch, value);
    break;
  case 9:
    hcontrol_list_houses(ch);
    break;
  default:
    send_to_char("Sorry, I don't understand that.\r\n", ch);
    break;
  }
}


#define PC   1
#define NPC  2
#define BOTH 3

#define MISC	0
#define BINARY	1
#define NUMBER	2

#define SET_OR_REMOVE(flagset, flags) { \
	if (on) SET_BIT(flagset, flags); \
	else if (off) REMOVE_BIT(flagset, flags); }

#define RANGE(low, high) (value = MAX((low), MIN((high), (value))))

ACMD(do_set)
{
  int i, l;
  struct char_data *vict = NULL, *cbuf = NULL;
  struct char_file_u tmp_store;
  char field[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH], val_arg[MAX_INPUT_LENGTH];
  int on = 0, off = 0, value = 0;
  char is_file = 0, is_mob = 0, is_player = 0;
  int player_i = 0;
  int get_race_align(struct char_data *ch);
  int parse_class(struct char_data *ch, char arg);
  int parse_race(char arg);
  int parse_diety(struct char_data *ch, char arg);
  void load_results(struct char_data * ch);

  struct set_struct {
    char *cmd;
    char level;
    char pcnpc;
    char type;
  }          fields[] = {
   { "brief",		LVL_GOD, 	PC, 	BINARY },  /* 0 */
   { "invstart", 	LVL_GOD, 	PC, 	BINARY },  /* 1 */
   { "title",		LVL_GOD, 	PC, 	MISC },
   { "nosummon", 	LVL_GRGOD, 	PC, 	BINARY },
   { "maxhit",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "maxmana", 	LVL_GRGOD, 	BOTH, 	NUMBER },  /* 5 */
   { "maxmove", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hit", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "mana",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "move",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "align",		LVL_GOD, 	BOTH, 	NUMBER },  /* 10 */
   { "str",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "stradd",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "int", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "wis", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "dex", 		LVL_GRGOD, 	BOTH, 	NUMBER },  /* 15 */
   { "con", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC },
   { "ac", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "olc",     LVL_HEAD_B,   PC,     NUMBER},
   { "home",	LVL_GOD,	PC,		NUMBER},
   { "exp", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hitroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "damroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "invis",		LVL_HEAD_B,	PC, 	NUMBER },
   { "nohassle", 	LVL_GRGOD, 	PC, 	BINARY },  /* 25 */
   { "frozen",		LVL_FREEZE, 	PC, 	BINARY },
   { "practices", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "lessons", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC },
   { "hunger",		LVL_GOD, 	BOTH, 	MISC },    /* 30 */
   { "thirst",		LVL_GOD, 	BOTH, 	MISC },
   { "killer",		LVL_GOD, 	PC, 	BINARY },
   { "thief",		LVL_GOD, 	PC, 	BINARY },
   { "level",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "room",		LVL_BUILDER, 	BOTH, 	NUMBER },  /* 35 */
   { "roomflag", 	LVL_GRGOD, 	PC, 	BINARY },
   { "siteok",		LVL_GRGOD, 	PC, 	BINARY },
   { "deleted", 	LVL_IMPL, 	PC, 	BINARY },
   { "class",		LVL_GRGOD, 	BOTH, 	MISC },
   { "nowizlist", 	LVL_GOD, 	PC, 	BINARY },  /* 40 */
   { "quest",		LVL_GOD, 	PC, 	BINARY },
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC },
   { "color",		LVL_GOD, 	PC, 	BINARY },
   { "idnum",		LVL_HEAD_B, 	PC, 	NUMBER },
   { "passwd",		LVL_HEAD_C, 	PC, 	MISC },    /* 45 */
   { "nodelete", 	LVL_GOD, 	PC, 	BINARY },
   { "cha",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "race",    LVL_GRGOD,  PC,     MISC },
   { "olc2",     LVL_HEAD_B,   PC,     NUMBER},
   { "olc3",     LVL_HEAD_B,   PC,     NUMBER},/*50*/
   { "olc4",     LVL_HEAD_B,   PC,     NUMBER},
   { "olc5",     LVL_HEAD_B,   PC,     NUMBER},
   { "plat",		LVL_GOD, 	BOTH, 	NUMBER },
   { "gold",		LVL_GOD, 	BOTH, 	NUMBER },
   { "silver",		LVL_GOD, 	BOTH, 	NUMBER },	 /*55*/
   { "copper",		LVL_GOD, 	BOTH, 	NUMBER },
   { "pbank",		LVL_GOD, 	PC, 	NUMBER },
   { "gbank",		LVL_GOD, 	PC, 	NUMBER },
   { "sbank",		LVL_GOD, 	PC, 	NUMBER },
   { "cbank",		LVL_GOD, 	PC, 	NUMBER },	 /*60*/
   { "diety",   LVL_GOD,        PC,      NUMBER },
   { "frag",   LVL_HEAD_B,        PC,      NUMBER },
   { "\n", 0, BOTH, MISC }
  };

  half_chop(argument, name, buf);
  if (!strcmp(name, "file")) {
    is_file = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "player")) {
    is_player = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "mob")) {
    is_mob = 1;
    half_chop(buf, name, buf);
  }
  half_chop(buf, field, buf);
  strcpy(val_arg, buf);

  if (!*name || !*field) {
    *buf2 = 0;
    send_to_char("Usage: set <victim> <field> <value>\r\n", ch);
    send_to_char("Set fields currently available to you:\r\n", ch);
    for (l = 0; *(fields[l].cmd) != '\n'; l++) {
      if (fields[l].level <= GET_LEVEL(ch)) {
	sprintf(buf2, "%s%-20.20s %-20.20s %-6.6s\r\n", buf2, fields[l].cmd,
	  (fields[l].pcnpc==PC?"Player Only":"Player or Mob"),
	  (fields[l].type==BINARY?"Binary":(fields[l].type==NUMBER?"Number":
	  "Misc")));
      }
    }
    page_string(ch->desc, buf2, 1);
    return;
  }
  if (!is_file) {
    if (is_player) {
      if (!(vict = get_player_vis(ch, name, 0))) {
	send_to_char("There is no such player.\r\n", ch);
	return;
      }
    } else {
      if (!(vict = get_char_vis(ch, name))) {
	send_to_char("There is no such creature.\r\n", ch);
	return;
      }
    }
  } else if (is_file) {
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    if ((player_i = load_char(name, &tmp_store)) > -1) {
      store_to_char(&tmp_store, cbuf);
      if (GET_LEVEL(cbuf) >= GET_LEVEL(ch)) {
	free_char(cbuf);
	send_to_char("Sorry, you can't do that.\r\n", ch);
	return;
      }
      vict = cbuf;
    } else {
      free(cbuf);
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
  }
  if (GET_LEVEL(ch) != LVL_HEAD_C) {
    if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict) && vict != ch) {
      send_to_char("Maybe that's not such a great idea...\r\n", ch);
      return;
    }
  }
  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  if (IS_NPC(vict) && !(fields[l].pcnpc & NPC)) {
    send_to_char("You can't do that to a beast!\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && !(fields[l].pcnpc & PC)) {
    send_to_char("That can only be done to a beast!\r\n", ch);
    return;
  }
  if (fields[l].type == BINARY) {
    if (!strcmp(val_arg, "on") || !strcmp(val_arg, "yes"))
      on = 1;
    else if (!strcmp(val_arg, "off") || !strcmp(val_arg, "no"))
      off = 1;
    if (!(on || off)) {
      send_to_char("Value must be on or off.\r\n", ch);
      return;
    }
  } else if (fields[l].type == NUMBER) {
    value = atoi(val_arg);
  }

  strcpy(buf, "Okay.");  /* can't use OK macro here 'cause of \r\n */
  switch (l) {
  case 0:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_BRIEF);
    break;
  case 1:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_INVSTART);
    break;
  case 2:
    if ( GET_LEVEL(ch) < 75)
    {
       send_to_char("You aren't high enough to give out titles!\r\n", ch);
       return;
    }
    set_title(vict, val_arg);
    sprintf(buf, "%s's title is now: %s", GET_NAME(vict), GET_TITLE(vict));
    break;
  case 3:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_SUMMONABLE);
    on = !on;			/* so output will be correct */
    break;
  case 4:
    vict->points.max_hit = RANGE(1, 500000);
    GET_NATHPS(vict) = vict->points.max_hit;
    affect_total(vict);
    /*con_aff(vict);*/
    break;
  case 5:
    vict->points.max_mana = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 6:
    vict->points.max_move = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 7:
    vict->points.hit = RANGE(-9, vict->points.max_hit);
    affect_total(vict);
    break;
  case 8:
    vict->points.mana = RANGE(0, vict->points.max_mana);
    affect_total(vict);
    break;
  case 9:
    vict->points.move = RANGE(0, vict->points.max_move);
    affect_total(vict);
    break;
  case 10:
    GET_ALIGNMENT(vict) = RANGE(-1000, 1000);
    affect_total(vict);
    break;
case 11:
		  RANGE(25, 100);
	  vict->view_abils.str = value;
	  if (value < 100)
		  vict->view_abils.str_add = 0;
	  load_results(vict);
	  affect_total(vict);
	  break;
 case 12:
	vict->view_abils.str_add = RANGE(0, 100);
    vict->view_abils.str_add = value;
	if (value > 0)
      vict->view_abils.str = 100;
	load_results(vict);
	affect_total(vict);
    break;
/*Edited by Proky,  values for intel*/
  case 13:
  RANGE(25, 100);
  vict->view_abils.intel = value;
  load_results(vict);
  affect_total(vict);
  break;
	/*Edited by Proky values for Wis*/
  case 14:
    RANGE(25, 100);
	vict->view_abils.wis = value;
	load_results(vict);
	affect_total(vict);
	break;
  case 15:
    RANGE(25, 100);
	vict->view_abils.dex = value;
	load_results(vict);
	affect_total(vict);
	break;
	/*Edited by Proky, values for Wis*/
  case 16:
    RANGE(25, 100);
	vict->view_abils.con = value;
	load_results(vict);
    affect_total(vict);
    /*con_aff(vict);*/
	break;
  case 17:
    if (!str_cmp(val_arg, "male"))
      vict->player.sex = SEX_MALE;
    else if (!str_cmp(val_arg, "female"))
      vict->player.sex = SEX_FEMALE;
    else if (!str_cmp(val_arg, "neutral"))
      vict->player.sex = SEX_NEUTRAL;
    else {
      send_to_char("Must be 'male', 'female', or 'neutral'.\r\n", ch);
      return;
    }
    break;
  case 18:
    vict->points.armor = RANGE(-100, 100);
    affect_total(vict);
    break;
    case 19:
	  GET_OLC_ZONE(vict) = value;
	  break;
  case 20:
	  if (IS_NPC(vict)) {
		  send_to_char("That is a mob Sir, Proky won't allow that.\r\n", ch);
		  return;
	  }
	  GET_HOME(vict) = value;
	  break;
  case 21:
    vict->points.exp = RANGE(0, 50000000);
    break;
  case 22:
    vict->points.hitroll = RANGE(-20, 40);
    affect_total(vict);
    break;
  case 23:
    vict->points.damroll = RANGE(-20, 36);
    affect_total(vict);
    break;
  case 24:
    if (GET_LEVEL(ch) < LVL_HEAD_C && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return;
    }
    GET_INVIS_LEV(vict) = RANGE(0, GET_LEVEL(vict));
    break;
  case 25:
    if (GET_LEVEL(ch) < LVL_HEAD_C && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return;
    }
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_NOHASSLE);
    break;
  case 26:
    if (ch == vict) {
      send_to_char("Better not -- could be a long winter!\r\n", ch);
      return;
    }
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_FROZEN);
    break;
  case 27:
  case 28:
    GET_PRACTICES(vict) = RANGE(0, 100);
    break;
  case 29:
  case 30:
  case 31:
    if (!str_cmp(val_arg, "off")) {
      GET_COND(vict, (l - 29)) = (char) -1;
      sprintf(buf, "%s's %s now off.", GET_NAME(vict), fields[l].cmd);
    } else if (is_number(val_arg)) {
      value = atoi(val_arg);
      RANGE(0, 24);
      GET_COND(vict, (l - 29)) = (char) value;
      sprintf(buf, "%s's %s set to %d.", GET_NAME(vict), fields[l].cmd,
	      value);
    } else {
      send_to_char("Must be 'off' or a value from 0 to 24.\r\n", ch);
      return;
    }
	check_regen_rates(vict);
    break;
  case 32:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_KILLER);
    break;
  case 33:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_THIEF);
    break;
  case 34:
    if (value > GET_LEVEL(ch) || value > LVL_OVERLORD) {
      send_to_char("You can't do that.\r\n", ch);
      return;
    }
    RANGE(0, LVL_IMPL);
    vict->player.level = (byte) value;
    break;
  case 35:
    if ((i = real_room(value)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return;
    }
    if (IN_ROOM(vict) != NOWHERE)
    char_from_room(vict);
    char_to_room(vict, i);
    break;
  case 36:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_ROOMFLAGS);
    break;
  case 37:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_SITEOK);
    break;
  case 38:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_DELETED);
    break;
  case 39:
	  if ((i = parse_class(vict, *val_arg)) == CLASS_UNDEFINED) {
      send_to_char("That is not a class.\r\n", ch);
      return;
    }
    clear_skills(vict);
    GET_CLASS(vict) = i;
    set_skills(vict);
    check_regen_rates(vict);
    break;
  case 40:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOWIZLIST);
    break;
  case 41:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_QUEST);
    break;
  case 42:
    if (!str_cmp(val_arg, "off"))
      REMOVE_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
    else if (is_number(val_arg)) {
      value = atoi(val_arg);
      if (real_room(value) != NOWHERE) {
        SET_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
	GET_LOADROOM(vict) = value;
	sprintf(buf, "%s will enter at room #%d.", GET_NAME(vict),
		GET_LOADROOM(vict));
      } else {
	sprintf(buf, "That room does not exist!");
      }
    } else {
      strcpy(buf, "Must be 'off' or a room's virtual number.\r\n");
    }
    break;
  case 43:
    SET_OR_REMOVE(PRF_FLAGS(vict), (PRF_COLOR_1 | PRF_COLOR_2));
    break;
  case 44:
    if (GET_IDNUM(ch) != 1 || !IS_NPC(vict))
      return;
    GET_IDNUM(vict) = value;
    break;
  case 45:
    if (!is_file)
      return;
    if (GET_IDNUM(ch) > 1) {
      send_to_char("Please don't use this command, yet.\r\n", ch);
      return;
    }
    if (GET_LEVEL(vict) >= LVL_GRGOD) {
      send_to_char("You cannot change that.\r\n", ch);
      return;
    }
    strncpy(tmp_store.pwd, CRYPT(val_arg, tmp_store.name), MAX_PWD_LENGTH);
    tmp_store.pwd[MAX_PWD_LENGTH] = '\0';
    sprintf(buf, "Password changed to '%s'.", val_arg);
    break;
  case 46:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NODELETE);
    break;
  case 47:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.cha = value;
    affect_total(vict);
    break;
  case 48:
	if ((i = parse_race(*val_arg)) == RACE_UNDEFINED) {
	    send_to_char("That is not a real race.\r\n", ch);
		return;
	}
	clear_skills(vict);
	GET_RACE(vict) = i;
        GET_RACE_ALIGN(vict) = set_race_align(vict);
	set_skills(vict);
	break;
  case 49:
	  GET_OLC2_ZONE(vict) = value;
	  break;
  case 50:
	   GET_OLC3_ZONE(vict) = value;
	  break;
case 51:
	  GET_OLC4_ZONE(vict) = value;
	  break;
  case 52:
	   GET_OLC5_ZONE(vict) = value;
	  break;
  case 53:
    GET_PLAT(vict) = RANGE(0, 100000000);
    break;
  case 54:
    GET_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 55:
    GET_SILVER(vict) = RANGE(0, 100000000);
    break;
  case 56:
    GET_COPPER(vict) = RANGE(0, 100000000);
    break;
  case 57:
    GET_BANK_PLAT(vict) = RANGE(0, 100000000);
    break;
  case 58:
    GET_BANK_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 59:
    GET_BANK_SILVER(vict) = RANGE(0, 100000000);
    break;
  case 60:
    GET_BANK_COPPER(vict) = RANGE(0, 100000000);
    break;

  case 61: /* diety */
    if((i = parse_diety(vict, *val_arg)) == INVALID_DIETY)
    {
       send_to_char("That's not a valid diety.\r\n", ch);
       return;
    }
    else
      GET_DIETY(ch) = i;
    break;
   case 62:
    GET_FRAG(vict) = value;
    send_to_char("Frag list wont be updated till next boot\r\n", ch);
    break;


  default:
    sprintf(buf, "Can't set that!");
    break;
  }

  if (fields[l].type == BINARY) {
    sprintf(buf, "%s %s for %s.\r\n", fields[l].cmd, ONOFF(on),
	    GET_NAME(vict));
    CAP(buf);
  } else if (fields[l].type == NUMBER) {
    sprintf(buf, "%s's %s set to %d.\r\n", GET_NAME(vict),
	    fields[l].cmd, value);
  } else
    strcat(buf, "\r\n");
  send_to_char(CAP(buf), ch);

  if (!is_file && !IS_NPC(vict))
    save_char(vict, NOWHERE);

  if (is_file) {
    char_to_store(vict, &tmp_store);
    fseek(player_fl, (player_i) * sizeof(struct char_file_u), SEEK_SET);
    fwrite(&tmp_store, sizeof(struct char_file_u), 1, player_fl);
    free_char(cbuf);
    send_to_char("Saved in file.\r\n", ch);
  }
}


static char *logtypes[] = {
"off", "brief", "normal", "complete", "\n"};

ACMD(do_syslog)
{
  int tp;

  one_argument(argument, arg);

  if (!*arg) {
    tp = ((PRF_FLAGGED(ch, PRF_LOG1) ? 1 : 0) +
	  (PRF_FLAGGED(ch, PRF_LOG2) ? 2 : 0));
    sprintf(buf, "Your syslog is currently %s.\r\n", logtypes[tp]);
    send_to_char(buf, ch);
    return;
  }
  if (((tp = search_block(arg, logtypes, FALSE)) == -1)) {
    send_to_char("Usage: syslog { Off | Brief | Normal | Complete }\r\n", ch);
    return;
  }
  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG1 | PRF_LOG2);
  SET_BIT(PRF_FLAGS(ch), (PRF_LOG1 * (tp & 1)) | (PRF_LOG2 * (tp & 2) >> 1));

  sprintf(buf, "Your syslog is now %s.\r\n", logtypes[tp]);
  send_to_char(buf, ch);
  }


 void send_to_imms(char *msg)
 {
   struct descriptor_data *pt;

   for (pt = descriptor_list; pt; pt = pt->next)
     if (!pt->connected && pt->character && GET_LEVEL(pt->character) >= LVL_GOD)
 	send_to_char(msg, pt->character);

 }

 ACMD(do_world)
 {
   char field[MAX_INPUT_LENGTH];

   half_chop(argument, field, buf);

   if (strcmp(field, "pk") == 0)
   {
     if (pk_allowed == 1)
     {
       pk_allowed = 0;
       sprintf(buf, "[SYS: %s disallows PKilling]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       pk_allowed = 1;
       sprintf(buf, "[SYS: %s allows PKilling]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "sleep") == 0)
   {
     if (sleep_allowed == 1)
     {
       sleep_allowed = 0;
       sprintf(buf, "[SYS: %s disallows players from casting sleep on each other]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       sleep_allowed = 1;
       sprintf(buf, "[SYS: %s allows players to cast sleep on each other]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "summon") == 0)
   {
     if (summon_allowed == 1)
     {
       summon_allowed = 0;
       sprintf(buf, "[SYS: %s disallows players from summoning one another]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       summon_allowed = 1;
       sprintf(buf, "[SYS: %s allows players to summon one another]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "charm") == 0)
   {
     if (charm_allowed == 1)
     {
       charm_allowed = 0;
       sprintf(buf, "[SYS: %s disallows players from charming one another]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       charm_allowed = 1;
       sprintf(buf, "[SYS: %s allows players to charm one another]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "roomaffect") == 0)
   {
     if (roomaffect_allowed == 1)
     {
       roomaffect_allowed = 0;
       sprintf(buf, "[SYS: %s disallows room affect spells from hurting other players]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       roomaffect_allowed = 1;
       sprintf(buf, "[SYS: %s allows room affect spells to hurt other players]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else
   {
     send_to_char("[Current world status:]\r\n", ch);
     if (pk_allowed == 1) send_to_char("Pkilling allowed,\r\n", ch);
     if (pk_allowed == 0) send_to_char("Pkilling not allowed,\r\n", ch);
     if (sleep_allowed == 1) send_to_char("Casting sleep on other players allowed,\r\n", ch);
     if (sleep_allowed == 0) send_to_char("Casting sleep on other players not allowed,\r\n", ch);
     if (summon_allowed == 1) send_to_char("Summoning other players allowed,\r\n", ch);
     if (summon_allowed == 0) send_to_char("Summoning other players not allowed,\r\n", ch);
     if (charm_allowed == 1) send_to_char("Charming other players allowed,\r\n", ch);
     if (charm_allowed == 0) send_to_char("Charming other players not allowed,\r\n", ch);
     if (roomaffect_allowed == 1) send_to_char("Room affect spells will hurt other players.\r\n", ch);
     if (roomaffect_allowed == 0) send_to_char("Room affect spells will not hurt other players.\r\n", ch);
   }

}

 ACMD(do_tedit) {
    int l, i;
    char field[MAX_INPUT_LENGTH];
    extern char *credits;
    extern char *news;
	extern char *anews;
    extern char *motd;
    extern char *imotd;
    extern char *help;
    extern char *info;
    extern char *background;
    extern char *handbook;
    extern char *policies;

    struct editor_struct {
       char *cmd;
       char level;
       char *buffer;
       int  size;
       char *filename;
    } fields[] = {
       /* edit the lvls to your own needs */
 	{ "credits",	LVL_IMPL,	"credits",	2400,	CREDITS_FILE},
 	{ "news",	LVL_GRGOD,	"news",		8192,	NEWS_FILE},
 	{ "anews",	LVL_GRGOD,	"anews",		8192,	ANEWS_FILE},
	{ "motd",	LVL_GRGOD,	"motd",		2400,	MOTD_FILE},
 	{ "imotd",	LVL_HEAD_B,	"imotd",		2400,	IMOTD_FILE},
 	{ "help",       LVL_GRGOD,	"help",		2400,	HELP_PAGE_FILE},
 	{ "info",	LVL_GRGOD,	"info",		8192,	INFO_FILE},
	{ "background",	LVL_GRGOD,	"background",	8192,	BACKGROUND_FILE},
 	{ "handbook",   LVL_HEAD_B,	"handbook",	8192,   HANDBOOK_FILE},
 	{ "policies",	LVL_IMPL,	"policies",	8192,	POLICIES_FILE},
 	{ "\n",		0,		NULL,		0,	NULL }
    };

    if (ch->desc == NULL) {
       send_to_char("Get outta here you linkdead head!\r\n", ch);
       return;
    }

    if (GET_LEVEL(ch) < LVL_GRGOD) {
       send_to_char("You do not have text editor permissions.\r\n", ch);
       return;
    }

    half_chop(argument, field, buf);

    if (!*field) {
       strcpy(buf, "Files available to be edited:\r\n");
       i = 1;
       for (l = 0; *fields[l].cmd != '\n'; l++) {
 	 if (GET_LEVEL(ch) >= fields[l].level) {
 	    sprintf(buf, "%s%-11.11s", buf, fields[l].cmd);
 	    if (!(i % 7)) strcat(buf, "\r\n");
 	    i++;
 	 }
       }
       if (--i % 7) strcat(buf, "\r\n");
       if (i == 0) strcat(buf, "None.\r\n");
       send_to_char(buf, ch);
      return;
    }
    for (l = 0; *(fields[l].cmd) != '\n'; l++)
      if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

    if (*fields[l].cmd == '\n') {
       send_to_char("Invalid text editor option.\r\n", ch);
       return;
    }

    if (GET_LEVEL(ch) < fields[l].level) {
       send_to_char("You are not godly enough for that!\r\n", ch);
       return;
    }

    switch (l) {
     case 0: ch->desc->str = &credits; break;
     case 1: ch->desc->str = &news; break;
	 case 2: ch->desc->str = &anews; break;
     case 3: ch->desc->str = &motd; break;
     case 4: ch->desc->str = &imotd; break;
     case 5: ch->desc->str = &help; break;
     case 6: ch->desc->str = &info; break;
     case 7: ch->desc->str = &background; break;
     case 8: ch->desc->str = &handbook; break;
     case 9: ch->desc->str = &policies; break;
     default:
       send_to_char("Invalid text editor option.\r\n", ch);
       return;
    }

    /* set up editor stats */
    send_to_char("\x1B[H\x1B[J", ch);
    send_to_char("Edit file below: (/s saves /h for help)\r\n", ch);
    ch->desc->backstr = NULL;
    if (fields[l].buffer) {
       send_to_char(fields[l].buffer, ch);
       ch->desc->backstr = str_dup(fields[l].buffer);
    }
    ch->desc->max_str = fields[l].size;
    ch->desc->mail_to = 0;
    ch->desc->storage = str_dup(fields[l].filename);
    act("$n begins editing a scroll.", TRUE, ch, 0, 0, TO_ROOM);
    SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
    STATE(ch->desc) = CON_TEXTED;
 }

ACMD(do_copyto)
{

/* Only works if you have Oasis OLC */
extern void olc_add_to_save_list(int zone, byte type);

  char buf2[10];
  char buf[80];
  int iroom = 0, rroom = 0;
  struct room_data *room;

  one_argument(argument, buf2);
  /* buf2 is room to copy to */

	CREATE (room, struct room_data, 1);

	iroom = atoi(buf2);
	rroom = real_room(atoi(buf2));
	*room = world[rroom];

 if (!*buf2) {
    send_to_char("Format: copyto <room number>\r\n", ch);
    return; }
 if (rroom <= 0) {
	sprintf(buf, "There is no room with the number %d.\r\n", iroom);
	send_to_char(buf, ch);
	return; }

/* Main stuff */

  if (world[ch->in_room].description) {
    world[rroom].description = str_dup(world[ch->in_room].description);

/* Only works if you have Oasis OLC */
  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);

 sprintf(buf, "You copy the description to room %d.\r\n", iroom);
 send_to_char(buf, ch); }
	else
	send_to_char("This room has no description!\r\n", ch);
}

ACMD(do_dig)
{
/* Only works if you have Oasis OLC */
extern void olc_add_to_save_list(int zone, byte type);

  char buf2[10];
  char buf3[10];
  char buf[80];
  int iroom = 0, rroom = 0;
  int dir = 0;
/*  struct room_data *room; */
   two_arguments(argument, buf2, buf3);
  /* buf2 is the direction, buf3 is the room */

	iroom = atoi(buf3);
	rroom = real_room(iroom);

 if (!*buf2) {
    send_to_char("Format: dig <dir> <room number>\r\n", ch);
    return; }
 else if (!*buf3) {
    send_to_char("Format: dig <dir> <room number>\r\n", ch);
    return; }
 if (rroom <= 0) {
	sprintf(buf, "There is no room with the number %d", iroom);
	send_to_char(buf, ch);
	return; }
/* Main stuff */
    switch (*buf2) {
    case 'n':
    case 'N':
      dir = NORTH;
      break;
    case 'e':
    case 'E':
      dir = EAST;
      break;
    case 's':
    case 'S':
      dir = SOUTH;
      break;
    case 'w':
    case 'W':
      dir = WEST;
      break;
    case 'u':
    case 'U':
      dir = UP;
      break;
    case 'd':
    case 'D':
      dir = DOWN;
      break; }

CREATE(world[rroom].dir_option[rev_dir[dir]], struct room_direction_data,1);
  world[rroom].dir_option[rev_dir[dir]]->general_description = NULL;
  world[rroom].dir_option[rev_dir[dir]]->keyword = NULL;
  world[rroom].dir_option[rev_dir[dir]]->to_room = ch->in_room;

CREATE(world[ch->in_room].dir_option[dir], struct room_direction_data,1);
  world[ch->in_room].dir_option[dir]->general_description = NULL;
  world[ch->in_room].dir_option[dir]->keyword = NULL;
  world[ch->in_room].dir_option[dir]->to_room = rroom;

/* Only works if you have Oasis OLC */
  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);

 sprintf(buf, "You make an exit %s to room %d.\r\n", buf2, iroom);
 send_to_char(buf, ch);
}

ACMD(do_rlist)
{
  extern struct room_data *world;
  extern int top_of_world;

  int first, last, nr, found = 0;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: rlist <begining number> <ending number>\r\n", ch);
    return;
  }

  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
   send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++) {
    if (world[nr].number >= first) {
      sprintf(buf, "%5d. [%5d] (%3d) %s\r\n", ++found,
              world[nr].number, world[nr].zone,
              world[nr].name);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No rooms were found in those parameters.\n\r", ch);
}


ACMD(do_mlist)
{
  extern struct index_data *mob_index;
  extern struct char_data *mob_proto;
  extern int top_of_mobt;

  int first, last, nr, found = 0;
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: mlist <begining number> <ending number>\r\n", ch);
    return;
  }

  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  for (nr = 0; nr <= top_of_mobt && (mob_index[nr].virtual <= last); nr++) {
    if (mob_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              mob_index[nr].virtual,
              mob_proto[nr].player.short_descr);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No mobiles were found in those parameters.\n\r", ch);
}


ACMD(do_rrestore)
/* Buru 30/11/97 */
{
  struct char_data *i;

  for (i = character_list; i; i = i->next){
  if ((i != ch)&&(!IS_NPC(i))){
    GET_HIT(i) = GET_MAX_HIT(i);
    GET_MANA(i) = GET_MAX_MANA(i);
    GET_MOVE(i) = GET_MAX_MOVE(i);
    act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in its path!&0", TRUE, ch, 0, i, TO_VICT);
  update_pos(i);
  }
  }
   send_to_char(OK, ch);
}





ACMD(do_olist)
{
  extern struct index_data *obj_index;
  extern struct obj_data *obj_proto;
  extern int top_of_objt;

  int first, last, nr, found = 0;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: olist <begining number> <ending number>\r\n", ch);
    return;
  }
  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  for (nr = 0; nr <= top_of_objt && (obj_index[nr].virtual <= last); nr++) {
    if (obj_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              obj_index[nr].virtual,
              obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No objects were found in those parameters.\n\r", ch);
}

void do_newbie(struct char_data *vict) /*To change newbie eq change
									      array in structs.h Banyal*/
{
  struct obj_data *obj;
  extern int warrior_eq[];
  extern int priest_eq[];
  extern int shaman_eq[];
  extern int thief_eq[];
  extern int mage_eq[];
  int i;


  if (GET_LEVEL(vict) < 5) {
 switch (GET_CLASS(vict)) {
   case CLASS_WARRIOR:
   case CLASS_RANGER:
  for (i = 0; warrior_eq[i] != -1; i++) {
    obj = read_object(warrior_eq[i], VIRTUAL);
    obj_to_char(obj, vict);

   }
   break;
   case CLASS_CLERIC:
   case CLASS_DRUID:
   for (i = 0; priest_eq[i] != -1; i++) {
    obj = read_object(priest_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
   }
   break;
   case CLASS_SHAMAN:
   for (i = 0; shaman_eq[i] != -1; i++) {
    obj = read_object(shaman_eq[i], VIRTUAL);
    obj_to_char(obj, vict);

   }
   break;
   case CLASS_ROGUE:
   case CLASS_THIEF:
   case CLASS_ASSASSIN:
   for (i = 0; thief_eq[i] != -1; i++) {
    obj = read_object(thief_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
   }
   break;
   case CLASS_MAGIC_USER:
   for (i = 0; mage_eq[i] != -1; i++) {
    obj = read_object(mage_eq[i], VIRTUAL);
    obj_to_char(obj, vict);

   }
  break;
  default:
  for (i = 0; warrior_eq[i] != -1; i++) {
    obj = read_object(warrior_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
  }
  break;
  }
}
}

ACMD(do_rclone)
{

/* Only works if you have Oasis OLC */
extern void olc_add_to_save_list(int zone, byte type);

  char buf2[10];
  char buf[80];
  int iroom = 0, rroom = 0;
  struct room_data *room;

  one_argument(argument, buf2);

	CREATE (room, struct room_data, 1);

	iroom = atoi(buf2);
	rroom = real_room(atoi(buf2));
	*room = world[rroom];

 if (!*buf2) {
    send_to_char("Format: hhroom <room number>\r\n", ch);
    return; }
 if (rroom <= 0) {
	sprintf(buf, "There is no room with the number %d.\r\n", iroom);
	send_to_char(buf, ch);
	return; }



  if (world[ch->in_room].description) {
    world[rroom].description = str_dup(world[ch->in_room].description);
  if (world[ch->in_room].name) {
	  world[rroom].name = str_dup(world[ch->in_room].name);}
  if (world[ch->in_room].room_flags) {
        world[rroom].room_flags = world[ch->in_room].room_flags;}
  if (world[ch->in_room].sector_type) {
       world[rroom].sector_type = world[ch->in_room].sector_type;}


  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);

 sprintf(buf, "You clone this room to room %d.\r\n", iroom);
 send_to_char(buf, ch); }
	else
	send_to_char("This room has no description so why clone it?!\r\n", ch);
}

void set_innate(struct char_data * ch, char *arg)
{
  struct affected_type *aff=NULL;
  int found=FALSE;

if(!arg){
	mudlog("NO ARG FOR INNATE", NRM, LVL_GOD, TRUE);
	return;}

if (ch->affected) {
    for (aff = ch->affected; aff && !found; aff = aff->next) {
        if  (is_abbrev(arg,spells[aff->type]))
           found=TRUE;
    }
  }

for (aff = ch->affected; aff; aff = aff->next) {
        if  (is_abbrev(arg,spells[aff->type]))
         aff->duration=-1;
       mudlog("INNATES SET", NRM, LVL_GOD, TRUE);
    }}

ACMD(do_speak)
{
  extern char *languages[];
  extern char *spells[];
  int i = MIN_LANGUAGE;
  int ofs = 190;

  skip_spaces(&argument);

  if (!*argument) {

	strcpy(buf, "You know of the following languages:\r\n");
 strcpy(buf2, buf);

	for (i = MIN_LANGUAGE +1; i < MAX_LANGUAGE+1; i++)
 {
   if (GET_SKILL(ch, i) > 0)
   {
    sprintf(buf, "%-20s %s\r\n", languages[(i - ofs)] , howgood(GET_SKILL(ch, i)));
    strcat(buf2, buf);
   }
 }
  page_string(ch->desc, buf2, 1);
  }else{

	if (is_abbrev(argument, "common")){
    if (GET_SKILL(ch, LANG_COMMON) > 0){
		SPEAKING(ch) = LANG_COMMON;
		send_to_char(OK, ch);
		return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
	}
	}else if (is_abbrev(argument, "dwarven")){
		if(GET_SKILL(ch, LANG_DWARVEN) > 0){
			SPEAKING(ch) = LANG_DWARVEN;
			send_to_char(OK, ch);
			return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
	}
	}else if (is_abbrev(argument, "elven")){
		if(GET_SKILL(ch, LANG_ELVEN) > 0){
         SPEAKING(ch) = LANG_ELVEN;
		 send_to_char(OK, ch);
		 return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
    }
	}else if (is_abbrev(argument, "halfling")){
		if(GET_SKILL(ch, LANG_HALFLING) > 0){
			SPEAKING(ch) = LANG_HALFLING;
			send_to_char(OK, ch);
			return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
	}
	}else if (is_abbrev(argument, "gnomish")){
		if(GET_SKILL(ch, LANG_GNOMISH) > 0){
			SPEAKING(ch) = LANG_GNOMISH;
			send_to_char(OK, ch);
			return;
		}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
return;
		}
		}else if (is_abbrev(argument, "barbarian")){
			if(GET_SKILL(ch, LANG_BARBARIAN) > 0){
				SPEAKING(ch) = LANG_BARBARIAN;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
			}else if (is_abbrev(argument, "drow")){
		if(GET_SKILL(ch, LANG_DROW) > 0){
				SPEAKING(ch) = LANG_DROW;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "trollish")){
		if(GET_SKILL(ch, LANG_TROLLISH) > 0){
				SPEAKING(ch) = LANG_TROLLISH;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
 }else if (is_abbrev(argument, "duergar")){
		if(GET_SKILL(ch, LANG_DUERGAR) > 0){
				SPEAKING(ch) = LANG_DUERGAR;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "ogre")){
		if(GET_SKILL(ch, LANG_OGRE) > 0){
				SPEAKING(ch) = LANG_OGRE;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "orcish")){
		if(GET_SKILL(ch, LANG_ORCISH) > 0){
				SPEAKING(ch) = LANG_ORCISH;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
			}else
		send_to_char("That is not a valid language.", ch);
  }
  }



ACMD(do_terminate)
{
  struct char_data *victim;
  int clan_num;

  send_to_char("&1&bThis command is disabbled read board Banyal&0\r\n",
  ch);
  return;

  one_argument(argument, buf);

  if (!*buf) {
    send_to_char("Whom do you wish to terminate?\r\n", ch);
    return;
  }
  victim = get_char_vis(ch,buf);
  if (victim) {
      if (victim == ch) {
      send_to_char("You cannot term yourself goon!\r\n", ch);
      return;
      }

      if (GET_LEVEL(victim) == LVL_IMPL)	{
        send_to_char("&1You dare NOT do that!&0 Go kill a wuss like Darr", ch);
        return;
      }
      if (IS_NPC(victim)) {
      send_to_char("You cannot term NPC's!\r\n", ch);
      return;
      }
      //delete and purge
      if(GET_LEVEL(victim) < LVL_GRGOD) {
	if(GET_CLAN(victim)) {
	  clan_num = find_clan_by_id(GET_CLAN(victim));
          if(GET_CLAN_RANK(victim)){
            clan[clan_num].members--;
	    clan[clan_num].power-=GET_LEVEL(victim);
	  }
          GET_CLAN(victim) = 0;
          GET_CLAN_RANK(victim) = 0;
	  update_clan(ch,clan_num);
        }
        SET_BIT(PLR_FLAGS(victim), PLR_DELETED);
      }
      save_char(victim, NOWHERE);
      Crash_delete_file(GET_NAME(victim));
      if (victim->desc) {
	close_socket(victim->desc);
	victim->desc = NULL;
      }
      act("&9&b$n cuts &0$N's &9&bthroat and buries $s corpse where no one will ever find it!&0", FALSE, ch, 0, victim, TO_ROOM);
      act("&9&bYou destroy &0$N &9&bforever.&0", FALSE, ch, 0, victim, TO_CHAR);
      sprintf(buf,"%s has terminated %s!",GET_NAME(ch),GET_NAME(victim));
      log(buf);
      extract_char(victim);
      return;
  }
  send_to_char("That player is not playing. If you must, linkload first.\r\n",ch);
  /*else {
     CREATE(cbuf, struct char_data, 1);
     clear_char(cbuf);
     if ((player_i = load_char(buf, &tmp_store)) > -1) {
       store_to_char(&tmp_store, cbuf);
       GET_PFILEPOS(cbuf) = player_i;
       act("&RYou destroy &W$N&R forever.&N", FALSE, ch, 0, cbuf, TO_CHAR);
       SET_BIT(PLR_FLAGS(cbuf), PLR_DELETED);
       save_char(cbuf, NOWHERE);
       Crash_delete_file(GET_NAME(cbuf));
       if (cbuf->desc) {
	  close_socket(cbuf->desc);
	  cbuf->desc = NULL;
       }
       return;
     } else {
         free(cbuf);
         send_to_char("There is no such player.\r\n", ch);
         return;
     }
  }*/
}

/* David Endre 1/17/99 For Zzur to control ultimate power! */
ACMD(do_rsdiamimp)
{
   if (!strcmp(GET_NAME(ch), "Zzur"))
   {   GET_LEVEL(ch) = LVL_IMPL;
       send_to_char("Level fixed...\r\n", ch);
   } else
       send_to_char("Huh?!?\r\n", ch);
}
@


1.337
log
@Change pulse variables into pulse_t, an unsigned integer type.
Fix other warnings.
@
text
@/***************************************************************************
 * $Id: act.wizard.c,v 1.336 2011/08/06 15:22:51 rsd Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: act.wizard.c                                   Part of FieryMUD *
 *  Usage: Player-level god commands and other goodies                     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "casting.h"
#include "house.h"
#include "screen.h"
#include "olc.h"
#include "dg_scripts.h"
#include "clan.h"
#include "quest.h"
#include "weather.h"
#include "events.h"
#include "class.h"
#include "races.h"
#include "skills.h"
#include "cooldowns.h"
#include "constants.h"
#include "math.h"
#include "players.h"
#include "pfiles.h"
#include "regen.h"
#include "exits.h"
#include "fight.h"
#include "legacy_structs.h"
#include "modify.h"
#include "act.h"
#include "movement.h"
#include "limits.h"
#include "composition.h"
#include "lifeforce.h"
#include "charsize.h"
#include "textfiles.h"

void garble_text(char *string, int percent);
void check_new_surroundings(struct char_data *ch, bool old_room_was_dark, bool tx_obvious);

extern int restrict;
extern int restrict_reason;
extern int max_group_difference;

extern int races_allowed;
extern int evil_races_allowed;
extern int pk_allowed;
extern int sleep_allowed;
extern int charm_allowed;
extern int summon_allowed;
extern int roomeffect_allowed;
extern int approve_names;
extern int napprove_pause;
extern int gossip_channel_active;
extern int nameserver_is_slow;
extern int level_gain;
extern int damage_amounts;
int Valid_Name(char *newname);
int reserved_word(char *argument);

/* Automatic rebooting */
extern int reboot_auto;
extern pulse_t global_pulse;
extern pulse_t reboot_pulse;
extern int reboot_warning;
extern int last_reboot_warning;
extern unsigned int reboot_warning_minutes;

/* extern functions */
void send_to_xnames(char *name);
int find_zone(int num);
void cure_laryngitis(struct char_data *ch);
void reboot_mud_prep();
void rebootwarning(int minutes);
void update_stats(struct char_data *ch);

/* Internal funct */
void do_wiztitle(char *outbuf, struct char_data *vict, char *argu);

ACMD(do_inctime) {
   skip_spaces(&argument);

   if (str_cmp(argument, "yes") != 0) {
      send_to_char("Are you sure you want to move time forward?\r\n"
            "If so, type 'inctime yes'.\r\n", ch);
      return;
   }

   send_to_char("Advancing game time by one hour.\r\n", ch);
   increment_game_time();
}

ACMD(do_iptables) {
  extern int normalize_ip_address(char *in, char *out); /* utils.c */
  char cBuf[MAX_INPUT_LENGTH];
  char cBuf2[MAX_INPUT_LENGTH];
  char cBuf3[MAX_INPUT_LENGTH];
  char tmpfile[MAX_INPUT_LENGTH];
  char arg[MAX_INPUT_LENGTH];
  struct char_data *vict;
  struct descriptor_data *desc;

  /* List of ports we want to open for coders */
  int ports_to_open[2] = {22, 80};
  /* Make sure this number matches the size of ports_to_open */
  int num_ports = 2;

  int i, num_ports_open;
  bool ports_open[2];

  FILE* tmp;

  sprintf(tmpfile,  "/tmp/iptables.list.%d", getpid());

  argument = one_argument(argument, arg);

  /* "list" is the default action */
  if (strcmp(arg, "list") == 0 || !arg[0]) {
    sprintf(cBuf3, "/sbin/iptables --list FieryMUD -v -n --line-numbers > %s",
      tmpfile);
    system(cBuf3);

    tmp = fopen(tmpfile, "rt");

    while (get_line(tmp, cBuf))
      pprintf(ch, "%s\r\n", cBuf);

    start_paging(ch);

    fclose(tmp);

    sprintf(cBuf3, "rm %s", tmpfile);
    system(cBuf3);
  } else if (strcmp(arg, "add") == 0) {
    one_argument(argument, arg);

    if (!*arg) {
      send_to_char("What player or IP address do you want allowed?\r\n", ch);
      return;
    } else {
      /* Must get normalized IP address string into buf now */

      if (normalize_ip_address(arg, buf)) {
         /* The string given is not a good IP address.  See if it's a player's name. */
         if (!strcmp("me", arg)) {
            vict = ch;
         } else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
            send_to_char("Nobody by that name (or invalid IP address).\r\n", ch);
            return;
         }

         /* We have a player's name. */
         desc = NULL;
         if (!IS_NPC(vict)) {
               if (vict->desc) {
                  desc = vict->desc;
               } else if (vict->forward && vict->forward->desc) {
                  desc = vict->forward->desc;
               }
         }
         if (!desc) {
            /* linkless */
            act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
            return;
         }
         if (!desc->host || !(*(desc->host))) {
            act("I can't seem to determine $s IP address.", FALSE, ch, 0, vict, TO_CHAR);
            return;
         }
         /* We have a valid player with a link */
         if (normalize_ip_address(desc->host, buf)) {
            sprintf(buf2, "Error! Could not normalize host '%s'!\r\n", desc->host);
            send_to_char(buf2, ch);
            return;
         }
         /* buf now contains the normlized IP address string for vict */
      }

      /* buf now contains normalized IP address string */

      if (!strcmp("127.0.0.1", buf)) {
         send_to_char("Cancelled - adding 127.0.0.1 is unnecessary.\r\n", ch);
         return;
      }

      /* Determine whether the address is already in the table. */

      sprintf(cBuf3, "/sbin/iptables --list FieryMUD -v -n --line-numbers > %s",
         tmpfile);
      system(cBuf3);

      tmp = fopen(tmpfile, "rt");

      /* Prepare the string to use when looking for the ip address */
      sprintf(buf2, " %s ", buf);
      num_ports_open = 0;
      for (i = 0; i < num_ports; i++) ports_open[i] = FALSE;

      /* Find out which ports (if any) are already opened for the
       * requested address */
      while(get_line(tmp, cBuf)) {
         if (strstr(cBuf, buf2)) {
            /* ip address found */
            for (i = 0; i < num_ports; i++) {
               if (!ports_open[i]) {
                  sprintf(buf1, " tcp dpt:%d ", ports_to_open[i]);
                  if (strstr(cBuf, buf1)) {
                     ports_open[i] = TRUE;
                     num_ports_open++;
                  }
               }
            }
         }
      }

      sprintf(cBuf3, "rm %s", tmpfile);
      system(cBuf3);
      fclose(tmp);

      if (num_ports_open == num_ports) {
         sprintf(buf1, "%s is already in the table.\r\n", buf);
         send_to_char(buf1, ch);
      } else {
         /* Open up the desired ports */
         for (i = 0; i < num_ports; i++) {
            if (!ports_open[i]) {
               sprintf(cBuf,
                   "/sbin/iptables -I FieryMUD --source %s --protocol tcp --dport %d --jump ACCEPT",
                   buf, ports_to_open[i]);
               system(cBuf);
            }
         }
         sprintf(buf2, "Ok, added %s to the table.\r\n", buf);
         send_to_char(buf2, ch);
      }
    }

  } else if (strcmp(arg, "del") == 0) {
    one_argument(argument, arg);
    if (!*arg) {
      send_to_char("Which line should be deleted?\r\n", ch);
    } else {
       int lineNum = 0;
       lineNum = atoi(arg);
       if (lineNum < 1) {
          send_to_char("That is not a valid line number.\r\n", ch);
       } else {
          sprintf(cBuf2, "/sbin/iptables -D FieryMUD %d", lineNum);
          system(cBuf2);

          send_to_char("Ok.\r\n",ch);
       }
    }
  } else {
    send_to_char("Usage:  iptables [add <ip/player>|del <number>|list]\r\n", ch);
  }

}

ACMD(do_echo)
{
  skip_spaces(&argument);

  if (!*argument)
    send_to_char("Yes.. but what?\r\n", ch);
  else {
    if (subcmd == SCMD_EMOTE || subcmd == SCMD_EMOTES) {
      if (EFF_FLAGGED(ch, EFF_SILENCE)) {
        send_to_char("Your lips move, but no sound forms.\r\n", ch);
        return;
      }
      if (!speech_ok(ch, 0)) return;
      if (GET_LEVEL(REAL_CHAR(ch)) < LVL_IMMORT)
        argument = strip_ansi(argument);
      sprintf(buf, "$n%s %s&0", subcmd == SCMD_EMOTES ? "'s" : "", argument);
    }
    else
      sprintf(buf, "%s@@0", argument);

    act(buf, subcmd != SCMD_ECHO, ch, 0, 0, TO_ROOM);

    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      act(buf, FALSE, ch, 0, 0, TO_CHAR);
  }
}


ACMD(do_send)
{
  struct char_data *vict;

  half_chop(argument, arg, buf);

  if (!*arg) {
    send_to_char("Send what to who?\r\n", ch);
    return;
  }
  if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return;
  }
  cprintf(vict, "%s@@0\r\n", buf);
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char("Sent.\r\n", ch);
  else
    cprintf(ch, "You send '%s@@0' to %s.\r\n", buf, GET_NAME(vict));
}

void perform_ptell(struct char_data *ch, struct char_data *vict, char *arg)
{
  struct descriptor_data *d;

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    sprintf(buf, "&6You respond to $N, '&b%s&0&6'&0", arg);
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  }
  if (PRF_FLAGGED(vict, PRF_AFK))  {
    send_to_char("You received the previous message while AFK.\r\n", vict);
    send_to_char("That person is AFK right now but received your message.\r\n", ch);
  }

  sprintf(buf, "&6%s responds to %s's petition, '&b%s&0&6'&0\r\n",
          GET_NAME(REAL_CHAR(ch)), GET_NAME(vict), arg);
  for (d = descriptor_list; d; d = d->next) {
    if (STATE(d) == CON_PLAYING && d != ch->desc &&
        GET_LEVEL(d->character) >= LVL_IMMORT &&
        !PLR_FLAGGED(d->character, PLR_WRITING) &&
        !PLR_FLAGGED(d->character, PLR_MAILING) &&
        !EDITING(d))
      send_to_char(buf, d->character);
  }

  if (vict->forward && !vict->desc)
    vict = vict->forward;

  sprintf(buf, "&6$n responds to your petition, '&b%s&0&6'&0", arg);
  act(buf, FALSE, REAL_CHAR(ch), 0, vict, TO_VICT | TO_SLEEP);
}

ACMD(do_ptell)
{
  struct char_data *vict;

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2)
    send_to_char("Who do you wish to ptell??\r\n", ch);
  else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, buf))))
    send_to_char(NOPERSON, ch);
  else if (ch == vict)
    send_to_char("You need mental help. Try ptelling someone besides yourself.\r\n", ch);
  else if (GET_LEVEL(vict) >= LVL_IMMORT)
    send_to_char("Just use wiznet!\r\n", ch);
  else if (!IS_NPC(vict) && !vict->desc && (!vict->forward || !vict->forward->desc))        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (vict->desc && EDITING(vict->desc))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else
    perform_ptell(ch, vict, buf2);
}


/* take a string, and return an rnum.. used for goto, at, etc.  -je 4/6/93 */
int find_target_room(struct char_data * ch, char *rawroomstr)
{
  int tmp;
  int location;
  struct char_data *target_mob;
  struct obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];

  one_argument(rawroomstr, roomstr);

  if (!*roomstr) {
    send_to_char("You must supply a room number or name.\r\n", ch);
    return NOWHERE;
  }
  if (isdigit(*roomstr) && !strchr(roomstr, '.')) {
    tmp = atoi(roomstr);
    if ((location = real_room(tmp)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return NOWHERE;
    }
  }
  else if ((target_mob = find_char_around_char(ch, find_vis_by_name(ch, roomstr))))
    location = target_mob->in_room;
  else if ((target_obj = find_obj_around_char(ch, find_vis_by_name(ch, roomstr)))) {
    if (target_obj->in_room != NOWHERE)
      location = target_obj->in_room;
    else {
      send_to_char("That object is not available.\r\n", ch);
      return NOWHERE;
    }
  } else {
    send_to_char("No such creature or object around.\r\n", ch);
    return NOWHERE;
  }

  /* a location has been found -- if you're < GRGOD, check restrictions. */
  if (GET_LEVEL(ch) < LVL_GOD) {
    if (ROOM_FLAGGED(location, ROOM_GODROOM)) {
      send_to_char("You are not godly enough to use that room!\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
        world[location].people && world[location].people->next_in_room) {
      send_to_char("There's a private conversation going on in that room.\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_HOUSE) &&
        !House_can_enter(ch, world[location].vnum)) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return NOWHERE;
    }
  }
  return location;
}

ACMD(do_at)
{
  char command[MAX_INPUT_LENGTH];
  int location, original_loc;

  half_chop(argument, buf, command);
  if (!*buf) {
    send_to_char("You must supply a room number or a name.\r\n", ch);
    return;
  }

  if (!*command) {
    send_to_char("What do you want to do there?\r\n", ch);
    return;
  }

  if ((location = find_target_room(ch, buf)) < 0)
    return;

  /* a location has been found. */
  original_loc = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, location);
  command_interpreter(ch, command);

  /* check if the char is still there */
  if (ch->in_room == location) {
    char_from_room(ch);
    char_to_room(ch, original_loc);
  }
}


ACMD(do_goto)
{
  int location;

  skip_spaces(&argument);
  if (strcmp(argument, "home") == 0) {
    if( (location = real_room(GET_HOMEROOM(ch))) < 0 ) {
      send_to_char("Your home room is invalid.\r\n", ch);
      return;
    }
  } else if ((location = find_target_room(ch, argument)) < 0) {
      return;
  }
  if (GET_POOFOUT(ch) && *GET_POOFOUT(ch))
    strcpy(buf, GET_POOFOUT(ch));
  else
    strcpy(buf, "$n disappears in a puff of smoke.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  dismount_char(ch);
  char_from_room(ch);
  char_to_room(ch, location);

  if (GET_POOFIN(ch) && *GET_POOFIN(ch))
    strcpy(buf, GET_POOFIN(ch));
  else
    strcpy(buf, "$n appears with an ear-splitting bang.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, FALSE);
}

ACMD(do_linkload)
{
  struct char_data *victim = 0;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Linkload who?\r\n", ch);
    return;
  }
  if (find_char_around_char(ch, find_plr_by_name(arg))) {
    send_to_char("They are already connected!\r\n", ch);
    return;
  }
  CREATE(victim, struct char_data, 1);
  clear_char(victim);
  if (load_player(arg, victim) > -1) {
    if (GET_LEVEL(victim) <= GET_LEVEL(ch)) {
      victim->player.time.logon = time(0);
      sprintf(buf, "(GC) %s has link-loaded %s.", GET_NAME(ch), GET_NAME(victim));
      mudlog(buf, BRF, GET_LEVEL(ch) + 1, TRUE);
      char_to_room(victim, IN_ROOM(ch));
      load_quests(victim);
      load_objects(victim);
      victim->next = character_list;
      character_list = victim;
      victim->desc = NULL;
      act("You linkload $N.", FALSE, ch, 0, victim, TO_CHAR);
      act("$n linkloads $N.", FALSE, ch, 0, victim, TO_NOTVICT);
    } else {
      send_to_char("Sorry, you aren't high enough to link-load that char.\r\n", ch);
      free_char(victim);
    }
  } else {
    send_to_char("No such player exists.\r\n", ch);
    free(victim);
  }
  return;
}


ACMD(do_trans)
{
  struct descriptor_data *i;
  struct char_data *victim;
  bool wasdark;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to transfer?\r\n", ch);
  else if (str_cmp("all", buf)) {
    if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, buf))))
      send_to_char(NOPERSON, ch);
    else if (victim == ch)
      send_to_char("That doesn't make much sense, does it?\r\n", ch);
    else {
      if ((GET_LEVEL(ch) < GET_LEVEL(victim)) && !IS_NPC(victim)) {
        send_to_char("Go transfer someone your own size.\r\n", ch);
        return;
      }
      act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
      wasdark = IS_DARK(victim->in_room) && !CAN_SEE_IN_DARK(victim);
      dismount_char(victim);
      char_from_room(victim);
      char_to_room(victim, ch->in_room);
      act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
      act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
      check_new_surroundings(victim, wasdark, TRUE);
    }
  } else {                        /* Trans All */
    if (GET_LEVEL(ch) < LVL_GRGOD) {
      send_to_char("I think not.\r\n", ch);
      return;
    }

    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->character && i->character != ch) {
        victim = i->character;
        if (GET_LEVEL(victim) >= GET_LEVEL(ch))
          continue;
        act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
   wasdark = IS_DARK(victim->in_room) && !CAN_SEE_IN_DARK(victim);
   dismount_char(victim);
        char_from_room(victim);
        char_to_room(victim, ch->in_room);
        act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
        act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
   check_new_surroundings(victim, wasdark, TRUE);
      }
    send_to_char(OK, ch);
  }
}



ACMD(do_teleport)
{
  struct char_data *victim;
  int target;
  bool wasdark;

  two_arguments(argument, buf, buf2);

  if (!*buf)
    send_to_char("Whom do you wish to teleport?\r\n", ch);
  else if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, buf))))
    send_to_char(NOPERSON, ch);
  else if (victim == ch)
    send_to_char("Use 'goto' to teleport yourself.\r\n", ch);
  else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
    send_to_char("Maybe you shouldn't do that.\r\n", ch);
  else if (!*buf2)
    send_to_char("Where do you wish to send this person?\r\n", ch);
  else if ((target = find_target_room(ch, buf2)) >= 0) {
    send_to_char(OK, ch);
    act("$n disappears in a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    wasdark = IS_DARK(victim->in_room) && !CAN_SEE_IN_DARK(victim);
    dismount_char(victim);
    char_from_room(victim);
    char_to_room(victim, target);
    act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    act("$n has teleported you!", FALSE, ch, 0, (char *) victim, TO_VICT);
    check_new_surroundings(victim, wasdark, TRUE);
  }
}


ACMD(do_shutdown)
{
  extern int circle_shutdown, circle_reboot;

  if (subcmd != SCMD_SHUTDOWN) {
    send_to_char("If you want to shut something down, say so!\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log("%s",buf);
    send_to_all("Shutting down.\r\n");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "reboot")) {
    sprintf(buf, "(GC) Reboot by %s.", GET_NAME(ch));
    log("%s",buf);
    reboot_mud_prep();
    circle_shutdown = circle_reboot = 1;
  } else if (!str_cmp(arg, "now")) {
    sprintf(buf, "(GC) Shutdown NOW by %s.", GET_NAME(ch));
    log("%s",buf);
    send_to_all("Rebooting.. come back in a minute or two.\r\n"
                 "           &1&b** ****** ****&0\r\n"
                "         &1&b**&0 &3&b***     *****&0  &1&b**&0\r\n"
                "       &1&b**&0 &3&b**      &1&b*&0     &3&b***&0  &1&b*&0\r\n"
                "       &1&b*&0    &3&b** **   *   *  *&0 &1&b**&0\r\n"
                "      &1&b*&0  &3&b** * *&0          &1&b*&0     &1&b*&0\r\n"
                "      &1&b*&0  &3&b*&0    &1&b**&0            &3&b* *&0 &1&b*&0\r\n"
                "     &1&b*&0 &3&b* &1&b** *&0     &3&b*   ******&0  &1&b*&0\r\n"
                "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n");
    send_to_all("        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
                "         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
                "                &1&b*&0   &3&b*&0 &1&b*&0\r\n"
                "               &1&b*&0  &3&b* *&0  &1&b*&0\r\n"
                "              &1&b*&0  &3&b*  **&0  &1&b*&0\r\n"
                "              &1&b*&0 &3&b**   *&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0  &1&b**&0\r\n"
                "               &1&b**&0     &1&b****&0\r\n"
                "              &1&b***&0  &3&b* *&0    &1&b****&0\r\n");
    circle_shutdown = 1;
    circle_reboot = 2;

  } else if (!str_cmp(arg, "die")) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log("%s",buf);
    send_to_all("Shutting down for maintenance.\r\n");
    touch("../.killscript");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "pause")) {
    sprintf(buf, "(GC) Shutdown by %s.", GET_NAME(ch));
    log("%s",buf);
    send_to_all("Shutting down for maintenance.\r\n");
    touch("../pause");
    circle_shutdown = 1;
  } else
    send_to_char("Unknown shutdown option.\r\n", ch);
}


void stop_snooping(struct char_data * ch)
{
  if (!ch->desc->snooping)
    send_to_char("You aren't snooping anyone.\r\n", ch);
  else {
    send_to_char("You stop snooping.\r\n", ch);
    ch->desc->snooping->snoop_by = NULL;
    ch->desc->snooping = NULL;
  }
}

void perform_snoop(struct char_data *ch, struct descriptor_data *d)
{
  struct char_data *tch;

  tch = NULL;

  if (d->snooping == ch->desc) {
    send_to_char("Don't be stupid.\r\n", ch);
    return;
  } else if (d->snoop_by) {
    send_to_char("Busy already.\r\n", ch);
    return;
  } else if (d == ch->desc) {
    send_to_char("Not a good idea.\r\n", ch);
    return;
  } else if (STATE(d) != CON_PLAYING) {
    /* This is to prevent snoopers from seeing passwords. */
    send_to_char("Please wait until they've logged in.\r\n", ch);
    return;
  }

  if (d->original)
    tch = d->original;
  else if (d->character)
    tch = d->character;

  if (tch && GET_LEVEL(tch) >= GET_LEVEL(ch)) {
    send_to_char("You can't.\r\n", ch);
    return;
  }

  /* It's ok to snoop on. */
  send_to_char(OK, ch);

  /* Stop snooping whoever you were snooping on before */
  if (ch->desc->snooping)
    ch->desc->snooping->snoop_by = NULL;

  ch->desc->snooping = d;
  d->snoop_by = ch->desc;
}

ACMD(do_snoop)
{
  struct char_data *victim;
  struct descriptor_data *d;
  int dnum;

  if (!ch->desc)
    return;

  one_argument(argument, arg);

  if (!*arg)
    stop_snooping(ch);
  else if (isdigit(*arg)) {
    dnum = atoi(arg);
    for (d = descriptor_list; d; d = d->next) {
      if (d->desc_num == dnum) {
        perform_snoop(ch, d);
        return;
      }
    }
    send_to_char("No such descriptor.\r\n", ch);
  } else if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, arg))))
    send_to_char("No such person around.\r\n", ch);
  else if (!victim->desc)
    send_to_char("There's no link.. nothing to snoop.\r\n", ch);
  else if (victim == ch)
    send_to_char("Not a good idea.\r\n", ch);
  else
    perform_snoop(ch, victim->desc);
}

ACMD(do_switch)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (POSSESSED(ch))
    send_to_char("You're already switched.\r\n", ch);
  else if (!*arg)
    send_to_char("Switch with who?\r\n", ch);
  else if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, arg))))
    send_to_char("No such character.\r\n", ch);
  else if (ch == victim)
    send_to_char("Hee hee... we are jolly funny today, eh?\r\n", ch);
  else if (victim->desc)
    send_to_char("You can't do that, the body is already in use!\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GRGOD) && !IS_NPC(victim))
    send_to_char("You aren't holy enough to use a mortal's body.\r\n", ch);
  else if ((GET_LEVEL(ch) < GET_LEVEL(victim)))
    send_to_char("You WISHED.\r\n",ch);
  else {
    send_to_char(OK, ch);

    ch->desc->character = victim;
    ch->desc->original = ch;

    victim->desc = ch->desc;
    ch->desc = NULL;

    if (!GET_PROMPT(victim) || IS_NPC(victim))
      GET_PROMPT(victim) = strdup(GET_PROMPT(ch));
  }
}

ACMD(do_rename)
{
  int player_i;
  struct char_data *victim=NULL;
  char tmp_name[MAX_INPUT_LENGTH], arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  extern struct char_data *is_playing(char *vict_name);

  two_arguments(argument, arg1, arg2);

  if (!ch || IS_NPC(ch))
    return;

  if (!*arg1 || !*arg2) {
    send_to_char("Usage: rename <player name> <new name>\r\n",ch);
    return;
  }

  victim = is_playing(arg1);

  if (!victim) {
    send_to_char("You can only rename a player currently logged in.\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) <= GET_LEVEL(victim)) {
    send_to_char("You don't have permission to change that name.\r\n", ch);
    return;
  }

  if (_parse_name(arg2, tmp_name) || strlen(tmp_name) < 2 ||
      strlen(tmp_name) > MAX_NAME_LENGTH || !Valid_Name(tmp_name) ||
      fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
    send_to_char("The new name is invalid.\r\n", ch);
    return;
  }

  if ((player_i = get_id_by_name(tmp_name)) >= 0) {
    send_to_char("There is already a player with that name.\r\n", ch);
    return;
  }

  sprintf(buf2, "&1&bYou have renamed &7%s&1 to &7%s&0\r\n", GET_NAME(victim), CAP(tmp_name));
  send_to_char(buf2, ch);
  sprintf(buf2, "(GC) %s has renamed %s to %s", GET_NAME(ch), GET_NAME(victim), tmp_name);
  mudlog(buf2, NRM, LVL_HEAD_C, TRUE);

  rename_player(victim, tmp_name);

  sprintf(buf2, "&1&b!!! You have been renamed to &7%s&1.&0\r\n", GET_NAME(victim));
  send_to_char(buf2, victim);
}

ACMD(do_return)
{
  if (POSSESSED(ch)) {
    if (GET_LEVEL(POSSESSOR(ch)) < 101 && subcmd == 0) {
      send_to_char("Huh?!?\r\n", ch);
      return;
    }
    if (GET_COOLDOWN(ch, CD_SHAPECHANGE) < 0 && subcmd == 0) {
      send_to_char("Use 'shapechange me' to return to your body.\r\n", ch);
      return;
    }

    send_to_char("You return to your original body.\r\n", ch);

    /* if someone switched into your original body, disconnect them */
    if (ch->desc->original->desc)
      close_socket(ch->desc->original->desc);

    ch->desc->character = ch->desc->original;
    ch->desc->original = NULL;

    ch->desc->character->desc = ch->desc;
    ch->desc = NULL;
  }
  else
    send_to_char("Huh?!?\r\n", ch);
}



ACMD(do_load)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("Usage: load { obj | mob } <number>\r\n", ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, ch->in_room);

    act("$n makes a quaint, magical gesture with one hand.", TRUE, ch,
        0, 0, TO_ROOM);
    act("$n has created $N!", FALSE, ch, 0, mob, TO_ROOM);
    act("You create $N.", FALSE, ch, 0, mob, TO_CHAR);
    sprintf(buf, "(GC) %s loads mob,  %s", GET_NAME(ch), GET_NAME(mob));
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
    load_mtrigger(mob);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    /*obj_to_room(obj, ch->in_room);*/
    obj_to_char(obj, ch);
    act("$n makes a strange magical gesture.", TRUE, ch, 0, 0, TO_ROOM);
    act("$n has created $p!", TRUE, ch, obj, 0, TO_ROOM);
    act("You create $p.", FALSE, ch, obj, 0, TO_CHAR);
    sprintf(buf, "(GC) %s loads OBJ,  %s", GET_NAME(ch), (obj)->short_description);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}


/* clean a room of all mobiles and objects */
ACMD(do_purge)
{
  struct char_data *vict, *next_v;
  struct obj_data *obj, *next_o;

  one_argument(argument, buf);

  if (*buf) {                        /* argument supplied. destroy single object
                                 * or char */
    if ((vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, buf)))) {
      if (!IS_NPC(vict) && (GET_LEVEL(ch) <= GET_LEVEL(vict)) && (GET_LEVEL(ch) >= LVL_HEAD_B)) {
        send_to_char("Fuuuuuuuuu!\r\n", ch);
        return;
      }
      act("$n disintegrates $N.", FALSE, ch, 0, vict, TO_NOTVICT);
      act("$n disintegrates YOU!", TRUE, ch, 0, vict, TO_VICT);
      if (!IS_NPC(vict)) {
        sprintf(buf, "(GC) %s has purged %s.", GET_NAME(ch), GET_NAME(vict));
        mudlog(buf, BRF, LVL_GOD, TRUE);
        if (vict->desc) {
          close_socket(vict->desc);
          vict->desc = NULL;
        }
        remove_player_from_game(vict, QUIT_PURGE);
      } else
        extract_char(vict);
    } else if ((obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, buf)))) {
      act("$n destroys $p.", FALSE, ch, obj, 0, TO_ROOM);
      extract_obj(obj);
    } else {
      send_to_char("Nothing here by that name.\r\n", ch);
      return;
    }
    send_to_char(OK, ch);
  } else {                        /* no argument. clean out the room */
    act("$n gestures... You are surrounded by scorching flames!",
        FALSE, ch, 0, 0, TO_ROOM);
    send_to_room("The world seems a little cleaner.\r\n", ch->in_room);
    for (vict = world[ch->in_room].people; vict; vict = next_v) {
      next_v = vict->next_in_room;
      if (IS_NPC(vict))
        extract_char(vict);
    }
    for (obj = world[ch->in_room].contents; obj; obj = next_o) {
      next_o = obj->next_content;
      if(GET_OBJ_WEAR(obj) != 0) { /* This prevents items w/o take flags from getting purged
                                      like in Fiery v1 RSD */
        extract_obj(obj);
      }
    }
  }
}

ACMD(do_advance)
{
  struct char_data *victim;
  char *name = arg, *level = buf2;
  int newlevel, oldlevel, i;

  two_arguments(argument, name, level);

  if (!*name) {
    cprintf(ch, "Advance who?\r\n");
    return;
  }
  if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, name)))) {
    send_to_char("That player is not here.\r\n", ch);
    return;
  }

  /*
   * I don't know which wise guy commented out this next check, but if
   * they ever do it again, I'll kill them.
   */
  if (GET_LEVEL(ch) <= GET_LEVEL(victim)) {
    send_to_char("Maybe that's not such a great idea.\r\n", ch);
    return;
  }
  if (IS_NPC(victim)) {
    send_to_char("NO!  Not on NPC's.\r\n", ch);
    return;
  }
  if (!*level || (newlevel = atoi(level)) <= 0) {
    send_to_char("That's not a level!\r\n", ch);
    return;
  }
  if (newlevel > LVL_IMPL) {
    sprintf(buf, "%d is the highest possible level.\r\n", LVL_IMPL);
    send_to_char(buf, ch);
    return;
  }


  if (newlevel > GET_LEVEL(ch)) {
    send_to_char("Yeah, right.\r\n", ch);
    return;
  }
  if (newlevel == GET_LEVEL(victim)) {
    send_to_char("They are already at that level.\r\n", ch);
    return;
  }
  oldlevel = GET_LEVEL(victim);
  if (newlevel < GET_LEVEL(victim)) {
    send_to_char("&0&9&bYou are momentarily enveloped by darkness!&0\r\n"
                 "&0&9&bYou feel somewhat diminished.&0\r\n", victim);
  } else {
    act("$n makes some strange gestures.\r\n"
        "A strange feeling comes upon you,\r\n"
        "Like a giant hand, light comes down\r\n"
        "from above, grabbing your body, that\r\n"
        "begins to pulse with colored lights\r\n"
        "from inside.\r\n\r\n"
        "Your head seems to be filled with demons\r\n"
        "from another plane as your body dissolves\r\n"
        "to the elements of time and space itself.\r\n"
        "Suddenly a silent explosion of light\r\n"
        "snaps you back to reality.\r\n\r\n"
        "You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
  }

  if (oldlevel >= LVL_IMMORT && newlevel < LVL_IMMORT) {
    /* If they are no longer an immortal, remove the immortal only flags. */
    REMOVE_FLAG(PRF_FLAGS(victim), PRF_LOG1);
    REMOVE_FLAG(PLR_FLAGS(victim), PRF_LOG2);
    REMOVE_FLAG(PRF_FLAGS(victim), PRF_NOHASSLE);
    REMOVE_FLAG(PLR_FLAGS(victim), PRF_HOLYLIGHT);
    REMOVE_FLAG(PLR_FLAGS(victim), PRF_SHOWVNUMS);
    REMOVE_FLAG(PLR_FLAGS(victim), PRF_ROOMVIS);
    REMOVE_FLAG(PLR_FLAGS(victim), PRF_ROOMVIS);
  }
  else if (oldlevel < LVL_IMMORT && newlevel >= LVL_IMMORT) {
    SET_FLAG(PRF_FLAGS(victim), PRF_HOLYLIGHT);
    SET_FLAG(PRF_FLAGS(victim), PRF_SHOWVNUMS);
    SET_FLAG(PRF_FLAGS(victim), PRF_AUTOEXIT);
    for (i = 1; i <= MAX_SKILLS; i++)
      SET_SKILL(victim, i, 100);
    /* Make sure they have an empty olc zone list */
    free_olc_zone_list(victim);
  }

  cprintf(ch, "%s", OK);

  if (newlevel < oldlevel)
    mprintf(L_STAT, MAX(LVL_IMMORT, GET_LEVEL(ch)),
            "(GC) %s has demoted %s from level %d to %d.",
            GET_NAME(ch), GET_NAME(victim), oldlevel, newlevel);
  else
    mprintf(L_STAT, MAX(LVL_IMMORT, GET_LEVEL(ch)),
            "(GC) %s has advanced %s to level %d (from %d)",
            GET_NAME(ch), GET_NAME(victim), newlevel, oldlevel);

  gain_exp(victim,
           exp_next_level(newlevel - 1, GET_CLASS(victim)) - GET_EXP(victim) + 1,
           GAIN_IGNORE_ALL);
  save_player_char(victim);

  /*
   * Normally, advance_level calls init_mem_list when losing levels,
   * but since we start over from level 1 in do_advance, we need
   * to call it ourselves.
   */
  if (newlevel < oldlevel)
    init_mem_list(victim);
}


void perform_restore(struct char_data *vict)
{
   extern void dispel_harmful_magic(struct char_data *ch);

   dispel_harmful_magic(vict);
   GET_HIT(vict) = MAX(GET_MAX_HIT(vict), GET_HIT(vict));
   GET_MANA(vict) = MAX(GET_MAX_MANA(vict), GET_MANA(vict));
   GET_MOVE(vict) = MAX(GET_MAX_MOVE(vict), GET_MOVE(vict));
   cure_laryngitis(vict);

   /* Since we didn't call alter_hit, which calls hp_pos_check */
   hp_pos_check(vict, NULL, 0);
}


ACMD(do_restore)
{
   struct char_data *vict;
   int i;

   one_argument(argument, buf);
   if (!*buf)
      send_to_char("Whom do you wish to restore?\r\n", ch);
   else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, buf))))
      send_to_char(NOPERSON, ch);
   else {
      send_to_char(OK, ch);
      act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR | TO_SLEEP);
      perform_restore(vict);
      if ((GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_IMMORT)) {
         for (i = 1; i <= TOP_SKILL; i++)
            SET_SKILL(vict, i, 1000);
         effect_total(vict);
      }
   }
}

void perform_pain(struct char_data *vict)
{
   int change;

   change = GET_HIT(vict) * 0.1;
   hurt_char(vict, NULL, change, TRUE);
   change = GET_MOVE(vict) * 0.1;
   alter_move(vict, change);
}


ACMD(do_pain)
{
   struct char_data *vict;

   one_argument(argument, buf);
   if (!(*buf))
      send_to_char("To whom do you wish to cause pain?\r\n",ch);
   else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, buf))))
      send_to_char(NOPERSON, ch);
   else {
      perform_pain(vict);
      send_to_char(OK, ch);
      act("A wave of pain and pesilence sent by $N harms you!", FALSE, vict, 0, ch, TO_CHAR | TO_SLEEP);
   }
}

void perform_immort_vis(struct char_data *ch)
{
  void appear(struct char_data *ch);

  if (GET_INVIS_LEV(ch) == 0 && !EFF_FLAGGED(ch, EFF_INVISIBLE) &&
      !IS_HIDDEN(ch) && !EFF_FLAGGED(ch, EFF_CAMOUFLAGED)) {
    send_to_char("You are already fully visible.\r\n", ch);
    return;
  }

  GET_INVIS_LEV(ch) = 0;
  appear(ch);
  send_to_char("You are now fully visible.\r\n", ch);
}


void perform_immort_invis(struct char_data *ch, int level)
{
  struct char_data *tch;

  if (IS_NPC(ch))
    return;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (tch == ch)
      continue;
    if (GET_LEVEL(tch) >= GET_INVIS_LEV(ch) && GET_LEVEL(tch) < level)
      act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0,
          tch, TO_VICT);
    if (GET_LEVEL(tch) < GET_INVIS_LEV(ch) && GET_LEVEL(tch) >= level)
      act("You suddenly realize that $n is standing beside you.", FALSE, ch, 0,
          tch, TO_VICT);
  }

  GET_INVIS_LEV(ch) = level;
  sprintf(buf, "Your invisibility level is %d.\r\n", level);
  send_to_char(buf, ch);
}


ACMD(do_invis)
{
  int level;

  if (IS_NPC(ch)) {
    send_to_char("You can't do that!\r\n", ch);
    return;
  }

  one_argument(argument, arg);
  if (!*arg) {
    if (GET_INVIS_LEV(ch) > 0)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, GET_LEVEL(ch));
  } else {
    level = atoi(arg);
    if (level > GET_LEVEL(ch))
      send_to_char("You can't go invisible above your own level.\r\n", ch);
    else if (level < 1)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, level);
  }
}


ACMD(do_gecho)
{
  struct descriptor_data *pt;

  skip_spaces(&argument);

  if (!*argument)
    send_to_char("That must be a mistake...\r\n", ch);
  else {
    sprintf(buf, "%s&0\r\n", argument);
    for (pt = descriptor_list; pt; pt = pt->next)
      if (!pt->connected && pt->character && pt->character != ch)
        send_to_char(buf, pt->character);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      send_to_char(buf, ch);
  }
}

/* completely redone in order to add poofs to the pfile */
/* --Fingon                                             */
ACMD(do_poofset)
{
  skip_spaces(&argument);

  switch (subcmd)
  {
  case SCMD_POOFIN:
    if(argument[0] !='\0')
    {
      GET_POOFIN(ch) = strdup(argument);
      sprintf(buf, "Your poofin is now: %s\r\n", GET_POOFIN(ch));
    }
    else
      sprintf(buf, "Your poofin is: %s\r\n", GET_POOFIN(ch));
    break;
  case SCMD_POOFOUT:
    if(argument[0] !='\0')
    {
      GET_POOFOUT(ch) = strdup(argument);
      sprintf(buf, "Your poofin is now: %s\r\n", GET_POOFOUT(ch));
    }
    else
      sprintf(buf, "Your poofout is: %s\r\n", GET_POOFOUT(ch));
    break;
  default:
    return;
    break;
  }

  send_to_char(buf, ch);
}



ACMD(do_dc)
{
  struct descriptor_data *d = NULL;
  int num_to_dc;

  one_argument(argument, arg);
  if ((num_to_dc = atoi(arg))) {
    for (d = descriptor_list; d && d->desc_num != num_to_dc; d = d->next);
    if (!d) {
      send_to_char("No such connection.\r\n", ch);
      return;
    }
  }
  else if (*arg)
    for (d = descriptor_list; d; d = d->next) {
      if (d->character && GET_NAME(d->character) &&
          !strcasecmp(GET_NAME(d->character), arg))
        break;
      if (d->original && GET_NAME(d->original) &&
          !strcasecmp(GET_NAME(d->original), arg))
        break;
    }

  if (!d) {
    send_to_char("Usage: DC <connection number | character name> (type USERS for a list)\r\n", ch);
    return;
  }

  if ((d->character && GET_LEVEL(d->character) >= GET_LEVEL(ch)) ||
      (d->original && GET_LEVEL(d->original) >= GET_LEVEL(ch))) {
    send_to_char("Umm.. maybe that's not such a good idea...\r\n", ch);
    return;
  }
  num_to_dc = d->desc_num;
  close_socket(d);
  sprintf(buf, "Connection #%d closed.\r\n", num_to_dc);
  send_to_char(buf, ch);
  sprintf(buf, "(GC) Connection closed by %s.", GET_NAME(ch));
  log("%s",buf);
}



ACMD(do_wizlock)
{
  int value;
  char *when;

  one_argument(argument, arg);
  if (*arg) {
    value = atoi(arg);
    if (value < 0 || value > GET_LEVEL(ch)) {
      send_to_char("Invalid wizlock value.\r\n", ch);
      return;
    }
    restrict = value;
    when = "now";

    if (restrict)
       restrict_reason = RESTRICT_MANUAL;
    else
       restrict_reason = RESTRICT_NONE;
  } else
    when = "currently";

  switch (restrict) {
  case 0:
    sprintf(buf, "The game is %s completely open.\r\n", when);
    break;
  case 1:
    sprintf(buf, "The game is %s closed to new players.\r\n", when);
    break;
  default:
    sprintf(buf, "Only level %d and above may enter the game %s.\r\n",
            restrict, when);
    break;
  }
  send_to_char(buf, ch);
  if (!*arg && restrict_reason == RESTRICT_AUTOBOOT)
      send_to_char("The restriction was set automatically by the automatic rebooting system.\r\n", ch);
}


ACMD(do_date)
{
  char *tmstr;
  time_t mytime;
  int d, h, m;
  extern time_t *boot_time;

  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
    mytime = boot_time[0];

  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  if (subcmd == SCMD_DATE)
    sprintf(buf, "Current machine time: %s\r\n", tmstr);
  else {
    mytime = time(0) - boot_time[0];
    d = mytime / 86400;
    h = (mytime / 3600) % 24;
    m = (mytime / 60) % 60;

    sprintf(buf, "Up since %s: %d day%s, %d:%02d\r\n", tmstr, d,
            ((d == 1) ? "" : "s"), h, m);
  }

  send_to_char(buf, ch);
}


ACMD(do_force)
{
  struct descriptor_data *i, *next_desc;
  struct char_data *vict, *next_force;
  char to_force[MAX_INPUT_LENGTH + 2];

  half_chop(argument, arg, to_force);

  sprintf(buf1, "$n has forced you to '%s'.", to_force);

  if (!*arg || !*to_force)
    send_to_char("Whom do you wish to force do what?\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GRGOD) || (str_cmp("all", arg) && str_cmp("room", arg))) {
    if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, arg))))
      send_to_char(NOPERSON, ch);
    else if (GET_LEVEL(ch) <= GET_LEVEL(vict))
      send_to_char("No, no, no!\r\n", ch);
    else {
      send_to_char(OK, ch);
      act(buf1, FALSE, ch, NULL, vict, TO_VICT);
      sprintf(buf, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      command_interpreter(vict, to_force);
    }
  } else if (!str_cmp("room", arg)) {
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced room %d to %s", GET_NAME(ch),
          world[ch->in_room].vnum, to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (vict = world[ch->in_room].people; vict; vict = next_force) {
      next_force = vict->next_in_room;
      if (GET_LEVEL(vict) >= GET_LEVEL(ch))
        continue;
      act(buf1, FALSE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  } else { /* force all */
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced all to %s", GET_NAME(ch), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (i = descriptor_list; i; i = next_desc) {
      next_desc = i->next;

      if (i->connected || !(vict = i->character) || GET_LEVEL(vict) >= GET_LEVEL(ch))
        continue;
      act(buf1, FALSE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  }
}



ACMD(do_wiznet)
{
  struct descriptor_data *d;
  char any = FALSE;
  bool explicit_level = FALSE;
  int level = LVL_IMMORT;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument) {
    send_to_char("Usage: wiznet <text> | #<level> <text>\r\n "
                 "       wiznet @@<level> | wiz @@\r\n", ch);
    return;
  }

  switch (*argument) {
  case '#':
    one_argument(argument + 1, buf1);
    if (is_number(buf1)) {
      half_chop(argument+1, buf1, argument);
      level = MAX(atoi(buf1), 1);
      if (level > GET_LEVEL(ch)) {
        send_to_char("You can't wizline above your own level.\r\n", ch);
        return;
      }
      explicit_level = TRUE;
    }
    break;
  case '@@':
    for (d = descriptor_list; d; d = d->next) {
      if (!d->connected && GET_LEVEL(d->character) >= LVL_IMMORT &&
          !PRF_FLAGGED(d->character, PRF_NOWIZ) &&
          (CAN_SEE(ch, d->character) || GET_LEVEL(ch) == LVL_IMPL)) {
        if (!any) {
          sprintf(buf1, "Gods online:\r\n");
          any = TRUE;
        }
        sprintf(buf1, "%s  %s", buf1, GET_NAME(d->character));
        if (PLR_FLAGGED(d->character, PLR_WRITING))
          sprintf(buf1, "%s (Writing)\r\n", buf1);
        else if (EDITING(d))
          sprintf(buf1, "%s (Writing)\r\n", buf1);
        else if (PLR_FLAGGED(d->character, PLR_MAILING))
          sprintf(buf1, "%s (Writing mail)\r\n", buf1);
        else
          sprintf(buf1, "%s\r\n", buf1);

      }
    }
    any = FALSE;
    for (d = descriptor_list; d; d = d->next) {
      if (!d->connected && GET_LEVEL(d->character) >= LVL_IMMORT &&
          PRF_FLAGGED(d->character, PRF_NOWIZ) &&
          CAN_SEE(ch, d->character)) {
        if (!any) {
          sprintf(buf1, "%sGods offline:\r\n", buf1);
          any = TRUE;
        }
        sprintf(buf1, "%s  %s\r\n", buf1, GET_NAME(d->character));
      }
    }
    send_to_char(buf1, ch);
    return;
    break;
  case '\\':
    ++argument;
    break;
  default:
    break;
  }
  if (PRF_FLAGGED(ch, PRF_NOWIZ)) {
    send_to_char("You are offline!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Don't bother the gods like that!\r\n", ch);
    return;
  }

  if (explicit_level) {
    sprintf(buf1, "&6%s: <%d> %s&0\r\n", GET_NAME(ch), level, argument);
    sprintf(buf2, "&6Someone: <%d> %s&0\r\n", level, argument);
  } else {
    sprintf(buf1, "&6%s: %s&0\r\n", GET_NAME(ch), argument);
    sprintf(buf2, "&6Someone: %s&0\r\n", argument);
  }

  for (d = descriptor_list; d; d = d->next) {
    if (!IS_PLAYING(d))
      continue;
    if (STATE(d) != CON_PLAYING || PLR_FLAGGED(d->character, PLR_WRITING) || PLR_FLAGGED(d->character, PLR_MAILING) || EDITING(d))
      if (!PRF_FLAGGED(d->character, PRF_OLCCOMM))
        continue;
    if (d->original ? GET_LEVEL(d->original) < level : GET_LEVEL(d->character) < level)
      continue;
    if (PRF_FLAGGED(d->character, PRF_NOWIZ))
      continue;
    if (d == ch->desc && PRF_FLAGGED(d->character, PRF_NOREPEAT))
      continue;
    if (CAN_SEE(d->character, ch))
      send_to_char(buf1, d->character);
    else
      send_to_char(buf2, d->character);
  }

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
}

/* added for name approval system by fingh 3/31/99 */
/* Complete name approval system redone by Zantir/David Endre 5/4/99 */
void broadcast_name(char *name)
{
  char temp[80];
  struct descriptor_data *d;

  *temp = '\0';

  sprintf(temp, "&2&b%s is awaiting name approval.&0\r\n", name);

  for (d = descriptor_list; d; d = d->next)
    if (IS_PLAYING(d) && d->character &&
        GET_LEVEL(d->character) >= LVL_IMMORT &&
        !PLR_FLAGGED(d->character, PLR_WRITING) &&
        !PLR_FLAGGED(d->character, PLR_MAILING) &&
        !EDITING(d))
     write_to_output(temp, d);
}

char *reasons[] = {
"Compound words. Examples: LadyJade, BraveBlade, ImmortalSoul\r\n These types of names give a player an unearned arrogance above\r\n other players and in some instances above the gods.",
"Offensive words or names, mispelled or backwards. Eg: Sgurd Kcuf Emod",
"Names from known mythos, movies etc... Examples: Feyd, Conan, Zeus\r\n Come on, you can be more creative than reliance on an existing known\r\n character.",
"Names that do not fit the character you are playing. Examples:\r\n A human named Gruzel\r\n A troll named Bob\r\n A boy named Sue\r\n An orc named Ripenthiel",
"No offensive words or names from other languages or cultures.",
"No Nouns verbs or adverbs. Eg. Jester, Red, Dog, Bloody, Hotly, Freedom\r\n Pervert, PC, Trouble, McIntosh, Desperado.  Sorry guys LAME.",
"No names that resemble common nouns verbs or adverbs. Eg. Jesterx,\r\n Redx, Chamelion, Desperato etc...",
"No modern names. Examples: Rina John Mike Steve",
"Other...Please talk to a god for further information."
};

ACMD(do_name)
{
  char buffer[MAX_STRING_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct descriptor_data *d;
  int choice = 0;
  int z = 0;

  *buffer = '\0';

  switch(subcmd)
  {
  case SCMD_ACCEPT:
    one_argument(argument, arg);
    if (!*arg)
    {
      send_to_char("Accept WHO?\r\n", ch);
      return;
    }
    /* cycle through the current connections */
    for (d = descriptor_list; d; d = d->next)
    {

      /* added to stop crashes while people are at CON_QANSI etc. */
      if(!d->character) continue;

      /* make sure player is either at the CON_NAME_WAIT_APPROVAL state
         or has been auto-accepted and still pending approval
         and the player is not yourself
      */
      if (((STATE(d) == CON_NAME_WAIT_APPROVAL) ||
           (PLR_FLAGGED(d->character, PLR_NAPPROVE))) &&
           ((d != ch->desc) &&
           (strn_cmp(GET_NAME(d->character), arg, strlen(arg)) == 0)))
      {
        /* create the player in the pfile if he isn't there already */
        if (GET_PFILEPOS(d->character) < 0) {
          GET_PFILEPOS(d->character) = create_player_index_entry(GET_NAME(d->character));
          /* initialize the the player */
          init_player(d->character);
          /* log the new player */
          sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
          mudlog(buf, NRM, LVL_IMMORT, TRUE);
        }
        /* accept the players name */
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);
        save_player_char(d->character);

        /* log the acceptance of the name */
        sprintf(buf, "The name: %s has been accepted by %s.", GET_NAME(d->character), GET_NAME(ch));
        mudlog(buf, NRM, LVL_IMMORT, TRUE);

        /* remove the choose new name flag */
        if (PLR_FLAGGED(d->character, PLR_NEWNAME))
           REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);

        /* check if the player is waiting approval or already auto approved */
        if(STATE(d) == CON_NAME_WAIT_APPROVAL) {
          /* send the motd and change connection states */
          write_to_output(get_text(TEXT_MOTD), d);
          write_to_output("\r\n\n*** PRESS RETURN: ", d);
          STATE(d) = CON_RMOTD;
        }

        /* tell the player the name has been accepted */
        sprintf(buf, "&2&bThe name: %s has been accepted.&0\r\n", GET_NAME(d->character));
        send_to_char(buf, ch);
        send_to_char(buf, d->character);
        return;
      }
    }
    send_to_char("No such player waiting for approval.\r\n", ch);
    break;
  case SCMD_DECLINE:
    two_arguments(argument, arg, arg2);
    if (!*arg)
    {
      send_to_char("Decline WHO?\r\n", ch);
      return;
    }
    if (!*arg2)
    {
      send_to_char("For what reason? Type 'nlist 0' for a list.\r\n", ch);
      return;
    }

    choice = atoi(arg2);
    choice--;
    if (choice < 0 || choice > 7)
      choice = 8;
    /* cycle through connected players */
    for (d = descriptor_list; d; d = d->next)
    {
      /* added to stop crashes while people are at CON_QANSI etc. */
      if(!d->character) continue;

      if (((STATE(d) == CON_NAME_WAIT_APPROVAL) ||
           (PLR_FLAGGED(d->character, PLR_NAPPROVE))) &&
         (d != ch->desc) &&
         (strn_cmp(GET_NAME(d->character), arg, strlen(arg)) == 0))
      {
         sprintf(buf, "The name: %s has been declined by %s, reason %d.", GET_NAME(d->character), GET_NAME(ch), choice+1);
         mudlog(buf, NRM, LVL_IMMORT, TRUE);
         sprintf(buf, "&2&bThe name: %s has been declined.&0\r\n", GET_NAME(d->character));
         send_to_char(buf, ch);
         send_to_xnames(GET_NAME(d->character));
         write_to_output("That name has been rejected, because it breaks this rule:\r\n", d);
         *buf = '\0';
         sprintf(buf, "%s\r\n", reasons[choice]);
         write_to_output(buf,d);
         SET_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);
         if(STATE(d) == CON_NAME_WAIT_APPROVAL) {
           write_to_output("Please try another name.\r\n", d);
           write_to_output("Name: ", d);
           STATE(d) = CON_NEW_NAME;
         } else {
           write_to_output("&6&bYou are welcome to play; however, you will be prompted&0\r\n&6&bfor a new name on your next login.&0\r\n", d);
           save_player_char(d->character);
         }
         return;
      }
    }
    send_to_char("No such player waiting for approval.\r\n", ch);
    break;
  case SCMD_LIST:
    one_argument(argument, arg);

    if (*arg)
    {
      if (atoi(arg) == 0) {
         *buf = '\0';
         for(z=0;z<8;z++)
            sprintf(buf, "%s%d. %s\r\n", buf, z+1, reasons[z]);
         send_to_char(buf, ch);
      }
    }

    for (d = descriptor_list; d; d = d->next)
    {
      /* added this NULL check to stop crashes when people where CON_QANSI etc */
      if(d->character) {
        if (((STATE(d) == CON_NAME_WAIT_APPROVAL) ||
             (PLR_FLAGGED(d->character, PLR_NAPPROVE) && !(PLR_FLAGGED(d->character, PLR_NEWNAME)))) &&
            (d != ch->desc)) {
          sprintf(buffer, "%s%s\r\n", buffer, GET_NAME(d->character));
        }
      }
    }

    if ( strlen(buffer) < 2)
    {
      sprintf(buffer, "No one.\r\n");
      send_to_char(buffer, ch);
    }
    else
    {
      send_to_char("The following people are awaiting name approval:\r\n", ch);
      send_to_char(buffer, ch);
    }
    break;
  default:
    break; /* maybe send an error to log here? */
  } /* end switch */
}

ACMD(do_zreset)
{
  void reset_zone(int zone, byte pop);

  int i, j;

  one_argument(argument, arg);

  if (!*arg || *arg == '.') {
    i = world[ch->in_room].zone;
  } else if (*arg == '*') {
      if (GET_LEVEL(ch) <= LVL_HEAD_B)
          return;
          for (i = 0; i <= top_of_zone_table; i++)
      reset_zone(i, FALSE);
    send_to_char("Reset world.\r\n", ch);
    sprintf(buf, "(GC) %s reset entire world.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
    return;
  } else if (!isdigit(*arg)) {
    send_to_char("Usage: zreset [<zone-number>]\r\n", ch);
    return;
  } else {
    j = atoi(arg);
    for (i = 0; i <= top_of_zone_table; i++)
      if (zone_table[i].number == j)
        break;
  }
  if (GET_LEVEL(ch) < LVL_GRGOD && !has_olc_access(ch, zone_table[i].number)) {
    send_to_char("Testing testing !!are you clear to do this!! no I dont think so\r\n", ch);
    return;
  }
  if (i >= 0 && i <= top_of_zone_table) {
    reset_zone(i, FALSE);
    sprintf(buf, "Reset zone %d (#%d): %s.\r\n", i, zone_table[i].number,
            zone_table[i].name);
    send_to_char(buf, ch);
    sprintf(buf, "(GC) %s reset zone %d (%s)", GET_NAME(ch), zone_table[i].number, zone_table[i].name);
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("Invalid zone number.\r\n", ch);
}


static char *center_wiztitle(char *wiztitle, int len, int noansi_len) {
  char centerbuf[MAX_INPUT_LENGTH];
  int i;
  bool add_zero;

  /* If the wiztitle doesn't end in &0, put it on. */
  add_zero = (len < 2 || wiztitle[len - 1] != '0' ||
              (wiztitle[len - 2] != CREL && wiztitle[len - 2] != CABS));

  sprintf(centerbuf + ((WIZ_TITLE_WIDTH - noansi_len) / 2), "%s%s", wiztitle, add_zero ? "&0" : "");

  /* +2 for the &0 we just tacked on */
  if (add_zero)
    len += 2;

  for (i = 0; i < (WIZ_TITLE_WIDTH - noansi_len) / 2; ++i) {
    centerbuf[i] = ' ';
    centerbuf[WIZ_TITLE_WIDTH - 1 + (len - noansi_len) - i] = ' ';
  }

  /* if odd-lengthed string, need an extra space to cover up \0 */
  if (noansi_len & 1)
    centerbuf[WIZ_TITLE_WIDTH - 1 + (len - noansi_len) - i] = ' ';
  centerbuf[WIZ_TITLE_WIDTH + (len - noansi_len)] = '\0';

  return strdup(centerbuf);
}

void do_wiztitle(char *outbuf, struct char_data *vict, char *argument)
{
  int noansi_len, len;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  /* check size of title w/out ansi chars */
  len = strlen(argument);
  noansi_len = len - count_color_chars(argument);

  if (IS_NPC(vict))
    sprintf(buf, "Mobile's do not have godly titles...nice try.\r\n");
  else if (strstr(argument, "[") || strstr(argument, "]"))
    sprintf(buf, "Godly Titles can't contain the [ or ] characters.\r\n");
  else if (strlen(argument) >= MAX_INPUT_LENGTH)
    sprintf(buf, "Sorry, godly titles can't be longer than %d characters.\r\n",
            MAX_INPUT_LENGTH - 1);
  else if (noansi_len > WIZ_TITLE_WIDTH)
    sprintf(buf, "Sorry, text portion of godly titles can't be longer than 12 characters.\r\n");
  else if (noansi_len == 0) {
    GET_WIZ_TITLE(vict) = NULL;
    sprintf(buf, "Okay, %s's godly title reset to default.\r\n", GET_NAME(vict));
  }
  else {
    if (GET_WIZ_TITLE(vict))
      free(GET_WIZ_TITLE(vict));
    GET_WIZ_TITLE(vict) = center_wiztitle(argument, len, noansi_len);
    sprintf(buf, "Okay, %s's godly title is now [%s]\r\n", GET_NAME(vict), GET_WIZ_TITLE(vict));
  }
}

/*
 *  General fn for wizcommands of the sort: cmd <player>
 */

ACMD(do_wizutil)
{
  struct char_data *vict;
  long result;

  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Yes, but for whom?!?\r\n", ch);
  else if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, arg))))
    send_to_char("There is no such player.\r\n", ch);
  else if (IS_NPC(vict))
    send_to_char("You can't do that to a mob!\r\n", ch);
  else if (GET_LEVEL(vict) > GET_LEVEL(ch))
    send_to_char("Hmmm...you'd better not.\r\n", ch);
  else {
    switch (subcmd) {
    case SCMD_REROLL:
      send_to_char("Rerolled not functinal for now\r\n", ch);
break;
      /*sprintf(buf, "(GC) %s has rerolled %s.", GET_NAME(ch), GET_NAME(vict));
      log("%s",buf);
      sprintf(buf, "New stats: Str %d/%d, Int %d, Wis %d, Dex %d, Con %d, Cha %d\r\n",
              GET_STR(vict), GET_ADD(vict), GET_INT(vict), GET_WIS(vict),
              GET_DEX(vict), GET_CON(vict), GET_CHA(vict));
      send_to_char(buf, ch);
      break;*/
    case SCMD_PARDON:
      if (!PLR_FLAGGED(vict, PLR_THIEF) && !PLR_FLAGGED(vict, PLR_KILLER)) {
        send_to_char("Your victim is not flagged.\r\n", ch);
        return;
      }
      REMOVE_FLAG(PLR_FLAGS(vict), PLR_THIEF);
      REMOVE_FLAG(PLR_FLAGS(vict), PLR_KILLER);
      send_to_char("Pardoned.\r\n", ch);
      send_to_char("You have been pardoned by the Gods!\r\n", vict);
      sprintf(buf, "(GC) %s pardoned by %s", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_NOTITLE:
      result = PLR_TOG_CHK(vict, PLR_NOTITLE);
      sprintf(buf, "(GC) Notitle %s for %s by %s.", ONOFF(result),
              GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case SCMD_SQUELCH:
      result = PLR_TOG_CHK(vict, PLR_NOSHOUT);
      sprintf(buf, "(GC) Squelch %s for %s by %s.", ONOFF(result),
              GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case SCMD_FREEZE:
      if (ch == vict) {
        send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
        return;
      }
      if (PLR_FLAGGED(vict, PLR_FROZEN)) {
        send_to_char("Your victim is already pretty cold.\r\n", ch);
        return;
      }
      SET_FLAG(PLR_FLAGS(vict), PLR_FROZEN);
      GET_FREEZE_LEV(vict) = GET_LEVEL(ch);
      send_to_char("A bitter wind suddenly rises and drains every erg of heat from your body!\r\nYou feel frozen!\r\n", vict);
      send_to_char("Frozen.\r\n", ch);
      act("A sudden cold wind conjured from nowhere freezes $n!", FALSE, vict, 0, 0, TO_ROOM);
      sprintf(buf, "(GC) %s frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_THAW:
      if (!PLR_FLAGGED(vict, PLR_FROZEN)) {
        send_to_char("Sorry, your victim is not morbidly encased in ice at the moment.\r\n", ch);
        return;
      }
      if (GET_FREEZE_LEV(vict) > GET_LEVEL(ch)) {
        sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n",
           GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
        send_to_char(buf, ch);
        return;
      }
      sprintf(buf, "(GC) %s un-frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      REMOVE_FLAG(PLR_FLAGS(vict), PLR_FROZEN);
      send_to_char("A fireball suddenly explodes in front of you, melting the ice!\r\nYou feel thawed.\r\n", vict);
      send_to_char("Thawed.\r\n", ch);
      act("A sudden fireball conjured from nowhere thaws $n!", FALSE, vict, 0, 0, TO_ROOM);
      break;
    case SCMD_UNAFFECT:
      if (vict->effects) {
        while (vict->effects)
          effect_remove(vict, vict->effects);
        send_to_char("There is a brief flash of light!\r\n"
                     "You feel slightly different.\r\n", vict);
        send_to_char("All spells removed.\r\n", ch);
        check_regen_rates(vict);
        /* if it had been an animated and now isnt then it needs to die */
        if (MOB_FLAGGED(vict, MOB_ANIMATED) &&
            !EFF_FLAGGED(vict, EFF_ANIMATED)) {
          act("$n freezes and falls twitching to the ground.", FALSE, vict, 0,
              0, TO_ROOM);
          die(vict, NULL);
          return;
        }
      } else {
        send_to_char("Your victim does not have any effects!\r\n", ch);
        return;
      }
      break;
    default:
      log("SYSERR: Unknown subcmd passed to do_wizutil (act.wizard.c)");
      break;
    }
    save_player_char(vict);
  }
}


#define PC   1
#define NPC  2
#define BOTH 3

#define MISC        0
#define BINARY        1
#define NUMBER        2

#define SET_OR_REMOVE(flagset, flags) do { \
        if (on) SET_FLAG(flagset, flags); \
        else if (off) REMOVE_FLAG(flagset, flags); } while (0)

#define RANGE(low, high) (value = MAX((low), MIN((high), (value))))

ACMD(do_set)
{
  int i, l;
  struct char_data *vict = NULL, *cbuf = NULL;
  char field[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH], val_arg[MAX_INPUT_LENGTH];
  int on = 0, off = 0, value = 0;
  char is_file = 0, is_mob = 0, is_player = 0, save = TRUE;
  int player_i = 0;
  int get_race_align(struct char_data *ch);
  int parse_diety(struct char_data *ch, char arg);

  struct set_struct {
    char *cmd;
    char level;
    char pcnpc;
    char type;
  } fields[] = {
   { "brief",        LVL_ATTENDANT,   PC,   BINARY }, /* 0*/
   { "",             LVL_GAMEMASTER,  PC,   BINARY }, /* 1*/  /* was invstart, now UNUSED */
   { "title",        LVL_GAMEMASTER,  PC,   MISC   },
   { "nosummon",     LVL_GAMEMASTER,  PC,   BINARY },
   { "maxhit",       LVL_GOD,         BOTH, NUMBER },
   { "maxmana",      LVL_GOD,         BOTH, NUMBER }, /* 5*/
   { "maxmove",      LVL_GOD,         BOTH, NUMBER },
   { "hitpoints",    LVL_GOD,         BOTH, NUMBER },
   { "manapoints",   LVL_GOD,         BOTH, NUMBER },
   { "movepoints",   LVL_GOD,         BOTH, NUMBER },
   { "align",        LVL_GOD,         BOTH, NUMBER }, /*10*/
   { "strength",     LVL_GOD,         BOTH, NUMBER },
   { "stradd",       LVL_GOD,         BOTH, NUMBER },
   { "intelligence", LVL_GOD,         BOTH, NUMBER },
   { "wisdom",       LVL_GOD,         BOTH, NUMBER },
   { "dexterity",    LVL_GOD,         BOTH, NUMBER }, /*15*/
   { "constitution", LVL_GOD,         BOTH, NUMBER },
   { "sex",          LVL_GOD,         BOTH, MISC   },
   { "ac",           LVL_GOD,         BOTH, NUMBER },
   { "olc",          LVL_ADMIN,       PC,   NUMBER },
   { "home",         LVL_GOD,         PC,   NUMBER }, /*20*/  /* THIS ONE CAN BE REPLACED - see homeroom below */
   { "experience",   LVL_ADMIN,       BOTH, NUMBER },
   { "hitroll",      LVL_GOD,         BOTH, NUMBER },
   { "damroll",      LVL_GOD,         BOTH, NUMBER },
   { "invis",        LVL_GAMEMASTER,  PC,   NUMBER },
   { "nohassle",     LVL_GAMEMASTER,  PC,   BINARY }, /*25*/
   { "frozen",       LVL_FREEZE,      PC,   BINARY },
   { "practices",    LVL_GAMEMASTER,  PC,   NUMBER },
   { "lessons",      LVL_GAMEMASTER,  PC,   NUMBER },
   { "drunk",        LVL_GOD,         BOTH, MISC   },
   { "hunger",       LVL_GOD,         BOTH, MISC   }, /*30*/
   { "thirst",       LVL_GOD,         BOTH, MISC   },
   { "killer",       LVL_ADMIN,       PC,   BINARY },
   { "thief",        LVL_ADMIN,       PC,   BINARY },
   { "level",        LVL_ADMIN,       BOTH, NUMBER },
   { "room",         LVL_ATTENDANT,   BOTH, NUMBER }, /*35*/
   { "roomflag",     LVL_ADMIN,       PC,   BINARY },
   { "siteok",       LVL_GAMEMASTER,  PC,   BINARY },
   { "deleted",      LVL_IMPL,        PC,   BINARY },
   { "class",        LVL_ATTENDANT,   BOTH, MISC   },
   { "nowizlist",    LVL_ATTENDANT,   PC,   BINARY }, /*40*/
   { "quest",        LVL_GOD,         PC,   BINARY },
   { "homeroom",     LVL_GOD,         PC,   MISC   },
   { "color",        LVL_GOD,         PC,   BINARY },
   { "idnum",        LVL_IMPL,        PC,   NUMBER },
   { "passwd",       LVL_GAMEMASTER,  PC,   MISC   }, /*45*/
   { "nodelete",     LVL_ATTENDANT,   PC,   BINARY },
   { "charisma",     LVL_GOD,         BOTH, NUMBER },
   { "race",         LVL_GOD,         PC,   MISC   },
   { "olc2",         LVL_ADMIN,       PC,   NUMBER },
   { "olc3",         LVL_ADMIN,       PC,   NUMBER }, /*50*/
   { "olc4",         LVL_ADMIN,       PC,   NUMBER },
   { "olc5",         LVL_ADMIN,       PC,   NUMBER },
   { "platinum",     LVL_GOD,         BOTH, NUMBER },
   { "gold",         LVL_GOD,         BOTH, NUMBER },
   { "silver",       LVL_GOD,         BOTH, NUMBER }, /*55*/
   { "copper",       LVL_GOD,         BOTH, NUMBER },
   { "pbank",        LVL_ATTENDANT,   PC,   NUMBER },
   { "gbank",        LVL_ATTENDANT,   PC,   NUMBER },
   { "sbank",        LVL_ATTENDANT,   PC,   NUMBER },
   { "cbank",        LVL_ATTENDANT,   PC,   NUMBER }, /*60*/
   { "UNUSED",       LVL_IMPL,        PC,   NUMBER },
   { "anon",         LVL_ATTENDANT,   PC,   BINARY },
   { "rename",       LVL_GOD,         PC,   BINARY },
   { "napprove",     LVL_GOD,         PC,   BINARY },
   { "holylight",    LVL_ATTENDANT,   PC,   BINARY }, /*65*/
   { "wiztitle",     LVL_GOD,         PC,   MISC   },
   { "chant",        LVL_GAMEMASTER,  PC,   NUMBER },
   { "size",         LVL_GOD,         PC,   MISC   },
   { "hiddenness",   LVL_GOD,         BOTH, NUMBER },
   { "rage",         LVL_GOD,         BOTH, NUMBER }, /*70*/
   { "ptitle",       LVL_GAMEMASTER,  PC,   MISC   },
   { "height",       LVL_GOD,         BOTH, NUMBER },
   { "weight",       LVL_GOD,         BOTH, NUMBER },
   { "lifeforce",    LVL_GOD,         BOTH, MISC   },
   { "composition",  LVL_GOD,         BOTH, MISC   }, /*75*/
   { "\n",           0,                      BOTH, MISC   }
  };

  half_chop(argument, name, buf);
  if (!strcmp(name, "file")) {
    is_file = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "player")) {
    is_player = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "mob")) {
    is_mob = 1;
    half_chop(buf, name, buf);
  }
  half_chop(buf, field, buf);
  strcpy(val_arg, buf);

  if (!*name || !*field) {
    pprintf(ch, "Usage: set <victim> <field> <value>\r\n");
    pprintf(ch, "Set fields currently available to you:\r\n");
    for (l = 0; *(fields[l].cmd) != '\n'; l++) {
      if (fields[l].level <= GET_LEVEL(ch) && *(fields[l].cmd)) {
        pprintf(ch, "%-20.20s %-20.20s %-6.6s\r\n", fields[l].cmd,
          (fields[l].pcnpc==PC?"Player Only":"Player or Mob"),
          (fields[l].type==BINARY?"Binary":(fields[l].type==NUMBER?"Number":
          "Misc")));
      }
    }
    start_paging(ch);
    return;
  }
  if (!is_file) {
    if (is_player) {
      if (!(vict = find_char_around_char(ch, find_vis_plr_by_name(ch, name)))) {
        send_to_char("There is no such player.\r\n", ch);
        return;
      }
    } else {
      if (!(vict = find_char_around_char(ch, find_vis_by_name(ch, name)))) {
        send_to_char("There is no such creature.\r\n", ch);
        return;
      }
    }
  } else if (is_file) {
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    CREATE(cbuf->player_specials, struct player_special_data, 1);
    if ((player_i = load_player(name, cbuf)) > -1) {
      if (GET_LEVEL(cbuf) >= GET_LEVEL(ch)) {
        free_char(cbuf);
        send_to_char("Sorry, you can't do that.\r\n", ch);
        return;
      }
      vict = cbuf;
    } else {
      free_char(cbuf);
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
  }
  if (GET_LEVEL(ch) != LVL_HEAD_C) {
    if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict) && vict != ch) {
      send_to_char("Maybe that's not such a great idea...\r\n", ch);
      return;
    }
  }
  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  if (IS_NPC(vict) && !(fields[l].pcnpc & NPC)) {
    send_to_char("You can't do that to a beast!\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && !(fields[l].pcnpc & PC)) {
    send_to_char("That can only be done to a beast!\r\n", ch);
    return;
  }
  if (fields[l].type == BINARY) {
    if (!strcmp(val_arg, "on") || !strcmp(val_arg, "yes"))
      on = 1;
    else if (!strcmp(val_arg, "off") || !strcmp(val_arg, "no"))
      off = 1;
    if (!(on || off)) {
      send_to_char("Value must be on or off.\r\n", ch);
      return;
    }
  } else if (fields[l].type == NUMBER) {
    value = atoi(val_arg);
  }

  strcpy(buf, OK);
  switch (l) {
  case 0:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_BRIEF);
    break;
  case 1:
    send_to_char("This option is unused.  You should not have seen this!\r\n", ch);
    return;
  case 2:
    set_title(vict, val_arg);
    sprintf(buf, "%s's title is now: %s\r\n", GET_NAME(vict), GET_TITLE(vict));
    break;
  case 3:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_SUMMONABLE);
    on = !on;                        /* so output will be correct */
    break;
  case 4:
    /* Base hit is in a player special. Don't set for npcs */
    if (IS_NPC(vict))
      GET_MAX_HIT(vict) = RANGE(1, 500000);
    else {
      GET_BASE_HIT(vict) = RANGE(1, 500000);
      effect_total(vict);
    }
    break;
  case 5:
    vict->points.max_mana = RANGE(1, 500000);
    effect_total(vict);
    break;
  case 6:
    vict->points.max_move = RANGE(1, 500000);
    effect_total(vict);
    break;
  case 7:
    vict->points.hit = RANGE(-9, vict->points.max_hit);
    effect_total(vict);
    break;
  case 8:
    vict->points.mana = RANGE(0, vict->points.max_mana);
    effect_total(vict);
    break;
  case 9:
    vict->points.move = RANGE(0, vict->points.max_move);
    effect_total(vict);
    break;
  case 10:
    GET_ALIGNMENT(vict) = RANGE(-1000, 1000);
    effect_total(vict);
    break;
  case 11:
    GET_NATURAL_STR(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 12:
    /*  This is no longer used --Gurlaek 6/23/1999
    vict->view_abils.str_add = RANGE(0, 100);
    vict->view_abils.str_add = value;
    if (value > 0)
      vict->view_abils.str = 100;
    effect_total(vict);
    */
    break;
    /*Edited by Proky,  values for intel*/
  case 13:
    GET_NATURAL_INT(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 14:
    GET_NATURAL_WIS(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 15:
    GET_NATURAL_DEX(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 16:
    GET_NATURAL_CON(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 17:
    if (!str_cmp(val_arg, "male"))
      vict->player.sex = SEX_MALE;
    else if (!str_cmp(val_arg, "female"))
      vict->player.sex = SEX_FEMALE;
    else if (!str_cmp(val_arg, "neutral"))
      vict->player.sex = SEX_NEUTRAL;
    else {
      send_to_char("Must be 'male', 'female', or 'neutral'.\r\n", ch);
      return;
    }
    break;
  case 18:
    GET_AC(vict) = RANGE(MIN_AC, MIN_AC);
    effect_total(vict);
    break;
  case 19:
    {
      struct olc_zone_list dummy, *zone, *next;
      dummy.next = GET_OLC_ZONES(vict);
      for (zone = &dummy, i = FALSE; zone->next; zone = next) {
        next = zone->next;
        /* If in list, remove it */
        if (next->zone == value) {
          zone->next = next->next;
          free(next);
          i = TRUE;
          sprintf(buf, "Removed %d from %s allowed OLC zones.\r\n", value, GET_NAME(vict));
          break;
        }
      }
      GET_OLC_ZONES(vict) = dummy.next;
      /* If i is false, we didn't find it, so add it */
      if (!i) {
        CREATE(zone, struct olc_zone_list, 1);
        zone->zone = value;
        zone->next = GET_OLC_ZONES(vict);
        GET_OLC_ZONES(vict) = zone;
        sprintf(buf, "Added %d to %s allowed OLC zones.\r\n", value, GET_NAME(vict));
      }
    }
    break;
  case 20:
    GET_HOMEROOM(vict) = value;
    break;
  case 21:
    vict->points.exp = RANGE(0, 299999999);
    break;
  case 22:
    GET_BASE_HITROLL(vict) = RANGE(MIN_DAMROLL, MAX_DAMROLL);
    effect_total(vict);
    break;
  case 23:
    GET_BASE_DAMROLL(vict) = RANGE(MIN_DAMROLL, MAX_DAMROLL);
    effect_total(vict);
    break;
  case 24:
    if (GET_LEVEL(ch) < LVL_HEAD_C && ch != vict) {
      strcpy(buf, "You aren't godly enough for that!\r\n");
      save = FALSE;
      break;
    }
    GET_INVIS_LEV(vict) = RANGE(0, GET_LEVEL(vict));
    break;
  case 25:
    if (GET_LEVEL(ch) < LVL_HEAD_C && ch != vict) {
      strcpy(buf, "You aren't godly enough for that!\r\n");
      save = FALSE;
      break;
    }
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_NOHASSLE);
    break;
  case 26:
    if (ch == vict) {
      send_to_char("Better not -- could be a long winter!\r\n", ch);
      /* OK: ch == vict so no memory was allocated */
      return;
    }
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_FROZEN);
    break;
  case 27:
  case 28:
    /* GET_PRACTICES(vict) = RANGE(0, 100); */
    break;
  case 29:
  case 30:
  case 31:
    if (!str_cmp(val_arg, "off")) {
      GET_COND(vict, (l - 29)) = (char) -1;
      sprintf(buf, "%s's %s now off.\r\n", GET_NAME(vict), fields[l].cmd);
    } else if (is_number(val_arg)) {
      value = atoi(val_arg);
      RANGE(0, 24);
      GET_COND(vict, (l - 29)) = (char) value;
      sprintf(buf, "%s's %s set to %d.\r\n", GET_NAME(vict), fields[l].cmd,
              value);
    } else {
      strcpy(buf, "Must be 'off' or a value from 0 to 24.\r\n");
      save = FALSE;
      break;
    }
    check_regen_rates(vict);
    break;
  case 32:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_KILLER);
    break;
  case 33:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_THIEF);
    break;
  case 34:
    if (value > GET_LEVEL(ch) || value > LVL_OVERLORD) {
      strcpy(buf, "You can't do that.\r\n");
      save = FALSE;
      break;
    }
    if (GET_CLAN(vict) && IS_CLAN_MEMBER(vict))
      GET_CLAN(vict)->power -= GET_LEVEL(vict);
    RANGE(0, LVL_IMPL);
    vict->player.level = (byte) value;
    if (GET_CLAN(vict) && IS_CLAN_MEMBER(vict))
      GET_CLAN(vict)->power += GET_LEVEL(vict);
    break;
  case 35:
    if ((i = real_room(value)) < 0) {
      strcpy(buf, "No room exists with that number.\r\n");
      save = FALSE;
      break;
    }
    if (!is_file) {
      if (IN_ROOM(vict) != NOWHERE)
        char_from_room(vict);
      char_to_room(vict, i);
    }
    break;
  case 36:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_ROOMFLAGS);
    break;
  case 37:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_SITEOK);
    break;
  case 38:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_DELETED);
    break;
  case 39:
    if ((i = parse_class(ch, vict, val_arg)) == CLASS_UNDEFINED) {
      save = FALSE;
      buf[0] = '\0'; /* Don't say "Okay", we just gave feedback. */
      break;
    }
    if (i == GET_CLASS(vict)) {
       sprintf(buf, "%s already %s.",
           vict == ch ? "You're" : "$e's",
           with_indefinite_article(CLASS_FULL(vict)));
    } else {
      convert_class(vict, i);
      if (ch != vict) {
        sprintf(buf, "$n has changed your class to %s!", CLASS_FULL(vict));
        act(buf, FALSE, ch, 0, vict, TO_VICT);
      }
      sprintf(buf, "Okay, %s now %s.",
          vict == ch ? "you are" : "$n is",
          with_indefinite_article(CLASS_FULL(vict)));
    }
    act(buf, FALSE, vict, 0, ch, TO_VICT);
    buf[0] = '\0'; /* Don't say "Okay", we just gave feedback. */
    break;
  case 40:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOWIZLIST);
    break;
  case 41:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_QUEST);
    break;
  case 42:
    if (is_number(val_arg)) {
      value = atoi(val_arg);
      if (real_room(value) != NOWHERE) {
        GET_HOMEROOM(vict) = value;
        sprintf(buf, "%s's home room is now #%d.\r\n", GET_NAME(vict),
                GET_HOMEROOM(vict));
      } else {
        strcpy(buf, "That room does not exist!\r\n");
        save = FALSE;
      }
    } else {
      strcpy(buf, "Must be a room's virtual number.\r\n");
      save = FALSE;
    }
    break;
  case 43:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_COLOR_1);
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_COLOR_2);
    break;
  case 44:
    if (GET_IDNUM(ch) != 1 || IS_NPC(vict))
      return;
    GET_IDNUM(vict) = value;
    break;
  case 45:
    if (!is_file) {
      send_to_char("Not while they're logged in!\r\n", ch);
      return;
    }
    if (GET_IDNUM(ch) > 2 && !strcasecmp(GET_NAME(ch),"zuur")) {
      strcpy(buf, "Please don't use this command, yet.\r\n");
      save = FALSE;
    }
    else if (GET_LEVEL(vict) > LVL_HEAD_C) {
      strcpy(buf, "You cannot change that.\r\n");
      save = FALSE;
    }
    else {
      strncpy(GET_PASSWD(vict), CRYPT(val_arg, GET_NAME(vict)), MAX_PWD_LENGTH);
      GET_PASSWD(vict)[MAX_PWD_LENGTH] = '\0';
      sprintf(buf, "Password changed to '%s'.\r\n", val_arg);
    }
    break;
  case 46:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NODELETE);
    break;
  case 47:
    GET_NATURAL_CHA(vict) = RANGE(MIN_ABILITY_VALUE, MAX_ABILITY_VALUE);
    effect_total(vict);
    break;
  case 48:
    if ((i = parse_race(ch, vict, val_arg)) == RACE_UNDEFINED) {
      save = FALSE;
      buf[0] = '\0'; /* Don't say "Okay", we just gave feedback. */
      break;
    }
    if (i == GET_RACE(vict)) {
       sprintf(buf, "%s already %s.",
           vict == ch ? "You're" : "$e's",
           with_indefinite_article(RACE_FULL(vict)));
    } else {
      convert_race(vict, i);
      if (ch != vict) {
        sprintf(buf, "$n has changed your race to %s!", RACE_FULL(vict));
        act(buf, FALSE, ch, 0, vict, TO_VICT);
      }
      sprintf(buf, "Okay, %s now %s.",
          vict == ch ? "you are" : "$n is",
          with_indefinite_article(RACE_FULL(vict)));
    }
    act(buf, FALSE, vict, 0, ch, TO_VICT);
    buf[0] = '\0'; /* Don't say "Okay", we just gave feedback. */
    break;
  case 49:
    /* GET_OLC2_ZONE(vict) = value; */
    break;
  case 50:
    /* GET_OLC3_ZONE(vict) = value; */
    break;
  case 51:
    /* GET_OLC4_ZONE(vict) = value; */
    break;
  case 52:
    /* GET_OLC5_ZONE(vict) = value; */
    break;
  case 53:
    GET_PLATINUM(vict) = RANGE(0, 100000000);
    break;
  case 54:
    GET_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 55:
    GET_SILVER(vict) = RANGE(0, 100000000);
    break;
  case 56:
    GET_COPPER(vict) = RANGE(0, 100000000);
    break;
  case 57:
    GET_BANK_PLATINUM(vict) = RANGE(0, 100000000);
    break;
  case 58:
    GET_BANK_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 59:
    GET_BANK_SILVER(vict) = RANGE(0, 100000000);
    break;
  case 60:
    GET_BANK_COPPER(vict) = RANGE(0, 100000000);
    break;

  case 61:
    break;
  case 62:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_ANON);
    break;
  case 63:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NEWNAME);
    break;
  case 64:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NAPPROVE);
    break;
  case 65:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_HOLYLIGHT);
    break;
  case 66:
    do_wiztitle(buf, vict, val_arg);
    break;
  case 67:
    GET_COOLDOWN(vict, CD_CHANT) = RANGE(0, 100);
    break;
  case 68:
    if (!*val_arg) {
      show_sizes(ch);
      save = FALSE;
      buf[0] = '\0';
      break;
    } else if ((value = parse_size(ch, val_arg)) == SIZE_UNDEFINED) {
      save = FALSE;
      buf[0] = '\0';
      break;
    }
    change_natural_size(vict, value);
    sprintf(buf, "%s %s now %s in size.\r\n",
            ch == vict ? "You" : GET_NAME(vict),
            ch == vict ? "are" : "is",
            SIZE_DESC(vict));
    break;
  case 69:
    GET_HIDDENNESS(vict) = RANGE(0, 1000);
    break;
  case 70:
    GET_RAGE(vict) = RANGE(0, 1000);
    check_regen_rates(vict);
    break;
  case 71:
    argument = any_one_arg(val_arg, field);
    skip_spaces(&argument);
    i = atoi(field);
    value = 1;
    if (GET_PERM_TITLES(ch))
      for (; GET_PERM_TITLES(ch)[value - 1]; ++value);
    if (i < 1 || i > value)
      sprintf(buf, "You can only set ptitles from 1 to %d.\r\n", value);
    else {
      if (strlen(argument) > MAX_TITLE_WIDTH)
        argument[MAX_TITLE_WIDTH] = '\0';
      if (i == value)
        add_perm_title(vict, argument);
      else {
        if (GET_PERM_TITLES(vict)[i - 1])
          free(GET_PERM_TITLES(vict)[i - 1]);
        GET_PERM_TITLES(vict)[i - 1] = strdup(argument);
      }
      sprintf(buf, "%s's p-title %d is now: %s\r\n", GET_NAME(vict), i,
              GET_PERM_TITLES(vict)[i - 1]);
    }
    break;
  case 72:
    GET_HEIGHT(vict) = value;
    break;
  case 73:
    GET_WEIGHT(vict) = value;
    break;
  case 74: /* LIFE FORCE */
    if ((i = parse_lifeforce(ch, val_arg)) == LIFE_UNDEFINED) {
      save = FALSE;
      buf[0] = '\0';
      break;
    }
    if (i == GET_LIFEFORCE(vict)) {
       sprintf(buf, "%s already infused with %s.",
           vict == ch ? "You're" : "$e's", LIFEFORCE_NAME(vict));
    } else {
      if (ch != vict) {
        sprintf(buf, "$n has changed your life force to %s!", lifeforces[i].name);
        act(buf, FALSE, ch, 0, vict, TO_VICT);
      }
      sprintf(buf, "Okay, %s's life force is now %s.",
          vict == ch ? "you are" : "$n is",
          lifeforces[i].name);
      convert_lifeforce(vict, i);
    }
    act(buf, FALSE, vict, 0, ch, TO_VICT);
    buf[0] = '\0';
    break;
  case 75: /* COMPOSITION */
    if ((i = parse_composition(ch, val_arg)) == COMP_UNDEFINED) {
      save = FALSE;
      buf[0] = '\0';
      break;
    }
    if (i == BASE_COMPOSITION(vict)) {
       sprintf(buf, "%s already composed of %s.",
           vict == ch ? "You're" : "$e's", compositions[i].name);
    } else {
      if (ch != vict) {
        sprintf(buf, "$n has changed your composition to %s!", compositions[i].name);
        act(buf, FALSE, ch, 0, vict, TO_VICT);
      }
      sprintf(buf, "Okay, %s now composed of %s.",
          vict == ch ? "you are" : "$n is",
          compositions[i].name);
      set_base_composition(vict, i);
    }
    act(buf, FALSE, vict, 0, ch, TO_VICT);
    buf[0] = '\0';
    break;
  default:
    sprintf(buf, "Can't set that!\r\n");
    break;
  }

  if (fields[l].type == BINARY) {
    sprintf(buf, "%s %s for %s.\r\n", fields[l].cmd, ONOFF(on),
            GET_NAME(vict));
    CAP(buf);
  } else if (fields[l].type == NUMBER) {
    sprintf(buf, "%s's %s set to %d.\r\n", GET_NAME(vict),
            fields[l].cmd, value);
  }
  if (buf[0])
    send_to_char(CAP(buf), ch);

  if (!is_file && !IS_NPC(vict) && save)
    save_player_char(vict);

  if (is_file) {
    if (save) {
      GET_PFILEPOS(cbuf) = player_i;
      save_player_char(cbuf);
      send_to_char("Saved in file.\r\n", ch);
    }
    free_char(cbuf);
  }
}


ACMD(do_syslog)
{
  int severity;

  one_argument(argument, arg);

  if (!*arg) {
    cprintf(ch, "The minimum severity of syslog messages you see is %s.\r\n",
            sprint_log_severity(GET_LOG_VIEW(ch)));
    return;
  }

  if ((severity = parse_log_severity(arg)) < 0) {
    cprintf(ch, "Usage: syslog [ ");
    for (severity = 0; *log_severities[severity] != '\n'; ++severity)
      cprintf(ch, "%s%s", severity ? " | " : "", log_severities[severity]);
    cprintf(ch, " ]\r\n");
    return;
  }

  GET_LOG_VIEW(ch) = severity;

  cprintf(ch, "The minimum severity of syslog messages you will see is now %s.\r\n",
          sprint_log_severity(severity));
}


 void send_to_imms(char *msg)
 {
   struct descriptor_data *pt;

   for (pt = descriptor_list; pt; pt = pt->next)
     if (!pt->connected && pt->character && GET_LEVEL(pt->character) >= LVL_GOD)
         send_to_char(msg, pt->character);

 }


/* do_game recoded by 321 to allow different toggles to have different
 * minimum levels */
ACMD(do_game)
{
  char field[MAX_INPUT_LENGTH], rest[MAX_INPUT_LENGTH];
  char shortbuf[40], linebuf[160];
  int i, n_visible = 0, value;
  char *msg;

  struct {
    char *name;
    int has_value;  /* Is it on/off (0) or does it have a value (1) */
    int *config;
    int min_level;
    char *turn_on;
    char *turn_off;
    char *enabled;
    char *disabled;
  } commands[] = {
    { "RACES", 0,     &races_allowed,         LVL_ADMIN,
      "[&2&bSYS: %s allows race logins&0]\r\n",
      "[&1&bSYS: %s disallows race logins&0]\r\n",
      "Race login allowed",
      "Race login not allowed" },
    { "EVILRACES",0, &evil_races_allowed,    LVL_ADMIN,
      "[&2&bSYS: %s allows evil race player creation&0]\r\n",
      "[&1&bSYS: %s disallows evil race player creation&0]\r\n",
      "Evil race player creation allowed",
      "Evil race player creation not allowed" },
    { "PK",     0,    &pk_allowed,            LVL_ADMIN,
      "[&2&bSYS: %s allows PKilling&0]\r\n",
      "[&1&bSYS: %s disallows PKilling&0]\r\n",
      "PKilling allowed",
      "PKilling not allowed" },
    { "SLEEP",  0,    &sleep_allowed,         LVL_ADMIN,
      "[&2&bSYS: %s allows players to cast sleep on each other&0]\r\n",
      "[&1&bSYS: %s disallows players from casting sleep on each other&0]\r\n",
      "Casting sleep on other players allowed",
      "Casting sleep on other players not allowed" },
    { "SUMMON", 0,  &summon_allowed,        LVL_ADMIN,
      "[&2&bSYS: %s allows players to summon one another&0]\r\n",
      "[&1&bSYS: %s disallows players from summoning one another&0]\r\n",
      "Summoning other players allowed",
      "Summoning other players not allowed" },
    { "CHARM",  0,  &charm_allowed,         LVL_ADMIN,
      "[&2&bSYS: %s allows players to cast charm on each other&0]\r\n",
      "[&1&bSYS: %s disallows players from casting charm on each other&0]\r\n",
      "Charming other players allowed",
      "Charming other players not allowed" },
    { "ROOMEFFECT",0, &roomeffect_allowed,    LVL_ADMIN,
      "[&2&bSYS: %s allows room effect spells to hurt other players&0]\r\n",
      "[&1&bSYS: %s disallows room effect spells from hurting other players&0]\r\n",
      "Room effect spells will hurt other players",
      "Room effect spells will not hurt other players" },
    { "NAMES",  0,  &approve_names,         LVL_ADMIN,
      "[&2&bSYS: %s turned on name approval&0]\r\n",
      "[&1&bSYS: %s turned off name approval&0]\r\n",
      "Name approval is required",
      "Name approval is NOT required" },
    { "NPAUSE", 0,  &napprove_pause,        LVL_ADMIN,
      "[&2&bSYS: %s turned on name approval pause&0]\r\n",
      "[&1&bSYS: %s turned off name approval pause&0]\r\n",
      "Name approval pause is ON",
      "Name approval pause is OFF" },
    { "OOC",    0,  &gossip_channel_active, LVL_ATTENDANT,
      "[&2&bSYS: %s enables OOC! ANARCHY!&0]\r\n",
      "[&1&bSYS: %s diables OOC! GAWD SAVE THE QUEEN!&0]\r\n",
      "OOC is enabled",
      "OOC is disabled" },
    { "SLOWNS", 0,  &nameserver_is_slow,    LVL_HEAD_C,
      "[&2&bSYS: %s turns off hostname lookup.&0]\r\n",
      "[&1&bSYS: %s turns on hostname lookup.&0]\r\n",
      "Nameserver lookup is disabled: slowns is on",
      "Nameserver lookup is enabled: slowns os off"},
    { "LEVELGAIN",0,  &level_gain,            LVL_BUILDER,
      "[&2&bSYS: %s turned on \"level gain\" code.&0]\r\n",
      "[&1&bSYS: %s turned off \"level gain\" code.&0]\r\n",
      "\"level gain\" code is active: levelgain is on",
      "\"level gain\" code is inactive: levelgain is off"},
    { "DAMAGEAMTS", 0, &damage_amounts,            LVL_BUILDER,
      "[&2&bSYS: %s turned on display damage amounts code.&0]\r\n",
      "[&1&bSYS: %s turned off display damage amounts code.&0]\r\n",
      "Display damage code is active: damageamts is on",
      "Display damage code is inactive: damageamts is off"},
    { "GROUPING", 1, &max_group_difference, LVL_ATTENDANT,
      "[&2&bSYS: %s set the max group level difference to %i.&0]\r\n",
      "[&1&bSYS: %s turned off the max group level difference.&0]\r\n",
      "Max group level difference is set to: ",
      "Max group level difference is off: " },

    { NULL, 0,  NULL, 0, NULL, NULL, NULL, NULL }
  };

  half_chop(argument, field, rest);

  for (i = 0; commands[i].name; i++)
    if ((GET_LEVEL(ch) >= commands[i].min_level) &&
        !strcasecmp(field, commands[i].name))
      break;


  if (!commands[i].name) {
    for (i = 0; commands[i].name; i++)
      if (GET_LEVEL(ch) >= commands[i].min_level) {
        if (!n_visible++)
          send_to_char("\r\n[Current game status:]\r\n\r\n", ch);

        sprintf(shortbuf, "[%s%s&0]", *commands[i].config ? "&2&b" : "&1&b",
                commands[i].name);

        if (commands[i].has_value) {

          sprintf(linebuf, "%-19s%s %i\r\n", shortbuf, *commands[i].config ?
                  commands[i].enabled : commands[i].disabled,
                  *commands[i].config);
        }
        else {
          sprintf(linebuf, "%-19s%s\r\n", shortbuf, *commands[i].config ?
                  commands[i].enabled : commands[i].disabled);

        };

        send_to_char(linebuf, ch);
      }
    if (!n_visible)
      send_to_char("You do not have access to any game config toggles", ch);
    return;
  }


  if (commands[i].has_value) {

    sscanf(rest, "%i", &value);
    *commands[i].config = value;
    msg = ((value ? commands[i].turn_on : commands[i].turn_off));
  }
  else
    {

    /* if we've gotten this far then the field was recognized and of suitable
     * level. toggle it and send an appropriate message */
  msg = ((*commands[i].config = !*commands[i].config) ? commands[i].turn_on :
         commands[i].turn_off);

    };

  if (commands[i].has_value) {

    sprintf(linebuf, msg, GET_NAME(ch), value);
    send_to_imms(linebuf);
  } else {

    sprintf(linebuf, msg, GET_NAME(ch));
    send_to_imms(linebuf);
  };
}

ACMD(do_autoboot)
{
   extern void check_auto_rebooting();
   extern void cancel_auto_reboot(int postponed);
   char field[MAX_INPUT_LENGTH];
   char field2[MAX_INPUT_LENGTH];
   char *s;
   unsigned int hours, mins, minutes;

   extern void reboot_info(struct char_data *ch);

   argument = any_one_arg(argument, field);
   argument = any_one_arg(argument, field2);

   if (!*field) {
      if (GET_LEVEL(ch) >= LVL_REBOOT_POSTPONE) {
         send_to_char("Usage:\r\n", ch);
         if (GET_LEVEL(ch) >= LVL_REBOOT_MASTER) {
            send_to_char("  autoboot off           - disable automatic reboot\r\n", ch);
            send_to_char("  autoboot on            - enable automatic reboot\r\n", ch);
            sprintf(buf, "  autoboot warntime <mn> - warnings begin <mn> minutes before reboot (now %d)\r\n",
                  reboot_warning_minutes);
            send_to_char(buf, ch);
            send_to_char("  autoboot [<hr>][:<mn>] - reboot in <hr> hours, <mn> minutes\r\n", ch);
         }
         sprintf(buf, "  autoboot postpone      - postpone reboot to %d minutes from now\r\n",
               2 * reboot_warning_minutes);
         send_to_char(buf, ch);
         send_to_char("\r\n", ch);
      }

      reboot_info(ch);
      return;
   }

   if (!strcmp(field, "postpone")) {
      if (GET_LEVEL(ch) < LVL_REBOOT_POSTPONE) {
         send_to_char("You can't do that.\r\n", ch);
         return;
      }

      if (!reboot_auto) {
         send_to_char("Automatic rebooting isn't even enabled!\r\n", ch);
         return;
      }

      minutes = 2 * reboot_warning_minutes;

      if (reboot_pulse - global_pulse > minutes * 60 * PASSES_PER_SEC) {
         sprintf(buf, "Not postponing reboot because it's over %d minutes away.\r\n",
               2 * reboot_warning_minutes);
         send_to_char(buf, ch);
         return;
      }

      reboot_pulse = global_pulse + minutes * 60 * PASSES_PER_SEC;

      sprintf(buf, "[ %s postponed autoboot for %d minutes ]\r\n", GET_NAME(ch),
            minutes);
      send_to_imms(buf);
      sprintf(buf, "(GC) %s postponed autoboot for %d minutes.", GET_NAME(ch),
            minutes);
      log("%s",buf);

      cancel_auto_reboot(1);
      return;
   }

   if (!strcmp(field, "on")) {
      if (GET_LEVEL(ch) < LVL_REBOOT_MASTER) {
         send_to_char("You can't do that.\r\n", ch);
         return;
      }

      if (reboot_auto) {
         send_to_char("Automatic rebooting is already on.\r\n", ch);
         reboot_info(ch);
         return;
      }
      reboot_auto = TRUE;
      sprintf(buf, "[ %s set autoboot to &2&bON&0 ]\r\n", GET_NAME(ch));
      send_to_imms(buf);
      sprintf(buf, "(GC) %s turned on autoboot.", GET_NAME(ch));
      log("%s",buf);

      /* Make sure the reboot is a minimum amount of time away */
      if (reboot_pulse - global_pulse < 60 * PASSES_PER_SEC * reboot_warning_minutes) {
         reboot_pulse = global_pulse + 60 * PASSES_PER_SEC * reboot_warning_minutes;
      }
      check_auto_rebooting();
      return;
   }

   if (!strcmp(field, "off")) {
      if (GET_LEVEL(ch) < LVL_REBOOT_MASTER) {
         send_to_char("You can't do that.\r\n", ch);
         return;
      }

      if (!reboot_auto) {
         send_to_char("Automatic rebooting is already off.\r\n", ch);
         return;
      }

      reboot_auto = FALSE;
      sprintf(buf, "[ %s set autoboot to &1&bOFF&0 ]\r\n", GET_NAME(ch));
      send_to_imms(buf);
      sprintf(buf, "(GC) %s turned off autoboot.", GET_NAME(ch));
      log("%s",buf);

      cancel_auto_reboot(0);
      return;
   }

   if (!strcmp(field, "warntime")) {
      if (GET_LEVEL(ch) < LVL_REBOOT_MASTER) {
         send_to_char("You can't do that.\r\n", ch);
         return;
      }

      if (!*field2) {
         send_to_char("Set the reboot warning to how many minutes?\r\n", ch);
         return;
      }
      mins = strtoul(field2, NULL, 10);
      if (mins < 1) {
         send_to_char("Invalid setting - must be 1 or greater.\r\n", ch);
         return;
      }
      reboot_warning_minutes = mins;

      sprintf(buf, "[ %s set reboot warning time to %d minutes ]\r\n", GET_NAME(ch),
            reboot_warning_minutes);
      send_to_imms(buf);
      sprintf(buf, "(GC) %s set reboot warning time to %d minutes.", GET_NAME(ch),
            reboot_warning_minutes);
      log("%s",buf);

      /* The rest of this block is about managing warnings, which is moot
       * unless reboot_auto is true, so: */
      if (!reboot_auto) return;

      /* See how many minutes until the reboot. */
      minutes = (reboot_pulse - global_pulse) / (60 * PASSES_PER_SEC);

      if (reboot_warning_minutes >= minutes && !reboot_warning) {
         check_auto_rebooting();
      } else if (reboot_warning) {
         /* You've set reboot_warning_minutes lower - but a moment ago, we were
          * sending warnings about an impending reboot. Set this to 0 to reflect
          * the fact that we are not sending warnings any more. */
         reboot_warning = 0;
      }
      return;
   }

   /* Any other parameter is taken to be an amount of time until an automatic reboot.
    * It may be:
    *    ##       - number of hours
    *    ##:##    - hours and minutes
    *    :##      - minutes only */

   hours = 0;
   minutes = 0;
   mins = 0;

   if (field[0] == ':' && strlen(field) > 1) {
      /* minutes only */
      mins = strtoul(field + 1, NULL, 10);
   } else {
      hours = strtoul(field, NULL, 10);
      s = strchr(field, ':');
      if (s && s[1]) {
         mins = strtoul(s + 1, NULL, 10);
      }
   }

   minutes = mins + hours * 60;

   if (minutes > 0) {
      if (GET_LEVEL(ch) < LVL_REBOOT_MASTER) {
         send_to_char("You can't do that.\r\n", ch);
         return;
      }

      reboot_auto = TRUE;
      sprintf(buf, "[ %s set the mud to reboot in &7&b%02d:%02d&0 ]\r\n",
            GET_NAME(ch), hours, mins);
      send_to_imms(buf);
      sprintf(buf, "(GC) %s set the mud to reboot in %02d:%02d.",
            GET_NAME(ch), hours, mins);
      log("%s",buf);

      reboot_pulse = global_pulse + 60 * PASSES_PER_SEC * minutes;
      if (minutes <= reboot_warning_minutes) {
         check_auto_rebooting();
      } else
         cancel_auto_reboot(0);
   } else {
      send_to_char("Sorry, I don't understand that.\r\n", ch);
   }
}

ACMD(do_copyto)
{

  /* Only works if you have Oasis OLC */

  char buf2[10];
  char buf[80];
  int iroom = 0, rroom = 0;
  struct room_data *room;

  one_argument(argument, buf2);
  /* buf2 is room to copy to */

  CREATE (room, struct room_data, 1);

  iroom = atoi(buf2);
  rroom = real_room(atoi(buf2));
  *room = world[rroom];

  if (!*buf2) {
    send_to_char("Format: copyto <room number>\r\n", ch);
    return; }
  if (rroom <= 0) {
    sprintf(buf, "There is no room with the number %d.\r\n", iroom);
    send_to_char(buf, ch);
    return; }

  /* Main stuff */

  if (world[ch->in_room].description) {
    world[rroom].description = strdup(world[ch->in_room].description);

    /* Only works if you have Oasis OLC */
  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);

  sprintf(buf, "You copy the description to room %d.\r\n", iroom);
  send_to_char(buf, ch); }
  else
        send_to_char("This room has no description!\r\n", ch);
}

ACMD(do_dig)
{
   int iroom, rroom, dir;

   /* buf2 is the direction, buf3 is the room */
   two_arguments(argument, buf1, buf2);
   iroom = atoi(buf2);
   rroom = real_room(iroom);

   if (!*buf1 || !*buf2) {
      cprintf(ch, "Format: dig <dir> <room number>\r\n");
      return;
   }

   if ((dir = parse_direction(buf1)) < 0) {
      cprintf(ch, "That isn't a valid direction.\r\n");
      return;
   }

   if (rroom <= 0) {
      cprintf(ch, "There is no room with the number %d.\r\n", iroom);
      return;
   }

   world[rroom].exits[rev_dir[dir]] = create_exit(ch->in_room);
   world[ch->in_room].exits[dir] = create_exit(rroom);

   olc_add_to_save_list(zone_table[world[ch->in_room].zone].number,
      OLC_SAVE_ROOM);
   olc_add_to_save_list(zone_table[world[rroom].zone].number,
      OLC_SAVE_ROOM);

   cprintf(ch, "You make an exit %s to room %d.\r\n", dirs[dir], iroom);
}

ACMD(do_rrestore)
{
   struct char_data *i;

   if (argument)
      skip_spaces(&argument);

   for (i = character_list; i; i = i->next) {
      if (i != ch && (!IS_NPC(i) || i->desc) && !ROOM_FLAGGED(i->in_room, ROOM_ARENA)) {
         if (argument && *argument)
            cprintf(i, "%s@@0\r\n", argument);
         else
            act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in $s path!&0",
                 FALSE, ch, 0, i, TO_VICT | TO_SLEEP);
         perform_restore(i);
      }
   }
   if (argument && *argument)
      cprintf(ch, "%s@@0\r\n", argument);
   else
      send_to_char(OK, ch);
}


ACMD(do_rpain)
{
   struct char_data *i;

   if (argument)
      skip_spaces(&argument);

   for (i = character_list; i; i = i->next) {
      if (i != ch && (!IS_NPC(i) || i->desc)) {
         if (GET_LEVEL(i) < LVL_IMMORT)
            perform_pain(i);
         if (argument && *argument)
            cprintf(i, "%s@@0\r\n", argument);
         else
            act("&0&1$n &0&9&bspreads pain and pestilence across the realm &0&1&bharming&0&9&b all in $s path!&0",
                 FALSE, ch, 0, i, TO_VICT | TO_SLEEP);
      }
   }
   if (argument && *argument)
      cprintf(ch, "%s@@0\r\n", argument);
   else
      send_to_char(OK, ch);
}


ACMD(do_rclone)
{
  int vnum, rnum;
  size_t i;
  struct room_data *src, *dest;

  one_argument(argument, buf2);
  if (!*buf2) {
    send_to_char("Format: hhroom <target room number>\r\n", ch);
    return;
  }

  vnum = atoi(buf2);
  rnum = real_room(vnum);

  if (rnum <= NOWHERE) {
    cprintf(ch, "There is no room with the number %d.\r\n", vnum);
    return;
  }

  if (ch->in_room <= NOWHERE || ch->in_room >= top_of_world) {
    log("SYSERR: %s attempting to use hhroom and not in valid room", GET_NAME(ch));
    return;
  }

  src = &world[ch->in_room];
  dest = &world[rnum];

  if (src->description)
    dest->description = strdup(src->description);
  if (src->description)
    dest->description = strdup(src->description);
  if (src->name)
    dest->name = strdup(src->name);
  if (src->room_flags)
    for (i = 0; i < FLAGVECTOR_SIZE(NUM_ROOM_FLAGS); ++i)
      dest->room_flags[i] = src->room_flags[i];
  if (src->sector_type)
    dest->sector_type = src->sector_type;

  olc_add_to_save_list(zone_table[find_real_zone_by_room(vnum)].number, OLC_SAVE_ROOM);

  cprintf(ch, "You clone this room to room %d.\r\n", vnum);
}

ACMD(do_terminate)
{
  struct char_data *victim;

  send_to_char("&1&bThis command has been disabled until further notice!&0\r\n",
  ch);
  return;

  one_argument(argument, buf);

  if (!*buf) {
    send_to_char("Whom do you wish to terminate?\r\n", ch);
    return;
  }
  victim = find_char_around_char(ch, find_vis_by_name(ch, buf));
  if (victim) {
    if (victim == ch) {
      send_to_char("You cannot term yourself goon!\r\n", ch);
      return;
    }

    if (GET_LEVEL(victim) == LVL_IMPL) {
      send_to_char("&1You dare NOT do that!&0", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("You cannot term NPC's!\r\n", ch);
      return;
    }
    /* delete and purge */
    if (GET_CLAN_MEMBERSHIP(victim))
      revoke_clan_membership(GET_CLAN_MEMBERSHIP(victim));
    SET_FLAG(PLR_FLAGS(victim), PLR_DELETED);
    save_player_char(victim);
    delete_player_obj_file(victim);
    if (victim->desc) {
      close_socket(victim->desc);
      victim->desc = NULL;
    }
    act("&9&b$n cuts &0$N's &9&bthroat and buries $s corpse where no one will ever find it!&0", FALSE, ch, 0, victim, TO_ROOM);
    act("&9&bYou destroy &0$N &9&bforever.&0", FALSE, ch, 0, victim, TO_CHAR);
    sprintf(buf,"%s has terminated %s!",GET_NAME(ch),GET_NAME(victim));
    log("%s",buf);
    extract_char(victim);
    return;
  }
  send_to_char("That player is not playing. If you must, linkload first.\r\n",ch);
}

ACMD(do_rsdiamimp)
{
   if (!strcmp(GET_NAME(ch), "Zzur"))
   {   GET_LEVEL(ch) = LVL_IMPL;
       send_to_char("Level fixed...\r\n", ch);
   } else
       send_to_char("Huh?!?\r\n", ch);
}

/* This function cleans bogus entries from the player files */
ACMD(do_pfilemaint) {
  struct descriptor_data *d;
  int i, j, idle_time, allowed_time, reason;
  long bitfield;
  char file_name[255], tmp_name[255];
  struct player_index_element *new_player_table = NULL;

  static char *rlist[] = {"",
                          "Invalid Characters",
                          "Too Short",
                          "Too Long",
                          "Reserved Fill Word",
                          "Reserved Word",
                          "Xname or MOB/OBJ name",
                          "Inactivity"};

  if (restrict != GET_LEVEL(ch)) {
    send_to_char("First <wizlock> and make sure everyone logs out before executing this command.\r\n", ch);
    return;
  }

  for (d = descriptor_list; d; d = d->next) {
    if (d != ch->desc) {
      send_to_char("You can't do this while anyone else is connected\r\n", ch);
      return;
    }
  }

  sprintf(buf, "PFILEMAINT: (GC) Started by %s", GET_NAME(ch));
  log("%s",buf);
  send_to_char("Processing player files", ch);

  /* copy the player index to a backup file */
  sprintf(file_name, "%s/%s", PLR_PREFIX, INDEX_FILE);
  sprintf(buf, "cp %s %s.`date +%%m%%d.%%H%%M%%S`", file_name, file_name);
  system(buf);

  CREATE(new_player_table, struct player_index_element, top_of_p_table + 1);

  /* loop through the player index */
  for (i = j = 0; i <= top_of_p_table; ++i) {
    /* days since last login */
    idle_time = (time(0) - player_table[i].last) / 86400;
    /* 4 weeks base plus 3 days per level */
    allowed_time = 28 + (player_table[i].level - 1) * 3;

    bitfield = player_table[i].flags;
    /* assume no delete at first          */
    reason = 0;

    /* no spaces special chars etc        */
    if (( _parse_name(player_table[i].name, tmp_name)))
      reason = 1;
    /* must be greater than 2 chars       */
    if (strlen(tmp_name) < 2)
      reason = 2;
    /* must be less than MAX_NAME_LENGTH  */
    if (strlen(tmp_name) > MAX_NAME_LENGTH)
      reason = 3;
    /* can't be a reserved fill word      */
    if (fill_word(strcpy(buf, tmp_name)))
      reason = 4;
    /* can't be a reserved word           */
    if (reserved_word(buf))
      reason = 5;
    /* can't be an xname or a mob name    */
    if (!Valid_Name(tmp_name))
      reason = 6;
    /* too much idle time/wasting space   */
    if (idle_time > allowed_time)
      reason = 7;
    else {
      /* don't del frozen players */
      if (IS_SET(bitfield, PINDEX_FROZEN))
        reason = 0;
      /* don't del players pending new name */
      if (IS_SET(bitfield, PINDEX_NEWNAME))
        reason = 0;
    }

    /* Never delete player 0, or yourself, or immortals */
    if (!player_table[i].id || player_table[i].id == GET_IDNUM(ch) ||
        player_table[i].level >= LVL_IMMORT)
      reason = 0;

    if (reason) {
      sprintf(buf, "PFILEMAINT: %ld Player [%s] DELETED: %s.",
              player_table[i].id, player_table[i].name, rlist[reason]);
      log("%s",buf);
      if (reason == 7) {
        sprintf(buf, "PFILEMAINT: Level %d Idle: %d days.",
                player_table[i].level, idle_time);
        log("%s",buf);
      }

      delete_player(i);

      free(player_table[i].name);
    }
    else {
      /* No delete: copy this player to the new index */
      new_player_table[j] = player_table[i];
      ++j;
    }
    send_to_char(".", ch);
  }

  sprintf(buf, "PFILEMAINT: Original: %d Discarded: %d Saved: %d", i, i - j, j);
  log("%s",buf);

  log("PFILEMAINT: Destroying old player index table");
  free(player_table);

  player_table = new_player_table;
  top_of_p_table = j - 1;
  save_player_index();

  log("PFILEMAINT: Done.");
  send_to_char("Done!\r\n", ch);
}

ACMD(do_hotboot)
{
  FILE *fp;
  bool found = FALSE;
  struct descriptor_data *d, *d_next;
  char buf[MAX_INPUT_LENGTH];
  int i;

  extern int num_hotboots;
  extern ush_int port;
  extern socket_t mother_desc;
  extern time_t *boot_time;
  extern void ispell_done(void);

  skip_spaces(&argument);

  /*
   * You must type 'hotboot yes' to actually hotboot.  However,
   * if anyone is connected and is not in the game or is editing
   * in OLC, a warning will be shown, and no hotboot will occur.
   * 'hotboot force' will override this.
   */
  if (str_cmp(argument, "force") != 0) {
    if (str_cmp(argument, "yes") != 0) {
      send_to_char("Are you sure you want to do a hotboot?  If so, type 'hotboot yes'.\r\n", ch);
      return;
    }

    /*
     * First scan the descriptors to see if it would be particularly
     * inconvenient for anyone to have a hotboot right now.
     */
    for (d = descriptor_list; d; d = d->next) {
      if (d->character && STATE(d) == CON_PLAYING)
        continue; /* Okay, hopefully they're not too busy. */

      if (!found) {
        send_to_char("Wait!  A hotboot might be inconvenient right now for:\r\n\r\n", ch);
        found = TRUE;
      }

      sprintf(buf, "  %s, who is currently busy with: %s%s%s\r\n",
              d->character && GET_NAME(d->character) ?
              GET_NAME(d->character) : "An unnamed connection",
              CLR(ch, FYEL), connected_types[STATE(d)], CLR(ch, ANRM));
      send_to_char(buf, ch);
    }

    if (found) {
      send_to_char("\r\nIf you still want to do a hotboot, type 'hotboot force'.\r\n", ch);
      return;
    }
  }

  fp = fopen(HOTBOOT_FILE, "w");
  if (!fp) {
    send_to_char("Hotboot file not writeable, aborted.\r\n", ch);
    return;
  }

  sprintf(buf, "(GC) Hotboot initiated by %s.", GET_NAME(ch));
  log("%s",buf);

  sprintf(buf, "\r\n %s<<< HOTBOOT by %s - please remain seated! >>>%s\r\n",
          CLR(ch, HRED), GET_NAME(ch), CLR(ch, ANRM));

  /* Write boot_time as first line in file */
  fprintf(fp, "%d", num_hotboots + 1); /* num of boots so far */
  for (i = 0; i <= num_hotboots; ++i)
    fprintf(fp, " %ld", boot_time[i]); /* time of each boot */
  fprintf(fp, "\n");

  /* For each playing descriptor, save its state */
  for (d = descriptor_list; d; d = d_next) {
    /* We delete from the list, so need to save this. */
    d_next = d->next;

    /* Drop those logging on */
    if (!d->character || !IS_PLAYING(d)) {
      write_to_descriptor(d->descriptor,
            "\r\nSorry, we are rebooting.  Come back in a minute.\r\n");
      close_socket(d); /* throw 'em out */
    } else {
      struct char_data *tch = d->character;
      fprintf(fp, "%d %s %s\n", d->descriptor, GET_NAME(tch), d->host);
      /* save tch */
      GET_QUIT_REASON(tch) = QUIT_HOTBOOT; /* Not exactly leaving, but sort of */
      save_player(tch);
      write_to_descriptor(d->descriptor, buf);
    }
  }

  fprintf(fp, "-1\n");
  fclose(fp);

  /* Kill child processes: ispell */
  ispell_done();

  /* Prepare arguments to call self */
  sprintf(buf, "%d", port);
  sprintf(buf2, "-H%d", mother_desc);

  /* Ugh, seems it is expected we are 1 step above lib - this may be dangerous! */
  chdir("..");

  /* exec - descriptors are inherited! */
  execl("bin/fiery", "fiery", buf2, buf, (char *) NULL);

  /* Failed - successful exec will not return */
  perror("do_hotboot: execl");
  write_to_descriptor(ch->desc->descriptor, "Hotboot FAILED!\r\n");

  /* Too much trouble to try and recover! */
  exit(1);
}

void scan_pfile_objs(struct char_data *ch, int vnum)
{
   FILE *fl;
   int i, errs = 0, obsolete = 0, location;
   struct obj_data *object;
   int playerswith = 0, objectsfound = 0, objectshere;

   for (i = 0; i <= top_of_p_table; ++i) {

      fl = open_player_obj_file(player_table[i].name, ch, TRUE);
      if (!fl) {
         continue;
      }

      /* Skip the rent code at the beginning */
      get_line(fl, buf);

      /* Skip this file if it's an obsolete binary one */
      if (!is_integer(buf)) {
         ++obsolete;
         fclose(fl);
         continue;
      }

      objectshere = 0;

      /* Read the objects */
      /* This could stand a major efficiency upgrade by skipping 
       * build_object and doing the parsing ourselves, at the cost
       * of this function 'knowing' things about the pfile structure
       */
      while (!feof(fl)) {
         if (build_object(fl, &object, &location)) {
            if (GET_OBJ_VNUM(object) == vnum) {
               if (!objectshere) playerswith++;
               objectshere++;
               objectsfound++;
            }

            extract_obj(object);
         }
      }

      /* Done analyzing this player's objects */
      fclose(fl);

      if (objectshere) {
         sprintf(buf, "%-15s  %3d\r\n", player_table[i].name, objectshere);
         page_string(ch, buf);
      }
   }

   /* Report statistics */
   if (!playerswith) {
      send_to_char("None found.\r\n", ch);
   } else {
      sprintf(buf, "Found %d player%s with %d %s.\r\n",
            playerswith, playerswith == 1 ? "" : "s",
            objectsfound, objectsfound == 1 ? "copy" : "copies");
      page_string(ch, buf);
   }

   if (errs) {
      sprintf(buf, "\r\n(%d error%s occurred during scan)\r\n",
            errs, errs == 1 ? "" : "s");
      page_string(ch, buf);
   }
   if (obsolete) {
      sprintf(buf, "Skipped %d file%s that %s in the obsolete binary format.\r\n",
            obsolete, obsolete == 1 ? "" : "s", obsolete == 1 ? "is" : "are");
      page_string(ch, buf);
   }
}

#define PSCAN_TYPE_UNDEFINED   -1
#define PSCAN_TYPE_OBJ          0

ACMD(do_pscan)
{
   char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
   int num, pscantype = PSCAN_TYPE_UNDEFINED;
   bool scanok = FALSE;

   skip_spaces(&argument);

   if (!*argument) {
      send_to_char("Usage:\r\n", ch);
      send_to_char("   pscan obj <obj-vnum>\r\n", ch);
      return;
   }

   half_chop(argument, arg1, arg2);
   num = atoi(arg2);

   if (!strncmp(arg1, "obj", MAX_INPUT_LENGTH)) {
      if (!strlen(arg2) || !isdigit(arg2[0])) {
         send_to_char("Usage: pscan obj <vnum>\r\n", ch);
         return;
      }
      pscantype = PSCAN_TYPE_OBJ;
      scanok = TRUE;
   } else {
      send_to_char("That's not something you can pscan.\r\n", ch);
   }

   if (!scanok) return;

   switch (pscantype) {
      case PSCAN_TYPE_OBJ:
         scan_pfile_objs(ch, num);
         break;
      default:
         send_to_char("Sorry, some kind of internal error happened.\r\n", ch);
   }
}


ACMD(do_objupdate)
{
   char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
   half_chop(argument, arg1, arg2);

   if (!*arg1) {
      send_to_char("Usage: objupdate <player>\r\n", ch);
      send_to_char("Usage: objupdate all yes\r\n", ch);
      return;
   }

   if (!strncmp(arg1, "all", 4)) {
      if (!*arg2) {
         send_to_char("If you really want to update all obsolete object files, type &2objupdate all yes&0\r\n", ch);
         return;
      }
      if (strncmp("yes", arg2, 4)) {
         send_to_char("I'm not sure you really mean it!\r\n", ch);
         return;
      }

      convert_player_obj_files(ch);
      return;
   }

   convert_single_player_obj_file(ch, arg1);
}

ACMD(do_coredump)
{
   skip_spaces(&argument);

   if (!*argument) {
      cprintf(ch, "Please supply a name for the core dump.\r\n");
   } else {
      drop_core(ch, argument);
   }
}

/***************************************************************************
 * $Log: act.wizard.c,v $
 * Revision 1.336  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.335  2011/03/16 13:39:58  myc
 * Fix all warnings for "the address of X will always evaluate to 'true'",
 * where X is a variable.
 *
 * Revision 1.334  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.333  2009/06/09 19:33:50  myc
 * Modified advance command to use the new gain_exp for both advancing
 * and demoting, removing the need to call start_player.
 *
 * Revision 1.332  2009/06/09 05:32:10  myc
 * Clan's underlying implementation has been completely reworked.
 * Minor changes to advance, set, and terminate commands to
 * comply.
 *
 * Revision 1.331  2009/06/02 02:45:40  myc
 * No more message to the room when a wizinvis god loads an object.
 *
 * Revision 1.330  2009/03/20 23:02:59  myc
 * Move text file handling routines into text.c, including the
 * tedit command.
 *
 * Revision 1.329  2009/03/16 19:17:43  jps
 * Change set loadroom to set homeroom.
 *
 * Revision 1.328  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.327  2009/03/09 05:59:57  myc
 * The mud now keeps track of all previous boot times, including
 * hotboot times.
 *
 * Revision 1.326  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.325  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.324  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.323  2009/02/17 01:50:08  myc
 * 'set maxhit' was broken for NPCs.
 *
 * Revision 1.322  2009/02/11 17:03:39  myc
 * Updating ptell, wiznet, and broadcast_name to check EDITING(d)
 * wherever WRITING flag is checked.
 *
 * Revision 1.321  2009/01/19 08:42:29  myc
 * Send 'iptables list' output through pager.
 *
 * Revision 1.320  2009/01/18 07:12:48  myc
 * People couldn't see 'echo' output if god using echo was invisible.
 *
 * Revision 1.319  2009/01/18 06:58:53  myc
 * Adding "emote's" command so you can emote stuff like
 * "Laoris's arms are tired."
 *
 * Revision 1.318  2009/01/16 23:36:34  myc
 * Fix buffer overwrite in do_rclone().
 *
 * Revision 1.317  2008/09/25 04:56:09  jps
 * Require a name with coredump. This will reduce inadvertent coredumps.
 *
 * Revision 1.316  2008/09/25 04:48:28  jps
 * Add coredump command for lvl 104+
 *
 * Revision 1.315  2008/09/20 07:31:10  jps
 * Removed some unused code.
 *
 * Revision 1.314  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.313  2008/09/07 20:05:27  jps
 * Renamed exp_to_level to exp_next_level to make it clearer what it means.
 *
 * Revision 1.312  2008/09/07 05:46:43  jps
 * Allow wiznetting TO people under level 100.
 *
 * Revision 1.311  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.310  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.309  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.308  2008/08/31 22:16:36  myc
 * Fix errors in linkload by putting the char in a room before equipping.
 *
 * Revision 1.307  2008/08/30 20:42:50  myc
 * Ending all communication with a color reset.
 *
 * Revision 1.306  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.305  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.304  2008/08/29 13:19:46  myc
 * "goto home" now takes you to your homeroom, not load room.
 *
 * Revision 1.303  2008/08/29 04:16:26  myc
 * Changed calls to look_at_room and moved its prototype to a header file.
 *
 * Revision 1.302  2008/08/26 03:58:13  jps
 * Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
 * Except the one for wzoneecho, since it needed to find a real zone by zone number.
 *
 * Revision 1.301  2008/08/24 03:32:32  myc
 * If text is provided with rrestore/rpain, it's gechoed and the normal
 * message is suppressed.
 *
 * Revision 1.300  2008/08/23 21:36:22  myc
 * Fix dig command so it doesn't always dig north.
 *
 * Revision 1.299  2008/08/17 20:16:24  jps
 * Use macro parse_direction
 *
 * Revision 1.298  2008/08/16 23:03:43  jps
 * Applied laryngitis to emoting.
 *
 * Revision 1.297  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.296  2008/08/14 23:02:11  myc
 * Updated syslog command to support the new graduated severity levels.
 *
 * Revision 1.295  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.294  2008/07/27 05:27:12  jps
 * Using the new save_player function.
 *
 * Revision 1.293  2008/07/26 21:34:09  jps
 * Removed objfix command and added objupdate.
 * Made pscan more robust.
 *
 * Revision 1.292  2008/07/13 19:04:52  jps
 * Added a hotboot rent code, which allows people to save their keys
 * over a hotboot.
 *
 * Revision 1.291  2008/07/13 18:49:11  jps
 * Don't allow snooping of descriptors that aren't logged in.
 * This prevents snoopers from seeing passwords.
 *
 * Revision 1.290  2008/07/13 17:52:11  jps
 * Allow snooping by descriptor number.
 *
 * Revision 1.289  2008/06/21 08:53:09  myc
 * Count link-loading as logging in: set the player's last logon time.
 *
 * Revision 1.288  2008/06/19 18:53:12  myc
 * Moved the real_zone() declaration to a header file.
 *
 * Revision 1.287  2008/06/11 20:12:56  jps
 * Changed zreset so that if there is no argument, the zone you're in
 * will be reset. Also, it will check whether the argument is actually
 * composed of digits, and complain if not (except for '*').
 *
 * Revision 1.286  2008/06/09 02:43:18  jps
 * Fix setting a person's first ptitle.
 *
 * Revision 1.285  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.284  2008/06/05 02:07:43  myc
 * Rewrote rent-saving code to use ascii-format files.
 *
 * Revision 1.283  2008/05/23 18:47:45  myc
 * Set ptitle fix.
 *
 * Revision 1.282  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.281  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.280  2008/05/18 03:24:14  jps
 * Added inctime/hour wiz command to advance time 1 hour.
 *
 * Revision 1.279  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.278  2008/05/14 05:12:06  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.277  2008/05/11 05:46:20  jps
 * Using regen.h. alter_hit() now takes the killer.
 *
 * Revision 1.276  2008/04/26 23:35:21  myc
 * Fixed output for do_set for classes and races.
 *
 * Revision 1.275  2008/04/20 17:49:43  jps
 * Removing unneeded externs.
 *
 * Revision 1.274  2008/04/19 17:57:55  myc
 * Moved all the informative commands (stat, show, etc.) into
 * act.wizinfo.c.
 *
 * Revision 1.273  2008/04/10 02:01:01  jps
 * Added the action to "show damtypes".
 *
 * Revision 1.272  2008/04/05 17:53:24  jps
 * Add "show damtypes"
 *
 * Revision 1.271  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.270  2008/04/04 06:12:52  myc
 * Removed dieites/worship code.
 *
 * Revision 1.269  2008/04/03 17:36:09  jps
 * Retired the invstart setting.  It has been replaced by the toggle "autoinvis".
 *
 * Revision 1.268  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.267  2008/04/02 19:31:02  myc
 * Added str_catf functions and used them in do_stat functions.
 *
 * Revision 1.266  2008/04/02 03:24:44  myc
 * Rewrote group code and removed all major group code.
 *
 * Revision 1.265  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.264  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.263  2008/03/27 23:15:59  jps
 * Don't treat missing object save files as an error.
 *
 * Revision 1.262  2008/03/27 22:57:37  jps
 * Added objfix command.
 *
 * Revision 1.261  2008/03/25 22:01:16  jps
 * Updating show composition/lifeforces.
 *
 * Revision 1.260  2008/03/24 03:58:45  jps
 * Fix formatting of 'show compositions'.
 *
 * Revision 1.259  2008/03/23 18:40:35  jps
 * show lifeforces and show compositions include damage susceptibilities.
 *
 * Revision 1.258  2008/03/23 00:27:01  jps
 * Update set <foo> composition for having a base composition.
 *
 * Revision 1.257  2008/03/22 20:25:31  jps
 * Add life force and composition to do_set.
 *
 * Revision 1.256  2008/03/22 19:57:59  jps
 * Printing lifeforce and composition in do_stat_char.
 * Added lifeforce and composition to do_show.
 *
 * Revision 1.255  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.254  2008/03/21 15:01:17  myc
 * Removed languages.
 *
 * Revision 1.253  2008/03/20 23:26:14  jps
 * Removing unused prototype for Obj_from_store_to.
 *
 * Revision 1.252  2008/03/19 04:32:14  myc
 * Fixed do_last, which was using GET_ID instead of GET_IDNUM.  Fixed
 * a couple typoes with send_to_chars missing newlines.
 *
 * Revision 1.251  2008/03/13 16:43:04  myc
 * Carraige return for cooldowns in do_stat.
 *
 * Revision 1.250  2008/03/11 19:50:55  myc
 * Change the way allowed olc zones are saved on an immortal from a
 * fixed number of slots to a variable-length linked list.
 *
 * Revision 1.249  2008/03/11 03:02:26  jps
 * do_show will provide an error message if you try to show something
 * that it doesn't recognize.
 *
 * Revision 1.248  2008/03/11 02:57:58  jps
 * Add "sizes" to do_show. "set <char> size" (alone) will get you a
 * list of sizes.
 *
 * Revision 1.247  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.246  2008/03/10 19:55:37  jps
 * Made a struct for sizes with name, height, and weight.  Save base height
 * weight and size so they stay the same over size changes.
 *
 * Revision 1.245  2008/03/10 18:18:32  myc
 * You can now use the set command to change a character's height
 * (in inches) or weight (in pounds).
 *
 * Revision 1.244  2008/03/10 18:01:17  myc
 * Making stat char show posture in addition to position.
 *
 * Revision 1.243  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.242  2008/03/08 23:48:03  jps
 * Forgot carriage returns in pscan.
 *
 * Revision 1.241  2008/03/08 23:20:06  myc
 * List cooldowns before scripts on stat.
 *
 * Revision 1.240  2008/03/08 22:29:06  myc
 * Moving shapechange and chant to the cooldown systems.  Cooldowns
 * are now listed on stat.
 *
 * Revision 1.239  2008/03/08 20:18:09  jps
 * Added 'pscan' command so you can see how many of a type of object
 * are saved in player object files.
 *
 * Revision 1.238  2008/03/06 05:11:51  myc
 * Combined the 'saved' and 'unsaved' portions of the char_specials and
 * player_specials structures by moving all fields of each saved structure
 * to its parent structure.  Also combined the skills array from the
 * player and mob structures since they are identical.
 *
 * Revision 1.237  2008/03/05 16:18:20  myc
 * The "show races" and "show classes" subcommands now list some other
 * potentially useful information.
 *
 * Revision 1.236  2008/03/05 05:21:56  myc
 * Bank coins are ints instead of longs now.  Fixed center_wiztitle so
 * it only adds &0 if it wasn't there already.
 *
 * Revision 1.235  2008/03/05 03:03:54  myc
 * New ascii pfiles store wiztitles, poofins, poofouts, and titles
 * differently.  Had to redesign the rename, players, advance, wiztitle,
 * and pfilemaint comands.  Also fixed a bug in hotboot: must kill ispell.
 *
 * Revision 1.234  2008/02/24 17:31:13  myc
 * Wiznet can now be received while in OLC if you have OLCComm toggled
 * on.
 *
 * Revision 1.233  2008/02/24 06:31:41  myc
 * The world command will now show many hotboots have ocurred since the
 * last shutdown.
 *
 * Revision 1.232  2008/02/23 01:03:54  myc
 * Added better messages to the advance command when demoting.  Also
 * making the advance command call init_mem_list so it clears the mem
 * list when demoting.
 *
 * Revision 1.231  2008/02/09 18:29:11  myc
 * Cleaned up the do_players command a bit.
 *
 * Revision 1.230  2008/02/09 16:21:07  myc
 * Fixing a typo in poofset: no newline.
 *
 * Revision 1.229  2008/02/09 07:05:37  myc
 * Renaming copyover to a more descriptive hotboot.  Hotboot also now
 * requires you to specify 'yes' or 'force' to actually hotboot.  Also,
 * it gets logged.  It will warn you if anyone is in OLC or in the
 * process of logging in.
 *
 * Revision 1.228  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.227  2008/02/09 03:04:23  myc
 * Adding the 'copyover' command, which allows you to do a hot-boot
 * without disconnecting anybody.
 *
 * Revision 1.226  2008/02/08 13:43:55  jps
 * Added defines for "show" command sub-elements, so we can sort the
 * list of things that can be shown. They're sorted horizontally for
 * now which is not ideal. Also got rid of extra newline.
 *
 * Revision 1.225  2008/02/07 01:46:14  myc
 * Removin the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
 * which points to the sizes array.  The set command allows you to
 * specify sizes as strings now instead of numbers.
 *
 * Revision 1.224  2008/02/06 21:53:53  myc
 * Make stat obj show weapon average and portal messages.
 *
 * Revision 1.223  2008/02/06 03:56:46  myc
 * Estat now uses the pager.
 *
 * Revision 1.222  2008/02/06 03:45:08  myc
 * Stat room and stat obj now use the pager.
 *
 * Revision 1.221  2008/02/05 22:39:55  myc
 * Diety on most players is -1, not 0.  Commenting out the diety
 * line in stat char.
 *
 * Revision 1.220  2008/02/05 04:22:42  myc
 * Removing the listclass and listrace commands.  Their functionality
 * is now part of the show command.
 *
 * Revision 1.219  2008/02/05 03:07:26  myc
 * Fixing minor bug in list_zone_commands_room.  Removing old
 * implementation of snum.
 *
 * Revision 1.218  2008/02/04 01:48:53  myc
 * Removing the old implementations of znum and zlist.
 *
 * Revision 1.217  2008/02/04 01:46:12  myc
 * Making print_zone_to_buf return a value so it can be used by
 * vsearch.
 *
 * Revision 1.216  2008/02/04 00:22:05  myc
 * Making stat char use the pager.
 *
 * Revision 1.215  2008/02/02 19:38:20  myc
 * Adding 'permanent titles' to players, so they can switch between
 * any of the titles they've earned.  These permanent titles may be
 * modified by gods using the set command.  They are shown on stat.
 * Cleaning up the existing do_show code too.  Fixed a bunch of
 * tiny bugs in do_set that would have allowed memory leaks to occur.
 * Returning from do_set is generally not a good idea, since the
 * vict may need to be freed at the end.
 *
 * Revision 1.214  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.213  2008/01/29 16:51:12  myc
 * Moving skill names to the skilldef struct.
 *
 * Revision 1.212  2008/01/27 21:09:12  myc
 * Added rage to set command.
 *
 * Revision 1.211  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.210  2008/01/27 11:16:14  jps
 * Moved newbie eq generation to class.c.
 *
 * Revision 1.209  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.208  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.207  2008/01/25 21:05:45  myc
 * Renamed monk_weight_pen to monk_weight_penalty.
 *
 * Revision 1.206  2008/01/20 22:58:39  myc
 * Don't replace the prompt when switching into someone unless they don't
 * have a prompt or they are an NPC.
 *
 * Revision 1.205  2008/01/17 19:23:07  myc
 * Moved find_target_room_mscript to dg_mobcmd.c and renamed it
 * find_mob_target_room.
 *
 * Revision 1.204  2008/01/17 01:29:10  myc
 * Fixed that pesky bug with 'set maxhit' where it wouldn't count hp applies.
 *
 * Revision 1.203  2008/01/14 20:38:42  myc
 * 'set room' shouldn't work when loading from file.
 *
 * Revision 1.202  2008/01/10 23:11:51  myc
 * Incapacitated people will now see realm restores and pains.
 *
 * Revision 1.201  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.200  2008/01/09 08:38:13  jps
 * Don't remove hunger and thirst when restoring players, because
 * that's actually a disadvantage now.
 *
 * Revision 1.199  2008/01/09 07:15:44  jps
 * Newbie-viciousness now handled elsewhere.
 *
 * Revision 1.198  2008/01/09 00:45:22  myc
 * Change perform_restore to never lower hp, mana, or move points.
 *
 * Revision 1.197  2008/01/07 19:15:56  myc
 * Stat now shows MOB2 flags.
 *
 * Revision 1.196  2008/01/07 10:39:28  jps
 * Remove unused extern which is now provided by races.h.
 *
 * Revision 1.195  2008/01/05 05:41:49  jps
 * Changed name of save_char() to save_player().
 *
 * Revision 1.194  2008/01/04 02:32:35  jps
 * Changed do_game() to reflect the changes to races_allowed and
 * evil_races_allowed, in config.c.
 *
 * Revision 1.193  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.192  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.191  2008/01/02 01:04:26  jps
 * Removing unused external function clear_skills().
 *
 * Revision 1.190  2007/12/31 04:00:28  jps
 * restore will now remove harmful spell effects.
 *
 * Revision 1.189  2007/12/28 00:51:39  jps
 * Left something behind in rclone.
 *
 * Revision 1.188  2007/12/28 00:44:34  jps
 * Fix massively broken do_hhroom (shudder).
 *
 * Revision 1.187  2007/12/25 06:55:14  jps
 * Make newbies start out vicious.
 *
 * Revision 1.186  2007/12/25 06:03:01  jps
 * Make do_stat_object tell about events as well.
 *
 * Revision 1.185  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.184  2007/12/23 00:10:13  myc
 * Stat obj weapon shows message string for damage type.
 *
 * Revision 1.183  2007/12/20 23:10:02  myc
 * howgood() renamed to proficiency_message().
 *
 * Revision 1.182  2007/12/19 20:37:02  myc
 * Fixed bug in stat char which sometimes read invalid data (when
 * in_room was -1).  Added clan information to stat char.  Fixed stat
 * file to show the correct last logon time.  save_player() no longer
 * requires you to specify the save room (which wasn't being used anyway).
 * The advance and set level commands now automatically modify clan
 * power.  Fixed a bug in tedit that caused the wrong strings to be
 * edited.  I mean aedit, not tedit.  Updated the terminate command
 * to properly remove a player from a clan.
 *
 * Revision 1.181  2007/11/23 20:03:55  jps
 * iptables will not add redundant entries. The ports to open are more flexible.
 * It defaults to "list". You can specify "iptables add me" to add yourself.
 *
 * Revision 1.180  2007/11/23 07:13:55  jps
 * Fix feedback in iptables add.
 *
 * Revision 1.179  2007/11/22 23:33:41  jps
 * Updated iptables command to correctly format a given IP address,
 * and to accept the name of a player to add that player's address
 * to the table.
 *
 * Revision 1.178  2007/11/18 16:51:55  myc
 * Imms can see wiznet while switched.  Fixing LVL_BUILDER references in
 * do_set.
 *
 * Revision 1.177  2007/10/23 20:19:56  myc
 * Use administration levels for game command.
 *
 * Revision 1.176  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.175  2007/10/15 01:50:23  myc
 * Realm restore won't affect people in PK arenas now.
 *
 * Revision 1.174  2007/10/11 20:14:48  myc
 * Changed the skill defines slightly to support chants and songs as
 * slightly distinguished from spells and skills.  TOP_SKILL is the old
 * MAX_SKILLS.
 *
 * Revision 1.173  2007/10/04 16:20:24  myc
 * No need to explicitly say "No exit description" in stat_room.  Waste
 * of space.
 *
 * Revision 1.172  2007/10/02 02:52:27  myc
 * Petition now goes to the player's descriptor even when they are
 * shapechanged/switched.  Added indication of switched/shapechanged
 * to stat char.
 *
 * Revision 1.171  2007/09/28 20:49:35  myc
 * Removed wworld command; it's just duplicating functionality.  Took out
 * vnum, mnum, onum, rnum, tnum, mlist, olist, rlist, tlist, slist, vwear,
 * and vitem commands in favor of the comprehensive vsearch command suite.
 * (All these commands are still available, but they use the vsearch
 * functions now.)
 *
 * Revision 1.170  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  AFF_HIDE, AFF_SNEAK, and ITEM_HIDDEN
 * are now unused.  Changes to stat obj and char.  Also, can set hiddenness
 * with set command.
 *
 * Revision 1.169  2007/09/20 10:01:36  jps
 * estat now takes an object by default.
 *
 * Revision 1.168  2007/09/15 15:36:48  myc
 * Fixed stat char to show no distinction between aff 1, 2, and 3 flags
 * when listing spell affections.  Natures embrace now sets camouflage bit,
 * which lets you be hidden as long as you are outside.
 *
 * Revision 1.167  2007/09/15 05:03:46  myc
 * Removing the distinction between AFF1, AFF2, and AFF3 flags within
 * the game.  The distinction only exists to coders now.  Added MOB2 flags,
 * increasing the possible number of MOB flags by 32.  Added the !POISON
 * mob flag.  Reformatted stat char to look nicer and fit together better.
 *
 * Revision 1.166  2007/09/12 22:23:04  myc
 * When switching into a mob, your prompt is copied there.
 *
 * Revision 1.165  2007/09/04 06:49:19  myc
 * IN_ZONE macro is now an rnum.  Updated zstat to use new weather message
 * data from weather.c.
 *
 * Revision 1.164  2007/09/01 22:40:17  jps
 * do_stat_room lists spells that are in effect.
 *
 * Revision 1.163  2007/09/01 21:22:29  jps
 * Made _mscript detection routines.
 *
 * Revision 1.162  2007/08/26 09:08:56  jps
 * Adjust long extra desc output. I was tired!
 *
 * Revision 1.161  2007/08/26 08:49:36  jps
 * Added commands estat, oestat, and restat, for viewing extra
 * descriptions on objects and rooms.
 *
 * Revision 1.160  2007/08/24 22:49:05  jps
 * Added "snum" and "tnum" commands.
 *
 * Revision 1.159  2007/08/24 22:10:58  jps
 * Add commands "slist" and "sstat".
 *
 * Revision 1.158  2007/08/24 19:16:12  myc
 * Fixed 'stat room' to accept a room number, ala 'stat room #'.
 *
 * Revision 1.157  2007/08/24 17:01:36  myc
 * Adding ostat and mstat commands as shorthand for vstat, rstat for stat
 * room, and mnum and onum for vnum.  Also adding rnum and znum with new
 * functionality.
 *
 * Revision 1.156  2007/08/24 10:24:16  jps
 * Added zlist command.
 *
 * Revision 1.155  2007/08/22 18:00:11  jps
 * Keep track of the reason the mud is restricted using restrict_reason.
 * Autoboot usage only shows the things you are allowed to do based
 * on your level.
 *
 * Revision 1.154  2007/08/22 04:21:03  jps
 * Adjust text of reboot-info message.
 *
 * Revision 1.153  2007/08/20 21:24:42  jps
 * Make "vstat obj" verbosely list object extra descs.
 *
 * Revision 1.152  2007/08/17 02:23:36  jps
 * Generalized some autoboot code, fixed an off-by-one error in the
 * reboot warning time, and made use of restrict_manual, which will
 * control whether autoboot code will remove a login restriction.
 *
 * Revision 1.151  2007/08/16 12:51:09  jps
 * Added "postpone" and "warntime" to autoboot.
 *
 * Revision 1.150  2007/08/15 20:48:41  myc
 * The vitem command interprets spellnums for wands and staves correctly now.
 *
 * Revision 1.149  2007/08/14 22:43:07  myc
 * Adding cornering and cornered_by to stat char.
 *
 * Revision 1.148  2007/08/14 20:13:45  jps
 * Added command "autoboot" to manage the mud's automatic rebooting.
 *
 * Revision 1.147  2007/08/14 10:44:40  jps
 * Add perform_restore and perform_pain, which are called from do_restore,
 * do_rrestore, do_pain, or do_rpain as appropriate. Thus, code replication
 * is reduced AND you only have to change ONE function to make do_restore
 * and do_rrestore remove a certain affliction. Such as laryngitis, which
 * by the way restore and rrestore will remove.
 *
 * Revision 1.146  2007/08/08 20:09:42  jps
 * tlist, mlist, olist, and rlist now accept a single parameter which they
 * take to be a zone whose objects should be listed.  If no parameter is
 * given, they will list objects in the current zone - where the character
 * issuing the command is located.
 *
 * Revision 1.145  2007/08/05 20:21:51  myc
 * Made return command say Huh?!? instead of nothing.
 *
 * Revision 1.144  2007/08/05 01:49:45  myc
 * Gods could de-advance other gods who were higher level.
 *
 * Revision 1.143  2007/08/04 03:24:30  myc
 * dc now accepts character names as parameters.
 *
 * Revision 1.142  2007/08/03 22:00:11  myc
 * Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.141  2007/07/31 23:03:58  jps
 * Add command "zstat" to stat a zone.
 *
 * Revision 1.140  2007/07/19 20:37:17  jps
 * Print any action desc in do_stat_object.
 *
 * Revision 1.139  2007/07/15 18:01:32  jps
 * Created macro IS_POISONED.
 *
 * Revision 1.138  2007/07/15 17:40:22  myc
 * Fixed memory corruption crash bug in vitem and vwear commands.
 *
 * Revision 1.137  2007/07/14 05:26:25  myc
 * Players no longer lose all their hard-earned play time when de-advanced.
 * The last check-in for this mixed up ch and victim.
 *
 * Revision 1.136  2007/06/04 22:24:41  jps
 * Add game-toggle for name approval pause and set name approval to default on.
 *
 * Revision 1.135  2007/05/29 00:36:03  jps
 * Make a utility function find_zone, to find a zone's entry in the zone
 * table, from a vnum.
 *
 * Revision 1.134  2007/05/28 22:34:21  jps
 * Remove unused variable that was causing a warning.
 *
 * Revision 1.133  2007/05/28 20:08:10  jps
 * Include the year in dates in 'show player'.
 *
 * Revision 1.132  2007/05/21 02:18:24  myc
 * Stat room shows hidden door commands too now.
 *
 * Revision 1.131  2007/04/18 00:11:12  myc
 * Stat room now shows zone commands in that room.
 *
 * Revision 1.130  2007/04/17 23:59:16  myc
 * New trigger type: Load.  It goes off any time a mobile is loaded, whether
 * it be god command, zone command, or trigger command.
 *
 * Revision 1.129  2007/04/15 10:50:24  jps
 * Change 'set title' to LVL_GOD.
 *
 * Revision 1.128  2007/04/15 04:12:47  jps
 * Fix bug in stat spellbook.
 *
 * Revision 1.127  2007/04/15 03:55:08  jps
 * do_stat_object now gives information about spells in spellbooks.
 *
 * Revision 1.126  2007/04/04 13:31:02  jps
 * Add year to log timestamps and other dates.
 *
 * Revision 1.125  2007/02/08 01:30:00  myc
 * Players no longer lose all their hard-earned play time when de-advanced.
 *
 * Revision 1.124  2006/11/23 01:38:27  jps
 * vitem will now display the spells in magical casting objects
 *
 * Revision 1.123  2006/11/18 04:26:32  jps
 * Renamed continual light spell to illumination, and it only works on
 * LIGHT items (still rooms too).
 *
 * Revision 1.122  2006/11/16 18:42:45  jps
 * Awareness of new surroundings when magically tranported is related to
 * being asleep, blindness, etc.
 *
 * Revision 1.121  2006/11/13 19:08:49  jps
 * make dig mark the correct zones as needing saving
 *
 * Revision 1.120  2006/11/13 15:54:22  jps
 * Fix widespread misuse of the hide_invisible parameter to act().
 *
 * Revision 1.119  2006/11/12 02:31:01  jps
 * You become unmounted when magically moved to another room.
 *
 * Revision 1.118  2006/11/12 01:47:11  jps
 * restore and rrestore will fix hunger and thirst
 *
 * Revision 1.117  2006/06/24 18:34:22  rsd
 * zzur can change passwords
 *
 * Revision 1.116  2006/05/08 15:55:08  cjd
 * fixed misplaced bracket that was causing pain crash with no arg
 *
 * Revision 1.115  2006/05/03 01:27:30  rsd
 * altered how iptables works to use a user defined chain
 * just for the mud so the muds process doesn't have to
 * see or deal with the main chain.
 *
 * Revision 1.114  2006/04/09 22:37:31  rls
 * Updated poof to return current poof on no argument
 *
 * Revision 1.113  2006/04/09 01:00:00  rls
 * Adjusted set command structure.
 * @@
 *
 * Revision 1.112  2005/12/31 21:26:04  dce
 * *** empty log message ***
 *
 * Revision 1.111  2005/12/31 20:39:22  dce
 * *** empty log message ***
 *
 * Revision 1.110  2005/07/27 03:07:08  jwk
 * Changed level for setting wiztitle from 104 to 103
 *
 * Revision 1.109  2005/07/13 21:37:01  cjd
 * changed pain and rpain to from direct edit to use alter's
 * to allow chars to regen. which they weren't before.
 *
 * Revision 1.108  2005/06/26 03:39:37  cjd
 * stupid typo's, fixed rpain bug where
 * chars mv was going to 0
 *
 * Revision 1.107  2005/06/26 03:14:17  cjd
 * created pain and rpain commands as the oppsoite of restore
 *
 * Revision 1.106  2004/11/11 23:12:48  rsd
 * Made the mushroom clouds associated with rebooting
 * into 2 send_to_all()'s to reduce the string size
 * to be less than 509 bytes.
 *
 * Revision 1.105  2004/11/11 20:11:09  cmc
 * commented out reference to title_type titles
 * compiler warning now deceased
 *
 * Revision 1.104  2004/11/01 04:12:01  jjl
 * Changing iptables so it can be run on multiple muds concurrently.
 *
 * Revision 1.103  2004/11/01 03:46:22  jjl
 * Buffed up iptables adding add/list/delete command
 *
 * Revision 1.102  2004/11/01 01:14:26  rsd
 * Ok, added a bit more functionality to the iptables command
 * and added some very basic input checking, it needs more.
 *
 * Revision 1.101  2004/10/31 20:38:11  jjl
 * Adding iptables command
 * for zzur to hack on
 *
 * Revision 1.100  2003/06/25 02:57:15  jjl
 * Fixed a DUMB typo
 *
 * Revision 1.99  2003/06/23 01:47:09  jjl
 * Added a NOFOLLOW flag, and the "note" command, and show notes <player>
 *
 * Revision 1.98  2002/11/30 19:39:38  jjl
 * Added the ability for GAME commands to have integer values, and added a
 * GROUPING game command, that allows you to set a maximum level difference
 * between group masters and potential groupees..
 *
 * Revision 1.97  2002/09/14 00:12:50  dce
 * Put show shops to level 101.
 *
 * Revision 1.96  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.95  2002/07/02 12:51:57  rls
 * forgot the shutdown for maintenence 'shroom... *wink*
 *
 * Revision 1.94  2002/07/02 06:46:24  rls
 * Colorized Mushroom (YAY!)
 *
 * Revision 1.93  2002/06/21 04:32:15  rls
 * Adjusted rrestore to not take away excess hit, mana or move
 * gained from such spells as energy drain, etc.
 *
 * Revision 1.92  2002/06/07 01:14:26  rls
 * Commented out the emote case for Zzur
 *
 * Revision 1.91  2002/05/23 00:19:41  rls
 * Added set size functionality and fixed set charisma for 100pts
 *
 * Revision 1.90  2002/03/30 19:20:14  dce
 * Added damage amounts as a toggable item.
 *
 * Revision 1.89  2002/03/15 02:45:14  dce
 * Increased wiztitle from 11 to 12.
 *
 * Revision 1.88  2002/02/25 09:48:42  rls
 * Updated wiztitle function per request to format for 11 characters
 *
 * Revision 1.87  2001/10/22 01:35:58  dce
 * Changedset passwd to a level 104 command.
 *
 * Revision 1.86  2001/04/08 17:23:46  dce
 * Show file was overwritting the buffer, so I increased
 * the size by using a new buffer.
 *
 * Revision 1.85  2001/04/07 17:02:30  dce
 * Added the vitem command.
 *
 * Revision 1.84  2001/04/02 03:18:41  dce
 * Added the command vwear.
 *
 * Revision 1.83  2001/03/31 22:17:56  dce
 * Tried to increase zonebuf larger than MAX_STIRNG_LENGTH
 * I am curious if this will crash the mud. (show zones).
 *
 * Revision 1.82  2001/03/28 02:08:26  dce
 * Show file works as advertised.
 *
 * Revision 1.81  2001/03/26 02:17:18  dce
 * Show file now goes beyond one page.
 *
 * Revision 1.80  2001/03/24 19:42:27  dce
 * Stating an object will show the level.
 *
 * Revision 1.79  2001/03/10 18:45:33  dce
 * Changed do_return function to pass a subcommand of 1.
 * This way I can make it so players can't use the return command.
 *
 * Revision 1.78  2001/03/07 03:08:09  dce
 * Fixed the output.
 *
 * Revision 1.77  2001/03/04 14:27:39  dce
 * Added the page function to show zones.
 *
 * Revision 1.76  2001/03/03 18:07:10  dce
 * Gods should not be able to use return from a shapechange.
 * Also mortals can no longer use return.
 *
 * Revision 1.75  2001/01/29 05:05:30  rsd
 * Ok, aded a couple of include to call mkdir so Jimmy and
 * I could redo pfile maint to clean up bogus files that
 * weren't being accounted for in the way pfilemaint was
 * being done.
 *
 * Revision 1.74  2000/11/28 00:46:32  mtp
 * remove mobprog stuff
 *
 * Revision 1.73  2000/11/25 08:12:06  rsd
 * Altered some of do_show() to comment why the case:zones
 * can't be put through the paging function.
 *
 * Revision 1.72  2000/11/20 05:02:57  rsd
 * added back rlog messages from before the addition of the
 * $log$ string.
 * grumble
 *
 * Revision 1.71  2000/11/16 02:43:00  rsd
 * added a check in do_name() nlist so if players names have
 * been declined they won't show up in nlist among the players
 * who are awaiting approval.
 *
 * Revision 1.70  2000/11/11 00:04:36  mtp
 * continue processing quest list even if a bad one was found
 *
 * Revision 1.69  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.68  2000/11/03 05:37:17  jimmy
 * Removed the quest.h file from structs.h arg!! and placed it
 * only in the appropriate files
 * Updated the dependancies in the Makefile and created
 * make supahclean.
 *
 * Revision 1.67  2000/11/02 23:41:19  mtp
 * added qid_num for debugging purposes
 *
 * Revision 1.66  2000/11/02 23:38:09  mtp
 * real_quest() for non existant virtual quest returns -1!
 *
 * Revision 1.65  2000/11/01 00:44:35  mtp
 * added extra check to avoid crashing mud...dunno why quests is not being nulled though
 *
 * Revision 1.64  2000/10/27 00:34:45  mtp
 * modeified do_stat to show quest info
 *
 * Revision 1.63  2000/10/13 04:27:23  cmc
 * added "level gain" toggle
 * typo correction duties
 *
 * Revision 1.62  2000/09/14 00:54:08  rsd
 * Fixed purge again, put proper logic not to return out
 * of the function in it.
 *
 * Revision 1.61  2000/09/13 22:20:43  rsd
 * altered the level at which set sub commands are avail
 *
 * Revision 1.60  2000/09/13 21:06:28  rsd
 * Fixed it so object without any wear flags, notably TAKE
 * , are not purged unless it's an argument.  So boards and
 * fountains etc won't be purged on a room purge.
 * Like the old Fiery.  Also
 * In do_players added the players level in (parens) so it's
 * easier to tell if anyone has advanced and needs name approval
 * just some admin stuffs.
 *
 * Revision 1.59  2000/08/31 17:45:35  rsd
 * Ok, more passwd changes
 *
 * Revision 1.58  2000/04/26 23:33:56  rsd
 * made name declination a little more obvious to the players
 * Also took some lame text out of the terminate command
 *
 * Revision 1.57  2000/04/22 22:31:41  rsd
 * fixed spelling of deity in player output.
 *
 * Revision 1.56  2000/04/14 19:09:35  rsd
 * passwd changes
 *
 * Revision 1.55  2000/04/14 18:56:15  rsd
 * OK I can definately use it now
 *
 * Revision 1.54  2000/04/14 18:52:26  rsd
 * I moved passwd to my level I swear
 *
 * Revision 1.53  2000/04/14 18:48:34  rsd
 * made passwd my level
 *
 * Revision 1.52  2000/02/25 02:42:00  rsd
 * added room and zone info to do_world, I even made a
 * variable for it woo.
 * /s
 *
 * Revision 1.51  2000/02/24 01:04:18  dce
 * Changed wiztitle from a command to a set.
 *
 * Revision 1.50  2000/02/16 07:58:39  mtp
 * added listrace...it just prints the choice menu that people have when they start
 *
 * Revision 1.49  2000/02/16 07:16:12  rsd
 * Aredryk fixed show zones (all) to fix overflow so the
 * list wouldn't truncate and stomp memory
 *
 * Revision 1.48  2000/01/31 03:58:41  cso
 * modified do_game to allow different game toggles to have different
 * min levels. it also looked ugly and kludgy, so i recoded it from scratch
 *
 * Revision 1.47  2000/01/30 23:11:18  rsd
 * added parts to allow a good races toggle in
 * addition to the existing complete race login toggle.
 *
 * Revision 1.46  1999/11/28 22:49:49  cso
 * do_stat_object: made stat on corpse reflect whether raisable or not
 * do_wizutil: unaffecting animated mob kills it
 *
 * Revision 1.45  1999/10/30 15:21:06  rsd
 * removed superflous void gain_exp(struct... definition
 * redundancy isn't needed.
 *
 * Revision 1.44  1999/10/04 21:39:18  rsd
 * Made holylight a set as well as a toggle, we have a mortal
 * who got it set on in a rez bug.
 *
 * Revision 1.43  1999/09/16 01:15:11  dce
 * Weight restrictions for monks...-hitroll, -damroll + ac
 *
 * Revision 1.42  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.41  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most significant
 * changes were moving all the BREATH's to within normal spell range, and
 * fixing the way socials were allocated.  Too many small fixes to list them
 * all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.40  1999/08/18 22:39:24  mtp
 * fixed afk bug in ptell
 *
 * Revision 1.39  1999/08/12 21:01:00  mud
 * Added the build number and compiled date functionality
 * to the world command. Reformatted the game command to add
 * spanky colors with the keyword toggles in addition to the
 * lines that indicate what state each toggle is in.
 *
 * Revision 1.38  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.37  1999/08/12 06:15:03  mtp
 * Added AFK message for ptell
 *
 * Revision 1.36  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.35  1999/07/29 20:19:35  jimmy
 * Added an idle time deletion algorithm to pfilemaint.  Players will now
 * be autodeleted after 14+((level - 1) * 3) days of idle time.
 * --gurlaek
 *
 * Revision 1.34  1999/07/26 00:20:59  mud
 * altered the priority of red and yellow color in do_players
 * so that players who are set newname on will take higher
 * precedence over those with napprove on.
 *
 * Revision 1.33  1999/07/24 23:27:13  jimmy
 * Yet another fix to pfilemaint.  Pfilemaint now destroys the old
 * player_table and rebuilds it on the fly.  NO more wierdness.
 *
 * --Gurlaek
 *
 * Revision 1.32  1999/07/23 23:37:38  jimmy
 * Fixed pfilemaint to do more sanity checking before deletions.
 * Only deletions are now logged and each is logged with a reason.
 * removed the send_toxnames from do_set "rename".  This should ahve
 * been in the interpreter all along and that's where i moved it from
 * in the first place.
 * --gurlaek
 *
 * Revision 1.31  1999/07/22 17:43:59  jimmy
 * Wrote a new command to do player file maintenace called pfilemaint.
 * This command will purge the player file using the same criteria
 * for creating new playes.  So, if it's in the xnames, it gets waxed
 * from the player file.  This will also take care of blank records
 * and reserved words.
 * --gurlaek
 *
 * Revision 1.30  1999/07/10 15:41:23  mud
 * added SLOWNS to the game toggles.
 *
 * Revision 1.29  1999/07/10 05:30:49  mud
 * made OOC a game sumcommand to prepare it to be removed
 * from the toggle subcommand list. And it works! wooo!
 *
 * Revision 1.28  1999/07/10 03:13:30  mud
 * Ok, I think I fixed the date command, I'm not very confident
 * that it works perfectly and someone should probably double
 * check my work.
 *
 * Revision 1.27  1999/07/07 22:53:38  mud
 * added the guts of the new do_world command, basically
 * stole the date subcommands and took out the logic splitting
 * them into two commands.
 *
 * Revision 1.26  1999/07/07 22:07:12  mud
 * Changed the do_world command to do game and altered the format
 * and color.
 *
 * Revision 1.25  1999/07/06 19:57:05  jimmy
 * This is a Mass check-in of the new skill/spell/language assignment system.
 * This New system combines the assignment of skill/spell/language for
 * both mobs and PCs.  LOts of code was touched and many errors were fixed.
 * MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
 * MObs now get random skill/spell/language levels baseed on their race/class/level
 * that exactly align with PC's.  PC's no longer have to rent to use skills gained
 * by leveling or when first creating a char.  Languages no longer reset to defaults
 * when a PC levels.  Discovered that languages have been defined right in the middle
 * of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
 * the mob files to compensate for the 13 to -1 class change.
 * --gurlaek 7/6/1999
 *
 * Revision 1.24  1999/06/30 18:11:09  jimmy
 * act.offensive.c    config.c      handler.c    spells.c
 * his is a major conversion from the 18 point attribute system to the
 * 100 point attribute system.  A few of the major changes are:
 * All attributes are now on a scale from 0-100
 * Everyone views attribs the same but, the attribs for one race
 *   may be differeent for that of another even if they are the
 *   same number.
 * Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * Mobs now have individual random attributes based on race/class.
 * The STR_ADD attrib has been completely removed.
 * All bonus tables for attribs in constants.c have been replaced by
 *   algorithims that closely duplicate the tables except on a 100 scale.
 * Some minor changes:
 * Race selection at char creation can now be toggled by using
 *   <world races off>
 * Lots of cleanup done to affected areas of code.
 * Setting attributes for mobs in the .mob file no longer functions
 *   but is still in the code for later use.
 * We now have a spare attribut structure in the pfile because the new
 *   system only used three instead of four.
 * --gurlaek 6/30/1999
 *
 * Revision 1.23  1999/06/22 18:23:36  jimmy
 * Added more checks for d->character in ndecline and naccept to stop
 * crashes when people were at CON_QANSI etc etc and ndecline or naccept
 * were typed.
 * gurlaek
 *
 * Revision 1.22  1999/06/18 21:56:51  mud
 * Added code to make set file renames write to xnames file
 * so those players who are denied and aren't online will be
 * written to xnames
 * I'm the man
 *
 * Revision 1.21  1999/06/18 17:25:42  jimmy
 * added check for d->character in the nlist (do_name) command.  This
 * fixed the problem of crashes when people where at CON_QANSI or
 * anywhere before their d->character's where created and someone typed
 * nlist.  --gurlaek.
 *
 * Revision 1.20  1999/06/11 17:58:10  jimmy
 * tweaked do_players to better utilize memory. --gurlaek
 *
 * Revision 1.19  1999/06/10 21:47:42  mud
 * Added color code to do_players I even freed my memory.
 *
 * Revision 1.18  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.17  1999/05/04 18:03:09  dce
 * Offer fixed
 *
 * Revision 1.16  1999/05/04 17:19:33  dce
 * Name accept system...version one...original code by Fingh, fixed up to work
 * by Zantir.
 *
 * Revision 1.15  1999/05/01 03:15:33  dce
 * Set can now toggle anonymous flag
 *
 * Revision 1.14  1999/04/20 22:40:38  jimmy
 * Fixed a silly overflow in do_players.  Once the length of all the
 * player's names exceeded the bufffer length boom!  Now you must type a
 * letter and only player's names beginning with that letter are displayed.
 * --Gurlaek
 *
 * Revision 1.13  1999/03/13 19:42:28  jimmy
 * fixed silly crashbug in show error
 * fingon
 *
 * Revision 1.12  1999/02/26 22:30:30  dce
 * Fixes file command to work in show command
 *
 * Revision 1.11  1999/02/23 16:48:06  dce
 * Creates a new command called file. Allows us to view files
 * through the mud.
 *
 * Revision 1.10  1999/02/19 01:58:44  dce
 * Changes wiztitle to max text length of 10
 *
 * Revision 1.9  1999/02/12 16:25:09  jimmy
 * Fixed poofs to show a default poof if none is set.
 *
 * Revision 1.8  1999/02/10 22:21:42  jimmy
 * Added do_wiztitle that allows gods to edit their
 * godly title ie Overlord.  Also added this title
 * to the playerfile
 * fingon
 *
 * Revision 1.7  1999/02/06 17:49:29  jimmy
 * Gods can now type goto home to get to
 * their homerooms.
 *
 * Revision 1.6  1999/02/06 00:40:36  jimmy
 * Major change to incorporate aliases into the pfile
 * moved alias structure from interpreter.h to structs.h
 * heavily modified alias code in interpreter.c
 * Jimmy Kincaid AKA fingon
 *
 * Revision 1.5  1999/02/05 07:47:42  jimmy
 * Added Poofs to the playerfile as well as 4 extra strings for
 * future use.  fingon
 *
 * Revision 1.4  1999/02/02 02:41:42  mud
 * dos2unix
 * Replaced Occurences of Hubis with Fiery
 *
 * Revision 1.3  1999/02/01 08:12:46  jimmy
 * Fixed show god --Fingon
 *
 * Revision 1.2  1999/01/31 19:26:45  jimmy
 * Fixed "show death" --fingon
 *
 * Revision 1.1
 * Initial Revision
 *
 ***************************************************************************/
@


1.336
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.335 2011/03/16 13:39:58 myc Exp $
d86 2
a87 2
extern long global_pulse;
extern long reboot_pulse;
d90 1
a90 1
extern int reboot_warning_minutes;
d2851 1
a2851 1
      "Max group level difference is off: "},
d2853 1
a2853 1
    { NULL,0,  NULL, 0, NULL, NULL }
d2927 1
a2927 1
   int hours, mins, minutes;
d3044 1
a3044 1
      mins = atoi(field2);
d3088 1
a3088 1
      mins = atoi(field + 1);
d3090 1
a3090 1
      hours = atoi(field);
d3093 1
a3093 1
         mins = atoi(s + 1);
d3250 2
a3251 1
  int vnum, rnum, i;
d3747 3
@


1.335
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.334 2010/06/05 14:56:27 mud Exp myc $
d654 1
a654 1
    log(buf);
d659 1
a659 1
    log(buf);
d664 1
a664 1
    log(buf);
d689 1
a689 1
    log(buf);
d695 1
a695 1
    log(buf);
d1347 1
a1347 1
  log(buf);
d1916 1
a1916 1
      log(buf);
d2982 1
a2982 1
      log(buf);
d3003 1
a3003 1
      log(buf);
d3028 1
a3028 1
      log(buf);
d3056 1
a3056 1
      log(buf);
d3111 1
a3111 1
      log(buf);
d3334 1
a3334 1
    log(buf);
d3380 1
a3380 1
  log(buf);
d3439 1
a3439 1
      log(buf);
d3443 1
a3443 1
        log(buf);
d3459 1
a3459 1
  log(buf);
d3533 1
a3533 1
  log(buf);
d3746 4
@


1.334
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.333 2009/06/09 19:33:50 myc Exp mud $
d160 1
a160 1
    if (!arg || !*arg) {
d263 1
a263 1
    if (!arg || !*arg) {
d836 1
a836 1
  if (!arg1 || !*arg1 || !arg2 || !*arg2) {
d3746 3
@


1.333
log
@Modified advance command to use the new gain_exp for both advancing
and demoting, removing the need to call start_player.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.332 2009/06/09 05:32:10 myc Exp myc $
d43 1
d3746 4
@


1.332
log
@Clan's underlying implementation has been completely reworked.
Minor changes to advance, set, and terminate commands to
comply.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.331 2009/06/02 02:45:40 myc Exp myc $
d1016 6
a1021 7
  if (*name) {
    if (!(victim = find_char_around_char(ch, find_vis_by_name(ch, name)))) {
      send_to_char("That player is not here.\r\n", ch);
      return;
    }
  } else {
    send_to_char("Advance who?\r\n", ch);
d1024 1
a1057 8
    /*
     * If the player is in a clan, decrease the power of the clan, since
     * start_player() will set the player's level to 1.  advance_level (called
     * by gain_exp_regardless below) will increase the clan's power again.
     */
    if (GET_CLAN(victim) && IS_CLAN_MEMBER(victim))
      GET_CLAN(victim)->power -= GET_LEVEL(victim);
    start_player(victim);
d1095 1
a1095 1
  send_to_char(OK, ch);
d1098 2
a1099 1
    sprintf(buf, "(GC) %s has demoted %s from level %d to %d.",
d1102 2
a1103 1
    sprintf(buf, "(GC) %s has advanced %s to level %d (from %d)",
a1104 1
  log(buf);
d1106 3
a1108 2
  gain_exp_regardless(victim, (exp_next_level((newlevel - 1),
              GET_CLASS(victim)) - GET_EXP(victim) + 1));
d3745 5
@


1.331
log
@No more message to the room when a wizinvis god loads an object.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.330 2009/03/20 23:02:59 myc Exp myc $
d58 1
a58 1
#include "text.h"
d1064 1
a1064 1
      modify_clan_power(GET_CLAN(victim), -GET_LEVEL(victim));
d2416 1
a2416 1
      modify_clan_power(GET_CLAN(vict), -GET_LEVEL(vict));
d2420 1
a2420 3
      modify_clan_power(GET_CLAN(vict), GET_LEVEL(vict));
    if (GET_CLAN(vict) && IS_CLAN_GOD(vict))
      remove_player_from_clan(GET_NAME(vict), GET_CLAN(vict));
d3327 2
a3328 6
    if (GET_CLAN(victim)) {
      int clan = find_clan_by_id(GET_CLAN(victim));
      if (clan >= 0 && IS_CLAN_MEMBER(victim))
        clans[clan].power -= GET_LEVEL(victim);
      remove_player_from_clan(GET_NAME(victim), GET_CLAN(victim));
    }
d3751 3
@


1.330
log
@Move text file handling routines into text.c, including the
tedit command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.329 2009/03/16 19:17:43 jps Exp myc $
d945 1
a945 1
    act("$n has created $p!", FALSE, ch, obj, 0, TO_ROOM);
d3757 4
@


1.329
log
@Change set loadroom to set homeroom.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.328 2009/03/09 20:36:00 myc Exp jps $
d58 1
a1631 1
  extern char *motd;
d1686 1
a1686 1
          write_to_output(motd, d);
a3129 87

 ACMD(do_tedit) {
    int l, i;
    char field[MAX_INPUT_LENGTH];
    extern char *credits;
    extern char *news;
        extern char *anews;
    extern char *motd;
    extern char *imotd;
    extern char *help;
    extern char *info;
    extern char *background;
    extern char *handbook;
    extern char *policies;

    struct editor_struct {
       char *cmd;
       char level;
       char **buffer;
       int  size;
       char *filename;
    } fields[] = {
       /* edit the lvls to your own needs */
         { "credits",        LVL_IMPL,        &credits,        2400,        CREDITS_FILE},
         { "news",        LVL_GRGOD,        &news,                8192,        NEWS_FILE},
         { "anews",        LVL_GRGOD,        &anews,                8192,        ANEWS_FILE},
        { "motd",        LVL_GRGOD,        &motd,                2400,        MOTD_FILE},
         { "imotd",        LVL_HEAD_B,        &imotd,                2400,        IMOTD_FILE},
         { "help",       LVL_GRGOD,        &help,                2400,        HELP_PAGE_FILE},
         { "info",        LVL_GRGOD,        &info,                8192,        INFO_FILE},
        { "background",        LVL_GRGOD,        &background,        8192,        BACKGROUND_FILE},
         { "handbook",   LVL_HEAD_B,        &handbook,        8192,   HANDBOOK_FILE},
         { "policies",        LVL_IMPL,        &policies,        8192,        POLICIES_FILE},
         { "\n",                0,                NULL,                0,        NULL }
    };

    if (ch->desc == NULL) {
       send_to_char("Get outta here you linkdead head!\r\n", ch);
       return;
    }

    if (GET_LEVEL(ch) < LVL_GRGOD) {
       send_to_char("You do not have text editor permissions.\r\n", ch);
       return;
    }

    half_chop(argument, field, buf);

    if (!*field) {
       strcpy(buf, "Files available to be edited:\r\n");
       i = 1;
       for (l = 0; *fields[l].cmd != '\n'; l++) {
          if (GET_LEVEL(ch) >= fields[l].level) {
             sprintf(buf, "%s%-11.11s", buf, fields[l].cmd);
             if (!(i % 7)) strcat(buf, "\r\n");
             i++;
          }
       }
       if (--i % 7) strcat(buf, "\r\n");
       if (i == 0) strcat(buf, "None.\r\n");
       send_to_char(buf, ch);
      return;
    }
    for (l = 0; *(fields[l].cmd) != '\n'; l++)
      if (!strncmp(field, fields[l].cmd, strlen(field)))
        break;

    if (*fields[l].cmd == '\n') {
       send_to_char("Invalid text editor option.\r\n", ch);
       return;
    }

    if (GET_LEVEL(ch) < fields[l].level) {
       send_to_char("You are not godly enough for that!\r\n", ch);
       return;
    }

    /* set up editor stats */
    send_to_char("\x1B[H\x1B[J", ch);
    send_to_char("Edit file below: (/s saves /h for help)\r\n", ch);
    string_write(ch->desc, fields[l].buffer, fields[l].size);
    ch->desc->storage = strdup(fields[l].filename);
    act("$n begins editing a scroll.", TRUE, ch, 0, 0, TO_ROOM);
    SET_FLAG(PLR_FLAGS(ch), PLR_WRITING);
    STATE(ch->desc) = CON_TEXTED;
 }

d3757 3
@


1.328
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.327 2009/03/09 05:59:57 myc Exp myc $
d487 1
a487 1
    if( (location = real_room(GET_HOME(ch))) < 0 ) {
d2071 1
a2071 1
   { "home",         LVL_GOD,         PC,   NUMBER },
d2093 1
a2093 1
   { "loadroom",     LVL_GOD,         PC,   MISC   },
d2343 1
a2343 1
    GET_HOME(vict) = value;
d2475 1
a2475 3
    if (!str_cmp(val_arg, "off"))
      REMOVE_FLAG(PLR_FLAGS(vict), PLR_LOADROOM);
    else if (is_number(val_arg)) {
d2478 3
a2480 4
        SET_FLAG(PLR_FLAGS(vict), PLR_LOADROOM);
        GET_LOADROOM(vict) = value;
        sprintf(buf, "%s will enter at room #%d.\r\n", GET_NAME(vict),
                GET_LOADROOM(vict));
d2486 1
a2486 1
      strcpy(buf, "Must be 'off' or a room's virtual number.\r\n");
d3844 3
@


1.327
log
@The mud now keeps track of all previous boot times, including
hotboot times.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.326 2009/03/08 23:34:14 jps Exp myc $
d2564 1
a2564 1
    GET_PLAT(vict) = RANGE(0, 100000000);
d2576 1
a2576 1
    GET_BANK_PLAT(vict) = RANGE(0, 100000000);
d3847 4
@


1.326
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.325 2009/03/08 21:43:27 jps Exp jps $
d1401 1
a1401 1
  extern time_t boot_time;
d1406 1
a1406 1
    mytime = boot_time;
d1414 1
a1414 1
    mytime = time(0) - boot_time;
d3579 1
d3584 1
a3584 1
  extern time_t boot_time;
d3639 5
a3643 2
  /* Write boot_tyime as first line in file */
  fprintf(fp, "%ld %d\n", boot_time, num_hotboots);
d3847 3
@


1.325
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.324 2009/03/03 19:41:50 myc Exp jps $
d31 1
a31 1
#include "spells.h"
d3843 3
@


1.324
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.323 2009/02/17 01:50:08 myc Exp myc $
d55 3
d3843 3
@


1.323
log
@'set maxhit' was broken for NPCs.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.322 2009/02/11 17:03:39 myc Exp myc $
d165 1
a165 1
         } else if (!(vict = get_char_vis(ch, arg))) {
d318 1
a318 1
  if (!(vict = get_char_vis(ch, arg))) {
d370 1
a370 1
  else if (!(vict = get_char_vis(ch, buf)))
d410 2
a411 1
  } else if ((target_mob = get_char_vis(ch, roomstr)))
d413 1
a413 1
  else if ((target_obj = get_obj_vis(ch, roomstr))) {
d520 1
a520 1
  if (get_player_vis(ch, arg, 0)) {
d561 1
a561 1
    if (!(victim = get_char_vis(ch, buf)))
d615 1
a615 1
  else if (!(victim = get_char_vis(ch, buf)))
d774 1
a774 1
  } else if (!(victim = get_char_vis(ch, arg)))
d794 1
a794 1
  else if (!(victim = get_char_vis(ch, arg)))
d960 1
a960 1
    if ((vict = get_char_room_vis(ch, buf))) {
d977 1
a977 1
    } else if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
d1013 1
a1013 1
    if (!(victim = get_char_vis(ch, name))) {
d1146 1
a1146 1
   else if (!(vict = get_char_vis(ch, buf)))
d1178 1
a1178 1
   else if (!(vict = get_char_vis(ch, buf)))
d1437 1
a1437 1
    if (!(vict = get_char_vis(ch, arg)))
d1906 1
a1906 1
  else if (!(vict = get_char_vis(ch, arg)))
d2157 1
a2157 1
      if (!(vict = get_player_vis(ch, name, 0))) {
d2162 1
a2162 1
      if (!(vict = get_char_vis(ch, name))) {
d3400 1
a3400 1
  victim = get_char_vis(ch,buf);
d3840 3
@


1.322
log
@Updating ptell, wiznet, and broadcast_name to check EDITING(d)
wherever WRITING flag is checked.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.321 2009/01/19 08:42:29 myc Exp myc $
d2234 7
a2240 2
    GET_BASE_HIT(vict) = RANGE(1, 500000);
    effect_total(vict);
d3839 4
@


1.321
log
@Send 'iptables list' output through pager.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.320 2009/01/18 07:12:48 myc Exp myc $
d350 2
a351 1
        !PLR_FLAGGED(d->character, PLR_MAILING))
d381 3
d1519 2
d1571 1
a1571 1
    if (STATE(d) != CON_PLAYING || PLR_FLAGGED(d->character, PLR_WRITING) || PLR_FLAGGED(d->character, PLR_MAILING))
d1602 6
a1607 7
  {
    if ((!d->connected) && (GET_LEVEL(d->character) >= LVL_IMMORT) &&
        (!PLR_FLAGGED(d->character, PLR_WRITING) && !PLR_FLAGGED(d->character, PLR_MAILING)))
    {
       send_to_char(temp, d->character);
    }
  }
d3834 3
@


1.320
log
@People couldn't see 'echo' output if god using echo was invisible.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.319 2009/01/18 06:58:53 myc Exp myc $
d143 4
a146 4
    while(get_line(tmp, cBuf)) {
      send_to_char(cBuf, ch);
      send_to_char("\r\n", ch);
    }
d3829 3
@


1.319
log
@Adding "emote's" command so you can emote stuff like
"Laoris's arms are tired."
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.318 2009/01/16 23:36:34 myc Exp myc $
d298 1
a298 1
    act(buf, TRUE, ch, 0, 0, TO_ROOM);
d3829 4
@


1.318
log
@Fix buffer overwrite in do_rclone().
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.317 2008/09/25 04:56:09 jps Exp myc $
d285 1
a285 1
    if (subcmd == SCMD_EMOTE) {
d293 1
a293 1
      sprintf(buf, "$n %s&0", argument);
d3829 3
@


1.317
log
@Require a name with coredump. This will reduce inadvertent coredumps.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.316 2008/09/25 04:48:28 jps Exp jps $
d3333 2
a3334 2
  int vroom, rroom, i;
  struct room_data *room;
d3338 1
a3338 1
    send_to_char("Format: hhroom <room number>\r\n", ch);
d3342 2
a3343 2
  vroom = atoi(buf2);
  rroom = real_room(vroom);
d3345 7
a3351 3
  if (rroom <= 0) {
    sprintf(buf, "There is no room with the number %d.\r\n", vroom);
    send_to_char(buf, ch);
d3355 2
a3356 1
  *room = world[rroom];
d3358 7
a3364 5
  if (world[ch->in_room].description)
    world[rroom].description = strdup(world[ch->in_room].description);
  if (world[ch->in_room].name)
    world[rroom].name = strdup(world[ch->in_room].name);
  if (world[ch->in_room].room_flags)
d3366 3
a3368 3
      world[rroom].room_flags[i] = world[ch->in_room].room_flags[i];
  if (world[ch->in_room].sector_type)
    world[rroom].sector_type = world[ch->in_room].sector_type;
d3370 1
a3370 1
  olc_add_to_save_list(zone_table[find_real_zone_by_room(vroom)].number, OLC_SAVE_ROOM);
d3372 1
a3372 2
  sprintf(buf, "You clone this room to room %d.\r\n", vroom);
  send_to_char(buf, ch);
d3829 3
@


1.316
log
@Add coredump command for lvl 104+
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.315 2008/09/20 07:31:10 jps Exp jps $
d3814 3
a3816 1
   if (*argument) {
a3817 2
   } else {
      drop_core(ch, NULL);
d3823 3
@


1.315
log
@Removed some unused code.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.314 2008/09/20 06:05:06 jps Exp jps $
d3810 10
d3823 3
@


1.314
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.313 2008/09/07 20:05:27 jps Exp jps $
a3419 21
  /*else {
     CREATE(cbuf, struct char_data, 1);
     clear_char(cbuf);
     if ((player_i = load_char(buf, &tmp_store)) > -1) {
       store_to_char(&tmp_store, cbuf);
       GET_PFILEPOS(cbuf) = player_i;
       act("&RYou destroy &W$N&R forever.&N", FALSE, ch, 0, cbuf, TO_CHAR);
       SET_FLAG(PLR_FLAGS(cbuf), PLR_DELETED);
       save_player_char(cbuf);
       Crash_delete_file(GET_NAME(cbuf));
       if (cbuf->desc) {
          close_socket(cbuf->desc);
          cbuf->desc = NULL;
       }
       return;
     } else {
         free(cbuf);
         send_to_char("There is no such player.\r\n", ch);
         return;
     }
  }*/
d3813 3
@


1.313
log
@Renamed exp_to_level to exp_next_level to make it clearer what it means.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.312 2008/09/07 05:46:43 jps Exp jps $
d785 1
a785 1
  if (ch->desc->original)
d868 2
a869 2
  if (ch->desc && ch->desc->original) {
    if (GET_LEVEL(ch->desc->original) < 101 && subcmd == 0) {
a879 1
    /* JE 2/22/95 */
d3834 3
@


1.312
log
@Allow wiznetting TO people under level 100.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.311 2008/09/02 06:52:30 jps Exp jps $
d1105 2
a1106 1
  gain_exp_regardless(victim, (exp_to_level((newlevel - 1), GET_CLASS(victim)) - GET_EXP(victim) + 1));
d3835 3
@


1.311
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.310 2008/09/01 23:47:49 jps Exp jps $
d1478 1
d1495 1
a1495 1
      level = MAX(atoi(buf1), LVL_IMMORT);
d1500 1
d1554 1
a1554 1
  if (level > LVL_IMMORT) {
d3834 3
@


1.310
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.309 2008/09/01 22:15:59 jps Exp jps $
d54 1
d3832 3
@


1.309
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.308 2008/08/31 22:16:36 myc Exp jps $
d53 1
a55 1
void dismount_char(struct char_data * ch);
d3831 3
@


1.308
log
@Fix errors in linkload by putting the char in a room before equipping.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.307 2008/08/30 20:42:50 myc Exp myc $
d961 1
d969 3
a971 2
      }
      extract_char(vict);
d3653 2
a3654 1
      save_player(tch, SAVE_HOTBOOT);
d3831 3
@


1.307
log
@Ending all communication with a color reset.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.306 2008/08/30 01:31:51 myc Exp myc $
d525 1
a530 1
      char_to_room(victim, IN_ROOM(ch));
d3828 3
@


1.306
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.305 2008/08/29 19:18:05 myc Exp myc $
a278 2
  char *echo;

a292 1
      echo = buf;
d295 1
a295 1
      echo = argument;
d297 1
a297 1
    act(echo, TRUE, ch, 0, 0, TO_ROOM);
d302 1
a302 1
      act(echo, FALSE, ch, 0, 0, TO_CHAR);
d321 1
a321 2
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
d324 2
a325 4
  else {
    sprintf(buf2, "You send '%s' to %s.\r\n", buf, GET_NAME(vict));
    send_to_char(buf2, ch);
  }
d3287 1
a3287 1
            cprintf(i, "%s\r\n", argument);
d3295 1
a3295 1
      cprintf(ch, "%s\r\n", argument);
d3313 1
a3313 1
            cprintf(i, "%s\r\n", argument);
d3320 1
a3320 1
      cprintf(ch, "%s\r\n", argument);
d3828 6
@


1.305
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.304 2008/08/29 13:19:46 myc Exp myc $
a1152 2
         /* next two lines added for the confersion to the 100 attrib scale */
         vict->actual_abils = vict->natural_abils;
d2231 1
a2231 1
    update_stats(vict);
d2258 1
a2258 2
    RANGE(30, 100);
    GET_NATURAL_STR(vict) = value;
d2272 1
a2272 2
    RANGE(25, 100);
    GET_NATURAL_INT(vict) = value;
a2274 1
    /*Edited by Proky values for Wis*/
d2276 1
a2276 2
    RANGE(25, 100);
    GET_NATURAL_WIS(vict) = value;
d2280 1
a2280 2
    RANGE(25, 100);
    GET_NATURAL_DEX(vict) = value;
a2282 1
    /*Edited by Proky, values for Wis*/
d2284 1
a2284 2
    RANGE(25, 100);
    GET_NATURAL_CON(vict) = value;
a2285 1
    /*con_aff(vict);*/
d2300 1
a2300 1
    vict->points.armor = RANGE(-100, 100);
d2336 1
a2336 1
    vict->points.hitroll = RANGE(-20, 40);
d2340 1
a2340 1
    vict->points.damroll = RANGE(-20, 36);
d2512 1
a2512 5
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 100);
    else
      RANGE(30, 100);
    GET_NATURAL_CHA(vict) = value;
d3834 4
@


1.304
log
@"goto home" now takes you to your homeroom, not load room.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.303 2008/08/29 04:16:26 myc Exp myc $
d1154 1
a1154 1
         vict->viewed_abils = vict->natural_abils;
d3848 3
@


1.303
log
@Changed calls to look_at_room and moved its prototype to a header file.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.302 2008/08/26 03:58:13 jps Exp myc $
d484 1
a484 1
    if( (location = real_room(GET_LOADROOM(ch))) < 0 ) {
d3848 3
@


1.302
log
@Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
Except the one for wzoneecho, since it needed to find a real zone by zone number.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.301 2008/08/24 03:32:32 myc Exp jps $
d52 1
a56 1
long exp_to_level(int, int);
d507 1
a507 1
  look_at_room(ch, 0);
a1007 1
  long exp_to_level(int, int);
d3848 4
@


1.301
log
@If text is provided with rrestore/rpain, it's gechoed and the normal
message is suppressed.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.300 2008/08/23 21:36:22 myc Exp myc $
d3379 1
a3379 1
  olc_add_to_save_list(zone_table[real_zone(vroom)].number, OLC_SAVE_ROOM);
d3849 4
@


1.300
log
@Fix dig command so it doesn't always dig north.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.299 2008/08/17 20:16:24 jps Exp myc $
d3302 3
d3307 5
a3311 2
         act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in $s path!&0",
               FALSE, ch, 0, i, TO_VICT | TO_SLEEP);
d3315 4
a3318 1
   send_to_char(OK, ch);
d3326 3
d3330 2
a3331 2
      if (i != ch) {
         if (!IS_NPC(i) && GET_LEVEL(i) < LVL_IMMORT)
d3333 5
a3337 2
         act("&0&1$n &0&9&bspreads pain and pestilence across the realm &0&1&bharming&0&9&b all in $s path!&0",
               FALSE, ch, 0, i, TO_VICT | TO_SLEEP);
d3340 4
a3343 1
   send_to_char(OK, ch);
d3849 3
@


1.299
log
@Use macro parse_direction
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.298 2008/08/16 23:03:43 jps Exp jps $
a3264 3
   char buf2[10];
   char buf3[10];
   char buf[80];
d3268 2
a3269 2
   two_arguments(argument, buf2, buf3);
   iroom = atoi(buf3);
d3272 1
a3272 4
   if (!*buf2) {
      cprintf(ch, "Format: dig <dir> <room number>\r\n");
      return;
   } else if (!*buf3) {
d3277 2
a3278 3
   if (rroom <= 0) {
      sprintf(buf, "There is no room with the number %d", iroom);
      send_to_char(buf, ch);
d3282 2
a3283 2
   if ((dir = parse_direction(buf2) < 0)) {
      cprintf(ch, "That isn't a valid direction.\r\n");
d3295 1
a3295 1
   cprintf(ch, "You make an exit %s to room %d.\r\n", buf2, iroom);
d3831 3
@


1.298
log
@Applied laryngitis to emoting.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.297 2008/08/15 03:59:08 jps Exp jps $
d3265 4
a3268 1
  /* Only works if you have Oasis OLC */
d3270 1
a3270 6
  char buf2[10];
  char buf3[10];
  char buf[80];
  int iroom = 0, rroom = 0;
  int dir = 0;
/*  struct room_data *room; */
d3272 2
a3273 1
  /* buf2 is the direction, buf3 is the room */
d3275 13
a3287 2
        iroom = atoi(buf3);
        rroom = real_room(iroom);
d3289 4
a3292 36
 if (!*buf2) {
    send_to_char("Format: dig <dir> <room number>\r\n", ch);
    return; }
 else if (!*buf3) {
    send_to_char("Format: dig <dir> <room number>\r\n", ch);
    return; }
 if (rroom <= 0) {
        sprintf(buf, "There is no room with the number %d", iroom);
        send_to_char(buf, ch);
        return; }
/* Main stuff */
    switch (*buf2) {
    case 'n':
    case 'N':
      dir = NORTH;
      break;
    case 'e':
    case 'E':
      dir = EAST;
      break;
    case 's':
    case 'S':
      dir = SOUTH;
      break;
    case 'w':
    case 'W':
      dir = WEST;
      break;
    case 'u':
    case 'U':
      dir = UP;
      break;
    case 'd':
    case 'D':
      dir = DOWN;
      break; }
d3294 2
a3295 2
world[rroom].exits[rev_dir[dir]] = create_exit(ch->in_room);
world[ch->in_room].exits[dir] = create_exit(rroom);
d3297 1
a3297 2
/* Only works if you have Oasis OLC */
  olc_add_to_save_list(zone_table[world[ch->in_room].zone].number,
d3299 1
a3299 1
  olc_add_to_save_list(zone_table[world[rroom].zone].number,
d3302 1
a3302 2
 sprintf(buf, "You make an exit %s to room %d.\r\n", buf2, iroom);
 send_to_char(buf, ch);
d3838 3
@


1.297
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.296 2008/08/14 23:02:11 myc Exp jps $
d291 1
d3862 3
@


1.296
log
@Updated syslog command to support the new graduated severity levels.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.295 2008/08/14 09:45:22 jps Exp myc $
d2139 2
a2140 3
    *buf2 = 0;
    send_to_char("Usage: set <victim> <field> <value>\r\n", ch);
    send_to_char("Set fields currently available to you:\r\n", ch);
d2143 1
a2143 1
        sprintf(buf2, "%s%-20.20s %-20.20s %-6.6s\r\n", buf2, fields[l].cmd,
d2149 1
a2149 1
    page_string(ch->desc, buf2);
d3761 1
a3761 1
         page_string(ch->desc, buf);
d3772 1
a3772 1
      page_string(ch->desc, buf);
d3778 1
a3778 1
      page_string(ch->desc, buf);
d3783 1
a3783 1
      page_string(ch->desc, buf);
d3861 3
@


1.295
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.294 2008/07/27 05:27:12 jps Exp jps $
a2736 3
static const char *logtypes[] = {
"off", "brief", "normal", "complete", "\n"};

d2739 1
a2739 1
  int tp;
d2744 2
a2745 4
    tp = ((PRF_FLAGGED(ch, PRF_LOG1) ? 1 : 0) +
          (PRF_FLAGGED(ch, PRF_LOG2) ? 2 : 0));
    sprintf(buf, "Your syslog is currently %s.\r\n", logtypes[tp]);
    send_to_char(buf, ch);
d2748 6
a2753 2
  if (((tp = searchblock(arg, logtypes, FALSE)) == -1)) {
    send_to_char("Usage: syslog { Off | Brief | Normal | Complete }\r\n", ch);
a2755 6
  REMOVE_FLAG(PRF_FLAGS(ch), PRF_LOG1);
  REMOVE_FLAG(PRF_FLAGS(ch), PRF_LOG2);
  if (IS_SET(tp, 1))
    SET_FLAG(PRF_FLAGS(ch), PRF_LOG1);
  if (IS_SET(tp, 2))
    SET_FLAG(PRF_FLAGS(ch), PRF_LOG2);
d2757 5
a2761 3
  sprintf(buf, "Your syslog is now %s.\r\n", logtypes[tp]);
  send_to_char(buf, ch);
  }
d3862 3
@


1.294
log
@Using the new save_player function.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.293 2008/07/26 21:34:09 jps Exp jps $
d51 1
d2150 1
a2150 1
    page_string(ch->desc, buf2, 1);
d3767 1
a3767 1
         page_string(ch->desc, buf, 1);
d3778 1
a3778 1
      page_string(ch->desc, buf, 1);
d3784 1
a3784 1
      page_string(ch->desc, buf, 1);
d3789 1
a3789 1
      page_string(ch->desc, buf, 1);
d3867 3
@


1.293
log
@Removed objfix command and added objupdate.
Made pscan more robust.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.292 2008/07/13 19:04:52 jps Exp jps $
d1108 1
a1108 1
  save_player(victim);
d1666 1
a1666 1
        save_player(d->character);
d1736 2
a1737 2
           write_to_output("&6&bYou are welcome to play, however, you will be prompted&0\r\n&6&bfor a new name on your next login.&0\r\n", d);
           save_player(d->character);
d2008 1
a2008 1
    save_player(vict);
d2723 1
a2723 1
    save_player(vict);
d2728 1
a2728 1
      save_player(cbuf);
d3439 2
a3440 2
    save_player(victim);
    delete_crash_file(victim);
d3461 1
a3461 1
       save_player(cbuf);
d3682 2
a3683 1
      write_to_descriptor(d->descriptor, "\r\nSorry, we are rebooting.  Come back in a minute.\r\n");
d3685 1
a3685 2
    }
    else {
d3689 1
a3689 3
      save_objects(tch, SAVE_HOTBOOT);
      save_player(tch);
      save_quests(tch);
d3866 4
@


1.292
log
@Added a hotboot rent code, which allows people to save their keys
over a hotboot.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.291 2008/07/13 18:49:11 jps Exp jps $
d3723 1
a3723 2
   char fname[MAX_STRING_LENGTH];
   int i, errs = 0, location;
d3729 2
a3730 5
      /* Get filename of objects file */
      if (!get_pfilename(player_table[i].name, fname, OBJ_FILE)) {
         sprintf(buf, "SYSERR: Can't get OBJ file for %s", player_table[i].name);
         log(buf);
         errs++;
d3734 7
a3740 8
      /* Open the file */
      if (!(fl = fopen(fname, "r"))) {
         if (errno != ENOENT) {
            sprintf(buf, "SYSERR: Can't open OBJ file for %s: %s",
                  player_table[i].name, strerror(errno));
            log(buf);
            ++errs;
         }
a3743 3
      /* Skip the rent code at the beginning */
      get_line(fl, buf);

d3752 6
a3757 6
         if (!build_object(fl, &object, &location)) {
            perror("Reading crash file: read_object.");
            fclose(fl);
            ++errs;
            break;
         }
d3759 1
a3759 4
         if (GET_OBJ_VNUM(object) == vnum) {
            if (!objectshere) playerswith++;
            objectshere++;
            objectsfound++;
a3760 2

         extract_obj(object);
d3787 5
a3835 136
/* fix_objfile_eff()
 *
 * ch: the god who is issuing the instruction and needs feedback
 * filename: an object file which needs fixing
 *
 * The function will read an object save file, fix the spell flags,
 * and write it again.  In the past, the spell flags portion of the
 * object save files were garbage.  Nobody seemed to notice because
 * they were restored from the object prototype when a player logged
 * back in.  But now we want the power to modify those flags on
 * individual objects.  Thus we must be able to read and write those
 * flags.
 *
 * But since most players had garbage in there, we had to do something
 * to clean them up.  This function will do it, restoring all of the
 * spell flags to the state of the objects' prototypes.  Then with a
 * clean slate, we can trust what the flags are and begin to modify
 * them in gameplay-meaningful ways.
 *
 * Nowadays this function is only useful for cleaning up obj files
 * that have been restored from backup.  Note that if you use it on
 * a modern obj file, you will WIPE OUT any changes that have occurred
 * to object spell flags. */
int fix_objfile_eff(struct char_data *ch, char *filename)
{
   FILE *fl, *fo;
   char tmpname[MAX_STRING_LENGTH];
   struct obj_file_elem object;
   struct rent_info rent;
   int nread, nwrote, rnum;

   sprintf(tmpname, "%s.tmp", filename);

   /* Open the existing object file for reading */
   if (!(fl = fopen(filename, "r+b"))) {
      if (errno != ENOENT) {
         sprintf(buf, " * * *  Error opening %s: %s * * *\r\n",
               filename, strerror(errno));
         page_string(ch->desc, buf, 1);
      } else {
         sprintf(buf, " * * *  Object file %s missing * * *\r\n", filename);
         page_string(ch->desc, buf, 1);
      }
      return 0;
   }

   /* Open the new object file for writing */
   if (!(fo = fopen(tmpname, "w+b"))) {
      sprintf(buf, " * * *  Error opening %s: %s * * *\r\n",
            tmpname, strerror(errno));
      page_string(ch->desc, buf, 1);
      return 0;
   }

   /* Do the rent_info struct at the beginning */
   nread = fread(&rent, sizeof(rent), 1, fl);
   if (!nread || ferror(fl)) {
      sprintf(buf, " * * * Error while reading %s: %s * * *\r\n",
            filename, strerror(errno));
      page_string(ch->desc, buf, 1);
      fclose(fl);
      fclose(fo);
      return 0;
   }

   nwrote = fwrite(&rent, sizeof(rent), 1, fo);
   if (!nwrote || ferror(fo)) {
      sprintf(buf, " * * * Error while writing %s: %s * * *\r\n",
            tmpname, strerror(errno));
      page_string(ch->desc, buf, 1);
      fclose(fl);
      fclose(fo);
      return 0;
   }

   /* Read the objects */
   while (!feof(fl)) {
      nread = fread(&object, sizeof(object), 1, fl);
      if (ferror(fl)) {
         sprintf(buf, " * * * Error while reading %s: %s * * *\r\n",
               filename, strerror(errno));
         page_string(ch->desc, buf, 1);
         fclose(fl);
         fclose(fo);
         return 0;
      }
      if (!nread) break;

      rnum = real_object(object.item_number);

      if (rnum < 0) {
         sprintf(buf, " ### File %s had nonexistent obj %d ###\r\n",
               filename, object.item_number);
         page_string(ch->desc, buf, 1);
      } else {
         /* This is where the fixin' happens! */
         object.effect_flags = obj_proto[rnum].obj_flags.effect_flags[0];
         object.effect_flags2 = obj_proto[rnum].obj_flags.effect_flags[1];
         object.effect_flags3 = obj_proto[rnum].obj_flags.effect_flags[2];
      }
      nwrote = fwrite(&object, sizeof(object), 1, fo);
      if (!nwrote || ferror(fo)) {
         sprintf(buf, " * * * Error while writing %s: %s * * *\r\n",
               tmpname, strerror(errno));
         page_string(ch->desc, buf, 1);
         fclose(fl);
         fclose(fo);
         return 0;
      }
   }

   fclose(fl);
   if (fclose(fo)) {
      sprintf(buf, " * * * Error while closing %s: %s * * *\r\n",
            tmpname, strerror(errno));
      page_string(ch->desc, buf, 1);
      return 0;
   }

   /* The new file at tmpname is ready to become the main obj file */
   if (rename(tmpname, filename)) {
      sprintf(buf, " * * * Error renaming %s to %s: %s * * *",
            tmpname, filename, strerror(errno));
      page_string(ch->desc, buf, 1);
      return 0;
   }

   return 1; /* Indicating success */
}

void fix_objfile_effs(struct char_data *ch)
{
   char fname[MAX_STRING_LENGTH];
   int successes = 0, errs = 0, failures = 0, skipped = 0, i;

   for (i = 0; i <= top_of_p_table; ++i) {
d3837 1
a3837 34
      /* Get filename of objects file */
      if (!get_pfilename(player_table[i].name, fname, OBJ_FILE)) {
         sprintf(buf, "SYSERR: Can't get OBJ file for %s", player_table[i].name);
         log(buf);
         errs++;
         continue;
      }
      if (access(fname, F_OK) && errno == ENOENT) {
         sprintf(buf, "* &3SKIPPING&0 %s who has no objects file\r\n",
               player_table[i].name);
         page_string(ch->desc, buf, 1);
         skipped++;
      } else if (fix_objfile_eff(ch, fname)) {
         sprintf(buf, "+ &2SUCCESS&0 fixing object file for %s\r\n", fname);
         page_string(ch->desc, buf, 1);
         successes++;
      } else {
         sprintf(buf, "- &1FAILED&0 to fix the object file for %s\r\n", fname);
         page_string(ch->desc, buf, 1);
         failures++;
      }
   }

   sprintf(buf, "   Errors: %d\r\n", errs);
   page_string(ch->desc, buf, 1);
   sprintf(buf, "Successes: %d\r\n", successes);
   page_string(ch->desc, buf, 1);
   sprintf(buf, " Failures: %d\r\n", failures);
   page_string(ch->desc, buf, 1);
   sprintf(buf, "  Skipped: %d\r\n", skipped);
   page_string(ch->desc, buf, 1);
}

ACMD(do_objfix)
d3840 1
a3840 3
   char fname[MAX_STRING_LENGTH];

   skip_spaces(&argument);
d3842 3
a3844 12
   if (!*argument) {
      send_to_char("Usage:\r\n", ch);
      send_to_char("   objfix <player>\r\n", ch);
      send_to_char("   objfix all\r\n", ch);
      send_to_char("\r\nThis modifies the player's object save file so that all\r\n", ch);
      send_to_char("spell flags, such as blind, sanctuary, and haste, are\r\n", ch);
      send_to_char("set to be the same as they are in the object prototypes.\r\n", ch);
      send_to_char("It should only be done for a player who has just been\r\n", ch);
      send_to_char("restored from a backup.  It will erase any modifications\r\n", ch);
      send_to_char("that have been done to those flags.  It's done to the\r\n", ch);
      send_to_char("restored files because they used to be saved with\r\n", ch);
      send_to_char("garbage where the flags go.\r\n", ch);
d3848 1
a3848 3
   half_chop(argument, arg1, arg2);

   if (!strncmp("all", arg1, 4)) {
d3850 1
a3850 5
         send_to_char("&5&bWHOA!&0\r\n", ch);
         send_to_char("This is a very dangerous operation that should only be done once!\r\n",
               ch);
         send_to_char("\r\nIf you really mean it, type &2objfix all ireallymeanit&0\r\n",
               ch);
d3853 1
a3853 1
      if (strncmp("ireallymeanit", arg2, 14)) {
d3857 2
a3858 1
      fix_objfile_effs(ch);
d3860 1
a3860 13
   } else if (*arg1) {
      /* Get filename of objects file */
      if (!get_pfilename(arg1, fname, OBJ_FILE)) {
         sprintf(buf, "Can't get OBJ file for %s\r\n", arg1);
         send_to_char(buf, ch);
         send_to_char("Most likely there is no such character.\r\n", ch);
         send_to_char(buf, ch);
         return;
      }
      if (access(fname, F_OK) && errno == ENOENT) {
         send_to_char("That player has no object save file.\r\n", ch);
         return;
      }
d3862 1
a3862 8
      if (fix_objfile_eff(ch, fname)) {
         send_to_char("Object file successfully updated.\r\n", ch);
      } else {
         send_to_char("Sorry, update failed!\r\n", ch);
      }
   } else {
      send_to_char("I got confused :(\r\n", ch);
   }
d3868 4
@


1.291
log
@Don't allow snooping of descriptors that aren't logged in.
This prevents snoopers from seeing passwords.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.290 2008/07/13 17:52:11 jps Exp jps $
d3689 1
a3689 1
      save_objects(tch, SAVE_RENT);
d4080 4
@


1.290
log
@Allow snooping by descriptor number.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.289 2008/06/21 08:53:09 myc Exp jps $
d723 4
d4080 3
@


1.289
log
@Count link-loading as logging in: set the player's last logon time.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.288 2008/06/19 18:53:12 myc Exp myc $
d708 37
d748 3
a750 1
  struct char_data *victim, *tch;
d759 10
a768 1
  else if (!(victim = get_char_vis(ch, arg)))
d773 3
a775 23
    stop_snooping(ch);
  else if (victim->desc->snoop_by)
    send_to_char("Busy already. \r\n", ch);
  else if (victim->desc->snooping == ch->desc)
    send_to_char("Don't be stupid.\r\n", ch);
  else {
    if (victim->desc->original)
      tch = victim->desc->original;
    else
      tch = victim;

    if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
      send_to_char("You can't.\r\n", ch);
      return;
    }
    send_to_char(OK, ch);

    if (ch->desc->snooping)
      ch->desc->snooping->snoop_by = NULL;

    ch->desc->snooping = victim->desc;
    victim->desc->snoop_by = ch->desc;
  }
a3471 1
/* David Endre 1/17/99 For Zzur to control ultimate power! */
d4076 3
@


1.288
log
@Moved the real_zone() declaration to a header file.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.287 2008/06/11 20:12:56 jps Exp myc $
d526 1
d4049 3
@


1.287
log
@Changed zreset so that if there is no argument, the zone you're in
will be reset. Also, it will check whether the argument is actually
composed of digits, and complain if not (except for '*').
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.286 2008/06/09 02:43:18 jps Exp jps $
a3332 2
  extern int real_zone(int number);

d4048 5
@


1.286
log
@Fix setting a person's first ptitle.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.285 2008/06/07 19:06:46 myc Exp jps $
d1758 1
d1760 3
a1762 6
  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("You must specify a zone.\r\n", ch);
    return;
  }
  if (*arg == '*') {
d1771 4
a1774 3
  } else if (*arg == '.')
    i = world[ch->in_room].zone;
  else {
d4050 3
@


1.285
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.284 2008/06/05 02:07:43 myc Exp myc $
d2614 1
a2614 1
        add_perm_title(ch, argument);
d4051 3
@


1.284
log
@Rewrote rent-saving code to use ascii-format files.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.283 2008/05/23 18:47:45 myc Exp myc $
a86 1
int list_spells_in_book(struct obj_data *obj, int spell_array[][MAX_SPELLBOOK_PAGES]);
d4051 3
@


1.283
log
@Set ptitle fix.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.282 2008/05/18 20:16:11 jps Exp myc $
d50 1
d529 2
a530 2
      loadpfile_quest(victim);
      loadpfile_objs(victim);
d3411 1
a3411 1
    Crash_delete_file(GET_NAME(victim));
a3589 1
  extern void Crash_rentsave(struct char_data *ch, int cost);
d3661 1
a3661 1
      Crash_rentsave(tch, 0);
d3663 1
d3696 2
a3697 2
   int i, errs = 0, nread;
   struct obj_file_elem object;
d3703 1
a3703 1
      if (!get_pfilename(player_table[i].name, fname, CRASH_FILE)) {
d3711 1
a3711 1
      if (!(fl = fopen(fname, "r+b"))) {
d3716 1
a3716 1
            errs++;
d3721 2
a3722 2
      /* Skip the rent_info struct at the beginning */
      fseek(fl, sizeof(struct rent_info), SEEK_SET);
d3727 4
d3732 2
a3733 3
         nread = fread(&object, sizeof(object), 1, fl);
         if (ferror(fl)) {
            perror("Reading crash file: Crash_load.");
d3735 1
a3735 1
            errs++;
a3737 1
         if (!nread) break;
d3739 1
a3739 1
         if (object.item_number == vnum) {
d3744 2
d3954 1
a3954 1
      if (!get_pfilename(player_table[i].name, fname, CRASH_FILE)) {
d4027 1
a4027 1
      if (!get_pfilename(arg1, fname, CRASH_FILE)) {
d4052 3
@


1.282
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.281 2008/05/18 05:39:59 jps Exp jps $
d2605 1
a2605 1
    value = 0;
d2607 1
a2607 1
      for (; GET_PERM_TITLES(ch)[value]; ++value);
d4047 3
@


1.281
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.280 2008/05/18 03:24:14 jps Exp jps $
d49 1
a58 1
extern struct attack_hit_type attack_hit_text[];
d4047 3
@


1.280
log
@Added inctime/hour wiz command to advance time 1 hour.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.279 2008/05/17 04:32:25 jps Exp jps $
d435 1
a435 1
        !House_can_enter(ch, world[location].number)) {
d1416 2
a1417 1
    sprintf(buf, "(GC) %s forced room %d to %s", GET_NAME(ch), world[ch->in_room].number, to_force);
d4047 3
@


1.279
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.278 2008/05/14 05:12:06 jps Exp jps $
d96 13
d3601 1
a3601 1
      send_to_char("Are you sure you want do a hotboot?  If so, type 'hotboot yes'.\r\n", ch);
d4046 3
@


1.278
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.277 2008/05/11 05:46:20 jps Exp jps $
d48 1
d3274 2
a3275 9
CREATE(world[rroom].dir_option[rev_dir[dir]], struct room_direction_data,1);
  world[rroom].dir_option[rev_dir[dir]]->general_description = NULL;
  world[rroom].dir_option[rev_dir[dir]]->keyword = NULL;
  world[rroom].dir_option[rev_dir[dir]]->to_room = ch->in_room;

CREATE(world[ch->in_room].dir_option[dir], struct room_direction_data,1);
  world[ch->in_room].dir_option[dir]->general_description = NULL;
  world[ch->in_room].dir_option[dir]->keyword = NULL;
  world[ch->in_room].dir_option[dir]->to_room = rroom;
d4033 3
@


1.277
log
@Using regen.h. alter_hit() now takes the killer.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.276 2008/04/26 23:35:21 myc Exp jps $
d1083 2
a1084 1
   hp_pos_check(vict, NULL, 0); /* Since we didn't call alter_hit, which calls hp_pos_check */
d1117 1
a1117 1
   alter_hit(vict, NULL, change, TRUE);
d4039 3
@


1.276
log
@Fixed output for do_set for classes and races.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.275 2008/04/20 17:49:43 jps Exp myc $
d47 1
d1083 1
a1083 1
   update_pos(vict);
d1116 1
a1116 1
   alter_hit(vict, change, TRUE);
a1118 1
   update_pos(vict);
d4038 3
@


1.275
log
@Removing unneeded externs.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.274 2008/04/19 17:57:55 myc Exp jps $
d2397 1
d2484 1
d4038 3
@


1.274
log
@Moved all the informative commands (stat, show, etc.) into
act.wizinfo.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.273 2008/04/10 02:01:01 jps Exp myc $
a3179 1
  extern void olc_add_to_save_list(int zone, byte type);
a3219 1
extern void olc_add_to_save_list(int zone, byte type);
a3322 1
  extern void olc_add_to_save_list(int zone, byte type);
d4036 4
@


1.273
log
@Added the action to "show damtypes".
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.272 2008/04/05 17:53:24 jps Exp jps $
a91 1
void do_file(struct char_data *ch, char *argument, char *value);
a617 1018
#define ZOCMD zone_table[zrnum].cmd[subcmd]

int find_real_zone_by_room(room_num vznum) {
  int bot, top, mid;
  int low, high;

  bot = 0;
  top = top_of_zone_table;

  /* perform binary search on zone-table */
  for (;;) {
    mid = (bot + top) / 2;

    /* Upper/lower bounds of the zone. */
    low = zone_table[mid].number * 100;
    high = zone_table[mid].top;

    if (low <= vznum && vznum <= high)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if (low > vznum)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}

void list_zone_commands_room(struct char_data *ch, char *buf, room_num rvnum)
{
  int zrnum = find_real_zone_by_room(rvnum);
  int rrnum = real_room(rvnum), cmd_room = NOWHERE;
  int subcmd = 0, count = 0;

  if (zrnum == NOWHERE || rrnum == NOWHERE) {
    strcpy(buf, "No zone information available.\r\n");
    return;
  }

  get_char_cols(ch);

  sprintf(buf, "Zone commands in this room:%s\r\n", yel);
  while (ZOCMD.command != 'S') {
    switch (ZOCMD.command) {
      case 'M':
      case 'O':
      case 'V':
        cmd_room = ZOCMD.arg3;
        break;
      case 'D':
      case 'R':
        cmd_room = ZOCMD.arg1;
        break;
      default:
        break;
    }
    if (cmd_room == rrnum) {
      count++;
      /* start listing */
      switch (ZOCMD.command) {
        case 'M':
          sprintf(buf1, "%sLoad %s [%s%d%s], Max : %d\r\n",
                  ZOCMD.if_flag ? " then " : "",
                  mob_proto[ZOCMD.arg1].player.short_descr, cyn,
                  mob_index[ZOCMD.arg1].virtual, yel, ZOCMD.arg2
                  );
          break;
        case 'G':
          sprintf(buf1, "%sGive it %s [%s%d%s], Max : %d\r\n",
              ZOCMD.if_flag ? " then " : "",
              obj_proto[ZOCMD.arg1].short_description,
              cyn, obj_index[ZOCMD.arg1].virtual, yel,
              ZOCMD.arg2
              );
          break;
        case 'O':
          sprintf(buf1, "%sLoad %s [%s%d%s], Max : %d\r\n",
              ZOCMD.if_flag ? " then " : "",
              obj_proto[ZOCMD.arg1].short_description,
              cyn, obj_index[ZOCMD.arg1].virtual, yel,
              ZOCMD.arg2
              );
          break;
        case 'E':
          sprintf(buf1, "%sEquip with %s [%s%d%s], %s, Max : %d\r\n",
              ZOCMD.if_flag ? " then " : "",
              obj_proto[ZOCMD.arg1].short_description,
              cyn, obj_index[ZOCMD.arg1].virtual, yel,
              equipment_types[ZOCMD.arg3],
              ZOCMD.arg2
              );
          break;
        case 'P':
          sprintf(buf1, "%sPut %s [%s%d%s] in %s [%s%d%s], Max : %d\r\n",
              ZOCMD.if_flag ? " then " : "",
              obj_proto[ZOCMD.arg1].short_description,
              cyn, obj_index[ZOCMD.arg1].virtual, yel,
              obj_proto[ZOCMD.arg3].short_description,
              cyn, obj_index[ZOCMD.arg3].virtual, yel,
              ZOCMD.arg2
              );
          break;
        case 'R':
          sprintf(buf1, "%sRemove %s [%s%d%s] from room.\r\n",
              ZOCMD.if_flag ? " then " : "",
              obj_proto[ZOCMD.arg2].short_description,
              cyn, obj_index[ZOCMD.arg2].virtual, yel
              );
          break;
        case 'D':
          sprintf(buf1, "%sSet door %s as %s.\r\n",
              ZOCMD.if_flag ? " then " : "",
              dirs[ZOCMD.arg2],
              ZOCMD.arg3 ? ((ZOCMD.arg3 == 1) ? "closed" : ((ZOCMD.arg3 == 2) ? "locked" : ((ZOCMD.arg3 == 3) ? "hidden" : ((ZOCMD.arg3 == 4) ? "hidden/closed/locked" : "hidden/closed")))) : "open"
              );
          break;
        default:
          strcpy(buf1, "<Unknown Command>\r\n");
          break;
      }
      sprintf(buf, "%s%s%3d - %s%s", buf, nrm, count, yel, buf1);
    }
    subcmd++;
  }
  strcat(buf, nrm);
  if (!count)
    strcat(buf, "  None.\r\n");

}


void stat_extra_descs(struct extra_descr_data *ed, struct char_data *ch, char *buf, bool showtext)
{
   struct extra_descr_data *desc;
   int count;

   if (!ed) {
      strcpy(buf, "No extra descs.\r\n");
      return;
   }

   if (showtext) {
      strcpy(buf, "");
      for (desc = ed; desc; desc = desc->next)
         sprintf(buf, "%s&4*&0 %s%s%s\r\n%s", buf, CLR(ch, FCYN),
               desc->keyword, CLR(ch, ANRM), desc->description);
   } else {
      count = 0;
      for (desc = ed; desc; desc = desc->next)
         count++;
      sprintf(buf, "Extra desc%s (%d):%s", ed->next ? "s" : "", count, CLR(ch, FCYN));
      for (desc = ed; desc; desc = desc->next) {
         if (desc != ed)
            strcat(buf, ",");
         strcat(buf, " ");
         strcat(buf, desc->keyword);
      }
      strcat(buf, CLR(ch, ANRM));
      strcat(buf, "\r\n");
   }
}

void do_stat_room(struct char_data * ch, int rrnum)
{
  struct room_data *rm = &world[rrnum];
  int i, found = 0;
  struct obj_data *j = 0;
  struct char_data *k = 0;
  struct room_effect_node *reff;

  if (!ch->desc)
    return;

  str_start(buf, sizeof(buf));

  str_catf(buf, "Room name: %s%s%s\r\n",
           CLR(ch, FCYN), rm->name, CLR(ch, ANRM));

  sprinttype(rm->sector_type, sector_types, buf2);
  str_catf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
           rm->zone, CLR(ch, FGRN), rm->number, CLR(ch, ANRM), rrnum, buf2);

  sprintflag(buf2, rm->room_flags, NUM_ROOM_FLAGS, room_bits);
  str_catf(buf, "SpecProc: %s, Flags: %s\r\n",
           (rm->func == NULL) ? "None" : "Exists", buf2);

  sprintflag(buf2, rm->room_effects, NUM_ROOM_EFF_FLAGS, room_effects);
  str_catf(buf, "Room effects: %s\r\n", buf2);

  str_catf(buf, "Ambient Light : %d\r\n", rm->light);

  str_cat(buf, "Description:\r\n");
  str_cat(buf, rm->description ? rm->description : "  None.\r\n");

  stat_extra_descs(rm->ex_description, ch, str_end(buf), FALSE);

  sprintf(buf2, "Chars present:%s", CLR(ch, FYEL));
  for (found = 0, k = rm->people; k; k = k->next_in_room) {
    if (!CAN_SEE(ch, k))
      continue;
    sprintf(buf2, "%s%s %s(%s)", buf2, found++ ? "," : "", GET_NAME(k),
            (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));
    if (strlen(buf2) >= 62) {
      str_catf(buf, "%s%s\r\n", buf2, k->next_in_room ? "," : "");
      *buf2 = found = 0;
    }
  }
  if (*buf2)
    str_catf(buf, "%s\r\n", buf2);
  str_cat(buf, CLR(ch, ANRM));

  if (rm->contents) {
    sprintf(buf2, "Contents:%s", CLR(ch, FGRN));
    for (found = 0, j = rm->contents; j; j = j->next_content) {
      if (!CAN_SEE_OBJ(ch, j))
        continue;
      sprintf(buf2, "%s%s %s", buf2, found++ ? "," : "",
              j->short_description);
      if (strlen(buf2) >= 62) {
        str_catf(buf, "%s%s\r\n", buf2, j->next_content ? "," : "");
        *buf2 = found = 0;
      }
    }

    if (*buf2)
      str_catf(buf, "%s\r\n", buf2);
    str_cat(buf, CLR(ch, ANRM));
  }

  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (rm->dir_option[i]) {
      if (rm->dir_option[i]->to_room == NOWHERE)
        sprintf(buf1, " %sNONE%s", CLR(ch, FCYN), CLR(ch, ANRM));
      else
        sprintf(buf1, "%s%5d%s", CLR(ch, FCYN),
                world[rm->dir_option[i]->to_room].number, CLR(ch, ANRM));
      sprintbit(rm->dir_option[i]->exit_info, exit_bits, buf2);
      str_catf(buf, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n",
               CLR(ch, FCYN), dirs[i], CLR(ch, ANRM), buf1, rm->dir_option[i]->key,
               rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None",
               buf2);
      if (rm->dir_option[i]->general_description)
        str_cat(buf, rm->dir_option[i]->general_description);
    }
  }

  /* Mention spells/effects */
  for (reff = room_effect_list; reff; reff = reff->next) {
     if (reff->room == rrnum) {
        sprinttype(reff->effect, room_effects, buf2);
        str_catf(buf, "SPL: (%3d) &6%-21s&0, sets %s\r\n",
                 reff->timer, skills[reff->spell].name, buf2);
     }
  }

  list_zone_commands_room(ch, str_end(buf), rm->number);

  /* check the room for a script */
  do_sstat_room(ch, str_end(buf), rm);

  page_string(ch->desc, buf, TRUE);
}


void stat_spellbook(struct obj_data *obj, char *buf) {
   int index = 0, spage = 0, fpage = 0;
   int spell_array[2][MAX_SPELLBOOK_PAGES];
   char list_buf[MAX_STRING_LENGTH];

   list_buf[0] = 0;
   for (index = 0; index < obj->spell_book_length; index++) {
      spell_array[0][index] = 0;
      spell_array[1][index] = 0;
   }

   strcpy(buf, "&7&b---Spellbook Contents---&0\r\n");

   /* Get a list of the spells in the book. */
   if (!list_spells_in_book(obj, spell_array)) {
      /* If we can't get a list of the spells in the book,
       * we need to say *exactly* why. */
      if (!obj->spell_book) {
         strcat(buf, "&1&b*&0 Its spell list is NULL.\r\n");
      } else if (!obj->spell_book->spell) {
         strcat(buf, "&1&b*&0 The first spell in its spell list is 0.\r\n");
      } else {
         strcat(buf, "&1&b***&0 Unknown reason why I can't show you the spell list! &1&b***&0\r\n");
      }
      return;
   }

   index = 0;
   while (spell_array[0][index]) {
      spage = fpage + 1;
      fpage = fpage + spell_array[1][index];
      sprintf(list_buf, "%s&6%3d-%3d)&0 &6&b%s&0\r\n",
            list_buf, spage, fpage, skills[spell_array[0][index]].name);
      index++;
   }

   if (((obj->spell_book_length - fpage) > 1)) {
      sprintf(list_buf, "%s&6%3d-%3d)&0 &4&b--Blank--&0\r\n",
      list_buf, fpage + 1, obj->spell_book_length);
   } else if ((obj->spell_book_length - fpage) == 1) {
      sprintf(list_buf, "%s    &6%3d)&0 &4&b--Blank--&0\r\n",
      list_buf, obj->spell_book_length);
   }

   strcat(buf, list_buf);
}

void do_stat_object(struct char_data * ch, struct obj_data * j)
{
  int i, virtual, found;
  struct obj_data *j2;
  struct event *e;

  extern const char *portal_entry_messages[];
  extern const char *portal_character_messages[];
  extern const char *portal_exit_messages[];

  if (!ch->desc)
    return;

  str_start(buf, sizeof(buf));

  virtual = GET_OBJ_VNUM(j);
  str_catf(buf, "Name: '%s%s%s', Aliases: %s, Level: %d\r\n",
           CLR(ch, FYEL), j->short_description ? j->short_description :
           "<None>", CLR(ch, ANRM), j->name, GET_OBJ_LEVEL(j));

  sprinttype(GET_OBJ_TYPE(j), item_types, buf1);
  if (GET_OBJ_RNUM(j) >= 0)
    strcpy(buf2, obj_index[GET_OBJ_RNUM(j)].func ? "Exists" : "None");
  else
    strcpy(buf2, "None");
  str_catf(buf, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s\r\n",
           CLR(ch, FGRN), virtual, CLR(ch, ANRM), GET_OBJ_RNUM(j), buf1, buf2);

  str_catf(buf, "L-Des: %s\r\n", j->description ? j->description :
           "None");

  if (j->action_description)
     str_catf(buf, "Action desc:\r\n%s%s%s\r\n",
              CLR(ch, FYEL), j->action_description, CLR(ch, ANRM));

  sprintbit(j->obj_flags.wear_flags, wear_bits, buf1);
  str_catf(buf, "Can be worn on: %s%s%s\r\n",
           CLR(ch, FCYN), buf1, CLR(ch, ANRM));

  sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf1);
  str_catf(buf, "Extra flags   : %s%s%s\r\n",
           CLR(ch, FGRN), buf1, CLR(ch, ANRM));

  *buf1 = '\0';
  sprintflag(buf1, GET_OBJ_EFF_FLAGS(j), NUM_EFF_FLAGS, effect_flags);
  str_catf(buf, "Spell Effects : %s%s%s\r\n",
           CLR(ch, FYEL), buf1, CLR(ch, ANRM));

  str_catf(buf, "Weight: %d, Value: %d, Cost/day: %d, "
                "Timer: %d, Hiddenness: %ld\r\n",
           GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j),
           GET_OBJ_TIMER(j), GET_OBJ_HIDDENNESS(j));

  if (j->in_room == NOWHERE)
    strcpy(buf1, "Nowhere");
  else
    sprintf(buf1, "%d", world[j->in_room].number);
  str_catf(buf, "In room: %s, In object: %s, Carried by: %s, Worn by: %s\r\n",
           buf1, j->in_obj ? j->in_obj->short_description : "None",
           j->carried_by ? GET_NAME(j->carried_by) : "Nobody",
           j->worn_by ? GET_NAME(j->worn_by) : "Nobody");

  switch (GET_OBJ_TYPE(j)) {
  case ITEM_LIGHT:
    if (GET_OBJ_VAL(j, 2) == -1)
      str_catf(buf, "Hours left: Infinite\r\n");
    else
      str_catf(buf, "Hours left: [%d]  Initial hours: [%d]\r\n",
               GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    str_catf(buf, "Spells: (Level %d) %s, %s, %s\r\n",
             GET_OBJ_VAL(j, 0), skill_name(GET_OBJ_VAL(j, 1)),
             skill_name(GET_OBJ_VAL(j, 2)), skill_name(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    str_catf(buf, "Spell: %s at level %d, %d (of %d) charges remaining\r\n",
             skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
             GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_WEAPON:
    str_catf(buf, "Todam: %dd%d (avg %.1f), Message type: %d, '%s'\r\n",
             GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), WEAPON_AVERAGE(j),
             GET_OBJ_VAL(j, 3),
             GET_OBJ_VAL(j, 3) >= 0 &&
             GET_OBJ_VAL(j, 3) <= TYPE_STAB - TYPE_HIT ?
             attack_hit_text[GET_OBJ_VAL(j, 3)].singular :
             "<&1INVALID&0>");
    break;
  case ITEM_ARMOR:
    str_catf(buf, "AC-apply: [%d]\r\n", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_TRAP:
    str_catf(buf, "Spell: %d, - Hitpoints: %d\r\n",
             GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_CONTAINER:
    if (!IS_CORPSE(j)) {
      sprintbit(GET_OBJ_VAL(j, 1), container_bits, buf2);
      str_catf(buf, "Weight capacity: %d, Lock Type: %s, Key Num: %d, Corpse: %s\r\n",
               GET_OBJ_VAL(j, 0), buf2, GET_OBJ_VAL(j, 2),
               YESNO(GET_OBJ_VAL(j, 3)));
    }
    else {
      str_catf(buf, "Weight capacity: %d, Index: %d, Corpse: %s, Player "
               "Corpse: %s, Raisable: %s\r\n", GET_OBJ_VAL(j,0), GET_OBJ_VAL(j,2),
               YESNO(GET_OBJ_VAL(j,3)), YESNO(IS_PLR_CORPSE(j)),
               YESNO(GET_OBJ_VAL(j, 3) == CORPSE_NPC));
    }
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    sprinttype(GET_OBJ_VAL(j, 2), drinks, buf2);
    str_catf(buf, "Capacity: %d, Contains: %d, Poisoned: %s, Liquid: %s\r\n",
             GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), YESNO(IS_POISONED(j)),
             buf2);
    break;
  case ITEM_NOTE:
    str_catf(buf, "Tongue: %d\r\n", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_KEY:
    break;
  case ITEM_FOOD:
    str_catf(buf, "Makes full: %d, Poisoned: %s\r\n",
             GET_OBJ_VAL(j, 0), YESNO(IS_POISONED(j)));
    break;
  case ITEM_MONEY:
    str_catf(buf, "Coins: %d\r\n", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_PORTAL:
    str_catf(buf, "To room: %d\r\n", GET_OBJ_VAL(j, 0));
    if (GET_OBJ_VAL(j, 1) >= 0) {
      for (i = 0; i < GET_OBJ_VAL(j, 1) &&
           *portal_entry_messages[i] != '\n'; ++i);
      if (*portal_entry_messages[i] != '\n')
        str_catf(buf, "Entry-Room message: %s", portal_entry_messages[i]);
    }
    if (GET_OBJ_VAL(j, 2) >= 0) {
      for (i = 0; i < GET_OBJ_VAL(j, 2) &&
           *portal_character_messages[i] != '\n'; ++i);
      if (*portal_character_messages[i] != '\n')
        str_catf(buf, "To-Char message   : %s", portal_character_messages[i]);
    }
    if (GET_OBJ_VAL(j, 3) >= 0) {
      for (i = 0; i < GET_OBJ_VAL(j, 3) &&
           *portal_exit_messages[i] != '\n'; ++i);
      if (*portal_exit_messages[i] != '\n')
        str_catf(buf, "Exit-Room message : %s", portal_exit_messages[i]);
    }
    break;
  default:
    str_catf(buf, "Values 0-3: [%d] [%d] [%d] [%d]\r\n",
             GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
             GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  }

  /*
   * I deleted the "equipment status" code from here because it seemed
   * more or less useless and just takes up valuable screen space.
   */

  if (j->contains) {
    sprintf(buf1, "\r\nContents:%s", CLR(ch, FGRN));
    for (found = 0, j2 = j->contains; j2; j2 = j2->next_content) {
      sprintf(buf1, "%s%s %s", buf1, found++ ? "," : "",
              j2->short_description);
      if (strlen(buf1) >= 62) {
        str_catf(buf, "%s%s\r\n", buf1, j2->next_content ? "," : "");
        *buf1 = found = 0;
      }
    }

    if (*buf1)
      str_catf(buf, "%s\r\n", buf1);
    str_cat(buf, CLR(ch, ANRM));
  }

  found = 0;
  str_catf(buf, "Applies:");
  for (i = 0; i < MAX_OBJ_EFFECT; i++)
    if (j->effects[i].location) {
      sprinttype(j->effects[i].location, apply_types, buf2);
      str_catf(buf, "%s %s", found++ ? "," : "",
               format_apply(j->effects[i].location, j->effects[i].modifier));
    }
  str_catf(buf, "%s\r\n", found ? "" : " None");

  if (GET_OBJ_TYPE(j) == ITEM_SPELLBOOK)
    stat_spellbook(j, str_end(buf));

  stat_extra_descs(j->ex_description, ch, str_end(buf), FALSE);

  /* Report any events attached. */
  if (j->events) {
    e = j->events;
    str_catf(buf, "Events: %s", eventname(e));
    while (e->next) {
      e = e->next;
      str_catf(buf, " %s", eventname(e));
    }
    str_cat(buf, "\r\n");
  } else {
    str_cat(buf, "No events.\r\n");
  }

  /* check the object for a script */
  do_sstat_object(ch, str_end(buf), j);

  page_string(ch->desc, buf, TRUE);
}


ACMD(do_estat)
{
   struct obj_data *obj;
   char *otarg;
   int tmp, r_num;

   half_chop(argument, buf1, buf2);

   if (!ch->desc)
      return;

   if (subcmd == SCMD_RESTAT || !strcmp(buf1, "room")) {
      if (subcmd == SCMD_RESTAT && *buf1)
         tmp = isdigit(*buf1) ? real_room(atoi(buf1)) : NOWHERE;
      else if (subcmd != SCMD_RESTAT && *buf2)
         tmp = isdigit(*buf2) ? real_room(atoi(buf2)) : NOWHERE;
      else
         tmp = ch->in_room;
      if (tmp == NOWHERE)
         send_to_char("No such room.\r\n", ch);
      else {
         stat_extra_descs(world[tmp].ex_description, ch, buf, TRUE);
         page_string(ch->desc, buf, TRUE);
      }
   } else {
      if (subcmd == SCMD_OESTAT)
         otarg = buf1;
      else if (!strcmp(buf1, "obj"))
         otarg = buf2;
      else
         otarg = buf1;

      if (!*otarg) {
         send_to_char("Usage: estat room [<vnum>]\r\n", ch);
         send_to_char("       estat obj <name>\r\n", ch);
      } else if (isdigit(*otarg)) {
         tmp = atoi(otarg);
         if ((r_num = real_object(tmp)) < 0)
            send_to_char("There is no object with that number.\r\n", ch);
         else {
            stat_extra_descs(obj_proto[r_num].ex_description, ch, buf, TRUE);
            page_string(ch->desc, buf, TRUE);
         }
      } else if ((obj = get_obj_vis(ch, otarg))) {
         stat_extra_descs(obj->ex_description, ch, buf, TRUE);
         page_string(ch->desc, buf, TRUE);
      } else {
         send_to_char("No such object around.\r\n", ch);
      }
   }
}

void do_stat_character(struct char_data * ch, struct char_data * k)
{
  int i, found, a;
  struct group_type *g;
  struct follow_type *fol;
  struct effect *eff;
  struct quest_list *quest;
  struct event *e;

  if (!ch->desc)
    return;

  str_start(buf, sizeof(buf));

  /* Vital character data */
  str_catf(buf, "%s '%s'  IDNum: [%5ld], In room [%5d]\r\n",
           (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
           GET_NAME(k), GET_IDNUM(k),
           k->in_room != NOWHERE ? world[k->in_room].number : 0);

  /* Prototyped mobile specific data. */
  if (IS_MOB(k))
    str_catf(buf, "Alias: %s, VNum: [%5d], RNum: [%5ld]\r\n",
             GET_NAMELIST(k), GET_MOB_VNUM(k), GET_MOB_RNUM(k));

  /* Strings */
  if (IS_NPC(k))
    str_catf(buf, "L-Des: %s",
             (GET_LDESC(k) ? GET_LDESC(k) : "<None>\r\n"));
  else
    str_catf(buf, "Title: %s\r\n",
             (k->player.title ? k->player.title : "<None>"));


  /* Various character stats */
  str_catf(buf, "Race: %s, Race Align: %s, ",
           RACE_PLAINNAME(k), RACE_ALIGN_ABBR(k));
/*
  if (!IS_NPC(k))
    str_catf(buf, "Deity: %s, ", GET_DIETY(ch) >= 0 ?
            Dieties[(int) GET_DIETY(ch)].diety_name : "None");
*/
  sprinttype(GET_SEX(k), genders, buf1);
  str_catf(buf,
           "Size: %c%s, Sex: %s\r\n"
           "Life force: %s%c%s&0, Composition: %s%c%s&0\r\n"
           "Class: %s, Lev: [%s%2d%s], XP: [%s%7ld%s], Align: [%4d]\r\n",
           UPPER(*SIZE_DESC(k)), SIZE_DESC(k) + 1, buf1,
           LIFEFORCE_COLOR(k), UPPER(*LIFEFORCE_NAME(k)), LIFEFORCE_NAME(k) + 1,
           COMPOSITION_COLOR(k), UPPER(*COMPOSITION_NAME(k)), COMPOSITION_NAME(k) + 1,
           CLASS_FULL(k), CLR(ch, FYEL), GET_LEVEL(k),
           CLR(ch, ANRM), CLR(ch, FYEL), GET_EXP(k),
           CLR(ch, ANRM), GET_ALIGNMENT(k));

  /* Player specific data. */
  if (!IS_NPC(k)) {
    strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(k->player.time.birth)));
    strftime(buf2, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(k->player.time.logon)));

    str_catf(buf,
             "Created: [%s], Last Logon: [%s], Played: [%dh %dm]\r\n"
             "Age: [%d], Homeroom: [%d], Speaks: [%d/%d/%d]",
             buf1, buf2, k->player.time.played / 3600,
             ((k->player.time.played / 3600) % 60),
             age(k).year, GET_HOME(k), GET_TALK(k, 0),
             GET_TALK(k, 1), GET_TALK(k, 2));

    if (GET_CLAN(k)) {
      int clan = find_clan_by_id(GET_CLAN(k));
      if (clan >= 0)
        str_catf(buf, ", Clan: [%s], Rank: [%d]",
                 clans[clan].abbreviation, GET_CLAN_RANK(k));
      else
        str_cat(buf, ", Clan: [Invalid]");
    }

    /* Display OLC zones for immorts */
    if (GET_LEVEL(k) >= LVL_IMMORT) {
      struct olc_zone_list *zone;
      *buf1 = '\0';
      for (zone = GET_OLC_ZONES(k); zone; zone = zone->next)
        sprintf(buf1, "%s%d%s", buf1, zone->zone,
                zone->next ? ", " : "");
      str_catf(buf, ", OLC Zones: [%s]", *buf1 ? buf1 : "NONE");
    }

    str_catf(buf, "\r\n");
  }

  /* Attributes, points, and money. */
  str_catf(buf,
           "         STR   INT   WIS   DEX   CON   CHA\r\n"
           "VIEWED   %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n"
           "NATURAL  %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n"
           "AFFECTED %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n",
           CLR(ch, FCYN), GET_VIEWED_STR(k), GET_VIEWED_INT(k),
           GET_VIEWED_WIS(k), GET_VIEWED_DEX(k), GET_VIEWED_CON(k),
           GET_VIEWED_CHA(k), CLR(ch, ANRM),
           CLR(ch, FCYN), GET_NATURAL_STR(k), GET_NATURAL_INT(k),
           GET_NATURAL_WIS(k), GET_NATURAL_DEX(k), GET_NATURAL_CON(k),
           GET_NATURAL_CHA(k), CLR(ch, ANRM),
           CLR(ch, FCYN), GET_AFFECTED_STR(k), GET_AFFECTED_INT(k),
           GET_AFFECTED_WIS(k), GET_AFFECTED_DEX(k), GET_AFFECTED_CON(k),
           GET_AFFECTED_CHA(k), CLR(ch, ANRM));

  str_catf(buf,
           "HP: [%s%d/%d+%d%s]  MP: [%s%d/%d+%d%s]  MV: [%s%d/%d+%d%s]\r\n",
           CLR(ch, FGRN), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CLR(ch, ANRM),
           CLR(ch, FGRN), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CLR(ch, ANRM),
           CLR(ch, FGRN), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CLR(ch, ANRM));

  str_catf(buf, "Coins: [%s%d%sp / %s%d%sg / %s%d%ss / %s%d%sc], "
                 "Bank: [%s%d%sp / %s%d%sg / %s%d%ss / %s%d%sc]\r\n",
           CLR(ch, FCYN), GET_PLAT(k), CLR(ch, ANRM),
           CLR(ch, HYEL), GET_GOLD(k), CLR(ch, ANRM),
           CLR(ch, FWHT), GET_SILVER(k), CLR(ch, ANRM),
           CLR(ch, FYEL), GET_COPPER(k), CLR(ch, ANRM),
           CLR(ch, FCYN), GET_BANK_PLAT(k), CLR(ch, ANRM),
           CLR(ch, HYEL), GET_BANK_GOLD(k), CLR(ch, ANRM),
           CLR(ch, FWHT), GET_BANK_SILVER(k), CLR(ch, ANRM),
           CLR(ch, FYEL), GET_BANK_COPPER(k), CLR(ch, ANRM));

  str_catf(buf, "AC: [%d/10], Hitroll: [%2d], Damroll: [%2d], "
                "Saving throws: [%d/%d/%d/%d/%d]\r\n"
                "Perception: [%4ld], Hiddenness: [%4ld], Rage: [%4d]\r\n",
           GET_AC(k) + 5 * monk_weight_penalty(k),
           GET_HITROLL(k) - monk_weight_penalty(k),
           GET_DAMROLL(k) - monk_weight_penalty(k),
           GET_SAVE(k, 0), GET_SAVE(k, 1), GET_SAVE(k, 2),
           GET_SAVE(k, 3), GET_SAVE(k, 4),
           GET_PERCEPTION(k), GET_HIDDENNESS(k), GET_RAGE(k));

  /* Status data. */
  sprinttype(GET_POS(k), position_types, buf1);
  sprinttype(GET_STANCE(k), stance_types, buf2);
  str_catf(buf, "Pos: %s (%s)", buf1, buf2);
  if (IS_NPC(k)) {
    sprinttype(k->mob_specials.default_pos, position_types, buf1);
    str_catf(buf, ", Default Pos: %s", buf1);
  }
  str_catf(buf, ", Fighting: %s",
          FIGHTING(k) ? GET_NAME(FIGHTING(k)) : "<none>");
  if (k->forward)
    str_catf(buf, ", %s into: %s",
             GET_LEVEL(k) > LVL_IMMORT ? "Switched" : "Shapechanged",
             GET_NAME(k->forward));
  str_cat(buf, "\r\n");

  *buf2 = '\0';
  if (!IS_NPC(k))
    sprintf(buf2, "Idle: [%d tic%s]",
            k->char_specials.timer,
            k->char_specials.timer == 1 ? "" : "s");
  if (k->desc) {
    sprinttype(k->desc->connected, connected_types, buf1);
    sprintf(buf2, "%s%sConnected: %s", buf2, *buf2 ?  ", " : "", buf1);
  }
  if (k->desc && k->desc->original)
    sprintf(buf2, "%s%s%s into by: %s", buf2, *buf2 ? ", " : "",
            GET_LEVEL(k->desc->original) > LVL_IMMORT ? "Switched" : "Shapechanged",
            GET_NAME(k->desc->original));
  if (*buf2)
    str_catf(buf, "%s\r\n", buf2);

  if (IS_MOB(k)) {
    if (k->mob_specials.attack_type >= 0 &&
        k->mob_specials.attack_type <= TYPE_STAB - TYPE_HIT)
      strcpy(buf2, attack_hit_text[k->mob_specials.attack_type].singular);
    else
      strcpy(buf2, "<&1INVALID&0>");
    str_catf(buf,
             "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d, Attack type: %s\r\n",
             (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
             k->mob_specials.damnodice, k->mob_specials.damsizedice,
             buf2);
  }

  /* Character flags. */
  if (IS_NPC(k)) {
    sprintflag(buf1, MOB_FLAGS(k), NUM_MOB_FLAGS, action_bits);
    str_catf(buf, "NPC flags: %s%s%s\r\n",
             CLR(ch, FCYN), buf1, CLR(ch, ANRM));
  }
  else {
    sprintflag(buf2, PLR_FLAGS(k), NUM_PLR_FLAGS, player_bits);
    str_catf(buf, "PLR: %s%s%s\r\n", CLR(ch, FCYN), buf2, CLR(ch, ANRM));
    sprintflag(buf2, PRF_FLAGS(k), NUM_PRF_FLAGS, preference_bits);
    str_catf(buf, "PRF: %s%s%s\r\n", CLR(ch, FGRN), buf2, CLR(ch, ANRM));
  }

  /* Weight and objects. */
  for (i = a = found = 0; i < NUM_WEARS; i++)
    if (GET_EQ(k, i)) {
      ++found;
      a += GET_OBJ_WEIGHT(GET_EQ(k, i));
    }
  str_catf(buf, "Max Carry: %d (%d weight); "
                "Carried: %d (%d weight); "
                "Worn: %d (%d weight)\r\n",
           CAN_CARRY_N(k), CAN_CARRY_W(k),
           IS_CARRYING_N(k), IS_CARRYING_W(k),
           found, a);

  /* Conditions. */
  str_cat(buf, "Hunger: ");
  if (GET_COND(k, FULL) < 0)
    str_cat(buf, "Off");
  else
    str_catf(buf, "%d", GET_COND(k, FULL));
  str_cat(buf, ", Thirst: ");
  if (GET_COND(k, THIRST) < 0)
    str_cat(buf, "Off");
  else
    str_catf(buf, "%d", GET_COND(k, THIRST));
  str_cat(buf, ", Drunk: ");
  if (GET_COND(k, DRUNK) < 0)
    str_cat(buf, "Off\r\n");
  else
    str_catf(buf, "%d\r\n", GET_COND(k, DRUNK));

  /* Group, follower, guard, etc. */
  sprintf(buf1, "Consented: %s, Master is: %s, Followers are:",
          (CONSENT(ch) ? GET_NAME(CONSENT(ch)) : "<none>"),
          (k->master ? GET_NAME(k->master) : "<none>"));

  found = 0;
  for (fol = k->followers; fol; fol = fol->next) {
    if (strlen(buf1) + strlen(PERS(fol->follower, ch)) >= 78) {
      str_catf(buf, "%s%s\r\n", buf1, found ? "," : "");
      *buf1 = found = 0;
    }
    sprintf(buf1, "%s%s %s", buf1, found++ ? "," : "", PERS(fol->follower, ch));
  }
  if (*buf1)
    str_catf(buf, "%s\r\n", buf1);

  /* Group list */
  sprintf(buf1, "&0&2&bGroup Master&0 is: %s, &0&2&bgroupees are:&0",
          ((k->group_master) ? GET_NAME(k->group_master) : "<none>"));

  found = 0;
  for (g = k->groupees; g; g = g->next) {
    if (strlen(buf1) + strlen(PERS(g->groupee, ch)) >= 78) {
      str_catf(buf, "%s%s\r\n", buf1, found ? "," : "");
      *buf1 = found = 0;
    }
    sprintf(buf1, "%s%s %s", buf1, found++ ? "," : "", PERS(g->groupee, ch));
  }
  if (*buf1)
    str_catf(buf, "%s\r\n", buf1);

  if (k->guarding || k->guarded_by)
    str_catf(buf, "Guarding: %s, Guarded by: %s\r\n",
            k->guarding ? GET_NAME(k->guarding) : "<none>",
            k->guarded_by ? GET_NAME(k->guarded_by) :"<none>");
  if (k->cornering || k->cornered_by)
    str_catf(buf, "Cornering: %s, Cornered by: %s",
            k->cornering ? GET_NAME(k->cornering) : "<none>",
            k->cornered_by ? GET_NAME(k->cornered_by) :"<none>");

  /* Effect bitvectors */
  sprintflag(buf1, EFF_FLAGS(k), NUM_EFF_FLAGS, effect_flags);
  str_catf(buf, "EFF: %s%s%s\r\n", CLR(ch, FYEL), buf1, CLR(ch, ANRM));

  /* NPC spell circle status */
  if (IS_NPC(k)) {
    str_cat(buf, "Spells MEMMED: ");
    /* Magic number! structs.h specifically gives mobs 12 circles. */
    for (i = 1; i <= 12; ++i)
      str_catf(buf, "%d/%d%s", GET_MEM_MEMED(k, i),
               spells_of_circle[(int) GET_LEVEL(k)][i],
               i == 12 ? "\r\n" : " ");
  }


  /* List spells the character is affected by. */
  for (eff = k->effects; eff; eff = eff->next) {
    if (eff->duration <  0)
      str_catf(buf, "SPL: (perma) %s%-21s%s ",
               CLR(ch, FCYN), skills[eff->type].name, CLR(ch, ANRM));
    else
      str_catf(buf, "SPL: (%3dhr) %s%-21s%s ", eff->duration + 1,
               CLR(ch, FCYN), skills[eff->type].name, CLR(ch, ANRM));
    if (eff->modifier)
      str_catf(buf, "%+d to %s", eff->modifier,
               apply_types[(int) eff->location]);
    if (HAS_FLAGS(eff->flags, NUM_EFF_FLAGS)) {
      sprintflag(buf1, eff->flags, NUM_EFF_FLAGS, effect_flags);
      str_catf(buf, "%ssets %s", eff->modifier ? ", " : "", buf1);
    }
    str_cat(buf, "\r\n");
  }

  /* Run through the quests the player is on*/
  if (k->quests) {
    if (all_quests) {
      quest = k->quests;
      while (quest) {
        if ((a = real_quest(quest->quest_id)) >= 0) {
          str_catf(buf, "Quest %s: ", all_quests[a].quest_name);
          if (quest->stage == QUEST_SUCCESS)
            str_cat(buf, "Completed\r\n");
          else if (quest->stage == QUEST_FAILURE)
            str_cat(buf, "Failed\r\n");
          else
            str_catf(buf, "Stage %d\r\n", quest->stage);
        }
        quest = quest->next;
      }
    }
    else
      log("SYSERR: do_stat_character: k->quests non-null but no quests exist (all_quests == NULL)");
  }

  /* Report any events attached. */
  if (k->events) {
    e = k->events;
    str_catf(buf, "Events: %s", eventname(e));
    while (e->next) {
      e = e->next;
      str_catf(buf, " %s", eventname(e));
    }
    str_cat(buf, "\r\n");
  } else {
    str_cat(buf, "No events.\r\n");
  }

  /* List cooldowns */
  for (i = found = 0; i < MAX_COOLDOWNS; ++i) {
    if (!GET_COOLDOWN(k, i))
      continue;
    if (!found)
      str_cat(buf, "Cooldowns:\r\n");
    str_catf(buf, "%25s: %d sec\r\n", cooldowns[i], GET_COOLDOWN(k, i) / PASSES_PER_SEC);
    found = TRUE;
  }

  /* Check mobiles for a script */
  if (IS_NPC(k))
    do_sstat_character(ch, str_end(buf), k);

  /* List permanent player titles */
  if (!IS_NPC(k) && GET_PERM_TITLES(k)) {
    str_cat(buf, "Permanent Titles:\r\n");
    for (i = 0; GET_PERM_TITLES(k)[i]; ++i)
      str_catf(buf, "  %d) %s\r\n", i + 1, GET_PERM_TITLES(k)[i]);
  }

  page_string(ch->desc, buf, TRUE);
}

ACMD(do_stat)
{
  void do_stat_shop(struct char_data *ch, char *arg);
  struct char_data *victim = 0;
  struct obj_data *object = 0;
  int tmp;

  half_chop(argument, buf1, buf2);

  if (subcmd == SCMD_RSTAT || is_abbrev(buf1, "room")) {
    if (subcmd == SCMD_RSTAT && *buf1)
      tmp = isdigit(*buf1) ? real_room(atoi(buf1)) : NOWHERE;
    else if (subcmd != SCMD_RSTAT && *buf2)
      tmp = isdigit(*buf2) ? real_room(atoi(buf2)) : NOWHERE;
    else
      tmp = ch->in_room;
    if (tmp == NOWHERE)
      send_to_char("No such room.\r\n", ch);
    else
      do_stat_room(ch, tmp);
  } else if (subcmd == SCMD_SSTAT || is_abbrev(buf1, "shop")) {
     if (subcmd == SCMD_SSTAT)
        do_stat_shop(ch, buf1);
     else
        do_stat_shop(ch, buf2);
  } else if (!*buf1) {
    send_to_char("Stats on who or what?\r\n", ch);
  } else if (is_abbrev(buf1, "mob")) {
    if (!*buf2)
      send_to_char("Stats on which mobile?\r\n", ch);
    else {
      if ((victim = get_char_vis(ch, buf2)))
        do_stat_character(ch, victim);
      else
        send_to_char("No such mobile around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "player")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      if ((victim = get_player_vis(ch, buf2, 0)))
        do_stat_character(ch, victim);
      else
        send_to_char("No such player around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "file")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      if (load_player(buf2, victim) > -1) {
        if (GET_LEVEL(victim) > GET_LEVEL(ch))
          send_to_char("Sorry, you can't do that.\r\n", ch);
        else
          do_stat_character(ch, victim);
        free_char(victim);
      } else {
        send_to_char("There is no such player.\r\n", ch);
        free(victim);
      }
    }
  } else if (is_abbrev(buf1, "object")) {
    if (!*buf2)
      send_to_char("Stats on which object?\r\n", ch);
    else {
      if ((object = get_obj_vis(ch, buf2)))
        do_stat_object(ch, object);
      else
        send_to_char("No such object around.\r\n", ch);
    }
  } else {
    if ((object = get_object_in_equip_vis(ch, buf1, ch->equipment, &tmp)))
      do_stat_object(ch, object);
    else if ((object = get_obj_in_list_vis(ch, buf1, ch->carrying)))
      do_stat_object(ch, object);
    else if ((victim = get_char_room_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_in_list_vis(ch, buf1, world[ch->in_room].contents)))
      do_stat_object(ch, object);
    else if ((victim = get_char_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_vis(ch, buf1)))
      do_stat_object(ch, object);
    else
      send_to_char("Nothing around by that name.\r\n", ch);
  }
}

a900 151

ACMD(do_vstat)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (subcmd == SCMD_VSTAT && (!*buf || !*buf2 || !isdigit(*buf2))) {
    send_to_char("Usage: vstat { obj | mob } <number>\r\n", ch);
  } else if (subcmd == SCMD_MSTAT && (!*buf || !isdigit(*buf))) {
    send_to_char("Usage: mstat <number>\r\n", ch);
  } else if (subcmd == SCMD_OSTAT && (!*buf || !isdigit(*buf))) {
    send_to_char("Usage: ostat <number>\r\n", ch);
  } else if ((number = (subcmd == SCMD_VSTAT ? atoi(buf2) : atoi(buf))) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
  } else if (subcmd == SCMD_MSTAT ||
             (subcmd == SCMD_VSTAT && is_abbrev(buf, "mob"))) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, 0);
    do_stat_character(ch, mob);
    extract_char(mob);
  } else if (subcmd == SCMD_OSTAT ||
             (subcmd == SCMD_VSTAT && is_abbrev(buf, "obj"))) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    do_stat_object(ch, obj);
    extract_obj(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}

ACMD(do_zstat)
{
   int vnum, rnum;
   char str[MAX_INPUT_LENGTH];
   struct zone_data *z;

   half_chop(argument, str, argument);

   if (!*str)
      vnum = zone_table[IN_ZONE(ch)].number;
   else
      vnum = atoi(str);

   rnum = find_zone(vnum);
   if (rnum == -1) {
      send_to_char("There is no such zone.\r\n", ch);
      return;
   }

   z = &(zone_table[rnum]);
   sprintf(buf,
         "Zone &6%d&0: &2%s&0\r\n"
         "Vnum range     : &3%d-%d&0\r\n"
         "Reset mode     : &3%s&0\r\n"
         "Lifespan       : &3%d minutes&0\r\n"
         "Zone factor%%   : &3%d&0\r\n"
         "Hemisphere     : &3%s&0\r\n"
         "Climate        : &3%s&0\r\n"
         "Temperature    : &6%d degrees&0\r\n"
         "Precipitation  : &6%d&0\r\n"
         "Wind speed     : &6%s&0 (&6%d&0)\r\n"
         "Wind direction : &6%s&0\r\n",
         vnum, z->name,
         vnum * 100, z->top,
         z->reset_mode ?
            ((z->reset_mode == 1) ?
               "Reset when no players are in zone" :
               "Normal reset") : "Never reset",
         z->lifespan,
         z->zone_factor,

         z->hemisphere >= 0 && z->hemisphere < NUM_HEMISPHERES ?
            hemispheres[z->hemisphere].name : "<INVALID>",

         z->climate >= 0 && z->climate < NUM_CLIMATES ?
            climates[z->climate].name : "<INVALID>",
         z->temperature,
         z->precipitation,
         z->wind_speed == WIND_NONE ? "none" : wind_speeds[z->wind_speed],
         z->wind_speed,

         z->wind_dir == NORTH ? "North" :
            z->wind_dir == SOUTH ? "South" :
            z->wind_dir == EAST ? "East" :
            z->wind_dir == WEST ? "West" : "<INVALID>"
         );
   send_to_char(buf, ch);
}

ACMD(do_players)
{
  int i, count = 0, buflen = 0;
  const char *color;
  long bitfield = 0;

  any_one_arg(argument, arg);

    /* show usage */
  if (strlen(arg) != 1 || !isalpha(*arg)) {
    send_to_char("'players <letter>' shows all player names beginning with <letter>\r\n", ch);
    return;
  }

  *arg = tolower(*arg);

  /* Go through all the names in the pfile */
  for (i = 0; i <= top_of_p_table; i++) {
    /* Check if the first letter matches the argument */
    if (tolower(*player_table[i].name) == *arg) {
      ++count;

      if (buflen > sizeof(buf) - 100) {
        buflen += sprintf(buf + buflen, "\r\nToo many players!  Buffer full.");
        break;
      }

      bitfield = player_table[i].flags;

      if (IS_SET(bitfield, PINDEX_FROZEN))
        color = FCYN;
      else if (IS_SET(bitfield, PINDEX_NEWNAME))
        color = FRED;
      else if (IS_SET(bitfield, PINDEX_NAPPROVE))
        color = FYEL;
      else
        color = FGRN;
      buflen += sprintf(buf + buflen, "  %s&b%-15.20s(%3d) &0%s",
                        color, player_table[i].name,
                        player_table[i].level, count % 3 ? "" : "\r\n");
    }
  }

  if (count == 0)
    strcpy(buf, "No players for that letter.\r\n");
  else if (count % 3)
    strcpy(buf + buflen, "\r\n");

  /* Show the name list */
  page_string(ch->desc, buf, TRUE);
}

a1374 34

ACMD(do_last)
{
   struct char_data *victim;

   one_argument(argument, arg);
   if (!*arg) {
      send_to_char("For whom do you wish to search?\r\n", ch);
      return;
   }

   CREATE(victim, struct char_data, 1);
   clear_char(victim);

   if (load_player(arg, victim) < 0) {
      send_to_char("There is no such player.\r\n", ch);
      free(victim);
      return;
   }
   if (GET_LEVEL(victim) > GET_LEVEL(ch) && GET_LEVEL(ch) < LVL_HEAD_B) {
      send_to_char("You are not sufficiently godly for that!\r\n", ch);
      free_char(victim);
      return;
   }
   sprintf(buf, "[%5ld] [%2d %s] %-12s : %-18s : %-20s\r\n",
      GET_IDNUM(victim), GET_LEVEL(victim),
      CLASS_ABBR(victim), GET_NAME(victim),
      GET_HOST(victim), ctime(&victim->player.time.logon));
   send_to_char(buf, ch);

   free_char(victim);
}


a1964 461
/* single zone printing fn used by "show zone" so it's not repeated in the
   code 3 times ... -je, 4/6/93 */

int print_zone_to_buf(char *bufptr, int zone)
{
  return sprintf(bufptr,
          "%s%3d %-30.30s Age: %3d; Reset: %3d (%1d); ZF:%d: Top: %5d\r\n",
          bufptr, zone_table[zone].number, zone_table[zone].name,
          zone_table[zone].age, zone_table[zone].lifespan,
          zone_table[zone].reset_mode, zone_table[zone].zone_factor,
          zone_table[zone].top);
}

#define SHOW_TYPE_UNDEFINED     -1
#define SHOW_TYPE_ZONES          0
#define SHOW_TYPE_PLAYER         1
#define SHOW_TYPE_RENT           2
#define SHOW_TYPE_STATS          3
#define SHOW_TYPE_ERRORS         4
#define SHOW_TYPE_DEATH          5
#define SHOW_TYPE_GODROOMS       6
#define SHOW_TYPE_SHOPS          7
#define SHOW_TYPE_HOUSES         8
#define SHOW_TYPE_FILE           9
#define SHOW_TYPE_NOTES         10
#define SHOW_TYPE_CLASSES       11
#define SHOW_TYPE_RACES         12
#define SHOW_TYPE_EXP           13
#define SHOW_TYPE_SNOOP         14
#define SHOW_TYPE_SIZES         15
#define SHOW_TYPE_LIFEFORCES    16
#define SHOW_TYPE_COMPOSITIONS  17
#define SHOW_TYPE_DAMTYPES      18

ACMD(do_show)
{
   int i, j, k, l, con, rn, rrn;
   struct char_data *vict;
   struct obj_data *obj;
   char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH];
   char zonebuf[50000], value2[MAX_INPUT_LENGTH], value3[MAX_INPUT_LENGTH];
   struct descriptor_data *d;
   extern int buf_switches, buf_largecount, buf_overflows;
   void show_shops(struct char_data * ch, char *value);
   void hcontrol_list_houses(struct char_data *ch);

   struct show_struct {
      char *cmd;
      char level;
      int showtype;
   } fields[] = {
      { "nothing",  0,             SHOW_TYPE_UNDEFINED  },
      /* Keep this list alphabetized */
      { "compositions", LVL_IMMORT, SHOW_TYPE_COMPOSITIONS },
      { "classes",  LVL_IMMORT,    SHOW_TYPE_CLASSES },
      { "damtypes", LVL_IMMORT,    SHOW_TYPE_DAMTYPES },
      { "death",    LVL_GOD,       SHOW_TYPE_DEATH },
      { "errors",   LVL_GRGOD,     SHOW_TYPE_ERRORS },
      { "exp",      LVL_IMMORT,    SHOW_TYPE_EXP },
      { "file",     LVL_GRGOD,     SHOW_TYPE_FILE },
      { "godrooms", LVL_GOD,       SHOW_TYPE_GODROOMS },
      { "houses",   LVL_GOD,       SHOW_TYPE_HOUSES },
      { "lifeforces", LVL_IMMORT,  SHOW_TYPE_LIFEFORCES },
      { "notes",    LVL_IMMORT,    SHOW_TYPE_NOTES },
      { "player",   LVL_GOD,       SHOW_TYPE_PLAYER },
      { "races",    LVL_IMMORT,    SHOW_TYPE_RACES },
      { "rent",     LVL_GOD,       SHOW_TYPE_RENT },
      { "shops",    LVL_GOD,       SHOW_TYPE_SHOPS },
      { "sizes",    LVL_IMMORT,    SHOW_TYPE_SIZES },
      { "snoop",    LVL_GOD,       SHOW_TYPE_SNOOP },
      { "stats",    LVL_IMMORT,    SHOW_TYPE_STATS },
      { "zones",    LVL_IMMORT,    SHOW_TYPE_ZONES },
      { "\n", 0, SHOW_TYPE_UNDEFINED }
   };

   *zonebuf = '\0';

   skip_spaces(&argument);

   if (!*argument) {
      strcpy(buf, "Show options:\r\n");
      for (j = 0, i = 1; fields[i].level; i++)
         if (fields[i].level <= GET_LEVEL(ch))
            sprintf(buf, "%s%-15s%s", buf, fields[i].cmd, (!(++j % 5) ? "\r\n" : ""));
      if (j % 5)
         strcat(buf, "\r\n");
      send_to_char(buf, ch);
      return;
   }

   half_chop(argument, field, value2);
   strcpy(arg, two_arguments(value2, value, value3));

   for (l = 0; *(fields[l].cmd) != '\n'; l++)
      if (!strncmp(field, fields[l].cmd, strlen(field)))
         break;

   if (GET_LEVEL(ch) < fields[l].level) {
      send_to_char("You are not godly enough for that!\r\n", ch);
      return;
   }

   buf[0] = '\0';

   switch (fields[l].showtype) {

      case SHOW_TYPE_COMPOSITIONS:
         sprintf(buf,
               "Idx  Composition  %sSlash&0  %sPierce&0  %sCrush&0  %sShock&0  %sFire&0  %sWater&0  %sCold&0  %sAcid&0  %sPoison&0  %sMagic&0\r\n",
               damtypes[DAM_SLASH].color,
               damtypes[DAM_PIERCE].color,
               damtypes[DAM_CRUSH].color,
               damtypes[DAM_SHOCK].color,
               damtypes[DAM_FIRE].color,
               damtypes[DAM_WATER].color,
               damtypes[DAM_COLD].color,
               damtypes[DAM_ACID].color,
               damtypes[DAM_POISON].color,
               damtypes[DAM_MAGIC].color
               );
         send_to_char(buf, ch);
         send_to_char("---  -----------  -----  ------  -----  -----   ---  ----  -----  ----  ------  -----\r\n", ch);
         for (i = 0; i < NUM_COMPOSITIONS; i++) {
            sprintf(buf,
                  "%2d.  %s%c%-10s  % 5d  % 6d  % 5d  % 5d  % 4d  % 4d  % 5d  % 4d  % 6d  % 5d&0\r\n",
                  i, compositions[i].color,
                  UPPER(*(compositions[i].name)), compositions[i].name + 1,
                  compositions[i].sus_slash,
                  compositions[i].sus_pierce,
                  compositions[i].sus_crush,
                  compositions[i].sus_shock,
                  compositions[i].sus_fire,
                  compositions[i].sus_water,
                  compositions[i].sus_cold,
                  compositions[i].sus_acid,
                  compositions[i].sus_poison,
                  compositions[i].sus_magic
                  );
            send_to_char(buf, ch);
         }
         break;

      case SHOW_TYPE_LIFEFORCES:
         sprintf(buf, "Idx  Life force   %sHeal&0  %sDisc.&0  %sDispel&0  %sMental&0\r\n",
               damtypes[DAM_HEAL].color,
               damtypes[DAM_DISCORPORATE].color,
               damtypes[DAM_DISPEL].color,
               damtypes[DAM_MENTAL].color);
         send_to_char(buf, ch);
         send_to_char("---  -----------  ----  -----  ------  ------\r\n", ch);
         for (i = 0; i < NUM_LIFEFORCES; i++) {
            sprintf(buf,
                  "%2d.  %s%c%-10s  % 4d  % 5d  % 6d  % 6d&0\r\n",
                  i, lifeforces[i].color,
                  UPPER(*(lifeforces[i].name)), lifeforces[i].name + 1,
                  lifeforces[i].sus_heal,
                  lifeforces[i].sus_discorporate,
                  lifeforces[i].sus_dispel,
                  lifeforces[i].sus_mental
                  );
            send_to_char(buf, ch);
         }
         break;

      case SHOW_TYPE_DAMTYPES:
         send_to_char("Idx  Damage type      Verb 1st         Verb 2nd          Action\r\n", ch);
         send_to_char("---  -------------    -------------    --------------    ----------\r\n", ch);
         for (i = 0; i < NUM_DAMTYPES; i++) {
            sprintf(buf,
                      "%2d.  %s%-15s  %-15s  %-15s   %-15s&0\r\n",
                      i, damtypes[i].color, damtypes[i].name,
                      damtypes[i].verb1st, damtypes[i].verb2nd,
                      damtypes[i].action);
            send_to_char(buf, ch);
         }
         break;
      case SHOW_TYPE_ZONES:
         if (!strcmp(value, ".")) {
            print_zone_to_buf(buf, world[ch->in_room].zone);
            send_to_char(buf, ch);
         } else if (*value && is_number(value)) {
            if ((i = find_zone(atoi(value))) == NOWHERE)
               send_to_char("That is not a valid zone.\r\n", ch);
            else {
               print_zone_to_buf(buf, i);
               send_to_char(buf, ch);
            }
         } else {
            for (i = 0; i <= top_of_zone_table; i++)
               print_zone_to_buf(zonebuf, i);
            page_string(ch->desc, zonebuf, 1);
         }
         break;

      case SHOW_TYPE_PLAYER:
         if (!*value) {
            send_to_char("A name would help.\r\n", ch);
            return;
         }

         CREATE(vict, struct char_data, 1);
         clear_char(vict);

         if (load_player(value, vict) < 0) {
            send_to_char("There is no such player.\r\n", ch);
            free(vict);
            return;
         }
         strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vict->player.time.birth)));
         strftime(buf2, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vict->player.time.logon)));
         sprintf(buf, "Player: %-12s (%s) [%2d %s] (%s)\r\n"
                            "Coins held:    [%7dp / %7dg / %7ds / %7dc]\r\n"
                            "Coins banked: [%7dp / %7dg / %7ds / %7dc]\r\n"
                            "Exp: %-8ld   Align: %-5d\r\n"
                            "Started: %s   Last: %s   Played: %3dh %2dm\r\n",
                     GET_NAME(vict), genders[(int) GET_SEX(vict)],
                     GET_LEVEL(vict), CLASS_ABBR(vict), RACE_ABBR(vict),
                     GET_PLAT(vict), GET_GOLD(vict), GET_SILVER(vict), GET_COPPER(vict),
                     GET_BANK_PLAT(vict), GET_BANK_GOLD(vict),
                     GET_BANK_SILVER(vict), GET_BANK_COPPER(vict),
                     GET_EXP(vict), GET_ALIGNMENT(vict),
            buf1, buf2, (int) (vict->player.time.played / 3600),
            (int) (vict->player.time.played / 60 % 60));
         send_to_char(buf, ch);
         free_char(vict);
         break;

      case SHOW_TYPE_RENT:
         if (*value)
            Crash_listrent(ch, value);
         else
            send_to_char("Show rent for whom?\r\n", ch);
         break;

      case SHOW_TYPE_STATS:
         i = j = k = con = 0;
         for (vict = character_list; vict; vict = vict->next) {
            if (IS_NPC(vict))
               j++;
            else if (CAN_SEE(ch, vict)) {
               i++;
               if (vict->desc)
                  con++;
            }
         }
         for (obj = object_list; obj; obj = obj->next)
            k++;
         sprintf(buf, "Current stats:\r\n"
                            "   %5d players in game   %5d connected\r\n"
                            "   %5d registered\r\n"
                            "   %5d mobiles               %5d prototypes\r\n"
                            "   %5d objects               %5d prototypes\r\n"
                            "   %5d rooms                  %5d zones\r\n"
                            "   %5d large bufs\r\n"
                            "   %5d buf switches       %5d overflows\r\n",
                     i, con,
                     top_of_p_table + 1,
            j, top_of_mobt + 1,
            k, top_of_objt + 1,
            top_of_world + 1, top_of_zone_table + 1,
                     buf_largecount,
            buf_switches, buf_overflows);
         send_to_char(buf, ch);
         break;

      case SHOW_TYPE_ERRORS:
         strcpy(buf, "Errant Rooms\r\n------------\r\n");
         for (i = 0; i <= top_of_zone_table; i++) {
            if (!zone_table[i].top)
               continue;
            for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
               if ((rrn = real_room(rn)) == NOWHERE)
                  continue;
               value3[0] = '\0';
               for (j = 0; j < NUM_OF_DIRS; j++) {
                  if (world[rrn].dir_option[j]) {
                     if (j == FDOWN || j == FUP)
                        sprintf(value3, "%s%s exit, ", value3, dirs[j]);
                     if (world[rrn].dir_option[j]->to_room == 0)
                        sprintf(value3, "%s%s to void, ", value3, dirs[j]);
                     if (world[rrn].dir_option[j]->to_room == NOWHERE &&
                           !world[rrn].dir_option[j]->general_description)
                        sprintf(value3, "%s%s to NOWHERE, ", value3, dirs[j]);
                  }
               }
               if (value3[0]) {
                  value3[strlen(value3) - 2] = '\0'; /* cut off last comma */
                  sprintf(buf, "%s [%5d] %-30s %s\r\n",
                        buf, world[rrn].number, world[rrn].name, value3);
               }
            }
         }
         send_to_char(buf, ch);
         break;

      case SHOW_TYPE_DEATH:
         strcpy(buf, "Death Traps\r\n-----------\r\n");
         for (i = 0, j = 0; i <= top_of_zone_table; i++) {
            if (!zone_table[i].top)
               continue;
            for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
               if ((rrn=real_room(rn)) == NOWHERE)
                  continue;
               if (ROOM_FLAGGED(rrn, ROOM_DEATH))
                  sprintf(buf, "%s%2d: [%5d] %s\r\n",
                              buf, j++, world[rrn].number, world[rrn].name);
            }
         }
         send_to_char(buf, ch);
         break;

      case SHOW_TYPE_GODROOMS:
         strcpy(buf, "Godrooms\r\n--------------------------\r\n");
         for (i = 0, j = 0; i <= top_of_zone_table; i++) {
            if (!zone_table[i].top)
               continue;
            for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
               if ((rrn=real_room(rn)) == NOWHERE)
                  continue;
               if (ROOM_FLAGGED(rrn, ROOM_GODROOM))
                  sprintf(buf, "%s%2d: [%5d] %s\r\n",
                              buf, j++, world[rrn].number, world[rrn].name);
            }
         }
         send_to_char(buf, ch);
         break;

      case SHOW_TYPE_SHOPS:
         show_shops(ch, value);
         break;

      case SHOW_TYPE_HOUSES:
         hcontrol_list_houses(ch);
         break;

      case SHOW_TYPE_FILE:
         do_file(ch, value, value3);
         break;

      case SHOW_TYPE_NOTES:
         if (!*value) {
            send_to_char("A name would help.\r\n", ch);
            return;
         }
         if (!get_pfilename(value, value2, NOTES_FILE)) {
            send_to_char("Couldn't find that player.\r\n", ch);
            return;
         }
         {
            FILE* i = fopen(value2, "rt");
            if (i == NULL) {
               send_to_char("There are no notes for that file.\r\n", ch);
               return;
            }
            zonebuf[0] = '\0';
            while(get_line(i, value3)) {
               strcat(zonebuf, value3);
               strcat(zonebuf, "\r\n");
               if (strlen(zonebuf) > 49500) {
                  strcat(zonebuf, "Max note length exceeded.\r\n");
                  break;
               }
            }
            fclose(i);
            page_string(ch->desc, zonebuf, 1);
         }
         break;

      case SHOW_TYPE_CLASSES:
         sprintf(buf, "Fiery Classes:\r\n-_-_-_-_-_-_-\r\n");
         strcpy(buf, "Class          Magic  Homeroom  Base Class  Max Subclass Level\r\n"
                     "-------------  -----  --------  ----------  ------------------\r\n");
         for (i = 0; i < NUM_CLASSES; i++) {
            char *mem_mode;
            j = count_color_chars(classes[i].displayname);
            if (classes[i].mem_mode == MEMORIZE)
              mem_mode = "mem";
            else if (classes[i].mem_mode == PRAY)
              mem_mode = "pray";
            else
              mem_mode = "none";
            if (classes[i].max_subclass_level > 0)
              sprintf(value, "%-2d", classes[i].max_subclass_level);
            else
              strcpy(value, "  ");
            sprintf(buf, "%s %-*.*s  %-5s  %-8d  %-10.10s  %s\r\n", buf,
                    13 + j, 13 + j, classes[i].displayname,
                    mem_mode, classes[i].homeroom,
                    classes[i].subclass_of == CLASS_UNDEFINED ? "" :
                    classes[classes[i].subclass_of].plainname,
                    value);
         }
         page_string(ch->desc, buf, 1);
         break;

      case SHOW_TYPE_RACES:
         strcpy(buf, "Race              Humanoid  Align    Size      HR/DR\r\n"
                     "----------------  --------  -------  --------  ------\r\n");
         for (i = 0; i < NUM_RACES; i++) {
            j = count_color_chars(races[i].fullname);
            sprintf(buf, "%s %-*.*s   %-8s  %5d    %-8.8s  %d/%d\r\n", buf,
                    15 + j, 15 + j, races[i].fullname,
                    YESNO(races[i].humanoid), races[i].def_align,
                    sizes[races[i].def_size].name,
                    races[i].bonus_hitroll, races[i].bonus_damroll);
         }
         page_string(ch->desc,buf,1);
         break;

      case SHOW_TYPE_EXP:
         if (!*value)
            send_to_char("Usage: show exp <class>\r\n", ch);
         else {
            for (l = 0; l < NUM_CLASSES; l++) {
               if (is_abbrev(value, classes[l].name)) {
                  sprintf(buf, "      Level          Experience Needed            Total\r\n");
                  strcat(buf,   " ---------         -----------------         ---------\r\n");
                  for (i = 1; i <= LVL_MAX_MORT; ++i)
                     sprintf(buf, "%s %3d - %3d                     %9ld         %9ld\r\n",
                                 buf, i, i + 1, exp_to_level(i, l) -
                                 exp_to_level(i - 1, l), exp_to_level(i, l));
                  page_string(ch->desc, buf, 1);
                  return;
               }
            }
            send_to_char("Invalid class.\r\n", ch);
         }
         break;

      case SHOW_TYPE_SNOOP:
         i = 0;
         send_to_char("People currently snooping:\r\n"
                            "--------------------------\r\n", ch);
         for (d = descriptor_list; d; d = d->next) {
            if (d->snooping == NULL || d->character == NULL)
               continue;
            if (STATE(d) != CON_PLAYING || GET_LEVEL(ch) < GET_LEVEL(d->character))
               continue;
            if (!CAN_SEE(ch, d->character) || IN_ROOM(d->character) == NOWHERE)
               continue;
            i++;
            sprintf(buf, "%-10s%s - snooped by %s%s.\r\n",
                        GET_NAME(d->snooping->character), QNRM,
                        GET_NAME(d->character), QNRM);
            send_to_char(buf, ch);
         }
         if (i == 0)
            send_to_char("No one is currently snooping.\r\n", ch);
         break;

      case SHOW_TYPE_SIZES:
         show_sizes(ch);
         break;

      default:
         send_to_char("That's not something you can show.\r\n", ch);
         break;
   }
}


a2727 75
void reboot_info(struct char_data *ch)
{
   int h, m, s;

   extern int num_hotboots;

   h = (reboot_pulse - global_pulse) / (3600 * PASSES_PER_SEC);
   m = ((reboot_pulse - global_pulse) % (3600 * PASSES_PER_SEC)) / (60 * PASSES_PER_SEC);
   s = ((reboot_pulse - global_pulse) % (60 * PASSES_PER_SEC)) / PASSES_PER_SEC;
   if (reboot_auto) {
      sprintf(buf, "Reboot in %02d:%02d:%02d.\r\n", h, m, s);
   } else {
      sprintf(buf, "Automatic rebooting is &1off&0; would reboot in %02d:%02d:%02d.\r\n",
            h, m, s);
   }
   send_to_char(buf, ch);

   if (num_hotboots > 0) {
      sprintf(buf, "%d hotboot%s since last shutdown.\r\n",
              num_hotboots, num_hotboots == 1 ? "" : "s");
      send_to_char(buf, ch);
   }
}

ACMD(do_world)
{
  char *tmstr;
  time_t mytime;
  time_t theytime;
  int d, h, m;
  extern time_t boot_time;
  extern int make_count;
  char bcbuf[100] = "0";
  struct stat statbuf;
  char wldinfo[100] = "0";

  mytime=time(0);

  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  sprintf(buf, "Current machine time: %s", tmstr);


  theytime=boot_time;

  tmstr = (char *) asctime(localtime(&theytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  theytime = time(0) - boot_time;
  d = theytime / 86400;
  h = (theytime / 3600) % 24;
  m = (theytime / 60) % 60;

  sprintf(buf,"%s\r\n"
          "Up since %s: %d day%s, %d:%02d\r\n",buf, tmstr, d,
          ((d == 1) ? "" : "s"), h, m);

  stat("../bin/fiery", &statbuf);
  sprintf(bcbuf, "Build: %d  Compiled: %s", make_count, ctime(&statbuf.st_mtime));
  bcbuf[strlen(bcbuf)-1] = 0;
  strcat(bcbuf,"\r\n");

  sprintf(wldinfo, "There are %5d rooms in %3d zones online.\r\n",
          top_of_world + 1, top_of_zone_table + 1);


  send_to_char(bcbuf, ch);
  send_to_char(buf, ch);
  send_to_char(wldinfo, ch);

  if (GET_LEVEL(ch) >= LVL_REBOOT_VIEW)
     reboot_info(ch);
}

d2895 2
a3447 109
/* David Endre 2/23/99 To view basic files online */
void do_file(struct char_data *ch, char *argument, char *value)
{
  FILE *req_file;
  int cur_line = 0,
      num_lines = 0,
      req_lines = 0,
      i,
      j;
  int l;
  char filebuf[50000];
  char filebuf2[50000];
  char field[MAX_INPUT_LENGTH];
  struct file_struct {
    char *cmd;
    char level;
    char *file;
  } fields[] = {
    { "none", LVL_IMPL, "Does Nothing" },
    { "bug", LVL_GOD, "../lib/misc/bugs"},
    { "typo", LVL_GOD, "../lib/misc/typos"},
    { "ideas", LVL_GOD, "../lib/misc/ideas"},
    { "xnames", LVL_GOD, "../lib/misc/xnames"},
    { "levels", LVL_GOD, "../log/levels" },
    { "rip", LVL_GOD, "../log/rip" },
    { "players", LVL_GOD, "../log/newplayers" },
    { "rentgone", LVL_GOD, "../log/rentgone" },
    { "godcmds", LVL_GOD, "../log/godcmds" },
    { "syslog", LVL_GOD, "../syslog" },
    { "crash", LVL_GOD, "../syslog.CRASH" },
    { "\n", 0, "\n" }
  };
  skip_spaces(&argument);
  if (!*argument)
  {
    strcpy(buf, "USAGE: show file <option> <num lines>\r\n\r\nFile options:\r\n");
    for (j = 0, i = 1; fields[i].level; i++)
      if (fields[i].level <= GET_LEVEL(ch))
        sprintf(buf, "%s%-15s%s\r\n", buf, fields[i].cmd, fields[i].file);
    send_to_char(buf, ch);
    return;
  }
  strcpy(arg, one_argument(argument, field));
  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if(*(fields[l].cmd) == '\n')
  {
    send_to_char("That is not a valid option!\r\n", ch);
    return;
  }
  if (GET_LEVEL(ch) < fields[l].level)
  {
    send_to_char("You are not godly enough to view that file!\r\n", ch);
    return;
  }
  if(!*value)
     req_lines = 15; /* default is the last 15 lines */
  else
     req_lines = atoi(value);
  /* open the requested file */
  if (!(req_file=fopen(fields[l].file,"r")))
  {
     sprintf(buf2, "SYSERR: Error opening file %s using 'file' command.",
             fields[l].file);
     mudlog(buf2, BRF, LVL_IMPL, TRUE);
     return;
  }
  /* count lines in requested file */
  get_line(req_file,filebuf);
  while (!feof(req_file))
  {
     num_lines++;
     get_line(req_file,filebuf);
  }
  fclose(req_file);

  /* Limit # of lines printed to # requested or # of lines in file or
     80 lines */
  if(req_lines > num_lines) req_lines = num_lines;
  if(req_lines > 500) req_lines = 500;
  /* close and re-open */
  if (!(req_file=fopen(fields[l].file,"r")))
  {
     sprintf(buf2, "SYSERR: Error opening file %s using 'file' command.",
             fields[l].file);
     mudlog(buf2, BRF, LVL_IMPL, TRUE);
     return;
  }

  filebuf2[0] = '\0';
  /* and print the requested lines */
  get_line(req_file,filebuf);
  while (!feof(req_file))
  {
     cur_line++;
     if(cur_line > (num_lines - req_lines))
     {
        sprintf(filebuf2,"%s%s\r\n",filebuf2, filebuf);
     }
     get_line(req_file,filebuf);
   }
   page_string(ch->desc, filebuf2, 1);


   fclose(req_file);
}

d4039 3
@


1.272
log
@Add "show damtypes"
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.271 2008/04/05 05:05:42 myc Exp jps $
d3334 2
a3335 2
         send_to_char("Idx  Damage type      Verb 1st         Verb 2nd\r\n", ch);
         send_to_char("---  -------------    -------------    --------------\r\n", ch);
d3338 1
a3338 1
                      "%2d.  %s%-15s  %-15s  %-15s&0\r\n",
d3340 2
a3341 1
                      damtypes[i].verb1st, damtypes[i].verb2nd);
d5886 3
@


1.271
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.270 2008/04/04 06:12:52 myc Exp myc $
d3201 1
d3224 1
d3321 1
a3321 1
                  "% 2d.  %s%c%-10s  % 4d  % 5d  % 6d  % 6d&0\r\n",
d3333 11
d5885 3
@


1.270
log
@Removed dieites/worship code.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.269 2008/04/03 17:36:09 jps Exp myc $
d2834 2
a2835 2
          SEND_TO_Q(motd, d);
          SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
d2881 1
a2881 1
         SEND_TO_Q("That name has been rejected, because it breaks this rule:\r\n", d);
d2884 1
a2884 1
         SEND_TO_Q(buf,d);
d2887 2
a2888 2
           SEND_TO_Q("Please try another name.\r\n", d);
           SEND_TO_Q("Name: ", d);
d2891 1
a2891 1
           SEND_TO_Q("&6&bYou are welcome to play, however, you will be prompted&0\r\n&6&bfor a new name on your next login.&0\r\n", d);
d5872 3
@


1.269
log
@Retired the invstart setting.  It has been replaced by the toggle "autoinvis".
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.268 2008/04/03 02:02:05 myc Exp jps $
a36 1
#include "worship.h"
a70 1
extern DI Dieties[];
d3708 1
a3708 1
   { "diety",        LVL_ADMIN,       PC,   NUMBER },
d3710 1
a3710 1
   { "rename",             LVL_GOD,         PC,   BINARY },
d4190 1
a4190 7
  case 61: /* diety */
    if((i = parse_diety(vict, *val_arg)) == INVALID_DIETY) {
       strcpy(buf, "That's not a valid deity.\r\n");
       save = FALSE;
    }
    else
      GET_DIETY(ch) = i;
d5872 3
@


1.268
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.267 2008/04/02 19:31:02 myc Exp myc $
d275 2
a276 2
	send_to_char("Your lips move, but no sound forms.\r\n", ch);
	return;
d336 1
a336 1
	  GET_NAME(REAL_CHAR(ch)), GET_NAME(vict), arg);
d418 1
a418 1
	world[location].people && world[location].people->next_in_room) {
d423 1
a423 1
	!House_can_enter(ch, world[location].number)) {
d552 2
a553 2
	send_to_char("Go transfer someone your own size.\r\n", ch);
	return;
d564 1
a564 1
  } else {			/* Trans All */
d572 4
a575 4
	victim = i->character;
	if (GET_LEVEL(victim) >= GET_LEVEL(ch))
	  continue;
	act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
d578 4
a581 4
	char_from_room(victim);
	char_to_room(victim, ch->in_room);
	act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
	act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
d801 1
a801 1
 	  rm->zone, CLR(ch, FGRN), rm->number, CLR(ch, ANRM), rrnum, buf2);
d822 1
a822 1
	    (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));
d836 1
a836 1
	continue;
d841 1
a841 1
	*buf2 = found = 0;
d853 1
a853 1
	sprintf(buf1, " %sNONE%s", CLR(ch, FCYN), CLR(ch, ANRM));
d855 2
a856 2
	sprintf(buf1, "%s%5d%s", CLR(ch, FCYN),
		world[rm->dir_option[i]->to_room].number, CLR(ch, ANRM));
d1034 2
a1035 2
	       GET_OBJ_VAL(j, 0), buf2, GET_OBJ_VAL(j, 2),
	       YESNO(GET_OBJ_VAL(j, 3)));
d1103 1
a1103 1
	*buf1 = found = 0;
d1422 1
a1422 1
	  (k->master ? GET_NAME(k->master) : "<none>"));
d1437 1
a1437 1
	  ((k->group_master) ? GET_NAME(k->group_master) : "<none>"));
d1582 1
a1582 1
	do_stat_character(ch, victim);
d1584 1
a1584 1
	send_to_char("No such mobile around.\r\n", ch);
d1591 1
a1591 1
	do_stat_character(ch, victim);
d1593 1
a1593 1
	send_to_char("No such player around.\r\n", ch);
d1602 5
a1606 5
	if (GET_LEVEL(victim) > GET_LEVEL(ch))
	  send_to_char("Sorry, you can't do that.\r\n", ch);
	else
	  do_stat_character(ch, victim);
	free_char(victim);
d1608 2
a1609 2
	send_to_char("There is no such player.\r\n", ch);
	free(victim);
d1617 1
a1617 1
	do_stat_object(ch, object);
d1619 1
a1619 1
	send_to_char("No such object around.\r\n", ch);
d1664 1
a1664 1
 		"           &1&b** ****** ****&0\r\n"
d1898 1
a1898 1
	0, 0, TO_ROOM);
d2081 2
a2082 2
  if (*buf) {			/* argument supplied. destroy single object
				 * or char */
d2085 2
a2086 2
	send_to_char("Fuuuuuuuuu!\r\n", ch);
	return;
d2090 6
a2095 6
	sprintf(buf, "(GC) %s has purged %s.", GET_NAME(ch), GET_NAME(vict));
	mudlog(buf, BRF, LVL_GOD, TRUE);
	if (vict->desc) {
	  close_socket(vict->desc);
	  vict->desc = NULL;
	}
d2106 1
a2106 1
  } else {			/* no argument. clean out the room */
d2108 1
a2108 1
	FALSE, ch, 0, 0, TO_ROOM);
d2113 1
a2113 1
	extract_char(vict);
d2118 2
a2119 2
				      like in Fiery v1 RSD */
	extract_obj(obj);
d2185 1
a2185 1
		 "&0&9&bYou feel somewhat diminished.&0\r\n", victim);
d2188 11
a2198 11
	"A strange feeling comes upon you,\r\n"
	"Like a giant hand, light comes down\r\n"
	"from above, grabbing your body, that\r\n"
	"begins to pulse with colored lights\r\n"
	"from inside.\r\n\r\n"
	"Your head seems to be filled with demons\r\n"
	"from another plane as your body dissolves\r\n"
	"to the elements of time and space itself.\r\n"
	"Suddenly a silent explosion of light\r\n"
	"snaps you back to reality.\r\n\r\n"
	"You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
d2338 1
a2338 1
	  tch, TO_VICT);
d2341 1
a2341 1
	  tch, TO_VICT);
d2389 1
a2389 1
	send_to_char(buf, pt->character);
d2507 1
a2507 1
	    restrict, when);
d2540 1
a2540 1
	    ((d == 1) ? "" : "s"), h, m);
d2613 1
a2613 1
	continue;
d2626 1
a2626 1
	continue;
d2646 1
a2646 1
		 "       wiznet @@<level> | wiz @@\r\n", ch);
d2657 2
a2658 2
	send_to_char("You can't wizline above your own level.\r\n", ch);
	return;
d2665 13
a2677 13
	  !PRF_FLAGGED(d->character, PRF_NOWIZ) &&
	  (CAN_SEE(ch, d->character) || GET_LEVEL(ch) == LVL_IMPL)) {
	if (!any) {
	  sprintf(buf1, "Gods online:\r\n");
	  any = TRUE;
	}
	sprintf(buf1, "%s  %s", buf1, GET_NAME(d->character));
	if (PLR_FLAGGED(d->character, PLR_WRITING))
	  sprintf(buf1, "%s (Writing)\r\n", buf1);
	else if (PLR_FLAGGED(d->character, PLR_MAILING))
	  sprintf(buf1, "%s (Writing mail)\r\n", buf1);
	else
	  sprintf(buf1, "%s\r\n", buf1);
d2684 7
a2690 7
	  PRF_FLAGGED(d->character, PRF_NOWIZ) &&
	  CAN_SEE(ch, d->character)) {
	if (!any) {
	  sprintf(buf1, "%sGods offline:\r\n", buf1);
	  any = TRUE;
	}
	sprintf(buf1, "%s  %s\r\n", buf1, GET_NAME(d->character));
d2804 2
a2805 2
	 or has been auto-accepted and still pending approval
	 and the player is not yourself
d2810 1
a2810 1
	   (strn_cmp(GET_NAME(d->character), arg, strlen(arg)) == 0)))
d2812 1
a2812 1
	/* create the player in the pfile if he isn't there already */
d2815 7
a2821 7
	  /* initialize the the player */
	  init_player(d->character);
	  /* log the new player */
	  sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
	  mudlog(buf, NRM, LVL_IMMORT, TRUE);
	}
	/* accept the players name */
d2825 1
a2825 1
	/* log the acceptance of the name */
d2829 1
a2829 1
	/* remove the choose new name flag */
d2833 7
a2839 7
	/* check if the player is waiting approval or already auto approved */
	if(STATE(d) == CON_NAME_WAIT_APPROVAL) {
	  /* send the motd and change connection states */
	  SEND_TO_Q(motd, d);
	  SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
	  STATE(d) = CON_RMOTD;
	}
d2841 1
a2841 1
	/* tell the player the name has been accepted */
d2844 1
a2844 1
	send_to_char(buf, d->character);
d2887 9
a2895 9
	 SET_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);
	 if(STATE(d) == CON_NAME_WAIT_APPROVAL) {
	   SEND_TO_Q("Please try another name.\r\n", d);
	   SEND_TO_Q("Name: ", d);
	   STATE(d) = CON_NEW_NAME;
	 } else {
	   SEND_TO_Q("&6&bYou are welcome to play, however, you will be prompted&0\r\n&6&bfor a new name on your next login.&0\r\n", d);
	   save_player(d->character);
	 }
d2918 5
a2922 5
	if (((STATE(d) == CON_NAME_WAIT_APPROVAL) ||
	     (PLR_FLAGGED(d->character, PLR_NAPPROVE) && !(PLR_FLAGGED(d->character, PLR_NEWNAME)))) &&
	    (d != ch->desc)) {
	  sprintf(buffer, "%s%s\r\n", buffer, GET_NAME(d->character));
	}
d2956 2
a2957 2
	  return;
	  for (i = 0; i <= top_of_zone_table; i++)
d2969 1
a2969 1
	break;
d2978 1
a2978 1
	    zone_table[i].name);
d3074 2
a3075 2
	      GET_STR(vict), GET_ADD(vict), GET_INT(vict), GET_WIS(vict),
	      GET_DEX(vict), GET_CON(vict), GET_CHA(vict));
d3080 2
a3081 2
	send_to_char("Your victim is not flagged.\r\n", ch);
	return;
d3093 1
a3093 1
	      GET_NAME(vict), GET_NAME(ch));
d3101 1
a3101 1
	      GET_NAME(vict), GET_NAME(ch));
d3108 2
a3109 2
	send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
	return;
d3112 2
a3113 2
	send_to_char("Your victim is already pretty cold.\r\n", ch);
	return;
d3125 2
a3126 2
	send_to_char("Sorry, your victim is not morbidly encased in ice at the moment.\r\n", ch);
	return;
d3129 4
a3132 4
	sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n",
	   GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
	send_to_char(buf, ch);
	return;
d3143 14
a3156 14
	while (vict->effects)
	  effect_remove(vict, vict->effects);
	send_to_char("There is a brief flash of light!\r\n"
		     "You feel slightly different.\r\n", vict);
	send_to_char("All spells removed.\r\n", ch);
	check_regen_rates(vict);
	/* if it had been an animated and now isnt then it needs to die */
	if (MOB_FLAGGED(vict, MOB_ANIMATED) &&
	    !EFF_FLAGGED(vict, EFF_ANIMATED)) {
	  act("$n freezes and falls twitching to the ground.", FALSE, vict, 0,
	      0, TO_ROOM);	
	  die(vict, NULL);
	  return;
	}
d3158 2
a3159 2
	send_to_char("Your victim does not have any effects!\r\n", ch);
	return;
d3178 3
a3180 3
	  bufptr, zone_table[zone].number, zone_table[zone].name,
	  zone_table[zone].age, zone_table[zone].lifespan,
	  zone_table[zone].reset_mode, zone_table[zone].zone_factor,
d3622 3
a3624 3
#define MISC	0
#define BINARY	1
#define NUMBER	2
d3627 2
a3628 2
	if (on) SET_FLAG(flagset, flags); \
	else if (off) REMOVE_FLAG(flagset, flags); } while (0)
d3650 1
a3650 1
   { "invstart",     LVL_ATTENDANT,   PC,   BINARY }, /* 1*/
d3669 1
a3669 1
   { "home",	     LVL_GOD,         PC,   NUMBER },
d3712 1
a3712 1
   { "rename",	     LVL_GOD,         PC,   BINARY },
d3725 1
a3725 1
   { "\n",           0,	              BOTH, MISC   }
d3747 5
a3751 5
      if (fields[l].level <= GET_LEVEL(ch)) {
	sprintf(buf2, "%s%-20.20s %-20.20s %-6.6s\r\n", buf2, fields[l].cmd,
	  (fields[l].pcnpc==PC?"Player Only":"Player or Mob"),
	  (fields[l].type==BINARY?"Binary":(fields[l].type==NUMBER?"Number":
	  "Misc")));
d3760 2
a3761 2
	send_to_char("There is no such player.\r\n", ch);
	return;
d3765 2
a3766 2
	send_to_char("There is no such creature.\r\n", ch);
	return;
d3775 3
a3777 3
	free_char(cbuf);
	send_to_char("Sorry, you can't do that.\r\n", ch);
	return;
d3826 2
a3827 2
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_INVSTART);
    break;
d3834 1
a3834 1
    on = !on;			/* so output will be correct */
d3997 1
a3997 1
	      value);
d4082 3
a4084 3
	GET_LOADROOM(vict) = value;
	sprintf(buf, "%s will enter at room #%d.\r\n", GET_NAME(vict),
		GET_LOADROOM(vict));
d4086 1
a4086 1
	strcpy(buf, "That room does not exist!\r\n");
d4322 1
a4322 1
	    GET_NAME(vict));
d4326 1
a4326 1
	    fields[l].cmd, value);
d4356 1
a4356 1
	  (PRF_FLAGGED(ch, PRF_LOG2) ? 2 : 0));
d4383 1
a4383 1
 	send_to_char(msg, pt->character);
d4442 2
a4443 2
	  "Up since %s: %d day%s, %d:%02d\r\n",buf, tmstr, d,
	  ((d == 1) ? "" : "s"), h, m);
d4451 1
a4451 1
	  top_of_world + 1, top_of_zone_table + 1);
d4560 1
a4560 1
	!strcasecmp(field, commands[i].name))
d4567 5
a4571 2
	if (!n_visible++)
	  send_to_char("\r\n[Current game status:]\r\n\r\n", ch);
d4573 1
a4573 2
	sprintf(shortbuf, "[%s%s&0]", *commands[i].config ? "&2&b" : "&1&b",
		commands[i].name);
d4575 9
a4583 1
	if (commands[i].has_value) {
d4585 1
a4585 11
	  sprintf(linebuf, "%-19s%s %i\r\n", shortbuf, *commands[i].config ?
		  commands[i].enabled : commands[i].disabled,
		  *commands[i].config);
	}
	else {
	  sprintf(linebuf, "%-19s%s\r\n", shortbuf, *commands[i].config ?
		  commands[i].enabled : commands[i].disabled);
	
	};
	
	send_to_char(linebuf, ch);
d4605 1
a4605 1
	 commands[i].turn_off);
d4827 1
a4827 1
	extern char *anews;
d4844 11
a4854 11
 	{ "credits",	LVL_IMPL,	&credits,	2400,	CREDITS_FILE},
 	{ "news",	LVL_GRGOD,	&news,		8192,	NEWS_FILE},
 	{ "anews",	LVL_GRGOD,	&anews,		8192,	ANEWS_FILE},
	{ "motd",	LVL_GRGOD,	&motd,		2400,	MOTD_FILE},
 	{ "imotd",	LVL_HEAD_B,	&imotd,		2400,	IMOTD_FILE},
 	{ "help",       LVL_GRGOD,	&help,		2400,	HELP_PAGE_FILE},
 	{ "info",	LVL_GRGOD,	&info,		8192,	INFO_FILE},
	{ "background",	LVL_GRGOD,	&background,	8192,	BACKGROUND_FILE},
 	{ "handbook",   LVL_HEAD_B,	&handbook,	8192,   HANDBOOK_FILE},
 	{ "policies",	LVL_IMPL,	&policies,	8192,	POLICIES_FILE},
 	{ "\n",		0,		NULL,		0,	NULL }
d4873 5
a4877 5
 	 if (GET_LEVEL(ch) >= fields[l].level) {
 	    sprintf(buf, "%s%-11.11s", buf, fields[l].cmd);
 	    if (!(i % 7)) strcat(buf, "\r\n");
 	    i++;
 	 }
d4922 1
a4922 1
  CREATE (room, struct room_data, 1);	
d4947 1
a4947 1
	send_to_char("This room has no description!\r\n", ch);
d4964 2
a4965 2
	iroom = atoi(buf3);
	rroom = real_room(iroom);
d4974 3
a4976 3
	sprintf(buf, "There is no room with the number %d", iroom);
	send_to_char(buf, ch);
	return; }
d5158 2
a5159 2
	  close_socket(cbuf->desc);
	  cbuf->desc = NULL;
d5218 1
a5218 1
	sprintf(buf, "%s%-15s%s\r\n", buf, fields[i].cmd, fields[i].file);
d5298 7
a5304 7
			  "Invalid Characters",
			  "Too Short",
			  "Too Long",
			  "Reserved Fill Word",
			  "Reserved Word",
			  "Xname or MOB/OBJ name",
			  "Inactivity"};
d5380 1
a5380 1
	sprintf(buf, "PFILEMAINT: Level %d Idle: %d days.",
d5382 1
a5382 1
	log(buf);
d5880 3
@


1.267
log
@Added str_catf functions and used them in do_stat functions.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.266 2008/04/02 03:24:44 myc Exp myc $
a272 4
    if (GET_LEVEL(ch) < LVL_IMMORT && strchr(argument, '&'))  {
      send_to_char("No ampersand sign allowed in input.\r\n", ch);
      return;
    }
d278 2
d765 2
a766 2
         sprintf(buf, "%s&4*&0 %s%s%s\r\n%s", buf, CCCYN(ch, C_NRM),
               desc->keyword, CCNRM(ch, C_NRM), desc->description);
d771 1
a771 1
      sprintf(buf, "Extra desc%s (%d):%s", ed->next ? "s" : "", count, CCCYN(ch, C_NRM));
d778 1
a778 1
      strcat(buf, CCNRM(ch, C_NRM));
d797 1
a797 1
           CCCYN(ch, C_NRM), rm->name, CCNRM(ch, C_NRM));
d801 1
a801 1
 	  rm->zone, CCGRN(ch, C_NRM), rm->number, CCNRM(ch, C_NRM), rrnum, buf2);
d817 1
a817 1
  sprintf(buf2, "Chars present:%s", CCYEL(ch, C_NRM));
d830 1
a830 1
  str_cat(buf, CCNRM(ch, C_NRM));
d833 1
a833 1
    sprintf(buf2, "Contents:%s", CCGRN(ch, C_NRM));
d847 1
a847 1
    str_cat(buf, CCNRM(ch, C_NRM));
d853 1
a853 1
	sprintf(buf1, " %sNONE%s", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
d855 2
a856 2
	sprintf(buf1, "%s%5d%s", CCCYN(ch, C_NRM),
		world[rm->dir_option[i]->to_room].number, CCNRM(ch, C_NRM));
d859 1
a859 1
               CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
d949 2
a950 2
           CCYEL(ch, C_NRM), j->short_description ? j->short_description :
           "<None>", CCNRM(ch, C_NRM), j->name, GET_OBJ_LEVEL(j));
d958 1
a958 1
           CCGRN(ch, C_NRM), virtual, CCNRM(ch, C_NRM), GET_OBJ_RNUM(j), buf1, buf2);
d965 1
a965 1
              CCYEL(ch, C_NRM), j->action_description, CCNRM(ch, C_NRM));
d969 1
a969 1
           CCCYN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d973 1
a973 1
           CCGRN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d978 1
a978 1
           CCYEL(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d1097 1
a1097 1
    sprintf(buf1, "\r\nContents:%s", CCGRN(ch, C_NRM));
d1109 1
a1109 1
    str_cat(buf, CCNRM(ch, C_NRM));
d1249 3
a1251 3
           CLASS_FULL(k), CCYEL(ch, C_NRM), GET_LEVEL(k),
           CCNRM(ch, C_NRM), CCYEL(ch, C_NRM), GET_EXP(k),
           CCNRM(ch, C_NRM), GET_ALIGNMENT(k));
d1294 1
a1294 1
           CCCYN(ch, C_NRM), GET_VIEWED_STR(k), GET_VIEWED_INT(k),
d1296 2
a1297 2
           GET_VIEWED_CHA(k), CCNRM(ch, C_NRM),
           CCCYN(ch, C_NRM), GET_NATURAL_STR(k), GET_NATURAL_INT(k),
d1299 2
a1300 2
           GET_NATURAL_CHA(k), CCNRM(ch, C_NRM),
           CCCYN(ch, C_NRM), GET_AFFECTED_STR(k), GET_AFFECTED_INT(k),
d1302 1
a1302 1
           GET_AFFECTED_CHA(k), CCNRM(ch, C_NRM));
d1306 14
a1319 14
           CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CCNRM(ch, C_NRM),
           CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CCNRM(ch, C_NRM),
           CCGRN(ch, C_NRM), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM));

  str_catf(buf, "Coins: [%s%d%sp / %s%s%d%sg / %s%d%ss / %s%d%sc], "
                 "Bank: [%s%d%sp / %s%s%d%sg / %s%d%ss / %s%d%sc]\r\n",
           CCCYN(ch, C_NRM), GET_PLAT(k), CCNRM(ch, C_NRM),
           CCYEL(ch, C_NRM), CCBLD(ch, C_NRM), GET_GOLD(k), CCNRM(ch, C_NRM),
           CCWHT(ch, C_NRM), GET_SILVER(k), CCNRM(ch, C_NRM),
           CCYEL(ch, C_NRM), GET_COPPER(k), CCNRM(ch, C_NRM),
           CCCYN(ch, C_NRM), GET_BANK_PLAT(k), CCNRM(ch, C_NRM),
           CCYEL(ch, C_NRM), CCBLD(ch, C_NRM), GET_BANK_GOLD(k), CCNRM(ch, C_NRM),
           CCWHT(ch, C_NRM), GET_BANK_SILVER(k), CCNRM(ch, C_NRM),
           CCYEL(ch, C_NRM), GET_BANK_COPPER(k), CCNRM(ch, C_NRM));
d1380 1
a1380 1
             CCCYN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d1384 1
a1384 1
    str_catf(buf, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1386 1
a1386 1
    str_catf(buf, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1461 1
a1461 1
  str_catf(buf, "EFF: %s%s%s\r\n", CCYEL(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d1478 1
a1478 1
               CCCYN(ch, C_NRM), skills[eff->type].name, CCNRM(ch, C_NRM));
d1481 1
a1481 1
               CCCYN(ch, C_NRM), skills[eff->type].name, CCNRM(ch, C_NRM));
d2051 1
a2051 1
        color = KCYN;
d2053 1
a2053 1
        color = KRED;
d2055 1
a2055 1
        color = KYEL;
d2057 1
a2057 1
        color = KGRN;
d2993 2
a2994 1
  add_zero = (len < 2 || wiztitle[len - 1] != '0' || wiztitle[len - 2] != '&');
d5455 1
a5455 1
              CCYEL(ch, C_NRM), connected_types[STATE(d)], CCNRM(ch, C_NRM));
d5474 2
a5475 2
  sprintf(buf, "\r\n %s%s<<< HOTBOOT by %s - please remain seated! >>>%s\r\n",
          CCRED(ch, C_NRM), CCBLD(ch, C_NRM), GET_NAME(ch), CCNRM(ch, C_NRM));
d5880 3
@


1.266
log
@Rewrote group code and removed all major group code.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.265 2008/03/30 17:30:38 jps Exp myc $
a791 1
  char *pos = buf;
d796 4
a799 2
  pos += sprintf(pos, "Room name: %s%s%s\r\n",
          CCCYN(ch, C_NRM), rm->name, CCNRM(ch, C_NRM));
d802 2
a803 2
  pos += sprintf(pos, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
	  rm->zone, CCGRN(ch, C_NRM), rm->number, CCNRM(ch, C_NRM), rrnum, buf2);
d806 2
a807 2
  pos += sprintf(pos, "SpecProc: %s, Flags: %s\r\n",
	  (rm->func == NULL) ? "None" : "Exists", buf2);
d810 1
a810 1
  pos += sprintf(pos, "Room effects: %s\r\n", buf2);
d812 1
a812 1
  pos += sprintf(pos, "Ambient Light : %d\r\n", rm->light);
d814 2
a815 2
  pos += sprintf(pos, "Description:\r\n%s",
          rm->description ? rm->description : "  None.\r\n");
d817 1
a817 2
  stat_extra_descs(rm->ex_description, ch, pos, FALSE);
  pos += strlen(pos);
d826 1
a826 1
      pos += sprintf(pos, "%s%s\r\n", buf2, k->next_in_room ? "," : "");
d831 2
a832 2
    pos += sprintf(pos, "%s\r\n", buf2);
  pos += sprintf(pos, "%s", CCNRM(ch, C_NRM));
d842 1
a842 1
        pos += sprintf(pos, "%s%s\r\n", buf2, j->next_content ? "," : "");
d848 2
a849 2
      pos += sprintf(pos, "%s\r\n", buf2);
    pos += sprintf(pos, "%s", CCNRM(ch, C_NRM));
d860 4
a863 4
      pos += sprintf(pos, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n",
	      CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
	      rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None",
	      buf2);
d865 1
a865 1
        pos += sprintf(pos, "%s", rm->dir_option[i]->general_description);
d873 2
a874 2
        pos += sprintf(pos, "SPL: (%3d) &6%-21s&0, sets %s\r\n",
              reff->timer, skills[reff->spell].name, buf2);
d878 1
a878 2
  list_zone_commands_room(ch, pos, rm->number);
  pos += strlen(pos);
d881 1
a881 1
  do_sstat_room(ch, pos, rm);
a938 1
  char *pos = buf;
d947 2
d950 3
a952 3
  pos += sprintf(pos, "Name: '%s%s%s', Aliases: %s, Level: %d\r\n",
          CCYEL(ch, C_NRM), j->short_description ? j->short_description :
          "<None>", CCNRM(ch, C_NRM), j->name, GET_OBJ_LEVEL(j));
d959 2
a960 2
  pos += sprintf(pos, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s\r\n",
	  CCGRN(ch, C_NRM), virtual, CCNRM(ch, C_NRM), GET_OBJ_RNUM(j), buf1, buf2);
d962 2
a963 2
  pos += sprintf(pos, "L-Des: %s\r\n", j->description ? j->description :
          "None");
d966 2
a967 2
     pos += sprintf(pos, "Action desc:\r\n%s%s%s\r\n",
             CCYEL(ch, C_NRM), j->action_description, CCNRM(ch, C_NRM));
d970 2
a971 2
  pos += sprintf(pos, "Can be worn on: %s%s%s\r\n",
          CCCYN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d974 2
a975 2
  pos += sprintf(pos, "Extra flags   : %s%s%s\r\n",
          CCGRN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d979 2
a980 2
  pos += sprintf(pos, "Spell Effects : %s%s%s\r\n",
          CCYEL(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d982 4
a985 4
  pos += sprintf(pos, "Weight: %d, Value: %d, Cost/day: %d, "
                      "Timer: %d, Hiddenness: %ld\r\n",
	  GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j),
          GET_OBJ_TIMER(j), GET_OBJ_HIDDENNESS(j));
d991 4
a994 4
  pos += sprintf(pos, "In room: %s, In object: %s, Carried by: %s, Worn by: %s\r\n",
          buf1, j->in_obj ? j->in_obj->short_description : "None",
          j->carried_by ? GET_NAME(j->carried_by) : "Nobody",
          j->worn_by ? GET_NAME(j->worn_by) : "Nobody");
d999 1
a999 1
      pos += sprintf(pos, "Hours left: Infinite\r\n");
d1001 2
a1002 2
      pos += sprintf(pos, "Hours left: [%d]  Initial hours: [%d]\r\n",
              GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
d1006 3
a1008 3
    pos += sprintf(pos, "Spells: (Level %d) %s, %s, %s\r\n",
            GET_OBJ_VAL(j, 0), skill_name(GET_OBJ_VAL(j, 1)),
            skill_name(GET_OBJ_VAL(j, 2)), skill_name(GET_OBJ_VAL(j, 3)));
d1012 3
a1014 3
    pos += sprintf(pos, "Spell: %s at level %d, %d (of %d) charges remaining\r\n",
	    skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
	    GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
d1017 7
a1023 7
    pos += sprintf(pos, "Todam: %dd%d (avg %.1f), Message type: %d, '%s'\r\n",
	    GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), WEAPON_AVERAGE(j),
            GET_OBJ_VAL(j, 3),
            GET_OBJ_VAL(j, 3) >= 0 &&
              GET_OBJ_VAL(j, 3) <= TYPE_STAB - TYPE_HIT ?
            attack_hit_text[GET_OBJ_VAL(j, 3)].singular :
            "<&1INVALID&0>");
d1026 1
a1026 1
    pos += sprintf(pos, "AC-apply: [%d]\r\n", GET_OBJ_VAL(j, 0));
d1029 2
a1030 2
    pos += sprintf(pos, "Spell: %d, - Hitpoints: %d\r\n",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1));
d1035 3
a1037 3
      pos += sprintf(pos, "Weight capacity: %d, Lock Type: %s, Key Num: %d, Corpse: %s\r\n",
	      GET_OBJ_VAL(j, 0), buf2, GET_OBJ_VAL(j, 2),
	      YESNO(GET_OBJ_VAL(j, 3)));
d1040 4
a1043 4
      pos += sprintf(pos, "Weight capacity: %d, Index: %d, Corpse: %s, Player "
	      "Corpse: %s, Raisable: %s\r\n", GET_OBJ_VAL(j,0), GET_OBJ_VAL(j,2),
	      YESNO(GET_OBJ_VAL(j,3)), YESNO(IS_PLR_CORPSE(j)),
	      YESNO(GET_OBJ_VAL(j, 3) == CORPSE_NPC));
d1049 3
a1051 3
    pos += sprintf(pos, "Capacity: %d, Contains: %d, Poisoned: %s, Liquid: %s\r\n",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), YESNO(IS_POISONED(j)),
	    buf2);
d1054 1
a1054 1
    pos += sprintf(pos, "Tongue: %d\r\n", GET_OBJ_VAL(j, 0));
d1059 2
a1060 2
    pos += sprintf(pos, "Makes full: %d, Poisoned: %s\r\n",
            GET_OBJ_VAL(j, 0), YESNO(IS_POISONED(j)));
d1063 1
a1063 1
    pos += sprintf(pos, "Coins: %d\r\n", GET_OBJ_VAL(j, 0));
d1066 1
a1066 1
    pos += sprintf(pos, "To room: %d\r\n", GET_OBJ_VAL(j, 0));
d1071 1
a1071 1
        pos += sprintf(pos, "Entry-Room message: %s", portal_entry_messages[i]);
d1077 1
a1077 1
        pos += sprintf(pos, "To-Char message   : %s", portal_character_messages[i]);
d1083 1
a1083 1
        pos += sprintf(pos, "Exit-Room message : %s", portal_exit_messages[i]);
d1087 3
a1089 3
    pos += sprintf(pos, "Values 0-3: [%d] [%d] [%d] [%d]\r\n",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
d1104 1
a1104 1
        pos += sprintf(pos, "%s%s\r\n", buf1, j2->next_content ? "," : "");
d1110 2
a1111 2
      pos += sprintf(pos, "%s\r\n", buf1);
    pos += sprintf(pos, "%s", CCNRM(ch, C_NRM));
d1115 1
a1115 1
  pos += sprintf(pos, "Applies:");
d1119 2
a1120 2
      pos += sprintf(pos, "%s %s", found++ ? "," : "",
            format_apply(j->effects[i].location, j->effects[i].modifier));
d1122 1
a1122 1
  pos += sprintf(pos, "%s\r\n", found ? "" : " None");
d1124 2
a1125 4
  if (GET_OBJ_TYPE(j) == ITEM_SPELLBOOK) {
    stat_spellbook(j, pos);
    pos += strlen(pos);
  }
d1127 1
a1127 2
  stat_extra_descs(j->ex_description, ch, pos, FALSE);
  pos += strlen(pos);
d1132 1
a1132 1
    pos += sprintf(pos, "Events: %s", eventname(e));
d1135 1
a1135 1
      pos += sprintf(pos, " %s", eventname(e));
d1137 1
a1137 1
    pos += sprintf(pos, "\r\n");
d1139 1
a1139 1
    pos += sprintf(pos, "No events.\r\n");
d1143 1
a1143 2
  do_sstat_object(ch, pos, j);
  /* pos += strlen(pos) */
a1208 1
  char *pos = buf;
d1213 2
d1216 4
a1219 4
  pos += sprintf(pos, "%s '%s'  IDNum: [%5ld], In room [%5d]\r\n",
          (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
          GET_NAME(k), GET_IDNUM(k),
          k->in_room != NOWHERE ? world[k->in_room].number : 0);
d1223 2
a1224 2
    pos += sprintf(pos, "Alias: %s, VNum: [%5d], RNum: [%5ld]\r\n",
            GET_NAMELIST(k), GET_MOB_VNUM(k), GET_MOB_RNUM(k));
d1228 2
a1229 2
    pos += sprintf(pos, "L-Des: %s",
            (GET_LDESC(k) ? GET_LDESC(k) : "<None>\r\n"));
d1231 2
a1232 2
    pos += sprintf(pos, "Title: %s\r\n",
            (k->player.title ? k->player.title : "<None>"));
d1236 2
a1237 2
  pos += sprintf(pos, "Race: %s, Race Align: %s, ",
          RACE_PLAINNAME(k), RACE_ALIGN_ABBR(k));
d1240 1
a1240 1
    pos += sprintf(pos, "Deity: %s, ", GET_DIETY(ch) >= 0 ?
d1244 10
a1253 10
  pos += sprintf(pos,
          "Size: %c%s, Sex: %s\r\n"
          "Life force: %s%c%s&0, Composition: %s%c%s&0\r\n"
          "Class: %s, Lev: [%s%2d%s], XP: [%s%7ld%s], Align: [%4d]\r\n",
          UPPER(*SIZE_DESC(k)), SIZE_DESC(k) + 1, buf1,
          LIFEFORCE_COLOR(k), UPPER(*LIFEFORCE_NAME(k)), LIFEFORCE_NAME(k) + 1,
          COMPOSITION_COLOR(k), UPPER(*COMPOSITION_NAME(k)), COMPOSITION_NAME(k) + 1,
          CLASS_FULL(k), CCYEL(ch, C_NRM), GET_LEVEL(k),
          CCNRM(ch, C_NRM), CCYEL(ch, C_NRM), GET_EXP(k),
          CCNRM(ch, C_NRM), GET_ALIGNMENT(k));
d1260 7
a1266 7
    pos += sprintf(pos,
            "Created: [%s], Last Logon: [%s], Played: [%dh %dm]\r\n"
            "Age: [%d], Homeroom: [%d], Speaks: [%d/%d/%d]",
	    buf1, buf2, k->player.time.played / 3600,
	    ((k->player.time.played / 3600) % 60),
            age(k).year, GET_HOME(k), GET_TALK(k, 0),
            GET_TALK(k, 1), GET_TALK(k, 2));
d1271 2
a1272 2
        pos += sprintf(pos, ", Clan: [%s], Rank: [%d]",
                clans[clan].abbreviation, GET_CLAN_RANK(k));
d1274 1
a1274 1
        pos += sprintf(pos, ", Clan: [Invalid]");
d1284 1
a1284 1
      pos += sprintf(pos, ", OLC Zones: [%s]", *buf1 ? buf1 : "NONE");
d1287 1
a1287 1
    pos += sprintf(pos, "\r\n");
d1291 41
a1331 41
  pos += sprintf(pos,
          "         STR   INT   WIS   DEX   CON   CHA\r\n"
	  "VIEWED   %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n"
	  "NATURAL  %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n"
	  "AFFECTED %s%3d   %3d   %3d   %3d   %3d   %3d%s\r\n",
	  CCCYN(ch, C_NRM), GET_VIEWED_STR(k), GET_VIEWED_INT(k),
          GET_VIEWED_WIS(k), GET_VIEWED_DEX(k), GET_VIEWED_CON(k),
          GET_VIEWED_CHA(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_NATURAL_STR(k), GET_NATURAL_INT(k),
          GET_NATURAL_WIS(k), GET_NATURAL_DEX(k), GET_NATURAL_CON(k),
          GET_NATURAL_CHA(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_AFFECTED_STR(k), GET_AFFECTED_INT(k),
          GET_AFFECTED_WIS(k), GET_AFFECTED_DEX(k), GET_AFFECTED_CON(k),
          GET_AFFECTED_CHA(k), CCNRM(ch, C_NRM));

  pos += sprintf(pos,
          "HP: [%s%d/%d+%d%s]  MP: [%s%d/%d+%d%s]  MV: [%s%d/%d+%d%s]\r\n",
	  CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM));

  pos += sprintf(pos, "Coins: [%s%d%sp / %s%s%d%sg / %s%d%ss / %s%d%sc], "
               "Bank: [%s%d%sp / %s%s%d%sg / %s%d%ss / %s%d%sc]\r\n",
          CCCYN(ch, C_NRM), GET_PLAT(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), CCBLD(ch, C_NRM), GET_GOLD(k), CCNRM(ch, C_NRM),
          CCWHT(ch, C_NRM), GET_SILVER(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_COPPER(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_BANK_PLAT(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), CCBLD(ch, C_NRM), GET_BANK_GOLD(k), CCNRM(ch, C_NRM),
          CCWHT(ch, C_NRM), GET_BANK_SILVER(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_BANK_COPPER(k), CCNRM(ch, C_NRM));

  pos += sprintf(pos, "AC: [%d/10], Hitroll: [%2d], Damroll: [%2d], "
               "Saving throws: [%d/%d/%d/%d/%d]\r\n"
               "Perception: [%4ld], Hiddenness: [%4ld], Rage: [%4d]\r\n",
	  GET_AC(k) + 5 * monk_weight_penalty(k),
          GET_HITROLL(k) - monk_weight_penalty(k),
          GET_DAMROLL(k) - monk_weight_penalty(k),
          GET_SAVE(k, 0), GET_SAVE(k, 1), GET_SAVE(k, 2),
          GET_SAVE(k, 3), GET_SAVE(k, 4),
          GET_PERCEPTION(k), GET_HIDDENNESS(k), GET_RAGE(k));
d1336 1
a1336 1
  pos += sprintf(pos, "Pos: %s (%s)", buf1, buf2);
d1339 1
a1339 1
    pos += sprintf(pos, ", Default Pos: %s", buf1);
d1341 1
a1341 1
  pos += sprintf(pos, ", Fighting: %s",
d1344 4
a1347 4
    pos += sprintf(pos, ", %s into: %s",
            GET_LEVEL(k) > LVL_IMMORT ? "Switched" : "Shapechanged",
            GET_NAME(k->forward));
  pos += sprintf(pos, "\r\n");
d1363 1
a1363 1
    pos += sprintf(pos, "%s\r\n", buf2);
d1371 5
a1375 5
    pos += sprintf(pos,
            "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d, Attack type: %s\r\n",
	    (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
	    k->mob_specials.damnodice, k->mob_specials.damsizedice,
            buf2);
d1381 2
a1382 2
    pos += sprintf(pos, "NPC flags: %s%s%s\r\n",
            CCCYN(ch, C_NRM), buf1, CCNRM(ch, C_NRM));
d1386 1
a1386 1
    pos += sprintf(pos, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1388 1
a1388 1
    pos += sprintf(pos, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1397 6
a1402 6
  pos += sprintf(pos, "Max Carry: %d (%d weight); "
                      "Carried: %d (%d weight); "
                      "Worn: %d (%d weight)\r\n",
          CAN_CARRY_N(k), CAN_CARRY_W(k),
          IS_CARRYING_N(k), IS_CARRYING_W(k),
          found, a);
d1405 1
a1405 1
  pos += sprintf(pos, "Hunger: ");
d1407 1
a1407 1
    pos += sprintf(pos, "Off");
d1409 2
a1410 2
    pos += sprintf(pos, "%d", GET_COND(k, FULL));
  pos += sprintf(pos, ", Thirst: ");
d1412 1
a1412 1
    pos += sprintf(pos, "Off");
d1414 2
a1415 2
    pos += sprintf(pos, "%d", GET_COND(k, THIRST));
  pos += sprintf(pos, ", Drunk: ");
d1417 1
a1417 1
    pos += sprintf(pos, "Off\r\n");
d1419 1
a1419 1
    pos += sprintf(pos, "%d\r\n", GET_COND(k, DRUNK));
d1429 1
a1429 1
      pos += sprintf(pos, "%s%s\r\n", buf1, found ? "," : "");
d1435 1
a1435 1
    pos += sprintf(pos, "%s\r\n", buf1);
d1444 1
a1444 1
      pos += sprintf(pos, "%s%s\r\n", buf1, found ? "," : "");
d1450 1
a1450 1
    pos += sprintf(pos, "%s\r\n", buf1);
d1453 1
a1453 1
    pos += sprintf(pos, "Guarding: %s, Guarded by: %s\r\n",
d1457 1
a1457 1
    pos += sprintf(pos, "Cornering: %s, Cornered by: %s",
d1462 2
a1463 4
  pos += sprintf(pos, "EFF: %s", CCYEL(ch, C_NRM));
  sprintflag(pos, EFF_FLAGS(k), NUM_EFF_FLAGS, effect_flags);
  pos += strlen(pos);
  pos += sprintf(pos, "\r\n%s", CCNRM(ch, C_NRM));
d1467 1
a1467 1
    pos += sprintf(pos, "Spells MEMMED: ");
d1470 3
a1472 3
      pos += sprintf(pos, "%d/%d%s", GET_MEM_MEMED(k, i),
              spells_of_circle[(int) GET_LEVEL(k)][i],
              i == 12 ? "\r\n" : " ");
d1479 2
a1480 2
      pos += sprintf(pos, "SPL: (perma) %s%-21s%s ",
              CCCYN(ch, C_NRM), skills[eff->type].name, CCNRM(ch, C_NRM));
d1482 2
a1483 2
      pos += sprintf(pos, "SPL: (%3dhr) %s%-21s%s ", eff->duration + 1,
              CCCYN(ch, C_NRM), skills[eff->type].name, CCNRM(ch, C_NRM));
d1485 2
a1486 2
      pos += sprintf(pos, "%+d to %s", eff->modifier,
              apply_types[(int) eff->location]);
d1488 2
a1489 3
      pos += sprintf(pos, "%ssets ", eff->modifier ? ", " : "");
      sprintflag(pos, eff->flags, NUM_EFF_FLAGS, effect_flags);
      pos += strlen(pos);
d1491 1
a1491 1
    pos += sprintf(pos, "\r\n");
d1500 1
a1500 1
          pos += sprintf(pos, "Quest %s: ", all_quests[a].quest_name);
d1502 1
a1502 1
            pos += sprintf(pos, "Completed\r\n");
d1504 1
a1504 1
            pos += sprintf(pos, "Failed\r\n");
d1506 1
a1506 1
            pos += sprintf(pos, "Stage %d\r\n", quest->stage);
d1518 1
a1518 1
    pos += sprintf(pos, "Events: %s", eventname(e));
d1521 1
a1521 1
      pos += sprintf(pos, " %s", eventname(e));
d1523 1
a1523 1
    pos += sprintf(pos, "\r\n");
d1525 1
a1525 1
    pos += sprintf(pos, "No events.\r\n");
d1533 2
a1534 2
      pos += sprintf(pos, "Cooldowns:\r\n");
    pos += sprintf(pos, "%25s: %d sec\r\n", cooldowns[i], GET_COOLDOWN(k, i) / PASSES_PER_SEC);
d1539 2
a1540 4
  if (IS_NPC(k)) {
    do_sstat_character(ch, pos, k);
    pos += strlen(pos);
  }
d1544 1
a1544 1
    pos += sprintf(pos, "Permanent Titles:\r\n");
d1546 1
a1546 1
      pos += sprintf(pos, "  %d) %s\r\n", i + 1, GET_PERM_TITLES(k)[i]);
d5881 3
@


1.265
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.264 2008/03/28 17:54:53 myc Exp jps $
a1208 1
  struct mgroup_type *mg;
d1442 1
a1442 1
	  ((k->groupmaster) ? GET_NAME(k->groupmaster) : "<none>"));
a1454 15
  /* Major group list */
  sprintf(buf1, "&0&1Major Group Master&0 is: %s, &0&1major groupees are:&0",
	  ((k->mgroupmaster) ? GET_NAME(k->mgroupmaster) : "<none>"));

  found = 0;
  for (mg = k->mgroupees; mg; mg = mg->next) {
    if (strlen(buf1) + strlen(PERS(mg->mgroupee, ch)) >= 78) {
      pos += sprintf(pos, "%s%s\r\n", buf1, found ? "," : "");
      *buf1 = found = 0;
    }
    sprintf(buf1, "%s%s %s", buf1, found++ ? "," : "", PERS(mg->mgroupee, ch));
  }
  if (*buf1)
    pos += sprintf(pos, "%s\r\n", buf1);

a3064 2
  void die(struct char_data *ch, struct char_data *killer);

d5889 4
@


1.264
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.263 2008/03/27 23:15:59 jps Exp myc $
d47 1
d56 1
a56 1
extern int max_group_difference; 
d99 1
a99 1
  char cBuf[MAX_INPUT_LENGTH]; 
d103 1
a103 1
  char arg[MAX_INPUT_LENGTH]; 
d111 1
a111 1
  
d115 3
a117 1
  FILE* tmp; 
d119 1
a119 3
  sprintf(tmpfile,  "/tmp/iptables.list.%d", getpid()); 
  
  argument = one_argument(argument, arg); 
d123 2
a124 2
    sprintf(cBuf3, "/sbin/iptables --list FieryMUD -v -n --line-numbers > %s", 
      tmpfile); 
d126 3
a128 3
    
    tmp = fopen(tmpfile, "rt"); 
    
d130 2
a131 2
      send_to_char(cBuf, ch); 
      send_to_char("\r\n", ch); 
d134 1
a134 1
    fclose(tmp); 
d136 1
a136 1
    sprintf(cBuf3, "rm %s", tmpfile); 
d139 2
a140 2
    one_argument(argument, arg); 
    
d192 2
a193 2
      sprintf(cBuf3, "/sbin/iptables --list FieryMUD -v -n --line-numbers > %s", 
         tmpfile); 
d195 3
a197 3
    
      tmp = fopen(tmpfile, "rt"); 
    
d220 1
a220 1
      sprintf(cBuf3, "rm %s", tmpfile); 
d222 1
a222 1
      fclose(tmp); 
d233 1
a233 1
                   buf, ports_to_open[i]); 
d243 1
a243 1
    one_argument(argument, arg); 
d247 2
a248 2
       int lineNum = 0; 
       lineNum = atoi(arg); 
d255 1
a255 1
          send_to_char("Ok.\r\n",ch); 
d259 1
a259 1
    send_to_char("Usage:  iptables [add <ip/player>|del <number>|list]\r\n", ch); 
d301 1
a301 1
  
d303 1
a303 1
  
d325 1
a325 1
  
d357 1
a357 1
  
d359 1
a359 1
  
d386 1
a386 1
  
d388 1
a388 1
  
d412 1
a412 1
  
d437 1
a437 1
  
d443 1
a443 1
  
d448 1
a448 1
  
d451 1
a451 1
  
d457 1
a457 1
  
d478 1
a478 1
  }  
d483 1
a483 1
  
d488 1
a488 1
  
d493 1
a493 1
  
d501 1
a501 1
  
d503 1
a503 1
  
d518 2
a519 1
      Crash_load(victim);
d543 1
a543 1
  
d571 1
a571 1
    
d597 1
a597 1
  
d599 1
a599 1
  
d791 1
a791 1
  struct room_effect_node *reff; 
d796 1
a796 1
  
d799 1
a799 1
  
d803 1
a803 1
  
d807 1
a807 1
  
d810 1
a810 1
  
d812 1
a812 1
  
d833 1
a833 1
  
d839 1
a839 1
      sprintf(buf2, "%s%s %s", buf2, found++ ? "," : "", 
d846 1
a846 1
    
d868 1
a868 1
  
d941 1
a941 1
  
d962 1
a962 1
  pos += sprintf(pos, "L-Des: %s\r\n", j->description ? j->description : 
d972 1
a972 1
  
d981 1
a981 1
  
d986 1
a986 1
  
d995 1
a995 1
  
d1001 1
a1001 1
      pos += sprintf(pos, "Hours left: [%d]  Initial hours: [%d]\r\n", 
d1022 1
a1022 1
            attack_hit_text[GET_OBJ_VAL(j, 3)].singular : 
d1041 2
a1042 2
	      "Corpse: %s, Raisable: %s\r\n", GET_OBJ_VAL(j,0), GET_OBJ_VAL(j,2), 
	      YESNO(GET_OBJ_VAL(j,3)), YESNO(IS_PLR_CORPSE(j)), 
d1092 1
a1092 1
  
d1097 1
a1097 1
  
d1101 1
a1101 1
      sprintf(buf1, "%s%s %s", buf1, found++ ? "," : "", 
d1108 1
a1108 1
    
d1209 1
a1209 1
  struct mgroup_type *mg;  
d1215 1
a1215 1
  
d1222 1
a1222 1
          GET_NAME(k), GET_IDNUM(k), 
d1237 2
a1238 2
  
  
d1248 1
a1248 1
  pos += sprintf(pos, 
d1258 1
a1258 1
  
d1309 1
a1309 1
  
d1315 1
a1315 1
  
d1326 1
a1326 1
  
d1368 1
a1368 1
  
d1394 1
a1394 1
  
d1407 1
a1407 1
  
d1455 1
a1455 1
  
d1459 1
a1459 1
  
d1472 1
a1472 1
    pos += sprintf(pos, "Guarding: %s, Guarded by: %s\r\n", 
d1485 1
a1485 1
  
d1495 2
a1496 2
  
  
d1582 1
a1582 1
  
d1584 1
a1584 1
  
d1669 1
a1669 1
  
d1675 1
a1675 1
  
d1710 1
a1710 1
    
d1743 1
a1743 1
  
d1746 1
a1746 1
  
d1748 1
a1748 1
  
d1766 1
a1766 1
    
d1772 1
a1772 1
    
d1775 1
a1775 1
    
d1784 1
a1784 1
  
d1786 1
a1786 1
  
d1800 1
a1800 1
    send_to_char("You WISHED.\r\n",ch);   
d1803 1
a1803 1
    
d1806 1
a1806 1
    
d1824 1
a1824 1
  
d1827 1
a1827 1
  
d1839 1
a1839 1
  
d1881 1
a1881 1
    
d1886 1
a1886 1
    
d1889 1
a1889 1
    
d1904 1
a1904 1
  
d1906 1
a1906 1
  
d1922 1
a1922 1
    
d1927 1
a1927 1
    sprintf(buf, "(GC) %s loads mob,  %s", GET_NAME(ch), GET_NAME(mob)); 
d1954 1
a1954 1
  
d1956 1
a1956 1
  
d2085 1
a2085 1
                        color, player_table[i].name, 
d2104 1
a2104 1
  
d2106 1
a2106 1
  
d2130 1
a2130 1
    }    
d2140 1
a2140 1
    }    
d2157 1
a2157 1
  
d2159 1
a2159 1
  
d2170 1
a2170 1
   * I don't know which wise guy commented out this next check, but if 
d2189 3
a2191 3
  }  
  
  
d2226 1
a2226 1
  
d2248 1
a2248 1
  
d2256 1
a2256 1
  
d2279 1
a2279 1
    
d2288 1
a2288 1
  
d2339 1
a2339 1
  
d2345 1
a2345 1
  
d2355 1
a2355 1
  
d2358 1
a2358 1
  
d2374 1
a2374 1
  
d2429 1
a2429 1
  switch (subcmd) 
d2449 1
a2449 1
  default: 
d2453 1
a2453 1
  
d2523 1
a2523 1
  
d2780 1
a2780 1
  for (d = descriptor_list; d; d = d->next) 
d2810 1
a2810 1
 
d2828 1
a2828 1
      
d2940 1
a2940 1
    for (d = descriptor_list; d; d = d->next) 
d2955 1
a2955 1
      send_to_char(buffer, ch); 
d2974 1
a2974 1
  
d3177 1
a3177 1
	if (MOB_FLAGGED(vict, MOB_ANIMATED) && 
d3180 1
a3180 1
	      0, TO_ROOM);	  
d3399 1
a3399 1
                     GET_NAME(vict), genders[(int) GET_SEX(vict)], 
d3402 1
a3402 1
                     GET_BANK_PLAT(vict), GET_BANK_GOLD(vict), 
d3584 1
a3584 1
            sprintf(buf, "%s %-*.*s   %-8s  %5d    %-8.8s  %d/%d\r\n", buf, 
d3730 1
a3730 1
   { "gold",         LVL_GOD,         BOTH, NUMBER },   
d3735 1
a3735 1
   { "sbank",        LVL_ATTENDANT,   PC,   NUMBER },  
d3743 1
a3743 1
   { "chant",        LVL_GAMEMASTER,  PC,   NUMBER },   
d3775 1
a3775 1
	sprintf(buf2, "%s%-20.20s %-20.20s %-6.6s\r\n", buf2, fields[l].cmd, 
d4218 1
a4218 1
    
d4229 1
a4229 1
    break;  
d4402 2
a4403 2
 
 
d4407 1
a4407 1
 
d4411 1
a4411 1
 
d4444 1
a4444 1
  extern time_t boot_time; 
d4451 1
a4451 1
  
d4454 1
a4454 1
  
d4456 2
a4457 2
  
  
d4459 1
a4459 1
  
d4462 1
a4462 1
  
d4467 1
a4467 1
  
d4471 1
a4471 1
  
d4509 2
a4510 2
    { "RACES", 0,     &races_allowed,         LVL_ADMIN, 
      "[&2&bSYS: %s allows race logins&0]\r\n", 
d4514 1
a4514 1
    { "EVILRACES",0, &evil_races_allowed,    LVL_ADMIN, 
d4519 1
a4519 1
    { "PK",     0,    &pk_allowed,            LVL_ADMIN, 
d4524 1
a4524 1
    { "SLEEP",  0,    &sleep_allowed,         LVL_ADMIN, 
d4529 1
a4529 1
    { "SUMMON", 0,  &summon_allowed,        LVL_ADMIN, 
d4534 1
a4534 1
    { "CHARM",  0,  &charm_allowed,         LVL_ADMIN, 
d4539 1
a4539 1
    { "ROOMEFFECT",0, &roomeffect_allowed,    LVL_ADMIN, 
d4544 1
a4544 1
    { "NAMES",  0,  &approve_names,         LVL_ADMIN, 
d4574 1
a4574 1
    { "GROUPING", 1, &max_group_difference, LVL_ATTENDANT, 
d4576 1
a4576 1
      "[&1&bSYS: %s turned off the max group level difference.&0]\r\n", 
d4579 1
a4579 1
      
d4584 1
a4584 1
  
d4586 1
a4586 1
    if ((GET_LEVEL(ch) >= commands[i].min_level) && 
d4597 1
a4597 1
	sprintf(shortbuf, "[%s%s&0]", *commands[i].config ? "&2&b" : "&1&b", 
d4602 2
a4603 2
	  sprintf(linebuf, "%-19s%s %i\r\n", shortbuf, *commands[i].config ? 
		  commands[i].enabled : commands[i].disabled, 
d4607 1
a4607 1
	  sprintf(linebuf, "%-19s%s\r\n", shortbuf, *commands[i].config ? 
d4609 1
a4609 1
	  
d4622 3
a4624 3
    sscanf(rest, "%i", &value); 
    *commands[i].config = value; 
    msg = ((value ? commands[i].turn_on : commands[i].turn_off)); 
d4628 2
a4629 2
  
    /* if we've gotten this far then the field was recognized and of suitable 
d4631 1
a4631 1
  msg = ((*commands[i].config = !*commands[i].config) ? commands[i].turn_on : 
d4633 1
a4633 1
  
d4637 1
a4637 1
    
d4639 1
a4639 1
    send_to_imms(linebuf); 
d4641 1
a4641 1
    
d4644 1
a4644 1
  };   
d4862 1
a4862 1
    
d4883 1
a4883 1
 
d4888 1
a4888 1
    
d4893 1
a4893 1
    
d4895 1
a4895 1
 
d4914 1
a4914 1
    
d4919 1
a4919 1
    
d4924 1
a4924 1
 
d4937 1
a4937 1
  
d4940 1
a4940 1
  
d4945 2
a4946 2
  
  one_argument(argument, buf2); 
d4948 1
a4948 1
  
d4950 1
a4950 1
  
d4954 1
a4954 1
  
d4956 1
a4956 1
    send_to_char("Format: copyto <room number>\r\n", ch); 
d4962 1
a4962 1
  
d4964 1
a4964 1
  
d4967 1
a4967 1
    
d4970 1
a4970 1
  
d4988 1
a4988 1
   two_arguments(argument, buf2, buf3); 
d4995 1
a4995 1
    send_to_char("Format: dig <dir> <room number>\r\n", ch); 
d4998 1
a4998 1
    send_to_char("Format: dig <dir> <room number>\r\n", ch); 
d5031 1
a5031 1
CREATE(world[rroom].dir_option[rev_dir[dir]], struct room_direction_data,1); 
d5034 1
a5034 1
  world[rroom].dir_option[rev_dir[dir]]->to_room = ch->in_room; 
d5036 1
a5036 1
CREATE(world[ch->in_room].dir_option[dir], struct room_direction_data,1); 
d5039 1
a5039 1
  world[ch->in_room].dir_option[dir]->to_room = rroom; 
d5090 1
a5090 1
  one_argument(argument, buf2); 
d5092 1
a5092 1
    send_to_char("Format: hhroom <room number>\r\n", ch); 
d5132 1
a5132 1
  
d5200 1
a5200 1
   if (!strcmp(GET_NAME(ch), "Zzur")) 
d5207 1
a5207 1
/* David Endre 2/23/99 To view basic files online */ 
d5253 1
a5253 1
      
d5284 1
a5284 1
  
d5297 1
a5297 1
  
d5311 2
a5312 2
   
   
d5344 1
a5344 1
  
d5396 1
a5396 1
    
d5398 1
a5398 1
    if (!player_table[i].id || player_table[i].id == GET_IDNUM(ch) || 
d5403 1
a5403 1
      sprintf(buf, "PFILEMAINT: %ld Player [%s] DELETED: %s.", 
d5407 1
a5407 1
	sprintf(buf, "PFILEMAINT: Level %d Idle: %d days.", 
d5423 1
a5423 1
  
d5433 1
a5433 1
  
d5457 1
a5457 1
   * in OLC, a warning will be shown, and no hotboot will occur.  
d5480 1
a5480 1
              d->character && GET_NAME(d->character) ? 
d5816 1
a5816 1
         sprintf(buf, "* &3SKIPPING&0 %s who has no objects file\r\n", 
d5907 4
d6772 1
a6772 1
 * 
d6874 1
a6874 1
 * This fixes all of the warnings associated with the new compiler and 
d6886 1
a6886 1
 * by Zantir. 
d6892 2
a6893 2
 * Fixed a silly overflow in do_players.  Once the length of all the 
 * player's names exceeded the bufffer length boom!  Now you must type a 
d6913 1
a6913 1
 * 
@


1.263
log
@Don't treat missing object save files as an error.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.262 2008/03/27 22:57:37 jps Exp jps $
d64 1
a64 1
extern int roomaffect_allowed;
d277 1
a277 1
      if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d339 4
a342 3
    if ((!d->connected) && (GET_LEVEL(d->character) >= LVL_IMMORT) &&
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
        && (d != ch->desc)) {
a343 1
    }
d789 1
a789 1
  struct raff_node *raff; 
d802 1
a802 1
  sprintbit((long) rm->room_flags, room_bits, buf2);
d806 2
a807 2
  sprintbit((long) rm->room_affections, room_affections, buf2);
  pos += sprintf(pos, "Room affections: %s\r\n", buf2);
d867 4
a870 4
  /* Mention spells/affectations */
  for (raff = raff_list; raff; raff = raff->next) {
     if (raff->room == rrnum) {
        sprintbit(raff->affection, room_affections, buf2);
d872 1
a872 1
              raff->timer, skills[raff->spell].name, buf2);
d976 2
a977 7
  if (GET_OBJ_SPELL(j))
    sprintbit(GET_OBJ_SPELL(j), affected_bits, buf1);
  if (GET_OBJ_SPELL2(j))
    sprintbit(GET_OBJ_SPELL2(j), affected_bits2, buf1 + strlen(buf1));
  if (GET_OBJ_SPELL3(j) || !(GET_OBJ_SPELL(j) || GET_OBJ_SPELL2(j)))
    sprintbit(GET_OBJ_SPELL3(j), affected_bits3, buf1 + strlen(buf1));
  pos += sprintf(pos, "Spell Affects : %s%s%s\r\n",
d1113 4
a1116 4
  pos += sprintf(pos, "Affections:");
  for (i = 0; i < MAX_OBJ_AFFECT; i++)
    if (j->affected[i].location) {
      sprinttype(j->affected[i].location, apply_types, buf2);
d1118 1
a1118 1
            format_apply(j->affected[i].location, j->affected[i].modifier));
d1209 1
a1209 1
  struct affected_type *aff;
d1382 1
a1382 4
    if (MOB_FLAGS(k) || !MOB2_FLAGS(k))
      sprintbit(MOB_FLAGS(k), action_bits, buf1);
    if (MOB2_FLAGS(k))
      sprintbit(MOB2_FLAGS(k), action_bits2, buf1 + strlen(buf1));
d1387 1
a1387 1
    sprintbit(PLR_FLAGS(k), player_bits, buf2);
d1389 1
a1389 1
    sprintbit(PRF_FLAGS(k), preference_bits, buf2);
d1478 4
a1481 14
  /* Affection bitvectors */
  pos += sprintf(pos, "AFF: %s", CCYEL(ch, C_NRM));
  if (AFF_FLAGS(k)) {
    sprintbit(AFF_FLAGS(k), affected_bits, pos);
    pos += strlen(pos);
  }
  if (AFF2_FLAGS(k)) {
    sprintbit(AFF2_FLAGS(k), affected_bits2, pos);
    pos += strlen(pos);
  }
  if (AFF3_FLAGS(k) || !(AFF_FLAGS(k) || AFF2_FLAGS(k))) {
    sprintbit(AFF3_FLAGS(k), affected_bits3, pos);
    pos += strlen(pos);
  }
d1496 14
a1509 26
  if (k->affected)
    for (aff = k->affected; aff; aff = aff->next) {
      if (aff->duration <  0)
        pos += sprintf(pos, "SPL: (perma) %s%-21s%s ",
                CCCYN(ch, C_NRM), skills[aff->type].name, CCNRM(ch, C_NRM));
      else
        pos += sprintf(pos, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
                CCCYN(ch, C_NRM), skills[aff->type].name, CCNRM(ch, C_NRM));
      if (aff->modifier)
        pos += sprintf(pos, "%+d to %s", aff->modifier,
                apply_types[(int) aff->location]);
      if (aff->bitvector || aff->bitvector2 || aff->bitvector3)
        pos += sprintf(pos, "%ssets ", aff->modifier ? ", " : "");
      if (aff->bitvector) {
        sprintbit(aff->bitvector, affected_bits, pos);
        pos += strlen(pos);
      }
      if (aff->bitvector2) {
        sprintbit(aff->bitvector2, affected_bits2, pos);
        pos += strlen(pos);
      }
      if (aff->bitvector3) {
	sprintbit(aff->bitvector3, affected_bits3, pos);
        pos += strlen(pos);
      }
      pos += sprintf(pos, "\r\n");
d1511 2
d1809 1
a1809 1
      GET_PROMPT(victim) = str_dup(GET_PROMPT(ch));
d2227 7
a2233 7
    REMOVE_BIT(PRF_FLAGS(victim), PRF_LOG1);
    REMOVE_BIT(PLR_FLAGS(victim), PRF_LOG2);
    REMOVE_BIT(PRF_FLAGS(victim), PRF_NOHASSLE);
    REMOVE_BIT(PLR_FLAGS(victim), PRF_HOLYLIGHT);
    REMOVE_BIT(PLR_FLAGS(victim), PRF_SHOWVNUMS);
    REMOVE_BIT(PLR_FLAGS(victim), PRF_ROOMVIS);
    REMOVE_BIT(PLR_FLAGS(victim), PRF_ROOMVIS);
d2236 3
a2238 3
    SET_BIT(PRF_FLAGS(victim), PRF_HOLYLIGHT);
    SET_BIT(PRF_FLAGS(victim), PRF_SHOWVNUMS);
    SET_BIT(PRF_FLAGS(victim), PRF_AUTOEXIT);
d2301 1
a2301 1
         affect_total(vict);
d2338 2
a2339 2
  if (GET_INVIS_LEV(ch) == 0 && !AFF_FLAGGED(ch, AFF_INVISIBLE) &&
      !IS_HIDDEN(ch) && !AFF3_FLAGGED(ch, AFF3_CAMOUFLAGED)) {
d2748 1
a2748 1
    if (STATE(d) != CON_PLAYING || PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
d2781 1
a2781 1
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING)))
d2846 1
a2846 1
        REMOVE_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
d2855 1
a2855 1
           REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d2911 1
a2911 1
	 SET_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d3104 1
a3104 1
      if (!PLR_FLAGGED(vict, PLR_THIEF | PLR_KILLER)) {
d3108 2
a3109 1
      REMOVE_BIT(PLR_FLAGS(vict), PLR_THIEF | PLR_KILLER);
d3140 1
a3140 1
      SET_BIT(PLR_FLAGS(vict), PLR_FROZEN);
d3161 1
a3161 1
      REMOVE_BIT(PLR_FLAGS(vict), PLR_FROZEN);
d3167 3
a3169 3
      if (vict->affected) {
	while (vict->affected)
	  affect_remove(vict, vict->affected);
d3176 1
a3176 1
	    !IS_AFFECTED3(vict, AFF3_ANIMATED)) {
d3183 1
a3183 1
	send_to_char("Your victim does not have any affections!\r\n", ch);
d3485 1
a3485 1
               if (IS_SET(ROOM_FLAGS(rrn), ROOM_DEATH))
d3501 1
a3501 1
               if (IS_SET(ROOM_FLAGS(rrn), ROOM_GODROOM))
d3651 3
a3653 3
#define SET_OR_REMOVE(flagset, flags) { \
	if (on) SET_BIT(flagset, flags); \
	else if (off) REMOVE_BIT(flagset, flags); }
d3867 1
a3867 1
    affect_total(vict);
d3871 1
a3871 1
    affect_total(vict);
d3875 1
a3875 1
    affect_total(vict);
d3879 1
a3879 1
    affect_total(vict);
d3883 1
a3883 1
    affect_total(vict);
d3887 1
a3887 1
    affect_total(vict);
d3892 1
a3892 1
    affect_total(vict);
d3900 1
a3900 1
    affect_total(vict);
d3907 1
a3907 1
    affect_total(vict);
d3913 1
a3913 1
    affect_total(vict);
d3918 1
a3918 1
    affect_total(vict);
d3924 1
a3924 1
    affect_total(vict);
d3941 1
a3941 1
    affect_total(vict);
d3977 1
a3977 1
    affect_total(vict);
d3981 1
a3981 1
    affect_total(vict);
d4102 1
a4102 1
      REMOVE_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
d4106 1
a4106 1
        SET_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
d4120 2
a4121 1
    SET_OR_REMOVE(PRF_FLAGS(vict), (PRF_COLOR_1 | PRF_COLOR_2));
d4156 1
a4156 1
    affect_total(vict);
d4390 6
a4395 2
  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG1 | PRF_LOG2);
  SET_BIT(PRF_FLAGS(ch), (PRF_LOG1 * (tp & 1)) | (PRF_LOG2 * (tp & 2) >> 1));
d4537 5
a4541 5
    { "ROOMAFFECT",0, &roomaffect_allowed,    LVL_ADMIN, 
      "[&2&bSYS: %s allows room affect spells to hurt other players&0]\r\n",
      "[&1&bSYS: %s disallows room affect spells from hurting other players&0]\r\n",
      "Room affect spells will hurt other players",
      "Room affect spells will not hurt other players" },
d4927 1
a4927 1
    ch->desc->storage = str_dup(fields[l].filename);
d4929 1
a4929 1
    SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
d4964 1
a4964 1
    world[rroom].description = str_dup(world[ch->in_room].description);
d5085 1
a5085 1
  int vroom, rroom;
d5106 1
a5106 1
    world[rroom].description = str_dup(world[ch->in_room].description);
d5108 1
a5108 1
    world[rroom].name = str_dup(world[ch->in_room].name);
d5110 2
a5111 1
    world[rroom].room_flags = world[ch->in_room].room_flags;
d5157 1
a5157 1
    SET_BIT(PLR_FLAGS(victim), PLR_DELETED);
d5179 1
a5179 1
       SET_BIT(PLR_FLAGS(cbuf), PLR_DELETED);
d5669 1
a5669 1
/* fix_objfile_aff()
d5692 1
a5692 1
int fix_objfile_aff(struct char_data *ch, char *filename)
d5765 3
a5767 3
         object.spell_flags = obj_proto[rnum].obj_flags.spell_flags;
         object.spell_flags2 = obj_proto[rnum].obj_flags.spell_flags2;
         object.spell_flags3 = obj_proto[rnum].obj_flags.spell_flags3;
d5799 1
a5799 1
void fix_objfile_affs(struct char_data *ch)
d5818 1
a5818 1
      } else if (fix_objfile_aff(ch, fname)) {
d5876 1
a5876 1
      fix_objfile_affs(ch);
d5892 1
a5892 1
      if (fix_objfile_aff(ch, fname)) {
d5905 3
@


1.262
log
@Added objfix command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.261 2008/03/25 22:01:16 jps Exp jps $
d5823 1
a5823 1
   int successes = 0, errs = 0, failures = 0, i;
d5834 6
a5839 2

      if (fix_objfile_aff(ch, fname)) {
d5841 1
d5845 1
a5847 2
      page_string(ch->desc, buf, 1);

d5856 2
d5908 4
d5926 3
@


1.261
log
@Updating show composition/lifeforces.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.260 2008/03/24 03:58:45 jps Exp jps $
d5690 224
d5916 3
@


1.260
log
@Fix formatting of 'show compositions'.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.259 2008/03/23 18:40:35 jps Exp jps $
d3329 1
a3329 1
               "Idx  Composition  %sSlash&0  %sPierce&0  %sCrush&0  %sEarth&0   %sAir&0  %sFire&0  %sWater&0  %sAcid&0  %sPoison&0  %sMagic&0\r\n",
d3333 1
a3333 2
               damtypes[DAM_EARTH].color,
               damtypes[DAM_AIR].color,
d3336 1
d3351 1
a3351 2
                  compositions[i].sus_earth,
                  compositions[i].sus_air,
d3354 1
d3364 1
a3364 1
         sprintf(buf, "Idx  Life force   %sHeal&0  %sDisc.&0  %sDispel&0\r\n",
d3367 2
a3368 1
               damtypes[DAM_DISPEL].color);
d3370 1
a3370 1
         send_to_char("---  -----------  ----  -----  ------\r\n", ch);
d3373 1
a3373 1
                  "% 2d.  %s%c%-10s  % 4d  % 5d  % 6d&0\r\n",
d3378 2
a3379 1
                  lifeforces[i].sus_dispel
d5692 3
@


1.259
log
@show lifeforces and show compositions include damage susceptibilities.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.258 2008/03/23 00:27:01 jps Exp jps $
d3345 1
a3345 1
                  "% 2d.  %s%c%-10s  % 5d  % 6d  % 5d  % 5d  % 4d  % 4d  % 5d  % 4d  % 6d  % 5d&0\r\n",
d5690 3
@


1.258
log
@Update set <foo> composition for having a base composition.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.257 2008/03/22 20:25:31 jps Exp jps $
d3328 15
d3344 15
a3358 2
            sprintf(buf, "% 2d.  %s%c%s&0\r\n", i, compositions[i].color,
                  UPPER(*(compositions[i].name)), compositions[i].name + 1);
d3364 6
d3371 8
a3378 2
            sprintf(buf, "% 2d.  %s%c%s&0\r\n", i, lifeforces[i].color,
                  UPPER(*(lifeforces[i].name)), lifeforces[i].name + 1);
d5690 3
@


1.257
log
@Add life force and composition to do_set.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.256 2008/03/22 19:57:59 jps Exp jps $
d1120 1
a1120 1
    if (j->affected[i].modifier) {
d1122 2
a1123 2
      pos += sprintf(pos, "%s %+d to %s", found++ ? "," : "",
	      j->affected[i].modifier, buf2);
d4308 1
a4308 1
    if (i == GET_COMPOSITION(vict)) {
d4310 1
a4310 1
           vict == ch ? "You're" : "$e's", COMPOSITION_NAME(vict));
d4319 1
a4319 1
      convert_composition(vict, i);
d5650 3
@


1.256
log
@Printing lifeforce and composition in do_stat_char.
Added lifeforce and composition to do_show.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.255 2008/03/22 03:22:38 myc Exp jps $
d3733 2
d4280 44
d5650 4
@


1.255
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.254 2008/03/21 15:01:17 myc Exp myc $
d1253 1
d1256 2
d3253 2
d3275 1
d3283 1
d3327 16
d5604 6
@


1.254
log
@Removed languages.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.253 2008/03/20 23:26:14 jps Exp myc $
d4837 1
a4837 8
    ch->desc->backstr = NULL;
    if (fields[l].buffer) {
       send_to_char(*fields[l].buffer, ch);
       ch->desc->backstr = str_dup(*fields[l].buffer);
    }
    ch->desc->str = fields[l].buffer;
    ch->desc->max_str = fields[l].size;
    ch->desc->mail_to = 0;
d5581 3
@


1.253
log
@Removing unused prototype for Obj_from_store_to.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.252 2008/03/19 04:32:14 myc Exp jps $
d265 2
a266 3
  char ibuf[MAX_INPUT_LENGTH];
  char obuf[MAX_INPUT_LENGTH];
  struct char_data *tch;
d268 1
a268 2
  
  
a270 1

d272 6
a277 8

    if(GET_LEVEL(ch) < LVL_IMMORT)
      if(strchr(argument, '&'))  {
	send_to_char("No ampersand sign allowed in input.\r\n", ch);
	return;
      }
    if (subcmd == SCMD_EMOTE){
      if(AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d281 8
a288 31
      strcpy(ibuf, argument);     /* save real message */
#ifdef LANGUAGES
      if (!IS_NPC(ch))
	garble_text(ibuf, GET_SKILL(ch, SPEAKING(ch)));
#endif
      
      for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
	if (tch != ch && AWAKE(tch) && tch->desc) {
	  
	  strcpy(obuf, ibuf);     /* preserve the first garble */
#ifdef LANGUAGES
	  if (!IS_NPC(ch))
	    garble_text(obuf, GET_SKILL(tch, SPEAKING(ch)));
#endif
	  
	  if ((GET_SKILL(tch, SPEAKING(ch)) < 1) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) &&
	      (GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0",  obuf);
	  else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_AFFECTED(tch, AFF_COMP_LANG)) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0", obuf);
	  else if ((GET_LEVEL(ch) < LVL_GOD) && (!IS_NPC(ch)))
	    sprintf(buf, "$n %s&0", argument);
	  else
	    sprintf(buf, "$n %s&0", argument);
	  act(buf, TRUE, ch, 0, tch, TO_VICT);
	  
	}
      }
    }else{
      strcpy(buf, argument);
      act(buf, FALSE, ch, 0, 0, TO_ROOM);}
d291 2
a292 5
    else {
      strcpy(buf, argument);
      sprintf(buf2, "$n %s", buf);
      act(buf2, FALSE, ch, 0, 0, TO_CHAR);
    }
d3540 2
a3541 2
         strcpy(buf, "Race              Humanoid  Align    Size      Language     HR/DR\r\n"
                     "----------------  --------  -------  --------  -----------  ------\r\n");
d3544 1
a3544 1
            sprintf(buf, "%s %-*.*s   %-8s  %5d    %-8.8s  %-11.11s  %d/%d\r\n", buf, 
a3547 1
                    skills[races[i].def_lang].name,
a5037 163
void set_innate(struct char_data * ch, char *arg)
{
  struct affected_type *aff=NULL;
  int found=FALSE;

if(!arg){
	mudlog("NO ARG FOR INNATE", NRM, LVL_GOD, TRUE);
	return;}

if (ch->affected) {
    for (aff = ch->affected; aff && !found; aff = aff->next) {
        if  (is_abbrev(arg, skills[aff->type].name))
           found=TRUE;
    }
  }

for (aff = ch->affected; aff; aff = aff->next) {
        if  (is_abbrev(arg, skills[aff->type].name))
         aff->duration=-1;  
       mudlog("INNATES SET", NRM, LVL_GOD, TRUE);
    }}

ACMD(do_speak)
{
  extern char *proficiency_message(int proficiency);
  int i = MIN_LANGUAGE;
  int ofs = 190;
 
  skip_spaces(&argument);
  
  if (!*argument) {
    
    strcpy(buf, "You know of the following languages:\r\n");
    strcpy(buf2, buf);
    
	for (i = MIN_LANGUAGE +1; i < MAX_LANGUAGE+1; i++)
	  {
	    if (GET_SKILL(ch, i) > 0)
	      {
		sprintf(buf, "%-20s (%s)\r\n", languages[(i - ofs)] , proficiency_message(GET_ISKILL(ch, i)));
		strcat(buf2, buf);
	      }
	  }
	page_string(ch->desc, buf2, 1); 
  }else{
  
    if (is_abbrev(argument, "common")){
      if (GET_SKILL(ch, LANG_COMMON) > 0){
	SPEAKING(ch) = LANG_COMMON;
	send_to_char(OK, ch);
	return;
      }else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
      }
    }else if (is_abbrev(argument, "dwarven")){
      if(GET_SKILL(ch, LANG_DWARVEN) > 0){
	SPEAKING(ch) = LANG_DWARVEN;
	send_to_char(OK, ch);
	return;
      }else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
      }
    }else if (is_abbrev(argument, "elven")){
      if(GET_SKILL(ch, LANG_ELVEN) > 0){
	SPEAKING(ch) = LANG_ELVEN;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "halfling")){
      if(GET_SKILL(ch, LANG_HALFLING) > 0){
	SPEAKING(ch) = LANG_HALFLING;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "gnomish")){
      if(GET_SKILL(ch, LANG_GNOMISH) > 0){
	SPEAKING(ch) = LANG_GNOMISH;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "barbarian")){
      if(GET_SKILL(ch, LANG_BARBARIAN) > 0){
	SPEAKING(ch) = LANG_BARBARIAN;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "drow")){
      if(GET_SKILL(ch, LANG_DROW) > 0){
	SPEAKING(ch) = LANG_DROW;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "trollish")){
      if(GET_SKILL(ch, LANG_TROLLISH) > 0){
	SPEAKING(ch) = LANG_TROLLISH;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "duergar")){
      if(GET_SKILL(ch, LANG_DUERGAR) > 0){
	SPEAKING(ch) = LANG_DUERGAR;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "ogre")){
      if(GET_SKILL(ch, LANG_OGRE) > 0){
	SPEAKING(ch) = LANG_OGRE;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else if (is_abbrev(argument, "orcish")){
      if(GET_SKILL(ch, LANG_ORCISH) > 0){
	SPEAKING(ch) = LANG_ORCISH;
	send_to_char(OK, ch);
	return;
      }else{
	sprintf(buf, "&0You can not speak that language well enough.\r\n");
	send_to_char(buf, ch);
	return;
      }
    }else
      send_to_char("That is not a valid language.\r\n", ch);
  }
}



d5588 3
@


1.252
log
@Fixed do_last, which was using GET_ID instead of GET_IDNUM.  Fixed
a couple typoes with send_to_chars missing newlines.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.251 2008/03/13 16:43:04 myc Exp myc $
a5668 2
   struct obj_data *Obj_from_store_to(struct obj_file_elem object, int *locate);

d5783 4
@


1.251
log
@Carraige return for cooldowns in do_stat.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.250 2008/03/11 19:50:55 myc Exp myc $
d2652 1
a2652 1
      GET_ID(victim), GET_LEVEL(victim),
d2958 1
a2958 1
         sprintf(buf, "The name:%s has been declined by %s, reason %d.", GET_NAME(d->character), GET_NAME(ch), choice+1);
d4100 1
a4100 1
	sprintf(buf, "%s will enter at room #%d.", GET_NAME(vict),
d4103 1
a4103 1
	strcpy(buf, "That room does not exist!");
d4135 1
a4135 1
      sprintf(buf, "Password changed to '%s'.", val_arg);
d4288 1
a4288 1
    sprintf(buf, "Can't set that!");
d5785 3
@


1.250
log
@Change the way allowed olc zones are saved on an immortal from a
fixed number of slots to a variable-length linked list.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.249 2008/03/11 03:02:26 jps Exp myc $
d1610 1
a1610 1
    pos += sprintf(pos, "%25s: %d sec\n", cooldowns[i], GET_COOLDOWN(k, i) / PASSES_PER_SEC);
d5785 4
@


1.249
log
@do_show will provide an error message if you try to show something
that it doesn't recognize.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.248 2008/03/11 02:57:58 jps Exp jps $
d1313 8
a1320 5
    if (GET_LEVEL(k) >= LVL_IMMORT)
      pos += sprintf(pos, ", OLC Zones: [%d/%d/%d/%d/%d]",
	      GET_OLC_ZONE(k), GET_OLC2_ZONE(k),
              GET_OLC3_ZONE(k), GET_OLC4_ZONE(k),
              GET_OLC5_ZONE(k));
d2115 2
d2120 1
a2120 1
    if (*player_table[i].name == *arg) {
d2297 2
a2298 1
    GET_OLC_ZONE(victim) = NOWHERE;
d3051 3
a3053 6
  if ((GET_LEVEL(ch) < LVL_GRGOD) &&
      (!((zone_table[i].number == GET_OLC_ZONE(ch)) || (zone_table[i].number == GET_OLC2_ZONE(ch))
	  || (zone_table[i].number == GET_OLC3_ZONE(ch))  || (zone_table[i].number == GET_OLC4_ZONE(ch)) || 
	  (zone_table[i].number == GET_OLC5_ZONE(ch))))) {
   send_to_char("Testing testing !!are you clear to do this!! no I dont think so\r\n", ch);
  return;
d3935 26
a3960 3
    case 19:
	  GET_OLC_ZONE(vict) = value;
	  break;
d3962 2
a3963 2
	  GET_HOME(vict) = value;
	  break;
d4001 1
a4001 1
    GET_PRACTICES(vict) = RANGE(0, 100);
d4172 1
a4172 1
    GET_OLC2_ZONE(vict) = value;
d4175 1
a4175 1
    GET_OLC3_ZONE(vict) = value;
d4178 1
a4178 1
    GET_OLC4_ZONE(vict) = value;
d4181 1
a4181 1
    GET_OLC5_ZONE(vict) = value;
d5785 4
@


1.248
log
@Add "sizes" to do_show. "set <char> size" (alone) will get you a
list of sizes.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.247 2008/03/10 20:46:55 myc Exp jps $
d3314 1
a3314 1
      { "\n", 0 }
d3628 1
a3628 1
         send_to_char("Sorry, I don't understand that.\r\n", ch);
d5759 4
@


1.247
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.246 2008/03/10 19:55:37 jps Exp myc $
d3277 1
d3310 1
d3623 4
d4209 2
a4210 1
    if ((value = parse_size(ch, val_arg)) == SIZE_UNDEFINED) {
d4212 5
d4219 1
a4219 1
    change_size(vict, value);
d5759 3
@


1.246
log
@Made a struct for sizes with name, height, and weight.  Save base height
weight and size so they stay the same over size changes.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.245 2008/03/10 18:18:32 myc Exp jps $
d1297 1
a1297 1
            "Age: [%d], Hometown: [%d], Speaks: [%d/%d/%d]",
d1300 1
a1300 1
            age(k).year, k->player.hometown, GET_TALK(k, 0),
d1367 1
a1367 1
  sprinttype(GET_POS1(k), posture_types, buf2);
d5747 4
@


1.245
log
@You can now use the set command to change a character's height
(in inches) or weight (in pounds).
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.244 2008/03/10 18:01:17 myc Exp myc $
d3573 1
a3573 1
                    sizes[races[i].def_size + 1], 
d4203 1
a4203 2
    if ((value = search_block(val_arg, sizes, FALSE) - 1) < 0) {
      strcpy(buf, "Invalid size.\r\n");
d4205 1
d4207 5
a4211 7
    else {
      GET_SIZE(vict) = RANGE(SIZE_SMALL, SIZE_COLOSSAL);
      sprintf(buf, "%s %s now %s in size.\r\n",
              ch == vict ? "You" : GET_NAME(vict),
              ch == vict ? "are" : "is",
              sizes[(int) GET_SIZE(vict) + 1]);
    }
d5747 4
@


1.244
log
@Making stat char show posture in addition to position.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.243 2008/03/09 06:38:37 jps Exp myc $
d3731 2
d4245 6
d5749 3
@


1.243
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.242 2008/03/08 23:48:03 jps Exp jps $
d1367 2
a1368 1
  pos += sprintf(pos, "Pos: %s", buf1);
d5741 5
@


1.242
log
@Forgot carriage returns in pscan.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.241 2008/03/08 23:20:06 myc Exp jps $
d1262 1
a1262 1
            k->player.name, GET_MOB_VNUM(k), GET_MOB_RNUM(k));
d2883 1
a2883 1
	   (strn_cmp(d->character->player.name, arg, strlen(arg)) == 0)))
d2949 1
a2949 1
         (strn_cmp(d->character->player.name, arg, strlen(arg)) == 0))
d2955 1
a2955 1
         send_to_xnames(d->character->player.name);
d5740 3
@


1.241
log
@List cooldowns before scripts on stat.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.240 2008/03/08 22:29:06 myc Exp myc $
d5674 1
a5674 1
         sprintf(buf, "%-15s  %3d\n", player_table[i].name, objectshere);
d5690 1
a5690 1
      sprintf(buf, "\n(%d error%s occurred during scan)\n",
d5740 3
@


1.240
log
@Moving shapechange and chant to the cooldown systems.  Cooldowns
are now listed on stat.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.239 2008/03/08 20:18:09 jps Exp myc $
d1178 1
a1178 1
  
a1599 6
  /* Check mobiles for a script */
  if (IS_NPC(k)) {
    do_sstat_character(ch, pos, k);
    pos += strlen(pos);
  }

d1610 6
d4218 1
d5740 4
@


1.239
log
@Added 'pscan' command so you can see how many of a type of object
are saved in player object files.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.238 2008/03/06 05:11:51 myc Exp jps $
d1382 1
a1382 1
    sprintf(buf2, "Idle: [%d tic%s], Chant Timer: [%d tic%s]",
d1384 1
a1384 3
            k->char_specials.timer == 1 ? "" : "s",
            k->player_specials->chant,
            k->player_specials->chant == 1 ? "" : "s");
d1606 10
d1925 1
a1925 2
    if (ch->desc->original->player_specials->chant < 0 &&
        subcmd == 0) {
d4197 1
a4197 1
    vict->player_specials->chant = RANGE(0, 100);
d5739 4
@


1.238
log
@Combined the 'saved' and 'unsaved' portions of the char_specials and
player_specials structures by moving all fields of each saved structure
to its parent structure.  Also combined the skills array from the
player and mob structures since they are identical.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.237 2008/03/05 16:18:20 myc Exp myc $
d5608 122
d5732 6
@


1.237
log
@The "show races" and "show classes" subcommands now list some other
potentially useful information.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.236 2008/03/05 05:21:56 myc Exp myc $
d1385 2
a1386 2
            k->player_specials->saved.chant,
            k->player_specials->saved.chant == 1 ? "" : "s");
d1917 1
a1917 1
    if (ch->desc->original->player_specials->saved.chant < 0 &&
d4190 1
a4190 1
    vict->player_specials->saved.chant = RANGE(0, 100);
d5610 4
@


1.236
log
@Bank coins are ints instead of longs now.  Fixed center_wiztitle so
it only adds &0 if it wasn't there already.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.235 2008/03/05 03:03:54 myc Exp myc $
d3532 22
a3553 2
         for (i = 0; i < NUM_CLASSES; i++)
            sprintf(buf, "%s   %s\r\n", buf, classes[i].displayname);
d3558 11
a3568 3
         sprintf(buf, "Fiery Races:\r\n-_-_-_-_-_-\r\n");
         for (i = 0; i < NUM_RACES; i++)
            sprintf(buf, "%s   %s\r\n", buf, races[i].fullname);
d5610 4
@


1.235
log
@New ascii pfiles store wiztitles, poofins, poofouts, and titles
differently.  Had to redesign the rename, players, advance, wiztitle,
and pfilemaint comands.  Also fixed a bug in hotboot: must kill ispell.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.234 2008/02/24 17:31:13 myc Exp myc $
d1345 1
a1345 1
               "Bank: [%s%ld%sp / %s%s%ld%sg / %s%ld%ss / %s%ld%sc]\r\n",
d3059 1
d3061 4
a3064 1
  sprintf(centerbuf + ((WIZ_TITLE_WIDTH - noansi_len) / 2), "%s&0", wiztitle);
d3067 2
a3068 1
  len += 2;
d3374 1
a3374 1
                            "Coins banked: [%7ldp / %7ldg / %7lds / %7ldc]\r\n"
d5582 5
@


1.234
log
@Wiznet can now be received while in OLC if you have OLCComm toggled
on.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.233 2008/02/24 06:31:41 myc Exp myc $
d46 1
d94 1
a94 1
void do_wiztitle(struct char_data *ch, struct char_data *vict, char *argu);
d509 2
a510 2
  if (strlen(POOFOUT(ch)) > 0)
    sprintf(buf, "%s", POOFOUT(ch));
d519 2
a520 2
  if (strlen(POOFIN(ch)) > 0)
    sprintf(buf, "%s", POOFIN(ch));
a530 1
  struct char_file_u tmp_store;
d544 1
a544 2
  if (load_char(arg, &tmp_store) > -1) {
    store_to_char(&tmp_store, victim);
d546 1
a546 1
      sprintf(buf, "(GC) %s has link-loaded %s.", GET_NAME(ch),GET_NAME(victim));
d1609 4
a1612 10
  if (!IS_NPC(k)) {
    found = FALSE;
    for (i = 0; i < NUM_P_TITLES; ++i)
      if (*GET_PTITLE(k, i)) {
        if (!found) {
          pos += sprintf(pos, "Permanent Titles:\r\n");
          found = TRUE;
        }
        pos += sprintf(pos, "  %d) %s\r\n", i + 1, GET_PTITLE(k, i));
      }
a1622 1
  struct char_file_u tmp_store;
d1669 1
a1669 8
      if (load_char(buf2, &tmp_store) > -1) {
	store_to_char(&tmp_store, victim);
        /*
         * Store to char sets the player's last logon to the current time,
         * but for 'stat file', we want to show the actual last logon,
         * which is in the char_file_u.
         */
        victim->player.time.logon = tmp_store.last_logon;
a1859 1
  struct char_file_u tmp_store;
a1863 3
  extern void save_char_file_u(struct char_file_u st);
  extern void modify_player_index_file(char *name, char *newname);
  extern char *get_fname(char *name, int mode);
d1867 1
a1867 1
  if(!ch || IS_NPC(ch))
d1870 1
a1870 1
  if(!arg1 || !*arg1 || !arg2 || !*arg2){
d1875 6
d1882 4
a1885 23
  if((victim=is_playing(arg1))) {
    if(GET_LEVEL(ch) <= GET_LEVEL(victim)) {
      send_to_char("You don't have permission to change that name.\r\n",ch);
      return;
    }
    if ((_parse_name(arg2, tmp_name)) || strlen(tmp_name) < 2 ||
	strlen(tmp_name) > MAX_NAME_LENGTH ||
	fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
      send_to_char("The new name is invalid.\r\n",ch);
      return;
    }
    if (!Valid_Name(tmp_name)) {
      send_to_char("The new name is invalid.\r\n",ch);
      return;
    }
    if ((player_i = load_char(tmp_name, &tmp_store)) > -1){
      send_to_char("There is already a player with that name.\r\n",ch);
      return;
    }
    sprintf(buf2,"&1&bYou have renamed &7%s&1 to &7%s&0\r\n",GET_NAME(victim),CAP(tmp_name));
    send_to_char(buf2, ch);
    sprintf(buf2, "%s has renamed %s to %s",GET_NAME(ch),GET_NAME(victim), tmp_name);
    mudlog(buf2,NRM,LVL_HEAD_C,TRUE);
d1887 6
a1892 4
    /* added to work with new split player files --gurlaek 8/9/1999 */
    modify_player_index_file(GET_NAME(victim), tmp_name);
    remove(get_fname(GET_NAME(victim), PLR_FILE));   /* old player file */
    remove(get_fname(GET_NAME(victim), CRASH_FILE)); /* old object file */
d1894 3
a1896 11
    strcpy((player_table + GET_PFILEPOS(victim))->name,CAP(tmp_name));
    strcpy(victim->player.name, CAP(tmp_name));
    save_player(victim);
    Crash_crashsave(victim);
    sprintf(buf2,"&1&b!!! You have been renamed to &7%s&1.&0\r\n",GET_NAME(victim));
    send_to_char(buf2, victim);    
  }
  else {
    send_to_char("That player is not playing at the moment.\r\n",ch);
    /* possible rename if offline? this would be bad because player
       would not know how to log in again.*/
d1898 10
d2092 1
a2092 2
  int i, count = 0, player_i, buflen = 0;
  struct char_file_u tmp_store;
d2108 1
a2108 1
      if ((player_i = load_char(player_table[i].name, &tmp_store)) > -1) {
d2110 4
a2113 6
        ++count;

        if (buflen > sizeof(buf) - 100) {
          buflen += sprintf(buf + buflen, "\r\nToo many players!  Buffer full.");
          break;
        }
d2115 1
a2115 1
        bitfield = tmp_store.char_specials_saved.act;
d2117 6
a2122 12
        if (IS_SET(bitfield, PLR_FROZEN))
          color = KCYN;
        else if (IS_SET(bitfield, PLR_NEWNAME))
          color = KRED;
        else if (IS_SET(bitfield, PLR_NAPPROVE))
          color = KYEL;
        else
          color = KGRN;
        buflen += sprintf(buf + buflen, "  %s&b%-15.20s(%3d) &0%s",
                          color, player_table[i].name, 
                          tmp_store.level, count % 3 ? "" : "\r\n");
      }
d2124 4
a2127 1
	mudlog("SYSERR:act.wizard.c:do_players:Unable to open player record.", NRM, LVL_GOD, FALSE);
d2196 1
a2196 1
  int newlevel, oldlevel, playtime, i;
a2249 2
    /* Save the victim's playtime since start_player() clears it. */
    playtime = victim->player.time.played;
a2250 1
    victim->player.time.played = playtime;
d2474 2
a2475 2
      strcpy(POOFIN(ch), argument);
      sprintf(buf, "Your poofin is now: %s\r\n", POOFIN(ch));
d2478 1
a2478 1
      sprintf(buf, "Your poofin is: %s\r\n", POOFIN(ch));
d2483 2
a2484 2
      strcpy(POOFOUT(ch), argument);
      sprintf(buf, "Your poofin is now: %s\r\n", POOFOUT(ch));
d2487 1
a2487 1
      sprintf(buf, "Your poofout is: %s\r\n", POOFOUT(ch));
d2616 1
a2616 1
   struct char_file_u chdata;
d2623 5
a2627 1
   if (load_char(arg, &chdata) < 0) {
d2629 1
d2632 1
a2632 1
   if ((chdata.level > GET_LEVEL(ch)) && (GET_LEVEL(ch) < LVL_HEAD_B)) {
d2634 1
d2638 3
a2640 3
      chdata.char_specials_saved.idnum, (int) chdata.level,
      classes[(int)chdata.class].abbrev, chdata.name, chdata.host,
      ctime(&chdata.last_logon));
d2642 2
d2880 1
a2880 1
          GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
d3056 23
a3078 1
void do_wiztitle(struct char_data *ch, struct char_data *vict, char *argu)  
d3080 1
a3080 2
  int noansi, i, back = 1;
  char centerbuf[MAX_WIZTITLE_LENGTH];
d3082 2
a3083 2
  skip_spaces(&argu);
  delete_doubledollar(argu);
d3086 2
a3087 10
  noansi = strlen(argu);
  if(noansi > 0) {
    for (i = 0; i < strlen(argu)-1; i++) {
      if (argu[i] == '&' && argu[i+1] != '&') {
        noansi -= 2;
      }
    }
  }
    
  sprintf(buf, "\r\n");
d3089 5
a3093 7
  if (IS_NPC(vict)) {
    send_to_char("Mobile's do not have godly titles...nice try.\r\n", ch);
    return;   
  } else if (strstr(argu, "[") || strstr(argu, "]")) {
    send_to_char("Godly Titles can't contain the [ or ] characters.\r\n", ch);
    return;   
  } else if (strlen(argu) > MAX_WIZTITLE_LENGTH - 1) {
d3095 2
a3096 4
            MAX_WIZTITLE_LENGTH - 1);
    return;
    /* changed size below to 12 to fit all of new god positions - rls:022502 */
  } else if (noansi  > 12) {
d3098 9
a3106 25
    return;   
  } else {
    /* center up the title */
    while (noansi < 12 && noansi > 0) {
      if (back) {
        strcat(argu, " ");
        back=0;
      } else {
        strcpy(centerbuf, " "); 
        strcat(centerbuf, argu);
        strcpy(argu, centerbuf);
        back=1;
      }
      noansi++;
    }
    if (noansi > 0) {
      strncpy(GET_WIZTITLE(vict), argu, MAX_WIZTITLE_LENGTH);
      sprintf(buf, "Okay, %s's godly title is now [%s]\r\n", GET_NAME(vict), GET_WIZTITLE(vict));
      return;   
    } else {
      strcpy(GET_WIZTITLE(vict), "\0");
      sprintf(buf, "Okay, %s's godly title reset to default.\r\n", GET_NAME(vict));
      return;   
    }
    return;   
a3107 1
  return;   
a3109 5
/* Based on do_title.  This allows gods to change their default */
/* title ie "Overlord" to whatever they wish                    */
/* --Fingon 2/10/1999                                           */


a3266 1
   struct char_file_u vbuf;
d3357 4
a3360 1
         if (load_char(value, &vbuf) < 0) {
d3362 1
d3365 2
a3366 2
         strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vbuf.birth)));
         strftime(buf2, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vbuf.last_logon)));
d3372 8
a3379 10
                     vbuf.name, genders[(int) vbuf.sex], vbuf.level, 
                     classes[(int) vbuf.class].abbrev,
                     races[(int) vbuf.race].displayname,
                     vbuf.points.coins.plat, vbuf.points.coins.gold,
                     vbuf.points.coins.silver, vbuf.points.coins.copper, 
                     vbuf.points.coins.bank_plat, vbuf.points.coins.bank_gold,
                     vbuf.points.coins.bank_silver, vbuf.points.coins.bank_copper,
                     vbuf.points.exp, vbuf.char_specials_saved.alignment,
            buf1, buf2, (int) (vbuf.played / 3600),
            (int) (vbuf.played / 60 % 60));
d3381 1
d3501 1
a3501 1
         if (!get_filename(value, value2, NOTES_FILE)) {
a3604 1
  struct char_file_u tmp_store;
a3610 1
  void save_char_file_u(struct char_file_u st);
a3679 1
   { "frag",         LVL_IMPL,        PC,   NUMBER },
d3682 2
a3683 2
   { "napprove",     LVL_GOD,         PC,   BINARY }, /*65*/
   { "holylight",    LVL_ATTENDANT,   PC,   BINARY },
d3687 2
a3688 2
   { "hiddenness",   LVL_GOD,         BOTH, NUMBER }, /*70*/
   { "rage",         LVL_GOD,         BOTH, NUMBER },
d3737 2
a3738 2
    if ((player_i = load_char(name, &tmp_store)) > -1) {
      store_to_char(&tmp_store, cbuf);
d3746 1
a3746 1
      free(cbuf);
d3802 1
a3802 1
    GET_NATHPS(vict) = RANGE(1, 500000);
d4058 2
a4059 2
      strncpy(tmp_store.pwd, CRYPT(val_arg, tmp_store.name), MAX_PWD_LENGTH);
      tmp_store.pwd[MAX_PWD_LENGTH] = '\0';
d4141 1
a4141 5
   case 62:
    GET_FRAG(vict) = value;
    strcpy(buf, "Frag list wont be updated till next boot.\r\n");
    break;
  case 63:
d4144 3
d4148 1
a4148 1
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NEWNAME);
d4151 1
a4151 1
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NAPPROVE);
d4154 1
a4154 1
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_HOLYLIGHT);
d4157 1
a4157 1
    do_wiztitle(ch, vict, val_arg);
a4159 3
    vict->player_specials->saved.chant = RANGE(0, 100);
    break;
  case 69:
d4172 1
a4172 1
  case 70:
d4175 1
a4175 1
  case 71:
d4178 1
a4178 1
  case 72:
d4182 5
a4186 2
    if (i < 1 || i > NUM_P_TITLES)
      strcpy(buf, "You can only set ptitles from 1 to 9.\r\n");
d4188 9
a4196 1
      strncpy(GET_PTITLE(vict, i - 1), argument, MAX_TITLE_LENGTH);
d4198 1
a4198 1
              GET_PTITLE(vict, i - 1));
d4222 2
a4223 2
      char_to_store(vict, &tmp_store);
      save_char_file_u(tmp_store);
a5340 1
/* by gurlaek 7/22/1999 */
a5341 3
  extern void build_player_index(void);
  FILE *player_fl, *player_file_index;
  struct char_file_u *player;
d5343 1
a5343 2
  int plrid = 0, saved = 0, axed = 0, reason = 0;
  int i, idle_time, allowed_time;
d5345 2
a5346 4
  char logbuf[MAX_STRING_LENGTH];
  char tmp_name[MAX_INPUT_LENGTH];
  char fn[255], plr_name[MAX_NAME_LENGTH + 1];
  char *tmp_dir = NULL, *tmp2_dir = NULL;
d5357 1
a5357 1
  if(restrict != GET_LEVEL(ch)) {
d5361 3
a5363 2
  for(d = descriptor_list; d; d = d->next) {
    if(d != ch->desc) {
d5369 3
a5371 1
  CREATE(player, struct char_file_u, 1);
d5373 3
a5375 7
  sprintf(logbuf, "PFILEMAINT: Started by %s", GET_NAME(ch));
  log(logbuf);
  SEND_TO_Q("Processing player files", ch->desc);

  /* move the player index to a backup file */
  sprintf(fn, "%s/%s", PLR_PREFIX, INDEX_FILE);
  sprintf(buf, "mv %s %s.`date +%%m%%d.%%H%%M%%S`", fn, fn);
d5378 1
a5378 22
  /* create a new player index file */
  if (!(player_file_index = fopen(fn, "w"))) {
    perror("fatal error opening playerfile index");
    exit(1);
  }

  /* The all new even better loop A - Z */
  log("PFILEMAINT: Creating TMP directories");
  for(i = 'A'; i <= 'Z'; i++) {
    tmp_dir = (char *)malloc(strlen(PLR_PREFIX) + 7); 
    sprintf(tmp_dir, "%s/%c.TMP", PLR_PREFIX, i);
    mkdir(tmp_dir, 0700); /* 700 is the mode of the directory */
    free(tmp_dir);
    tmp_dir = NULL;
  }

  /* loop through the player files */
  for(i = 0; i <= top_of_p_table; i++) {
    strcpy(plr_name, player_table[i].name);
    plr_name[0] = toupper(plr_name[0]);
    memset(fn, 0x0, 255);
    get_filename(plr_name, fn, PLR_FILE);
d5380 10
a5389 9
    if (!(player_fl = fopen(fn, "r+"))) {
      sprintf(buf, "No player file for index name: %s", player_table[i].name);
      log(buf);
      continue;
    }
    if(!fread(player , sizeof(struct char_file_u), 1, player_fl))
      continue;
    else
      fclose(player_fl);
d5391 2
a5392 6
    idle_time = (time(0) - player->last_logon) / 86400;  /* number of days since last login */
    allowed_time = 28 + ((player->level - 1) * 3);       /* 4 weeks base plus 3 days per level */
    bitfield = player->char_specials_saved.act;
    reason = 0;                                 /* assume no delete at first          */

    if (( _parse_name(player->name, tmp_name))) /* no spaces special chars etc        */
d5394 2
a5395 1
    if (strlen(tmp_name) < 2)                   /* must be greater than 2 chars       */
d5397 2
a5398 1
    if (strlen(tmp_name) > MAX_NAME_LENGTH)     /* must be less than MAX_NAME_LENGTH  */
d5400 2
a5401 1
    if (fill_word(strcpy(buf, tmp_name)))       /* can't be a reserved fill word      */
d5403 2
a5404 1
    if (reserved_word(buf))                     /* can't be a reserved word           */
d5406 2
a5407 1
    if (!Valid_Name(tmp_name))                  /* can't be an xname or a mob name    */
d5409 2
a5410 1
    if (idle_time > allowed_time)               /* too much idle time/wasting space   */
d5412 23
d5436 10
a5445 62
    if((((reason) &&                             /* reason 0-7 above                   */
	 (!IS_SET(bitfield, PLR_FROZEN)) &&      /* don't del frozen players           */
	 (!IS_SET(bitfield, PLR_NEWNAME))) ||    /* don't del players pending new name */
	(reason == 7)) &&                        /* too much idle time, delete anyway  */
       (plrid) &&                                /* NEVER delete player 0              */
       (strcmp(player->name, GET_NAME(ch))) &&   /* NEVER delete yourself              */
       (player->level < LVL_IMMORT)              /* NEVER delete Immortals             */
       ) {
      sprintf(logbuf, "PFILEMAINT: %d Player [%s] DELETED: %s.", plrid, player->name, rlist[reason]);
      log(logbuf);
      if(reason == 7) {
	sprintf(logbuf, "PFILEMAINT: Level %d Idle: %d days.", player->level, idle_time);
	log(logbuf);
      }
      axed++;
    } else {
      fputs(player->name, player_file_index);
      fputs("\n", player_file_index);
      saved++;
      tmp_dir = (char *)malloc(strlen(PLR_PREFIX) + 7); 
      sprintf(tmp_dir, "%s/%c.TMP", PLR_PREFIX, plr_name[0]);     
      sprintf(buf, "mv %s %s", fn, tmp_dir); 
      system(buf);
      sprintf(buf, "mv %s.* %s", fn, tmp_dir); 
      system(buf);
      free(tmp_dir);
      tmp_dir = NULL;
    }
    SEND_TO_Q(".", ch->desc);
    plrid++;
  }
  fclose(player_file_index);
  free(player);
  
  sprintf(logbuf, "PFILEMAINT: Original: %d Discarded: %d Saved: %d", plrid, axed, saved);
  log(logbuf);

  /* Delete old directory and move the new one in */
  log("PFILEMAINT: Restoring files");
  for(i = 'A'; i <= 'Z'; i++) {    
    /* Creating the string for the directory names the game uses */
    tmp2_dir = (char *)malloc(strlen(PLR_PREFIX) + 3); 
    sprintf(tmp2_dir, "%s/%c", PLR_PREFIX, i);
    
    /* Creating the string for the Temporary (*.TMP) directory that
       files are put into until moved back */    
    tmp_dir = (char *)malloc(strlen(PLR_PREFIX) + 7); 
    sprintf(tmp_dir, "%s/%c.TMP", PLR_PREFIX, i);
    
    /* remove the old directory with extraneous crap in it */
    sprintf(buf, "rm -rf %s", tmp2_dir);  
    system(buf);
    
    /* move the *.TMP over the valid directory name to replace it */
    sprintf(buf, "mv %s %s", tmp_dir, tmp2_dir);
    system(buf);
    
    /* Look ma no memory leak */
    free(tmp2_dir);
    tmp2_dir = NULL;
    free(tmp_dir);
    tmp_dir = NULL;
d5448 3
a5451 7
  for(i = 0; i <= top_of_p_table; i++) {
    if(player_table[i].name) {
      free(player_table[i].name);
      player_table[i].name = NULL;
    }
    player_table[i].id = 0;
  }
d5453 4
a5456 5
  player_table = NULL;
  
  /* generate new player index table */
  log("PFILEMAINT: Rebuilding player table index");
  build_player_index();
d5459 1
a5459 2
  SEND_TO_Q("Done!\r\n", ch->desc);
  return;
d5473 2
a5474 1
  void Crash_rentsave(struct char_data *ch, int cost);
d5554 4
a5557 1
  /* exec - descriptors are inherited! */
d5564 1
a5564 1
  /* Close reserve and other always-open files and release other resources */
d5577 4
@


1.233
log
@The world command will now show many hotboots have ocurred since the
last shutdown.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.232 2008/02/23 01:03:54 myc Exp myc $
a2732 1
  char emote = FALSE;
d2740 2
a2741 2
    send_to_char("Usage: wiznet <text> | #<level> <text> | *<emotetext> |\r\n "
		 "       wiznet @@<level> *<emotetext> | wiz @@\r\n", ch);
d2744 1
a2745 2
    /* case '*':
       emote = TRUE; removed for ZZur RLS:060702*/ 
d2755 1
a2755 2
    } else if (emote)
      argument++;
d2807 1
d2809 2
a2810 4
    sprintf(buf1, "&6%s: <%d> %s%s&0\r\n", GET_NAME(ch), level,
	    emote ? "<--- " : "", argument);
    sprintf(buf2, "&6Someone: <%d> %s%s&0\r\n", level, emote ? "<--- " : "",
	    argument);
d2812 2
a2813 3
    sprintf(buf1, "&6%s: %s%s&0\r\n", GET_NAME(ch), emote ? "<--- " : "",
	    argument);
    sprintf(buf2, "&6Someone: %s%s&0\r\n", emote ? "<--- " : "", argument);
d2817 1
a2817 1
    if (STATE(d) != CON_PLAYING)
d2819 3
a2825 2
    if (PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
      continue;
d5670 4
@


1.232
log
@Added better messages to the advance command when demoting.  Also
making the advance command call init_mem_list so it clears the mem
list when demoting.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.231 2008/02/09 18:29:11 myc Exp myc $
d4313 2
d4325 6
d5570 1
d5629 1
a5629 1
  fprintf(fp, "%ld\n", boot_time);
d5674 5
@


1.231
log
@Cleaned up the do_players command a bit.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.230 2008/02/09 16:21:07 myc Exp myc $
d2230 1
a2230 1
  int newlevel, oldlevel, playtime;
d2305 19
d2326 6
a2331 2
  sprintf(buf, "(GC) %s has advanced %s to level %d (from %d)",
	  GET_NAME(ch), GET_NAME(victim), newlevel, oldlevel);
d2336 8
d5665 3
@


1.230
log
@Fixing a typo in poofset: no newline.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.229 2008/02/09 07:05:37 myc Exp myc $
d1932 1
a1932 1
    send_to_char("That players is not playing at the moment.\r\n",ch);
d2120 1
a2120 2
  int i, count = 0, player_i;
  char playbuf[MAX_STRING_LENGTH];
d2122 1
d2125 20
a2144 2
  memset(playbuf, 0x0, MAX_STRING_LENGTH);
  one_argument(argument, arg);
d2146 1
a2146 8
  /* check for single char argument */
  if(strlen(arg) == 1) {
    
    /* go through all the names in the pfile */
    for (i = 0; i <= top_of_p_table; i++) {
      /* check if the first letter matches the argument */
      if(memchr((player_table + i)->name, arg[0], 1)) {
	if ((player_i = load_char((player_table + i)->name, &tmp_store)) > -1) {	
d2148 11
a2158 39
	  bitfield = tmp_store.char_specials_saved.act;
	  
	  /* check if there is enough room left in the buffer */ /* for 6 ascii characters */
	  if((strlen(playbuf) + strlen((player_table + i)->name) +6 ) <= (MAX_STRING_LENGTH - 3)) {
	  /* add the name to the buffer in groups of three per line */
	    count++;
	    if (count == 3) {
	      count = 0;
	      strcat(playbuf, "\r\n");
	    }
	  } else {
	    /* buffer too small for all names */
	    strcat(playbuf, "\r\n");
	    send_to_char("Too many names to show them all!\r\n", ch);
	    page_string(ch->desc, playbuf, 1);
	    return;
	  }
	  
	  /* This sets the player name light cyan if the player is frozen */
	  if(IS_SET(bitfield, PLR_FROZEN)){
	    sprintf(buf, "%s (%d)", (player_table + i)->name, tmp_store.level); 	  
	    sprintf(playbuf, "%s  &6&b%-20.20s&0", playbuf, buf);
	    /* This sets the player name red if the name is rejected and needs to be renamed */	  
	  } else if(IS_SET(bitfield, PLR_NEWNAME)) {
	    sprintf(buf, "%s (%d)", (player_table + i)->name, tmp_store.level);
	    sprintf(playbuf, "%s  &1&b%-20.20s&0", playbuf, buf);
	    /* This sets the player name yellow of the name is pending approval */	
	  } else if(IS_SET(bitfield, PLR_NAPPROVE)) {
	    sprintf(buf, "%s (%d)", (player_table + i)->name, tmp_store.level);
	    sprintf(playbuf, "%s  &3&b%-20.20s&0", playbuf, buf);
	    /* This sets the player name light green if the player name is accepted */	  
	  } else {
	    sprintf(buf, "%s (%d)", (player_table + i)->name, tmp_store.level);
	    sprintf(playbuf, "%s  &2&b%-20.20s&0", playbuf, buf);
	  }
	} else {
	  mudlog("SYSERR:act.wizard.c:do_players:Unable to open player record.", NRM, LVL_GOD, FALSE);
	}
	
d2160 2
a2161 1
      
a2162 9
    
    /* show the name list */
    page_string(ch->desc, playbuf, 1);
    return;
  } else {
    
    /* show usage */
    send_to_char("'players <letter>' shows all player names beginning with <letter>", ch);
    return;
d2164 8
d5634 3
@


1.229
log
@Renaming copyover to a more descriptive hotboot.  Hotboot also now
requires you to specify 'yes' or 'force' to actually hotboot.  Also,
it gets logged.  It will warn you if anyone is in OLC or in the
process of logging in.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.228 2008/02/09 04:27:47 myc Exp myc $
d2498 1
a2498 1
      sprintf(buf, "Your poofin is now: %s", POOFIN(ch));
d2501 1
a2501 1
      sprintf(buf, "Your poofin is: %s", POOFIN(ch));
d2507 1
a2507 1
      sprintf(buf, "Your poofin is now: %s", POOFOUT(ch));
d2510 1
a2510 1
      sprintf(buf, "Your poofout is: %s", POOFOUT(ch));
d5651 6
@


1.228
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.227 2008/02/09 03:04:23 myc Exp myc $
d5541 1
a5541 1
ACMD(do_copyover)
d5544 1
d5546 1
d5553 41
a5593 1
  fp = fopen(COPYOVER_FILE, "w");
d5595 1
a5595 1
    send_to_char("Copyover file not writeable, aborted.\r\n", ch);
d5599 5
a5603 1
  sprintf(buf, "\r\n &3&8<&0&3<&1<&8< HOTBOOT by %s - please remain seated! >&0&1>&3&8>&0&3>&0\r\n", GET_NAME(ch));
d5614 1
a5614 1
    if (!d->character || d->connected > CON_PLAYING) {
d5633 1
a5633 1
  sprintf(buf2, "-C%d", mother_desc);
d5642 2
a5643 2
  perror("do_copyover: execl");
  write_to_descriptor(ch->desc->descriptor, "Copyover FAILED!\r\n");
d5651 3
@


1.227
log
@Adding the 'copyover' command, which allows you to do a hot-boot
without disconnecting anybody.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.226 2008/02/08 13:43:55 jps Exp myc $
d45 1
d5605 4
@


1.226
log
@Added defines for "show" command sub-elements, so we can sort the
list of things that can be shown. They're sorted horizontally for
now which is not ideal. Also got rid of extra newline.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.225 2008/02/07 01:46:14 myc Exp jps $
d5540 62
d5604 5
@


1.225
log
@Removin the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
which points to the sizes array.  The set command allows you to
specify sizes as strings now instead of numbers.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.224 2008/02/06 21:53:53 myc Exp myc $
d3279 16
d3298 50
a3347 33
  struct char_file_u vbuf;
  int i, j, k, l, con, rn, rrn;
  struct char_data *vict;
  struct obj_data *obj;
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH];
  char zonebuf[50000], value2[MAX_INPUT_LENGTH], value3[MAX_INPUT_LENGTH];
  struct descriptor_data *d;
  extern int buf_switches, buf_largecount, buf_overflows;
  void show_shops(struct char_data * ch, char *value);
  void hcontrol_list_houses(struct char_data *ch);

  struct show_struct {
    char *cmd;
    char level;
  } fields[] = {
    { "nothing",	0  },				/* 0 */
    { "zones",		LVL_IMMORT },			/* 1 */
    { "player",		LVL_GOD },
    { "rent",		LVL_GOD },
    { "stats",		LVL_IMMORT },
    { "errors",		LVL_GRGOD },			/* 5 */
    { "death",		LVL_GOD },
    { "godrooms",	LVL_GOD },
    { "shops",		LVL_GOD },
    { "houses",		LVL_GOD },
    { "file",		LVL_GRGOD },
    { "notes",		LVL_IMMORT },
    { "classes",	LVL_IMMORT },
    { "races",		LVL_IMMORT },
    { "exp",		LVL_IMMORT },
    { "snoop",		LVL_GOD },
    { "\n", 0 }
  };
d3349 2
a3350 1
  *zonebuf = '\0';
d3352 3
a3354 18
  skip_spaces(&argument);

  if (!*argument) {
    strcpy(buf, "Show options:\r\n");
    for (j = 0, i = 1; fields[i].level; i++)
      if (fields[i].level <= GET_LEVEL(ch))
	sprintf(buf, "%s%-15s%s", buf, fields[i].cmd, (!(++j % 5) ? "\r\n" : ""));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }

  half_chop(argument, field, value2);
  strcpy(arg, two_arguments(value2, value, value3));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;
d3356 2
a3357 31
  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }

  buf[0] = '\0';

  switch (l) {
  case 1: /* zone */
    if (!strcmp(value, ".")) {
      print_zone_to_buf(buf, world[ch->in_room].zone);
      send_to_char(buf, ch);
    }
    else if (*value && is_number(value)) {
      if ((i = find_zone(atoi(value))) == NOWHERE)
        send_to_char("That is not a valid zone.\r\n", ch);
      else {
        print_zone_to_buf(buf, i);
        send_to_char(buf, ch);
      }
    }
    else {
      for (i = 0; i <= top_of_zone_table; i++)
	print_zone_to_buf(zonebuf, i);
      page_string(ch->desc, zonebuf, 1);
    }
    break;

  case 2: /* player */
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
d3359 1
a3359 1
    }
d3361 1
a3361 23
    if (load_char(value, &vbuf) < 0) {
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
    strftime(buf1, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vbuf.birth)));
    strftime(buf2, MAX_STRING_LENGTH, TIMEFMT_DATE, localtime(&(vbuf.last_logon)));
    sprintf(buf, "Player: %-12s (%s) [%2d %s] (%s)\r\n"
                 "Coins held:   [%7dp / %7dg / %7ds / %7dc]\r\n"
                 "Coins banked: [%7ldp / %7ldg / %7lds / %7ldc]\r\n"
                 "Exp: %-8ld  Align: %-5d\r\n"
                 "Started: %s  Last: %s  Played: %3dh %2dm\r\n",
            vbuf.name, genders[(int) vbuf.sex], vbuf.level, 
            classes[(int) vbuf.class].abbrev,
            races[(int) vbuf.race].displayname,
            vbuf.points.coins.plat, vbuf.points.coins.gold,
            vbuf.points.coins.silver, vbuf.points.coins.copper, 
            vbuf.points.coins.bank_plat, vbuf.points.coins.bank_gold,
            vbuf.points.coins.bank_silver, vbuf.points.coins.bank_copper,
            vbuf.points.exp, vbuf.char_specials_saved.alignment,
	    buf1, buf2, (int) (vbuf.played / 3600),
	    (int) (vbuf.played / 60 % 60));
    send_to_char(buf, ch);
    break;
d3363 1
a3363 6
  case 3: /* rent */
    if (*value)
      Crash_listrent(ch, value);
    else
      send_to_char("Show rent for whom?\r\n", ch);
    break;
d3365 17
a3381 30
  case 4: /* stats */
    i = j = k = con = 0;
    for (vict = character_list; vict; vict = vict->next) {
      if (IS_NPC(vict))
	j++;
      else if (CAN_SEE(ch, vict)) {
	i++;
	if (vict->desc)
	  con++;
      }
    }
    for (obj = object_list; obj; obj = obj->next)
      k++;
    sprintf(buf, "Current stats:\r\n"
                 "  %5d players in game  %5d connected\r\n"
                 "  %5d registered\r\n"
                 "  %5d mobiles          %5d prototypes\r\n"
                 "  %5d objects          %5d prototypes\r\n"
                 "  %5d rooms            %5d zones\r\n"
                 "  %5d large bufs\r\n"
                 "  %5d buf switches     %5d overflows\r\n",
            i, con,
            top_of_p_table + 1, 
	    j, top_of_mobt + 1,
	    k, top_of_objt + 1,
	    top_of_world + 1, top_of_zone_table + 1,
            buf_largecount,
	    buf_switches, buf_overflows);
    send_to_char(buf, ch);
    break;
d3383 5
a3387 29
  case 5: /* error */
    strcpy(buf, "Errant Rooms\r\n------------\r\n");
    for (i = 0; i <= top_of_zone_table; i++) {
      if (!zone_table[i].top)
        continue;
      for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
        if ((rrn = real_room(rn)) == NOWHERE)
          continue;
        value3[0] = '\0';
	for (j = 0; j < NUM_OF_DIRS; j++) {
	  if (world[rrn].dir_option[j]) {
            if (j == FDOWN || j == FUP)
              sprintf(value3, "%s%s exit, ", value3, dirs[j]);
            if (world[rrn].dir_option[j]->to_room == 0)
              sprintf(value3, "%s%s to void, ", value3, dirs[j]);
            if (world[rrn].dir_option[j]->to_room == NOWHERE &&
                !world[rrn].dir_option[j]->general_description)
              sprintf(value3, "%s%s to NOWHERE, ", value3, dirs[j]);
	  }
        }
        if (value3[0]) {
          value3[strlen(value3) - 2] = '\0'; /* cut off last comma */
	  sprintf(buf, "%s [%5d] %-30s %s\r\n",
                  buf, world[rrn].number, world[rrn].name, value3);
        }
      }
    }
    send_to_char(buf, ch);
    break;
d3389 23
a3411 15
  case 6: /* death */
    strcpy(buf, "Death Traps\r\n-----------\r\n");
    for (i = 0, j = 0; i <= top_of_zone_table; i++) {
      if (!zone_table[i].top)
        continue;
      for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
        if ((rrn=real_room(rn)) == NOWHERE)
          continue;
        if (IS_SET(ROOM_FLAGS(rrn), ROOM_DEATH))
          sprintf(buf, "%s%2d: [%5d] %s\r\n",
                  buf, j++, world[rrn].number, world[rrn].name);
      }
    }
    send_to_char(buf, ch);
    break;
d3413 37
a3449 15
  case 7: /* godrooms */
    strcpy(buf, "Godrooms\r\n--------------------------\r\n");
    for (i = 0, j = 0; i <= top_of_zone_table; i++) {
      if (!zone_table[i].top)
        continue;
      for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
        if ((rrn=real_room(rn)) == NOWHERE)
          continue;
        if (IS_SET(ROOM_FLAGS(rrn), ROOM_GODROOM))
          sprintf(buf, "%s%2d: [%5d] %s\r\n",
                  buf, j++, world[rrn].number, world[rrn].name);
      }
    }
    send_to_char(buf, ch);
    break;
d3451 29
a3479 3
  case 8: /* shops */
    show_shops(ch, value);
    break;
d3481 15
a3495 3
  case 9: /* houses */
    hcontrol_list_houses(ch);
    break;
d3497 15
a3511 3
  case 10: /* file */
    do_file(ch, value, value3);
    break;
d3513 40
a3552 28
  case 11: /* notes */
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
      return;
    }
    if (!get_filename(value, value2, NOTES_FILE)) {
      send_to_char("Couldn't find that player.\r\n", ch);
      return;
    }
    {
      FILE* i = fopen(value2, "rt");
      if (i == NULL) {
	send_to_char("There are no notes for that file.\r\n", ch);
	return;
      }
      zonebuf[0] = '\0';
      while(get_line(i, value3)) {
	strcat(zonebuf, value3);
	strcat(zonebuf, "\r\n");
	if (strlen(zonebuf) > 49500) {
	  strcat(zonebuf, "Max note length exceeded.\r\n");
	  break;
	}
      }
      fclose(i);
      page_string(ch->desc, zonebuf, 1);
    }
    break; 
d3554 33
a3586 6
  case 12: /* classes */
    sprintf(buf, "Fiery Classes:\r\n-_-_-_-_-_-_-\r\n");
    for (i = 0; i < NUM_CLASSES; i++)
      sprintf(buf, "%s  %s\r\n", buf, classes[i].displayname);
    page_string(ch->desc, buf, 1);
    break;
d3588 20
a3607 6
  case 13: /* races */
    sprintf(buf, "Fiery Races:\r\n-_-_-_-_-_-\r\n");
    for (i = 0; i < NUM_RACES; i++)
      sprintf(buf, "%s  %s\r\n", buf, races[i].fullname);
    page_string(ch->desc,buf,1);
    break;
d3609 4
a3612 45
  case 14: /* exp */
    if (!*value)
      send_to_char("Usage: show exp <class>\r\n", ch);
    else {
      for (l = 0; l < NUM_CLASSES; l++) {
        if (is_abbrev(value, classes[l].name)) {
          sprintf(buf, "    Level       Experience Needed        Total\r\n");
          strcat(buf,  " ---------      -----------------      ---------\r\n");
          for (i = 1; i <= LVL_MAX_MORT; ++i)
            sprintf(buf, "%s %3d - %3d              %9ld      %9ld\r\n",
                    buf, i, i + 1, exp_to_level(i, l) -
                    exp_to_level(i - 1, l), exp_to_level(i, l));
          page_string(ch->desc, buf, 1);
          return;
        }
      }
      send_to_char("Invalid class.\r\n", ch);
    }
    break;

  case 15: /* snoop */
    i = 0;
    send_to_char("People currently snooping:\r\n"
                 "--------------------------\r\n", ch);
    for (d = descriptor_list; d; d = d->next) {
      if (d->snooping == NULL || d->character == NULL)
        continue;
      if (STATE(d) != CON_PLAYING || GET_LEVEL(ch) < GET_LEVEL(d->character))
        continue;
      if (!CAN_SEE(ch, d->character) || IN_ROOM(d->character) == NOWHERE)
        continue;
      i++;
      sprintf(buf, "%-10s%s - snooped by %s%s.\r\n",
              GET_NAME(d->snooping->character), QNRM,
              GET_NAME(d->character), QNRM);
      send_to_char(buf, ch);
    }
    if (i == 0)
      send_to_char("No one is currently snooping.\r\n", ch);
    break;

  default:
    send_to_char("Sorry, I don't understand that.\r\n", ch);
    break;
  }
d5542 5
@


1.224
log
@Make stat obj show weapon average and portal messages.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.223 2008/02/06 03:56:46 myc Exp myc $
d1283 1
a1283 1
          "Size: %s, Sex: %s\r\n"
d1285 1
a1285 1
          SIZE_ABBR(k), buf1,
d3700 1
a3700 1
   { "size",         LVL_GOD,         PC,   NUMBER },
d4178 11
a4188 1
    GET_SIZE(vict) = RANGE(1, 3);
d5524 3
@


1.223
log
@Estat now uses the pager.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.222 2008/02/06 03:45:08 myc Exp myc $
d971 4
d1051 3
a1053 2
    pos += sprintf(pos, "Todam: %dd%d, Message type: %d, '%s'\r\n",
	    GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3),
d1099 21
d5514 3
@


1.222
log
@Stat room and stat obj now use the pager.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.221 2008/02/05 22:39:55 myc Exp myc $
d1169 3
d1183 1
a1183 1
         send_to_char(buf, ch);
d1202 1
a1202 1
            send_to_char(buf, ch);
d1206 1
a1206 1
         send_to_char(buf, ch);
d5488 3
@


1.221
log
@Diety on most players is -1, not 0.  Commenting out the diety
line in stat char.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.220 2008/02/05 04:22:42 myc Exp myc $
d680 1
a680 1
void list_zone_commands_room(struct char_data *ch, room_num rvnum)
d687 1
a687 1
    send_to_char("No zone information available.\r\n", ch);
a693 1
  send_to_char(buf, ch);
d713 1
a713 1
          sprintf(buf, "%sLoad %s [%s%d%s], Max : %d\r\n",
d720 1
a720 1
          sprintf(buf, "%sGive it %s [%s%d%s], Max : %d\r\n",
d728 1
a728 1
          sprintf(buf, "%sLoad %s [%s%d%s], Max : %d\r\n",
d736 1
a736 1
          sprintf(buf, "%sEquip with %s [%s%d%s], %s, Max : %d\r\n",
d745 1
a745 1
          sprintf(buf, "%sPut %s [%s%d%s] in %s [%s%d%s], Max : %d\r\n",
d755 1
a755 1
          sprintf(buf, "%sRemove %s [%s%d%s] from room.\r\n",
d762 1
a762 1
          sprintf(buf, "%sSet door %s as %s.\r\n",
d769 1
a769 1
          sprintf(buf, "<Unknown Command>\r\n");
d772 1
a772 2
      sprintf(buf1, "  %s%d - %s%s", nrm, count, yel, buf);
      send_to_char(buf1, ch);
d776 1
a776 1
  send_to_char(nrm, ch);
d778 1
a778 1
    send_to_char("  None.\r\n", ch);
d783 1
a783 1
void stat_extra_descs(struct extra_descr_data *ed, struct char_data *ch, bool showtext)
d789 1
a789 1
      send_to_char("No extra descs.\r\n", ch);
d794 4
a797 6
      for (desc = ed; desc; desc = desc->next) {
         sprintf(buf, "&4*&0 %s%s%s\r\n", CCCYN(ch, C_NRM), desc->keyword,
               CCNRM(ch, C_NRM));
         send_to_char(buf, ch);
         send_to_char(desc->description, ch);
      }
d810 1
a810 1
      send_to_char(strcat(buf, "\r\n"), ch);
d821 1
d823 2
d826 2
a827 3
  sprintf(buf, "Room name: %s%s%s\r\n", CCCYN(ch, C_NRM), rm->name,
	  CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
d830 1
a830 1
  sprintf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
a831 1
  send_to_char(buf, ch);
d834 1
a834 1
  sprintf(buf, "SpecProc: %s, Flags: %s\r\n",
a835 1
  send_to_char(buf, ch);
d838 1
a838 2
  sprintf(buf, "Room affections: %s\r\n", buf2);
  send_to_char(buf, ch);
d840 1
a840 2
  sprintf(buf, "Ambient Light : %d\r\n", rm->light);
  send_to_char(buf, ch);
d842 7
a848 8
  send_to_char("Description:\r\n", ch);
  if (rm->description)
    send_to_char(rm->description, ch);
  else
    send_to_char("  None.\r\n", ch);
  
  stat_extra_descs(rm->ex_description, ch, FALSE);
  sprintf(buf, "Chars present:%s", CCYEL(ch, C_NRM));
d852 1
a852 1
    sprintf(buf2, "%s %s(%s)", found++ ? "," : "", GET_NAME(k),
d854 3
a856 7
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (k->next_in_room)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
d859 3
a861 4
  
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  send_to_char(CCNRM(ch, C_NRM), ch);
d864 1
a864 1
    sprintf(buf, "Contents:%s", CCGRN(ch, C_NRM));
d868 5
a872 8
      sprintf(buf2, "%s %s", found++ ? "," : "", j->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
d876 3
a878 3
    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
d880 1
d889 1
a889 1
      sprintf(buf, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n ",
a892 1
      send_to_char(buf, ch);
d894 1
a894 1
	send_to_char(rm->dir_option[i]->general_description, ch);
d902 1
a902 1
        sprintf(buf, "SPL: (%3d) &6%-21s&0, sets %s\r\n",
a903 1
        send_to_char(buf, ch);
d907 2
a908 1
  list_zone_commands_room(ch, rm->number);
d911 3
a913 1
  do_sstat_room(ch, rm);
d917 1
a917 1
void stat_spellbook(struct obj_data *obj, struct char_data *ch) {
d928 1
a928 1
   send_to_char("&7&b---Spellbook Contents---&0\r\n", ch);
d935 1
a935 1
         send_to_char("&1&b*&0 Its spell list is NULL.\r\n", ch);
d937 1
a937 1
         send_to_char("&1&b*&0 The first spell in its spell list is 0.\r\n", ch);
d939 1
a939 1
         send_to_char("&1&b***&0 Unknown reason why I can't show you the spell list! &1&b***&0\r\n", ch);
d961 1
a961 2
   send_to_char(list_buf, ch);
   return;      
d969 1
d971 3
d975 4
a978 4
  sprintf(buf, "Name: '%s%s%s', Aliases: %s, Level: %d\r\n", CCYEL(ch, C_NRM),
	  ((j->short_description) ? j->short_description : "<None>"),
	  CCNRM(ch, C_NRM), j->name, GET_OBJ_LEVEL(j));
  send_to_char(buf, ch);
d981 1
a981 1
    strcpy(buf2, (obj_index[GET_OBJ_RNUM(j)].func ? "Exists" : "None"));
d984 1
a984 1
  sprintf(buf, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s\r\n",
a985 3
  send_to_char(buf, ch);
  sprintf(buf, "L-Des: %s\r\n", ((j->description) ? j->description : "None"));
  send_to_char(buf, ch);
d987 16
a1002 17
  if (j->action_description) {
     send_to_char("Action desc:\r\n", ch);
     sprintf(buf, "%s%s%s\r\n", CCYEL(ch, C_NRM), j->action_description,
           CCNRM(ch, C_NRM));
     send_to_char(buf, ch);
  }
  send_to_char("Can be worn on: ", ch);
  sprintbit(j->obj_flags.wear_flags, wear_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  
  send_to_char("Extra flags   : ", ch);
  sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  
  strcpy(buf, "Spell Affects : ");
d1004 1
a1004 1
    sprintbit(GET_OBJ_SPELL(j), affected_bits, buf + strlen(buf));
d1006 1
a1006 1
    sprintbit(GET_OBJ_SPELL2(j), affected_bits2, buf + strlen(buf));
d1008 3
a1010 4
    sprintbit(GET_OBJ_SPELL3(j), affected_bits3, buf + strlen(buf));
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  
d1012 2
a1013 2
  sprintf(buf, "Weight: %d, Value: %d, Cost/day: %d, "
                "Timer: %d, Hiddenness: %ld\r\n",
a1015 1
  send_to_char(buf, ch);
a1016 1
  strcpy(buf, "In room: ");
d1018 7
a1024 13
    strcat(buf, "Nowhere");
  else {
    sprintf(buf2, "%d", world[j->in_room].number);
    strcat(buf, buf2);
  }
  strcat(buf, ", In object: ");
  strcat(buf, j->in_obj ? j->in_obj->short_description : "None");
  strcat(buf, ", Carried by: ");
  strcat(buf, j->carried_by ? GET_NAME(j->carried_by) : "Nobody");
  strcat(buf, ", Worn by: ");
  strcat(buf, j->worn_by ? GET_NAME(j->worn_by) : "Nobody");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
d1029 1
a1029 1
      strcpy(buf, "Hours left: Infinite");
d1031 2
a1032 1
      sprintf(buf, "Hours left: [%d]  Initial hours: [%d]", GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
d1036 3
a1038 3
    sprintf(buf, "Spells: (Level %d) %s, %s, %s", GET_OBJ_VAL(j, 0),
	    skill_name(GET_OBJ_VAL(j, 1)), skill_name(GET_OBJ_VAL(j, 2)),
	    skill_name(GET_OBJ_VAL(j, 3)));
d1042 1
a1042 1
    sprintf(buf, "Spell: %s at level %d, %d (of %d) charges remaining",
d1047 1
a1047 5
    if (GET_OBJ_VAL(j, 3) >= 0 && GET_OBJ_VAL(j, 3) <= TYPE_STAB - TYPE_HIT)
      strcpy(buf2, attack_hit_text[GET_OBJ_VAL(j, 3)].singular);
    else
      strcpy(buf2, "<&1INVALID&0>");
    sprintf(buf, "Todam: %dd%d, Message type: %d, '%s'",
d1049 4
a1052 1
            buf2);
d1055 1
a1055 1
    sprintf(buf, "AC-apply: [%d]", GET_OBJ_VAL(j, 0));
d1058 1
a1058 1
    sprintf(buf, "Spell: %d, - Hitpoints: %d",
d1064 1
a1064 1
      sprintf(buf, "Weight capacity: %d, Lock Type: %s, Key Num: %d, Corpse: %s",
d1069 2
a1070 2
      sprintf(buf, "Weight capacity: %d, Index: %d, Corpse: %s, Player "
	      "Corpse: %s, Raisable: %s", GET_OBJ_VAL(j,0), GET_OBJ_VAL(j,2), 
d1078 1
a1078 1
    sprintf(buf, "Capacity: %d, Contains: %d, Poisoned: %s, Liquid: %s",
d1083 1
a1083 1
    sprintf(buf, "Tongue: %d", GET_OBJ_VAL(j, 0));
a1085 1
    strcpy(buf, "");
d1088 2
a1089 2
    sprintf(buf, "Makes full: %d, Poisoned: %s", GET_OBJ_VAL(j, 0),
	    YESNO(IS_POISONED(j)));
d1092 1
a1092 1
    sprintf(buf, "Coins: %d", GET_OBJ_VAL(j, 0));
d1095 3
a1097 3
    sprintf(buf, "Values 0-3: [%d] [%d] [%d] [%d]",
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
	    GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
a1099 1
  send_to_char(strcat(buf, "\r\n"), ch);
d1107 1
a1107 1
    sprintf(buf, "\r\nContents:%s", CCGRN(ch, C_NRM));
d1109 5
a1113 8
      sprintf(buf2, "%s %s", found++ ? "," : "", j2->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j2->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
d1117 3
a1119 3
    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
d1121 1
d1123 1
a1123 1
  send_to_char("Affections:", ch);
d1127 1
a1127 1
      sprintf(buf, "%s %+d to %s", found++ ? "," : "",
a1128 1
      send_to_char(buf, ch);
d1130 1
a1130 4
  if (!found)
    send_to_char(" None", ch);
  
  send_to_char("\r\n", ch);
d1132 4
a1135 1
  if (GET_OBJ_TYPE(j) == ITEM_SPELLBOOK) stat_spellbook(j, ch);
d1137 2
a1138 1
  stat_extra_descs(j->ex_description, ch, FALSE);
d1143 1
a1143 1
    sprintf(buf, "Events: %s", eventname(e));
d1146 1
a1146 1
      sprintf(buf, "%s %s", buf, eventname(e));
d1148 1
a1148 2
    sprintf(buf, "%s\r\n", buf);
    send_to_char(buf, ch);
d1150 1
a1150 1
    send_to_char("No events.\r\n", ch);
d1154 4
a1157 1
  do_sstat_object(ch, j);
d1178 4
a1181 2
      else
         stat_extra_descs(world[tmp].ex_description, ch, TRUE);
d1197 4
a1200 2
         else
            stat_extra_descs(obj_proto[r_num].ex_description, ch, TRUE);
d1202 2
a1203 1
         stat_extra_descs(obj->ex_description, ch, TRUE);
d5485 4
@


1.220
log
@Removing the listclass and listrace commands.  Their functionality
is now part of the show command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.219 2008/02/05 03:07:26 myc Exp myc $
d1267 1
d1269 3
a1271 2
    pos += sprintf(pos, "Deity: %s, ",
            GET_DIETY(ch) ? Dieties[(int) GET_DIETY(ch)].diety_name : "None");
d5505 4
@


1.219
log
@Fixing minor bug in list_zone_commands_room.  Removing old
implementation of snum.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.218 2008/02/04 01:48:53 myc Exp myc $
d49 1
a525 20
ACMD(do_listclass)
{
   int i;

   sprintf(buf, "Fiery Classes:\r\n-_-_-_-_-_-_-\r\n");
   for (i = 0; i < NUM_CLASSES; i++)
      sprintf(buf, "%s  %s\r\n", buf, classes[i].displayname);
   page_string(ch->desc, buf, 1);
}

ACMD(do_listrace)
{
   int i;

   sprintf(buf, "Fiery Races:\r\n-_-_-_-_-_-\r\n");
   for (i = 0; i < NUM_RACES; i++)
      sprintf(buf, "%s  %s\r\n", buf, races[i].fullname);
   page_string(ch->desc,buf,1);
}

d3277 1
a3300 1
    { "spells",		LVL_IMMORT },
d3525 54
a3578 7
/*
    { "classes",	LVL_IMMORT },
    { "races",		LVL_IMMORT },
    { "exp",		LVL_IMMORT },
    { "spells",		LVL_IMMORT },
    { "snoop",		LVL_GOD },
*/
d5503 4
@


1.218
log
@Removing the old implementations of znum and zlist.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.217 2008/02/04 01:46:12 myc Exp myc $
a670 13


ACMD(do_snum)
{
   int vnum_shop(char *searchname, struct char_data * ch);
   one_argument(argument, arg);

   if (!*arg)
      send_to_char("Usage: snum <name>\r\n", ch);
   else if (!vnum_shop(arg, ch))
      send_to_char("No shops by that name.\r\n", ch);
}

a723 1
        cmd_room = ZOCMD.arg1;
d5475 3
@


1.217
log
@Making print_zone_to_buf return a value so it can be used by
vsearch.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.216 2008/02/04 00:22:05 myc Exp myc $
a683 10
ACMD(do_znum)
{
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Usage: znum <name>\r\n", ch);
  else if (!vnum_zone(arg, ch))
    send_to_char("No zones by that name.\r\n", ch);
}

a4876 71
ACMD(do_zlist)
{
   int first, second = -1, i;
   char zonebuf[50000];
   bool any;

   two_arguments(argument, buf, buf2);

   if (*buf) {
      if (!strcmp(".", buf))
         first = -1;
      else {
         first = atoi(buf);
         if (first < 0 || first > MAX_VNUM) {
            sprintf(buf, "Values must be between 0 and %d.\n\r", MAX_VNUM);
            send_to_char(buf, ch);
            return;
         }
      }
   } else {
      first = 0;
      second = MAX_VNUM;
   }

   if (*buf2) {
      second = atoi(buf2);
      if (second < 0 || second > MAX_VNUM) {
         sprintf(buf, "Values must be between 0 and %d.\n\r", MAX_VNUM);
         send_to_char(buf, ch);
         return;
      }
      if (first >= 0 && first > second) {
         send_to_char("The first parameter must be less than the second.\r\n", ch);
         return;
      }
   }

   buf[0] = '\0';

   if (first == -1) {
      print_zone_to_buf(buf, world[ch->in_room].zone);
      send_to_char(buf, ch);
   } else if (first >= 0 && second == -1) {
       i = find_zone(first);
       if (i == -1) {
          sprintf(buf, "%d is not a valid zone.\r\n", first);
          send_to_char(buf, ch);
          return;
       }
       print_zone_to_buf(buf, i);
       send_to_char(buf, ch);
   } else {
      any = FALSE;
      zonebuf[0] = '\0';
      for (i = 0; i <= top_of_zone_table; i++) {
         if (zone_table[i].number >= first && zone_table[i].number <= second) {
            any = TRUE;
            print_zone_to_buf(buf, i);
            sprintf(zonebuf, "%s%s", zonebuf, buf);
            buf[0] = '\0';
         }
      }
      if (!any) {
         send_to_char("There are no zones in that range.\r\n", ch);
      } else {
         page_string(ch->desc, zonebuf, 1);
      }
   }
}


d5489 4
@


1.216
log
@Making stat char use the pager.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.215 2008/02/02 19:38:20 myc Exp myc $
d3301 1
a3301 1
void print_zone_to_buf(char *bufptr, int zone)
d3303 2
a3304 1
  sprintf(bufptr, "%s%3d %-30.30s Age: %3d; Reset: %3d (%1d); ZF:%d: Top: %5d\r\n",
d3307 2
a3308 1
	  zone_table[zone].reset_mode, zone_table[zone].zone_factor, zone_table[zone].top);
d5570 3
@


1.215
log
@Adding 'permanent titles' to players, so they can switch between
any of the titles they've earned.  These permanent titles may be
modified by gods using the set command.  They are shown on stat.
Cleaning up the existing do_show code too.  Fixed a bunch of
tiny bugs in do_set that would have allowed memory leaks to occur.
Returning from do_set is generally not a good idea, since the
vict may need to be freed at the end.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.214 2008/01/29 21:02:31 myc Exp myc $
d1273 1
a1273 1
void do_stat_character(struct char_data * ch, struct char_data * k/*, struct descriptor_data * d*/)
d1282 1
d1284 3
d1288 3
a1290 3
  sprintf(buf2, "%s '%s'  IDNum: [%5ld], In room [%5d]\r\n",
	  (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
	  GET_NAME(k), GET_IDNUM(k), 
a1291 1
  send_to_char(buf2, ch);
d1293 4
a1296 6
  /* Mob specific data. */
  if (IS_MOB(k)) {
    sprintf(buf, "Alias: %s, VNum: [%5d], RNum: [%5ld]\r\n",
	    k->player.name, GET_MOB_VNUM(k), GET_MOB_RNUM(k));
    send_to_char(buf, ch);
  }
d1300 2
a1301 1
    sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : "<None>\r\n"));
d1303 2
a1304 2
    sprintf(buf, "Title: %s\r\n", (k->player.title ? k->player.title : "<None>"));
  send_to_char(buf, ch);
d1308 5
a1312 8
  if (IS_NPC(k))
    sprintf(buf, "Race: %s, Race Align: %s, ", RACE_PLAINNAME(k), RACE_ALIGN_ABBR(k));
  else
    sprintf(buf, "Race: %s, Race Align: %s, Deity: %s, ", RACE_ABBR(k),
	    RACE_ALIGN_ABBR(k),((GET_DIETY(ch)) ? "None" :
            Dieties[(int)GET_DIETY(ch)].diety_name));  
  send_to_char(buf,ch);

d1314 7
a1320 10
  sprintf(buf, "Size: %s, Sex: %s\r\n", SIZE_ABBR(k), buf1);
  send_to_char(buf, ch);
  
  strcpy(buf, "Class: ");
  strcat(buf, CLASS_FULL(k));
  sprintf(buf, "%s, Lev: [%s%2d%s], XP: [%s%7ld%s], Align: [%4d]\r\n",
	  buf, CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
	  CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
	  GET_ALIGNMENT(k));
  send_to_char(buf, ch);
d1327 3
a1329 1
    sprintf(buf, "Created: [%s], Last Logon: [%s], Played: [%dh %dm]\r\n",
d1331 1
a1331 4
	    ((k->player.time.played / 3600) % 60));
    send_to_char(buf, ch);
    
    sprintf(buf, "Age: [%d], Hometown: [%d], Speaks: [%d/%d/%d]",
d1334 1
d1338 2
a1339 2
        sprintf(buf, "%s, Clan: [%s], Rank: [%d]", buf,
              clans[clan].abbreviation, GET_CLAN_RANK(k));
d1341 1
a1341 1
        strcat(buf, ", Clan: [Invalid]");
d1343 1
d1346 1
a1346 1
      sprintf(buf, "%s, OLC Zones: [%d/%d/%d/%d/%d]", buf, 
d1350 2
a1351 2
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
d1355 2
a1356 1
  sprintf(buf, "         STR   INT   WIS   DEX   CON   CHA\r\n"
a1368 1
  send_to_char(buf, ch);
d1370 2
a1371 1
  sprintf(buf, "HP: [%s%d/%d+%d%s]  MP: [%s%d/%d+%d%s]  MV: [%s%d/%d+%d%s]\r\n",
a1374 1
  send_to_char(buf, ch);
d1376 1
a1376 1
  sprintf(buf, "Coins: [%s%d%sp / %s%s%d%sg / %s%d%ss / %s%d%sc], "
a1385 1
  send_to_char(buf, ch);
d1387 1
a1387 1
  sprintf(buf, "AC: [%d/10], Hitroll: [%2d], Damroll: [%2d], "
d1389 1
a1389 1
               "Perception: [%4ld], Hiddenness: [%4ld]\r\n",
d1395 1
a1395 3
          GET_PERCEPTION(k), GET_HIDDENNESS(k));
  send_to_char(buf, ch);

d1399 1
a1399 1
  sprintf(buf, "Pos: %s", buf1);
d1402 1
a1402 1
    sprintf(buf, "%s, Default Pos: %s", buf, buf1);
d1404 1
a1404 1
  sprintf(buf, "%s, Fighting: %s", buf,
d1407 1
a1407 1
    sprintf(buf, "%s, %s into: %s", buf,
d1410 1
a1410 1
  send_to_char(strcat(buf, "\r\n"), ch);
d1412 1
a1412 1
  *buf = '\0';
d1414 1
a1414 1
    sprintf(buf, "Idle: [%d tic%s], Chant Timer: [%d tic%s]",
d1420 2
a1421 2
    sprinttype(k->desc->connected, connected_types, buf2);
    sprintf(buf, "%s%sConnected: %s", buf, *buf ? ", " : "", buf2);
d1424 1
a1424 1
    sprintf(buf, "%s%s%s into by: %s", buf, *buf ? ", " : "",
d1427 2
a1428 2
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
d1436 2
a1437 2
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d, "
                 "Attack type: %s\r\n",
a1440 1
    send_to_char(buf, ch);
d1449 1
a1449 1
    sprintf(buf, "NPC flags: %s%s%s\r\n",
a1450 1
    send_to_char(buf, ch);
d1454 1
a1454 2
    sprintf(buf, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
d1456 1
a1456 2
    sprintf(buf, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
d1465 3
a1467 3
  sprintf(buf, "Max Carry: %d (%d weight); "
               "Carried: %d (%d weight); "
               "Worn: %d (%d weight)\r\n",
a1470 1
  send_to_char(buf, ch);
d1473 1
a1473 1
  strcpy(buf, "Hunger: ");
d1475 1
a1475 1
    strcat(buf, "Off");
d1477 2
a1478 2
    sprintf(buf, "%s%d", buf, GET_COND(k, FULL));
  strcat(buf, ", Thirst: ");
d1480 1
a1480 1
    strcat(buf, "Off");
d1482 2
a1483 2
    sprintf(buf, "%s%d", buf, GET_COND(k, THIRST));
  strcat(buf, ", Drunk: ");
d1485 1
a1485 1
    strcat(buf, "Off\r\n");
d1487 1
a1487 2
    sprintf(buf, "%s%d\r\n", buf, GET_COND(k, DRUNK));
  send_to_char(buf, ch);
d1490 1
a1490 1
  sprintf(buf, "Consented: %s, Master is: %s, Followers are:",
d1496 3
a1498 6
    if (strlen(buf) + strlen(PERS(fol->follower, ch)) >= 78) {
      if (found)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
        send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
d1500 1
a1500 1
    sprintf(buf, "%s%s %s", buf, found++ ? "," : "", PERS(fol->follower, ch));
d1502 2
a1503 2
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
d1506 1
a1506 1
  sprintf(buf, "&0&2&bGroup Master&0 is: %s, &0&2&bgroupees are:&0",
d1511 3
a1513 6
    if (strlen(buf) + strlen(PERS(g->groupee, ch)) >= 78) {
      if (found)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
d1515 1
a1515 1
    sprintf(buf, "%s%s %s", buf, found++ ? "," : "", PERS(g->groupee, ch));
d1517 2
a1518 2
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
d1521 1
a1521 1
  sprintf(buf, "&0&1Major Group Master&0 is: %s, &0&1major groupees are:&0",
d1526 17
a1542 20
    if (strlen(buf) + strlen(PERS(mg->mgroupee, ch)) >= 78) {
      if (found)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
    sprintf(buf, "%s%s %s", buf, found++ ? "," : "", PERS(mg->mgroupee, ch));
  }
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);

  sprintf(buf, "Guarding : %s, Guarded by : %s", 
	  k->guarding ? GET_NAME(k->guarding) : "<none>",
	  k->guarded_by ? GET_NAME(k->guarded_by) :"<none>");
  sprintf(buf, "%s\r\nCornering : %s, Cornered by : %s", buf, 
	  k->cornering ? GET_NAME(k->cornering) : "<none>",
	  k->cornered_by ? GET_NAME(k->cornered_by) :"<none>");
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
d1545 14
a1558 10
  sprintf(buf, "AFF: %s", CCYEL(ch, C_NRM));
  if (AFF_FLAGS(k))
    sprintbit(AFF_FLAGS(k), affected_bits, buf + strlen(buf));
  if (AFF2_FLAGS(k))
    sprintbit(AFF2_FLAGS(k), affected_bits2, buf + strlen(buf));
  if (AFF3_FLAGS(k) || !(AFF_FLAGS(k) || AFF2_FLAGS(k)))
    sprintbit(AFF3_FLAGS(k), affected_bits3, buf + strlen(buf));
  strcat(buf, "\r\n");
  strcat(buf, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
d1562 1
a1562 1
    strcpy(buf, "Spells MEMMED: ");
d1565 3
a1567 3
      sprintf(buf, "%s%d/%d ", buf, GET_MEM_MEMED(k, i),
              spells_of_circle[(int) GET_LEVEL(k)][i]);
    send_to_char(strcat(buf, "\r\n"), ch);
a1573 1
      *buf2 = '\0';
d1575 2
a1576 2
        sprintf(buf, "SPL: (perma) %s%-21s%s ",
		CCCYN(ch, C_NRM), skills[aff->type].name, CCNRM(ch, C_NRM));
d1578 2
a1579 2
	sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
		CCCYN(ch, C_NRM), skills[aff->type].name, CCNRM(ch, C_NRM));
d1581 17
a1597 15
	sprintf(buf, "%s%+d to %s", buf,
                aff->modifier, apply_types[(int) aff->location]);
      if (aff->bitvector || aff->bitvector2 || aff->bitvector3) {
        if (aff->modifier)
          strcat(buf, ", sets ");
        else
          strcat(buf, "sets ");
      }
      if (aff->bitvector)
	sprintbit(aff->bitvector, affected_bits, buf + strlen(buf));
      if (aff->bitvector2)
	sprintbit(aff->bitvector2, affected_bits2, buf + strlen(buf));
      if (aff->bitvector3)
	sprintbit(aff->bitvector3, affected_bits3, buf + strlen(buf));
      send_to_char(strcat(buf, "\r\n"), ch);
d1606 1
a1606 1
          sprintf(buf, "Quest %s: ", all_quests[a].quest_name);
d1608 1
a1608 1
            strcat(buf, "Completed\r\n");
d1610 1
a1610 1
            strcat(buf, "Failed\r\n");
d1612 1
a1612 2
            sprintf(buf, "%sStage %d\r\n", buf, quest->stage);
          send_to_char(buf, ch);
d1624 1
a1624 1
    sprintf(buf, "Events: %s", eventname(e));
d1627 1
a1627 1
      sprintf(buf, "%s %s", buf, eventname(e));
d1629 1
a1629 2
    sprintf(buf, "%s\r\n", buf);
    send_to_char(buf, ch);
d1631 1
a1631 1
    send_to_char("No events.\r\n", ch);
d1635 4
a1638 2
  if (IS_NPC(k))
    do_sstat_character(ch, k);
d1646 1
a1646 1
          send_to_char("Permanent Titles:\r\n", ch);
d1649 1
a1649 2
        sprintf(buf, "  %d) %s\r\n", i + 1, GET_PTITLE(k, i));
        send_to_char(buf, ch);
d1652 2
d5568 9
@


1.214
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.213 2008/01/29 16:51:12 myc Exp myc $
d1655 14
d3150 1
a3150 1
    return;   
a3328 1
  char self = 0;
d3352 6
a3357 1
    { "notes",          LVL_IMMORT }, 
d3386 1
a3386 2
  if (!strcmp(value, "."))
    self = 1;
d3388 1
d3390 2
a3391 6
  case 1:			/* zone */
    /* tightened up by JE 4/6/93 */
    /* Strong desire to smak JE -RSD 2/15/00 */
    /* So many zones we were overwriting buf when showing all zones.
     * fixed -321 2/15/00 */
    if (self) {
d3394 7
a3400 13
    } else if (*value && is_number(value)) {
       i = find_zone(atoi(value));
       if (i == -1) {
         send_to_char("That is not a valid zone.\r\n", ch);
         return;
       }
       print_zone_to_buf(buf, i);
       send_to_char(buf, ch);
    } else {
      for (i = 0; i <= top_of_zone_table; i++) {
	print_zone_to_buf(buf, i);                   /* put single zone referenced in this pass of the for loop */
	sprintf(zonebuf, "%s%s", zonebuf, buf);      /* into buf, then send the line to the player, then clear */
	buf[0] = '\0';                               /* out buf so it's empty for the next pass of the loop    */
d3402 4
a3405 2
      /* 3/3/01 - David Endre
         Added the page function */
d3409 2
a3410 1
  case 2:			/* player */
a3419 7
    sprintf(buf, "Player: %-12s (%s) [%2d %s]\r\n", vbuf.name,
      genders[(int) vbuf.sex], vbuf.level, classes[(int)vbuf.class].abbrev);
    sprintf(buf, "%sCoins held: [%dp / %dg / %ds / %dc]\r\nCoins banked: [%ldp / %ldg / %lds / %ldc]\r\n  Exp: %-8ld  Align: %-5d  Lessons: %-3d\r\n",	    buf, vbuf.points.coins.plat, vbuf.points.coins.gold, vbuf.points.coins.silver,
		vbuf.points.coins.copper, vbuf.points.coins.bank_plat, vbuf.points.coins.bank_gold,
		vbuf.points.coins.bank_silver, vbuf.points.coins.bank_copper, vbuf.points.exp,
	    vbuf.char_specials_saved.alignment,
	    vbuf.player_specials_saved.spells_to_learn);
d3422 14
a3435 3
   sprintf(buf,
	    "%sStarted: %s  Last: %s  Played: %3dh %2dm\r\n",
	    buf, buf1, buf2, (int) (vbuf.played / 3600),
d3439 6
a3444 2
  case 3:
    Crash_listrent(ch, value);
d3446 3
a3448 5
  case 4:
    i = 0;
    j = 0;
    k = 0;
    con = 0;
d3460 14
a3473 11
    sprintf(buf, "Current stats:\r\n");
    sprintf(buf, "%s  %5d players in game  %5d connected\r\n", buf, i, con);
    sprintf(buf, "%s  %5d registered\r\n", buf, top_of_p_table + 1);
    sprintf(buf, "%s  %5d mobiles          %5d prototypes\r\n",
	    buf, j, top_of_mobt + 1);
    sprintf(buf, "%s  %5d objects          %5d prototypes\r\n",
	    buf, k, top_of_objt + 1);
    sprintf(buf, "%s  %5d rooms            %5d zones\r\n",
	    buf, top_of_world + 1, top_of_zone_table + 1);
    sprintf(buf, "%s  %5d large bufs\r\n", buf, buf_largecount);
    sprintf(buf, "%s  %5d buf switches     %5d overflows\r\n", buf,
a3476 3
  case 5: /* ERROR */
    /* I completely redid this section.  No more crashes. */
    /* -fingon */
d3478 1
d3481 15
a3495 12
      if ((zone_table[i].top)) {
        for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
          if ((rrn=real_room(rn)) != NOWHERE) {
	    for (j = 0, k = 0; j < NUM_OF_DIRS; j++) {
	      if (world[rrn].dir_option[j] && world[rrn].dir_option[j]->to_room == 0) {
		k++;
	      }
	    }
	    if(k) {
	      sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, k, world[rrn].number,
		      world[rrn].name);
	    }
d3498 5
a3506 4
  case 6: /* DEATH */
    
    /* I completely redid this section.  No more crashes. */
    /* -fingon */
d3508 1
d3511 8
a3518 9
      if ((zone_table[i].top)) {
        for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
          if ((rrn=real_room(rn)) != NOWHERE) {
            if (IS_SET(ROOM_FLAGS(rrn), ROOM_DEATH)) {
    	      sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, j++,
		      world[rrn].number, world[rrn].name);
            }
          }
        }
a3522 4
  case 7:

    /* This also has been completely redone */
    /* --Fingon */
d3524 1
d3527 8
a3534 9
      if ((zone_table[i].top)) {
        for (rn = (100 * zone_table[i].number); rn <= zone_table[i].top; rn++) {
          if ((rrn=real_room(rn)) != NOWHERE) {
            if (IS_SET(ROOM_FLAGS(rrn), ROOM_GODROOM)) {
    	      sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, j++,
		      world[rrn].number, world[rrn].name);
            }
          }
        }
d3539 2
a3540 1
  case 8:
d3543 2
a3544 1
  case 9:
d3547 2
a3548 1
  case 10:
d3551 2
a3552 1
  case 11:
a3556 1

d3558 1
a3558 1
      send_to_char("Couldn't find that player.\r\n", ch); 
a3560 1

d3562 1
a3562 1
      FILE* i = fopen(value2, "rt"); 
d3564 2
a3565 2
	send_to_char("There are no notes for that file.\r\n", ch); 
	return; 
d3567 1
a3567 3

      zonebuf[0] = '\0'; 

d3569 2
a3570 3
	strcat(zonebuf, value3); 
	strcat(zonebuf, "\r\n"); 

d3572 2
a3573 2
	  strcat(zonebuf, "Max note length exceeded.\r\n"); 
	  break; 
d3576 2
a3577 4

      fclose(i); 

      page_string(ch->desc, zonebuf,1); 
d3579 1
a3579 2
    
    
d3581 7
a3587 1
    break; 
d3617 1
a3617 1
  char is_file = 0, is_mob = 0, is_player = 0;
d3701 1
d3797 1
a3797 1
  strcpy(buf, "Okay.");  /* can't use OK macro here 'cause of \r\n */
a3805 5
    if ( GET_LEVEL(ch) < 75)
    {
       send_to_char("You aren't high enough to give out titles!\r\n", ch);
       return;
    }
d3807 1
a3807 1
    sprintf(buf, "%s's title is now: %s", GET_NAME(vict), GET_TITLE(vict));
a3898 4
	  if (IS_NPC(vict)) {
		  send_to_char("That is a mob Sir, Proky won't allow that.\r\n", ch);
		  return;
	  }
d3914 3
a3916 2
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return;
d3922 3
a3924 2
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return;
d3931 1
d3945 1
a3945 1
      sprintf(buf, "%s's %s now off.", GET_NAME(vict), fields[l].cmd);
d3950 1
a3950 1
      sprintf(buf, "%s's %s set to %d.", GET_NAME(vict), fields[l].cmd,
d3953 3
a3955 2
      send_to_char("Must be 'off' or a value from 0 to 24.\r\n", ch);
      return;
d3957 1
a3957 1
	check_regen_rates(vict);
d3967 3
a3969 2
      send_to_char("You can't do that.\r\n", ch);
      return;
d3982 3
a3984 2
      send_to_char("No room exists with that number.\r\n", ch);
      return;
d4002 4
a4005 2
    if ((i = parse_class(ch, vict, val_arg)) == CLASS_UNDEFINED)
      return;
d4040 2
a4041 1
	sprintf(buf, "That room does not exist!");
d4045 1
d4057 2
a4058 1
    if (!is_file)
d4060 1
d4062 11
a4072 6
      send_to_char("Please don't use this command, yet.\r\n", ch);
      return;
    } 
    if (GET_LEVEL(vict) > LVL_HEAD_C) {
      send_to_char("You cannot change that.\r\n", ch);
      return;
a4073 3
    strncpy(tmp_store.pwd, CRYPT(val_arg, tmp_store.name), MAX_PWD_LENGTH);
    tmp_store.pwd[MAX_PWD_LENGTH] = '\0';
    sprintf(buf, "Password changed to '%s'.", val_arg);
d4087 4
a4090 2
    if ((i = parse_race(ch, vict, val_arg)) == RACE_UNDEFINED)
      return;
d4146 3
a4148 4
    if((i = parse_diety(vict, *val_arg)) == INVALID_DIETY)
    {
       send_to_char("That's not a valid deity.\r\n", ch);
       return;
d4155 1
a4155 1
    send_to_char("Frag list wont be updated till next boot\r\n", ch);
d4184 12
d4208 1
a4208 2
  } else if (buf[0])
    strcat(buf, "\r\n");
d4212 1
a4212 1
  if (!is_file && !IS_NPC(vict))
d4216 5
a4220 2
    char_to_store(vict, &tmp_store);
    save_char_file_u(tmp_store);
a4221 1
    send_to_char("Saved in file.\r\n", ch);
d5324 1
a5324 1
    strcpy(buf, "USAGE: file <option> <num lines>\r\n\r\nFile options:\r\n");
d5583 4
@


1.213
log
@Moving skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.212 2008/01/27 21:09:12 myc Exp myc $
d44 1
a49 13
extern int spells_of_circle[(LVL_IMPL + 1)][(NUM_SPELL_CIRCLES + 1)];
extern struct room_data *world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct descriptor_data *descriptor_list;
/*extern struct title_type titles[NUM_CLASSES][LVL_IMPL + 1];*/
extern struct player_index_element *player_table;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct int_app_type int_app[];
extern struct wis_app_type wis_app[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;
a52 6
extern int top_of_world;
extern int top_of_mobt;
extern int top_of_objt;
extern int top_of_p_table;
extern int rev_dir[];
extern int top_of_p_table;
a71 36
/* for objects */
extern char *item_types[];
extern char *wear_bits[];
extern char *extra_bits[];
extern char *container_bits[];
extern char *drinks[];

/* for rooms */
extern char *dirs[];
extern char *room_bits[];
extern char *exit_bits[];
extern char *sector_types[];

/* for zones */
extern struct climate_data climates[];

/* for chars */
extern char *genders[];
extern char *equipment_types[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern char *apply_types[];
extern char *npc_class_types[];
extern char *action_bits[];
extern char *action_bits2[];
extern char *player_bits[];
extern char *preference_bits[];
extern char *position_types[];
extern char *connected_types[];
extern char *race_abbrevs[];
extern struct index_data *obj_index;
extern struct obj_data *obj_proto;
extern int top_of_objt;
extern const struct str_app_type str_app[];

a726 1
  extern struct char_data *mob_proto;
a862 1
  extern char *room_affections[];
a867 1
  extern struct raff_node *raff_list;
a1280 1
  extern struct quest_info *all_quests;
a1906 1
  extern struct player_index_element *player_table;
a3319 1
  extern char *genders[];
d4186 1
a4186 1
static char *logtypes[] = {
a5025 1
  extern char *languages[];
d5543 3
@


1.212
log
@Added rage to set command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.211 2008/01/27 13:43:50 jps Exp myc $
d1018 1
a1018 1
              raff->timer, skillnames[raff->spell], buf2);
d1062 1
a1062 1
            list_buf, spage, fpage, skillnames[spell_array[0][index]]);
d1652 1
a1652 1
		CCCYN(ch, C_NRM), skillnames[aff->type], CCNRM(ch, C_NRM));
d1655 1
a1655 1
		CCCYN(ch, C_NRM), skillnames[aff->type], CCNRM(ch, C_NRM));
d5073 1
a5073 1
        if  (is_abbrev(arg, skillnames[aff->type]))
d5079 1
a5079 1
        if  (is_abbrev(arg, skillnames[aff->type]))
d5604 3
@


1.211
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.210 2008/01/27 11:16:14 jps Exp jps $
d3740 1
d4214 3
d5604 3
@


1.210
log
@Moved newbie eq generation to class.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.209 2008/01/27 09:45:41 jps Exp jps $
a120 1
extern char *mspecies_types[];
d1365 1
a1365 1
    sprintf(buf, "Species: %s, Race Align: %s, ", mspecies_types[(int)GET_SPECIES(k)], RACE_ALIGN_ABBR(k));
d5600 3
@


1.209
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.208 2008/01/26 14:26:31 jps Exp jps $
a5018 61

/*To change newbie eq change array in structs.h Banyal*/
void do_newbie(struct char_data *vict)
{
  struct obj_data *obj;
  extern int warrior_eq[];
  extern int priest_eq[];
  extern int shaman_eq[];
  extern int thief_eq[];
  extern int mage_eq[];
  int i;

  if (GET_LEVEL(vict) < 5) {
 switch (GET_CLASS(vict)) {  
   case CLASS_WARRIOR:
   case CLASS_RANGER:
  for (i = 0; warrior_eq[i] != -1; i++) {
    obj = read_object(warrior_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
  
   }
   break;
   case CLASS_CLERIC:
   case CLASS_DRUID:
   for (i = 0; priest_eq[i] != -1; i++) {
    obj = read_object(priest_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
   }
   break;
   case CLASS_SHAMAN:
   for (i = 0; shaman_eq[i] != -1; i++) {
    obj = read_object(shaman_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
  
   }
   break;
   case CLASS_ROGUE:
   case CLASS_THIEF: 
   case CLASS_ASSASSIN:
   for (i = 0; thief_eq[i] != -1; i++) {
    obj = read_object(thief_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
   }
   break;
   case CLASS_SORCERER:
   for (i = 0; mage_eq[i] != -1; i++) {
    obj = read_object(mage_eq[i], VIRTUAL);
    obj_to_char(obj, vict);
  
   }
  break;
  default:
  for (i = 0; warrior_eq[i] != -1; i++) {
    obj = read_object(warrior_eq[i], VIRTUAL);
    obj_to_char(obj, vict); 
  }
  break;
  }
}
}

d5601 4
@


1.208
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.207 2008/01/25 21:05:45 myc Exp jps $
a121 1
extern char *mclass_types[];
d1378 1
a1378 5
  if (IS_NPC(k))
    sprinttype(k->player.class + 1, mclass_types, buf2);
  else
    strcpy(buf2, CLASS_WIDE(k));
  strcat(buf, buf2);
d5662 3
@


1.207
log
@Renamed monk_weight_pen to monk_weight_penalty.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.206 2008/01/20 22:58:39 myc Exp $
d43 1
a107 1
extern char *spells[];
d1020 1
a1020 1
              raff->timer, spells[raff->spell], buf2);
a1032 1
   extern char *spells[];
d1064 1
a1064 1
            list_buf, spage, fpage, spells[spell_array[0][index]]);
d1658 1
a1658 1
		CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));
d1661 1
a1661 1
		CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));
d5136 1
a5136 1
        if  (is_abbrev(arg,spells[aff->type]))
d5142 1
a5142 1
        if  (is_abbrev(arg,spells[aff->type]))
d5667 3
@


1.206
log
@Don't replace the prompt when switching into someone unless they don't
have a prompt or they are an NPC.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.205 2008/01/17 19:23:07 myc Exp myc $
d1459 3
a1461 3
	  GET_AC(k) + 5 * monk_weight_pen(k),
          GET_HITROLL(k) - monk_weight_pen(k),
          GET_DAMROLL(k) - monk_weight_pen(k),
d5668 4
@


1.205
log
@Moved find_target_room_mscript to dg_mobcmd.c and renamed it
find_mob_target_room.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.204 2008/01/17 01:29:10 myc Exp myc $
d1964 2
a1965 1
    GET_PROMPT(victim) = str_dup(GET_PROMPT(ch));
d5668 4
@


1.204
log
@Fixed that pesky bug with 'set maxhit' where it wouldn't count hp applies.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.203 2008/01/14 20:38:42 myc Exp myc $
a515 59
/* find_target_room_mscript is for mob triggers.
 * It will always detect, except when the target is wizinvis. */
int find_target_room_mscript(struct char_data * ch, char *rawroomstr)
{
  extern struct obj_data *get_obj_vis_mscript(struct char_data * ch, char *name);
  extern struct char_data *get_char_vis_mscript(struct char_data * ch, char *name);

  int tmp;
  int location;
  struct char_data *target_mob;
  struct obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];
  
  one_argument(rawroomstr, roomstr);
  
  if (!*roomstr) {
    send_to_char("You must supply a room number or name.\r\n", ch);
    return NOWHERE;
  }
  if (isdigit(*roomstr) && !strchr(roomstr, '.')) {
    tmp = atoi(roomstr);
    if ((location = real_room(tmp)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return NOWHERE;
    }
  } else if ((target_mob = get_char_vis_mscript(ch, roomstr)))
    location = target_mob->in_room;
  else if ((target_obj = get_obj_vis_mscript(ch, roomstr))) {
    if (target_obj->in_room != NOWHERE)
      location = target_obj->in_room;
    else {
      send_to_char("That object is not available.\r\n", ch);
      return NOWHERE;
    }
  } else {
    send_to_char("No such creature or object around.\r\n", ch);
    return NOWHERE;
  }
  /* a location has been found -- if you're < GRGOD, check restrictions. */
  if (GET_LEVEL(ch) < LVL_GOD) {
    if (ROOM_FLAGGED(location, ROOM_GODROOM)) {
      send_to_char("You are not godly enough to use that room!\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room) {
      send_to_char("There's a private conversation going on in that room.\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_HOUSE) &&
	!House_can_enter(ch, world[location].number)) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return NOWHERE;
    }
  }
  return location;
}


d5667 3
@


1.203
log
@'set room' shouldn't work when loading from file.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.202 2008/01/10 23:11:51 myc Exp myc $
d143 1
d3922 2
a3923 4
    vict->points.max_hit = RANGE(1, 500000);
    GET_NATHPS(vict) = vict->points.max_hit;
    affect_total(vict);
    /*con_aff(vict);*/
d5726 3
@


1.202
log
@Incapacitated people will now see realm restores and pains.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.201 2008/01/10 05:39:43 myc Exp myc $
d4093 5
a4097 3
    if (IN_ROOM(vict) != NOWHERE)
    char_from_room(vict);
    char_to_room(vict, i);
d5727 3
@


1.201
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.200 2008/01/09 08:38:13 jps Exp myc $
d2514 1
a2514 1
      act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
d2550 1
a2550 1
      act("A wave of pain and pesilence sent by $N harms you!", FALSE, vict, 0, ch, TO_CHAR);
d5058 1
a5058 1
               FALSE, ch, 0, i, TO_VICT);
d5075 1
a5075 1
               FALSE, ch, 0, i, TO_VICT);
d5725 4
@


1.200
log
@Don't remove hunger and thirst when restoring players, because
that's actually a disadvantage now.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.199 2008/01/09 07:15:44 jps Exp jps $
d2531 1
a2531 1
   alter_hit(vict, change, 1);
d5725 4
@


1.199
log
@Newbie-viciousness now handled elsewhere.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.198 2008/01/09 00:45:22 myc Exp jps $
a2495 2
   gain_condition(vict, THIRST, 100);
   gain_condition(vict, FULL, 100);
d5725 3
@


1.198
log
@Change perform_restore to never lower hp, mana, or move points.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.197 2008/01/07 19:15:56 myc Exp myc $
a5095 3
  /* Set newbies Vicious */
  SET_BIT(PRF_FLAGS(vict), PRF_VICIOUS);

d5727 3
@


1.197
log
@Stat now shows MOB2 flags.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.196 2008/01/07 10:39:28 jps Exp myc $
d2493 3
a2495 3
   GET_HIT(vict) = GET_MAX_HIT(vict);
   GET_MANA(vict) = GET_MAX_MANA(vict);
   GET_MOVE(vict) = GET_MAX_MOVE(vict);
d5730 3
@


1.196
log
@Remove unused extern which is now provided by races.h.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.195 2008/01/05 05:41:49 jps Exp jps $
a1574 1
    *buf1 = '\0';
d1578 1
a1578 1
      sprintbit(MOB2_FLAGS(k), action_bits2, buf2 + strlen(buf1));
d5730 3
@


1.195
log
@Changed name of save_char() to save_player().
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.194 2008/01/04 02:32:35 jps Exp jps $
a120 1
extern char *size_abbrevs[];
d5731 3
@


1.194
log
@Changed do_game() to reflect the changes to races_allowed and
evil_races_allowed, in config.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.193 2008/01/04 01:53:26 jps Exp jps $
a44 1
void set_skills(struct char_data *ch);
d2083 1
a2083 1
    save_char(victim);
a2404 1
  void do_start(struct char_data *ch);
d2453 1
a2453 1
     * do_start will set the player's level to 1.  advance_level (called
d2458 1
a2458 1
    /* Save the victim's playtime since do_start clears it. */
d2460 1
a2460 1
    do_start(victim);
d2486 1
a2486 1
  save_char(victim);
d3060 1
a3060 1
	  init_char(d->character);
d3067 1
a3067 1
        save_char(d->character);
d3138 1
a3138 1
	   save_char(d->character);
d3421 1
a3421 1
    save_char(vict);
a3728 2
  extern void convert_class(struct char_data *ch, int newclass);
  extern void convert_race(struct char_data *ch, int newrace);
d4299 1
a4299 1
    save_char(vict);
d5391 1
a5391 1
    save_char(victim);
d5413 1
a5413 1
       save_char(cbuf);
d5732 4
d5776 1
a5776 1
 * file to show the correct last logon time.  save_char() no longer
@


1.193
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.192 2008/01/03 12:44:03 jps Exp jps $
d74 1
a74 1
extern int good_races_allowed; /* Temp for good races only */
a643 2
   if (!ch)
      return;
d645 1
a645 1
   sprintf(buf, "Fiery Classes:\r\n-_-_-_-_-_-_\r\n");
d653 1
a653 3
  extern char *race_menu;
  if (!ch)
    return;
d655 4
a658 2
  sprintf(buf, "Fiery Races:\r\n-_-_-_-_-_\r\n%s",race_menu);
  page_string(ch->desc,buf,1);
d4444 5
a4448 5
    { "GOOD_RACES",0, &good_races_allowed,    LVL_ADMIN, 
      "[&2&bSYS: %s allows good race logins&0]\r\n",
      "[&1&bSYS: %s disallows good race logins&0]\r\n",
      "Good Race login allowed",
      "Good Race login not allowed" },
a4574 7
  
  
  /* and a few special cases */
  if (commands[i].config == &races_allowed)
    good_races_allowed = 0;
  if (commands[i].config == &good_races_allowed)
    races_allowed = 0;
d5736 4
@


1.192
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.191 2008/01/02 01:04:26 jps Exp jps $
d42 1
a122 1
extern char *race_align_abbrevs[];
a124 1
extern char *race_align_abbrevs[];
a127 1
int set_race_align(struct char_data *ch);
a3731 1
  int parse_race(char arg);
d4194 1
a4194 2
    if ((i = parse_race(*val_arg)) == RACE_UNDEFINED) {
      send_to_char("That is not a real race.\r\n", ch);
d4196 13
d4210 2
a4211 1
    convert_race(vict, i); /* this does it all --gurlaek 7/6/1999 */
d5745 4
@


1.191
log
@Removing unused external function clear_skills().
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.190 2007/12/31 04:00:28 jps Exp jps $
d41 1
a112 1
extern char *pc_class_types[];
d645 8
a652 9
  extern char *class_display[NUM_CLASSES];
  int i;
  if(!ch)
    return;
  
  sprintf(buf, "Fiery Classes:\r\n-_-_-_-_-_-_\r\n");
  for(i=0;i<NUM_CLASSES;i++)
    sprintf(buf,"%s%s\r\n", buf, class_display[i]);
  page_string(ch->desc, buf, 1);
d1447 1
a1447 1
    sprinttype(k->player.class, pc_class_types, buf2);
d2804 1
a2804 2
  struct char_file_u chdata;
  extern char *class_abbrevs[];
d2806 18
a2823 18
  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("For whom do you wish to search?\r\n", ch);
    return;
  }
  if (load_char(arg, &chdata) < 0) {
    send_to_char("There is no such player.\r\n", ch);
    return;
  }
  if ((chdata.level > GET_LEVEL(ch)) && (GET_LEVEL(ch) < LVL_HEAD_B)) {
    send_to_char("You are not sufficiently godly for that!\r\n", ch);
    return;
  }
  sprintf(buf, "[%5ld] [%2d %s] %-12s : %-18s : %-20s\r\n",
	  chdata.char_specials_saved.idnum, (int) chdata.level,
	  class_abbrevs[(int) chdata.class], chdata.name, chdata.host,
	  ctime(&chdata.last_logon));
  send_to_char(buf, ch);
a3452 1
  extern char *class_abbrevs[];
d3544 1
a3544 1
      genders[(int) vbuf.sex], vbuf.level, class_abbrevs[(int) vbuf.class]);
a3733 1
  int parse_class(struct char_data *ch, char arg);
d4120 1
a4120 2
    if ((i = parse_class(vict, *val_arg)) == CLASS_UNDEFINED) {
      send_to_char("That is not a class.\r\n", ch);
d4122 13
d4136 2
a4137 1
    convert_class(vict, i); /* this does it all --gurlaek 7/6/1999 */
d4289 1
a4289 1
  } else
d4291 2
a4292 1
  send_to_char(CAP(buf), ch);
d5136 1
a5136 1
   case CLASS_MAGIC_USER:
d5735 3
@


1.190
log
@restore will now remove harmful spell effects.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.189 2007/12/28 00:51:39 jps Exp jps $
a41 2
/*   external vars  */
/* extern FILE *player_fl; */
a42 1
void clear_skills(struct char_data *ch);
d5725 3
@


1.189
log
@Left something behind in rclone.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.188 2007/12/28 00:44:34 jps Exp jps $
d2502 3
d2527 2
a2536 2
      send_to_char(OK, ch);
      act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
a5056 1
         perform_restore(i);
d5059 1
d5728 3
@


1.188
log
@Fix massively broken do_hhroom (shudder).
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.187 2007/12/25 06:55:14 jps Exp jps $
a5156 2
  CREATE (room, struct room_data, 1);

d5725 3
@


1.187
log
@Make newbies start out vicious.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.186 2007/12/25 06:03:01 jps Exp jps $
d5145 2
d5148 1
a5148 6
/* Only works if you have Oasis OLC */
extern void olc_add_to_save_list(int zone, byte type);

  char buf2[10];
  char buf[80];
  int iroom = 0, rroom = 0;
d5152 4
d5157 1
a5157 1
	CREATE (room, struct room_data, 1);	
d5159 2
a5160 3
	iroom = atoi(buf2);
	rroom = real_room(atoi(buf2));
	*room = world[rroom];
d5162 5
a5166 7
 if (!*buf2) {
    send_to_char("Format: hhroom <room number>\r\n", ch); 
    return; }
 if (rroom <= 0) {
	sprintf(buf, "There is no room with the number %d.\r\n", iroom);
	send_to_char(buf, ch);
	return; }
d5168 1
d5170 1
a5170 2

  if (world[ch->in_room].description) {
d5172 6
a5177 6
  if (world[ch->in_room].name) {
	  world[rroom].name = str_dup(world[ch->in_room].name);}
  if (world[ch->in_room].room_flags) {
        world[rroom].room_flags = world[ch->in_room].room_flags;}
  if (world[ch->in_room].sector_type) { 
       world[rroom].sector_type = world[ch->in_room].sector_type;}
d5179 1
d5181 2
a5182 6
  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);

 sprintf(buf, "You clone this room to room %d.\r\n", iroom);
 send_to_char(buf, ch); }
	else
	send_to_char("This room has no description so why clone it?!\r\n", ch);
d5727 3
@


1.186
log
@Make do_stat_object tell about events as well.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.185 2007/12/25 05:41:49 jps Exp jps $
d5090 4
a5093 2
  
  
d5732 3
@


1.185
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.184 2007/12/23 00:10:13 myc Exp jps $
d1153 1
d1337 14
d5730 5
@


1.184
log
@Stat obj weapon shows message string for damage type.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.183 2007/12/20 23:10:02 myc Exp myc $
d40 1
d1395 1
d1748 1
a1748 1
          send_to_char(buf,ch);
d1757 14
d5715 3
@


1.183
log
@howgood() renamed to proficiency_message().
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.182 2007/12/19 20:37:02 myc Exp myc $
d71 1
d1238 7
a1244 2
    sprintf(buf, "Todam: %dd%d, Message type: %d",
	    GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
a1392 1
  extern struct attack_hit_type attack_hit_text[];
d1553 5
d1562 1
a1562 1
            attack_hit_text[k->mob_specials.attack_type].singular);
d5699 3
@


1.182
log
@Fixed bug in stat char which sometimes read invalid data (when
in_room was -1).  Added clan information to stat char.  Fixed stat
file to show the correct last logon time.  save_char() no longer
requires you to specify the save room (which wasn't being used anyway).
The advance and set level commands now automatically modify clan
power.  Fixed a bug in tedit that caused the wrong strings to be
edited.  I mean aedit, not tedit.  Updated the terminate command
to properly remove a player from a clan.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.181 2007/11/23 20:03:55 jps Exp myc $
a69 1
extern char *howgood(int percent);
d5172 1
d5187 1
a5187 1
		sprintf(buf, "%-20s %s\r\n", languages[(i - ofs)] , howgood(GET_SKILL(ch, i)));
d5689 10
@


1.181
log
@iptables will not add redundant entries. The ports to open are more flexible.
It defaults to "list". You can specify "iptables add me" to add yourself.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.180 2007/11/23 07:13:55 jps Exp jps $
d1394 2
a1395 1
	  GET_NAME(k), GET_IDNUM(k), world[k->in_room].number);
d1451 8
d1805 6
d2052 1
a2052 1
    save_char(victim, NOWHERE);
d2421 7
d2456 1
a2456 1
  save_char(victim, NOWHERE);
d3035 1
a3035 1
        save_char(d->character, NOWHERE);
d3106 1
a3106 1
	   save_char(d->character, NOWHERE);
d3389 1
a3389 1
    save_char(vict, NOWHERE);
d4056 2
d4060 4
d4245 1
a4245 1
    save_char(vict, NOWHERE);
d4745 1
a4745 1
       char *buffer;
d4750 10
a4759 10
 	{ "credits",	LVL_IMPL,	"credits",	2400,	CREDITS_FILE},
 	{ "news",	LVL_GRGOD,	"news",		8192,	NEWS_FILE},
 	{ "anews",	LVL_GRGOD,	"anews",		8192,	ANEWS_FILE},
	{ "motd",	LVL_GRGOD,	"motd",		2400,	MOTD_FILE},
 	{ "imotd",	LVL_HEAD_B,	"imotd",		2400,	IMOTD_FILE},
 	{ "help",       LVL_GRGOD,	"help",		2400,	HELP_PAGE_FILE},
 	{ "info",	LVL_GRGOD,	"info",		8192,	INFO_FILE},
	{ "background",	LVL_GRGOD,	"background",	8192,	BACKGROUND_FILE},
 	{ "handbook",   LVL_HEAD_B,	"handbook",	8192,   HANDBOOK_FILE},
 	{ "policies",	LVL_IMPL,	"policies",	8192,	POLICIES_FILE},
d4792 1
a4792 1
      break;
a4803 16
    switch (l) {
     case 0: ch->desc->str = &credits; break;
     case 1: ch->desc->str = &news; break; 
	 case 2: ch->desc->str = &anews; break;
     case 3: ch->desc->str = &motd; break;
     case 4: ch->desc->str = &imotd; break;
     case 5: ch->desc->str = &help; break;
     case 6: ch->desc->str = &info; break;
     case 7: ch->desc->str = &background; break;
     case 8: ch->desc->str = &handbook; break;
     case 9: ch->desc->str = &policies; break;
     default:
       send_to_char("Invalid text editor option.\r\n", ch);
       return;
    }
    
d4809 2
a4810 2
       send_to_char(fields[l].buffer, ch);
       ch->desc->backstr = str_dup(fields[l].buffer);
d4812 1
a5313 1
  int clan_num;
d5327 1
a5327 1
      if (victim == ch) {
d5330 1
a5330 1
      }
d5332 5
a5336 5
      if (GET_LEVEL(victim) == LVL_IMPL)	{
        send_to_char("&1You dare NOT do that!&0", ch);
        return;
      }
      if (IS_NPC(victim)) {
d5339 21
a5359 27
      }
       /* delete and purge */
      if(GET_LEVEL(victim) < LVL_GRGOD) {
	if(GET_CLAN(victim)) {
	  clan_num = find_clan_by_id(GET_CLAN(victim));
          if(GET_CLAN_RANK(victim)){
            clan[clan_num].members--;
	    clan[clan_num].power-=GET_LEVEL(victim);
	  }
          GET_CLAN(victim) = 0;
          GET_CLAN_RANK(victim) = 0;
	  update_clan(ch,clan_num);
        }
        SET_BIT(PLR_FLAGS(victim), PLR_DELETED);
      }
      save_char(victim, NOWHERE);
      Crash_delete_file(GET_NAME(victim));
      if (victim->desc) {
	close_socket(victim->desc);
	victim->desc = NULL;
      }
      act("&9&b$n cuts &0$N's &9&bthroat and buries $s corpse where no one will ever find it!&0", FALSE, ch, 0, victim, TO_ROOM);
      act("&9&bYou destroy &0$N &9&bforever.&0", FALSE, ch, 0, victim, TO_CHAR);
      sprintf(buf,"%s has terminated %s!",GET_NAME(ch),GET_NAME(victim));
      log(buf);
      extract_char(victim);
      return;
d5370 1
a5370 1
       save_char(cbuf, NOWHERE);
d5689 4
@


1.180
log
@Fix feedback in iptables add.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.179 2007/11/22 23:33:41 jps Exp jps $
d164 8
d178 2
a179 1
  if (strcmp(arg, "list") == 0) {
d206 3
a208 1
         if (!(vict = get_char_vis(ch, arg))) {
d247 1
a247 1
      /* TODO: determine whether the address is already in the table */
d249 27
a275 4
      sprintf(cBuf,
          "/sbin/iptables -I FieryMUD --source %s --protocol tcp --dport 80 --jump ACCEPT",
          buf); 
      system(cBuf);
d277 20
a296 7
      sprintf(cBuf2,
          "/sbin/iptables -I FieryMUD --source %s --protocol tcp --dport 22 --jump ACCEPT",
          buf); 
      system(cBuf2);

      sprintf(buf2, "Ok, added %s to the table.\r\n", buf);
      send_to_char(buf2, ch);
d299 1
a299 2
  } else if (strcmp(arg, "delete") == 0) {
    int lineNum = 0; 
d301 10
a310 3
    lineNum = atoi(arg); 
    sprintf(cBuf2, "/sbin/iptables -D FieryMUD %d", lineNum);
    system(cBuf2);
d312 3
a314 1
    send_to_char("Ok.\r\n",ch); 
d316 1
a316 1
    send_to_char("Usage:  iptables [add|delete|list]\r\n", ch); 
d5683 3
@


1.179
log
@Updated iptables command to correctly format a given IP address,
and to accept the name of a player to add that player's address
to the table.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.178 2007/11/18 16:51:55 myc Exp jps $
d249 1
d5628 5
@


1.178
log
@Imms can see wiznet while switched.  Fixing LVL_BUILDER references in
do_set.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.177 2007/10/23 20:19:56 myc Exp myc $
d155 1
d161 2
a165 4
  if (GET_LEVEL(ch) < 104) {
    return; 
  }

d172 1
a172 1
	    tmpfile); 
a185 1
  
d189 2
a190 2
    if (!arg || !*arg || strlen(arg) < 7 || strlen(arg) > 15) {
      send_to_char("What IP address do you want allowed?\r\n", ch);
d193 56
a248 4
      sprintf(cBuf, "/sbin/iptables -I FieryMUD --source %s --protocol tcp --dport 80 --jump ACCEPT", argument); 
      system(cBuf); 
      sprintf(cBuf2, "/sbin/iptables -I FieryMUD --source %s --protocol tcp --dport 22 --jump ACCEPT", argument); 
      system(cBuf2); 
d258 1
a258 16
/* Ok, once upon a time this pointed at the main firewall table
   and not a subchain.  The mud had all lines below 18 and none
   above.  Since the mud has its own subchain in iptables now
   this code doesn't apply.  However, there may need to be a
   check to prevent a coder from deleting some lines of the
   subchain, like the drop all at the end, if that line is 
   even necessary.. - rsd
    if (lineNum < 18) {
      send_to_char("Cannot modify lines below 18.\r\n", ch); 
      return; 
    } else {
      sprintf(cBuf2, "/sbin/iptables -D FieryMUD %d", lineNum); 
      system(cBuf2); 
    }
*/

a262 2
  
  send_to_char("Ok.\r\n",ch); 
d5627 4
@


1.177
log
@Use administration levels for game command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.176 2007/10/17 17:18:04 myc Exp myc $
d2824 14
a2837 9
    if ((!d->connected) && (GET_LEVEL(d->character) >= level) &&
	(!PRF_FLAGGED(d->character, PRF_NOWIZ)) &&
	(!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
	&& (d != ch->desc || !(PRF_FLAGGED(d->character, PRF_NOREPEAT)))) {
      if (CAN_SEE(d->character, ch))
	send_to_char(buf1, d->character);
      else
	send_to_char(buf2, d->character);
    }
d3593 78
a3670 78
  struct set_struct {   /*  LVL_OVERLORD   105 */
    char *cmd;          /*  LVL_HEAD_C     104 */
    char level;         /*  LVL_HEAD_B     103 */
    char pcnpc;         /*  LVL_GRGOD      102 */
    char type;          /*  LVL_GOD        101 */
  }          fields[] = {
   { "brief",		LVL_HEAD_B, 	PC, 	BINARY }, /* 0*/
   { "invstart", 	LVL_GOD, 	PC, 	BINARY }, /* 1*/
   { "title",		LVL_GOD, 	PC, 	MISC   },
   { "nosummon", 	LVL_GRGOD, 	PC, 	BINARY },
   { "maxhit",		LVL_GOD, 	BOTH, 	NUMBER },
   { "maxmana", 	LVL_GOD, 	BOTH, 	NUMBER }, /* 5*/
   { "maxmove", 	LVL_GOD, 	BOTH, 	NUMBER },
   { "hit", 		LVL_GOD, 	BOTH, 	NUMBER },
   { "mana",		LVL_GOD, 	BOTH, 	NUMBER },
   { "move",		LVL_GOD, 	BOTH, 	NUMBER },
   { "align",		LVL_GOD, 	BOTH, 	NUMBER }, /*10*/
   { "str",		LVL_GOD, 	BOTH, 	NUMBER },
   { "stradd",		LVL_GOD, 	BOTH, 	NUMBER },
   { "int", 		LVL_GOD, 	BOTH, 	NUMBER },
   { "wis", 		LVL_GOD, 	BOTH, 	NUMBER },
   { "dex", 		LVL_GOD, 	BOTH, 	NUMBER }, /*15*/
   { "con", 		LVL_GOD, 	BOTH, 	NUMBER },
   { "sex", 		LVL_GOD, 	BOTH, 	MISC   },
   { "ac", 		LVL_GOD, 	BOTH, 	NUMBER },
   { "olc",             LVL_HEAD_B,     PC,     NUMBER },
   { "home",	        LVL_GOD,	PC,	NUMBER },
   { "exp", 		LVL_HEAD_C, 	BOTH, 	NUMBER },
   { "hitroll", 	LVL_GOD, 	BOTH, 	NUMBER },
   { "damroll", 	LVL_GOD, 	BOTH, 	NUMBER },
   { "invis",		LVL_HEAD_B,	PC, 	NUMBER },
   { "nohassle", 	LVL_HEAD_B, 	PC, 	BINARY }, /*25*/
   { "frozen",		LVL_FREEZE, 	PC, 	BINARY },
   { "practices", 	LVL_HEAD_B, 	PC, 	NUMBER },
   { "lessons", 	LVL_HEAD_B, 	PC, 	NUMBER },
   { "drunk",		LVL_GOD, 	BOTH, 	MISC   },
   { "hunger",		LVL_GOD, 	BOTH, 	MISC   }, /*30*/
   { "thirst",		LVL_GOD, 	BOTH, 	MISC   },
   { "killer",		LVL_HEAD_C, 	PC, 	BINARY },
   { "thief",		LVL_HEAD_C, 	PC, 	BINARY },
   { "level",		LVL_HEAD_C, 	BOTH, 	NUMBER },
   { "room",		LVL_BUILDER, 	BOTH, 	NUMBER }, /*35*/
   { "roomflag", 	LVL_HEAD_C, 	PC, 	BINARY },
   { "siteok",		LVL_GRGOD, 	PC, 	BINARY },
   { "deleted", 	LVL_IMPL, 	PC, 	BINARY },
   { "class",		LVL_GOD, 	BOTH, 	MISC   },
   { "nowizlist", 	LVL_GOD, 	PC, 	BINARY }, /*40*/
   { "quest",		LVL_GOD, 	PC, 	BINARY },
   { "loadroom", 	LVL_GOD, 	PC, 	MISC   },
   { "color",		LVL_GOD, 	PC, 	BINARY },
   { "idnum",		LVL_IMPL, 	PC, 	NUMBER },
   { "passwd",		LVL_HEAD_B, 	PC, 	MISC   }, /*45*/
   { "nodelete", 	LVL_GOD, 	PC, 	BINARY },
   { "cha",		LVL_GOD, 	BOTH, 	NUMBER },
   { "race",            LVL_GOD,     PC,     MISC   },
   { "olc2",            LVL_HEAD_B,     PC,     NUMBER },
   { "olc3",            LVL_HEAD_B,     PC,     NUMBER }, /*50*/
   { "olc4",            LVL_HEAD_B,     PC,     NUMBER },
   { "olc5",            LVL_HEAD_B,     PC,     NUMBER },
   { "plat",		LVL_GOD, 	BOTH, 	NUMBER },
   { "gold",		LVL_GOD, 	BOTH, 	NUMBER },   
   { "silver",		LVL_GOD, 	BOTH, 	NUMBER }, /*55*/
   { "copper",		LVL_GOD, 	BOTH, 	NUMBER },
   { "pbank",		LVL_GRGOD, 	PC, 	NUMBER },
   { "gbank",		LVL_GRGOD, 	PC, 	NUMBER },
   { "sbank",		LVL_GRGOD, 	PC, 	NUMBER },  
   { "cbank",		LVL_GRGOD, 	PC, 	NUMBER }, /*60*/
   { "diety",           LVL_HEAD_C,     PC,     NUMBER },
   { "frag",            LVL_IMPL,       PC,     NUMBER },
   { "anon",   		LVL_GRGOD,	PC,	BINARY },
   { "rename",	        LVL_GOD,	PC,	BINARY },
   { "napprove",        LVL_GOD,	PC,	BINARY }, /*65*/
   { "holylight",	LVL_GOD,	PC,     BINARY },
   { "wiztitle",	LVL_GOD,	PC,     MISC   },
   { "chant",		LVL_HEAD_C,	PC,     NUMBER },   
   { "size",		LVL_GOD,	PC,     NUMBER },
   { "hiddenness",	LVL_GOD,	BOTH,   NUMBER }, /*70*/
   { "\n",              0,		BOTH, 	MISC   }
d4911 1
a4911 1
      if (i != ch && !IS_NPC(i) && !ROOM_FLAGGED(i->in_room, ROOM_ARENA)) {
d5594 3
@


1.176
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.175 2007/10/15 01:50:23 myc Exp myc $
d4259 1
a4259 1
    { "RACES", 0,     &races_allowed,         LVL_HEAD_C, 
d4264 1
a4264 1
    { "GOOD_RACES",0, &good_races_allowed,    LVL_HEAD_C, 
d4269 1
a4269 1
    { "PK",     0,    &pk_allowed,            LVL_HEAD_C, 
d4274 1
a4274 1
    { "SLEEP",  0,    &sleep_allowed,         LVL_HEAD_C, 
d4279 1
a4279 1
    { "SUMMON", 0,  &summon_allowed,        LVL_HEAD_C, 
d4284 1
a4284 1
    { "CHARM",  0,  &charm_allowed,         LVL_HEAD_C, 
d4289 1
a4289 1
    { "ROOMAFFECT",0, &roomaffect_allowed,    LVL_HEAD_C, 
d4294 1
a4294 1
    { "NAMES",  0,  &approve_names,         LVL_HEAD_C, 
d4299 1
a4299 1
    { "NPAUSE", 0,  &napprove_pause,        LVL_HEAD_C,
d4304 1
a4304 1
    { "OOC",    0,  &gossip_channel_active, LVL_BUILDER,
d4314 1
a4314 1
    { "LEVELGAIN",0,  &level_gain,            LVL_HEAD_C,
d4319 1
a4319 1
    { "DAMAGEAMTS", 0, &damage_amounts,            LVL_HEAD_C,
d4324 1
a4324 1
    { "GROUPING", 1, &max_group_difference, LVL_BUILDER, 
d5589 4
@


1.175
log
@Realm restore won't affect people in PK arenas now.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.174 2007/10/11 20:14:48 myc Exp myc $
d4150 1
a4150 1
  if (((tp = search_block(arg, logtypes, FALSE)) == -1)) {
d5589 3
@


1.174
log
@Changed the skill defines slightly to support chants and songs as
slightly distinguished from spells and skills.  TOP_SKILL is the old
MAX_SKILLS.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.173 2007/10/04 16:20:24 myc Exp myc $
d4906 1
a4906 1
      if (i != ch && !IS_NPC(i)) {
d5589 5
@


1.173
log
@No need to explicitly say "No exit description" in stat_room.  Waste
of space.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.172 2007/10/02 02:52:27 myc Exp myc $
d2375 1
a2375 1
         for (i = 1; i <= MAX_SKILLS; i++)
d5589 4
@


1.172
log
@Petition now goes to the player's descriptor even when they are
shapechanged/switched.  Added indication of switched/shapechanged
to stat char.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.171 2007/09/28 20:49:35 myc Exp myc $
d989 1
a989 4
	strcpy(buf, rm->dir_option[i]->general_description);
      else
	strcpy(buf, "  No exit description.\r\n");
      send_to_char(buf, ch);
d5589 5
@


1.171
log
@Removed wworld command; it's just duplicating functionality.  Took out
vnum, mnum, onum, rnum, tnum, mlist, olist, rlist, tlist, slist, vwear,
and vitem commands in favor of the comprehensive vsearch command suite.
(All these commands are still available, but they use the vsearch
functions now.)
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.170 2007/09/20 21:20:43 myc Exp myc $
a324 3
  sprintf(buf, "&6$n responds to your petition, '&b%s&0&6'&0", arg);
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);
  
d331 5
d337 1
a337 2
	  GET_NAME(ch), GET_NAME(vict), arg);
  
d345 6
d365 3
a367 1
  else if (!IS_NPC(vict) && !vict->desc)        /* linkless */
d372 1
a372 1
  else  {
a373 5
    if (PRF_FLAGGED(vict,PRF_AFK))  {
      send_to_char("You received the previous message while AFK\r\n",vict);
      send_to_char("That person is AFK right now but received your message\r\n",ch);
    }
  }
d1429 13
a1441 6
  if (IS_NPC(k)) {
    strcat(buf, ", Attack type: ");
    strcat(buf, attack_hit_text[k->mob_specials.attack_type].singular);
  }
  else
    sprintf(buf, "%s, Idle: [%d tics]", buf, k->char_specials.timer);
d1444 1
a1444 1
    sprintf(buf, "%s, Connected: %s", buf, buf2);
d1446 6
a1451 1
  send_to_char(strcat(buf, "\r\n"), ch);
d1454 2
a1455 1
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d\r\n",
d1457 2
a1458 1
	    k->mob_specials.damnodice, k->mob_specials.damsizedice);
d1488 6
a1493 6
  sprintf(buf, "Max Carry: weight: %d, items: %d; "
               "Carried: weight: %d, items: %d; "
               "Equipment: weight: %d, items: %d\r\n",
          CAN_CARRY_W(k), CAN_CARRY_N(k),
          IS_CARRYING_W(k), IS_CARRYING_N(k),
          a, found);
d5592 7
@


1.170
log
@Hide points and perception are in.  AFF_HIDE, AFF_SNEAK, and ITEM_HIDDEN
are now unused.  Changes to stat obj and char.  Also, can set hiddenness
with set command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.169 2007/09/20 10:01:36 jps Exp myc $
a142 2
int vnum_object_zone(int zone, struct char_data *ch);
int vnum_mob_zone(int zone, struct char_data *ch);
a153 81
/* VNUMARGS
 *
 * Processes the command arguments for a command whose parameters are
 * as follows:
 *
 *    <starting vnum> <ending vnum>
 *  (or)
 *    <zone vnum>
 *  (or)
 *    "*"
 *  (or)
 *    (nothing, in which case it defaults to the current zone)
 * 
 * The return value is 1 if valid argument(s) were received. In this
 * case, the first and second integer values have been set. If both
 * were specified, that's what they have been set to. If only a zone
 * was specified (or if none was specified and the current zone was
 * used), then the first value is the beginning of the zone and
 * the second value is the "top of zone".
 *
 * If a "*" was given, the values are set to 0 and MAX_VNUM,
 * so all requested items can be listed.
 *
 * The return value is 0 if invalid argument(s) were received.
 * In this case, a message has already been sent to the character.
 *
 * This function is meant to be useful for the following commands:
 *
 *    tlist, mlist, olist, rlist
 */

int vnumargs(struct char_data *ch, char *argument, int *first, int *second)
{
   int znum;

   two_arguments(argument, buf, buf2);

   if (!strcmp("*", buf)) {
      *first = 0;
      *second = MAX_VNUM;
      return 1;
   }

   if (!*buf)
      *first = zone_table[IN_ZONE(ch)].number;
   else
      *first = atoi(buf);

   if (*first < 0 || *first > MAX_VNUM) {
      sprintf(buf, "Values must be between 0 and %d.\n\r", MAX_VNUM);
      send_to_char(buf, ch);
      return 0;
   }

   if (*buf2) *second = atoi(buf2);
   else {
      /* Fewer than two parameters were given. Use the given number or the current zone,
       * and show everything from first*100 to the top of that zone
       * (e.g., 30 => 3000-3499, Mielikki).
       * If the zone can't be identified, show everything from first*100 to first*100+99. */
      znum = find_zone(*first);
      *first *= 100;
      if (znum == -1)
         *second = *first + 99;
      else
         *second = zone_table[znum].top;
   }
  
   if ((*first < 0) || (*first > MAX_VNUM) || (*second < 0) || (*second > MAX_VNUM)) {
      sprintf(buf, "Values must be between 0 and %d.\n\r", MAX_VNUM);
      send_to_char(buf, ch);
      return 0;
   }
  
   if (*first >= *second) {
      send_to_char("Second value must be greater than first.\n\r", ch);
      return 0;
   }
   return 1;
}

a371 42
ACMD(do_wworld)
{ 
  int number=0, zone=0, found=0, j, i;
  struct room_data *rm = &world[ch->in_room];
  
  two_arguments(argument, buf, buf2);
  
  if (!*buf) {
    send_to_char("Usage: wworld { obj | mob } [zone number]\r\n", ch);
    return;
  }
  if (*buf2 && isdigit(*buf2)) {
    found=1;
    if ((number = atoi(buf2)) < 0) {
      send_to_char("A NEGATIVE number??\r\n", ch);
      return;
    }
    for (j= number, i=0; zone_table[i].number != j && i <= top_of_zone_table; i++);
    if (i > top_of_zone_table) {
      send_to_char("That is not a valid zone.\r\n", ch);
      return;
    }
    else
      zone=i;
  } else zone = rm->zone;
  
  if (is_abbrev(buf, "obj")) {
    sprintf(buf2, "Object listing for zone #%d\r\n----------------------------\r\n",number);
    send_to_char(buf2,ch);
    vnum_object_zone(zone, ch);
  }
  else if (is_abbrev(buf, "mob")) {
    sprintf(buf2, "Mob listing for zone #%d\r\n-------------------------\r\n",number);
    send_to_char(buf2,ch);
    vnum_mob_zone(zone, ch);
  }
  else {
    send_to_char("Usage: world { obj | mob } [zone number]\r\n", ch);
  }
}


a702 46
ACMD(do_vnum)
{
  two_arguments(argument, buf, buf2);
  
  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && !is_abbrev(buf, "obj")))
    send_to_char("Usage: vnum { obj | mob } <name>\r\n", ch);
  else if (is_abbrev(buf, "mob")) {
    if (!vnum_mobile(buf2, ch))
      send_to_char("No mobiles by that name.\r\n", ch);
  }
  else if (is_abbrev(buf, "obj")) {
    if (!vnum_object(buf2, ch))
      send_to_char("No objects by that name.\r\n", ch);
  }
}

ACMD(do_mnum)
{
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Usage: mnum <name>\r\n", ch);
  else if (!vnum_mobile(arg, ch))
    send_to_char("No mobiles by that name.\r\n", ch);
}

ACMD(do_onum)
{
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Usage: onum <name>\r\n", ch);
  else if (!vnum_object(arg, ch))
    send_to_char("No objects by that name.\r\n", ch);
}

ACMD(do_rnum)
{
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Usage: rnum <name>\r\n", ch);
  else if (!vnum_room(arg, ch))
    send_to_char("No rooms by that name.\r\n", ch);
}

a713 11
ACMD(do_tnum)
{
   int vnum_trigger(char *searchname, struct char_data *ch);
   one_argument(argument, arg);

   if (!*arg)
      send_to_char("Usage: tnum <name>\r\n", ch);
   else if (!vnum_trigger(arg, ch))
      send_to_char("No triggers by that name.\r\n", ch);
}

d1476 1
a4814 105
ACMD(do_mlist)
{
  extern struct index_data *mob_index;
  extern struct char_data *mob_proto;
  extern int top_of_mobt;

  int first, last, nr, found = 0;

  if (!vnumargs(ch, argument, &first, &last)) return;

  for (nr = 0; nr <= top_of_mobt && (mob_index[nr].virtual <= last); nr++) {
    if (mob_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              mob_index[nr].virtual,
              mob_proto[nr].player.short_descr);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No mobiles were found in those parameters.\n\r", ch);
}

ACMD(do_olist)
{
  extern struct index_data *obj_index;
  extern struct obj_data *obj_proto;
  extern int top_of_objt;

  int first, last, nr, found = 0;

  if (!vnumargs(ch, argument, &first, &last)) return;

  for (nr = 0; nr <= top_of_objt && (obj_index[nr].virtual <= last); nr++) {
    if (obj_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              obj_index[nr].virtual,
              obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No objects were found in those parameters.\n\r", ch);
}

ACMD(do_rlist)
{
  extern struct room_data *world;
  extern int top_of_world;

  int first, last, nr, found = 0;

  if (!vnumargs(ch, argument, &first, &last)) return;

  for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++) {
    if (world[nr].number >= first) {
      sprintf(buf, "%5d. [%5d] (%3d) %s\r\n", ++found,
              world[nr].number, world[nr].zone,
              world[nr].name);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No rooms were found in those parameters.\n\r", ch);
}

ACMD(do_tlist)
{
  extern int top_of_trigt;
  extern struct index_data **trig_index;
  
  int first, last, nr, found = 0;
  char pagebuf[65536];
  
  strcpy(pagebuf,"");
  if (!vnumargs(ch, argument, &first, &last)) return;
  
  for (nr = 0; nr < top_of_trigt ; nr++)
    {
      if ((trig_index[nr]->virtual >= first) && (trig_index[nr]->virtual <= last)) {
	sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
		trig_index[nr]->virtual,
		trig_index[nr]->proto->name);
	strcat(pagebuf, buf);
      }
    }
  
  if (!found)
    send_to_char("No triggers were found in those parameters.\n\r", ch);
  else page_string(ch->desc, pagebuf, TRUE);
}

ACMD(do_slist)
{
   void list_shops(struct char_data *ch, int start, int end);
   int first, last;

   if (!vnumargs(ch, argument, &first, &last))
      return;
   else
      list_shops(ch, first, last);
}

a5571 319
void vwear_object(int wearpos, struct char_data * ch, int low_lev,
                  int mid_lev, int high_lev) {
  int nr, found = 0, overflow = 0, buflen;
  char vwear_buf[50000]; 

  strcpy(vwear_buf, " Num   Lvl   Obnum  Desc\r\n"
                    " ---   ---   -----  ----\r\n");
  buflen = strlen(vwear_buf);

  for (nr = 0; nr <= top_of_objt; nr++) {
    if (!CAN_WEAR(&obj_proto[nr], wearpos))
      continue;
    if (low_lev >= 0 && high_lev >= 0 &&
        (obj_proto[nr].obj_flags.level_obj < low_lev ||
        obj_proto[nr].obj_flags.level_obj > high_lev))
      continue;
    else if (mid_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj != mid_lev)
      continue;
    else if (low_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj > low_lev)
      continue;
    else if (high_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj < high_lev)
      continue;
    if (overflow)
      ++overflow;
    else if (buflen > sizeof(vwear_buf) - 300)
      overflow = 1;
    else
      buflen = sprintf(vwear_buf, "%s %3d.  %3d   %5d  %s\r\n", vwear_buf, 
                       ++found, obj_proto[nr].obj_flags.level_obj,
                       obj_index[nr].virtual, obj_proto[nr].short_description); 
  }
  if (found == 0)
    send_to_char("None.\r\n", ch);
  else {
    if (overflow)
      sprintf(vwear_buf, "%s\r\n&1&8!! OVERFLOW !!&0  %d matching items not shown.\r\n", vwear_buf, overflow);
    page_string(ch->desc, vwear_buf, 1);
  }
}

ACMD(do_vwear)
{
  char field[MAX_INPUT_LENGTH];
  char second_arg[MAX_INPUT_LENGTH];
  char argu[MAX_INPUT_LENGTH];
  char extra[MAX_INPUT_LENGTH];
  char level[MAX_INPUT_LENGTH];
  char level2[MAX_INPUT_LENGTH];
  char mode;
 
  int i, j, l, low_lev = -1, high_lev = -1, mid_lev = -1;
 
  struct listeq_struct {
    char *cmd;
    int flag;
  }
 
  fields[] = {
    { "finger",    ITEM_WEAR_FINGER   },
    { "neck",      ITEM_WEAR_NECK     },
    { "body",      ITEM_WEAR_BODY     },
    { "head",      ITEM_WEAR_HEAD     },
    { "legs",      ITEM_WEAR_LEGS     },
    { "feet",      ITEM_WEAR_FEET     },
    { "hands",     ITEM_WEAR_HANDS    },
    { "arms",      ITEM_WEAR_ARMS     },
    { "shield",    ITEM_WEAR_SHIELD   },
    { "about",     ITEM_WEAR_ABOUT    },
    { "waist",     ITEM_WEAR_WAIST    },
    { "wrist",     ITEM_WEAR_WRIST    },
    { "wield",     ITEM_WEAR_WIELD    },
    { "hold",      ITEM_WEAR_HOLD     },
    { "2hwield",   ITEM_WEAR_2HWIELD  },
    { "eyes",      ITEM_WEAR_EYES     },
    { "face",      ITEM_WEAR_FACE     },
    { "ear",       ITEM_WEAR_EAR      },
    { "badge",     ITEM_WEAR_BADGE    },
    { "obelt",     ITEM_WEAR_OBELT    },
    /* Add any extra eq types here */
    { "\n",        0                  }
  };
 
  skip_spaces(&argument);
 
  if (*argument) {
    half_chop(argument, field, second_arg);
    if (*second_arg) {
      half_chop(second_arg, argu, extra);
      if (*argu == '-') {
        mode = *(argu + 1);
        switch (mode) {
          case 'e':
            one_argument(extra, level);
            mid_lev = atoi(level);
            break;
          case 'g':
            one_argument(extra, level);
            high_lev = atoi(level);
            break;
          case 'l':
            one_argument(extra, level);
            low_lev = atoi(level);
            break;
          case 'b':
            two_arguments(extra, level, level2);
            low_lev = atoi(level);
            high_lev = atoi(level2);
            break;
        }
      }
    }
 
    for (l = 0; *(fields[l].cmd) != '\n'; l++)
      if (is_abbrev(field, fields[l].cmd)) {
        vwear_object(fields[l].flag, ch, low_lev, mid_lev, high_lev);
        return;
      }
  }

  strcpy(buf, "Usage: vwear <wear position> <level(s) option>\r\n\r\n");
  sprintf(buf, "%sPossible positions are:\r\n", buf);
  for (j = 0, i = 0; fields[i].cmd != "\n"; i++)
    sprintf(buf, "%s%-10s%s", buf, fields[i].cmd, (!(++j % 7) ? "\r\n" : ""));
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  return;
  
} 

void vitem_object(int type, struct char_data * ch, int low_lev,
                  int mid_lev, int high_lev) {
  int nr, found = 0, numspells = 0, maxspells = 0, i, buflen, overflow = 0;
  char vwear_buf[50000];
  char spells_buf[1000];
  bool spellitem = FALSE;

  strcpy(vwear_buf, " Num   Lvl   Obnum  Desc\r\n"
                    " ---   ---   -----  ----\r\n");
  buflen = strlen(vwear_buf);

  for (nr = 0; nr <= top_of_objt; nr++) {
    if (GET_OBJ_TYPE(&obj_proto[nr]) != type)
      continue;
    if (low_lev >= 0 && high_lev >= 0 &&
        (obj_proto[nr].obj_flags.level_obj < low_lev ||
        obj_proto[nr].obj_flags.level_obj > high_lev))
      continue;
    else if (mid_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj != mid_lev)
      continue;
    else if (low_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj > low_lev)
      continue;
    else if (high_lev >= 0 &&
             obj_proto[nr].obj_flags.level_obj < high_lev)
      continue;

    spells_buf[0] = '\0';
    numspells = 0;

    switch (GET_OBJ_TYPE(&obj_proto[nr])) {
      case ITEM_SCROLL:
      case ITEM_POTION:
        spellitem = TRUE;
        maxspells = 3;
        break;
      case ITEM_WAND:
      case ITEM_STAFF:
        spellitem = TRUE;
        maxspells = 1;
    }

    if (spellitem) {
      /*
       * If maxspells is 1, 4 - 1 = 3, (value 4) which contains the spellnum
       *   (For wands/staves)
       * If maxspells is 3, 4 - 3 = 1, (value 1) which is the first spellnum
       *   Then iterate through the next 2.
       *   (For potions/scrolls)
       */
      for (i = 4 - maxspells; i <= 3; i++) {
        if (GET_OBJ_VAL(&obj_proto[nr], i) > 0) {
          if (!numspells)
            strcat(spells_buf, " ");
          numspells++;
          sprintf(buf, " &7%3d. &2%s                    ",
                  GET_OBJ_VAL(&obj_proto[nr], i),
                  spells[GET_OBJ_VAL(&obj_proto[nr], i)]);
          sprintf(buf + 24, "&0 ");
          strcat(spells_buf, buf);
        }
      }
      if (!numspells) {
        if (maxspells == 1) {
          sprintf(buf, "  (&3no spell&0)");
        } else {
          sprintf(buf, "  (&3no spells&0)");
        }
        strcat(spells_buf, buf);
      }
    }

    if (overflow)
      ++overflow;
    else if (buflen > sizeof(vwear_buf) - 300)
      overflow = 1;
    else
      buflen = sprintf(vwear_buf, "%s%4d.  %3d   %5d  %-35s%s\r\n", vwear_buf, ++found,
                       obj_proto[nr].obj_flags.level_obj,
                       obj_index[nr].virtual, obj_proto[nr].short_description, spells_buf); 
  }
  if (found == 0)
    send_to_char("None.\r\n", ch);
  else {
    if (overflow)
      sprintf(vwear_buf, "%s\r\n&1&8!! OVERFLOW !!&0  %d matching items not shown.\r\n", vwear_buf, overflow);
    page_string(ch->desc, vwear_buf, 1);
  }
}

ACMD(do_vitem)
{
  char field[MAX_INPUT_LENGTH];
  char second_arg[MAX_INPUT_LENGTH];
  char argu[MAX_INPUT_LENGTH];
  char extra[MAX_INPUT_LENGTH];
  char level[MAX_INPUT_LENGTH];
  char level2[MAX_INPUT_LENGTH];
  char mode;
 
  int i, j, l, low_lev = -1, high_lev = -1, mid_lev = -1;
 
  struct listeq_struct {
    char *cmd;
    int flag;
  }
 
  fields[] = {
    { "light",     ITEM_LIGHT      },
    { "scroll",    ITEM_SCROLL     },
    { "wand",      ITEM_WAND       },
    { "staff",     ITEM_STAFF      },
    { "weapon",    ITEM_WEAPON     },
    { "fweapon",   ITEM_FIREWEAPON },
    { "missile",   ITEM_MISSILE    },
    { "treasure",  ITEM_TREASURE   },
    { "armor",     ITEM_ARMOR      },
    { "potion",    ITEM_POTION     },
    { "worn",      ITEM_WORN       },
    { "other",     ITEM_OTHER      },
    { "trash",     ITEM_TRASH      },
    { "trap",      ITEM_TRAP       },
    { "container", ITEM_CONTAINER  },
    { "note",      ITEM_NOTE       },
    { "drinkcon",  ITEM_DRINKCON   },
    { "key",       ITEM_KEY        },
    { "food",      ITEM_FOOD       },
    { "money",     ITEM_MONEY      },
    { "pen",       ITEM_PEN        },
    { "boat",      ITEM_BOAT       },
    { "fountain",  ITEM_FOUNTAIN   },
    { "portal",    ITEM_PORTAL     },
    { "rope",      ITEM_ROPE       },
    { "spellbook", ITEM_SPELLBOOK  },
    { "wall",      ITEM_WALL       },
    /* Add any extra item types here */
    { "\n",        0               }
  };
 
  skip_spaces(&argument);
 
  if (*argument) {
    half_chop(argument, field, second_arg);
    if (*second_arg) {
      half_chop(second_arg, argu, extra);
      if (*argu == '-') {
        mode = *(argu + 1);
        switch (mode) {
          case 'e':
            one_argument(extra, level);
            mid_lev = atoi(level);
            break;
          case 'g':
            one_argument(extra, level);
            high_lev = atoi(level);
            break;
          case 'l':
            one_argument(extra, level);
            low_lev = atoi(level);
            break;
          case 'b':
            two_arguments(extra, level, level2);
            low_lev = atoi(level);
            high_lev = atoi(level2);
            break;
        }
      }
    }
 
    for (l = 0; *(fields[l].cmd) != '\n'; l++)
      if (is_abbrev(field, fields[l].cmd)) {
        vitem_object(fields[l].flag, ch, low_lev, mid_lev, high_lev);
        return;
      }
  }

  strcpy(buf, "Usage: vitem <item type> <level(s) option>\r\n\r\n");
  sprintf(buf, "%sPossible item types are:\r\n", buf);
  for (j = 0, i = 0; fields[i].cmd != "\n"; i++)
    sprintf(buf, "%s%-10s%s", buf, fields[i].cmd, (!(++j % 7) ? "\r\n" : ""));
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  return;
  
} 

d5574 5
@


1.169
log
@estat now takes an object by default.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.168 2007/09/15 15:36:48 myc Exp jps $
d1288 4
a1291 2
  sprintf(buf, "Weight: %d, Value: %d, Cost/day: %d, Timer: %d\r\n",
	  GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j), GET_OBJ_TIMER(j));
d1557 9
a1565 6
	  CCCYN(ch, C_NRM), GET_VIEWED_STR(k), GET_VIEWED_INT(k), GET_VIEWED_WIS(k),  
	  GET_VIEWED_DEX(k), GET_VIEWED_CON(k), GET_VIEWED_CHA(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_NATURAL_STR(k), GET_NATURAL_INT(k), GET_NATURAL_WIS(k),  
	  GET_NATURAL_DEX(k), GET_NATURAL_CON(k), GET_NATURAL_CHA(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_AFFECTED_STR(k), GET_AFFECTED_INT(k), GET_AFFECTED_WIS(k),  
	  GET_AFFECTED_DEX(k), GET_AFFECTED_CON(k), GET_AFFECTED_CHA(k), CCNRM(ch, C_NRM));
d1568 1
a1568 1
  sprintf(buf, "HP:[%s%d/%d+%d%s]  MP:[%s%d/%d+%d%s]  MV:[%s%d/%d+%d%s]\r\n",
d1587 2
a1588 1
               "Saving throws: [%d/%d/%d/%d/%d]\r\n",
d1593 2
a1594 1
          GET_SAVE(k, 3), GET_SAVE(k, 4));
d2584 2
a2585 3
  if (GET_INVIS_LEV(ch) == 0 &&
      !AFF_FLAGGED(ch, AFF_HIDE | AFF_INVISIBLE) &&
      !AFF3_FLAGGED(ch, AFF3_CAMOUFLAGED)) {
a3018 1
        (!PRF_FLAGGED(d->character, PRF_NONAME_BROADCAST)) &&
d3826 5
a3830 4
   { "holylight",       LVL_GOD,      PC,     BINARY },
   { "wiztitle",        LVL_GOD,     PC,     MISC   },
   { "chant",		LVL_HEAD_C,     PC,     NUMBER },   
   { "size",		LVL_GOD,      PC,     NUMBER },
d4269 3
d6179 3
@


1.168
log
@Fixed stat char to show no distinction between aff 1, 2, and 3 flags
when listing spell affections.  Natures embrace now sets camouflage bit,
which lets you be hidden as long as you are outside.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.167 2007/09/15 05:03:46 myc Exp myc $
d1445 1
a1445 1
   } else if (subcmd == SCMD_OESTAT || !strcmp(buf1, "obj")) {
d1448 2
d1451 1
a1451 1
         otarg = buf2;
d1453 4
a1456 3
      if (!*otarg)
         send_to_char("Stat the extra descs of which object?\r\n", ch);
      else if (isdigit(*otarg)) {
a1466 3
   } else {
      send_to_char("Usage: estat room [<vnum>]\r\n", ch);
      send_to_char("       estat obj <name>\r\n", ch);
d6170 5
@


1.167
log
@Removing the distinction between AFF1, AFF2, and AFF3 flags within
the game.  The distinction only exists to coders now.  Added MOB2 flags,
increasing the possible number of MOB flags by 32.  Added the !POISON
mob flag.  Reformatted stat char to look nicer and fit together better.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.166 2007/09/12 22:23:04 myc Exp myc $
d1758 1
a1758 1
  if (k->affected) {
d1762 1
a1762 1
        sprintf(buf, "SPL: (innate) %s%-21s%s ",
d1767 15
a1781 28
      if (aff->modifier) {
	sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
	strcat(buf, buf2);
      }
      if (aff->bitvector) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector, affected_bits, buf2);
	strcat(buf, buf2);
      }
      if (aff->bitvector2) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector2, affected_bits2, buf2);
	strcat(buf, buf2);
      }
      if (aff->bitvector3) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector3, affected_bits3, buf2);
	strcat(buf, buf2);
      }
d1784 1
a1784 1
  }
d2577 3
a2579 1
  if (GET_INVIS_LEV(ch) == 0 && !IS_AFFECTED(ch, AFF_HIDE | AFF_INVISIBLE)) {
d6170 6
@


1.166
log
@When switching into a mob, your prompt is copied there.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.165 2007/09/04 06:49:19 myc Exp myc $
d107 1
d117 1
a1271 5
  send_to_char("Set char bits : ", ch);
  sprintbit(j->obj_flags.bitvector, affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  
d1277 7
a1283 10
  send_to_char("Spell Affects 1 : ", ch);
  sprintbit(GET_OBJ_SPELL(j), affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  send_to_char("Spell Affects 2 : ", ch);
  sprintbit(GET_OBJ_SPELL2(j), affected_bits2, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  send_to_char("Spell Affects 3 : ", ch);
  sprintbit(GET_OBJ_SPELL3(j), affected_bits3, buf);
d1472 1
a1472 2
  int i, i2, found = 0;
  int a,qid_num;
a1474 1
  struct obj_data *j;
d1477 1
a1477 1
  struct quest_list *qst;
a1479 6
  switch (GET_SEX(k)) {
  case SEX_NEUTRAL:    strcpy(buf, "NEUTRAL-SEX");   break;
  case SEX_MALE:       strcpy(buf, "MALE");          break;
  case SEX_FEMALE:     strcpy(buf, "FEMALE");        break;
  default:             strcpy(buf, "ILLEGAL-SEX!!"); break;
  }
d1481 2
a1482 1
  sprintf(buf2, " %s '%s'  IDNum: [%5ld], In room [%5d]\r\n",
d1485 3
a1487 1
  send_to_char(strcat(buf, buf2), ch);
d1493 6
a1498 1
  sprintf(buf, "Title: %s\r\n", (k->player.title ? k->player.title : "<None>"));
a1500 2
  sprintf(buf, "Size: %s\r\n", SIZE_ABBR(k));
  send_to_char(buf, ch);
d1502 11
a1512 1
  sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : "<None>\r\n"));
d1515 2
a1516 15
  
  
  if (IS_NPC(k)) {
    sprintf(buf, "Species: %s, Race_align: %s\n\r", mspecies_types[(int)GET_SPECIES(k)], RACE_ALIGN_ABBR(k));
    send_to_char(buf, ch); 
  }
  else  {
    sprintf(buf, "Species: %s, Race_align: %s, Deity: %s\n\r", RACE_ABBR(k),
	    RACE_ALIGN_ABBR(k),((GET_DIETY(ch)) ? "No Deity"
				:
				Dieties[(int)GET_DIETY(ch)].diety_name));  
    send_to_char(buf,ch);
  }
  if (IS_NPC(k)) {
    strcpy(buf, "Monster Class: ");
d1518 1
a1518 2
  } else {
    strcpy(buf, "Class: ");
a1519 1
  }
d1521 2
a1522 5
  
  
  
  sprintf(buf2, ", Lev: [%s%2d%s], XP: [%s%7ld%s], Align: [%4d]\r\n",
	  CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
a1524 1
  strcat(buf, buf2);
d1527 1
d1532 1
a1532 1
    sprintf(buf, " Created: [%s], Last Logon: [%s], Played [%dh %dm], Age [%d]\r\n",
d1534 1
a1534 1
	    ((k->player.time.played / 3600) % 60), age(k).year);
d1537 9
a1545 8
    sprintf(buf, "Frags[%4.2f], Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])", GET_FRAG(k),
	    k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
	    GET_PRACTICES(k), int_app[GET_INT(k)].learn,
	    wis_app[GET_WIS(k)].bonus);
    /*. Display OLC zone for immorts .*/
    if(GET_LEVEL(k) >= LVL_IMMORT)
      sprintf(buf, "%s,\r\n OLC[%d], OLC2[%d], OLC3[%d], OLC4[%d], OLC5[%d]", buf, 
	      GET_OLC_ZONE(k), GET_OLC2_ZONE(k), GET_OLC3_ZONE(k), GET_OLC4_ZONE(k), GET_OLC5_ZONE(k));
d1548 3
a1550 1
  } /* new printf for stats for the 100 base system */
d1563 1
a1563 1
  sprintf(buf, "Hit p.:[%s%d/%d+%d%s]  Mana p.:[%s%d/%d+%d%s]  Move p.:[%s%d/%d+%d%s]\r\n",
d1569 19
a1587 3
  sprintf(buf, "Coins: [%dp / %dg / %ds / %dc]\r\nBank: [%ldp / %ldg / %lds / %ldc]\r\n",
	  GET_PLAT(k), GET_GOLD(k), GET_SILVER(k), GET_COPPER(k),
	  GET_BANK_PLAT(k), GET_BANK_GOLD(k), GET_BANK_SILVER(k), GET_BANK_COPPER(k));
d1589 11
a1599 10
  
  sprintf(buf, "AC: [%d/10], Hitroll: [%2d], Damroll: [%2d], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	  GET_AC(k)+(monk_weight_pen(k)*5), k->points.hitroll - monk_weight_pen(k), k->points.damroll - monk_weight_pen(k), GET_SAVE(k, 0),
	  GET_SAVE(k, 1), GET_SAVE(k, 2), GET_SAVE(k, 3), GET_SAVE(k, 4));
  send_to_char(buf, ch);
  
  sprinttype(GET_POS(k), position_types, buf2);
  sprintf(buf, "Pos: %s, Fighting: %s", buf2,
	  (FIGHTING(k) ? GET_NAME(FIGHTING(k)) : "Nobody"));
  
d1604 2
d1608 1
a1608 2
    strcat(buf, ", Connected: ");
    strcat(buf, buf2);
d1612 8
a1619 8
  strcpy(buf, "Default position: ");
  sprinttype((k->mob_specials.default_pos), position_types, buf2);
  strcat(buf, buf2);
  
  sprintf(buf2, ", Idle Timer (in tics) [%d]\r\n", k->char_specials.timer);
  strcat(buf, buf2);
  send_to_char(buf, ch);
  
d1621 7
a1627 2
    sprintbit(MOB_FLAGS(k), action_bits, buf2);
    sprintf(buf, "NPC flags: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1629 2
a1630 1
  } else {
d1639 29
a1667 18
  if (IS_MOB(k)) {
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d\r\n",
	    (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
	    k->mob_specials.damnodice, k->mob_specials.damsizedice);
    send_to_char(buf, ch);
  }
  sprintf(buf, "Max Carry: weight: %d, items: %d\r\n", CAN_CARRY_W(k), CAN_CARRY_N(k));
  sprintf(buf, "%sCarried: weight: %d, items: %d; ", buf,
	  IS_CARRYING_W(k), IS_CARRYING_N(k));
  
  for (i = 0, j = k->carrying; j; j = j->next_content, i++);
  sprintf(buf, "%sItems in: inventory: %d, ", buf, i);
  
  for (i = 0, i2 = 0; i < NUM_WEARS; i++)
    if (GET_EQ(k, i))
      i2++;
  sprintf(buf2, "eq: %d\r\n", i2);
  strcat(buf, buf2);
d1669 7
a1675 9
  
  sprintf(buf, "Hunger: %d, Thirst: %d, Drunk: %d\r\n",
	  GET_COND(k, FULL), GET_COND(k, THIRST), GET_COND(k, DRUNK));
  send_to_char(buf, ch);
  sprintf(buf, "Consented: %s", ((CONSENT(ch)) ? GET_NAME(CONSENT(ch)) : "<none>"));
  send_to_char(strcat(buf, ",\r\n"), ch);
  sprintf(buf, "Master is: %s, Followers are:",
	  ((k->master) ? GET_NAME(k->master) : "<none>"));
  
d1677 2
a1678 4
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(fol->follower, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (fol->next)
d1681 1
a1681 1
	send_to_char(strcat(buf, "\r\n"), ch);
d1684 1
a1685 1
  
d1688 2
a1689 1
  /*group lists*/
d1692 2
a1693 1
  
d1695 2
a1696 4
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(g->groupee, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (g->next)
d1702 1
d1707 1
a1707 1
  /*major group lists*/
d1711 1
d1713 2
a1714 4
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(mg->mgroupee, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (mg->next)
d1720 1
d1722 6
a1727 3
  sprintf(buf, "%s\r\nGuarding : %s, Guarded by : %s", buf, 
	  k->guarding ? GET_NAME(k->guarding) : "<NULL>",
	  k->guarded_by ? GET_NAME(k->guarded_by) :"<NULL>");
d1729 2
a1730 2
	  k->cornering ? GET_NAME(k->cornering) : "<NULL>",
	  k->cornered_by ? GET_NAME(k->cornered_by) :"<NULL>");
d1733 11
a1743 9
  /* Showing the bitvector */
  sprintbit(AFF_FLAGS(k), affected_bits, buf2);
  sprintf(buf, "AFF: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
  sprintbit(AFF2_FLAGS(k), affected_bits2, buf2);
  sprintf(buf, "AFF2: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);
  sprintbit(AFF3_FLAGS(k), affected_bits3, buf2);
  sprintf(buf, "AFF3: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1746 9
a1754 11
  if (IS_NPC(k))
    {
      send_to_char("Spells MEMMED:", ch);
      for (a = 0;a <= NUM_SPELL_CIRCLES - 4;a++)
	{
	  sprintf(buf, "%d/%d ", (GET_MEM_MEMED(k, a + 1)),
		  spells_of_circle[(int)GET_LEVEL(k)][(a + 1)]);
	  send_to_char(buf, ch);
	}
      send_to_char("\r\n", ch);
    }
d1757 1
a1757 1
  /* Routine to show what spells a char is affected by */
d1798 20
a1817 33
  /* run through the quests the player is on*/
  if (k->quests)
  {
	  /*
	   * shouldn't have to perform this check...
	   */
	  if (all_quests)
	  {
	  	qst=k->quests;
	  	while (qst)
		{
			if ((qid_num = real_quest(qst->quest_id)) >=0)
	  		{
		  		sprintf(buf,"Quest %s: ",all_quests[qid_num ].quest_name);
		  		if (qst->stage == QUEST_SUCCESS)
			  		strcat(buf,"Completed\r\n");
		  		else if (qst->stage == QUEST_FAILURE)
			  		strcat(buf,"Failed\r\n");
		  		else
		  		{
			  		sprintf(buf2,"Stage %d\r\n",qst->stage);
			  		strcat(buf,buf2);
		  		}
		  		send_to_char(buf,ch);
			}
		  	qst = qst->next;
	  	}
	  }
	  else
	  {
		  sprintf(buf,"SYSERR: in do_stat_character, k->quests = %p and there ARE no quests (should be null)",(void*)k->quests);
		  log(buf);
	  }
d1819 2
a1820 1
  /* check mobiles for a script */
d6181 3
@


1.165
log
@IN_ZONE macro is now an rnum.  Updated zstat to use new weather message
data from weather.c.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.164 2007/09/01 22:40:17 jps Exp myc $
d2050 2
d6171 4
@


1.164
log
@do_stat_room lists spells that are in effect.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.163 2007/09/01 21:22:29 jps Exp jps $
d39 1
a39 1

d104 1
a104 4
extern char *hemisphere_name[];
extern char *climate_name[];
extern int num_hemispheres;
extern int num_climates;
d198 1
a198 1
      *first = IN_ZONE(ch);
d2250 1
a2250 1
      vnum = IN_ZONE(ch);
d2269 1
a2269 1
         "Temperature    : &6%d&0\r\n"
d2271 1
a2271 1
         "Wind speed     : &6%d&0\r\n"
d2282 2
a2283 2
         z->hemisphere >= 0 && z->hemisphere < num_hemispheres ?
            hemisphere_name[z->hemisphere] : "<INVALID>",
d2285 2
a2286 2
         z->climate >= 0 && z->climate < num_climates ?
            climate_name[z->climate] : "<INVALID>",
d2289 1
d6169 3
@


1.163
log
@Made _mscript detection routines.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.162 2007/08/26 09:08:56 jps Exp jps $
d1082 3
d1174 10
d6171 3
@


1.162
log
@Adjust long extra desc output. I was tired!
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.161 2007/08/26 08:49:36 jps Exp jps $
d554 57
d6158 3
@


1.161
log
@Added commands estat, oestat, and restat, for viewing extra
descriptions on objects and rooms.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.160 2007/08/24 22:49:05 jps Exp jps $
d997 1
a997 1
         sprintf(buf, "&4==&0 Extra desc: %s%s%s\r\n", CCCYN(ch, C_NRM), desc->keyword,
a1001 1
      send_to_char("&4====&0\r\n", ch);
d6101 4
@


1.160
log
@Added "snum" and "tnum" commands.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.159 2007/08/24 22:10:58 jps Exp jps $
d985 34
a1021 1
  struct extra_descr_data *desc;
d1054 1
a1054 9
  if (rm->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = rm->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
a1175 1
  struct extra_descr_data *desc;
d1359 1
a1359 9
  if (j->ex_description) {
    for (desc = j->ex_description; desc; desc = desc->next) {
      sprintf(buf, "&4==&0 Extra desc: %s%s%s\r\n", CCCYN(ch, C_NRM), desc->keyword,
         CCNRM(ch, C_NRM));
      send_to_char(buf, ch);
      send_to_char(desc->description, ch);
    }
    send_to_char("&4====&0\r\n", ch);
  }
d1366 43
d6102 3
@


1.159
log
@Add commands "slist" and "sstat".
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.158 2007/08/24 19:16:12 myc Exp jps $
d818 22
d6043 3
@


1.158
log
@Fixed 'stat room' to accept a room number, ala 'stat room #'.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.157 2007/08/24 17:01:36 myc Exp myc $
d166 2
d177 3
a187 2
#define MAX_VNUM 99999

d194 6
d1670 1
d1689 5
d4932 11
d6021 3
@


1.157
log
@Adding ostat and mstat commands as shorthand for vstat, rstat for stat
room, and mnum and onum for vnum.  Also adding rnum and znum with new
functionality.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.156 2007/08/24 10:24:16 jps Exp myc $
d1668 5
a1672 5
  if (subcmd == SCMD_RSTAT) {
    if (*buf1) {
      tmp = atoi(buf1);
      tmp = real_room(tmp);
    }
a1680 2
  } else if (is_abbrev(buf1, "room")) {
    do_stat_room(ch, ch->in_room);
d5995 5
@


1.156
log
@Added zlist command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.155 2007/08/22 18:00:11 jps Exp jps $
d767 1
a767 1
  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && !is_abbrev(buf, "obj"))) {
d769 1
a769 3
    return;
  }
  if (is_abbrev(buf, "mob"))
d772 2
a773 2
  
  if (is_abbrev(buf, "obj"))
d776 41
d954 1
a954 1
void do_stat_room(struct char_data * ch)
d958 1
a958 1
  struct room_data *rm = &world[ch->in_room];
d969 1
a969 1
	  rm->zone, CCGRN(ch, C_NRM), rm->number, CCNRM(ch, C_NRM), ch->in_room, buf2);
d1063 1
a1063 1
  do_sstat_room(ch);
d1668 12
a1679 1
  if (!*buf1) {
a1680 1
    return;
d1682 1
a1682 1
    do_stat_room(ch);
d2050 1
a2050 1
  if (!*buf || !*buf2 || !isdigit(*buf2)) {
d2052 5
a2056 3
    return;
  }
  if ((number = atoi(buf2)) < 0) {
d2058 2
a2059 3
    return;
  }
  if (is_abbrev(buf, "mob")) {
d2068 2
a2069 1
  } else if (is_abbrev(buf, "obj")) {
d5997 3
@


1.155
log
@Keep track of the reason the mud is restricted using restrict_reason.
Autoboot usage only shows the things you are allowed to do based
on your level.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.154 2007/08/22 04:21:03 jps Exp jps $
d4774 46
d4842 25
d4868 1
a4868 1
ACMD(do_mlist)
d4870 21
a4890 3
  extern struct index_data *mob_index;
  extern struct char_data *mob_proto;
  extern int top_of_mobt;
d4892 12
a4903 1
  int first, last, nr, found = 0;
d4905 1
a4905 1
  if (!vnumargs(ch, argument, &first, &last)) return;
d4907 2
a4908 5
  for (nr = 0; nr <= top_of_mobt && (mob_index[nr].virtual <= last); nr++) {
    if (mob_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              mob_index[nr].virtual,
              mob_proto[nr].player.short_descr);
d4910 26
a4935 5
    }
  }

  if (!found)
    send_to_char("No mobiles were found in those parameters.\n\r", ch);
a4970 23
ACMD(do_olist)
{
  extern struct index_data *obj_index;
  extern struct obj_data *obj_proto;
  extern int top_of_objt;

  int first, last, nr, found = 0;

  if (!vnumargs(ch, argument, &first, &last)) return;

  for (nr = 0; nr <= top_of_objt && (obj_index[nr].virtual <= last); nr++) {
    if (obj_index[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              obj_index[nr].virtual,
              obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }

  if (!found)
    send_to_char("No objects were found in those parameters.\n\r", ch);
}

d5946 5
@


1.154
log
@Adjust text of reboot-info message.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.153 2007/08/20 21:24:42 jps Exp jps $
d63 1
a63 1
extern int manual_restrict;
d2543 1
a2543 1
       manual_restrict = 1;
d2545 1
a2545 1
       manual_restrict = 0;
d2562 1
a2562 1
  if (!*arg && !manual_restrict)
d4179 1
a4179 1
  if (GET_LEVEL(ch) >= LVL_GOD)
d4361 15
a4375 11
      send_to_char("Usage:\r\n", ch);
      send_to_char("  autoboot off           - disable automatic reboot\r\n", ch);
      send_to_char("  autoboot on            - enable automatic reboot\r\n", ch);
      sprintf(buf, "  autoboot warntime <mn> - warnings begin <mn> minutes before reboot (now %d)\r\n",
            reboot_warning_minutes);
      send_to_char(buf, ch);
      send_to_char("  autoboot [<hr>][:<mn>] - reboot in <hr> hours, <mn> minutes\r\n", ch);
      sprintf(buf, "  autoboot postpone      - postpone reboot to %d minutes from now\r\n",
            2 * reboot_warning_minutes);
      send_to_char(buf, ch);
      send_to_char("\r\n", ch);
d4382 1
a4382 1
      if (GET_LEVEL(ch) < LVL_GOD) {
d4415 1
a4415 1
      if (GET_LEVEL(ch) < LVL_HEAD_C) {
d4440 1
a4440 1
      if (GET_LEVEL(ch) < LVL_HEAD_C) {
d4461 1
a4461 1
      if (GET_LEVEL(ch) < LVL_HEAD_C) {
d4526 1
a4526 1
      if (GET_LEVEL(ch) < LVL_HEAD_C) {
d5851 3
@


1.153
log
@Make "vstat obj" verbosely list object extra descs.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.152 2007/08/17 02:23:36 jps Exp jps $
d4124 1
a4124 1
      sprintf(buf, "Reboot in approximately %02d:%02d:%02d.\r\n", h, m, s);
d5847 3
@


1.152
log
@Generalized some autoboot code, fixed an off-by-one error in the
reboot warning time, and made use of restrict_manual, which will
control whether autoboot code will remove a login restriction.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.151 2007/08/16 12:51:09 jps Exp jps $
a1104 9
  if (j->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = j->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
d1264 10
d5847 5
@


1.151
log
@Added "postpone" and "warntime" to autoboot.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.150 2007/08/15 20:48:41 myc Exp jps $
d63 1
d2540 5
d2561 2
d4349 2
d4405 1
a4405 5
      if (reboot_warning) {
         reboot_warning = 0;
         send_to_all("&6*** Automatic Reboot Postponed ***&0\r\n");
      }

a4428 3
         rebootwarning(reboot_warning_minutes);
         reboot_warning = 1;
         last_reboot_warning = reboot_warning_minutes;
d4430 1
d4451 1
a4451 4
      if (reboot_warning) {
         reboot_warning = 0;
         send_to_all("&6&b*** Automatic Reboot Cancelled ***&0\r\n");
      }
d4486 2
a4487 6
      if (reboot_warning_minutes > minutes && !reboot_warning) {
         /* You've set the reboot_warning_minutes higher such that we're now
          * within the warning zone. Send the warning. */
         rebootwarning(minutes);
         reboot_warning = 1;
         last_reboot_warning = minutes;
d4536 3
a4538 7
         rebootwarning(minutes);
         reboot_warning = 1;
         last_reboot_warning = minutes;
      } else if (reboot_warning) {
         reboot_warning = 0;
         send_to_all("&6&b*** Automatic Reboot Cancelled ***&0\r\n");
      }
d5846 3
@


1.150
log
@The vitem command interprets spellnums for wands and staves correctly now.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.149 2007/08/14 22:43:07 myc Exp myc $
d4342 1
d4346 3
a4348 1
   half_chop(argument, field, buf);
d4350 12
d4366 37
d4454 48
a4501 2
   /* Any parameter other than "on" or "off" is taken to be an amount of
    * time until an automatic reboot. It may be:
d5853 3
@


1.149
log
@Adding cornering and cornered_by to stat char.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.148 2007/08/14 20:13:45 jps Exp myc $
d5610 8
a5617 1
      for (i = 1; i <= maxspells; i++) {
d5755 3
@


1.148
log
@Added command "autoboot" to manage the mud's automatic rebooting.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.147 2007/08/14 10:44:40 jps Exp jps $
d1506 1
a1506 1
  sprintf(buf, "%s\r\nGuarding : %s, Guarded_by : %s", buf, 
d1509 4
a1512 1
  if (*buf)  
d5748 3
@


1.147
log
@Add perform_restore and perform_pain, which are called from do_restore,
do_rrestore, do_pain, or do_rpain as appropriate. Thus, code replication
is reduced AND you only have to change ONE function to make do_restore
and do_rrestore remove a certain affliction. Such as laryngitis, which
by the way restore and rrestore will remove.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.146 2007/08/08 20:09:42 jps Exp jps $
d133 9
d149 2
a1708 3
    /*do global save*/
    Crash_save_all();
    House_save_all();
d1711 1
a1711 20
    send_to_all("Rebooting.. come back in a minute or two.\r\n"
 		"           &1&b** ****** ****&0\r\n"
                "         &1&b**&0 &3&b***     *****&0  &1&b**&0\r\n"
                "       &1&b**&0 &3&b**      &1&b*&0     &3&b***&0  &1&b*&0\r\n"
                "       &1&b*&0    &3&b** **   *   *  *&0 &1&b**&0\r\n"
                "      &1&b*&0  &3&b** * *&0          &1&b*&0     &1&b*&0\r\n"
                "      &1&b*&0  &3&b*&0    &1&b**&0            &3&b* *&0 &1&b*&0\r\n"
                "     &1&b*&0 &3&b* &1&b** *&0     &3&b*   ******&0  &1&b*&0\r\n"
                "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n");
    send_to_all("        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
		"         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
                "                &1&b*&0   &3&b*&0 &1&b*&0\r\n"
                "               &1&b*&0  &3&b* *&0  &1&b*&0\r\n"
                "              &1&b*&0  &3&b*  **&0  &1&b*&0\r\n"
                "              &1&b*&0 &3&b**   *&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0 &1&b*&0\r\n"
                "                &1&b*&0 &3&b*&0  &1&b**&0\r\n"
                "               &1&b**&0     &1&b****&0\r\n"
                "              &1&b***&0  &3&b* *&0    &1&b****&0\r\n");
    touch("../.fastboot");
d4104 3
d4108 13
a4120 1
 ACMD(do_world)
a4121 12
  /************************************************
   * This is a complete HACK, I have no idea what *			   
   * any of these functions do. I suspected that  *
   * removing the date and time subcommands from  *
   * an IF structure would cause seemingly shared *
   * variable names to have to then be different. *
   * Someone may want to check to make sure that  *
   * the memory used by this isn't causing one of *
   * those memory leak things.                    *
   * RSD 7/9/99                                   *
   ************************************************/

d4166 3
a4168 1
  
d4336 114
d5745 7
@


1.146
log
@tlist, mlist, olist, and rlist now accept a single parameter which they
take to be a zone whose objects should be listed.  If no parameter is
given, they will list objects in the current zone - where the character
issuing the command is located.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.145 2007/08/05 20:21:51 myc Exp jps $
d139 1
d2303 11
d2318 2
a2319 2
  struct char_data *vict;
  int i;
d2321 28
a2348 23
  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to restore?\r\n", ch);
  else if (!(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else {
    GET_HIT(vict) = GET_MAX_HIT(vict);
    GET_MANA(vict) = GET_MAX_MANA(vict);
    GET_MOVE(vict) = GET_MAX_MOVE(vict);
    gain_condition(vict, THIRST, 100);
    gain_condition(vict, FULL, 100);
    
    if ((GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_IMMORT)) {
      for (i = 1; i <= MAX_SKILLS; i++)
	SET_SKILL(vict, i, 1000);
      /* next two lines added for the confersion to the 100 attrib scale */
      vict->viewed_abils = vict->natural_abils;
      affect_total(vict);
    }
    update_pos(vict);
    send_to_char(OK, ch);
    act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
  }
d2351 1
a2354 1
   int change;
d2358 1
a2358 1
      send_to_char("Whom do you wish to cause pain too?\r\n",ch);
d2362 1
a2362 5
      change = GET_HIT(vict) * 0.1;
      alter_hit(vict, change, 1);
      change = GET_MOVE(vict) * 0.1;
      alter_move(vict, change);
      update_pos(vict);
d2364 1
a2364 1
      act("A lethal wave of pain and pesilence sent by $N harms you!", FALSE, vict, 0, ch, TO_CHAR);
a4614 1
/* Buru 30/11/97 */
d4616 1
a4616 1
  struct char_data *i;
d4618 8
a4625 18
  for (i = character_list; i; i = i->next)
  {
    if ((i != ch)&&(!IS_NPC(i)))
    {
      if (GET_HIT(i) < GET_MAX_HIT(i))
         GET_HIT(i) = GET_MAX_HIT(i);
      if (GET_MANA(i) < GET_MAX_MANA(i))
         GET_MANA(i) = GET_MAX_MANA(i);
      if (GET_MOVE(i) < GET_MAX_MOVE(i))
         GET_MOVE(i) = GET_MAX_MOVE(i);
      gain_condition(i, THIRST, 100);
      gain_condition(i, FULL, 100);
      act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in $s path!&0",
            FALSE, ch, 0, i, TO_VICT);
      update_pos(i);
    }
  }
  send_to_char(OK, ch);
a4629 1
/*Ace 06/25/2005 - opposite of rrestore*/
a4631 1
   int change;
d4633 6
a4638 9
   for (i = character_list; i; i = i->next)
   {
      if ((i != ch)&&(!IS_NPC(i))&&(GET_LEVEL(i) < 100))
      {
         change = GET_HIT(i) * 0.1;
         alter_hit(i, change, 1);
         change = GET_MOVE(i) * 0.1;
         alter_move(i, change);
         update_pos(i);
a4639 2
      act("&0&1$n &0&9&bspreads pain and pestilence across the realm &0&1&bharming&0&9&b all in $s path!&0",
            FALSE, ch, 0, i, TO_VICT);
d5637 6
@


1.145
log
@Made return command say Huh?!? instead of nothing.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.144 2007/08/05 01:49:45 myc Exp myc $
d144 72
d2043 4
a2046 4
   if (!*str) {
      send_to_char("Usage: zstat <vnum>\r\n", ch);
      return;
   }
a2047 1
   vnum = atoi(str);
d4561 1
a4561 19
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: rlist <begining number> <ending number>\r\n", ch);
    return;
  }

  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
   send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }
a4583 14
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: mlist <begining number> <ending number>\r\n", ch);
    return;
  }

  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }
d4585 1
a4585 4
  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }
d4659 1
a4659 18
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    send_to_char("Usage: olist <begining number> <ending number>\r\n", ch);
    return;
  }
  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }
d5642 3
@


1.144
log
@Gods could de-advance other gods who were higher level.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.143 2007/08/04 03:24:30 myc Exp myc $
d1870 2
d5623 3
@


1.143
log
@dc now accepts character names as parameters.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.142 2007/08/03 22:00:11 myc Exp myc $
d2165 3
a2171 1
  */
d5621 3
@


1.142
log
@Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.141 2007/07/31 23:03:58 jps Exp myc $
d2404 1
a2404 1
  struct descriptor_data *d;
d2408 6
a2413 3
  if (!(num_to_dc = atoi(arg))) {
    send_to_char("Usage: DC <connection number> (type USERS for a list)\r\n", ch);
    return;
d2415 9
a2423 1
  for (d = descriptor_list; d && d->desc_num != num_to_dc; d = d->next);
d2426 1
a2426 1
    send_to_char("No such connection.\r\n", ch);
d2429 3
a2431 1
  if (d->character && GET_LEVEL(d->character) >= GET_LEVEL(ch)) {
d2435 1
d5619 3
@


1.141
log
@Add command "zstat" to stat a zone.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.140 2007/07/19 20:37:17 jps Exp jps $
d237 1
a237 1
	send_to_char("No ampersand sign allowed in input.", ch);
d502 1
a502 1
      send_to_char("Your home room is invalid.", ch);
d1803 1
a1803 1
      send_to_char("You don't have permission to change that name.",ch);
d2052 1
a2052 1
	    send_to_char("Too many names to show them all!", ch);
d2952 1
a2952 1
    send_to_char("Mobile's do not have godly titles...nice try.", ch);
d2955 1
a2955 1
    send_to_char("Godly Titles can't contain the [ or ] characters.", ch);
d3363 1
a3363 1
      send_to_char("Couldn't find that player.", ch); 
d3370 1
a3370 1
	send_to_char("There are no notes for that file.", ch); 
d4902 1
a4902 1
      send_to_char("That is not a valid language.", ch);
d5605 3
@


1.140
log
@Print any action desc in do_stat_object.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.139 2007/07/15 18:01:32 jps Exp jps $
d102 6
d1961 59
d5605 3
@


1.139
log
@Created macro IS_POISONED.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.138 2007/07/15 17:40:22 myc Exp jps $
d1007 7
a1013 1
  
d5540 3
@


1.138
log
@Fixed memory corruption crash bug in vitem and vwear commands.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.137 2007/07/14 05:26:25 myc Exp myc $
d1114 1
a1114 1
	    GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), YESNO(GET_OBJ_VAL(j, 3)),
d1125 1
a1125 1
	    YESNO(GET_OBJ_VAL(j, 3)));
d5534 3
@


1.137
log
@Players no longer lose all their hard-earned play time when de-advanced.
The last check-in for this mixed up ch and victim.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.136 2007/06/04 22:24:41 jps Exp myc $
d5222 1
a5222 1
  int nr, found = 0, print = 0;
d5225 3
a5227 2
  sprintf(vwear_buf, " Num   Lvl   Obnum  Desc\r\n");
  sprintf(vwear_buf, "%s ---   ---   -----  ----\r\n", vwear_buf);
d5230 23
a5252 28
    print = 0;
    if (CAN_WEAR(&obj_proto[nr], wearpos)) {
      if (low_lev >= 0 && high_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj >= low_lev &&
            obj_proto[nr].obj_flags.level_obj <= high_lev) {
          print = 1;
        } 
      } else if (mid_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj == mid_lev) {
          print = 1;
        } 
      } else if (low_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj <= low_lev) {
          print = 1;
        } 
      } else if (high_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj >= high_lev) {
          print = 1;
        } 
      } else {
        print = 1;
      }
      if (print == 1) {
        sprintf(vwear_buf, "%s %3d.  %3d   %5d  %s\r\n", vwear_buf, ++found,
        obj_proto[nr].obj_flags.level_obj,
        obj_index[nr].virtual, obj_proto[nr].short_description); 
      }
    }
d5256 3
a5258 1
  else
d5260 1
d5354 2
a5355 2
  int nr, found = 0, print = 0, numspells = 0, maxspells = 0, i;
  char vwear_buf[50000]; 
d5359 3
a5361 2
  sprintf(vwear_buf, " Num   Lvl   Obnum  Desc\r\n");
  sprintf(vwear_buf, "%s ---   ---   -----  ----\r\n", vwear_buf);
d5364 43
a5406 21
    print = 0;
    if (GET_OBJ_TYPE(&obj_proto[nr]) == type) {
      if (low_lev >= 0 && high_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj >= low_lev &&
            obj_proto[nr].obj_flags.level_obj <= high_lev) {
          print = 1;
        } 
      } else if (mid_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj == mid_lev) {
          print = 1;
        } 
      } else if (low_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj <= low_lev) {
          print = 1;
        } 
      } else if (high_lev >= 0) {
        if (obj_proto[nr].obj_flags.level_obj >= high_lev) {
          print = 1;
        } 
      } else {
        print = 1;
d5408 7
a5414 42
      if (print == 1) {
         spells_buf[0] = '\0';
         numspells = 0;

         switch (GET_OBJ_TYPE(&obj_proto[nr])) {
            case ITEM_SCROLL:
            case ITEM_POTION:
               spellitem = TRUE;
               maxspells = 3;
               break;
            case ITEM_WAND:
            case ITEM_STAFF:
               spellitem = TRUE;
               maxspells = 1;
         }

         if (spellitem) {
            for (i = 1; i <= maxspells; i++) {
               if (GET_OBJ_VAL(&obj_proto[nr], i) > 0) {
                  if (!numspells)
                     strcat(spells_buf, " ");
                  numspells++;
                  sprintf(buf, " &7%3d. &2%s                    ",
                        GET_OBJ_VAL(&obj_proto[nr], i),
                        spells[GET_OBJ_VAL(&obj_proto[nr], i)]);
                  sprintf(buf + 24, "&0 ");
                  strcat(spells_buf, buf);
               }
            }
            if (!numspells) {
               if (maxspells == 1) {
                  sprintf(buf, "  (&3no spell&0)");
               } else {
                  sprintf(buf, "  (&3no spells&0)");
               }
               strcat(spells_buf, buf);
            }
         }

        sprintf(vwear_buf, "%s %3d.  %3d   %5d  %-35s%s\r\n", vwear_buf, ++found,
        obj_proto[nr].obj_flags.level_obj,
        obj_index[nr].virtual, obj_proto[nr].short_description, spells_buf); 
d5417 9
d5429 3
a5431 1
  else
d5433 1
d5534 4
@


1.136
log
@Add game-toggle for name approval pause and set name approval to default on.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.135 2007/05/29 00:36:03 jps Exp jps $
d2124 2
a2125 1
    playtime = ch->player.time.played;
d2127 1
a2127 1
    ch->player.time.played = playtime;
d5535 3
@


1.135
log
@Make a utility function find_zone, to find a zone's entry in the zone
table, from a vnum.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.134 2007/05/28 22:34:21 jps Exp jps $
d80 1
d4063 5
d5534 4
@


1.134
log
@Remove unused variable that was causing a warning.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.133 2007/05/28 20:08:10 jps Exp jps $
d131 1
d3134 7
a3140 8
      for (j = atoi(value), i = 0; zone_table[i].number != j && i <= top_of_zone_table; i++);
      if (i <= top_of_zone_table) {
	print_zone_to_buf(buf, i);
	send_to_char(buf, ch);
      } else {
	send_to_char("That is not a valid zone.\r\n", ch);
	return;
      }
d5528 3
@


1.133
log
@Include the year in dates in 'show player'.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.132 2007/05/21 02:18:24 myc Exp jps $
d3068 1
a3068 1
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH], birth[80];
d5528 3
@


1.132
log
@Stat room shows hidden door commands too now.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.131 2007/04/18 00:11:12 myc Exp myc $
d3169 2
a3170 1
    strcpy(birth, ctime(&vbuf.birth));
d3172 2
a3173 2
	    "%sStarted: %-20.16s  Last: %-20.16s  Played: %3dh %2dm\r\n",
	    buf, birth, ctime(&vbuf.last_logon), (int) (vbuf.played / 3600),
d5528 3
@


1.131
log
@Stat room now shows zone commands in that room.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.130 2007/04/17 23:59:16 myc Exp myc $
d803 1
a803 1
              ZOCMD.arg3 ? ((ZOCMD.arg3 == 1) ? "closed" : "locked") : "open"
d5527 3
@


1.130
log
@New trigger type: Load.  It goes off any time a mobile is loaded, whether
it be god command, zone command, or trigger command.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.129 2007/04/15 10:50:24 jps Exp myc $
d687 133
d927 3
a929 1
  
d5527 4
@


1.129
log
@Change 'set title' to LVL_GOD.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.128 2007/04/15 04:12:47 jps Exp jps $
d1755 1
d5392 3
@


1.128
log
@Fix bug in stat spellbook.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.127 2007/04/15 03:55:08 jps Exp jps $
d3231 1
a3231 1
   { "title",		LVL_HEAD_B, 	PC, 	MISC   },
d5391 3
@


1.127
log
@do_stat_object now gives information about spells in spellbooks.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.126 2007/04/04 13:31:02 jps Exp jps $
d806 1
d5391 3
@


1.126
log
@Add year to log timestamps and other dates.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.125 2007/02/08 01:30:00 myc Exp jps $
d130 2
d800 47
d1036 2
d5390 3
@


1.125
log
@Players no longer lose all their hard-earned play time when de-advanced.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.124 2006/11/23 01:38:27 jps Exp myc $
d1063 3
a1065 4
    strcpy(buf1, (char *) asctime(localtime(&(k->player.time.birth))));
    strcpy(buf2, (char *) asctime(localtime(&(k->player.time.logon))));
    buf1[10] = buf2[10] = '\0';
    
d5339 3
@


1.124
log
@vitem will now display the spells in magical casting objects
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.123 2006/11/18 04:26:32 jps Exp jps $
d1889 1
a1889 1
  int newlevel, oldlevel;
d1935 1
d1937 1
d5340 3
@


1.123
log
@Renamed continual light spell to illumination, and it only works on
LIGHT items (still rooms too).
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.122 2006/11/16 18:42:45 jps Exp jps $
d5158 1
a5158 1
  int nr, found = 0, print = 0;
d5160 2
d5190 39
a5228 1
        sprintf(vwear_buf, "%s %3d.  %3d   %5d  %s\r\n", vwear_buf, ++found,
d5230 1
a5230 1
        obj_index[nr].virtual, obj_proto[nr].short_description); 
d5338 4
@


1.122
log
@Awareness of new surroundings when magically tranported is related to
being asleep, blindness, etc.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.121 2006/11/13 19:08:49 jps Exp jps $
d884 1
a884 1
      sprintf(buf, "Hours left: [%d]", GET_OBJ_VAL(j, 2));
d5298 4
@


1.121
log
@make dig mark the correct zones as needing saving
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.120 2006/11/13 15:54:22 jps Exp jps $
d47 1
d585 1
d601 1
d607 1
a607 1
      look_at_room(victim, 0);
d621 1
d627 1
a627 1
	look_at_room(victim, 0);
d639 1
d656 1
d662 1
a662 1
    look_at_room(victim, 0);
d5298 3
@


1.120
log
@Fix widespread misuse of the hide_invisible parameter to act().
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.119 2006/11/12 02:31:01 jps Exp jps $
d4182 4
a4185 1
  olc_add_to_save_list((iroom/100), OLC_SAVE_ROOM);
d5292 3
@


1.119
log
@You become unmounted when magically moved to another room.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.118 2006/11/12 01:47:11 jps Exp jps $
d2272 1
a2272 1
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
d2286 1
a2286 1
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
d2299 1
a2299 1
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
d4287 2
a4288 1
      act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in its path!&0", TRUE, ch, 0, i, TO_VICT);
d4312 2
a4313 1
      act("&0&1$n &0&9&bspreads pain and pestilence across the realm &0&1&bharming&0&9&b all in its path!&0",TRUE, ch, 0, i, TO_VICT);
d5289 3
@


1.118
log
@restore and rrestore will fix hunger and thirst
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.117 2006/06/24 18:34:22 rsd Exp jps $
d46 2
d503 1
d599 1
d618 1
d651 1
d5287 3
@


1.117
log
@zzur can change passwords
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.116 2006/05/08 15:55:08 cjd Exp $
d1968 2
d4279 2
d5281 3
@


1.116
log
@fixed misplaced bracket that was causing pain crash with no arg
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.115 2006/05/03 01:27:30 rsd Exp $
d3569 1
a3569 1
    if (GET_IDNUM(ch) > 2) {
d5277 3
@


1.115
log
@altered how iptables works to use a user defined chain
just for the mud so the muds process doesn't have to
see or deal with the main chain.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.114 2006/04/09 22:37:31 rls Exp $
d1988 1
a1988 1
   if (!*buf)
d1997 3
a2000 3
   update_pos(vict);
   send_to_char(OK, ch);
   act("A lethal wave of pain and pesilence sent by $N harms you!", FALSE, vict, 0, ch, TO_CHAR);
a4298 1
         act("&0&1$n &0&9&bspreads fear and pestilence across the realm &0&1&bharming&0&9&b all in its path!&0", TRUE, ch, 0, i, TO_VICT);
d4301 1
d5277 5
@


1.114
log
@Updated poof to return current poof on no argument
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.113 2006/04/09 01:00:00 rls Exp $
d149 1
a149 1
    sprintf(cBuf3, "/sbin/iptables --list INPUT -v -n --line-numbers > %s", 
d172 1
a172 1
      sprintf(cBuf, "/sbin/iptables -A INPUT --source %s --protocol tcp --dport 80 --jump ACCEPT", argument); 
d174 1
a174 1
      sprintf(cBuf2, "/sbin/iptables -A INPUT --source %s --protocol tcp --dport 22 --jump ACCEPT", argument); 
d182 2
d185 7
d196 1
a196 1
      sprintf(cBuf2, "/sbin/iptables -D INPUT %d", lineNum); 
a197 1
      
d199 1
d5277 3
@


1.113
log
@Adjusted set command structure.
@@
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.112 2005/12/31 21:26:04 dce Exp $
a2083 1

d2086 2
a2087 1
  switch (subcmd) {
d2089 2
a2090 1
    if(argument)
d2092 2
d2095 1
a2095 1
      strcpy(POOFIN(ch), "\0");
d2098 2
a2099 1
    if(argument)
d2101 2
d2104 1
a2104 1
      strcpy(POOFOUT(ch), "\0");
d2106 1
a2106 1
  default:
d2110 2
a2111 1
  send_to_char(OK, ch);
d5268 4
@


1.112
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.111 2005/12/31 20:39:22 dce Exp dce $
d3150 15
a3164 15
   { "maxhit",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "maxmana", 	LVL_HEAD_B, 	BOTH, 	NUMBER }, /* 5*/
   { "maxmove", 	LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "hit", 		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "mana",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "move",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "align",		LVL_HEAD_B, 	BOTH, 	NUMBER }, /*10*/
   { "str",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "stradd",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "int", 		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "wis", 		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "dex", 		LVL_HEAD_B, 	BOTH, 	NUMBER }, /*15*/
   { "con", 		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "sex", 		LVL_HEAD_B, 	BOTH, 	MISC   },
   { "ac", 		LVL_HEAD_B, 	BOTH, 	NUMBER },
d3166 1
a3166 1
   { "home",	        LVL_GRGOD,	PC,	NUMBER },
d3168 2
a3169 2
   { "hitroll", 	LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "damroll", 	LVL_HEAD_B, 	BOTH, 	NUMBER },
d3175 1
a3175 1
   { "drunk",		LVL_HEAD_B, 	BOTH, 	MISC   },
d3185 1
a3185 1
   { "class",		LVL_HEAD_B, 	BOTH, 	MISC   },
d3188 1
a3188 1
   { "loadroom", 	LVL_HEAD_B, 	PC, 	MISC   },
d3191 1
a3191 1
   { "passwd",		LVL_HEAD_C, 	PC, 	MISC   }, /*45*/
d3193 2
a3194 2
   { "cha",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "race",            LVL_HEAD_B,     PC,     MISC   },
d3199 8
a3206 8
   { "plat",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "gold",		LVL_HEAD_B, 	BOTH, 	NUMBER },   
   { "silver",		LVL_HEAD_B, 	BOTH, 	NUMBER }, /*55*/
   { "copper",		LVL_HEAD_B, 	BOTH, 	NUMBER },
   { "pbank",		LVL_HEAD_B, 	PC, 	NUMBER },
   { "gbank",		LVL_HEAD_B, 	PC, 	NUMBER },
   { "sbank",		LVL_HEAD_B, 	PC, 	NUMBER },  
   { "cbank",		LVL_HEAD_B, 	PC, 	NUMBER }, /*60*/
d3210 4
a3213 4
   { "rename",	        LVL_GRGOD,	PC,	BINARY },
   { "napprove",        LVL_GRGOD,	PC,	BINARY }, /*65*/
   { "holylight",       LVL_GRGOD,      PC,     BINARY },
   { "wiztitle",        LVL_HEAD_B,     PC,     MISC   },
d3215 1
a3215 1
   { "size",		LVL_GRGOD,      PC,     NUMBER },
d5261 3
@


1.111
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.110 2005/07/27 03:07:08 jwk Exp dce $
a145 3
system(argument);
return;

d5261 3
@


1.110
log
@Changed level for setting wiztitle from 104 to 103
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.109 2005/07/13 21:37:01 cjd Exp $
d146 3
d5264 3
@


1.109
log
@changed pain and rpain to from direct edit to use alter's
to allow chars to regen. which they weren't before.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.108 2005/06/26 03:39:37 cjd Exp $
d3213 1
a3213 1
   { "wiztitle",        LVL_HEAD_C,     PC,     MISC   },
d5261 4
@


1.108
log
@stupid typo's, fixed rpain bug where
chars mv was going to 0
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.107 2005/06/26 03:14:17 cjd Exp $
d1976 1
d1984 4
a1987 3
      GET_HIT(vict) = GET_HIT(vict) * 0.9;
      GET_MANA(vict) = GET_MANA(vict) * 0.9;
      GET_MOVE(vict) = GET_MOVE(vict) * 0.9;
d4273 1
d4279 4
a4282 3
         GET_HIT(i) = GET_HIT(i) * 0.9;
         GET_MANA(i) = GET_MANA(i) * 0.9;
         GET_MOVE(i) = GET_MOVE(i) * 0.9;
d5261 4
@


1.107
log
@created pain and rpain commands as the oppsoite of restore
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.106 2004/11/11 23:12:48 rsd Exp $
d4278 1
a4278 1
         GET_MOVE(i) = GET_MANA(i) * 0.9;
d5257 3
@


1.106
log
@Made the mushroom clouds associated with rebooting
into 2 send_to_all()'s to reduce the string size
to be less than 509 bytes.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.105 2004/11/11 20:11:09 cmc Exp $
d1973 18
d4267 18
d5257 5
@


1.105
log
@commented out reference to title_type titles
compiler warning now deceased
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.104 2004/11/01 04:12:01 jjl Exp cmc $
d1417 3
a1419 3
                "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n"
                "        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
                "         &1&b*****&0   &3&b*     *   * *&0 &1&b*&0\r\n"
d1441 2
a1442 2
                "      &1&b*&0   &3&b* &1&b* **&0  &3&b***&0     &1&b*&0  &3&b*&0 &1&b*&0\r\n"
                "        &1&b*&0  &3&b*  *&0 &1&b**********&0  &3&b***&0 &1&b*&0\r\n"
d5221 4
@


1.104
log
@Changing iptables so it can be run on multiple muds concurrently.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.103 2004/11/01 03:46:22 jjl Exp $
d51 1
a51 1
extern struct title_type titles[NUM_CLASSES][LVL_IMPL + 1];
d5221 3
@


1.103
log
@Buffed up iptables adding add/list/delete command
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.102 2004/11/01 01:14:26 rsd Exp $
d135 1
a135 1
  char *tmpfile = "/tmp/iptables.list"; 
d143 2
d161 4
a164 1
    
d196 1
d5221 3
@


1.102
log
@Ok, added a bit more functionality to the iptables command
and added some very basic input checking, it needs more.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.101 2004/10/31 20:38:11 jjl Exp $
d23 1
d135 4
a138 1
  skip_spaces(&argument); 
d143 43
a186 7
  /* Ok I'd like some argument parsing here for sanity.
     No blank arguments, no arguments other than IP addresses
     really.. -RSD
  */
  if (strlen(argument) < 7 || strlen(argument) > 15) {
    send_to_char("What IP address do you want allowed?\r\n", ch);
    return;
d188 1
a188 8
    sprintf(cBuf, "/sbin/iptables -A INPUT --source %s --protocol tcp --dport 80 --jump ACCEPT", argument); 
    system(cBuf); 
    sprintf(cBuf2, "/sbin/iptables -A INPUT --source %s --protocol tcp --dport 22 --jump ACCEPT", argument); 
    system(cBuf2); 
    sprintf(cBuf3, "/sbin/iptables --list INPUT -v -n --line-numbers"); 
    system(cBuf3);
    /*    sprintf(buf, "Argument is [%s]", argument); 
	  send_to_char(buf, ch); */
d190 2
a191 1
  
d5215 4
@


1.101
log
@Adding iptables command
for zzur to hack on
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.100 2003/06/25 02:57:15 jjl Exp $
d132 2
d140 18
a157 5
  sprintf(cBuf, "/sbin/iptables -A INPUT --source %s --protocol tcp --dport 80 --jump ACCEPT", argument); 
  system(cBuf); 

  send_to_char("Ok!\r\n", ch); 

d5181 4
@


1.100
log
@Fixed a DUMB typo
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.99 2003/06/23 01:47:09 jjl Exp jjl $
d22 1
d130 15
d5166 3
@


1.99
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.98 2002/11/30 19:39:38 jjl Exp $
d2996 1
a2996 1
	if (strlen(zonebuf) < 49500) {
d5150 3
@


1.98
log
@Added the ability for GAME commands to have integer values, and added a
GROUPING game command, that allows you to set a maximum level difference
between group masters and potential groupees..
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.97 2002/09/14 00:12:50 dce Exp $
d2781 1
d2972 39
d5150 5
@


1.97
log
@Put show shops to level 101.
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.96 2002/09/13 02:32:10 jjl Exp $
d58 1
d3658 1
a3658 1
  int i, n_visible = 0;
d3663 1
d3671 1
a3671 1
    { "RACES",      &races_allowed,         LVL_HEAD_C, 
d3676 1
a3676 1
    { "GOOD_RACES", &good_races_allowed,    LVL_HEAD_C, 
d3681 1
a3681 1
    { "PK",         &pk_allowed,            LVL_HEAD_C, 
d3686 1
a3686 1
    { "SLEEP",      &sleep_allowed,         LVL_HEAD_C, 
d3691 1
a3691 1
    { "SUMMON",     &summon_allowed,        LVL_HEAD_C, 
d3696 1
a3696 1
    { "CHARM",      &charm_allowed,         LVL_HEAD_C, 
d3701 1
a3701 1
    { "ROOMAFFECT", &roomaffect_allowed,    LVL_HEAD_C, 
d3706 1
a3706 1
    { "NAMES",      &approve_names,         LVL_HEAD_C, 
d3711 1
a3711 1
    { "OOC",        &gossip_channel_active, LVL_BUILDER,
d3716 1
a3716 1
    { "SLOWNS",     &nameserver_is_slow,    LVL_HEAD_C,
d3721 1
a3721 1
    { "LEVELGAIN",  &level_gain,            LVL_HEAD_C,
d3726 1
a3726 1
    { "DAMAGEAMTS",  &damage_amounts,            LVL_HEAD_C,
d3731 7
a3737 1
    { NULL, NULL, 0, NULL, NULL }
d3753 1
d3756 13
a3768 2
	sprintf(linebuf, "%-19s%s\r\n", shortbuf, *commands[i].config ? 
		commands[i].enabled : commands[i].disabled);
d3776 12
a3787 2
  /* if we've gotten this far then the field was recognized and of suitable 
   * level. toggle it and send an appropriate message */
d3790 2
a3791 2
  sprintf(linebuf, msg, GET_NAME(ch));
  send_to_imms(linebuf);
d3793 11
d5110 3
@


1.96
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.wizard.c,v 1.95 2002/07/02 12:51:57 rls Exp $
d2777 1
a2777 1
    { "shops",		LVL_IMMORT },
d5069 3
@


1.95
log
@forgot the shutdown for maintenence 'shroom... *wink*
@
text
@d1 3
a3 1
// $Id: act.wizard.c,v 1.94 2002/07/02 06:46:24 rls Exp $
d1229 1
a1229 1
		  sprintf(buf,"SYSERR: in do_stat_character, k->quests = %p and there ARE no quests (should be null)",k->quests);
d3008 5
a3012 5
  struct set_struct {  // LVL_OVERLORD   105
    char *cmd;         // LVL_HEAD_C     104
    char level;        // LVL_HEAD_B     103
    char pcnpc;        // LVL_GRGOD      102
    char type;         // LVL_GOD        101
d4441 1
a4441 1
      //delete and purge
d5067 421
a5487 416
// $Log: act.wizard.c,v $
// Revision 1.94  2002/07/02 06:46:24  rls
// Colorized Mushroom (YAY!)
//
// Revision 1.93  2002/06/21 04:32:15  rls
// Adjusted rrestore to not take away excess hit, mana or move
// gained from such spells as energy drain, etc.
//
// Revision 1.92  2002/06/07 01:14:26  rls
// Commented out the emote case for Zzur
//
// Revision 1.91  2002/05/23 00:19:41  rls
// Added set size functionality and fixed set charisma for 100pts
//
// Revision 1.90  2002/03/30 19:20:14  dce
// Added damage amounts as a toggable item.
//
// Revision 1.89  2002/03/15 02:45:14  dce
// Increased wiztitle from 11 to 12.
//
// Revision 1.88  2002/02/25 09:48:42  rls
// Updated wiztitle function per request to format for 11 characters
//
// Revision 1.87  2001/10/22 01:35:58  dce
// Changedset passwd to a level 104 command.
//
// Revision 1.86  2001/04/08 17:23:46  dce
// Show file was overwritting the buffer, so I increased
// the size by using a new buffer.
//
// Revision 1.85  2001/04/07 17:02:30  dce
// Added the vitem command.
//
// Revision 1.84  2001/04/02 03:18:41  dce
// Added the command vwear.
//
// Revision 1.83  2001/03/31 22:17:56  dce
// Tried to increase zonebuf larger than MAX_STIRNG_LENGTH
// I am curious if this will crash the mud. (show zones).
//
// Revision 1.82  2001/03/28 02:08:26  dce
// Show file works as advertised.
//
// Revision 1.81  2001/03/26 02:17:18  dce
// Show file now goes beyond one page.
//
// Revision 1.80  2001/03/24 19:42:27  dce
// Stating an object will show the level.
//
// Revision 1.79  2001/03/10 18:45:33  dce
// Changed do_return function to pass a subcommand of 1.
// This way I can make it so players can't use the return command.
//
// Revision 1.78  2001/03/07 03:08:09  dce
// Fixed the output.
//
// Revision 1.77  2001/03/04 14:27:39  dce
// Added the page function to show zones.
//
// Revision 1.76  2001/03/03 18:07:10  dce
// Gods should not be able to use return from a shapechange.
// Also mortals can no longer use return.
//
// Revision 1.75  2001/01/29 05:05:30  rsd
// Ok, aded a couple of include to call mkdir so Jimmy and
// I could redo pfile maint to clean up bogus files that
// weren't being accounted for in the way pfilemaint was
// being done.
//
// Revision 1.74  2000/11/28 00:46:32  mtp
// remove mobprog stuff
//
// Revision 1.73  2000/11/25 08:12:06  rsd
// Altered some of do_show() to comment why the case:zones
// can't be put through the paging function.
//
// Revision 1.72  2000/11/20 05:02:57  rsd
// added back rlog messages from before the addition of the
// $log$ string.
// grumble
//
// Revision 1.71  2000/11/16 02:43:00  rsd
// added a check in do_name() nlist so if players names have
// been declined they won't show up in nlist among the players
// who are awaiting approval.
//
// Revision 1.70  2000/11/11 00:04:36  mtp
// continue processing quest list even if a bad one was found
//
// Revision 1.69  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.68  2000/11/03 05:37:17  jimmy
// Removed the quest.h file from structs.h arg!! and placed it
// only in the appropriate files
// Updated the dependancies in the Makefile and created
// make supahclean.
//
// Revision 1.67  2000/11/02 23:41:19  mtp
// added qid_num for debugging purposes
//
// Revision 1.66  2000/11/02 23:38:09  mtp
// real_quest() for non existant virtual quest returns -1!
//
// Revision 1.65  2000/11/01 00:44:35  mtp
// added extra check to avoid crashing mud...dunno why quests is not being nulled though
//
// Revision 1.64  2000/10/27 00:34:45  mtp
// modeified do_stat to show quest info
//
// Revision 1.63  2000/10/13 04:27:23  cmc
// added "level gain" toggle
// typo correction duties
//
// Revision 1.62  2000/09/14 00:54:08  rsd
// Fixed purge again, put proper logic not to return out
// of the function in it.
//
// Revision 1.61  2000/09/13 22:20:43  rsd
// altered the level at which set sub commands are avail
//
// Revision 1.60  2000/09/13 21:06:28  rsd
// Fixed it so object without any wear flags, notably TAKE
// , are not purged unless it's an argument.  So boards and
// fountains etc won't be purged on a room purge.
// Like the old Fiery.  Also
// In do_players added the players level in (parens) so it's
// easier to tell if anyone has advanced and needs name approval
// just some admin stuffs.
//
// Revision 1.59  2000/08/31 17:45:35  rsd
// Ok, more passwd changes
//
// Revision 1.58  2000/04/26 23:33:56  rsd
// made name declination a little more obvious to the players
// Also took some lame text out of the terminate command
//
// Revision 1.57  2000/04/22 22:31:41  rsd
// fixed spelling of deity in player output.
//
// Revision 1.56  2000/04/14 19:09:35  rsd
// passwd changes
//
// Revision 1.55  2000/04/14 18:56:15  rsd
// OK I can definately use it now
//
// Revision 1.54  2000/04/14 18:52:26  rsd
// I moved passwd to my level I swear
//
// Revision 1.53  2000/04/14 18:48:34  rsd
// made passwd my level
//
// Revision 1.52  2000/02/25 02:42:00  rsd
// added room and zone info to do_world, I even made a
// variable for it woo.
// /s
//
// Revision 1.51  2000/02/24 01:04:18  dce
// Changed wiztitle from a command to a set.
//
// Revision 1.50  2000/02/16 07:58:39  mtp
// added listrace...it just prints the choice menu that people have when they start
//
// Revision 1.49  2000/02/16 07:16:12  rsd
// Aredryk fixed show zones (all) to fix overflow so the
// list wouldn't truncate and stomp memory
//
// Revision 1.48  2000/01/31 03:58:41  cso
// modified do_game to allow different game toggles to have different
// min levels. it also looked ugly and kludgy, so i recoded it from scratch
//
// Revision 1.47  2000/01/30 23:11:18  rsd
// added parts to allow a good races toggle in
// addition to the existing complete race login toggle.
//
// Revision 1.46  1999/11/28 22:49:49  cso
// do_stat_object: made stat on corpse reflect whether raisable or not
// do_wizutil: unaffecting animated mob kills it
//
// Revision 1.45  1999/10/30 15:21:06  rsd
// removed superflous void gain_exp(struct... definition
// redundancy isn't needed.
//
// Revision 1.44  1999/10/04 21:39:18  rsd
// Made holylight a set as well as a toggle, we have a mortal
// who got it set on in a rez bug.
//
// Revision 1.43  1999/09/16 01:15:11  dce
// Weight restrictions for monks...-hitroll, -damroll + ac
//
// Revision 1.42  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.41  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most significant
// changes were moving all the BREATH's to within normal spell range, and
// fixing the way socials were allocated.  Too many small fixes to list them
// all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.40  1999/08/18 22:39:24  mtp
// fixed afk bug in ptell
//
// Revision 1.39  1999/08/12 21:01:00  mud
// Added the build number and compiled date functionality
// to the world command. Reformatted the game command to add
// spanky colors with the keyword toggles in addition to the
// lines that indicate what state each toggle is in.
//
// Revision 1.38  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.37  1999/08/12 06:15:03  mtp
// Added AFK message for ptell
//
// Revision 1.36  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.35  1999/07/29 20:19:35  jimmy
// Added an idle time deletion algorithm to pfilemaint.  Players will now
// be autodeleted after 14+((level - 1) * 3) days of idle time.
// --gurlaek
//
// Revision 1.34  1999/07/26 00:20:59  mud
// altered the priority of red and yellow color in do_players
// so that players who are set newname on will take higher
// precedence over those with napprove on.
//
// Revision 1.33  1999/07/24 23:27:13  jimmy
// Yet another fix to pfilemaint.  Pfilemaint now destroys the old
// player_table and rebuilds it on the fly.  NO more wierdness.
// 
// --Gurlaek
//
// Revision 1.32  1999/07/23 23:37:38  jimmy
// Fixed pfilemaint to do more sanity checking before deletions.
// Only deletions are now logged and each is logged with a reason.
// removed the send_toxnames from do_set "rename".  This should ahve
// been in the interpreter all along and that's where i moved it from
// in the first place.
// --gurlaek
//
// Revision 1.31  1999/07/22 17:43:59  jimmy
// Wrote a new command to do player file maintenace called pfilemaint.
// This command will purge the player file using the same criteria
// for creating new playes.  So, if it's in the xnames, it gets waxed
// from the player file.  This will also take care of blank records
// and reserved words.
// --gurlaek
//
// Revision 1.30  1999/07/10 15:41:23  mud
// added SLOWNS to the game toggles.
//
// Revision 1.29  1999/07/10 05:30:49  mud
// made OOC a game sumcommand to prepare it to be removed
// from the toggle subcommand list. And it works! wooo!
//
// Revision 1.28  1999/07/10 03:13:30  mud
// Ok, I think I fixed the date command, I'm not very confident
// that it works perfectly and someone should probably double
// check my work.
//
// Revision 1.27  1999/07/07 22:53:38  mud
// added the guts of the new do_world command, basically
// stole the date subcommands and took out the logic splitting
// them into two commands.
//
// Revision 1.26  1999/07/07 22:07:12  mud
// Changed the do_world command to do game and altered the format
// and color.
//
// Revision 1.25  1999/07/06 19:57:05  jimmy
// This is a Mass check-in of the new skill/spell/language assignment system.
// This New system combines the assignment of skill/spell/language for
// both mobs and PCs.  LOts of code was touched and many errors were fixed.
// MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
// MObs now get random skill/spell/language levels baseed on their race/class/level
// that exactly align with PC's.  PC's no longer have to rent to use skills gained
// by leveling or when first creating a char.  Languages no longer reset to defaults
// when a PC levels.  Discovered that languages have been defined right in the middle
// of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
// the mob files to compensate for the 13 to -1 class change.
// --gurlaek 7/6/1999
//
// Revision 1.24  1999/06/30 18:11:09  jimmy
// act.offensive.c    config.c      handler.c    spells.c
// his is a major conversion from the 18 point attribute system to the
// 100 point attribute system.  A few of the major changes are:
// All attributes are now on a scale from 0-100
// Everyone views attribs the same but, the attribs for one race
//   may be differeent for that of another even if they are the
//   same number.
// Mobs attribs now get rolled and scaled using the same algorithim as PC's
// Mobs now have individual random attributes based on race/class.
// The STR_ADD attrib has been completely removed.
// All bonus tables for attribs in constants.c have been replaced by
//   algorithims that closely duplicate the tables except on a 100 scale.
// Some minor changes:
// Race selection at char creation can now be toggled by using
//   <world races off>
// Lots of cleanup done to affected areas of code.
// Setting attributes for mobs in the .mob file no longer functions
//   but is still in the code for later use.
// We now have a spare attribut structure in the pfile because the new
//   system only used three instead of four.
// --gurlaek 6/30/1999
//
// Revision 1.23  1999/06/22 18:23:36  jimmy
// Added more checks for d->character in ndecline and naccept to stop
// crashes when people were at CON_QANSI etc etc and ndecline or naccept
// were typed.
// gurlaek
//
// Revision 1.22  1999/06/18 21:56:51  mud
// Added code to make set file renames write to xnames file
// so those players who are denied and aren't online will be
// written to xnames
// I'm the man
//
// Revision 1.21  1999/06/18 17:25:42  jimmy
// added check for d->character in the nlist (do_name) command.  This
// fixed the problem of crashes when people where at CON_QANSI or
// anywhere before their d->character's where created and someone typed
// nlist.  --gurlaek.
//
// Revision 1.20  1999/06/11 17:58:10  jimmy
// tweaked do_players to better utilize memory. --gurlaek
//
// Revision 1.19  1999/06/10 21:47:42  mud
// Added color code to do_players I even freed my memory.
//
// Revision 1.18  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.17  1999/05/04 18:03:09  dce
// Offer fixed
//
// Revision 1.16  1999/05/04 17:19:33  dce
// Name accept system...version one...original code by Fingh, fixed up to work
// by Zantir. 
//
// Revision 1.15  1999/05/01 03:15:33  dce
// Set can now toggle anonymous flag
//
// Revision 1.14  1999/04/20 22:40:38  jimmy
// Fixed a silly overflow in do_players.  Once the length of all the 
// player's names exceeded the bufffer length boom!  Now you must type a 
// letter and only player's names beginning with that letter are displayed.
// --Gurlaek
//
// Revision 1.13  1999/03/13 19:42:28  jimmy
// fixed silly crashbug in show error
// fingon
//
// Revision 1.12  1999/02/26 22:30:30  dce
// Fixes file command to work in show command
//
// Revision 1.11  1999/02/23 16:48:06  dce
// Creates a new command called file. Allows us to view files
// through the mud.
//
// Revision 1.10  1999/02/19 01:58:44  dce
// Changes wiztitle to max text length of 10
//
// Revision 1.9  1999/02/12 16:25:09  jimmy
// Fixed poofs to show a default poof if none is set.
// 
// Revision 1.8  1999/02/10 22:21:42  jimmy
// Added do_wiztitle that allows gods to edit their
// godly title ie Overlord.  Also added this title
// to the playerfile
// fingon
//
// Revision 1.7  1999/02/06 17:49:29  jimmy
// Gods can now type goto home to get to
// their homerooms.
//
// Revision 1.6  1999/02/06 00:40:36  jimmy
// Major change to incorporate aliases into the pfile
// moved alias structure from interpreter.h to structs.h
// heavily modified alias code in interpreter.c
// Jimmy Kincaid AKA fingon
//
// Revision 1.5  1999/02/05 07:47:42  jimmy
// Added Poofs to the playerfile as well as 4 extra strings for
// future use.  fingon
//
// Revision 1.4  1999/02/02 02:41:42  mud
// dos2unix
// Replaced Occurences of Hubis with Fiery
//
// Revision 1.3  1999/02/01 08:12:46  jimmy
// Fixed show god --Fingon
//
// Revision 1.2  1999/01/31 19:26:45  jimmy
// Fixed "show death" --fingon
//
// Revision 1.1
// Initial Revision
//
@


1.94
log
@Colorized Mushroom (YAY!)
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.93 2002/06/21 04:32:15 rls Exp $
d1360 18
a1377 18
 		"           ** ****** ****\r\n"
                "         ** ***     *****  **\r\n"
                "       ** **      *     ***  *\r\n"
                "       *    ** **   *   *  * **\r\n"
                "      *  ** * *          *     *\r\n"
                "      *  *    **            * * *\r\n"
                "     * * ** *     *   ******  *\r\n"
                "      *   * * **  ***     *  * *\r\n"
                "        *  *  * **********  *** *\r\n"
                "         *****   *     *   * * *\r\n"
                "                *   * *\r\n"
                "               *  * *  *\r\n"
                "              *  *  **  *\r\n"
                "              * **   * *\r\n"
                "                * * *\r\n"
                "                * *  **\r\n"
                "               **     ****\r\n"
                "              ***  * *    ****\r\n");
d5066 3
@


1.93
log
@Adjusted rrestore to not take away excess hit, mana or move
gained from such spells as energy drain, etc.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.92 2002/06/07 01:14:26 rls Exp $
d1336 18
a1353 18
 		"           ** ****** ****\r\n"
                "         ** ***     *****  **\r\n"
                "       ** **      *     ***  *\r\n"
                "       *    ** **   *   *  * **\r\n"
                "      *  ** * *          *     *\r\n"
                "      *  *    **            * * *\r\n"
                "     * * ** *     *   ******  *\r\n"
                "      *   * * **  ***     *  * *\r\n"
                "        *  *  * **********  *** *\r\n"
                "         *****   *     *   * * *\r\n"
                "                *   * *\r\n"
                "               *  * *  *\r\n"
                "              *  *  **  *\r\n"
                "              * **   * *\r\n"
                "                * * *\r\n"
                "                * *  **\r\n"
                "               **     ****\r\n"
                "              ***  * *    ****\r\n");
d5066 4
@


1.92
log
@Commented out the emote case for Zzur
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.91 2002/05/23 00:19:41 rls Exp $
d4077 13
a4089 7
  for (i = character_list; i; i = i->next){
  if ((i != ch)&&(!IS_NPC(i))){
    GET_HIT(i) = GET_MAX_HIT(i);
    GET_MANA(i) = GET_MAX_MANA(i);
    GET_MOVE(i) = GET_MAX_MOVE(i);
    act("&0&b&4$n &0&b&9spreads $s &0&b&8energy&0&b&9 across the realms &0&6restoring&0&b&9 all in its path!&0", TRUE, ch, 0, i, TO_VICT);
  update_pos(i);
d4091 1
a4091 2
  }
   send_to_char(OK, ch);
d5066 3
@


1.91
log
@Added set size functionality and fixed set charisma for 100pts
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.90 2002/03/30 19:20:14 dce Exp $
d2205 2
a2206 2
  case '*':
    emote = TRUE;
d5061 3
@


1.90
log
@Added damage amounts as a toggable item.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.89 2002/03/15 02:45:14 dce Exp $
d3080 2
a3081 1
   { "chant",		LVL_HEAD_C,     PC,     NUMBER },
d3436 1
a3436 1
      RANGE(3, 25);
d3517 3
d5061 3
@


1.89
log
@Increased wiztitle from 11 to 12.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.88 2002/02/25 09:48:42 rls Exp $
d75 1
d3718 5
d5057 3
@


1.88
log
@Updated wiztitle function per request to format for 11 characters
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.87 2001/10/22 01:35:58 dce Exp $
d2573 3
a2575 3
    /* changed size below to 11 to fit all of new god positions - rls:022502 */
  } else if (noansi  > 11) {
    sprintf(buf, "Sorry, text portion of godly titles can't be longer than 10 characters.\r\n");
d2579 1
a2579 1
    while (noansi < 11 && noansi > 0) {
d5051 3
@


1.87
log
@Changedset passwd to a level 104 command.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.86 2001/04/08 17:23:46 dce Exp $
d2573 2
a2574 1
  } else if (noansi  > 10) {
d2579 1
a2579 1
    while (noansi < 10 && noansi > 0) {
d5051 3
@


1.86
log
@Show file was overwritting the buffer, so I increased
the size by using a new buffer.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.85 2001/04/07 17:02:30 dce Exp $
d3055 1
a3055 1
   { "passwd",		LVL_IMPL, 	PC, 	MISC   }, /*45*/
d5050 4
@


1.85
log
@Added the vitem command.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.84 2001/04/02 03:18:41 dce Exp $
d4494 2
d4554 1
a4554 1
  get_line(req_file,buf);
d4558 1
a4558 1
     get_line(req_file,buf);
d4575 1
a4575 1
  buf2[0] = '\0';
d4577 1
a4577 1
  get_line(req_file,buf);
d4583 1
a4583 1
        sprintf(buf2,"%s%s\r\n",buf2, buf);
d4585 1
a4585 1
     get_line(req_file,buf);
d4587 1
a4587 1
   page_string(ch->desc, buf2, 1);
d5050 3
@


1.84
log
@Added the command vwear.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.83 2001/03/31 22:17:56 dce Exp $
d4907 140
d5048 3
@


1.83
log
@Tried to increase zonebuf larger than MAX_STIRNG_LENGTH
I am curious if this will crash the mud. (show zones).
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.82 2001/03/28 02:08:26 dce Exp $
d112 3
d4774 133
d4908 4
@


1.82
log
@Show file works as advertised.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.81 2001/03/26 02:17:18 dce Exp $
d2751 1
a2751 1
  char zonebuf[MAX_STRING_LENGTH], value2[MAX_INPUT_LENGTH], value3[MAX_INPUT_LENGTH];
d4772 3
@


1.81
log
@Show file now goes beyond one page.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.80 2001/03/24 19:42:27 dce Exp $
d119 1
a119 1
void do_file(struct char_data *ch, char *argument);
d2751 1
a2751 1
  char zonebuf[MAX_STRING_LENGTH];
d2790 2
a2791 1
  strcpy(arg, two_arguments(argument, field, value));
d2961 1
a2961 1
    do_file(ch, value);
d4482 1
a4482 1
void do_file(struct char_data *ch, char *argument)
d4491 1
a4491 2
  char field[MAX_INPUT_LENGTH],
       value[MAX_INPUT_LENGTH];
d4521 1
a4521 1
  strcpy(arg, two_arguments(argument, field, value));
d4537 1
a4537 1
     req_lines = 80; /* default is the last 15 lines */
d4560 1
a4560 1
  if(req_lines > 80) req_lines = 80;
d4576 1
a4576 1
     if(cur_line < req_lines)
d4772 3
@


1.80
log
@Stating an object will show the level.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.79 2001/03/10 18:45:33 dce Exp $
d4537 1
a4537 1
     req_lines = 15; /* default is the last 15 lines */
a4556 1
  
d4576 1
a4576 1
     if(cur_line > (num_lines - req_lines))
d4772 3
@


1.79
log
@Changed do_return function to pass a subcommand of 1.
This way I can make it so players can't use the return command.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.78 2001/03/07 03:08:09 dce Exp $
d707 1
a707 1
  sprintf(buf, "Name: '%s%s%s', Aliases: %s\r\n", CCYEL(ch, C_NRM),
d709 1
a709 1
	  CCNRM(ch, C_NRM), j->name);
d4773 4
@


1.78
log
@Fixed the output.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.77 2001/03/04 14:27:39 dce Exp $
d1548 1
a1548 1
    if (GET_LEVEL(ch->desc->original) < 101) {
d1552 2
a1553 1
    if (ch->desc->original->player_specials->saved.chant < 0) {
d4773 3
@


1.77
log
@Added the page function to show zones.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.76 2001/03/03 18:07:10 dce Exp $
d2828 1
a2828 1
      page_string(ch->desc, zonebuf, 0);
d4772 3
@


1.76
log
@Gods should not be able to use return from a shapechange.
Also mortals can no longer use return.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.75 2001/01/29 05:05:30 rsd Exp $
d2750 1
d2775 2
d2822 7
a2828 4
	print_zone_to_buf(buf, i); /* put single zone referenced in this pass of the for loop */
	send_to_char(buf, ch);     /* into buf, then send the line to the player, then clear */
	buf[0] = '\0';             /* out buf so it's empty for the next pass of the loop    */
      }
d4772 4
@


1.75
log
@Ok, aded a couple of include to call mkdir so Jimmy and
I could redo pfile maint to clean up bogus files that
weren't being accounted for in the way pfilemaint was
being done.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.74 2000/11/28 00:46:32 mtp Exp $
d1548 9
d3067 1
d3500 3
d4766 6
@


1.74
log
@remove mobprog stuff
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.73 2000/11/25 08:12:06 rsd Exp mtp $
a15 1

d19 2
d36 1
d4582 1
d4621 10
a4681 6
      /* remove the pfile */
      sprintf(buf, "rm %s", fn);
      system(buf);
      /* remove the objfile */
      sprintf(buf, "rm %s.objs", fn);
      system(buf);
d4687 8
d4704 27
d4742 1
a4742 1

d4746 1
a4746 1

d4753 3
@


1.73
log
@Altered some of do_show() to comment why the case:zones
can't be put through the paging function.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.72 2000/11/20 05:02:57 rsd Exp $
a166 1
	  MOBTrigger = FALSE;
a172 1
      MOBTrigger = FALSE;
a176 1
      MOBTrigger = FALSE;
d4711 4
@


1.72
log
@added back rlog messages from before the addition of the
$log$ string.
grumble
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.71 2000/11/16 02:43:00 rsd Exp $
d2809 1
a2809 1
    } else
d2811 3
a2813 3
	print_zone_to_buf(buf, i);
	send_to_char(buf, ch);
	buf[0] = '\0';
d2815 1
d4714 5
@


1.71
log
@added a check in do_name() nlist so if players names have
been declined they won't show up in nlist among the players
who are awaiting approval.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.70 2000/11/11 00:04:36 mtp Exp $
a4711 13













d4713 5
d4826 221
@


1.70
log
@continue processing quest list even if a bad one was found
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.69 2000/11/03 17:28:33 jimmy Exp mtp $
d2460 1
a2460 1
	     (PLR_FLAGGED(d->character, PLR_NAPPROVE))) &&
d4726 3
@


1.69
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.68 2000/11/03 05:37:17 jimmy Exp $
d1203 16
a1218 14
	  	while (qst && (real_quest(qst->quest_id) >=0))
	  	{
			qid_num = real_quest(qst->quest_id);
		  	sprintf(buf,"Quest %s: ",all_quests[qid_num ].quest_name);
		  	if (qst->stage == QUEST_SUCCESS)
			  	strcat(buf,"Completed\r\n");
		  	else if (qst->stage == QUEST_FAILURE)
			  	strcat(buf,"Failed\r\n");
		  	else
		  	{
			  	sprintf(buf2,"Stage %d\r\n",qst->stage);
			  	strcat(buf,buf2);
		  	}
		  	send_to_char(buf,ch);
d4726 5
@


1.68
log
@Removed the quest.h file from structs.h arg!! and placed it
only in the appropriate files
Updated the dependancies in the Makefile and created
make supahclean.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.67 2000/11/02 23:41:19 mtp Exp $
d402 4
a405 1
    location = real_room(GET_LOADROOM(ch));
d3842 4
a3845 4

/* Only works if you have Oasis OLC */
extern void olc_add_to_save_list(int zone, byte type);

d3850 1
a3850 1

d3853 8
a3860 8

	CREATE (room, struct room_data, 1);	

	iroom = atoi(buf2);
	rroom = real_room(atoi(buf2));
	*room = world[rroom];

 if (!*buf2) {
d3863 7
a3869 7
 if (rroom <= 0) {
	sprintf(buf, "There is no room with the number %d.\r\n", iroom);
	send_to_char(buf, ch);
	return; }

/* Main stuff */

d3872 2
a3873 2

/* Only works if you have Oasis OLC */
d3875 4
a3878 4

 sprintf(buf, "You copy the description to room %d.\r\n", iroom);
 send_to_char(buf, ch); }
	else
d3884 1
a3884 1
/* Only works if you have Oasis OLC */
d4724 6
@


1.67
log
@added qid_num for debugging purposes
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.66 2000/11/02 23:38:09 mtp Exp mtp $
d33 1
d4721 3
@


1.66
log
@real_quest() for non existant virtual quest returns -1!
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.65 2000/11/01 00:44:35 mtp Exp mtp $
d895 1
a895 1
  int a;
d1201 2
a1202 1
		  	sprintf(buf,"Quest %s: ",all_quests[real_quest(qst->quest_id) ].quest_name);
d4720 3
@


1.65
log
@added extra check to avoid crashing mud...dunno why quests is not being nulled though
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.64 2000/10/27 00:34:45 mtp Exp mtp $
d1199 1
a1199 1
	  	while (qst)
d4719 3
@


1.64
log
@modeified do_stat to show quest info
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.63 2000/10/13 04:27:23 cmc Exp mtp $
d1193 4
a1196 2
	  qst=k->quests;
	  while (qst)
d1198 21
a1218 12
		  sprintf(buf,"Quest %s: ",all_quests[real_quest(qst->quest_id) ].quest_name);
		  if (qst->stage == QUEST_SUCCESS)
			  strcat(buf,"Completed\r\n");
		  else if (qst->stage == QUEST_FAILURE)
			  strcat(buf,"Failed\r\n");
		  else
		  {
			  sprintf(buf2,"Stage %d\r\n",qst->stage);
			  strcat(buf,buf2);
		  }
		  send_to_char(buf,ch);
		  qst = qst->next;
d4719 3
@


1.63
log
@added "level gain" toggle
typo correction duties
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.62 2000/09/14 00:54:08 rsd Exp cmc $
d901 1
d903 1
d1190 20
d4708 4
@


1.62
log
@Fixed purge again, put proper logic not to return out
of the function in it.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.61 2000/09/13 22:20:43 rsd Exp $
d71 1
d3613 2
a3614 2
      "[&2&bSYS: %s allows players to cast sleep on eachother&0]\r\n",
      "[&1&bSYS: %s disallows players from casting sleep on eachother&0]\r\n",
d3623 2
a3624 2
      "[&2&bSYS: %s allows players to cast charm on eachother&0]\r\n",
      "[&1&bSYS: %s disallows players from casting charm on eachother&0]\r\n",
d3647 5
d4686 4
@


1.61
log
@altered the level at which set sub commands are avail
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.60 2000/09/13 21:06:28 rsd Exp $
d1728 1
a1728 1
      if(GET_OBJ_WEAR(obj) == 0) { /* This prevents items w/o take flags from getting purged
a1729 2
	return;
      } else {
d4680 3
@


1.60
log
@Fixed it so object without any wear flags, notably TAKE
, are not purged unless it's an argument.  So boards and
fountains etc won't be purged on a room purge.
Like the old Fiery.  Also
In do_players added the players level in (parens) so it's
easier to tell if anyone has advanced and needs name approval
just some admin stuffs.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.59 2000/08/31 17:45:35 rsd Exp $
d2945 5
a2949 5
  struct set_struct {
    char *cmd;
    char level;
    char pcnpc;
    char type;
d2951 1
a2951 1
   { "brief",		LVL_GOD, 	PC, 	BINARY }, /* 0*/
d2953 1
a2953 1
   { "title",		LVL_GOD, 	PC, 	MISC   },
d2955 15
a2969 15
   { "maxhit",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "maxmana", 	LVL_GRGOD, 	BOTH, 	NUMBER }, /* 5*/
   { "maxmove", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hit", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "mana",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "move",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "align",		LVL_GOD, 	BOTH, 	NUMBER }, /*10*/
   { "str",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "stradd",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "int", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "wis", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "dex", 		LVL_GRGOD, 	BOTH, 	NUMBER }, /*15*/
   { "con", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC   },
   { "ac", 		LVL_GRGOD, 	BOTH, 	NUMBER },
d2971 4
a2974 4
   { "home",	        LVL_GOD,	PC,	NUMBER },
   { "exp", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hitroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "damroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
d2976 1
a2976 1
   { "nohassle", 	LVL_GRGOD, 	PC, 	BINARY }, /*25*/
d2978 3
a2980 3
   { "practices", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "lessons", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC   },
d2983 3
a2985 3
   { "killer",		LVL_GOD, 	PC, 	BINARY },
   { "thief",		LVL_GOD, 	PC, 	BINARY },
   { "level",		LVL_HEAD_B, 	BOTH, 	NUMBER },
d2987 1
a2987 1
   { "roomflag", 	LVL_GRGOD, 	PC, 	BINARY },
d2990 1
a2990 1
   { "class",		LVL_GRGOD, 	BOTH, 	MISC   },
d2993 1
a2993 1
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC   },
d2995 2
a2996 2
   { "idnum",		LVL_HEAD_B, 	PC, 	NUMBER },
   { "passwd",		LVL_HEAD_C, 	PC, 	MISC   }, /*45*/
d2998 2
a2999 2
   { "cha",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "race",            LVL_GRGOD,      PC,     MISC   },
d3004 16
a3019 16
   { "plat",		LVL_GOD, 	BOTH, 	NUMBER },
   { "gold",		LVL_GOD, 	BOTH, 	NUMBER },   
   { "silver",		LVL_GOD, 	BOTH, 	NUMBER }, /*55*/
   { "copper",		LVL_GOD, 	BOTH, 	NUMBER },
   { "pbank",		LVL_GOD, 	PC, 	NUMBER },
   { "gbank",		LVL_GOD, 	PC, 	NUMBER },
   { "sbank",		LVL_GOD, 	PC, 	NUMBER },  
   { "cbank",		LVL_GOD, 	PC, 	NUMBER }, /*60*/
   { "diety",           LVL_GOD,        PC,     NUMBER },
   { "frag",            LVL_HEAD_B,     PC,     NUMBER },
   { "anon",   		LVL_HEAD_B,	PC,	BINARY },
   { "rename",	        LVL_HEAD_B,	PC,	BINARY },
   { "napprove",        LVL_HEAD_B,	PC,	BINARY }, /*65*/
   { "holylight",       LVL_HEAD_B,     PC,     BINARY },
   { "wiztitle",        LVL_HEAD_B,     PC,     MISC   },
   { "\n",              0,		BOTH, 	MISC }
d4682 9
@


1.59
log
@Ok, more passwd changes
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.58 2000/04/26 23:33:56 rsd Exp $
d1649 3
a1651 2
	  if(IS_SET(bitfield, PLR_FROZEN)){ 	  
	    sprintf(playbuf, "%s  &6&b%-20.20s&0", playbuf, (player_table + i)->name);
d1654 2
a1655 1
	    sprintf(playbuf, "%s  &1&b%-20.20s&0", playbuf, (player_table + i)->name);
d1658 2
a1659 1
	    sprintf(playbuf, "%s  &3&b%-20.20s&0", playbuf, (player_table + i)->name);
d1662 2
a1663 1
	    sprintf(playbuf, "%s  &2&b%-20.20s&0", playbuf, (player_table + i)->name);
a1699 1
      
d1715 1
a1715 2
    }
    
a1720 1
    
d1725 1
a1725 2
    }
    
d1728 6
a1733 1
      extract_obj(obj);
d4682 3
@


1.58
log
@made name declination a little more obvious to the players
Also took some lame text out of the terminate command
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.57 2000/04/22 22:31:41 rsd Exp $
d3351 1
a3351 1
   /* if (GET_IDNUM(ch) >= 2) {
d3354 2
a3355 2
    } */
    if (GET_LEVEL(vict) >= LVL_GRGOD) {
d4677 4
@


1.57
log
@fixed spelling of deity in player output.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.56 2000/04/14 19:09:35 rsd Exp $
d2390 1
a2390 1
	   SEND_TO_Q("You will be prompted for a new name on your next login.\r\n", d);
d4325 1
a4325 1
  send_to_char("&1&bThis command is disabbled read board Banyal&0\r\n",
d4343 1
a4343 1
        send_to_char("&1You dare NOT do that!&0 Go kill a wuss like Darr", ch);
d4677 3
@


1.56
log
@passwd changes
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.55 2000/04/14 18:56:15 rsd Exp $
d3421 1
a3421 1
       send_to_char("That's not a valid diety.\r\n", ch);
d4677 3
@


1.55
log
@OK I can definately use it now
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.54 2000/04/14 18:52:26 rsd Exp rsd $
d2991 1
a2991 1
   { "passwd",		LVL_OVERLORD, 	PC, 	MISC   }, /*45*/
d4677 3
@


1.54
log
@I moved passwd to my level I swear
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.53 2000/04/14 18:48:34 rsd Exp rsd $
d3351 1
a3351 1
    if (GET_IDNUM(ch) >= 2) {
d3354 1
a3354 1
    }
d4677 3
@


1.53
log
@made passwd my level
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.52 2000/02/25 02:42:00 rsd Exp $
d3351 1
a3351 1
    if (GET_IDNUM(ch) > 2) {
d4677 3
@


1.52
log
@added room and zone info to do_world, I even made a
variable for it woo.
/s
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.51 2000/02/24 01:04:18 dce Exp $
d3 1
a3 1
 *   File: act.wizard.c                                  Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d2991 1
a2991 1
   { "passwd",		LVL_HEAD_C, 	PC, 	MISC   }, /*45*/
d3351 1
a3351 1
    if (GET_IDNUM(ch) > 1) {
d4677 5
@


1.51
log
@Changed wiztitle from a command to a set.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.50 2000/02/16 07:58:39 mtp Exp $
d3533 1
a3533 1

d3562 4
d3568 1
d4675 3
@


1.50
log
@added listrace...it just prints the choice menu that people have when they start
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.49 2000/02/16 07:16:12 rsd Exp mtp $
d114 1
d2485 1
a2485 6

/* Based on do_title.  This allows gods to change their default */
/* title ie "Overlord" to whatever they wish                    */
/* --Fingon 2/10/1999                                           */

ACMD(do_wiztitle)
d2490 2
a2491 2
  skip_spaces(&argument);
  delete_doubledollar(argument);
d2494 1
a2494 1
  noansi = strlen(argument);
d2496 3
a2498 3
    for (i = 0; i < strlen(argument)-1; i++) {
      if (argument[i] == '&' && argument[i+1] != '&') {
	noansi -= 2;
d2500 4
a2503 2
    }    
  }    
d2505 7
a2511 5
  if (IS_NPC(ch))
    send_to_char("Your title is fine... go away.\r\n", ch);
  else if (strstr(argument, "[") || strstr(argument, "]"))
    send_to_char("Godly Titles can't contain the [ or ] characters.\r\n", ch);
  else if (strlen(argument) > MAX_WIZTITLE_LENGTH - 1) {
d2513 2
a2514 2
	    MAX_WIZTITLE_LENGTH - 1);
    send_to_char(buf, ch);
d2517 1
a2517 1
    send_to_char(buf, ch);
d2522 2
a2523 2
        strcat(argument, " ");
	back=0;
d2525 4
a2528 4
	strcpy(centerbuf, " ");
	strcat(centerbuf, argument);
        strcpy(argument, centerbuf);
	back=1;
d2533 3
a2535 3
      strncpy(GET_WIZTITLE(ch), argument, MAX_WIZTITLE_LENGTH);
      sprintf(buf, "Okay, you're godly title is now [%s]\r\n", GET_WIZTITLE(ch));
      send_to_char(buf, ch);
d2537 3
a2539 2
      strcpy(GET_WIZTITLE(ch), "\0");
      send_to_char("Godly title reset to default\r\n", ch);
d2541 1
d2543 1
d2546 3
a2548 1

d3011 2
a3012 1
   { "\n",              0,              BOTH,   MISC   }
d3441 3
d4670 3
@


1.49
log
@Aredryk fixed show zones (all) to fix overflow so the
list wouldn't truncate and stomp memory
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.48 2000/01/31 03:58:41 cso Exp $
d432 10
d4661 4
@


1.48
log
@modified do_game to allow different game toggles to have different
min levels. it also looked ugly and kludgy, so i recoded it from scratch
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.47 2000/01/30 23:11:18 rsd Exp $
d2733 4
a2736 1
    if (self)
d2738 2
a2739 1
    else if (*value && is_number(value)) {
d2741 1
a2741 1
      if (i <= top_of_zone_table)
d2743 2
a2744 1
      else {
d2749 1
a2749 1
      for (i = 0; i <= top_of_zone_table; i++)
d2751 3
a2753 1
    send_to_char(buf, ch);
d4651 4
@


1.47
log
@added parts to allow a good races toggle in
addition to the existing complete race login toggle.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.46 1999/11/28 22:49:49 cso Exp $
d3542 72
a3613 5
 ACMD(do_game)
{
  char field[MAX_INPUT_LENGTH];
   
  half_chop(argument, field, buf);
d3615 20
a3634 12
  if (strcmp(field, "races") == 0) { 
    if (races_allowed == 1) {
	  races_allowed = 0;
	  good_races_allowed = 0;
	  sprintf(buf, "[&2&bSYS: %s disallows race logins&0]\r\n", GET_NAME(ch));
	  send_to_imms(buf);
    } else {
      races_allowed = 1;
      good_races_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s allows race logins&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
d3636 13
a3648 126
  if (strcmp(field, "good_races") == 0) { 
    if (good_races_allowed == 1) {
	  good_races_allowed = 0;
	  races_allowed = 0;
	  sprintf(buf, "[&2&bSYS: %s disallows good race logins&0]\r\n", GET_NAME(ch));
	  send_to_imms(buf);
    } else {
      good_races_allowed = 1;
      races_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s allows good race logins&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  }
  if (strcmp(field, "pk") == 0) { 
    if (pk_allowed == 1) {
      pk_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s disallows PKilling&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      pk_allowed = 1;
      sprintf(buf, "[&2&bSYS: %s allows PKilling&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "sleep") == 0) {
    if (sleep_allowed == 1) {
      sleep_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s disallows players from casting sleep on each other&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      sleep_allowed = 1;
      sprintf(buf, "[&2&bSYS: %s allows players to cast sleep on each other&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "summon") == 0) {
    if (summon_allowed == 1) {
      summon_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s disallows players from summoning one another&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      summon_allowed = 1;
      sprintf(buf, "[&2&bSYS: %s allows players to summon one another&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "charm") == 0) {
    if (charm_allowed == 1) {
      charm_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s disallows players from charming one another&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      charm_allowed = 1;
      sprintf(buf, "[&2&bSYS: %s allows players to charm one another&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "roomaffect") == 0) {
    if (roomaffect_allowed == 1) {
      roomaffect_allowed = 0;
      sprintf(buf, "[&2&bSYS: %s disallows room affect spells from hurting other players&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      roomaffect_allowed = 1;
      sprintf(buf, "[&2&bSYS: %s allows room affect spells to hurt other players&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "names") == 0) {
    if (approve_names == 1) {
      approve_names = 0;
      sprintf(buf, "[&2&bSYS: %s turned off name approval&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      approve_names = 1;
      sprintf(buf, "[&2&bSYS: %s turned on name approval&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    }
  } else if (strcmp(field, "ooc") == 0) {
    if (gossip_channel_active == 1) {
      gossip_channel_active = 0;
      sprintf(buf, "[&2&bSYS: %s disables OOC! GAWD SAVE THE QUEEN!&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      gossip_channel_active  = 1;
      sprintf(buf, "[&2&bSYS: %s enables OOC! ANARCHY!&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);	  
    }
  } else if (strcmp(field, "slowns") == 0) {
    if (nameserver_is_slow == 1) {
      nameserver_is_slow = 0;
      sprintf(buf, "[&2&bSYS: %s turns on hostname lookup.&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);
    } else {
      nameserver_is_slow = 1;
      sprintf(buf, "[&2&bSYS: %s turns off hostname lookup.&0]\r\n", GET_NAME(ch));
      send_to_imms(buf);	  
    }
  } else {
    send_to_char("\r\n"
		 "[Current game status:]\r\n"
		 "\r\n", ch);
    if (races_allowed == 1) send_to_char("[&2&bRACES&0]      Race login allowed\r\n", ch);
    if (races_allowed == 0) send_to_char("[&1&bRACES&0]      Race login not allowed\r\n", ch);
    if (good_races_allowed == 1) send_to_char("[&2&bGOOD_RACES&0] Good Race login allowed\r\n", ch);
    if (good_races_allowed == 0) send_to_char("[&1&bGOOD_RACES&0] Good Race login not allowed\r\n", ch);
    if (pk_allowed == 1) send_to_char("[&2&bPK&0]         Pkilling allowed\r\n", ch);
    if (pk_allowed == 0) send_to_char("[&1&bPK&0]         Pkilling not allowed\r\n", ch);
    if (sleep_allowed == 1) send_to_char("[&2&bSLEEP&0]      Casting sleep on other players allowed\r\n", ch);
    if (sleep_allowed == 0) send_to_char("[&1&bSLEEP&0]      Casting sleep on other players not allowed\r\n", ch);
    if (summon_allowed == 1) send_to_char("[&2&bSUMMON&0]     Summoning other players allowed\r\n", ch);
    if (summon_allowed == 0) send_to_char("[&1&bSUMMON&0]     Summoning other players not allowed\r\n", ch);
    if (charm_allowed == 1) send_to_char("[&2&bCHARM&0]      Charming other players allowed\r\n", ch);
    if (charm_allowed == 0) send_to_char("[&1&bCHARM&0]      Charming other players not allowed\r\n", ch);
    if (roomaffect_allowed == 1) send_to_char("[&2&bROOMAFFECT&0] Room affect spells will hurt other players\r\n", ch);
    if (roomaffect_allowed == 0) send_to_char("[&1&bROOMAFFECT&0] Room affect spells will not hurt other players\r\n", ch);
    if (approve_names)
      send_to_char("[&2&bNAMES&0]      Name approval is required\r\n", ch);
    else
      send_to_char("[&1&bNAMES&0]      Name approval is NOT required\r\n", ch);
    if (gossip_channel_active)
      send_to_char("[&2&bOOC&0]        OOC is enabled\r\n", ch);
    else
      send_to_char("[&1&bOOC&0]        OOC is disabled\r\n", ch);
    if (nameserver_is_slow)
      send_to_char("[&2&bSLOWNS&0]     Nameserver lookup is disabled:slowns on\r\n", ch); 
    else
      send_to_char("[&1&bSLOWNS&0]     Nameserver lookup is enabled:slowns off\r\n", ch);
    
  }
  
d4644 4
@


1.46
log
@do_stat_object: made stat on corpse reflect whether raisable or not
do_wizutil: unaffecting animated mob kills it
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.45 1999/10/30 15:21:06 rsd Exp $
d60 1
d3551 1
d3556 1
d3561 13
d3660 2
d4682 4
@


1.45
log
@removed superflous void gain_exp(struct... definition
redundancy isn't needed.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.44 1999/10/04 21:39:18 rsd Exp $
d800 4
a803 3
      sprintf(buf, "Weight capacity: %d, Player Corpse: %s, Index: %d, Corpse: %s",
	      GET_OBJ_VAL(j,0), YESNO(GET_OBJ_VAL(j,1)), GET_OBJ_VAL(j,2),
	      YESNO(GET_OBJ_VAL(j,3)));
d2544 2
d2638 8
d4664 4
@


1.44
log
@Made holylight a set as well as a toggle, we have a mortal
who got it set on in a rez bug.
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.43 1999/09/16 01:15:11 dce Exp $
a1724 1
  void gain_exp(struct char_data * ch, long gain);
d4653 4
@


1.43
log
@Weight restrictions for monks...-hitroll, -damroll + ac
@
text
@d1 1
a1 1
// $Id: act.wizard.c,v 1.42 1999/09/05 07:00:39 jimmy Exp $
d2977 1
d3404 3
d4654 3
@


1.42
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d987 1
a987 1
	  GET_AC(k), k->points.hitroll, k->points.damroll, GET_SAVE(k, 0),
d4649 4
a4652 1
// $Log$
@


1.41
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d1 1
d4649 1
@


1.40
log
@fixed afk bug in ptell
@
text
@d36 1
a36 1
extern int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)];
@


1.39
log
@Added the build number and compiled date functionality
to the world command. Reformatted the game command to add
spanky colors with the keyword toggles in addition to the
lines that indicate what state each toggle is in.
@
text
@d247 1
a247 1
  else
d249 1
a249 2
    if (PRF_FLAGGED(vict,PRF_AFK))
    {
d253 1
@


1.38
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d14 3
a16 1

d3479 1
a3479 1
   * the all time great goat fucks to the code.   *
d3488 5
a3492 2
  
  
d3515 6
d3523 1
a3523 1
} 
d3525 2
a3526 6
/***********************************************************************
   This next set of code in comment is the date and uptime subcommands
   that have been carved up to form the new world command. 
   DO NOT uncomment this as all this code exists in the ACMD(do_date)
   already. If you don't want it here just delete it... 
   Punks.... RSD 7/9/99
d3528 3
d3532 119
a3650 9
  char *tmstr;
  time_t mytime;
  int d, h, m;
  extern time_t boot_time;
  
  
  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
d3652 1
a3652 1
    mytime = boot_time;
d3654 1
a3654 195
  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';
  
  if (subcmd == SCMD_DATE) 
    sprintf(buf, "Current machine time: %s\r\n", tmstr);
  else { 
    mytime = time(0) - boot_time;
    d = mytime / 86400;
    h = (mytime / 3600) % 24;
    m = (mytime / 60) % 60;
    
    sprintf(buf,"%s\r\n"
	    "Up since %s: %d day%s, %d:%02d\r\n",buf, tmstr, d,
            ((d == 1) ? "" : "s"), h, m);
  } 
  
  send_to_char(buf, ch);
  
} 
*****************************************************************/
 ACMD(do_game)

 {
   char field[MAX_INPUT_LENGTH];
 
   half_chop(argument, field, buf);
 
   if (strcmp(field, "races") == 0)
   { 
     if (races_allowed == 1)
     {
       races_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows race logins&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       races_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows race logins&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   if (strcmp(field, "pk") == 0)
   { 
     if (pk_allowed == 1)
     {
       pk_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows PKilling&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       pk_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows PKilling&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "sleep") == 0)
   {
     if (sleep_allowed == 1)
     {
       sleep_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows players from casting sleep on each other&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       sleep_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows players to cast sleep on each other&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "summon") == 0)
   {
     if (summon_allowed == 1)
     {
       summon_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows players from summoning one another&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       summon_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows players to summon one another&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "charm") == 0)
   {
     if (charm_allowed == 1)
     {
       charm_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows players from charming one another&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
     {
       charm_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows players to charm one another&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
   }
   else if (strcmp(field, "roomaffect") == 0)
   {
     if (roomaffect_allowed == 1)
     {
       roomaffect_allowed = 0;
       sprintf(buf, "[&2&bSYS: %s disallows room affect spells from hurting other players&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
     else
       {
	 roomaffect_allowed = 1;
	 sprintf(buf, "[&2&bSYS: %s allows room affect spells to hurt other players&0]\r\n", GET_NAME(ch));
	 send_to_imms(buf);
       }
   }
   else if (strcmp(field, "names") == 0)
     {
       if (approve_names == 1)
	 {
	   approve_names = 0;
	   sprintf(buf, "[&2&bSYS: %s turned off name approval&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);
	 }
       else
	 {
	   approve_names = 1;
	   sprintf(buf, "[&2&bSYS: %s turned off name approval&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);
	 }
     }
   else if (strcmp(field, "ooc") == 0)
     {
       if (gossip_channel_active == 1)
	 {
	   gossip_channel_active = 0;
	   sprintf(buf, "[&2&bSYS: %s disables OOC! GAWD SAVE THE QUEEN!&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);
	 }
       else
	 {
	   gossip_channel_active  = 1;
	   sprintf(buf, "[&2&bSYS: %s enables OOC! ANARCHY!&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);	  
	 }
     }
   else if (strcmp(field, "slowns") == 0)
     {
       if (nameserver_is_slow == 1)
	 {
	   nameserver_is_slow = 0;
	   sprintf(buf, "[&2&bSYS: %s turns on hostname lookup.&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);
	 }
       else
	 {
	   nameserver_is_slow = 1;
	   sprintf(buf, "[&2&bSYS: %s turns off hostname lookup.&0]\r\n", GET_NAME(ch));
	   send_to_imms(buf);	  
	 }
     }
   else
     {
       send_to_char("\r\n"
		    "[Current game status:]\r\n"
		    "\r\n", ch);
       if (races_allowed == 1) send_to_char("Race login allowed,\r\n", ch);
       if (races_allowed == 0) send_to_char("Race login not allowed,\r\n", ch);
       if (pk_allowed == 1) send_to_char("Pkilling allowed,\r\n", ch);
       if (pk_allowed == 0) send_to_char("Pkilling not allowed,\r\n", ch);
       if (sleep_allowed == 1) send_to_char("Casting sleep on other players allowed,\r\n", ch);
       if (sleep_allowed == 0) send_to_char("Casting sleep on other players not allowed,\r\n", ch);
       if (summon_allowed == 1) send_to_char("Summoning other players allowed,\r\n", ch);
       if (summon_allowed == 0) send_to_char("Summoning other players not allowed,\r\n", ch);
       if (charm_allowed == 1) send_to_char("Charming other players allowed,\r\n", ch);
       if (charm_allowed == 0) send_to_char("Charming other players not allowed,\r\n", ch);
       if (roomaffect_allowed == 1) send_to_char("Room affect spells will hurt other players.\r\n", ch);
       if (roomaffect_allowed == 0) send_to_char("Room affect spells will not hurt other players.\r\n", ch);
       if (approve_names)
	 send_to_char("Name approval is required.\r\n", ch);
       else
	 send_to_char("Name approval is NOT required.\r\n", ch);
       if (gossip_channel_active)
	 send_to_char("OOC is enabled.\r\n", ch);
       else
	 send_to_char("OOC is disabled.\r\n", ch);
       if (nameserver_is_slow)
	 send_to_char("Nameserver lookup is disabled:slowns on.\r\n", ch); 
       else
	 send_to_char("Nameserver lookup is enabled:slowns off.\r\n", ch);

    }
   
 }
@


1.37
log
@Added AFK message for ptell
@
text
@d1722 1
a1722 1
  void gain_exp(struct char_data * ch, int gain);
d3185 1
a3185 1
    vict->points.exp = RANGE(0, 50000000);
@


1.36
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d247 5
@


1.35
log
@Added an idle time deletion algorithm to pfilemaint.  Players will now
be autodeleted after 14+((level - 1) * 3) days of idle time.
--gurlaek
@
text
@d30 1
a30 1
extern FILE *player_fl;
d1421 2
a1422 2
  char tmp_name[MAX_INPUT_LENGTH], arg1[MAX_INPUT_LENGTH],
    arg2[MAX_INPUT_LENGTH];
d1425 3
d1437 1
d1462 6
d1730 1
a1730 1
  
d1735 1
d2895 1
d3299 1
a3299 1
    if (GET_IDNUM(ch) != 1 || !IS_NPC(vict))
d3416 1
a3416 2
    fseek(player_fl, (player_i) * sizeof(struct char_file_u), SEEK_SET);
    fwrite(&tmp_store, sizeof(struct char_file_u), 1, player_fl);
d4561 1
a4561 1
/* This function cleans bogus entries from the player file */
d4565 1
a4565 1
  FILE *pfile, *pfile_new;
d4573 2
a4593 11
  if (!(pfile = fopen(PLAYER_FILE, "r"))) {
    if (errno != ENOENT) {
      send_to_char("FAILED\r\n", ch);
      log("SYSERR:act.wizard.c:do_pfilemaint: Fatal error opening playerfile");
      return;
    } else {
      send_to_char("FAILED\r\n", ch);
      log("SYSERR:act.wizard.c:do_pfilemaint: Playerfile doesn't exist");
      return;
    }
  }
a4596 1
  pfile_new = fopen(PLAYER_FILE".new", "w");
d4599 29
a4627 1
  send_to_char("Creating new playerfile...\r\n", ch);
a4628 2
  /* loop through the player file */
  while (fread(player , sizeof(struct char_file_u), 1, pfile)) {
d4630 1
a4630 1
    allowed_time = 14 + ((player->level - 1) * 3);       /* 2 weeks base plus 3 days per level */
d4649 7
a4655 6
    if((reason) &&                             /* reason 0-6 above                   */
       (plrid) &&                              /* don't del player 0                 */
       (!IS_SET(bitfield, PLR_FROZEN)) &&      /* don't del frozen players           */
       (!IS_SET(bitfield, PLR_NEWNAME)) &&     /* don't del players pending new name */
       (strcmp(player->name, GET_NAME(ch))) && /* don't del yourself                 */
       (player->level < LVL_IMMORT)            /* don't del Immortals                */
d4663 6
d4671 2
a4672 4
      fwrite(player, sizeof(struct char_file_u), 1, pfile_new);
      if(!strcmp(player->name, GET_NAME(ch))) {
	GET_IDNUM(ch) = saved;
      }
d4675 1
d4678 1
a4678 2
  fclose(pfile);
  fclose(pfile_new);
d4680 1
a4680 4

  system("mv "PLAYER_FILE" "PLAYER_FILE".`date +%m%d.%H%M%S`"); /* backup the pfile and date/time stamp it */
  system("mv "PLAYER_FILE".new "PLAYER_FILE); /* replace pfile with the new one */

d4683 1
a4683 1

d4700 1
a4700 1
  send_to_char("Done!\r\n", ch);
a4702 1
 
@


1.34
log
@altered the priority of red and yellow color in do_players
so that players who are set newname on will take higher
precedence over those with napprove on.
@
text
@d4557 2
a4558 1
  int plrid = 0, saved = 0, axed = 0, reason = 0, i;
d4568 2
a4569 1
			  "Xname or MOB/OBJ name"};
d4602 2
d4619 9
a4627 6
    
    if((reason) &&                          /* reason 0-6 above                   */
       (plrid) &&                           /* don't del player 0                 */
       (!IS_SET(bitfield, PLR_FROZEN)) &&   /* don't del frozen players           */
       (!IS_SET(bitfield, PLR_NEWNAME)) &&  /* don't del players pending new name */
       (strcmp(player->name, GET_NAME(ch))) /* don't del yourself                 */
d4631 4
@


1.33
log
@Yet another fix to pfilemaint.  Pfilemaint now destroys the old
player_table and rebuilds it on the fly.  NO more wierdness.

--Gurlaek
@
text
@d1618 3
a1623 3
	    /* This sets the player name red if the name is rejected and needs to be renamed */	  
	  } else if(IS_SET(bitfield, PLR_NEWNAME)) {
	    sprintf(playbuf, "%s  &1&b%-20.20s&0", playbuf, (player_table + i)->name);
@


1.32
log
@Fixed pfilemaint to do more sanity checking before deletions.
Only deletions are now logged and each is logged with a reason.
removed the send_toxnames from do_set "rename".  This should ahve
been in the interpreter all along and that's where i moved it from
in the first place.
--gurlaek
@
text
@d4553 1
d4557 1
a4557 1
  int plrid = 0, saved = 0, axed = 0, reason = 0;
d4596 1
a4596 1
  send_to_char("Creating new playerfile...", ch);
d4643 18
a4660 2
  send_to_char(logbuf, ch);
  send_to_char("\r\nDone!\r\n", ch);
@


1.31
log
@Wrote a new command to do player file maintenace called pfilemaint.
This command will purge the player file using the same criteria
for creating new playes.  So, if it's in the xnames, it gets waxed
from the player file.  This will also take care of blank records
and reserved words.
--gurlaek
@
text
@a3378 1
    send_to_xnames(GET_NAME(vict));              /*  Added so set file denials get put in xnames */
d4550 1
d4555 3
a4557 1
  int plrid = 0, saved = 0, axed = 0;
a4558 1
  struct descriptor_data *d;
d4560 7
a4571 1
  
a4577 1
  
d4591 1
a4591 1
  
a4594 1
  
d4596 2
d4599 15
a4613 3
    if(!strcmp(player->name, GET_NAME(ch))) {
      GET_IDNUM(ch) = plrid;
    }
d4615 8
a4622 5
    if (((_parse_name(player->name, tmp_name)) || strlen(tmp_name) < 2 ||
	strlen(tmp_name) > MAX_NAME_LENGTH ||
	fill_word(strcpy(buf, tmp_name)) || reserved_word(buf) || 
	!Valid_Name(tmp_name)) && (plrid)) {
      sprintf(logbuf, "PFILEMAINT: %6d %s DISCARDED.", plrid, player->name);
d4626 3
a4628 1
      sprintf(logbuf, "PFILEMAINT: %6d %s Saved to new player file", plrid, player->name);
a4631 1
    log(logbuf);
d4637 2
a4638 2
  system("mv "PLAYER_FILE" "PLAYER_FILE".old");
  system("mv "PLAYER_FILE".new "PLAYER_FILE);
d4642 2
a4643 1
  send_to_char("Done!\r\n", ch);
@


1.30
log
@added SLOWNS to the game toggles.
@
text
@d4550 87
@


1.29
log
@made OOC a game sumcommand to prepare it to be removed
from the toggle subcommand list. And it works! wooo!
@
text
@d64 1
d3666 15
d3706 5
@


1.28
log
@Ok, I think I fixed the date command, I'm not very confident
that it works perfectly and someone should probably double
check my work.
@
text
@d63 1
d3629 5
a3633 5
     {
       roomaffect_allowed = 1;
       sprintf(buf, "[&2&bSYS: %s allows room affect spells to hurt other players&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
     }
a3635 2
   {
     if (approve_names == 1)
d3637 12
a3648 3
       approve_names = 0;
       sprintf(buf, "[&2&bSYS: %s turned off name approval&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
d3650 1
a3650 1
     else
d3652 12
a3663 3
       approve_names = 1;
       sprintf(buf, "[&2&bSYS: %s turned off name approval&0]\r\n", GET_NAME(ch));
       send_to_imms(buf);
a3664 1
   }
d3666 27
a3692 23
   {
     send_to_char("\r\n"
		  "[Current game status:]\r\n"
		  "\r\n", ch);
     if (races_allowed == 1) send_to_char("Race login allowed,\r\n", ch);
     if (races_allowed == 0) send_to_char("Race login not allowed,\r\n", ch);
     if (pk_allowed == 1) send_to_char("Pkilling allowed,\r\n", ch);
     if (pk_allowed == 0) send_to_char("Pkilling not allowed,\r\n", ch);
     if (sleep_allowed == 1) send_to_char("Casting sleep on other players allowed,\r\n", ch);
     if (sleep_allowed == 0) send_to_char("Casting sleep on other players not allowed,\r\n", ch);
     if (summon_allowed == 1) send_to_char("Summoning other players allowed,\r\n", ch);
     if (summon_allowed == 0) send_to_char("Summoning other players not allowed,\r\n", ch);
     if (charm_allowed == 1) send_to_char("Charming other players allowed,\r\n", ch);
     if (charm_allowed == 0) send_to_char("Charming other players not allowed,\r\n", ch);
     if (roomaffect_allowed == 1) send_to_char("Room affect spells will hurt other players.\r\n", ch);
     if (roomaffect_allowed == 0) send_to_char("Room affect spells will not hurt other players.\r\n", ch);
     if (approve_names)
       send_to_char("Name approval is required.\r\n", ch);
     else
       send_to_char("Name approval is NOT required.\r\n", ch);
   }
 
}
@


1.27
log
@added the guts of the new do_world command, basically
stole the date subcommands and took out the logic splitting
them into two commands.
@
text
@d3451 45
d3497 6
d3509 2
a3510 2

  /*
d3514 1
a3514 1
  */
d3516 1
a3516 1

d3519 2
a3520 2

  /* if (subcmd == SCMD_DATE) */
d3522 1
a3522 1
    /* else { */
d3527 1
a3527 1

d3529 1
a3529 1
                "Up since %s: %d day%s, %d:%02d\r\n",buf, tmstr, d,
d3531 2
a3532 2
 /* } */

d3534 1
a3534 1

d3536 1
a3536 1

@


1.26
log
@Changed the do_world command to do game and altered the format
and color.
@
text
@d3448 38
a3485 1
 
@


1.25
log
@This is a Mass check-in of the new skill/spell/language assignment system.
This New system combines the assignment of skill/spell/language for
both mobs and PCs.  LOts of code was touched and many errors were fixed.
MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
MObs now get random skill/spell/language levels baseed on their race/class/level
that exactly align with PC's.  PC's no longer have to rent to use skills gained
by leveling or when first creating a char.  Languages no longer reset to defaults
when a PC levels.  Discovered that languages have been defined right in the middle
of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
the mob files to compensate for the 13 to -1 class change.
--gurlaek 7/6/1999
@
text
@d3449 2
a3450 1
 ACMD(do_world)
d3461 1
a3461 1
       sprintf(buf, "[SYS: %s disallows race logins]\r\n", GET_NAME(ch));
d3467 1
a3467 1
       sprintf(buf, "[SYS: %s allows race logins]\r\n", GET_NAME(ch));
d3476 1
a3476 1
       sprintf(buf, "[SYS: %s disallows PKilling]\r\n", GET_NAME(ch));
d3482 1
a3482 1
       sprintf(buf, "[SYS: %s allows PKilling]\r\n", GET_NAME(ch));
d3491 1
a3491 1
       sprintf(buf, "[SYS: %s disallows players from casting sleep on each other]\r\n", GET_NAME(ch));
d3497 1
a3497 1
       sprintf(buf, "[SYS: %s allows players to cast sleep on each other]\r\n", GET_NAME(ch));
d3506 1
a3506 1
       sprintf(buf, "[SYS: %s disallows players from summoning one another]\r\n", GET_NAME(ch));
d3512 1
a3512 1
       sprintf(buf, "[SYS: %s allows players to summon one another]\r\n", GET_NAME(ch));
d3521 1
a3521 1
       sprintf(buf, "[SYS: %s disallows players from charming one another]\r\n", GET_NAME(ch));
d3527 1
a3527 1
       sprintf(buf, "[SYS: %s allows players to charm one another]\r\n", GET_NAME(ch));
d3536 1
a3536 1
       sprintf(buf, "[SYS: %s disallows room affect spells from hurting other players]\r\n", GET_NAME(ch));
d3542 1
a3542 1
       sprintf(buf, "[SYS: %s allows room affect spells to hurt other players]\r\n", GET_NAME(ch));
d3551 1
a3551 1
       sprintf(buf, "[SYS: %s turned off name approval]\r\n", GET_NAME(ch));
d3557 1
a3557 1
       sprintf(buf, "[SYS: %s turned off name approval]\r\n", GET_NAME(ch));
d3563 3
a3565 1
     send_to_char("[Current world status:]\r\n", ch);
d3585 1
@


1.24
log
@act.item.c         class.c       db.c         medit.c        utils.hact.offensive.c    config.c      handler.c    spells.cThis is a major conversion from the 18 point attribute system to the
100 point attribute system.  A few of the major changes are:
All attributes are now on a scale from 0-100
Everyone views attribs the same but, the attribs for one race
  may be differeent for that of another even if they are the
  same number.
Mobs attribs now get rolled and scaled using the same algorithim as PC's
Mobs now have individual random attributes based on race/class.
The STR_ADD attrib has been completely removed.
All bonus tables for attribs in constants.c have been replaced by
  algorithims that closely duplicate the tables except on a 100 scale.
Some minor changes:
Race selection at char creation can now be toggled by using
  <world races off>
Lots of cleanup done to affected areas of code.
Setting attributes for mobs in the .mob file no longer functions
  but is still in the code for later use.
We now have a spare attribut structure in the pfile because the new
  system only used three instead of four.
--gurlaek 6/30/1999
@
text
@d916 1
a916 1
    sprinttype(k->player.class, mclass_types, buf2);
d2880 2
d3252 1
a3252 1
	  if ((i = parse_class(vict, *val_arg)) == CLASS_UNDEFINED) {
d3256 1
a3256 4
    clear_skills(vict);
    GET_CLASS(vict) = i;
    set_skills(vict);
    check_regen_rates(vict);
d3316 6
a3321 9
	if ((i = parse_race(*val_arg)) == RACE_UNDEFINED) {
	    send_to_char("That is not a real race.\r\n", ch);
		return;
	}
	clear_skills(vict);
	GET_RACE(vict) = i;
        GET_RACE_ALIGN(vict) = set_race_align(vict);
	set_skills(vict);
	break;
d3323 2
a3324 2
	  GET_OLC2_ZONE(vict) = value;
	  break;
d3326 5
a3330 5
	   GET_OLC3_ZONE(vict) = value;
	  break;
case 51:
	  GET_OLC4_ZONE(vict) = value;
	  break;
d3332 2
a3333 2
	   GET_OLC5_ZONE(vict) = value;
	  break;
d4086 4
a4089 4

	strcpy(buf, "You know of the following languages:\r\n");
 strcpy(buf2, buf);

d4091 8
a4098 8
 {
   if (GET_SKILL(ch, i) > 0)
   {
    sprintf(buf, "%-20s %s\r\n", languages[(i - ofs)] , howgood(GET_SKILL(ch, i)));
    strcat(buf2, buf);
   }
 }
  page_string(ch->desc, buf2, 1); 
d4101 6
a4106 6
	if (is_abbrev(argument, "common")){
    if (GET_SKILL(ch, LANG_COMMON) > 0){
		SPEAKING(ch) = LANG_COMMON;
		send_to_char(OK, ch);
		return;
	}else{
d4110 7
a4116 7
	}
	}else if (is_abbrev(argument, "dwarven")){
		if(GET_SKILL(ch, LANG_DWARVEN) > 0){
			SPEAKING(ch) = LANG_DWARVEN;
			send_to_char(OK, ch);
			return;
	}else{
d4120 93
a4212 93
	}
	}else if (is_abbrev(argument, "elven")){
		if(GET_SKILL(ch, LANG_ELVEN) > 0){
         SPEAKING(ch) = LANG_ELVEN;
		 send_to_char(OK, ch);
		 return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
    }
	}else if (is_abbrev(argument, "halfling")){
		if(GET_SKILL(ch, LANG_HALFLING) > 0){
			SPEAKING(ch) = LANG_HALFLING;
			send_to_char(OK, ch);
			return;
	}else{
  sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
	}
	}else if (is_abbrev(argument, "gnomish")){
		if(GET_SKILL(ch, LANG_GNOMISH) > 0){
			SPEAKING(ch) = LANG_GNOMISH;
			send_to_char(OK, ch);
			return;
		}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
return;
		}
		}else if (is_abbrev(argument, "barbarian")){
			if(GET_SKILL(ch, LANG_BARBARIAN) > 0){
				SPEAKING(ch) = LANG_BARBARIAN;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
			}else if (is_abbrev(argument, "drow")){
		if(GET_SKILL(ch, LANG_DROW) > 0){
				SPEAKING(ch) = LANG_DROW;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "trollish")){
		if(GET_SKILL(ch, LANG_TROLLISH) > 0){
				SPEAKING(ch) = LANG_TROLLISH;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
 }else if (is_abbrev(argument, "duergar")){
		if(GET_SKILL(ch, LANG_DUERGAR) > 0){
				SPEAKING(ch) = LANG_DUERGAR;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "ogre")){
		if(GET_SKILL(ch, LANG_OGRE) > 0){
				SPEAKING(ch) = LANG_OGRE;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
  }else if (is_abbrev(argument, "orcish")){
		if(GET_SKILL(ch, LANG_ORCISH) > 0){
				SPEAKING(ch) = LANG_ORCISH;
				send_to_char(OK, ch);
				return;
			}else{
sprintf(buf, "&0You can not speak that language well enough.\r\n");
  send_to_char(buf, ch);
  return;
			}
			}else
		send_to_char("That is not a valid language.", ch);
d4214 3
a4216 3
  }
  
  
@


1.23
log
@Added more checks for d->character in ndecline and naccept to stop
crashes when people were at CON_QANSI etc etc and ndecline or naccept
were typed.
gurlaek
@
text
@d56 1
d952 11
a962 9
  }
  sprintf(buf, "Str:[%s%d(%d)/%d(%d)|%d(%d)/%d(%d)%s] Int:[%s%d/%d|%d/%d%s] \r\nWis:[%s%d/%d|%d/%d%s] "
	  "Dex:[%s%d/%d|%d/%d%s]\r\nCon:[%s%d/%d|%d/%d%s] Cha:[%s%d/%d|%d/%d%s]\r\n",
	  CCCYN(ch, C_NRM), GET_STR(k), GET_ADD(k), GET_RSTR(k), GET_RADD(k), GET_STR_VAFF(k), GET_ADD_VAFF(k), GET_STR_VIEW(k), GET_ADD_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_INT(k), GET_RINT(k), GET_INT_VAFF(k), GET_INT_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_WIS(k), GET_RWIS(k), GET_WIS_VAFF(k), GET_WIS_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_DEX(k), GET_RDEX(k), GET_DEX_VAFF(k), GET_DEX_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_CON(k), GET_RCON(k), GET_CON_VAFF(k), GET_CON_VIEW(k), CCNRM(ch, C_NRM),
	  CCCYN(ch, C_NRM), GET_CHA(k), GET_RCHA(k), GET_CHA_VAFF(k), GET_CHA_VIEW(k), CCNRM(ch, C_NRM));
d1797 3
a1799 2
      
      vict->aff_abils = vict->real_abils;
a2521 1
  void roll_real_abils(struct char_data *ch);
a2879 1
  void load_results(struct char_data * ch);
d2887 3
a2889 3
   { "brief",		LVL_GOD, 	PC, 	BINARY },  /* 0 */
   { "invstart", 	LVL_GOD, 	PC, 	BINARY },  /* 1 */
   { "title",		LVL_GOD, 	PC, 	MISC },
d2892 1
a2892 1
   { "maxmana", 	LVL_GRGOD, 	BOTH, 	NUMBER },  /* 5 */
d2897 1
a2897 1
   { "align",		LVL_GOD, 	BOTH, 	NUMBER },  /* 10 */
d2902 1
a2902 1
   { "dex", 		LVL_GRGOD, 	BOTH, 	NUMBER },  /* 15 */
d2904 1
a2904 1
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC },
d2906 2
a2907 2
   { "olc",     LVL_HEAD_B,   PC,     NUMBER},
   { "home",	LVL_GOD,	PC,		NUMBER},
d2912 1
a2912 1
   { "nohassle", 	LVL_GRGOD, 	PC, 	BINARY },  /* 25 */
d2916 3
a2918 3
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC },
   { "hunger",		LVL_GOD, 	BOTH, 	MISC },    /* 30 */
   { "thirst",		LVL_GOD, 	BOTH, 	MISC },
d2922 1
a2922 1
   { "room",		LVL_BUILDER, 	BOTH, 	NUMBER },  /* 35 */
d2926 2
a2927 2
   { "class",		LVL_GRGOD, 	BOTH, 	MISC },
   { "nowizlist", 	LVL_GOD, 	PC, 	BINARY },  /* 40 */
d2929 1
a2929 1
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC },
d2932 1
a2932 1
   { "passwd",		LVL_HEAD_C, 	PC, 	MISC },    /* 45 */
d2935 5
a2939 5
   { "race",    LVL_GRGOD,  PC,     MISC },
   { "olc2",     LVL_HEAD_B,   PC,     NUMBER},
   { "olc3",     LVL_HEAD_B,   PC,     NUMBER},/*50*/
   { "olc4",     LVL_HEAD_B,   PC,     NUMBER},
   { "olc5",     LVL_HEAD_B,   PC,     NUMBER},
d2942 1
a2942 1
   { "silver",		LVL_GOD, 	BOTH, 	NUMBER },	 /*55*/
d2947 3
a2949 3
   { "cbank",		LVL_GOD, 	PC, 	NUMBER },	 /*60*/
   { "diety",   LVL_GOD,        PC,      NUMBER },
   { "frag",   LVL_HEAD_B,        PC,      NUMBER },
d2951 3
a2953 3
   { "rename",	LVL_HEAD_B,	PC,	BINARY },
   { "napprove",LVL_HEAD_B,	PC,	BINARY },
   { "\n", 0, BOTH, MISC }
d3099 8
a3106 10
case 11:
		  RANGE(25, 100);
	  vict->view_abils.str = value;
	  if (value < 100)
		  vict->view_abils.str_add = 0;
	  load_results(vict);
	  affect_total(vict);
	  break;
 case 12:
	vict->view_abils.str_add = RANGE(0, 100);
d3108 1
a3108 1
	if (value > 0)
d3110 2
a3111 2
	load_results(vict);
	affect_total(vict);
d3113 1
a3113 1
/*Edited by Proky,  values for intel*/
d3115 5
a3119 6
  RANGE(25, 100);
  vict->view_abils.intel = value;
  load_results(vict);
  affect_total(vict);
  break;
	/*Edited by Proky values for Wis*/
d3122 3
a3124 4
	vict->view_abils.wis = value;
	load_results(vict);
	affect_total(vict);
	break;
d3127 4
a3130 5
	vict->view_abils.dex = value;
	load_results(vict);
	affect_total(vict);
	break;
	/*Edited by Proky, values for Wis*/
d3133 1
a3133 2
	vict->view_abils.con = value;
	load_results(vict);
d3136 1
a3136 1
	break;
d3312 2
a3313 2
      RANGE(3, 18);
    vict->real_abils.cha = value;
d3459 15
d3567 2
@


1.22
log
@Added code to make set file renames write to xnames file
so those players who are denied and aren't online will be
written to xnames
I'm the man
@
text
@d2257 4
d2328 3
@


1.21
log
@added check for d->character in the nlist (do_name) command.  This
fixed the problem of crashes when people where at CON_QANSI or
anywhere before their d->character's where created and someone typed
nlist.  --gurlaek.
@
text
@d3378 1
@


1.20
log
@tweaked do_players to better utilize memory. --gurlaek
@
text
@d2367 7
a2373 5
      if (((STATE(d) == CON_NAME_WAIT_APPROVAL) ||
           (PLR_FLAGGED(d->character, PLR_NAPPROVE))) &&
         (d != ch->desc)) 
      {
         sprintf(buffer, "%s%s\r\n", buffer, GET_NAME(d->character));
@


1.19
log
@Added color code to do_players I even freed my memory.
@
text
@d1578 1
a1578 3
  struct char_data *tch = NULL;

  CREATE(tch, struct char_data, 1);
d1591 2
a1592 2
	  tch->char_specials.saved.act = tmp_store.char_specials_saved.act;
	  
d1611 1
a1611 1
	  if(PLR_FLAGGED(tch, PLR_FROZEN)){ 	  
d1614 1
a1614 1
	  } else if(PLR_FLAGGED(tch, PLR_NAPPROVE)) {
d1617 1
a1617 1
	  } else if(PLR_FLAGGED(tch, PLR_NEWNAME)) {
a1632 2
    free(tch);
    tch = NULL;
a1637 2
    free(tch);
    tch = NULL; /* Look Ma no memory leak */
@


1.18
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1575 1
a1575 1
  int i, count = 0;
d1577 4
d1587 1
a1587 1

a1589 1

d1592 3
a1594 3
	
	/* check if there is enough room left in the buffer */
	if((strlen(playbuf) + strlen( (player_table + i)->name)) <= (MAX_STRING_LENGTH - 3)) {
d1596 2
d1599 7
a1605 4
	  sprintf(playbuf, "%s  %-20.20s", playbuf, (player_table + i)->name);
	  count++;
	  if (count == 3) {
	    count = 0;
d1607 17
d1626 1
a1626 6
	  
	  /* buffer too small for all names */
	  strcat(playbuf, "\r\n");
	  send_to_char("Too many names to show them all!", ch);
	  page_string(ch->desc, playbuf, 1);
	  return;
d1628 1
d1630 1
d1632 1
a1632 1

d1635 2
d1639 1
a1639 1

d1642 2
a1646 1

@


1.17
log
@Offer is fixed
@
text
@a1412 1
  extern int top_of_p_table;
d1419 1
a1419 1
  extern save_char_file_u(struct char_file_u st);
d2235 1
a2235 1

d2238 4
d2247 2
a2248 1
        if (GET_PFILEPOS(d->character) < 0)
d2250 7
a2256 2
        if (!PLR_FLAGGED(d->character, PLR_NEWNAME))
           init_char(d->character);
d2259 3
a2261 4
        SEND_TO_Q(motd, d);
	SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
        STATE(d) = CON_RMOTD;
        sprintf(buf, "%s has been accepted by %s.", GET_NAME(d->character), GET_NAME(ch));
d2263 2
a2264 4
        if (!PLR_FLAGGED(d->character, PLR_NEWNAME)) {
           sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
           mudlog(buf, NRM, LVL_IMMORT, TRUE);
        }
d2267 11
a2277 1
        sprintf(buf, "&2&b%s has been accepted.&0\r\n", GET_NAME(d->character));
d2279 1
d2302 1
a2302 1

d2310 1
a2310 1
         sprintf(buf, "%s has been declined by %s, reason %d.", GET_NAME(d->character), GET_NAME(ch), choice+1);
d2312 1
a2312 1
         sprintf(buf, "&2&b%s has been declined.&0\r\n", GET_NAME(d->character));
d2319 9
a2327 3
         SEND_TO_Q("Please try another name.\r\n", d);
         SEND_TO_Q("Name: ", d);
         STATE(d) = CON_NEW_NAME;
a4041 1
  extern char *spells[];
@


1.16
log
@Name accept system...version one...original code by Fingh, fixed up to work
by Zantir.
@
text
@d2183 1
@


1.15
log
@Set can now toggle anonymous flag
@
text
@d61 1
d104 1
a107 1

d2182 129
d2312 35
d2897 2
d3331 6
a3336 1

d3485 15
d3513 4
@


1.14
log
@Fixed a silly overflow in do_players.  Once the length of all the player's names exceeded the bufffer length boom!  Now you must type a letter and only
player's names beginning with that letter are displayed.
--Gurlaek
@
text
@d2731 1
d3161 3
a3163 1
  
@


1.13
log
@fixed silly crashbug in show error
fingon
@
text
@d1576 33
a1608 8
  *buf = 0;
  
  for (i = 0; i <= top_of_p_table; i++) {
    sprintf(buf, "%s  %-20.20s", buf, (player_table + i)->name);
    count++;
    if (count == 3) {
      count = 0;
      strcat(buf, "\r\n");
d1610 9
a1619 1
  page_string(ch->desc, buf, 1);
@


1.12
log
@Fixes file command to work in show command
@
text
@d2520 4
a2523 1
  case 5:
d2525 17
a2541 5
    for (i = 0, k = 0; i <= top_of_world; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
	if (world[i].dir_option[j] && world[i].dir_option[j]->to_room == 0)
	  sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, ++k, world[i].number,
		  world[i].name);
d2544 2
a2545 2
  case 6:

@


1.11
log
@Creates a new command called file. Allows us to view files
through the mud.
@
text
@d103 3
d2416 1
d2575 3
d4006 3
a4008 1
/* David Endre 2/23/99 To view basic files online */ ACMD(do_file) {
@


1.10
log
@Changes wiztitle to max text length of 10
@
text
@d3998 107
@


1.9
log
@Fixed poofs to show a default poof if none is set.
@
text
@d2226 2
a2227 2
  } else if (noansi  > 14) {
    sprintf(buf, "Sorry, text portion of godly titles can't be longer than 14 characters.\r\n");
d2231 1
a2231 1
    while (noansi < 14 && noansi > 0) {
@


1.8
log
@Added do_wiztitle that allows gods to edit their
godly title ie Overlord.  Also added this title
to the playerfile
fingon
@
text
@d385 1
a385 1
  if (POOFOUT(ch))
d394 1
a394 1
  if (POOFIN(ch))
d1847 1
a1847 1
      strcpy(POOFIN(ch), NULL);
d1853 1
a1853 1
      strcpy(POOFOUT(ch), NULL);
@


1.7
log
@Gods can now type goto home to get to
their homerooms.
@
text
@d2195 62
@


1.6
log
@Major change to incorporate aliases into the pfile
moved alias structure from interpreter.h to structs.h
heavily modified alias code in interpreter.c
Jimmy Kincaid AKA fingon
@
text
@d378 7
a384 4
  
  if ((location = find_target_room(ch, argument)) < 0)
    return;
  
@


1.5
log
@Added Poofs to the playerfile as well as 4 extra strings for
future use.  fingon
@
text
@d3571 2
a3572 2
void do_newbie(struct char_data *vict) /*To change newbie eq change 
									      array in structs.h Banyal*/
@


1.4
log
@dos2unix
Replaced Occurences of Hubis with Fiery
@
text
@d383 1
a383 1
    sprintf(buf, "$n %s", POOFOUT(ch));
d392 1
a392 1
    sprintf(buf, "$n %s", POOFIN(ch));
d1832 2
a1833 1

a1835 7
  char **msg;
  
  switch (subcmd) {
  case SCMD_POOFIN:    msg = &(POOFIN(ch));    break;
  case SCMD_POOFOUT:   msg = &(POOFOUT(ch));   break;
  default:    return;    break;
  }
d1839 17
a1855 8
  if (*msg)
    free(*msg);
  
  if (!*argument)
    *msg = NULL;
  else
    *msg = str_dup(argument);

@


1.3
log
@Fixed show god --Fingon
@
text
@d1 1
a1 1
/* ************************************************************************
d9 1
a9 1
 ************************************************************************ */
d407 1
a407 1
  sprintf(buf, "Hubis Classes:\r\n==============\r\n");
@


1.2
log
@Fixed show"show death" --fingon
@
text
@d2463 1
a2463 1
    for (i = 0; i <= top_of_zone_table; i++) {
d2468 1
a2468 1
    	      sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, i,
d2478 4
a2481 3
#define GOD_ROOMS_ZONE 2
    /* This also needs redone */
    /* Fingon */
d2483 12
a2494 4
    for (i = 0, j = 0; i < top_of_world; i++)
      if (world[i].zone == GOD_ROOMS_ZONE)
	sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, j++, world[i].number,
		world[i].name);
@


1.1
log
@Initial revision
@
text
@d2320 1
a2320 1
  int i, j, k, l, con;
d2458 4
d2463 12
a2474 4
    for (i = 0, j = 0; i <= top_of_world; i++)
      if (IS_SET(ROOM_FLAGS(i), ROOM_DEATH))
	sprintf(buf, "%s%2d: [%5d] %s\r\n", buf, ++j,
		world[i].number, world[i].name);
d2479 2
@
