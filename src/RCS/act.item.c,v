head	1.170;
access;
symbols;
locks; strict;
comment	@ * @;


1.170
date	2010.06.20.19.53.47;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.166;

1.166
date	2009.03.15.07.09.24;	author jps;	state Exp;
branches;
next	1.165;

1.165
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.164;

1.164
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.163;

1.163
date	2009.03.09.05.41.31;	author jps;	state Exp;
branches;
next	1.162;

1.162
date	2009.03.09.02.22.32;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.159;

1.159
date	2009.01.16.23.36.34;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2008.09.29.03.24.44;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.09.07.01.29.12;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.09.03.17.34.08;	author myc;	state Exp;
branches;
next	1.152;

1.152
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.08.31.01.19.54;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.08.30.22.02.42;	author myc;	state Exp;
branches;
next	1.148;

1.148
date	2008.08.30.21.55.50;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.08.30.20.51.38;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2008.08.30.20.25.38;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2008.08.30.20.21.07;	author jps;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2008.08.19.02.11.14;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.08.15.18.18.24;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.07.27.05.14.02;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2008.07.21.19.28.35;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2008.07.10.20.11.36;	author myc;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2008.05.14.05.10.28;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2008.05.11.05.42.46;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.04.13.21.57.17;	author jps;	state Exp;
branches;
next	1.131;

1.131
date	2008.04.13.10.03.27;	author jps;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.13.01.53.46;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.08.02.13.48;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2008.04.06.19.47.00;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.04.03.42.57;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.03.02.05.34;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.02.05.36.19;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.122;

1.122
date	2008.03.26.23.31.34;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2008.03.21.22.52.52;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2008.03.19.04.32.14;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.03.09.18.11.17;	author jps;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.116;

1.116
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.115;

1.115
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.28.05.16.11;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.27.01.42.03;	author jps;	state Exp;
branches;
next	1.110;

1.110
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.109;

1.109
date	2008.01.26.12.29.44;	author jps;	state Exp;
branches;
next	1.108;

1.108
date	2008.01.22.22.29.25;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2008.01.15.03.21.11;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2008.01.11.02.04.32;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.01.09.10.11.56;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.09.07.41.32;	author jps;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.07.11.57.31;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.06.23.50.47;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.06.05.31.35;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2007.12.21.07.51.43;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2007.12.19.20.36.01;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.18.20.01.05;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2007.10.25.20.37.00;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.21.18.08.29;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.21.08.44.45;	author jps;	state Exp;
branches;
next	1.88;

1.88
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.03.23.59.43;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2007.08.26.01.55.19;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.17.03.34.41;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2007.08.16.19.53.38;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.19.21.59.52;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2007.07.19.15.32.01;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.15.18.01.46;	author myc;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.15.17.16.12;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2007.07.14.14.34.15;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.14.01.00.14;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.28.23.41.34;	author jps;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.28.06.35.49;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.27.17.45.28;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.27.17.34.42;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.24.05.02.49;	author jps;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.21.01.35.22;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.18.00.23.34;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.15.10.36.53;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.11.14.15.28;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.11.07.25.43;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.20.17.16.27;	author myc;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.08.05.06.58;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.06.02.14.21;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.30.05.06.24;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.24.06.50.02;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.21.20.17.04;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2006.11.21.03.45.52;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.18.21.00.28;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.18.09.08.15;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.18.04.26.32;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.18.00.03.31;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.16.16.42.14;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.14.19.00.43;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.12.20.22.32;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.08.10.12.28;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.08.08.47.58;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.08.07.57.08;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2006.11.07.11.07.57;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.07.08.29.16;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.20.07.38.42;	author cjd;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.24.22.47.15;	author jjl;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.06.20.00.30;	author jjl;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.21.21.01.21;	author jjl;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.15.04.01.18;	author jjl;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.07.00.15.03;	author dce;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.18.02.29.41;	author dce;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.07.15.42.30;	author dce;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.23.03.31.37;	author dce;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.08.13.25.12;	author dce;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.07.14.10.18;	author dce;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.31.21.22.01;	author dce;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.24.15.10.26;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.16.19.25.37;	author rsd;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.28.00.44.00;	author mtp;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.25.08.09.43;	author rsd;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.20.03.34.31;	author rsd;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.10.23.32.26;	author mtp;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.10.00.04.25;	author mtp;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.04.19.41.01;	author rsd;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.22.22.24.46;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.05.22.55.57;	author rsd;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.05.22.31.12;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.05.21.53.33;	author rsd;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.05.20.49.32;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.05.06.30.44;	author rsd;	state Exp;
branches;
next	1.18;

1.18
date	99.12.02.23.17.10;	author rsd;	state Exp;
branches;
next	1.17;

1.17
date	99.11.23.15.48.23;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.09.10.01.07.05;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	99.09.10.01.04.25;	author mtp;	state Exp;
branches;
next	1.14;

1.14
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.09.03.22.57.43;	author mtp;	state Exp;
branches;
next	1.12;

1.12
date	99.08.13.21.33.19;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.08.07.23.49.16;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	99.05.02.16.50.16;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	99.04.09.03.38.36;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.03.12.18.05.43;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.02.20.18.41.36;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.02.12.16.25.09;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.10.02.38.58;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.04.09.01;	author dce;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.29;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.item.c                                    Part of CircleMUD *
 *  Usage: object handling routines -- get/drop and container handling     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "dg_scripts.h"
/*coin defins*/
#define PLAT 0
#define GOLD 1
#define SILVER 2
#define COPPER 3



/* extern variables */
extern struct str_app_type str_app[];
extern struct room_data *world;
extern char *drinks[];
extern int drink_aff[][3];
extern int invalid_class(struct char_data *ch, struct obj_data *obj);
ACMD(do_action);
ACMD(do_say);
ACMD(do_bash);
extern void Crash_crashsave(struct char_data *ch);

void mprog_give_trigger(struct char_data * mob, struct char_data * ch, struct obj_data * obj);
void mprog_bribe_trigger(struct char_data * mob, struct char_data * ch, int amount);
bool check_get_disarmed_obj(struct char_data *ch, struct char_data *last_to_hold, struct obj_data *obj);
obj_data *get_object_in_equip(char_data * ch, char *name, int *i);

void perform_put(struct char_data * ch, struct obj_data * obj,
		 struct obj_data * cont)
{
  if (!drop_otrigger(obj, ch))
    return;
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
    act("$p won't fit in $P.", FALSE, ch, obj, cont, TO_CHAR);
  else {
    obj_from_char(obj);
    obj_to_obj(obj, cont);
    act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
    act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
  }
}


/* The following put modes are supported by the code below:

   1) put <object> <container>
   2) put all.<object> <container>
   3) put all <container>

   <container> must be in inventory or on ground.
   all objects to be put into container must be in inventory.
*/

ACMD(do_put)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj, *cont;
  struct char_data *tmp_char;
  int obj_dotmode, cont_dotmode, found = 0;

  two_arguments(argument, arg1, arg2);
  obj_dotmode = find_all_dots(arg1);
  cont_dotmode = find_all_dots(arg2);

  if (!*arg1)
    send_to_char("Put what in what?\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You can only put things into one container at a time.\r\n", ch);
  else if (!*arg2) {
    sprintf(buf, "What do you want to put %s in?\r\n",
	    ((obj_dotmode == FIND_INDIV) ? "it" : "them"));
    send_to_char(buf, ch);
  } else {
    generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
    if (!cont) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
    } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
      send_to_char("You'd better open it first!\r\n", ch);
    else {
      if (obj_dotmode == FIND_INDIV) {	/* put <obj> <container> */
	if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
	  sprintf(buf, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
	  send_to_char(buf, ch);
	} else if (obj == cont)
	  send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
	else
	  perform_put(ch, obj, cont);
      } else {
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  if (obj != cont && CAN_SEE_OBJ(ch, obj) &&
	      (obj_dotmode == FIND_ALL || isname(arg1, obj->name))) {
	    found = 1;
	    perform_put(ch, obj, cont);
	  }
	}
	if (!found) {
	  if (obj_dotmode == FIND_ALL)
	    send_to_char("You don't seem to have anything to put in it.\r\n", ch);
	  else {
	    sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
	    send_to_char(buf, ch);
	  }
	}
      }
    }
  }
}



int can_take_obj(struct char_data * ch, struct obj_data * obj)
{
  if (GET_LEVEL(ch) >= LVL_BUILDER)
    return 1;
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) {
    act("$p: you can't carry that many items.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  } else if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
    act("$p: you can't carry that much weight.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  } else if (!(CAN_WEAR(obj, ITEM_WEAR_TAKE))) {
    act("$p: you can't take that!", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  }
  return 1;
}


void get_check_money(struct char_data * ch, struct obj_data * obj)
{
  if ((GET_OBJ_TYPE(obj) == ITEM_MONEY)) {
    obj_from_char(obj);
    if (GET_OBJ_VAL(obj, 0)+GET_OBJ_VAL(obj, 1)+GET_OBJ_VAL(obj, 2)+GET_OBJ_VAL(obj, 3) == 1){
      return;}
    else{
      sprintf(buf, "There were %d platinum, %d gold, %d silver and %d copper coins.\r\n", GET_OBJ_VAL(obj, 0)
	      , GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3));
      if (GET_OBJ_VAL(obj, 0)+GET_OBJ_VAL(obj, 1)+GET_OBJ_VAL(obj, 2)+GET_OBJ_VAL(obj, 3) == 0){
	sprintf(buf, "%sMust have been an illusion!\r\n", buf);}
      send_to_char(buf, ch);
    }
    GET_PLAT(ch) += GET_OBJ_VAL(obj, 0);
    GET_GOLD(ch) += GET_OBJ_VAL(obj, 1);
    GET_SILVER(ch) += GET_OBJ_VAL(obj, 2);
    GET_COPPER(ch) += GET_OBJ_VAL(obj, 3);
    extract_obj(obj);
  }
}


void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
				struct obj_data * cont, int mode)
{
  if (mode == FIND_OBJ_INV || can_take_obj(ch, obj)) {
    if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      act("$p: you can't hold any more items.", FALSE, ch, obj, 0, TO_CHAR);
    else if (get_otrigger(obj, ch)) {
      obj_from_obj(obj);
      obj_to_char(obj, ch);
      act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      get_check_money(ch, obj);
    }
  }
}


void get_from_container(struct char_data * ch, struct obj_data * cont,
			char *arg, int mode)
{
  struct obj_data *obj, *next_obj;
  int obj_dotmode, found = 0;

  obj_dotmode = find_all_dots(arg);

  if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
    act("$p is closed.", FALSE, ch, cont, 0, TO_CHAR);
  else if (obj_dotmode == FIND_INDIV) {
    if (!(obj = get_obj_in_list_vis(ch, arg, cont->contains))) {
      sprintf(buf, "There doesn't seem to be %s %s in $p.", AN(arg), arg);
      act(buf, FALSE, ch, cont, 0, TO_CHAR);
    } else
      perform_get_from_container(ch, obj, cont, mode);
  } else {
    if (obj_dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = cont->contains; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
	  (obj_dotmode == FIND_ALL || isname(arg, obj->name))) {
	found = 1;
	perform_get_from_container(ch, obj, cont, mode);
      }
    }
    if (!found) {
      if (obj_dotmode == FIND_ALL)
	act("$p seems to be empty.", FALSE, ch, cont, 0, TO_CHAR);
      else {
	sprintf(buf, "You can't seem to find any %ss in $p.", arg);
	act(buf, FALSE, ch, cont, 0, TO_CHAR);
      }
    }
  }
}


int perform_get_from_room(struct char_data * ch, struct obj_data * obj)
{
  if (check_get_disarmed_obj(ch, obj->last_to_hold, obj))
    return 0;
  if (can_take_obj(ch, obj) && get_otrigger(obj, ch)) {
    obj_from_room(obj);
    obj_to_char(obj, ch);
    act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n gets $p.", TRUE, ch, obj, 0, TO_ROOM);
    get_check_money(ch, obj);
    return 1;
  }
  return 0;
}


void get_from_room(struct char_data * ch, char *arg)
{
  struct obj_data *obj, *next_obj;
  int dotmode, found = 0;

  dotmode = find_all_dots(arg);

  if (dotmode == FIND_INDIV) {
    if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
      return;
    } else
      perform_get_from_room(ch, obj);
  } else {
    if (dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = world[ch->in_room].contents; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
	  (dotmode == FIND_ALL || isname(arg, obj->name))) {
	found = 1;
	perform_get_from_room(ch, obj);
      }
    }
    if (!found) {
      if (dotmode == FIND_ALL)
	send_to_char("There doesn't seem to be anything here.\r\n", ch);
      else {
	sprintf(buf, "You don't see any %ss here.\r\n", arg);
	send_to_char(buf, ch);
      }
    }
  }
}



ACMD(do_get)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];

  int cont_dotmode, found = 0, mode;
  struct obj_data *cont;
  struct char_data *tmp_char;

  two_arguments(argument, arg1, arg2);

  if ((IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) && (!(GET_LEVEL(ch) >= LVL_IMMORT)))
    send_to_char("Your arms are already full!\r\n", ch);
  else if (!*arg1)
    send_to_char("Get what?\r\n", ch);
  else if (!*arg2)
    get_from_room(ch, arg1);
  else
    {
      cont_dotmode = find_all_dots(arg2);
      if (cont_dotmode == FIND_INDIV)
	{
	  mode = generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
	  if (!cont)
	    {
	      sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
	      send_to_char(buf, ch);
	    }
	  else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
	    act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
	  else
	    get_from_container(ch, cont, arg1, mode);
	}
      else
	{
	  if (cont_dotmode == FIND_ALLDOT && !*arg2)
	    {
	      send_to_char("Get from all of what?\r\n", ch);
	      return;
	    }
	  for (cont = ch->carrying; cont; cont = cont->next_content)
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
	      if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER)
		{
		  found = 1;
		  get_from_container(ch, cont, arg1, FIND_OBJ_INV);
		}
	      else if (cont_dotmode == FIND_ALLDOT)
		{
		  found = 1;
		  act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
		}
	  for (cont = world[ch->in_room].contents; cont; cont = cont->next_content)
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
	      if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER)
		{
		  get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
		  found = 1;
		}
	      else if (cont_dotmode == FIND_ALLDOT)
		{
		  act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
		  found = 1;
		}
	  if (!found)
	    {
	      if (cont_dotmode == FIND_ALL)
		send_to_char("You can't seem to find any containers.\r\n", ch);
	      else
		{
		  sprintf(buf, "You can't seem to find any %ss here.\r\n", arg2);
		  send_to_char(buf, ch);
		}
	    }
	}
    }
  Crash_crashsave(ch);
}


void perform_drop_gold(struct char_data * ch, int amount,
		       byte mode, int RDR)
{
  struct obj_data *obj;

  if (amount <= 0)
    send_to_char("Heh heh heh.. we are jolly funny today, eh?\r\n", ch);
  else if (GET_GOLD(ch) < amount)
    send_to_char("You don't have that many coins!\r\n", ch);
  else {
    if (mode != SCMD_JUNK) {
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
      obj = create_money(0, amount, 0, 0);

      if (mode == SCMD_DONATE) {
	send_to_char("You throw some gold into the air where it disappears in a puff of smoke!\r\n", ch);
	act("$n throws some gold into the air where it disappears in a puff of smoke!",
	    FALSE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, RDR);
	act("$p suddenly appears in a puff of orange smoke!", 0, 0, obj, 0, TO_ROOM);
      } else {
	if (!drop_wtrigger(obj, ch)) {
          extract_obj(obj);
          return;
        }
	send_to_char("You drop some gold.\r\n", ch);
	sprintf(buf, "$n drops %s.", money_desc(amount));
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, ch->in_room);
      }
    } else {
      sprintf(buf, "$n drops %s which disappears in a puff of smoke!",
	      money_desc(amount));
      act(buf, FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You drop some gold which disappears in a puff of smoke!\r\n", ch);
    }
    GET_GOLD(ch) -= amount;
  }
}


#define VANISH(mode) ((mode == SCMD_DONATE || mode == SCMD_JUNK) ? \
		      "  It vanishes in a puff of smoke!" : "")

int perform_drop(struct char_data * ch, struct obj_data * obj,
		 byte mode, char *sname, int RDR)
{
  int value;

  if (!drop_otrigger(obj, ch))
    return 0;
  if ((mode == SCMD_DROP) && !drop_wtrigger(obj, ch))
    return 0;

  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
    sprintf(buf, "You can't %s $p, it must be CURSED!", sname);
    act(buf, FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  }
  sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
  act(buf, FALSE, ch, obj, 0, TO_CHAR);
  sprintf(buf, "$n %ss $p.%s", sname, VANISH(mode));
  act(buf, TRUE, ch, obj, 0, TO_ROOM);
  obj_from_char(obj);

  if ((mode == SCMD_DONATE) && IS_OBJ_STAT(obj, ITEM_NODONATE))
    mode = SCMD_JUNK;

  switch (mode) {
  case SCMD_DROP:
    obj_to_room(obj, ch->in_room);
    return 0;
    break;
  case SCMD_DONATE:
    obj_to_room(obj, RDR);
    act("$p suddenly appears in a puff a smoke!", FALSE, 0, obj, 0, TO_ROOM);
    return 0;
    break;
  case SCMD_JUNK:
    value = MAX(1, MIN(200, GET_OBJ_COST(obj) >> 4));
    extract_obj(obj);
    return value;
    break;
  default:
    log("SYSERR: Incorrect argument passed to perform_drop");
    break;
  }

  return 0;
}

ACMD(do_drop)
{
  extern int donation_room_1;
#if 0
  extern int donation_room_2;  /* uncomment if needed! */
  extern int donation_room_3;  /* uncomment if needed! */
#endif
  struct obj_data *obj, *next_obj;
  int RDR = 0;
  byte mode = SCMD_DROP;
  int dotmode, amount = 0;
  char *sname;

  switch (subcmd) {
  case SCMD_JUNK:
    sname = "junk";
    mode = SCMD_JUNK;
    break;
  case SCMD_DONATE:
    sname = "donate";
    mode = SCMD_DONATE;
    switch (number(0, 2)) {
    case 0:
      mode = SCMD_JUNK;
      break;
    case 1:
    case 2:
      RDR = real_room(donation_room_1);
      break;
      /*    case 3: RDR = real_room(donation_room_2); break;
	    case 4: RDR = real_room(donation_room_3); break;
      */
    }
    if (RDR == NOWHERE) {
      send_to_char("Sorry, you can't donate anything right now.\r\n", ch);
      return;
    }
    break;
  default:
    sname = "drop";
    break;
  }

  argument = one_argument(argument, arg);

  if (!*arg) {
    sprintf(buf, "What do you want to %s?\r\n", sname);
    send_to_char(buf, ch);
    return;
  }

  else if (is_number(arg)) {
    amount = atoi(arg);
    argument = one_argument(argument, arg);
    if (!str_cmp("platinum", arg) || !str_cmp("p", arg)){
      if (GET_PLAT(ch)<amount){
	send_to_char("You don't have enough!\r\n", ch);
	return;}
      obj = create_money(amount, 0, 0, 0);
      obj_to_room(obj, ch->in_room);
      GET_PLAT(ch) = GET_PLAT(ch)-amount;
      if(amount < 2){
	send_to_char("You drop a &0&b&6platinum&0 coin!\r\n", ch);
	return;}
      if (amount > 1){
	{sprintf(buf, "You drop &0&b&6%d&0 platinum coins!\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&b&6platinum&0 coins!\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
    }
    if (!str_cmp("gold", arg) || !str_cmp("g", arg)){
      if (GET_GOLD(ch)<amount){
	send_to_char("You don't have enough!\r\n", ch);
	return;}
      obj = create_money(0, amount, 0, 0);
      obj_to_room(obj, ch->in_room);
      GET_GOLD(ch) = GET_GOLD(ch)-amount;
      if(amount < 2){
	send_to_char("You drop a &0&b&3gold&0 coin!\r\n", ch);
	return;}
      if (amount > 1){
	{sprintf(buf, "You drop &0&b&3%d&0 gold coins!\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&b&3gold&0 coins!\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
    }
    if (!str_cmp("silver", arg) || !str_cmp("s", arg)){
      if (GET_SILVER(ch)<amount){
	send_to_char("You don't have enough!\r\n", ch);
	return;}
      obj = create_money(0, 0, amount, 0);
      obj_to_room(obj, ch->in_room);
      GET_SILVER(ch) = GET_SILVER(ch)-amount;
      if(amount < 2){
	send_to_char("You drop a silver coin.\r\n", ch);
	return;}
      if (amount > 1){
	{sprintf(buf, "You drop %d silver coins.\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}
	{sprintf(buf, "$n drops some silver coins.\r\n");
	act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
    }
    if (!str_cmp("copper", arg) || !str_cmp("c", arg)){
      if (GET_COPPER(ch)<amount){
	send_to_char("You don't have enough!\r\n", ch);
	return;}
      obj = create_money(0, 0, 0, amount);
      obj_to_room(obj, ch->in_room);
      GET_COPPER(ch) = GET_COPPER(ch)-amount;
      if(amount == 1){
	send_to_char("You drop a &0&3copper&0 coin.\r\n", ch);}
      if (amount > 1){
	{sprintf(buf, "You drop &0&3%d&0 copper coins.\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&3copper&0 coins.\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
    }
    else {
      /* code to drop multiple items.  anyone want to write it? -je */
      send_to_char("Sorry, you can't do that to more than one item at a time.\r\n", ch);
    }
    return;
  }   else {
    dotmode = find_all_dots(arg);

    /* Can't junk or donate all */
    if ((dotmode == FIND_ALL) && (subcmd == SCMD_JUNK || subcmd == SCMD_DONATE)) {
      if (subcmd == SCMD_JUNK)
	send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
      else
	send_to_char("Go do the donation room if you want to donate EVERYTHING!\r\n", ch);
      return;
    }
    if (dotmode == FIND_ALL) {
      if (!ch->carrying)
	send_to_char("You don't seem to be carrying anything.\r\n", ch);
      else
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  amount += perform_drop(ch, obj, mode, sname, RDR);
	}
    } else if (dotmode == FIND_ALLDOT) {
      if (!*arg) {
	sprintf(buf, "What do you want to %s all of?\r\n", sname);
	send_to_char(buf, ch);
	return;
      }
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
	sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
	send_to_char(buf, ch);
      }
      while (obj) {
	next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
	amount += perform_drop(ch, obj, mode, sname, RDR);
	obj = next_obj;
      }
    } else {
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
	sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf, ch);
      } else
	amount += perform_drop(ch, obj, mode, sname, RDR);
    }
  }

  if (amount && (subcmd == SCMD_JUNK)) {
    send_to_char("You have been rewarded by the gods!\r\n", ch);
    act("$n has been rewarded by the gods!", TRUE, ch, 0, 0, TO_ROOM);
    GET_GOLD(ch) += amount;
  }
}

void perform_give(struct char_data * ch, struct char_data * vict,
		  struct obj_data * obj)
{
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
    act("You can't let go of $p!!  Yeech!", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
  if (IS_CARRYING_N(vict) >= CAN_CARRY_N(vict)) {
    act("$N seems to have $S hands full.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(vict) > CAN_CARRY_W(vict)) {
    act("$E can't carry that much weight.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (!give_otrigger(obj, ch, vict) || !receive_mtrigger(vict, ch, obj))
    return;

  obj_from_char(obj);
  obj_to_char(obj, vict);
  MOBTrigger = FALSE;
  act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
  MOBTrigger = FALSE;
  act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
  MOBTrigger = FALSE;
  act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
  mprog_give_trigger(vict, ch, obj);
}

/* utility function for give */
struct char_data *give_find_vict(struct char_data * ch, char *arg)
{
  struct char_data *vict;

  if (!*arg) {
    send_to_char("To who?\r\n", ch);
    return NULL;
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char(NOPERSON, ch);
    return NULL;
  } else if (vict == ch) {
    send_to_char("What's the point of that?\r\n", ch);
    return NULL;
  } else
    return vict;
}


void perform_give_gold(struct char_data * ch, struct char_data * vict,
		       int *cPtr)
{
  bool afford = 1;/*assume they can afford it*/
  int amount = 0;
  int i;
  for (i = 0; i <=3;i++)
    {
      amount = amount + cPtr[i];
    }

  if (amount <= 0)
    {
      send_to_char("Heh heh heh ... we are jolly funny today, eh?\r\n", ch);
      return;
    }

  if (GET_PLAT(ch) < cPtr[PLAT])
    afford = 0;
  if (GET_GOLD(ch) < cPtr[GOLD])
    afford = 0;
  if (GET_SILVER(ch) < cPtr[SILVER])
    afford = 0;
  if (GET_COPPER(ch) < cPtr[COPPER])
    afford = 0;

  if (!afford)
    {
      send_to_char("You don't have that many coins!\r\n", ch);
      return;
    }
  else
    {
      strcpy(buf, "You give ");/*null buf string*/
      if (cPtr[PLAT])
	sprintf(buf, "%s&0&b&6%d &0platinum&0 ", buf, cPtr[PLAT]);
      if (cPtr[GOLD])
	sprintf(buf, "%s&0&b&3%d &0gold&0 ", buf, cPtr[GOLD]);
      if (cPtr[SILVER])
	sprintf(buf, "%s%d silver ", buf, cPtr[SILVER]);
      if (cPtr[COPPER])
	sprintf(buf, "%s&0&3%d&0 copper ", buf, cPtr[COPPER]);
      if (amount > 1)
	strcat(buf, "coins to $n.");
      else
	strcat(buf, "coin to $n.");


      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      if (!(PRF_FLAGGED(ch, PRF_NOREPEAT)))
	act(buf, FALSE, vict, 0, ch, TO_VICT);
      mprog_bribe_trigger(vict, ch, cPtr[GOLD]);

      strcpy(buf, "$n gives you  ");/*null buf string*/
      if (cPtr[PLAT])
	sprintf(buf, "%s &0&b&6%d&0 platinum ", buf, cPtr[PLAT]);
      if (cPtr[GOLD])
	sprintf(buf, "%s &0&b&3%d&0 gold ", buf, cPtr[GOLD]);
      if (cPtr[SILVER])
	sprintf(buf, "%s %d &0silver&0 ", buf, cPtr[SILVER]);
      if (cPtr[COPPER])
	sprintf(buf, "%s &0&3%d&0 copper ", buf, cPtr[COPPER]);
      if (amount > 1)
	strcat(buf, "coins");
      else
	strcat(buf, "coin");

      MOBTrigger = FALSE;
      act(buf, FALSE, ch, 0, vict, TO_VICT);

      strcpy(buf, "$n gives some coins to $N");

      MOBTrigger = FALSE;
      act(buf, TRUE, ch, 0, vict, TO_NOTVICT);

      if((vict==ch)&&(GET_LEVEL(ch)>=LVL_IMMORT))
	send_to_char("Ok.\r\n", ch);
      if (cPtr[PLAT])
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_PLAT(vict) += cPtr[PLAT];
	else
	  {
	    GET_PLAT(ch) -= cPtr[PLAT];
	    GET_PLAT(vict) += cPtr[PLAT];
	    bribe_mtrigger(vict, ch, cPtr[PLAT]);
	  }
      if (cPtr[GOLD])
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_GOLD(vict) += cPtr[GOLD];
	else
	  {
	    GET_GOLD(ch) -= cPtr[GOLD];
	    GET_GOLD(vict) += cPtr[GOLD];
	    bribe_mtrigger(vict, ch, cPtr[GOLD]);
	  }

      if (cPtr[SILVER])
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_SILVER(vict) += cPtr[SILVER];
	else
	  {
	    GET_SILVER(ch) -= cPtr[SILVER];
	    GET_SILVER(vict) += cPtr[SILVER];
	    bribe_mtrigger(vict, ch, cPtr[SILVER]);
	  }
      if (cPtr[COPPER])
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_COPPER(vict) += cPtr[COPPER];
	else
	  {
	    GET_COPPER(ch) -= cPtr[COPPER];
	    GET_COPPER(vict) += cPtr[COPPER];
	    bribe_mtrigger(vict, ch, cPtr[COPPER]);
	  }

      if ((cPtr[PLAT]>49) || (cPtr[GOLD]>499))
	{
	  sprintf(buf, "%s gave %d Plat %d Gold to %s", GET_NAME(ch), cPtr[PLAT], cPtr[GOLD], GET_NAME(vict));
	  mudlog(buf, CMP, LVL_GOD, FALSE);
	}
    }
}


ACMD(do_give)
{
  int amount=1, dotmode;
  int *cPtr;
  struct char_data *vict;
  struct obj_data *obj, *next_obj;
  int cash[4] = {0};
  int i;
  bool coins = 1;
  cPtr = &cash[0];
  argument = one_argument(argument, arg);
  /*if no argument then dont know who to give to so exit*/
  if (!*arg)
    {
      send_to_char("Give what to who?\r\n", ch);
      return;
    }

  /*ok we at first real argument after name*/
  /*P/G/S/C GIVE*/

  if (is_number(arg))
    {
      amount = atoi(arg);
      while (is_number(arg))
	{
	  argument = one_argument(argument, arg);
	  if (!str_cmp("platinum", arg) || !str_cmp("p", arg))
	    cash[PLAT] = amount;
	  else if (!str_cmp("gold", arg) || !str_cmp("g", arg))
	    cash[GOLD] = amount;
	  else if (!str_cmp("silver", arg) || !str_cmp("s", arg))
	    cash[SILVER] = amount;
	  else if (!str_cmp("copper", arg) || !str_cmp("c", arg))
	    cash[COPPER] = amount;
	  else
	    {
	      coins = 0;
	      break;
	    }
	  argument = one_argument(argument, arg);
	  amount = atoi(arg);
	}
      if (coins)
	{
	  /*coin handling*/
	  if (!(vict = give_find_vict(ch, arg)))
	    {
	      /*No victem found*/
	      return;
	    }
	  cPtr = &cash[0];
	  perform_give_gold(ch, vict, cPtr);
	  return;
	}
    }/*Note no coin handling past this point*/
  one_argument(argument, buf1);
  if (!(vict = give_find_vict(ch, buf1)))
    {
      /*No victem found*/
      return;
    }
  dotmode = find_all_dots(arg);
  for (i=1;i <= amount;i++)
    {
      if (dotmode == FIND_INDIV)
	{
	  if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)))
	    {
	      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	      send_to_char(buf, ch);
	    }
	  else
	    perform_give(ch, vict, obj);
	}
      else
	{
	  if (dotmode == FIND_ALLDOT && !*arg)
	    {
	      send_to_char("All of what?\r\n", ch);
	      return;
	    }
	  if (!ch->carrying)
	    send_to_char("You don't seem to be holding anything.\r\n", ch);
	  else
	    for (obj = ch->carrying; obj; obj = next_obj)
	      {
		next_obj = obj->next_content;
		if (CAN_SEE_OBJ(ch, obj) && ((dotmode == FIND_ALL || isname(arg, obj->name))))
		  perform_give(ch, vict, obj);
	      }
	}
    }
}

void weight_change_object(struct obj_data * obj, int weight)
{
  struct obj_data *tmp_obj;
  struct char_data *tmp_ch;

  if (obj->in_room != NOWHERE) {
    GET_OBJ_WEIGHT(obj) += weight;
  } else if ((tmp_ch = obj->carried_by)) {
    obj_from_char(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_char(obj, tmp_ch);
  } else if ((tmp_obj = obj->in_obj)) {
    obj_from_obj(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_obj(obj, tmp_obj);
  } else {
    log("SYSERR: Unknown attempt to subtract weight from an object.");
  }
}

void name_from_drinkcon(struct obj_data * obj)
{
  int i;
  char *new_name;
  extern struct obj_data *obj_proto;

  for (i = 0; (*((obj->name) + i) != ' ') && (*((obj->name) + i) != '\0'); i++);

  if (*((obj->name) + i) == ' ') {
    new_name = str_dup((obj->name) + i + 1);
    if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
      free(obj->name);
    obj->name = new_name;
  }
}

void name_to_drinkcon(struct obj_data * obj, int type)
{
  char *new_name;
  extern struct obj_data *obj_proto;
  extern char *drinknames[];

  CREATE(new_name, char, strlen(obj->name) + strlen(drinknames[type]) + 2);
  sprintf(new_name, "%s %s", drinknames[type], obj->name);
  if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
    free(obj->name);
  obj->name = new_name;
}

ACMD(do_drink)
{
  struct obj_data *temp;
  struct affected_type af;
  int amount, weight;
  int on_ground = 0;

  if(IS_FIGHTING(ch)) {
    send_to_char("You are afraid to try in combat!\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Drink from what?\r\n", ch);
    return;
  }
  if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    if (!(temp = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    } else
      on_ground = 1;
  }
  if ((GET_OBJ_TYPE(temp) != ITEM_DRINKCON) &&
      (GET_OBJ_TYPE(temp) != ITEM_FOUNTAIN)) {
    send_to_char("You can't drink from that!\r\n", ch);
    return;
  }
  if (on_ground && (GET_OBJ_TYPE(temp) == ITEM_DRINKCON)) {
    send_to_char("You have to be holding that to drink from it.\r\n", ch);
    return;
  }
  if ((GET_COND(ch, DRUNK) > 10) && (GET_COND(ch, THIRST) > 0)) {
    /* The pig is drunk */
    send_to_char("You can't seem to get close enough to your mouth.\r\n", ch);
    act("$n tries to drink but misses $s mouth!", TRUE, ch, 0, 0, TO_ROOM);
    return;
  }
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 0)) {
    send_to_char("Your stomach can't contain anymore!\r\n", ch);
    return;
  }
  if (!GET_OBJ_VAL(temp, 1)) {
    send_to_char("It's empty.\r\n", ch);
    return;
  }
  if (subcmd == SCMD_DRINK) {
    sprintf(buf, "$n drinks %s from $p.", drinks[GET_OBJ_VAL(temp, 2)]);
    act(buf, TRUE, ch, temp, 0, TO_ROOM);

    sprintf(buf, "You drink the %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);

    if (drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] > 0)
      amount = (25 - GET_COND(ch, THIRST)) / drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK];
    else
      amount = number(1, 3);

  } else {
    act("$n sips from $p.", TRUE, ch, temp, 0, TO_ROOM);
    sprintf(buf, "It tastes like %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);
    amount = 1;
  }

  amount = MIN(amount, GET_OBJ_VAL(temp, 1));

  /* You can't subtract more than the object weighs */
  weight = MIN(amount, GET_OBJ_WEIGHT(temp));

  weight_change_object(temp, -weight);	/* Subtract amount */

  gain_condition(ch, DRUNK,
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);

  gain_condition(ch, FULL,
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][FULL] * amount) / 1);

  gain_condition(ch, THIRST,
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 1);

  if (GET_COND(ch, DRUNK) > 10)
    send_to_char("You feel drunk.\r\n", ch);

  if (GET_COND(ch, THIRST) > 20)
    send_to_char("You don't feel thirsty any more.\r\n", ch);

  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);

  if (GET_OBJ_VAL(temp, 3)) {	/* The shit was poisoned ! */
    send_to_char("Oops, it tasted rather strange!\r\n", ch);
    act("$n chokes and utters some strange sounds.", TRUE, ch, 0, 0, TO_ROOM);

    af.type = SPELL_POISON;
    af.duration = amount * 3;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE, TRUE);
  }
  /* empty the container, and no longer poison. */
  GET_OBJ_VAL(temp, 1) -= amount;
  if (!GET_OBJ_VAL(temp, 1)) {	/* The last bit */
    GET_OBJ_VAL(temp, 2) = 0;
    GET_OBJ_VAL(temp, 3) = 0;
    name_from_drinkcon(temp);
  }
  return;
}

ACMD(do_eat)
{
  struct obj_data *food;
  struct affected_type af;
  int amount;

  if(IS_FIGHTING(ch)) {
    send_to_char("You are afraid to try in combat!\r\n", ch);
  return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Eat what?\r\n", ch);
    return;
  }
  if (!(food = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
    return;
  }
  if (subcmd == SCMD_TASTE && ((GET_OBJ_TYPE(food) == ITEM_DRINKCON) ||
			       (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN))) {
    do_drink(ch, argument, 0, SCMD_SIP);
    return;
  }
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && (GET_LEVEL(ch) < LVL_GOD)) {
    send_to_char("You can't eat THAT!\r\n", ch);
    return;
  }
  if (GET_COND(ch, FULL) > 20) {/* Stomach full */
    act("You are too full to eat more!", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_EAT) {
    act("You eat the $o.", FALSE, ch, food, 0, TO_CHAR);
    act("$n eats $p.", TRUE, ch, food, 0, TO_ROOM);
  } else {
    act("You nibble a little bit of the $o.", FALSE, ch, food, 0, TO_CHAR);
    act("$n tastes a little bit of $p.", TRUE, ch, food, 0, TO_ROOM);
  }

  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, 0) : 1);

  gain_condition(ch, FULL, amount);

  if (GET_COND(ch, FULL) > 20)
    act("You are full.", FALSE, ch, 0, 0, TO_CHAR);

  if (GET_OBJ_VAL(food, 3) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    /* The shit was poisoned ! */
    send_to_char("Oops, that tasted rather strange!\r\n", ch);
    act("$n coughs and utters some strange sounds.", FALSE, ch, 0, 0, TO_ROOM);

    af.type = SPELL_POISON;
    af.duration = amount * 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE, TRUE);
  }
  if (subcmd == SCMD_EAT)
    extract_obj(food);
  else {
    if (!(--GET_OBJ_VAL(food, 0))) {
      send_to_char("There's nothing left now.\r\n", ch);
      extract_obj(food);
    }
  }
}


ACMD(do_pour)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *from_obj = NULL, *to_obj = NULL;
  int amount;

  two_arguments(argument, arg1, arg2);

  if (subcmd == SCMD_POUR) {
    if (!*arg1) {		/* No arguments */
      act("From what do you want to pour?", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_DRINKCON) {
      act("You can't pour from that!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  }
  if (subcmd == SCMD_FILL) {
    if (!*arg1) {		/* no arguments */
      send_to_char("What do you want to fill?  And what are you filling it from?\r\n", ch);
      return;
    }
    if (!(to_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      send_to_char("You can't find it!", ch);
      return;
    }
    if (GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) {
      act("You can't fill $p!", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!*arg2) {		/* no 2nd argument */
      act("What do you want to fill $p from?", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = get_obj_in_list_vis(ch, arg2, world[ch->in_room].contents))) {
      sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN) {
      act("You can't fill something from $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      return;
    }
  }
  if (GET_OBJ_VAL(from_obj, 1) == 0) {
    act("The $p is empty.", FALSE, ch, from_obj, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR) {	/* pour */
    if (!*arg2) {
      act("Where do you want it?  Out or in what?", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (!str_cmp(arg2, "out")) {
      act("$n empties $p.", TRUE, ch, from_obj, 0, TO_ROOM);
      act("You empty $p.", FALSE, ch, from_obj, 0, TO_CHAR);

      weight_change_object(from_obj, -GET_OBJ_VAL(from_obj, 1)); /* Empty */

      GET_OBJ_VAL(from_obj, 1) = 0;
      GET_OBJ_VAL(from_obj, 2) = 0;
      GET_OBJ_VAL(from_obj, 3) = 0;
      name_from_drinkcon(from_obj);

      return;
    }
    if (!(to_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if ((GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) &&
	(GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN)) {
      act("You can't pour anything into that.", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  }
  if (to_obj == from_obj) {
    act("A most unproductive effort.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if ((GET_OBJ_VAL(to_obj, 1) != 0) &&
      (GET_OBJ_VAL(to_obj, 2) != GET_OBJ_VAL(from_obj, 2))) {
    act("There is already another liquid in it!", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (!(GET_OBJ_VAL(to_obj, 1) < GET_OBJ_VAL(to_obj, 0))) {
    act("There is no room for more.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR) {
    sprintf(buf, "You pour the %s into the %s.",
	    drinks[GET_OBJ_VAL(from_obj, 2)], arg2);
    send_to_char(buf, ch);
  }
  if (subcmd == SCMD_FILL) {
    act("You gently fill $p from $P.", FALSE, ch, to_obj, from_obj, TO_CHAR);
    act("$n gently fills $p from $P.", TRUE, ch, to_obj, from_obj, TO_ROOM);
  }
  /* New alias */
  if (GET_OBJ_VAL(to_obj, 1) == 0)
    name_to_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2));

  /* First same type liq. */
  GET_OBJ_VAL(to_obj, 2) = GET_OBJ_VAL(from_obj, 2);

  /* Then how much to pour */
  GET_OBJ_VAL(from_obj, 1) -= (amount =
			       (GET_OBJ_VAL(to_obj, 0) - GET_OBJ_VAL(to_obj, 1)));

  GET_OBJ_VAL(to_obj, 1) = GET_OBJ_VAL(to_obj, 0);

  if (GET_OBJ_VAL(from_obj, 1) < 0) {	/* There was too little */
    GET_OBJ_VAL(to_obj, 1) += GET_OBJ_VAL(from_obj, 1);
    amount += GET_OBJ_VAL(from_obj, 1);
    GET_OBJ_VAL(from_obj, 1) = 0;
    GET_OBJ_VAL(from_obj, 2) = 0;
    GET_OBJ_VAL(from_obj, 3) = 0;
    name_from_drinkcon(from_obj);
  }
  /* Then the poison boogie */
  GET_OBJ_VAL(to_obj, 3) =
    (GET_OBJ_VAL(to_obj, 3) || GET_OBJ_VAL(from_obj, 3));

  /* And the weight boogie */
  weight_change_object(from_obj, -amount);
  weight_change_object(to_obj, amount);	/* Add weight */

  return;
}



void wear_message(struct char_data * ch, struct obj_data * obj, int where)
{
  char *wear_messages[][2] = {
    {"$n lights $p and holds it.",
     "You light $p and hold it."},

    {"$n slides $p on to $s right ring finger.",
     "You slide $p on to your right ring finger."},

    {"$n slides $p on to $s left ring finger.",
     "You slide $p on to your left ring finger."},

    {"$n wears $p around $s neck.",
     "You wear $p around your neck."},

    {"$n wears $p around $s neck.",
     "You wear $p around your neck."},

    {"$n wears $p on $s body.",
     "You wear $p on your body.",},

    {"$n wears $p on $s head.",
     "You wear $p on your head."},

    {"$n puts $p on $s legs.",
     "You put $p on your legs."},

    {"$n wears $p on $s feet.",
     "You wear $p on your feet."},

    {"$n puts $p on $s hands.",
     "You put $p on your hands."},

    {"$n wears $p on $s arms.",
     "You wear $p on your arms."},

    {"$n straps $p around $s arm as a shield.",
     "You start to use $p as a shield."},

    {"$n wears $p about $s body.",
     "You wear $p around your body."},

    {"$n wears $p around $s waist.",
     "You wear $p around your waist."},

    {"$n puts $p on around $s right wrist.",
     "You put $p on around your right wrist."},

    {"$n puts $p on around $s left wrist.",
     "You put $p on around your left wrist."},

    {"$n wields $p.",
     "You wield $p."},


    {"$n wields $p.",
     "You wield $p."},


    {"$n grabs $p.",
     "You grab $p."},


    {"$n grabs $p.",
     "You grab $p."},

    {"$n wields $p.",
     "You wield $p."},

    {"$n wears $p over $s eyes.",
     "You wear $p over your eyes."},

    {"$n wears $p on $s face.",
     "You wear $p on your face."},

    {"$n wears $p in $s left ear.",
     "You wear $p in your left ear."},

    {"$n wears $p in $s right ear.",
     "You wear $p in your right ear."},

    {"$n wears $p as a badge.",
     "You wear $p as a badge."},

    {"$n attaches $p on $s belt.",
     "You attach $p on your belt."}
  };

  act(wear_messages[where][0], TRUE, ch, obj, 0, TO_ROOM);
  act(wear_messages[where][1], FALSE, ch, obj, 0, TO_CHAR);
}



void perform_wear(struct char_data * ch, struct obj_data * obj, int where)
{
  int a = 0;
  /*
   * ITEM_WEAR_TAKE is used for objects that do not require special bits
   * to be put into that position (e.g. you can hold any object, not just
   * an object with a HOLD bit.)
   */

  int wear_bitvectors[] = {
    ITEM_WEAR_TAKE, ITEM_WEAR_FINGER, ITEM_WEAR_FINGER, ITEM_WEAR_NECK,
    ITEM_WEAR_NECK, ITEM_WEAR_BODY, ITEM_WEAR_HEAD, ITEM_WEAR_LEGS,
    ITEM_WEAR_FEET, ITEM_WEAR_HANDS, ITEM_WEAR_ARMS, ITEM_WEAR_SHIELD,
    ITEM_WEAR_ABOUT, ITEM_WEAR_WAIST, ITEM_WEAR_WRIST, ITEM_WEAR_WRIST,
    ITEM_WEAR_WIELD, ITEM_WEAR_WIELD, ITEM_WEAR_HOLD, ITEM_WEAR_HOLD,
    ITEM_WEAR_2HWIELD, ITEM_WEAR_EYES, ITEM_WEAR_FACE, ITEM_WEAR_EAR,
    ITEM_WEAR_EAR, ITEM_WEAR_BADGE, ITEM_WEAR_OBELT};

  char *already_wearing[] = {
    "You're already using a light.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something on both of your ring fingers.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You can't wear anything else around your neck.\r\n",
    "You're already wearing something on your body.\r\n",
    "You're already wearing something on your head.\r\n",
    "You're already wearing something on your legs.\r\n",
    "You're already wearing something on your feet.\r\n",
    "You're already wearing something on your hands.\r\n",
    "You're already wearing something on your arms.\r\n",
    "You're already using a shield.\r\n",
    "You're already wearing something about your body.\r\n",
    "You already have something around your waist.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something around both of your wrists.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already wielding a weopon there!\r\n",
    "You're already holding something.\r\n",
    "You're already holding something.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already wearing something on your eyes.\r\n",
    "You're already wearing something on your face.\r\n",
    "YOU SHOULD NEVER SEE THIS REPORT IT!.\r\n",
    "You're already wearing something in both of your ears.\r\n",
    "You're already wearing a badge.\r\n",
    "You can't wear attach anymore to your belt.\r\n"
  };

  /* first, make sure that the wear position is valid. */
  if (!CAN_WEAR(obj, wear_bitvectors[where])) {
    if (!(IS_NPC(ch)))
      act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }

  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
	invalid_class(ch, obj)) {
      act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
      return;
    }
  }
  /* for neck, finger, and wrist, try pos 2 if pos 1 is already full */

  if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R) || (where == WEAR_HOLD) ||
      (where == WEAR_LEAR))
    if (GET_EQ(ch, where))
      where++;
  if (where == 11 || ((where >= 16) && (where <= 19)))  {
    a = 0;
    if (GET_EQ(ch, WEAR_2HWIELD))
      {
	a++;
	a++;
      }
    if (GET_EQ(ch, WEAR_HOLD))
      a++;
    if (GET_EQ(ch, WEAR_HOLD2))
      a++;
    if (GET_EQ(ch, WEAR_SHIELD))
      a++;
    if (GET_EQ(ch, WEAR_WIELD))
      a++;
    if (GET_EQ(ch, WEAR_WIELD2))
      a++;
    if (a >= 2) {
      send_to_char("I don't think so, what?? you plan to use your feet to hold that!!", ch);
      return;
    }
  }	  if (GET_EQ(ch, where)) {
    send_to_char(already_wearing[where], ch);
    return;
  }

  if (!wear_otrigger(obj, ch, where))
    return;
  wear_message(ch, obj, where);
  obj_from_char(obj);
  equip_char(ch, obj, where);
  /* SPELL AFFECTS FROM OBJECTS -revised by nechtrous */
  AFF_FLAGS(ch) = (GET_OBJ_SPELL(obj) | AFF_FLAGS(ch));
  AFF2_FLAGS(ch) = (GET_OBJ_SPELL2(obj) | AFF2_FLAGS(ch));
  AFF3_FLAGS(ch) = (GET_OBJ_SPELL3(obj) | AFF3_FLAGS(ch));

  /* I am upgrading this.... -Nechtrous
     if (IS_OBJ_SPELL_AFF(obj, ITEM_BLIND))
     SET_BIT(AFF_FLAGS(ch), AFF_BLIND);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_INVIS))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_INVIS);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_ALIGN))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_ALIGN);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_MAGIC))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_MAGIC);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_BLUR))
     SET_BIT(AFF_FLAGS(ch), AFF_BLUR);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_HASTE))
     SET_BIT(AFF_FLAGS(ch), AFF_HASTE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_INVIS))
     SET_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_EVIL))
     SET_BIT(AFF_FLAGS(ch), AFF_PROTECT_EVIL);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_GOOD))
     SET_BIT(AFF_FLAGS(ch), AFF_PROTECT_GOOD);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SANCTUARY))
     SET_BIT(AFF_FLAGS(ch), AFF_SANCTUARY);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SLEEP)){
     SET_BIT(AFF_FLAGS(ch), AFF_SLEEP);
     GET_POS(ch) = POS_SLEEPING;
     update_pos(ch);}
     if (IS_OBJ_SPELL_AFF(obj, ITEM_STONESKIN))
     SET_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SENSE_LIFE))
     SET_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_INFRA))
     SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_FLY))
     SET_BIT(AFF_FLAGS(ch), AFF_FLYING);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_FARSEE))
     SET_BIT(AFF_FLAGS(ch), AFF_FARSEE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_COMP_LANG))
     SET_BIT(AFF_FLAGS(ch), AFF_COMP_LANG);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PARALIZE))
     SET_BIT(AFF_FLAGS(ch), AFF_MAJOR_PARA);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_POISON))
     SET_BIT(AFF_FLAGS(ch), AFF_POISON);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SNEAK))
     SET_BIT(AFF_FLAGS(ch), AFF_SNEAK);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_HIDE))
     SET_BIT(AFF_FLAGS(ch), AFF_HIDE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_WATERWALK))
     SET_BIT(AFF_FLAGS(ch), AFF_WATERWALK);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_NOTRACK))
     SET_BIT(AFF_FLAGS(ch), AFF_NOTRACK);
  */
}



int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg)
{
  int where = -1;

  static char *keywords[] = {
    "!RESERVED!",
    "finger",
    "!RESERVED!",
    "neck",
    "!RESERVED!",
    "body",
    "head",
    "legs",
    "feet",
    "hands",
    "arms",
    "shield",
    "about",
    "waist",
    "wrist",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "eyes",
    "face",
    "ear",
    "!RESERVED!",
    "badge",
    "belt",
    "\n"
  };

  if (!arg || !*arg) {
    if (CAN_WEAR(obj, ITEM_WEAR_FINGER))      where = WEAR_FINGER_R;
    if (CAN_WEAR(obj, ITEM_WEAR_NECK))        where = WEAR_NECK_1;
    if (CAN_WEAR(obj, ITEM_WEAR_BODY))        where = WEAR_BODY;
    if (CAN_WEAR(obj, ITEM_WEAR_HEAD))        where = WEAR_HEAD;
    if (CAN_WEAR(obj, ITEM_WEAR_LEGS))        where = WEAR_LEGS;
    if (CAN_WEAR(obj, ITEM_WEAR_FEET))        where = WEAR_FEET;
    if (CAN_WEAR(obj, ITEM_WEAR_HANDS))       where = WEAR_HANDS;
    if (CAN_WEAR(obj, ITEM_WEAR_ARMS))        where = WEAR_ARMS;
    if (CAN_WEAR(obj, ITEM_WEAR_SHIELD))      where = WEAR_SHIELD;
    if (CAN_WEAR(obj, ITEM_WEAR_ABOUT))       where = WEAR_ABOUT;
    if (CAN_WEAR(obj, ITEM_WEAR_WAIST))       where = WEAR_WAIST;
    if (CAN_WEAR(obj, ITEM_WEAR_WRIST))       where = WEAR_WRIST_R;
    if (CAN_WEAR(obj, ITEM_WEAR_EYES))        where = WEAR_EYES;
    if (CAN_WEAR(obj, ITEM_WEAR_FACE))        where = WEAR_FACE;
    if (CAN_WEAR(obj, ITEM_WEAR_EAR))         where = WEAR_LEAR;
    if (CAN_WEAR(obj, ITEM_WEAR_BADGE))       where = WEAR_BADGE;
  } else {
    if ((where = search_block(arg, keywords, FALSE)) < 0) {
      sprintf(buf, "'%s'?  What part of your body is THAT?\r\n", arg);
      send_to_char(buf, ch);
    }
  }

  return where;
}

ACMD(do_wear)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj;
  int where, dotmode, items_worn = 0;

  two_arguments(argument, arg1, arg2);

  if (!*arg1) {
    send_to_char("Wear what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg1);

  if (*arg2 && (dotmode != FIND_INDIV)) {
    send_to_char("You can't specify the same body location for more than one item!\r\n", ch);
    return;
  }
  if (dotmode == FIND_ALL) {
    for (obj = ch->carrying; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) && (where = find_eq_pos(ch, obj, 0)) >= 0) {
	items_worn++;
	perform_wear(ch, obj, where);
      }
    }
    if (!items_worn)
      send_to_char("You don't seem to have anything wearable.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg1) {
      send_to_char("Wear all of what?\r\n", ch);
      return;
    }
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
      send_to_char(buf, ch);
    } else
      while (obj) {
	next_obj = get_obj_in_list_vis(ch, arg1, obj->next_content);
	if ((where = find_eq_pos(ch, obj, 0)) >= 0)
	  perform_wear(ch, obj, where);
	else
	  act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
	obj = next_obj;
      }
  } else {
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg1), arg1);
      send_to_char(buf, ch);
    } else {
      if ((where = find_eq_pos(ch, obj, arg2)) >= 0)
	perform_wear(ch, obj, where);
      else if (!*arg2)
	act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
    }
  }
}

ACMD(do_wield)
{
  struct obj_data *obj;
  struct obj_data *wielding = GET_EQ(ch, WEAR_WIELD);
  struct obj_data *hwielding = GET_EQ(ch, WEAR_2HWIELD);

  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Wield what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (!CAN_WEAR(obj, ITEM_WEAR_WIELD) && !CAN_WEAR(obj, ITEM_WEAR_2HWIELD))
      send_to_char("You can't wield that.\r\n", ch);
    if (CAN_WEAR(obj, ITEM_WEAR_WIELD) && (hwielding))
      send_to_char("You cant dual wield while wielding a two-hand weapon.\r\n", ch);

    else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_APPLY_INDEX(ch)].wield_w)
      send_to_char("It's too heavy for you to use.\r\n", ch);
    else if ((!wielding) && (!hwielding)) {
      if (CAN_WEAR(obj, ITEM_WEAR_WIELD) || GET_CLASS(ch) == RACE_OGRE)
	perform_wear(ch, obj, WEAR_WIELD);
      else if (CAN_WEAR(obj, ITEM_WEAR_2HWIELD))
	perform_wear(ch, obj, WEAR_2HWIELD);


    }	else {




      if (GET_SKILL(ch, SKILL_DUAL_WIELD))
	{
	  struct obj_data *wielding = GET_EQ(ch, WEAR_WIELD);
	  struct obj_data *wielding2 = GET_EQ(ch, WEAR_WIELD2);
	  struct obj_data *hwielding = GET_EQ(ch, WEAR_2HWIELD);

	  if (wielding)
	    {
	      if (!*arg)
		send_to_char("Wield what?\r\n", ch);
	      else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
		sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
		send_to_char(buf, ch);
	      } else {
		if (!CAN_WEAR(obj, ITEM_WEAR_WIELD))
		  send_to_char("You can't wield that.\r\n", ch);
		if (CAN_WEAR(obj, ITEM_WEAR_WIELD) && (hwielding) &&
                  GET_CLASS(ch) != RACE_OGRE)
		  send_to_char("You cant dual wield while wielding a two-hand weapon.\r\n", ch);

		else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_APPLY_INDEX(ch)].wield_w)
		  send_to_char("It's too heavy for you to use.\r\n", ch);
		else if (!wielding2)
		  perform_wear(ch, obj, WEAR_WIELD2);

	      }
	    }
	}
    }

  }
}

ACMD(do_grab)
{
  struct obj_data *obj;
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Hold what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)) &&
           !((obj = get_obj_in_list(arg, ch->carrying)) &&
	     GET_OBJ_TYPE(obj) == ITEM_LIGHT)) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      perform_wear(ch, obj, WEAR_LIGHT);
    else {
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && GET_OBJ_TYPE(obj) != ITEM_WAND &&
	  GET_OBJ_TYPE(obj) != ITEM_STAFF && GET_OBJ_TYPE(obj) != ITEM_SCROLL &&
	  GET_OBJ_TYPE(obj) != ITEM_POTION)
	send_to_char("You can't hold that.\r\n", ch);
      else {
	perform_wear(ch, obj, WEAR_HOLD);
      }
    }
  }
}

void perform_remove(struct char_data * ch, int pos)
{
  struct obj_data *obj;

  if (!(obj = GET_EQ(ch, pos))) {
    log("Error in perform_remove: bad pos passed.");
    return;
  }
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
    act("$p: you can't carry that many items!", FALSE, ch, obj, 0, TO_CHAR);
  else {
    obj_to_char(unequip_char(ch, pos), ch);
    act("You stop using $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n stops using $p.", TRUE, ch, obj, 0, TO_ROOM);

    if(IS_OBJ_STAT(obj, ITEM_TRANSIENT)) {
      act("$p&0 crumbles to dust and blows away.",FALSE,ch,obj,0,TO_ROOM);
      act("$p&0 crumbles to dust and blows away.",FALSE,ch,obj,0,TO_CHAR);
      extract_obj(obj);
    }

    AFF_FLAGS(ch) = (GET_OBJ_SPELL(obj) ^ AFF_FLAGS(ch));
    AFF2_FLAGS(ch) = (GET_OBJ_SPELL2(obj) ^ AFF2_FLAGS(ch));
    AFF3_FLAGS(ch) = (GET_OBJ_SPELL3(obj) ^ AFF3_FLAGS(ch));
    /* upgrading this -nechtrous
       if (IS_OBJ_SPELL_AFF(obj, ITEM_BLIND))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_BLIND);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_INVIS))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_INVIS);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_ALIGN))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_ALIGN);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_MAGIC))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_MAGIC);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_BLUR))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_BLUR);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_HASTE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_HASTE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_INVIS))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_EVIL))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_PROTECT_EVIL);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_GOOD))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_PROTECT_GOOD);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SANCTUARY))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SANCTUARY);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SLEEP)){
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SLEEP);
       GET_POS(ch) = POS_SITTING;
       update_pos(ch);}
       if (IS_OBJ_SPELL_AFF(obj, ITEM_STONESKIN))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SENSE_LIFE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_INFRA))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_FLY))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_FLYING);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_FARSEE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_FARSEE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_COMP_LANG))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_COMP_LANG);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PARALIZE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_MAJOR_PARA);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_POISON))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_POISON);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SNEAK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SNEAK);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_HIDE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_WATERWALK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_WATERWALK);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_NOTRACK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_NOTRACK);
    */
  }
}

ACMD(do_remove)
{
  struct obj_data *obj;
  int i, dotmode, found;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Remove what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg);

  if (dotmode == FIND_ALL) {
    found = 0;
    for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i)) {
	perform_remove(ch, i);
	found = 1;
      }
    if (!found)
      send_to_char("You're not using anything.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg)
      send_to_char("Remove all of what?\r\n", ch);
    else {
      found = 0;
      for (i = 0; i < NUM_WEARS; i++)
	if (GET_EQ(ch, i) &&
	    isname(arg, GET_EQ(ch, i)->name)) {
	  perform_remove(ch, i);
	  found = 1;
	}
      if (!found) {
	sprintf(buf, "You don't seem to be using any %ss.\r\n", arg);
	send_to_char(buf, ch);
      }
    }
  } else {
    if ((obj = (get_object_in_equip(ch, arg, &i))) == NULL) {
      sprintf(buf, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    } else {
      if (i == WEAR_WIELD || WEAR_2HWIELD) {
	perform_remove(ch, i);
	if (GET_EQ(ch, WEAR_WIELD2))  	{
	  if (!(GET_EQ(ch, WEAR_WIELD))) {
	    obj = GET_EQ(ch, WEAR_WIELD2);
	    obj_to_char(unequip_char(ch, WEAR_WIELD2), ch);
	    obj_from_char(obj);
	    equip_char(ch, obj, WEAR_WIELD);
	  }
	}
	return;
      }
      perform_remove(ch, i);
    }
  }
}



ACMD(do_drag)
     /* Buru 30/11/97 */
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  int door = 0, k;
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  extern int movement_loss[];

  two_arguments(argument, arg1, arg2);

  if ((!*arg2)||(!*arg1)) {
    send_to_char("Drag what? Where?", ch);
    return;
  }

  /* David Endre 1/25/99 Zzur doesn't want flying people to
                         drag things */
  if (GET_POS(ch) == POS_FLYING) {
    send_to_char("You don't have the proper leverage to do that, try standing.\r\n", ch);
    return;
  }

  if (*arg2){

    switch (*arg2) {
    case 'n':
    case 'N':
      door = 0;
      break;
    case 'e':
    case 'E':
      door = 1;
      break;
    case 's':
    case 'S':
      door = 2;
      break;
    case 'w':
    case 'W':
      door = 3;
      break;
    case 'u':
    case 'U':
      door = 4;
      break;
    case 'd':
    case 'D':
      door = 5;
      break;
    }
  }

  k = generic_find(arg1, FIND_OBJ_ROOM | FIND_CHAR_ROOM, ch, &tch, &tobj);

  if (!k){
    send_to_char("&0Can't find that!&0\r\n", ch);
    return;
  }
  if (k == FIND_OBJ_ROOM){
  if (GET_OBJ_TYPE(tobj) == ITEM_PORTAL){
  send_to_char("You cant drag that!\r\n", ch);
   return; }
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE && !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED)) {
      if (GET_OBJ_WEIGHT(tobj) > (CAN_CARRY_W(ch)*3)){
	send_to_char("&0It is too heavy for you to drag!&0", ch);}
      else {
	if(GET_LEVEL(ch)<LVL_GOD){
	  if      (GET_OBJ_WEIGHT(tobj)>50){
	    if (GET_MOVE(ch)-((GET_OBJ_WEIGHT(tobj)/50)+(movement_loss[SECT(ch->in_room)]))<(0)) {
	      send_to_char("&0You are too exhausted!&0\r\n", ch);

	      return;
	    }
	    else {
	      {
		GET_MOVE(ch) = GET_MOVE(ch)-((GET_OBJ_WEIGHT(tobj)/50)+(movement_loss[SECT(ch->in_room)]));
	      }
	    }
	  }else{
	    if(GET_MOVE(ch)-(4) < 0){
	      send_to_char("&0You are too exhausted!&0\r\n", ch);
	      return;
	    }
	    else {
	      GET_MOVE(ch) = GET_MOVE(ch)-(4);
	    }
	  }
	}
	{obj_from_room(tobj);}
	{sprintf(buf, "&0You drag %s &0behind you.\r\n", tobj->short_description);{
	  send_to_char(buf, ch);
	}
	}
	{sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);{
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}}
	{  perform_move(ch, door, 1);}
	{obj_to_room(tobj, ch->in_room);}
	{sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);{
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}}}
      return;
    }
    else     { send_to_char("&0You can't go that way!&0\r\n", ch);}
    return;}
  if (k == FIND_CHAR_ROOM){
    sprintf(buf, "&0Maybe you should kill $m first!&0");{
      act(buf, FALSE, ch, 0, 0, TO_CHAR);}return;}
  else{
    send_to_char("&0You can't drag that!&0\r\n", ch);}
  return;}
ACMD(do_doorbash)
     /* BURU 5/12/97 */
     /*Changed to a skill to allow multi_assigning to races in class.c */
     /*Banyal*/
#define EXITK(room, dir)		(world[room].dir_option[dir])
#define OPEN_DOORK(room, door) (TOGGLE_BIT(EXITK(room, door)->exit_info,EX_CLOSED))
{
  char arg[MAX_INPUT_LENGTH];
  int dir = 0, percent, temp, race;
  extern int rev_dir[];
  one_argument(argument, arg);
  percent = number(0, 101);
  temp = percent + GET_LEVEL(ch);
  if (GET_LEVEL(ch) >= LVL_IMMORT){
    temp = 101;}
  if (!*arg&&((GET_SKILL(ch, SKILL_DOORBASH))||(GET_LEVEL(ch)>=LVL_IMMORT))){
    send_to_char("&0What direction?&0\r\n", ch);
    return;}
  if (GET_LEVEL(ch)<LVL_IMMORT)
    {

      race = GET_RACE(ch);
      if((race != RACE_TROLL) && (race != RACE_OGRE) && (race!= RACE_BARBARIAN))
	{
	  send_to_char("&0You do not feel massive enough!&0\r\n", ch);
	  return;
	}
    }

  if (*arg){
    switch (*arg) {
    case 'n':
    case 'N':
      dir = 0;
      break;
    case 'e':
    case 'E':
      dir = 1;
      break;
    case 's':
    case 'S':
      dir = 2;
      break;
    case 'w':
    case 'W':
      dir = 3;
      break;
    case 'u':
    case 'U':
      dir = 4;
      break;
    case 'd':
    case 'D':
      dir = 5;
      break;
default:
  send_to_char("Doorbash where?\r\n", ch);
  return;
  break;		 }}
  if ((GET_SKILL(ch, SKILL_DOORBASH)||(GET_LEVEL(ch)>=LVL_IMMORT))){
    if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE){
      send_to_char("&0Even YOU couldn't bash through that!...\r\n&0", ch);
      return;}
    if (EXIT(ch, dir) && EXIT(ch, dir)->to_room != NOWHERE &&
	!IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
      send_to_char("&0There is no obstruction!&0\r\n", ch);
      return;}

    if (EXIT(ch, dir)) {
      if (!IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF)){
	if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED))||(IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))){
	  if (temp < 80){
	    {sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n", fname(EXIT(ch, dir)->keyword));
	    send_to_char(buf, ch);}
	    {sprintf(buf, "&0$n &0charges at the %s and simple bounces off!&0", fname(EXIT(ch, dir)->keyword));
	    act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	    WAIT_STATE(ch, PULSE_VIOLENCE*3);
	    if(GET_LEVEL(ch) < LVL_IMMORT){
	      if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5){
		GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
		update_pos(ch);}
	      else {
		GET_HIT(ch) = -5;
		update_pos(ch);}
	      return;}}


	  if (temp >79){
	    OPEN_DOORK(ch->in_room, dir);
	    {
	      sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
	      act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	    {
	      sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n", fname(EXIT(ch, dir)->keyword));
	      send_to_char(buf, ch);}
	    {	  sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
	    act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);}
	    perform_move(ch, dir, 1);
	    if (EXIT(ch, rev_dir[dir])) {
	      OPEN_DOORK(ch->in_room, rev_dir[dir]);
	      WAIT_STATE(ch, PULSE_VIOLENCE);}
	    else{
	      return;}}
	  return;}}
      else{
	{sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n", fname(EXIT(ch, dir)->keyword));
	send_to_char(buf, ch);}
	{sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0", fname(EXIT(ch, dir)->keyword));
	act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	WAIT_STATE(ch, PULSE_VIOLENCE*3);
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5){
	    GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
	    update_pos(ch);}
	  else {
	    GET_HIT(ch) = -5;
	    update_pos(ch);}
	}
	return;
      }
    }
  }
}


ACMD(do_home)
{
  struct char_data;

  if (POOFOUT(ch))
    sprintf(buf, "$n %s", POOFOUT(ch));
  else
    strcpy(buf, "$n disappears in a puff of smoke.");
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  char_from_room(ch);
  char_to_room(ch, real_room(GET_LOADROOM(ch)));
  if (POOFIN(ch))
    sprintf(buf, "$n %s", POOFIN(ch));
  else
    strcpy(buf, "$n appears with an ear-splitting bang.");
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
  return;
}

bool check_get_disarmed_obj(struct char_data *ch, struct char_data *last_to_hold, struct obj_data *obj)
{
  int rand;
  struct char_data *tmp_ch;
  bool retval = FALSE;
  char Gbuf4[MAX_STRING_LENGTH];
  int cmd_say, cmd_glare, cmd_bash;
  cmd_say = find_command("say");
  cmd_glare = find_command("glare");
  cmd_bash = find_command("bash");


  if (IS_SET(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED)) {
    /* make sure owner isn't dead, or has left room. either case means */
    /* he doesn't care about his item(s) any longer */
    LOOP_THRU_PEOPLE(tmp_ch, ch)
      if (tmp_ch != ch && tmp_ch == last_to_hold)
	break;

    if (tmp_ch && AWAKE(tmp_ch)) {
      /*if (racial_traits[GET_RACE(last_to_hold)].has_hands &&
	racial_traits[GET_RACE(last_to_hold)].can_talk) {*/
      strcpy(Gbuf4, "No you don't!! That belongs to me!");
      do_say(last_to_hold, Gbuf4, cmd_say, 0);
      /*} else {
	strcpy(Gbuf4, "GRRRRRRRR!!");
	do_yell(last_to_hold, Gbuf4, 0);
	}*/

      strcpy(Gbuf4, GET_NAME(ch));
      do_action(last_to_hold, Gbuf4, cmd_glare, 0);

      if (number(1, 64) > 8) {	/* darn, PC failed to grab it. now they pay. */
	rand = number(1, 4);

	retval = TRUE;

	if (rand == 1) {
	  act("$N plants $S solid brickhouse body directly in front of $n, ", FALSE, ch, 0, last_to_hold, TO_ROOM);
	  act("making $o totally inaccessible.", FALSE, ch, obj, 0, TO_ROOM);
	  act("$N steps directly in front of your path.  No way to get it now.", FALSE, ch, 0, last_to_hold, TO_CHAR);
	} else if (rand == 2) {
	  act("$N throws $self within $o's close vicinity, making it totally impossible to get to.",
	      FALSE, ch, obj, last_to_hold, TO_ROOM);
	  act("$N hurdles $Mself into close vicinity of the $o.  Impossible to get to now!",
	      FALSE, ch, obj, last_to_hold, TO_CHAR);
	} else {		/* this is the real kicker */
	  act("$n gets far too close, and $N shoves $S wrecking-ball fist through $n's chest.",
	      FALSE, ch, 0, last_to_hold, TO_ROOM);
	  act("You have managed to get FAR TOO CLOSE to $N.", FALSE, ch, 0, last_to_hold, TO_CHAR);

	  sprintf(Gbuf4, " %s", GET_NAME(ch));

	  do_bash(last_to_hold, Gbuf4, cmd_bash, 0);	/* yes, they got
							   too close, so they pay */
	}
      } else {
	act("You amazingly evade $N and reach your goal!", FALSE, ch, 0, last_to_hold, TO_CHAR);
	act("$n throws $N for major loop, incredulously making $s way to $o.",
	    FALSE, ch, obj, last_to_hold, TO_ROOM);
      }
    }
  }
  return retval;
}
@


1.170
log
@Log to file errors we might want to see.
@
text
@/***************************************************************************
 * $Id: act.item.c,v 1.169 2009/03/20 13:56:22 jps Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: act.item.c                                     Part of FieryMUD *
 *  Usage: object handling routines -- get/drop and container handling     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <math.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "dg_scripts.h"
#include "races.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "chars.h"
#include "pfiles.h"
#include "screen.h"
#include "shop.h"
#include "regen.h"
#include "limits.h"
#include "composition.h"
#include "board.h"
#include "money.h"

/* GIVE return codes */
#define GIVE_FAIL           0
#define GIVE_SUCCESS        1
#define GIVE_FAIL_FULL      2
#define GIVE_FAIL_FLUID     3
#define GIVE_FAIL_DONTHAVE  4

/* extern variables */
ACMD(do_action);
ACMD(do_say);
ACMD(do_bash);

/*
 * Returns an integer.  100 and below should be failure.  Above 100 should
 * be interpreted as success.
 */
#define MAX_CONCEAL_WEIGHT        200
int conceal_roll(struct char_data *ch, struct obj_data *obj) {
  int skill = GET_SKILL(ch, SKILL_CONCEAL);
  int lower_bound = -0.0008 * pow(skill, 3) + 0.1668 * pow(skill, 2) - 3.225 * skill;
  int upper_bound = 2000 * skill / (3 * GET_DEX(ch) + GET_INT(ch));
  int roll = number(lower_bound, upper_bound) + dex_app_skill[GET_DEX(ch)].hide;

  /* You can't conceal/palm/stow an item higher than your level. */
  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch))
    return 0;

  if (GET_LEVEL(ch) < LVL_IMMORT) {
    /* Modify roll by weight. */
    roll *= (MAX_CONCEAL_WEIGHT - GET_OBJ_WEIGHT(obj)) / ((float) MAX_CONCEAL_WEIGHT);

    /* It is more difficult to conceal items of a level closer to your own. */
    roll -= GET_OBJ_LEVEL(obj) - GET_LEVEL(ch);
  }

  return MAX(0, roll);
}

void perform_put(struct char_data * ch, struct obj_data * obj,
                 struct obj_data * cont)
{
  if (!drop_otrigger(obj, ch))
    return;
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, VAL_CONTAINER_CAPACITY))
    act("$p won't fit in $P.", FALSE, ch, obj, cont, TO_CHAR);
  else if (OBJ_FLAGGED(obj, ITEM_NODROP))
    act("You can't put $p in $P - it must be CURSED!", FALSE, ch, obj, cont, TO_CHAR);
  else {
    if (!RIGID(ch) && cont->carried_by != ch)
      act("$p becomes solid again as it leaves your grasp.", FALSE, ch, obj, 0, TO_CHAR);
    obj_from_char(obj);
    obj_to_obj(obj, cont);
    /* When you put a nonpermanent light in a container, it is
     * extinguished. */
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
        GET_OBJ_VAL(obj, VAL_LIGHT_LIT) &&
        GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) >= 0) {
      GET_OBJ_VAL(obj, 0) = 0;
      /* obj_from_char takes care of decrementing room light */
      act("You extinguish $p and put it in $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n extinguishes $p and puts it in $P.", TRUE, ch, obj, cont, TO_ROOM);
    }
    else {
      act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
    }
  }
}


/* The following put modes are supported by the code below:

   1) put <object> <container>
   2) put all.<object> <container>
   3) put all <container>

   <container> must be in inventory or on ground.
   all objects to be put into container must be in inventory.
*/

ACMD(do_put)
{
  char argbuf1[MAX_INPUT_LENGTH], *arg1 = argbuf1;
  char argbuf2[MAX_INPUT_LENGTH], *arg2 = argbuf2;
  struct obj_data *obj, *next_obj, *cont;
  struct char_data *tmp_char;
  int obj_dotmode, cont_dotmode, found = 0;

  two_arguments(argument, arg1, arg2);
  obj_dotmode = find_all_dots(&arg1);
  cont_dotmode = find_all_dots(&arg2);

  if (!*arg1)
    send_to_char("Put what in what?\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You can only put things into one container at a time.\r\n", ch);
  else if (!*arg2)
    cprintf(ch, "What do you want to put %s in?\r\n",
            ((obj_dotmode == FIND_INDIV) ? "it" : "them"));
  else if (CONFUSED(ch))
    send_to_char("You're too confused.\r\n", ch);
  else {
    generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
    if (!cont)
      cprintf(ch, "You don't see %s %s here.\r\n", AN(arg2), arg2);
    else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (IS_SET(GET_OBJ_VAL(cont, VAL_CONTAINER_BITS), CONT_CLOSED))
      send_to_char("You'd better open it first!\r\n", ch);
    else {
      if (obj_dotmode == FIND_INDIV) {        /* put <obj> <container> */
        if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1))))
          cprintf(ch, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
        else if (obj == cont)
          send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
        else
          perform_put(ch, obj, cont);
      } else {
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          if (obj != cont && CAN_SEE_OBJ(ch, obj) &&
              (obj_dotmode == FIND_ALL || isname(arg1, obj->name))) {
            found = 1;
            perform_put(ch, obj, cont);
          }
        }
        if (!found) {
          if (obj_dotmode == FIND_ALL)
            send_to_char("You don't seem to have anything to put in it.\r\n", ch);
          else
            cprintf(ch, "You don't seem to have any %s%s.\r\n", arg1,
                    isplural(arg1) ? "" : "s");
        }
      }
    }
  }
}


ACMD(do_stow)
{
  char argbuf1[MAX_INPUT_LENGTH], *arg1 = argbuf1;
  char argbuf2[MAX_INPUT_LENGTH], *arg2 = argbuf2;
  struct obj_data *obj, *cont = NULL;
  struct char_data *tch;
  int obj_dotmode, cont_dotmode;

  ACMD(do_drop);

  if (CONFUSED(ch)) {
    send_to_char("You are too confused.\r\n", ch);
    return;
  }

  two_arguments(argument, arg1, arg2);
  obj_dotmode = find_all_dots(&arg1);
  cont_dotmode = find_all_dots(&arg2);

  if (!GET_SKILL(ch, SKILL_CONCEAL)) {
    if (*arg2)
      do_put(ch, argument, cmd, 0);
    else
      do_drop(ch, argument, cmd, SCMD_DROP);
  }
  else if (!*arg1)
    send_to_char("Stow what in what?\r\n", ch);
  else if (obj_dotmode != FIND_INDIV)
    send_to_char("You can only stow one item at a time.\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You'll need to break it into pieces to put it into more than one container!\r\n", ch);
  else {
    if (*arg2)
      generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tch, &cont);
    if (*arg2 && !cont)
      cprintf(ch, "You don't see %s %s here.\r\n", AN(arg2), arg2);
    else if (cont && GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (cont && IS_SET(GET_OBJ_VAL(cont, VAL_CONTAINER_BITS), CONT_CLOSED))
      send_to_char("You'd better open it first!\r\n", ch);
    else {
      if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1))))
        cprintf(ch, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
      else if (obj == cont)
        send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
      else if (!drop_otrigger(obj, ch))
        return;
      else if (OBJ_FLAGGED(obj, ITEM_NODROP))
        act("You can't stow $p in $P because it's CURSED!", FALSE, ch, obj, cont, TO_CHAR);
      else if (cont && GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, VAL_CONTAINER_CAPACITY))
        act("$p won't fit in $P.", FALSE, ch, obj, cont, TO_CHAR);
      else {
        int roll = conceal_roll(ch, obj);
        obj_from_char(obj);
        if (!*arg2) {
          obj_to_room(obj, ch->in_room);
          act("You sneakily toss $p by your feet.", FALSE, ch, obj, 0, TO_CHAR);
        }
        else {
          obj_to_obj(obj, cont);
          /* When you stow a nonpermanent light in a container, it is
            * automatically extinguished. */
          if (GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
              GET_OBJ_VAL(obj, VAL_LIGHT_LIT) &&
              GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) >= 0) {
            GET_OBJ_VAL(obj, VAL_LIGHT_LIT) = 0;
            roll -= 20;
            /* obj_from_char takes care of decrementing room light */
            act("You extinguish $p and slip it inside $P.", FALSE, ch, obj, cont, TO_CHAR);
          }
          else
            act("You furtively slip $p inside $P.", FALSE, ch, obj, cont, TO_CHAR);
        }
        LOOP_THRU_PEOPLE(tch, ch) {
          if (tch == ch)
            continue;
          if (!CAN_SEE(tch, ch))
            continue;
          if (CAN_SEE(ch, tch) ?
              (GET_PERCEPTION(tch) < roll - 50 + number(0, 50)) :
              (GET_PERCEPTION(tch) < roll / 2))
            continue;
          if (!*arg2)
            act("$n tosses $p by $s feet.", FALSE, ch, obj, tch, TO_VICT);
          else {
            sprintf(buf, "%s looks around, furtively slipping $p into $P.", GET_NAME(ch));
            act(buf, TRUE, tch, obj, cont, TO_CHAR);
          }
        }
        WAIT_STATE(ch, PULSE_VIOLENCE);
        improve_skill(ch, SKILL_CONCEAL);
      }
    }
  }
}



void perform_drop(struct char_data * ch, struct obj_data * obj,
                 byte mode, const char *verb)
{
  const char *sname = verb;
  /* Possible modes here are SCMD_DROP, SCMD_JUNK, SCMD_DONATE,
   * and SCMD_LETDROP.  That last mode occurs when you tried to
   * give an object to someone who was insubstantial, so the
   * object falls to the ground.  You could also use it for any
   * drop-like action where you don't want this function to
   * print messages. */

  /* If you cannot drop the item, you cannot invoke its drop trigger,
   * so this comes before the trigger checks. */

  if (OBJ_FLAGGED(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100) {
    sprintf(buf, "You can't %s $p - it must be CURSED!", verb);
    act(buf, FALSE, ch, obj, 0, TO_CHAR);
    return;
  }

  if (OBJ_FLAGGED(obj, ITEM_NOFALL))
    sname = "release";

  /* Fiery does not use 'donate', and 'junk' should not cause a drop
   * trigger to go off. */

  if (mode == SCMD_DROP || mode == SCMD_LETDROP) {
     if (!drop_otrigger(obj, ch))
       return;
     if (!drop_wtrigger(obj, ch))
       return;
  }

  if (mode != SCMD_LETDROP) {
    sprintf(buf, "You %s $p.", sname);
    act(buf, FALSE, ch, obj, 0, TO_CHAR);
    sprintf(buf, "$n %ss $p.", sname);
    act(buf, !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
  }

  if (mode != SCMD_JUNK && !RIGID(ch))
    act("$p becomes solid again as it leaves your grasp.", FALSE, ch, obj, 0, TO_CHAR);
  obj_from_char(obj);

  switch (mode) {
  case SCMD_DROP:
  case SCMD_LETDROP:
    obj_to_room(obj, ch->in_room);
    break;
  case SCMD_JUNK:
    extract_obj(obj);
    break;
  default:
    log("SYSERR: Incorrect argument passed to perform_drop");
    break;
  }
}

struct obj_data *random_inventory_object(struct char_data *ch)
{
   struct obj_data *obj, *chosen = NULL;
   int count = 0;

   for (obj = ch->carrying; obj; obj = obj->next_content) {
      if (CAN_SEE_OBJ(ch, obj)) {
         if (chosen == NULL || number(0, count) == 0)
            chosen = obj;
         count++;
      }
   }

   return chosen;
}

struct obj_data *confused_inventory_switch(struct char_data *ch, struct obj_data *obj)
{
   struct obj_data *chosen = obj;

   if (CONFUSED(ch) && number(0, 1) == 0) {
      chosen = random_inventory_object(ch);
      if (chosen && obj != chosen) {
         act("&5Fumbling about, you grasp $p&0&5...&0", FALSE,
              ch, chosen, 0, TO_CHAR);
         return chosen;
      }
   }

   return obj;
}

void drop_random_object(struct char_data *ch)
{
   struct obj_data *obj;
   if ((obj = random_inventory_object(ch)))
     perform_drop(ch, obj, SCMD_DROP, "drop");
}

ACMD(do_drop)
{
  struct obj_data *obj, *next_obj;
  int dotmode, amount, type, total;
  const char *cmdname = "drop";
  int coins[4] = { 0, 0, 0, 0 };
  struct find_context context;
  char *name = arg;

  if (subcmd == SCMD_JUNK) {
    cmdname = "junk";
    if (CONFUSED(ch)) {
       send_to_char("That's impossible in your confused state.\r\n", ch);
       return;
    }
  }

  if (parse_money(&argument, coins)) {
    if (!CASH_VALUE(coins)) {
      send_to_char("You drop 0 coins.  Okaaayy...\r\n", ch);
      return;
    }
    for (type = 0; type < NUM_COIN_TYPES; ++type)
      if (GET_COINS(ch)[type] < coins[type]) {
        cprintf(ch, "You don't have enough %s!\r\n", COIN_NAME(type));
        return;
      }
    obj = create_money(coins);
    obj_to_char(obj, ch);
    for (type = 0; type < NUM_COIN_TYPES; ++type)
      GET_COINS(ch)[type] -= coins[type];
    perform_drop(ch, obj, subcmd, cmdname);
    return;
  }

  argument = one_argument(argument, name);

  if (!*name) {
    cprintf(ch, "What do you want to %s?\r\n", cmdname);
    return;
  }

  dotmode = find_all_dots(&name);

  if (dotmode == FIND_ALL) {
    if (subcmd == SCMD_JUNK)
      send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
    else if (!ch->carrying)
      send_to_char("You don't seem to be carrying anything.\r\n", ch);
    else
      for (obj = ch->carrying; obj; obj = next_obj) {
        next_obj = obj->next_content;
        perform_drop(ch, obj, subcmd, cmdname);
      }
  }
  else if (dotmode == FIND_ALLDOT) {
    context = find_vis_by_name(ch, name);
    if (!*name)
      cprintf(ch, "What do you want to %s all of?\r\n", cmdname);
    else if (!(obj = find_obj_in_list(ch->carrying, context)))
      cprintf(ch, "You don't seem to have any %s%s.\r\n", name,
              isplural(name) ? "" : "s");
    else
      while (obj) {
        next_obj = find_obj_in_list(obj->next_content, context);
        perform_drop(ch, obj, subcmd, cmdname);
        obj = next_obj;
      }
  }
  else {
    amount = 1;
    if (is_number(name)) {
      skip_spaces(&argument);
      if (*argument) {
        amount = atoi(name);
        one_argument(argument, name);
      }
    }
    context = find_vis_by_name(ch, name);

    if (!amount)
      send_to_char("So...you don't want to drop anything?\r\n", ch);
    else if (!(obj = find_obj_in_list(ch->carrying, context)))
      cprintf(ch, "You don't seem to have %s %s%s.\r\n",
              amount == 1 ? AN(name) : "any", arg,
              amount == 1 || isplural(name) ? "" : "s");
    else {
      total = amount;

      while (obj && amount > 0) {
        next_obj = find_obj_in_list(obj->next_content, context);
        --amount;
        if (CONFUSED(ch) && number(0, 1) == 0) {
          drop_random_object(ch);
          /* Cannot continue loop; drop_random_object may drop next_obj */
          break;
        }
        else
          perform_drop(ch, obj, subcmd, cmdname);
        obj = next_obj;
      }

      if (!CONFUSED(ch) && amount)
        cprintf(ch, "You only had %d %s%s.\r\n",
                total - amount, name,
                isplural(name) || total - amount == 1? "" : "s");
    }
  }
}

int check_container_give(struct obj_data *obj, struct char_data *ch,
                                               struct char_data *vict)
{
  struct obj_data *cont;
  int retval = 0;

  if (obj->contains) {
    cont = obj->contains;
    while (cont) {
      if (GET_OBJ_LEVEL(cont) > GET_LEVEL(vict)) {
        sprintf(buf, "%s isn't experienced enough to use $p that is in $P.", GET_NAME(vict));
        act(buf, FALSE, ch, cont, obj, TO_CHAR);
        return 1;
      }
      if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
        if (check_container_give(cont, ch, vict))
          return 1;
      }
      cont = cont->next_content;
    }
  }

  return retval;
}


int perform_give(struct char_data * ch, struct char_data * vict,
                  struct obj_data * obj, int silent)
{
  if (OBJ_FLAGGED(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100
      && !(IS_NPC(ch) && (!(ch)->desc ||
                          GET_LEVEL(POSSESSOR(ch))>=LVL_IMPL))) {
    act("You can't let go of $p!!  Yeech!", FALSE, ch, obj, 0, TO_CHAR);
    return GIVE_FAIL;
  }
  if (IS_CARRYING_N(vict) >= CAN_CARRY_N(vict)) {
    act("$N seems to have $S hands full.", FALSE, ch, 0, vict, TO_CHAR);
    return GIVE_FAIL_FULL;
  }
  if (!ADDED_WEIGHT_OK(vict, obj)) {
    act("$E can't carry that much weight.", FALSE, ch, 0, vict, TO_CHAR);
    return GIVE_FAIL;
  }
  if (ADDED_WEIGHT_REFUSED(vict, obj)) {
    act("$E doesn't look like $E could handle the additional weight.", FALSE, ch, 0, vict, TO_CHAR);
    return GIVE_FAIL;
  }
  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(vict)) {
    act("$E isn't experienced enough to use $p.", FALSE, ch, obj, vict, TO_CHAR);
    return GIVE_FAIL;
  }
  if (!give_otrigger(obj, ch, vict) || !receive_mtrigger(vict, ch, obj))
    return GIVE_FAIL;

  if (give_shopkeeper_reject(ch, vict, obj))
    return GIVE_FAIL;

  if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER)
    if (check_container_give(obj, ch, vict))
      return GIVE_FAIL;

  if (!RIGID(ch) && !RIGID(vict) && !MOB_FLAGGED(vict, MOB_ILLUSORY)) {
     /* Between fluid persons, the transfer seems completely normal */
  } else if (!RIGID(ch))
    act("$p becomes solid again as it leaves your grasp.", FALSE, ch, obj, 0, TO_CHAR);

  /* When you give items to an illusory or fluid mob, they fall to the ground. */

  if (SOLIDCHAR(ch) && !SOLIDCHAR(vict) && GET_LEVEL(ch) < LVL_IMMORT && GET_LEVEL(vict) < LVL_IMMORT) {
    /* Note that "silent" only applies to success messages. */
    act("$n gives you $p, but you can't hold onto it.",
          FALSE, ch, obj, vict, TO_VICT);
    if (IS_SPLASHY(IN_ROOM(vict))) {
      act("You hand $p to $N, but it simply falls into the water.",
            FALSE, ch, obj, vict, TO_CHAR);
      act("$n gives $p to $N, but it falls into the water.",
            !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch),
            ch, obj, vict, TO_NOTVICT);
    } else {
      act("You hand $p to $N, but it simply falls to the ground.",
            FALSE, ch, obj, vict, TO_CHAR);
      act("$n gives $p to $N, but it falls to the ground.",
            !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch),
            ch, obj, vict, TO_NOTVICT);
    }
    perform_drop(ch, obj, SCMD_LETDROP, "release");
    return GIVE_FAIL;
  }

  obj_from_char(obj);
  obj_to_char(obj, vict);

  if (!silent) {
    act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
    act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
    act("$n gives $p to $N.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch),
          ch, obj, vict, TO_NOTVICT);
  }

  return GIVE_SUCCESS;
}

/* utility function for give */
struct char_data *give_find_vict(struct char_data * ch, char *arg)
{
  struct char_data *vict;

  if (!*arg) {
    send_to_char("To who?\r\n", ch);
    return NULL;
  } else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return NULL;
  } else if (vict == ch) {
    send_to_char("What's the point of that?\r\n", ch);
    return NULL;
  } else
    return vict;
}


void perform_give_money(struct char_data * ch, struct char_data * vict,
                        int coins[])
{
   bool afford = TRUE;
   int amount = 0, i;
   struct obj_data *obj;

   for (i = 0; i <= 3; i++)
      amount = amount + coins[i];

   if (amount <= 0) {
      send_to_char("Heh heh heh ... we are jolly funny today, eh?\r\n", ch);
      return;
   }

   if (GET_PLATINUM(ch) < coins[PLATINUM])
      afford = FALSE;
   else if (GET_GOLD(ch) < coins[GOLD])
      afford = FALSE;
   else if (GET_SILVER(ch) < coins[SILVER])
      afford = FALSE;
   else if (GET_COPPER(ch) < coins[COPPER])
      afford = FALSE;

   if (!afford) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return;
   }

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      GET_PLATINUM(ch) -= coins[PLATINUM];
      GET_GOLD(ch)     -= coins[GOLD];
      GET_SILVER(ch)   -= coins[SILVER];
      GET_COPPER(ch)   -= coins[COPPER];
   }

   if (!SOLIDCHAR(vict) && GET_LEVEL(vict) < LVL_IMMORT) {
      obj = create_money(coins);
      act("The coins seem to fall right through $n's hands!",
            FALSE, vict, 0, ch, TO_VICT);
      if (IS_SPLASHY(IN_ROOM(vict))) {
         act("$n tries to give some coins to $N, but they fell into the water!",
               TRUE, ch, 0, vict, TO_NOTVICT);
      } else {
         act("$n tries to give some coins to $N, but they fell to the ground!",
               TRUE, ch, 0, vict, TO_NOTVICT);
      }
      obj_to_room(obj, vict->in_room);
      return;
   }

   if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
   else {
      strcpy(buf, "You give $n ");
      statemoney(buf + strlen(buf), coins);
      strcat(buf, ".");
      act(buf, FALSE, vict, 0, ch, TO_VICT);
   }

   strcpy(buf, "$n gives you ");
   statemoney(buf + strlen(buf), coins);
   strcat(buf, ".");
   act(buf, FALSE, ch, 0, vict, TO_VICT);

   act("$n gives some coins to $N.", TRUE, ch, 0, vict, TO_NOTVICT);

   GET_PLATINUM(vict) += coins[PLATINUM];
   GET_GOLD(vict) += coins[GOLD];
   GET_SILVER(vict) += coins[SILVER];
   GET_COPPER(vict) += coins[COPPER];

   bribe_mtrigger(vict, ch, coins);

   if (coins[PLATINUM] > 50 || coins[GOLD] > 500) {
      sprintf(buf, "%s gave %d Plat %d Gold to %s",
              GET_NAME(ch), coins[PLATINUM], coins[GOLD], GET_NAME(vict));
      mudlog(buf, CMP, LVL_GOD, TRUE);
   }
}


ACMD(do_give)
{
  int amount = 1, dotmode, result = GIVE_FAIL_DONTHAVE, i, counter = 0;
  struct char_data *vict;
  struct obj_data *obj, *next_obj, *ref_obj = NULL;
  int cash[NUM_COIN_TYPES] = {0};
  char *name = arg;

  if (parse_money(&argument, cash)) {
    one_argument(argument, name);
    if (!(vict = give_find_vict(ch, name)))
      return;
    perform_give_money(ch, vict, cash);
    return;
  }

  argument = one_argument(argument, name);

  if (!*name) {
    send_to_char("Give what to who?\r\n", ch);
    return;
  }

  if (is_number(name)) {
    amount = atoi(name);
    argument = one_argument(argument, name);
  }

  /* And who are we giving this to? */
  one_argument(argument, buf1);
  if (!(vict = give_find_vict(ch, buf1)))
    return;

  dotmode = find_all_dots(&name);

  if (amount <= 0) {
    act("You give nothing to $N.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }

  if (amount > 1 && dotmode != FIND_INDIV) {
    cprintf(ch, "Do you want to give '%d' or 'all'?  Make up your mind!\r\n", amount);
    return;
  }

  if (dotmode == FIND_INDIV) {
    for (i = 0; i < amount; ++i) {
      if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, name)))) {
        if (amount == 1)
          cprintf(ch, "You don't seem to have a %s.\r\n", name);
        else
          cprintf(ch, "You don't seem to have %d %ss.\r\n", amount, name);
        break;
      }
      obj = confused_inventory_switch(ch, obj);
      if (!ref_obj)
        ref_obj = obj;
      result = perform_give(ch, vict, obj, 1);
      if (result == GIVE_SUCCESS)
        ++counter;
      else if (result == GIVE_FAIL_FULL)
        break;
    }
  }
  else if (CONFUSED(ch)) {
    send_to_char("You are too confused for such juggling.\r\n", ch);
    return;
  } else {
    if (dotmode == FIND_ALLDOT && !*name) {
      send_to_char("All of what?\r\n", ch);
      return;
    }
    counter = 0;
    for (obj = ch->carrying; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (!CAN_SEE_OBJ(ch, obj))
        continue;
      if (dotmode == FIND_ALL || isname(name, obj->name)) {
        if (!ref_obj)
          ref_obj = obj;
        result = perform_give(ch, vict, obj, 1);
        if (result != GIVE_SUCCESS)
          break;
        ++counter;
      }
    }
  }

  if (counter == 0) {
    if (result == GIVE_FAIL_DONTHAVE) {
      if (dotmode == FIND_ALLDOT)
        cprintf(ch, "You don't even have one %s!\r\n", name);
      else if (dotmode == FIND_ALL)
        send_to_char("You don't seem to be holding anything.\r\n", ch);
    }
  }
  else if (counter == 1) {
    act("You give $p to $N.", FALSE, ch, ref_obj, vict, TO_CHAR);
    act("$n gives you $p.", FALSE, ch, ref_obj, vict, TO_VICT);
    act("$n gives $p to $N.", !HIGHLY_VISIBLE(ref_obj) || GET_INVIS_LEV(ch), ch, ref_obj, vict, TO_NOTVICT);
  }
  else if (counter > 1) {
    sprintf(buf, "You give $p to $N. (x%d)",counter);
    act(buf, FALSE, ch, ref_obj, vict, TO_CHAR);
    sprintf(buf, "$n gives you $p. (x%d)",counter);
    act(buf, FALSE, ch, ref_obj, vict, TO_VICT);
    act("$n gives $p to $N. (multiple)", !HIGHLY_VISIBLE(ref_obj) || GET_INVIS_LEV(ch), ch, ref_obj, vict, TO_NOTVICT);
  }
}

ACMD(do_drink)
{
  struct obj_data *temp;
  struct effect eff;
  int amount; /* ounces */
  int on_ground = 0;

  if (FIGHTING(ch)) {
    send_to_char("You are afraid to try in combat!\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Drink from what?\r\n", ch);
    return;
  }
  if (!(temp = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg)))) {
    if (!(temp = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg)))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    } else
      on_ground = 1;
  }
  if ((GET_OBJ_TYPE(temp) != ITEM_DRINKCON) &&
      (GET_OBJ_TYPE(temp) != ITEM_FOUNTAIN)) {
    send_to_char("You can't drink from that!\r\n", ch);
    return;
  }
  if (on_ground && (GET_OBJ_TYPE(temp) == ITEM_DRINKCON)) {
    send_to_char("You have to be holding that to drink from it.\r\n", ch);
    return;
  }
  if ((GET_COND(ch, DRUNK) > 10) && (GET_COND(ch, THIRST) > 0)) {
    /* The pig is drunk */
    send_to_char("You can't seem to get close enough to your mouth.\r\n", ch);
    act("$n tries to drink but misses $s mouth!", TRUE, ch, 0, 0, TO_ROOM);
    return;
  }
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 5)) {
    send_to_char("Your stomach can't contain any more!\r\n", ch);
    return;
  }
  if (GET_COND(ch, THIRST) > MAX_THIRST - HOURLY_THIRST_CHANGE) {
    send_to_char("You couldn't drink another drop!\r\n", ch);
    return;
  }

  if (!GET_OBJ_VAL(temp, VAL_DRINKCON_REMAINING)) {
    send_to_char("It's empty.\r\n", ch);
    return;
  }

  if (!consume_otrigger(temp, ch, SCMD_DRINK))
    return;

  if (subcmd == SCMD_DRINK) {
    sprintf(buf, "$n drinks %s from $p.", LIQ_NAME(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)));
    act(buf, TRUE, ch, temp, 0, TO_ROOM);

    sprintf(buf, "You drink the %s.\r\n", LIQ_NAME(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)));
    send_to_char(buf, ch);

    /* Let's say you normally drink 1/2 cup (a lot, but hey). */
    amount = 4;
  } else {
    act("$n sips from $p.", TRUE, ch, temp, 0, TO_ROOM);
    cprintf(ch, "It tastes like %s.\r\n", LIQ_NAME(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)));
    amount = 1;
  }

  amount = MIN(amount, GET_OBJ_VAL(temp, VAL_DRINKCON_REMAINING));

  /* You can't subtract more than the object weighs */
  liquid_from_container(temp, amount);

  gain_condition(ch, DRUNK,
                 (LIQ_COND(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID), DRUNK) * amount) / 4);

  gain_condition(ch, FULL,
                 (LIQ_COND(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID), FULL)* amount) / 1);

  gain_condition(ch, THIRST,
                 (LIQ_COND(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID), THIRST) * amount) / 1);

  if (GET_COND(ch, DRUNK) > 10)
    send_to_char("You feel drunk.\r\n", ch);

  if (GET_COND(ch, THIRST) > 20)
    send_to_char("You don't feel thirsty any more.\r\n", ch);

  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);

  if (IS_POISONED(temp)) {
    send_to_char("Oops, it tasted rather strange!\r\n", ch);
    act("$n chokes and utters some strange sounds.", TRUE, ch, 0, 0, TO_ROOM);

    memset(&eff, 0, sizeof(eff));
    eff.type = SPELL_POISON;
    eff.duration = amount * 3;
    eff.modifier = 0;
    eff.location = APPLY_NONE;
    SET_FLAG(eff.flags, EFF_POISON);
    effect_join(ch, &eff, FALSE, FALSE, FALSE, FALSE, TRUE);
  }

  /* This will restore movement points, such that drinking the max
   * would restore 100% or 200, whichever is lower. */
  alter_move(ch, - MIN(200, GET_MAX_MOVE(ch) * amount / MAX_THIRST));

  return;
}

ACMD(do_eat)
{
  struct obj_data *food;
  struct effect eff;
  int amount;

  if (FIGHTING(ch)) {
    send_to_char("You are afraid to try in combat!\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Eat what?\r\n", ch);
    return;
  }
  if (!(food = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg)))) {
    cprintf(ch, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    return;
  }
  if (subcmd == SCMD_TASTE && ((GET_OBJ_TYPE(food) == ITEM_DRINKCON) ||
                               (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN))) {
    do_drink(ch, argument, 0, SCMD_SIP);
    return;
  }
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && (GET_LEVEL(ch) < LVL_GOD)) {
    send_to_char("You can't eat THAT!\r\n", ch);
    return;
  }
  if (GET_COND(ch, FULL) > 20) {/* Stomach full */
    act("You are too full to eat more!", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }

  if (!consume_otrigger(food, ch, SCMD_EAT))
    return;

  if (subcmd == SCMD_EAT) {
    act("You eat the $o.", FALSE, ch, food, 0, TO_CHAR);
    act("$n eats $p.", TRUE, ch, food, 0, TO_ROOM);
  } else {
    act("You nibble a little bit of the $o.", FALSE, ch, food, 0, TO_CHAR);
    act("$n tastes a little bit of $p.", TRUE, ch, food, 0, TO_ROOM);
  }

  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, VAL_FOOD_FILLINGNESS) : 1);

  gain_condition(ch, FULL, amount);

  if (GET_COND(ch, FULL) > 20)
    act("You are full.", FALSE, ch, 0, 0, TO_CHAR);

  if (IS_POISONED(food) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    send_to_char("Oops, that tasted rather strange!\r\n", ch);
    act("$n coughs and utters some strange sounds.", FALSE, ch, 0, 0, TO_ROOM);

    memset(&eff, 0, sizeof(eff));
    eff.type = SPELL_POISON;
    eff.duration = amount * 2;
    eff.modifier = 0;
    eff.location = APPLY_NONE;
    SET_FLAG(eff.flags, EFF_POISON);
    effect_join(ch, &eff, FALSE, FALSE, FALSE, FALSE, TRUE);
  }
  /* This will restore hit points, such that a meal of size 24
   * would restore 33% or 70, whichever is lower. */
  hurt_char(ch, 0, - MIN(70, GET_MAX_HIT(ch) * amount / 72), TRUE);

  if (subcmd == SCMD_EAT)
    extract_obj(food);
  else {
    if (!(--GET_OBJ_VAL(food, VAL_FOOD_FILLINGNESS))) {
      send_to_char("There's nothing left now.\r\n", ch);
      extract_obj(food);
    }
  }
}

/* Object values for liquid containers and fountains:
 *
 *     GET_OBJ_VAL(from_obj, X)
 *
 * 0: max drink units
 * 1: current drink units
 * 2: liquid type
 * 3: poisoned (boolean)
 *
 * Liquid types (as of 2006 November 16):
 *
 *   0) water                  1) beer
 *   2) wine                   3) ale
 *   4) dark ale               5) whisky
 *   6) lemonade               7) firebreather
 *   8) local speciality       9) slime mold juice
 *   10) milk                  11) tea
 *   12) coffee                13) blood
 *   14) salt water            15) rum
 */

ACMD(do_pour)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *from_obj = NULL, *to_obj = NULL;
  int amount;

  if (FIGHTING(ch)) {
    send_to_char("You can't coordinate the maneuver while fighting!\r\n",ch);
    return;
  }
  two_arguments(argument, arg1, arg2);

  if (subcmd == SCMD_POUR) {
    if (!*arg1) {                /* No arguments */
      act("From what do you want to pour?", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1)))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_DRINKCON) {
      act("You can't pour from that!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  }
  if (subcmd == SCMD_FILL) {
    if (!*arg1) {                /* no arguments */
      send_to_char("What do you want to fill?  And what are you filling it from?\r\n", ch);
      return;
    }
    if (!(to_obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1)))) {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) {
      act("You can't fill $p!", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!*arg2) {                /* no 2nd argument */
      act("What do you want to fill $p from?", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg2)))) {
      sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN) {
      act("You can't fill something from $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      return;
    }
  }
  if (GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING) == 0) {
    act("The $o is empty.", FALSE, ch, from_obj, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR) {        /* pour */
    if (!*arg2) {
      act("Where do you want it?  Out or in what?", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if (!str_cmp(arg2, "out")) {
      act("$n empties $p.", FALSE, ch, from_obj, 0, TO_ROOM);
      act("You empty $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      liquid_from_container(from_obj, GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING));
      return;
    }
    if (!(to_obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg2)))) {
      act("You can't find it!", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    if ((GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) &&
        (GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN)) {
      act("You can't pour anything into that.", FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
  }
  if (to_obj == from_obj) {
    act("A most unproductive effort.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if ((GET_OBJ_VAL(to_obj, VAL_DRINKCON_REMAINING) != 0) &&
      (GET_OBJ_VAL(to_obj, VAL_DRINKCON_LIQUID) != GET_OBJ_VAL(from_obj, VAL_DRINKCON_LIQUID))) {
    act("There is already another liquid in it!", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (GET_OBJ_VAL(to_obj, VAL_DRINKCON_REMAINING) >= GET_OBJ_VAL(to_obj, VAL_DRINKCON_CAPACITY)) {
    act("There is no room for more.", FALSE, ch, 0, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR)
    cprintf(ch, "You pour the %s into the %s.\r\n",
            LIQ_NAME(GET_OBJ_VAL(from_obj, VAL_DRINKCON_LIQUID)), arg2);
  if (subcmd == SCMD_FILL) {
    act("You gently fill $p from $P.", FALSE, ch, to_obj, from_obj, TO_CHAR);
    act("$n gently fills $p from $P.", !HIGHLY_VISIBLE(to_obj) || GET_INVIS_LEV(ch), ch, to_obj, from_obj, TO_ROOM);
  }

  /* how much to pour */
  amount = MIN(GET_OBJ_VAL(to_obj, VAL_DRINKCON_CAPACITY) -
        GET_OBJ_VAL(to_obj, VAL_DRINKCON_REMAINING),
        GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING));

  liquid_to_container(to_obj, amount,
        GET_OBJ_VAL(from_obj, VAL_DRINKCON_LIQUID),
        IS_POISONED(from_obj));

  if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN) {
    liquid_from_container(from_obj, amount);
  }

  return;
}



void wear_message(struct char_data * ch, struct obj_data * obj, int where)
{
  char *wear_messages[][2] = {
    {"$n starts using $p as a light.",
     "You start using $p as a light."},

    {"$n slides $p onto $s right ring finger.",
     "You slide $p onto your right ring finger."},

    {"$n slides $p onto $s left ring finger.",
     "You slide $p onto your left ring finger."},

    {"$n wears $p around $s neck.",
     "You wear $p around your neck."},

    {"$n wears $p around $s neck.",
     "You wear $p around your neck."},

    {"$n wears $p on $s body.",
     "You wear $p on your body.",},

    {"$n wears $p on $s head.",
     "You wear $p on your head."},

    {"$n puts $p on $s legs.",
     "You put $p on your legs."},

    {"$n wears $p on $s feet.",
     "You wear $p on your feet."},

    {"$n puts $p on $s hands.",
     "You put $p on your hands."},

    {"$n wears $p on $s arms.",
     "You wear $p on your arms."},

    {"$n straps $p around $s arm as a shield.",
     "You start to use $p as a shield."},

    {"$n wears $p about $s body.",
     "You wear $p around your body."},

    {"$n wears $p around $s waist.",
     "You wear $p around your waist."},

    {"$n puts $p on $s right wrist.",
     "You put $p on your right wrist."},

    {"$n puts $p on $s left wrist.",
     "You put $p on your left wrist."},

    {"$n wields $p.",
     "You wield $p."},


    {"$n wields $p.",
     "You wield $p."},


    {"$n grabs $p.",
     "You grab $p."},


    {"$n grabs $p.",
     "You grab $p."},

    {"$n wields $p.",
     "You wield $p."},

    {"$n wears $p over $s eyes.",
     "You wear $p over your eyes."},

    {"$n wears $p on $s face.",
     "You wear $p on your face."},

    {"$n wears $p in $s left ear.",
     "You wear $p in your left ear."},

    {"$n wears $p in $s right ear.",
     "You wear $p in your right ear."},

    {"$n wears $p as a badge.",
     "You wear $p as a badge."},

    {"$n attaches $p to $s belt.",
     "You attach $p to your belt."}
  };

  act(wear_messages[where][0], TRUE, ch, obj, 0, TO_ROOM);
  act(wear_messages[where][1], FALSE, ch, obj, 0, TO_CHAR);
}



/* Returns TRUE if the object was worn. */

bool perform_wear(
      struct char_data * ch,   /* Who is trying to wear something */

      struct obj_data * obj,   /* The object being put on */

      int where,               /* The positioni it should be worn at */

      bool collective          /* Whether the character has issued a command like
                                  "wear all" or "wear all.leather".  This parameter
                                  will suppress the error message for objects that
                                  can't be worn. */
      )
{
   if (!may_wear_eq(ch, obj, &where, !collective))
      return FALSE;
   if (!wear_otrigger(obj, ch, where))
      return FALSE;
   wear_message(ch, obj, where);
   obj_from_char(obj);
   equip_char(ch, obj, where);
   return TRUE;
}



int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg)
{
  int where = -1;

  static const char *keywords[] = {
    "light",
    "finger",
    "!RESERVED!",
    "neck",
    "!RESERVED!",
    "body",
    "head",
    "legs",
    "feet",
    "hands",
    "arms",
    "shield",
    "about",
    "waist",
    "wrist",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "eyes",
    "face",
    "ear",
    "!RESERVED!",
    "badge",
    "belt",
    "\n"
  };

  if (!arg || !*arg) {
    /* Allow wearing of light objects in light pos.  Gets overridden
       by any other can wear flags below. - myc 5 Dec 2006 */
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)      where = WEAR_LIGHT;
    if (CAN_WEAR(obj, ITEM_WEAR_FINGER))      where = WEAR_FINGER_R;
    if (CAN_WEAR(obj, ITEM_WEAR_NECK))        where = WEAR_NECK_1;
    if (CAN_WEAR(obj, ITEM_WEAR_BODY))        where = WEAR_BODY;
    if (CAN_WEAR(obj, ITEM_WEAR_HEAD))        where = WEAR_HEAD;
    if (CAN_WEAR(obj, ITEM_WEAR_LEGS))        where = WEAR_LEGS;
    if (CAN_WEAR(obj, ITEM_WEAR_FEET))        where = WEAR_FEET;
    if (CAN_WEAR(obj, ITEM_WEAR_HANDS))       where = WEAR_HANDS;
    if (CAN_WEAR(obj, ITEM_WEAR_ARMS))        where = WEAR_ARMS;
    if (CAN_WEAR(obj, ITEM_WEAR_SHIELD))      where = WEAR_SHIELD;
    if (CAN_WEAR(obj, ITEM_WEAR_ABOUT))       where = WEAR_ABOUT;
    if (CAN_WEAR(obj, ITEM_WEAR_WAIST))       where = WEAR_WAIST;
    if (CAN_WEAR(obj, ITEM_WEAR_WRIST))       where = WEAR_WRIST_R;
    if (CAN_WEAR(obj, ITEM_WEAR_EYES))        where = WEAR_EYES;
    if (CAN_WEAR(obj, ITEM_WEAR_FACE))        where = WEAR_FACE;
    if (CAN_WEAR(obj, ITEM_WEAR_EAR))         where = WEAR_LEAR;
    if (CAN_WEAR(obj, ITEM_WEAR_BADGE))       where = WEAR_BADGE;
    if (CAN_WEAR(obj, ITEM_WEAR_OBELT))       where = WEAR_OBELT;
    /* Add Wield and 2 Handed Wield to this search block - DE 8/13/99 */
    if (CAN_WEAR(obj, ITEM_WEAR_WIELD))              where = WEAR_WIELD;
    if (CAN_WEAR(obj, ITEM_WEAR_2HWIELD))     where = WEAR_2HWIELD;
  } else {
    /* 2/6/02 - DCE Put in a check for !. Players could wear item !,
       and it would put the item in the light position. */
    if (!strcmp(arg, "!") || (where = search_block(arg, keywords, FALSE)) < 0) {
      sprintf(buf, "'%s'?  What part of your body is THAT?\r\n", arg);
      send_to_char(buf, ch);
    }
  }

  return where;
}

ACMD(do_wear)
{
  char argbuf1[MAX_INPUT_LENGTH], *arg1 = argbuf1;
  char argbuf2[MAX_INPUT_LENGTH], *arg2 = argbuf2;
  struct obj_data *obj, *next_obj;
  int where, dotmode, wearable_items = 0, worn_items = 0;

  two_arguments(argument, arg1, arg2);

  if (GET_RACE(ch) == RACE_ANIMAL) {
    return;
  }

  if (!*arg1) {
    send_to_char("Wear what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(&arg1);

  if (*arg2 && (dotmode != FIND_INDIV)) {
    send_to_char("You can't specify the same body location for more than one item!\r\n", ch);
    return;
  }
  if (dotmode == FIND_ALL) {
    if (CONFUSED(ch)) {
      send_to_char("You're a bit too confused for mass equipment changes.\r\n", ch);
      return;
    }
    for (obj = ch->carrying; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) && (where = find_eq_pos(ch, obj, 0)) >= 0) {
        wearable_items++;
        if (perform_wear(ch, obj, where, TRUE)) worn_items++;
      }
    }
    if (!wearable_items || !worn_items)
      send_to_char("You don't have anything you can wear.\r\n", ch);
  }

  else if (dotmode == FIND_ALLDOT) {
    if (!*arg1) {
      send_to_char("Wear all of what?\r\n", ch);
      return;
    }
    if (CONFUSED(ch)) {
      send_to_char("You're a bit too confused for mass equipment changes.\r\n", ch);
      return;
    }
    if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1))))
      cprintf(ch, "You don't seem to have any %s%s.\r\n", arg1,
           isplural(arg1) ? "" : "s");
    else {
      while (obj) {
        next_obj = find_obj_in_list(obj->next_content, find_vis_by_name(ch, arg1));
        if ((where = find_eq_pos(ch, obj, 0)) >= 0) {
          if (perform_wear(ch, obj, where, TRUE)) worn_items++;
        }
        obj = next_obj;
      }
      if (!worn_items)
        send_to_char("You don't have anything wearable like that.\r\n", ch);
    }
  }

  /* FIND_INDIV */
  else {
    if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg1)))) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg1), arg1);
      send_to_char(buf, ch);
      return;
    }
    obj = confused_inventory_switch(ch, obj);
    if ((where = find_eq_pos(ch, obj, arg2)) >= 0)
      perform_wear(ch, obj, where, FALSE);
    else if (!*arg2)
      act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
  }
}

ACMD(do_wield) {
   struct obj_data *obj;
   int hands_used, weapon_hands_used;

   one_argument(argument, arg);

   /* Basic checks first */

   if (GET_RACE(ch) == RACE_ANIMAL)
      return;

   if (!*arg) {
      send_to_char("Wield what?\r\n", ch);
      return;
   }

   if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg)))) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
      return;
   }

   if (!CAN_WEAR(obj, ITEM_WEAR_WIELD) && !CAN_WEAR(obj, ITEM_WEAR_2HWIELD)) {
      send_to_char("You can't wield that.\r\n", ch);
      return;
   }

   if (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w) {
      send_to_char("It's too heavy for you to use.\r\n", ch);
      return;
   }

   /* By now we know it's a weapon that can be wielded by this char
    * under some circumstances, at least. So check for free hands,
    * dual wielding, and two-handed weapon. */

   count_hand_eq(ch, &hands_used, &weapon_hands_used);

   /* Both hands used? Bye. */
   if (hands_used > 1) {
      send_to_char("Your hands are full!\r\n", ch);
      return;
   }

   /* See if they need both hands free: two-handed weapon and they aren't an ogre. */
   if (CAN_WEAR(obj, ITEM_WEAR_2HWIELD) && GET_CLASS(ch) != RACE_OGRE) {
      if (hands_used) {
         send_to_char("You need both hands for this weapon.\r\n", ch);
         return;
      }
      perform_wear(ch, obj, WEAR_2HWIELD, FALSE);
      return;
   }

   /* This weapon can be wielded one-handed, and ch has at least one hand free. */
   if (weapon_hands_used) {
      /* One weapon is already wielded. Got dual wield? */
      if GET_SKILL(ch, SKILL_DUAL_WIELD) {
         obj = confused_inventory_switch(ch, obj);
         perform_wear(ch, obj, WEAR_WIELD2, FALSE);
      } else
         send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
   } else {
      obj = confused_inventory_switch(ch, obj);
      perform_wear(ch, obj, WEAR_WIELD, FALSE);
   }
}



static MATCH_OBJ_FUNC(match_light_by_name)
{
  if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
    if (isname(context->string, obj->name))
      if (--context->number <= 0)
        return TRUE;
  return FALSE;
}


ACMD(do_light)
{
   struct obj_data *obj;
   struct find_context find_darklights;

   one_argument(argument, arg);

   if (!*arg) {
      if (subcmd == SCMD_EXTINGUISH)
         send_to_char("Extinguish what?\r\n", ch);
      else
         send_to_char("Light what?\r\n", ch);
      return;
   }

   /* Lights are searched for:
    * - worn (visible or not)
    * - in inventory (visible first)
    * - in inventory (not visible - allows you to turn on lights in an dark room)
    */

   find_darklights = find_by_name(arg);
   find_darklights.obj_func = match_light_by_name;

   if (!(obj = (find_obj_in_eq(ch, NULL, find_darklights))) &&
         !(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg))) &&
         !(obj = find_obj_in_list(ch->carrying, find_darklights))) {
      cprintf(ch, "You don't seem to have %s %s.\r\n", AN(arg), arg);
      return;
   }

   obj = confused_inventory_switch(ch, obj);

   if (GET_OBJ_TYPE(obj) != ITEM_LIGHT) {
      if (subcmd == SCMD_EXTINGUISH)
         send_to_char("You can't extinguish that!\r\n", ch);
      else
         send_to_char("You can't light that!\r\n", ch);
      return;
   }

   if (!GET_OBJ_VAL(obj, VAL_LIGHT_LIT)) {   /* It is not lit */

      if (subcmd == SCMD_EXTINGUISH) {
         send_to_char("It isn't lit.\r\n", ch);
         return;
      }

      if (GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) != 0) {  /* It is not worn out */
         if (GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) < 0) {  /* It's a permanent light */
            act("You activate $p.", TRUE, ch, obj, 0, TO_CHAR);
            act("$n activates $p.", TRUE, ch, obj, 0, TO_ROOM);
         } else {
            act("You light $p.", TRUE, ch, obj, 0, TO_CHAR);
            act("$n lights $p.", TRUE, ch, obj, 0, TO_ROOM);
         }
         GET_OBJ_VAL(obj, VAL_LIGHT_LIT) = TRUE;  /* Now it's lit */
         if (ch->in_room != NOWHERE)
            world[ch->in_room].light++;
         else
            log("SYSERR: do_light - my char_data* object wasn't in a room!");
      } else
         act("Sorry, there's no more power left in $p.", TRUE, ch,  obj, 0, TO_CHAR);
   } else {
      /* It was already lit, so we are extinguishing it */
      if (GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) < 0) {  /* It's a permanent light */
         act("You deactivate $p.", TRUE, ch, obj, 0, TO_CHAR);
         act("$n deactivates $p.", TRUE, ch, obj, 0, TO_ROOM);
      } else {
         act("You extinguish $p.", TRUE, ch, obj, 0, TO_CHAR);
         act("$n extinguishes $p.", TRUE, ch, obj, 0, TO_ROOM);
      }
      GET_OBJ_VAL(obj, VAL_LIGHT_LIT) = FALSE;
      if (GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) != 0) {
         if (ch->in_room != NOWHERE)
            world[ch->in_room].light--;
         else
            log("SYSERR: do_light (extinguishing) - my char_data* object wasn't in a room!");
      }
   }
}

ACMD(do_grab)
{
  struct obj_data *obj;
  struct find_context find_darklights;

  one_argument(argument, arg);

  find_darklights = find_by_name(arg);
  find_darklights.obj_func = match_light_by_name;

  if (!*arg)
    send_to_char("Hold what?\r\n", ch);
  else if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg))) &&
           !(obj = find_obj_in_list(ch->carrying, find_darklights)))
    cprintf(ch, "You don't seem to have %s %s.\r\n", AN(arg), arg);
  else {
    obj = confused_inventory_switch(ch, obj);
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      perform_wear(ch, obj, WEAR_HOLD, FALSE);
    else {
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && GET_OBJ_TYPE(obj) != ITEM_WAND &&
          GET_OBJ_TYPE(obj) != ITEM_STAFF && GET_OBJ_TYPE(obj) != ITEM_SCROLL &&
          GET_OBJ_TYPE(obj) != ITEM_POTION)
        send_to_char("You can't hold that.\r\n", ch);
      else {
        perform_wear(ch, obj, WEAR_HOLD, FALSE);
      }
    }
  }
}

void perform_remove(struct char_data * ch, int pos)
{
  struct obj_data *obj;

  if (!(obj = GET_EQ(ch, pos))) {
    log("Error in perform_remove: bad pos passed.");
    return;
  }
  if (!remove_otrigger(obj, ch))
    return;
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
    act("$p: you can't carry that many items!", FALSE, ch, obj, 0, TO_CHAR);
  else {
    obj_to_char(unequip_char(ch, pos), ch);
    act("You stop using $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n stops using $p.", TRUE, ch, obj, 0, TO_ROOM);
  }
}

ACMD(do_remove)
{
  struct obj_data *obj;
  int where, dotmode, found;
  char *name = arg;

  argument = one_argument(argument, name);

  if (!*name) {
    send_to_char("Remove what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(&name);

  if (dotmode == FIND_ALL) {
    found = 0;
    for (where = 0; where < NUM_WEARS; ++where)
      if (GET_EQ(ch, where)) {
        perform_remove(ch, where);
        found = 1;
      }
    if (!found)
      send_to_char("You're not using anything.\r\n", ch);
  }

  else if (dotmode == FIND_ALLDOT) {
    if (!*name)
      send_to_char("Remove all of what?\r\n", ch);
    else {
      found = 0;
      for (where = 0; where < NUM_WEARS; ++where)
        if (GET_EQ(ch, where) && isname(name, GET_EQ(ch, where)->name)) {
          perform_remove(ch, where);
          found = 1;
        }
      if (!found)
        cprintf(ch, "You don't seem to be using any %s%s.\r\n", name,
                isplural(name) ? "" : "s");
    }
  }

  else if (is_number(name) &&
           universal_find(find_vis_by_type(ch, ITEM_BOARD),
                          FIND_OBJ_EQUIP | FIND_OBJ_ROOM | FIND_OBJ_WORLD,
                          NULL, &obj) && obj)
    remove_message(ch, board(GET_OBJ_VAL(obj, VAL_BOARD_NUMBER)), atoi(name), obj);
  else if (is_number(argument) &&
           generic_find(name, FIND_OBJ_EQUIP | FIND_OBJ_ROOM | FIND_OBJ_WORLD,
                        ch, NULL, &obj) && obj && GET_OBJ_TYPE(obj) == ITEM_BOARD)
    remove_message(ch, board(GET_OBJ_VAL(obj, VAL_BOARD_NUMBER)), atoi(argument), obj);
  else if (!(obj = (find_obj_in_eq(ch, &where, find_vis_by_name(ch, name)))))
    cprintf(ch, "You don't seem to be using %s %s.\r\n", AN(name), name);
  else
    perform_remove(ch, where);

  /*
   * If the first weapon was removed but there is still a secondary
   * weapon, then move it to the first position.
   */
  if (GET_EQ(ch, WEAR_WIELD2) && !GET_EQ(ch, WEAR_WIELD))
    equip_char(ch, unequip_char(ch, WEAR_WIELD2), WEAR_WIELD);

  /*
   * If the character is wearing something on their belt, but is no
   * longer wearing a belt, remove the thing on their belt.
   */
  if (GET_EQ(ch, WEAR_OBELT) && !GET_EQ(ch, WEAR_WAIST)) {
    act("$p falls off as you remove your belt.", FALSE, ch, GET_EQ(ch, WEAR_OBELT), 0, TO_CHAR);
    act("$p falls off as $n removes $s belt.", TRUE, ch, GET_EQ(ch, WEAR_OBELT), 0, TO_ROOM);
    obj_to_char(unequip_char(ch, WEAR_OBELT), ch);
  }
}



bool check_get_disarmed_obj(struct char_data *ch, struct char_data *last_to_hold, struct obj_data *obj)
{
  int rand;
  struct char_data *tmp_ch;
  bool retval = FALSE;
  char Gbuf4[MAX_STRING_LENGTH];
  int cmd_say, cmd_glare, cmd_bash;
  cmd_say = find_command("say");
  cmd_glare = find_command("glare");
  cmd_bash = find_command("bash");


   if (OBJ_FLAGGED(obj, ITEM_WAS_DISARMED)) {
       /* make sure owner isn't dead, or has left room. either case means */
       /* he doesn't care about his item(s) any longer */
      LOOP_THRU_PEOPLE(tmp_ch, ch)
         if (tmp_ch != ch && tmp_ch == last_to_hold)
            break;

      if (tmp_ch && AWAKE(tmp_ch)) {
         if (!IS_NPC(last_to_hold) && CONSENT(last_to_hold) == ch) {
            act("$n nods briefly as $N reaches for $p.", TRUE, last_to_hold, obj, ch, TO_NOTVICT);
            act("You nod briefly as $N reaches for $p.", FALSE, last_to_hold, obj, ch, TO_CHAR);
            act("$n nods briefly as you reach for $p.", TRUE, last_to_hold, obj, ch, TO_VICT);
         } else if (GET_LEVEL(ch) >= LVL_IMMORT && GET_LEVEL(ch) >= GET_LEVEL(last_to_hold)) {
            /* nothing */
         } else if (number(1, 64) > 8) {        /* darn, PC failed to grab it. now they pay. */
            rand = number(1, 4);

            if (rand == 1) {
               act("$n makes a quick grab for $p!", FALSE, ch, obj, 0, TO_ROOM);
               act("You lunge for $p!", FALSE, ch, obj, 0, TO_CHAR);

               act("$N tries to block $n, but isn't quick enough.", FALSE, ch, 0, last_to_hold, TO_NOTVICT);
               act("You try to block $N, but $E's too fast.", FALSE, last_to_hold, 0, ch, TO_CHAR);
               act("$N tries to block you, but is far too slow.", FALSE, ch, 0, last_to_hold, TO_CHAR);
            } else {
               act("$n tries to grab $p!", FALSE, ch, obj, 0, TO_ROOM);

               strcpy(Gbuf4, "No you don't!! That belongs to me!");
               do_say(last_to_hold, Gbuf4, cmd_say, 0);
               strcpy(Gbuf4, GET_NAME(ch));
               do_action(last_to_hold, Gbuf4, cmd_glare, 0);

               act("$N plants $Mself directly in front of $n, blocking $m.",
                     FALSE, ch, 0, last_to_hold, TO_NOTVICT);
               act("You plant yourself directly in front of $N, blocking $M.",
                     FALSE, last_to_hold, 0, ch, TO_CHAR);
               act("$N steps directly in front of your path.  No way to get it now.",
                     FALSE, ch, 0, last_to_hold, TO_CHAR);
               retval = TRUE;

               /* Delay them so they can't spam grab attempts and bypass this
                * too easily */
               WAIT_STATE(ch, PULSE_VIOLENCE + 1);
            }
         }
      }
   }

   if (!retval)
      REMOVE_FLAG(GET_OBJ_FLAGS(obj), ITEM_WAS_DISARMED);

   return retval;
}


ACMD(do_conceal)
{
  struct obj_data *obj;
  struct char_data *tch;
  extern void appear(struct char_data *ch);

  one_argument(argument, arg);
  if (CONFUSED(ch)) {
     send_to_char("You're too confused to hide things.\r\n", ch);
     return;
  }

  if (!GET_SKILL(ch, SKILL_CONCEAL))
    send_to_char("You aren't skilled enough to conceal an item.\r\n", ch);
  else if (!*arg)
    send_to_char("What do you want to conceal?\r\n", ch);
  else if (!str_cmp(arg, "all") || !strn_cmp(arg, "all.", 4))
    send_to_char("You can't conceal multiple items at once.\r\n", ch);
  else if (ch->in_room == NOWHERE || !(obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg))))
    send_to_char("You don't see that here.\r\n", ch);
  else if (!CAN_WEAR(obj, ITEM_WEAR_TAKE) && GET_LEVEL(ch) < LVL_IMMORT) {
    act("You can't seem to shift $p's position.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n tugs at $p, unable to move it.", TRUE, ch, obj, 0, TO_ROOM);
  }
  else if (GET_OBJ_WEIGHT(obj) > MAX_CONCEAL_WEIGHT && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You can't hide something that large!\r\n", ch);
    act("$n drags $p around, trying to conceal it, but it's just too large.", TRUE, ch, obj, 0, TO_ROOM);
  }
  else if (IS_WATER(IN_ROOM(ch)) && GET_LEVEL(ch) < LVL_IMMORT)
    send_to_char("There's nowhere to hide it!\r\n", ch);
  else if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, VAL_LIGHT_LIT))
    act("You should probably $T the $o before attempting to conceal it.",
        FALSE, ch, obj, GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) == LIGHT_PERMANENT ?
        "deactivate" : "extinguish", TO_CHAR);
  else if (check_get_disarmed_obj(ch, obj->last_to_hold, obj))
    act("You won't be able to conceal $N's $p!", FALSE, ch, obj, obj->last_to_hold, TO_CHAR);
  else {
    int roll = conceal_roll(ch, obj);

    if (roll) {
      if (GET_OBJ_HIDDENNESS(obj)) {
        if (IS_FOREST(ch->in_room))
          act("You try to conceal $p under another bush.", FALSE, ch, obj, 0, TO_CHAR);
        else if (CH_OUTSIDE(ch))
          act("You surreptitiously move $p to another hiding spot.", FALSE, ch, obj, 0, TO_CHAR);
        else
          act("You furtively switch $p's hiding spot.", FALSE, ch, obj, 0, TO_CHAR);
      }
      else {
        if (IS_FOREST(ch->in_room))
          act("You steathily conceal $p under some bushes.", FALSE, ch, obj, 0, TO_CHAR);
        else if (CH_OUTSIDE(ch))
          act("You surreptitiously cover up $p.", FALSE, ch, obj, 0, TO_CHAR);
        else
          act("You furtively conceal $p in a corner.", FALSE, ch, obj, 0, TO_CHAR);
      }
      LOOP_THRU_PEOPLE(tch, ch) {
        if (tch == ch)
          continue;
        if (!CAN_SEE(tch, ch))
          continue;
        if (CAN_SEE(ch, tch) ?
            (GET_PERCEPTION(tch) < roll - 50 + number(0, 50)) :
            (GET_PERCEPTION(tch) < roll / 2))
          continue;
        if (GET_OBJ_HIDDENNESS(obj))
          act("You notice $n trying to move $p!", FALSE, ch, obj, tch, TO_VICT);
        else
          act("You spot $n concealing $p!", FALSE, ch, obj, tch, TO_VICT);
      }
      GET_OBJ_HIDDENNESS(obj) = roll;
      obj->last_to_hold = ch;
    }

    /* Failure. orz */
    else {
      if (number(0, 100) <= 30) {
        if (EFF_FLAGGED(ch, EFF_INVISIBLE))
          appear(ch);
        else if (IS_HIDDEN(ch))
          GET_HIDDENNESS(ch) = MAX(0, GET_HIDDENNESS(ch) - 100);
      }
      if (IS_FOREST(ch->in_room)) {
        act("You drag $p under some bushes, but they don't quite cover it.", FALSE, ch, obj, 0, TO_CHAR);
        act("$n tries to hide $p under some bushes, but they don't quite cover it.", TRUE, ch, obj, 0, TO_ROOM);
      }
      else {
        act("You try to conceal $p, but can't find a good spot.", FALSE, ch, obj, 0, TO_CHAR);
        act("$n clumsily tries to conceal $p, botching the attempt.", TRUE, ch, obj, 0, TO_ROOM);
      }
    }
    improve_skill(ch, SKILL_CONCEAL);
    WAIT_STATE(ch, PULSE_VIOLENCE);
  }
}

ACMD(do_touch)
{
   struct obj_data *obj;

   one_argument(argument, arg);

   if (!*arg)
      send_to_char("Touch what?\r\n", ch);
   else if (!str_cmp(arg, "all") || !strn_cmp(arg, "all.", 4))
      send_to_char("One at a time...\r\n", ch);
   else if (ch->in_room == NOWHERE ||
            !(obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg))))
      send_to_char("You don't see that here.\r\n", ch);
   else {
      act("$n touches $p.", TRUE, ch, obj, 0, TO_ROOM);
      if (GET_OBJ_TYPE(obj) == ITEM_TOUCHSTONE && !IS_NPC(ch)) {
         act("As you touch $p, you feel a magical link form.", FALSE, ch, obj, 0, TO_CHAR);
         GET_HOMEROOM(ch) = world[ch->in_room].vnum;
      } else {
         act("You touch $p.  Nothing happens.", FALSE, ch, obj, 0, TO_CHAR);
      }
   }
}


#define SWAP(a,b)        { temp = a; a = b; b = temp; }
ACMD(do_compare)
{
  struct obj_data *obj1, *obj2, *temp;

  two_arguments(argument, buf1, buf2);

  if (!*buf1 || !*buf2)
    send_to_char("Compare what?\r\n", ch);
  else if (!str_cmp(buf1, "all") || !strn_cmp(buf1, "all.", 4) ||
           !str_cmp(buf2, "all") || !strn_cmp(buf2, "all.", 4))
    send_to_char("You can only compare two items at a time!\r\n", ch);
  else if (!(obj1 = find_obj_in_list(ch->carrying, find_vis_by_name(ch, buf1))))
    cprintf(ch, "You don't have a %s.\r\n", buf1);
  else if (!(obj2 = find_obj_in_list(ch->carrying, find_vis_by_name(ch, buf2))))
    cprintf(ch, "You don't have a %s.\r\n", buf2);
  else if (obj1 == obj2)
    send_to_char("They're the same item!\r\n", ch);
  else if (GET_OBJ_TYPE(obj1) != GET_OBJ_TYPE(obj2))
    act("The $o and $O have nothing in common.", FALSE, ch, obj1, obj2, TO_CHAR);
  else switch (GET_OBJ_TYPE(obj1)) {
    case ITEM_LIGHT:
      if (GET_OBJ_VAL(obj1, VAL_LIGHT_REMAINING) == LIGHT_PERMANENT ||
          GET_OBJ_VAL(obj2, VAL_LIGHT_REMAINING) == LIGHT_PERMANENT)
        send_to_char("You can't tell much about the two items.\r\n", ch);
      else if (GET_OBJ_VAL(obj1, VAL_LIGHT_REMAINING) == GET_OBJ_VAL(obj2, VAL_LIGHT_REMAINING))
        send_to_char("They look to have the same amount of fuel.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj1, VAL_LIGHT_REMAINING) < GET_OBJ_VAL(obj2, VAL_LIGHT_REMAINING))
          SWAP(obj1, obj2);
        act("$p looks to have more fuel than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_WEAPON:
      if ((IS_WEAPON_SLASHING(obj1) && !IS_WEAPON_SLASHING(obj2)) ||
          (IS_WEAPON_PIERCING(obj1) && !IS_WEAPON_PIERCING(obj2)) ||
          (IS_WEAPON_CRUSHING(obj1) && !IS_WEAPON_CRUSHING(obj2)))
        send_to_char("These weapons are too different to realistically compare them!\r\n", ch);
      else if (WEAPON_AVERAGE(obj1) == WEAPON_AVERAGE(obj2))
        send_to_char("They each look about as dangerous as the other.\r\n", ch);
      else {
        if (WEAPON_AVERAGE(obj1) < WEAPON_AVERAGE(obj2))
          SWAP(obj1, obj2);
        act("$p looks more dangerous than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      if (!EFF_FLAGGED(ch, EFF_DETECT_MAGIC))
        send_to_char("You can't tell anything about either item.\r\n", ch);
      else if (GET_OBJ_VAL(obj1, VAL_WAND_CHARGES_LEFT) == GET_OBJ_VAL(obj2, VAL_WAND_CHARGES_LEFT))
        send_to_char("They seem to each hold equal power.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj1, VAL_WAND_CHARGES_LEFT) < GET_OBJ_VAL(obj2, VAL_WAND_CHARGES_LEFT))
          SWAP(obj1, obj2);
        act("$p seems to have more charges than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_TREASURE:
    case ITEM_MONEY:
      if (GET_OBJ_COST(obj1) == GET_OBJ_COST(obj2))
        send_to_char("They look equally valuable.\r\n", ch);
      else {
        if (GET_OBJ_COST(obj1) < GET_OBJ_COST(obj2))
          SWAP(obj1, obj2);
        act("$p looks more valuable than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_ARMOR:
      if (GET_OBJ_VAL(obj1, VAL_ARMOR_AC) == GET_OBJ_VAL(obj2, VAL_ARMOR_AC))
        send_to_char("They look like they offer similar protection.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj1, VAL_ARMOR_AC) < GET_OBJ_VAL(obj2, VAL_ARMOR_AC))
          SWAP(obj1, obj2);
        act("$p looks more protective than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_CONTAINER:
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      if (GET_OBJ_VAL(obj1, VAL_CONTAINER_CAPACITY) == GET_OBJ_VAL(obj2, VAL_CONTAINER_CAPACITY))
        send_to_char("They appear to be very similar in size.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj1, VAL_CONTAINER_CAPACITY) < GET_OBJ_VAL(obj2, VAL_CONTAINER_CAPACITY))
          SWAP(obj1, obj2);
        act("$p looks larger than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_FOOD:
      if (GET_OBJ_VAL(obj1, VAL_FOOD_FILLINGNESS) == GET_OBJ_VAL(obj2, VAL_FOOD_FILLINGNESS))
        send_to_char("They look equally filling.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj1, VAL_FOOD_FILLINGNESS) < GET_OBJ_VAL(obj2, VAL_FOOD_FILLINGNESS))
          SWAP(obj1, obj2);
        act("$p looks more filling than $P.", FALSE, ch, obj1, obj2, TO_CHAR);
      }
      break;
    case ITEM_WORN:
    case ITEM_SCROLL:
    case ITEM_POTION:
    case ITEM_OTHER:
    case ITEM_TRASH:
    case ITEM_TRAP:
    case ITEM_NOTE:
    case ITEM_KEY:
    case ITEM_PEN:
    case ITEM_BOAT:
    case ITEM_PORTAL:
    case ITEM_ROPE:
    case ITEM_SPELLBOOK:
    case ITEM_WALL:
    case ITEM_FIREWEAPON:
    case ITEM_TOUCHSTONE:
    default:
      send_to_char("You can't decide which is better.\r\n", ch);
      break;
  }
}

/***************************************************************************
 * $Log: act.item.c,v $
 * Revision 1.169  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.168  2009/03/19 23:16:23  myc
 * Moved the get command and its kids from here to act.get.c.
 *
 * Revision 1.167  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.166  2009/03/15 07:09:24  jps
 * Add !FALL flag for objects
 *
 * Revision 1.165  2009/03/09 21:43:50  myc
 * Make get_check_money use statemoney.
 *
 * Revision 1.164  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 * Overhauled do_drop to work with dropping multiple types of
 * coins at once.  Also now supports dropping multiple objects
 * at once.
 *
 * Revision 1.163  2009/03/09 05:41:31  jps
 * Moved money stuff into money.h, money.c
 *
 * Revision 1.162  2009/03/09 02:22:32  myc
 * Added functionality for removing messages from the new boards
 * to the remove command.
 *
 * Revision 1.161  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.160  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.159  2009/01/16 23:36:34  myc
 * Fix possible use of uninitialized variable in do_palm().
 *
 * Revision 1.158  2008/09/29 03:24:44  jps
 * Make container weight automatic. Move some liquid container functions to objects.c.
 *
 * Revision 1.157  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.156  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.155  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.154  2008/09/07 01:29:12  jps
 * You can't be given enough weight to make you fall from flying.
 *
 * Revision 1.153  2008/09/03 17:34:08  myc
 * Moved liquid information into a def struct array.
 *
 * Revision 1.152  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.151  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.150  2008/08/31 01:19:54  jps
 * You screwed up holding items in slots with two of the same position!
 * Fix.
 *
 * Revision 1.149  2008/08/30 22:02:42  myc
 * Actions affecting corpses just go to the syslog now, not the RIP log.
 *
 * Revision 1.148  2008/08/30 21:55:50  myc
 * Players retrieving items from their corpse won't be logged to the RIP
 * log anymore.
 *
 * Revision 1.147  2008/08/30 20:51:38  jps
 * Fix wearing bug.
 *
 * Revision 1.146  2008/08/30 20:25:38  jps
 * Moved count_hand_eq() into handler.c and mentioned it in handler.h.
 *
 * Revision 1.145  2008/08/30 20:21:07  jps
 * Moved equipment-wearability checks into function may_wear_eq() and moved
 * it to handler.c.
 *
 * Revision 1.144  2008/08/30 18:20:53  myc
 * Changed rnum check for an object to use NOTHING constant.
 *
 * Revision 1.143  2008/08/19 02:11:14  jps
 * Don't apply fluid/rigidity restrictions to immortals.
 *
 * Revision 1.142  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.141  2008/08/15 18:18:24  jps
 * Don't exempt immortals from the need to wear a belt before wearing
 * an item on the belt.
 *
 * Revision 1.140  2008/07/27 05:14:02  jps
 * Changed the name of SAVE_CRASH to SAVE_AUTO.
 *
 * Revision 1.139  2008/07/21 19:28:35  jps
 * Add Oxford comma to coin list.
 *
 * Revision 1.138  2008/07/10 20:11:36  myc
 * Crash bug: can't move stuff directly between equipment positions!  Must
 * use equip_char/unequip_char.  In do_remove...was causing a crash at
 * rent-time.
 *
 * Revision 1.137  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.136  2008/06/05 02:07:43  myc
 * Changing object flags to use flagvectors.  Rewrote rent-saving code
 * to use ascii-format files.
 *
 * Revision 1.135  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.134  2008/05/14 05:10:28  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.133  2008/05/11 05:42:46  jps
 * Using regen.h. alter_hit() now takes the attacker.
 *
 * Revision 1.132  2008/04/13 21:57:17  jps
 * Made it more difficult to manipulate objects when confused.
 * You usually can't do "all.", and you will frequently fumble
 * and choose the wrong object. You can't conceal or stow.
 * Moved do_doorbash to act.movement.c
 *
 * Revision 1.131  2008/04/13 10:03:27  jps
 * Don't send the message about object becoming solid again when
 * you're junking it.
 *
 * Revision 1.130  2008/04/13 01:53:46  jps
 * Fix error message when you failed to give when using "all." or "all".
 *
 * Revision 1.129  2008/04/08 02:13:48  jps
 * Oops couldn't get objects out of containers.
 *
 * Revision 1.128  2008/04/06 19:47:00  jps
 * Use perform_drop when things fall because you gave them to fluid
 * people.  Thus drop triggers will run.
 *
 * Revision 1.127  2008/04/04 03:42:57  jps
 * Add call to give_shopkeeper_reject().  Also allow passing objects
 * between two fluid creatures.
 *
 * Revision 1.126  2008/04/03 02:05:34  myc
 * Depending on screen.h now.
 *
 * Revision 1.125  2008/04/02 05:36:19  myc
 * Added the autosplit toggle, which causes players to automatically
 * split the coins they pick up from corpses.
 *
 * Revision 1.124  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.123  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.122  2008/03/26 23:31:34  jps
 * Prevent handling of objects when in a fluid state.  If you drop
 * something, it becomes solid, and you can't pick it up again.
 *
 * Revision 1.121  2008/03/21 22:52:52  jps
 * Reset TRANSIENT objects' timers when they are placed in a room,
 * not when they are picked up.  Prior to this, TRANSIENT objects
 * would tend to dissolve in under an hour if not picked up, which
 * was really too short.
 *
 * Revision 1.120  2008/03/19 04:32:14  myc
 * Fixed capitalization in a message in do_palm.
 *
 * Revision 1.119  2008/03/10 20:46:55  myc
 * Renamed hometown to homeroom and using GET_HOME macro.
 *
 * Revision 1.118  2008/03/09 18:11:17  jps
 * perform_move may be misdirected now.
 *
 * Revision 1.117  2008/03/05 03:03:54  myc
 * Removed defunct do_home command.  (This functionality is available via
 * do_goto).
 *
 * Revision 1.116  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.115  2008/02/02 04:27:55  myc
 * Making get object trigger go off before illusory mob check.
 * Adding consume object trigger.
 *
 * Revision 1.114  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.113  2008/01/28 05:16:11  jps
 * Suppress can't-wear messages for individual items when you say
 * "wear all" or "wear all.foo".
 *
 * Revision 1.112  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.111  2008/01/27 01:42:03  jps
 * Fix grammar when informing player of cursed objects.
 *
 * Revision 1.110  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.109  2008/01/26 12:29:44  jps
 * Use skills.h to import improve_skill().
 *
 * Revision 1.108  2008/01/22 22:29:25  myc
 * Refined perform_wear.  Only allow wearing an item 'on belt' if actually
 * wearing a belt.  If the belt is removed, any item 'on belt' falls off.
 *
 * Revision 1.107  2008/01/15 03:21:11  myc
 * Rewrote give command so it always gives feedback.  Also made REMOVE
 * triggers not prevent immortals from removing items.
 *
 * Revision 1.106  2008/01/13 23:06:04  myc
 * Took out a redundant check in can_take_obj.
 *
 * Revision 1.105  2008/01/11 02:04:32  myc
 * Moved do_drag to act.movement.c
 *
 * Revision 1.104  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.103  2008/01/09 10:11:56  jps
 * Jacked up the drink-mv restoration to 100% for drinking 24 units.
 *
 * Revision 1.102  2008/01/09 07:41:32  jps
 * Give proper feedback for "give all <vict>", similar to "give all.foo <vict>"
 *
 * Revision 1.101  2008/01/07 11:57:31  jps
 * Fix output for failure to give things to illusions.
 *
 * Revision 1.100  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.99  2008/01/06 05:31:35  jps
 * Macro NOWEAR_CLASS for item flags that stop you from wearing equipment.
 *
 * Revision 1.98  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.97  2007/12/21 07:51:43  myc
 * Give command now gives feedback for 'give all.item person' when you
 * have none of the item.
 *
 * Revision 1.96  2007/12/19 20:36:01  myc
 * Replaced static '4' with 'NUM_COIN_TYPES'.
 *
 * Revision 1.95  2007/11/18 20:01:05  jps
 * Cause transient objects' timers to be reset when picked up.
 *
 * Revision 1.94  2007/11/18 16:51:55  myc
 * Changing LVL_BUILDER reference to LVL_GOD.
 *
 * Revision 1.93  2007/10/25 20:37:00  myc
 * Fixed a bug that was throwing garbage bits in the RIP log.
 * Added the compare command, which lets you compare two similar items.
 *
 * Revision 1.92  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.91  2007/10/04 16:20:24  myc
 * The transient item flag now makes things decay when they are on the
 * ground.
 *
 * Revision 1.90  2007/09/21 18:08:29  jps
 * Eating food will restore hit points, while drinking water will
 * restore movement points.
 *
 * Revision 1.89  2007/09/21 08:44:45  jps
 * Added object type "touchstone" and command "touch" so you can set
 * your home room by touching specific objects.
 *
 * Revision 1.88  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  AFF_HIDE and ITEM_HIDDEN are now
 * unused.  Changes to conceal, palm, stow, and get.
 *
 * Revision 1.87  2007/09/03 23:59:43  jps
 * Added macro ADDED_WEIGHT_OK for testing whether a char can have an
 * object added to its inventory.  Avoids an integer overflow problem
 * that could occur if an object's weight was near maxint.
 *
 * Revision 1.86  2007/08/26 01:55:19  myc
 * Adding lag to conceal, palm, stow.
 *
 * Revision 1.85  2007/08/17 03:34:41  myc
 * Correct error message for do_conceal when no argument.
 *
 * Revision 1.84  2007/08/16 19:53:38  myc
 * Adding stow/palm commands as secondary functionality to conceal skill.
 *
 * Revision 1.83  2007/08/14 22:43:07  myc
 * Adding 'conceal' skill which lets you hide items in the room.
 *
 * Revision 1.82  2007/08/03 22:00:11  myc
 * Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.81  2007/07/19 21:59:52  jps
 * Dynamic strings for drink containers.
 *
 * Revision 1.80  2007/07/19 15:32:01  jps
 * Add "extinguish" as a subcommand of light.
 *
 * Revision 1.79  2007/07/15 18:01:46  myc
 * You can now put lit permanent lights into containers.  Lit nonpermanent
 * lights are automatically extinguished.
 *
 * Revision 1.78  2007/07/15 17:16:12  jps
 * Add IS_POISONED macro, and moved HIGHLY_VISIBLE macro to utils.h
 *
 * Revision 1.77  2007/07/14 14:34:15  myc
 * Actions on highly visible objects are only seen when the actor is not
 * wiz-invis.
 *
 * Revision 1.76  2007/07/14 01:00:14  jps
 * Clear the af struct before use, so that poison doesn't set all
 * kinds of random unintended effects.
 *
 * Revision 1.75  2007/05/28 23:41:34  jps
 * put and get will interact first with equipped containers.
 *
 * Revision 1.74  2007/05/28 06:35:49  jps
 * Use the verb "activate" for permanent lights and "extinguish" otherwise.
 *
 * Revision 1.73  2007/05/27 17:45:28  jps
 * Fix pluralization in not-found messages.
 *
 * Revision 1.72  2007/05/27 17:34:42  jps
 * Typo fix "You slide <item> onto your ... finger"
 *
 * Revision 1.71  2007/05/24 05:02:49  jps
 * Rewrite do_wield. Fix bug with refusing to wield when one hand holds an item.
 *
 * Revision 1.70  2007/05/21 01:35:22  jps
 * Fix 'wear <weapon>' allowing dual wield without the skill.
 *
 * Revision 1.69  2007/04/18 00:23:34  myc
 * Fixed a typo in perform_wear.
 *
 * Revision 1.68  2007/04/15 10:36:53  jps
 * Make take/drop/give messages always visible when the object being
 * manipulated is highly visible (lit, glowing, or large).
 *
 * Revision 1.67  2007/04/11 14:15:28  jps
 * Give money piles proper keywords and make them dissolve when stolen.
 *
 * Revision 1.66  2007/04/11 07:25:43  jps
 * Remove magic numbers from hand-equipping code.  Make the wear command
 * equip weapons wielded secondary as well.
 *
 * Revision 1.65  2007/02/20 17:16:27  myc
 * Fixed crash bug in doorbash.
 *
 * Revision 1.64  2006/12/08 05:06:58  myc
 * Bribe triggers now give proper amounts and variables.
 *
 * Revision 1.63  2006/12/06 02:14:21  myc
 * Allowed use of 'worn as light' pos to players for lights that
 * are holdable and not wearable anywhere else.
 *
 * Revision 1.62  2006/11/30 05:06:24  jps
 * Add remove trigger for objects
 *
 * Revision 1.61  2006/11/24 06:50:02  jps
 * Draggability is now conferred with the TAKE wear flag.
 * An exception is made for corpses.
 *
 * Revision 1.60  2006/11/21 20:17:04  jps
 * Fix feedback when trying to pour: "The <name> is empty."
 *
 * Revision 1.59  2006/11/21 03:45:52  jps
 * The 'light' command now looks first at equipped items.
 *
 * Revision 1.58  2006/11/18 21:00:28  jps
 * Reworked disarm skill and disarmed-weapon retrieval.
 *
 * Revision 1.57  2006/11/18 09:08:15  jps
 * Use pretty-printing statemoney to format coins
 *
 * Revision 1.56  2006/11/18 04:26:32  jps
 * Renamed continual light spell to illumination, and it only works on
 * LIGHT items (still rooms too).
 *
 * Revision 1.55  2006/11/18 00:03:31  jps
 * Fix continual light items to always work when they have the
 * bit set.  Rooms now print an indicator of being continually lit.
 * Can't use it to make a room permanently lit any more.
 *
 * Revision 1.54  2006/11/16 16:42:14  jps
 * Prevent fountains from being emptied.
 *
 * Revision 1.53  2006/11/14 19:00:43  jps
 * Even if you are full, you can drink when you are a little thirsty.
 *
 * Revision 1.52  2006/11/12 20:22:32  jps
 * JUNKing an item will no longer invoke any drop triggers.
 * Attempting to drop a cursed item also won't invoke drop triggers.
 *
 * Revision 1.51  2006/11/08 10:12:28  jps
 * Fixed typo where you wore bracelets "on around" your wrist.
 *
 * Revision 1.50  2006/11/08 08:47:58  jps
 * Fixed gender in message about dragging a living creature.
 * Added slightly humorous message for when you try to drag yourself.
 *
 * Revision 1.49  2006/11/08 07:57:08  jps
 * Typo fix "stomach can't contain anymore" -> "any more"
 *
 * Revision 1.48  2006/11/07 11:07:57  jps
 * Allow belt items to be worn normally, and fix belt message typos.
 *
 * Revision 1.47  2006/11/07 08:29:16  jps
 * Can't drink any more when not thirsty.
 *
 * Revision 1.46  2006/07/20 07:38:42  cjd
 * Typo fixes.
 *
 * Revision 1.45  2003/07/24 22:47:15  jjl
 * Added the ability for mobs to give away cursed items.
 *
 * Revision 1.44  2003/07/06 20:00:30  jjl
 * Added some checking to avoid giving mobs items they can't use.
 *
 * Revision 1.43  2002/12/21 21:01:21  jjl
 * Refixed doorbash.  The hell was I thinking?
 *
 * Revision 1.42  2002/09/15 04:01:18  jjl
 * Fixed Doorbash so that the door is OPEN WHEN you go through.  Also,
 * stuns you even if there is no return door.
 *
 * Revision 1.41  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.40  2002/02/07 00:15:03  dce
 * Modified the code so players could not 'wear gloves !' and
 * have the item put in the light wear position.
 *
 * Revision 1.39  2001/12/18 02:29:41  dce
 * Gods can now drop and give cursed items away. This was
 * done for the quest.
 *
 * Revision 1.38  2001/12/07 15:42:30  dce
 * Fixed a bug with object spell effects where if a player
 * was wearing an item and died, they would permanently
 * gain that ability.
 *
 * Revision 1.37  2001/04/23 03:31:37  dce
 * Players will not be able to pick up an object that is
 * a higher level than they are. Also players will not
 * be able to give a low level character a high level item
 * in a bag. I also fixed cursed items by not allowing them
 * to be placed into a container.
 *
 * Revision 1.36  2001/04/08 13:25:12  dce
 * Prevented perform_give from give a high level boat to
 * a low level character.
 *
 * Revision 1.35  2001/04/07 14:10:18  dce
 * Can't get a boat that is a higher level than you.
 *
 * Revision 1.34  2001/03/31 21:22:01  dce
 * Fixed the doorbash bug when an exit doesn't exist.
 *
 * Revision 1.33  2001/03/24 15:10:26  dce
 * Players can not wear equipment until they are the proper
 * level based on the object.
 *
 * Revision 1.32  2001/01/16 19:25:37  rsd
 * Added a null check to doorbash to prevent crashing on
 * doorbash of invalid door. RE-tabbed section of doorbash
 * code
 * ..
 *
 * Revision 1.31  2000/11/28 00:44:00  mtp
 * removed mobprog references
 *
 * Revision 1.30  2000/11/25 08:09:43  rsd
 * Added corpse dragging debug to do_drag to track when player
 * corpses are drug from one room to another.  Also added debug
 * to perform_get_from_container() or something like that to
 * log each object looted from a player corpse to prevent
 * players from claiming that their eq just 'disappeared'.
 * Also retabbed and braced {} sections of the associated code
 * in an attempt to make it readable.
 *
 * Revision 1.29  2000/11/20 03:34:31  rsd
 * added some missing and back rlog messages from prior
 * to the addition of the $log$ string.
 *
 * Revision 1.28  2000/11/10 23:32:26  mtp
 * fixed the wear/wield weirdness including weight check for weapons
 *
 * Revision 1.27  2000/11/10 00:04:25  mtp
 * fixed the wear all allowing 2 handers + 2 weapons
 *
 * Revision 1.26  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.25  2000/09/04 19:41:01  rsd
 * Retabbed doorbash and added a skill ckeck early in the function.
 *
 * Revision 1.24  2000/04/22 22:24:46  rsd
 * No more animals wearing eq and wielding weapons
 *
 * Revision 1.23  2000/04/05 22:55:57  rsd
 * more cmc enhancements to do give...
 *
 * Revision 1.22  2000/04/05 22:31:12  rsd
 * More cmc tweaks on do give :)
 *
 * Revision 1.21  2000/04/05 21:53:33  rsd
 * CMC altered perform_give() to include the summation of many
 * items given to someone. Also altered do_give() to reflect
 * the implementation of these changes.
 *
 * Revision 1.20  2000/04/05 20:49:32  rsd
 * Chris added a fix to do_get to prevent a huge loop of
 * trying to give non-existant objects to someone, Ie give
 * 48000 cpper person.
 *
 * Revision 1.19  2000/04/05 06:30:44  rsd
 * changed the comment header to make it a fiery file
 *
 * Revision 1.18  1999/12/02 23:17:10  rsd
 * removed mode == SCMD_JUNK from #define VANISH(mode)
 * in order to drop the silly vanishes message from junking
 *
 * Revision 1.17  1999/11/23 15:48:23  jimmy
 * Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
 * Reinstated dual wield.
 * Allowed mobs/players to pick up items while fighting.
 * Fixed a bug in the damage message that wrongfully indicated a miss
 * due to a rounding error in the math.
 * This was all done in order to facilitate the chance to sling your
 * weapon in combat.  Dex and proficiency checks are now made on any missed
 * attact and a failure of both causes the weapon to be slung.
 *
 * Revision 1.16  1999/09/10 01:07:05  mtp
 * also message if can-t 't dual wield (no skill)
 *
 * Revision 1.15  1999/09/10 01:04:25  mtp
 * message if trying to wield when already wielding 2 weapons
 *
 * Revision 1.14  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.13  1999/09/03 22:57:43  mtp
 * added some IS_FIGHTING checks
 *
 * Revision 1.12  1999/08/13 21:33:19  dce
 * Wear all and rent now does weapons.
 *
 * Revision 1.11  1999/08/07 23:49:16  mud
 * Added the function corpse_consent to assist in checking
 * for player consent to messing with their corpses. Added the
 * functionality to looting (do_get) and dragging corpses.
 *
 * Revision 1.10  1999/06/30 18:25:04  jimmy
 * >> This is a major conversion from the 18 point attribute system to the
 * >> 100 point attribute system.  A few of the major changes are:
 * >> All attributes are now on a scale from 0-100
 * >> Everyone views attribs the same but, the attribs for one race
 * >>   may be differeent for that of another even if they are the
 * >>   same number.
 * >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * >> Mobs now have individual random attributes based on race/class.
 * >> The STR_ADD attrib has been completely removed.
 * >> All bonus tables for attribs in constants.c have been replaced by
 * >>   algorithims that closely duplicate the tables except on a 100 scale.
 * >> Some minor changes:
 * >> Race selection at char creation can now be toggled by using
 * >>   <world races off>
 * >> Lots of cleanup done to affected areas of code.
 * >> Setting attributes for mobs in the .mob file no longer functions
 * >>   but is still in the code for later use.
 * >> We now have a spare attribut structure in the pfile because the new
 * >>   system only used three instead of four.
 * >> --gurlaek 6/30/1999
 *
 * Revision 1.9  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.8  1999/05/02 16:50:16  dce
 * You can now get one coin.
 *
 * Revision 1.7  1999/04/09 03:38:36  dce
 * Junk command is back!
 *
 * Revision 1.6  1999/03/12 18:05:43  dce
 * Players can no longer hold lights in the light position
 *
 * Revision 1.5  1999/02/20 18:41:36  dce
 * Adds improve_skill calls so that players can imprve their skills.
 *
 * Revision 1.4  1999/02/12 16:25:09  jimmy
 * Fixed poofs to show a default poof if none is set.
 *
 * Revision 1.3  1999/02/10 02:38:58  dce
 * Fixes some of continual light.
 *
 * Revision 1.2  1999/02/06 04:09:01  dce
 * David Endre 2/5/99
 * Adds do_light, to allow lights to be turned on while in
 * someones inventory.
 *
 * Revision 1.1  1999/01/29 01:23:29  mud
 * Initial Revision
 *
 ***************************************************************************/
@


1.169
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.168 2009/03/19 23:16:23 myc Exp jps $
d683 1
a683 1
      mudlog(buf, CMP, LVL_GOD, FALSE);
d1998 3
@


1.168
log
@Moved the get command and its kids from here to act.get.c.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.167 2009/03/16 19:17:52 jps Exp myc $
d399 1
a399 1
        cprintf(ch, "You don't have enough %s!\r\n", coin_names[type]);
d1998 3
@


1.167
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.166 2009/03/15 07:09:24 jps Exp jps $
a52 4
bool check_get_disarmed_obj(struct char_data *ch, struct char_data *last_to_hold, struct obj_data *obj);
bool corpse_consent(struct char_data *ch, struct obj_data *cont);


d123 2
a124 2
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d130 2
a131 2
  obj_dotmode = find_all_dots(arg1);
  cont_dotmode = find_all_dots(arg2);
d182 2
a183 2
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d196 2
a197 2
  obj_dotmode = find_all_dots(arg1);
  cont_dotmode = find_all_dots(arg2);
a276 491
int can_take_obj(struct char_data * ch, struct obj_data * obj)
{
  if (GET_LEVEL(ch) >= LVL_GOD)
    return 1;
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) {
    act("$p: you can't carry that many items.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  } else if (!ADDED_WEIGHT_OK(ch, obj)) {
    act("$p: you can't carry that much weight.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  } else if (!CAN_WEAR(obj, ITEM_WEAR_TAKE)) {
    act("$p: you can't take that!", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  } else if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
    act("You are not experienced enough to use $p.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
  }
  return 1;
}

void unhide_object(struct obj_data *obj) {
  if (GET_OBJ_HIDDENNESS(obj)) {
    GET_OBJ_HIDDENNESS(obj) = 0;
    if (!OBJ_FLAGGED(obj, ITEM_WAS_DISARMED))
      obj->last_to_hold = NULL;
  }
}

void get_check_money(struct char_data * ch, struct obj_data * obj)
{
  if (GET_OBJ_TYPE(obj) == ITEM_MONEY) {
    obj_from_char(obj);
    if (MONEY_VALUE(obj) < 0)
      return;
    else if (MONEY_VALUE(obj) == 0)
      send_to_char("There were 0 coins.\r\n"
                   "Must have been an illusion!\r\n", ch);
    else {
      statemoney(buf, obj->obj_flags.value); /* HACK */
      cprintf(ch, "There were %s.\r\n", buf);
    }
    GET_PLATINUM(ch) += GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM);
    GET_GOLD(ch) += GET_OBJ_VAL(obj, VAL_MONEY_GOLD);
    GET_SILVER(ch) += GET_OBJ_VAL(obj, VAL_MONEY_SILVER);
    GET_COPPER(ch) += GET_OBJ_VAL(obj, VAL_MONEY_COPPER);
    extract_obj(obj);
  }
}


void get_check_split(struct char_data *ch, struct obj_data *obj)
{
  int coins[NUM_COIN_TYPES];

  extern void split_coins(struct char_data *ch, int coins[]);

  /* Save the amount of coins, since get_check_money will extract obj */
  coins[PLATINUM] = GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM);
  coins[GOLD] = GET_OBJ_VAL(obj, VAL_MONEY_GOLD);
  coins[SILVER] = GET_OBJ_VAL(obj, VAL_MONEY_SILVER);
  coins[COPPER] = GET_OBJ_VAL(obj, VAL_MONEY_COPPER);

  get_check_money(ch, obj);

  if (GET_OBJ_TYPE(obj) == ITEM_MONEY &&
      PRF_FLAGGED(ch, PRF_AUTOSPLIT) && IS_GROUPED(ch))
    if (coins[COPPER] || coins[SILVER] || coins[GOLD] || coins[PLATINUM])
      split_coins(ch, coins);
}

void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
                                struct obj_data * cont, int mode)
{
  if (!SOLIDCHAR(ch) && cont->carried_by != ch && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You can't handle solid objects in your condition.\r\n", ch);
    return;
  }
  if (mode == FIND_OBJ_INV || can_take_obj(ch, obj)) {
    if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      act("$p: you can't hold any more items.", FALSE, ch, obj, 0, TO_CHAR);
    else if (get_otrigger(obj, ch)) {
      if (MOB_FLAGGED(ch, MOB_ILLUSORY)) {
        /* Just pretend */
        act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
        act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      }
      else {
        obj_from_obj(obj);
        obj_to_char(obj, ch);
        act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
        act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
        unhide_object(obj);
        if (IS_PLR_CORPSE(cont))
          log("CORPSE: %s gets %s from %s.",
              GET_NAME(ch), strip_ansi(obj->short_description),
              cont->short_description);
        if (IS_CORPSE(cont))
          get_check_split(ch, obj);
        else
          get_check_money(ch, obj); 
      }
    }
  }
}


void get_from_container(struct char_data * ch, struct obj_data * cont,
                        char *arg, int mode)
{
  struct obj_data *obj, *next_obj;
  int obj_dotmode, found = 0;

  obj_dotmode = find_all_dots(arg);

  if (IS_SET(GET_OBJ_VAL(cont, VAL_CONTAINER_BITS), CONT_CLOSED)) {
    act("$p is closed.", FALSE, ch, cont, 0, TO_CHAR);
  } else if (obj_dotmode == FIND_INDIV) {
    if (!(obj = find_obj_in_list(cont->contains, find_vis_by_name(ch, arg)))) {
      sprintf(buf, "There doesn't seem to be %s %s in $p.", AN(arg), arg);
      act(buf, FALSE, ch, cont, 0, TO_CHAR);
    } else {
      perform_get_from_container(ch, obj, cont, mode);
    }
  } else {
    if (obj_dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = cont->contains; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
          (obj_dotmode == FIND_ALL || isname(arg, obj->name))) {
        found = 1;
        perform_get_from_container(ch, obj, cont, mode);
      }
    }
    if (!found) {
      if (obj_dotmode == FIND_ALL) {
        act("$p seems to be empty.", FALSE, ch, cont, 0, TO_CHAR);
      } else {
        sprintf(buf, "You can't seem to find any %s%s in $p.", arg,
           isplural(arg) ? "" : "s");
        act(buf, FALSE, ch, cont, 0, TO_CHAR);
      }
    }
  }
}

int perform_get_from_room(struct char_data * ch, struct obj_data * obj)
{
  if (!RIGID(ch) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("In your fluid state, you can't pick things up.\r\n", ch);
    return 0;
  }
  if (check_get_disarmed_obj(ch, obj->last_to_hold, obj))
    return 0;
  if (can_take_obj(ch, obj)) {
    if (get_otrigger(obj, ch)) {
      if (MOB_FLAGGED(ch, MOB_ILLUSORY)) {
        /* Just pretend */
        act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
        act("$n gets $p.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
      }
      else {
        obj_from_room(obj);
        obj_to_char(obj, ch);
        act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
        act("$n gets $p.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
        unhide_object(obj);
        get_check_money(ch, obj);
        return 1;
      }
    }
  }
  return 0;
}

int get_random_object(struct char_data *ch)
{
   struct obj_data *obj, *chosen = NULL;
   int count = 0;

   for (obj = world[ch->in_room].contents; obj; obj = obj->next_content) {
      if (CAN_SEE_OBJ(ch, obj)) {
         if (chosen == NULL || number(0, count) == 0)
            chosen = obj;
         count++;
      }
   }

   if (!chosen) return 0;
   return perform_get_from_room(ch, chosen);
}


void get_from_room(struct char_data * ch, char *arg)
{
  struct obj_data *obj, *next_obj;
  int dotmode, found = 0;

  dotmode = find_all_dots(arg);

  if (dotmode == FIND_INDIV) {
    if (!(obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg))))
      cprintf(ch, "You don't see %s %s here.\r\n", AN(arg), arg);
    else if (CONFUSED(ch) && number(0, 1) == 0) {
      send_to_char("&5You fumble haphazardly...&0\r\n", ch);
      get_random_object(ch);
    } else
       perform_get_from_room(ch, obj);
  } else {
    if (dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = world[ch->in_room].contents; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
          (dotmode == FIND_ALL || isname(arg, obj->name))) {
        found = 1;
        if (CONFUSED(ch) && number(0, 1) == 0) {
          send_to_char("&5You fumble haphazardly...&0\r\n", ch);
          get_random_object(ch);
          /* Note: this loop cannot be allowed to continue, because the current
           * next_obj might have been taken by get_random_object().
           * It's ok though, because when you're confused, you're not allowed
           * to use "FIND_ALLDOT" and such - so you only wanted to get one
           * thing anyway. */
          break;
        }
        perform_get_from_room(ch, obj);
      }
    }
    if (!found) {
      if (dotmode == FIND_ALL)
        send_to_char("There doesn't seem to be anything here.\r\n", ch);
      else
        cprintf(ch, "You don't see any %s%s here.\r\n", arg,
           isplural(arg) ? "" : "s");
    }
  }
}


ACMD(do_get) {
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  int cont_dotmode, found = 0, mode;
  struct obj_data *cont;
  struct char_data *tmp_char;

  two_arguments(argument, arg1, arg2);

  if (!*arg1)
    send_to_char("Get what?\r\n", ch);
  else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch) && GET_LEVEL(ch) < LVL_IMMORT)
    send_to_char("Your arms are already full!\r\n", ch);
  else if (!*arg2) {
    get_from_room(ch, arg1);
    save_player_objects(ch);
  }
  else if (CONFUSED(ch))
    send_to_char("You're too confused!\r\n", ch);
  else {
    cont_dotmode = find_all_dots(arg2);
    if (cont_dotmode == FIND_INDIV) {
      mode = generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
      if (!cont) {
        sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
        send_to_char(buf, ch);
      }
      else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
        act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
      else if (!IS_PLR_CORPSE(cont) || corpse_consent(ch, cont)) {
        get_from_container(ch, cont, arg1, mode);
        save_player_objects(ch);
      }
    }
    else {
      if (cont_dotmode == FIND_ALLDOT && !*arg2) {
        send_to_char("Get from all of what?\r\n", ch);
        return;
      }
      for (cont = ch->carrying; cont; cont = cont->next_content)
        if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
          if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
            found = 1;
            get_from_container(ch, cont, arg1, FIND_OBJ_INV);
          }
          else if (cont_dotmode == FIND_ALLDOT) {
            found = 1;
            act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
          }
        }
      for (cont = world[ch->in_room].contents; cont; cont = cont->next_content) {
        if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
          if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
            found = 1;
            /* Added functionality to check for consent to prevent players from
             * looting each others corpses. Zzur 8/7/1999
             */
            if (!IS_PLR_CORPSE(cont) || corpse_consent(ch, cont))
              get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
          } else if (cont_dotmode == FIND_ALLDOT) {
            act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
            found = 1;
          }
        }
      }
      if (found)
        save_player_objects(ch);
      else {
        if (cont_dotmode == FIND_ALL)
          send_to_char("You can't seem to find any containers.\r\n", ch);
        else
          cprintf(ch, "You can't seem to find any %s%s here.\r\n", arg2,
                  isplural(arg2) ? "" : "s");
      }
    }
  }
}


ACMD(do_palm)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  int obj_dotmode, cont_dotmode, cont_mode, roll = 100;
  struct obj_data *cont, *obj;
  struct char_data *tch;

  if (CONFUSED(ch)) {
    send_to_char("You are too confused.\r\n", ch);
    return;
  }

  two_arguments(argument, arg1, arg2);

  obj_dotmode = find_all_dots(arg1);
  cont_dotmode = find_all_dots(arg2);

  if (!GET_SKILL(ch, SKILL_CONCEAL))
    do_get(ch, argument, cmd, 0);
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch) && GET_LEVEL(ch) < LVL_GOD)
    send_to_char("Your arms are already full!\r\n", ch);
  else if (!*arg1)
    send_to_char("Palm what?\r\n", ch);
  else if (obj_dotmode != FIND_INDIV)
    send_to_char("You can only palm one item at a time!\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You can only palm an item from one container at a time!\r\n", ch);
  /* No container - palm from room */
  else if (!*arg2) {
    if (!(obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg1))))
      cprintf(ch, "You don't see %s %s here.\r\n", AN(arg1), arg1);
    else if (!check_get_disarmed_obj(ch, obj->last_to_hold, obj) &&
             can_take_obj(ch, obj) && get_otrigger(obj, ch)) {
      int people = 0;
      roll = conceal_roll(ch, obj);
      obj_from_room(obj);
      obj_to_char(obj, ch);

      if (!SOLIDCHAR(ch) && GET_LEVEL(ch) < LVL_IMMORT)
        sprintf(buf, "%s tries to snatch $p off the ground, but seems to be having difficulty.", GET_NAME(ch));
      else
        sprintf(buf, "%s coyly snatches $p off the ground.", GET_NAME(ch));
      LOOP_THRU_PEOPLE(tch, ch) {
        if (tch == ch)
          continue;
        if (CAN_SEE(ch, tch)) {
          ++people;
          if (GET_PERCEPTION(tch) < roll - 50 + number(0, 50))
            continue;
        }
        else if (GET_PERCEPTION(tch) < roll / 2)
          continue;
        if (!CAN_SEE(tch, ch))
          continue;
        if (!CAN_SEE_OBJ(tch, obj) && number(0, 1))
          continue;
        act(buf, TRUE, tch, obj, cont, TO_CHAR);
      }
      if (!SOLIDCHAR(ch) && GET_LEVEL(ch) < LVL_IMMORT)
        act("You casually reach for $p... but you can't get a grip on it!", FALSE, ch, obj, 0, TO_CHAR);
      else {
        if (people)
          act("You palm $p when you think no one is looking.", FALSE, ch, obj, 0, TO_CHAR);
        else
          act("You smoothly palm $p.", FALSE, ch, obj, 0, TO_CHAR);
        unhide_object(obj);
        get_check_money(ch, obj);
        WAIT_STATE(ch, PULSE_VIOLENCE);
        improve_skill(ch, SKILL_CONCEAL);
      }
    }
  }
  else {
    cont_mode = generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tch, &cont);
    if (!cont)
      cprintf(ch, "You can't find %s %s.\r\n", AN(arg2), arg2);
    else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (IS_SET(GET_OBJ_VAL(cont, VAL_CONTAINER_BITS), CONT_CLOSED))
      act("$p is closed.", FALSE, ch, cont, 0, TO_CHAR);
    else if (!IS_PLR_CORPSE(cont) || corpse_consent(ch, cont)) {
      if (!(obj = find_obj_in_list(cont->contains, find_vis_by_name(ch, arg1)))) {
        sprintf(buf, "There doesn't seem to be %s %s in $p.", AN(arg1), arg1);
        act(buf, FALSE, ch, cont, 0, TO_CHAR);
      }
      else if (cont_mode == FIND_OBJ_INV || can_take_obj(ch, obj)) {
        if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
          act("$p: you can't hold any more items.", FALSE, ch, obj, 0, TO_CHAR);
        else if (get_otrigger(obj, ch)) {

          if (SOLIDCHAR(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
            roll = conceal_roll(ch, obj);
            obj_from_obj(obj);
            obj_to_char(obj, ch);
            act("You quietly palm $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
            sprintf(buf, "%s quietly slips $p out of $P.", GET_NAME(ch));
          } else {
            act("You quietly reach into $P, but you can't seem to grasp $p.", FALSE, ch, obj, cont, TO_CHAR);
            sprintf(buf, "%s tries to slip $p out of $P, but is having trouble.", GET_NAME(ch));
          }

          LOOP_THRU_PEOPLE(tch, ch) {
            if (tch == ch)
              continue;
            if (!CAN_SEE(tch, ch))
              continue;
            if (!CAN_SEE_OBJ(tch, obj) && number(0, 1))
              continue;
            if (CAN_SEE(ch, tch) ?
                (GET_PERCEPTION(tch) < roll - 50 + number(0, 50)) :
                (GET_PERCEPTION(tch) < roll / 2))
              continue;
            act(buf, TRUE, tch, obj, cont, TO_CHAR);
          }
          if (SOLIDCHAR(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
            unhide_object(obj);
            if (IS_PLR_CORPSE(cont))
              log("CORPSE: %s palms %s from %s.",
                  GET_NAME(ch), strip_ansi(obj->short_description),
                  cont->short_description);
            get_check_money(ch, obj);
            WAIT_STATE(ch, PULSE_VIOLENCE);
            improve_skill(ch, SKILL_CONCEAL);
          }
        }
      }
    }
  }
}


/* This function checks to see if the player ch has the consent of  */
/* the owner of the corpse cont. or is the owner of the corpse cont */
/* Returns TRUE if so.             gurlaek 8/7/1999                 */

bool corpse_consent(struct char_data *ch, struct obj_data *cont) {
  struct descriptor_data *d;
  bool done = FALSE;

  sprintf(buf, "corpse %s", GET_NAME(ch));
  if (GET_LEVEL(ch) >= LVL_GOD) {
    /* If you are a god, then you always have consent */
    done = TRUE;
  } else if (!str_cmp(buf, cont->name)) {
    /* if it's your own corpse then you have consent */
    done = TRUE;
  } else {
    /* loop through all the connected descriptors */
    for (d = descriptor_list; d && !done; d = d->next) {
      if (d->character) {
        /* compare the name of the corpse to the current d->character  */
        /* if the d->character is consented to the person who's acting */
        /* on the corpse then the act is allowed.                      */
        sprintf(buf, "corpse %s", GET_NAME(d->character));
        if (!str_cmp(buf, cont->name) && CONSENT(d->character) == ch) {
          done = TRUE;
        }
      }
    }
  }
  /* no consent and not your own corpse */
  if (!done)
    send_to_char("Not without consent you don't!\r\n",ch);

  return done;
}

d382 1
d392 5
a396 1
  if (parse_money(argument, coins)) {
d410 1
a410 1
  argument = one_argument(argument, arg);
d412 1
a412 1
  if (!*arg) {
d417 1
a417 1
  dotmode = find_all_dots(arg);
d431 2
a432 2
    context = find_vis_by_name(ch, arg);
    if (!*arg)
d435 2
a436 2
      cprintf(ch, "You don't seem to have any %s%s.\r\n", arg,
              isplural(arg) ? "" : "s");
d446 1
a446 1
    if (is_number(arg)) {
d449 2
a450 2
        amount = atoi(arg);
        one_argument(argument, arg);
d453 1
a453 1
    context = find_vis_by_name(ch, arg);
d459 2
a460 2
              amount == 1 ? AN(arg) : "any", arg,
              amount == 1 || isplural(arg) ? "" : "s");
d467 1
a467 1
        if (CONFUSED(ch) && number(0, 1) == 0)
d469 3
d479 2
a480 2
                total - amount, arg,
                isplural(arg) || total - amount == 1? "" : "s");
d606 2
a607 2
void perform_give_gold(struct char_data * ch, struct char_data * vict,
                       int coins[])
d622 1
a622 1
      afford = 0;
d624 1
a624 1
      afford = 0;
d626 1
a626 1
      afford = 0;
d628 1
a628 1
      afford = 0;
d636 4
a639 4
      GET_PLATINUM(ch)   -= coins[PLATINUM];
      GET_GOLD(ch)   -= coins[GOLD];
      GET_SILVER(ch) -= coins[SILVER];
      GET_COPPER(ch) -= coins[COPPER];
d694 9
a702 1
  bool is_coins;
d704 1
a704 1
  argument = one_argument(argument, arg);
d706 1
a706 1
  if (!*arg) {
d711 3
a713 28
  /* is_number fortunately doesn't allow negative values */
  if (is_number(arg)) {
    is_coins = TRUE;
    amount = atoi(arg);
    while (is_number(arg)) {
      argument = one_argument(argument, arg);
      if (is_abbrev(arg, "platinum"))
        cash[PLATINUM] += amount;
      else if (is_abbrev(arg, "gold"))
        cash[GOLD] += amount;
      else if (is_abbrev(arg, "silver"))
        cash[SILVER] += amount;
      else if (is_abbrev(arg, "copper"))
        cash[COPPER] += amount;
      else {
        is_coins = FALSE;
        break;
      }
      argument = one_argument(argument, arg);
      amount = atoi(arg);
    }

    if (is_coins) {
      if (!(vict = give_find_vict(ch, arg)))
        return;
      perform_give_gold(ch, vict, cash);
      return;
    }
d721 1
a721 1
  dotmode = find_all_dots(arg);
d729 1
a729 2
    sprintf(buf, "Do you want to give '%d' or 'all'?  Make up your mind!\r\n", amount);
    send_to_char(buf, ch);
d735 1
a735 1
      if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg)))) {
d737 1
a737 1
          cprintf(ch, "You don't seem to have a %s.\r\n", arg);
d739 1
a739 1
          cprintf(ch, "You don't seem to have %d %ss.\r\n", amount, arg);
d756 1
a756 1
    if (dotmode == FIND_ALLDOT && !*arg) {
d765 1
a765 1
      if (dotmode == FIND_ALL || isname(arg, obj->name)) {
d779 1
a779 1
        cprintf(ch, "You don't even have one %s!\r\n", arg);
d1325 2
a1326 2
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d1340 1
a1340 1
  dotmode = find_all_dots(arg1);
d1618 1
d1620 1
a1620 1
  argument = one_argument(argument, arg);
d1622 1
a1622 1
  if (!*arg) {
d1626 1
a1626 1
  dotmode = find_all_dots(arg);
d1640 1
a1640 1
    if (!*arg)
d1645 1
a1645 1
        if (GET_EQ(ch, where) && isname(arg, GET_EQ(ch, where)->name)) {
d1650 2
a1651 2
        cprintf(ch, "You don't seem to be using any %s%s.\r\n", arg,
                isplural(arg) ? "" : "s");
d1655 1
a1655 1
  else if (is_number(arg) &&
d1659 1
a1659 1
    remove_message(ch, board(GET_OBJ_VAL(obj, VAL_BOARD_NUMBER)), atoi(arg), obj);
d1661 1
a1661 1
           generic_find(arg, FIND_OBJ_EQUIP | FIND_OBJ_ROOM | FIND_OBJ_WORLD,
d1664 2
a1665 2
  else if (!(obj = (find_obj_in_eq(ch, &where, find_vis_by_name(ch, arg)))))
    cprintf(ch, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
d1998 3
@


1.166
log
@Add !FALL flag for objects
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.165 2009/03/09 21:43:50 myc Exp jps $
d2373 1
a2373 1
         GET_HOME(ch) = world[ch->in_room].vnum;
d2502 3
@


1.165
log
@Make get_check_money use statemoney.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.164 2009/03/09 20:36:00 myc Exp myc $
d774 1
a774 1
                 byte mode, const char *sname)
d776 1
d788 1
a788 1
    sprintf(buf, "You can't %s $p - it must be CURSED!", sname);
d793 3
d2502 3
@


1.164
log
@Renamed all *PLAT macros to *PLATINUM.
Overhauled do_drop to work with dropping multiple types of
coins at once.  Also now supports dropping multiple objects
at once.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.163 2009/03/09 05:41:31 jps Exp myc $
d315 3
d319 2
a320 8
      sprintf(buf, "There were %d platinum, %d gold, %d silver, and %d copper coins.\r\n",
              GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM),
              GET_OBJ_VAL(obj, VAL_MONEY_GOLD),
              GET_OBJ_VAL(obj, VAL_MONEY_SILVER),
              GET_OBJ_VAL(obj, VAL_MONEY_COPPER));
      if (MONEY_VALUE(obj) == 0)
        sprintf(buf, "%sMust have been an illusion!\r\n", buf);
      send_to_char(buf, ch);
d517 2
a518 2
      else {
        sprintf(buf, "You don't see any %s%s here.\r\n", arg,
a519 2
        send_to_char(buf, ch);
      }
a720 3
            get_check_money(ch, obj);
            WAIT_STATE(ch, PULSE_VIOLENCE);
            improve_skill(ch, SKILL_CONCEAL);
d725 3
d1143 2
a1144 2
      strcpy(buf, "You give $n");
      statemoney(buf, coins);
d1149 2
a1150 2
   strcpy(buf, "$n gives you");
   statemoney(buf, coins);
d2498 6
@


1.163
log
@Moved money stuff into money.h, money.c
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.162 2009/03/09 02:22:32 myc Exp jps $
d325 1
a325 1
    GET_PLAT(ch) += GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM);
d341 1
a341 1
  coins[PLAT] = GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM);
d350 1
a350 1
    if (coins[COPPER] || coins[SILVER] || coins[GOLD] || coins[PLAT])
a776 5
void perform_drop_gold(struct char_data * ch, int amount,
                       byte mode, int RDR)
{
  struct obj_data *obj;
  char *shortdesc;
d778 2
a779 41
  if (amount <= 0)
    send_to_char("Heh heh heh.. we are jolly funny today, eh?\r\n", ch);
  else if (GET_GOLD(ch) < amount)
    send_to_char("You don't have that many coins!\r\n", ch);
  else {
    if (mode != SCMD_JUNK) {
      WAIT_STATE(ch, PULSE_VIOLENCE);        /* to prevent coin-bombing */
      obj = create_money(0, amount, 0, 0);

      if (mode == SCMD_DONATE) {
        send_to_char("You throw some gold into the air where it disappears in a puff of smoke!\r\n", ch);
        act("$n throws some gold into the air where it disappears in a puff of smoke!",
            FALSE, ch, 0, 0, TO_ROOM);
        obj_to_room(obj, RDR);
        act("$p suddenly appears in a puff of orange smoke!", 0, 0, obj, 0, TO_ROOM);
      } else {
        if (!drop_wtrigger(obj, ch)) {
          extract_obj(obj);
          return;
        }
        send_to_char("You drop some gold.\r\n", ch);
   money_desc(amount, &shortdesc, NULL);
        sprintf(buf, "$n drops %s.", shortdesc);
        act(buf, FALSE, ch, 0, 0, TO_ROOM);
        obj_to_room(obj, ch->in_room);
      }
    } else {
      money_desc(amount, &shortdesc, NULL);
      sprintf(buf, "$n drops %s which disappears in a puff of smoke!", shortdesc);
      act(buf, FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You drop some gold which disappears in a puff of smoke!\r\n", ch);
    }
    GET_GOLD(ch) -= amount;
  }
}

#define VANISH(mode) ((mode == SCMD_DONATE) ? \
                      "  It vanishes in a puff of smoke!" : "")

int perform_drop(struct char_data * ch, struct obj_data * obj,
                 byte mode, char *sname, int RDR)
a780 2
  int value;

d794 1
a794 1
    return 0;
d802 1
a802 1
       return 0;
d804 1
a804 1
       return 0;
d808 1
a808 1
    sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
d810 1
a810 1
    sprintf(buf, "$n %ss $p.%s", sname, VANISH(mode));
a813 3
  if ((mode == SCMD_DONATE) && OBJ_FLAGGED(obj, ITEM_NODONATE))
    mode = SCMD_JUNK;

a821 6
    return 0;
    break;
  case SCMD_DONATE:
    obj_to_room(obj, RDR);
    act("$p suddenly appears in a puff a smoke!", FALSE, 0, obj, 0, TO_ROOM);
    return 0;
a823 1
    value = MAX(1, MIN(200, GET_OBJ_COST(obj) >> 4));
a824 1
    return value;
a829 2

  return 0;
d864 1
a864 1
int drop_random_object(struct char_data *ch)
d866 3
a868 3
   struct obj_data *obj = random_inventory_object(ch);
   if (!obj) return 0;
   return perform_drop(ch, obj, SCMD_DROP, "drop", 0);
a872 1
  extern int donation_room_1;
d874 4
a877 4
  int RDR = 0;
  byte mode = SCMD_DROP;
  int dotmode, amount = 0;
  char *sname;
d879 2
a880 4
  switch (subcmd) {
  case SCMD_JUNK:
    sname = "junk";
    mode = SCMD_JUNK;
d885 14
a898 24
    break;
  case SCMD_DONATE:
    sname = "donate";
    mode = SCMD_DONATE;
    switch (number(0, 2)) {
    case 0:
      mode = SCMD_JUNK;
      break;
    case 1:
    case 2:
      RDR = real_room(donation_room_1);
      break;
      /*    case 3: RDR = real_room(donation_room_2); break;
            case 4: RDR = real_room(donation_room_3); break;
      */
    }
    if (RDR == NOWHERE) {
      send_to_char("Sorry, you can't donate anything right now.\r\n", ch);
      return;
    }
    break;
  default:
    sname = "drop";
    break;
d904 1
a904 2
    sprintf(buf, "What do you want to %s?\r\n", sname);
    send_to_char(buf, ch);
d908 1
a908 81
  else if (is_number(arg)) {
    amount = atoi(arg);
    argument = one_argument(argument, arg);
    if (!str_cmp("platinum", arg) || !str_cmp("p", arg)){
      if (GET_PLAT(ch)<amount){
        send_to_char("You don't have enough!\r\n", ch);
        return;}
      obj = create_money(amount, 0, 0, 0);
      obj_to_room(obj, ch->in_room);
      GET_PLAT(ch) = GET_PLAT(ch)-amount;
      if(amount < 2){
        send_to_char("You drop a &0&b&6platinum&0 coin!\r\n", ch);
        return;}
      if (amount > 1){
        {sprintf(buf, "You drop &0&b&6%d&0 platinum coins!\r\n", amount);
        act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
          sprintf(buf, "$n drops some &0&b&6platinum&0 coins!\r\n");
          act(buf, FALSE, ch, 0, 0, TO_ROOM);}
        return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);        /* to prevent coin-bombing */
    }
    if (!str_cmp("gold", arg) || !str_cmp("g", arg)){
      if (GET_GOLD(ch)<amount){
        send_to_char("You don't have enough!\r\n", ch);
        return;}
      obj = create_money(0, amount, 0, 0);
      obj_to_room(obj, ch->in_room);
      GET_GOLD(ch) = GET_GOLD(ch)-amount;
      if(amount < 2){
        send_to_char("You drop a &0&b&3gold&0 coin!\r\n", ch);
        return;}
      if (amount > 1){
        {sprintf(buf, "You drop &0&b&3%d&0 gold coins!\r\n", amount);
        act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
          sprintf(buf, "$n drops some &0&b&3gold&0 coins!\r\n");
          act(buf, FALSE, ch, 0, 0, TO_ROOM);}
        return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);        /* to prevent coin-bombing */
    }
    if (!str_cmp("silver", arg) || !str_cmp("s", arg)){
      if (GET_SILVER(ch)<amount){
        send_to_char("You don't have enough!\r\n", ch);
        return;}
      obj = create_money(0, 0, amount, 0);
      obj_to_room(obj, ch->in_room);
      GET_SILVER(ch) = GET_SILVER(ch)-amount;
      if(amount < 2){
        send_to_char("You drop a silver coin.\r\n", ch);
        return;}
      if (amount > 1){
        {sprintf(buf, "You drop %d silver coins.\r\n", amount);
        act(buf, FALSE, ch, 0, 0, TO_CHAR);}
        {sprintf(buf, "$n drops some silver coins.\r\n");
        act(buf, FALSE, ch, 0, 0, TO_ROOM);}
        return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);        /* to prevent coin-bombing */
    }
    if (!str_cmp("copper", arg) || !str_cmp("c", arg)){
      if (GET_COPPER(ch)<amount){
        send_to_char("You don't have enough!\r\n", ch);
        return;}
      obj = create_money(0, 0, 0, amount);
      obj_to_room(obj, ch->in_room);
      GET_COPPER(ch) = GET_COPPER(ch)-amount;
      if(amount == 1){
        send_to_char("You drop a &0&3copper&0 coin.\r\n", ch);}
      if (amount > 1){
        {sprintf(buf, "You drop &0&3%d&0 copper coins.\r\n", amount);
        act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
          sprintf(buf, "$n drops some &0&3copper&0 coins.\r\n");
          act(buf, FALSE, ch, 0, 0, TO_ROOM);}
        return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);        /* to prevent coin-bombing */
    }
    else {
      /* code to drop multiple items.  anyone want to write it? -je */
      send_to_char("Sorry, you can't do that to more than one item at a time.\r\n", ch);
    }
    return;
  }   else {
    dotmode = find_all_dots(arg);
d910 9
a918 20
    /* Can't junk or donate all */
    if ((dotmode == FIND_ALL) && (subcmd == SCMD_JUNK || subcmd == SCMD_DONATE)) {
      if (subcmd == SCMD_JUNK)
        send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
      else
        send_to_char("Go do the donation room if you want to donate EVERYTHING!\r\n", ch);
      return;
    }
    if (dotmode == FIND_ALL) {
      if (!ch->carrying)
        send_to_char("You don't seem to be carrying anything.\r\n", ch);
      else
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          amount += perform_drop(ch, obj, mode, sname, RDR);
        }
    } else if (dotmode == FIND_ALLDOT) {
      if (!*arg) {
        cprintf(ch, "What do you want to %s all of?\r\n", sname);
        return;
d920 9
a928 3
      if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg))))
        cprintf(ch, "You don't seem to have any %s%s.\r\n", arg,
           isplural(arg) ? "" : "s");
d930 2
a931 2
        next_obj = find_obj_in_list(obj->next_content, find_vis_by_name(ch, arg));
        amount += perform_drop(ch, obj, mode, sname, RDR);
d934 9
a942 7
    } else {
      if (!(obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg) )))
        cprintf(ch, "You don't seem to have %s %s.\r\n", AN(arg), arg);
      else if (CONFUSED(ch) && number(0, 1) == 0)
        amount += drop_random_object(ch);
      else
        amount += perform_drop(ch, obj, mode, sname, RDR);
d944 20
a963 1
  }
d965 5
a969 5
  amount = 0;
  if (amount && (subcmd == SCMD_JUNK)) {
    send_to_char("You have been rewarded by the gods!\r\n", ch);
    act("$n has been rewarded by the gods!", TRUE, ch, 0, 0, TO_ROOM);
    GET_GOLD(ch) += amount;
d1058 1
a1058 1
    perform_drop(ch, obj, SCMD_LETDROP, "release", 0);
d1109 1
a1109 1
   if (GET_PLAT(ch) < coins[PLAT])
d1124 1
a1124 1
      GET_PLAT(ch)   -= coins[PLAT];
d1131 1
a1131 1
      obj = create_money(coins[PLAT], coins[GOLD], coins[SILVER], coins[COPPER]);
d1161 1
a1161 1
   GET_PLAT(vict) += coins[PLAT];
d1168 1
a1168 1
   if (coins[PLAT] > 50 || coins[GOLD] > 500) {
d1170 1
a1170 1
              GET_NAME(ch), coins[PLAT], coins[GOLD], GET_NAME(vict));
d1198 1
a1198 1
        cash[PLAT] += amount;
d2503 3
@


1.162
log
@Added functionality for removing messages from the new boards
to the remove command.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.161 2009/03/08 21:43:27 jps Exp myc $
d39 1
d2640 4
@


1.161
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.160 2009/03/03 19:41:50 myc Exp jps $
d38 1
d2261 1
a2261 1
  one_argument(argument, arg);
d2296 13
a2308 6
  else {
    if (!(obj = (find_obj_in_eq(ch, &where, find_vis_by_name(ch, arg)))))
      cprintf(ch, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
    else
      perform_remove(ch, where);
  }
d2639 3
@


1.160
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.159 2009/01/16 23:36:34 myc Exp myc $
d37 1
d2631 3
@


1.159
log
@Fix possible use of uninitialized variable in do_palm().
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.158 2008/09/29 03:24:44 jps Exp myc $
a50 1
obj_data *get_object_in_equip(char_data * ch, char *name, int *i);
d138 2
a139 2
  else if (!*arg2) {
    sprintf(buf, "What do you want to put %s in?\r\n",
d141 1
a141 2
    send_to_char(buf, ch);
  } else if (CONFUSED(ch)) {
d143 1
a143 2
    return;
  } else {
d145 3
a147 4
    if (!cont) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
    } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
d153 3
a155 4
        if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
          sprintf(buf, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
          send_to_char(buf, ch);
        } else if (obj == cont)
d171 3
a173 5
          else {
            sprintf(buf, "You don't seem to have any %s%s.\r\n", arg1,
            isplural(arg1) ? "" : "s");
            send_to_char(buf, ch);
          }
d215 2
a216 4
    if (*arg2 && !cont) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
    }
d222 2
a223 4
      if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
        sprintf(buf, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
        send_to_char(buf, ch);
      }
d398 1
a398 1
    if (!(obj = get_obj_in_list_vis(ch, arg, cont->contains))) {
d484 7
a490 9
    if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
      return;
    } else if (CONFUSED(ch) && number(0, 1) == 0) {
          send_to_char("&5You fumble haphazardly...&0\r\n", ch);
          get_random_object(ch);
      } else
         perform_get_from_room(ch, obj);
d597 2
a598 2
        else {
          sprintf(buf, "You can't seem to find any %s%s here.\r\n", arg2,
a599 2
          send_to_char(buf, ch);
        }
d636 2
a637 4
    if (!(obj = get_obj_in_list_vis(ch, arg1, world[ch->in_room].contents))) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg1), arg1);
      send_to_char(buf, ch);
    }
d681 2
a682 4
    if (!cont) {
      sprintf(buf, "You can't find %s %s.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
    }
d688 1
a688 1
      if (!(obj = get_obj_in_list_vis(ch, arg1, cont->contains))) {
d1078 1
a1078 2
        sprintf(buf, "What do you want to %s all of?\r\n", sname);
        send_to_char(buf, ch);
d1081 2
a1082 2
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf, "You don't seem to have any %s%s.\r\n", arg,
a1083 2
        send_to_char(buf, ch);
      }
d1085 1
a1085 1
        next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
d1090 6
a1095 8
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        send_to_char(buf, ch);
      } else
        if (CONFUSED(ch) && number(0, 1) == 0)
          amount += drop_random_object(ch);
        else
          amount += perform_drop(ch, obj, mode, sname, RDR);
d1217 1
a1217 1
  } else if (!(vict = get_char_room_vis(ch, arg))) {
d1375 1
a1375 1
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d1377 1
a1377 1
          sprintf(buf, "You don't seem to have a %s.\r\n", arg);
d1379 1
a1379 2
          sprintf(buf, "You don't seem to have %d %ss.\r\n", amount, arg);
        send_to_char(buf, ch);
d1418 2
a1419 4
      if (dotmode == FIND_ALLDOT) {
        sprintf(buf, "You don't even have one %s!\r\n", arg);
        send_to_char(buf, ch);
      }
d1456 2
a1457 2
  if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    if (!(temp = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
d1570 2
a1571 3
  if (!(food = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
d1671 1
a1671 1
    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d1685 1
a1685 1
    if (!(to_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d1697 1
a1697 1
    if (!(from_obj = get_obj_in_list_vis(ch, arg2, world[ch->in_room].contents))) {
d1722 1
a1722 1
    if (!(to_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
d2011 2
a2012 2
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %s%s.\r\n", arg1,
d2014 1
a2014 2
      send_to_char(buf, ch);
    } else {
d2016 1
a2016 1
        next_obj = get_obj_in_list_vis(ch, arg1, obj->next_content);
d2029 1
a2029 1
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d2058 1
a2058 1
   if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d2110 12
d2125 1
a2125 1
   int i;
d2143 7
a2149 5
   if (!(obj = (get_object_in_equip(ch, arg, &i))) &&
         !(obj = get_obj_in_list_vis(ch, arg, ch->carrying)) &&
         !((obj = get_obj_in_list(arg, ch->carrying)) && GET_OBJ_TYPE(obj) == ITEM_LIGHT)) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
d2207 2
d2211 3
d2216 4
a2219 6
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)) &&
           !((obj = get_obj_in_list(arg, ch->carrying)) &&
             GET_OBJ_TYPE(obj) == ITEM_LIGHT)) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
d2288 2
a2289 2
      if (!found) {
        sprintf(buf, "You don't seem to be using any %s%s.\r\n", arg,
a2290 2
        send_to_char(buf, ch);
      }
d2295 2
a2296 4
    if ((obj = (get_object_in_equip(ch, arg, &where))) == NULL) {
      sprintf(buf, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    }
d2406 1
a2406 1
  else if (ch->in_room == NOWHERE || !(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents)))
d2494 2
a2495 1
   else if (ch->in_room == NOWHERE || !(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents)))
d2521 4
a2524 8
  else if (!(obj1 = get_obj_in_list_vis(ch, buf1, ch->carrying))) {
    sprintf(buf, "You don't have a %s.\r\n", buf1);
    send_to_char(buf, ch);
  }
  else if (!(obj2 = get_obj_in_list_vis(ch, buf2, ch->carrying))) {
    sprintf(buf, "You don't have a %s.\r\n", buf2);
    send_to_char(buf, ch);
  }
d2630 3
@


1.158
log
@Make container weight automatic. Move some liquid container functions to objects.c.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.157 2008/09/22 02:09:17 jps Exp jps $
d625 1
a625 1
  int obj_dotmode, cont_dotmode, cont_mode, roll;
a656 1
      int roll = conceal_roll(ch, obj);
d658 1
d2649 3
@


1.157
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.156 2008/09/20 06:05:06 jps Exp jps $
a1464 183
void weight_change_object(struct obj_data * obj, float weight)
{
  struct obj_data *tmp_obj;
  struct char_data *tmp_ch;

  if (obj->in_room != NOWHERE) {
    GET_OBJ_WEIGHT(obj) += weight;
  } else if ((tmp_ch = obj->carried_by)) {
    obj_from_char(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_char(obj, tmp_ch);
  } else if ((tmp_obj = obj->in_obj)) {
    obj_from_obj(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_obj(obj, tmp_obj);
  } else {
    log("SYSERR: Unknown attempt to subtract weight from an object.");
  }
}

#define REPLACE_OBJ_STR(obj, strname, newstr) do {\
      if (GET_OBJ_RNUM(obj) == NOTHING || (obj)->strname != obj_proto[GET_OBJ_RNUM(obj)].strname) \
         free((obj)->strname); \
      (obj)->strname = newstr; \
   } while (0)

/* NAME_FROM_DRINKCON
 *
 * Called when a liquid container becomes empty.
 *
 * It will remove the first name from the object's aliases, if it is
 * the same as the name of the liquid.
 */

void name_from_drinkcon(struct obj_data *obj, int type)
{
   int aliaslen;
   char *new_name;

   if (!VALID_LIQ_TYPE(type)) return;

   aliaslen = strlen(LIQ_NAME(type));

   if (strlen(obj->name) > aliaslen + 1 &&
         /* The aliases are long enough to have more than just the drink name */
         (obj->name)[aliaslen] == ' ' &&
         /* An alias terminates just where the drink name should */
         !strncmp(LIQ_NAME(type), obj->name, aliaslen))
         /* Same string: we are go for removal */
   {
      new_name = strdup((obj->name) + aliaslen + 1);
      REPLACE_OBJ_STR(obj, name, new_name);
   }
}

void name_to_drinkcon(struct obj_data * obj, int type)
{
  char *new_name;

  if (!VALID_LIQ_TYPE(type) || isname(LIQ_NAME(type), obj->name))
    return;

  CREATE(new_name, char, strlen(obj->name) + strlen(LIQ_NAME(type)) + 2);
  sprintf(new_name, "%s %s", LIQ_NAME(type), obj->name);
  REPLACE_OBJ_STR(obj, name, new_name);
}

/* SETUP_DRINKCON
 *
 * Call this when:
 *
 *   1. The object is first created. Pass (obj, -1)
 *   2. The object becomes empty.    Pass (obj, 0)
 *   3. The object's liquid changes. Pass (obj, liquid)
 *
 * Parameter:
 *
 *     newliq      The liquid that the container's going to be
 *                 carrying.  Set this to -1 if the liquid is not
 *                 changing.
 *
 * It does the following:
 *
 * -- makes certain that the alias list begins with the liquid name
 * -- applies the special "action desc" settings, as follows:
 *
 *    *nl <string>  - string is processed to become obj->name (aliases)
 *    *sl <string>  - string is processed to become short description
 *    *ll <string>  - string is processed to become long description
 *
 *    *ne <string>  - same as *nl, but when the container is empty
 *    *se <string>  - as *sl, empty
 *    *le <string>  - as *ll, empty
 *
 * The format codes for the action desc settings are:
 *
 *    $l  - Replaced with the liquid name
 *
 * It always attempts to change the aliases (obj->name). If the action
 * desc specifies *nl and/or *ne, those will override the default aliases.
 */

void setup_drinkcon(struct obj_data *obj, int newliq)
{
   char *line, *adesc, *newtext;

   /* Ensure that the namelist begins with the drink name.
    * This effort will be undone if the action desc so directs,
    * but that's ok. */
   if (newliq < 0)
      newliq = GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID);

   /* First get the old liquid's name out of the object's aliases. */
   /* This is done when the liquid is changing, or the container is empty. */
   if (newliq != GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID) ||
       GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING) == 0) {
      name_from_drinkcon(obj, GET_OBJ_VAL(obj, 2));
      GET_OBJ_VAL(obj, 2) = newliq;
   }

   /* Put the drink name only if there is some liquid inside. */
   if (GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING) > 0)
      name_to_drinkcon(obj, GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID));

   /* Get ready to process the action description. */
   adesc = obj->action_description;
   if (!adesc || !*adesc)
      return;

   /* Loop to process each line of text in the action description */
   while (*adesc) {
      if (!(line = next_line(&adesc))) break;
      /* We must subsequently free line else cause a memory leak. */

      if (strlen(line) > 4 && line[0] == '*' && line[3] == ' ') {
         if (line[2] != 'e' && line[2] != 'l') {
            sprintf(buf, "Error setting up drinkcon %d: expected 'l' or 'e' in adesc, but got #%d",
                  GET_OBJ_VNUM(obj), line[2]);
            mudlog(buf, BRF, LVL_IMMORT, TRUE);
         } else {
            if (line[2] == 'l' && GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING) > 0) {
               /* Processing input line with liquid present */
               newtext = strdup(line + 4);

               /* Ignore the return value of replace_str, because it's ok
                * for no replacements to occur. */
               replace_str(&newtext, "$l", LIQ_NAME(GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID)), 1, 190);
            } else if (line[2] == 'e' && GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING) == 0) {
               /* Processing input line when empty */
               newtext = strdup(line + 4);

               /* Just a copy, nothing else to do */
            } else {
               /* Since l/e doesn't match current fill state, ignore this line */
               goto ADESC_LINE;
            }

            /* newtext now contains the processed string. It is ready for
             * insertion into the object. */
            switch (line[1]) {
               case 'n':
                  REPLACE_OBJ_STR(obj, name, newtext);
                  break;
               case 's':
                  REPLACE_OBJ_STR(obj, short_description, newtext);
                  break;
               case 'l':
                  REPLACE_OBJ_STR(obj, description, newtext);
                  break;
               default:
                  sprintf(buf, "Error setting up drinkcon %d: expected 'n', 's', or 'l' in adesc, but got #%d",
                        GET_OBJ_VNUM(obj), line[1]);
                  mudlog(buf, BRF, LVL_IMMORT, TRUE);
                  free(newtext);
            }
         }
      }
ADESC_LINE:
      free(line);
   }
}
#undef REPLACE_OBJ_STR

d1469 1
a1469 2
  int amount;
  float weight;
d1509 1
a1509 1
  if (GET_COND(ch, THIRST) > 20) {
d1529 2
a1530 5
    if (LIQ_COND(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID), DRUNK) > 0)
      amount = (25 - GET_COND(ch, THIRST)) / LIQ_COND(GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID), DRUNK);
    else
      amount = number(1, 3);

d1540 1
a1540 3
  weight = MIN(amount, GET_OBJ_WEIGHT(temp));

  weight_change_object(temp, -weight);        /* Subtract amount */
d1573 1
a1573 1
  /* This will restore movement points, such that a drink of size 24
d1575 1
a1575 1
  alter_move(ch, - MIN(200, GET_MAX_MOVE(ch) * amount / 24));
a1576 6
  /* empty the container, and no longer poison. */
  GET_OBJ_VAL(temp, VAL_DRINKCON_REMAINING) -= amount;
  if (!GET_OBJ_VAL(temp, VAL_DRINKCON_REMAINING)) {        /* The last bit */
     GET_OBJ_VAL(temp, VAL_DRINKCON_POISONED) = FALSE;
     setup_drinkcon(temp, 0);
  }
d1646 1
a1646 1
  /* This will restore hit points, such that a drink of size 24
d1747 1
a1747 7

      weight_change_object(from_obj, -GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING)); /* Empty */

      GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING) = 0;
      GET_OBJ_VAL(from_obj, VAL_DRINKCON_POISONED) = FALSE;
      setup_drinkcon(from_obj, 0);

d1786 3
a1788 5
  GET_OBJ_VAL(to_obj, VAL_DRINKCON_REMAINING) += amount;
  GET_OBJ_VAL(to_obj, VAL_DRINKCON_POISONED) = IS_POISONED(to_obj) || IS_POISONED(from_obj);

  weight_change_object(to_obj, amount);        /* Add weight */
  setup_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2));
d1791 1
a1791 7
     GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING) -= amount;
     weight_change_object(from_obj, -amount);
     if (GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING) < 1) {  /* It's now empty */
       GET_OBJ_VAL(from_obj, VAL_DRINKCON_REMAINING) = 0;
       GET_OBJ_VAL(from_obj, VAL_DRINKCON_POISONED) = FALSE;
       setup_drinkcon(from_obj, 0);
    }
d2649 4
@


1.156
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.155 2008/09/09 08:23:37 jps Exp jps $
d1465 1
a1465 1
void weight_change_object(struct obj_data * obj, int weight)
d1652 2
a1653 1
  int amount, weight;
d2858 3
@


1.155
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.154 2008/09/07 01:29:12 jps Exp jps $
d1162 1
a1162 1
                          GET_LEVEL((ch)->desc->original)>=LVL_IMPL))) {
d2857 3
@


1.154
log
@You can't be given enough weight to make you fall from flying.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.153 2008/09/03 17:34:08 myc Exp jps $
d2655 1
a2655 1
        else if (OUTSIDE(ch))
d2663 1
a2663 1
        else if (OUTSIDE(ch))
d2857 3
@


1.153
log
@Moved liquid information into a def struct array.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.152 2008/09/02 06:52:30 jps Exp myc $
d1174 4
d2857 3
@


1.152
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.151 2008/09/01 22:15:59 jps Exp jps $
d1500 1
a1500 1
   if (type < 0 || type >= NUM_LIQ_TYPES) return;
d1502 1
a1502 1
   aliaslen = strlen(drinks[type]);
d1508 1
a1508 1
         !strncmp(drinks[type], obj->name, aliaslen))
d1520 1
a1520 1
  if (type < 0 || type >= NUM_LIQ_TYPES || isname(drinks[type], obj->name))
d1523 2
a1524 2
  CREATE(new_name, char, strlen(obj->name) + strlen(drinks[type]) + 2);
  sprintf(new_name, "%s %s", drinks[type], obj->name);
d1607 1
a1607 1
               replace_str(&newtext, "$l", drinks[GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID)], 1, 190);
d1702 1
a1702 1
    sprintf(buf, "$n drinks %s from $p.", drinks[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)]);
d1705 1
a1705 1
    sprintf(buf, "You drink the %s.\r\n", drinks[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)]);
d1708 2
a1709 2
    if (drink_aff[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)][DRUNK] > 0)
      amount = (25 - GET_COND(ch, THIRST)) / drink_aff[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)][DRUNK];
d1715 1
a1715 2
    sprintf(buf, "It tastes like %s.\r\n", drinks[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)]);
    send_to_char(buf, ch);
d1727 1
a1727 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)][DRUNK] * amount) / 4);
d1730 1
a1730 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)][FULL] * amount) / 1);
d1733 1
a1733 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, VAL_DRINKCON_LIQUID)][THIRST] * amount) / 1);
d1969 3
a1971 5
  if (subcmd == SCMD_POUR) {
    sprintf(buf, "You pour the %s into the %s.\r\n",
            drinks[GET_OBJ_VAL(from_obj, VAL_DRINKCON_LIQUID)], arg2);
    send_to_char(buf, ch);
  }
d2853 3
@


1.151
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.150 2008/08/31 01:19:54 jps Exp jps $
d36 1
d2856 3
@


1.150
log
@You screwed up holding items in slots with two of the same position!
Fix.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.149 2008/08/30 22:02:42 myc Exp jps $
d554 1
a554 1
    save_objects(ch, SAVE_AUTO);
d570 1
a570 1
        save_objects(ch, SAVE_AUTO);
d605 1
a605 1
        save_objects(ch, SAVE_AUTO);
d2855 4
@


1.149
log
@Actions affecting corpses just go to the syslog now, not the RIP log.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.148 2008/08/30 21:55:50 myc Exp myc $
d2114 1
a2114 1
   if (!may_wear_eq(ch, obj, where, !collective))
d2855 3
@


1.148
log
@Players retrieving items from their corpse won't be logged to the RIP
log anymore.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.147 2008/08/30 20:51:38 jps Exp myc $
d744 4
a747 9
            /* Note: killed is the keyword that autorun greps for to sort
             *       corpse info into the rip log.  This will so bust
             *       players who claim the game ate their corpse. */
            if (IS_PLR_CORPSE(cont)) {
              sprintf(buf, "killed: %s palms %s from %s.", GET_NAME(ch),
                    strip_ansi(obj->short_description),
                    cont->short_description);
              log(buf);
            }
d2855 4
@


1.147
log
@Fix wearing bug.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.146 2008/08/30 20:25:38 jps Exp jps $
d383 4
a386 10
        if (IS_PLR_CORPSE(cont)) {
          /* Note: killed is the keyword autorun greps on to sort corpse info
           *       into the rip log.  This will so bust players who claim the
           *       game ate their corpse.
           */
          sprintf(buf, "killed: %s gets %s from %s.", GET_NAME(ch),
                  strip_ansi(obj->short_description),
                  cont->short_description);
          log(buf);
        }
d2860 3
@


1.146
log
@Moved count_hand_eq() into handler.c and mentioned it in handler.h.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.145 2008/08/30 20:21:07 jps Exp jps $
d2125 1
a2125 1
   if (may_wear_eq(ch, obj, where, !collective))
d2866 3
@


1.145
log
@Moved equipment-wearability checks into function may_wear_eq() and moved
it to handler.c.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.144 2008/08/30 18:20:53 myc Exp jps $
a79 10
void count_hand_eq(struct char_data *ch, int *hands_used, int *weapon_hands_used) {
   *hands_used = *weapon_hands_used = 0;
   if (GET_EQ(ch, WEAR_2HWIELD)) { (*hands_used) += 2; (*weapon_hands_used) += 2; }
   if (GET_EQ(ch, WEAR_HOLD))    (*hands_used)++;
   if (GET_EQ(ch, WEAR_HOLD2))   (*hands_used)++;
   if (GET_EQ(ch, WEAR_SHIELD))  (*hands_used)++;
   if (GET_EQ(ch, WEAR_WIELD))   { (*hands_used)++; (*weapon_hands_used)++; }
   if (GET_EQ(ch, WEAR_WIELD2))  { (*hands_used)++; (*weapon_hands_used)++; }
}

d2866 4
@


1.144
log
@Changed rnum check for an object to use NOTHING constant.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.143 2008/08/19 02:11:14 jps Exp myc $
d2119 1
d2135 1
a2135 128
  int a = 0, w = 0;
  /*
   * ITEM_WEAR_TAKE is used for objects that do not require special bits
   * to be put into that position (e.g. you can hold any object, not just
   * an object with a HOLD bit.)
   */
  const int wear_bitvectors[] = {
    ITEM_WEAR_TAKE, ITEM_WEAR_FINGER, ITEM_WEAR_FINGER, ITEM_WEAR_NECK,
    ITEM_WEAR_NECK, ITEM_WEAR_BODY, ITEM_WEAR_HEAD, ITEM_WEAR_LEGS,
    ITEM_WEAR_FEET, ITEM_WEAR_HANDS, ITEM_WEAR_ARMS, ITEM_WEAR_SHIELD,
    ITEM_WEAR_ABOUT, ITEM_WEAR_WAIST, ITEM_WEAR_WRIST, ITEM_WEAR_WRIST,
    ITEM_WEAR_WIELD, ITEM_WEAR_WIELD, ITEM_WEAR_HOLD, ITEM_WEAR_HOLD,
    ITEM_WEAR_2HWIELD, ITEM_WEAR_EYES, ITEM_WEAR_FACE, ITEM_WEAR_EAR,
    ITEM_WEAR_EAR, ITEM_WEAR_BADGE, ITEM_WEAR_OBELT
  };

  char *already_wearing[] = {
    "You're already using a light.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something on both of your ring fingers.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You can't wear anything else around your neck.\r\n",
    "You're already wearing something on your body.\r\n",
    "You're already wearing something on your head.\r\n",
    "You're already wearing something on your legs.\r\n",
    "You're already wearing something on your feet.\r\n",
    "You're already wearing something on your hands.\r\n",
    "You're already wearing something on your arms.\r\n",
    "You're already using a shield.\r\n",
    "You're already wearing something about your body.\r\n",
    "You already have something around your waist.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something around both of your wrists.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already wielding a weapon there!\r\n",
    "You're already holding something.\r\n",
    "You're already holding something.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already wearing something on your eyes.\r\n",
    "You're already wearing something on your face.\r\n",
    "YOU SHOULD NEVER SEE THIS REPORT IT!.\r\n",
    "You're already wearing something in both of your ears.\r\n",
    "You're already wearing a badge.\r\n",
    "You can't attach any more to your belt.\r\n"
  };

   /* first, make sure that the wear position is valid. */
   /* Only allow light items in the light pos, and then only
      when they cannot be worn anywhere else - myc 5 Dec 2006 */
   if (!CAN_WEAR(obj, wear_bitvectors[where]) ||
         (where == 0 && GET_OBJ_TYPE(obj) != ITEM_LIGHT) ||
         (where == 0 && GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
         GET_OBJ_WEAR(obj) != ITEM_WEAR_TAKE + ITEM_WEAR_HOLD)) {
      if (!(IS_NPC(ch)) && !collective)
         act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
      return FALSE;
  }

   /* Check the level of the object. Zantir 3/23/01 */
   if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
      if (!IS_NPC(ch) && !collective) {
         act("You're not a high enough level to use $p.",
             FALSE, ch, obj, 0, TO_CHAR);
         act("$n struggles and fails to use $p.", TRUE, ch, obj, 0, TO_ROOM);
      }
      return FALSE;
   }

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      /* Check alignment restrictions. */
      if ((OBJ_FLAGGED(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
          (OBJ_FLAGGED(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
          (OBJ_FLAGGED(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
           NOWEAR_CLASS(ch, obj)) {
         if (!collective)
            act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
         return FALSE;
      }

      if (GET_OBJ_TYPE(obj)== ITEM_WEAPON && GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w) {
         if (!collective)
            send_to_char("It's too heavy for you to use.\r\n", ch);
         return FALSE;
      }
   }

   /* You can only wear something on your belt if you are wearing a belt. */
   if (where == WEAR_OBELT && !GET_EQ(ch, WEAR_WAIST)) {
      if (!collective)
         act("You'll need to wear a belt first.",
             FALSE, ch, obj, 0, TO_CHAR);
      return FALSE;
   }

   /* for neck, finger, wrist, held, and wielded, try pos 2 if pos 1 is already full */

   if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R) ||
         (where == WEAR_HOLD) || (where == WEAR_LEAR) || (where == WEAR_WIELD))
      if (GET_EQ(ch, where))
         where++;

   /* for shield, weapon, or held, must make sure the right number of hands are free */

   if ((where == WEAR_SHIELD) || (where == WEAR_WIELD) || (where == WEAR_WIELD2) ||
         (where == WEAR_HOLD) || (where == WEAR_HOLD2) || (where == WEAR_2HWIELD)) {

      /* a = hands occupied; w = hands wielding a weapon */
      count_hand_eq(ch, &a, &w);

      if ((GET_OBJ_WEAR(obj) & ITEM_WEAR_2HWIELD) && a) {
         if (!collective)
            send_to_char("You need both hands free for this weapon!\r\n",ch);
         return FALSE;
      } else if (a > 1) {
         if (!collective)
            send_to_char("Both of your hands are already using something.\r\n", ch);
         return FALSE;
      } else if (a == 1 && w > 0 && (where == WEAR_WIELD || where == WEAR_WIELD2) &&
            !(GET_SKILL(ch, SKILL_DUAL_WIELD))) {
         if (!collective)
            send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
         return FALSE;
      }
   }

   if (GET_EQ(ch, where)) {
      if (!collective)
         send_to_char(already_wearing[where], ch);
a2136 2
   }

d2876 3
@


1.143
log
@Don't apply fluid/rigidity restrictions to immortals.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.142 2008/08/18 01:35:38 jps Exp jps $
d1501 5
a1505 4
#define REPLACE_OBJ_STR(obj, strname, newstr) \
   if (GET_OBJ_RNUM(obj) < 0 || (obj)->strname != obj_proto[GET_OBJ_RNUM(obj)].strname) \
      free((obj)->strname); \
   (obj)->strname = newstr
d3004 3
@


1.142
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.141 2008/08/15 18:18:24 jps Exp jps $
d374 1
a374 1
  if (!SOLIDCHAR(ch) && cont->carried_by != ch) {
d457 1
a457 1
  if (!RIGID(ch)) {
d677 1
a677 1
      if (!SOLIDCHAR(ch))
d697 1
a697 1
      if (!SOLIDCHAR(ch))
d731 1
a731 1
          if (SOLIDCHAR(ch)) {
d755 1
a755 1
          if (SOLIDCHAR(ch)) {
d1215 1
a1215 1
  if (SOLIDCHAR(ch) && !SOLIDCHAR(vict)) {
d1304 1
a1304 1
   if (!SOLIDCHAR(vict)) {
d3003 3
@


1.141
log
@Don't exempt immortals from the need to wear a belt before wearing
an item on the belt.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.140 2008/07/27 05:14:02 jps Exp jps $
d1899 1
a1899 1
    send_to_char("You can't coordinate the maneuver while fighting!\n\r",ch);
d3003 4
@


1.140
log
@Changed the name of SAVE_CRASH to SAVE_AUTO.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.139 2008/07/21 19:28:35 jps Exp jps $
d2217 1
d2219 6
a2224 7
      /* You can only wear something on your belt if you are wearing a belt. */
      if (where == WEAR_OBELT && !GET_EQ(ch, WEAR_WAIST)) {
         if (!collective)
            act("You'll need to wear a belt first.",
                FALSE, ch, obj, 0, TO_CHAR);
         return FALSE;
      }
d3003 3
@


1.139
log
@Add Oxford comma to coin list.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.138 2008/07/10 20:11:36 myc Exp jps $
d570 1
a570 1
    save_objects(ch, SAVE_CRASH);
d586 1
a586 1
        save_objects(ch, SAVE_CRASH);
d621 1
a621 1
        save_objects(ch, SAVE_CRASH);
d3003 3
@


1.138
log
@Crash bug: can't move stuff directly between equipment positions!  Must
use equip_char/unequip_char.  In do_remove...was causing a crash at
rent-time.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.137 2008/06/07 19:06:46 myc Exp myc $
d333 1
a333 1
      sprintf(buf, "There were %d platinum, %d gold, %d silver and %d copper coins.\r\n",
d3003 5
@


1.137
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.136 2008/06/05 02:07:43 myc Exp myc $
d2675 2
a2676 4
  if (GET_EQ(ch, WEAR_WIELD2) && !GET_EQ(ch, WEAR_WIELD)) {
    GET_EQ(ch, WEAR_WIELD) = GET_EQ(ch, WEAR_WIELD2);
    GET_EQ(ch, WEAR_WIELD2) = NULL;
  }
d3003 3
@


1.136
log
@Changing object flags to use flagvectors.  Rewrote rent-saving code
to use ascii-format files.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.135 2008/05/18 05:39:59 jps Exp myc $
d95 1
a95 1
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
d107 2
a108 2
        GET_OBJ_VAL(obj, 0) == 1 &&
        GET_OBJ_VAL(obj, 2) >= 0) {
d162 1
a162 1
    else if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
d237 1
a237 1
    else if (cont && IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
d250 1
a250 1
      else if (cont && GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
d264 3
a266 3
              GET_OBJ_VAL(obj, 0) == 1 &&
              GET_OBJ_VAL(obj, 2) >= 0) {
            GET_OBJ_VAL(obj, 0) = 0;
d330 10
a339 7
    if (GET_OBJ_VAL(obj, 0)+GET_OBJ_VAL(obj, 1)+GET_OBJ_VAL(obj, 2)+GET_OBJ_VAL(obj, 3) == -1){
      return;}
    else{
      sprintf(buf, "There were %d platinum, %d gold, %d silver and %d copper coins.\r\n", GET_OBJ_VAL(obj, 0)
              , GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3));
      if (GET_OBJ_VAL(obj, 0)+GET_OBJ_VAL(obj, 1)+GET_OBJ_VAL(obj, 2)+GET_OBJ_VAL(obj, 3) == 0){
        sprintf(buf, "%sMust have been an illusion!\r\n", buf);}
d342 4
a345 4
    GET_PLAT(ch) += GET_OBJ_VAL(obj, 0);
    GET_GOLD(ch) += GET_OBJ_VAL(obj, 1);
    GET_SILVER(ch) += GET_OBJ_VAL(obj, 2);
    GET_COPPER(ch) += GET_OBJ_VAL(obj, 3);
d358 4
a361 4
  coins[PLAT] = GET_OBJ_VAL(obj, 0);
  coins[GOLD] = GET_OBJ_VAL(obj, 1);
  coins[SILVER] = GET_OBJ_VAL(obj, 2);
  coins[COPPER] = GET_OBJ_VAL(obj, 3);
d421 1
a421 1
  if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED)) {
d719 1
a719 1
    else if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
d1590 1
a1590 1
      newliq = GET_OBJ_VAL(obj, 2);
d1594 2
a1595 1
   if (newliq != GET_OBJ_VAL(obj, 2) || GET_OBJ_VAL(obj, 1) == 0) {
d1601 2
a1602 2
   if (GET_OBJ_VAL(obj, 1) > 0)
      name_to_drinkcon(obj, GET_OBJ_VAL(obj, 2));
d1620 1
a1620 1
            if (line[2] == 'l' && GET_OBJ_VAL(obj, 1) > 0) {
d1626 2
a1627 2
               replace_str(&newtext, "$l", drinks[GET_OBJ_VAL(obj, 2)], 1, 190);
            } else if (line[2] == 'e' && GET_OBJ_VAL(obj, 1) == 0) {
d1712 1
a1712 1
  if (!GET_OBJ_VAL(temp, 1)) {
d1721 1
a1721 1
    sprintf(buf, "$n drinks %s from $p.", drinks[GET_OBJ_VAL(temp, 2)]);
d1724 1
a1724 1
    sprintf(buf, "You drink the %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
d1727 2
a1728 2
    if (drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] > 0)
      amount = (25 - GET_COND(ch, THIRST)) / drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK];
d1734 1
a1734 1
    sprintf(buf, "It tastes like %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
d1739 1
a1739 1
  amount = MIN(amount, GET_OBJ_VAL(temp, 1));
d1747 1
a1747 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);
d1750 1
a1750 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][FULL] * amount) / 1);
d1753 1
a1753 1
                 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 1);
d1782 3
a1784 3
  GET_OBJ_VAL(temp, 1) -= amount;
  if (!GET_OBJ_VAL(temp, 1)) {        /* The last bit */
     IS_POISONED(temp) = FALSE;
d1837 1
a1837 1
  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, 0) : 1);
d1863 1
a1863 1
    if (!(--GET_OBJ_VAL(food, 0))) {
d1945 1
a1945 1
  if (GET_OBJ_VAL(from_obj, 1) == 0) {
d1958 1
a1958 1
      weight_change_object(from_obj, -GET_OBJ_VAL(from_obj, 1)); /* Empty */
d1960 2
a1961 2
      GET_OBJ_VAL(from_obj, 1) = 0;
      IS_POISONED(from_obj) = FALSE;
d1980 2
a1981 2
  if ((GET_OBJ_VAL(to_obj, 1) != 0) &&
      (GET_OBJ_VAL(to_obj, 2) != GET_OBJ_VAL(from_obj, 2))) {
d1985 1
a1985 1
  if (!(GET_OBJ_VAL(to_obj, 1) < GET_OBJ_VAL(to_obj, 0))) {
d1991 1
a1991 1
            drinks[GET_OBJ_VAL(from_obj, 2)], arg2);
d2000 3
a2002 4
  amount = MIN(GET_OBJ_VAL(to_obj, 0) - GET_OBJ_VAL(to_obj, 1),
        GET_OBJ_VAL(from_obj, 1));

  GET_OBJ_VAL(to_obj, 1) += amount;
d2004 2
a2005 1
  IS_POISONED(to_obj) = IS_POISONED(to_obj) || IS_POISONED(from_obj);
d2011 1
a2011 1
     GET_OBJ_VAL(from_obj, 1) -= amount;
d2013 3
a2015 3
     if (GET_OBJ_VAL(from_obj, 1) < 1) {  /* It's now empty */
       GET_OBJ_VAL(from_obj, 1) = 0;
       IS_POISONED(from_obj) = FALSE;
d2532 1
a2532 1
   if (GET_OBJ_VAL(obj, 0) == 0) {   /* It is not lit */
d2539 2
a2540 2
      if (GET_OBJ_VAL(obj, 2) != 0) {  /* It is not worn out */
         if (GET_OBJ_VAL(obj, 2) < 0) {  /* It's a permanent light */
d2547 1
a2547 1
         GET_OBJ_VAL(obj, 0) = 1;  /* Now it's lit */
d2556 1
a2556 1
      if (GET_OBJ_VAL(obj, 2) < 0) {  /* It's a permanent light */
d2563 2
a2564 2
      GET_OBJ_VAL(obj, 0) = 0;
      if (GET_OBJ_VAL(obj, 2) != 0) {
d2790 4
a2793 2
  else if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1)
    act("You should probably $T the $o before attempting to conceal it.", FALSE, ch, obj, GET_OBJ_VAL(obj, 2) >= 0 ? "extinguish" : "deactivate", TO_CHAR);
d2906 2
a2907 1
      if (GET_OBJ_VAL(obj1, 2) == -1 || GET_OBJ_VAL(obj2, 2) == -1)
d2909 1
a2909 1
      else if (GET_OBJ_VAL(obj1, 2) == GET_OBJ_VAL(obj2, 2))
d2912 1
a2912 1
        if (GET_OBJ_VAL(obj1, 2) < GET_OBJ_VAL(obj2, 2))
d2920 1
a2920 1
          (IS_WEAPON_BLUDGEONING(obj1) && !IS_WEAPON_BLUDGEONING(obj2)))
d2934 1
a2934 1
      else if (GET_OBJ_VAL(obj1, 2) == GET_OBJ_VAL(obj2, 2))
d2937 1
a2937 1
        if (GET_OBJ_VAL(obj1, 2) < GET_OBJ_VAL(obj2, 2))
d2953 1
a2953 1
      if (GET_OBJ_VAL(obj1, 0) == GET_OBJ_VAL(obj2, 0))
d2956 1
a2956 1
        if (GET_OBJ_VAL(obj1, 0) < GET_OBJ_VAL(obj2, 0))
d2964 1
a2964 1
      if (GET_OBJ_VAL(obj1, 0) == GET_OBJ_VAL(obj2, 0))
d2967 1
a2967 1
        if (GET_OBJ_VAL(obj1, 0) < GET_OBJ_VAL(obj2, 0))
d2973 1
a2973 1
      if (GET_OBJ_VAL(obj1, 0) == GET_OBJ_VAL(obj2, 0))
d2976 1
a2976 1
        if (GET_OBJ_VAL(obj1, 0) < GET_OBJ_VAL(obj2, 0))
d3005 4
@


1.135
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.134 2008/05/14 05:10:28 jps Exp jps $
d97 1
a97 1
  else if (IS_OBJ_STAT(obj, ITEM_NODROP))
d248 1
a248 1
      else if (IS_OBJ_STAT(obj, ITEM_NODROP))
d321 1
a321 1
    if (!IS_OBJ_STAT(obj, ITEM_WAS_DISARMED))
d563 1
a563 1
  else if ((IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) && (!(GET_LEVEL(ch) >= LVL_IMMORT)))
d565 1
a565 1
  else if (!*arg2)
d567 3
a569 1
  else if (CONFUSED(ch)) {
d571 1
a571 2
    return;
  } else {
d578 2
a579 1
      } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER) {
d581 3
a583 13
      } else {
        /* Added functionality to check for consent to prevent players from
         * looting each others corpses. Zzur 8/7/1999
          */
        if(!IS_PLR_CORPSE(cont)) {
          get_from_container(ch, cont, arg1, mode);
        } else {
          if(corpse_consent(ch, cont)) {
            get_from_container(ch, cont, arg1, mode);
          } else {
            return;
          }
        }
d585 2
a586 1
    } else {
d609 1
a609 1
            if(!IS_PLR_CORPSE(cont)) {
a610 5
            } else {
              if(corpse_consent(ch, cont)) {
                get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
              }
            }
d617 3
a619 1
      if (!found) {
d624 1
a624 1
           isplural(arg2) ? "" : "s");
a626 1
        return;
a629 1
  Crash_crashsave(ch);
d782 1
a782 1
  sprintf(buf,"corpse %s", GET_NAME(ch));
d786 1
a786 1
  } else if(!str_cmp(buf,cont->name)) {
d796 2
a797 2
        sprintf(buf,"corpse %s", GET_NAME(d->character));
        if (!str_cmp(buf,cont->name) && CONSENT(d->character) == ch) {
d804 1
a804 1
  if(!done)
d870 1
a870 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100) {
d893 1
a893 1
  if ((mode == SCMD_DONATE) && IS_OBJ_STAT(obj, ITEM_NODONATE))
d1177 1
a1177 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100
d2199 3
a2201 3
      if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
          (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
          (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
d2701 1
a2701 1
   if (IS_SET(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED)) {
d2750 1
a2750 1
      REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED);
d2998 3
@


1.134
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.133 2008/05/11 05:42:46 jps Exp jps $
d2878 1
a2878 1
         GET_HOME(ch) = world[ch->in_room].number;
d3010 3
@


1.133
log
@Using regen.h. alter_hit() now takes the attacker.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.132 2008/04/13 21:57:17 jps Exp jps $
d1866 1
a1866 1
  alter_hit(ch, 0, - MIN(70, GET_MAX_HIT(ch) * amount / 72), TRUE);
d3010 3
@


1.132
log
@Made it more difficult to manipulate objects when confused.
You usually can't do "all.", and you will frequently fumble
and choose the wrong object. You can't conceal or stow.
Moved do_doorbash to act.movement.c
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.131 2008/04/13 10:03:27 jps Exp jps $
d35 1
d1866 1
a1866 1
  alter_hit(ch, - MIN(70, GET_MAX_HIT(ch) * amount / 72), TRUE);
d3010 6
@


1.131
log
@Don't send the message about object becoming solid again when
you're junking it.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.130 2008/04/13 01:53:46 jps Exp jps $
d151 3
d206 5
a450 1

d480 17
d510 5
a514 2
    } else
      perform_get_from_room(ch, obj);
d525 10
d566 4
a569 1
  else {
d652 5
a862 1

d935 39
a976 4
#if 0
  extern int donation_room_2;  /* uncomment if needed! */
  extern int donation_room_3;  /* uncomment if needed! */
#endif
d987 4
d1144 4
a1147 1
        amount += perform_drop(ch, obj, mode, sname, RDR);
a1184 3



d1431 1
d1441 4
a1444 1
  else {
a2360 2
  /* No more animals wearing eq. */

d2376 4
d2396 4
d2422 1
d2424 2
a2425 1
    else if ((where = find_eq_pos(ch, obj, arg2)) >= 0)
d2490 1
d2495 1
d2529 2
d2593 1
a2698 170
ACMD(do_doorbash)
     /* BURU 5/12/97 */
     /*Changed to a skill to allow multi_assigning to races in class.c */
     /*Banyal*/
#define EXITK(room, dir) (world[room].dir_option[dir])
#define OPEN_DOORK(room, door) (TOGGLE_BIT(EXITK(room, door)->exit_info,EX_CLOSED))
{
  char arg[MAX_INPUT_LENGTH];
  int dir = 0, percent, temp, race;

  one_argument(argument, arg);
  percent = number(0, 101);
  temp = percent + GET_LEVEL(ch);

  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    temp = 101;
  }
  if (GET_SKILL(ch, SKILL_DOORBASH) == 0 && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You don't have that skill.", ch);
    return;
  }
  if (!*arg && ((GET_SKILL(ch, SKILL_DOORBASH)) || (GET_LEVEL(ch) >= LVL_IMMORT))) {
    send_to_char("&0What direction?&0\r\n", ch);
    return;
  }
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (FIGHTING(ch)) {
      send_to_char("You can't take time out to do that just yet!\n\r",ch);
      return ;
    }
    race = GET_RACE(ch);
    if((race != RACE_TROLL) && (race != RACE_OGRE) && (race != RACE_BARBARIAN)) {
      send_to_char("&0You do not feel massive enough!&0\r\n", ch);
      return;
    }
  }

  if (*arg){
    switch (*arg) {
    case 'n':
    case 'N':
      dir = 0;
      break;
    case 'e':
    case 'E':
      dir = 1;
      break;
    case 's':
    case 'S':
      dir = 2;
      break;
    case 'w':
    case 'W':
      dir = 3;
      break;
    case 'u':
    case 'U':
      dir = 4;
      break;
    case 'd':
    case 'D':
      dir = 5;
      break;
    default:
      send_to_char("Doorbash where?\r\n", ch);
      return;
      break;
    }
  }

  if ((GET_SKILL(ch, SKILL_DOORBASH) || (GET_LEVEL(ch) >= LVL_IMMORT))) {
    if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) {
      send_to_char("&0Even YOU couldn't bash through that!...\r\n&0", ch);
      return;
    }
    if (EXIT(ch, dir) && EXIT(ch, dir)->to_room != NOWHERE &&
        !IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
      send_to_char("&0There is no obstruction!&0\r\n", ch);
      return;
    }
    if(EXIT(ch, dir)->keyword == NULL) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A one sided door in room %d", world[ch->in_room].number);
      log(buf);
      send_to_char("&0This exit seems broken, tell a god.&0\r\n", ch);
      return;
    }
    else if(!IS_SET(EXIT(ch, dir)->exit_info, EX_ISDOOR)) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A closed nondoor exit in room %d", world[ch->in_room].number);
      log(buf);
      send_to_char("&0This exit seems broken, tell a god.&0\r\n", ch);
      return;
    }

    if (EXIT(ch, dir)) {
      if (!(IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF))) {
        if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) ||
            (IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))) {
          if (temp < 80) {
            /*           improve_skill(ch, SKILL_DOORBASH); */
            sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n",
                    fname(EXIT(ch, dir)->keyword));
            send_to_char(buf, ch);
            sprintf(buf, "&0$n &0charges at the %s but simply bounces off!&0",
                    fname(EXIT(ch, dir)->keyword));
            act(buf, FALSE, ch, 0, 0, TO_ROOM);

            WAIT_STATE(ch, PULSE_VIOLENCE*3);
            if(GET_LEVEL(ch) < LVL_IMMORT) {
              if ((GET_HIT(ch) - (((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch))) > -5) {
                GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
                update_pos(ch);
              } else {
                GET_HIT(ch) = -5;
                update_pos(ch);
              }
              return;
            }
          }

          if (temp > 79) {
            /*           improve_skill(ch, SKILL_DOORBASH); */
            OPEN_DOORK(ch->in_room, dir);

            sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
            act(buf, FALSE, ch, 0, 0, TO_ROOM);
            sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n",
                    fname(EXIT(ch, dir)->keyword));
            send_to_char(buf, ch);
            sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
            act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);

            if (world[EXIT(ch, dir)->to_room].dir_option[rev_dir[dir]]) {
              OPEN_DOORK(EXIT(ch, dir)->to_room, rev_dir[dir]);
              WAIT_STATE(ch, PULSE_VIOLENCE);
              perform_move(ch, dir, 1, FALSE);
            } else {
              WAIT_STATE(ch, PULSE_VIOLENCE);
              perform_move(ch, dir, 1, FALSE);
              return;
            }


          }
          return;
        }
      } else {
        /*       improve_skill(ch, SKILL_DOORBASH); */

        sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n",
                fname(EXIT(ch, dir)->keyword));
        send_to_char(buf, ch);
        sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0",
                fname(EXIT(ch, dir)->keyword));
        act(buf, FALSE, ch, 0, 0, TO_ROOM);

        WAIT_STATE(ch, PULSE_VIOLENCE*3);
        if(GET_LEVEL(ch) < LVL_IMMORT) {
          if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5) {
            GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
            update_pos(ch);
          } else {
            GET_HIT(ch) = -5;
            update_pos(ch);}
        }
        return;
      }
    }
  }
}

d2774 4
d3009 4
@


1.130
log
@Fix error message when you failed to give when using "all." or "all".
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.129 2008/04/08 02:13:48 jps Exp jps $
d860 4
a863 1
  if (!RIGID(ch))
a866 3
  if ((mode == SCMD_DONATE) && IS_OBJ_STAT(obj, ITEM_NODONATE))
    mode = SCMD_JUNK;

d3075 3
@


1.129
log
@Oops couldn't get objects out of containers.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.128 2008/04/06 19:47:00 jps Exp jps $
d37 5
a41 3
#define GIVE_SUCCESS 1
#define GIVE_FAIL 0
#define GIVE_FAIL_FULL 2
d1277 1
a1277 1
  int amount = 1, dotmode, result, i, counter = 0;
d1379 7
a1385 3
    if (dotmode == FIND_ALLDOT) {
      sprintf(buf, "You don't even have one %s!\r\n", arg);
      send_to_char(buf, ch);
a1386 2
    else if (dotmode == FIND_ALL)
      send_to_char("You don't seem to be holding anything.\r\n", ch);
d3075 3
@


1.128
log
@Use perform_drop when things fall because you gave them to fluid
people.  Thus drop triggers will run.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.127 2008/04/04 03:42:57 jps Exp jps $
d360 1
a360 1
  if (SOLIDCHAR(ch) && cont->carried_by != ch) {
d3071 4
@


1.127
log
@Add call to give_shopkeeper_reject().  Also allow passing objects
between two fluid creatures.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.126 2008/04/03 02:05:34 myc Exp jps $
d360 1
a360 1
  if (!RIGID(ch) && cont->carried_by != ch) {
d637 5
a641 1
      sprintf(buf, "%s coyly snatches $p off the ground.", GET_NAME(ch));
d658 12
a669 8
      if (people)
        act("You palm $p when you think no one is looking.", FALSE, ch, obj, 0, TO_CHAR);
      else
        act("You smoothly palm $p.", FALSE, ch, obj, 0, TO_CHAR);
      unhide_object(obj);
      get_check_money(ch, obj);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      improve_skill(ch, SKILL_CONCEAL);
d691 12
a702 5
          roll = conceal_roll(ch, obj);
          obj_from_obj(obj);
          obj_to_char(obj, ch);
          act("You quietly palm $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
          sprintf(buf, "%s quietly slips $p out of $P.", GET_NAME(ch));
d716 14
a729 11
          unhide_object(obj);
          get_check_money(ch, obj);
          WAIT_STATE(ch, PULSE_VIOLENCE);
          improve_skill(ch, SKILL_CONCEAL);
          /* Note: killed is the keyword that autorun greps for to sort
           *       corpse info into the rip log.  This will so bust
           *       players who claim the game ate their corpse.
           */
          if (IS_PLR_CORPSE(cont)) {
            sprintf(buf, "killed: %s palms %s from %s.", GET_NAME(ch), strip_ansi(obj->short_description), cont->short_description);
            log(buf);
d825 6
a830 1
  /* Possible modes here are SCMD_DROP, SCMD_JUNK, and SCMD_DONATE. */
d844 1
a844 1
  if (mode == SCMD_DROP) {
d851 7
a857 4
  sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
  act(buf, FALSE, ch, obj, 0, TO_CHAR);
  sprintf(buf, "$n %ss $p.%s", sname, VANISH(mode));
  act(buf, !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
d867 1
d1137 2
a1138 3
  if (!RIGID(vict) || MOB_FLAGGED(vict, MOB_ILLUSORY)) {
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
d1155 1
d1227 1
a1227 1
   if (MOB_FLAGGED(vict, MOB_ILLUSORY)) {
d3071 4
@


1.126
log
@Depending on screen.h now.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.125 2008/04/02 05:36:19 myc Exp myc $
d34 1
d1096 4
d1104 3
a1106 1
  if (!RIGID(ch))
d1138 2
a1139 1
    act("$n gives $p to $N.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, vict, TO_NOTVICT);
d3044 3
@


1.125
log
@Added the autosplit toggle, which causes players to automatically
split the coins they pick up from corpses.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.124 2008/03/30 17:30:38 jps Exp myc $
d33 1
d3036 4
@


1.124
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.123 2008/03/28 17:54:53 myc Exp jps $
d315 1
a315 1
  if ((GET_OBJ_TYPE(obj) == ITEM_MONEY)) {
d335 20
d387 4
a390 1
        get_check_money(ch, obj);
d3035 4
@


1.123
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.122 2008/03/26 23:31:34 jps Exp myc $
d32 1
a42 1
extern void Crash_crashsave(struct char_data *ch);
d3012 4
@


1.122
log
@Prevent handling of objects when in a fluid state.  If you drop
something, it becomes solid, and you can't pick it up again.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.121 2008/03/21 22:52:52 jps Exp jps $
d346 1
a346 1
      if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d427 1
a427 1
      if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d493 1
a493 6
  /* removed so PC's can retrieve slung weapons --gurlaek 11/21/1999
   *  if (IS_FIGHTING(ch)) {
   *    send_to_char("You are too busy fighting to do that!\n\r",ch);
   *    return;
   *  }
   */
d1079 1
a1079 1
  if (!RIGID(vict) || MOB2_FLAGGED(vict, MOB2_ILLUSORY)) {
d1168 1
a1168 1
   if (MOB2_FLAGGED(vict, MOB2_ILLUSORY)) {
d1388 1
a1388 1
      new_name = str_dup((obj->name) + aliaslen + 1);
d1479 1
a1479 1
               newtext = str_dup(line + 4);
d1486 1
a1486 1
               newtext = str_dup(line + 4);
d1523 1
a1523 1
  struct affected_type af;
d1527 1
a1527 1
  if(IS_FIGHTING(ch)) {
d1625 7
a1631 7
    memset(&af, 0, sizeof(af));
    af.type = SPELL_POISON;
    af.duration = amount * 3;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE, TRUE);
d1650 1
a1650 1
  struct affected_type af;
d1653 1
a1653 1
  if(IS_FIGHTING(ch)) {
d1655 1
a1655 1
  return;
d1705 7
a1711 7
    memset(&af, 0, sizeof(af));
    af.type = SPELL_POISON;
    af.duration = amount * 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE, TRUE);
d1755 1
a1755 1
  if (IS_FIGHTING(ch)) {
d2562 1
a2562 1
    if (IS_FIGHTING(ch)) {
d2845 1
a2845 1
        if (AFF_FLAGGED(ch, AFF_INVISIBLE))
d2939 1
a2939 1
      if (!AFF_FLAGGED(ch, AFF_DETECT_MAGIC))
d3012 4
@


1.121
log
@Reset TRANSIENT objects' timers when they are placed in a room,
not when they are picked up.  Prior to this, TRANSIENT objects
would tend to dissolve in under an hour if not picked up, which
was really too short.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.120 2008/03/19 04:32:14 myc Exp jps $
d31 1
d95 2
d338 4
d419 4
d501 3
a503 1
  if ((IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) && (!(GET_LEVEL(ch) >= LVL_IMMORT)))
a504 2
  else if (!*arg1)
    send_to_char("Get what?\r\n", ch);
d812 2
d1080 5
a1084 2
  /* When you give items to an illusory mob, they fall to the ground. */
  if (MOB2_FLAGGED(vict, MOB2_ILLUSORY)) {
d3017 6
@


1.120
log
@Fixed capitalization in a message in do_palm.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.119 2008/03/10 20:46:55 myc Exp myc $
d49 1
a49 1
 * Returns an integer.  100 and below should be failure.  Above 100 should 
d96 1
a96 1
    /* When you put a nonpermanent light in a container, it is 
d115 1
a115 1
   
d119 1
a119 1
   
d131 1
a131 1
  
d135 1
a135 1
  
d193 1
a193 1
  
d199 1
a199 1
  
d350 1
a350 1
        if (IS_PLR_CORPSE(cont)) {        
d372 1
a372 1
  
d374 1
a374 1
  
a425 2
        if (IS_OBJ_STAT(obj, ITEM_TRANSIENT) && GET_OBJ_TIMER(obj) < 5)
           GET_OBJ_TIMER(obj) = 5;
d440 1
a440 1
  
d442 1
a442 1
  
d489 1
a489 1
  
d510 2
a511 2
          get_from_container(ch, cont, arg1, mode); 
        } else {          
d529 1
a529 1
          } 
d544 1
a544 1
            } else {          
d674 2
a675 2
          /* Note: killed is the keyword that autorun greps for to sort 
           *       corpse info into the rip log.  This will so bust 
d696 1
a696 1
  
d699 1
a699 1
    /* If you are a god, then you always have consent */    
d701 1
a701 1
  } else if(!str_cmp(buf,cont->name)) {            
d706 1
a706 1
    for (d = descriptor_list; d && !done; d = d->next) {      
d716 2
a717 2
    }          
  }    
d721 1
a721 1
  
d730 1
a730 1
  
d739 1
a739 1
      
d796 1
a796 1
  
d802 1
a802 1
  
d805 1
a805 1
  
d825 1
a825 1
  
d841 1
a841 1
  
d871 1
a871 1
  
d873 1
a873 1
  
d878 2
a879 2
  } 
  
d961 1
a961 1
    
d1002 1
a1002 1
  
d1032 1
a1032 1
  
d1043 2
a1044 2
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100 
      && !(IS_NPC(ch) && (!(ch)->desc || 
d1065 1
a1065 1
      return GIVE_FAIL;  
d1087 1
a1087 1
    return GIVE_FAIL;  
d1106 1
a1106 1
  
d1130 1
a1130 1
  
d1135 1
a1135 1
  
d1217 1
a1217 1
  
d1332 1
a1332 1
  
d1365 1
a1365 1
  
d1374 1
a1374 1
         !strncmp(drinks[type], obj->name, aliaslen)) 
d1388 1
a1388 1
  
d1407 1
a1407 1
 * 
d1515 1
a1515 1
  
d1520 1
a1520 1
  
d1522 1
a1522 1
  
d1569 1
a1569 1
    
d1572 1
a1572 1
    
d1577 1
a1577 1
    
d1584 1
a1584 1
  
d1586 1
a1586 1
  
d1589 1
a1589 1
  
d1591 1
a1591 1
  
d1594 1
a1594 1
  
d1597 1
a1597 1
  
d1600 1
a1600 1
  
d1603 1
a1603 1
  
d1606 1
a1606 1
  
d1609 1
a1609 1
  
d1613 1
a1613 1
    
d1641 1
a1641 1
  
d1644 1
a1644 1
  return; 
d1646 1
a1646 1
  
d1648 1
a1648 1
  
d1682 1
a1682 1
  
d1684 1
a1684 1
  
d1686 1
a1686 1
  
d1689 1
a1689 1
  
d1693 1
a1693 1
    
d1727 8
a1734 8
 *   0) water                  1) beer                 
 *   2) wine                   3) ale                  
 *   4) dark ale               5) whisky               
 *   6) lemonade               7) firebreather         
 *   8) local speciality       9) slime mold juice     
 *   10) milk                  11) tea                  
 *   12) coffee                13) blood                
 *   14) salt water            15) rum                  
d1743 1
a1743 1
  
d1749 1
a1749 1
  
d1803 1
a1803 1
      
d1805 1
a1805 1
      
d1809 1
a1809 1
      
d1844 1
a1844 1
  
d1855 1
a1855 1
  
d1876 1
a1876 1
    
d1879 1
a1879 1
    
d1882 1
a1882 1
    
d1885 1
a1885 1
    
d1888 1
a1888 1
    
d1891 1
a1891 1
    
d1894 1
a1894 1
    
d1897 1
a1897 1
    
d1900 1
a1900 1
    
d1903 1
a1903 1
    
d1906 1
a1906 1
    
d1909 1
a1909 1
    
d1912 1
a1912 1
    
d1915 1
a1915 1
    
d1918 1
a1918 1
    
d1921 1
a1921 1
    
d1924 2
a1925 2
    
    
d1928 2
a1929 2
    
    
d1932 2
a1933 2
    
    
d1936 1
a1936 1
    
d1939 1
a1939 1
    
d1942 1
a1942 1
    
d1945 1
a1945 1
    
d1948 1
a1948 1
    
d1951 1
a1951 1
    
d1954 1
a1954 1
    
d1958 1
a1958 1
  
d2040 1
a2040 1
         act("You're not a high enough level to use $p.", 
d2123 1
a2123 1
  
d2154 1
a2154 1
  
d2173 1
a2173 1
    if (CAN_WEAR(obj, ITEM_WEAR_EAR))         where = WEAR_LEAR; 
d2187 1
a2187 1
  
d2197 1
a2197 1
  
d2205 1
a2205 1
  
d2211 1
a2211 1
  
d2335 1
a2335 1
  
d2360 1
a2360 1
         send_to_char("You can't extinguish that!\r\n", ch);          
d2362 1
a2362 1
         send_to_char("You can't light that!\r\n", ch);          
d2415 1
a2415 1
           !((obj = get_obj_in_list(arg, ch->carrying)) && 
d2437 1
a2437 1
  
d2457 1
a2457 1
  
d2459 1
a2459 1
  
d2465 1
a2465 1
  
d2502 1
a2502 1
  }  
d2538 1
a2538 1
  
d2561 1
a2561 1
  
d2587 1
a2587 1
      break; 
d2591 1
a2591 1
      break;                 
d2617 1
a2617 1
    
d2620 1
a2620 1
        if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) || 
d2624 1
a2624 1
            sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n", 
d2627 1
a2627 1
            sprintf(buf, "&0$n &0charges at the %s but simply bounces off!&0", 
d2630 1
a2630 1
            
d2634 1
a2634 1
                GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));        
d2643 1
a2643 1
          
d2647 1
a2647 1
            
d2650 1
a2650 1
            sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n", 
d2655 1
a2655 1
            
d2672 2
a2673 2
        
        sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n", 
d2676 2
a2677 2
        sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0", 
                fname(EXIT(ch, dir)->keyword));                
d2679 1
a2679 1
        
d2683 1
a2683 1
            GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));        
d2687 2
a2688 2
            update_pos(ch);}        
        } 
d2706 2
a2707 2
  
  
d2724 1
a2724 1
         
d2844 1
a2844 1
        act("You try to conceal $p, but can't find a good spot.", FALSE, ch, obj, 0, TO_CHAR); 
d2996 1
a2996 1
  }  
d3001 3
d3413 1
a3413 1
 * >> Setting attributes for mobs in the .mob file no longer functions 
d3421 1
a3421 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.119
log
@Renamed hometown to homeroom and using GET_HOME macro.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.118 2008/03/09 18:11:17 jps Exp myc $
d647 1
a647 1
        sprintf(buf, "there doesn't seem to be %s %s in $p.", AN(arg1), arg1);
d3003 3
@


1.118
log
@perform_move may be misdirected now.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.117 2008/03/05 03:03:54 myc Exp jps $
d2871 1
a2871 1
         ch->player.hometown = world[ch->in_room].number;
d3003 3
@


1.117
log
@Removed defunct do_home command.  (This functionality is available via
do_goto).
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.116 2008/02/09 04:27:47 myc Exp myc $
d2661 1
a2661 1
              perform_move(ch, dir, 1);
d2664 1
a2664 1
              perform_move(ch, dir, 1);
d3003 4
@


1.116
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.115 2008/02/02 04:27:55 myc Exp myc $
a2697 31
ACMD(do_home)
{
  struct char_data;
  int rr;

  rr = real_room(GET_LOADROOM(ch));
  
  if(rr == NOWHERE) {
    send_to_char("You're home room isn't set!\r\n", ch);
    return;
  }
  if (strlen(POOFOUT(ch)) > 0) {
    sprintf(buf, "$n %s", POOFOUT(ch));
  } else {
    strcpy(buf, "$n disappears in a puff of smoke.");
  }
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  
  char_from_room(ch);
  char_to_room(ch, rr);

  if (strlen(POOFIN(ch)) > 0) {
    sprintf(buf, "$n %s", POOFIN(ch));
  } else {
    strcpy(buf, "$n appears with an ear-splitting bang.");
  }
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
  return;
}

d3003 3
@


1.115
log
@Making get object trigger go off before illusory mob check.
Adding consume object trigger.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.114 2008/01/29 21:02:31 myc Exp myc $
d30 1
d3034 4
@


1.114
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.113 2008/01/28 05:16:11 jps Exp myc $
d337 23
a359 18
    else if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
      /* Just pretend */
      act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      return;
    } else if (get_otrigger(obj, ch)) {
      obj_from_obj(obj);
      obj_to_char(obj, ch);
      act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      unhide_object(obj);
      if (IS_PLR_CORPSE(cont)) {        
        /* Note: killed is the keyword autorun greps on to sort corpse info
         *       into the rip log.  This will so bust players who claim the
         *       game ate their corpse.
         */
        sprintf(buf,"killed: %s gets %s from %s.", GET_NAME(ch), strip_ansi(obj->short_description), cont->short_description);
        log(buf);
a360 1
      get_check_money(ch, obj);
d414 17
a430 14
    if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
      /* Just pretend */
      act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
      act("$n gets $p.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
    } else if (get_otrigger(obj, ch)) {
      obj_from_room(obj);
      obj_to_char(obj, ch);
      act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
      act("$n gets $p.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
      if (IS_OBJ_STAT(obj, ITEM_TRANSIENT) && GET_OBJ_TIMER(obj) < 5)
         GET_OBJ_TIMER(obj) = 5;
      unhide_object(obj);
      get_check_money(ch, obj);
      return 1;
d1563 4
d1672 4
d3033 4
@


1.113
log
@Suppress can't-wear messages for individual items when you say
"wear all" or "wear all.foo".
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.112 2008/01/27 13:43:50 jps Exp jps $
d29 1
a36 4
extern struct str_app_type str_app[];
extern struct room_data *world;
extern char *drinks[];
extern int drink_aff[][3];
a52 2
  extern struct dex_skill_type dex_app_skill[];

a687 1
  extern struct descriptor_data *descriptor_list;
a1358 2
   extern struct obj_data *obj_proto;
   extern char *drinks[];
a1378 2
  extern struct obj_data *obj_proto;
  extern char *drinks[];
a1425 2
   extern struct obj_data *obj_proto;
   extern char *drinks[];
d2110 1
a2110 1
  static char *keywords[] = {
a2519 1
  extern int rev_dir[];
d3018 4
@


1.112
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.111 2008/01/27 01:42:03 jps Exp jps $
d1962 1
d1964 12
a1975 1
void perform_wear(struct char_data * ch, struct obj_data * obj, int where)
d1992 1
a1992 1
  
d2022 1
a2022 1
  
d2030 1
a2030 1
      if (!(IS_NPC(ch)))
d2032 1
a2032 1
      return;
d2037 1
a2037 1
      if (!IS_NPC(ch)) {
d2042 1
a2042 1
      return;
d2051 3
a2053 2
         act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
         return;
d2057 3
a2059 2
         send_to_char("It's too heavy for you to use.\r\n", ch);
         return;
d2064 4
a2067 3
         act("You're not even wearing a belt to wear $p on!",
             FALSE, ch, obj, 0, TO_CHAR);
         return;
d2087 3
a2089 2
         send_to_char("You need both hands free for this weapon!\r\n",ch);
         return;
d2091 3
a2093 2
         send_to_char("Both of your hands are already using something.\r\n", ch);
         return;
d2096 3
a2098 2
         send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
         return;
d2103 3
a2105 2
      send_to_char(already_wearing[where], ch);
      return;
d2107 1
a2107 1
  
d2109 1
a2109 1
      return;
d2113 1
d2194 1
a2194 1
  int where, dotmode, wearable_items = 0;
d2219 1
a2219 1
        perform_wear(ch, obj, where);
d2222 2
a2223 2
    if (!wearable_items)
      send_to_char("You don't seem to have anything wearable.\r\n", ch);
d2235 1
a2235 2
    }
    else
d2238 3
a2240 4
        if ((where = find_eq_pos(ch, obj, 0)) >= 0)
          perform_wear(ch, obj, where);
        else
          act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
d2243 3
d2255 1
a2255 1
      perform_wear(ch, obj, where);
d2311 1
a2311 1
      perform_wear(ch, obj, WEAR_2HWIELD);
d2319 1
a2319 1
         perform_wear(ch, obj, WEAR_WIELD2);
d2323 1
a2323 1
      perform_wear(ch, obj, WEAR_WIELD);
d2419 1
a2419 1
      perform_wear(ch, obj, WEAR_HOLD);
d2426 1
a2426 1
        perform_wear(ch, obj, WEAR_HOLD);
d3031 3
@


1.111
log
@Fix grammar when informing player of cursed objects.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.110 2008/01/26 14:26:31 jps Exp jps $
d2180 1
a2180 1
  if (GET_SPECIES(ch) == SPECIES_ANIMAL) {
d2248 1
a2248 1
   if (GET_SPECIES(ch) == SPECIES_ANIMAL)
d3010 3
@


1.110
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.109 2008/01/26 12:29:44 jps Exp jps $
d782 1
a782 1
    sprintf(buf, "You can't %s $p, it must be CURSED!", sname);
d3010 3
@


1.109
log
@Use skills.h to import improve_skill().
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.108 2008/01/22 22:29:25 myc Exp jps $
a25 1
#include "spells.h"
d3010 3
@


1.108
log
@Refined perform_wear.  Only allow wearing an item 'on belt' if actually
wearing a belt.  If the belt is removed, any item 'on belt' falls off.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.107 2008/01/15 03:21:11 myc Exp myc $
d29 1
a45 1
void improve_skill(struct char_data *ch, int skill);
d3011 4
@


1.107
log
@Rewrote give command so it always gives feedback.  Also made REMOVE
triggers not prevent immortals from removing items.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.106 2008/01/13 23:06:04 myc Exp myc $
d1972 1
a1972 2
  
  int wear_bitvectors[] = {
d1979 2
a1980 1
    ITEM_WEAR_EAR, ITEM_WEAR_BADGE, ITEM_WEAR_OBELT};
d2028 1
a2028 1
         FALSE, ch, obj, 0, TO_CHAR);
d2035 1
d2037 3
a2039 3
            (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
            (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
            NOWEAR_CLASS(ch, obj)) {
d2043 12
d2161 1
a2161 1
    if (!strcmp(arg, "!") || (where = searchblock(arg, keywords, FALSE)) < 0) {
d2175 1
a2175 1
  int where, dotmode, items_worn = 0;
d2199 1
a2199 6
        items_worn++;
        if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
        {
            send_to_char("It's too heavy for you to use.\r\n", ch);
            return;
        }
d2203 1
a2203 1
    if (!items_worn)
d2205 3
a2207 1
  } else if (dotmode == FIND_ALLDOT) {
d2216 2
a2217 1
    } else
d2221 1
a2221 8
        {
            if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
            {
                send_to_char("It's too heavy for you to use.\r\n", ch);
                return;
            }
            perform_wear(ch, obj, where);
        }
d2226 4
a2229 1
  } else {
a2232 12
    } else {
      if ((where = find_eq_pos(ch, obj, arg2)) >= 0)
      {
        if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
        {
            send_to_char("It's too heavy for you to use.\r\n", ch);
            return;
        }
        perform_wear(ch, obj, where);
      }
      else if (!*arg2)
        act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
d2234 4
d2420 1
a2420 1
  if (!remove_otrigger(obj, ch) && GET_LEVEL(ch) < LVL_IMMORT)
d2434 1
a2434 1
  int i, dotmode, found;
d2446 3
a2448 3
    for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i)) {
        perform_remove(ch, i);
d2453 3
a2455 1
  } else if (dotmode == FIND_ALLDOT) {
d2460 3
a2462 4
      for (i = 0; i < NUM_WEARS; i++)
        if (GET_EQ(ch, i) &&
            isname(arg, GET_EQ(ch, i)->name)) {
          perform_remove(ch, i);
d2467 1
a2467 1
           isplural(arg) ? "" : "s");
d2471 4
a2474 2
  } else {
    if ((obj = (get_object_in_equip(ch, arg, &i))) == NULL) {
a2476 14
    } else {
      if (i == WEAR_WIELD || WEAR_2HWIELD) {
        perform_remove(ch, i);
        if (GET_EQ(ch, WEAR_WIELD2))          {
          if (!(GET_EQ(ch, WEAR_WIELD))) {
            obj = GET_EQ(ch, WEAR_WIELD2);
            obj_to_char(unequip_char(ch, WEAR_WIELD2), ch);
            obj_from_char(obj);
            equip_char(ch, obj, WEAR_WIELD);
          } 
        }
        return;
      }        
      perform_remove(ch, i);
d2478 2
d2481 19
d3011 4
@


1.106
log
@Took out a redundant check in can_take_obj.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.105 2008/01/11 02:04:32 myc Exp myc $
d181 1
a181 1
           isplural(arg1) ? "" : "s");
d1027 1
a1027 1
        if(check_container_give(cont, ch, vict))
d1123 1
a1123 1
                       int *cPtr)
d1125 1
a1125 1
   bool afford = 1;/*assume they can afford it*/
d1129 2
a1130 3
   for (i = 0; i <= 3; i++) {
      amount = amount + cPtr[i];
   }
d1137 1
a1137 1
   if (GET_PLAT(ch) < cPtr[PLAT])
d1139 1
a1139 1
   if (GET_GOLD(ch) < cPtr[GOLD])
d1141 1
a1141 1
   if (GET_SILVER(ch) < cPtr[SILVER])
d1143 1
a1143 1
   if (GET_COPPER(ch) < cPtr[COPPER])
d1149 11
a1159 8
   } else if (MOB2_FLAGGED(vict, MOB2_ILLUSORY)) {
      obj = create_money(cPtr[0], cPtr[1], cPtr[2], cPtr[3]);
      if (GET_LEVEL(ch) < LVL_IMMORT) {
        GET_PLAT(ch)   -= cPtr[PLAT];
        GET_GOLD(ch)   -= cPtr[GOLD];
        GET_SILVER(ch) -= cPtr[SILVER];
        GET_COPPER(ch) -= cPtr[COPPER];
      }
d1171 5
a1175 1
   } else {
d1177 1
a1177 1
      statemoney(buf, cPtr);
d1179 2
d1182 4
a1185 4
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
         send_to_char(OK, ch);
      if (!(PRF_FLAGGED(ch, PRF_NOREPEAT)))
         act(buf, FALSE, vict, 0, ch, TO_VICT);
d1187 1
a1187 3
      strcpy(buf, "$n gives you");
      statemoney(buf, cPtr);
      strcat(buf, ".");
d1189 4
a1192 1
      act(buf, FALSE, ch, 0, vict, TO_VICT);
d1194 1
a1194 1
      strcpy(buf, "$n gives some coins to $N.");
d1196 5
a1200 43
      act(buf, TRUE, ch, 0, vict, TO_NOTVICT);

      if((vict==ch)&&(GET_LEVEL(ch)>=LVL_IMMORT))
         send_to_char("Ok.\r\n", ch);
      if (cPtr[PLAT]) {
         if (GET_LEVEL(ch) >= LVL_IMMORT)
            GET_PLAT(vict) += cPtr[PLAT];
         else {
            GET_PLAT(ch) -= cPtr[PLAT];
            GET_PLAT(vict) += cPtr[PLAT];
         }
      }
      if (cPtr[GOLD]) {
         if (GET_LEVEL(ch) >= LVL_IMMORT)
            GET_GOLD(vict) += cPtr[GOLD];
         else {
            GET_GOLD(ch) -= cPtr[GOLD];
            GET_GOLD(vict) += cPtr[GOLD];
         }         
      }
      if (cPtr[SILVER]) {
         if (GET_LEVEL(ch)>=LVL_IMMORT)
            GET_SILVER(vict) += cPtr[SILVER];
         else {
            GET_SILVER(ch) -= cPtr[SILVER];
            GET_SILVER(vict) += cPtr[SILVER];
         }
      }
      if (cPtr[COPPER]) {
         if (GET_LEVEL(ch)>=LVL_IMMORT)
            GET_COPPER(vict) += cPtr[COPPER];
         else {
            GET_COPPER(ch) -= cPtr[COPPER];
            GET_COPPER(vict) += cPtr[COPPER];
         }
      }
      bribe_mtrigger(vict, ch, cPtr);
      if ((cPtr[PLAT]>49) || (cPtr[GOLD]>499)) {
         sprintf(buf, "%s gave %d Plat %d Gold to %s",
               GET_NAME(ch), cPtr[PLAT], cPtr[GOLD], GET_NAME(vict));
         mudlog(buf, CMP, LVL_GOD, FALSE);
      }
   }        
d1206 1
a1206 2
  int amount=1, dotmode, result;
  int *cPtr;
d1208 1
a1208 1
  struct obj_data *obj, *next_obj, *ref_obj=0;
d1210 1
a1210 3
  int i, counter=0;
  bool coins = 1;
  char local_give_buf[MAX_STRING_LENGTH];
a1211 1
  cPtr = &cash[0];
d1213 1
a1213 1
  /*if no argument then dont know who to give to so exit*/
d1219 1
a1219 3
  /*ok we at first real argument after name*/        
  /*P/G/S/C GIVE*/
  
d1221 1
d1225 8
a1232 8
      if (!str_cmp("platinum", arg) || !str_cmp("p", arg)) 
        cash[PLAT] = amount;
      else if (!str_cmp("gold", arg) || !str_cmp("g", arg)) 
        cash[GOLD] = amount;
      else if (!str_cmp("silver", arg) || !str_cmp("s", arg)) 
        cash[SILVER] = amount;
      else if (!str_cmp("copper", arg) || !str_cmp("c", arg)) 
        cash[COPPER] = amount;
d1234 1
a1234 1
        coins = 0;
d1238 1
a1238 1
          amount = atoi(arg);
d1240 3
a1242 4
    if (coins) {
      /*coin handling*/
      if (!(vict = give_find_vict(ch, arg))) {
        /*No victem found*/
d1244 1
a1244 3
      }
      cPtr = &cash[0];
      perform_give_gold(ch, vict, cPtr);
d1247 3
a1249 1
  }/*Note no coin handling past this point*/
d1251 13
a1263 2
  if (!(vict = give_find_vict(ch, buf1))) {
    /*No victem found*/
a1265 1
  dotmode = find_all_dots(arg);
d1267 2
a1268 2
  for (i=1;i <= amount;i++) {
    if (dotmode == FIND_INDIV) {
d1270 4
a1273 1
        sprintf(buf, "You don't seem to have %d %s.\r\n", amount, arg);
d1275 22
a1296 2
        i=amount; /* Prevents give 48000 burps does not exist crashes! CMC 4/5/00 */ 
      } else {
d1300 3
a1302 38
        if (result == GIVE_SUCCESS) {
          counter++;
        } else if (result == GIVE_FAIL_FULL) {
          i=amount;
        }
      }
    } else {
      if (dotmode == FIND_ALLDOT && !*arg) {
        send_to_char("All of what?\r\n", ch);
        return;
      }
      if (!ch->carrying) {
        send_to_char("You don't seem to be holding anything.\r\n", ch);
      } else {
        counter=0;
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          if (CAN_SEE_OBJ(ch, obj) && ((dotmode == FIND_ALL || isname(arg, obj->name)))) {
            if (!ref_obj) {
              ref_obj = obj;
            }
            if (dotmode == FIND_ALLDOT) {
              if (perform_give(ch, vict, obj, 1) == GIVE_SUCCESS) {
                counter++;
              } else {
                obj = next_obj = 0;
              }
            } else if (perform_give(ch, vict, obj, 1) == GIVE_FAIL_FULL) {
              obj = next_obj = 0;
            } else {
              counter++;
            }
          }
        }
        if (counter == 0) {
          sprintf(buf, "You don't even have one %s!\r\n", arg);
          send_to_char(buf, ch);
        }
d1307 9
a1315 1
  if (counter == 1) {
d1319 6
a1324 5
  } else if (counter > 1) {
    sprintf(local_give_buf,"You give $p to $N. (x%d)",counter);
    act(local_give_buf, FALSE, ch, ref_obj, vict, TO_CHAR);
    sprintf(local_give_buf,"$n gives you $p. (x%d)",counter);
    act(local_give_buf, FALSE, ch, ref_obj, vict, TO_VICT);
a1326 1

d2421 1
a2421 1
  if (!remove_otrigger(obj, ch))
d3002 3
@


1.105
log
@Moved do_drag to act.movement.c
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.104 2008/01/10 05:39:43 myc Exp myc $
d297 1
a297 1
  } else if (!(CAN_WEAR(obj, ITEM_WEAR_TAKE))) {
a302 3
  } else if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch) && GET_OBJ_TYPE(obj) == ITEM_BOAT) {
    act("You are not experienced enough to use that.", FALSE, ch, obj, 0, TO_CHAR);
    return 0;
d3031 3
@


1.104
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.103 2008/01/09 10:11:56 jps Exp myc $
a2525 154

ACMD(do_drag)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  int door = 0, k = 0, from_room = 0, to_room = 0, move_cost;
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  extern int movement_loss[];
  
  two_arguments(argument, arg1, arg2);
  
  if (!*arg2 || !*arg1) {
    send_to_char("Drag what? Where?\r\n", ch);
    return;
  }

  if (IS_FIGHTING(ch)) {
    send_to_char("You are a bit busy right now to think about dragging stuff.\n\r",ch);
    return;
  }
  
  if (GET_POS(ch) == POS_FLYING) {
    send_to_char("You don't have the proper leverage to do that.  Try standing.\r\n", ch);
    return;
  }

  if (*arg2){
    
    switch (*arg2) {
    case 'n':
    case 'N':
      door = 0;
      break;
    case 'e':
    case 'E':
      door = 1;
      break;
    case 's':
    case 'S':
      door = 2;
      break;
    case 'w':
    case 'W':
      door = 3;
      break;
    case 'u':
    case 'U':
      door = 4;
      break;
    case 'd':
    case 'D':
      door = 5;
      break; 
    }
  }
  
   k = generic_find(arg1, FIND_OBJ_ROOM | FIND_CHAR_ROOM, ch, &tch, &tobj);

   if (!k) {
      send_to_char("Can't find that!\r\n", ch);
      return;
   }

   /* This should never happen, but check anyway */
   if (k != FIND_OBJ_ROOM) {
      send_to_char("You can't drag that!\r\n", ch);
      return;
   }

   /* Tried to drag a mobile? */
   if (k == FIND_CHAR_ROOM) {
      if (ch == tch)
         /* Tried to drag yourself. */
         send_to_char("One foot in front of the other, now...\r\n", ch);
      else {
         act("Maybe you should kill $M first!", FALSE, ch, 0, tch, TO_CHAR);
      }
      return;
   }

  /* Items can be made draggable by giving them the TAKE wear flag.
   * Here we check for that flag.  But an exception is made so that you
   * can also drag corpses. */
   if (!(CAN_WEAR(tobj, ITEM_WEAR_TAKE)) && !IS_CORPSE(tobj)) {
      send_to_char("You cant drag that!\r\n", ch);
      return; 
   }

   if (!EXIT(ch, door) || EXIT(ch, door)->to_room == NOWHERE) {
      send_to_char("You can't go that way!\r\n", ch);
      return;
   }

   if (IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED)) {
      if (EXIT(ch, door)->keyword) {
         if (isplural(EXIT(ch, door)->keyword))
            sprintf(buf2, "The %s seem to be closed.\r\n", fname(EXIT(ch, door)->keyword));
         else
            sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, door)->keyword));
         send_to_char(buf2, ch);
      } else {
         send_to_char("It seems to be closed.\r\n", ch);
      }
      return;
   }

   if (GET_OBJ_WEIGHT(tobj) > (CAN_CARRY_W(ch)*3)) {
      send_to_char("It is too heavy for you to drag.\r\n", ch); 
      return;
   }

   if (IS_PLR_CORPSE(tobj)) {
      if (!corpse_consent(ch, tobj)) {
         sprintf(buf,"killed:%s tried to drag %s without CONSENT!",
               GET_NAME(ch), tobj->short_description);
         mudlog(buf, BRF, LVL_IMMORT, TRUE);
         log(buf);
         return;
      }
   }

   if (GET_LEVEL(ch) < LVL_GOD) {
      move_cost = MIN(4, GET_OBJ_WEIGHT(tobj) / 50 +
            movement_loss[SECT(ch->in_room)]);
      if (GET_MOVE(ch) < move_cost) {
         send_to_char("You are too exhausted!\r\n", ch);              
         return;
      } else {
         alter_move(ch, move_cost);
      }
   }

        obj_from_room(tobj);        
        sprintf(buf, "You drag %s &0behind you.\r\n", tobj->short_description);          
        send_to_char(buf, ch);        
        sprintf(buf, "$n &0drags %s &0behind $m.&0", tobj->short_description);
        act(buf, FALSE, ch, 0, 0, TO_ROOM);
        from_room = world[ch->in_room].number;  /* to log below */
        perform_move(ch, door, 1);
        obj_to_room(tobj, ch->in_room);
        sprintf(buf, "$n &0drags %s &0behind $m.&0", tobj->short_description);
        act(buf, FALSE, ch, 0, 0, TO_ROOM);
        to_room = world[ch->in_room].number;   /* to log below */
        
        if (IS_PLR_CORPSE(tobj)) {        
      /* Note: killed is the keyword autorun greps on to sort corpse info
       *       into the rip log. */
      sprintf(buf, "killed: %s drags %s from room %d to room %d.",
            GET_NAME(ch), tobj->short_description, from_room, to_room);
      log(buf);
   }
}

d3034 4
@


1.103
log
@Jacked up the drink-mv restoration to 100% for drinking 24 units.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.102 2008/01/09 07:41:32 jps Exp jps $
d1735 1
a1735 1
  alter_hit(ch, - MIN(70, GET_MAX_HIT(ch) * amount / 72), 3);
d3188 3
@


1.102
log
@Give proper feedback for "give all <vict>", similar to "give all.foo <vict>"
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.101 2008/01/07 11:57:31 jps Exp jps $
d1659 2
a1660 2
   * would restore 33% or 70, whichever is lower. */
  alter_move(ch, - MIN(70, GET_MAX_MOVE(ch) * amount / 72));
d3188 3
@


1.101
log
@Fix output for failure to give things to illusions.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.100 2008/01/06 23:50:47 jps Exp jps $
d55 1
a55 1
#define MAX_CONCEAL_WEIGHT	200
d90 1
a90 1
		 struct obj_data * cont)
d147 1
a147 1
	    ((obj_dotmode == FIND_INDIV) ? "it" : "them"));
d159 8
a166 8
      if (obj_dotmode == FIND_INDIV) {	/* put <obj> <container> */
	if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
	  sprintf(buf, "You aren't carrying %s %s.\r\n", AN(arg1), arg1);
	  send_to_char(buf, ch);
	} else if (obj == cont)
	  send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
	else
	  perform_put(ch, obj, cont);
d168 13
a180 13
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  if (obj != cont && CAN_SEE_OBJ(ch, obj) &&
	      (obj_dotmode == FIND_ALL || isname(arg1, obj->name))) {
	    found = 1;
	    perform_put(ch, obj, cont);
	  }
	}
	if (!found) {
	  if (obj_dotmode == FIND_ALL)
	    send_to_char("You don't seem to have anything to put in it.\r\n", ch);
	  else {
	    sprintf(buf, "You don't seem to have any %s%s.\r\n", arg1,
d182 3
a184 3
	    send_to_char(buf, ch);
	  }
	}
d326 1
a326 1
	      , GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3));
d328 1
a328 1
	sprintf(buf, "%sMust have been an illusion!\r\n", buf);}
d341 1
a341 1
				struct obj_data * cont, int mode)
d357 7
a363 7
      if (IS_PLR_CORPSE(cont)) {	
	/* Note: killed is the keyword autorun greps on to sort corpse info
	 *       into the rip log.  This will so bust players who claim the
	 *       game ate their corpse.
	 */
	sprintf(buf,"killed: %s gets %s from %s.", GET_NAME(ch), strip_ansi(obj->short_description), cont->short_description);
	log(buf);
d372 1
a372 1
			char *arg, int mode)
d396 3
a398 3
	  (obj_dotmode == FIND_ALL || isname(arg, obj->name))) {
	found = 1;
	perform_get_from_container(ch, obj, cont, mode);
d403 1
a403 1
	act("$p seems to be empty.", FALSE, ch, cont, 0, TO_CHAR);
d405 1
a405 1
	sprintf(buf, "You can't seem to find any %s%s in $p.", arg,
d407 1
a407 1
	act(buf, FALSE, ch, cont, 0, TO_CHAR);
d461 3
a463 3
	  (dotmode == FIND_ALL || isname(arg, obj->name))) {
	found = 1;
	perform_get_from_room(ch, obj);
d468 1
a468 1
	send_to_char("There doesn't seem to be anything here.\r\n", ch);
d470 1
a470 1
	sprintf(buf, "You don't see any %s%s here.\r\n", arg,
d472 1
a472 1
	send_to_char(buf, ch);
d504 2
a505 2
	sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
	send_to_char(buf, ch);
d507 1
a507 1
	act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
d509 12
a520 12
	/* Added functionality to check for consent to prevent players from
	 * looting each others corpses. Zzur 8/7/1999
 	 */
	if(!IS_PLR_CORPSE(cont)) {
	  get_from_container(ch, cont, arg1, mode); 
	} else {	  
	  if(corpse_consent(ch, cont)) {
	    get_from_container(ch, cont, arg1, mode);
	  } else {
	    return;
	  }
	}
d524 2
a525 2
	send_to_char("Get from all of what?\r\n", ch);
	return;
d528 10
a537 10
	if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
	    found = 1;
	    get_from_container(ch, cont, arg1, FIND_OBJ_INV);
	  } 
	  else if (cont_dotmode == FIND_ALLDOT) {
	    found = 1;
	    act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
	  }
	}
d539 18
a556 18
	if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
	    found = 1;
	    /* Added functionality to check for consent to prevent players from
	     * looting each others corpses. Zzur 8/7/1999
	     */
	    if(!IS_PLR_CORPSE(cont)) {
	      get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
	    } else {	  
	      if(corpse_consent(ch, cont)) {
		get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
	      }
	    }
	  } else if (cont_dotmode == FIND_ALLDOT) {
	    act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
	    found = 1;
	  }
	}
d559 4
a562 4
	if (cont_dotmode == FIND_ALL)
	  send_to_char("You can't seem to find any containers.\r\n", ch);
	else {
	  sprintf(buf, "You can't seem to find any %s%s here.\r\n", arg2,
d564 3
a566 3
	  send_to_char(buf, ch);
	}
	return;
d705 1
a705 1
  } else if(!str_cmp(buf,cont->name)) {	    
d712 7
a718 7
	/* compare the name of the corpse to the current d->character  */
	/* if the d->character is consented to the person who's acting */
	/* on the corpse then the act is allowed.                      */
	sprintf(buf,"corpse %s", GET_NAME(d->character));
	if (!str_cmp(buf,cont->name) && CONSENT(d->character) == ch) {
	  done = TRUE;
	}
d720 1
a720 1
    }	  
d730 1
a730 1
		       byte mode, int RDR)
d741 1
a741 1
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
d745 5
a749 5
	send_to_char("You throw some gold into the air where it disappears in a puff of smoke!\r\n", ch);
	act("$n throws some gold into the air where it disappears in a puff of smoke!",
	    FALSE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, RDR);
	act("$p suddenly appears in a puff of orange smoke!", 0, 0, obj, 0, TO_ROOM);
d751 1
a751 1
	if (!drop_wtrigger(obj, ch)) {
d755 1
a755 1
	send_to_char("You drop some gold.\r\n", ch);
d757 3
a759 3
	sprintf(buf, "$n drops %s.", shortdesc);
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, ch->in_room);
d773 1
a773 1
		      "  It vanishes in a puff of smoke!" : "")
d776 1
a776 1
		 byte mode, char *sname, int RDR)
d863 1
a863 1
	    case 4: RDR = real_room(donation_room_3); break;
d889 2
a890 2
	send_to_char("You don't have enough!\r\n", ch);
	return;}
d895 2
a896 2
	send_to_char("You drop a &0&b&6platinum&0 coin!\r\n", ch);
	return;}
d898 6
a903 6
	{sprintf(buf, "You drop &0&b&6%d&0 platinum coins!\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&b&6platinum&0 coins!\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
d907 2
a908 2
	send_to_char("You don't have enough!\r\n", ch);
	return;}
d913 2
a914 2
	send_to_char("You drop a &0&b&3gold&0 coin!\r\n", ch);
	return;}
d916 6
a921 6
	{sprintf(buf, "You drop &0&b&3%d&0 gold coins!\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&b&3gold&0 coins!\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
d925 2
a926 2
	send_to_char("You don't have enough!\r\n", ch);
	return;}
d931 2
a932 2
	send_to_char("You drop a silver coin.\r\n", ch);
	return;}
d934 6
a939 6
	{sprintf(buf, "You drop %d silver coins.\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}
	{sprintf(buf, "$n drops some silver coins.\r\n");
	act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
d943 2
a944 2
	send_to_char("You don't have enough!\r\n", ch);
	return;}
d949 1
a949 1
	send_to_char("You drop a &0&3copper&0 coin.\r\n", ch);}
d951 6
a956 6
	{sprintf(buf, "You drop &0&3%d&0 copper coins.\r\n", amount);
	act(buf, FALSE, ch, 0, 0, TO_CHAR);}{
	  sprintf(buf, "$n drops some &0&3copper&0 coins.\r\n");
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	return;}
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
d969 1
a969 1
	send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
d971 1
a971 1
	send_to_char("Go do the donation room if you want to donate EVERYTHING!\r\n", ch);
d976 1
a976 1
	send_to_char("You don't seem to be carrying anything.\r\n", ch);
d978 4
a981 4
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  amount += perform_drop(ch, obj, mode, sname, RDR);
	}
d984 3
a986 3
	sprintf(buf, "What do you want to %s all of?\r\n", sname);
	send_to_char(buf, ch);
	return;
d989 1
a989 1
	sprintf(buf, "You don't seem to have any %s%s.\r\n", arg,
d991 1
a991 1
	send_to_char(buf, ch);
d994 3
a996 3
	next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
	amount += perform_drop(ch, obj, mode, sname, RDR);
	obj = next_obj;
d1000 2
a1001 2
	sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf, ch);
d1003 1
a1003 1
	amount += perform_drop(ch, obj, mode, sname, RDR);
d1045 1
a1045 1
		  struct obj_data * obj, int silent)
d1049 1
a1049 1
			  GET_LEVEL((ch)->desc->original)>=LVL_IMPL))) {
d1126 1
a1126 1
		       int *cPtr)
d1208 1
a1208 1
         } 	
d1232 1
a1232 1
   }	
d1255 1
a1255 1
  /*ok we at first real argument after name*/	
d1263 1
a1263 1
	cash[PLAT] = amount;
d1265 1
a1265 1
	cash[GOLD] = amount;
d1267 1
a1267 1
	cash[SILVER] = amount;
d1269 1
a1269 1
	cash[COPPER] = amount;
d1271 2
a1272 2
	coins = 0;
	break;
d1275 1
a1275 1
	  amount = atoi(arg);
d1280 2
a1281 2
	/*No victem found*/
	return;
d1298 3
a1300 3
	sprintf(buf, "You don't seem to have %d %s.\r\n", amount, arg);
	send_to_char(buf, ch);
	i=amount; /* Prevents give 48000 burps does not exist crashes! CMC 4/5/00 */ 
d1302 8
a1309 8
	if (!ref_obj)
	  ref_obj = obj;
	result = perform_give(ch, vict, obj, 1);
	if (result == GIVE_SUCCESS) {
	  counter++;
	} else if (result == GIVE_FAIL_FULL) {
	  i=amount;
	}
d1313 2
a1314 2
	send_to_char("All of what?\r\n", ch);
	return;
d1317 1
a1317 1
	send_to_char("You don't seem to be holding anything.\r\n", ch);
d1319 20
a1338 18
	counter=0;
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  if (CAN_SEE_OBJ(ch, obj) && ((dotmode == FIND_ALL || isname(arg, obj->name)))) {
	    if (dotmode == FIND_ALLDOT) {
	      if (!ref_obj) {
		ref_obj = obj;
	      }
	      if (perform_give(ch, vict, obj, 1) == GIVE_SUCCESS) {
		counter++;
	      } else {
		obj = next_obj = 0;
	      }
	    } else if (perform_give(ch, vict, obj, 0) == GIVE_FAIL_FULL) {
	      obj = next_obj = 0;
	    }
	  }
	}
d1625 1
a1625 1
  weight_change_object(temp, -weight);	/* Subtract amount */
d1628 1
a1628 1
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);
d1631 1
a1631 1
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][FULL] * amount) / 1);
d1634 1
a1634 1
		 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 1);
d1664 1
a1664 1
  if (!GET_OBJ_VAL(temp, 1)) {	/* The last bit */
d1694 1
a1694 1
			       (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN))) {
d1782 1
a1782 1
    if (!*arg1) {		/* No arguments */
d1796 1
a1796 1
    if (!*arg1) {		/* no arguments */
d1808 1
a1808 1
    if (!*arg2) {		/* no 2nd argument */
d1826 1
a1826 1
  if (subcmd == SCMD_POUR) {	/* pour */
d1848 1
a1848 1
	(GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN)) {
d1868 1
a1868 1
	    drinks[GET_OBJ_VAL(from_obj, 2)], arg2);
d1884 1
a1884 1
  weight_change_object(to_obj, amount);	/* Add weight */
d2175 1
a2175 1
    if (CAN_WEAR(obj, ITEM_WEAR_WIELD))	      where = WEAR_WIELD;
d2218 3
a2220 3
	items_worn++;
	if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
	{
d2222 3
a2224 3
	    return;
	}
	perform_wear(ch, obj, where);
d2240 5
a2244 5
	next_obj = get_obj_in_list_vis(ch, arg1, obj->next_content);
	if ((where = find_eq_pos(ch, obj, 0)) >= 0)
	{
	    if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
	    {
d2246 7
a2252 7
	        return;
	    }
	    perform_wear(ch, obj, where);
	}
	else
	  act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
	obj = next_obj;
d2261 2
a2262 2
	if ((GET_OBJ_TYPE(obj)== ITEM_WEAPON) && (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w))
	{
d2264 3
a2266 3
	    return;
	}
	perform_wear(ch, obj, where);
d2269 1
a2269 1
	act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
d2427 1
a2427 1
	     GET_OBJ_TYPE(obj) == ITEM_LIGHT)) {
d2435 3
a2437 3
	  GET_OBJ_TYPE(obj) != ITEM_STAFF && GET_OBJ_TYPE(obj) != ITEM_SCROLL &&
	  GET_OBJ_TYPE(obj) != ITEM_POTION)
	send_to_char("You can't hold that.\r\n", ch);
d2439 1
a2439 1
	perform_wear(ch, obj, WEAR_HOLD);
d2481 2
a2482 2
	perform_remove(ch, i);
	found = 1;
d2492 5
a2496 5
	if (GET_EQ(ch, i) &&
	    isname(arg, GET_EQ(ch, i)->name)) {
	  perform_remove(ch, i);
	  found = 1;
	}
d2498 1
a2498 1
	sprintf(buf, "You don't seem to be using any %s%s.\r\n", arg,
d2500 1
a2500 1
	send_to_char(buf, ch);
d2509 11
a2519 11
	perform_remove(ch, i);
	if (GET_EQ(ch, WEAR_WIELD2))  	{
	  if (!(GET_EQ(ch, WEAR_WIELD))) {
	    obj = GET_EQ(ch, WEAR_WIELD2);
	    obj_to_char(unequip_char(ch, WEAR_WIELD2), ch);
	    obj_from_char(obj);
	    equip_char(ch, obj, WEAR_WIELD);
	  } 
	}
	return;
      }	
d2652 1
a2652 1
         send_to_char("You are too exhausted!\r\n", ch);	      
d2659 13
a2671 13
	obj_from_room(tobj);	
	sprintf(buf, "You drag %s &0behind you.\r\n", tobj->short_description);	  
	send_to_char(buf, ch);	
	sprintf(buf, "$n &0drags %s &0behind $m.&0", tobj->short_description);
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	from_room = world[ch->in_room].number;  /* to log below */
	perform_move(ch, door, 1);
	obj_to_room(tobj, ch->in_room);
	sprintf(buf, "$n &0drags %s &0behind $m.&0", tobj->short_description);
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	to_room = world[ch->in_room].number;   /* to log below */
	
	if (IS_PLR_CORPSE(tobj)) {	
d2747 1
a2747 1
      break;		 
d2757 1
a2757 1
	!IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
d2776 50
a2825 50
	if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) || 
	    (IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))) {
	  if (temp < 80) {
	    /*  	 improve_skill(ch, SKILL_DOORBASH); */
	    sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n", 
		    fname(EXIT(ch, dir)->keyword));
	    send_to_char(buf, ch);
	    sprintf(buf, "&0$n &0charges at the %s but simply bounces off!&0", 
		    fname(EXIT(ch, dir)->keyword));
	    act(buf, FALSE, ch, 0, 0, TO_ROOM);
	    
	    WAIT_STATE(ch, PULSE_VIOLENCE*3);
	    if(GET_LEVEL(ch) < LVL_IMMORT) {
	      if ((GET_HIT(ch) - (((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch))) > -5) {
		GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
		update_pos(ch);
	      } else {
		GET_HIT(ch) = -5;
		update_pos(ch);
	      }
	      return;
	    }
	  }
	  
	  if (temp > 79) {
	    /*  	 improve_skill(ch, SKILL_DOORBASH); */
	    OPEN_DOORK(ch->in_room, dir);
	    
	    sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
	    act(buf, FALSE, ch, 0, 0, TO_ROOM);
	    sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n", 
		    fname(EXIT(ch, dir)->keyword));
	    send_to_char(buf, ch);
	    sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
	    act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);
	    
	    if (world[EXIT(ch, dir)->to_room].dir_option[rev_dir[dir]]) {
	      OPEN_DOORK(EXIT(ch, dir)->to_room, rev_dir[dir]);
	      WAIT_STATE(ch, PULSE_VIOLENCE);
	      perform_move(ch, dir, 1);
	    } else {
	      WAIT_STATE(ch, PULSE_VIOLENCE);
	      perform_move(ch, dir, 1);
	      return;
	    }


	  }
	  return;
	}
d2827 19
a2845 19
	/*       improve_skill(ch, SKILL_DOORBASH); */
	
	sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n", 
		fname(EXIT(ch, dir)->keyword));
	send_to_char(buf, ch);
	sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0", 
		fname(EXIT(ch, dir)->keyword));		
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	
	WAIT_STATE(ch, PULSE_VIOLENCE*3);
	if(GET_LEVEL(ch) < LVL_IMMORT) {
	  if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5) {
	    GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
	    update_pos(ch);
	  } else {
	    GET_HIT(ch) = -5;
	    update_pos(ch);}	
	} 
	return;
d2909 1
a2909 1
         } else if (number(1, 64) > 8) {	/* darn, PC failed to grab it. now they pay. */
d3064 1
a3064 1
#define SWAP(a,b)	{ temp = a; a = b; b = temp; }
d3188 3
@


1.100
log
@Added spells project and simulacrum, and MOB2_ILLUSORY flag.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.99 2008/01/06 05:31:35 jps Exp jps $
d1075 15
a1089 16
    if (!silent) {
      act("$n gives you $p, but you can't hold onto it.",
            FALSE, ch, obj, vict, TO_VICT);
      if (IS_SPLASHY(IN_ROOM(vict))) {
        act("You hand $p to $N, but it simply falls into the water.",
              FALSE, ch, obj, vict, TO_CHAR);
        act("$n gives $p to $N, but it falls into the water.",
              !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch),
              ch, obj, vict, TO_NOTVICT);
      } else {
        act("You hand $p to $N, but it simply falls to the ground.",
              FALSE, ch, obj, vict, TO_CHAR);
        act("$n gives $p to $N, but it falls to the ground.",
              !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch),
              ch, obj, vict, TO_NOTVICT);
      }
d3186 3
@


1.99
log
@Macro NOWEAR_CLASS for item flags that stop you from wearing equipment.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.98 2008/01/04 01:53:26 jps Exp jps $
d346 6
a351 1
    else if (get_otrigger(obj, ch)) {
d418 16
a433 10
  if (can_take_obj(ch, obj) && get_otrigger(obj, ch)) {
    obj_from_room(obj);
    obj_to_char(obj, ch);
    act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n gets $p.", !HIGHLY_VISIBLE(obj) || GET_INVIS_LEV(ch), ch, obj, 0, TO_ROOM);
    if (IS_OBJ_STAT(obj, ITEM_TRANSIENT) && GET_OBJ_TIMER(obj) < 5)
       GET_OBJ_TIMER(obj) = 5;
    unhide_object(obj);
    get_check_money(ch, obj);
    return 1;
d1071 24
d1131 1
d1154 19
d3187 3
@


1.98
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.97 2007/12/21 07:51:43 myc Exp jps $
a39 1
extern int invalid_class(struct char_data *ch, struct obj_data *obj);
d2014 1
a2014 1
            invalid_class(ch, obj)) {
d3132 4
@


1.97
log
@Give command now gives feedback for 'give all.item person' when you
have none of the item.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.96 2007/12/19 20:36:01 myc Exp myc $
d28 1
d3133 4
@


1.96
log
@Replaced static '4' with 'NUM_COIN_TYPES'.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.95 2007/11/18 20:01:05 jps Exp myc $
d1283 4
d3132 3
@


1.95
log
@Cause transient objects' timers to be reset when picked up.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.94 2007/11/18 16:51:55 myc Exp jps $
d1188 1
a1188 1
  int cash[4] = {0};
d3128 3
@


1.94
log
@Changing LVL_BUILDER reference to LVL_GOD.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.93 2007/10/25 20:37:00 myc Exp myc $
d418 2
d3128 3
@


1.93
log
@Fixed a bug that was throwing garbage bits in the RIP log.
Added the compare command, which lets you compare two similar items.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.92 2007/10/17 17:18:04 myc Exp myc $
d289 1
a289 1
  if (GET_LEVEL(ch) >= LVL_BUILDER)
d3126 4
@


1.92
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.91 2007/10/04 16:20:24 myc Exp myc $
d352 1
a352 2
      get_check_money(ch, obj);
      if(IS_PLR_CORPSE(cont)) {	
d360 1
d703 1
a703 1
	if(!str_cmp(buf,cont->name) && CONSENT(d->character) == ch) {
d3002 122
d3126 4
@


1.91
log
@The transient item flag now makes things decay when they are on the
ground.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.90 2007/09/21 18:08:29 jps Exp myc $
d2118 1
a2118 1
    if (!strcmp(arg, "!") || (where = search_block(arg, keywords, FALSE)) < 0) {
d3004 4
@


1.90
log
@Eating food will restore hit points, while drinking water will
restore movement points.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.89 2007/09/21 08:44:45 jps Exp jps $
a2398 7
    
    if(IS_OBJ_STAT(obj, ITEM_TRANSIENT)) {
      act("$p&0 crumbles to dust and blows away.",FALSE,ch,obj,0,TO_ROOM);
      act("$p&0 crumbles to dust and blows away.",FALSE,ch,obj,0,TO_CHAR);
      extract_obj(obj);
    }

d3004 4
@


1.89
log
@Added object type "touchstone" and command "touch" so you can set
your home room by touching specific objects.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.88 2007/09/20 21:20:43 myc Exp jps $
d1595 5
d1671 4
d3011 4
@


1.88
log
@Hide points and perception are in.  AFF_HIDE and ITEM_HIDDEN are now
unused.  Changes to conceal, palm, stow, and get.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.87 2007/09/03 23:59:43 jps Exp myc $
d2976 22
d3002 4
@


1.87
log
@Added macro ADDED_WEIGHT_OK for testing whether a char can have an
object added to its inventory.  Avoids an integer overflow problem
that could occur if an object's weight was near maxint.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.86 2007/08/26 01:55:19 myc Exp jps $
d18 1
d56 1
a56 2
#define CONCEAL_LEVEL_EFFECT	50
int conceal_chance(struct char_data *ch, struct obj_data *obj, int *people) {
d59 4
a62 8
  struct char_data *tch;
  int chance = GET_SKILL(ch, SKILL_CONCEAL) + number(0, 100) + dex_app_skill[GET_DEX(ch)].hide;

  if (people)
    *people = 0;

  /* Modify chance by weight. */
  chance -= (GET_OBJ_WEIGHT(obj) * 100) / MAX_CONCEAL_WEIGHT;
d68 3
a70 2
  /* It is more difficult to conceal items of a level closer to your own. */
  chance -= (GET_OBJ_LEVEL(obj) * CONCEAL_LEVEL_EFFECT) / GET_LEVEL(ch);
d72 3
a74 14
  /* If people can see you, it becomes more difficult. */
  if (ch->in_room != NOWHERE)
    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
      if (tch == ch)
        continue;
      if (CAN_SEE(tch, ch)) {
        /* This would be a great place to use Zzur's perception points. */
        chance -= GET_INT(tch) / 10;
        if (!CAN_SEE(ch, tch))
          chance -= GET_WIS(tch) / 10;
        else if (people)
          ++*people;
      }
    }
d76 1
a76 1
  return chance;
d196 1
a196 1
  struct char_data *tmp_char;
d219 1
a219 1
      generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
d242 1
a242 1
        int chance = conceal_chance(ch, obj, NULL);
d256 1
a256 1
            chance -= 20;
d263 9
a271 1
        if (chance <= 100) {
d273 5
a277 3
            act("$n tosses $p by $s feet.", TRUE, ch, obj, 0, TO_ROOM);
          else
            act("$n looks around, furtively slipping $p into $P.", TRUE, ch, obj, cont, TO_ROOM);
d310 7
d351 1
d418 1
d565 1
a565 1
  int obj_dotmode, cont_dotmode, cont_mode, chance, people;
d567 1
a567 1
  struct char_data *tmp_char;
d592 2
a593 1
      chance = conceal_chance(ch, obj, &people);
d596 17
d617 1
a618 2
      if (chance <= 100)
        act("$n coyly snatches $p off the ground.", TRUE, ch, obj, 0, TO_ROOM);
d624 1
a624 1
    cont_mode = generic_find(arg2, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
d642 1
a642 1
          chance = conceal_chance(ch, obj, &people);
d646 15
a661 2
          if (chance <= 100)
            act("$n quietly slips $p out of $P.", FALSE, ch, obj, cont, TO_ROOM);
d2889 1
d2902 1
a2902 1
  else if (!CAN_WEAR(obj, ITEM_WEAR_TAKE)) {
d2906 1
a2906 1
  else if (GET_OBJ_WEIGHT(obj) > MAX_CONCEAL_WEIGHT) {
d2910 1
a2910 1
  else if (IS_WATER(IN_ROOM(ch)))
a2911 2
  else if (IS_OBJ_STAT(obj, ITEM_HIDDEN))
    act("$p is already concealed pretty well!", FALSE, ch, obj, 0, TO_CHAR);
d2914 2
d2917 1
a2917 2
    int people;
    int chance = conceal_chance(ch, obj, &people);
d2919 33
a2951 11
    /* Success! */
    if (chance > 100) {
      if (IS_FOREST(ch->in_room))
        act("You steathily conceal $p under some bushes.", FALSE, ch, obj, 0, TO_CHAR);
      else if (OUTSIDE(ch))
        act("You surreptitiously cover up $p.", FALSE, ch, obj, 0, TO_CHAR);
      else
        act("You furtively conceal $p in a corner.", FALSE, ch, obj, 0, TO_CHAR);
      if (chance <= 130)
        act("You spot $n concealing $p in the room!", TRUE, ch, obj, 0, TO_ROOM);
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_HIDDEN);
d2956 6
a2961 2
      if (chance <= 30 && AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
        appear(ch);
d2967 1
a2967 4
        if (people > 1 && number(0, 1))
          act("As you attempt to conceal $p, you get the feeling you've been spotted...", FALSE, ch, obj, 0, TO_CHAR);
        else
          act("You try to conceal $p, but can't find a good spot.", FALSE, ch, obj, 0, TO_CHAR); 
d2980 5
@


1.86
log
@Adding lag to conceal, palm, stow.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.85 2007/08/17 03:34:41 myc Exp myc $
d298 1
a298 1
  } else if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
d1009 1
a1009 1
  if (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(vict) > CAN_CARRY_W(vict)) {
d2922 3
@


1.85
log
@Correct error message for do_conceal when no argument.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.84 2007/08/16 19:53:38 myc Exp myc $
d283 1
d597 1
d627 1
d2914 1
a2914 1
    WAIT_STATE(ch, PULSE_VIOLENCE / 2);
d2922 3
@


1.84
log
@Adding stow/palm commands as secondary functionality to conceal skill.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.83 2007/08/14 22:43:07 myc Exp myc $
d2857 2
d2919 3
@


1.83
log
@Adding 'conceal' skill which lets you hide items in the room.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.82 2007/08/03 22:00:11 myc Exp myc $
d49 44
d108 1
a108 1
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0)) {
d110 3
a112 6
    return;
  } else if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
    sprintf(buf, "You can't put $p in $P, it must be CURSED!");
    act(buf, FALSE, ch, obj, cont, TO_CHAR);
    return;
  } else {
d205 84
d554 87
a2847 2
#define MAX_CONCEAL_WEIGHT	200

a2850 1
  extern struct dex_skill_type dex_app_skill[];
d2873 2
d2876 2
a2877 19
    int chance = GET_SKILL(ch, SKILL_CONCEAL) + number(0, 100) + dex_app_skill[GET_DEX(ch)].hide;
    int people = 0;
    struct char_data *tch;

    /* Weighted chance for weight. */
    chance -= (GET_OBJ_WEIGHT(obj) * 100) / MAX_CONCEAL_WEIGHT;

    /* If people can see you, it becomes more difficult. */
    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
      if (tch == ch)
        continue;
      if (CAN_SEE(tch, ch)) {
        chance -= GET_INT(tch) / 10;
        if (!CAN_SEE(ch, tch))
          chance -= GET_WIS(tch) / 10;
        else
          ++people;
      }
    }
d2917 3
@


1.82
log
@Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.81 2007/07/19 21:59:52 jps Exp myc $
d2636 85
d2723 3
@


1.81
log
@Dynamic strings for drink containers.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.80 2007/07/19 15:32:01 jps Exp jps $
d1480 1
a1480 1
      send_to_char("You can't find it!", ch);
d1546 1
a1546 1
    sprintf(buf, "You pour the %s into the %s\r\n.",
d2224 2
a2225 2
  if ((!*arg2)||(!*arg1)) {
    send_to_char("Drag what? Where?", ch);
d2546 1
a2546 1
    send_to_char("You're home room isn't set!", ch);
d2638 3
@


1.80
log
@Add "extinguish" as a subcommand of light.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.79 2007/07/15 18:01:46 myc Exp jps $
d1069 14
a1082 1
void name_from_drinkcon(struct obj_data * obj)
d1084 19
a1102 12
  int i;
  char *new_name;
  extern struct obj_data *obj_proto;
  
  for (i = 0; (*((obj->name) + i) != ' ') && (*((obj->name) + i) != '\0'); i++);
  
  if (*((obj->name) + i) == ' ') {
    new_name = str_dup((obj->name) + i + 1);
    if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
      free(obj->name);
    obj->name = new_name;
  }
d1109 4
a1112 1
  extern char *drinknames[];
d1114 3
a1116 5
  CREATE(new_name, char, strlen(obj->name) + strlen(drinknames[type]) + 2);
  sprintf(new_name, "%s %s", drinknames[type], obj->name);
  if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
    free(obj->name);
  obj->name = new_name;
d1119 117
d1348 2
a1349 3
    GET_OBJ_VAL(temp, 2) = 0;
    IS_POISONED(temp) = FALSE;
    name_from_drinkcon(temp);
a1516 1
      GET_OBJ_VAL(from_obj, 2) = 0;
d1518 1
a1518 1
      name_from_drinkcon(from_obj);
d1546 1
a1546 1
    sprintf(buf, "You pour the %s into the %s.",
a1553 6
  /* New alias */
  if (GET_OBJ_VAL(to_obj, 1) == 0)
    name_to_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2));
  
  /* First same type liq. */
  GET_OBJ_VAL(to_obj, 2) = GET_OBJ_VAL(from_obj, 2);
d1564 1
a1570 1
       GET_OBJ_VAL(from_obj, 2) = 0;
d1572 1
a1572 1
       name_from_drinkcon(from_obj);
d2638 3
@


1.79
log
@You can now put lit permanent lights into containers.  Lit nonpermanent
lights are automatically extinguished.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.78 2007/07/15 17:16:12 jps Exp myc $
d1897 4
a1900 1
      send_to_char("Light what?\r\n", ch);
d1918 8
d1927 7
a1933 21
      if (GET_OBJ_TYPE(obj) == ITEM_LIGHT) {
         if (GET_OBJ_VAL(obj, 2) != 0) {  /* It is not worn out */
            if (GET_OBJ_VAL(obj, 2) < 0) {  /* It's a permanent light */
               act("You activate $p.", TRUE, ch, obj, 0, TO_CHAR);
               act("$n activates $p.", TRUE, ch, obj, 0, TO_ROOM);
            } else {
               act("You light $p.", TRUE, ch, obj, 0, TO_CHAR);
               act("$n lights $p.", TRUE, ch, obj, 0, TO_ROOM);
            }
            GET_OBJ_VAL(obj, 0) = 1;  /* Now it's lit */
            if (ch->in_room != NOWHERE)
               world[ch->in_room].light++;
            else
               log("SYSERR: do_light - my char_data* object wasn't in a room!");
         } else
            act("Sorry, there's no more power left in $p.", TRUE, ch,  obj, 0, TO_CHAR);
      } else
         send_to_char("You can't light that!\r\n", ch);
   } else {
      /* It was already lit, so we are extinguishing it */
      if (GET_OBJ_TYPE(obj) == ITEM_LIGHT) {
d1935 2
a1936 2
            act("You deactivate $p.", TRUE, ch, obj, 0, TO_CHAR);
            act("$n deactivates $p.", TRUE, ch, obj, 0, TO_ROOM);
d1938 2
a1939 9
            act("You extinguish $p.", TRUE, ch, obj, 0, TO_CHAR);
            act("$n extinguishes $p.", TRUE, ch, obj, 0, TO_ROOM);
         }
         GET_OBJ_VAL(obj, 0) = 0;
         if (GET_OBJ_VAL(obj, 2) != 0) {
            if (ch->in_room != NOWHERE)
               world[ch->in_room].light--;
            else
               log("SYSERR: do_light (extinguishing) - my char_data* object wasn't in a room!");
d1941 5
d1947 17
a1963 1
          send_to_char("You can't light that!\r\n", ch);          
d2508 4
@


1.78
log
@Add IS_POISONED macro, and moved HIGHLY_VISIBLE macro to utils.h
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.77 2007/07/14 14:34:15 myc Exp jps $
a70 3
  } else if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1) {
    act("You need to deactivate $p before putting it into $P.", FALSE, ch, obj, cont, TO_CHAR);
    return;
d74 14
a87 2
    act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
    act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
d2497 3
@


1.77
log
@Actions on highly visible objects are only seen when the actor is not
wiz-invis.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.76 2007/07/14 01:00:14 jps Exp myc $
a32 4
#define HIGHLY_VISIBLE(obj) (GET_OBJ_WEIGHT(obj) > 6 || \
      (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL((obj), 0) == 1) || \
      IS_OBJ_STAT((obj), ITEM_GLOW))

d1186 1
a1186 1
  if (GET_OBJ_VAL(temp, 3)) {	/* The shit was poisoned ! */
d1202 1
a1202 1
    GET_OBJ_VAL(temp, 3) = 0;
d1258 1
a1258 2
  if (GET_OBJ_VAL(food, 3) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    /* The shit was poisoned ! */
d1372 1
a1372 1
      GET_OBJ_VAL(from_obj, 3) = 0;
d1422 1
a1422 3
  /* poison */
  GET_OBJ_VAL(to_obj, 3) =
    (GET_OBJ_VAL(to_obj, 3) || GET_OBJ_VAL(from_obj, 3));
d1432 1
a1432 1
       GET_OBJ_VAL(from_obj, 3) = 0;
d2488 4
@


1.76
log
@Clear the af struct before use, so that poison doesn't set all
kinds of random unintended effects.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.75 2007/05/28 23:41:34 jps Exp jps $
d282 1
a282 1
    act("$n gets $p.", !HIGHLY_VISIBLE(obj), ch, obj, 0, TO_ROOM);
d536 1
a536 1
  act(buf, !HIGHLY_VISIBLE(obj), ch, obj, 0, TO_ROOM);
d809 1
a809 1
    act("$n gives $p to $N.", !HIGHLY_VISIBLE(obj), ch, obj, vict, TO_NOTVICT);
d1033 1
a1033 1
    act("$n gives $p to $N.", !HIGHLY_VISIBLE(ref_obj), ch, ref_obj, vict, TO_NOTVICT);
d1039 1
a1039 1
    act("$n gives $p to $N. (multiple)", !HIGHLY_VISIBLE(ref_obj), ch, ref_obj, vict, TO_NOTVICT);
d1412 1
a1412 1
    act("$n gently fills $p from $P.", !HIGHLY_VISIBLE(to_obj), ch, to_obj, from_obj, TO_ROOM);
d2495 4
@


1.75
log
@put and get will interact first with equipped containers.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.74 2007/05/28 06:35:49 jps Exp jps $
d1194 1
d1267 1
d2495 3
@


1.74
log
@Use the verb "activate" for permanent lights and "extinguish" otherwise.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.73 2007/05/27 17:45:28 jps Exp jps $
d118 1
a118 1
    generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
d353 1
a353 1
      mode = generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
d2493 3
@


1.73
log
@Fix pluralization in not-found messages.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.72 2007/05/27 17:34:42 jps Exp jps $
d1914 7
a1920 2
            act("You activate $p.", TRUE, ch, obj, 0, TO_CHAR);
            act("$n activates $p.", TRUE, ch, obj, 0, TO_ROOM);
d1933 7
a1939 2
         act("You deactivate $p.", TRUE, ch, obj, 0, TO_CHAR);
         act("$n deactivates $p.", TRUE, ch, obj, 0, TO_ROOM);
a1955 7
  
  /* David Endre - 3/9/99 Zzur wants the <used at light> position removed
     but he also wants it saved in case we find something else to put there
     so, let's just not let a character use the position by attempting to
     hold a light. When we find something else to put in it's place
     all we need to do is replace all the wear stuff. Actually, even simpler
     if you hold a light it goes to the hold position. */
d2090 1
a2090 1
    send_to_char("You don't have the proper leverage to do that, try standing.\r\n", ch);
d2493 3
@


1.72
log
@Typo fix "You slide <item> onto your ... finger"
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.71 2007/05/24 05:02:49 jps Exp jps $
d148 2
a149 1
	    sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
d265 2
a266 1
	sprintf(buf, "You can't seem to find any %ss in $p.", arg);
d321 2
a322 1
	sprintf(buf, "You don't see any %ss here.\r\n", arg);
d413 2
a414 1
	  sprintf(buf, "You can't seem to find any %ss here.\r\n", arg2);
d721 2
a722 1
	sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
d1780 2
a1781 1
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
d2036 2
a2037 1
	sprintf(buf, "You don't seem to be using any %ss.\r\n", arg);
d2490 3
@


1.71
log
@Rewrite do_wield. Fix bug with refusing to wield when one hand holds an item.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.70 2007/05/21 01:35:22 jps Exp jps $
d1448 2
a1449 2
    {"$n slides $p on to $s right ring finger.",
     "You slide $p on to your right ring finger."},
d1451 2
a1452 2
    {"$n slides $p on to $s left ring finger.",
     "You slide $p on to your left ring finger."},
d2483 3
@


1.70
log
@Fix 'wear <weapon>' allowing dual wield without the skill.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.69 2007/04/18 00:23:34 myc Exp jps $
d53 10
d1538 1
a1538 1
  int a = 0;
d1628 2
a1629 8
      a = 0; /* the number of hands currently occupied */

      if (GET_EQ(ch, WEAR_2HWIELD)) a += 2;
      if (GET_EQ(ch, WEAR_HOLD))    a++;
      if (GET_EQ(ch, WEAR_HOLD2))   a++;
      if (GET_EQ(ch, WEAR_SHIELD))  a++;
      if (GET_EQ(ch, WEAR_WIELD))   a++;
      if (GET_EQ(ch, WEAR_WIELD2))  a++;
d1637 1
a1637 1
      } else if (a == 1 && (where == WEAR_WIELD || where == WEAR_WIELD2) &&
d1813 21
a1833 10
ACMD(do_wield)
{
  struct obj_data *obj;
  struct obj_data *wielding = GET_EQ(ch, WEAR_WIELD);
  struct obj_data *hwielding = GET_EQ(ch, WEAR_2HWIELD);
  
  one_argument(argument, arg);
  
  /* No more animals wielding weapons, maybe should fix do wear as well
     RSD 4/22/00 */
d1835 1
a1835 10
  if (GET_SPECIES(ch) == SPECIES_ANIMAL) {
    return;
  }
  if (!*arg)
    send_to_char("Wield what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (!CAN_WEAR(obj, ITEM_WEAR_WIELD) && !CAN_WEAR(obj, ITEM_WEAR_2HWIELD))
d1837 4
a1840 4
    if (CAN_WEAR(obj, ITEM_WEAR_WIELD) && (hwielding))
      send_to_char("You cant dual wield while wielding a two-hand weapon.\r\n", ch);
    
    else if (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w)
d1842 24
a1865 38
    else if ((!wielding) && (!hwielding)) {
      if (CAN_WEAR(obj, ITEM_WEAR_WIELD) || GET_CLASS(ch) == RACE_OGRE) 
	perform_wear(ch, obj, WEAR_WIELD);
      else if (CAN_WEAR(obj, ITEM_WEAR_2HWIELD))
	perform_wear(ch, obj, WEAR_2HWIELD);
      
      
    }	else {
      
      
      
      
      if (GET_SKILL(ch, SKILL_DUAL_WIELD))
	{
	  struct obj_data *wielding = GET_EQ(ch, WEAR_WIELD);
	  struct obj_data *wielding2 = GET_EQ(ch, WEAR_WIELD2);
	  struct obj_data *hwielding = GET_EQ(ch, WEAR_2HWIELD);
	  
	  if (wielding)
	    {
	      if (!*arg)
		send_to_char("Wield what?\r\n", ch);
	      else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
		sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
		send_to_char(buf, ch);
	      } else {
		if (!CAN_WEAR(obj, ITEM_WEAR_WIELD)) 
		  send_to_char("You can't wield that.\r\n", ch);
		if (CAN_WEAR(obj, ITEM_WEAR_WIELD) && (hwielding) &&
                  GET_CLASS(ch) != RACE_OGRE)
		  send_to_char("You cant dual wield while wielding a two-hand weapon.\r\n", ch);
		
		else if (GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w)
		  send_to_char("It's too heavy for you to use.\r\n", ch);
		else if (!wielding2)
		  perform_wear(ch, obj, WEAR_WIELD2);
                else /*wielding in 1 and 2*/
                  send_to_char("You don't seem to have a spare hand...\r\n",ch);
d1867 10
a1876 9
		
	      }
	    }
	}
        else
          send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
    }
    
  }
a1878 2
/* Added to allow lit objects in your inventory 
   David Endre 2/2/98 */
d2483 3
@


1.69
log
@Fixed a typo in perform_wear.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.68 2007/04/15 10:36:53 jps Exp myc $
d1633 4
d2492 3
@


1.68
log
@Make take/drop/give messages always visible when the object being
manipulated is highly visible (lit, glowing, or large).
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.67 2007/04/11 14:15:28 jps Exp jps $
d1562 1
a1562 1
    "You're already wielding a weopon there!\r\n",
d2488 4
@


1.67
log
@Give money piles proper keywords and make them dissolve when stolen.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.66 2007/04/11 07:25:43 jps Exp jps $
d33 4
d270 1
a270 1
    act("$n gets $p.", TRUE, ch, obj, 0, TO_ROOM);
d522 1
a522 1
  act(buf, TRUE, ch, obj, 0, TO_ROOM);
d794 1
a794 1
    act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
d1018 1
a1018 1
    act("$n gives $p to $N.", TRUE, ch, ref_obj, vict, TO_NOTVICT);
d1024 1
a1024 1
    act("$n gives $p to $N. (multiple)", TRUE, ch, ref_obj, vict, TO_NOTVICT);
d1353 1
a1353 1
      act("$n empties $p.", TRUE, ch, from_obj, 0, TO_ROOM);
d1395 1
a1395 1
    act("$n gently fills $p from $P.", TRUE, ch, to_obj, from_obj, TO_ROOM);
a1997 63
    /* Moved to unequip_char in handler.c by DCE 07-dec-01 */
    /* Spell affects from objects redone by DCE 07-dec-01 */
/*    if (IS_OBJ_SPELL_AFF(obj, GET_OBJ_SPELL(obj)))
      REMOVE_BIT(AFF_FLAGS(ch), GET_OBJ_SPELL(obj));
    if (IS_OBJ_SPELL_AFF2(obj, GET_OBJ_SPELL2(obj)))
      REMOVE_BIT(AFF2_FLAGS(ch), GET_OBJ_SPELL2(obj));
    if (IS_OBJ_SPELL_AFF3(obj, GET_OBJ_SPELL3(obj)))
      REMOVE_BIT(AFF3_FLAGS(ch), GET_OBJ_SPELL3(obj));
    update_pos(ch); */
/*    
    AFF_FLAGS(ch) = (GET_OBJ_SPELL(obj) ^ AFF_FLAGS(ch));
    AFF2_FLAGS(ch) = (GET_OBJ_SPELL2(obj) ^ AFF2_FLAGS(ch));
    AFF3_FLAGS(ch) = (GET_OBJ_SPELL3(obj) ^ AFF3_FLAGS(ch)); */
    /* upgrading this -nechtrous 
       if (IS_OBJ_SPELL_AFF(obj, ITEM_BLIND))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_BLIND);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_INVIS))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_INVIS);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_ALIGN))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_ALIGN);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_MAGIC))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_DETECT_MAGIC);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_BLUR))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_BLUR);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_HASTE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_HASTE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_INVIS))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_EVIL))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_PROTECT_EVIL);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_GOOD))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_PROTECT_GOOD);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SANCTUARY))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SANCTUARY);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SLEEP)){
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SLEEP);
       GET_POS(ch) = POS_SITTING;
       update_pos(ch);}
       if (IS_OBJ_SPELL_AFF(obj, ITEM_STONESKIN))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SENSE_LIFE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_INFRA))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_FLY))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_FLYING);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_FARSEE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_FARSEE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_COMP_LANG))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_COMP_LANG);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_PARALIZE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_MAJOR_PARA);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_POISON))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_POISON);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_SNEAK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_SNEAK);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_HIDE))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_WATERWALK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_WATERWALK);
       if (IS_OBJ_SPELL_AFF(obj, ITEM_NOTRACK))
       REMOVE_BIT(AFF_FLAGS(ch), AFF_NOTRACK);
    */
d2488 3
@


1.66
log
@Remove magic numbers from hand-equipping code.  Make the wear command
equip weapons wielded secondary as well.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.65 2007/02/20 17:16:27 myc Exp jps $
d447 1
d470 2
a471 1
	sprintf(buf, "$n drops %s.", money_desc(amount));
d476 2
a477 2
      sprintf(buf, "$n drops %s which disappears in a puff of smoke!",
	      money_desc(amount));
d2547 4
@


1.65
log
@Fixed crash bug in doorbash.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.64 2006/12/08 05:06:58 myc Exp myc $
d1568 10
a1577 10
  /* first, make sure that the wear position is valid. */
  /* Only allow light items in the light pos, and then only
     when they cannot be worn anywhere else - myc 5 Dec 2006 */
  if (!CAN_WEAR(obj, wear_bitvectors[where]) ||
      (where == 0 && GET_OBJ_TYPE(obj) != ITEM_LIGHT) ||
      (where == 0 && GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
       GET_OBJ_WEAR(obj) != ITEM_WEAR_TAKE + ITEM_WEAR_HOLD)) {
    if (!(IS_NPC(ch)))
      act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
    return;
d1580 7
a1586 16
  /* Check the level of the object. Zantir 3/23/01 */
  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
    if (!IS_NPC(ch)) {
      act("You're not a high enough level to use $p.", 
	  FALSE, ch, obj, 0, TO_CHAR);
      act("$n struggles and fails to use $p.", TRUE, ch, obj, 0, TO_ROOM);
    }
    return;
  }
  
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
	invalid_class(ch, obj)) {
      act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
d1588 39
a1626 14
    }
  }
  /* for neck, finger, and wrist, try pos 2 if pos 1 is already full */
  
  if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R) || (where == WEAR_HOLD) ||
      (where == WEAR_LEAR))
    if (GET_EQ(ch, where))
      where++;
  if (where == 11 || ((where >= 16) && (where <= 20)))  {
    a = 0;
    if (GET_EQ(ch, WEAR_2HWIELD))
      {
	a++;
	a++;
d1628 4
a1631 17
    if (GET_EQ(ch, WEAR_HOLD))
      a++;
    if (GET_EQ(ch, WEAR_HOLD2)) 
      a++;
    if (GET_EQ(ch, WEAR_SHIELD)) 
      a++;
    if (GET_EQ(ch, WEAR_WIELD)) 
      a++;
    if (GET_EQ(ch, WEAR_WIELD2)) 
      a++;
    if ((GET_OBJ_WEAR(obj) & ITEM_WEAR_2HWIELD) && (a >= 1))
    {
	    send_to_char("You need both hands free for this weapon!\r\n",ch);
	    return;
    }
    else if (a >= 2) {
      send_to_char("Both of your hands are already using something.\r\n", ch);
d1633 1
a1633 5
    }
  }	  if (GET_EQ(ch, where)) {
    send_to_char(already_wearing[where], ch);
    return;
  }
d1635 5
a1639 71
  if (!wear_otrigger(obj, ch, where))
    return;
  wear_message(ch, obj, where);
  obj_from_char(obj);
  equip_char(ch, obj, where);

  /* Moved to equip_char in handler.c by DCE 07-dec-01 */
  /* Spell affects from objects redone by DCE 07-dec-01
  if (IS_OBJ_SPELL_AFF(obj, GET_OBJ_SPELL(obj)))
    SET_BIT(AFF_FLAGS(ch), GET_OBJ_SPELL(obj));
  if (IS_OBJ_SPELL_AFF2(obj, GET_OBJ_SPELL2(obj)))
    SET_BIT(AFF2_FLAGS(ch), GET_OBJ_SPELL2(obj));
  if (IS_OBJ_SPELL_AFF3(obj, GET_OBJ_SPELL3(obj)))
    SET_BIT(AFF3_FLAGS(ch), GET_OBJ_SPELL3(obj));
  update_pos(ch); */

  /* SPELL AFFECTS FROM OBJECTS -revised by nechtrous
  AFF_FLAGS(ch) = (GET_OBJ_SPELL(obj) | AFF_FLAGS(ch));
  AFF2_FLAGS(ch) = (GET_OBJ_SPELL2(obj) | AFF2_FLAGS(ch));
  AFF3_FLAGS(ch) = (GET_OBJ_SPELL3(obj) | AFF3_FLAGS(ch));
  */
  /* I am upgrading this.... -Nechtrous
     if (IS_OBJ_SPELL_AFF(obj, ITEM_BLIND))
     SET_BIT(AFF_FLAGS(ch), AFF_BLIND);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_INVIS))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_INVIS);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_ALIGN))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_ALIGN);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_DET_MAGIC))
     SET_BIT(AFF_FLAGS(ch), AFF_DETECT_MAGIC);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_BLUR))
     SET_BIT(AFF_FLAGS(ch), AFF_BLUR);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_HASTE))
     SET_BIT(AFF_FLAGS(ch), AFF_HASTE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_INVIS))
     SET_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_EVIL))
     SET_BIT(AFF_FLAGS(ch), AFF_PROTECT_EVIL);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PROT_GOOD))
     SET_BIT(AFF_FLAGS(ch), AFF_PROTECT_GOOD);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SANCTUARY))
     SET_BIT(AFF_FLAGS(ch), AFF_SANCTUARY);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SLEEP)){
     SET_BIT(AFF_FLAGS(ch), AFF_SLEEP);
     GET_POS(ch) = POS_SLEEPING;
     update_pos(ch);}
     if (IS_OBJ_SPELL_AFF(obj, ITEM_STONESKIN))
     SET_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SENSE_LIFE))
     SET_BIT(AFF_FLAGS(ch), AFF_SENSE_LIFE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_INFRA))
     SET_BIT(AFF_FLAGS(ch), AFF_INFRAVISION);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_FLY))
     SET_BIT(AFF_FLAGS(ch), AFF_FLYING);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_FARSEE))
     SET_BIT(AFF_FLAGS(ch), AFF_FARSEE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_COMP_LANG))
     SET_BIT(AFF_FLAGS(ch), AFF_COMP_LANG);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_PARALIZE))
     SET_BIT(AFF_FLAGS(ch), AFF_MAJOR_PARA);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_POISON))
     SET_BIT(AFF_FLAGS(ch), AFF_POISON);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_SNEAK))
     SET_BIT(AFF_FLAGS(ch), AFF_SNEAK);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_HIDE))
     SET_BIT(AFF_FLAGS(ch), AFF_HIDE);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_WATERWALK))
     SET_BIT(AFF_FLAGS(ch), AFF_WATERWALK);
     if (IS_OBJ_SPELL_AFF(obj, ITEM_NOTRACK))
     SET_BIT(AFF_FLAGS(ch), AFF_NOTRACK);
  */
d2545 3
@


1.64
log
@Bribe triggers now give proper amounts and variables.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.63 2006/12/06 02:14:21 myc Exp myc $
d2427 6
d2435 1
a2435 1
      if (!IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF)) {
d2472 1
a2472 2
	    if (EXIT(ch, rev_dir[dir])) {
	      
d2612 3
@


1.63
log
@Allowed use of 'worn as light' pos to players for lights that
are holdable and not wearable anywhere else.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.62 2006/11/30 05:06:24 jps Exp $
a32 6
/*coin defins*/
#define PLAT 0
#define GOLD 1
#define SILVER 2
#define COPPER 3

a867 1
            bribe_mtrigger(vict, ch, cPtr[PLAT]);
a875 1
            bribe_mtrigger(vict, ch, cPtr[GOLD]);
a883 1
            bribe_mtrigger(vict, ch, cPtr[SILVER]);
a891 1
            bribe_mtrigger(vict, ch, cPtr[COPPER]);
d894 1
d2607 4
@


1.62
log
@Add remove trigger for objects
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.61 2006/11/24 06:50:02 jps Exp jps $
d1438 2
a1439 2
    {"$n lights $p and holds it.",
     "You light $p and hold it."},
d1578 6
a1583 1
  if (!CAN_WEAR(obj, wear_bitvectors[where])) {
d1725 1
a1725 1
    "!RESERVED!",
d1756 3
d2616 3
@


1.61
log
@Draggability is now conferred with the TAKE wear flag.
An exception is made for corpses.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.60 2006/11/21 20:17:04 jps Exp jps $
d2045 2
d2608 4
@


1.60
log
@Fix feedback when trying to pour: "The <name> is empty."
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.59 2006/11/21 03:45:52 jps Exp jps $
a2186 2
     /* Buru 30/11/97 */
     /* De-{-ified by Zzur 8/7/99 */
d2190 1
a2190 1
  int door = 0, k = 0, from_room = 0, to_room = 0;
a2206 2
  /* David Endre 1/25/99 Zzur doesn't want flying people to
                         drag things */
d2242 28
a2269 8
  k = generic_find(arg1, FIND_OBJ_ROOM | FIND_CHAR_ROOM, ch, &tch, &tobj);
  
  if (!k){
    send_to_char("&0Can't find that!&0\r\n", ch);
    return;
  }
  if (k == FIND_OBJ_ROOM) {
    if (GET_OBJ_TYPE(tobj) == ITEM_PORTAL) {
d2272 41
a2312 4
    }
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE && !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED)) {
      if (GET_OBJ_WEIGHT(tobj) > (CAN_CARRY_W(ch)*3)) {
	send_to_char("&0It is too heavy for you to drag!&0", ch); 
d2314 3
a2316 28
	/* Added functionality to check for consent to prevent players from
	 * dragging each others corpses. Zzur 8/7/1999
 	 */
	if(IS_PLR_CORPSE(tobj)) {
	  if(!corpse_consent(ch, tobj)) {
	    sprintf(buf,"killed:%s tried to drag %s without CONSENT!", GET_NAME(ch), tobj->short_description);
	    mudlog(buf, BRF, LVL_IMMORT, TRUE);
	    log(buf);
	    return;
	  }
	}
	if (GET_LEVEL(ch)<LVL_GOD) {
	  if (GET_OBJ_WEIGHT(tobj)>50) {
	    if (GET_MOVE(ch)-((GET_OBJ_WEIGHT(tobj)/50)+(movement_loss[SECT(ch->in_room)]))<(0)) {
	      send_to_char("&0You are too exhausted!&0\r\n", ch);	      
	      return;
	    } else {
	      GET_MOVE(ch) = GET_MOVE(ch)-((GET_OBJ_WEIGHT(tobj)/50)+(movement_loss[SECT(ch->in_room)]));
	    }
	  } else {
	    if(GET_MOVE(ch)-(4) < 0) {
	      send_to_char("&0You are too exhausted!&0\r\n", ch);
	      return;
	    } else { 
	      GET_MOVE(ch) = GET_MOVE(ch)-(4);
	    }
	  }
	}
d2319 1
a2319 1
	sprintf(buf, "&0You drag %s &0behind you.\r\n", tobj->short_description);	  
d2321 1
a2321 1
	sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);
d2326 1
a2326 1
	sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);
d2330 7
a2336 27
	if(IS_PLR_CORPSE(tobj)) {	
	  /* Note: killed is the keyword autorun greps on to sort corpse info
	   *       into the rip log.
	   */
	  sprintf(buf,"killed: %s drags %s from room %d to room %d.",GET_NAME(ch),tobj->short_description,from_room,to_room);
	  log(buf);
	}
      }
      return;
    } else { 
      send_to_char("&0You can't go that way!&0\r\n", ch);
    }
    return;
  }
  if (k == FIND_CHAR_ROOM) {
    if (ch == tch)
       /* Tried to drag yourself. */
       send_to_char("One foot in front of the other, now...\r\n", ch);
    else {
       sprintf(buf, "&0Maybe you should kill $M first!&0");
       act(buf, FALSE, ch, 0, tch, TO_CHAR);
    }
    return;
  } else {
    send_to_char("&0You can't drag that!&0\r\n", ch);
  }
  return;
d2606 3
@


1.59
log
@The 'light' command now looks first at equipped items.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.58 2006/11/18 21:00:28 jps Exp jps $
d1347 1
a1347 1
    act("The $p is empty.", FALSE, ch, from_obj, 0, TO_CHAR);
d2598 3
@


1.58
log
@Reworked disarm skill and disarmed-weapon retrieval.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.57 2006/11/18 09:08:15 jps Exp jps $
d1948 4
a1951 2
  struct obj_data *obj;
  one_argument(argument, arg);
d1953 46
a1998 34
  if (!*arg)
    send_to_char("Light what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)) &&
           !((obj = get_obj_in_list(arg, ch->carrying)) && 
	     GET_OBJ_TYPE(obj) == ITEM_LIGHT)) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (GET_OBJ_VAL(obj, 0) == 0) {
       if (GET_OBJ_TYPE(obj) == ITEM_LIGHT) {
          if (GET_OBJ_VAL(obj, 2) != 0) {
             act("You activate $p.", TRUE, ch, obj, 0, TO_CHAR);
             act("$n activates $p.", TRUE, ch, obj, 0, TO_ROOM);
             GET_OBJ_VAL(obj, 0) = 1;
             if (ch->in_room != NOWHERE)
                world[ch->in_room].light++;
             else
                log("SYSERR: do_light - didn't turn on!");
          } else
             act("Sorry, there's no more power left in $p.", TRUE, ch,  obj, 0, TO_CHAR);
       } else
          send_to_char("You can't light that!\r\n", ch);
    } else {
       if (GET_OBJ_TYPE(obj) == ITEM_LIGHT) {
          act("You deactivate $p.", TRUE, ch, obj, 0, TO_CHAR);
          act("$n deactivates $p.", TRUE, ch, obj, 0, TO_ROOM);
          GET_OBJ_VAL(obj, 0) = 0;
          if (GET_OBJ_VAL(obj, 2) != 0) {
             if (ch->in_room != NOWHERE)
                world[ch->in_room].light--;
             else
                log("SYSERR: do_light - didn't turn off!");
          }
       } else
d2000 1
a2000 2
    }
  }
d2598 3
@


1.57
log
@Use pretty-printing statemoney to format coins
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.56 2006/11/18 04:26:32 jps Exp jps $
d2528 45
a2572 48
  if (IS_SET(obj->obj_flags.extra_flags, ITEM_WAS_DISARMED)) {
    /* make sure owner isn't dead, or has left room. either case means */
    /* he doesn't care about his item(s) any longer */
    LOOP_THRU_PEOPLE(tmp_ch, ch)
      if (tmp_ch != ch && tmp_ch == last_to_hold)
	break;
    
    if (tmp_ch && AWAKE(tmp_ch)) {
      /*if (racial_traits[GET_RACE(last_to_hold)].has_hands &&
	racial_traits[GET_RACE(last_to_hold)].can_talk) {*/
      strcpy(Gbuf4, "No you don't!! That belongs to me!");
      do_say(last_to_hold, Gbuf4, cmd_say, 0);
      /*} else {
	strcpy(Gbuf4, "GRRRRRRRR!!");
	do_yell(last_to_hold, Gbuf4, 0);
	}*/
      
      strcpy(Gbuf4, GET_NAME(ch));
      do_action(last_to_hold, Gbuf4, cmd_glare, 0);
      
      if (number(1, 64) > 8) {	/* darn, PC failed to grab it. now they pay. */
	rand = number(1, 4);
	
	retval = TRUE;
	
	if (rand == 1) {
	  act("$N plants $S solid brickhouse body directly in front of $n, ", FALSE, ch, 0, last_to_hold, TO_ROOM);
	  act("making $o totally inaccessible.", FALSE, ch, obj, 0, TO_ROOM);
	  act("$N steps directly in front of your path.  No way to get it now.", FALSE, ch, 0, last_to_hold, TO_CHAR);
	} else if (rand == 2) {
	  act("$N throws $self within $o's close vicinity, making it totally impossible to get to.",
	      FALSE, ch, obj, last_to_hold, TO_ROOM);
	  act("$N hurdles $Mself into close vicinity of the $o.  Impossible to get to now!",
	      FALSE, ch, obj, last_to_hold, TO_CHAR);
	} else {		/* this is the real kicker */
	  act("$n gets far too close, and $N shoves $S wrecking-ball fist through $n's chest.",
	      FALSE, ch, 0, last_to_hold, TO_ROOM);
	  act("You have managed to get FAR TOO CLOSE to $N.", FALSE, ch, 0, last_to_hold, TO_CHAR);
	  
	  sprintf(Gbuf4, " %s", GET_NAME(ch));
	  
	  do_bash(last_to_hold, Gbuf4, cmd_bash, 0);	/* yes, they got
							   too close, so they pay */
	}
      } else {
	act("You amazingly evade $N and reach your goal!", FALSE, ch, 0, last_to_hold, TO_CHAR);
	act("$n throws $N for major loop, incredulously making $s way to $o.",
	    FALSE, ch, obj, last_to_hold, TO_ROOM);
d2574 6
a2579 3
    }
  }
  return retval;
d2585 3
@


1.56
log
@Renamed continual light spell to illumination, and it only works on
LIGHT items (still rooms too).
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.55 2006/11/18 00:03:31 jps Exp jps $
d822 4
a825 5
  bool afford = 1;/*assume they can afford it*/
  int amount = 0;
  int i;
  for (i = 0; i <=3;i++)
    {
d827 1
a827 1
    }
d829 1
a829 2
  if (amount <= 0) 
    {
d832 1
a832 1
    }
d834 10
a843 11
  if (GET_PLAT(ch) < cPtr[PLAT])
    afford = 0;
  if (GET_GOLD(ch) < cPtr[GOLD])
    afford = 0;
  if (GET_SILVER(ch) < cPtr[SILVER])
    afford = 0;
  if (GET_COPPER(ch) < cPtr[COPPER])
    afford = 0;
  
  if (!afford)
    {
d846 5
a850 18
    }
  else
    {
      strcpy(buf, "You give ");/*null buf string*/
      if (cPtr[PLAT])
	sprintf(buf, "%s&0&b&6%d &0platinum&0 ", buf, cPtr[PLAT]);	
      if (cPtr[GOLD])
	sprintf(buf, "%s&0&b&3%d &0gold&0 ", buf, cPtr[GOLD]);
      if (cPtr[SILVER])
	sprintf(buf, "%s%d silver ", buf, cPtr[SILVER]);
      if (cPtr[COPPER])
	sprintf(buf, "%s&0&3%d&0 copper ", buf, cPtr[COPPER]);
      if (amount > 1)
	strcat(buf, "coins to $n.");
      else
	strcat(buf, "coin to $n.");
      
      
d852 1
a852 1
	send_to_char(OK, ch);
d854 6
a859 16
	act(buf, FALSE, vict, 0, ch, TO_VICT);
      
      strcpy(buf, "$n gives you  ");/*null buf string*/
      if (cPtr[PLAT])
	sprintf(buf, "%s &0&b&6%d&0 platinum ", buf, cPtr[PLAT]);	
      if (cPtr[GOLD])
	sprintf(buf, "%s &0&b&3%d&0 gold ", buf, cPtr[GOLD]);
      if (cPtr[SILVER])
	sprintf(buf, "%s %d &0silver&0 ", buf, cPtr[SILVER]);
      if (cPtr[COPPER])
	sprintf(buf, "%s &0&3%d&0 copper ", buf, cPtr[COPPER]);
      if (amount > 1)
	strcat(buf, "coins");
      else
	strcat(buf, "coin");
      
d861 1
a861 1
      
d863 1
a863 1
      
d865 1
a865 1
      
d867 1
a867 1
	send_to_char("Ok.\r\n", ch);
d869 7
a875 8
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_PLAT(vict) += cPtr[PLAT];
	else
	  {
	    GET_PLAT(ch) -= cPtr[PLAT];
	    GET_PLAT(vict) += cPtr[PLAT];
	    bribe_mtrigger(vict, ch, cPtr[PLAT]);
	  }
d878 7
a884 8
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_GOLD(vict) += cPtr[GOLD];
	else
	  {
	    GET_GOLD(ch) -= cPtr[GOLD];
	    GET_GOLD(vict) += cPtr[GOLD];
	    bribe_mtrigger(vict, ch, cPtr[GOLD]);
	  } 	
d887 7
a893 8
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_SILVER(vict) += cPtr[SILVER];
	else
	  {
	    GET_SILVER(ch) -= cPtr[SILVER];
	    GET_SILVER(vict) += cPtr[SILVER];
	    bribe_mtrigger(vict, ch, cPtr[SILVER]);
	  }
d896 12
a907 8
	if (GET_LEVEL(ch)>=LVL_IMMORT)
	  GET_COPPER(vict) += cPtr[COPPER];
	else
	  {
	    GET_COPPER(ch) -= cPtr[COPPER];
	    GET_COPPER(vict) += cPtr[COPPER];
	    bribe_mtrigger(vict, ch, cPtr[COPPER]);
	  }
d909 1
a909 6
      if ((cPtr[PLAT]>49) || (cPtr[GOLD]>499))
	{
	  sprintf(buf, "%s gave %d Plat %d Gold to %s", GET_NAME(ch), cPtr[PLAT], cPtr[GOLD], GET_NAME(vict));
	  mudlog(buf, CMP, LVL_GOD, FALSE);
	}
    }	
d2585 4
@


1.55
log
@Fix continual light items to always work when they have the
bit set.  Rooms now print an indicator of being continually lit.
Can't use it to make a room permanently lit any more.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.54 2006/11/16 16:42:14 jps Exp jps $
a72 2
    if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT))
       world[ch->in_room].light--;    
a203 2
       if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT))
         world[ch->in_room].light++;
d2615 5
@


1.54
log
@Prevent fountains from being emptied.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.53 2006/11/14 19:00:43 jps Exp jps $
d73 1
a73 1
    if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
d206 2
a207 2
      if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
	world[ch->in_room].light++;
d2619 3
@


1.53
log
@Even if you are full, you can drink when you are a little thirsty.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.52 2006/11/12 20:22:32 jps Exp jps $
d1305 20
d1441 7
a1447 15
  /* Then how much to pour */
  GET_OBJ_VAL(from_obj, 1) -= (amount =
			       (GET_OBJ_VAL(to_obj, 0) - GET_OBJ_VAL(to_obj, 1)));
  
  GET_OBJ_VAL(to_obj, 1) = GET_OBJ_VAL(to_obj, 0);
  
  if (GET_OBJ_VAL(from_obj, 1) < 0) {	/* There was too little */
    GET_OBJ_VAL(to_obj, 1) += GET_OBJ_VAL(from_obj, 1);
    amount += GET_OBJ_VAL(from_obj, 1);
    GET_OBJ_VAL(from_obj, 1) = 0;
    GET_OBJ_VAL(from_obj, 2) = 0;
    GET_OBJ_VAL(from_obj, 3) = 0;
    name_from_drinkcon(from_obj);
  }
  /* Then the poison boogie */
d1450 1
a1450 3
  
  /* And the weight boogie */
  weight_change_object(from_obj, -amount);
d1453 11
d2619 3
@


1.52
log
@JUNKing an item will no longer invoke any drop triggers.
Attempting to drop a cursed item also won't invoke drop triggers.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.51 2006/11/08 10:12:28 jps Exp jps $
d1155 1
a1155 1
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 0)) {
d2598 4
@


1.51
log
@Fixed typo where you wore bracelets "on around" your wrist.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.50 2006/11/08 08:47:58 jps Exp jps $
d501 6
a506 6
  
  if (!drop_otrigger(obj, ch))
    return 0;
  if ((mode == SCMD_DROP) && !drop_wtrigger(obj, ch))
    return 0;
  
d512 11
d2598 3
@


1.50
log
@Fixed gender in message about dragging a living creature.
Added slightly humorous message for when you try to drag yourself.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.49 2006/11/08 07:57:08 jps Exp jps $
d1482 2
a1483 2
    {"$n puts $p on around $s right wrist.",
     "You put $p on around your right wrist."},
d1485 2
a1486 2
    {"$n puts $p on around $s left wrist.",
     "You put $p on around your left wrist."},
d2587 4
@


1.49
log
@Typo fix "stomach can't contain anymore" -> "any more"
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.48 2006/11/07 11:07:57 jps Exp jps $
d2306 7
a2312 2
    sprintf(buf, "&0Maybe you should kill $m first!&0");
    act(buf, FALSE, ch, 0, 0, TO_CHAR);
d2587 3
@


1.48
log
@Allow belt items to be worn normally, and fix belt message typos.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.47 2006/11/07 08:29:16 jps Exp $
d1145 1
a1145 1
    send_to_char("Your stomach can't contain anymore!\r\n", ch);
d2582 3
@


1.47
log
@Can't drink any more when not thirsty.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.46 2006/07/20 07:38:42 cjd Exp $
d1521 2
a1522 2
    {"$n attaches $p on $s belt.",
     "You attach $p on your belt."}
d1576 1
a1576 1
    "You can't attach anymore to your belt.\r\n"
d1769 1
d2582 3
@


1.46
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.45 2003/07/24 22:47:15 jjl Exp $
d1148 5
d2581 3
@


1.45
log
@Added the ability for mobs to give away cursed items.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.44 2003/07/06 20:00:30 jjl Exp $
d881 1
a881 1
      strcpy(buf, "$n gives some coins to $N");
d1571 1
a1571 1
    "You can't wear attach anymore to your belt.\r\n"
d2406 1
a2406 1
	    sprintf(buf, "&0$n &0charges at the %s and simple bounces off!&0", 
d2576 3
@


1.44
log
@Added some checking to avoid giving mobs items they can't use.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.43 2002/12/21 21:01:21 jjl Exp $
d750 4
d757 3
a759 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && GET_LEVEL(ch) < 100) {
d2576 3
@


1.43
log
@Refixed doorbash.  The hell was I thinking?
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.42 2002/09/15 04:01:18 jjl Exp $
d1577 5
a1581 2
    act("You're not a high enough level to use $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n struggles and fails to use $p.", TRUE, ch, obj, 0, TO_ROOM);
d2570 3
@


1.42
log
@Fixed Doorbash so that the door is OPEN WHEN you go through.  Also,
stuns you even if there is no return door.
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.41 2002/09/13 02:32:10 jjl Exp $
d2427 2
a2428 1
	      OPEN_DOORK(ch->in_room, rev_dir[dir]);
d2567 4
@


1.41
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.item.c,v 1.40 2002/02/07 00:15:03 dce Exp $
a2425 1
	    perform_move(ch, dir, 1);
d2429 1
d2431 2
d2435 2
d2566 3
@


1.40
log
@Modified the code so players could not 'wear gloves !' and
have the item put in the light wear position.
@
text
@d1 3
a3 1
// $Id: act.item.c,v 1.39 2001/12/18 02:29:41 dce Exp $
d2560 186
a2745 180
// $Log: act.item.c,v $
// Revision 1.39  2001/12/18 02:29:41  dce
// Gods can now drop and give cursed items away. This was
// done for the quest.
//
// Revision 1.38  2001/12/07 15:42:30  dce
// Fixed a bug with object spell effects where if a player
// was wearing an item and died, they would permanently
// gain that ability.
//
// Revision 1.37  2001/04/23 03:31:37  dce
// Players will not be able to pick up an object that is
// a higher level than they are. Also players will not
// be able to give a low level character a high level item
// in a bag. I also fixed cursed items by not allowing them
// to be placed into a container.
//
// Revision 1.36  2001/04/08 13:25:12  dce
// Prevented perform_give from give a high level boat to
// a low level character.
//
// Revision 1.35  2001/04/07 14:10:18  dce
// Can't get a boat that is a higher level than you.
//
// Revision 1.34  2001/03/31 21:22:01  dce
// Fixed the doorbash bug when an exit doesn't exist.
//
// Revision 1.33  2001/03/24 15:10:26  dce
// Players can not wear equipment until they are the proper
// level based on the object.
//
// Revision 1.32  2001/01/16 19:25:37  rsd
// Added a null check to doorbash to prevent crashing on
// doorbash of invalid door. RE-tabbed section of doorbash
// code
// ..
//
// Revision 1.31  2000/11/28 00:44:00  mtp
// removed mobprog references
//
// Revision 1.30  2000/11/25 08:09:43  rsd
// Added corpse dragging debug to do_drag to track when player
// corpses are drug from one room to another.  Also added debug
// to perform_get_from_container() or something like that to
// log each object looted from a player corpse to prevent
// players from claiming that their eq just 'disappeared'.
// Also retabbed and braced {} sections of the associated code
// in an attempt to make it readable.
//
// Revision 1.29  2000/11/20 03:34:31  rsd
// added some missing and back rlog messages from prior
// to the addition of the $log$ string.
//
// Revision 1.28  2000/11/10 23:32:26  mtp
// fixed the wear/wield weirdness including weight check for weapons
//
// Revision 1.27  2000/11/10 00:04:25  mtp
// fixed the wear all allowing 2 handers + 2 weapons
//
// Revision 1.26  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.25  2000/09/04 19:41:01  rsd
// Retabbed doorbash and added a skill ckeck early in the function.
//
// Revision 1.24  2000/04/22 22:24:46  rsd
// No more animals wearing eq and wielding weapons
//
// Revision 1.23  2000/04/05 22:55:57  rsd
// more cmc enhancements to do give...
//
// Revision 1.22  2000/04/05 22:31:12  rsd
// More cmc tweaks on do give :)
//
// Revision 1.21  2000/04/05 21:53:33  rsd
// CMC altered perform_give() to include the summation of many
// items given to someone. Also altered do_give() to reflect
// the implementation of these changes.
//
// Revision 1.20  2000/04/05 20:49:32  rsd
// Chris added a fix to do_get to prevent a huge loop of
// trying to give non-existant objects to someone, Ie give
// 48000 cpper person.
//
// Revision 1.19  2000/04/05 06:30:44  rsd
// changed the comment header to make it a fiery file
//
// Revision 1.18  1999/12/02 23:17:10  rsd
// removed mode == SCMD_JUNK from #define VANISH(mode)
// in order to drop the silly vanishes message from junking
//
// Revision 1.17  1999/11/23 15:48:23  jimmy
// Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
// Reinstated dual wield.
// Allowed mobs/players to pick up items while fighting.
// Fixed a bug in the damage message that wrongfully indicated a miss
// due to a rounding error in the math.
// This was all done in order to facilitate the chance to sling your
// weapon in combat.  Dex and proficiency checks are now made on any missed
// attact and a failure of both causes the weapon to be slung.
//
// Revision 1.16  1999/09/10 01:07:05  mtp
// also message if can-t 't dual wield (no skill)
//
// Revision 1.15  1999/09/10 01:04:25  mtp
// message if trying to wield when already wielding 2 weapons
//
// Revision 1.14  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.13  1999/09/03 22:57:43  mtp
// added some IS_FIGHTING checks
//
// Revision 1.12  1999/08/13 21:33:19  dce
// Wear all and rent now does weapons.
//
// Revision 1.11  1999/08/07 23:49:16  mud
// Added the function corpse_consent to assist in checking
// for player consent to messing with their corpses. Added the
// functionality to looting (do_get) and dragging corpses.
//
// Revision 1.10  1999/06/30 18:25:04  jimmy
// >> This is a major conversion from the 18 point attribute system to the
// >> 100 point attribute system.  A few of the major changes are:
// >> All attributes are now on a scale from 0-100
// >> Everyone views attribs the same but, the attribs for one race
// >>   may be differeent for that of another even if they are the
// >>   same number.
// >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
// >> Mobs now have individual random attributes based on race/class.
// >> The STR_ADD attrib has been completely removed.
// >> All bonus tables for attribs in constants.c have been replaced by
// >>   algorithims that closely duplicate the tables except on a 100 scale.
// >> Some minor changes:
// >> Race selection at char creation can now be toggled by using
// >>   <world races off>
// >> Lots of cleanup done to affected areas of code.
// >> Setting attributes for mobs in the .mob file no longer functions 
// >>   but is still in the code for later use.
// >> We now have a spare attribut structure in the pfile because the new
// >>   system only used three instead of four.
// >> --gurlaek 6/30/1999
//
// Revision 1.9  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.8  1999/05/02 16:50:16  dce
// You can now get one coin.
//
// Revision 1.7  1999/04/09 03:38:36  dce
// Junk command is back!
//
// Revision 1.6  1999/03/12 18:05:43  dce
// Players can no longer hold lights in the light position
//
// Revision 1.5  1999/02/20 18:41:36  dce
// Adds improve_skill calls so that players can imprve their skills.
//
// Revision 1.4  1999/02/12 16:25:09  jimmy
// Fixed poofs to show a default poof if none is set.
//
// Revision 1.3  1999/02/10 02:38:58  dce
// Fixes some of continual light.
//
// Revision 1.2  1999/02/06 04:09:01  dce
// David Endre 2/5/99
// Adds do_light, to allow lights to be turned on while in
// someones inventory.
//
// Revision 1.1  1999/01/29 01:23:29  mud
// Initial Revision
//
@


1.39
log
@Gods can now drop and give cursed items away. This was
done for the quest.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.38 2001/12/07 15:42:30 dce Exp $
d1757 3
a1759 1
    if ((where = search_block(arg, keywords, FALSE)) < 0) {
d2559 4
@


1.38
log
@Fixed a bug with object spell effects where if a player
was wearing an item and died, they would permanently
gain that ability.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.37 2001/04/23 03:31:37 dce Exp $
d505 1
a505 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d751 1
a751 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d2557 5
@


1.37
log
@Players will not be able to pick up an object that is
a higher level than they are. Also players will not
be able to give a low level character a high level item
in a bag. I also fixed cursed items by not allowing them
to be placed into a container.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.36 2001/04/08 13:25:12 dce Exp $
d1631 12
a1642 1
  /* SPELL AFFECTS FROM OBJECTS -revised by nechtrous */
d1646 1
a1646 1
  
d2027 11
a2037 1
    
d2040 1
a2040 1
    AFF3_FLAGS(ch) = (GET_OBJ_SPELL3(obj) ^ AFF3_FLAGS(ch));
d2557 7
@


1.36
log
@Prevented perform_give from give a high level boat to
a low level character.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.35 2001/04/07 14:10:18 dce Exp $
d58 1
a58 1
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
d60 6
a65 1
  else if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1)
d67 2
a68 1
  else {
d164 3
d723 25
d763 1
a763 1
  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(vict) && GET_OBJ_TYPE(obj) == ITEM_BOAT) {
d769 4
a772 1
  
d2536 4
@


1.35
log
@Can't get a boat that is a higher level than you.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.34 2001/03/31 21:22:01 dce Exp $
d729 4
d2499 3
@


1.34
log
@Fixed the doorbash bug when an exit doesn't exist.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.33 2001/03/24 15:10:26 dce Exp $
d158 3
d2495 3
@


1.33
log
@Players can not wear equipment until they are the proper
level based on the object.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.32 2001/01/16 19:25:37 rsd Exp $
a2301 6
  if(EXIT(ch, dir)->keyword == NULL) {
    sprintf(buf, "SYSERR:act.item.c:do_doorbash():A one sided door in room %d", world[ch->in_room].number);
    log(buf);
    send_to_char("&0This exit seems broken, tell a god.&0\r\n", ch);
    return;
  }
d2312 6
d2492 4
@


1.32
log
@Added a null check to doorbash to prevent crashing on
doorbash of invalid door. RE-tabbed section of doorbash
code
..
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.31 2000/11/28 00:44:00 mtp Exp $
d1528 7
d2492 6
@


1.31
log
@removed mobprog references
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.30 2000/11/25 08:09:43 rsd Exp mtp $
d2294 7
a2300 1
  
d2312 70
a2381 70
 if (EXIT(ch, dir)) {
   if (!IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF)) {
     if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) || 
	 (IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))) {
       if (temp < 80) {
/*  	 improve_skill(ch, SKILL_DOORBASH); */
	 sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n", 
		 fname(EXIT(ch, dir)->keyword));
	 send_to_char(buf, ch);
	 sprintf(buf, "&0$n &0charges at the %s and simple bounces off!&0", 
		 fname(EXIT(ch, dir)->keyword));
	 act(buf, FALSE, ch, 0, 0, TO_ROOM);
	 
	 WAIT_STATE(ch, PULSE_VIOLENCE*3);
	 if(GET_LEVEL(ch) < LVL_IMMORT) {
	   if ((GET_HIT(ch) - (((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch))) > -5) {
	     GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
	     update_pos(ch);
	   } else {
	     GET_HIT(ch) = -5;
	     update_pos(ch);
	   }
	   return;
	 }
       }

       if (temp > 79) {
/*  	 improve_skill(ch, SKILL_DOORBASH); */
	 OPEN_DOORK(ch->in_room, dir);
	 
	 sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
	 act(buf, FALSE, ch, 0, 0, TO_ROOM);
	 sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n", 
		 fname(EXIT(ch, dir)->keyword));
	 send_to_char(buf, ch);
	 sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
	 act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);
	 
	 perform_move(ch, dir, 1);
	 if (EXIT(ch, rev_dir[dir])) {
	   OPEN_DOORK(ch->in_room, rev_dir[dir]);
	   WAIT_STATE(ch, PULSE_VIOLENCE);
	 } else {
	   return;
	 }
       }
       return;
     }
   } else {
/*       improve_skill(ch, SKILL_DOORBASH); */
     
     sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n", 
	     fname(EXIT(ch, dir)->keyword));
     send_to_char(buf, ch);
     sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0", 
	     fname(EXIT(ch, dir)->keyword));		
     act(buf, FALSE, ch, 0, 0, TO_ROOM);
     
     WAIT_STATE(ch, PULSE_VIOLENCE*3);
     if(GET_LEVEL(ch) < LVL_IMMORT) {
       if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5) {
	 GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
	 update_pos(ch);
       } else {
	 GET_HIT(ch) = -5;
	 update_pos(ch);}	
     } 
     return;
   }
 }
d2485 3
@


1.30
log
@Added corpse dragging debug to do_drag to track when player
corpses are drug from one room to another.  Also added debug
to perform_get_from_container() or something like that to
log each object looted from a player corpse to prevent
players from claiming that their eq just 'disappeared'.
Also retabbed and braced {} sections of the associated code
in an attempt to make it readable.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.29 2000/11/20 03:34:31 rsd Exp $
a48 2
void mprog_give_trigger(struct char_data * mob, struct char_data * ch, struct obj_data * obj);
void mprog_bribe_trigger(struct char_data * mob, struct char_data * ch, int amount);
a732 1
    MOBTrigger = FALSE;
a733 1
    MOBTrigger = FALSE;
a734 1
    MOBTrigger = FALSE;
a737 1
  mprog_give_trigger(vict, ch, obj);
a811 1
      mprog_bribe_trigger(vict, ch, cPtr[GOLD]);
a826 1
      MOBTrigger = FALSE;
a830 1
      MOBTrigger = FALSE;
a989 1
    MOBTrigger = FALSE;
a990 1
    MOBTrigger = FALSE;
a991 1
    MOBTrigger = FALSE;
a993 1
    MOBTrigger = FALSE;
a995 1
    MOBTrigger = FALSE;
a997 1
    MOBTrigger = FALSE;
d2479 9
@


1.29
log
@added some missing and back rlog messages from prior
to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.28 2000/11/10 23:32:26 mtp Exp $
a16 1

a36 2


d195 1
a195 1
         world[ch->in_room].light++;
d201 8
d222 1
a222 1
  if (IS_SET(GET_OBJ_VAL(cont, 1), CONT_CLOSED))
d224 1
a224 1
  else if (obj_dotmode == FIND_INDIV) {
d228 1
a228 1
    } else
d230 1
d245 1
a245 1
      if (obj_dotmode == FIND_ALL)
d247 1
a247 1
      else {
a310 1

d344 1
a344 1
	if( !IS_PLR_CORPSE(cont) ) {
d2105 1
a2105 1
  int door = 0, k;
d2177 1
a2177 1
	if( IS_PLR_CORPSE(tobj) ) {
d2179 3
a2202 3



d2208 1
d2213 9
d2494 4
@


1.28
log
@fixed the wear/wield weirdness including weight check for weapons
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.26 2000/11/03 17:28:33 jimmy Exp mtp $
a2477 3



d2479 3
d2502 10
d2537 68
@


1.27
log
@fixed the wear all allowing 2 handers + 2 weapons
@
text
@d1571 6
a1576 1
    if (a >= 2) {
d1744 5
d1766 8
a1773 1
	  perform_wear(ch, obj, where);
d1784 6
d1791 1
d2482 3
@


1.26
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.25 2000/09/04 19:41:01 rsd Exp $
d1554 1
a1554 1
  if (where == 11 || ((where >= 16) && (where <= 19)))  {
d2458 5
@


1.25
log
@Retabbed doorbash and added a skill ckeck early in the function.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.24 2000/04/22 22:24:46 rsd Exp $
d2359 3
d2363 5
a2367 1
  if (strlen(POOFOUT(ch)) > 0)
d2369 1
a2369 1
  else
d2371 1
d2373 1
d2375 3
a2377 2
  char_to_room(ch, real_room(GET_LOADROOM(ch)));
  if (strlen(POOFIN(ch)) > 0)
d2379 1
a2379 1
  else
d2381 1
d2458 3
@


1.24
log
@No more animals wearing eq and wielding weapons
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.23 2000/04/05 22:55:57 rsd Exp $
d2204 1
a2204 1
#define EXITK(room, dir)		(world[room].dir_option[dir])
d2210 1
d2214 9
a2222 3
  if (GET_LEVEL(ch) >= LVL_IMMORT){
    temp = 101;}
  if (!*arg&&((GET_SKILL(ch, SKILL_DOORBASH))||(GET_LEVEL(ch)>=LVL_IMMORT))){
d2224 11
a2234 14
    return;}
  if (GET_LEVEL(ch)<LVL_IMMORT)
    {
      if (IS_FIGHTING(ch)) {
        send_to_char("You can't take time out to do that just yet!\n\r",ch);
        return ;
      }
      
      race = GET_RACE(ch);
      if((race != RACE_TROLL) && (race != RACE_OGRE) && (race!= RACE_BARBARIAN))
	{
	  send_to_char("&0You do not feel massive enough!&0\r\n", ch);
	  return;
	}
d2236 1
d2264 9
a2272 6
default:
  send_to_char("Doorbash where?\r\n", ch);
  return;
  break;		 }}
  if ((GET_SKILL(ch, SKILL_DOORBASH)||(GET_LEVEL(ch)>=LVL_IMMORT))){
    if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE){
d2274 2
a2275 1
      return;}
d2279 2
a2280 1
      return;}
d2282 70
a2351 56
    if (EXIT(ch, dir)) {
      if (!IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF)){
	if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED))||(IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))){
	  if (temp < 80){
        improve_skill(ch, SKILL_DOORBASH);
	    {sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n", fname(EXIT(ch, dir)->keyword));
	    send_to_char(buf, ch);}
	    {sprintf(buf, "&0$n &0charges at the %s and simple bounces off!&0", fname(EXIT(ch, dir)->keyword));		
	    act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	    WAIT_STATE(ch, PULSE_VIOLENCE*3);
	    if(GET_LEVEL(ch) < LVL_IMMORT){
	      if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5){
		GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
		update_pos(ch);}
	      else {
		GET_HIT(ch) = -5;
		update_pos(ch);}
	      return;}}
	  
	  
	  if (temp >79){
        improve_skill(ch, SKILL_DOORBASH);
	    OPEN_DOORK(ch->in_room, dir);
	    {	
	      sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
	      act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	    {
	      sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n", fname(EXIT(ch, dir)->keyword));
	      send_to_char(buf, ch);}
	    {	  sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
	    act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);}
	    perform_move(ch, dir, 1);
	    if (EXIT(ch, rev_dir[dir])) {
	      OPEN_DOORK(ch->in_room, rev_dir[dir]);
	      WAIT_STATE(ch, PULSE_VIOLENCE);}
	    else{
	      return;}}
	  return;}}
      else{
        improve_skill(ch, SKILL_DOORBASH);
	{sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n", fname(EXIT(ch, dir)->keyword));
	send_to_char(buf, ch);}
	{sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0", fname(EXIT(ch, dir)->keyword));		
	act(buf, FALSE, ch, 0, 0, TO_ROOM);}
	WAIT_STATE(ch, PULSE_VIOLENCE*3);
	if(GET_LEVEL(ch) < LVL_IMMORT){
	  if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5){
	    GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));	
	    update_pos(ch);}
	  else {
	    GET_HIT(ch) = -5;
	    update_pos(ch);}	
	} 
	return;
      }
    }
d2447 3
@


1.23
log
@more cmc enhancements to do give...
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.22 2000/04/05 22:31:12 rsd Exp $
d1717 6
d1782 6
d2423 3
@


1.22
log
@More cmc tweaks on do give :)
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.19 2000/04/05 06:30:44 rsd Exp $
d975 10
a984 1
	    if (perform_give(ch, vict, obj, 0) == GIVE_FAIL_FULL) {
d2411 3
@


1.21
log
@CMC altered perform_give() to include the summation of many
items given to someone. Also altered do_give() to reflect
the implementation of these changes.
@
text
@d30 1
d709 1
a709 1
		  struct obj_data * obj)
d717 1
a717 1
    return GIVE_FAIL;
d728 10
d890 1
a890 1
  int amount=1, dotmode;
d952 1
a952 1
	i=amount + 1; /* Prevents give 48000 burps does not exist crashes! CMC 4/5/00 */ 
d956 2
a957 1
	if (perform_give(ch, vict, obj) == GIVE_SUCCESS) {
d959 2
d971 1
d975 2
a976 3
	    if (perform_give(ch, vict, obj) == GIVE_SUCCESS) {
	      ref_obj=obj;
	      counter=1;
@


1.20
log
@Chris added a fix to do_get to prevent a huge loop of
trying to give non-existant objects to someone, Ie give
48000 cpper person.
@
text
@d26 5
d707 1
a707 1
void perform_give(struct char_data * ch, struct char_data * vict,
d712 1
a712 1
    return;
d716 1
a716 1
    return;
d720 1
a720 1
    return;
d723 1
a723 1
    return;
a726 6
  MOBTrigger = FALSE;
  act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
  MOBTrigger = FALSE;
  act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
  MOBTrigger = FALSE;
  act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
d728 1
d882 1
a882 1
  struct obj_data *obj, *next_obj;
d884 1
a884 1
  int i;
d886 2
d939 1
a939 1
	sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
d942 7
a948 2
      } else
	perform_give(ch, vict, obj);
d954 1
a954 1
      if (!ch->carrying)
d956 1
a956 1
      else
d959 6
a964 2
	  if (CAN_SEE_OBJ(ch, obj) && ((dotmode == FIND_ALL || isname(arg, obj->name))))
	    perform_give(ch, vict, obj);
d966 1
d969 19
@


1.19
log
@changed the comment header to make it a fiery file
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.18 1999/12/02 23:17:10 rsd Exp $
d889 4
a892 5
  if (!*arg)
    {
      send_to_char("Give what to who?\r\n", ch);
      return;
    }
d897 17
a913 20
  if (is_number(arg)) 
    {
      amount = atoi(arg);
      while (is_number(arg))
	{
	  argument = one_argument(argument, arg);
	  if (!str_cmp("platinum", arg) || !str_cmp("p", arg)) 
	    cash[PLAT] = amount;
	  else if (!str_cmp("gold", arg) || !str_cmp("g", arg)) 
	    cash[GOLD] = amount;
	  else if (!str_cmp("silver", arg) || !str_cmp("s", arg)) 
	    cash[SILVER] = amount;
	  else if (!str_cmp("copper", arg) || !str_cmp("c", arg)) 
	    cash[COPPER] = amount;
	  else
	    {
	      coins = 0;
	      break;
	    }
	  argument = one_argument(argument, arg);
d915 9
a923 18
	}
      if (coins)
	{
	  /*coin handling*/
	  if (!(vict = give_find_vict(ch, arg)))
	    {
	      /*No victem found*/
	      return;
	    }
	  cPtr = &cash[0];
	  perform_give_gold(ch, vict, cPtr);
	  return;
	}
    }/*Note no coin handling past this point*/
  one_argument(argument, buf1);
  if (!(vict = give_find_vict(ch, buf1)))
    {
      /*No victem found*/
d926 6
d933 20
a952 10
  for (i=1;i <= amount;i++)
    {
      if (dotmode == FIND_INDIV) 
	{
	  if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)))	
	    {
	      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	      send_to_char(buf, ch);
	    } 
	  else
a953 17
	} 
      else 
	{
	  if (dotmode == FIND_ALLDOT && !*arg) 
	    {
	      send_to_char("All of what?\r\n", ch);
	      return;
	    }
	  if (!ch->carrying)
	    send_to_char("You don't seem to be holding anything.\r\n", ch);
	  else
	    for (obj = ch->carrying; obj; obj = next_obj) 
	      {
		next_obj = obj->next_content;
		if (CAN_SEE_OBJ(ch, obj) && ((dotmode == FIND_ALL || isname(arg, obj->name))))
		  perform_give(ch, vict, obj);
	      }
d956 1
d2357 3
@


1.18
log
@removed mode == SCMD_JUNK from #define VANISH(mode)
in order to drop the silly vanishes message from junking
@
text
@d1 3
a3 3
// $Id: act.item.c,v 1.17 1999/11/23 15:48:23 jimmy Exp $
/* ************************************************************************
 *   File: act.item.c                                    Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
d2370 4
@


1.17
log
@Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
Reinstated dual wield.
Allowed mobs/players to pick up items while fighting.
Fixed a bug in the damage message that wrongfully indicated a miss
due to a rounding error in the math.
This was all done in order to facilitate the chance to sling your
weapon in combat.  Dex and proficiency checks are now made on any missed
attact and a failure of both causes the weapon to be slung.
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.16 1999/09/10 01:07:05 mtp Exp $
d469 1
a469 1
#define VANISH(mode) ((mode == SCMD_DONATE || mode == SCMD_JUNK) ? \
d2368 10
@


1.16
log
@also message if can-t 't dual wield (no skill)
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.15 1999/09/10 01:04:25 mtp Exp mtp $
d304 6
a309 5

  if (IS_FIGHTING(ch)) {
    send_to_char("You are too busy fighting to do that!\n\r",ch);
    return;
  }
d2368 3
@


1.15
log
@message if trying to wield when already wielding 2 weapons
@
text
@d1 1
a1 1
// $Id: act.item.c,v 1.14 1999/09/05 07:00:39 jimmy Exp mtp $
d1788 2
d2367 3
@


1.14
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d1781 3
d2364 4
a2367 1
// $Log$
@


1.13
log
@added some IS_FIGHTING checks
@
text
@d1 1
d2361 1
@


1.12
log
@Wear all and rent now does weapons.
@
text
@d304 4
d1210 4
d2025 5
d2158 4
@


1.11
log
@Added the function corpse_consent to assist in checking
for player consent to messing with their corpses. Added the
functionality to looting (do_get) and dragging corpses.
@
text
@d1519 1
a1519 1
      send_to_char("I don't think so, what?? you plan to use your feet to hold that!!", ch);
d1643 3
@


1.10
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@d47 1
d297 1
a297 2
ACMD(do_get)
{
a299 1
  
d303 1
a303 1
  
d312 36
a347 12
  else 
    {
      cont_dotmode = find_all_dots(arg2);
      if (cont_dotmode == FIND_INDIV) 
	{
	  mode = generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
	  if (!cont) 
	    {
	      sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
	      send_to_char(buf, ch);
	    } 
	  else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
d349 15
a363 45
	  else
	    get_from_container(ch, cont, arg1, mode);
	} 
      else 
	{
	  if (cont_dotmode == FIND_ALLDOT && !*arg2) 
	    {
	      send_to_char("Get from all of what?\r\n", ch);
	      return;
	    }
	  for (cont = ch->carrying; cont; cont = cont->next_content)
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	      if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) 
		{
		  found = 1;
		  get_from_container(ch, cont, arg1, FIND_OBJ_INV);
		} 
	      else if (cont_dotmode == FIND_ALLDOT) 
		{
		  found = 1;
		  act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
		}
	    }
	  for (cont = world[ch->in_room].contents; cont; cont = cont->next_content)
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	      if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) 
		{
		  get_from_container(ch, cont, arg1, FIND_OBJ_ROOM);
		  found = 1;
		}
	      else if (cont_dotmode == FIND_ALLDOT) 
		{
		  act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
		  found = 1;
		}
	    }
	  if (!found) 
	    {
	      if (cont_dotmode == FIND_ALL)
		send_to_char("You can't seem to find any containers.\r\n", ch);
	      else 
		{
		  sprintf(buf, "You can't seem to find any %ss here.\r\n", arg2);
		  send_to_char(buf, ch);
		}
d365 12
d378 2
d381 1
d385 36
d1999 1
d2058 5
a2062 4
  if (k == FIND_OBJ_ROOM){
  if (GET_OBJ_TYPE(tobj) == ITEM_PORTAL){
  send_to_char("You cant drag that!\r\n", ch);
   return; }
d2064 13
a2076 5
      if (GET_OBJ_WEIGHT(tobj) > (CAN_CARRY_W(ch)*3)){
	send_to_char("&0It is too heavy for you to drag!&0", ch);}
      else {
	if(GET_LEVEL(ch)<LVL_GOD){
	  if      (GET_OBJ_WEIGHT(tobj)>50){
d2078 1
a2078 2
	      send_to_char("&0You are too exhausted!&0\r\n", ch);
	      
d2080 2
d2083 2
a2084 7
	    else {
	      {
		GET_MOVE(ch) = GET_MOVE(ch)-((GET_OBJ_WEIGHT(tobj)/50)+(movement_loss[SECT(ch->in_room)]));
	      }
	    }
	  }else{
	    if(GET_MOVE(ch)-(4) < 0){
d2087 1
a2087 2
	    }
	    else { 
d2092 30
a2121 21
	{obj_from_room(tobj);}
	{sprintf(buf, "&0You drag %s &0behind you.\r\n", tobj->short_description);{
	  send_to_char(buf, ch);
	}
	}
	{sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);{
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}}
	{  perform_move(ch, door, 1);}
	{obj_to_room(tobj, ch->in_room);}
	{sprintf(buf, "&0$n &0drags %s &0behind $m.&0", tobj->short_description);{
	  act(buf, FALSE, ch, 0, 0, TO_ROOM);}}}
      return;
    }
    else     { send_to_char("&0You can't go that way!&0\r\n", ch);}
    return;}
  if (k == FIND_CHAR_ROOM){
    sprintf(buf, "&0Maybe you should kill $m first!&0");{
      act(buf, FALSE, ch, 0, 0, TO_CHAR);}return;}
  else{
    send_to_char("&0You can't drag that!&0\r\n", ch);}
  return;}
@


1.9
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1687 1
a1687 1
    else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_APPLY_INDEX(ch)].wield_w)
d1721 1
a1721 1
		else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_APPLY_INDEX(ch)].wield_w)
@


1.8
log
@You can now get one coin.
@
text
@d337 1
a337 1
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
d348 1
d350 1
a350 1
	    if (CAN_SEE_OBJ(ch, cont) && (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
d361 1
d776 1
a776 1
      if (cPtr[PLAT])
d785 2
a786 1
      if (cPtr[GOLD])
d795 2
a796 2
      
      if (cPtr[SILVER])
d805 2
a806 1
      if (cPtr[COPPER])
d815 1
a815 1
      
@


1.7
log
@Junk command is back!
@
text
@d162 1
a162 1
    if (GET_OBJ_VAL(obj, 0)+GET_OBJ_VAL(obj, 1)+GET_OBJ_VAL(obj, 2)+GET_OBJ_VAL(obj, 3) == 1){
@


1.6
log
@Players can no longer hold lights in the light position
@
text
@d640 1
@


1.5
log
@Adds improve_skill calls so that players can imprve their skills.
@
text
@d1746 1
a1746 1
          if (GET_OBJ_VAL(obj, 2) > 0) {
d1763 1
a1763 1
          if (GET_OBJ_VAL(obj, 2) > 0) {
d1780 7
d1796 1
a1796 1
      perform_wear(ch, obj, WEAR_LIGHT);
@


1.4
log
@Fixed poofs to show a default poof if none is set.
@
text
@d42 1
d2124 1
d2141 1
d2159 1
@


1.3
log
@Fixes some of continual light.
@
text
@d2180 1
a2180 1
  if (POOFOUT(ch))
d2187 1
a2187 1
  if (POOFIN(ch))
@


1.2
log
@David Endre 2/5/99
Adds do_light, to allow lights to be turned on while in
someones inventory.
@
text
@d57 2
a60 2
    obj_from_char(obj);
    obj_to_obj(obj, cont);
@


1.1
log
@Initial revision
@
text
@d54 2
d57 2
d186 2
d1725 46
@
