head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.11.21.04.01;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.10.20.30.03;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.07.04.12.25;	author jps;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.18.56.43;	author rsd;	state Exp;
branches;
next	1.4;

1.4
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.06.19.33;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/*
 * File: hedit.c
 * Comment: OLC for MUDs -- this one edits help files
 * By Steve Wolfe
 * for use with OasisOLC
 */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "interpreter.h"
#include "handler.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"
#include "screen.h"

extern int top_of_helpt;
extern struct help_index_element *help_table;
int find_help(char *keyword);

void free_help(struct help_index_element *help);

/* function protos */
void hedit_disp_menu(struct descriptor_data *d);
void hedit_parse(struct descriptor_data *d, char *arg);
void hedit_setup_new(struct descriptor_data *d);
void hedit_setup_existing(struct descriptor_data *d, int real_num);
void hedit_save_to_disk(struct descriptor_data *d);
void hedit_save_internally(struct descriptor_data *d);
void index_boot(int mode);

/*
 * Utils and exported functions.
 */

void hedit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_HELP(d), struct help_index_element, 1);
  OLC_HELP(d)->keyword = str_dup(OLC_STORAGE(d));
  OLC_HELP(d)->entry = str_dup("This help file is unfinished.\r\n");
  OLC_HELP(d)->min_level = 0;
  OLC_HELP(d)->duplicate = 0;
  hedit_disp_menu(d);
  OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void hedit_setup_existing(struct descriptor_data *d, int real_num)
{
  CREATE(OLC_HELP(d), struct help_index_element, 1);
  OLC_HELP(d)->keyword = str_dup(help_table[real_num].keyword);
  OLC_HELP(d)->entry = str_dup(help_table[real_num].entry);
  OLC_HELP(d)->min_level = help_table[real_num].min_level;
  OLC_HELP(d)->duplicate = help_table[real_num].duplicate;
  OLC_VAL(d) = 0;
  hedit_disp_menu(d);
}


void hedit_save_internally(struct descriptor_data *d)
{
  struct help_index_element *new_help_table = NULL;
  int i;
  char *temp = NULL;

  /* add a new help element into the list */
  if (OLC_ZNUM(d) > top_of_helpt) {
    CREATE(new_help_table, struct help_index_element, top_of_helpt + 2);
    for (i = 0; i <= top_of_helpt; i++)
      new_help_table[i] = help_table[i];
    new_help_table[++top_of_helpt] = *OLC_HELP(d);
    free(help_table);
    help_table = new_help_table;
  } else {
 /* This was the original end of hedit_save_internally,
 * however, this would cause crashing in multiple keyword
 * entries.  The fix was posted by Chris Jacobson
 * <fear@@ATHENET.NET> on the CircleMUD Mailing List
 *
 *  i = find_help(OLC_HELP(d)->keyword);
 *
 *  free_help(help_table + OLC_ZNUM(d));
 *  help_table[OLC_ZNUM(d)] = *OLC_HELP(d);
 *
 * Begin the fix
 */
  temp = help_table[OLC_ZNUM(d)].entry;
  for (i = 0; i < top_of_helpt; i++) {
    if (help_table[i].entry == temp) {
/*    if (!help_table[i].duplicate)   FREE(help_table[i].entry);
 * The line above had to be commented because freeing based
 * upon a duplicate is not only unnecessary--it's dangerous.
 */
      help_table[i].entry = OLC_HELP(d)->entry;
      help_table[i].min_level = OLC_HELP(d)->min_level;
    }
  }
  free(temp);
  }
  olc_add_to_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}


/*------------------------------------------------------------------------*/

void hedit_save_to_disk(struct descriptor_data *d)
{
  FILE *fp;
  int i;

  if (!(fp = fopen(HELP_FILE, "w+"))) {
    sprintf(buf, "Can't open help file '%s'", HELP_FILE);
    perror(buf);
    exit(1);
  }
  for (i = 0; i <= top_of_helpt; i++) {
    if (help_table[i].duplicate > 0)
      continue;

    /*. Remove the '\r\n' sequences from entry . */
    strcpy(buf1, help_table[i].entry ? help_table[i].entry : "Empty");
    strip_string(buf1);

    sprintf(buf, "%s#%d\n",
	    buf1,
	    help_table[i].min_level);
    fputs(buf, fp);
  }

  fprintf(fp, "$\n");
  fclose(fp);
  olc_remove_from_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}

/*------------------------------------------------------------------------*/

/* Menu functions */

/* the main menu */
void hedit_disp_menu(struct descriptor_data *d)
{
  struct help_index_element *help;
  char *nrm = CCNRM(d->character, C_NRM);
  char *yel = CCYEL(d->character, C_NRM);
  char *grn = CCGRN(d->character, C_NRM);

  help = OLC_HELP(d);

  sprintf(buf,
	  ".[H.[J"
	  "Keywords    : %s%s\r\n"
	  "%s1%s) Entry       :\r\n%s%s"
	  "%s2%s) Min Level   : %s%d\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  yel, help->keyword,
	  grn, nrm, yel, help->entry,
	  grn, nrm, yel, help->min_level,
	  grn, nrm
      );
  send_to_char(buf, d->character);

  OLC_MODE(d) = HEDIT_MAIN_MENU;
}

/*
 * The main loop
 */

void hedit_parse(struct descriptor_data *d, char *arg)
{
  int i;

  switch (OLC_MODE(d)) {
  case HEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_save_internally(d);
      hedit_save_to_disk(d);
      if (help_table) {
	for (i = 0; i <= top_of_helpt; i++) {
	  if (help_table[i].keyword)
	    free(help_table[i].keyword);
	  if (help_table[i].entry && !help_table[i].duplicate)
	    free(help_table[i].entry);
	}
	free(help_table);
      }
      top_of_helpt = 0;
      index_boot(DB_BOOT_HLP);


      sprintf(buf, "OLC: %s edits help.", GET_NAME(d->character));
      mudlog(buf, CMP, LVL_IMPL, TRUE);
      /* do not free the strings.. just the structure */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Help saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /* free everything up, including strings etc */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this help internally? ", d->character);
      break;
    }
    return;			/* end of HEDIT_CONFIRM_SAVESTRING */

  case HEDIT_CONFIRM_EDIT:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_setup_existing(d, OLC_ZNUM(d));
      break;
    case 'q':
    case 'Q':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    case 'n':
    case 'N':
      OLC_ZNUM(d)++;
      for (; (OLC_ZNUM(d) <= top_of_helpt); OLC_ZNUM(d)++)
	if (is_abbrev(OLC_STORAGE(d), help_table[OLC_ZNUM(d)].keyword))
	  break;
      if (OLC_ZNUM(d) > top_of_helpt) {
	if (find_help(OLC_STORAGE(d)) > NOTHING) {
	  cleanup_olc(d, CLEANUP_ALL);
	  break;
	}
	sprintf(buf, "Do you wish to add help on '%s'? ",
		OLC_STORAGE(d));
	send_to_char(buf, d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_ADD;
      } else {
	sprintf(buf, "Do you wish to edit help on '%s'? ", help_table[OLC_ZNUM(d)].keyword);
	send_to_char(buf, d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_EDIT;
      }
      break;
    default:
      sprintf(buf, "Invalid choice!\r\nDo you wish to edit help on '%s'? ", help_table[OLC_ZNUM(d)].keyword);
      send_to_char(buf, d->character);
      break;
    }
    return;

  case HEDIT_CONFIRM_ADD:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_setup_new(d);
      break;
    case 'n':
    case 'N':
    case 'q':
    case 'Q':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      sprintf(buf, "Invalid choice!\r\nDo you wish to add help on '%s'? ", OLC_STORAGE(d));
      send_to_char(buf, d->character);
      break;
    }
    return;

  case HEDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {		/* Something was modified */
	send_to_char("Do you wish to save this help internally? ", d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      break;
    case '1':
      OLC_MODE(d) = HEDIT_ENTRY;
      SEND_TO_Q("\x1B[H\x1B[J", d);
      SEND_TO_Q("Enter the help info: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_HELP(d)->entry) {
	SEND_TO_Q(OLC_HELP(d)->entry, d);
	d->backstr = str_dup(OLC_HELP(d)->entry);
      }
      d->str = &OLC_HELP(d)->entry;
      d->max_str = MAX_STRING_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '2':
      send_to_char("Enter the minimum level a player has to be to read this help: "
		   ,d->character);
      OLC_MODE(d) = HEDIT_MIN_LEVEL;
      return;
    default:
      hedit_disp_menu(d);
      break;
    }
    return;

  case HEDIT_ENTRY:
    /* should never get here */
    mudlog("SYSERR: Reached HEDIT_ENTRY in hedit_parse", BRF, LVL_BUILDER, TRUE);
    break;
  case HEDIT_MIN_LEVEL:
    if (*arg) {
      i = atoi(arg);
      if ((i < 0) && (i > LVL_IMPL)) {
	hedit_disp_menu(d);
	return;
      } else
	OLC_HELP(d)->min_level = i;
    } else {
      hedit_disp_menu(d);
      return;
    }
    break;
  default:
    /* we should never get here */
    break;
  }
  OLC_VAL(d) = 1;
  hedit_disp_menu(d);
}

int find_help(char *keyword)
{

  extern int top_of_helpt;
  extern struct help_index_element *help_table;

  int chk, bot, top, mid, minlen;

  bot = 0;
  top = top_of_helpt;
  minlen = strlen(keyword);

  for (;;) {
    mid = (bot + top) / 2;

    if (bot > top)
      return -1;
    else if (!(chk = strn_cmp(keyword, help_table[mid].keyword, minlen))) {
      /* trace backwards to find first matching entry. Thanks Jeff Fink! */
      while ((mid > 0) &&
       (!(chk = strn_cmp(keyword, help_table[mid - 1].keyword, minlen))))
	mid--;
      return mid;
    } else {
      if (chk > 0)
	bot = mid + 1;
      else
	top = mid - 1;
    }
  }
}

void free_help(struct help_index_element *help)
{
  if (help->keyword)
    free(help->keyword);
  if (help->entry)
    free(help->entry);
  memset(help, 0, sizeof(struct help_index_element));
}
@


1.15
log
@Replaced the pager.
@
text
@/***************************************************************************
 * $Id: hedit.c,v 1.14 2008/04/05 05:05:42 myc Exp jps $
 ***************************************************************************/
/***************************************************************************
 *   File: hedit.c                                        Part of FieryMUD *
 *  Usage: Edits help files, for use with OasisOLC.                        *
 *     By: Steve Wolfe                                                     *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "interpreter.h"
#include "handler.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"
#include "screen.h"
#include "math.h"
#include "modify.h"

int find_help(char *keyword);

void free_help(struct help_index_element *help);

/* function protos */
void hedit_disp_menu(struct descriptor_data *d);
void hedit_parse(struct descriptor_data *d, char *arg);
void hedit_setup_new(struct descriptor_data *d);
void hedit_setup_existing(struct descriptor_data *d, int real_num);
void hedit_save_to_disk(struct descriptor_data *d);
void hedit_save_internally(struct descriptor_data *d);
void index_boot(int mode);

/*
 * Utils and exported functions.
 */

void hedit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_HELP(d), struct help_index_element, 1);
  OLC_HELP(d)->keyword = strdup(OLC_STORAGE(d));
  OLC_HELP(d)->entry = strdup("KEYWORDS\r\n\r\nThis help file is unfinished.\r\n");
  OLC_HELP(d)->min_level = 0;
  OLC_HELP(d)->duplicate = 0;
  OLC_VAL(d) = 0;
  hedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void hedit_setup_existing(struct descriptor_data *d, int real_num)
{
  CREATE(OLC_HELP(d), struct help_index_element, 1);
  OLC_HELP(d)->keyword = strdup(help_table[real_num].keyword);
  OLC_HELP(d)->entry = strdup(help_table[real_num].entry);
  OLC_HELP(d)->min_level = help_table[real_num].min_level;
  OLC_HELP(d)->duplicate = help_table[real_num].duplicate;
  OLC_VAL(d) = 0;
  hedit_disp_menu(d);
}


void hedit_save_internally(struct descriptor_data *d)
{
  struct help_index_element *new_help_table = NULL;
  int i;
  char *temp = NULL;
  
  /* add a new help element into the list */
  if (OLC_ZNUM(d) > top_of_helpt) {
    CREATE(new_help_table, struct help_index_element, top_of_helpt + 2);
    for (i = 0; i <= top_of_helpt; i++)
      new_help_table[i] = help_table[i];
    new_help_table[++top_of_helpt] = *OLC_HELP(d);
    free(help_table);
    help_table = new_help_table;
  } else {
    /* This was the original end of hedit_save_internally,
     * however, this would cause crashing in multiple keyword
     * entries.  The fix was posted by Chris Jacobson
     * <fear@@ATHENET.NET> on the CircleMUD Mailing List
     *
     *  i = find_help(OLC_HELP(d)->keyword);
     *
     *  free_help(help_table + OLC_ZNUM(d));
     *  help_table[OLC_ZNUM(d)] = *OLC_HELP(d);
     *
     * Begin the fix
     */
    temp = help_table[OLC_ZNUM(d)].entry;
    for (i = 0; i < top_of_helpt; i++) {
      if (help_table[i].entry == temp) {
	/*    if (!help_table[i].duplicate)   free(help_table[i].entry);
	 * The line above had to be commented because freeing based
	 * upon a duplicate is not only unnecessary--it's dangerous.
	 */
	help_table[i].entry = OLC_HELP(d)->entry;
	help_table[i].min_level = OLC_HELP(d)->min_level;
      }
    }
    free(temp);
  }
  olc_add_to_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}


/*------------------------------------------------------------------------*/

void hedit_save_to_disk(struct descriptor_data *d)
{
  FILE *fp;
  int i;
  
  if (!(fp = fopen(HELP_FILE, "w+"))) {
    sprintf(buf, "Can't open help file '%s'", HELP_FILE);
    perror(buf);
    exit(1);
  }
  for (i = 0; i <= top_of_helpt; i++) {
    if (help_table[i].duplicate > 0)
      continue;
    
    /*. Remove the '\r\n' sequences from entry . */
    strcpy(buf1, help_table[i].entry ? help_table[i].entry : "Empty");
    strip_string(buf1);
    
    sprintf(buf, "%s#%d\n",
	    buf1,
	    help_table[i].min_level);
    fputs(buf, fp);
  }
  
  fprintf(fp, "$\n");
  fclose(fp);
  olc_remove_from_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}

/*------------------------------------------------------------------------*/

/* Menu functions */

/* the main menu */
void hedit_disp_menu(struct descriptor_data *d)
{
  struct help_index_element *help;

  get_char_cols(d->character);
  
  help = OLC_HELP(d);
  
  sprintf(buf,
	  "Keywords       : %s%s\r\n"
	  "%s1%s) Entry       :\r\n%s%s"
	  "%s2%s) Min Level   : %s%d\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  yel, help->keyword,
	  grn, nrm, yel, help->entry,
	  grn, nrm, yel, help->min_level,
	  grn, nrm
	  );
  send_to_char(buf, d->character);
  
  OLC_MODE(d) = HEDIT_MAIN_MENU;
}

/*
 * The main loop
 */

void hedit_parse(struct descriptor_data *d, char *arg)
{
  int i;
  
  switch (OLC_MODE(d)) {
  case HEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_save_internally(d);
      hedit_save_to_disk(d);
      if (help_table) {
	for (i = 0; i <= top_of_helpt; i++) {
	  if (help_table[i].keyword)
	    free(help_table[i].keyword);
	  if (help_table[i].entry && !help_table[i].duplicate)
	    free(help_table[i].entry);
	}
	free(help_table);
      }
      top_of_helpt = 0;
      index_boot(DB_BOOT_HLP);
      
      
      sprintf(buf, "OLC: %s edits help for %s.", GET_NAME(d->character), OLC_HELP(d)->keyword);
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* do not free the strings.. just the structure */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Help saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /* free everything up, including strings etc */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this help internally? ", d->character);
      break;
    }
    return;			/* end of HEDIT_CONFIRM_SAVESTRING */
    
  case HEDIT_CONFIRM_EDIT:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_setup_existing(d, OLC_ZNUM(d));
      break;
    case 'q':
    case 'Q':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    case 'n':
    case 'N':
      OLC_ZNUM(d)++;
      for (; (OLC_ZNUM(d) <= top_of_helpt); OLC_ZNUM(d)++)
	if (is_abbrev(OLC_STORAGE(d), help_table[OLC_ZNUM(d)].keyword))
	  break;
      if (OLC_ZNUM(d) > top_of_helpt) {
	if (find_help(OLC_STORAGE(d)) > NOTHING) {
	  cleanup_olc(d, CLEANUP_ALL);
	  break;
	}
	sprintf(buf, "Do you wish to add help on '%s'? ",
		OLC_STORAGE(d));
	send_to_char(buf, d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_ADD;
      } else {
	sprintf(buf, "Do you wish to edit help on '%s'? ", help_table[OLC_ZNUM(d)].keyword);
	send_to_char(buf, d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_EDIT;
      }
      break;
    default:
      sprintf(buf, "Invalid choice!\r\nDo you wish to edit help on '%s'? ", help_table[OLC_ZNUM(d)].keyword);
      send_to_char(buf, d->character);
      break;
    }
    return;
    
  case HEDIT_CONFIRM_ADD:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_setup_new(d);
      break;
    case 'n':
    case 'N':
    case 'q':
    case 'Q':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      sprintf(buf, "Invalid choice!\r\nDo you wish to add help on '%s'? ", OLC_STORAGE(d));
      send_to_char(buf, d->character);
      break;
    }
    return;
    
  case HEDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {		/* Something was modified */
	send_to_char("Do you wish to save this help internally? ", d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      break;
    case '1':
      OLC_MODE(d) = HEDIT_ENTRY;
      write_to_output("Enter the help info: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_HELP(d)->entry, MAX_STRING_LENGTH);
      OLC_VAL(d) = 1;
      break;
    case '2':
      send_to_char("Enter the minimum level a player has to be to read this help: "
		   ,d->character);
      OLC_MODE(d) = HEDIT_MIN_LEVEL;
      return;
    default:
      hedit_disp_menu(d);
      break;
    }
    return;
    
  case HEDIT_ENTRY:
    /* should never get here */
    mudlog("SYSERR: Reached HEDIT_ENTRY in hedit_parse", BRF, LVL_ATTENDANT, TRUE);
    break;
  case HEDIT_MIN_LEVEL:
    if (*arg) {
      i = atoi(arg);
      if ((i < 0) && (i > LVL_IMPL)) {
	hedit_disp_menu(d);
	return;
      } else
	OLC_HELP(d)->min_level = i;
    } else {
      hedit_disp_menu(d);
      return;
    }
    break;
  default:
    /* we should never get here */
    break;
  }
  OLC_VAL(d) = 1;
  hedit_disp_menu(d);
}

int find_help(char *keyword)
{
  int chk, bot, top, mid, minlen;
  
  bot = 0;
  top = top_of_helpt;
  minlen = strlen(keyword);
  
  for (;;) {
    mid = (bot + top) / 2;
    
    if (bot > top)
      return -1;
    else if (!(chk = strn_cmp(keyword, help_table[mid].keyword, minlen))) {
      /* trace backwards to find first matching entry. Thanks Jeff Fink! */
      while ((mid > 0) &&
	     (!(chk = strn_cmp(keyword, help_table[mid - 1].keyword, minlen))))
	mid--;
      return mid;
    } else {
      if (chk > 0)
	bot = mid + 1;
      else
	top = mid - 1;
    }
  }
}

void free_help(struct help_index_element *help)
{
  if (help->keyword)
    free(help->keyword);
  if (help->entry)
    free(help->entry);
  memset(help, 0, sizeof(struct help_index_element));
}

/***************************************************************************
 * $Log: hedit.c,v $
 * Revision 1.14  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.13  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.12  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.11  2008/02/11 21:04:01  myc
 * Fix the formatting in the main menu.
 *
 * Revision 1.10  2008/02/10 20:30:03  myc
 * Clean-up hedit a tiny bit.
 *
 * Revision 1.9  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.8  2007/11/18 16:51:55  myc
 * Fixing LVL_BUILDER references.
 *
 * Revision 1.7  2007/09/07 04:12:25  jps
 * Fix keyword formatting and disable screen-clearing when you start to edit.
 *
 * Revision 1.6  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.5  2000/11/21 18:56:43  rsd
 * Altered comment header and added back rlog messages from
 * prior to the addition of the $log$ string.
 *
 * Revision 1.4  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.3  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and 
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.2  1999/01/31 06:19:33  mud
 * Added comment header
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.14
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.13 2008/03/28 17:54:53 myc Exp myc $
d29 1
d371 3
@


1.13
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.12 2008/03/22 03:22:38 myc Exp myc $
d291 1
a291 1
      SEND_TO_Q("Enter the help info: (/s saves /h for help)\r\n\r\n", d);
d370 4
@


1.12
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.11 2008/02/11 21:04:01 myc Exp myc $
d50 2
a51 2
  OLC_HELP(d)->keyword = str_dup(OLC_STORAGE(d));
  OLC_HELP(d)->entry = str_dup("KEYWORDS\r\n\r\nThis help file is unfinished.\r\n");
d63 2
a64 2
  OLC_HELP(d)->keyword = str_dup(help_table[real_num].keyword);
  OLC_HELP(d)->entry = str_dup(help_table[real_num].entry);
d370 6
@


1.11
log
@Fix the formatting in the main menu.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.10 2008/02/10 20:30:03 myc Exp myc $
a290 2
      /* The following line sends the clear-screen code.  I don't like that! */
      /* SEND_TO_Q("\x1B[H\x1B[J", d); */
d292 1
a292 8
      d->backstr = NULL;
      if (OLC_HELP(d)->entry) {
	SEND_TO_Q(OLC_HELP(d)->entry, d);
	d->backstr = str_dup(OLC_HELP(d)->entry);
      }
      d->str = &OLC_HELP(d)->entry;
      d->max_str = MAX_STRING_LENGTH;
      d->mail_to = 0;
d370 3
@


1.10
log
@Clean-up hedit a tiny bit.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.9 2008/01/29 21:02:31 myc Exp myc $
d161 1
a161 1
	  "Keywords           : %s%s\r\n"
d379 3
@


1.9
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.8 2007/11/18 16:51:55 myc Exp myc $
d28 1
d51 1
a51 1
  OLC_HELP(d)->entry = str_dup("This help file is unfinished.\r\n");
d54 1
a55 1
  OLC_VAL(d) = 0;
d155 2
a156 3
  char *nrm = CCNRM(d->character, C_NRM);
  char *yel = CCYEL(d->character, C_NRM);
  char *grn = CCGRN(d->character, C_NRM);
d161 1
a161 1
	  "Keywords       : %s%s\r\n"
d205 2
a206 2
      sprintf(buf, "OLC: %s edits help.", GET_NAME(d->character));
      mudlog(buf, CMP, LVL_IMPL, TRUE);
d379 4
@


1.8
log
@Fixing LVL_BUILDER references.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.7 2007/09/07 04:12:25 jps Exp myc $
a28 2
extern int top_of_helpt;
extern struct help_index_element *help_table;
a341 4
  
  extern int top_of_helpt;
  extern struct help_index_element *help_table;
  
d379 3
@


1.7
log
@Fix keyword formatting and disable screen-clearing when you start to edit.
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.6 2002/09/13 02:32:10 jjl Exp jps $
d319 1
a319 1
    mudlog("SYSERR: Reached HEDIT_ENTRY in hedit_parse", BRF, LVL_BUILDER, TRUE);
d385 3
@


1.6
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: hedit.c,v 1.5 2000/11/21 18:56:43 rsd Exp $
d163 1
a163 2
	  ".[H.[J"
	  "Keywords    : %s%s\r\n"
d293 2
a294 1
      SEND_TO_Q("\x1B[H\x1B[J", d);
d385 3
@


1.5
log
@Altered comment header and added back rlog messages from
prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: hedit.c,v 1.4 1999/09/05 07:00:39 jimmy Exp $
d383 26
a408 20
// $Log: hedit.c,v $
// Revision 1.4  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.3  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.2  1999/01/31 06:19:33  mud
// Added comment header
// Indented file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.4
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d3 10
a12 4
 *  File: hedit.c                                         Part of FieryMUD *
 *  Usage:  OLC for MUDs -- this one edits help files, for use with        *
 *          OasisOLC.                                                      *
 *  By: Steve Wolfe                                                        *
d381 20
a400 2

// $Log$
@


1.3
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d1 1
d376 1
@


1.2
log
@Added comment header
Indented file
@
text
@d94 1
a94 1
	/*    if (!help_table[i].duplicate)   FREE(help_table[i].entry);
@


1.1
log
@Initial revision
@
text
@d1 6
a6 6
/*
 * File: hedit.c
 * Comment: OLC for MUDs -- this one edits help files
 * By Steve Wolfe
 * for use with OasisOLC
 */
d69 1
a69 1

d79 22
a100 21
 /* This was the original end of hedit_save_internally,
 * however, this would cause crashing in multiple keyword
 * entries.  The fix was posted by Chris Jacobson
 * <fear@@ATHENET.NET> on the CircleMUD Mailing List
 *
 *  i = find_help(OLC_HELP(d)->keyword);
 *
 *  free_help(help_table + OLC_ZNUM(d));
 *  help_table[OLC_ZNUM(d)] = *OLC_HELP(d);
 *
 * Begin the fix
 */
  temp = help_table[OLC_ZNUM(d)].entry;
  for (i = 0; i < top_of_helpt; i++) {
    if (help_table[i].entry == temp) {
/*    if (!help_table[i].duplicate)   FREE(help_table[i].entry);
 * The line above had to be commented because freeing based
 * upon a duplicate is not only unnecessary--it's dangerous.
 */
      help_table[i].entry = OLC_HELP(d)->entry;
      help_table[i].min_level = OLC_HELP(d)->min_level;
d102 1
a102 2
  }
  free(temp);
d114 1
a114 1

d123 1
a123 1

d127 1
a127 1

d133 1
a133 1

d150 1
a150 1

d152 1
a152 1

d165 1
a165 1
      );
d167 1
a167 1

d178 1
a178 1

d197 2
a198 2


d215 1
a215 1

d253 1
a253 1

d272 1
a272 1

d307 1
a307 1

d335 1
a335 1

d338 1
a338 1

d340 1
a340 1

d344 1
a344 1

d347 1
a347 1

d353 1
a353 1
       (!(chk = strn_cmp(keyword, help_table[mid - 1].keyword, minlen))))
d372 3
a374 1
}@
