head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2009.06.09.05.40.33;	author myc;	state Exp;
branches;
next	;


desc
@IAlloc incrementally allocates memory space using a series
of linked arrays which grow exponentially.
@


1.1
log
@Initial revision
@
text
@#include <stddef.h>

/* Pointer to an ialloc block */
typedef struct ialloc_block *ialloc_token;

/* Return type for icoalesce: an array plus its size in elements */
typedef struct {
  void *array;
  size_t size;
} ialloc_array;

/*
 * ialloc_token ibegin(size_t entry_size)
 *
 * Prepare to begin allocating memory for an array of elements.  Expects
 * one parameter, the size in bytes of one element, as returned by
 * sizeof(element type).  Returns an ialloc token which is required as
 * input for other ialloc functions.
 */
extern ialloc_token ibegin   (size_t       entry_size);

/*
 * void *ialloc(ialloc_token token)
 *
 * Allocate space for one element (determined by the entry_size passed
 * to ibegin for the given token) and return a pointer to this space.
 * This element is added to the internal array.  This memory is 
 * guaranteed to be filled with zeroes.
 */
extern void        *ialloc   (ialloc_token token     );

/*
 * size_t icount(ialloc_token token)
 *
 * Return the number of elements currently in the array.  This value, n,
 * is not cached, and is calculated in O(log n) time.
 */
extern size_t       icount   (ialloc_token token     );

/*
 * ialloc_array icoalesce(ialloc_token token)
 *
 * Return an array containing all elements previously allocated; i.e.,
 * the size of the returned array is equal to the number of times
 * ialloc() is called with the given ialloc token.  icoalesce consumes
 * the ialloc_token, causing it to no longer be valid.  Subsequent
 * invocations of ialloc functions using an invalidated token will
 * result in undefined behavior.
 */
extern ialloc_array icoalesce(ialloc_token token     );
@
