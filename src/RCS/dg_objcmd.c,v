head	1.36;
access;
symbols;
locks; strict;
comment	@ * @;


1.36
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.14.05.09.30;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.11.05.48.33;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.05.20.41.53;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.05.19.44.22;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.05.18.46.13;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.18.20.30.11;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.17.19.23.07;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.30.19.42.46;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.11.19.34.15;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.17.23.59.16;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.14.20.41.49;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.12.02.31.01;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.29.03.36.42;	author rsd;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.24.22.22.30;	author jjl;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.25.06.59.02;	author mtp;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.19.23.46.52;	author mtp;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.22.23.15.13;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.03.44.47;	author rsd;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.27.22.16.48;	author mtp;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.01.21.04.42;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	99.10.30.15.30.42;	author rsd;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.00.53.55;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/**************************************************************************
*  File: objcmd.c                                                         *
*  Usage: contains the command_interpreter for objects,                   *
*         object commands.                                                *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/04 23:10:16 $
*  $Revision: 3.8 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern struct index_data *obj_index;

char_data *get_char_by_obj(obj_data *obj, char *name);
obj_data *get_obj_by_obj(obj_data *obj, char *name);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
void die(struct char_data * ch, struct char_data *killer);

#define OCMD(name)  \
   void (name)(obj_data *obj, char *argument, int cmd, int subcmd)


struct obj_command_info {
   char *command;
   void	(*command_pointer)(obj_data *obj, char *argument, int cmd, int subcmd);
   int	subcmd;
};


/* do_osend */
#define SCMD_OSEND         0
#define SCMD_OECHOAROUND   1



/* attaches object name and vnum to msg and sends it to script_log */
void obj_log(obj_data *obj, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Obj (%s, VNum %d): %s",
	    obj->short_description, GET_OBJ_VNUM(obj), msg);
    script_log(buf);
}


/* returns the real room number that the object or object's carrier is in */
int obj_room(obj_data *obj)
{
    if (obj->in_room != NOWHERE)
	return obj->in_room;
    else if (obj->carried_by)
	return IN_ROOM(obj->carried_by);
    else if (obj->worn_by)
	return IN_ROOM(obj->worn_by);
    else if (obj->in_obj)
	return obj_room(obj->in_obj);
    else
	return NOWHERE;
}


/* returns the real room number, or NOWHERE if not found or invalid */
int find_obj_target_room(obj_data *obj, char *rawroomstr)
{
    int tmp;
    int location;
    char_data *target_mob;
    obj_data *target_obj;
    char roomstr[MAX_INPUT_LENGTH];

    one_argument(rawroomstr, roomstr);

    if (!*roomstr)
	return NOWHERE;

    if (isdigit(*roomstr) && !strchr(roomstr, '.'))
    {
	tmp = atoi(roomstr);
	if ((location = real_room(tmp)) < 0)
	    return NOWHERE;
    }

    else if ((target_mob = get_char_by_obj(obj, roomstr)))
	location = IN_ROOM(target_mob);
    else if ((target_obj = get_obj_by_obj(obj, roomstr)))
    {
	if (target_obj->in_room != NOWHERE)
	    location = target_obj->in_room;
	else
	    return NOWHERE;
    }
    else
	return NOWHERE;

    /* a room has been found.  Check for permission */
    if (ROOM_FLAGGED(location, ROOM_GODROOM) ||
#ifdef ROOM_IMPROOM
	ROOM_FLAGGED(location, ROOM_IMPROOM) ||
#endif
	ROOM_FLAGGED(location, ROOM_HOUSE))
	return NOWHERE;

    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room)
	return NOWHERE;

    return location;
}



/* Object commands */

OCMD(do_oecho)
{
    int room;

    skip_spaces(&argument);

    if (!*argument)
	obj_log(obj, "oecho called with no args");

    else if ((room = obj_room(obj)) != NOWHERE)
    {
    	if (world[room].people)
	    sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
    }

    else
	obj_log(obj, "oecho called by object in NOWHERE");
}


OCMD(do_oforce)
{
    char_data *ch, *next_ch;
    int room;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !arg2)
    {
	obj_log(obj, "oforce called with too few args");
	return;
    }

    if (!str_cmp(arg1, "all"))
    {
	if ((room = obj_room(obj)) == NOWHERE)
	    obj_log(obj, "oforce called by object in NOWHERE");
	else
	{
	    for (ch = world[room].people; ch; ch = next_ch)
	    {
		next_ch = ch->next_in_room;

		if (GET_LEVEL(ch)<LVL_IMMORT)
		{
		    command_interpreter(ch, arg2);
		}
	    }
	}
    }

    else
    {
	if ((ch = get_char_by_obj(obj, arg1)))
	{
	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, arg2);
	    }
	}

	else
	    obj_log(obj, "oforce: no target found");
    }
}


OCMD(do_osend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;

    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
	obj_log(obj, "osend called with no args");
	return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
	obj_log(obj, "osend called without a message");
	return;
    }

    if ((ch = get_char_by_obj(obj, buf)))
    {
	if (subcmd == SCMD_OSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_OECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
    }

    else
	obj_log(obj, "no target found for osend");
}

/* increases the target's exp */
OCMD(do_oexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount)
    {
	obj_log(obj, "oexp: too few arguments");
	return;
    }

    if ((ch = get_char_by_obj(obj, name)))
	gain_exp(ch, atoi(amount));
    else
    {
	obj_log(obj, "oexp: target not found");
	return;
    }
}


/* purge all objects an npcs in room, or specified object or mob */
OCMD(do_opurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *o, *next_obj;
    int rm;

    one_argument(argument, arg);

    if (!*arg)
    {
	if ((rm = obj_room(obj)) != NOWHERE)
	{
	    for (ch = world[rm].people; ch; ch = next_ch )
	    {
		next_ch = ch->next_in_room;
		if (IS_NPC(ch))
		    extract_char(ch);
	    }

	    for (o = world[rm].contents; o; o = next_obj )
	    {
		next_obj = o->next_content;
		if (o != obj)
		    extract_obj(o);
	    }
	}

	return;
    }

    if (!(ch = get_char_by_obj(obj, arg)))
    {
	if ((o = get_obj_by_obj(obj, arg)))
	    extract_obj(o);
	else
	    obj_log(obj, "opurge: bad argument");

	return;
    }

    if (!IS_NPC(ch))
    {
	obj_log(obj, "opurge: purging a PC");
	return;
    }

    extract_char(ch);
}


OCMD(do_oteleport)
{
    char_data *ch, *next_ch;
    int target, rm;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2)
    {
	obj_log(obj, "oteleport called with too few args");
	return;
    }

    target = find_obj_target_room(obj, arg2);

    if (target == NOWHERE)
	obj_log(obj, "oteleport target is an invalid room");

    else if (!str_cmp(arg1, "all"))
    {
	rm = obj_room(obj);
	if (target == rm)
	    obj_log(obj, "oteleport target is itself");

	for (ch = world[rm].people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;

	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    }

    else
    {
	if ((ch = get_char_by_obj(obj, arg1)))
	{
	    char_from_room(ch);
	    char_to_room(ch, target);
	}

	else
	    obj_log(obj, "oteleport: no target found");
    }
}


OCMD(do_dgoload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0, room;
    char_data *mob;
    obj_data *object;

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0))
    {
        obj_log(obj, "oload: bad syntax");
        return;
    }

    if ((room = obj_room(obj)) == NOWHERE)
    {
        obj_log(obj, "oload: object in NOWHERE trying to load");
        return;
    }

    if (is_abbrev(arg1, "mob"))
    {
        if ((mob = read_mobile(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad mob vnum");
            return;
        }
        char_to_room(mob, room);
    }

    else if (is_abbrev(arg1, "obj"))
    {
        if ((object = read_object(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad object vnum");
            return;
        }

        obj_to_room(object, room);
    }

    else
        obj_log(obj, "oload: bad type");

}

OCMD(do_odamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	obj_log(obj, "odamage: bad syntax");
	return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_obj(obj, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.", ch);
	    return;
	}
	GET_HIT(ch) -= dam;
	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
       	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
	    }
    	    die(ch, NULL);
	}
    }
    else
	obj_log(obj, "odamage: target not found");
}

const struct obj_command_info obj_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

    { "oecho"      , do_oecho    , 0 },
    { "oechoaround", do_osend    , SCMD_OECHOAROUND },
    { "oexp"       , do_oexp     , 0 },
    { "oforce"     , do_oforce   , 0 },
    { "oload"	   , do_dgoload	 , 0 },
    { "opurge"     , do_opurge   , 0 },
    { "osend"      , do_osend    , SCMD_OSEND },
    { "oteleport"  , do_oteleport, 0 },
    { "odamage"    , do_odamage,   0 },

    { "\n", 0, 0 }	/* this must be last */
};



/*
 *  This is the command interpreter used by objects, called by script_driver.
 */
void obj_command_interpreter(obj_data *obj, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];

    skip_spaces(&argument);

    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg),cmd = 0;
	 *obj_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(obj_cmd_info[cmd].command, arg, length))
	    break;

    if (*obj_cmd_info[cmd].command == '\n')
    {
	sprintf(buf2, "Unknown object cmd: '%s'", argument);
	obj_log(obj, buf2);
    }
    else
	((*obj_cmd_info[cmd].command_pointer)
	 (obj, line, cmd, obj_cmd_info[cmd].subcmd));
}
@


1.36
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@/***************************************************************************
 * $Id: dg_objcmd.c,v 1.35 2009/06/09 19:33:50 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *  File: objcmd.c                                       Part of FieryMUD  *
 *  Usage: contains the command_interpreter for objects, object commands.  *
 *  $Author: myc $                                                         *
 *  $Date: 2009/06/09 19:33:50 $                                           *
 *  $Revision: 1.35 $                                                       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "quest.h"
#include "chars.h"
#include "events.h"
#include "regen.h"
#include "movement.h"
#include "limits.h"
#include "damage.h"

void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
int get_room_location(char *room);
struct find_context find_dg_by_name(char *name);


#define OCMD(name)  \
   void (name)(obj_data *obj, struct trig_data *t, char *argument, int cmd, int subcmd)


struct obj_command_info {
  char *command;
  void        (*command_pointer)(obj_data *obj, struct trig_data *t,char *argument, int cmd, int subcmd);
  int        subcmd;
};


/* do_osend */
#define SCMD_OSEND         0
#define SCMD_OECHOAROUND   1



/* attaches object name and vnum to msg and sends it to script_log */
void obj_log(obj_data *obj, struct trig_data *t, char *msg)
{
  char buf[MAX_INPUT_LENGTH + 100];

  void script_log(struct trig_data *t, char *msg);

  sprintf(buf, "(TRG)(object %d): %s", GET_OBJ_VNUM(obj), msg);
  script_log(t, buf);
}


/* returns the real room number that the object or object's carrier is in */
int obj_room(obj_data *obj)
{
  if (obj->in_room != NOWHERE)
    return obj->in_room;
  else if (obj->carried_by)
    return IN_ROOM(obj->carried_by);
  else if (obj->worn_by)
    return IN_ROOM(obj->worn_by);
  else if (obj->in_obj)
    return obj_room(obj->in_obj);
  else
    return NOWHERE;
}


/* returns the real room number, or NOWHERE if not found or invalid */
int find_obj_target_room(obj_data *obj, char *rawroomstr)
{
  int location;
  char_data *target_mob;
  obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];

  one_argument(rawroomstr, roomstr);

  if (!*roomstr)
    return NOWHERE;

  /*
   * See if the string refers to a room UID or vnum first.  If no
   * matching room is found, try a character, and then an object.
   */
  if ((location = get_room_location(roomstr)) != NOWHERE);
  else if ((target_mob = find_char_around_obj(obj, find_dg_by_name(roomstr))) &&
           (location = IN_ROOM(target_mob)) != NOWHERE);
  else if ((target_obj = find_obj_around_obj(obj, find_by_name(roomstr))) &&
           (location = obj_room(target_obj)) != NOWHERE);
  else return NOWHERE;

  /* A room has been found.  Check for permission */
  if (ROOM_FLAGGED(location, ROOM_GODROOM) ||
      ROOM_FLAGGED(location, ROOM_HOUSE))
    return NOWHERE;

  if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
      world[location].people && world[location].people->next_in_room)
    return NOWHERE;

  return location;
}



/* Object commands */

OCMD(do_oecho)
{
  int room;

  skip_spaces(&argument);

  if (!*argument)
    obj_log(obj, t, "oecho called with no args");

  else if ((room = obj_room(obj)) != NOWHERE)
    {
      if (world[room].people)
        sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
    }

  else
    obj_log(obj, t, "oecho called by object in NOWHERE");
}


OCMD(do_oforce)
{
  char_data *ch, *next_ch;
  int room;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  /* two_arguments only returns two _words_ but our force string
  ** may be more than one word..
  */
  /*two_arguments(argument, arg1, arg2);*/
  strncpy(arg2, one_argument(argument, arg1), MAX_INPUT_LENGTH);

  if (!*arg1 || !*arg2)
    {
      obj_log(obj, t, "oforce called with too few args");
      return;
    }

  if (!str_cmp(arg1, "all"))
    {
      if ((room = obj_room(obj)) == NOWHERE)
        obj_log(obj, t, "oforce called by object in NOWHERE");
      else
        {
          for (ch = world[room].people; ch; ch = next_ch)
            {
              next_ch = ch->next_in_room;

              if (GET_LEVEL(ch)<LVL_IMMORT)
                {
                  command_interpreter(ch, arg2);
                }
            }
        }
    }

  else
    {
      if ((ch = find_char_around_obj(obj, find_dg_by_name(arg1))))
        {
          if (GET_LEVEL(ch)<LVL_IMMORT)
            {
              command_interpreter(ch, arg2);
            }
        }

      else
        obj_log(obj, t, "oforce: no target found");
    }
}


OCMD(do_osend)
{
  char buf[MAX_INPUT_LENGTH], *msg;
  char_data *ch;

  msg = any_one_arg(argument, buf);

  if (!*buf)
    {
      obj_log(obj, t, "osend called with no args");
      return;
    }

  skip_spaces(&msg);

  if (!*msg)
    {
      obj_log(obj, t, "osend called without a message");
      return;
    }

  if ((ch = find_char_around_obj(obj, find_dg_by_name(buf))))
    {
      if (subcmd == SCMD_OSEND)
        sub_write(msg, ch, TRUE, TO_CHAR);
      else if (subcmd == SCMD_OECHOAROUND)
        sub_write(msg, ch, TRUE, TO_ROOM);
    }

  else
    obj_log(obj, t, "no target found for osend");
}

/* increases the target's exp */
OCMD(do_oexp)
{
  char_data *ch;
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

  two_arguments(argument, name, amount);

  if (!*name || !*amount)
    {
      obj_log(obj, t, "oexp: too few arguments");
      return;
    }

  if ((ch = find_char_around_obj(obj, find_dg_by_name(name))))
    gain_exp(ch, atoi(amount), GAIN_IGNORE_LEVEL_BOUNDARY |
                               GAIN_IGNORE_LOCATION);
  else
    {
      obj_log(obj, t, "oexp: target not found");
      return;
    }
}


/* purge all objects an npcs in room, or specified object or mob */
OCMD(do_opurge)
{
  char arg[MAX_INPUT_LENGTH];
  char_data *ch, *next_ch;
  obj_data *o, *next_obj;
  int rm;

  one_argument(argument, arg);

  if (!*arg) {
    if ((rm = obj_room(obj))) {
      for (ch = world[rm].people; ch; ch = next_ch) {
        next_ch = ch->next_in_room;
        if (IS_NPC(ch))
          fullpurge_char(ch);
      }
      for (o = world[rm].contents; o; o = next_obj) {
         next_obj = o->next_content;
         if (o != obj)
           extract_obj(o);
      }
    }
    return;
  }

  if (!(ch = find_char_around_obj(obj, find_dg_by_name(arg)))) {
    if ((o = find_obj_for_keyword(obj, arg)))
      extract_obj(obj);
    else if ((o = find_obj_around_obj(obj, find_by_name(arg))))
      extract_obj(o);
    else
      obj_log(obj, t, "opurge: bad argument");
      return;
  }

  if (!IS_NPC(ch)) {
    obj_log(obj, t, "opurge: attempting to purge PC");
    return;
  }

  fullpurge_char(ch);
}


OCMD(do_oteleport)
{
  char_data *ch, *next_ch;
  int target, rm;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  two_arguments(argument, arg1, arg2);

  if (!*arg1 || !*arg2) {
    obj_log(obj, t, "oteleport called with too few args");
    return;
  }

  target = find_obj_target_room(obj, arg2);

  if (target == NOWHERE)
    obj_log(obj, t, "oteleport target is an invalid room");

  else if (!str_cmp(arg1, "all")) {
    rm = obj_room(obj);
    if (target == rm)
      obj_log(obj, t, "oteleport target is itself");

    for (ch = world[rm].people; ch; ch = next_ch) {
      next_ch = ch->next_in_room;
      dismount_char(ch);
      char_from_room(ch);
      char_to_room(ch, target);
    }
  }

  else {
    if ((ch = find_char_around_obj(obj, find_dg_by_name(arg1)))) {
      dismount_char(ch);
      char_from_room(ch);
      char_to_room(ch, target);
    }
    else
      obj_log(obj, t, "oteleport: no target found");
  }
}


OCMD(do_dgoload)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int number = 0, room;
  char_data *mob;
  obj_data *object;

  two_arguments(argument, arg1, arg2);

  if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0))
    {
      obj_log(obj, t, "oload: bad syntax");
      return;
    }

  if ((room = obj_room(obj)) == NOWHERE)
    {
      obj_log(obj, t, "oload: object in NOWHERE trying to load");
      return;
    }

  if (is_abbrev(arg1, "mob"))
    {
      if ((mob = read_mobile(number, VIRTUAL)) == NULL)
        {
          obj_log(obj, t, "oload: bad mob vnum");
          return;
        }
      char_to_room(mob, room);
      load_mtrigger(mob);
    }

  else if (is_abbrev(arg1, "obj"))
    {
      if ((object = read_object(number, VIRTUAL)) == NULL)
        {
          obj_log(obj, t, "oload: bad object vnum");
          return;
        }

      obj_to_room(object, room);
    }

  else
    obj_log(obj, t, "oload: bad type");

}

OCMD(do_oheal) {
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
  int dam = 0;
  char_data *ch;

  two_arguments(argument, name, amount);

  if (!*name || !*amount || !isdigit(*amount)) {
    obj_log(obj, t, "oheal: bad syntax");
    return;
  }

  dam = atoi(amount);

  if ((ch = find_char_around_obj(obj, find_dg_by_name(name)))) {
    if (GET_LEVEL(ch)>=LVL_IMMORT) {
      send_to_char("Being a god, you don't need healing.\r\n", ch);
      return;
    }
    hurt_char(ch, NULL, -dam, TRUE);
  }
  else
    obj_log(obj, t, "oheal: target not found");
}

OCMD(do_odamage) {
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH], damtype[MAX_INPUT_LENGTH];
  int dam = 0, dtype = DAM_UNDEFINED;
  char_data *ch;

  t->damdone = 0;
  argument = one_argument(argument, name);
  argument = one_argument(argument, amount);

  if (!*name || !*amount || !isdigit(*amount)) {
    obj_log(obj, t, "odamage: bad syntax");
    return;
  }

  dam = atoi(amount);

  ch = find_char_around_obj(obj, find_dg_by_name(name));
  if (!ch) {
    obj_log(obj, t, "odamage: target not found");
    return;
  }

  if (GET_LEVEL(ch) >= LVL_IMMORT) return;

  /* Check for and use optional damage-type parameter */
  argument = one_argument(argument, damtype);
  if (*damtype) {
    dtype = parse_damtype(0, damtype);
    if (dtype == DAM_UNDEFINED) {
      sprintf(buf,
            "odamage called with invalid third argument (\"%s\") - not a damage type",
            damtype);
      obj_log(obj, t, buf);
      return;
    }
    dam = dam * susceptibility(ch, dtype) / 100;
    if (!dam) return;
  }

  t->damdone = dam;
  sethurtevent(0, ch, dam);
}

/*
 * Object version of do_quest
 * note, we don't return anything regardless of success of fail (whats an object gonna do?)
 * and we DONT allow the godly commands (rewind, restart) or stage since its a bit
 * pointless..
 * conversley, we CAN match any player in the mud, even invis/hidden whatever
 */
OCMD(do_obj_quest)
{
  perform_quest(t, argument, NULL, obj, NULL);
}

OCMD(do_obj_log) {
  obj_log(obj, t, argument);
}

const struct obj_command_info obj_cmd_info[] = {
  { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

  { "oecho"      , do_oecho    , 0 },
  { "oechoaround", do_osend    , SCMD_OECHOAROUND },
  { "oexp"       , do_oexp     , 0 },
  { "oforce"     , do_oforce   , 0 },
  { "oload"         , do_dgoload  , 0 },
  { "opurge"     , do_opurge   , 0 },
  { "osend"      , do_osend    , SCMD_OSEND },
  { "oteleport"  , do_oteleport, 0 },
  { "odamage"    , do_odamage  , 0 },
  { "oheal"      , do_oheal    , 0 },
  { "quest"         , do_obj_quest, 0 },
  { "log"        , do_obj_log  , 0 },
  { "\n", 0, 0 }        /* this must be last */
};



/*
 *  This is the command interpreter used by objects, called by script_driver.
 */
void obj_command_interpreter(obj_data *obj, struct trig_data *t,char *argument)
{
  int cmd, length;
  char *line, arg[MAX_INPUT_LENGTH];

  skip_spaces(&argument);

  /* just drop to next line for hitting CR */
  if (!*argument)
    return;

  line = any_one_arg(argument, arg);


  /* find the command */
  for (length = strlen(arg),cmd = 0;
       *obj_cmd_info[cmd].command != '\n'; cmd++)
    if (!strncmp(obj_cmd_info[cmd].command, arg, length))
      break;

  if (*obj_cmd_info[cmd].command == '\n')
    {
      sprintf(buf2, "Unknown object cmd: '%s'", argument);
      obj_log(obj, t, buf2);
    }
  else
    ((*obj_cmd_info[cmd].command_pointer)
     (obj, t, line, cmd, obj_cmd_info[cmd].subcmd));
}


/***************************************************************************
 * $Log: dg_objcmd.c,v $
 * Revision 1.35  2009/06/09 19:33:50  myc
 * Rewrote gain_exp and retired gain_exp_regardless.
 *
 * Revision 1.34  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.33  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.32  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.31  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.30  2008/05/14 05:09:30  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.29  2008/05/11 05:48:33  jps
 * Calling alter_hit() which also takes care of position changes.
 *
 * Revision 1.28  2008/04/05 20:41:53  jps
 * odamage sets an event to do damage rather than doing it itself.
 *
 * Revision 1.27  2008/04/05 19:44:22  jps
 * Set damdone to the damage done by odamage. Don't send any messages
 * when someone receives 0 damage.
 *
 * Revision 1.26  2008/04/05 18:46:13  jps
 * Allow a third parameter, damage type, to odamage, which will
 * allow the victim to resist.
 *
 * Revision 1.25  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.24  2008/04/02 03:24:44  myc
 * Removed unnecessary function declaration.
 *
 * Revision 1.23  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.22  2008/01/18 20:30:11  myc
 * Fixing some send_to_char strings that don't end with a newline.
 *
 * Revision 1.21  2008/01/17 19:23:07  myc
 * The find_obj_target_room function now accepts a room UID, and
 * is used by oteleport.
 *
 * Revision 1.20  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.19  2007/08/30 19:42:46  jps
 * Cause *purge dg script commands to destroy all of a mobile's inventory
 * and equipment when purging mobs.
 *
 * Revision 1.18  2007/05/11 19:34:15  myc
 * Modified the quest command functions so they are thin wrappers for
 * perform_quest() in quest.c.  Error handling and messages should be
 * much better now.  Advance and rewind now accept another argument
 * specifying how many stages to advance or rewind.
 *
 * Revision 1.17  2007/04/17 23:59:16  myc
 * New trigger type: Load.  It goes off any time a mobile is loaded, whether
 * it be god command, zone command, or trigger command.
 *
 * Revision 1.16  2006/11/14 20:41:49  jps
 * Make trap damage regenerate normally.
 *
 * Revision 1.15  2006/11/12 02:31:01  jps
 * You become unmounted when magically moved to another room.
 *
 * Revision 1.14  2003/07/29 03:36:42  rsd
 * added (TRG) to the logging output of the log command
 * for ease of parsing.
 *
 * Revision 1.13  2003/07/24 22:22:30  jjl
 * Added the "log" command for mob, room, and object triggers.  Spits
 * whatever you want into the log.
 *
 * Revision 1.12  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.11  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.10  2001/07/25 06:59:02  mtp
 * modified logging to hopefully be a bit more helpful by specifying the
 * trigger id wherever possible. This does not apply to logging of mob trigs yet
 * as mobs use the same commands as players :-(
 *
 * Revision 1.9  2001/06/19 23:46:52  mtp
 * improved quest error messages
 *
 * Revision 1.8  2000/11/22 23:15:13  mtp
 * added ability to use quest command in here
 *
 * Revision 1.7  2000/11/21 03:44:47  rsd
 * Altered the comment header slightly and added the back
 * rlog messages from prior to the addition of then $log$
 * string.
 *
 * Revision 1.6  2000/03/27 22:16:48  mtp
 * added oheal which wasnt there before for some reason
 *
 * Revision 1.5  2000/02/01 21:04:42  mtp
 * fixed oforce command so that it takes a line instead of
 * just a second word
 *
 * Revision 1.4  1999/10/30 15:30:42  rsd
 * Jimmy coded alignment restrictions for paladins and exp
 * altered gain_exp() to reference the victim.
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 00:53:55  mud
 * Added to the comment header
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.35
log
@Rewrote gain_exp and retired gain_exp_regardless.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.34 2009/03/08 21:43:27 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2009/03/08 21:43:27 $                                           *
 *  $Revision: 1.34 $                                                       *
d157 1
a157 1
  if (!*arg1 || !arg2)
d531 3
@


1.34
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.33 2009/03/03 19:43:44 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2009/03/03 19:43:44 $                                           *
 *  $Revision: 1.33 $                                                       *
d245 2
a246 1
    gain_exp(ch, NULL, atoi(amount));
d531 3
@


1.33
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.32 2008/09/02 06:52:30 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/09/02 06:52:30 $                                           *
 *  $Revision: 1.32 $                                                       *
d33 1
d530 3
@


1.32
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.31 2008/09/01 23:47:49 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/09/01 23:47:49 $                                           *
 *  $Revision: 1.31 $                                                       *
a33 2
char_data *get_char_by_obj(obj_data *obj, char *name);
obj_data *get_obj_by_obj(obj_data *obj, char *name);
d36 1
d102 1
a102 1
  else if ((target_mob = get_char_by_obj(obj, roomstr)) &&
d104 1
a104 1
  else if ((target_obj = get_obj_by_obj(obj, roomstr)) &&
d154 1
a154 1
  strncpy(arg2,one_argument(argument,arg1),MAX_INPUT_LENGTH);
d182 1
a182 1
      if ((ch = get_char_by_obj(obj, arg1)))
d217 1
a217 1
  if ((ch = get_char_by_obj(obj, buf)))
d243 1
a243 1
  if ((ch = get_char_by_obj(obj, name)))
d263 12
a274 20
  if (!*arg)
    {
      if ((rm = obj_room(obj)) != NOWHERE)
        {
          for (ch = world[rm].people; ch; ch = next_ch )
            {
              next_ch = ch->next_in_room;
              if (IS_NPC(ch))
            fullpurge_char(ch);
            }

          for (o = world[rm].contents; o; o = next_obj )
            {
              next_obj = o->next_content;
              if (o != obj)
                extract_obj(o);
            }
        }

      return;
d276 2
d279 7
a285 7
  if (!(ch = get_char_by_obj(obj, arg)))
    {
      if ((o = get_obj_by_obj(obj, arg)))
        extract_obj(o);
      else
        obj_log(obj, t, "opurge: bad argument");

d287 1
a287 1
    }
d289 4
a292 5
  if (!IS_NPC(ch))
    {
      obj_log(obj, t, "opurge: purging a PC");
      return;
    }
d330 1
a330 1
    if ((ch = get_char_by_obj(obj, arg1))) {
d403 1
a403 1
  if ((ch = get_char_by_obj(obj, name))) {
d430 1
a430 1
  ch = get_char_by_obj(obj, name);
d529 3
@


1.31
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.30 2008/05/14 05:09:30 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/14 05:09:30 $                                           *
 *  $Revision: 1.30 $                                                       *
d32 1
d537 3
@


1.30
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.29 2008/05/11 05:48:33 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/05/11 05:48:33 $                                           *
 *  $Revision: 1.29 $                                                       *
d31 1
a35 1
void dismount_char(struct char_data * ch);
d536 3
@


1.29
log
@Calling alter_hit() which also takes care of position changes.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.28 2008/04/05 20:41:53 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 20:41:53 $                                           *
 *  $Revision: 1.28 $                                                       *
d415 1
a415 1
    alter_hit(ch, NULL, -dam, TRUE);
d536 3
@


1.28
log
@odamage sets an event to do damage rather than doing it itself.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.27 2008/04/05 19:44:22 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 19:44:22 $                                           *
 *  $Revision: 1.27 $                                                       *
d30 1
d415 1
a415 6
    if ((GET_HIT(ch) + dam) < GET_MAX_HIT(ch))
            GET_HIT(ch) += dam;
    else
        GET_HIT(ch) = GET_MAX_HIT(ch);

    update_pos(ch);
d536 3
@


1.27
log
@Set damdone to the damage done by odamage. Don't send any messages
when someone receives 0 damage.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.26 2008/04/05 18:46:13 jps Exp jps $
d8 2
a9 2
 *  $Date: 2008/04/05 18:46:13 $                                           *
 *  $Revision: 1.26 $                                                       *
d29 1
a463 1
  alter_hit(ch, dam, TRUE);
d465 1
a465 37
  update_pos(ch);

  switch (GET_POS(ch)) {
  case POS_MORTALLYW:
    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
    break;
  case POS_INCAP:
    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    break;
  case POS_STUNNED:
    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    break;
  case POS_DEAD:
    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("You are dead!  Sorry...\r\n", ch);
    break;

  default:                        /* >= POSITION SLEEPING */
    if (dam > (GET_MAX_HIT(ch) >> 2))
      act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
      sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
              CLRLV(ch, FRED, C_SPR), CLRLV(ch, ANRM, C_SPR));
      send_to_char(buf2, ch);
    }
  }
  if (GET_POS(ch) == POS_DEAD) {
    if (!IS_NPC(ch)) {
      sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
              world[ch->in_room].name);
      mudlog(buf2, BRF, 0, TRUE);
    }
    die(ch, NULL);
  }
d540 4
@


1.26
log
@Allow a third parameter, damage type, to odamage, which will
allow the victim to resist.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.25 2008/04/03 02:02:05 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/04/03 02:02:05 $                                           *
 *  $Revision: 1.25 $                                                       *
d429 1
d446 1
a446 4
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.\r\n", ch);
    return;
  }
d460 1
a460 5
    if (!dam) {
      send_to_char("You are unaffected by the trap.\r\n", ch);
      act("$n is unharmed.", TRUE, ch, 0, 0, TO_ROOM);
      return;
    }
d464 1
d576 4
@


1.25
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.24 2008/04/02 03:24:44 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/04/02 03:24:44 $                                           *
 *  $Revision: 1.24 $                                                       *
d28 1
d43 2
a44 2
  void	(*command_pointer)(obj_data *obj, struct trig_data *t,char *argument, int cmd, int subcmd);
  int	subcmd;
d58 1
a58 1
  
d60 1
a60 1
  
d89 1
a89 1
  
d91 1
a91 1
  
d94 1
a94 1
  
d105 1
a105 1
  
d107 1
a107 1
  if (ROOM_FLAGGED(location, ROOM_GODROOM) || 
d110 1
a110 1
  
d114 1
a114 1
  
d125 1
a125 1
  
d127 2
a128 2
  
  if (!*argument) 
d130 1
a130 1
  
d134 1
a134 1
	sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
d136 1
a136 1
  
d147 1
a147 1
  
d153 1
a153 1
  
d159 1
a159 1
  
d162 2
a163 2
      if ((room = obj_room(obj)) == NOWHERE) 
	obj_log(obj, t, "oforce called by object in NOWHERE");
d165 11
a175 11
	{
	  for (ch = world[room].people; ch; ch = next_ch)
	    {
	      next_ch = ch->next_in_room;
	      
	      if (GET_LEVEL(ch)<LVL_IMMORT)
		{
		  command_interpreter(ch, arg2);
		}
	    }
	}      
d177 1
a177 1
  
d181 7
a187 7
	{
	  if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
	      command_interpreter(ch, arg2);
	    }
	}
      
d189 1
a189 1
	obj_log(obj, t, "oforce: no target found");
d198 1
a198 1
  
d200 1
a200 1
  
d206 1
a206 1
  
d208 1
a208 1
  
d214 1
a214 1
  
d218 1
a218 1
	sub_write(msg, ch, TRUE, TO_CHAR);
d220 1
a220 1
	sub_write(msg, ch, TRUE, TO_ROOM);
d222 1
a222 1
  
d232 1
a232 1
  
d234 1
a234 1
  
d240 2
a241 2
  
  if ((ch = get_char_by_obj(obj, name))) 
d258 1
a258 1
  
d260 1
a260 1
  
d264 5
a268 5
	{
	  for (ch = world[rm].people; ch; ch = next_ch )
	    {
	      next_ch = ch->next_in_room;
	      if (IS_NPC(ch))
d270 10
a279 10
	    }
	  
	  for (o = world[rm].contents; o; o = next_obj )
	    {
	      next_obj = o->next_content;
	      if (o != obj)
		extract_obj(o);
	    }
	}
      
d282 1
a282 1
  
d286 4
a289 4
	extract_obj(o);
      else 
	obj_log(obj, t, "opurge: bad argument");
      
d292 1
a292 1
  
d298 1
a298 1
  
d308 1
a308 1
  
d310 1
a310 1
  
d315 1
a315 1
  
d317 2
a318 2
  
  if (target == NOWHERE) 
d320 1
a320 1
  
d325 1
a325 1
      
d333 1
a333 1
  
d352 1
a352 1
  
d354 1
a354 1
  
d360 1
a360 1
  
d366 1
a366 1
  
d371 2
a372 2
	  obj_log(obj, t, "oload: bad mob vnum");
	  return;
d377 1
a377 1
  
d382 2
a383 2
	  obj_log(obj, t, "oload: bad object vnum");
	  return;
d385 1
a385 1
      
d388 1
a388 1
  
d391 1
a391 1
  
d398 1
a398 1
  
d400 1
a400 1
  
d405 1
a405 1
  
d407 1
a407 1
  
d414 1
a414 1
    	GET_HIT(ch) += dam;
d417 1
a417 1
    
d425 2
a426 2
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
  int dam = 0;
d428 4
a431 3
  
  two_arguments(argument, name, amount);
  
d436 1
a436 1
  
d438 27
a464 4
  
  if ((ch = get_char_by_obj(obj, name))) {
    if (GET_LEVEL(ch) >= LVL_IMMORT) {
      send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.\r\n", ch);
d467 37
a503 36
    alter_hit(ch, dam, TRUE);
    update_pos(ch);
    switch (GET_POS(ch)) {
    case POS_MORTALLYW:
      act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
      break;
    case POS_INCAP:
      act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
      break;
    case POS_STUNNED:
      act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
      break;
    case POS_DEAD:
      act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You are dead!  Sorry...\r\n", ch);
      break;
      
    default:			/* >= POSITION SLEEPING */
      if (dam > (GET_MAX_HIT(ch) >> 2))
	act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
      if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		CLRLV(ch, FRED, C_SPR), CLRLV(ch, ANRM, C_SPR));
	send_to_char(buf2, ch);
      }
    }
    if (GET_POS(ch) == POS_DEAD) {
      if (!IS_NPC(ch)) {
	sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
		world[ch->in_room].name);
	mudlog(buf2, BRF, 0, TRUE);
      }
      die(ch, NULL);
d505 1
a506 2
  else
    obj_log(obj, t, "odamage: target not found");
d522 1
a522 1
  obj_log(obj, t, argument); 
d527 1
a527 1
  
d532 1
a532 1
  { "oload"	 , do_dgoload  , 0 },
d538 3
a540 3
  { "quest"	 , do_obj_quest, 0 },
  { "log"        , do_obj_log  , 0 }, 
  { "\n", 0, 0 }	/* this must be last */
d552 1
a552 1
  
d554 1
a554 1
  
d558 1
a558 1
  
d560 2
a561 2
  
  
d567 1
a567 1
  
d574 1
a574 1
    ((*obj_cmd_info[cmd].command_pointer) 
d581 3
d667 1
a667 1
 * Added to the comment header 
@


1.24
log
@Removed unnecessary function declaration.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.23 2008/01/29 21:02:31 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/29 21:02:31 $                                           *
 *  $Revision: 1.23 $                                                       *
d467 1
a467 1
		CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
d556 3
@


1.23
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.22 2008/01/18 20:30:11 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/18 20:30:11 $                                           *
 *  $Revision: 1.22 $                                                       *
a31 1
void die(struct char_data * ch, struct char_data *killer);
d556 4
@


1.22
log
@Fixing some send_to_char strings that don't end with a newline.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.21 2008/01/17 19:23:07 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/17 19:23:07 $                                           *
 *  $Revision: 1.21 $                                                       *
a28 3
extern struct room_data *world;
extern struct index_data *obj_index;

d557 3
@


1.21
log
@The find_obj_target_room function now accepts a room UID, and
is used by oteleport.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.20 2008/01/10 05:39:43 myc Exp myc $
d8 2
a9 2
 *  $Date: 2008/01/10 05:39:43 $                                           *
 *  $Revision: 1.20 $                                                       *
d413 1
a413 1
      send_to_char("Being a god, you don't need healing.", ch);
d442 2
a443 2
    if (GET_LEVEL(ch)>=LVL_IMMORT) {
      send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.", ch);
d560 4
@


1.20
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.19 2007/08/30 19:42:46 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2007/08/30 19:42:46 $                                           *
 *  $Revision: 1.19 $                                                       *
d37 1
a87 1
  int tmp;
d98 10
a107 18
  if (isdigit(*roomstr) && !strchr(roomstr, '.'))
    {
      tmp = atoi(roomstr);
      if ((location = real_room(tmp)) < 0)
	return NOWHERE;
    }
  
  else if ((target_mob = get_char_by_obj(obj, roomstr)))
    location = IN_ROOM(target_mob);
  else if ((target_obj = get_obj_by_obj(obj, roomstr)))
    {
      if (target_obj->in_room != NOWHERE)
	location = target_obj->in_room;
      else 
	return NOWHERE;
    }
  else
    return NOWHERE;
d109 1
a109 1
  /* a room has been found.  Check for permission */
a110 3
#ifdef ROOM_IMPROOM
      ROOM_FLAGGED(location, ROOM_IMPROOM) ||
#endif
d314 4
a317 5
  if (!*arg1 || !*arg2)
    {
      obj_log(obj, t, "oteleport called with too few args");
      return;
    }
d324 4
a327 5
  else if (!str_cmp(arg1, "all"))
    {
      rm = obj_room(obj);
      if (target == rm)
	obj_log(obj, t, "oteleport target is itself");
d329 5
a333 8
      for (ch = world[rm].people; ch; ch = next_ch)
	{
	  next_ch = ch->next_in_room;
	  
     dismount_char(ch);
	  char_from_room(ch);
	  char_to_room(ch, target);
	}
d335 1
d337 2
a338 4
  else
    {
      if ((ch = get_char_by_obj(obj, arg1)))
	{
d340 2
a341 6
	  char_from_room(ch);
	  char_to_room(ch, target);
	}
      
      else
	obj_log(obj, t, "oteleport: no target found");
d343 3
d560 4
@


1.19
log
@Cause *purge dg script commands to destroy all of a mobile's inventory
and equipment when purging mobs.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.18 2007/05/11 19:34:15 myc Exp jps $
d7 3
a9 3
 *  $Author: myc $                                                         *
 *  $Date: 2007/05/11 19:34:15 $                                           *
 *  $Revision: 1.18 $                                                       *
d464 1
a464 1
    alter_hit(ch, dam, 2);
d578 4
@


1.18
log
@Modified the quest command functions so they are thin wrappers for
perform_quest() in quest.c.  Error handling and messages should be
much better now.  Advance and rewind now accept another argument
specifying how many stages to advance or rewind.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.17 2007/04/17 23:59:16 myc Exp myc $
d8 2
a9 2
 *  $Date: 2007/04/17 23:59:16 $                                           *
 *  $Revision: 1.17 $                                                       *
d283 1
a283 1
		extract_char(ch);
d313 1
a313 1
  extract_char(ch);
d578 6
@


1.17
log
@New trigger type: Load.  It goes off any time a mobile is loaded, whether
it be god command, zone command, or trigger command.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.16 2006/11/14 20:41:49 jps Exp myc $
d7 3
a9 3
 *  $Author: jps $                                                         *
 *  $Date: 2006/11/14 20:41:49 $                                           *
 *  $Revision: 1.16 $                                                       *
d515 1
a515 97
  char arg[MAX_INPUT_LENGTH];
  char qcmd[12];	/*longest command is complete (8chars)*/
  char * qname;
  char subclass[25];
  char variable[21];
  char value[21]; 

  struct char_data * vict;
  int retc;
  extern struct char_data *character_list;

  argument = one_argument(argument, qcmd);
  if (strlen(qcmd) == 0)
	  return;

  argument = one_argument(argument,arg);
  if (strlen(arg) == 0)
	  return;
  CREATE(qname,char,strlen(arg) +1);
  sprintf(qname,"%s",arg);
  argument = one_argument(argument,arg);
  if (strlen(arg) == 0)
  {
	  free(qname);
	  return;
  }

  /*
   * need to find the person this command is goig to affect
   */
  for (vict = character_list; vict; vict = vict->next)
    if (!IS_NPC(vict) && !str_cmp(vict->player.name, arg))
	    break;
  if (vict)	/* if we ran out of chars then vict is null*/
  {
	  /* based on command, run the appropriate procedure */
	  if (!strn_cmp(qcmd,"complete",strlen(qcmd)))
		  retc = quest_complete(qname,vict);
	  else if (!strn_cmp(qcmd,"fail",strlen(qcmd)))
		  retc = quest_fail(qname,vict);
	  else if (!strn_cmp(qcmd,"variable", strlen(qcmd)))
	    {
	      argument = one_argument(argument, variable);
              argument = one_argument(argument, value);
              retc = set_quest_variable(qname, vict, variable, value);
	    }
	  
	  else if (!strn_cmp(qcmd,"start",strlen(qcmd)))
	  {
		  argument = one_argument(argument,subclass);
		  retc = quest_start(qname,vict,subclass);
		  if (retc < 1)
		  {
			  switch (retc)
			  {
			  case -3:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to start second subclass quest for %s",obj->short_description,GET_OBJ_VNUM(obj),GET_NAME(vict));
				  mudlog(buf ,NRM, LVL_GOD, TRUE);
				  break;
			  case -4:
				  sprintf(buf,"QUEST ERROR:Attempt by %s(%d) to start subclass with bad start or dest class in quest %s",obj->short_description,GET_OBJ_VNUM(obj),qname);
				  mudlog(buf, NRM, LVL_GOD, TRUE);
				  break;
			  case -7:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to start subclass quest without specifying subclass",obj->short_description,GET_OBJ_VNUM(obj));
				  mudlog(buf,NRM,LVL_GOD, TRUE);
				  break;
			  }
		  }
	  }
	  else if (!strn_cmp(qcmd,"advance",strlen(qcmd)))
	  {
		  retc = quest_advance(qname,vict);
		  if (retc < 0)
		  {
			  switch (retc)
			  {
				  /* note: only send to char if quest starter was a mob*/
			  case -1:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to advance from final stage in quest %s\r\n",obj->short_description,GET_OBJ_VNUM(obj),qname);
				  mudlog(buf,NRM,LVL_GOD,TRUE);
				  break;
			  case -2:
				  sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to advance failed quest %s\n",obj->short_description,GET_OBJ_VNUM(obj),qname);
				  mudlog(buf ,NRM, LVL_GOD, TRUE);
				  break;
			  }
		  }
	  }
	  else
	  {
		free(qname);
	  	return;
	  }
  }

  free(qname);
d578 4
@


1.16
log
@Make trap damage regenerate normally.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.15 2006/11/12 02:31:01 jps Exp jps $
d8 2
a9 2
 *  $Date: 2006/11/12 02:31:01 $                                           *
 *  $Revision: 1.15 $                                                       *
d396 1
d674 3
@


1.15
log
@You become unmounted when magically moved to another room.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.14 2003/07/29 03:36:42 rsd Exp jps $
d7 3
a9 3
 *  $Author: rsd $                                                         *
 *  $Date: 2003/07/29 03:36:42 $                                           *
 *  $Revision: 1.14 $                                                       *
d463 1
a463 1
    GET_HIT(ch) -= dam;
d673 3
@


1.14
log
@added (TRG) to the logging output of the log command
for ease of parsing.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.13 2003/07/24 22:22:30 jjl Exp $
d7 3
a9 3
 *  $Author: jjl $                                                         *
 *  $Date: 2003/07/24 22:22:30 $                                           *
 *  $Revision: 1.13 $                                                       *
d36 2
d346 1
d356 1
d673 4
@


1.13
log
@Added the "log" command for mob, room, and object triggers.  Spits
whatever you want into the log.
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.12 2002/09/19 01:07:53 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/19 01:07:53 $                                           *
 *  $Revision: 1.12 $                                                       *
d61 1
a61 1
  sprintf(buf, "(object %d): %s", GET_OBJ_VNUM(obj), msg);
d669 4
@


1.12
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.11 2002/09/13 02:32:10 jjl Exp $
d8 2
a9 2
 *  $Date: 2002/09/13 02:32:10 $                                           *
 *  $Revision: 1.11 $                                                       *
d609 4
d620 1
a620 1
  { "oload"	   , do_dgoload	 , 0 },
d624 4
a627 4
  { "odamage"    , do_odamage,   0 },
  { "oheal"    , do_oheal,   0 },
  { "quest"	,do_obj_quest, 0},
  
d669 3
@


1.11
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_objcmd.c,v 1.10 2001/07/25 06:59:02 mtp Exp $
d7 3
a9 3
 *  $Author: mtp $                                                         *
 *  $Date: 2001/07/25 06:59:02 $                                           *
 *  $Revision: 1.10 $                                                       *
d514 3
d550 7
d665 3
@


1.10
log
@modified logging to hopefully be a bit more helpful by specifying the
trigger id wherever possible. This does not apply to logging of mob trigs yet
as mobs use the same commands as players :-(
@
text
@d1 3
a3 1
// $Id: dg_objcmd.c,v 1.8 2000/11/22 23:15:13 mtp Exp $
d8 2
a9 2
 *  $Date: 2000/11/22 23:15:13 $                                           *
 *  $Revision: 1.8 $                                                       *
d653 40
a692 33
// $Log: dg_objcmd.c,v $
// Revision 1.9  2001/06/19 23:46:52  mtp
// improved quest error messages
//
// Revision 1.8  2000/11/22 23:15:13  mtp
// added ability to use quest command in here
//
// Revision 1.7  2000/11/21 03:44:47  rsd
// Altered the comment header slightly and added the back
// rlog messages from prior to the addition of then $log$
// string.
//
// Revision 1.6  2000/03/27 22:16:48  mtp
// added oheal which wasnt there before for some reason
//
// Revision 1.5  2000/02/01 21:04:42  mtp
// fixed oforce command so that it takes a line instead of
// just a second word
//
// Revision 1.4  1999/10/30 15:30:42  rsd
// Jimmy coded alignment restrictions for paladins and exp
// altered gain_exp() to reference the victim.
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 00:53:55  mud
// Added to the comment header 
// Indented file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.9
log
@improved quest error messages
@
text
@d36 1
a36 1
   void (name)(obj_data *obj, char *argument, int cmd, int subcmd)
d41 1
a41 1
  void	(*command_pointer)(obj_data *obj, char *argument, int cmd, int subcmd);
d53 1
a53 1
void obj_log(obj_data *obj, char *msg)
d57 1
a57 1
  void script_log(char *msg);
d59 2
a60 3
  sprintf(buf, "Obj (%s, VNum %d): %s",
	  obj->short_description, GET_OBJ_VNUM(obj), msg);
  script_log(buf);
d139 1
a139 1
    obj_log(obj, "oecho called with no args");
d148 1
a148 1
    obj_log(obj, "oecho called by object in NOWHERE");
d166 1
a166 1
      obj_log(obj, "oforce called with too few args");
d173 1
a173 1
	obj_log(obj, "oforce called by object in NOWHERE");
d199 1
a199 1
	obj_log(obj, "oforce: no target found");
d213 1
a213 1
      obj_log(obj, "osend called with no args");
d221 1
a221 1
      obj_log(obj, "osend called without a message");
d234 1
a234 1
    obj_log(obj, "no target found for osend");
d247 1
a247 1
      obj_log(obj, "oexp: too few arguments");
d255 1
a255 1
      obj_log(obj, "oexp: target not found");
d298 1
a298 1
	obj_log(obj, "opurge: bad argument");
d305 1
a305 1
      obj_log(obj, "opurge: purging a PC");
d323 1
a323 1
      obj_log(obj, "oteleport called with too few args");
d330 1
a330 1
    obj_log(obj, "oteleport target is an invalid room");
d336 1
a336 1
	obj_log(obj, "oteleport target is itself");
d356 1
a356 1
	obj_log(obj, "oteleport: no target found");
d372 1
a372 1
      obj_log(obj, "oload: bad syntax");
d378 1
a378 1
      obj_log(obj, "oload: object in NOWHERE trying to load");
d386 1
a386 1
	  obj_log(obj, "oload: bad mob vnum");
d396 1
a396 1
	  obj_log(obj, "oload: bad object vnum");
d404 1
a404 1
    obj_log(obj, "oload: bad type");
d416 1
a416 1
    obj_log(obj, "oheal: bad syntax");
d435 1
a435 1
    obj_log(obj, "oheal: target not found");
d446 1
a446 1
    obj_log(obj, "odamage: bad syntax");
d496 1
a496 1
    obj_log(obj, "odamage: target not found");
d620 1
a620 1
void obj_command_interpreter(obj_data *obj, char *argument)
d643 1
a643 1
      obj_log(obj, buf2);
d647 1
a647 1
     (obj, line, cmd, obj_cmd_info[cmd].subcmd));
d652 3
@


1.8
log
@added ability to use quest command in here
@
text
@d1 1
a1 1
// $Id: dg_objcmd.c,v 1.7 2000/11/21 03:44:47 rsd Exp $
d5 3
a7 3
 *  $Author: rsd $                                                         *
 *  $Date: 2000/11/21 03:44:47 $                                           *
 *  $Revision: 1.7 $                                                       *
d550 18
d570 1
d572 16
d653 3
@


1.7
log
@Altered the comment header slightly and added the back
rlog messages from prior to the addition of then $log$
string.
@
text
@d1 1
a1 1
// $Id: dg_objcmd.c,v 1.6 2000/03/27 22:16:48 mtp Exp $
d5 3
a7 3
 *  $Author: mtp $                                                         *
 *  $Date: 2000/03/27 22:16:48 $                                           *
 *  $Revision: 1.6 $                                                       *
d25 1
d500 63
d576 1
d618 5
@


1.6
log
@added oheal which wasnt there before for some reason
@
text
@d1 1
a1 1
// $Id: dg_objcmd.c,v 1.5 2000/02/01 21:04:42 mtp Exp $
d4 6
a9 2
 *  Usage: contains the command_interpreter for objects,                   *
 *         object commands.                                                *
d11 1
a11 4
 *  By: Someone of HubisMUD Maybe                                          *
 *  $Author: mtp $                                                         *
 *  $Date: 2000/02/01 21:04:42 $                                           *
 *  $Revision: 1.5 $                                                       *
d553 3
d566 7
@


1.5
log
@fixed oforce command so that it takes a line instead of
just a second word
@
text
@d1 1
a1 1
// $Id: dg_objcmd.c,v 1.4 1999/10/30 15:30:42 rsd Exp mtp $
d8 3
a10 3
 *  $Author: rsd $                                                         *
 *  $Date: 1999/10/30 15:30:42 $                                           *
 *  $Revision: 1.4 $                                                       *
d407 30
d510 1
d552 4
@


1.4
log
@Jimmy coded alignment restrictions for paladins and exp
altered gain_exp() to reference the victim.
@
text
@d1 1
a1 1
// $Id: dg_objcmd.c,v 1.3 1999/09/05 07:00:39 jimmy Exp $
d8 3
a10 3
 *  $Author: jimmy $                                                         *
 *  $Date: 1999/09/05 07:00:39 $                                           *
 *  $Revision: 1.3 $                                                       *
d157 5
a161 1
  two_arguments(argument, arg1, arg2);
d521 4
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d8 3
a10 3
 *  $Author: mud $                                                         *
 *  $Date: 1999/01/31 00:53:55 $                                           *
 *  $Revision: 1.2 $                                                       *
d247 1
a247 1
    gain_exp(ch, atoi(amount));
d516 4
a519 1
// $Log$
@


1.2
log
@Added to the comment header 
Indented file
@
text
@d1 1
d9 2
a10 2
 *  $Date: 1999/01/29 01:23:30 $                                           *
 *  $Revision: 1.1 $                                                       *
d516 1
@


1.1
log
@Initial revision
@
text
@d1 10
a10 10
/**************************************************************************
*  File: objcmd.c                                                         *
*  Usage: contains the command_interpreter for objects,                   *
*         object commands.                                                *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/04 23:10:16 $
*  $Revision: 3.8 $
**************************************************************************/
a14 1

d37 3
a39 3
   char *command;
   void	(*command_pointer)(obj_data *obj, char *argument, int cmd, int subcmd);
   int	subcmd;
d52 7
a58 7
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Obj (%s, VNum %d): %s",
	    obj->short_description, GET_OBJ_VNUM(obj), msg);
    script_log(buf);
d65 10
a74 10
    if (obj->in_room != NOWHERE)
	return obj->in_room;
    else if (obj->carried_by)
	return IN_ROOM(obj->carried_by);
    else if (obj->worn_by)
	return IN_ROOM(obj->worn_by);
    else if (obj->in_obj)
	return obj_room(obj->in_obj);
    else
	return NOWHERE;
d81 15
a95 9
    int tmp;
    int location;
    char_data *target_mob;
    obj_data *target_obj;
    char roomstr[MAX_INPUT_LENGTH];

    one_argument(rawroomstr, roomstr);

    if (!*roomstr)
a96 6

    if (isdigit(*roomstr) && !strchr(roomstr, '.'))
    {
	tmp = atoi(roomstr);
	if ((location = real_room(tmp)) < 0)
	    return NOWHERE;
d98 9
a106 9

    else if ((target_mob = get_char_by_obj(obj, roomstr)))
	location = IN_ROOM(target_mob);
    else if ((target_obj = get_obj_by_obj(obj, roomstr)))
    {
	if (target_obj->in_room != NOWHERE)
	    location = target_obj->in_room;
	else 
	    return NOWHERE;
d108 2
a109 2
    else
	return NOWHERE;
d111 2
a112 2
    /* a room has been found.  Check for permission */
    if (ROOM_FLAGGED(location, ROOM_GODROOM) || 
d114 1
a114 1
	ROOM_FLAGGED(location, ROOM_IMPROOM) ||
d116 8
a123 8
	ROOM_FLAGGED(location, ROOM_HOUSE))
	return NOWHERE;

    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room)
	return NOWHERE;

    return location;
d132 6
a137 3
    int room;

    skip_spaces(&argument);
d139 1
a139 4
    if (!*argument) 
	obj_log(obj, "oecho called with no args");

    else if ((room = obj_room(obj)) != NOWHERE)
d141 2
a142 2
    	if (world[room].people)
	    sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
d145 2
a146 2
    else
	obj_log(obj, "oecho called by object in NOWHERE");
d152 3
a154 3
    char_data *ch, *next_ch;
    int room;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
d156 1
a156 1
    two_arguments(argument, arg1, arg2);
d158 1
a158 1
    if (!*arg1 || !arg2)
d160 2
a161 2
	obj_log(obj, "oforce called with too few args");
	return;
d164 1
a164 1
    if (!str_cmp(arg1, "all"))
d166 3
a168 3
	if ((room = obj_room(obj)) == NOWHERE) 
	    obj_log(obj, "oforce called by object in NOWHERE");
	else
d170 1
a170 1
	    for (ch = world[room].people; ch; ch = next_ch)
d172 3
a174 3
		next_ch = ch->next_in_room;
	
		if (GET_LEVEL(ch)<LVL_IMMORT)
d176 1
a176 1
		    command_interpreter(ch, arg2);
d182 1
a182 1
    else
d184 1
a184 1
	if ((ch = get_char_by_obj(obj, arg1)))
d186 1
a186 1
	    if (GET_LEVEL(ch)<LVL_IMMORT)
d188 1
a188 1
		command_interpreter(ch, arg2);
d191 3
a193 3
    
	else
	    obj_log(obj, "oforce: no target found");
d200 4
a203 2
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
d205 1
a205 3
    msg = any_one_arg(argument, buf);

    if (!*buf)
d207 2
a208 2
	obj_log(obj, "osend called with no args");
	return;
d210 4
a213 4

    skip_spaces(&msg);

    if (!*msg)
d215 2
a216 2
	obj_log(obj, "osend called without a message");
	return;
d218 2
a219 2

    if ((ch = get_char_by_obj(obj, buf)))
d221 4
a224 4
	if (subcmd == SCMD_OSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_OECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
d226 3
a228 3

    else
	obj_log(obj, "no target found for osend");
d234 6
a239 6
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount)
d241 2
a242 2
	obj_log(obj, "oexp: too few arguments");
	return;
d244 4
a247 4
    
    if ((ch = get_char_by_obj(obj, name))) 
	gain_exp(ch, atoi(amount));
    else
d249 2
a250 2
	obj_log(obj, "oexp: target not found");
	return;
d258 6
a263 6
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *o, *next_obj;
    int rm;

    one_argument(argument, arg);
d265 1
a265 1
    if (!*arg)
d267 1
a267 1
	if ((rm = obj_room(obj)) != NOWHERE)
d269 1
a269 1
	    for (ch = world[rm].people; ch; ch = next_ch )
d271 3
a273 3
		next_ch = ch->next_in_room;
		if (IS_NPC(ch))
		    extract_char(ch);
d275 2
a276 2
    
	    for (o = world[rm].contents; o; o = next_obj )
d278 3
a280 3
		next_obj = o->next_content;
		if (o != obj)
		    extract_obj(o);
d283 2
a284 2
    
	return;
d287 1
a287 1
    if (!(ch = get_char_by_obj(obj, arg)))
d289 6
a294 6
	if ((o = get_obj_by_obj(obj, arg)))
	    extract_obj(o);
	else 
	    obj_log(obj, "opurge: bad argument");
    
	return;
d297 1
a297 1
    if (!IS_NPC(ch))
d299 2
a300 2
	obj_log(obj, "opurge: purging a PC");
	return;
d303 1
a303 1
    extract_char(ch);
d309 5
a313 5
    char_data *ch, *next_ch;
    int target, rm;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
d315 1
a315 1
    if (!*arg1 || !*arg2)
d317 2
a318 2
	obj_log(obj, "oteleport called with too few args");
	return;
a319 2

    target = find_obj_target_room(obj, arg2);
d321 4
a324 2
    if (target == NOWHERE) 
	obj_log(obj, "oteleport target is an invalid room");
d326 1
a326 1
    else if (!str_cmp(arg1, "all"))
d328 5
a332 5
	rm = obj_room(obj);
	if (target == rm)
	    obj_log(obj, "oteleport target is itself");

	for (ch = world[rm].people; ch; ch = next_ch)
d334 4
a337 4
	    next_ch = ch->next_in_room;
	    
	    char_from_room(ch);
	    char_to_room(ch, target);
d341 1
a341 1
    else
d343 1
a343 1
	if ((ch = get_char_by_obj(obj, arg1)))
d345 2
a346 2
	    char_from_room(ch);
	    char_to_room(ch, target);
d348 3
a350 3
    
	else
	    obj_log(obj, "oteleport: no target found");
d357 8
a364 8
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0, room;
    char_data *mob;
    obj_data *object;

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0))
d366 2
a367 2
        obj_log(obj, "oload: bad syntax");
        return;
d369 2
a370 2
 
    if ((room = obj_room(obj)) == NOWHERE)
d372 2
a373 2
        obj_log(obj, "oload: object in NOWHERE trying to load");
        return;
d375 2
a376 2
    
    if (is_abbrev(arg1, "mob"))
d378 1
a378 1
        if ((mob = read_mobile(number, VIRTUAL)) == NULL)
d380 2
a381 2
            obj_log(obj, "oload: bad mob vnum");
            return;
d383 1
a383 1
        char_to_room(mob, room);
d385 2
a386 2
     
    else if (is_abbrev(arg1, "obj"))
d388 1
a388 1
        if ((object = read_object(number, VIRTUAL)) == NULL)
d390 2
a391 2
            obj_log(obj, "oload: bad object vnum");
            return;
d393 2
a394 2

        obj_to_room(object, room);
d396 4
a399 4
         
    else
        obj_log(obj, "oload: bad type");

d403 58
a460 58
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	obj_log(obj, "odamage: bad syntax");
	return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_obj(obj, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.", ch);
	    return;
	}
	GET_HIT(ch) -= dam;
	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
       	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
	    }
    	    die(ch, NULL);
	}
    }
    else
	obj_log(obj, "odamage: target not found");
d464 13
a476 13
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

    { "oecho"      , do_oecho    , 0 },
    { "oechoaround", do_osend    , SCMD_OECHOAROUND },
    { "oexp"       , do_oexp     , 0 },
    { "oforce"     , do_oforce   , 0 },
    { "oload"	   , do_dgoload	 , 0 },
    { "opurge"     , do_opurge   , 0 },
    { "osend"      , do_osend    , SCMD_OSEND },
    { "oteleport"  , do_oteleport, 0 },
    { "odamage"    , do_odamage,   0 },
    
    { "\n", 0, 0 }	/* this must be last */
d486 10
a495 2
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
a496 1
    skip_spaces(&argument);
d498 5
a502 12
    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg),cmd = 0;
	 *obj_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(obj_cmd_info[cmd].command, arg, length))
	    break;
d504 1
a504 1
    if (*obj_cmd_info[cmd].command == '\n')
d506 2
a507 2
	sprintf(buf2, "Unknown object cmd: '%s'", argument);
	obj_log(obj, buf2);
d509 3
a511 3
    else
	((*obj_cmd_info[cmd].command_pointer) 
	 (obj, line, cmd, obj_cmd_info[cmd].subcmd));
d513 2
@
