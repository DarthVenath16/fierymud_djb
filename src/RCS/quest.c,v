head	1.54;
access;
symbols;
locks; strict;
comment	@ * @;


1.54
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.20.19.53.47;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.29.21.16.41;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.29.21.14.37;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.10.20.24.23;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.10.20.19.19;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.10.19.43.38;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.18.01.28.57;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.05.20.33.05;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.25.00.10.41;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.05.01.49.05;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.12.02.24.57;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.28.16.53.38;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.28.07.20.37;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.21.02.24.36;	author myc;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.11.19.34.15;	author myc;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.28.19.55.01;	author cjd;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.06.20.31.18;	author jjl;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.17.15.43.33;	author rls;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.08.17.47.40;	author mtp;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.19.23.22.25;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.01.21.59.31;	author mtp;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.12.23.26.43;	author mtp;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.12.01.29.06;	author mtp;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.03.00.56.51;	author mtp;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.22.01.51.17;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.19.00.51.26;	author rsd;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.19.00.39.59;	author rsd;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.19.00.26.58;	author rsd;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.19.00.24.24;	author rsd;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.15.00.30.19;	author mtp;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.15.00.25.18;	author mtp;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.07.02.00.24;	author mtp;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.07.01.59.00;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.07.01.49.37;	author mtp;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.03.05.37.17;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.31.23.26.43;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.27.00.08.07;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.03.42.04;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/*++
*******************************************************************
*
* Filename: Quest.c
*
* Purpose:  Implements load_quest and related functions to provide
*           (automated) run-time loading of quest mobs and objects
*           as well as provide a method for instantly connecting
*           quest zones to the world
*
* Author:   Fingh @@ Hubis
*
* Last Modified:[11/10/98] initial version
*******************************************************************
--*/
#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "db.h"
#include "utils.h"
#include "handler.h"

/*++
 * Quests. Why? To encourage roleplaying and establish Hubis as a
 * persistent world, rather than just a static place to go hack and slash.
 * What about mogprogs?  Well, mobprogs certainly handle the majority of
 * the work in our quests, however one fundamental element missing from
 * a mobprog is the ability to load itself at runtime, without the
 * intervention of an imm.  With quests, we can connect a zone to the mud,
 * add quest mobiles and objects to any zone in the world, all at
 * run-time.
--*/


#define QFLEN 8     // filename length, i.e. ddd.qst + null

extern struct room_data *world;

// function declarations
void load_quest(int number);
int parse_quest_file(FILE *quest_file);
void connect_rooms(int existing, int connection, int dir);
void loadquestMob(int mob_vnum, int room);
void loadquestObj(int objnum, int flag, int where);


// load the quest from the file by number
void load_quest(int number)
{
  FILE *quest_file;
  char quest_file_name[QFLEN];

  memset(quest_file_name, 0, QFLEN);
  sprintf(quest_file_name, "%s/%d.qst", QST_PREFIX, number);

  if (!(quest_file = fopen(quest_file_name, "r")))
  {
     mudlog("SYSERR: attempting to load non-existant quest", BRF, LVL_BUILDER, TRUE);
     return;
  }

  if (!parse_quest_file(quest_file))
  {
     mudlog("SYSERR: Quest NOT loaded", BRF, LVL_BUILDER, TRUE);
     return;
  }
} // end load_quest()


int parse_quest_file(FILE * file)
{
  char line[256];       // longest line allowed in most editors
  int  value[3];       // there are three values for EVERY actor type
  char actor_type;

  for(;;)
  {
    get_line(file, line);

    // watch for end of file marker
    if(*line == '$')
      return FALSE;

    // catch unexpected end of file
    if(feof(file))
    {
      mudlog("SYSERR: Unexpected EOF in file.", BRF, LVL_BUILDER, TRUE);
      return FALSE;
    }

    // read the actor data....all types have same format in file
    if(sscanf(line, "%c %d %d %d", &actor_type, &value[0], &value[1], &value[2]) != 4)
    {
      mudlog("SYSERR: Invalid read in quest file.", BRF, LVL_BUILDER, TRUE);
      return FALSE;
    }

    switch(actor_type)
    {
    case 'c':
    case 'C':
      connect_rooms(value[0], value[1], value[2]);
      break;
    case 'm':
    case 'M':
      loadquestMob(value[0], value[1]);
      break;
    case 'o':
    case 'O':
      loadquestObj(value[0], value[1], value[2]);
      break;
    default:
      mudlog("SYSERR: Garbage data in quest file.", BRF, LVL_BUILDER, TRUE);
      return FALSE;
    }
  }

  return TRUE;
}


void connect_rooms(int existing, int connection, int dir)
{
  int opposite_dir = -1;

  world[real_room(existing)].dir_options[dir] = real_room[connection];
  world[real_room(connection)].dir_options[(dir + 2) % 4] = real_room[existing];
}


void loadquestMob(int mob_vnum, int room)
{
  struct char_data *mob;

  mob = read_mobile(mob_vnum, VIRTUAL);
  char_to_room(mob,  real_room(room));
}


void loadquestObj(int objnum, int flag, int where)
{
  struct obj_data *obj;
  struct char_data *target;

  obj = read_object(objnum, VIRTUAL);

  if(flag)
  {
    target = read_mobile(where, VIRTUAL);
    obj_to_char(obj, target);
  }
  else
  {
    obj_to_room(obj, real_room(where));
  }
}
@


1.54
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@/***************************************************************************
 * $Id: quest.c,v 1.53 2010/06/20 19:53:47 mud Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: quest.c                                        Part of FieryMUD *
 *  Usage: Implementation of routines for handling quests                  *
 *     By: Matt Proctor 22 Oct 2000                                        *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 2000 by the Fiery Consortium                    *
 ***************************************************************************/

#define __QUEST_C__

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "db.h"
#include "utils.h"
#include "handler.h"
#include "interpreter.h"
#include "comm.h"
#include "casting.h"
#include "quest.h"
#include "dg_scripts.h"
#include "races.h"
#include "chars.h"
#include "class.h"
#include "math.h"

/* Local functions */
struct quest_list *quest_find_char(struct char_data *ch, char *qname);

/* Quest defines */
int max_quests = 0;
struct quest_info *all_quests = NULL;


void boot_quests()
{
  FILE *fl;
  char line[256];
  char *quest_name;
  int quest_num, max_stages, num_records = 0;

  max_quests = 0;

  if ((fl = fopen(ALL_QUEST_FILE, "r")) == NULL) {
    fprintf(stderr, "Unable to find any quest data file (non-fatal)\r\n");
    return;
  }

  while (get_line(fl, line))
    ++num_records;

  fclose(fl);

  CREATE(all_quests, struct quest_info, num_records);

  fl = fopen(ALL_QUEST_FILE, "r");
  while (get_line(fl, line)) {
    CREATE(quest_name, char, 30);
    if (sscanf(line, "%s %d %d", quest_name, &quest_num, &max_stages) != 3) {
      fprintf(stderr, "Error in quest file line format (%s)\n", line);
      free(quest_name);
      break;
    }
    else {
      all_quests[max_quests].quest_name = quest_name;
      all_quests[max_quests].quest_id = quest_num;
      all_quests[max_quests].maxstages = max_stages;
      ++max_quests;
    }
  }
  fclose(fl);

}

/* quest_stat - returns true if any stat info was listed */
bool quest_stat(struct char_data *ch, struct char_data *vict, char *qname)
{
   struct quest_list* quest = quest_find_char(vict, qname);
   struct quest_var_list* vars;
   int qid_num;

   if (!quest) return FALSE;

   if ((qid_num = real_quest(quest->quest_id)) >=0) {
      sprintf(buf,"Quest %s: ",all_quests[qid_num].quest_name);
      if (quest->stage == QUEST_SUCCESS)
         strcat(buf,"Completed\r\n");
      else if (quest->stage == QUEST_FAILURE)
         strcat(buf,"Failed\r\n");
      else {
         sprintf(buf2,"Stage %d\r\n",quest->stage);
         strcat(buf,buf2);
      }
      send_to_char(buf,ch);
      for (vars = quest->variables; vars; vars = vars->next) {
         sprintf(buf, "\t%s = %s\r\n", vars->var, vars->val);
         send_to_char(buf, ch);
      }
   } else {
      sprintf(buf, "Invalid quest: %s\r\n", qname);
      send_to_char(buf, ch);
   }

   return TRUE;
}

void quest_mstat(struct char_data *ch, struct char_data *vict)
{
   int qnum;
   bool any = FALSE;

   for (qnum = 0; qnum < max_quests; qnum++)
      if (quest_stat(ch, vict, all_quests[qnum].quest_name))
         any = TRUE;

   if (!any)
      send_to_char("No quest data found.\r\n", ch);
}

struct char_data *quest_id_char(struct trig_data *t, struct char_data *ch, char *name)
{
   struct char_data *vict;

   if (!(vict = find_char_for_keyword(ch, name)))
      vict = find_char_in_world(find_by_name(name));
   if (vict && IS_NPC(vict))
      vict = NULL;
   if (!vict) {
      if (t)
         mprintf(L_WARN, LVL_GOD, "QUEST ERROR: quest command couldn't "
                "find player %s in trigger %d", name, GET_TRIG_VNUM(t));
      else if (ch)
         send_to_char("There's no player by that name here.\r\n", ch);
      return NULL;
   }
   return vict;
}

ACMD(do_qstat)
{
   struct char_data *vict;
   char *quest_name;

   argument = any_one_arg(argument, arg);   /* player name */
   argument = any_one_arg(argument, buf1);  /* quest */

   if (!*arg) {
      send_to_char("Usage: qstat <player> [<quest>]\r\n", ch);
      return;
   }

   if (!(vict = quest_id_char(NULL, ch, arg)))
      return;

   if (*buf1) {
      /* Two arguments: a specific quest */

      /* Try and figure out which quest we want. */
      if (!(quest_name = check_quest_name(buf1))) {
         send_to_char("That is not a valid quest name.\r\n", ch);
         return;
      }
      if (!quest_stat(ch, vict, quest_name)) {
         send_to_char("No quest data was found.\r\n", ch);
      }
   } else {
      /* One argument: display all quests for this player */
      quest_mstat(ch, vict);
   }
}

void perform_quest(struct trig_data *t, char *argument, struct char_data *ch, struct obj_data *obj, struct room_data *room) {
  char error_string[MAX_INPUT_LENGTH * 2], *quest_name, e2[MAX_INPUT_LENGTH * 2];
  struct char_data *vict;
  int amount;

  skip_spaces(&argument);
  argument = any_one_arg(argument, arg);	/* command */
  argument = any_one_arg(argument, buf1);	/* quest */
  argument = any_one_arg(argument, buf2);	/* player name */

  /* Check for the "mstat" command first, since it requires one fewer argument
   * than the rest of them.  This one can only be done by a character (not a trigger). */
  if (*arg && !strcmp(arg, "mstat") && ch) {
     if (*buf1) {
        /* OK: mstat command, buf1 = player name */
        if ((vict = quest_id_char(NULL, ch, buf1)))
          quest_mstat(ch, vict);
     } else {
       send_to_char("Usage: quest mstat <player>\r\n", ch);
     }
     return;
  }

  /* Make sure we have a quest command. */
  if (!*arg || !*buf1 || !*buf2) {
    if (t) {
      sprintf(buf, "QUEST ERROR: quest command called with less than 3 args by trigger %d", GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    else if (ch)
      send_to_char("Usage: quest <command> <quest> <player> [<subclass>] [<var name> <var value>]\r\n", ch);
    return;
  }

  /* Try and figure out which quest we want. */
  if (!(quest_name = check_quest_name(buf1))) {
    if (t) {
      sprintf(buf, "QUEST ERROR: quest command tried to access invalid quest %s in trigger %d", buf1, GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    else if (ch)
      send_to_char("That is not a valid quest name.\r\n", ch);
    return;
  }


  /* Try and figure out who we want to affect. */
  vict = quest_id_char(t, ch, buf2);
  if (!vict) return;

  /* At this point, we assume we have a valid quest_name and victim.  Now
     we just have to see if we have valid command.  But first, let's set
     up the standard error string. Also, we're done with buf1 and buf2
     so they can be reused. */

  /* Mob / deity error string */
  if (ch) {
    if (t)
      sprintf(error_string, "QUEST ERROR: %s (%d) tried to %%s "
              "[%s on quest %s in trigger %d]", GET_NAME(ch),
              GET_MOB_VNUM(ch), GET_NAME(vict), quest_name,
              GET_TRIG_VNUM(t));
    else
      sprintf(error_string, "QUEST_ERROR: %s tried to %%s "
              "[%s on quest %s]", GET_NAME(ch), GET_NAME(vict),
              quest_name);
  }
  /* Object trigger error string */
  else if (obj) {
    sprintf(error_string, "QUEST ERROR: %s (%d) tried to %%s "
            "[%s on quest %s in trigger %d]", obj->short_description,
            GET_OBJ_VNUM(obj), GET_NAME(vict), quest_name,
            GET_TRIG_VNUM(t));
  }
  /* Room trigger error string */
  else if (room) {
    sprintf(error_string, "QUEST ERROR: %s (%d) tried to %%s "
            "[%s on quest %s in trigger %d]", room->name, room->vnum,
            GET_NAME(vict), quest_name, GET_TRIG_VNUM(t));
  }
  /* Other error string */
  else {
    sprintf(error_string, "QUEST ERROR: unknown actor tried to %%s "
            "[%s on quest %s in trigger %d]", GET_NAME(vict), quest_name,
            GET_TRIG_VNUM(t));
  }

  /*
   * This is kind of a hack.  The quest_ subfunctions below use the ch
   * argument to decide whether to log an error or just send_to_char.
   * If ch is NULL, then it logs.  So to make sure we get errors logged
   * for mob triggers, we set ch to NULL if there's a trigger.
   */
  if (t)
    ch = NULL;

  /* advance
   *
   * Advances player <vict> by <amount> stages in the quest <quest_name>.
   * Defaults to 1 stage.
   */
  if (!strncmp(arg, "advance", strlen(arg))) {
    argument = any_one_arg(argument, buf1);
    amount = atoi(buf1);
    if (!amount && !*buf1) /* If no amount given, then advance by 1. */
      amount = 1;
    quest_advance(ch, vict, quest_name, error_string, amount);
  }

  /* start
   *
   * Start player <vict> on the quest <quest_name>.
   */
  else if (!strncmp(arg, "start", strlen(arg))) {
    argument = any_one_arg(argument, buf1);
    quest_start(ch, vict, quest_name, error_string, buf1);
  }

  /* variable
   *
   * Set quest variable <buf1> to value <buf2> on player <vict> on the
   * quest <quest_name>, or check quest variable <buf1> on player <vict>
   * on the quest <quest_name>.
   */
  else if (!strncmp(arg, "variable", strlen(arg))) {
    argument = any_one_arg(argument, buf1);
    argument = any_one_arg(argument, buf2);
    if (ch && !*buf1)
      send_to_char("Which variable?\r\n", ch);
    else if (ch && !*buf2) {
      sprintf(buf, "Variable %s on %s for quest %s: %s\r\n",
              buf1, GET_NAME(vict), quest_name,
              get_quest_variable(vict, quest_name, buf1));
      send_to_char(buf, ch);
    }
    else if (*buf1 && *buf2)
      set_quest_variable(ch, vict, quest_name, error_string, buf1, buf2);
    else if (!*buf1) {
      sprintf(buf, error_string, "set variable with no variable");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    else if (!*buf2) {
      sprintf(e2, "set variable \"%s\" with no value", buf1);
      sprintf(buf, error_string, e2);
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
  }

  /* complete
   *
   * Sets quest <quest_name> to complete on player <vict>.
   */
  else if (!strncmp(arg, "complete", strlen(arg)))
    quest_complete(ch, vict, quest_name, error_string);

  /* fail
   *
   * Sets quest <quest_name> to failed on player <vict>.
   */
  else if (!strncmp(arg, "fail", strlen(arg)))
    quest_fail(ch, vict, quest_name, error_string);

  /* rewind
   *
   * Rewinds player <vict> by <amount> stages in the quest <quest_name>.
   * Defaults to 1 stage.
   */
  else if (!strncmp(arg, "rewind", strlen(arg))) {
    argument = any_one_arg(argument, buf1);
    amount = atoi(buf1);
    if (!amount && !*buf1) /* If no amount given, then rewind by 1. */
      amount = 1;
    quest_rewind(ch, vict, quest_name, error_string, amount);
  }

  /* restart
   *
   * Start player <vict> on the quest <quest_name> if they have already
   * started it.
   */
  else if (!strncmp(arg, "restart", strlen(arg)))
    quest_restart(ch, vict, quest_name, error_string);

  /* erase
   *
   * Erase quest <quest_name> on player <vict>.
   */
  else if (!strncmp(arg, "erase", strlen(arg)))
    quest_erase(ch, vict, quest_name, error_string);

  /* stage
   *
   * Shows stage for quest <quest_name> on player <vict>.
   */
  else if (ch && !strncmp(arg, "stage", strlen(arg))) {
      if (quest_find_char(vict, quest_name)) {
         amount = quest_stage(vict, quest_name);
         if (amount == QUEST_FAILURE)
            sprintf(buf, "%s has failed the %s quest.\r\n",
                  GET_NAME(vict), quest_name);
         else if (amount == QUEST_SUCCESS)
            sprintf(buf, "%s has completed the %s quest.\r\n",
                  GET_NAME(vict), quest_name);
         else
            sprintf(buf, "%s is on stage %d of the %s quest.\r\n",
                  GET_NAME(vict), amount, quest_name);
      } else {
         sprintf(buf, "%s has not started the %s quest.\r\n",
               GET_NAME(vict), quest_name);
      }
    send_to_char(buf, ch);
  }

  /* stat
   *
   * Shows variable data for a quest
   */
  else if (ch && !strcmp(arg, "stat")) {
     if (!quest_stat(ch, vict, quest_name)) {
        send_to_char("No quest data was found.\r\n", ch);
     }
  }

  else {
    if (t) {
      sprintf(buf, "use an invalid command %s", arg);
      sprintf(buf1, error_string, buf);
      mudlog(buf1, NRM, LVL_GOD, TRUE);
    }
    else if (ch) {
      sprintf(buf, "Sorry, %s is not a valid quest command.\r\n", arg);
      send_to_char(buf, ch);
    }
  }

}


/*
 * quest_find_num
 *
 * descr:	internal routine to return the quest_id for  a specified quest name
 * 		so that all quests can be referred to by names externally.
 *
 * NOTE:	uses strn_cmp so abbreviations of quest anmes are tolerated.
 */
unsigned short quest_find_num(char *qname)
{
  int count;
  /*
   * Loop through the quests and if we find the one we're looking for,
   * return its quest id.
   */
  for (count = 0; count < max_quests; count++) {
    if (!strn_cmp(all_quests[count].quest_name, qname, strlen(qname)))
      return all_quests[count].quest_id;
  }
  return 0;
}

/*
 * utility function for perform_quest.  Returns the full qualified name of
 * a quest based on an abbreviation.
 */
char *check_quest_name(char *qname) {
  int count;
  for (count = 0; count < max_quests; count++)
    if (!strn_cmp(all_quests[count].quest_name, qname, strlen(qname)))
      return all_quests[count].quest_name;
  return NULL;
}

/*
 * quest_find_max_stage
 *
 * Internal routine to find the maximum stage for a quest.
 */
short quest_find_max_stage(char *qname)
{
  int count = 0;

  for (count = 0; count < max_quests; count++)
    if (!strn_cmp(all_quests[count].quest_name, qname, strlen(qname)))
      return all_quests[count].maxstages;
  return 0;
}

/*
 * quest_find_char
 *
 * descr:	internal routine to find a quest in a quest_list
 */
struct quest_list *quest_find_char(struct char_data *ch, char *qname)
{
  struct quest_list *quest;
  int quest_num = quest_find_num(qname);

  for (quest = ch->quests; quest; quest = quest->next)
    if (quest->quest_id == quest_num)
      return quest;
  return NULL;
}

/*
 * get_quest_variable
 */
char* get_quest_variable(struct char_data *vict, char *qname, char *variable) {
  struct quest_list* quest = quest_find_char(vict, qname);
  struct quest_var_list* vars;

  if (!quest)
    return "0";

  for (vars = quest->variables; vars; vars = vars->next)
    if (!strcmp(variable, vars->var))
      return vars->val;

  return "0";
}


void set_quest_variable(struct char_data *ch, struct char_data *vict, char *qname, char *error_string, char *variable, char *value) {
  struct quest_list* quest = quest_find_char(vict, qname);
  struct quest_var_list* vars;

  if (!quest) {
    if (ch) {
      sprintf(buf, "You can't set variables on a quest %s hasn't started yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else {
      sprintf(buf, error_string, "set variable on nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  for (vars = quest->variables; vars; vars = vars->next)
    if (!strcmp(variable, vars->var)) {
      strncpy(vars->val, value, 20);
      return;
    }

  CREATE(vars, struct quest_var_list, 1);
  CREATE(vars->var, char, 21);
  strncpy(vars->var, variable, 20);
  vars->var[20] = '\0';
  CREATE(vars->val, char, 21);
  strncpy(vars->val, value, 20);
  vars->val[20] = '\0';
  vars->next = quest->variables;
  quest->variables = vars;

  if (ch) {
    sprintf(buf, "Set quest %s variable %s to '%s' on %s.\r\n",
            qname, variable, value, GET_NAME(vict));
    send_to_char(buf, ch);
  }
}

/*
 * quest_stage
 *
 * descr:	returns the value (int) of the stage the specified char is at
 * 		for the specified quest, or 0 if the char has not started the
 * 		quest or the quest does not exist.
 *
 * NOTE:	if a zero is returned here it could mean there was an error or
 * 		that the char has failed this quest, so call has_failed_quest
 * 		to be sure
 */
int quest_stage(struct char_data *ch, char *qname)
{
  struct quest_list *quest;

  if (!ch)
    return (int) quest_find_max_stage(qname);

  if ((quest = quest_find_char(ch, qname)))
    return quest->stage;

  return 0;
}

/*
 * quest_complete, quest_fail, quest_advance, quest_start
 *
 * descr:	stage manipulation routines for quest, failure means set all bits to 0
 * 		success means set all bits to 1 and advance is add one to current stage
 *
 * returns:	all return the newly set stage if successful, except quest_fail which
 * 		returns 1 if successful (cos new stage is 0!)
 *
 * NOTE:	advance will fail and log an error if the quest is already at stage 254
 * 		or 0 because starting a quest sets stage to 1 and we can't retry a failed
 * 		quest, and must sue quest_complete to set to 255. If you need more
 * 		than 254 stages in your quest you are an evil bastard and should seek help.
 */
void quest_complete(struct char_data *ch, struct char_data *vict, char *qname, char *error_string) {
  struct quest_list *quest = quest_find_char(vict, qname);

  if (!quest) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "complete nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_SUCCESS) {
    if (ch) {
      sprintf(buf, "%s has already completed that quest!\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "complete already-completed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_FAILURE) {
    if (ch) {
      sprintf(buf, "%s has already failed that quest!\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "complete already-failed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  quest->stage = QUEST_SUCCESS;

  sprintf(buf, "Congratulations, you completed the %s quest!\r\n", qname);
  send_to_char(buf, vict);

  if (ch) {
    sprintf(buf, "Set the %s quest to &8completed&0 on %s.\r\n",
      qname, GET_NAME(vict));
    send_to_char(buf, ch);
  }

}

void quest_fail(struct char_data *ch, struct char_data *vict, char *qname, char *error_string) {
  struct quest_list *quest = quest_find_char(vict, qname);

  if (!quest) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "fail nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_SUCCESS) {
    if (ch) {
      sprintf(buf, "%s has already completed that quest!\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "fail already-completed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_FAILURE) {
    if (ch) {
      sprintf(buf, "%s has already failed that quest!\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "fail already-failed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  quest->stage = QUEST_FAILURE;

  if (ch) {
    sprintf(buf, "Set the %s quest to &8failed&0 on %s.\r\n",
      qname, GET_NAME(vict));
    send_to_char(buf, ch);
  }
}


/*
 * quest advance
 *
 */
void quest_advance(struct char_data *ch, struct char_data *vict, char *qname, char *error_string, int amount) {
  short max_stage;
  struct quest_list *quest = quest_find_char(vict, qname);

  if (!quest) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "advance nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_FAILURE) {
    if (ch) {
      sprintf(buf, "%s has already failed this quest.  Use quest restart.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "advance failed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_SUCCESS) {
    if (ch) {
      sprintf(buf, "%s has already completed this quest.  Use quest restart.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "advance already completed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  max_stage = quest_find_max_stage(qname);
  if (quest->stage + amount > max_stage) {
    quest->stage = max_stage;
    if (ch) {
      sprintf(buf, "You can't advance past the quest's max stage.  %s's stage set to max.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, "advance past quest max stage of %d", max_stage);
      sprintf(buf1, error_string, buf);
      mudlog(buf1, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  /* Great success! */
  quest->stage += amount;

  if (ch) {
    sprintf(buf, "Advanced the %s quest's stage by %d to %d on %s.\r\n",
      qname, amount, quest->stage, GET_NAME(vict));
    send_to_char(buf, ch);
  }

}

/*
 * quest start
 *
 */
void quest_start(struct char_data *ch, struct char_data *vict, char *qname, char *error_string, char *subclass_abbr) {
  struct quest_list *quest = quest_find_char(vict, qname);
  extern int class_ok_race[NUM_RACES][NUM_CLASSES];
  unsigned short quest_num;
  int subclass = CLASS_UNDEFINED;

  if (quest) {
    if (ch) {
      sprintf(buf, "%s has already started this quest.  Use quest restart.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "start already-started quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  quest_num = quest_find_num(qname);

  if (!*subclass_abbr && IS_SUBCLASS_QUEST(quest_num)) {
    if (ch)
      send_to_char("You must supply the name of the subclass for this quest.\r\n", ch);
    else if (error_string) {
      sprintf(buf, error_string, "start subclass quest without specifying which");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (*subclass_abbr && IS_SUBCLASS_QUEST(quest_num)) {

    /* A player can only be on one subclass quest at a time, so check for another one. */
    quest = vict->quests;
    while(quest) {
      if (quest->quest_id & SUBCLASS_BIT) {
        if (ch) {
          sprintf(buf,
                "%s is already on a subclass quest.  Erase it before starting another.\r\n",
                GET_NAME(vict));
          send_to_char(buf, ch);
        }
        else if (error_string) {
          sprintf(buf, error_string, "start subclass quest with one already in progress");
          mudlog(buf, NRM, LVL_GOD, TRUE);
        }
        return;
      }
      quest = quest->next;
    }

    subclass = parse_class(0, 0, subclass_abbr);

    if (subclass == CLASS_UNDEFINED) {
      if (ch)
        send_to_char("That's not a valid class.\r\n", ch);
      else if (error_string) {
        sprintf(buf, error_string, "start subclass quest with invalid class abbreviation");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* Is the player a base class? */
    if (classes[(int)GET_CLASS(vict)].is_subclass) {
      if (ch) {
        sprintf(buf, "%s has already subclassed.\r\n", GET_NAME(vict));
        send_to_char(buf, ch);
      } else if (error_string) {
        sprintf(buf, error_string, "start subclass quest on already subclassed player");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* Is the proposed class a subclass of the player's current class? */
    if (!classes[subclass].is_subclass || !classes[subclass].subclass_of == GET_CLASS(vict)) {
      if (ch) {
        sprintf(buf, "Invalid subclass for %s's class.\r\n", GET_NAME(vict));
        send_to_char(buf, ch);
      }
      else if (error_string) {
        sprintf(buf, error_string, "start subclass quest when player's class does not permit it");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* Does the player's race permit this subclass? */
    if (!class_ok_race[(int) GET_RACE(vict)][subclass]) {
      if (ch) {
        sprintf(buf, "Invalid subclass for %s's race.\r\n", GET_NAME(vict));
        send_to_char(buf, ch);
      }
      else if (error_string) {
        sprintf(buf, error_string, "start subclass quest when player's race does not permit it");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* You must be at least level 10 to start a subclass quest,
     * unless a deity hooks you up. */
    if (GET_LEVEL(vict) < 10 && !ch) {
      if (error_string) {
        sprintf(buf, error_string, "start subclass quest before player is level 10");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* You must be less than the subclass quest max level to start the
     * quest, unless a deity hooks you up. */
    if (!ch && GET_LEVEL(vict) > classes[(int) GET_CLASS(vict)].max_subclass_level) {
      if (error_string) {
        sprintf(buf, error_string, "start subclass quest after player is past max subclass level");
        mudlog(buf, NRM, LVL_GOD, TRUE);
      }
      return;
    }

    /* You may begin the subclass quest. */
  }

  /* Okay, make the new quest */
  CREATE(quest, struct quest_list, 1);
  quest->quest_id = quest_num;
  quest->stage = QUEST_START;
  quest->next = vict->quests;
  vict->quests = quest;

  /* For subclass quests, store the name of the subclass in a quest variable. */
  if (subclass != CLASS_UNDEFINED) {
    set_quest_variable(ch, vict, qname, error_string, "subclass_name",
        classes[subclass].name);
  }

  if (ch) {
    sprintf(buf, "Started the %s quest on %s and set stage to 1.\r\n",
      qname, GET_NAME(vict));
    send_to_char(buf, ch);
  }

}

void quest_rewind(struct char_data *ch, struct char_data *vict, char *qname, char *error_string, int amount) {
  struct quest_list *quest = quest_find_char(vict, qname);

  if (!quest) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "rewind nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_FAILURE) {
    if (ch) {
      sprintf(buf, "%s has already failed this quest.  Use quest restart.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "rewind failed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage == QUEST_SUCCESS) {
    if (ch) {
      sprintf(buf, "%s has already completed this quest.  Use quest restart.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "rewind already completed quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  if (quest->stage - amount < 1) {
    quest->stage = 1;
    if (ch) {
      sprintf(buf, "You can't rewind past the first stage.  %s's stage set to 1.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "rewind past quest first stage");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  /* Great success! */
  quest->stage -= amount;

  if (ch) {
    sprintf(buf, "Rewound the %s quest's stage by %d to %d on %s.\r\n",
      qname, amount, quest->stage, GET_NAME(vict));
    send_to_char(buf, ch);
  }

}

void quest_restart(struct char_data *ch, struct char_data *vict, char *qname, char *error_string) {
  struct quest_list *quest = quest_find_char(vict, qname);

  if (!quest) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "restart nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  quest->stage = QUEST_START;

  if (ch) {
    sprintf(buf, "Restarted the %s quest on %s by resetting stage to 1.\r\n",
      qname, GET_NAME(vict));
    send_to_char(buf, ch);
  }

}


/*
 * quest_erase
 *
 * descr:	Removes a named quest from a player (no forced save!)
 *
 * returns:	1 if quest removed from player, 0 if quest not exist or
 * 		unable to remove it
 *
 * NOTE:	This procedure does not force a save of the player. This
 * 		procedure does no checking of stage or even subclassiness - if
 * 		this was a completed subclass and the player has CHANGED
 * 		subclass, then they will not be changed back.
 */
void quest_erase(struct char_data *ch, struct char_data *vict, char *qname, char *error_string) {
  struct quest_list *quest, *prev;
/*  struct quest_var_list *vars, *next_vars; */
  unsigned short quest_num;

  if (!vict->quests) {
    if (ch) {
      sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
    else if (error_string) {
      sprintf(buf, error_string, "erase nonexistent quest");
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    return;
  }

  quest_num = quest_find_num(qname);

  for (quest = vict->quests; quest; prev = quest, quest = quest->next) {
    /* Skip quests with quest_ids that don't match. */
    if (quest->quest_id != quest_num)
      continue;
    /* If we're here, the current quest matches. */
    if (quest == vict->quests)
      vict->quests = vict->quests->next; /* quest is the first quest */
    else
      prev->next = quest->next; /* quest is not the first quest */
    /* Free variables */
/* For some reason this causes a crash on production.  I dunno.
    for (vars = quest->variables; vars; vars = next_vars) {
      next_vars = vars->next;
      if (vars->var)
        free(vars->var);
      if (vars->val)
        free(vars->val);
      free(vars);
    }
*/
    free(quest);
    if (ch) {
      sprintf(buf, "Erased the %s quest from %s.\r\n",
        qname, GET_NAME(vict));
      send_to_char(buf, ch);
    }
    return;
  }

  if (ch) {
    sprintf(buf, "%s hasn't started that quest yet.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
  else if (error_string) {
    sprintf(buf, error_string, "erase nonexistent quest");
    mudlog(buf, NRM, LVL_GOD, TRUE);
  }
}

/*
 * has_failed_quest
 *
 * descr:	Has the player failed the quest specified
 *
 * returns:	1 if the player has failed the quest, 0 if the quest is not failed
 * 		or if the quest does not exist, or the player has not started it.
 *
 * NOTE:	if has_failed_quest returns 0, and quest_stage also returns 0 then
 * 		the quest does not exist or the player has not started it
 */
int has_failed_quest(char *qname, struct char_data *ch) {
  struct quest_list *quest = quest_find_char(ch, qname);

  if (quest && quest->stage == QUEST_FAILURE)
    return 1;

  return 0;
}


/*
 * has_completed_quest
 *
 * descr:	Has the player completed the quest specified
 *
 * returns:	1 if the player has completed the quest successfully, 0 if the quest is not completed
 * 		or if the quest does not exist, or the player has not started it.
 *
 */
int has_completed_quest(char *qname, struct char_data *ch) {
  struct quest_list *quest = quest_find_char(ch, qname);

  if (quest && quest->stage == QUEST_SUCCESS)
    return 1;

  return 0;
}

/*
 * do_add
 *
 * descr:	Allows user to config a new quest (add to misc/quests and array)
 */
ACMD(do_qadd)
{
  int new_id = 1, max_id, i, stages;
  FILE *fp;

  argument = any_one_arg(argument, buf1);
  argument = any_one_arg(argument, buf2);

  if (!*buf1 || !*buf2) {
    send_to_char("Usage: qadd <quest_name> <max_stages> [<yes_if_subclass_quest>]\r\n", ch);
    return;
  }

  if (strlen(buf1) >= MAX_QNAME_LEN) {
    sprintf(buf, "The quest name may not be longer than %d characters.\r\n", MAX_QNAME_LEN - 1);
    send_to_char(buf, ch);
    return;
  }

  /* Can't create a new quest with the same name as another one! */
  if (quest_find_num(buf1)) {
    sprintf(buf, "There's already a quest named %s!\r\n", buf1);
    send_to_char(buf, ch);
    return;
  }

  /* Check and see if this is going to be a subclass quest.  Start the
   * new_id appropriately if so.  We have to check to make sure arg is
   * longer than 0, otherwise all quests are subclass quests.
   */
  argument = any_one_arg(argument, arg);
  if (*arg && !strn_cmp("yes", arg, strlen(arg))) {
    max_id = (MAX_SUBCLASS_QUEST_ID | SUBCLASS_BIT);
    new_id |= SUBCLASS_BIT;
  }
  else
    max_id = MAX_QUEST_ID;

  /* Generate a new quest ID. */
  for (i = 0; i < max_quests; i++) {
    if (all_quests[i].quest_id > new_id)
      break;
    new_id++;
  }

  if (new_id > max_id) {
    send_to_char("No free quest IDs are left.  Remove some old ones first.\r\n", ch);
    return;
  }

  if (!(stages = atoi(buf2))) {
    send_to_char("You must specify an integer for the maximum number of stages.\r\n", ch);
    return;
  }
  if (real_quest(new_id) != NOWHERE) {
    send_to_char("Unable to allocate a quest ID for the new quest.\r\n", ch);
    return;
  }

  /*
   * rewrite the quest file and add this one in the correct place
   */
  if((fp = fopen(ALL_QUEST_FILE,"w")) == NULL) {
    log("Unable to open ALL_QUEST_FILE in qadd\r\n");
    return;
  }
  if (max_quests)
    for (i = 0; (all_quests[i].quest_id < new_id) && (i < max_quests); i++)
      fprintf(fp, "%s %d %d\n", all_quests[i].quest_name,
              all_quests[i].quest_id, all_quests[i].maxstages);
  fprintf(fp, "%s %d %d\n", buf1, new_id, stages);
  if (max_quests)
    for (; i < max_quests; i++)
      fprintf(fp, "%s %d %d\n", all_quests[i].quest_name,
              all_quests[i].quest_id, all_quests[i].maxstages);
  fclose(fp);

  /*
   * Reboot quests.
   */
  boot_quests();
  if (new_id & SUBCLASS_BIT) {
    sprintf(buf, "(GC) %s created a new subclass quest %s.", GET_NAME(ch), buf1);
    sprintf(buf2, "New &8subclass&0 quest %s successfully added.\r\n", buf1);
  }
  else {
    sprintf(buf, "(GC) %s created a new quest %s.", GET_NAME(ch), buf1);
    sprintf(buf2, "New quest %s successfully added.\r\n", buf1);
  }
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  send_to_char(buf2, ch);
}

/*
 * do_qdel
 *
 * descr:	opposite of qadd, removes a quest from global list with NO CONFIRM
 * 		note: doesn't remove quests from players, these will be removed on
 * 		next login, but stats will stop showing themimmediately
 */
ACMD(do_qdel) {
  int quest_num = 0, i;
  FILE *fp;

  argument = any_one_arg(argument, buf1);

  if (!*buf1) {
    send_to_char("Usage: qdel <quest_name>\r\n", ch);
    return;
  }

  /*
   * Instead of using quest_find_num, we'll search the quest index
   * ourselves, because quest_find_num allows abbreviations, and I
   * think we should be a little more careful than that when deleting.
   */
  for (i = 0; i < max_quests; i++)
    if (!str_cmp(all_quests[i].quest_name, buf1)) {
      quest_num = all_quests[i].quest_id;
      break;
    }

  /* We didn't find the quest. */
  if (!quest_num) {
    sprintf(buf, "There is no quest named %s.\r\n", buf1);
    send_to_char(buf, ch);
    return;
  }

  /* Rewrite the quest file and drop this one. */
  if (!(fp = fopen(ALL_QUEST_FILE, "w"))) {
    log("Unable to open ALL_QUEST_FILE in qdel.\r\n");
    return;
  }

  if (max_quests)
    for (i = 0; i < max_quests; i++)
      if (all_quests[i].quest_id != quest_num)
        fprintf(fp, "%s %d %d\n", all_quests[i].quest_name,
                all_quests[i].quest_id, all_quests[i].maxstages);

  fclose(fp);

  /* Reboot quests. */
  boot_quests();
  if (IS_SUBCLASS_QUEST(quest_num)) {
    sprintf(buf, "(GC) %s deleted subclass quest %s.", GET_NAME(ch), buf1);
    sprintf(buf2, "Subclass quest %s successfully deleted.\r\n", buf1);
  }
  else {
    sprintf(buf, "(GC) %s deleted quest %s.", GET_NAME(ch), buf1);
    sprintf(buf2, "Quest %s successfully deleted.\r\n", buf1);
  }
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  send_to_char(buf2, ch);

}


/*
 * do_qlist
 *
 * descr:	just lists all the quests in the array..nothing fancy (yet)
 */
ACMD(do_qlist)
{
	int i;
	char intbuf[8];
	char msgbuf[100];

	sprintf(msgbuf,"There are %d quests:\r\n====================\r\n",max_quests);
	send_to_char(msgbuf,ch);
	sprintf(msgbuf,"%35s %6s %15s\r\n","Quest Name","Stages","Quest Type");
	send_to_char(msgbuf,ch);

	for (i=0;i<max_quests;i++)
	{
		sprintf(intbuf,"%d",all_quests[i].maxstages);
		sprintf(msgbuf,"%35s %6s %15s\r\n",all_quests[i].quest_name, intbuf,(IS_SUBCLASS_QUEST(all_quests[i].quest_id))?"Subclass Quest":"Regular Quest");
		send_to_char(msgbuf,ch);
	}
}

void free_quest_list(struct char_data *ch)
{
  struct quest_list *quest, *next_quest;

  quest = ch->quests;
  while (quest) {
    next_quest = quest->next;
    if (quest->variables) {
      struct quest_var_list* quest_var;
      struct quest_var_list* next_var;

      quest_var = quest->variables;

      while (quest_var) {
        next_var = quest_var->next;
        free(quest_var->var);
        free(quest_var->val);
        free(quest_var);
        quest_var = next_var;
      }
    }

    free (quest);
    quest = next_quest;
  }

  ch->quests = NULL;
}


void free_quests()
{
  int i;

  for (i = 0; i < max_quests; ++i)
    free(all_quests[i].quest_name);

  free(all_quests);
}

/***************************************************************************
 * $Log: quest.c,v $
 * Revision 1.53  2010/06/20 19:53:47  mud
 * Log to file errors we might want to see.
 *
 * Revision 1.52  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.51  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.50  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.49  2008/03/29 21:16:41  myc
 * Don't let mobs refer to themselves using self.
 *
 * Revision 1.48  2008/03/29 21:14:37  myc
 * You can use 'self' or 'me' with the quest command now.
 *
 * Revision 1.47  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.46  2008/02/16 20:31:32  myc
 * Adding functions to free quests at program termination.
 *
 * Revision 1.45  2008/02/10 20:24:23  jps
 * More of the same
 *
 * Revision 1.44  2008/02/10 20:19:19  jps
 * Further quest numbering tweaks/fixes.
 *
 * Revision 1.43  2008/02/10 19:43:38  jps
 * Subclass quests now store the target subclass as a quest variable rather
 * than as 3 bits in the quest id.
 *
 * Revision 1.42  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.41  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.40  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.39  2008/01/18 01:28:57  myc
 * Subclass quest code was checking wrong class for max subclass level.
 *
 * Revision 1.38  2008/01/05 20:33:05  jps
 * More informative error message when not enough params to quest.
 *
 * Revision 1.37  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.36  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.35  2007/08/25 00:10:41  jps
 * Added qstat command, and added 'mstat' and 'stat' subcommands
 * to the main quest command.
 *
 * Revision 1.34  2007/08/05 01:49:05  myc
 * Make the quest command able to see players the mob may not be able to see.
 *
 * Revision 1.33  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.32  2007/06/12 02:24:57  myc
 * Quest start was using the wrong class number for subclass quests,
 * which was preventing some races from doing some subclass quests.
 * Now fixed.
 *
 * Revision 1.31  2007/05/28 16:53:38  jps
 * Fix fencepost bug in set_quest_variable.
 *
 * Revision 1.30  2007/05/28 07:20:37  jps
 * Allow use of the quest command on players not in the same room, for
 * deities.  "quest stage..." will correctly report when someone hasn't
 * started a quest.
 *
 * Revision 1.29  2007/05/21 02:24:36  myc
 * Attempting to fix a crash bug in quest erase.
 *
 * Revision 1.28  2007/05/11 19:34:15  myc
 * Modified the quest command functions so they are thin wrappers for
 * perform_quest() in quest.c.  Error handling and messages should be
 * much better now.  Advance and rewind now accept another argument
 * specifying how many stages to advance or rewind.
 *
 * Revision 1.27  2006/06/28 19:55:01  cjd
 * adjusted maximum level check for subclasses to relfect the
 * actual numbers as this was interfering.
 *
 * Revision 1.26  2002/10/06 20:31:18  jjl
 * Fixed to return 0 when the variable is unset, as I had originally meant it to
 * This should keep the crashes down to a minimum.
 *
 * Revision 1.25  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.24  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.23  2002/06/17 15:43:33  rls
 * Updated max subclass levels to 40 per Jeff's request. RLS: 06-07-2002
 *
 * Revision 1.22  2001/07/08 17:47:40  mtp
 * added quest erase to remove a quest from a player (non documented)
 *
 * Revision 1.21  2001/06/19 23:22:25  mtp
 * moved error messages up a level to report which mob/room failed
 *
 * Revision 1.20  2001/04/01 21:59:31  mtp
 * changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
 *
 * Revision 1.19  2001/02/12 23:26:43  mtp
 * level check on quest_start
 *
 * Revision 1.18  2001/02/12 01:29:06  mtp
 * feedback on quest completion (may need to change this?)
 *
 * Revision 1.17  2001/02/03 00:56:51  mtp
 * do a race check before starting subclass quest
 * also returing different codes so that calling procs can do something sensible
 * on failure
 *
 * Revision 1.16  2000/11/22 01:51:17  mtp
 * allow removeal of quests from global list with dqdel
 * note: qdel removes from list but not players, their quest structs are
 * managed on login
 *
 * Revision 1.15  2000/11/19 00:51:26  rsd
 * Added more old log info from post logs before the log
 * rcs string was added.  Noticed an interesting time bug
 * I'm checking this file in Sat Nov 18 19:51:14 EST 2000
 * I had to resync the time between the two boxes as
 * xntp had barfed on rift.  Time time stamps on the file
 * are way off though, more than the 15 minutes rift was
 * off....
 *
 * Revision 1.14  2000/11/19 00:39:59  rsd
 * Added the rlog information to the bottom of the file so it
 * seems to be a continious series of comments.
 *
 * Revision 1.13  2000/11/19 00:26:58  rsd
 * Another attempt to get logging information to appear
 * at the bottom of the file
 *
 * Revision 1.12  2000/11/19 00:23:58  rsd
 * Added the comment header, attempting to add RCS strings
 *
 * Revision 1.11  2000/11/15 00:30:19  mtp
 * added confirmation of added quest
 *
 * Revision 1.10  2000/11/15 00:25:18  mtp
 * auto numbering of quests
 *
 * Revision 1.9  2000/11/07 02:00:24  mtp
 * removed some debug messages that slipped in..
 *
 * Revision 1.8  2000/11/07 01:59:00  mtp
 * fixed little teeny buglet in the file writing..
 *
 * Revision 1.7  2000/11/07 01:49:37  mtp
 * added a load of stuff to help with subclasses, and also changed some
 * function defn to use unsigned short instead of int (which was giving
 * some probs)
 *
 * Revision 1.6  2000/11/03 05:37:17  jimmy
 * Removed the quest.h file from structs.h arg!! and placed it
 * only in the appropriate files
 * Updated the dependancies in the Makefile and created
 * make supahclean.
 *
 * Revision 1.5  2000/10/31 23:26:43  mtp
 * added qadd and qlist to manage new quests (no quest_remove yet)
 *
 * Revision 1.4  2000/10/27 00:08:07  mtp
 * new quest code to handle start/complete/fail/advance and stage queries
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/02/01 03:42:04  mud
 * dos2unix
 * Indented slightly
 * Tweaked comment header
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.53
log
@Log to file errors we might want to see.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.52 2009/03/08 23:34:14 jps Exp mud $
d189 1
a189 1
  if (arg && !strcmp(arg, "mstat") && ch) {
d1324 3
@


1.52
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.51 2009/03/03 19:43:44 myc Exp jps $
d404 1
a404 1
      mudlog(buf1, NRM, LVL_GOD, LVL_GOD);
d1188 1
a1188 1
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), FALSE);
d1252 1
a1252 1
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), FALSE);
d1324 3
@


1.51
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.50 2008/05/18 05:39:59 jps Exp myc $
d24 1
a24 1
#include "spells.h"
d1324 3
@


1.50
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.49 2008/03/29 21:16:41 myc Exp jps $
d129 4
a132 10
   if (*name == UID_CHAR) {
      vict = get_char(name);
      if (IS_NPC(vict))
        vict = NULL;
   } else if (ch && !IS_NPC(ch) && (!str_cmp(name, "self") || !str_cmp(name, "me")))
      vict = ch;
   else
      for (vict = character_list; vict; vict = vict->next)
         if (!IS_NPC(vict) && !str_cmp(GET_NAMELIST(vict), name))
            break;
d134 4
a137 5
      if (t) {
         sprintf(buf, "QUEST ERROR: quest command couldn't find player %s in trigger %d",
               name, GET_TRIG_VNUM(t));
         mudlog(buf, NRM, LVL_GOD, TRUE);
      } else if (ch)
d1324 3
@


1.49
log
@Don't let mobs refer to themselves using self.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.48 2008/03/29 21:14:37 myc Exp myc $
d261 1
a261 1
            "[%s on quest %s in trigger %d]", room->name, room->number,
d1331 3
@


1.48
log
@You can use 'self' or 'me' with the quest command now.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.47 2008/03/09 06:38:37 jps Exp myc $
d133 1
a133 1
   } else if (ch && (!str_cmp(name, "self") || !str_cmp(name, "me")))
d1331 3
@


1.47
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.46 2008/02/16 20:31:32 myc Exp jps $
d132 4
a135 2
      vict = NULL;
   } else {
a138 1
   }
d1331 5
@


1.46
log
@Adding functions to free quests at program termination.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.45 2008/02/10 20:24:23 jps Exp myc $
d135 1
a135 1
         if (!IS_NPC(vict) && !str_cmp(vict->player.name, name))
d1330 3
@


1.45
log
@More of the same
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.44 2008/02/10 20:19:19 jps Exp jps $
d32 1
a32 2
/* External functions */
void boot_quests();
d1288 40
d1330 3
@


1.44
log
@Further quest numbering tweaks/fixes.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.43 2008/02/10 19:43:38 jps Exp jps $
d760 1
a760 1
  unsigned short quest_num, a;
a880 9
  a = real_quest(quest_num);
  sprintf(buf, "You are starting quest %hu (%s) on %s.\n",
        a,
        all_quests[a].quest_name,
        GET_NAME(vict));
  send_to_char(buf, ch);
  sprintf(buf, "You are calling it \"%s\".\n", qname);
  send_to_char(buf, ch);

d888 1
d1291 3
@


1.43
log
@Subclass quests now store the target subclass as a quest variable rather
than as 3 bits in the quest id.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.42 2008/02/09 04:27:47 myc Exp jps $
d437 1
a437 1
  for (count = 0; count < max_quests; count++)
d440 1
a480 5
  /* if the quest is a subclass quest then bits
   * 15,14,13 will be describing the destination class
   * and so only the top bit and the bottom 11 bits are
   * relevant for the check
   */
d482 1
a482 1
    if (((quest->quest_id) & (~SUBCLASS_BIT)) == quest_num)
d760 1
a760 1
  unsigned short quest_num;
d881 9
d1033 1
a1033 1
    if (((quest->quest_id) & (~SUBCLASS_BIT)) != quest_num)
d1299 4
@


1.42
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.41 2008/01/29 21:02:31 myc Exp myc $
d234 2
a235 2
  /* At this point, we assume we have a valid quest_name and victim.  Now 
     we just have to see if we have valid command.  But first, let's set 
d248 1
a248 1
              "[%s on quest %s]", GET_NAME(ch), GET_NAME(vict), 
d255 1
a255 1
            GET_OBJ_VNUM(obj), GET_NAME(vict), quest_name,  
d304 1
a304 1
   * Set quest variable <buf1> to value <buf2> on player <vict> on the 
d434 1
a434 1
   * Loop through the quests and if we find the one we're looking for, 
d444 1
a444 1
 * utility function for perform_quest.  Returns the full qualified name of 
d485 2
a486 6
  for (quest = ch->quests; quest; quest = quest->next) {
    if (IS_SUBCLASS_QUEST(quest->quest_id)) {
      if ((quest->quest_id & ~(SUBCLASS_MASK)) == quest_num)
        return quest;
    }
    else if (quest->quest_id == quest_num)
a487 1
  }
d578 1
a578 1
 * returns:	all return the newly set stage if successful, except quest_fail which 
d612 1
a612 1
    
d624 1
a624 1
    
d664 1
a664 1
    
d676 1
a676 1
    
d765 1
a765 1
  int subclass;
d833 1
a833 1
      return;     
d846 1
a846 1
      return;     
d859 1
a859 1
      return;     
d872 1
a872 1
    /* You must be less than the subclass quest max level to start the 
d882 1
a882 3
    /* We're using some of the quest num bits to signify subclass quests.
     * They should have just added another field to the quest_info struct. */
    quest_num |= (subclass << ARRAY_LOCN);
d892 5
d1028 1
a1028 5
    if (IS_SUBCLASS_QUEST(quest->quest_id)) {
      if ((quest->quest_id & ~(SUBCLASS_MASK)) != quest_num)
        continue;
    }
    else if (quest->quest_id != quest_num)
d1135 2
a1136 2
  /* Check and see if this is going to be a subclass quest.  Start the 
   * new_id appropriately if so.  We have to check to make sure arg is 
d1177 1
a1177 1
      fprintf(fp, "%s %d %d\n", all_quests[i].quest_name, 
d1182 1
a1182 1
      fprintf(fp, "%s %d %d\n", all_quests[i].quest_name, 
d1185 1
a1185 1
  
d1190 1
a1190 1
  if (new_id > SUBCLASS_BIT) {
d1221 1
a1221 1
   * Instead of using quest_find_num, we'll search the quest index 
d1294 3
@


1.41
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.40 2008/01/26 14:26:31 jps Exp myc $
d30 1
a30 1

d1300 4
@


1.40
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.39 2008/01/18 01:28:57 myc Exp jps $
d14 2
a30 8
/* External variables */
extern int max_quests;
extern struct quest_info *all_quests;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct index_data **trig_index;
extern struct room_data *world;
extern char_data *character_list;
d36 45
d1300 3
@


1.39
log
@Subclass quest code was checking wrong class for max subclass level.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.38 2008/01/05 20:33:05 jps Exp myc $
d26 2
d1261 3
@


1.38
log
@More informative error message when not enough params to quest.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.37 2008/01/04 01:53:26 jps Exp jps $
d838 1
a838 1
    if (!ch && GET_LEVEL(vict) > classes[subclass].max_subclass_level) {
d1259 3
@


1.37
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.36 2008/01/03 12:44:03 jps Exp jps $
d144 1
a144 1
  char error_string[MAX_INPUT_LENGTH * 2], *quest_name;
d285 2
a286 1
      sprintf(buf, error_string, "set variable with no value");
d1259 4
@


1.36
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.35 2007/08/25 00:10:41 jps Exp jps $
d25 1
d1258 4
@


1.35
log
@Added qstat command, and added 'mstat' and 'stat' subcommands
to the main quest command.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.34 2007/08/05 01:49:05 myc Exp jps $
a724 5
  extern char *class_abbrevs[];
  extern int mage_subclasses[];
  extern int cleric_subclasses[];
  extern int rogue_subclasses[];
  extern int warrior_subclasses[];
a725 1
  int subclass, class, max_subclasses, *subclass_allowed;
d727 1
d760 3
a762 1
          sprintf(buf, "%s is already on a subclass quest.  Erase it before starting another.\r\n", GET_NAME(vict));
d774 3
a776 9
    /* This is some great Hubis legacy code that we have to hold on to 
     * lest we have to convert all the player quest files.  (Maybe that's
     * not such a bad idea...)
     */
    for (class = 0; class < NUM_CLASSES && strn_cmp(subclass_abbr, strip_ansi(class_abbrevs[class]), 3); class++);

    /* If i is NUM_CLASSES, then we didn't actually find the destination
     * class, so failure! */
    if (class == NUM_CLASSES) {
d786 10
a795 28
    /* Now check to see if this player can actually become the target subclass. */
    switch (GET_CLASS(vict)) {
      case CLASS_WARRIOR:
        subclass_allowed = warrior_subclasses;
        max_subclasses = WARRIOR_SUBCLASSES;
        break;
      case CLASS_CLERIC:
        subclass_allowed = cleric_subclasses;
        max_subclasses = CLERIC_SUBCLASSES;
        break;
      case CLASS_ROGUE:
        subclass_allowed = rogue_subclasses;
        max_subclasses = ROGUE_SUBCLASSES;
        break;
      case CLASS_MAGIC_USER:
        subclass_allowed = mage_subclasses;
        max_subclasses = MAGE_SUBCLASSES;
        break;
      default:
        if (ch) {
          sprintf(buf, "%s has already subclassed.\r\n", GET_NAME(vict));
          send_to_char(buf, ch);
        }
        else if (error_string) {
          sprintf(buf, error_string, "start subclass quest on already subclassed player");
          mudlog(buf, NRM, LVL_GOD, TRUE);
        }
        return;     
d798 2
a799 3
    /* Does the player's class permit this subclass? */
    for (subclass = 0; subclass < max_subclasses && subclass_allowed[subclass] != class; subclass++);
    if (subclass == max_subclasses) {
d812 1
a812 1
    if (!class_ok_race[(int) GET_RACE(vict)][class]) {
d824 2
a825 3
    /* You must be at least level 10 to start a subclass quest.  Unless a 
     * deity hooks you up--only throw an error if in a trigger.
     */
d835 2
a836 8
     * quest.  Unless a deity hooks you up--only throw an error if in a 
     * trigger.
     */
    if (!ch && (
            (GET_CLASS(vict) == CLASS_WARRIOR && GET_LEVEL(vict) > 25) ||
            (GET_CLASS(vict) == CLASS_CLERIC && GET_LEVEL(vict) > 45) ||
            (GET_CLASS(vict) == CLASS_ROGUE && GET_LEVEL(vict) > 25) ||
            (GET_CLASS(vict) == CLASS_MAGIC_USER && GET_LEVEL(vict) > 45))) {
d845 1
a845 2
     * They should have just added another field to the quest_info struct.
     */
d1257 4
@


1.34
log
@Make the quest command able to see players the mob may not be able to see.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.33 2007/07/24 23:02:52 jps Exp myc $
d39 103
d152 13
d189 2
a190 19
  if (*buf2 == UID_CHAR) {
    vict = get_char(buf2);
    if (IS_NPC(vict))
      vict = NULL;
  }
  else {
    for (vict = character_list; vict; vict = vict->next)
      if (!IS_NPC(vict) && !str_cmp(vict->player.name, buf2))
        break;
  }
  if (!vict) {
    if (t) {
      sprintf(buf, "QUEST ERROR: quest command couldn't find player %s in trigger %d", buf2, GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
    else if (ch)
      send_to_char("There's no player by that name here.\r\n", ch);
    return;
  }
d354 10
d371 1
a371 1
      sprintf(buf, "Sorry, %s is not a valid quest command.", arg);
d1293 3
@


1.33
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.32 2007/06/12 02:24:57 myc Exp jps $
a91 4
  if (ch && GET_LEVEL(ch) < LVL_IMMORT && !CAN_SEE(ch, vict)) {
    send_to_char("There's no player by that name here.\r\n", ch);
    return;
  }
d1184 3
@


1.32
log
@Quest start was using the wrong class number for subclass quests,
which was preventing some races from doing some subclass quests.
Now fixed.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.31 2007/05/28 16:53:38 jps Exp myc $
d376 1
a376 1
      sprintf(buf, error_string, "set variable on nonexistant quest");
d452 1
a452 1
      sprintf(buf, error_string, "complete nonexistant quest");
d504 1
a504 1
      sprintf(buf, error_string, "fail nonexistant quest");
d558 1
a558 1
      sprintf(buf, error_string, "advance nonexistant quest");
d804 1
a804 1
      sprintf(buf, error_string, "rewind nonexistant quest");
d867 1
a867 1
      sprintf(buf, error_string, "restart nonexistant quest");
d908 1
a908 1
      sprintf(buf, error_string, "erase nonexistant quest");
d954 1
a954 1
    sprintf(buf, error_string, "erase nonexistant quest");
d1188 5
@


1.31
log
@Fix fencepost bug in set_quest_variable.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.30 2007/05/28 07:20:37 jps Exp jps $
d735 1
a735 1
    if (!class_ok_race[(int) GET_RACE(vict)][subclass]) {
d1188 3
@


1.30
log
@Allow use of the quest command on players not in the same room, for
deities.  "quest stage..." will correctly report when someone hasn't
started a quest.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.29 2007/05/21 02:24:36 myc Exp jps $
d391 1
a391 1
  vars->var[21] = '\0';
d394 1
a394 1
  vars->val[21] = '\0';
d1188 5
@


1.29
log
@Attempting to fix a crash bug in quest erase.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.28 2007/05/11 19:34:15 myc Exp $
d37 1
d92 1
a92 1
  if (ch && !CAN_SEE(ch, vict)) {
d241 15
a255 10
    amount = quest_stage(vict, quest_name);
    if (amount == QUEST_FAILURE)
      sprintf(buf, "%s has failed the %s quest.\r\n",
              GET_NAME(vict), quest_name);
    else if (amount == QUEST_SUCCESS)
      sprintf(buf, "%s has completed the %s quest.\r\n",
              GET_NAME(vict), quest_name);
    else
      sprintf(buf, "%s is on stage %d of the %s quest.\r\n",
              GET_NAME(vict), amount, quest_name);
d1188 3
@


1.28
log
@Modified the quest command functions so they are thin wrappers for
perform_quest() in quest.c.  Error handling and messages should be
much better now.  Advance and rewind now accept another argument
specifying how many stages to advance or rewind.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.27 2006/06/28 19:55:01 cjd Exp myc $
d106 1
a106 1
              GET_MOB_VNUM(ch), quest_name, GET_NAME(vict), 
d110 2
a111 2
              "[%s on quest %s]", GET_NAME(ch), quest_name, 
              GET_NAME(vict));
d174 1
a174 1
      send_to_char("Which variable?", ch);
d893 1
a893 1
  struct quest_var_list *vars, *next_vars;
d924 1
d933 1
d1182 6
@


1.27
log
@adjusted maximum level check for subclasses to relfect the
actual numbers as this was interfering.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.26 2002/10/06 20:31:18 jjl Exp $
d24 1
d26 1
d30 237
d278 10
a287 1
	int count;
d289 10
a298 6
	for (count=0;count < max_quests ;count ++)
	{
		if (!strn_cmp(all_quests[count].quest_name,qname,strlen(qname)))
			return all_quests[count].quest_id;
	}
	return (short) 0;
d301 6
a306 1
short quest_find_maxstage(char *qname)
d308 1
a308 1
	short count=0;
d310 4
a313 6
	for (count=0;count < max_quests ;count ++)
	{
		if (!strn_cmp(all_quests[count].quest_name,qname,strlen(qname)))
			return all_quests[count].maxstages;
	}
	return (short) 0;
d321 1
a321 1
struct quest_list * quest_find_char(struct quest_list *qlist,char * qname)
d323 2
a324 2
	unsigned short qnum;
	char errbuf[100];
d326 14
a339 28
	if ((qnum = quest_find_num(qname)))
	{
		while (qlist)
		{
			/* if the quest is a subclass quest then bits
			 * 15,14,13 will be describing the destination class
			 * and so only the top bit and the bottom 11 bits are
			 * relevant for the check
			 */
			if (IS_SUBCLASS_QUEST(qlist->quest_id))
			{
				if ((qlist->quest_id & ~(SUBCLASS_MASK)) == qnum)
					return qlist;
			}
			else
				if (qlist->quest_id == qnum)
					return qlist;
			/* failed both matches..*/
			qlist = qlist->next;

		}
	}
	else
	{
		sprintf (errbuf,"QUEST ERROR:Attempt to find stage of non-existant quest %s",qname);
      		mudlog(errbuf, NRM, LVL_GOD, TRUE);
	}
	return (struct quest_list *)NULL;
d342 5
a346 3
char* get_quest_variable(char *qname,struct char_data *ch,char* variable)
{
  struct quest_list* pertinent_quest; 
d349 6
a354 4
  pertinent_quest = quest_find_char(ch->quests, qname); 
  
  if (pertinent_quest)
    {
d356 1
a356 16
      vars = pertinent_quest->variables; 
      
      while(vars)
	{
	  if (strcmp(variable, vars->var) == 0)
	    {
	      return vars->val; 
	    };
	  vars = vars->next;
	};
      return "0"; 
    }
  else
    {
      return "0"; 
    };
d360 2
a361 4
int set_quest_variable(char *qname,struct char_data *ch,char* variable, 
		       char *value)
{
  struct quest_list* pertinent_quest; 
a362 24
  struct quest_var_list* last; 
  
  pertinent_quest = quest_find_char(ch->quests, qname); 
  
  if (pertinent_quest)
    {
      
      vars = pertinent_quest->variables; 
      
      if (!vars)
	{
	  
	  CREATE(pertinent_quest->variables, struct quest_var_list, 21);
	  vars = pertinent_quest->variables;
	  CREATE(vars->var, char, 21); 
	  CREATE(vars->val, char, 21); 
	  
	  strncpy(vars->var, variable, 20); 
	  strncpy(vars->val, value, 20); 
	  
	  (vars->var)[20] = '\0';
	  (vars->val)[20] = '\0';
	  
	  vars->next = NULL; 
d364 16
a379 26
	  return 1; 
	}
      
      while(vars)
	{
	  if (strcmp(variable, vars->var) == 0)
	    {
	      strncpy(vars->val, value, 20); 
	      return 1;
	    };
	  last = vars;
	  vars = vars->next; 
	};

      CREATE(last->next, struct quest_var_list, 1); 
      vars = last->next; 

      CREATE(vars->var, char, 21); 
      CREATE(vars->val, char, 21); 
      strncpy(vars->var, variable, 20); 
      (vars->var)[20] = '\0';
      strncpy(vars->val, value, 20); 
      (vars->val)[20] = '\0';
      vars->next = NULL; 
      
      return 1; 
a380 5
  else
    {
      sprintf(buf, "Quest not found for qname=%s in set_quest_var\r\n", 
	      qname); 
      log(buf); 
d382 15
a396 2
      return 0;
    };
d410 1
a410 1
int quest_stage(char *qname,struct char_data *ch)
d412 4
a415 1
	struct quest_list *qlist;
d417 4
a420 9
	if (ch != (struct char_data *)NULL)
	{
		if ((qlist = quest_find_char(ch->quests,qname)))
			return qlist->stage;
		else
			return 0;	/* quest doesnt exist! or player didnt start it*/
	}
	else
		return (int) quest_find_maxstage(qname);
d437 49
a485 3
int quest_complete(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
a486 13
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		if (qlist->stage == QUEST_SUCCESS || qlist->stage == QUEST_FAILURE)
		{
			return 0;
		}
		qlist->stage = QUEST_SUCCESS;
		sprintf(buf,"Congratulations, you completed the %s quest!\n\r",qname);
		send_to_char(buf,ch);
		return qlist->stage;
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
a487 3
int quest_fail(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
d489 46
a534 11
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		if (qlist->stage == QUEST_SUCCESS || qlist->stage == QUEST_FAILURE)
		{
			return 0;
		}
		qlist->stage = QUEST_FAILURE;
		return 1;	/* the stage is also 0 which is not a handy ret code :)*/
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
a535 4
int quest_advance(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
	short maxstage;
a536 26
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		/*
		 * if current stage is 0 we have failed this quest...
		 * if current stage is 254 we have run out of stages
		 */
		if ((qlist->stage > 0) && (qlist->stage < QUEST_MAXSTAGE ))
		{
			maxstage = quest_find_maxstage(qname);
			if (qlist->stage < maxstage)
				qlist->stage ++;
			else
			{
				sprintf(buf,"QUEST ERROR:Attempt by %s (%d) to go beyond max configured stages (%d) for quest %s\r\n",GET_NAME(ch),GET_MOB_VNUM(ch),maxstage,qname);
      				mudlog(buf, NRM, LVL_GOD, TRUE);
			}
			return qlist->stage;
		}
		else
		{
			int rc = 0;

			if (qlist->stage > 0)
				rc = -1;
			else
				rc = -2;
d538 68
a605 5
			return rc;
		}
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
a606 14
int quest_start(char *qname,struct char_data *ch,char *subclass)
{
	struct quest_list *qlist,*curr;
	unsigned short dummy;
	int i,j;
	/* these 5 arrays come from class.c*/
	extern char *class_abbrevs[];
	extern int mage_subclasses[];
	extern int cleric_subclasses[];
	extern int rogue_subclasses[];
	extern int warrior_subclasses[];
	extern int class_ok_race[NUM_RACES][NUM_CLASSES];
	int * subclass_allowed;
	int max_subclasses;
d608 179
a786 122
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		return 0;	/* we have already started this quest..*/
	}
	else
	{
		dummy = quest_find_num(qname);
		if (dummy > 0)
		{
			if (strlen (subclass) == 0)
			{
			if (IS_SUBCLASS_QUEST(dummy))
			{
				return -7;
			}
			}
			else if (strlen(subclass) > 0)
			{
				/*
				 * note: we can only run one subclass quest
				 */
				curr = ch->quests;
				while (curr)
				{
					if (curr->quest_id & SUBCLASS_BIT)
					{
						return -3;
					}
					curr = curr->next;
				}
				/* we have a subclass abbr. now
				 * we need to get a value to describe
				 * it and add to dummy
				 * subclass is dependent on current class
				 * There exists an array in class.c of abbrevs
				 * which we will search for this abbrev, and use the
				 * index (which corresponds to the CLASS_* defined in
				 * structs.h) in the quest_id
				 */
				for (i=0; i < NUM_CLASSES && strn_cmp(subclass,strip_ansi(class_abbrevs[i]),3); i++);

				/* if i is NUM_CLASSES then we didn't actually find
				 * the destination class so FAIL
				 */
				if (i == NUM_CLASSES)
				{
					sprintf(buf,"QUEST ERROR: Non existant subclass %s",subclass);
					mudlog(buf,NRM,LVL_GOD,TRUE);
					return -4;
				}

				/* sanity check..can the current class become this subclass?*/
				switch (GET_CLASS(ch))
				{
					/* may be worth logging failures to match subclass attempts
					 * in the 'case' statements (which could occur if a script
					 * was wrong and tried to change a cleric to a necromancer for eg
					 */
					case CLASS_WARRIOR:	subclass_allowed = warrior_subclasses;
								max_subclasses = WARRIOR_SUBCLASSES;
								break;
					case CLASS_CLERIC:	subclass_allowed = cleric_subclasses;
								max_subclasses = CLERIC_SUBCLASSES;
								break;
								/* this is very confusing: dunno who named all the subclass
								 * stuff roguish when the base class is thief :-(
								 */
					case CLASS_ROGUE:	subclass_allowed = rogue_subclasses;
								max_subclasses = ROGUE_SUBCLASSES;
								break;
					case CLASS_MAGIC_USER:	subclass_allowed = mage_subclasses;
								max_subclasses = MAGE_SUBCLASSES;
								break;
					default:		return -8;/* not really worth logging as this could happen a lot..*/
								break;
				}

				/* our class permits this subclass ? */
				for (j=0; j < max_subclasses && subclass_allowed[j] != i; j++);
				if (j == max_subclasses)
					return -1;
				/* our race permits this subclass ? */
				/* note: i IS the subclass, j is the index into allowed
				 * subclasses derived from the baseclass
				 * ...confused yet? (I was :-(( )
				 */
				if (!class_ok_race[(int)GET_RACE(ch)][i])
					return -2;
				/* if ch->lev < min quest lev, message and return */
				if (GET_LEVEL(ch) < 5)
				{
					return -5;
				}
				/* if ch->lev > max quest lev, message and return */
				if ((GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_WARRIOR) ||
						(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_MAGIC_USER) ||
						(GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_ROGUE) ||
						(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_CLERIC))
				{
					return -6;
				}

				dummy |= (j << ARRAY_LOCN);/* j < 8, relative to current class...*/
			}
			CREATE(qlist,struct quest_list,1);
			qlist->quest_id = dummy;
			qlist->stage = QUEST_START;
			qlist->next = (struct quest_list *)NULL;

			/* traverse the list of quests and add at end*/
			curr = ch->quests;
			if (curr == (struct quest_list *) NULL)
				ch->quests = qlist;
			else
			{
				while (curr->next) curr = curr->next;
				curr->next = qlist;
			}
			
		}
		return dummy;
	}
a787 3
int quest_rewind(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
d789 60
a848 22
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		/*
		 * if current stage is 0 we have failed this quest...
		 * if current stage is 254 we have run out of stages
		 * We cannot rewind past the start
		 */
		if ((qlist->stage > QUEST_START) && (qlist->stage < QUEST_SUCCESS ))
		{
			qlist->stage --;
			return qlist->stage;
		}
		else
		{
			int rc=0;

			if (qlist->stage == QUEST_START)
				rc = -1;
			else if (qlist->stage == QUEST_FAILURE)
				rc = -2;
			else /*(qlist->stage == QUEST_SUCCESS)*/
				rc = -3;
a849 5
			return rc;
		}
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
a850 3
int quest_restart(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
d852 23
a874 11
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		/*
		 * if current stage is 0 we have failed this quest...
		 * if current stage is 254 we have run out of stages
		 */
		qlist->stage = QUEST_START;
		return qlist->stage;
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
d877 1
d891 16
a906 4
int quest_erase (char *qname, struct char_data *ch)
{
	struct quest_list *qlist,*prev;
	int qnum;
d908 1
a908 2
	qnum = quest_find_num(qname);
	qlist = ch->quests;
d910 30
a939 13
	fprintf(stderr, "Quest number s %d and player quest pointer is %p\n",qnum,(void*)qlist);
	if (qnum == 0 || qlist == (struct quest_list *)NULL)
		return 0;

	prev = qlist;
	while (qlist &&
		((!IS_SUBCLASS_QUEST(qlist->quest_id) && (qlist->quest_id != qnum)) ||
		(IS_SUBCLASS_QUEST(qlist->quest_id) && (qlist->quest_id & ~(SUBCLASS_MASK)) != qnum))
		)
	{
		prev = qlist;
		qlist = qlist->next;
	}
d941 9
a949 13
	/* sanity check..somehow we went off the end of the array?*/
	if (qlist == (struct quest_list *)NULL)
	{
		fprintf(stderr,"SANITY FAILED!\n");
		return 0;
	}

	if (qlist == ch->quests)
		ch->quests= qlist->next;
	else
		prev->next = qlist->next;

	free (qlist);
a950 2
	return 1;
}
d962 5
a966 3
int has_failed_quest(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
d968 1
a968 9
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		if (qlist->stage)
			return 0;
		else
			return 1;
	}
	else
		return 0;	/* quest doesnt exist!, or player didnt start it*/
d970 2
d981 2
a982 3
int has_completed_quest(char *qname,struct char_data *ch)
{
	struct quest_list *qlist;
d984 2
a985 7
	if ((qlist = quest_find_char(ch->quests,qname)))
	{
		if (qlist->stage == QUEST_SUCCESS)
			return 1;
		else
			return 0;
	}
d987 1
a987 1
	return 0;	/* quest doesnt exist!, or player didnt start it*/
d997 8
a1004 9
  char name[MAX_QNAME_LEN],maxst[10];
  int tst,myid,maxid,counter;
  FILE * fp;
  void boot_quests();
	/*
	 * check that valid info is given and that quest_id doesn't already exist
	 */
  if (ch->player.level <= LVL_GRGOD) {	/*103 and above can add questst*/
    send_to_char("Huh?!?\r\n", ch);
d1008 16
a1023 2
  /*
   * ok..so i am not checking very rigorously :-(
d1025 4
a1028 19
  argument = one_argument(argument, name);
  argument = one_argument(argument, maxst);
  if (strlen(name) == 0 || strlen(name) > MAX_QNAME_LEN || strlen(maxst) == 0)
  {
	  send_to_char("Syntax: qadd <name_max_35_chars> <max_stages> [ is_subclass ]\r\n",ch);
	  return;
  }
  /* ok syntax is fine, lets gen an ID for this quest
     we will go through the list and grab the first free id
     */
  myid = 0;
  while (isspace(*argument)) argument++;
  if (*argument == 'Y' || *argument == 'y' )
	  /* this will be a subclass quest so set the top bit
	   * and clear the mask which will be used to determin destination class
	   */
  {
	  maxid = ( MAX_SUBCLASS_QUEST_ID | SUBCLASS_BIT );
	  myid |= SUBCLASS_BIT;
d1031 7
a1037 2
  {
  	  maxid = MAX_QUEST_ID;
d1039 4
a1042 21
  for (counter=0; counter < max_quests; counter++)
  {
	  if (myid & SUBCLASS_BIT)
		  if( !(all_quests[counter].quest_id & SUBCLASS_BIT))
			  continue;

	myid++;
  	if (all_quests[counter].quest_id > myid)
  	{
	  	break;
  	}
  }
  /* we went through all the list and the were all consecutive...make a new one*/
  if (counter == max_quests)
	  myid++;

  /* just check it is in bounds */
  if (myid > maxid)
  {
	  send_to_char("No free quest ids are left, please talk to a mud admin\r\n",ch);
	  return;
d1045 3
a1047 6

  tst = atoi(maxst);
  if (tst == 0)
  {
	  send_to_char("Please specify max_stages as an int\r\n",ch);
	  return;
d1049 3
a1051 7
  /*
   * can't add a quest with an existing id...
   */
  if (real_quest(myid) != NOWHERE)
  {
	  send_to_char("A quest already exists with that id\r\n",ch);
	  return;
d1056 4
a1059 5
  */
  if((fp = fopen(ALL_QUEST_FILE,"w")) == NULL)
  {
  	log("Unable to open ALL_QUEST_FILE in qadd\r\n");
  	return;
d1062 4
a1065 7
  {
  	for (tst=0; (all_quests[tst].quest_id< myid) && (tst <max_quests) ;tst++)
  	{
  		fprintf(fp,"%s %d %d\n",all_quests[tst].quest_name,all_quests[tst].quest_id,all_quests[tst].maxstages);
  	}
  }
  fprintf(fp,"%s %d %d\n",name,myid,atoi(maxst));
d1067 3
a1069 6
  {
  	for (; tst < max_quests ;tst++)
  	{
  		fprintf(fp,"%s %d %d\n",all_quests[tst].quest_name,all_quests[tst].quest_id,all_quests[tst].maxstages);
  	}
  }
d1073 2
a1074 2
  * add the quest to global list
  */
d1076 10
a1085 1
	send_to_char("Quest successfully added\r\n",ch);
d1095 56
a1150 47
ACMD(do_qdel)
{
	int rmid,tst;
	FILE * fp;
	char name[MAX_QNAME_LEN];
	void boot_quests();

	if (ch->player.level <= LVL_GRGOD) {	/*103 and above can add questst*/
		send_to_char("Huh?!?\r\n", ch);
		return;
	}
	argument = one_argument(argument, name);
	if (strlen(name) == 0)
	{
		send_to_char("Syntax: qdel <quest_name>\r\n",ch);
		return;
	}
	if ((rmid = quest_find_num(name)))
	{
	/*
	* rewrite the quest file and drop this one
	*/
		if((fp = fopen(ALL_QUEST_FILE,"w")) == NULL)
		{
	  		log("Unable to open ALL_QUEST_FILE in qdel\r\n");
	  		return;
		}
		if (max_quests)
		{
	  		for (tst=0; tst <max_quests ;tst++)
	  		{
				if (all_quests[tst].quest_id != rmid)
	  				fprintf(fp,"%s %d %d\n",all_quests[tst].quest_name,all_quests[tst].quest_id,all_quests[tst].maxstages);
			}
		}
		fclose(fp);
	
	/*
	* add the quest to global list
	*/
		boot_quests();
		send_to_char("Quest successfully removed\r\n",ch);
	}
	else
	{
		send_to_char("That quest doesn't exist!\r\n",ch);
	}
d1180 4
@


1.26
log
@Fixed to return 0 when the variable is unset, as I had originally meant it to
This should keep the crashes down to a minimum.
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.25 2002/09/19 01:07:53 jjl Exp $
d418 4
a421 4
				if ((GET_LEVEL(ch) > 40 && GET_CLASS(ch) == CLASS_WARRIOR) ||
						(GET_LEVEL(ch) > 40 && GET_CLASS(ch) == CLASS_MAGIC_USER) ||
						(GET_LEVEL(ch) > 40 && GET_CLASS(ch) == CLASS_ROGUE) ||
						(GET_LEVEL(ch) > 40 && GET_CLASS(ch) == CLASS_CLERIC))
d797 4
@


1.25
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.24 2002/09/13 02:32:10 jjl Exp $
d121 1
a121 1
      return ""; 
d125 1
a125 1
      return ""; 
d797 3
@


1.24
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: quest.c,v 1.23 2002/06/17 15:43:33 rls Exp $
d101 96
d797 3
@


1.23
log
@Updated max subclass levels to 40 per Jeff's request. RLS: 06-07-2002
@
text
@d1 3
a3 1
// $Id: quest.c,v 1.22 2001/07/08 17:47:40 mtp Exp $
d422 1
a422 1
	fprintf(stderr, "Quest number s %d and player quest pointer is %p\n",qnum,qlist);
d699 91
a789 86
// $Log: quest.c,v $
// Revision 1.22  2001/07/08 17:47:40  mtp
// added quest erase to remove a quest from a player (non documented)
//
// Revision 1.21  2001/06/19 23:22:25  mtp
// moved error messages up a level to report which mob/room failed
//
// Revision 1.20  2001/04/01 21:59:31  mtp
// changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
//
// Revision 1.19  2001/02/12 23:26:43  mtp
// level check on quest_start
//
// Revision 1.18  2001/02/12 01:29:06  mtp
// feedback on quest completion (may need to change this?)
//
// Revision 1.17  2001/02/03 00:56:51  mtp
// do a race check before starting subclass quest
// also returing different codes so that calling procs can do something sensible
// on failure
//
// Revision 1.16  2000/11/22 01:51:17  mtp
// allow removeal of quests from global list with dqdel
// note: qdel removes from list but not players, their quest structs are
// managed on login
//
// Revision 1.15  2000/11/19 00:51:26  rsd
// Added more old log info from post logs before the log
// rcs string was added.  Noticed an interesting time bug
// I'm checking this file in Sat Nov 18 19:51:14 EST 2000
// I had to resync the time between the two boxes as
// xntp had barfed on rift.  Time time stamps on the file
// are way off though, more than the 15 minutes rift was
// off....
//
// Revision 1.14  2000/11/19 00:39:59  rsd
// Added the rlog information to the bottom of the file so it
// seems to be a continious series of comments.
//
// Revision 1.13  2000/11/19 00:26:58  rsd
// Another attempt to get logging information to appear
// at the bottom of the file
//
// Revision 1.12  2000/11/19 00:23:58  rsd
// Added the comment header, attempting to add RCS strings
//
// Revision 1.11  2000/11/15 00:30:19  mtp
// added confirmation of added quest
//
// Revision 1.10  2000/11/15 00:25:18  mtp
// auto numbering of quests
//
// Revision 1.9  2000/11/07 02:00:24  mtp
// removed some debug messages that slipped in..
//
// Revision 1.8  2000/11/07 01:59:00  mtp
// fixed little teeny buglet in the file writing..
//
// Revision 1.7  2000/11/07 01:49:37  mtp
// added a load of stuff to help with subclasses, and also changed some
// function defn to use unsigned short instead of int (which was giving
// some probs)
//
// Revision 1.6  2000/11/03 05:37:17  jimmy
// Removed the quest.h file from structs.h arg!! and placed it
// only in the appropriate files
// Updated the dependancies in the Makefile and created
// make supahclean.
//
// Revision 1.5  2000/10/31 23:26:43  mtp
// added qadd and qlist to manage new quests (no quest_remove yet)
//
// Revision 1.4  2000/10/27 00:08:07  mtp
// new quest code to handle start/complete/fail/advance and stage queries
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/02/01 03:42:04  mud
// dos2unix
// Indented slightly
// Tweaked comment header
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.22
log
@added quest erase to remove a quest from a player (non documented)
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.21 2001/06/19 23:22:25 mtp Exp mtp $
d320 4
a323 4
				if ((GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_WARRIOR) ||
						(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_MAGIC_USER) ||
						(GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_ROGUE) ||
						(GET_LEVEL(ch) > 45 && GET_CLASS(ch) == CLASS_CLERIC))
d698 3
@


1.21
log
@moved error messages up a level to report which mob/room failed
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.20 2001/04/01 21:59:31 mtp Exp $
d400 51
d698 3
@


1.20
log
@changed CLASS_THIEF to CLASS_ROGUE, since rogue is teh base not thief
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.19 2001/02/12 23:26:43 mtp Exp mtp $
d25 1
d93 1
a93 1
		sprintf (errbuf,"Attempt to find stage of non-existant quest %s",qname);
a146 1
			mudlog("attempt to complete already completed quest\r\n",NRM,LVL_GOD,TRUE);
a164 1
			mudlog("attempt to fail already completed quest\r\n",NRM,LVL_GOD,TRUE);
a175 1
	char errbuf[100];
d191 2
a192 2
				sprintf(errbuf,"Attempt to go beyond max configured stages (%d) for quest %s\r\n",maxstage,qname);
      				mudlog(errbuf, NRM, LVL_GOD, TRUE);
d198 2
d201 1
a201 1
				sprintf(errbuf,"tried to advance from stage %d in quest %s\r\n",QUEST_MAXSTAGE,qname);
d203 1
a203 1
				sprintf(errbuf,"tried to advance failed quest %s\n",qname);
d205 1
a205 2
      			mudlog(errbuf, NRM, LVL_GOD, TRUE);
			return 0;
a224 1
	char msgbuf[100];
d227 1
d229 1
d235 8
a242 1
			if (strlen(subclass) > 0)
a251 1
						mudlog("Attempt to start second subclass quest not allowed",NRM, LVL_GOD, TRUE);
d272 2
a273 2
					sprintf(msgbuf,"Attempt to run subclass quest for non-existant subclass %s",subclass);
					mudlog(msgbuf,NRM, LVL_GOD, TRUE);
d299 1
a299 1
					default:		return -4;/* not really worth logging as this could happen a lot..*/
a351 1
	char errbuf[100];
d367 2
d370 1
a370 1
				sprintf(errbuf,"tried to rewind from first stage in quest %s\r\n",qname);
d372 1
a372 1
				sprintf(errbuf,"tried to rewind failed quest %s (use restart)\r\n",qname);
d374 1
a374 1
				sprintf(errbuf,"tried to rewind completed quest %s (use restart)\r\n",qname);
d376 1
a376 2
      			mudlog(errbuf, NRM, LVL_GOD, TRUE);
			return 0;
d647 3
@


1.19
log
@level check on quest_start
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.16 2000/11/22 01:51:17 mtp Exp $
d287 1
a287 1
					case CLASS_THIEF:	subclass_allowed = rogue_subclasses;
d316 1
a316 1
						(GET_LEVEL(ch) > 25 && GET_CLASS(ch) == CLASS_THIEF) ||
d641 3
@


1.18
log
@feedback on quest completion (may need to change this?)
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.17 2001/02/03 00:56:51 mtp Exp mtp $
d308 13
d641 3
@


1.17
log
@do a race check before starting subclass quest
also returing different codes so that calling procs can do something sensible
on failure
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.16 2000/11/22 01:51:17 mtp Exp $
d150 2
d628 5
@


1.16
log
@allow removeal of quests from global list with dqdel
note: qdel removes from list but not players, their quest structs are
managed on login
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.15 2000/11/19 00:51:26 rsd Exp $
d221 4
d244 1
a244 1
						return 0;
d263 5
a267 1
					return 0;
d276 2
a277 3
					case CLASS_MAGIC_USER:	for(j=0;j<MAGE_SUBCLASSES && mage_subclasses[j] != i; j++);
								if (j == MAGE_SUBCLASSES)
									return 0;
d279 2
a280 3
					case CLASS_CLERIC:	for(j=0;j<CLERIC_SUBCLASSES && cleric_subclasses[j] != i; j++);
								if (j == CLERIC_SUBCLASSES)
									return 0;
d282 5
a286 3
					case CLASS_ROGUE:	for(j=0;j<ROGUE_SUBCLASSES && rogue_subclasses[j] != i; j++);
								if (j == ROGUE_SUBCLASSES)
									return 0;
d288 2
a289 3
					case CLASS_WARRIOR:	for(j=0;j<WARRIOR_SUBCLASSES && warrior_subclasses[j] != i; j++);
								if (j == WARRIOR_SUBCLASSES)
									return 0;
d291 1
a291 1
					default:		return 0;/* not really worth logging as this could happen a lot..*/
d294 13
d626 5
@


1.15
log
@Added more old log info from post logs before the log
rcs string was added.  Noticed an interesting time bug
I'm checking this file in Sat Nov 18 19:51:14 EST 2000
I had to resync the time between the two boxes as
xntp had barfed on rift.  Time time stamps on the file
are way off though, more than the 15 minutes rift was
off....
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.14 2000/11/19 00:39:59 rsd Exp $
d524 56
d606 9
@


1.14
log
@Added the rlog information to the bottom of the file so it
seems to be a continious series of comments.
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.13 2000/11/19 00:26:58 rsd Exp $
d550 4
d561 1
a561 1
// Revision 1.11
d564 1
a564 1
// Revision 1.10
d567 1
a567 1
// Revision 1.9
d570 1
a570 1
// Revision 1.8
d573 1
a573 1
// Revision 1.7
d578 1
a578 1
// Revision 1.6
d584 1
a584 1
// Revision 1.5
d587 1
a587 1
// Revision 1.4
d590 1
a590 1
// Revision 1.3
d593 1
a593 1
// Revision 1.2
d598 1
a598 1
// Revision 1.1
@


1.13
log
@Another attempt to get logging information to appear
at the bottom of the file
@
text
@d1 1
a1 1
// $Id: quest.c,v 1.12 2000/11/19 00:24:24 rsd Exp $
d549 48
a596 1
// $Log:$
@


1.12
log
@Added the comment header, attempting to add RCS strings
@
text
@d1 1
a1 1
// $Id:$
d549 1
a549 1
// hrmm
@


1.11
log
@added confirmation of added quest
@
text
@d1 11
a11 8
/*
 * name:	quest.c
 * created:	22 Oct 2000
 * author:	Matt Proctor for fierymud
 *
 * descr:	implementation of routines for handling quests
 *
 */
d548 2
@


1.10
log
@auto numbering of quests
@
text
@d518 1
@


1.9
log
@removed some debug messages that slipped in..
@
text
@d411 2
a412 2
  char name[MAX_QNAME_LEN],id[10],maxst[10];
  int tst,myid;
a426 1
  argument = one_argument(argument, id);
d428 1
a428 1
  if (strlen(name) == 0 || strlen(name) > MAX_QNAME_LEN || strlen(id) == 0 || strlen(maxst) == 0)
d430 1
a430 1
	  send_to_char("Syntax: qadd <name_max_35_chars> <id> <max_stages> [ is_subclass ]\r\n",ch);
d433 6
a438 18
  myid = atoi(id);
  if (myid == 0 || myid > MAX_QUEST_ID)
  {
	  char mybuf[100];
	  sprintf(mybuf,"Please specify id as an int of max value %d\r\n",MAX_QUEST_ID);
	  send_to_char(mybuf,ch);
	  return;
  }
  /* just a warning..not an error*/
  argument = one_argument(argument, id);
  if ((strlen(id) > 0) && (myid > MAX_SUBCLASS_QUEST_ID))
  {
	  char mybuf[100];
	  sprintf(mybuf,"This quest cannot be used as a subclass quest (max id < %d for that)\r\n",MAX_SUBCLASS_QUEST_ID);
	  send_to_char(mybuf,ch);
	  return;
  }
  else if (strlen(id) > 0)
d443 1
a444 1
	  myid &= ~(SUBCLASS_MASK); /* ~() for invers of mask..switch off*/
d446 27
d529 2
a530 1
	char msgbuf[50];
d534 2
d539 2
a540 1
		sprintf(msgbuf,"%d:\t%s (%d) %s\r\n",(all_quests[i].quest_id & ~(SUBCLASS_BIT)),all_quests[i].quest_name,all_quests[i].maxstages,(IS_SUBCLASS_QUEST(all_quests[i].quest_id))?"Subclass Quest":"Regular Quest");
@


1.8
log
@fixed little teeny buglet in the file writing..
@
text
@a223 1
		fprintf(stderr,"got the quest number (%d = %X)\n",(dummy & ~(SUBCLASS_BIT)),dummy);
a254 1
				fprintf(stderr,"In quest_start, retrieved i = %d (max = %d), name = %s (actually %s)\n",i,NUM_CLASSES,strip_ansi(class_abbrevs[i]),subclass);
@


1.7
log
@added a load of stuff to help with subclasses, and also changed some
function defn to use unsigned short instead of int (which was fgiving some probs)
@
text
@d485 1
a485 1
  for (tst=0; (all_quests[tst].quest_id< myid) && (tst <max_quests) ;tst++)
d487 4
a490 2

  	fprintf(fp,"%s %d %d\n",all_quests[tst].quest_name,all_quests[tst].quest_id,all_quests[tst].maxstages);
d493 1
a493 1
  for (; tst < max_quests ;tst++)
d495 4
a498 2

  	fprintf(fp,"%s %d %d\n",all_quests[tst].quest_name,all_quests[tst].quest_id,all_quests[tst].maxstages);
@


1.6
log
@Removed the quest.h file from structs.h arg!! and placed it
only in the appropriate files
Updated the dependancies in the Makefile and created
make supahclean.
@
text
@d31 1
a31 1
short quest_find_num(char *qname)
d62 1
a62 1
	short qnum;
d67 16
a82 1
		while (qlist && ((qlist->quest_id) != qnum))
d85 1
a85 1
		return qlist;
d90 1
a90 1
      		mudlog(errbuf, NRM, LVL_GOD, FALSE);
d143 1
a143 1
			mudlog("attempt to complete already completed quest\r\n",NRM,LVL_GOD,FALSE);
d160 1
a160 1
			mudlog("attempt to fail already completed quest\r\n",NRM,LVL_GOD,FALSE);
d189 1
a189 1
      				mudlog(errbuf, NRM, LVL_GOD, FALSE);
d200 1
a200 1
      			mudlog(errbuf, NRM, LVL_GOD, FALSE);
d207 1
a207 1
int quest_start(char *qname,struct char_data *ch)
d210 8
a217 1
	short dummy;
d224 1
d227 61
d307 49
d413 1
a413 1
  char name[35],id[10],maxst[10];
d431 1
a431 1
  if (strlen(name) == 0 || strlen(name) > 30 || strlen(id) == 0 || strlen(maxst) == 0)
d433 1
a433 1
	  send_to_char("Syntax: qadd <name_max_30_chars> <id> <max_stages>\r\n",ch);
d437 1
a437 1
  if (myid == 0)
d439 3
a441 1
	  send_to_char("Please specify id as an int\r\n",ch);
d444 18
d471 1
a471 1
  for (tst=0;tst <max_quests;tst++)
d473 2
a474 5
	  if (all_quests[tst].quest_id == myid)
	  {
		  send_to_char("A quest already exists with that id\r\n",ch);
		  return;
	  }
d478 3
a480 3
   * open the quest file and add this one to the end
   */
  if((fp = fopen(ALL_QUEST_FILE,"a")) == NULL)
d485 5
d491 5
d520 1
a520 1
		sprintf(msgbuf,"%d:\t%s (%d)\r\n",all_quests[i].quest_id,all_quests[i].quest_name,all_quests[i].maxstages);
@


1.5
log
@added qadd and qlist to manage new quests (no quest_remove yet)
@
text
@d18 1
@


1.4
log
@new quest code to handle start/complete/fail/advance and stage queries
@
text
@d46 1
a46 1
	for (count=0;str_cmp(all_quests[count].quest_name,"endofquests") ;count ++)
d73 1
a73 1
		sprintf (errbuf,"Attempt to find stage of non-existant quest %s\r\n",qname);
d94 7
a100 2
	if ((qlist = quest_find_char(ch->quests,qname)))
		return qlist->stage;
d102 1
a102 1
		return 0;	/* quest doesnt exist! or player didnt start it*/
d272 91
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 8
a8 14
// $Id$
/*********************************************************************
 *                                              NOW Part of FieryMUD *
 * Filename: Quest.c                                                 *
 *                                                                   *
 * Purpose:  Implements load_quest and related functions to provide  *
 *           (automated) run-time loading of quest mobs and objects  *
 *           as well as provide a method for instantly connecting    *
 *           quest zones to the world                                *
 *                                                                   *
 * Author:   Fingh of HubisMUD                                       *
 *                                                                   * 
 * Last Modified:[11/10/98] initial version                          *
 *********************************************************************/
a10 1

d15 48
d64 34
a97 133
/*++ 
 * Quests. Why? To encourage roleplaying and establish Hubis as a
 * persistent world, rather than just a static place to go hack and slash.
 * What about mogprogs?  Well, mobprogs certainly handle the majority of
 * the work in our quests, however one fundamental element missing from
 * a mobprog is the ability to load itself at runtime, without the
 * intervention of an imm.  With quests, we can connect a zone to the mud,
 * add quest mobiles and objects to any zone in the world, all at
 * run-time.
 --*/


#define QFLEN 8     // filename length, i.e. ddd.qst + null

extern struct room_data *world;

// function declarations
void load_quest(int number);
int parse_quest_file(FILE *quest_file);
void connect_rooms(int existing, int connection, int dir);
void loadquestMob(int mob_vnum, int room);
void loadquestObj(int objnum, int flag, int where);


// load the quest from the file by number
void load_quest(int number)
{
  FILE *quest_file;        
  char quest_file_name[QFLEN];  
  
  memset(quest_file_name, 0, QFLEN);
  sprintf(quest_file_name, "%s/%d.qst", QST_PREFIX, number);
  
  if (!(quest_file = fopen(quest_file_name, "r")))
    {
      mudlog("SYSERR: attempting to load non-existant quest", BRF, LVL_BUILDER, TRUE);
      return;
    }
  
  if (!parse_quest_file(quest_file))
    {
      mudlog("SYSERR: Quest NOT loaded", BRF, LVL_BUILDER, TRUE);
      return;
    } 
} // end load_quest()


int parse_quest_file(FILE * file)
{
  char line[256];       // longest line allowed in most editors  
  int  value[3];       // there are three values for EVERY actor type
  char actor_type;
  
  for(;;)
    {
      get_line(file, line);
      
      // watch for end of file marker
      if(*line == '$')
	return FALSE;
      
      // catch unexpected end of file
      if(feof(file))
	{
	  mudlog("SYSERR: Unexpected EOF in file.", BRF, LVL_BUILDER, TRUE);  
	  return FALSE;
	}
      
      // read the actor data....all types have same format in file
      if(sscanf(line, "%c %d %d %d", &actor_type, &value[0], &value[1], &value[2]) != 4)
	{
	  mudlog("SYSERR: Invalid read in quest file.", BRF, LVL_BUILDER, TRUE);  
	  return FALSE;
	}
      
      switch(actor_type)
	{
	case 'c':
	case 'C':
	  connect_rooms(value[0], value[1], value[2]);
	  break;
	case 'm':
	case 'M':
	  loadquestMob(value[0], value[1]);
	  break;
	case 'o':
	case 'O':
	  loadquestObj(value[0], value[1], value[2]);
	  break;
	default: 
	  mudlog("SYSERR: Garbage data in quest file.", BRF, LVL_BUILDER, TRUE);  
	  return FALSE;
	}
    }
  
  return TRUE;
}


void connect_rooms(int existing, int connection, int dir)
{
  int opposite_dir = -1;
  
  world[real_room(existing)].dir_options[dir] = real_room[connection];
  world[real_room(connection)].dir_options[(dir + 2) % 4] = real_room[existing];
}


void loadquestMob(int mob_vnum, int room)
{
  struct char_data *mob;
  
  mob = read_mobile(mob_vnum, VIRTUAL);
  char_to_room(mob,  real_room(room));
}


void loadquestObj(int objnum, int flag, int where)
{
  struct obj_data *obj;
  struct char_data *target;
  
  obj = read_object(objnum, VIRTUAL);
  
  if(flag)
    {
      target = read_mobile(where, VIRTUAL);
      obj_to_char(obj, target);
    }
  else
    {
      obj_to_room(obj, real_room(where));
    }
d100 166
a266 1
// $Log$
@


1.2
log
@dos2unix
Indented slightly
Tweaked comment header
@
text
@d1 1
d159 1
@


1.1
log
@Initial revision
@
text
@d1 13
a13 15
/*++
*******************************************************************
*
* Filename: Quest.c
*
* Purpose:  Implements load_quest and related functions to provide
*           (automated) run-time loading of quest mobs and objects
*           as well as provide a method for instantly connecting 
*           quest zones to the world
*
* Author:   Fingh @@ Hubis
*
* Last Modified:[11/10/98] initial version
*******************************************************************
--*/
d31 1
a31 1
--*/
d51 1
a51 1

d56 5
a60 5
  {
     mudlog("SYSERR: attempting to load non-existant quest", BRF, LVL_BUILDER, TRUE);
     return;
  }

d62 4
a65 4
  {
     mudlog("SYSERR: Quest NOT loaded", BRF, LVL_BUILDER, TRUE);
     return;
  } 
d74 1
a74 1

a75 9
  {
    get_line(file, line);

    // watch for end of file marker
    if(*line == '$')
      return FALSE;

    // catch unexpected end of file
    if(feof(file))
d77 38
a114 28
      mudlog("SYSERR: Unexpected EOF in file.", BRF, LVL_BUILDER, TRUE);  
      return FALSE;
    }
    
    // read the actor data....all types have same format in file
    if(sscanf(line, "%c %d %d %d", &actor_type, &value[0], &value[1], &value[2]) != 4)
    {
      mudlog("SYSERR: Invalid read in quest file.", BRF, LVL_BUILDER, TRUE);  
      return FALSE;
    }

    switch(actor_type)
    {
    case 'c':
    case 'C':
      connect_rooms(value[0], value[1], value[2]);
      break;
    case 'm':
    case 'M':
      loadquestMob(value[0], value[1]);
      break;
    case 'o':
    case 'O':
      loadquestObj(value[0], value[1], value[2]);
      break;
    default: 
      mudlog("SYSERR: Garbage data in quest file.", BRF, LVL_BUILDER, TRUE);  
      return FALSE;
a115 1
  }
d124 1
a124 1

d129 1
a129 1
  
d133 1
a133 1

d143 1
a143 1

d145 1
a145 1

d147 4
a150 4
  {
    target = read_mobile(where, VIRTUAL);
    obj_to_char(obj, target);
  }
d152 3
a154 3
  {
    obj_to_room(obj, real_room(where));
  }
d156 1
a156 1
      
@
