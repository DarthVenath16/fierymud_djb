head	1.26;
access;
symbols;
locks; strict;
comment	@ * @;


1.26
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.05.18.58.54;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.22.20.12.42;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.22.20.05.59;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.22.19.50.24;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.21.15.58.34;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.18.00.34.11;	author myc;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.28.01.18.21;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.23.00.57.04;	author mtp;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.03.51.01;	author rsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.14.11.12.40;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.07.07.42.05;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.01.08.28;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/*
** dg_olc.c: this source file is used in extending Oasis style OLC for
** dg-scripts onto a CircleMUD that already has dg-scripts (as released
** by Mark Heilpern on 1/1/98) implemented.
**
** Parts of this file by Chris Jacobson of _Aliens vs Predator: The MUD_
*/


#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "olc.h"
#include "dg_olc.h"
#include "dg_event.h"

/* declare externally defined globals */
extern struct index_data **trig_index;
extern char *trig_types[], *otrig_types[], *wtrig_types[];
extern struct descriptor_data *descriptor_list;
extern struct trig_data *trigger_list;
extern int top_of_trigt;
extern struct zone_data *zone_table;


/* prototype externally defined functions */
void trig_data_copy(trig_data *this, const trig_data *trg);
void free_varlist(struct trig_var_data *vd);

void trigedit_disp_menu(struct descriptor_data *d);
void trigedit_save(struct descriptor_data *d);

/* copy an entire script from one holder (mob/obj/room) to another */
void script_copy(void *dst, void *src, int type)
{
  struct script_data *s_src = NULL;
  struct script_data *s_dst = NULL;
  trig_data *t_src, *t_dst;

  /* find the scripts of the source and destination */
  switch (type)
  {
    case MOB_TRIGGER:
      s_src = SCRIPT((struct char_data *)src);
      s_dst = SCRIPT((struct char_data *)dst);
      ((struct char_data *)dst)->proto_script =
        ((struct char_data *)src)->proto_script;
     break;
    case OBJ_TRIGGER:
      s_src = SCRIPT((struct obj_data *)src);
      s_dst = SCRIPT((struct obj_data *)dst);
      ((struct obj_data *)dst)->proto_script =
        ((struct obj_data *)src)->proto_script;
      break;
    case WLD_TRIGGER:
      s_src = SCRIPT((struct room_data *)src);
      s_dst = SCRIPT((struct room_data *)dst);
      ((struct room_data *)dst)->proto_script =
        ((struct room_data *)src)->proto_script;
      break;
    default:
      log("SYSERR: Unknown type code sent to script_copy()!");
      break;
  }

  /* make sure the dst doesnt already have a script       */
  /* if it does, delete it                                */
  if (s_dst) extract_script(s_dst);

  /* copy the scrip data */
  s_dst->types = s_src->types;
  t_src = TRIGGERS(s_src);
  while (t_src)
  {
    CREATE(t_dst, trig_data, 1);
    if (!TRIGGERS(s_dst)) TRIGGERS(s_dst) = t_dst;
    trig_data_copy(t_dst, t_src);
    t_dst = t_dst->next;
    t_src = t_src->next;
  }

}

/* called when a mob or object is being saved to disk, so its script can */
/* be saved */
void script_save_to_disk(FILE *fp, void *item, int type)
{
  struct trig_proto_list *t;

  if (type==MOB_TRIGGER)
    t = ((struct char_data *)item)->proto_script;
  else if (type==OBJ_TRIGGER)
    t = ((struct obj_data *)item)->proto_script;
  else if (type==WLD_TRIGGER)
    t = ((struct room_data *)item)->proto_script;
  else {
    log("SYSERR: Invalid type passed to script_save_mobobj_to_disk()");
    return;
  }

  while (t)
  {
    fprintf(fp,"T %d\n", t->vnum);
    t = t->next;
  }
}


void trigedit_setup_new(struct descriptor_data *d)
{
  struct trig_data *trig;

  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);

  trig->nr = -1;

  /*
   * Set up some defaults
   */
  trig->name = str_dup("new trigger");
  trig->trigger_type = MTRIG_GREET;

  /* cmdlist will be a large char string until the trigger is saved */
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d),
    "say My trigger commandlist is not complete!\r\n");
  trig->narg = 100;

  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */

  trigedit_disp_menu(d);
}

void trigedit_setup_existing(struct descriptor_data *d, int rtrg_num)
{
  struct trig_data *trig;
  struct cmdlist_element *c;

  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);

  trig_data_copy(trig, trig_index[rtrg_num]->proto);

  /* convert cmdlist to a char string */
  c = trig->cmdlist;
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d), "");

  while (c)
  {
    strcat(OLC_STORAGE(d), c->cmd);
    strcat(OLC_STORAGE(d), "\r\n");
    c = c->next;
  }
  /* now trig->cmdlist is something to pass to the text editor */
  /* it will be converted back to a real cmdlist_element list later */

  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */

  trigedit_disp_menu(d);
}


void trigedit_disp_menu(struct descriptor_data *d)
{
  struct trig_data *trig = OLC_TRIG(d);
  char *attach_type;
  char trgtypes[256];

  get_char_cols(d->character);

  if (trig->attach_type==OBJ_TRIGGER) {
    attach_type = "Objects";
    sprintbit(GET_TRIG_TYPE(trig), otrig_types, trgtypes);
  } else if (trig->attach_type==WLD_TRIGGER) {
    attach_type = "Rooms";
    sprintbit(GET_TRIG_TYPE(trig), wtrig_types, trgtypes);
  } else {
    attach_type = "Mobiles";
    sprintbit(GET_TRIG_TYPE(trig), trig_types, trgtypes);
  }

  sprintf(buf,
#if defined(CLEAR_SCREEN)
"[H[J"
#endif

  "Trigger Editor [%s%d%s]\r\n\r\n"
  "%s1)%s Name         : %s%s\r\n"
  "%s2)%s Intended for : %s%s\r\n"
  "%s3)%s Trigger types: %s%s\r\n"
  "%s4)%s Numberic Arg : %s%d\r\n"
  "%s5)%s Arguments    : %s%s\r\n"
  "%s6)%s Commands:\r\n%s%s\r\n"
  "%sQ)%s Quit\r\n"
  "Enter Choice :",

  grn, OLC_NUM(d), nrm, 			/* vnum on the title line */
  grn, nrm, yel, GET_TRIG_NAME(trig),		/* name                   */
  grn, nrm, yel, attach_type,			/* attach type            */
  grn, nrm, yel, trgtypes,			/* greet/drop/etc         */
  grn, nrm, yel, trig->narg,			/* numeric arg            */
  grn, nrm, yel, trig->arglist,			/* strict arg             */
  grn, nrm, cyn, OLC_STORAGE(d),		/* the command list       */
  grn, nrm);                                    /* quit colors            */

  send_to_char(buf, d->character);
  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
}

void trigedit_disp_types(struct descriptor_data *d)
{
  int i, columns = 0;
  char **types;

  switch(OLC_TRIG(d)->attach_type)
  {
    case WLD_TRIGGER:
      types = wtrig_types;
      break;
    case OBJ_TRIGGER:
      types = otrig_types;
      break;
    case MOB_TRIGGER:
    default:
      types = trig_types;
      break;
  }

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_TRIG_TYPE_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, types[i],
              !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_TRIG_TYPE(OLC_TRIG(d)), types, buf1);
  sprintf(buf, "\r\nCurrent types : %s%s%s\r\nEnter type (0 to quit) : ",
                cyn, buf1, nrm);
  send_to_char(buf, d->character);

}

void trigedit_parse(struct descriptor_data *d, char *arg)
{
  int i = 0;

  switch (OLC_MODE(d)) {
    case TRIGEDIT_MAIN_MENU:
     switch (tolower(*arg)) {
       case 'q':
         if (OLC_VAL(d)) { /* Anything been changed? */
           if (!GET_TRIG_TYPE(OLC_TRIG(d))) {
             send_to_char("Invalid Trigger Type! Answer a to abort quit!\r\n",
               d->character);
           }
           send_to_char("Do you wish to save the changes to the trigger? (y/n): ",
             d->character);
           OLC_MODE(d) = TRIGEDIT_CONFIRM_SAVESTRING;
         } else
           cleanup_olc(d, CLEANUP_ALL);
           return;
         case '1':
           OLC_MODE(d) = TRIGEDIT_NAME;
           send_to_char("Name: ", d->character);
           break;
         case '2':
           OLC_MODE(d) = TRIGEDIT_INTENDED;
           send_to_char("0: Mobiles, 1: Objects, 2: Rooms: ", d->character);
           break;
         case '3':
           OLC_MODE(d) = TRIGEDIT_TYPES;
           trigedit_disp_types(d);
           break;
         case '4':
           OLC_MODE(d) = TRIGEDIT_NARG;
           send_to_char("Numeric argument: ", d->character);
           break;
         case '5':
           OLC_MODE(d) = TRIGEDIT_ARGUMENT;
           send_to_char("Argument: ", d->character);
           break;
         case '6':
           OLC_MODE(d) = TRIGEDIT_COMMANDS;
           send_to_char(
             "Enter trigger commands: (/s saves /h for help)\r\n\r\n",
             d->character);
           d->backstr = NULL;
           if (OLC_STORAGE(d)) {
             send_to_char(OLC_STORAGE(d), d->character);
             d->backstr = str_dup(OLC_STORAGE(d));
           }
           d->str = &OLC_STORAGE(d);
           d->max_str = MAX_CMD_LENGTH;
           d->mail_to = 0;
           OLC_VAL(d) = 1;

           break;
         default:
           trigedit_disp_menu(d);
           return;
     }
     return;

    case TRIGEDIT_CONFIRM_SAVESTRING:
      switch(tolower(*arg)) {
        case 'y':
          trigedit_save(d);
          sprintf(buf, "OLC: %s edits trigger %d", GET_NAME(d->character),
            OLC_NUM(d));
          mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
          /* fall through */
        case 'n':
          cleanup_olc(d, CLEANUP_ALL);
          return;
        case 'a': /* abort quitting */
          break;
        default:
          send_to_char("Invalid choice!\r\n", d->character);
          send_to_char("Do you wish to save the trigger? : ", d->character);
          return;
      }
      break;

    case TRIGEDIT_NAME:
      if (OLC_TRIG(d)->name)
        free(OLC_TRIG(d)->name);
      OLC_TRIG(d)->name = str_dup((arg && *arg) ? arg : "undefined");
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_INTENDED:
      if ((atoi(arg)>=MOB_TRIGGER) || (atoi(arg)<=WLD_TRIGGER))
        OLC_TRIG(d)->attach_type = atoi(arg);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_NARG:
      OLC_TRIG(d)->narg = atoi(arg);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_ARGUMENT:
      OLC_TRIG(d)->arglist = (*arg?str_dup(arg):NULL);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_TYPES:
      if ((i = atoi(arg)) == 0)
        break;
      else if (!((i < 0) || (i > NUM_TRIG_TYPE_FLAGS)))
        TOGGLE_BIT((GET_TRIG_TYPE(OLC_TRIG(d))), 1 << (i - 1));
      OLC_VAL(d)++;
      trigedit_disp_types(d);
      return;

    case TRIGEDIT_COMMANDS:
      break;

  }

  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
  trigedit_disp_menu(d);
}

/*
** print out the letter codes pertaining to the bits set in 'data'
*/
void sprintbits(int data, char *dest)
{
  int i;
  char *p = dest;

  for (i=0; i<32; i++) {
    if (data & (1<<i)) {
      *p = ((i<=25)?('a'+i):('A'+i));
      p++;
    }
  }
  *p = '\0';
}


/* save the zone's triggers to internal memory and to disk */
void trigedit_save(struct descriptor_data *d)
{
  int trig_rnum, i;
  int found = 0;
  char *s;
  trig_data *proto;
  trig_data *trig = OLC_TRIG(d);
  trig_data *live_trig;
  struct cmdlist_element *cmd, *next_cmd;
  struct index_data **new_index;
  struct descriptor_data *dsc;
  FILE *trig_file;
  int zone, top;
  char buf[MAX_CMD_LENGTH];
  char bitBuf[MAX_INPUT_LENGTH];
  char fname[MAX_INPUT_LENGTH];
  char logbuf[MAX_INPUT_LENGTH];


  if ((trig_rnum = real_trigger(OLC_NUM(d))) != -1) {
    proto = trig_index[trig_rnum]->proto;
    for (cmd = proto->cmdlist; cmd; cmd = next_cmd) {
      next_cmd = cmd->next;
      if (cmd->cmd)
        free(cmd->cmd);
      free(cmd);
    }


    free(proto->arglist);
    free(proto->name);

    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cmd = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      cmd->cmd = str_dup(s);
    }

    /* make the prorotype look like what we have */
    trig_data_copy(proto, trig);

    /* go through the mud and replace existing triggers         */
    live_trig = trigger_list;
    while (live_trig)
    {
      if (GET_TRIG_RNUM(live_trig) == trig_rnum) {
        if (live_trig->arglist) {
          free(live_trig->arglist);
          live_trig->arglist = NULL;
        }
        if (live_trig->name) {
          free(live_trig->name);
          live_trig->name = NULL;
        }

        if (proto->arglist)
          live_trig->arglist = str_dup(proto->arglist);
        if (proto->name)
          live_trig->name = str_dup(proto->name);

        live_trig->cmdlist = proto->cmdlist;
        live_trig->curr_state = live_trig->cmdlist;
        live_trig->trigger_type = proto->trigger_type;
        live_trig->attach_type = proto->attach_type;
        live_trig->narg = proto->narg;
        live_trig->data_type = proto->data_type;
        live_trig->depth = 0;
        live_trig->wait_event = NULL;
        if (GET_TRIG_WAIT(live_trig))
          remove_event(GET_TRIG_WAIT(live_trig));
        free_varlist(live_trig->var_list);
      }

      live_trig = live_trig->next_in_world;
    }
  } else {
    /* this is a new trigger */
    CREATE(new_index, struct index_data *, top_of_trigt + 2);

    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cmd = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      cmd->cmd = str_dup(s);
    }

    for (i = 0; i < top_of_trigt; i++) {
      if (!found) {
        if (trig_index[i]->virtual > OLC_NUM(d)) {
          found = TRUE;
          trig_rnum = i;

          CREATE(new_index[trig_rnum], struct index_data, 1);
          GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;
          new_index[trig_rnum]->virtual = OLC_NUM(d);
          new_index[trig_rnum]->number = 0;
          new_index[trig_rnum]->func = NULL;
          CREATE(proto, struct trig_data, 1);
          new_index[trig_rnum]->proto = proto;
          trig_data_copy(proto, trig);

          if (trig->name)
            proto->name = str_dup(trig->name);
          if (trig->arglist)
            proto->arglist = str_dup(trig->arglist);

          new_index[trig_rnum + 1] = trig_index[trig_rnum];

          proto = trig_index[trig_rnum]->proto;
          proto->nr = trig_rnum + 1;
        } else {
          new_index[i] = trig_index[i];
        }
      } else {
         new_index[i + 1] = trig_index[i];
         proto = trig_index[i]->proto;
         proto->nr = i + 1;
      }
    }

    if (!found) {
      trig_rnum = i;
      CREATE(new_index[trig_rnum], struct index_data, 1);
      GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;
      new_index[trig_rnum]->virtual = OLC_NUM(d);
      new_index[trig_rnum]->number = 0;
      new_index[trig_rnum]->func = NULL;

      CREATE(proto, struct trig_data, 1);
      new_index[trig_rnum]->proto = proto;
      trig_data_copy(proto, trig);

      if (trig->name)
        proto->name = str_dup(trig->name);
      if (trig->arglist)
        proto->arglist = str_dup(trig->arglist);
    }

    free(trig_index);

    trig_index = new_index;
    top_of_trigt++;

    /* HERE IT HAS TO GO THROUGH AND FIX ALL SCRIPTS/TRIGS OF HIGHER RNUM */
    for (live_trig = trigger_list; live_trig; live_trig = live_trig->next_in_world)
      if (GET_TRIG_RNUM(live_trig) > trig_rnum)
        GET_TRIG_RNUM(live_trig)++;

    /*
     * Update other trigs being edited.
     */
     for (dsc = descriptor_list; dsc; dsc = dsc->next)
       if (dsc->connected == CON_TRIGEDIT)
         if (GET_TRIG_RNUM(OLC_TRIG(dsc)) >= trig_rnum)
           GET_TRIG_RNUM(OLC_TRIG(dsc))++;

  }

  /* now write the trigger out to disk, along with the rest of the  */
  /* triggers for this zone, of course                              */
  /* note: we write this to disk NOW instead of letting the builder */
  /* have control because if we lose this after having assigned a   */
  /* new trigger to an item, we will get SYSERR's upton reboot that */
  /* could make things hard to debug.                               */

  zone = zone_table[OLC_ZNUM(d)].number;
  top = zone_table[OLC_ZNUM(d)].top;

#ifdef CIRCLE_MAC
  sprintf(fname, "%s:%i.new", TRG_PREFIX, zone);
#else
  sprintf(fname, "%s/%i.new", TRG_PREFIX, zone);
#endif

  if (!(trig_file = fopen(fname, "w"))) {
    sprintf(logbuf,"SYSERR: OLC: Can't open trig file \"%s\"", fname);
    mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    return;
  }

  for (i = zone * 100; i <= top; i++) {
    if ((trig_rnum = real_trigger(i)) != -1) {
      trig = trig_index[trig_rnum]->proto;

      if (fprintf(trig_file, "#%d\n", i) < 0) {
        sprintf(logbuf, "SYSERR: OLC: Can't write trig file!");
        mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
        fclose(trig_file);
        return;
      }
      sprintbits(GET_TRIG_TYPE(trig), bitBuf);
      fprintf(trig_file,      "%s~\n"
                              "%d %s %d\n"
                              "%s~\n",
           (GET_TRIG_NAME(trig)) ? (GET_TRIG_NAME(trig)) : "unknown trigger",
           trig->attach_type,
           bitBuf, GET_TRIG_NARG(trig),
           GET_TRIG_ARG(trig) ? GET_TRIG_ARG(trig) : "");

      /* Build the text for the script */
      strcpy(buf,"");
      for (cmd = trig->cmdlist; cmd; cmd = cmd->next) {
        strcat(buf, cmd->cmd);
        strcat(buf, "\r\n");
      }

      if (!buf[0])
        strcpy(buf, "* Empty script");

      fprintf(trig_file, "%s~\n", buf);
      *buf = '\0';
    }
  }

  fprintf(trig_file, "$~\n");
  fclose(trig_file);

#ifdef CIRCLE_MAC
  sprintf(buf, "%s:%d.trg", TRG_PREFIX, zone);
#else
  sprintf(buf, "%s/%d.trg", TRG_PREFIX, zone);
#endif

  rename(fname, buf);
}

void dg_olc_script_free(struct descriptor_data *d)
{
  struct trig_proto_list *editscript, *prevscript;

  editscript = OLC_SCRIPT(d);
  while (editscript) {
    prevscript = editscript;
    editscript = editscript->next;
    free(prevscript);
  }
}


void dg_olc_script_copy(struct descriptor_data *d)
{
  struct trig_proto_list *origscript, *editscript;

  if (OLC_ITEM_TYPE(d)==MOB_TRIGGER)
    origscript = OLC_MOB(d)->proto_script;
  else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER)
    origscript = OLC_OBJ(d)->proto_script;
  else origscript = OLC_ROOM(d)->proto_script;

  if (origscript) {
    CREATE(editscript, struct trig_proto_list, 1);
    OLC_SCRIPT(d) = editscript;

    while (origscript) {
      editscript->vnum = origscript->vnum;
      origscript = origscript->next;
      if (origscript)
        CREATE(editscript->next, struct trig_proto_list, 1);
      editscript = editscript->next;
    }
  } else
      OLC_SCRIPT(d) = NULL;
}

void dg_script_menu(struct descriptor_data *d)
{
  struct trig_proto_list *editscript;
  int i = 0;

  /* make sure our input parser gets used */
  OLC_MODE(d) = OLC_SCRIPT_EDIT;
  OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;


#if defined(CLEAR_SCREEN) /* done wierd to compile with the vararg send() */
#define FMT    "[H[J     Script Editor\r\n\r\n     Trigger List:\r\n"
#else
#define FMT    "     Script Editor\r\n\r\n     Trigger List:\r\n"
#endif
  send_to_char(FMT,d->character);
#undef FMT

  editscript = OLC_SCRIPT(d);
  while (editscript) {
    sprintf(buf,"     %2d) [%s%d%s] %s%s%s", ++i, cyn,
      editscript->vnum, nrm, cyn,
      trig_index[real_trigger(editscript->vnum)]->proto->name, nrm);
    send_to_char(buf, d->character);
    if (trig_index[real_trigger(editscript->vnum)]->proto->attach_type !=
        OLC_ITEM_TYPE(d))
      sprintf(buf,"   %s** Mis-matched Trigger Type **%s\r\n",grn,nrm);
    else
      sprintf(buf,"\r\n");
    send_to_char(buf, d->character);

    editscript = editscript->next;
  }
  if (i==0) send_to_char("     <none>\r\n", d->character);

  sprintf(buf, "\r\n"
    " %sN%s)  New trigger for this script\r\n"
    " %sD%s)  Delete a trigger in this script\r\n"
    " %sX%s)  Exit Script Editor\r\n\r\n"
    "     Enter choice :",
    grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf,d->character);
}

int dg_script_edit_parse(struct descriptor_data *d, char *arg)
{
  struct trig_proto_list *trig, *currtrig;
  int count, pos, vnum;

  switch(OLC_SCRIPT_EDIT_MODE(d)) {
    case SCRIPT_MAIN_MENU:
      switch(tolower(*arg)) {
        case 'x':
          if (OLC_ITEM_TYPE(d)==MOB_TRIGGER) {
            trig = OLC_MOB(d)->proto_script;
            OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
          } else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER) {
            trig = OLC_OBJ(d)->proto_script;
            OLC_OBJ(d)->proto_script = OLC_SCRIPT(d);
          } else {
            trig = OLC_ROOM(d)->proto_script;
            OLC_ROOM(d)->proto_script = OLC_SCRIPT(d);
          }

          while (trig) {
            currtrig = trig->next;
            free(trig);
            trig = currtrig;
          }
          return 0;
        case 'n':
          send_to_char("\r\nPlease enter position, vnum   (ex: 1, 200):",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_NEW_TRIGGER;
          break;
        case 'd':
          send_to_char("     Which entry should be deleted?  0 to abort :",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_DEL_TRIGGER;
          break;
      }
      return 1;

    case SCRIPT_NEW_TRIGGER:
      vnum = -1;
      count = sscanf(arg,"%d, %d",&pos,&vnum);
      if (count==1) {
        vnum = pos;
        pos = 999;
      }

      if (pos<=0) break; /* this aborts a new trigger entry */

      if (vnum==0) break; /* this aborts a new trigger entry */

      if (real_trigger(vnum)<0) {
        send_to_char("Invalid Trigger VNUM!\r\n"
            "Please enter position, vnum   (ex: 1, 200):",
            d->character);
        return 1;
      }

      /* add the new info in position */
      currtrig = OLC_SCRIPT(d);
      CREATE(trig, struct trig_proto_list, 1);
      trig->vnum = vnum;

      if (pos==1 || !currtrig) {
        trig->next = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = trig;
      } else {
        while (currtrig->next && --pos) {
          currtrig = currtrig->next;
        }
        trig->next = currtrig->next;
        currtrig->next = trig;
      }
      OLC_VAL(d)++;
      break;

    case SCRIPT_DEL_TRIGGER:
      pos = atoi(arg);
      if (pos<=0) break;

      if (pos==1 && OLC_SCRIPT(d)) {
        OLC_VAL(d)++;
        currtrig = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = currtrig->next;
        free(currtrig);
        break;
      }

      pos--;
      currtrig = OLC_SCRIPT(d);
      while (--pos && currtrig) currtrig = currtrig->next;
      /* now curtrig points one before the target */
      if (currtrig && currtrig->next) {
        OLC_VAL(d)++;
        trig = currtrig->next;
        currtrig->next = trig->next;
        free(trig);
      }
      break;
  }

  dg_script_menu(d);
  return 1;
}
@


1.26
log
@Fix possible use of uninitialized variable.
@
text
@/***************************************************************************
 * $Id: dg_olc.c,v 1.25 2008/08/18 01:35:38 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *  File: dg_olc.c                                        Part of FieryMUD * 
 * Usage: This source file is used in extending Oasis style OLC for        *
 *        dg-scripts onto a CircleMUD that already has dg-scripts (as      *
 *        released by Mark Heilpern on 1/1/98) implemented.                *
 * Parts of this file by Chris Jacobson of _Aliens vs Predator: The MUD_   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "olc.h"
#include "dg_olc.h"
#include "events.h"
#include "math.h"
#include "interpreter.h"
#include "stack.h"
#include "modify.h"

/* prototype externally defined functions */
void trig_data_copy(trig_data *this, const trig_data *trg);

void trigedit_disp_menu(struct descriptor_data *d);
void trigedit_save(struct descriptor_data *d);

/* called when a mob or object is being saved to disk, so its script can */
/* be saved */
void script_save_to_disk(FILE *fp, void *item, int type)
{
  struct trig_proto_list *t;
  
  if (type==MOB_TRIGGER)
    t = ((struct char_data *)item)->proto_script;
  else if (type==OBJ_TRIGGER)
    t = ((struct obj_data *)item)->proto_script;
  else if (type==WLD_TRIGGER)
    t = ((struct room_data *)item)->proto_script;
  else {
    log("SYSERR: Invalid type passed to script_save_mobobj_to_disk()");
    return;
  }
  
  while (t)
    {
      fprintf(fp,"T %d\n", t->vnum);
      t = t->next;
    }
}


void trigedit_setup_new(struct descriptor_data *d)
{
  struct trig_data *trig;
  
  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);
  
  trig->nr = -1;
  
  /*
   * Set up some defaults
   */ 
  trig->name = strdup("new trigger");
  trig->trigger_type = MTRIG_GREET;
  
  /* cmdlist will be a large char string until the trigger is saved */
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d),
	 "say My trigger commandlist is not complete!\r\n");
  trig->narg = 100;
  
  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  
  trigedit_disp_menu(d);
}

void trigedit_setup_existing(struct descriptor_data *d, int rtrg_num)
{
  struct trig_data *trig;
  struct cmdlist_element *c;
  
  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);
  
  trig_data_copy(trig, trig_index[rtrg_num]->proto);
  
  /* convert cmdlist to a char string */
  c = trig->cmdlist;
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d), "");
  
  while (c)
    {
      strcat(OLC_STORAGE(d), c->cmd);
      strcat(OLC_STORAGE(d), "\r\n");
      c = c->next;
    }
  /* now trig->cmdlist is something to pass to the text editor */
  /* it will be converted back to a real cmdlist_element list later */
  
  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  
  trigedit_disp_menu(d);
}


void trigedit_disp_menu(struct descriptor_data *d)
{
  struct trig_data *trig = OLC_TRIG(d);
  char *attach_type;
  char trgtypes[256];
  
  get_char_cols(d->character);
  
  if (trig->attach_type==OBJ_TRIGGER) {
    attach_type = "Objects";
    sprintbit(GET_TRIG_TYPE(trig), otrig_types, trgtypes);
  } else if (trig->attach_type==WLD_TRIGGER) {
    attach_type = "Rooms";
    sprintbit(GET_TRIG_TYPE(trig), wtrig_types, trgtypes);
  } else {
    attach_type = "Mobiles";
    sprintbit(GET_TRIG_TYPE(trig), trig_types, trgtypes);
  }
  
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  
	  "Trigger Editor [%s%d%s]\r\n\r\n"
	  "%s1)%s Name         : %s%s\r\n"
	  "%s2)%s Intended for : %s%s\r\n"
	  "%s3)%s Trigger types: %s%s\r\n"
	  "%s4)%s Numeric Arg  : %s%d\r\n"
	  "%s5)%s Arguments    : %s%s\r\n"
	  "%s6)%s Commands:\r\n%s%s\r\n"
	  "%sQ)%s Quit\r\n"
	  "Enter Choice :",
	  
	  grn, OLC_NUM(d), nrm, 			/* vnum on the title line */
	  grn, nrm, yel, GET_TRIG_NAME(trig),		/* name                   */
	  grn, nrm, yel, attach_type,			/* attach type            */
	  grn, nrm, yel, trgtypes,			/* greet/drop/etc         */
	  grn, nrm, yel, trig->narg,			/* numeric arg            */
	  grn, nrm, yel, trig->arglist,			/* strict arg             */
	  grn, nrm, cyn, OLC_STORAGE(d),		/* the command list       */
	  grn, nrm);                                    /* quit colors            */
  
  send_to_char(buf, d->character);
  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
}

void trigedit_disp_types(struct descriptor_data *d)
{
  int i, columns = 0;
  const char **types;
  
  switch(OLC_TRIG(d)->attach_type)
    {
    case WLD_TRIGGER:
      types = wtrig_types;
      break;
    case OBJ_TRIGGER:
      types = otrig_types;
      break;
    case MOB_TRIGGER:
    default:
      types = trig_types;
      break;
    }
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_TRIG_TYPE_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, types[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_TRIG_TYPE(OLC_TRIG(d)), types, buf1);
  sprintf(buf, "\r\nCurrent types : %s%s%s\r\nEnter type (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
  
}

void trigedit_parse(struct descriptor_data *d, char *arg)
{
  int i = 0;
  
  switch (OLC_MODE(d)) {
  case TRIGEDIT_MAIN_MENU:
    switch (tolower(*arg)) {
    case 'q':
      if (OLC_VAL(d)) { /* Anything been changed? */
	if (!GET_TRIG_TYPE(OLC_TRIG(d))) {
	  send_to_char("Invalid Trigger Type! Answer a to abort quit!\r\n",
		       d->character);     
	}
	send_to_char("Do you wish to save the changes to the trigger? (y/n): ",
		     d->character);     
	OLC_MODE(d) = TRIGEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      OLC_MODE(d) = TRIGEDIT_NAME;
      send_to_char("Name: ", d->character);
      break;
    case '2':
      OLC_MODE(d) = TRIGEDIT_INTENDED;
      send_to_char("0: Mobiles, 1: Objects, 2: Rooms: ", d->character);
      break;
    case '3':
      OLC_MODE(d) = TRIGEDIT_TYPES;
      trigedit_disp_types(d);
      break;
    case '4':
      OLC_MODE(d) = TRIGEDIT_NARG;
      send_to_char("Numeric argument: ", d->character);
      break;
    case '5':
      OLC_MODE(d) = TRIGEDIT_ARGUMENT;
      send_to_char("Argument: ", d->character);
      break;
    case '6':
      OLC_MODE(d) = TRIGEDIT_COMMANDS;
      send_to_char("Enter trigger commands: (/s saves /h for help)\r\n\r\n",
		   d->character);
      string_write(d, &OLC_STORAGE(d), MAX_CMD_LENGTH);
      OLC_VAL(d) = 1;
      
      break;
    default:
      trigedit_disp_menu(d);
      return;
    }
    return;
    
  case TRIGEDIT_CONFIRM_SAVESTRING:
    switch(tolower(*arg)) {
    case 'y':
      trigedit_save(d);
      sprintf(buf, "OLC: %s edits trigger %d", GET_NAME(d->character),
	      OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* fall through */
    case 'n':
      cleanup_olc(d, CLEANUP_ALL);
      return;
    case 'a': /* abort quitting */
      break;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save the trigger? : ", d->character);
      return;
    }
    break;
    
  case TRIGEDIT_NAME:
    if (OLC_TRIG(d)->name)
      free(OLC_TRIG(d)->name);
    OLC_TRIG(d)->name = strdup((arg && *arg) ? arg : "undefined");
    OLC_VAL(d)++;
    break;
    
  case TRIGEDIT_INTENDED:
    if ((atoi(arg)>=MOB_TRIGGER) || (atoi(arg)<=WLD_TRIGGER))
      OLC_TRIG(d)->attach_type = atoi(arg);
    OLC_VAL(d)++;
    break;
    
  case TRIGEDIT_NARG:
    OLC_TRIG(d)->narg = atoi(arg);
    OLC_VAL(d)++;
    break;
    
  case TRIGEDIT_ARGUMENT:
    OLC_TRIG(d)->arglist = (*arg?strdup(arg):NULL);
    OLC_VAL(d)++;
    break;
    
  case TRIGEDIT_TYPES:
    if ((i = atoi(arg)) == 0)
      break;
    else if (!((i < 0) || (i > NUM_TRIG_TYPE_FLAGS)))
      TOGGLE_BIT((GET_TRIG_TYPE(OLC_TRIG(d))), 1 << (i - 1));
    OLC_VAL(d)++;
    trigedit_disp_types(d);
    return;
    
  case TRIGEDIT_COMMANDS:
    break;
    
  }
  
  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
  trigedit_disp_menu(d);
}

/*
** print out the letter codes pertaining to the bits set in 'data'
*/
void sprintbits(int data, char *dest)
{
  int i;
  char *p = dest;
  
  for (i=0; i<32; i++) {
    if (data & (1<<i)) {
      *p = ((i<=25)?('a'+i):('A'+i));
      p++;
    }
  }
  *p = '\0';
}


/* save the zone's triggers to internal memory and to disk */
void trigedit_save(struct descriptor_data *d)
{
  int trig_rnum, i;
  int found = 0;
  char *s;
  trig_data *proto;
  trig_data *trig = OLC_TRIG(d);
  trig_data *live_trig;
  struct cmdlist_element *cmd, *next_cmd;
  struct index_data **new_index;
  struct descriptor_data *dsc;
  FILE *trig_file;
  int zone, top;
  char buf[MAX_CMD_LENGTH];
  char bitBuf[MAX_INPUT_LENGTH];
  char fname[MAX_INPUT_LENGTH];
  char logbuf[MAX_INPUT_LENGTH];


  if ((trig_rnum = real_trigger(OLC_NUM(d))) != -1) {
    proto = trig_index[trig_rnum]->proto;
    for (cmd = proto->cmdlist; cmd; cmd = next_cmd) { 
      next_cmd = cmd->next;
      if (cmd->cmd)
        free(cmd->cmd);
      free(cmd);
    }
    
    
    free(proto->arglist);
    free(proto->name);

    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);
    
    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    if (s) {
      trig->cmdlist->cmd = strdup(strtok(s, "\r\n"));
      cmd = trig->cmdlist;
      cmd->next = NULL;		/*don't want dangling pointers..*/
    
      while ((s = strtok(NULL, "\r\n"))) {
        CREATE(cmd->next, struct cmdlist_element, 1);
        cmd = cmd->next;
        cmd->cmd = strdup(s);
        cmd->next = NULL;	/*don't want dangling pointers..*/
      }
    }
    else
      trig->cmdlist->cmd = strdup("* No Script");
    
    /* make the prorotype look like what we have */
    trig_data_copy(proto, trig);
    
    /* go through the mud and replace existing triggers         */
    live_trig = trigger_list;
    while (live_trig)
      {
	if (GET_TRIG_RNUM(live_trig) == trig_rnum) {
	  if (live_trig->arglist) {
	    free(live_trig->arglist);
	    live_trig->arglist = NULL;
	  }
	  if (live_trig->name) {
	    free(live_trig->name);
	    live_trig->name = NULL;
	  }
	  
	  if (proto->arglist)
	    live_trig->arglist = strdup(proto->arglist);
	  if (proto->name)
	    live_trig->name = strdup(proto->name);
	  
	  live_trig->cmdlist = proto->cmdlist;
	  live_trig->curr_state = live_trig->cmdlist;
	  live_trig->trigger_type = proto->trigger_type;
	  live_trig->attach_type = proto->attach_type;
	  live_trig->narg = proto->narg;
	  live_trig->data_type = proto->data_type;
	  live_trig->depth = 0;
	  live_trig->wait_event = NULL;
	  if (GET_TRIG_WAIT(live_trig))
	    event_cancel(GET_TRIG_WAIT(live_trig));
	  free_varlist(live_trig->var_list);
	}
	
	live_trig = live_trig->next_in_world;
      }
  } else {
    /* this is a new trigger */
    CREATE(new_index, struct index_data *, top_of_trigt + 2);
    
    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);
    
    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    if (s) {
      trig->cmdlist->cmd = strdup(strtok(s, "\r\n"));
      cmd = trig->cmdlist;
      cmd->next = NULL;		/*don't want dangling pointers..*/
                                
      while ((s = strtok(NULL, "\r\n"))) {
        CREATE(cmd->next, struct cmdlist_element, 1);
        cmd = cmd->next;
        cmd->cmd = strdup(s);
        cmd->next = NULL;		/*don't want dangling pointers..*/
      }
    }
    else
      trig->cmdlist->cmd = strdup("* No Script");
    
    for (i = 0; i < top_of_trigt; i++) {
      if (!found) {
        if (trig_index[i]->virtual > OLC_NUM(d)) {
          found = TRUE;
          trig_rnum = i;
	  
          CREATE(new_index[trig_rnum], struct index_data, 1);
          GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;
          new_index[trig_rnum]->virtual = OLC_NUM(d);
          new_index[trig_rnum]->number = 0; 
          new_index[trig_rnum]->func = NULL;
          CREATE(proto, struct trig_data, 1);
          new_index[trig_rnum]->proto = proto;
          trig_data_copy(proto, trig);

          if (trig->name)
            proto->name = strdup(trig->name);
          if (trig->arglist)
            proto->arglist = strdup(trig->arglist);  

          new_index[trig_rnum + 1] = trig_index[trig_rnum];
	  
          proto = trig_index[trig_rnum]->proto;
          proto->nr = trig_rnum + 1;
        } else {
          new_index[i] = trig_index[i];
        }
      } else {
	new_index[i + 1] = trig_index[i];
	proto = trig_index[i]->proto;
	proto->nr = i + 1;
      }
    }
    
    if (!found) {
      trig_rnum = i;
      CREATE(new_index[trig_rnum], struct index_data, 1);
      GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;  
      new_index[trig_rnum]->virtual = OLC_NUM(d);
      new_index[trig_rnum]->number = 0;
      new_index[trig_rnum]->func = NULL;
      
      CREATE(proto, struct trig_data, 1);
      new_index[trig_rnum]->proto = proto;
      trig_data_copy(proto, trig);
      
      if (trig->name)
        proto->name = strdup(trig->name);
      if (trig->arglist)
        proto->arglist = strdup(trig->arglist);  
    }
    
    free(trig_index);
    
    trig_index = new_index;
    top_of_trigt++;         
    
    /* HERE IT HAS TO GO THROUGH AND FIX ALL SCRIPTS/TRIGS OF HIGHER RNUM */
    for (live_trig = trigger_list; live_trig; live_trig = live_trig->next_in_world)
      if (GET_TRIG_RNUM(live_trig) > trig_rnum)
        GET_TRIG_RNUM(live_trig)++;
    
    /*
     * Update other trigs being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_TRIGEDIT)
	if (GET_TRIG_RNUM(OLC_TRIG(dsc)) >= trig_rnum)
	  GET_TRIG_RNUM(OLC_TRIG(dsc))++;
    
  }
  
  /* now write the trigger out to disk, along with the rest of the  */
  /* triggers for this zone, of course                              */
  /* note: we write this to disk NOW instead of letting the builder */
  /* have control because if we lose this after having assigned a   */
  /* new trigger to an item, we will get SYSERR's upon reboot that  */
  /* could make things hard to debug.                               */
  
  zone = zone_table[OLC_ZNUM(d)].number;
  top = zone_table[OLC_ZNUM(d)].top;
  
#ifdef CIRCLE_MAC
  sprintf(fname, "%s:%i.new", TRG_PREFIX, zone);
#else
  sprintf(fname, "%s/%i.new", TRG_PREFIX, zone);
#endif
  
  if (!(trig_file = fopen(fname, "w"))) {
    sprintf(logbuf,"SYSERR: OLC: Can't open trig file \"%s\"", fname);
    mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    return;
  }
  
  for (i = zone * 100; i <= top; i++) {
    if ((trig_rnum = real_trigger(i)) != -1) {
      trig = trig_index[trig_rnum]->proto;
      
      if (fprintf(trig_file, "#%d\n", i) < 0) {
        sprintf(logbuf, "SYSERR: OLC: Can't write trig file!"); 
        mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
        fclose(trig_file);
        return;
      }
      sprintbits(GET_TRIG_TYPE(trig), bitBuf);
      fprintf(trig_file,      "%s~\n"
	                      "%d %s %d\n"
	                      "%s~\n",
	      (GET_TRIG_NAME(trig)) ? (GET_TRIG_NAME(trig)) : "unknown trigger",
	      trig->attach_type,
	      bitBuf, GET_TRIG_NARG(trig),
	      GET_TRIG_ARG(trig) ? GET_TRIG_ARG(trig) : "");
      
      /* Build the text for the script */
      strcpy(buf,"");
      for (cmd = trig->cmdlist; cmd; cmd = cmd->next) {
        strcat(buf, cmd->cmd);
        strcat(buf, "\r\n");
      }
      
      if (!buf[0])
        strcpy(buf, "* Empty script");
      
      fprintf(trig_file, "%s~\n", buf);
      *buf = '\0';
    }
  }
  
  fprintf(trig_file, "$~\n");
  fclose(trig_file);
  
#ifdef CIRCLE_MAC
  sprintf(buf, "%s:%d.trg", TRG_PREFIX, zone);
#else
  sprintf(buf, "%s/%d.trg", TRG_PREFIX, zone);
#endif
  
  rename(fname, buf);
}

void dg_olc_script_free(struct descriptor_data *d)
{
  struct trig_proto_list *editscript, *prevscript;
  
  editscript = OLC_SCRIPT(d);
  while (editscript) {
    prevscript = editscript;
    editscript = editscript->next;
    free(prevscript);
  }
}


void dg_olc_script_copy(struct descriptor_data *d)
{
  struct trig_proto_list *origscript, *editscript;
  
  if (OLC_ITEM_TYPE(d) == MOB_TRIGGER)
    origscript = OLC_MOB(d)->proto_script;
  else if (OLC_ITEM_TYPE(d) == OBJ_TRIGGER)
    origscript = OLC_OBJ(d)->proto_script;
  else
    origscript = OLC_ROOM(d)->proto_script;
  
  if (origscript) {
    CREATE(editscript, struct trig_proto_list, 1);
    OLC_SCRIPT(d) = editscript;
    
    while (origscript) {
      editscript->vnum = origscript->vnum;
      origscript = origscript->next;
      if (origscript)
        CREATE(editscript->next, struct trig_proto_list, 1);
      editscript = editscript->next;
    }
  } else
    OLC_SCRIPT(d) = NULL;
}

void dg_script_menu(struct descriptor_data *d)
{
  struct trig_proto_list *editscript;
  int i = 0;
  
  /* make sure our input parser gets used */
  OLC_MODE(d) = OLC_SCRIPT_EDIT;
  OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
  
  
#if defined(CLEAR_SCREEN) /* done wierd to compile with the vararg send() */

  /* Hey does that line entionally have those control characters? RSD */  

#define FMT    "[H[J     Script Editor\r\n\r\n     Trigger List:\r\n"
#else
#define FMT    "     Script Editor\r\n\r\n     Trigger List:\r\n"
#endif
  send_to_char(FMT,d->character);
#undef FMT
  
  editscript = OLC_SCRIPT(d);
  while (editscript) {
    sprintf(buf,"     %2d) [%s%d%s] %s%s%s", ++i, cyn,
	    editscript->vnum, nrm, cyn,
	    trig_index[real_trigger(editscript->vnum)]->proto->name, nrm);
    send_to_char(buf, d->character);
    if (trig_index[real_trigger(editscript->vnum)]->proto->attach_type !=
        OLC_ITEM_TYPE(d))
      sprintf(buf,"   %s** Mis-matched Trigger Type **%s\r\n",grn,nrm);
    else
      sprintf(buf,"\r\n");
    send_to_char(buf, d->character);
    
    editscript = editscript->next;
  }
  if (i==0) send_to_char("     <none>\r\n", d->character);
  
  sprintf(buf, "\r\n"
	  " %sN%s)  New trigger for this script\r\n"
	  " %sD%s)  Delete a trigger in this script\r\n"
	  " %sX%s)  Exit Script Editor\r\n\r\n"
	  "     Enter choice :",
	  grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf,d->character);
}

int dg_script_edit_parse(struct descriptor_data *d, char *arg)
{
  struct trig_proto_list *trig, *currtrig, *starttrig;
  int pos, vnum;
  
  switch(OLC_SCRIPT_EDIT_MODE(d)) {
  case SCRIPT_MAIN_MENU:
    switch(tolower(*arg)) {
    case 'x':
    case 'X':
      if (OLC_ITEM_TYPE(d)==MOB_TRIGGER ) {
	trig = OLC_MOB(d)->proto_script;
	OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
      } else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER ) {
	trig = OLC_OBJ(d)->proto_script;
	OLC_OBJ(d)->proto_script = OLC_SCRIPT(d);
      } else {
	trig = OLC_ROOM(d)->proto_script;
	OLC_ROOM(d)->proto_script = OLC_SCRIPT(d);
      }
      
      return 0;
    case 'n':
    case 'N':
      send_to_char("\r\nPlease enter trigger vnum: ",
		   d->character);
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_NEW_TRIGGER;
      break;
    case 'd':
    case 'D':
        if (OLC_SCRIPT(d) == (struct trig_proto_list *)NULL)
            send_to_char("Cannot delete a trigger as there are none!\r\n",d->character);
        else
        {
            send_to_char("     Which entry should be deleted?  0 to abort :",
		   d->character);
            OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_DEL_TRIGGER;
        }
      break;
    default:
        send_to_char("\r\nUnrecognized command.  Try again: ", d->character);
        break;
    }
    return 1;
    
  case SCRIPT_NEW_TRIGGER:
    vnum = -1;
    vnum = atoi(arg);
    
    if (vnum<=0) break; /* this aborts a new trigger entry */
    
    if (real_trigger(vnum)<0) {
      send_to_char("Invalid Trigger VNUM!\r\n"
		   "Please enter vnum: ",
		   d->character);
      return 1;
    }
    
    CREATE(trig, struct trig_proto_list, 1);
    trig->vnum = vnum;
    trig->next = (struct trig_proto_list *)NULL;

    /* add the new info in position */
    if (OLC_SCRIPT(d) == (struct trig_proto_list *)NULL)
        OLC_SCRIPT(d) = trig;
    else
    {
        currtrig = OLC_SCRIPT(d);
    
        /* go to end of list */
        while (currtrig && currtrig->next) currtrig = currtrig->next;


        currtrig->next = trig;
    }
    OLC_VAL(d)++;
    break;
    
  case SCRIPT_DEL_TRIGGER:
    pos = atoi(arg);
    if (pos<=0) break;
    
    currtrig = OLC_SCRIPT(d);
    starttrig= currtrig;	/* hold the start of list trig and currtrig traverse the list and we need to know the beginning for when we return*/
    trig = currtrig;
    while (--pos && currtrig->next) { trig = currtrig; currtrig = currtrig->next; }

    if (pos)	/* damn fool specified a non-existent position */
    {
      send_to_char("No such trigger!\r\nTry Again:",d->character);
      return 1;
    }
    /* we are going to free currtrig...so we need to join up around it*/

    if (trig == currtrig)	/* first node in list */
    {
	    /* first node in list is to be removed, so we just start list
	     * at second node...
	     * note: if there _is_ only 1 node, currtrig->next = NULL
	     */
	starttrig=currtrig->next;
    }
    else
    {
	    /* currtrig is the node to be removed, trig is the node before
	     * so make trig->next skip currtrig...
	     */
        trig->next = currtrig->next;
    }
    free(currtrig);

    OLC_SCRIPT(d)=starttrig;

    break;
  }
  
  dg_script_menu(d);
  return 1;      
}


/*
 * Formats and indents a script.  Returns TRUE if the format was 
 * successful.  Returns FALSE if the format failed--in which case
 * the original text is not replaced.
 */
bool format_script(struct descriptor_data *d, int indent_quantum)
{
  #define CS_NONE	0
  #define CS_IF		1
  #define CS_SWITCH	2
  #define CS_CASE	3
  #define CS_DEFAULT	4
  #define CS_WHILE	5
  #define CS_ELSEIF	6
  #define CS_ELSE	7
  #define COMPLAIN(msg)	do { \
    snprintf(error, sizeof(error) - 1, msg " (line %d)!\r\n", line_num); \
    write_to_output(error, d); \
  } while (0)
  #define ABORT(msg)	do { \
    COMPLAIN(msg); \
    free(script); \
    return FALSE; \
  } while (0)

  char out[MAX_CMD_LENGTH], *line, *script, error[100];
  int line_num = 0, indent = 0, len = 0, max_len, i, indent_next = 0, needed;
  struct scope {
    int scope;
    int line_num;
  } scope;
  array_stack(struct scope) stack;
  struct scope_types {
    int type;
    char *name;
    int length;
  } cmd_scopes[] = {
    { CS_IF,      "if ",     3 },
    { CS_SWITCH,  "switch ", 7 },
    { CS_CASE,    "case",    4 },
    { CS_DEFAULT, "default", 7 },
    { CS_WHILE,   "while ",  6 },
    { CS_ELSEIF,  "elseif ", 7 }, /* needs to come before else check */
    { CS_ELSE,    "else",    4 },
    { CS_NONE,    NULL,      0 },
  };

  if (!d->str || !*d->str)
    return FALSE;

  script = strdup(*d->str); /* Make a copy, because of strtok() */
  *out = '\0';
  max_len = MAX(d->max_str, sizeof(out));
  scope.scope = CS_NONE;
  scope.line_num = 0;
  as_init(stack, 10, scope);

  /* Iterate through the script line by line */
  for (line = strtok(script, "\r\n"); line; line = strtok(NULL, "\r\n")) {
    ++line_num;
    skip_spaces(&line);

    /* Does this line open a new scope? */
    for (i = 0; cmd_scopes[i].name; ++i)
      if (!strn_cmp(line, cmd_scopes[i].name, cmd_scopes[i].length))
        break;

    /* If it does, i will not point to the last cmd_scopes entry */
    if (cmd_scopes[i].name) {
      /* Found a scope opener */
      switch (cmd_scopes[i].type) {
      case CS_CASE:
      case CS_DEFAULT:
        if (as_peek(stack).scope == CS_DEFAULT)
          ABORT("Case/default after default statement");
        else if (as_peek(stack).scope == CS_CASE) {
          /* Falling through from one case statement to another */
          scope = as_pop(stack);
          indent -= indent_quantum;
        }
        else if (as_peek(stack).scope != CS_SWITCH)
          ABORT("Case/default outside switch");
        /* Scope is switch */
        scope.scope = cmd_scopes[i].type;
        scope.line_num = line_num;
        as_push(stack, scope);
        indent_next = indent_quantum;
        break;
      case CS_ELSEIF:
      case CS_ELSE:
        if (as_peek(stack).scope != CS_IF && as_peek(stack).scope != CS_ELSEIF)
          ABORT("Unmatched 'else'");
        scope = as_pop(stack); /* pop off IF or ELSEIF */
        indent -= indent_quantum;
        scope.scope = cmd_scopes[i].type;
        scope.line_num = line_num;
        as_push(stack, scope);
        indent_next = indent_quantum;
        break;
      default: /* if, switch, while go here */
        scope.scope = cmd_scopes[i].type;
        scope.line_num = line_num;
        as_push(stack, scope);
        indent_next = indent_quantum;
        break;
      }
    }
    else {
      /* Didn't find a scope opener */
      if (!strn_cmp(line, "end", 3)) {
        switch (as_peek(stack).scope) {
        case CS_IF:
        case CS_ELSEIF:
        case CS_ELSE:
          scope = as_pop(stack);
          indent -= indent_quantum;
          break;
        default:
          ABORT("Unmatched 'end'");
        }
      }
      else if (!strn_cmp(line, "done", 4)) {
        do {
          if (as_peek(stack).scope == CS_WHILE)
            break;
          if (as_peek(stack).scope == CS_SWITCH)
            COMPLAIN("Switch/done without case/default");
          if (as_peek(stack).scope == CS_CASE || as_peek(stack).scope == CS_DEFAULT) {
            scope = as_pop(stack);
            indent -= indent_quantum;
          }
          /* Keep going, check for switch */
          if (as_peek(stack).scope == CS_SWITCH)
            break;
          ABORT("Unmatched 'done'");
        } while(0);
        scope = as_pop(stack);
        indent -= indent_quantum;
      }
      else if (!strn_cmp(line, "break", 5)) {
        array_stack(struct scope) temp;
        as_init(temp, as_size(stack), as_null(stack));
        /* Search the stack for a while, case, or default */
        for (i = FALSE; !as_empty(stack); ) {
          as_push(temp, as_pop(stack));
          if (as_peek(temp).scope == CS_WHILE ||
              as_peek(temp).scope == CS_CASE ||
              as_peek(temp).scope == CS_DEFAULT) {
            i = TRUE; /* found */
            break;
          }
        }
        if (!i)
          COMPLAIN("Break not in 'case' or 'while'");
        /* Put everything back on the original stack */
        while (!as_empty(temp))
          as_push(stack, as_pop(temp));
        as_destroy(temp);
      }
      else if (as_peek(stack).scope == CS_SWITCH)
        COMPLAIN("Non case/default statement directly after 'switch'");
    }

    /* How much space do we need for this line?  Include indent and \r\n */
    needed = strnlen(line, max_len - len + 1) + indent + 2;
    if (len + needed >= max_len)
      ABORT("String too long, formatting aborted");

    /* Indent, then copy line */
    for (i = 0; i < indent; ++i)
      out[len++] = ' ';
    len += sprintf(out + len, "%s\r\n", line);  /* size checked above */

    /* Indent the next line */
    if (indent_next) {
      indent += indent_next;
      indent_next = 0;
    }
  }

  /* If the stack is not empty, complain about it */
  while (!as_empty(stack)) {
    scope = as_pop(stack);
    line_num = scope.line_num;
    switch (scope.scope) {
    case CS_IF:      COMPLAIN("Unmatched 'if' ignored"); break;
    case CS_SWITCH:  COMPLAIN("Unmatched 'switch' ignored"); break;
    case CS_CASE:    COMPLAIN("Unmatched 'switch/case' ignored"); break;
    case CS_DEFAULT: COMPLAIN("Unmatched 'default' ignored"); break;
    case CS_WHILE:   COMPLAIN("Unmatched 'while' ignored"); break;
    case CS_ELSE:    COMPLAIN("Unmatched 'else' ignored"); break;
    case CS_ELSEIF:  COMPLAIN("Unmatched 'elseif' ignored"); break;
    }
  }

  /* Clean-up strings */
  free(*d->str);
  *d->str = strdup(out);
  free(script);
  as_destroy(stack);

  return TRUE;

  /* Clean-up defines */
  #undef CS_NONE
  #undef CS_IF
  #undef CS_SWITCH
  #undef CS_CASE
  #undef CS_DEFAULT
  #undef CS_WHILE
  #undef CS_ELSE
  #undef CS_ELSEIF
  #undef ABORT
  #undef COMPLAIN
}

/***************************************************************************
 * $Log: dg_olc.c,v $
 * Revision 1.25  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.24  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.23  2008/04/05 18:58:54  jps
 * FINALLY fixed that "Numberic Arg" silliness.
 *
 * Revision 1.22  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.21  2008/03/22 20:12:42  myc
 * Fixed indentation with else/elseif, and handling of 'end'.
 *
 * Revision 1.20  2008/03/22 20:05:59  myc
 * Fixed bug in script formatter: need to pop off if/else if before putting
 * another one on stack.
 *
 * Revision 1.19  2008/03/22 19:50:24  myc
 * Rewrote the script formatter to use a stack.  It is now leet haxorz.
 *
 * Revision 1.18  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.17  2008/03/21 15:58:34  myc
 * Added a utility format scripts.
 *
 * Revision 1.16  2008/03/17 16:22:42  myc
 * Removing the 'script_copy' function, which was unnecessary and caused
 * confusion with dg_olc_script_copy.
 *
 * Revision 1.15  2008/02/16 20:26:04  myc
 * Moving free_varlist to header file.
 *
 * Revision 1.14  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.13  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.12  2008/01/17 01:29:10  myc
 * Took out the restriction that comments out mskillset.
 *
 * Revision 1.11  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.10  2007/04/18 00:34:11  myc
 * The script editor in medit, oedit, and redit will now give better
 * feedback when you enter a command it doesn't recognize.
 *
 * Revision 1.9  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.8  2000/11/28 01:18:21  mtp
 * replaceed dg_event.c code with events.c code
 *
 * Revision 1.7  2000/11/23 00:57:04  mtp
 * added mskillset which allows a mob to set a players skill (or spell) proficiency
 * this required a change to not allow lev 102 and below to save a trigger with
 * mskillset in it so any lines with the text mskillset are commented
 *
 * Revision 1.6  2000/11/21 03:51:01  rsd
 * Altered the comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.5  2000/10/14 11:12:40  mtp
 * fixed the addition/removal of triggers from a script on
 * mob/obj/room, there was some dodgy freeing going on which has
 * been removed. HOPE there should be no memory leaks...:-)
 *
 * Revision 1.4  2000/03/07 07:42:05  mtp
 * In save of trigger, the memory structure to represent a sequence of command lists
 * is created, and this was not initialising the 'next' pointers to NULL. I have
 * done this now, to avoid problems when we follow the linked list freeing the
 * commands.
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 01:08:28  mud
 * Altered comment header and indented entire file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.25
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.24 2008/08/14 09:45:22 jps Exp jps $
d851 1
d1015 3
@


1.24
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.23 2008/04/05 18:58:54 jps Exp jps $
d376 1
a376 1
      trig->cmdlist->cmd = strdup(strtok(s, "\n\r"));
d380 1
a380 1
      while ((s = strtok(NULL, "\n\r"))) {
d436 1
a436 1
      trig->cmdlist->cmd = strdup(strtok(s, "\n\r"));
d440 1
a440 1
      while ((s = strtok(NULL, "\n\r"))) {
d854 1
a854 1
  for (line = strtok(script, "\n\r"); line; line = strtok(NULL, "\n\r")) {
d1014 3
@


1.23
log
@FINALLY fixed that "Numberic Arg" silliness.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.22 2008/03/28 17:54:53 myc Exp jps $
d29 1
d1014 3
@


1.22
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.21 2008/03/22 20:12:42 myc Exp myc $
d151 1
a151 1
	  "%s4)%s Numberic Arg : %s%d\r\n"
d1013 4
@


1.21
log
@Fixed indentation with else/elseif, and handling of 'end'.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.20 2008/03/22 20:05:59 myc Exp myc $
d75 1
a75 1
  trig->name = str_dup("new trigger");
d281 1
a281 1
    OLC_TRIG(d)->name = str_dup((arg && *arg) ? arg : "undefined");
d297 1
a297 1
    OLC_TRIG(d)->arglist = (*arg?str_dup(arg):NULL);
d407 1
a407 1
	    live_trig->arglist = str_dup(proto->arglist);
d409 1
a409 1
	    live_trig->name = str_dup(proto->name);
d435 1
a435 1
      trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
d442 1
a442 1
        cmd->cmd = str_dup(s);
d465 1
a465 1
            proto->name = str_dup(trig->name);
d467 1
a467 1
            proto->arglist = str_dup(trig->arglist);  
d496 1
a496 1
        proto->name = str_dup(trig->name);
d498 1
a498 1
        proto->arglist = str_dup(trig->arglist);  
d1013 3
@


1.20
log
@Fixed bug in script formatter: need to pop off if/else if before putting
another one on stack.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.19 2008/03/22 19:50:24 myc Exp myc $
d888 1
d905 8
a912 1
        if (as_peek(stack).scope != CS_IF && as_peek(stack).scope != CS_ELSEIF)
d914 1
a914 2
        scope = as_pop(stack);
        indent -= indent_quantum;
d1013 4
@


1.19
log
@Rewrote the script formatter to use a stack.  It is now leet haxorz.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.18 2008/03/22 03:22:38 myc Exp myc $
d887 1
d1006 3
@


1.18
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.17 2008/03/21 15:58:34 myc Exp myc $
d28 1
d801 1
a801 1
int format_script(struct descriptor_data *d, int indent_quantum)
d803 39
a841 4
  char nsc[MAX_CMD_LENGTH], *t, line[MAX_INPUT_LENGTH];
  char *sc;
  size_t len = 0, nlen = 0, llen = 0;
  int indent = 0, indent_next = FALSE, found_case = FALSE, line_num = 0;
d846 102
a947 63
  sc = strdup(*d->str); /* we work on a copy, because of strtok() */
  t = strtok(sc, "\n\r");
  *nsc = '\0';

  while (t) {
    line_num++;
    skip_spaces(&t);
    if (!strn_cmp(t, "if ", 3) ||
        !strn_cmp(t, "switch ", 7)) {
      indent_next = TRUE;
    } else if (!strn_cmp(t, "while ", 6)) {
      found_case = TRUE;  /* so you can 'break' a loop without complains */
      indent_next = TRUE;
    } else if (!strn_cmp(t, "end", 3) ||
               !strn_cmp(t, "done", 4)) {
      if (!indent) {
        sprintf(line, "Unmatched 'end' or 'done' (line %d)!\r\n", line_num);
        write_to_output(line, d);
        free(sc);
        return FALSE;
      }
      indent--;
      indent_next = FALSE;
    } else if (!strn_cmp(t, "else", 4)) {
      if (!indent) {
        sprintf(line, "Unmatched 'else' (line %d)!\r\n", line_num);
        write_to_output(line, d);
        free(sc);
        return FALSE;
      }
      indent--;
      indent_next = TRUE;
    } else if (!strn_cmp(t, "case", 4) ||
               !strn_cmp(t, "default", 7)) {
      if (!indent) {
        sprintf(line, "Case/default outside switch (line %d)!\r\n", line_num);
        write_to_output(line, d);
        free(sc);
        return FALSE;
      }
      if (!found_case) /* so we don't indent multiple case statements without a break */
        indent_next = TRUE;
      found_case = TRUE;
    } else if (!strn_cmp(t, "break", 5)) {
      if (!found_case || !indent ) {
        sprintf(line, "Break not in case (line %d)!\r\n", line_num);
        write_to_output(line, d);
        free(sc);
        return FALSE;
      }
      found_case = FALSE;
      indent--;
    }

    *line = '\0';
    for (nlen = 0; nlen < indent * indent_quantum; ++nlen)
      line[nlen] = ' ';
    line[nlen] = '\0';
    llen = snprintf(line + nlen, sizeof(line) - nlen, "%s\r\n", t);
    if (llen < 0 || llen + nlen + len > d->max_str - 1 ) {
      write_to_output("String too long, formatting aborted\r\n", d);
      free(sc);
      return FALSE;
a948 2
    len = len + nlen + llen;
    strcat(nsc, line);  /* strcat OK, size checked above */
d950 11
d962 2
a963 2
      indent++;
      indent_next = FALSE;
a964 1
    t = strtok(NULL, "\n\r");
d967 14
a980 2
  if (indent)
    write_to_output("Unmatched if, while or switch ignored.\r\n", d);
d982 1
d984 3
a986 2
  *d->str = strdup(nsc);
  free(sc);
d989 12
d1005 6
@


1.17
log
@Added a utility format scripts.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.16 2008/03/17 16:22:42 myc Exp myc $
d245 1
a245 2
      send_to_char(
		   "Enter trigger commands: (/s saves /h for help)\r\n\r\n",
d247 1
a247 8
      d->backstr = NULL;
      if (OLC_STORAGE(d)) {
	send_to_char(OLC_STORAGE(d), d->character);
	d->backstr = str_dup(OLC_STORAGE(d));
      }
      d->str = &OLC_STORAGE(d);
      d->max_str = MAX_CMD_LENGTH;
      d->mail_to = 0;
d896 3
@


1.16
log
@Removing the 'script_copy' function, which was unnecessary and caused
confusion with dg_olc_script_copy.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.15 2008/02/16 20:26:04 myc Exp myc $
d27 1
d801 101
d904 4
@


1.15
log
@Moving free_varlist to header file.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.14 2008/02/09 04:27:47 myc Exp myc $
a33 51
/* copy an entire script from one holder (mob/obj/room) to another */
void script_copy(void *dst, void *src, int type)
{
  struct script_data *s_src = NULL;
  struct script_data *s_dst = NULL;
  trig_data *t_src, *t_dst;
  
  /* find the scripts of the source and destination */
  switch (type)
    {
    case MOB_TRIGGER:
      s_src = SCRIPT((struct char_data *)src);
      s_dst = SCRIPT((struct char_data *)dst);
      ((struct char_data *)dst)->proto_script =
        ((struct char_data *)src)->proto_script;
      break;
    case OBJ_TRIGGER:
      s_src = SCRIPT((struct obj_data *)src);
      s_dst = SCRIPT((struct obj_data *)dst);
      ((struct obj_data *)dst)->proto_script =
        ((struct obj_data *)src)->proto_script;
      break;
    case WLD_TRIGGER:
      s_src = SCRIPT((struct room_data *)src);
      s_dst = SCRIPT((struct room_data *)dst);
      ((struct room_data *)dst)->proto_script =
        ((struct room_data *)src)->proto_script;
      break;
    default:
      log("SYSERR: Unknown type code sent to script_copy()!");
      break;
    }
  
  /* make sure the dst doesnt already have a script       */
  /* if it does, delete it                                */
  if (s_dst) extract_script(s_dst);
  
  /* copy the scrip data */
  s_dst->types = s_src->types;
  t_src = TRIGGERS(s_src);
  while (t_src)
    {
      CREATE(t_dst, trig_data, 1);
      if (!TRIGGERS(s_dst)) TRIGGERS(s_dst) = t_dst;
      trig_data_copy(t_dst, t_src);
      t_dst = t_dst->next;
      t_src = t_src->next;
    }
  
}

d612 1
a612 1
  if (OLC_ITEM_TYPE(d)==MOB_TRIGGER)
d614 1
a614 1
  else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER)
d616 2
a617 1
  else origscript = OLC_ROOM(d)->proto_script;
d802 3
@


1.14
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.13 2008/01/29 21:02:31 myc Exp myc $
a29 1
void free_varlist(struct trig_var_data *vd);
d852 3
@


1.13
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.12 2008/01/17 01:29:10 myc Exp myc $
d26 1
d853 4
@


1.12
log
@Took out the restriction that comments out mskillset.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.11 2007/07/24 23:02:52 jps Exp myc $
a26 9
/* declare externally defined globals */
extern struct index_data **trig_index;
extern char *trig_types[], *otrig_types[], *wtrig_types[];
extern struct descriptor_data *descriptor_list;
extern struct trig_data *trigger_list;
extern int top_of_trigt;
extern struct zone_data *zone_table;


d222 1
a222 1
  char **types;
d852 3
@


1.11
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.10 2007/04/18 00:34:11 myc Exp jps $
d417 1
a417 1
  char buf[MAX_CMD_LENGTH],*chptr;
a420 1
  int writers_lvl;
a438 3
    /* if the writer is less than GRGOD level, they can't use mskillset */
    writers_lvl = GET_LEVEL(d->character);

d440 3
a442 18
    chptr = strtok(s,"\n\r");
    if (writers_lvl < LVL_HEAD_B && *chptr != '*' && (strstr(chptr,"mskillset")))
	    sprintf(buf,"* %s",chptr);
    else
	    strcpy(buf,chptr);

    trig->cmdlist->cmd = str_dup(buf);
    cmd = trig->cmdlist;
    cmd->next = NULL;		/*don't want dangling pointers..*/
    
    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      if (writers_lvl < LVL_HEAD_B && *s != '*' && (strstr(s,"mskillset")))
	    sprintf(buf,"* %s",s);
      else
	    strcpy(buf,s);
      cmd->cmd = str_dup(buf);
d444 7
d452 2
d500 4
a503 3
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cmd = trig->cmdlist;
    cmd->next = NULL;		/*don't want dangling pointers..*/
d505 6
a510 5
    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      cmd->cmd = str_dup(s);
      cmd->next = NULL;		/*don't want dangling pointers..*/
d512 2
d591 1
a591 1
  /* new trigger to an item, we will get SYSERR's upton reboot that */
d861 3
@


1.10
log
@The script editor in medit, oedit, and redit will now give better
feedback when you enter a command it doesn't recognize.
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.9 2002/09/13 02:32:10 jjl Exp myc $
d833 1
a833 1
    if (pos)	/* damn fool specified a non-existant position */
d867 4
@


1.9
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_olc.c,v 1.8 2000/11/28 01:18:21 mtp Exp $
d755 1
d769 1
d775 1
d785 3
d867 3
@


1.8
log
@replaceed dg_event.c code with events.c code
@
text
@d1 3
a3 1
// $Id: dg_olc.c,v 1.7 2000/11/23 00:57:04 mtp Exp mtp $
d859 35
a893 30
// $Log: dg_olc.c,v $
// Revision 1.7  2000/11/23 00:57:04  mtp
// added mskillset which allows a mob to set a players skill (or spell) proficiency
// this required a change to not allow lev 102 and below to save a trigger with
// mskillset in it so any lines with the text mskillset are commented
//
// Revision 1.6  2000/11/21 03:51:01  rsd
// Altered the comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.5  2000/10/14 11:12:40  mtp
// fixed the addition/removal of triggers from a script on
// mob/obj/room, there was some dodgy freeing going on which has
// been removed. HOPE there should be no memory leaks...:-)
//
// Revision 1.4  2000/03/07 07:42:05  mtp
// In save of trigger, the memory structure to represent a sequence of command lists
// is created, and this was not initialising the 'next' pointers to NULL. I have
// done this now, to avoid problems when we follow the linked list freeing the
// commands.
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 01:08:28  mud
// Altered comment header and indented entire file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.7
log
@added mskillset which allows a mob to set a players skill (or spell) proficiency
this required a change to not allow lev 102 and below to save a trigger with
mskillset in it so any lines with the text mskillset are commented
@
text
@d1 1
a1 1
// $Id: dg_olc.c,v 1.6 2000/11/21 03:51:01 rsd Exp $
d23 1
a23 1
#include "dg_event.h"
d494 1
a494 1
	    remove_event(GET_TRIG_WAIT(live_trig));
d858 5
@


1.6
log
@Altered the comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: dg_olc.c,v 1.5 2000/10/14 11:12:40 mtp Exp $
d415 1
a415 1
  char buf[MAX_CMD_LENGTH];
d419 1
d438 3
d442 7
a448 1
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
d455 5
a459 1
      cmd->cmd = str_dup(s);
d858 4
@


1.5
log
@fixed the addition/removal of triggers from a script on
mob/obj/room, there was some dodgy freeing going on which has
been removed. HOPE there should be no memory leaks...:-)
@
text
@d1 12
a12 9
// $Id: dg_olc.c,v 1.4 2000/03/07 07:42:05 mtp Exp $
/**************************************************************************
 * File: dg_olc.c                                    NOW Part of FieryMUD * 
 * Usage: This source file is used in extending Oasis style OLC for       *
 *        dg-scripts onto a CircleMUD that already has dg-scripts (as     *
 *        released by Mark Heilpern on 1/1/98) implemented.               *
 *                                                                        *
 * Parts of this file by Chris Jacobson of _Aliens vs Predator: The MUD_  *
 **************************************************************************/
d844 5
d857 6
@


1.4
log
@In save of trigger, the memory structure to represent a sequence of command lists
is created, and this was not initialising the 'next' pointers to NULL. I have
done this now, to avoid problems when we follow the linked list freeing the
commands.
@
text
@d1 1
a1 1
// $Id: dg_olc.c,v 1.3 1999/09/05 07:00:39 jimmy Exp mtp $
d729 2
a730 2
  struct trig_proto_list *trig, *currtrig;
  int count, pos, vnum;
d736 1
a736 1
      if (OLC_ITEM_TYPE(d)==MOB_TRIGGER) {
d739 1
a739 1
      } else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER) {
a746 5
      while (trig) {
	currtrig = trig->next;
	free(trig);
	trig = currtrig;
      }
d749 1
a749 1
      send_to_char("\r\nPlease enter position, vnum   (ex: 1, 200):",
d754 5
a758 1
      send_to_char("     Which entry should be deleted?  0 to abort :",
d760 2
a761 1
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_DEL_TRIGGER;
d768 1
a768 7
    count = sscanf(arg,"%d, %d",&pos,&vnum);
    if (count==1) {
      vnum = pos;
      pos = 999;
    }
    
    if (pos<=0) break; /* this aborts a new trigger entry */
d770 1
a770 1
    if (vnum==0) break; /* this aborts a new trigger entry */
d774 1
a774 1
		   "Please enter position, vnum   (ex: 1, 200):",
a778 2
    /* add the new info in position */
    currtrig = OLC_SCRIPT(d);
d781 8
d790 5
a794 9
    if (pos==1 || !currtrig) {
      trig->next = OLC_SCRIPT(d);
      OLC_SCRIPT(d) = trig;
    } else {
      while (currtrig->next && --pos) {
	currtrig = currtrig->next;
      }
      trig->next = currtrig->next;
      currtrig->next = trig;
d803 19
a821 6
    if (pos==1 && OLC_SCRIPT(d)) {
      OLC_VAL(d)++;
      currtrig = OLC_SCRIPT(d);
      OLC_SCRIPT(d) = currtrig->next;
      free(currtrig);
      break;
d823 6
a828 10
    
    pos--;
    currtrig = OLC_SCRIPT(d);
    while (--pos && currtrig) currtrig = currtrig->next;
    /* now curtrig points one before the target */
    if (currtrig && currtrig->next) {
      OLC_VAL(d)++;
      trig = currtrig->next;
      currtrig->next = trig->next;
      free(trig);
d830 4
d841 6
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d437 1
d443 1
d493 1
d499 1
d831 4
a834 1
// $Log$
@


1.2
log
@Altered comment header and indented entire file
@
text
@d1 1
d827 1
@


1.1
log
@Initial revision
@
text
@d1 8
a8 8
/*
** dg_olc.c: this source file is used in extending Oasis style OLC for
** dg-scripts onto a CircleMUD that already has dg-scripts (as released
** by Mark Heilpern on 1/1/98) implemented.
**
** Parts of this file by Chris Jacobson of _Aliens vs Predator: The MUD_
*/

d43 1
a43 1

d46 1
a46 1
  {
d52 1
a52 1
     break;
d68 2
a69 2
  }

d73 1
a73 1

d78 8
a85 8
  {
    CREATE(t_dst, trig_data, 1);
    if (!TRIGGERS(s_dst)) TRIGGERS(s_dst) = t_dst;
    trig_data_copy(t_dst, t_src);
    t_dst = t_dst->next;
    t_src = t_src->next;
  }

d93 1
a93 1

d104 1
a104 1

d106 4
a109 4
  {
    fprintf(fp,"T %d\n", t->vnum);
    t = t->next;
  }
d121 1
a121 1

d123 1
a123 1

d129 1
a129 1

d133 1
a133 1
    "say My trigger commandlist is not complete!\r\n");
d135 1
a135 1

d138 1
a138 1
    
d146 1
a146 1

d151 1
a151 1

d153 1
a153 1

d160 5
a164 5
  {
    strcat(OLC_STORAGE(d), c->cmd);
    strcat(OLC_STORAGE(d), "\r\n");
    c = c->next;
  }
d167 1
a167 1

d170 1
a170 1
    
d180 1
a180 1

d182 1
a182 1

d193 1
a193 1
      
d196 1
a196 1
"[H[J"
d198 20
a217 20

  "Trigger Editor [%s%d%s]\r\n\r\n"
  "%s1)%s Name         : %s%s\r\n"
  "%s2)%s Intended for : %s%s\r\n"
  "%s3)%s Trigger types: %s%s\r\n"
  "%s4)%s Numberic Arg : %s%d\r\n"
  "%s5)%s Arguments    : %s%s\r\n"
  "%s6)%s Commands:\r\n%s%s\r\n"
  "%sQ)%s Quit\r\n"
  "Enter Choice :",

  grn, OLC_NUM(d), nrm, 			/* vnum on the title line */
  grn, nrm, yel, GET_TRIG_NAME(trig),		/* name                   */
  grn, nrm, yel, attach_type,			/* attach type            */
  grn, nrm, yel, trgtypes,			/* greet/drop/etc         */
  grn, nrm, yel, trig->narg,			/* numeric arg            */
  grn, nrm, yel, trig->arglist,			/* strict arg             */
  grn, nrm, cyn, OLC_STORAGE(d),		/* the command list       */
  grn, nrm);                                    /* quit colors            */

d226 1
a226 1

d228 1
a228 1
  {
d239 2
a240 2
  }

d247 1
a247 1
              !(++columns % 2) ? "\r\n" : "");
d252 1
a252 1
                cyn, buf1, nrm);
d254 1
a254 1

d260 1
a260 1

d262 21
a282 74
    case TRIGEDIT_MAIN_MENU:
     switch (tolower(*arg)) {
       case 'q':
         if (OLC_VAL(d)) { /* Anything been changed? */
           if (!GET_TRIG_TYPE(OLC_TRIG(d))) {
             send_to_char("Invalid Trigger Type! Answer a to abort quit!\r\n",
               d->character);     
           }
           send_to_char("Do you wish to save the changes to the trigger? (y/n): ",
             d->character);     
           OLC_MODE(d) = TRIGEDIT_CONFIRM_SAVESTRING;
         } else
           cleanup_olc(d, CLEANUP_ALL);
           return;
         case '1':
           OLC_MODE(d) = TRIGEDIT_NAME;
           send_to_char("Name: ", d->character);
           break;
         case '2':
           OLC_MODE(d) = TRIGEDIT_INTENDED;
           send_to_char("0: Mobiles, 1: Objects, 2: Rooms: ", d->character);
           break;
         case '3':
           OLC_MODE(d) = TRIGEDIT_TYPES;
           trigedit_disp_types(d);
           break;
         case '4':
           OLC_MODE(d) = TRIGEDIT_NARG;
           send_to_char("Numeric argument: ", d->character);
           break;
         case '5':
           OLC_MODE(d) = TRIGEDIT_ARGUMENT;
           send_to_char("Argument: ", d->character);
           break;
         case '6':
           OLC_MODE(d) = TRIGEDIT_COMMANDS;
           send_to_char(
             "Enter trigger commands: (/s saves /h for help)\r\n\r\n",
             d->character);
           d->backstr = NULL;
           if (OLC_STORAGE(d)) {
             send_to_char(OLC_STORAGE(d), d->character);
             d->backstr = str_dup(OLC_STORAGE(d));
           }
           d->str = &OLC_STORAGE(d);
           d->max_str = MAX_CMD_LENGTH;
           d->mail_to = 0;
           OLC_VAL(d) = 1;

           break;
         default:
           trigedit_disp_menu(d);
           return;
     }
     return;
    
    case TRIGEDIT_CONFIRM_SAVESTRING:
      switch(tolower(*arg)) {
        case 'y':
          trigedit_save(d);
          sprintf(buf, "OLC: %s edits trigger %d", GET_NAME(d->character),
            OLC_NUM(d));
          mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
          /* fall through */
        case 'n':
          cleanup_olc(d, CLEANUP_ALL);
          return;
        case 'a': /* abort quitting */
          break;
        default:
          send_to_char("Invalid choice!\r\n", d->character);
          send_to_char("Do you wish to save the trigger? : ", d->character);
          return;
      }
d284 3
a286 6

    case TRIGEDIT_NAME:
      if (OLC_TRIG(d)->name)
        free(OLC_TRIG(d)->name);
      OLC_TRIG(d)->name = str_dup((arg && *arg) ? arg : "undefined");
      OLC_VAL(d)++;
d288 23
a310 5

    case TRIGEDIT_INTENDED:
      if ((atoi(arg)>=MOB_TRIGGER) || (atoi(arg)<=WLD_TRIGGER))
        OLC_TRIG(d)->attach_type = atoi(arg);
      OLC_VAL(d)++;
d312 18
a329 4

    case TRIGEDIT_NARG:
      OLC_TRIG(d)->narg = atoi(arg);
      OLC_VAL(d)++;
d331 3
a333 13

    case TRIGEDIT_ARGUMENT:
      OLC_TRIG(d)->arglist = (*arg?str_dup(arg):NULL);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_TYPES:
      if ((i = atoi(arg)) == 0)
        break;
      else if (!((i < 0) || (i > NUM_TRIG_TYPE_FLAGS)))
        TOGGLE_BIT((GET_TRIG_TYPE(OLC_TRIG(d))), 1 << (i - 1));
      OLC_VAL(d)++;
      trigedit_disp_types(d);
d335 28
a362 2

    case TRIGEDIT_COMMANDS:
d364 9
a372 1

d374 1
a374 1

d386 1
a386 1

d425 2
a426 2


d432 1
a432 1

d436 1
a436 1

d442 1
a442 1

d445 1
a445 1

d449 30
a478 27
    {
      if (GET_TRIG_RNUM(live_trig) == trig_rnum) {
        if (live_trig->arglist) {
          free(live_trig->arglist);
          live_trig->arglist = NULL;
        }
        if (live_trig->name) {
          free(live_trig->name);
          live_trig->name = NULL;
        }

        if (proto->arglist)
          live_trig->arglist = str_dup(proto->arglist);
        if (proto->name)
          live_trig->name = str_dup(proto->name);

        live_trig->cmdlist = proto->cmdlist;
        live_trig->curr_state = live_trig->cmdlist;
        live_trig->trigger_type = proto->trigger_type;
        live_trig->attach_type = proto->attach_type;
        live_trig->narg = proto->narg;
        live_trig->data_type = proto->data_type;
        live_trig->depth = 0;
        live_trig->wait_event = NULL;
        if (GET_TRIG_WAIT(live_trig))
          remove_event(GET_TRIG_WAIT(live_trig));
        free_varlist(live_trig->var_list);
a479 3

      live_trig = live_trig->next_in_world;
    }
d483 1
a483 1

d486 1
a486 1
         
d496 1
a496 1

d502 1
a502 1
                        
d518 1
a518 1

d525 3
a527 3
         new_index[i + 1] = trig_index[i];
         proto = trig_index[i]->proto;
         proto->nr = i + 1;
d530 1
a530 1

d538 1
a538 1
                        
d542 1
a542 1

d548 1
a548 1
                
d550 1
a550 1
                        
d553 1
a553 1

d558 1
a558 1
        
d562 5
a566 5
     for (dsc = descriptor_list; dsc; dsc = dsc->next)
       if (dsc->connected == CON_TRIGEDIT)
         if (GET_TRIG_RNUM(OLC_TRIG(dsc)) >= trig_rnum)
           GET_TRIG_RNUM(OLC_TRIG(dsc))++;

d568 1
a568 1

d575 1
a575 1

d578 1
a578 1

d584 1
a584 1

d590 1
a590 1
        
d594 1
a594 1

d603 7
a609 7
                              "%d %s %d\n"
                              "%s~\n",
           (GET_TRIG_NAME(trig)) ? (GET_TRIG_NAME(trig)) : "unknown trigger",
           trig->attach_type,
           bitBuf, GET_TRIG_NARG(trig),
           GET_TRIG_ARG(trig) ? GET_TRIG_ARG(trig) : "");
                
d616 1
a616 1

d619 1
a619 1
                
d624 1
a624 1
        
d627 1
a627 1
                
d633 1
a633 1
        
d640 1
a640 1

d653 1
a653 1

d659 1
a659 1

d663 1
a663 1

d672 1
a672 1
      OLC_SCRIPT(d) = NULL;
d679 1
a679 1

d683 3
d687 1
a688 1
#if defined(CLEAR_SCREEN) /* done wierd to compile with the vararg send() */
d695 1
a695 1

d699 2
a700 2
      editscript->vnum, nrm, cyn,
      trig_index[real_trigger(editscript->vnum)]->proto->name, nrm);
d708 1
a708 1

d712 1
a712 1

d714 5
a718 5
    " %sN%s)  New trigger for this script\r\n"
    " %sD%s)  Delete a trigger in this script\r\n"
    " %sX%s)  Exit Script Editor\r\n\r\n"
    "     Enter choice :",
    grn, nrm, grn, nrm, grn, nrm);
d726 1
a726 1

d728 12
a739 30
    case SCRIPT_MAIN_MENU:
      switch(tolower(*arg)) {
        case 'x':
          if (OLC_ITEM_TYPE(d)==MOB_TRIGGER) {
            trig = OLC_MOB(d)->proto_script;
            OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
          } else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER) {
            trig = OLC_OBJ(d)->proto_script;
            OLC_OBJ(d)->proto_script = OLC_SCRIPT(d);
          } else {
            trig = OLC_ROOM(d)->proto_script;
            OLC_ROOM(d)->proto_script = OLC_SCRIPT(d);
          }

          while (trig) {
            currtrig = trig->next;
            free(trig);
            trig = currtrig;
          }
          return 0;
        case 'n':
          send_to_char("\r\nPlease enter position, vnum   (ex: 1, 200):",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_NEW_TRIGGER;
          break;
        case 'd':
          send_to_char("     Which entry should be deleted?  0 to abort :",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_DEL_TRIGGER;
          break;
d741 36
d778 13
a790 34

    case SCRIPT_NEW_TRIGGER:
      vnum = -1;
      count = sscanf(arg,"%d, %d",&pos,&vnum);
      if (count==1) {
        vnum = pos;
        pos = 999;
      }

      if (pos<=0) break; /* this aborts a new trigger entry */

      if (vnum==0) break; /* this aborts a new trigger entry */

      if (real_trigger(vnum)<0) {
        send_to_char("Invalid Trigger VNUM!\r\n"
            "Please enter position, vnum   (ex: 1, 200):",
            d->character);
        return 1;
      }

      /* add the new info in position */
      currtrig = OLC_SCRIPT(d);
      CREATE(trig, struct trig_proto_list, 1);
      trig->vnum = vnum;

      if (pos==1 || !currtrig) {
        trig->next = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = trig;
      } else {
        while (currtrig->next && --pos) {
          currtrig = currtrig->next;
        }
        trig->next = currtrig->next;
        currtrig->next = trig;
d792 11
a803 15
      break;

    case SCRIPT_DEL_TRIGGER:
      pos = atoi(arg);
      if (pos<=0) break;

      if (pos==1 && OLC_SCRIPT(d)) {
        OLC_VAL(d)++;
        currtrig = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = currtrig->next;
        free(currtrig);
        break;
      }

      pos--;
d805 2
a806 8
      while (--pos && currtrig) currtrig = currtrig->next;
      /* now curtrig points one before the target */
      if (currtrig && currtrig->next) {
        OLC_VAL(d)++;
        trig = currtrig->next;
        currtrig->next = trig->next;
        free(trig);
      }
d808 13
d822 1
a822 1

@
