head	1.108;
access;
symbols;
locks; strict;
comment	@ * @;


1.108
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.107;

1.107
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.103;

1.103
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2009.02.18.19.25.57;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.04.21.07.25;	author myc;	state Exp;
branches;
next	1.100;

1.100
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2008.09.13.18.52.51;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.31.20.54.08;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.31.17.04.19;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.08.25.00.20.33;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.15.04.07.08;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.10.16.46.49;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.20.02.38.17;	author jps;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.19.06.51.39;	author jps;	state Exp;
branches;
next	1.87;

1.87
date	2008.05.19.06.33.53;	author jps;	state Exp;
branches;
next	1.86;

1.86
date	2008.05.19.05.47.50;	author jps;	state Exp;
branches;
next	1.85;

1.85
date	2008.05.18.20.46.19;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.18.20.15.57;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.18.03.49.13;	author jps;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.20.03.54.28;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.19.20.17.27;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2008.04.18.16.13.05;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.14.02.19.18;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.10.01.38.38;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.17.15.31.27;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.09.18.10.32;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.08.23.54.54;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.11.21.04.01;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.64;

1.64
date	2008.02.01.17.55.09;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.28.00.14.32;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.27.21.14.59;	author myc;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.22.14.59.23;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.21.02.44.26;	author myc;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.20.23.18.52;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.16.04.12.00;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.14.21.28.32;	author myc;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.14.20.38.42;	author myc;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.13.03.19.53;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.12.19.12.05;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.12.19.08.14;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.07.11.57.57;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.07.10.34.53;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.06.23.50.47;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.27.03.18.58;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.08.23.19.23;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.07.19.51.30;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.29.01.22.18;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2007.08.26.01.55.41;	author myc;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.16.11.53.58;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.05.22.19.17;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.18.21.05.16;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.18.17.02.25;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.11.16.05.27;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.08.01.32.20;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.08.04.01.13;	author myc;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.27.00.17.00;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.20.09.03.58;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.20.07.25.34;	author jps;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.17.22.52.59;	author jps;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.30.01.12.32;	author jjl;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.07.03.02.59;	author dce;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.28.00.45.28;	author mtp;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.24.18.42.20;	author rsd;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.24.20.00.41;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.22.22.38.37;	author rsd;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.25.03.32.11;	author cso;	state Exp;
branches;
next	1.17;

1.17
date	99.12.06.20.21.04;	author cso;	state Exp;
branches;
next	1.16;

1.16
date	99.11.28.23.51.54;	author cso;	state Exp;
branches;
next	1.15;

1.15
date	99.11.23.15.48.23;	author jimmy;	state Exp;
branches;
next	1.14;

1.14
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.09.04.18.46.52;	author jimmy;	state Exp;
branches;
next	1.12;

1.12
date	99.07.25.05.40.18;	author jimmy;	state Exp;
branches;
next	1.11;

1.11
date	99.07.14.19.24.03;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.07.12.02.58.46;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.07.06.19.57.05;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.05.02.19.32.34;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	99.04.04.04.05.12;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.04.04.03.42.41;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.03.31.22.06.06;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.03.22.18.57.32;	author tph;	state Exp;
branches;
next	1.3;

1.3
date	99.02.04.21.07.27;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.17.19.29;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@  /***************************************************************************
   *   File: mobact.c                                      Part of HubisMUD  *
   *  Usage: Functions for generating intelligent behavior in mobiles        *
   *  This file is no more than a conductor to the other mob AI files        *
   *  All rights reserved.  See license.doc for complete information.        *
   *                                                                         *
   *       Redesigned by Proky                                               *
   *                                                                         *
   *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
   *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
   ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "spells.h"
#include "ai.h"
/* external structs */
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct room_data *world;
extern struct str_app_type str_app[];
extern struct char_data *combat_list;	/* head of l-list of fighting chars */
extern struct char_data *next_combat_list;
extern int rogue_subclasses[ROGUE_SUBCLASSES];

ACMD (do_get);
ACMD (do_flee);
ACMD (do_bash);
ACMD (do_kick);
ACMD (do_cast);
ACMD (do_stand);
ACMD (do_circle);
ACMD (do_backstab);
bool update_inv (struct char_data *ch, struct obj_data *obj, int where);
void perform_wear (struct char_data *ch, struct obj_data *obj, int where);
int find_eq_pos (struct char_data *ch, struct obj_data *obj, char *arg);
int CountToughness (struct char_data *ch, struct char_data *victim);
int NumAttackers (struct char_data *ch);
void check_mob_status (struct char_data *ch);
bool is_grouped (struct char_data *ch, struct char_data *tch);
void mob_cast (struct char_data *ch, struct char_data *victim, int spellnum);
void class_operator (struct char_data *ch, struct char_data *victim);
bool is_aggr_to (struct char_data *ch, struct char_data *target);
int mem_inMemory (struct char_data *ch, struct char_data *vict);
void remember (struct char_data *ch, struct char_data *victim);

void mprog_random_trigger (struct char_data *mob);
void mprog_wordlist_check (char *arg, struct char_data *mob,
	 struct char_data *actor, struct obj_data *obj, void *vo, int type);
extern struct char_data *mob_proto;
extern int is_empty (int zone_nr);
void hunt_victim (struct char_data *ch);
void perform_arrest (struct char_data *vict);

ACMD (do_track);
ACMD (do_DumbMobTrack);

void
mobile_activity (void)
{
   register struct char_data *ch, *next_ch, *vict;
//   struct char_data *i;
   struct obj_data *obj, *best_obj, *x;
   int door, found = FALSE, max, hurm;
   int cmd_track, where;
   struct descriptor_data *d, *next_d;
   memory_rec *names;
   extern int no_specials;

   ACMD (do_get);
   for (ch = character_list; ch; ch = next_ch)
   {
      next_ch = ch->next;
      if (ch->in_room == real_room (30761))
      {
	 special_update (ch);
      }
      if (ch->in_room == real_room (9800))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9801))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9802))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9803))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9804))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9805))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9806))
      {
	 el_passage (ch);
      }
      if (ch->in_room == real_room (9807))
      {
	 el_passage (ch);
      }

      if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
	 continue;
     if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
         continue;
      if (ch->desc && ch->desc->original)
	 continue;
      check_mob_status (ch);	/*checks spell ups etc */
      /* Examine call for special procedure */
      if (MOB_FLAGGED (ch, MOB_CASTING))
	 continue;
      /*if sitting and not ment to be better stand */
      if (GET_POS (ch) < POS_FIGHTING)
	 if (GET_DEFAULT_POS (ch) == POS_STANDING)
	    if (GET_MOB_WAIT (ch) <= 0)
	    {
	       max = find_command ("stand");
	       do_stand (ch, "", max, 0);
	       max = 0;
	    }

      if (MOB_FLAGGED (ch, MOB_SPEC) && !no_specials)
      {
	 if (mob_index[GET_MOB_RNUM (ch)].func == NULL)
	 {
	    sprintf (buf, "%s (#%d): Attempting to call non-existing mob func",
		     GET_NAME (ch), GET_MOB_VNUM (ch));
	    log (buf);
	    REMOVE_BIT (MOB_FLAGS (ch), MOB_SPEC);
	 }
	 else
	 {
	    if ((mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, ""))
	       continue;	/* go to next char */
	 }
      }

      if (!is_empty (world[ch->in_room].zone))
	 mprog_random_trigger (ch);
      /* Scavenger (picking up objects) */
      if (MOB_FLAGGED (ch, MOB_SCAVENGER) && !FIGHTING (ch) && AWAKE (ch))
      {
	 if (world[ch->in_room].contents && !number (0, 1))
	 {
	    max = 0;
	    best_obj = NULL;
	    for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
	       if (CAN_GET_OBJ (ch, obj) && GET_OBJ_COST (obj) > max)
	       {
		  best_obj = obj;
		  max = GET_OBJ_COST (obj);
	       }
	    if (best_obj != NULL)
	    {
	       obj_from_room (best_obj);
	       obj_to_char (best_obj, ch);
	       act ("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM);
	    }
	 }
	 /*if stuff in inventry check to use it */
	 for (obj = ch->carrying; obj; obj = obj->next_content)
	 {
	    if (CAN_SEE_OBJ (ch, obj))
	    {
	       where = find_eq_pos (ch, obj, 0);
	       if (GET_EQ (ch, where))
	       {
		  if (where >= 0)
		  {
		     x = GET_EQ (ch, where);
		     if (GET_OBJ_COST (x) >= GET_OBJ_COST (obj))
			continue;
		     else
		     {
			perform_remove (ch, where);
			perform_wear (ch, obj, where);
			continue;
		     }
		     /*perform_wear(ch, obj, where); */
		  }
	       }
	       else
	       {
		  if (where >= 0)
		  {
		     perform_wear (ch, obj, where);
		     continue;
		  }
	       }
	       /*where = -1, bag or weopon or type */
	       if (!(update_inv (ch, obj, where)))	/*try it */
		  if (check_weopeon_value (ch, obj))
		  {
		     mob_remove_weopon (ch, obj, where);
		     if (!(update_inv (ch, obj, where)))
			mudlog ("Mob Coudnt Update with weopoen exchange - Proky.", NRM, LVL_GOD, FALSE);
		  }
	    }


	 }
      }




      /* Mob Movement */
      if (!MOB_FLAGGED (ch, MOB_SENTINEL) && (GET_POS (ch) == POS_STANDING) &&
	  ((door = number (0, 18)) < NUM_OF_DIRS) && CAN_GO (ch, door) &&
	!ROOM_FLAGGED (EXIT (ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH) &&
	  (!MOB_FLAGGED (ch, MOB_STAY_ZONE) ||
	 (world[EXIT (ch, door)->to_room].zone == world[ch->in_room].zone)))
      {
	 perform_move (ch, door, 1);
      }

      /* MOB Prog foo */
      if (IS_NPC (ch) && ch->mpactnum > 0 && !is_empty (world[ch->in_room].zone))
      {
	 MPROG_ACT_LIST *tmp_act, *tmp2_act;

	 for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp_act->next)
	 {
	    mprog_wordlist_check (tmp_act->buf, ch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG);
	    free (tmp_act->buf);
	 }
	 for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp2_act)
	 {
	    tmp2_act = tmp_act->next;
	    free (tmp_act);
	 }
	 ch->mpactnum = 0;
	 ch->mpact = NULL;
      }

      /* Helper Mobs */
      if (MOB_FLAGGED (ch, MOB_HELPER))
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    if (ch != vict && IS_NPC (vict) && FIGHTING (vict) &&
		!IS_NPC (FIGHTING (vict)) && ch != FIGHTING (vict))
	    {
	       if (GET_LEVEL (FIGHTING (vict)) > 20)
	       {

		  act ("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
		  class_operator (ch, FIGHTING (vict));		/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		     hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
		  found = TRUE;
	       }
	       else
	       {
		  hurm = number (1, 10);
		  if (hurm == 1)
		     act ("$n watches the battle in amusment.", FALSE, ch, 0, vict, TO_ROOM);
		  if (hurm == 2)
		     act ("$n chuckles at your as $e watches the fight", FALSE, ch, 0, vict, TO_ROOM);
		  if (hurm == 3)
		     act ("$n takes note of your battle tatics.", FALSE, ch, 0, vict, TO_ROOM);
	       }
	    }
      }
/* Added fast to slow till bug is fixed Banyal*/
      if (!MOB_FLAGGED (ch, MOB_SENTINEL))
      {				/*slow track Banyal */
	 if (MOB_FLAGGED (ch, MOB_SLOW_TRACK))
	 {
	    if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
	    {
	       for (d = descriptor_list; d; d = next_d)
	       {
		  if (STATE (d) != CON_PLAYING)
		  {
		     next_d = d->next;
		     continue;
		  }
		  next_d = d->next;

		  for (names = MEMORY (ch); names && !found; names = names->next)
		  {
		     if (names->id == GET_IDNUM (d->character))
		     {
			cmd_track = find_command ("DumbMobTrack");
			do_DumbMobTrack (ch, d->character->player.name, cmd_track, 0);
			if (d->character->in_room == ch->in_room)
			{
			   class_operator (ch, d->character);	/*hit with special type if got one */
			   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
			      hit (ch, d->character, TYPE_UNDEFINED);
			}
			return;
		     }
		  }
	       }
	    }
	 }
	 /* Add new mobile actions here */
      }
   }				/* end for() */
}


#ifdef PROKYMOBMEMORY

/* Mob Memory Routines */

/* make ch remember victim */
void
remember (struct char_data *ch, struct char_data *victim)
{
   memory_rec *tmp;
   bool present = FALSE;

   if (!IS_NPC (ch) || IS_NPC (victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
      return;
if (victim->desc && victim->desc->original)
   remember(ch, victim->desc->original);

   for (tmp = MEMORY (ch); tmp && !present; tmp = tmp->next)
      if (tmp->id == GET_IDNUM (victim))
	 present = TRUE;

   if (!present)
   {
      CREATE (tmp, memory_rec, 1);

      if (!(MEMORY (ch)))
	 tmp->next = NULL;
      tmp->next = MEMORY (ch);
      tmp->id = GET_IDNUM (victim);
      MEMORY (ch) = tmp;
   }
}


/* make ch forget victim */
void
forget (struct char_data *ch, struct char_data *victim)
{
   memory_rec *curr, *tmp = NULL;

   if (!(curr = MEMORY (ch)))
      return;

/*function re-done by Proky */
   curr = MEMORY (ch);
   /*check for top of list */
   if (curr->id == GET_IDNUM (victim))
   {
      if (curr->next)
	 MEMORY (ch) = curr->next;
      else
	 MEMORY (ch) = NULL;
      free (curr);
      return;
   }
   /*middle of list or end */
   for (curr = MEMORY (ch); curr->next->id != GET_IDNUM (victim); curr = curr->next);
   tmp = curr->next;
   if (tmp)
   {
      curr->next = tmp->next;
      free (tmp);
   }
}

#endif

void remember(struct char_data * ch, struct char_data * victim)
{
  memory_rec *tmp;
  bool present = FALSE;

  if (!IS_NPC(ch) || IS_NPC(victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
    return;

  for (tmp = MEMORY(ch); tmp && !present; tmp = tmp->next)
    if (tmp->id == GET_IDNUM(victim))
      present = TRUE;

  if (!present) {
    CREATE(tmp, memory_rec, 1);
    tmp->next = MEMORY(ch);
    tmp->id = GET_IDNUM(victim);
    MEMORY(ch) = tmp;
  }
}


/* make ch forget victim */
void forget(struct char_data * ch, struct char_data * victim)
{
  memory_rec *curr, *prev = NULL;

  if (!(curr = MEMORY(ch)))
    return;

  while (curr && curr->id != GET_IDNUM(victim)) {
    prev = curr;
    curr = curr->next;
  }

  if (!curr)
    return;			/* person wasn't there at all. */

  if (curr == MEMORY(ch))
    MEMORY(ch) = curr->next;
  else
    prev->next = curr->next;

  free(curr);
}

/* erase ch's memory */
void
clearMemory (struct char_data *ch)
{
   memory_rec *curr, *next;

   curr = MEMORY (ch);

   while (curr)
   {
      next = curr->next;
      free (curr);
      curr = next;
   }

   MEMORY (ch) = NULL;
}


/*Function for setting mob skills on login */
#define STSP   MIN(98, MAX(75, (aloud_skill) ? mob_proto[i].player.level * 3 : 0))
#define STSK   MIN(95, MAX((mob_proto[i].player.level) * 2, 20))
void
set_mob_skills (int i, int class, int race)
{
   switch (race)
   {
   case SPECIES_DRAGON:
    SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
    SET_MSKILL (mob_proto[i], SKILL_SWEEP, STSK);
    SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
    SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
    break;
   case SPECIES_DEMON:
    SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
    SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
    SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
    break;
   }
   switch (class)
   {
   case MCLASS_VOID:

      break;
   case MCLASS_SORCERER:

      SET_MSKILL (mob_proto[i], SPELL_COMPREHEND_LANG, STSP);
      SET_MSKILL (mob_proto[i], SPELL_TELEPORT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISINTEGRATE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MASS_INVIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MINOR_GLOBE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MAJOR_GLOBE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HARNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_RELOCATE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHAIN_LIGHTNING, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIRESHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_COLDSHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ICE_STORM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ICE_SHARDS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MINOR_PARALYSIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_TELEPORT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BIGBYS_CLENCHED_FIST, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BURNING_HANDS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHILL_TOUCH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIREBALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_COLOR_SPRAY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MAGIC_MISSILE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_INFRAVISION, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_INVIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_INVISIBLE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BOLT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SHOCKING_GRASP, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SLEEP, STSP);
      SET_MSKILL (mob_proto[i], SPELL_STONE_SKIN, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FARSEE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_METEORSWARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_RAY_OF_ENFEEB, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HASTE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DIMENSION_DOOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHARM, STSP);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (70, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, MIN (70, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (40, MAX ((mob_proto[i].player.level), 5)));

      break;
   case MCLASS_CLERIC:
      SET_MSKILL (mob_proto[i], SPELL_PLANE_SHIFT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_UNHOLY_WORD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WATERWALK, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HOLY_WORD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CONTINUAL_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SOULSHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SILENCE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FLAMESTRIKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DESTROY_UNDEAD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BLESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_PRESERVE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ARMOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BLINDNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CREATE_FOOD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CREATE_WATER, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURSE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_BLIND, STSP);
      SET_MSKILL (mob_proto[i], SPELL_PROT_FROM_EVIL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_ALIGN, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SUMMON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_EARTHQUAKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VITALITY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_EVIL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_EARTHQUAKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DARKNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VITALITY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_REMOVE_CURSE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SUMMON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WORD_OF_RECALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_REMOVE_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SENSE_LIFE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_GOOD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_ARMOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_RECALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WATERWALK, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FULL_HARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FULL_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (80, MAX ((mob_proto[i].player.level * 2), 10)));
      SET_MSKILL (mob_proto[i], SKILL_RIDING, MIN (80, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, MIN (80, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (50, MAX ((mob_proto[i].player.level), 5)));

      break;

   case MCLASS_THIEF:
      SET_MSKILL (mob_proto[i], SKILL_SNEAK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_STEAL, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, MIN (100, MAX ((((mob_proto[i].player.level) * 3)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_PICK_LOCK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (75, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_CIRCLE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TAME, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIDING, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      break;

   case MCLASS_WARRIOR:
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BASH, STSK);
      SET_MSKILL (mob_proto[i], SKILL_KICK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RESCUE,
 MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
      SET_MSKILL (mob_proto[i], SKILL_GUARD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK,
 MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIPOST,
 MIN (60, MAX ((mob_proto[i].player.level) * 1, 10)));
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      break;

   case MCLASS_MERCENARY:
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BASH, STSK);
      SET_MSKILL (mob_proto[i], SKILL_KICK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RESCUE,
 MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
      SET_MSKILL (mob_proto[i], SKILL_GUARD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK,
 MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, STSK);
      break;

   case MCLASS_ASSASSIN:
      SET_MSKILL (mob_proto[i], SKILL_SNEAK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_KICK, (mob_proto[i].player.level > 35) ? MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)) : 0);
      SET_MSKILL (mob_proto[i], SKILL_THROATCUT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_STEAL, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PICK_LOCK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (85, MAX ((((mob_proto[i].player.level) * 2)), 10)));

      SET_MSKILL (mob_proto[i], SKILL_CIRCLE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TAME, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIDING, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
   default:
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (75, MAX ((((mob_proto[i].player.level) * 2)), 10)));

      break;

   }
}
/* Moved aggresive mob code and old memory code here cause
   pulse mobile_act was to slow for proper agressive and aggro mobs
   also original intent was to code trackers Banyal */

void
mobile_spec_activity (void)
{
   register struct char_data *ch, *next_ch, *vict;
//   struct char_data *i;
   struct descriptor_data *d, *next_d;
   int found = FALSE, a;
   bool hascast = FALSE;
   memory_rec *names, *namestmp;
   int cmd_track;
   bool WHYTRACK = FALSE;

   for (ch = character_list; ch; ch = next_ch)
   {
      next_ch = ch->next;
      if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
	 continue;
      if (ch->desc && ch->desc->original)
	 continue;
      if (MOB_FLAGGED (ch, MOB_CASTING))
	 continue;
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
         continue;
      if (IS_FIGHTING (ch))
	 continue;
      /*if mob not fighting still decrease wait state */
      if ((GET_MOB_WAIT (ch) > 0))
      {
	 WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE)), 0))
	    continue;
      }

      /*pets banyal */

      if (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict))
	    {
	       act ("&7$n assist $s master!!&0", FALSE, ch, 0, vict, TO_ROOM);
	       hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
	       found = TRUE;
	    }
      }


/* Aggressive Mobs */
      if (MOB_FLAGGED (ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN))
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	 {
	    if (IS_NPC (vict) || !(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	       continue;
	    if (MOB_FLAGGED (ch, MOB_WIMPY) && AWAKE (vict))
	       continue;
	    if ((IS_AFFECTED (ch, AFF_CHARM)))
	       if (ch->master)
	       {
		  if (ch->master == vict)
		     continue;
		  if ((ch->in_room) == (ch->master->in_room))
		  {
		     continue;
		  }
		  if (is_grouped (ch, vict))
		  {
		     continue;
		  }
	       }


	    if (!MOB_FLAGGED (ch, MOB_AGGR_TO_ALIGN) ||
		(MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
		 (GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_GOOD_ALIGN) &&
		 (GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)))
	    {
	       class_operator (ch, vict);	/*hit with special type if got one */
	       if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		  hit (ch, vict, TYPE_UNDEFINED);
	       found = TRUE;
	       WHYTRACK = TRUE;
	    }
	 }
      }
      if (MOB_FLAGGED (ch, MOB_ARRESTOR) && (!MEMORY (ch)))
	 extract_char (ch);


      /* Mob Memory */
      if ((MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) &&
	  (MOB_FLAGGED (ch, MOB_WIMPY) &&
	   (GET_HIT (ch) < (GET_MAX_HIT (ch) >> 2))))
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	 {
	    if (IS_NPC (vict) || !CAN_SEE (ch, vict) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	       continue;
	    for (names = MEMORY (ch); names && !found; names = namestmp)
	       namestmp = names->next;
	    if (names && names->id == GET_IDNUM (vict))
	    {
	       found = TRUE;
	       WHYTRACK = TRUE;
	       if (!MOB_FLAGGED (ch, MOB_ARRESTOR))	/*is he here to kill or arrest Banyal */
	       {
		  class_operator (ch, vict);	/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		     hit (ch, vict, TYPE_UNDEFINED);
	       }
	       else
	       {
		  perform_arrest (vict);
		  forget (ch, vict);
		  extract_char (ch);
	       }
	       continue;
	    }
	 }
      }

      if (GET_CLASS (ch) == MCLASS_CLERIC)
	 if (((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) < 95)
	 {
	    mob_heal_up (ch);
	    continue;
	 }

      /*remove anyone without memory or not flagged memory */
      if ((!MOB_FLAGGED (ch, MOB_MEMORY)) || (!MEMORY (ch)))
	 continue;

      /*Check maybe he wants to summon target */
      if (GET_MSKILL (ch, SPELL_SUMMON))
      {
	 if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
	    for (d = descriptor_list; d; d = next_d)
	    {
	       if (STATE (d) != CON_PLAYING)
	       {
		  next_d = d->next;
		  continue;
	       }
	       next_d = d->next;
	       if (GET_LEVEL (d->character) > LVL_IMMORT)
		  continue;
	       for (names = MEMORY (ch); names && !found; names = names->next)
		  if (names->id == GET_IDNUM (d->character))
		  {
		     if ((GET_MSKILL (ch, SPELL_SUMMON)))
		     {
			a = 0;
			a = SPELL_CIRCLE (SPELL_SUMMON);
			if (can_summon (ch, d->character))
			{
			   hascast = TRUE;
			   break;
			}
		     }
		  }
	       if (hascast)
		  break;
	    }
      }
      if (hascast)
	 continue;

      /*try to dim to him or relocate */
      if (((GET_MSKILL (ch, SPELL_DIMENSION_DOOR))) || ((GET_MSKILL (ch, SPELL_RELOCATE))))
      {
	 if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
	    for (d = descriptor_list; d; d = next_d)
	    {
	       if (STATE (d) != CON_PLAYING)
	       {
		  next_d = d->next;
		  continue;
	       }

	       next_d = d->next;
	       if (d->character && GET_LEVEL (d->character) > LVL_IMMORT)
		  continue;
	       for (names = MEMORY (ch); names && !found; names = names->next)
		  if (names->id == GET_IDNUM (d->character))
		  {
		     if ((GET_MSKILL (ch, SPELL_DIMENSION_DOOR)))
			if (can_dim (ch, d->character))
			{

			   hascast = TRUE;
			   break;
			}
		     /*if real high try relocate */
		     a = 0;
		     a = SPELL_CIRCLE (SPELL_RELOCATE);
		     if ((GET_MSKILL (ch, SPELL_RELOCATE)))
			if (GET_LEVEL (ch) > 60)
			   if (try_cast (ch, d->character, a, SPELL_RELOCATE))
			   {

			      hascast = TRUE;
			      break;
			   }
		  }
	       if (hascast)
		  break;

	    }
      }
      if (hascast)
	 continue;
      /*Fast track Banyal */
      if (WHYTRACK == FALSE)
     {
	 if (MOB_FLAGGED (ch, MOB_FAST_TRACK))
	 {
	    if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
	    {

	       for (d = descriptor_list; d; d = next_d)
	       {
		  if (STATE (d) != CON_PLAYING)
		  {
		     next_d = d->next;
		     continue;
		  }

		  next_d = d->next;
		  for (names = MEMORY (ch); names && !found; names = names->next)
		  {
		     if (d->character && names->id == GET_IDNUM (d->character))
		     {
			cmd_track = find_command ("DumbMobTrack");
			do_DumbMobTrack (ch, d->character->player.name, cmd_track,0);

			if (d->character->in_room == ch->in_room)
			{
			   class_operator (ch, d->character);	/*hit with special type if got one */
			   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING(ch)))
			      hit (ch, d->character, TYPE_UNDEFINED);
			}
			return;
		     }
		  }
	       }
	    }
	 }
     }
   }
}



void
class_operator (struct char_data *ch, struct char_data *victim)
{

   if (MOB_FLAGGED (ch, MOB_CASTING))
      return;
   if (MOB_FLAGGED (ch, MOB_ARRESTOR)) {
   perform_arrest (victim);
                  forget (ch, victim);
                  extract_char (ch);
    return;
   }
  if((GET_RACE(ch) != SPECIES_DRAGON) && (GET_RACE(ch) != SPECIES_DEMON))
   switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default:
      break;

   }
if (GET_RACE(ch) == SPECIES_DRAGON) // when others done change to dragon_
switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      dragon_sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      dragon_sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default:
      break;

   }
if (GET_RACE(ch) == SPECIES_DEMON) // when others done change to demon_
switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      demon_sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      demon_sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default:
      break;

   }
}


int
try_cast (struct char_data *ch, struct char_data *victim, int spells_circle, int spellnum)
{
   int cmd_stand;

   if (GET_MOB_WAIT (ch) <= 0)
      if (GET_POS (ch) < POS_FIGHTING)
      {
	 cmd_stand = find_command ("stand");
	 do_stand (ch, "",
		   cmd_stand, 0);
      }
   if (AFF2_FLAGGED (ch, AFF2_SILENCE))
   {
      return 0;
   }
   if (MOB_FLAGGED (ch, MOB_CASTING))
      return 0;
   if ((GET_MEM_STATE (ch, spells_circle) == 0) && (GET_MEM_MEMED (ch, spells_circle) == 0))
      SET_MEM_STATE (ch, spells_circle, 1);
   if ((GET_MEM_STATE (ch, spells_circle) == 1) && (GET_MEM_MEMED (ch, spells_circle) ==
	       spells_of_circle[(int) GET_LEVEL (ch)][(int) spells_circle]))
      SET_MEM_STATE (ch, spells_circle, 0);
   if ((GET_MEM_MEMED (ch, spells_circle) > 0) && (GET_MEM_STATE (ch, spells_circle) != 1))
   {
      mob_cast (ch, victim, spellnum);
      return 1;
   }
   return 0;
}





void
perform_mob_violence (void)
{
   struct char_data *ch;
   struct char_data *victim;

   /* This function is called each second to check if mob ready to do a special
      attack PLEASE DO NOT CHANGE IT IT IS VERY VERY TOUCHY!!
      - if you wish to change mob activity change class_opperator
      Proky
    */
   for (ch = combat_list; ch; ch = next_combat_list)
   {
      next_combat_list = ch->next_fighting;

      if (FIGHTING (ch) == NULL || ch->in_room != FIGHTING (ch)->in_room)
      {
	 stop_fighting (ch);
	 continue;
      }
      if (IS_NPC (ch) && !(ch->desc && ch->desc->original))
      {
	 if ((FIGHTING (ch)) && (GET_POS (ch) > POS_FIGHTING))
	    GET_POS (ch) = POS_FIGHTING;
/*Stand mob up if no pause */
	 if (GET_MOB_WAIT (ch) > 0)
	    WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE / 2)), 0))
	       else
	 {
	    if (!(GET_MOB_WAIT (ch) > 0))
	    {
	       if (GET_POS (ch) < POS_FIGHTING)
	       {
		  GET_POS (ch) = POS_FIGHTING;
		  act ("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
		  return;
	       }
	       victim = FIGHTING (ch);
	       class_operator (ch, victim);
	    }
	 }
      }
   }
}

void
casting_gain (void)
{
   struct char_data *i, *next_char;
   int var;
   int circle = 0;

   /* characters */
   for (i = character_list; i; i = next_char)
   {
      next_char = i->next;
      /*npc only */
      if (IS_NPC (i))
      {
	 var = 0;
	 circle = 0;
	 while (var < GET_LEVEL (i))
	 {
	    circle++;
	    var = circle * 5 + 1;
	 }
	 var = 0;

	 if (circle > 12)
	    circle = 12;
	 if (circle <= 0)
	    circle = 1;
	 circle--;
	 for (; circle >= 0; circle--)
	 {

	    if ((i)->mob_specials.mem_memed[circle] < spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)])
	    {
	       (i)->mob_specials.mem_memed[circle] = MIN (((i)->mob_specials.mem_memed[circle] + 3),
		   (spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)]));
	    }
	 }
      }
   }
}

/*Track aggro check Banyal*/

bool is_aggr_to_trackee (struct char_data *ch, struct char_data *target)
{
   /* common checks first */

   if ((!ch) || (!target) || (ch == target) ||
   (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
      return FALSE;

   if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return FALSE;

   /*pets now needs a master to inhibit aggression */
   if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
      return FALSE;

   /* now different checks for pcs/npcs */


    if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
         (mem_inMemory (ch, target) && !MOB_FLAGGED (ch, MOB_NOVICIOUS)))
         return TRUE;


      /* not trigger, so it's not aggr */
      return FALSE;


}

bool is_aggr_to (struct char_data *ch, struct char_data *target)
{
   /* common checks first */

   if ((!ch) || (!target) || (ch == target) || (ch->in_room != target->in_room)
   || (FIGHTING (target) != ch) || (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
      return FALSE;

   if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return FALSE;

   /* now needs a master to inhibit aggression */
   if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
      return FALSE;

   /* now different checks for pcs/npcs */

   if (IS_NPC (ch))
   {


      /* after the above check, we are dealing with a pet or a PC */



      /* if target in memory, then it acts as if it's agg, even if it's not
       */
      if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
	  mem_inMemory (ch, target))
	 return TRUE;

      if (!MOB_FLAGGED (ch, MOB_NOVICIOUS))
	 return TRUE;

      /* not trigger, so it's not aggr */
      return TRUE; /*should be false but changed to true for a test*/

   }
   else
   {

      if (!IS_NPC (target))
	 return FALSE;


      if (GET_WIMP_LEV (ch) > GET_HIT (ch))	/* not agg and wimpy both */
	 return FALSE;

      if (!PRF_FLAGGED (ch, PRF_VICIOUS))
      {
	 if (!AWAKE (target) || IS_AFFECTED2 (target, AFF2_MINOR_PARALYSIS) ||
	     IS_AFFECTED (target, AFF_MAJOR_PARA))
	    return FALSE;
      }
      if ((ch->player_specials->saved.aggressive != -1) &&
	  (ch->player_specials->saved.aggressive < GET_HIT (ch)) &&
	  is_aggr_to (target, ch))
	 return TRUE;
   }

   return FALSE;
}


/* mobact.c */

/* Return 0 if "name" is not in memory "mem", otherwise, */
/* non-zero integer. */

int
mem_inMemory (struct char_data *ch, struct char_data *vict)
{
   memory_rec *names;
   bool found = FALSE;

   if (MEMORY (ch) == NULL)
      return 0;

   for (names = MEMORY (ch); names && !found; names = names->next)
      if (names->id == GET_IDNUM (vict))
      {
	 found = TRUE;
	 return 1;
      }

   return 0;
}


/*This function checks mobs for spell ups */
/*if fighting exit */
void
check_mob_status (register struct char_data *ch)
{
   switch (GET_CLASS (ch))
   {
   case MCLASS_SORCERER:
      check_sor_status (ch);
      break;
   case MCLASS_CLERIC:
      check_cler_status (ch);
      break;
   default:
      break;
   }
}










bool
update_inv (struct char_data *ch, struct obj_data *obj, int where)
{
   struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
   struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);

   /*struct obj_data *wielding2 = GET_EQ(ch, WEAR_WIELD2) */

   if (!(obj))
      return FALSE;
   else
   {
      if (!CAN_WEAR (obj, ITEM_WEAR_WIELD) && !CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
	 return TRUE;
      if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
	 return FALSE;
      else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
	 return TRUE;
      else if ((!wielding) && (!hwielding))
      {
	 if (CAN_WEAR (obj, ITEM_WEAR_WIELD))
	 {
	    perform_wear (ch, obj, WEAR_WIELD);
	    return TRUE;
	 }
	 else if (CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
	 {
	    perform_wear (ch, obj, WEAR_2HWIELD);
	    return FALSE;
	 }
      }
      else
      {
	 if (GET_MSKILL (ch, SKILL_DUAL_WIELD))
	 {
	    struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
	    struct obj_data *wielding2 = GET_EQ (ch, WEAR_WIELD2);
	    struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);

	    if (wielding)
	    {
	       if (!CAN_WEAR (obj, ITEM_WEAR_WIELD))
		  return FALSE;
	       if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
		  return FALSE;
	       else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
		  return FALSE;
	       else if (!wielding2)
	       {
		  perform_wear (ch, obj, WEAR_WIELD2);
		  return TRUE;
	       }

	    }
	 }


      }
   }
   return FALSE;
}


int
CountToughness (struct char_data *ch, struct char_data *victim)
{
   int val, foo;

   if (!IS_NPC (ch))
      return -1;

   val = GET_HIT (victim);

   if (IS_CLERIC (victim) || IS_MAGIC_USER (victim))
      val = val * 2 / 3;
   else if (IS_WARRIOR (victim))
      val = val * 2;
   foo = MAX (0, 60 - GET_LEVEL (victim));
   if (!IS_FIGHTING (victim))
      val = val / (IS_THIEF (ch) ? 4 : 2);
   if ((IS_AFFECTED3 (victim, AFF3_AWARE)) && IS_THIEF (ch))
      val = (int) (val * 1.5);
   val = val * 100 / number (100 - foo, 100 + foo);
   return val;
}

#define MAX_TARGETS   20

struct char_data *
picktarget (struct char_data *ch)
{
   struct char_data *t_ch;
   int target_table[MAX_TARGETS + 1];
   struct char_data *target_addr[MAX_TARGETS + 1];
   int a, b, c, d, n_a;

   if (!SanityCheck (ch, "PickTarget"))
      return NULL;

   if (PLR_FLAGGED (ch, PLR_BOUND) || !AWAKE (ch) ||
       IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return NULL;

   a = 0;
   n_a = NumAttackers (ch);

   for (t_ch = world[ch->in_room].people; t_ch; t_ch = t_ch->next_in_room)
   {
      if (t_ch == ch)
	 continue;
      if (!is_aggr_to (ch, t_ch))
	 continue;
      if (a < MAX_TARGETS)
      {
	 target_table[a] = CountToughness (ch, t_ch);
	 target_addr[a] = t_ch;
	 target_table[a + 1] = -1;
	 target_addr[a + 1] = NULL;
	 a++;
      }
      else
	 break;
   }

   if (a == 0)
      return NULL;

   if (!IS_NPC (ch))
      return (target_addr[number (0, (a - 1))]);

   b = -2;
   c = -1;
   for (d = 0; d < a; d++)
      if ((target_table[d] < b) || (b == -2))
      {
	 c = d;
	 b = target_table[d];
      }
   if (c != -1)
      return target_addr[c];

   /* nope, no likely targets in room */
   return NULL;
}


void Forgive_The_Basterd(struct char_data *ch)
{
 register struct char_data *co, *next_co;


  for (co = character_list; co; co = next_co)
  {
       next_co = co->next;

    if (!IS_MOB (co))
    continue;
  if ((!MOB_FLAGGED (co, MOB_MEMORY)) && (!MEMORY (co)))
    continue;
  if (co == ch)
   continue;
  if (co->desc && co->desc->original)
         continue;
   else
   forget(co, ch);
continue;
   }
}
@


1.108
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: mobact.c,v 1.107 2009/03/19 23:16:23 myc Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: mobact.c                                      Part of FieryMUD  *
 *  Usage: Functions for generating intelligent behavior in mobiles.       *
 *         Memory procedures are here, but combat AI is outsourced.        *
 *  All rights reserved.  See license.doc for complete information.        *
 *  Redesigned by: Ben Horner (Proky of HubisMUD)                          *
 *  Redesigned again by: Laoris of FieryMUD                                *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "casting.h"
#include "ai.h"
#include "races.h"
#include "skills.h"
#include "math.h"
#include "events.h"
#include "rooms.h"
#include "fight.h"
#include "movement.h"
#include "composition.h"
#include "directions.h"
#include "act.h"

/* external structs */
extern struct char_data *combat_list;   /* head of l-list of fighting chars */
extern struct char_data *next_combat_list;

/* External functions */
ACMD(do_stand);
ACMD(do_recline);
ACMD(do_sit);
ACMD(do_kneel);
ACMD(do_fly);
ACMD(do_sweep);
ACMD(do_breathe);
ACMD(do_roar);
ACMD(do_track);
ACMD(do_hide);
ACMD(do_sneak);
ACMD(do_douse);
bool update_inventory(struct char_data *ch, struct obj_data *obj, int where);
struct char_data* check_guard(struct char_data *ch, struct char_data *victim, int gag_output);
void get_check_money(struct char_data * ch, struct obj_data * obj);
void perform_wear(struct char_data *ch, struct obj_data *obj, int where);
int find_eq_pos(struct char_data *ch, struct obj_data *obj, char *arg);
bool mob_cast(struct char_data *ch, struct char_data *tch, struct obj_data *tobj, int spellnum);
void hunt_victim (struct char_data *ch);
void start_memming(struct char_data *ch);

/* Local functions */
bool check_mob_status (struct char_data *ch);
void remember (struct char_data *ch, struct char_data *victim);
void mob_attempt_equip(struct char_data *ch);
bool mob_memory_action(struct char_data *ch, bool allow_spells);
void memory_attack_announce(struct char_data *ch, struct char_data *victim);
void memory_attack(struct char_data *ch, struct char_data *vict);
void track_victim_check(struct char_data *ch, struct char_data *vict);
bool mob_memory_check(struct char_data *ch);
/* mobile_activity subfunctions */
void mob_scavenge(struct char_data *ch);
bool mob_movement(struct char_data *ch);
bool mob_assist(struct char_data *ch);
void mob_attack(struct char_data *ch, struct char_data *victim);
bool check_spellbank(struct char_data *ch);

void mobile_activity(void) {
  register struct char_data *ch, *next_ch;
  extern int no_specials;

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    /* Players, sleeping mobs, and paralyzed, and casting mobs don't do
     * anything. */
    if (!IS_MOB(ch) || CASTING(ch) || !AWAKE(ch) ||
            EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) ||
            EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS) ||
            EFF_FLAGGED(ch, EFF_MESMERIZED))
      continue;

    /* Don't execute procs when someone is switched in. */
    if (POSSESSED(ch) || MEMMING(ch))
       continue;

    /* If lower than default position, get up. */
    if (GET_MOB_WAIT(ch) <= 0 && GET_DEFAULT_POS(ch) > GET_POS(ch) &&
        GET_STANCE(ch) >= STANCE_RESTING) {
      switch (GET_DEFAULT_POS(ch)) {
      case POS_PRONE:
        do_recline(ch, "", 0, 0);
        break;
      case POS_SITTING:
        do_sit(ch, "", 0, 0);
        break;
      case POS_KNEELING:
        do_kneel(ch, "", 0, 0);
        break;
      case POS_STANDING:
        do_stand(ch, "", 0, 0);
        break;
      case POS_FLYING:
        do_fly(ch, "", 0, 0);
        break;
      }
    }

    /* Execute any special procs. */
    if (MOB_PERFORMS_SCRIPTS(ch) && MOB_FLAGGED(ch, MOB_SPEC) && !no_specials) {
      if (mob_index[GET_MOB_RNUM(ch)].func == NULL) {
        sprintf(buf, "%s (#%d): Attempting to call non-existing mob func",
                GET_NAME(ch), GET_MOB_VNUM(ch));
        log("%s",buf);
        REMOVE_FLAG(MOB_FLAGS(ch), MOB_SPEC);
      }
      else if ((mob_index[GET_MOB_RNUM(ch)].func)(ch, ch, 0, ""))
        /* If it executes okay, go on to the next mob. */
        continue;
    }

    /* And now scavenger mobs pick up objects and wear them. */
    if (MOB_FLAGGED(ch, MOB_SCAVENGER) && !MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      mob_scavenge(ch);
      mob_attempt_equip(ch);
    }

    /*
     * All AI activity past this point in the function should only occur
     * when the mobile is not in combat.
     */
    if (FIGHTING(ch))
      continue;

    /*
     * Mobs on fire attempt to douse themselves (50% chance to attempt).
     */
    if (EFF_FLAGGED(ch, EFF_ON_FIRE) && number(0, 1)) {
      /* If the mob is flagged !CLASS_AI, then just douse, don't try to cast. */
      if (MOB_FLAGGED(ch, MOB_NO_CLASS_AI) ? TRUE :
          !mob_cast(ch, ch, NULL, SPELL_EXTINGUISH))
        do_douse(ch, "", 0, 0);
      continue;
    }

    /*
     * None of the following actions should be taken by charmies.
     */
    if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master &&
        ch->master->in_room != ch->in_room)
      continue;

    /*
     * These actions are special AI.  They're mainly class specific.
     */
    if (!MOB_FLAGGED(ch, MOB_NO_CLASS_AI)) {

      /*
       * This calls check_sorcerer_status() and check_cleric_status()
       * which cast spells like remove curse, etc.
       */
      if (check_mob_status(ch))
        continue;

      /*
       * Check the mob's spellbank and attempt to remem spells.
       */
      if (check_spellbank(ch))
        continue;

      /*
       * Only do these actions if not immortal, since immortals get
       * all skills, but we don't necessarily want them running
       * around stealing and making zombies.
       */
      if (GET_LEVEL(ch) < LVL_IMMORT) {

        /*
         * Attempt to hide/sneak for those mobs who can do it.
         */
        if (GET_SKILL(ch, SKILL_HIDE) && GET_HIDDENNESS(ch) == 0)
          do_hide(ch, "", 0, 0);

        /* Attempt to steal something from a player in the room. */
        if (GET_SKILL(ch, SKILL_STEAL) && number(0, 101) < GET_SKILL(ch, SKILL_STEAL))
          if (mob_steal(ch))
            continue;

        /* Attempt to make a zombie! */
        if (GET_SKILL(ch, SPELL_ANIMATE_DEAD) && !ch->followers &&
            !MOB_FLAGGED(ch, MOB_ANIMATED))
          if (mob_animate(ch))
            continue;
      }

    }

    /*
     * Mob movement
     *
     * Only move if the mob is standing or flying.
     */
    if (!MOB_FLAGGED(ch, MOB_SENTINEL) && GET_POS(ch) >= POS_STANDING)
      if (mob_movement(ch))
        continue;

    /*
     * Helper mobs
     *
     * This is where we assist.  A helper mob will assist any other mob,
     * unless it is fighting that mob, that mob is fighting a player
     * level 20 or less.
     */
    if (MOB_ASSISTER(ch) && !ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL))
      if (mob_assist(ch))
        continue;

    /*
     * Slow track
     *
     * This is where slow track is taken care of, because mobile_activity
     * is called once every PULSE_MOBILE.  Tracking only occurs when the
     * mob isn't sentinel, isn't fighting, is marked slow track, is
     * marked memory, has someone in its memory.
     */
    if (!MOB_FLAGGED(ch, MOB_SENTINEL) && MOB_FLAGGED(ch, MOB_SLOW_TRACK) &&
        MOB_FLAGGED(ch, MOB_MEMORY))
      if (mob_memory_action(ch, FALSE))
        continue;
  }
}


/*
 * mobile_spec_activity
 *
 * This handles special mobile activity, called every PULSE_VIOLENCE.
 */
void mobile_spec_activity (void) {
  register struct char_data *ch, *next_ch, *vict;
  int found = FALSE;

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    /* Only for mobiles who aren't fighting, asleep, or casting */
    if (!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch) || CASTING(ch))
      continue;

    /* Skip mobiles with someone switched in. */
    if (POSSESSED(ch))
      continue;

    /* Skip mobiles who are paralyzed. */
    if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
      continue;

    /* If mob isn't fighting, just decrease wait state. */
    if (GET_MOB_WAIT (ch) > 0) {
      WAIT_STATE(ch, MAX(GET_MOB_WAIT(ch) - PULSE_VIOLENCE, 0));
      continue;
    }

    /* Pets, courtesy of Banyal */
    if (PLAYERALLY(ch)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
        if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict)) {
          act("&7$n assists $s master!&0", FALSE, ch, 0, vict, TO_ROOM);
          attack(ch, check_guard(ch, FIGHTING(vict), FALSE));
          found = TRUE;
          break;
        }
      if (found)
        continue;
    }

    /* Should I start a fight? */

    /* Don't start a fight if you're too scared */
    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2) &&
        MOB_FLAGGED(ch, MOB_WIMPY))
      continue;

    /* Look for people I'd like to attack */
    if (!ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL) &&
        !EFF_FLAGGED(ch, EFF_MESMERIZED) &&
        (!EFF_FLAGGED(ch, EFF_CHARM) || (ch->master &&
         ch->master->in_room != ch->in_room))) {
      if ((vict = find_aggr_target(ch))) {
        mob_attack(ch, vict);
        continue;
      }
    }

    /*
     * Simple mob memory
     *
     * Checks room for memory targets.
     */
    if (MOB_FLAGGED(ch, MOB_MEMORY) && mob_memory_check(ch))
        continue;

    /* If cleric-type and hurt, then heal. */
    if (!MOB_FLAGGED(ch, MOB_NO_CLASS_AI))
      if ((GET_CLASS(ch) == CLASS_CLERIC || GET_CLASS(ch) == CLASS_DRUID ||
          GET_CLASS(ch) == CLASS_PRIEST || GET_CLASS(ch) == CLASS_DIABOLIST ||
          GET_CLASS(ch) == CLASS_PALADIN || GET_CLASS(ch) == CLASS_RANGER) &&
          100 * GET_HIT(ch) / GET_MAX_HIT(ch) < 95)
        if (mob_heal_up(ch))
          continue;

    /*
     * Advanced mob memory
     *
     * Attempt to summon victim, dim door to victim, or just fast track.
     */
    if (GET_SKILL(ch, SPELL_SUMMON) || GET_SKILL(ch, SPELL_DIMENSION_DOOR) ||
        MOB_FLAGGED(ch, MOB_FAST_TRACK))
      if (mob_memory_action(ch, TRUE))
        continue;
  }
}


/*
   This function is called every other combat round.  It allows NPCs who
   are in battle to attempt special skills, such as bash or spellcasting.
*/
void perform_mob_violence(void)
{
   register struct char_data *ch;

   for (ch = combat_list; ch; ch = next_combat_list) {
      next_combat_list = ch->next_fighting;
      if (IS_NPC(ch) && !ch->desc) {
         if (GET_POS(ch) > POS_KNEELING)
            GET_STANCE(ch) = STANCE_FIGHTING;

         if (GET_MOB_WAIT(ch) > 0)
            /* If the NPC is delayed, continue waiting */
            WAIT_STATE(ch, MAX ((GET_MOB_WAIT(ch) - (PULSE_VIOLENCE / 2)), 0));
         else {
            /* This NPC is ready to perform actions */
            if (GET_POS(ch) < POS_STANDING) {
               GET_POS(ch) = POS_STANDING;
               GET_STANCE(ch) = STANCE_FIGHTING;
               act("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
            } else
               mob_attack(ch, FIGHTING(ch));
         }
      }
   }
}


bool mob_movement(struct char_data *ch) {
  struct char_data *vict;
  int door = number(0, 18);

  if (door >= NUM_OF_DIRS || !CAN_GO(ch, door))
    return FALSE;
  if (ROOM_FLAGGED(CH_NDEST(ch, door), ROOM_NOMOB) ||
      ROOM_FLAGGED(CH_NDEST(ch, door), ROOM_DEATH))
    return FALSE;
  if (MOB_FLAGGED(ch, MOB_STAY_ZONE) && CH_DEST(ch, door)->zone != CH_ROOM(ch)->zone)
    return FALSE;
  if (EFF_FLAGGED(ch, EFF_CHARM) && !MOB_FLAGGED(ch, MOB_ILLUSORY))
    return FALSE;

  /* Don't wander off while someone is fighting you! */
  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
    if (FIGHTING(vict) == ch)
      return FALSE;

  if (ROOM_EFF_FLAGGED(ch->in_room, ROOM_EFF_ISOLATION)) {
    act("$n looks vainly about for an exit.", TRUE, ch, 0, 0, TO_ROOM);
    /* True since it did *something* (looking around) */
    return TRUE;
  }

  /* If we made it through all the checks above, then move! */

  /* Mobs with misdirection like to be sneaky */
  if (EFF_FLAGGED(ch, EFF_MISDIRECTION)) {
     if (number(1, NUM_OF_DIRS) == 1) {
        /* Decided to stay but pretend to move */
        perform_move(ch, door, 1, TRUE);
     } else {
        /* Decided to move */
        perform_move(ch, number(0, NUM_OF_DIRS - 1), 1, TRUE);
        SET_FLAG(EFF_FLAGS(ch), EFF_MISDIRECTING);
        perform_move(ch, door, 1, FALSE);
        REMOVE_FLAG(EFF_FLAGS(ch), EFF_MISDIRECTING);
     }
  } else
    perform_move(ch, door, 1, FALSE);
  return TRUE;
}


bool mob_assist(struct char_data *ch) {
  struct char_data *vict, *cvict = NULL;

  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
    if (!will_assist(ch, vict))
      continue;
    /*
    if (ch == vict || !FIGHTING(vict) || ch == FIGHTING(vict))
      continue;
    if (FIGHTING(vict)->in_room != ch->in_room)
      continue;
    if (!IS_NPC(vict) || MOB_FLAGGED(vict, MOB_PLAYER_PHANTASM))
      continue;
    if (IS_NPC(FIGHTING(vict)) && !MOB_FLAGGED(FIGHTING(vict), MOB_PLAYER_PHANTASM))
      continue;
      */
    if (GET_LEVEL(FIGHTING(vict)) <= 20)
      cvict = vict;
    else if (EFF_FLAGGED(FIGHTING(vict), EFF_FAMILIARITY) &&
          number(1, 100 + GET_CHA(FIGHTING(vict)) - GET_CHA(vict)) < 50) {
      act("$n moves to join the fight, but gets a good look at $N and stops, confused.",
            TRUE, ch, 0, FIGHTING(vict), TO_ROOM);
      act("You want to help, but $N looks like your friend too!",
            FALSE, ch, 0, FIGHTING(vict), TO_CHAR);
      return FALSE;
    } else {
      act("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
      mob_attack(ch, FIGHTING(vict));
      return TRUE;
    }
  }
  if (cvict) {
    int chuckle = number(1, 10);
    if (chuckle == 1)
      act("$n watches the battle in amusement.", FALSE, ch, 0, cvict, TO_ROOM);
    else if (chuckle == 2)
      act("$n chuckles as $e watches the fight.", FALSE, ch, 0, cvict, TO_ROOM);
    else if (chuckle == 3) {
      act("$n takes note of your battle tactics.", FALSE, ch, 0, FIGHTING(cvict), TO_CHAR);
      act("$n takes note of $N's battle tactics.", FALSE, ch, 0, FIGHTING(cvict), TO_ROOM);
    }
  }

  return FALSE;
}


void mob_attack(struct char_data *ch, struct char_data *victim)
{
   if (CASTING(ch))
      return;

   /* See if anyone is guarding the victim.
    * But guarding doesn't apply if this NPC was already fighting the victim. */
   if (FIGHTING(ch) != victim)
      victim = check_guard(ch, victim, FALSE);

   /* Mob should not execute any special mobile AI procedures. */
   if (!MOB_FLAGGED(ch, MOB_NO_CLASS_AI)) {

      /* Attempt special class actions first. */
      switch (GET_CLASS(ch)) {
         case CLASS_RANGER:
         case CLASS_PALADIN:
         case CLASS_ANTI_PALADIN:
            if (cleric_ai_action(ch, victim))
               return;
            /* Otherwise go on down to warrior ai action. */
         case CLASS_WARRIOR:
         case CLASS_MONK:
         case CLASS_MERCENARY:
         case CLASS_BERSERKER:
            if (warrior_ai_action(ch, victim))
               return;
            break;
         case CLASS_CLERIC:
         case CLASS_DRUID:
         case CLASS_DIABOLIST:
         case CLASS_PRIEST:
         case CLASS_SHAMAN:
            victim = weakest_attacker(ch, victim);
            if (cleric_ai_action(ch, victim))
               return;
            break;
         case CLASS_SORCERER:
         case CLASS_PYROMANCER:
         case CLASS_CRYOMANCER:
         case CLASS_NECROMANCER:
         case CLASS_ILLUSIONIST:
         case CLASS_CONJURER:
            victim = weakest_attacker(ch, victim);
            if (sorcerer_ai_action(ch, victim))
               return;
            break;
         case CLASS_ASSASSIN:
         case CLASS_THIEF:
         case CLASS_ROGUE:
         case CLASS_BARD:
            if (rogue_ai_action(ch, victim))
               return;
            break;
      }

      switch (GET_RACE(ch)) {
         case RACE_DRAGON:
         case RACE_DEMON:
            if (dragonlike_attack(ch))
               return;
            break;
      }
   }

   if (!FIGHTING(ch))
      attack(ch, victim);
}


void mob_scavenge(struct char_data *ch) {
  int best_value, value;
  struct obj_data *best_obj, *obj;

  /* If there's nothing to pick up, return.  50% chance otherwise. */
  if (!world[ch->in_room].contents || !number(0, 1))
    return;

  best_value = 0;
  best_obj = NULL;

  /* Find the most desirable item in the room. */
  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
    if (CAN_GET_OBJ(ch, obj) && (value = appraise_item(ch, obj)) > best_value) {
      best_obj = obj;
      best_value = value;
    }

  /* And then pick it up. */
  if (best_obj != NULL) {
    struct get_context *context = begin_get_transaction(ch);
    perform_get_from_room(context, best_obj);
    end_get_transaction(context, NULL);
  }
}

/*
 * mob_attempt_equip
 *
 * Makes the mob attempt to wear an item in its inventory.
 * Returns 1 as soon as something is worn or removed.  0
 * otherwise.
 */
void mob_attempt_equip(struct char_data *ch) {
  int where;
  struct obj_data *obj;

  if (GET_RACE(ch) == RACE_ANIMAL)
    return;

  for (obj = ch->carrying; obj; obj = obj->next_content) {
    if (!CAN_SEE_OBJ(ch, obj))
      continue;

    where = find_eq_pos(ch, obj, NULL);
    if (where >= 0) {
      if (GET_EQ(ch, where)) {
        if (appraise_item(ch, GET_EQ(ch, where)) >= appraise_item(ch, obj))
          continue;
        perform_remove(ch, where);
      }
      perform_wear(ch, obj, where);
      continue;
    }
    else { /* where < 0 means not wearable */
      /* Maybe handle other types of items here; eat food, I dunno */
    }
  }
}

/*
 * mob_memory_action
 *
 * Expects a mob with the MOB_MEMORY flag.
 */
bool mob_memory_action(struct char_data *ch, bool allow_spells) {
  struct descriptor_data *d, *next_d;
  memory_rec *names;

  if (!MEMORY(ch))
    return FALSE;

  /* Check everyone logged on against the memory. */
  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (STATE(d) != CON_PLAYING)
      continue;

    /* Check all the names in memory against this descriptor. */
    for (names = MEMORY(ch); names; names = names->next) {
      if (names->id != GET_IDNUM(d->character))
        continue;

      if (allow_spells && !MOB_FLAGGED(ch, MOB_NO_CLASS_AI)) {
        /* Now attempt spells that require the tracker and victim to be
           in the same zone. */
        if (world[ch->in_room].zone == world[d->character->in_room].zone) {
          /* First try to summon. */
          if (GET_LEVEL(d->character) <= GET_SKILL(ch, SKILL_SPHERE_SUMMON) + 3)
            if (mob_cast(ch, d->character, NULL, SPELL_SUMMON))
              return TRUE;
          /* Then try to dimension door. */
          if (mob_cast(ch, d->character, NULL, SPELL_DIMENSION_DOOR))
            return TRUE;
        }
      }

      if ((MOB_FLAGGED(ch, MOB_SLOW_TRACK) || MOB_FLAGGED(ch, MOB_FAST_TRACK))
            && !EVENT_FLAGGED(ch, EVENT_TRACK)) {
        do_track(ch, GET_NAMELIST(d->character), 0, 0);
        track_victim_check(ch, d->character);
        return TRUE;
      }
    }
  }
  return FALSE;
}

bool mob_memory_check(struct char_data *ch) {
  struct char_data *vict;
  memory_rec *names;

  if (!MEMORY(ch))
    return FALSE;

  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
    if (IS_NPC(vict) || !CAN_SEE(ch, vict) || PRF_FLAGGED(vict, PRF_NOHASSLE))
      continue;

    for (names = MEMORY(ch); names; names = names->next) {
      if (names->id != GET_IDNUM(vict))
        continue;
      track_victim_check(ch, vict);
      return TRUE;
    }
  }
  return FALSE;
}

void memory_attack_announce(struct char_data *ch, struct char_data *vict)
{
  /* No announcement if the mob is trying to be sneaky. */
  if (EFF_FLAGGED(ch, EFF_SNEAK) || GET_HIDDENNESS(ch) > 0)
    return;

  /* No announcement if the room is peaceful. (Because there's no attack.) */
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL))
    return;

  if (EFF_FLAGGED(ch, EFF_SILENCE)) {
    act("$n silently moves in for the attack.",
        TRUE, ch, 0, vict, TO_ROOM);
  }
  else if (GET_RACE(ch) == RACE_ANIMAL) {
    act("$n growls angrily at $N, and attacks!",
        FALSE, ch, 0, vict, TO_NOTVICT);
    act("$n growls angrily at you, and attacks!",
        FALSE, ch, 0, vict, TO_VICT);
  }
  else {
    switch(number(1, 10)) {
      case 1:
        act("$n growls, 'Thought you could walk away from a fight, eh?'",
            FALSE, ch, 0, vict, TO_ROOM);
        break;
      case 2:
        /* Using GET_NAME because a mob wouldn't growl "someone" */
        sprintf(buf, "$n growls, 'This ends here and now, %s!'",
              GET_NAME(vict));
        act(buf, FALSE, ch, 0, vict, TO_ROOM);
        break;
      case 10:
      default:
        act("$n snarls, 'You're not getting away that easily!'",
            FALSE, ch, 0, vict, TO_ROOM);
        break;
      /*
       * Add more messages here for variety!
       */
    }
  }
}

void track_victim_check(struct char_data *ch, struct char_data *vict)
{
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL))
     return;
   if (ch->in_room == vict->in_room ||
       ((vict = find_char_around_char(ch, find_vis_by_name(ch, GET_NAME(vict)))) &&
       MOB_FLAGGED(vict, MOB_PLAYER_PHANTASM)))
     if (!CASTING(ch) && !FIGHTING(ch)) {
       memory_attack_announce(ch, vict);
       mob_attack(ch, vict);
     }
}



/* Add victim to ch's memory list. */
void remember(struct char_data *ch, struct char_data *victim) {
  memory_rec *tmp;
  bool present = FALSE;

  if (!IS_NPC(ch) || IS_NPC(victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
    return;

  for (tmp = MEMORY(ch); tmp && !present; tmp = tmp->next)
    if (tmp->id == GET_IDNUM(victim))
      present = TRUE;

  if (!present) {
    CREATE(tmp, memory_rec, 1);
    tmp->next = MEMORY(ch);
    tmp->id = GET_IDNUM(victim);
    MEMORY(ch) = tmp;
  }
}


/* Make character forget a victim. */
void forget(struct char_data *ch, struct char_data *victim)
{
  memory_rec *curr, *prev = NULL;

  if (!(curr = MEMORY(ch)))
    return;

  while (curr && curr->id != GET_IDNUM(victim)) {
    prev = curr;
    curr = curr->next;
  }

  if (!curr)
    return;   /* person wasn't there at all. */

  if (curr == MEMORY(ch))
    MEMORY(ch) = curr->next;
  else
    prev->next = curr->next;

  free(curr);
}

/* erase ch's memory */
void clear_memory(struct char_data *ch) {
  memory_rec *curr, *next;

  curr = MEMORY(ch);

  while (curr) {
    next = curr->next;
    free (curr);
    curr = next;
  }

  MEMORY(ch) = NULL;
}


/* Returns true if victim is in the mob's memory, false otherwise */
bool in_memory(struct char_data *ch, struct char_data *vict) {
  memory_rec *memory;

  for (memory = MEMORY(ch); memory; memory = memory->next)
    if (memory->id == GET_IDNUM(vict))
      return TRUE;

  return FALSE;
}


/* This function checks mobs for spell ups */
bool check_mob_status (struct char_data *ch) {
  switch (GET_CLASS(ch)) {
    case CLASS_SORCERER:
    case CLASS_PYROMANCER:
    case CLASS_CRYOMANCER:
    case CLASS_NECROMANCER:
    case CLASS_ILLUSIONIST:
      if (check_sorcerer_status(ch))
        return TRUE;
      break;
    case CLASS_CLERIC:
    case CLASS_DRUID:
    case CLASS_PRIEST:
    case CLASS_DIABOLIST:
    case CLASS_PALADIN:
    case CLASS_ANTI_PALADIN:
      /* check_cleric_status is useless in combat */
      if (!FIGHTING(ch) && check_cleric_status(ch))
        return TRUE;
      break;
  }
  return FALSE;
}

bool check_spellbank(struct char_data *ch)
{
  int i;
  /* If any spell circles are not fully charged, start memming and 
   * return TRUE */
  for (i = 1; i < NUM_SPELL_CIRCLES; ++i)
    if (GET_MOB_SPLBANK(ch, i) < spells_of_circle[(int) GET_LEVEL(ch)][i]) {
      do_sit(ch, NULL, 0, 0);
      if (GET_POS(ch) == POS_SITTING &&
          GET_STANCE(ch) >= STANCE_RESTING &&
          GET_STANCE(ch) <= STANCE_ALERT) {
        act(MEM_MODE(ch) == PRAY ? "$n begins praying to $s deity." :
            "$n takes out $s books and begins to study.",
            TRUE, ch, 0, 0, TO_ROOM);
        start_memming(ch);
        return TRUE;
      }
    }
  return FALSE;
}

void remove_from_all_memories(struct char_data *ch) {
  register struct char_data *tch, *next_tch;

  for (tch = character_list; tch; tch = next_tch) {
    next_tch = tch->next;

    if (!MOB_FLAGGED(tch, MOB_MEMORY) || !MEMORY(tch))
      continue;
    if (tch == ch)
      continue;
    if (POSSESSED(tch))
      continue;
    else
      forget(tch, ch);
  }
}

bool dragonlike_attack(struct char_data *ch) {
  int roll = number(0, 125 - GET_LEVEL(ch));

  /* At level 100, 10% chance to breath, 2% chance for each different type */
  if (roll < 5 && GET_SKILL(ch, SKILL_BREATHE)) {
    switch (GET_COMPOSITION(ch)) {
    case COMP_EARTH:
    case COMP_STONE:
      do_breathe(ch, "acid", 0, 0);
      break;
    case COMP_AIR:
    case COMP_ETHER:
      do_breathe(ch, "lightning", 0, 0);
      break;
    case COMP_FIRE:
    case COMP_LAVA:
      do_breathe(ch, "fire", 0, 0);
      break;
    case COMP_WATER:
    case COMP_ICE:
    case COMP_MIST:
      do_breathe(ch, "frost", 0, 0);
      break;
    case COMP_METAL:
    case COMP_BONE:
    case COMP_PLANT:
      do_breathe(ch, "gas", 0, 0);
      break;
    default:
      switch (roll) {
      case 0:
        do_breathe(ch, "fire", 0, 0);
        break;
      case 1:
        do_breathe(ch, "gas", 0, 0);
        break;
      case 2:
        do_breathe(ch, "frost", 0, 0);
        break;
      case 3:
        do_breathe(ch, "acid", 0, 0);
        break;
      case 4:
      default:
        do_breathe(ch, "lightning", 0, 0);
        break;
      }
    }
    return TRUE;
  }

  /* At level 100, 10% chance to sweep */
  else if (roll < 10 && GET_SKILL(ch, SKILL_SWEEP)) {
    do_sweep(ch, "", 0, 0);
    return TRUE;
  }

  /* At level 100, 10% chance to roar */
  else if (roll < 15 && GET_SKILL(ch, SKILL_ROAR)) {
    int cmd_roar = find_command("roar");
    /*
     * Since do_roar can map to do_action, we MUST find the correct
     * cmd value for roar here.  If we do not and the roar fails, it
     * may get passed to do_action, which will cause the game to
     * crash if passed an invalid cmd value.
     */
    do_roar(ch, "", cmd_roar, 0);
    return TRUE;
  }
  return FALSE;
}

/***************************************************************************
 * $Log: mobact.c,v $
 * Revision 1.107  2009/03/19 23:16:23  myc
 * Moved get command to its own file.
 *
 * Revision 1.106  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.105  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.104  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.103  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.102  2009/02/18 19:25:57  myc
 * Paladins and anti-paladins will try to cast soulshield etc now.
 *
 * Revision 1.101  2009/02/04 21:07:25  myc
 * Mobs using dragonbreath will attempt to match type to composition.
 *
 * Revision 1.100  2009/01/19 09:25:23  myc
 * Removed MOB_PET flag.
 *
 * Revision 1.99  2009/01/17 00:28:02  myc
 * Fix possible use of uninitialized variable.
 *
 * Revision 1.98  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.97  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.96  2008/09/13 18:52:51  jps
 * Cause mobs to scan for victims even if they aren't aggressive to players.
 * They could be aggressive for other reasons.
 *
 * Revision 1.95  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.94  2008/08/31 20:54:08  jps
 * Using will_assist() function which is in ai_utils.c.
 *
 * Revision 1.93  2008/08/31 17:04:19  myc
 * Remove debug message from mob tracking.
 *
 * Revision 1.92  2008/08/25 00:20:33  myc
 * Changed the way mobs memorize spells.
 *
 * Revision 1.91  2008/08/15 04:07:08  jps
 * Fix isolation check
 *
 * Revision 1.90  2008/08/10 16:46:49  jps
 * Stop mobs from wandering out of rooms with ISOLATION.
 *
 * Revision 1.89  2008/05/20 02:38:17  jps
 * Fix mob attack declaration.
 *
 * Revision 1.88  2008/05/19 06:51:39  jps
 * Cause illusionists to cast sorcerer spells.
 *
 * Revision 1.87  2008/05/19 06:33:53  jps
 * Cause wandering mobs to make use of misdirection.
 *
 * Revision 1.86  2008/05/19 05:47:50  jps
 * Don't allow actions when mesmerized.
 *
 * Revision 1.85  2008/05/18 20:46:19  jps
 * Helper mobs may hesitate when the one they would attack has FAMILIARITY.
 *
 * Revision 1.84  2008/05/18 20:15:57  jps
 * Moved glory checking to find_aggr_target.
 *
 * Revision 1.83  2008/05/18 03:49:13  jps
 * Try to stop wimpy mobs from attacking when they're hurt.
 *
 * Revision 1.82  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.81  2008/04/20 03:54:28  jps
 * Make mobs use the same tracking as players.
 *
 * Revision 1.80  2008/04/19 20:17:27  jps
 * Stop intra-fight mob attacks from invoking the guard response.
 *
 * Revision 1.79  2008/04/18 16:13:05  mud
 * Make illusionists do sorcerer AI.
 *
 * Revision 1.78  2008/04/14 02:19:18  jps
 * Implementing EFF_GLORY.  Aggressive mobs are distracted and probably won't
 * attack while someone with GLORY is in their presence.
 *
 * Revision 1.77  2008/04/10 01:38:38  myc
 * Fix handling of default position handling in mob ai so they'll
 * stop standing when flying.
 *
 * Revision 1.76  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.75  2008/04/04 06:12:52  myc
 * Removed justice code.
 *
 * Revision 1.74  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.73  2008/03/17 15:31:27  myc
 * WAIT_STATE macro changed internally.
 *
 * Revision 1.72  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.71  2008/03/10 18:01:17  myc
 * Bug: was setting POS1 to POS_STANDING.
 *
 * Revision 1.70  2008/03/09 18:10:32  jps
 * perform_move may be misdirected now.
 *
 * Revision 1.69  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.68  2008/03/08 23:54:54  jps
 * Check whether a mob performs scripts when initiating specprocs.
 *
 * Revision 1.67  2008/02/11 21:04:01  myc
 * Mobs won't try to autocast summon if the target is too high level.
 *
 * Revision 1.66  2008/02/09 21:07:50  myc
 * Casting macro now checks event flags instead of mob flags.
 *
 * Revision 1.65  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.64  2008/02/01 17:55:09  myc
 * Fixed a crash bug where do_roar was being called with an invalid
 * cmd value.
 *
 * Revision 1.63  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.62  2008/01/28 00:14:32  jps
 * Fix rogue NPC attacking.
 *
 * Revision 1.61  2008/01/27 21:14:59  myc
 * Replace hit() with attack().
 *
 * Revision 1.60  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.59  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.58  2008/01/22 14:59:23  jps
 * Fix chuckles-at-fight bug.
 *
 * Revision 1.57  2008/01/21 02:44:26  myc
 * Make peaceful mobs not assist.
 *
 * Revision 1.56  2008/01/20 23:18:52  myc
 * Fixed mob AI to only leave out class actions.
 *
 * Revision 1.55  2008/01/16 04:12:00  myc
 * Moving pick_target from here to fight.c (renamed find_aggr_target).
 *
 * Revision 1.54  2008/01/14 21:28:32  myc
 * Moved is_aggr_to to fight.c.
 *
 * Revision 1.53  2008/01/14 20:38:42  myc
 * Fixed a crash bug (infinite recursion) in is_aggr_to.
 *
 * Revision 1.52  2008/01/13 23:06:04  myc
 * Removed the NumAttackers function.  Changed mob_scavenge to use
 * appraise_item in ai_utils.
 *
 * Revision 1.51  2008/01/13 03:19:53  myc
 * Made immortal mobs not use hide, steal, and animate dead.
 * Added a check_guard call.
 *
 * Revision 1.50  2008/01/12 23:13:20  myc
 * Cleaned up mobact a bunch.  Subfunctionalized a bunch of actions, added a few,
 * and replaced try_cast with direct calls to mob_cast, which now supports
 * target objects.
 *
 * Revision 1.49  2008/01/12 19:12:05  myc
 * Oops, accidentally erased some of the log entries.
 *
 * Revision 1.48  2008/01/12 19:08:14  myc
 * Rerowte a lot of mob AI functionality.
 *
 * Revision 1.47  2008/01/07 11:57:57  jps
 * Allow illusory mobs to wander.
 *
 * Revision 1.46  2008/01/07 10:34:53  jps
 * Allow mobs to be aggressive to player phantasms.  Mobs will also pause
 * in their tracking to kill such, but won't be fooled once the phantasm dies.
 *
 * Revision 1.45  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.44  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.43  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.42  2007/10/27 03:18:58  myc
 * Fixed bug in CAN_SEE so mobs can see without lights.  Removed MCAN_SEE
 * since it does the same thing as CAN_SEE.
 *
 * Revision 1.41  2007/09/08 23:19:23  jps
 * Stop memory mobs from blabbering when they try to start fights
 * in peaceful rooms.
 *
 * Revision 1.40  2007/09/07 19:51:30  jps
 * Added more checks for death after special initial attack, in
 * response to another aggressive-mob-killing-player crash bug.
 *
 * Revision 1.39  2007/08/29 01:22:18  jps
 * An assisting mob's initial special attack might well kill its
 * target.  Made the code check for that, and not press the
 * attack further if so.
 *
 * Revision 1.38  2007/08/26 01:55:41  myc
 * Fire now does real damage.  All fire spells have a chance to catch the
 * victim on fire.  Mobs attempt to douse themselves.
 *
 * Revision 1.37  2007/08/16 11:53:58  jps
 * Remove references to defunct specprocs.
 *
 * Revision 1.36  2007/08/05 22:19:17  myc
 * Set POS1 in addition to POS when a mob scrambles back to its feet.
 *
 * Revision 1.35  2007/07/18 21:05:16  jps
 * Make mobs behave mercifully toward other mobs only when
 * they are flagged NOVICIOUS.
 *
 * Revision 1.34  2007/07/18 17:02:25  jps
 * Stop helpers from rushing to assist their buddy if their buddy's
 * attacker has left the room.
 *
 *
 * Revision 1.33  2007/04/11 16:05:27  jps
 * Scavengers who pick up money won't end up with the money pile object in inventory.
 *
 * Revision 1.32  2007/03/27 04:27:05  myc
 * Fixed typo in battle message.
 *
 * Revision 1.31  2007/02/08 01:32:20  myc
 * Hopefully no crashes when mobs are killed by circle of fire now.
 *
 * Revision 1.30  2006/12/08 04:01:13  myc
 * Aggro mobs don't all announce their attack like memory mobs now.
 *
 * Revision 1.29  2006/11/27 00:17:00  jps
 * Fix mob tracking oops
 *
 * Revision 1.28  2006/11/20 09:03:58  jps
 * Mobs with memory attack - not just the ones with track.
 * They also give some announcement or make noise as they do.
 *
 * Revision 1.27  2006/11/20 07:25:34  jps
 * Stop mobs from wandering off in the middle of a battle, such as
 * when they get up after being bashed.
 *
 * Revision 1.26  2006/11/17 22:52:59  jps
 * Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
 *
 * Revision 1.25  2002/09/30 01:12:32  jjl
 * Added checks so guard does something.
 *
 * Revision 1.24  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.23  2001/04/07 03:02:59  dce
 * Mobs will no longer be agrresive to each other with the
 * MOB_AGGRESSIVE flag...a new flag will be coming soon.
 *
 * Revision 1.22  2000/11/28 00:45:28  mtp
 * removed mobprog stuff
 *
 * Revision 1.21  2000/11/24 18:42:20  rsd
 * Added back rlog messages from prior to the addition of
 * the $log$ string.
 *
 * Revision 1.20  2000/04/24 20:00:41  rsd
 * Ok, mobiles really don't wear eq and wield weapons now,
 * I swear!
 *
 * Revision 1.19  2000/04/22 22:38:37  rsd
 * Fixed comment header, fixed logged information about weapon exchange
 * to include ch's name. Also encouraged animals not to try to wield weapons.
 *
 * Revision 1.18  2000/02/25 03:32:11  cso
 * fixing typos.. guard chuckles at you as he watches the fight
 *
 * Revision 1.17  1999/12/06 20:21:04  cso
 * Fixed a typo in line "takes note of your battle tactics."
 *
 * Revision 1.16  1999/11/28 23:51:54  cso
 * added check to mobile_activity to keep charmed mobs from wandering
 *
 * Revision 1.15  1999/11/23 15:48:23  jimmy
 * Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
 * Reinstated dual wield.
 * Allowed mobs/players to pick up items while fighting.
 * Fixed a bug in the damage message that wrongfully indicated a miss
 * due to a rounding error in the math.
 * This was all done in order to facilitate the chance to sling your
 * weapon in combat.  Dex and proficiency checks are now made on any missed
 * attact and a failure of both causes the weapon to be slung.
 *
 * Revision 1.14  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.13  1999/09/04 18:46:52  jimmy
 * More small but important bug fixes found with insure.  These are all runtime fixes.
 *
 * Revision 1.12  1999/07/25 05:40:18  jimmy
 * Fixed the skill advancement in peace rooms bug.
 * --gurlaek
 *
 * Revision 1.11  1999/07/14 19:24:03  jimmy
 * The combat system was enhanced/improved in the following ways:  Mobs
 * can no longer flee while bashed or sitting.  Fleeing causes casters to
 * stop casting.  You can now flee while flying.  pk checks were added to
 * bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
 * fixes. spellcasting for mobs is now very similar to PC spellcasting.
 * MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
 * Mobs no longer improve skills.  Bash now requires mobs to have a shield
 * just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
 * --gurlaek
 *
 * Revision 1.10  1999/07/12 02:58:46  jimmy
 * Lots of formatting and general cleanup. No code changes.
 * gurlaek.
 *
 * Revision 1.9  1999/07/06 19:57:05  jimmy
 * This is a Mass check-in of the new skill/spell/language assignment system.
 * This New system combines the assignment of skill/spell/language for
 * both mobs and PCs.  LOts of code was touched and many errors were fixed.
 * MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
 * MObs now get random skill/spell/language levels baseed on their race/class/level
 * that exactly align with PC's.  PC's no longer have to rent to use skills gained
 * by leveling or when first creating a char.  Languages no longer reset to defaults
 * when a PC levels.  Discovered that languages have been defined right in the middle
 * of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
 * the mob files to compensate for the 13 to -1 class change.
 * --gurlaek 7/6/1999
 *
 * Revision 1.8  1999/05/02 19:32:34  dce
 * Temporarly make fast track = slow track
 *
 * Revision 1.7  1999/04/04 04:05:12  dce
 * Mob fighting fixes
 *
 * Revision 1.6  1999/04/04 03:42:41  dce
 * Mobs don't atack each other...only if AGGR_ALIGN.
 *
 * Revision 1.5  1999/03/31 22:06:06  dce
 * Allows flying mobs to wander.
 *
 * Revision 1.4  1999/03/22 18:57:32  tph
 * mobs nolonger try_cast in NOMAGIC rooms.
 *
 * Revision 1.3  1999/02/04 21:07:27  jimmy
 * Made mobs aggressive to each other.
 * fingon
 *
 * Revision 1.2  1999/01/31 17:19:29  mud
 * Added a standard comment header
 * Indented the entire file
 * took out some ranges of blank space
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.107
log
@Moved get command to its own file.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.106 2009/03/09 04:33:20 jps Exp myc $
d128 1
a128 1
        log(buf);
d931 3
@


1.106
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.105 2009/03/08 23:34:14 jps Exp jps $
d38 1
a63 1
void perform_get_from_room(struct char_data *ch, struct obj_data *obj);
d552 5
a556 2
  if (best_obj != NULL)
    perform_get_from_room(ch, best_obj);
d931 4
@


1.105
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.104 2009/03/08 21:43:27 jps Exp jps $
d37 1
d928 3
@


1.104
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.103 2009/03/03 19:43:44 myc Exp jps $
d27 1
a27 1
#include "spells.h"
d927 3
@


1.103
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.102 2009/02/18 19:25:57 myc Exp myc $
d36 1
d927 3
@


1.102
log
@Paladins and anti-paladins will try to cast soulshield etc now.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.101 2009/02/04 21:07:25 myc Exp myc $
d706 1
a706 1
       ((vict = get_char_vis(ch, GET_NAME(vict))) &&
d926 3
@


1.101
log
@Mobs using dragonbreath will attempt to match type to composition.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.100 2009/01/19 09:25:23 myc Exp myc $
d804 2
d926 3
@


1.100
log
@Removed MOB_PET flag.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.99 2009/01/17 00:28:02 myc Exp myc $
d855 25
a879 1
    switch (roll) {
d896 1
d924 3
@


1.99
log
@Fix possible use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.98 2008/09/21 20:40:40 jps Exp myc $
d277 1
a277 1
    if (IS_NPC(ch) && MOB_FLAGGED(ch, MOB_PET)) {
d899 3
@


1.98
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.97 2008/09/20 06:05:06 jps Exp jps $
d415 1
a415 2
  struct char_data *vict, *cvict;
  int chuckle = 0;
d430 1
a430 1
    if (GET_LEVEL(FIGHTING(vict)) <= 20) {
d432 1
a432 2
      chuckle = 1;
    } else if (EFF_FLAGGED(FIGHTING(vict), EFF_FAMILIARITY) &&
d445 2
a446 2
  if (chuckle) {
    chuckle = number(1, 10);
d899 4
@


1.97
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.96 2008/09/13 18:52:51 jps Exp jps $
a347 6

      if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) {
         stop_fighting (ch);
         continue;
      }

d901 3
@


1.96
log
@Cause mobs to scan for victims even if they aren't aggressive to players.
They could be aggressive for other reasons.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.95 2008/09/01 23:47:49 jps Exp jps $
d96 2
a97 5
    if (ch->desc && ch->desc->original)
      continue;

    if (MEMMING(ch))
      continue;
d263 1
a263 1
    if (ch->desc && ch->desc->original)
d851 1
a851 1
    if (tch->desc && tch->desc->original)
d907 4
@


1.95
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.94 2008/08/31 20:54:08 jps Exp jps $
d300 1
a300 1
    /* Aggressive mobs look for victims */
a301 6
        (MOB_FLAGGED(ch, MOB_AGGRESSIVE) ||
         MOB_FLAGGED(ch, MOB_AGGR_EVIL) ||
         MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) ||
         MOB_FLAGGED(ch, MOB_AGGR_GOOD) ||
         MOB_FLAGGED(ch, MOB_AGGR_EVIL_RACE) ||
         MOB_FLAGGED(ch, MOB_AGGR_GOOD_RACE)) &&
d910 3
@


1.94
log
@Using will_assist() function which is in ai_utils.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.93 2008/08/31 17:04:19 myc Exp jps $
d35 1
a65 1
bool is_grouped (struct char_data *ch, struct char_data *tch);
d916 3
@


1.93
log
@Remove debug message from mob tracking.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.92 2008/08/25 00:20:33 myc Exp myc $
a65 1
bool in_memory (struct char_data *ch, struct char_data *vict);
d229 1
a229 2
    if (MOB_FLAGGED(ch, MOB_HELPER) && !MOB_FLAGGED(ch, MOB_PEACEFUL) &&
        !ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL))
d434 3
d445 1
d916 3
@


1.92
log
@Changed the way mobs memorize spells.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.91 2008/08/15 04:07:08 jps Exp myc $
a641 1
         printf("Mob tracking %s\n", GET_NAMELIST(d->character));
d914 3
@


1.91
log
@Fix isolation check
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.90 2008/08/10 16:46:49 jps Exp jps $
d61 1
d79 1
d100 3
a124 7
    /* If on fire, attempt to douse */
    if (EFF_FLAGGED(ch, EFF_ON_FIRE))
      if (GET_STANCE(ch) == STANCE_ALERT) {
        do_douse(ch, "", 0, 0);
        continue;
      }

d182 6
a792 17
void casting_gain(void) {
  struct char_data *ch, *next_char;
  int circle = 0;

  for (ch = character_list; ch; ch = next_char) {
    next_char = ch->next;
    /* NPCs only: regain spells in mob spell circles */
    if (IS_NPC(ch)) {
      for (circle = 0; circle <= (GET_LEVEL(ch) - 1)/ 8 && circle <= 12; circle++)
        if (ch->mob_specials.mem_memed[circle] < spells_of_circle[(int) GET_LEVEL(ch)][circle + 1])
          ch->mob_specials.mem_memed[circle] = MIN(ch->mob_specials.mem_memed[circle] + 2,
                  spells_of_circle[(int) GET_LEVEL(ch)][circle + 1]);
    }
  }
}


d828 21
d915 3
@


1.90
log
@Stop mobs from wandering out of rooms with ISOLATION.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.89 2008/05/20 02:38:17 jps Exp jps $
d401 1
a401 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_EFF_ISOLATION)) {
d907 3
@


1.89
log
@Fix mob attack declaration.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.88 2008/05/19 06:51:39 jps Exp jps $
d401 6
d907 3
@


1.88
log
@Cause illusionists to cast sorcerer spells.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.87 2008/05/19 06:33:53 jps Exp jps $
d690 4
a693 2
        act("$n growls, 'This ends here and now, %N!'",
            FALSE, ch, 0, vict, TO_ROOM);
d901 3
@


1.87
log
@Cause wandering mobs to make use of misdirection.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.86 2008/05/19 05:47:50 jps Exp jps $
d817 1
d899 3
@


1.86
log
@Don't allow actions when mesmerized.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.85 2008/05/18 20:46:19 jps Exp jps $
d402 15
a416 1
  perform_move(ch, door, 1, FALSE);
d898 3
@


1.85
log
@Helper mobs may hesitate when the one they would attack has FAMILIARITY.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.84 2008/05/18 20:15:57 jps Exp jps $
d90 2
a91 1
            EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
d306 1
d884 3
@


1.84
log
@Moved glory checking to find_aggr_target.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.83 2008/05/18 03:49:13 jps Exp jps $
d421 7
d882 3
@


1.83
log
@Try to stop wimpy mobs from attacking when they're hurt.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.82 2008/05/17 22:03:01 jps Exp jps $
d34 1
a60 2
bool is_aggr_to(struct char_data *ch, struct char_data *tch);
EVENTFUNC(quick_aggro_event);
a63 1
int appraise_opponent(struct char_data *ch, struct char_data *victim);
d307 2
a308 8
      found = FALSE;
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
        if (is_aggr_to(ch, vict)) {
          mob_attack(ch, vict);
          found = TRUE;
          break;
        }
      if (found)
d310 1
a444 2
   struct char_data *glorion;

a447 35
   /* Is there anyone in the room with GLORY to distract this attacker? */
   if (EFF_FLAGGED(victim, EFF_GLORY))
       glorion = victim;
   else
       for (glorion = world[ch->in_room].people;
                glorion && !(EFF_FLAGGED(glorion, EFF_GLORY) && CAN_SEE(ch, glorion));
                glorion = glorion->next_in_room);

   if (glorion && EFF_FLAGGED(glorion, EFF_GLORY)) {
       /* Someone is here with GLORY.   The initial target won't be attacked.
         * (Unless they are the same person.) */
       if (number(1, 100) < 3 && !PRF_FLAGGED(glorion, PRF_NOHASSLE)) {
            /* They get attacked! */
            act("$n forgets $s appreciation of $N's glorious appearance, and attacks!",
                     TRUE, ch, 0, glorion, TO_NOTVICT);
            act("The look of awe in $N's eyes falters, and $e attacks!",
                     TRUE, glorion, 0, ch, TO_CHAR);
            act("You see right through $N's magical disguise!",
                     FALSE, ch, 0, glorion, TO_CHAR);
            event_create(EVENT_QUICK_AGGRO, quick_aggro_event,
                     mkgenericevent(ch, glorion, 0), TRUE, &(ch->events), 0);
            victim = glorion;
       } else {
            /* Glory wins: no attack. */
            if (number(1, 8) == 1) {
                act("$n looks upon $N with awe in $s eyes.",
                         TRUE, ch, 0, glorion, TO_NOTVICT);
                act("$n gazes at you in wonder.", TRUE, ch, 0, glorion, TO_VICT);
                act("You are distracted by $N's unearthly beauty.",
                         TRUE, ch, 0, glorion, TO_CHAR);
            }
            return; /* No attack. */
       }
   }

d875 3
@


1.82
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.81 2008/04/20 03:54:28 jps Exp jps $
d292 8
a299 1
    /* Aggressive Mobs */
d323 1
a323 1
     * Checks room for memory targets but only if not wimpy.
d325 1
a325 3
    if (MOB_FLAGGED(ch, MOB_MEMORY) && !(MOB_FLAGGED(ch, MOB_WIMPY) &&
        GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)))
      if (mob_memory_check(ch))
d787 1
a787 1
void clear_memory (struct char_data *ch) {
d919 3
@


1.81
log
@Make mobs use the same tracking as players.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.80 2008/04/19 20:17:27 jps Exp jps $
d33 1
d388 2
a389 2
  if (ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_NOMOB) ||
      ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_DEATH))
d391 1
a391 2
  if (MOB_FLAGGED(ch, MOB_STAY_ZONE) &&
      world[EXIT(ch, door)->to_room].zone != world[ch->in_room].zone)
d914 3
@


1.80
log
@Stop intra-fight mob attacks from invoking the guard response.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.79 2008/04/18 16:13:05 mud Exp jps $
d47 1
a47 1
ACMD(do_DumbMobTrack);
d646 4
a649 2
      if (MOB_FLAGGED(ch, MOB_SLOW_TRACK) || MOB_FLAGGED(ch, MOB_FAST_TRACK)) {
        do_DumbMobTrack(ch, GET_NAMELIST(d->character), 0, 0);
d914 3
@


1.79
log
@Make illusionists do sorcerer AI.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.78 2008/04/14 02:19:18 jps Exp mud $
d35 1
a35 1
extern struct char_data *combat_list;	/* head of l-list of fighting chars */
d87 1
a87 1
    /* Players, sleeping mobs, and paralyzed, and casting mobs don't do 
d147 1
a147 1
     * All AI activity past this point in the function should only occur 
d202 1
a202 1
        if (GET_SKILL(ch, SPELL_ANIMATE_DEAD) && !ch->followers && 
d234 1
a234 1
     * This is where slow track is taken care of, because mobile_activity 
d255 1
a255 1
  
d276 1
a276 1
    
d345 2
a346 3
   This function is called each second to check if mob ready to do a special 
   attack PLEASE DO NOT CHANGE IT IT IS VERY VERY TOUCHY!!
   Proky
d350 1
a350 4
  register struct char_data *ch;

  for (ch = combat_list; ch; ch = next_combat_list) {
    next_combat_list = ch->next_fighting;
d352 2
a353 4
    if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) {
      stop_fighting (ch);
      continue;
    }
d355 3
a357 3
    if (IS_NPC(ch) && !ch->desc) {
      if (GET_POS(ch) > POS_KNEELING) {
        GET_STANCE(ch) = STANCE_FIGHTING;
d360 16
a375 11
      /* Stand mob up if no pause */
      if (GET_MOB_WAIT(ch) > 0)
        WAIT_STATE(ch, MAX ((GET_MOB_WAIT(ch) - (PULSE_VIOLENCE / 2)), 0));
      else if (GET_MOB_WAIT(ch) <= 0) {
        if (GET_POS(ch) < POS_STANDING) {
          GET_POS(ch) = POS_STANDING;
          GET_STANCE(ch) = STANCE_FIGHTING;
          act("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
          continue;
        }
        mob_attack(ch, FIGHTING(ch));
d377 1
a377 2
    }
  }
d445 2
a446 1
void mob_attack(struct char_data *ch, struct char_data *victim) {
d449 2
a450 2
  if (CASTING(ch))
    return;
d452 85
a536 34
  /* Is there anyone in the room with GLORY to distract this attacker? */
  if (EFF_FLAGGED(victim, EFF_GLORY))
     glorion = victim;
  else
     for (glorion = world[ch->in_room].people;
           glorion && !(EFF_FLAGGED(glorion, EFF_GLORY) && CAN_SEE(ch, glorion));
           glorion = glorion->next_in_room);

  if (glorion && EFF_FLAGGED(glorion, EFF_GLORY)) {
     /* Someone is here with GLORY.  The initial target won't be attacked.
      * (Unless they are the same person.) */
     if (number(1, 100) < 3 && !PRF_FLAGGED(glorion, PRF_NOHASSLE)) {
        /* They get attacked! */
        act("$n forgets $s appreciation of $N's glorious appearance, and attacks!",
              TRUE, ch, 0, glorion, TO_NOTVICT);
        act("The look of awe in $N's eyes falters, and $e attacks!",
              TRUE, glorion, 0, ch, TO_CHAR);
        act("You see right through $N's magical disguise!",
              FALSE, ch, 0, glorion, TO_CHAR);
        event_create(EVENT_QUICK_AGGRO, quick_aggro_event,
              mkgenericevent(ch, glorion, 0), TRUE, &(ch->events), 0);
        victim = glorion;
     } else {
        /* Glory wins: no attack. */
        if (number(1, 8) == 1) {
           act("$n looks upon $N with awe in $s eyes.",
                 TRUE, ch, 0, glorion, TO_NOTVICT);
           act("$n gazes at you in wonder.", TRUE, ch, 0, glorion, TO_VICT);
           act("You are distracted by $N's unearthly beauty.",
                 TRUE, ch, 0, glorion, TO_CHAR);
        }
        return; /* No attack. */
     }
  }
d538 8
a545 57
  /* See if anyone is guarding the victim. */
  victim = check_guard(ch, victim, FALSE);

  /* Mob should not execute any special mobile AI procedures. */
  if (!MOB_FLAGGED(ch, MOB_NO_CLASS_AI)) {

    /* Attempt special class actions first. */
    switch (GET_CLASS(ch)) {
      case CLASS_RANGER:
      case CLASS_PALADIN:
      case CLASS_ANTI_PALADIN:
        if (cleric_ai_action(ch, victim))
          return;
        /* Otherwise go on down to warrior ai action. */
      case CLASS_WARRIOR:
      case CLASS_MONK:
      case CLASS_MERCENARY:
      case CLASS_BERSERKER:
        if (warrior_ai_action(ch, victim))
          return;
        break;
      case CLASS_CLERIC:
      case CLASS_DRUID:
      case CLASS_DIABOLIST:
      case CLASS_PRIEST:
      case CLASS_SHAMAN:
        victim = weakest_attacker(ch, victim);
        if (cleric_ai_action(ch, victim))
          return;
        break;
      case CLASS_SORCERER:
      case CLASS_PYROMANCER:
      case CLASS_CRYOMANCER:
      case CLASS_NECROMANCER:
      case CLASS_ILLUSIONIST:
      case CLASS_CONJURER:
        victim = weakest_attacker(ch, victim);
        if (sorcerer_ai_action(ch, victim))
          return;
        break;
      case CLASS_ASSASSIN:
      case CLASS_THIEF:
      case CLASS_ROGUE:
      case CLASS_BARD:
        if (rogue_ai_action(ch, victim))
          return;
        break;
    }

    switch (GET_RACE(ch)) {
      case RACE_DRAGON:
      case RACE_DEMON:
        if (dragonlike_attack(ch))
          return;
        break;
    }
  }
d547 2
a548 2
  if (!FIGHTING(ch))
    attack(ch, victim);
d704 5
d738 1
a738 1
  
d741 1
a741 1
  
d745 1
a745 1
  
d759 1
a759 1
  
d762 1
a762 1
  
d767 1
a767 1
  
d769 2
a770 2
    return;			/* person wasn't there at all. */
  
d775 1
a775 1
  
d782 1
a782 1
  
d784 1
a784 1
  
d790 1
a790 1
  
d798 1
a798 1
  
d805 1
a805 1
          ch->mob_specials.mem_memed[circle] = MIN(ch->mob_specials.mem_memed[circle] + 2, 
d848 1
a848 1
  
d851 1
a851 1
    
d912 3
@


1.78
log
@Implementing EFF_GLORY.  Aggressive mobs are distracted and probably won't
attack while someone with GLORY is in their presence.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.77 2008/04/10 01:38:38 myc Exp jps $
d522 1
d906 4
@


1.77
log
@Fix handling of default position handling in mob ai so they'll
stop standing when flying.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.76 2008/04/07 03:02:54 jps Exp myc $
d60 1
d448 2
d453 35
d905 4
@


1.76
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.75 2008/04/04 06:12:52 myc Exp jps $
d40 4
d97 14
a110 3
    /* If sitting, and default position is standing, stand up. */
    if (GET_POS(ch) < POS_STANDING && GET_MOB_WAIT(ch) <= 0 &&
            GET_DEFAULT_POS(ch) >= POS_STANDING) {
d112 5
a116 1
        continue;
d121 1
a121 1
      if (GET_STANCE(ch) != STANCE_FIGHTING) {
d867 4
@


1.75
log
@Removed justice code.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.74 2008/03/28 17:54:53 myc Exp myc $
d94 1
a94 1
    if (GET_POS(ch) < POS_FIGHTING && GET_MOB_WAIT(ch) <= 0 &&
d102 1
a102 1
      if (GET_POS(ch) > POS_FIGHTING) {
d329 2
a330 1
void perform_mob_violence (void) {
d335 1
a335 1
    
d342 2
a343 3
      if (GET_POS(ch) > POS_FIGHTING) {
        GET_POS(ch) = POS_FIGHTING;
        GET_STANCE(ch) = STANCE_STANDING;
d350 3
a352 3
        if (GET_POS(ch) < POS_FIGHTING) {
          GET_POS(ch) = POS_FIGHTING;
          GET_STANCE(ch) = STANCE_STANDING;
d848 3
@


1.74
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.73 2008/03/17 15:31:27 myc Exp myc $
a53 1
void perform_arrest (struct char_data *vict);
a292 11
     * Remnants of the justice system.
     *
     * If the mob is an arrestor, but has no one else on its memory list, 
     * then its purpose is finished.
     */
    if (MOB_FLAGGED(ch, MOB_ARRESTOR) && !MEMORY(ch)) {
      extract_char(ch);
      continue;
    }

    /*
a430 8
  /* If the mob is an arrestor, he's here to arrest, not kill. */
  if (MOB_FLAGGED(ch, MOB_ARRESTOR)) {
    perform_arrest(victim);
    forget(ch, victim);
    extract_char(ch);
    return;
  }

d611 1
a611 10
      /*
       * If the mob is an arrestor, then he's here to arrest, not kill.
       */
      if (MOB_FLAGGED(ch, MOB_ARRESTOR)) {
        perform_arrest(vict);
        forget(ch, vict);
        extract_char(ch);
      }
      else
        track_victim_check(ch, vict);
d848 4
@


1.73
log
@WAIT_STATE macro changed internally.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.72 2008/03/10 20:46:55 myc Exp myc $
d86 2
a87 2
            AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) ||
            AFF_FLAGGED(ch, AFF_MAJOR_PARA))
d102 1
a102 1
    if (AFF2_FLAGGED(ch, AFF2_ON_FIRE))
d114 1
a114 1
        REMOVE_BIT(MOB_FLAGS(ch), MOB_SPEC);
d122 1
a122 1
    if (MOB_FLAGGED(ch, MOB_SCAVENGER) && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d137 1
a137 1
    if (AFF2_FLAGGED(ch, AFF2_ON_FIRE) && number(0, 1)) {
d139 1
a139 1
      if (MOB2_FLAGGED(ch, MOB2_NO_CLASS_AI) ? TRUE :
d148 1
a148 1
    if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master &&
d155 1
a155 1
    if (!MOB2_FLAGGED(ch, MOB2_NO_CLASS_AI)) {
d249 1
a249 1
    if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) || AFF_FLAGGED(ch, AFF_MAJOR_PARA))
d274 7
a280 2
        MOB_FLAGGED(ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN) &&
        (!AFF_FLAGGED(ch, AFF_CHARM) || (ch->master &&
d315 1
a315 1
    if (!MOB2_FLAGGED(ch, MOB2_NO_CLASS_AI))
d381 2
a382 1
  if (ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH))
d387 1
a387 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && !MOB2_FLAGGED(ch, MOB2_ILLUSORY))
d410 1
a410 1
    if (!IS_NPC(vict) || MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM))
d412 1
a412 1
    if (IS_NPC(FIGHTING(vict)) && !MOB2_FLAGGED(FIGHTING(vict), MOB2_PLAYER_PHANTASM))
d455 1
a455 1
  if (!MOB2_FLAGGED(ch, MOB2_NO_CLASS_AI)) {
d593 1
a593 1
      if (allow_spells && !MOB2_FLAGGED(ch, MOB2_NO_CLASS_AI)) {
d650 1
a650 1
  if (AFF_FLAGGED(ch, AFF_SNEAK) || GET_HIDDENNESS(ch) > 0)
d657 1
a657 1
  if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
d690 1
a690 1
       MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM)))
d877 3
@


1.72
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.71 2008/03/10 18:01:17 myc Exp myc $
d254 1
a254 1
      WAIT_STATE(ch, MAX(GET_MOB_WAIT(ch) - PULSE_VIOLENCE, 0))
d355 1
a355 1
        WAIT_STATE(ch, MAX ((GET_MOB_WAIT(ch) - (PULSE_VIOLENCE / 2)), 0))
d871 3
@


1.71
log
@Bug: was setting POS1 to POS_STANDING.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.70 2008/03/09 18:10:32 jps Exp myc $
d350 1
a350 1
        GET_POS1(ch) = POS1_STANDING;
d359 1
a359 1
          GET_POS1(ch) = POS1_STANDING;
d871 3
@


1.70
log
@perform_move may be misdirected now.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.69 2008/03/09 06:38:37 jps Exp jps $
d359 1
a359 1
          GET_POS1(ch) = POS_STANDING;
d871 3
@


1.69
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.68 2008/03/08 23:54:54 jps Exp jps $
d390 1
a390 1
  perform_move(ch, door, 1);
d871 5
@


1.68
log
@Check whether a mob performs scripts when initiating specprocs.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.67 2008/02/11 21:04:01 myc Exp jps $
d602 1
a602 1
        do_DumbMobTrack(ch, d->character->player.name, 0, 0);
d871 3
@


1.67
log
@Mobs won't try to autocast summon if the target is too high level.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.66 2008/02/09 21:07:50 myc Exp myc $
d96 1
a96 1
            GET_DEFAULT_POS(ch) >= POS_STANDING)
d98 2
d103 1
a103 1
      if (GET_POS(ch) > POS_FIGHTING)
d105 2
d109 1
a109 1
    if (MOB_FLAGGED(ch, MOB_SPEC) && !no_specials) {
d871 3
@


1.66
log
@Casting macro now checks event flags instead of mob flags.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.65 2008/02/09 04:27:47 myc Exp myc $
d588 3
a590 2
          if (mob_cast(ch, d->character, NULL, SPELL_SUMMON))
            return TRUE;
d867 3
@


1.65
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.64 2008/02/01 17:55:09 myc Exp myc $
d32 1
d85 1
a85 2
    if (!IS_MOB(ch) ||
            MOB_FLAGGED(ch, MOB_CASTING) ||
d87 1
a87 2
            AFF_FLAGGED(ch, AFF_MAJOR_PARA) ||
            !AWAKE(ch))
d237 1
a237 1
    if (!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch) || MOB_FLAGGED(ch, MOB_CASTING))
d430 1
a430 1
  if (MOB_FLAGGED(ch, MOB_CASTING))
d680 1
a680 1
     if (!MOB_FLAGGED(ch, MOB_CASTING) && !FIGHTING(ch)) {
d866 3
@


1.64
log
@Fixed a crash bug where do_roar was being called with an invalid
cmd value.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.63 2008/01/29 21:02:31 myc Exp myc $
d31 1
d867 4
@


1.63
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.62 2008/01/28 00:14:32 jps Exp myc $
d851 8
a858 1
    do_roar(ch, "", 0, 0);
d866 4
@


1.62
log
@Fix rogue NPC attacking.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.61 2008/01/27 21:14:59 myc Exp jps $
a32 5
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct room_data *world;
extern struct str_app_type str_app[];
a34 1
extern struct char_data *mob_proto;
d859 3
@


1.61
log
@Replace hit() with attack().
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.60 2008/01/27 13:43:50 jps Exp myc $
d490 1
a490 1
        if (rogue_ai_action(ch, victim));
d865 3
@


1.60
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.59 2008/01/26 14:26:31 jps Exp jps $
d266 1
a266 1
          hit(ch, check_guard(ch, FIGHTING(vict), FALSE), TYPE_UNDEFINED);
d505 1
a505 1
    hit(ch, victim, TYPE_UNDEFINED);
d865 3
@


1.59
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.58 2008/01/22 14:59:23 jps Exp jps $
d495 3
a497 3
    switch (GET_SPECIES(ch)) {
      case SPECIES_DRAGON:
      case SPECIES_DEMON:
d543 1
a543 1
  if (GET_SPECIES(ch) == SPECIES_ANIMAL)
d656 1
a656 1
  else if (GET_SPECIES(ch) == SPECIES_ANIMAL) {
d865 3
@


1.58
log
@Fix chuckles-at-fight bug.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.57 2008/01/21 02:44:26 myc Exp jps $
d30 1
d865 3
@


1.57
log
@Make peaceful mobs not assist.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.56 2008/01/20 23:18:52 myc Exp myc $
d397 1
a397 1
  struct char_data *vict;
d409 2
a410 1
    if (GET_LEVEL(FIGHTING(vict)) <= 20)
d412 1
a412 1
    else {
d421 1
a421 1
      act("$n watches the battle in amusement.", FALSE, ch, 0, vict, TO_ROOM);
d423 1
a423 1
      act("$n chuckles as $e watches the fight.", FALSE, ch, 0, vict, TO_ROOM);
d425 2
a426 2
      act("$n takes note of your battle tactics.", FALSE, ch, 0, FIGHTING(vict), TO_CHAR);
      act("$n takes note of $N's battle tactics.", FALSE, ch, 0, FIGHTING(vict), TO_ROOM);
d864 3
@


1.56
log
@Fixed mob AI to only leave out class actions.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.55 2008/01/16 04:12:00 myc Exp myc $
d208 2
a209 1
    if (MOB_FLAGGED(ch, MOB_HELPER))
d863 3
@


1.55
log
@Moving pick_target from here to fight.c (renamed find_aggr_target).
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.54 2008/01/14 21:28:32 myc Exp myc $
d139 3
a141 1
      if (!mob_cast(ch, ch, NULL, SPELL_EXTINGUISH))
d156 1
a156 1
    if (!MOB2_FLAGGED(ch, MOB2_NOAI)) {
d218 1
a218 1
     * marked memory, has someone in its memory, and is not marked !AI.
d220 2
a221 4
    if (!MOB_FLAGGED(ch, MOB_SENTINEL) &&
            MOB_FLAGGED(ch, MOB_SLOW_TRACK) &&
            MOB_FLAGGED(ch, MOB_MEMORY) &&
            !MOB2_FLAGGED(ch, MOB2_NOAI))
a299 7
     * The remainder of the procedures here are considered "special" and 
     * will not be executed for mobs who are marked !AI.
     */
    if (MOB2_FLAGGED(ch, MOB2_NOAI))
      continue;

    /*
d310 7
a316 6
    if ((GET_CLASS(ch) == CLASS_CLERIC || GET_CLASS(ch) == CLASS_DRUID ||
        GET_CLASS(ch) == CLASS_PRIEST || GET_CLASS(ch) == CLASS_DIABOLIST ||
        GET_CLASS(ch) == CLASS_PALADIN || GET_CLASS(ch) == CLASS_RANGER) &&
        100 * GET_HIT(ch) / GET_MAX_HIT(ch) < 95)
      if (mob_heal_up(ch))
        continue;
a443 4
  /* Mob should not execute any special mobile AI procedures. */
  if (MOB2_FLAGGED(ch, MOB2_NOAI))
    return;

d447 44
a490 41
  /* Attempt special class actions first. */
  switch (GET_CLASS(ch)) {
    case CLASS_RANGER:
    case CLASS_PALADIN:
    case CLASS_ANTI_PALADIN:
      if (cleric_ai_action(ch, victim))
        return;
      /* Otherwise go on down to warrior ai action. */
    case CLASS_WARRIOR:
    case CLASS_MONK:
    case CLASS_MERCENARY:
    case CLASS_BERSERKER:
      if (warrior_ai_action(ch, victim))
        return;
      break;
    case CLASS_CLERIC:
    case CLASS_DRUID:
    case CLASS_DIABOLIST:
    case CLASS_PRIEST:
    case CLASS_SHAMAN:
      victim = weakest_attacker(ch, victim);
      if (cleric_ai_action(ch, victim))
        return;
      break;
    case CLASS_SORCERER:
    case CLASS_PYROMANCER:
    case CLASS_CRYOMANCER:
    case CLASS_NECROMANCER:
    case CLASS_CONJURER:
      victim = weakest_attacker(ch, victim);
      if (sorcerer_ai_action(ch, victim))
        return;
      break;
    case CLASS_ASSASSIN:
    case CLASS_THIEF:
    case CLASS_ROGUE:
    case CLASS_BARD:
      if (rogue_ai_action(ch, victim));
        return;
      break;
  }
d492 7
a498 6
  switch (GET_SPECIES(ch)) {
    case SPECIES_DRAGON:
    case SPECIES_DEMON:
      if (dragonlike_attack(ch))
        return;
      break;
d586 1
a586 1
      if (allow_spells) {
d862 3
@


1.54
log
@Moved is_aggr_to to fight.c.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.53 2008/01/14 20:38:42 myc Exp myc $
a808 70
int appraise_opponent(struct char_data *ch, struct char_data *victim) {
  int val;
  
  if (!IS_NPC(ch))
    return -1;
  
  val = GET_HIT (victim);
  
  if (IS_CLERIC(victim) || IS_MAGIC_USER(victim))
    val *= 2 / 3;
  else if (IS_WARRIOR(victim))
    val *= 2;
  if (!FIGHTING(victim))
    val /= (IS_THIEF(ch) ? 4 : 2);
  if ((AFF3_FLAGGED(victim, AFF3_AWARE)) && IS_THIEF(ch))
    val *= 1.5;
  if (GET_LEVEL(victim) < 60)
    val /= number(40 + GET_LEVEL(victim), 160 - GET_LEVEL(victim));
  return val;
}

#define MAX_TARGETS   20

struct char_data *pick_target (struct char_data *ch) {
  struct char_data *tch;
  int target_difficulties[MAX_TARGETS + 1];
  struct char_data *targets[MAX_TARGETS];
  int i = 0, j, k;
  
  if (!ch || ch->in_room == -1)
    return NULL;
  
  if (PLR_FLAGGED(ch, PLR_BOUND) || !AWAKE(ch) ||
      AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) ||
      AFF_FLAGGED(ch, AFF_MAJOR_PARA))
    return NULL;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (tch == ch)
      continue;
    if (!is_aggr_to(ch, tch))
      continue;
    if (i < MAX_TARGETS) {
      target_difficulties[i] = appraise_opponent(ch, tch);
      targets[i] = tch;
      i++;
    }
    else
      break;
  }
  
  if (i == 0)
    return NULL;

  if (!IS_NPC(ch) || MOB2_FLAGGED(ch, MOB2_PLAYER_PHANTASM))
    return targets[number(0, i - 1)];

  k = i;
  target_difficulties[k] = 1000000000; /* Arbitrarily large number */
  for (j = 0; j < i; j++)
    if (target_difficulties[j] < target_difficulties[k])
      k = j;

  /* No potential targets in the room. */
  if (k == i || k >= MAX_TARGETS)
    return NULL;

  return targets[k];
}

d868 3
@


1.53
log
@Fixed a crash bug (infinite recursion) in is_aggr_to.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.52 2008/01/13 23:06:04 myc Exp myc $
d59 1
a64 1
bool is_aggr_to (struct char_data *ch, struct char_data *target);
a77 2
/* mobile_spec_activity subfunctions */
bool mob_aggro(struct char_data *ch);
d274 11
a284 4
            MOB_FLAGGED(ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN) &&
            AFF_FLAGGED(ch, AFF_CHARM) && ch->master &&
              ch->master->in_room != ch->in_room)
      if (mob_aggro(ch))
d286 1
a535 37
 *
 *
 */
bool mob_aggro(struct char_data *ch) {
  struct char_data *vict;

  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
    if (ch == vict)
      continue;
    /* Skip most NPCs, but remain aggro to illusory players */
    if (IS_NPC(vict) && !MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM))
      continue;
    if (!CAN_SEE(ch, vict) | PRF_FLAGGED(vict, PRF_NOHASSLE))
      continue;
    if (MOB_FLAGGED(ch, MOB_WIMPY) && AWAKE(vict))
      continue;
    if (is_grouped(ch, vict))
      continue;

    /* Now if the mob is marked any kind of aggro that matches the 
       victim, attack! */
    if (MOB_FLAGGED(ch, MOB_AGGRESSIVE) ||
        (MOB_FLAGGED(ch, MOB_AGGR_GOOD_RACE) &&
          GET_RACE_ALIGN(vict) == RACE_ALIGN_GOOD) ||
        (MOB_FLAGGED(ch, MOB_AGGR_EVIL_RACE) && 
          GET_RACE_ALIGN(vict) == RACE_ALIGN_EVIL) ||
        (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(vict)) ||
        (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(vict)) ||
        (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(vict))) {
      mob_attack(ch, vict);
      return TRUE;
    }
  }
  return FALSE;
}

/*
a774 42
bool is_aggr_to (struct char_data *ch, struct char_data *target) {

  /* Common checks first */  
  if (!ch || !target || ch == target || !AWAKE(ch) || !CAN_SEE(ch, target))
    return FALSE;
  
  if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) || AFF_FLAGGED(ch, AFF_MAJOR_PARA))
    return FALSE;
  
  /* Pets now need a master to inhibit aggression */
  if (AFF_FLAGGED(ch, AFF_CHARM) || MOB_FLAGGED (ch, MOB_PET))
    return FALSE;
  
  /* now different checks for pcs/npcs */
  if (IS_NPC(ch)) {
    /* If target is in memory, then it acts as if it's aggro, even if it's not */
    if (MOB_FLAGGED(ch, MOB_MEMORY) && in_memory(ch, target))
      return TRUE;
    
    return FALSE;
  }
  else { /* PC */
    if (GET_WIMP_LEV(ch) >= GET_HIT(ch))	/* not agg and wimpy both */
      return FALSE;

    /* If not vicious, be merciful to sleeping/paralyzed mobs */
    if (!PRF_FLAGGED(ch, PRF_VICIOUS) && (!AWAKE(target) ||
        AFF2_FLAGGED(target, AFF2_MINOR_PARALYSIS) ||
        AFF_FLAGGED(target, AFF_MAJOR_PARA)))
      return FALSE;
    /* Um... can anyone say infinite recursion? */
    /*
    if (ch->player_specials->saved.aggressive != -1 &&
        ch->player_specials->saved.aggressive < GET_HIT(ch) &&
        is_aggr_to(target, ch))
      return TRUE;
     */
  }

  return FALSE;
}

d938 3
@


1.52
log
@Removed the NumAttackers function.  Changed mob_scavenge to use
appraise_item in ai_utils.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.51 2008/01/13 03:19:53 myc Exp myc $
d836 2
d842 1
d1011 4
@


1.51
log
@Made immortal mobs not use hide, steal, and animate dead.
Added a check_guard call.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.50 2008/01/12 23:13:20 myc Exp myc $
a54 1
int NumAttackers (struct char_data *ch);
d58 1
d507 1
a507 1
  int best_cost;
d514 1
a514 1
  best_cost = 0;
d517 1
a517 1
  /* Find the most expensive item in the room. */
d519 1
a519 1
    if (CAN_GET_OBJ(ch, obj) && GET_OBJ_COST(obj) > best_cost) {
d521 1
a521 1
      best_cost = GET_OBJ_COST(obj);
d525 2
a526 6
  if (best_obj != NULL) {
    obj_from_room(best_obj);
    obj_to_char(best_obj, ch);
    act("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM);
    get_check_money(ch, best_obj);
  }
d587 1
a587 2
        /* This should be improved to calculate an item's real value */
        if (GET_OBJ_COST(GET_EQ(ch, where)) >= GET_OBJ_COST(obj))
d595 1
a595 1
      /* Maybe handle other types of items here; eat food, I dunno */      
d1008 4
@


1.50
log
@Cleaned up mobact a bunch.  Subfunctionalized a bunch of actions, added a few,
and replaced try_cast with direct calls to mob_cast, which now supports
target objects.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.49 2008/01/12 19:12:05 myc Exp myc $
a158 6
       * Attempt to hide/sneak for those mobs who can do it.
       */
      if (GET_SKILL(ch, SKILL_HIDE) && GET_HIDDENNESS(ch) == 0)
        do_hide(ch, "", 0, 0);

      /*
d165 6
a170 4
      /* Attempt to steal something from a player in the room. */
      if (GET_SKILL(ch, SKILL_STEAL) && number(0, 101) < GET_SKILL(ch, SKILL_STEAL))
        if (mob_steal(ch))
          continue;
d172 16
a187 5
      /* Attempt to make a zombie! */
      if (GET_SKILL(ch, SPELL_ANIMATE_DEAD) && !ch->followers && 
          !MOB_FLAGGED(ch, MOB_ANIMATED)) {
        if (mob_animate(ch))
          continue;
d448 3
d1013 5
@


1.49
log
@Oops, accidentally erased some of the log entries.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.48 2008/01/12 19:08:14 myc Exp $
a46 1
ACMD(do_steal);
d56 1
a56 1
void mob_cast (struct char_data *ch, struct char_data *victim, int spellnum);
a63 1
bool class_operator (struct char_data *ch, struct char_data *victim);
a66 1
void mob_scavenge(struct char_data *ch);
d72 8
a79 2


d82 1
a82 2
  register struct char_data *ch, *next_ch, *vict;
  int door, go = FALSE, cmd;
d103 2
a104 4
            GET_DEFAULT_POS(ch) >= POS_STANDING) {
        cmd = find_command("stand");
        do_stand(ch, "", cmd, 0);
    }
d141 1
a141 1
      if (!try_cast(ch, ch, SPELL_EXTINGUISH))
d168 1
a168 1
      if(check_mob_status(ch))
d172 2
a173 13
      if (GET_MSKILL(ch, SKILL_STEAL) && number(0, 101) < GET_MSKILL(ch, SKILL_STEAL)) {
        /*
         * In an attempt to cut down on crime/clock cycles, only steal 
         * from the first character in the room, and only if it is a 
         * player.  Obviously this has drawbacks, but it can be changed
         * in the future if we want mob thieves to steal from everyone
         * in the room.
         */
        vict = world[ch->in_room].people;
        if (!IS_NPC(vict) && ch != vict && CAN_SEE(ch, vict) && GET_LEVEL(ch) + 5 > GET_LEVEL(vict)) {
          /* Right now we only support stealing coins. */
          sprintf(buf1, "%s %s", "coins", GET_NAME(vict));
          do_steal(ch, buf1, 0, 0);
a174 2
        }
      }
d176 2
a177 10
      /*
       * I've disabled this section (with the FALSE) because mob_cast 
       * doesn't support target objects @@#$%! and do_cast is not reliable
       * enough for this purpose.  Someone should rewrite the casting 
       * functions :P  do_cast and mob_cast should be combined into 
       * perform_cast, and do_cast should be a thin wrapper that merely 
       * finds spell targets.  Yes.
       */
      if (FALSE && GET_MSKILL(ch, SPELL_ANIMATE_DEAD) &&
          !ch->followers && 
d179 1
a179 22
        struct obj_data *obj;
        go = FALSE;
        for (obj = world[ch->in_room].contents; obj; obj = obj->next_content) {
          /*
           * There's no IS_NPC_CORPSE macro, and I don't want to check 
           * GET_OBJ_VAL twice in one expression, so I'm not using 
           * IS_CORPSE. _laoris_
           */
          if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER &&
              GET_OBJ_VAL(obj, 3) == CORPSE_NPC &&
              GET_OBJ_MOB_FROM(obj) != NOBODY &&
              GET_LEVEL(mob_proto + GET_OBJ_MOB_FROM(obj)) + 10 < GET_LEVEL(ch) &&
              !ROOM_FLAGGED(ch->in_room, ROOM_NOMAGIC) &&
              !AFF2_FLAGGED(ch, AFF2_SILENCE)) {

            /* This is where the call to perform_cast would go. */

            go = TRUE;
            break;            
          }
        }
        if (go)
d190 2
a191 25
    if (!MOB_FLAGGED(ch, MOB_SENTINEL) && GET_POS(ch) >= POS_STANDING) {
      go = TRUE;
      door = number(0, 18);
      if (door >= NUM_OF_DIRS || !CAN_GO(ch, door))
        go = FALSE;
      else if (ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH))
        go = FALSE;
      else if (MOB_FLAGGED(ch, MOB_STAY_ZONE) &&
              world[EXIT(ch, door)->to_room].zone != world[ch->in_room].zone)
        go = FALSE;
      else if (AFF_FLAGGED(ch, AFF_CHARM) && !MOB2_FLAGGED(ch, MOB2_ILLUSORY))
        go = FALSE;
      /* Don't wander off while someone is fighting you! */
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
        if (FIGHTING(vict) == ch) {
          go = FALSE;
          break;
        }

      /* If we made it through all the checks above, then move! */
      if (go)
        perform_move(ch, door, 1);
      /* But wait!  perform_move has the ability to kill, so if the mob
         didn't survive the move, go to the next mob. */
      if (ch == NULL || GET_POS(ch) == POS_DEAD)
a192 1
    }
d201 2
a202 32
    if (MOB_FLAGGED(ch, MOB_HELPER)) {
      go = TRUE;
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
         if (ch == vict || !FIGHTING(vict) || ch == FIGHTING(vict))
           continue;
         if (FIGHTING(vict)->in_room != ch->in_room)
           continue;
         if (!IS_NPC(vict) || MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM))
           continue;
         if (IS_NPC(FIGHTING(vict)) && !MOB2_FLAGGED(FIGHTING(vict), MOB2_PLAYER_PHANTASM))
           continue;
        if (GET_LEVEL(FIGHTING(vict)) <= 20) {
          act("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
          /* Try special attack first, otherwise just hit. */
          if (!class_operator(ch, FIGHTING(vict)))
            hit(ch, check_guard(ch, FIGHTING(vict), FALSE), TYPE_UNDEFINED);
          go = FALSE;
          break;
        }
        else {
          door = number(1, 10);
          if (door == 1)
            act("$n watches the battle in amusement.", FALSE, ch, 0, vict, TO_ROOM);
          else if (door == 2)
            act("$n chuckles as $e watches the fight.", FALSE, ch, 0, vict, TO_ROOM);
          else if (door == 3) {
            act("$n takes note of your battle tactics.", FALSE, ch, 0, FIGHTING(vict), TO_CHAR);
            act("$n takes note of $N's battle tactics.", FALSE, ch, 0, FIGHTING(vict), TO_ROOM);
          }
        }
      }
      if (!go)
a203 1
    }
d223 272
d524 37
a602 1
  int cmd;
d623 1
a623 1
          if (try_cast(ch, d->character, SPELL_SUMMON))
d626 1
a626 1
          if (try_cast(ch, d->character, SPELL_DIMENSION_DOOR))
d630 1
d632 1
a632 2
        cmd = find_command("DumbMobTrack");
        do_DumbMobTrack(ch, d->character->player.name, cmd, 0);
a707 11
void memory_attack(struct char_data *ch, struct char_data *vict)
{
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) return;
   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
      class_operator (ch, vict); /* hit with special type if got one */
      if (GET_POS(vict) == POS_DEAD) return;
      memory_attack_announce(ch, vict);
      hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
   }
}

d710 9
a718 7
   struct char_data *ivict;

   if (ch->in_room == vict->in_room)
      memory_attack(ch, vict);
   else if ((ivict = get_char_vis(ch, GET_NAME(vict))) &&
         MOB2_FLAGGED(ivict, MOB2_PLAYER_PHANTASM))
      memory_attack(ch, ivict);
d769 1
a769 1
void clearMemory (struct char_data *ch) {
a782 280
/*
 * mobile_spec_activity
 *
 * This handles special mobile activity, called every PULSE_VIOLENCE.
 */
void mobile_spec_activity (void) {
  register struct char_data *ch, *next_ch, *vict;
  int found = FALSE;
  
  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    /* Only for mobiles who aren't fighting, asleep, or casting */
    if (!IS_MOB(ch) || FIGHTING(ch) || !AWAKE(ch) || MOB_FLAGGED(ch, MOB_CASTING))
      continue;

    /* Skip mobiles with someone switched in. */
    if (ch->desc && ch->desc->original)
      continue;

    /* Skip mobiles who are paralyzed. */
    if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) || AFF_FLAGGED(ch, AFF_MAJOR_PARA))
      continue;

    /* If mob isn't fighting, just decrease wait state. */
    if (GET_MOB_WAIT (ch) > 0) {
      WAIT_STATE(ch, MAX(GET_MOB_WAIT(ch) - PULSE_VIOLENCE, 0))
      continue;
    }
    
    /* Pets, courtesy of Banyal */
    if (IS_NPC(ch) && MOB_FLAGGED(ch, MOB_PET)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
        if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict)) {
          act("&7$n assists $s master!&0", FALSE, ch, 0, vict, TO_ROOM);
          hit(ch, check_guard(ch, FIGHTING(vict), FALSE), TYPE_UNDEFINED);
          found = TRUE;
          break;
        }
      if (found)
        continue;
    }

    /* Aggressive Mobs */
    if (!ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL) &&
            MOB_FLAGGED(ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN) &&
            AFF_FLAGGED(ch, AFF_CHARM) && ch->master &&
              ch->master->in_room != ch->in_room) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room) {
        if (ch == vict)
          continue;
        /* Skip most NPCs, but remain aggro to illusory players */
        if (IS_NPC(vict) && !MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM))
          continue;
        if (!CAN_SEE(ch, vict) | PRF_FLAGGED(vict, PRF_NOHASSLE))
          continue;
        if (MOB_FLAGGED(ch, MOB_WIMPY) && AWAKE(vict))
          continue;
        if (is_grouped(ch, vict))
           continue;
        /* Now if the mob is marked any kind of aggro that matches the 
           victim, attack! */
        if (MOB_FLAGGED(ch, MOB_AGGRESSIVE) ||
                (MOB_FLAGGED(ch, MOB_AGGR_GOOD_RACE) &&
                  GET_RACE_ALIGN(vict) == RACE_ALIGN_GOOD) ||
                (MOB_FLAGGED(ch, MOB_AGGR_EVIL_RACE) && 
                  GET_RACE_ALIGN(vict) == RACE_ALIGN_EVIL) ||
                (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(vict)) ||
                (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(vict)) ||
                (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(vict))) {
          if (!class_operator(ch, vict))
            hit(ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
          found = TRUE;
          break;
        }
      }
      if (found)
        continue;
    }

    /*
     * Remnants of the justice system.
     *
     * If the mob is an arrestor, but has no one else on its memory list, 
     * then its purpose is finished.
     */
    if (MOB_FLAGGED(ch, MOB_ARRESTOR) && !MEMORY(ch)) {
      extract_char(ch);
      continue;
    }

    /*
     * The remainder of the procedures here are considered "special" and 
     * will not be executed for mobs who are marked !AI.
     */
    if (MOB2_FLAGGED(ch, MOB2_NOAI))
      continue;

    /*
     * Simple mob memory
     *
     * Checks room for memory targets but only if not wimpy.
     */
    if (MOB_FLAGGED(ch, MOB_MEMORY) && !(MOB_FLAGGED(ch, MOB_WIMPY) &&
            GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)))
      if (mob_memory_check(ch))
        continue;

    /* If cleric-type and hurt, then heal. */
    if ((GET_CLASS(ch) == MCLASS_CLERIC ||
            GET_CLASS(ch) == MCLASS_DRUID ||
            GET_CLASS(ch) == MCLASS_PRIEST ||
            GET_CLASS(ch) == MCLASS_DIABOLIST ||
            GET_CLASS(ch) == MCLASS_PALADIN ||
            GET_CLASS(ch) == MCLASS_RANGER) &&
            (100 * GET_HIT(ch) / GET_MAX_HIT(ch) < 95)) {
      if(mob_heal_up(ch))
        continue;
    }

    /*
     * Advanced mob memory
     *
     * Attempt to summon victim, dim door to victim, or just fast track.
     */
    if (GET_MSKILL(ch, SPELL_SUMMON) ||
            GET_MSKILL(ch, SPELL_DIMENSION_DOOR) ||
            MOB_FLAGGED(ch, MOB_FAST_TRACK))
      if (mob_memory_action(ch, TRUE))
        continue;
  }
}


/*
 * class_operator
 *
 * Attack using a special combat skill based on a mob's class.
 * Returns 1 if an action was taken or 0 otherwise.
 */
bool class_operator(struct char_data *ch, struct char_data *victim) {
  if (MOB_FLAGGED(ch, MOB_CASTING))
    /* Action wasn't really taken, but we don't want to 
     * trigger a hit in the caller. */
    return TRUE;

  /* If the mob is an arrestor, he's here to arrest, not kill. */
  if (MOB_FLAGGED(ch, MOB_ARRESTOR)) {
    perform_arrest(victim);
    forget(ch, victim);
    extract_char(ch);
    return TRUE;
  }

  /* Mob should not execute any special mobile AI procedures. */
  if (MOB2_FLAGGED(ch, MOB2_NOAI))
    return FALSE;

  switch (GET_CLASS (ch)) {
    case MCLASS_RANGER:
    case MCLASS_PALADIN:
    case MCLASS_ANTI_PALADIN:
      if (cleric_ai_action(ch, victim))
        return TRUE;
      /* Otherwise go on down to warrior ai action. */
    case MCLASS_WARRIOR:
    case MCLASS_MONK:
    case MCLASS_MERCENARY:
    case MCLASS_BERSERKER:
      return warrior_ai_action(ch, victim);
    case MCLASS_CLERIC:
    case MCLASS_DRUID:
    case MCLASS_DIABOLIST:
    case MCLASS_PRIEST:
    case MCLASS_SHAMAN:
      victim = weakest_attacker(ch, victim);
      return cleric_ai_action(ch, victim);
    case MCLASS_SORCERER:
    case MCLASS_PYROMANCER:
    case MCLASS_CRYOMANCER:
    case MCLASS_NECROMANCER:
    case MCLASS_CONJURER:
      victim = weakest_attacker(ch, victim);
      return sorcerer_ai_action(ch, victim);
    case MCLASS_ASSASSIN:
    case MCLASS_THIEF:
    case MCLASS_ROGUE:
    case MCLASS_BARD:
      return rogue_ai_action(ch, victim);
  }
  switch (GET_SPECIES(ch)) {
    case SPECIES_DRAGON:
    case SPECIES_DEMON:
      return dragonlike_attack(ch);
  }

  return FALSE;
}

/* Determine if all the conditions are met to cast a spell, then start casting. */
bool try_cast(struct char_data *ch, struct char_data *victim, int spellnum) {
  int spells_circle = SPELL_CIRCLE(spellnum);

  if (!GET_MSKILL(ch, spellnum))
    return FALSE;

  if (MOB_FLAGGED(ch, MOB_CASTING))
    return FALSE;

  if (GET_MOB_WAIT(ch) <= 0 && GET_POS(ch) < POS_FIGHTING)
    /* I don't think we actually need to send it a cmd value? */
    do_stand(ch, "", 0, 0);

  if (ROOM_FLAGGED(ch->in_room, ROOM_NOMAGIC))
    return FALSE;
  
  if (AFF2_FLAGGED(ch, AFF2_SILENCE))
    return FALSE;

  /* Most classes using clerical spells have alignment restrictions. */
  if ((GET_CLASS(ch) == CLASS_DIABOLIST && !IS_EVIL(ch)) ||
      (GET_CLASS(ch) == CLASS_PRIEST && !IS_GOOD(ch)) ||
      (GET_CLASS(ch) == CLASS_PALADIN && !IS_GOOD(ch)) ||
      (GET_CLASS(ch) == CLASS_RANGER && !IS_GOOD(ch)) ||
      (GET_CLASS(ch) == CLASS_ANTI_PALADIN && !IS_EVIL(ch)))
    return FALSE;

  /* I don't know what this MEM_STATE crap is, but I guess I'll leave it in. */
  if (GET_MEM_STATE(ch, spells_circle) == 0 && GET_MEM_MEMED(ch, spells_circle) == 0)
    SET_MEM_STATE(ch, spells_circle, 1);
  if (GET_MEM_STATE(ch, spells_circle) == 1 && GET_MEM_MEMED(ch, spells_circle) == spells_of_circle[(int) GET_LEVEL(ch)][spells_circle])
    SET_MEM_STATE(ch, spells_circle, 0);
  
  if (GET_MEM_MEMED(ch, spells_circle) > 0 && GET_MEM_STATE(ch, spells_circle) != 1) {
    /* Okay, cast the spell.  No need to check guard here.  It's done in mag_damage. */
    mob_cast(ch, victim, spellnum);
    return TRUE;
  }
  return FALSE;
}

/* This function is called each second to check if mob ready to do a special 
   attack PLEASE DO NOT CHANGE IT IT IS VERY VERY TOUCHY!!
   - if you wish to change mob activity change class_operator
   Proky
*/
void perform_mob_violence (void) {
  register struct char_data *ch;

  for (ch = combat_list; ch; ch = next_combat_list) {
    next_combat_list = ch->next_fighting;
    
    if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) {
      stop_fighting (ch);
      continue;
    }

    if (IS_NPC(ch) && !ch->desc) {
      if (GET_POS(ch) > POS_FIGHTING) {
        GET_POS(ch) = POS_FIGHTING;
        GET_POS1(ch) = POS1_STANDING;
      }

      /* Stand mob up if no pause */
      if (GET_MOB_WAIT(ch) > 0)
        WAIT_STATE(ch, MAX ((GET_MOB_WAIT(ch) - (PULSE_VIOLENCE / 2)), 0))
      else if (GET_MOB_WAIT(ch) <= 0) {
        if (GET_POS(ch) < POS_FIGHTING) {
          GET_POS(ch) = POS_FIGHTING;
          GET_POS1(ch) = POS_STANDING;
          act("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
          continue;
        }
        class_operator(ch, FIGHTING(ch));
      }
    }
  }
}
a799 20
/* Track aggro check Banyal */
bool is_aggr_to_trackee (struct char_data *ch, struct char_data *target) {     
  /* common checks first */
  if (!ch || !target || ch == target ||!AWAKE(ch) || !CAN_SEE(ch, target))
    return FALSE;
  
  if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) || AFF_FLAGGED(ch, AFF_MAJOR_PARA))
    return FALSE;
  
  /* Pets now need a master to inhibit aggression */
  if (AFF_FLAGGED(ch, AFF_CHARM) || MOB_FLAGGED (ch, MOB_PET))
    return FALSE;
  
  if (MOB_FLAGGED(ch, MOB_MEMORY) && MEMORY(ch) != NULL && 
      in_memory(ch, target))
    return TRUE;
  
  /* Not trigger, so it's not aggr */
  return FALSE;
}
d802 3
a804 2
  /* common checks first */  
  if (!ch || !target || ch == target ||!AWAKE(ch) || !CAN_SEE(ch, target))
d815 1
a815 1
  if (IS_NPC(ch)) { /* NPC */
a822 3
    if (!IS_NPC(ch))
      return FALSE;

d827 1
a827 1
    if (!PRF_FLAGGED (ch, PRF_VICIOUS) && (!AWAKE(target) ||
d855 4
a858 4
    case MCLASS_SORCERER:
    case MCLASS_PYROMANCER:
    case MCLASS_CRYOMANCER:
    case MCLASS_NECROMANCER:
d862 4
a865 4
    case MCLASS_CLERIC:
    case MCLASS_DRUID:
    case MCLASS_PRIEST:
    case MCLASS_DIABOLIST:
a873 61
/* Check an object in inventory to see if the mob can make use of it.
 * Returns true if the object is removed from inventory, false otherwise. */
bool proccess_object(struct char_data *ch, struct obj_data *obj) {
/*  struct object_data *worn_obj;*/
  int wear = find_eq_pos(ch, obj, FALSE);

  if (!obj)
    return FALSE;

/*
  if (GET_SPECIES(ch) != SPECIES_ANIMAL) {
    if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
    if (compare_weapons(obj, GET_EQ(ch, ITEM_WEAR_WIELD)) > 0)
      wear =
    if (CAN_WEAR(obj, ITEM_WEAR_WIELD) && !CAN_WEAR(obj, ITEM_WEARGET_EQ(ch, WEAR_2HWIELD))
*/
  /* Attempt to dual wield */
  if (wear == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD) && GET_MSKILL(ch, SKILL_DUAL_WIELD))
    wear = WEAR_WIELD2;
/*

    if (!CAN_WEAR (obj, ITEM_WEAR_WIELD) && !CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
      return TRUE;
    if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
      return FALSE;
    else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
      return TRUE;
    else if ( ((!wielding) && (!hwielding)) && (GET_SPECIES(ch) != SPECIES_ANIMAL)) {
      if (CAN_WEAR (obj, ITEM_WEAR_WIELD)) {
	perform_wear (ch, obj, WEAR_WIELD);
	return TRUE;
      } else if (CAN_WEAR (obj, ITEM_WEAR_2HWIELD) && (GET_SPECIES(ch) != SPECIES_ANIMAL)    ) {
	perform_wear (ch, obj, WEAR_2HWIELD);
	return FALSE;
      }
    } else {
      if (GET_MSKILL (ch, SKILL_DUAL_WIELD)) {
	struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
	struct obj_data *wielding2 = GET_EQ (ch, WEAR_WIELD2);
	struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);
	
	if (wielding) {
	  if (!CAN_WEAR (obj, ITEM_WEAR_WIELD))
	    return FALSE;
	  if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
	    return FALSE;
	  else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
	    return FALSE;
	  else if (!wielding2) {
	    perform_wear (ch, obj, WEAR_WIELD2);
	    return TRUE;
	  }
	}
      }
    }
  }
*/
  return FALSE;
}


d950 1
a950 1
    if(!MOB_FLAGGED(tch, MOB_MEMORY) || !MEMORY(tch))
d952 1
a952 1
    if(tch == ch)
d954 1
a954 1
    if(tch->desc && tch->desc->original)
d963 3
a965 2
  /* at level 100, 10% chance to breath, 2% chance for each different type */
  if (roll < 5 && GET_MSKILL(ch, SKILL_BREATHE)) {
d986 3
a988 2
  /* at level 100, 10% chance to sweep */
  else if (roll < 10 && GET_MSKILL(ch, SKILL_SWEEP)) {
d992 3
a994 2
  /* at level 100, 10% chance to roar */
  else if (roll < 15 && GET_MSKILL(ch, SKILL_ROAR)) {
d1003 3
@


1.48
log
@Rerowte a lot of mob AI functionality.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.47 2008/01/07 11:57:57 jps Exp myc $
d1161 57
@


1.47
log
@Allow illusory mobs to wander.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.46 2008/01/07 10:34:53 jps Exp jps $
d6 2
a7 2
 *  Usage: Functions for generating intelligent behavior in mobiles        *
 *  This file is no more than a conductor to the other mob AI files        *
d10 1
d39 1
d41 11
a51 9
ACMD (do_get);
ACMD (do_flee);
ACMD (do_bash);
ACMD (do_kick);
ACMD (do_cast);
ACMD (do_stand);
ACMD (do_circle);
ACMD (do_backstab);
bool update_inv (struct char_data *ch, struct obj_data *obj, int where);
d53 3
a55 4

void perform_wear (struct char_data *ch, struct obj_data *obj, int where);
int find_eq_pos (struct char_data *ch, struct obj_data *obj, char *arg);
int CountToughness (struct char_data *ch, struct char_data *victim);
a56 2
void check_mob_status (struct char_data *ch);
bool is_grouped (struct char_data *ch, struct char_data *tch);
a57 8
void class_operator (struct char_data *ch, struct char_data *victim);
bool is_aggr_to (struct char_data *ch, struct char_data *target);
int mem_inMemory (struct char_data *ch, struct char_data *vict);
void remember (struct char_data *ch, struct char_data *victim);
void get_check_money(struct char_data * ch, struct obj_data * obj);

extern struct char_data *mob_proto;
extern int is_empty (int zone_nr);
d61 14
a74 2
ACMD (do_track);
ACMD (do_DumbMobTrack);
a75 10
void memory_attack_announce(struct char_data *ch, struct char_data *vict) {
   if (AFF2_FLAGGED(ch, AFF2_SILENCE)) {
      act("$n silently moves in for the attack.", FALSE, ch, 0, vict, TO_ROOM);
   } else if (GET_SPECIES(ch) == SPECIES_ANIMAL) {
      act("$n growls angrily at $N, and attacks!", FALSE, ch, 0, vict, TO_NOTVICT);
      act("$n growls angrily at you, and attacks!", FALSE, ch, 0, vict, TO_VICT);
   } else {
      act("$n growls, 'Thought you could walk away from a fight, eh?'", FALSE, ch, 0, vict, TO_ROOM);
   }
}
a76 14
void memory_attack(struct char_data *ch, struct char_data *vict)
{
   if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) return;
   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
      class_operator (ch, vict); /* hit with special type if got one */
      if (GET_POS(vict) == POS_DEAD) return;
      memory_attack_announce(ch, vict);
      hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
   }
}

void track_victim_check(struct char_data *ch, struct char_data *vict)
{
   struct char_data *ivict;
d78 1
a78 8
   if (ch->in_room == vict->in_room)
      memory_attack(ch, vict);
   else if ((ivict = get_char_vis(ch, GET_NAME(vict))) &&
         MOB2_FLAGGED(ivict, MOB2_PLAYER_PHANTASM))
      memory_attack(ch, ivict);
}

void mobile_activity (void) {
d80 1
a80 6
   /*    struct char_data *i; */
  struct obj_data *obj, *best_obj, *x;
  int door, found = FALSE, max, hurm;
  int cmd_track, where;
  struct descriptor_data *d, *next_d;
  memory_rec *names;
d82 1
a82 3
  ACMD (do_get);
  ACMD(do_douse);
  
d85 8
a92 2
    
    if (!IS_MOB (ch) || !AWAKE (ch))
d94 2
a95 4
    
    if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
      continue;
    
d98 8
a105 15
    check_mob_status (ch);	/*checks spell ups etc */
    
    /* Examine call for special procedure */
    if (MOB_FLAGGED (ch, MOB_CASTING))
      continue;
    
    /*if sitting and not ment to be better stand */
    if (GET_POS (ch) < POS_FIGHTING)
      if (GET_DEFAULT_POS (ch) == POS_STANDING)
	if (GET_MOB_WAIT (ch) <= 0) {
	  max = find_command ("stand");
	  do_stand (ch, "", max, 0);
	  max = 0;
	}
    
d111 7
a117 10
      if (MOB_FLAGGED (ch, MOB_SPEC) && !no_specials) {
	if (mob_index[GET_MOB_RNUM (ch)].func == NULL) {
	  sprintf (buf, "%s (#%d): Attempting to call non-existing mob func",
		   GET_NAME (ch), GET_MOB_VNUM (ch));
	  log (buf);
	  REMOVE_BIT (MOB_FLAGS (ch), MOB_SPEC);
	} else {
	  if ((mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, ""))
	    continue;	/* go to next char */
	}
d119 33
a151 18
      
      /* Scavenger (picking up objects) */
      if (MOB_FLAGGED (ch, MOB_SCAVENGER) && AWAKE (ch) && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
	if (world[ch->in_room].contents && !number (0, 1)) {
	  max = 0;
	  best_obj = NULL;
	  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
	    if (CAN_GET_OBJ (ch, obj) && GET_OBJ_COST (obj) > max) {
	      best_obj = obj;
	      max = GET_OBJ_COST (obj);
	    }
	  if (best_obj != NULL) {
	    obj_from_room (best_obj);
	    obj_to_char (best_obj, ch);
	    act ("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM);
       get_check_money(ch, best_obj);
	  }
	}
d153 34
a186 35
	/*if stuff in inventry check to use it */
	/* re-ordered by Gurlaek 8/29/1999 due to insure errors */
	/* No animals wearing eq! */
	if (GET_SPECIES(ch) != SPECIES_ANIMAL) {
	  for (obj = ch->carrying; obj; obj = obj->next_content) {
	    if (CAN_SEE_OBJ (ch, obj)) {
	      where = find_eq_pos (ch, obj, 0);
	      if (where >= 0) {
		if (GET_EQ (ch, where)) {
		  x = GET_EQ (ch, where);
		  if (GET_OBJ_COST (x) >= GET_OBJ_COST (obj))
		    continue;
		  else {
		    perform_remove (ch, where);
		    perform_wear (ch, obj, where);
		    continue;
		  }
		} else {
		  perform_wear (ch, obj, where);
		  continue;
		}
	      } else { /* where = -1, bag or weopon or type */
		if (!(update_inv (ch, obj, where)))  {	/*try it */
		  if (check_weopeon_value (ch, obj)) {
		    mob_remove_weopon (ch, obj, where);
		    if (!(update_inv (ch, obj, where))) {
		      sprintf(buf, "%s couldn't update with weopeon() exchange.", GET_NAME(ch));
		      mudlog (buf, NRM, LVL_GOD, FALSE);
		    }
		  }
		}
	      } /* (where >= 0) */
	    }
	  }
	}
d188 35
a222 20
      /* Mob Movement */
      /* this needs to be fixed for IN_FLIGHT rooms and gravity as well as RIDING */
      /* added charm clause to keep charmed mobs from wandering. perform_move
       * used to check this, but there are circumstances when a charmed
       * mob can move (eg via order) but we don't want him to wander */
      if ((!MOB_FLAGGED(ch, MOB_SENTINEL) && (GET_POS(ch) == POS_STANDING ||
					      (GET_POS(ch) == POS_FLYING)) &&
	  ((door = number (0, 18)) < NUM_OF_DIRS) && CAN_GO (ch, door) &&
	  !ROOM_FLAGGED (EXIT (ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH) &&
	  (!MOB_FLAGGED (ch, MOB_STAY_ZONE) ||
	   (world[EXIT(ch, door)->to_room].zone == world[ch->in_room].zone)))
	  && (!IS_AFFECTED(ch, AFF_CHARM) || MOB2_FLAGGED(ch, MOB2_ILLUSORY))) {
         /* Don't wander off while someone is fighting you! */
	      for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
            if (vict->char_specials.fighting == ch)
                  return;
         perform_move (ch, door, 1);
         /* if the mob didn't survive the move, next mob -myc 28 Jan 2007 */
         if (ch == NULL || GET_POS(ch) == POS_DEAD)
            continue;
d224 73
a296 32
      
      /* Helper Mobs */
      if (MOB_FLAGGED (ch, MOB_HELPER) && !FIGHTING(ch)) {
	found = FALSE;
	for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	  if (ch != vict && (IS_NPC (vict) && !MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM)) &&
           FIGHTING (vict) &&
	      (!IS_NPC(FIGHTING (vict)) || MOB2_FLAGGED(FIGHTING(vict), MOB2_PLAYER_PHANTASM)) &&
         ch != FIGHTING (vict) &&
         FIGHTING(vict)->in_room == ch->in_room) {
	    if (GET_LEVEL (FIGHTING (vict)) > 20) {
		
	      act ("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);


	      class_operator (ch, 
			      check_guard(ch,FIGHTING (vict),TRUE)) ;  /* hit with special type if got one */

	      if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)) && FIGHTING(vict))
		hit (ch, check_guard(ch,FIGHTING(vict), FALSE), TYPE_UNDEFINED);

	      found = TRUE;
	    } else {
	      hurm = number (1, 10);
	      if (hurm == 1)
		act ("$n watches the battle in amusement.", FALSE, ch, 0, vict, TO_ROOM);
	      if (hurm == 2)
		act ("$n chuckles at you as $e watches the fight", FALSE, ch, 0, vict, TO_ROOM);
	      if (hurm == 3)
		act ("$n takes note of your battle tactics.", FALSE, ch, 0, vict, TO_ROOM);
	    }
	  }
d298 3
d302 71
a372 23
      if (!MOB_FLAGGED (ch, MOB_SENTINEL) && !FIGHTING(ch)) { 
         /* slow_track here because this function is called only every PULSE_MOBILE */
	if (MOB_FLAGGED (ch, MOB_SLOW_TRACK)) {
	  if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) {
	    for (d = descriptor_list; d; d = next_d) {
	      if (STATE (d) != CON_PLAYING) {
		next_d = d->next;
		continue;
	      }
	      next_d = d->next;
	      
	      for (names = MEMORY (ch); names && !found; names = names->next) {
		if (names->id == GET_IDNUM (d->character)) {
		  cmd_track = find_command ("DumbMobTrack");
		  do_DumbMobTrack (ch, d->character->player.name, cmd_track, 0);
      track_victim_check(ch, d->character);
		  return;
		}
	      }
	    }
	  }
	}
	/* Add new mobile actions here */
d374 7
a380 1
  } /* end for() */
d383 9
d393 2
a394 1
#ifdef PROKYMOBMEMORY
d396 5
a400 1
/* Mob Memory Routines */
d402 24
a425 22
/* make ch remember victim */
void remember (struct char_data *ch, struct char_data *victim) {
  memory_rec *tmp;
  bool present = FALSE;
  
  if (!IS_NPC (ch) || IS_NPC (victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
    return;
  if (victim->desc && victim->desc->original)
    remember(ch, victim->desc->original);
  
  for (tmp = MEMORY (ch); tmp && !present; tmp = tmp->next)
    if (tmp->id == GET_IDNUM (victim))
      present = TRUE;
  
  if (!present) {
    CREATE (tmp, memory_rec, 1);
      
    if (!(MEMORY (ch)))
      tmp->next = NULL;
    tmp->next = MEMORY (ch);
    tmp->id = GET_IDNUM (victim);
    MEMORY (ch) = tmp;
d427 1
d430 10
d441 23
a463 5
/* make ch forget victim */
void forget (struct char_data *ch, struct char_data *victim) {
  memory_rec *curr, *tmp = NULL;
  
  if (!(curr = MEMORY (ch)))
d465 3
a467 10
  
  /*function re-done by Proky */
  curr = MEMORY (ch);
  /*check for top of list */
  if (curr->id == GET_IDNUM (victim)) {
    if (curr->next)
      MEMORY (ch) = curr->next;
    else
      MEMORY (ch) = NULL;
    free (curr);
d469 4
d474 5
a478 6
  /*middle of list or end */
  for (curr = MEMORY (ch); curr->next->id != GET_IDNUM (victim); curr = curr->next);
  tmp = curr->next;
  if (tmp) {
    curr->next = tmp->next;
    free (tmp);
d480 26
d508 10
a517 1
#endif  /* PROKYMOBMEMORY */
d519 4
a522 1
void remember(struct char_data * ch, struct char_data * victim) {
d542 2
a543 2
/* make ch forget victim */
void forget(struct char_data * ch, struct char_data * victim)
d570 1
a570 1
  curr = MEMORY (ch);
d578 1
a578 1
  MEMORY (ch) = NULL;
d581 5
d587 23
a609 26
   register struct char_data *ch, *next_ch, *vict;
   /*    struct char_data *i; */
   struct descriptor_data *d, *next_d;
   int found = FALSE, a;
   bool hascast = FALSE;
   memory_rec *names, *namestmp;
   int cmd_track;
   bool WHYTRACK = FALSE;
  
   for (ch = character_list; ch; ch = next_ch) {
      next_ch = ch->next;
      if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
         continue;
      if (ch->desc && ch->desc->original)
         continue;
      if (MOB_FLAGGED (ch, MOB_CASTING))
         continue;
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
         continue;
      if (IS_FIGHTING (ch))
         continue;
      /*if mob not fighting still decrease wait state */
      if ((GET_MOB_WAIT (ch) > 0)) {
         WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE)), 0))
         continue;
      }
d611 13
a623 1
      /*pets banyal */
d625 33
a657 63
      if (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)) {
         found = FALSE;
         for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
            if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict)) {
               act ("&7$n assist $s master!!&0", FALSE, ch, 0, vict, TO_ROOM);
               hit (ch, check_guard(ch,FIGHTING (vict),FALSE), TYPE_UNDEFINED);
               found = TRUE;
            }
      }
    
    
      /* Aggressive Mobs */
    
      if (!ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL) &&
            MOB_FLAGGED (ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN)) {
         found = FALSE;
         for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
            if (ch == vict)
               continue;
            /* Skip most NPCs, but remain aggro to illusory players */
            if (IS_NPC(vict) && !MOB2_FLAGGED(vict, MOB2_PLAYER_PHANTASM))
               continue;
            if (!CAN_SEE(ch, vict) || PRF_FLAGGED(vict, PRF_NOHASSLE))
               continue;
            if (MOB_FLAGGED (ch, MOB_WIMPY) && AWAKE (vict))
               continue;
            if ((IS_AFFECTED (ch, AFF_CHARM)))
               if (ch->master) {
                  if (ch->master == vict)
                     continue;
                  if ((ch->in_room) == (ch->master->in_room)) {
                     continue;
                  }
                  if (is_grouped (ch, vict)) {
                     continue;
                  }
               }


            if (((MOB_FLAGGED (ch, MOB_AGGR_EVIL_RACE) &&
                  GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL) ||
                  (MOB_FLAGGED (ch, MOB_AGGR_GOOD_RACE) &&
                  GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD))) {
               class_operator (ch, vict);	/*hit with special type if got one */
               if (GET_POS(vict) == POS_DEAD) return;
               if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
                  hit (ch, check_guard(ch,vict,FALSE), TYPE_UNDEFINED);
               found = TRUE;
               WHYTRACK = TRUE;
            }

            if (((MOB_FLAGGED (ch, MOB_AGGRESSIVE)) ||
                  (MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
                  (MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
                  (MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict)))) {
               class_operator (ch, vict);	/*hit with special type if got one */
               if (GET_POS(vict) == POS_DEAD) return;
               if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
                  hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
               found = TRUE;
               WHYTRACK = TRUE;
            }
         }
d659 3
d663 10
a672 2
      if (MOB_FLAGGED (ch, MOB_ARRESTOR) && (!MEMORY (ch)))
         extract_char (ch);
d674 6
a679 63
      /* Mob Memory */
      if ((MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) &&
            !(MOB_FLAGGED (ch, MOB_WIMPY) &&
            (GET_HIT (ch) < (GET_MAX_HIT (ch) >> 2)))) {
         found = FALSE;
         for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
            if (IS_NPC (vict) || !CAN_SEE (ch, vict) || PRF_FLAGGED (vict, PRF_NOHASSLE))
               continue;
            for (names = MEMORY (ch); names && !found; names = namestmp) {
               namestmp = names->next;
               if (names && names->id == GET_IDNUM (vict)) {
                  found = TRUE;
                  WHYTRACK = TRUE;
                  if (!MOB_FLAGGED (ch, MOB_ARRESTOR)) { /*is he here to kill or arrest */ 
                     track_victim_check(ch, vict);
                  } else {
                     perform_arrest (vict);
                     forget (ch, vict);
                     extract_char (ch);
                  }
                  continue;
               }
            }
         }
      }
    
      if (GET_CLASS (ch) == MCLASS_CLERIC)
         /* heal if less than 95% hp */
         if (((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) < 95) {
            mob_heal_up (ch);
            continue;
         }
      
      /*remove anyone without memory or not flagged memory */
      if ((!MOB_FLAGGED (ch, MOB_MEMORY)) || (!MEMORY (ch)))
         continue;

      /*Check maybe he wants to summon target */
      if (GET_MSKILL (ch, SPELL_SUMMON)) {
         if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30)) /* if greater than 30%hp */
            for (d = descriptor_list; d; d = next_d) {
               if (STATE (d) != CON_PLAYING) {
                  next_d = d->next;
                  continue;
               }
               next_d = d->next;
               if (GET_LEVEL (d->character) > LVL_IMMORT)
                  continue;
               for (names = MEMORY (ch); names && !found; names = names->next)
                  if (names->id == GET_IDNUM (d->character)) {
                     if ((GET_MSKILL (ch, SPELL_SUMMON))) {
                        a = 0;
                        a = SPELL_CIRCLE (SPELL_SUMMON);
                        if (can_summon (ch, d->character)) {
                           hascast = TRUE;
                           break;
                        }
                     }
                  }
               if (hascast)
                  break;
	         }
      }
d681 21
a701 38
      if (hascast)
         continue;
    
      /*try to dim to him or relocate */
      if (((GET_MSKILL (ch, SPELL_DIMENSION_DOOR))) || ((GET_MSKILL (ch, SPELL_RELOCATE)))) {
         if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
            for (d = descriptor_list; d; d = next_d) {
               if (STATE (d) != CON_PLAYING) {
                  next_d = d->next;
                  continue;
               }

               next_d = d->next;
               if (d->character && GET_LEVEL (d->character) > LVL_IMMORT)
                  continue;
               for (names = MEMORY (ch); names && !found; names = names->next)
                  if (names->id == GET_IDNUM (d->character)) {
                     if ((GET_MSKILL (ch, SPELL_DIMENSION_DOOR)))
                        if (can_dim (ch, d->character)) {
                           hascast = TRUE;
                           break;
                        }
                     /*if real high try relocate */
                     a = 0;
                     a = SPELL_CIRCLE (SPELL_RELOCATE);
                     if ((GET_MSKILL (ch, SPELL_RELOCATE)))
                        if (GET_LEVEL (ch) > 60)
                           if (try_cast (ch, d->character, a, SPELL_RELOCATE)) {
                              hascast = TRUE;
                              break;
                           }
                  }
               if (hascast)
                  break;
            }
      }
      if (hascast)
         continue;
d703 11
a713 25
      if (WHYTRACK == FALSE) {
         /* fast track here because this is called every PULSE_VIOLENCE */
         if (MOB_FLAGGED (ch, MOB_FAST_TRACK)) {
            if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) {

               for (d = descriptor_list; d; d = next_d) {
                  if (STATE (d) != CON_PLAYING) {
                     next_d = d->next;
                     continue;
                  }

                  next_d = d->next;
                  for (names = MEMORY (ch); names && !found; names = names->next) {
                     if (d->character && names->id == GET_IDNUM (d->character)) {
                        cmd_track = find_command ("DumbMobTrack");
                        do_DumbMobTrack(ch, d->character->player.name, cmd_track,0);
                        track_victim_check(ch, d->character);
                        return;
                     }
                  }
               }
            }
         }
      }
   }
d717 11
a727 3
/* attack using special combat skills for a mobile's class */
/* integrated case statements --gurlaek 7/11/1999          */
void class_operator (struct char_data *ch, struct char_data *victim) {
d729 6
a734 7
  if (MOB_FLAGGED (ch, MOB_CASTING))
    return;
  if (MOB_FLAGGED (ch, MOB_ARRESTOR)) {
    perform_arrest (victim);
    forget (ch, victim);
    extract_char (ch);
    return;
d736 5
d742 32
a773 6
  case MCLASS_WARRIOR:
  case MCLASS_MERCENARY:
    switch(GET_RACE(ch)) {
    case SPECIES_DEMON:
      demon_sel_warrior_mob_spells (ch, victim);
      break;
a774 13
      dragon_sel_warrior_mob_spells (ch, victim);
      break;
    default:
      sel_warrior_mob_spells (ch, victim);
      break;
    }
    break;
  case MCLASS_CLERIC:
    sel_cleric_mob_spells (ch, victim);
    break;
  case MCLASS_SORCERER:
    victim = lowest_hp_in_group (ch, victim);
    switch(GET_RACE(ch)) {
d776 1
a776 16
      demon_sel_mage_mob_spells (ch, victim);
      break;
    case SPECIES_DRAGON:
      dragon_sel_mage_mob_spells (ch, victim);
      break;
    default:
      sel_mage_mob_spells (ch, victim);
      break;
    }
    break;
  case MCLASS_ASSASSIN:
  case MCLASS_THIEF:
    sel_thief_mob_spells (ch, victim);
    break;
  default:
    break;
d778 2
d782 13
a794 3
/* determine if all the conditions are met to cast a spell, then start casting */
int try_cast (struct char_data *ch, struct char_data *victim, int spells_circle, int spellnum) {
  int cmd_stand;
d797 1
a797 1
    return 0;
d799 21
a819 20
  if (GET_MOB_WAIT (ch) <= 0)
    if (GET_POS (ch) < POS_FIGHTING) {
      cmd_stand = find_command ("stand");
      do_stand (ch, "",	cmd_stand, 0);
    }
  if (AFF2_FLAGGED (ch, AFF2_SILENCE)) {
    return 0;
  }
  if (MOB_FLAGGED (ch, MOB_CASTING))
    return 0;
  if ((GET_MEM_STATE (ch, spells_circle) == 0) && (GET_MEM_MEMED (ch, spells_circle) == 0))
    SET_MEM_STATE (ch, spells_circle, 1);
  if ((GET_MEM_STATE (ch, spells_circle) == 1) 
      && (GET_MEM_MEMED (ch, spells_circle) == spells_of_circle[(int) GET_LEVEL (ch)][(int) spells_circle]))
    SET_MEM_STATE (ch, spells_circle, 0);
  
  if ((GET_MEM_MEMED (ch, spells_circle) > 0) && (GET_MEM_STATE (ch, spells_circle) != 1)) {
    /* ok cast the spell */
    mob_cast (ch, check_guard(ch,victim,FALSE), spellnum);
    return 1;
d821 1
a821 1
  return 0;
d826 1
a826 1
   - if you wish to change mob activity change class_opperator
d830 2
a831 3
  struct char_data *ch;
  struct char_data *victim;
  
d835 1
a835 1
    if (FIGHTING (ch) == NULL || ch->in_room != FIGHTING (ch)->in_room) {
d839 5
a843 4
    if (IS_NPC (ch) && !(ch->desc && ch->desc->original)) {
      if ((FIGHTING (ch)) && (GET_POS (ch) > POS_FIGHTING)) {
	GET_POS (ch) = POS_FIGHTING;
        GET_POS1(ch) = POS_STANDING;
d845 12
a856 14
      /*Stand mob up if no pause */
      if (GET_MOB_WAIT (ch) > 0) {
	WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE / 2)), 0))
      } else {
	if (!(GET_MOB_WAIT (ch) > 0)) {
	  if (GET_POS (ch) < POS_FIGHTING) {
	    GET_POS (ch) = POS_FIGHTING;
            GET_POS1(ch) = POS_STANDING;
	    act ("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
	    return;
	  }
	  victim = FIGHTING (ch);
	  class_operator (ch, victim);
	}
d862 2
a863 3
void casting_gain (void) {
  struct char_data *i, *next_char;
  int var;
d866 8
a873 26
  /* characters */
  for (i = character_list; i; i = next_char) {
    next_char = i->next;
    /*npc only */
    if (IS_NPC (i)) {
      var = 0;
      circle = 0;
	  while (var < GET_LEVEL (i)) {
	    circle++;
	    var = circle * 5 + 1;
	  }
	  var = 0;
	  
	  if (circle > 12)
	    circle = 12;
	  if (circle <= 0)
	    circle = 1;
	  circle--;
	  for (; circle >= 0; circle--) {
	      
	    if ((i)->mob_specials.mem_memed[circle] < spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)]) {
	      (i)->mob_specials.mem_memed[circle] = 
		MIN (((i)->mob_specials.mem_memed[circle] + 3)
		     ,(spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)]));
	    }
	  }
d878 1
a878 2
/*Track aggro check Banyal*/

d881 1
a881 3
  
  if ((!ch) || (!target) || (ch == target) ||
      (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
d884 1
a884 1
  if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
d887 2
a888 2
  /*pets now needs a master to inhibit aggression */
  if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
d891 2
a892 2
  if (MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
      (mem_inMemory (ch, target)))
d894 2
a895 2

  /* not trigger, so it's not aggr */
d900 2
a901 4
  /* common checks first */
  
  if ((!ch) || (!target) || (ch == target) || (ch->in_room != target->in_room)
      || (FIGHTING (target) != ch) || (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
d904 1
a904 1
  if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
d907 2
a908 2
  /* now needs a master to inhibit aggression */
  if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
d912 4
a915 3
  
  if (IS_NPC (ch)) { /* NPC */
    /* after the above check, we are dealing with a pet or a PC */
d917 5
a921 4
    /* if target in memory, then it acts as if it's agg, even if it's not */
    if (MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
	mem_inMemory (ch, target))
      return TRUE;
d923 2
a924 2
    /* not trigger, so it's not aggr */
    return FALSE;
d926 9
a934 16
  } else { /* PC */
    if (!IS_NPC (target)) /* PC can't be agg to other PC's */
	return FALSE;
      
      if (GET_WIMP_LEV (ch) > GET_HIT (ch))	/* not agg and wimpy both */
	return FALSE;
      
      if (!PRF_FLAGGED (ch, PRF_VICIOUS)) {
	if (!AWAKE (target) || IS_AFFECTED2 (target, AFF2_MINOR_PARALYSIS) ||
	    IS_AFFECTED (target, AFF_MAJOR_PARA))
	  return FALSE;
      }
      if ((ch->player_specials->saved.aggressive != -1) &&
	  (ch->player_specials->saved.aggressive < GET_HIT (ch)) &&
	  is_aggr_to (target, ch))
	return TRUE;
d936 1
a936 1
  
d940 7
a946 2
/* Return 0 if "name" is not in memory "mem", otherwise, */
/* non-zero integer. */
d948 1
a948 14
int mem_inMemory (struct char_data *ch, struct char_data *vict) {
  memory_rec *names;
  bool found = FALSE;
  
  if (MEMORY (ch) == NULL)
    return 0;
  
  for (names = MEMORY (ch); names && !found; names = names->next)
    if (names->id == GET_IDNUM (vict)) {
      found = TRUE;
      return 1;
    }
  
  return 0;
d953 17
a969 11
/* if fighting exit */
void check_mob_status (register struct char_data *ch) {
  switch (GET_CLASS (ch)) {
  case MCLASS_SORCERER:
    check_sor_status (ch);
    break;
  case MCLASS_CLERIC:
    check_cler_status (ch);
    break;
  default:
    break;
d971 1
d974 5
d980 14
a993 3
bool update_inv (struct char_data *ch, struct obj_data *obj, int where) {
  struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
  struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);
a994 5
  /*struct obj_data *wielding2 = GET_EQ(ch, WEAR_WIELD2) */
  
  if (!(obj))
    return FALSE;
  else {
d1030 1
d1035 2
a1036 2
int CountToughness (struct char_data *ch, struct char_data *victim) {
  int val, foo;
d1038 1
a1038 1
  if (!IS_NPC (ch))
d1043 10
a1052 10
  if (IS_CLERIC (victim) || IS_MAGIC_USER (victim))
    val = val * 2 / 3;
  else if (IS_WARRIOR (victim))
    val = val * 2;
  foo = MAX (0, 60 - GET_LEVEL (victim));
  if (!IS_FIGHTING (victim))
    val = val / (IS_THIEF (ch) ? 4 : 2);
  if ((IS_AFFECTED3 (victim, AFF3_AWARE)) && IS_THIEF (ch))
    val = (int) (val * 1.5);
  val = val * 100 / number (100 - foo, 100 + foo);
d1058 5
a1062 5
struct char_data *picktarget (struct char_data *ch) {
  struct char_data *t_ch;
  int target_table[MAX_TARGETS + 1];
  struct char_data *target_addr[MAX_TARGETS + 1];
  int a, b, c, d, n_a;
d1064 1
a1064 1
  if (!SanityCheck (ch, "PickTarget"))
d1067 3
a1069 2
  if (PLR_FLAGGED (ch, PLR_BOUND) || !AWAKE (ch) ||
      IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
d1071 3
a1073 6
  
  a = 0;
  n_a = NumAttackers (ch);
  
  for (t_ch = world[ch->in_room].people; t_ch; t_ch = t_ch->next_in_room) {
    if (t_ch == ch)
d1075 1
a1075 1
    if (!is_aggr_to (ch, t_ch))
d1077 4
a1080 6
    if (a < MAX_TARGETS) {
      target_table[a] = CountToughness (ch, t_ch);
      target_addr[a] = t_ch;
      target_table[a + 1] = -1;
      target_addr[a + 1] = NULL;
      a++;
d1086 14
a1099 1
  if (a == 0)
d1101 2
a1102 17
  
  if (!IS_NPC (ch) || MOB2_FLAGGED(ch, MOB2_PLAYER_PHANTASM))
    return (target_addr[number (0, (a - 1))]);
  
  b = -2;
  c = -1;
  for (d = 0; d < a; d++)
    if ((target_table[d] < b) || (b == -2))
      {
	c = d;
	b = target_table[d];
      }
  if (c != -1)
    return target_addr[c];
  
  /* nope, no likely targets in room */
  return NULL;
d1105 2
a1106 3

void Forgive_The_Basterd(struct char_data *ch) {
  register struct char_data *co, *next_co;
d1108 2
a1109 2
  for (co = character_list; co; co = next_co) {
    next_co = co->next;
d1111 1
a1111 3
    if (!IS_MOB (co))
      continue;
    if ((!MOB_FLAGGED (co, MOB_MEMORY)) && (!MEMORY (co)))
d1113 1
a1113 1
    if (co == ch)
d1115 1
a1115 1
    if (co->desc && co->desc->original)
d1118 1
a1118 2
      forget(co, ch);
    continue;
d1122 37
a1160 50
 * Revision 1.46  2008/01/07 10:34:53  jps
 * Allow mobs to be aggressive to player phantasms.  Mobs will also pause
 * in their tracking to kill such, but won't be fooled once the phantasm dies.
 *
 * Revision 1.45  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.44  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.43  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.42  2007/10/27 03:18:58  myc
 * Fixed bug in CAN_SEE so mobs can see without lights.  Removed MCAN_SEE
 * since it does the same thing as CAN_SEE.
 *
 * Revision 1.41  2007/09/08 23:19:23  jps
 * Stop memory mobs from blabbering when they try to start fights
 * in peaceful rooms.
 *
 * Revision 1.40  2007/09/07 19:51:30  jps
 * Added more checks for death after special initial attack, in
 * response to another aggressive-mob-killing-player crash bug.
 *
 * Revision 1.39  2007/08/29 01:22:18  jps
 * An assisting mob's initial special attack might well kill its
 * target.  Made the code check for that, and not press the
 * attack further if so.
 *
 * Revision 1.38  2007/08/26 01:55:41  myc
 * Fire now does real damage.  All fire spells have a chance to catch the
 * victim on fire.  Mobs attempt to douse themselves.
 *
 * Revision 1.37  2007/08/16 11:53:58  jps
 * Remove references to defunct specprocs.
 *
 * Revision 1.36  2007/08/05 22:19:17  myc
 * Set POS1 in addition to POS when a mob scrambles back to its feet.
 *
 * Revision 1.35  2007/07/18 21:05:16  jps
 * Make mobs behave mercifully toward other mobs only when
 * they are flagged NOVICIOUS.
 *
 * Revision 1.34  2007/07/18 17:02:25  jps
 * Stop helpers from rushing to assist their buddy if their buddy's
 * attacker has left the room.
 *
@


1.46
log
@Allow mobs to be aggressive to player phantasms.  Mobs will also pause
in their tracking to kill such, but won't be fooled once the phantasm dies.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.45 2008/01/06 23:50:47 jps Exp jps $
d217 1
a217 1
       * mob can move (eg via order) but we don't want him to wander - 321 */
d224 1
a224 1
	  && (!IS_AFFECTED(ch, AFF_CHARM))) {
d231 1
a231 1
         if(ch == NULL || GET_POS(ch) == POS_DEAD)
d1057 4
@


1.45
log
@Added spells project and simulacrum, and MOB2_ILLUSORY flag.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.44 2008/01/04 01:53:26 jps Exp jps $
d82 22
d239 4
a242 2
	  if (ch != vict && IS_NPC (vict) && FIGHTING (vict) &&
	      !IS_NPC (FIGHTING (vict)) && ch != FIGHTING (vict) &&
d283 1
a283 10
		  if (d->character->in_room == ch->in_room) {
		    class_operator (ch, d->character);	/*hit with special type if got one */
          if (GET_POS(d->character) == POS_DEAD) return;
          if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) return;
		    if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
            memory_attack_announce(ch, d->character);
		      hit (ch, check_guard(ch, d->character,FALSE), 
			   TYPE_UNDEFINED);
          }
		  }
d463 4
a466 1
            if (IS_NPC(vict) || !CAN_SEE(ch, vict) || PRF_FLAGGED(vict, PRF_NOHASSLE))
d486 1
a486 2
                  GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)) &&
                  (!IS_NPC(vict))) {
d525 2
a526 8
                  if (!MOB_FLAGGED (ch, MOB_ARRESTOR)) { /*is he here to kill or arrest Banyal */ 
                     class_operator (ch, vict);	/*hit with special type if got one */
                     if (GET_POS(vict) == POS_DEAD) return;
                     if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) return;
                     if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
                        memory_attack_announce(ch, vict);
                        hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
                     }
d630 2
a631 11
                        do_DumbMobTrack (ch, d->character->player.name, cmd_track,0);
                           
                        if (d->character->in_room == ch->in_room) {
                           class_operator (ch, d->character);	/*hit with special type if got one */
                           if (GET_POS(d->character) == POS_DEAD) return;
                           if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) return;
                           if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING(ch))) {
                              memory_attack_announce(ch, d->character);
                              hit (ch, check_guard(ch,d->character,FALSE), TYPE_UNDEFINED);
                           }
                        }
d823 1
a823 3
  return FALSE;      
  
  
d1016 1
a1016 1
  if (!IS_NPC (ch))
d1057 3
@


1.44
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.43 2008/01/03 12:44:03 jps Exp jps $
d138 1
a138 1
      if (MOB_FLAGGED (ch, MOB_SCAVENGER) && AWAKE (ch)) {
d1057 4
@


1.43
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.42 2007/10/27 03:18:58 myc Exp jps $
d28 2
d1057 4
@


1.42
log
@Fixed bug in CAN_SEE so mobs can see without lights.  Removed MCAN_SEE
since it does the same thing as CAN_SEE.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.41 2007/09/08 23:19:23 jps Exp myc $
a35 1
extern int rogue_subclasses[ROGUE_SUBCLASSES];
d1055 4
@


1.41
log
@Stop memory mobs from blabbering when they try to start fights
in peaceful rooms.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.40 2007/09/07 19:51:30 jps Exp jps $
d447 1
a447 1
            if (IS_NPC(vict) || !(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
d1056 4
@


1.40
log
@Added more checks for death after special initial attack, in
response to another aggressive-mob-killing-player crash bug.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.39 2007/08/29 01:22:18 jps Exp jps $
d261 1
d510 1
d623 1
d1056 4
@


1.39
log
@An assisting mob's initial special attack might well kill its
target.  Made the code check for that, and not press the
attack further if so.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.38 2007/08/26 01:55:41 myc Exp jps $
d260 1
d469 1
d481 1
d508 1
d620 1
d1053 5
@


1.38
log
@Fire now does real damage.  All fire spells have a chance to catch the
victim on fire.  Mobs attempt to douse themselves.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.37 2007/08/16 11:53:58 jps Exp myc $
d227 1
a227 1
	      if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
d1048 4
@


1.37
log
@Remove references to defunct specprocs.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.36 2007/08/05 22:19:17 myc Exp jps $
d91 1
d119 5
d1048 3
@


1.36
log
@Set POS1 in addition to POS when a mob scrambles back to its feet.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.35 2007/07/18 21:05:16 jps Exp myc $
a93 27
    if (ch->in_room == real_room (30761)) {
      special_update (ch);
    }
    if (ch->in_room == real_room (9800)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9801)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9802)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9803)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9804)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9805)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9806)) {
      el_passage (ch);
    }
    if (ch->in_room == real_room (9807)) {
      el_passage (ch);
    }
d1042 3
@


1.35
log
@Make mobs behave mercifully toward other mobs only when
they are flagged NOVICIOUS.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.34 2007/07/18 17:02:25 jps Exp jps $
d756 1
d765 1
d1069 4
@


1.34
log
@Stop helpers from rushing to assist their buddy if their buddy's
attacker has left the room.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.33 2007/04/11 16:05:27 jps Exp jps $
d826 2
a827 5
  /* now different checks for pcs/npcs */
  
  
  if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
      (mem_inMemory (ch, target) && !MOB_FLAGGED (ch, MOB_NOVICIOUS)))
d829 1
a829 2
  
  
d856 1
a856 1
    if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
d859 1
a859 4
    
    if (!MOB_FLAGGED (ch, MOB_NOVICIOUS))
      return TRUE;
    
d1067 4
@


1.33
log
@Scavengers who pick up money won't end up with the money pile object in inventory.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.32 2007/03/27 04:27:05 myc Exp jps $
d238 2
a239 1
	      !IS_NPC (FIGHTING (vict)) && ch != FIGHTING (vict)) {
d1074 3
@


1.32
log
@Fixed typo in battle message.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.31 2007/02/08 01:32:20 myc Exp myc $
d60 1
d171 1
d1073 3
@


1.31
log
@Hopefully no crashes when mobs are killed by circle of fire now.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.30 2006/12/08 04:01:13 myc Exp myc $
d252 1
a252 1
		act ("$n watches the battle in amusment.", FALSE, ch, 0, vict, TO_ROOM);
d1071 3
@


1.30
log
@Aggro mobs don't all announce their attack like memory mobs now.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.29 2006/11/27 00:17:00 jps Exp $
d226 3
d1071 3
@


1.29
log
@Fix mob tracking oops
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.28 2006/11/20 09:03:58 jps Exp jps $
d483 1
a483 2
               if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
                  memory_attack_announce(ch, vict);
a484 1
               }
d494 1
a494 2
               if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch))) {
                  memory_attack_announce(ch, vict);
a495 1
               }
d1068 3
@


1.28
log
@Mobs with memory attack - not just the ones with track.
They also give some announcement or make noise as they do.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.27 2006/11/20 07:25:34 jps Exp jps $
a257 1
      /* Added fast to slow till bug is fixed Banyal*/
d259 2
a260 3
	/*slow track Banyal */
	 /*  temporarly make fast == slow track, remove || FAST_TRACK to return to normal */
	if (MOB_FLAGGED (ch, MOB_SLOW_TRACK) || MOB_FLAGGED(ch,MOB_SLOW_TRACK)) {
a615 1
      /*Fast track Banyal */
d617 2
a618 3
         /*  To temporarly make fast track = slow track we'll make a dummy staement here */
         /*  remove && FLAGGED( SLOW_TRACK) to make it normal again */
         if (MOB_FLAGGED (ch, MOB_FAST_TRACK) && MOB_FLAGGED(ch, MOB_SLOW_TRACK)) {
d1072 4
@


1.27
log
@Stop mobs from wandering off in the middle of a battle, such as
when they get up after being bashed.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.26 2006/11/17 22:52:59 jps Exp jps $
d69 11
d277 2
a278 1
		    if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
d281 1
d414 1
a414 1
  register struct char_data *ch, *next_ch, *vict;
d416 24
a439 24
  struct descriptor_data *d, *next_d;
  int found = FALSE, a;
  bool hascast = FALSE;
  memory_rec *names, *namestmp;
  int cmd_track;
  bool WHYTRACK = FALSE;
  
  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;
    if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
      continue;
    if (ch->desc && ch->desc->original)
      continue;
    if (MOB_FLAGGED (ch, MOB_CASTING))
      continue;
    if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
      continue;
    if (IS_FIGHTING (ch))
      continue;
    /*if mob not fighting still decrease wait state */
    if ((GET_MOB_WAIT (ch) > 0)) {
      WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE)), 0))
	continue;
    }
d441 11
a451 1
    /*pets banyal */
a452 9
    if (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict)) {
	  act ("&7$n assist $s master!!&0", FALSE, ch, 0, vict, TO_ROOM);
	  hit (ch, check_guard(ch,FIGHTING (vict),FALSE), TYPE_UNDEFINED);
	  found = TRUE;
	}
    }
d454 1
d456 83
a538 48
    /* Aggressive Mobs */
    
    if (MOB_FLAGGED (ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
	if (ch == vict)
	  continue;
	if (IS_NPC(vict) || !(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	  continue;
	if (MOB_FLAGGED (ch, MOB_WIMPY) && AWAKE (vict))
	  continue;
	if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) /* gurlaek 7/25/1999 */
	  continue;
	if ((IS_AFFECTED (ch, AFF_CHARM)))
	  if (ch->master) {
	    if (ch->master == vict)
	      continue;
	    if ((ch->in_room) == (ch->master->in_room)) {
	      continue;
	    }
	    if (is_grouped (ch, vict)) {
	      continue;
	    }
	  }
	
	      
	if (((MOB_FLAGGED (ch, MOB_AGGR_EVIL_RACE) &&
	      GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL) ||
	     (MOB_FLAGGED (ch, MOB_AGGR_GOOD_RACE) &&
	      GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)) &&
	    (!IS_NPC(vict))) {
	  class_operator (ch, vict);	/*hit with special type if got one */
	  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
	    hit (ch, check_guard(ch,vict,FALSE), TYPE_UNDEFINED);
	  found = TRUE;
	  WHYTRACK = TRUE;
	}
	
	if (((MOB_FLAGGED (ch, MOB_AGGRESSIVE)) ||
	     (MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
	     (MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
	     (MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict)))) {
	  class_operator (ch, vict);	/*hit with special type if got one */
	  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
	    hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
	  found = TRUE;
	  WHYTRACK = TRUE;
	}
a539 3
    }
    if (MOB_FLAGGED (ch, MOB_ARRESTOR) && (!MEMORY (ch)))
      extract_char (ch);
d541 36
a576 25
    
    /* Mob Memory */
    if ((MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) &&
	(MOB_FLAGGED (ch, MOB_WIMPY) &&
	 (GET_HIT (ch) < (GET_MAX_HIT (ch) >> 2)))) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
	if (IS_NPC (vict) || !CAN_SEE (ch, vict) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	  continue;
	for (names = MEMORY (ch); names && !found; names = namestmp)
	  namestmp = names->next;
	if (names && names->id == GET_IDNUM (vict)) {
	  found = TRUE;
	  WHYTRACK = TRUE;
	  if (!MOB_FLAGGED (ch, MOB_ARRESTOR))	{ /*is he here to kill or arrest Banyal */ 
	    class_operator (ch, vict);	/*hit with special type if got one */
	    if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
	      hit (ch, check_guard(ch, vict, FALSE), TYPE_UNDEFINED);
	  } else {
	    perform_arrest (vict);
	    forget (ch, vict);
	    extract_char (ch);
	  }
	  continue;
	}
d578 3
a580 1
    }
d582 32
a613 4
    if (GET_CLASS (ch) == MCLASS_CLERIC)
      if (((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) < 95) { /* heal if less than 95% hp */
	mob_heal_up (ch);
	continue;
d615 35
a649 99
      
    /*remove anyone without memory or not flagged memory */
    if ((!MOB_FLAGGED (ch, MOB_MEMORY)) || (!MEMORY (ch)))
      continue;
    
    /*Check maybe he wants to summon target */
    if (GET_MSKILL (ch, SPELL_SUMMON)) {
      if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30)) /* if greater than 30%hp */
	for (d = descriptor_list; d; d = next_d) {
	  if (STATE (d) != CON_PLAYING) {
	    next_d = d->next;
	    continue;
	  }
	  next_d = d->next;
	  if (GET_LEVEL (d->character) > LVL_IMMORT)
	    continue;
	  for (names = MEMORY (ch); names && !found; names = names->next)
	    if (names->id == GET_IDNUM (d->character)) {
	      if ((GET_MSKILL (ch, SPELL_SUMMON))) {
		a = 0;
		a = SPELL_CIRCLE (SPELL_SUMMON);
		if (can_summon (ch, d->character)) {
		  hascast = TRUE;
		  break;
		}
	      }
	    }
	  if (hascast)
	    break;
	}
    }
    if (hascast)
      continue;
    
    /*try to dim to him or relocate */
    if (((GET_MSKILL (ch, SPELL_DIMENSION_DOOR))) || ((GET_MSKILL (ch, SPELL_RELOCATE)))) {
      if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
	for (d = descriptor_list; d; d = next_d) {
	  if (STATE (d) != CON_PLAYING) {
	    next_d = d->next;
	    continue;
	  }
	  
	  next_d = d->next;
	  if (d->character && GET_LEVEL (d->character) > LVL_IMMORT)
	    continue;
	  for (names = MEMORY (ch); names && !found; names = names->next)
	    if (names->id == GET_IDNUM (d->character)) {
	      if ((GET_MSKILL (ch, SPELL_DIMENSION_DOOR)))
		if (can_dim (ch, d->character)) {
		  hascast = TRUE;
		  break;
		}
	      /*if real high try relocate */
	      a = 0;
	      a = SPELL_CIRCLE (SPELL_RELOCATE);
	      if ((GET_MSKILL (ch, SPELL_RELOCATE)))
		if (GET_LEVEL (ch) > 60)
		  if (try_cast (ch, d->character, a, SPELL_RELOCATE)) {
		    hascast = TRUE;
		    break;
		  }
	    }
	  if (hascast)
	    break;
	  
	}
    }
    if (hascast)
      continue;
    /*Fast track Banyal */
    if (WHYTRACK == FALSE) {
       /*  To temporarly make fast track = slow track we'll make a dummy staement here */
       /*  remove && FLAGGED( SLOW_TRACK) to make it normal again */
      if (MOB_FLAGGED (ch, MOB_FAST_TRACK) && MOB_FLAGGED(ch, MOB_SLOW_TRACK)) {
	if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) {
	  
	  for (d = descriptor_list; d; d = next_d) {
	    if (STATE (d) != CON_PLAYING) {
	      next_d = d->next;
	      continue;
	    }
	    
	    next_d = d->next;
	    for (names = MEMORY (ch); names && !found; names = names->next) {
	      if (d->character && names->id == GET_IDNUM (d->character)) {
		cmd_track = find_command ("DumbMobTrack");
		do_DumbMobTrack (ch, d->character->player.name, cmd_track,0);
			      
		if (d->character->in_room == ch->in_room) {
		  class_operator (ch, d->character);	/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING(ch)))
		    hit (ch, check_guard(ch,d->character,FALSE), TYPE_UNDEFINED);
		}
		return;
	      }
	    }
	  }
	}
d651 1
a651 2
    }
  }
d1076 4
@


1.26
log
@Change AGGR_GOOD/EVIL_ALIGN to AGGR_GOOD/EVIL_RACE
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.25 2002/09/30 01:12:32 jjl Exp jps $
d210 5
a214 1
	perform_move (ch, door, 1);
d1053 3
@


1.25
log
@Added checks so guard does something.
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.24 2002/09/13 02:32:10 jjl Exp $
d463 1
a463 1
	if (((MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
d465 1
a465 1
	     (MOB_FLAGGED (ch, MOB_AGGR_GOOD_ALIGN) &&
d1049 3
@


1.24
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: mobact.c,v 1.23 2001/04/07 03:02:59 dce Exp $
d47 2
d222 5
a226 1
	      class_operator (ch, FIGHTING (vict));  /* hit with special type if got one */
d228 2
a229 1
		hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
d263 2
a264 1
		      hit (ch, d->character, TYPE_UNDEFINED);
d431 1
a431 1
	  hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
d470 1
a470 1
	    hit (ch, vict, TYPE_UNDEFINED);
d481 1
a481 1
	    hit (ch, vict, TYPE_UNDEFINED);
d507 1
a507 1
	      hit (ch, vict, TYPE_UNDEFINED);
d615 1
a615 1
		    hit (ch, d->character, TYPE_UNDEFINED);
d706 1
a706 1
    mob_cast (ch, victim, spellnum);
d1049 3
@


1.23
log
@Mobs will no longer be agrresive to each other with the
MOB_AGGRESSIVE flag...a new flag will be coming soon.
@
text
@d1 3
a3 1
// $Id: mobact.c,v 1.22 2000/11/28 00:45:28 mtp Exp $
d69 1
a69 1
  //   struct char_data *i;
d239 1
a239 1
	// temporarly make fast == slow track, remove || FAST_TRACK to return to normal
d390 1
a390 1
  //   struct char_data *i;
d587 2
a588 2
      // To temporarly make fast track = slow track we'll make a dummy staement here
      // remove && FLAGGED( SLOW_TRACK) to make it normal again
d1039 106
a1144 100
// $Log: mobact.c,v $
// Revision 1.22  2000/11/28 00:45:28  mtp
// removed mobprog stuff
//
// Revision 1.21  2000/11/24 18:42:20  rsd
// Added back rlog messages from prior to the addition of
// the $log$ string.
//
// Revision 1.20  2000/04/24 20:00:41  rsd
// Ok, mobiles really don't wear eq and wield weapons now,
// I swear!
//
// Revision 1.19  2000/04/22 22:38:37  rsd
// Fixed comment header, fixed logged information about weapon exchange
// to include ch's name. Also encouraged animals not to try to wield weapons.
//
// Revision 1.18  2000/02/25 03:32:11  cso
// fixing typos.. guard chuckles at you as he watches the fight
//
// Revision 1.17  1999/12/06 20:21:04  cso
// Fixed a typo in line "takes note of your battle tactics."
//
// Revision 1.16  1999/11/28 23:51:54  cso
// added check to mobile_activity to keep charmed mobs from wandering
//
// Revision 1.15  1999/11/23 15:48:23  jimmy
// Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
// Reinstated dual wield.
// Allowed mobs/players to pick up items while fighting.
// Fixed a bug in the damage message that wrongfully indicated a miss
// due to a rounding error in the math.
// This was all done in order to facilitate the chance to sling your
// weapon in combat.  Dex and proficiency checks are now made on any missed
// attact and a failure of both causes the weapon to be slung.
//
// Revision 1.14  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.13  1999/09/04 18:46:52  jimmy
// More small but important bug fixes found with insure.  These are all runtime fixes.
//
// Revision 1.12  1999/07/25 05:40:18  jimmy
// Fixed the skill advancement in peace rooms bug.
// --gurlaek
//
// Revision 1.11  1999/07/14 19:24:03  jimmy
// The combat system was enhanced/improved in the following ways:  Mobs
// can no longer flee while bashed or sitting.  Fleeing causes casters to
// stop casting.  You can now flee while flying.  pk checks were added to
// bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
// fixes. spellcasting for mobs is now very similar to PC spellcasting.
// MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
// Mobs no longer improve skills.  Bash now requires mobs to have a shield
// just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
// --gurlaek
//
// Revision 1.10  1999/07/12 02:58:46  jimmy
// Lots of formatting and general cleanup. No code changes.
// gurlaek.
//
// Revision 1.9  1999/07/06 19:57:05  jimmy
// This is a Mass check-in of the new skill/spell/language assignment system.
// This New system combines the assignment of skill/spell/language for
// both mobs and PCs.  LOts of code was touched and many errors were fixed.
// MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
// MObs now get random skill/spell/language levels baseed on their race/class/level
// that exactly align with PC's.  PC's no longer have to rent to use skills gained
// by leveling or when first creating a char.  Languages no longer reset to defaults
// when a PC levels.  Discovered that languages have been defined right in the middle
// of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
// the mob files to compensate for the 13 to -1 class change.
// --gurlaek 7/6/1999
//
// Revision 1.8  1999/05/02 19:32:34  dce
// Temporarly make fast track = slow track
//
// Revision 1.7  1999/04/04 04:05:12  dce
// Mob fighting fixes
//
// Revision 1.6  1999/04/04 03:42:41  dce
// Mobs don't atack each other...only if AGGR_ALIGN.
//
// Revision 1.5  1999/03/31 22:06:06  dce
// Allows flying mobs to wander.
//
// Revision 1.4  1999/03/22 18:57:32  tph
// mobs nolonger try_cast in NOMAGIC rooms.
//
// Revision 1.3  1999/02/04 21:07:27  jimmy
// Made mobs aggressive to each other.
// fingon
//
// Revision 1.2  1999/01/31 17:19:29  mud
// Added a standard comment header
// Indented the entire file
// took out some ranges of blank space
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.22
log
@removed mobprog stuff
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.21 2000/11/24 18:42:20 rsd Exp mtp $
a427 2
    /* Mobs are now aggressive to each other!!! */
    /* --Fingon                                 */
d434 1
a434 1
	if (!(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
d1038 3
@


1.21
log
@Added back rlog messages from prior to the addition of
the $log$ string.
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.20 2000/04/24 20:00:41 rsd Exp $
a56 2
void mprog_random_trigger (struct char_data *mob);
void mprog_wordlist_check (char *arg, struct char_data *mob, struct char_data *actor, struct obj_data *obj, void *vo, int type);
a140 4
      /* only execute random triggers if someone is in zone */
      if (!is_empty (world[ch->in_room].zone))
	mprog_random_trigger (ch);
      
a208 17
      /* MOB Prog foo */
      /* only execute prog if zone isn't empty */
      if (!FIGHTING(ch) && IS_NPC (ch) && ch->mpactnum > 0 && !is_empty (world[ch->in_room].zone)) {
	MPROG_ACT_LIST *tmp_act, *tmp2_act;
	
	for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp_act->next) {
	  mprog_wordlist_check (tmp_act->buf, ch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG);
	  free (tmp_act->buf);
	}
	for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp2_act) {
	  tmp2_act = tmp_act->next;
	  free (tmp_act);
	}
	ch->mpactnum = 0;
	ch->mpact = NULL;
      }
      
d1040 4
@


1.20
log
@Ok, mobiles really don't wear eq and wield weapons now,
I swear!
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.19 2000/04/22 22:38:37 rsd Exp $
a1061 19



















d1063 4
d1092 62
@


1.19
log
@Fixed comment header, fixed logged information about weapon exchange
to include ch's name. Also encouraged animals not to try to wield weapons.
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.18 2000/02/25 03:32:11 cso Exp $
d166 16
a181 10
	for (obj = ch->carrying; obj; obj = obj->next_content) {
	  if (CAN_SEE_OBJ (ch, obj)) {
	    where = find_eq_pos (ch, obj, 0);
	    if (where >= 0) {
	      if (GET_EQ (ch, where)) {
		x = GET_EQ (ch, where);
		if (GET_OBJ_COST (x) >= GET_OBJ_COST (obj))
		  continue;
		else {
		  perform_remove (ch, where);
d185 8
a192 11
	      } else {
		perform_wear (ch, obj, where);
		continue;
	      }
	    } else { /* where = -1, bag or weopon or type */
	      if (!(update_inv (ch, obj, where)))  {	/*try it */
		if (check_weopeon_value (ch, obj)) {
		  mob_remove_weopon (ch, obj, where);
		  if (!(update_inv (ch, obj, where))) {
		    sprintf(buf, "%s Coudnt Update with weopoen exchange - Proky.", GET_NAME(ch));
		    mudlog (buf, NRM, LVL_GOD, FALSE);
d195 2
a196 2
	      }
	    } /* (where >= 0) */
a199 1
      
d1082 4
@


1.18
log
@fixing typos.. guard chuckles at you as he watches the fight
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.17 1999/12/06 20:21:04 cso Exp $
d3 1
a3 1
 *   File: mobact.c                                  NOW Part of FieryMUD  *
a6 1
 *                                                                         *
d9 3
a11 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
a17 1

d188 2
a189 1
		    mudlog ("Mob Coudnt Update with weopoen exchange - Proky.", NRM, LVL_GOD, FALSE);
d918 1
a918 1
  
d930 1
a930 1
    else if ((!wielding) && (!hwielding)) {
d934 1
a934 1
      } else if (CAN_WEAR (obj, ITEM_WEAR_2HWIELD)) {
d1080 3
@


1.17
log
@Fixed a typo in line "takes note of your battle tactics."
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.16 1999/11/28 23:51:54 cso Exp $
d247 1
a247 1
		act ("$n chuckles at your as $e watches the fight", FALSE, ch, 0, vict, TO_ROOM);
d1079 3
@


1.16
log
@added check to mobile_activity to keep charmed mobs from wandering
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.15 1999/11/23 15:48:23 jimmy Exp cso $
d249 1
a249 1
		act ("$n takes note of your battle tatics.", FALSE, ch, 0, vict, TO_ROOM);
d1079 3
@


1.15
log
@Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
Reinstated dual wield.
Allowed mobs/players to pick up items while fighting.
Fixed a bug in the damage message that wrongfully indicated a miss
due to a rounding error in the math.
This was all done in order to facilitate the chance to sling your
weapon in combat.  Dex and proficiency checks are now made on any missed
attact and a failure of both causes the weapon to be slung.
@
text
@d1 1
a1 1
// $Id: mobact.c,v 1.14 1999/09/05 07:00:39 jimmy Exp $
d199 5
a203 1
      if (!FIGHTING(ch) && !MOB_FLAGGED (ch, MOB_SENTINEL) && (GET_POS (ch) == POS_STANDING || (GET_POS(ch) == POS_FLYING)) &&
d207 2
a208 1
	   (world[EXIT (ch, door)->to_room].zone == world[ch->in_room].zone))) {
d1079 10
@


1.14
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d108 1
a108 1
    if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
d148 1
a148 1
      if (MOB_FLAGGED (ch, MOB_SCAVENGER) && !FIGHTING (ch) && AWAKE (ch)) {
d199 1
a199 1
      if (!MOB_FLAGGED (ch, MOB_SENTINEL) && (GET_POS (ch) == POS_STANDING || (GET_POS(ch) == POS_FLYING)) &&
d209 1
a209 1
      if (IS_NPC (ch) && ch->mpactnum > 0 && !is_empty (world[ch->in_room].zone)) {
d225 1
a225 1
      if (MOB_FLAGGED (ch, MOB_HELPER)) {
d250 1
a250 1
      if (!MOB_FLAGGED (ch, MOB_SENTINEL)) { 
d1073 4
a1076 1
// $Log$
@


1.13
log
@More small but important bug fixes found with insure.  These are all runtime fixes.
@
text
@d1 1
d1073 1
@


1.12
log
@Fixed the skill advancement in peace rooms bug.
--gurlaek
@
text
@d164 1
d168 2
a169 2
	    if (GET_EQ (ch, where)) {
	      if (where >= 0) {
d178 1
a178 4
		/*perform_wear(ch, obj, where); */
	      }
	    } else {
	      if (where >= 0) {
d182 8
a189 7
	    }
	    /*where = -1, bag or weopon or type */
	    if (!(update_inv (ch, obj, where)))	/*try it */
	      if (check_weopeon_value (ch, obj)) {
		mob_remove_weopon (ch, obj, where);
		if (!(update_inv (ch, obj, where)))
		  mudlog ("Mob Coudnt Update with weopoen exchange - Proky.", NRM, LVL_GOD, FALSE);
d191 1
@


1.11
log
@The combat system was enhanced/improved in the following ways:  Mobs
can no longer flee while bashed or sitting.  Fleeing causes casters to
stop casting.  You can now flee while flying.  pk checks were added to
bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
fixes. spellcasting for mobs is now very similar to PC spellcasting.
MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
Mobs no longer improve skills.  Bash now requires mobs to have a shield
just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
--gurlaek
@
text
@d454 2
@


1.10
log
@Lots of formatting and general cleanup. No code changes.
gurlaek.
@
text
@d688 1
a688 1
  
d733 1
a733 1
      if ((FIGHTING (ch)) && (GET_POS (ch) > POS_FIGHTING))
d735 1
d737 1
a737 1
      if (GET_MOB_WAIT (ch) > 0)
d739 6
a744 10
	  else {
	    if (!(GET_MOB_WAIT (ch) > 0)) {
	      if (GET_POS (ch) < POS_FIGHTING) {
		GET_POS (ch) = POS_FIGHTING;
		act ("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
		return;
	      }
	      victim = FIGHTING (ch);
	      class_operator (ch, victim);
	    }
d746 4
@


1.9
log
@This is a Mass check-in of the new skill/spell/language assignment system.
This New system combines the assignment of skill/spell/language for
both mobs and PCs.  LOts of code was touched and many errors were fixed.
MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
MObs now get random skill/spell/language levels baseed on their race/class/level
that exactly align with PC's.  PC's no longer have to rent to use skills gained
by leveling or when first creating a char.  Languages no longer reset to defaults
when a PC levels.  Discovered that languages have been defined right in the middle
of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
the mob files to compensate for the 13 to -1 class change.
--gurlaek 7/6/1999
@
text
@d57 1
a57 2
void mprog_wordlist_check (char *arg, struct char_data *mob,
			   struct char_data *actor, struct obj_data *obj, void *vo, int type);
d66 1
a66 3
void 
mobile_activity (void)
{
d75 1
d77 62
a138 75
  ACMD (do_get);
  for (ch = character_list; ch; ch = next_ch)
    {
      next_ch = ch->next;
      if (ch->in_room == real_room (30761))
	{
	  special_update (ch);
	}
      if (ch->in_room == real_room (9800))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9801))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9802))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9803))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9804))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9805))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9806))
	{
	  el_passage (ch);
	}
      if (ch->in_room == real_room (9807))
	{
	  el_passage (ch);
	}
      
      if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
	continue;
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
	continue;
      if (ch->desc && ch->desc->original)
	continue;
      check_mob_status (ch);	/*checks spell ups etc */
      /* Examine call for special procedure */
      if (MOB_FLAGGED (ch, MOB_CASTING))
	continue;
      /*if sitting and not ment to be better stand */
      if (GET_POS (ch) < POS_FIGHTING)
	if (GET_DEFAULT_POS (ch) == POS_STANDING)
	  if (GET_MOB_WAIT (ch) <= 0)
	    {
	      max = find_command ("stand");
	      do_stand (ch, "", max, 0);
	      max = 0;
	    }
      
      if (MOB_FLAGGED (ch, MOB_SPEC) && !no_specials)
	{
	  if (mob_index[GET_MOB_RNUM (ch)].func == NULL)
	    {
	      sprintf (buf, "%s (#%d): Attempting to call non-existing mob func",
		       GET_NAME (ch), GET_MOB_VNUM (ch));
	      log (buf);
	      REMOVE_BIT (MOB_FLAGS (ch), MOB_SPEC);
	    }
	  else
	    {
	      if ((mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, ""))
		continue;	/* go to next char */
	    }
d140 1
d142 1
d145 1
d147 29
a175 17
      if (MOB_FLAGGED (ch, MOB_SCAVENGER) && !FIGHTING (ch) && AWAKE (ch))
	{
	  if (world[ch->in_room].contents && !number (0, 1))
	    {
	      max = 0;
	      best_obj = NULL;
	      for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
		if (CAN_GET_OBJ (ch, obj) && GET_OBJ_COST (obj) > max)
		  {
		    best_obj = obj;
		    max = GET_OBJ_COST (obj);
		  }
	      if (best_obj != NULL)
		{
		  obj_from_room (best_obj);
		  obj_to_char (best_obj, ch);
		  act ("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM);
d177 7
d185 8
a192 42
	  /*if stuff in inventry check to use it */
	  for (obj = ch->carrying; obj; obj = obj->next_content)
	    {
	      if (CAN_SEE_OBJ (ch, obj))
		{
		  where = find_eq_pos (ch, obj, 0);
		  if (GET_EQ (ch, where))
		    {
		      if (where >= 0)
			{
			  x = GET_EQ (ch, where);
			  if (GET_OBJ_COST (x) >= GET_OBJ_COST (obj))
			    continue;
			  else
			    {
			      perform_remove (ch, where);
			      perform_wear (ch, obj, where);
			      continue;
			    }
			  /*perform_wear(ch, obj, where); */
			}
		    }
		  else
		    {
		      if (where >= 0)
			{
			  perform_wear (ch, obj, where);
			  continue;
			}
		    }
		  /*where = -1, bag or weopon or type */
		  if (!(update_inv (ch, obj, where)))	/*try it */
		    if (check_weopeon_value (ch, obj))
		      {
			mob_remove_weopon (ch, obj, where);
			if (!(update_inv (ch, obj, where)))
			  mudlog ("Mob Coudnt Update with weopoen exchange - Proky.", NRM, LVL_GOD, FALSE);
		      }
		}
	      
	      
	    }
d194 1
a194 3
      
      
      
d197 1
d202 3
a204 4
	   (world[EXIT (ch, door)->to_room].zone == world[ch->in_room].zone)))
	{
	  perform_move (ch, door, 1);
	}
d207 11
a217 16
      if (IS_NPC (ch) && ch->mpactnum > 0 && !is_empty (world[ch->in_room].zone))
	{
	  MPROG_ACT_LIST *tmp_act, *tmp2_act;
	  
	  for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp_act->next)
	    {
	      mprog_wordlist_check (tmp_act->buf, ch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG);
	      free (tmp_act->buf);
	    }
	  for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp2_act)
	    {
	      tmp2_act = tmp_act->next;
	      free (tmp_act);
	    }
	  ch->mpactnum = 0;
	  ch->mpact = NULL;
d219 3
d224 43
a266 12
      if (MOB_FLAGGED (ch, MOB_HELPER))
	{
	  found = FALSE;
	  for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    if (ch != vict && IS_NPC (vict) && FIGHTING (vict) &&
		!IS_NPC (FIGHTING (vict)) && ch != FIGHTING (vict))
	      {
		if (GET_LEVEL (FIGHTING (vict)) > 20)
		  {
		    
		    act ("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
		    class_operator (ch, FIGHTING (vict));		/*hit with special type if got one */
d268 1
a268 12
		      hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
		    found = TRUE;
		  }
		else
		  {
		    hurm = number (1, 10);
		    if (hurm == 1)
		      act ("$n watches the battle in amusment.", FALSE, ch, 0, vict, TO_ROOM);
		    if (hurm == 2)
		      act ("$n chuckles at your as $e watches the fight", FALSE, ch, 0, vict, TO_ROOM);
		    if (hurm == 3)
		      act ("$n takes note of your battle tatics.", FALSE, ch, 0, vict, TO_ROOM);
d270 2
a272 35
	}
      /* Added fast to slow till bug is fixed Banyal*/
      if (!MOB_FLAGGED (ch, MOB_SENTINEL))
	{				/*slow track Banyal */
// temporarly make fast == slow track, remove || FAST_TRACK to return to normal
	  if (MOB_FLAGGED (ch, MOB_SLOW_TRACK) || MOB_FLAGGED(ch,MOB_SLOW_TRACK)) 
	    {
	      if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
		{
		  for (d = descriptor_list; d; d = next_d)
		    {
		      if (STATE (d) != CON_PLAYING)
			{
			  next_d = d->next;
			  continue;
			}
		      next_d = d->next;
		      
		      for (names = MEMORY (ch); names && !found; names = names->next)
			{
			  if (names->id == GET_IDNUM (d->character))
			    {
			      cmd_track = find_command ("DumbMobTrack");
			      do_DumbMobTrack (ch, d->character->player.name, cmd_track, 0);
			      if (d->character->in_room == ch->in_room)
				{
				  class_operator (ch, d->character);	/*hit with special type if got one */
				  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
				    hit (ch, d->character, TYPE_UNDEFINED);
				}
			      return;
			    }
			}
		    }
		}
d274 1
a274 1
	  /* Add new mobile actions here */
d276 3
a278 1
    }				/* end for() */
d287 1
a287 3
void 
remember (struct char_data *ch, struct char_data *victim)
{
d300 2
a301 3
  if (!present)
    {
      CREATE (tmp, memory_rec, 1);
d303 6
a308 6
      if (!(MEMORY (ch)))
	tmp->next = NULL;
      tmp->next = MEMORY (ch);
      tmp->id = GET_IDNUM (victim);
      MEMORY (ch) = tmp;
    }
d313 1
a313 3
void 
forget (struct char_data *ch, struct char_data *victim)
{
d322 8
a329 9
  if (curr->id == GET_IDNUM (victim))
    {
      if (curr->next)
	MEMORY (ch) = curr->next;
      else
	MEMORY (ch) = NULL;
      free (curr);
      return;
    }
d333 4
a336 5
  if (tmp)
    {
      curr->next = tmp->next;
      free (tmp);
    }
d339 1
a339 1
#endif
d341 1
a341 2
void remember(struct char_data * ch, struct char_data * victim)
{
d386 1
a386 3
void 
clearMemory (struct char_data *ch)
{
d391 5
a395 6
  while (curr)
    {
      next = curr->next;
      free (curr);
      curr = next;
    }
d400 1
a400 227

/*Function for setting mob skills on login */
/* This has been replaced by set_skills() in class.c. Mobs and players now */
/* have similar skillsets --gurlaek 7/3/1999
#define STSP   MIN(98, MAX(75, (aloud_skill) ? mob_proto[i].player.level * 3 : 0))
#define STSK   MIN(95, MAX((mob_proto[i].player.level) * 2, 20))
void set_mob_skills (int i, int class, int race)
{
  struct char_data *mobproto;

  mobproto = &mob_proto[i];
  
  switch (race)
    {
    case SPECIES_DRAGON:
      SET_SKILL (mobproto, SKILL_BREATH, STSK);
      SET_SKILL (mobproto, SKILL_SWEEP, STSK);
      SET_SKILL (mobproto, SKILL_ROAR, STSK);
      SET_SKILL (mobproto, SPELL_ACID_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_FROST_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_GAS_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_FIRE_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_LIGHTNING_BREATH, STSP);
      break;
    case SPECIES_DEMON:
      SET_SKILL (mobproto, SKILL_BREATH, STSK);
      SET_SKILL (mobproto, SKILL_ROAR, STSK);
      SET_SKILL (mobproto, SPELL_ACID_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_FROST_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_GAS_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_FIRE_BREATH, STSP);
      SET_SKILL (mobproto, SPELL_LIGHTNING_BREATH, STSP);
      break;
    }
  switch (class)
    {
    case MCLASS_VOID:
      
      break;
    case MCLASS_SORCERER:
      
      SET_SKILL (mobproto, SPELL_COMPREHEND_LANG, STSP);
      SET_SKILL (mobproto, SPELL_TELEPORT, STSP);
      SET_SKILL (mobproto, SPELL_DISINTEGRATE, STSP);
      SET_SKILL (mobproto, SPELL_MASS_INVIS, STSP);
      SET_SKILL (mobproto, SPELL_MINOR_GLOBE, STSP);
      SET_SKILL (mobproto, SPELL_MAJOR_GLOBE, STSP);
      SET_SKILL (mobproto, SPELL_HARNESS, STSP);
      SET_SKILL (mobproto, SPELL_RELOCATE, STSP);
      SET_SKILL (mobproto, SPELL_CHAIN_LIGHTNING, STSP);
      SET_SKILL (mobproto, SPELL_FIRESHIELD, STSP);
      SET_SKILL (mobproto, SPELL_COLDSHIELD, STSP);
      SET_SKILL (mobproto, SPELL_ICE_STORM, STSP);
      SET_SKILL (mobproto, SPELL_ICE_SHARDS, STSP);
      SET_SKILL (mobproto, SPELL_DISPEL_MAGIC, STSP);
      SET_SKILL (mobproto, SPELL_MINOR_PARALYSIS, STSP);
      SET_SKILL (mobproto, SPELL_TELEPORT, STSP);
      SET_SKILL (mobproto, SPELL_BIGBYS_CLENCHED_FIST, STSP);
      SET_SKILL (mobproto, SPELL_BURNING_HANDS, STSP);
      SET_SKILL (mobproto, SPELL_CHARM, STSP);
      SET_SKILL (mobproto, SPELL_CHILL_TOUCH, STSP);
      SET_SKILL (mobproto, SPELL_FIREBALL, STSP);
      SET_SKILL (mobproto, SPELL_COLOR_SPRAY, STSP);
      SET_SKILL (mobproto, SPELL_MAGIC_MISSILE, STSP);
      SET_SKILL (mobproto, SPELL_INFRAVISION, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_INVIS, STSP);
      SET_SKILL (mobproto, SPELL_INVISIBLE, STSP);
      SET_SKILL (mobproto, SPELL_LIGHTNING_BOLT, STSP);
      SET_SKILL (mobproto, SPELL_SHOCKING_GRASP, STSP);
      SET_SKILL (mobproto, SPELL_SLEEP, STSP);
      SET_SKILL (mobproto, SPELL_STONE_SKIN, STSP);
      SET_SKILL (mobproto, SPELL_FARSEE, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_MAGIC, STSP);
      SET_SKILL (mobproto, SPELL_METEORSWARM, STSP);
      SET_SKILL (mobproto, SPELL_RAY_OF_ENFEEB, STSP);
      SET_SKILL (mobproto, SPELL_HASTE, STSP);
      SET_SKILL (mobproto, SPELL_DIMENSION_DOOR, STSP);
      SET_SKILL (mobproto, SPELL_CHARM, STSP);
      SET_SKILL (mobproto, SKILL_DODGE, MIN (70, MAX ((mobproto->player.level), 10)));
      SET_SKILL (mobproto, SKILL_MOUNT, MIN (70, MAX ((mobproto->player.level), 10)));
      SET_SKILL (mobproto, SKILL_TRACK, MIN (40, MAX ((mobproto->player.level), 5)));
      
      break;
    case MCLASS_CLERIC:
      SET_SKILL (mobproto, SPELL_PLANE_SHIFT, STSP);
      SET_SKILL (mobproto, SPELL_UNHOLY_WORD, STSP);
      SET_SKILL (mobproto, SPELL_WATERWALK, STSP);
      SET_SKILL (mobproto, SPELL_HOLY_WORD, STSP);
      SET_SKILL (mobproto, SPELL_CONTINUAL_LIGHT, STSP);
      SET_SKILL (mobproto, SPELL_SOULSHIELD, STSP);
      SET_SKILL (mobproto, SPELL_SILENCE, STSP);
      SET_SKILL (mobproto, SPELL_FLAMESTRIKE, STSP);
      SET_SKILL (mobproto, SPELL_DESTROY_UNDEAD, STSP);
      SET_SKILL (mobproto, SPELL_CAUSE_LIGHT, STSP);
      SET_SKILL (mobproto, SPELL_CURE_SERIOUS, STSP);
      SET_SKILL (mobproto, SPELL_VIGORIZE_LIGHT, STSP);
      SET_SKILL (mobproto, SPELL_BLESS, STSP);
      SET_SKILL (mobproto, SPELL_VIGORIZE_SERIOUS, STSP);
      SET_SKILL (mobproto, SPELL_VIGORIZE_CRITIC, STSP);
      SET_SKILL (mobproto, SPELL_PRESERVE, STSP);
      SET_SKILL (mobproto, SPELL_CAUSE_SERIOUS, STSP);
      SET_SKILL (mobproto, SPELL_CAUSE_CRITIC, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_POISON, STSP);
      SET_SKILL (mobproto, SPELL_ARMOR, STSP);
      SET_SKILL (mobproto, SPELL_BLINDNESS, STSP);
      SET_SKILL (mobproto, SPELL_CREATE_FOOD, STSP);
      SET_SKILL (mobproto, SPELL_CREATE_WATER, STSP);
      SET_SKILL (mobproto, SPELL_CURE_CRITIC, STSP);
      SET_SKILL (mobproto, SPELL_CURE_LIGHT, STSP);
      SET_SKILL (mobproto, SPELL_CURSE, STSP);
      SET_SKILL (mobproto, SPELL_CURE_BLIND, STSP);
      SET_SKILL (mobproto, SPELL_PROT_FROM_EVIL, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_ALIGN, STSP);
      SET_SKILL (mobproto, SPELL_SUMMON, STSP);
      SET_SKILL (mobproto, SPELL_EARTHQUAKE, STSP);
      SET_SKILL (mobproto, SPELL_VITALITY, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_MAGIC, STSP);
      SET_SKILL (mobproto, SPELL_DETECT_POISON, STSP);
      SET_SKILL (mobproto, SPELL_DISPEL_EVIL, STSP);
      SET_SKILL (mobproto, SPELL_EARTHQUAKE, STSP);
      SET_SKILL (mobproto, SPELL_HARM, STSP);
      SET_SKILL (mobproto, SPELL_HEAL, STSP);
      SET_SKILL (mobproto, SPELL_DARKNESS, STSP);
      SET_SKILL (mobproto, SPELL_VITALITY, STSP);
      SET_SKILL (mobproto, SPELL_POISON, STSP);
      SET_SKILL (mobproto, SPELL_REMOVE_CURSE, STSP);
      SET_SKILL (mobproto, SPELL_SUMMON, STSP);
      SET_SKILL (mobproto, SPELL_WORD_OF_RECALL, STSP);
      SET_SKILL (mobproto, SPELL_REMOVE_POISON, STSP);
      SET_SKILL (mobproto, SPELL_SENSE_LIFE, STSP);
      SET_SKILL (mobproto, SPELL_DISPEL_GOOD, STSP);
      SET_SKILL (mobproto, SPELL_GROUP_ARMOR, STSP);
      SET_SKILL (mobproto, SPELL_GROUP_HEAL, STSP);
      SET_SKILL (mobproto, SPELL_GROUP_RECALL, STSP);
      SET_SKILL (mobproto, SPELL_WATERWALK, STSP);
      SET_SKILL (mobproto, SPELL_FULL_HARM, STSP);
      SET_SKILL (mobproto, SPELL_FULL_HEAL, STSP);
      SET_SKILL (mobproto, SKILL_DODGE, MIN (80, MAX ((mobproto->player.level * 2), 10)));
      SET_SKILL (mobproto, SKILL_RIDING, MIN (80, MAX ((mobproto->player.level), 10)));
      SET_SKILL (mobproto, SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
      SET_SKILL (mobproto, SKILL_MOUNT, MIN (80, MAX ((mobproto->player.level), 10)));
      SET_SKILL (mobproto, SKILL_TRACK, MIN (50, MAX ((mobproto->player.level), 5)));
      
      break;
      
    case MCLASS_THIEF:
      SET_SKILL (mobproto, SKILL_SNEAK, STSK);
      SET_SKILL (mobproto, SKILL_HIDE, STSK);
      SET_SKILL (mobproto, SKILL_STEAL, STSK);
      SET_SKILL (mobproto, SKILL_BACKSTAB, MIN (100, MAX ((((mobproto->player.level) * 3)), 10)));
      SET_SKILL (mobproto, SKILL_PICK_LOCK, STSK);
      SET_SKILL (mobproto, SKILL_TRACK, MIN (75, MAX ((((mobproto->player.level) * 2)), 10)));
      SET_SKILL (mobproto, SKILL_CIRCLE, STSK);
      SET_SKILL (mobproto, SKILL_TAME, STSK);
      SET_SKILL (mobproto, SKILL_DODGE, STSK);
      SET_SKILL (mobproto, SKILL_MOUNT, STSK);
      SET_SKILL (mobproto, SKILL_RIDING, STSK);
      SET_SKILL (mobproto, SKILL_PARRY, STSK);
      SET_SKILL (mobproto, SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
      SET_SKILL (mobproto, SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
      break;
      
    case MCLASS_WARRIOR:
      SET_SKILL (mobproto, SKILL_DOUBLE_ATTACK, STSK);
      SET_SKILL (mobproto, SKILL_DUAL_WIELD, STSK);
      SET_SKILL (mobproto, SKILL_BASH, STSK);
      SET_SKILL (mobproto, SKILL_KICK, STSK);
      SET_SKILL (mobproto, SKILL_RESCUE,
		  MIN (85, MAX ((mobproto->player.level) * 2, 10)));
      SET_SKILL (mobproto, SKILL_GUARD, STSK);
      SET_SKILL (mobproto, SKILL_TRACK,
		  MIN (70, MAX ((((mobproto->player.level) * 2)), 10)));
      SET_SKILL (mobproto, SKILL_DODGE, STSK);
      SET_SKILL (mobproto, SKILL_RIPOST,
		  MIN (60, MAX ((mobproto->player.level) * 1, 10)));
      SET_SKILL (mobproto, SKILL_PARRY, STSK);
      break;
      
    case MCLASS_MERCENARY:
      SET_SKILL (mobproto, SKILL_DOUBLE_ATTACK, STSK);
      SET_SKILL (mobproto, SKILL_DUAL_WIELD, STSK);
      SET_SKILL (mobproto, SKILL_BASH, STSK); 
      SET_SKILL (mobproto, SKILL_KICK, STSK);
      SET_SKILL (mobproto, SKILL_RESCUE, 
		  MIN (85, MAX ((mobproto->player.level) * 2, 10)));
      SET_SKILL (mobproto, SKILL_GUARD, STSK);
      SET_SKILL (mobproto, SKILL_TRACK, 
		  MIN (70, MAX ((((mobproto->player.level) * 2)), 10)));
      SET_SKILL (mobproto, SKILL_DODGE, STSK);
      SET_SKILL (mobproto, SKILL_PARRY, STSK);
      SET_SKILL (mobproto, SKILL_HIDE, STSK);
      SET_SKILL (mobproto, SKILL_BACKSTAB, STSK); 
      break;
      
    case MCLASS_ASSASSIN:
      SET_SKILL (mobproto, SKILL_SNEAK, STSK);
      SET_SKILL (mobproto, SKILL_KICK, (mobproto->player.level > 35) ? MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)) : 0);
      SET_SKILL (mobproto, SKILL_THROATCUT, STSK);
      SET_SKILL (mobproto, SKILL_HIDE, STSK);
      SET_SKILL (mobproto, SKILL_STEAL, STSK);
      SET_SKILL (mobproto, SKILL_BACKSTAB, STSK);
      SET_SKILL (mobproto, SKILL_PICK_LOCK, STSK);
      SET_SKILL (mobproto, SKILL_TRACK, MIN (85, MAX ((((mobproto->player.level) * 2)), 10)));
      
      SET_SKILL (mobproto, SKILL_CIRCLE, STSK);
      SET_SKILL (mobproto, SKILL_TAME, STSK);
      SET_SKILL (mobproto, SKILL_DODGE, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
      SET_SKILL (mobproto, SKILL_MOUNT, STSK);
      SET_SKILL (mobproto, SKILL_RIDING, STSK);
      SET_SKILL (mobproto, SKILL_PARRY, STSK);
      SET_SKILL (mobproto, SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
      SET_SKILL (mobproto, SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mobproto->player.level) * 1.5)), 10)));
    default:
      SET_SKILL (mobproto, SKILL_TRACK, MIN (75, MAX ((((mobproto->player.level) * 2)), 10)));
      
      break;
      
    }
}
*/
/* Moved aggresive mob code and old memory code here cause
   pulse mobile_act was to slow for proper agressive and aggro mobs
   also original intent was to code trackers Banyal */

void 
mobile_spec_activity (void)
{
d410 67
a476 18
  for (ch = character_list; ch; ch = next_ch)
    {
      next_ch = ch->next;
      if (!IS_MOB (ch) || FIGHTING (ch) || !AWAKE (ch))
	continue;
      if (ch->desc && ch->desc->original)
	continue;
      if (MOB_FLAGGED (ch, MOB_CASTING))
	continue;
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
	continue;
      if (IS_FIGHTING (ch))
	continue;
      /*if mob not fighting still decrease wait state */
      if ((GET_MOB_WAIT (ch) > 0))
	{
	  WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE)), 0))
	    continue;
d478 10
a487 13
      
      /*pets banyal */
      
      if (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))
	{
	  found = FALSE;
	  for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    if (ch != vict && (ch->master == vict) && FIGHTING (vict) && ch != FIGHTING (vict))
	      {
		act ("&7$n assist $s master!!&0", FALSE, ch, 0, vict, TO_ROOM);
		hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
		found = TRUE;
	      }
d489 29
a517 57
      
      
      /* Aggressive Mobs */
      /* Mobs are now aggressive to each other!!! */
      /* --Fingon                                 */

      if (MOB_FLAGGED (ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN))
	{
	  found = FALSE;
	  for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    {
	      if (ch == vict)
		continue;
	      if (!(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
		continue;
	      if (MOB_FLAGGED (ch, MOB_WIMPY) && AWAKE (vict))
		continue;
	      if ((IS_AFFECTED (ch, AFF_CHARM)))
		if (ch->master)
		  {
		    if (ch->master == vict)
		      continue;
		    if ((ch->in_room) == (ch->master->in_room))
		      {
			continue;
		      }
		    if (is_grouped (ch, vict))
		      {
			continue;
		      }
		  }
	      
	      
              if (((MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
		   GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL) ||
		  (MOB_FLAGGED (ch, MOB_AGGR_GOOD_ALIGN) &&
		   GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)) &&
                   (!IS_NPC(vict))) {
		  class_operator (ch, vict);	/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		    hit (ch, vict, TYPE_UNDEFINED);
		  found = TRUE;
		  WHYTRACK = TRUE;
              }

	      if (((MOB_FLAGGED (ch, MOB_AGGRESSIVE)) ||
		   (MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
		   (MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
		   (MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict))))
		{
		  class_operator (ch, vict);	/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		    hit (ch, vict, TYPE_UNDEFINED);
		  found = TRUE;
		  WHYTRACK = TRUE;
		}
	    }
d519 8
a526 2
      if (MOB_FLAGGED (ch, MOB_ARRESTOR) && (!MEMORY (ch)))
	extract_char (ch);
d528 23
a550 30
      
      /* Mob Memory */
      if ((MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch)) &&
	  (MOB_FLAGGED (ch, MOB_WIMPY) &&
	   (GET_HIT (ch) < (GET_MAX_HIT (ch) >> 2))))
	{
	  found = FALSE;
	  for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	    {
	      if (IS_NPC (vict) || !CAN_SEE (ch, vict) || PRF_FLAGGED (vict, PRF_NOHASSLE))
		continue;
	      for (names = MEMORY (ch); names && !found; names = namestmp)
		namestmp = names->next;
	      if (names && names->id == GET_IDNUM (vict))
		{
		  found = TRUE;
		  WHYTRACK = TRUE;
		  if (!MOB_FLAGGED (ch, MOB_ARRESTOR))	/*is he here to kill or arrest Banyal */
		    {
		      class_operator (ch, vict);	/*hit with special type if got one */
		      if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
			hit (ch, vict, TYPE_UNDEFINED);
		    }
		  else
		    {
		      perform_arrest (vict);
		      forget (ch, vict);
		      extract_char (ch);
		    }
		  continue;
d552 1
d554 2
d557 10
a566 5
      
      if (GET_CLASS (ch) == MCLASS_CLERIC)
	if (((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) < 95)
	  {
	    mob_heal_up (ch);
d569 9
a577 34
      
      /*remove anyone without memory or not flagged memory */
      if ((!MOB_FLAGGED (ch, MOB_MEMORY)) || (!MEMORY (ch)))
	continue;
      
      /*Check maybe he wants to summon target */
      if (GET_MSKILL (ch, SPELL_SUMMON))
	{
	  if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
	    for (d = descriptor_list; d; d = next_d)
	      {
		if (STATE (d) != CON_PLAYING)
		  {
		    next_d = d->next;
		    continue;
		  }
		next_d = d->next;
		if (GET_LEVEL (d->character) > LVL_IMMORT)
		  continue;
		for (names = MEMORY (ch); names && !found; names = names->next)
		  if (names->id == GET_IDNUM (d->character))
		    {
		      if ((GET_MSKILL (ch, SPELL_SUMMON)))
			{
			  a = 0;
			  a = SPELL_CIRCLE (SPELL_SUMMON);
			  if (can_summon (ch, d->character))
			    {
			      hascast = TRUE;
			      break;
			    }
			}
		    }
		if (hascast)
d579 9
a587 15
	      }
	}
      if (hascast)
	continue;
      
      /*try to dim to him or relocate */
      if (((GET_MSKILL (ch, SPELL_DIMENSION_DOOR))) || ((GET_MSKILL (ch, SPELL_RELOCATE))))
	{
	  if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
	    for (d = descriptor_list; d; d = next_d)
	      {
		if (STATE (d) != CON_PLAYING)
		  {
		    next_d = d->next;
		    continue;
d589 4
a592 30
		
		next_d = d->next;
		if (d->character && GET_LEVEL (d->character) > LVL_IMMORT)
		  continue;
		for (names = MEMORY (ch); names && !found; names = names->next)
		  if (names->id == GET_IDNUM (d->character))
		    {
		      if ((GET_MSKILL (ch, SPELL_DIMENSION_DOOR)))
			if (can_dim (ch, d->character))
			  {
			    
			    hascast = TRUE;
			    break;
			  }
		      /*if real high try relocate */
		      a = 0;
		      a = SPELL_CIRCLE (SPELL_RELOCATE);
		      if ((GET_MSKILL (ch, SPELL_RELOCATE)))
			if (GET_LEVEL (ch) > 60)
			  if (try_cast (ch, d->character, a, SPELL_RELOCATE))
			    {
			      
			      hascast = TRUE;
			      break;
			    }
		    }
		if (hascast)
		  break;
		
	      }
d594 21
a614 27
      if (hascast)
	continue;
      /*Fast track Banyal */
      if (WHYTRACK == FALSE)
	{
// To temporarly make fast track = slow track we'll make a dummy staement here
// remove && FLAGGED( SLOW_TRACK) to make it normal again
	  if (MOB_FLAGGED (ch, MOB_FAST_TRACK) && MOB_FLAGGED(ch, MOB_SLOW_TRACK))
	    {
	      if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
		{
		  
		  for (d = descriptor_list; d; d = next_d)
		    {
		      if (STATE (d) != CON_PLAYING)
			{
			  next_d = d->next;
			  continue;
			}
		      
		      next_d = d->next;
		      for (names = MEMORY (ch); names && !found; names = names->next)
			{
			  if (d->character && names->id == GET_IDNUM (d->character))
			    {
			      cmd_track = find_command ("DumbMobTrack");
			      do_DumbMobTrack (ch, d->character->player.name, cmd_track,0);
d616 4
a619 10
			      if (d->character->in_room == ch->in_room)
				{
				  class_operator (ch, d->character);	/*hit with special type if got one */
				  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING(ch)))
				    hit (ch, d->character, TYPE_UNDEFINED);
				}
			      return;
			    }
			}
		    }
d621 2
d624 1
d626 1
d628 1
d632 3
a635 4
void 
class_operator (struct char_data *ch, struct char_data *victim)
{
  
d644 39
a682 66
  if((GET_RACE(ch) != SPECIES_DRAGON) && (GET_RACE(ch) != SPECIES_DEMON))
    switch (GET_CLASS (ch))
      {
      case MCLASS_WARRIOR:
      case MCLASS_MERCENARY:
	sel_warrior_mob_spells (ch, victim);
	break;
      case MCLASS_CLERIC:
	sel_cleric_mob_spells (ch, victim);
	break;
      case MCLASS_SORCERER:
	victim = lowest_hp_in_group (ch, victim);
	sel_mage_mob_spells (ch, victim);
	break;
      case MCLASS_ASSASSIN:
      case MCLASS_THIEF:
	sel_thief_mob_spells (ch, victim);
	break;
      default:
	break;
	
      }
  if (GET_RACE(ch) == SPECIES_DRAGON) // when others done change to dragon_
    switch (GET_CLASS (ch))
      {
      case MCLASS_WARRIOR:
      case MCLASS_MERCENARY:
	dragon_sel_warrior_mob_spells (ch, victim);
	break;
      case MCLASS_CLERIC:
	sel_cleric_mob_spells (ch, victim);
	break;
      case MCLASS_SORCERER:
	victim = lowest_hp_in_group (ch, victim);
	dragon_sel_mage_mob_spells (ch, victim);
	break;
      case MCLASS_ASSASSIN:
      case MCLASS_THIEF:
	sel_thief_mob_spells (ch, victim);
	break;
      default:
	break;
	
      }    
  if (GET_RACE(ch) == SPECIES_DEMON) // when others done change to demon_
    switch (GET_CLASS (ch))
      {
      case MCLASS_WARRIOR:
      case MCLASS_MERCENARY:
	demon_sel_warrior_mob_spells (ch, victim);
	break;
      case MCLASS_CLERIC:
	sel_cleric_mob_spells (ch, victim);
	break;
      case MCLASS_SORCERER:
	victim = lowest_hp_in_group (ch, victim);
	demon_sel_mage_mob_spells (ch, victim);
	break;
      case MCLASS_ASSASSIN:
      case MCLASS_THIEF:
	sel_thief_mob_spells (ch, victim);
	break;
      default: 
	break;
	
      }
d685 2
a686 4

int 
try_cast (struct char_data *ch, struct char_data *victim, int spells_circle, int spellnum)
{
d691 1
a691 1

d693 3
a695 9
    if (GET_POS (ch) < POS_FIGHTING)
      {
	cmd_stand = find_command ("stand");
	do_stand (ch, "",
		  cmd_stand, 0);
      }
  if (AFF2_FLAGGED (ch, AFF2_SILENCE))
    {
      return 0;
d697 3
d704 2
a705 2
  if ((GET_MEM_STATE (ch, spells_circle) == 1) && (GET_MEM_MEMED (ch, spells_circle) ==
						   spells_of_circle[(int) GET_LEVEL (ch)][(int) spells_circle]))
d707 6
a712 5
  if ((GET_MEM_MEMED (ch, spells_circle) > 0) && (GET_MEM_STATE (ch, spells_circle) != 1))
    {
      mob_cast (ch, victim, spellnum);
      return 1;
    }
d716 6
a721 4

void 
perform_mob_violence (void)
{
d725 24
a748 36
  /* This function is called each second to check if mob ready to do a special 
     attack PLEASE DO NOT CHANGE IT IT IS VERY VERY TOUCHY!!
     - if you wish to change mob activity change class_opperator
     Proky
  */
  for (ch = combat_list; ch; ch = next_combat_list)
    {
      next_combat_list = ch->next_fighting;
      
      if (FIGHTING (ch) == NULL || ch->in_room != FIGHTING (ch)->in_room)
	{
	  stop_fighting (ch);
	  continue;
	}
      if (IS_NPC (ch) && !(ch->desc && ch->desc->original))
	{
	  if ((FIGHTING (ch)) && (GET_POS (ch) > POS_FIGHTING))
	    GET_POS (ch) = POS_FIGHTING;
	  /*Stand mob up if no pause */
	  if (GET_MOB_WAIT (ch) > 0)
	    WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE / 2)), 0))
	      else
		{
		  if (!(GET_MOB_WAIT (ch) > 0))
		    {
		      if (GET_POS (ch) < POS_FIGHTING)
			{
			  GET_POS (ch) = POS_FIGHTING;
			  act ("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
			  return;
			}
		      victim = FIGHTING (ch);
		      class_operator (ch, victim);
		    }
		}
	}
d750 1
d753 1
a753 3
void 
casting_gain (void)
{
d759 10
a768 13
  for (i = character_list; i; i = next_char)
    {
      next_char = i->next;
      /*npc only */
      if (IS_NPC (i))
	{
	  var = 0;
	  circle = 0;
	  while (var < GET_LEVEL (i))
	    {
	      circle++;
	      var = circle * 5 + 1;
	    }
d776 1
a776 2
	  for (; circle >= 0; circle--)
	    {
d778 4
a781 5
	      if ((i)->mob_specials.mem_memed[circle] < spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)])
		{
		  (i)->mob_specials.mem_memed[circle] = MIN (((i)->mob_specials.mem_memed[circle] + 3),
							     (spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)]));
		}
d783 1
a783 1
	}
d785 1
d790 1
a790 2
bool is_aggr_to_trackee (struct char_data *ch, struct char_data *target)
{     
d818 1
a818 2
bool is_aggr_to (struct char_data *ch, struct char_data *target)
{
d834 16
a849 25
  if (IS_NPC (ch))
    {
      
      
      /* after the above check, we are dealing with a pet or a PC */
      
      
      
      /* if target in memory, then it acts as if it's agg, even if it's not
       */
      if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
	  mem_inMemory (ch, target))
	return TRUE;
      
      if (!MOB_FLAGGED (ch, MOB_NOVICIOUS))
	return TRUE;
      
      /* not trigger, so it's not aggr */
      return TRUE; /*should be false but changed to true for a test*/
      
    }
  else
    {
      
      if (!IS_NPC (target))
a851 1
      
d855 5
a859 6
      if (!PRF_FLAGGED (ch, PRF_VICIOUS))
	{
	  if (!AWAKE (target) || IS_AFFECTED2 (target, AFF2_MINOR_PARALYSIS) ||
	      IS_AFFECTED (target, AFF_MAJOR_PARA))
	    return FALSE;
	}
d864 1
a864 1
    }
a868 3

/* mobact.c */

d872 1
a872 3
int 
mem_inMemory (struct char_data *ch, struct char_data *vict)
{
d880 4
a883 5
    if (names->id == GET_IDNUM (vict))
      {
	found = TRUE;
	return 1;
      }
d889 13
a901 16
/*This function checks mobs for spell ups */
/*if fighting exit */
void 
check_mob_status (register struct char_data *ch)
{
  switch (GET_CLASS (ch))
    {
    case MCLASS_SORCERER:
      check_sor_status (ch);
      break;
    case MCLASS_CLERIC:
      check_cler_status (ch);
      break;
    default:
      break;
    }
d905 1
a905 3
bool 
update_inv (struct char_data *ch, struct obj_data *obj, int where)
{
d913 10
a922 3
  else
    {
      if (!CAN_WEAR (obj, ITEM_WEAR_WIELD) && !CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
d924 2
a925 1
      if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
d927 18
a944 41
      else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
	return TRUE;
      else if ((!wielding) && (!hwielding))
	{
	  if (CAN_WEAR (obj, ITEM_WEAR_WIELD))
	    {
	      perform_wear (ch, obj, WEAR_WIELD);
	      return TRUE;
	    }
	  else if (CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
	    {
	      perform_wear (ch, obj, WEAR_2HWIELD);
	      return FALSE;
	    }
	}
      else
	{
	  if (GET_MSKILL (ch, SKILL_DUAL_WIELD))
	    {
	      struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
	      struct obj_data *wielding2 = GET_EQ (ch, WEAR_WIELD2);
	      struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);
	      
	      if (wielding)
		{
		  if (!CAN_WEAR (obj, ITEM_WEAR_WIELD))
		    return FALSE;
		  if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
		    return FALSE;
		  else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
		    return FALSE;
		  else if (!wielding2)
		    {
		      perform_wear (ch, obj, WEAR_WIELD2);
		      return TRUE;
		    }
		  
		}
	    }
	  
	  
d946 1
d948 1
d953 1
a953 3
int 
CountToughness (struct char_data *ch, struct char_data *victim)
{
d976 1
a976 3
struct char_data *
picktarget (struct char_data *ch)
{
d992 11
a1002 16
  for (t_ch = world[ch->in_room].people; t_ch; t_ch = t_ch->next_in_room)
    {
      if (t_ch == ch)
	continue;
      if (!is_aggr_to (ch, t_ch))
	continue;
      if (a < MAX_TARGETS)
	{
	  target_table[a] = CountToughness (ch, t_ch);
	  target_addr[a] = t_ch;
	  target_table[a + 1] = -1;
	  target_addr[a + 1] = NULL;
	  a++;
      }
      else
	break;
d1004 3
d1030 1
a1030 2
void Forgive_The_Basterd(struct char_data *ch)
{
d1033 10
a1042 15
  
  for (co = character_list; co; co = next_co)
    {
      next_co = co->next;
      
      if (!IS_MOB (co))
	continue;
      if ((!MOB_FLAGGED (co, MOB_MEMORY)) && (!MEMORY (co)))
	continue;
      if (co == ch)
	continue;
      if (co->desc && co->desc->original)
	continue;
      else
	forget(co, ch);
d1044 4
a1047 1
    }
@


1.8
log
@Temporarly make fast track = slow track
@
text
@d455 2
d459 1
a459 2
void 
set_mob_skills (int i, int class, int race)
d461 4
d468 8
a475 8
      SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
      SET_MSKILL (mob_proto[i], SKILL_SWEEP, STSK);
      SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
      SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
d478 7
a484 7
      SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
      SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
      SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
d494 40
a533 40
      SET_MSKILL (mob_proto[i], SPELL_COMPREHEND_LANG, STSP);
      SET_MSKILL (mob_proto[i], SPELL_TELEPORT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISINTEGRATE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MASS_INVIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MINOR_GLOBE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MAJOR_GLOBE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HARNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_RELOCATE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHAIN_LIGHTNING, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIRESHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_COLDSHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ICE_STORM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ICE_SHARDS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MINOR_PARALYSIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_TELEPORT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BIGBYS_CLENCHED_FIST, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BURNING_HANDS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHILL_TOUCH, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FIREBALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_COLOR_SPRAY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_MAGIC_MISSILE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_INFRAVISION, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_INVIS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_INVISIBLE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BOLT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SHOCKING_GRASP, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SLEEP, STSP);
      SET_MSKILL (mob_proto[i], SPELL_STONE_SKIN, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FARSEE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_METEORSWARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_RAY_OF_ENFEEB, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HASTE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DIMENSION_DOOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CHARM, STSP);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (70, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, MIN (70, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (40, MAX ((mob_proto[i].player.level), 5)));
d537 58
a594 58
      SET_MSKILL (mob_proto[i], SPELL_PLANE_SHIFT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_UNHOLY_WORD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WATERWALK, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HOLY_WORD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CONTINUAL_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SOULSHIELD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SILENCE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FLAMESTRIKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DESTROY_UNDEAD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BLESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VIGORIZE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_PRESERVE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_SERIOUS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CAUSE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_ARMOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_BLINDNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CREATE_FOOD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CREATE_WATER, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_CRITIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_LIGHT, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURSE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_CURE_BLIND, STSP);
      SET_MSKILL (mob_proto[i], SPELL_PROT_FROM_EVIL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_ALIGN, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SUMMON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_EARTHQUAKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VITALITY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_MAGIC, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DETECT_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_EVIL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_EARTHQUAKE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DARKNESS, STSP);
      SET_MSKILL (mob_proto[i], SPELL_VITALITY, STSP);
      SET_MSKILL (mob_proto[i], SPELL_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_REMOVE_CURSE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SUMMON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WORD_OF_RECALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_REMOVE_POISON, STSP);
      SET_MSKILL (mob_proto[i], SPELL_SENSE_LIFE, STSP);
      SET_MSKILL (mob_proto[i], SPELL_DISPEL_GOOD, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_ARMOR, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_GROUP_RECALL, STSP);
      SET_MSKILL (mob_proto[i], SPELL_WATERWALK, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FULL_HARM, STSP);
      SET_MSKILL (mob_proto[i], SPELL_FULL_HEAL, STSP);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (80, MAX ((mob_proto[i].player.level * 2), 10)));
      SET_MSKILL (mob_proto[i], SKILL_RIDING, MIN (80, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, MIN (80, MAX ((mob_proto[i].player.level), 10)));
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (50, MAX ((mob_proto[i].player.level), 5)));
d599 14
a612 14
      SET_MSKILL (mob_proto[i], SKILL_SNEAK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_STEAL, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, MIN (100, MAX ((((mob_proto[i].player.level) * 3)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_PICK_LOCK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (75, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_CIRCLE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TAME, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIDING, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
d616 13
a628 13
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BASH, STSK);
      SET_MSKILL (mob_proto[i], SKILL_KICK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RESCUE,
		  MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
      SET_MSKILL (mob_proto[i], SKILL_GUARD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK,
		  MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIPOST,
		  MIN (60, MAX ((mob_proto[i].player.level) * 1, 10)));
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
d632 13
a644 13
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BASH, STSK); 
      SET_MSKILL (mob_proto[i], SKILL_KICK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RESCUE, 
		  MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
      SET_MSKILL (mob_proto[i], SKILL_GUARD, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK, 
		  MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DODGE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, STSK); 
d648 17
a664 17
      SET_MSKILL (mob_proto[i], SKILL_SNEAK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_KICK, (mob_proto[i].player.level > 35) ? MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)) : 0);
      SET_MSKILL (mob_proto[i], SKILL_THROATCUT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_HIDE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_STEAL, STSK);
      SET_MSKILL (mob_proto[i], SKILL_BACKSTAB, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PICK_LOCK, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (85, MAX ((((mob_proto[i].player.level) * 2)), 10)));
      
      SET_MSKILL (mob_proto[i], SKILL_CIRCLE, STSK);
      SET_MSKILL (mob_proto[i], SKILL_TAME, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DODGE, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_MOUNT, STSK);
      SET_MSKILL (mob_proto[i], SKILL_RIDING, STSK);
      SET_MSKILL (mob_proto[i], SKILL_PARRY, STSK);
      SET_MSKILL (mob_proto[i], SKILL_DOUBLE_ATTACK, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
      SET_MSKILL (mob_proto[i], SKILL_DUAL_WIELD, MIN (70, MAX (((int) ((mob_proto[i].player.level) * 1.5)), 10)));
d666 1
a666 1
      SET_MSKILL (mob_proto[i], SKILL_TRACK, MIN (75, MAX ((((mob_proto[i].player.level) * 2)), 10)));
d672 1
@


1.7
log
@Mob fighting fixes
@
text
@d286 2
a287 1
	  if (MOB_FLAGGED (ch, MOB_SLOW_TRACK)) 
d904 3
a906 1
	  if (MOB_FLAGGED (ch, MOB_FAST_TRACK))
@


1.6
log
@Mobs don't atack each other...only if AGGR_ALIGN.
@
text
@d748 1
a748 1
              if ((MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
d751 2
a752 1
		   GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)) {
d763 1
a763 2
		   (MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict))) &&
                   (!IS_NPC(vict)))
@


1.5
log
@Allows flying mobs to wander.
@
text
@d748 2
a749 6
	      if ((MOB_FLAGGED (ch, MOB_AGGRESSIVE)) ||
		  (MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
		  (MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
		  (MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict)) ||
		  (MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
		   (GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL)) ||
d751 13
a763 1
		   (GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)))
@


1.4
log
@mobs nolonger try_cast in NOMAGIC rooms.
@
text
@d226 1
a226 1
      if (!MOB_FLAGGED (ch, MOB_SENTINEL) && (GET_POS (ch) == POS_STANDING) &&
@


1.3
log
@Made mobs aggressive to each other.
fingon
@
text
@d1020 3
@


1.2
log
@Added a standard comment header
Indented the entire file
took out some ranges of blank space
@
text
@d718 3
d726 3
a728 1
	      if (IS_NPC (vict) || !(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
d748 1
a748 1
	      if (!MOB_FLAGGED (ch, MOB_AGGR_TO_ALIGN) ||
@


1.1
log
@Initial revision
@
text
@d1 11
a11 11
  /***************************************************************************
   *   File: mobact.c                                      Part of HubisMUD  *
   *  Usage: Functions for generating intelligent behavior in mobiles        *
   *  This file is no more than a conductor to the other mob AI files        *
   *  All rights reserved.  See license.doc for complete information.        *
   *                                                                         *
   *       Redesigned by Proky                                               *
   *                                                                         *
   *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
   *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
   ************************************************************************ */
d58 1
a58 1
	 struct char_data *actor, struct obj_data *obj, void *vo, int type);
d70 12
a81 12
   register struct char_data *ch, *next_ch, *vict;
//   struct char_data *i;
   struct obj_data *obj, *best_obj, *x;
   int door, found = FALSE, max, hurm;
   int cmd_track, where;
   struct descriptor_data *d, *next_d;
   memory_rec *names;
   extern int no_specials;

   ACMD (do_get);
   for (ch = character_list; ch; ch = next_ch)
   {
d84 3
a86 3
      {
	 special_update (ch);
      }
d88 3
a90 3
      {
	 el_passage (ch);
      }
d92 3
a94 3
      {
	 el_passage (ch);
      }
d96 3
a98 3
      {
	 el_passage (ch);
      }
d100 3
a102 3
      {
	 el_passage (ch);
      }
d104 3
a106 3
      {
	 el_passage (ch);
      }
d108 3
a110 3
      {
	 el_passage (ch);
      }
d112 3
a114 3
      {
	 el_passage (ch);
      }
d116 4
a119 4
      {
	 el_passage (ch);
      }

d121 3
a123 3
	 continue;
     if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA))
         continue;
d125 1
a125 1
	 continue;
d129 1
a129 1
	 continue;
d132 2
a133 2
	 if (GET_DEFAULT_POS (ch) == POS_STANDING)
	    if (GET_MOB_WAIT (ch) <= 0)
d135 3
a137 3
	       max = find_command ("stand");
	       do_stand (ch, "", max, 0);
	       max = 0;
d139 1
a139 1

d141 15
a155 15
      {
	 if (mob_index[GET_MOB_RNUM (ch)].func == NULL)
	 {
	    sprintf (buf, "%s (#%d): Attempting to call non-existing mob func",
		     GET_NAME (ch), GET_MOB_VNUM (ch));
	    log (buf);
	    REMOVE_BIT (MOB_FLAGS (ch), MOB_SPEC);
	 }
	 else
	 {
	    if ((mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, ""))
	       continue;	/* go to next char */
	 }
      }

d157 1
a157 1
	 mprog_random_trigger (ch);
d160 2
a161 12
      {
	 if (world[ch->in_room].contents && !number (0, 1))
	 {
	    max = 0;
	    best_obj = NULL;
	    for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
	       if (CAN_GET_OBJ (ch, obj) && GET_OBJ_COST (obj) > max)
	       {
		  best_obj = obj;
		  max = GET_OBJ_COST (obj);
	       }
	    if (best_obj != NULL)
d163 14
a176 3
	       obj_from_room (best_obj);
	       obj_to_char (best_obj, ch);
	       act ("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM);
d178 2
a179 5
	 }
	 /*if stuff in inventry check to use it */
	 for (obj = ch->carrying; obj; obj = obj->next_content)
	 {
	    if (CAN_SEE_OBJ (ch, obj))
d181 38
a218 33
	       where = find_eq_pos (ch, obj, 0);
	       if (GET_EQ (ch, where))
	       {
		  if (where >= 0)
		  {
		     x = GET_EQ (ch, where);
		     if (GET_OBJ_COST (x) >= GET_OBJ_COST (obj))
			continue;
		     else
		     {
			perform_remove (ch, where);
			perform_wear (ch, obj, where);
			continue;
		     }
		     /*perform_wear(ch, obj, where); */
		  }
	       }
	       else
	       {
		  if (where >= 0)
		  {
		     perform_wear (ch, obj, where);
		     continue;
		  }
	       }
	       /*where = -1, bag or weopon or type */
	       if (!(update_inv (ch, obj, where)))	/*try it */
		  if (check_weopeon_value (ch, obj))
		  {
		     mob_remove_weopon (ch, obj, where);
		     if (!(update_inv (ch, obj, where)))
			mudlog ("Mob Coudnt Update with weopoen exchange - Proky.", NRM, LVL_GOD, FALSE);
		  }
d220 5
a224 8


	 }
      }




d228 1
a228 1
	!ROOM_FLAGGED (EXIT (ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH) &&
d230 5
a234 5
	 (world[EXIT (ch, door)->to_room].zone == world[ch->in_room].zone)))
      {
	 perform_move (ch, door, 1);
      }

d237 17
a253 17
      {
	 MPROG_ACT_LIST *tmp_act, *tmp2_act;

	 for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp_act->next)
	 {
	    mprog_wordlist_check (tmp_act->buf, ch, tmp_act->ch, tmp_act->obj, tmp_act->vo, ACT_PROG);
	    free (tmp_act->buf);
	 }
	 for (tmp_act = ch->mpact; tmp_act != NULL; tmp_act = tmp2_act)
	 {
	    tmp2_act = tmp_act->next;
	    free (tmp_act);
	 }
	 ch->mpactnum = 0;
	 ch->mpact = NULL;
      }

d256 3
a258 3
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
d261 2
a262 32
	    {
	       if (GET_LEVEL (FIGHTING (vict)) > 20)
	       {

		  act ("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
		  class_operator (ch, FIGHTING (vict));		/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		     hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
		  found = TRUE;
	       }
	       else
	       {
		  hurm = number (1, 10);
		  if (hurm == 1)
		     act ("$n watches the battle in amusment.", FALSE, ch, 0, vict, TO_ROOM);
		  if (hurm == 2)
		     act ("$n chuckles at your as $e watches the fight", FALSE, ch, 0, vict, TO_ROOM);
		  if (hurm == 3)
		     act ("$n takes note of your battle tatics.", FALSE, ch, 0, vict, TO_ROOM);
	       }
	    }
      }
/* Added fast to slow till bug is fixed Banyal*/
      if (!MOB_FLAGGED (ch, MOB_SENTINEL))
      {				/*slow track Banyal */
	 if (MOB_FLAGGED (ch, MOB_SLOW_TRACK)) 
	 {
	    if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
	    {
	       for (d = descriptor_list; d; d = next_d)
	       {
		  if (STATE (d) != CON_PLAYING)
d264 6
a269 2
		     next_d = d->next;
		     continue;
d271 1
a271 3
		  next_d = d->next;

		  for (names = MEMORY (ch); names && !found; names = names->next)
d273 20
a292 5
		     if (names->id == GET_IDNUM (d->character))
		     {
			cmd_track = find_command ("DumbMobTrack");
			do_DumbMobTrack (ch, d->character->player.name, cmd_track, 0);
			if (d->character->in_room == ch->in_room)
d294 2
a295 3
			   class_operator (ch, d->character);	/*hit with special type if got one */
			   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
			      hit (ch, d->character, TYPE_UNDEFINED);
d297 19
a315 4
			return;
		     }
		  }
	       }
d317 3
a319 4
	 }
	 /* Add new mobile actions here */
      }
   }				/* end for() */
d331 14
a344 14
   memory_rec *tmp;
   bool present = FALSE;

   if (!IS_NPC (ch) || IS_NPC (victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
      return;
if (victim->desc && victim->desc->original)
   remember(ch, victim->desc->original);

   for (tmp = MEMORY (ch); tmp && !present; tmp = tmp->next)
      if (tmp->id == GET_IDNUM (victim))
	 present = TRUE;

   if (!present)
   {
d346 1
a346 1

d348 1
a348 1
	 tmp->next = NULL;
d352 1
a352 1
   }
d360 10
a369 10
   memory_rec *curr, *tmp = NULL;

   if (!(curr = MEMORY (ch)))
      return;

/*function re-done by Proky */
   curr = MEMORY (ch);
   /*check for top of list */
   if (curr->id == GET_IDNUM (victim))
   {
d371 1
a371 1
	 MEMORY (ch) = curr->next;
d373 1
a373 1
	 MEMORY (ch) = NULL;
d376 6
a381 6
   }
   /*middle of list or end */
   for (curr = MEMORY (ch); curr->next->id != GET_IDNUM (victim); curr = curr->next);
   tmp = curr->next;
   if (tmp)
   {
d384 1
a384 1
   }
d393 1
a393 1

d396 1
a396 1

d400 1
a400 1

d414 1
a414 1

d417 1
a417 1

d422 1
a422 1

d425 1
a425 1

d430 1
a430 1

d438 6
a443 6
   memory_rec *curr, *next;

   curr = MEMORY (ch);

   while (curr)
   {
d447 3
a449 3
   }

   MEMORY (ch) = NULL;
d459 26
a484 26
   switch (race)
   {
   case SPECIES_DRAGON:
    SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
    SET_MSKILL (mob_proto[i], SKILL_SWEEP, STSK);
    SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
    SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
    break;
   case SPECIES_DEMON:
    SET_MSKILL (mob_proto[i], SKILL_BREATH, STSK);
    SET_MSKILL (mob_proto[i], SKILL_ROAR, STSK);
    SET_MSKILL (mob_proto[i], SPELL_ACID_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FROST_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_GAS_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_FIRE_BREATH, STSP);
    SET_MSKILL (mob_proto[i], SPELL_LIGHTNING_BREATH, STSP);
    break;
   }
   switch (class)
   {
   case MCLASS_VOID:

d486 2
a487 2
   case MCLASS_SORCERER:

d528 1
a528 1

d530 1
a530 1
   case MCLASS_CLERIC:
d589 1
a589 1

d591 2
a592 2

   case MCLASS_THIEF:
d608 2
a609 2

   case MCLASS_WARRIOR:
d615 1
a615 1
 MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
d618 1
a618 1
 MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
d621 1
a621 1
 MIN (60, MAX ((mob_proto[i].player.level) * 1, 10)));
d624 2
a625 2

   case MCLASS_MERCENARY:
d631 1
a631 1
 MIN (85, MAX ((mob_proto[i].player.level) * 2, 10)));
d634 1
a634 1
 MIN (70, MAX ((((mob_proto[i].player.level) * 2)), 10)));
d640 2
a641 2

   case MCLASS_ASSASSIN:
d650 1
a650 1

d659 1
a659 1
   default:
d661 1
a661 1

d663 2
a664 2

   }
d673 11
a683 11
   register struct char_data *ch, *next_ch, *vict;
//   struct char_data *i;
   struct descriptor_data *d, *next_d;
   int found = FALSE, a;
   bool hascast = FALSE;
   memory_rec *names, *namestmp;
   int cmd_track;
   bool WHYTRACK = FALSE;

   for (ch = character_list; ch; ch = next_ch)
   {
d686 1
a686 1
	 continue;
d688 1
a688 1
	 continue;
d690 1
a690 1
	 continue;
d692 1
a692 1
         continue;
d694 1
a694 1
	 continue;
d697 2
a698 2
      {
	 WAIT_STATE (ch, MAX ((GET_MOB_WAIT (ch) - (PULSE_VIOLENCE)), 0))
d700 2
a701 2
      }

d703 1
a703 1

d705 3
a707 3
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
d709 13
d723 6
a728 23
	       act ("&7$n assist $s master!!&0", FALSE, ch, 0, vict, TO_ROOM);
	       hit (ch, FIGHTING (vict), TYPE_UNDEFINED);
	       found = TRUE;
	    }
      }


/* Aggressive Mobs */
      if (MOB_FLAGGED (ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN))
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	 {
	    if (IS_NPC (vict) || !(MCAN_SEE (ch, vict)) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	       continue;
	    if (MOB_FLAGGED (ch, MOB_WIMPY) && AWAKE (vict))
	       continue;
	    if ((IS_AFFECTED (ch, AFF_CHARM)))
	       if (ch->master)
	       {
		  if (ch->master == vict)
		     continue;
		  if ((ch->in_room) == (ch->master->in_room))
d730 10
a739 1
		     continue;
d741 17
a757 21
		  if (is_grouped (ch, vict))
		  {
		     continue;
		  }
	       }


	    if (!MOB_FLAGGED (ch, MOB_AGGR_TO_ALIGN) ||
		(MOB_FLAGGED (ch, MOB_AGGR_EVIL) && IS_EVIL (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_GOOD) && IS_GOOD (vict)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_EVIL_ALIGN) &&
		 (GET_RACE_ALIGN (vict) == RACE_ALIGN_EVIL)) ||
		(MOB_FLAGGED (ch, MOB_AGGR_GOOD_ALIGN) &&
		 (GET_RACE_ALIGN (vict) == RACE_ALIGN_GOOD)))
	    {
	       class_operator (ch, vict);	/*hit with special type if got one */
	       if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		  hit (ch, vict, TYPE_UNDEFINED);
	       found = TRUE;
	       WHYTRACK = TRUE;
d759 1
a759 2
	 }
      }
d761 3
a763 3
	 extract_char (ch);


d768 3
a770 9
      {
	 found = FALSE;
	 for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
	 {
	    if (IS_NPC (vict) || !CAN_SEE (ch, vict) || PRF_FLAGGED (vict, PRF_NOHASSLE))
	       continue;
	    for (names = MEMORY (ch); names && !found; names = namestmp)
	       namestmp = names->next;
	    if (names && names->id == GET_IDNUM (vict))
d772 22
a793 15
	       found = TRUE;
	       WHYTRACK = TRUE;
	       if (!MOB_FLAGGED (ch, MOB_ARRESTOR))	/*is he here to kill or arrest Banyal */
	       {
		  class_operator (ch, vict);	/*hit with special type if got one */
		  if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING (ch)))
		     hit (ch, vict, TYPE_UNDEFINED);
	       }
	       else
	       {
		  perform_arrest (vict);
		  forget (ch, vict);
		  extract_char (ch);
	       }
	       continue;
d795 2
a796 3
	 }
      }

d798 2
a799 2
	 if (((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) < 95)
	 {
d802 2
a803 2
	 }

d806 2
a807 2
	 continue;

d810 2
a811 2
      {
	 if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
d813 8
a820 8
	    {
	       if (STATE (d) != CON_PLAYING)
	       {
		  next_d = d->next;
		  continue;
	       }
	       next_d = d->next;
	       if (GET_LEVEL (d->character) > LVL_IMMORT)
d822 1
a822 1
	       for (names = MEMORY (ch); names && !found; names = names->next)
d824 2
a825 6
		  {
		     if ((GET_MSKILL (ch, SPELL_SUMMON)))
		     {
			a = 0;
			a = SPELL_CIRCLE (SPELL_SUMMON);
			if (can_summon (ch, d->character))
d827 7
a833 2
			   hascast = TRUE;
			   break;
d835 2
a836 3
		     }
		  }
	       if (hascast)
d838 2
a839 2
	    }
      }
d841 2
a842 2
	 continue;

d845 2
a846 2
      {
	 if ((((int) ((100 * (float) GET_HIT (ch)) / GET_MAX_HIT (ch))) > 30))
d848 9
a856 9
	    {
	       if (STATE (d) != CON_PLAYING)
	       {
		  next_d = d->next;
		  continue;
	       }

	       next_d = d->next;
	       if (d->character && GET_LEVEL (d->character) > LVL_IMMORT)
d858 1
a858 1
	       for (names = MEMORY (ch); names && !found; names = names->next)
d860 2
a861 2
		  {
		     if ((GET_MSKILL (ch, SPELL_DIMENSION_DOOR)))
d863 9
a871 9
			{

			   hascast = TRUE;
			   break;
			}
		     /*if real high try relocate */
		     a = 0;
		     a = SPELL_CIRCLE (SPELL_RELOCATE);
		     if ((GET_MSKILL (ch, SPELL_RELOCATE)))
d873 3
a875 3
			   if (try_cast (ch, d->character, a, SPELL_RELOCATE))
			   {

d878 3
a880 3
			   }
		  }
	       if (hascast)
d882 3
a884 3

	    }
      }
d886 1
a886 1
	 continue;
d889 2
a890 4
     {
	 if (MOB_FLAGGED (ch, MOB_FAST_TRACK))
	 {
	    if (MOB_FLAGGED (ch, MOB_MEMORY) && MEMORY (ch))
d892 13
a904 18

	       for (d = descriptor_list; d; d = next_d)
	       {
		  if (STATE (d) != CON_PLAYING)
		  {
		     next_d = d->next;
		     continue;
		  }

		  next_d = d->next;
		  for (names = MEMORY (ch); names && !found; names = names->next)
		  {
		     if (d->character && names->id == GET_IDNUM (d->character))
		     {
			cmd_track = find_command ("DumbMobTrack");
			do_DumbMobTrack (ch, d->character->player.name, cmd_track,0);

			if (d->character->in_room == ch->in_room)
d906 13
a918 3
			   class_operator (ch, d->character);	/*hit with special type if got one */
			   if ((!MOB_FLAGGED (ch, MOB_CASTING)) && (!FIGHTING(ch)))
			      hit (ch, d->character, TYPE_UNDEFINED);
d920 2
a921 4
			return;
		     }
		  }
	       }
d923 2
a924 3
	 }
     }
   }
d932 7
a938 7

   if (MOB_FLAGGED (ch, MOB_CASTING))
      return;
   if (MOB_FLAGGED (ch, MOB_ARRESTOR)) {
   perform_arrest (victim);
                  forget (ch, victim);
                  extract_char (ch);
d940 1
a940 1
   }
d942 65
a1006 65
   switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default:
      break;

   }
if (GET_RACE(ch) == SPECIES_DRAGON) // when others done change to dragon_
switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      dragon_sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      dragon_sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default:
      break;
      
   }    
if (GET_RACE(ch) == SPECIES_DEMON) // when others done change to demon_
switch (GET_CLASS (ch))
   {
   case MCLASS_WARRIOR:
   case MCLASS_MERCENARY:
      demon_sel_warrior_mob_spells (ch, victim);
      break;
   case MCLASS_CLERIC:
      sel_cleric_mob_spells (ch, victim);
      break;
   case MCLASS_SORCERER:
      victim = lowest_hp_in_group (ch, victim);
      demon_sel_mage_mob_spells (ch, victim);
      break;
   case MCLASS_ASSASSIN:
   case MCLASS_THIEF:
      sel_thief_mob_spells (ch, victim);
      break;
   default: 
      break;
      
   }
d1013 8
a1020 8
   int cmd_stand;

   if (GET_MOB_WAIT (ch) <= 0)
      if (GET_POS (ch) < POS_FIGHTING)
      {
	 cmd_stand = find_command ("stand");
	 do_stand (ch, "",
		   cmd_stand, 0);
d1022 2
a1023 2
   if (AFF2_FLAGGED (ch, AFF2_SILENCE))
   {
d1025 10
a1034 10
   }
   if (MOB_FLAGGED (ch, MOB_CASTING))
      return 0;
   if ((GET_MEM_STATE (ch, spells_circle) == 0) && (GET_MEM_MEMED (ch, spells_circle) == 0))
      SET_MEM_STATE (ch, spells_circle, 1);
   if ((GET_MEM_STATE (ch, spells_circle) == 1) && (GET_MEM_MEMED (ch, spells_circle) ==
	       spells_of_circle[(int) GET_LEVEL (ch)][(int) spells_circle]))
      SET_MEM_STATE (ch, spells_circle, 0);
   if ((GET_MEM_MEMED (ch, spells_circle) > 0) && (GET_MEM_STATE (ch, spells_circle) != 1))
   {
d1037 2
a1038 2
   }
   return 0;
a1041 3



d1045 10
a1054 10
   struct char_data *ch;
   struct char_data *victim;

   /* This function is called each second to check if mob ready to do a special 
      attack PLEASE DO NOT CHANGE IT IT IS VERY VERY TOUCHY!!
      - if you wish to change mob activity change class_opperator
      Proky
    */
   for (ch = combat_list; ch; ch = next_combat_list)
   {
d1056 1
a1056 1

d1058 4
a1061 4
      {
	 stop_fighting (ch);
	 continue;
      }
d1063 2
a1064 2
      {
	 if ((FIGHTING (ch)) && (GET_POS (ch) > POS_FIGHTING))
d1066 2
a1067 2
/*Stand mob up if no pause */
	 if (GET_MOB_WAIT (ch) > 0)
d1069 16
a1084 16
	       else
	 {
	    if (!(GET_MOB_WAIT (ch) > 0))
	    {
	       if (GET_POS (ch) < POS_FIGHTING)
	       {
		  GET_POS (ch) = POS_FIGHTING;
		  act ("&0&3$n scrambles to $s feet!&0", TRUE, ch, 0, 0, TO_ROOM);
		  return;
	       }
	       victim = FIGHTING (ch);
	       class_operator (ch, victim);
	    }
	 }
      }
   }
d1090 7
a1096 7
   struct char_data *i, *next_char;
   int var;
   int circle = 0;

   /* characters */
   for (i = character_list; i; i = next_char)
   {
d1100 11
a1110 11
      {
	 var = 0;
	 circle = 0;
	 while (var < GET_LEVEL (i))
	 {
	    circle++;
	    var = circle * 5 + 1;
	 }
	 var = 0;

	 if (circle > 12)
d1112 1
a1112 1
	 if (circle <= 0)
d1114 2
a1115 5
	 circle--;
	 for (; circle >= 0; circle--)
	 {

	    if ((i)->mob_specials.mem_memed[circle] < spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)])
d1117 6
a1122 2
	       (i)->mob_specials.mem_memed[circle] = MIN (((i)->mob_specials.mem_memed[circle] + 3),
		   (spells_of_circle[(int) (GET_LEVEL (i))][(circle + 1)]));
d1124 2
a1125 3
	 }
      }
   }
d1132 25
a1156 25
   /* common checks first */
         
   if ((!ch) || (!target) || (ch == target) ||
   (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
      return FALSE;
         
   if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return FALSE;
         
   /*pets now needs a master to inhibit aggression */
   if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
      return FALSE;
      
   /* now different checks for pcs/npcs */
         

    if (!IS_NPC (target) && MOB_FLAGGED (ch, MOB_MEMORY) && (MEMORY (ch) != NULL) &&
         (mem_inMemory (ch, target) && !MOB_FLAGGED (ch, MOB_NOVICIOUS)))
         return TRUE;
    
      
      /* not trigger, so it's not aggr */
      return FALSE;      
   
          
d1158 1
a1158 1
      
d1161 19
a1179 19
   /* common checks first */

   if ((!ch) || (!target) || (ch == target) || (ch->in_room != target->in_room)
   || (FIGHTING (target) != ch) || (!AWAKE (ch)) || (!CAN_SEE (ch, target)))
      return FALSE;

   if (IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return FALSE;

   /* now needs a master to inhibit aggression */
   if (IS_AFFECTED (ch, AFF_CHARM) || (IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET)))
      return FALSE;

   /* now different checks for pcs/npcs */

   if (IS_NPC (ch))
   {


d1181 3
a1183 3



d1188 2
a1189 2
	 return TRUE;

d1191 2
a1192 2
	 return TRUE;

d1195 5
a1199 5

   }
   else
   {

d1201 3
a1203 3
	 return FALSE;


d1205 2
a1206 2
	 return FALSE;

d1208 3
a1210 3
      {
	 if (!AWAKE (target) || IS_AFFECTED2 (target, AFF2_MINOR_PARALYSIS) ||
	     IS_AFFECTED (target, AFF_MAJOR_PARA))
d1212 1
a1212 1
      }
d1216 4
a1219 4
	 return TRUE;
   }

   return FALSE;
d1231 8
a1238 8
   memory_rec *names;
   bool found = FALSE;

   if (MEMORY (ch) == NULL)
      return 0;

   for (names = MEMORY (ch); names && !found; names = names->next)
      if (names->id == GET_IDNUM (vict))
d1240 2
a1241 2
	 found = TRUE;
	 return 1;
d1243 2
a1244 2

   return 0;
d1253 3
a1255 3
   switch (GET_CLASS (ch))
   {
   case MCLASS_SORCERER:
d1258 1
a1258 1
   case MCLASS_CLERIC:
d1261 1
a1261 1
   default:
d1263 1
a1263 1
   }
a1266 8








d1270 9
a1278 9
   struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
   struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);

   /*struct obj_data *wielding2 = GET_EQ(ch, WEAR_WIELD2) */

   if (!(obj))
      return FALSE;
   else
   {
d1280 1
a1280 1
	 return TRUE;
d1282 1
a1282 1
	 return FALSE;
d1284 1
a1284 1
	 return TRUE;
d1286 12
a1297 12
      {
	 if (CAN_WEAR (obj, ITEM_WEAR_WIELD))
	 {
	    perform_wear (ch, obj, WEAR_WIELD);
	    return TRUE;
	 }
	 else if (CAN_WEAR (obj, ITEM_WEAR_2HWIELD))
	 {
	    perform_wear (ch, obj, WEAR_2HWIELD);
	    return FALSE;
	 }
      }
d1299 2
a1300 8
      {
	 if (GET_MSKILL (ch, SKILL_DUAL_WIELD))
	 {
	    struct obj_data *wielding = GET_EQ (ch, WEAR_WIELD);
	    struct obj_data *wielding2 = GET_EQ (ch, WEAR_WIELD2);
	    struct obj_data *hwielding = GET_EQ (ch, WEAR_2HWIELD);

	    if (wielding)
d1302 19
a1320 12
	       if (!CAN_WEAR (obj, ITEM_WEAR_WIELD))
		  return FALSE;
	       if (CAN_WEAR (obj, ITEM_WEAR_WIELD) && (hwielding))
		  return FALSE;
	       else if (GET_OBJ_WEIGHT (obj) > str_app[STRENGTH_APPLY_INDEX (ch)].wield_w)
		  return FALSE;
	       else if (!wielding2)
	       {
		  perform_wear (ch, obj, WEAR_WIELD2);
		  return TRUE;
	       }

d1322 5
a1326 6
	 }


      }
   }
   return FALSE;
d1333 18
a1350 18
   int val, foo;

   if (!IS_NPC (ch))
      return -1;

   val = GET_HIT (victim);

   if (IS_CLERIC (victim) || IS_MAGIC_USER (victim))
      val = val * 2 / 3;
   else if (IS_WARRIOR (victim))
      val = val * 2;
   foo = MAX (0, 60 - GET_LEVEL (victim));
   if (!IS_FIGHTING (victim))
      val = val / (IS_THIEF (ch) ? 4 : 2);
   if ((IS_AFFECTED3 (victim, AFF3_AWARE)) && IS_THIEF (ch))
      val = (int) (val * 1.5);
   val = val * 100 / number (100 - foo, 100 + foo);
   return val;
d1358 17
a1374 17
   struct char_data *t_ch;
   int target_table[MAX_TARGETS + 1];
   struct char_data *target_addr[MAX_TARGETS + 1];
   int a, b, c, d, n_a;

   if (!SanityCheck (ch, "PickTarget"))
      return NULL;

   if (PLR_FLAGGED (ch, PLR_BOUND) || !AWAKE (ch) ||
       IS_AFFECTED2 (ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED (ch, AFF_MAJOR_PARA))
      return NULL;

   a = 0;
   n_a = NumAttackers (ch);

   for (t_ch = world[ch->in_room].people; t_ch; t_ch = t_ch->next_in_room)
   {
d1376 1
a1376 1
	 continue;
d1378 1
a1378 1
	 continue;
d1380 6
a1385 6
      {
	 target_table[a] = CountToughness (ch, t_ch);
	 target_addr[a] = t_ch;
	 target_table[a + 1] = -1;
	 target_addr[a + 1] = NULL;
	 a++;
d1388 59
a1446 2
	 break;
   }
a1447 2
   if (a == 0)
      return NULL;
a1448 2
   if (!IS_NPC (ch))
      return (target_addr[number (0, (a - 1))]);
a1449 10
   b = -2;
   c = -1;
   for (d = 0; d < a; d++)
      if ((target_table[d] < b) || (b == -2))
      {
	 c = d;
	 b = target_table[d];
      }
   if (c != -1)
      return target_addr[c];
a1450 3
   /* nope, no likely targets in room */
   return NULL;
}
a1452 3
void Forgive_The_Basterd(struct char_data *ch)
{
 register struct char_data *co, *next_co;
a1454 17
  for (co = character_list; co; co = next_co)
  {
       next_co = co->next;
                        
    if (!IS_MOB (co))
    continue;
  if ((!MOB_FLAGGED (co, MOB_MEMORY)) && (!MEMORY (co)))
    continue;
  if (co == ch)
   continue;
  if (co->desc && co->desc->original)
         continue;
   else
   forget(co, ch);
continue;
   }
}
@
