head	1.165;
access;
symbols;
locks; strict;
comment	@ * @;


1.165
date	2011.08.06.15.48.42;	author rsd;	state Exp;
branches;
next	1.164;

1.164
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.163;

1.163
date	2010.06.05.04.43.57;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2009.06.09.05.40.10;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2009.05.22.17.56.14;	author myc;	state Exp;
branches;
next	1.160;

1.160
date	2009.03.15.07.09.24;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2009.03.07.22.28.27;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.154;

1.154
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.153;

1.153
date	2009.01.17.01.17.33;	author myc;	state Exp;
branches;
next	1.152;

1.152
date	2009.01.16.23.36.34;	author myc;	state Exp;
branches;
next	1.151;

1.151
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.09.20.09.07.48;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2008.09.13.18.52.12;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2008.09.08.05.18.00;	author jps;	state Exp;
branches;
next	1.146;

1.146
date	2008.09.07.07.55.17;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2008.09.07.07.20.28;	author jps;	state Exp;
branches;
next	1.144;

1.144
date	2008.09.07.01.30.47;	author jps;	state Exp;
branches;
next	1.143;

1.143
date	2008.09.06.19.10.49;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2008.09.06.05.49.37;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.09.04.00.23.43;	author myc;	state Exp;
branches;
next	1.139;

1.139
date	2008.09.02.07.16.00;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2008.09.02.06.51.20;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.135;

1.135
date	2008.08.31.22.16.21;	author myc;	state Exp;
branches;
next	1.134;

1.134
date	2008.08.31.18.38.33;	author myc;	state Exp;
branches;
next	1.133;

1.133
date	2008.08.31.04.34.12;	author myc;	state Exp;
branches;
next	1.132;

1.132
date	2008.08.31.02.20.48;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2008.08.31.01.42.22;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2008.08.31.01.19.54;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2008.08.30.22.02.42;	author myc;	state Exp;
branches;
next	1.128;

1.128
date	2008.08.30.20.25.38;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2008.08.30.20.21.07;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.125;

1.125
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.124;

1.124
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.123;

1.123
date	2008.08.17.08.11.56;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2008.08.17.06.50.34;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2008.07.27.05.25.55;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2008.07.10.20.21.46;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2008.05.14.05.12.26;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.11.07.12.40;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.11.05.49.48;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2008.04.14.05.11.40;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2008.04.14.02.18.57;	author jps;	state Exp;
branches;
next	1.110;

1.110
date	2008.04.13.01.41.39;	author jps;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2008.04.02.04.55.59;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.04.01.00.13.09;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2008.03.29.17.34.55;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2008.03.24.02.28.37;	author jps;	state Exp;
branches;
next	1.101;

1.101
date	2008.03.23.00.27.38;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2008.03.21.22.52.52;	author jps;	state Exp;
branches;
next	1.99;

1.99
date	2008.03.21.14.54.19;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2008.03.19.04.32.14;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2008.03.16.00.21.53;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.11.02.53.41;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.94;

1.94
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2008.03.08.23.20.06;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.30.19.20.57;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.27.23.31.20;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.27.13.40.58;	author jps;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.26.07.27.27;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.17.04.10.07;	author myc;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.16.04.12.00;	author myc;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.14.21.28.54;	author myc;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.12.23.13.20;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.12.19.08.14;	author myc;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.09.01.51.42;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.06.05.32.56;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.05.05.37.31;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.25.19.45.55;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.23.19.27.26;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.19.20.51.38;	author myc;	state Exp;
branches;
next	1.66;

1.66
date	2007.12.09.03.31.46;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.25.00.04.59;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.26.23.49.30;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.25.20.39.11;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.03.22.53.54;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.01.21.22.29;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.01.20.45.47;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.01.20.34.10;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.30.20.00.09;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.30.19.42.46;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.25.02.57.26;	author myc;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.24.01.24.37;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.14.01.42.38;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.11.14.15.28;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.07.02.34.42;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.04.17.56.29;	author myc;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.21.03.45.52;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.20.22.24.17;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.18.07.36.48;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.18.04.26.32;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.18.00.03.31;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.17.03.47.30;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.15.06.19.18;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.13.18.15.05;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.08.21.36.05;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.07.06.15.02;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.27.02.32.05;	author dce;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.19.01.07.53;	author jjl;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.18.23.52.27;	author dce;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.18.03.29.04;	author dce;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.07.15.42.30;	author dce;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.10.18.45.33;	author dce;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.29.00.47.35;	author mtp;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.25.08.07.20;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.20.03.10.54;	author rsd;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.13.02.38.21;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	99.11.28.23.26.09;	author cso;	state Exp;
branches;
next	1.22;

1.22
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.21;

1.21
date	99.09.04.18.46.52;	author jimmy;	state Exp;
branches;
next	1.20;

1.20
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.19;

1.19
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.18;

1.18
date	99.08.05.14.52.02;	author dce;	state Exp;
branches;
next	1.17;

1.17
date	99.07.21.03.10.19;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.07.04.05.40.16;	author jimmy;	state Exp;
branches;
next	1.15;

1.15
date	99.07.04.05.24.47;	author jimmy;	state Exp;
branches;
next	1.14;

1.14
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.13;

1.13
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.04.22.01.44.49;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.03.12.19.44.42;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.03.05.20.02.36;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.02.16.17.00.19;	author dce;	state Exp;
branches;
next	1.8;

1.8
date	99.02.16.03.07.58;	author dce;	state Exp;
branches;
next	1.7;

1.7
date	99.02.13.20.23.48;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.02.13.19.37.12;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.02.11.16.44.23;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.02.10.02.38.58;	author dce;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.04.09.01;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.05.22.29;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: handler.c                                     Part of CircleMUD *
*  Usage: internal funcs: moving and finding chars/objs                   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "interpreter.h"
#include "spells.h"
#include "events.h"
#include "dg_scripts.h"
#include "corpse_save.h"

/* external vars */
extern struct player_frags_data pos_player_frags[15];
extern struct player_frags_data neg_player_frags[15];
extern int top_of_world;
extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern struct char_data *picktarget(struct char_data *ch);
extern char *MENU;
extern char *race_abbrevs[];
extern char *race_target[];
extern struct corpse_control_rec corpse_control[MAX_CORPSES];

/* external functions */
bool is_aggr_to(struct char_data *ch,struct char_data *target);
bool remove_from_frag_list(struct char_data *ch, bool);
bool add_to_frag_list(struct char_data *ch, bool);
void change_affected_stats(struct char_data * ch);
void load_results(struct char_data * ch);
void free_char(struct char_data * ch);
void stop_fighting(struct char_data * ch);
void remove_follower(struct char_data * ch);
void clearMemory(struct char_data * ch);
void Corpse_save_control(void);
int find_corpse(int index);
void ccontrol_destroy_corpse(int index);
void update_stats(struct char_data *ch);

/*Defines for MAX ABILS settings*/
#define MIN_AC	-100
#define MAX_AC	100
#define MAX_DAMROLL	40
#define MAX_HITROLL	40

char *fname(char *namelist)
{
  static char holder[30];
  register char *point;

  for (point = holder; isalpha(*namelist); namelist++, point++)
    *point = *namelist;

  *point = '\0';

  return (holder);
}


int isname(char *str, char *namelist)
{
  register char *curname, *curstr;

  curname = namelist;
  for (;;) {
    for (curstr = str;; curstr++, curname++) {
      if (!*curstr && !isalpha(*curname))
	return (1);

      if (!*curname)
	return (0);

      if (!*curstr || *curname == ' ')
	break;

      if (LOWER(*curstr) != LOWER(*curname))
	break;
    }

    /* skip to next name */

    for (; isalpha(*curname); curname++);
    if (!*curname)
      return (0);
    curname++;			/* first char of new name */
  }
}



/*Trophy Utilities*/
void trophy_update(struct char_data *ch, struct char_data *vict, float amount)
{
    int tmp_virtual, i;
    if (IS_NPC(ch))
        return;
    if (IS_NPC(vict))
        tmp_virtual = GET_MOB_VNUM(vict);
    else
        tmp_virtual = 0 - GET_RACE(vict);
    for (i = 0;i<=USE_TROPHY;i++)
    {
        if ((GET_TROPHY(ch, i).virtual == tmp_virtual) && (GET_TROPHY(ch, i).value > 0.0))
        {
            GET_TROPHY(ch, i).value = GET_TROPHY(ch, i).value + amount;
            return;
        }
    }
    /*if here new trophy so move records down one and add new one*/
    GET_TROPHY(ch, GET_TRTOP(ch)).virtual = tmp_virtual;
    GET_TROPHY(ch, GET_TRTOP(ch)).value = amount;
    /*move top pointer on*/
    if (GET_TRTOP(ch) >= (USE_TROPHY))/*end of array*/
       GET_TRTOP(ch) = 0;
    else
       GET_TRTOP(ch)++;

}


void frag_update(struct char_data *ch, struct char_data *victim, float amount)
{
   bool chaction = FALSE;
   bool victimaction = FALSE;
/*this updates a persons frag then checks to see if globel
frag list needs updating
    struct pos and neg _player_frags_data {
    int playerid;
    char name[MAX_NAME_LENGTH+1];
    float frag;
}*/ int i;
    /*int j = 0;*/
/*ok remove if not a good enough kill*/
   if ((!IS_NPC(ch) || (IS_NPC(ch) && (ch->desc && ch->desc->original)))  &&
 (!IS_NPC(victim) || (IS_NPC(victim) && (victim->desc && victim->desc->original))));
   else
      return;
   if ((GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(victim)))
      return;
   if  ((GET_LEVEL(victim) <= 35) && ((GET_LEVEL(ch) - GET_LEVEL(victim)) > 20))
      return;
   if ((GET_LEVEL(victim) < 20) && (GET_LEVEL(ch) > 20))
      return;
   if (GET_LEVEL(ch) > 70)
      return;


   // GET_FRAG(ch) = GET_FRAG(ch) + amount;
   //  GET_FRAG(victim) = GET_FRAG(victim) - amount;
   GET_FRAG(ch) += amount;
   GET_FRAG(victim) -= amount;
    /*ok check globel list*/
    /*extern struct player_frags_data player_frags[19];*/
    for (i=0;i<=14;i++)
    {/*if in list remove*/
        if ((GET_PFILEPOS(ch) == pos_player_frags[i].playerid))
        {
            if(!(remove_from_frag_list(ch, 1)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(ch, 1);
            chaction = TRUE;
        }
        if ((GET_PFILEPOS(victim) == pos_player_frags[i].playerid))
        {
            if (!(remove_from_frag_list(victim, 1)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(victim, 1);
            victimaction = TRUE;
        }
        if ((GET_PFILEPOS(ch) == neg_player_frags[i].playerid))
        {
            if(!(remove_from_frag_list(ch, 0)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(ch, 0);
            chaction = TRUE;
        }
        if ((GET_PFILEPOS(victim) == neg_player_frags[i].playerid))
        {
            if(!(remove_from_frag_list(victim, 0)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(victim, 0);
            victimaction = TRUE;
        }
    }


    /*fragger not on list*/
    if (!chaction)
    if (GET_FRAG(ch) < 0.0)
    {
        if (!(add_to_frag_list(ch, 0)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(ch));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }
    }else
    {
       if (!(add_to_frag_list(ch, 1)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(ch));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }

    }
    if (!victimaction)
    if (GET_FRAG(victim) < 0.0)
    {
        if (!(add_to_frag_list(victim, 0)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(victim));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }
    }else
    {
       if (!(add_to_frag_list(victim, 1)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(victim));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }

    }
}




/*removes person from frag list*/
bool remove_from_frag_list(struct char_data *ch, bool pos)
{
    int i, j;
    if (pos)
    {
        for (i=0;i<=14;i++)
        {
            if (GET_PFILEPOS(ch) == pos_player_frags[i].playerid)
            {
                for (j = i; j < 14;j++)
                {
                    pos_player_frags[j] = pos_player_frags[j + 1];
                }


                pos_player_frags[14].frag = 0.0;
                pos_player_frags[14].playerid = 0;
                strcpy(pos_player_frags[14].name, "");
                return TRUE;
            }
        }
    }
    else
    {
        for (i=0;i <= 14;i++)
        {
            if (GET_PFILEPOS(ch) == neg_player_frags[i].playerid)
            {
                for (j = i; j < 14;j++)
                {
                    neg_player_frags[j] = neg_player_frags[j+1];
                }
                neg_player_frags[14].frag = 0.0;
                neg_player_frags[14].playerid = 0;
                strcpy(neg_player_frags[14].name, "");
                return TRUE;
            }
        }
    }
    return FALSE;
}


/*adds person to frag list*/
bool add_to_frag_list(struct char_data *ch, bool pos)
{
    int i, j;
    if (pos)
    {
        for (i = 0;i <= 14;i++)
        {
            if (pos_player_frags[i].frag < GET_FRAG(ch))
            {/*ok insert person with frag details.*/
        /*1. copy all others down*/
                for (j = 14;j > i; j--)
                {
                    pos_player_frags[j] = pos_player_frags[j - 1];
                }
                pos_player_frags[i].playerid = GET_PFILEPOS(ch);
                strcpy(pos_player_frags[i].name, GET_NAME(ch));
                pos_player_frags[i].frag = GET_FRAG(ch);
                return TRUE;
            }
        }
    }
    else
    {
        for (i = 0;i <= 14;i++)
        {
            if (neg_player_frags[i].frag > GET_FRAG(ch))
            {/*ok insert person with frag details.*/
        /*1. copy all others down*/
                for (j = 14;j > i; j--)
                {
                    neg_player_frags[j] = neg_player_frags[j - 1];
                }
                neg_player_frags[i].playerid = GET_PFILEPOS(ch);
                strcpy(neg_player_frags[i].name, GET_NAME(ch));
                neg_player_frags[i].frag = GET_FRAG(ch);
                return TRUE;
            }
        }
    }
    return FALSE;
}

int perform_trophy_decrease(struct char_data *ch, struct char_data *vict, int exp)
{
    float x = 0;
    int i;
    bool found = FALSE;
    /*check to see if in trophy*/
    for (i = 0;i <= USE_TROPHY; i++)
    {
        if (GET_TROPHY(ch, i).virtual > 0)
        {/*npc trophy*/
            if (GET_TROPHY(ch, i).virtual == GET_MOB_VNUM(vict))
            {
                x = GET_TROPHY(ch, i).value;
                found = TRUE;
                break;
            }
        }
        else
        {/*pc trophy*/
            if (abs(GET_TROPHY(ch, i).virtual) == GET_RACE(vict))
            {
                x = GET_TROPHY(ch, i).value;
                found = TRUE;
                break;
            }
        }
    }
    if (!(found))
        return exp;

    if (x < 2.01)
        return exp;
    else if (x < 3.01)
        return (int) (exp * .95);
    else if(x < 5.01)
        return (int) (exp * .85);
    else if (x < 7.01)
        return (int) (exp * .65);
    else if (x < 10.01)
        return (int) (exp * .45);
    else
        return (int) (exp * .3);

}

/* This fuction redone by proky...Banyal*/



void affect_modify(struct char_data * ch, byte loc, sh_int mod, long bitv,
		        bool add, int aff_vector)
{
  int maxabil;

  if (!aff_vector)
    if (add)
      SET_BIT(AFF_FLAGS(ch), bitv);
    else{
      REMOVE_BIT(AFF_FLAGS(ch), bitv);
      mod = -mod;
    }
  if (aff_vector==2)
    if (add)
      SET_BIT(AFF2_FLAGS(ch), bitv);
    else{
      REMOVE_BIT(AFF2_FLAGS(ch), bitv);
      mod = -mod;
    }
  if (aff_vector==3)
    if(add)
      SET_BIT(AFF3_FLAGS(ch), bitv);
    else{
      REMOVE_BIT(AFF3_FLAGS(ch), bitv);
      mod = -mod;
    }


  maxabil = (IS_NPC(ch) ? 100 : 100);

  switch (loc) {
  case APPLY_NONE:
    break;

  case APPLY_STR:
	if ((GET_STR_VAFF(ch) + mod) < 121)
	  GET_STR_VAFF(ch) +=mod;
	else
	  GET_STR_VAFF(ch) = 120;
	break;
  case APPLY_DEX:
    if ((GET_DEX_VAFF(ch) + mod) < 121)
	  GET_DEX_VAFF(ch) +=mod;
	else
		GET_DEX_VAFF(ch) = 120;
	break;
  case APPLY_INT:
	if ((GET_INT_VAFF(ch) + mod) < 121)
	  GET_INT_VAFF(ch) +=mod;
	else
		GET_INT_VAFF(ch) = 120;
	break;
  case APPLY_WIS:
    if ((GET_WIS_VAFF(ch) + mod) < 121)
	  GET_WIS_VAFF(ch) +=mod;
	else
		GET_WIS_VAFF(ch) = 120;
	break;
  case APPLY_CON:
    if ((GET_CON_VAFF(ch) + mod) < 121)
        GET_CON_VAFF(ch) +=mod;
	else
		GET_CON_VAFF(ch) = 120;
	break;
  case APPLY_CHA:
  if ((GET_CHA_VAFF(ch) + mod) < 121)
	  GET_CHA_VAFF(ch) +=mod;
	else
		GET_CHA_VAFF(ch) = 120;
	break;

  case APPLY_CLASS:

    break;

  case APPLY_LEVEL:
    GET_LEVEL(ch) += mod;
    break;

  case APPLY_AGE:
    ch->player.time.birth -= (mod * SECS_PER_MUD_YEAR);
    break;

  case APPLY_CHAR_WEIGHT:
    GET_WEIGHT(ch) += mod;
    break;

  case APPLY_CHAR_HEIGHT:
    GET_HEIGHT(ch) += mod;
    break;

  case APPLY_MANA:
    GET_MAX_MANA(ch) += mod;
    break;

  case APPLY_HIT:
    GET_MAX_HIT(ch) += mod;
	alter_hit(ch, -1 * (mod), 3);
	/*GET_HIT(ch)+=mod;*/
    break;

  case APPLY_MOVE:
    GET_MAX_MOVE(ch) += mod;
    break;

  case APPLY_SIZE:
	  GET_SIZE(ch) += mod;
	  break;

  case APPLY_GOLD:
    break;

  case APPLY_EXP:
    break;

  case APPLY_AC:
 GET_AC(ch) += mod;
   break;

  case APPLY_HITROLL:
    GET_HITROLL(ch) = MIN(MAX_HITROLL, (GET_HITROLL(ch) + mod));
    break;

  case APPLY_DAMROLL:
     GET_DAMROLL(ch) = MIN(MAX_DAMROLL, (GET_DAMROLL(ch) + mod));
    break;

  case APPLY_SAVING_PARA:
    GET_SAVE(ch, SAVING_PARA) += mod;
    break;

  case APPLY_SAVING_ROD:
    GET_SAVE(ch, SAVING_ROD) += mod;
    break;

  case APPLY_SAVING_PETRI:
    GET_SAVE(ch, SAVING_PETRI) += mod;
    break;

  case APPLY_SAVING_BREATH:
    GET_SAVE(ch, SAVING_BREATH) += mod;
    break;

  case APPLY_SAVING_SPELL:
    GET_SAVE(ch, SAVING_SPELL) += mod;
    break;
/*These two below are crashy in our haste I just remove em till fixed
ao we can move on....Banyal*/
/*
case APPLY_MANA_REGEN:
   ch->char_specials.managain  += mod;
     break;

case APPLY_HIT_REGEN:
   ch->char_specials.hitgain += mod;
    break;
*/
  default:
    log("SYSERR: Unknown apply adjust attempt (handler.c, affect_modify).");
    break;
  }

}


/*This function redone by proky....Banyal
*/


/* This updates a character by subtracting everything he is affected by */
/* restoring original abilities, and then affecting all again           */
void affect_total(struct char_data * ch)
{
  struct affected_type *af;
  int i, j, vector=0;
  long bit;
//  int tmp_con;
//  bool con = FALSE;

  for (i = 0; i < NUM_WEARS; i++)
  {
      if (GET_EQ(ch, i))
	      for (j = 0; j < MAX_OBJ_AFFECT; j++) /*Max_obj_affect is 6*/
         {
            affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
               GET_EQ(ch, i)->affected[j].modifier,
		         GET_EQ(ch, i)->obj_flags.bitvector, FALSE, 0);
         }
  }

   for (af = ch->affected; af; af = af->next)
   {
      bit=0;
      vector=0;
      if(af->bitvector!=0)
      {
         bit = af->bitvector;
         vector=0;
      }
      else if(af->bitvector2!=0)
      {
         bit = af->bitvector2;
         vector=2;
      }
      else if(af->bitvector3!=0)
      {
         bit = af->bitvector3;
         vector=3;
      }
      affect_modify(ch, af->location, af->modifier, bit, FALSE, vector);
   }

  ch->vaff_abils = ch->view_abils;
  for (i = 0; i < NUM_WEARS; i++)
  {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
      {
	      affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
		      GET_EQ(ch, i)->affected[j].modifier,
		      GET_EQ(ch, i)->obj_flags.bitvector, TRUE, 0);
      }
   }
   /*set ac to 100 here as its re-calculated after this function*/
   if (!(IS_NPC(ch)))
      GET_AC(ch) = 100;

   for (af = ch->affected; af; af = af->next)
   {
      bit = 0;
      vector=0;
      if(af->bitvector!=0)
      {
         bit = af->bitvector;
         vector=0;
      }
      else if(af->bitvector2!=0)
      {
         bit = af->bitvector2;
         vector=2;
      }
      else if(af->bitvector3!=0)
      {
         bit = af->bitvector3;
         vector=3;
      }
      affect_modify(ch, af->location, af->modifier, bit, TRUE, vector);
   }


   if (IS_NPC(ch))
   { /*Data Effecting NPC (computer characters)*/
      i = 25;
      GET_DEX(ch) = MAX(0, MIN(GET_INT(ch), i));
      GET_INT(ch) = MAX(0, MIN(GET_INT(ch), i));
      GET_WIS(ch) = MAX(0, MIN(GET_WIS(ch), i));
      GET_CON(ch) = MAX(0, MIN(GET_CON(ch), i));
      GET_STR(ch) = MAX(0, GET_STR(ch));
      GET_STR(ch)= MIN(GET_STR(ch), i);
   }
   else
   {
/*Data if a PC ok*/
      i = 100;
      GET_DEX_VAFF(ch) = MAX(0, MIN(GET_DEX_VAFF(ch), i));
      GET_INT_VAFF(ch) = MAX(0, MIN(GET_INT_VAFF(ch), i));
      GET_WIS_VAFF(ch) = MAX(0, MIN(GET_WIS_VAFF(ch), i));
      GET_CON_VAFF(ch) = MAX(0, MIN(GET_CON_VAFF(ch), i));
      GET_CHA_VAFF(ch) = MAX(0, MIN(GET_CHA_VAFF(ch), i));
      GET_STR_VAFF(ch) = MAX(0, GET_STR_VAFF(ch));
      if (GET_STR_VAFF(ch) > 100)
      {
         i = GET_ADD_VAFF(ch) + ((GET_STR_VAFF(ch) - 100) * 5);
         GET_ADD_VAFF(ch) = MIN(i, 100);
	      GET_STR_VAFF(ch) = 100;
      }
   }
   change_affected_stats(ch);
/*ok update stats*/
   if (!(IS_NPC(ch)))
      update_stats(ch);

   check_regen_rates(ch);	/* update regen rates (for age) */
}


/* Insert an affect_type in a char_data structure
   Automatically sets apropriate bits and apply's */
void affect_to_char(struct char_data * ch, struct affected_type * af)
{
  long bit=0;bool con = FALSE;
  int vector = 0;
  struct affected_type *affected_alloc;

  CREATE(affected_alloc, struct affected_type, 1);

  *affected_alloc = *af;
  affected_alloc->next = ch->affected;
  ch->affected = affected_alloc;

  if(af->bitvector!=0)
    bit = af->bitvector;
  else if(af->bitvector2!=0){
    bit = af->bitvector2;
    vector=2;
    if (af->bitvector2 == AFF2_LIGHT)
      if (ch->in_room != -1)
      world[ch->in_room].light++;
  }
  else if(af->bitvector3!=0) {
    bit = af->bitvector3;
    vector=3;
  }
 if (!(IS_NPC(ch)))
    if (af->location == APPLY_CON)
        con = TRUE;
  affect_modify(ch, af->location, af->modifier, bit, TRUE, vector);

  affect_total(ch);
    /* if (con)
     con_aff(ch);*/
}



/*
 * Remove an affected_type structure from a char (called when duration
 * reaches zero). Pointer *af must never be NIL!  Frees mem and calls
 * affect_location_apply
 */
void affect_remove(struct char_data * ch, struct affected_type * af)
{
  struct affected_type *temp;
  long bit = 0;bool con = FALSE;
  int vector = 0;

  assert(ch->affected);

  if(af->bitvector!=0) {
    bit = af->bitvector;
    if (af->bitvector == AFF_FLYING && GET_POS(ch)==POS_FLYING){
     // act("You gently float back to the ground.",FALSE,ch,0,0,TO_CHAR);
    /* This line below is crashing the mud so I did some changes to it Banyal*/
     //  sprintf(buf, "%n floats back to the ground.", GET_NAME(ch));
     // act(buf,FALSE,ch,0,0,TO_ROOM);
      GET_POS(ch) = POS_STANDING;
    }
  }
  else if(af->bitvector2!=0){
    bit = af->bitvector2;
    vector=2;
    if (af->bitvector2==AFF2_LIGHT)
if (ch->in_room != -1)
 world[ch->in_room].light--;
  }
  else if(af->bitvector3!=0) {
    bit = af->bitvector3;
    vector=3;
  }
 if (!(IS_NPC(ch)))
    if (af->location == APPLY_CON)
        con = TRUE;

  affect_modify(ch, af->location, af->modifier, bit, FALSE,vector);

  REMOVE_FROM_LIST(af, ch->affected, next);
  free(af);
  affect_total(ch);
  /*if (con)
      con_aff(ch);*/
}



/* Call affect_remove with every spell of spelltype "skill" */
void affect_from_char(struct char_data * ch, int type)
{
  struct affected_type *hjp, *next;

  for (hjp = ch->affected; hjp; hjp = next) {
    next = hjp->next;
    if (hjp->type == type)
      affect_remove(ch, hjp);
  }
}



/*
 * Return if a char is affected by a spell (SPELL_XXX), NULL indicates
 * not affected
 */
bool affected_by_spell(struct char_data * ch, int type)
{
  struct affected_type *hjp;
if (ch->affected == NULL)
return FALSE;
  for (hjp = ch->affected; hjp; hjp = hjp->next)
    if (hjp->type == type)
      return TRUE;

  return FALSE;
}



void affect_join(struct char_data * ch, struct affected_type * af,
		      bool add_dur, bool avg_dur, bool add_mod, bool avg_mod,
		      bool refresh)
{
  struct affected_type *hjp;
  bool found = FALSE;

  for (hjp = ch->affected; !found && hjp; hjp = hjp->next) {

    if ((hjp->type == af->type) && (hjp->location == af->location)) {
      if (add_dur)
	af->duration += hjp->duration;
      else if (refresh)
        af->duration = hjp->duration;
      if (avg_dur)
	af->duration >>= 1;

      if (add_mod)
	af->modifier += hjp->modifier;
      if (avg_mod)
	af->modifier >>= 1;

      affect_remove(ch, hjp);
      affect_to_char(ch, af);
      found = TRUE;
    }
  }
  if (!found)
    affect_to_char(ch, af);
}


/* move a player out of a room */
void char_from_room(struct char_data * ch)
{
  struct char_data *temp;

  if (ch == NULL || ch->in_room == NOWHERE) {
    log("SYSERR: NULL or NOWHERE in handler.c, char_from_room");
    exit(1);
  }

  if (FIGHTING(ch) != NULL)
    stop_fighting(ch);

  if (IS_AFFECTED2(ch,AFF2_LIGHT) || ((GET_EQ(ch, WEAR_LIGHT) != NULL) &&
      (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT) &&
       (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light is ON */
if (ch->in_room != -1)
	world[ch->in_room].light--;

  REMOVE_FROM_LIST(ch, world[ch->in_room].people, next_in_room);
  ch->in_room = NOWHERE;
  ch->next_in_room = NULL;
}


/* place a character in a room */
void char_to_room(struct char_data * ch, int room)
{
  struct char_data *t_ch;

  if (!ch || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to char_to_room");
  else {
    ch->next_in_room = world[room].people;
    world[room].people = ch;
    ch->in_room = room;

    if (IS_AFFECTED2(ch,AFF2_LIGHT) || (GET_EQ(ch, WEAR_LIGHT) &&
	GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT &&
         (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light ON */
	world[room].light++;

  /* Stop fighting now, if we left. */
    if (FIGHTING(ch) && IN_ROOM(ch) != IN_ROOM(FIGHTING(ch))) {
      stop_fighting(FIGHTING(ch));
      stop_fighting(ch);
    }
  }
/* some new stuff for aggro code Banyal*/
if(ALONE(ch))
return;
if(!IS_NPC(ch)) {
t_ch = picktarget(ch);
if (t_ch && is_aggr_to(ch, t_ch))
if (number(0, 5))
hit(t_ch, ch, TYPE_UNDEFINED);
}
}


/* give an object to a char   */
void obj_to_char(struct obj_data * object, struct char_data * ch)
{
  if (object && ch) {
    object->next_content = ch->carrying;
    ch->carrying = object;
    object->carried_by = ch;
    object->in_room = NOWHERE;
    IS_CARRYING_W(ch) += GET_OBJ_WEIGHT(object);
    IS_CARRYING_N(ch)++;

    /* set flag for crash-save system */
    SET_BIT(PLR_FLAGS(ch), PLR_CRASH);
  } else
    log("SYSERR: NULL obj or char passed to obj_to_char");
}


/* take an object from a char */
void obj_from_char(struct obj_data * object)
{
  struct obj_data *temp;

  if (object == NULL) {
    log("SYSERR: NULL object passed to obj_from_char");
    return;
  }
  REMOVE_FROM_LIST(object, object->carried_by->carrying, next_content);

  /* set flag for crash-save system */
  SET_BIT(PLR_FLAGS(object->carried_by), PLR_CRASH);

  IS_CARRYING_W(object->carried_by) -= GET_OBJ_WEIGHT(object);
  IS_CARRYING_N(object->carried_by)--;
  object->carried_by = NULL;
  object->next_content = NULL;
}



/* Return the effect of a piece of armor in position eq_pos */
int apply_ac(struct char_data * ch, int eq_pos)
{
  int factor;

  assert(GET_EQ(ch, eq_pos));

  if (!(GET_OBJ_TYPE(GET_EQ(ch, eq_pos)) == ITEM_ARMOR))
    return 0;

  switch (eq_pos) {

  case WEAR_BODY:
    factor = 1;
    break;			/* 30% */
  case WEAR_HEAD:
    factor = 1;
    break;			/* 20% */
  case WEAR_LEGS:
    factor = 1;
    break;			/* 20% */
  default:
    factor = 1;
    break;			/* all others 10% */
  }

  return (factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), 0));
}



void equip_char(struct char_data * ch, struct obj_data * obj, int pos)
{
  int j;bool con = FALSE;
  int invalid_class(struct char_data *ch, struct obj_data *obj);

  assert(pos >= 0 && pos < NUM_WEARS);

  if (GET_EQ(ch, pos)) {
    sprintf(buf, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
	    obj->short_description);
    log(buf);
    return;
  }
  if (obj->carried_by) {
    log("SYSERR: EQUIP: Obj is carried_by when equip.");
    return;
  }
  if (obj->in_room != NOWHERE) {
    log("SYSERR: EQUIP: Obj is in_room when equip.");
    return;
  }
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
	invalid_class(ch, obj)) {
      act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
      /*act("$n is zapped by $p and instantly lets go of it.", FALSE, ch, obj, 0, TO_ROOM);*/
      obj_to_char(obj, ch);	/* changed to drop in inventory instead of
				 * ground */
      return;
    }
  }

  GET_EQ(ch, pos) = obj;
  obj->worn_by = ch;
  obj->worn_on = pos;

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
    GET_AC(ch) -= apply_ac(ch, pos);

  if (ch->in_room != NOWHERE) {
    if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
      world[ch->in_room].light++;
  }

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))	/* if light is ON */
	world[ch->in_room].light++;
  } else
    log("SYSERR: ch->in_room = NOWHERE when equipping char.");

  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    {
      if (!(IS_NPC(ch)))
	if (obj->affected[j].location == APPLY_CON)
	  con = TRUE;
      affect_modify(ch, obj->affected[j].location,
		    obj->affected[j].modifier,
		    obj->obj_flags.bitvector, TRUE, 0);
    }

  affect_total(ch);
  /*if (con)
    con_aff(ch);*/
}



struct obj_data *unequip_char(struct char_data * ch, int pos)
{
  int j;bool con = FALSE;
  struct obj_data *obj;

  assert(pos >= 0 && 16 < NUM_WEARS);
  assert(GET_EQ(ch, pos));

  obj = GET_EQ(ch, pos);
  obj->worn_by = NULL;
  obj->worn_on = -1;

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
    GET_AC(ch) += apply_ac(ch, pos);

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))	/* if light is ON */
	world[ch->in_room].light--;
  } else
    log("SYSERR: ch->in_room = NOWHERE when equipping char.");

  GET_EQ(ch, pos) = NULL;

  for (j = 0; j < MAX_OBJ_AFFECT; j++)
  {  if (!(IS_NPC(ch)))
      if (obj->affected[j].location == APPLY_CON)
        con = TRUE;
      affect_modify(ch, obj->affected[j].location,
		  obj->affected[j].modifier,
		  obj->obj_flags.bitvector, FALSE, 0);

  }

  affect_total(ch);
  /*if (con)
      con_aff(ch);*/
  return (obj);
}


int get_number(char **name)
{
  int i;
  char *ppos;
  char number[MAX_INPUT_LENGTH];

  *number = '\0';

  if ((ppos = strchr(*name, '.'))) {
    *ppos++ = '\0';
    strcpy(number, *name);
    strcpy(*name, ppos);

    for (i = 0; *(number + i); i++)
      if (!isdigit(*(number + i)))
	return 0;

    return (atoi(number));
  }
  return 1;
}



/* Search a given list for an object number, and return a ptr to that obj */
struct obj_data *get_obj_in_list_num(int num, struct obj_data * list)
{
  struct obj_data *i;

  for (i = list; i; i = i->next_content)
    if (GET_OBJ_RNUM(i) == num)
      return i;

  return NULL;
}

struct obj_data *get_obj_in_list_vnum(int num, struct obj_data * list)
{
  struct obj_data *i;

  for (i = list; i; i = i->next_content)
    if (GET_OBJ_VNUM(i) == num)
      return i;

  return NULL;
}



/* search the entire world for an object number, and return a pointer  */
struct obj_data *get_obj_num(int nr)
{
  struct obj_data *i;

  for (i = object_list; i; i = i->next)
    if (GET_OBJ_RNUM(i) == nr)
      return i;

  return NULL;
}



/* search a room for a char, and return a pointer if found..  */
struct char_data *get_char_room(char *name, int room)
{
  struct char_data *i;
  struct char_data *ch = NULL;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = world[room].people; i && (j <= number); i = i->next_in_room)
    if (isname(tmp, i->player.name)){
      if (++j == number)
	return i;
   }else if (is_abbrev(name, RACE_TARG(i)))
		  if (++j == number)
		if(i != ch)
		  return i;

  return NULL;
}



/* search all over the world for a char num, and return a pointer if found */
struct char_data *get_char_num(int nr)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (GET_MOB_RNUM(i) == nr)
      return i;

  return NULL;
}



/* put an object in a room */
void obj_to_room(struct obj_data * object, int room)
{
  int i=0;

  if (!object || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to obj_to_room");
  else {
    object->next_content = world[room].contents;
    world[room].contents = object;
    object->in_room = room;
    object->carried_by = NULL;
    if((SECT(room) == SECT_WATER_SWIM || SECT(room) == SECT_WATER_NOSWIM ||
       SECT(room) == SECT_OCEAN) && (!IS_OBJ_STAT(object, ITEM_FLOAT))) {
      act("$p&4&b sinks like a rock.&0",FALSE,0,object,0,TO_ROOM);
      extract_obj(object);
      return;
    }
    if (ROOM_FLAGGED(room, ROOM_HOUSE))
      SET_BIT(ROOM_FLAGS(room), ROOM_HOUSE_CRASH);
    /* if this is a player corpse, save the new room vnum to
       the corpse control record. This can later be optimized as
       a flag, much like houses  -  nechtrous */
    if (IS_CORPSE(object) && GET_OBJ_VAL(object, 1)) {
      if ((i = find_corpse(GET_OBJ_VAL(object,2)))) {
        corpse_control[i].vnum = world[room].number;
        Corpse_save_control();
      }
    }
  }
}


/* Take an object from a room */
void obj_from_room(struct obj_data * object)
{
  struct obj_data *temp;

  if (!object || object->in_room == NOWHERE) {
    log("SYSERR: NULL object or obj not in a room passed to obj_from_room");
    return;
  }

  REMOVE_FROM_LIST(object, world[object->in_room].contents, next_content);

  if (ROOM_FLAGGED(object->in_room, ROOM_HOUSE))
    SET_BIT(ROOM_FLAGS(object->in_room), ROOM_HOUSE_CRASH);
  object->in_room = NOWHERE;
  object->next_content = NULL;
}


/* put an object in an object (quaint)  */
void obj_to_obj(struct obj_data * obj, struct obj_data * obj_to)
{
  struct obj_data *tmp_obj;

  if (!obj || !obj_to || obj == obj_to) {
    log("SYSERR: NULL object or same source and target obj passed to obj_to_obj");
    return;
  }

  obj->next_content = obj_to->contains;
  obj_to->contains = obj;
  obj->in_obj = obj_to;

  for (tmp_obj = obj->in_obj; tmp_obj->in_obj; tmp_obj = tmp_obj->in_obj)
    GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);

  /* top level object.  Subtract weight from inventory if necessary. */
  GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);
  if (tmp_obj->carried_by)
    IS_CARRYING_W(tmp_obj->carried_by) += GET_OBJ_WEIGHT(obj);
}


/* remove an object from an object */
void obj_from_obj(struct obj_data * obj)
{
  struct obj_data *temp, *obj_from;

  if (obj->in_obj == NULL) {
    log("error (handler.c): trying to illegally extract obj from obj");
    return;
  }
  obj_from = obj->in_obj;
  REMOVE_FROM_LIST(obj, obj_from->contains, next_content);

  /* Subtract weight from containers container */
  for (temp = obj->in_obj; temp->in_obj; temp = temp->in_obj)
    GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);

  /* Subtract weight from char that carries the object */
  GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);
  if (temp->carried_by)
    IS_CARRYING_W(temp->carried_by) -= GET_OBJ_WEIGHT(obj);

  obj->in_obj = NULL;
  obj->next_content = NULL;

  /* to fix some eq dupping, if obj_from is a pcorpse, save the corpse -nech */
  if(IS_CORPSE(obj_from) && GET_OBJ_VAL(obj_from, 1))
    Corpse_crashsave(GET_OBJ_VAL(obj_from,2), obj_from);
}


/* Set all carried_by to point to new owner */
void object_list_new_owner(struct obj_data * list, struct char_data * ch)
{
  if (list) {
    object_list_new_owner(list->contains, ch);
    object_list_new_owner(list->next_content, ch);
    list->carried_by = ch;
  }
}


/* Extract an object from the world */
void extract_obj(struct obj_data * obj)
{
  struct obj_data *temp;

  if(IS_CORPSE(obj) && GET_OBJ_VAL(obj, 1))
    ccontrol_destroy_corpse(GET_OBJ_VAL(obj,2));

  if (obj->worn_by != NULL)
    if (unequip_char(obj->worn_by, obj->worn_on) != obj)
      log("SYSERR: Inconsistent worn_by and worn_on pointers!!");
  if (obj->in_room != NOWHERE)
    obj_from_room(obj);
  else if (obj->carried_by)
    obj_from_char(obj);
  else if (obj->in_obj)
    obj_from_obj(obj);

  /* Get rid of the contents of the object, as well. */
  while (obj->contains)
    extract_obj(obj->contains);

  REMOVE_FROM_LIST(obj, object_list, next);

  if (GET_OBJ_RNUM(obj) >= 0)
    (obj_index[GET_OBJ_RNUM(obj)].number)--;

  if (SCRIPT(obj))
    extract_script(SCRIPT(obj));

  free_obj(obj);
}



void update_object(struct obj_data * obj, int use)
{
  if (GET_OBJ_TIMER(obj) > 0)
    GET_OBJ_TIMER(obj) -= use;
  if (obj->contains)
    update_object(obj->contains, use);
  if (obj->next_content)
    update_object(obj->next_content, use);
}


void update_char_objects(struct char_data * ch)
{
  int i;

  if (GET_EQ(ch, WEAR_LIGHT) != NULL)
    if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT)
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2) > 0) {
	i = --GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2);
	if (i == 1) {
	  act("Your light begins to flicker and fade.", FALSE, ch, 0, 0, TO_CHAR);
	  act("$n's light begins to flicker and fade.", FALSE, ch, 0, 0, TO_ROOM);
	} else if (i == 0) {
	  act("Your light sputters out and dies.", FALSE, ch, 0, 0, TO_CHAR);
	  act("$n's light sputters out and dies.", FALSE, ch, 0, 0, TO_ROOM);
	  world[ch->in_room].light--;
	}
      }

  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      update_object(GET_EQ(ch, i), 2);

  if (ch->carrying)
    update_object(ch->carrying, 1);
}



/* Extract a ch completely from the world, and leave his stuff behind
maybe leave stuf behind >:) Banyal*/
void extract_char(struct char_data * ch)
{
  struct char_data *k, *temp;
  struct descriptor_data *t_desc;
  struct obj_data *obj;
  int i, freed = 0;
  int save_room;
  void dismount_char(struct char_data *ch);
  void stop_guarding(struct char_data *ch);
  extern struct char_data *combat_list;

  ACMD(do_return);

void die_consentee(struct char_data *ch);
void die_follower(struct char_data * ch);
void die_groupee(struct char_data *ch);
void stop_ignoring_me(struct char_data *ch);
void die_consentee_clean(struct char_data *ch);
  if (!IS_NPC(ch) && !ch->desc) {
    for (t_desc = descriptor_list; t_desc; t_desc = t_desc->next)
      if (t_desc->original == ch)
	do_return(t_desc->character, "", 0, 0);
  }
  if (ch->in_room == NOWHERE) {
    log("SYSERR: NOWHERE extracting char. (handler.c, extract_char)");
    exit(1);
  }
stop_ignoring_me(ch);
die_consentee_clean(ch);
  if (ch->followers || ch->master)
    die_follower(ch);
if (ch->groupmaster || ch->groupees)
	  die_groupee(ch);
  if (CONSENT(ch))
	  die_consentee(ch);
  if (RIDING(ch) || RIDDEN_BY(ch))
     dismount_char(ch);
  if(ch->guarding)
     stop_guarding(ch);
  if(ch->guarded_by)
     stop_guarding(ch->guarded_by);
  /* Forget snooping, if applicable */
  if (ch->desc) {
    if (ch->desc->snooping) {
      ch->desc->snooping->snoop_by = NULL;
      ch->desc->snooping = NULL;
    }
    if (ch->desc->snoop_by) {
      SEND_TO_Q("Your victim is no longer among us.\r\n",
		ch->desc->snoop_by);
      ch->desc->snoop_by->snooping = NULL;
      ch->desc->snoop_by = NULL;
    }
  }
  /* transfer objects to room, if any if not camping is now an event*/
  /*if (!PRF_FLAGGED(ch, PRF_CAMPING)){*/
  while (ch->carrying) {
    obj = ch->carrying;
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
  }/*}*/

  /* transfer equipment to room, if any if not camping is now an event*/
   /*if (!PRF_FLAGGED(ch, PRF_CAMPING)){*/
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_room(unequip_char(ch, i), ch->in_room);/*}*/

  if (FIGHTING(ch))
    stop_fighting(ch);


  for (k = combat_list; k; k = temp) {
    temp = k->next_fighting;
    if (FIGHTING(k) == ch)
      stop_fighting(k);
  }

   /* cancel point updates */
  for (i = 0; i < 3; i++)
    if (GET_POINTS_EVENT(ch, i)) {
      event_cancel(GET_POINTS_EVENT(ch, i));
      GET_POINTS_EVENT(ch, i) = NULL;
    }

  char_from_room(ch);
  save_room = ch->in_room;

  /* pull the char from the list */
  REMOVE_FROM_LIST(ch, character_list, next);

  if (ch->desc && ch->desc->original)
    do_return(ch, "", 0, 0);

  if (!IS_NPC(ch)) {
    save_char(ch, NOWHERE);
    Crash_delete_crashfile(ch);
  } else {
    if (GET_MOB_RNUM(ch) > -1)		/* if mobile */
      mob_index[GET_MOB_RNUM(ch)].number--;
    clearMemory(ch);		/* Only NPC's can have memory */
    if (SCRIPT(ch))
    extract_script(SCRIPT(ch));
    free_char(ch);
    freed = 1;
  }

  if (!freed && ch->desc != NULL) {
    STATE(ch->desc) = CON_MENU;
    SEND_TO_Q(MENU, ch->desc);
  } else {  /* if a player gets purged from within the game */
    if (!freed)
      free_char(ch);
  }
}



/* ***********************************************************************
* Here follows high-level versions of some earlier routines, ie functions*
* which incorporate the actual player-data                               *.
*********************************************************************** */


struct char_data *get_player_vis(struct char_data * ch, char *name, int inroom)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (!IS_NPC(i) && (!inroom || i->in_room == ch->in_room) &&
	!str_cmp(i->player.name, name) && CAN_SEE(ch, i))
      return i;
  /*else if (is_abbrev(name, RACE_TARG(i)))
		if (CAN_SEE(ch, i))
		  return i;*/

  return NULL;
}


struct char_data *get_char_room_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* JE 7/18/94 :-) :-) */
  if (!str_cmp(name, "self") || !str_cmp(name, "me"))
    return ch;

  /* 0.<name> means PC with name shithead*/
  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 1);

  for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)
    if (isname(tmp, i->player.name)){
      if (CAN_SEE(ch, i))
	if (++j == number)
	  return i;
  }else if (is_abbrev(name, RACE_TARG(i)))
		if (CAN_SEE(ch, i))
		  if (i != ch && GET_RACE_ALIGN(ch) != GET_RACE_ALIGN(i))
		  /*if (++j == number)*/
		  return i;

 /* for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)*/
	  /*sprintf(buf, "%s", RACE_ABBR(i));
	  if (str_cmp(tmp, RACE_ABBR(i)))
		  if (CAN_SEE(ch, i))
		  if (++j == number)
		  return i;*/

  return NULL;
}


struct char_data *get_char_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* check the room first */
  if ((i = get_char_room_vis(ch, name)) != NULL)
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 0);

  for (i = character_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->player.name) && CAN_SEE(ch, i))/*{*/
      if (++j == number)
	return i;/*}*/
  /*else if (is_abbrev(name, RACE_TARG(i)))
		if (CAN_SEE(ch, i))
		  if (++j == number)
		  return i;*/

  return NULL;
}



struct obj_data *get_obj_in_list_vis(struct char_data * ch, char *name,
				              struct obj_data * list)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);/*shithead*/
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = list; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i))
	if (++j == number)
	  return i;

  return NULL;
}




/* search the entire world for an object, and return a pointer  */
struct obj_data *get_obj_vis(struct char_data * ch, char *name)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* scan items carried */
  if ((i = get_obj_in_list_vis(ch, name, ch->carrying)))
    return i;

  /* scan room */
  if ((i = get_obj_in_list_vis(ch, name, world[ch->in_room].contents)))
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  /* ok.. no luck yet. scan the entire obj list   */
  for (i = object_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i))
	if (++j == number)
	  return i;

  return NULL;
}



struct obj_data *get_object_in_equip_vis(struct char_data * ch,
		           char *arg, struct obj_data * equipment[], int *j)
{
  for ((*j) = 0; (*j) < NUM_WEARS; (*j)++)
    if (equipment[(*j)])
      if (CAN_SEE_OBJ(ch, equipment[(*j)]))
	if (isname(arg, equipment[(*j)]->name))
	  return (equipment[(*j)]);

  return NULL;
}


char *money_desc(int amount)
{
  static char buf[128];

  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money.");
    return NULL;
  }
  if (amount == 1)
    strcpy(buf, "a single coin");
  else if (amount <= 9)
    strcpy(buf, "a tiny pile of coins");
  else if (amount <= 20)
    strcpy(buf, "a handful of coins");
  else if (amount <= 75)
    strcpy(buf, "a little pile of coins");
  else if (amount <= 200)
    strcpy(buf, "a small pile of coins");
  else if (amount <= 1000)
    strcpy(buf, "a pile of coins");
  else if (amount <= 5000)
    strcpy(buf, "a big pile of coins");
  else if (amount <= 10000)
    strcpy(buf, "a large heap of coins");
  else if (amount <= 20000)
    strcpy(buf, "a huge mound of coins");
  else if (amount <= 75000)
    strcpy(buf, "an enormous mound of coins");
  else if (amount <= 150000)
    strcpy(buf, "a small mountain of coins");
  else if (amount <= 250000)
    strcpy(buf, "a mountain of coins");
  else if (amount <= 500000)
    strcpy(buf, "a huge mountain of coins");
  else if (amount <= 1000000)
    strcpy(buf, "an enormous mountain of coins");
  else
    strcpy(buf, "an absolutely colossal mountain of gold coins");

  return buf;
}


struct obj_data *create_money(int pamount, int gamount, int samount, int camount)
{int amount;
  struct obj_data *obj;
  struct extra_descr_data *new_descr;
  char buf[200];
amount = pamount+gamount+samount+camount;
  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money.");
    return NULL;
  }
  obj = create_obj();
  CREATE(new_descr, struct extra_descr_data, 1);

  if (amount == 1) {
	if (pamount == 1){
	  obj->name = str_dup("platinum coin");
    obj->short_description = str_dup("a platinum coin");
	obj->description = str_dup("A single platinum coin is lying here.");
    new_descr->keyword = str_dup("coin platinum");
    new_descr->description = str_dup("A shiny platinum coin!");}
		if (gamount == 1){
	  obj->name = str_dup("gold coin");
    obj->short_description = str_dup("a gold coin");
	obj->description = str_dup("A single gold coin is lying here.");
    new_descr->keyword = str_dup("coin gold");
    new_descr->description = str_dup("A worn gold coin!");}
			if (samount == 1){
	  obj->name = str_dup("silver coin");
    obj->short_description = str_dup("a silver coin");
	obj->description = str_dup("A single silver coin is lying here.");
    new_descr->keyword = str_dup("coin silver");
    new_descr->description = str_dup("A tarnished silver coin.");}
				if (camount == 1){
	  obj->name = str_dup("copper coin");
    obj->short_description = str_dup("a copper coin");
	obj->description = str_dup("A single copper coin is lying here.");
    new_descr->keyword = str_dup("coin copper");
    new_descr->description = str_dup("A dull copper coin.");}
  }

  else {
    obj->name = str_dup("coins");
    obj->short_description = str_dup(money_desc(amount));
    sprintf(buf, "%s is lying here.", money_desc(amount));
    obj->description = str_dup(CAP(buf));

    new_descr->keyword = str_dup("coins");
    if (amount < 10) {
      sprintf(buf, "There are %d coins.", amount);
      new_descr->description = str_dup(buf);
    } else if (amount < 100) {
      sprintf(buf, "There are about %d coins.", 10 * (amount / 10));
      new_descr->description = str_dup(buf);
    } else if (amount < 1000) {
      sprintf(buf, "It looks to be about %d coins.", 100 * (amount / 100));
      new_descr->description = str_dup(buf);
    } else if (amount < 100000) {
      sprintf(buf, "You guess there are, maybe, %d coins.",
	      1000 * ((amount / 1000) + number(0, (amount / 1000))));
      new_descr->description = str_dup(buf);
    } else
      new_descr->description = str_dup("There are a LOT of coins.");
  }

  new_descr->next = NULL;
  obj->ex_description = new_descr;

  GET_OBJ_TYPE(obj) = ITEM_MONEY;
  GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE;
  GET_OBJ_VAL(obj, 0) = pamount;
  GET_OBJ_VAL(obj, 1) = gamount;
    GET_OBJ_VAL(obj, 2) = samount;
	  GET_OBJ_VAL(obj, 3) = camount;
  GET_OBJ_COST(obj) = pamount*1000+gamount*100+samount*10+camount;
  obj->item_number = NOTHING;

  return obj;
}


/* Generic Find, designed to find any object/character                    */
/* Calling :                                                              */
/*  *arg     is the sting containing the string to be searched for.       */
/*           This string doesn't have to be a single word, the routine    */
/*           extracts the next word itself.                               */
/*  bitv..   All those bits that you want to "search through".            */
/*           Bit found will be result of the function                     */
/*  *ch      This is the person that is trying to "find"                  */
/*  **tar_ch Will be NULL if no character was found, otherwise points     */
/* **tar_obj Will be NULL if no object was found, otherwise points        */
/*                                                                        */
/* The routine returns a pointer to the next word in *arg (just like the  */
/* one_argument routine).                                                 */

int generic_find(char *arg, int bitvector, struct char_data * ch,
		     struct char_data ** tar_ch, struct obj_data ** tar_obj)
{
  int i, found;
  char name[256];

  one_argument(arg, name);

  if (!*name)
    return (0);

  *tar_ch = NULL;
  *tar_obj = NULL;

  if (IS_SET(bitvector, FIND_CHAR_ROOM)) {	/* Find person in room */
    if ((*tar_ch = get_char_room_vis(ch, name))) {
      return (FIND_CHAR_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_CHAR_WORLD)) {
    if ((*tar_ch = get_char_vis(ch, name))) {
      return (FIND_CHAR_WORLD);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_EQUIP)) {
    for (found = FALSE, i = 0; i < NUM_WEARS && !found; i++)
      if (GET_EQ(ch, i) && isname(name, GET_EQ(ch, i)->name) == 1) {
	*tar_obj = GET_EQ(ch, i);
	found = TRUE;
      }
    if (found) {
      return (FIND_OBJ_EQUIP);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_INV)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
      return (FIND_OBJ_INV);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_ROOM)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, world[ch->in_room].contents))) {
      return (FIND_OBJ_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_WORLD)) {
    if ((*tar_obj = get_obj_vis(ch, name))) {
      return (FIND_OBJ_WORLD);
    }
  }
  return (0);
}


/* a function to scan for "all" or "all.x" */
int find_all_dots(char *arg)
{
  if (!strcmp(arg, "all"))
    return FIND_ALL;
  else if (!strncmp(arg, "all.", 4)) {
    strcpy(arg, arg + 4);
    return FIND_ALLDOT;
  } else
    return FIND_INDIV;
}


 /* dismount_char() / fr: Daniel Koepke (dkoepke@@california.com)
   If a character is mounted on something, we dismount them.  If
   someone is mounting our character, then we dismount that someone.
   This is used for cleaning up after a mount is cancelled by
    something (either intentionally or by death, etc.)*/
 void dismount_char(struct char_data *ch) {
   if (RIDING(ch)) {
     RIDDEN_BY(RIDING(ch)) = NULL;
     RIDING(ch) = NULL;
   }

   if (RIDDEN_BY(ch)) {
     RIDING(RIDDEN_BY(ch)) = NULL;
     RIDDEN_BY(ch) = NULL;
   }
 }


 /* mount_char() / fr: Daniel Koepke (dkoepke@@california.com)
   Sets _ch_ to mounting _mount_.  This does not make any checks
   what-so-ever to see if the _mount_ is mountable, etc.  That is
   left up to the calling function.  This does not present any
    messages, either.*/
 void mount_char(struct char_data *ch, struct char_data *mount) {
   RIDING(ch) = mount;
   RIDDEN_BY(mount) = ch;
  }
@


1.165
log
@fixed - warning: format not a string literal and no format arguments
@
text
@/***************************************************************************
 * $Id: handler.c,v 1.164 2011/08/06 15:22:51 rsd Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: handler.c                                      Part of FieryMUD *
 *  Usage: internal funcs: moving chars/objs and handling effects          *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "interpreter.h"
#include "casting.h"
#include "events.h"
#include "dg_scripts.h"
#include "corpse_save.h"
#include "quest.h"
#include "races.h"
#include "chars.h"
#include "class.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "players.h"
#include "trophy.h"
#include "pfiles.h"
#include "regen.h"
#include "fight.h"
#include "movement.h"
#include "limits.h"
#include "ai.h"
#include "composition.h"
#include "charsize.h"
#include "clan.h"

/* external vars */
extern char *MENU;

/* external functions */
void free_char(struct char_data * ch);
void remove_follower(struct char_data * ch);
void abort_casting(struct char_data *ch);


static int apply_ac(struct char_data * ch, int eq_pos);


char *fname(const char *namelist)
{
  static char holder[30];
  register char *point;

  for (point = holder; isalpha(*namelist); namelist++, point++)
    *point = *namelist;

  *point = '\0';

  return (holder);
}


int isname(const char *str, const char *namelist)
{
  register const char *curname, *curstr;

  curname = namelist;
  for (;;) {
    for (curstr = str;; curstr++, curname++) {
      if (!*curstr && !isalpha(*curname))
        return (1);

      if (!*curname)
        return (0);

      if (!*curstr || *curname == ' ')
        break;

      if (LOWER(*curstr) != LOWER(*curname))
        break;
    }

    /* skip to next name */

    for (; isalpha(*curname); curname++);
    if (!*curname)
      return (0);
    curname++;                        /* first char of new name */
  }
}

void effect_modify(struct char_data * ch, byte loc, sh_int mod,
                   flagvector bitv[], bool add)
{
  int i;

  if (add) {
    /* Special behaviors for aff flags. */
    if (IS_FLAGGED(bitv, EFF_LIGHT) && ch->in_room != NOWHERE &&
        !EFF_FLAGGED(ch, EFF_LIGHT))
      world[ch->in_room].light++;

    /* Add effect flags. */
    for (i = 0; i < NUM_EFF_FLAGS; ++i)
      if (IS_FLAGGED(bitv, i))
        SET_FLAG(EFF_FLAGS(ch), i);
  }
  else {
    /* Special behaviors for aff flags. */
    if (IS_FLAGGED(bitv, EFF_LIGHT) && ch->in_room != NOWHERE &&
        EFF_FLAGGED(ch, EFF_LIGHT))
      world[ch->in_room].light--;
    if (IS_FLAGGED(bitv, EFF_CAMOUFLAGED))
      GET_HIDDENNESS(ch) = 0;

    /* Remove effect flags. */
    for (i = 0; i < NUM_EFF_FLAGS; ++i)
      if (IS_FLAGGED(bitv, i))
        REMOVE_FLAG(EFF_FLAGS(ch), i);

    /* Negative modifier for !add. */
    mod = -mod;
  }

  switch (loc) {
  case APPLY_NONE:
    break;

  case APPLY_STR:
    GET_ACTUAL_STR(ch) += mod;
    break;
  case APPLY_DEX:
    GET_ACTUAL_DEX(ch) += mod;
    break;
  case APPLY_INT:
    GET_ACTUAL_INT(ch) += mod;
    break;
  case APPLY_WIS:
    GET_ACTUAL_WIS(ch) += mod;
    break;
  case APPLY_CON:
    GET_ACTUAL_CON(ch) += mod;
    break;
  case APPLY_CHA:
    GET_ACTUAL_CHA(ch) += mod;
    break;

  case APPLY_CLASS:
    break;

  case APPLY_LEVEL:
    GET_LEVEL(ch) += mod;
    break;

  case APPLY_AGE:
    ch->player.time.birth -= (mod * SECS_PER_MUD_YEAR);
    break;

  case APPLY_CHAR_WEIGHT:
    GET_WEIGHT(ch) += mod;
    break;

  case APPLY_CHAR_HEIGHT:
    GET_HEIGHT(ch) += mod;
    break;

  case APPLY_MANA:
    GET_MAX_MANA(ch) += mod;
    break;

  case APPLY_HIT:
    GET_MAX_HIT(ch) += mod;
    GET_HIT(ch) += mod;
    break;

  case APPLY_MOVE:
    GET_MAX_MOVE(ch) += mod;
    GET_MOVE(ch) += mod;
    break;

  case APPLY_SIZE:
    adjust_size(ch, mod);
    break;
  case APPLY_GOLD:
    break;
  case APPLY_EXP:
    break;
  case APPLY_AC:
    /* Subtract from AC because negative AC is better */
    GET_AC(ch) -= mod;
    break;
  case APPLY_HITROLL:
    GET_HITROLL(ch) += mod;
    break;
  case APPLY_DAMROLL:
    GET_DAMROLL(ch) += mod;
    break;
  case APPLY_SAVING_PARA:
    GET_SAVE(ch, SAVING_PARA) += mod;
    break;

  case APPLY_SAVING_ROD:
    GET_SAVE(ch, SAVING_ROD) += mod;
    break;

  case APPLY_SAVING_PETRI:
    GET_SAVE(ch, SAVING_PETRI) += mod;
    break;

  case APPLY_SAVING_BREATH:
    GET_SAVE(ch, SAVING_BREATH) += mod;
    break;

  case APPLY_SAVING_SPELL:
    GET_SAVE(ch, SAVING_SPELL) += mod;
    break;
  case APPLY_MANA_REGEN:
    ch->char_specials.managain += mod;
    break;
  case APPLY_HIT_REGEN:
    ch->char_specials.hitgain += mod;
    break;
  case APPLY_PERCEPTION:
    GET_PERCEPTION(ch) += mod;
    break;
  case APPLY_HIDDENNESS:
    GET_HIDDENNESS(ch) = LIMIT(0, GET_HIDDENNESS(ch) + mod, 1000);
    break;
  case APPLY_COMPOSITION:
    if (mod >= 0)
      convert_composition(ch, mod);
    else
      convert_composition(ch, BASE_COMPOSITION(ch));
    break;
  default:
    sprintf(buf, "SYSERR:handler.c:effect_modify() Unknown apply adjust attempt for: %s", GET_NAME(ch));
    log("%s",buf);
    break;
  }

  scale_attribs(ch); /* recalc the affected attribs */
}



/* This updates a character by subtracting everything he is affected by */
/* restoring original abilities, and then affecting all again           */
/* The character may not be in a room at this point.                    */
void effect_total(struct char_data * ch)
{
  void start_char_falling(struct char_data *ch);

  struct effect *eff;
  int i, j, old_hp = GET_MAX_HIT(ch);

  /* Remove effects of equipment. */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i)) {
      if (GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR)
        GET_AC(ch) += apply_ac(ch, i);
      for (j = 0; j < MAX_OBJ_APPLIES; j++)
        effect_modify(ch, GET_EQ(ch, i)->applies[j].location,
                      GET_EQ(ch, i)->applies[j].modifier,
                      GET_OBJ_EFF_FLAGS(GET_EQ(ch, i)), FALSE);
  }

  /* Remove spell effects. */
  for (eff = ch->effects; eff; eff = eff->next)
    effect_modify(ch, eff->location, eff->modifier, eff->flags, FALSE);

  /* Now that all affects should be removed...let's make sure that
     their natural stats are where they should be. This was done in
     attempt to fix equipment messing up a players stats. DCE 12-18-01 */
  ch->actual_abils = ch->natural_abils;
  GET_COMPOSITION(ch) = BASE_COMPOSITION(ch);
  if (!IS_NPC(ch)) {
    GET_DAMROLL(ch) = GET_BASE_DAMROLL(ch);
    GET_HITROLL(ch) = GET_BASE_HITROLL(ch);
    GET_AC(ch) = MAX_AC;
    GET_MAX_HIT(ch) = GET_BASE_HIT(ch);

    /* Perception bonus
     * It comes out to base 480 for a level 99 human with maxed int and wis.
     */
    GET_PERCEPTION(ch) = (GET_LEVEL(ch) * ((GET_INT(ch) + GET_WIS(ch)) / 30));
  }

  /* Alrighty, add the equipment effects back in. */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i)) {
      if (GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_ARMOR)
        GET_AC(ch) -= apply_ac(ch, i);
      for (j = 0; j < MAX_OBJ_APPLIES; j++)
        effect_modify(ch, GET_EQ(ch, i)->applies[j].location,
                      GET_EQ(ch, i)->applies[j].modifier,
                      GET_OBJ_EFF_FLAGS(GET_EQ(ch, i)), TRUE);
    }

  /* And put the spells back too. */
  for (eff = ch->effects; eff; eff = eff->next)
    effect_modify(ch, eff->location, eff->modifier, eff->flags, TRUE);

  /* Update stats */
  if (!IS_NPC(ch)) {
    scale_attribs(ch);

    /* Now that we know current dex, add static AC and then cap */
    GET_AC(ch) -= static_ac(GET_DEX(ch));
    GET_AC(ch) = LIMIT(MIN_AC, GET_AC(ch), MAX_AC);

    /* Calculate HP bonus */
    GET_MAX_HIT(ch) += con_aff(ch);

    /* Fix hp */
    alter_hit(ch, old_hp - GET_MAX_HIT(ch), TRUE);

    /* Cap perception stat */
    GET_PERCEPTION(ch) = MAX(0, MIN(GET_PERCEPTION(ch), 1000));

    /* Cap damroll/hitroll stats */
    GET_DAMROLL(ch) = LIMIT(MIN_DAMROLL, GET_DAMROLL(ch), MAX_DAMROLL);
    GET_HITROLL(ch) = LIMIT(MIN_HITROLL, GET_HITROLL(ch), MAX_HITROLL);
  }
  else {
    GET_DEX(ch) = LIMIT(MIN_ABILITY_VALUE, GET_DEX(ch), MAX_ABILITY_VALUE);
    GET_INT(ch) = LIMIT(MIN_ABILITY_VALUE, GET_INT(ch), MAX_ABILITY_VALUE);
    GET_WIS(ch) = LIMIT(MIN_ABILITY_VALUE, GET_WIS(ch), MAX_ABILITY_VALUE);
    GET_CON(ch) = LIMIT(MIN_ABILITY_VALUE, GET_CON(ch), MAX_ABILITY_VALUE);
    GET_STR(ch) = LIMIT(MIN_ABILITY_VALUE, GET_STR(ch), MAX_ABILITY_VALUE);
    GET_CHA(ch) = LIMIT(MIN_ABILITY_VALUE, GET_CHA(ch), MAX_ABILITY_VALUE);
  }

  check_regen_rates(ch); /* update regen rates (for age) */

  if (IN_ROOM(ch) != NOWHERE && !PLR_FLAGGED(ch, PLR_SAVING)) {
    /* Check for issues with flying and such */
    if (SECT(IN_ROOM(ch)) == SECT_AIR) {
      if (!EFF_FLAGGED(ch, EFF_FLY) || GET_POS(ch) != POS_FLYING) {
        if (GET_POS(ch) == POS_FLYING)
          GET_POS(ch) = POS_STANDING;
        start_char_falling(ch);
      } else
        overweight_check(ch);
    } else if (GET_POS(ch) == POS_FLYING) {
       if (!EFF_FLAGGED(ch, EFF_FLY)) {
         if (!EVENT_FLAGGED(ch, EVENT_FALLTOGROUND)) {
           SET_FLAG(GET_EVENT_FLAGS(ch), EVENT_FALLTOGROUND);
           event_create(EVENT_FALLTOGROUND, falltoground_event,
               ch, FALSE, &(ch->events), 0);
         }
       } else {
         overweight_check(ch);
      }
    }
    composition_check(ch);
    alter_pos(ch, GET_POS(ch), GET_STANCE(ch));
  }
}


/* Insert an effect in a char_data structure
   Automatically sets apropriate bits and apply's */
void effect_to_char(struct char_data * ch, struct effect *eff)
{
  struct effect *effect_alloc;

  CREATE(effect_alloc, struct effect, 1);

  *effect_alloc = *eff;
  effect_alloc->next = ch->effects;
  ch->effects = effect_alloc;

  effect_modify(ch, eff->location, eff->modifier, eff->flags, TRUE);

  effect_total(ch);
}


/*
 * Remove an effect structure from a char (called when duration
 * reaches zero). Pointer *eff must never be NIL!  Frees mem and calls
 * effect_total
 */
void effect_remove(struct char_data * ch, struct effect *eff)
{
  struct effect *temp;

  assert(ch->effects);

  effect_modify(ch, eff->location, eff->modifier, eff->flags, FALSE);

  REMOVE_FROM_LIST(eff, ch->effects, next);
  free(eff);
  effect_total(ch);
}



/* Call effect_remove with every spell of spelltype "skill" */
void effect_from_char(struct char_data * ch, int type)
{
  struct effect *hjp, *next;

  for (hjp = ch->effects; hjp; hjp = next) {
    next = hjp->next;
    if (hjp->type == type)
      effect_remove(ch, hjp);
  }
}

/* Call active_effect_remove with every spell of spelltype "skill"
 *
 * This function allows you to remove spells/skills and send the
 * wearoff message. */
void active_effect_from_char(struct char_data * ch, int type)
{
  struct effect *hjp, *next;

  for (hjp = ch->effects; hjp; hjp = next) {
    next = hjp->next;
    if (hjp->type == type)
      active_effect_remove(ch, hjp);
  }
}

void lose_levitation_messages(struct char_data *ch)
{
   if (GET_POS(ch) >= POS_STANDING) {
      cprintf(ch, "%s\r\n", skills[SPELL_LEVITATE].wearoff);
      act("$n floats back to the ground.", TRUE, ch, 0, 0, TO_ROOM);
   } else {
      send_to_char("Your weight feels normal again.\r\n", ch);
   }
}

void active_effect_remove(struct char_data *ch, struct effect *effect)
{
   if (skills[effect->type].wearoff != NULL) {
      /* Whether to send a message about the spell going away: */

      /* Naturally, there has to be a message to send. */
      if (*skills[effect->type].wearoff &&

            /* But if the next effect is caused by the same spell, don't
             * send a message.  This way, we'll only send a dispel message
             * once per spell, even for spells that set multiple effects. */
            !(effect->next && effect->next->type == effect->type)) {

         if (GET_STANCE(ch) > STANCE_STUNNED && skills[effect->type].wearoff) {
            switch (effect->type) {
               case SPELL_LEVITATE:
                  lose_levitation_messages(ch);
                  break;
               default:
                  cprintf(ch, "%s\r\n", skills[effect->type].wearoff);
            }
         }
      }
   } else {
      sprintf(buf,
            "SYSERR: handler.c active_effect_remove() no wear-off message; effect->type = %d on %s.",
            effect->type, GET_NAME(ch));
      log("%s",buf);
   }

   effect_remove(ch, effect);
}


/*
 * Return if a char is affected by a spell (SPELL_XXX), NULL indicates
 * not affected
 */
bool affected_by_spell(struct char_data * ch, int type)
{
  struct effect *hjp;
  if (ch->effects == NULL)
    return FALSE;
  for (hjp = ch->effects; hjp; hjp = hjp->next)
    if (hjp->type == type)
      return TRUE;

  return FALSE;
}



void effect_join(struct char_data * ch, struct effect *eff,
                 bool add_dur, bool avg_dur, bool add_mod, bool avg_mod,
                 bool refresh)
{
  struct effect *hjp;
  int i;

  for (hjp = ch->effects; hjp; hjp = hjp->next)
    if (hjp->type == eff->type && hjp->location == eff->location) {
      if (add_dur)
        eff->duration += hjp->duration;
      if (avg_dur)
        eff->duration /= 2;
      if (!refresh)
        eff->duration = hjp->duration;

      if (add_mod)
        eff->modifier += hjp->modifier;
      if (avg_mod)
        eff->modifier /= 2;

      /* copy effect flags from hjp to eff */
      for (i = 0; i < NUM_EFF_FLAGS; ++i)
        if (IS_FLAGGED(hjp->flags, i))
          SET_FLAG(eff->flags, i);

      effect_remove(ch, hjp);
      effect_to_char(ch, eff);
      return;
    }

  /* A matching affect was not found above. */
  effect_to_char(ch, eff);
}

/* init_char()
 *
 * Initialize a character according to class and race.
 * For new characters only! */

void init_char(struct char_data *ch)
{
   init_char_class(ch);  /* class.c */
   init_char_race(ch);   /* races.c */
   update_char(ch);
}

/* update_char()
 *
 * Set up a character according to class and race.  Makes changes
 * that are ok for new or existing characters, unlike init_char().
 * Therefore, it's appropriate for when you change a character's
 * race, or they subclass or gain a level. */

void update_char(struct char_data *ch)
{
   update_skills(ch);       /* spells.c */
   update_char_class(ch);   /* class.c */
   update_char_race(ch);    /* races.c */
}

/* How many lights on this guy? */
int char_lightlevel(struct char_data *ch) {
   int j, llevel = 0;
   obj_data *obj, *next_obj;

   for (j = 0; j < NUM_WEARS; j++)
      if (GET_EQ(ch, j) != NULL && GET_OBJ_TYPE(GET_EQ(ch, j)) == ITEM_LIGHT &&
               GET_OBJ_VAL(GET_EQ(ch, j), VAL_LIGHT_LIT))
         llevel++;

   for (obj = ch->carrying; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, VAL_LIGHT_LIT))
         llevel++;
   }

   if (EFF_FLAGGED(ch, EFF_LIGHT))
     ++llevel;

   return llevel;
}

/* move a player out of a room */
void char_from_room(struct char_data * ch)
{
  struct char_data *temp;

  if (ch == NULL || ch->in_room == NOWHERE) {
    log("SYSERR: NULL or NOWHERE in handler.c, char_from_room");
    /*exit(1);*/
  }

  if (FIGHTING(ch) != NULL)
    stop_fighting(ch);
  stop_attackers(ch);

  world[ch->in_room].light -= char_lightlevel(ch);

  REMOVE_FROM_LIST(ch, world[ch->in_room].people, next_in_room);
  ch->in_room = NOWHERE;
  ch->next_in_room = NULL;
}


/* place a character in a room */
void char_to_room(struct char_data * ch, int room)
{
  EVENTFUNC(autodouse_event);
  void start_char_falling(struct char_data *ch);
  char ctrbuf[100];

  if (!ch) {
    log("SYSERR:handler.c:char_to_room() NULL char pointer");
  } else if (room < 0 || room > top_of_world) {
    sprintf(ctrbuf, "SYSERR: char_to_room: name)%s room)%d", GET_NAME(ch), room);
    log("%s", ctrbuf);
  } else {
    ch->next_in_room = world[room].people;
    world[room].people = ch;
    ch->in_room = room;

    world[room].light += char_lightlevel(ch);

    /* Kill flames immediately upon entering a water room */
    if (EFF_FLAGGED(ch, EFF_ON_FIRE) && IS_WATER(IN_ROOM(ch))) {
       event_create(EVENT_AUTODOUSE, autodouse_event,
             ch, FALSE, &(ch->events), 0);
    }

    if (SECT(room) == SECT_AIR)
      falling_check(ch);

    /* Quick aggro for players */
    else if (!ALONE(ch) && !IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_NOHASSLE)) {
      struct char_data *tch = find_aggr_target(ch);
      if (tch && number(0, 5))
        event_create(EVENT_QUICK_AGGRO, quick_aggro_event,
                     mkgenericevent(ch, tch, 0), TRUE, &(ch->events), 0);
    }
  }
}


/* give an object to a char   */
void obj_to_char(struct obj_data *object, struct char_data *ch)
{
  if (object && ch) {
    object->next_content = ch->carrying;
    ch->carrying = object;
    object->carried_by = ch;
    if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, VAL_LIGHT_LIT))
       world[ch->in_room].light++;
    object->in_room = NOWHERE;
    IS_CARRYING_W(ch) += GET_OBJ_WEIGHT(object);
    IS_CARRYING_N(ch)++;

    if (!IS_NPC(ch))
      SET_FLAG(PLR_FLAGS(ch), PLR_AUTOSAVE);
    if (PLAYERALLY(ch))
      stop_decomposing(object);
    overweight_check(ch);
  } else
    log("SYSERR:handler.c:obj_to_char() NULL obj or char");
}


/* take an object from a char */
void obj_from_char(struct obj_data *object)
{
  struct obj_data *temp;

  if (object == NULL) {
    log("SYSERR:handler.c:obj_from_char() NULL object");
    return;
  }
  if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, VAL_LIGHT_LIT))
      world[object->carried_by->in_room].light--;

  REMOVE_FROM_LIST(object, object->carried_by->carrying, next_content);

  if (!IS_NPC(object->carried_by))
    SET_FLAG(PLR_FLAGS(object->carried_by), PLR_AUTOSAVE);
  if (MORTALALLY(object->carried_by))
    start_decomposing(object);

  IS_CARRYING_W(object->carried_by) -= GET_OBJ_WEIGHT(object);
  IS_CARRYING_N(object->carried_by)--;
  object->carried_by = NULL;
  object->next_content = NULL;
}



/* Return the effect of a piece of armor in position eq_pos */
static int apply_ac(struct char_data * ch, int eq_pos)
{
  int factor;

  assert(GET_EQ(ch, eq_pos));

  if (GET_OBJ_TYPE(GET_EQ(ch, eq_pos)) != ITEM_ARMOR)
    return 0;

  switch (eq_pos) {

  case WEAR_BODY:
    factor = 1;
    break;                        /* 30% */
  case WEAR_HEAD:
    factor = 1;
    break;                        /* 20% */
  case WEAR_LEGS:
    factor = 1;
    break;                        /* 20% */
  default:
    factor = 1;
    break;                        /* all others 10% */
  }

  return (factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), VAL_ARMOR_AC));
}

void count_hand_eq(struct char_data *ch, int *hands_used, int *weapon_hands_used) {
   *hands_used = *weapon_hands_used = 0;
   if (GET_EQ(ch, WEAR_2HWIELD)) { (*hands_used) += 2; (*weapon_hands_used) += 2; }
   if (GET_EQ(ch, WEAR_HOLD))    (*hands_used)++;
   if (GET_EQ(ch, WEAR_HOLD2))   (*hands_used)++;
   if (GET_EQ(ch, WEAR_SHIELD))  (*hands_used)++;
   if (GET_EQ(ch, WEAR_WIELD))   { (*hands_used)++; (*weapon_hands_used)++; }
   if (GET_EQ(ch, WEAR_WIELD2))  { (*hands_used)++; (*weapon_hands_used)++; }
}


bool may_wear_eq(
      struct char_data * ch,   /* Who is trying to wear something */

      struct obj_data * obj,   /* The object being put on */

      int *where,              /* The position it should be worn at */

      bool sendmessage         /* Whether to send a rejection message to ch, if
                                  the item could not be worn. */
      )
{
   int a = 0, w = 0;
   /*
    * ITEM_WEAR_TAKE is used for objects that do not require special bits
    * to be put into that position (e.g. you can hold any object, not just
    * an object with a HOLD bit.)
    */
   const int wear_bitvectors[] = {
      ITEM_WEAR_TAKE, ITEM_WEAR_FINGER, ITEM_WEAR_FINGER, ITEM_WEAR_NECK,
      ITEM_WEAR_NECK, ITEM_WEAR_BODY, ITEM_WEAR_HEAD, ITEM_WEAR_LEGS,
      ITEM_WEAR_FEET, ITEM_WEAR_HANDS, ITEM_WEAR_ARMS, ITEM_WEAR_SHIELD,
      ITEM_WEAR_ABOUT, ITEM_WEAR_WAIST, ITEM_WEAR_WRIST, ITEM_WEAR_WRIST,
      ITEM_WEAR_WIELD, ITEM_WEAR_WIELD, ITEM_WEAR_HOLD, ITEM_WEAR_HOLD,
      ITEM_WEAR_2HWIELD, ITEM_WEAR_EYES, ITEM_WEAR_FACE, ITEM_WEAR_EAR,
      ITEM_WEAR_EAR, ITEM_WEAR_BADGE, ITEM_WEAR_OBELT
   };

   char *already_wearing[] = {
      "You're already using a light.\r\n",
      "YOU SHOULD NEVER SEE THIS MESSAGE.   PLEASE REPORT.\r\n",
      "You're already wearing something on both of your ring fingers.\r\n",
      "YOU SHOULD NEVER SEE THIS MESSAGE.   PLEASE REPORT.\r\n",
      "You can't wear anything else around your neck.\r\n",
      "You're already wearing something on your body.\r\n",
      "You're already wearing something on your head.\r\n",
      "You're already wearing something on your legs.\r\n",
      "You're already wearing something on your feet.\r\n",
      "You're already wearing something on your hands.\r\n",
      "You're already wearing something on your arms.\r\n",
      "You're already using a shield.\r\n",
      "You're already wearing something about your body.\r\n",
      "You already have something around your waist.\r\n",
      "YOU SHOULD NEVER SEE THIS MESSAGE.   PLEASE REPORT.\r\n",
      "You're already wearing something around both of your wrists.\r\n",
      "You're already wielding a weapon.\r\n",
      "You're already wielding a weapon there!\r\n",
      "You're already holding something.\r\n",
      "You're already holding something.\r\n",
      "You're already wielding a weapon.\r\n",
      "You're already wearing something on your eyes.\r\n",
      "You're already wearing something on your face.\r\n",
      "YOU SHOULD NEVER SEE THIS REPORT IT!.\r\n",
      "You're already wearing something in both of your ears.\r\n",
      "You're already wearing a badge.\r\n",
      "You can't attach any more to your belt.\r\n"
   };

    /* first, make sure that the wear position is valid. */
    /* Only allow light items in the light pos, and then only
         when they cannot be worn anywhere else. */
    if (!CAN_WEAR(obj, wear_bitvectors[*where]) ||
             (*where == 0 && GET_OBJ_TYPE(obj) != ITEM_LIGHT) ||
             (*where == 0 && GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
             GET_OBJ_WEAR(obj) != ITEM_WEAR_TAKE + ITEM_WEAR_HOLD)) {
         if (!(IS_NPC(ch)) && sendmessage)
             act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
         return FALSE;
   }

   /* for neck, finger, wrist, held, and wielded, try pos 2 if pos 1 is already full */

   if ((*where == WEAR_FINGER_R) || (*where == WEAR_NECK_1) || (*where == WEAR_WRIST_R) ||
         (*where == WEAR_HOLD) || (*where == WEAR_LEAR) || (*where == WEAR_WIELD))
      if (GET_EQ(ch, *where))
         (*where)++;

   /* for shield, weapon, or held, must make sure the right number of hands are free */

   if ((*where == WEAR_SHIELD) || (*where == WEAR_WIELD) || (*where == WEAR_WIELD2) ||
         (*where == WEAR_HOLD) || (*where == WEAR_HOLD2) || (*where == WEAR_2HWIELD)) {

      /* a = hands occupied; w = hands wielding a weapon */
      count_hand_eq(ch, &a, &w);

      if ((GET_OBJ_WEAR(obj) & ITEM_WEAR_2HWIELD) && a) {
         if (sendmessage)
            send_to_char("You need both hands free for this weapon!\r\n",ch);
         return FALSE;
      } else if (a > 1) {
         if (sendmessage)
            send_to_char("Both of your hands are already using something.\r\n", ch);
         return FALSE;
      } else if (a == 1 && w > 0 && (*where == WEAR_WIELD || *where == WEAR_WIELD2) &&
            !(GET_SKILL(ch, SKILL_DUAL_WIELD))) {
         if (sendmessage)
            send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
         return FALSE;
      }
   }

   /* If something is in that position, you can't wear something else there. */
   if (GET_EQ(ch, *where)) {
      if (sendmessage)
         send_to_char(already_wearing[*where], ch);
      return FALSE;
   }

   /* The NO_EQ_RESTRICT flag overrides the remaining considerations. */
   if (IS_NPC(ch) && MOB_FLAGGED(ch, MOB_NO_EQ_RESTRICT))
      return TRUE;

   /* Check the level of the object. */
   if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
      if (!IS_NPC(ch) && sendmessage) {
         act("You're not a high enough level to use $p.",
             FALSE, ch, obj, 0, TO_CHAR);
         act("$n struggles and fails to use $p.", TRUE, ch, obj, 0, TO_ROOM);
      }
      return FALSE;
   }

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      /* Check alignment restrictions. */
      if ((OBJ_FLAGGED(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
          (OBJ_FLAGGED(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
          (OBJ_FLAGGED(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
           NOWEAR_CLASS(ch, obj)) {
         if (sendmessage)
            act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
         return FALSE;
      }

      if (GET_OBJ_TYPE(obj)== ITEM_WEAPON && GET_OBJ_WEIGHT(obj) > str_app[GET_STR(ch)].wield_w) {
         if (sendmessage)
            send_to_char("It's too heavy for you to use.\r\n", ch);
         return FALSE;
      }
   }

   /* You can only wear something on your belt if you are wearing a belt. */
   if (*where == WEAR_OBELT && !GET_EQ(ch, WEAR_WAIST)) {
      if (sendmessage)
         act("You'll need to wear a belt first.",
             FALSE, ch, obj, 0, TO_CHAR);
      return FALSE;
   }

   return TRUE;
}

enum equip_result equip_char(struct char_data * ch, struct obj_data * obj, int pos)
{
   int j;

   assert(pos >= 0 && pos < NUM_WEARS);

   if (GET_EQ(ch, pos)) {
      mprintf(L_ERROR, LVL_GOD, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
              obj->short_description);
      return EQUIP_RESULT_ERROR;
   }
   if (obj->carried_by) {
      mprintf(L_ERROR, LVL_GOD, "SYSERR: EQUIP: Obj is carried_by when equip.");
      return EQUIP_RESULT_ERROR;
   }
   if (obj->in_room != NOWHERE) {
      mprintf(L_ERROR, LVL_GOD, "SYSERR: EQUIP: Obj is in_room when equip.");
      return EQUIP_RESULT_ERROR;
   }

   GET_EQ(ch, pos) = obj;
   obj->worn_by = ch;
   obj->worn_on = pos;

   if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
      GET_AC(ch) -= apply_ac(ch, pos);

    if (ch->in_room != NOWHERE) {
         if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, VAL_LIGHT_LIT))
             world[ch->in_room].light++;
    } else
         mprintf(L_ERROR, LVL_GOD, "SYSERR: ch->in_room = NOWHERE when equipping char.");


    for (j = 0; j < MAX_OBJ_APPLIES; j++)
         effect_modify(ch, obj->applies[j].location,
                           obj->applies[j].modifier,
                           GET_OBJ_EFF_FLAGS(obj), TRUE);

   if (PLAYERALLY(ch))
     stop_decomposing(obj);
   IS_CARRYING_W(ch) += GET_OBJ_WEIGHT(obj);
   effect_total(ch);
   return EQUIP_RESULT_SUCCESS;
}


struct obj_data *unequip_char(struct char_data * ch, int pos)
{
  int j;
  struct obj_data *obj;

  assert(pos >= 0 && pos < NUM_WEARS);
  assert(GET_EQ(ch, pos));

  obj = GET_EQ(ch, pos);
  obj->worn_by = NULL;
  obj->worn_on = -1;

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
    GET_AC(ch) += apply_ac(ch, pos);

  if (ch->in_room != NOWHERE) {
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
        GET_OBJ_VAL(obj, VAL_LIGHT_LIT))
      world[ch->in_room].light--;
  } else
    log("SYSERR: ch->in_room = NOWHERE when unequipping char.");

  GET_EQ(ch, pos) = NULL;
  IS_CARRYING_W(ch) -= GET_OBJ_WEIGHT(obj);

  /* Reapply all the racial effects in case they were removed above. */
  update_char(ch);

  for (j = 0; j < MAX_OBJ_APPLIES; j++)
    effect_modify(ch, obj->applies[j].location,
                  obj->applies[j].modifier,
                  obj->obj_flags.effect_flags, FALSE);

  if (MORTALALLY(ch))
    start_decomposing(obj);
  effect_total(ch);
  return (obj);
}


EVENTFUNC(sink_and_lose_event)
{
   struct sink_and_lose *data = (struct sink_and_lose *)event_obj;
   struct obj_data *obj = data->obj;
   int room = data->room;
   char *conjugation;

   if (obj->in_room == room) {
      if (isplural(GET_OBJ_NAME(obj)))
         conjugation = "";
      else
         conjugation = "s";
      act("$p&4&b sink$T like a rock.&0", FALSE, 0, obj, conjugation, TO_ROOM);
      extract_obj(obj);
   }

   return EVENT_FINISHED;
}

/* put an object in a room */
void obj_to_room(struct obj_data *object, int room)
{
  void start_obj_falling(struct obj_data *obj);
  char otrbuf[50];
  struct sink_and_lose *sinkdata;

  if (!object) {
    log("SYSERR: NULL object pointer passed to obj_to_room");
  } else if (room < 0 || room > top_of_world) {
    sprintf(otrbuf, "SYSERR: obj_to_room: obj)%d room)%d", GET_OBJ_VNUM(object), room);
    log("%s", otrbuf);
  } else {
    object->next_content = world[room].contents;
    world[room].contents = object;
    object->in_room = room;
    object->carried_by = NULL;
    if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, VAL_LIGHT_LIT))
      world[object->in_room].light++;

    /* Falling or sinking - the !FALL flag prevents both */
    if (!OBJ_FLAGGED(object, ITEM_NOFALL)) {
      /* Will the object sink in water? */
      if ((SECT(room) == SECT_SHALLOWS || SECT(room) == SECT_WATER) &&
          (!OBJ_FLAGGED(object, ITEM_FLOAT))) {
        /* Yep, say goodbye. */
        CREATE(sinkdata, struct sink_and_lose, 1);
        sinkdata->room = room;
        sinkdata->obj = object;
        event_create(EVENT_SINK_AND_LOSE, &sink_and_lose_event, sinkdata,
              TRUE, &(object->events), 2);
        return;
      } else if (SECT(room) == SECT_AIR)
        start_obj_falling(object);

      if (ROOM_FLAGGED(room, ROOM_HOUSE))
        SET_FLAG(ROOM_FLAGS(room), ROOM_HOUSE_CRASH);
      /* if this is a player corpse, save the new room vnum to
         the corpse control record. This can later be optimized as
         a flag, much like houses  -  nechtrous */
      if (IS_PLR_CORPSE(object))
        update_corpse(object);
    }
  }
}


/* Take an object from a room */
void obj_from_room(struct obj_data * object)
{
  struct obj_data *temp;

  if (!object || object->in_room == NOWHERE) {
    log("SYSERR:handler.c:obj_from_room() NULL obj or obj->in_room = -1");
    return;
  }

  if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, VAL_LIGHT_LIT))
    world[object->in_room].light--;

  REMOVE_FROM_LIST(object, world[object->in_room].contents, next_content);

  if (ROOM_FLAGGED(object->in_room, ROOM_HOUSE))
    SET_FLAG(ROOM_FLAGS(object->in_room), ROOM_HOUSE_CRASH);
  object->in_room = NOWHERE;
  object->next_content = NULL;
}


/* put an object in an object (quaint)  */
void obj_to_obj(struct obj_data *obj, struct obj_data *obj_to)
{
  struct obj_data *tmp_obj;

  if (!obj || !obj_to || obj == obj_to) {
    log("SYSERR: NULL object or same source and target obj passed to obj_to_obj");
    return;
  }

  obj->next_content = obj_to->contains;
  obj_to->contains = obj;
  obj->in_obj = obj_to;

  for (tmp_obj = obj->in_obj; tmp_obj->in_obj; tmp_obj = tmp_obj->in_obj)
    GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);

  /* top level object.  Subtract weight from inventory if necessary. */
  GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);
  if (tmp_obj->carried_by) {
    IS_CARRYING_W(tmp_obj->carried_by) += GET_OBJ_WEIGHT(obj);
    if (PLAYERALLY(tmp_obj->carried_by))
      stop_decomposing(obj);
  } else if (tmp_obj->worn_by) {
    IS_CARRYING_W(tmp_obj->worn_by) += GET_OBJ_WEIGHT(obj);
    if (PLAYERALLY(tmp_obj->worn_by))
      stop_decomposing(obj);
  }
}


/* remove an object from an object */
void obj_from_obj(struct obj_data * obj)
{
  struct obj_data *temp, *obj_from;
  extern int short_pc_corpse_time;

  if (obj->in_obj == NULL) {
    log("error (handler.c): trying to illegally extract obj from obj");
    return;
  }
  obj_from = obj->in_obj;
  REMOVE_FROM_LIST(obj, obj_from->contains, next_content);

  /* Subtract weight from containers container */
  for (temp = obj->in_obj; temp->in_obj; temp = temp->in_obj)
    GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);

  /* Subtract weight from char that carries the object */
  GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);
  if (temp->carried_by)
    IS_CARRYING_W(temp->carried_by) -= GET_OBJ_WEIGHT(obj);
  else if (temp->worn_by)
    IS_CARRYING_W(temp->worn_by) -= GET_OBJ_WEIGHT(obj);

  obj->in_obj = NULL;
  obj->next_content = NULL;

  /* to fix some eq duping, if obj_from is a pcorpse, save the corpse */
  if (IS_PLR_CORPSE(obj_from)) {
    save_corpse(obj_from);
    /* When you remove all objects from a PC corpse, its decomp time shortens */
    if (!obj_from->contains && GET_OBJ_DECOMP(obj_from) > short_pc_corpse_time)
      GET_OBJ_DECOMP(obj_from) = short_pc_corpse_time;
  }
}


/* Global object iterator
 *
 * Helps the object extractor in limits.c to iterate over all objects
 * in the world while destroying some of them. */

struct obj_data *go_iterator = NULL;

/* Extract an object from the world */
void extract_obj(struct obj_data * obj)
{
  struct obj_data *temp;

  if (obj->casters)
    obj_forget_casters(obj);
  /* rewriting to use IS_PLR_CORPSE macro - 321 */
  if (IS_PLR_CORPSE(obj)) {
    destroy_corpse(obj);
    /* Log when a player corpse decomposes so people can't
       falsely claim the code ate their corpse. RSD 11/12/2000
     */
    if (obj->in_room != NOWHERE)
      log("CORPSE: %s has been extracted from %s [%d]",
          obj->short_description, world[obj->in_room].name,
          world[obj->in_room].vnum);
    else if (obj->in_obj)
      log("CORPSE: %s has been extracted from inside %s",
          obj->short_description, obj->in_obj->short_description);
    else if (obj->carried_by)
      log("CORPSE: %s has been extracted from %s's inventory",
          obj->short_description, GET_NAME(obj->carried_by));
    else
      log("CORPSE: %s has been extracted from an unknown location",
          obj->short_description);
  }
  if (obj->worn_by != NULL)
    if (unequip_char(obj->worn_by, obj->worn_on) != obj)
      log("SYSERR: Inconsistent worn_by and worn_on pointers!!");

  if (obj->in_room != NOWHERE)
    obj_from_room(obj);
  else if (obj->carried_by)
    obj_from_char(obj);
  else if (obj->in_obj)
    obj_from_obj(obj);

  /* Get rid of the contents of the object, as well. */
  while (obj->contains)
    extract_obj(obj->contains);

  if (obj == go_iterator)
     go_iterator = obj->next;

  REMOVE_FROM_LIST(obj, object_list, next);

  if (GET_OBJ_RNUM(obj) != NOTHING)
    (obj_index[GET_OBJ_RNUM(obj)].number)--;

  if (obj->events)
     cancel_event_list(&(obj->events));

  free_obj(obj);
}


void purge_objs(struct char_data *ch)
{
   int i;

   while (ch->carrying)
      extract_obj(ch->carrying);

   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i))
         extract_obj(GET_EQ(ch, i));
}


/* Extract a ch completely from the world, and leave his stuff behind  */
void extract_char(struct char_data * ch)
{
  struct char_data *temp;
  struct descriptor_data *d;
  struct obj_data *obj;
  int i, freed = 0;
  void dismount_char(struct char_data *ch);
  void stop_guarding(struct char_data *ch);
  ACMD(do_return);
  void die_groupee(struct char_data *ch);
  void die_consentee_clean(struct char_data *ch);

  if (ch->in_room == NOWHERE) {
    sprintf(buf, "SYSERR:handler.c:extract_char: NOWHERE extracting char: %s", GET_NAME(ch));
    log("%s",buf);
  }

  /*
   * Booting the (original) character of someone who has switched out, so
   * first we need to stuff them back into their own body.  This will set
   * ch->desc to the proper value below.
   */
  if (!IS_NPC(ch) && !ch->desc)
    for (d = descriptor_list; d; d = d->next)
      if (d->original == ch) {
        do_return(d->character, "", 0, 1);
        break;
      }

  /*
   * Now check to see if there is someone switched into this body
   * from another one, if so; put the switcher back into their own
   * body.
   */
  if (POSSESSED(ch))
    do_return(ch, NULL, 0, 0);

  die_consentee_clean(ch);

  if (ch->followers || ch->master)
    die_follower(ch);

  if (IS_GROUPED(ch))
    ungroup(ch, TRUE, FALSE);

  if (RIDING(ch) || RIDDEN_BY(ch))
    dismount_char(ch);

  if (ch->guarding)
    stop_guarding(ch);
  if (ch->guarded_by)
    stop_guarding(ch->guarded_by);

  if (ch->cornering) {
    if (ch->cornering->cornered_by == ch)
      ch->cornering->cornered_by = NULL;
    ch->cornering = NULL;
  }
  if (ch->cornered_by) {
    if (ch->cornered_by->cornering == ch)
      ch->cornered_by->cornering = NULL;
    ch->cornering = NULL;
  }
  /* Forget snooping, if applicable */
  if (ch->desc) {
    if (ch->desc->snooping) {
      ch->desc->snooping->snoop_by = NULL;
      ch->desc->snooping = NULL;
    }
    if (ch->desc->snoop_by) {
      write_to_output("Your victim is no longer among us.\r\n",
                      ch->desc->snoop_by);
      ch->desc->snoop_by->snooping = NULL;
      ch->desc->snoop_by = NULL;
    }
  }

  /* Make any spells being cast upon me abort */
  if (ch->casters)
     char_forget_casters(ch);

  if (CASTING(ch)) {
    STOP_CASTING(ch);
  }

  /* transfer objects to room */
  while (ch->carrying) {
    obj = ch->carrying;
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
  }

  /* Remove runtime link to clan */
  if (GET_CLAN_MEMBERSHIP(ch))
    GET_CLAN_MEMBERSHIP(ch)->player = NULL;

  /* transfer equipment to room */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_room(unequip_char(ch, i), ch->in_room);

  char_from_room(ch);

  /* pull the char from the list */
  REMOVE_FROM_LIST(ch, character_list, next);

  /*
   * Take out events now, since the character may not be freed
   * below (in the case of players).
   */
  if (ch->events)
    cancel_event_list(&(ch->events));
  for (i = 0; i < EVENT_FLAG_FIELDS; ++i)
    ch->event_flags[i] = 0;

  if (!IS_NPC(ch)) {
    ch->in_room = NOWHERE;
    if (!PLR_FLAGGED(ch, PLR_REMOVING))
       save_player(ch);
  } else {
    /* if mobile, and wasn't raised from the dead, decrease load count */
    if (GET_MOB_RNUM(ch) > -1 && !MOB_FLAGGED(ch, MOB_ANIMATED))
      mob_index[GET_MOB_RNUM(ch)].number--;
    free_char(ch);
    freed = 1;
  }

  if (!freed && ch->desc != NULL) {
    STATE(ch->desc) = CON_MENU;
    write_to_output(MENU, ch->desc);
  } else {  /* if a player gets purged from within the game */
    if (!freed)
      free_char(ch);
  }
}


/***************************************************************************
 * $Log: handler.c,v $
 * Revision 1.164  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.163  2010/06/05 04:43:57  mud
 * Replacing ocean sector type with cave.
 *
 * Revision 1.162  2009/06/09 05:40:10  myc
 * Remove runtime link to clan when character is extracted.
 *
 * Revision 1.161  2009/05/22 17:56:14  myc
 * Fix verb conjugation for plural items when they sink in the water.
 *
 * Revision 1.160  2009/03/15 07:09:24  jps
 * Add !FALL flag for objects
 *
 * Revision 1.159  2009/03/09 20:36:00  myc
 * Moved money functions from here to money.c.
 *
 * Revision 1.158  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.157  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.156  2009/03/07 22:28:27  jps
 * Add function active_effect_from_char, which is called to remove effects
 * in-game and provide feedback.
 *
 * Revision 1.155  2009/03/03 19:43:44  myc
 * Split off target-finding protocol from handler into find.c.
 *
 * Revision 1.154  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default;
 * assert L_NOFILE to prevent that.
 *
 * Revision 1.153  2009/01/17 01:17:33  myc
 * Fix that "cleric ac bug".  AC will now be added and deducted
 * from mobs correctly.
 *
 * Revision 1.152  2009/01/16 23:36:34  myc
 * Correct typo in error message in active_effect_remove().
 *
 * Revision 1.151  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.150  2008/09/20 09:07:48  jps
 * Remove extra flight-loss messages.
 *
 * Revision 1.149  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.148  2008/09/13 18:52:12  jps
 * Including ai.h
 *
 * Revision 1.147  2008/09/08 05:18:00  jps
 * obj_to_obj needs to stop decomposing things if a player is carrying the container.
 *
 * Revision 1.146  2008/09/07 07:55:17  jps
 * Make obj_to_obj and obj_from_obj adjust weight amounts when the
 * enclosing container is being worn.
 *
 * Revision 1.145  2008/09/07 07:20:28  jps
 * Using MORTALALLY for the events that might cause decomposition to start.
 * This means that immortals won't cause items to start decomposing by
 * handling them. It also means that they can stop things decomposing by
 * grabbing them and then getting rid of them.
 *
 * Revision 1.144  2008/09/07 01:30:47  jps
 * Handle losing fly. You might fall to the ground, or fall farther.
 *
 * Revision 1.143  2008/09/06 19:10:49  jps
 * Use PLAYERALLY when deciding if objects should decompose.
 * Control decomposition when wearing equipment.
 *
 * Revision 1.142  2008/09/06 05:49:37  jps
 * Make worn equipment count towards weight-carried as well.
 *
 * Revision 1.141  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.140  2008/09/04 00:23:43  myc
 * Add newlines to fly and levitate wearoff messages.
 *
 * Revision 1.139  2008/09/02 07:16:00  mud
 * Changing object TIMER uses into DECOMP where appropriate
 *
 * Revision 1.138  2008/09/02 06:51:20  jps
 * Objects removed from players start decomposing and those being added to
 * players stop decomposing.
 *
 * Revision 1.137  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.136  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.135  2008/08/31 22:16:21  myc
 * Fixed hp by bypassing alter_hit and modifying hitpoints directly.
 *
 * Revision 1.134  2008/08/31 18:38:33  myc
 * Consider HP in effect_total before removing effects.
 *
 * Revision 1.133  2008/08/31 04:34:12  myc
 * Fixing HP again.
 *
 * Revision 1.132  2008/08/31 02:20:48  myc
 * Fix faulty handling of hitpoints in effect_total.
 *
 * Revision 1.131  2008/08/31 01:42:22  myc
 * Fix ARMOR applies so they subtract instead of add.
 *
 * Revision 1.130  2008/08/31 01:19:54  jps
 * You screwed up holding items in slots with two of the same position!
 * Fix.
 *
 * Revision 1.129  2008/08/30 22:02:42  myc
 * Actions affecting corpses just go to the syslog now, not the RIP log.
 *
 * Revision 1.128  2008/08/30 20:25:38  jps
 * Moved count_hand_eq() into handler.c and mentioned it in handler.h.
 *
 * Revision 1.127  2008/08/30 20:21:07  jps
 * Moved equipment-wearability checks into function may_wear_eq() and moved
 * it to handler.c.
 *
 * Revision 1.126  2008/08/30 18:20:53  myc
 * Changed an object rnum check to compare against NOTHING constant.
 *
 * Revision 1.125  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.124  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.123  2008/08/17 08:11:56  jps
 * Logging equip errors to file.
 *
 * Revision 1.122  2008/08/17 06:50:34  jps
 * equip_char will return one of several result codes, indicating success,
 * failure, or bad error. It uses mprintf for logging.
 *
 * Revision 1.121  2008/07/27 05:25:55  jps
 * extract_char will save players who are being extracted, but only if they
 * are not being explicitly removed.
 *
 * Revision 1.120  2008/07/10 20:21:46  myc
 * unequip_char was making the wrong assertion.  Fixzored!
 *
 * Revision 1.119  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.118  2008/06/05 02:07:43  myc
 * Changed object flags to use flagvectors.  Rewrote corpse saving and
 * loading to use ascii object files.
 *
 * Revision 1.117  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.116  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.115  2008/05/14 05:12:26  jps
 * alter_hit doesn't take the attacker any more.
 *
 * Revision 1.114  2008/05/11 07:12:40  jps
 * Moved active_effect_remove here, which is what you call when a spell
 * goes away. Modified it to handle some spells differently: fly and levitate.
 *
 * Revision 1.113  2008/05/11 05:49:48  jps
 * Using regen.h. alter_hit() takes the killer. alter_pos is now the way
 * to change position.
 *
 * Revision 1.112  2008/04/14 05:11:40  jps
 * Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
 * to fly - not that the characer is actually flying.
 *
 * Revision 1.111  2008/04/14 02:18:57  jps
 * Removing unused function prototype.
 *
 * Revision 1.110  2008/04/13 01:41:39  jps
 * Calling composition_check() which makes sure no fluid/rigid
 * mount/rider pairs are possible.
 *
 * Revision 1.109  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.108  2008/04/02 04:55:59  myc
 * Made the disband group message show up when extracting a char.
 *
 * Revision 1.107  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.
 *
 * Revision 1.106  2008/04/01 00:13:09  jps
 * Perform in_room check during effect_total.
 *
 * Revision 1.105  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.104  2008/03/29 17:34:55  myc
 * Autodouse event memory leak.
 *
 * Revision 1.103  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.102  2008/03/24 02:28:37  jps
 * Fix autodouse event bug.
 *
 * Revision 1.101  2008/03/23 00:27:38  jps
 * Implement the composition apply.
 *
 * Revision 1.100  2008/03/21 22:52:52  jps
 * Reset TRANSIENT objects' timers when they are placed in a room,
 * not when they are picked up.  Prior to this, TRANSIENT objects
 * would tend to dissolve in under an hour if not picked up, which
 * was really too short.
 *
 * Revision 1.99  2008/03/21 14:54:19  myc
 * Added freeing of the event list back to extract char, fixing the
 * death crash bug.
 *
 * Revision 1.98  2008/03/19 04:32:14  myc
 * Removed a bunch of frag code that was simply commented out before.
 *
 * Revision 1.97  2008/03/16 00:21:53  jps
 * Updated trophy code.
 *
 * Revision 1.96  2008/03/11 02:53:41  jps
 * Use adjust_size instead of direct modification.
 *
 * Revision 1.95  2008/03/10 18:01:17  myc
 * Quick aggro won't go off if you are flagged no hassle.
 *
 * Revision 1.94  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.93  2008/03/08 23:20:06  myc
 * Free events in free_char instead of in extract_char.
 *
 * Revision 1.92  2008/03/05 05:21:56  myc
 * Removed frags.
 *
 * Revision 1.91  2008/03/05 03:03:54  myc
 * Moved the trophy_update function to players.c and updated
 * perform_trophy_decrease for the new trophy structures.  Reversed
 * the order of scale_attribs and update_stats calls in affect_total
 * so it isn't stupid.
 *
 * Revision 1.90  2008/02/16 20:31:32  myc
 * Moving script extraction from extract_char/extract_obj to
 * free_char/free_obj.  Moving clear_quest list to free_char.
 * Moving clear_memory to free_char.
 *
 * Revision 1.89  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.
 *
 * Revision 1.88  2008/02/09 18:29:11  myc
 * The event code now handles freeing of event objects.
 *
 * Revision 1.87  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.86  2008/01/30 19:20:57  myc
 * Gravity is now an event, triggered whenever a character or object
 * enters a room, or when a character loses fly.
 *
 * Revision 1.85  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.84  2008/01/27 23:31:20  jps
 * Fix stop-casting for extracted chars.
 *
 * Revision 1.83  2008/01/27 13:40:58  jps
 * Removing unused function prototype scale_attribs().
 *
 * Revision 1.82  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.81  2008/01/26 07:27:27  jps
 * Stop a char from casting any spells as it's extracted.
 *
 * Revision 1.80  2008/01/17 04:10:07  myc
 * Updating get_obj_by_obj() and get_char_room_mscript() to check
 * UIDs against the calling object and char (since find_replacement
 * now returns a UID for the object/char instead of "self" now).
 *
 * Revision 1.79  2008/01/16 04:12:00  myc
 * Adding quick-aggro event.
 *
 * Revision 1.78  2008/01/14 21:28:54  myc
 * Disabled player "quick-aggro".
 *
 * Revision 1.77  2008/01/12 23:13:20  myc
 * Added multi-purpose get_random_char_around function to pick random chars
 * in a room.  Renamed clearMemory clear_memory.
 *
 * Revision 1.76  2008/01/12 19:08:14  myc
 * Rewrote a lot of mob AI functionality.
 * Renamed 'picktarget' as 'pick_target'.
 *
 * Revision 1.75  2008/01/10 05:39:43  myc
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.74  2008/01/09 01:51:42  jps
 * Get rid of obsolete points events.
 *
 * Revision 1.73  2008/01/06 05:32:56  jps
 * Use macro NOWEAR_CLASS for equipment restrictions.
 *
 * Revision 1.72  2008/01/05 05:37:31  jps
 * Added function init_char() to handle updating of class and race-
 * related skills, innates, and other stuff.
 *
 * Revision 1.71  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.70  2007/12/25 19:45:55  jps
 * Move flying check from affect_modify to affect_total so it doesn't get
 * executed as much.
 *
 * Revision 1.69  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.68  2007/12/23 19:27:26  jps
 * Use global object iterator to prevent decay events from operating on
 * already-extracted objects.
 *
 * Revision 1.67  2007/12/19 20:51:38  myc
 * save_player() no longer requires you to supply a save/load room
 * (which wasn't being used anyway).
 *
 * Revision 1.66  2007/12/09 03:31:46  jps
 * Add a position check - it will force the position to be updated
 * correctly when you use the wizard command 'set', among other situations.
 *
 * Revision 1.65  2007/11/25 00:04:59  jps
 * Spell targets will keep close track of whoever's casting a spell
 * at them.  This allows spells to be safely aborted if the target
 * is removed from the game before the spell is completed.
 *
 * Revision 1.64  2007/10/26 23:49:30  myc
 * AC applies should be negative.
 *
 * Revision 1.63  2007/10/25 20:39:11  myc
 * Fixed a bug where the corpse decomposition message expected the
 * corpse to be on the ground.  Not always true.
 *
 * Revision 1.62  2007/10/11 20:14:48  myc
 * Fixed some bugs in the behavior of affect_join when doing "refresh"
 * spells.
 *
 * Revision 1.61  2007/10/04 16:20:24  myc
 * Got rid of update_char_objects, because all objects are being updated
 * by point_update in limits.c
 *
 * Revision 1.60  2007/10/02 02:52:27  myc
 * Cleaned up extract_char.
 *
 * Revision 1.59  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Fixed a lot of affect-handling
 * code to work more smoothly (and sanely).
 *
 * Revision 1.58  2007/09/15 15:36:48  myc
 * Cleaned up affect-handling code a lot.  It didn't properly handle
 * bitvectors 1, 2, and 3.  Now it does.
 *
 * Revision 1.57  2007/09/03 22:53:54  jps
 * Make a person's flames go out automatically if they enter a water room.
 *
 * Revision 1.56  2007/09/01 21:22:29  jps
 * Made _mscript detection routines.
 *
 * Revision 1.55  2007/09/01 20:45:47  jps
 * Fix!
 *
 * Revision 1.54  2007/09/01 20:34:10  jps
 * Add function get_char_in_room, which bypasses CAN_SEE, for
 * scripting m* commands.
 *
 * Revision 1.53  2007/08/30 20:00:09  jps
 * Oops, purge_objs wasn't actually purging.
 *
 * Revision 1.52  2007/08/30 19:42:46  jps
 * Add function purge_objs() to destroy all objects on a character.
 *
 * Revision 1.51  2007/08/14 22:43:07  myc
 * Added cornering/cornered_by clean-up to extract_char.
 *
 * Revision 1.50  2007/07/25 02:57:26  myc
 * Only set crashsave bit in obj_from_char for players.
 *
 * Revision 1.49  2007/07/24 01:24:37  myc
 * AFF2_LIGHT on objects will no longer cause permadarkened rooms.
 *
 * Revision 1.48  2007/07/14 01:42:38  jps
 * Stop trying to set the PLR_CRASH bit on NPCs when they receive an object.
 *
 * Revision 1.47  2007/04/11 14:15:28  jps
 * Give money piles proper keywords and make them dissolve when stolen.
 *
 * Revision 1.46  2006/12/07 02:34:42  myc
 * Aff2 Light flag won't cause permadark anymore.
 *
 * Revision 1.45  2006/12/04 17:56:29  myc
 * Fixed a crash bug with update_char_object, containers, and recursive looping.
 *
 * Revision 1.44  2006/11/21 03:45:52  jps
 * Running down of lights is now handled in limits.c.
 *
 * Revision 1.43  2006/11/20 22:24:17  jps
 * End the difficulties in interaction between evil and good player races.
 *
 * Revision 1.42  2006/11/18 07:36:48  jps
 * Specify what light object is burning out.
 *
 * Revision 1.41  2006/11/18 04:26:32  jps
 * Renamed continual light spell to illumination, and it only works on
 * LIGHT items (still rooms too).
 *
 * Revision 1.40  2006/11/18 00:03:31  jps
 * Fix continual light items to always work when they have the
 * bit set.  Rooms now print an indicator of being continually lit.
 * Can't use it to make a room permanently lit any more.
 *
 * Revision 1.39  2006/11/17 03:47:30  jps
 * Eliminate points_event events being enqueued for outgoing players.
 *
 * Revision 1.38  2006/11/15 06:19:18  jps
 * Fix crash where a player being extracted would have more regen events enqueued.
 *
 * Revision 1.37  2006/11/13 18:15:05  jps
 * Fix lights to actually actually burn out.
 *
 * Revision 1.36  2006/11/08 21:36:05  jps
 * Fix so lights anywhere in inventory (not just top slot) can burn out.
 *
 * Revision 1.35  2006/11/07 06:15:02  jps
 * 'animate dead' - raised mobs would double-decrease their load
 * count, having died twice.
 *
 * Revision 1.34  2006/04/27 02:32:05  dce
 * Put a cap on hitgain of 100 to prevent crashes
 * because hitgain is only defined as a sbyte
 *
 * Revision 1.33  2002/09/19 01:07:53  jjl
 * Update to add in quest variables!
 *
 * Revision 1.32  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.31  2001/12/18 23:52:27  dce
 * Made a small addtion to affect_total to finish off fixing
 * the attributes and items problem. Which was items that
 * affect your atrribs mess up your attribs..
 *
 * Revision 1.30  2001/12/18 03:29:04  dce
 * Fixed the bug where if you have a natural stat of 100, and
 * then an item added to that stat. You would actually lose
 * points to the stat when you removed the item. The root
 * of the cause was in affect_modify. I added a check to see
 * if the affect was being added or subtracted. If it was being
 * subtracted then I made sure that AFFECTED_STAT - mod was
 * not less than NATURAL_STAT.
 *
 * Revision 1.29  2001/12/07 15:42:30  dce
 * Fixed a bug with object spell effects where if a player
 * was wearing an item and died, they would permanently
 * gain that ability.
 *
 * Revision 1.28  2001/03/10 18:45:33  dce
 * Changed do_return function to pass a subcommand of 1.
 * This way I can make it so players can't use the return command.
 *
 * Revision 1.27  2000/11/29 00:47:35  mtp
 * fix problem wthat makes quest list grow if player doesnt completely log out
 *
 * Revision 1.26  2000/11/25 08:07:20  rsd
 * Altered debug in corpse decay to use short description
 * and not the name to make the debug resemble english.
 *
 * Revision 1.25  2000/11/20 03:10:54  rsd
 * Altered comment header and added back rlog messages from
 * pior to the addition of the $log$ string.
 *
 * Revision 1.24  2000/11/13 02:38:21  rsd
 * Added log message for when a player corpse decomposes.
 *
 * Revision 1.23  1999/11/28 23:26:09  cso
 * obj_to_room: modified to use IS_PLR_CORPSE macro
 * obj_from_obj: same
 * extract_obj: same
 *
 * Revision 1.22  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.21  1999/03/05 20:02:36  dce
 * Chant added to, and songs craeted
 *
 * Revision 1.20  1999/03/04 20:13:51  jimmy
 * removed silly debug message
 * fingon
 *
 * Revision 1.19  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.18  1999/02/26 22:30:30  dce
 * Monk additions/fixes
 *
 * Revision 1.17  1999/02/23 16:48:06  dce
 * Creates a new command called file. Allows us to view files
 * through the mud.
 *
 * Revision 1.16  1999/02/13 19:35:06  mud
 * commented out unused variable in line 1554 associated with
 *  / * Subclassing explaination/preface * / which was commented
 * earlier to hide subclasses from players at login.
 *
 * Revision 1.15  1999/02/12 21:43:38  mud
 * Ok, I finished moving the subclass issue from the class selection view
 * the todo list will have more on the work remaining on this.
 *
 * Revision 1.14  1999/02/12 21:41:28  mud
 * I removed the View of the subclasses from the class Selection screen
 * In doing so I've created a warning, I have no idea how to fix it,
 * someone take a peek at it?
 *
 * Revision 1.13  1999/02/10 22:21:42  jimmy
 * Added do_wiztitle that allows gods to edit their
 * godly title ie Overlord.  Also added this title
 * to the playerfile
 * fingon
 *
 * Revision 1.12  1999/02/07 07:29:01  mud
 * removed debug message
 *
 * Revision 1.11  1999/02/06 05:32:46  jimmy
 * Fixed buffer overflow in do_alias
 * fingon
 *
 * Revision 1.10  1999/02/06 04:29:51  dce
 * David Endre 2/5/99
 * Added do_light
 *
 * Revision 1.9  1999/02/06 00:40:36  jimmy
 * Major change to incorporate aliases into the pfile
 * moved alias structure from interpreter.h to structs.h
 * heavily modified alias code in interpreter.c
 * Jimmy Kincaid AKA fingon
 *
 * Revision 1.8  1999/02/04 16:42:34  jimmy
 * Combined attributes, score, and exp commands.
 *
 * Revision 1.7  1999/02/04 00:02:59  jimmy
 * max/min exp loss/gain set to 2 notches.
 *
 * Revision 1.6  1999/02/01 22:40:16  jimmy
 * made listspells an LVL_IMMORT command
 *
 * Revision 1.5  1999/02/01 08:15:46  jimmy
 * improved build counter
 *
 * Revision 1.4  1999/02/01 04:18:50  jimmy
 * Added buildcounter to GREETING --Fingon
 *
 * Revision 1.3  1999/01/31 06:43:09  mud
 * Indented file
 *
 * Revision 1.2  1999/01/29 04:06:46  jimmy
 * temp remove races from login menu
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial Revision
 *
 ***************************************************************************/
@


1.164
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.163 2010/06/05 04:43:57 mud Exp $
d615 1
a615 1
    log(ctrbuf);
d1000 1
a1000 1
    log(otrbuf);
d1343 3
@


1.163
log
@Replacing ocean sector type with cave.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.162 2009/06/09 05:40:10 myc Exp mud $
d248 1
a248 1
    log(buf);
d474 1
a474 1
      log(buf);
d1218 1
a1218 1
    log(buf);
d1343 3
@


1.162
log
@Remove runtime link to clan when character is extracted.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.161 2009/05/22 17:56:14 myc Exp myc $
d1012 2
a1013 2
      if ((SECT(room) == SECT_SHALLOWS || SECT(room) == SECT_WATER ||
          SECT(room) == SECT_OCEAN) && (!OBJ_FLAGGED(object, ITEM_FLOAT))) {
d1343 3
@


1.161
log
@Fix verb conjugation for plural items when they sink in the water.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.160 2009/03/15 07:09:24 jps Exp myc $
d46 1
d1296 4
d1343 3
@


1.160
log
@Add !FALL flag for objects
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.159 2009/03/09 20:36:00 myc Exp jps $
d974 1
d977 5
a981 1
      act("$p&4&b sinks like a rock.&0", FALSE, 0, obj, 0, TO_ROOM);
d1338 3
@


1.159
log
@Moved money functions from here to money.c.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.158 2009/03/08 23:34:14 jps Exp myc $
d1003 22
a1024 10
    /* Will the object sink in water? */
    if ((SECT(room) == SECT_SHALLOWS || SECT(room) == SECT_WATER ||
        SECT(room) == SECT_OCEAN) && (!OBJ_FLAGGED(object, ITEM_FLOAT))) {
      /* Yep, say goodbye. */
      CREATE(sinkdata, struct sink_and_lose, 1);
      sinkdata->room = room;
      sinkdata->obj = object;
      event_create(EVENT_SINK_AND_LOSE, &sink_and_lose_event, sinkdata,
            TRUE, &(object->events), 2);
      return;
a1025 12
    else if (SECT(room) == SECT_AIR)
      start_obj_falling(object);

    if (ROOM_FLAGGED(room, ROOM_HOUSE))
      SET_FLAG(ROOM_FLAGS(room), ROOM_HOUSE_CRASH);
    /* if this is a player corpse, save the new room vnum to
       the corpse control record. This can later be optimized as
       a flag, much like houses  -  nechtrous */
    /* fixed by gurlaek 9/4/1999 added the != -1 */
    /* rewriting to use IS_PLR_CORPSE macro -321 */
    if (IS_PLR_CORPSE(object))
      update_corpse(object);
d1333 3
@


1.158
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.157 2009/03/08 21:43:27 jps Exp jps $
a1330 141
void money_desc(int amount, char **shortdesc, char **keywords) {
   static char sdbuf[128], kwbuf[128];

   if (amount <= 0) {
      log("SYSERR: Try to create negative or 0 money.");
      strcpy(sdbuf, "an erroneous object");
      strcpy(kwbuf, "erroneous object");
   }
   if (amount == 1) {
      strcpy(sdbuf, "a single coin");
      strcpy(kwbuf, "single coin");
   } else if (amount <= 9) {
      strcpy(sdbuf, "a tiny pile of coins");
      strcpy(kwbuf, "tiny pile coins");
   } else if (amount <= 20) {
      strcpy(sdbuf, "a handful of coins");
      strcpy(kwbuf, "handful coins");
   } else if (amount <= 75) {
      strcpy(sdbuf, "a little pile of coins");
      strcpy(kwbuf, "little pile coins");
   } else if (amount <= 200) {
      strcpy(sdbuf, "a small pile of coins");
      strcpy(kwbuf, "small pile coins");
   } else if (amount <= 1000) {
      strcpy(sdbuf, "a pile of coins");
      strcpy(kwbuf, "pile coins");
   } else if (amount <= 5000) {
      strcpy(sdbuf, "a big pile of coins");
      strcpy(kwbuf, "big pile coins");
   } else if (amount <= 10000) {
      strcpy(sdbuf, "a large heap of coins");
      strcpy(kwbuf, "large heap coins");
   } else if (amount <= 20000) {
      strcpy(sdbuf, "a huge mound of coins");
      strcpy(kwbuf, "huge mound coins");
   } else if (amount <= 75000) {
      strcpy(sdbuf, "an enormous mound of coins");
      strcpy(kwbuf, "enormous mound coins");
   } else if (amount <= 150000) {
      strcpy(sdbuf, "a small mountain of coins");
      strcpy(kwbuf, "small mountain coins");
   } else if (amount <= 250000) {
      strcpy(sdbuf, "a mountain of coins");
      strcpy(kwbuf, "mountain coins");
   } else if (amount <= 500000) {
      strcpy(sdbuf, "a huge mountain of coins");
      strcpy(kwbuf, "huge mountain coins");
   } else if (amount <= 1000000) {
      strcpy(sdbuf, "an enormous mountain of coins");
      strcpy(kwbuf, "enormous mountain coins");
   } else {
      strcpy(sdbuf, "an absolutely colossal mountain of coins");
      strcpy(kwbuf, "colossal mountain coins");
   }

   if (shortdesc) *shortdesc = sdbuf;
   if (keywords) *keywords = kwbuf;
}


struct obj_data *create_money(int pamount, int gamount, int samount, int camount)
{int amount;
 struct obj_data *obj;
 struct extra_descr_data *new_descr;
 char buf[200], *shortdesc, *keywords;
 amount = pamount+gamount+samount+camount;
 if (amount <= 0) {
   log("SYSERR: Try to create negative or 0 money.");
   return NULL;
 }
 obj = create_obj();
 CREATE(new_descr, struct extra_descr_data, 1);

 if (amount == 1) {
   if (pamount == 1){
     obj->name = strdup("platinum coin");
     obj->short_description = strdup("a platinum coin");
     obj->description = strdup("A single platinum coin is lying here.");
     new_descr->keyword = strdup("coin platinum");
     new_descr->description = strdup("A shiny platinum coin!");}
   if (gamount == 1){
     obj->name = strdup("gold coin");
     obj->short_description = strdup("a gold coin");
     obj->description = strdup("A single gold coin is lying here.");
     new_descr->keyword = strdup("coin gold");
     new_descr->description = strdup("A worn gold coin!");}
   if (samount == 1){
     obj->name = strdup("silver coin");
     obj->short_description = strdup("a silver coin");
     obj->description = strdup("A single silver coin is lying here.");
     new_descr->keyword = strdup("coin silver");
     new_descr->description = strdup("A tarnished silver coin.");}
   if (camount == 1){
     obj->name = strdup("copper coin");
     obj->short_description = strdup("a copper coin");
     obj->description = strdup("A single copper coin is lying here.");
     new_descr->keyword = strdup("coin copper");
     new_descr->description = strdup("A dull copper coin.");}
 }

 else {
    money_desc(amount, &shortdesc, &keywords);
    obj->name = strdup(keywords);
    obj->short_description = strdup(shortdesc);
    new_descr->keyword = strdup(keywords);

   sprintf(buf, "%s is lying here.", obj->short_description);
   obj->description = strdup(CAP(buf));
   if (amount < 10) {
     sprintf(buf, "There are %d coins.", amount);
     new_descr->description = strdup(buf);
   } else if (amount < 100) {
     sprintf(buf, "There are about %d coins.", 10 * (amount / 10));
     new_descr->description = strdup(buf);
   } else if (amount < 1000) {
     sprintf(buf, "It looks to be about %d coins.", 100 * (amount / 100));
     new_descr->description = strdup(buf);
   } else if (amount < 100000) {
     sprintf(buf, "You guess there are, maybe, %d coins.",
             1000 * ((amount / 1000) + number(0, (amount / 1000))));
     new_descr->description = strdup(buf);
   } else
     new_descr->description = strdup("There are a LOT of coins.");
 }

 new_descr->next = NULL;
 obj->ex_description = new_descr;

 GET_OBJ_TYPE(obj) = ITEM_MONEY;
 GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE;
 GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM) = pamount;
 GET_OBJ_VAL(obj, VAL_MONEY_GOLD) = gamount;
 GET_OBJ_VAL(obj, VAL_MONEY_SILVER) = samount;
 GET_OBJ_VAL(obj, VAL_MONEY_COPPER) = camount;
 GET_OBJ_COST(obj) = pamount * 1000 + gamount * 100 + samount * 10 + camount;
 obj->item_number = NOTHING;

 return obj;
}


d1333 3
@


1.157
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.156 2009/03/07 22:28:27 jps Exp jps $
d25 1
a25 1
#include "spells.h"
d1474 3
@


1.156
log
@Add function active_effect_from_char, which is called to remove effects
in-game and provide feedback.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.155 2009/03/03 19:43:44 myc Exp jps $
a18 1

d44 2
d1474 4
@


1.155
log
@Split off target-finding protocol from handler into find.c.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.154 2009/02/21 03:30:16 myc Exp myc $
d420 15
d1473 3
@


1.154
log
@Removed L_FILE flag--mprintf now logs to file by default;
assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.153 2009/01/17 01:17:33 myc Exp myc $
d6 1
a6 1
 *  Usage: internal funcs: moving and finding chars/objs                   *
a952 103
int get_number(char **name)
{
  int i;
  char *ppos;
  char number[MAX_INPUT_LENGTH];

  *number = '\0';

  if ((ppos = strchr(*name, '.'))) {
    *ppos++ = '\0';
    strcpy(number, *name);
    strcpy(*name, ppos);

    for (i = 0; *(number + i); i++)
      if (!isdigit(*(number + i)))
        return 0;

    return (atoi(number));
  }
  return 1;
}



/* Search a given list for an object number, and return a ptr to that obj */
struct obj_data *get_obj_in_list_num(int num, struct obj_data * list)
{
  struct obj_data *i;

  for (i = list; i; i = i->next_content)
    if (GET_OBJ_RNUM(i) == num)
      return i;

  return NULL;
}

struct obj_data *get_obj_in_list_vnum(int num, struct obj_data * list)
{
  struct obj_data *i;

  for (i = list; i; i = i->next_content)
    if (GET_OBJ_VNUM(i) == num)
      return i;

  return NULL;
}



/* search the entire world for an object number, and return a pointer  */
struct obj_data *get_obj_num(int nr)
{
  struct obj_data *i;

  for (i = object_list; i; i = i->next)
    if (GET_OBJ_RNUM(i) == nr)
      return i;

  return NULL;
}



/* search a room for a char, and return a pointer if found..  */
struct char_data *get_char_room(char *name, int room)
{
  struct char_data *i;
  struct char_data *ch = NULL;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = world[room].people; i && (j <= number); i = i->next_in_room)
    if (isname(tmp, GET_NAMELIST(i))){
      if (++j == number)
        return i;
    }else if (is_abbrev(name, races[(int)GET_RACE(i)].name))
      if (++j == number)
        if(i != ch)
          return i;

  return NULL;
}



/* search all over the world for a char num, and return a pointer if found */
struct char_data *get_char_num(int nr)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (GET_MOB_RNUM(i) == nr)
      return i;

  return NULL;
}


a1314 230

/***************************************************************************
 * Here follows high-level versions of some earlier routines, ie functions *
 * which incorporate the actual player-data                                *
 ***************************************************************************/


struct char_data *get_player_vis(struct char_data * ch, char *name, int inroom)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (!IS_NPC(i) && (!inroom || i->in_room == ch->in_room) &&
        !str_cmp(GET_NAMELIST(i), name) && CAN_SEE(ch, i))
      return i;

  return NULL;
}

/* get_player_vis_mscript is just like get_player_vis, but for mob triggers.
 * It will detect all players except those with wizinis. */
struct char_data *get_player_vis_mscript(struct char_data * ch, char *name, int inroom)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (!IS_NPC(i) && (!inroom || i->in_room == ch->in_room) &&
      !str_cmp(GET_NAMELIST(i), name) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
      return i;

  return NULL;
}

/* get_char_room_mscript is just like get_char_room, but for mob triggers.
 * It detects characters except those with wizinvis. */
struct char_data *get_char_room_mscript(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  if (!str_cmp(name, "self") || !str_cmp(name, "me"))
    return ch;

  if (*name == UID_CHAR && atoi(name + 1) == GET_ID(ch))
    return ch;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis_mscript(ch, tmp, 1);

  for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)
    if (isname(tmp, GET_NAMELIST(i)) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
      if (++j == number)
        return i;

  return NULL;
}

struct char_data *get_char_room_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  if (!str_cmp(name, "self") || !str_cmp(name, "me"))
    return ch;

  /* 0.<name> means PC with name shithead*/
  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 1);

  for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)
    if (isname(tmp, GET_NAMELIST(i))){
      if (CAN_SEE(ch, i))
        if (++j == number)
          return i;
    }

  return NULL;
}

/* get_char_vis_mscript: detects everyone except wizinvis */
struct char_data *get_char_vis_mscript(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* check the room first */
  if ((i = get_char_room_vis(ch, name)) != NULL)
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis_mscript(ch, tmp, 0);

  for (i = character_list; i && (j <= number); i = i->next)
    if (isname(tmp, GET_NAMELIST(i)) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
      if (++j == number)
         return i;

  return NULL;
}

struct char_data *get_char_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* check the room first */
  if ((i = get_char_room_vis(ch, name)) != NULL)
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 0);

  for (i = character_list; i && (j <= number); i = i->next)
    if (isname(tmp, GET_NAMELIST(i)) && CAN_SEE(ch, i))
      if (++j == number)
        return i;

  return NULL;
}



struct obj_data *get_obj_in_list_vis(struct char_data * ch, char *name,
                                     struct obj_data * list)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);/*shithead*/
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = list; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i))
        if (++j == number)
          return i;

  return NULL;
}

/* get_obj_vis_mscript: always detects. */
struct obj_data *get_obj_vis_mscript(struct char_data * ch, char *name)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* scan items carried */
  if ((i = get_obj_in_list_vis(ch, name, ch->carrying)))
    return i;

  /* scan room */
  if ((i = get_obj_in_list_vis(ch, name, world[ch->in_room].contents)))
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  /* ok.. no luck yet. scan the entire obj list   */
  for (i = object_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->name))
        if (++j == number)
          return i;

  return NULL;
}



/* search the entire world for an object, and return a pointer  */
struct obj_data *get_obj_vis(struct char_data * ch, char *name)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* scan items carried */
  if ((i = get_obj_in_list_vis(ch, name, ch->carrying)))
    return i;

  /* scan room */
  if ((i = get_obj_in_list_vis(ch, name, world[ch->in_room].contents)))
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  /* ok.. no luck yet. scan the entire obj list   */
  for (i = object_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i))
        if (++j == number)
          return i;

  return NULL;
}



struct obj_data *get_object_in_equip_vis(struct char_data * ch,
                                         char *arg, struct obj_data * equipment[], int *j)
{
  for ((*j) = 0; (*j) < NUM_WEARS; (*j)++)
    if (equipment[(*j)])
      if (CAN_SEE_OBJ(ch, equipment[(*j)]))
        if (isname(arg, equipment[(*j)]->name))
          return (equipment[(*j)]);

  return NULL;
}

a1455 113
/* Generic Find, designed to find any object/character                    */
/* Calling :                                                              */
/*  *arg     is the sting containing the string to be searched for.       */
/*           This string doesn't have to be a single word, the routine    */
/*           extracts the next word itself.                               */
/*  bitv..   All those bits that you want to "search through".            */
/*           Bit found will be result of the function                     */
/*  *ch      This is the person that is trying to "find"                  */
/*  **tar_ch Will be NULL if no character was found, otherwise points     */
/* **tar_obj Will be NULL if no object was found, otherwise points        */
/*                                                                        */
/* The routine returns a pointer to the next word in *arg (just like the  */
/* one_argument routine).                                                 */

int generic_find(char *arg, int bitvector, struct char_data * ch,
                 struct char_data ** tar_ch, struct obj_data ** tar_obj)
{
  int i, found;
  char name[256];

  one_argument(arg, name);

  if (!*name)
    return (0);

  *tar_ch = NULL;
  *tar_obj = NULL;

  if (IS_SET(bitvector, FIND_CHAR_ROOM)) {        /* Find person in room */
    if ((*tar_ch = get_char_room_vis(ch, name))) {
      return (FIND_CHAR_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_CHAR_WORLD)) {
    if ((*tar_ch = get_char_vis(ch, name))) {
      return (FIND_CHAR_WORLD);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_EQUIP)) {
    for (found = FALSE, i = 0; i < NUM_WEARS && !found; i++)
      if (GET_EQ(ch, i) && isname(name, GET_EQ(ch, i)->name) == 1) {
        *tar_obj = GET_EQ(ch, i);
        found = TRUE;
      }
    if (found) {
      return (FIND_OBJ_EQUIP);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_INV)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
      return (FIND_OBJ_INV);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_ROOM)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, world[ch->in_room].contents))) {
      return (FIND_OBJ_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_WORLD)) {
    if ((*tar_obj = get_obj_vis(ch, name))) {
      return (FIND_OBJ_WORLD);
    }
  }
  return (0);
}


/* a function to scan for "all" or "all.x" */
int find_all_dots(char *arg)
{
  if (!strcmp(arg, "all"))
    return FIND_ALL;
  else if (!strncmp(arg, "all.", 4)) {
    strcpy(arg, arg + 4);
    return FIND_ALLDOT;
  } else
    return FIND_INDIV;
}


struct char_data *get_random_char_around(struct char_data *ch, int mode) {
  int count = 0;
  struct char_data *vict = NULL;
  struct char_data *i;

  if (!ch)
    return vict;

  for (i = world[ch->in_room].people; i; i = i->next_in_room) {
    if (IS_SET(mode, RAND_PLAYERS) && IS_NPC(i))
      continue;
    if (IS_SET(mode, RAND_HASSLE) && PRF_FLAGGED(i, PRF_NOHASSLE))
      continue;
    if (IS_SET(mode, RAND_VISIBLE) && !CAN_SEE(ch, i))
      continue;
    if (IS_SET(mode, RAND_NOT_SELF) && ch == i)
      continue;
    if (IS_SET(mode, RAND_WIZ_VIS) && GET_INVIS_LEV(i))
      continue;
    /*
     * 100% chance to pick the first person,
     * 50% chance to pick the second person (50% to keep first),
     * 33% chance to pick the third person (66% to keep one of first two),
     * etc...
     */
    if (number(0, count++) == 0)
      vict = i;
  }

  return vict;
}


d1458 4
@


1.153
log
@Fix that "cleric ac bug".  AC will now be added and deducted
from mobs correctly.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.152 2009/01/16 23:36:34 myc Exp myc $
d873 1
a873 1
      mprintf(L_ERR | L_FILE, LVL_GOD, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
d878 1
a878 1
      mprintf(L_ERR | L_FILE, LVL_GOD, "SYSERR: EQUIP: Obj is carried_by when equip.");
d882 1
a882 1
      mprintf(L_ERR | L_FILE, LVL_GOD, "SYSERR: EQUIP: Obj is in_room when equip.");
d897 1
a897 1
         mprintf(L_ERR | L_FILE, LVL_GOD, "SYSERR: ch->in_room = NOWHERE when equipping char.");
d1904 4
@


1.152
log
@Correct typo in error message in active_effect_remove().
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.151 2008/09/21 20:40:40 jps Exp myc $
d267 3
a269 1
    if (GET_EQ(ch, i))
d274 1
d1904 3
@


1.151
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.150 2008/09/20 09:07:48 jps Exp jps $
d452 1
a452 1
            "SYSERR:spellc.c active_effect_remove() effect->type = %d on %s.",
d1901 4
@


1.150
log
@Remove extra flight-loss messages.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.149 2008/09/20 06:05:06 jps Exp jps $
d574 1
a602 6
    /* Stop fighting now, if we left. */
    if (FIGHTING(ch) && IN_ROOM(ch) != IN_ROOM(FIGHTING(ch))) {
      stop_fighting(FIGHTING(ch));
      stop_fighting(ch);
    }

d1284 1
a1284 1
  struct char_data *k, *temp;
a1289 1
  extern struct char_data *combat_list;
a1378 9
  if (FIGHTING(ch))
    stop_fighting(ch);

  for (k = combat_list; k; k = temp) {
    temp = k->next_fighting;
    if (FIGHTING(k) == ch)
      stop_fighting(k);
  }

d1901 3
@


1.149
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.148 2008/09/13 18:52:12 jps Exp jps $
a416 18
void lose_fly_messages(struct char_data *ch)
{
   if (GET_POS(ch) == POS_FLYING) {
      if (IS_SPLASHY(IN_ROOM(ch))) {
         send_to_char("You fall into the water.\r\n", ch);
         act("$n falls into the water with a splash.", FALSE, ch, 0, 0, TO_ROOM);
      } else if (SECT(IN_ROOM(ch)) == SECT_AIR) {
         send_to_char("You feel heavier again.  Uh-oh...\r\n", ch);
      } else {
         send_to_char("You fall back to the ground.\r\n", ch);
         act("$n falls back to the ground.", TRUE, ch, 0, 0, TO_ROOM);
      }
   } else {
      /* The standard wearoff message applies when you aren't flying. */
      cprintf(ch, "%s\r\n", skills[SPELL_FLY].wearoff);
   }
}

a441 3
               case SPELL_FLY:
                  lose_fly_messages(ch);
                  break;
d1916 3
@


1.148
log
@Including ai.h
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.147 2008/09/08 05:18:00 jps Exp jps $
d1343 1
a1343 1
  if (ch->desc && ch->desc->original)
d1937 3
@


1.147
log
@obj_to_obj needs to stop decomposing things if a player is carrying the container.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.146 2008/09/07 07:55:17 jps Exp jps $
d44 1
d1937 3
@


1.146
log
@Make obj_to_obj and obj_from_obj adjust weight amounts when the
enclosing container is being worn.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.145 2008/09/07 07:20:28 jps Exp jps $
d1162 1
a1162 1
void obj_to_obj(struct obj_data * obj, struct obj_data * obj_to)
d1180 1
a1180 1
  if (tmp_obj->carried_by)
d1182 3
a1184 1
  else if (tmp_obj->worn_by)
d1186 3
d1936 4
@


1.145
log
@Using MORTALALLY for the events that might cause decomposition to start.
This means that immortals won't cause items to start decomposing by
handling them. It also means that they can stop things decomposing by
grabbing them and then getting rid of them.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.144 2008/09/07 01:30:47 jps Exp jps $
d1182 2
d1208 2
d1931 6
@


1.144
log
@Handle losing fly. You might fall to the ground, or fall farther.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.143 2008/09/06 19:10:49 jps Exp jps $
d79 1
a79 1
	return (1);
d82 1
a82 1
	return (0);
d85 1
a85 1
	break;
d88 1
a88 1
	break;
d96 1
a96 1
    curname++;			/* first char of new name */
d266 1
a266 1
    if (GET_EQ(ch, i))	
d500 2
a501 2
		 bool add_dur, bool avg_dur, bool add_mod, bool avg_mod,
		 bool refresh)
d509 1
a509 1
	eff->duration += hjp->duration;
d511 1
a511 1
	eff->duration /= 2;
d516 1
a516 1
	eff->modifier += hjp->modifier;
d518 1
a518 1
	eff->modifier /= 2;
d687 1
a687 1
  if (PLAYERALLY(object->carried_by))
d712 1
a712 1
    break;			/* 30% */
d715 1
a715 1
    break;			/* 20% */
d718 1
a718 1
    break;			/* 20% */
d721 1
a721 1
    break;			/* all others 10% */
d968 1
a968 1
  if (PLAYERALLY(ch))
d990 1
a990 1
	return 0;
d1054 1
a1054 1
	return i;
d1057 2
a1058 2
	if(i != ch)
	  return i;
d1324 1
a1324 1
	do_return(d->character, "", 0, 1);
d1519 2
a1520 2
	if (++j == number)
	  return i;
d1576 1
a1576 1
				     struct obj_data * list)
d1590 2
a1591 2
	if (++j == number)
	  return i;
d1619 2
a1620 2
	if (++j == number)
	  return i;
d1651 2
a1652 2
	if (++j == number)
	  return i;
d1660 1
a1660 1
					 char *arg, struct obj_data * equipment[], int *j)
d1665 2
a1666 2
	if (isname(arg, equipment[(*j)]->name))
	  return (equipment[(*j)]);
d1790 1
a1790 1
	     1000 * ((amount / 1000) + number(0, (amount / 1000))));
d1827 1
a1827 1
		 struct char_data ** tar_ch, struct obj_data ** tar_obj)
d1840 1
a1840 1
  if (IS_SET(bitvector, FIND_CHAR_ROOM)) {	/* Find person in room */
d1853 2
a1854 2
	*tar_obj = GET_EQ(ch, i);
	found = TRUE;
d1927 3
@


1.143
log
@Use PLAYERALLY when deciding if objects should decompose.
Control decomposition when wearing equipment.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.142 2008/09/06 05:49:37 jps Exp jps $
d340 19
a358 5
  if (IN_ROOM(ch) != NOWHERE) {
    if (GET_POS(ch) == POS_FLYING && !EFF_FLAGGED(ch, EFF_FLY)) {
       GET_POS(ch) = POS_STANDING;
       if (SECT(IN_ROOM(ch)) == SECT_AIR)
         start_char_falling(ch);
a383 1

d635 1
a635 1
      start_char_falling(ch);
a644 1

d665 1
d1927 4
@


1.142
log
@Make worn equipment count towards weight-carried as well.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.141 2008/09/04 06:47:36 jps Exp jps $
d649 1
a649 1
    if (!IS_NPC(ch)) {
d651 1
a652 1
    }
d672 1
a672 1
  if (!IS_NPC(object->carried_by)) {
d674 1
a675 1
  }
d914 2
d955 2
d1176 1
d1197 2
a1198 3
  /* to fix some eq dupping, if obj_from is a pcorpse, save the corpse -nech */
  /* rewriting to use IS_PLR_CORPSE macro - 321 */
  if (IS_PLR_CORPSE(obj_from))
d1200 4
d1914 3
@


1.141
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.140 2008/09/04 00:23:43 myc Exp jps $
d914 1
d943 1
d1906 3
@


1.140
log
@Add newlines to fly and levitate wearoff messages.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.139 2008/09/02 07:16:00 mud Exp myc $
d343 1
a343 1
       if (SECT(IN_ROOM(ch)) == SECT_FLYING)
d409 1
a409 1
      } else if (SECT(IN_ROOM(ch)) == SECT_FLYING) {
d621 1
a621 1
    if (SECT(room) == SECT_FLYING)
d1094 1
a1094 1
    if ((SECT(room) == SECT_WATER_SWIM || SECT(room) == SECT_WATER_NOSWIM ||
d1104 1
a1104 1
    else if (SECT(room) == SECT_FLYING)
d1904 3
@


1.139
log
@Changing object TIMER uses into DECOMP where appropriate
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.138 2008/09/02 06:51:20 jps Exp mud $
d417 1
a417 1
      send_to_char(skills[SPELL_FLY].wearoff, ch);
d424 1
a424 1
      send_to_char(skills[SPELL_LEVITATE].wearoff, ch);
d453 1
a453 2
                  send_to_char(skills[effect->type].wearoff, ch);
                  send_to_char("\r\n", ch);
d1904 3
@


1.138
log
@Objects removed from players start decomposing and those being added to
players stop decomposing.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.137 2008/09/01 23:47:49 jps Exp jps $
a1090 2
    if (OBJ_FLAGGED(object, ITEM_TRANSIENT) && GET_OBJ_TIMER(object) < 5)
      GET_OBJ_TIMER(object) = 5;
d1905 4
@


1.137
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.136 2008/09/01 22:15:59 jps Exp jps $
d43 1
d638 1
a638 1
void obj_to_char(struct obj_data * object, struct char_data * ch)
d650 4
a653 2
    /* set flag for crash-save system */
    if (!IS_NPC(ch)) SET_FLAG(PLR_FLAGS(ch), PLR_AUTOSAVE);
d660 1
a660 1
void obj_from_char(struct obj_data * object)
d673 1
a673 2
  /* set flag for crash-save system */
  if (!IS_NPC(object->carried_by))
d675 2
d1907 3
@


1.136
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.135 2008/08/31 22:16:21 myc Exp jps $
d42 1
a1283 1
  void die_follower(struct char_data * ch);
a1867 29
/* dismount_char() / fr: Daniel Koepke (dkoepke@@california.com)
   If a character is mounted on something, we dismount them.  If
   someone is mounting our character, then we dismount that someone.
   This is used for cleaning up after a mount is cancelled by
   something (either intentionally or by death, etc.)*/
void dismount_char(struct char_data *ch) {
  if (RIDING(ch)) {
    RIDDEN_BY(RIDING(ch)) = NULL;
    RIDING(ch) = NULL;
  }

  if (RIDDEN_BY(ch)) {
    RIDING(RIDDEN_BY(ch)) = NULL;
    RIDDEN_BY(ch) = NULL;
  }
}


/* mount_char() / fr: Daniel Koepke (dkoepke@@california.com)
   Sets _ch_ to mounting _mount_.  This does not make any checks
   what-so-ever to see if the _mount_ is mountable, etc.  That is
   left up to the calling function.  This does not present any
   messages, either.*/
void mount_char(struct char_data *ch, struct char_data *mount) {
  RIDING(ch) = mount;
  RIDDEN_BY(mount) = ch;
}


d1903 3
@


1.135
log
@Fixed hp by bypassing alter_hit and modifying hitpoints directly.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.134 2008/08/31 18:38:33 myc Exp myc $
d1398 1
a1398 1
       save_player(ch, SAVE_EMERGENCY);
d1932 3
@


1.134
log
@Consider HP in effect_total before removing effects.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.133 2008/08/31 04:34:12 myc Exp myc $
d179 1
a179 1
    alter_hit(ch, -mod, TRUE);
d1932 3
@


1.133
log
@Fixing HP again.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.132 2008/08/31 02:20:48 myc Exp myc $
d260 1
a260 1
  int i, j, start_hp;
d314 1
a314 2
    /* Calculate HP bonus, and add it to both max HP and HP */
    start_hp = GET_MAX_HIT(ch);
d316 3
a318 1
    alter_hit(ch, start_hp - GET_MAX_HIT(ch), TRUE);
d1932 3
@


1.132
log
@Fix faulty handling of hitpoints in effect_total.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.131 2008/08/31 01:42:22 myc Exp myc $
d179 1
a179 1
    alter_hit(ch, -1 * (mod), TRUE);
a261 3
  /* Remember start HP */
  start_hp = GET_MAX_HIT(ch);

d314 2
a315 1
    /* Calculate HP bonus and fix current HP */
d1931 3
@


1.131
log
@Fix ARMOR applies so they subtract instead of add.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.130 2008/08/31 01:19:54 jps Exp myc $
d224 1
a224 1
    ch->char_specials.hitgain += mod;
d262 3
a276 3
  /* Remember start HP */
  start_hp = GET_MAX_HIT(ch);

d1933 3
@


1.130
log
@You screwed up holding items in slots with two of the same position!
Fix.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.129 2008/08/30 22:02:42 myc Exp jps $
d195 2
a196 1
    GET_AC(ch) += mod;
d1933 4
@


1.129
log
@Actions affecting corpses just go to the syslog now, not the RIP log.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.128 2008/08/30 20:25:38 jps Exp myc $
d726 1
a726 1
      int where,               /* The position it should be worn at */
d781 3
a783 3
    if (!CAN_WEAR(obj, wear_bitvectors[where]) ||
             (where == 0 && GET_OBJ_TYPE(obj) != ITEM_LIGHT) ||
             (where == 0 && GET_OBJ_TYPE(obj) == ITEM_LIGHT &&
d790 31
d822 1
a822 1
   if (GET_EQ(ch, where)) {
d824 1
a824 1
         send_to_char(already_wearing[where], ch);
d861 1
a861 1
   if (where == WEAR_OBELT && !GET_EQ(ch, WEAR_WAIST)) {
a867 31
   /* for neck, finger, wrist, held, and wielded, try pos 2 if pos 1 is already full */

   if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R) ||
         (where == WEAR_HOLD) || (where == WEAR_LEAR) || (where == WEAR_WIELD))
      if (GET_EQ(ch, where))
         where++;

   /* for shield, weapon, or held, must make sure the right number of hands are free */

   if ((where == WEAR_SHIELD) || (where == WEAR_WIELD) || (where == WEAR_WIELD2) ||
         (where == WEAR_HOLD) || (where == WEAR_HOLD2) || (where == WEAR_2HWIELD)) {

      /* a = hands occupied; w = hands wielding a weapon */
      count_hand_eq(ch, &a, &w);

      if ((GET_OBJ_WEAR(obj) & ITEM_WEAR_2HWIELD) && a) {
         if (sendmessage)
            send_to_char("You need both hands free for this weapon!\r\n",ch);
         return FALSE;
      } else if (a > 1) {
         if (sendmessage)
            send_to_char("Both of your hands are already using something.\r\n", ch);
         return FALSE;
      } else if (a == 1 && w > 0 && (where == WEAR_WIELD || where == WEAR_WIELD2) &&
            !(GET_SKILL(ch, SKILL_DUAL_WIELD))) {
         if (sendmessage)
            send_to_char("You don't have the co-ordination to dual wield.\r\n",ch);
         return FALSE;
      }
   }

d1932 3
@


1.128
log
@Moved count_hand_eq() into handler.c and mentioned it in handler.h.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.127 2008/08/30 20:21:07 jps Exp jps $
d1216 3
a1218 3
      sprintf(buf, "killed: %s has been extracted from %s [%d]",
              obj->short_description, world[obj->in_room].name,
              world[obj->in_room].vnum);
d1220 2
a1221 2
      sprintf(buf, "killed: %s has been extracted from inside %s",
              obj->short_description, obj->in_obj->short_description);
d1223 2
a1224 2
      sprintf(buf, "killed: %s has been extracted from %s's inventory",
              obj->short_description, GET_NAME(obj->carried_by));
d1226 2
a1227 3
      sprintf(buf, "killed: %s has been extracted from an unknown location",
              obj->short_description);
    log(buf);
d1932 3
@


1.127
log
@Moved equipment-wearability checks into function may_wear_eq() and moved
it to handler.c.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.126 2008/08/30 18:20:53 myc Exp jps $
d710 11
d1933 4
@


1.126
log
@Changed an object rnum check to compare against NOTHING constant.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.125 2008/08/30 01:31:51 myc Exp myc $
d710 149
a878 10
   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if ((OBJ_FLAGGED(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
            (OBJ_FLAGGED(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
            (OBJ_FLAGGED(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
            NOWEAR_CLASS(ch, obj)) {
         act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
         obj_to_char(obj, ch);
         return EQUIP_RESULT_REFUSE;
      }
   }
d1922 3
@


1.125
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.124 2008/08/29 19:18:05 myc Exp myc $
d1100 1
a1100 1
  if (GET_OBJ_RNUM(obj) >= 0)
d1783 6
@


1.124
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.123 2008/08/17 08:11:56 jps Exp myc $
a48 1
void update_stats(struct char_data *ch);
d52 2
a53 5
/*Defines for MAX ABILS settings*/
#define MIN_AC	-100
#define MAX_AC	100
#define MAX_DAMROLL	40
#define MAX_HITROLL	40
a189 1

a191 1

a193 1

d195 1
a195 1
    GET_AC(ch) -= mod;
a196 1

d198 1
a198 1
    GET_HITROLL(ch) = MIN(MAX_HITROLL, (GET_HITROLL(ch) + mod));
a199 1

d201 1
a201 1
    GET_DAMROLL(ch) = MIN(MAX_DAMROLL, (GET_DAMROLL(ch) + mod));
a202 1

d222 3
a224 10
    /*These two below are crashy in our haste I just remove em till fixed
      ao we can move on....Banyal*/
    /*
      case APPLY_MANA_REGEN:
      ch->char_specials.managain  += mod;
      break;
    */
  /* DCE 4-26-2006 Put a cap of 100 for hitgain, because hitgain is
      defined as a sbyte (-128 to 127) and was causing crashes
      when overflowing */
d226 2
a227 3
      ch->char_specials.hitgain = MIN(ch->char_specials.hitgain + mod, 100);
      break;

d229 2
a230 3
      GET_PERCEPTION(ch) += mod;
      break;

d232 2
a233 4
      GET_HIDDENNESS(ch) += mod;
      GET_HIDDENNESS(ch) = MAX(0, MIN(GET_HIDDENNESS(ch), 1000));
      break;

d235 5
a239 6
      if (mod >= 0)
         convert_composition(ch, mod);
      else
         convert_composition(ch, BASE_COMPOSITION(ch));
      break;

d259 1
a259 1
  int i, j;
d273 3
d279 1
a279 6
  GET_ACTUAL_DEX(ch) = GET_NATURAL_DEX(ch);
  GET_ACTUAL_INT(ch) = GET_NATURAL_INT(ch);
  GET_ACTUAL_WIS(ch) = GET_NATURAL_WIS(ch);
  GET_ACTUAL_CON(ch) = GET_NATURAL_CON(ch);
  GET_ACTUAL_CHA(ch) = GET_NATURAL_CHA(ch);
  GET_ACTUAL_STR(ch) = GET_NATURAL_STR(ch);
d281 11
d295 3
a297 1
    if (GET_EQ(ch, i))
d302 1
d304 1
d308 26
a333 6
  if (IS_NPC(ch)) {
    GET_DEX(ch) = MAX(MIN_ABILITY_VALUE, MIN(GET_DEX(ch), MAX_ABILITY_VALUE));
    GET_INT(ch) = MAX(MIN_ABILITY_VALUE, MIN(GET_INT(ch), MAX_ABILITY_VALUE));
    GET_WIS(ch) = MAX(MIN_ABILITY_VALUE, MIN(GET_WIS(ch), MAX_ABILITY_VALUE));
    GET_CON(ch) = MAX(MIN_ABILITY_VALUE, MIN(GET_CON(ch), MAX_ABILITY_VALUE));
    GET_STR(ch) = MAX(MIN_ABILITY_VALUE, MIN(GET_STR(ch), MAX_ABILITY_VALUE));
a335 5
  /*ok update stats*/
  if (!IS_NPC(ch)) {
    scale_attribs(ch); /* must be done before update_stats  */
    update_stats(ch);  /* ac thaco hp etc */
  }
d682 1
a682 1
int apply_ac(struct char_data * ch, int eq_pos)
d1783 4
@


1.123
log
@Logging equip errors to file.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.122 2008/08/17 06:50:34 jps Exp jps $
d140 1
a140 11
    if (add) {
      if ((GET_VIEWED_STR(ch) + mod) <= 100)
        GET_VIEWED_STR(ch) += mod;
      else
        GET_VIEWED_STR(ch) = 100;
    } else {
      if ((GET_VIEWED_STR(ch) + mod) < GET_NATURAL_STR(ch))
        GET_VIEWED_STR(ch) = GET_NATURAL_STR(ch);
      else
        GET_VIEWED_STR(ch) += mod;
    }
d143 1
a143 11
    if (add) {
      if ((GET_VIEWED_DEX(ch) + mod) <= 100)
        GET_VIEWED_DEX(ch) +=mod;
      else
        GET_VIEWED_DEX(ch) = 100;
    } else {
      if ((GET_VIEWED_DEX(ch) + mod) < GET_NATURAL_DEX(ch))
        GET_VIEWED_DEX(ch) = GET_NATURAL_DEX(ch);
      else
        GET_VIEWED_DEX(ch) += mod;
    }
d146 1
a146 11
    if (add) {
      if ((GET_VIEWED_INT(ch) + mod) <= 100)
        GET_VIEWED_INT(ch) +=mod;
      else
        GET_VIEWED_INT(ch) = 100;
    } else {
      if ((GET_VIEWED_INT(ch) + mod) < GET_NATURAL_INT(ch))
        GET_VIEWED_INT(ch) = GET_NATURAL_INT(ch);
      else
        GET_VIEWED_INT(ch) += mod;
    }
d149 1
a149 11
    if (add) {
      if ((GET_VIEWED_WIS(ch) + mod) <= 100)
        GET_VIEWED_WIS(ch) +=mod;
      else
        GET_VIEWED_WIS(ch) = 100;
    } else {
      if ((GET_VIEWED_WIS(ch) + mod) < GET_NATURAL_WIS(ch))
        GET_VIEWED_WIS(ch) = GET_NATURAL_WIS(ch);
      else
        GET_VIEWED_WIS(ch) += mod;
    }
d152 1
a152 11
    if (add) {
      if ((GET_VIEWED_CON(ch) + mod) <= 100)
        GET_VIEWED_CON(ch) +=mod;
      else
        GET_VIEWED_CON(ch) = 100;
    } else {
      if ((GET_VIEWED_CON(ch) + mod) < GET_NATURAL_CON(ch))
        GET_VIEWED_CON(ch) = GET_NATURAL_CON(ch);
      else
        GET_VIEWED_CON(ch) += mod;
    }
d155 1
a155 11
    if (add) {
      if ((GET_VIEWED_CHA(ch) + mod) <= 100)
        GET_VIEWED_CHA(ch) +=mod;
      else
        GET_VIEWED_CHA(ch) = 100;
    } else {
      if ((GET_VIEWED_CHA(ch) + mod) < GET_NATURAL_CHA(ch))
        GET_VIEWED_CHA(ch) = GET_NATURAL_CHA(ch);
      else
        GET_VIEWED_CHA(ch) += mod;
    }
d298 6
a303 6
  GET_VIEWED_DEX(ch) = GET_NATURAL_DEX(ch);
  GET_VIEWED_INT(ch) = GET_NATURAL_INT(ch);
  GET_VIEWED_WIS(ch) = GET_NATURAL_WIS(ch);
  GET_VIEWED_CON(ch) = GET_NATURAL_CON(ch);
  GET_VIEWED_CHA(ch) = GET_NATURAL_CHA(ch);
  GET_VIEWED_STR(ch) = GET_NATURAL_STR(ch);
d318 5
a322 13
    GET_DEX(ch) = MAX(0, MIN(GET_DEX(ch), 100));
    GET_INT(ch) = MAX(0, MIN(GET_INT(ch), 100));
    GET_WIS(ch) = MAX(0, MIN(GET_WIS(ch), 100));
    GET_CON(ch) = MAX(0, MIN(GET_CON(ch), 100));
    GET_STR(ch) = MAX(0, MIN(GET_STR(ch), 100));
  }
  else {
    GET_VIEWED_DEX(ch) = MAX(0, MIN(GET_VIEWED_DEX(ch), 100));
    GET_VIEWED_INT(ch) = MAX(0, MIN(GET_VIEWED_INT(ch), 100));
    GET_VIEWED_WIS(ch) = MAX(0, MIN(GET_VIEWED_WIS(ch), 100));
    GET_VIEWED_CON(ch) = MAX(0, MIN(GET_VIEWED_CON(ch), 100));
    GET_VIEWED_CHA(ch) = MAX(0, MIN(GET_VIEWED_CHA(ch), 100));
    GET_VIEWED_STR(ch) = MAX(0, MIN(GET_VIEWED_STR(ch), 100));
d1777 3
@


1.122
log
@equip_char will return one of several result codes, indicating success,
failure, or bad error. It uses mprintf for logging.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.121 2008/07/27 05:25:55 jps Exp jps $
d780 1
a780 1
      mprintf(L_ERR, LVL_GOD, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
d785 1
a785 1
      mprintf(L_ERR, LVL_GOD, "SYSERR: EQUIP: Obj is carried_by when equip.");
d789 1
a789 1
      mprintf(L_ERR, LVL_GOD, "SYSERR: EQUIP: Obj is in_room when equip.");
d814 1
a814 1
         mprintf(L_ERR, LVL_GOD, "SYSERR: ch->in_room = NOWHERE when equipping char.");
d1845 4
@


1.121
log
@extract_char will save players who are being extracted, but only if they
are not being explicitly removed.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.120 2008/07/10 20:21:46 myc Exp jps $
d773 1
a773 2

void equip_char(struct char_data * ch, struct obj_data * obj, int pos)
d780 3
a782 4
      sprintf(buf, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
                  obj->short_description);
      log(buf);
      return;
d785 2
a786 2
      log("SYSERR: EQUIP: Obj is carried_by when equip.");
      return;
d789 2
a790 2
      log("SYSERR: EQUIP: Obj is in_room when equip.");
      return;
d799 1
a799 1
         return;
d814 1
a814 1
         log("SYSERR: ch->in_room = NOWHERE when equipping char.");
d823 1
d1845 4
@


1.120
log
@unequip_char was making the wrong assertion.  Fixzored!
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.119 2008/06/07 19:06:46 myc Exp myc $
d711 1
a711 1
    if (!IS_NPC(ch)) SET_FLAG(PLR_FLAGS(ch), PLR_CRASH);
d733 1
a733 1
    SET_FLAG(PLR_FLAGS(object->carried_by), PLR_CRASH);
d1311 2
a1312 2
    save_player(ch);
    delete_crash_file(ch);
d1846 3
@


1.119
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.118 2008/06/05 02:07:43 myc Exp myc $
d833 1
a833 1
  assert(pos >= 0 && 16 < NUM_WEARS);
d1846 3
@


1.118
log
@Changed object flags to use flagvectors.  Rewrote corpse saving and
loading to use ascii object files.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.117 2008/05/18 20:16:11 jps Exp myc $
d615 1
a615 1
               GET_OBJ_VAL(GET_EQ(ch, j), 0) == 1)
d620 1
a620 1
      if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1)
d704 1
a704 1
    if((GET_OBJ_TYPE(object) == ITEM_LIGHT) && (GET_OBJ_VAL(object,0) == 1))
d726 1
a726 1
  if((GET_OBJ_TYPE(object) == ITEM_LIGHT) && (GET_OBJ_VAL(object,0) == 1))
d750 1
a750 1
  if (!(GET_OBJ_TYPE(GET_EQ(ch, eq_pos)) == ITEM_ARMOR))
d769 1
a769 1
  return (factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), 0));
d813 1
a813 1
         if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1)
d845 1
a845 1
        GET_OBJ_VAL(obj, 0) == 1)
d1001 1
a1001 1
    if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, 0)==1)
d1041 1
a1041 1
  if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, 0)==1)
d1691 5
a1695 5
 GET_OBJ_VAL(obj, 0) = pamount;
 GET_OBJ_VAL(obj, 1) = gamount;
 GET_OBJ_VAL(obj, 2) = samount;
 GET_OBJ_VAL(obj, 3) = camount;
 GET_OBJ_COST(obj) = pamount*1000+gamount*100+samount*10+camount;
d1846 4
@


1.117
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.116 2008/05/18 05:39:59 jps Exp jps $
a44 1
extern struct corpse_control_rec corpse_control[MAX_CORPSES];
a48 3
void Corpse_save_control(void);
int find_corpse(int index);
void ccontrol_destroy_corpse(int index);
d346 3
a348 3
      for (j = 0; j < MAX_OBJ_EFFECT; j++)
        effect_modify(ch, GET_EQ(ch, i)->effects[j].location,
                      GET_EQ(ch, i)->effects[j].modifier,
d369 3
a371 3
      for (j = 0; j < MAX_OBJ_EFFECT; j++)
        effect_modify(ch, GET_EQ(ch, i)->effects[j].location,
                      GET_EQ(ch, i)->effects[j].modifier,
d394 1
a394 1
  if (!(IS_NPC(ch))) {
d795 3
a797 3
      if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
            (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
            (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
d819 3
a821 3
    for (j = 0; j < MAX_OBJ_EFFECT; j++)
         effect_modify(ch, obj->effects[j].location,
                           obj->effects[j].modifier,
d855 3
a857 3
  for (j = 0; j < MAX_OBJ_EFFECT; j++)
    effect_modify(ch, obj->effects[j].location,
                  obj->effects[j].modifier,
a985 1
  int i=0;
d999 1
a999 1
    if (IS_OBJ_STAT(object, ITEM_TRANSIENT) && GET_OBJ_TIMER(object) < 5)
d1006 1
a1006 1
        SECT(room) == SECT_OCEAN) && (!IS_OBJ_STAT(object, ITEM_FLOAT))) {
d1025 2
a1026 6
    if (IS_PLR_CORPSE(object)) {
      if ( (i = find_corpse(GET_OBJ_VAL(object,2))) != -1 ) {
        corpse_control[i].vnum = world[room].vnum;
        Corpse_save_control();
      }
    }
d1103 2
a1104 2
  if(IS_PLR_CORPSE(obj_from))
    Corpse_crashsave(GET_OBJ_VAL(obj_from,2), obj_from);
a1107 10
/* Set all carried_by to point to new owner */
void object_list_new_owner(struct obj_data * list, struct char_data * ch)
{
  if (list) {
    object_list_new_owner(list->contains, ch);
    object_list_new_owner(list->next_content, ch);
    list->carried_by = ch;
  }
}

d1124 1
a1124 1
    ccontrol_destroy_corpse(GET_OBJ_VAL(obj,2));
d1312 1
a1312 1
    Crash_delete_crashfile(ch);
d1846 3
@


1.116
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.115 2008/05/14 05:12:26 jps Exp jps $
d41 1
a43 1
extern struct char_data *find_aggr_target(struct char_data *ch);
a48 1
void stop_fighting(struct char_data * ch);
a658 1
  EVENTFUNC(quick_aggro_event);
d1865 3
@


1.115
log
@alter_hit doesn't take the attacker any more.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.114 2008/05/11 07:12:40 jps Exp jps $
d1034 1
a1034 1
        corpse_control[i].vnum = world[room].number;
d1152 1
a1152 1
              world[obj->in_room].number);
d1867 3
@


1.114
log
@Moved active_effect_remove here, which is what you call when a spell
goes away. Modified it to handle some spells differently: fly and levitate.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.113 2008/05/11 05:49:48 jps Exp jps $
d248 1
a248 1
    alter_hit(ch, NULL, -1 * (mod), TRUE);
d1867 4
@


1.113
log
@Using regen.h. alter_hit() takes the killer. alter_pos is now the way
to change position.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.112 2008/04/14 05:11:40 jps Exp jps $
d468 64
d1867 4
@


1.112
log
@Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
to fly - not that the characer is actually flying.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.111 2008/04/14 02:18:57 jps Exp jps $
d40 1
d248 1
a248 1
    alter_hit(ch, -1 * (mod), TRUE);
d412 1
a412 1
    update_pos(ch);
d1803 4
@


1.111
log
@Removing unused function prototype.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.110 2008/04/13 01:41:39 jps Exp jps $
d405 1
a405 1
    if (GET_POS(ch) == POS_FLYING && !EFF_FLAGGED(ch, EFF_FLYING)) {
d1802 3
@


1.110
log
@Calling composition_check() which makes sure no fluid/rigid
mount/rider pairs are possible.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.109 2008/04/05 05:05:42 myc Exp jps $
a46 1
bool is_aggr_to(struct char_data *ch,struct char_data *target);
d1802 4
@


1.109
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.108 2008/04/02 04:55:59 myc Exp myc $
d411 1
d1803 3
@


1.108
log
@Made the disband group message show up when extracting a char.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.107 2008/04/02 03:24:44 myc Exp myc $
d1215 2
a1216 2
      SEND_TO_Q("Your victim is no longer among us.\r\n",
		ch->desc->snoop_by);
d1279 1
a1279 1
    SEND_TO_Q(MENU, ch->desc);
d1802 3
@


1.107
log
@Rewrote group code and removed major group code.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.106 2008/04/01 00:13:09 jps Exp myc $
d1188 1
a1188 1
    ungroup(ch, FALSE, FALSE);
d1802 3
@


1.106
log
@Perform in_room check during effect_total.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.105 2008/03/30 17:30:38 jps Exp jps $
a106 36
long perform_trophy_decrease(struct char_data *ch, struct char_data *vict, long exp)
{
  float amount = 0;
  struct trophy_node *node;

  /* Check to see if in trophy */
  for (node = GET_TROPHY(ch); node; node = node->next) {
    if (node->kill_type == TROPHY_PLAYER) {
      if (!IS_NPC(vict)) {
        amount = node->amount;
        break;
      }
    }
    else if (node->kill_type == TROPHY_MOBILE) {
      if (IS_MOB(vict)) {
        amount = node->amount;
        break;
      }
    }
  }

  if (amount < 2.01)
    return exp;
  else if (amount < 3.01)
    return (long) (exp * .95);
  else if (amount < 5.01)
    return (long) (exp * .85);
  else if (amount < 7.01)
    return (long) (exp * .65);
  else if (amount < 10.01)
    return (long) (exp * .45);
  else
    return (long) (exp * .3);

}

a1152 1
  void die_consentee(struct char_data *ch);
d1187 2
a1188 5
  if (ch->groupmaster || ch->groupees)
    die_groupee(ch);

  if (CONSENT(ch))
    die_consentee(ch);
d1802 3
@


1.105
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.104 2008/03/29 17:34:55 myc Exp jps $
d376 1
d439 9
a447 5
  check_regen_rates(ch);	/* update regen rates (for age) */		
  if (GET_POS(ch) == POS_FLYING && !EFF_FLAGGED(ch, EFF_FLYING)) {
     GET_POS(ch) = POS_STANDING;
     if (SECT(IN_ROOM(ch)) == SECT_FLYING)
       start_char_falling(ch);
a448 1
  update_pos(ch);
d1842 4
@


1.104
log
@Autodouse event memory leak.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.103 2008/03/28 17:54:53 myc Exp myc $
d39 1
d1838 3
@


1.103
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.102 2008/03/24 02:28:37 jps Exp myc $
a625 1
  EVENTFUNC(gravity_event);
d651 1
a651 2
             mkgenericevent(ch, 0, 0), FALSE,
             &(ch->events), 0);
d1837 4
@


1.102
log
@Fix autodouse event bug.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.101 2008/03/23 00:27:38 jps Exp jps $
d142 2
a143 2
void affect_modify(struct char_data * ch, byte loc, sh_int mod,
                   long bitv1, long bitv2, long bitv3, bool add)
d145 1
d149 2
a150 2
    if (IS_SET(bitv2, AFF2_LIGHT) && ch->in_room != NOWHERE &&
        !AFF2_FLAGGED(ch, AFF2_LIGHT))
d153 4
a156 4
    /* Add aff flags. */
    SET_BIT(AFF_FLAGS(ch), bitv1);
    SET_BIT(AFF2_FLAGS(ch), bitv2);
    SET_BIT(AFF3_FLAGS(ch), bitv3);
d160 2
a161 2
    if (IS_SET(bitv2, AFF2_LIGHT) && ch->in_room != NOWHERE &&
        AFF2_FLAGGED(ch, AFF2_LIGHT))
d163 1
a163 1
    if (IS_SET(bitv3, AFF3_CAMOUFLAGED))
d166 4
a169 4
    /* Remove aff flags. */
    REMOVE_BIT(AFF_FLAGS(ch), bitv1);
    REMOVE_BIT(AFF2_FLAGS(ch), bitv2);
    REMOVE_BIT(AFF3_FLAGS(ch), bitv3);
d363 1
a363 1
    sprintf(buf, "SYSERR:handler.c:affect_modify() Unknown apply adjust attempt for: %s", GET_NAME(ch));
d375 1
a375 1
void affect_total(struct char_data * ch)
d379 1
a379 1
  struct affected_type *af;
d385 4
a388 6
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.spell_flags,
                      GET_EQ(ch, i)->obj_flags.spell_flags2,
                      GET_EQ(ch, i)->obj_flags.spell_flags3, FALSE);
d391 2
a392 3
  for (af = ch->affected; af; af = af->next)
    affect_modify(ch, af->location, af->modifier, af->bitvector,
                  af->bitvector2, af->bitvector3, FALSE);
d408 7
a414 10
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.spell_flags,
                      GET_EQ(ch, i)->obj_flags.spell_flags2,
                      GET_EQ(ch, i)->obj_flags.spell_flags3, TRUE);

  for (af = ch->affected; af; af = af->next)
    affect_modify(ch, af->location, af->modifier, af->bitvector,
                  af->bitvector2, af->bitvector3, TRUE);
d438 1
a438 1
  if (GET_POS(ch) == POS_FLYING && !AFF_FLAGGED(ch, AFF_FLYING)) {
d447 1
a447 1
/* Insert an affect_type in a char_data structure
d449 1
a449 1
void affect_to_char(struct char_data * ch, struct affected_type * af)
d451 1
a451 1
  struct affected_type *affected_alloc;
d453 1
a453 1
  CREATE(affected_alloc, struct affected_type, 1);
d455 3
a457 3
  *affected_alloc = *af;
  affected_alloc->next = ch->affected;
  ch->affected = affected_alloc;
d459 1
a459 2
  affect_modify(ch, af->location, af->modifier, af->bitvector,
                af->bitvector2, af->bitvector3, TRUE);
d461 1
a461 1
  affect_total(ch);
d467 3
a469 3
 * Remove an affected_type structure from a char (called when duration
 * reaches zero). Pointer *af must never be NIL!  Frees mem and calls
 * affect_location_apply
d471 1
a471 1
void affect_remove(struct char_data * ch, struct affected_type * af)
d473 1
a473 1
  struct affected_type *temp;
d475 1
a475 1
  assert(ch->affected);
d477 1
a477 2
  affect_modify(ch, af->location, af->modifier, af->bitvector,
                af->bitvector2, af->bitvector3, FALSE);
d479 3
a481 3
  REMOVE_FROM_LIST(af, ch->affected, next);
  free(af);
  affect_total(ch);
d486 2
a487 2
/* Call affect_remove with every spell of spelltype "skill" */
void affect_from_char(struct char_data * ch, int type)
d489 1
a489 1
  struct affected_type *hjp, *next;
d491 1
a491 1
  for (hjp = ch->affected; hjp; hjp = next) {
d494 1
a494 1
      affect_remove(ch, hjp);
d506 2
a507 2
  struct affected_type *hjp;
  if (ch->affected == NULL)
d509 1
a509 1
  for (hjp = ch->affected; hjp; hjp = hjp->next)
d518 1
a518 1
void affect_join(struct char_data * ch, struct affected_type * af,
d522 2
a523 1
  struct affected_type *hjp;
d525 2
a526 2
  for (hjp = ch->affected; hjp; hjp = hjp->next)
    if (hjp->type == af->type && hjp->location == af->location) {
d528 1
a528 1
	af->duration += hjp->duration;
d530 1
a530 1
	af->duration /= 2;
d532 1
a532 1
        af->duration = hjp->duration;
d535 1
a535 1
	af->modifier += hjp->modifier;
d537 1
a537 1
	af->modifier /= 2;
d539 4
a542 3
      af->bitvector = af->bitvector | hjp->bitvector;
      af->bitvector2 = af->bitvector2 | hjp->bitvector2;
      af->bitvector3 = af->bitvector3 | hjp->bitvector3;
d544 2
a545 2
      affect_remove(ch, hjp);
      affect_to_char(ch, af);
d550 1
a550 1
  affect_to_char(ch, af);
d595 1
a595 1
   if (AFF2_FLAGGED(ch, AFF2_LIGHT))
d650 1
a650 1
    if (AFF2_FLAGGED(ch, AFF2_ON_FIRE) && IS_WATER(IN_ROOM(ch))) {
d685 1
a685 1
    if (!IS_NPC(ch)) SET_BIT(PLR_FLAGS(ch), PLR_CRASH);
d707 1
a707 1
    SET_BIT(PLR_FLAGS(object->carried_by), PLR_CRASH);
d793 4
a796 6
    for (j = 0; j < MAX_OBJ_AFFECT; j++)
         affect_modify(ch, obj->affected[j].location,
                           obj->affected[j].modifier,
                           obj->obj_flags.spell_flags,
                           obj->obj_flags.spell_flags2,
                           obj->obj_flags.spell_flags3, TRUE);
d798 1
a798 1
   affect_total(ch);
d829 4
a832 6
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    affect_modify(ch, obj->affected[j].location,
                  obj->affected[j].modifier,
                  obj->obj_flags.spell_flags,
                  obj->obj_flags.spell_flags2,
                  obj->obj_flags.spell_flags3, FALSE);
d834 1
a834 1
  affect_total(ch);
d994 1
a994 1
      SET_BIT(ROOM_FLAGS(room), ROOM_HOUSE_CRASH);
d1026 1
a1026 1
    SET_BIT(ROOM_FLAGS(object->in_room), ROOM_HOUSE_CRASH);
d1629 5
a1633 5
     obj->name = str_dup("platinum coin");
     obj->short_description = str_dup("a platinum coin");
     obj->description = str_dup("A single platinum coin is lying here.");
     new_descr->keyword = str_dup("coin platinum");
     new_descr->description = str_dup("A shiny platinum coin!");}
d1635 5
a1639 5
     obj->name = str_dup("gold coin");
     obj->short_description = str_dup("a gold coin");
     obj->description = str_dup("A single gold coin is lying here.");
     new_descr->keyword = str_dup("coin gold");
     new_descr->description = str_dup("A worn gold coin!");}
d1641 5
a1645 5
     obj->name = str_dup("silver coin");
     obj->short_description = str_dup("a silver coin");
     obj->description = str_dup("A single silver coin is lying here.");
     new_descr->keyword = str_dup("coin silver");
     new_descr->description = str_dup("A tarnished silver coin.");}
d1647 5
a1651 5
     obj->name = str_dup("copper coin");
     obj->short_description = str_dup("a copper coin");
     obj->description = str_dup("A single copper coin is lying here.");
     new_descr->keyword = str_dup("coin copper");
     new_descr->description = str_dup("A dull copper coin.");}
d1656 3
a1658 3
    obj->name = str_dup(keywords);
    obj->short_description = str_dup(shortdesc);
    new_descr->keyword = str_dup(keywords);
d1661 1
a1661 1
   obj->description = str_dup(CAP(buf));
d1664 1
a1664 1
     new_descr->description = str_dup(buf);
d1667 1
a1667 1
     new_descr->description = str_dup(buf);
d1670 1
a1670 1
     new_descr->description = str_dup(buf);
d1674 1
a1674 1
     new_descr->description = str_dup(buf);
d1676 1
a1676 1
     new_descr->description = str_dup("There are a LOT of coins.");
d1839 3
@


1.101
log
@Implement the composition apply.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.100 2008/03/21 22:52:52 jps Exp jps $
d656 2
a657 1
       event_create(EVENT_AUTODOUSE, autodouse_event, ch, FALSE,
d1848 3
@


1.100
log
@Reset TRANSIENT objects' timers when they are placed in a room,
not when they are picked up.  Prior to this, TRANSIENT objects
would tend to dissolve in under an hour if not picked up, which
was really too short.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.99 2008/03/21 14:54:19 myc Exp jps $
d354 7
d405 1
d1847 6
@


1.99
log
@Added freeing of the event list back to extract char, fixing the
death crash bug.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.98 2008/03/19 04:32:14 myc Exp myc $
d67 1
a67 1
  
d70 1
a70 1
  
d72 1
a72 1
  
d80 1
a80 1
  
d86 1
a86 1
      
d89 1
a89 1
      
d92 1
a92 1
      
d98 1
a98 1
    
d139 1
a139 1
  
d150 1
a150 1
      world[ch->in_room].light++;      
d177 1
a177 1
    
d188 1
a188 1
        GET_VIEWED_STR(ch) += mod;       
d201 1
a201 1
        GET_VIEWED_DEX(ch) += mod;       
d214 1
a214 1
        GET_VIEWED_INT(ch) += mod;       
d227 1
a227 1
        GET_VIEWED_WIS(ch) += mod;       
d240 1
a240 1
        GET_VIEWED_CON(ch) += mod;       
d253 1
a253 1
        GET_VIEWED_CHA(ch) += mod;       
d256 1
a256 1
    
d259 1
a259 1
    
d261 1
a261 1
    GET_LEVEL(ch) += mod; 
d263 1
a263 1
    
d267 1
a267 1
    
d271 1
a271 1
    
d275 1
a275 1
    
d279 1
a279 1
    
d284 1
a284 1
    
d289 1
a289 1
    
d293 1
a293 1
    
d296 1
a296 1
    
d299 2
a300 2
    
  case APPLY_AC:        
d303 1
a303 1
    
d311 1
a311 1
    
d315 1
a315 1
    
d319 1
a319 1
    
d337 1
a337 1
    */      
d342 1
a342 1
      ch->char_specials.hitgain = MIN(ch->char_specials.hitgain + mod, 100); 
d375 1
a375 1
  for (i = 0; i < NUM_WEARS; i++) 
d383 1
a383 1
  
d392 6
a397 6
  GET_VIEWED_DEX(ch) = GET_NATURAL_DEX(ch); 
  GET_VIEWED_INT(ch) = GET_NATURAL_INT(ch); 
  GET_VIEWED_WIS(ch) = GET_NATURAL_WIS(ch); 
  GET_VIEWED_CON(ch) = GET_NATURAL_CON(ch); 
  GET_VIEWED_CHA(ch) = GET_NATURAL_CHA(ch); 
  GET_VIEWED_STR(ch) = GET_NATURAL_STR(ch); 
d400 1
a400 1
  for (i = 0; i < NUM_WEARS; i++) 
d410 1
a410 1
    affect_modify(ch, af->location, af->modifier, af->bitvector, 
d412 1
a412 1
  
d419 1
a419 1
  } 
d449 1
a449 1
  
d451 1
a451 1
  
d455 1
a455 1
  
d458 1
a458 1
  
d474 1
a474 1
  
d489 1
a489 1
  
d511 1
a511 1
  
d522 1
a522 1
  
d531 1
a531 1
      
d540 1
a540 1
      
d602 1
a602 1
  
d607 1
a607 1
  
d659 1
a659 1
        event_create(EVENT_QUICK_AGGRO, quick_aggro_event, 
d691 1
a691 1
  
d700 1
a700 1
   
d704 1
a704 1
  
d717 1
a717 1
  
d719 1
a719 1
  
d722 1
a722 1
  
d724 1
a724 1
    
d738 1
a738 1
  
d747 1
a747 1
   
d749 1
a749 1
   
d774 1
a774 1
   
d778 1
a778 1
   
d781 1
a781 1
   
d788 1
a788 1
   
d795 1
a795 1
   
d804 1
a804 1
  
d807 1
a807 1
  
d811 1
a811 1
  
d814 1
a814 1
  
d816 1
a816 1
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && 
d821 1
a821 1
  
d844 1
a844 1
  
d846 1
a846 1
  
d851 1
a851 1
    
d855 1
a855 1
    
d867 1
a867 1
  
d871 1
a871 1
  
d878 1
a878 1
  
d882 1
a882 1
  
d892 1
a892 1
  
d896 1
a896 1
  
d910 1
a910 1
  
d914 1
a914 1
  
d921 1
a921 1
	if(i != ch) 
d923 1
a923 1
  
d933 1
a933 1
  
d937 1
a937 1
  
d957 1
a957 1
void obj_to_room(struct obj_data * object, int room)
d963 1
a963 1
  
d974 2
d1014 1
a1014 1
  
d1019 2
a1020 2
  
  if (GET_OBJ_TYPE(object) == ITEM_LIGHT && GET_OBJ_VAL(object, 0)==1) 
d1024 1
a1024 1
  
d1036 1
a1036 1
  
d1041 1
a1041 1
  
d1045 1
a1045 1
  
d1048 1
a1048 1
  
d1060 1
a1060 1
  
d1067 1
a1067 1
  
d1071 1
a1071 1
  
d1076 1
a1076 1
  
d1079 1
a1079 1
  
d1118 2
a1119 2
      sprintf(buf, "killed: %s has been extracted from %s [%d]", 
              obj->short_description, world[obj->in_room].name, 
d1142 1
a1142 1
  
d1146 1
a1146 1
  
d1151 1
a1151 1
  
d1154 1
a1154 1
  
d1157 1
a1157 1
  
d1186 2
a1187 2
  void die_consentee(struct char_data *ch);  
  void die_follower(struct char_data * ch);  
d1230 1
a1230 1
  if (ch->guarding) 
d1273 1
a1273 1
  
d1281 1
a1281 1
  
d1287 1
a1287 1
  
d1289 1
a1289 1
  
d1301 1
a1301 1
  
d1334 1
a1334 1
  
d1339 1
a1339 1
  
d1348 1
a1348 1
  
d1365 1
a1365 1
  
d1368 1
a1368 1
  
d1375 1
a1375 1
  
d1390 1
a1390 1
  
d1393 1
a1393 1
  
d1398 1
a1398 1
  
d1416 1
a1416 1
  
d1420 1
a1420 1
  
d1424 1
a1424 1
  
d1429 1
a1429 1
  
d1439 1
a1439 1
  
d1443 1
a1443 1
  
d1447 1
a1447 1
  
d1452 1
a1452 1
  
d1465 1
a1465 1
  
d1469 1
a1469 1
  
d1475 1
a1475 1
  
d1486 1
a1486 1
  
d1494 1
a1494 1
  
d1517 1
a1517 1
  
d1525 1
a1525 1
  
d1550 1
a1550 1
  
d1626 1
a1626 1
 
d1653 1
a1653 1
 
d1678 1
a1678 1
 
d1681 1
a1681 1
 
d1690 1
a1690 1
 
d1714 1
a1714 1
  
d1716 1
a1716 1
  
d1719 1
a1719 1
  
d1722 1
a1722 1
  
d1785 1
a1785 1
  
d1839 4
@


1.98
log
@Removed a bunch of frag code that was simply commented out before.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.97 2008/03/16 00:21:53 jps Exp myc $
d1290 9
d1837 3
@


1.97
log
@Updated trophy code.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.96 2008/03/11 02:53:41 jps Exp jps $
a105 199


/* slated to be removed --gurlaek 8/9/1999 
void frag_update(struct char_data *ch, struct char_data *victim, float amount) {
  bool chaction = FALSE;
  bool victimaction = FALSE;
  int i;

  if(!ch)
    return;

   / *  ok remove if not a good enough kill * /
  if ((!IS_NPC(ch) || (IS_NPC(ch) && (ch->desc && ch->desc->original)))  &&
      (!IS_NPC(victim) || (IS_NPC(victim) && (victim->desc && victim->desc->original))));
  else
    return;
  if ((GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(victim)))
    return;
  if  ((GET_LEVEL(victim) <= 35) && ((GET_LEVEL(ch) - GET_LEVEL(victim)) > 20))
    return;
  if ((GET_LEVEL(victim) < 20) && (GET_LEVEL(ch) > 20))
    return;
  if (GET_LEVEL(ch) > 70)
    return;
  
  
   / *  GET_FRAG(ch) = GET_FRAG(ch) + amount; * /
   / *   GET_FRAG(victim) = GET_FRAG(victim) - amount; * /
  GET_FRAG(ch) += amount;
  GET_FRAG(victim) -= amount;
   / *  ok check globel list * /
   / *  extern struct player_frags_data player_frags[19]; * /
  for (i=0;i<=14;i++)
    {  / *  if in list remove * /
      if ((GET_PFILEPOS(ch) == pos_player_frags[i].playerid))
        {
	  if(!(remove_from_frag_list(ch, 1)))
	    mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
	  add_to_frag_list(ch, 1);
	  chaction = TRUE;
        }
      if ((GET_PFILEPOS(victim) == pos_player_frags[i].playerid))
        {
	  if (!(remove_from_frag_list(victim, 1)))
	    mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
	  add_to_frag_list(victim, 1);
	  victimaction = TRUE;
        }
      if ((GET_PFILEPOS(ch) == neg_player_frags[i].playerid))
        {
	  if(!(remove_from_frag_list(ch, 0)))
	    mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
	  add_to_frag_list(ch, 0);
	  chaction = TRUE;
        }
      if ((GET_PFILEPOS(victim) == neg_player_frags[i].playerid))
        {
	  if(!(remove_from_frag_list(victim, 0)))
	    mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
	  add_to_frag_list(victim, 0);
	  victimaction = TRUE;
        }
    }
  
  
   / *  fragger not on list * /
  if (!chaction) {
    if (GET_FRAG(ch) < 0.0)
      {
        if (!(add_to_frag_list(ch, 0)))
	  {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(ch));
            mudlog(buf, NRM, LVL_GOD, FALSE);
	  }
      }else
	{
	  if (!(add_to_frag_list(ch, 1)))
	    {
	      sprintf(buf, "%s has just joined the fragged!!", GET_NAME(ch));
	      mudlog(buf, NRM, LVL_GOD, FALSE);
	    }
	  
	}
  }
  if (!victimaction) {
    if (GET_FRAG(victim) < 0.0)
      {
        if (!(add_to_frag_list(victim, 0)))
	  {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(victim));
            mudlog(buf, NRM, LVL_GOD, FALSE);
	  }
      }else
	{
	  if (!(add_to_frag_list(victim, 1)))
	    {
	      sprintf(buf, "%s has just joined the fragged!!", GET_NAME(victim));
	      mudlog(buf, NRM, LVL_GOD, FALSE);
	    }
	  
	}
  }
}




/ ***************************************************************************
 * removes person from frag list
 *************************************************************************** /
bool remove_from_frag_list(struct char_data *ch, bool pos)
{
  int i, j;
  if (pos)
    {
      for (i=0;i<=14;i++)
        {
	  if (GET_PFILEPOS(ch) == pos_player_frags[i].playerid)
            {
	      for (j = i; j < 14;j++)
                {
		  pos_player_frags[j] = pos_player_frags[j + 1];
                }
	      
	      
	      pos_player_frags[14].frag = 0.0;
	      pos_player_frags[14].playerid = 0;
	      strcpy(pos_player_frags[14].name, "");  
	      return TRUE;
            }
        }
    }
  else
    { 
      for (i=0;i <= 14;i++)
        {
	  if (GET_PFILEPOS(ch) == neg_player_frags[i].playerid)
            {
	      for (j = i; j < 14;j++)
                {
		  neg_player_frags[j] = neg_player_frags[j+1];
                }
	      neg_player_frags[14].frag = 0.0;
	      neg_player_frags[14].playerid = 0;
	      strcpy(neg_player_frags[14].name, "");
	      return TRUE;         
            }
        }
    }
  return FALSE;
}


/ ***************************************************************************
 * adds person to frag list
 *************************************************************************** /
bool add_to_frag_list(struct char_data *ch, bool pos)
{
  int i, j;
  if (pos)
    {
      for (i = 0;i <= 14;i++)
        {     
	  if (pos_player_frags[i].frag < GET_FRAG(ch))
            {  / *  ok insert person with frag details. * /
	       / *  1. copy all others down * /
	      for (j = 14;j > i; j--)  
                {
		  pos_player_frags[j] = pos_player_frags[j - 1];
                }
	      pos_player_frags[i].playerid = GET_PFILEPOS(ch);
	      strcpy(pos_player_frags[i].name, GET_NAME(ch));
	      pos_player_frags[i].frag = GET_FRAG(ch);
	      return TRUE;
            }
        }
    } 
  else
    {
      for (i = 0;i <= 14;i++)
        {
	  if (neg_player_frags[i].frag > GET_FRAG(ch))
            {  / *  ok insert person with frag details. * /
	       / *  1. copy all others down * /
	      for (j = 14;j > i; j--)
                {
		  neg_player_frags[j] = neg_player_frags[j - 1];
                }
	      neg_player_frags[i].playerid = GET_PFILEPOS(ch);
	      strcpy(neg_player_frags[i].name, GET_NAME(ch));
	      neg_player_frags[i].frag = GET_FRAG(ch);
	      return TRUE;
            }
        }
    }
  return FALSE;   
}
end of section to be removed */ 

d1828 3
@


1.96
log
@Use adjust_size instead of direct modification.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.95 2008/03/10 18:01:17 myc Exp jps $
d38 1
d308 1
a308 1
  struct trophy_data *node;
d311 1
a311 1
  for (node = GET_TROPHY(ch).oldest; node; node = node->next) {
d2027 3
@


1.95
log
@Quick aggro won't go off if you are flagged no hassle.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.94 2008/03/09 06:38:37 jps Exp myc $
d489 1
a489 1
    GET_SIZE(ch) += mod;
d2026 3
@


1.94
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.93 2008/03/08 23:20:06 myc Exp jps $
d854 1
a854 1
    else if (!ALONE(ch) && !IS_NPC(ch)) {
d2026 5
@


1.93
log
@Free events in free_char instead of in extract_char.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.92 2008/03/05 05:21:56 myc Exp myc $
d1114 1
a1114 1
    if (isname(tmp, i->player.name)){
d1524 1
a1524 1
        !str_cmp(i->player.name, name) && CAN_SEE(ch, i))
d1538 1
a1538 1
      !str_cmp(i->player.name, name) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
d1564 1
a1564 1
    if (isname(tmp, i->player.name) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
d1587 1
a1587 1
    if (isname(tmp, i->player.name)){
d1613 1
a1613 1
    if (isname(tmp, i->player.name) && GET_INVIS_LEV(i) <= GET_LEVEL(ch))
d1636 1
a1636 1
    if (isname(tmp, i->player.name) && CAN_SEE(ch, i))
d2026 3
@


1.92
log
@Removed frags.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.91 2008/03/05 03:03:54 myc Exp myc $
a1488 5
  if (ch->events)
     cancel_event_list(&(ch->events));
  for (i = 0; i < EVENT_FLAG_FIELDS; ++i)
    ch->event_flags[i] = 0;

d2026 3
@


1.91
log
@Moved the trophy_update function to players.c and updated
perform_trophy_decrease for the new trophy structures.  Reversed
the order of scale_attribs and update_stats calls in affect_total
so it isn't stupid.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.90 2008/02/16 20:31:32 myc Exp myc $
a39 2
extern struct player_frags_data pos_player_frags[15];
extern struct player_frags_data neg_player_frags[15];
a45 2
/* bool remove_from_frag_list(struct char_data *ch, bool); */
/* bool add_to_frag_list(struct char_data *ch, bool); */
d2031 6
@


1.90
log
@Moving script extraction from extract_char/extract_obj to
free_char/free_obj.  Moving clear_quest list to free_char.
Moving clear_memory to free_char.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.89 2008/02/09 21:07:50 myc Exp myc $
d37 1
a110 33
/*Trophy Utilities*/
void trophy_update(struct char_data *ch, struct char_data *vict, float amount)
{
  int tmp_virtual, i;
  if (!ch) /* fix those funny guys dropping link while fighting */
    return;
  if (IS_NPC(ch))
    return;
  if (IS_NPC(vict))
    tmp_virtual = GET_MOB_VNUM(vict);
  else
    tmp_virtual = 0 - GET_RACE(vict);
  for (i = 0;i<=USE_TROPHY;i++)
    {
      if ((GET_TROPHY(ch, i).virtual == tmp_virtual) && (GET_TROPHY(ch, i).value > 0.0))
        {
	  GET_TROPHY(ch, i).value = GET_TROPHY(ch, i).value + amount;
	  return;
        }
    }
  /*if here new trophy so move records down one and add new one*/
  GET_TROPHY(ch, GET_TRTOP(ch)).virtual = tmp_virtual;
  GET_TROPHY(ch, GET_TRTOP(ch)).value = amount;
  /*move top pointer on*/
  if (GET_TRTOP(ch) >= (USE_TROPHY))/*end of array*/
    GET_TRTOP(ch) = 0;
  else 
    GET_TRTOP(ch)++;
  
}



d310 16
a325 24
  float x = 0;
  int i;
  bool found = FALSE;
  /*check to see if in trophy*/
  for (i = 0;i <= USE_TROPHY; i++)
    {
      if (GET_TROPHY(ch, i).virtual > 0)
        {/*npc trophy*/
	  if (GET_TROPHY(ch, i).virtual == GET_MOB_VNUM(vict))
            {
	      x = GET_TROPHY(ch, i).value;
	      found = TRUE;
	      break;
            }
        }
      else
        {/*pc trophy*/
	  if (abs(GET_TROPHY(ch, i).virtual) == GET_RACE(vict))
            {
	      x = GET_TROPHY(ch, i).value;
	      found = TRUE;
	      break;
            }
        }
d327 3
a329 4
  if (!(found))
    return exp;
  
  if (x < 2.01)
d331 1
a331 1
  else if (x < 3.01)
d333 1
a333 1
  else if(x < 5.01)
d335 1
a335 1
  else if (x < 7.01)
d337 1
a337 1
  else if (x < 10.01)
d633 1
a634 1
    scale_attribs(ch);
d2035 5
@


1.89
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.88 2008/02/09 18:29:11 myc Exp myc $
a51 1
void clear_memory(struct char_data * ch);
a1395 3
  if (SCRIPT(obj))
    extract_script(SCRIPT(obj));

a1421 2
  struct quest_list * cq;
  struct quest_list * nq;
a1519 24
  /* clear quest list*/
  cq = ch->quests;
  while (cq) {
    nq = cq->next;
    if (cq->variables) {
      struct quest_var_list* temp; 
      struct quest_var_list* np; 

      temp = cq->variables;

      while (temp) {
        np = temp->next;
        FREE(temp->var);
        FREE(temp->val); 	
        FREE(temp); 
        temp = np; 
      }
    }

    free (cq);
    cq = nq;
  }
  ch->quests = NULL;

a1546 3
    clear_memory(ch);		/* Only NPC's can have memory */
    if (SCRIPT(ch))
      extract_script(SCRIPT(ch));
d2076 4
@


1.88
log
@The event code now handles freeing of event objects.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.87 2008/02/09 04:27:47 myc Exp myc $
d892 2
a893 2
       event_create(EVENT_AUTODOUSE, autodouse_event,
             mkgenericevent(ch, 0, 0), &(ch->events), 0);
d904 1
a904 1
                     mkgenericevent(ch, tch, 0), &(ch->events), 0);
d1229 1
a1229 1
            &(object->events), 2);
d1511 1
a1511 6
    if (IS_NPC(ch))
      REMOVE_BIT(MOB_FLAGS(ch), MOB_CASTING);
    else
      REMOVE_BIT(PLR_FLAGS(ch), PLR_CASTING);
    if ((ch)->casting.obj) obj_forget_caster((ch)->casting.obj, ch);
    if ((ch)->casting.tch) char_forget_caster((ch)->casting.tch, ch);
d2109 3
@


1.87
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.86 2008/01/30 19:20:57 myc Exp myc $
d1197 1
a1197 1
   return 0;
d2114 3
@


1.86
log
@Gravity is now an event, triggered whenever a character or object
enters a room, or when a character loses fly.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.85 2008/01/29 21:02:31 myc Exp myc $
d36 1
d2114 4
@


1.85
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.84 2008/01/27 23:31:20 jps Exp myc $
d57 1
a57 1
EVENTFUNC(quick_aggro_event);
d612 2
d680 2
d866 3
d894 11
a906 7
  /* Quick aggro for players */
  if (!ALONE(ch) && !IS_NPC(ch)) {
    struct char_data *tch = find_aggr_target(ch);
    if (tch && number(0, 5))
      event_create(EVENT_QUICK_AGGRO, quick_aggro_event, 
                   mkgenericevent(ch, tch, 0), &(ch->events), 0);
  }
d1202 1
d1231 2
d1570 2
a1571 1
  ch->regenerating = 0;
d2113 4
@


1.84
log
@Fix stop-casting for extracted chars.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.83 2008/01/27 13:40:58 jps Exp jps $
d35 1
a39 7
extern int top_of_world;
extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
a41 1
extern char *race_abbrevs[];
d65 1
a65 1
char *fname(char *namelist)
d79 1
a79 1
int isname(char *str, char *namelist)
d81 1
a81 1
  register char *curname, *curstr;
d2098 3
@


1.83
log
@Removing unused function prototype scale_attribs().
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.82 2008/01/26 14:26:31 jps Exp jps $
d1502 8
a1509 6
  if (IS_NPC(ch))
    REMOVE_BIT(MOB_FLAGS(ch), MOB_CASTING);
  else
    REMOVE_BIT(PLR_FLAGS(ch), PLR_CASTING);
  if ((ch)->casting.obj) obj_forget_caster((ch)->casting.obj, ch);
  if ((ch)->casting.tch) char_forget_caster((ch)->casting.tch, ch);
d2105 3
@


1.82
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.81 2008/01/26 07:27:27 jps Exp jps $
a394 1
  extern void scale_attribs(struct char_data *ch);
d621 1
a621 2
  extern void scale_attribs(struct char_data *ch);
  
d2103 3
@


1.81
log
@Stop a char from casting any spells as it's extracted.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.80 2008/01/17 04:10:07 myc Exp jps $
d32 3
d2105 3
@


1.80
log
@Updating get_obj_by_obj() and get_char_room_mscript() to check
UIDs against the calling object and char (since find_replacement
now returns a UID for the object/char instead of "self" now).
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.79 2008/01/16 04:12:00 myc Exp myc $
d60 1
d1501 7
d2102 5
@


1.79
log
@Adding quick-aggro event.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.78 2008/01/14 21:28:54 myc Exp myc $
d1624 3
d2094 3
@


1.78
log
@Disabled player "quick-aggro".
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.77 2008/01/12 23:13:20 myc Exp myc $
d43 1
a43 1
extern struct char_data *pick_target(struct char_data *ch);
d60 1
d893 2
a894 2
  /* some new stuff for aggro code Banyal*/
  /* Disabled for now - Laoris
d896 4
a899 3
    struct char_data *tch = pick_target(ch);
    if (tch && is_aggr_to(ch, tch) && number(0, 5))
      hit(ch, tch, TYPE_UNDEFINED);
a900 1
  */
d2091 3
@


1.77
log
@Added multi-purpose get_random_char_around function to pick random chars
in a room.  Renamed clearMemory clear_memory.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.76 2008/01/12 19:08:14 myc Exp myc $
a865 1
  struct char_data *t_ch;
d893 5
a897 7
  if(ALONE(ch))
    return;
  if(!IS_NPC(ch)) {
    t_ch = pick_target(ch);
    if (t_ch && is_aggr_to(ch, t_ch))
      if (number(0, 5))
	hit(t_ch, ch, TYPE_UNDEFINED);
d899 1
d2090 4
@


1.76
log
@Rewrote a lot of mob AI functionality.
Renamed 'picktarget' as 'pick_target'.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.75 2008/01/10 05:39:43 myc Exp myc $
d55 1
a55 1
void clearMemory(struct char_data * ch);
d1563 1
a1563 1
    clearMemory(ch);		/* Only NPC's can have memory */
d2057 33
d2092 4
@


1.75
log
@alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.74 2008/01/09 01:51:42 jps Exp myc $
d43 1
a43 1
extern struct char_data *picktarget(struct char_data *ch);
d897 1
a897 1
    t_ch = picktarget(ch);
d2059 4
@


1.74
log
@Get rid of obsolete points events.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.73 2008/01/06 05:32:56 jps Exp jps $
d528 1
a528 1
    alter_hit(ch, -1 * (mod), 3);
d2059 3
@


1.73
log
@Use macro NOWEAR_CLASS for equipment restrictions.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.72 2008/01/05 05:37:31 jps Exp jps $
a1545 7
  /* cancel point updates */
  for (i = 0; i < 3; ++i)
    if (GET_POINTS_EVENT(ch, i)) {
      event_cancel(GET_POINTS_EVENT(ch, i));
      GET_POINTS_EVENT(ch, i) = NULL;
    }
  
d1553 1
d2059 3
@


1.72
log
@Added function init_char() to handle updating of class and race-
related skills, innates, and other stuff.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.71 2008/01/04 01:53:26 jps Exp jps $
d984 16
a999 28
  int j;
  int invalid_class(struct char_data *ch, struct obj_data *obj);
  
  assert(pos >= 0 && pos < NUM_WEARS);
  
  if (GET_EQ(ch, pos)) {
    sprintf(buf, "SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
	    obj->short_description);
    log(buf);
    return;
  }
  if (obj->carried_by) {
    log("SYSERR: EQUIP: Obj is carried_by when equip.");
    return;
  }
  if (obj->in_room != NOWHERE) {
    log("SYSERR: EQUIP: Obj is in_room when equip.");
    return;
  }
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if ((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
	(IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
	invalid_class(ch, obj)) {
      act("You can not use $p.", FALSE, ch, obj, 0, TO_CHAR);
      /*act("$n is zapped by $p and instantly lets go of it.", FALSE, ch, obj, 0, TO_ROOM);*/
      obj_to_char(obj, ch);	/* changed to drop in inventory instead of
				 * ground */
d1001 24
a1024 15
    }
  }
  
  GET_EQ(ch, pos) = obj;
  obj->worn_by = ch;
  obj->worn_on = pos;
  
  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
    GET_AC(ch) -= apply_ac(ch, pos);
  
   if (ch->in_room != NOWHERE) {
      if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1)
         world[ch->in_room].light++;
   } else
      log("SYSERR: ch->in_room = NOWHERE when equipping char.");
d1026 9
a1034 9
  
   for (j = 0; j < MAX_OBJ_AFFECT; j++)
      affect_modify(ch, obj->affected[j].location,
                    obj->affected[j].modifier,
                    obj->obj_flags.spell_flags,
                    obj->obj_flags.spell_flags2,
                    obj->obj_flags.spell_flags3, TRUE);
  
  affect_total(ch);
a1037 1

d2065 4
@


1.71
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.70 2007/12/25 19:45:55 jps Exp jps $
a59 2
void set_racial_affects(struct char_data *ch);
void set_class_affects(struct char_data *ch);
d793 26
d1066 2
a1067 4
  /* Reapply all the racial affects in case they were
     removed above. DCE 07-dec-01 */
  set_class_affects(ch);
  set_racial_affects(ch);
d1567 1
a1567 1
    save_char(ch);
d2069 4
d2087 1
a2087 1
 * save_char() no longer requires you to supply a save/load room
@


1.70
log
@Move flying check from affect_modify to affect_total so it doesn't get
executed as much.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.69 2007/12/25 05:41:49 jps Exp jps $
d31 1
a45 1
extern char *race_target[];
d1139 1
a1139 1
    }else if (is_abbrev(name, RACE_TARG(i)))
d1581 1
a1581 1
	!str_cmp(i->player.name, name) && CAN_SEE(ch, i))
a1582 3
  /*else if (is_abbrev(name, RACE_TARG(i)))
    if (CAN_SEE(ch, i))
    return i;*/
d1690 1
a1690 1
    if (isname(tmp, i->player.name) && CAN_SEE(ch, i))/*{*/
d1692 1
a1692 5
	return i;/*}*/
  /*else if (is_abbrev(name, RACE_TARG(i)))
    if (CAN_SEE(ch, i))
    if (++j == number)
    return i;*/
d2047 4
@


1.69
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.68 2007/12/23 19:27:26 jps Exp jps $
a406 3
    if (IS_SET(bitv1, AFF_FLYING) && AFF_FLAGGED(ch, AFF_FLYING) &&
        GET_POS(ch) == POS_FLYING)
      GET_POS(ch) = POS_STANDING;
d682 3
d2054 5
@


1.68
log
@Use global object iterator to prevent decay events from operating on
already-extracted objects.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.67 2007/12/19 20:51:38 myc Exp jps $
d865 2
a866 1
       event_create(autodouse_event, ch, 0);
d1162 13
d1181 1
d1195 10
a1204 4
    if((SECT(room) == SECT_WATER_SWIM || SECT(room) == SECT_WATER_NOSWIM ||
	SECT(room) == SECT_OCEAN) && (!IS_OBJ_STAT(object, ITEM_FLOAT))) {
      act("$p&4&b sinks like a rock.&0",FALSE,0,object,0,TO_ROOM);
      extract_obj(object);
d1207 1
d1372 3
d1540 3
d1557 1
a1557 1
  
d2054 4
@


1.67
log
@save_char() no longer requires you to supply a save/load room
(which wasn't being used anyway).
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.66 2007/12/09 03:31:46 jps Exp myc $
d1290 6
d1340 3
d2026 4
@


1.66
log
@Add a position check - it will force the position to be updated
correctly when you use the wizard command 'set', among other situations.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.65 2007/11/25 00:04:59 jps Exp jps $
d1508 1
a1508 1
    save_char(ch, NOWHERE);
d2017 4
@


1.65
log
@Spell targets will keep close track of whoever's casting a spell
at them.  This allows spells to be safely aborted if the target
is removed from the game before the spell is completed.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.64 2007/10/26 23:49:30 myc Exp jps $
d685 1
d2017 5
@


1.64
log
@AC applies should be negative.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.63 2007/10/25 20:39:11 myc Exp myc $
d1294 3
a1296 1
  
d1443 5
d2016 3
@


1.63
log
@Fixed a bug where the corpse decomposition message expected the
corpse to be on the ground.  Not always true.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.62 2007/10/11 20:14:48 myc Exp myc $
d552 1
a552 1
    GET_AC(ch) += mod;
d2009 4
@


1.62
log
@Fixed some bugs in the behavior of affect_join when doing "refresh"
spells.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.61 2007/10/04 16:20:24 myc Exp myc $
d1296 1
a1296 1
  if(IS_PLR_CORPSE(obj)) {
d1301 13
a1313 1
    sprintf(buf, "killed: %s has DECOMPOSED in [%d] %s.", obj->short_description, world[obj->in_room].number, world[obj->in_room].name);
d2009 4
@


1.61
log
@Got rid of update_char_objects, because all objects are being updated
by point_update in limits.c
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.60 2007/10/02 02:52:27 myc Exp myc $
a765 1
  bool found = FALSE;
d767 2
a768 3
  for (hjp = ch->affected; !found && hjp; hjp = hjp->next) {
    
    if ((hjp->type == af->type) && (hjp->location == af->location)) {
d771 3
a773 1
      else if (refresh)
a774 2
      if (avg_dur)
	af->duration >>= 1;
d779 1
a779 1
	af->modifier >>= 1;
d787 1
a787 1
      found = TRUE;
d789 3
a791 3
  }
  if (!found)
    affect_to_char(ch, af);
d1997 4
@


1.60
log
@Cleaned up extract_char.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.59 2007/09/20 21:20:43 myc Exp myc $
a1332 45
/* This is where items with a timer field get it decremented.
 *
 * The decrement of the timer field is normally 1.  However,
 * if the object is worn, or if it's an activated light, the
 * timer is decremented by 2.
 */

void update_char_object(struct char_data *ch, struct obj_data *obj, bool worn) {
   int weardown;

   weardown = worn ? 2 : 1;

   /* IF:
    * -- it's a light
    * -- and it's lit
    * -- and it isn't permanent
    */
   if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0) == 1 &&
         GET_OBJ_VAL(obj, 2) > 0) {
      weardown = 2;
   }

   if (GET_OBJ_TIMER(obj) > 0) {
      GET_OBJ_TIMER(obj) -= weardown;
      if (GET_OBJ_TIMER(obj) < 0)
        GET_OBJ_TIMER(obj) = 0;
   }
   if (obj->contains)
      update_char_object(ch, obj->contains, FALSE);
   if (obj->next_content)
      update_char_object(ch, obj->next_content, FALSE);
}

void update_char_objects(struct char_data * ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      update_char_object(ch, GET_EQ(ch, i), TRUE);

  if (ch->carrying)
     update_char_object(ch, ch->carrying, FALSE);
}

d1999 3
@


1.59
log
@Hide points and perception are in.  Fixed a lot of affect-handling
code to work more smoothly (and sanely).
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.58 2007/09/15 15:36:48 myc Exp myc $
d1395 1
a1395 1
  struct descriptor_data *t_desc;
a1399 1
  int save_room;
a1402 1
  
a1403 1
  
a1406 1
  void stop_ignoring_me(struct char_data *ch); 
d1408 1
a1408 5
  if (!IS_NPC(ch) && !ch->desc) {
    for (t_desc = descriptor_list; t_desc; t_desc = t_desc->next)
      if (t_desc->original == ch)
	do_return(t_desc->character, "", 0, 1);
  }
a1411 1
    /*abort();*/ /* not really sure what the purpose of this is */
d1413 21
a1433 1
  stop_ignoring_me(ch);
d1435 1
d1438 1
d1441 1
d1444 1
d1447 2
a1448 1
  if(ch->guarding) 
d1450 1
a1450 1
  if(ch->guarded_by)
d1452 1
d1486 2
a1487 1
      obj_to_room(unequip_char(ch, i), ch->in_room);/*}*/
d1490 16
a1505 8
  while(cq)
  {
        nq = cq->next;

	if (cq->variables)
	  {
	    struct quest_var_list* temp; 
	    struct quest_var_list* np; 
d1507 2
a1508 15
	    temp = cq->variables;

	    while(temp)
	      {
		FREE(temp->var);
		FREE(temp->val); 
		
		np = temp->next;
		FREE(temp); 
		temp = np; 
	      };
	  };
   
	free (cq);
        cq=nq;
d1510 1
a1510 1
  ch->quests = (struct quest_list *)NULL;
a1514 1
  
d1522 1
a1522 1
  for (i = 0; i < 3; i++)
a1528 1
  save_room = ch->in_room;
a1532 3
  if (ch->desc && ch->desc->original)
    do_return(ch, "", 0, 1);
  
d2044 4
@


1.58
log
@Cleaned up affect-handling code a lot.  It didn't properly handle
bitvectors 1, 2, and 3.  Now it does.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.57 2007/09/03 22:53:54 jps Exp myc $
d389 2
a390 4
/* This fuction redone by proky...Banyal*/

void affect_modify(struct char_data * ch, byte loc, sh_int mod, long bitv,
		   bool add, int aff_vector)
d394 28
a421 1
  if (!add)
d423 1
a424 22
  switch (aff_vector) {
    case 0:
    case 1:
      if (add)
        SET_BIT(AFF_FLAGS(ch), bitv);
      else
        REMOVE_BIT(AFF_FLAGS(ch), bitv);
      break;
    case 2:
      if (add) 
        SET_BIT(AFF2_FLAGS(ch), bitv);
      else
        REMOVE_BIT(AFF2_FLAGS(ch), bitv);
      break;
    case 3:
      if (add)
        SET_BIT(AFF3_FLAGS(ch), bitv);
      else
        REMOVE_BIT(AFF3_FLAGS(ch), bitv);
      break;
  }  
    
d432 1
a432 1
        GET_VIEWED_STR(ch) +=mod;
a508 1
    
d595 10
a614 3
/*This function redone by proky....Banyal
 */

d627 1
a627 1
      for (j = 0; j < MAX_OBJ_AFFECT; j++) {
d630 3
a632 8
                      GET_EQ(ch, i)->obj_flags.spell_flags, FALSE, 0);
        if (GET_EQ(ch, i)->obj_flags.spell_flags2)
          affect_modify(ch, APPLY_NONE, 0,
                        GET_EQ(ch, i)->obj_flags.spell_flags2, FALSE, 2);
        if (GET_EQ(ch, i)->obj_flags.spell_flags3)
          affect_modify(ch, APPLY_NONE, 0,
                        GET_EQ(ch, i)->obj_flags.spell_flags3, FALSE, 3);
      }
d635 3
a637 7
  for (af = ch->affected; af; af = af->next) {
    affect_modify(ch, af->location, af->modifier, af->bitvector, FALSE, 0);
    if (af->bitvector2)
      affect_modify(ch, APPLY_NONE, 0, af->bitvector2, FALSE, 2);
    if (af->bitvector3)
      affect_modify(ch, APPLY_NONE, 0, af->bitvector3, FALSE, 3);
  }
d652 1
a652 1
      for (j = 0; j < MAX_OBJ_AFFECT; j++) {
d655 7
a661 16
                      GET_EQ(ch, i)->obj_flags.spell_flags, TRUE, 0);
        if (GET_EQ(ch, i)->obj_flags.spell_flags2)
          affect_modify(ch, APPLY_NONE, 0,
                        GET_EQ(ch, i)->obj_flags.spell_flags2, TRUE, 2);
        if (GET_EQ(ch, i)->obj_flags.spell_flags3)
          affect_modify(ch, APPLY_NONE, 0,
                        GET_EQ(ch, i)->obj_flags.spell_flags3, TRUE, 3);
      }

  for (af = ch->affected; af; af = af->next) {
    affect_modify(ch, af->location, af->modifier, af->bitvector, TRUE, 0);
    if (af->bitvector2)
      affect_modify(ch, APPLY_NONE, 0, af->bitvector2, TRUE, 2);
    if (af->bitvector3)
      affect_modify(ch, APPLY_NONE, 0, af->bitvector3, TRUE, 3);
  }
d700 2
a701 9
  affect_modify(ch, af->location, af->modifier, af->bitvector, TRUE, 0);
  if (af->bitvector2) {
    if (IS_SET(af->bitvector2, AFF2_LIGHT))
      if (ch->in_room != NOWHERE && !AFF2_FLAGGED(ch, AFF2_LIGHT))
        world[ch->in_room].light++;      
    affect_modify(ch, APPLY_NONE, 0, af->bitvector2, TRUE, 2);
  }
  if (af->bitvector3)
    affect_modify(ch, APPLY_NONE, 0, af->bitvector3, TRUE, 3);
d719 2
a720 13
  if (IS_SET(af->bitvector, AFF_FLYING) &&
      AFF_FLAGGED(ch, AFF_FLYING) && GET_POS(ch) == POS_FLYING)
    GET_POS(ch) = POS_STANDING;

  affect_modify(ch, af->location, af->modifier, af->bitvector, FALSE, 0);
  if (af->bitvector2) {
    if (IS_SET(af->bitvector2, AFF2_LIGHT))
      if (ch->in_room != NOWHERE && AFF2_FLAGGED(ch, AFF2_LIGHT))
	world[ch->in_room].light--;
    affect_modify(ch, APPLY_NONE, 0, af->bitvector2, FALSE, 2);
  }
  if (af->bitvector3)
    affect_modify(ch, APPLY_NONE, 0, af->bitvector3, FALSE, 3);
a960 1
  bool con = FALSE;
a1001 2
      if (!AFF2_FLAGGED(ch, AFF2_LIGHT) && IS_OBJ_SPELL_AFF2(obj, AFF2_LIGHT))
         world[ch->in_room].light++;
d1006 1
a1006 13
  /* Add spell effects - DCE 07-dec-01 */
  if (IS_OBJ_SPELL_AFF(obj, GET_OBJ_SPELL(obj)))
    SET_BIT(AFF_FLAGS(ch), GET_OBJ_SPELL(obj));
  if (IS_OBJ_SPELL_AFF2(obj, GET_OBJ_SPELL2(obj)))
    SET_BIT(AFF2_FLAGS(ch), GET_OBJ_SPELL2(obj));
  if (IS_OBJ_SPELL_AFF3(obj, GET_OBJ_SPELL3(obj)))
    SET_BIT(AFF3_FLAGS(ch), GET_OBJ_SPELL3(obj));
  update_pos(ch);
  
   for (j = 0; j < MAX_OBJ_AFFECT; j++) {
      if (!(IS_NPC(ch)))
         if (obj->affected[j].location == APPLY_CON)
            con = TRUE;
d1008 4
a1011 3
      obj->affected[j].modifier,
      obj->obj_flags.bitvector, TRUE, 0);
   }
a1013 2
  /*if (con)
    con_aff(ch);*/
d1020 1
a1020 1
  int j;bool con = FALSE;
a1036 2
    if (AFF2_FLAGGED(ch, AFF2_LIGHT) && IS_OBJ_SPELL_AFF2(obj, AFF2_LIGHT))
      world[ch->in_room].light--;
a1041 9
  /* Remove spell effects - DCE 07-dec-01 */
  if (IS_OBJ_SPELL_AFF(obj, GET_OBJ_SPELL(obj)))
    REMOVE_BIT(AFF_FLAGS(ch), GET_OBJ_SPELL(obj));
  if (IS_OBJ_SPELL_AFF2(obj, GET_OBJ_SPELL2(obj)))  
    REMOVE_BIT(AFF2_FLAGS(ch), GET_OBJ_SPELL2(obj));
  if (IS_OBJ_SPELL_AFF3(obj, GET_OBJ_SPELL3(obj)))  
    REMOVE_BIT(AFF3_FLAGS(ch), GET_OBJ_SPELL3(obj));
  update_pos(ch);  

d1047 7
a1053 10
  for (j = 0; j < MAX_OBJ_AFFECT; j++) {
    if (!(IS_NPC(ch)))
      if (obj->affected[j].location == APPLY_CON)
        con = TRUE;
      affect_modify(ch, obj->affected[j].location,
                    obj->affected[j].modifier,
                    obj->obj_flags.bitvector, FALSE, 0);
    
  }
  
a1054 2
  /*if (con)
    con_aff(ch);*/
d2036 4
@


1.57
log
@Make a person's flames go out automatically if they enter a water room.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.56 2007/09/01 21:22:29 jps Exp jps $
a393 1
  int maxabil;
d396 23
a418 23
  if (!aff_vector) {
    if (add) 
      SET_BIT(AFF_FLAGS(ch), bitv);
    else{
      REMOVE_BIT(AFF_FLAGS(ch), bitv);
      mod = -mod;
    }
  }
  if (aff_vector==2) {
    if (add) 
      SET_BIT(AFF2_FLAGS(ch), bitv);
    else{
      REMOVE_BIT(AFF2_FLAGS(ch), bitv);
      mod = -mod;
    }
  }
  if (aff_vector==3) {
    if(add)
      SET_BIT(AFF3_FLAGS(ch), bitv);
    else{ 
      REMOVE_BIT(AFF3_FLAGS(ch), bitv);
      mod = -mod;
    }  
d420 1
a420 3
  
  maxabil = (IS_NPC(ch) ? 100 : 100);
  
a530 1
    /*GET_HIT(ch)+=mod;*/
d535 1
d611 1
a611 2
  int i, j, vector=0;
  long bit;
a612 2
   /*   int tmp_con; */
   /*   bool con = FALSE; */
d614 1
d616 12
a627 9
    {
      if (GET_EQ(ch, i))	
	for (j = 0; j < MAX_OBJ_AFFECT; j++) /*Max_obj_affect is 6*/
	  {       
            affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
			  GET_EQ(ch, i)->affected[j].modifier,
			  GET_EQ(ch, i)->obj_flags.bitvector, FALSE, 0);
	  }
    }
d629 8
a636 21
  for (af = ch->affected; af; af = af->next)
    {
      bit=0;
      vector=0;
      if(af->bitvector!=0)
	{
	  bit = af->bitvector;    
	  vector=0;
	}
      else if(af->bitvector2!=0)
	{
	  bit = af->bitvector2;
	  vector=2;
	}
      else if(af->bitvector3!=0) 
	{
	  bit = af->bitvector3;
	  vector=3;
	}
      affect_modify(ch, af->location, af->modifier, bit, FALSE, vector);
    }
d647 2
a648 1
  
d650 37
a686 56
    {
      if (GET_EQ(ch, i))
	for (j = 0; j < MAX_OBJ_AFFECT; j++)
	  {
	    affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
			  GET_EQ(ch, i)->affected[j].modifier,
			  GET_EQ(ch, i)->obj_flags.bitvector, TRUE, 0);
	  }   
    }
  /*set ac to 100 here as its re-calculated after this function*/
  if (!(IS_NPC(ch)))
    GET_AC(ch) = 100;
  
  for (af = ch->affected; af; af = af->next) 
    {
      bit = 0;
      vector=0;
      if(af->bitvector!=0)
	{
	  bit = af->bitvector;    
	  vector=0;
	}
      else if(af->bitvector2!=0)
	{
	  bit = af->bitvector2;
	  vector=2;
	}
      else if(af->bitvector3!=0) 
	{
	  bit = af->bitvector3;
	  vector=3;
	}
      affect_modify(ch, af->location, af->modifier, bit, TRUE, vector);
    }
  
  
  if (IS_NPC(ch)) 
    { /*Data Effecting NPC (computer characters)*/
      i = 100; /* changed from 25 to 100 for the new system */
      GET_DEX(ch) = MAX(0, MIN(GET_DEX(ch), i));
      GET_INT(ch) = MAX(0, MIN(GET_INT(ch), i));
      GET_WIS(ch) = MAX(0, MIN(GET_WIS(ch), i));
      GET_CON(ch) = MAX(0, MIN(GET_CON(ch), i));
      GET_STR(ch) = MAX(0, MIN(GET_STR(ch), i));
    } 
  else 
    {
      /*Data if a PC ok*/
      i = 100;
      GET_VIEWED_DEX(ch) = MAX(0, MIN(GET_VIEWED_DEX(ch), i));
      GET_VIEWED_INT(ch) = MAX(0, MIN(GET_VIEWED_INT(ch), i));
      GET_VIEWED_WIS(ch) = MAX(0, MIN(GET_VIEWED_WIS(ch), i));
      GET_VIEWED_CON(ch) = MAX(0, MIN(GET_VIEWED_CON(ch), i));
      GET_VIEWED_CHA(ch) = MAX(0, MIN(GET_VIEWED_CHA(ch), i));
      GET_VIEWED_STR(ch) = MAX(0, MIN(GET_VIEWED_STR(ch), i));
    }
a699 2
  long bit=0;bool con = FALSE;
  int vector = 0;
d708 9
a716 17
  if(af->bitvector!=0)
    bit = af->bitvector;    
  else if(af->bitvector2!=0){
    bit = af->bitvector2;
    vector=2;
    if (af->bitvector2 == AFF2_LIGHT)
      if (ch->in_room != -1 && !AFF2_FLAGGED(ch, AFF2_LIGHT))
	world[ch->in_room].light++;
  }
  else if(af->bitvector3!=0) {
    bit = af->bitvector3;
    vector=3;
  }
  if (!(IS_NPC(ch)))
    if (af->location == APPLY_CON)
      con = TRUE;
  affect_modify(ch, af->location, af->modifier, bit, TRUE, vector);
a718 2
  /* if (con)
     con_aff(ch);*/
a730 2
  long bit = 0;bool con = FALSE;
  int vector = 0;
d734 8
a741 15
  if(af->bitvector!=0) {
    bit = af->bitvector;    
    if (af->bitvector == AFF_FLYING && GET_POS(ch)==POS_FLYING){
       /*  act("You gently float back to the ground.",FALSE,ch,0,0,TO_CHAR); */
      /* This line below is crashing the mud so I did some changes to it Banyal*/
       /*   sprintf(buf, "%n floats back to the ground.", GET_NAME(ch)); */
       /*  act(buf,FALSE,ch,0,0,TO_ROOM); */
      GET_POS(ch) = POS_STANDING;
    }
  }
  else if(af->bitvector2!=0){
    bit = af->bitvector2;
    vector=2;
    if (af->bitvector2==AFF2_LIGHT)
      if (ch->in_room != -1 && AFF2_FLAGGED(ch, AFF2_LIGHT))
d743 1
d745 3
a747 10
  else if(af->bitvector3!=0) {
    bit = af->bitvector3;
    vector=3;
  }
  if (!(IS_NPC(ch)))
    if (af->location == APPLY_CON)
      con = TRUE;
  
  affect_modify(ch, af->location, af->modifier, bit, FALSE,vector);
  
a750 2
  /*if (con)
    con_aff(ch);*/
d808 4
d2094 3
@


1.56
log
@Made _mscript detection routines.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.55 2007/09/01 20:45:47 jps Exp jps $
d926 1
d947 5
d2152 3
@


1.55
log
@Fix!
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.54 2007/09/01 20:34:10 jps Exp jps $
d1682 13
d1696 3
a1698 2
/* Like get_char_room_vis, but doesn't take visibility into account */
struct char_data *get_char_in_room(struct char_data * ch, char *name)
d1710 1
a1710 1
    return get_player_vis(ch, tmp, 1);
d1713 1
a1713 1
    if (isname(tmp, i->player.name))
d1745 23
d1819 28
d2146 3
@


1.54
log
@Add function get_char_in_room, which bypasses CAN_SEE, for
scripting m* commands.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.53 2007/08/30 20:00:09 jps Exp jps $
d1699 1
a1699 1
    if (CAN_SEE(ch, i))
d2081 4
@


1.53
log
@Oops, purge_objs wasn't actually purging.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.52 2007/08/30 19:42:46 jps Exp jps $
d1683 23
a1712 1
  /* JE 7/18/94 :-) :-) */
d2081 3
@


1.52
log
@Add function purge_objs() to destroy all objects on a character.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.51 2007/08/14 22:43:07 myc Exp jps $
a1489 1
   struct obj_data *obj;
d1492 2
a1493 5
   while (ch->carrying) {
      obj = ch->carrying;
      obj_from_char(obj);
      obj_to_room(obj, ch->in_room);
   }
d1497 1
a1497 1
         obj_to_room(unequip_char(ch, i), ch->in_room);
d2059 3
@


1.51
log
@Added cornering/cornered_by clean-up to extract_char.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.50 2007/07/25 02:57:26 myc Exp myc $
d1488 15
d1505 1
a1505 2
/* Extract a ch completely from the world, and leave his stuff behind 
maybe leave stuf behind >:) Banyal*/
d1573 1
a1573 2
  /* transfer objects to room, if any if not camping is now an event*/
  /*if (!PRF_FLAGGED(ch, PRF_CAMPING)){*/
d1578 1
a1578 1
  }/*}*/
d1580 1
a1580 2
  /* transfer equipment to room, if any if not camping is now an event*/
  /*if (!PRF_FLAGGED(ch, PRF_CAMPING)){*/
d2063 3
@


1.50
log
@Only set crashsave bit in obj_from_char for players.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.49 2007/07/24 01:24:37 myc Exp myc $
d1536 10
d2051 3
@


1.49
log
@AFF2_LIGHT on objects will no longer cause permadarkened rooms.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.48 2007/07/14 01:42:38 jps Exp myc $
d994 2
a995 1
  SET_BIT(PLR_FLAGS(object->carried_by), PLR_CRASH);
d2041 3
@


1.48
log
@Stop trying to set the PLR_CRASH bit on NPCs when they receive an object.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.47 2007/04/11 14:15:28 jps Exp jps $
d749 1
a749 1
      if (ch->in_room != -1)
d795 1
a795 1
      if (ch->in_room != -1)     
d1037 2
a1038 1
  int j;bool con = FALSE;
d1080 2
d1084 1
d1130 2
d2040 3
@


1.47
log
@Give money piles proper keywords and make them dissolve when stolen.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.46 2006/12/07 02:34:42 myc Exp jps $
d973 1
a973 1
    SET_BIT(PLR_FLAGS(ch), PLR_CRASH);
d2034 3
@


1.46
log
@Aff2 Light flag won't cause permadark anymore.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.45 2006/12/04 17:56:29 myc Exp myc $
d1782 2
d1785 54
a1838 40
char *money_desc(int amount)
{
  static char buf[128];
  
  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money.");
    return NULL;
  }
  if (amount == 1)
    strcpy(buf, "a single coin");
  else if (amount <= 9)
    strcpy(buf, "a tiny pile of coins");
  else if (amount <= 20)
    strcpy(buf, "a handful of coins");
  else if (amount <= 75)
    strcpy(buf, "a little pile of coins");
  else if (amount <= 200)
    strcpy(buf, "a small pile of coins");
  else if (amount <= 1000)
    strcpy(buf, "a pile of coins");
  else if (amount <= 5000)
    strcpy(buf, "a big pile of coins");
  else if (amount <= 10000)
    strcpy(buf, "a large heap of coins");
  else if (amount <= 20000)
    strcpy(buf, "a huge mound of coins");
  else if (amount <= 75000)
    strcpy(buf, "an enormous mound of coins");
  else if (amount <= 150000)
    strcpy(buf, "a small mountain of coins");
  else if (amount <= 250000)
    strcpy(buf, "a mountain of coins");
  else if (amount <= 500000)
    strcpy(buf, "a huge mountain of coins");
  else if (amount <= 1000000)
    strcpy(buf, "an enormous mountain of coins");
  else
    strcpy(buf, "an absolutely colossal mountain of gold coins");
  
  return buf;
d1846 1
a1846 1
 char buf[200];
d1883 6
a1888 3
   obj->name = str_dup("coins");
   obj->short_description = str_dup(money_desc(amount));
   sprintf(buf, "%s is lying here.", money_desc(amount));
a1889 2
   
   new_descr->keyword = str_dup("coins");
d2034 3
@


1.45
log
@Fixed a crash bug with update_char_object, containers, and recursive looping.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.44 2006/11/21 03:45:52 jps Exp $
d896 3
d2017 3
@


1.44
log
@Running down of lights is now handled in limits.c.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.43 2006/11/20 22:24:17 jps Exp jps $
d1455 1
a1455 1
   if (GET_OBJ_TIMER(obj) > 0)
d1457 3
d1461 1
a1461 1
      update_char_object(ch, obj, FALSE);
d2014 3
@


1.43
log
@End the difficulties in interaction between evil and good player races.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.42 2006/11/18 07:36:48 jps Exp jps $
d880 18
a902 1
  struct obj_data *obj, *next_obj;
d911 2
a912 13
  
  if (IS_AFFECTED2(ch,AFF2_LIGHT) || ((GET_EQ(ch, WEAR_LIGHT) != NULL) &&
				      (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT) &&
				      (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light is ON */
    if (ch->in_room != -1)
      world[ch->in_room].light--;
  
  for(obj=ch->carrying;obj;obj=next_obj) {
    next_obj = obj->next_content;
    if((GET_OBJ_TYPE(obj) == ITEM_LIGHT) && (GET_OBJ_VAL(obj,0) == 1))
      if (ch->in_room != -1)
        world[ch->in_room].light--;
  }
a923 1
  struct obj_data *obj, *next_obj;  
a934 11
    
    if (IS_AFFECTED2(ch,AFF2_LIGHT) || (GET_EQ(ch, WEAR_LIGHT) &&
					GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT &&
					(GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light ON */
      world[room].light++;

  for(obj=ch->carrying;obj;obj=next_obj) {
    next_obj = obj->next_content;
    if((GET_OBJ_TYPE(obj) == ITEM_LIGHT) && (GET_OBJ_VAL(obj,0) == 1))
        world[room].light++;
  }
d936 2
a937 1
    
d1073 5
a1077 6
  if (ch->in_room != NOWHERE) {
     
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && 
        GET_OBJ_VAL(obj, 0) == 1)
      world[ch->in_room].light++;
  }
a1078 7
  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))	/* if light is ON */
	world[ch->in_room].light++;
  } else
    log("SYSERR: ch->in_room = NOWHERE when equipping char.");

d1088 1
a1088 2
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    {
d1090 2
a1091 2
	if (obj->affected[j].location == APPLY_CON)
	  con = TRUE;
d1093 3
a1095 3
		    obj->affected[j].modifier,
		    obj->obj_flags.bitvector, TRUE, 0);
    }
a1122 6
  }

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))	/* if light is ON */
	world[ch->in_room].light--;
d1433 11
d1445 16
a1460 8
void update_object(struct obj_data * obj, int use)
{
  if (GET_OBJ_TIMER(obj) > 0)
    GET_OBJ_TIMER(obj) -= use;
  if (obj->contains)
    update_object(obj->contains, use);
  if (obj->next_content)
    update_object(obj->next_content, use);
a1462 1

a1465 17
  struct obj_data *obj, *next_obj;

  /* Run down a light if equipped "as light" */
  if (GET_EQ(ch, WEAR_LIGHT) != NULL)
    if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT)
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2) > 0) {
	i = --GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2);
	if (i == 1) {
	  act("Your $o begins to flicker and fade.", FALSE, ch, GET_EQ(ch, WEAR_LIGHT), 0, TO_CHAR);
	  act("$n's $o begins to flicker and fade.", FALSE, ch, GET_EQ(ch, WEAR_LIGHT), 0, TO_ROOM);
	} else if (i == 0) {
	  act("Your $o sputters out and dies.", FALSE, ch, GET_EQ(ch, WEAR_LIGHT), 0, TO_CHAR);
	  act("$n's $o sputters out and dies.", FALSE, ch, GET_EQ(ch, WEAR_LIGHT), 0, TO_ROOM);
	  world[ch->in_room].light--;
     GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 0) = 0;
	}
      }
d1469 1
a1469 1
      update_object(GET_EQ(ch, i), 2);
d1471 2
a1472 19
  /* Run down all lights carried in inventory */
  for (obj = ch->carrying; obj; obj = next_obj) {
    next_obj = obj->next_content;
    if ((GET_OBJ_TYPE(obj) == ITEM_LIGHT) && (GET_OBJ_VAL(obj, 0) == 1) && (GET_OBJ_VAL(obj, 2) > 0)) {
       i = --GET_OBJ_VAL(obj, 2);
       if (i == 1) {
           act("Your $o begins to flicker and fade.", FALSE, ch, obj, 0, TO_CHAR);
           act("$n's $o begins to flicker and fade.", FALSE, ch, obj, 0, TO_ROOM);
       } else if (i == 0) {
           act("Your $o sputters out and dies.", FALSE, ch, obj, 0, TO_CHAR);
           act("$n's $o sputters out and dies.", FALSE, ch, obj, 0, TO_ROOM);
           world[ch->in_room].light--;
           GET_OBJ_VAL(obj, 0) = 0;
       }
       update_object(obj, 2);
    } else {
       update_object(obj, 1);
    }
  }
d2011 3
@


1.42
log
@Specify what light object is burning out.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.41 2006/11/18 04:26:32 jps Exp jps $
d1709 2
a1710 13
    }else if (is_abbrev(name, RACE_TARG(i)))
      if (CAN_SEE(ch, i))
	if (i != ch && GET_RACE_ALIGN(ch) != GET_RACE_ALIGN(i))
	  /*if (++j == number)*/
	  return i;
  
  /* for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)*/
  /*sprintf(buf, "%s", RACE_ABBR(i));
    if (str_cmp(tmp, RACE_ABBR(i)))
    if (CAN_SEE(ch, i))
    if (++j == number)
    return i;*/
  
d2047 3
@


1.41
log
@Renamed continual light spell to illumination, and it only works on
LIGHT items (still rooms too).
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.40 2006/11/18 00:03:31 jps Exp jps $
d1476 2
a1477 2
	  act("Your light begins to flicker and fade.", FALSE, ch, 0, 0, TO_CHAR);
	  act("$n's light begins to flicker and fade.", FALSE, ch, 0, 0, TO_ROOM);
d1479 2
a1480 2
	  act("Your light sputters out and dies.", FALSE, ch, 0, 0, TO_CHAR);
	  act("$n's light sputters out and dies.", FALSE, ch, 0, 0, TO_ROOM);
d1496 2
a1497 2
           act("Your light begins to flicker and fade.", FALSE, ch, 0, 0, TO_CHAR);
           act("$n's light begins to flicker and fade.", FALSE, ch, 0, 0, TO_ROOM);
d1499 2
a1500 2
           act("Your light sputters out and dies.", FALSE, ch, 0, 0, TO_CHAR);
           act("$n's light sputters out and dies.", FALSE, ch, 0, 0, TO_ROOM);
d2058 4
@


1.40
log
@Fix continual light items to always work when they have the
bit set.  Rooms now print an indicator of being continually lit.
Can't use it to make a room permanently lit any more.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.39 2006/11/17 03:47:30 jps Exp jps $
a883 1
  int j;
a900 8
/* David Endre 2/16/99 - Stupid ommision on my part */
  for(j=0;j<NUM_WEARS;j++)
    if (GET_EQ(ch,j) != NULL)
       if (IS_OBJ_STAT(GET_EQ(ch, j), ITEM_CONT_LIGHT))
        world[ch->in_room].light--; 

/* David Endre 2/4/99 & 2/9/99 */

a905 3
      if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT) && !obj->in_obj)
      if (ch->in_room != -1)
        world[ch->in_room].light--;
a916 1
  int j;
a935 8
/* David Endre 2/16/99 - Stupid ommision on my part */
  for(j=0;j<NUM_WEARS;j++)
    if (GET_EQ(ch,j) != NULL)
       if (IS_OBJ_STAT(GET_EQ(ch, j), ITEM_CONT_LIGHT))
        world[ch->in_room].light++; 

/* David Endre 2/4/99 & 2/9/99 */

a939 2
    if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT) && !obj->in_obj)
        world[room].light++;
a969 2
    if (IS_OBJ_STAT(object, ITEM_CONT_LIGHT) && !object->in_obj)
       world[ch->in_room].light++;    
a991 2
  if (IS_OBJ_STAT(object, ITEM_CONT_LIGHT) && !object->in_obj)
      world[object->carried_by->in_room].light--;
a1079 2
    if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT) && !obj->in_obj)
      world[ch->in_room].light++;
a1133 2
    if (IS_OBJ_STAT(obj, ITEM_CONT_LIGHT) && !obj->in_obj)
      world[ch->in_room].light--;
a1298 2
    if (IS_OBJ_STAT(object, ITEM_CONT_LIGHT) && !object->in_obj)
      world[object->in_room].light++;
a1333 2
  if (IS_OBJ_STAT(object, ITEM_CONT_LIGHT) && !object->in_obj)
    world[object->in_room].light--;
d2058 5
@


1.39
log
@Eliminate points_event events being enqueued for outgoing players.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.38 2006/11/15 06:19:18 jps Exp jps $
d905 1
a905 1
      if (GET_EQ(ch,j)->obj_flags.extra_flags == ITEM_CONT_LIGHT)
d915 1
a915 1
    if(obj->obj_flags.extra_flags == ITEM_CONT_LIGHT && !obj->in_obj)
d952 1
a952 1
      if (GET_EQ(ch,j)->obj_flags.extra_flags == ITEM_CONT_LIGHT)
d961 1
a961 1
    if(obj->obj_flags.extra_flags == ITEM_CONT_LIGHT && !obj->in_obj)
d993 1
a993 1
    if(object->obj_flags.extra_flags == ITEM_CONT_LIGHT && !object->in_obj)
d1017 1
a1017 1
  if(object->obj_flags.extra_flags == ITEM_CONT_LIGHT && !object->in_obj)
d1106 2
a1107 1
    if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT && !obj->in_obj)
d1163 1
a1163 1
    if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT && !obj->in_obj)
d1330 1
a1330 1
    if (object->obj_flags.extra_flags == ITEM_CONT_LIGHT && !object->in_obj)
d1367 1
a1367 1
  if (object->obj_flags.extra_flags == ITEM_CONT_LIGHT && !object->in_obj)
d2093 3
@


1.38
log
@Fix crash where a player being extracted would have more regen events enqueued.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.37 2006/11/13 18:15:05 jps Exp jps $
d725 1
a725 2
  if (ch->in_room != NOWHERE)
     check_regen_rates(ch);	/* update regen rates (for age) */		
d2092 3
@


1.37
log
@Fix lights to actually actually burn out.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.36 2006/11/08 21:36:05 jps Exp jps $
d725 2
a726 1
  check_regen_rates(ch);	/* update regen rates (for age) */		
d1676 1
d2093 3
@


1.36
log
@Fix so lights anywhere in inventory (not just top slot) can burn out.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.35 2006/11/07 06:15:02 jps Exp jps $
d1516 1
d1536 1
a1536 1
           GET_OBJ_VAL(ch->carrying, 0) = 0;
d2091 3
@


1.35
log
@'animate dead' - raised mobs would double-decrease their load
count, having died twice.
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.34 2006/04/27 02:32:05 dce Exp $
d1502 1
d1504 1
d1523 13
a1535 15
  i = 0;
  if (ch->carrying) {
    if ((GET_OBJ_TYPE(ch->carrying) == ITEM_LIGHT) && (GET_OBJ_VAL(ch->carrying, 0) == 1)) {
       if (GET_OBJ_VAL(ch->carrying, 2) > 0) {
          i = --GET_OBJ_VAL(ch->carrying, 2);
       	    if (i == 1) {
	        act("Your light begins to flicker and fade.", FALSE, ch, 0, 0, TO_CHAR);
	        act("$n's light begins to flicker and fade.", FALSE, ch, 0, 0, TO_ROOM);
  	    } else if (i == 0) {
	        act("Your light sputters out and dies.", FALSE, ch, 0, 0, TO_CHAR);
	        act("$n's light sputters out and dies.", FALSE, ch, 0, 0, TO_ROOM);
	        world[ch->in_room].light--;
                GET_OBJ_VAL(ch->carrying, 0) = 0;
	    }
          update_object(ch->carrying, 2); 
d1537 4
a1540 2
    } else
          update_object(ch->carrying, 1);
d2090 4
@


1.34
log
@Put a cap on hitgain of 100 to prevent crashes
because hitgain is only defined as a sbyte
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.33 2002/09/19 01:07:53 jjl Exp dce $
d1675 2
a1676 1
    if (GET_MOB_RNUM(ch) > -1)		/* if mobile */
d2088 4
@


1.33
log
@Update to add in quest variables!
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.32 2002/09/13 02:32:10 jjl Exp $
d589 5
a593 2
      case APPLY_HIT_REGEN:
      ch->char_specials.hitgain += mod; 
d2087 3
@


1.32
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: handler.c,v 1.31 2001/12/18 23:52:27 dce Exp $
d1618 20
a1637 1
        free (cq);
d1641 1
a1641 1
  
d2084 3
@


1.31
log
@Made a small addtion to affect_total to finish off fixing
the attributes and items problem. Which was items that
affect your atrribs mess up your attribs..
@
text
@d1 3
a3 1
// $Id: handler.c,v 1.30 2001/12/18 03:29:04 dce Exp $
d145 2
d156 1
a156 1
  // ok remove if not a good enough kill
d171 2
a172 2
  // GET_FRAG(ch) = GET_FRAG(ch) + amount;
  //  GET_FRAG(victim) = GET_FRAG(victim) - amount;
d175 2
a176 2
  // ok check globel list
  // extern struct player_frags_data player_frags[19];
d178 1
a178 1
    { // if in list remove
d210 1
a210 1
  // fragger not on list
d252 3
a254 1
// removes person from frag list
d298 3
a300 1
// adds person to frag list
d309 2
a310 2
            { // ok insert person with frag details.
	      // 1. copy all others down
d327 2
a328 2
            { // ok insert person with frag details.
	      // 1. copy all others down
d614 2
a615 2
  //  int tmp_con;
  //  bool con = FALSE;
d781 1
a781 1
      // act("You gently float back to the ground.",FALSE,ch,0,0,TO_CHAR);
d783 2
a784 2
      //  sprintf(buf, "%n floats back to the ground.", GET_NAME(ch));
      // act(buf,FALSE,ch,0,0,TO_ROOM);
d2063 130
a2192 123
// $Log: handler.c,v $
// Revision 1.30  2001/12/18 03:29:04  dce
// Fixed the bug where if you have a natural stat of 100, and
// then an item added to that stat. You would actually lose
// points to the stat when you removed the item. The root
// of the cause was in affect_modify. I added a check to see
// if the affect was being added or subtracted. If it was being
// subtracted then I made sure that AFFECTED_STAT - mod was
// not less than NATURAL_STAT.
//
// Revision 1.29  2001/12/07 15:42:30  dce
// Fixed a bug with object spell effects where if a player
// was wearing an item and died, they would permanently
// gain that ability.
//
// Revision 1.28  2001/03/10 18:45:33  dce
// Changed do_return function to pass a subcommand of 1.
// This way I can make it so players can't use the return command.
//
// Revision 1.27  2000/11/29 00:47:35  mtp
// fix problem wthat makes quest list grow if player doesnt completely log out
//
// Revision 1.26  2000/11/25 08:07:20  rsd
// Altered debug in corpse decay to use short description
// and not the name to make the debug resemble english.
//
// Revision 1.25  2000/11/20 03:10:54  rsd
// Altered comment header and added back rlog messages from
// pior to the addition of the $log$ string.
//
// Revision 1.24  2000/11/13 02:38:21  rsd
// Added log message for when a player corpse decomposes.
//
// Revision 1.23  1999/11/28 23:26:09  cso
// obj_to_room: modified to use IS_PLR_CORPSE macro
// obj_from_obj: same
// extract_obj: same
//
// Revision 1.22  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.21  1999/03/05 20:02:36  dce
// Chant added to, and songs craeted
//
// Revision 1.20  1999/03/04 20:13:51  jimmy
// removed silly debug message
// fingon
//
// Revision 1.19  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
//
// Revision 1.18  1999/02/26 22:30:30  dce
// Monk additions/fixes
//
// Revision 1.17  1999/02/23 16:48:06  dce
// Creates a new command called file. Allows us to view files
// through the mud.
//
// Revision 1.16  1999/02/13 19:35:06  mud
// commented out unused variable in line 1554 associated with
//  /* Subclassing explaination/preface */ which was commented
// earlier to hide subclasses from players at login.
//
// Revision 1.15  1999/02/12 21:43:38  mud
// Ok, I finished moving the subclass issue from the class selection view
// the todo list will have more on the work remaining on this.
//
// Revision 1.14  1999/02/12 21:41:28  mud
// I removed the View of the subclasses from the class Selection screen
// In doing so I've created a warning, I have no idea how to fix it,
// someone take a peek at it?
//
// Revision 1.13  1999/02/10 22:21:42  jimmy
// Added do_wiztitle that allows gods to edit their
// godly title ie Overlord.  Also added this title
// to the playerfile
// fingon
//
// Revision 1.12  1999/02/07 07:29:01  mud
// removed debug message
//
// Revision 1.11  1999/02/06 05:32:46  jimmy
// Fixed buffer overflow in do_alias
// fingon
//
// Revision 1.10  1999/02/06 04:29:51  dce
// David Endre 2/5/99
// Added do_light
//
// Revision 1.9  1999/02/06 00:40:36  jimmy
// Major change to incorporate aliases into the pfile
// moved alias structure from interpreter.h to structs.h
// heavily modified alias code in interpreter.c
// Jimmy Kincaid AKA fingon
//
// Revision 1.8  1999/02/04 16:42:34  jimmy
// Combined attributes, score, and exp commands.
//
// Revision 1.7  1999/02/04 00:02:59  jimmy
// max/min exp loss/gain set to 2 notches.
//
// Revision 1.6  1999/02/01 22:40:16  jimmy
// made listspells an LVL_IMMORT command
//
// Revision 1.5  1999/02/01 08:15:46  jimmy
// improved build counter
//
// Revision 1.4  1999/02/01 04:18:50  jimmy
// Added buildcounter to GREETING --Fingon
//
// Revision 1.3  1999/01/31 06:43:09  mud
// Indented file
//
// Revision 1.2  1999/01/29 04:06:46  jimmy
// temp remove races from login menu
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial Revision
//
@


1.30
log
@Fixed the bug where if you have a natural stat of 100, and
then an item added to that stat. You would actually lose
points to the stat when you removed the item. The root
of the cause was in affect_modify. I added a check to see
if the affect was being added or subtracted. If it was being
subtracted then I made sure that AFFECTED_STAT - mod was
not less than NATURAL_STAT.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.29 2001/12/07 15:42:30 dce Exp $
a382 2


d641 10
d2056 9
@


1.29
log
@Fixed a bug with object spell effects where if a player
was wearing an item and died, they would permanently
gain that ability.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.28 2001/03/10 18:45:33 dce Exp $
d423 11
a433 4
    if ((GET_VIEWED_STR(ch) + mod) <= 100)
      GET_VIEWED_STR(ch) +=mod;
    else
      GET_VIEWED_STR(ch) = 100;
d436 11
a446 4
    if ((GET_VIEWED_DEX(ch) + mod) <= 100)
      GET_VIEWED_DEX(ch) +=mod;
    else
      GET_VIEWED_DEX(ch) = 100;
d449 11
a459 4
    if ((GET_VIEWED_INT(ch) + mod) <= 100)
      GET_VIEWED_INT(ch) +=mod;
    else
      GET_VIEWED_INT(ch) = 100;
d462 11
a472 4
    if ((GET_VIEWED_WIS(ch) + mod) <= 100)
      GET_VIEWED_WIS(ch) +=mod;
    else
      GET_VIEWED_WIS(ch) = 100;
d475 11
a485 4
    if ((GET_VIEWED_CON(ch) + mod) <= 100)
      GET_VIEWED_CON(ch) +=mod;
    else
      GET_VIEWED_CON(ch) = 100;
d488 11
a498 4
    if ((GET_VIEWED_CHA(ch) + mod) <= 100)
      GET_VIEWED_CHA(ch) +=mod;
    else
      GET_VIEWED_CHA(ch) = 100;
d2048 5
@


1.28
log
@Changed do_return function to pass a subcommand of 1.
This way I can make it so players can't use the return command.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.27 2000/11/29 00:47:35 mtp Exp $
d58 2
d1058 9
d1113 1
a1113 1
    log("SYSERR: ch->in_room = NOWHERE when equipping char.");
d1116 17
a1132 3
  
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    {  if (!(IS_NPC(ch)))
d1135 3
a1137 3
    affect_modify(ch, obj->affected[j].location,
		  obj->affected[j].modifier,
		  obj->obj_flags.bitvector, FALSE, 0);
d1139 1
a1139 1
    }
d2006 4
@


1.27
log
@fix problem wthat makes quest list grow if player doesnt completely log out
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.26 2000/11/25 08:07:20 rsd Exp mtp $
d1483 1
a1483 1
	do_return(t_desc->character, "", 0, 0);
d1564 1
a1564 1
    do_return(ch, "", 0, 0);
d1981 3
@


1.26
log
@Altered debug in corpse decay to use short description
and not the name to make the debug resemble english.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.25 2000/11/20 03:10:54 rsd Exp $
d28 1
d1465 2
d1530 9
d1981 4
@


1.25
log
@Altered comment header and added back rlog messages from
pior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.24 2000/11/13 02:38:21 rsd Exp $
d1370 1
a1370 1
    sprintf(buf, "killed %s has DECOMPOSED in [%d] %s.", obj->name, world[obj->in_room].number, world[obj->in_room].name);
d1969 4
@


1.24
log
@Added log message for when a player corpse decomposes.
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.23 1999/11/28 23:26:09 cso Exp $
d3 1
a3 1
 *   File: handler.c                                     Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d1969 3
d1979 82
@


1.23
log
@obj_to_room: modified to use IS_PLR_CORPSE macro
obj_from_obj: same
extract_obj: same
@
text
@d1 1
a1 1
// $Id: handler.c,v 1.22 1999/09/05 07:00:39 jimmy Exp $
d1363 1
a1363 1
  if(IS_PLR_CORPSE(obj))
d1365 6
a1370 1
    
d1967 5
@


1.22
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d544 1
d1256 2
a1257 1
    if (IS_CORPSE(object) && GET_OBJ_VAL(object, 1)) {
d1340 2
a1341 1
  if(IS_CORPSE(obj_from) && GET_OBJ_VAL(obj_from, 1))
d1362 2
a1363 1
  if(IS_CORPSE(obj) && GET_OBJ_VAL(obj, 1)) {
a1364 1
  }
a1365 1
  
d1961 4
a1964 1
// $Log$
@


1.21
log
@More small but important bug fixes found with insure.  These are all runtime fixes.
@
text
@d1 1
d1959 1
@


1.20
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d1253 1
d1255 1
a1255 1
      if ((i = find_corpse(GET_OBJ_VAL(object,2)))) {
@


1.19
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d330 1
a330 1
int perform_trophy_decrease(struct char_data *ch, struct char_data *vict, int exp)
d363 1
a363 1
    return (int) (exp * .95);
d365 1
a365 1
    return (int) (exp * .85);
d367 1
a367 1
    return (int) (exp * .65);
d369 1
a369 1
    return (int) (exp * .45);
d371 1
a371 1
    return (int) (exp * .3);
@


1.18
log
@Removed corpse saving log.
@
text
@d44 2
a45 2
bool remove_from_frag_list(struct char_data *ch, bool);
bool add_to_frag_list(struct char_data *ch, bool);
d137 2
a138 3

void frag_update(struct char_data *ch, struct char_data *victim, float amount)
{
d141 1
a141 8
  /*this updates a persons frag then checks to see if globel 
    frag list needs updating
    struct pos and neg _player_frags_data {
    int playerid;
    char name[MAX_NAME_LENGTH+1];
    float frag;
    }*/ int i;
  /*int j = 0;*/
d143 1
a143 1
  if(!ch) /* fix those funny guys dropping link while fighting */
d146 1
a146 1
  /*ok remove if not a good enough kill*/
d165 2
a166 2
  /*ok check globel list*/
  /*extern struct player_frags_data player_frags[19];*/
d168 1
a168 1
    {/*if in list remove*/
d200 1
a200 1
  /*fragger not on list*/
d242 1
a242 1
/*removes person from frag list*/
d286 1
a286 1
/*adds person to frag list*/
d295 2
a296 2
            {/*ok insert person with frag details.*/
	      /*1. copy all others down*/
d313 2
a314 2
            {/*ok insert person with frag details.*/
	      /*1. copy all others down*/
d328 1
@


1.17
log
@removed an abort() and an exit() for stability.  Still yet to determine
how people end up in room = -1
@
text
@a1262 2
        log("Corpse about to be saved from handler.c");
        mudlog("Corpse about to be saved from handler.c", BRF, LVL_HEAD_B, TRUE);
a1364 2
    log("About to destroy a decaying corpse.");
    mudlog("About to destory a decaying corpse.", BRF, LVL_HEAD_B, TRUE);
@


1.16
log
@fixed another frag_update NULL check
@
text
@d829 1
a829 1
    exit(1);
d1485 1
a1485 1
    abort();
@


1.15
log
@fixed new bug in trophy_update() that didn't check for NULL ch
@
text
@d150 4
@


1.14
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@d110 2
@


1.13
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@a45 2
void change_affected_stats(struct char_data * ch);
void load_results(struct char_data * ch);
d384 2
a385 1
  
d418 2
a419 2
    if ((GET_STR_VAFF(ch) + mod) < 121)
      GET_STR_VAFF(ch) +=mod;
d421 1
a421 1
      GET_STR_VAFF(ch) = 120;
d424 2
a425 2
    if ((GET_DEX_VAFF(ch) + mod) < 121)
      GET_DEX_VAFF(ch) +=mod;
d427 1
a427 1
      GET_DEX_VAFF(ch) = 120;
d430 2
a431 2
    if ((GET_INT_VAFF(ch) + mod) < 121)
      GET_INT_VAFF(ch) +=mod;
d433 1
a433 1
      GET_INT_VAFF(ch) = 120;
d436 2
a437 2
    if ((GET_WIS_VAFF(ch) + mod) < 121)
      GET_WIS_VAFF(ch) +=mod;
d439 1
a439 1
      GET_WIS_VAFF(ch) = 120;
d442 2
a443 2
    if ((GET_CON_VAFF(ch) + mod) < 121)
      GET_CON_VAFF(ch) +=mod;
d445 1
a445 1
      GET_CON_VAFF(ch) = 120;
d448 2
a449 2
    if ((GET_CHA_VAFF(ch) + mod) < 121)
      GET_CHA_VAFF(ch) +=mod;
d451 1
a451 1
      GET_CHA_VAFF(ch) = 120;
d544 1
a544 1
  
d559 1
a595 1
  ch->vaff_abils = ch->view_abils;
d635 2
a636 2
      i = 25;
      GET_DEX(ch) = MAX(0, MIN(GET_INT(ch), i));
d640 2
a641 3
      GET_STR(ch) = MAX(0, GET_STR(ch));
      GET_STR(ch)= MIN(GET_STR(ch), i);
   } 
d646 6
a651 12
      GET_DEX_VAFF(ch) = MAX(0, MIN(GET_DEX_VAFF(ch), i));
      GET_INT_VAFF(ch) = MAX(0, MIN(GET_INT_VAFF(ch), i));
      GET_WIS_VAFF(ch) = MAX(0, MIN(GET_WIS_VAFF(ch), i));
      GET_CON_VAFF(ch) = MAX(0, MIN(GET_CON_VAFF(ch), i));
      GET_CHA_VAFF(ch) = MAX(0, MIN(GET_CHA_VAFF(ch), i));
      GET_STR_VAFF(ch) = MAX(0, GET_STR_VAFF(ch));
      if (GET_STR_VAFF(ch) > 100) 
	{
	  i = GET_ADD_VAFF(ch) + ((GET_STR_VAFF(ch) - 100) * 5);
	  GET_ADD_VAFF(ch) = MIN(i, 100);
	  GET_STR_VAFF(ch) = 100;    
	}
a652 1
  change_affected_stats(ch);
d654 4
a657 3
  if (!(IS_NPC(ch)))
    update_stats(ch);
  
@


1.12
log
@Debuging for corpse saving
@
text
@d205 1
a205 1
  if (!chaction)
d222 2
a223 1
  if (!victimaction)
d240 1
d387 1
a387 1
  if (!aff_vector)
d394 2
a395 1
  if (aff_vector==2)
d402 2
a403 1
  if (aff_vector==3)
d410 1
a410 1
  
@


1.11
log
@Updated debug messages in comm.c and handler.c to include
more useful info, as well as adding an abort where exit
used to be in order to get a core.
fingon
@
text
@d1261 2
d1364 3
a1366 1
  if(IS_CORPSE(obj) && GET_OBJ_VAL(obj, 1))
d1368 2
@


1.10
log
@Chant added to, and songs craeted
@
text
@d537 2
a538 1
    log("SYSERR: Unknown apply adjust attempt (handler.c, affect_modify).");
d869 1
d871 6
a876 3
  if (!ch || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to char_to_room");
  else {
d939 1
a939 1
    log("SYSERR: NULL obj or char passed to obj_to_char");
d949 1
a949 1
    log("SYSERR: NULL object passed to obj_from_char");
d1231 1
d1233 6
a1238 3
  if (!object || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to obj_to_room");
  else {
d1274 1
a1274 1
    log("SYSERR: NULL object or obj not in a room passed to obj_from_room");
d1475 3
a1477 2
    log("SYSERR: NOWHERE extracting char. (handler.c, extract_char)");
    exit(1);
@


1.9
log
@Final fix for conitnual light. This checks a char's worn eq
for lit objects.
@
text
@d532 1
a532 1
      
a535 1
    */
@


1.8
log
@Finishes light fixes.
@
text
@d821 1
d839 6
d866 1
d882 6
d1086 8
d1360 1
a1360 10
  /* David Endre - 2/10/99 - Let's make sure the lights go off */
  if (GET_OBJ_TYPE(obj) == ITEM_LIGHT && GET_OBJ_VAL(obj, 0)==1) {
    GET_OBJ_VAL(obj, 0) = 0;
    world[obj->in_room].light--;
  }
  if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
    if (obj->in_room != NOWHERE && !obj->in_obj)
      world[obj->in_room].light--;
    else
      log("SYSERR: Extra light left in room, due to NOWHERE!");
@


1.7
log
@Fixes obj_to_char and char_to_obj for lights.
@
text
@d845 1
a845 1
    if(obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
a878 1
      // if (ch->in_room != -1)
d880 1
a880 1
    if(obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
d910 4
d917 1
a917 1
    
d934 5
d1025 1
a1025 1
    if (obj->obj_flags.extra_flags == ITEM_CONT_LIGHT)
d1213 4
d1248 5
@


1.6
log
@Lights work we loaded from a char.
@
text
@a914 8
    if (ch->in_room != NOWHERE) {
      if (object->obj_flags.extra_flags == ITEM_CONT_LIGHT)
        world[ch->in_room].light++;
      if (GET_OBJ_TYPE(object) == ITEM_LIGHT && 
          GET_OBJ_VAL(object, 0) == 1)
        world[ch->in_room].light++;
    }

a932 9
  if (object->carried_by->in_room != NOWHERE) {
    if (object->obj_flags.extra_flags == ITEM_CONT_LIGHT)
      world[object->carried_by->in_room].light--;
    if (GET_OBJ_TYPE(object) == ITEM_LIGHT && 
        GET_OBJ_VAL(object, 0) == 1)
      world[object->carried_by->in_room].light--;
  }


@


1.5
log
@Fixes continual light so the light disappears when obj is removed
@
text
@d915 8
d940 10
a949 1
  
@


1.4
log
@Fixes some of continual light.
@
text
@d1321 10
@


1.3
log
@David Endre 2/5/99
Adds do_light, to allow lights to be turned on while in
someones inventory.
@
text
@d838 1
a838 1
/* David Endre 2/4/99 */
d845 3
d874 1
a874 1
/* David Endre 2/4/99 */
d881 2
d1018 3
@


1.2
log
@Indented file
@
text
@d822 1
d838 9
d857 2
a858 1
  
d870 10
d1370 19
a1388 2
  if (ch->carrying)
    update_object(ch->carrying, 1);
@


1.1
log
@Initial revision
@
text
@d1 9
a9 9
/* ************************************************************************
*   File: handler.c                                     Part of CircleMUD *
*  Usage: internal funcs: moving and finding chars/objs                   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d67 1
a67 1

d70 1
a70 1

d72 1
a72 1

d80 1
a80 1

d86 1
a86 1

d89 1
a89 1

d92 1
a92 1

d98 1
a98 1

d111 8
a118 8
    int tmp_virtual, i;
    if (IS_NPC(ch))
        return;
    if (IS_NPC(vict))
        tmp_virtual = GET_MOB_VNUM(vict);
    else
        tmp_virtual = 0 - GET_RACE(vict);
    for (i = 0;i<=USE_TROPHY;i++)
d120 1
a120 1
        if ((GET_TROPHY(ch, i).virtual == tmp_virtual) && (GET_TROPHY(ch, i).value > 0.0))
d122 2
a123 2
            GET_TROPHY(ch, i).value = GET_TROPHY(ch, i).value + amount;
            return;
d126 9
a134 9
    /*if here new trophy so move records down one and add new one*/
    GET_TROPHY(ch, GET_TRTOP(ch)).virtual = tmp_virtual;
    GET_TROPHY(ch, GET_TRTOP(ch)).value = amount;
    /*move top pointer on*/
    if (GET_TRTOP(ch) >= (USE_TROPHY))/*end of array*/
       GET_TRTOP(ch) = 0;
    else 
       GET_TRTOP(ch)++;

d140 4
a143 4
   bool chaction = FALSE;
   bool victimaction = FALSE;
/*this updates a persons frag then checks to see if globel 
frag list needs updating
d148 24
a171 24
}*/ int i;
    /*int j = 0;*/
/*ok remove if not a good enough kill*/
   if ((!IS_NPC(ch) || (IS_NPC(ch) && (ch->desc && ch->desc->original)))  &&
 (!IS_NPC(victim) || (IS_NPC(victim) && (victim->desc && victim->desc->original))));
   else
      return;
   if ((GET_RACE_ALIGN(ch) == GET_RACE_ALIGN(victim)))
      return;
   if  ((GET_LEVEL(victim) <= 35) && ((GET_LEVEL(ch) - GET_LEVEL(victim)) > 20))
      return;
   if ((GET_LEVEL(victim) < 20) && (GET_LEVEL(ch) > 20))
      return;
   if (GET_LEVEL(ch) > 70)
      return;
        

   // GET_FRAG(ch) = GET_FRAG(ch) + amount;
   //  GET_FRAG(victim) = GET_FRAG(victim) - amount;
   GET_FRAG(ch) += amount;
   GET_FRAG(victim) -= amount;
    /*ok check globel list*/
    /*extern struct player_frags_data player_frags[19];*/
    for (i=0;i<=14;i++)
d173 1
a173 1
        if ((GET_PFILEPOS(ch) == pos_player_frags[i].playerid))
d175 4
a178 4
            if(!(remove_from_frag_list(ch, 1)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(ch, 1);
            chaction = TRUE;
d180 1
a180 1
        if ((GET_PFILEPOS(victim) == pos_player_frags[i].playerid))
d182 4
a185 4
            if (!(remove_from_frag_list(victim, 1)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(victim, 1);
            victimaction = TRUE;
d187 1
a187 1
        if ((GET_PFILEPOS(ch) == neg_player_frags[i].playerid))
d189 4
a192 4
            if(!(remove_from_frag_list(ch, 0)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(ch, 0);
            chaction = TRUE;
d194 1
a194 1
        if ((GET_PFILEPOS(victim) == neg_player_frags[i].playerid))
d196 4
a199 4
            if(!(remove_from_frag_list(victim, 0)))
                mudlog("Error in removing Frag.", NRM, LVL_GOD, FALSE);
            add_to_frag_list(victim, 0);
            victimaction = TRUE;
d202 4
a205 4
    
    
    /*fragger not on list*/
    if (!chaction)
d207 1
a207 1
    {
d209 1
a209 1
        {
d212 11
a222 11
        }
    }else
    {
       if (!(add_to_frag_list(ch, 1)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(ch));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }
    
    }
    if (!victimaction)
d224 1
a224 1
    {
d226 1
a226 1
        {
d229 10
a238 10
        }
    }else
    {
       if (!(add_to_frag_list(victim, 1)))
        {
            sprintf(buf, "%s has just joined the fragged!!", GET_NAME(victim));
            mudlog(buf, NRM, LVL_GOD, FALSE);
        }
    
    }
d247 2
a248 2
    int i, j;
    if (pos)
d250 1
a250 1
        for (i=0;i<=14;i++)
d252 1
a252 1
            if (GET_PFILEPOS(ch) == pos_player_frags[i].playerid)
d254 1
a254 1
                for (j = i; j < 14;j++)
d256 1
a256 1
                    pos_player_frags[j] = pos_player_frags[j + 1];
d258 6
a263 6
                
                
                pos_player_frags[14].frag = 0.0;
                pos_player_frags[14].playerid = 0;
                strcpy(pos_player_frags[14].name, "");  
                return TRUE;
d267 1
a267 1
    else
d269 1
a269 1
        for (i=0;i <= 14;i++)
d271 1
a271 1
            if (GET_PFILEPOS(ch) == neg_player_frags[i].playerid)
d273 1
a273 1
                for (j = i; j < 14;j++)
d275 1
a275 1
                    neg_player_frags[j] = neg_player_frags[j+1];
d277 4
a280 4
                neg_player_frags[14].frag = 0.0;
                neg_player_frags[14].playerid = 0;
                strcpy(neg_player_frags[14].name, "");
                return TRUE;         
d284 1
a284 1
    return FALSE;
d291 2
a292 2
    int i, j;
    if (pos)
d294 1
a294 1
        for (i = 0;i <= 14;i++)
d296 1
a296 1
            if (pos_player_frags[i].frag < GET_FRAG(ch))
d298 2
a299 2
        /*1. copy all others down*/
                for (j = 14;j > i; j--)  
d301 1
a301 1
                    pos_player_frags[j] = pos_player_frags[j - 1];
d303 4
a306 4
                pos_player_frags[i].playerid = GET_PFILEPOS(ch);
                strcpy(pos_player_frags[i].name, GET_NAME(ch));
                pos_player_frags[i].frag = GET_FRAG(ch);
                return TRUE;
d310 1
a310 1
    else
d312 1
a312 1
        for (i = 0;i <= 14;i++)
d314 1
a314 1
            if (neg_player_frags[i].frag > GET_FRAG(ch))
d316 2
a317 2
        /*1. copy all others down*/
                for (j = 14;j > i; j--)
d319 1
a319 1
                    neg_player_frags[j] = neg_player_frags[j - 1];
d321 4
a324 4
                neg_player_frags[i].playerid = GET_PFILEPOS(ch);
                strcpy(neg_player_frags[i].name, GET_NAME(ch));
                neg_player_frags[i].frag = GET_FRAG(ch);
                return TRUE;
d328 1
a328 1
    return FALSE;   
d333 5
a337 5
    float x = 0;
    int i;
    bool found = FALSE;
    /*check to see if in trophy*/
    for (i = 0;i <= USE_TROPHY; i++)
d339 1
a339 1
        if (GET_TROPHY(ch, i).virtual > 0)
d341 1
a341 1
            if (GET_TROPHY(ch, i).virtual == GET_MOB_VNUM(vict))
d343 3
a345 3
                x = GET_TROPHY(ch, i).value;
                found = TRUE;
                break;
d348 1
a348 1
        else
d350 1
a350 1
            if (abs(GET_TROPHY(ch, i).virtual) == GET_RACE(vict))
d352 3
a354 3
                x = GET_TROPHY(ch, i).value;
                found = TRUE;
                break;
d358 16
a373 16
    if (!(found))
        return exp;

    if (x < 2.01)
        return exp;
    else if (x < 3.01)
        return (int) (exp * .95);
    else if(x < 5.01)
        return (int) (exp * .85);
    else if (x < 7.01)
        return (int) (exp * .65);
    else if (x < 10.01)
        return (int) (exp * .45);
    else
        return (int) (exp * .3);
    
d381 1
a381 1
		        bool add, int aff_vector)
d384 1
a384 1

d407 1
a407 1

d409 1
a409 1

d413 1
a413 1

d415 5
a419 5
	if ((GET_STR_VAFF(ch) + mod) < 121)
	  GET_STR_VAFF(ch) +=mod;
	else
	  GET_STR_VAFF(ch) = 120;
	break;
d422 4
a425 4
	  GET_DEX_VAFF(ch) +=mod;
	else
		GET_DEX_VAFF(ch) = 120;
	break;
d427 5
a431 5
	if ((GET_INT_VAFF(ch) + mod) < 121)
	  GET_INT_VAFF(ch) +=mod;
	else
		GET_INT_VAFF(ch) = 120;
	break;
d434 4
a437 4
	  GET_WIS_VAFF(ch) +=mod;
	else
		GET_WIS_VAFF(ch) = 120;
	break;
d440 4
a443 4
        GET_CON_VAFF(ch) +=mod;
	else
		GET_CON_VAFF(ch) = 120;
	break;
d445 6
a450 6
  if ((GET_CHA_VAFF(ch) + mod) < 121)
	  GET_CHA_VAFF(ch) +=mod;
	else
		GET_CHA_VAFF(ch) = 120;
	break;

d452 1
a452 1

d454 1
a454 1

d458 1
a458 1

d462 1
a462 1

d466 1
a466 1

d470 1
a470 1

d474 1
a474 1

d477 2
a478 2
	alter_hit(ch, -1 * (mod), 3);
	/*GET_HIT(ch)+=mod;*/
d480 1
a480 1

d484 1
a484 1

d486 3
a488 3
	  GET_SIZE(ch) += mod;
	  break;

d491 1
a491 1

d494 1
a494 1

d496 3
a498 3
 GET_AC(ch) += mod;
   break;

d504 1
a504 1
     GET_DAMROLL(ch) = MIN(MAX_DAMROLL, (GET_DAMROLL(ch) + mod));
d506 1
a506 1

d510 1
a510 1

d514 1
a514 1

d526 11
a536 11
/*These two below are crashy in our haste I just remove em till fixed
ao we can move on....Banyal*/
/*
case APPLY_MANA_REGEN:
   ch->char_specials.managain  += mod;
     break;

case APPLY_HIT_REGEN:
   ch->char_specials.hitgain += mod; 
    break;
*/
d546 1
a546 1
*/
d556 3
a558 3
//  int tmp_con;
//  bool con = FALSE;

d560 1
a560 1
  {
d562 2
a563 2
	      for (j = 0; j < MAX_OBJ_AFFECT; j++) /*Max_obj_affect is 6*/
         {       
d565 4
a568 4
               GET_EQ(ch, i)->affected[j].modifier,
		         GET_EQ(ch, i)->obj_flags.bitvector, FALSE, 0);
         }
  }
d570 2
a571 2
   for (af = ch->affected; af; af = af->next)
   {
d575 4
a578 4
      {
         bit = af->bitvector;    
         vector=0;
      }
d580 4
a583 4
      {
         bit = af->bitvector2;
         vector=2;
      }
d585 4
a588 4
      {
         bit = af->bitvector3;
         vector=3;
      }
d590 2
a591 2
   }

d594 15
a608 15
  {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
      {
	      affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
		      GET_EQ(ch, i)->affected[j].modifier,
		      GET_EQ(ch, i)->obj_flags.bitvector, TRUE, 0);
      }   
   }
   /*set ac to 100 here as its re-calculated after this function*/
   if (!(IS_NPC(ch)))
      GET_AC(ch) = 100;

   for (af = ch->affected; af; af = af->next) 
   {
d612 4
a615 4
      {
         bit = af->bitvector;    
         vector=0;
      }
d617 4
a620 4
      {
         bit = af->bitvector2;
         vector=2;
      }
d622 4
a625 4
      {
         bit = af->bitvector3;
         vector=3;
      }
d627 5
a631 5
   }

	
   if (IS_NPC(ch)) 
   { /*Data Effecting NPC (computer characters)*/
d640 3
a642 3
   else 
   {
/*Data if a PC ok*/
d651 12
a662 12
      {
         i = GET_ADD_VAFF(ch) + ((GET_STR_VAFF(ch) - 100) * 5);
         GET_ADD_VAFF(ch) = MIN(i, 100);
	      GET_STR_VAFF(ch) = 100;    
      }
   }
   change_affected_stats(ch);
/*ok update stats*/
   if (!(IS_NPC(ch)))
      update_stats(ch);

   check_regen_rates(ch);	/* update regen rates (for age) */		
d673 1
a673 1

d675 1
a675 1

d679 1
a679 1

d687 1
a687 1
      world[ch->in_room].light++;
d693 1
a693 1
 if (!(IS_NPC(ch)))
d695 1
a695 1
        con = TRUE;
d697 1
a697 1

d699 1
a699 1
    /* if (con)
d717 1
a717 1

d721 4
a724 4
     // act("You gently float back to the ground.",FALSE,ch,0,0,TO_CHAR);
    /* This line below is crashing the mud so I did some changes to it Banyal*/
     //  sprintf(buf, "%n floats back to the ground.", GET_NAME(ch));
     // act(buf,FALSE,ch,0,0,TO_ROOM);
d732 2
a733 2
if (ch->in_room != -1)     
 world[ch->in_room].light--;
d739 1
a739 1
 if (!(IS_NPC(ch)))
d741 2
a742 2
        con = TRUE;

d744 1
a744 1

d749 1
a749 1
      con_aff(ch);*/
d758 1
a758 1

d775 2
a776 2
if (ch->affected == NULL)
return FALSE;
d780 1
a780 1

d787 2
a788 2
		      bool add_dur, bool avg_dur, bool add_mod, bool avg_mod,
		      bool refresh)
d792 1
a792 1

d794 1
a794 1

d802 1
a802 1

d807 1
a807 1

d822 1
a822 1

d827 1
a827 1

d830 1
a830 1

d832 5
a836 5
      (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT) &&
       (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light is ON */
if (ch->in_room != -1)
	world[ch->in_room].light--;

d847 1
a847 1

d854 1
a854 1

d856 5
a860 5
	GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT &&
         (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))))	/* Light ON */
	world[room].light++;

  /* Stop fighting now, if we left. */
d866 9
a874 9
/* some new stuff for aggro code Banyal*/
if(ALONE(ch))
return;
if(!IS_NPC(ch)) {
t_ch = picktarget(ch);
if (t_ch && is_aggr_to(ch, t_ch))
if (number(0, 5))
hit(t_ch, ch, TYPE_UNDEFINED);
}
d888 1
a888 1

d900 1
a900 1

d906 1
a906 1

d909 1
a909 1

d922 1
a922 1

d924 1
a924 1

d927 1
a927 1

d929 1
a929 1

d943 1
a943 1

d1023 1
a1023 1

d1026 1
a1026 1

d1030 1
a1030 1

d1033 1
a1033 1

d1040 1
a1040 1

d1042 1
a1042 1

d1044 1
a1044 1
  {  if (!(IS_NPC(ch)))
d1047 1
a1047 1
      affect_modify(ch, obj->affected[j].location,
d1050 3
a1052 3

  }

d1055 1
a1055 1
      con_aff(ch);*/
d1065 1
a1065 1

d1067 1
a1067 1

d1072 1
a1072 1

d1076 1
a1076 1

d1088 1
a1088 1

d1092 1
a1092 1

d1099 1
a1099 1

d1103 1
a1103 1

d1113 1
a1113 1

d1117 1
a1117 1

d1131 1
a1131 1

d1135 1
a1135 1

d1140 5
a1144 5
   }else if (is_abbrev(name, RACE_TARG(i)))
		  if (++j == number)
		if(i != ch) 
		  return i;

d1154 1
a1154 1

d1158 1
a1158 1

d1168 1
a1168 1

d1177 1
a1177 1
       SECT(room) == SECT_OCEAN) && (!IS_OBJ_STAT(object, ITEM_FLOAT))) {
d1201 1
a1201 1

d1206 1
a1206 1

d1208 1
a1208 1

d1220 1
a1220 1

d1225 1
a1225 1

d1229 1
a1229 1

d1232 1
a1232 1

d1244 1
a1244 1

d1251 1
a1251 1

d1255 1
a1255 1

d1260 1
a1260 1

d1263 1
a1263 1

d1285 1
a1285 1

d1288 1
a1288 1

d1298 1
a1298 1

d1302 1
a1302 1

d1304 1
a1304 1

d1310 1
a1310 1

d1367 1
a1367 1

d1369 6
a1374 6

void die_consentee(struct char_data *ch);  
void die_follower(struct char_data * ch);  
void die_groupee(struct char_data *ch);
void stop_ignoring_me(struct char_data *ch); 
void die_consentee_clean(struct char_data *ch);
d1384 2
a1385 2
stop_ignoring_me(ch);
die_consentee_clean(ch);
d1388 2
a1389 2
if (ch->groupmaster || ch->groupees)
	  die_groupee(ch);
d1391 1
a1391 1
	  die_consentee(ch);
d1393 1
a1393 1
     dismount_char(ch);
d1395 1
a1395 1
     stop_guarding(ch);
d1397 1
a1397 1
     stop_guarding(ch->guarded_by);
d1418 1
a1418 1

d1420 1
a1420 1
   /*if (!PRF_FLAGGED(ch, PRF_CAMPING)){*/
d1424 1
a1424 1

d1427 2
a1428 2
 

d1434 2
a1435 2

   /* cancel point updates */
d1441 1
a1441 1

d1444 1
a1444 1

d1447 1
a1447 1

d1450 1
a1450 1

d1459 1
a1459 1
    extract_script(SCRIPT(ch));
d1463 1
a1463 1

d1475 4
a1478 4
/* ***********************************************************************
* Here follows high-level versions of some earlier routines, ie functions*
* which incorporate the actual player-data                               *.
*********************************************************************** */
d1484 1
a1484 1

d1490 3
a1492 3
		if (CAN_SEE(ch, i))
		  return i;*/

d1503 1
a1503 1

d1507 1
a1507 1

d1512 1
a1512 1

d1518 13
a1530 13
  }else if (is_abbrev(name, RACE_TARG(i)))
		if (CAN_SEE(ch, i))
		  if (i != ch && GET_RACE_ALIGN(ch) != GET_RACE_ALIGN(i))
		  /*if (++j == number)*/
		  return i;
  
 /* for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)*/
	  /*sprintf(buf, "%s", RACE_ABBR(i));
	  if (str_cmp(tmp, RACE_ABBR(i)))
		  if (CAN_SEE(ch, i))
		  if (++j == number)
		  return i;*/

d1541 1
a1541 1

d1545 1
a1545 1

d1549 1
a1549 1

d1555 4
a1558 4
		if (CAN_SEE(ch, i))
		  if (++j == number)
		  return i;*/

d1565 1
a1565 1
				              struct obj_data * list)
d1571 1
a1571 1

d1575 1
a1575 1

d1581 1
a1581 1

d1595 1
a1595 1

d1603 1
a1603 1

d1621 1
a1621 1
		           char *arg, struct obj_data * equipment[], int *j)
d1628 1
a1628 1

d1636 1
a1636 1

d1671 1
a1671 1

d1678 75
a1752 75
  struct obj_data *obj;
  struct extra_descr_data *new_descr;
  char buf[200];
amount = pamount+gamount+samount+camount;
  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money.");
    return NULL;
  }
  obj = create_obj();
  CREATE(new_descr, struct extra_descr_data, 1);

  if (amount == 1) {
	if (pamount == 1){
	  obj->name = str_dup("platinum coin");
    obj->short_description = str_dup("a platinum coin");
	obj->description = str_dup("A single platinum coin is lying here.");
    new_descr->keyword = str_dup("coin platinum");
    new_descr->description = str_dup("A shiny platinum coin!");}
		if (gamount == 1){
	  obj->name = str_dup("gold coin");
    obj->short_description = str_dup("a gold coin");
	obj->description = str_dup("A single gold coin is lying here.");
    new_descr->keyword = str_dup("coin gold");
    new_descr->description = str_dup("A worn gold coin!");}
			if (samount == 1){
	  obj->name = str_dup("silver coin");
    obj->short_description = str_dup("a silver coin");
	obj->description = str_dup("A single silver coin is lying here.");
    new_descr->keyword = str_dup("coin silver");
    new_descr->description = str_dup("A tarnished silver coin.");}
				if (camount == 1){
	  obj->name = str_dup("copper coin");
    obj->short_description = str_dup("a copper coin");
	obj->description = str_dup("A single copper coin is lying here.");
    new_descr->keyword = str_dup("coin copper");
    new_descr->description = str_dup("A dull copper coin.");}
  }

  else {
    obj->name = str_dup("coins");
    obj->short_description = str_dup(money_desc(amount));
    sprintf(buf, "%s is lying here.", money_desc(amount));
    obj->description = str_dup(CAP(buf));

    new_descr->keyword = str_dup("coins");
    if (amount < 10) {
      sprintf(buf, "There are %d coins.", amount);
      new_descr->description = str_dup(buf);
    } else if (amount < 100) {
      sprintf(buf, "There are about %d coins.", 10 * (amount / 10));
      new_descr->description = str_dup(buf);
    } else if (amount < 1000) {
      sprintf(buf, "It looks to be about %d coins.", 100 * (amount / 100));
      new_descr->description = str_dup(buf);
    } else if (amount < 100000) {
      sprintf(buf, "You guess there are, maybe, %d coins.",
	      1000 * ((amount / 1000) + number(0, (amount / 1000))));
      new_descr->description = str_dup(buf);
    } else
      new_descr->description = str_dup("There are a LOT of coins.");
  }

  new_descr->next = NULL;
  obj->ex_description = new_descr;

  GET_OBJ_TYPE(obj) = ITEM_MONEY;
  GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE;
  GET_OBJ_VAL(obj, 0) = pamount;
  GET_OBJ_VAL(obj, 1) = gamount;
    GET_OBJ_VAL(obj, 2) = samount;
	  GET_OBJ_VAL(obj, 3) = camount;
  GET_OBJ_COST(obj) = pamount*1000+gamount*100+samount*10+camount;
  obj->item_number = NOTHING;

  return obj;
d1771 1
a1771 1
		     struct char_data ** tar_ch, struct obj_data ** tar_obj)
d1775 1
a1775 1

d1777 1
a1777 1

d1780 1
a1780 1

d1783 1
a1783 1

d1834 3
a1836 3
 
 
 /* dismount_char() / fr: Daniel Koepke (dkoepke@@california.com)
d1840 15
a1854 15
    something (either intentionally or by death, etc.)*/
 void dismount_char(struct char_data *ch) {
   if (RIDING(ch)) {
     RIDDEN_BY(RIDING(ch)) = NULL;
     RIDING(ch) = NULL;
   }
   
   if (RIDDEN_BY(ch)) {
     RIDING(RIDDEN_BY(ch)) = NULL;
     RIDDEN_BY(ch) = NULL;
   }
 }
 
 
 /* mount_char() / fr: Daniel Koepke (dkoepke@@california.com)
d1858 6
a1863 5
    messages, either.*/
 void mount_char(struct char_data *ch, struct char_data *mount) {
   RIDING(ch) = mount;
   RIDDEN_BY(mount) = ch;
  }
@
