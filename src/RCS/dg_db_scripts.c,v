head	1.23;
access;
symbols;
locks; strict;
comment	@ * @;


1.23
date	2011.08.07.01.15.42;	author rsd;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.16.20.26.04;	author myc;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.09.02.30.43;	author jps;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.05.01.03.42;	author mtp;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.28.01.20.32;	author mtp;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.21.01.28.28;	author rsd;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.09.22.43.32;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.08.22.03.28;	author mtp;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.07.07.56.08;	author mtp;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.16.08.20.03;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.13.07.34.13;	author mtp;	state Exp;
branches;
next	1.3;

1.3
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.00.08.35;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*  File: db.script.c                             Part of Death's Gate MUD *
*                                                                         *
*  Usage: Contains routines to handle db functions for scripts and trigs  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/30 21:27:54 $
*  $Revision: 3.7 $
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "db.h"
#include "handler.h"
#include "dg_event.h"
#include "comm.h"

void trig_data_copy(trig_data *this, const trig_data *trg);
void trig_data_free(trig_data *this);

extern struct index_data **trig_index;
extern int top_of_trigt;

extern struct index_data *mob_index;
extern struct index_data *obj_index;

extern void half_chop(char *string, char *arg1, char *arg2);
extern long asciiflag_conv(char *flag);

void parse_trigger(FILE *trig_f, int nr)
{
    int t[2], k, attach_type;
    char line[256], *cmds, *s, flags[256];
    struct cmdlist_element *cle;
    index_data *index;
    trig_data *trig;

    CREATE(trig, trig_data, 1);
    CREATE(index, index_data, 1);

    index->virtual = nr;
    index->number = 0;
    index->func = NULL;
    index->proto = trig;

    sprintf(buf2, "trig vnum %d", nr);

    trig->nr = top_of_trigt;
    trig->name = fread_string(trig_f, buf2);

    get_line(trig_f, line);
    k = sscanf(line, "%d %s %d", &attach_type, flags, t);
    trig->attach_type = (byte)attach_type;
    trig->trigger_type = asciiflag_conv(flags);
    trig->narg = (k == 3) ? t[0] : 0;

    trig->arglist = fread_string(trig_f, buf2);

    cmds = s = fread_string(trig_f, buf2);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cle = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
	CREATE(cle->next, struct cmdlist_element, 1);
	cle = cle->next;
	cle->cmd = str_dup(s);
    }

    free(cmds);

    trig_index[top_of_trigt++] = index;
}


/*
 * create a new trigger from a prototype.
 * nr is the real number of the trigger.
 */
trig_data *read_trigger(int nr)
{
    index_data *index;
    trig_data *trig;

    if (nr >= top_of_trigt) return NULL;
    if ((index = trig_index[nr]) == NULL)
	return NULL;

    CREATE(trig, trig_data, 1);
    trig_data_copy(trig, index->proto);

    index->number++;

    return trig;
}


/* release memory allocated for a variable list */
void free_varlist(struct trig_var_data *vd)
{
    struct trig_var_data *i, *j;

    for (i = vd; i;) {
	j = i;
	i = i->next;
	if (j->name)
	    free(j->name);
	if (j->value)
	    free(j->value);
	free(j);
    }
}


/* release memory allocated for a script */
void free_script(struct script_data *sc)
{
    trig_data *t1, *t2;

    for (t1 = TRIGGERS(sc); t1 ;) {
	t2 = t1;
	t1 = t1->next;
	trig_data_free(t2);
    }

    free_varlist(sc->global_vars);

    free(sc);
}

void trig_data_init(trig_data *this)
{
    this->nr = NOTHING;
    this->data_type = 0;
    this->name = NULL;
    this->trigger_type = 0;
    this->cmdlist = NULL;
    this->curr_state = NULL;
    this->narg = 0;
    this->arglist = NULL;
    this->depth = 0;
    this->wait_event = NULL;
    this->purged = FALSE;
    this->var_list = NULL;

    this->next = NULL;
}


void trig_data_copy(trig_data *this, const trig_data *trg)
{
    trig_data_init(this);

    this->nr = trg->nr;
    this->attach_type = trg->attach_type;
    this->data_type = trg->data_type;
    this->name = str_dup(trg->name);
    this->trigger_type = trg->trigger_type;
    this->cmdlist = trg->cmdlist;
    this->narg = trg->narg;
    if (trg->arglist) this->arglist = str_dup(trg->arglist);
}


void trig_data_free(trig_data *this)
{
/*    struct cmdlist_element *i, *j;*/

    free(this->name);

    /*
     * The command list is a memory leak right now!
     *
    if (cmdlist != trigg->cmdlist || this->proto)
	for (i = cmdlist; i;) {
	    j = i;
	    i = i->next;
	    free(j->cmd);
	    free(j);
	}
	*/

    free(this->arglist);

    free_varlist(this->var_list);

    if (this->wait_event)
	remove_event(this->wait_event);

    free(this);
}

/* for mobs and rooms: */
void dg_read_trigger(FILE *fp, void *proto, int type)
{
  char line[256];
  char junk[8];
  int vnum, rnum, count;
  char_data *mob;
  room_data *room;
  struct trig_proto_list *trg_proto, *new_trg;

  get_line(fp, line);
  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
    log(line);
    return;
  }

  switch(type) {
    case MOB_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;

      mob = (char_data *)proto;
      trg_proto = mob->proto_script;
      if (!trg_proto) {
        mob->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }
      break;
    case WLD_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;
      room = (room_data *)proto;
      trg_proto = room->proto_script;
      if (!trg_proto) {
        room->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }

      if (rnum>=0) {
        if (!(room->script))
          CREATE(room->script, struct script_data, 1);
        add_trigger(SCRIPT(room), read_trigger(rnum), -1);
      } else {
        sprintf(line,"SYSERR: non-existant trigger #%d assigned to room #%d",
          vnum, room->number);
        log(line);
      }
      break;
    default:
      sprintf(line,"SYSERR: Trigger vnum #%d assigned to non-mob/obj/room",
              vnum);
      log(line);
  }
}

void dg_obj_trigger(char *line, struct obj_data *obj)
{
  char junk[8];
  int vnum, rnum, count;
  struct trig_proto_list *trg_proto, *new_trg;

  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
    log(line);
    return;
  }

  CREATE(new_trg, struct trig_proto_list, 1);
  new_trg->vnum = vnum;
  new_trg->next = NULL;

  trg_proto = obj->proto_script;
  if (!trg_proto) {
    obj->proto_script = trg_proto = new_trg;
  } else {
    while (trg_proto->next) trg_proto = trg_proto->next;
    trg_proto->next = new_trg;
  }
}

void assign_triggers(void *i, int type)
{
  char_data *mob;
  obj_data *obj;
  struct room_data *room;
  int rnum;
  char buf[256];
  struct trig_proto_list *trg_proto;

  switch (type)
  {
    case MOB_TRIGGER:
      mob = (char_data *)i;
      trg_proto = mob->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for mob #%d",
            trg_proto->vnum, mob_index[mob->nr].virtual);
          log(buf);
        } else {
          if (!SCRIPT(mob))
            CREATE(SCRIPT(mob), struct script_data, 1);
          add_trigger(SCRIPT(mob), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case OBJ_TRIGGER:
      obj = (obj_data *)i;
      trg_proto = obj->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for obj #%d",
            trg_proto->vnum, obj_index[obj->item_number].virtual);
          log(buf);
        } else {
          if (!SCRIPT(obj))
            CREATE(SCRIPT(obj), struct script_data, 1);
          add_trigger(SCRIPT(obj), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case WLD_TRIGGER:
      room = (struct room_data *)i;
      trg_proto = room->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for room #%d",
            trg_proto->vnum, room->number);
          log(buf);
        } else {
          if (!SCRIPT(room))
            CREATE(SCRIPT(room), struct script_data, 1);
          add_trigger(SCRIPT(room), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    default:
      log("SYSERR: unknown type for assign_triggers()");
      break;
  }
}
@


1.23
log
@fixed -  warning: format not a string literal and no format arguments
@
text
@/***************************************************************************
 * $Id: dg_db_scripts.c,v 1.22 2011/08/06 15:22:51 rsd Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: dg_db_scripts.c                                Part of FieryMUD *
 *  Usage: Contains routines to handle db functions for scripts and trigs  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  Adapted from db.script.c Part of Death's Gate MUD                      *
 *  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 *                                                                         *
 *  $Author: rsd $                                                         *
 *  $Date: 2011/08/06 15:22:51 $                                           *
 *  $Revision: 1.22 $                                                       *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "db.h"
#include "handler.h"
#include "events.h"
#include "comm.h"

void trig_data_copy(trig_data *this, const trig_data *trg);

extern void half_chop(char *string, char *arg1, char *arg2);
extern long asciiflag_conv(char *flag);

void parse_trigger(FILE *trig_f, int nr)
{
  int t[2], k, attach_type;
  char line[256], *cmds, *s, flags[256];
  struct cmdlist_element *cle;
  index_data *index;
  trig_data *trig;

  CREATE(trig, trig_data, 1);
  CREATE(index, index_data, 1);

  index->virtual = nr;
  index->number = 0;
  index->func = NULL;
  index->proto = trig;

  sprintf(buf2, "trig vnum %d", nr);

  trig->nr = top_of_trigt;
  trig->name = fread_string(trig_f, buf2);

  get_line(trig_f, line);
  k = sscanf(line, "%d %s %d", &attach_type, flags, t);
  trig->attach_type = (byte)attach_type;
  trig->trigger_type = asciiflag_conv(flags);
  trig->narg = (k == 3) ? t[0] : 0;

  trig->arglist = fread_string(trig_f, buf2);

  cmds = s = fread_string(trig_f, buf2);

  CREATE(trig->cmdlist, struct cmdlist_element, 1);
  trig->cmdlist->cmd = strdup(strtok(s, "\r\n"));
  cle = trig->cmdlist;
  cle->next = NULL;        /*remove dangling pointers*/

  while ((s = strtok(NULL, "\r\n"))) {
    CREATE(cle->next, struct cmdlist_element, 1);
    cle = cle->next;
    cle->cmd = strdup(s);
    cle->next = NULL;        /*remove dangling pointers*/
  }

  free(cmds);

  trig_index[top_of_trigt++] = index;
}


/*
 * create a new trigger from a prototype.
 * nr is the real number of the trigger.
 */
trig_data *read_trigger(int nr)
{
  index_data *index;
  trig_data *trig;

  if (nr >= top_of_trigt) return NULL;
  if ((index = trig_index[nr]) == NULL)
    return NULL;

  CREATE(trig, trig_data, 1);
  trig_data_copy(trig, index->proto);

  index->number++;

  return trig;
}


/* release memory allocated for a variable list */
void free_varlist(struct trig_var_data *vd)
{
  struct trig_var_data *i, *j;

  for (i = vd; i;) {
    j = i;
    i = i->next;
    if (j->name)
      free(j->name);
    if (j->value)
      free(j->value);
    free(j);
  }
}


/* release memory allocated for a script */
void free_script(struct script_data *sc)
{
  trig_data *t1, *t2;

  for (t1 = TRIGGERS(sc); t1 ;) {
    t2 = t1;
    t1 = t1->next;
    free_trigger(t2);
  }

  free_varlist(sc->global_vars);

  free(sc);
}

void trig_data_init(trig_data *this)
{
  this->nr = NOTHING;
  this->data_type = 0;
  this->name = NULL;
  this->trigger_type = 0;
  this->cmdlist = NULL;
  this->curr_state = NULL;
  this->narg = 0;
  this->arglist = NULL;
  this->depth = 0;
  this->wait_event = NULL;
  this->purged = FALSE;
  this->running = FALSE;
  this->var_list = NULL;

  this->next = NULL;
}


void trig_data_copy(trig_data *this, const trig_data *trg)
{
  trig_data_init(this);

  this->nr = trg->nr;
  this->attach_type = trg->attach_type;
  this->data_type = trg->data_type;
  this->name = strdup(trg->name);
  this->trigger_type = trg->trigger_type;
  this->cmdlist = trg->cmdlist;
  this->narg = trg->narg;
  if (trg->arglist) this->arglist = strdup(trg->arglist);
}


void free_trigger(trig_data *trig)
{
  free(trig->name);
  trig->name = NULL;

  /* trigger code is reused by multiple objects, so dont free it! */
  trig->cmdlist = NULL;

  if (trig->arglist) {
    free(trig->arglist);
    trig->arglist = NULL;
  }

  free_varlist(trig->var_list);

  if (GET_TRIG_WAIT(trig))
    event_cancel(GET_TRIG_WAIT(trig));

  free(trig);
}

/* for mobs and rooms: */
void dg_read_trigger(FILE *fp, void *proto, int type)
{
  char line[256];
  char junk[8];
  int vnum, rnum, count;
  char_data *mob;
  room_data *room;
  struct trig_proto_list *trg_proto, *new_trg;

  get_line(fp, line);
  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
      if (type == MOB_TRIGGER)
      {
          mob = (char_data *)proto;
        sprintf(line,"SYSERR: Non-existent Trigger (vnum #%d) required for mob %d (%s)!",vnum,GET_MOB_VNUM(mob),GET_NAME(mob));
      }
      if (type == WLD_TRIGGER)
        sprintf(line,"SYSERR: Non-existent Trigger (vnum #%d) required for room %d!", vnum,((room_data *)proto)->vnum);
      log("%s", line);
    return;
  }

  switch(type) {
  case MOB_TRIGGER:
    CREATE(new_trg, struct trig_proto_list, 1);
    new_trg->vnum = vnum;
    new_trg->next = NULL;

    mob = (char_data *)proto;
    trg_proto = mob->proto_script;
    if (!trg_proto) {
      mob->proto_script = trg_proto = new_trg;
    } else {
      while (trg_proto->next) trg_proto = trg_proto->next;
      trg_proto->next = new_trg;
    }
    break;
  case WLD_TRIGGER:
    CREATE(new_trg, struct trig_proto_list, 1);
    new_trg->vnum = vnum;
    new_trg->next = NULL;
    room = (room_data *)proto;
    trg_proto = room->proto_script;
    if (!trg_proto) {
      room->proto_script = trg_proto = new_trg;
    } else {
      while (trg_proto->next) trg_proto = trg_proto->next;
      trg_proto->next = new_trg;
    }

    if (rnum>=0) {
      if (!(room->script))
    CREATE(room->script, struct script_data, 1);
      add_trigger(SCRIPT(room), read_trigger(rnum), -1);
    } else {
      sprintf(line,"SYSERR: non-existent trigger #%d assigned to room #%d",
          vnum, room->vnum);
      log("%s", line);
    }
    break;
  default:
    sprintf(line,"SYSERR: Trigger vnum #%d assigned to non-mob/obj/room",
        vnum);
    log("%s", line);
  }
}

void dg_obj_trigger(char *line, struct obj_data *obj)
{
  char junk[8];
  int vnum, rnum, count;
  struct trig_proto_list *trg_proto, *new_trg;

  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
    sprintf(line,"SYSERR: Non-existent Trigger (vnum #%d) required for obj %d!", vnum,GET_OBJ_VNUM(obj));
    log("%s", line);
    return;
  }

  CREATE(new_trg, struct trig_proto_list, 1);
  new_trg->vnum = vnum;
  new_trg->next = NULL;

  trg_proto = obj->proto_script;
  if (!trg_proto) {
    obj->proto_script = trg_proto = new_trg;
  } else {
    while (trg_proto->next) trg_proto = trg_proto->next;
    trg_proto->next = new_trg;
  }
}

void assign_triggers(void *i, int type)
{
  char_data *mob;
  obj_data *obj;
  struct room_data *room;
  int rnum;
  char buf[256];
  struct trig_proto_list *trg_proto;

  switch (type)
    {
    case MOB_TRIGGER:
      mob = (char_data *)i;
      trg_proto = mob->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existent, for mob #%d",
          trg_proto->vnum, mob_index[GET_MOB_RNUM(mob)].virtual);
          log("%s",buf);
        } else {
          if (!SCRIPT(mob))
            CREATE(SCRIPT(mob), struct script_data, 1);
          add_trigger(SCRIPT(mob), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case OBJ_TRIGGER:
      obj = (obj_data *)i;
      trg_proto = obj->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existent, for obj #%d",
                  trg_proto->vnum, GET_OBJ_RNUM(obj) == NOTHING ? 
                  NOTHING : obj_index[GET_OBJ_RNUM(obj)].virtual);
          log("%s",buf);
        } else {
          if (!SCRIPT(obj))
            CREATE(SCRIPT(obj), struct script_data, 1);
          add_trigger(SCRIPT(obj), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case WLD_TRIGGER:
      room = (struct room_data *)i;
      trg_proto = room->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existent, for room #%d",
          trg_proto->vnum, room->vnum);
          log("%s",buf);
        } else {
          if (!SCRIPT(room))
            CREATE(SCRIPT(room), struct script_data, 1);
          add_trigger(SCRIPT(room), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    default:
      log("SYSERR: unknown type for assign_triggers()");
      break;
    }
}


void free_proto_script(struct trig_proto_list **list)
{
  struct trig_proto_list *proto, *fproto;

  if (!list)
    return;

  proto = *list;

  while (proto) {
    fproto = proto;
    proto = proto->next;
    free(fproto);
  }

  *list = NULL;
}


/***************************************************************************
 * $Log: dg_db_scripts.c,v $
 * Revision 1.22  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.21  2008/08/30 18:20:53  myc
 * Changed GET_OBJ_RNUM call to check for NOTHING first.
 *
 * Revision 1.20  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.19  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.18  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.17  2008/03/17 16:22:42  myc
 * Updating free_proto_script.
 *
 * Revision 1.16  2008/02/16 20:26:04  myc
 * Cleaning up function to free triggers.  Adding function to free
 * prototype scripts at program termination.
 *
 * Revision 1.15  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.14  2008/01/09 02:30:43  jps
 * Use macro to get mob real number.
 *
 * Revision 1.13  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.12  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.11  2001/01/05 01:03:42  mtp
 * more info if trigger not found (although mob info seems limited...shows bad vnum for some reason?)
 *
 * Revision 1.10  2000/11/28 01:20:32  mtp
 * replaced dg_event.c code with events.c code
 *
 * Revision 1.9  2000/11/21 01:28:28  rsd
 * Altered the comment header in an attempt to propery follow
 * the circle license and give proper credit to the origonal
 * authorse whoever they are.  Also added back rlog messages
 * prior to the addition of the $log$ string.
 *
 * Revision 1.8  2000/04/09 22:43:32  mtp
 * trigger code is reused by multiple objects, it was a mistake to free it!
 *
 * Revision 1.7  2000/03/08 22:03:28  mtp
 * remove dangling pointers on trigger creation (hopefully)
 *
 * Revision 1.6  2000/03/07 07:56:08  mtp
 * explicit set of cmdlist to null (belt and braces approach to freeing
 * cmdlist!)
 *
 * Revision 1.5  2000/02/16 08:20:03  mtp
 * but code in to free trigger command list
 *
 * Revision 1.4  2000/02/13 07:34:13  mtp
 * set running flag (new to solve opurge/mpure probs) to flase at start
 *
 * Revision 1.3  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.2  1999/01/31 00:08:35  mud
 * Edited comment header to give credit
 * Indented entire file.
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.22
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.21 2008/08/30 18:20:53 myc Exp $
d17 3
a19 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/08/30 18:20:53 $                                           *
 *  $Revision: 1.21 $                                                       *
d226 1
a226 1
    log(line);
d265 1
a265 1
      log(line);
d271 1
a271 1
    log(line);
d292 1
a292 1
    log(line);
d400 3
@


1.21
log
@Changed GET_OBJ_RNUM call to check for NOTHING first.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.20 2008/08/18 01:35:38 jps Exp myc $
d17 3
a19 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/08/18 01:35:38 $                                           *
 *  $Revision: 1.20 $                                                       *
d328 1
a328 1
          log(buf);
d346 1
a346 1
          log(buf);
d363 1
a363 1
          log(buf);
d400 3
@


1.20
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.19 2008/05/18 05:39:59 jps Exp jps $
d18 2
a19 2
 *  $Date: 2008/05/18 05:39:59 $                                           *
 *  $Revision: 1.19 $                                                       *
d344 2
a345 1
          trg_proto->vnum, obj_index[obj->item_number].virtual);
d400 3
@


1.19
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.18 2008/03/28 17:54:53 myc Exp jps $
d17 3
a19 3
 *  $Author: myc $                                                         *
 *  $Date: 2008/03/28 17:54:53 $                                           *
 *  $Revision: 1.18 $                                                       *
d70 1
a70 1
  trig->cmdlist->cmd = strdup(strtok(s, "\n\r"));
d74 1
a74 1
  while ((s = strtok(NULL, "\n\r"))) {
d399 3
@


1.18
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.17 2008/03/17 16:22:42 myc Exp myc $
d18 2
a19 2
 *  $Date: 2008/03/17 16:22:42 $                                           *
 *  $Revision: 1.17 $                                                       *
d45 1
a45 1
  
d48 1
a48 1
  
d53 1
a53 1
  
d55 1
a55 1
  
d58 1
a58 1
  
d64 1
a64 1
  
d66 1
a66 1
  
d68 1
a68 1
  
d72 2
a73 2
  cle->next = NULL;		/*remove dangling pointers*/
  
d78 1
a78 1
    cle->next = NULL;		/*remove dangling pointers*/
d80 1
a80 1
  
d82 1
a82 1
  
d95 1
a95 1
  
d99 1
a99 1
  
d102 1
a102 1
  
d104 1
a104 1
  
d113 1
a113 1
  
d130 1
a130 1
  
d136 1
a136 1
  
d138 1
a138 1
  
d157 2
a158 2
  
  this->next = NULL;  
d165 1
a165 1
  
d181 1
a181 1
  
d189 1
a189 1
  
d191 1
a191 1
  
d194 1
a194 1
  
d207 1
a207 1
  
d210 1
a210 1
  
d216 1
a216 1
  
d219 7
a225 7
	  if (type == MOB_TRIGGER)
	  {
		  mob = (char_data *)proto;
		sprintf(line,"SYSERR: Non-existent Trigger (vnum #%d) required for mob %d (%s)!",vnum,GET_MOB_VNUM(mob),GET_NAME(mob));
	  }
	  if (type == WLD_TRIGGER)
		sprintf(line,"SYSERR: Non-existent Trigger (vnum #%d) required for room %d!", vnum,((room_data *)proto)->number);
d229 1
a229 1
  
d235 1
a235 1
    
d257 1
a257 1
    
d260 1
a260 1
	CREATE(room->script, struct script_data, 1);
d264 1
a264 1
	      vnum, room->number);
d270 1
a270 1
	    vnum);
d280 1
a280 1
  
d282 1
a282 1
  
d288 1
a288 1
  
d295 1
a295 1
  
d299 1
a299 1
  
d317 1
a317 1
  
d327 1
a327 1
		  trg_proto->vnum, mob_index[GET_MOB_RNUM(mob)].virtual);
d344 1
a344 1
		  trg_proto->vnum, obj_index[obj->item_number].virtual);
d361 1
a361 1
		  trg_proto->vnum, room->number);
d399 4
@


1.17
log
@Updating free_proto_script.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.16 2008/02/16 20:26:04 myc Exp myc $
d18 2
a19 2
 *  $Date: 2008/02/16 20:26:04 $                                           *
 *  $Revision: 1.16 $                                                       *
d70 1
a70 1
  trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
d77 1
a77 1
    cle->cmd = str_dup(s);
d169 1
a169 1
  this->name = str_dup(trg->name);
d173 1
a173 1
  if (trg->arglist) this->arglist = str_dup(trg->arglist);
d399 3
@


1.16
log
@Cleaning up function to free triggers.  Adding function to free
prototype scripts at program termination.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.15 2008/01/29 21:02:31 myc Exp myc $
d18 2
a19 2
 *  $Date: 2008/01/29 21:02:31 $                                           *
 *  $Revision: 1.15 $                                                       *
d378 1
a378 1
void free_proto_script(void *thing, int type)
d380 1
a380 4
  struct trig_proto_list *proto = NULL, *fproto;
  char_data *mob;
  obj_data *obj;
  room_data *room;
d382 2
a383 29
  switch (type) {
    case MOB_TRIGGER:
      mob = (struct char_data *)thing;
      proto = mob->proto_script;
      mob->proto_script = NULL;
      break;
    case OBJ_TRIGGER:
      obj = (struct obj_data *)thing;
      proto = obj->proto_script;
      obj->proto_script = NULL;
      break;
    case WLD_TRIGGER:
      room = (struct room_data *)thing;
      proto = room->proto_script;
      room->proto_script = NULL;
      break;
  }

#if 0 /* debugging */
  {
    struct char_data *i = character_list;
    struct obj_data *j = object_list;
    int k;
    if (proto) {
      for ( ; i ; i = i->next)
        assert(proto != i->proto_script);

      for ( ; j ; j = j->next)
        assert(proto != j->proto_script);
d385 1
a385 5
      for (k = 0; k < top_of_world; k++)
        assert(proto != world[k].proto_script);
    }
  }
#endif
d392 2
d399 4
@


1.15
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.14 2008/01/09 02:30:43 jps Exp myc $
d17 3
a19 3
 *  $Author: jps $                                                         *
 *  $Date: 2008/01/09 02:30:43 $                                           *
 *  $Revision: 1.14 $                                                       *
a33 1
void trig_data_free(trig_data *this);
d134 1
a134 1
    trig_data_free(t2);
d177 1
a177 1
void trig_data_free(trig_data *this)
d179 2
a180 1
  /*struct cmdlist_element *i, *j;*/
d182 7
a188 15
  free(this->name);
  
/*
** trigger code is reused by multiple objects, so dont free it!
   for (i = this->cmdlist; i;) {
   j = i;
   i = i->next;
   free(j->cmd);
   free(j);
   }
*/
  
  /* just to avoid ANY confusion */
  this->cmdlist=NULL;
  free(this->arglist);
d190 1
a190 1
  free_varlist(this->var_list);
d192 2
a193 2
  if (this->wait_event)
    event_cancel(this->wait_event);
d195 1
a195 1
  free(this);
d377 52
d431 4
@


1.14
log
@Use macro to get mob real number.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.13 2007/07/24 23:02:52 jps Exp jps $
d18 2
a19 2
 *  $Date: 2007/07/24 23:02:52 $                                           *
 *  $Revision: 1.13 $                                                       *
a35 6
extern struct index_data **trig_index;
extern int top_of_trigt;

extern struct index_data *mob_index;
extern struct index_data *obj_index;

d387 3
@


1.13
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.12 2002/09/13 02:32:10 jjl Exp jps $
d17 3
a19 3
 *  $Author: jjl $                                                         *
 *  $Date: 2002/09/13 02:32:10 $                                           *
 *  $Revision: 1.12 $                                                       *
d341 1
a341 1
		  trg_proto->vnum, mob_index[mob->nr].virtual);
d393 3
@


1.12
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_db_scripts.c,v 1.11 2001/01/05 01:03:42 mtp Exp $
d17 3
a19 3
 *  $Author: mtp $                                                         *
 *  $Date: 2001/01/05 01:03:42 $                                           *
 *  $Revision: 1.11 $                                                       *
d236 1
a236 1
		sprintf(line,"SYSERR: Non-existant Trigger (vnum #%d) required for mob %d (%s)!",vnum,GET_MOB_VNUM(mob),GET_NAME(mob));
d239 1
a239 1
		sprintf(line,"SYSERR: Non-existant Trigger (vnum #%d) required for room %d!", vnum,((room_data *)proto)->number);
d277 1
a277 1
      sprintf(line,"SYSERR: non-existant trigger #%d assigned to room #%d",
d305 1
a305 1
    sprintf(line,"SYSERR: Non-existant Trigger (vnum #%d) required for obj %d!", vnum,GET_OBJ_VNUM(obj));
d340 1
a340 1
          sprintf(buf,"SYSERR: trigger #%d non-existant, for mob #%d",
d357 1
a357 1
          sprintf(buf,"SYSERR: trigger #%d non-existant, for obj #%d",
d374 1
a374 1
          sprintf(buf,"SYSERR: trigger #%d non-existant, for room #%d",
d393 3
@


1.11
log
@more info if trigger not found (although mob info seems limited...shows bad vnum for some reason?)
@
text
@d1 3
a3 1
// $Id: dg_db_scripts.c,v 1.10 2000/11/28 01:20:32 mtp Exp $
d18 2
a19 2
 *  $Date: 2000/11/28 01:20:32 $                                           *
 *  $Revision: 1.10 $                                                       *
d391 41
a431 36
// $Log: dg_db_scripts.c,v $
// Revision 1.10  2000/11/28 01:20:32  mtp
// replaced dg_event.c code with events.c code
//
// Revision 1.9  2000/11/21 01:28:28  rsd
// Altered the comment header in an attempt to propery follow
// the circle license and give proper credit to the origonal
// authorse whoever they are.  Also added back rlog messages
// prior to the addition of the $log$ string.
//
// Revision 1.8  2000/04/09 22:43:32  mtp
// trigger code is reused by multiple objects, it was a mistake to free it!
//
// Revision 1.7  2000/03/08 22:03:28  mtp
// remove dangling pointers on trigger creation (hopefully)
//
// Revision 1.6  2000/03/07 07:56:08  mtp
// explicit set of cmdlist to null (belt and braces approach to freeing
// cmdlist!)
//
// Revision 1.5  2000/02/16 08:20:03  mtp
// but code in to free trigger command list
//
// Revision 1.4  2000/02/13 07:34:13  mtp
// set running flag (new to solve opurge/mpure probs) to flase at start
//
// Revision 1.3  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.2  1999/01/31 00:08:35  mud
// Edited comment header to give credit
// Indented entire file.
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.10
log
@replaced dg_event.c code with events.c code
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.9 2000/11/21 01:28:28 rsd Exp $
d15 3
a17 3
 *  $Author: rsd $                                                         *
 *  $Date: 2000/11/21 01:28:28 $                                           *
 *  $Revision: 1.9 $                                                       *
d231 7
a237 1
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
d303 1
a303 1
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
d390 3
@


1.9
log
@Altered the comment header in an attempt to propery follow
the circle license and give proper credit to the origonal
authorse whoever they are.  Also added back rlog messages
prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.8 2000/04/09 22:43:32 mtp Exp $
d15 3
a17 3
 *  $Author: mtp $                                                         *
 *  $Date: 2000/04/09 22:43:32 $                                           *
 *  $Revision: 1.8 $                                                       *
d28 1
a28 1
#include "dg_event.h"
d205 1
a205 1
    remove_event(this->wait_event);
d384 6
@


1.8
log
@trigger code is reused by multiple objects, it was a mistake to free it!
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.7 2000/03/08 22:03:28 mtp Exp mtp $
d3 1
a3 2
 *                       Adapted from db.script.c Part of Death's Gate MUD *
 *  File: dg_db_scripts.c                                                  *
d8 4
d16 2
a17 2
 *  $Date: 2000/03/08 22:03:28 $                                           *
 *  $Revision: 1.7 $                                                       *
d382 1
d384 3
d402 7
@


1.7
log
@remove dangling pointers on trigger creation (hopefully)
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.6 2000/03/07 07:56:08 mtp Exp mtp $
d13 2
a14 2
 *  $Date: 2000/03/07 07:56:08 $                                           *
 *  $Revision: 1.6 $                                                       *
d181 1
a181 1
  struct cmdlist_element *i, *j;
d185 2
d193 1
d380 3
@


1.6
log
@explicit set of cmdlist to null (belt and braces approach to freeing
cmdlist!)
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.5 2000/02/16 08:20:03 mtp Exp mtp $
d13 2
a14 2
 *  $Date: 2000/02/16 08:20:03 $                                           *
 *  $Revision: 1.5 $                                                       *
d74 1
d80 1
d377 4
@


1.5
log
@but code in to free trigger command list
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.4 2000/02/13 07:34:13 mtp Exp mtp $
d13 2
a14 2
 *  $Date: 2000/02/13 07:34:13 $                                           *
 *  $Revision: 1.4 $                                                       *
d190 2
d375 3
@


1.4
log
@set running flag (new to solve opurge/mpure probs) to flase at start
@
text
@d1 1
a1 1
// $Id: dg_db_scripts.c,v 1.3 1999/09/05 07:00:39 jimmy Exp mtp $
d12 3
a14 3
 *  $Author: jimmy $                                                         *
 *  $Date: 1999/09/05 07:00:39 $                                           *
 *  $Revision: 1.3 $                                                       *
d179 1
a179 1
  /*    struct cmdlist_element *i, *j;*/
d183 1
a183 5
  /*
   * The command list is a memory leak right now!
   *
   if (cmdlist != trigg->cmdlist || this->proto)
   for (i = cmdlist; i;) {
a188 1
  */
d373 3
@


1.3
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d12 3
a14 3
 *  $Author: mud $                                                         *
 *  $Date: 1999/01/31 00:08:35 $                                           *
 *  $Revision: 1.2 $                                                       *
d155 1
d377 4
a380 1
// $Log$
@


1.2
log
@Eddited comment header to give credit
Indernted entire file/.
@
text
@d1 1
d13 2
a14 2
 *  $Date: 1999/01/29 01:23:30 $                                           *
 *  $Revision: 1.1 $                                                       *
d376 1
@


1.1
log
@Initial revision
@
text
@d1 14
a14 14
/* ************************************************************************
*  File: db.script.c                             Part of Death's Gate MUD *
*                                                                         *
*  Usage: Contains routines to handle db functions for scripts and trigs  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/30 21:27:54 $
*  $Revision: 3.7 $
************************************************************************ */
d41 42
a82 42
    int t[2], k, attach_type;
    char line[256], *cmds, *s, flags[256];
    struct cmdlist_element *cle;
    index_data *index;
    trig_data *trig;

    CREATE(trig, trig_data, 1);
    CREATE(index, index_data, 1);

    index->virtual = nr;
    index->number = 0;
    index->func = NULL;
    index->proto = trig;

    sprintf(buf2, "trig vnum %d", nr);

    trig->nr = top_of_trigt;
    trig->name = fread_string(trig_f, buf2);

    get_line(trig_f, line);
    k = sscanf(line, "%d %s %d", &attach_type, flags, t);
    trig->attach_type = (byte)attach_type;
    trig->trigger_type = asciiflag_conv(flags);
    trig->narg = (k == 3) ? t[0] : 0;

    trig->arglist = fread_string(trig_f, buf2);
  
    cmds = s = fread_string(trig_f, buf2);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cle = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
	CREATE(cle->next, struct cmdlist_element, 1);
	cle = cle->next;
	cle->cmd = str_dup(s);
    }

    free(cmds);

    trig_index[top_of_trigt++] = index;
d92 13
a104 13
    index_data *index;
    trig_data *trig;

    if (nr >= top_of_trigt) return NULL;
    if ((index = trig_index[nr]) == NULL)
	return NULL;

    CREATE(trig, trig_data, 1);
    trig_data_copy(trig, index->proto);

    index->number++;

    return trig;
d111 11
a121 11
    struct trig_var_data *i, *j;

    for (i = vd; i;) {
	j = i;
	i = i->next;
	if (j->name)
	    free(j->name);
	if (j->value)
	    free(j->value);
	free(j);
    }
d128 11
a138 11
    trig_data *t1, *t2;

    for (t1 = TRIGGERS(sc); t1 ;) {
	t2 = t1;
	t1 = t1->next;
	trig_data_free(t2);
    }

    free_varlist(sc->global_vars);

    free(sc);
d143 14
a156 14
    this->nr = NOTHING;
    this->data_type = 0;
    this->name = NULL;
    this->trigger_type = 0;
    this->cmdlist = NULL;
    this->curr_state = NULL;
    this->narg = 0;
    this->arglist = NULL;
    this->depth = 0;
    this->wait_event = NULL;
    this->purged = FALSE;
    this->var_list = NULL;

    this->next = NULL;  
d162 10
a171 10
    trig_data_init(this);

    this->nr = trg->nr;
    this->attach_type = trg->attach_type;
    this->data_type = trg->data_type;
    this->name = str_dup(trg->name);
    this->trigger_type = trg->trigger_type;
    this->cmdlist = trg->cmdlist;
    this->narg = trg->narg;
    if (trg->arglist) this->arglist = str_dup(trg->arglist);
d177 22
a198 17
/*    struct cmdlist_element *i, *j;*/

    free(this->name);

    /*
     * The command list is a memory leak right now!
     *
    if (cmdlist != trigg->cmdlist || this->proto)
	for (i = cmdlist; i;) {
	    j = i;
	    i = i->next;
	    free(j->cmd);
	    free(j);
	}
	*/

    free(this->arglist);
d200 1
a200 6
    free_varlist(this->var_list);

    if (this->wait_event)
	remove_event(this->wait_event);

    free(this);
d212 1
a212 1

d215 1
a215 1

d221 1
a221 1

d228 1
a228 1

d230 34
a263 40
    case MOB_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;

      mob = (char_data *)proto;
      trg_proto = mob->proto_script;
      if (!trg_proto) {
        mob->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }
      break;
    case WLD_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;
      room = (room_data *)proto;
      trg_proto = room->proto_script;
      if (!trg_proto) {
        room->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }

      if (rnum>=0) {
        if (!(room->script))
          CREATE(room->script, struct script_data, 1);
        add_trigger(SCRIPT(room), read_trigger(rnum), -1);
      } else {
        sprintf(line,"SYSERR: non-existant trigger #%d assigned to room #%d",
          vnum, room->number);
        log(line);
      }
      break;
    default:
      sprintf(line,"SYSERR: Trigger vnum #%d assigned to non-mob/obj/room",
              vnum);
d265 6
d279 1
a279 1

d281 1
a281 1

d287 1
a287 1

d294 1
a294 1

d298 1
a298 1

d316 1
a316 1

d318 1
a318 1
  {
d326 1
a326 1
            trg_proto->vnum, mob_index[mob->nr].virtual);
d343 1
a343 1
            trg_proto->vnum, obj_index[obj->item_number].virtual);
d360 1
a360 1
            trg_proto->vnum, room->number);
d373 1
a373 1
  }
@
