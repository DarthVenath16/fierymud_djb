head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2009.03.20.20.19.51;	author myc;	state Exp;
branches;
next	;


desc
@Temporary infodump implementation for old board data.  Not
placing in active code, since boards.c is now defunct.
@


1.1
log
@Initial revision
@
text
@/***************************************************************************
 * $Id: infodump.board.c,v $
 ***************************************************************************/
/***************************************************************************
 *   File: infodump.board.c                               Part of FieryMUD *
 *  Usage: Dump old-school board files to new format                       *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "boards.h"


/* From act.wizinfo.c */
extern bool get_infodump_filename(const char *name, char *filename);


static const char *board_months[12] = {
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};
static const char *board_weekdays[7] = {
  "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
};

/* WKD MON dd */
static time_t convert_time_a(char *str) {
  char weekday[4], month[4];
  int day, mth, yr, wkd;
  time_t rawtime;
  struct tm *timeinfo;

  sscanf(str, "%s %s %d", weekday, month, &day);

  for (mth = 0; mth < 12; ++mth)
    if (!str_cmp(board_months[mth], month))
      break;

  for (wkd = 0; wkd < 7; ++wkd)
    if (!str_cmp(board_weekdays[wkd], weekday))
      break;

  /* get current timeinfo and modify it to user's choice */
  time(&rawtime);
  timeinfo = localtime(&rawtime);
  timeinfo->tm_mon = mth;
  timeinfo->tm_mday = day;

  timeinfo->tm_sec = 0;
  timeinfo->tm_min = 0;
  timeinfo->tm_hour = 12;

  for (yr = 2007 - 1900; yr > 2003 - 1900; --yr) {
    timeinfo->tm_year = yr;
    mktime(timeinfo);
    if (timeinfo->tm_wday == wkd)
      break;
  }

  return mktime(timeinfo);
}

/* MON dd YYYY */
static time_t convert_time_b(char *str) {
  char month[4];
  int day, mth, year;
  time_t rawtime;
  struct tm *timeinfo;

  sscanf(str, "%s %d %d", month, &day, &year);

  for (mth = 0; mth < 12; ++mth)
    if (!str_cmp(board_months[mth], month))
      break;

  /* get current timeinfo and modify it to user's choice */
  time(&rawtime);
  timeinfo = localtime(&rawtime);
  timeinfo->tm_year = year - 1900;
  timeinfo->tm_mon = mth;
  timeinfo->tm_mday = day;

  timeinfo->tm_sec = 0;
  timeinfo->tm_min = 0;
  timeinfo->tm_hour = 12;

  return mktime(timeinfo);
}


void infodump_board(struct char_data *ch, char *argument)
{
  char boardname[MAX_INPUT_LENGTH];
  char fname[MAX_INPUT_LENGTH];
  char poster[MAX_INPUT_LENGTH];
  char *subject;
  FILE *fl;
  int board, rnum, i, j;
  time_t posttime;

  extern struct board_info_type board_info[NUM_OF_BOARDS];
  extern int num_of_msgs[NUM_OF_BOARDS];
  extern struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];
  extern char *msg_storage[INDEX_SIZE];

  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Which board do you want to dump?\r\n", ch); 
    return;
  }

  if (!is_number(argument) || (rnum = real_object(atoi(argument))) == -1) {
    cprintf(ch, "'%s' is not a valid board vnum.\r\n", argument);
    return;
  }

  for (board = 0; board < NUM_OF_BOARDS; ++board)
    if (BOARD_RNUM(board) == rnum)
      break;

  if (board >= NUM_OF_BOARDS) {
    cprintf(ch, "No board with vnum %s.\r\n", argument);
    return;
  }

  sprintf(boardname, "board.%d", BOARD_VNUM(board));

  if (!get_infodump_filename(boardname, fname)) {
    send_to_char("ERROR: Could not get the output filename.\r\n", ch);
    return;
  }

  if (!(fl = fopen(fname, "w"))) {
    cprintf(ch, "ERROR: Could not write file %s.\r\n", fname);
    return;
  }

  for (i = 0; i < num_of_msgs[board]; ++i) {
    if (MSG_HEADING(board, i)) {

      strncpy(buf, MSG_HEADING(board, i), 12);
      buf[11] = '\0';
      if (buf[10] == ' ') {
        posttime = convert_time_a(buf); /* old school time, like Sat Feb 25 */
        strncpy(poster, 12 + MSG_HEADING(board, i), 13);
        poster[12] = '\0';
        subject = MSG_HEADING(board, i) + 27;
      }
      else {
        posttime = convert_time_b(buf); /* new school time, like Jan 11 2007 */
        strncpy(poster, 13 + MSG_HEADING(board, i), 13);
        poster[12] = '\0';
        subject = MSG_HEADING(board, i) + 28;
      }

      for (j = 0; poster[j]; ++j)
        if (poster[j] == ')') {
          poster[j] = '\0';
          break;
        }

      fprintf(fl, "level: %d\n"
                  "poster: %s\n"
                  "time: %ld\n"
                  "subject: %s\n"
                  "message:\n%s~\n~~\n",
                  MSG_LEVEL(board, i), poster, posttime, subject,
                  msg_storage[MSG_SLOTNUM(board, i)]);
    }
  }

  fclose(fl);
  cprintf(ch, "Dumped board %d to %s.\r\n", BOARD_VNUM(board), fname);
}


/***************************************************************************
 * $Log: infodump.board.c,v $
 ***************************************************************************/
@
