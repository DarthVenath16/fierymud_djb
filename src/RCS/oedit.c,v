head	1.58;
access;
symbols;
locks; strict;
comment	@ * @;


1.58
date	2009.03.20.20.19.51;	author myc;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.29.03.24.44;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.22.02.09.17;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.03.17.34.08;	author myc;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.03.07.14.34;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.29.05.34.24;	author myc;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.29.05.26.06;	author myc;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.29.05.14.02;	author myc;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.26.03.58.13;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.22.07.25.26;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.18.16.36.22;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.14.15.50.51;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.19.19.12.54;	author myc;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.19.19.08.17;	author myc;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.19.18.53.12;	author myc;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.11.23.05.02;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.20.17.48.26;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.23.00.25.41;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.21.15.01.17;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.18.23.01.52;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.18.22.28.47;	author jps;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.18.01.21.34;	author jps;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.15.21.16.12;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.14.03.41.18;	author rls;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.08.16.01.22;	author mtp;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.26.00.46.22;	author mtp;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.24.05.12.01;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.24.19.24.58;	author rsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.14.11.12.40;	author mtp;	state Exp;
branches;
next	1.4;

1.4
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.07.22.17.43.59;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.22.05.32;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - oedit.c 		                                          *
*    				                                          *
*  Copyright 1996 Harvey Gilpin.                                          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*. Original author: Levork .*/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "spells.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "shop.h"
#include "olc.h"
#include "dg_olc.h"

/*------------------------------------------------------------------------*/
/* external variables */
int *tmp_ptr;
extern struct obj_data *obj_proto;
extern struct index_data *obj_index;
extern struct obj_data *object_list;
extern int top_of_objt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern struct shop_data *shop_index;
extern int top_shop;
extern struct attack_hit_type attack_hit_text[];
extern char *item_types[];
extern char *wear_bits[];
extern char *extra_bits[];
extern char *drinks[];
extern char *apply_types[];
extern char *container_bits[];
extern char *spells[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern struct board_info_type board_info[];
extern struct descriptor_data *descriptor_list;
extern int *obj_limit;

/*------------------------------------------------------------------------*/
/*. Macros .*/

#define S_PRODUCT(s, i) ((s)->producing[(i)])

/*------------------------------------------------------------------------*/

void oedit_disp_container_flags_menu(struct descriptor_data *d);
void oedit_disp_extradesc_menu(struct descriptor_data *d);
void oedit_disp_weapon_menu(struct descriptor_data *d);
void oedit_disp_val1_menu(struct descriptor_data *d);
void oedit_disp_val2_menu(struct descriptor_data *d);
void oedit_disp_val3_menu(struct descriptor_data *d);
void oedit_disp_val4_menu(struct descriptor_data *d);
void oedit_disp_type_menu(struct descriptor_data *d);
void oedit_disp_extra_menu(struct descriptor_data *d);
void oedit_disp_wear_menu(struct descriptor_data *d);
void oedit_disp_menu(struct descriptor_data *d);

void oedit_parse(struct descriptor_data *d, char *arg);
void oedit_disp_spells_menu(struct descriptor_data *d);
void oedit_liquid_type(struct descriptor_data *d);
void oedit_setup_new(struct descriptor_data *d);
void oedit_setup_existing(struct descriptor_data *d, int real_num);
void oedit_save_to_disk(int zone);
void oedit_save_internally(struct descriptor_data *d);

/*------------------------------------------------------------------------*\
  Utility and exported functions
\*------------------------------------------------------------------------*/

void oedit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_OBJ(d), struct obj_data, 1);
  clear_object(OLC_OBJ(d));
  OLC_OBJ(d)->name = str_dup("unfinished object");
  OLC_OBJ(d)->description = str_dup("An unfinished object is lying here.");
  OLC_OBJ(d)->short_description = str_dup("an unfinished object");
  GET_OBJ_WEAR(OLC_OBJ(d)) = ITEM_WEAR_TAKE;
  OLC_VAL(d) = 0;
  oedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void oedit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct extra_descr_data *this, *temp, *temp2;
  struct obj_data *obj;

  /*
   * Allocate object in memory.
   */
  CREATE(obj, struct obj_data, 1);

  clear_object(obj);
  *obj = obj_proto[real_num];


  /*
   * Copy all strings over.
   */
  obj->name = str_dup(obj_proto[real_num].name ? obj_proto[real_num].name : "undefined");
  obj->short_description = str_dup(obj_proto[real_num].short_description ?
		obj_proto[real_num].short_description : "undefined");
  obj->description = str_dup(obj_proto[real_num].description ?
		obj_proto[real_num].description : "undefined");
  obj->action_description = (obj_proto[real_num].action_description ?
		str_dup(obj_proto[real_num].action_description) : NULL);

  /*
   * Extra descriptions if necessary.
   */
  if (obj_proto[real_num].ex_description) {
    CREATE(temp, struct extra_descr_data, 1);

    obj->ex_description = temp;
     for (this = obj_proto[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword && *this->keyword) ? str_dup(this->keyword) : NULL;
      temp->description = (this->description && *this->description) ?
		str_dup(this->description) : NULL;
      if (this->next) {
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
      } else
	temp->next = NULL;
    }
  }


  if (SCRIPT(obj))
    script_copy(obj, &obj_proto[real_num], OBJ_TRIGGER);

  /*. Attatch new obj to players descriptor .*/
  OLC_OBJ(d) = obj;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  dg_olc_script_copy(d);
  oedit_disp_menu(d);
}
/*------------------------------------------------------------------------*/

#define ZCMD zone_table[zone].cmd[cmd_no]

void oedit_save_internally(struct descriptor_data *d)
{
  int i, shop, robj_num, found = FALSE, zone, cmd_no;
  struct extra_descr_data *this, *next_one;
  struct obj_data *obj, *swap, *new_obj_proto;
  struct index_data *new_obj_index;
  struct descriptor_data *dsc;

  /*
   * Write object to internal tables.
   */
  if ((robj_num = real_object(OLC_NUM(d))) > 0) {
    /*
     * We need to run through each and every object currently in the
     * game to see which ones are pointing to this prototype.
     * if object is pointing to this prototype, then we need to replace it
     * with the new one.
     */
    CREATE(swap, struct obj_data, 1);
    for (obj = object_list; obj; obj = obj->next) {
      if (obj->item_number == robj_num) {
    *swap = *obj;
	*obj = *OLC_OBJ(d);
	/*
	 * Copy game-time dependent variables over.
	 */
	obj->in_room = swap->in_room;
	obj->item_number = robj_num;
	obj->carried_by = swap->carried_by;
	obj->worn_by = swap->worn_by;
	obj->worn_on = swap->worn_on;
	obj->in_obj = swap->in_obj;
	obj->contains = swap->contains;
	obj->next_content = swap->next_content;
	obj->next = swap->next;
      }
    }
    free_obj(swap);
    /* now safe to free old proto and write over */
    if (obj_proto[robj_num].name)
    free(obj_proto[robj_num].name);
    if (obj_proto[robj_num].description)
      free(obj_proto[robj_num].description);
    if (obj_proto[robj_num].short_description)
      free(obj_proto[robj_num].short_description);
    if (obj_proto[robj_num].action_description)
      free(obj_proto[robj_num].action_description);
    if (obj_proto[robj_num].ex_description)
     for (this = obj_proto[robj_num].ex_description; this; this = next_one) {
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
      }
    obj_proto[robj_num] = *OLC_OBJ(d);
    obj_proto[robj_num].item_number = robj_num;
	obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
  } else {
    /*. It's a new object, we must build new tables to contain it .*/

    CREATE(new_obj_index, struct index_data, top_of_objt + 2);
    CREATE(new_obj_proto, struct obj_data, top_of_objt + 2);
    /* start counting through both tables */
    for (i = 0; i <= top_of_objt; i++) {
      /* if we haven't found it */
      if (!found) {
    /*
	 * Check if current virtual is bigger than our virtual number.
	 */
	if (obj_index[i].virtual > OLC_NUM(d)) {
	  found = TRUE;
	  robj_num = i;
	  OLC_OBJ(d)->item_number = robj_num;
	  new_obj_index[robj_num].virtual = OLC_NUM(d);
	  new_obj_index[robj_num].number = 0;
	  new_obj_index[robj_num].object_limit = 0;
	  new_obj_index[robj_num].func = NULL;
	  new_obj_proto[robj_num] = *(OLC_OBJ(d));
	  new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
	  new_obj_proto[robj_num].in_room = NOWHERE;
          /*. Copy over the mob that should be here .*/
          new_obj_index[robj_num + 1] = obj_index[robj_num];
	  new_obj_proto[robj_num + 1] = obj_proto[robj_num];
	  new_obj_proto[robj_num + 1].item_number = robj_num + 1;
        } else {
	  /* just copy from old to new, no num change */
	  new_obj_proto[i] = obj_proto[i];
  	  new_obj_index[i] = obj_index[i];
    }
      } else {
        /* we HAVE already found it.. therefore copy to object + 1 */
        new_obj_index[i + 1] = obj_index[i];
        new_obj_proto[i + 1] = obj_proto[i];
        new_obj_proto[i + 1].item_number = i + 1;
      }
    }
    if (!found) {
      robj_num = i;
      OLC_OBJ(d)->item_number = robj_num;
      new_obj_index[robj_num].virtual = OLC_NUM(d);
      new_obj_index[robj_num].number = 0;
      new_obj_index[robj_num].func = NULL;
      new_obj_proto[robj_num] = *(OLC_OBJ(d));
	  new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
      new_obj_proto[robj_num].in_room = NOWHERE;
    }

    /* free and replace old tables */
    free (obj_proto);
    free (obj_index);
    obj_proto = new_obj_proto;
    obj_index = new_obj_index;
    top_of_objt++;

    /*. Renumber live objects .*/
    for (obj = object_list; obj; obj = obj->next)
      if (GET_OBJ_RNUM (obj) >= robj_num)
        GET_OBJ_RNUM (obj)++;



    /*. Renumber zone table .*/
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
  	switch (ZCMD.command) {
	case 'P':
	  if (ZCMD.arg3 >= robj_num)
	    ZCMD.arg3++;
	  /*
	   * No break here - drop into next case.
	   */
	case 'O':
	case 'G':
	case 'E':
	  if (ZCMD.arg1 >= robj_num)
	    ZCMD.arg1++;
	  break;
	case 'R':
	  if (ZCMD.arg2 >= robj_num)
	    ZCMD.arg2++;
	  break;
	}

    /*. Renumber notice boards */
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) >= robj_num)
	BOARD_RNUM(i) = BOARD_RNUM(i) + 1;

    /*. Renumber shop produce .*/
    for(shop = 0; shop < top_shop; shop++)
      for(i = 0; SHOP_PRODUCT(shop, i) != -1; i++)
        if (SHOP_PRODUCT(shop, i) >= robj_num)
          SHOP_PRODUCT(shop, i)++;




/*and those being edited     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT)
	for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
	  if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
	    S_PRODUCT(OLC_SHOP(dsc), i)++;

  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_OBJ);
}

/*------------------------------------------------------------------------*/


void oedit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct obj_data *obj;
  struct extra_descr_data *ex_desc;

  sprintf(buf, "%s/%d.new", OBJ_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_BUILDER,
TRUE);
    return;
  }
  /*
   * Start running through all objects in this zone.
   */
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_object(counter)) >= 0) {
      if ((obj = (obj_proto + realcounter))->action_description) {
	strcpy(buf1, obj->action_description);
	strip_string(buf1);
      } else
	*buf1 = '\0';

	  if (GET_OBJ_TYPE(obj) == 24){
          fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d\n"
	      "%d %d %d %d %d %ld %d\n"
	      "%d %d %d %d %d %d %d %d\n",

	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ?
			obj->short_description : "undefined",
	      (obj->description && *obj->description) ?
			obj->description : "undefined",
	      buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
GET_OBJ_WEAR(obj),
	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
2),
	      GET_OBJ_VAL(obj, 3),  obj->spare1, obj->spare2, obj->spare3,
		  GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
	      GET_OBJ_TIMER(obj), GET_OBJ_SPELL(obj),
		  GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
          obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
		  );}
	  else {
          fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d\n"
	      "%d %d %d %d %d %ld %d\n"
	      "%d %d %d %d %d %d %d %d\n",

	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ?
			obj->short_description : "undefined",
	      (obj->description && *obj->description) ?
			obj->description : "undefined",
	      buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
GET_OBJ_WEAR(obj),
	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
2),
	      GET_OBJ_VAL(obj, 3), obj->spare1, obj->spare2, obj->spare3,
		  GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
	      GET_OBJ_RENT(obj), GET_OBJ_SPELL(obj),
		  GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
          obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
		  );}

	  script_save_to_disk(fp, obj, OBJ_TRIGGER);

	  /*
       * Do we have extra descriptions?
       */
      if (obj->ex_description) {	/* Yes, save them too. */
	for (ex_desc = obj->ex_description; ex_desc; ex_desc =
ex_desc->next) {
	  /*
	   * Sanity check to prevent nasty protection faults.
	   */
	  if (!*ex_desc->keyword || !*ex_desc->description) {
	    mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!",
BRF, LVL_BUILDER, TRUE);
	    continue;
	  }
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n"
		  "%s~\n"
		  "%s~\n", ex_desc->keyword, buf1);
	}
      }

      /* Do we have affects? */
      for (counter2 = 0; counter2 < MAX_OBJ_AFFECT; counter2++)
      	if (obj->affected[counter2].modifier)
	  fprintf(fp, "A\n"
		  "%d %d\n", obj->affected[counter2].location,
		  obj->affected[counter2].modifier);
    }
  }

  /* write final line, close */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.obj", OBJ_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_OBJ);
}



/**************************************************************************
 Menu functions
 **************************************************************************/

/*
 *  For wall flags.
 */
void oedit_disp_wall_block_dirs(struct descriptor_data *d)
{
  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
  #endif
  sprintf(buf,
	  "%s0%s) NORTH\r\n"
	  "%s1%s) EAST\r\n"
	  "%s2%s) SOUTH\r\n"
	  "%s3%s) WEST\r\n"
	  "%s4%s) UP\r\n"
	  "%s5%s) DOWN\r\n"
	  "Enter flag : ",
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
}

/*
 * For container flags.
 */
void oedit_disp_container_flags_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintbit(GET_OBJ_VAL(OLC_OBJ(d), 1), container_bits, buf1);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  sprintf(buf,
	  "%s1%s) CLOSEABLE\r\n"
	  "%s2%s) PICKPROOF\r\n"
	  "%s3%s) CLOSED\r\n"
	  "%s4%s) LOCKED\r\n"
	  "Container flags: %s%s%s\r\n"
	  "Enter flag, 0 to quit : ",
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * For extra descriptions.
 */
void oedit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  strcpy(buf1, !extra_desc->next ? "<Not set>\r\n" : "Set.");

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  sprintf(buf,
	  "Extra desc menu\r\n"
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: %s\r\n"
	  "%s0%s) Quit\r\n"
	  "Enter choice : ",

     	  grn, nrm, yel, (extra_desc->keyword && *extra_desc->keyword) ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, (extra_desc->description && *extra_desc->description) ? extra_desc->description : "<NONE>",
	  grn, nrm, buf1, grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_EXTRADESC_MENU;
}

/*
 * Ask for *which* apply to edit.
 */
void oedit_disp_prompt_apply_menu(struct descriptor_data *d)
{
  int counter;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < MAX_OBJ_AFFECT; counter++) {
    if (OLC_OBJ(d)->affected[counter].modifier) {
      sprinttype(OLC_OBJ(d)->affected[counter].location, apply_types, buf2);
      sprintf(buf, " %s%d%s) %+d to %s\r\n", grn, counter + 1, nrm,
	      OLC_OBJ(d)->affected[counter].modifier, buf2);
      send_to_char(buf, d->character);
    } else {
      sprintf(buf, " %s%d%s) None.\r\n", grn, counter + 1, nrm);
      send_to_char(buf, d->character);
    }
  }
  send_to_char("\r\nEnter affection to modify (0 to quit) : ", d->character);
  OLC_MODE(d) = OEDIT_PROMPT_APPLY;
}

void oedit_disp_prompt_spell_apply_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char(".[H.[J", d->character);
  #endif
  for (counter = 0; counter < NUM_SPELL_APPLIES; counter++) {
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		affected_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_SPELL(OLC_OBJ(d)), affected_bits, buf1);
    sprintf(buf, "\r\nSpell flags: %s%s%s\r\n"
	  "Enter spell flag, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

void oedit_disp_component(struct descriptor_data *d)
{
 // int counter;

  get_char_cols(d->character);
  send_to_char("this is not a functional system yet sorry", d->character);

}

/*
 * Ask for liquid type.
 */
void oedit_liquid_type(struct descriptor_data *d)
{
 int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_LIQ_TYPES; counter++) {
    sprintf(buf, " %s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
	    drinks[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n%sEnter drink type : ", nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_VALUE_3;
}

/*
 * The actual apply to set.
 */
void oedit_disp_apply_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_APPLIES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		apply_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter apply type (0 is no apply) : ", d->character);
  OLC_MODE(d) = OEDIT_APPLY;
}


/*
 * Weapon type.
 */
void oedit_disp_weapon_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ATTACK_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		attack_hit_text[counter].singular,
		!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter weapon type : ", d->character);
}

/*
 * Spell type.
 */
void oedit_disp_spells_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_SPELLS; counter++) {
    sprintf(buf, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
	spells[counter], !(++columns % 3) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n%sEnter spell choice (0 for none) : ", nrm);
  send_to_char(buf, d->character);
}

/*
 * Object value #1
 */
void oedit_disp_val1_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_1;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    /* values 0 and 1 are unused.. jump to 2 */
    oedit_disp_val3_menu(d);
    break;
  case ITEM_SCROLL:
  case ITEM_WAND:
  case ITEM_STAFF:
  case ITEM_POTION:
    send_to_char("Spell level : ", d->character);
    break;
  case ITEM_WEAPON:
    /* this seems to be a circleism.. not part of normal diku? */
    send_to_char("Modifier to Hitroll : ", d->character);
    break;
  case ITEM_ARMOR:
    send_to_char("Apply to AC : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Max weight to contain : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Max drink units : ", d->character);
    break;
  case ITEM_FOOD:
    send_to_char("Hours to fill stomach : ", d->character);
    break;


  case ITEM_MONEY:
    send_to_char("Number of platinum coins : ", d->character);
    break;
  case ITEM_NOTE:
    /* this is supposed to be language, but it's unused */

	  break;
  case ITEM_PORTAL:
	  send_to_char("Room to go to : ", d->character);
	  break;
  case ITEM_WALL:
	oedit_disp_wall_block_dirs(d);
        break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #2
 */
void oedit_disp_val2_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_2;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Max number of charges : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Number of damage dice : ", d->character);
    break;
  case ITEM_FOOD:
    /* values 2 and 3 are unused, jump to 4. how odd */
    oedit_disp_val4_menu(d);
    break;
  case ITEM_CONTAINER:
    /* these are flags, needs a bit of special handling */
    oedit_disp_container_flags_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Initial drink units : ", d->character);
    break;
   case ITEM_MONEY:
    send_to_char("Number of gold coins : ", d->character);
    break;
  case ITEM_PORTAL:
	  send_to_char("Entry Msg.(To Room) : ", d->character);
	  break;
  case ITEM_WALL:
    send_to_char("Does wall crumble on dispel magic? (0)No (1)Yes : ",d->character);
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #3
 */
void oedit_disp_val3_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_3;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    send_to_char("Number of hours (0 = burnt, -1 is infinite) : ", d->character);
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Number of charges remaining : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Size of damage dice : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Vnum of key to open container (-1 for no key) : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    oedit_liquid_type(d);
    break;
    case ITEM_MONEY:
    send_to_char("Number of silver coins : ", d->character);
    break;
case ITEM_PORTAL:
	  send_to_char("Entry Msg.(To Char) : ", d->character);
	  break;
  case ITEM_WALL:
    send_to_char("Wall Hit Points : ",d->character);
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #4
 */
void oedit_disp_val4_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_4;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
  case ITEM_WAND:
  case ITEM_STAFF:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WEAPON:
    oedit_disp_weapon_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
  case ITEM_FOOD:
    send_to_char("Poisoned (0 = not poison) : ", d->character);
    break;

	  case ITEM_MONEY:
    send_to_char("Number of copper coins : ", d->character);
    break;
  case ITEM_PORTAL:
	  send_to_char("Exit Msg.(To Room) : ", d->character);
	  break;


  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object type.
 */
void oedit_disp_type_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ITEM_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		item_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter object type : ", d->character);
}

/*
 * Object extra flags.
 */
void oedit_disp_extra_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ITEM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		extra_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_EXTRA(OLC_OBJ(d)), extra_bits, buf1);
  sprintf(buf, "\r\nObject flags: %s%s%s\r\n"
	  "Enter object extra flag (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * Object wear flags.
 */
void oedit_disp_wear_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (counter = 0; counter < NUM_ITEM_WEARS; counter++) {
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		wear_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_WEAR(OLC_OBJ(d)), wear_bits, buf1);
    sprintf(buf, "\r\nWear flags: %s%s%s\r\n"
	  "Enter wear flag, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * Display main menu.
 */
void oedit_disp_menu(struct descriptor_data *d)
{
  struct obj_data *obj;

  obj = OLC_OBJ(d);
  get_char_cols(d->character);

  /*. Build buffers for first part of menu .*/
  sprinttype(GET_OBJ_TYPE(obj), item_types, buf1);
  sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf2);

  /*
   * Build first half of menu.
   */
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  ".[H.[J"
#endif
	  "-- Item number : [%s%d%s]\r\n"
	  "%s1%s) Namelist : %s%s\r\n"
	  "%s2%s) S-Desc   : %s%s\r\n"
	  "%s3%s) L-Desc   :-\r\n%s%s\r\n"
	  "%s4%s) A-Desc   :-\r\n%s%s"
	  "%s5%s) Type        : %s%s\r\n"
	  "%s6%s) Extra flags : %s%s\r\n",

	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, yel, (obj->name && *obj->name) ? obj->name : "undefined",
	  grn, nrm, yel, (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
	  grn, nrm, yel, (obj->description && *obj->description) ? obj->description : "undefined",
	  grn, nrm, yel, (obj->action_description && *obj->action_description) ? obj->action_description : "<not set>\r\n",
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2
	  );
  /*
   * Send first half.
   */
  send_to_char(buf, d->character);

  /*. Build second half of menu .*/
  sprintbit(GET_OBJ_WEAR(obj), wear_bits, buf1);
  sprintf(buf,
  	  "%s7%s) Wear flags  : %s%s\r\n"
	  "%s8%s) Weight      : %s%d\r\n"
	  "%s9%s) Cost        : %s%d\r\n"
	  "%sA%s) Cost/Day    : %s%d\r\n"
	  "%sB%s) Timer       : %s%d\r\n"
	  "%sC%s) Values      : %s%d %d %d %d\r\n"
	  "%sD%s) Applies menu\r\n"
	  "%sE%s) Extra descriptions menu\r\n"
	  "%sF%s) Spell affects menu\r\n"
	  "%sG%s) Spell Components Menu\r\n"
	  "%sH%s) Object Limitation Value : %s%d\r\n"
	  "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, GET_OBJ_WEIGHT(obj),
	  grn, nrm, cyn, GET_OBJ_COST(obj),
	  grn, nrm, cyn, GET_OBJ_RENT(obj),
	  grn, nrm, cyn, GET_OBJ_TIMER(obj),
	  grn, nrm, cyn, GET_OBJ_VAL(obj, 0),
	  GET_OBJ_VAL(obj, 1),
	  GET_OBJ_VAL(obj, 2),
	  GET_OBJ_VAL(obj, 3),
	  grn, nrm, grn, nrm,
	  grn, nrm,
	  grn, nrm,
	  grn, nrm, cyn, GET_OBJ_LIMITATION(obj),
	  grn, nrm,
	  cyn, obj->proto_script?"Set.":"Not Set.",
      grn, nrm
	  );
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_MAIN_MENU;
}

/***************************************************************************
 main loop (of sorts).. basically interpreter throws all input to here
 ***************************************************************************/


void oedit_parse(struct descriptor_data *d, char *arg)
{
  int number, max_val, min_val;

  switch (OLC_MODE(d)) {

  case OEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      send_to_char("Saving object to memory.\r\n", d->character);
      oedit_save_internally(d);
      sprintf(buf, "OLC: %s edits obj %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      cleanup_olc(d, CLEANUP_STRUCTS);
      return;
    case 'n':
    case 'N':
      /*. Cleanup all .*/
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save this object internally?\r\n", d->character);
      return;
    }

  case OEDIT_MAIN_MENU:
    /* throw us out to whichever edit mode based on user input */
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {	/* Something has been modified. */
	send_to_char("Do you wish to save this object internally? : ", d->character);
	OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter namelist : ", d->character);
      OLC_MODE(d) = OEDIT_EDIT_NAMELIST;
      break;
    case '2':
      send_to_char("Enter short desc : ", d->character);
      OLC_MODE(d) = OEDIT_SHORTDESC;
      break;
    case '3':
      send_to_char("Enter long desc :-\r\n| ", d->character);
      OLC_MODE(d) = OEDIT_LONGDESC;
      break;
    case '4':
      OLC_MODE(d) = OEDIT_ACTDESC;
       SEND_TO_Q("Enter action description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_OBJ(d)->action_description) {
	SEND_TO_Q(OLC_OBJ(d)->action_description, d);
	d->backstr = str_dup(OLC_OBJ(d)->action_description);
      }
      d->str = &OLC_OBJ(d)->action_description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '5':
      oedit_disp_type_menu(d);
      OLC_MODE(d) = OEDIT_TYPE;
      break;
    case '6':
      oedit_disp_extra_menu(d);
      OLC_MODE(d) = OEDIT_EXTRAS;
      break;
    case '7':
      oedit_disp_wear_menu(d);
      OLC_MODE(d) = OEDIT_WEAR;
      break;
    case '8':
      send_to_char("Enter weight : ", d->character);
      OLC_MODE(d) = OEDIT_WEIGHT;
      break;
   case '9':
      send_to_char("Enter cost (copper) : ", d->character);
      OLC_MODE(d) = OEDIT_COST;
      break;
    case 'a':
    case 'A':
      send_to_char("Enter cost per day : ", d->character);
      OLC_MODE(d) = OEDIT_COSTPERDAY;
      break;
    case 'b':
    case 'B':
      send_to_char("Enter timer : ", d->character);
      OLC_MODE(d) = OEDIT_TIMER;
      break;
    case 'c':
    case 'C':
      /*
       * Clear any old values
       */
      GET_OBJ_VAL(OLC_OBJ(d), 0) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 1) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 2) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 3) = 0;
      oedit_disp_val1_menu(d);
      break;
    case 'd':
    case 'D':
      oedit_disp_prompt_apply_menu(d);
      break;
    case 'e':
    case 'E':
      /*
       * If extra descriptions don't exist.
       */
      if (!OLC_OBJ(d)->ex_description) {
	CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
	OLC_OBJ(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_OBJ(d)->ex_description;
      oedit_disp_extradesc_menu(d);
      break;
	      case 'f' :
    case 'F':
      oedit_disp_prompt_spell_apply_menu(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY;
      break;
	case 'g':
	case 'G':
	  OLC_MODE(d) = OEDIT_SPELL_COMPONENT;
	  oedit_disp_component(d);
	  break;
	case 'h':
	case 'H':
		OLC_MODE(d) = OEDIT_LIMITATION;
		send_to_char("Please enter number of Items allowed(0 for infinate)>", d->character);
		break;
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;


    default:
      oedit_disp_menu(d);
      break;
    }
    return;			/* end of OEDIT_MAIN_MENU */


  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
  case OEDIT_EDIT_NAMELIST:
    if (OLC_OBJ(d)->name)
      free(OLC_OBJ(d)->name);
    OLC_OBJ(d)->name = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_SHORTDESC:
    if (OLC_OBJ(d)->short_description)
      free(OLC_OBJ(d)->short_description);
    OLC_OBJ(d)->short_description = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_LONGDESC:
    if (OLC_OBJ(d)->description)
      free(OLC_OBJ(d)->description);
    OLC_OBJ(d)->description = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_TYPE:
    number = atoi(arg);
    if ((number < 1) || (number >= NUM_ITEM_TYPES)) {
      send_to_char("Invalid choice, try again : ", d->character);
      return;
       } else
      GET_OBJ_TYPE(OLC_OBJ(d)) = number;
    break;
  case OEDIT_SPELL_COMPONENT:
	break;
  case OEDIT_LIMITATION:
	  number = atoi(arg);
	  if (number < 0)
	  {
		  send_to_char("Please choose 0 for infinate or a positive number>", d->character);
		  return;
	  }
	  else
	  {
		  GET_OBJ_LIMITATION(OLC_OBJ(d)) = number;
	  }
	  break;
  case OEDIT_EXTRAS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ITEM_FLAGS)) {
      oedit_disp_extra_menu(d);
      return;
    } else if (number == 0)
      break;
    else {
      TOGGLE_BIT(GET_OBJ_EXTRA(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_extra_menu(d);
      return;

    }

  case OEDIT_WEAR:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ITEM_WEARS)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      oedit_disp_wear_menu(d);
      return;
    } else if (number == 0)	/* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_WEAR(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_wear_menu(d);
      return;
    }

  case OEDIT_WEIGHT:
    GET_OBJ_WEIGHT(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_COST:
    number = atoi(arg);
    GET_OBJ_COST(OLC_OBJ(d)) = number;
    break;

  case OEDIT_COSTPERDAY:
    GET_OBJ_RENT(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_TIMER:
    GET_OBJ_TIMER(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_VALUE_1:
    /*
     * Lucky, I don't need to check any of these for out of range values.
     * Hmm, I'm not so sure - Rv
     */
    GET_OBJ_VAL(OLC_OBJ(d), 0) = atoi(arg);
    /*
     * proceed to menu 2
     */
    oedit_disp_val2_menu(d);
    return;
  case OEDIT_VALUE_2:
    /* here, I do need to check for outofrange values */
    number = atoi(arg);
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      if (number < 0 || number >= NUM_SPELLS)
	oedit_disp_val2_menu(d);
      else {
	GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
	oedit_disp_val3_menu(d);
	}
      break;
    case ITEM_CONTAINER:
      /*
       * Needs some special handling since we are dealing with flag values
       * here.
       */
      if (number < 0 || number > 4)
	oedit_disp_container_flags_menu(d);
      else if (number != 0) {
        TOGGLE_BIT(GET_OBJ_VAL(OLC_OBJ(d), 1), 1 << (number - 1));
        OLC_VAL(d) = 1;
	oedit_disp_val2_menu(d);
      } else
	oedit_disp_val3_menu(d);
      break;

    default:
      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
      oedit_disp_val3_menu(d);
    }
    return;

  case OEDIT_VALUE_3:
    number = atoi(arg);
    /*
     * Quick'n'easy error checking.
     */
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      min_val = 0;
      max_val = NUM_SPELLS - 1;
      break;
    case ITEM_WEAPON:
      min_val = 1;
      max_val = 50;
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 0;
      max_val = 20;
      break;
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      min_val = 0;
      max_val = NUM_LIQ_TYPES - 1;
      break;
    default:
      min_val = -92000;
      max_val = 92000;
    }
    GET_OBJ_VAL(OLC_OBJ(d), 2) = MAX(min_val, MIN(number, max_val));
    oedit_disp_val4_menu(d);
    return;

  case OEDIT_VALUE_4:
    number = atoi(arg);
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      min_val = 0;
      max_val = NUM_SPELLS - 1;
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 1;
      max_val = NUM_SPELLS - 1;
      break;
    case ITEM_WEAPON:
      min_val = 0;
      max_val = NUM_ATTACK_TYPES - 1;
      break;
    default:
      min_val = -92000;
      max_val = 92000;
      break;
    }
    GET_OBJ_VAL(OLC_OBJ(d), 3) = MAX(min_val, MIN(number, max_val));
    break;

  case OEDIT_PROMPT_APPLY:
    if ((number = atoi(arg)) == 0)
      break;
     else if (number < 0 || number > MAX_OBJ_AFFECT) {
      oedit_disp_prompt_apply_menu(d);
      return;
    }
    OLC_VAL(d) = number - 1;
    OLC_MODE(d) = OEDIT_APPLY;
    oedit_disp_apply_menu(d);
    return;

  case OEDIT_APPLY:
      if (atoi(arg) == 8) {
		  send_to_char("I don't think so\r\n", d->character);
		  return;
	  }
	  if ((number = atoi(arg)) == 0) {
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = 0;
      OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = 0;
      oedit_disp_prompt_apply_menu(d);
    } else if (number < 0 || number >= NUM_APPLIES)
      oedit_disp_apply_menu(d);
    else {
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = number;
      send_to_char("Modifier : ", d->character);
      OLC_MODE(d) = OEDIT_APPLYMOD;
    }
    return;

  case OEDIT_APPLYMOD:
    OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = atoi(arg);
    oedit_disp_prompt_apply_menu(d);
    return;
  case OEDIT_SPELL_APPLY:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_SPELL_APPLIES)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
	oedit_disp_prompt_spell_apply_menu(d);
      return;
    } else if (number == 0)	/* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_SPELL(OLC_OBJ(d)), 1 << (number - 1));
	  oedit_disp_prompt_spell_apply_menu(d);
      return;
    }

  case OEDIT_EXTRADESC_KEY:
    if (OLC_DESC(d)->keyword)
      free(OLC_DESC(d)->keyword);
    OLC_DESC(d)->keyword = str_dup((arg && *arg) ? arg : "undefined");
    oedit_disp_extradesc_menu(d);
    return;

  case OEDIT_EXTRADESC_MENU:
    switch ((number = atoi(arg))) {
    case 0:
       if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	struct extra_descr_data **tmp_desc;

	if (OLC_DESC(d)->keyword)
	  free(OLC_DESC(d)->keyword);
	if (OLC_DESC(d)->description)
	  free(OLC_DESC(d)->description);

	/*
	 * Clean up pointers
	 */
	for (tmp_desc = &(OLC_OBJ(d)->ex_description); *tmp_desc;
	     tmp_desc = &((*tmp_desc)->next)) {
	  if (*tmp_desc == OLC_DESC(d)) {
	    *tmp_desc = NULL;
	    break;
	  }
	}
		 free(OLC_DESC(d));
      }
      break;

    case 1:
      OLC_MODE(d) = OEDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces :-\r\n| ", d->character);
      return;

    case 2:
      OLC_MODE(d) = OEDIT_EXTRADESC_DESCRIPTION;
	SEND_TO_Q("Enter the extra description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      return;

    case 3:
      /*
       * Only go to the next description if this one is finished.
       */
      if (OLC_DESC(d)->keyword && OLC_DESC(d)->description) {
	struct extra_descr_data *new_extra;
	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {	/* Make new extra description and attach at end. */
	  CREATE(new_extra, struct extra_descr_data, 1);

	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = OLC_DESC(d)->next;
	}
      }
      /*. No break - drop into default case .*/
    default:
      oedit_disp_extradesc_menu(d);
      return;
    }
    break;
  default:
    mudlog("SYSERR: OLC: Reached default case in oedit_parse()!", BRF, LVL_BUILDER, TRUE);
	send_to_char("Oops...\r\n", d->character);
    break;
  }

  /*
   * If we get here, we have changed something.
   */
  OLC_VAL(d) = 1;
  oedit_disp_menu(d);
}
@


1.58
log
@Removing dependency upon old board system.
@
text
@/***************************************************************************
 * $Id: oedit.c,v 1.57 2009/03/20 13:56:22 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: oedit.c                                        Part of FieryMUD *
 *  Usage:                                                                 *
 *     By: Levork (whoever that is)                                        *
 *         TwyliteMud by Rv. (shameless plug)                              *
 *         Copyright 1996 Harvey Gilpin.                                   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "casting.h"
#include "utils.h"
#include "db.h"
#include "shop.h"
#include "olc.h"
#include "dg_olc.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "fight.h"
#include "interpreter.h"
#include "handler.h"
#include "modify.h"
#include "board.h"
#include "composition.h"

/* external variables */
int *tmp_ptr;
extern const char *portal_entry_messages[];
extern const char *portal_character_messages[];
extern const char *portal_exit_messages[];

/*------------------------------------------------------------------------*/
/*. Macros .*/

#define S_PRODUCT(s, i) ((s)->producing[(i)])

/*------------------------------------------------------------------------*/

void oedit_disp_container_flags_menu(struct descriptor_data *d);
void oedit_disp_extradesc_menu(struct descriptor_data *d);
void oedit_disp_weapon_menu(struct descriptor_data *d);
void oedit_disp_val1_menu(struct descriptor_data *d);
void oedit_disp_val2_menu(struct descriptor_data *d);
void oedit_disp_val3_menu(struct descriptor_data *d);
void oedit_disp_val4_menu(struct descriptor_data *d);
void oedit_disp_type_menu(struct descriptor_data *d);
void oedit_disp_extra_menu(struct descriptor_data *d);
void oedit_disp_wear_menu(struct descriptor_data *d);
void oedit_disp_menu(struct descriptor_data *d);

void oedit_parse(struct descriptor_data *d, char *arg);
void oedit_disp_spells_menu(struct descriptor_data *d);
void oedit_liquid_type(struct descriptor_data *d);
void oedit_setup_new(struct descriptor_data *d);
void oedit_setup_existing(struct descriptor_data *d, int real_num);
void oedit_save_to_disk(int zone);
void oedit_reverse_exdescs(int zone, struct char_data *ch);
int oedit_reverse_exdesc(int real_num, struct char_data *ch);
void oedit_save_internally(struct descriptor_data *d);
void iedit_save_changes(struct descriptor_data *d);

/*------------------------------------------------------------------------*\
  Utility and exported functions
\*------------------------------------------------------------------------*/

void oedit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_OBJ(d), struct obj_data, 1);
  clear_object(OLC_OBJ(d));
  OLC_OBJ(d)->name = strdup("unfinished object");
  OLC_OBJ(d)->description = strdup("An unfinished object is lying here.");
  OLC_OBJ(d)->short_description = strdup("an unfinished object");
  GET_OBJ_WEAR(OLC_OBJ(d)) = ITEM_WEAR_TAKE;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  OLC_VAL(d) = 0;
  oedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void oedit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct extra_descr_data *this, *temp, *temp2;
  struct obj_data *obj;

  /*
   * Allocate object in memory.
   */
  CREATE(obj, struct obj_data, 1);

  clear_object(obj);
  *obj = obj_proto[real_num];


  /*
   * Copy all strings over.
   */
  obj->name = strdup(obj_proto[real_num].name ? obj_proto[real_num].name : "undefined");
  obj->short_description = strdup(obj_proto[real_num].short_description ?
                   obj_proto[real_num].short_description : "undefined");
  obj->description = strdup(obj_proto[real_num].description ?
                 obj_proto[real_num].description : "undefined");
  obj->action_description = (obj_proto[real_num].action_description ?
                 strdup(obj_proto[real_num].action_description) : NULL);

  /*
   * Extra descriptions if necessary.
   */
  if (obj_proto[real_num].ex_description) {
    CREATE(temp, struct extra_descr_data, 1);

    obj->ex_description = temp;
    for (this = obj_proto[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword && *this->keyword) ? strdup(this->keyword) : NULL;
      temp->description = (this->description && *this->description) ?
    strdup(this->description) : NULL;
      if (this->next) {
    CREATE(temp2, struct extra_descr_data, 1);
    temp->next = temp2;
    temp = temp2;
      } else
    temp->next = NULL;
    }
  }

  /*. Attatch new obj to players descriptor .*/
  OLC_OBJ(d) = obj;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  dg_olc_script_copy(d);
  oedit_disp_menu(d);
}
/*------------------------------------------------------------------------*/

#define ZCMD zone_table[zone].cmd[cmd_no]

void oedit_save_internally(struct descriptor_data *d)
{
  int i, shop, robj_num, found = FALSE, zone, cmd_no;
  struct extra_descr_data *this, *next_one;
  struct obj_data *obj, *swap, *new_obj_proto;
  struct index_data *new_obj_index;
  struct descriptor_data *dsc;

  /*
   * Write object to internal tables.
   */
  if ((robj_num = real_object(OLC_NUM(d))) > 0) {
    /*
     * Are we purging?
     */
    if (OLC_MODE(d) == OEDIT_PURGE_OBJECT)
    {
      struct obj_data *placeholder;
      void extract_obj(struct obj_data * ch); /* leaves eq behind..*/

      for (obj = object_list; obj; obj = obj->next)
      {
        if ( GET_OBJ_RNUM(obj) == robj_num)
    {
        placeholder=obj;
#if defined(DEBUG)
        fprintf(stderr, "remove object %d ",GET_OBJ_VNUM(obj));
#endif
        extract_obj(obj);    /*remove all existing objects*/
        obj=placeholder;    /*so we can keep removing..*/
#if defined(DEBUG)
        fprintf(stderr,"(%d left)\n",obj_index[robj_num].number);
#endif
    }
      }
    CREATE(new_obj_proto, struct obj_data, top_of_objt );
    CREATE(new_obj_index, struct index_data, top_of_objt );
#if defined(DEBUG)
    fprintf(stderr,"looking to destroy %d (%d)\n",robj_num,obj_index[robj_num].virtual);
#endif
        for (i = 0; i <= top_of_objt ; i++)
    {
          if (!found)
      {        /* Is this the place? */
    /*    if ((robj_num > top_of_objt) || (mob_index[robj_num].virtual > OLC_NUM(d))) */
        if (i == robj_num)
        {
          found = TRUE;
          /* don't copy..it will be blatted by the free later*/
        }
        else
        {    /* Nope, copy over as normal. */
          new_obj_index[i] = obj_index[i];
          new_obj_proto[i] = obj_proto[i];
        }
          }
      else
      { /* We've already found it, copy the rest over. */
        new_obj_index[i - 1] = obj_index[i];
        new_obj_proto[i - 1] = obj_proto[i];
          }
    }
        top_of_objt --;
#if !defined(I_CRASH)
        free(obj_index);
        free(obj_proto);
#endif
        obj_index = new_obj_index;
        obj_proto = new_obj_proto;
    /*. Renumber live objects .*/
    for (obj = object_list; obj; obj = obj->next)
      if (GET_OBJ_RNUM(obj) != NOTHING && GET_OBJ_RNUM (obj) >= robj_num)
        GET_OBJ_RNUM (obj)--;

    /*. Renumber zone table .*/
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
      switch (ZCMD.command) {
    case 'P':
      if (ZCMD.arg3 >= robj_num)
        ZCMD.arg3--;
      /*
       * No break here - drop into next case.
       */
    case 'O':
    case 'G':
    case 'E':
      if (ZCMD.arg1 >= robj_num)
        ZCMD.arg1--;
      break;
    case 'R':
      if (ZCMD.arg2 >= robj_num)
        ZCMD.arg2--;
      break;
    }

    /*. Renumber shop produce .*/
    for(shop = 0; shop < top_shop; shop++)
      for(i = 0; SHOP_PRODUCT(shop, i) != -1; i++)
        if (SHOP_PRODUCT(shop, i) >= robj_num)
          SHOP_PRODUCT(shop, i)--;

    /*and those being edited     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT)
    for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
      if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
        S_PRODUCT(OLC_SHOP(dsc), i)--;

      /*MARK POINT XXXXX*/
    } else {
    /*
     * We need to run through each and every object currently in the
     * game to see which ones are pointing to this prototype.
     * if object is pointing to this prototype, then we need to replace it
     * with the new one.
     */
    CREATE(swap, struct obj_data, 1);
    for (obj = object_list; obj; obj = obj->next) {
      if (obj->item_number == robj_num) {
    *swap = *obj;
    *obj = *OLC_OBJ(d);
    /*
     * Copy game-time dependent variables over.
     */
    obj->in_room = swap->in_room;
    obj->item_number = robj_num;
    obj->carried_by = swap->carried_by;
    obj->worn_by = swap->worn_by;
    obj->worn_on = swap->worn_on;
    obj->in_obj = swap->in_obj;
    obj->contains = swap->contains;
    obj->next_content = swap->next_content;
    obj->next = swap->next;
        obj->proto_script = OLC_SCRIPT(d);
      }
    }
    free(swap);
    /* now safe to free old proto and write over */
    if (obj_proto[robj_num].name)
      free(obj_proto[robj_num].name);
    if (obj_proto[robj_num].description)
      free(obj_proto[robj_num].description);
    if (obj_proto[robj_num].short_description)
      free(obj_proto[robj_num].short_description);
    if (obj_proto[robj_num].action_description)
      free(obj_proto[robj_num].action_description);
    if (obj_proto[robj_num].ex_description)
      for (this = obj_proto[robj_num].ex_description; this; this = next_one) {
    next_one = this->next;
    if (this->keyword)
      free(this->keyword);
    if (this->description)
      free(this->description);
    free(this);
      }
    /* Must do this before copying OLC_OBJ over */
    if (obj_proto[robj_num].proto_script &&
        obj_proto[robj_num].proto_script != OLC_SCRIPT(d))
      free_proto_script(&obj_proto[robj_num].proto_script);
    obj_proto[robj_num] = *OLC_OBJ(d);
    obj_proto[robj_num].item_number = robj_num;
    obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
  }
  } else {
    /*. It's a new object, we must build new tables to contain it .*/

    CREATE(new_obj_index, struct index_data, top_of_objt + 2);
    CREATE(new_obj_proto, struct obj_data, top_of_objt + 2);
    /* start counting through both tables */
    for (i = 0; i <= top_of_objt; i++) {
      /* if we haven't found it */
      if (!found) {
    /*
     * Check if current virtual is bigger than our virtual number.
     */
    if (obj_index[i].virtual > OLC_NUM(d)) {
      found = TRUE;
      robj_num = i;
      OLC_OBJ(d)->item_number = robj_num;
      new_obj_index[robj_num].virtual = OLC_NUM(d);
      new_obj_index[robj_num].number = 0;
      new_obj_index[robj_num].func = NULL;
      new_obj_proto[robj_num] = *(OLC_OBJ(d));
      new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
      new_obj_proto[robj_num].in_room = NOWHERE;
          /*. Copy over the mob that should be here .*/
          new_obj_index[robj_num + 1] = obj_index[robj_num];
      new_obj_proto[robj_num + 1] = obj_proto[robj_num];
      new_obj_proto[robj_num + 1].item_number = robj_num + 1;
        } else {
      /* just copy from old to new, no num change */
      new_obj_proto[i] = obj_proto[i];
        new_obj_index[i] = obj_index[i];
    }
      } else {
        /* we HAVE already found it.. therefore copy to object + 1 */
        new_obj_index[i + 1] = obj_index[i];
        new_obj_proto[i + 1] = obj_proto[i];
        new_obj_proto[i + 1].item_number = i + 1;
      }
    }
    if (!found) {
      robj_num = i;
      OLC_OBJ(d)->item_number = robj_num;
      new_obj_index[robj_num].virtual = OLC_NUM(d);
      new_obj_index[robj_num].number = 0;
      new_obj_index[robj_num].func = NULL;
      new_obj_proto[robj_num] = *(OLC_OBJ(d));
      new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
      new_obj_proto[robj_num].in_room = NOWHERE;
    }

    /* free and replace old tables */
    free (obj_proto);
    free (obj_index);
    obj_proto = new_obj_proto;
    obj_index = new_obj_index;
    top_of_objt++;

    /*. Renumber live objects .*/
    for (obj = object_list; obj; obj = obj->next)
      if (GET_OBJ_RNUM(obj) != NOTHING && GET_OBJ_RNUM (obj) >= robj_num)
        GET_OBJ_RNUM (obj)++;



    /*. Renumber zone table .*/
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
      switch (ZCMD.command) {
    case 'P':
      if (ZCMD.arg3 >= robj_num)
        ZCMD.arg3++;
      /*
       * No break here - drop into next case.
       */
    case 'O':
    case 'G':
    case 'E':
      if (ZCMD.arg1 >= robj_num)
        ZCMD.arg1++;
      break;
    case 'R':
      if (ZCMD.arg2 >= robj_num)
        ZCMD.arg2++;
      break;
    }

    /*. Renumber shop produce .*/
    for(shop = 0; shop < top_shop; shop++)
      for(i = 0; SHOP_PRODUCT(shop, i) != -1; i++)
        if (SHOP_PRODUCT(shop, i) >= robj_num)
          SHOP_PRODUCT(shop, i)++;




    /*and those being edited     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT)
    for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
      if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
        S_PRODUCT(OLC_SHOP(dsc), i)++;

  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_OBJ);
}

/*------------------------------------------------------------------------*/


void oedit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct obj_data *obj;
  struct extra_descr_data *ex_desc;

  sprintf(buf, "%s/%d.new", OBJ_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_GOD,
       TRUE);
    return;
  }
  /*
   * Start running through all objects in this zone.
   */
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_object(counter)) >= 0) {
      if ((obj = (obj_proto + realcounter))->action_description) {
    strcpy(buf1, obj->action_description);
    strip_string(buf1);
      } else
    *buf1 = '\0';

    fprintf(fp,
        "#%d\n"
        "%s~\n"
        "%s~\n"
        "%s~\n"
        "%s~\n"
        "%d %ld %d %d\n"
        "%d %d %d %d %d %d %d\n"
        "%.2f %d %d %ld %d %d %ld %ld\n",

        GET_OBJ_VNUM(obj),
        (obj->name && *obj->name) ? obj->name : "undefined",
        (obj->short_description && *obj->short_description) ?
        obj->short_description : "undefined",
        (obj->description && *obj->description) ?
        obj->description : "undefined",
        buf1,

        GET_OBJ_TYPE(obj), GET_OBJ_FLAGS(obj)[0],
        GET_OBJ_WEAR(obj), GET_OBJ_LEVEL(obj),

        GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2),
        GET_OBJ_VAL(obj, 3), GET_OBJ_VAL(obj, 4), GET_OBJ_VAL(obj, 5),
        GET_OBJ_VAL(obj, 6),

        GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
        GET_OBJ_TIMER(obj), GET_OBJ_EFF_FLAGS(obj)[0],
        0, 0,
        GET_OBJ_EFF_FLAGS(obj)[1], GET_OBJ_EFF_FLAGS(obj)[2]
        );

      script_save_to_disk(fp, obj, OBJ_TRIGGER);

      /*
       * Do we have extra descriptions?
       */
      if (obj->ex_description) {    /* Yes, save them too. */
    for (ex_desc = obj->ex_description; ex_desc; ex_desc =
           ex_desc->next) {
      /*
       * Sanity check to prevent nasty protection faults.
       */
      if (!*ex_desc->keyword || !*ex_desc->description) {
        mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!",
           BRF, LVL_GOD, TRUE);
        continue;
      }
      strcpy(buf1, ex_desc->description);
      strip_string(buf1);
      fprintf(fp, "E\n"
          "%s~\n"
          "%s~\n", ex_desc->keyword, buf1);
    }
      }

      /* Do we have affects? */
      for (counter2 = 0; counter2 < MAX_OBJ_APPLIES; counter2++)
          if (obj->applies[counter2].location)
      fprintf(fp, "A\n"
          "%d %d\n", obj->applies[counter2].location,
          obj->applies[counter2].modifier);

      if (obj->obj_flags.hiddenness)
        fprintf(fp, "H\n%ld\n", obj->obj_flags.hiddenness);
    }
  }

  /* write final line, close */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.obj", OBJ_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_OBJ);
}


/*------------------------------------------------------------------------*/

int oedit_reverse_exdesc(int real_num, struct char_data *ch)
{
   struct obj_data *obj;
   struct extra_descr_data *ex_desc, *tmp;

   obj = obj_proto + real_num;

   if ((ex_desc = obj->ex_description) && ex_desc->next) {
      for (obj->ex_description = NULL; ex_desc;) {
         tmp = ex_desc->next;
         ex_desc->next = obj->ex_description;
         obj->ex_description = ex_desc;
         ex_desc = tmp;
      }
      if (ch) {
         sprintf(buf, "Reversed exdescs of object %d, %s.\r\n",
               GET_OBJ_VNUM(obj), obj->short_description);
         send_to_char(buf, ch);
      }
      olc_add_to_save_list(
            zone_table[find_real_zone_by_room(GET_OBJ_VNUM(obj))].number,
            OLC_SAVE_OBJ);
      return 1;
   }
   return 0;
}

/*------------------------------------------------------------------------*/

void oedit_reverse_exdescs(int zone, struct char_data *ch)
{
   int counter, realcounter, numprocessed = 0, nummodified = 0;

   for (counter = zone_table[zone].number * 100;
         counter <= zone_table[zone].top; counter++) {
      if ((realcounter = real_object(counter)) >= 0) {
         nummodified += oedit_reverse_exdesc(realcounter, ch);
         numprocessed++;
      }
   }

   /*
   if (nummodified)
      olc_add_to_save_list(zone_table[zone].number, OLC_SAVE_OBJ);
      */

   if (ch) {
      sprintf(buf, "Modified %d of %d object prototype%s in zone %d, %s.\r\n",
            nummodified, numprocessed, numprocessed == 1 ? "" : "s",
            zone_table[zone].number, zone_table[zone].name);
      send_to_char(buf, ch);
   }
}

/**************************************************************************
 *                         Menu functions                                 *
 **************************************************************************/

/*
 *  For wall flags.
 */
void oedit_disp_wall_block_dirs(struct descriptor_data *d)
{
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  sprintf(buf,
      "%s0%s) NORTH\r\n"
      "%s1%s) EAST\r\n"
      "%s2%s) SOUTH\r\n"
      "%s3%s) WEST\r\n"
      "%s4%s) UP\r\n"
      "%s5%s) DOWN\r\n"
      "Enter flag : ",
      grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
}

/*
 * For container flags.
 */
void oedit_disp_container_flags_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintbit(GET_OBJ_VAL(OLC_OBJ(d), VAL_CONTAINER_BITS), container_bits, buf1);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  sprintf(buf,
      "%s1%s) CLOSEABLE\r\n"
      "%s2%s) PICKPROOF\r\n"
      "%s3%s) CLOSED\r\n"
      "%s4%s) LOCKED\r\n"
      "Container flags: %s%s%s\r\n"
      "Enter flag, 0 to quit : ",
      grn, nrm, grn, nrm, grn, nrm, grn, nrm, cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * For extra descriptions.
 */
void oedit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  strcpy(buf1, !extra_desc->next ? "<Not set>\r\n" : "Set.");

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  sprintf(buf,
      "Extra desc menu\r\n"
      "%s1%s) Keyword: %s%s\r\n"
      "%s2%s) Description:\r\n%s%s\r\n"
      "%s3%s) Goto next description: %s\r\n"
      "%s0%s) Quit\r\n"
      "Enter choice : ",

           grn, nrm, yel, (extra_desc->keyword && *extra_desc->keyword) ? extra_desc->keyword : "<NONE>",
      grn, nrm, yel, (extra_desc->description && *extra_desc->description) ? extra_desc->description : "<NONE>",
      grn, nrm, buf1, grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_EXTRADESC_MENU;
}

/*
 * Ask for *which* apply to edit.
 */
void oedit_disp_prompt_apply_menu(struct descriptor_data *d)
{
  int counter;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < MAX_OBJ_APPLIES; counter++) {
    sprintf(buf, " %s%d%s) %s\r\n", grn, counter + 1, nrm,
          format_apply(OLC_OBJ(d)->applies[counter].location,
               OLC_OBJ(d)->applies[counter].modifier));
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter apply to modify (0 to quit) : ", d->character);
  OLC_MODE(d) = OEDIT_PROMPT_APPLY;
}

#define FLAG_INDEX      ((NUM_EFF_FLAGS / columns + 1) * j + i)
void oedit_disp_aff_flags(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char(".[H.[J", d->character);
#endif

  for (i = 0; i <= NUM_EFF_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j) {
      if (FLAG_INDEX >= NUM_EFF_FLAGS)
        break;
      sprintf(buf, "%s%s%2d%s) %-20.20s", buf, grn, FLAG_INDEX + 1, nrm, effect_flags[FLAG_INDEX]);
    }
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  *buf1 = '\0';
  sprintflag(buf1, GET_OBJ_EFF_FLAGS(OLC_OBJ(d)), NUM_EFF_FLAGS, effect_flags);
  sprintf(buf, "\r\nSpell flags: %s%s%s\r\n"
      "Enter spell flag, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
#undef FLAG_INDEX


void oedit_disp_component(struct descriptor_data *d)
{
   /*  int counter; */

  get_char_cols(d->character);
  send_to_char("this is not a functional system yet sorry", d->character);

}

/*
 * Ask for liquid type.
 */
#define TYPE_INDEX    ((NUM_LIQ_TYPES / columns + 1) * j + i)
void oedit_liquid_type(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= NUM_LIQ_TYPES / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (TYPE_INDEX < NUM_LIQ_TYPES)
        sprintf(buf, "%s%s%2d%s) %s%-20.20s%s ", buf,
                grn, TYPE_INDEX + 1, nrm, yel, LIQ_NAME(TYPE_INDEX), nrm);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintf(buf, "\r\n%sEnter drink type : ", nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_VALUE_3;
}
#undef TYPE_INDEX

/*
 * The actual apply to set.
 */
#define TYPE_INDEX    ((NUM_APPLY_TYPES / columns + 1) * j + i)
void oedit_disp_apply_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= NUM_APPLY_TYPES / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (TYPE_INDEX < NUM_APPLY_TYPES)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, TYPE_INDEX, nrm, apply_types[TYPE_INDEX]);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  send_to_char("\r\nEnter apply type (0 is no apply) : ", d->character);
  OLC_MODE(d) = OEDIT_APPLY;
}
#undef TYPE_INDEX

/*
 * Weapon type.
 */
#define TYPE_INDEX    ((NUM_ATTACK_TYPES / columns + 1) * j + i)
void oedit_disp_weapon_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= NUM_ATTACK_TYPES / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (TYPE_INDEX < NUM_ATTACK_TYPES)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, TYPE_INDEX + 1, nrm, attack_hit_text[TYPE_INDEX].singular);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  send_to_char("\r\nEnter weapon type : ", d->character);
}
#undef TYPE_INDEX

/*
 * Spell type.
 */
void oedit_disp_spells_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  /* Fixed to use all spells --gurlaek 7/22/1999 */
  for (counter = 0; counter <= MAX_SPELLS; counter++) {
    if (strcmp(skills[counter].name, "!UNUSED!")) {
      sprintf(buf, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
              skills[counter].name, !(++columns % 3) ? "\r\n" : "");
      send_to_char(buf, d->character);
    }
  }
  sprintf(buf, "\r\n%sEnter spell choice (0 for none) : ", nrm);
  send_to_char(buf, d->character);
}

void oedit_disp_portal_messages_menu(struct descriptor_data *d,
                                     const char *messages[]) {
  int i = 0;

  while (*messages[i] != '\n') {
    sprintf(buf, "%s%d%s) %s", grn, i, nrm, messages[i]);
    send_to_char(buf, d->character);
    ++i;
  }
}

void oedit_disp_boards(struct descriptor_data *d) {
  struct board_iter *iter = board_iterator();
  const struct board_data *board;
  int i = 1;

  while ((board = next_board(iter)))
    dprintf(d, "%s%d%s) %s\r\n", grn, i++, nrm, board->title);

  free_board_iterator(iter);

  dprintf(d, "\r\n%sEnter board choice: ", nrm);
}

/*
 * Object value #1
 */
void oedit_disp_val1_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_1;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    /* values 0 and 1 are unused.. jump to 2 */
    oedit_disp_val3_menu(d);
    break;
  case ITEM_SCROLL:
  case ITEM_WAND:
  case ITEM_STAFF:
  case ITEM_POTION:
    send_to_char("Spell level : ", d->character);
    break;
  case ITEM_WEAPON:
    /* this seems to be a circleism.. not part of normal diku? */
    send_to_char("Modifier to Hitroll : ", d->character);
    break;
  case ITEM_ARMOR:
    send_to_char("Apply to AC : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Max weight to contain : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Capacity (ounces) : ", d->character);
    break;
  case ITEM_FOOD:
    send_to_char("Hours to fill stomach : ", d->character);
    break;
  case ITEM_SPELLBOOK:
    send_to_char("Pages in spellbook : ", d->character);
    break;
  case ITEM_MONEY:
    dprintf(d, "Number of %s coins : ", COIN_NAME(PLATINUM));
    break;
  case ITEM_PORTAL:
    send_to_char("Room to go to : ", d->character);
    break;
  case ITEM_WALL:
    oedit_disp_wall_block_dirs(d);
    break;
  case ITEM_BOARD:
    if (board_count())
      oedit_disp_boards(d);
    else
      dprintf(d, "No boards defined.  (Hit enter.)\r\n");
    break;
  default:
    limit_obj_values(OLC_OBJ(d));
    oedit_disp_menu(d);
  }
}

/*
 * Object value #2
 */
void oedit_disp_val2_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_2;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Max number of charges : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Number of damage dice : ", d->character);
    break;
  case ITEM_FOOD:
    /* values 2 and 3 are unused, jump to 4. how odd */
    oedit_disp_val4_menu(d);
    break;
  case ITEM_CONTAINER:
    /* these are flags, needs a bit of special handling */
    oedit_disp_container_flags_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Initial contents (ounces): ", d->character);
    break;
  case ITEM_MONEY:
    dprintf(d, "Number of %s coins : ", COIN_NAME(GOLD));
    break;
  case ITEM_PORTAL:
    oedit_disp_portal_messages_menu(d, portal_entry_messages);
    send_to_char("Portal entry message to original room: ", d->character);
    break;
  case ITEM_WALL:
    send_to_char("Does wall crumble on dispel magic? (0)No (1)Yes : ",d->character);
    break;
  default:
    limit_obj_values(OLC_OBJ(d));
    oedit_disp_menu(d);
  }
}

/*
 * Object value #3
 */
void oedit_disp_val3_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_3;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    send_to_char("Number of hours (0 = burnt, -1 is infinite) : ", d->character);
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Number of charges remaining : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Size of damage dice : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Vnum of key to open container (-1 for no key) : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    oedit_liquid_type(d);
    break;
  case ITEM_MONEY:
    dprintf(d, "Number of %s coins : ", COIN_NAME(SILVER));
    break;
  case ITEM_PORTAL:
    oedit_disp_portal_messages_menu(d, portal_character_messages);
    send_to_char("Portal entry message to character: ", d->character);
    break;
  case ITEM_WALL:
    send_to_char("Wall Hit Points : ",d->character);
    break;
  default:
    limit_obj_values(OLC_OBJ(d));
    oedit_disp_menu(d);
  }
}

/*
 * Object value #4
 */
void oedit_disp_val4_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_4;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
  case ITEM_WAND:
  case ITEM_STAFF:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WEAPON:
    oedit_disp_weapon_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
  case ITEM_FOOD:
    send_to_char("Poisoned (0 = not poison) : ", d->character);
    break;
  case ITEM_MONEY:
    dprintf(d, "Number of %s coins : ", COIN_NAME(COPPER));
    break;
  case ITEM_PORTAL:
    oedit_disp_portal_messages_menu(d, portal_exit_messages);
    send_to_char("Portal exit message to target room: ", d->character);
    break;
  default:
    limit_obj_values(OLC_OBJ(d));
    oedit_disp_menu(d);
  }
}

/*
 * Object type.
 */
#define FLAG_INDEX (((NUM_ITEM_TYPES - 1) / columns + 1) * j + i)
void oedit_disp_type_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= (NUM_ITEM_TYPES - 1) / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (FLAG_INDEX < NUM_ITEM_TYPES - 1)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, FLAG_INDEX + 1, nrm, item_types[FLAG_INDEX + 1].name);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }
  send_to_char("\r\nEnter object type : ", d->character);
}
#undef FLAG_INDEX

/*
 * Object extra flags.
 */
#define FLAG_INDEX    ((NUM_ITEM_FLAGS / columns + 1) * j + i)
void oedit_disp_extra_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  for (i = 0; i <= NUM_ITEM_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (FLAG_INDEX < NUM_ITEM_FLAGS)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, FLAG_INDEX + 1, nrm, extra_bits[FLAG_INDEX]);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintflag(buf1, GET_OBJ_FLAGS(OLC_OBJ(d)), NUM_ITEM_FLAGS, extra_bits);
  sprintf(buf, "\r\nObject flags: %s%s%s\r\n"
      "Enter object extra flag (0 to quit) : ",
      cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
#undef FLAG_INDEX

/*
 * Object wear flags.
 */
#define FLAG_INDEX    ((NUM_ITEM_WEAR_FLAGS / columns + 1) * j + i)
void oedit_disp_wear_menu(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i <= NUM_ITEM_WEAR_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j)
      if (FLAG_INDEX < NUM_ITEM_WEAR_FLAGS)
        sprintf(buf, "%s%s%2d%s) %-20.20s ", buf,
                grn, FLAG_INDEX + 1, nrm, wear_bits[FLAG_INDEX]);
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintbit(GET_OBJ_WEAR(OLC_OBJ(d)), wear_bits, buf1);
  sprintf(buf, "\r\nWear flags: %s%s%s\r\n"
      "Enter wear flag, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
#undef FLAG_INDEX


void oedit_disp_obj_values(struct descriptor_data *d) {
  struct obj_data *obj = OLC_OBJ(d);
  int i;

  switch (GET_OBJ_TYPE(obj)) {
    case ITEM_LIGHT:
      if (GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING) == LIGHT_PERMANENT)
        sprintf(buf, "         Hours : %sInfinite%s\r\n", cyn, nrm);
      else
        sprintf(buf, "         Hours : %s%d%s\r\n",
                cyn, GET_OBJ_VAL(obj, VAL_LIGHT_REMAINING), nrm);
      break;
    case ITEM_SCROLL:
    case ITEM_POTION:
      sprintf(buf, "   Spell Level : %s%d%s\r\n"
                   "        Spells : %s%s, %s, %s%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_SCROLL_LEVEL), nrm,
              cyn, skill_name(GET_OBJ_VAL(obj, VAL_SCROLL_SPELL_1)),
              skill_name(GET_OBJ_VAL(obj, VAL_SCROLL_SPELL_2)),
              skill_name(GET_OBJ_VAL(obj, VAL_SCROLL_SPELL_3)), nrm);
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      sprintf(buf, "         Spell : %s%s%s\r\n"
                   "   Spell Level : %s%d%s\r\n"
                   "       Charges : %s%d remaining of %d max%s\r\n",
              cyn, skill_name(GET_OBJ_VAL(obj, VAL_WAND_SPELL)), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_WAND_LEVEL), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_WAND_CHARGES_LEFT),
                   GET_OBJ_VAL(obj, VAL_WAND_MAX_CHARGES), nrm);
      break;
    case ITEM_WEAPON:
      sprintf(buf, "   Damage Dice : %s%dd%d%s\r\n"
                   "       Message : %s%s%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_WEAPON_DICE_NUM),
                   GET_OBJ_VAL(obj, VAL_WEAPON_DICE_SIZE), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_WEAPON_DAM_TYPE) >= 0 &&
                   GET_OBJ_VAL(obj, VAL_WEAPON_DAM_TYPE) <= TYPE_STAB - TYPE_HIT?
                   attack_hit_text[GET_OBJ_VAL(obj, VAL_WEAPON_DAM_TYPE)].singular :
                   "INVALID", nrm);
      break;
    case ITEM_ARMOR:
      sprintf(buf, "      AC-Apply : %s%d%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_ARMOR_AC), nrm);
      break;
    case ITEM_TRAP:
      sprintf(buf, "         Spell : %s%s%s\r\n"
                   "     Hitpoints : %s%d%s\r\n",
              cyn, skill_name(GET_OBJ_VAL(obj, VAL_TRAP_SPELL)), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_TRAP_HITPOINTS), nrm);
      break;
    case ITEM_CONTAINER:
      sprintf(buf, "      Capacity : %s%d%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_CONTAINER_CAPACITY), nrm);
      break;
    case ITEM_NOTE:
      sprintf(buf, "        Tongue : %s%d%s\r\n",
              cyn, GET_OBJ_VAL(obj, 0), nrm);
      break;
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      sprintf(buf, "      Capacity : %s%d oz%s\r\n"
                   "      Contains : %s%d oz%s\r\n"
                   "      Poisoned : %s%s%s\r\n"
                   "        Liquid : %s%s%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_DRINKCON_CAPACITY), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_DRINKCON_REMAINING), nrm,
              cyn, YESNO(IS_POISONED(obj)), nrm,
              cyn, LIQ_NAME(GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID)), nrm);
      break;
    case ITEM_FOOD:
      sprintf(buf, "    Makes full : %s%d hours%s\r\n"
                   "      Poisoned : %s%s%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_FOOD_FILLINGNESS), nrm,
              cyn, YESNO(IS_POISONED(obj)), nrm);
      break;
    case ITEM_MONEY:
      sprintf(buf, "         Coins : %s%dp %dg %ds %dc%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM),
                   GET_OBJ_VAL(obj, VAL_MONEY_GOLD),
                   GET_OBJ_VAL(obj, VAL_MONEY_SILVER),
                   GET_OBJ_VAL(obj, VAL_MONEY_COPPER), nrm);
      break;
    case ITEM_PORTAL:
      i = real_room(GET_OBJ_VAL(obj, VAL_PORTAL_DESTINATION));
      sprinttype(GET_OBJ_VAL(obj, VAL_PORTAL_ENTRY_MSG), portal_entry_messages, buf1);
      sprinttype(GET_OBJ_VAL(obj, VAL_PORTAL_CHAR_MSG), portal_character_messages, buf2);
      sprinttype(GET_OBJ_VAL(obj, VAL_PORTAL_EXIT_MSG), portal_exit_messages, arg);
      sprintf(buf, "   Target Room : %s%s (%d)%s\r\n"
                   " Entry Message : %s%s%s"
                   "  Char Message : %s%s%s"
                   "  Exit Message : %s%s%s",
              cyn, i == NOWHERE ? "Invalid Room" : world[i].name,
              GET_OBJ_VAL(obj, VAL_PORTAL_DESTINATION), nrm,
              cyn, buf1, nrm,
              cyn, buf2, nrm,
              cyn, arg, nrm);
      break;
    case ITEM_SPELLBOOK:
      sprintf(buf, "         Pages : %s%d%s\r\n",
              cyn, GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES), nrm);
      break;
    case ITEM_WALL:
      sprinttype(GET_OBJ_VAL(obj, VAL_WALL_DIRECTION), dirs, buf1);
      sprintf(buf, "     Direction : %s%s%s\r\n"
                   "    Dispelable : %s%s%s\r\n"
                   "     Hitpoints : %s%d%s\r\n",
              cyn, buf1, nrm,
              cyn, YESNO(GET_OBJ_VAL(obj, VAL_WALL_DISPELABLE)), nrm,
              cyn, GET_OBJ_VAL(obj, VAL_WALL_HITPOINTS), nrm);
      break;
    case ITEM_BOARD:
      sprintf(buf, "   Board Title : %s%s%s\r\n",
              cyn, board(GET_OBJ_VAL(obj, VAL_BOARD_NUMBER))->title, nrm);
      break;
    default:
      return;
  }
  send_to_char(buf, d->character);
}


/*
 * Display main menu.
 */
void oedit_disp_menu(struct descriptor_data *d)
{
  struct obj_data *obj;

  obj = OLC_OBJ(d);
  get_char_cols(d->character);

  /*. Build buffers for first part of menu .*/
  sprintflag(buf2, GET_OBJ_FLAGS(obj), NUM_ITEM_FLAGS, extra_bits);

  /*
   * Build first half of menu.
   */
  sprintf(buf,
#if defined(CLEAR_SCREEN)
      ".[H.[J"
#endif
      "-- Item: '&5%s&0'  vnum: [&2%5d&0]\r\n"
      "%s1%s) Namelist : %s%s\r\n"
      "%s2%s) S-Desc   : %s%s\r\n"
      "%s3%s) L-Desc   :-\r\n%s%s\r\n"
      "%s4%s) A-Desc   :-\r\n%s%s"
      "%s5%s) Type        : %s%s\r\n"
      "%s6%s) Extra flags : %s%s\r\n",


      (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
      OLC_NUM(d),
      grn, nrm, yel, (obj->name && *obj->name) ? obj->name : "undefined",
      grn, nrm, yel, (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
      grn, nrm, yel, (obj->description && *obj->description) ? obj->description : "undefined",
      grn, nrm, yel, (obj->action_description && *obj->action_description) ? obj->action_description : "<not set>\r\n",
      grn, nrm, cyn, OBJ_TYPE_NAME(obj),
      grn, nrm, cyn, buf2
      );
  /*
   * Send first half.
   */
  send_to_char(buf, d->character);

  /*. Build second half of menu .*/
  sprintbit(GET_OBJ_WEAR(obj), wear_bits, buf1);
  sprintf(buf,
      "%s7%s) Wear flags  : %s%s\r\n"
      "%s8%s) Weight      : %s%.2f\r\n"
      "%s9%s) Cost        : %s%d\r\n"
      "%sA%s) Timer       : %s%d\r\n"
      "%sB%s) Level       : %s%d\r\n"
      "%sC%s) Hiddenness  : %s%ld\r\n"
      "%sD%s) Values      : %s%d %d %d %d %d %d %d%s\r\n",

      grn, nrm, cyn, buf1,
      grn, nrm, cyn, GET_OBJ_WEIGHT(obj),
      grn, nrm, cyn, GET_OBJ_COST(obj),
      grn, nrm, cyn, GET_OBJ_TIMER(obj),
      grn, nrm, cyn, GET_OBJ_LEVEL(obj),
          grn, nrm, cyn, GET_OBJ_HIDDENNESS(obj),
      grn, nrm, cyn, GET_OBJ_VAL(obj, 0),
      GET_OBJ_VAL(obj, 1),
      GET_OBJ_VAL(obj, 2),
      GET_OBJ_VAL(obj, 3),
      GET_OBJ_VAL(obj, 4),
      GET_OBJ_VAL(obj, 5),
      GET_OBJ_VAL(obj, 6),
      nrm
      );

  send_to_char(buf, d->character);

  oedit_disp_obj_values(d);

  *buf1 = '\0';
  sprintflag(buf1, GET_OBJ_EFF_FLAGS(obj), NUM_EFF_FLAGS, effect_flags);
  sprintf(buf,
          "%sE%s) Applies menu\r\n"
      "%sF%s) Extra descriptions menu\r\n"
      "%sG%s) Spell applies : &6%s&0\r\n"
      "%sS%s) Script      : %s%s\r\n"
      "%sQ%s) Quit\r\n"
      "Enter choice : ",

      grn, nrm,
      grn, nrm,
      grn, nrm, buf1,
      grn, nrm,
      cyn, obj->proto_script?"Set.":"Not Set.",
      grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_MAIN_MENU;
}

/***************************************************************************
 *  main loop (of sorts).. basically interpreter throws all input to here  *
 ***************************************************************************/


void oedit_parse(struct descriptor_data *d, char *arg)
{
  int number = atoi(arg);
  float fnum = atof(arg);

  switch (OLC_MODE(d)) {

  case OEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      if (STATE(d) == CON_IEDIT) {
        write_to_output("Saving changes to object.\r\n", d);
        iedit_save_changes(d);
        sprintf(buf, "OLC: %s edits unique obj %s", GET_NAME(d->character), OLC_IOBJ(d)->short_description);
        mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
        REMOVE_FLAG(PLR_FLAGS(d->character), PLR_WRITING);
        STATE(d) = CON_PLAYING;
      }
      else {
        send_to_char("Saving object to memory.\r\n", d->character);
        oedit_save_internally(d);
        sprintf(buf, "OLC: %s edits obj %d", GET_NAME(d->character), OLC_NUM(d));
        mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
      }
      cleanup_olc(d, CLEANUP_STRUCTS);
      return;
    case 'n':
    case 'N':
      /*. Cleanup all .*/
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save this object internally?\r\n", d->character);
      return;
    }

  case OEDIT_MAIN_MENU:
    /* throw us out to whichever edit mode based on user input */
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {    /* Something has been modified. */
        send_to_char("Do you wish to save this object internally? : ", d->character);
        OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
      } else
        cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter namelist : ", d->character);
      OLC_MODE(d) = OEDIT_EDIT_NAMELIST;
      break;
    case '2':
      send_to_char("Enter short desc : ", d->character);
      OLC_MODE(d) = OEDIT_SHORTDESC;
      break;
    case '3':
      send_to_char("Enter long desc :-\r\n| ", d->character);
      OLC_MODE(d) = OEDIT_LONGDESC;
      break;
    case '4':
      OLC_MODE(d) = OEDIT_ACTDESC;
      write_to_output("Enter action description: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_OBJ(d)->action_description, MAX_DESC_LENGTH);
      OLC_VAL(d) = 1;
      break;
    case '5':
      oedit_disp_type_menu(d);
      OLC_MODE(d) = OEDIT_TYPE;
      break;
    case '6':
      oedit_disp_extra_menu(d);
      OLC_MODE(d) = OEDIT_EXTRAS;
      break;
    case '7':
      oedit_disp_wear_menu(d);
      OLC_MODE(d) = OEDIT_WEAR;
      break;
    case '8':
      send_to_char("Enter weight : ", d->character);
      OLC_MODE(d) = OEDIT_WEIGHT;
      break;
   case '9':
      send_to_char("Enter cost (copper) : ", d->character);
      OLC_MODE(d) = OEDIT_COST;
      break;
    case 'a':
    case 'A':
      send_to_char("Enter timer : ", d->character);
      OLC_MODE(d) = OEDIT_TIMER;
      break;
    case 'b':
    case 'B':
      send_to_char("Enter level : ", d->character);
      OLC_MODE(d) = OEDIT_LEVEL;
      break;
    case 'c':
    case 'C':
      send_to_char("Enter hiddenness : ", d->character);
      OLC_MODE(d) = OEDIT_HIDDENNESS;
      break;
    case 'd':
    case 'D':
      /*
       * Clear any old values
       */
      for (number = 0; number < NUM_VALUES; ++number)
        GET_OBJ_VAL(OLC_OBJ(d), number) = 0;
      oedit_disp_val1_menu(d);
      break;
    case 'e':
    case 'E':
      oedit_disp_prompt_apply_menu(d);
      break;
    case 'f':
    case 'F':
      /*
       * If extra descriptions don't exist.
       */
      if (!OLC_OBJ(d)->ex_description) {
    CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
    OLC_OBJ(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_OBJ(d)->ex_description;
      oedit_disp_extradesc_menu(d);
      break;
    case 'g':
    case 'G':
      oedit_disp_aff_flags(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY;
      break;
/*
    case 'h':
    case 'H':
      OLC_MODE(d) = OEDIT_SPELL_COMPONENT;
      oedit_disp_component(d);
      break;
*/
    case 'p':
    case 'P':
      if (GET_OBJ_RNUM(OLC_OBJ(d)) == NOTHING)
      {
        send_to_char("You cannot purge a non-existent (unsaved) objext! Choose again:\r\n",d->character);
      }
      else if (GET_LEVEL(d->character)<LVL_HEAD_B)
      {
        sprintf(buf,"You are too low level to purge! Get a level %d or greater to do this.\r\n",LVL_HEAD_B);
        send_to_char(buf,d->character);
      }
      else
      {
        OLC_MODE(d) = OEDIT_PURGE_OBJECT;
        /* make extra sure*/
        send_to_char("Purging will also remove all existing objects of this sort!\r\n", d->character);
        send_to_char("Are you sure you wish to PERMANENTLY DELETE the object? (y/n) : ", d->character);
      }
      return;
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;


    default:
      oedit_disp_menu(d);
      break;
    }
    return;            /* end of OEDIT_MAIN_MENU */


  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
  case OEDIT_EDIT_NAMELIST:
    if (OLC_OBJ(d)->name)
      free(OLC_OBJ(d)->name);
    OLC_OBJ(d)->name = strdup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_SHORTDESC:
    if (OLC_OBJ(d)->short_description)
      free(OLC_OBJ(d)->short_description);
    OLC_OBJ(d)->short_description = strdup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_LONGDESC:
    if (OLC_OBJ(d)->description)
      free(OLC_OBJ(d)->description);
    OLC_OBJ(d)->description = strdup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_TYPE:
    if ((number < 1) || (number > NUM_ITEM_TYPES)) {
      send_to_char("Invalid choice, try again : ", d->character);
      return;
    }
    GET_OBJ_TYPE(OLC_OBJ(d)) = number;
    limit_obj_values(OLC_OBJ(d));
    break;
  case OEDIT_EXTRAS:
    if ((number < 0) || (number > NUM_ITEM_FLAGS)) {
      oedit_disp_extra_menu(d);
      return;
    } else if (number == 0)
      break;
    else {
      TOGGLE_FLAG(GET_OBJ_FLAGS(OLC_OBJ(d)), number - 1);
      /* This flag shouldn't be on object prototypes */
      REMOVE_FLAG(GET_OBJ_FLAGS(OLC_OBJ(d)), ITEM_WAS_DISARMED);
      oedit_disp_extra_menu(d);
      return;
    }

  case OEDIT_WEAR:
    if ((number < 0) || (number > NUM_ITEM_WEAR_FLAGS)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      oedit_disp_wear_menu(d);
      return;
    } else if (number == 0)    /* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_WEAR(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_wear_menu(d);
      return;
    }

  case OEDIT_WEIGHT:
    GET_OBJ_WEIGHT(OLC_OBJ(d)) = fnum;
    break;

  case OEDIT_COST:
    GET_OBJ_COST(OLC_OBJ(d)) = number;
    break;

  case OEDIT_TIMER:
    GET_OBJ_TIMER(OLC_OBJ(d)) = number;
    break;

  case OEDIT_LEVEL:
    GET_OBJ_LEVEL(OLC_OBJ(d)) = number;
    break;

  case OEDIT_HIDDENNESS:
    GET_OBJ_HIDDENNESS(OLC_OBJ(d)) = LIMIT(0, number, 1000);
    break;

  case OEDIT_VALUE_1:
    /* Range-check values at the very end by calling limit_obj_values */
    GET_OBJ_VAL(OLC_OBJ(d), 0) = number;
    OLC_VAL(d) = 1;
    /* Proceed to menu 2. */
    oedit_disp_val2_menu(d);
    return;

  case OEDIT_VALUE_2:
    /* Check for out of range values. */
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
      if (number < 0 || number > MAX_SPELLS ||
          !strcmp(skills[number].name, "!UNUSED!")) {
        oedit_disp_val2_menu(d);
        return;
      }
      break;
    case ITEM_CONTAINER:
      if (number < 0 || number > 4)
        oedit_disp_container_flags_menu(d);
      else if (number != 0) {
        TOGGLE_BIT(GET_OBJ_VAL(OLC_OBJ(d), VAL_CONTAINER_BITS), 1 << (number - 1));
        oedit_disp_val2_menu(d);
      } else
        oedit_disp_val3_menu(d);
      return;
    default:
      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
    }
    OLC_VAL(d) = 1;
    oedit_disp_val3_menu(d);
    return;

  case OEDIT_VALUE_3:
    /*
     * Quick'n'easy error checking.
     */
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      GET_OBJ_VAL(OLC_OBJ(d), 2) = number;
      if (number < 0 || number > MAX_SPELLS ||
          !strcmp(skills[number].name, "!UNUSED!")) {
        oedit_disp_val3_menu(d);
        return;
      }
      break;
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      --number; /* Types are displayed starting with 1 index */
      /* fall through to default! */
    default:
      GET_OBJ_VAL(OLC_OBJ(d), 2) = number;
    }
    OLC_VAL(d) = 1;
    oedit_disp_val4_menu(d);
    return;

  case OEDIT_VALUE_4:
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
    case ITEM_WAND:
    case ITEM_STAFF:
      GET_OBJ_VAL(OLC_OBJ(d), 3) = number;
      if (number < 0 || number > MAX_SPELLS ||
          !strcmp(skills[number].name, "!UNUSED!")) {
        oedit_disp_val4_menu(d);
        return;
      }
      break;
    case ITEM_WEAPON:
      --number; /* Types are displayed starting with 1 index */
      /* fall through to default! */
    default:
      GET_OBJ_VAL(OLC_OBJ(d), 3) = number;
    }
    OLC_VAL(d) = 1;    
    limit_obj_values(OLC_OBJ(d));
    break;

  case OEDIT_PROMPT_APPLY:
    if (number == 0)
      break;
    else if (number < 0 || number > MAX_OBJ_APPLIES) {
      oedit_disp_prompt_apply_menu(d);
      return;
    }
    OLC_VAL(d) = number - 1;
    OLC_MODE(d) = OEDIT_APPLY;
    oedit_disp_apply_menu(d);
    return;

  case OEDIT_APPLY:
    if (number == 8) {
      send_to_char("I don't think so\r\n", d->character);
      return;
    }
    if (number == 0) {
      OLC_OBJ(d)->applies[OLC_VAL(d)].location = 0;
      OLC_OBJ(d)->applies[OLC_VAL(d)].modifier = 0;
      oedit_disp_prompt_apply_menu(d);
    } else if (number < 0 || number >= NUM_APPLY_TYPES)
      oedit_disp_apply_menu(d);
    else {
      OLC_OBJ(d)->applies[OLC_VAL(d)].location = number;
      if (number == APPLY_COMPOSITION) {
        list_olc_compositions(d->character);
        send_to_char("Composition : ", d->character);
      } else
        send_to_char("Modifier : ", d->character);
      OLC_MODE(d) = OEDIT_APPLYMOD;
    }
    return;

  case OEDIT_APPLYMOD:
    if (OLC_OBJ(d)->applies[OLC_VAL(d)].location == APPLY_COMPOSITION &&
        (number < 0 || number >= NUM_COMPOSITIONS)) {
      send_to_char("Invalid composition!\r\n", d->character);
      list_olc_compositions(d->character);
      send_to_char("Composition : ", d->character);
      return;
    }
    OLC_OBJ(d)->applies[OLC_VAL(d)].modifier = number;
    oedit_disp_prompt_apply_menu(d);
    return;

  case OEDIT_SPELL_APPLY:
    if (number == 0)
      break;
    else if (number > 0 && number <= NUM_EFF_FLAGS)
      TOGGLE_FLAG(GET_OBJ_EFF_FLAGS(OLC_OBJ(d)), number - 1);
    else
      send_to_char("That's not a valid choice!\r\n", d->character);
    oedit_disp_aff_flags(d);
    return;

  case OEDIT_EXTRADESC_KEY:
    if (OLC_DESC(d)->keyword)
      free(OLC_DESC(d)->keyword);
    OLC_DESC(d)->keyword = strdup((arg && *arg) ? arg : "undefined");
    oedit_disp_extradesc_menu(d);
    return;

  case OEDIT_EXTRADESC_MENU:
    switch (number) {
    case 0:
      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
    struct extra_descr_data **tmp_desc;

    if (OLC_DESC(d)->keyword)
      free(OLC_DESC(d)->keyword);
    if (OLC_DESC(d)->description)
      free(OLC_DESC(d)->description);

    /*
     * Clean up pointers
     */
    for (tmp_desc = &(OLC_OBJ(d)->ex_description); *tmp_desc;
         tmp_desc = &((*tmp_desc)->next)) {
      if (*tmp_desc == OLC_DESC(d)) {
        *tmp_desc = NULL;
        break;
      }
    }
    free(OLC_DESC(d));
      }
      break;

    case 1:
      OLC_MODE(d) = OEDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces :-\r\n| ", d->character);
      return;

    case 2:
      OLC_MODE(d) = OEDIT_EXTRADESC_DESCRIPTION;
      write_to_output("Enter the extra description: (/s saves /h for help)\r\n\r\n", d);
      string_write(d, &OLC_DESC(d)->description, MAX_DESC_LENGTH);
      OLC_VAL(d) = 1;
      return;

    case 3:
      /*
       * Only go to the next description if this one is finished.
       */
      if (OLC_DESC(d)->keyword && OLC_DESC(d)->description) {
    struct extra_descr_data *new_extra;
    if (OLC_DESC(d)->next)
      OLC_DESC(d) = OLC_DESC(d)->next;
    else {    /* Make new extra description and attach at end. */
      CREATE(new_extra, struct extra_descr_data, 1);

      OLC_DESC(d)->next = new_extra;
      OLC_DESC(d) = OLC_DESC(d)->next;
    }
      }
      /*. No break - drop into default case .*/
    default:
      oedit_disp_extradesc_menu(d);
      return;
    }
    break;
    case OEDIT_PURGE_OBJECT:
      switch (*arg) {
      case 'y':
      case 'Y':
    /*. Splat the object in memory ..*/
    send_to_char("Purging object from memory.\r\n", d->character);

    /*need to remove all existing objects of this type too..*/
    /*ok..we use save internally, but we are purging because of the mode*/
    oedit_save_internally(d);
    sprintf(buf, "OLC: %s PURGES object %d", GET_NAME(d->character), OLC_NUM(d));
    mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    /* FALL THROUGH */
      case 'n':
      case 'N':
    cleanup_olc(d, CLEANUP_ALL);
    return;
      default:
    send_to_char("Invalid choice!\r\n", d->character);
    send_to_char("Do you wish to purge the object? : ", d->character);
    return;
      }
      break;
  default:
    mudlog("SYSERR: OLC: Reached default case in oedit_parse()!", BRF, LVL_GOD, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }

  /*
   * If we get here, we have changed something.
   */
  OLC_VAL(d) = 1;
  oedit_disp_menu(d);
}


void iedit_setup_existing(struct descriptor_data *d, struct obj_data *obj)
{
  struct obj_data *temp;

  /* So there's no way for this obj to get extracted (by point_update 
   * for example) */
  REMOVE_FROM_LIST(obj, object_list, next);

  /* free any assigned scripts */
  if (SCRIPT(obj))
    extract_script(SCRIPT(obj));
  SCRIPT(obj) = NULL;

  CREATE(OLC_OBJ(d), struct obj_data, 1);

  copy_object(OLC_OBJ(d), obj);

  OLC_IOBJ(d) = obj; /* save reference to real object */
  OLC_VAL(d) = 0;
  OLC_NUM(d) = NOTHING;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  dg_olc_script_copy(d);
  OLC_OBJ(d)->proto_script = NULL;
  oedit_disp_menu(d);
}

void iedit_save_changes(struct descriptor_data *d)
{
  struct obj_data *obj = OLC_IOBJ(d);

  GET_ID(OLC_OBJ(d)) = GET_ID(obj);
  if (GET_OBJ_RNUM(obj) != NOTHING)
    obj_index[GET_OBJ_RNUM(obj)].number--;
  copy_object(obj, OLC_OBJ(d));
  obj->proto_script = OLC_SCRIPT(d);
  GET_OBJ_RNUM(obj) = NOTHING;
}       


ACMD(do_iedit)
{
  struct obj_data *obj;
  int i;

  argument = one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Which object do you want to edit?\r\n", ch);
    return;
  }

  if ((obj = find_obj_in_eq(ch, &i, find_vis_by_name(ch, arg))))
    unequip_char(ch, i);
  else if ((obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, arg))))
    obj_from_char(obj);
  else if ((obj = find_obj_in_list(world[IN_ROOM(ch)].contents, find_vis_by_name(ch, arg))))
    obj_from_room(obj);
  else {
    send_to_char("Object not found.\r\n", ch);
    return;
  }

  /* Setup OLC */
  CREATE(ch->desc->olc, struct olc_data, 1);

  SET_FLAG(PLR_FLAGS(ch), PLR_WRITING);
  iedit_setup_existing(ch->desc, obj);

  act("$n starts using OLC.", TRUE, ch, 0, 0, TO_ROOM);

  STATE(ch->desc) = CON_IEDIT;  
}


/***************************************************************************
 * $Log: oedit.c,v $
 * Revision 1.57  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.56  2009/03/09 21:43:50  myc
 * Use references to coin_names instead of string constants.
 *
 * Revision 1.55  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.54  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.53  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.52  2009/02/21 03:30:16  myc
 * Added new board type.
 *
 * Revision 1.51  2008/09/29 03:24:44  jps
 * Make container weight automatic. Move some liquid container functions to objects.c.
 *
 * Revision 1.50  2008/09/22 02:09:17  jps
 * Changed weight into a floating-point value. Precision is preserved to
 * the 1/100 place.
 *
 * Revision 1.49  2008/09/03 17:34:08  myc
 * Moved liquid information into a def struct array.
 *
 * Revision 1.48  2008/09/03 07:14:34  myc
 * Prevent point_update from extracting an object being iedited.
 *
 * Revision 1.47  2008/08/30 18:20:53  myc
 * Changed some rnum checks to compare against NOTHING constant.
 * Removed UNIQUE item flag.  Fixed obj index number corruption
 * bug.
 *
 * Revision 1.46  2008/08/29 05:34:24  myc
 * Fix doubled 'X stops using OLC.' message when exiting iedit.
 *
 * Revision 1.45  2008/08/29 05:26:06  myc
 * Make sure object prototypes don't have the UNIQUE or WAS_DISARMED flags.
 *
 * Revision 1.44  2008/08/29 05:14:02  myc
 * Removed an extra free_object_strings_proto call that was causing
 * crashes due to double frees.
 *
 * Revision 1.43  2008/08/26 03:58:13  jps
 * Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
 * Except the one for wzoneecho, since it needed to find a real zone by zone number.
 *
 * Revision 1.42  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.41  2008/07/22 07:25:26  myc
 * Added basic iedit (unique item editor) functionality.
 *
 * Revision 1.40  2008/07/18 16:36:22  jps
 * Revert last change - it wasn't trivial.
 *
 * Revision 1.39  2008/07/14 15:50:51  jps
 * Don't update in-game objects when saving a modified object prototype.
 *
 * Revision 1.38  2008/06/19 19:12:54  myc
 * Count an object as being modified when having changed an item value.
 *
 * Revision 1.37  2008/06/19 19:08:17  myc
 * Show pages in spellbook in oedit menu.
 *
 * Revision 1.36  2008/06/19 18:53:12  myc
 * Expaneded item values to 7.  Replaced the item_types and item_type_desc
 * arrays with a typedef struct array that also describes the min and max
 * values for a particular item type.  Oedit now uses these values instead
 * of the ones previously hard-coded into the parser.
 *
 * Revision 1.35  2008/06/11 23:05:02  jps
 * Changed the intro line of the oedit menu.
 *
 * Revision 1.34  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.33  2008/06/05 02:07:43  myc
 * Removed several fields from the object structure, including
 * cost_per_day, spare1, spare2, spare3, and spell component.
 * Changed object flags to use flagvectors.  Fixed an alignment
 * bug in the type menu.
 *
 * Revision 1.32  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.31  2008/04/20 17:48:26  jps
 * Removing unneeded externs.
 *
 * Revision 1.30  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.29  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.28  2008/03/23 00:25:41  jps
 * Allow editing of the composition apply.
 *
 * Revision 1.27  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.26  2008/03/21 15:01:17  myc
 * Removed languages.
 *
 * Revision 1.25  2008/03/17 16:22:42  myc
 * Fixed handling of proto scripts in OLC, including the squashing of
 * a memory leak.  Also fixed a possible premature freeing of memory.
 *
 * Revision 1.24  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.23  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.22  2008/01/29 16:51:12  myc
 * Moving skill names to the skilldef struct.
 *
 * Revision 1.21  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.20  2007/11/18 16:51:55  myc
 * Fixing LVL_BUILDER references.
 *
 * Revision 1.19  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  Hiddenness can be set for objects
 * in oedit.  Cleaned up object value editing and display in oedit.
 * Many values are now checked against min/max values.
 *
 * Revision 1.18  2007/09/15 15:36:48  myc
 * Was zeroing the wrong buffer.
 *
 * Revision 1.17  2007/09/15 05:03:46  myc
 * Implemented a new loop method for some of the menus so that items in
 * the menus get listed column-major instead of by rows.  This applies
 * to the spell applies, liquid types, apply types, weapon types, item
 * types, extra flags, and wear types menus.  Removed a dangerous (small)
 * buffer from oedit_disp_menu.  Removed the in-game distinction between
 * aff 1, 2, and 3 flags.  All aff flags are created equal now, at least
 * from the builder's perspective.
 *
 * Revision 1.16  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.15  2007/07/18 23:01:52  jps
 * Split "oedit revex" into "oedit zrevex" for an entire zone and
 * "oedit revex" for a single object.
 *
 * Revision 1.14  2007/07/18 22:28:47  jps
 * Added syntax "oedit revex <zone>" to reverse extra descs that may
 * have ended up reversed due to the way db.c used to read them.
 *
 * Revision 1.13  2007/07/18 01:21:34  jps
 * You can edit AFF2/AFF3 flags with oedit.
 *
 * Revision 1.12  2007/07/15 21:16:12  myc
 * No more crash when you edit a script on a new object or room.
 *
 * Revision 1.11  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.10  2002/07/14 03:41:18  rls
 * removed purge functionality from menu
 *
 * Revision 1.9  2001/07/08 16:01:22  mtp
 * added safety check for purge of level LVL_HEAD_B (currently 103)
 *
 * Revision 1.7  2001/03/24 05:12:01  dce
 * Objects will now accept a level through olc and upon
 * booting the objects. The level code for the players will
 * follow.
 *
 * Revision 1.6  2000/11/24 19:24:58  rsd
 * Altered comment header and added back rlog messages from
 * prior to the addition of the $log$ string.
 *
 * Revision 1.5  2000/10/14 11:12:40  mtp
 * fixed the olc triggers editting in medit/oedit/redit
 *
 * Revision 1.4  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.3  1999/07/22 17:43:59  jimmy
 * removed the #define NUM_SPELLS that was wrong and used MAX_SPELLS instead.
 * Now all spells are available to assign to scrolls, objs etc.  Not
 * just 71.  This was done to reimplement the IDENTIFY scroll.
 * --gurlaek
 *
 * Revision 1.2  1999/01/31 22:05:32  mud
 * Indented file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.57
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.56 2009/03/09 21:43:50 myc Exp jps $
a25 1
#include "boards.h"
a245 5
    /*. Renumber notice boards */
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) >= robj_num)
    BOARD_RNUM(i) = BOARD_RNUM(i) - 1;

a398 5
    /*. Renumber notice boards */
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) >= robj_num)
    BOARD_RNUM(i) = BOARD_RNUM(i) + 1;

d1403 1
a1403 1
      string_write(d, &OLC_OBJ(d)->action_description, MAX_MESSAGE_LENGTH);
d1767 1
a1767 1
      string_write(d, &OLC_DESC(d)->description, MAX_MESSAGE_LENGTH);
d1905 3
@


1.56
log
@Use references to coin_names instead of string constants.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.55 2009/03/08 23:34:14 jps Exp myc $
d898 1
a898 1
    dprintf(d, "Number of %s coins : ", coin_names[PLATINUM]);
d949 1
a949 1
    dprintf(d, "Number of %s coins : ", coin_names[GOLD]);
d993 1
a993 1
    dprintf(d, "Number of %s coins : ", coin_names[SILVER]);
d1030 1
a1030 1
    dprintf(d, "Number of %s coins : ", coin_names[COPPER]);
d1916 3
@


1.55
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.54 2009/03/08 21:43:27 jps Exp jps $
d898 1
a898 1
    send_to_char("Number of platinum coins : ", d->character);
d949 1
a949 1
    send_to_char("Number of gold coins : ", d->character);
d993 1
a993 1
    send_to_char("Number of silver coins : ", d->character);
d1030 1
a1030 1
    send_to_char("Number of copper coins : ", d->character);
d1916 3
@


1.54
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.53 2009/03/03 19:43:44 myc Exp jps $
d23 1
a23 1
#include "spells.h"
d1916 3
@


1.53
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.52 2009/02/21 03:30:16 myc Exp myc $
d38 1
d1916 3
@


1.52
log
@Added new board type.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.51 2008/09/29 03:24:44 jps Exp myc $
d1890 1
a1890 1
  if ((obj = get_object_in_equip_vis(ch, arg, ch->equipment, &i)))
d1892 1
a1892 1
  else if ((obj = get_obj_in_list_vis(ch, arg, ch->carrying)))
d1894 1
a1894 1
  else if ((obj = get_obj_in_list_vis(ch, arg, world[IN_ROOM(ch)].contents)))
d1915 3
@


1.51
log
@Make container weight automatic. Move some liquid container functions to objects.c.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.50 2008/09/22 02:09:17 jps Exp jps $
d37 1
d846 13
d905 6
d1239 4
d1915 3
@


1.50
log
@Changed weight into a floating-point value. Precision is preserved to
the 1/100 place.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.49 2008/09/03 17:34:08 myc Exp jps $
d874 1
a874 1
    send_to_char("Max drink units : ", d->character);
d925 1
a925 1
    send_to_char("Initial drink units : ", d->character);
d1169 2
a1170 2
      sprintf(buf, "      Capacity : %s%d%s\r\n"
                   "      Contains : %s%d%s\r\n"
d1891 4
@


1.49
log
@Moved liquid information into a def struct array.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.48 2008/09/03 07:14:34 myc Exp myc $
d464 1
a464 1
        "%d %d %d %ld %d %d %ld %ld\n",
d1273 1
a1273 1
      "%s8%s) Weight      : %s%d\r\n"
d1328 1
d1554 1
a1554 1
    GET_OBJ_WEIGHT(OLC_OBJ(d)) = number;
d1891 3
@


1.48
log
@Prevent point_update from extracting an object being iedited.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.47 2008/08/30 18:20:53 myc Exp myc $
d746 1
a746 1
                grn, TYPE_INDEX + 1, nrm, yel, drinks[TYPE_INDEX], nrm);
a1168 1
      sprinttype(GET_OBJ_VAL(obj, VAL_DRINKCON_LIQUID), drinks, buf1);
d1176 1
a1176 1
              cyn, buf1, nrm);
d1890 3
@


1.47
log
@Changed some rnum checks to compare against NOTHING constant.
Removed UNIQUE item flag.  Fixed obj index number corruption
bug.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.46 2008/08/29 05:34:24 myc Exp myc $
d1817 6
d1891 5
@


1.46
log
@Fix doubled 'X stops using OLC.' message when exiting iedit.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.45 2008/08/29 05:26:06 myc Exp myc $
d220 1
a220 1
      if (GET_OBJ_RNUM (obj) >= robj_num)
d376 1
a376 1
      if (GET_OBJ_RNUM (obj) >= robj_num)
d1466 1
a1466 1
      if (GET_OBJ_RNUM(OLC_OBJ(d)) == -1)
d1534 1
a1534 2
      /* These flags shouldn't be on object prototypes */
      REMOVE_FLAG(GET_OBJ_FLAGS(OLC_OBJ(d)), ITEM_UNIQUE);
a1816 2
  struct extra_descr_data *desc, *from;

a1822 5
  *OLC_OBJ(d) = *obj;
  OLC_OBJ(d)->name = obj->name ? strdup(obj->name) : NULL;
  OLC_OBJ(d)->description = obj->description ? strdup(obj->description) : NULL;
  OLC_OBJ(d)->short_description = obj->short_description ? strdup(obj->short_description) : NULL;
  OLC_OBJ(d)->action_description = obj->action_description ? strdup(obj->action_description) : NULL;
d1824 1
a1824 12
  if (obj->ex_description) {
    CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
    desc = OLC_OBJ(d)->ex_description;
    for (from = obj->ex_description; from; from = from->next, desc = desc->next) {
      desc->keyword = strdup(from->keyword);
      desc->description = strdup(from->description);
      if (from->next)
        CREATE(desc->next, struct extra_descr_data, 1);
    }
  }
  else
    OLC_OBJ(d)->ex_description = NULL;
d1828 1
a1828 1
  OLC_NUM(d) = GET_OBJ_VNUM(obj);
d1840 2
d1844 1
a1844 1
  SET_FLAG(GET_OBJ_FLAGS(obj), ITEM_UNIQUE);
d1885 3
@


1.45
log
@Make sure object prototypes don't have the UNIQUE or WAS_DISARMED flags.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.44 2008/08/29 05:14:02 myc Exp myc $
a1342 1
        act("$n stops using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
d1902 3
@


1.44
log
@Removed an extra free_object_strings_proto call that was causing
crashes due to double frees.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.43 2008/08/26 03:58:13 jps Exp myc $
d1535 3
d1903 4
@


1.43
log
@Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
Except the one for wzoneecho, since it needed to find a real zone by zone number.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.42 2008/08/14 09:45:22 jps Exp jps $
a1855 1
  free_object_strings_proto(obj);
d1900 4
@


1.42
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.41 2008/07/22 07:25:26 myc Exp jps $
d559 1
a559 1
            zone_table[real_zone(GET_OBJ_VNUM(obj))].number,
d1901 3
@


1.41
log
@Added basic iedit (unique item editor) functionality.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.40 2008/07/18 16:36:22 jps Exp myc $
d36 1
d1901 3
@


1.40
log
@Revert last change - it wasn't trivial.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.39 2008/07/14 15:50:51 jps Exp jps $
d34 2
d71 1
d1335 15
a1349 4
      send_to_char("Saving object to memory.\r\n", d->character);
      oedit_save_internally(d);
      sprintf(buf, "OLC: %s edits obj %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
d1369 2
a1370 2
    send_to_char("Do you wish to save this object internally? : ", d->character);
    OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
d1372 1
a1372 1
    cleanup_olc(d, CLEANUP_ALL);
d1812 86
d1900 3
@


1.39
log
@Don't update in-game objects when saving a modified object prototype.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.38 2008/06/19 19:12:54 myc Exp jps $
d148 2
a149 1
  struct obj_data *obj, *new_obj_proto;
d259 54
d1800 3
@


1.38
log
@Count an object as being modified when having changed an item value.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.37 2008/06/19 19:08:17 myc Exp myc $
d148 1
a148 2
  struct extra_descr_data *this, *next_one;
  struct obj_data *obj, *swap, *new_obj_proto;
a257 54
      /*MARK POINT XXXXX*/
    } else {
    /*
     * We need to run through each and every object currently in the
     * game to see which ones are pointing to this prototype.
     * if object is pointing to this prototype, then we need to replace it
     * with the new one.
     */
    CREATE(swap, struct obj_data, 1);
    for (obj = object_list; obj; obj = obj->next) {
      if (obj->item_number == robj_num) {
    *swap = *obj;
    *obj = *OLC_OBJ(d);
    /*
     * Copy game-time dependent variables over.
     */
    obj->in_room = swap->in_room;
    obj->item_number = robj_num;
    obj->carried_by = swap->carried_by;
    obj->worn_by = swap->worn_by;
    obj->worn_on = swap->worn_on;
    obj->in_obj = swap->in_obj;
    obj->contains = swap->contains;
    obj->next_content = swap->next_content;
    obj->next = swap->next;
        obj->proto_script = OLC_SCRIPT(d);
      }
    }
    free(swap);
    /* now safe to free old proto and write over */
    if (obj_proto[robj_num].name)
      free(obj_proto[robj_num].name);
    if (obj_proto[robj_num].description)
      free(obj_proto[robj_num].description);
    if (obj_proto[robj_num].short_description)
      free(obj_proto[robj_num].short_description);
    if (obj_proto[robj_num].action_description)
      free(obj_proto[robj_num].action_description);
    if (obj_proto[robj_num].ex_description)
      for (this = obj_proto[robj_num].ex_description; this; this = next_one) {
    next_one = this->next;
    if (this->keyword)
      free(this->keyword);
    if (this->description)
      free(this->description);
    free(this);
      }
    /* Must do this before copying OLC_OBJ over */
    if (obj_proto[robj_num].proto_script &&
        obj_proto[robj_num].proto_script != OLC_SCRIPT(d))
      free_proto_script(&obj_proto[robj_num].proto_script);
    obj_proto[robj_num] = *OLC_OBJ(d);
    obj_proto[robj_num].item_number = robj_num;
    obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
d1745 3
@


1.37
log
@Show pages in spellbook in oedit menu.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.36 2008/06/19 18:53:12 myc Exp myc $
d1560 1
a1581 1
        OLC_VAL(d) = 1;
d1589 1
d1614 1
d1637 1
d1800 3
@


1.36
log
@Expaneded item values to 7.  Replaced the item_types and item_type_desc
arrays with a typedef struct array that also describes the min and max
values for a particular item type.  Oedit now uses these values instead
of the ones previously hard-coded into the parser.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.35 2008/06/11 23:05:02 jps Exp myc $
d1203 4
d1797 6
@


1.35
log
@Changed the intro line of the oedit menu.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.34 2008/06/07 19:06:46 myc Exp jps $
a39 1
extern int real_zone(int number);
a451 1
      if (GET_OBJ_TYPE(obj) == ITEM_PORTAL){
d474 2
a475 1
        GET_OBJ_VAL(obj, 3), 0, 0, 0,
d481 1
a481 29
        );}
      else {
    fprintf(fp,
        "#%d\n"
        "%s~\n"
        "%s~\n"
        "%s~\n"
        "%s~\n"
        "%d %ld %d %d\n"
        "%d %d %d %d %d %d %d\n"
        "%d %d %d %ld %d %d %ld %ld\n",

        GET_OBJ_VNUM(obj),
        (obj->name && *obj->name) ? obj->name : "undefined",
        (obj->short_description && *obj->short_description) ?
        obj->short_description : "undefined",
        (obj->description && *obj->description) ?
        obj->description : "undefined",
        buf1, GET_OBJ_TYPE(obj), GET_OBJ_FLAGS(obj)[0],
        GET_OBJ_WEAR(obj),
                GET_OBJ_LEVEL(obj),
        GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
                                      2),
        GET_OBJ_VAL(obj, 3), 0, 0, 0,
        GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
        0, GET_OBJ_EFF_FLAGS(obj)[0],
        0, 0,
        GET_OBJ_EFF_FLAGS(obj)[1], GET_OBJ_EFF_FLAGS(obj)[2]
        );}
d875 3
a877 2


d888 1
d934 1
d978 1
a1010 1

d1012 1
d1036 1
a1036 1
                grn, FLAG_INDEX + 1, nrm, item_types[FLAG_INDEX + 1]);
a1229 1
  sprinttype(GET_OBJ_TYPE(obj), item_types, buf1);
d1254 1
a1254 1
      grn, nrm, cyn, buf1,
d1265 1
a1265 1
        "%s7%s) Wear flags  : %s%s\r\n"
d1271 1
a1271 1
      "%sD%s) Values      : %s%d %d %d %d%s\r\n",
d1282 6
a1287 2
      GET_OBJ_VAL(obj, 3), nrm
          );
d1320 1
a1320 1
  int number, max_val = 100000, min_val = -100000;
d1414 2
a1415 4
      GET_OBJ_VAL(OLC_OBJ(d), 0) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 1) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 2) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 3) = 0;
a1500 1
    number = atoi(arg);
d1504 3
a1506 2
    } else
      GET_OBJ_TYPE(OLC_OBJ(d)) = number;
a1508 1
    number = atoi(arg);
a1517 1

a1520 1
    number = atoi(arg);
d1534 1
a1534 1
    GET_OBJ_WEIGHT(OLC_OBJ(d)) = atoi(arg);
a1537 1
    number = atoi(arg);
d1542 1
a1542 1
    GET_OBJ_TIMER(OLC_OBJ(d)) = atoi(arg);
a1545 1
    number = atoi(arg);
d1550 1
a1550 2
    number = atoi(arg);
    GET_OBJ_HIDDENNESS(OLC_OBJ(d)) = MAX(0, MIN(number, 1000));
d1554 2
a1555 27
    /* Range-check values */
    number = atoi(arg);
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 0;
      max_val = 100;
      break;
    case ITEM_TRAP:
      min_val = 0;
      max_val = MAX_SPELLS;
      break;
    case ITEM_WALL:
      min_val = 0;
      max_val = NUM_OF_DIRS;
      break;
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
    case ITEM_FOOD:
    case ITEM_MONEY:
    case ITEM_PORTAL:
      min_val = 0;
      break;
    }
    GET_OBJ_VAL(OLC_OBJ(d), 0) = MAX(min_val, MIN(number, max_val));
a1561 1
    number = atoi(arg);
d1565 4
a1568 2
      if (number < 0 || number > MAX_SPELLS || !strcmp(skills[number].name, "!UNUSED!")) {
    oedit_disp_val2_menu(d);
a1571 10
    case ITEM_WEAPON:
      min_val = 1;
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
    case ITEM_TRAP:
    case ITEM_MONEY:
      /* Lower bound of 0 */
      min_val = 0;
      break;
a1572 4
      /*
       * Needs some special handling since we are dealing with flag values
       * here.
       */
d1574 1
a1574 1
    oedit_disp_container_flags_menu(d);
d1578 1
a1578 1
    oedit_disp_val2_menu(d);
d1580 1
a1580 1
    oedit_disp_val3_menu(d);
d1582 2
a1583 13
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      min_val = 0;
      max_val = GET_OBJ_VAL(OLC_OBJ(d), VAL_DRINKCON_CAPACITY);
      break;
    case ITEM_WALL:
      number = (number != 0); /* Yes = 1, No = 0 */
      break;
    case ITEM_PORTAL:
      min_val = 0;
      for (max_val = 0; *portal_entry_messages[max_val] != '\n'; ++max_val);
      --max_val;
      break;
a1584 1
    GET_OBJ_VAL(OLC_OBJ(d), 1) = MAX(min_val, MIN(number, max_val));
a1588 1
    number = atoi(arg);
a1592 3
    case ITEM_LIGHT:
      min_val = -1;
      break;
d1595 4
a1598 2
      if (number < 0 || number > MAX_SPELLS || !strcmp(skills[number].name, "!UNUSED!")) {
    oedit_disp_val3_menu(d);
a1601 8
    case ITEM_WEAPON:
      min_val = 1;
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 0;
      max_val = GET_OBJ_VAL(OLC_OBJ(d), VAL_WAND_MAX_CHARGES);
      break;
d1605 3
a1607 15
      if (number < 0 || number >= NUM_LIQ_TYPES) {
        send_to_char("Invalid liquid type.\r\n", d->character);
        oedit_liquid_type(d);
        return;
      }
      break;
    case ITEM_MONEY:
    case ITEM_WALL:
      min_val = 0;
      break;
    case ITEM_PORTAL:
      min_val = 0;
      for (max_val = 0; *portal_entry_messages[max_val] != '\n'; ++max_val);
      --max_val;
      break;
a1608 1
    GET_OBJ_VAL(OLC_OBJ(d), 2) = MAX(min_val, MIN(number, max_val));
a1612 1
    number = atoi(arg);
d1618 4
a1621 2
      if (number < 0 || number > MAX_SPELLS || !strcmp(skills[number].name, "!UNUSED!")) {
    oedit_disp_val4_menu(d);
a1625 2
      min_val = 0;
      max_val = NUM_ATTACK_TYPES - 1;
d1627 3
a1629 14
      break;
    case ITEM_FOOD:
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      number = (number != 0);
      break;
    case ITEM_MONEY:
      min_val = 0;
      break;
    case ITEM_PORTAL:
      min_val = 0;
      for (max_val = 0; *portal_entry_messages[max_val] != '\n'; ++max_val);
      --max_val;
      break;
d1631 1
a1631 1
    GET_OBJ_VAL(OLC_OBJ(d), 3) = MAX(min_val, MIN(number, max_val));
d1635 1
a1635 1
    if ((number = atoi(arg)) == 0)
d1647 1
a1647 1
    if (atoi(arg) == 8) {
d1651 1
a1651 1
    if ((number = atoi(arg)) == 0) {
a1668 1
    number = atoi(arg);
d1681 1
a1681 1
    if ((number = atoi(arg)) == 0)
d1698 1
a1698 1
    switch ((number = atoi(arg))) {
d1793 3
@


1.34
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.33 2008/06/05 02:07:43 myc Exp myc $
d94 1
a94 1
  
d99 1
a99 1
  
d102 2
a103 2
  
  
d109 1
a109 1
				   obj_proto[real_num].short_description : "undefined");
d111 1
a111 1
			     obj_proto[real_num].description : "undefined");
d113 2
a114 2
			     strdup(obj_proto[real_num].action_description) : NULL);
  
d120 1
a120 1
    
d125 1
a125 1
	strdup(this->description) : NULL;
d127 3
a129 3
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
d131 1
a131 1
	temp->next = NULL;
d134 1
a134 1
  
d153 1
a153 1
  
d169 2
a170 2
	{
		placeholder=obj;
d172 1
a172 1
		fprintf(stderr, "remove object %d ",GET_OBJ_VNUM(obj));
d174 2
a175 2
		extract_obj(obj);	/*remove all existing objects*/
		obj=placeholder;	/*so we can keep removing..*/
d177 1
a177 1
		fprintf(stderr,"(%d left)\n",obj_index[robj_num].number);
d179 1
a179 1
	}
d187 1
a187 1
	{
d189 12
a200 12
	  {		/* Is this the place? */
	/*	if ((robj_num > top_of_objt) || (mob_index[robj_num].virtual > OLC_NUM(d))) */
	    if (i == robj_num)
	    {
	      found = TRUE;
	      /* don't copy..it will be blatted by the free later*/
	    }
	    else
	    {	/* Nope, copy over as normal. */
	      new_obj_index[i] = obj_index[i];
	      new_obj_proto[i] = obj_proto[i];
	    }
d202 4
a205 4
	  else
	  { /* We've already found it, copy the rest over. */
	    new_obj_index[i - 1] = obj_index[i];
	    new_obj_proto[i - 1] = obj_proto[i];
d207 1
a207 1
	}
d219 1
a219 1
    
d223 19
a241 19
  	switch (ZCMD.command) {
	case 'P':
	  if (ZCMD.arg3 >= robj_num)
	    ZCMD.arg3--;
	  /*
	   * No break here - drop into next case.
	   */
	case 'O':
	case 'G':
	case 'E':
	  if (ZCMD.arg1 >= robj_num)
	    ZCMD.arg1--;
	  break;
	case 'R':
	  if (ZCMD.arg2 >= robj_num)
	    ZCMD.arg2--;
	  break;
	}
    
d245 2
a246 2
	BOARD_RNUM(i) = BOARD_RNUM(i) - 1;
    
d252 1
a252 1
    
d256 5
a260 5
	for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
	  if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
	    S_PRODUCT(OLC_SHOP(dsc), i)--;
    
	  /*MARK POINT XXXXX*/
d271 14
a284 14
	*swap = *obj;
	*obj = *OLC_OBJ(d);
	/*
	 * Copy game-time dependent variables over.
	 */
	obj->in_room = swap->in_room;
	obj->item_number = robj_num;
	obj->carried_by = swap->carried_by;
	obj->worn_by = swap->worn_by;
	obj->worn_on = swap->worn_on;
	obj->in_obj = swap->in_obj;
	obj->contains = swap->contains;
	obj->next_content = swap->next_content;
	obj->next = swap->next;
d300 6
a305 6
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
d317 1
a317 1
    
d324 13
a336 13
	/*
	 * Check if current virtual is bigger than our virtual number.
	 */
	if (obj_index[i].virtual > OLC_NUM(d)) {
	  found = TRUE;
	  robj_num = i;
	  OLC_OBJ(d)->item_number = robj_num;
	  new_obj_index[robj_num].virtual = OLC_NUM(d);
	  new_obj_index[robj_num].number = 0;
	  new_obj_index[robj_num].func = NULL;
	  new_obj_proto[robj_num] = *(OLC_OBJ(d));
	  new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
	  new_obj_proto[robj_num].in_room = NOWHERE;
d339 2
a340 2
	  new_obj_proto[robj_num + 1] = obj_proto[robj_num];
	  new_obj_proto[robj_num + 1].item_number = robj_num + 1;
d342 4
a345 4
	  /* just copy from old to new, no num change */
	  new_obj_proto[i] = obj_proto[i];
  	  new_obj_index[i] = obj_index[i];
	}
d363 1
a363 1
    
d370 1
a370 1
    
d375 3
a377 3
    
    
    
d381 19
a399 19
  	switch (ZCMD.command) {
	case 'P':
	  if (ZCMD.arg3 >= robj_num)
	    ZCMD.arg3++;
	  /*
	   * No break here - drop into next case.
	   */
	case 'O':
	case 'G':
	case 'E':
	  if (ZCMD.arg1 >= robj_num)
	    ZCMD.arg1++;
	  break;
	case 'R':
	  if (ZCMD.arg2 >= robj_num)
	    ZCMD.arg2++;
	  break;
	}
    
d403 2
a404 2
	BOARD_RNUM(i) = BOARD_RNUM(i) + 1;
    
d410 4
a413 4
    
    
    
    
d417 4
a420 4
	for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
	  if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
	    S_PRODUCT(OLC_SHOP(dsc), i)++;
    
d434 1
a434 1
  
d438 1
a438 1
	   TRUE);
d448 2
a449 2
	strcpy(buf1, obj->action_description);
	strip_string(buf1);
d451 2
a452 2
	*buf1 = '\0';
      
d454 29
a482 29
	fprintf(fp,
		"#%d\n"
		"%s~\n"
		"%s~\n"
		"%s~\n"
		"%s~\n"
		"%d %ld %d %d\n"
		"%d %d %d %d %d %d %d\n"
		"%d %d %d %ld %d %d %ld %ld\n",
		
		GET_OBJ_VNUM(obj),
		(obj->name && *obj->name) ? obj->name : "undefined",
		(obj->short_description && *obj->short_description) ?
		obj->short_description : "undefined",
		(obj->description && *obj->description) ?
		obj->description : "undefined",
		buf1,

		GET_OBJ_TYPE(obj), GET_OBJ_FLAGS(obj)[0],
		GET_OBJ_WEAR(obj), GET_OBJ_LEVEL(obj),

		GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2),
		GET_OBJ_VAL(obj, 3), 0, 0, 0,

		GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
		GET_OBJ_TIMER(obj), GET_OBJ_EFF_FLAGS(obj)[0], 
		0, 0,
		GET_OBJ_EFF_FLAGS(obj)[1], GET_OBJ_EFF_FLAGS(obj)[2]
		);}
d484 18
a501 18
	fprintf(fp,
		"#%d\n"
		"%s~\n"
		"%s~\n"
		"%s~\n"
		"%s~\n"
		"%d %ld %d %d\n"
		"%d %d %d %d %d %d %d\n"
		"%d %d %d %ld %d %d %ld %ld\n",
		
		GET_OBJ_VNUM(obj),
		(obj->name && *obj->name) ? obj->name : "undefined",
		(obj->short_description && *obj->short_description) ?
		obj->short_description : "undefined",
		(obj->description && *obj->description) ?
		obj->description : "undefined",
		buf1, GET_OBJ_TYPE(obj), GET_OBJ_FLAGS(obj)[0],
		GET_OBJ_WEAR(obj),
d503 9
a511 9
		GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
								      2),
		GET_OBJ_VAL(obj, 3), 0, 0, 0,
		GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
		0, GET_OBJ_EFF_FLAGS(obj)[0],
		0, 0,
		GET_OBJ_EFF_FLAGS(obj)[1], GET_OBJ_EFF_FLAGS(obj)[2]
		);}
      
d513 1
a513 1
      
d515 1
a515 1
       * Do we have extra descriptions? 
d517 17
a533 17
      if (obj->ex_description) {	/* Yes, save them too. */
	for (ex_desc = obj->ex_description; ex_desc; ex_desc =
	       ex_desc->next) {
	  /*
	   * Sanity check to prevent nasty protection faults.
	   */
	  if (!*ex_desc->keyword || !*ex_desc->description) {
	    mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!",
		   BRF, LVL_GOD, TRUE);
	    continue;
	  }
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n"
		  "%s~\n"
		  "%s~\n", ex_desc->keyword, buf1);
	}
d535 1
a535 1
      
d538 4
a541 4
      	if (obj->applies[counter2].location)
	  fprintf(fp, "A\n"
		  "%d %d\n", obj->applies[counter2].location,
		  obj->applies[counter2].modifier);
d557 1
a557 1
  
d632 8
a639 8
	  "%s0%s) NORTH\r\n"
	  "%s1%s) EAST\r\n"
	  "%s2%s) SOUTH\r\n"
	  "%s3%s) WEST\r\n"
	  "%s4%s) UP\r\n"
	  "%s5%s) DOWN\r\n"
	  "Enter flag : ",
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm);
d654 7
a660 7
	  "%s1%s) CLOSEABLE\r\n"
	  "%s2%s) PICKPROOF\r\n"
	  "%s3%s) CLOSED\r\n"
	  "%s4%s) LOCKED\r\n"
	  "Container flags: %s%s%s\r\n"
	  "Enter flag, 0 to quit : ",
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, cyn, buf1, nrm);
d670 1
a670 1
  
d672 1
a672 1
  
d678 10
a687 10
	  "Extra desc menu\r\n"
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: %s\r\n"
	  "%s0%s) Quit\r\n"
	  "Enter choice : ",
	  
     	  grn, nrm, yel, (extra_desc->keyword && *extra_desc->keyword) ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, (extra_desc->description && *extra_desc->description) ? extra_desc->description : "<NONE>",
	  grn, nrm, buf1, grn, nrm);
d718 1
a718 1
  
d737 1
a737 1
	  "Enter spell flag, 0 to quit : ", cyn, buf1, nrm);
d746 1
a746 1
  
d749 1
a749 1
  
d755 1
a755 1
#define TYPE_INDEX	((NUM_LIQ_TYPES / columns + 1) * j + i)
d760 1
a760 1
  
d784 1
a784 1
#define TYPE_INDEX	((NUM_APPLY_TYPES / columns + 1) * j + i)
d789 1
a789 1
  
d812 1
a812 1
#define TYPE_INDEX	((NUM_ATTACK_TYPES / columns + 1) * j + i)
d817 1
a817 1
  
d904 2
a905 2
    
    
d1028 1
a1028 1
    break;    
d1036 1
a1036 1
    
d1050 1
a1050 1
  
d1071 1
a1071 1
#define FLAG_INDEX	((NUM_ITEM_FLAGS / columns + 1) * j + i)
d1076 1
a1076 1
  
d1093 2
a1094 2
	  "Enter object extra flag (0 to quit) : ",
	  cyn, buf1, nrm);
d1102 1
a1102 1
#define FLAG_INDEX	((NUM_ITEM_WEAR_FLAGS / columns + 1) * j + i)
d1107 1
a1107 1
  
d1123 1
a1123 1
	  "Enter wear flag, 0 to quit : ", cyn, buf1, nrm);
d1167 1
a1167 1
                   attack_hit_text[GET_OBJ_VAL(obj, VAL_WEAPON_DAM_TYPE)].singular : 
d1250 1
a1250 1
  
d1253 1
a1253 1
  
d1257 1
a1257 1
  
d1263 1
a1263 1
	  ".[H.[J"
d1265 18
a1282 16
	  "-- Item number : [%s%d%s]\r\n"
	  "%s1%s) Namelist : %s%s\r\n"
	  "%s2%s) S-Desc   : %s%s\r\n"
	  "%s3%s) L-Desc   :-\r\n%s%s\r\n"
	  "%s4%s) A-Desc   :-\r\n%s%s"
	  "%s5%s) Type        : %s%s\r\n"
	  "%s6%s) Extra flags : %s%s\r\n",
	  
	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, yel, (obj->name && *obj->name) ? obj->name : "undefined",
	  grn, nrm, yel, (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
	  grn, nrm, yel, (obj->description && *obj->description) ? obj->description : "undefined",
	  grn, nrm, yel, (obj->action_description && *obj->action_description) ? obj->action_description : "<not set>\r\n",
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2
	  );
d1287 1
a1287 1
  
d1291 13
a1303 13
  	  "%s7%s) Wear flags  : %s%s\r\n"
	  "%s8%s) Weight      : %s%d\r\n"
	  "%s9%s) Cost        : %s%d\r\n"
	  "%sA%s) Timer       : %s%d\r\n"
	  "%sB%s) Level       : %s%d\r\n"
	  "%sC%s) Hiddenness  : %s%ld\r\n"
	  "%sD%s) Values      : %s%d %d %d %d\r\n",

	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, GET_OBJ_WEIGHT(obj),
	  grn, nrm, cyn, GET_OBJ_COST(obj),
	  grn, nrm, cyn, GET_OBJ_TIMER(obj),
	  grn, nrm, cyn, GET_OBJ_LEVEL(obj),
d1305 4
a1308 4
	  grn, nrm, cyn, GET_OBJ_VAL(obj, 0),
	  GET_OBJ_VAL(obj, 1),
	  GET_OBJ_VAL(obj, 2),
	  GET_OBJ_VAL(obj, 3)
d1319 12
a1330 12
	  "%sF%s) Extra descriptions menu\r\n"
	  "%sG%s) Spell applies : &6%s&0\r\n"
	  "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  grn, nrm,
	  grn, nrm,
	  grn, nrm, buf1,
	  grn, nrm,
	  cyn, obj->proto_script?"Set.":"Not Set.",
	  grn, nrm);
d1343 1
a1343 1
  
d1345 1
a1345 1
    
d1366 1
a1366 1
    
d1372 3
a1374 3
      if (OLC_VAL(d)) {	/* Something has been modified. */
	send_to_char("Do you wish to save this object internally? : ", d->character);
	OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
d1376 1
a1376 1
	cleanup_olc(d, CLEANUP_ALL);
d1434 1
a1434 1
       * Clear any old values  
d1452 2
a1453 2
	CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
	OLC_OBJ(d)->ex_description->next = NULL;
d1467 1
a1467 1
      oedit_disp_component(d);	
d1478 2
a1479 2
		sprintf(buf,"You are too low level to purge! Get a level %d or greater to do this.\r\n",LVL_HEAD_B);
		send_to_char(buf,d->character);
d1494 2
a1495 2
      
      
d1500 3
a1502 3
    return;			/* end of OEDIT_MAIN_MENU */
    
    
d1511 1
a1511 1
    
d1517 1
a1517 1
    
d1523 1
a1523 1
    
d1543 1
a1543 1
      
d1545 1
a1545 1
    
d1552 1
a1552 1
    } else if (number == 0)	/* Quit. */
d1559 1
a1559 1
    
d1563 1
a1563 1
    
d1568 1
a1568 1
    
d1572 1
a1572 1
    
d1622 1
a1622 1
	oedit_disp_val2_menu(d);
d1642 1
a1642 1
	oedit_disp_container_flags_menu(d);
d1646 1
a1646 1
	oedit_disp_val2_menu(d);
d1648 1
a1648 1
	oedit_disp_val3_menu(d);
d1667 1
a1667 1
    
d1680 1
a1680 1
	oedit_disp_val3_menu(d);
d1714 1
a1714 1
    
d1723 1
a1723 1
	oedit_disp_val4_menu(d);
d1748 1
a1748 1
    
d1760 1
a1760 1
    
d1782 1
a1782 1
    
d1812 1
a1812 1
    
d1817 18
a1834 18
	struct extra_descr_data **tmp_desc;
	
	if (OLC_DESC(d)->keyword)
	  free(OLC_DESC(d)->keyword);
	if (OLC_DESC(d)->description)
	  free(OLC_DESC(d)->description);
	
	/*
	 * Clean up pointers  
	 */
	for (tmp_desc = &(OLC_OBJ(d)->ex_description); *tmp_desc;
	     tmp_desc = &((*tmp_desc)->next)) {
	  if (*tmp_desc == OLC_DESC(d)) {
	    *tmp_desc = NULL;
	    break;
	  }
	}
	free(OLC_DESC(d));
d1837 1
a1837 1
      
d1842 1
a1842 1
      
d1849 1
a1849 1
      
d1855 9
a1863 9
	struct extra_descr_data *new_extra;
	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {	/* Make new extra description and attach at end. */
	  CREATE(new_extra, struct extra_descr_data, 1);
	  
	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = OLC_DESC(d)->next;
	}
d1875 2
a1876 2
	/*. Splat the object in memory ..*/
	send_to_char("Purging object from memory.\r\n", d->character);
d1878 6
a1883 6
	/*need to remove all existing objects of this type too..*/
	/*ok..we use save internally, but we are purging because of the mode*/
	oedit_save_internally(d);
	sprintf(buf, "OLC: %s PURGES object %d", GET_NAME(d->character), OLC_NUM(d));
	mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
	/* FALL THROUGH */
d1886 2
a1887 2
	cleanup_olc(d, CLEANUP_ALL);
	return;
d1889 3
a1891 3
	send_to_char("Invalid choice!\r\n", d->character);
	send_to_char("Do you wish to purge the object? : ", d->character);
	return;
d1899 1
a1899 1
  
d1901 1
a1901 1
   * If we get here, we have changed something.  
d1909 3
@


1.33
log
@Removed several fields from the object structure, including
cost_per_day, spare1, spare2, spare3, and spell component.
Changed object flags to use flagvectors.  Fixed an alignment
bug in the type menu.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.32 2008/05/18 20:16:11 jps Exp myc $
d649 1
a649 1
  sprintbit(GET_OBJ_VAL(OLC_OBJ(d), 1), container_bits, buf1);
d1135 1
a1135 1
      if (GET_OBJ_VAL(obj, 2) == -1)
d1139 1
a1139 1
                cyn, GET_OBJ_VAL(obj, 2), nrm);
d1145 4
a1148 4
              cyn, GET_OBJ_VAL(obj, 0), nrm,
              cyn, skill_name(GET_OBJ_VAL(obj, 1)),
              skill_name(GET_OBJ_VAL(obj, 2)),
              skill_name(GET_OBJ_VAL(obj, 3)), nrm);
d1155 4
a1158 3
              cyn, skill_name(GET_OBJ_VAL(obj, 3)), nrm,
              cyn, GET_OBJ_VAL(obj, 0), nrm,
              cyn, GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 1), nrm);
d1163 5
a1167 4
              cyn, GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), nrm,
              cyn, GET_OBJ_VAL(obj, 3) >= 0 &&
                   GET_OBJ_VAL(obj, 3) <= TYPE_STAB - TYPE_HIT?
                   attack_hit_text[GET_OBJ_VAL(obj, 3)].singular : 
d1172 1
a1172 1
              cyn, GET_OBJ_VAL(obj, 0), nrm);
d1177 2
a1178 2
              cyn, skill_name(GET_OBJ_VAL(obj, 0)), nrm,
              cyn, GET_OBJ_VAL(obj, 1), nrm);
d1182 1
a1182 1
              cyn, GET_OBJ_VAL(obj, 0), nrm);
d1190 1
a1190 1
      sprinttype(GET_OBJ_VAL(obj, 2), drinks, buf1);
d1195 2
a1196 2
              cyn, GET_OBJ_VAL(obj, 0), nrm,
              cyn, GET_OBJ_VAL(obj, 1), nrm,
d1203 1
a1203 1
              cyn, GET_OBJ_VAL(obj, 0), nrm,
d1208 4
a1211 2
              cyn, GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1),
              GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3), nrm);
d1214 4
a1217 4
      i = real_room(GET_OBJ_VAL(obj, 0));
      sprinttype(GET_OBJ_VAL(obj, 1), portal_entry_messages, buf1);
      sprinttype(GET_OBJ_VAL(obj, 2), portal_character_messages, buf2);
      sprinttype(GET_OBJ_VAL(obj, 3), portal_exit_messages, arg);
d1223 1
a1223 1
              GET_OBJ_VAL(obj, 0), nrm,
d1229 1
a1229 1
      sprinttype(GET_OBJ_VAL(obj, 0), dirs, buf1);
d1234 2
a1235 2
              cyn, YESNO(GET_OBJ_VAL(obj, 1)), nrm,
              cyn, GET_OBJ_VAL(obj, 2), nrm);
d1642 1
a1642 1
        TOGGLE_BIT(GET_OBJ_VAL(OLC_OBJ(d), 1), 1 << (number - 1));
d1651 1
a1651 1
      max_val = GET_OBJ_VAL(OLC_OBJ(d), 0);
d1688 1
a1688 1
      max_val = GET_OBJ_VAL(OLC_OBJ(d), 1);
d1907 6
@


1.32
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.31 2008/04/20 17:48:26 jps Exp jps $
d460 2
a461 2
		"%d %d %d %d\n"
		"%d %d %d %d %d %ld %d\n"
d470 5
a474 3
		buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
		GET_OBJ_WEAR(obj),
                GET_OBJ_LEVEL(obj),
d476 2
a477 1
		GET_OBJ_VAL(obj, 3),  obj->spare1, obj->spare2, obj->spare3,
d480 1
a480 1
		GET_OBJ_COMPONENT(obj), 0,
d490 2
a491 2
		"%d %d %d %d\n"
		"%d %d %d %d %d %ld %d\n"
d500 1
a500 1
		buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
d505 1
a505 1
		GET_OBJ_VAL(obj, 3), obj->spare1, obj->spare2, obj->spare3,
d507 2
a508 2
		GET_OBJ_RENT(obj), GET_OBJ_EFF_FLAGS(obj)[0],
		GET_OBJ_COMPONENT(obj), 0,
d537 2
a538 2
      for (counter2 = 0; counter2 < MAX_OBJ_EFFECT; counter2++)
      	if (obj->effects[counter2].location)
d540 2
a541 2
		  "%d %d\n", obj->effects[counter2].location,
		  obj->effects[counter2].modifier);
d703 1
a703 1
  for (counter = 0; counter < MAX_OBJ_EFFECT; counter++) {
d705 2
a706 2
          format_apply(OLC_OBJ(d)->effects[counter].location,
               OLC_OBJ(d)->effects[counter].modifier));
d1045 1
a1045 1
#define FLAG_INDEX ((NUM_ITEM_TYPES / columns + 1) * j + i)
d1056 1
a1056 1
  for (i = 0; i <= NUM_ITEM_TYPES / columns; ++i) {
d1059 1
a1059 1
      if (FLAG_INDEX < NUM_ITEM_TYPES)
d1091 1
a1091 1
  sprintbit(GET_OBJ_EXTRA(OLC_OBJ(d)), extra_bits, buf1);
d1252 1
a1252 1
  sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf2);
d1288 4
a1291 5
	  "%sA%s) Cost/Day    : %s%d\r\n"
	  "%sB%s) Timer       : %s%d\r\n"
	  "%sC%s) Level       : %s%d\r\n"
	  "%sD%s) Hiddenness  : %s%ld\r\n"
	  "%sE%s) Values      : %s%d %d %d %d\r\n",
a1295 1
	  grn, nrm, cyn, GET_OBJ_RENT(obj),
d1312 3
a1314 3
          "%sF%s) Applies menu\r\n"
	  "%sG%s) Extra descriptions menu\r\n"
	  "%sH%s) Spell applies : &6%s&0\r\n"
d1412 2
a1413 2
      send_to_char("Enter cost per day : ", d->character);
      OLC_MODE(d) = OEDIT_COSTPERDAY;
d1417 2
a1418 2
      send_to_char("Enter timer : ", d->character);
      OLC_MODE(d) = OEDIT_TIMER;
d1422 2
a1423 2
      send_to_char("Enter level : ", d->character);
      OLC_MODE(d) = OEDIT_LEVEL;
a1426 5
      send_to_char("Enter hiddenness : ", d->character);
      OLC_MODE(d) = OEDIT_HIDDENNESS;
      break;
    case 'e':
    case 'E':
d1436 4
a1441 4
      oedit_disp_prompt_apply_menu(d);
      break;
    case 'g':
    case 'G':
d1452 2
a1453 2
    case 'h':
    case 'H':
d1458 2
a1459 2
    case 'j':
    case 'J':
a1525 2
  case OEDIT_SPELL_COMPONENT:
    break;
d1534 1
a1534 1
      TOGGLE_BIT(GET_OBJ_EXTRA(OLC_OBJ(d)), 1 << (number - 1));
a1562 4
  case OEDIT_COSTPERDAY:
    GET_OBJ_RENT(OLC_OBJ(d)) = atoi(arg);
    break;
    
d1746 1
a1746 1
    else if (number < 0 || number > MAX_OBJ_EFFECT) {
d1761 2
a1762 2
      OLC_OBJ(d)->effects[OLC_VAL(d)].location = 0;
      OLC_OBJ(d)->effects[OLC_VAL(d)].modifier = 0;
d1767 1
a1767 1
      OLC_OBJ(d)->effects[OLC_VAL(d)].location = number;
d1779 1
a1779 1
    if (OLC_OBJ(d)->effects[OLC_VAL(d)].location == APPLY_COMPOSITION &&
d1786 1
a1786 1
    OLC_OBJ(d)->effects[OLC_VAL(d)].modifier = number;
d1903 3
@


1.31
log
@Removing unneeded externs.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.30 2008/04/05 05:05:42 myc Exp jps $
d33 1
a36 1
extern struct attack_hit_type attack_hit_text[];
d1913 3
@


1.30
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.29 2008/03/28 17:54:53 myc Exp myc $
a35 2
extern struct shop_data *shop_index;
extern int top_shop;
a39 1
extern struct board_info_type board_info[];
d1913 3
@


1.29
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.28 2008/03/23 00:25:41 jps Exp myc $
d1388 1
a1388 1
      SEND_TO_Q("Enter action description: (/s saves /h for help)\r\n\r\n", d);
d1852 1
a1852 1
      SEND_TO_Q("Enter the extra description: (/s saves /h for help)\r\n\r\n", d);
d1916 4
@


1.28
log
@Allow editing of the composition apply.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.27 2008/03/22 03:22:38 myc Exp jps $
d82 3
a84 3
  OLC_OBJ(d)->name = str_dup("unfinished object");
  OLC_OBJ(d)->description = str_dup("An unfinished object is lying here.");
  OLC_OBJ(d)->short_description = str_dup("an unfinished object");
d110 2
a111 2
  obj->name = str_dup(obj_proto[real_num].name ? obj_proto[real_num].name : "undefined");
  obj->short_description = str_dup(obj_proto[real_num].short_description ?
d113 1
a113 1
  obj->description = str_dup(obj_proto[real_num].description ?
d116 1
a116 1
			     str_dup(obj_proto[real_num].action_description) : NULL);
d126 1
a126 1
      temp->keyword = (this->keyword && *this->keyword) ? str_dup(this->keyword) : NULL;
d128 1
a128 1
	str_dup(this->description) : NULL;
a335 1
	  new_obj_index[robj_num].object_limit = 0;
d456 1
a456 1
      if (GET_OBJ_TYPE(obj) == 24){
d465 1
a465 1
		"%d %d %d %d %d %d %d %d\n",
d479 3
a481 3
		GET_OBJ_TIMER(obj), GET_OBJ_SPELL(obj), 
		GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
		obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
d492 1
a492 1
		"%d %d %d %d %d %d %d %d\n",
d507 3
a509 3
		GET_OBJ_RENT(obj), GET_OBJ_SPELL(obj),
		GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
		obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
d537 2
a538 2
      for (counter2 = 0; counter2 < MAX_OBJ_AFFECT; counter2++)
      	if (obj->affected[counter2].location)
d540 2
a541 2
		  "%d %d\n", obj->affected[counter2].location,
		  obj->affected[counter2].modifier);
d703 1
a703 1
  for (counter = 0; counter < MAX_OBJ_AFFECT; counter++) {
d705 2
a706 2
          format_apply(OLC_OBJ(d)->affected[counter].location,
               OLC_OBJ(d)->affected[counter].modifier));
d709 1
a709 1
  send_to_char("\r\nEnter affection to modify (0 to quit) : ", d->character);
d713 1
a713 2
#define TOTAL_AFF_FLAGS (NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
#define FLAG_INDEX      ((TOTAL_AFF_FLAGS / columns + 1) * j + i)
d724 1
a724 1
  for (i = 0; i <= TOTAL_AFF_FLAGS / columns; ++i) {
d727 1
a727 1
      if (FLAG_INDEX >= TOTAL_AFF_FLAGS)
d729 1
a729 7
      sprintf(buf, "%s%s%2d%s) ", buf, grn, FLAG_INDEX + 1, nrm);
      if (FLAG_INDEX < NUM_AFF_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits[FLAG_INDEX]);
      else if (FLAG_INDEX < NUM_AFF_FLAGS + NUM_AFF2_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits2[FLAG_INDEX - NUM_AFF_FLAGS]);
      else if (FLAG_INDEX < NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits3[FLAG_INDEX - NUM_AFF_FLAGS - NUM_AFF2_FLAGS]);
d735 1
a735 6
  if (GET_OBJ_SPELL(OLC_OBJ(d)))
    sprintbit(GET_OBJ_SPELL(OLC_OBJ(d)), affected_bits, buf1);
  if (GET_OBJ_SPELL2(OLC_OBJ(d)))
    sprintbit(GET_OBJ_SPELL2(OLC_OBJ(d)), affected_bits2, buf1 + strlen(buf1));
  if (GET_OBJ_SPELL3(OLC_OBJ(d)) || !(GET_OBJ_SPELL(OLC_OBJ(d)) || GET_OBJ_SPELL2(OLC_OBJ(d))))
    sprintbit(GET_OBJ_SPELL3(OLC_OBJ(d)), affected_bits3, buf1 + strlen(buf1));
a739 1
#undef TOTAL_AFF_FLAGS
d784 1
a784 1
#define TYPE_INDEX	((NUM_APPLIES / columns + 1) * j + i)
d795 1
a795 1
  for (i = 0; i <= NUM_APPLIES / columns; ++i) {
d798 1
a798 1
      if (TYPE_INDEX < NUM_APPLIES)
d1102 1
a1102 1
#define FLAG_INDEX	((NUM_ITEM_WEARS / columns + 1) * j + i)
d1112 1
a1112 1
  for (i = 0; i <= NUM_ITEM_WEARS / columns; ++i) {
d1115 1
a1115 1
      if (FLAG_INDEX < NUM_ITEM_WEARS)
d1312 1
a1312 7
  if (GET_OBJ_SPELL(obj))
    sprintbit(GET_OBJ_SPELL(obj), affected_bits, buf1);
  if (GET_OBJ_SPELL2(obj))
    sprintbit(GET_OBJ_SPELL2(obj), affected_bits2, buf1 + strlen(buf1));
  /* If no aff1 or 2 flags, then do 3 so it prints NOBITS */
  if (GET_OBJ_SPELL3(obj) || !(GET_OBJ_SPELL(obj) || GET_OBJ_SPELL2(obj)))
    sprintbit(GET_OBJ_SPELL3(obj), affected_bits3, buf1 + strlen(buf1));
d1316 1
a1316 3
	  "%sH%s) Object Limitation Value : %s%d\r\n"
	  "%sI%s) Spell applies : &6%s&0\r\n"
/*	  "%sJ%s) Spell Components Menu\r\n" */
a1322 1
	  grn, nrm, cyn, GET_OBJ_LIMITATION(obj), 
a1323 1
/*	  grn, nrm, */
a1460 5
      OLC_MODE(d) = OEDIT_LIMITATION;
      send_to_char("Please enter number of Items allowed(0 for infinate)>", d->character);
      break;
    case 'i':
    case 'I':
d1510 1
a1510 1
    OLC_OBJ(d)->name = str_dup((arg && *arg) ? arg : "undefined");
d1516 1
a1516 1
    OLC_OBJ(d)->short_description = str_dup((arg && *arg) ? arg : "undefined");
d1522 1
a1522 1
    OLC_OBJ(d)->description = str_dup((arg && *arg) ? arg : "undefined");
a1534 12
  case OEDIT_LIMITATION:
    number = atoi(arg);
    if (number < 0)
      {
	send_to_char("Please choose 0 for infinate or a positive number>", d->character);
	return;
      }
    else
      {
	GET_OBJ_LIMITATION(OLC_OBJ(d)) = number;
      }
    break;
d1551 1
a1551 1
    if ((number < 0) || (number > NUM_ITEM_WEARS)) {
d1759 1
a1759 1
    else if (number < 0 || number > MAX_OBJ_AFFECT) {
d1774 2
a1775 2
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = 0;
      OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = 0;
d1777 1
a1777 1
    } else if (number < 0 || number >= NUM_APPLIES)
d1780 1
a1780 1
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = number;
d1792 1
a1792 1
    if (OLC_OBJ(d)->affected[OLC_VAL(d)].location == APPLY_COMPOSITION &&
d1799 1
a1799 1
    OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = number;
d1806 2
a1807 8
    else if (number > 0 && number <= NUM_AFF_FLAGS)
      TOGGLE_BIT(GET_OBJ_SPELL(OLC_OBJ(d)), 1 << (number - 1));
    else if (number > NUM_AFF_FLAGS &&
             number <= NUM_AFF_FLAGS + NUM_AFF2_FLAGS)
      TOGGLE_BIT(GET_OBJ_SPELL2(OLC_OBJ(d)), 1 << (number - 1 - NUM_AFF_FLAGS));
    else if (number > NUM_AFF_FLAGS + NUM_AFF2_FLAGS &&
             number <= NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
      TOGGLE_BIT(GET_OBJ_SPELL3(OLC_OBJ(d)), 1 << (number - 1 - NUM_AFF_FLAGS + NUM_AFF2_FLAGS));
d1816 1
a1816 1
    OLC_DESC(d)->keyword = str_dup((arg && *arg) ? arg : "undefined");
d1916 3
@


1.27
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.26 2008/03/21 15:01:17 myc Exp myc $
d539 1
a539 1
      	if (obj->affected[counter2].modifier)
d699 1
a699 1
  
d705 4
a708 9
    if (OLC_OBJ(d)->affected[counter].modifier) {
      sprinttype(OLC_OBJ(d)->affected[counter].location, apply_types, buf2);
      sprintf(buf, " %s%d%s) %+d to %s\r\n", grn, counter + 1, nrm,
	      OLC_OBJ(d)->affected[counter].modifier, buf2);
      send_to_char(buf, d->character);
    } else {
      sprintf(buf, " %s%d%s) None.\r\n", grn, counter + 1, nrm);
      send_to_char(buf, d->character);
    }
d1822 5
a1826 1
      send_to_char("Modifier : ", d->character);
d1832 9
a1840 1
    OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = atoi(arg);
d1963 6
@


1.26
log
@Removed languages.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.25 2008/03/17 16:22:42 myc Exp myc $
d1418 1
a1418 8
      d->backstr = NULL;
      if (OLC_OBJ(d)->action_description) {
	SEND_TO_Q(OLC_OBJ(d)->action_description, d);
	d->backstr = str_dup(OLC_OBJ(d)->action_description);
      }
      d->str = &OLC_OBJ(d)->action_description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
d1893 1
a1893 8
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
d1956 3
@


1.25
log
@Fixed handling of proto scripts in OLC, including the squashing of
a memory leak.  Also fixed a possible premature freeing of memory.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.24 2008/02/09 04:27:47 myc Exp myc $
a927 4
  case ITEM_NOTE:
    /* this is supposed to be language, but it's unused */
    
    break;
a1668 4
    case ITEM_NOTE:
      min_val = MIN_LANGUAGE;
      max_val = MAX_LANGUAGE;
      break;
d1970 4
@


1.24
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.23 2008/01/29 21:02:31 myc Exp myc $
a137 4
  
  if (SCRIPT(obj))
    script_copy(obj, &obj_proto[real_num], OBJ_TRIGGER);
  
d288 1
d291 1
a291 1
    free_obj(swap);
d310 4
a1537 2
      OLC_SCRIPT(d) = OLC_OBJ(d)->proto_script;
      OLC_OBJ(d)->proto_script=(struct trig_proto_list *)NULL;
d1978 3
@


1.23
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.22 2008/01/29 16:51:12 myc Exp myc $
d32 1
d1979 4
@


1.22
log
@Moving skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.21 2008/01/26 14:26:31 jps Exp myc $
d31 1
a34 6
extern struct obj_data *obj_proto;
extern struct index_data *obj_index;
extern struct obj_data *object_list;
extern int top_of_objt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
d38 3
a40 13
extern char *item_types[];
extern char *wear_bits[];
extern char *extra_bits[];
extern char *drinks[];
extern char *apply_types[];
extern char *container_bits[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern char *dirs[];
extern char *portal_entry_messages[];
extern char *portal_character_messages[];
extern char *portal_exit_messages[];
a41 2
extern struct descriptor_data *descriptor_list;
extern int *obj_limit;
a42 1
extern struct room_data *world;
d877 1
a877 1
                                     char *messages[]) {
d1978 3
@


1.21
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.20 2007/11/18 16:51:55 myc Exp jps $
d884 1
a884 1
    if(strcmp(skillnames[counter], "!UNUSED!")) {
d886 1
a886 1
              skillnames[counter], !(++columns % 3) ? "\r\n" : "");
d1707 1
a1707 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(skillnames[number], "!UNUSED!")) {
d1765 1
a1765 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(skillnames[number], "!UNUSED!")) {
d1808 1
a1808 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(skillnames[number], "!UNUSED!")) {
d1996 3
@


1.20
log
@Fixing LVL_BUILDER references.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.19 2007/09/20 21:20:43 myc Exp myc $
d30 1
a31 1
/*------------------------------------------------------------------------*/
a48 1
extern char *spells[];
d884 1
a884 1
    if(strcmp(spells[counter], "!UNUSED!")) {
d886 1
a886 1
              spells[counter], !(++columns % 3) ? "\r\n" : "");
d1707 1
a1707 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(spells[number], "!UNUSED!")) {
d1765 1
a1765 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(spells[number], "!UNUSED!")) {
d1808 1
a1808 1
      if (number < 0 || number > MAX_SPELLS || !strcmp(spells[number], "!UNUSED!")) {
d1996 3
@


1.19
log
@Hide points and perception are in.  Hiddenness can be set for objects
in oedit.  Cleaned up object value editing and display in oedit.
Many values are now checked against min/max values.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.18 2007/09/15 15:36:48 myc Exp myc $
d458 1
a458 1
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_BUILDER,
d543 1
a543 1
		   BRF, LVL_BUILDER, TRUE);
d1399 1
a1399 1
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
d1970 1
a1970 1
	mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
d1983 1
a1983 1
    mudlog("SYSERR: OLC: Reached default case in oedit_parse()!", BRF, LVL_BUILDER, TRUE);
d1997 5
@


1.18
log
@Was zeroing the wrong buffer.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.17 2007/09/15 05:03:46 myc Exp myc $
d53 4
d61 1
d560 3
d565 1
a565 1
  
d895 11
d994 2
a995 1
    send_to_char("Entry Msg.(To Room) : ", d->character);
d1037 2
a1038 1
    send_to_char("Entry Msg.(To Char) : ", d->character);
d1068 1
a1068 2
    break;
    
d1073 2
a1074 1
    send_to_char("Exit Msg.(To Room) : ", d->character);
a1076 1
    
d1168 112
d1330 3
a1332 3
     "%sC%s) Level       : %s%d\r\n"
	  "%sD%s) Values      : %s%d %d %d %d\r\n"
	  "%sE%s) Applies menu\r\n",
d1340 1
d1344 2
a1345 2
	  GET_OBJ_VAL(obj, 3),
     grn, nrm);
d1349 2
d1360 5
a1364 4
	  "%sF%s) Extra descriptions menu\r\n"
	  "%sG%s) Object Limitation Value : %s%d\r\n"
	  "%sH%s) Spell applies : &6%s&0\r\n"
/*	  "%sI%s) Spell Components Menu\r\n" */
d1370 1
d1388 1
a1388 1
  int number, max_val, min_val;
d1486 5
d1500 2
a1501 2
    case 'e':
    case 'E':
d1504 2
a1505 2
    case 'f':
    case 'F':
d1516 2
a1517 2
    case 'g':
    case 'G':
d1521 2
a1522 2
    case 'h':
    case 'H':
d1527 2
a1528 2
    case 'i':
    case 'I':
d1661 5
d1667 32
a1698 8
    /*
     * Lucky, I don't need to check any of these for out of range values.
     * Hmm, I'm not so sure - Rv  
     */
    GET_OBJ_VAL(OLC_OBJ(d), 0) = atoi(arg);
    /*
     * proceed to menu 2 
     */
d1701 1
d1703 1
a1703 1
    /* here, I do need to check for outofrange values */
d1708 1
a1708 2
      /* fixed to use all spells --gurlaek 7/22/1999 */
      if (number < 0 || number > MAX_SPELLS || !strcmp(spells[number], "!UNUSED!"))
d1710 1
a1710 3
      else {
	GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
	oedit_disp_val3_menu(d);
d1713 10
d1736 13
a1749 4
      
    default:
      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
      oedit_disp_val3_menu(d);
d1751 2
d1761 3
d1766 4
a1769 2
      min_val = 0;
      max_val = MAX_SPELLS; /* fixed to allow for all spells --gurlaek 7/22/1999 */
d1773 1
a1773 1
      max_val = 50;
d1777 1
a1777 1
      max_val = 20;
d1781 9
a1790 2
      max_val = NUM_LIQ_TYPES - 1;
      --number; /* Types are displayed starting with 1 index */
d1792 5
a1796 3
    default:
      min_val = -92000;
      max_val = 92000;
a1806 3
      min_val = 0;
      max_val = MAX_SPELLS; /* gurlaek 7/22/1999 */
      break;
d1809 4
a1812 2
      min_val = 1;
      max_val = MAX_SPELLS; /* gurlaek 7/22/1999 */
d1819 12
a1830 3
    default:
      min_val = -92000;
      max_val = 92000;
d1997 3
@


1.17
log
@Implemented a new loop method for some of the menus so that items in
the menus get listed column-major instead of by rows.  This applies
to the spell applies, liquid types, apply types, weapon types, item
types, extra flags, and wear types menus.  Removed a dangerous (small)
buffer from oedit_disp_menu.  Removed the in-game distinction between
aff 1, 2, and 3 flags.  All aff flags are created equal now, at least
from the builder's perspective.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.16 2007/07/24 23:02:52 jps Exp myc $
d756 1
a756 1
  *buf = '\0';
d1785 9
@


1.16
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.15 2007/07/18 23:01:52 jps Exp jps $
d728 3
a730 1
void oedit_disp_prompt_spell_apply_menu(struct descriptor_data *d)
d732 2
a733 1
  int counter, columns = 0;
d739 24
a762 6
  for (counter = 0; counter < NUM_SPELL_APPLIES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
	    affected_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_SPELL(OLC_OBJ(d)), affected_bits, buf1);
d767 2
a769 45
/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/


void oedit_disp_aff2_flags(struct descriptor_data *d)
{ 
  int i, columns = 0;
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits2[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_SPELL2(OLC_OBJ(d)), affected_bits2, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff2 flags (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}


/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/

void oedit_disp_aff3_flags(struct descriptor_data *d)
{ 
  int i, columns = 0;
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits3[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_SPELL3(OLC_OBJ(d)), affected_bits3, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff3 flags (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
d783 1
d786 2
a787 1
  int counter, columns = 0;
d793 8
a800 4
  for (counter = 0; counter < NUM_LIQ_TYPES; counter++) {
    sprintf(buf, " %s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
	    drinks[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d802 1
d807 1
d812 1
d815 2
a816 1
  int counter, columns = 0;
d822 8
a829 4
  for (counter = 0; counter < NUM_APPLIES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
	    apply_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d831 1
d835 1
a835 1

d840 1
d843 2
a844 1
  int counter, columns = 0;
d850 8
a857 5
  for (counter = 0; counter < NUM_ATTACK_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
	    attack_hit_text[counter].singular,
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d859 1
d862 1
d870 1
a870 1
  
d873 1
a873 1
  send_to_char("[H[J", d->character);
d879 1
a879 1
	      spells[counter], !(++columns % 3) ? "\r\n" : "");
d1065 1
d1068 2
a1069 1
  int counter, columns = 0;
d1075 8
a1082 4
  for (counter = 0; counter < NUM_ITEM_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
	    item_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d1086 1
d1091 1
d1094 2
a1095 1
  int counter, columns = 0;
d1101 8
a1108 4
  for (counter = 0; counter < NUM_ITEM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
	    extra_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d1110 1
d1117 1
d1122 1
d1125 2
a1126 1
  int counter, columns = 0;
d1132 7
a1138 4
  for (counter = 0; counter < NUM_ITEM_WEARS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
	    wear_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d1140 1
d1146 1
a1153 2
  char buf3[609];

d1216 8
a1223 3
  sprintbit(GET_OBJ_SPELL(obj), affected_bits, buf1);
  sprintbit(GET_OBJ_SPELL2(obj), affected_bits2, buf2);
  sprintbit(GET_OBJ_SPELL3(obj), affected_bits3, buf3);
d1226 3
a1228 5
	  "%sG%s) Spell Components Menu\r\n"
	  "%sH%s) Object Limitation Value : %s%d\r\n"
	  "%sI%s) Spell applies 1  : &6%s&0\r\n"
	  "%sJ%s) Spell applies 2  : &6%s&0\r\n"
	  "%sK%s) Spell applies 3  : &6%s&0\r\n"
a1233 1
	  grn, nrm, 
d1236 1
a1236 2
	  grn, nrm, buf2,
	  grn, nrm, buf3,
d1374 1
a1374 1
    case 'g' :
d1376 2
a1377 2
      OLC_MODE(d) = OEDIT_SPELL_COMPONENT;
      oedit_disp_component(d);	
d1381 2
a1382 2
      OLC_MODE(d) = OEDIT_LIMITATION;
      send_to_char("Please enter number of Items allowed(0 for infinate)>", d->character);
d1384 1
d1387 2
a1388 12
      oedit_disp_prompt_spell_apply_menu(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY;
      break;
    case 'j':
    case 'J':
      oedit_disp_aff2_flags(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY2;
      break;
    case 'k':
    case 'K':
      oedit_disp_aff3_flags(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY3;
d1390 1
d1449 1
a1449 1
    if ((number < 1) || (number >= NUM_ITEM_TYPES)) {
d1588 1
d1614 1
d1658 1
d1660 1
a1660 6
    number = atoi(arg);
    if ((number < 0) || (number > NUM_SPELL_APPLIES)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      oedit_disp_prompt_spell_apply_menu(d);
      return;
    } else if (number == 0)	/* Quit. */
d1662 1
a1662 1
    else {
d1664 7
a1670 6
      oedit_disp_prompt_spell_apply_menu(d);
      return;
    }
  case OEDIT_SPELL_APPLY2:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_AFF_FLAGS)) {
d1672 3
a1674 23
      oedit_disp_aff2_flags(d);
      return;
    } else if (number == 0)	/* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_SPELL2(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_aff2_flags(d);
      return;
    }
  case OEDIT_SPELL_APPLY3:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_AFF_FLAGS)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      oedit_disp_aff3_flags(d);
      return;
    } else if (number == 0)	/* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_SPELL3(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_aff3_flags(d);
      return;
    }
    
d1785 3
@


1.15
log
@Split "oedit revex" into "oedit zrevex" for an entire zone and
"oedit revex" for a single object.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.14 2007/07/18 22:28:47 jps Exp jps $
d1382 1
a1382 1
        send_to_char("You cannot purge a non-existant (unsaved) objext! Choose again:\r\n",d->character);
d1793 4
@


1.14
log
@Added syntax "oedit revex <zone>" to reverse extra descs that may
have ended up reversed due to the way db.c used to read them.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.13 2007/07/18 01:21:34 jps Exp jps $
d56 1
d84 1
d574 29
a605 2
   struct obj_data *obj;
   struct extra_descr_data *ex_desc, *tmp;
d609 2
a610 16
      if ((realcounter = real_object(counter)) >= 0 && (obj = (obj_proto + realcounter))) {
         /* Only attempts to reverse exdesc lists of two or more elements. */
         if ((ex_desc = obj->ex_description) && ex_desc->next) {
            for (obj->ex_description = NULL; ex_desc;) {
               tmp = ex_desc->next;
               ex_desc->next = obj->ex_description;
               obj->ex_description = ex_desc;
               ex_desc = tmp;
            }
            nummodified++;
            if (ch) {
               sprintf(buf, "Reversed exdescs of object %d, %s.\r\n",
                     GET_OBJ_VNUM(obj), obj->short_description);
               send_to_char(buf, ch);
            }
         }
d615 1
d618 1
d1793 4
@


1.13
log
@You can edit AFF2/AFF3 flags with oedit.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.12 2007/07/15 21:16:12 myc Exp jps $
d82 1
d570 40
d1776 3
@


1.12
log
@No more crash when you edit a script on a new object or room.
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.11 2002/09/13 02:32:10 jjl Exp myc $
d689 46
d1074 2
d1120 1
a1120 1
          "%sC%s) Level       : %s%d\r\n"
d1122 2
a1123 9
	  "%sE%s) Applies menu\r\n"
	  "%sF%s) Extra descriptions menu\r\n"
	  "%sG%s) Spell affects menu\r\n"
	  "%sH%s) Spell Components Menu\r\n"
	  "%sI%s) Object Limitation Value : %s%d\r\n"
	  "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",
	  
d1134 19
a1152 2
	  grn, nrm, grn, nrm, 
	  grn, nrm, 
d1155 3
d1297 2
a1298 2
      oedit_disp_prompt_spell_apply_menu(d);
      OLC_MODE(d) = OEDIT_SPELL_APPLY;
d1302 2
a1303 2
      OLC_MODE(d) = OEDIT_SPELL_COMPONENT;
      oedit_disp_component(d);	
d1307 12
a1318 2
      OLC_MODE(d) = OEDIT_LIMITATION;
      send_to_char("Please enter number of Items allowed(0 for infinate)>", d->character);
d1598 26
d1735 3
@


1.11
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: oedit.c,v 1.10 2002/07/14 03:41:18 rls Exp $
d96 1
d1638 3
@


1.10
log
@removed purge functionality from menu
@
text
@d1 3
a3 1
// $Id: oedit.c,v 1.9 2001/07/08 16:01:22 mtp Exp $
d690 1
a690 1
  // int counter;
d1635 36
a1670 31
// $Log: oedit.c,v $
// Revision 1.9  2001/07/08 16:01:22  mtp
// added safety check for purge of level LVL_HEAD_B (currently 103)
//
// Revision 1.7  2001/03/24 05:12:01  dce
// Objects will now accept a level through olc and upon
// booting the objects. The level code for the players will
// follow.
//
// Revision 1.6  2000/11/24 19:24:58  rsd
// Altered comment header and added back rlog messages from
// prior to the addition of the $log$ string.
//
// Revision 1.5  2000/10/14 11:12:40  mtp
// fixed the olc triggers editting in medit/oedit/redit
//
// Revision 1.4  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.3  1999/07/22 17:43:59  jimmy
// removed the #define NUM_SPELLS that was wrong and used MAX_SPELLS instead.
// Now all spells are available to assign to scrolls, objs etc.  Not
// just 71.  This was done to reimplement the IDENTIFY scroll.
// --gurlaek
//
// Revision 1.2  1999/01/31 22:05:32  mud
// Indented file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.9
log
@added safety check for purge of level LVL_HEAD_B (currently 103)
@
text
@d1 1
a1 1
// $Id: oedit.c,v 1.7 2001/03/24 05:12:01 dce Exp $
d1077 1
a1077 1
	  "%s%sQ%s) Quit\r\n"
d1096 1
a1096 3
	  (((GET_LEVEL(d->character)<LVL_HEAD_B) || (GET_OBJ_RNUM(obj) == -1))?"":"&1&bP&0) &1&bPURGE&0\r\n"),
	  grn, nrm
	  );
d1634 3
@


1.8
log
@added purge which deletes from world and file
@
text
@d1096 1
a1096 1
	  ((GET_OBJ_RNUM(obj) == -1)?"":"&1&bP&0) &1&bPURGE&0\r\n"),
d1253 5
@


1.7
log
@Objects will now accept a level through olc and upon
booting the objects. The level code for the players will
follow.
@
text
@d1 1
a1 1
// $Id: oedit.c,v 1.6 2000/11/24 19:24:58 rsd Exp $
d173 104
d323 1
d1077 1
a1077 1
	  "%sQ%s) Quit\r\n"
d1096 1
d1248 14
d1594 23
d1631 5
@


1.6
log
@Altered comment header and added back rlog messages from
prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: oedit.c,v 1.5 2000/10/14 11:12:40 mtp Exp $
d365 1
a365 1
		"%d %d %d\n"
d377 1
d392 1
a392 1
		"%d %d %d\n"
d404 1
d964 7
a970 6
	  "%sC%s) Values      : %s%d %d %d %d\r\n"
	  "%sD%s) Applies menu\r\n"
	  "%sE%s) Extra descriptions menu\r\n"
	  "%sF%s) Spell affects menu\r\n"
	  "%sG%s) Spell Components Menu\r\n"
	  "%sH%s) Object Limitation Value : %s%d\r\n"
d980 1
d1097 5
d1111 2
a1112 2
    case 'd':
    case 'D':
d1115 2
a1116 2
    case 'e':
    case 'E':
d1127 2
a1128 2
    case 'f' :
    case 'F':
d1132 2
a1133 2
    case 'g':
    case 'G':
d1137 2
a1138 2
    case 'h':
    case 'H':
d1246 5
d1488 4
@


1.5
log
@fixed the olc triggers editting in medit/oedit/redit
@
text
@d1 15
a15 9
// $Id: oedit.c,v 1.4 1999/09/05 07:00:39 jimmy Exp $
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
 *    				                                          *
 *  OasisOLC - oedit.c 		                                          *
 *    				                                          *
 *  Copyright 1996 Harvey Gilpin.                                          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*. Original author: Levork .*/
a1472 1

d1474 3
d1479 12
@


1.4
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d1130 2
d1468 4
a1471 1
// $Log$
@


1.3
log
@removed the #define NUM_SPELLS that was wrong and used MAX_SPELLS instead.
Now all spells are available to assign to scrolls, objs etc.  Not
just 71.  This was done to reimplement the IDENTIFY scroll.
--gurlaek
@
text
@d1 1
d1466 1
@


1.2
log
@Indented file
@
text
@d654 7
a660 4
  for (counter = 0; counter < NUM_SPELLS; counter++) {
    sprintf(buf, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
	    spells[counter], !(++columns % 3) ? "\r\n" : "");
    send_to_char(buf, d->character);
d1245 2
a1246 1
      if (number < 0 || number >= NUM_SPELLS)
d1283 1
a1283 1
      max_val = NUM_SPELLS - 1;
d1312 1
a1312 1
      max_val = NUM_SPELLS - 1;
d1317 1
a1317 1
      max_val = NUM_SPELLS - 1;
@


1.1
log
@Initial revision
@
text
@d2 5
a6 5
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - oedit.c 		                                          *
*    				                                          *
*  Copyright 1996 Harvey Gilpin.                                          *
d97 1
a97 1

d102 1
a102 1

d105 1
a105 1
 
d112 1
a112 1
		obj_proto[real_num].short_description : "undefined");
d114 1
a114 1
		obj_proto[real_num].description : "undefined");
d116 2
a117 2
		str_dup(obj_proto[real_num].action_description) : NULL);

d123 1
a123 1

d125 1
a125 1
     for (this = obj_proto[real_num].ex_description; this; this = this->next) {
d128 1
a128 1
		str_dup(this->description) : NULL;
d137 1
a137 1

d141 1
a141 1

d160 1
a160 1

d174 1
a174 1
    *swap = *obj;
d193 1
a193 1
    free(obj_proto[robj_num].name);
d201 1
a201 1
     for (this = obj_proto[robj_num].ex_description; this; this = next_one) {
d211 1
a211 1
	obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
d214 1
a214 1

d221 1
a221 1
    /*
d243 1
a243 1
    }
d258 1
a258 1
	  new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
d261 1
a261 1

d268 1
a268 1

d273 3
a275 3

	  

d297 1
a297 1

d302 1
a302 1

d308 5
a312 5
		
	


/*and those being edited     */
d318 1
a318 1

d332 1
a332 1

d336 1
a336 1
TRUE);
a349 55

	  if (GET_OBJ_TYPE(obj) == 24){
          fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d\n"
	      "%d %d %d %d %d %ld %d\n"
	      "%d %d %d %d %d %d %d %d\n",

	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ?
			obj->short_description : "undefined",
	      (obj->description && *obj->description) ?
			obj->description : "undefined",
	      buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
GET_OBJ_WEAR(obj),
	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
2),
	      GET_OBJ_VAL(obj, 3),  obj->spare1, obj->spare2, obj->spare3,
		  GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
	      GET_OBJ_TIMER(obj), GET_OBJ_SPELL(obj), 
		  GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
          obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
		  );}
	  else {
          fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d\n"
	      "%d %d %d %d %d %ld %d\n"
	      "%d %d %d %d %d %d %d %d\n",

	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ?
			obj->short_description : "undefined",
	      (obj->description && *obj->description) ?
			obj->description : "undefined",
	      buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj),
GET_OBJ_WEAR(obj),
	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj,
2),
	      GET_OBJ_VAL(obj, 3), obj->spare1, obj->spare2, obj->spare3,
		  GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
	      GET_OBJ_RENT(obj), GET_OBJ_SPELL(obj),
		  GET_OBJ_COMPONENT(obj), GET_OBJ_LIMITATION(obj),
          obj->obj_flags.spell_flags2, obj->obj_flags.spell_flags3
		  );}
d351 55
a405 1
	  script_save_to_disk(fp, obj, OBJ_TRIGGER);
d407 1
a407 1
	  /*
d412 1
a412 1
ex_desc->next) {
d418 1
a418 1
BRF, LVL_BUILDER, TRUE);
d428 1
a428 1

d437 1
a437 1

d447 1
a447 1

d454 1
a454 1
 Menu functions 
d463 1
a463 1
  #if defined(CLEAR_SCREEN)
d465 1
a465 1
  #endif
d485 1
a485 1
  #if defined(CLEAR_SCREEN)
d487 1
a487 1
  #endif
d507 1
a507 1

d509 1
a509 1
  #if defined(CLEAR_SCREEN)
d511 1
a511 1
  #endif
d519 1
a519 1

d533 1
a533 1

d535 1
a535 1
  #if defined(CLEAR_SCREEN)
d537 1
a537 1
  #endif
d556 1
a556 1

d558 1
a558 1
  #if defined(CLEAR_SCREEN)
d560 1
a560 1
  #endif
d562 2
a563 2
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		affected_bits[counter], !(++columns % 2) ? "\r\n" : "");
d567 1
a567 1
    sprintf(buf, "\r\nSpell flags: %s%s%s\r\n"
d574 2
a575 2
 // int counter;

d586 2
a587 2
 int counter, columns = 0;

d589 1
a589 1
  #if defined(CLEAR_SCREEN)
d591 1
a591 1
  #endif
d608 1
a608 1

d610 1
a610 1
  #if defined(CLEAR_SCREEN)
d612 1
a612 1
  #endif
d615 1
a615 1
		apply_types[counter], !(++columns % 2) ? "\r\n" : "");
d629 1
a629 1

d631 1
a631 1
  #if defined(CLEAR_SCREEN)
d633 1
a633 1
  #endif
d636 2
a637 2
		attack_hit_text[counter].singular,
		!(++columns % 2) ? "\r\n" : "");
d649 1
a649 1

d651 1
a651 1
  #if defined(CLEAR_SCREEN)
d653 1
a653 1
  #endif
d656 1
a656 1
	spells[counter], !(++columns % 3) ? "\r\n" : "");
d697 2
a698 2
 

d704 2
a705 2
  
	  break;
d707 2
a708 2
	  send_to_char("Room to go to : ", d->character);
	  break;
d710 2
a711 2
	oedit_disp_wall_block_dirs(d);
        break;
d747 1
a747 1
   case ITEM_MONEY:
d751 2
a752 2
	  send_to_char("Entry Msg.(To Room) : ", d->character);
	  break;
d789 1
a789 1
    case ITEM_MONEY:
d792 3
a794 3
case ITEM_PORTAL:
	  send_to_char("Entry Msg.(To Char) : ", d->character);
	  break;
d824 2
a825 2
  
	  case ITEM_MONEY:
d829 4
a832 4
	  send_to_char("Exit Msg.(To Room) : ", d->character);
	  break;


d844 1
a844 1

d846 1
a846 1
  #if defined(CLEAR_SCREEN)
d848 1
a848 1
  #endif
d851 1
a851 1
		item_types[counter], !(++columns % 2) ? "\r\n" : "");
d863 1
a863 1

d865 1
a865 1
  #if defined(CLEAR_SCREEN)
d867 1
a867 1
  #endif
d870 1
a870 1
		extra_bits[counter], !(++columns % 2) ? "\r\n" : "");
d886 1
a886 1

d888 1
a888 1
  #if defined(CLEAR_SCREEN)
d890 1
a890 1
  #endif
d892 2
a893 2
        sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		wear_bits[counter], !(++columns % 2) ? "\r\n" : "");
d897 1
a897 1
    sprintf(buf, "\r\nWear flags: %s%s%s\r\n"
d908 1
a908 1

d911 1
a911 1

d915 1
a915 1

d930 1
a930 1

d943 1
a943 1

d961 1
a961 1

d977 1
a977 1
      grn, nrm
d984 1
a984 1
 main loop (of sorts).. basically interpreter throws all input to here
d991 1
a991 1

d993 1
a993 1

d1014 1
a1014 1

d1040 1
a1040 1
       SEND_TO_Q("Enter action description: (/s saves /h for help)\r\n\r\n", d);
d1108 1
a1108 1
	      case 'f' :
d1113 10
a1122 10
	case 'g':
	case 'G':
	  OLC_MODE(d) = OEDIT_SPELL_COMPONENT;
	  oedit_disp_component(d);	
	  break;
	case 'h':
	case 'H':
		OLC_MODE(d) = OEDIT_LIMITATION;
		send_to_char("Please enter number of Items allowed(0 for infinate)>", d->character);
		break;
d1128 2
a1129 2


d1135 2
a1136 2

	
d1145 1
a1145 1

d1151 1
a1151 1

d1157 1
a1157 1

d1163 1
a1163 1
       } else
d1167 1
a1167 1
	break;
d1169 11
a1179 11
	  number = atoi(arg);
	  if (number < 0)
	  {
		  send_to_char("Please choose 0 for infinate or a positive number>", d->character);
		  return;
	  }
	  else
	  {
		  GET_OBJ_LIMITATION(OLC_OBJ(d)) = number;
	  }
	  break;
d1191 1
a1191 1
   
d1193 1
a1193 1

d1207 1
a1207 1

d1211 1
a1211 1

d1216 1
a1216 1

d1220 1
a1220 1

d1224 1
a1224 1

d1247 1
a1247 1
	}
d1263 1
a1263 1

d1269 1
a1269 1

d1301 1
a1301 1

d1326 1
a1326 1

d1330 1
a1330 1
     else if (number < 0 || number > MAX_OBJ_AFFECT) {
d1338 1
a1338 1

d1340 5
a1344 5
      if (atoi(arg) == 8) {
		  send_to_char("I don't think so\r\n", d->character);
		  return;
	  }
	  if ((number = atoi(arg)) == 0) {
d1356 1
a1356 1

d1365 1
a1365 1
	oedit_disp_prompt_spell_apply_menu(d);
d1371 1
a1371 1
	  oedit_disp_prompt_spell_apply_menu(d);
d1374 1
a1374 1

d1381 1
a1381 1

d1385 1
a1385 1
       if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
d1387 1
a1387 1

d1392 1
a1392 1

d1403 1
a1403 1
		 free(OLC_DESC(d));
d1406 1
a1406 1

d1411 1
a1411 1

d1414 1
a1414 1
	SEND_TO_Q("Enter the extra description: (/s saves /h for help)\r\n\r\n", d);
d1425 1
a1425 1

d1436 1
a1436 1

d1449 1
a1449 1
	send_to_char("Oops...\r\n", d->character);
d1452 1
a1452 1

d1459 2
@
