head	1.75;
access;
symbols;
locks; strict;
comment	@ * @;


1.75
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.14.18.11.10;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.09.03.45.17;	author jps;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.25.00.20.33;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.27.05.13.43;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.12.03.12.43;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.11.05.42.14;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2008.05.09.22.05.33;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.13.22.26.41;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.16.07.01.50;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.10.18.35.17;	author myc;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.27.21.14.59;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.26.12.31.19;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.09.04.15.27;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.05.05.38.16;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.01.04.33.08;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.28.23.34.59;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.19.20.56.05;	author myc;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.20.19.01.18;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.13.20.15.09;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.21.18.07.32;	author jps;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.02.22.31.57;	author jps;	state Exp;
branches;
next	1.38;

1.38
date	2007.08.07.01.30.45;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.31.23.44.36;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.31.16.54.05;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.11.20.12.33;	author myc;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.15.08.30.49;	author jps;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.15.06.49.19;	author jps;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.15.05.15.07;	author jps;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.15.05.11.23;	author jps;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.18.06.57.24;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.08.09.16.04;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.07.09.32.46;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.25.02.33.15;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.22.22.40.15;	author rsd;	state Exp;
branches;
next	1.24;

1.24
date	99.11.28.23.56.19;	author cso;	state Exp;
branches;
next	1.23;

1.23
date	99.10.04.21.27.28;	author rsd;	state Exp;
branches;
next	1.22;

1.22
date	99.09.10.01.40.10;	author mtp;	state Exp;
branches;
next	1.21;

1.21
date	99.09.10.00.45.28;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	99.09.10.00.31.41;	author mtp;	state Exp;
branches;
next	1.19;

1.19
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.18;

1.18
date	99.07.20.19.45.51;	author jimmy;	state Exp;
branches;
next	1.17;

1.17
date	99.04.24.06.46.52;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.04.16.05.49.17;	author jimmy;	state Exp;
branches;
next	1.15;

1.15
date	99.04.07.18.14.32;	author jen;	state Exp;
branches;
next	1.14;

1.14
date	99.04.07.16.57.41;	author jen;	state Exp;
branches;
next	1.13;

1.13
date	99.04.07.15.38.11;	author jen;	state Exp;
branches;
next	1.12;

1.12
date	99.03.31.21.32.15;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.03.24.23.43.16;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.03.03.20.11.02;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.03.01.05.31.34;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.02.16.08.53.46;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.02.12.15.33.17;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.11.22.17.40;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.11.19.21.33;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.03.20.54.47;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.03.18.11.43;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.19.15.20;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.32;	author mud;	state Exp;
branches;
next	;


desc
@/*********************************************************************
* File: spell_mem.c                             Part of xx MUD
* Usage: This file contains all of the code for spell_memorization.
*
* Last Modified: 10-4-98
*********************************************************************/
#include "mudmath.h"
#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "spells.h"
#include "handler.h"
#include "comm.h"
#include "db.h"

/* macros */
/*#define GET_CIRCLE(s) (spell_info[(s)].min_circle[(int)GET_CLASS(ch)])*/
#define GET_MEMMED_CIRCLE(s) ch->spells_memmed_circle[GET_CIRCLE(s)]
#define GET_MEMMED(c) ch->spells_memmed_circle[c]
#define CIRCLE_ABBR(s) circle_abbrev[GET_CIRCLE(s)]
#define MEMORIZE	0
#define PRAY		1

/* for the new add_spell */
#define ADD_NEW         0
#define RESTORE_CHAR    1

/* global data */
extern struct spell_info_type spell_info[];
extern struct room_data *world;

/* ------extern functions------ */
extern char *skill_name(int num);
extern char *circle_abbrev[NUM_SPELL_CIRCLES +1];
extern int find_skill_num(char *name);
void improve_skill(struct char_data *ch, int skill);

/* --------function prototypes ---------*/
ACMD(do_meditate);
ACMD(do_pray);
ACMD(do_action);
ACMD(do_scribe);

void show_spell_list(struct char_data *ch, int args);
int get_num_memmed(struct char_data *ch, struct mem_list *this);
int SpellList(struct char_data *ch, char memmed[], char to_mem[]);
void list_spell_to_char(struct char_data * ch, char memmed[]);
int add_spell(struct char_data *ch, int spell, int mode, int is_memmed, int add_type);
int rem_spell(struct char_data *ch, int spell);
int check_spell_memory(struct char_data *ch, int spellnum);
void charge_mem(struct char_data *ch, int spellnum);
void update_spell_mem(void);
void add_mem_list(struct char_data *ch);
void rem_memming(struct char_data *ch);
int set_mem_time(struct char_data *ch, int spell);
void save_mem_list(struct char_data *ch);
int restore_spells(struct char_data *ch, int spell, int state);
void assign_mem_list(struct char_data *ch);

/* spell book stuff - Fingh 10/1/98 */
int AddSpellToBook(struct char_data *ch, struct obj_data *book, int spell);
int FindSpellInBook(struct obj_data *book, int spell);
int ListSpellsInBook(struct obj_data *book, int *spell_array);
int GetBookAtHand(struct char_data *ch, int spell);
/* only returns first book found */
struct obj_data *GetBook(struct char_data *ch);
int FindTeacher(struct char_data *ch, int spell);
int GetBookScribe(struct char_data *ch, int spell);

/* ------ global data ------ */
struct char_data *memming = 0; /* head of memming characters linked list */

/* spell circle abbreviations
const char *circle_abbrev[NUM_SPELL_CIRCLES +1] = {
	"!UNUSED!",
	" 1st",
	" 2nd",
	" 3rd",
	" 4th",
	" 5th",
	" 6th",
	" 7th",
	" 8th",
	" 9th",
	"10th"
};*/

/*---- spell table -------
* This table describes how many spells a caster can memorize from a
* specific CIRCLE at each level. This is class Independent. Class
* dependencies can be controlled using spell_level() calls in class.c
* IF YOU CHANGE THIS ARRAY, YOU MUST CHANGE STRUCTS.H MAX_CHAR_SPELLS
* to the new value...*/

int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)]={
/* level 0 and circle 0 are NOT USED!!! */
/* 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14<-SPELL CIRCLE */

  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 0 */
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 1 */
  {0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 2 */
  {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 3 */
  {0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 4 */
  {0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 5 */
  {0, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 6 */
  {0, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 7 */
  {0, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 8 */
  {0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 9 */
  {0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 10*/
  {0, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 11*/
  {0, 5, 5, 2, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 12*/
  {0, 5, 5, 3, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 13*/
  {0, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 14*/
  {0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 15*/
  {0, 6, 5, 5, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 16*/
  {0, 6, 5, 5, 2, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 17*/
  {0, 6, 5, 5, 3, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 18*/
  {0, 6, 5, 5, 4, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 19*/
  {0, 6, 5, 5, 5, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 20*/
  {0, 6, 6, 5, 5, 1, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 21*/
  {0, 6, 6, 5, 5, 2, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 22*/
  {0, 6, 6, 5, 5, 3, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 23*/
  {0, 6, 6, 5, 5, 4, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 24*/
  {0, 6, 6, 5, 5, 5, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 25*/
  {0, 7, 6, 6, 5, 5, 1, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 26*/
  {0, 7, 6, 6, 5, 5, 2, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 27*/
  {0, 7, 6, 6, 5, 5, 3, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 28*/
  {0, 7, 6, 6, 5, 5, 4, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 29*/
  {0, 7, 6, 6, 5, 5, 5, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 30*/
  {0, 7, 7, 6, 6, 5, 5, 1, 0, 0, 0,  0,  0,  0,  0},  /* level 31*/
  {0, 7, 7, 6, 6, 5, 5, 2, 0, 0, 0,  0,  0,  0,  0},  /* level 32*/
  {0, 7, 7, 6, 6, 5, 5, 3, 0, 0, 0,  0,  0,  0,  0},  /* level 33*/
  {0, 7, 7, 6, 6, 5, 5, 4, 0, 0, 0,  0,  0,  0,  0},  /* level 34*/
  {0, 7, 7, 6, 6, 5, 5, 5, 0, 0, 0,  0,  0,  0,  0},  /* level 35*/
  {0, 8, 7, 7, 6, 6, 5, 5, 1, 0, 0,  0,  0,  0,  0},  /* level 36*/
  {0, 8, 7, 7, 6, 6, 5, 5, 2, 0, 0,  0,  0,  0,  0},  /* level 37*/
  {0, 8, 7, 7, 6, 6, 5, 5, 3, 0, 0,  0,  0,  0,  0},  /* level 38*/
  {0, 8, 7, 7, 6, 6, 5, 5, 4, 0, 0,  0,  0,  0,  0},  /* level 39*/
  {0, 8, 8, 7, 7, 6, 5, 5, 4, 0, 0,  0,  0,  0,  0},  /* level 40*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 1, 0,  0,  0,  0,  0},  /* level 41*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 2, 0,  0,  0,  0,  0},  /* level 42*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 3, 0,  0,  0,  0,  0},  /* level 43*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 4, 0,  0,  0,  0,  0},  /* level 44*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 5, 0,  0,  0,  0,  0},  /* level 45*/
  {0, 9, 8, 8, 7, 6, 6, 6, 5, 5, 1,  0,  0,  0,  0},  /* level 46*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 2,  0,  0,  0,  0},  /* level 47*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 3,  0,  0,  0,  0},  /* level 48*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4,  0,  0,  0,  0},  /* level 49*/
  {0, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5,  0,  0,  0,  0},  /* level 50 PATTERN CHANGES!*/
  {0, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5,  1,  0,  0,  0},  /* level 51*/
  {0, 10, 9, 9, 9, 8, 7, 7, 6, 6, 5,  2,  0,  0,  0},  /* level 52*/
  {0, 10, 10, 10, 9, 9, 8, 8, 7, 6, 6,  3,  0,  0,  0},  /* level 53*/
  {0, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6,  4,  0,  0,  0},  /* level 54*/
  {0, 10, 10, 10, 9, 9, 9, 8, 7, 7, 6,  5,  0,  0,  0},  /* level 55*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7,  5,  1,  0,  0},  /* level 56*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 8, 7,  5,  2,  0,  0},  /* level 57*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8,  5,  3,  0,  0},  /* level 58*/
  {0, 10, 10, 10, 10, 10, 10, 10, 9, 8, 8,  6,  4,  0,  0},  /* level 59*/
  {0, 11, 11, 11, 11, 10, 10, 10, 9, 9, 8,  6,  5,  0,  0},   /* level 60*/
  {0, 11, 11, 11, 11, 11, 10, 10, 9, 9, 8,  6,  5,  1,  0},   /* level 61*/
  {0, 11, 11, 11, 11, 11, 11, 10, 9, 9, 8,  6,  5,  2,  0},   /* level 62*/
  {0, 11, 11, 11, 11, 11, 11, 11, 9, 9, 8,  7,  5,  3,  0},   /* level 63*/
  {0, 11, 11, 11, 11, 11, 11, 11, 10, 9, 8,  7,  6,  4,  0},   /* level 64*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 9, 8,  7,  6,  5,  0},   /* level 65*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 10, 8,  7,  6,  5,  0},   /* level 66*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 10, 9,  8,  6,  5,  1},   /* level 67*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 9,  8,  7,  5,  2},   /* level 68*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10,  8,  7,  6,  3},   /* level 69*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4}   /* level 70*/
 /* {0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  9,  8,  7,  5}    level 71  = skipped 39 before */
}; /* 11+11+11+11+11+11+10+10+10 = 149 = max_char_spells  */
   /* corrected lvl 39 missing. new max_char_spells = 135 */

int check_mem_mode(struct char_data *ch)
{
   switch (GET_CLASS(ch)) {
      case CLASS_MAGIC_USER:
      case CLASS_CRYOMANCER:
      case CLASS_PYROMANCER:
      case CLASS_NECROMANCER:
      case CLASS_CONJURER:
      case CLASS_RANGER:
      case CLASS_BARD:
        return MEMORIZE;
      case CLASS_CLERIC:
      case CLASS_DIABOLIST:
      case CLASS_DRUID:
      case CLASS_PRIEST:
      case CLASS_PALADIN:
      case CLASS_ANTI_PALADIN:
        return PRAY;
      default:
	return -1;
   }
}

/* do_memorize can be called with or without arguments, causing a spell
to be added to the list, or just display the current list, respectively. */
ACMD(do_memorize)
{
   int spell;

   if(!ch || IS_NPC(ch))
      return;
   if(check_mem_mode(ch) != MEMORIZE) {
      send_to_char("You do not study sorcery.", ch);;
      return;
   }
   if(GET_LEVEL(ch) >= LVL_IMMORT)
   {
       send_to_char("You don't need to memorize spells to cast them.\r\n", ch);
       return;
   }
   skip_spaces(&argument);

   /* if no arg, show the current spell list */
   if(!*argument)
   {
      show_spell_list(ch, FALSE);
   }

   /* check the char's position */
   else if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
      send_to_char("You are not comfortable enough to study.\r\n", ch);

   /* for the spell name, find the spell num, and add it to the mem list. */
   else
   {
      spell = find_skill_num(argument);
      if((spell < 0) || (spell > MAX_SKILLS))
      {
         send_to_char("Memorize What?!\r\n", ch);
         return;
      }

      if((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])
      {
          send_to_char("That spell is beyond your knowledge.\r\n", ch);
          return;
      }

      if(GET_SKILL(ch, spell) == 0)
      {
         send_to_char("You don't know that spell.\r\n", ch);
         return;
      }

      /* check number of spells already memmed against the spell_table */
      if(spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell))
      {
         sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
         send_to_char(buf, ch);
         return;
      }

      /* finally, the spell is available...add it to the list */
      else
      {
         ch->num_spells += add_spell(ch, spell, MEMORIZE, 0, ADD_NEW);
         if(!ch->mem_status)
         {
            /* get the char started memming his list.. */
            add_mem_list(ch);
	    if(!(ch->mem_status))
	      act("$n takes out $s books and begins to study.",TRUE,ch,0,0,TO_ROOM);
            ch->mem_status = 1;
         }
      }
   }
}


ACMD(do_pray)
{
  int spell;

   if(!ch || IS_NPC(ch))
      return;
   if(check_mem_mode(ch) != PRAY) {
      do_action(ch, argument, cmd, subcmd);
      return;
   }

   if(GET_LEVEL(ch) >= LVL_IMMORT)
   {
       send_to_char("You don't need to pray for spells to cast them.\r\n", ch);
       return;
   }
   skip_spaces(&argument);

   /* if no arg, show the current spell list */
   if(!*argument)
   {
      show_spell_list(ch, FALSE);
   }

   /* check the char's position */
   else if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
      send_to_char("You are not comfortable enough to pray to your diety.\r\n", ch);

   /* for the spell name, find the spell num, and add it to the mem list. */
   else
   {
      spell = find_skill_num(argument);
      if((spell < 0) || (spell > MAX_SKILLS))
      {
         send_to_char("Pray for What?!\r\n", ch);
         return;
      }

      if((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])
      {
          send_to_char("That spell is beyond your knowledge.\r\n", ch);
          return;
      }

      if(GET_SKILL(ch, spell) == 0)
      {
         send_to_char("You have heard of that spell, but have no idea how to cast it.\r\n", ch);
         return;
      }

      /* check number of spells already memmed against the spell_table */
      if(spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell))
      {
         sprintf(buf, "You can pray for no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
         send_to_char(buf, ch);
         return;
      }

      /* finally, the spell is available...add it to the list */
      else
      {
         ch->num_spells += add_spell(ch, spell, PRAY, 0, ADD_NEW);
         if(!ch->mem_status)
         {
            /* get the char started memming his list.. */
            add_mem_list(ch);
            if(!(ch->mem_status))
	      act("$n begins praying to $s diety.",TRUE,ch,0,0,TO_ROOM);
            ch->mem_status = 1;
         }
      }
   }
}

void wipe_mem(struct char_data *ch)
{
    int counter;
    struct mem_list *cur, *next;

    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
    if(ch->mem_status) {
       send_to_char("You abort your studies.\r\n", ch);
       rem_memming(ch);
    }
    ch->num_spells = 0;
    ch->num_memmed = 0;
    for(counter=0;counter < MAX_CHAR_SPELLS;counter++){
      ch->player_specials->saved.memmed_spells[counter][0] = 0;
      ch->player_specials->saved.memmed_spells[counter][1] = 0;
    }

    cur = ch->spell_list;
    ch->spell_list = NULL;

    while(cur) {
      next = cur->next;
      free(cur);
      cur = next;
    }
    for(counter=1;counter <= NUM_SPELL_CIRCLES;counter++)
      GET_MEMMED(counter) = 0;
    save_char(ch, NOWHERE);
    send_to_char("You purge all spells from your mind.\r\n",ch);
}

ACMD(do_forget)
{
   int spell;
   char buf[128];
   skip_spaces(&argument);

   if(!ch || IS_NPC(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
     send_to_char("You have no need to forget spells.\r\n",ch);
     return;
   }

   if(!argument)
   {
      send_to_char("Are you trying to forget something in particular?\r\n", ch);
      return;
   }

   if(is_abbrev(argument, "all")){
     wipe_mem(ch);
     return;
   }

   spell = find_skill_num(argument);

   if((spell < 0) || (spell > MAX_SKILLS))
   {
      send_to_char("Forget What?!\r\n", ch);
      return;
   }
   else
   {
       if(rem_spell(ch, spell))
       {
          sprintf(buf, "You purge %s from your memory.\r\n", skill_name(spell));
          send_to_char(buf, ch);
       }
       else
       {
          sprintf(buf, "You do not have that spell memorized!\r\n");
          send_to_char(buf, ch);
       }
   }
}

/* set the meditate flag */
ACMD(do_meditate)
{
  if(GET_POS(ch) > POS_SITTING){
  send_to_char("Try resting first....\r\n", ch);
    return;
    }
	SET_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
	send_to_char("You begin to meditate.\r\n", ch);
        WAIT_STATE(ch, PULSE_VIOLENCE * 2);
        improve_skill(ch, SKILL_MEDITATE);
}

/* add a spell to the char's mem_list */
int add_spell(struct char_data *ch, int spell, int mode, int is_memmed, int add_type)
{
   struct mem_list *cur, *prev;
   char buf[128];

   /* see if ch can even use that circle of spell.... */
   if(!spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)])
   {
      if(add_type == ADD_NEW)
      {
        sprintf(buf, "You can't use spells from Circle %d yet.\r\n", GET_CIRCLE(spell));
        send_to_char(buf, ch);
      }
      return 0;
   }
   /* initialize the ptr and check it before proceeding */
   if(((ch->num_spells == 0) && (add_type == ADD_NEW)) || ((ch->spell_list == 0) && (add_type == RESTORE_CHAR)))
   {
    if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
           return 0;
       ch->spell_list->next = 0;
       cur = ch->spell_list;
   }else
   {

 // iterate the list to add new spell at the END...SLOW and UGLY!!!
      for(cur = ch->spell_list; cur ; cur = cur->next)
      {
        if(cur->next == 0)
        {
          prev = cur;
          if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
            return 0;

          prev->next = cur;
          cur->next = 0;
          break;
        }
      }

   }

   cur->spell = spell;
   cur->can_cast = is_memmed;
   cur->mem_time = set_mem_time(ch, cur->spell);

   if(add_type == RESTORE_CHAR)
   {
     GET_MEMMED_CIRCLE(spell)++;
     return 1;
   }
   if(mode == MEMORIZE)
      sprintf(buf, "You begin memorizing %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time);
   else if(mode == PRAY)
      sprintf(buf, "You begin praying for %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time);
   send_to_char(buf, ch);
   GET_MEMMED_CIRCLE(spell)++;

   /* increment the players num_spells */
   return 1;
}


/* remove a spell from the characters memorize list */
int rem_spell(struct char_data *ch, int spell)
{
   struct mem_list *temp, *cur;
   cur = temp = ch->spell_list;
   while(cur)
   {
      if(cur->spell == spell)
      {
         if(cur == ch->spell_list)
         {
	         ch->spell_list = ch->spell_list->next;
             ch->num_spells -= 1;
             if(cur->can_cast)
                ch->num_memmed -= 1;

             free(cur);
             GET_MEMMED_CIRCLE(spell)--;
             return 1;
         }
         else
         {
             /* remove the spell, free the memory, and return found */
             temp->next = cur->next;
             ch->num_spells -= 1;
             if(cur->can_cast)
                ch->num_memmed -= 1;
             free(cur);
             GET_MEMMED_CIRCLE(spell)--;
             return 1;
         }
      }
      else
      {
         temp = cur;
         cur = cur->next;
      }
   }
   return 0;
 }


void show_spell_list(struct char_data *ch, int args)
{
   char memmed[MAX_STRING_LENGTH];
   char to_mem[MAX_STRING_LENGTH];
   char buf[256];
   char remaining[256];
   char string[256];
   int circle;			/* check spell circle */
   int avail;           /* how many more spells in this circle? */
   if(SpellList(ch, memmed, to_mem))
   {
      if((GET_POS(ch) == POS_SITTING) || (GET_POS(ch) == POS_RESTING))
      {
         if(ch->mem_status)
         {
            if(check_mem_mode(ch) == MEMORIZE)
              strcat(to_mem, "\r\nYou continue your studies.\r\n");
            if(check_mem_mode(ch) == PRAY)
              strcat(to_mem, "\r\nYou continue to pray.\r\n");

         }
         else
         {
            /* add the player to the memming list so spells can be updated */
            add_mem_list(ch);
            ch->mem_status = 1;
            strcat(to_mem, "\r\nYou continue your studies.\r\n");
         }
      }
      strcat(to_mem, "\0");
      send_to_char(to_mem, ch);
   }

   memset(string , 0x0, 256);
   memset(remaining , 0x0, 256);
   memset(buf , 0x0, 256);

   /* display all remaining available spell slots for each circle*/
   if(check_mem_mode(ch) == MEMORIZE)
      sprintf(remaining, "\r\nYou can memorize");
   if(check_mem_mode(ch) == PRAY)
      sprintf(remaining, "\r\nYou can pray for");
   for(circle = 1; circle <= NUM_SPELL_CIRCLES; circle++)
   {
	  avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_MEMMED(circle);
	  if(avail == 0)
		  continue;
	  sprintf(buf, " (%d)%d", avail, circle);
	  strcat(string, buf);

	  switch(circle)
	  {
	    case 1:
		  strcat(string, "st");
		  break;
	    case 2:
		  strcat(string, "nd");
		  break;
	    case 3:
		  strcat(string, "rd");
		  break;
	    default:
		  strcat(string, "th");
		  break;
	  }
	}
    if(strlen(string)< 7)
      strcat(string, " no more");
    else
      strcat(string, " circle");
    strcat(string, " spell(s)\r\n\r\n");
    strcat(remaining, string);
    send_to_char(remaining, ch);
}

int check_spell_memory(struct char_data *ch, int spellnum)
{
   struct mem_list *cur;

   cur = ch->spell_list;
   /* traverse the list and find out if the spell is memmed or not. */
   while(cur)
   {
      if(cur->spell == spellnum)
         if(cur->can_cast)
            /* okay, the spell is memmed...return true */
            return 1;

       cur = cur->next;
   }
   /* couldn't find a memmed copy of that spell anywhere... */
   return 0;
}


void charge_mem(struct char_data *ch, int spellnum)
{
   struct mem_list *cur;

   cur = ch->spell_list;
   /* traverse the list to find the spell. */
   while(cur)
   {
      if(cur->spell == spellnum)
         if(cur->can_cast)
         {  /* okay, this is a valid copy of the spell */
            cur->can_cast = 0;
            ch->num_memmed--;
            return;
         }

      cur = cur->next;
   }
}


void add_mem_list(struct char_data *ch)
{
  if(memming == 0)
  {
    memming = ch;
    ch->next_memming = 0;
  }
  else
  {
    ch->next_memming =  memming;
    memming = ch;
  }
}

void update_spell_mem(void)
{
   struct char_data *ch = 0;
   struct mem_list *cur = 0;
   char buf[256];

   ch = memming;
   /* if no one is memming, don't bother */
   if(memming == 0)
      return;

   while(ch)
   {
      if(GET_COND(ch, DRUNK) > 0)
      {
         send_to_char("You cannot study while intoxicated\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

      if(GET_COND(ch, FULL) < 1)
      {
         send_to_char("You are too hungry too study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

      if(GET_COND(ch, THIRST) < 1)
      {
         send_to_char("You are too thirsty to study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

      if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
      {
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);

          return;
      }

      cur = ch->spell_list;
      while(cur)
      {
         if(cur->can_cast)
             cur = cur->next;
         else
         {
      /*     STILL awaiting fix from Fingh... 11/7/98
       *     if(check_mem_mode(ch) == MEMORIZE)
       *     {
       *       if( !GetBookAtHand(ch, cur->spell) )
       *       {
       *         send_to_char("You need a spellbook with that spell written* in it.",ch);
       *         rem_memming(ch);
       *         break;
       *       }
       *     }
       */
          /* using pulse violence, which means we only update every _2_ seconds
             please do NOT change this, unless you change in comm.c to
             pulse_violence/2
          */
             cur->mem_time -= 2;

   	     /*check meditate skill */
	     if(PLR_FLAGGED(ch, PLR_MEDITATE))
	     {
		 if(cur->mem_time <= ((int) (set_mem_time(ch, cur->spell) / 2) + 1))
		 {
	  	   if((number(1,110)) < GET_SKILL(ch, SKILL_MEDITATE))
		     cur->mem_time = 0;
		 if(number(0,20) > 15)
		   improve_skill(ch, SKILL_MEDITATE);
		 }
	     }

             if(cur->mem_time < 1)
             {
		 if(check_mem_mode(ch) == MEMORIZE)
                    sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
		 else if(check_mem_mode(ch) == PRAY)
                    sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
                 send_to_char(buf, ch);

                 /* reset so the guy has to remem after casting it.*/
                 cur->mem_time = set_mem_time(ch, cur->spell);
                 cur->can_cast = 1;
                 ch->num_memmed++;

                 if(ch->num_memmed == ch->num_spells)
                 {
		    if(check_mem_mode(ch) == MEMORIZE)
                    {
                        send_to_char("You have completed your studies.\r\n", ch);
		        act("$n closes $s book and smiles.", TRUE, ch, 0, 0, TO_ROOM);
		    }
		    else if(check_mem_mode(ch) == PRAY)
                    {
                        send_to_char("Your prayers are complete.\r\n", ch);
		        act("$n finishes praying to $s diety.", TRUE, ch, 0, 0, TO_ROOM);
		    }
                    rem_memming(ch);
		    cur = 0;
                 }
             }
             /* make sure only one spell is finished each time through...*/
             else
                 cur = 0;
         }
      }
   ch = ch->next_memming;
   }
}

/* rewritten and cleaned up by Fingh 11/15/98 to prevent mem abort
 * loops and crash bugs */
void rem_memming(struct char_data *ch)
{
   struct char_data *temp, *prev;

   for(prev = temp = memming; temp; temp = temp->next_memming)
   {
     if(temp == ch)
     {
       if(ch == memming)
       {
         memming = ch->next_memming;
         ch->next_memming = 0;
       }
       else
       {
         prev->next_memming = ch->next_memming;
         ch->next_memming = 0;
       }

       REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
       ch->mem_status = 0;
       return;
     } // temp == ch

     prev = temp;
   } // end for
}

int set_mem_time(struct char_data *ch, int spell)
{
    double mem_time; /* base time of 30 seconds */
//    int mode = check_mem_mode(ch);
//    int mem_time;
    /* Here's the happy new mem time code... if you want to make mem times,
	slower or faster, the variable base_time is the base seconds, just
	change that to tweek it - Nechtrous */

/*    exp = ((float)(2*(GET_CIRCLE(spell) -1)) + 5.5) / ((float)(GET_LEVEL(ch) / 2) + 5);
   mem_time = pow(base_time, exp);
    if(mode == PRAY)
    mod = (float)((float)GET_RWIS(ch) / 18);
    if(mode == MEMORIZE)
      mod = (float)((float)GET_RINT(ch) / 18);
    mem_time = mem_time / mod;
*/
    mem_time = 33 ;
     //modify base to reflect level experience
     mem_time -= (int)((NUM_SPELL_CIRCLES - GET_CIRCLE(spell))*2);
     mem_time -= (int)((GET_LEVEL(ch)/6) * 1.5);
     //modify for intelligence
     if(check_mem_mode(ch) == MEMORIZE)
       mem_time -= (int) (GET_INT(ch)/20);
     else
       mem_time -= (int) (GET_WIS(ch)/20);

   /* cap the mem time in case any wackiness happens   */
    if(mem_time > 40)
      mem_time = 40;
   /*  modify in case mem_time has gone below or at 0 */
    if (mem_time <= 1)
      mem_time = 2;

    return (int)mem_time;
}


void save_mem_list(struct char_data *ch)
{
    struct mem_list *cur;
    int counter = 0;

    ch->player_specials->saved.spells_in_mem = ch->num_spells;

    if(ch->num_spells > 0)
    {
       cur = ch->spell_list;

       while(counter < ch->num_spells && cur)
       {
          ch->player_specials->saved.memmed_spells[counter][0] = cur->spell;
          ch->player_specials->saved.memmed_spells[counter][1] = cur->can_cast;
          cur =  cur->next;
          counter++;
       } /* end while(cur) */
    } /* end if() */
} /* end save_mem_list() */


/* Okay, we can finally save the char's spell list on disk. */
void assign_mem_list(struct char_data *ch)
{
    int index=0;
    int new_num_spells = 0;

    if(!ch)
      return;

    ch->num_spells = ch->player_specials->saved.spells_in_mem;
    ch->spell_list = 0;

    if(ch->num_spells)
    {
       for(index = 0; index < ch->num_spells;index++)
       {
          new_num_spells += add_spell(ch, ch->player_specials->saved.memmed_spells[index][0], check_mem_mode(ch),
               ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);

          if(ch->player_specials->saved.memmed_spells[index][1])
            ch->num_memmed++;

       } /* end for() */
    } /* end if() */
    else
       ch->spell_list = 0;

//    if(new_num_spells != ch->num_spells)
//      ch->num_spells = new_num_spells;
} /* end assign_mem_list() */

int restore_spells(struct char_data *ch, int spell, int state)
{
   struct mem_list *cur;

   /* initialize the ptr and check it before proceeding */
   if(ch->num_spells == 0)
   {
       if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
           return 0;
       ch->spell_list->next = 0;
       cur = ch->spell_list;
   }else
   {
      if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
         return 0;
      cur->next = ch->spell_list;
   }

   cur->spell = spell;
   cur->can_cast = state;

   if(cur->can_cast)
      ch->num_memmed++;

   cur->mem_time = set_mem_time(ch, spell);

   GET_MEMMED_CIRCLE(spell)++;

   /* reset the head of the list */
   ch->spell_list = cur;

   /* increment the players num_spells */
   return 1;
}


int SpellList(struct char_data *ch, char *memmed, char *to_mem)
{
   struct mem_list *tmp;
   char buf[256];
   int is_memming = 0;
   int num, i, found, circle = 0;
   int list_time = 0;

   tmp = ch->spell_list;

   if(check_mem_mode(ch) == MEMORIZE){
      sprintf(memmed, "\r\nYou have memorized the following spells:\r\n\t");
      sprintf(to_mem, "\r\nYou are currently memorizing:\r\n");
   }
   if(check_mem_mode(ch) == PRAY){
      sprintf(memmed, "\r\nYou have prayed for the following spells:\r\n\t");
      sprintf(to_mem, "\r\nYou are currently praying for:\r\n");
   }
   /* sort the memmed spells  */
   for(i = 1; i < NUM_SPELL_CIRCLES; i++)
   {
	   found = 1;
	   circle++;
	   tmp =ch->spell_list;
	   while(tmp)
	   {
		  if(GET_CIRCLE(tmp->spell) == i)
		  {
			  if(tmp->can_cast)
			  {
				  num = get_num_memmed(ch, tmp);
				  if(num > 0)
				  {
					  if(found == 1)
					  {
						  sprintf(buf, "\r\n(%s %s)  ", CIRCLE_ABBR(tmp->spell), "circle");
						  strcat(memmed, buf);
					      sprintf(buf, "\t%2d - %s\r\n", num, skill_name(tmp->spell));
						  strcat(memmed, buf);

						  found--;
					  }
					  else
					  {
						  sprintf(buf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell));
						  strcat(memmed, buf);
						  strcat(memmed, "\0");
						  memset(buf, 0x0, 256);
					  }
				  }
			  }
		  }
		  tmp = tmp->next;
	   }
   }

   tmp = ch->spell_list;
   /* display the un-memmed spells */
   while(tmp)
   {
	  if(!tmp->can_cast)
      {
          sprintf(buf, "   %2d seconds: (%s) %-20s\t\t  \r\n", tmp->mem_time, CIRCLE_ABBR(tmp->spell), skill_name(tmp->spell));
          strcat(to_mem, buf);
          is_memming = 1;
          list_time += tmp->mem_time;
      }
      tmp = tmp->next;

   }

   /* if char still has spells memming, display total mem time */
   if(list_time)
   {
       sprintf(buf, "\r\n   %d seconds remaining\r\n", list_time);
       strcat(to_mem, buf);
   }

   /* char may have spells in list, but none are currently memmed */
   if(ch->num_memmed < 1)
   {
       sprintf(buf, "   None!\r\n");
       strcat(memmed, buf);
   }

   if(memmed)
      send_to_char(memmed, ch);

   return(is_memming);
}

int get_num_memmed(struct char_data *ch, struct mem_list *this)
{
	struct mem_list *list = ch->spell_list;
	int num = 0;

	while(list != this)
	{
		if(this == list)
			continue;

		if((this->spell == list->spell) &&(list->can_cast) )
			return(0);
		list = list->next;
	}

	for(list = this; list; list = list->next)
		if(( this->spell == list->spell) && (list->can_cast))
			num++;

	return(num);
}


/* spellbooks */
#define SPELLBOOK_MAX_STRING 128
#define SPELLBOOK_PAGES 100

/* used for scribing */
struct obj_data *GetBook(struct char_data *ch)
{
  struct obj_data *cur_obj;

  for(cur_obj = ch->carrying; cur_obj; cur_obj = cur_obj->next_content)
    if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)
      return cur_obj;

  return 0;  /* make sure returned pointer value is checked!!! */
}


/* used in do_memorize() */
int GetBookAtHand(struct char_data *ch, int spell)
{
  struct obj_data *cur_obj;

  for(cur_obj = ch->carrying; cur_obj; cur_obj = cur_obj->next_content)
  {
    if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)
    {
      if( FindSpellInBook(cur_obj, spell) )
        return TRUE;
      else
        continue;
    } /* end if */
  }

  return FALSE;
}


int ListSpellsInBook(struct obj_data *book, int *spell_array)
{
  struct extra_descr_data * tmp;
  int index = 0, PSE_Present = 0, sa_index = 0;
  char *parsenum;
  char *desc_ptr;

  for(tmp = book->ex_description; tmp; tmp = tmp->next)
    if( strcmp(tmp->keyword, "PSE") == 0) /* equal */
    {
      PSE_Present++;
      break;
    }

  /* you can't mem from a book that has nothing in it... */
  if(!PSE_Present)
    return FALSE;

  desc_ptr = (char *)malloc(strlen(tmp->description));
  if(desc_ptr)
    strcpy(desc_ptr, tmp->description);

  parsenum = strtok(desc_ptr, ", ");
  index = 0;

  if(parsenum)
    spell_array[sa_index] = atoi(parsenum);
    /*sscanf(parsenum, "%d", &spell_array[sa_index++]);*/
  else
  {
    free(desc_ptr);
    return FALSE;
  }

  do
  {
    parsenum = 0;
    parsenum = strtok(NULL,", ");
    if(parsenum)
      sscanf(parsenum, "%d", &spell_array[sa_index++]);
  } while(parsenum);  /* end do-while() */

  free(desc_ptr);
  return TRUE;
}


int FindSpellInBook(struct obj_data *book, int spell)
{
  int index = 0;
  int spell_array[SPELLBOOK_PAGES];  /* 100 first level spells? */

  memset(spell_array, 0x0, SPELLBOOK_PAGES);

  if( !ListSpellsInBook(book, spell_array))
  {
    mudlog("ListSpellsInBook returned false to findspellinbook", NRM, LVL_GOD, TRUE);
    return FALSE;
  }

  for(index = 0;index < SPELLBOOK_PAGES; index++)
  {
    if(spell_array[index] == spell)
      return TRUE;
  }

  /* not found... */
  return FALSE;
}

/* ugh this is horrible function, sorry. BUT, it works... suffer bitch*/
int AddSpellToBook(struct char_data *ch, struct obj_data *book, int spell)
{
  struct extra_descr_data *entry, *tmp;
  char spellnumbuf[6];   /* max spell num 9999 */
  int added = 0;
  int len, copy_len;
  char *tmp_desc, *entry_desc;
  int entry_exists = 0;

  if(FindSpellInBook(book, spell))
  {
    send_to_char("The spell is already scribed into this book.",ch);
    return TRUE;
  }

  memset(spellnumbuf, 0x0, 6);
  sprintf(spellnumbuf, "%d, ", spell); /* comma mandatory for read */

  /* PSE = Parse Spell Entry, and it ensures this ex_descr is used
   * for the spell contents string, not some builder work.
  */
  for(entry = book->ex_description; entry; entry = entry->next)
  {
    if( strcmp(entry->keyword, "PSE") == 0) /* equal */
    {
      entry_exists = 1;
      break;
    }
    else
      continue;
  } /* enf for() */

  /* process the existing PSE entry */
  if(entry_exists)
  {
      len = strlen(entry->description) + strlen(spellnumbuf) +1;
      if(len > SPELLBOOK_MAX_STRING)
      {
        log("spellbook string too long\r\n");
        return FALSE;
      }

      tmp = (struct extra_descr_data *) malloc(sizeof(struct extra_descr_data));

      /* resize the string to hold the new value */
      tmp->description = (char *) malloc(len);
      if(!tmp)
      {
        log("SYSERR: Couldn't malloc the freakin' spellbook entry.");
        return FALSE;
      }

      /* zero out the memory */
      memset(tmp->description, 0x0, len);

      /* move the existing value to the new, larger buf */
      tmp_desc = tmp->description;
      entry_desc = entry->description;

      /* remove the file-appended /r/n as we copy */
      for(copy_len = 0; copy_len < strlen(entry->description); copy_len++)
      {
         if((*entry_desc == 10) || (*entry_desc == 13))
           continue;
         else
           *tmp_desc++ = *entry_desc++;
      }
      //strcpy(tmp->description, entry->description);

      /* add the two strings, old value + new value MINUS the CR/LF*/
//      strcat((tmp->description + strlen(tmp->description) - 2), spellnumbuf);
        strcat(tmp->description, spellnumbuf);
      /* kill the old memory */
      free(entry->description);

      /* now we can copy from tmp desc to the entry desc
       * copy the pointer, NOT the data
      */
      entry->description = tmp->description;
      added = 1;

  } /* end if(entry_exists) */
  else
  {
     CREATE(tmp, struct extra_descr_data, 1);
     tmp->next = book->ex_description;
     book->ex_description = tmp;
     tmp->keyword = strdup("PSE");
     tmp->description = (char*)malloc(strlen(spellnumbuf) + 1);
     memset(tmp->description, 0x0, (strlen(spellnumbuf) + 1));
     strcpy(tmp->description, spellnumbuf);
     added = 1;
  } /* end else (entry_exists) */

  if(added)
  {
    send_to_char("You write the spell in your spellbook",ch);
    return TRUE;
  }
  else
    log("SYSERR: PSE not found for spellbook");

  send_to_char("You were unable to copy that spell to your spellbook.\r\n", ch);
  return FALSE;
}


/* okay, here we add the spell to the book.  there are a
 * few different cases for adding a spell to a spell book:
 * 1. to book from teacher
 * 2. to book from another PC
 * 3. to book from another book
*/
ACMD(do_scribe)
{
  int spellnum;
  struct obj_data *book = 0;

  if(IS_NPC(ch))
    return;

  if(GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING)
  {
    send_to_char("You have to be sitting to scribe.\r\n",ch);
    return;
  }

  /* okay, there are one, maybe two arguments depending on
   * what the guy is scribing from.  typcially, he will scribe
   * while being taught by a teacher.  sometimes he might scribe from a
   * spellbook, or from another PC.  The latter two examples require an
   * argument.
  */

  if(!*argument)
  {
    send_to_char("Scribe what where?\r\n", ch);
    return;
  }

  spellnum = find_skill_num(argument);

  if((spellnum < 0) || (spellnum > MAX_SKILLS))
  {
    send_to_char("Try all you want, but there's no such thing.\r\n", ch);
    return;
  }

  /* no pc or NPC teacher && no book */
  if(!FindTeacher(ch, spellnum) && !GetBookScribe(ch, spellnum))
  {
    send_to_char("And just how do you expect to learn that spell?\r\n",ch);
    return;
  }

  if((int)GET_LEVEL(ch) < spell_info[spellnum].min_level[(int)GET_CLASS(ch)])
  {
    send_to_char("You don't understand the magic used in that spell.\r\n", ch);
    return;
  }

  book = GetBook(ch);

  if(book)
    AddSpellToBook(ch, book, spellnum);
  else
    send_to_char("You need a book to scribe.\r\n",ch);

}

/* this guy is gonna scribe, but wait! Is there someone to show it to him?... */
int FindTeacher(struct char_data *ch, int spell)
{
  struct char_data *dude;

  /* currently, don't allow pc to teach another pc spells
  if(*arg)
  {
    send_to_char("They might not know that spell...try a REAL teacher.\r\n", ch);
    return FALSE;
  }*/

  for (dude = world[ch->in_room].people ; dude ; dude = dude->next_in_room)
    if(MOB_FLAGGED(dude, MOB_TEACHER))
       return TRUE;

  return FALSE;
} /* end FindTeacher() */

int GetBookScribe(struct char_data *ch, int spell)
{
  if(GetBookAtHand(ch, spell))
    return TRUE;
  else
    return FALSE;
}
@


1.75
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@/***************************************************************************
 * $Id: spell_mem.c,v 1.74 2009/06/14 18:11:10 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: spell_mem.c                                    Part of FieryMUD *
 *  Usage: This file contains all of the code for spell_memorization.      *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *                                                                         *
 * This code was received origonally from HubisMUD in 1998 and no lable or *
 * claim of ownership or copyright was made anywhere in the file.          *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "casting.h"
#include "handler.h"
#include "comm.h"
#include "db.h"
#include "events.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "players.h"
#include "regen.h"
#include "screen.h"

#define MEM_INTERVAL      PULSE_VIOLENCE
#define SCRIBE_INTERVAL   PASSES_PER_SEC

const char *circle_abbrev[NUM_SPELL_CIRCLES +1] = {
    "!UNUSED!",
    " 1st",
    " 2nd",
    " 3rd",
    " 4th",
    " 5th",
    " 6th",
    " 7th",
    " 8th",
    " 9th",
    "10th",
    "11th",
    "12th",
    "13th",
    "14th"
};



/* --------function prototypes ---------*/
ACMD(do_meditate);
ACMD(do_pray);
ACMD(do_action);
ACMD(do_scribe);

/* memorizing and praying */
void show_spell_list(struct char_data *ch, struct char_data *tch);
int rem_spell(struct char_data *ch, int spell);
int check_spell_memory(struct char_data *ch, int spellnum);
void charge_mem(struct char_data *ch, int spellnum);
void update_spell_mem(void);
void start_memming(struct char_data *ch);
void rem_memming(struct char_data *ch);
int set_mem_time(struct char_data *ch, int spell);
void save_mem_list(struct char_data *ch);
int restore_spells(struct char_data *ch, int spell, int state);
void assign_mem_list(struct char_data *ch);
void done_memming(struct char_data *ch);

/* spell book stuff */
int add_spell_to_book(struct char_data *ch, struct obj_data *obj, int spell);
int book_contains_spell(struct obj_data *obj, int spell);
struct obj_data *find_spellbook_with_spell(struct char_data *ch, int spell);
struct char_data *find_teacher_for_spell(struct char_data *ch, int spell);
void print_spells_in_book(struct char_data *ch, struct obj_data *obj, char *dest_buf);
int room_in_book(struct obj_data *obj, int pages);
void start_scribing(struct char_data *ch);
void clear_scribing(struct char_data *ch);
int add_spell_scribe(struct char_data *ch, int spell);
int rem_spell_scribe(struct char_data *ch, int spell);
int get_spell_pages(struct char_data *ch, int spell);
int start_scribing_spell(struct char_data *ch, struct obj_data *spellbook,
      struct scribing *scr);

/* ------ global data ------ */
struct char_data *memming = 0; /* head of memming characters linked list */

/*---- spell table -------
 * This table describes how many spells a caster can memorize from a
 * specific CIRCLE at each level. This is class Independent. Class
 * dependencies can be controlled using spell_level() calls in class.c
 * IF YOU CHANGE THIS ARRAY, YOU MUST CHANGE STRUCTS.H MAX_CHAR_SPELLS
 * to the new value...
 */

int spells_of_circle[(LVL_IMPL + 1)][(NUM_SPELL_CIRCLES + 1)]={
/* level 0 and circle 0 are NOT USED!!! */
/* 0  1   2   3   4   5   6   7   8   9  10  11  12  13  14<-SPELL CIRCLE */

  {0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 0 */
  {0, 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 1 CIRCLE 1 */
  {0, 2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 2 */
  {0, 3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 3 */
  {0, 4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 4 */
  {0, 5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 5 */
  {0, 5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 6 */
  {0, 6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 7 */
  {0, 6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 8 */
  {0, 7,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 9 CIRCLE 2 */
  {0, 7,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 10*/
  {0, 7,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 11*/
  {0, 7,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 12*/
  {0, 7,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 13*/
  {0, 7,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 14*/
  {0, 7,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 15*/
  {0, 7,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 16*/
  {0, 7,  6,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 17 CIRCLE 3 */
  {0, 7,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 18*/
  {0, 7,  6,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 19*/
  {0, 7,  6,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 20*/
  {0, 7,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 21*/
  {0, 7,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 22*/
  {0, 7,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 23*/
  {0, 7,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 24*/
  {0, 7,  7,  6,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 25 CIRCLE 4 */
  {0, 7,  7,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 26*/
  {0, 7,  7,  6,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 27*/
  {0, 7,  7,  6,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 28*/
  {0, 7,  7,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 29*/
  {0, 7,  7,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 30*/
  {0, 7,  7,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 31*/
  {0, 7,  7,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 32*/
  {0, 7,  7,  6,  6,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 33 CIRCLE 5 */
  {0, 7,  7,  6,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 34*/
  {0, 7,  7,  6,  6,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 35*/
  {0, 7,  7,  6,  6,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 36*/
  {0, 7,  7,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 37*/
  {0, 7,  7,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 38*/
  {0, 7,  7,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 39*/
  {0, 7,  7,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 40*/
  {0, 7,  7,  6,  6,  6,  1,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 41 CIRCLE 6 */
  {0, 7,  7,  6,  6,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 42*/
  {0, 7,  7,  6,  6,  6,  3,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 43*/
  {0, 7,  7,  6,  6,  6,  4,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 44*/
  {0, 7,  7,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 45*/
  {0, 7,  7,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 46*/
  {0, 7,  7,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 47*/
  {0, 7,  7,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0},  /* level 48*/
  {0, 7,  7,  7,  6,  6,  6,  1,  0,  0,  0,  0,  0,  0,  0},  /* level 49 CIRCLE 7 */
  {0, 7,  7,  7,  6,  6,  6,  2,  0,  0,  0,  0,  0,  0,  0},  /* level 50*/
  {0, 7,  7,  7,  6,  6,  6,  3,  0,  0,  0,  0,  0,  0,  0},  /* level 51*/
  {0, 7,  7,  7,  6,  6,  6,  4,  0,  0,  0,  0,  0,  0,  0},  /* level 52*/
  {0, 7,  7,  7,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0},  /* level 53*/
  {0, 7,  7,  7,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0,  0},  /* level 54*/
  {0, 7,  7,  7,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0},  /* level 55*/
  {0, 7,  7,  7,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0,  0},  /* level 56*/
  {0, 7,  7,  7,  6,  6,  6,  6,  1,  0,  0,  0,  0,  0,  0},  /* level 57 CIRCLE 8 */
  {0, 7,  7,  7,  6,  6,  6,  6,  2,  0,  0,  0,  0,  0,  0},  /* level 58*/
  {0, 7,  7,  7,  6,  6,  6,  6,  3,  0,  0,  0,  0,  0,  0},  /* level 59*/
  {0, 7,  7,  7,  6,  6,  6,  6,  4,  0,  0,  0,  0,  0,  0},   /* level 60*/
  {0, 7,  7,  7,  6,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0},   /* level 61*/
  {0, 7,  7,  7,  6,  6,  6,  6,  5,  0,  0,  0,  0,  0,  0},   /* level 62*/
  {0, 7,  7,  7,  6,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0},   /* level 63*/
  {0, 7,  7,  7,  6,  6,  6,  6,  6,  0,  0,  0,  0,  0,  0},   /* level 64*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  1,  0,  0,  0,  0,  0},  /* level 65 CIRCLE 9 */
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  2,  0,  0,  0,  0,  0},   /* level 66*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  3,  0,  0,  0,  0,  0},   /* level 67*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  4,  0,  0,  0,  0,  0},   /* level 68*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  5,  0,  0,  0,  0,  0},   /* level 69*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  5,  0,  0,  0,  0,  0},  /* level 70*/
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  5,  0,  0,  0,  0,  0},  /* level 71 */
  {0, 7,  7,  7,  7,  6,  6,  6,  6,  6,  0,  0,  0,  0,  0},  /* level 72 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  1,  0,  0,  0,  0},  /* level 73 CIRCLE 10 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  2,  0,  0,  0,  0},  /* level 74 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  3,  0,  0,  0,  0},  /* level 75 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0,  0},  /* level 76 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  5,  0,  0,  0,  0},  /* level 77 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  5,  0,  0,  0,  0},  /* level 78 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  5,  0,  0,  0,  0},  /* level 79 */
  {0, 8,  7,  7,  7,  6,  6,  6,  6,  6,  6,  0,  0,  0,  0},  /* level 80 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  1,  0,  0,  0},  /* level 81 CIRCLE 11 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  2,  0,  0,  0},  /* level 82 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  3,  0,  0,  0},  /* level 83 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0},  /* level 84 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0},  /* level 85 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0},  /* level 86 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0},  /* level 87 */
  {0, 8,  8,  7,  7,  7,  6,  6,  6,  6,  6,  4,  0,  0,  0},  /* level 88 */
  {0, 8,  8,  7,  7,  7,  7,  6,  6,  6,  6,  5,  1,  0,  0},  /* level 89 CIRCLE 12 */
  {0, 8,  8,  8,  7,  7,  7,  6,  6,  6,  6,  5,  2,  0,  0},  /* level 90 */
  {0, 8,  8,  8,  7,  7,  7,  6,  6,  6,  6,  5,  3,  0,  0},  /* level 91 */
  {0, 8,  8,  8,  8,  7,  7,  7,  6,  6,  6,  5,  4,  0,  0},  /* level 92 */
  {0, 8,  8,  8,  8,  7,  7,  7,  6,  6,  6,  5,  4,  0,  0},  /* level 93 */
  {0, 8,  8,  8,  8,  8,  7,  7,  7,  6,  6,  5,  4,  0,  0},  /* level 94 */
  {0, 8,  8,  8,  8,  8,  7,  7,  7,  6,  6,  5,  4,  0,  0},  /* level 95 */
  {0, 8,  8,  8,  8,  8,  8,  7,  7,  6,  6,  5,  4,  0,  0},  /* level 96 */
  {0, 9,  9,  8,  8,  8,  8,  8,  7,  7,  6,  5,  4,  1,  0},  /* level 97 CIRCLE 13 */
  {0, 9,  9,  9,  9,  9,  9,  8,  7,  7,  6,  5,  4,  2,  0},  /* level 98 */
  {0, 10, 10, 10, 10, 10, 10, 9,  8,  7,  6,  5,  4,  3,  0},  /* level 99 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0},  /* level 100 */ /* Immortal+ */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0},  /* level 101 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0},  /* level 102 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0},  /* level 103 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0},  /* level 104 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  0}   /* level 105 CIRCLE 14 */
}; /* 11+11+11+11+11+11+11+11+11+11+8+7+6 = 131 = max_char_spells  */

int mob_mem_time(struct char_data *ch, int circle)
{
   double mem_time;

   mem_time = 9 - (GET_LEVEL(ch) - circle_to_level(circle)) / 2;

   if (mem_time < 2)
      mem_time = 2;

   /* Now adjust it for meditation. */
   if (GET_SKILL(ch, SKILL_MEDITATE))
     mem_time *= 0.3 + 0.007 * (100 - GET_SKILL(ch, SKILL_MEDITATE));

   return MAX(mem_time, 1);
}

EVENTFUNC(memming_event)
{
   struct char_data *ch = (struct char_data *) event_obj;
   struct mem_list *cur = 0;
   char buf[256];
   int i;

   if (FIGHTING(ch)) {
      cprintf(ch, "Your studies are rudely interrupted!\r\n"
                  "You abort your studies.\r\n");
      rem_memming(ch);
      return EVENT_FINISHED;
   }

   if (IS_DRUNK(ch)) {
      cprintf(ch, "You cannot study while intoxicated.\r\n"
                  "You abort your studies.\r\n");
      rem_memming(ch);
      return EVENT_FINISHED;
   }

   if (GET_POS(ch) != POS_SITTING ||
         GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
      send_to_char("You abort your studies.\r\n", ch);
      rem_memming(ch);
      return EVENT_FINISHED;
   }

   if (EVENT_FLAGGED(ch, EVENT_SCRIBE)) {
      send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
      rem_memming(ch);
      return EVENT_FINISHED;
   }

   /* Mobs memorize spells differently than players */
   if (IS_NPC(ch)) {
      for (i = NUM_SPELL_CIRCLES; i > 0; --i)
         if (GET_MOB_SPLBANK(ch, i) < spells_of_circle[(int) GET_LEVEL(ch)][i]) {
            if (GET_MOB_SPLMEM_TIME(ch) >= 0)
              GET_MOB_SPLMEM_TIME(ch) -= 2;
            else
              GET_MOB_SPLMEM_TIME(ch) = mob_mem_time(ch, i) - 2;
            if (GET_MOB_SPLMEM_TIME(ch) <= 0)
              GET_MOB_SPLBANK(ch, i)++;
            return MEM_INTERVAL;
         }
      rem_memming(ch);
      return EVENT_FINISHED;
   }

   cur = GET_SPELL_MEM(ch).list_head;
   while (cur && cur->can_cast)
      cur = cur->next;
   if (!cur) {
      done_memming(ch);
      return EVENT_FINISHED;
   } else {
      if (MEM_MODE(ch) == MEMORIZE) {
         if (!find_spellbook_with_spell(ch, cur->spell) ) {
            send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
            rem_memming(ch);
            return EVENT_FINISHED;
         }
      }

      /* using pulse violence, which means we only update every _2_ seconds
         please do NOT change this, unless you change in comm.c to
         pulse_violence/2  */
      cur->mem_time -= 2;

      /* check meditate skill */
      if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
         if (number(0, 20) > 17)
            improve_skill(ch, SKILL_MEDITATE);
      }

      if (cur->mem_time < 1) {
         if (MEM_MODE(ch) == MEMORIZE)
            sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
         else if (MEM_MODE(ch) == PRAY)
            sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
         send_to_char(buf, ch);

         /* reset so the guy has to remem after casting it.*/
         cur->mem_time = set_mem_time(ch, cur->spell);
         cur->can_cast = TRUE;
         GET_SPELL_MEM(ch).num_memmed++;
         if (GET_SPELL_MEM(ch).num_memmed == GET_SPELL_MEM(ch).num_spells || !cur->next) {
            done_memming(ch);
            return EVENT_FINISHED;
         }
      }
   }
   return MEM_INTERVAL;
}


EVENTFUNC(scribe_event)
{
   struct char_data *ch = (struct char_data *) event_obj;
   struct scribing *cur, *next_scribing;
   struct obj_data *obj;
   struct obj_data *held_right = 0;
   struct obj_data *held_left = 0;
   int right_type = 0, left_type = 0, added;

   /* Check for conditions that will interrupt scribing. */

   if (FIGHTING(ch)) {
      send_to_char("Your work is rudely interrupted!\r\n", ch);
      send_to_char("You stop scribing.\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   if (IS_DRUNK(ch)) {
      send_to_char("Sober up first, lush!\r\n", ch);
      send_to_char("You stop scribing.\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   if (GET_POS(ch) != POS_SITTING ||
         GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
      send_to_char("You stop scribing.\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   if (GET_SPELL_MEM(ch).mem_status) {
      send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   /* Make sure writing instrument and book are held. */

   held_right = GET_EQ(ch, WEAR_HOLD);
   held_left = GET_EQ(ch, WEAR_HOLD2);

   if (held_right)
      right_type = GET_OBJ_TYPE(held_right);

   if (held_left)
      left_type = GET_OBJ_TYPE(held_left);

   if (right_type != ITEM_PEN && left_type != ITEM_PEN) {
      send_to_char("You need something to write with.\r\n", ch);
      send_to_char("You stop scribing.\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   if (right_type != ITEM_SPELLBOOK) {
      if (left_type != ITEM_SPELLBOOK) {
         send_to_char("You are no longer holding a spellbook.\r\n", ch);
         clear_scribing(ch);
         return EVENT_FINISHED;
      } else {
         obj = held_left;
      }
   } else {
      obj = held_right;
   }

   /* Can't scribe in the dark. */

   if (!LIGHT_OK(ch)) {
      send_to_char("It is too dark, so you stop scribing.\r\n", ch);
      act("Unable to see, $n gives up scribing.", TRUE, ch, 0, 0, TO_ROOM);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   cur = ch->scribe_list;
   cur->scribe_time += 1;

   /* Did your teacher go away?  Lose your source book somehow? */

   if (!find_spellbook_with_spell(ch, cur->spell) &&
         !find_teacher_for_spell(ch, cur->spell)) {
      sprintf(buf, "You've lost your source for %s!\r\n",
            skill_name(cur->spell));
      send_to_char(buf, ch);
      send_to_char("&3With a weary sigh, you stop scribing.&0\r\n", ch);
      act("$n sighs and stops scribing.", TRUE, ch, 0, 0, TO_ROOM);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }

   /* There is a chance to improve the scribe skill in each round of scribing. */

   if (number(1, 20) > 15) {
      improve_skill(ch, SKILL_SCRIBE);
   }

   if (cur->scribe_time >= PAGE_SCRIBE_TIME) {

      /* A page has been finished. */

      cur->scribe_time = 0;
      cur->pages_left -= 1;

      if (cur->pages_left > 0) {
         if (PAGE_SCRIBE_TIME > 1) {
            sprintf(buf, "You finish a page in your spellbook.\r\n");
            send_to_char(buf, ch);
         }
         return SCRIBE_INTERVAL;
      }

      /* A spell has been finished. */

      /* Add this spell to the spellbook. */
      next_scribing = cur->next;
      added = add_spell_to_book(ch, obj, cur->spell);

      /* Any more spells in this person's scribe list? */

      if (!next_scribing) {
         sprintf(buf, "&6You have finished scribing %s.  &3You are done scribing.&0\r\n",
               skill_name(cur->spell));
         send_to_char(buf, ch);
         clear_scribing(ch);
         return EVENT_FINISHED;
      } else {
         sprintf(buf, "&6You have finished scribing %s&0.\r\n",
               skill_name(cur->spell));
         send_to_char(buf, ch);
      }

      rem_spell_scribe(ch, cur->spell);

      /* Scribe the next spell, if possible. */

      for (cur = next_scribing; cur; cur = next_scribing) {
         next_scribing = cur->next;
         if (start_scribing_spell(ch, obj, cur))
            return SCRIBE_INTERVAL;
         rem_spell_scribe(ch, cur->spell);
      }

      /* None of the spells in the scribing list could be scribed. */

      send_to_char("&3You are done scribing.&0\r\n", ch);
      clear_scribing(ch);
      return EVENT_FINISHED;
   }
   return SCRIBE_INTERVAL;
}

/* do_memorize can be called with or without arguments, causing a spell
to be added to the list, or just display the current list, respectively. */
ACMD(do_memorize)
{
   int spell, circle;
   struct char_data *tch;

   if (!ch || IS_NPC(ch))
      return;

   argument = delimited_arg_all(argument, arg, '\'');

   if (GET_LEVEL(ch) >= LVL_IMMORT) {
      if (!*arg)
         cprintf(ch, "You don't need to memorize spells to cast them.\r\n");
      else if (!(tch = find_char_around_char(ch, find_vis_by_name(ch, arg))))
         cprintf(ch, "%s", NOPERSON);
      else if (MEM_MODE(tch) != MEMORIZE)
         cprintf(ch, "%s does not study sorcery.\r\n", GET_NAME(tch));
      else
         show_spell_list(ch, tch);
      return;
   }

   if (MEM_MODE(ch) != MEMORIZE) {
      send_to_char("You do not study sorcery.\r\n", ch);
      return;
   }

   /* if no arg, show the current spell list */
   if (!*arg) {
      show_spell_list(ch, ch);
      if (GET_SPELL_MEM(ch).num_spells - GET_SPELL_MEM(ch).num_memmed > 0 &&
          GET_POS(ch) == POS_SITTING &&
          (GET_STANCE(ch) == STANCE_RESTING || GET_STANCE(ch) == STANCE_ALERT)) {
         send_to_char("\r\nYou continue your studies.\r\n", ch);
         start_memming(ch);
      }
      return;
   }

   if (FIGHTING(ch)) {
      send_to_char("If you want to commit suicide just say so!\r\n", ch);
      return;
   }

   /* check the char's position */
   if (GET_POS(ch) != POS_SITTING ||
         GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
      send_to_char("You are not comfortable enough to study.\r\n", ch);
      return;
   }

   /* for the spell name, find the spell num, and add it to the mem list. */
   spell = find_spell_num(arg);

   if (!IS_SPELL(spell)) {
      send_to_char("Memorize what?!\r\n", ch);
      return;
   }

   if (GET_LEVEL(ch) < SKILL_LEVEL(ch, spell)) {
      send_to_char("That spell is beyond your knowledge.\r\n", ch);
      return;
   }

   if (GET_SKILL(ch, spell) == 0) {
      send_to_char("You don't know that spell.\r\n", ch);
      return;
   }

   circle = SPELL_CIRCLE(ch, spell);

   /* check number of spells already memmed against the spell_table */
   if (spells_of_circle[(int)GET_LEVEL(ch)][circle] <= GET_SPELL_MEM(ch).num_circle[circle]) {
      sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", circle);
      send_to_char(buf, ch);
      return;
   }

   /* check for a spellbook */
   if (!find_spellbook_with_spell(ch, spell)) {
      send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
      return;
   }

   /* finally, the spell is available...add it to the list */
   add_spell(ch, spell, FALSE, 0, TRUE);
   if (!MEMMING(ch))
      act("$n takes out $s books and begins to study.", TRUE, ch, 0, 0, TO_ROOM);
   start_memming(ch);
}


ACMD(do_pray)
{
  int spell, circle;
   struct char_data *tch;

   if (!ch || IS_NPC(ch))
      return;

   argument = delimited_arg_all(argument, arg, '\'');

   if (GET_LEVEL(ch) >= LVL_IMMORT) {
      if (!*arg)
         cprintf(ch, "You don't need to pray for spells to cast them.\r\n");
      else if (!(tch = find_char_around_char(ch, find_vis_by_name(ch, arg))))
         cprintf(ch, "%s", NOPERSON);
      else if (MEM_MODE(tch) != PRAY)
         cprintf(ch, "%s does not pray for spells.\r\n", GET_NAME(tch));
      else
         show_spell_list(ch, tch);
      return;
   }

   if (MEM_MODE(ch) != PRAY) {
      do_action(ch, argument, cmd, subcmd);
      return;
   }

   /* if no arg, show the current spell list */
   if (!*arg) {
      show_spell_list(ch, ch);
      if (GET_SPELL_MEM(ch).num_spells - GET_SPELL_MEM(ch).num_memmed > 0 &&
          GET_POS(ch) == POS_SITTING &&
          (GET_STANCE(ch) == STANCE_RESTING || GET_STANCE(ch) == STANCE_ALERT)) {
         send_to_char("\r\nYou continue to pray.\r\n", ch);
         start_memming(ch);
      }
      return;
   }

  /* check the char's position */
  if (GET_POS(ch) != POS_SITTING ||
        GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
    send_to_char("You are not comfortable enough to pray to your deity.\r\n", ch);
    return;
  }

  /* for the spell name, find the spell num, and add it to the mem list. */
  spell = find_spell_num(arg);
  if (!IS_SPELL(spell)) {
    send_to_char("Pray for What?!\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) < SKILL_LEVEL(ch, spell)) {
    send_to_char("That spell is beyond your knowledge.\r\n", ch);
    return;
  }

  if (GET_SKILL(ch, spell) == 0) {
    send_to_char("You have heard of that spell, but have no idea how to cast it.\r\n", ch);
    return;
  }

  circle = SPELL_CIRCLE(ch, spell);

  /* check number of spells already memmed against the spell_table */
  if (spells_of_circle[(int)GET_LEVEL(ch)][circle] <= GET_SPELL_MEM(ch).num_circle[circle]) {
    sprintf(buf, "You can pray for no more spells from Circle %d.\r\n", circle);
    send_to_char(buf, ch);
    return;
  }

  add_spell(ch, spell, FALSE, 0, TRUE);
  if (!MEMMING(ch))
    act("$n begins praying to $s deity.",TRUE,ch,0,0,TO_ROOM);
  start_memming(ch);
}

void wipe_mem(struct char_data *ch)
{
  int i;
  struct mem_list *cur, *next;

  if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
    act("$n ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("&8You stop meditating.\r\n&0", ch);
    REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
  }

  if (GET_SPELL_MEM(ch).mem_status) {
    send_to_char("You abort your studies.\r\n", ch);
    rem_memming(ch);
  }

  GET_SPELL_MEM(ch).num_spells = 0;
  GET_SPELL_MEM(ch).num_memmed = 0;

  cur = GET_SPELL_MEM(ch).list_head;
  GET_SPELL_MEM(ch).list_head = NULL;
  GET_SPELL_MEM(ch).list_tail = NULL;

  while (cur) {
    next = cur->next;
    free(cur);
    cur = next;
  }

  for (i = 1; i <= NUM_SPELL_CIRCLES; ++i)
    GET_SPELL_MEM(ch).num_circle[i] = 0;

  save_player_char(ch);
  send_to_char("You purge all spells from your mind.\r\n",ch);
}

ACMD(do_forget)
{
  int spell;
  char buf[128];

  if (!ch || IS_NPC(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("You have no need to forget spells.\r\n",ch);
    return;
  }

  argument = delimited_arg_all(argument, arg, '\'');

  if (!*arg) {
    send_to_char("Are you trying to forget something in particular?\r\n", ch);
    return;
  }

  if (!str_cmp(arg, "all")) {
    wipe_mem(ch);
    return;
  }

  spell = find_spell_num(arg);

  if (!IS_SPELL(spell)) {
    send_to_char("Forget What?!\r\n", ch);
    return;
  } else {
    if (rem_spell(ch, spell)) {
      sprintf(buf, "You purge %s from your memory.\r\n", skill_name(spell));
      send_to_char(buf, ch);
    } else {
      sprintf(buf, "You do not have that spell memorized!\r\n");
      send_to_char(buf, ch);
    }
  }
}

/* set the meditate flag */
ACMD(do_meditate)
{
  if (IS_NPC(ch)) {
    send_to_char("You don't need to meditate!\r\n", ch);
    return;
  }
  if (GET_SKILL(ch, SKILL_MEDITATE) == 0) {
    send_to_char("You just can't seem to focus your mind enough.\r\n", ch);
    return;
  }
  if (GET_POS(ch) != POS_SITTING ||
        GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
    send_to_char("Try resting first....\r\n", ch);
    return;
  }
  if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
    send_to_char("You're already meditating!\r\n", ch);
    return;
  }

  if (GET_CLASS(ch) == CLASS_BERSERKER) {
    act("$n closes $s eyes and begins meditating.\r\n", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You begin to meditate, letting your rage build...\r\n", ch);
    check_regen_rates(ch);
  }
  else {
    act("$n begins meditating to improve $s concentration.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("You begin to meditate.\r\n", ch);
  }

  SET_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
  WAIT_STATE(ch, PULSE_VIOLENCE * 2); /* stun time */
  improve_skill(ch, SKILL_MEDITATE);
}

/* add a spell to the char's mem_list */
int add_spell(struct char_data *ch, int spell, int can_cast, int mem_time, bool verbose)
{
  struct mem_list *cur;
  char buf[128];
  int circle = SPELL_CIRCLE(ch, spell);

  /* see if ch can even use that circle of spell.... */
  if (!spells_of_circle[(int)GET_LEVEL(ch)][circle]) {
    if (verbose) {
      sprintf(buf, "You can't use spells from Circle %d yet.\r\n", circle);
      send_to_char(buf, ch);
    }
    return 0;
  }

  /* initialize the ptr and check it before proceeding */
  if (GET_SPELL_MEM(ch).num_spells == 0 ||
      !GET_SPELL_MEM(ch).list_tail || !GET_SPELL_MEM(ch).list_head) {
    CREATE(cur, struct mem_list, 1);
    cur->next = NULL;
    GET_SPELL_MEM(ch).list_head = cur;
    GET_SPELL_MEM(ch).list_tail = cur;
  }
  else {
    CREATE(cur, struct mem_list, 1);
    cur->next = NULL;
    GET_SPELL_MEM(ch).list_tail->next = cur;
    GET_SPELL_MEM(ch).list_tail = cur;
  }

  cur->spell = spell;
  cur->can_cast = can_cast;
  cur->mem_time = (mem_time <= 0 ? set_mem_time(ch, spell) : mem_time);

  GET_SPELL_MEM(ch).num_circle[circle]++;
  GET_SPELL_MEM(ch).num_spells++;
  if (can_cast)
    GET_SPELL_MEM(ch).num_memmed++;

  if (verbose) {
    sprintf(buf, "You begin %s %s, which will take %d seconds.\r\n",
            MEM_MODE(ch) == MEMORIZE ? "memorizing" : "praying for",
            skill_name(spell), cur->mem_time);
    send_to_char(buf, ch);
  }

  return 1;
}


/* remove the first instance of a spell from the char's memorize list */
int rem_spell(struct char_data *ch, int spell)
{
  struct mem_list dummy, *cur, *temp = NULL;
  int found = 0;

  dummy.next = GET_SPELL_MEM(ch).list_head;

  for (cur = &dummy; cur->next; cur = cur->next) {
    if (cur->next->spell != spell)
      continue;
    temp = cur->next;
    cur->next = temp->next;
    GET_SPELL_MEM(ch).num_spells--;
    if (temp->can_cast)
      GET_SPELL_MEM(ch).num_memmed--;
    free(temp);
    GET_SPELL_MEM(ch).num_circle[SPELL_CIRCLE(ch, spell)]--;
    found = 1;
    break;
  }

  if (dummy.next != GET_SPELL_MEM(ch).list_head)
    GET_SPELL_MEM(ch).list_head = dummy.next;

  if (!GET_SPELL_MEM(ch).list_head)
    GET_SPELL_MEM(ch).list_tail = NULL;

  if (temp == GET_SPELL_MEM(ch).list_tail)
    GET_SPELL_MEM(ch).list_tail = cur;

  return found;
}

void free_mem_list(struct char_data *ch) {
  struct mem_list *next, *mem = GET_SPELL_MEM(ch).list_head;
  while (mem) {
    next = mem->next;
    free(mem);
    mem = next;
  }
  GET_SPELL_MEM(ch).list_head = NULL;
  GET_SPELL_MEM(ch).list_tail = NULL;
}

void free_scribe_list(struct char_data *ch) {
  struct scribing *next;
  while (ch->scribe_list) {
    next = ch->scribe_list->next;
    free(ch->scribe_list);
    ch->scribe_list = next;
  }
}

void show_memorized_slots(struct char_data *ch, struct char_data *tch)
#define _MEM_PER_CIRCLE      10
{
   struct {
      struct {
         int spellnum;
         int memorized;
      } memorized[_MEM_PER_CIRCLE];
      int num_memorized;
   } circles[NUM_SPELL_CIRCLES];
   int circle, pos, memming = FALSE, time_remaining, show_next;
   struct mem_list *mem;

   memset(circles, 0x0, sizeof(circles));

   for (mem = GET_SPELL_MEM(tch).list_head; mem; mem = mem->next) {
      if (!mem->can_cast) {
         memming = TRUE;
         continue;
      }
      /* Spell circles are 1-based whereas our array is 0-based */
      circle = SPELL_CIRCLE(tch, mem->spell) - 1;
      for (pos = 0; pos < circles[circle].num_memorized; ++pos)
         if (circles[circle].memorized[pos].spellnum == mem->spell)
            break;
      if (pos >= _MEM_PER_CIRCLE) {
         continue;
      }
      if (pos == circles[circle].num_memorized)
         ++circles[circle].num_memorized;
      circles[circle].memorized[pos].spellnum = mem->spell;
      ++circles[circle].memorized[pos].memorized;
   }

   str_start(buf, sizeof(buf));

   sprintf(buf2, "%s %s %s:",
           ch == tch ? "You" : GET_NAME(tch),
           ch == tch ? "have" : "has",
           MEM_MODE(tch) == MEMORIZE ? "memorized" : "prayed for");
   if (memming)
      str_catf(buf, "%-37.37s%s %s currently %s:\r\n\r\n", buf2,
               ch == tch ? "You" : GET_NAME(tch),
               ch == tch ? "are" : "is",
               MEM_MODE(tch) == MEMORIZE ? "memorizing" : "praying for");
   else
      str_catf(buf, "%s\r\n\r\n", buf2);

   if (memming) {
      mem = GET_SPELL_MEM(tch).list_head;
      while (mem && mem->can_cast) mem = mem->next;
   }

   time_remaining = 0;
   show_next = 0;
   for (circle = 0; circle < NUM_SPELL_CIRCLES; ++circle) {
      for (pos = 0; pos < circles[circle].num_memorized; ++pos) {
         if (pos == 0)
            str_catf(buf, AHBLU "Circle %2d" ANRM "  ", circle + 1);
         else
            str_catf(buf, AHBLU "%9s" ANRM "  ", "");

         str_catf(buf, "%2d - %-21.21s%s",
                  circles[circle].memorized[pos].memorized,
                  skill_name(circles[circle].memorized[pos].spellnum),
                  mem || time_remaining || show_next ? "" : "\r\n");

         if (mem) {
            str_catf(buf, "%3d sec: (" AHBLU "%s" ANRM ") %s\r\n",
                     mem->mem_time, CIRCLE_ABBR(tch, mem->spell),
                     skill_name(mem->spell));
            time_remaining += mem->mem_time;
            do mem = mem->next; while (mem && mem->can_cast);
         }
         else if (time_remaining) {
            str_catf(buf, "\r\n");
            show_next = time_remaining;
            time_remaining = 0;
         }
         else if (show_next) {
            str_catf(buf, "%3d second%s remaining...\r\n", show_next,
                     show_next == 1 ? "" : "s");
            show_next = 0;
         }
      }
   }

   pos = 0;
   while (mem) {
      str_catf(buf, "%-37s%3d sec: (" AHBLU "%s" ANRM ") %s\r\n",
               !pos++ && GET_SPELL_MEM(tch).num_memmed < 1 ? "   None!" : "",
               mem->mem_time, CIRCLE_ABBR(tch, mem->spell),
               skill_name(mem->spell));
      time_remaining += mem->mem_time;
      do mem = mem->next; while (mem && mem->can_cast);
   }

   if (show_next)
      time_remaining = show_next;
   if (time_remaining)
      str_catf(buf, "%s%-37s%3d second%s remaining...\r\n",
               show_next ? "" : "\r\n", "", time_remaining,
               time_remaining == 1 ? "" : "s");
   else if (GET_SPELL_MEM(tch).num_memmed < 1)
      str_cat(buf, "   None!\r\n");

   str_cat(buf, "\r\n");

   send_to_char(buf, ch);
}
#undef _MEM_PER_CIRCLE


void show_available_slots(struct char_data *ch, struct char_data *tch)
{
   int circle, avail, found;

   str_start(buf, sizeof(buf));

   /* Display available spell slots for each circle */
   str_cat(buf, ch == tch ? "You" : GET_NAME(tch));
   if (MEM_MODE(tch) == MEMORIZE)
      str_cat(buf, " can memorize");
   else if (MEM_MODE(tch) == PRAY)
      str_cat(buf, " can pray for");

   for (circle = 1, found = 0; circle <= NUM_SPELL_CIRCLES; ++circle) {
      avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_SPELL_MEM(ch).num_circle[circle];
      if (avail > 0) {
         str_catf(buf, " (%d)%d%s", avail, circle,
                  circle == 1 ? "st" :
                  circle == 2 ? "nd" :
                  circle == 3 ? "rd" : "th");
         found += avail;
      }
   }

   if (found)
      str_cat(buf, " circle");
   else
      str_cat(buf, " no more");
   str_catf(buf, " spell%s\r\n", avail == 1 ? "" : "s");

   send_to_char(buf, ch);
}

void show_spell_list(struct char_data *ch, struct char_data *tch)
{
   show_memorized_slots(ch, tch);
   show_available_slots(ch, tch);
}

int check_spell_memory(struct char_data *ch, int spellnum)
{
  struct mem_list *cur;

  cur = GET_SPELL_MEM(ch).list_head;

  /* traverse the list and find out if the spell is memmed or not. */
  while (cur) {
    if (cur->spell == spellnum && cur->can_cast)
      return TRUE;

    cur = cur->next;
  }

  /* couldn't find a memmed copy of that spell anywhere... */
  return 0;
}


void charge_mem(struct char_data *ch, int spellnum)
{
  struct mem_list *cur;

  /*
   * Mobs don't memorize specific spells; they only recharge
   * slots in circles in their spell bank.
   */
  if (IS_NPC(ch)) {
    if (GET_MOB_SPLBANK(ch, SPELL_CIRCLE(ch, spellnum)) > 0)
      GET_MOB_SPLBANK(ch, SPELL_CIRCLE(ch, spellnum))--;
    return;
  }

  cur = GET_SPELL_MEM(ch).list_head;
  /* traverse the list to find the spell. */
  while (cur) {
    if (cur->spell == spellnum && cur->can_cast) {
      /* okay, this is a valid copy of the spell */
      cur->can_cast = 0;
      GET_SPELL_MEM(ch).num_memmed--;
      return;
    }
    cur = cur->next;
  }
}

void start_memming(struct char_data *ch)
{
   if (!MEMMING(ch)) {
      SET_FLAG(GET_EVENT_FLAGS(ch), EVENT_MEM);
      event_create(EVENT_MEM, memming_event, ch, FALSE, &(ch->events),
                   MEM_INTERVAL);
   }
}

void done_memming(struct char_data *ch)
{
   if (MEM_MODE(ch) == MEMORIZE) {
      send_to_char("You have completed your studies.\r\n", ch);
      act("$n closes $s book and smiles.", TRUE, ch, 0, 0, TO_ROOM);
   } else if (MEM_MODE(ch) == PRAY) {
      send_to_char("Your prayers are complete.\r\n", ch);
      act("$n finishes praying to $s deity.", TRUE, ch, 0, 0, TO_ROOM);
   }
   rem_memming(ch);
}


void rem_memming(struct char_data *ch)
{
   REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_MEM);
   cancel_event(GET_EVENTS(ch), EVENT_MEM);

   if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
      act("$n ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("&8You stop meditating.\r\n&0", ch);
      REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
   }
}

int spell_mem_time(struct char_data *ch, int spell)
{
   double mem_time;

   mem_time = 9 - ((int)GET_LEVEL(ch) - skills[spell].min_level[(int)GET_CLASS(ch)]) / 2;

   if (mem_time < 2)
      mem_time = 2;

   /* Now adjust it for meditation. */
   if (PLR_FLAGGED(ch, PLR_MEDITATE))
      mem_time *= 0.3 + 0.007 * (100 - GET_SKILL(ch, SKILL_MEDITATE));

   return MAX((int)mem_time, 1);
}

int set_mem_time(struct char_data *ch, int spell)
{
   int mem_time;

   mem_time = spell_mem_time(ch, spell);

   if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
      improve_skill(ch, SKILL_MEDITATE);

      /* There's a 1-5% chance it will be a deep trance and take only 1 second. */
      if (number(1, 100) <= 1 + GET_SKILL(ch, SKILL_MEDITATE) / 25) {
         send_to_char("You go into a deep trance...\r\n", ch);
         act("$n falls into a deep trance...", TRUE, ch, 0, 0, TO_ROOM);
         mem_time = 1;
      }
   }

   return MAX((int)mem_time, 1);
}

/* Okay, we can finally save the char's spell list on disk. */
void init_mem_list(struct char_data *ch)
{
  int remove, circle;
  struct mem_list *mem, *next_mem;

  if (!ch || IS_NPC(ch))
    return;

  for (mem = GET_SPELL_MEM(ch).list_head; mem; mem = next_mem) {
    next_mem = mem->next;
    remove = FALSE;
    circle = SPELL_CIRCLE(ch, mem->spell);
    if (GET_LEVEL(ch) < skills[mem->spell].min_level[(int) GET_CLASS(ch)])
      remove = TRUE;
    else if (spells_of_circle[(int) GET_LEVEL(ch)][circle] < GET_SPELL_MEM(ch).num_circle[circle])
      remove = TRUE;
    if (remove)
      rem_spell(ch, mem->spell);
  }

} /* end init_mem_list() */


/********************/
/**** SPELLBOOKS ****/
/********************/


/*
 * is_spellbook_with_spell
 *
 * Determine whether this object is a spellbook, and whether the
 * given spell is written in it.
 *
 */

int is_spellbook_with_spell(struct obj_data *obj, int spell) {

   return obj->obj_flags.type_flag == ITEM_SPELLBOOK &&
         book_contains_spell(obj, spell);
}

/*
 * find_spellbook_with_spell
 *
 * Identify a spellbook on this person which has the requested spell.
 *
 */

struct obj_data *find_spellbook_with_spell(struct char_data *ch, int spell) {
   struct obj_data *obj;

   for (obj = ch->carrying; obj; obj = obj->next_content) {
      if (is_spellbook_with_spell(obj, spell) && CAN_SEE_OBJ(ch, obj))
         return obj;
   }

   obj = ch->equipment[WEAR_HOLD];
   if (obj && is_spellbook_with_spell(obj, spell) && CAN_SEE_OBJ(ch, obj))
      return obj;

   obj = ch->equipment[WEAR_HOLD2];
   if (obj && is_spellbook_with_spell(obj, spell) && CAN_SEE_OBJ(ch, obj))
      return obj;

   return 0;
}

/*
 * book_contains_spell
 *
 * Determine whether this object is a spellbook, in which is written
 * the given spell.
 *
 */
int book_contains_spell(struct obj_data *obj, int spell) {
   struct spell_book_list *entry;

   for (entry = obj->spell_book; entry; entry = entry->next)
      if (entry->spell == spell)
         return TRUE;

   return FALSE;
}

/*
 * print_spells_in_book
 *
 * Prints a list of spells in the spellbook to the character.
 *
 * You can also pass a buffer for the text, if desired.  If you do,
 * the text will be appended to any string in it.  If you do not,
 * the text will be sent to the character.
 *
 * (This feature is needed by show_obj_to_char() in act.informative.c)
 *
 */

void print_spells_in_book(struct char_data *ch, struct obj_data *obj, char *dest_buf) {
   int spage = 0, fpage = 0;
   struct spell_book_list *entry;
   char list_buf[MAX_STRING_LENGTH];
   char *obuf = list_buf;

   list_buf[0] = 0;
   if (dest_buf) obuf = dest_buf;

   if (!obj->spell_book) {
      sprintf(obuf, "%sThere is nothing written in it.\r\n", obuf);
      if (!dest_buf)
         send_to_char(obuf, ch);
      return;
   }

   sprintf(obuf, "%sThe following is written in it:\r\n", obuf);

   for (entry = obj->spell_book; entry; entry = entry->next) {
      spage = fpage + 1;
      fpage = fpage + entry->length;
      if ((int)GET_LEVEL(ch) < skills[entry->spell].min_level[(int)GET_CLASS(ch)]) {
         sprintf(obuf, "%s&6%3d-%3d:&0 &9&b%s&0\r\n",
               obuf, spage, fpage, skills[entry->spell].name);
      } else {
         sprintf(obuf, "%s&6%3d-%3d:&0 &6&b%s&0\r\n",
               obuf, spage, fpage, skills[entry->spell].name);
      }
   }

   if ((GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) - fpage) > 1) {
      sprintf(obuf, "%s&6%3d-%3d:&0 &4&b(blank)&0\r\n",
         obuf, fpage + 1, GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES));
   } else if ((GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) - fpage) == 1) {
      sprintf(obuf, "%s    &6%3d:&0 &4&b(blank)&0\r\n",
      obuf, GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES));
   }

   if (!dest_buf) send_to_char(obuf, ch);
   return;
}


/*
 * add_spell_to_book
 *
 * Yup, adds a spell to a book.  As a result of scribing.
 *
 */

int add_spell_to_book(struct char_data *ch, struct obj_data *obj, int spell) {
   struct spell_book_list *entry;
   int pages;

   if (book_contains_spell(obj, spell)) {
      send_to_char("That spell is already in this book.\r\n", ch);
      return FALSE;
   }

   pages = get_spell_pages(ch, spell);

   if (!room_in_book(obj, pages)) {
      send_to_char("Your spellbook is too full for that spell.\r\n", ch);
      return FALSE;
   }

   if (obj->spell_book) {
      for (entry = obj->spell_book; entry->next; entry = entry->next);
      CREATE(entry->next, struct spell_book_list, 1);
      entry = entry->next;
   } else {
      CREATE(entry, struct spell_book_list, 1);
      obj->spell_book = entry;
   }

   entry->spell = spell;
   entry->length = pages;
   return TRUE;
}


/*
 * pages_left_in_book
 *
 * How many pages in this spellbook are still blank?
 *
 */

int pages_left_in_book(struct obj_data *obj) {
   struct spell_book_list *entry;
   int pages_used = 0;

   if (obj->obj_flags.type_flag != ITEM_SPELLBOOK)
      return 0;

   for (entry = obj->spell_book; entry; entry = entry->next)
      pages_used += entry->length;

   return GET_OBJ_VAL(obj, VAL_SPELLBOOK_PAGES) - pages_used;
}

/*
 * do_scribe
 *
 * Someone has issued the scribe command, e.g. "scribe magic missile".
 *
 */

ACMD(do_scribe) {
   int spellnum, pages_needed, pages_left;
   struct obj_data *book = 0, *pen, *sourcebook;
   struct char_data *teacher;
   struct obj_data *held_right = GET_EQ(ch, WEAR_HOLD);
   struct obj_data *held_left = GET_EQ(ch, WEAR_HOLD2);
   int right_type = 0, left_type = 0;
   struct scribing *sl;

   /* Mobs can't scribe. */

   if (IS_NPC(ch)) return;

   /* Yeah, scribe a spell while fighitng... */

   if (FIGHTING(ch)) {
      send_to_char("If you wanna commit suicide just say so!\r\n", ch);
      return;
   }

   /* Can't scribe in darkness. */

   if (!LIGHT_OK(ch)) {
      send_to_char("It is too dark for writing.\r\n", ch);
      return;
   }

   /* Can't scribe while confused. */

   if (CONFUSED(ch)) {
      send_to_char("You're too confused to write!\r\n", ch);
      return;
   }

   /* Make sure they are holding a writing instrument and a spellbook. */

   if (held_right)
      right_type = GET_OBJ_TYPE(held_right);
   if (held_left)
      left_type = GET_OBJ_TYPE(held_left);

   /* Find the writing instrument. */

   if (right_type == ITEM_PEN) {
      pen = held_right;
   } else if (left_type == ITEM_PEN) {
      pen = held_left;
   } else {
      send_to_char("You don't seem to have anything to write with.\r\n", ch);
      return;
   }

   /* Find the spellbook. */

   if (right_type == ITEM_SPELLBOOK) {
      book = held_right;
   } else if (left_type == ITEM_SPELLBOOK) {
      book = held_left;
   } else {
      send_to_char("You need to hold a spellbook before you can write in it.\r\n", ch);
      return;
   }

   /* Make sure player is in proper position. */

   if (GET_POS(ch) != POS_SITTING ||
        GET_STANCE(ch) < STANCE_RESTING || GET_STANCE(ch) > STANCE_ALERT) {
      send_to_char("You have to be sitting to scribe.\r\n", ch);
      return;
   }

   /* Identify the spell to be scribed. */

   argument = delimited_arg_all(argument, arg, '\'');

   if (!*arg) {
      send_to_char("What spell do you want to scribe?\r\n", ch);
      return;
   }

   spellnum = find_spell_num(arg);

   if (!IS_SPELL(spellnum)) {
      send_to_char("Try all you want, but there's no such thing.\r\n", ch);
      return;
   }

   /* Make sure there's a source for the spell - another character, or a spellbook. */

   sourcebook = find_spellbook_with_spell(ch, spellnum);
   teacher = find_teacher_for_spell(ch, spellnum);
   if (!sourcebook && !teacher) {
      send_to_char("There is nobody here to teach that spell, and nothing to copy it from.\r\n",
            ch);
      return;
   }

   /* Make sure it's a spell they are allowed to use, according to class and level. */

   if ((int)GET_LEVEL(ch) < skills[spellnum].min_level[(int)GET_CLASS(ch)] ||
         GET_SKILL(ch, spellnum) == 0)  {
      send_to_char("You don't understand the magic used in that spell.\r\n", ch);
      return;
   }

   /* Don't allow a spell to be scribed into a book twice (waste of time/space). */

   if (book_contains_spell(book, spellnum)) {
      send_to_char("That spell is already written in this book.\r\n", ch);
      return;
   }

   /* Make sure there's space in the book. */

   pages_needed = get_spell_pages(ch, spellnum);
   pages_left = pages_left_in_book(book);
   if (!room_in_book(book, pages_needed)) {
      if (pages_left == 0) {
         act("$P is full.", FALSE, ch, 0, book, TO_CHAR);
      } else {
         sprintf(buf, "You'd need %d pages to scribe that, but $P only has %d page%s left.",
               pages_needed, pages_left, pages_left == 1 ? "" : "s");
         act(buf, FALSE, ch, 0, book, TO_CHAR);
      }
      return;
   }

   /* Make sure they aren't already scribing it, or planning to. */

   for (sl = ch->scribe_list; sl; sl = sl->next)
      if (sl->spell == spellnum) {
         if (sl == ch->scribe_list)
            send_to_char("You're already scribing that spell!\r\n", ch);
         else
            send_to_char("You are already planning on scribing that spell.\r\n", ch);
         return;
      }

   /* Add the spell to the list of spells that this character is scribing. */

   add_spell_scribe(ch, spellnum);

   /* Make sure player is scribing, and provide feedback. */

   if (!EVENT_FLAGGED(ch, EVENT_SCRIBE)) {
      start_scribing(ch);
      act("$n picks up $s $o and starts writing in $P.", TRUE, ch, pen, book, TO_ROOM);
      sprintf(buf, "You begin scribing %s.\r\n", skill_name(spellnum));
      send_to_char(buf, ch);
   } else {
      sprintf(buf, "You make a mental note to scribe %s.\r\n", skill_name(spellnum));
      send_to_char(buf, ch);
   }
}

/*
 * find_teacher_for_spell
 *
 * Given a spell, locate a player or NPC who knows the spell and could
 * teach it, thus allowing someone to scribe it nearby.
 *
 */

struct char_data *find_teacher_for_spell(struct char_data *ch, int spell) {
   struct char_data *dude;

   for (dude = world[ch->in_room].people ; dude ; dude = dude->next_in_room) {

      if (dude == ch || !CAN_SEE(ch, dude)) continue;

      /* It must be a player or a teacher */

      if (!(IS_NPC(dude) && MOB_FLAGGED(dude, MOB_TEACHER)) && IS_NPC(dude))
         continue;

      /* It must know that spell */

      if (GET_LEVEL(dude) < skills[spell].min_level[(int)GET_CLASS(dude)])
         continue;

      return dude;
   }

   return 0;
}

/*
 * room_in_book
 *
 * Does this book have enough pages?
 *
 */

int room_in_book(struct obj_data *obj, int pages)
{
   return pages_left_in_book(obj) >= pages;
}

/*
 * start_scribing_spell
 *
 * Determine if a spell can be scribed, and give feedback.
 * Returns TRUE if it can be scribed, FALSE otherwise.
 *
 */

int start_scribing_spell(struct char_data *ch, struct obj_data *spellbook,
      struct scribing *scr)
{
   struct char_data *teacher;
   struct obj_data *sourcebook;

   /* Is there room in the book? */

   if (scr->pages > pages_left_in_book(spellbook)) {
      act("&3There is no room to scribe $T&3 in $p&3.&0", FALSE, ch, spellbook,
            skill_name(scr->spell), TO_CHAR);
      return FALSE;
   }

   /* Find out who/what we're scribing from. */
   teacher = find_teacher_for_spell(ch, scr->spell);
   if (teacher) {
      sprintf(buf, "With $N's help, you start scribing %s.",
            skill_name(scr->spell));
      act(buf, FALSE, ch, 0, teacher, TO_CHAR);
      sprintf(buf, "With $N's help, $n starts scribing %s.",
            skill_name(scr->spell));
      act(buf, TRUE, ch, 0, teacher, TO_NOTVICT);
      sprintf(buf, "With your help, $n starts scribing %s.",
            skill_name(scr->spell));
      act(buf, FALSE, ch, 0, teacher, TO_VICT);
      return TRUE;
   }

   sourcebook = find_spellbook_with_spell(ch, scr->spell);
   if (sourcebook) {
      act("You start scribing $T from $o.", FALSE, ch, sourcebook,
            skill_name(scr->spell), TO_CHAR);
      act("$n starts scribing from $o.", TRUE, ch, sourcebook, 0, TO_ROOM);
      return TRUE;
   }

   sprintf(buf, "There is no source for %s nearby, so you skip it for now.\r\n",
         skill_name(scr->spell));
   send_to_char(buf, ch);
   return FALSE;
}


/*
 * clear_scribing
 *
 * Clear a character's scribing list.
 *
 */

void clear_scribing(struct char_data *ch)
{
   struct scribing *this;

   REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_SCRIBE);

   this = ch->scribe_list;
   while (this) {
      rem_spell_scribe(ch, this->spell);
      this = ch->scribe_list;
   }
   ch->scribe_list = 0;
}

/*
 * add_spell_scribe
 *
 * Add a spell to the list of spells that a player is scribing.
 *
 */

int add_spell_scribe(struct char_data *ch, int spell)
{
   struct scribing *cur, *sc;

   CREATE(cur, struct scribing, 1);
   if (!ch->scribe_list) {
      ch->scribe_list = cur;
   } else {
      for (sc = ch->scribe_list; sc->next; sc = sc->next);
      sc->next = cur;
   }

   cur->spell = spell;
   cur->pages = get_spell_pages(ch, spell);
   cur->pages_left = get_spell_pages(ch, spell);
   return 1;
}


/*
 * rem_spell_scribe
 *
 * Remove a spell from the list of spells that a player is scribing.
 * Returns 1 if the spell was found and removed, else 0.
 *
 */

int rem_spell_scribe(struct char_data *ch, int spell)
{
   struct scribing *temp, *cur;

   cur = temp = ch->scribe_list;

   while (cur) {
      if (cur->spell == spell) {
         if (cur == ch->scribe_list)
            ch->scribe_list = cur->next;
         else
            temp->next = cur->next;
         free(cur);
         return 1;
      }
      temp = cur;
      cur = cur->next;
   }
   return 0;
}

/*
 * start_scribing
 *
 * Start a player scribing.
 *
 */

void start_scribing(struct char_data *ch)
{
   if (!EVENT_FLAGGED(ch, EVENT_SCRIBE)) {
      SET_FLAG(GET_EVENT_FLAGS(ch), EVENT_SCRIBE);
      event_create(EVENT_SCRIBE, scribe_event, ch, FALSE, &(ch->events),
                   SCRIBE_INTERVAL);
   }
}

/*
 *
 * get_spell_pages
 *
 * Get the number of pages that a spell would take to scribe,
 * according to the scribe skill of the player who wishes to
 * scribe it.
 *
 */

int get_spell_pages(struct char_data *ch, int spell) {
   float pages = 0, factor;
   int x;

   factor = (100 - (float)GET_SKILL(ch, SKILL_SCRIBE))/100;

   for (x = 1; x <= skills[spell].pages; x++) {
      pages += factor;
   }

   if (pages < 1)
      return 1;
   else
      return (int)pages + 1;
}




/***************************************************************************
 * $Log: spell_mem.c,v $
 * Revision 1.74  2009/06/14 18:11:10  myc
 * Gave the memorize/pray commands a makeover so everything gets
 * shown on one page.
 *
 * Revision 1.73  2009/03/09 03:45:17  jps
 * Extract some spell-mem related stuff from structs.h and put it in spell_mem.h
 *
 * Revision 1.72  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.71  2009/01/17 00:28:02  myc
 * Fix use of uninitialized variable.
 *
 * Revision 1.70  2008/08/25 00:20:33  myc
 * Changed the way mobs memorize spells.
 *
 * Revision 1.69  2008/07/27 05:13:43  jps
 * Changed name of save_player to save_player_char, since it only saves the
 * character, not other stuff like objects and quests.
 *
 * Revision 1.68  2008/06/07 19:06:46  myc
 * Moved object-related constants and routines to objects.h.
 *
 * Revision 1.67  2008/05/12 03:12:43  jps
 * Don't let people add spells to their to-scribe list multiple times.
 *
 * Revision 1.66  2008/05/11 05:42:14  jps
 * Using regen.h.
 *
 * Revision 1.65  2008/05/09 22:05:33  jps
 * Allow quotes or not when specifying a spell to memorize, pray,
 * forget, and scribe.
 *
 * Revision 1.64  2008/04/13 22:26:41  jps
 * Don't allow scribing while confused.
 *
 * Revision 1.63  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.62  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.61  2008/03/16 07:01:50  jps
 * Compensate for missing or corrupted time value in the saved spell mem list.
 *
 * Revision 1.60  2008/03/10 18:35:17  myc
 * Bug in init_mem_list was causing the last spell in a spell circle to
 * be forgotten.
 *
 * Revision 1.59  2008/03/05 03:03:54  myc
 * Changed the spell memory structures for the new ascii player files.
 *
 * Revision 1.58  2008/02/23 01:03:54  myc
 * Fixing some memory leaks in spell memorization.
 *
 * Revision 1.57  2008/02/16 20:31:32  myc
 * Adding functions to free memory and scribing lists on a player.
 *
 * Revision 1.56  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.  Now using event flags
 * for memming and scribing instead of plr flags.  Also directly
 * passing in the character instead of wrapping it in an event obj.
 *
 * Revision 1.55  2008/02/09 18:29:11  myc
 * The event code now takes care of freeing event objects.
 *
 * Revision 1.54  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.53  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.52  2008/01/29 16:51:12  myc
 * Adding skill names to the skilldef struct.
 *
 * Revision 1.51  2008/01/27 21:14:59  myc
 * Change meditate messages for berserkers.
 *
 * Revision 1.50  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.49  2008/01/26 12:31:19  jps
 * Use skills.h to import improve_skill().
 *
 * Revision 1.48  2008/01/09 04:15:27  jps
 * Make memming and scribing into events.
 *
 * Revision 1.47  2008/01/05 05:38:16  jps
 * Changed name of save_char() to save_player().
 *
 * Revision 1.46  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.45  2008/01/01 04:33:08  jps
 * Don't allow scribing of spells you don't know (including quest spells).
 *
 * Revision 1.44  2007/12/28 23:34:59  jps
 * If you lose the source of a spell you're scribing (teacher or book),
 * you will stop scribing that spell. You must be able to see the source.
 * You cannot scribe in darkness. The update_spell_scribe() loop will
 * correctly process every scribing person, even if some of them abort
 * scribing due to difficulties. Cut back on the "you finished a page"
 * spam. Changed a lot of the feedback for scribing events.
 *
 * Revision 1.43  2007/12/19 20:56:05  myc
 * save_player() no longer requires you to supply a save room (which
 * wasn't being used anyway).
 *
 * Revision 1.42  2007/10/20 19:01:18  myc
 * Meditate shouldn't be usable by NPC's because it sets the !BASH bit on them.
 *
 * Revision 1.41  2007/10/13 20:15:09  myc
 * Added functions to find spell/skill/chant nums to spells.h
 *
 * Revision 1.40  2007/09/21 18:07:32  jps
 * Stop hunger and thirst from interfering with scribing and memming.
 *
 * Revision 1.39  2007/09/02 22:31:57  jps
 * Minor typo fix.
 *
 * Revision 1.38  2007/08/07 01:30:45  jps
 * Use find_spell_num() so that skills aren't considered when the
 * input expected is a spell name.
 *
 * Revision 1.37  2007/07/31 23:44:36  jps
 * New macros IS_HUNGRY, IS_THIRSTY, IS_DRUNK.
 *
 * Revision 1.36  2007/07/31 16:54:05  jps
 * Cut memorization times in half.
 * Fix bug where you could finish memorization but not be told about it.
 *
 * Revision 1.35  2007/05/11 20:12:33  myc
 * find_spellbook_with_spell was trying to operate on a null pointer.
 *
 * Revision 1.34  2007/04/15 08:30:49  jps
 * Make scribing much, much faster. Also fix various idiosyncrasies related
 * to scribing and make it more user-friendly.
 *
 * Revision 1.33  2007/04/15 06:49:19  jps
 * Checking whether there's room in a book to scribe another spell now
 * uses the actual number it would take to scribe, based on scribe skill.
 *
 * Revision 1.32  2007/04/15 05:15:07  jps
 * "Scribe" alone just gets you an error msg because you can see the
 * spells by looking at the book now.
 *
 * Revision 1.31  2007/04/15 05:11:23  jps
 * Big code cleanup. Can see spells in a book just by looking at it.
 * Pyros can only learn their pyro spells from pyros, and the same goes
 * for cryos (we have those guildmasters now).
 *
 * Revision 1.30  2006/11/18 06:57:24  jps
 * Minor typos
 *
 * Revision 1.29  2006/11/08 09:16:04  jps
 * Fixed some loose-lose typos.
 *
 * Revision 1.28  2006/11/07 09:32:46  jps
 * Prevent memorizing/praying/scribing skills.
 *
 * Revision 1.27  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.26  2000/11/25 02:33:15  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.25  2000/04/22 22:40:15  rsd
 * fixed spelling of deity in player output, retabbed and braced
 * sections of code. Warrior types can no longer meditate.
 *
 * Revision 1.24  1999/11/28 23:56:19  cso
 * noted a memory leak. isn't fixed yet, but i marked it for later fixing
 *
 * Revision 1.23  1999/10/04 21:27:28  rsd
 * Removed the include for mudmath.h because it's obsolete now.
 *
 * Revision 1.22  1999/09/10 01:40:10  mtp
 * can mem from help spellbook too now
 *
 * Revision 1.21  1999/09/10 00:45:28  mtp
 * IS_MONK doesnt exists..used GET_CLASS=CL=CLASS_MONK
 *
 * Revision 1.20  1999/09/10 00:31:41  mtp
 * stop warriror/thief from meditiaating
 * it didnt do anything for them anyway bt *shrug*
 *
 * Revision 1.19  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.18  1999/07/20 19:45:51  jimmy
 * This is the spanky New Spell recognition code.
 * This code allows mobs/players that have the KNOW_SPELL skill
 * to make a skill check to guess the spell.  A good roll will show both
 * the spell and the target.  A bad roll will show the spell garbled and
 * then an INT check for the target.  If a really bad roll is made, the spell
 * will be replaced by an incorrect one.  the heart of this system is
 * start_chant(), end_chant, and bad_guess().
 * --gurlaek 7/20/1999
 *
 * Revision 1.17  1999/04/24 06:46:52  jimmy
 * changed to work with new pedantic flag --gurlaek
 *
 * Revision 1.16  1999/04/16 05:49:17  jimmy
 * initialized ch->num_memmed in assign_mem_list() to fix the
 * problem with not being able to tell when you were finished
 * memming after you leveled without renting and coming back or
 * forgetting all first.  Gurlaek.
 *
 * Revision 1.15  1999/04/07 18:14:32  jen
 * Added some messages about meditating... perhaps fixed the improve for meditating
 *
 * Revision 1.14  1999/04/07 16:57:41  jen
 * Added a msg to chars for deep trances
 *
 * Revision 1.13  1999/04/07 15:38:11  jen
 * Changed spell mem & prayer times to Scott's new system... JEN II
 *
 * Revision 1.12  1999/03/31 21:32:15  dce
 * Fixed a huge crash bug. Ch->spell_list wasn't check to see if it
 * was initialized upon adding a spell.
 *
 * Revision 1.11  1999/03/24 23:43:16  jimmy
 * Working on quest spells.  Still in progress.  HOwever, skills[] array now has a flag
 * quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
 * learn from any sorcerer type teacher
 * fingon
 *
 * Revision 1.10  1999/03/03 20:11:02  jimmy
 * Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
 * Spellbooks now have to be held to scribe as well as a quill in the other hand.
 *
 * -fingon
 *
 * Revision 1.9  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.8  1999/02/16 08:53:46  jimmy
 * Debugged and re-enabled spell books.  Added function to list all spells
 * scribed in a book.  Added checks so teachers only teach spells appropriate
 * to thier level.  Also, added checks so that players can't see spells above
 * thier level in spellbooks.
 * Fingon
 *
 * Revision 1.7  1999/02/12 15:33:17  jimmy
 * Brand new spell table, thanks to Zzur
 * Glad I didnt' have to do it...
 * fingon
 *
 * Revision 1.6  1999/02/11 22:17:40  jimmy
 * Moved spell circles to every 8 levels.  Filled in the
 * spells array to extend from level 70 to 105.
 * fingon
 *
 * Revision 1.5  1999/02/11 19:21:33  jimmy
 * Fixed spell mem bug.  High level casters would mem all of their
 * low level spells instantly when they got to them in the mem
 * list.  All mem times are now cumulative.
 * fingon
 *
 * Revision 1.4  1999/02/03 20:54:47  jimmy
 * If this doesn't fix spellcaster/leveling problems im gonna scream
 *
 * Revision 1.3  1999/02/03 18:11:43  jimmy
 * Fixed yet more bugs with spellcasters and leveling
 * Fhope this does it.
 *
 * Revision 1.2  1999/02/02 19:15:20  mud
 * Indented entire file.
 *
 * Revision 1.1  1999/01/29 01:23:32  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.74
log
@Gave the memorize/pray commands a makeover so everything gets
shown on one page.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.73 2009/03/09 03:45:17 jps Exp myc $
d701 1
a701 1
  if (!arg) {
d1716 4
@


1.73
log
@Extract some spell-mem related stuff from structs.h and put it in spell_mem.h
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.72 2009/03/08 23:34:14 jps Exp jps $
d31 1
d63 1
a63 4
void show_spell_list(struct char_data *ch, int args);
int get_num_memmed(struct char_data *ch, struct mem_list *this);
int SpellList(struct char_data *ch, char memmed[], char to_mem[]);
void list_spell_to_char(struct char_data * ch, char memmed[]);
d486 1
d491 11
a501 2
   if (MEM_MODE(ch) != MEMORIZE) {
      send_to_char("You do not study sorcery.\r\n", ch);;
d505 2
a506 2
   if (GET_LEVEL(ch) >= LVL_IMMORT) {
      send_to_char("You don't need to memorize spells to cast them.\r\n", ch);
a509 2
   argument = delimited_arg_all(argument, arg, '\'');

d512 7
a518 1
      show_spell_list(ch, FALSE);
d578 6
d585 11
a595 6
  if (!ch || IS_NPC(ch))
    return;
  if (MEM_MODE(ch) != PRAY) {
    do_action(ch, argument, cmd, subcmd);
    return;
  }
d597 4
a600 5
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("You don't need to pray for spells to cast them.\r\n", ch);
    return;
  }
  argument = delimited_arg_all(argument, arg, '\'');
d602 11
a612 5
  /* if no arg, show the current spell list */
  if (!*arg) {
    show_spell_list(ch, FALSE);
    return;
  }
d868 2
a869 1
void show_spell_list(struct char_data *ch, int args)
d871 80
a950 20
   char memmed[MAX_STRING_LENGTH];
   char to_mem[MAX_STRING_LENGTH];
   char buf[256];
   char remaining[256];
   char string[256];
   int circle;                                    /* check spell circle */
   int avail;                /* how many more spells in this circle? */

   if (SpellList(ch, memmed, to_mem)) {
      if (GET_POS(ch) == POS_SITTING &&
        (GET_STANCE(ch) == STANCE_RESTING || GET_STANCE(ch) == STANCE_ALERT)) {
         if (MEMMING(ch)) {
            if (MEM_MODE(ch) == MEMORIZE)
               strcat(to_mem, "\r\nYou continue your studies.\r\n");
            if (MEM_MODE(ch) == PRAY)
               strcat(to_mem, "\r\nYou continue to pray.\r\n");
         } else {
            /* add the player to the memming list so spells can be updated */
            start_memming(ch);
            strcat(to_mem, "\r\nYou continue your studies.\r\n");
a952 2
      strcat(to_mem, "\0");
      send_to_char(to_mem, ch);
d955 47
a1001 32
   memset(string , 0x0, 256);
   memset(remaining , 0x0, 256);
   memset(buf , 0x0, 256);

   /* display all remaining available spell slots for each circle*/
   if(MEM_MODE(ch) == MEMORIZE)
      sprintf(remaining, "\r\nYou can memorize");
   if(MEM_MODE(ch) == PRAY)
      sprintf(remaining, "\r\nYou can pray for");
   for(circle = 1; circle <= NUM_SPELL_CIRCLES; circle++)
      {
         avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_SPELL_MEM(ch).num_circle[circle];
         if(avail == 0)
            continue;
         sprintf(buf, " (%d)%d", avail, circle);
         strcat(string, buf);

         switch(circle)
            {
            case 1:
               strcat(string, "st");
               break;
            case 2:
               strcat(string, "nd");
               break;
            case 3:
               strcat(string, "rd");
               break;
            default:
               strcat(string, "th");
               break;
            }
d1003 4
a1006 2
   if(strlen(string)< 7)
      strcat(string, " no more");
d1008 10
a1017 4
      strcat(string, " circle");
   strcat(string, " spell(s)\r\n\r\n");
   strcat(remaining, string);
   send_to_char(remaining, ch);
a1158 113
int SpellList(struct char_data *ch, char *memmed, char *to_mem)
{
  struct mem_list *tmp;
  char membuf[256];
  int is_memming = 0;
  int num, i, found, circle = 0;
  int list_time = 0;

  tmp = GET_SPELL_MEM(ch).list_head;

  if(MEM_MODE(ch) == MEMORIZE){
    sprintf(memmed, "\r\nYou have memorized the following spells:\r\n\t");
    sprintf(to_mem, "\r\nYou are currently memorizing:\r\n");
  }
  if(MEM_MODE(ch) == PRAY){
    sprintf(memmed, "\r\nYou have prayed for the following spells:\r\n\t");
    sprintf(to_mem, "\r\nYou are currently praying for:\r\n");
  }
  /* sort the memmed spells  */
  for(i = 1; i < NUM_SPELL_CIRCLES; i++)
    {
      found = 1;
      circle++;
      tmp = GET_SPELL_MEM(ch).list_head;
      while(tmp)
        {
          if(SPELL_CIRCLE(ch, tmp->spell) == i)
            {
              if(tmp->can_cast)
                {
                  num = get_num_memmed(ch, tmp);
                  if(num > 0)
                    {
                      if(found == 1)
                        {
                          sprintf(membuf, "\r\n(%s %s)  ", CIRCLE_ABBR(ch, tmp->spell), "circle");
                          strcat(memmed, membuf);
                          sprintf(membuf, "\t%2d - %s\r\n", num, skill_name(tmp->spell));
                          strcat(memmed, membuf);

                          found--;
                        }
                      else
                        {
                          sprintf(membuf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell));
                          strcat(memmed, membuf);
                          strcat(memmed, "\0");
                          memset(membuf, 0x0, 256);
                        }
                    }
                }
            }
          tmp = tmp->next;
        }
    }

  tmp = GET_SPELL_MEM(ch).list_head;
  /* display the un-memmed spells */
  while(tmp)
    {
      if(!tmp->can_cast)
        {
          sprintf(membuf, "   %2d seconds: (%s) %-20s\t\t  \r\n", tmp->mem_time, CIRCLE_ABBR(ch, tmp->spell), skill_name(tmp->spell));
          strcat(to_mem, membuf);
          is_memming = 1;
          list_time += tmp->mem_time;
        }
      tmp = tmp->next;

    }

  /* if char still has spells memming, display total mem time */
  if(list_time)
    {
      sprintf(membuf, "\r\n   %d seconds remaining\r\n", list_time);
      strcat(to_mem, membuf);
    }

  /* char may have spells in list, but none are currently memmed */
  if(GET_SPELL_MEM(ch).num_memmed < 1)
    {
      sprintf(membuf, "   None!\r\n");
      strcat(memmed, membuf);
    }

  if(memmed)
    send_to_char(memmed, ch);

  return(is_memming);
}

int get_num_memmed(struct char_data *ch, struct mem_list *this)
{
  struct mem_list *list = GET_SPELL_MEM(ch).list_head;
  int num = 0;

  while (list != this) {
    if (this == list)
      continue;

    if (this->spell == list->spell && list->can_cast)
      return (0);

    list = list->next;
  }

  for (list = this; list; list = list->next)
    if (this->spell == list->spell && list->can_cast)
      num++;

  return (num);
}

d1716 3
@


1.72
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.71 2009/01/17 00:28:02 myc Exp jps $
d35 20
d1719 3
@


1.71
log
@Fix use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.70 2008/08/25 00:20:33 myc Exp myc $
d21 1
a21 1
#include "spells.h"
d1699 3
@


1.70
log
@Changed the way mobs memorize spells.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.69 2008/07/27 05:13:43 jps Exp myc $
d769 1
a769 1
  struct mem_list dummy, *cur, *temp;
d1699 3
@


1.69
log
@Changed name of save_player to save_player_char, since it only saves the
character, not other stuff like objects and quests.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.68 2008/06/07 19:06:46 myc Exp jps $
d196 16
d217 1
d220 2
a221 2
      send_to_char("Your studies are rudely interrupted!\r\n", ch);
      send_to_char("You abort your studies.\r\n", ch);
d227 2
a228 2
      send_to_char("You cannot study while intoxicated.\r\n", ch);
      send_to_char("You abort your studies.\r\n", ch);
d246 16
d913 10
d1699 4
@


1.68
log
@Moved object-related constants and routines to objects.h.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.67 2008/05/12 03:12:43 jps Exp myc $
d604 1
a604 1
  save_player(ch);
d1656 3
@


1.67
log
@Don't let people add spells to their to-scribe list multiple times.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.66 2008/05/11 05:42:14 jps Exp jps $
a60 1
int list_spells_in_book(struct obj_data *obj, int spell_array[][MAX_SPELLBOOK_PAGES]);
a1145 26
 *
 * list_spells_in_book
 *
 * Fill an array with a list of spellbook entries, which are taken from
 * the passed object, which must be a spellbook.
 *
 */

int list_spells_in_book(struct obj_data *book, int spell_array[][MAX_SPELLBOOK_PAGES]) {
   struct spell_book_list *entry;
   int sa_index = 0;

   if (!book->spell_book || !book->spell_book->spell) {
      return FALSE;
   }

   for (entry = book->spell_book; entry; entry = entry->next) {
      spell_array[0][sa_index] = entry->spell;
      spell_array[1][sa_index] = entry->spell_length;
      sa_index++;
   }

   return TRUE;
}

/*
a1151 1

d1153 1
a1153 9
   int index = 0;
   int spell_array[2][MAX_SPELLBOOK_PAGES];

   for (index = 0; index < obj->spell_book_length; index++) {
      spell_array[0][index] = 0;
      spell_array[1][index] = 0;
   }

   if (!list_spells_in_book(obj, spell_array)) return FALSE;
d1155 2
a1156 2
   for (index = 0; index < obj->spell_book_length; index++) {
      if (spell_array[0][index] == spell) {
a1157 2
      }
   }
d1176 2
a1177 2
   int index = 0, spage = 0, fpage = 0;
   int spell_array[2][MAX_SPELLBOOK_PAGES];
d1184 1
a1184 6
   for (index = 0; index < obj->spell_book_length; index++) {
      spell_array[0][index] = 0;
      spell_array[1][index] = 0;
   }

   if (!list_spells_in_book(obj, spell_array)) {
d1193 1
a1193 2
   index = 0;
   while (spell_array[0][index]) {
d1195 2
a1196 2
      fpage = fpage + spell_array[1][index];
      if ((int)GET_LEVEL(ch) < skills[spell_array[0][index]].min_level[(int)GET_CLASS(ch)]) {
d1198 1
a1198 1
               obuf, spage, fpage, skills[spell_array[0][index]].name);
d1201 1
a1201 1
               obuf, spage, fpage, skills[spell_array[0][index]].name);
a1202 1
      index++;
d1205 1
a1205 1
   if (((obj->spell_book_length - fpage) > 1)) {
d1207 2
a1208 2
         obuf, fpage + 1, obj->spell_book_length);
   } else if ((obj->spell_book_length - fpage) == 1) {
d1210 1
a1210 1
      obuf, obj->spell_book_length);
d1251 1
a1251 1
   entry->spell_length = pages;
d1270 2
a1271 3
   for (entry = obj->spell_book; entry; entry = entry->next) {
      pages_used += entry->spell_length;
   }
d1273 1
a1273 1
   return obj->spell_book_length - pages_used;
d1656 3
@


1.66
log
@Using regen.h.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.65 2008/05/09 22:05:33 jps Exp jps $
d1336 1
d1456 11
d1702 3
@


1.65
log
@Allow quotes or not when specifying a spell to memorize, pray,
forget, and scribe.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.64 2008/04/13 22:26:41 jps Exp jps $
d30 1
d1690 4
@


1.64
log
@Don't allow scribing while confused.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.63 2008/04/07 03:02:54 jps Exp jps $
d449 1
a449 1
   skip_spaces(&argument);
d452 1
a452 1
   if (!*argument) {
d470 1
a470 1
   spell = find_spell_num(argument);
d525 1
a525 1
  skip_spaces(&argument);
d528 1
a528 1
  if (!*argument) {
d541 1
a541 1
  spell = find_spell_num(argument);
a611 1
  skip_spaces(&argument);
d618 3
a620 1
  if (!argument) {
d625 1
a625 1
  if (!str_cmp(argument, "all")) {
d630 1
a630 1
  spell = find_spell_num(argument);
a1234 3
   /* display the spell on each page, but don't allow PC to read spells */
   /* that aren't available to his level/class  heheheheh               */

d1240 2
a1241 1
         sprintf(obuf, "%s&6%3d-%3d:&0 &5(unreadable)&0\r\n", obuf, spage, fpage);
d1400 3
a1402 1
   if (!*argument) {
d1407 1
a1407 1
   spellnum = find_spell_num(argument);
d1689 3
@


1.63
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.62 2008/03/28 17:54:53 myc Exp jps $
d1344 1
a1344 1
      send_to_char("If you wanna commit suicide just say so!.\r\n", ch);
d1355 7
d1688 4
@


1.62
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.61 2008/03/16 07:01:50 jps Exp myc $
d216 2
a217 1
   if (GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING) {
d301 2
a302 1
   if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING)) {
d463 2
a464 1
   if (GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING) {
d534 2
a535 1
  if(GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING) {
d656 2
a657 1
  if (GET_POS(ch) > POS_SITTING) {
d797 2
a798 1
      if ((GET_POS(ch) == POS_SITTING) || (GET_POS(ch) == POS_RESTING)) {
d1386 2
a1387 1
   if (GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING) {
d1681 4
@


1.61
log
@Compensate for missing or corrupted time value in the saved spell mem list.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.60 2008/03/10 18:35:17 myc Exp jps $
d576 1
a576 1
    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d671 1
a671 1
  SET_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d916 1
a916 1
      REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d1674 3
@


1.60
log
@Bug in init_mem_list was causing the last spell in a spell circle to
be forgotten.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.59 2008/03/05 03:03:54 myc Exp myc $
d920 1
a920 1
int set_mem_time(struct char_data *ch, int spell)
d930 12
a949 3
      } else {
         /* Otherwise, the meditate skill will reduce the time depending on how good it is. */
         mem_time *= 0.3 + 0.007 * (100 - GET_SKILL(ch, SKILL_MEDITATE));
d952 1
d1674 4
@


1.59
log
@Changed the spell memory structures for the new ascii player files.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.58 2008/02/23 01:03:54 myc Exp myc $
d711 1
a711 1
  GET_SPELL_MEM(ch).num_circle[SPELL_CIRCLE(ch, spell)]++;
d961 1
a961 1
    else if (spells_of_circle[(int) GET_LEVEL(ch)][circle] <= GET_SPELL_MEM(ch).num_circle[circle])
d1664 3
@


1.58
log
@Fixing some memory leaks in spell memorization.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.57 2008/02/16 20:31:32 myc Exp myc $
d29 1
a29 4

/* for the new add_spell */
#define ADD_NEW         0
#define RESTORE_CHAR    1
a44 1
int add_spell(struct char_data *ch, int spell, int mode, int is_memmed, int add_type);
d228 1
a228 1
   cur = ch->spell_list;
d263 3
a265 3
         cur->can_cast = 1;
         ch->num_memmed++;
         if (ch->num_memmed == ch->num_spells || !cur->next) {
d286 1
a286 1
   if (IS_FIGHTING(ch)) {
d306 1
a306 1
   if (ch->mem_status) {
d487 1
a487 1
   if (spells_of_circle[(int)GET_LEVEL(ch)][circle] <= GET_MEMMED(ch, circle)) {
d500 1
a500 1
   ch->num_spells += add_spell(ch, spell, MEMORIZE, 0, ADD_NEW);
d556 1
a556 1
  if (spells_of_circle[(int)GET_LEVEL(ch)][circle] <= GET_MEMMED(ch, circle)) {
d562 1
a562 1
  ch->num_spells += add_spell(ch, spell, PRAY, 0, ADD_NEW);
d579 1
a579 1
  if (ch->mem_status) {
d584 2
a585 2
  ch->num_spells = 0;
  ch->num_memmed = 0;
d587 3
a589 4
  for (i = 0; i < MAX_CHAR_SPELLS; ++i) {
    ch->player_specials->saved.memmed_spells[i][0] = 0;
    ch->player_specials->saved.memmed_spells[i][1] = 0;
  }
d591 1
a591 4
  cur = ch->spell_list;
  ch->spell_list = NULL;

  while(cur) {
d598 1
a598 1
    GET_MEMMED(ch, i) = 0;
d610 1
a610 1
  if(!ch || IS_NPC(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
d615 1
a615 1
  if(!argument) {
d620 1
a620 1
  if(is_abbrev(argument, "all")) {
d631 1
a631 1
    if(rem_spell(ch, spell)) {
d677 1
a677 1
int add_spell(struct char_data *ch, int spell, int mode, int is_memmed, int add_type)
d679 1
a679 1
  struct mem_list *cur, *prev;
d684 4
a687 8
  if(!spells_of_circle[(int)GET_LEVEL(ch)][circle])
    {
      if(add_type == ADD_NEW)
        {
          sprintf(buf, "You can't use spells from Circle %d yet.\r\n", circle);
          send_to_char(buf, ch);
        }
      return 0;
d689 3
d693 13
a705 26
  if(((ch->num_spells == 0) && (add_type == ADD_NEW)) || ((ch->spell_list == 0) && (add_type == RESTORE_CHAR)) || (!ch->spell_list))
    {
      /* MEMORY LEAK!! insure is calling this next line a memory leak */
      if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
        return 0;
      ch->spell_list->next = 0;
      cur = ch->spell_list;
    }else
      {

         /*  iterate the list to add new spell at the END...SLOW and UGLY!!! */
        for(cur = ch->spell_list; cur ; cur = cur->next)
          {
            if(cur->next == 0)
              {
                prev = cur;
                if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
                  return 0;

                prev->next = cur;
                cur->next = 0;
                break;
              }
          }

      }
d708 2
a709 2
  cur->can_cast = is_memmed;
  cur->mem_time = set_mem_time(ch, cur->spell);
d711 11
a721 11
  if(add_type == RESTORE_CHAR)
    {
      GET_MEMMED(ch, circle)++;
      return 1;
    }
  if(mode == MEMORIZE)
    sprintf(buf, "You begin memorizing %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time);
  else if(mode == PRAY)
    sprintf(buf, "You begin praying for %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time);
  send_to_char(buf, ch);
  GET_MEMMED(ch, circle)++;
a722 1
  /* increment the players num_spells */
d727 1
a727 1
/* remove a spell from the characters memorize list */
d733 1
a733 1
  dummy.next = ch->spell_list;
d739 2
a740 2
    cur->next = NULL;
    ch->num_spells--;
d742 1
a742 1
      ch->num_memmed--;
d744 1
a744 1
    GET_MEMMED(ch, SPELL_CIRCLE(ch, spell))--;
d749 8
a756 2
  if (dummy.next != ch->spell_list)
    ch->spell_list = dummy.next;
d762 5
a766 5
  struct mem_list *next;
  while (ch->spell_list) {
    next = ch->spell_list->next;
    free(ch->spell_list);
    ch->spell_list = next;
d768 2
d819 1
a819 1
         avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_MEMMED(ch, circle);
d854 2
a855 1
  cur = ch->spell_list;
d857 6
a862 6
  while(cur)
    {
      if(cur->spell == spellnum)
        if(cur->can_cast)
          /* okay, the spell is memmed...return true */
          return 1;
a863 2
      cur = cur->next;
    }
d873 1
a873 1
  cur = ch->spell_list;
d875 6
a880 11
  while(cur)
    {
      if(cur->spell == spellnum)
        if(cur->can_cast)
          {  /* okay, this is a valid copy of the spell */
            cur->can_cast = 0;
            ch->num_memmed--;
            return;
          }

      cur = cur->next;
d882 2
a945 15
void save_mem_list(struct char_data *ch)
{
  struct mem_list *cur;
  int counter = 0;

  for (cur = ch->spell_list, counter = 0; cur; cur = cur->next, ++counter) {
    ch->player_specials->saved.memmed_spells[counter][0] = cur->spell;
    ch->player_specials->saved.memmed_spells[counter][1] = cur->can_cast;
  }

  ch->player_specials->saved.spells_in_mem = counter;

} /* end save_mem_list() */


d949 1
a949 2
  int index = 0, i;
  int spell = 0, new_num_spells = 0, circle = 1;
d955 1
a955 8
  /* Set everything to zero */
  for (i = 1; i < NUM_SPELL_CIRCLES; i++)
    GET_MEMMED(ch, i) = 0;

  ch->num_memmed = 0;

  /* Free the existing mem list if there is one. */
  for (mem = ch->spell_list; mem; mem = next_mem) {
d957 8
a964 28
    free(mem);
  }
  ch->spell_list = NULL;

  /* Load memorize list from player specials */
  ch->num_spells = ch->player_specials->saved.spells_in_mem;
  for (i = 0; i < ch->num_spells; ++i) {

    /* find the spell number/circle */
    spell = ch->player_specials->saved.memmed_spells[i][0];
    circle = SPELL_CIRCLE(ch, spell);

    /* check the number of spells available in this circle at this level */
    new_num_spells = spells_of_circle[(int) GET_LEVEL(ch)][circle];

    /* check if PC is still high enough level for spell */
    if (GET_LEVEL(ch) >= skills[spell].min_level[(int) GET_CLASS(ch)]) {
      /* check if PC has less mem slots for spells */
      if (GET_MEMMED(ch, circle) < new_num_spells) {

        add_spell(ch, spell, MEM_MODE(ch),
                  ch->player_specials->saved.memmed_spells[index][1],
                  RESTORE_CHAR);

        if (ch->player_specials->saved.memmed_spells[index][1])
          ch->num_memmed++;
      }
    }
d967 1
a967 1
} /* end assign_mem_list() */
d977 1
a977 1
  tmp = ch->spell_list;
d992 1
a992 1
      tmp =ch->spell_list;
d1025 1
a1025 1
  tmp = ch->spell_list;
d1048 1
a1048 1
  if(ch->num_memmed < 1)
d1062 1
a1062 1
  struct mem_list *list = ch->spell_list;
d1065 6
a1070 4
  while(list != this)
    {
      if(this == list)
        continue;
d1072 2
a1073 4
      if((this->spell == list->spell) &&(list->can_cast) )
        return(0);
      list = list->next;
    }
d1075 2
a1076 2
  for(list = this; list; list = list->next)
    if(( this->spell == list->spell) && (list->can_cast))
d1079 1
a1079 1
  return(num);
d1327 1
a1327 1
   if (IS_FIGHTING(ch)) {
d1664 3
@


1.57
log
@Adding functions to free memory and scribing lists on a player.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.56 2008/02/09 21:07:50 myc Exp myc $
a29 3
/* macros */
#define CIRCLE_ABBR(s) circle_abbrev[GET_CIRCLE(s)]

d436 1
a436 1
   int spell;
d459 1
a459 1
   if (IS_FIGHTING(ch)) {
d465 1
a465 1
   if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING)) {
d478 1
a478 1
   if ((int)GET_LEVEL(ch) < skills[spell].min_level[(int)GET_CLASS(ch)])   {
d488 2
d491 2
a492 2
   if (spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell)) {
      sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
d513 1
a513 1
  int spell;
d531 1
d535 1
a535 1
  else if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
d537 2
d541 10
a550 8
  else
    {
      spell = find_spell_num(argument);
      if (!IS_SPELL(spell))
        {
          send_to_char("Pray for What?!\r\n", ch);
          return;
        }
d552 4
a555 5
      if((int)GET_LEVEL(ch) < skills[spell].min_level[(int)GET_CLASS(ch)])
        {
          send_to_char("That spell is beyond your knowledge.\r\n", ch);
          return;
        }
d557 1
a557 5
      if(GET_SKILL(ch, spell) == 0)
        {
          send_to_char("You have heard of that spell, but have no idea how to cast it.\r\n", ch);
          return;
        }
d559 6
a564 7
      /* check number of spells already memmed against the spell_table */
      if(spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell))
        {
          sprintf(buf, "You can pray for no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
          send_to_char(buf, ch);
          return;
        }
d566 4
a569 9
      /* finally, the spell is available...add it to the list */
      else
        {
          ch->num_spells += add_spell(ch, spell, PRAY, 0, ADD_NEW);
          if (!MEMMING(ch))
            act("$n begins praying to $s deity.",TRUE,ch,0,0,TO_ROOM);
          start_memming(ch);
        }
    }
d574 1
a574 1
  int counter;
d577 1
a577 2
  if (PLR_FLAGGED(ch, PLR_MEDITATE))
  {
d582 6
a587 5
  if(ch->mem_status)
    {
      send_to_char("You abort your studies.\r\n", ch);
      rem_memming(ch);
    }
d590 5
a594 5
  for(counter=0;counter < MAX_CHAR_SPELLS;counter++)
    {
      ch->player_specials->saved.memmed_spells[counter][0] = 0;
      ch->player_specials->saved.memmed_spells[counter][1] = 0;
    }
d599 9
a607 8
  while(cur)
    {
      next = cur->next;
      free(cur);
      cur = next;
    }
  for(counter=1;counter <= NUM_SPELL_CIRCLES;counter++)
    GET_MEMMED(counter) = 0;
d689 1
d692 1
a692 1
  if(!spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)])
d696 1
a696 1
          sprintf(buf, "You can't use spells from Circle %d yet.\r\n", GET_CIRCLE(spell));
d735 1
a735 1
      GET_MEMMED_CIRCLE(spell)++;
d743 1
a743 1
  GET_MEMMED_CIRCLE(spell)++;
d753 23
a775 36
  struct mem_list *temp, *cur;
  cur = temp = ch->spell_list;
  while(cur)
    {
      if(cur->spell == spell)
        {
          if(cur == ch->spell_list)
            {
              ch->spell_list = ch->spell_list->next;
              ch->num_spells -= 1;
              if(cur->can_cast)
                ch->num_memmed -= 1;

              free(cur);
              GET_MEMMED_CIRCLE(spell)--;
              return 1;
            }
          else
            {
              /* remove the spell, free the memory, and return found */
              temp->next = cur->next;
              ch->num_spells -= 1;
              if(cur->can_cast)
                ch->num_memmed -= 1;
              free(cur);
              GET_MEMMED_CIRCLE(spell)--;
              return 1;
            }
        }
      else
        {
          temp = cur;
          cur = cur->next;
        }
    }
  return 0;
d834 1
a834 1
         avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - (int)GET_MEMMED(circle);
d970 4
a973 1
  ch->player_specials->saved.spells_in_mem = ch->num_spells;
d975 1
a975 3
  if(ch->num_spells > 0)
    {
      cur = ch->spell_list;
a976 8
      while(counter < ch->num_spells && cur)
        {
          ch->player_specials->saved.memmed_spells[counter][0] = cur->spell;
          ch->player_specials->saved.memmed_spells[counter][1] = cur->can_cast;
          cur =  cur->next;
          counter++;
        }
    }
d981 1
a981 1
void assign_mem_list(struct char_data *ch)
d983 1
a983 1
  int index=0, i;
d985 3
a987 1
  if(!ch)
d990 4
a993 4
  /* zeroed GET_MEMMED to fix memorize bug --Fingon */
  for(i = 1; i < NUM_SPELL_CIRCLES; i++)
    GET_MEMMED(i) = 0;
  /* zeroed ch->num_memmed to fix memorization and leveling --Gurlaek */
d996 8
d1005 1
a1005 30
  ch->spell_list = 0;

  if(ch->num_spells)
    {
      for(index = 0; index < ch->num_spells;index++)
        {
          /* find the spell number/circle */
          spell = ch->player_specials->saved.memmed_spells[index][0];
          circle = GET_CIRCLE(spell);

          /* check the number of spells available in this circle at this level */
          new_num_spells = spells_of_circle[(int)GET_LEVEL(ch)][circle];

          /* check if PC is still high enough level for spell */
          if((int)GET_LEVEL(ch) >= skills[spell].min_level[(int)GET_CLASS(ch)]) {

            /* check if PC has less mem slots for spells */
            if(GET_MEMMED(circle) < new_num_spells) {

              add_spell(ch, spell, MEM_MODE(ch),
                        ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);

              if(ch->player_specials->saved.memmed_spells[index][1])
                ch->num_memmed++;
            }
          }
        }
    }
  else
    ch->spell_list = 0;
d1007 15
a1021 3
  /* Added so spells can be gained at time of level gain --Fingon */
  for(i = 1; i <= MAX_SPELLS; i++) {
    if((int)GET_LEVEL(ch) >= skills[i].min_level[(int)GET_CLASS(ch)]) {
d1023 2
a1024 8
      if(!IS_QUEST_SPELL(i)) {

        /* give all the regular spells */
        SET_SKILL(ch, i, 1000);
      } else if(GET_SKILL(ch, i) == 100) {

        /* keep the quest spells ch already has*/
        SET_SKILL(ch, i, 1000);
a1025 4
    } else {

      /* lose spells that ch doesn't have the level for */
      SET_SKILL(ch, i, 0);
d1028 1
a1030 37
int restore_spells(struct char_data *ch, int spell, int state)
{
  struct mem_list *cur;

  /* initialize the ptr and check it before proceeding */
  if(ch->num_spells == 0)
    {
      if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
        return 0;
      ch->spell_list->next = 0;
      cur = ch->spell_list;
    }
  else
    {
      if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
        return 0;
      cur->next = ch->spell_list;
    }

  cur->spell = spell;
  cur->can_cast = state;

  if(cur->can_cast)
    ch->num_memmed++;

  cur->mem_time = set_mem_time(ch, spell);

  GET_MEMMED_CIRCLE(spell)++;

  /* reset the head of the list */
  ch->spell_list = cur;

  /* increment the players num_spells */
  return 1;
}


d1057 1
a1057 1
          if(GET_CIRCLE(tmp->spell) == i)
d1066 1
a1066 1
                          sprintf(membuf, "\r\n(%s %s)  ", CIRCLE_ABBR(tmp->spell), "circle");
d1093 1
a1093 1
          sprintf(membuf, "   %2d seconds: (%s) %-20s\t\t  \r\n", tmp->mem_time, CIRCLE_ABBR(tmp->spell), skill_name(tmp->spell));
d1726 3
@


1.56
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.  Now using event flags
for memming and scribing instead of plr flags.  Also directly
passing in the character instead of wrapping it in an event obj.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.55 2008/02/09 18:29:11 myc Exp myc $
d796 17
d1804 6
@


1.55
log
@The event code now takes care of freeing event objects.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.54 2008/02/09 04:27:47 myc Exp myc $
d205 1
a205 2
   struct generic_event_data *eventdata = (struct generic_event_data *) event_obj;
   struct char_data *ch;
a208 2
   ch = eventdata->ch;

d223 1
a223 1
   if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING)) {
d229 1
a229 1
   if (PLR_FLAGGED(ch, PLR_SCRIBE)) {
d240 1
a240 1
      return 0;
d284 1
a284 2
   struct generic_event_data *eventdata = (struct generic_event_data *) event_obj;
   struct char_data *ch;
a290 2
   ch = eventdata->ch;

d334 1
a334 1
      return 0;
d909 3
a911 3
      SET_BIT(PLR_FLAGS(ch), PLR_MEMMING);
      event_create(EVENT_MEM, memming_event, mkgenericevent(ch, 0, 0),
         &(ch->events), MEM_INTERVAL);
d930 1
a930 1
   REMOVE_BIT(PLR_FLAGS(ch), PLR_MEMMING);
d1558 1
a1558 1
   if (!PLR_FLAGGED(ch, PLR_SCRIBE)) {
d1675 1
a1675 1
   REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
d1749 4
a1752 4
   if (!IS_SET(PLR_FLAGS(ch), PLR_SCRIBE)) {
      SET_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
      event_create(EVENT_SCRIBE, scribe_event, mkgenericevent(ch, 0, 0),
         &(ch->events), SCRIBE_INTERVAL);
d1787 3
@


1.54
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.53 2008/01/29 21:02:31 myc Exp myc $
d212 1
a212 1
   if (IS_FIGHTING(ch)) {
d216 1
a216 1
      return 0;
d223 1
a223 1
      return 0;
d229 1
a229 1
      return 0;
d235 1
a235 1
      return 0;
d249 1
a249 1
            return 0;
d277 1
a277 1
            return 0;
d303 1
a303 1
      return 0;
d310 1
a310 1
      return 0;
d316 1
a316 1
      return 0;
d322 1
a322 1
      return 0;
d347 1
a347 1
         return 0;
d361 1
a361 1
      return 0;
d377 1
a377 1
      return 0;
d414 1
a414 1
         return 0;
d436 1
a436 1
      return 0;
d937 1
a937 1
   cancel_event(ch, EVENT_MEM);
d1793 3
@


1.53
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.52 2008/01/29 16:51:12 myc Exp myc $
d28 1
d1793 4
@


1.52
log
@Adding skill names to the skilldef struct.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.51 2008/01/27 21:14:59 myc Exp myc $
d27 1
a38 6
/* global data */
extern struct room_data *world;

/* ------extern functions------ */
extern char *circle_abbrev[NUM_SPELL_CIRCLES +1];

d1792 3
@


1.51
log
@Change meditate messages for berserkers.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.50 2008/01/26 14:26:31 jps Exp myc $
a41 1
extern char *skill_name(int num);
d1362 1
a1362 1
               obuf, spage, fpage, skillnames[spell_array[0][index]]);
d1797 3
@


1.50
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.49 2008/01/26 12:31:19 jps Exp jps $
d263 1
a263 1
      /*check meditate skill */
d673 4
d685 9
a693 11
  switch (GET_CLASS(ch)) {
    case CLASS_WARRIOR:
    case CLASS_THIEF:
    case CLASS_ASSASSIN:
    case CLASS_MERCENARY:
    case CLASS_MONK:
    case CLASS_BERSERKER:
    case CLASS_ROGUE:
    case CLASS_BARD:
      send_to_char("You just can't seem to focus your mind enough.\r\n", ch);
      return;
a695 1
  act("$n begins meditating to improve $s concentration.", TRUE, ch, 0, 0, TO_ROOM);
a696 1
  send_to_char("You begin to meditate.\r\n", ch);
d1798 3
@


1.49
log
@Use skills.h to import improve_skill().
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.48 2008/01/09 04:15:27 jps Exp jps $
a38 1
extern struct spell_info_type spell_info[];
d89 3
a91 3
 * This table describes how many spells a caster can memorize from a 
 * specific CIRCLE at each level. This is class Independent. Class 
 * dependencies can be controlled using spell_level() calls in class.c 
d157 1
a157 1
  {0, 7,  7,  7,  6,  6,  6,  6,  1,  0,  0,  0,  0,  0,  0},  /* level 57 CIRCLE 8 */ 
d214 1
a214 1
  
d217 1
a217 1
   if (IS_FIGHTING(ch)) { 
d230 1
a230 1
   
d256 1
a256 1
      } 
d304 1
a304 1
   if (IS_FIGHTING(ch)) { 
d317 1
a317 1
   
d347 1
a347 1
   
d368 1
a368 1
   
d446 1
a446 1
/* do_memorize can be called with or without arguments, causing a spell 
d451 1
a451 1
   
d466 1
a466 1
    
d485 1
a485 1
   spell = find_spell_num(argument);         
d492 1
a492 1
   if ((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])   {
d526 1
a526 1
  
d533 1
a533 1
  
d539 1
a539 1
  
d544 1
a544 1
  
d548 1
a548 1
  
d552 1
a552 1
      spell = find_spell_num(argument);      
d558 2
a559 2
      
      if((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])  
d564 1
a564 1
      
d570 1
a570 1
      
d578 1
a578 1
      
d587 1
a587 1
    }        
d594 1
a594 1
  
d601 1
a601 1
  if(ch->mem_status) 
d613 1
a613 1
  
d616 2
a617 2
  
  while(cur) 
d634 1
a634 1
  
d639 1
a639 1
  
d644 1
a644 1
  
d649 3
a651 3
  
  spell = find_spell_num(argument);      
  
d663 1
a663 1
  }  
d693 1
a693 1
  
d706 1
a706 1
  
d716 1
a716 1
    }      
d727 1
a727 1
        
d736 1
a736 1
                
d742 3
a744 3
        
      }      
  
d747 2
a748 2
  cur->mem_time = set_mem_time(ch, cur->spell);      
  
d754 2
a755 2
  if(mode == MEMORIZE)     
    sprintf(buf, "You begin memorizing %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time); 
d757 1
a757 1
    sprintf(buf, "You begin praying for %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time); 
d760 1
a760 1
  
d762 1
a762 1
  return 1; 
d774 1
a774 1
        {  
d781 1
a781 1
              
d801 1
a801 1
          cur = cur->next;       
d818 1
a818 1
   if (SpellList(ch, memmed, to_mem)) {   
d830 2
a831 2
      }    
      strcat(to_mem, "\0");    
d834 5
a838 5
   
   memset(string , 0x0, 256); 
   memset(remaining , 0x0, 256);   
   memset(buf , 0x0, 256);   
   
d843 1
a843 1
      sprintf(remaining, "\r\nYou can pray for");    
d851 1
a851 1
         
d873 1
a873 1
   strcat(remaining, string);    
d880 1
a880 1
  
d889 1
a889 1
      
d900 1
a900 1
  
d911 2
a912 2
          } 
      
d935 1
a935 1
   rem_memming(ch);          
d955 1
a955 1
   mem_time = 9 - ((int)GET_LEVEL(ch) - spell_info[spell].min_level[(int)GET_CLASS(ch)]) / 2;
d970 1
a970 1
         /* Otherwise, the meditate skill will reduce the time depending on how good it is. */ 
d981 1
a981 1
  
d983 1
a983 1
  
d987 1
a987 1
      
d989 1
a989 1
        {          
d998 1
a998 1
   
d1028 1
a1028 1
          if((int)GET_LEVEL(ch) >= spell_info[spell].min_level[(int)GET_CLASS(ch)]) {
d1033 1
a1033 1
              add_spell(ch, spell, MEM_MODE(ch), 
d1035 2
a1036 2
              
              if(ch->player_specials->saved.memmed_spells[index][1]) 
d1042 1
a1042 1
  else 
d1047 2
a1048 2
    if((int)GET_LEVEL(ch) >= spell_info[i].min_level[(int)GET_CLASS(ch)]) {
      
d1050 1
a1050 1
        
d1054 1
a1054 1
        
d1059 1
a1059 1
      
d1069 1
a1069 1
  
d1072 1
a1072 1
    {     
d1083 2
a1084 2
    }      
  
d1087 1
a1087 1
  
d1090 3
a1092 3
  
  cur->mem_time = set_mem_time(ch, spell);      
  
d1094 1
a1094 1
  
d1097 1
a1097 1
  
d1099 1
a1099 1
  return 1; 
d1109 2
a1110 2
  int list_time = 0;         
  
d1112 1
a1112 1
  
d1114 1
a1114 1
    sprintf(memmed, "\r\nYou have memorized the following spells:\r\n\t");   
d1118 1
a1118 1
    sprintf(memmed, "\r\nYou have prayed for the following spells:\r\n\t");   
d1140 1
a1140 1
                          sprintf(membuf, "\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
d1142 1
a1142 1
                          
d1147 1
a1147 1
                          sprintf(membuf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
d1150 1
a1150 1
                          memset(membuf, 0x0, 256);        
d1158 1
a1158 1
  
d1171 1
a1171 1
      
d1173 1
a1173 1
  
d1175 1
a1175 1
  if(list_time) 
d1180 1
a1180 1
  
d1187 4
a1190 4
  
  if(memmed)          
    send_to_char(memmed, ch);          
  
d1198 1
a1198 1
  
d1203 1
a1203 1
      
d1208 1
a1208 1
  
d1212 1
a1212 1
  
d1245 1
a1245 1
 
d1285 1
a1285 1
   return TRUE;  
d1299 1
a1299 1
 
d1313 1
a1313 1
   return FALSE;      
a1329 1
   extern char *spells[];
d1350 1
a1350 1
   sprintf(obuf, "%sThe following is written in it:\r\n", obuf); 
d1359 1
a1359 1
      if ((int)GET_LEVEL(ch) < spell_info[spell_array[0][index]].min_level[(int)GET_CLASS(ch)]) {
d1363 1
a1363 1
               obuf, spage, fpage, spells[spell_array[0][index]]);
d1377 1
a1377 1
   return;      
d1519 1
a1519 1
      send_to_char("Try all you want, but there's no such thing.\r\n", ch); 
d1531 1
a1531 1
   } 
d1535 1
a1535 1
   if ((int)GET_LEVEL(ch) < spell_info[spellnum].min_level[(int)GET_CLASS(ch)] ||
d1572 1
a1572 1
      sprintf(buf, "You begin scribing %s.\r\n", skill_name(spellnum)); 
d1602 1
a1602 1
      if (GET_LEVEL(dude) < spell_info[spell].min_level[(int)GET_CLASS(dude)])
d1737 1
a1737 1
      if (cur->spell == spell) {  
d1746 1
a1746 1
      cur = cur->next;       
d1783 1
a1783 1
   for (x = 1; x <= spell_info[spell].pages; x++) {
d1798 3
d1936 1
a1936 1
 * Revision 1.12  1999/03/31 21:32:15  dce 
d1939 1
a1939 1
 * 
d1941 1
a1941 1
 * Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
d1949 1
a1949 1
 * 
@


1.48
log
@Make memming and scribing into events.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.47 2008/01/05 05:38:16 jps Exp jps $
d26 1
a44 1
void improve_skill(struct char_data *ch, int skill);
d1800 3
@


1.47
log
@Changed name of save_char() to save_player().
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.46 2008/01/03 12:44:03 jps Exp jps $
d25 1
d34 3
d52 1
d62 1
a62 1
void add_mem_list(struct char_data *ch);
d68 1
d78 2
a79 3
void update_spell_scribe(void);
void add_scribing(struct char_data *ch);
void rem_scribing(struct char_data *ch);
d83 2
a87 1
struct char_data *scribing = 0; /* list of scribing PC's */
d209 238
d480 1
a480 1
   if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
d482 2
d486 1
d488 4
a491 6
   else {
      spell = find_spell_num(argument);         
      if (!IS_SPELL(spell)) {
         send_to_char("Memorize what?!\r\n", ch);
         return;
      }
d493 4
a496 4
      if ((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])   {
         send_to_char("That spell is beyond your knowledge.\r\n", ch);
         return;
      }
d498 4
a501 4
      if (GET_SKILL(ch, spell) == 0) {
         send_to_char("You don't know that spell.\r\n", ch);
         return;
      }
d503 6
a508 6
      /* check number of spells already memmed against the spell_table */
      if (spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell)) {
         sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
         send_to_char(buf, ch);
         return;
      }
d510 5
a514 5
      /* check for a spellbook */
      if (!find_spellbook_with_spell(ch, spell)) {
         send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
         return;
      }
d516 5
a520 12
      /* finally, the spell is available...add it to the list */
      else {
         ch->num_spells += add_spell(ch, spell, MEMORIZE, 0, ADD_NEW);
         if (!ch->mem_status) {
            /* get the char started memming his list.. */
            add_mem_list(ch);
            if (!(ch->mem_status))
               act("$n takes out $s books and begins to study.",TRUE,ch,0,0,TO_ROOM);
            ch->mem_status = 1;
         }
      }
   }
d555 4
a558 4
	{
	  send_to_char("Pray for What?!\r\n", ch);
	  return;
	}
d561 1
a561 1
	{
d564 1
a564 1
	}
d567 4
a570 4
	{
	  send_to_char("You have heard of that spell, but have no idea how to cast it.\r\n", ch);
	  return;
	}
d574 5
a578 5
	{
	  sprintf(buf, "You can pray for no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
	  send_to_char(buf, ch);
	  return;
	}
d582 7
a588 12
	{
	  ch->num_spells += add_spell(ch, spell, PRAY, 0, ADD_NEW);
	  if(!ch->mem_status)
	    {
	      /* get the char started memming his list.. */
	      add_mem_list(ch);
	      if(!(ch->mem_status))
		act("$n begins praying to $s deity.",TRUE,ch,0,0,TO_ROOM);
	      ch->mem_status = 1;
	    }
	}
    }	
d712 4
a715 4
	{
	  sprintf(buf, "You can't use spells from Circle %d yet.\r\n", GET_CIRCLE(spell));
	  send_to_char(buf, ch);
	}
d723 1
a723 1
	return 0;
d728 16
a743 16
	
	 /*  iterate the list to add new spell at the END...SLOW and UGLY!!! */
	for(cur = ch->spell_list; cur ; cur = cur->next)
	  {
	    if(cur->next == 0)
	      {
		prev = cur;
		if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
		  return 0;
		
		prev->next = cur;
		cur->next = 0;
		break;
	      }
	  }
	
d775 6
a780 6
	{  
	  if(cur == ch->spell_list)
	    {
	      ch->spell_list = ch->spell_list->next;
	      ch->num_spells -= 1;
	      if(cur->can_cast)
d782 11
a792 11
	      
	      free(cur);
	      GET_MEMMED_CIRCLE(spell)--;
	      return 1;
	    }
	  else
	    {
	      /* remove the spell, free the memory, and return found */
	      temp->next = cur->next;
	      ch->num_spells -= 1;
	      if(cur->can_cast)
d794 5
a798 5
	      free(cur);
	      GET_MEMMED_CIRCLE(spell)--;
	      return 1;
	    }
	}
d800 4
a803 4
	{
	  temp = cur;
	  cur = cur->next;       
	}
d811 65
a875 71
  char memmed[MAX_STRING_LENGTH];
  char to_mem[MAX_STRING_LENGTH];
  char buf[256];
  char remaining[256];
  char string[256];
  int circle;			/* check spell circle */
  int avail;           /* how many more spells in this circle? */
  if(SpellList(ch, memmed, to_mem))
   {  
     if((GET_POS(ch) == POS_SITTING) || (GET_POS(ch) == POS_RESTING))
       {
         if(ch->mem_status)
	   { 
	     if(MEM_MODE(ch) == MEMORIZE)
	       strcat(to_mem, "\r\nYou continue your studies.\r\n");
	     if(MEM_MODE(ch) == PRAY)
	       strcat(to_mem, "\r\nYou continue to pray.\r\n");
	     
	   }
         else
	   {
	     /* add the player to the memming list so spells can be updated */
	     add_mem_list(ch);
	     ch->mem_status = 1;
	     strcat(to_mem, "\r\nYou continue your studies.\r\n");
	   }
       }   
     strcat(to_mem, "\0");   
     send_to_char(to_mem, ch);
   }
  
  memset(string , 0x0, 256); 
  memset(remaining , 0x0, 256);  
  memset(buf , 0x0, 256);  
  
  /* display all remaining available spell slots for each circle*/
  if(MEM_MODE(ch) == MEMORIZE)
    sprintf(remaining, "\r\nYou can memorize");
  if(MEM_MODE(ch) == PRAY)
    sprintf(remaining, "\r\nYou can pray for");   
  for(circle = 1; circle <= NUM_SPELL_CIRCLES; circle++)
    {
      avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - (int)GET_MEMMED(circle);
      if(avail == 0)
	continue;
      sprintf(buf, " (%d)%d", avail, circle);
      strcat(string, buf);
      
      switch(circle)
	{
	case 1:
	  strcat(string, "st");
	  break;
	case 2:
	  strcat(string, "nd");
	  break;
	case 3:
	  strcat(string, "rd");
	  break;
	default:
	  strcat(string, "th");
	  break;
	}
    }
  if(strlen(string)< 7)
    strcat(string, " no more");
  else
    strcat(string, " circle");
  strcat(string, " spell(s)\r\n\r\n");
  strcat(remaining, string);   
  send_to_char(remaining, ch);
d887 3
a889 3
	if(cur->can_cast)
	  /* okay, the spell is memmed...return true */
	  return 1;
d907 3
a909 3
	if(cur->can_cast)
	  {  /* okay, this is a valid copy of the spell */
	    cur->can_cast = 0;
d912 1
a912 1
	  } 
d918 1
a918 2

void add_mem_list(struct char_data *ch)
d920 5
a924 10
  if(memming == 0)
    {
      memming = ch;
      ch->next_memming = 0;
    }
  else
    {
      ch->next_memming =  memming;
      memming = ch;
    }
a938 82
void update_spell_mem(void)
{
  struct char_data *ch = 0;
  struct mem_list *cur = 0;
  char buf[256];
  
  ch = memming;
  /* if no one is memming, don't bother */
  if(memming == 0)
    return;
  
   while(ch) {
      if (IS_FIGHTING(ch)) { 
         send_to_char("Your studies are rudely interrupted!\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

      if (IS_DRUNK(ch)) {
         send_to_char("You cannot study while intoxicated.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }
      
      if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING)) {
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

      if (PLR_FLAGGED(ch, PLR_SCRIBE)) {
         send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
         rem_memming(ch);
         return;
      }

      cur = ch->spell_list;
      while (cur && cur->can_cast)
         cur = cur->next;
      if (!cur) {
         done_memming(ch);
      } else {
         if (MEM_MODE(ch) == MEMORIZE) {
            if (!find_spellbook_with_spell(ch, cur->spell) ) {
               send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
               rem_memming(ch);
               break;
            }
         } 

         /* using pulse violence, which means we only update every _2_ seconds
            please do NOT change this, unless you change in comm.c to
            pulse_violence/2  */
         cur->mem_time -= 2;

         /*check meditate skill */
         if (PLR_FLAGGED(ch, PLR_MEDITATE)) {
            if (number(0, 20) > 17)
               improve_skill(ch, SKILL_MEDITATE);
         }

         if (cur->mem_time < 1) {
            if (MEM_MODE(ch) == MEMORIZE)
               sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
            else if (MEM_MODE(ch) == PRAY)
               sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
            send_to_char(buf, ch);

            /* reset so the guy has to remem after casting it.*/
            cur->mem_time = set_mem_time(ch, cur->spell);
            cur->can_cast = 1;
            ch->num_memmed++;
            if (ch->num_memmed == ch->num_spells || !cur->next) {
               done_memming(ch);
            }
         }
      }
      ch = ch->next_memming;
   }   
}
d942 2
a943 16
  struct char_data *temp, *prev;
  
  for(prev = temp = memming; temp; temp = temp->next_memming)
    {
      if(temp == ch)
	{
	  if(ch == memming)
	    {
	      memming = ch->next_memming;
	      ch->next_memming = 0;
	    }
	  else
	    {
	      prev->next_memming = ch->next_memming;
	      ch->next_memming = 0;        
	    }
d945 5
a949 12
          if (PLR_FLAGGED(ch, PLR_MEDITATE))
          {
            act("$n ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
            send_to_char("&8You stop meditating.\r\n&0", ch);
	    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
          }
	  ch->mem_status = 0;
	  return;
	}
      
      prev = temp;
    }  /*  end for */
d990 1
a990 1
	{          
d995 1
a995 1
	}
d1020 22
a1041 22
	{
	  /* find the spell number/circle */
	  spell = ch->player_specials->saved.memmed_spells[index][0];
	  circle = GET_CIRCLE(spell);

	  /* check the number of spells available in this circle at this level */
	  new_num_spells = spells_of_circle[(int)GET_LEVEL(ch)][circle];

	  /* check if PC is still high enough level for spell */
	  if((int)GET_LEVEL(ch) >= spell_info[spell].min_level[(int)GET_CLASS(ch)]) {

	    /* check if PC has less mem slots for spells */
	    if(GET_MEMMED(circle) < new_num_spells) {

	      add_spell(ch, spell, MEM_MODE(ch), 
			ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);
	      
	      if(ch->player_specials->saved.memmed_spells[index][1]) 
		ch->num_memmed++;
	    }
	  }
	}
d1051 3
a1053 3
	
	/* give all the regular spells */
	SET_SKILL(ch, i, 1000);
d1055 3
a1057 3
	
	/* keep the quest spells ch already has*/
	SET_SKILL(ch, i, 1000);
d1075 1
a1075 1
	return 0;
d1082 1
a1082 1
	return 0;
d1129 29
a1157 29
	{
	  if(GET_CIRCLE(tmp->spell) == i)
	    {
	      if(tmp->can_cast)
		{
		  num = get_num_memmed(ch, tmp);
		  if(num > 0)
		    {
		      if(found == 1)
			{
			  sprintf(membuf, "\r\n(%s %s)  ", CIRCLE_ABBR(tmp->spell), "circle");
			  strcat(memmed, membuf);
			  sprintf(membuf, "\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
			  strcat(memmed, membuf);
			  
			  found--;
			}
		      else
			{
			  sprintf(membuf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
			  strcat(memmed, membuf);
			  strcat(memmed, "\0");
			  memset(membuf, 0x0, 256);	
			}
		    }
		}
	    }
	  tmp = tmp->next;
	}
d1165 1
a1165 1
	{
d1170 1
a1170 1
	}
d1189 2
a1190 2
  if(memmed)	  
    send_to_char(memmed, ch);	  
d1203 1
a1203 1
	continue;
d1206 1
a1206 1
	return(0);
d1572 1
a1572 1
      add_scribing(ch);
a1675 163
/*
 * update_spell_scribe
 *
 * Send messages to everyone who's scribing about their progress,
 * if they did manage to make some progress.  End those whose
 * scribing has ended.
 *
 */

void update_spell_scribe(void) {
   struct char_data *ch, *nextch;
   struct scribing *cur, *next_scribing;
   struct obj_data *obj;
   struct obj_data *held_right = 0;
   struct obj_data *held_left = 0;
   int right_type = 0, left_type = 0, added;

   for (ch = scribing; ch; ch = nextch) {
      nextch = ch->next_scribing;

      /* Check for conditions that will interrupt scribing. */

      if (IS_FIGHTING(ch)) { 
         send_to_char("Your work is rudely interrupted!\r\n", ch);
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         goto next_scriber;
      }

      if (IS_DRUNK(ch)) {
         send_to_char("Sober up first, lush!\r\n", ch);
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         goto next_scriber;
      }
      
      if ((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING)) {
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         goto next_scriber;
      }

      if (ch->mem_status) {
         send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
         rem_scribing(ch);
         goto next_scriber;
      }

      /* Make sure writing instrument and book are held. */

      held_right = GET_EQ(ch, WEAR_HOLD);
      held_left = GET_EQ(ch, WEAR_HOLD2);

      if (held_right)
         right_type = GET_OBJ_TYPE(held_right);

      if (held_left)
         left_type = GET_OBJ_TYPE(held_left);

      if (right_type != ITEM_PEN && left_type != ITEM_PEN) {
         send_to_char("You need something to write with.\r\n", ch);
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         goto next_scriber;
      }
      
      if (right_type != ITEM_SPELLBOOK) {
         if (left_type != ITEM_SPELLBOOK) {
            send_to_char("You are no longer holding a spellbook.\r\n", ch);
            rem_scribing(ch);
            goto next_scriber;
         } else {
            obj = held_left;
         }
      } else {
         obj = held_right;
      }

      /* Can't scribe in the dark. */

      if (!LIGHT_OK(ch)) {
         send_to_char("It is too dark, so you stop scribing.\r\n", ch);
         act("Unable to see, $n gives up scribing.", TRUE, ch, 0, 0, TO_ROOM);
         rem_scribing(ch);
         goto next_scriber;
      }
      
      cur = ch->scribe_list;
      cur->scribe_time += 1;

      /* Did your teacher go away?  Lose your source book somehow? */

      if (!find_spellbook_with_spell(ch, cur->spell) &&
            !find_teacher_for_spell(ch, cur->spell)) {
         sprintf(buf, "You've lost your source for %s!\r\n",
               skill_name(cur->spell));
         send_to_char(buf, ch);
         send_to_char("&3With a weary sigh, you stop scribing.&0\r\n", ch);
         act("$n sighs and stops scribing.", TRUE, ch, 0, 0, TO_ROOM);
         rem_scribing(ch);
         goto next_scriber;
      }

      /* There is a chance to improve the scribe skill in each round of scribing. */

      if (number(1, 20) > 15) {
         improve_skill(ch, SKILL_SCRIBE);
      }

      if (cur->scribe_time >= PAGE_SCRIBE_TIME) {

         /* A page has been finished. */

         cur->scribe_time = 0;
         cur->pages_left -= 1;

         if (cur->pages_left > 0) {
            if (PAGE_SCRIBE_TIME > 1) {
               sprintf(buf, "You finish a page in your spellbook.\r\n");
               send_to_char(buf, ch);
            }
            goto next_scriber;
         }

         /* A spell has been finished. */

         /* Add this spell to the spellbook. */
         next_scribing = cur->next;
         added = add_spell_to_book(ch, obj, cur->spell);

         /* Any more spells in this person's scribe list? */

         if (!next_scribing) {
            sprintf(buf, "&6You have finished scribing %s.  &3You are done scribing.&0\r\n",
                  skill_name(cur->spell));
            send_to_char(buf, ch);
            rem_scribing(ch);
            goto next_scriber;
         } else {
            sprintf(buf, "&6You have finished scribing %s&0.\r\n",
                  skill_name(cur->spell));
            send_to_char(buf, ch);
         }

         rem_spell_scribe(ch, cur->spell);

         /* Scribe the next spell, if possible. */

         for (cur = next_scribing; cur; cur = next_scribing) {
            next_scribing = cur->next;
            if (start_scribing_spell(ch, obj, cur))
               goto next_scriber;
            rem_spell_scribe(ch, cur->spell);
         }

         /* None of the spells in the scribing list could be scribed. */

         rem_scribing(ch);
         send_to_char("&3You are done scribing.&0\r\n", ch);
      }
      next_scriber:;
   }
}
d1678 1
a1678 1
 * rem_scribing
d1680 1
a1680 1
 * Take a player out of the list of players who are scribing.
d1684 1
a1684 1
void rem_scribing(struct char_data *ch)
a1685 1
   struct char_data *temp, *prev;
d1688 6
a1693 25
  for (prev = temp = scribing; temp; temp = temp->next_scribing) {
      if (temp == ch) {
         if (ch == scribing) {
            this = ch->scribe_list;
            while (this) {
               rem_spell_scribe(ch, this->spell);
               this = ch->scribe_list;
            }
            ch->scribe_list = 0;
            scribing = ch->next_scribing;
            ch->next_scribing = 0;
         } else {
            this = ch->scribe_list;
            while(this) {
               rem_spell_scribe(ch, this->spell);
               this = ch->scribe_list;
            }
            ch->scribe_list = 0;
            prev->next_scribing = ch->next_scribing;
            ch->next_scribing = 0;        
         }
         REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
         return;
      }
   prev = temp;
d1695 1
d1754 1
a1754 1
 * add_scribing
d1756 1
a1756 1
 * Add a player to the list of players who are scribing.
d1760 1
a1760 1
void add_scribing(struct char_data *ch)
d1762 5
a1766 6
   if (scribing == 0)
      ch->next_scribing = 0;
   else
      ch->next_scribing = scribing;
   scribing = ch;
   SET_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
d1800 3
@


1.46
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.45 2008/01/01 04:33:08 jps Exp jps $
d393 1
a393 1
  save_char(ch);
d1865 4
d1881 1
a1881 1
 * save_char() no longer requires you to supply a save room (which
@


1.45
log
@Don't allow scribing of spells you don't know (including quest spells).
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.44 2007/12/28 23:34:59 jps Exp jps $
a202 24
int check_mem_mode(struct char_data *ch)
{
  switch (GET_CLASS(ch)) 
    { 
    case CLASS_MAGIC_USER:
    case CLASS_CRYOMANCER:
    case CLASS_PYROMANCER:
    case CLASS_NECROMANCER:
    case CLASS_CONJURER:
    case CLASS_RANGER:
    case CLASS_BARD:
      return MEMORIZE;
    case CLASS_CLERIC:
    case CLASS_DIABOLIST:
    case CLASS_DRUID:
    case CLASS_PRIEST:
    case CLASS_PALADIN:
    case CLASS_ANTI_PALADIN:
      return PRAY;
    default:
      return -1;
    }  
}

d212 1
a212 1
   if (check_mem_mode(ch) != MEMORIZE) {
d290 1
a290 1
  if(!ch || IS_NPC(ch))
d292 1
a292 1
  if(check_mem_mode(ch) != PRAY) {
d297 4
a300 5
  if(GET_LEVEL(ch) >= LVL_IMMORT)
    {
      send_to_char("You don't need to pray for spells to cast them.\r\n", ch);
      return;
    }
d304 3
a306 4
  if(!*argument)
    {
      show_spell_list(ch, FALSE);
    }
d591 1
a591 1
	     if(check_mem_mode(ch) == MEMORIZE)
d593 1
a593 1
	     if(check_mem_mode(ch) == PRAY)
d614 1
a614 1
  if(check_mem_mode(ch) == MEMORIZE)
d616 1
a616 1
  if(check_mem_mode(ch) == PRAY)
d708 1
a708 1
   if (check_mem_mode(ch) == MEMORIZE) {
d711 1
a711 1
   } else if (check_mem_mode(ch) == PRAY) {
d762 1
a762 1
         if (check_mem_mode(ch) == MEMORIZE) {
d782 1
a782 1
            if (check_mem_mode(ch) == MEMORIZE)
d784 1
a784 1
            else if (check_mem_mode(ch) == PRAY)
d916 1
a916 1
	      add_spell(ch, spell, check_mem_mode(ch), 
d996 1
a996 1
  if(check_mem_mode(ch) == MEMORIZE){
d1000 1
a1000 1
  if(check_mem_mode(ch) == PRAY){
d1865 3
@


1.44
log
@If you lose the source of a spell you're scribing (teacher or book),
you will stop scribing that spell. You must be able to see the source.
You cannot scribe in darkness. The update_spell_scribe() loop will
correctly process every scribing person, even if some of them abort
scribing due to difficulties. Cut back on the "you finished a page"
spam. Changed a lot of the feedback for scribing events.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.43 2007/12/19 20:56:05 myc Exp jps $
d231 14
a244 14
  int spell;
  
  if(!ch || IS_NPC(ch))
    return;
   if(check_mem_mode(ch) != MEMORIZE) 
     {
       send_to_char("You do not study sorcery.\r\n", ch);;
       return;
     }
   if(GET_LEVEL(ch) >= LVL_IMMORT)
     {
       send_to_char("You don't need to memorize spells to cast them.\r\n", ch);
       return;
     }
d247 1
a247 1
   
d249 8
a256 9
   if(!*argument)
     {
       show_spell_list(ch, FALSE);
       return;
     }
   
   if(IS_FIGHTING(ch)) {
     send_to_char("If you want to commit suicide just say so!\r\n", ch);
     return;
d260 2
a262 3
   if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
     send_to_char("You are not comfortable enough to study.\r\n", ch);
   
d265 42
a306 49
   else
     {
       spell = find_spell_num(argument);      
       if (!IS_SPELL(spell))
	 {
	   send_to_char("Memorize What?!\r\n", ch);
	   return;
	 }
       
       if((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])  
	 {
	   send_to_char("That spell is beyond your knowledge.\r\n", ch);
	   return;
	 }
       
       if(GET_SKILL(ch, spell) == 0)
	 {
	   send_to_char("You don't know that spell.\r\n", ch);
	   return;
	 }
       
       /* check number of spells already memmed against the spell_table */
       if(spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell))
	 {
	   sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
	   send_to_char(buf, ch);
	   return;
	 }
       /* check for a spellbook */
       if( !find_spellbook_with_spell(ch, spell) )
	 {
	   send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
	   return;
	 } 
		
       /* finally, the spell is available...add it to the list */
       else
	 {
	   ch->num_spells += add_spell(ch, spell, MEMORIZE, 0, ADD_NEW);
	   if(!ch->mem_status)
	     {
	       /* get the char started memming his list.. */
	       add_mem_list(ch);
	       if(!(ch->mem_status))
		 act("$n takes out $s books and begins to study.",TRUE,ch,0,0,TO_ROOM);
	       ch->mem_status = 1;
	     }
	 }
     }	
d1445 2
a1446 1
   if ((int)GET_LEVEL(ch) < spell_info[spellnum].min_level[(int)GET_CLASS(ch)])  {
d1891 8
@


1.43
log
@save_char() no longer requires you to supply a save room (which
wasn't being used anyway).
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.42 2007/10/20 19:01:18 myc Exp myc $
a26 5
/*#define GET_CIRCLE(s) (spell_info[(s)].min_circle[(int)GET_CLASS(ch)])*/
/*
#define GET_MEMMED_CIRCLE(s) ch->spells_memmed_circle[GET_CIRCLE(s)]
#define GET_MEMMED(c) ch->spells_memmed_circle[c]
*/
d64 1
a64 1
/* spell book stuff - Fingh 10/1/98 */
d68 2
a69 5
int has_spell_in_spellbook(struct char_data *ch, int spell);
/* only returns first book found */
struct obj_data *get_spellbook(struct char_data *ch);
int find_teacher_for_spell(struct char_data *ch, int spell);
int get_spellbookScribe(struct char_data *ch, int spell);
d296 1
a296 1
       if( !has_spell_in_spellbook(ch, spell) )
a778 16
      /*
      if (IS_HUNGRY(ch)) {
         send_to_char("You are too hungry too study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }
      
      if (IS_THIRSTY(ch)) {
         send_to_char("You are too thirsty to study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }
      */
      
d798 1
a798 1
            if (!has_spell_in_spellbook(ch, cur->spell) ) {
a835 2
/* rewritten and cleaned up by Fingh 11/15/98 to prevent mem abort
 * loops and crash bugs */
d863 1
a863 1
	}  /*  temp == ch */
a894 1
/* save_mem_list Completely redone by Fingon 2/3/1999 */
a1139 18

/*
 * GET_SPELLBOOK
 *
 * Find a spellbook in the character's inventory.
 *
 */

struct obj_data *get_spellbook(struct char_data *ch) {
   struct obj_data *obj;

   for(obj = ch->carrying; obj; obj = obj->next_content)
      if(obj->obj_flags.type_flag == ITEM_SPELLBOOK && CAN_SEE_OBJ(ch, obj))
      return obj;

   return 0;
}

d1155 1
a1155 1
 * has_spell_in_spellbook
d1157 1
a1157 2
 * Determine whether this person possesses a spellbook with the given
 * spell, whether in inventory or held.
d1161 1
a1161 1
int has_spell_in_spellbook(struct char_data *ch, int spell) {
d1166 1
a1166 1
         return TRUE;
d1171 1
a1171 1
      return TRUE;
d1175 1
a1175 1
      return TRUE;
d1177 1
a1177 1
   return FALSE;
a1299 1

a1337 1

d1368 2
a1369 1
   struct obj_data *book = 0, *pen;
d1385 9
d1399 1
a1399 1
   /* Make sure they are holding something to write with. */
d1410 1
a1410 1
   /* Identify the book to be written in. */
d1428 2
a1434 2
   /* Identify the spell to be scribed. */

d1444 5
a1448 2
   if (!find_teacher_for_spell(ch, spellnum) && !has_spell_in_spellbook(ch, spellnum)) {
      send_to_char("And just how do you expect to learn that spell?\r\n",ch);
d1485 1
a1485 1
   /* Make sure the player is in "scribing" mode. */
d1490 5
d1502 1
a1502 1
 * teach it.  Thus allowing someone to scribe it nearby.
d1506 1
a1506 1
int find_teacher_for_spell(struct char_data *ch, int spell) {
d1511 1
a1511 1
      if (dude == ch) continue;
d1523 1
a1523 1
      return TRUE;
d1526 1
a1526 1
   return FALSE;
d1536 2
a1537 1
int room_in_book(struct obj_data *obj, int pages) {
d1541 50
d1602 3
a1604 4
   struct char_data *ch = 0;
   struct scribing *cur = 0;
   struct obj_data *obj = 0;
   char scribebuf[256];
d1609 4
a1612 1
   ch = scribing;
a1613 4
   if (scribing == 0)
      return;
  
   while (ch) {
d1618 1
a1618 1
         return;
d1625 1
a1625 16
         return;
      }
      
      /*
      if (IS_HUNGRY(ch)) {
         send_to_char("You are too hungry to scribe.\r\n", ch);
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         return;
      }
      
      if (IS_THIRSTY(ch)) {
         send_to_char("You are too thirsty to scribe.\r\n", ch);
         send_to_char("You stop scribing.\r\n", ch);
         rem_scribing(ch);
         return;
a1626 1
      */
d1631 1
a1631 1
         return;
d1637 1
a1637 1
         return;
d1640 2
d1655 1
a1655 1
         return;
d1662 1
a1662 1
            return;
d1669 9
d1680 3
d1684 33
a1716 1
      while (cur) {
d1718 16
a1733 3
         cur->scribe_time += 1;
         if (number(1, 20) > 15) {
            improve_skill(ch, SKILL_SCRIBE);
d1736 9
a1744 24
         if (cur->scribe_time >= BASE_SCRIBE_TIME) {
            cur->scribe_time = 0;
            cur->pages_left -= 1;
            sprintf(scribebuf, "You finish a page in your spellbook.\r\n");
            send_to_char(scribebuf, ch);
            if (cur->pages_left <= 0) {
               sprintf(scribebuf, "You have finished scribing %s.\r\n", skill_name(cur->spell));
               send_to_char(scribebuf, ch);
               added = add_spell_to_book(ch, obj, cur->spell);
               rem_spell_scribe(ch, cur->spell);
               cur = ch->scribe_list;
               if (cur && cur->pages > pages_left_in_book(obj)) {
                  sprintf(scribebuf, "There is no room to scribe %s.\r\n", skill_name(cur->spell));
                  send_to_char(scribebuf, ch);
                  cur = NULL;
               }
               if (!cur || !added) {
                  send_to_char("You have finished writing spells.\r\n", ch);
                  act("$n finishes writing spells.", TRUE, ch, 0, 0, TO_ROOM);
                  rem_scribing(ch);          
               }
            } else {
               cur->scribe_time = 0;
            }
d1746 7
a1752 4
         /* make sure only one spell is finished each time through...*/
         cur = 0;
      }    
      ch = ch->next_scribing;
d1765 2
a1766 2
  struct char_data *temp, *prev;
  struct scribing *this;
d1768 26
a1793 31
  for(prev = temp = scribing; temp; temp = temp->next_scribing)
    {
      if(temp == ch)
	{
	  if(ch == scribing)
	    {
	      this = ch->scribe_list;
	      while(this) {
		rem_spell_scribe(ch, this->spell);
		this = ch->scribe_list;
	      }
	      ch->scribe_list = 0;
	      scribing = ch->next_scribing;
	      ch->next_scribing = 0;
	    }
	  else
	    {
	      this = ch->scribe_list;
	      while(this) {
		rem_spell_scribe(ch, this->spell);
		this = ch->scribe_list;
	      }
	      ch->scribe_list = 0;
	      prev->next_scribing = ch->next_scribing;
	      ch->next_scribing = 0;        
	    }
	  REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
	  return;
	}
      prev = temp;
    }
d1805 9
a1813 2
  struct scribing *cur, *prev;
  char scribebuf[256];
d1815 4
a1818 32
  /* initialize the ptr and check it before proceeding */
  
  if(!ch->scribe_list) {
    if(!(ch->scribe_list = (struct scribing *) malloc(sizeof(struct scribing))))
      return 0;
    ch->scribe_list->next = 0;
    cur = ch->scribe_list;
  } else {
    
     /*  iterate the list to add new spell at the END...SLOW and UGLY!!! */
    for(cur = ch->scribe_list; cur ; cur = cur->next)
      {
	if(cur->next == 0)
	  {
	    prev = cur;
	    if(!(cur = (struct scribing *) malloc(sizeof(struct scribing))))
	      return 0;
	    
	    prev->next = cur;
	    cur->next = 0;
	    break;
	  }
      }
  }      
  
  cur->spell = spell;
  cur->pages = get_spell_pages(ch, spell);
  cur->pages_left = get_spell_pages(ch, spell);
  cur->scribe_time = 0;
  sprintf(scribebuf, "You begin scribing %s.\r\n", skill_name(spell)); 
  send_to_char(scribebuf, ch);
  return 1;
d1826 1
d1832 1
a1832 2
  struct scribing *temp, *cur;
  cur = temp = ch->scribe_list;
d1834 15
a1848 27
  while(cur)
    {
      if(cur->spell == spell)
	{  
	  if(cur == ch->scribe_list)
	    {
	      ch->scribe_list = ch->scribe_list->next;
	      free(cur);
	      cur = 0;
	      return 1;
	    }
	  else
	    {
	      /* remove the spell, free the memory, and return found */
	      temp->next = cur->next;
	      free(cur);
	      cur = 0;
	      return 1;
	    }
	}
      else
	{
	  temp = cur;
	  cur = cur->next;       
	}
    }
  return 0;
d1860 1
a1860 3
  if(scribing == 0)
    {
      scribing = ch;
d1862 4
a1865 7
    }
  else
    {
      ch->next_scribing =  scribing;
      scribing = ch;
    }
  SET_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
d1884 1
a1884 1
   for(x = 1; x <= spell_info[spell].pages; x++) {
d1899 4
d1910 1
a1910 1
 * Stop hunger and thirst from interfering with hunger and thirst.
d1916 1
a1916 1
 * Use fine_spell_num() so that skills aren't considered when the
d1927 1
a1927 1
 * has_spell_in_spellbook was trying to operate on a null pointer.
@


1.42
log
@Meditate shouldn't be usable by NPC's because it sets the !BASH bit on them.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.41 2007/10/13 20:15:09 myc Exp myc $
d436 1
a436 1
  save_char(ch, NOWHERE);
d1892 3
@


1.41
log
@Added functions to find spell/skill/chant nums to spells.h
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.40 2007/09/21 18:07:32 jps Exp myc $
d480 5
a484 1
  if(GET_POS(ch) > POS_SITTING) {
d488 2
a489 4
  if (GET_CLASS(ch) == CLASS_WARRIOR || GET_CLASS(ch) == CLASS_THIEF ||  GET_CLASS(ch) == CLASS_ASSASSIN \
      || GET_CLASS(ch) == CLASS_MERCENARY || GET_CLASS(ch) == CLASS_MONK || GET_CLASS(ch) == CLASS_BERSERKER \
      || GET_CLASS(ch) == CLASS_ROGUE || GET_CLASS(ch) == CLASS_BARD) {
    send_to_char("You just can't seem to focus your mind enough.\r\n", ch);
d492 12
d1892 3
@


1.40
log
@Stop hunger and thirst from interfering with hunger and thirst.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.39 2007/09/02 22:31:57 jps Exp jps $
a44 1
extern int find_spell_num(char *name);
d1878 3
@


1.39
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.38 2007/08/07 01:30:45 jps Exp jps $
d774 1
d788 1
d1596 1
d1610 1
d1879 3
@


1.38
log
@Use fine_spell_num() so that skills aren't considered when the
input expected is a spell name.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.37 2007/07/31 23:44:36 jps Exp jps $
d768 1
a768 1
         send_to_char("You cannot study while intoxicated\r\n", ch);
d1875 4
@


1.37
log
@New macros IS_HUNGRY, IS_THIRSTY, IS_DRUNK.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.36 2007/07/31 16:54:05 jps Exp jps $
d45 1
a45 1
extern int find_skill_num(char *name);
d278 2
a279 2
       spell = find_skill_num(argument);      
       if((spell < 0) || (spell > MAX_SPELLS))
d359 2
a360 2
      spell = find_skill_num(argument);      
      if((spell < 1) || (spell > MAX_SPELLS))
d462 1
a462 1
  spell = find_skill_num(argument);      
d464 1
a464 1
  if((spell < 0) || (spell > MAX_SPELLS)) {
d1458 1
a1458 1
   spellnum = find_skill_num(argument);
d1460 1
a1460 1
   if ((spellnum < 0) || (spellnum > MAX_SPELLS)) {
d1875 3
@


1.36
log
@Cut memorization times in half.
Fix bug where you could finish memorization but not be told about it.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.35 2007/05/11 20:12:33 myc Exp jps $
d767 1
a767 1
      if (GET_COND(ch, DRUNK) > 0) { 
d774 1
a774 1
      if (GET_COND(ch, FULL) < 1) { 
d781 1
a781 1
      if (GET_COND(ch, THIRST) < 1) { 
d1587 1
a1587 1
      if (GET_COND(ch, DRUNK) > 0) { 
d1594 1
a1594 1
      if (GET_COND(ch, FULL) < 1) { 
d1601 1
a1601 1
      if (GET_COND(ch, THIRST) < 1) { 
d1875 4
@


1.35
log
@has_spell_in_spellbook was trying to operate on a null pointer.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.34 2007/04/15 08:30:49 jps Exp myc $
d736 12
d759 7
a765 9
  while(ch)
    {
      if(IS_FIGHTING(ch))
	{ 
	  send_to_char("Your studies are rudely interrupted!\r\n", ch);
	  send_to_char("You abort your studies.\r\n", ch);
	  rem_memming(ch);
	  return;
	}
d767 6
a772 7
      if(GET_COND(ch, DRUNK) > 0)
	{ 
	  send_to_char("You cannot study while intoxicated\r\n", ch);
	  send_to_char("You abort your studies.\r\n", ch);
	  rem_memming(ch);
	  return;
	}
d774 6
a779 7
      if(GET_COND(ch, FULL) < 1)
	{ 
	  send_to_char("You are too hungry too study.\r\n", ch);
	  send_to_char("You abort your studies.\r\n", ch);
	  rem_memming(ch);
	  return;
	}
d781 6
a786 7
      if(GET_COND(ch, THIRST) < 1)
	{ 
	  send_to_char("You are too thirsty to study.\r\n", ch);
	  send_to_char("You abort your studies.\r\n", ch);
	  rem_memming(ch);
	  return;
	}
d788 5
a792 7
      if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
	{
	  send_to_char("You abort your studies.\r\n", ch);
	  rem_memming(ch);
	  
          return;
	}
d794 4
a797 4
      if(PLR_FLAGGED(ch, PLR_SCRIBE)) {
	send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
	rem_memming(ch);
	return;
d800 24
d825 16
a840 71
      cur = ch->spell_list;
      while(cur)
	{
	  if(cur->can_cast)
	    cur = cur->next;
	  else  
	    {  
	      if(check_mem_mode(ch) == MEMORIZE)
		{
		  if( !has_spell_in_spellbook(ch, cur->spell) )
		    {
		      send_to_char("You need a spellbook with that spell written in it.\r\n",ch);
		      rem_memming(ch);
		      break;
		    } 
		} 
	      /* using pulse violence, which means we only update every _2_ seconds
		 please do NOT change this, unless you change in comm.c to
		 pulse_violence/2  
	      */
	      cur->mem_time -= 2;
	      
	      /*check meditate skill */
	      if(PLR_FLAGGED(ch, PLR_MEDITATE))
		{
/***************************************************************************
 *		  if(cur->mem_time <= ((int) (set_mem_time(ch, cur->spell) / 2) + 1))
 *		    {
 *		      if((number(1,110)) < GET_SKILL(ch, SKILL_MEDITATE))
 *			cur->mem_time = 0;
 ***************************************************************************/
		      if(number(0,20) > 15)
			improve_skill(ch, SKILL_MEDITATE);
/***************************************************************************
 *		    }
 ***************************************************************************/
		}
	      
	      if(cur->mem_time < 1)
		{
		  if(check_mem_mode(ch) == MEMORIZE)
		    sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
		  else if(check_mem_mode(ch) == PRAY)
		    sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
		  send_to_char(buf, ch);
		  
		  /* reset so the guy has to remem after casting it.*/
		  cur->mem_time = set_mem_time(ch, cur->spell);
		  cur->can_cast = 1;
		  ch->num_memmed++;
		  if(ch->num_memmed == ch->num_spells)
		    {
		      if(check_mem_mode(ch) == MEMORIZE) 
			{
			  send_to_char("You have completed your studies.\r\n", ch);
			  act("$n closes $s book and smiles.", TRUE, ch, 0, 0, TO_ROOM);
			}
		      else if(check_mem_mode(ch) == PRAY) 
			{
			  send_to_char("Your prayers are complete.\r\n", ch);
			  act("$n finishes praying to $s deity.", TRUE, ch, 0, 0, TO_ROOM);
			}
		      rem_memming(ch);          
		      cur = 0;
		    }
		}
	      /* make sure only one spell is finished each time through...*/
	      /* Fixed by Fingon                                          */
	      cur = 0;
	    }    
	}   
d842 1
a842 1
    }   
d882 1
a882 30
  double mem_time; /* base time of 30 seconds */
   /*     int mode = check_mem_mode(ch); */
   /*     int mem_time; */

  int chance = 0;
  
  /*    exp = ((float)(2*(GET_CIRCLE(spell) -1)) + 5.5) / ((float)(GET_LEVEL(ch) / 2) + 5);
	mem_time = pow(base_time, exp);
	if(mode == PRAY)
	mod = (float)((float)GET_RWIS(ch) / 18);
	if(mode == MEMORIZE)    
	mod = (float)((float)GET_RINT(ch) / 18);
	mem_time = mem_time / mod;
  */


/* OK, another NEW mem time calculation... base is 18 secs at
   the level the caster can access that spell, minus one per level
    above that... below is the old code, for reference... Selina 4-6-99

  mem_time = 33 ; 
   / * modify base to reflect level experience   * /
  mem_time -= (int)((NUM_SPELL_CIRCLES - GET_CIRCLE(spell))*2); 
  mem_time -= (int)((GET_LEVEL(ch)/6) * 1.5);
   / * modify for intelligence * /
  if(check_mem_mode(ch) == MEMORIZE)
    mem_time -= (int) (GET_INT(ch)/20);  
  else
    mem_time -= (int) (GET_WIS(ch)/20);
*/
d884 1
d886 2
a887 4
  /* Selandria (4-6-99)
     The base mem time for a spell is 18 seconds... minus one second
     for each level the char is above the minimum required for that spell.
  */
d889 12
a900 25
  mem_time = 18 - ((int)GET_LEVEL(ch) - spell_info[spell].min_level[(int)GET_CLASS(ch)]);

  if (mem_time < 4)
    mem_time = 4;

  /* Now adjust it for meditation... */
  if (PLR_FLAGGED(ch, PLR_MEDITATE))
  {
    improve_skill(ch, SKILL_MEDITATE);
    /* There's a 5% chance it will be a deep trance and take only 1 second... */
    chance = number(1, 100);
    if (chance <=5 && GET_SKILL(ch, SKILL_MEDITATE) > 99)
    {
      send_to_char("You go into a deep trance...\r\n", ch);
      act("$n falls into a deep trance...", TRUE, ch, 0, 0, TO_ROOM);
      mem_time = 1;
    }
    else
    {
      /* Otherwise, the meditate skill will reduce the time depending on how good it is... */ 
      switch (GET_SKILL(ch, SKILL_MEDITATE) / 10) {
      case 1:
      {
        mem_time = mem_time * .93;
        break;
d902 2
a903 51
      case 2:
      {
        mem_time = mem_time * .86;
        break;
      }
      case 3:
      {
        mem_time = mem_time * .79;
        break;
      }
      case 4:
      {
        mem_time = mem_time * .72;
        break;
      }
      case 5:
      {
        mem_time = mem_time * .65;
        break;
      }
      case 6:
      {
        mem_time = mem_time * .58;
        break;
      }
      case 7:
      {
        mem_time = mem_time * .51;
        break;
      }
      case 8:
      {
        mem_time = mem_time * .44;
        break;
      }
      case 9:
      {
        mem_time = mem_time * .37;
        break;
      }
      case 10:
      {
        mem_time = mem_time * .30;
        break;
      } }
    }

  }


  return (int)mem_time;
d1875 3
@


1.34
log
@Make scribing much, much faster. Also fix various idiosyncrasies related
to scribing and make it more user-friendly.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.33 2007/04/15 06:49:19 jps Exp jps $
d1319 1
a1319 1
   if (is_spellbook_with_spell(obj, spell) && CAN_SEE_OBJ(ch, obj))
d1323 1
a1323 1
   if (is_spellbook_with_spell(obj, spell) && CAN_SEE_OBJ(ch, obj))
d1993 4
@


1.33
log
@Checking whether there's room in a book to scribe another spell now
uses the actual number it would take to scribe, based on scribe skill.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.32 2007/04/15 05:15:07 jps Exp jps $
d1448 2
d1453 1
a1453 2
 * Called (sometime) during the scribing process, to add a spell to a
 * spellbook, and notify the writing character of the result.
d1458 1
a1458 1
   struct spell_book_list *entry, *pentry;
d1462 2
a1463 2
      send_to_char("The spell is already scribed into this book.\r\n", ch);
      return TRUE;
d1466 1
a1466 1
   pages = ch->scribe_list->pages;
d1474 3
a1476 11
      for (entry = obj->spell_book; entry; entry = entry->next) {
         if (!entry->next) {
            pentry = entry;
            CREATE(entry, struct spell_book_list, 1);      
            pentry->next = entry;
            entry->next = 0;
            entry->spell = spell;
            entry->spell_length = pages;
            return TRUE;
         }
      }
d1478 2
a1479 5
      CREATE(obj->spell_book, struct spell_book_list, 1);
      obj->spell_book->next = 0;
      obj->spell_book->spell = spell;
      obj->spell_book->spell_length = pages;
      return TRUE;   
d1482 3
a1484 2
   send_to_char("You were unable to copy that spell to your spellbook.\r\n", ch);
   return FALSE;
d1488 1
d1507 1
a1507 1
   return pages_used;
d1518 1
a1518 1
   int spellnum, pages_needed;
d1600 1
a1600 1
      send_to_char("The spell is already written in this book.\r\n", ch);
d1607 1
d1609 7
a1615 3
      sprintf(buf, "You'd need %d pages to scribe that, but $N only has %d pages left.",
            pages_needed, pages_left_in_book(book));
      act(buf, FALSE, ch, 0, book, TO_CHAR);
d1627 1
a1627 1
      act("$n picks up $s $o and starts writing.", TRUE, ch, pen,0,TO_ROOM);
d1684 7
a1690 7
  struct char_data *ch = 0;
  struct scribing *cur = 0;
  struct obj_data *obj = 0;
  char scribebuf[256];
  struct obj_data *held_right = 0;
  struct obj_data *held_left = 0;
  int right_type = 0, left_type = 0;
d1692 1
a1692 1
  ch = scribing;
d1694 2
a1695 2
  if(scribing == 0)
    return;
d1697 7
a1703 9
  while(ch)
    {
      if(IS_FIGHTING(ch))
	{ 
	  send_to_char("Your work is rudely interrupted!\r\n", ch);
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  return;
	}
d1705 6
a1710 7
      if(GET_COND(ch, DRUNK) > 0)
	{ 
	  send_to_char("Sober up first, lush!\r\n", ch);
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  return;
	}
d1712 6
a1717 7
      if(GET_COND(ch, FULL) < 1)
	{ 
	  send_to_char("You are too hungry to scribe.\r\n", ch);
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  return;
	}
d1719 6
a1724 7
      if(GET_COND(ch, THIRST) < 1)
	{ 
	  send_to_char("You are too thirsty to scribe.\r\n", ch);
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  return;
	}
d1726 10
a1735 11
      if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
	{
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  
          return;
	}
      if(ch->mem_status) {
	send_to_char("You can't memorize and scribe at the same time!\r\n", ch);
	rem_scribing(ch);
	return;
d1741 2
a1742 2
      if(held_right)
	right_type = GET_OBJ_TYPE(held_right);
d1744 2
a1745 2
      if(held_left)
	left_type = GET_OBJ_TYPE(held_left);
d1747 5
a1751 7
      if( right_type != ITEM_PEN ) {
	if( left_type != ITEM_PEN ) {
	  send_to_char("You need something to write with.\r\n", ch);
	  send_to_char("You stop scribing.\r\n", ch);
	  rem_scribing(ch);
	  return;
	}
d1754 8
a1761 8
      if( right_type != ITEM_SPELLBOOK ) {
	if( left_type != ITEM_SPELLBOOK ) {
	  send_to_char("You are no longer holding a spellbook.\r\n", ch);
	  rem_scribing(ch);
	  return;
	} else {
	  obj = held_left;
	}
d1763 1
a1763 1
	obj = held_right;
d1768 6
a1773 8
      while(cur)
	{
	  
	  cur->scribe_time += 1;
	  
	  if(number(1,20) > 15) {
	    improve_skill(ch, SKILL_SCRIBE);
	  }
d1775 28
a1802 26
	  if(cur->scribe_time >= BASE_SCRIBE_TIME)
	    {
	      cur->scribe_time = 0;
	      cur->pages_left -= 1;
	      sprintf(scribebuf, "You finish a page in your spellbook.\r\n");
	      send_to_char(scribebuf, ch);
	      if(cur->pages_left <= 0) {
		sprintf(scribebuf, "You have finished scribing %s.\r\n", skill_name(cur->spell));
		send_to_char(scribebuf, ch);
		add_spell_to_book(ch, obj, cur->spell);
		rem_spell_scribe(ch, cur->spell);
		cur = ch->scribe_list;
		if(!cur)
		  {
		    send_to_char("You have finished writing spells.\r\n", ch);
		    act("$n finishes writing spells.", TRUE, ch, 0, 0, TO_ROOM);
		    rem_scribing(ch);          
		  }
	      } else {
		cur->scribe_time = 0;
	      }
	    }
	  /* make sure only one spell is finished each time through...*/
	  /* Fixed by Fingon                                          */
	  cur = 0;
	}    
d1804 1
a1804 1
    }   
d1993 4
@


1.32
log
@"Scribe" alone just gets you an error msg because you can see the
spells by looking at the book now.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.31 2007/04/15 05:11:23 jps Exp jps $
a91 19
/* spell circle abbreviations 
const char *circle_abbrev[NUM_SPELL_CIRCLES +1] = {
	"!UNUSED!",
	" 1st",
	" 2nd",
	" 3rd",
	" 4th",
	" 5th",
	" 6th",
	" 7th",
	" 8th",
	" 9th",
	"10th",
	"11th",
	"12th",
	"13th",
	"14th"
};*/
	
d1392 2
d1496 22
d1526 1
a1526 1
   int spellnum;
d1614 5
a1618 2
   if (!room_in_book(book, spell_info[spellnum].pages)) {
      send_to_char("Your spellbook is too full for that spell.\r\n", ch);
d1673 1
a1673 10
   struct spell_book_list *entry;
   int pages_used = 0, pages_left = 0;

   for (entry = obj->spell_book; entry; entry = entry->next) {
      pages_used += entry->spell_length;
   }

   pages_left = obj->spell_book_length - pages_used;

   return pages_left >= pages;
d2004 4
@


1.31
log
@Big code cleanup. Can see spells in a book just by looking at it.
Pyros can only learn their pyro spells from pyros, and the same goes
for cryos (we have those guildmasters now).
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.30 2006/11/18 06:57:24 jps Exp jps $
d1574 2
d1804 1
a1804 1
		    act("$n removes $s spectacles and stops writing.", TRUE, ch, 0, 0, TO_ROOM);
d2005 5
@


1.30
log
@Minor typos
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.29 2006/11/08 09:16:04 jps Exp jps $
d71 4
a74 4
int AddSpellToBook(struct char_data *ch, struct obj_data *obj, int spell);
int FindSpellInBook(struct obj_data *obj, int spell);
int ListSpellsInBook(struct obj_data *obj, int spell_array[][MAX_SPELLBOOK_PAGES]);
int GetBookAtHand(struct char_data *ch, int spell);
d76 5
a80 5
struct obj_data *GetBook(struct char_data *ch);
int FindTeacher(struct char_data *ch, int spell);
int GetBookScribe(struct char_data *ch, int spell);
void ScribeList(struct char_data *ch, struct obj_data *obj);
int RoomInBook(struct obj_data *obj, int pages);
d324 1
a324 1
       if( !GetBookAtHand(ch, spell) )
d824 1
a824 1
		  if( !GetBookAtHand(ch, cur->spell) )
d1284 3
a1286 3
/* spellbooks */
/* mostly written by Feeblex */
/* completed by Fingon */
d1289 16
a1304 10
/* used for scribing */
struct obj_data *GetBook(struct char_data *ch)
{
  struct obj_data *cur_obj;
  
  for(cur_obj = ch->carrying; cur_obj; cur_obj = cur_obj->next_content)
    if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK && CAN_SEE_OBJ(ch, cur_obj))
      return cur_obj;
  
  return 0;  /* make sure returned pointer value is checked!!! */
d1307 9
d1317 2
a1318 26
/* used in do_memorize() */
int GetBookAtHand(struct char_data *ch, int spell)
{
  struct obj_data *cur_obj;
  
  for(cur_obj = ch->carrying; cur_obj; cur_obj = cur_obj->next_content)
    {
      if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)
	{
	  if( FindSpellInBook(cur_obj, spell) && CAN_SEE_OBJ(ch, cur_obj))
	    return TRUE;
	  else
	    continue;
	} /* end if */
    }
  cur_obj = ch->equipment[WEAR_HOLD];
  if(cur_obj && (cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)) {
      if( FindSpellInBook(cur_obj, spell) && CAN_SEE_OBJ(ch, cur_obj))
        return TRUE;
  } /* end if */
  cur_obj = ch->equipment[WEAR_HOLD2];
  if(cur_obj && (cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)) {
      if( FindSpellInBook(cur_obj, spell) && CAN_SEE_OBJ(ch, cur_obj))
        return TRUE;
  } /* end if */
  return FALSE;
d1321 7
d1329 17
a1345 13
int ListSpellsInBook(struct obj_data *obj, int spell_array[][MAX_SPELLBOOK_PAGES])
{
  struct spell_book_list *book;
  int sa_index = 0;
  if(!obj->spell_book || !obj->spell_book->spell) {
    return FALSE;
  }
  for(book = obj->spell_book; book; book = book->next) {
    spell_array[0][sa_index] = book->spell;
    spell_array[1][sa_index] = book->spell_length;
    sa_index++;
  }
  return TRUE;  
d1348 14
a1361 11
int FindSpellInBook(struct obj_data *obj, int spell)
{
  int index = 0;
  int spell_array[2][MAX_SPELLBOOK_PAGES];
  
  for(index = 0; index < obj->spell_book_length; index++) {
    spell_array[0][index] = 0;
    spell_array[1][index] = 0;
  }
  if( !ListSpellsInBook(obj, spell_array))
    {
d1363 33
a1395 5
    }
  for(index = 0; index < obj->spell_book_length; index++)
    {
      if(spell_array[0][index] == spell) {
	return TRUE;
d1397 3
a1399 2
    }
  return FALSE;      
d1402 37
a1438 8
/* this lists all spells in the first book found          */
/* function is a new addition to feeblex's code  --Fingon */
void ScribeList(struct char_data *ch, struct obj_data *obj)
{
  extern char *spells[];
  int index = 0, spage = 0, fpage = 0;
  int spell_array[2][MAX_SPELLBOOK_PAGES];
  char list_buf[MAX_STRING_LENGTH];
d1440 12
a1451 9
  for (index = 0; index < obj->spell_book_length; index++) {
    spell_array[0][index] = 0;
    spell_array[1][index] = 0;
  }
  if (!ListSpellsInBook(obj, spell_array)) {
    send_to_char("The spellbook is blank.\r\n", ch);
    return;
  }
  sprintf(list_buf, "&7&b---Spellbook Contents---&0\r\n"); 
d1453 7
a1459 2
  /* display the spell on each page, but don't allow PC to read spells */
  /* that aren't available to his level/class  heheheheh               */
d1461 2
a1462 21
  index = 0;
  while(spell_array[0][index]) {
    spage = fpage + 1;
    fpage = fpage + spell_array[1][index];
    if((int)GET_LEVEL(ch) < spell_info[spell_array[0][index]].min_level[(int)GET_CLASS(ch)]) {
      sprintf(list_buf, "%s&6%3d-%3d)&0 &5--Unreadable--&0\n", list_buf, spage, fpage);
    } else {
      sprintf(list_buf, "%s&6%3d-%3d)&0 &6&b%s&0\n",
              list_buf, spage, fpage, spells[spell_array[0][index]]);
    }
    index++;
  }
  if (((obj->spell_book_length - fpage) > 1)) {
    sprintf(list_buf, "%s&6%3d-%3d)&0 &4&b--Blank--&0\n",
	    list_buf, fpage + 1, obj->spell_book_length);
  } else if ((obj->spell_book_length - fpage) == 1) {
    sprintf(list_buf, "%s    &6%3d)&0 &4&b--Blank--&0\n",
	    list_buf, obj->spell_book_length);
  }
  send_to_char(list_buf, ch);
  return;      
d1465 18
a1482 9
/* completely rewritten by fingon */
int AddSpellToBook(struct char_data *ch, struct obj_data *obj, int spell) {
  struct spell_book_list *book, *pbook;
  int pages;

  if(FindSpellInBook(obj, spell)) {
    send_to_char("The spell is already scribed into this book.\r\n", ch);
    return TRUE;
  }
d1484 4
a1487 1
  pages = ch->scribe_list->pages;
d1489 11
a1499 14
  if(!RoomInBook(obj, pages)) {
    send_to_char("Your spellbook is too full for that spell.\r\n", ch);
    return FALSE;
  }
  if(obj->spell_book) {
    for(book = obj->spell_book; book; book = book->next) {
      if(!book->next) {
        pbook = book;
        CREATE(book, struct spell_book_list, 1);      
        pbook->next = book;
        book->next = 0;
        book->spell = spell;
        book->spell_length = pages;
        return TRUE;
d1501 10
a1510 10
    }
  } else {
    CREATE(obj->spell_book, struct spell_book_list, 1);
    obj->spell_book->next = 0;
    obj->spell_book->spell = spell;
    obj->spell_book->spell_length = pages;
    return TRUE;   
  }
  send_to_char("You were unable to copy that spell to your spellbook.\r\n", ch);
  return FALSE;
d1513 5
a1517 5
/* okay, here we add the spell to the book.  there are a
 * few different cases for adding a spell to a spell book:
 * 1. to book from teacher
 * 2. to book from another PC
 * 3. to book from another book
a1518 7
ACMD(do_scribe)
{
  int spellnum;
  struct obj_data *obj = 0;
  struct obj_data *held_right = GET_EQ(ch, WEAR_HOLD);
  struct obj_data *held_left = GET_EQ(ch, WEAR_HOLD2);
  int right_type = 0, left_type = 0;
d1520 10
a1529 4
  if(IS_NPC(ch))
    return;
  
  /* no argument, just list spells scribed in current book -Fingon */
d1531 1
d1533 2
a1534 3
  if(IS_FIGHTING(ch))
    {
      send_to_char("If you wanna commit suicide just say so!.\r\n",ch);
d1536 1
a1536 1
    }
d1538 13
a1550 9
  if(held_right)
    right_type = GET_OBJ_TYPE(held_right);
  if(held_left)
    left_type = GET_OBJ_TYPE(held_left);
  
  if(!*argument) {
    if(right_type == ITEM_SPELLBOOK) {
      obj = held_right;
      ScribeList(ch, obj);
d1552 10
a1561 3
    } else if (left_type == ITEM_SPELLBOOK) {
      obj = held_left;
      ScribeList(ch, obj);
d1563 6
a1568 2
    } else {
      send_to_char("What do you intend to read from, your hand?\r\n", ch);
d1570 1
a1570 2
    }
  }
d1572 2
a1573 6
  if( right_type != ITEM_PEN ) {
    if( left_type != ITEM_PEN ) {
      send_to_char("What do you intend to write with, your finger?\r\n", ch);
      return;
    }
  }
d1575 1
a1575 10
  if( right_type != ITEM_SPELLBOOK ) {
    if( left_type != ITEM_SPELLBOOK ) {
      send_to_char("What do you intend to write on, your hand?\r\n", ch);
      return;
    } else {
      obj = held_left;
    }
  } else {
    obj = held_right;
  }
d1577 1
a1577 5
  if(GET_POS(ch) > POS_SITTING || GET_POS(ch) < POS_RESTING)
    {
      send_to_char("You have to be sitting to scribe.\r\n",ch);
      return;
    }
d1579 1
a1579 11
  /* okay, there are one, maybe two arguments depending on 
   * what the guy is scribing from.  typcially, he will scribe
   * while being taught by a teacher.  sometimes he might scribe from a
   * spellbook, or from another PC.  The latter two examples require an
   * argument.
   */
  
  spellnum = find_skill_num(argument);
  
  if((spellnum < 0) || (spellnum > MAX_SPELLS))
    {
d1582 3
a1584 3
    }
  
  /* no pc or NPC teacher && no book or teacher isn't high enough level for spell*/
d1586 1
a1586 2
  if(!FindTeacher(ch, spellnum) && !GetBookAtHand(ch, spellnum))
    {
d1589 5
a1593 4
    } 
  
  if((int)GET_LEVEL(ch) < spell_info[spellnum].min_level[(int)GET_CLASS(ch)])  
    {
d1596 19
a1614 1
    }
d1616 1
a1616 4
  if(FindSpellInBook(obj, spellnum)) {
    send_to_char("The spell is already scribed into this book.\r\n", ch);
    return;
  }
d1618 1
a1618 8
  if(!RoomInBook(obj, spell_info[spellnum].pages)) {
    send_to_char("Your spellbook is too full for that spell.\r\n", ch);
    return;
  }
  
  if(obj) {
    add_spell_scribe(ch, spellnum);
    if(!PLR_FLAGGED(ch, PLR_SCRIBE)) {
d1620 2
a1621 6
      act("$n puts on $s spectacles and begins writing.",TRUE,ch,0,0,TO_ROOM);
    }
  } else {
    /* we should never get here */
    send_to_char("You need a book to scribe.\r\n",ch);
  }
d1624 14
a1637 5
/* this guy is gonna scribe, but wait! Is there someone to show it to him?... */
int FindTeacher(struct char_data *ch, int spell)
{
  struct char_data *dude;
  int dude_cl = 0;
d1639 1
a1639 1
  /* added check to make sure the teacher has level required for spell --fingon */
d1641 2
a1642 2
  for (dude = world[ch->in_room].people ; dude ; dude = dude->next_in_room) {
    if(MOB_FLAGGED(dude, MOB_TEACHER)) { 
d1644 1
a1644 3
      if(GET_LEVEL(dude) >= spell_info[spell].min_level[(int)GET_CLASS(dude)]) {
	return TRUE;
      }
d1646 2
a1647 21
      /* OK, this next section is a hack that will allow pyro/cryo PC's
	 to scribe from necro/conj/sorc teacher mobs since there is currently no
	 pyro/cryo mob type.  The level of the teacher mob is still taken
	 into account for the spell being taught. --Fingon
      */
      dude_cl = GET_CLASS(dude);
      if(dude_cl == MCLASS_NECROMANCER ||
	 dude_cl == MCLASS_CONJURER ||
	 dude_cl == MCLASS_SORCERER) {
	if(GET_CLASS(ch) == CLASS_PYROMANCER) {
	  if(GET_LEVEL(dude) >= spell_info[spell].min_level[CLASS_PYROMANCER]) {
	    return TRUE;
	  }
	}
	if(GET_CLASS(ch) == CLASS_CRYOMANCER) {
	  if(GET_LEVEL(dude) >= spell_info[spell].min_level[CLASS_CRYOMANCER]) {
	    return TRUE;
	  }
	}
      }
      /* end of badly hacked pyro/cryo scribe code. */
d1649 2
a1650 2
    }  
  }
d1652 1
a1652 1
  return FALSE;
d1654 1
d1656 17
a1672 6
int GetBookScribe(struct char_data *ch, int spell)
{
  if(GetBookAtHand(ch, spell))
    return TRUE;
  else
    return FALSE;
a1673 4
*/
int RoomInBook(struct obj_data *obj, int pages) {
  struct spell_book_list *book;
  int pages_used = 0, pages_left = 0;
a1674 3
  for(book = obj->spell_book; book; book = book->next) {
    pages_used += book->spell_length;
  }
d1676 8
a1683 6
  pages_left = obj->spell_book_length - pages_used;
  if(pages_left >= pages) {
    return TRUE;
  }
  return FALSE;
}
d1685 1
a1685 2
void update_spell_scribe(void)
{
d1796 1
a1796 1
		AddSpellToBook(ch, obj, cur->spell);
d1817 7
d1862 7
d1909 7
a1915 1
/* remove a spell from the characters scribe list */
d1950 7
d1972 9
d1983 2
a1984 2
  float pages = 0, factor;
  int x;
d1986 1
a1986 1
  factor = (100 - (float)GET_SKILL(ch, SKILL_SCRIBE))/100;
d1988 8
a1995 7
  for(x = 1; x <= spell_info[spell].pages; x++) {
    pages += factor;
  }
  if (pages < 1)
    return 1;
  else
    return (int)pages + 1;
d2003 3
@


1.29
log
@Fixed some loose-lose typos.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.28 2006/11/07 09:32:46 jps Exp jps $
d265 1
a265 1
       send_to_char("You do not study sorcery.", ch);;
d326 1
a326 1
	   send_to_char("You need a spellbook with that spell written* in it.",ch);
d826 1
a826 1
		      send_to_char("You need a spellbook with that spell written* in it.",ch);
d1419 1
a1419 1
    send_to_char("The spell is already scribed into this book.", ch);
d1426 1
a1426 1
    send_to_char("Your spellbook is too full for that spell.", ch);
d1552 1
a1552 1
    send_to_char("The spell is already scribed into this book.", ch);
d1557 1
a1557 1
    send_to_char("Your spellbook is too full for that spell.", ch);
d1921 3
@


1.28
log
@Prevent memorizing/praying/scribing skills.
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.27 2002/09/13 02:32:10 jjl Exp $
d1127 1
a1127 1
      /* loose spells that ch doesn't have the level for */
d1921 3
@


1.27
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: spell_mem.c,v 1.26 2000/11/25 02:33:15 rsd Exp $
d298 1
a298 1
       if((spell < 0) || (spell > MAX_SKILLS))
d379 1
a379 1
      if((spell < 0) || (spell > MAX_SKILLS))
d483 1
a483 1
  if((spell < 0) || (spell > MAX_SKILLS)) {
d1531 1
a1531 1
  if((spellnum < 0) || (spellnum > MAX_SKILLS))
d1921 3
@


1.26
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: spell_mem.c,v 1.25 2000/04/22 22:40:15 rsd Exp $
d545 1
a545 1
	// iterate the list to add new spell at the END...SLOW and UGLY!!!
d840 6
a845 4
//		  if(cur->mem_time <= ((int) (set_mem_time(ch, cur->spell) / 2) + 1))
//		    {
//		      if((number(1,110)) < GET_SKILL(ch, SKILL_MEDITATE))
//			cur->mem_time = 0;
d848 3
a850 1
//		    }
d919 1
a919 1
	} // temp == ch
d922 1
a922 1
    } // end for
d928 2
a929 2
  //    int mode = check_mem_mode(ch);
  //    int mem_time;
d948 1
a948 1
  //modify base to reflect level experience  
d951 1
a951 1
  //modify for intelligence
d1824 1
a1824 1
    // iterate the list to add new spell at the END...SLOW and UGLY!!!
d1919 117
a2035 111
// $Log: spell_mem.c,v $
// Revision 1.25  2000/04/22 22:40:15  rsd
// fixed spelling of deity in player output, retabbed and braced
// sections of code. Warrior types can no longer meditate.
//
// Revision 1.24  1999/11/28 23:56:19  cso
// noted a memory leak. isn't fixed yet, but i marked it for later fixing
//
// Revision 1.23  1999/10/04 21:27:28  rsd
// Removed the include for mudmath.h because it's obsolete now.
//
// Revision 1.22  1999/09/10 01:40:10  mtp
// can mem from help spellbook too now
//
// Revision 1.21  1999/09/10 00:45:28  mtp
// IS_MONK doesnt exists..used GET_CLASS=CL=CLASS_MONK
//
// Revision 1.20  1999/09/10 00:31:41  mtp
// stop warriror/thief from meditiaating
// it didnt do anything for them anyway bt *shrug*
//
// Revision 1.19  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.18  1999/07/20 19:45:51  jimmy
// This is the spanky New Spell recognition code.
// This code allows mobs/players that have the KNOW_SPELL skill
// to make a skill check to guess the spell.  A good roll will show both
// the spell and the target.  A bad roll will show the spell garbled and
// then an INT check for the target.  If a really bad roll is made, the spell
// will be replaced by an incorrect one.  the heart of this system is
// start_chant(), end_chant, and bad_guess().
// --gurlaek 7/20/1999
//
// Revision 1.17  1999/04/24 06:46:52  jimmy
// changed to work with new pedantic flag --gurlaek
//
// Revision 1.16  1999/04/16 05:49:17  jimmy
// initialized ch->num_memmed in assign_mem_list() to fix the
// problem with not being able to tell when you were finished
// memming after you leveled without renting and coming back or
// forgetting all first.  Gurlaek.
//
// Revision 1.15  1999/04/07 18:14:32  jen
// Added some messages about meditating... perhaps fixed the improve for meditating
//
// Revision 1.14  1999/04/07 16:57:41  jen
// Added a msg to chars for deep trances
//
// Revision 1.13  1999/04/07 15:38:11  jen
// Changed spell mem & prayer times to Scott's new system... JEN II
//
// Revision 1.12  1999/03/31 21:32:15  dce 
// Fixed a huge crash bug. Ch->spell_list wasn't check to see if it
// was initialized upon adding a spell.
// 
// Revision 1.11  1999/03/24 23:43:16  jimmy
// Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
// quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
// learn from any sorcerer type teacher
// fingon
//
// Revision 1.10  1999/03/03 20:11:02  jimmy
// Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
// Spellbooks now have to be held to scribe as well as a quill in the other hand.
// 
// -fingon
//
// Revision 1.9  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
//
// Revision 1.8  1999/02/16 08:53:46  jimmy
// Debugged and re-enabled spell books.  Added function to list all spells
// scribed in a book.  Added checks so teachers only teach spells appropriate
// to thier level.  Also, added checks so that players can't see spells above
// thier level in spellbooks.
// Fingon
//
// Revision 1.7  1999/02/12 15:33:17  jimmy
// Brand new spell table, thanks to Zzur
// Glad I didnt' have to do it...
// fingon
//
// Revision 1.6  1999/02/11 22:17:40  jimmy
// Moved spell circles to every 8 levels.  Filled in the
// spells array to extend from level 70 to 105.
// fingon
//
// Revision 1.5  1999/02/11 19:21:33  jimmy
// Fixed spell mem bug.  High level casters would mem all of their
// low level spells instantly when they got to them in the mem
// list.  All mem times are now cumulative.
// fingon
//
// Revision 1.4  1999/02/03 20:54:47  jimmy
// If this doesn't fix spellcaster/leveling problems im gonna scream
//
// Revision 1.3  1999/02/03 18:11:43  jimmy
// Fixed yet more bugs with spellcasters and leveling
// Fhope this does it.
//
// Revision 1.2  1999/02/02 19:15:20  mud
// Indented entire file.
//
// Revision 1.1  1999/01/29 01:23:32  mud
// Initial revision
//
@


1.25
log
@fixed spelling of deity in player output, retabbed and braced
sections of code. Warrior types can no longer meditate.
@
text
@d1 12
a12 9
// $Id: spell_mem.c,v 1.24 1999/11/28 23:56:19 cso Exp $
/*********************************************************************
 * File: spell_mem.c                                Part of FieryMUD *
 * Usage: This file contains all of the code for spell_memorization. *
 * By: Someone of HubisMUD maybe                                     *
 *                                                                   *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium  *
 *  FieryMUD is based on HubisMUD Copyright (C) 1997, 1998.          *
 *********************************************************************/
d1914 4
d1936 87
@


1.24
log
@noted a memory leak. isn't fixed yet, but i marked it for later fixing
@
text
@d1 1
a1 1
// $Id: spell_mem.c,v 1.23 1999/10/04 21:27:28 rsd Exp $
d5 1
d7 2
a8 2
 * By: Someone of HubisMUD maybe                                     *
 * Last Modified: 10-4-98                                            *
d368 1
a368 1
    send_to_char("You are not comfortable enough to pray to your diety.\r\n", ch);
d409 1
a409 1
		act("$n begins praying to $s diety.",TRUE,ch,0,0,TO_ROOM);
d461 4
a464 5
  if(!ch || IS_NPC(ch) || GET_LEVEL(ch) >= LVL_IMMORT) 
    {
      send_to_char("You have no need to forget spells.\r\n",ch);
      return;
    }
d466 4
a469 5
  if(!argument)
    {
      send_to_char("Are you trying to forget something in particular?\r\n", ch);
      return;
    }
d471 4
a474 5
  if(is_abbrev(argument, "all"))
    {
      wipe_mem(ch);
      return;
    }
d478 10
a487 4
  if((spell < 0) || (spell > MAX_SKILLS))
    {
      send_to_char("Forget What?!\r\n", ch);
      return;
d489 1
a489 13
  else
    {
      if(rem_spell(ch, spell))
	{
          sprintf(buf, "You purge %s from your memory.\r\n", skill_name(spell));
          send_to_char(buf, ch);
	}
      else
	{
          sprintf(buf, "You do not have that spell memorized!\r\n");
          send_to_char(buf, ch);
	}
    }  
d495 8
a502 11
  if(GET_POS(ch) > POS_SITTING)
    {
      send_to_char("Try resting first....\r\n", ch);
      return;
    }
  if (IS_WARRIOR(ch)   ||
      IS_THIEF(ch)     ||
      IS_ASSASSIN(ch)  ||
      IS_MERCENARY(ch) ||
      (GET_CLASS(ch) == CLASS_MONK))  {
    send_to_char("You just can't seem to focus your mind enough.\r\n",ch);
d505 1
d509 1
a509 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
d866 1
a866 1
			  act("$n finishes praying to $s diety.", TRUE, ch, 0, 0, TO_ROOM);
d1911 3
@


1.23
log
@Removed the include for mudmath.h because it's obsolete now.
@
text
@d1 1
a1 1
// $Id: spell_mem.c,v 1.22 1999/09/10 01:40:10 mtp Exp $
d542 1
d1921 3
@


1.22
log
@can mem from help spellbook too now
@
text
@d1 1
a1 1
// $Id: spell_mem.c,v 1.21 1999/09/10 00:45:28 mtp Exp mtp $
a9 1
#include "mudmath.h"
d1920 3
@


1.21
log
@IS_MONK doesnt exists..used GET_CLASS=CL=CLASS_MONK
@
text
@d1 1
a1 1
// $Id: spell_mem.c,v 1.20 1999/09/10 00:31:41 mtp Exp mtp $
d1318 10
d1921 3
@


1.20
log
@stop warriror/thief from meditiaating
it didnt do anything for them anyway bt *shrug*
@
text
@d1 1
a1 1
// $Id: spell_mem.c,v 1.19 1999/09/05 07:00:39 jimmy Exp mtp $
d513 1
a513 1
      IS_MONK(ch))  {
d1911 4
@


1.19
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d509 8
d1910 4
a1913 1
// $Log$
@


1.18
log
@This is the spanky New Spell recognition code.
This code allows mobs/players that have the KNOW_SPELL skill
to make a skill check to guess the spell.  A good roll will show both
the spell and the target.  A bad roll will show the spell garbled and
then an INT check for the target.  If a really bad roll is made, the spell
will be replaced by an incorrect one.  the heart of this system is
start_chant(), end_chant, and bad_guess().
--gurlaek 7/20/1999
@
text
@d1 1
d1902 1
@


1.17
log
@changed to work with new pedantic flag --gurlaek
@
text
@a26 2
#define MEMORIZE	0
#define PRAY		1
@


1.16
log
@initialized ch->num_memmed in assign_mem_list() to fix the
problem with not being able to tell when you were finished
memming after you leveled without renting and coming back or
forgetting all first.  Gurlaek.
@
text
@d69 1
a69 1
int ListSpellsInBook(struct obj_data *obj, int spell_array[][obj->spell_book_length]);
d1315 1
a1315 1
int ListSpellsInBook(struct obj_data *obj, int spell_array[][obj->spell_book_length])
d1333 1
a1333 1
  int spell_array[2][obj->spell_book_length];
d1358 1
a1358 1
  int spell_array[2][obj->spell_book_length];
@


1.15
log
@Added some messages about meditating... perhaps fixed the improve for meditating
@
text
@a858 1
		  
d1071 2
@


1.14
log
@Added a msg to chars for deep trances
@
text
@d422 6
a427 1
  REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d510 1
d905 7
a911 2
	  
	  REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d967 1
d973 1
@


1.13
log
@Changed spell mem & prayer times to Scott's new system... JEN II
@
text
@d959 2
d962 1
@


1.12
log
@Fixed a huge crash bug. Ch->spell_list wasn't check to see if it
was initialized upon adding a spell.
@
text
@d832 4
a835 4
		  if(cur->mem_time <= ((int) (set_mem_time(ch, cur->spell) / 2) + 1))
		    {
		      if((number(1,110)) < GET_SKILL(ch, SKILL_MEDITATE))
			cur->mem_time = 0;
d838 1
a838 1
		    }
d914 2
a915 3
  /* Here's the happy new mem time code... if you want to make mem times,
     slower or faster, the variable base_time is the base seconds, just
     change that to tweek it - Nechtrous */
d925 6
d940 79
a1018 8
  
  /* cap the mem time in case any wackiness happens   */
  if(mem_time > 40)
    mem_time = 40;
  /*  modify in case mem_time has gone below or at 0 */ 
  if (mem_time <= 1)
    mem_time = 2;
  
@


1.11
log
@Working on quest spells.  Still in progress.  HOwever, spell_info[] array now has a flag
quest.  If it's true then it's considerd a quest spell.  Also, allowed pyro/cryo's to
learn from any sorcerer type teacher
fingon
l.
@
text
@d528 1
a528 1
  if(((ch->num_spells == 0) && (add_type == ADD_NEW)) || ((ch->spell_list == 0) && (add_type == RESTORE_CHAR)))
@


1.10
log
@Many enhancements to scribe and spellbooks.  Lots of checks added.  Scribe is now a skill.
Spellbooks now have to be held to scribe as well as a quill in the other hand.

-fingon
@
text
@d1016 10
a1025 1
      SET_SKILL(ch, i, 1000);
d1027 2
d1031 1
a1031 2
  }  

d1468 2
a1469 1
  
d1471 33
a1503 4
  for (dude = world[ch->in_room].people ; dude ; dude = dude->next_in_room)
    if(MOB_FLAGGED(dude, MOB_TEACHER) && GET_LEVEL(dude) >= spell_info[spell].min_level[(int)GET_CLASS(dude)])
      return TRUE;
  
@


1.9
log
@Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
and take 20 seconds to scribe each page.  This will be more dynamic when the
SCRIBE skill is introduced.  --Fingon.
@
text
@d76 1
a76 1
int RoomInBook(struct obj_data *obj, int spell);
d82 1
d269 1
d276 1
d279 5
d285 2
a286 1
   else if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
d290 1
d319 7
a325 1
       
d760 8
d799 8
a806 1
      
d814 9
a822 9
	            if(check_mem_mode(ch) == MEMORIZE)
	            {
	              if( !GetBookAtHand(ch, cur->spell) )
	              {
	                send_to_char("You need a spellbook with that spell written* in it.",ch);
	                rem_memming(ch);
	                break;
	              } 
	            } 
d1064 1
a1064 1
  char buf[256];
d1096 4
a1099 4
			  sprintf(buf, "\r\n(%s %s)  ", CIRCLE_ABBR(tmp->spell), "circle");
			  strcat(memmed, buf);
			  sprintf(buf, "\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
			  strcat(memmed, buf);
d1105 2
a1106 2
			  sprintf(buf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
			  strcat(memmed, buf);
d1108 1
a1108 1
			  memset(buf, 0x0, 256);	
d1123 2
a1124 2
          sprintf(buf, "   %2d seconds: (%s) %-20s\t\t  \r\n", tmp->mem_time, CIRCLE_ABBR(tmp->spell), skill_name(tmp->spell));
          strcat(to_mem, buf);
d1135 2
a1136 2
      sprintf(buf, "\r\n   %d seconds remaining\r\n", list_time);
      strcat(to_mem, buf);
d1142 2
a1143 2
      sprintf(buf, "   None!\r\n");
      strcat(memmed, buf);
d1186 1
a1186 1
    if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)
d1202 1
a1202 1
	  if( FindSpellInBook(cur_obj, spell) )
a1207 1
  
d1297 1
a1297 1
  int spell_length = 5;
d1303 4
a1306 1
  if(!RoomInBook(obj, spell)) {
d1318 1
a1318 1
        book->spell_length = spell_length;
d1326 1
a1326 2
    obj->spell_book->spell_length = spell_length;
    send_to_char("You write the spell in your spellbook.",ch);
d1343 3
d1352 2
a1353 1
  if(!*argument)
d1355 34
a1388 5
      if((obj = GetBook(ch))) {
        ScribeList(ch, obj);
      } else {
        send_to_char("Scribe what? Where?\r\n", ch);
      }
d1390 2
d1393 4
d1402 1
a1402 1
  
d1420 1
a1420 1
  if(!FindTeacher(ch, spellnum) && !GetBookScribe(ch, spellnum))
d1431 10
a1440 2
  
  obj = GetBook(ch);
a1442 1

d1449 1
d1466 1
a1466 1

d1474 2
a1475 2

int RoomInBook(struct obj_data *obj, int spell) {
d1484 1
a1484 1
  if(pages_left >= 5) {
d1496 4
a1499 1
  
d1507 8
d1546 35
d1583 1
d1586 1
d1588 6
a1593 1
	  if(cur->scribe_time == BASE_SCRIBE_TIME)
d1595 3
a1597 1
	      sprintf(scribebuf, "You scribe another page in your spellbook.\r\n");
d1599 1
a1599 2
	      cur->pages_left -= 1;
	      if(cur->pages_left == 0) {
a1601 2
		/* need to add lots of stuff here to check */
		obj = GetBook(ch);
d1604 2
a1605 1
		if(!cur->next)
a1609 1
		    cur = 0;
d1626 2
a1627 1
  
d1634 6
d1645 6
a1653 1
	  log("removed from scribe list");
a1656 1
      
d1664 2
a1665 1
  
d1692 2
a1693 1
  cur->pages_left = 5;
d1695 2
a1696 3
  
  sprintf(buf, "You begin scribing %s, which will take %d seconds.\r\n", skill_name(spell), BASE_SCRIBE_TIME * cur->pages_left); 
  send_to_char(buf, ch);
a1701 2
/* need to check if spell is last removed and remove SCIRBE flag if so */

d1706 1
a1713 1
	      
a1721 1

a1747 1
  log("added to scribe list");
d1750 20
@


1.8
log
@Debugged and re-enabled spell books.  Added function to list all spells
scribed in a book.  Added checks so teachers only teach spells appropriate
to thier level.  Also, added checks so that players can't see spells above
thier level in spellbooks.
Fingon
@
text
@d67 3
a69 3
int AddSpellToBook(struct char_data *ch, struct obj_data *book, int spell);
int FindSpellInBook(struct obj_data *book, int spell);
int ListSpellsInBook(struct obj_data *book, int *spell_array);
d75 7
a81 1
void ScribeList(struct char_data *ch, struct obj_data *book);
d85 1
a1147 2
#define SPELLBOOK_MAX_STRING 128
#define SPELLBOOK_PAGES 100
d1182 1
a1182 1
int ListSpellsInBook(struct obj_data *book, int *spell_array)
d1184 3
a1186 14
  struct extra_descr_data * tmp;
  int index = 0, PSE_Present = 0, sa_index = 0;
  char *parsenum;
  char *desc_ptr;
  
  for(tmp = book->ex_description; tmp; tmp = tmp->next)
    if( strcmp(tmp->keyword, "PSE") == 0) /* equal */
      {
	PSE_Present++;
	break;
      }
  
  /* you can't mem from a book that has nothing in it... */ 
  if(!PSE_Present) {
a1187 13
  }  
  desc_ptr = (char *)malloc(strlen(tmp->description) + 1);

  /* spell numbers separated by "_" */
  if(desc_ptr) {
    strcpy(desc_ptr, tmp->description);
    parsenum = strsep(&desc_ptr, "_");
    index = 0; 
  } else {
    return FALSE;
  }  
  if(parsenum) {
    spell_array[sa_index] = atoi(parsenum);
d1189 4
a1192 3
  else {
    free(desc_ptr);
    return FALSE;
a1193 9
    while((parsenum = strsep(&desc_ptr, "_")))
    {
      if(parsenum  && atoi(parsenum) > 0) {
        sa_index++;
        spell_array[sa_index] = atoi(parsenum);
      }
    }

  free(desc_ptr);
d1197 1
a1197 2

int FindSpellInBook(struct obj_data *book, int spell)
d1200 1
a1200 1
  int spell_array[SPELLBOOK_PAGES];  /* 100 first level spells? */
d1202 3
a1204 2
  for(index = 0; index < SPELLBOOK_PAGES; index++) {
    spell_array[index] = 0;
d1206 1
a1206 2
  
  if( !ListSpellsInBook(book, spell_array))
d1210 1
a1210 2
  
  for(index = 0; index < SPELLBOOK_PAGES; index++)
d1212 1
a1212 1
      if(spell_array[index] == spell) {
a1215 2
  
  /* not found... */
d1221 1
a1221 1
void ScribeList(struct char_data *ch, struct obj_data *book)
d1224 2
a1225 2
  int index = 0;
  int spell_array[SPELLBOOK_PAGES];
d1228 3
a1230 2
  for (index = 0; index < SPELLBOOK_PAGES; index++) {
    spell_array[index] = 0;
d1232 2
a1233 3
  
  if (!ListSpellsInBook(book, spell_array)) {
    send_to_char("You have no spells scribed anywhere.\r\n", ch);
d1236 1
a1236 2

  sprintf(list_buf, "&7&b---Spellbook Index---&0\r\n"); 
d1240 1
d1242 5
a1246 3
  while(spell_array[index]) {
    if((int)GET_LEVEL(ch) < spell_info[spell_array[index]].min_level[(int)GET_CLASS(ch)]) {
      sprintf(list_buf, "%s&6Page %2d)&0 &5Unreadable&0\n", list_buf, index+1);
d1248 2
a1249 1
      sprintf(list_buf, "%s&6Page %2d)&0 &6&b%s&0\n", list_buf, index+1, spells[spell_array[index]]);
d1253 7
d1264 4
d1269 18
a1286 67
/* ugh this is horrible function, sorry. BUT, it works... suffer bitch*/
int AddSpellToBook(struct char_data *ch, struct obj_data *book, int spell)
{
  struct extra_descr_data *entry, *tmp;
  char spellnumbuf[6];   /* max spell num 9999 */
  int added = 0;
  int len, copy_len;
  char *tmp_desc, *entry_desc;
  int entry_exists = 0;
  
  if(FindSpellInBook(book, spell))
    {
      send_to_char("The spell is already scribed into this book.",ch);
      return TRUE;
    }
  
  memset(spellnumbuf, 0x0, 6);
  sprintf(spellnumbuf, "%d_", spell);
  
  /* PSE = Parse Spell Entry, and it ensures this ex_descr is used 
   * for the spell contents string, not some builder work.
   */
  for(entry = book->ex_description; entry; entry = entry->next)
    {
      if( strcmp(entry->keyword, "PSE") == 0) /* equal */
	{
	  entry_exists = 1;
	  break;
	}
      else
	continue;
    } /* enf for() */
  
  /* process the existing PSE entry */
  if(entry_exists)
    {   
      len = strlen(entry->description) + strlen(spellnumbuf) +1;
      if(len > SPELLBOOK_MAX_STRING)
	{
	  log("spellbook string too long\r\n");
	  return FALSE;
	}
      
      tmp = (struct extra_descr_data *) malloc(sizeof(struct extra_descr_data));
      
      /* resize the string to hold the new value */
      tmp->description = (char *) malloc(len);
      if(!tmp)
	{
	  log("SYSERR: Couldn't malloc the freakin' spellbook entry.");
	  return FALSE;
	}
      
      /* zero out the memory */
      memset(tmp->description, 0x0, len); 
      
      /* move the existing value to the new, larger buf */
      tmp_desc = tmp->description;
      entry_desc = entry->description;
      
      /* remove the file-appended /r/n as we copy */
      for(copy_len = 0; copy_len < strlen(entry->description); copy_len++)
      {
	if((*entry_desc == 10) || (*entry_desc == 13))
	  continue;
	else
	  *tmp_desc++ = *entry_desc++; 
a1287 31
      //strcpy(tmp->description, entry->description);
      
      /* add the two strings, old value + new value MINUS the CR/LF*/
      //      strcat((tmp->description + strlen(tmp->description) - 2), spellnumbuf);
      strcat(tmp->description, spellnumbuf);
      /* kill the old memory */
      free(entry->description);
      
      /* now we can copy from tmp desc to the entry desc 
       * copy the pointer, NOT the data
       */
      entry->description = tmp->description;
      added = 1;
      
    } /* end if(entry_exists) */
  else
    {
      CREATE(tmp, struct extra_descr_data, 1);
      tmp->next = book->ex_description;
      book->ex_description = tmp;
      tmp->keyword = strdup("PSE");
      tmp->description = (char*)malloc(strlen(spellnumbuf) + 1);
      memset(tmp->description, 0x0, (strlen(spellnumbuf) + 1));
      strcpy(tmp->description, spellnumbuf);
      added = 1;
    } /* end else (entry_exists) */
  
  if(added)  
    {
      send_to_char("You write the spell in your spellbook",ch);
    return TRUE;
d1289 8
a1296 3
  else
    log("SYSERR: PSE not found for spellbook");
  
a1300 1

d1310 2
a1311 2
  struct obj_data *book = 0;
  
d1316 1
d1319 2
a1320 2
      if((book = GetBook(ch))) {
        ScribeList(ch, book);
a1325 1
  
d1348 1
d1361 1
a1361 1
  book = GetBook(ch);
d1363 8
a1370 3
  if(book)
    AddSpellToBook(ch, book, spellnum);
  else
d1372 1
a1372 1
  
a1379 8
  /* currently, don't allow pc to teach another pc spells 
   *  if(*arg)
   * {
   *  send_to_char("They might not know that spell...try a REAL teacher.\r\n", ch);
   * return FALSE;
   * }
   */

d1386 1
a1386 1
} /* end FindTeacher() */
d1396 215
@


1.7
log
@Brand new spell table, thanks to Zzur
Glad I didnt' have to do it...
fingon
@
text
@d75 1
d776 9
a784 11
	      /*     STILL awaiting fix from Fingh... 11/7/98
	       *     if(check_mem_mode(ch) == MEMORIZE)
	       *     {
	       *       if( !GetBookAtHand(ch, cur->spell) )
	       *       {
	       *         send_to_char("You need a spellbook with that spell written* in it.",ch);
	       *         rem_memming(ch);
	       *         break;
	       *       } 
	       *     } 
	       */
d1138 3
d1192 1
a1192 1
  if(!PSE_Present)
d1194 5
a1198 3
  
  desc_ptr = (char *)malloc(strlen(tmp->description));
  if(desc_ptr)
d1200 6
a1205 5
  
  parsenum = strtok(desc_ptr, ", ");
  index = 0; 
  
  if(parsenum)
d1207 6
a1212 2
  /*sscanf(parsenum, "%d", &spell_array[sa_index++]);*/
  else
d1214 4
a1217 2
      free(desc_ptr);
      return FALSE;
d1219 1
a1219 10
  
  do
    {
      parsenum = 0;
      parsenum = strtok(NULL,", ");
      if(parsenum)
	sscanf(parsenum, "%d", &spell_array[sa_index++]);
    } 
  while(parsenum);  /* end do-while() */
  
d1230 3
a1232 1
  memset(spell_array, 0x0, SPELLBOOK_PAGES);
a1235 1
      mudlog("ListSpellsInBook returned false to findspellinbook", NRM, LVL_GOD, TRUE);
d1239 1
a1239 1
  for(index = 0;index < SPELLBOOK_PAGES; index++)
d1241 1
a1241 1
      if(spell_array[index] == spell)
d1243 1
d1250 36
d1303 1
a1303 1
  sprintf(spellnumbuf, "%d, ", spell); /* comma mandatory for read */
d1408 11
a1431 6
  if(!*argument)
    {
      send_to_char("Scribe what where?\r\n", ch);
      return;
    }
  
d1440 1
a1440 1
  /* no pc or NPC teacher && no book */
d1474 2
a1475 1
  
d1477 1
a1477 1
    if(MOB_FLAGGED(dude, MOB_TEACHER))
@


1.6
log
@Moved spell circles to every 8 levels.  Filled in the
spells array to extend from level 70 to 105.
fingon
@
text
@d99 6
a104 5
* This table describes how many spells a caster can memorize from a 
* specific CIRCLE at each level. This is class Independent. Class 
* dependencies can be controlled using spell_level() calls in class.c 
* IF YOU CHANGE THIS ARRAY, YOU MUST CHANGE STRUCTS.H MAX_CHAR_SPELLS
* to the new value...*/
d108 1
a108 1
/* 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14<-SPELL CIRCLE */
d110 107
a216 108
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 0 */
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 1 */
  {0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 2 */
  {0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 3 */
  {0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 4 */
  {0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 5 */
  {0, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 6 */
  {0, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 7 */
  {0, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 8 */
  {0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 9 */
  {0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 10*/
  {0, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 11*/
  {0, 5, 5, 2, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 12*/
  {0, 5, 5, 3, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 13*/
  {0, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 14*/
  {0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 15*/
  {0, 6, 5, 5, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 16*/
  {0, 6, 5, 5, 2, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 17*/
  {0, 6, 5, 5, 3, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 18*/
  {0, 6, 5, 5, 4, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 19*/
  {0, 6, 5, 5, 5, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 20*/
  {0, 6, 6, 5, 5, 1, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 21*/
  {0, 6, 6, 5, 5, 2, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 22*/
  {0, 6, 6, 5, 5, 3, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 23*/
  {0, 6, 6, 5, 5, 4, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 24*/
  {0, 6, 6, 5, 5, 5, 0, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 25*/
  {0, 7, 6, 6, 5, 5, 1, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 26*/
  {0, 7, 6, 6, 5, 5, 2, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 27*/
  {0, 7, 6, 6, 5, 5, 3, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 28*/
  {0, 7, 6, 6, 5, 5, 4, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 29*/
  {0, 7, 6, 6, 5, 5, 5, 0, 0, 0, 0,  0,  0,  0,  0},  /* level 30*/
  {0, 7, 7, 6, 6, 5, 5, 1, 0, 0, 0,  0,  0,  0,  0},  /* level 31*/
  {0, 7, 7, 6, 6, 5, 5, 2, 0, 0, 0,  0,  0,  0,  0},  /* level 32*/
  {0, 7, 7, 6, 6, 5, 5, 3, 0, 0, 0,  0,  0,  0,  0},  /* level 33*/
  {0, 7, 7, 6, 6, 5, 5, 4, 0, 0, 0,  0,  0,  0,  0},  /* level 34*/
  {0, 7, 7, 6, 6, 5, 5, 5, 0, 0, 0,  0,  0,  0,  0},  /* level 35*/
  {0, 8, 7, 7, 6, 6, 5, 5, 1, 0, 0,  0,  0,  0,  0},  /* level 36*/
  {0, 8, 7, 7, 6, 6, 5, 5, 2, 0, 0,  0,  0,  0,  0},  /* level 37*/
  {0, 8, 7, 7, 6, 6, 5, 5, 3, 0, 0,  0,  0,  0,  0},  /* level 38*/
  {0, 8, 7, 7, 6, 6, 5, 5, 4, 0, 0,  0,  0,  0,  0},  /* level 39*/
  {0, 8, 8, 7, 7, 6, 5, 5, 4, 0, 0,  0,  0,  0,  0},  /* level 40*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 1, 0,  0,  0,  0,  0},  /* level 41*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 2, 0,  0,  0,  0,  0},  /* level 42*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 3, 0,  0,  0,  0,  0},  /* level 43*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 4, 0,  0,  0,  0,  0},  /* level 44*/
  {0, 8, 8, 7, 7, 6, 6, 5, 5, 5, 0,  0,  0,  0,  0},  /* level 45*/
  {0, 9, 8, 8, 7, 6, 6, 6, 5, 5, 1,  0,  0,  0,  0},  /* level 46*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 2,  0,  0,  0,  0},  /* level 47*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 3,  0,  0,  0,  0},  /* level 48*/
  {0, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4,  0,  0,  0,  0},  /* level 49*/
  {0, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5,  0,  0,  0,  0},  /* level 50 PATTERN CHANGES!*/
  {0, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5,  1,  0,  0,  0},  /* level 51*/
  {0, 10, 9, 9, 9, 8, 7, 7, 6, 6, 5,  2,  0,  0,  0},  /* level 52*/
  {0, 10, 10, 10, 9, 9, 8, 8, 7, 6, 6,  3,  0,  0,  0},  /* level 53*/
  {0, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6,  4,  0,  0,  0},  /* level 54*/
  {0, 10, 10, 10, 9, 9, 9, 8, 7, 7, 6,  5,  0,  0,  0},  /* level 55*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7,  5,  1,  0,  0},  /* level 56*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 8, 7,  5,  2,  0,  0},  /* level 57*/
  {0, 10, 10, 10, 10, 10, 9, 9, 8, 8, 8,  5,  3,  0,  0},  /* level 58*/
  {0, 10, 10, 10, 10, 10, 10, 10, 9, 8, 8,  6,  4,  0,  0},  /* level 59*/
  {0, 11, 11, 11, 11, 10, 10, 10, 9, 9, 8,  6,  5,  0,  0},   /* level 60*/
  {0, 11, 11, 11, 11, 11, 10, 10, 9, 9, 8,  6,  5,  1,  0},   /* level 61*/
  {0, 11, 11, 11, 11, 11, 11, 10, 9, 9, 8,  6,  5,  2,  0},   /* level 62*/
  {0, 11, 11, 11, 11, 11, 11, 11, 9, 9, 8,  7,  5,  3,  0},   /* level 63*/
  {0, 11, 11, 11, 11, 11, 11, 11, 10, 9, 8,  7,  6,  4,  0},   /* level 64*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 9, 8,  7,  6,  5,  0},   /* level 65*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 10, 8,  7,  6,  5,  0},   /* level 66*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 10, 9,  8,  6,  5,  1},   /* level 67*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 9,  8,  7,  5,  2},   /* level 68*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10,  8,  7,  6,  3},   /* level 69*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 70*/
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 71 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 72 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 73 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 74 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 75 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 76 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 77 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 78 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 79 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 80 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 81 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 82 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 83 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 84 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 85 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 86 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 87 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 88 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 89 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 90 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 91 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 92 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 93 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 94 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 95 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 96 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 97 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 98 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 99 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 100 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 101 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 102 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 103 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4},  /* level 104 */
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4}   /* level 105 */
}; /* 11+11+11+11+11+11+10+10+10 = 149 = max_char_spells  */
   /* corrected lvl 39 missing. new max_char_spells = 135 */
@


1.5
log
@Fixed spell mem bug.  High level casters would mem all of their
low level spells instantly when they got to them in the mem
list.  All mem times are now cumulative.
fingon
@
text
@d91 5
a95 1
	"10th"
d105 1
a105 1
int spells_of_circle[(LVL_MAX_MORT + 1)][(NUM_SPELL_CIRCLES + 1)]={
d179 36
a214 2
  {0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  8,  7,  6,  4}   /* level 70*/
 /* {0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  9,  8,  7,  5}    level 71  = skipped 39 before */
@


1.4
log
@If this doesn't fix spellcaster/leveling problems im gonna scream
@
text
@d758 6
a763 6
		 {
	  	   if((number(1,110)) < GET_SKILL(ch, SKILL_MEDITATE))
		     cur->mem_time = 0;
		   if(number(0,20) > 15)
		     improve_skill(ch, SKILL_MEDITATE);
		 }
d768 26
a793 26
		 if(check_mem_mode(ch) == MEMORIZE)
		   sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
		 else if(check_mem_mode(ch) == PRAY)
		   sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
                 send_to_char(buf, ch);
		 
                 /* reset so the guy has to remem after casting it.*/
                 cur->mem_time = set_mem_time(ch, cur->spell);
                 cur->can_cast = 1;
                 ch->num_memmed++;
		 
                 if(ch->num_memmed == ch->num_spells)
		   {
		     if(check_mem_mode(ch) == MEMORIZE) 
		       {
			 send_to_char("You have completed your studies.\r\n", ch);
			 act("$n closes $s book and smiles.", TRUE, ch, 0, 0, TO_ROOM);
		       }
		     else if(check_mem_mode(ch) == PRAY) 
		       {
			 send_to_char("Your prayers are complete.\r\n", ch);
			 act("$n finishes praying to $s diety.", TRUE, ch, 0, 0, TO_ROOM);
		       }
		     rem_memming(ch);          
		     cur = 0;
		   }
d796 2
a797 2
	      else 
		cur = 0;               
@


1.3
log
@Fixed yet more bugs with spellcasters and leveling
hope this does it.
@
text
@d871 1
a871 1

d898 1
a898 1
  
d908 1
a908 1
  
d912 21
a932 7
	{          
          add_spell(ch, ch->player_specials->saved.memmed_spells[index][0], check_mem_mode(ch), 
		    ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);

          if(ch->player_specials->saved.memmed_spells[index][1]) 
            ch->num_memmed++;
	  
d942 2
@


1.2
log
@Indented entire file.
@
text
@d22 1
d25 1
d599 1
a599 1
      avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_MEMMED(circle);
d889 2
a890 2
	} /* end while(cur) */
    } /* end if() */
d897 1
a897 2
  int index=0;
  int new_num_spells = 0; 
d901 5
a905 1
  
d913 3
a915 3
          new_num_spells += add_spell(ch, ch->player_specials->saved.memmed_spells[index][0], check_mem_mode(ch), 
				      ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);
	  
d919 2
a920 2
	} /* end for() */
    } /* end if() */
d923 8
a930 3
  
  //    if(new_num_spells != ch->num_spells)
  //      ch->num_spells = new_num_spells;
@


1.1
log
@Initial revision
@
text
@d2 7
a8 5
* File: spell_mem.c                             Part of xx MUD
* Usage: This file contains all of the code for spell_memorization.
*
* Last Modified: 10-4-98
*********************************************************************/
d180 20
a199 19
   switch (GET_CLASS(ch)) { 
      case CLASS_MAGIC_USER:
      case CLASS_CRYOMANCER:
      case CLASS_PYROMANCER:
      case CLASS_NECROMANCER:
      case CLASS_CONJURER:
      case CLASS_RANGER:
      case CLASS_BARD:
        return MEMORIZE;
      case CLASS_CLERIC:
      case CLASS_DIABOLIST:
      case CLASS_DRUID:
      case CLASS_PRIEST:
      case CLASS_PALADIN:
      case CLASS_ANTI_PALADIN:
        return PRAY;
      default:
	return -1;
   }  
d206 9
a214 8
   int spell;

   if(!ch || IS_NPC(ch))
      return;
   if(check_mem_mode(ch) != MEMORIZE) {
      send_to_char("You do not study sorcery.", ch);;
      return;
   }
d216 1
a216 1
   {
d219 1
a219 1
   }
d221 1
a221 1

d224 4
a227 4
   {
      show_spell_list(ch, FALSE);
   }

d230 2
a231 2
      send_to_char("You are not comfortable enough to study.\r\n", ch);

d234 42
a275 42
   {
      spell = find_skill_num(argument);      
      if((spell < 0) || (spell > MAX_SKILLS))
      {
         send_to_char("Memorize What?!\r\n", ch);
         return;
      }
   
      if((int)GET_LEVEL(ch) < spell_info[spell].min_level[(int)GET_CLASS(ch)])  
      {
          send_to_char("That spell is beyond your knowledge.\r\n", ch);
          return;
      }

      if(GET_SKILL(ch, spell) == 0)
      {
         send_to_char("You don't know that spell.\r\n", ch);
         return;
      }

      /* check number of spells already memmed against the spell_table */
      if(spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)] <= GET_MEMMED_CIRCLE(spell))
      {
         sprintf(buf, "You can memorize no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
         send_to_char(buf, ch);
         return;
      }

      /* finally, the spell is available...add it to the list */
      else
      {
         ch->num_spells += add_spell(ch, spell, MEMORIZE, 0, ADD_NEW);
         if(!ch->mem_status)
         {
            /* get the char started memming his list.. */
            add_mem_list(ch);
	    if(!(ch->mem_status))
	      act("$n takes out $s books and begins to study.",TRUE,ch,0,0,TO_ROOM);
            ch->mem_status = 1;
         }
      }
   }	
d282 11
a292 2

   if(!ch || IS_NPC(ch))
d294 6
a299 15
   if(check_mem_mode(ch) != PRAY) {
      do_action(ch, argument, cmd, subcmd);
      return;
   }

   if(GET_LEVEL(ch) >= LVL_IMMORT)
   {
       send_to_char("You don't need to pray for spells to cast them.\r\n", ch);
       return;
   }
   skip_spaces(&argument);

   /* if no arg, show the current spell list */
   if(!*argument)
   {
d301 9
a309 9
   }

   /* check the char's position */
   else if((GET_POS(ch) > POS_SITTING) || (GET_POS(ch) < POS_RESTING))
      send_to_char("You are not comfortable enough to pray to your diety.\r\n", ch);

   /* for the spell name, find the spell num, and add it to the mem list. */
   else
   {
d312 5
a316 5
      {
         send_to_char("Pray for What?!\r\n", ch);
         return;
      }
   
d318 1
a318 1
      {
d321 2
a322 2
      }

d324 5
a328 5
      {
         send_to_char("You have heard of that spell, but have no idea how to cast it.\r\n", ch);
         return;
      }

d331 6
a336 6
      {
         sprintf(buf, "You can pray for no more spells from Circle %d.\r\n", GET_CIRCLE(spell));
         send_to_char(buf, ch);
         return;
      }

d339 12
a350 12
      {
         ch->num_spells += add_spell(ch, spell, PRAY, 0, ADD_NEW);
         if(!ch->mem_status)
         {
            /* get the char started memming his list.. */
            add_mem_list(ch);
            if(!(ch->mem_status))
	      act("$n begins praying to $s diety.",TRUE,ch,0,0,TO_ROOM);
            ch->mem_status = 1;
         }
      }
   }	
d355 13
a367 11
    int counter;
    struct mem_list *cur, *next;

    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
    if(ch->mem_status) {
       send_to_char("You abort your studies.\r\n", ch);
       rem_memming(ch);
    }
    ch->num_spells = 0;
    ch->num_memmed = 0;
    for(counter=0;counter < MAX_CHAR_SPELLS;counter++){
d371 6
a376 5

    cur = ch->spell_list;
    ch->spell_list = NULL;

    while(cur) {
d381 4
a384 4
    for(counter=1;counter <= NUM_SPELL_CIRCLES;counter++)
      GET_MEMMED(counter) = 0;
    save_char(ch, NOWHERE);
    send_to_char("You purge all spells from your mind.\r\n",ch);
d389 12
a400 11
   int spell;
   char buf[128];
   skip_spaces(&argument);
   
   if(!ch || IS_NPC(ch) || GET_LEVEL(ch) >= LVL_IMMORT) {
     send_to_char("You have no need to forget spells.\r\n",ch);
     return;
   }

   if(!argument)
   {
d403 12
a414 11
   }

   if(is_abbrev(argument, "all")){
     wipe_mem(ch);
     return;
   }

   spell = find_skill_num(argument);      

   if((spell < 0) || (spell > MAX_SKILLS))
   {
d417 5
a421 5
   }
   else
   {
       if(rem_spell(ch, spell))
       {
d424 3
a426 3
       }
       else
       {
d429 2
a430 2
       }
   }  
d436 4
a439 3
  if(GET_POS(ch) > POS_SITTING){
  send_to_char("Try resting first....\r\n", ch);
    return;
d441 4
a444 4
	SET_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
	send_to_char("You begin to meditate.\r\n", ch);
        WAIT_STATE(ch, PULSE_VIOLENCE * 2);
        improve_skill(ch, SKILL_MEDITATE);
d450 6
a455 6
   struct mem_list *cur, *prev;
   char buf[128];
   
   /* see if ch can even use that circle of spell.... */
   if(!spells_of_circle[(int)GET_LEVEL(ch)][GET_CIRCLE(spell)])
   {
d457 4
a460 4
      {
        sprintf(buf, "You can't use spells from Circle %d yet.\r\n", GET_CIRCLE(spell));
        send_to_char(buf, ch);
      }
d462 9
a470 13
   }      
   /* initialize the ptr and check it before proceeding */
   if(((ch->num_spells == 0) && (add_type == ADD_NEW)) || ((ch->spell_list == 0) && (add_type == RESTORE_CHAR)))
   {
    if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
           return 0;
       ch->spell_list->next = 0;
       cur = ch->spell_list;
   }else
   {

 // iterate the list to add new spell at the END...SLOW and UGLY!!!
      for(cur = ch->spell_list; cur ; cur = cur->next)
d472 36
a507 32
        if(cur->next == 0)
        {
          prev = cur;
          if(!(cur = (struct mem_list *) malloc(sizeof(struct mem_list))))
            return 0;
      
          prev->next = cur;
          cur->next = 0;
          break;
        }
      }
      
   }      
      
   cur->spell = spell;
   cur->can_cast = is_memmed;
   cur->mem_time = set_mem_time(ch, cur->spell);      

   if(add_type == RESTORE_CHAR)
   {
     GET_MEMMED_CIRCLE(spell)++;
     return 1;
   }
   if(mode == MEMORIZE)     
      sprintf(buf, "You begin memorizing %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time); 
   else if(mode == PRAY)
      sprintf(buf, "You begin praying for %s, which will take %d seconds.\r\n", skill_name(spell), cur->mem_time); 
   send_to_char(buf, ch);
   GET_MEMMED_CIRCLE(spell)++;
   
   /* increment the players num_spells */
   return 1; 
d514 4
a517 4
   struct mem_list *temp, *cur;
   cur = temp = ch->spell_list;
   while(cur)
   {
d519 6
a524 6
      {  
         if(cur == ch->spell_list)
         {
	         ch->spell_list = ch->spell_list->next;
             ch->num_spells -= 1;
             if(cur->can_cast)
d526 11
a536 11

             free(cur);
             GET_MEMMED_CIRCLE(spell)--;
             return 1;
         }
         else
         {
             /* remove the spell, free the memory, and return found */
             temp->next = cur->next;
             ch->num_spells -= 1;
             if(cur->can_cast)
d538 5
a542 5
             free(cur);
             GET_MEMMED_CIRCLE(spell)--;
             return 1;
         }
      }
d544 7
a550 7
      {
         temp = cur;
         cur = cur->next;       
      }
   }
   return 0;
 }
d555 8
a562 8
   char memmed[MAX_STRING_LENGTH];
   char to_mem[MAX_STRING_LENGTH];
   char buf[256];
   char remaining[256];
   char string[256];
   int circle;			/* check spell circle */
   int avail;           /* how many more spells in this circle? */
   if(SpellList(ch, memmed, to_mem))
d564 2
a565 2
      if((GET_POS(ch) == POS_SITTING) || (GET_POS(ch) == POS_RESTING))
      {
d567 7
a573 7
         { 
            if(check_mem_mode(ch) == MEMORIZE)
              strcat(to_mem, "\r\nYou continue your studies.\r\n");
            if(check_mem_mode(ch) == PRAY)
              strcat(to_mem, "\r\nYou continue to pray.\r\n");

         }
d575 9
a583 9
         {
            /* add the player to the memming list so spells can be updated */
            add_mem_list(ch);
            ch->mem_status = 1;
            strcat(to_mem, "\r\nYou continue your studies.\r\n");
         }
      }   
      strcat(to_mem, "\0");   
      send_to_char(to_mem, ch);
d585 32
a616 33
   
   memset(string , 0x0, 256); 
   memset(remaining , 0x0, 256);  
   memset(buf , 0x0, 256);  

   /* display all remaining available spell slots for each circle*/
   if(check_mem_mode(ch) == MEMORIZE)
      sprintf(remaining, "\r\nYou can memorize");
   if(check_mem_mode(ch) == PRAY)
      sprintf(remaining, "\r\nYou can pray for");   
   for(circle = 1; circle <= NUM_SPELL_CIRCLES; circle++)
   {
	  avail = spells_of_circle[(int)GET_LEVEL(ch)][circle] - GET_MEMMED(circle);
	  if(avail == 0)
		  continue;
	  sprintf(buf, " (%d)%d", avail, circle);
	  strcat(string, buf);
	  
	  switch(circle)
	  {
	    case 1:
		  strcat(string, "st");
		  break;
	    case 2:
		  strcat(string, "nd");
		  break;
	    case 3:
		  strcat(string, "rd");
		  break;
	    default:
		  strcat(string, "th");
		  break;
	  }
d618 8
a625 7
    if(strlen(string)< 7)
      strcat(string, " no more");
    else
      strcat(string, " circle");
    strcat(string, " spell(s)\r\n\r\n");
    strcat(remaining, string);   
    send_to_char(remaining, ch);
d630 6
a635 6
   struct mem_list *cur;
   
   cur = ch->spell_list;
   /* traverse the list and find out if the spell is memmed or not. */
   while(cur)
   {
d637 8
a644 8
         if(cur->can_cast)
            /* okay, the spell is memmed...return true */
            return 1;
 
       cur = cur->next;
   }
   /* couldn't find a memmed copy of that spell anywhere... */
   return 0;
d650 6
a655 6
   struct mem_list *cur;
   
   cur = ch->spell_list;
   /* traverse the list to find the spell. */
   while(cur)
   {
d657 3
a659 3
         if(cur->can_cast)
         {  /* okay, this is a valid copy of the spell */
            cur->can_cast = 0;
d662 2
a663 2
         } 
     
d665 1
a665 1
   }
d667 2
a668 2
     
      
d672 4
a675 4
  {
    memming = ch;
    ch->next_memming = 0;
  }
d677 4
a680 4
  {
    ch->next_memming =  memming;
    memming = ch;
  }
d685 11
a695 11
   struct char_data *ch = 0;
   struct mem_list *cur = 0;
   char buf[256];
   
   ch = memming;
   /* if no one is memming, don't bother */
   if(memming == 0)
      return;

   while(ch)
   {
d697 7
a703 7
      { 
         send_to_char("You cannot study while intoxicated\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

d705 7
a711 7
      { 
         send_to_char("You are too hungry too study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

d713 7
a719 7
      { 
         send_to_char("You are too thirsty to study.\r\n", ch);
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
         return;
      }

d721 4
a724 4
      {
         send_to_char("You abort your studies.\r\n", ch);
         rem_memming(ch);
 
d726 1
a726 1
      }
d730 26
a755 26
      {
         if(cur->can_cast)
             cur = cur->next;
         else  
         {  
      /*     STILL awaiting fix from Fingh... 11/7/98
       *     if(check_mem_mode(ch) == MEMORIZE)
       *     {
       *       if( !GetBookAtHand(ch, cur->spell) )
       *       {
       *         send_to_char("You need a spellbook with that spell written* in it.",ch);
       *         rem_memming(ch);
       *         break;
       *       } 
       *     } 
       */
          /* using pulse violence, which means we only update every _2_ seconds
             please do NOT change this, unless you change in comm.c to
             pulse_violence/2  
          */
             cur->mem_time -= 2;
			 
   	     /*check meditate skill */
	     if(PLR_FLAGGED(ch, PLR_MEDITATE))
	     {
		 if(cur->mem_time <= ((int) (set_mem_time(ch, cur->spell) / 2) + 1))
d759 2
a760 2
		 if(number(0,20) > 15)
		   improve_skill(ch, SKILL_MEDITATE);
d762 4
a765 4
	     }

             if(cur->mem_time < 1)
             {
d767 1
a767 1
                    sprintf(buf, "You have finished memorizing %s.\r\n", skill_name(cur->spell));
d769 1
a769 1
                    sprintf(buf, "You have finished praying for %s.\r\n", skill_name(cur->spell));
d771 1
a771 1

d776 1
a776 1

d778 22
a799 22
                 {
		    if(check_mem_mode(ch) == MEMORIZE) 
                    {
                        send_to_char("You have completed your studies.\r\n", ch);
		        act("$n closes $s book and smiles.", TRUE, ch, 0, 0, TO_ROOM);
		    }
		    else if(check_mem_mode(ch) == PRAY) 
                    {
                        send_to_char("Your prayers are complete.\r\n", ch);
		        act("$n finishes praying to $s diety.", TRUE, ch, 0, 0, TO_ROOM);
		    }
                    rem_memming(ch);          
		    cur = 0;
                 }
             }
             /* make sure only one spell is finished each time through...*/
             else 
                 cur = 0;               
         }    
      }   
   ch = ch->next_memming;
   }   
d806 1
a806 1
   struct char_data *temp, *prev;
d808 22
a829 22
   for(prev = temp = memming; temp; temp = temp->next_memming)
   {
     if(temp == ch)
     {
       if(ch == memming)
       {
         memming = ch->next_memming;
         ch->next_memming = 0;
       }
       else
       {
         prev->next_memming = ch->next_memming;
         ch->next_memming = 0;        
       }

       REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
       ch->mem_status = 0;
       return;
     } // temp == ch

     prev = temp;
   } // end for
d834 33
a866 33
    double mem_time; /* base time of 30 seconds */
//    int mode = check_mem_mode(ch);
//    int mem_time;
    /* Here's the happy new mem time code... if you want to make mem times,
	slower or faster, the variable base_time is the base seconds, just
	change that to tweek it - Nechtrous */

/*    exp = ((float)(2*(GET_CIRCLE(spell) -1)) + 5.5) / ((float)(GET_LEVEL(ch) / 2) + 5);
   mem_time = pow(base_time, exp);
    if(mode == PRAY)
    mod = (float)((float)GET_RWIS(ch) / 18);
    if(mode == MEMORIZE)    
      mod = (float)((float)GET_RINT(ch) / 18);
    mem_time = mem_time / mod;
*/
    mem_time = 33 ; 
     //modify base to reflect level experience  
     mem_time -= (int)((NUM_SPELL_CIRCLES - GET_CIRCLE(spell))*2); 
     mem_time -= (int)((GET_LEVEL(ch)/6) * 1.5);
     //modify for intelligence
     if(check_mem_mode(ch) == MEMORIZE)
       mem_time -= (int) (GET_INT(ch)/20);  
     else
       mem_time -= (int) (GET_WIS(ch)/20);

   /* cap the mem time in case any wackiness happens   */
    if(mem_time > 40)
      mem_time = 40;
   /*  modify in case mem_time has gone below or at 0 */ 
    if (mem_time <= 1)
      mem_time = 2;
    
    return (int)mem_time;
d872 6
a877 6
    struct mem_list *cur;
    int counter = 0;

    ch->player_specials->saved.spells_in_mem = ch->num_spells;

    if(ch->num_spells > 0)
d879 4
a882 4
       cur = ch->spell_list;

       while(counter < ch->num_spells && cur)
       {          
d887 1
a887 1
       } /* end while(cur) */
d895 10
a904 10
    int index=0;
    int new_num_spells = 0; 
 
    if(!ch)
      return;

    ch->num_spells = ch->player_specials->saved.spells_in_mem;
    ch->spell_list = 0;

    if(ch->num_spells)
d906 2
a907 2
       for(index = 0; index < ch->num_spells;index++)
       {          
d909 2
a910 2
               ch->player_specials->saved.memmed_spells[index][1], RESTORE_CHAR);

d913 2
a914 2

       } /* end for() */
d916 5
a920 5
    else 
       ch->spell_list = 0;

//    if(new_num_spells != ch->num_spells)
//      ch->num_spells = new_num_spells;
d925 12
a936 11
   struct mem_list *cur;
     
   /* initialize the ptr and check it before proceeding */
   if(ch->num_spells == 0)
   {     
       if(!(ch->spell_list = (struct mem_list *) malloc(sizeof(struct mem_list))))
           return 0;
       ch->spell_list->next = 0;
       cur = ch->spell_list;
   }else
   {
d938 1
a938 1
         return 0;
d940 17
a956 17
   }      
      
   cur->spell = spell;
   cur->can_cast = state;
   
   if(cur->can_cast)
      ch->num_memmed++;
      
   cur->mem_time = set_mem_time(ch, spell);      

   GET_MEMMED_CIRCLE(spell)++;

   /* reset the head of the list */
   ch->spell_list = cur;

   /* increment the players num_spells */
   return 1; 
d962 60
a1021 60
   struct mem_list *tmp;
   char buf[256];
   int is_memming = 0;
   int num, i, found, circle = 0;
   int list_time = 0;         

   tmp = ch->spell_list;

   if(check_mem_mode(ch) == MEMORIZE){
      sprintf(memmed, "\r\nYou have memorized the following spells:\r\n\t");   
      sprintf(to_mem, "\r\nYou are currently memorizing:\r\n");
   }
   if(check_mem_mode(ch) == PRAY){
      sprintf(memmed, "\r\nYou have prayed for the following spells:\r\n\t");   
      sprintf(to_mem, "\r\nYou are currently praying for:\r\n");
   }
   /* sort the memmed spells  */
   for(i = 1; i < NUM_SPELL_CIRCLES; i++)
   {
	   found = 1;
	   circle++;
	   tmp =ch->spell_list;
	   while(tmp)
	   {
		  if(GET_CIRCLE(tmp->spell) == i)
		  {
			  if(tmp->can_cast)
			  {
				  num = get_num_memmed(ch, tmp);
				  if(num > 0)
				  {
					  if(found == 1)
					  {
						  sprintf(buf, "\r\n(%s %s)  ", CIRCLE_ABBR(tmp->spell), "circle");
						  strcat(memmed, buf);
					      sprintf(buf, "\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
						  strcat(memmed, buf);
					  
						  found--;
					  }
					  else
					  {
						  sprintf(buf, "\t\t%2d - %s\r\n", num, skill_name(tmp->spell)); 
						  strcat(memmed, buf);
						  strcat(memmed, "\0");
						  memset(buf, 0x0, 256);	
					  }
				  }
			  }
		  }
		  tmp = tmp->next;
	   }
   }
   
   tmp = ch->spell_list;
   /* display the un-memmed spells */
   while(tmp)
   {
	  if(!tmp->can_cast)
      {
d1026 1
a1026 1
      }
d1028 21
a1048 21
	  
   }

   /* if char still has spells memming, display total mem time */
   if(list_time) 
   {
       sprintf(buf, "\r\n   %d seconds remaining\r\n", list_time);
       strcat(to_mem, buf);
   }

   /* char may have spells in list, but none are currently memmed */
   if(ch->num_memmed < 1)
   {
       sprintf(buf, "   None!\r\n");
       strcat(memmed, buf);
   }

   if(memmed)	  
      send_to_char(memmed, ch);	  
   
   return(is_memming);
d1053 18
a1070 18
	struct mem_list *list = ch->spell_list;
	int num = 0;

	while(list != this)
	{
		if(this == list)
			continue;

		if((this->spell == list->spell) &&(list->can_cast) )
			return(0);
		list = list->next;
	}

	for(list = this; list; list = list->next)
		if(( this->spell == list->spell) && (list->can_cast))
			num++;

	return(num);
d1082 1
a1082 1
 
d1086 1
a1086 1

d1095 1
a1095 1
 
a1096 2
  {
    if(cur_obj->obj_flags.type_flag == ITEM_SPELLBOOK)
d1098 9
a1106 7
      if( FindSpellInBook(cur_obj, spell) )
        return TRUE;
      else
        continue;
    } /* end if */
  }

d1117 1
a1117 1

d1120 5
a1124 5
    {
      PSE_Present++;
      break;
    }

d1128 1
a1128 1

d1132 1
a1132 1

d1138 1
a1138 1
    /*sscanf(parsenum, "%d", &spell_array[sa_index++]);*/
d1140 5
a1144 5
  {
    free(desc_ptr);
    return FALSE;
  }

d1146 8
a1153 7
  {
    parsenum = 0;
    parsenum = strtok(NULL,", ");
    if(parsenum)
      sscanf(parsenum, "%d", &spell_array[sa_index++]);
  } while(parsenum);  /* end do-while() */

d1165 1
a1165 1

d1167 4
a1170 4
  {
    mudlog("ListSpellsInBook returned false to findspellinbook", NRM, LVL_GOD, TRUE);
    return FALSE;
  }
d1173 4
a1176 4
  {
    if(spell_array[index] == spell)
      return TRUE;
  }
d1191 1
a1191 1

d1193 5
a1197 5
  {
    send_to_char("The spell is already scribed into this book.",ch);
    return TRUE;
  }

d1200 1
a1200 1

d1203 1
a1203 1
  */
a1204 2
  {
    if( strcmp(entry->keyword, "PSE") == 0) /* equal */
d1206 8
a1213 6
      entry_exists = 1;
      break;
    }
    else
      continue;
  } /* enf for() */
d1217 1
a1217 1
  {   
d1220 5
a1224 5
      {
        log("spellbook string too long\r\n");
        return FALSE;
      }

d1226 1
a1226 1

d1230 4
a1233 4
      {
        log("SYSERR: Couldn't malloc the freakin' spellbook entry.");
        return FALSE;
      }
d1237 1
a1237 1

d1241 1
a1241 1

d1245 4
a1248 4
         if((*entry_desc == 10) || (*entry_desc == 13))
           continue;
         else
           *tmp_desc++ = *entry_desc++; 
d1251 1
a1251 1

d1253 2
a1254 2
//      strcat((tmp->description + strlen(tmp->description) - 2), spellnumbuf);
        strcat(tmp->description, spellnumbuf);
d1257 1
a1257 1

d1260 1
a1260 1
      */
d1263 2
a1264 2
     
  } /* end if(entry_exists) */
d1266 11
a1276 11
  {
     CREATE(tmp, struct extra_descr_data, 1);
     tmp->next = book->ex_description;
     book->ex_description = tmp;
     tmp->keyword = strdup("PSE");
     tmp->description = (char*)malloc(strlen(spellnumbuf) + 1);
     memset(tmp->description, 0x0, (strlen(spellnumbuf) + 1));
     strcpy(tmp->description, spellnumbuf);
     added = 1;
  } /* end else (entry_exists) */

d1278 2
a1279 2
  {
    send_to_char("You write the spell in your spellbook",ch);
d1281 1
a1281 1
  }
d1295 1
a1295 1
*/
d1300 1
a1300 1

d1305 5
a1309 5
  {
    send_to_char("You have to be sitting to scribe.\r\n",ch);
    return;
  }

d1315 2
a1316 2
  */

d1318 5
a1322 5
  {
    send_to_char("Scribe what where?\r\n", ch);
    return;
  }

d1324 1
a1324 1

d1326 5
a1330 5
  {
    send_to_char("Try all you want, but there's no such thing.\r\n", ch); 
    return;
  }
 
d1333 5
a1337 5
  {
    send_to_char("And just how do you expect to learn that spell?\r\n",ch);
    return;
  } 
 
d1339 5
a1343 5
  {
    send_to_char("You don't understand the magic used in that spell.\r\n", ch);
    return;
  }

d1357 1
a1357 1

d1359 7
a1365 6
  if(*arg)
  {
    send_to_char("They might not know that spell...try a REAL teacher.\r\n", ch);
    return FALSE;
  }*/
 
d1368 2
a1369 2
       return TRUE;

d1380 1
@
