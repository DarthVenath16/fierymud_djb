head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2010.04.25.22.51.45;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.09.05.45.49;	author myc;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.21.08.09.03;	author myc;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.09.05.51.25;	author jps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.09.05.41.12;	author jps;	state Exp;
branches;
next	;


desc
@Cash
@


1.9
log
@Fix crash bug in parse_money.c due to faulty boolean
logic in testing whether there are more args.
@
text
@/***************************************************************************
 * $Id: money.c,v 1.8 2009/06/09 05:45:49 myc Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: money.c                                        Part of FieryMUD *
 *  Usage: It's all about the cash                                         *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "money.h"
#include "db.h"
#include "math.h"
#include "screen.h"

/* coindefs[]
 *
 * name, shortname, initial, color, abbrev, scale
 */

struct coindef coindefs[NUM_COIN_TYPES] = {
   { "platinum", "plat", "p", "&6&b", "p", 1000 },
   { "gold", NULL, "g", "&3&b", "g", 100 },
   { "silver", NULL, "s", "&7&b", "s", 10 },
   { "copper", NULL, "c", "&3", "c", 1 }
};

bool is_coin_name(char *name, int cointype) {
   if (!str_cmp(name, COIN_NAME(cointype)))
      return TRUE;
   if (COIN_SHORTNAME(cointype) && !str_cmp(name, COIN_SHORTNAME(cointype)))
      return TRUE;
   return FALSE;
}

#define APPENDCOIN(coin) sprintf(buf, "%s%s%d" ANRM " %s", buf, \
   COIN_COLOR(coin), coins[coin], COIN_NAME(coin))

void statemoney(char *buf, const int coins[]) {
   int ctypes = 0, ctype2 = 0, amount = 0, i;

   *buf = '\0';

   for (i = 0; i < 4; i++) {
      if (coins[i]) {
         amount += coins[i];
         ctypes++;
         if (ctypes == 2)
            ctype2 = i;
      }
   }

   if (coins[PLATINUM]) {
      APPENDCOIN(PLATINUM);
      if (ctypes == 2)
         strcat(buf, " and ");
      else if (ctypes > 2)
         strcat(buf, ", ");
   }
   if (coins[GOLD]) {
      APPENDCOIN(GOLD);
      if (ctypes == 2 && ctype2 != GOLD)
         strcat(buf, " and ");
      else if (ctypes == 4 || (ctypes == 3 && ctype2 != GOLD))
         strcat(buf, ", ");
      else if (ctypes == 3)
         strcat(buf, ", and ");
   }
   if (coins[SILVER]) {
      APPENDCOIN(SILVER);
      if (ctypes == 2 && ctype2 != SILVER)
         strcat(buf, " and ");
      else if (ctypes == 4 || (ctypes == 3 && ctype2 == SILVER))
         strcat(buf, ", and ");
   }
   if (coins[COPPER])
      APPENDCOIN(COPPER);
   if (amount == 0)
      strcpy(buf, "0 coins");
   else if (amount > 1)
      strcat(buf, " coins");
   else
      strcat(buf, " coin");
}

#undef APPENDCOIN

#define COINBRIEF(coin, amount) sprintf(buf, "%s%s%d%s" ANRM, \
      buf, COIN_COLOR(coin), amount, COIN_INITIAL(coin))

/* Prints a string about some money, in the requested number of spaces,
 * using at most two types of coin. */
void briefmoney(char *buf, int spaces, int amt) {
   bool topset = FALSE;
   bool lowset = FALSE;
   int toptype = 0, topval = 0, topchars = 0,
       lowtype = 0, lowval = 0, lowchars = 0;
   int i, maxval = 9;
   int coins[4];

   /* Limit the number of digits so that there's 1 spot left over for a
    * coin-type designator (p, g, s, or c) */
   for (i = 0; i < spaces - 1; i++) {
      maxval = maxval * 10 + 9;
   }

   coins[PLATINUM] = amt / PLATINUM_SCALE;
   coins[GOLD] = (amt % PLATINUM_SCALE) / GOLD_SCALE;
   coins[SILVER] = (amt % GOLD_SCALE) / SILVER_SCALE;
   coins[COPPER] = (amt % SILVER_SCALE) / COPPER_SCALE;

   for (i = 0; i < 4; i++) {
      if (coins[i]) {
         if (!topset) {
            topset = TRUE;
            toptype = i;
            topval = coins[i];
            topchars = sprintf(buf, "%d", topval); /* count digits */
         } else if (!lowset) {
            lowset = TRUE;
            lowtype = i;
            lowval = coins[i];
            lowchars = sprintf(buf, "%d", lowval); /* count digits */
         }
      }
   }

   /* If the top coin type and low coin type can't fit within the requested
    * space, only the top will be used */
   if (lowset && lowchars + topchars > spaces - 2)
      lowset = FALSE;

   *buf = '\0';

   if (topset) {
      COINBRIEF(toptype, topval > maxval ? maxval : topval);
      if (lowset)
         COINBRIEF(lowtype, lowval);
   } else {
      sprintf(buf, "0");
   }
}

#undef COINBRIEF

bool parse_money(char **money, int coins[])
{
  char arg[MAX_INPUT_LENGTH];
  int amount, type;
  char *last;
  bool found_coins = FALSE;

  coins[PLATINUM] = 0;
  coins[GOLD] = 0;
  coins[SILVER] = 0;
  coins[COPPER] = 0;

  skip_spaces(money);

  while (**money) {
    *money = any_one_arg(last = *money, arg);
    if (!*arg)
      break;
    else if (!is_number(arg)) {
      *money = last;
      break; /* Not a number! */
    }
    amount = atoi(arg);
    *money = any_one_arg(*money, arg);
    if (!*arg || (type = parse_obj_name(NULL, arg, NULL, NUM_COIN_TYPES,
                            coindefs, sizeof(struct coindef))) < 0) {
      *money = last;
      break;
    }
    coins[type] += amount;
    found_coins = TRUE;
  }

  return found_coins;
}


void money_desc(int amount, char **shortdesc, char **keywords) {
   static char sdbuf[128], kwbuf[128];

   if (amount <= 0) {
      log("SYSERR: Try to create negative or 0 money.");
      strcpy(sdbuf, "an erroneous object");
      strcpy(kwbuf, "erroneous object");
   }
   if (amount == 1) {
      strcpy(sdbuf, "a single coin");
      strcpy(kwbuf, "single coin");
   } else if (amount <= 9) {
      strcpy(sdbuf, "a tiny pile of coins");
      strcpy(kwbuf, "tiny pile coins");
   } else if (amount <= 20) {
      strcpy(sdbuf, "a handful of coins");
      strcpy(kwbuf, "handful coins");
   } else if (amount <= 75) {
      strcpy(sdbuf, "a little pile of coins");
      strcpy(kwbuf, "little pile coins");
   } else if (amount <= 200) {
      strcpy(sdbuf, "a small pile of coins");
      strcpy(kwbuf, "small pile coins");
   } else if (amount <= 1000) {
      strcpy(sdbuf, "a pile of coins");
      strcpy(kwbuf, "pile coins");
   } else if (amount <= 5000) {
      strcpy(sdbuf, "a big pile of coins");
      strcpy(kwbuf, "big pile coins");
   } else if (amount <= 10000) {
      strcpy(sdbuf, "a large heap of coins");
      strcpy(kwbuf, "large heap coins");
   } else if (amount <= 20000) {
      strcpy(sdbuf, "a huge mound of coins");
      strcpy(kwbuf, "huge mound coins");
   } else if (amount <= 75000) {
      strcpy(sdbuf, "an enormous mound of coins");
      strcpy(kwbuf, "enormous mound coins");
   } else if (amount <= 150000) {
      strcpy(sdbuf, "a small mountain of coins");
      strcpy(kwbuf, "small mountain coins");
   } else if (amount <= 250000) {
      strcpy(sdbuf, "a mountain of coins");
      strcpy(kwbuf, "mountain coins");
   } else if (amount <= 500000) {
      strcpy(sdbuf, "a huge mountain of coins");
      strcpy(kwbuf, "huge mountain coins");
   } else if (amount <= 1000000) {
      strcpy(sdbuf, "an enormous mountain of coins");
      strcpy(kwbuf, "enormous mountain coins");
   } else {
      strcpy(sdbuf, "an absolutely colossal mountain of coins");
      strcpy(kwbuf, "colossal mountain coins");
   }

   if (shortdesc) *shortdesc = sdbuf;
   if (keywords) *keywords = kwbuf;
}


struct obj_data *create_money(const int coins[])
{
  struct obj_data *obj;
  int amount = coins[PLATINUM] + coins[GOLD] + coins[SILVER] + coins[COPPER];
  int which;

  if (amount <= 0) {
    mprintf(L_ERROR, LVL_IMMORT, "SYSERR: create_money: Attempt to create %d money.", amount);
    return NULL;
  }

  for (which = 0; which < NUM_COIN_TYPES; ++which)
    if (coins[which] < 0) {
      mprintf(L_ERROR, LVL_IMMORT, "SYSERR: create_money: Attempt to "
                                 "create money with %d %s.", 
              coins[which], COIN_NAME(which));
      return NULL;
    }

  obj = create_obj();
  CREATE(obj->ex_description, struct extra_descr_data, 1);

  GET_OBJ_TYPE(obj) = ITEM_MONEY;
  GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE;
  GET_OBJ_VAL(obj, VAL_MONEY_PLATINUM) = coins[PLATINUM];
  GET_OBJ_VAL(obj, VAL_MONEY_GOLD) = coins[GOLD];
  GET_OBJ_VAL(obj, VAL_MONEY_SILVER) = coins[SILVER];
  GET_OBJ_VAL(obj, VAL_MONEY_COPPER) = coins[COPPER];
  GET_OBJ_COST(obj) = CASH_VALUE(coins);
  obj->item_number = NOTHING;

  if (amount == 1) {
    if (coins[PLATINUM]) which = PLATINUM;
    else if (coins[GOLD]) which = GOLD;
    else if (coins[SILVER]) which = SILVER;
    else if (coins[COPPER]) which = COPPER;
    obj->name = strdupf("%s coin", COIN_NAME(which));
    obj->short_description = strdupf("a %s", obj->name);
    obj->description = strdupf("A single %s is lying here.", obj->name);
    obj->ex_description->keyword = strdup(obj->name);
    obj->ex_description->description = strdupf("A shiny %s!", obj->name);
  }
  else {
    money_desc(amount, &obj->short_description, &obj->name);
    obj->name = strdup(obj->name);
    obj->short_description = strdup(obj->short_description);
    obj->ex_description->keyword = strdup(obj->name);
    obj->description = strdupf("%s is lying here.", obj->short_description);
    cap_by_color(obj->description);
    if (amount < 10)
      obj->ex_description->description =
          strdupf("There are %d coins.", amount);
    else if (amount < 100)
      obj->ex_description->description =
          strdupf("There are about %d coins.", (amount / 10) * 10);
    else if (amount < 1000)
      obj->ex_description->description =
          strdupf("It looks to be about %d coins.", (amount / 100) * 100);
    else if (amount < 100000)
      obj->ex_description->description =
          strdupf("You guess there are maybe %d coins.",
                  ((amount / 1000) + random_number(0, amount / 1000)) * 1000);
    else
      obj->ex_description->description = strdup("There are a LOT of coins.");
  }

  return obj;
}

/***************************************************************************
 * $Log: money.c,v $
 * Revision 1.8  2009/06/09 05:45:49  myc
 * Statemoney now says "0 coins" if there weren't any coins.
 * Declaring several parameters const.
 *
 * Revision 1.7  2009/03/21 08:09:03  myc
 * Fix bug in parse_money.
 *
 * Revision 1.6  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.5  2009/03/19 23:16:23  myc
 * parse_money now takes a char** and moves the pointer up to
 * just past any money phrase it parses.
 *
 * Revision 1.4  2009/03/09 21:43:50  myc
 * Change statemoney from strcat to strcpy semantics.
 *
 * Revision 1.3  2009/03/09 20:36:00  myc
 * Moved money functions from handler to here.
 *
 * Revision 1.2  2009/03/09 05:51:25  jps
 * Moved some money-related functions from utils to money
 *
 * Revision 1.1  2009/03/09 05:41:12  jps
 * Initial revision
 *
 ***************************************************************************/
@


1.8
log
@Statemoney now says "0 coins" if there weren't any coins.
Declaring several parameters const.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.7 2009/03/21 08:09:03 myc Exp myc $
d181 1
a181 1
    if (*arg && (type = parse_obj_name(NULL, arg, NULL, NUM_COIN_TYPES,
d325 4
@


1.7
log
@Fix bug in parse_money.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.6 2009/03/20 13:56:22 jps Exp myc $
d50 1
a50 1
void statemoney(char *buf, int coins[]) {
d89 3
a91 1
   if (amount > 1)
d181 2
a182 2
    if ((type = parse_obj_name(NULL, arg, NULL, NUM_COIN_TYPES,
                coindefs, sizeof(struct coindef))) < 0) {
d254 1
a254 1
struct obj_data *create_money(int coins[])
d325 3
@


1.6
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.5 2009/03/19 23:16:23 myc Exp jps $
d180 1
a180 1
                coindefs, sizeof(struct coindef)))) {
d323 3
@


1.5
log
@parse_money now takes a char** and moves the pointer up to
just past any money phrase it parses.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.4 2009/03/09 21:43:50 myc Exp myc $
d27 10
a36 6
const char *coin_names[NUM_COIN_TYPES + 1] = {
  "platinum",
  "gold",
  "silver",
  "copper",
  "\n",
d39 11
d65 1
a65 2
      sprintf(buf, AHCYN "%d" ANRM " %s",
              coins[PLATINUM], coin_names[PLATINUM]);
d72 1
a72 2
      sprintf(buf, "%s" AHYEL "%d" ANRM " %s", buf,
              coins[GOLD], coin_names[GOLD]);
d81 1
a81 1
      sprintf(buf, "%s%d %s", buf, coins[SILVER], coin_names[SILVER]);
d88 1
a88 2
      sprintf(buf, "%s" AFYEL "%d" ANRM " %s", buf,
              coins[COPPER], coin_names[COPPER]);
d95 4
a98 20
static void briefmoneyelement(char *buf, int cointype, int amount)
{
   switch (cointype) {
      case PLATINUM:
         sprintf(buf, "%s&6&b%dp&0", buf, amount);
         break;
      case GOLD:
         sprintf(buf, "%s&3&b%dg&0", buf, amount);
         break;
      case SILVER:
         sprintf(buf, "%s&7&b%ds&0", buf, amount);
         break;
      case COPPER:
         sprintf(buf, "%s&3%dc&0", buf, amount);
         break;
      default:
         sprintf(buf, "%s&5%d?&0", buf, amount);
         break;
   }
}
d145 1
a145 1
      briefmoneyelement(buf, toptype, topval > maxval ? maxval : topval);
d147 1
a147 1
         briefmoneyelement(buf, lowtype, lowval);
d153 2
d179 2
a180 1
    if ((type = search_block(arg, coin_names, FALSE)) < 0) {
d267 1
a267 1
              coins[which], coin_names[which]);
d288 1
a288 1
    obj->name = strdupf("%s coin", coin_names[which]);
d323 4
@


1.4
log
@Change statemoney from strcat to strcpy semantics.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.3 2009/03/09 20:36:00 myc Exp myc $
d157 1
a157 1
bool parse_money(char *money, int coins[])
d161 2
d169 1
a169 1
  skip_spaces(&money);
d171 8
a178 7
  if (!*money)
    return FALSE;

  while (*money) {
    money = any_one_arg(money, arg);
    if (!is_number(arg))
      return FALSE; /* Not a number! */
d180 5
a184 3
    money = any_one_arg(money, arg);
    if ((type = search_block(arg, coin_names, FALSE)) < 0)
      return FALSE;
d186 1
d189 1
a189 1
  return TRUE;
d324 3
@


1.3
log
@Moved money functions from handler to here.
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.2 2009/03/09 05:51:25 jps Exp myc $
d25 1
d38 2
d50 2
a51 1
      sprintf(buf, "%s &0&b&6%d &0platinum&0", buf, coins[0]);
d53 1
a53 1
         sprintf(buf, "%s and", buf);
d55 1
a55 1
         sprintf(buf, "%s,", buf);
d58 6
a63 5
      sprintf(buf, "%s &0&b&3%d &0gold&0", buf, coins[1]);
      if (ctypes == 2 && ctype2 != 1)
         sprintf(buf, "%s and", buf);
      else if (ctypes == 4 || (ctypes ==3 && ctype2 == 2) )
         sprintf(buf, "%s,", buf);
d65 1
a65 1
         sprintf(buf, "%s, and", buf);
d68 5
a72 5
      sprintf(buf, "%s %d silver", buf, coins[2]);
      if (ctypes == 2 && ctype2 != 2)
         sprintf(buf, "%s and", buf);
      else if (ctypes == 4 || (ctypes == 3 && ctype2 == 2))
         sprintf(buf, "%s, and", buf);
d75 2
a76 1
      sprintf(buf, "%s &0&3%d&0 copper", buf, coins[3]);
d318 3
@


1.2
log
@Moved some money-related functions from utils to money
@
text
@d2 1
a2 1
 * $Id: money.c,v 1.1 2009/03/09 05:41:12 jps Exp jps $
d23 2
d46 1
a46 1
   if (coins[PLAT]) {
d77 1
a77 1
void briefmoneyelement(char *buf, int cointype, int amount)
d80 1
a80 1
      case PLAT:
d114 4
a117 4
   coins[PLAT] = amt / 1000;
   coins[GOLD] = (amt % 1000) / 100;
   coins[SILVER] = (amt % 100) / 10;
   coins[COPPER] = amt % 10;
d156 1
a156 1
  coins[PLAT] = 0;
d163 3
d181 129
d312 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d19 3
d32 143
d177 4
a180 1
 * $Log$
@
