head	1.66;
access;
symbols;
locks; strict;
comment	@ * @;


1.66
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2008.08.26.03.58.13;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.17.07.17.58;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.17.06.52.31;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.11.23.04.48;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.11.22.51.36;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2008.04.20.17.49.00;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.07.17.24.51;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.23.00.24.48;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.22.21.44.54;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.17.16.22.42;	author myc;	state Exp;
branches;
next	1.46;

1.46
date	2008.03.11.02.55.09;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.10.19.55.37;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.43;

1.43
date	2008.03.09.02.40.21;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.10.23.30.05;	author myc;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.07.01.46.14;	author myc;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.27.09.45.41;	author jps;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.14.15.51.52;	author myc;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.18.00.04.41;	author jps;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.19.21.04.15;	author rls;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.11.09.25.45;	author rls;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.11.09.07.49;	author rls;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.11.22.27.28;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.14.03.41.31;	author rls;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.08.16.01.22;	author mtp;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.26.00.46.22;	author mtp;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.28.01.46.44;	author mtp;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.28.01.26.11;	author mtp;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.23.05.11.16;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.22.01.09.13;	author mtp;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.09.03.43.19;	author rsd;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.14.11.12.40;	author mtp;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.13.23.13.42;	author mtp;	state Exp;
branches;
next	1.12;

1.12
date	99.12.10.05.13.14;	author cso;	state Exp;
branches;
next	1.11;

1.11
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.07.09.22.30.27;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.07.06.19.57.05;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.06.30.18.25.04;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.03.31.16.03.47;	author jen;	state Exp;
branches;
next	1.6;

1.6
date	99.03.30.19.46.06;	author jen;	state Exp;
branches;
next	1.5;

1.5
date	99.02.15.01.12.40;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.11.23.52.09;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.10.05.57.14;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.17.07.53;	author mud;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;

1.2.1.1
date	99.02.12.00.07.20;	author jimmy;	state Exp;
branches;
next	;


desc
@/********************************************************************************
 The below header states the original author of this file
Proky haschanged almost every aspect to allow mobs to use our unigue mobile booter
that allows universal balance and the use of bonus. Also Banyal total chnaged
all the save_internals to us a valid size check (templet) before save.
we mad almost 90K rooms and 7K mobs with this and never had a error
sometimes a save want save and its 'cause teh save was rejected by the templet
Banyal
********************************************************************************/





/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - medit.c 		                                          *
*    				                                          *
**  Copyright 1996 Harvey Gilpin.
*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "spells.h"
#include "utils.h"
#include "db.h"
#include "shop.h"
#include "olc.h"
#include "handler.h"
#include "dg_olc.h"


/*
 * Set this to 1 for debugging logs in medit_save_internally.
 */
#if 0
#define DEBUG
#endif

/*
 * Set this to 1 as a last resort to save mobiles.
 */
#if 0
#define I_CRASH
#endif


/*-------------------------------------------------------------------*/
/* external variables */
extern struct index_data *mob_index;
extern struct char_data *mob_proto;
extern struct char_data *character_list;
extern int top_of_mobt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern struct player_special_data dummy_mob;
extern struct attack_hit_type attack_hit_text[];
extern char *action_bits[];
extern char *affected_bits[];
extern char *position_types[];
extern char *genders[];
extern int top_shop;
extern struct shop_data *shop_index;
extern struct descriptor_data *descriptor_list;
#if defined(OASIS_MPROG)
extern const char *mobprog_types[];
#endif
extern char *mclass_types[];
extern char *mspecies_types[];				/*. constants.c .*/
/*-------------------------------------------------------------------*/
/*. Handy  macros .*/
#define GET_ZONE(ch) ((ch)->mob_specials.zone)


#define GET_NDD(mob) ((mob)->mob_specials.damnodice)
#define GET_SDD(mob) ((mob)->mob_specials.damsizedice)
#define GET_ALIAS(mob) ((mob)->player.name)
#define GET_SDESC(mob) ((mob)->player.short_descr)
#define GET_LDESC(mob) ((mob)->player.long_descr)
#define GET_DDESC(mob) ((mob)->player.description)
#define GET_ATTACK(mob) ((mob)->mob_specials.attack_type)
#define S_KEEPER(shop) ((shop)->keeper)
#if defined(OASIS_MPROG)
#define GET_MPROG(mob)		(mob_index[(mob)->nr].mobprogs)
#define GET_MPROG_TYPE(mob)	(mob_index[(mob)->nr].progtypes)
#endif

/*-------------------------------------------------------------------*/
/*. Function prototypes .*/
int get_ac(int level, int race, int class);
int mob_race_align(int);
byte mob_find_size(int);
void medit_parse(struct descriptor_data *d, char *arg);
void medit_disp_menu(struct descriptor_data *d);
void medit_setup_new(struct descriptor_data *d);
void medit_setup_existing(struct descriptor_data *d, int rmob_num);
void medit_save_internally(struct descriptor_data *d);
void medit_save_to_disk(int zone_num);
void init_mobile(struct char_data *mob);
void copy_mobile(struct char_data *tmob, struct char_data *fmob);
void medit_disp_positions(struct descriptor_data *d);
void medit_disp_mob_flags(struct descriptor_data *d);
void medit_disp_aff_flags(struct descriptor_data *d);
void medit_disp_attack_types(struct descriptor_data *d);
void medit_class_types(struct descriptor_data *d);
void medit_species_types(struct descriptor_data *d);
long get_set_exp(int, int, int, int);
sh_int get_set_hit(int, int, int, int);
sbyte get_set_hd(int, int, int, int);
int get_set_dice(int, int, int, int);
#if defined(OASIS_MPROG)
void medit_disp_mprog(struct descriptor_data *d);
void medit_change_mprog(struct descriptor_data *d);
const char *medit_get_mprog_type(struct mob_prog_data *mprog);
#endif

/*-------------------------------------------------------------------*\
  utility functions
\*-------------------------------------------------------------------*/

/* * * * *
 * Free a mobile structure that has been edited.
 * Take care of existing mobiles and their mob_proto!
 * * * * */

void medit_free_mobile(struct char_data *mob)
{
  int i;
  /*
   * Non-prototyped mobile.  Also known as new mobiles.
   */
  if (!mob)
    return;
  else if (GET_MOB_RNUM(mob) == -1) {
    if (mob->player.name)
      free(mob->player.name);
    if (mob->player.title)
      free(mob->player.title);
    if (mob->player.short_descr)
      free(mob->player.short_descr);
    if (mob->player.long_descr)
      free(mob->player.long_descr);
    if (mob->player.description)
      free(mob->player.description);
 } else if ((i = GET_MOB_RNUM(mob)) > -1) {	/* Prototyped mobile. */
    if (mob->player.name && mob->player.name != mob_proto[i].player.name)
      free(mob->player.name);
    if (mob->player.title && mob->player.title != mob_proto[i].player.title)
      free(mob->player.title);
    if (mob->player.short_descr && mob->player.short_descr != mob_proto[i].player.short_descr)
      free(mob->player.short_descr);
    if (mob->player.long_descr && mob->player.long_descr != mob_proto[i].player.long_descr)
      free(mob->player.long_descr);
    if (mob->player.description && mob->player.description != mob_proto[i].player.description)
      free(mob->player.description);
  }
  while (mob->affected)
    affect_remove(mob, mob->affected);

  free(mob);
}

void medit_setup_new(struct descriptor_data *d)
{
  struct char_data *mob;

  /*. Alloc some mob shaped space .*/
  CREATE(mob, struct char_data, 1);

  init_mobile(mob);

  GET_MOB_RNUM(mob) = -1;
  /*. default strings .*/
  GET_ALIAS(mob) = str_dup("mob unfinished");
  GET_SDESC(mob) = str_dup("the unfinished mob");
  GET_LDESC(mob) = str_dup("An unfinished mob stands here.\r\n");
  GET_DDESC(mob) = str_dup("It looks unfinished.\r\n");
#if defined(OASIS_MPROG)
  OLC_MPROGL(d) = NULL;
  OLC_MPROG(d) = NULL;
#endif

  OLC_MOB(d) = mob;
  OLC_ITEM_TYPE(d) = MOB_TRIGGER;
  dg_olc_script_copy(d);
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */

  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

void medit_setup_existing(struct descriptor_data *d, int rmob_num)
{
  struct char_data *mob;
#if defined(OASIS_MPROG)
  MPROG_DATA *temp;
  MPROG_DATA *head;
#endif

  /*
   * Allocate a scratch mobile structure.
   */
  CREATE(mob, struct char_data, 1);

  copy_mobile(mob, mob_proto + rmob_num);

#if defined(OASIS_MPROG)
  {
  /*
   * I think there needs to be a brace from the if statement to the #endif
   * according to the way the original patch was indented.  If this crashes,
   * try it with the braces and report to greerga@@van.ml.org on if that works.
   */
  if (GET_MPROG(mob))
    CREATE(OLC_MPROGL(d), MPROG_DATA, 1);
  head = OLC_MPROGL(d);
  for (temp = GET_MPROG(mob); temp;temp = temp->next) {
    OLC_MPROGL(d)->type = temp->type;
    OLC_MPROGL(d)->arglist = str_dup(temp->arglist);
    OLC_MPROGL(d)->comlist = str_dup(temp->comlist);
    if (temp->next) {
      CREATE(OLC_MPROGL(d)->next, MPROG_DATA, 1);
      OLC_MPROGL(d) = OLC_MPROGL(d)->next;
    }
  }
  OLC_MPROGL(d) = head;
  OLC_MPROG(d) = OLC_MPROGL(d);}
#endif

  OLC_MOB(d) = mob;
  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/
/*. Copy one mob struct to another .*/

void copy_mobile(struct char_data *tmob, struct char_data *fmob)
{
  struct trig_proto_list *proto, *fproto;

  /*. Free up any used strings .*/
  if (GET_ALIAS(tmob))
    free(GET_ALIAS(tmob));
  if (GET_SDESC(tmob))
    free(GET_SDESC(tmob));
  if (GET_LDESC(tmob))
    free(GET_LDESC(tmob));
  if (GET_DDESC(tmob))
    free(GET_DDESC(tmob));
  /* delete the old script list */
  proto = tmob->proto_script;
  while (proto) {
    fproto = proto;
    proto = proto->next;
    free(fproto);
  }

  /*
   * Copy mob over.
   */
  *tmob = *fmob;

  /*
   * Reallocate strings.
   */
  GET_ALIAS(tmob) = str_dup((GET_ALIAS(fmob) && *GET_ALIAS(fmob)) ? GET_ALIAS(fmob) : "undefined");
  GET_SDESC(tmob) = str_dup((GET_SDESC(fmob) && *GET_SDESC(fmob)) ? GET_SDESC(fmob) : "undefined");
  GET_LDESC(tmob) = str_dup((GET_LDESC(fmob) && *GET_LDESC(fmob)) ? GET_LDESC(fmob) : "undefined");
  GET_DDESC(tmob) = str_dup((GET_DDESC(fmob) && *GET_DDESC(fmob)) ? GET_DDESC(fmob) : "undefined");


  /* copy the new script list */
  if (fmob->proto_script) {
    fproto = fmob->proto_script;
    CREATE(proto, struct trig_proto_list, 1);
    tmob->proto_script = proto;
    do {
      proto->vnum = fproto->vnum;
      fproto = fproto->next;
      if (fproto) {
        CREATE(proto->next, struct trig_proto_list, 1);
        proto = proto->next;
      }
    } while (fproto);
  }

}


/*-------------------------------------------------------------------*/
/*. Ideally, this function should be in db.c, but I'll put it here for
    portability.*/

void init_mobile(struct char_data *mob)
{
  clear_char(mob);

  /*GET_HIT(mob) = 5;
  GET_MANA(mob) = 10;
  */
  (mob)->mob_specials.ex_no_dice = 0;
  (mob)->mob_specials.ex_face = 0;
  GET_SPECIES(mob) = 17;
  GET_CLASS(mob) = 13;
  GET_MAX_MANA(mob) = 100;
  GET_MAX_MOVE(mob) = 100;
  GET_NDD(mob) = 0;
  GET_SDD(mob) = 0;
  GET_WEIGHT(mob) = 200;
  GET_HEIGHT(mob) = 198;
  GET_SIZE(mob) = 2;

  mob->real_abils.str = 11;
  mob->real_abils.intel = 11;
  mob->real_abils.wis = 11;
  mob->real_abils.dex = 11;
  mob->real_abils.con = 11;
  mob->real_abils.cha = 11;
  mob->aff_abils = mob->real_abils;

  SET_BIT(MOB_FLAGS(mob), MOB_ISNPC);
  mob->player_specials = &dummy_mob;
}

/*-------------------------------------------------------------------*/
/*. Save new/edited mob to memory .*/

#define ZCMD zone_table[zone].cmd[cmd_no]

void medit_save_internally(struct descriptor_data *d)
{
  int rmob_num, found = 0, new_mob_num = 0, zone, cmd_no, shop;
  struct char_data *new_proto;
  struct index_data *new_index;
  struct char_data *live_mob;
  struct descriptor_data *dsc;

  /* put the script into proper position */
  OLC_MOB(d)->proto_script = OLC_SCRIPT(d);


  /*
   * Mob exists? Just update it.
   */
  if ((rmob_num = real_mobile(OLC_NUM(d))) != -1) {
    OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
    copy_mobile((mob_proto + rmob_num), OLC_MOB(d));
    /*
     * Update live mobiles.
     */
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (IS_MOB(live_mob) && GET_MOB_RNUM(live_mob) == rmob_num) {
        /*
	 * Only really need to update the strings, since these can
	 * cause protection faults.  The rest can wait till a reset/reboot.
	 */
	GET_ALIAS(live_mob) = GET_ALIAS(mob_proto + rmob_num);
	GET_SDESC(live_mob) = GET_SDESC(mob_proto + rmob_num);
	GET_LDESC(live_mob) = GET_LDESC(mob_proto + rmob_num);
	GET_DDESC(live_mob) = GET_DDESC(mob_proto + rmob_num);
      }
   }
  /*
   * Mob does not exist, we have to add it.
   */
  else {
#if defined(DEBUG)
    fprintf(stderr, "top_of_mobt: %d, new top_of_mobt: %d\n", top_of_mobt, top_of_mobt + 1);
#endif

    CREATE(new_proto, struct char_data, top_of_mobt + 2);
    CREATE(new_index, struct index_data, top_of_mobt + 2);

    for (rmob_num = 0; rmob_num <= top_of_mobt; rmob_num++) {
      if (!found) {		/* Is this the place? */
/*	if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) {*/
	if (mob_index[rmob_num].virtual > OLC_NUM(d)) {
	  /*
	   * Yep, stick it here.
	   */
	  found = TRUE;
#if defined(DEBUG)
	  fprintf(stderr, "Inserted: rmob_num: %d\n", rmob_num);
#endif
	  new_index[rmob_num].virtual = OLC_NUM(d);
	  new_index[rmob_num].number = 0;
	  new_index[rmob_num].func = NULL;
	  new_mob_num = rmob_num;
	  GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
	  copy_mobile((new_proto + rmob_num), OLC_MOB(d));
	  /*
	   * Copy the mob that should be here on top.
	   */
	  new_index[rmob_num + 1] = mob_index[rmob_num];
	  new_proto[rmob_num + 1] = mob_proto[rmob_num];
	  GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
	} else {	/* Nope, copy over as normal. */
	  new_index[rmob_num] = mob_index[rmob_num];
	  new_proto[rmob_num] = mob_proto[rmob_num];
	}
      } else { /* We've already found it, copy the rest over. */
	new_index[rmob_num + 1] = mob_index[rmob_num];
	new_proto[rmob_num + 1] = mob_proto[rmob_num];
	GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
      }
    }
#if defined(DEBUG)
    fprintf(stderr, "rmob_num: %d, top_of_mobt: %d, array size: 0-%d (%d)\n",
		rmob_num, top_of_mobt, top_of_mobt + 1, top_of_mobt + 2);
#endif
    if (!found) { /* Still not found, must add it to the top of the table. */
#if defined(DEBUG)
      fprintf(stderr, "Append.\n");
#endif
      new_index[rmob_num].virtual = OLC_NUM(d);
      new_index[rmob_num].number = 0;
      new_index[rmob_num].func = NULL;
      new_mob_num = rmob_num;
      GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
      copy_mobile((new_proto + rmob_num), OLC_MOB(d));
    }

    /*. Replace tables .*/
#if defined(DEBUG)
    fprintf(stderr, "Attempted free.\n");
#endif
#if !defined(I_CRASH)
    free(mob_index);
    free(mob_proto);
#endif
    mob_index = new_index;
    mob_proto = new_proto;
    top_of_mobt++;
#if defined(DEBUG)
    fprintf(stderr, "Free ok.\n");
#endif

    /*
     * Update live mobile rnums.
     */
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (GET_MOB_RNUM(live_mob) > new_mob_num)
	GET_MOB_RNUM(live_mob)++;

    /*
     * Update zone table.
     */
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
	if (ZCMD.command == 'M')
	  if (ZCMD.arg1 >= new_mob_num)
	    ZCMD.arg1++;

    /*
     * Update shop keepers.
     */
    if (shop_index)
      for (shop = 0; shop <= top_shop; shop++)
 	if (SHOP_KEEPER(shop) >= new_mob_num)
	  SHOP_KEEPER(shop)++;

    /*
     * Update keepers in shops being edited and other mobs being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT) {
	if (S_KEEPER(OLC_SHOP(dsc)) >= new_mob_num)
	  S_KEEPER(OLC_SHOP(dsc))++;
      } else if (dsc->connected == CON_MEDIT) {
	if (GET_MOB_RNUM(OLC_MOB(dsc)) >= new_mob_num)
	  GET_MOB_RNUM(OLC_MOB(dsc))++;
      }
  }

#if defined(OASIS_MPROG)
  GET_MPROG(OLC_MOB(d)) = OLC_MPROGL(d);
  GET_MPROG_TYPE(OLC_MOB(d)) = (OLC_MPROGL(d) ? OLC_MPROGL(d)->type : 0);
  while (OLC_MPROGL(d)) {
    GET_MPROG_TYPE(OLC_MOB(d)) |= OLC_MPROGL(d)->type;
    OLC_MPROGL(d) = OLC_MPROGL(d)->next;
  }
#endif

  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_MOB);
}



/*
 * Save ALL mobiles for a zone to their .mob file, mobs are all
 * saved in Extended format, regardless of whether they have any
 * extended fields.  Thanks to Sammy for ideas on this bit of code.
 */
void medit_save_to_disk(int zone_num)
{
  int i, rmob_num, zone, top;
  FILE *mob_file;
  char fname[64];
  struct char_data *mob;

 #if defined(OASIS_MPROG)
  MPROG_DATA *mob_prog = NULL;
#endif

  zone = zone_table[zone_num].number;
  top = zone_table[zone_num].top;

  sprintf(fname, "%s/%d.new", MOB_PREFIX, zone);
  if (!(mob_file = fopen(fname, "w"))) {
    mudlog("SYSERR: OLC: Cannot open mob file!", BRF, LVL_BUILDER, TRUE);
    return;
  }

   /*
   * Seach the database for mobs in this zone and save them.
   */
  for (i = zone * 100; i <= top; i++) {
    if ((rmob_num = real_mobile(i)) != -1) {
      if (fprintf(mob_file, "#%d\n", i) < 0) {
	mudlog("SYSERR: OLC: Cannot write mob file!\r\n", BRF, LVL_BUILDER, TRUE);
	fclose(mob_file);
	return;
      }
      mob = (mob_proto + rmob_num);

      /*
       * Clean up strings.
       */
      strcpy(buf1, (GET_LDESC(mob) && *GET_LDESC(mob)) ? GET_LDESC(mob) : "undefined");
      strip_string(buf1);
      strcpy(buf2, (GET_DDESC(mob) && *GET_DDESC(mob)) ? GET_DDESC(mob) : "undefined");
      strip_string(buf2);

   fprintf(mob_file, "%s~\n"
	"%s~\n"
	"%s~\n"
	"%s~\n"
	"%ld %ld %d E\n"
	"%d %d %d %dd%d+%d %dd%d+%d\n"
	"%d %d %ld %d\n"
	"%d %d %d %d %d %d %d\n",
	      (GET_ALIAS(mob) && *GET_ALIAS(mob)) ? GET_ALIAS(mob) : "undefined",
	      (GET_SDESC(mob) && *GET_SDESC(mob)) ? GET_SDESC(mob) : "undefined",
	      buf1, buf2, MOB_FLAGS(mob), AFF_FLAGS(mob), GET_ALIGNMENT(mob),
	      GET_LEVEL(mob), 20 - mob->mob_specials.ex_hitroll, /* Hitroll -> THAC0 */
	      GET_EX_AC(mob) / 10, (mob)->mob_specials.ex_no_dice, (mob)->mob_specials.ex_face, GET_MOVE(mob),
	      (mob)->mob_specials.ex_damnodice, (mob)->mob_specials.ex_damsizedice, mob->mob_specials.ex_damroll, GET_EX_GOLD(mob), GET_EX_PLAT(mob),
	      GET_EX_EXP(mob), zone, GET_POS(mob), GET_DEFAULT_POS(mob), GET_SEX(mob),
	     GET_CLASS(mob), GET_SPECIES(mob), GET_RACE_ALIGN(mob), GET_SIZE(mob)
      );

      /*
       * Deal with Extra stats in case they are there.
       */
      if (GET_ATTACK(mob) != 0)
	fprintf(mob_file, "BareHandAttack: %d\n", GET_ATTACK(mob));
            if (GET_STR(mob) != 11)
	fprintf(mob_file, "Str: %d\n", GET_STR(mob));
      if (GET_ADD(mob) != 0)
	fprintf(mob_file, "StrAdd: %d\n", GET_ADD(mob));
      if (GET_DEX(mob) != 11)
	fprintf(mob_file, "Dex: %d\n", GET_DEX(mob));
      if (GET_INT(mob) != 11)
	fprintf(mob_file, "Int: %d\n", GET_INT(mob));
      if (GET_WIS(mob) != 11)
	fprintf(mob_file, "Wis: %d\n", GET_WIS(mob));
      if (GET_CON(mob) != 11)
	fprintf(mob_file, "Con: %d\n", GET_CON(mob));
      if (GET_CHA(mob) != 11)
	fprintf(mob_file, "Cha: %d\n", GET_CHA(mob));

      /*
       * XXX: Add E-mob handlers here.
       */
      fprintf(mob_file, "E\n");

	  script_save_to_disk(mob_file, mob, MOB_TRIGGER);

#if defined(OASIS_MPROG)
      /*
       * Write out the MobProgs.
       */
      mob_prog = GET_MPROG(mob);
      while(mob_prog) {
	strcpy(buf1, mob_prog->arglist);
	strip_string(buf1);
	strcpy(buf2, mob_prog->comlist);
	strip_string(buf2);
	fprintf(mob_file, "%s %s~\n%s", medit_get_mprog_type(mob_prog),
					buf1, buf2);
	mob_prog = mob_prog->next;
	fprintf(mob_file, "~\n%s", (!mob_prog ? "|\n" : ""));
      }
#endif
    }
  }
  fprintf(mob_file, "$\n");
  fclose(mob_file);
    sprintf(buf2, "%s/%d.mob", MOB_PREFIX, zone);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(fname, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_MOB);
}

/**************************************************************************
 Menu functions
 **************************************************************************/
/*. Display poistions (sitting, standing etc) .*/

void medit_disp_positions(struct descriptor_data *d)
{
	int i;

  get_char_cols(d->character);

  #if defined(CLEAR_SCREEN)
send_to_char("[H[J", d->character);
  #endif
  for (i = 0; *position_types[i] != '\n'; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, position_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter position number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*. Display sex (Oooh-err).*/

#if defined(OASIS_MPROG)
/*
 * Get the type of MobProg.
 */
const char *medit_get_mprog_type(struct mob_prog_data *mprog)
{
  switch (mprog->type) {
  case IN_FILE_PROG:	return ">in_file_prog";
  case ACT_PROG:	return ">act_prog";
  case SPEECH_PROG:	return ">speech_prog";
  case RAND_PROG:	return ">rand_prog";
  case FIGHT_PROG:	return ">fight_prog";
  case HITPRCNT_PROG:	return ">hitprcnt_prog";
  case DEATH_PROG:	return ">death_prog";
  case ENTRY_PROG:	return ">entry_prog";
  case GREET_PROG:	return ">greet_prog";
  case ALL_GREET_PROG:	return ">all_greet_prog";
  case GIVE_PROG:	return ">give_prog";
  case BRIBE_PROG:	return ">bribe_prog";
  }
  return ">ERROR_PROG";
}

/*-------------------------------------------------------------------*/

/*
 * Display the MobProgs.
 */
void medit_disp_mprog(struct descriptor_data *d)
{
  struct mob_prog_data *mprog = OLC_MPROGL(d);

  OLC_MTOTAL(d) = 1;

#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  while (mprog) {
    sprintf(buf, "%d) %s %s\r\n", OLC_MTOTAL(d), medit_get_mprog_type(mprog),
		(mprog->arglist ? mprog->arglist : "NONE"));
    send_to_char(buf, d->character);
    OLC_MTOTAL(d)++;
    mprog = mprog->next;
  }
  sprintf(buf,  "%d) Create New Mob Prog\r\n"
		"%d) Purge Mob Prog\r\n"
		"Enter number to edit [0 to exit]:  ",
		OLC_MTOTAL(d), OLC_MTOTAL(d) + 1);
  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProgs.
 */
void medit_change_mprog(struct descriptor_data *d)
{
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  sprintf(buf,  "1) Type: %s\r\n"
		"2) Args: %s\r\n"
		"3) Commands:\r\n%s\r\n\r\n"
		"Enter number to edit [0 to exit]: ",
	medit_get_mprog_type(OLC_MPROG(d)),
	(OLC_MPROG(d)->arglist ? OLC_MPROG(d)->arglist: "NONE"),
	(OLC_MPROG(d)->comlist ? OLC_MPROG(d)->comlist : "NONE"));

  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_CHANGE_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProg type.
 */
void medit_disp_mprog_types(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif

  for (i = 0; i < NUM_PROGS-1; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, mobprog_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter mob prog type : ", d->character);
  OLC_MODE(d) = MEDIT_MPROG_TYPE;
}
#endif

/*-------------------------------------------------------------------*/

/*
 * Display the gender of the mobile.
 */

void medit_disp_sex(struct descriptor_data *d)
{
	int i;

  get_char_cols(d->character);

  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
 #endif
  for (i = 0; i < NUM_GENDERS; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, genders[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter gender number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*. Display attack types menu .*/

void medit_disp_attack_types(struct descriptor_data *d)
{
	int i;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (i = 0; i < NUM_ATTACK_TYPES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, attack_hit_text[i].singular);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter attack type : ", d->character);
}


/*-------------------------------------------------------------------*/
/*. Display mob-flags menu .*/

void medit_disp_mob_flags(struct descriptor_data *d)
{
	int i, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (i = 0; i < NUM_MOB_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, action_bits[i],
		!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(MOB_FLAGS(OLC_MOB(d)), action_bits, buf1);
    sprintf(buf, "\r\nCurrent flags : %s%s%s\r\nEnter mob flags (0 to quit) : ",
		  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

void medit_class_types(struct descriptor_data *d)
{
	int i;
 get_char_cols(d->character);
 #if defined(CLEAR_SCREEN)
/*send_to_char(".[H.[J", d->character);	*/
 send_to_char("\n\rListings of Classes\n\r", d->character);
 #endif
 for (i = 0; i < MCLASS_NUMBER; i++)
  {  sprintf(buf, "%s%2d%s) %s\r\n",
	grn, i, nrm, mclass_types[i]);
     send_to_char(buf, d->character);
  }
  send_to_char("Enter Class : ", d->character);

}

int mob_race_align(int arg)
{
	switch(arg) {
	case SPECIES_OTHER:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_UNDEAD:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_HUMANOID:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_ANIMAL:
	return RACE_ALIGN_GOOD;
	break;
	case SPECIES_DRAGON:
		return RACE_ALIGN_GOOD;
		break;
	case SPECIES_DEMON:
		return RACE_ALIGN_EVIL;
		break;
	case SPECIES_GIANT:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_TROLL:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_ORC:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_DUERGAR:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_DROW_ELF:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_OGRE:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_HUMAN:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_ELF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_HALF_ELF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_DWARF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_GNOME:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_BARBARIAN:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_HALFLING:
		return RACE_ALIGN_GOOD;
		break;
	default:
		return RACE_ALIGN_GOOD;
		break;
	}
}

byte mob_find_size(int arg)
{
	switch(arg) {
	case SPECIES_OTHER:
		return SIZE_MEDIUM;
	break;
	case SPECIES_UNDEAD:
		return SIZE_MEDIUM;
	break;
	case SPECIES_HUMANOID:
		return SIZE_MEDIUM;
	break;
	case SPECIES_ANIMAL:
	return SIZE_SMALL;
	break;
	case SPECIES_DRAGON:
		return SIZE_GARGANTUAN;
		break;
	case SPECIES_DEMON:
		return SIZE_GIANT;
		break;
	case SPECIES_GIANT:
		return SIZE_GIANT;
		break;
		case SPECIES_TROLL:
		return SIZE_LARGE;
		break;
		case SPECIES_ORC:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DUERGAR:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DROW_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_OGRE:
		return SIZE_HUGE;
		break;
		case SPECIES_HUMAN:
		return SIZE_MEDIUM;
		break;
		case SPECIES_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_HALF_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DWARF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_GNOME:
		return SIZE_SMALL;
		break;
		case SPECIES_BARBARIAN:
		return SIZE_LARGE;
		break;
		case SPECIES_HALFLING:
		return SIZE_SMALL;
		break;
	default:
		return SIZE_MEDIUM;
		break;
	}
}



void medit_species_types(struct descriptor_data *d)
{
	int i;
 get_char_cols(d->character);
 #if defined(CLEAR_SCREEN)
/*send_to_char(".[H.[J", d->character);	*/
 send_to_char("\n\rListings of Species\n\r", d->character);
 #endif
 for (i = 0; i < SPECIES_NUMBER; i++)
  {  sprintf(buf, "%s%2d%s) %s\r\n",
	grn, i, nrm, mspecies_types[i]);
     send_to_char(buf, d->character);
  }
  send_to_char("Enter Species : ", d->character);

}

/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/

void medit_disp_aff_flags(struct descriptor_data *d)
{
	int i, columns = 0;

  get_char_cols(d->character);
  #if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
  #endif
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits[i],
			!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(AFF_FLAGS(OLC_MOB(d)), affected_bits, buf1);
    sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
			  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*-------------------------------------------------------------------*/
/*. Display main menu .*/

/*
 * Display main menu.
 */
void medit_disp_menu(struct descriptor_data *d)
{
  struct char_data *mob;

  mob = OLC_MOB(d);
  get_char_cols(d->character);

    sprintf(buf,
#if defined(CLEAR_SCREEN)
".[H.[J"
#endif
	  "&0&1&bHitroll/Damroll/Main hp/numdamdice/sizedamdice are BONUSES&0\r\n"
	"-- Mob Number:  [%s%d%s]\r\n"
	"%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
        "%s3%s) S-Desc: %s%s\r\n"
	"%s4%s) L-Desc:-\r\n%s%s"
	"%s5%s) D-Desc:-\r\n%s%s"
	"%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]  Total exp: (%ld)\r\n"
        "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:     (%d)[%s%4d%s]\r\n"
        "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	"%sC%s)No HP Dice&0&1&bB&0:(%d)[%s%2d%s], %sD%s)Size HP Dice&0&1&bB&0:(%d)[%s%4d%s], %sE%s) Main&0&1&bB&0(%d):[%s%5d%s]\r\n"
	"%sF%s) Armor Class: (%d)[%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s]\r\n  %sH%s) Gold:  [%s%8d%s] %sR%s) Plat:  [%s%8d%s]\r\n",
	cyn, OLC_NUM(d), nrm,
	grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	grn, nrm, yel, GET_ALIAS(mob),
	grn, nrm, yel, GET_SDESC(mob),
	grn, nrm, yel, GET_LDESC(mob),
	grn, nrm, yel, GET_DDESC(mob),
	grn, nrm, cyn, GET_LEVEL(mob), nrm,
	grn, nrm, cyn, GET_ALIGNMENT(mob), nrm, GET_EXP(mob),
	grn, nrm,  (mob->points.hitroll), cyn, (mob->mob_specials.ex_hitroll), nrm,
	grn, nrm,  (mob->points.damroll), cyn, (mob->mob_specials.ex_damroll), nrm,
	grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
	grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
	grn, nrm, (mob)->points.hit, cyn, (mob->mob_specials.ex_no_dice), nrm,
	grn, nrm, (mob->points.mana), cyn, (mob->mob_specials.ex_face), nrm,
	grn, nrm, (GET_EX_MAIN_HP(mob) + (mob)->points.move), cyn, GET_MOVE(mob), nrm,
	grn, nrm, GET_AC(mob) , cyn, GET_EX_AC(mob), nrm,
        /*. Gold & Exp are longs in my mud, ignore any warnings .*/
	grn, nrm, cyn, (long)GET_EX_EXP(mob), nrm,
	grn, nrm, cyn, GET_EX_GOLD(mob), nrm,
	grn, nrm, cyn, GET_EX_PLAT(mob), nrm);
  send_to_char(buf, d->character);

  sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  sprintf(buf,
	    "%sI%s) Position  : %s%s\r\n"
        "%sJ%s) Default   : %s%s\r\n"
        "%sK%s) Attack    : %s%s\r\n"
        "%sL%s) NPC Flags : %s%s\r\n"
        "%sM%s) AFF Flags : %s%s\r\n"
		"%sN%s) Class	  : %s%s\r\n"
		"%sO%s) Species	  : %s%s\r\n"
#if defined(OASIS_MPROG)
	  "%sP%s) Mob Progs : %s%s\r\n"
#endif
	  "%sS%s) Script    : %s%s\r\n"
        "%sQ%s) Quit\r\n"
        "Enter choice : ",

	grn, nrm, yel, position_types[(int)GET_POS(mob)],
	grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
    grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
	grn, nrm, cyn, buf1,
	grn, nrm, cyn, buf2,
	grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],
	grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
#if defined(OASIS_MPROG)
	grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
#endif
	grn, nrm, cyn, mob->proto_script?"Set.":"Not Set.",
        grn, nrm
  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = MEDIT_MAIN_MENU;
}

/*

void medit_disp_menu(struct descriptor_data *d)
{
  struct char_data *mob;

  mob = OLC_MOB(d);
  get_char_cols(d->character);

    sprintf(buf,
#if defined(CLEAR_SCREEN)
".[H.[J"
#endif
	  "&0&1&bHitroll/Damroll/Main hp/numdamdice/sizedamdice are BONUSES&0\r\n"
	"-- Mob Number:  [%s%d%s]\r\n"
	"%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
        "%s3%s) S-Desc: %s%s\r\n"
	"%s4%s) L-Desc:-\r\n%s%s"
	"%s5%s) D-Desc:-\r\n%s%s"
	"%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]\r\n"
        "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:    (%d)[%s%4d%s]\r\n"
        "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	"%sC%s) Num HP Dice: [%s%4d%s],  %sD%s) Size HP Dice: [%s%4d%s],  %sE%s) Main hp&0&1&bB&0:(%ld)[%s%5d%s]\r\n"
	"%sF%s) Armor Class: [%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s],  %sH%s) Gold:  [%s%8ld%s]\r\n",
	cyn, OLC_NUM(d), nrm,
	grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	grn, nrm, yel, GET_ALIAS(mob),
	grn, nrm, yel, GET_SDESC(mob),
	grn, nrm, yel, GET_LDESC(mob),
	grn, nrm, yel, GET_DDESC(mob),
	grn, nrm, cyn, GET_LEVEL(mob), nrm,
	grn, nrm, cyn, GET_ALIGNMENT(mob), nrm,
	grn, nrm, (mob->points.hitroll) ,cyn, (mob->mob_specials.ex_hitroll), nrm,
	grn, nrm, (mob->points.hitroll), cyn, (mob->mob_specials.ex_damroll), nrm,
	grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
	grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
	grn, nrm, cyn, (mob->mob_specials.ex_no_dice), nrm,
	grn, nrm, cyn, (mob->mob_specials.ex_face), nrm,
	grn, nrm, cyn, GET_MOVE(mob), nrm,
	grn, nrm, cyn, GET_AC(mob), nrm,
   */     /*. Gold & Exp are longs in my mud, ignore any warnings .*/
/*	grn, nrm, ((long)GET_EXP(mob)), cyn, (long)GET_EX_EXP(mob), nrm,
	grn, nrm, cyn, (long)GET_GOLD(mob), nrm);
  send_to_char(buf, d->character);

  sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  sprintf(buf,
	    "%sI%s) Position  : %s%s\r\n"
        "%sJ%s) Default   : %s%s\r\n"
        "%sK%s) Attack    : %s%s\r\n"
        "%sL%s) NPC Flags : %s%s\r\n"
        "%sM%s) AFF Flags : %s%s\r\n"
		"%sN%s) Class	  : %s%s\r\n"
		"%sO%s) Species	  : %s%s\r\n"
#if defined(OASIS_MPROG)
	  "%sP%s) Mob Progs : %s%s\r\n"
#endif
        "%sQ%s) Quit\r\n"
        "Enter choice : ",

	grn, nrm, yel, position_types[(int)GET_POS(mob)],
	grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
        grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
	grn, nrm, cyn, buf1,
	grn, nrm, cyn, buf2,
	 grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],
	 grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
#if defined(OASIS_MPROG)
	  grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
#endif
        grn, nrm
  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = MEDIT_MAIN_MENU;
}


*/
/**************************************************************************
  The GARGANTAUN event handler
 **************************************************************************/

void medit_parse(struct descriptor_data *d, char *arg)
{
int i;
if (OLC_MODE(d) > MEDIT_NUMERICAL_RESPONSE) {
	if (!*arg || (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1]))))) {
      send_to_char("Field must be numerical, try again : ", d->character);
      return;
    }
  }

  switch (OLC_MODE(d))
  {
/*-------------------------------------------------------------------*/
  case MEDIT_CONFIRM_SAVESTRING:
    /*. Ensure mob has MOB_ISNPC set or things will go pair shaped .*/
    SET_BIT(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
    switch (*arg) {
    case 'y':
    case 'Y':
      /*. Save the mob in memory and to disk  .*/
      send_to_char("Saving mobile to memory.\r\n", d->character);
      medit_save_internally(d);
      sprintf(buf, "OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* FALL THROUGH */
    case 'n':
    case 'N':
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save the mobile? : ", d->character);
      return;
    }
    break;

/*-------------------------------------------------------------------*/
  case MEDIT_MAIN_MENU:
    i = 0;
      switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {	/* Anything been changed? */
	send_to_char("Do you wish to save the changes to the mobile? (y/n) : ", d->character);
	OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      OLC_MODE(d) = MEDIT_SEX;
      medit_disp_sex(d);
      return;
    case '2':
      OLC_MODE(d) = MEDIT_ALIAS;
      i--;
      break;
    case '3':
      OLC_MODE(d) = MEDIT_S_DESC;
      i--;
      break;
    case '4':
      OLC_MODE(d) = MEDIT_L_DESC;
      i--;
      break;
    case '5':
      OLC_MODE(d) = MEDIT_D_DESC;
      SEND_TO_Q("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_MOB(d)->player.description) {
	SEND_TO_Q(OLC_MOB(d)->player.description, d);
	d->backstr = str_dup(OLC_MOB(d)->player.description);
      }
      d->str = &OLC_MOB(d)->player.description;
      d->max_str = MAX_MOB_DESC;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      return;
    case '6':
      OLC_MODE(d) = MEDIT_LEVEL;
      i++;
      break;
    case '7':
      OLC_MODE(d) = MEDIT_ALIGNMENT;
      i++;
      break;
    case '8':
      OLC_MODE(d) = MEDIT_HITROLL;
      i++;
      break;
    case '9':
      OLC_MODE(d) = MEDIT_DAMROLL;
      i++;
      break;
    case 'a':
    case 'A':
      OLC_MODE(d) = MEDIT_NDD;
      i++;
      break;
    case 'b':
    case 'B':
      OLC_MODE(d) = MEDIT_SDD;
      i++;
      break;
    case 'c':
    case 'C':
      OLC_MODE(d) = MEDIT_NUM_HP_DICE;
      i++;
      break;
    case 'd':
    case 'D':
      OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
      i++;
      break;
    case 'e':
    case 'E':
      OLC_MODE(d) = MEDIT_ADD_HP;
      i++;
      break;
    case 'f':
    case 'F':
      OLC_MODE(d) = MEDIT_AC;
      i++;
      break;
    case 'g':
    case 'G':
      OLC_MODE(d) = MEDIT_EXP;
      i++;
      break;
    case 'h':
    case 'H':
      OLC_MODE(d) = MEDIT_EX_GOLD;
      i++;
      break;
	      case 'r':
    case 'R':
      OLC_MODE(d) = MEDIT_EX_PLAT;
      i++;
      break;
    case 'i':
    case 'I':
      OLC_MODE(d) = MEDIT_POS;
      medit_disp_positions(d);
      return;
    case 'j':
    case 'J':
      OLC_MODE(d) = MEDIT_DEFAULT_POS;
      medit_disp_positions(d);
      return;
    case 'k':
    case 'K':
      OLC_MODE(d) = MEDIT_ATTACK;
      medit_disp_attack_types(d);
      return;
    case 'l':
    case 'L':
      OLC_MODE(d) = MEDIT_NPC_FLAGS;
      medit_disp_mob_flags(d);
      return;
    case 'm':
    case 'M':
      OLC_MODE(d) = MEDIT_AFF_FLAGS;
      medit_disp_aff_flags(d);
      return;
		    case 'n':
	  case 'N':
		OLC_MODE(d) = MEDIT_CLASS;
	  	medit_class_types(d);
	  return;
	  case 'o':
	  case 'O':
		  OLC_MODE(d) = MEDIT_SPECIES;
		  medit_species_types(d);
		  return;
#if defined(OASIS_MPROG)
    case 'p':
    case 'P':
      OLC_MODE(d) = MEDIT_MPROG;
      medit_disp_mprog(d);
      return;
#endif
	case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
      default:
        medit_disp_menu(d);
	return;
    }
    if (i != 0) {
      send_to_char(i == 1 ? "\r\nEnter new value : " :
		   i == -1 ? "\r\nEnter new text :\r\n] " :
			"\r\nOops...:\r\n", d->character);
      return;

    }
    break;

/*-------------------------------------------------------------------*/
  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_ALIAS:
    if(GET_ALIAS(OLC_MOB(d)))
      free(GET_ALIAS(OLC_MOB(d)));
    GET_ALIAS(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_S_DESC:
    if(GET_SDESC(OLC_MOB(d)))
      free(GET_SDESC(OLC_MOB(d)));
    GET_SDESC(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_L_DESC:
    if(GET_LDESC(OLC_MOB(d)))
      free(GET_LDESC(OLC_MOB(d)));
    if (arg && *arg) {
      strcpy(buf, arg);
      strcat(buf, "\r\n");
      GET_LDESC(OLC_MOB(d)) = str_dup(buf);
    } else
      GET_LDESC(OLC_MOB(d)) = str_dup("undefined");


    break;
/*-------------------------------------------------------------------*/
  case MEDIT_D_DESC:
    /*
     * We should never get here.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached D_DESC case!",
			BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
/*-------------------------------------------------------------------*/
#if defined(OASIS_MPROG)
  case MEDIT_MPROG_COMLIST:
    /*
     * We should never get here, but if we do, bail out.
     */
    cleanup_olc(d, CLEANUP_ALL);
        mudlog("SYSERR: OLC: medit_parse(): Reached MPROG_COMLIST case!",
			BRF, LVL_BUILDER, TRUE);
    break;
#endif
/*-------------------------------------------------------------------*/
  case MEDIT_NPC_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
        else if (!((i < 0) || (i > NUM_MOB_FLAGS)))
      TOGGLE_BIT(MOB_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_mob_flags(d);
    return;
/*-------------------------------------------------------------------*/
  case MEDIT_AFF_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
        else if (!((i < 0) || (i > NUM_AFF_FLAGS)))
      TOGGLE_BIT(AFF_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_aff_flags(d);
    return;
/*-------------------------------------------------------------------*/
/*. Numerical responses .*/
#if defined(OASIS_MPROG)
  case MEDIT_MPROG:
    if ((i = atoi(arg)) == 0)
      medit_disp_menu(d);
    else if (i == OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      CREATE(temp, struct mob_prog_data, 1);
      temp->next = OLC_MPROGL(d);
      temp->type = -1;
      temp->arglist = NULL;
      temp->comlist = NULL;
      OLC_MPROG(d) = temp;
      OLC_MPROGL(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;
      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
        x++;
      OLC_MPROG(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i == OLC_MTOTAL(d) + 1) {
      send_to_char("Which mob prog do you want to purge? ", d->character);
      OLC_MODE(d) = MEDIT_PURGE_MPROG;
    } else
      medit_disp_menu(d);
    return;

  case MEDIT_PURGE_MPROG:
    if ((i = atoi(arg)) > 0 && i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;

      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
	x++;
      OLC_MPROG(d) = temp;
      REMOVE_FROM_LIST(OLC_MPROG(d), OLC_MPROGL(d), next);
      free(OLC_MPROG(d)->arglist);
      free(OLC_MPROG(d)->comlist);
      free(OLC_MPROG(d));
      OLC_MPROG(d) = NULL;
      OLC_VAL(d) = 1;
    }
    medit_disp_mprog(d);
    return;

  case MEDIT_CHANGE_MPROG: {
    if ((i = atoi(arg)) == 1)
      medit_disp_mprog_types(d);
    else if (i == 2) {
      send_to_char ("Enter new arg list: ", d->character);
      OLC_MODE(d) = MEDIT_MPROG_ARGS;
    } else if (i == 3) {
      send_to_char("Enter new mob prog commands:\r\n", d->character);
      /*
       * Pass control to modify.c for typing.
       */
      OLC_MODE(d) = MEDIT_MPROG_COMLIST;
      d->backstr = NULL;
      if (OLC_MPROG(d)->comlist) {
        SEND_TO_Q(OLC_MPROG(d)->comlist, d);
        d->backstr = str_dup(OLC_MPROG(d)->comlist);
      }
      d->str = &OLC_MPROG(d)->comlist;
      d->max_str = MAX_STRING_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
    } else
      medit_disp_mprog(d);
    return;}
#endif

/*-------------------------------------------------------------------*/

/*
 * Numerical responses.
 */

#if defined(OASIS_MPROG)

  /*David Klasinc suggests for MEDIT_MPROG_TYPE:

    switch (atoi(arg)) {
      case 0: OLC_MPROG(d)->type = 0; break;
      case 1: OLC_MPROG(d)->type = 1; break;
      case 2: OLC_MPROG(d)->type = 2; break;
      case 3: OLC_MPROG(d)->type = 4; break;
      case 4: OLC_MPROG(d)->type = 8; break;
      case 5: OLC_MPROG(d)->type = 16; break;
      case 6: OLC_MPROG(d)->type = 32; break;
      case 7: OLC_MPROG(d)->type = 64; break;
      case 8: OLC_MPROG(d)->type = 128; break;
      case 9: OLC_MPROG(d)->type = 256; break;
      case 10: OLC_MPROG(d)->type = 512; break;
      case 11: OLC_MPROG(d)->type = 1024; break;
      default: OLC_MPROG(d)->type = -1; break;
    }
*/
case MEDIT_MPROG_TYPE:
    OLC_MPROG(d)->type = (1 << MAX(0, MIN(atoi(arg), NUM_PROGS - 1)));
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;

  case MEDIT_MPROG_ARGS:
    OLC_MPROG(d)->arglist = str_dup(arg);
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;
#endif

  case MEDIT_SEX:
    GET_SEX(OLC_MOB(d)) = MAX(0, MIN(NUM_GENDERS -1, atoi(arg)));
    break;

  case MEDIT_HITROLL:
    OLC_MOB(d)->mob_specials.ex_hitroll = MAX(-50, MIN(50, atoi(arg)));
    OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;

	break;

  case MEDIT_DAMROLL:
    OLC_MOB(d)->mob_specials.ex_damroll = MAX(-50, MIN(50, atoi(arg)));
    OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
	OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll;

	break;

  case MEDIT_NDD:
    OLC_MOB(d)->mob_specials.ex_damnodice = MAX(-30, MIN(30, atoi(arg)));
    OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
    OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
	break;




  case MEDIT_SDD:
    OLC_MOB(d)->mob_specials.ex_damsizedice = MAX(-125, MIN(125, atoi(arg)));
   	OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;

	break;

  case MEDIT_NUM_HP_DICE:
    OLC_MOB(d)->mob_specials.ex_no_dice = MAX(-30, MIN(30, atoi(arg)));
		    OLC_MOB(d)->points.hit = 20;
	OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
    break;

  case MEDIT_SIZE_HP_DICE:
    OLC_MOB(d)->mob_specials.ex_face = MAX(-1000, MIN(1000, atoi(arg)));
		OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);
		OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;

    break;



  case MEDIT_ADD_HP:
    GET_MOVE(OLC_MOB(d)) = MAX(-30000, MIN(30000, atoi(arg)));
   	GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
    break;

  case MEDIT_AC:
    GET_EX_AC(OLC_MOB(d)) = MAX(-100, MIN(100, atoi(arg)));
    GET_AC(OLC_MOB(d)) = MIN(100, MAX(-100, (get_ac(OLC_MOB(d)->player.level, OLC_MOB(d)->player.race, OLC_MOB(d)->player.class) + GET_EX_AC(OLC_MOB(d))) ));
    break;

  case MEDIT_EXP:
    GET_EX_EXP(OLC_MOB(d)) = atol(arg);
    GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
	GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d));
	break;

 case MEDIT_EX_GOLD:
    GET_EX_GOLD(OLC_MOB(d)) = atol(arg);
	GET_GOLD(OLC_MOB(d)) += GET_EX_GOLD(OLC_MOB(d));
	break;

 case MEDIT_EX_PLAT:
    GET_EX_PLAT(OLC_MOB(d)) = atol(arg);
	GET_PLAT(OLC_MOB(d)) += GET_EX_PLAT(OLC_MOB(d));
	break;

  case MEDIT_POS:
    GET_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
    break;

  case MEDIT_DEFAULT_POS:
    GET_DEFAULT_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
    break;

  case MEDIT_ATTACK:
    GET_ATTACK(OLC_MOB(d)) = MAX(0, MIN(NUM_ATTACK_TYPES-1, atoi(arg)));
    break;

  case MEDIT_LEVEL:
    GET_LEVEL(OLC_MOB(d)) = MAX(1, MIN(100, atoi(arg)));
    break;

  case MEDIT_ALIGNMENT:
    GET_ALIGNMENT(OLC_MOB(d)) = MAX(-1000, MIN(1000, atoi(arg)));
    break;
  case MEDIT_CLASS:
	  GET_CLASS(OLC_MOB(d)) = atoi(arg);
  	  /*update class effected stuff*/
	  break;
	case MEDIT_SPECIES:
	  GET_RACE(OLC_MOB(d)) = atoi(arg);
  	  GET_RACE_ALIGN(OLC_MOB(d)) = mob_race_align(atoi(arg));
	  GET_SIZE(OLC_MOB(d)) = mob_find_size(atoi(arg));

	  break;


/*-------------------------------------------------------------------*/
  default:
    /*. We should never get here .*/
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }
/*-------------------------------------------------------------------*/
/*. END OF CASE
    If we get here, we have probably changed something, and now want to
    return to main menu.  Use OLC_VAL as a 'has changed' flag .*/

		   	  /*update species effected stuff*/
GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
    GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
	GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d));
 	OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);
	OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;
			    OLC_MOB(d)->points.hit = 20;
	OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
       	OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
	OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll;
       OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;
	 OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
    OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
	  	OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;



  OLC_VAL(d) = 1;
  medit_disp_menu(d);
}
/*. End of medit_parse() .*/
@


1.66
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@/***************************************************************************
 * $Id: medit.c,v 1.65 2009/03/08 23:34:14 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: medit.c                                        Part of FieryMUD *
 *  Usage: OASIS OLC - ?                                                   *
 *     By: Harvey Gilpin of TwyliteMud by Rv. (shameless plug)             *
 *         Copyright 1996 Harvey Gilpin.                                   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "comm.h"
#include "casting.h"
#include "utils.h"
#include "db.h"
#include "shop.h"
#include "olc.h"
#include "handler.h"
#include "dg_olc.h"
#include "races.h"
#include "skills.h"
#include "chars.h"
#include "constants.h"
#include "math.h"
#include "fight.h"
#include "modify.h"
#include "genzon.h"
#include "composition.h"
#include "lifeforce.h"
#include "charsize.h"

/*
 * Set this to 1 for debugging logs in medit_save_internally.
 */
#if 0
#define DEBUG
#endif

/*
 * Set this to 1 as a last resort to save mobiles.
 */
#if 0
#define I_CRASH
#endif


/*-------------------------------------------------------------------*/
/* external variables */

extern struct player_special_data dummy_mob;

/*-------------------------------------------------------------------*/
/*. Handy  macros .*/

#define GET_ZONE(ch) ((ch)->mob_specials.zone)
#define GET_NDD(mob) ((mob)->mob_specials.damnodice)
#define GET_SDD(mob) ((mob)->mob_specials.damsizedice)
#define GET_SDESC(mob) ((mob)->player.short_descr)
#define GET_MOBLDESC(mob) ((mob)->player.long_descr)
#define GET_DDESC(mob) ((mob)->player.description)
#define GET_ATTACK(mob) ((mob)->mob_specials.attack_type)
#define S_KEEPER(shop) ((shop)->keeper)
/*-------------------------------------------------------------------*/
/*. Function prototypes .*/
int get_ac(int level, int race, int class);
void medit_parse(struct descriptor_data *d, char *arg);
void medit_disp_menu(struct descriptor_data *d);
void medit_setup_new(struct descriptor_data *d);
void medit_setup_existing(struct descriptor_data *d, int rmob_num);
void medit_save_internally(struct descriptor_data *d);
void medit_save_to_disk(int zone_num);
void init_mobile(struct char_data *mob);
void copy_mobile(struct char_data *tmob, struct char_data *fmob);
void medit_disp_stances(struct descriptor_data *d);
void medit_disp_positions(struct descriptor_data *d);
void medit_disp_mob_flags(struct descriptor_data *d);
void medit_disp_aff_flags(struct descriptor_data *d);
void medit_disp_attack_types(struct descriptor_data *d);
void medit_class_types(struct descriptor_data *d);
void medit_size(struct descriptor_data *d);
void medit_race_types(struct descriptor_data *d);
long get_set_exp(int, int, int, int);
sh_int get_set_hit(int, int, int, int);
sbyte get_set_hd(int, int, int, int);
int get_set_dice(int, int, int, int);

/*-------------------------------------------------------------------*\
  utility functions
\*-------------------------------------------------------------------*/

/* * * * *
 * Free a mobile structure that has been edited.
 * Take care of existing mobiles and their mob_proto!
 * * * * */

void medit_free_mobile(struct char_data *mob)
{
  int i;
  /*
   * Non-prototyped mobile.  Also known as new mobiles.
   */
  if (!mob)
    return;
  else if (GET_MOB_RNUM(mob) == -1) {
    if (mob->player.namelist)
      free(mob->player.namelist);
    if (mob->player.title)
      free(mob->player.title);
    if (mob->player.short_descr)
      free(mob->player.short_descr);
    if (GET_MOBLDESC(mob))
      free(GET_MOBLDESC(mob));
    if (mob->player.description)
      free(mob->player.description);
  } else if ((i = GET_MOB_RNUM(mob)) > -1) {    /* Prototyped mobile. */
    if (mob->player.namelist && mob->player.namelist != mob_proto[i].player.namelist)
      free(mob->player.namelist);
    if (mob->player.title && mob->player.title != mob_proto[i].player.title)
      free(mob->player.title);
    if (mob->player.short_descr && mob->player.short_descr != mob_proto[i].player.short_descr)
      free(mob->player.short_descr);
    if (GET_MOBLDESC(mob) && GET_MOBLDESC(mob) != mob_proto[i].player.long_descr)
      free(GET_MOBLDESC(mob));
    if (mob->player.description && mob->player.description != mob_proto[i].player.description)
      free(mob->player.description);
  }
  while (mob->effects)
    effect_remove(mob, mob->effects);

  free(mob);
}

void medit_setup_new(struct descriptor_data *d)
{
  struct char_data *mob;

  /*. Alloc some mob shaped space .*/
  CREATE(mob, struct char_data, 1);

  init_mobile(mob);

  GET_MOB_RNUM(mob) = -1;
  /*. default strings .*/
  GET_NAMELIST(mob) = strdup("mob unfinished");
  GET_SDESC(mob) = strdup("the unfinished mob");
  GET_MOBLDESC(mob) = strdup("An unfinished mob stands here.\r\n");
  GET_DDESC(mob) = strdup("It looks unfinished.\r\n");
  GET_CLASS(mob) = CLASS_DEFAULT;

  OLC_MOB(d) = mob;

  /*
  ** to be honest I am not sure if these lines need to be here
  ** but since they didn't seem to be doing any harm I left them
  */
  OLC_ITEM_TYPE(d) = MOB_TRIGGER;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  dg_olc_script_copy(d);
  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

void medit_setup_existing(struct descriptor_data *d, int rmob_num)
{
  struct char_data *mob;

  /*
   * Allocate a scratch mobile structure.
   */
  CREATE(mob, struct char_data, 1);

  copy_mobile(mob, mob_proto + rmob_num);

  OLC_MOB(d) = mob;
  OLC_ITEM_TYPE(d) = MOB_TRIGGER;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  dg_olc_script_copy(d);
  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/
/*. Copy one mob struct to another .*/

void copy_mobile(struct char_data *tmob, struct char_data *fmob)
{
  /*. Free up any used strings .*/
  if (GET_NAMELIST(tmob))
    free(GET_NAMELIST(tmob));
  if (GET_SDESC(tmob))
    free(GET_SDESC(tmob));
  if (GET_MOBLDESC(tmob))
    free(GET_MOBLDESC(tmob));
  if (GET_DDESC(tmob))
    free(GET_DDESC(tmob));

  /* delete the old script list */
  if (tmob->proto_script && tmob->proto_script != fmob->proto_script)
    free_proto_script(&tmob->proto_script);

  /*
   * Copy mob over.
   */
  *tmob = *fmob;

  /*
   * Reallocate strings.
   */
  GET_NAMELIST(tmob) = strdup((GET_NAMELIST(fmob) && *GET_NAMELIST(fmob)) ? GET_NAMELIST(fmob) : "undefined");
  GET_SDESC(tmob) = strdup((GET_SDESC(fmob) && *GET_SDESC(fmob)) ? GET_SDESC(fmob) : "undefined");
  GET_MOBLDESC(tmob) = strdup((GET_MOBLDESC(fmob) && *GET_MOBLDESC(fmob)) ? GET_MOBLDESC(fmob) : "undefined");
  GET_DDESC(tmob) = strdup((GET_DDESC(fmob) && *GET_DDESC(fmob)) ? GET_DDESC(fmob) : "undefined");
}


/*-------------------------------------------------------------------*/
/*. Ideally, this function should be in db.c, but I'll put it here for
  portability.*/

void init_mobile(struct char_data *mob)
{
  clear_char(mob);

  /*GET_HIT(mob) = 5;
    GET_MANA(mob) = 10;
  */
  (mob)->mob_specials.ex_hpnumdice = 0;
  (mob)->mob_specials.ex_hpsizedice = 0;
  GET_RACE(mob) = DEFAULT_RACE;
  GET_CLASS(mob) = CLASS_UNDEFINED;
  GET_MAX_MANA(mob) = 100;
  GET_MAX_MOVE(mob) = 100;
  GET_NDD(mob) = 0;
  GET_SDD(mob) = 0;
  GET_WEIGHT(mob) = 200;
  GET_HEIGHT(mob) = 198;
  set_base_size(mob, SIZE_MEDIUM);

  mob->natural_abils.str = 11;
  mob->natural_abils.intel = 11;
  mob->natural_abils.wis = 11;
  mob->natural_abils.dex = 11;
  mob->natural_abils.con = 11;
  mob->natural_abils.cha = 11;
  mob->affected_abils = mob->natural_abils;

  SET_FLAG(MOB_FLAGS(mob), MOB_ISNPC);
  mob->player_specials = &dummy_mob;
}

/*-------------------------------------------------------------------*/
/*. Save new/edited mob to memory .*/

#define ZCMD (zone_table[zone].cmd[cmd_no])

void medit_save_internally(struct descriptor_data *d)
{
  int rmob_num, found = 0, new_mob_num = 0, zone, cmd_no, shop;
  struct char_data *new_proto;
  struct index_data *new_index;
  struct char_data *live_mob;
  struct descriptor_data *dsc;

      int i;
  /* put the script into proper position */
  OLC_MOB(d)->proto_script = OLC_SCRIPT(d);


  /*
   * Mob exists? Just update it.
   */
  if ((rmob_num = real_mobile(OLC_NUM(d))) != -1) {

    /*
     * Are we purging?
     */
    if (OLC_MODE(d) == MEDIT_PURGE_MOBILE)
    {
      struct char_data *placeholder;
      void extract_char(struct char_data * ch); /* leaves eq behind..*/

      for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      {
        if (IS_MOB(live_mob) && GET_MOB_RNUM(live_mob) == rmob_num)
    {
        placeholder=live_mob;
#if defined(DEBUG)
        fprintf(stderr, "remove mob %d ",GET_MOB_VNUM(live_mob));
#endif
        extract_char(live_mob);    /*remove all existing mobs*/
        live_mob=placeholder;    /*so we can keep removing..*/
#if defined(DEBUG)
        fprintf(stderr,"(%d left)\n",mob_index[rmob_num].number);
#endif
    }
      }
    CREATE(new_proto, struct char_data, top_of_mobt );
    CREATE(new_index, struct index_data, top_of_mobt );
#if defined(DEBUG)
    fprintf(stderr,"looking to destroy %d (%d)\n",rmob_num,mob_index[rmob_num].virtual);
#endif
        for (i = 0; i <= top_of_mobt ; i++)
    {
          if (!found)
      {        /* Is this the place? */
    /*    if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) */
        if (i == rmob_num)
        {
          found = TRUE;
          /* don't copy..it will be blatted by the free later*/
        }
        else
        {    /* Nope, copy over as normal. */
          new_index[i] = mob_index[i];
          new_proto[i] = mob_proto[i];
        }
          }
      else
      { /* We've already found it, copy the rest over. */
        new_index[i - 1] = mob_index[i];
        new_proto[i - 1] = mob_proto[i];
          }
    }
        top_of_mobt --;
#if !defined(I_CRASH)
        free(mob_index);
        free(mob_proto);
#endif
        mob_index = new_index;
        mob_proto = new_proto;
        /*
         * Update live mobile rnums.
         */
        for (live_mob = character_list; live_mob; live_mob = live_mob->next)
          if (GET_MOB_RNUM(live_mob) > rmob_num)
        GET_MOB_RNUM(live_mob)--;

        /*
         * Update zone table.
         */
        for (zone = 0; zone <= top_of_zone_table; zone++)
          for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
        if (ZCMD.command == 'M')
          if (ZCMD.arg1 >= rmob_num)
            ZCMD.arg1--;

        /*
         * Update shop keepers.
         */
        if (shop_index)
          for (shop = 0; shop <= top_shop; shop++)
         if (SHOP_KEEPER(shop) >= rmob_num)
          SHOP_KEEPER(shop)--;

        /*
         * Update keepers in shops being edited and other mobs being edited.
         */
        for (dsc = descriptor_list; dsc; dsc = dsc->next)
          if (dsc->connected == CON_SEDIT) {
        if (S_KEEPER(OLC_SHOP(dsc)) >= rmob_num)
          S_KEEPER(OLC_SHOP(dsc))--;
          } else if (dsc->connected == CON_MEDIT) {
        if (GET_MOB_RNUM(OLC_MOB(dsc)) >= rmob_num)
          GET_MOB_RNUM(OLC_MOB(dsc))--;
          }
    }
    else
    {

      OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
      copy_mobile((mob_proto + rmob_num), OLC_MOB(d));
      /*
       * Update live mobiles.
       */
      for (live_mob = character_list; live_mob; live_mob = live_mob->next)
        if (IS_MOB(live_mob) && GET_MOB_RNUM(live_mob) == rmob_num) {
          /*
       * Only really need to update the strings, since these can
       * cause protection faults.  The rest can wait till a reset/reboot.
       */
      GET_NAMELIST(live_mob) = GET_NAMELIST(mob_proto + rmob_num);
      GET_SDESC(live_mob) = GET_SDESC(mob_proto + rmob_num);
      GET_MOBLDESC(live_mob) = (GET_MOBLDESC(mob_proto + rmob_num));
      GET_DDESC(live_mob) = GET_DDESC(mob_proto + rmob_num);
        }
    }
  }
  /*
   * Mob does not exist, we have to add it.
   */
  else {
#if defined(DEBUG)
    fprintf(stderr, "top_of_mobt: %d, new top_of_mobt: %d\n", top_of_mobt, top_of_mobt + 1);
#endif

    CREATE(new_proto, struct char_data, top_of_mobt + 2);
    CREATE(new_index, struct index_data, top_of_mobt + 2);

    for (rmob_num = 0; rmob_num <= top_of_mobt; rmob_num++) {
      if (!found) {        /* Is this the place? */
    /*    if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) {*/
    if (mob_index[rmob_num].virtual > OLC_NUM(d)) {
      /*
       * Yep, stick it here.
       */
      found = TRUE;
#if defined(DEBUG)
      fprintf(stderr, "Inserted: rmob_num: %d\n", rmob_num);
#endif
      new_index[rmob_num].virtual = OLC_NUM(d);
      new_index[rmob_num].number = 0;
      new_index[rmob_num].func = NULL;
      new_mob_num = rmob_num;
      GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
      copy_mobile((new_proto + rmob_num), OLC_MOB(d));
      /*
       * Copy the mob that should be here on top.
       */
      new_index[rmob_num + 1] = mob_index[rmob_num];
      new_proto[rmob_num + 1] = mob_proto[rmob_num];
      GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
    } else {    /* Nope, copy over as normal. */
      new_index[rmob_num] = mob_index[rmob_num];
      new_proto[rmob_num] = mob_proto[rmob_num];
    }
      } else { /* We've already found it, copy the rest over. */
    new_index[rmob_num + 1] = mob_index[rmob_num];
    new_proto[rmob_num + 1] = mob_proto[rmob_num];
    GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
      }
    }
#if defined(DEBUG)
    fprintf(stderr, "rmob_num: %d, top_of_mobt: %d, array size: 0-%d (%d)\n",
        rmob_num, top_of_mobt, top_of_mobt + 1, top_of_mobt + 2);
#endif
    if (!found) { /* Still not found, must add it to the top of the table. */
#if defined(DEBUG)
      fprintf(stderr, "Append.\n");
#endif
      new_index[rmob_num].virtual = OLC_NUM(d);
      new_index[rmob_num].number = 0;
      new_index[rmob_num].func = NULL;
      new_mob_num = rmob_num;
      GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
      copy_mobile((new_proto + rmob_num), OLC_MOB(d));
    }

    /*. Replace tables .*/
#if defined(DEBUG)
    fprintf(stderr, "Attempted free.\n");
#endif
#if !defined(I_CRASH)
    free(mob_index);
    free(mob_proto);
#endif
    mob_index = new_index;
    mob_proto = new_proto;
    top_of_mobt++;
#if defined(DEBUG)
    fprintf(stderr, "Free ok.\n");
#endif

    /*
     * Update live mobile rnums.
     */
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (GET_MOB_RNUM(live_mob) > new_mob_num)
    GET_MOB_RNUM(live_mob)++;

    /*
     * Update zone table.
     */
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
    if (ZCMD.command == 'M')
      if (ZCMD.arg1 >= new_mob_num)
        ZCMD.arg1++;

    /*
     * Update shop keepers.
     */
    if (shop_index)
      for (shop = 0; shop <= top_shop; shop++)
     if (SHOP_KEEPER(shop) >= new_mob_num)
      SHOP_KEEPER(shop)++;

    /*
     * Update keepers in shops being edited and other mobs being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT) {
    if (S_KEEPER(OLC_SHOP(dsc)) >= new_mob_num)
      S_KEEPER(OLC_SHOP(dsc))++;
      } else if (dsc->connected == CON_MEDIT) {
    if (GET_MOB_RNUM(OLC_MOB(dsc)) >= new_mob_num)
      GET_MOB_RNUM(OLC_MOB(dsc))++;
      }
  }

    /*debug: dump the list*/
#if defined(DEBUG)
    fprintf(stderr,"there are now %d mobs in the list:\n",top_of_mobt);
#endif
    /*for (i=0;i<top_of_mobt;i++)*/
    /*
      for (live_mob = character_list,i=0; live_mob; live_mob = live_mob->next,i++)
        fprintf(stderr,"(%d - %d:%s)",i,GET_MOB_VNUM(live_mob),GET_NAME(live_mob));
        */
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_MOB);
}



/*
 * Save ALL mobiles for a zone to their .mob file, mobs are all
 * saved in Extended format, regardless of whether they have any
 * extended fields.  Thanks to Sammy for ideas on this bit of code.
 */
void medit_save_to_disk(int zone_num)
{
  int i, rmob_num, zone, top;
  FILE *mob_file;
  char fname[64];
  struct char_data *mob;

  zone = zone_table[zone_num].number;
  top = zone_table[zone_num].top;

  sprintf(fname, "%s/%d.new", MOB_PREFIX, zone);
  if (!(mob_file = fopen(fname, "w"))) {
    mudlog("SYSERR: OLC: Cannot open mob file!", BRF, LVL_GOD, TRUE);
    return;
  }

  /*
   * Seach the database for mobs in this zone and save them.
   */
  for (i = zone * 100; i <= top; i++) {
    if ((rmob_num = real_mobile(i)) != -1) {
      if (fprintf(mob_file, "#%d\n", i) < 0) {
    mudlog("SYSERR: OLC: Cannot write mob file!\r\n", BRF, LVL_GOD, TRUE);
    fclose(mob_file);
    return;
      }
      mob = (mob_proto + rmob_num);

      /*
       * Clean up strings.
       */
      strcpy(buf1, (GET_MOBLDESC(mob) && *GET_MOBLDESC(mob)) ? GET_MOBLDESC(mob) : "undefined");
      strip_string(buf1);
      strcpy(buf2, (GET_DDESC(mob) && *GET_DDESC(mob)) ? GET_DDESC(mob) : "undefined");
      strip_string(buf2);

      fprintf(mob_file, "%s~\n"
          "%s~\n"
          "%s~\n"
          "%s~\n"
          "%ld %ld %d E\n"
          "%d %d %d %dd%d+%d %dd%d+%d\n"
          "%d %d %ld %d\n"
          "%d %d %d %d %d %d %d\n",
          (GET_NAMELIST(mob) && *GET_NAMELIST(mob)) ? GET_NAMELIST(mob) : "undefined",
          (GET_SDESC(mob) && *GET_SDESC(mob)) ? GET_SDESC(mob) : "undefined",
          buf1, buf2, MOB_FLAGS(mob)[0], EFF_FLAGS(mob)[0], GET_ALIGNMENT(mob),
          GET_LEVEL(mob), 20 - mob->mob_specials.ex_hitroll, /* Hitroll -> THAC0 */
          GET_EX_AC(mob) / 10, (mob)->mob_specials.ex_hpnumdice, (mob)->mob_specials.ex_hpsizedice, GET_MOVE(mob),
          (mob)->mob_specials.ex_damnodice, (mob)->mob_specials.ex_damsizedice, mob->mob_specials.ex_damroll, GET_EX_GOLD(mob), GET_EX_PLATINUM(mob),
          GET_EX_EXP(mob), zone, GET_POS(mob), GET_DEFAULT_POS(mob), GET_SEX(mob),
          GET_CLASS(mob), GET_RACE(mob), GET_RACE_ALIGN(mob), GET_SIZE(mob)
          );

      /*
       * Deal with Extra stats in case they are there.
       */
      if (GET_ATTACK(mob) != 0)
    fprintf(mob_file, "BareHandAttack: %d\n", GET_ATTACK(mob));
      if (GET_STR(mob) != 11)
    fprintf(mob_file, "Str: %d\n", GET_STR(mob));
      if (GET_DEX(mob) != 11)
    fprintf(mob_file, "Dex: %d\n", GET_DEX(mob));
      if (GET_INT(mob) != 11)
    fprintf(mob_file, "Int: %d\n", GET_INT(mob));
      if (GET_WIS(mob) != 11)
    fprintf(mob_file, "Wis: %d\n", GET_WIS(mob));
      if (GET_CON(mob) != 11)
    fprintf(mob_file, "Con: %d\n", GET_CON(mob));
      if (GET_CHA(mob) != 11)
    fprintf(mob_file, "Cha: %d\n", GET_CHA(mob));

   fprintf(mob_file, "AFF2: %ld\n", EFF_FLAGS(mob)[1]);
   fprintf(mob_file, "AFF3: %ld\n", EFF_FLAGS(mob)[2]);
   fprintf(mob_file, "MOB2: %ld\n", MOB_FLAGS(mob)[1]);
   fprintf(mob_file, "PERC: %ld\n", GET_PERCEPTION(mob));
   fprintf(mob_file, "HIDE: %ld\n", GET_HIDDENNESS(mob));
   fprintf(mob_file, "Lifeforce: %d\n", GET_LIFEFORCE(mob));
   fprintf(mob_file, "Composition: %d\n", BASE_COMPOSITION(mob));
   fprintf(mob_file, "Stance: %d\n", GET_STANCE(mob));

      /*
       * XXX: Add E-mob handlers here.
       */
      fprintf(mob_file, "E\n");

      script_save_to_disk(mob_file, mob, MOB_TRIGGER);

    }
  }
  fprintf(mob_file, "$\n");
  fclose(mob_file);
  sprintf(buf2, "%s/%d.mob", MOB_PREFIX, zone);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(fname, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_MOB);
}

/*************************************************************************
 *                Menu functions                               *
 *************************************************************************/

void medit_disp_stances(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; *stance_types[i] != '\n'; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, stance_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter stance number : ", d->character);
}

/*. Display positions (sitting, standing etc) .*/

void medit_disp_positions(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; *position_types[i] != '\n'; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, position_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter position number : ", d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display the gender of the mobile.
 */

void medit_disp_sex(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_SEXES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, genders[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter gender number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*
 * Display the mobile's size! -- Cas
 */

void medit_size(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_SIZES; i++) {
    sprintf(buf, "%s%2d%s) %c%s\r\n", grn, i, nrm, (sizes[i].name)[0],
          sizes[i].name + 1);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter size number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*. Display attack types menu .*/

void medit_disp_attack_types(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_ATTACK_TYPES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, attack_hit_text[i].singular);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter attack type : ", d->character);
}


/*-------------------------------------------------------------------*/
/*. Display mob-flags menu .*/

#define FLAG_INDEX    ((NUM_MOB_FLAGS / columns + 1) * j + i)
void medit_disp_mob_flags(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif

  /* Outer loop goes through rows, inner loop goes through columns. */
  for (i = 0; i <= NUM_MOB_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j) {
      if (FLAG_INDEX >= NUM_MOB_FLAGS)
        break;
      sprintf(buf, "%s%s%2d%s) %-20.20s", buf, grn, FLAG_INDEX + 1, nrm, action_bits[FLAG_INDEX]);
    }
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintflag(buf1, MOB_FLAGS(OLC_MOB(d)), NUM_MOB_FLAGS, action_bits);
  sprintf(buf, "\r\nCurrent flags : %s%s%s\r\nEnter mob flags (0 to quit) : ",
      cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
#undef FLAG_INDEX


void medit_class_types(struct descriptor_data *d)
{
  int i;
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("\r\nListings of Classes\r\n", d->character);
#endif
  for (i = 0; i < NUM_CLASSES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, classes[i].plainname);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter Class : ", d->character);
}


void medit_race_types(struct descriptor_data *d)
{
  int i;
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  /*send_to_char(".[H.[J", d->character);    */
  send_to_char("\r\nListings of Races\r\n", d->character);
#endif
  for (i = 0; i < NUM_RACES; i++)
    {  sprintf(buf, "%s%2d%s) %s\r\n",
           grn, i, nrm, races[i].plainname);
    send_to_char(buf, d->character);
    }
  send_to_char("Enter Races : ", d->character);

}

/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/

#define FLAG_INDEX    ((NUM_EFF_FLAGS / columns + 1) * j + i)
void medit_disp_aff_flags(struct descriptor_data *d)
{
  const int columns = 3;
  int i, j;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i <= NUM_EFF_FLAGS / columns; ++i) {
    *buf = '\0';
    for (j = 0; j < columns; ++j) {
      if (FLAG_INDEX >= NUM_EFF_FLAGS)
        break;
      sprintf(buf, "%s%s%2d%s) %-20.20s", buf, grn, FLAG_INDEX + 1, nrm, effect_flags[FLAG_INDEX]);
    }
    send_to_char(strcat(buf, "\r\n"), d->character);
  }

  sprintflag(buf1, EFF_FLAGS(OLC_MOB(d)), NUM_EFF_FLAGS, effect_flags);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
      cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
#undef FLAG_INDEX

/*-------------------------------------------------------------------*/
/*. Display life forces menu .*/

void medit_disp_lifeforces(struct descriptor_data *d)
{
   int i;

#if defined(CLEAR_SCREEN)
   send_to_char("[H[J", d->character);
#endif
   for (i = 0; i < NUM_LIFEFORCES; i++) {
      sprintf(buf, "%s%2d%s) %s%c%s%s\r\n", grn, i, nrm,
            lifeforces[i].color,
            UPPER((lifeforces[i].name)[0]),
            lifeforces[i].name + 1, nrm);
      send_to_char(buf, d->character);
   }
   send_to_char("Enter life force number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*. Display compositions menu .*/

void medit_disp_compositions(struct descriptor_data *d)
{
#if defined(CLEAR_SCREEN)
   send_to_char("[H[J", d->character);
#endif
   list_olc_compositions(d->character);
   send_to_char("Enter composition number : ", d->character);
}

/*-------------------------------------------------------------------*/
/*. Display main menu .*/

/*
 * Display main menu.
 */
void medit_disp_menu(struct descriptor_data *d)
{
  struct char_data *mob;

  mob = OLC_MOB(d);
  get_char_cols(d->character);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
      ".[H.[J"
#endif
      "-- Mob: '&5%s&0'  vnum: [&2%5d&0]\r\n"
      "&2&b0&0) Alias: &6%s&0\r\n"
      "&2&b1&0) Short: &6%s&0\r\n"
      "&2&b2&0) Long : &6%s&0\r"
      "&2&b3&0) Description:\r\n&6%s&0"
      "&2&b4&0) Race: &6%-10s&0            &2&b5&0) Size: &6%-10s&0         &2&b6&0) Sex: &6%s&0\r\n"
      "&2&b7&0) Level: &6%-3d&0                  &2&b8&0) Class: &6%-10s&0        &2&b9&0) Alignment: &6%d&0\r\n",

      GET_SDESC(mob), OLC_NUM(d), GET_NAMELIST(mob), GET_SDESC(mob), GET_MOBLDESC(mob), GET_DDESC(mob),
      RACE_PLAINNAME(mob), SIZE_DESC(mob),
      genders[(int)GET_SEX(mob)], GET_LEVEL(mob), classes[(int)GET_CLASS(mob)].plainname, GET_ALIGNMENT(mob));
  send_to_char(buf, d->character);

  sprintf(buf,
      "&2&bA&0) Hitroll    : (&6%3d&0) [&6&b%3d&0]    &2&bB&0) Damroll     : (&6%3d&0) [&6&b%3d&0]\r\n"
      "&2&bC&0&0) # Dam Dice : (&6%3d&0) [&6&b%3d&0]    &2&bD&0) Size Dam Die: (&6%3d&0) [&6&b%3d&0]  (ie. XdY + Z) \r\n"
      "&2&bE&0) # HP Dice  : (&6%3d&0) [&6&b%3d&0]    &2&bF&0) Size HP Dice: (&6%3d&0) [&6&b%3d&0] &2&bG&0) Bonus: (&6%5d&0) [&6&b%5d&0]\r\n"
          "&2&bH&0) Armor Class: (&6%3d&0) [&6&b%3d&0]    &2&bI&0) Exp         : [&6&b%9ld&0]\r\n"
          "&2&bJ&0) Gold       : [&6&b%8d&0]     &2&bK&0) Platinum     : [&6&b%9d&0]\r\n",
      (mob->points.hitroll), (mob->mob_specials.ex_hitroll),
      (mob->points.damroll), (mob->mob_specials.ex_damroll),
      (mob->mob_specials.damnodice),   (mob->mob_specials.ex_damnodice),
      (mob->mob_specials.damsizedice), (mob->mob_specials.ex_damsizedice),
      (mob)->points.hit,  (mob->mob_specials.ex_hpnumdice),
      (mob->points.mana), (mob->mob_specials.ex_hpsizedice),
      (GET_EX_MAIN_HP(mob) + (mob)->points.move), GET_MOVE(mob),
      GET_AC(mob), GET_EX_AC(mob),
      (long)GET_EX_EXP(mob), GET_EX_GOLD(mob), GET_EX_PLATINUM(mob));
  send_to_char(buf, d->character);

  sprintflag(buf1, MOB_FLAGS(mob), NUM_MOB_FLAGS, action_bits);
  sprintflag(buf2, EFF_FLAGS(mob), NUM_EFF_FLAGS, effect_flags);

  sprintf(buf,
          "&2&bL&0) Perception : [&6&b%4ld&0]         &2&bM&0) Hiddenness  : [&6&b%4ld&0]\r\n"
     "&2&bN&0) Life Force    : %s%c%s&0\r\n"
     "&2&bO&0) Composition   : %s%c%s&0\r\n"
      "&2&bP&0) Stance        : &6%s&0\r\n"
      "&2&bR&0) Load Position : &6%s&0\r\n"
      "&2&bT&0) Default Pos   : &6%s&0\r\n"
      "&2&bU&0) Attack Type   : &6%s&0\r\n"
      "&2&bV&0) Act Flags     : &6%s&0\r\n"
      "&2&bW&0) Aff Flags     : &6%s&0\r\n"
      "&2&bS&0) Script        : &6%s&0\r\n"
      "&2&bQ&0) Quit\r\n"
      "Enter choice : ",

         GET_PERCEPTION(mob), GET_HIDDENNESS(mob),
         LIFEFORCE_COLOR(mob), UPPER(*LIFEFORCE_NAME(mob)), LIFEFORCE_NAME(mob) + 1,
         COMPOSITION_COLOR(mob), UPPER(*COMPOSITION_NAME(mob)), COMPOSITION_NAME(mob) + 1,

         stance_types[(int)GET_STANCE(mob)],
     position_types[(int)GET_POS(mob)],
     position_types[(int)GET_DEFAULT_POS(mob)],
     attack_hit_text[GET_ATTACK(mob)].singular,
     buf1,
     buf2,
     mob->proto_script?"&6&bSet&0":"&6Not Set&0");
  send_to_char(buf, d->character);

  OLC_MODE(d) = MEDIT_MAIN_MENU;
}

/**************************************************************************
 *                The GARGANTAUN event handler                      *
 **************************************************************************/

void medit_parse(struct descriptor_data *d, char *arg)
{
  int i;
  if (OLC_MODE(d) > MEDIT_NUMERICAL_RESPONSE) {
    if (!*arg || (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1]))))) {
      send_to_char("Field must be numerical, try again : ", d->character);
      return;
    }
  }

  switch (OLC_MODE(d))
    {
/*-------------------------------------------------------------------*/
    case MEDIT_CONFIRM_SAVESTRING:
      /*. Ensure mob has MOB_ISNPC set or things will go pair shaped .*/
      SET_FLAG(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
      switch (*arg) {
      case 'y':
      case 'Y':
    /*. Save the mob in memory and to disk  .*/
    send_to_char("Saving mobile to memory.\r\n", d->character);
    medit_save_internally(d);
    sprintf(buf, "OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
    mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    /* FALL THROUGH */
        cleanup_olc(d, CLEANUP_STRUCTS);
        return;
      case 'n':
      case 'N':
    cleanup_olc(d, CLEANUP_ALL);
    return;
      default:
    send_to_char("Invalid choice!\r\n", d->character);
    send_to_char("Do you wish to save the mobile? : ", d->character);
    return;
      }
      break;

/*-------------------------------------------------------------------*/
    case MEDIT_MAIN_MENU:
      i = 0;
      switch (*arg)
      {
      case 'q':
      case 'Q':
    if (OLC_VAL(d)) {    /* Anything been changed? */
      send_to_char("Do you wish to save the changes to the mobile? (y/n) : ", d->character);
      OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
    } else
      cleanup_olc(d, CLEANUP_ALL);
    return;
      case '0':
    OLC_MODE(d) = MEDIT_ALIAS;
    i--;
    break;
      case '1':
    OLC_MODE(d) = MEDIT_S_DESC;
    i--;
    break;
      case '2':
    OLC_MODE(d) = MEDIT_L_DESC;
    i--;
    break;
      case '3':
    OLC_MODE(d) = MEDIT_D_DESC;
    write_to_output("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
        string_write(d, &OLC_MOB(d)->player.description, MAX_MOB_DESC);
    OLC_VAL(d) = 1;
    return;
      case '4':
    OLC_MODE(d) = MEDIT_RACE;
    medit_race_types(d);
    return;
      case '5':
        OLC_MODE(d) = MEDIT_SIZE;
        medit_size(d);
        return;
      case '6':
    OLC_MODE(d) = MEDIT_SEX;
    medit_disp_sex(d);
    return;
      case '7':
    OLC_MODE(d) = MEDIT_LEVEL;
    i++;
    break;
      case '8':
    OLC_MODE(d) = MEDIT_CLASS;
    medit_class_types(d);
    return;
      case '9':
    OLC_MODE(d) = MEDIT_ALIGNMENT;
    i++;
    break;
      case 'a':
      case 'A':
    OLC_MODE(d) = MEDIT_HITROLL;
    i++;
    break;
      case 'b':
      case 'B':
    OLC_MODE(d) = MEDIT_DAMROLL;
    i++;
    break;
      case 'c':
      case 'C':
    OLC_MODE(d) = MEDIT_NDD;
    i++;
    break;
      case 'd':
      case 'D':
    OLC_MODE(d) = MEDIT_SDD;
    i++;
    break;
      case 'e':
      case 'E':
    OLC_MODE(d) = MEDIT_NUM_HP_DICE;
    i++;
    break;
      case 'f':
      case 'F':
    OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
    i++;
    break;
      case 'g':
      case 'G':
    OLC_MODE(d) = MEDIT_ADD_HP;
    i++;
    break;
      case 'h':
      case 'H':
    OLC_MODE(d) = MEDIT_AC;
    i++;
    break;
      case 'i':
      case 'I':
    OLC_MODE(d) = MEDIT_EXP;
    i++;
    break;
      case 'j':
      case 'J':
    OLC_MODE(d) = MEDIT_EX_GOLD;
    i++;
    break;
      case 'k':
      case 'K':
    OLC_MODE(d) = MEDIT_EX_PLATINUM;
    i++;
    break;
      case 'l':
      case 'L':
        OLC_MODE(d) = MEDIT_PERCEPTION;
        i++;
        break;
      case 'm':
      case 'M':
        OLC_MODE(d) = MEDIT_HIDDENNESS;
        i++;
        break;
      case 'n':
      case 'N':
        OLC_MODE(d) = MEDIT_LIFEFORCE;
        medit_disp_lifeforces(d);
        return;
        break;
      case 'o':
      case 'O':
        OLC_MODE(d) = MEDIT_COMPOSITION;
        medit_disp_compositions(d);
        return;
        break;
      case 'p':
      case 'P':
        OLC_MODE(d) = MEDIT_STANCE;
        medit_disp_stances(d);
        return;
      case 'r':
      case 'R':
    OLC_MODE(d) = MEDIT_POS;
    medit_disp_positions(d);
    return;
      case 't':
      case 'T':
    OLC_MODE(d) = MEDIT_DEFAULT_POS;
    medit_disp_positions(d);
    return;
      case 'u':
      case 'U':
    OLC_MODE(d) = MEDIT_ATTACK;
    medit_disp_attack_types(d);
    return;
      case 'v':
      case 'V':
    OLC_MODE(d) = MEDIT_NPC_FLAGS;
    medit_disp_mob_flags(d);
    return;
      case 'w':
      case 'W':
    OLC_MODE(d) = MEDIT_AFF_FLAGS;
    medit_disp_aff_flags(d);
    return;
      case 's':
      case 'S':
    OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
    dg_script_menu(d);
    return;
    /*  purging = bad thing!  removed from display back in 2k?, commented out 20060409 - RLS
        case '?':
    if (GET_MOB_RNUM(OLC_MOB(d)) == -1)
    {
        send_to_char("You cannot purge a non-existent (unsaved) mob! Choose again:\r\n",d->character);
    }
    else if (GET_LEVEL(d->character)<LVL_HEAD_B)
    {
        sprintf(buf,"You are too low level to purge! Get a level %d or greater to do this.\r\n",LVL_HEAD_B);
        send_to_char(buf,d->character);
    }
    else
    {
      OLC_MODE(d) = MEDIT_PURGE_MOBILE;
      * make extra sure*
      send_to_char("Purging will also remove all existing mobiles of this sort!\r\n", d->character);
      send_to_char("Are you sure you wish to PERMANENTLY DELETE the mobile? (y/n) : ", d->character);
    }
    return; */
      default:
        medit_disp_menu(d);
    return;
      }
      if (i != 0) {
    send_to_char(i == 1 ? "\r\nEnter new value : " :
             i == -1 ? "\r\nEnter new text :\r\n] " :
             "\r\nOops...:\r\n", d->character);
    return;

      }
      break;

/*-------------------------------------------------------------------*/
    case OLC_SCRIPT_EDIT:
      if (dg_script_edit_parse(d, arg)) return;
      break;
/*-------------------------------------------------------------------*/
    case MEDIT_ALIAS:
      if(GET_NAMELIST(OLC_MOB(d)))
    free(GET_NAMELIST(OLC_MOB(d)));
      GET_NAMELIST(OLC_MOB(d)) = strdup((arg && *arg) ? arg : "undefined");
      break;
/*-------------------------------------------------------------------*/
    case MEDIT_S_DESC:
      if(GET_SDESC(OLC_MOB(d)))
    free(GET_SDESC(OLC_MOB(d)));
      GET_SDESC(OLC_MOB(d)) = strdup((arg && *arg) ? arg : "undefined");
      break;
/*-------------------------------------------------------------------*/
    case MEDIT_L_DESC:
      if(GET_MOBLDESC(OLC_MOB(d)))
    free(GET_MOBLDESC(OLC_MOB(d)));
      if (arg && *arg) {
    strcpy(buf, arg);
    strcat(buf, "\r\n");
    GET_MOBLDESC(OLC_MOB(d)) = strdup(buf);
      } else
    GET_MOBLDESC(OLC_MOB(d)) = strdup("undefined");


      break;
/*-------------------------------------------------------------------*/
    case MEDIT_D_DESC:
      /*
       * We should never get here.
       */
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: medit_parse(): Reached D_DESC case!",
         BRF, LVL_GOD, TRUE);
      send_to_char("Oops...\r\n", d->character);
      break;
/*-------------------------------------------------------------------*/
    case MEDIT_NPC_FLAGS:
      if ((i = atoi(arg)) == 0)
    break;
      else if (i > 0 && i <= NUM_MOB_FLAGS)
    TOGGLE_FLAG(MOB_FLAGS(OLC_MOB(d)), i - 1);
      medit_disp_mob_flags(d);
      return;
/*-------------------------------------------------------------------*/
    case MEDIT_AFF_FLAGS:
      if ((i = atoi(arg)) == 0)
    break;
      else if (i > 0 && i <= NUM_EFF_FLAGS)
    TOGGLE_FLAG(EFF_FLAGS(OLC_MOB(d)), i - 1);
      medit_disp_aff_flags(d);
      return;
/*-------------------------------------------------------------------*/
      /*. Numerical responses .*/

    case MEDIT_SEX:
      GET_SEX(OLC_MOB(d)) = MAX(0, MIN(NUM_SEXES -1, atoi(arg)));
      break;

    case MEDIT_SIZE:
      set_base_size(OLC_MOB(d), MAX(0, MIN(NUM_SIZES -1, atoi(arg))));
      break;

    case MEDIT_HITROLL:
      OLC_MOB(d)->mob_specials.ex_hitroll = MAX(-50, MIN(50, atoi(arg)));
      OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
      OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;

      break;

    case MEDIT_DAMROLL:
      OLC_MOB(d)->mob_specials.ex_damroll = MAX(-50, MIN(50, atoi(arg)));
      OLC_MOB(d)->points.damroll    = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
      OLC_MOB(d)->points.damroll    += OLC_MOB(d)->mob_specials.ex_damroll;

      break;

    case MEDIT_NDD:
      OLC_MOB(d)->mob_specials.ex_damnodice = MAX(-30, MIN(30, atoi(arg)));
      OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
      OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
      break;


    case MEDIT_SDD:
      OLC_MOB(d)->mob_specials.ex_damsizedice = MAX(-125, MIN(125, atoi(arg)));
      OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
      OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;

      break;

    case MEDIT_NUM_HP_DICE:
      OLC_MOB(d)->mob_specials.ex_hpnumdice = MAX(-30, MIN(30, atoi(arg)));
      OLC_MOB(d)->points.hit = 20;
      OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_hpnumdice;
      break;

    case MEDIT_SIZE_HP_DICE:
      OLC_MOB(d)->mob_specials.ex_hpsizedice = MAX(MIN_ALIGNMENT, MIN(MAX_ALIGNMENT, atoi(arg)));
      OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);
      OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_hpsizedice;

      break;



    case MEDIT_ADD_HP:
      GET_MOVE(OLC_MOB(d)) = MAX(-30000, MIN(30000, atoi(arg)));
      GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
      break;

    case MEDIT_AC:
      GET_EX_AC(OLC_MOB(d)) = MAX(-100, MIN(100, atoi(arg)));
      GET_AC(OLC_MOB(d)) = MIN(100, MAX(-100, (get_ac(OLC_MOB(d)->player.level, OLC_MOB(d)->player.race, OLC_MOB(d)->player.class) + GET_EX_AC(OLC_MOB(d))) ));
      break;

    case MEDIT_EXP:
      GET_EX_EXP(OLC_MOB(d)) = atol(arg);
      GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
      GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d));
      break;

    case MEDIT_EX_GOLD:
      GET_EX_GOLD(OLC_MOB(d)) = atol(arg);
      GET_GOLD(OLC_MOB(d)) += GET_EX_GOLD(OLC_MOB(d));
      break;

    case MEDIT_EX_PLATINUM:
      GET_EX_PLATINUM(OLC_MOB(d)) = atol(arg);
      GET_PLATINUM(OLC_MOB(d)) += GET_EX_PLATINUM(OLC_MOB(d));
      break;

    case MEDIT_PERCEPTION:
      GET_PERCEPTION(OLC_MOB(d)) = MAX(0, MIN(atol(arg), 1000));
      break;

    case MEDIT_HIDDENNESS:
      GET_HIDDENNESS(OLC_MOB(d)) = MAX(0, MIN(atol(arg), 1000));
      break;

    case MEDIT_LIFEFORCE:
      i = parse_lifeforce(d->character, arg);
      if (i != LIFE_UNDEFINED)
         GET_LIFEFORCE(OLC_MOB(d)) = i;
      else {
         medit_disp_lifeforces(d);
         return;
      }
      break;

    case MEDIT_COMPOSITION:
      i = parse_composition(d->character, arg);
      if (i != COMP_UNDEFINED) {
         BASE_COMPOSITION(OLC_MOB(d)) = i;
         GET_COMPOSITION(OLC_MOB(d)) = i;
      } else {
         medit_disp_compositions(d);
         return;
      }
      break;

    case MEDIT_STANCE:
      GET_STANCE(OLC_MOB(d)) = MAX(0, MIN(NUM_STANCES - 1, atoi(arg)));
      break;

    case MEDIT_POS:
      GET_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS - 1, atoi(arg)));
      break;

    case MEDIT_DEFAULT_POS:
      GET_DEFAULT_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS - 1, atoi(arg)));
      break;

    case MEDIT_ATTACK:
      GET_ATTACK(OLC_MOB(d)) = MAX(0, MIN(NUM_ATTACK_TYPES - 1, atoi(arg)));
      break;

    case MEDIT_LEVEL:
      GET_LEVEL(OLC_MOB(d)) = MAX(1, MIN(100, atoi(arg)));
      /* generate autolevel values for mob */
      break;
    case MEDIT_ALIGNMENT:
      GET_ALIGNMENT(OLC_MOB(d)) = MAX(-1000, MIN(1000, atoi(arg)));
      break;
    case MEDIT_CLASS:
      if (atoi(arg) < 0 || atoi(arg) >= NUM_CLASSES) {
         send_to_char("That choice is out of range.  Please try again: ",
               d->character);
         return;
      }
      GET_CLASS(OLC_MOB(d)) = atoi(arg);
      break;

    case MEDIT_RACE:
      if (atoi(arg) < 0 || atoi(arg) >= NUM_RACES) {
         send_to_char("That choice is out of range.  Please try again: ",
               d->character);
         return;
      }
      GET_RACE(OLC_MOB(d)) = atoi(arg);
      init_proto_race(OLC_MOB(d));
      init_char_race(OLC_MOB(d));
      update_char_race(OLC_MOB(d));
      /* GET_RACE_ALIGN(OLC_MOB(d)) = ALIGN_OF_RACE(atoi(arg)); */
      break;
    case MEDIT_PURGE_MOBILE:
      switch (*arg) {
      case 'y':
      case 'Y':
    /*. Splat the mob in memory ..*/
    send_to_char("Purging mobile from memory.\r\n", d->character);

    /*need to remove all existing mobs of this type too..*/
    /*ok..we use save internally, but we are purging because of the mode*/
    medit_save_internally(d);
    sprintf(buf, "OLC: %s PURGES mob %d", GET_NAME(d->character), OLC_NUM(d));
    mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    /* FALL THROUGH */
      case 'n':
      case 'N':
    cleanup_olc(d, CLEANUP_ALL);
    return;
      default:
    send_to_char("Invalid choice!\r\n", d->character);
    send_to_char("Do you wish to purge the mobile? : ", d->character);
    return;
      }
      break;


/*-------------------------------------------------------------------*/
    default:
      /*. We should never get here .*/
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: medit_parse(): Reached default case!", BRF, LVL_GOD, TRUE);
      send_to_char("Oops...\r\n", d->character);
      break;
    }
/*-------------------------------------------------------------------*/
  /*. END OF CASE
    If we get here, we have probably changed something, and now want to
    return to main menu.  Use OLC_VAL as a 'has changed' flag .*/

  /* update species effected stuff */
  GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
  GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
  GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d));
  OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);
  OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_hpsizedice;
  OLC_MOB(d)->points.hit = 20;
  OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_hpnumdice;
  OLC_MOB(d)->points.damroll    = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
  OLC_MOB(d)->points.damroll    += OLC_MOB(d)->mob_specials.ex_damroll;
  OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
  OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;
  OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
  OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
  OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
  OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;



  OLC_VAL(d) = 1;
  medit_disp_menu(d);
}
/*. End of medit_parse() .*/


bool delete_mobile(obj_num rnum)
{
   int i, vnum, zrnum, zone, cmd_no;
   struct char_data *mob, *tmp, *next;
   bool save_this_zone, mload_just_deleted;

   if (rnum == NOTHING || rnum > top_of_mobt) {
      sprintf(buf, "ERR: delete_mobile() rnum %d out of range", rnum);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return FALSE;
   }

   mob = &mob_proto[rnum];
   vnum = GET_MOB_VNUM(mob);

   zrnum = find_real_zone_by_room(GET_MOB_VNUM(mob));
   if (zrnum == -1) {
      sprintf(buf, "ERR: delete_mobile() can't identify zone for mob vnum %d", vnum);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return FALSE;
   }

   for (tmp = character_list; tmp; tmp = next) {
      next = tmp->next;
      if (GET_MOB_VNUM(tmp) == vnum)
         extract_char(tmp);
   }

   /* Make sure all are removed. */
   assert(mob_index[rnum].number == 0);

   /* Adjust rnums of all other mobiles. */
   for (tmp = character_list; tmp; tmp = tmp->next) {
      if (IS_NPC(tmp))
         GET_MOB_RNUM(tmp) -= (GET_MOB_RNUM(tmp) > rnum);
   }

   for (i = rnum; i < top_of_mobt; i++) {
      mob_index[i] = mob_index[i + 1];
      mob_proto[i] = mob_proto[i + 1];
      GET_MOB_RNUM(&mob_proto[i]) = i;
   }

   top_of_mobt--;
   RECREATE(mob_index, struct index_data, top_of_mobt + 1);
   RECREATE(mob_proto, struct char_data, top_of_mobt + 1);

   /* Renumber zone table. */
   for (zone = 0; zone <= top_of_zone_table; zone++) {
      save_this_zone = FALSE;
      mload_just_deleted = FALSE;
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {
         switch (ZCMD.command) {
            case 'E':
            case 'F':
            case 'G':
               /* These are commands that refer to a previously-loaded mobile.
                * If we just deleted a command to load the deleted mobile, then
                * this command should be deleted too. */
               if (mload_just_deleted) {
                  delete_zone_command(&zone_table[zone], cmd_no);
                  cmd_no--;
                  save_this_zone = TRUE;
               }
               break;
            case 'M':
               if (ZCMD.arg1 == rnum) {
                  delete_zone_command(&zone_table[zone], cmd_no);
                  cmd_no--;
                  mload_just_deleted = TRUE;
                  save_this_zone = TRUE;
               } else {
                  ZCMD.arg1 -= (ZCMD.arg1 > rnum);
                  mload_just_deleted = FALSE;
               }
               break;
            default:
               mload_just_deleted = FALSE;
         }
      }
      if (save_this_zone) {
         olc_add_to_save_list(zone_table[zone].number, OLC_SAVE_ZONE);
      }
   }

   olc_add_to_save_list(zone_table[zrnum].number, OLC_SAVE_MOB);

   return TRUE;
}

/***************************************************************************
 * $Log: medit.c,v $
 * Revision 1.65  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.64  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.63  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.62  2008/08/26 03:58:13  jps
 * Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
 * Except the one for wzoneecho, since it needed to find a real zone by zone number.
 *
 * Revision 1.61  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.60  2008/08/17 07:17:58  jps
 * Correctly mark which zone files need saving when deleting a mobile.
 *
 * Revision 1.59  2008/08/17 06:52:31  jps
 * Added delete_mobile.
 *
 * Revision 1.58  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.57  2008/06/11 23:04:48  jps
 * Changed medit menu to be like oedit and redit.
 *
 * Revision 1.56  2008/06/11 22:51:36  jps
 * Tidied the medit menu.
 *
 * Revision 1.55  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.54  2008/04/20 17:49:00  jps
 * Removing unneeded externs.
 *
 * Revision 1.53  2008/04/07 17:24:51  jps
 * Allow mediting of stance.
 *
 * Revision 1.52  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.51  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.50  2008/03/23 00:24:48  jps
 * Fix composition apply editing.
 *
 * Revision 1.49  2008/03/22 21:44:54  jps
 * Add life force and composition to medit.
 *
 * Revision 1.48  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.47  2008/03/17 16:22:42  myc
 * Fixed handling of proto scripts in OLC, including the squashing of
 * a memory leak.
 *
 * Revision 1.46  2008/03/11 02:55:09  jps
 * Use set_base_size when editing mob proto sizes.
 *
 * Revision 1.45  2008/03/10 19:55:37  jps
 * Made a struct for sizes with name, height, and weight.  Save base height
 * weight and size so they stay the same over size changes.
 *
 * Revision 1.44  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.43  2008/03/09 02:40:21  jps
 * Update usage of dummy_mob, which is no longer declared as a pointer.
 *
 * Revision 1.42  2008/02/10 23:30:05  myc
 * Fixing alignment in main medit screen.
 *
 * Revision 1.41  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.40  2008/02/07 01:46:14  myc
 * Removing the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
 * which points to the sizes array.
 *
 * Revision 1.39  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.38  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.37  2008/01/27 09:45:41  jps
 * Got rid of the MCLASS_ defines and we now have a single set of classes
 * for both players and mobiles.
 *
 * Revision 1.36  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.35  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.34  2007/11/18 16:51:55  myc
 * Fixing LVL_BUILDER references.
 *
 * Revision 1.33  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  They can be set in medit.  They
 * are saved using especs.
 *
 * Revision 1.32  2007/09/15 05:03:46  myc
 * Implementing MOB2 flags.  They are saved in the mob files as an espec.
 * Implemented a new loop method for most of the medit menus so that
 * they get listed column-major instead of by rows.  This applies to the
 * mob flags and aff flags menus, which both also support many flags in
 * one menu; e.g., there is only one aff menu which holds all aff 1,
 * aff2, and aff3 flags.  The distinction between aff 1, 2, and 3 flags
 * has been removed.
 *
 * Revision 1.31  2007/08/14 15:51:52  myc
 * Updating number of aff2 and aff3 flags in medit menus.
 *
 * Revision 1.30  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.29  2007/07/18 00:04:41  jps
 * Save AFF2 and AFF3 flags for mobiles.
 *
 * Revision 1.28  2007/03/27 04:27:05  myc
 * Fixed index bug with sizes where they were all one off.
 *
 * Revision 1.27  2006/04/19 21:04:15  rls
 * Recolorized medit menu and cleaned up formatting
 *
 * Revision 1.26  2006/04/11 09:25:45  rls
 * *** empty log message ***
 *
 * Revision 1.25  2006/04/11 09:07:49  rls
 * Updated mobile display screen... added aff2, aff3
 *
 * Revision 1.24  2004/11/11 22:27:28  rsd
 * Split up a large buffer that the compiler was complaining
 * was over 509 bytes.
 *
 * Revision 1.23  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.22  2002/07/14 03:41:31  rls
 * removed purge functionality from menu
 *
 * Revision 1.21  2001/07/08 16:01:22  mtp
 * added safety check for purge of level LVL_HEAD_B (currently 103)
 *
 * Revision 1.19  2000/11/28 01:46:44  mtp
 * made class explicitly MCLASS_VOID for new mobs
 *
 * Revision 1.18  2000/11/28 01:26:11  mtp
 * removed a lot of mobprog stuff
 *
 * Revision 1.17  2000/11/23 05:11:16  rsd
 * Added the standard comment header, also mopped up some
 * whitespace.  Added back rlog messages from prior to
 * the addition of the $log$ string.
 *
 * Revision 1.16  2000/11/22 01:09:13  mtp
 * added more mob classes (all the ones that are available for players)
 *
 * Revision 1.15  2000/11/09 03:43:19  rsd
 * removed mob progs from the medit display menue and the
 * switch that allows choice P to enter the prog menue
 * system.
 *
 * Revision 1.14  2000/10/14 11:12:40  mtp
 * fixed the olc triggers editting in medit/oedit/redit
 *
 * Revision 1.13  2000/10/13 23:13:42  mtp
 * fixed why scripts weren't showing in medit, but the medit
 * code is _really_ buggy
 *
 * Revision 1.12  1999/12/10 05:13:14  cso
 * added support for choosing mob size (case Z in medit)
 *
 * Revision 1.11  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.10  1999/07/09 22:30:27  jimmy
 * Attempt to control the spiraling of memory.  Added a free() to the
 * prompt code in comm.c to free memory allocated by parse_color().
 * made a global structure dummy_mob and malloc'ed it for mobs
 * to share as their player_specials to cut memory.
 * gurlaek
 *
 * Revision 1.9  1999/07/06 19:57:05  jimmy
 * This is a Mass check-in of the new skill/spell/language assignment system.
 * This New system combines the assignment of skill/spell/language for
 * both mobs and PCs.  LOts of code was touched and many errors were fixed.
 * MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
 * MObs now get random skill/spell/language levels baseed on their race/class/level
 * that exactly align with PC's.  PC's no longer have to rent to use skills gained
 * by leveling or when first creating a char.  Languages no longer reset to defaults
 * when a PC levels.  Discovered that languages have been defined right in the middle
 * of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
 * the mob files to compensate for the 13 to -1 class change.
 * --gurlaek 7/6/1999
 *
 * Revision 1.8  1999/06/30 18:25:04  jimmy
 * >> This is a major conversion from the 18 point attribute system to the
 * >> 100 point attribute system.  A few of the major changes are:
 * >> All attributes are now on a scale from 0-100
 * >> Everyone views attribs the same but, the attribs for one race
 * >>   may be differeent for that of another even if they are the
 * >>   same number.
 * >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * >> Mobs now have individual random attributes based on race/class.
 * >> The STR_ADD attrib has been completely removed.
 * >> All bonus tables for attribs in constants.c have been replaced by
 * >>   algorithims that closely duplicate the tables except on a 100 scale.
 * >> Some minor changes:
 * >> Race selection at char creation can now be toggled by using
 * >>   <world races off>
 * >> Lots of cleanup done to affected areas of code.
 * >> Setting attributes for mobs in the .mob file no longer functions
 * >>   but is still in the code for later use.
 * >> We now have a spare attribut structure in the pfile because the new
 * >>   system only used three instead of four.
 * >> --gurlaek 6/30/1999
 *
 * Revision 1.7  1999/03/31 16:03:47  jen
 * Added a "()" pair to remove a warning during compilation.
 *
 * Revision 1.6  1999/03/30 19:46:06  jen
 * Changed the medit_mprog_type so that it properly changed the type
 * of mprog... Selina 3-30-99
 *
 * Revision 1.5  1999/02/15 01:12:40  jimmy
 * Yet another atempt to fix the medit crashe bug
 * created by adding the long descr to the pfile.
 * Think this finally got it.
 * fingon
 *
 * Revision 1.4  1999/02/11 23:52:09  jimmy
 * fixed medit crash bug introduced by adding
 * long desc to pfile
 * fingon
 *
 * Revision 1.3  1999/02/10 05:57:14  jimmy
 * Added long description to player file.  Added AFK toggle.
 * removed NOAUCTION toggle.
 * fingon
 *
 * Revision 1.2  1999/01/31 17:07:53  mud
 * Branches 1.2.1
 * Indented entire file
 * IInteresting header comments, and is it just me or
 * Iis about a third of the file commented?
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 * Revision 1.2.1.1
 * Had to backrev to fix medit crash bug.
 * should be all fixed now.
 * fingon
 *
 ***************************************************************************/
@


1.65
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.64 2009/03/08 21:43:27 jps Exp jps $
d577 1
a577 1
          (mob)->mob_specials.ex_damnodice, (mob)->mob_specials.ex_damsizedice, mob->mob_specials.ex_damroll, GET_EX_GOLD(mob), GET_EX_PLAT(mob),
d893 1
a893 1
          "&2&bJ&0) Gold       : [&6&b%8d&0]     &2&bK&0) Plat        : [&6&b%9d&0]\r\n",
d902 1
a902 1
      (long)GET_EX_EXP(mob), GET_EX_GOLD(mob), GET_EX_PLAT(mob));
d1087 1
a1087 1
    OLC_MODE(d) = MEDIT_EX_PLAT;
d1309 3
a1311 3
    case MEDIT_EX_PLAT:
      GET_EX_PLAT(OLC_MOB(d)) = atol(arg);
      GET_PLAT(OLC_MOB(d)) += GET_EX_PLAT(OLC_MOB(d));
d1542 3
@


1.64
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.63 2008/08/30 01:31:51 myc Exp jps $
d22 1
a22 1
#include "spells.h"
d1542 3
@


1.63
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.62 2008/08/26 03:58:13 jps Exp myc $
d37 3
d1542 6
@


1.62
log
@Replaced real_zone calls with find_real_zone_by_room, since that's what it did.
Except the one for wzoneecho, since it needed to find a real zone by zone number.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.61 2008/08/18 01:35:38 jps Exp jps $
d1277 1
a1277 1
      OLC_MOB(d)->mob_specials.ex_hpsizedice = MAX(-1000, MIN(1000, atoi(arg)));
d1539 4
@


1.61
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.60 2008/08/17 07:17:58 jps Exp jps $
d1462 1
a1462 1
   zrnum = real_zone(GET_MOB_VNUM(mob));
d1539 3
@


1.60
log
@Correctly mark which zone files need saving when deleting a mobile.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.59 2008/08/17 06:52:31 jps Exp jps $
d766 1
a766 1
  send_to_char("\n\rListings of Classes\n\r", d->character);
d782 1
a782 1
  send_to_char("\n\rListings of Races\n\r", d->character);
d1539 3
@


1.59
log
@Added delete_mobile.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.58 2008/08/14 09:45:22 jps Exp jps $
d1517 1
a1521 1
               save_this_zone = TRUE;
d1539 3
@


1.58
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.57 2008/06/11 23:04:48 jps Exp jps $
d36 1
d260 1
a260 1
#define ZCMD zone_table[zone].cmd[cmd_no]
d1446 91
d1539 3
@


1.57
log
@Changed medit menu to be like oedit and redit.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.56 2008/06/11 22:51:36 jps Exp jps $
d35 1
d1447 3
@


1.56
log
@Tidied the medit menu.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.55 2008/05/18 20:16:11 jps Exp jps $
d870 1
a870 1
      "&5&b%d&0 &3&b%s&0\r\n"
d878 1
a878 1
      OLC_NUM(d), GET_SDESC(mob), GET_NAMELIST(mob), GET_SDESC(mob), GET_MOBLDESC(mob), GET_DDESC(mob),
d1446 3
@


1.55
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.54 2008/04/20 17:49:00 jps Exp jps $
d119 1
a119 1
  } else if ((i = GET_MOB_RNUM(mob)) > -1) {	/* Prototyped mobile. */
d289 2
a290 2
	{
		placeholder=live_mob;
d292 1
a292 1
		fprintf(stderr, "remove mob %d ",GET_MOB_VNUM(live_mob));
d294 2
a295 2
		extract_char(live_mob);	/*remove all existing mobs*/
		live_mob=placeholder;	/*so we can keep removing..*/
d297 1
a297 1
		fprintf(stderr,"(%d left)\n",mob_index[rmob_num].number);
d299 1
a299 1
	}
d307 1
a307 1
	{
d309 12
a320 12
	  {		/* Is this the place? */
	/*	if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) */
	    if (i == rmob_num)
	    {
	      found = TRUE;
	      /* don't copy..it will be blatted by the free later*/
	    }
	    else
	    {	/* Nope, copy over as normal. */
	      new_index[i] = mob_index[i];
	      new_proto[i] = mob_proto[i];
	    }
d322 4
a325 4
	  else
	  { /* We've already found it, copy the rest over. */
	    new_index[i - 1] = mob_index[i];
	    new_proto[i - 1] = mob_proto[i];
d327 1
a327 1
	}
d340 1
a340 1
	    GET_MOB_RNUM(live_mob)--;
d347 3
a349 3
	    if (ZCMD.command == 'M')
	      if (ZCMD.arg1 >= rmob_num)
	        ZCMD.arg1--;
d356 2
a357 2
 	    if (SHOP_KEEPER(shop) >= rmob_num)
	      SHOP_KEEPER(shop)--;
d364 2
a365 2
	    if (S_KEEPER(OLC_SHOP(dsc)) >= rmob_num)
	      S_KEEPER(OLC_SHOP(dsc))--;
d367 2
a368 2
	    if (GET_MOB_RNUM(OLC_MOB(dsc)) >= rmob_num)
	      GET_MOB_RNUM(OLC_MOB(dsc))--;
d382 7
a388 7
	   * Only really need to update the strings, since these can
	   * cause protection faults.  The rest can wait till a reset/reboot.
	   */
	  GET_NAMELIST(live_mob) = GET_NAMELIST(mob_proto + rmob_num);
	  GET_SDESC(live_mob) = GET_SDESC(mob_proto + rmob_num);
	  GET_MOBLDESC(live_mob) = (GET_MOBLDESC(mob_proto + rmob_num));
	  GET_DDESC(live_mob) = GET_DDESC(mob_proto + rmob_num);
d404 7
a410 7
      if (!found) {		/* Is this the place? */
	/*	if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) {*/
	if (mob_index[rmob_num].virtual > OLC_NUM(d)) {
	  /*
	   * Yep, stick it here.
	   */
	  found = TRUE;
d412 1
a412 1
	  fprintf(stderr, "Inserted: rmob_num: %d\n", rmob_num);
d414 16
a429 16
	  new_index[rmob_num].virtual = OLC_NUM(d);
	  new_index[rmob_num].number = 0;
	  new_index[rmob_num].func = NULL;
	  new_mob_num = rmob_num;
	  GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
	  copy_mobile((new_proto + rmob_num), OLC_MOB(d));
	  /*
	   * Copy the mob that should be here on top.
	   */
	  new_index[rmob_num + 1] = mob_index[rmob_num];
	  new_proto[rmob_num + 1] = mob_proto[rmob_num];
	  GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
	} else {	/* Nope, copy over as normal. */
	  new_index[rmob_num] = mob_index[rmob_num];
	  new_proto[rmob_num] = mob_proto[rmob_num];
	}
d431 3
a433 3
	new_index[rmob_num + 1] = mob_index[rmob_num];
	new_proto[rmob_num + 1] = mob_proto[rmob_num];
	GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
d438 1
a438 1
	    rmob_num, top_of_mobt, top_of_mobt + 1, top_of_mobt + 2);
d472 1
a472 1
	GET_MOB_RNUM(live_mob)++;
d479 3
a481 3
	if (ZCMD.command == 'M')
	  if (ZCMD.arg1 >= new_mob_num)
	    ZCMD.arg1++;
d488 2
a489 2
 	if (SHOP_KEEPER(shop) >= new_mob_num)
	  SHOP_KEEPER(shop)++;
d496 2
a497 2
	if (S_KEEPER(OLC_SHOP(dsc)) >= new_mob_num)
	  S_KEEPER(OLC_SHOP(dsc))++;
d499 2
a500 2
	if (GET_MOB_RNUM(OLC_MOB(dsc)) >= new_mob_num)
	  GET_MOB_RNUM(OLC_MOB(dsc))++;
d511 2
a512 2
	    fprintf(stderr,"(%d - %d:%s)",i,GET_MOB_VNUM(live_mob),GET_NAME(live_mob));
	    */
d545 3
a547 3
	mudlog("SYSERR: OLC: Cannot write mob file!\r\n", BRF, LVL_GOD, TRUE);
	fclose(mob_file);
	return;
d560 16
a575 16
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%ld %ld %d E\n"
	      "%d %d %d %dd%d+%d %dd%d+%d\n"
	      "%d %d %ld %d\n"
	      "%d %d %d %d %d %d %d\n",
	      (GET_NAMELIST(mob) && *GET_NAMELIST(mob)) ? GET_NAMELIST(mob) : "undefined",
	      (GET_SDESC(mob) && *GET_SDESC(mob)) ? GET_SDESC(mob) : "undefined",
	      buf1, buf2, MOB_FLAGS(mob)[0], EFF_FLAGS(mob)[0], GET_ALIGNMENT(mob),
	      GET_LEVEL(mob), 20 - mob->mob_specials.ex_hitroll, /* Hitroll -> THAC0 */
	      GET_EX_AC(mob) / 10, (mob)->mob_specials.ex_hpnumdice, (mob)->mob_specials.ex_hpsizedice, GET_MOVE(mob),
	      (mob)->mob_specials.ex_damnodice, (mob)->mob_specials.ex_damsizedice, mob->mob_specials.ex_damroll, GET_EX_GOLD(mob), GET_EX_PLAT(mob),
	      GET_EX_EXP(mob), zone, GET_POS(mob), GET_DEFAULT_POS(mob), GET_SEX(mob),
	      GET_CLASS(mob), GET_RACE(mob), GET_RACE_ALIGN(mob), GET_SIZE(mob)
	      );
d581 1
a581 1
	fprintf(mob_file, "BareHandAttack: %d\n", GET_ATTACK(mob));
d583 1
a583 1
	fprintf(mob_file, "Str: %d\n", GET_STR(mob));
d585 1
a585 1
	fprintf(mob_file, "Dex: %d\n", GET_DEX(mob));
d587 1
a587 1
	fprintf(mob_file, "Int: %d\n", GET_INT(mob));
d589 1
a589 1
	fprintf(mob_file, "Wis: %d\n", GET_WIS(mob));
d591 1
a591 1
	fprintf(mob_file, "Con: %d\n", GET_CON(mob));
d593 1
a593 1
	fprintf(mob_file, "Cha: %d\n", GET_CHA(mob));
d626 1
a626 1
 *			    Menu functions                               *
d729 1
a729 1
#define FLAG_INDEX	((NUM_MOB_FLAGS / columns + 1) * j + i)
d753 1
a753 1
	  cyn, buf1, nrm);
d779 1
a779 1
  /*send_to_char(".[H.[J", d->character);	*/
d784 1
a784 1
	       grn, i, nrm, races[i].plainname);
d794 1
a794 1
#define FLAG_INDEX	((NUM_EFF_FLAGS / columns + 1) * j + i)
d816 1
a816 1
	  cyn, buf1, nrm);
d868 1
a868 1
	  ".[H.[J"
d870 11
a880 12
	  /* Total exp: (%ld)\r\n */
	  "          &0&1&b[] denotes Bonus Value&0...\r\n"
          "-- Mob #: [&6&b%d&0]\r\n"
	  "&2&b0&0) Alias: &6%s&0\r\n"
	  "&2&b1&0) Short: &6%s&0\r\n"
	  "&2&b2&0) Long : &6%s&0\r"
	  "&2&b3&0) Description:\r\n&6%s&0"
	  "&2&b4&0) Race: &6%-10s&0            &2&b5&0) Size: &6%-10s&0         &2&b6&0) Sex: &6%s&0\r\n"
     	  "&2&b7&0) Level: &6%-3d&0                  &2&b8&0) Class: &6%-10s&0        &2&b9&0) Alignment: &6%4d&0\r\n",
	  OLC_NUM(d), GET_NAMELIST(mob), GET_SDESC(mob), GET_MOBLDESC(mob), GET_DDESC(mob),
     RACE_PLAINNAME(mob), SIZE_DESC(mob),
	  genders[(int)GET_SEX(mob)], GET_LEVEL(mob), classes[(int)GET_CLASS(mob)].plainname, GET_ALIGNMENT(mob));
d882 1
d884 14
a897 14
	  "&2&bA&0) Hitroll: (&6%-3d&0)[&6&b%-3d&0]         &2&bB&0) Damroll: (&6%-3d&0)[&6&b%-3d&0] \r\n"
	  "&2&bC&0&0) # Dam Dice: (&6%-3d&0) [&6&b%-3d&0]     &2&bD&0) Size Dam Die: (&6%-3d&0) [&6&b%-3d&0]  (ie. xdy + z) \r\n"
	  "&2&bE&0) # HP Dice:(&6%-3d&0) [&6&b%-3d&0]       &2&bF&0) Size HP Dice:(&6%-3d&0) [&6&b%-3d&0] &2&bG&0) Bonus: (&6%-5d&0) [&6&b%-5d&0]\r\n"
          "&2&bH&0) Armor Class: (&6%-3d&0) [&6&b%-3d&0]   &2&bI&0) Exp: [&6&b%-9ld&0] \r\n"
          "&2&bJ&0) Gold:  [&6&b%-8d&0]           &2&bK&0) Plat:  [&6&b%-8d&0] \r\n",
	  (mob->points.hitroll), (mob->mob_specials.ex_hitroll),
	  (mob->points.damroll), (mob->mob_specials.ex_damroll),
	  (mob->mob_specials.damnodice),   (mob->mob_specials.ex_damnodice),
	  (mob->mob_specials.damsizedice), (mob->mob_specials.ex_damsizedice),
	  (mob)->points.hit,  (mob->mob_specials.ex_hpnumdice),
	  (mob->points.mana), (mob->mob_specials.ex_hpsizedice),
	  (GET_EX_MAIN_HP(mob) + (mob)->points.move), GET_MOVE(mob),
	  GET_AC(mob), GET_EX_AC(mob),
	  (long)GET_EX_EXP(mob), GET_EX_GOLD(mob), GET_EX_PLAT(mob));
d904 1
a904 1
          "&2&bL&0) Perception: [&6&b%-4ld&0]          &2&bM&0) Hiddenness: [&6&b%-4ld&0]\r\n"
d907 10
a916 10
	  "&2&bP&0) Stance        : &6%s&0\r\n"
	  "&2&bR&0) Load Position : &6%s&0\r\n"
	  "&2&bT&0) Default Pos   : &6%s&0\r\n"
	  "&2&bU&0) Attack Type   : &6%s&0\r\n"
	  "&2&bV&0) Act Flags     : &6%s&0\r\n"
	  "&2&bW&0) Aff Flags     : &6%s&0\r\n"
	  "&2&bS&0) Script        : &6%s&0\r\n"
	  "&2&bQ&0) Quit\r\n"
	  "Enter choice : ",
	
d922 6
a927 6
	 position_types[(int)GET_POS(mob)],
	 position_types[(int)GET_DEFAULT_POS(mob)],
	 attack_hit_text[GET_ATTACK(mob)].singular,
	 buf1,
	 buf2,
	 mob->proto_script?"&6&bSet&0":"&6Not Set&0");
d934 1
a934 1
 *		        The GARGANTAUN event handler                      *
d956 6
a961 6
	/*. Save the mob in memory and to disk  .*/
	send_to_char("Saving mobile to memory.\r\n", d->character);
	medit_save_internally(d);
	sprintf(buf, "OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
	mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
	/* FALL THROUGH */
d966 2
a967 2
	cleanup_olc(d, CLEANUP_ALL);
	return;
d969 3
a971 3
	send_to_char("Invalid choice!\r\n", d->character);
	send_to_char("Do you wish to save the mobile? : ", d->character);
	return;
d982 6
a987 6
	if (OLC_VAL(d)) {	/* Anything been changed? */
	  send_to_char("Do you wish to save the changes to the mobile? (y/n) : ", d->character);
	  OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
	} else
	  cleanup_olc(d, CLEANUP_ALL);
	return;
d989 3
a991 3
	OLC_MODE(d) = MEDIT_ALIAS;
	i--;
	break;
d993 3
a995 3
	OLC_MODE(d) = MEDIT_S_DESC;
	i--;
	break;
d997 3
a999 3
	OLC_MODE(d) = MEDIT_L_DESC;
	i--;
	break;
d1001 2
a1002 2
	OLC_MODE(d) = MEDIT_D_DESC;
	write_to_output("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
d1004 2
a1005 2
	OLC_VAL(d) = 1;
	return;
d1007 3
a1009 3
	OLC_MODE(d) = MEDIT_RACE;
	medit_race_types(d);
	return;
d1015 3
a1017 3
	OLC_MODE(d) = MEDIT_SEX;
	medit_disp_sex(d);
	return;
d1019 3
a1021 3
	OLC_MODE(d) = MEDIT_LEVEL;
	i++;
	break;
d1023 3
a1025 3
	OLC_MODE(d) = MEDIT_CLASS;
	medit_class_types(d);	
	return;
d1027 3
a1029 3
	OLC_MODE(d) = MEDIT_ALIGNMENT;
	i++;
	break;
d1032 3
a1034 3
	OLC_MODE(d) = MEDIT_HITROLL;
	i++;
	break;
d1037 3
a1039 3
	OLC_MODE(d) = MEDIT_DAMROLL;
	i++;
	break;
d1042 3
a1044 3
	OLC_MODE(d) = MEDIT_NDD;
	i++;
	break;
d1047 3
a1049 3
	OLC_MODE(d) = MEDIT_SDD;
	i++;
	break;
d1052 3
a1054 3
	OLC_MODE(d) = MEDIT_NUM_HP_DICE;
	i++;
	break;
d1057 3
a1059 3
	OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
	i++;
	break;
d1062 3
a1064 3
	OLC_MODE(d) = MEDIT_ADD_HP;
	i++;
	break;
d1067 3
a1069 3
	OLC_MODE(d) = MEDIT_AC;
	i++;
	break;
d1072 3
a1074 3
	OLC_MODE(d) = MEDIT_EXP;
	i++;
	break;
d1077 3
a1079 3
	OLC_MODE(d) = MEDIT_EX_GOLD;
	i++;
	break;
d1082 3
a1084 3
	OLC_MODE(d) = MEDIT_EX_PLAT;
	i++;
	break;
d1114 3
a1116 3
	OLC_MODE(d) = MEDIT_POS;
	medit_disp_positions(d);
	return;
d1119 3
a1121 3
	OLC_MODE(d) = MEDIT_DEFAULT_POS;
	medit_disp_positions(d);
	return;
d1124 3
a1126 3
	OLC_MODE(d) = MEDIT_ATTACK;
	medit_disp_attack_types(d);
	return;
d1129 3
a1131 3
	OLC_MODE(d) = MEDIT_NPC_FLAGS;
	medit_disp_mob_flags(d);
	return;
d1134 3
a1136 3
	OLC_MODE(d) = MEDIT_AFF_FLAGS;
	medit_disp_aff_flags(d);
	return;
d1139 3
a1141 3
	OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
	dg_script_menu(d);
	return;
d1144 17
a1160 17
	if (GET_MOB_RNUM(OLC_MOB(d)) == -1)
	{
		send_to_char("You cannot purge a non-existent (unsaved) mob! Choose again:\r\n",d->character);
	}
	else if (GET_LEVEL(d->character)<LVL_HEAD_B)
	{
		sprintf(buf,"You are too low level to purge! Get a level %d or greater to do this.\r\n",LVL_HEAD_B);
		send_to_char(buf,d->character);
	}
	else
	{
	  OLC_MODE(d) = MEDIT_PURGE_MOBILE;
	  * make extra sure*
	  send_to_char("Purging will also remove all existing mobiles of this sort!\r\n", d->character);
	  send_to_char("Are you sure you wish to PERMANENTLY DELETE the mobile? (y/n) : ", d->character);
	}
	return; */
d1163 1
a1163 1
	return;
d1166 5
a1170 5
	send_to_char(i == 1 ? "\r\nEnter new value : " :
		     i == -1 ? "\r\nEnter new text :\r\n] " :
		     "\r\nOops...:\r\n", d->character);
	return;
	
d1181 1
a1181 1
	free(GET_NAMELIST(OLC_MOB(d)));
d1187 1
a1187 1
	free(GET_SDESC(OLC_MOB(d)));
d1193 1
a1193 1
	free(GET_MOBLDESC(OLC_MOB(d)));
d1195 3
a1197 3
	strcpy(buf, arg);
	strcat(buf, "\r\n");
	GET_MOBLDESC(OLC_MOB(d)) = strdup(buf);
d1199 1
a1199 1
	GET_MOBLDESC(OLC_MOB(d)) = strdup("undefined");
d1210 1
a1210 1
	     BRF, LVL_GOD, TRUE);
d1216 1
a1216 1
	break;
d1218 1
a1218 1
	TOGGLE_FLAG(MOB_FLAGS(OLC_MOB(d)), i - 1);
d1224 1
a1224 1
	break;
d1226 1
a1226 1
	TOGGLE_FLAG(EFF_FLAGS(OLC_MOB(d)), i - 1);
d1249 2
a1250 2
      OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
      OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll;
d1386 2
a1387 2
	/*. Splat the mob in memory ..*/
	send_to_char("Purging mobile from memory.\r\n", d->character);
d1389 6
a1394 6
	/*need to remove all existing mobs of this type too..*/
	/*ok..we use save internally, but we are purging because of the mode*/
	medit_save_internally(d);
	sprintf(buf, "OLC: %s PURGES mob %d", GET_NAME(d->character), OLC_NUM(d));
	mudlog(buf, CMP, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
	/* FALL THROUGH */
d1397 2
a1398 2
	cleanup_olc(d, CLEANUP_ALL);
	return;
d1400 3
a1402 3
	send_to_char("Invalid choice!\r\n", d->character);
	send_to_char("Do you wish to purge the mobile? : ", d->character);
	return;
d1428 2
a1429 2
  OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
  OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll;
d1446 3
@


1.54
log
@Removing unneeded externs.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.53 2008/04/07 17:24:51 jps Exp jps $
d34 1
a53 1
extern struct attack_hit_type attack_hit_text[];
d1446 3
@


1.53
log
@Allow mediting of stance.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.52 2008/04/05 05:05:42 myc Exp jps $
d52 1
a53 2
extern int top_shop;
extern struct shop_data *shop_index;
d55 1
d58 1
a59 2


d1446 3
@


1.52
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.51 2008/03/28 17:54:53 myc Exp myc $
d79 1
d603 1
d629 18
a646 1
/*. Display poistions (sitting, standing etc) .*/
d908 6
a913 5
	  "&2&bP&0) Load Position : &6%s&0\r\n"
	  "&2&bR&0) Default Pos   : &6%s&0\r\n"
	  "&2&bT&0) Attack Type   : &6%s&0\r\n"
	  "&2&bU&0) Act Flags     : &6%s&0\r\n"
	  "&2&bV&0) Aff Flags     : &6%s&0\r\n"
d922 1
d1110 5
d1118 2
a1119 2
      case 'r':
      case 'R':
d1123 2
a1124 2
      case 't':
      case 'T':
d1128 2
a1129 2
      case 'u':
      case 'U':
d1133 2
a1134 2
      case 'v':
      case 'V':
d1339 4
d1344 1
a1344 1
      GET_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
d1348 1
a1348 1
      GET_DEFAULT_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
d1352 1
a1352 1
      GET_ATTACK(OLC_MOB(d)) = MAX(0, MIN(NUM_ATTACK_TYPES-1, atoi(arg)));
d1447 3
@


1.51
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.50 2008/03/23 00:24:48 jps Exp myc $
d982 1
a982 1
	SEND_TO_Q("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
d1417 4
@


1.50
log
@Fix composition apply editing.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.49 2008/03/22 21:44:54 jps Exp jps $
d131 2
a132 2
  while (mob->affected)
    affect_remove(mob, mob->affected);
d148 4
a151 4
  GET_NAMELIST(mob) = str_dup("mob unfinished");
  GET_SDESC(mob) = str_dup("the unfinished mob");
  GET_MOBLDESC(mob) = str_dup("An unfinished mob stands here.\r\n");
  GET_DDESC(mob) = str_dup("It looks unfinished.\r\n");
d213 4
a216 4
  GET_NAMELIST(tmob) = str_dup((GET_NAMELIST(fmob) && *GET_NAMELIST(fmob)) ? GET_NAMELIST(fmob) : "undefined");
  GET_SDESC(tmob) = str_dup((GET_SDESC(fmob) && *GET_SDESC(fmob)) ? GET_SDESC(fmob) : "undefined");
  GET_MOBLDESC(tmob) = str_dup((GET_MOBLDESC(fmob) && *GET_MOBLDESC(fmob)) ? GET_MOBLDESC(fmob) : "undefined");
  GET_DDESC(tmob) = str_dup((GET_DDESC(fmob) && *GET_DDESC(fmob)) ? GET_DDESC(fmob) : "undefined");
d251 1
a251 1
  SET_BIT(MOB_FLAGS(mob), MOB_ISNPC);
d569 1
a569 1
	      buf1, buf2, MOB_FLAGS(mob), AFF_FLAGS(mob), GET_ALIGNMENT(mob),
d595 3
a597 3
   fprintf(mob_file, "AFF2: %ld\n", AFF2_FLAGS(mob));
   fprintf(mob_file, "AFF3: %ld\n", AFF3_FLAGS(mob));
   fprintf(mob_file, "MOB2: %ld\n", MOB2_FLAGS(mob));
d660 1
a660 1
  for (i = 0; i < NUM_GENDERS; i++) {
d711 1
a711 2
#define TOTAL_MOB_FLAGS	(NUM_MOB_FLAGS + NUM_MOB2_FLAGS)
#define FLAG_INDEX	((TOTAL_MOB_FLAGS / columns + 1) * j + i)
d723 1
a723 1
  for (i = 0; i <= TOTAL_MOB_FLAGS / columns; ++i) {
d726 1
a726 1
      if (FLAG_INDEX >= TOTAL_MOB_FLAGS)
d728 1
a728 5
      sprintf(buf, "%s%s%2d%s) ", buf, grn, FLAG_INDEX + 1, nrm);
      if (FLAG_INDEX < NUM_MOB_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, action_bits[FLAG_INDEX]);
      else if (FLAG_INDEX < NUM_MOB_FLAGS + NUM_MOB2_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, action_bits2[FLAG_INDEX - NUM_MOB_FLAGS]);
d733 1
a733 6
  *buf = '\0';
  if (MOB_FLAGS(OLC_MOB(d)))
    sprintbit(MOB_FLAGS(OLC_MOB(d)), action_bits, buf1);
  /* If no mob flags, then gotta print mob2 flags so NOBITS gets printed. */
  if (MOB2_FLAGS(OLC_MOB(d)) || !MOB_FLAGS(OLC_MOB(d)))
    sprintbit(MOB2_FLAGS(OLC_MOB(d)), action_bits2, buf1 + strlen(buf1));
a737 1
#undef TOTAL_MOB_FLAGS
d776 1
a776 2
#define TOTAL_AFF_FLAGS	(NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
#define FLAG_INDEX	((TOTAL_AFF_FLAGS / columns + 1) * j + i)
d786 1
a786 1
  for (i = 0; i <= TOTAL_AFF_FLAGS / columns; ++i) {
d789 1
a789 1
      if (FLAG_INDEX >= TOTAL_AFF_FLAGS)
d791 1
a791 7
      sprintf(buf, "%s%s%2d%s) ", buf, grn, FLAG_INDEX + 1, nrm);
      if (FLAG_INDEX < NUM_AFF_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits[FLAG_INDEX]);
      else if (FLAG_INDEX < NUM_AFF_FLAGS + NUM_AFF2_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits2[FLAG_INDEX - NUM_AFF_FLAGS]);
      else if (FLAG_INDEX < NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
        sprintf(buf, "%s%-20.20s", buf, affected_bits3[FLAG_INDEX - NUM_AFF_FLAGS - NUM_AFF2_FLAGS]);
d796 1
a796 8
  *buf1 = '\0';
  if (AFF_FLAGS(OLC_MOB(d)))
    sprintbit(AFF_FLAGS(OLC_MOB(d)), affected_bits, buf1);
  if (AFF2_FLAGS(OLC_MOB(d)))
    sprintbit(AFF2_FLAGS(OLC_MOB(d)), affected_bits2, buf1 + strlen(buf1));
  if (AFF3_FLAGS(OLC_MOB(d)) || !(AFF_FLAGS(OLC_MOB(d)) || AFF2_FLAGS(OLC_MOB(d))))
    sprintbit(AFF3_FLAGS(OLC_MOB(d)), affected_bits3, buf1 + strlen(buf1));

a800 1
#undef TOTAL_AFF_FLAGS
d882 2
a883 17
  *buf1 = '\0';
  if (MOB_FLAGS(mob))
    sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  if (MOB2_FLAGS(mob))
    sprintbit(MOB2_FLAGS(mob), action_bits2, buf1 + strlen(buf1));
  if (!MOB_FLAGS(mob) && !MOB2_FLAGS(mob))
    strcpy(buf1, "NOBITS");

  *buf2 = '\0';
  if (AFF_FLAGS(mob))
    sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  if (AFF2_FLAGS(mob))
    sprintbit(AFF2_FLAGS(mob), affected_bits2, buf2 + strlen(buf2));
  if (AFF3_FLAGS(mob))
    sprintbit(AFF3_FLAGS(mob), affected_bits3, buf2 + strlen(buf2));
  if (!AFF_FLAGS(mob) && !AFF2_FLAGS(mob) && !AFF3_FLAGS(mob))
    strcpy(buf2, "NOBITS");
d932 1
a932 1
      SET_BIT(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
d1157 1
a1157 1
      GET_NAMELIST(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
d1163 1
a1163 1
      GET_SDESC(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
d1193 1
a1193 3
	TOGGLE_BIT(MOB_FLAGS(OLC_MOB(d)), 1 << (i - 1));
      else if (i > NUM_MOB_FLAGS && i <= NUM_MOB_FLAGS + NUM_MOB2_FLAGS)
        TOGGLE_BIT(MOB2_FLAGS(OLC_MOB(d)), 1 << (i - 1 - NUM_MOB_FLAGS));
d1200 2
a1201 6
      else if (i > 0 && i <= NUM_AFF_FLAGS)
	TOGGLE_BIT(AFF_FLAGS(OLC_MOB(d)), 1 << (i - 1));
      else if (i > NUM_AFF_FLAGS && i <= NUM_AFF_FLAGS + NUM_AFF2_FLAGS)
	TOGGLE_BIT(AFF2_FLAGS(OLC_MOB(d)), 1 << (i - 1 - NUM_AFF_FLAGS));
      else if (i > NUM_AFF_FLAGS + NUM_AFF2_FLAGS && i <= NUM_AFF_FLAGS + NUM_AFF2_FLAGS + NUM_AFF3_FLAGS)
	TOGGLE_BIT(AFF3_FLAGS(OLC_MOB(d)), 1 << (i - 1 - NUM_AFF_FLAGS - NUM_AFF2_FLAGS));
d1208 1
a1208 1
      GET_SEX(OLC_MOB(d)) = MAX(0, MIN(NUM_GENDERS -1, atoi(arg)));
d1417 3
@


1.49
log
@Add life force and composition to medit.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.48 2008/03/22 03:22:38 myc Exp jps $
d601 1
a601 1
   fprintf(mob_file, "Composition: %d\n", GET_COMPOSITION(mob));
a853 2
   int i;

d857 1
a857 7
   for (i = 0; i < NUM_COMPOSITIONS; i++) {
      sprintf(buf, "%s%2d%s) %s%c%s%s\r\n", grn, i, nrm,
            compositions[i].color,
            UPPER((compositions[i].name)[0]),
            compositions[i].name + 1, nrm);
      send_to_char(buf, d->character);
   }
d1351 2
a1352 1
      if (i != COMP_UNDEFINED)
d1354 1
a1354 1
      else {
d1464 3
@


1.48
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.47 2008/03/17 16:22:42 myc Exp myc $
d600 2
d830 40
d936 7
a942 5
	  "&2&bN&0) Load Position : &6%s&0\r\n"
	  "&2&bO&0) Default Pos   : &6%s&0\r\n"
	  "&2&bP&0) Attack Type   : &6%s&0\r\n"
	  "&2&bR&0) Act Flags     : &6%s&0\r\n"
	  "&2&bT&0) Aff Flags     : &6%s&0\r\n"
d948 3
d1126 12
d1141 2
a1142 2
      case 'o':
      case 'O':
d1146 2
a1147 2
      case 'p':
      case 'P':
d1151 2
a1152 2
      case 'r':
      case 'R':
d1156 2
a1157 2
      case 't':
      case 'T':
d1347 20
d1402 4
a1405 1
      GET_RACE_ALIGN(OLC_MOB(d)) = ALIGN_OF_RACE(atoi(arg));
d1471 6
@


1.47
log
@Fixed handling of proto scripts in OLC, including the squashing of
a memory leak.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.46 2008/03/11 02:55:09 jps Exp myc $
d985 1
a985 8
	d->backstr = NULL;
	if (OLC_MOB(d)->player.description) {
	  SEND_TO_Q(OLC_MOB(d)->player.description, d);
	  d->backstr = str_dup(OLC_MOB(d)->player.description);
	}
	d->str = &OLC_MOB(d)->player.description;
	d->max_str = MAX_MOB_DESC;
	d->mail_to = 0;
d1389 4
@


1.46
log
@Use set_base_size when editing mob proto sizes.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.45 2008/03/10 19:55:37 jps Exp jps $
a190 2
  struct trig_proto_list *proto, *fproto;

d200 1
d202 2
a203 6
  proto = tmob->proto_script;
  while (proto) {
    fproto = proto;
    proto = proto->next;
    free(fproto);
  }
a216 17


  /* copy the new script list */
  if (fmob->proto_script) {
    fproto = fmob->proto_script;
    CREATE(proto, struct trig_proto_list, 1);
    tmob->proto_script = proto;
    do {
      proto->vnum = fproto->vnum;
      fproto = fproto->next;
      if (fproto) {
        CREATE(proto->next, struct trig_proto_list, 1);
        proto = proto->next;
      }
    } while (fproto);
  }

d944 2
a1111 2
	OLC_SCRIPT(d) = OLC_MOB(d)->proto_script;
	OLC_MOB(d)->proto_script=(struct trig_proto_list *)NULL;
d1396 3
@


1.45
log
@Made a struct for sizes with name, height, and weight.  Save base height
weight and size so they stay the same over size changes.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.44 2008/03/09 06:38:37 jps Exp jps $
d263 1
a263 1
  GET_SIZE(mob) = 2;
a878 1

d1237 1
a1237 1
      GET_SIZE(OLC_MOB(d)) = MAX(0, MIN(NUM_SIZES -1, atoi(arg)));
d1418 4
@


1.44
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.43 2008/03/09 02:40:21 jps Exp jps $
d702 2
a703 2
    sprintf(buf, "%s%2d%s) %c%s\r\n", grn, i, nrm, *sizes[i + 1], 
            sizes[i + 1] + 1);
d876 1
a876 1
     RACE_PLAINNAME(mob), sizes[(int)GET_SIZE(mob) + 1],
d1419 5
@


1.43
log
@Update usage of dummy_mob, which is no longer declared as a pointer.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.42 2008/02/10 23:30:05 myc Exp jps $
a62 1
#define GET_ALIAS(mob) ((mob)->player.name)
d109 2
a110 2
    if (mob->player.name)
      free(mob->player.name);
d120 2
a121 2
    if (mob->player.name && mob->player.name != mob_proto[i].player.name)
      free(mob->player.name);
d148 1
a148 1
  GET_ALIAS(mob) = str_dup("mob unfinished");
d194 2
a195 2
  if (GET_ALIAS(tmob))
    free(GET_ALIAS(tmob));
d218 1
a218 1
  GET_ALIAS(tmob) = str_dup((GET_ALIAS(fmob) && *GET_ALIAS(fmob)) ? GET_ALIAS(fmob) : "undefined");
d407 1
a407 1
	  GET_ALIAS(live_mob) = GET_ALIAS(mob_proto + rmob_num);
d589 1
a589 1
	      (GET_ALIAS(mob) && *GET_ALIAS(mob)) ? GET_ALIAS(mob) : "undefined",
d875 1
a875 1
	  OLC_NUM(d), GET_ALIAS(mob), GET_SDESC(mob), GET_MOBLDESC(mob), GET_DDESC(mob),
d1175 3
a1177 3
      if(GET_ALIAS(OLC_MOB(d)))
	free(GET_ALIAS(OLC_MOB(d)));
      GET_ALIAS(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
d1419 3
@


1.42
log
@Fixing alignment in main medit screen.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.41 2008/02/09 04:27:47 myc Exp myc $
d55 1
a55 1
extern struct player_special_data *dummy_mob;
d275 1
a275 1
  mob->player_specials = dummy_mob;
d1420 3
@


1.41
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.40 2008/02/07 01:46:14 myc Exp myc $
d874 1
a874 1
	  "&2&b4&0) Race: &6%-10s&0         &2&b5&0) Size: &6%-10s&0         &2&b6&0) Sex: &6%s&0\r\n"
d885 1
a885 1
          "&2&bH&0) Armor Class: (&6%-3d&0) [&6&b%-3d&0]    &2&bI&0) Exp: [&6&b%-9ld&0] \r\n"
d1420 3
@


1.40
log
@Removing the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
which points to the sizes array.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.39 2008/01/29 21:02:31 myc Exp myc $
d33 1
d1420 4
@


1.39
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.38 2008/01/27 13:43:50 jps Exp myc $
d702 2
a703 1
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, sizes[i+1]);
d1419 4
@


1.38
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.37 2008/01/27 09:45:41 jps Exp jps $
d32 1
a50 6
extern struct index_data *mob_index;
extern struct char_data *mob_proto;
extern struct char_data *character_list;
extern int top_of_mobt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
a51 8
extern char *action_bits[];
extern char *action_bits2[];
extern char *affected_bits[];
extern char *affected_bits2[];
extern char *affected_bits3[];
extern char *position_types[];
extern char *sizes[];
extern char *genders[];
a53 1
extern struct descriptor_data *descriptor_list;
d1418 3
@


1.37
log
@Got rid of the MCLASS_ defines and we now have a single set of classes
for both players and mobiles.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.36 2008/01/26 14:26:31 jps Exp jps $
a68 1
extern char *mspecies_types[];				/*. constants.c .*/
a84 2
int mob_race_align(int);
byte mob_find_size(int);
d99 2
a100 2
void medit_species_types(struct descriptor_data *d);
long get_set_exp(int, int, int, int); 
d102 1
a102 1
sbyte get_set_hd(int, int, int, int); 
d106 1
a106 1
  utility functions 
d147 1
a147 1
  
d154 1
a154 1
  
d157 1
a157 1
  
d159 1
a159 1
  
d167 1
a167 1
  
d169 1
a169 1
  
d185 1
a185 1
  
d187 1
a187 1
   * Allocate a scratch mobile structure. 
d190 1
a190 1
  
d192 1
a192 1
  
d206 1
a206 1
  
d223 1
a223 1
  
d228 1
a228 1
  
d236 2
a237 2
  
  
d246 1
a246 1
      if (fproto) { 
d252 1
a252 1
  
d263 1
a263 1
  
d269 1
a269 1
  GET_SPECIES(mob) = 17;
d278 1
a278 1
  
d286 1
a286 1
  
d303 1
a303 1
  
d307 2
a308 2
  
  
d377 1
a377 1
        
d386 1
a386 1
        
d394 1
a394 1
        
d435 1
a435 1
    
d438 1
a438 1
    
d487 1
a487 1
    
d502 1
a502 1
    
d509 1
a509 1
    
d518 1
a518 1
    
d526 1
a526 1
    
d539 1
a539 1
  
d555 1
a555 1
 * Save ALL mobiles for a zone to their .mob file, mobs are all 
d565 1
a565 1
  
d568 1
a568 1
  
d574 1
a574 1
  
d586 1
a586 1
      
d594 1
a594 1
      
d610 1
a610 1
	      GET_CLASS(mob), GET_SPECIES(mob), GET_RACE_ALIGN(mob), GET_SIZE(mob)
d612 1
a612 1
      
d636 1
a636 1
      
d641 1
a641 1
      
d643 1
a643 1
      
d654 1
a654 1
  
d664 1
a664 1
{ 
d666 1
a666 1
  
d668 1
a668 1
  
d686 1
a686 1
{ 
d688 1
a688 1
  
d690 1
a690 1
  
d707 1
a707 1
{ 
d709 1
a709 1
  
d711 1
a711 1
  
d726 1
a726 1
{ 
d728 1
a728 1
  
d747 1
a747 1
{ 
d750 1
a750 1
  
a798 30
int mob_race_align(int arg)
{
  switch(arg) {
  case SPECIES_OTHER:
  case SPECIES_UNDEAD:
  case SPECIES_HUMANOID:
  case SPECIES_ANIMAL:
  case SPECIES_DRAGON:
  case SPECIES_HUMAN:
  case SPECIES_HALF_ELF:
  case SPECIES_DWARF:
  case SPECIES_GNOME:
  case SPECIES_BARBARIAN:
  case SPECIES_HALFLING:
  case SPECIES_ELF:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_DEMON:
  case SPECIES_TROLL:
  case SPECIES_ORC:
  case SPECIES_DUERGAR:
  case SPECIES_DROW_ELF:
  case SPECIES_OGRE:
    return RACE_ALIGN_EVIL;
    break;
  default:
    return RACE_ALIGN_GOOD;
    break;
  }
}
d800 1
a800 1
byte mob_find_size(int arg)
a801 42
  switch(arg) {
  case SPECIES_OTHER:
  case SPECIES_UNDEAD:
  case SPECIES_HUMANOID:
  case SPECIES_ORC:
  case SPECIES_DUERGAR:
  case SPECIES_DROW_ELF:
  case SPECIES_HUMAN:
  case SPECIES_ELF:
  case SPECIES_HALF_ELF:
  case SPECIES_DWARF:
    return SIZE_MEDIUM;
    break;
  case SPECIES_ANIMAL:
  case SPECIES_GNOME:
  case SPECIES_HALFLING:
    return SIZE_SMALL;
    break;
  case SPECIES_TROLL:
  case SPECIES_BARBARIAN:
    return SIZE_LARGE;
    break;
  case SPECIES_OGRE:
    return SIZE_HUGE;
    break;
  case SPECIES_DEMON:
  case SPECIES_GIANT:
    return SIZE_GIANT;
    break;
  case SPECIES_DRAGON:
    return SIZE_GARGANTUAN;
    break;
  default:
    return SIZE_MEDIUM;
    break;
  }
}



void medit_species_types(struct descriptor_data *d)
{ 
d806 1
a806 1
  send_to_char("\n\rListings of Species\n\r", d->character);
d808 3
a810 3
  for (i = 0; i < SPECIES_NUMBER; i++)
    {  sprintf(buf, "%s%2d%s) %s\r\n", 
	       grn, i, nrm, mspecies_types[i]);
d813 2
a814 2
  send_to_char("Enter Species : ", d->character);
  
d823 1
a823 1
{ 
d826 1
a826 1
  
d871 1
a871 1
  
d874 1
a874 1
  
d886 1
a886 1
	  "&2&b4&0) Species: &6%-10s&0         &2&b5&0) Size: &6%-10s&0         &2&b6&0) Sex: &6%s&0\r\n"
d888 2
a889 2
	  OLC_NUM(d), GET_ALIAS(mob), GET_SDESC(mob), GET_MOBLDESC(mob), GET_DDESC(mob), 
	  mspecies_types[(int)GET_SPECIES(mob)], sizes[(int)GET_SIZE(mob) + 1], 
d897 1
a897 1
          "&2&bH&0) Armor Class: (&6%-3d&0) [&6&b%-3d&0]    &2&bI&0) Exp: [&6&b%-9ld&0] \r\n"          
d900 4
a903 4
	  (mob->points.damroll), (mob->mob_specials.ex_damroll), 
	  (mob->mob_specials.damnodice),   (mob->mob_specials.ex_damnodice), 
	  (mob->mob_specials.damsizedice), (mob->mob_specials.ex_damsizedice), 
	  (mob)->points.hit,  (mob->mob_specials.ex_hpnumdice), 
d906 1
a906 1
	  GET_AC(mob), GET_EX_AC(mob),  
d909 1
a909 1
  
d938 1
a938 1
	  
d943 1
a943 1
	 buf1, 
d947 1
a947 1
  
d964 2
a965 2
  
  switch (OLC_MODE(d)) 
d990 1
a990 1
      
d994 1
a994 1
      switch (*arg) 
d1030 2
a1031 2
	OLC_MODE(d) = MEDIT_SPECIES;
	medit_species_types(d);
d1047 1
a1047 1
	medit_class_types(d);	 
d1180 2
a1181 2
      break; 
      
d1208 2
a1209 2
      
      
d1245 1
a1245 1
      
d1253 1
a1253 1
      
d1258 1
a1258 1
      
d1260 1
a1260 1
      
d1264 2
a1265 2
      OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll; 
      
d1267 1
a1267 1
      
d1273 2
a1274 2
      
            
d1279 1
a1279 1
      
d1281 1
a1281 1
      
d1287 1
a1287 1
      
d1290 1
a1290 1
      OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);  
d1292 1
a1292 1
      
d1294 3
a1296 3
      
      
      
d1301 1
a1301 1
      
d1306 1
a1306 1
      
d1310 1
a1310 1
      GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d)); 
d1312 1
a1312 1
      
d1317 1
a1317 1
      
d1326 1
a1326 1
      
d1334 1
a1334 1
      
d1338 1
a1338 1
      
d1342 1
a1342 1
      
d1359 6
a1364 1
    case MEDIT_SPECIES:
d1366 1
a1366 3
      GET_RACE_ALIGN(OLC_MOB(d)) = mob_race_align(atoi(arg));
/*      GET_SIZE(OLC_MOB(d)) = mob_find_size(atoi(arg)); */
      
d1402 1
a1402 1
  /*. END OF CASE 
d1405 1
a1405 1
  
d1409 2
a1410 2
  GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d)); 
  OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);  
d1415 1
a1415 1
  OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll; 
d1422 2
a1423 2
  
  
d1432 4
d1516 1
a1516 1
 * fixed why scripts weren't showing in medit, but the medit 
@


1.36
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.35 2008/01/04 01:53:26 jps Exp jps $
d31 1
a68 1
extern char *mclass_types[];
d169 1
d273 1
a273 1
  GET_CLASS(mob) = MCLASS_VOID;
a792 1
  /*send_to_char(".[H.[J", d->character);	*/
d795 2
a796 3
  for (i = 0; i < MCLASS_NUMBER; i++)
    {  sprintf(buf, "%s%2d%s) %s\r\n", 
	       grn, i - 1, nrm, mclass_types[i]);
d798 1
a798 1
    }
d800 1
a800 2
  
}	
d965 1
a965 1
	  genders[(int)GET_SEX(mob)], GET_LEVEL(mob), mclass_types[(int)GET_CLASS(mob) + 1], GET_ALIGNMENT(mob));
a1420 4




a1421 1
      
a1424 1

d1426 4
a1429 4
      if (atoi(arg) == 17 || atoi(arg) == 22 || atoi(arg) == 23)
      {
	      send_to_char("Sorry that class is not permitted at the moment, try again:",d->character);
	      return;
a1431 1
      /*update class effected stuff*/
d1504 3
@


1.35
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.34 2007/11/18 16:51:55 myc Exp jps $
d30 1
d1513 4
@


1.34
log
@Fixing LVL_BUILDER references.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.33 2007/09/20 21:20:43 myc Exp myc $
d29 1
d1512 3
@


1.33
log
@Hide points and perception are in.  They can be set in medit.  They
are saved using especs.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.32 2007/09/15 05:03:46 myc Exp myc $
d571 1
a571 1
    mudlog("SYSERR: OLC: Cannot open mob file!", BRF, LVL_BUILDER, TRUE);
d581 1
a581 1
	mudlog("SYSERR: OLC: Cannot write mob file!\r\n", BRF, LVL_BUILDER, TRUE);
d1053 1
a1053 1
	mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
d1293 1
a1293 1
	     BRF, LVL_BUILDER, TRUE);
d1458 1
a1458 1
	mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
d1476 1
a1476 1
      mudlog("SYSERR: OLC: medit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
d1511 4
@


1.32
log
@Implementing MOB2 flags.  They are saved in the mob files as an espec.
Implemented a new loop method for most of the medit menus so that
they get listed column-major instead of by rows.  This applies to the
mob flags and aff flags menus, which both also support many flags in
one menu; e.g., there is only one aff menu which holds all aff 1,
aff2, and aff3 flags.  The distinction between aff 1, 2, and 3 flags
has been removed.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.31 2007/08/14 15:51:52 myc Exp myc $
d634 2
a805 2
    return RACE_ALIGN_GOOD;
    break;
a806 2
    return RACE_ALIGN_GOOD;
    break;
a807 2
    return RACE_ALIGN_GOOD;
    break;
a808 2
    return RACE_ALIGN_GOOD;
    break;
d810 7
a819 5
    return RACE_ALIGN_EVIL;
    break;
  case SPECIES_GIANT:
    return RACE_ALIGN_GOOD;
    break;
a820 2
    return RACE_ALIGN_EVIL;
    break;
a821 2
    return RACE_ALIGN_EVIL;
    break;
a822 2
    return RACE_ALIGN_EVIL;
    break;
a823 2
    return RACE_ALIGN_EVIL;
    break;
a826 21
  case SPECIES_HUMAN:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_ELF:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_HALF_ELF:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_DWARF:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_GNOME:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_BARBARIAN:
    return RACE_ALIGN_GOOD;
    break;
  case SPECIES_HALFLING:
    return RACE_ALIGN_GOOD;
    break;
a836 2
    return SIZE_MEDIUM;
    break;
a837 2
    return SIZE_MEDIUM;
    break;
a838 17
    return SIZE_MEDIUM;
    break;
  case SPECIES_ANIMAL:
    return SIZE_SMALL;
    break;
  case SPECIES_DRAGON:
    return SIZE_GARGANTUAN;
    break;
  case SPECIES_DEMON:
    return SIZE_GIANT;
    break;
  case SPECIES_GIANT:
    return SIZE_GIANT;
    break;
  case SPECIES_TROLL:
    return SIZE_LARGE;
    break;
a839 2
    return SIZE_MEDIUM;
    break;
a840 2
    return SIZE_MEDIUM;
    break;
a841 5
    return SIZE_MEDIUM;
    break;
  case SPECIES_OGRE:
    return SIZE_HUGE;
    break;
a842 2
    return SIZE_MEDIUM;
    break;
a843 2
    return SIZE_MEDIUM;
    break;
a844 2
    return SIZE_MEDIUM;
    break;
d848 1
d850 1
d853 1
d857 9
a865 2
  case SPECIES_HALFLING:
    return SIZE_SMALL;
d971 1
a971 1
	  "&2&bE&0) # HP Dice:(&6%-3d&0) [&6&b%-3d&0]       &2&bF&0)Size HP Dice:(&6%-3d&0) [&6&b%-3d&0]  &2&bG&0) Bonus: (&6%-5d&0) [&6&b%-5d&0]\r\n"
d973 1
a973 1
          "&2&bJ&0) Gold:  [&6&b%-8d&0]           &2&bk&0) Plat:  [&6&b%-8d&0] \r\n",
d1004 6
a1009 5
	  "&2&bL&0) Load Position : &6%s&0\r\n"
	  "&2&bM&0) Default Pos   : &6%s&0\r\n"
	  "&2&bN&0) Attack Type   : &6%s&0\r\n"
	  "&2&bO&0) Act Flags     : &6%s&0\r\n"
	  "&2&bP&0) Aff Flags     : &6%s&0\r\n"
d1014 1
d1185 10
d1198 2
a1199 2
      case 'm':
      case 'M':
d1203 2
a1204 2
      case 'n':
      case 'N':
d1208 2
a1209 2
      case 'o':
      case 'O':
d1213 2
a1214 2
      case 'p':
      case 'P':
d1397 4
d1402 4
d1485 1
a1485 1
  /*update species effected stuff*/
d1511 9
@


1.31
log
@Updating number of aff2 and aff3 flags in medit menus.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.30 2007/07/24 23:02:52 jps Exp myc $
d55 1
a96 2
void medit_disp_aff2_flags(struct descriptor_data *d);
void medit_disp_aff3_flags(struct descriptor_data *d);
d633 1
d742 2
d746 2
a747 1
  int i, columns = 0;
d753 14
a766 4
  for (i = 0; i < NUM_MOB_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, action_bits[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
d768 7
a774 1
  sprintbit(MOB_FLAGS(OLC_MOB(d)), action_bits, buf1);
d779 3
d954 2
d958 2
a959 1
  int i, columns = 0;
d965 14
a978 4
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
a979 7
  sprintbit(AFF_FLAGS(OLC_MOB(d)), affected_bits, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}
/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/
d981 7
d989 1
a989 38
void medit_disp_aff2_flags(struct descriptor_data *d)
{ 
  int i, columns = 0;
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_AFF2_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits2[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(AFF2_FLAGS(OLC_MOB(d)), affected_bits2, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff2 flags (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}


/*-------------------------------------------------------------------*/
/*. Display aff-flags menu .*/

void medit_disp_aff3_flags(struct descriptor_data *d)
{ 
  int i, columns = 0;
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_AFF3_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits3[i],
	    !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(AFF3_FLAGS(OLC_MOB(d)), affected_bits3, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff3 flags (0 to quit) : ",
d993 2
a994 1

a1003 4
  char cbuf[609];
  char buf3[609];
  char buf4[609];

d1014 1
a1014 1
	  "          &0&1&b[] denotes Bonus Value&0... &0&3&bDo &1&bNOT&0&3&b use MOB PROGS!&0\r\n"
d1025 1
d1027 6
a1032 6
  sprintf(cbuf,
	  "&2&ba&0) Hitroll: (&6%-3d&0)[&6&b%-3d&0]         &2&bb&0) Damroll: (&6%-3d&0)[&6&b%-3d&0] \r\n"
	  "&2&bc&0&0) # Dam Dice: (&6%-3d&0) [&6&b%-3d&0]     &2&bd&0) Size Dam Die: (&6%-3d&0) [&6&b%-3d&0]  (ie. xdy + z) \r\n"
	  "&2&be&0) # HP Dice:(&6%-3d&0) [&6&b%-3d&0]       &2&bf&0)Size HP Dice:(&6%-3d&0) [&6&b%-3d&0]  &2&bg&0) Bonus: (&6%-5d&0) [&6&b%-5d&0]\r\n"
          "&2&bh&0) Armor Class: (&6%-3d&0) [&6&b%-3d&0]   &2&bi&0) Exp: [&6&b%-9ld&0] \r\n"          
          "&2&bj&0) Gold:  [&6&b%-8d&0]           &2&bk&0) Plat:  [&6&b%-8d&0] \r\n",
a1041 1

a1042 1
  send_to_char(cbuf, d->character);
d1044 17
a1060 4
  sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  sprintbit(AFF2_FLAGS(mob), affected_bits2, buf3);
  sprintbit(AFF3_FLAGS(mob), affected_bits3, buf4);
d1063 7
a1069 9
	  "&2&bl&0) Load Position : &6%s&0\r\n"
	  "&2&bm&0) Default Pos   : &6%s&0\r\n"
	  "&2&bn&0) Attack Type   : &6%s&0\r\n"
	  "&2&bo&0) Act Flags     : &6%s&0\r\n"
	  "&2&bp&0) Aff1 Flags    : &6%s&0\r\n"
	  "&2&br&0) Aff2 Flags    : &6%s&0\r\n"
	  "&2&bt&0) Aff3 Flags    : &6%s&0\r\n"
	  "&2&bs&0) Script        : &6%s&0\r\n"
	  "&2&bq&0) Quit\r\n"
a1076 2
	 buf3,
	 buf4,
a1082 74
/*
  
  void medit_disp_menu(struct descriptor_data *d)
  {
  struct char_data *mob;
  
  mob = OLC_MOB(d);
  get_char_cols(d->character);
  
  sprintf(buf,
  #if defined(CLEAR_SCREEN)
  ".[H.[J"
  #endif
  "&0&1&bHitroll/Damroll/Main hp/numdamdice/sizedamdice are BONUSES&0\r\n"
  "-- Mob Number:  [%s%d%s]\r\n"
  "%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
  "%s3%s) S-Desc: %s%s\r\n"
  "%s4%s) L-Desc:-\r\n%s%s"
  "%s5%s) D-Desc:-\r\n%s%s"
  "%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]\r\n"
  "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:    (%d)[%s%4d%s]\r\n"
  "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
  "%sC%s) Num HP Dice: [%s%4d%s],  %sD%s) Size HP Dice: [%s%4d%s],  %sE%s) Main hp&0&1&bB&0:(%ld)[%s%5d%s]\r\n"
  "%sF%s) Armor Class: [%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s],  %sH%s) Gold:  [%s%8ld%s]\r\n",	
  cyn, OLC_NUM(d), nrm,
  grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
  grn, nrm, yel, GET_ALIAS(mob),
  grn, nrm, yel, GET_SDESC(mob),
  grn, nrm, yel, GET_MOBLDESC(mob),
  grn, nrm, yel, GET_DDESC(mob),
  grn, nrm, cyn, GET_LEVEL(mob), nrm,
  grn, nrm, cyn, GET_ALIGNMENT(mob), nrm,
  grn, nrm, (mob->points.hitroll) ,cyn, (mob->mob_specials.ex_hitroll), nrm,
  grn, nrm, (mob->points.hitroll), cyn, (mob->mob_specials.ex_damroll), nrm,
  grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
  grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
  grn, nrm, cyn, (mob->mob_specials.ex_no_dice), nrm,
  grn, nrm, cyn, (mob->mob_specials.ex_face), nrm,
  grn, nrm, cyn, GET_MOVE(mob), nrm,
  grn, nrm, cyn, GET_AC(mob), nrm, 
*/     /*. Gold & Exp are longs in my mud, ignore any warnings .*/
/*	grn, nrm, ((long)GET_EXP(mob)), cyn, (long)GET_EX_EXP(mob), nrm,
	grn, nrm, cyn, (long)GET_GOLD(mob), nrm);
	send_to_char(buf, d->character);
	
	sprintbit(MOB_FLAGS(mob), action_bits, buf1);
	sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
	sprintf(buf,
	"%sI%s) Position  : %s%s\r\n"
        "%sJ%s) Default   : %s%s\r\n"
        "%sK%s) Attack    : %s%s\r\n"
        "%sL%s) NPC Flags : %s%s\r\n"
        "%sM%s) AFF Flags : %s%s\r\n"
	"%sN%s) Class	  : %s%s\r\n"
	"%sO%s) Species	  : %s%s\r\n"
        "%sQ%s) Quit\r\n"
        "Enter choice : ",
	
	grn, nrm, yel, position_types[(int)GET_POS(mob)],
	grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
        grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
	grn, nrm, cyn, buf1, 
	grn, nrm, cyn, buf2,
	grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob) + 1],    
	grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
        grn, nrm
	);
	send_to_char(buf, d->character);
	
	OLC_MODE(d) = MEDIT_MAIN_MENU;
	}
	
	
*/
a1264 10
      case 'r':
      case 'R':
	OLC_MODE(d) = MEDIT_AFF2_FLAGS;
	medit_disp_aff2_flags(d);
	return;
      case 't':
      case 'T':
	OLC_MODE(d) = MEDIT_AFF3_FLAGS;
	medit_disp_aff3_flags(d);
	return;
d1347 1
a1347 1
      else if (!((i < 0) || (i > NUM_MOB_FLAGS)))
d1349 2
d1357 1
a1357 1
      else if (!((i < 0) || (i > NUM_AFF_FLAGS)))
d1359 4
a1365 16
    case MEDIT_AFF2_FLAGS:
      if ((i = atoi(arg)) == 0)
	break;
      else if (!((i < 0) || (i > NUM_AFF2_FLAGS)))
	TOGGLE_BIT(AFF2_FLAGS(OLC_MOB(d)), 1 << (i - 1));
      medit_disp_aff2_flags(d);
      return;
/*-------------------------------------------------------------------*/
    case MEDIT_AFF3_FLAGS:
      if ((i = atoi(arg)) == 0)
	break;
      else if (!((i < 0) || (i > NUM_AFF3_FLAGS)))
	TOGGLE_BIT(AFF3_FLAGS(OLC_MOB(d)), 1 << (i - 1));
      medit_disp_aff3_flags(d);
      return;
/*-------------------------------------------------------------------*/
d1550 3
@


1.30
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.29 2007/07/18 00:04:41 jps Exp jps $
d962 1
a962 1
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
d985 1
a985 1
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
d1641 3
@


1.29
log
@Save AFF2 and AFF3 flags for mobiles.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.28 2007/03/27 04:27:05 myc Exp jps $
d1357 1
a1357 1
		send_to_char("You cannot purge a non-existant (unsaved) mob! Choose again:\r\n",d->character);
d1641 3
@


1.28
log
@Fixed index bug with sizes where they were all one off.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.27 2006/04/19 21:04:15 rls Exp myc $
d631 3
d1641 3
@


1.27
log
@Recolorized medit menu and cleaned up formatting
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.26 2006/04/11 09:25:45 rls Exp $
d711 1
a711 1
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, sizes[i]);
d1025 1
a1025 1
	  mspecies_types[(int)GET_SPECIES(mob)], sizes[(int)GET_SIZE(mob)], 
d1032 1
a1032 1
          "&2&bh&0) Armor Class: (&6%-3d&0) [&6&b%-3d&0]    &2&bi&0) Exp: [&6&b%-9ld&0] \r\n"          
d1638 3
@


1.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.25 2006/04/11 09:07:49 rls Exp $
d1017 7
a1023 7
          "-- Mob #: [%d]\r\n"
	  "0) Alias: %s\r\n"
	  "1) Short: %s\r\n"
	  "2) Long : %s\r"
	  "3) Description:\r\n%s"
	  "4) Species: %-10s    5) Size: %-10s      6) Sex: %s\r\n"
     	  "7) Level: %-3d             8) Class: %-10s    9) Alignment: %4d\r\n",
d1029 5
a1033 5
	  "a) Hitroll: (%-3d)[%-3d]    b) Damroll: (%-3d)[%-3d] \r\n"
	  "c) # Dam Dice: (%-3d) [%-3d]  d) Size Dam Die: (%-3d) [%-3d]  (ie. xdy + z) \r\n"
	  "e) # HP Dice:(%-3d) [%-3d]      f)Size HP Dice:(%-3d) [%-3d%]    g) Bonus HP: (%-5d%) [%-5d] \r\n"
	  "h) Armor Class: (%-3d) [%-3d]   i) Exp: [%-9ld] \r\n"          
          "j) Gold:  [%-8d]             k) Plat:  [%-8d] \r\n",
d1053 9
a1061 9
	  "%sl%s) Load Position : %s%s\r\n"
	  "%sm%s) Default Pos   : %s%s\r\n"
	  "%sn%s) Attack Type   : %s%s\r\n"
	  "%so%s) Act Flags     : %s%s\r\n"
	  "%sp%s) Aff1 Flags    : %s%s\r\n"
	  "%sr%s) Aff2 Flags    : %s%s\r\n"
	  "%st%s) Aff3 Flags    : %s%s\r\n"
	  "%ss%s) Script        : %s%s\r\n"
	  "%sq%s) Quit\r\n"
d1064 8
a1071 10
	  grn, nrm, yel, position_types[(int)GET_POS(mob)],
	  grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
	  grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
	  grn, nrm, cyn, buf1, 
	  grn, nrm, cyn, buf2,
	  grn, nrm, cyn, buf3,
	  grn, nrm, cyn, buf4,
	  grn, nrm, cyn, mob->proto_script?"Set.":"Not Set.",
	  grn, nrm
	  );
d1638 3
@


1.25
log
@Updated mobile display screen... added aff2, aff3
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.24 2004/11/11 22:27:28 rsd Exp $
d1005 1
a1005 1
  char buf5[609];
d1640 3
@


1.24
log
@Split up a large buffer that the compiler was complaining
was over 509 bytes.
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.23 2002/09/13 02:32:10 jjl Exp $
d56 2
d96 2
d268 2
a269 2
  (mob)->mob_specials.ex_no_dice = 0;
  (mob)->mob_specials.ex_face = 0;
d608 1
a608 1
	      GET_EX_AC(mob) / 10, (mob)->mob_specials.ex_no_dice, (mob)->mob_specials.ex_face, GET_MOVE(mob),
d947 46
d1003 3
d1015 12
a1026 18
	  "&0&1&bHitroll/Damroll/Main hp/numdamdice/sizedamdice are BONUSES&0\r\n"
	  "&0&3&bDo &1&bNOT&0&3&b use MOB PROGS anymore! We are removing MOB PROGS&0\r\n"
          "&0&3&bUse triggers instead.&0\r\n"
	  "-- Mob Number:  [%s%d%s]\r\n"
	  "%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
	  "%s3%s) S-Desc: %s%s\r\n"
	  "%s4%s) L-Desc:-\r\n%s%s"
	  "%s5%s) D-Desc:-\r\n%s%s"
	  "%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]  Total exp: (%ld)\r\n",
	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	  grn, nrm, yel, GET_ALIAS(mob),
	  grn, nrm, yel, GET_SDESC(mob),
	  grn, nrm, yel, GET_MOBLDESC(mob),
	  grn, nrm, yel, GET_DDESC(mob),
	  grn, nrm, cyn, GET_LEVEL(mob), nrm,
	  grn, nrm, cyn, GET_ALIGNMENT(mob), nrm, GET_EXP(mob)
	  );
d1029 15
a1043 16
	  "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:     (%d)[%s%4d%s]\r\n"
	  "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	  "%sC%s)No HP Dice&0&1&bB&0:(%d)[%s%2d%s], %sD%s)Size HP Dice&0&1&bB&0:(%d)[%s%4d%s], %sE%s) Main&0&1&bB&0(%d):[%s%5d%s]\r\n"
	  "%sF%s) Armor Class: (%d)[%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s]\r\n  %sH%s) Gold:  [%s%8d%s] %sR%s) Plat:  [%s%8d%s]\r\n",	
	  grn, nrm,  (mob->points.hitroll), cyn, (mob->mob_specials.ex_hitroll), nrm,
	  grn, nrm,  (mob->points.damroll), cyn, (mob->mob_specials.ex_damroll), nrm,
	  grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
	  grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
	  grn, nrm, (mob)->points.hit, cyn, (mob->mob_specials.ex_no_dice), nrm,
	  grn, nrm, (mob->points.mana), cyn, (mob->mob_specials.ex_face), nrm,
	  grn, nrm, (GET_EX_MAIN_HP(mob) + (mob)->points.move), cyn, GET_MOVE(mob), nrm,
	  grn, nrm, GET_AC(mob) , cyn, GET_EX_AC(mob), nrm, 
	  /*. Gold & Exp are longs in my mud, ignore any warnings .*/
	  grn, nrm, cyn, (long)GET_EX_EXP(mob), nrm,
	  grn, nrm, cyn, GET_EX_GOLD(mob), nrm,
	  grn, nrm, cyn, GET_EX_PLAT(mob), nrm);
d1049 3
d1053 9
a1061 10
	  "%sI%s) Position  : %s%s\r\n"
	  "%sJ%s) Default   : %s%s\r\n"
	  "%sK%s) Attack    : %s%s\r\n"
	  "%sL%s) NPC Flags : %s%s\r\n"
	  "%sM%s) AFF Flags : %s%s\r\n"
	  "%sN%s) Class	    : %s%s\r\n"
	  "%sO%s) Species   : %s%s\r\n"
          "%sZ%s) Size      : %s%s\r\n"
	  "%sS%s) Script    : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
d1069 2
a1070 3
	  grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob) + 1],    
	  grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
          grn, nrm, cyn, sizes[(int)GET_SIZE(mob)],
d1196 2
a1197 1
      switch (*arg) {
d1206 1
a1206 5
      case '1':
	OLC_MODE(d) = MEDIT_SEX;
	medit_disp_sex(d);
	return;
      case '2':
d1210 1
a1210 1
      case '3':
d1214 1
a1214 1
      case '4':
d1218 1
a1218 1
      case '5':
d1231 8
d1240 4
a1246 4
      case '7':
	OLC_MODE(d) = MEDIT_ALIGNMENT;
	i++;
	break;
d1248 3
a1250 3
	OLC_MODE(d) = MEDIT_HITROLL;
	i++;
	break;
d1252 1
a1252 1
	OLC_MODE(d) = MEDIT_DAMROLL;
d1257 1
a1257 1
	OLC_MODE(d) = MEDIT_NDD;
d1262 1
a1262 1
	OLC_MODE(d) = MEDIT_SDD;
d1267 1
a1267 1
	OLC_MODE(d) = MEDIT_NUM_HP_DICE;
d1272 1
a1272 1
	OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
d1277 1
a1277 1
	OLC_MODE(d) = MEDIT_ADD_HP;
d1282 1
a1282 1
	OLC_MODE(d) = MEDIT_AC;
d1287 1
a1287 1
	OLC_MODE(d) = MEDIT_EXP;
d1292 10
d1305 2
a1306 2
      case 'r':
      case 'R':
d1310 2
a1311 2
      case 'i':
      case 'I':
d1315 2
a1316 2
      case 'j':
      case 'J':
d1320 2
a1321 2
      case 'k':
      case 'K':
d1325 2
a1326 2
      case 'l':
      case 'L':
d1330 2
a1331 2
      case 'm':
      case 'M':
d1335 9
a1343 4
      case 'n':
      case 'N':
	OLC_MODE(d) = MEDIT_CLASS;
	medit_class_types(d);	 
d1345 6
a1350 4
      case 'o':
      case 'O':
	OLC_MODE(d) = MEDIT_SPECIES;
	medit_species_types(d);
d1352 2
a1353 2
      case 'p':
      case 'P':
d1366 1
a1366 1
	  /* make extra sure*/
d1370 1
a1370 13
	return;
      case 'z':
      case 'Z':
        OLC_MODE(d) = MEDIT_SIZE;
        medit_size(d);
        return;
      case 's':
      case 'S':
	OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
	OLC_SCRIPT(d) = OLC_MOB(d)->proto_script;
	OLC_MOB(d)->proto_script=(struct trig_proto_list *)NULL;
	dg_script_menu(d);
	return;
d1440 16
d1495 1
a1495 1
      OLC_MOB(d)->mob_specials.ex_no_dice = MAX(-30, MIN(30, atoi(arg)));
d1497 1
a1497 1
      OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
d1501 1
a1501 1
      OLC_MOB(d)->mob_specials.ex_face = MAX(-1000, MIN(1000, atoi(arg)));
d1503 1
a1503 1
      OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;
d1549 5
d1619 1
a1619 1
  OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;
d1621 1
a1621 1
  OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
d1640 4
@


1.23
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: medit.c,v 1.22 2002/07/14 03:41:31 rls Exp $
d952 1
d970 1
a970 5
	  "%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]  Total exp: (%ld)\r\n"
	  "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:     (%d)[%s%4d%s]\r\n"
	  "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	  "%sC%s)No HP Dice&0&1&bB&0:(%d)[%s%2d%s], %sD%s)Size HP Dice&0&1&bB&0:(%d)[%s%4d%s], %sE%s) Main&0&1&bB&0(%d):[%s%5d%s]\r\n"
	  "%sF%s) Armor Class: (%d)[%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s]\r\n  %sH%s) Gold:  [%s%8d%s] %sR%s) Plat:  [%s%8d%s]\r\n",	
d978 8
a985 1
	  grn, nrm, cyn, GET_ALIGNMENT(mob), nrm, GET_EXP(mob),
d999 1
d1562 3
@


1.22
log
@removed purge functionality from menu
@
text
@d1 3
a3 1
// $Id: medit.c,v 1.21 2001/07/08 16:01:22 mtp Exp $
d1555 120
a1674 115
// $Log: medit.c,v $
// Revision 1.21  2001/07/08 16:01:22  mtp
// added safety check for purge of level LVL_HEAD_B (currently 103)
//
// Revision 1.19  2000/11/28 01:46:44  mtp
// made class explicitly MCLASS_VOID for new mobs
//
// Revision 1.18  2000/11/28 01:26:11  mtp
// removed a lot of mobprog stuff
//
// Revision 1.17  2000/11/23 05:11:16  rsd
// Added the standard comment header, also mopped up some
// whitespace.  Added back rlog messages from prior to
// the addition of the $log$ string.
//
// Revision 1.16  2000/11/22 01:09:13  mtp
// added more mob classes (all the ones that are available for players)
//
// Revision 1.15  2000/11/09 03:43:19  rsd
// removed mob progs from the medit display menue and the
// switch that allows choice P to enter the prog menue
// system.
//
// Revision 1.14  2000/10/14 11:12:40  mtp
// fixed the olc triggers editting in medit/oedit/redit
//
// Revision 1.13  2000/10/13 23:13:42  mtp
// fixed why scripts weren't showing in medit, but the medit 
// code is _really_ buggy
//
// Revision 1.12  1999/12/10 05:13:14  cso
// added support for choosing mob size (case Z in medit)
//
// Revision 1.11  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.10  1999/07/09 22:30:27  jimmy
// Attempt to control the spiraling of memory.  Added a free() to the
// prompt code in comm.c to free memory allocated by parse_color().
// made a global structure dummy_mob and malloc'ed it for mobs
// to share as their player_specials to cut memory.
// gurlaek
//
// Revision 1.9  1999/07/06 19:57:05  jimmy
// This is a Mass check-in of the new skill/spell/language assignment system.
// This New system combines the assignment of skill/spell/language for
// both mobs and PCs.  LOts of code was touched and many errors were fixed.
// MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
// MObs now get random skill/spell/language levels baseed on their race/class/level
// that exactly align with PC's.  PC's no longer have to rent to use skills gained
// by leveling or when first creating a char.  Languages no longer reset to defaults
// when a PC levels.  Discovered that languages have been defined right in the middle
// of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
// the mob files to compensate for the 13 to -1 class change.
// --gurlaek 7/6/1999
//
// Revision 1.8  1999/06/30 18:25:04  jimmy
// >> This is a major conversion from the 18 point attribute system to the
// >> 100 point attribute system.  A few of the major changes are:
// >> All attributes are now on a scale from 0-100
// >> Everyone views attribs the same but, the attribs for one race
// >>   may be differeent for that of another even if they are the
// >>   same number.
// >> Mobs attribs now get rolled and scaled using the same algorithim as PC's
// >> Mobs now have individual random attributes based on race/class.
// >> The STR_ADD attrib has been completely removed.
// >> All bonus tables for attribs in constants.c have been replaced by
// >>   algorithims that closely duplicate the tables except on a 100 scale.
// >> Some minor changes:
// >> Race selection at char creation can now be toggled by using
// >>   <world races off>
// >> Lots of cleanup done to affected areas of code.
// >> Setting attributes for mobs in the .mob file no longer functions
// >>   but is still in the code for later use.
// >> We now have a spare attribut structure in the pfile because the new
// >>   system only used three instead of four.
// >> --gurlaek 6/30/1999
//
// Revision 1.7  1999/03/31 16:03:47  jen
// Added a "()" pair to remove a warning during compilation.
//
// Revision 1.6  1999/03/30 19:46:06  jen
// Changed the medit_mprog_type so that it properly changed the type
// of mprog... Selina 3-30-99
//
// Revision 1.5  1999/02/15 01:12:40  jimmy
// Yet another atempt to fix the medit crashe bug
// created by adding the long descr to the pfile.
// Think this finally got it.
// fingon
//
// Revision 1.4  1999/02/11 23:52:09  jimmy
// fixed medit crash bug introduced by adding
// long desc to pfile
// fingon
//
// Revision 1.3  1999/02/10 05:57:14  jimmy
// Added long description to player file.  Added AFK toggle.
// removed NOAUCTION toggle.
// fingon
//
// Revision 1.2  1999/01/31 17:07:53  mud
// Branches 1.2.1
// Indented entire file
// IInteresting header comments, and is it just me or
// Iis about a third of the file commented?
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
// Revision 1.2.1.1
// Had to backrev to fix medit crash bug.
// should be all fixed now.
// fingon
//
@


1.21
log
@added safety check for purge of level LVL_HEAD_B (currently 103)
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.19 2000/11/28 01:46:44 mtp Exp $
d1006 1
a1006 1
	  "%s%sQ%s) Quit\r\n"
a1017 1
	  (((GET_LEVEL(d->character)<LVL_HEAD_B) || (GET_MOB_RNUM(mob) == -1))?"":"&1&bP&0) &1&bPURGE&0\r\n"),
d1554 3
@


1.20
log
@added purge which deletes from world and file
@
text
@d1018 1
a1018 1
	  ((GET_MOB_RNUM(mob) == -1)?"":"&1&bP&0) &1&bPURGE&0\r\n"),
d1282 5
@


1.19
log
@made class explicitly MCLASS_VOID for new mobs
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.18 2000/11/28 01:26:11 mtp Exp mtp $
d299 1
d308 1
a308 2
    OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
    copy_mobile((mob_proto + rmob_num), OLC_MOB(d));
d310 1
a310 1
     * Update live mobiles.
d312 78
a389 2
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (IS_MOB(live_mob) && GET_MOB_RNUM(live_mob) == rmob_num) {
d391 31
a421 8
	 * Only really need to update the strings, since these can
	 * cause protection faults.  The rest can wait till a reset/reboot.
	 */
	GET_ALIAS(live_mob) = GET_ALIAS(mob_proto + rmob_num);
	GET_SDESC(live_mob) = GET_SDESC(mob_proto + rmob_num);
	GET_MOBLDESC(live_mob) = (GET_MOBLDESC(mob_proto + rmob_num));
	GET_DDESC(live_mob) = GET_DDESC(mob_proto + rmob_num);
      }
d535 9
d1006 1
a1006 1
	  "%sQ%s) Quit\r\n"
d1018 1
d1277 14
d1487 23
d1550 3
@


1.18
log
@removed a lot of mobprog stuff
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.17 2000/11/23 05:11:16 rsd Exp mtp $
d265 1
a265 1
  GET_CLASS(mob) = 13;
d1404 3
@


1.17
log
@Added the standard comment header, also mopped up some
whitespace.  Added back rlog messages from prior to
the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.16 2000/11/22 01:09:13 mtp Exp $
a60 3
#if defined(OASIS_MPROG)
extern const char *mobprog_types[];
#endif
a75 5
#if defined(OASIS_MPROG)
#define GET_MPROG(mob)		(mob_index[(mob)->nr].mobprogs)
#define GET_MPROG_TYPE(mob)	(mob_index[(mob)->nr].progtypes)
#endif

a99 5
#if defined(OASIS_MPROG)
void medit_disp_mprog(struct descriptor_data *d);
void medit_change_mprog(struct descriptor_data *d);
const char *medit_get_mprog_type(struct mob_prog_data *mprog);
#endif
a161 4
#if defined(OASIS_MPROG)
  OLC_MPROGL(d) = NULL;
  OLC_MPROG(d) = NULL;
#endif
a179 4
#if defined(OASIS_MPROG)
  MPROG_DATA *temp;
  MPROG_DATA *head;
#endif
a187 23
#if defined(OASIS_MPROG)
  {
    /*
     * I think there needs to be a brace from the if statement to the #endif
     * according to the way the original patch was indented.  If this crashes,
     * try it with the braces and report to greerga@@van.ml.org on if that works.
     */
    if (GET_MPROG(mob))
      CREATE(OLC_MPROGL(d), MPROG_DATA, 1);
    head = OLC_MPROGL(d);
    for (temp = GET_MPROG(mob); temp;temp = temp->next) {
      OLC_MPROGL(d)->type = temp->type;
      OLC_MPROGL(d)->arglist = str_dup(temp->arglist);
      OLC_MPROGL(d)->comlist = str_dup(temp->comlist);
      if (temp->next) {
	CREATE(OLC_MPROGL(d)->next, MPROG_DATA, 1);
	OLC_MPROGL(d) = OLC_MPROGL(d)->next;
      }
    }
    OLC_MPROGL(d) = head;
    OLC_MPROG(d) = OLC_MPROGL(d);}
#endif
  
a435 9
#if defined(OASIS_MPROG)
  GET_MPROG(OLC_MOB(d)) = OLC_MPROGL(d);
  GET_MPROG_TYPE(OLC_MOB(d)) = (OLC_MPROGL(d) ? OLC_MPROGL(d)->type : 0);
  while (OLC_MPROGL(d)) {
    GET_MPROG_TYPE(OLC_MOB(d)) |= OLC_MPROGL(d)->type;
    OLC_MPROGL(d) = OLC_MPROGL(d)->next;
  }
#endif
  
a452 4
#if defined(OASIS_MPROG)
  MPROG_DATA *mob_prog = NULL;
#endif
  
a524 16
#if defined(OASIS_MPROG)
      /*
       * Write out the MobProgs.
       */
      mob_prog = GET_MPROG(mob);
      while(mob_prog) {
	strcpy(buf1, mob_prog->arglist);
	strip_string(buf1);
	strcpy(buf2, mob_prog->comlist);
	strip_string(buf2);
	fprintf(mob_file, "%s %s~\n%s", medit_get_mprog_type(mob_prog),
		buf1, buf2);
	mob_prog = mob_prog->next;
	fprintf(mob_file, "~\n%s", (!mob_prog ? "|\n" : ""));
      }
#endif
a560 100
/*. Display sex (Oooh-err).*/

#if defined(OASIS_MPROG)
/*
 * Get the type of MobProg.
 */
const char *medit_get_mprog_type(struct mob_prog_data *mprog)
{
  switch (mprog->type) {
  case IN_FILE_PROG:	return ">in_file_prog";
  case ACT_PROG:	return ">act_prog";
  case SPEECH_PROG:	return ">speech_prog";
  case RAND_PROG:	return ">rand_prog";
  case FIGHT_PROG:	return ">fight_prog";
  case HITPRCNT_PROG:	return ">hitprcnt_prog";
  case DEATH_PROG:	return ">death_prog";
  case ENTRY_PROG:	return ">entry_prog";
  case GREET_PROG:	return ">greet_prog";
  case ALL_GREET_PROG:	return ">all_greet_prog";
  case GIVE_PROG:	return ">give_prog";
  case BRIBE_PROG:	return ">bribe_prog";
  }
  return ">ERROR_PROG";
}

/*-------------------------------------------------------------------*/

/*
 * Display the MobProgs.
 */
void medit_disp_mprog(struct descriptor_data *d)
{
  struct mob_prog_data *mprog = OLC_MPROGL(d);
  
  OLC_MTOTAL(d) = 1;
  
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  while (mprog) {
    sprintf(buf, "%d) %s %s\r\n", OLC_MTOTAL(d), medit_get_mprog_type(mprog),
	    (mprog->arglist ? mprog->arglist : "NONE"));
    send_to_char(buf, d->character);
    OLC_MTOTAL(d)++;
    mprog = mprog->next;
  }
  sprintf(buf,  "%d) Create New Mob Prog\r\n"
	  "%d) Purge Mob Prog\r\n"
	  "Enter number to edit [0 to exit]:  ",
	  OLC_MTOTAL(d), OLC_MTOTAL(d) + 1);
  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProgs.
 */
void medit_change_mprog(struct descriptor_data *d)
{
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  sprintf(buf,  "1) Type: %s\r\n"
	  "2) Args: %s\r\n"
	  "3) Commands:\r\n%s\r\n\r\n"
	  "Enter number to edit [0 to exit]: ",
	  medit_get_mprog_type(OLC_MPROG(d)),
	  (OLC_MPROG(d)->arglist ? OLC_MPROG(d)->arglist: "NONE"),
	  (OLC_MPROG(d)->comlist ? OLC_MPROG(d)->comlist : "NONE"));
  
  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_CHANGE_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProg type.
 */
void medit_disp_mprog_types(struct descriptor_data *d)
{
  int i;
  
  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  
  for (i = 0; i < NUM_PROGS-1; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, mobprog_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter mob prog type : ", d->character);
  OLC_MODE(d) = MEDIT_MPROG_TYPE;
}
#endif

/*-------------------------------------------------------------------*/
a896 5
/*
#if defined(OASIS_MPROG)
	  "%sP%s) Mob Progs : %s%s\r\n"
#endif
*/
a908 5
/*
#if defined(OASIS_MPROG)
	  grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
#endif
*/
a971 3
	#if defined(OASIS_MPROG)
	"%sP%s) Mob Progs : %s%s\r\n"
	#endif
a981 3
	#if defined(OASIS_MPROG)
	grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
	#endif
a1172 9
	/*
	  #if defined(OASIS_MPROG)
	  case 'p':
	  case 'P':
	  OLC_MODE(d) = MEDIT_MPROG;
	  medit_disp_mprog(d);
	  return;
	  #endif
	*/
a1232 11
#if defined(OASIS_MPROG)
    case MEDIT_MPROG_COMLIST:
      /*
       * We should never get here, but if we do, bail out.
       */
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: medit_parse(): Reached MPROG_COMLIST case!",
	     BRF, LVL_BUILDER, TRUE);
      break;
#endif
/*-------------------------------------------------------------------*/
a1249 113
#if defined(OASIS_MPROG)
    case MEDIT_MPROG:
      if ((i = atoi(arg)) == 0)
	medit_disp_menu(d);
      else if (i == OLC_MTOTAL(d)) {
	struct mob_prog_data *temp;
	CREATE(temp, struct mob_prog_data, 1);
	temp->next = OLC_MPROGL(d);
	temp->type = -1;
	temp->arglist = NULL;
	temp->comlist = NULL;
	OLC_MPROG(d) = temp;
	OLC_MPROGL(d) = temp;
	OLC_MODE(d) = MEDIT_CHANGE_MPROG;
	medit_change_mprog (d);
      } else if (i < OLC_MTOTAL(d)) {
	struct mob_prog_data *temp;
	int x = 1;
	for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
	  x++;
	OLC_MPROG(d) = temp;
	OLC_MODE(d) = MEDIT_CHANGE_MPROG;
	medit_change_mprog (d);
      } else if (i == OLC_MTOTAL(d) + 1) {
	send_to_char("Which mob prog do you want to purge? ", d->character);
	OLC_MODE(d) = MEDIT_PURGE_MPROG;
      } else
	medit_disp_menu(d);
      return;
      
    case MEDIT_PURGE_MPROG:
      if ((i = atoi(arg)) > 0 && i < OLC_MTOTAL(d)) {
	struct mob_prog_data *temp;
	int x = 1;
	
	for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
	  x++;
	OLC_MPROG(d) = temp;
	REMOVE_FROM_LIST(OLC_MPROG(d), OLC_MPROGL(d), next);
	free(OLC_MPROG(d)->arglist);
	free(OLC_MPROG(d)->comlist);
	free(OLC_MPROG(d));
	OLC_MPROG(d) = NULL;
	OLC_VAL(d) = 1;
      }
      medit_disp_mprog(d);
      return;
      
    case MEDIT_CHANGE_MPROG: {
      if ((i = atoi(arg)) == 1)
	medit_disp_mprog_types(d);
      else if (i == 2) {
	send_to_char ("Enter new arg list: ", d->character);
	OLC_MODE(d) = MEDIT_MPROG_ARGS;
      } else if (i == 3) {
	send_to_char("Enter new mob prog commands:\r\n", d->character);
	/*
	 * Pass control to modify.c for typing.
	 */
	OLC_MODE(d) = MEDIT_MPROG_COMLIST;
	d->backstr = NULL;
	if (OLC_MPROG(d)->comlist) {
	  SEND_TO_Q(OLC_MPROG(d)->comlist, d);
	  d->backstr = str_dup(OLC_MPROG(d)->comlist);
	}
	d->str = &OLC_MPROG(d)->comlist;
	d->max_str = MAX_STRING_LENGTH;
	d->mail_to = 0;
	OLC_VAL(d) = 1;
      } else
	medit_disp_mprog(d);
      return;}
#endif

/*-------------------------------------------------------------------*/

    /*
     * Numerical responses.
     */
    
#if defined(OASIS_MPROG)
    
    /*David Klasinc suggests for MEDIT_MPROG_TYPE:
      
      switch (atoi(arg)) {
      case 0: OLC_MPROG(d)->type = 0; break;
      case 1: OLC_MPROG(d)->type = 1; break;
      case 2: OLC_MPROG(d)->type = 2; break;
      case 3: OLC_MPROG(d)->type = 4; break;
      case 4: OLC_MPROG(d)->type = 8; break;
      case 5: OLC_MPROG(d)->type = 16; break;
      case 6: OLC_MPROG(d)->type = 32; break;
      case 7: OLC_MPROG(d)->type = 64; break;
      case 8: OLC_MPROG(d)->type = 128; break;
      case 9: OLC_MPROG(d)->type = 256; break;
      case 10: OLC_MPROG(d)->type = 512; break;
      case 11: OLC_MPROG(d)->type = 1024; break;
      default: OLC_MPROG(d)->type = -1; break;
      }
    */
    case MEDIT_MPROG_TYPE:
      /* Changed (added the final "-1") to fix a bug in medit ... Selina 3-30-99 */
      OLC_MPROG(d)->type = (1 << (MAX(0, MIN(atoi(arg), NUM_PROGS - 1)) - 1));
      OLC_VAL(d) = 1;
      medit_change_mprog(d);
      return;
      
    case MEDIT_MPROG_ARGS:
      OLC_MPROG(d)->arglist = str_dup(arg);
      OLC_VAL(d) = 1;
      medit_change_mprog(d);
      return;
#endif
d1404 5
@


1.16
log
@added motere mob classes (all the ones that are available for players)
@
text
@d1 14
a14 9
// $Id: medit.c,v 1.15 2000/11/09 03:43:19 rsd Exp $
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
 *    				                                          *
 *  OasisOLC - medit.c 		                                          *
 *    				                                          *
 **  Copyright 1996 Harvey Gilpin.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
a27 1

a1724 3



d1726 3
d1738 2
a1739 1
// fixed why scripts weren't showing in medit, but the medit code is _really_ buggy
d1746 79
@


1.15
log
@removed mob progs from the medit display menue and the
switch that allows choice P to enter the prog menue
system.
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.14 2000/10/14 11:12:40 mtp Exp $
d1667 5
d1725 5
@


1.14
log
@fixed the olc triggers editting in medit/oedit/redit
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.13 2000/10/13 23:13:42 mtp Exp $
d1021 2
d1066 1
a1066 1

d1070 1
d1083 1
a1083 1

d1087 1
d1358 9
a1366 8

#if defined(OASIS_MPROG)
      case 'p':
      case 'P':
	OLC_MODE(d) = MEDIT_MPROG;
	medit_disp_mprog(d);
	return;
#endif
d1720 3
@


1.13
log
@fixed why scripts weren't showing in medit, but the medit code is _really_ buggy
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.12 1999/12/10 05:13:14 cso Exp mtp $
d1365 2
d1715 3
@


1.12
log
@added support for choosing mob size (case Z in medit)
@
text
@d1 1
a1 1
// $Id: medit.c,v 1.11 1999/09/05 07:00:39 jimmy Exp $
d177 5
d183 1
a184 2
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  
d229 3
d1713 3
@


1.11
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d51 1
d98 1
d745 21
d1054 4
a1057 2
	  "%sN%s) Class	  : %s%s\r\n"
	  "%sO%s) Species	  : %s%s\r\n"
d1072 2
d1342 6
d1558 4
d1583 1
a1583 3
      
      
      
d1651 1
d1656 1
d1660 1
a1660 1
      GET_SIZE(OLC_MOB(d)) = mob_find_size(atoi(arg));
d1705 4
a1708 1
// $Log$
@


1.10
log
@Attempt to control the spiraling of memory.  Added a free() to the
prompt code in comm.c to free memory allocated by parse_color().
made a global structure dummy_mob and malloc'ed it for mobs
to share as their player_specials to cut memory.
gurlaek
@
text
@d1 1
d1668 1
@


1.9
log
@This is a Mass check-in of the new skill/spell/language assignment system.
This New system combines the assignment of skill/spell/language for
both mobs and PCs.  LOts of code was touched and many errors were fixed.
MCLASS_VOID was moved from 13 to -1 to match CLASS_UNDEFINED for PC's.
MObs now get random skill/spell/language levels baseed on their race/class/level
that exactly align with PC's.  PC's no longer have to rent to use skills gained
by leveling or when first creating a char.  Languages no longer reset to defaults
when a PC levels.  Discovered that languages have been defined right in the middle
of the spell area.  This needs to be fixed.  A conversion util neeDs to be run on
the mob files to compensate for the 13 to -1 class change.
--gurlaek 7/6/1999
@
text
@d54 1
a286 2
  struct player_special_data *dummy_mob;

a312 2
  /* added by gurlaek to stop the dummy_mob losses 7/4/1999 */
  CREATE(dummy_mob, struct player_special_data, 1);
@


1.8
log
@>> This is a major conversion from the 18 point attribute system to the
>> 100 point attribute system.  A few of the major changes are:
>> All attributes are now on a scale from 0-100
>> Everyone views attribs the same but, the attribs for one race
>>   may be differeent for that of another even if they are the
>>   same number.
>> Mobs attribs now get rolled and scaled using the same algorithim as PC's
>> Mobs now have individual random attributes based on race/class.
>> The STR_ADD attrib has been completely removed.
>> All bonus tables for attribs in constants.c have been replaced by
>>   algorithims that closely duplicate the tables except on a 100 scale.
>> Some minor changes:
>> Race selection at char creation can now be toggled by using
>>   <world races off>
>> Lots of cleanup done to affected areas of code.
>> Setting attributes for mobs in the .mob file no longer functions
>>   but is still in the code for later use.
>> We now have a spare attribut structure in the pfile because the new
>>   system only used three instead of four.
>> --gurlaek 6/30/1999
@
text
@a45 1
extern struct player_special_data dummy_mob;
d286 2
d314 3
a316 1
  mob->player_specials = &dummy_mob;
d795 1
a795 1
	       grn, i, nrm, mclass_types[i]);
d1047 1
a1047 1
	  grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],    
d1126 1
a1126 1
	grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],    
@


1.7
log
@Added a "()" pair to remove a warning during compilation.
@
text
@a0 15

/********************************************************************************
 The below header states the original author of this file
Proky haschanged almost every aspect to allow mobs to use our unigue mobile booter 
that allows universal balance and the use of bonus. Also Banyal total chnaged
all the save_internals to us a valid size check (templet) before save.
we mad almost 90K rooms and 7K mobs with this and never had a error
sometimes a save want save and its 'cause teh save was rejected by the templet
Banyal
********************************************************************************/





d304 7
a310 7
  mob->real_abils.str = 11;
  mob->real_abils.intel = 11;
  mob->real_abils.wis = 11;
  mob->real_abils.dex = 11;
  mob->real_abils.con = 11;
  mob->real_abils.cha = 11;
  mob->aff_abils = mob->real_abils;
a549 2
      if (GET_ADD(mob) != 0)
	fprintf(mob_file, "StrAdd: %d\n", GET_ADD(mob));
@


1.6
log
@Changed the medit_mprog_type so that it properly changed the type
of mprog... Selina 3-30-99
@
text
@d1526 1
a1526 1
      OLC_MPROG(d)->type = (1 << MAX(0, MIN(atoi(arg), NUM_PROGS - 1)) - 1);
@


1.5
log
@Yet another atempt to fix the medit crashe bug
created by adding the long descr to the pfile.
Think this finally got it.
fingon
@
text
@d1525 2
a1526 1
      OLC_MPROG(d)->type = (1 << MAX(0, MIN(atoi(arg), NUM_PROGS - 1)));
@


1.4
log
@fixed medit crash bug introduced by adding
long desc to pfile
fingon
@
text
@d181 1
a181 1
  strcpy(GET_MOBLDESC(mob), "An unfinished mob stands here.\r\n");
d274 1
a274 1
  strcpy(GET_MOBLDESC(tmob), (GET_MOBLDESC(fmob) && *GET_MOBLDESC(fmob)) ? GET_MOBLDESC(fmob) : "undefined");
d365 1
a365 1
	strcpy(GET_MOBLDESC(live_mob), GET_MOBLDESC(mob_proto + rmob_num));
d1379 1
a1379 1
	strcpy(GET_MOBLDESC(OLC_MOB(d)), buf);
d1381 1
a1381 1
	strcpy(GET_MOBLDESC(OLC_MOB(d)), "undefined");
d1592 1
a1592 1
      GET_EX_AC(OLC_MOB(d)) = MAX(-100, MIN(100, atoi(arg)));
@


1.3
log
@Added long description to player file.  Added AFK toggle.
removed NOAUCTION toggle.
fingon
@
text
@d1 1
d84 1
a84 1
/*#define GET_LDESC(mob) ((mob)->player.long_descr)*/
d146 2
a147 2
    if (GET_LDESC(mob))
      free(GET_LDESC(mob));
d157 2
a158 2
    if (GET_LDESC(mob) && GET_LDESC(mob) != mob_proto[i].player.long_descr)
      free(GET_LDESC(mob));
d181 1
a181 1
  strcpy(GET_LDESC(mob), "An unfinished mob stands here.\r\n");
d252 2
a253 2
  if (GET_LDESC(tmob))
    free(GET_LDESC(tmob));
d274 1
a274 1
  strcpy(GET_LDESC(tmob), (GET_LDESC(fmob) && *GET_LDESC(fmob)) ? GET_LDESC(fmob) : "undefined");
d365 1
a365 1
	strcpy(GET_LDESC(live_mob), GET_LDESC(mob_proto + rmob_num));
d535 1
a535 1
      strcpy(buf1, (GET_LDESC(mob) && *GET_LDESC(mob)) ? GET_LDESC(mob) : "undefined");
d1021 1
a1021 1
	  grn, nrm, yel, GET_LDESC(mob),
d1102 1
a1102 1
  grn, nrm, yel, GET_LDESC(mob),
d1374 2
a1375 2
      if(GET_LDESC(OLC_MOB(d)))
	free(GET_LDESC(OLC_MOB(d)));
d1379 1
a1379 1
	strcpy(GET_LDESC(OLC_MOB(d)), buf);
d1381 1
a1381 1
	strcpy(GET_LDESC(OLC_MOB(d)), "undefined");
@


1.2
log
@Indented entrire file
Interesting header comments, and is it just me or
is about a third of the file commented?
@
text
@d83 1
a83 1
#define GET_LDESC(mob) ((mob)->player.long_descr)
d145 2
a146 2
    if (mob->player.long_descr)
      free(mob->player.long_descr);
d156 2
a157 2
    if (mob->player.long_descr && mob->player.long_descr != mob_proto[i].player.long_descr)
      free(mob->player.long_descr);
d180 1
a180 1
  GET_LDESC(mob) = str_dup("An unfinished mob stands here.\r\n");
d273 1
a273 1
  GET_LDESC(tmob) = str_dup((GET_LDESC(fmob) && *GET_LDESC(fmob)) ? GET_LDESC(fmob) : "undefined");
d364 1
a364 1
	GET_LDESC(live_mob) = GET_LDESC(mob_proto + rmob_num);
d1378 1
a1378 1
	GET_LDESC(OLC_MOB(d)) = str_dup(buf);
d1380 1
a1380 1
	GET_LDESC(OLC_MOB(d)) = str_dup("undefined");
@


1.2.1.1
log
@Had to backrev to fix medit crash bug.
should be all fixed now.
fingon
@
text
@d83 1
a83 1
#define GET_MLDESC(mob) ((mob)->player.long_descr)
d180 1
a180 1
  GET_MLDESC(mob) = str_dup("An unfinished mob stands here.\r\n");
d251 2
a252 2
  if (GET_MLDESC(tmob))
    free(GET_MLDESC(tmob));
d273 1
a273 1
  GET_MLDESC(tmob) = str_dup((GET_MLDESC(fmob) && *GET_MLDESC(fmob)) ? GET_MLDESC(fmob) : "undefined");
d364 1
a364 1
	GET_MLDESC(live_mob) = GET_MLDESC(mob_proto + rmob_num);
d534 1
a534 1
      strcpy(buf1, (GET_MLDESC(mob) && *GET_MLDESC(mob)) ? GET_MLDESC(mob) : "undefined");
d1020 1
a1020 1
	  grn, nrm, yel, GET_MLDESC(mob),
d1101 1
a1101 1
  grn, nrm, yel, GET_MLDESC(mob),
d1373 2
a1374 2
      if(GET_MLDESC(OLC_MOB(d)))
	free(GET_MLDESC(OLC_MOB(d)));
d1378 1
a1378 1
	GET_MLDESC(OLC_MOB(d)) = str_dup(buf);
d1380 1
a1380 1
	GET_MLDESC(OLC_MOB(d)) = str_dup("undefined");
@


1.1
log
@Initial revision
@
text
@d16 6
a21 6
*  _TwyliteMud_ by Rv.                          Based on CircleMud3.0bpl9 *
*    				                                          *
*  OasisOLC - medit.c 		                                          *
*    				                                          *
**  Copyright 1996 Harvey Gilpin.
*
d129 1
a129 1
 
d149 1
a149 1
 } else if ((i = GET_MOB_RNUM(mob)) > -1) {	/* Prototyped mobile. */
d163 1
a163 1

d170 1
a170 1

d173 1
a173 1

d186 1
a186 1

d204 1
a204 1

d209 1
a209 1

d214 16
a229 15
  /*
   * I think there needs to be a brace from the if statement to the #endif
   * according to the way the original patch was indented.  If this crashes,
   * try it with the braces and report to greerga@@van.ml.org on if that works.
   */
  if (GET_MPROG(mob))
    CREATE(OLC_MPROGL(d), MPROG_DATA, 1);
  head = OLC_MPROGL(d);
  for (temp = GET_MPROG(mob); temp;temp = temp->next) {
    OLC_MPROGL(d)->type = temp->type;
    OLC_MPROGL(d)->arglist = str_dup(temp->arglist);
    OLC_MPROGL(d)->comlist = str_dup(temp->comlist);
    if (temp->next) {
      CREATE(OLC_MPROGL(d)->next, MPROG_DATA, 1);
      OLC_MPROGL(d) = OLC_MPROGL(d)->next;
d231 2
a232 3
  }
  OLC_MPROGL(d) = head;
  OLC_MPROG(d) = OLC_MPROGL(d);}
d234 1
a234 1

d245 1
a245 1

d262 1
a262 1

d267 1
a267 1

d275 1
a275 1

d291 1
a291 1

d297 1
a297 1
    portability.*/
d302 1
a302 1

d304 1
a304 1
  GET_MANA(mob) = 10;
d317 1
a317 1

d325 1
a325 1

d342 1
a342 1

d345 2
a346 2


d367 1
a367 1
   }
d375 1
a375 1

d378 1
a378 1

d381 1
a381 1
/*	if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].virtual > OLC_NUM(d))) {*/
d414 1
a414 1
		rmob_num, top_of_mobt, top_of_mobt + 1, top_of_mobt + 2);
d427 1
a427 1

d442 1
a442 1

d449 1
a449 1

d458 1
a458 1

d466 1
a466 1

d479 1
a479 1

d488 1
a488 1

d505 2
a506 2

 #if defined(OASIS_MPROG)
d509 1
a509 1

d512 1
a512 1

d518 2
a519 2

   /*
d530 1
a530 1

d538 9
a546 9

   fprintf(mob_file, "%s~\n"
	"%s~\n"
	"%s~\n"
	"%s~\n"
	"%ld %ld %d E\n"
	"%d %d %d %dd%d+%d %dd%d+%d\n"
	"%d %d %ld %d\n"
	"%d %d %d %d %d %d %d\n",
d554 3
a556 3
	     GET_CLASS(mob), GET_SPECIES(mob), GET_RACE_ALIGN(mob), GET_SIZE(mob)
      );

d562 1
a562 1
            if (GET_STR(mob) != 11)
d576 1
a576 1

d581 3
a583 3
	 
	  script_save_to_disk(mob_file, mob, MOB_TRIGGER);

d595 1
a595 1
					buf1, buf2);
d604 1
a604 1
    sprintf(buf2, "%s/%d.mob", MOB_PREFIX, zone);
d610 1
a610 1

d614 3
a616 3
/**************************************************************************
 Menu functions 
 **************************************************************************/
d621 2
a622 2
	int i;

d624 4
a627 4

  #if defined(CLEAR_SCREEN)
send_to_char("[H[J", d->character);
  #endif
d669 1
a669 1

d671 1
a671 1

d677 1
a677 1
		(mprog->arglist ? mprog->arglist : "NONE"));
d683 3
a685 3
		"%d) Purge Mob Prog\r\n"
		"Enter number to edit [0 to exit]:  ",
		OLC_MTOTAL(d), OLC_MTOTAL(d) + 1);
d701 7
a707 7
		"2) Args: %s\r\n"
		"3) Commands:\r\n%s\r\n\r\n"
		"Enter number to edit [0 to exit]: ",
	medit_get_mprog_type(OLC_MPROG(d)),
	(OLC_MPROG(d)->arglist ? OLC_MPROG(d)->arglist: "NONE"),
	(OLC_MPROG(d)->comlist ? OLC_MPROG(d)->comlist : "NONE"));

d720 1
a720 1

d725 1
a725 1

d743 2
a744 2
	int i;

d746 2
a747 2

  #if defined(CLEAR_SCREEN)
d749 1
a749 1
 #endif
d762 1
a762 1
	int i;
d765 1
a765 1
  #if defined(CLEAR_SCREEN)
d767 1
a767 1
  #endif
d774 1
a774 1
 
d781 1
a781 1
	int i, columns = 0;
d784 1
a784 1
  #if defined(CLEAR_SCREEN)
d786 1
a786 1
  #endif
d789 1
a789 1
		!(++columns % 2) ? "\r\n" : "");
d793 2
a794 2
    sprintf(buf, "\r\nCurrent flags : %s%s%s\r\nEnter mob flags (0 to quit) : ",
		  cyn, buf1, nrm);
d800 11
a810 11
	int i;
 get_char_cols(d->character);
 #if defined(CLEAR_SCREEN)
/*send_to_char(".[H.[J", d->character);	*/
 send_to_char("\n\rListings of Classes\n\r", d->character);
 #endif
 for (i = 0; i < MCLASS_NUMBER; i++)
  {  sprintf(buf, "%s%2d%s) %s\r\n", 
	grn, i, nrm, mclass_types[i]);
     send_to_char(buf, d->character);
  }
d812 1
a812 1

d817 62
a878 62
	switch(arg) {
	case SPECIES_OTHER:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_UNDEAD:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_HUMANOID:
		return RACE_ALIGN_GOOD;
	break;
	case SPECIES_ANIMAL:
	return RACE_ALIGN_GOOD;
	break;
	case SPECIES_DRAGON:
		return RACE_ALIGN_GOOD;
		break;
	case SPECIES_DEMON:
		return RACE_ALIGN_EVIL;
		break;
	case SPECIES_GIANT:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_TROLL:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_ORC:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_DUERGAR:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_DROW_ELF:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_OGRE:
		return RACE_ALIGN_EVIL;
		break;
		case SPECIES_HUMAN:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_ELF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_HALF_ELF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_DWARF:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_GNOME:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_BARBARIAN:
		return RACE_ALIGN_GOOD;
		break;
		case SPECIES_HALFLING:
		return RACE_ALIGN_GOOD;
		break;
	default:
		return RACE_ALIGN_GOOD;
		break;
	}
d883 62
a944 62
	switch(arg) {
	case SPECIES_OTHER:
		return SIZE_MEDIUM;
	break;
	case SPECIES_UNDEAD:
		return SIZE_MEDIUM;
	break;
	case SPECIES_HUMANOID:
		return SIZE_MEDIUM;
	break;
	case SPECIES_ANIMAL:
	return SIZE_SMALL;
	break;
	case SPECIES_DRAGON:
		return SIZE_GARGANTUAN;
		break;
	case SPECIES_DEMON:
		return SIZE_GIANT;
		break;
	case SPECIES_GIANT:
		return SIZE_GIANT;
		break;
		case SPECIES_TROLL:
		return SIZE_LARGE;
		break;
		case SPECIES_ORC:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DUERGAR:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DROW_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_OGRE:
		return SIZE_HUGE;
		break;
		case SPECIES_HUMAN:
		return SIZE_MEDIUM;
		break;
		case SPECIES_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_HALF_ELF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_DWARF:
		return SIZE_MEDIUM;
		break;
		case SPECIES_GNOME:
		return SIZE_SMALL;
		break;
		case SPECIES_BARBARIAN:
		return SIZE_LARGE;
		break;
		case SPECIES_HALFLING:
		return SIZE_SMALL;
		break;
	default:
		return SIZE_MEDIUM;
		break;
	}
d947 1
a947 1
		 
d951 11
a961 11
	int i;
 get_char_cols(d->character);
 #if defined(CLEAR_SCREEN)
/*send_to_char(".[H.[J", d->character);	*/
 send_to_char("\n\rListings of Species\n\r", d->character);
 #endif
 for (i = 0; i < SPECIES_NUMBER; i++)
  {  sprintf(buf, "%s%2d%s) %s\r\n", 
	grn, i, nrm, mspecies_types[i]);
     send_to_char(buf, d->character);
  }
d963 1
a963 1

d971 1
a971 1
	int i, columns = 0;
d974 1
a974 1
  #if defined(CLEAR_SCREEN)
d976 1
a976 1
  #endif
d979 1
a979 1
			!(++columns % 2) ? "\r\n" : "");
d983 2
a984 2
    sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
			  cyn, buf1, nrm);
d987 1
a987 1
  
d997 1
a997 1

d1000 2
a1001 2

    sprintf(buf,
d1003 1
a1003 1
".[H.[J"
d1006 30
a1035 30
	"-- Mob Number:  [%s%d%s]\r\n"
	"%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
        "%s3%s) S-Desc: %s%s\r\n"
	"%s4%s) L-Desc:-\r\n%s%s"
	"%s5%s) D-Desc:-\r\n%s%s"
	"%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]  Total exp: (%ld)\r\n"
        "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:     (%d)[%s%4d%s]\r\n"
        "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	"%sC%s)No HP Dice&0&1&bB&0:(%d)[%s%2d%s], %sD%s)Size HP Dice&0&1&bB&0:(%d)[%s%4d%s], %sE%s) Main&0&1&bB&0(%d):[%s%5d%s]\r\n"
	"%sF%s) Armor Class: (%d)[%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s]\r\n  %sH%s) Gold:  [%s%8d%s] %sR%s) Plat:  [%s%8d%s]\r\n",	
	cyn, OLC_NUM(d), nrm,
	grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	grn, nrm, yel, GET_ALIAS(mob),
	grn, nrm, yel, GET_SDESC(mob),
	grn, nrm, yel, GET_LDESC(mob),
	grn, nrm, yel, GET_DDESC(mob),
	grn, nrm, cyn, GET_LEVEL(mob), nrm,
	grn, nrm, cyn, GET_ALIGNMENT(mob), nrm, GET_EXP(mob),
	grn, nrm,  (mob->points.hitroll), cyn, (mob->mob_specials.ex_hitroll), nrm,
	grn, nrm,  (mob->points.damroll), cyn, (mob->mob_specials.ex_damroll), nrm,
	grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
	grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
	grn, nrm, (mob)->points.hit, cyn, (mob->mob_specials.ex_no_dice), nrm,
	grn, nrm, (mob->points.mana), cyn, (mob->mob_specials.ex_face), nrm,
	grn, nrm, (GET_EX_MAIN_HP(mob) + (mob)->points.move), cyn, GET_MOVE(mob), nrm,
	grn, nrm, GET_AC(mob) , cyn, GET_EX_AC(mob), nrm, 
        /*. Gold & Exp are longs in my mud, ignore any warnings .*/
	grn, nrm, cyn, (long)GET_EX_EXP(mob), nrm,
	grn, nrm, cyn, GET_EX_GOLD(mob), nrm,
	grn, nrm, cyn, GET_EX_PLAT(mob), nrm);
d1037 1
a1037 1

d1041 7
a1047 7
	    "%sI%s) Position  : %s%s\r\n"
        "%sJ%s) Default   : %s%s\r\n"
        "%sK%s) Attack    : %s%s\r\n"
        "%sL%s) NPC Flags : %s%s\r\n"
        "%sM%s) AFF Flags : %s%s\r\n"
		"%sN%s) Class	  : %s%s\r\n"
		"%sO%s) Species	  : %s%s\r\n"
d1052 10
a1061 10
        "%sQ%s) Quit\r\n"
        "Enter choice : ",

	grn, nrm, yel, position_types[(int)GET_POS(mob)],
	grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
    grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
	grn, nrm, cyn, buf1, 
	grn, nrm, cyn, buf2,
	grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],    
	grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
d1063 1
a1063 1
	grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
d1065 3
a1067 3
	grn, nrm, cyn, mob->proto_script?"Set.":"Not Set.",
        grn, nrm
  );
d1069 1
a1069 1

d1074 3
a1076 3

void medit_disp_menu(struct descriptor_data *d)
{
d1078 1
a1078 1

d1081 33
a1113 33

    sprintf(buf,
#if defined(CLEAR_SCREEN)
".[H.[J"
#endif
	  "&0&1&bHitroll/Damroll/Main hp/numdamdice/sizedamdice are BONUSES&0\r\n"
	"-- Mob Number:  [%s%d%s]\r\n"
	"%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
        "%s3%s) S-Desc: %s%s\r\n"
	"%s4%s) L-Desc:-\r\n%s%s"
	"%s5%s) D-Desc:-\r\n%s%s"
	"%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]\r\n"
        "%s8%s) Hitroll&0&1&bB&0:    (%d)[%s%4d%s],  %s9%s) Damroll&0&1&bB&0:    (%d)[%s%4d%s]\r\n"
        "%sA%s) NumDamDice&0&1&bB&0: (%d)[%s%4d%s],  %sB%s) SizeDamDice&0&1&bB&0: (%d)[%s%4d%s]   Zone: %s%d%s\r\n"
	"%sC%s) Num HP Dice: [%s%4d%s],  %sD%s) Size HP Dice: [%s%4d%s],  %sE%s) Main hp&0&1&bB&0:(%ld)[%s%5d%s]\r\n"
	"%sF%s) Armor Class: [%s%4d%s],  %sG%s) Exp&0&1&bB&0:    [%s%9ld%s],  %sH%s) Gold:  [%s%8ld%s]\r\n",	
	cyn, OLC_NUM(d), nrm,
	grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	grn, nrm, yel, GET_ALIAS(mob),
	grn, nrm, yel, GET_SDESC(mob),
	grn, nrm, yel, GET_LDESC(mob),
	grn, nrm, yel, GET_DDESC(mob),
	grn, nrm, cyn, GET_LEVEL(mob), nrm,
	grn, nrm, cyn, GET_ALIGNMENT(mob), nrm,
	grn, nrm, (mob->points.hitroll) ,cyn, (mob->mob_specials.ex_hitroll), nrm,
	grn, nrm, (mob->points.hitroll), cyn, (mob->mob_specials.ex_damroll), nrm,
	grn, nrm, (mob->mob_specials.damnodice), cyn, (mob->mob_specials.ex_damnodice), nrm,
	grn, nrm, (mob->mob_specials.damsizedice), cyn, (mob->mob_specials.ex_damsizedice), nrm, cyn, GET_ZONE(mob), cyn,
	grn, nrm, cyn, (mob->mob_specials.ex_no_dice), nrm,
	grn, nrm, cyn, (mob->mob_specials.ex_face), nrm,
	grn, nrm, cyn, GET_MOVE(mob), nrm,
	grn, nrm, cyn, GET_AC(mob), nrm, 
   */     /*. Gold & Exp are longs in my mud, ignore any warnings .*/
d1116 6
a1121 6
  send_to_char(buf, d->character);

  sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  sprintf(buf,
	    "%sI%s) Position  : %s%s\r\n"
d1126 5
a1130 5
		"%sN%s) Class	  : %s%s\r\n"
		"%sO%s) Species	  : %s%s\r\n"
#if defined(OASIS_MPROG)
	  "%sP%s) Mob Progs : %s%s\r\n"
#endif
d1133 1
a1133 1

d1139 5
a1143 5
	 grn, nrm, cyn, mclass_types[(int)GET_CLASS(mob)],    
	 grn, nrm, cyn, mspecies_types[(int)GET_SPECIES(mob)],
#if defined(OASIS_MPROG)
	  grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
#endif
d1145 7
a1151 7
  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = MEDIT_MAIN_MENU;
}


d1154 1
a1154 1
  The GARGANTAUN event handler
d1159 3
a1161 3
int i;
if (OLC_MODE(d) > MEDIT_NUMERICAL_RESPONSE) {
	if (!*arg || (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1]))))) {
d1166 1
a1166 1

d1168 1
a1168 25
  {
/*-------------------------------------------------------------------*/
  case MEDIT_CONFIRM_SAVESTRING:
    /*. Ensure mob has MOB_ISNPC set or things will go pair shaped .*/
    SET_BIT(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
    switch (*arg) {
    case 'y':
    case 'Y':
      /*. Save the mob in memory and to disk  .*/
      send_to_char("Saving mobile to memory.\r\n", d->character);
      medit_save_internally(d);
      sprintf(buf, "OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* FALL THROUGH */
    case 'n':
    case 'N':
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save the mobile? : ", d->character);
      return;
    }
    break;

d1170 3
a1172 2
  case MEDIT_MAIN_MENU:
    i = 0;
d1174 10
a1183 6
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {	/* Anything been changed? */
	send_to_char("Do you wish to save the changes to the mobile? (y/n) : ", d->character);
	OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
      } else
d1185 5
a1189 24
      return;
    case '1':
      OLC_MODE(d) = MEDIT_SEX;
      medit_disp_sex(d);
      return;
    case '2':
      OLC_MODE(d) = MEDIT_ALIAS;
      i--;
      break;
    case '3':
      OLC_MODE(d) = MEDIT_S_DESC;
      i--;
      break;
    case '4':
      OLC_MODE(d) = MEDIT_L_DESC;
      i--;
      break;
    case '5':
      OLC_MODE(d) = MEDIT_D_DESC;
      SEND_TO_Q("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_MOB(d)->player.description) {
	SEND_TO_Q(OLC_MOB(d)->player.description, d);
	d->backstr = str_dup(OLC_MOB(d)->player.description);
d1191 139
a1329 101
      d->str = &OLC_MOB(d)->player.description;
      d->max_str = MAX_MOB_DESC;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      return;
    case '6':
      OLC_MODE(d) = MEDIT_LEVEL;
      i++;
      break;
    case '7':
      OLC_MODE(d) = MEDIT_ALIGNMENT;
      i++;
      break;
    case '8':
      OLC_MODE(d) = MEDIT_HITROLL;
      i++;
      break;
    case '9':
      OLC_MODE(d) = MEDIT_DAMROLL;
      i++;
      break;
    case 'a':
    case 'A':
      OLC_MODE(d) = MEDIT_NDD;
      i++;
      break;
    case 'b':
    case 'B':
      OLC_MODE(d) = MEDIT_SDD;
      i++;
      break;
    case 'c':
    case 'C':
      OLC_MODE(d) = MEDIT_NUM_HP_DICE;
      i++;
      break;
    case 'd':
    case 'D':
      OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
      i++;
      break;
    case 'e':
    case 'E':
      OLC_MODE(d) = MEDIT_ADD_HP;
      i++;
      break;
    case 'f':
    case 'F':
      OLC_MODE(d) = MEDIT_AC;
      i++;
      break;
    case 'g':
    case 'G':
      OLC_MODE(d) = MEDIT_EXP;
      i++;
      break;
    case 'h':
    case 'H':
      OLC_MODE(d) = MEDIT_EX_GOLD;
      i++;
      break;
	      case 'r':
    case 'R':
      OLC_MODE(d) = MEDIT_EX_PLAT;
      i++;
      break;
    case 'i':
    case 'I':
      OLC_MODE(d) = MEDIT_POS;
      medit_disp_positions(d);
      return;
    case 'j':
    case 'J':
      OLC_MODE(d) = MEDIT_DEFAULT_POS;
      medit_disp_positions(d);
      return;
    case 'k':
    case 'K':
      OLC_MODE(d) = MEDIT_ATTACK;
      medit_disp_attack_types(d);
      return;
    case 'l':
    case 'L':
      OLC_MODE(d) = MEDIT_NPC_FLAGS;
      medit_disp_mob_flags(d);
      return;
    case 'm':
    case 'M':
      OLC_MODE(d) = MEDIT_AFF_FLAGS;
      medit_disp_aff_flags(d);
      return;
		    case 'n':
	  case 'N':
		OLC_MODE(d) = MEDIT_CLASS;
	  	medit_class_types(d);	 
	  return;
	  case 'o':
	  case 'O':
		  OLC_MODE(d) = MEDIT_SPECIES;
		  medit_species_types(d);
		  return;
d1331 5
a1335 5
    case 'p':
    case 'P':
      OLC_MODE(d) = MEDIT_MPROG;
      medit_disp_mprog(d);
      return;
d1337 5
a1341 5
	case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
d1345 10
a1354 10
    }
    if (i != 0) {
      send_to_char(i == 1 ? "\r\nEnter new value : " :
		   i == -1 ? "\r\nEnter new text :\r\n] " :
			"\r\nOops...:\r\n", d->character);
      return;
    
    }
    break; 

d1356 3
a1358 3
  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
d1360 5
a1364 5
  case MEDIT_ALIAS:
    if(GET_ALIAS(OLC_MOB(d)))
      free(GET_ALIAS(OLC_MOB(d)));
    GET_ALIAS(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
d1366 5
a1370 5
  case MEDIT_S_DESC:
    if(GET_SDESC(OLC_MOB(d)))
      free(GET_SDESC(OLC_MOB(d)));
    GET_SDESC(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
d1372 12
a1383 12
  case MEDIT_L_DESC:
    if(GET_LDESC(OLC_MOB(d)))
      free(GET_LDESC(OLC_MOB(d)));
    if (arg && *arg) {
      strcpy(buf, arg);
      strcat(buf, "\r\n");
      GET_LDESC(OLC_MOB(d)) = str_dup(buf);
    } else
      GET_LDESC(OLC_MOB(d)) = str_dup("undefined");


    break;
d1385 9
a1393 9
  case MEDIT_D_DESC:
    /*
     * We should never get here.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached D_DESC case!",
			BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
d1396 8
a1403 8
  case MEDIT_MPROG_COMLIST:
    /*
     * We should never get here, but if we do, bail out.
     */
    cleanup_olc(d, CLEANUP_ALL);
        mudlog("SYSERR: OLC: medit_parse(): Reached MPROG_COMLIST case!",
			BRF, LVL_BUILDER, TRUE);
    break;
d1406 7
a1412 7
  case MEDIT_NPC_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
        else if (!((i < 0) || (i > NUM_MOB_FLAGS)))
      TOGGLE_BIT(MOB_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_mob_flags(d);
    return;
d1414 7
a1420 7
  case MEDIT_AFF_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
        else if (!((i < 0) || (i > NUM_AFF_FLAGS)))
      TOGGLE_BIT(AFF_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_aff_flags(d);
    return;
d1422 1
a1422 1
/*. Numerical responses .*/
d1424 43
a1466 63
  case MEDIT_MPROG:
    if ((i = atoi(arg)) == 0)
      medit_disp_menu(d);
    else if (i == OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      CREATE(temp, struct mob_prog_data, 1);
      temp->next = OLC_MPROGL(d);
      temp->type = -1;
      temp->arglist = NULL;
      temp->comlist = NULL;
      OLC_MPROG(d) = temp;
      OLC_MPROGL(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;
      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
        x++;
      OLC_MPROG(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i == OLC_MTOTAL(d) + 1) {
      send_to_char("Which mob prog do you want to purge? ", d->character);
      OLC_MODE(d) = MEDIT_PURGE_MPROG;
    } else
      medit_disp_menu(d);
    return;

  case MEDIT_PURGE_MPROG:
    if ((i = atoi(arg)) > 0 && i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;

      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
	x++;
      OLC_MPROG(d) = temp;
      REMOVE_FROM_LIST(OLC_MPROG(d), OLC_MPROGL(d), next);
      free(OLC_MPROG(d)->arglist);
      free(OLC_MPROG(d)->comlist);
      free(OLC_MPROG(d));
      OLC_MPROG(d) = NULL;
      OLC_VAL(d) = 1;
    }
    medit_disp_mprog(d);
    return;

  case MEDIT_CHANGE_MPROG: {
    if ((i = atoi(arg)) == 1)
      medit_disp_mprog_types(d);
    else if (i == 2) {
      send_to_char ("Enter new arg list: ", d->character);
      OLC_MODE(d) = MEDIT_MPROG_ARGS;
    } else if (i == 3) {
      send_to_char("Enter new mob prog commands:\r\n", d->character);
      /*
       * Pass control to modify.c for typing.
       */
      OLC_MODE(d) = MEDIT_MPROG_COMLIST;
      d->backstr = NULL;
      if (OLC_MPROG(d)->comlist) {
        SEND_TO_Q(OLC_MPROG(d)->comlist, d);
        d->backstr = str_dup(OLC_MPROG(d)->comlist);
a1467 5
      d->str = &OLC_MPROG(d)->comlist;
      d->max_str = MAX_STRING_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
    } else
d1469 26
a1494 1
    return;}
d1499 4
a1502 4
/*
 * Numerical responses.
 */

d1504 4
a1507 4

  /*David Klasinc suggests for MEDIT_MPROG_TYPE:

    switch (atoi(arg)) {
d1521 13
a1533 13
    }
*/
case MEDIT_MPROG_TYPE:
    OLC_MPROG(d)->type = (1 << MAX(0, MIN(atoi(arg), NUM_PROGS - 1)));
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;

  case MEDIT_MPROG_ARGS:
    OLC_MPROG(d)->arglist = str_dup(arg);
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;
d1535 105
a1639 105

  case MEDIT_SEX:
    GET_SEX(OLC_MOB(d)) = MAX(0, MIN(NUM_GENDERS -1, atoi(arg)));
    break;

  case MEDIT_HITROLL:
    OLC_MOB(d)->mob_specials.ex_hitroll = MAX(-50, MIN(50, atoi(arg)));
    OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;

	break;

  case MEDIT_DAMROLL:
    OLC_MOB(d)->mob_specials.ex_damroll = MAX(-50, MIN(50, atoi(arg)));
    OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
	OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll; 

	break;

  case MEDIT_NDD:
    OLC_MOB(d)->mob_specials.ex_damnodice = MAX(-30, MIN(30, atoi(arg)));
    OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
    OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
	break;




  case MEDIT_SDD:
    OLC_MOB(d)->mob_specials.ex_damsizedice = MAX(-125, MIN(125, atoi(arg)));
   	OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;

	break;

  case MEDIT_NUM_HP_DICE:
    OLC_MOB(d)->mob_specials.ex_no_dice = MAX(-30, MIN(30, atoi(arg)));
		    OLC_MOB(d)->points.hit = 20;
	OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
    break;

  case MEDIT_SIZE_HP_DICE:
    OLC_MOB(d)->mob_specials.ex_face = MAX(-1000, MIN(1000, atoi(arg)));
		OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);  
		OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;

    break;

  

  case MEDIT_ADD_HP:
    GET_MOVE(OLC_MOB(d)) = MAX(-30000, MIN(30000, atoi(arg)));
   	GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
    break;

  case MEDIT_AC:
    GET_EX_AC(OLC_MOB(d)) = MAX(-100, MIN(100, atoi(arg)));
    GET_AC(OLC_MOB(d)) = MIN(100, MAX(-100, (get_ac(OLC_MOB(d)->player.level, OLC_MOB(d)->player.race, OLC_MOB(d)->player.class) + GET_EX_AC(OLC_MOB(d))) ));
    break;

  case MEDIT_EXP:
    GET_EX_EXP(OLC_MOB(d)) = atol(arg);
    GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
	GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d)); 
	break;

 case MEDIT_EX_GOLD:
    GET_EX_GOLD(OLC_MOB(d)) = atol(arg);
	GET_GOLD(OLC_MOB(d)) += GET_EX_GOLD(OLC_MOB(d));
	break;

 case MEDIT_EX_PLAT:
    GET_EX_PLAT(OLC_MOB(d)) = atol(arg);
	GET_PLAT(OLC_MOB(d)) += GET_EX_PLAT(OLC_MOB(d));
	break;

  case MEDIT_POS:
    GET_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
    break;

  case MEDIT_DEFAULT_POS:
    GET_DEFAULT_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS-1, atoi(arg)));
    break;

  case MEDIT_ATTACK:
    GET_ATTACK(OLC_MOB(d)) = MAX(0, MIN(NUM_ATTACK_TYPES-1, atoi(arg)));
    break;

  case MEDIT_LEVEL:
    GET_LEVEL(OLC_MOB(d)) = MAX(1, MIN(100, atoi(arg)));
    break;

  case MEDIT_ALIGNMENT:
    GET_ALIGNMENT(OLC_MOB(d)) = MAX(-1000, MIN(1000, atoi(arg)));
    break;
  case MEDIT_CLASS:
	  GET_CLASS(OLC_MOB(d)) = atoi(arg);
  	  /*update class effected stuff*/
	  break;
	case MEDIT_SPECIES:
	  GET_RACE(OLC_MOB(d)) = atoi(arg);
  	  GET_RACE_ALIGN(OLC_MOB(d)) = mob_race_align(atoi(arg));
	  GET_SIZE(OLC_MOB(d)) = mob_find_size(atoi(arg));

	  break;
d1643 7
a1649 7
  default:
    /*. We should never get here .*/
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }
d1651 1
a1651 1
/*. END OF CASE 
d1654 19
a1672 19

		   	  /*update species effected stuff*/
GET_EX_MAIN_HP(OLC_MOB(d)) = (get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1));
    GET_EXP(OLC_MOB(d)) = get_set_exp(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, GET_ZONE(OLC_MOB(d)));
	GET_EXP(OLC_MOB(d)) += GET_EX_EXP(OLC_MOB(d)); 
 	OLC_MOB(d)->points.mana = get_set_hit(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 2);  
	OLC_MOB(d)->points.mana += OLC_MOB(d)->mob_specials.ex_face;
			    OLC_MOB(d)->points.hit = 20;
	OLC_MOB(d)->points.hit += OLC_MOB(d)->mob_specials.ex_no_dice;
       	OLC_MOB(d)->points.damroll	= get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
	OLC_MOB(d)->points.damroll	+= OLC_MOB(d)->mob_specials.ex_damroll; 
       OLC_MOB(d)->points.hitroll = get_set_hd(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->points.hitroll += OLC_MOB(d)->mob_specials.ex_hitroll;
	 OLC_MOB(d)->mob_specials.damnodice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 0);
    OLC_MOB(d)->mob_specials.damnodice += OLC_MOB(d)->mob_specials.ex_damnodice;
	  	OLC_MOB(d)->mob_specials.damsizedice = get_set_dice(OLC_MOB(d)->player.class, OLC_MOB(d)->player.race, OLC_MOB(d)->player.level, 1);
	OLC_MOB(d)->mob_specials.damsizedice += OLC_MOB(d)->mob_specials.ex_damsizedice;


d1678 1
@
