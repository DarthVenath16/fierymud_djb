head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.25.00.38.03;	author jps;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.24.23.34.00;	author jps;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.20.07.02.20;	author jps;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.01.19.10;	author rsd;	state Exp;
branches;
next	1.5;

1.5
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.08.29.07.06.04;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.04.24.06.46.52;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.00.00.41;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
/*extern void send_to_zone(char *messg, int zone_rnum);*/

/* same as any_one_arg except that it stops at punctuation */
char *any_one_name(char *argument, char *first_arg)
{
    char* arg;

    /* Find first non blank */
    while(isspace(*argument))
        argument++;

    /* Find length of first word */
    for(arg = first_arg ;
        *argument && !isspace(*argument) &&
          (!ispunct(*argument) || *argument == '#' || *argument == '-') ;
        arg++, argument++)
        *arg = LOWER(*argument);
    *arg = '\0';

    return argument;
}


void sub_write_to_char(char_data *ch, char *tokens[],
		       void *otokens[], char type[])
{
    char sb[MAX_STRING_LENGTH];
    int i;

    strcpy(sb,"");

    for (i = 0; tokens[i + 1]; i++)
    {
	strcat(sb,tokens[i]);

	switch (type[i])
	{
	case '~':
	    if (!otokens[i])
		strcat(sb,"someone");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,PERS((char_data *)otokens[i], ch));
	    break;

	case '@@':
	    if (!otokens[i])
		strcat(sb,"someone's");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"your");
	    else
	    {
		strcat(sb,PERS((char_data *) otokens[i], ch));
		strcat(sb,"'s");
	    }
	    break;

	case '^':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"its");
	    else if (otokens[i] == ch)
		strcat(sb,"your");
	    else
		strcat(sb,HSHR((char_data *) otokens[i]));
	    break;

	case '>':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HSSH((char_data *) otokens[i]));
	    break;

	case '*':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HMHR((char_data *) otokens[i]));
	    break;

	case '`':
	    if (!otokens[i])
		strcat(sb,"something");
	    else
		strcat(sb,OBJS(((obj_data *) otokens[i]), ch));
	    break;
	}
    }

    strcat(sb,tokens[i]);
    strcat(sb,"\n\r");
    sb[0] = toupper(sb[0]);
    send_to_char(sb,ch);
}


void sub_write(char *arg, char_data *ch, byte find_invis, int targets)
{
    char str[MAX_INPUT_LENGTH * 2];
    char type[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
    char *tokens[MAX_INPUT_LENGTH], *s, *p;
    void *otokens[MAX_INPUT_LENGTH];
    char_data *to;
    obj_data *obj;
    int i, tmp;
    int sleep = 1; /* mainly for windows compiles */

    if (!arg)
	return;

    tokens[0] = str;

    for (i = 0, p = arg, s = str; *p;)
    {
	switch (*p) {
	case '~':
	case '@@':
	case '^':
	case '>':
	case '*':
	    /* get char_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (char_data *)otokens[i] =
		find_invis ? get_char(name) : get_char_room_vis(ch, name);
	    tokens[++i] = ++s;
	    break;

	case '`':
	    /* get obj_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (obj_data *)otokens[i] =
		find_invis ? (obj = get_obj(name)) :
		    ((obj = get_obj_in_list_vis(ch, name,
				world[IN_ROOM(ch)].contents)) ? obj :
		     (obj = get_object_in_equip_vis(ch, name,
						    ch->equipment, &tmp)) ?
		     obj :
		     (obj = get_obj_in_list_vis(ch, name, ch->carrying)));
	    (obj_data *)otokens[i] = obj;
	    tokens[++i] = ++s;
	    break;

	case '\\':
	    p++;
	    *s++ = *p++;
	    break;

	default:
	    *s++ = *p++;
	}
    }

    *s = '\0';
    tokens[++i] = NULL;

    if (IS_SET(targets, TO_CHAR) && SENDOK(ch))
	sub_write_to_char(ch, tokens, otokens, type);

    if (IS_SET(targets, TO_ROOM))
	for (to = world[ch->in_room].people;
	     to; to = to->next_in_room)
	    if (to != ch && SENDOK(to))
		sub_write_to_char(to, tokens, otokens, type);
}
@


1.17
log
@New target finding mechanism in find.c.
@
text
@/***************************************************************************
 * $Id: dg_comm.c,v 1.16 2008/08/18 01:35:38 jps Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: dg_comm.c                                      Part of FieryMUD *
 *  Usage: Who knows?                                                      *
 *     By: Unknown                                                         *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 2000 by the Fiery Consortium                    *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "screen.h"

/* same as any_one_arg except that it stops at punctuation */
char *any_one_name(char *argument, char *first_arg)
{
  char* arg;
  
  /* Find first non blank */
  while (isspace(*argument))
    ++argument;
  
  /* Find length of first word */
  for (arg = first_arg;
       *argument && !isspace(*argument) &&
        (!ispunct(*argument) || *argument == '#' || *argument == '-');
      arg++, argument++)
    *arg = LOWER(*argument);
  *arg = '\0';
  
  return argument;
}

void sub_write_to_char(char_data *ch, char *tokens[],
                       char_data *ctokens[], obj_data *otokens[], char type[])
{
  char sb[MAX_STRING_LENGTH];
  int i;
  
  strcpy(sb, "");
  
  for (i = 0; tokens[i + 1]; i++)
    {
      strcat(sb, tokens[i]);
      /* changed everything to either c or o tokens respectively --gurlaek */
      switch (type[i])
	{
	case '~':
	  if (!ctokens[i])
	    strcat(sb, "someone");
	  else if (ctokens[i] == ch)
	    strcat(sb, "you");
	  else
	    strcat(sb, PERS(ctokens[i], ch));
	  break;
	  
	case '@@':
	  if (!ctokens[i])
	    strcat(sb, "someone's");
	  else if (ctokens[i] == ch)
	    strcat(sb, "your");
	  else
	    {
	      strcat(sb, PERS(ctokens[i], ch));
	      strcat(sb, "'s");
	    }
	  break;
	  
	case '^':
	  if (!ctokens[i] || !CAN_SEE(ch, ctokens[i]))
	    strcat(sb, "its");
	  else if (ctokens[i] == ch)
	    strcat(sb, "your");
	  else
	    strcat(sb, HSHR(ctokens[i]));
	  break;
	  
	case '>':
	  if (!ctokens[i] || !CAN_SEE(ch, ctokens[i]))
	    strcat(sb, "it");
	  else if (ctokens[i] == ch)
	    strcat(sb, "you");
	  else
	    strcat(sb, HSSH(ctokens[i]));
	  break;
	  
	case '*':
	  if (!ctokens[i] || !CAN_SEE(ch, ctokens[i]))
	    strcat(sb, "it");
	  else if (ctokens[i] == ch)
	    strcat(sb, "you");
	  else
	    strcat(sb, HMHR(ctokens[i]));
	  break;
	  
	case '`':
	  if (!otokens[i])
	    strcat(sb, "something");
	  else
	    strcat(sb, OBJS(otokens[i], ch));
	  break;
	}
    }
  
  strcat(sb, tokens[i]);
  strcat(sb, "\r\n");

  /* Want to capitalize it... by passing it through CAP, which will
   * skip past any &D color codes.
   * However, if it starts with &0, that's the signal that the
   * script writer does not want it capitalized. */
  if ((sb[0] == CREL || sb[0] == CABS) && sb[1] == '0')
     send_to_char(sb, ch);
  else
     send_to_char(CAP(sb), ch);
}


void sub_write(char *arg, char_data *ch, byte find_invis, int targets)
{
  char str[MAX_INPUT_LENGTH * 2];
  char type[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
  char *tokens[MAX_INPUT_LENGTH], *s, *p;
  char_data *ctokens[MAX_INPUT_LENGTH];
  obj_data  *otokens[MAX_INPUT_LENGTH];

  char_data *to;
  obj_data *obj;
  int i;
  int sleep = 1; /* mainly for windows compiles */
  int olc = 0;
  
  if (!arg)
    return;
  
  tokens[0] = str;
  
  for (i = 0, p = arg, s = str; *p;)
    {
      ctokens[i] = NULL;
      otokens[i] = NULL;
      switch (*p) {
      case '~':
      case '@@':
      case '^':
      case '>':
      case '*':
	/* get char_data, move to next token */
	type[i] = *p;
	*s = '\0';
        ++p;
	p = any_one_name(p, name);
	ctokens[i] = find_invis ? find_char_in_world(find_by_name(name)) : find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, name));
	tokens[++i] = ++s;
	break;
	
      case '`':
	/* get obj_data, move to next token */
	type[i] = *p;
	*s = '\0';
        ++p;
	p = any_one_name(++p, name);
        if (find_invis) obj = find_obj_in_world(find_by_name(name));
        else if (!(obj = find_obj_in_list(world[IN_ROOM(ch)].contents, find_vis_by_name(ch, name))));
        else if (!(obj = find_obj_in_eq(ch, NULL, find_vis_by_name(ch, name))));
        else obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, name));
	otokens[i] = obj;
	tokens[++i] = ++s;
	break;
	
      case '\\':
	p++;
	*s++ = *p++;
	break;
	
      default:
	*s++ = *p++;
      }
    }
  
  *s = '\0';
  tokens[++i] = NULL;
  
  if (IS_SET(targets, TO_CHAR) && SENDOK(ch))
    sub_write_to_char(ch, tokens, ctokens, otokens, type);
  
  if (IS_SET(targets, TO_ROOM))
    for (to = world[ch->in_room].people; to; to = to->next_in_room)
      if (to != ch && SENDOK(to))
        sub_write_to_char(to, tokens, ctokens, otokens, type);
}

/***************************************************************************
 * $Log: dg_comm.c,v $
 * Revision 1.16  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.15  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.14  2008/03/05 03:03:54  myc
 * Fix capitalization for DG triggers.
 *
 * Revision 1.13  2008/02/24 17:31:13  myc
 * Added a TO_OLC flag to act() to allow messages to be sent to people
 * while in OLC if they have OLCComm toggled on.
 *
 * Revision 1.12  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.11  2008/01/17 01:29:10  myc
 * Cleaned up sub_write_to_char and sub_write.  Everything seems to
 * still work...
 *
 * Revision 1.10  2007/07/25 00:38:03  jps
 * Give send_to_zone a room to skip, and make it use virtual zone number.
 *
 * Revision 1.9  2007/07/24 23:34:00  jps
 * Add a parameter min_position to send_to_zone()
 *
 * Revision 1.8  2006/11/20 07:02:20  jps
 * Allow color code &0 at the beginning of a line to suppress
 * capitalization of dg script messages.
 *
 * Revision 1.7  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.6  2000/11/21 01:19:10  rsd
 * Altered the comment header slightly, and added back rlog
 * messages from prior to the addition of the $log$ string.
 *
 * Revision 1.5  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.4  1999/08/29 07:06:04  jimmy
 * Many many small but ver significant bug fixes found using insure.  The
 * code now compiles cleanly and boots cleanly with insure.  The most significant
 * changes were moving all the BREATH's to within normal spell range, and
 * fixing the way socials were allocated.  Too many small fixes to list them
 * all. --gurlaek (now for the runtime debugging :( )
 *
 * Revision 1.3  1999/04/24 06:46:52  jimmy
 * changed to work with new pedantic flag --gurlaek
 *
 * Revision 1.2  1999/01/31 00:00:41  mud
 * Added the generic comment header
 * Indented entire file
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.16
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.15 2008/04/03 02:02:05 myc Exp jps $
d140 1
a140 1
  int i, tmp;
d164 1
a164 1
	ctokens[i] = find_invis ? get_char(name) : get_char_room_vis(ch, name);
d174 4
a177 4
        if (find_invis) obj = get_obj(name);
        else if (!(obj = get_obj_in_list_vis(ch, name, world[IN_ROOM(ch)].contents)));
        else if (!(obj = get_object_in_equip_vis(ch, name, ch->equipment, &tmp)));
        else obj = get_obj_in_list_vis(ch, name, ch->carrying);
d206 3
@


1.15
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.14 2008/03/05 03:03:54 myc Exp myc $
d117 1
a117 1
  strcat(sb, "\n\r");
d206 3
@


1.14
log
@Fix capitalization for DG triggers.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.13 2008/02/24 17:31:13 myc Exp myc $
d23 1
a23 1

d123 1
a123 1
  if (sb[0] == '&' && sb[1] == '0')
d206 3
@


1.13
log
@Added a TO_OLC flag to act() to allow messages to be sent to people
while in OLC if they have OLCComm toggled on.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.12 2008/01/29 21:02:31 myc Exp myc $
d109 1
a109 1
	    strcat(sb,"something");
d116 2
a117 2
  strcat(sb,tokens[i]);
  strcat(sb,"\n\r");
d124 1
a124 1
     send_to_char(CAP(sb),ch);
d126 1
a126 1
     send_to_char(sb,ch);
d206 4
@


1.12
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.11 2008/01/17 01:29:10 myc Exp myc $
d142 1
d206 4
@


1.11
log
@Cleaned up sub_write_to_char and sub_write.  Everything seems to
still work...
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.10 2007/07/25 00:38:03 jps Exp myc $
a23 3
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
/*extern void send_to_zone(char *messg, int zone_vnum, int skip_room, int min_position);*/
d205 4
@


1.10
log
@Give send_to_zone a room to skip, and make it use virtual zone number.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.9 2007/07/24 23:34:00 jps Exp jps $
d34 2
a35 2
  while(isspace(*argument))
    argument++; 
d38 3
a40 3
  for(arg = first_arg ;
      *argument && !isspace(*argument) &&
	(!ispunct(*argument) || *argument == '#' || *argument == '-') ;
a47 1
/* added *ctokens gurlaek */
d54 1
a54 1
  strcpy(sb,"");
d58 1
a58 1
      strcat(sb,tokens[i]);
d64 1
a64 1
	    strcat(sb,"someone");
d66 1
a66 1
	    strcat(sb,"you");
d68 1
a68 1
	    strcat(sb,PERS(ctokens[i], ch));
d73 1
a73 1
	    strcat(sb,"someone's");
d75 1
a75 1
	    strcat(sb,"your");
d78 2
a79 2
	      strcat(sb,PERS(ctokens[i], ch));
	      strcat(sb,"'s");
d85 1
a85 1
	    strcat(sb,"its");
d87 1
a87 1
	    strcat(sb,"your");
d89 1
a89 1
	    strcat(sb,HSHR((char_data *) ctokens[i]));
d94 1
a94 1
	    strcat(sb,"it");
d96 1
a96 1
	    strcat(sb,"you");
d98 1
a98 1
	    strcat(sb,HSSH(ctokens[i]));
d103 1
a103 1
	    strcat(sb,"it");
d105 1
a105 1
	    strcat(sb,"you");
d107 1
a107 1
	    strcat(sb,HMHR(ctokens[i]));
d114 1
a114 1
	    strcat(sb,OBJS((otokens[i]), ch));
d126 1
a126 1
  if (sb[0] != '&' || sb[1] != '0')
a137 2
  /*  void *otokens[MAX_INPUT_LENGTH]; changed by gurlaek */
  /* added for ANSI compliance */
d153 2
d164 1
a164 3
	/* p = any_one_name(++p, name); */
	/* replaced above line with following two. Needs to be tested. gurlaek 8/26/1999 */
	p++;
a165 1
	/* (char_data *)otokens[i] = removed by gurlaek */
d174 6
a179 14
	/* p = any_one_name(++p, name); */
	/* replaced above line with following two. Needs to be tested. gurlaek 8/26/1999 */
	p++;
	p = any_one_name(p, name);
	/* (obj_data *)otokens[i] = removed by gurlaek */
        otokens[i] =
	  find_invis ? (obj = get_obj(name)) :
	    ((obj = get_obj_in_list_vis(ch, name,
					world[IN_ROOM(ch)].contents)) ? obj :
	     (obj = get_object_in_equip_vis(ch, name,
					    ch->equipment, &tmp)) ?
	     obj :
	     (obj = get_obj_in_list_vis(ch, name, ch->carrying)));
/*	(obj_data *)otokens[i] = obj; removed by gurlaek */
a197 1
/*    sub_write_to_char(ch, tokens, otokens, type); removed by gurlaek */
d201 1
a201 2
    for (to = world[ch->in_room].people;
	 to; to = to->next_in_room)
d203 1
a203 2
/*    sub_write_to_char(to, tokens, otokens, type); removed by gurlaek */
    sub_write_to_char(to, tokens, ctokens, otokens, type);
d208 3
@


1.9
log
@Add a parameter min_position to send_to_zone()
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.8 2006/11/20 07:02:20 jps Exp jps $
d26 1
a26 1
/*extern void send_to_zone(char *messg, int zone_rnum, int min_position);*/
d223 3
@


1.8
log
@Allow color code &0 at the beginning of a line to suppress
capitalization of dg script messages.
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.7 2002/09/13 02:32:10 jjl Exp jps $
d26 1
a26 1
/*extern void send_to_zone(char *messg, int zone_rnum);*/
d223 4
@


1.7
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: dg_comm.c,v 1.6 2000/11/21 01:19:10 rsd Exp $
d122 9
a130 2
  sb[0] = toupper(sb[0]);
  send_to_char(sb,ch);
d223 3
@


1.6
log
@Altered the comment header slightly, and added back rlog
messages from prior to the addition of the $log$ string.
@
text
@d1 3
a3 1
// $Id: dg_comm.c,v 1.5 1999/09/05 07:00:39 jimmy Exp $
d214 27
a240 21
// $Log: dg_comm.c,v $
// Revision 1.5  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.4  1999/08/29 07:06:04  jimmy
// Many many small but ver significant bug fixes found using insure.  The
// code now compiles cleanly and boots cleanly with insure.  The most significant
// changes were moving all the BREATH's to within normal spell range, and
// fixing the way socials were allocated.  Too many small fixes to list them
// all. --gurlaek (now for the runtime debugging :( )
//
// Revision 1.3  1999/04/24 06:46:52  jimmy
// changed to work with new pedantic flag --gurlaek
//
// Revision 1.2  1999/01/31 00:00:41  mud
// Added the generic comment header
// Indented entire file
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.5
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d3 1
a3 1
 *  File: dg_comm.c                                       Part of FieryMUD *
d5 1
d7 1
a7 1
 *  By: Someone of HubisMUD                                                *
d9 1
a209 1

d212 21
a232 3


// $Log$
@


1.4
log
@Many many small but ver significant bug fixes found using insure.  The
code now compiles cleanly and boots cleanly with insure.  The most significant
changes were moving all the BREATH's to within normal spell range, and
fixing the way socials were allocated.  Too many small fixes to list them
all. --gurlaek (now for the runtime debugging :( )
@
text
@d1 1
d213 1
@


1.3
log
@changed to work with new pedantic flag --gurlaek
@
text
@d153 5
a157 2
	p = any_one_name(++p, name);
/*	(char_data *)otokens[i] = removed by gurlaek */
d166 5
a170 2
	p = any_one_name(++p, name);
/*	(obj_data *)otokens[i] = removed by gurlaek */
@


1.2
log
@Added the generic comment header
Indented entire fiulelele
@
text
@d43 1
a43 1

d45 1
a45 1
		       void *otokens[], char type[])
d55 1
a55 1
      
d59 1
a59 1
	  if (!otokens[i])
d61 1
a61 1
	  else if ((char_data *)otokens[i] == ch)
d64 1
a64 1
	    strcat(sb,PERS((char_data *)otokens[i], ch));
d68 1
a68 1
	  if (!otokens[i])
d70 1
a70 1
	  else if ((char_data *)otokens[i] == ch)
d74 1
a74 1
	      strcat(sb,PERS((char_data *) otokens[i], ch));
d80 1
a80 1
	  if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
d82 1
a82 1
	  else if (otokens[i] == ch)
d85 1
a85 1
	    strcat(sb,HSHR((char_data *) otokens[i]));
d89 1
a89 1
	  if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
d91 1
a91 1
	  else if (otokens[i] == ch)
d94 1
a94 1
	    strcat(sb,HSSH((char_data *) otokens[i]));
d98 1
a98 1
	  if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
d100 1
a100 1
	  else if (otokens[i] == ch)
d103 1
a103 1
	    strcat(sb,HMHR((char_data *) otokens[i]));
d110 1
a110 1
	    strcat(sb,OBJS(((obj_data *) otokens[i]), ch));
d127 5
a131 1
  void *otokens[MAX_INPUT_LENGTH];
d154 2
a155 2
	(char_data *)otokens[i] =
	  find_invis ? get_char(name) : get_char_room_vis(ch, name);
d164 2
a165 1
	(obj_data *)otokens[i] =
d173 2
a174 1
	(obj_data *)otokens[i] = obj;
d192 2
a193 1
    sub_write_to_char(ch, tokens, otokens, type);
d199 3
a201 1
	sub_write_to_char(to, tokens, otokens, type);
@


1.1
log
@Initial revision
@
text
@d1 8
d26 15
a40 15
    char* arg;

    /* Find first non blank */
    while(isspace(*argument))
        argument++; 
 
    /* Find length of first word */
    for(arg = first_arg ;
        *argument && !isspace(*argument) &&
          (!ispunct(*argument) || *argument == '#' || *argument == '-') ;
        arg++, argument++)
        *arg = LOWER(*argument);
    *arg = '\0';

    return argument;
d47 6
a52 6
    char sb[MAX_STRING_LENGTH];
    int i;

    strcpy(sb,"");

    for (i = 0; tokens[i + 1]; i++)
d54 3
a56 3
	strcat(sb,tokens[i]);

	switch (type[i])
d59 8
a66 8
	    if (!otokens[i])
		strcat(sb,"someone");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,PERS((char_data *)otokens[i], ch));
	    break;

d68 5
a72 5
	    if (!otokens[i])
		strcat(sb,"someone's");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"your");
	    else
d74 2
a75 2
		strcat(sb,PERS((char_data *) otokens[i], ch));
		strcat(sb,"'s");
d77 2
a78 2
	    break;

d80 8
a87 8
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"its");
	    else if (otokens[i] == ch)
		strcat(sb,"your");
	    else
		strcat(sb,HSHR((char_data *) otokens[i]));
	    break;
		
d89 8
a96 8
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HSSH((char_data *) otokens[i]));
	    break;
	    
d98 8
a105 8
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HMHR((char_data *) otokens[i]));
	    break;

d107 5
a111 5
	    if (!otokens[i])
		strcat(sb,"something");
	    else
		strcat(sb,OBJS(((obj_data *) otokens[i]), ch));
	    break;
d114 5
a118 5

    strcat(sb,tokens[i]);
    strcat(sb,"\n\r");
    sb[0] = toupper(sb[0]);
    send_to_char(sb,ch);
d124 15
a138 15
    char str[MAX_INPUT_LENGTH * 2];
    char type[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
    char *tokens[MAX_INPUT_LENGTH], *s, *p;
    void *otokens[MAX_INPUT_LENGTH];
    char_data *to;
    obj_data *obj;
    int i, tmp;
    int sleep = 1; /* mainly for windows compiles */

    if (!arg)
	return;
    
    tokens[0] = str;
    
    for (i = 0, p = arg, s = str; *p;)
d140 40
a179 40
	switch (*p) {
	case '~':
	case '@@':
	case '^':
	case '>':
	case '*':
	    /* get char_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (char_data *)otokens[i] =
		find_invis ? get_char(name) : get_char_room_vis(ch, name);
	    tokens[++i] = ++s;
	    break;
	    
	case '`':
	    /* get obj_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (obj_data *)otokens[i] =
		find_invis ? (obj = get_obj(name)) :
		    ((obj = get_obj_in_list_vis(ch, name,
				world[IN_ROOM(ch)].contents)) ? obj :
		     (obj = get_object_in_equip_vis(ch, name,
						    ch->equipment, &tmp)) ?
		     obj :
		     (obj = get_obj_in_list_vis(ch, name, ch->carrying)));
	    (obj_data *)otokens[i] = obj;
	    tokens[++i] = ++s;
	    break;

	case '\\':
	    p++;
	    *s++ = *p++;
	    break;
	    
	default:
	    *s++ = *p++;
	}
d181 12
a192 12

    *s = '\0';
    tokens[++i] = NULL;

    if (IS_SET(targets, TO_CHAR) && SENDOK(ch))
	sub_write_to_char(ch, tokens, otokens, type);

    if (IS_SET(targets, TO_ROOM))
	for (to = world[ch->in_room].people;
	     to; to = to->next_in_room)
	    if (to != ch && SENDOK(to))
		sub_write_to_char(to, tokens, otokens, type);
@
