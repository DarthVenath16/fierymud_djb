head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2011.08.18.00.13.14;	author myc;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.09.05.39.07;	author myc;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.12.04.44.30;	author myc;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	;


desc
@Brand new text editor to replace functionality of old one.
@


1.5
log
@Fix compiler warnings.
@
text
@/***************************************************************************
 * $Id: editor.c,v 1.4 2009/06/09 05:39:07 myc Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: editor.c                                       Part of FieryMUD *
 *  Usage: Routines for the string editor                                  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

/*
 * TODO:
 *   a flag to make default_list escape color characters
 */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "editor.h"
#include "math.h"
#include "interpreter.h"
#include "modify.h"
#include "screen.h"
#include "events.h"

static struct {
  char command;
  EDITOR_FUNC(*default_callback);
} command_types[NUM_ED_COMMAND_TYPES] = {
  { '\0', editor_default_begin,       },
  { 'c',  editor_default_clear,       },
  { 'f',  editor_default_format,      },
  { 'i',  editor_default_insert_line, },
  { 'e',  editor_default_edit_line,   },
  { 'r',  editor_default_replace,     },
  { 'd',  editor_default_delete_line, },
  { 'h',  editor_default_help,        },
  { 'l',  editor_default_list,        },
  { 'n',  editor_default_list,        },
  { 's',  editor_default_exit,        },
  { 'a',  editor_default_exit,        },
  { 'k',  editor_default_spellcheck,  },
  { '\0', editor_default_other,       },
};

/*
 * Although struct editor_data is referenced from structs.h,
 * because it is only a pointer, we can locally define the
 * struct here, which makes it private to editor.c.  This
 * prevents code in other modules from modifying anything
 * in the editor.  But don't add code to editor.c just to
 * access this struct.  Add proper methods, and make sure
 * what you want to do can't be done with the existing hooks.
 */
struct editor_data {
  bool started;
  char *string;
  char **destination;
  char *begin_string;
  size_t length;
  size_t max_length;
  size_t lines;
  size_t max_lines;
  void *data;
  enum ed_cleanup_action cleanup_action;

  EDITOR_FUNC(*action[NUM_ED_COMMAND_TYPES]);
};


static struct editor_context *create_context(struct descriptor_data *d, enum ed_command_type command, const char *argument);
static struct descriptor_data *consume_context(struct editor_context *c);
static void editor_action(struct descriptor_data *d, enum ed_command_type command, char *argument);
static void editor_append(struct descriptor_data *d, char *line);
static bool editor_format_text(char **string, int indent, size_t max_length, int first_line, int last_line);
static int editor_replace_string(char **string, char *pattern, char *replacement, bool replace_all, size_t max_length);
static size_t limit_lines(char *string, size_t max_lines);
static EVENTFUNC(editor_start);

extern void ispell_check(struct descriptor_data *d, const char *word);


const struct descriptor_data *editor_edited_by(char **message)
{
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next)
    if (d->editor && d->editor->destination == message)
      return d;

  return NULL;
}


void editor_init(struct descriptor_data *d, char **string, size_t max_length)
{
  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_init");
    return;
  }

  if (max_length < 1) {
    log("SYSERR: invalid max_length %d passed to editor_init", max_length);
    return;
  }

  if (EDITING(d)) {
    log("SYSERR: editor_init called on descriptor editing string: forcing abort");
    editor_cleanup(d);
  }

  CREATE(d->editor, struct editor_data, 1);

  d->editor->started = FALSE;
  d->editor->string = (string && *string && **string) ? strdup(*string) : NULL;
  d->editor->destination = string;
  d->editor->begin_string = NULL;
  d->editor->max_length = max_length;
  d->editor->max_lines = 9999;
  d->editor->data = NULL;
  d->editor->cleanup_action = ED_NO_ACTION;

  event_create(EVENT_EDITOR_START, editor_start, d, FALSE, NULL, 0);
}


EVENTFUNC(editor_start)
{
  struct descriptor_data *d = (struct descriptor_data *) event_obj;

  if (!d)
    log("SYSERR: NULL descriptor passed to editor_start");
  else if (!EDITING(d))
    log("SYSERR: Editor not initialized on descriptor passed to editor_start");
  else if (d->editor->started)
    log("SYSERR: Editor already started on descriptor passed to editor_start");
  else {
    if (!d->editor->action[ED_FORMAT] && d->editor->max_length > MAX_STRING_LENGTH)
      log("WARNING: editor_start: editor max_length is %d > MAX_STRING_LENGTH;"
          " format command disabled", d->editor->max_length);
    d->editor->started = TRUE;
    if (d->editor->string) {
      d->editor->lines = limit_lines(d->editor->string, d->editor->max_lines);
      d->editor->length = strlen(d->editor->string);
    }
    if (d->editor->length > d->editor->max_length) {
      d->editor->string[d->editor->length - 1] = '\0';
      d->editor->length = d->editor->max_length;
    }
    editor_action(d, ED_BEGIN, NULL);
  }

  return EVENT_FINISHED;
}


void editor_set_callback_data(struct descriptor_data *d, void *data, enum ed_cleanup_action action)
{
  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_set_callback_data");
    return;
  }

  if (!EDITING(d)) {
    log("SYSERR: Editor not initialized on descriptor passed to editor_set_callback_data");
    return;
  }

  d->editor->data = data;
  d->editor->cleanup_action = action;
}


void editor_set_callback(struct descriptor_data *d, enum ed_command_type type, EDITOR_FUNC(*callback))
{
  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_set_callback");
    return;
  }

  if (type >= NUM_ED_COMMAND_TYPES) {
    log("SYSERR: Invalid editor command type %d passed to editor_set_callback", type);
    return;
  }

  if (!EDITING(d)) {
    log("SYSERR: Editor not initialized on descriptor passed to editor_set_callback");
    return;
  }

  d->editor->action[type] = callback;
}


void editor_set_max_lines(struct descriptor_data *d, size_t max_lines)
{
  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_set_max_lines");
    return;
  }

  if (!EDITING(d)) {
    log("SYSERR: Editor not initialized on descriptor passed to editor_set_max_lines");
    return;
  }

  if (max_lines <= 0) {
    log("SYSERR: Invalid maximum number of lines %d specified in editor_set_max_lines", max_lines);
    return;
  }

  d->editor->max_lines = max_lines;
}


void editor_set_begin_string(struct descriptor_data *d, char *string, ...)
{
  va_list args;
  char buf[MAX_STRING_LENGTH];

  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_set_begin_string");
    return;
  }

  if (!EDITING(d)) {
    log("SYSERR: Editor not initialized on descriptor passed to editor_set_begin_string");
    return;
  }

  if (!string) {
    log("SYSERR: NULL string passed to editor_set_begin_string");
    return;
  }

  va_start(args, string);
  vsnprintf(buf, sizeof(buf), string, args);
  va_end(args);

  d->editor->begin_string = strdup(buf);
}


static struct editor_context *create_context(struct descriptor_data *d, enum ed_command_type command, const char *argument)
{
  struct editor_context *context;

  CREATE(context, struct editor_context, 1);
  context->descriptor = d;
  context->string     = d->editor->string;
  context->max_length = d->editor->max_length;
  context->data       = d->editor->data;
  context->command    = command;
  context->argument   = argument;

  return context;
}


static struct descriptor_data *consume_context(struct editor_context *c)
{
  struct descriptor_data *d = c->descriptor;

  if ((d->editor->string = c->string)) {
    d->editor->length = strlen(d->editor->string);
    if (d->editor->length >= d->editor->max_length)
      d->editor->string[d->editor->max_length - 1] = '\0';
    d->editor->lines = limit_lines(d->editor->string, d->editor->max_lines);
  }
  else
    d->editor->lines = d->editor->length = 0;

  d->editor->data = c->data;

  free(c);

  return d;
}


static void editor_action(struct descriptor_data *d, enum ed_command_type command, char *argument)
{
  struct editor_context *context;

  if (command >= NUM_ED_COMMAND_TYPES)
    command = ED_OTHER;
  if (!argument)
    argument = "";

  context = create_context(d, command, argument);
  if (d->editor->action[command]) {
    if ((d->editor->action[command])(context) == ED_IGNORED)
      (command_types[command].default_callback)(context);
  }
  else
    (command_types[command].default_callback)(context);
  consume_context(context);

  if (command == ED_EXIT_SAVE || command == ED_EXIT_ABORT)
    editor_cleanup(d);
}


void editor_interpreter(struct descriptor_data *d, char *line)
{
  char *argument = line;
  size_t i;

  if (!EDITING(d)) {
    log("SYSERR: editor_interpreter invoked on descriptor without allocated editor member");
    return;
  }

  delete_doubledollar(line);
  smash_tilde(line);
  skip_spaces(&argument);

  if (!d->editor->started)
    editor_action(d, ED_BEGIN, NULL);

  /* If the line doesn't start with a /, it's not a command: append it */
  if (*argument != ED_CMD_CHAR)
    editor_append(d, line);

  /* Find the correct command to execute */
  else if (*(++argument)) {
    for (i = 0; i < NUM_ED_COMMAND_TYPES; ++i)
      if (*argument == command_types[i].command) {
        editor_action(d, i, argument + 1);
        break;
      }
    /* editor action not found above */
    if (i == NUM_ED_COMMAND_TYPES)
      editor_action(d, ED_OTHER, argument);
  }

}


static void editor_append(struct descriptor_data *d, char *line)
{
  size_t line_length = strlen(line) + 2; /* +2 for \r\n */
  size_t space_left = d->editor->max_length - d->editor->length;
  size_t new_length = d->editor->length + line_length;
  char *orig_string;
  char *new_string;

  if (d->editor->lines >= d->editor->max_lines) {
    dprintf(d, "Too many lines - Input ignored.  Max lines: %u lines.\r\n",
            d->editor->max_lines);
    return;
  }

  if (line_length >= space_left) {
    /* Shorter than 3?  To short for even a newline.  Ignore line. */
    if (space_left <= 3) {
      dprintf(d, "String too long - Input ignored.  Max length: %u characters.\r\n",
              d->editor->max_length);
      return;
    }
    dprintf(d, "String too long - Input truncated.  Max length: %u characters.\r\n",
            d->editor->max_length);
    new_length = d->editor->max_length - 1;
  }

  orig_string = d->editor->string;
  CREATE(new_string, char, new_length + 1);
  if (orig_string)
    strcpy(new_string, orig_string);
  if (line_length >= space_left) {
    line_length = space_left - 1;
    line[line_length + 2] = '\0';
  }
  strcpy(new_string + d->editor->length, line);
  strcpy(new_string + d->editor->length + line_length - 2, "\r\n");
  if (orig_string)
    free(orig_string);
  d->editor->length += line_length;
  d->editor->string = new_string;
  d->editor->lines++;
}


void editor_cleanup(struct descriptor_data *d)
{
  if (!d) {
    log("SYSERR: NULL descriptor passed to editor_set_other_handler");
    return;
  }

  if (!EDITING(d)) {
    log("SYSERR: Editor not initialized on descriptor passed to editor_cleanup");
    return;
  }

  if (d->editor->string)
    free(d->editor->string);

  if (d->editor->begin_string)
    free(d->editor->begin_string);

  if (d->editor->cleanup_action == ED_FREE_DATA)
    free(d->editor->data);

  free(d->editor);
  d->editor = NULL;
}


EDITOR_FUNC(editor_default_begin)
{
  dprintf(edit->descriptor, "%s  (/s saves, /h for help)\r\n",
          edit->descriptor->editor->begin_string ?
          edit->descriptor->editor->begin_string :
          "Write your message.");

  editor_action(edit->descriptor, ED_LIST, NULL);

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_clear)
{
  if (edit->string) {
    free(edit->string);
    edit->string = NULL;
    dprintf(edit->descriptor, "Current buffer cleared.\r\n");
  }
  else
    dprintf(edit->descriptor, "Current buffer empty.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_format)
{
  int indent = 0;
  int first_line, last_line;

  if (!edit->string) {
    dprintf(edit->descriptor, "Current buffer empty.\r\n");
    return ED_PROCESSED;
  }

  /* Does the user want it indented? */
  if (*edit->argument == 'i') {
    ++edit->argument;
    indent = 3;
  }

  /* Does the user want only a portion formatted? */
  switch (sscanf(edit->argument, " %d %d", &first_line, &last_line)) {
  case -1:
  case 0:  /* user didn't specify any numbers */
    first_line = 1;
    last_line = 999999;
    break;
  case 1:  /* user specified one number */
    last_line = first_line;
    break;
  case 2:  /* user specified two numbers */
    if (last_line < first_line) {
      dprintf(edit->descriptor, "That range is invalid.\r\n");
      return ED_PROCESSED;
    }
    break;
  }
  first_line = MAX(1, first_line);

  if (editor_format_text(&edit->string, indent, edit->max_length,
                         first_line, last_line))
    dprintf(edit->descriptor, "Text formatted with%s indent.\r\n", indent ? "" : "out");
  else
    dprintf(edit->descriptor, "Text format failed.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_help)
{
  dprintf(edit->descriptor,
          "Editor command formats: /<letter>\r\n\r\n"
          "/a          -  abort editor\r\n"
          "/c          -  clear buffer\r\n"
          "/d#         -  delete line #\r\n"
          "/e# <text>  -  change the line at # with <text>\r\n"
          "/f          -  format entire text\r\n"
          "/fi         -  indented formatting of text\r\n"
          "/h          -  list text editor commands\r\n"
          "/k <word>   -  spellcheck word\r\n"
          "/i# <text>  -  insert <text> at line #\r\n");
  dprintf(edit->descriptor,
          "/l          -  list entire buffer\r\n"
          "/n          -  list entire buffer with line numbers\r\n"
          "/r <a> <b>  -  replace 1st occurrence of text <a> in buffer with text <b>\r\n"
          "/ra <a> <b> -  replace all occurrences of text <a> within buffer with text <b>\r\n"
          "               usage: /r[a] pattern replacement\r\n"
          "                      /r[a] 'pattern' 'replacement'\r\n"
          "                      (enclose in single quotes for multi-word phrases)\r\n"
          "/s          -  save text\r\n");
  dprintf(edit->descriptor,
          "\r\n"
          "Note: /d, /f, /fi, /l, and /n also accept ranges of lines.  For instance:\r\n"
          "   /d 2 5   -  delete lines 2 through 5\r\n"
          "   /fi3 6   -  format lines 3 through 6 with indent\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_insert_line)
{
  char *str, temp, *start;
  int line, insert_line;
  size_t final_length;
  struct descriptor_data *d = edit->descriptor;
  const char *argument = edit->argument;

  if (!edit->string) {
    dprintf(d, "Current buffer empty; nowhere to insert.\r\n");
    return ED_PROCESSED;
  }

  /* Skip spaces; can't use skip_spaces since argument is const */
  while (*argument && isspace(*argument))
    ++argument;

  if (!isdigit(*argument)) {
    dprintf(d, "Specify a line number at which to insert.\r\n");
    return ED_PROCESSED;
  }

  insert_line = atoi(argument);

  if (insert_line <= 0) {
    dprintf(d, "Line number must be higher than 0.\r\n");
    return ED_PROCESSED;
  }

  /* Skip over value */
  while (*argument && !isspace(*argument))
    ++argument;
  if (isspace(*argument))
    ++argument; /* skip the first space */
  /* argument now points to what we want to insert */

  final_length = strlen(edit->string) + strlen(argument) + 2;
  if (final_length > edit->max_length) {
    dprintf(d, "Insert text pushes buffer over maximum size, insert aborted.\r\n");
    return ED_PROCESSED;
  }

  line = 1;
  str = edit->string;

  while (str && line < insert_line)
    if ((str = strchr(str, '\n'))) {
      ++line;
      ++str;
    }

  if (line < insert_line || !str || !*str) {
    dprintf(d, "Line number out of range; insert aborted.\r\n");
    return ED_PROCESSED;
  }

  start = edit->string;
  CREATE(edit->string, char, final_length + 1);
  str_start(edit->string, final_length + 1);

  temp = *str;
  *str = '\0';
  str_cat(edit->string, start);
  *str = temp;

  str_cat(edit->string, argument);
  str_cat(edit->string, "\r\n");

  str_cat(edit->string, str);

  free(start);
  dprintf(d, "Line inserted.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_edit_line)
{
  char *str, *start, *cut, *cont;
  int line, edit_line;
  size_t final_length;
  struct descriptor_data *d = edit->descriptor;
  const char *argument = edit->argument;

  if (!edit->string) {
    dprintf(d, "Specify a line number at which to insert.\r\n");
    return ED_PROCESSED;
  }

  edit_line = atoi(argument);

  if (edit_line <= 0) {
    dprintf(d, "Line number must be higher than 0.\r\n");
    return ED_PROCESSED;
  }

  /* Skip over line number */
  while (*argument && !isspace(*argument))
    ++argument;
  if (isspace(*argument))
    ++argument; /* skip the first space */
  /* argument now points to what we want to insert */

  line = 1;
  str = edit->string;

  while (str && line < edit_line)
    if ((str = strchr(str, '\n'))) {
      ++line;
      ++str;
    }  

  start = edit->string;
  cut = str;
  if (str)
    str = strchr(str, '\n');

  if (line < edit_line || !cut || !str) {
    dprintf(d, "Line number out of range; line replacement aborted.\r\n");
    return ED_PROCESSED;
  }

  *cut = '\0';
  *str = '\0';
  cont = str + 1;
  final_length = strlen(start) + strlen(argument) + 3 + strlen(cont);

  CREATE(edit->string, char, final_length);
  str_start(edit->string, final_length);
  str_cat(edit->string, start);
  str_cat(edit->string, argument);
  str_cat(edit->string, "\r\n");
  str_cat(edit->string, cont);

  free(start);
  dprintf(d, "Line replaced.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_replace)
{
  bool replace_all = FALSE;
  char arg[MAX_INPUT_LENGTH], search[MAX_INPUT_LENGTH],
       replace[MAX_INPUT_LENGTH], *argument;
  int replaced;

  if (!edit->string) {
    dprintf(edit->descriptor, "Current buffer empty.\r\n");
    return ED_PROCESSED;
  }

  strcpy(arg, edit->argument);
  argument = arg;

  /* Does the user want it indented? */
  if (*argument == 'a') {
    ++argument;
    replace_all = TRUE;
  }

  argument = delimited_arg_case(argument, search, '\'');
  if (!*search) {
    dprintf(edit->descriptor, "No target search string.\r\n");
    return ED_PROCESSED;
  }

  argument = delimited_arg_case(argument, replace, '\'');
  if (!*replace) {
    dprintf(edit->descriptor, "No replacement string.\r\n");
    return ED_PROCESSED;
  }

  skip_spaces(&argument);
  if (*argument) {
    dprintf(edit->descriptor, "Invalid search format.  Enclose search/replacement strings in single quotes.\r\n");
    return ED_PROCESSED;
  }

  replaced = editor_replace_string(&edit->string, search, replace, 
                                   replace_all, edit->max_length);
  if (replaced > 0)
    dprintf(edit->descriptor, "Replaced %d occurance%s of '%s' with '%s'.\r\n",
            replaced, replaced == 1 ? "" : "s", search, replace);
  else if (replaced == 0)
    dprintf(edit->descriptor, "String '%s' not found.\r\n", search);
  else
    dprintf(edit->descriptor, "Replacement string causes buffer overflow: aborted replace.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_delete_line)
{
  int first_line, last_line, line = 1, total_len = 1;
  struct descriptor_data *d = edit->descriptor;
  char *start, *str;

  if (!(str = edit->string)) {
    dprintf(edit->descriptor, "Current buffer empty.\r\n");
    return ED_PROCESSED;
  }

  switch (sscanf(edit->argument, " %d %d", &first_line, &last_line)) {
  case 2:
    break;
  case 1:
    last_line = first_line;
    break;
  default:
    first_line = 1;
    last_line = 99999;
    break;
  }

  if (first_line < 1) {
    dprintf(d, "Line numbers must be greater than 0.\r\n");
    return ED_PROCESSED;
  }
  else if (last_line < first_line) {
    dprintf(d, "That line range is invalid.\r\n");
    return ED_PROCESSED;
  }

  while (str && line < first_line)
    if ((str = strchr(str, '\n'))) {
      ++line;
      ++str;
    }
  if (!str || !*str || line < first_line) {
    dprintf(d, "Line(s) out of range; not deleting.\r\n");
    return ED_PROCESSED;
  }
  start = str;
  while (str && line < last_line)
    if ((str = strchr(str, '\n'))) {
      ++line;
      ++total_len;
      ++str;
    }
  if (str && (str = strchr(str, '\n'))) {
    while (*(++str))
      *(start++) = *str;
  }
  else
    --total_len;
  *start = '\0';
  RECREATE(edit->string, char, strlen(edit->string) + 3);

  dprintf(d, "%d line%s deleted.\r\n", total_len, total_len == 1 ? "" : "s");
  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_list)
{
  int first_line, last_line, line, lines;
  struct descriptor_data *d = edit->descriptor;
  bool show_nums = (edit->command == ED_LIST_NUMERIC);
  char *str, *start = NULL, temp;

  if (!(str = edit->string)) {
    dprintf(edit->descriptor, "Current buffer empty.\r\n");
    return ED_PROCESSED;
  }

  switch (sscanf(edit->argument, " %d %d", &first_line, &last_line)) {
  case 2:
    break;
  case 1:
    last_line = first_line;
    break;
  default:
    first_line = 1;
    last_line = 99999;
    break;
  }

  if (first_line < 1) {
    dprintf(d, "Line numbers must be greater than 0.\r\n");
    return ED_PROCESSED;
  }
  else if (last_line < first_line) {
    dprintf(d, "That line range is invalid.\r\n");
    return ED_PROCESSED;
  }

  if (first_line > 1 || last_line < 99999)
    pdprintf(d, "Current buffer range [%d - %d]:\r\n", first_line, last_line);

  line = 1;
  lines = 0;

  while (str && line < first_line)
    if ((str = strchr(str, '\n'))) {
      ++line; /* count line */
      ++str;  /* move past newline */
    }

  if (line < first_line || !str) {
    dprintf(d, "Line%s out of range; no buffer listing.\r\n",
            last_line - first_line ? "(s)" : "");
    return ED_PROCESSED;
  }

  do {
    if (show_nums || !lines)
      start = str;
    str = strchr(str, '\n');
    if (show_nums) {
      if (str) {
        temp = *str;
        *str = '\0';
      }
      pdprintf(d, "%4d: %s\r\n", line, start);
      if (str)
        *str = temp;
    }
    ++line;
    ++lines;
    if (str)
      ++str;
  } while (str && *str && line <= last_line);

  if (start && *start && !show_nums) {
    if (str) {
      temp = *str;
      *str = '\0';
    }
    pdprintf(d, "%s", start);
    if (str)
      *str = temp;
  }

  start_paging_desc(d);

  return ED_PROCESSED;
}


/*
 * Implementations of ED_EXIT_SAVE *must* set edit->string to NULL
 * to prevent editor_cleanup from freeing it.
 */
EDITOR_FUNC(editor_default_exit)
{
  struct descriptor_data *d = edit->descriptor;

  if (edit->command == ED_EXIT_SAVE) {
    if (!d->editor->destination) {
      dprintf(d, "ERROR: No location to save changes to.  Edit aborted.\r\n");
      log("SYSERR: d->editor->destination NULL in save attempt in editor_default_exit");
    }
    else {
      dprintf(d, "Changes saved.\r\n");
      if (*d->editor->destination)
        /* TODO: do we need a flag to say whether to free this or not? */
        free(*d->editor->destination);
      *d->editor->destination = d->editor->string ? d->editor->string :
                                                    strdup("Nothing.\r\n");
      d->editor->string = NULL;
      edit->string = NULL;
    }
  }
  else
    dprintf(d, "Edit aborted.  Changes not saved.\r\n");

  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_other)
{
  dprintf(edit->descriptor, "Invalid option.\r\n");
  return ED_PROCESSED;
}


EDITOR_FUNC(editor_default_spellcheck)
{
  const char *ptr = edit->argument;
  char arg[MAX_INPUT_LENGTH + 1];
  int i = 0;

  /* Grab first word from the argument; ignore '+' */
  while (*ptr && (*ptr == ' ' || *ptr == '+'))
    ++ptr;
  while (*ptr && *ptr != ' ' && i < MAX_INPUT_LENGTH)
    arg[i++] = *(ptr++);
  arg[i] = '\0';

  ispell_check(edit->descriptor, arg);
  return ED_PROCESSED;
}




/*
 * Code from stock TBAMUD.
 */
static bool editor_format_text(char **string, int indent,
                               size_t max_length, int first_line, int last_line)
{
  int line_chars, color_chars = 0, i;
  bool cap_next = TRUE, cap_next_next = FALSE, pass_line = FALSE;
  char *flow, *start = NULL, temp;
  char formatted[MAX_STRING_LENGTH + 16] = "";
  char str[MAX_STRING_LENGTH + 16];

  /* Fix memory overrun. */
  if (max_length > MAX_STRING_LENGTH) {
    log("SYSERR: format_text: max_str is greater than buffer size.");
    return 0;
  }

  /* XXX: Want to make sure the string doesn't grow either... */
  if ((flow = *string) == NULL)
    return 0;

  strcpy(str, flow);

  for (i = 0; i < first_line - 1; i++) {
    start = strtok(str, "\n");
    if (!start)
      return 0;
    strcat(formatted, strcat(start, "\n"));
    flow = strstr(flow, "\n");
    strcpy(str, ++flow);
  }

  if (indent > 0) {
    if (indent > 40) /* arbitrary indentation limit */
      indent = 40;
    line_chars = indent;
    str[indent] = '\0';
    do {
      str[--indent] = ' ';
    } while (indent);
    strcat(formatted, str);
    line_chars = 3;
  }
  else
    line_chars = 0;

  while (*flow && i < last_line) {
    while (*flow && strchr("\n\r\f\t\v ", *flow)) {
      if (*flow == '\n' && !pass_line)
        if (i++ >= last_line) {
          pass_line = 1;
          break;
        }
      flow++;
    }

    if (*flow) {
      start = flow;
      while (*flow && !strchr("\n\r\f\t\v .?!", *flow)) {
        if (*flow == '@@') {
          if (*(flow + 1) == '@@')
            color_chars++;
          else
            color_chars += 2;
          flow++;
        }
        flow++;
      }

      if (cap_next_next) {
        cap_next_next = FALSE;
        cap_next = TRUE;
      }

      /* This is so that if we stopped on a sentence, we move off the sentence
       * delimiter. */
      while (strchr(".!?", *flow)) {
        cap_next_next = TRUE;
        flow++;
      }

      /* Special case: if we're at the end of the last line, and the last
       * character is a delimiter, the flow++ above will have *flow pointing
       * to the \r (or \n) character after the delimiter. Thus *flow will be
       * non-null, and an extra (blank) line might be added erroneously. We
       * fix it by skipping the newline characters in between. - Welcor */
      if (strchr("\n\r", *flow)) {
        *flow = '\0';  /* terminate 'start' string */
        flow++;        /* we know this is safe     */
        if (*flow == '\n' && i++ >= last_line)
          pass_line = 1;

        while (*flow && strchr("\n\r", *flow) && !pass_line) {
          flow++;      /* skip to next non-delimiter */
          if (*flow == '\n' && i++ >= last_line)
            pass_line = 1;
        }
        temp = *flow;  /* save this char             */
      }
      else {
        temp = *flow;
        *flow = '\0';
      }

      if (line_chars + strlen(start) + 1 - color_chars > ED_DEFAULT_PAGE_WIDTH) {
        strcat(formatted, "\r\n");
        line_chars = 0;
        color_chars = count_color_chars(start);
      }

      if (cap_next) {
        cap_next = FALSE;
        CAP(start);
      }
      else if (line_chars > 0) {
        strcat(formatted, " ");
        line_chars++;
      }

      line_chars += strlen(start);
      strcat(formatted, start);

      *flow = temp;
    }

    if (cap_next_next && *flow) {
      if (line_chars + 3 - color_chars > ED_DEFAULT_PAGE_WIDTH) {
        strcat(formatted, "\r\n");
        line_chars = 0;
        color_chars = count_color_chars(start);
      } else if (*flow == '\"' || *flow == '\'') {
        char buf[4];
        sprintf(buf, "%c  ", *flow);
        strcat(formatted, buf);
        flow++;
        line_chars++;
      } else {
        strcat(formatted, "  ");
        line_chars += 2;
      }
    }
  }

  if (*flow)
    strcat(formatted, "\r\n");
  strcat(formatted, flow);
  if (!*flow)
    strcat(formatted, "\r\n");

  if (strlen(formatted) + 1 > max_length) {
    /* Make sure the string is nul- and newline-terminated */
    formatted[max_length - 1] = '\0';
    formatted[max_length - 2] = '\n';
    formatted[max_length - 3] = '\r';
  }
  RECREATE(*string, char, MIN(max_length, strlen(formatted) + 1));
  strcpy(*string, formatted);
  return 1;
}


/*
 * Code from stock TBAMUD.
 */
static int editor_replace_string(char **string, char *pattern, char *replacement, bool replace_all, size_t max_length)
{
  char *replace_buffer = NULL;
  char *flow, *jetsam, temp;
  int len, i;

  if (strlen(*string) - strlen(pattern) + strlen(replacement) > max_length)
    return -1;

  CREATE(replace_buffer, char, max_length);
  i = 0;
  jetsam = *string;
  flow = *string;
  str_start(replace_buffer, max_length);

  if (replace_all) {
    while ((flow = strstr(flow, pattern)) != NULL) {
      ++i;
      temp = *flow;
      *flow = '\0';
      if ((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement)) > max_length) {
        i = -1;
        break;
      }
      str_cat(replace_buffer, jetsam);
      str_cat(replace_buffer, replacement);
      *flow = temp;
      flow += strlen(pattern);
      jetsam = flow;
    }
    str_cat(replace_buffer, jetsam);
  }
  else if ((flow = strstr(*string, pattern)) != NULL) {
    ++i;
    flow += strlen(pattern);
    len = (flow - *string) - strlen(pattern);
    strn_cat(replace_buffer, *string, len);
    str_cat(replace_buffer, replacement);
    str_cat(replace_buffer, flow);
  }

  if (i > 0) {
    RECREATE(*string, char, strlen(replace_buffer) + 3);
    strcpy(*string, replace_buffer);
  }
  free(replace_buffer);
  return i;
}

static size_t limit_lines(char *string, size_t max_lines)
{
  size_t lines = 0;

  if (string) {
    string = strchr(string, '\n');
    while (string) {
      if (++lines == max_lines) {
        *(++string) = '\0';
        break;
      }
      string = strchr(string + 1, '\n');
    }
  }

  return lines;
}

/***************************************************************************
 * $Log: editor.c,v $
 * Revision 1.4  2009/06/09 05:39:07  myc
 * Adding editor_edited_by() to find out if any descriptors are
 * editing a particular string pointer location.  Making the editor
 * handle freeing callback data.
 *
 * Revision 1.3  2009/02/21 03:30:16  myc
 * Modified editor_init to allow starting up with a NULL
 * string/destination.  Fixed editor_action so if a callback
 * returns ED_IGNORED, it automatically calls the default
 * callback.  Tweaked editor_save to allow no destination.
 *
 * Revision 1.2  2009/02/12 04:44:30  myc
 * Added rudimentary spellchecker to text editor; uses ispell.
 *
 * Revision 1.1  2009/02/11 17:03:39  myc
 * Initial revision
 *
 ***************************************************************************/
@


1.4
log
@Adding editor_edited_by() to find out if any descriptors are
editing a particular string pointer location.  Making the editor
handle freeing callback data.
@
text
@d2 1
a2 1
 * $Id: editor.c,v 1.3 2009/02/21 03:30:16 myc Exp myc $
d189 1
a189 1
  if (type < 0 || type >= NUM_ED_COMMAND_TYPES) {
d293 1
a293 1
  if (command < 0 || command >= NUM_ED_COMMAND_TYPES)
d1139 1
a1139 1
  int lines = 0;
d1157 5
@


1.3
log
@Modified editor_init to allow starting up with a NULL
string/destination.  Fixed editor_action so if a callback
returns ED_IGNORED, it automatically calls the default
callback.  Tweaked editor_save to allow no destination.
@
text
@d2 1
a2 1
 * $Id: editor.c,v 1.2 2009/02/12 04:44:30 myc Exp myc $
d73 1
d91 12
d122 1
d125 1
d128 2
a129 1
  d->editor->started = FALSE;
d150 8
d165 1
a165 1
void editor_set_callback_data(struct descriptor_data *d, void *data)
d178 1
d410 3
d1157 6
@


1.2
log
@Added rudimentary spellchecker to text editor; uses ispell.
@
text
@d2 1
a2 1
 * $Id: editor.c,v 1.1 2009/02/11 17:03:39 myc Exp myc $
a96 5
  if (!string) {
    log("SYSERR: NULL string location passed to editor_init");
    return;
  }

d109 1
a109 1
  d->editor->string = (*string && **string) ? strdup(*string) : NULL;
d274 4
a277 2
  if (d->editor->action[command])
    (d->editor->action[command])(context);
d837 4
d846 14
a859 8
    dprintf(d, "Changes saved.\r\n");
    if (*d->editor->destination)
      /* TODO: do we need a flag to say whether to free this or not? */
      free(*d->editor->destination);
    *d->editor->destination = d->editor->string ? d->editor->string :
                                                  strdup("Nothing.\r\n");
    d->editor->string = NULL;
    edit->string = NULL;
d1129 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: editor.c,v $
d50 1
d54 23
d87 2
d476 1
d868 18
d1122 3
@
