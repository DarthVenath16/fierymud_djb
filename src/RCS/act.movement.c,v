head	1.173;
access;
symbols;
locks; strict;
comment	@ * @;


1.173
date	2011.03.16.13.39.58;	author myc;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.05.04.43.57;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2009.07.18.01.17.23;	author myc;	state Exp;
branches;
next	1.170;

1.170
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2009.03.09.02.22.32;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.166;

1.166
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.165;

1.165
date	2009.03.07.09.34.47;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2009.03.03.19.41.50;	author myc;	state Exp;
branches;
next	1.163;

1.163
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2008.12.03.03.14.16;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2008.09.21.21.04.20;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2008.09.20.17.38.00;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2008.09.20.08.00.09;	author jps;	state Exp;
branches;
next	1.158;

1.158
date	2008.09.20.07.58.01;	author jps;	state Exp;
branches;
next	1.157;

1.157
date	2008.09.13.17.20.55;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.09.11.04.22.04;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.154;

1.154
date	2008.09.07.01.27.15;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.09.04.06.47.36;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2008.09.02.07.16.00;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.09.01.08.35.04;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2008.08.30.22.02.42;	author myc;	state Exp;
branches;
next	1.148;

1.148
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.08.28.23.42.53;	author rbr;	state Exp;
branches;
next	1.146;

1.146
date	2008.08.19.02.11.14;	author jps;	state Exp;
branches;
next	1.145;

1.145
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.17.20.24.31;	author jps;	state Exp;
branches;
next	1.143;

1.143
date	2008.08.09.20.35.57;	author jps;	state Exp;
branches;
next	1.142;

1.142
date	2008.07.10.21.23.54;	author jps;	state Exp;
branches;
next	1.141;

1.141
date	2008.06.09.23.00.13;	author myc;	state Exp;
branches;
next	1.140;

1.140
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.139;

1.139
date	2008.05.19.06.53.45;	author jps;	state Exp;
branches;
next	1.138;

1.138
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.137;

1.137
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.134;

1.134
date	2008.05.14.05.11.28;	author jps;	state Exp;
branches;
next	1.133;

1.133
date	2008.05.11.05.43.26;	author jps;	state Exp;
branches;
next	1.132;

1.132
date	2008.04.19.22.43.09;	author jps;	state Exp;
branches;
next	1.131;

1.131
date	2008.04.14.05.11.40;	author jps;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.14.02.18.45;	author jps;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.14.01.26.18;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2008.04.13.21.56.22;	author jps;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.13.20.07.25;	author jps;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.13.01.09.51;	author jps;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.07.17.22.12;	author jps;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.07.15.35.47;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2008.04.07.04.54.55;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2008.04.07.03.02.37;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2008.04.06.19.48.19;	author jps;	state Exp;
branches;
next	1.120;

1.120
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2008.04.03.02.05.34;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.116;

1.116
date	2008.03.09.18.16.08;	author jps;	state Exp;
branches;
next	1.115;

1.115
date	2008.03.08.23.31.22;	author jps;	state Exp;
branches;
next	1.114;

1.114
date	2008.03.08.23.28.44;	author jps;	state Exp;
branches;
next	1.113;

1.113
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.112;

1.112
date	2008.02.07.01.46.14;	author myc;	state Exp;
branches;
next	1.111;

1.111
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.110;

1.110
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.109;

1.109
date	2008.01.30.19.20.57;	author myc;	state Exp;
branches;
next	1.108;

1.108
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.26.12.30.01;	author jps;	state Exp;
branches;
next	1.105;

1.105
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.104;

1.104
date	2008.01.24.15.43.47;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2008.01.15.03.18.19;	author myc;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.11.03.35.36;	author myc;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.11.02.06.07;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.09.10.08.48;	author jps;	state Exp;
branches;
next	1.98;

1.98
date	2008.01.07.11.56.31;	author jps;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.96;

1.96
date	2008.01.01.03.20.19;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2007.12.08.21.02.45;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.24.20.57.29;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.24.01.21.25;	author jps;	state Exp;
branches;
next	1.92;

1.92
date	2007.10.20.19.01.48;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.28.20.49.35;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.12.22.23.04;	author myc;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.11.19.41.07;	author myc;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.11.16.34.24;	author myc;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.08.22.03.19;	author jps;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.03.21.20.46;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2007.08.31.05.36.19;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.20.00.41.16;	author jps;	state Exp;
branches;
next	1.77;

1.77
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.75;

1.75
date	2007.08.05.01.50.16;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2007.08.04.22.20.38;	author jps;	state Exp;
branches;
next	1.73;

1.73
date	2007.08.04.02.13.27;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.04.02.10.57;	author myc;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.01.02.10.39;	author jps;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.14.04.17.35;	author jps;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.14.02.16.22;	author jps;	state Exp;
branches;
next	1.67;

1.67
date	2007.07.14.01.42.58;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.28.23.51.35;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.25.06.41.27;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.08.01.30.00;	author myc;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.21.20.15.01;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.20.19.52.04;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.18.07.17.16;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2006.11.14.23.24.39;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.14.22.38.04;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.13.14.57.54;	author jps;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.13.13.32.25;	author jps;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.12.02.31.01;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.08.08.51.58;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.08.08.36.54;	author jps;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.08.08.16.14;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.07.16.53.29;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.20.07.42.36;	author cjd;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.12.00.12.52;	author rls;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.29.01.56.31;	author rls;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.28.18.08.25;	author rls;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.01.05.18.24;	author jjl;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.01.05.17.05;	author jjl;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.04.22.10.55;	author jjl;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.20.13.17.47;	author rls;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.02.01.33.17;	author jjl;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.28.21.56.42;	author jjl;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.30.19.44.06;	author jjl;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.22.19.33.05;	author jjl;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.17.17.04.37;	author rls;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.16.19.38.44;	author rls;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.16.19.29.35;	author rls;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.13.23.30.07;	author dce;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.11.02.47.57;	author dce;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.16.00.13.58;	author rjd;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.11.07.19.25;	author rjd;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.07.14.14.30;	author dce;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.04.15.11.33;	author dce;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.23.23.48.26;	author dce;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.28.00.42.15;	author mtp;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.20.03.43.03;	author rsd;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.19.21.37.17;	author rsd;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.18.01.32.48;	author rsd;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.07.01.54.32;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.05.18.43.56;	author rsd;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.05.00.21.06;	author rsd;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.31.21.54.14;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.22.22.25.46;	author rsd;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.21.00.56.44;	author rsd;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.17.00.49.58;	author rsd;	state Exp;
branches;
next	1.13;

1.13
date	99.12.06.20.19.59;	author cso;	state Exp;
branches;
next	1.12;

1.12
date	99.11.28.22.35.18;	author cso;	state Exp;
branches;
next	1.11;

1.11
date	99.09.08.07.06.03;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.9;

1.9
date	99.09.03.23.05.48;	author mtp;	state Exp;
branches;
next	1.8;

1.8
date	99.07.25.04.33.11;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	99.04.07.01.20.18;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.03.14.14.28.11;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.03.14.03.18.02;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.03.12.18.05.43;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.02.20.18.41.36;	author dce;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.30;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
 *   File: act.movement.c                                Part of CircleMUD *
 *  Usage: movement commands, door handling, & sleep/rest/etc state        *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "dg_scripts.h"
#include "weather.h"

/* external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *obj_index;
extern int rev_dir[];
extern char *dirs[];
extern int movement_loss[];
extern const struct str_app_type str_app[];

/* external functs */
int special(struct char_data *ch, int cmd, char *arg);
void death_cry(struct char_data *ch);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void dismount_char(struct char_data * ch);
void mount_char(struct char_data *ch, struct char_data *mount);
void improve_skill(struct char_data *ch, int skill);
bool is_aggr_to(struct char_data *ch,struct char_data *target);
bool statsave(struct char_data *ch, int stat, int mod);
void mprog_greet_trigger(struct char_data * ch);
void mprog_entry_trigger(struct char_data * mob);
void justice_trigger(struct char_data *tch);


/* simple function to determine if char can walk on water */
int has_boat(struct char_data *ch)
{
  struct obj_data *obj;
  int i;

  if (IS_AFFECTED(ch, AFF_WATERWALK))
    return 1;

  /* non-wearable boats in inventory will do it */
  for (obj = ch->carrying; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == ITEM_BOAT && (find_eq_pos(ch, obj, NULL) < 0))
      return 1;

  /* and any boat you're wearing will do it too */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_BOAT)
      return 1;

  return 0;
}



/* do_simple_move assumes
 *    1. That there is no master and no followers.
 *    2. That the direction exists.
 *
 *   Returns :
 *   1 : If succes.
 *   0 : If fail
 */

#define BLOOD_DROP_OBJ     34   /* the vnum of the blood object */
#define BLOOD_POOL_OBJ     35   /* the vnum of the blood object */

/*Buru coded blood trail, and this fucntion was getting sludgy,
  with all the new stuff, I redid most making it so can take into
  account gods and sense life with sneak amd outdoor sneak*/
int do_simple_move(struct char_data *ch, int dir, int need_specials_check)
{
  int same_room = 0, riding = 0, ridden_by = 0, flying = 0;
  int was_in, need_movement;
  int vnum;
  struct obj_data *bloodp, *bloodd, *i, *obj;
  struct extra_descr_data *new_descr;
  char mmsg[MAX_STRING_LENGTH];
  char tmp[MAX_STRING_LENGTH];
  struct char_data *people;
  int special(struct char_data *ch, int cmd, char *arg);

  /*
   * Check for special routines (North is 1 in command list, but 0 here) Note
   * -- only check if following; this avoids 'double spec-proc' bug
   */
  if (need_specials_check && special(ch, dir + 1, ""))
    return 0;

  /*dont allow people in God rooms*/
  if (GET_LEVEL(ch) < LVL_IMMORT)
    if (ch->master)
      {
	if (GET_LEVEL(ch->master) < LVL_IMMORT)
	  {
	    if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
	      {
		send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
		return 0;
	      }
	  }else
	    {
	      if ((ch->master->in_room) != (EXIT(ch, dir)->to_room))
		{
		  if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
		    {
		      send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
		      return 0;
		    }
		}
	    }
      }
    else
      {
	if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
	  {
	    send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
	    return 0;
	  }
      }

  if (GET_POS(ch) == POS_FLYING)  flying = 1;
  /* Mounted?*/
  if (RIDING(ch))    riding = 1;
  if (RIDDEN_BY(ch)) ridden_by = 1;

  /*  This allows mounts/mountee's to fly if either are flying */

  if (riding && IS_AFFECTED(RIDING(ch), AFF_FLYING))  flying = 1;
  if (ridden_by && IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING))  flying = 1;



  /* if they're mounted, are they in the same room w/ their mount(ee)?*/
  if (riding && RIDING(ch)->in_room == ch->in_room)
    same_room = 1;
  else if (ridden_by && RIDDEN_BY(ch)->in_room == ch->in_room)
    same_room = 1;

  /* Tamed?*/
  if (ridden_by && same_room && AFF_FLAGGED(ch, AFF_TAMED)) {
    send_to_char("You've been tamed.  Now act it!\r\n", ch);
    return 0;
  }
  /* if load 90% and over, bite the dust. Nechtrous */
  if(!riding && !flying && CURRENT_LOAD(ch) >= 9) {
    act("You stagger about, then fall under your heavy load.",FALSE,ch,0,0,TO_CHAR);
    act("$n staggers about, then collapses under $s heavy load.",TRUE,ch,0,0,TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    GET_POS1(ch) = POS1_RESTING;
    return 0;
  }

  /* charmed?*/
  if (IS_AFFECTED(ch, AFF_CHARM) && ch->master && ch->in_room == ch->master->in_room) {
    send_to_char("The thought of leaving your master makes you weep.\r\n", ch);
    return 0;
  }

  /* check for a wall in room */
  for(obj = world[ch->in_room].contents;obj;obj = obj->next_content) {
    if(GET_OBJ_TYPE(obj) == ITEM_WALL && GET_OBJ_VAL(obj,0) == dir){
      act("Oof. You bump into $p.",FALSE,ch,obj,0,TO_CHAR);
      act("$n bumps into $p.",FALSE,ch,obj,0,TO_ROOM);
      return 0;
    }
  }

  /* if this room or the one we're going to needs a boat, check for one */
  if ((SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_WATER_NOSWIM)) {

    if ((riding && !has_boat(RIDING(ch))) || !has_boat(ch) || !flying) {
      send_to_char("You need a boat to go there.\r\n", ch);
      return 0;
    }
  }
  if(SECT(EXIT(ch,dir)->to_room) == SECT_OCEAN && (IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)) {
    send_to_char("The rough currents would be hazardous to your health.\r\n",ch);
    return 0;
  }

  if ((SECT(ch->in_room) == SECT_FLYING) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_FLYING)) {

    if (!flying && dir == UP) {
      send_to_char("&7Try flapping your wings.&0\r\n", ch);
      return 0;
    }
  }

  /* move points needed is avg. move loss for src and destination sect type */
  if(GET_POS(ch) == POS_FLYING && !riding)
    need_movement = 1;
  else
    need_movement = (movement_loss[SECT(ch->in_room)] +
		     movement_loss[SECT(EXIT(ch, dir)->to_room)]) >> 1;

  if (riding) {
    if (GET_MOVE(RIDING(ch)) < need_movement) {
      send_to_char("Your mount is too exhausted.\r\n", ch);
      return 0;
    }
  } else {
    if (GET_MOVE(ch) < need_movement && !IS_NPC(ch)) {
      if (need_specials_check && ch->master)
	send_to_char("You are too exhausted to follow.\r\n", ch);
      else
	send_to_char("You are too exhausted.\r\n", ch);
      return 0;
    }
  }

  if (riding && GET_SKILL(ch, SKILL_RIDING) < number(1, 101)-number(-4,need_movement)) {
    act("$N rears backwards, throwing you to the ground.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
    act("You rear backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_VICT);
    act("$N rears backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_NOTVICT);
    dismount_char(ch);
    improve_skill(ch, SKILL_RIDING);
    damage(ch, ch, dice(10,6), -1);
    return 0;
  }
  vnum = world[EXIT(ch, dir)->to_room].number;

  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_ATRIUM)) {
    /*if (!House_can_enter(ch, world[EXIT(ch, dir)->to_room].number)) {*/
    if (!House_can_enter(ch, vnum)) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return 0;
    }
  }

  if ((riding || ridden_by) && IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_TUNNEL)) {
    send_to_char("There isn't enough room there, while mounted.\r\n", ch);
    return 0;
  } else {
    if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_TUNNEL) &&
	num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) > 1) {
      send_to_char("There isn't enough room there for more than one person!\r\n", ch);
      return 0;
    }
  }

  /* see if an entry trigger disallows the move */
  if (!entry_mtrigger(ch))
    return 0;
  if (!enter_wtrigger(&world[EXIT(ch, dir)->to_room], ch, dir))
    return 0;

  /* alter the need_movement depending on wind direction and speed */
  if ((zone_table[world[ch->in_room].zone]).wind_speed >= WIND_GALE)
    {
      if ((zone_table[world[ch->in_room].zone]).wind_dir == (dir + 2) % 4)
	{
	  need_movement *= 2;
	  send_to_char("The wind beats hard upon your body as you forge ahead.\r\n", ch);

	  /* nifty affect for the little guys!:) */
	  if (GET_SIZE(ch) <= SIZE_SMALL)
	    {
	      if (number(0,9) > 7) /* 20% chance */
		{
		  GET_POS(ch) = POS_SITTING;
		  send_to_char("The wind is so powerful that your small body is knocked backward and you fall to the ground!\r\n", ch);
		  act("$n is knocked backward by the force of the wind!", FALSE, ch, 0, 0, TO_ROOM);
		}
	    }
	}
    }
  if (GET_LEVEL(ch) < LVL_IMMORT && !IS_NPC(ch) && !(riding || ridden_by))
    alter_move(ch, need_movement);
  else if (riding)
    /*GET_MOVE(RIDING(ch)) -= need_movement;*/
    alter_move(RIDING(ch), need_movement);
  else if (ridden_by)
    /*GET_MOVE(RIDDEN_BY(ch)) -= need_movement;*/
    alter_move(RIDDEN_BY(ch), need_movement);

  if (riding) {
    sprintf(buf2, "You ride %s on %s.\r\n", dirs[dir],
	    PERS(RIDING(ch), ch));
    act(buf2, TRUE, ch, 0, 0, TO_CHAR);
    sprintf(mmsg, "$n rides %s on ", dirs[dir]);
  } else {
    sprintf(mmsg, "$n %s %s.",
	    movewords(ch, dir, ch->in_room, TRUE), dirs[dir]);
  }

  LOOP_THRU_PEOPLE(people, ch) {
    if ((ch == people) || !AWAKE(people))
      continue;
    if (people == RIDING(ch)) {
      sprintf(tmp, "%s you.", mmsg);
      act(tmp, TRUE, ch, 0, people, TO_VICT);
      continue;
    }
    if(riding){
      sprintf(tmp, "%s %s.", mmsg, CAN_SEE(people, RIDING(ch)) ?
	      GET_NAME(RIDING(ch)) : "something");
      act(tmp, TRUE, ch, 0, people, TO_VICT);
    }else if (!IS_AFFECTED(ch, AFF_SNEAK) && !OUTDOOR_SNEAK(ch) &&
	      CAN_SEE(people, ch)) {
      act(mmsg, TRUE, ch, 0, people, TO_VICT);
    } else {
      if (GET_LEVEL(people) >= LVL_IMMORT ||
	  ((IS_AFFECTED(people,AFF_SENSE_LIFE) ||
	    IS_AFFECTED3(people,AFF3_AWARE)) && statsave(people, APPLY_INT, -4)))
	act(mmsg, TRUE, ch, 0, people, TO_VICT);
    }
  }
  was_in = ch->in_room;
  if (GET_HIT(ch)<(((int)(0.3*GET_MAX_HIT(ch))))){
    for (i = world[ch->in_room].contents; i; i = i->next_content) {
      if(GET_OBJ_VNUM(i)==34){
	extract_obj(i);
      }else if(GET_OBJ_VNUM(i)==35){
	extract_obj(i);}}}
  if (GET_HIT(ch)<((int)(0.1*GET_MAX_HIT(ch)))){
    bloodp = read_object(BLOOD_POOL_OBJ, VIRTUAL);
    GET_OBJ_VAL(bloodp, 0) = ch->in_room;
    GET_OBJ_TIMER(bloodp) = 3;
    CREATE(new_descr, struct extra_descr_data, 1);
    new_descr->keyword = str_dup("blood pool");
    sprintf(buf, "&0&1Quite a large pool of blood.&0");
    new_descr->description = str_dup(buf);
    new_descr->next = bloodp->ex_description;
    bloodp->ex_description = new_descr;
    obj_to_room(bloodp, ch->in_room);}
  if (GET_HIT(ch)>=((int)(0.1*GET_MAX_HIT(ch)))){
    if (GET_HIT(ch)<((int)(0.3*GET_MAX_HIT(ch)))){
      bloodd = read_object(BLOOD_DROP_OBJ, VIRTUAL);
      GET_OBJ_VAL(bloodd, 0) = ch->in_room;
      GET_OBJ_TIMER(bloodd) = 2;
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = str_dup("blood drops");
      sprintf(buf, "&0&1Several drops of blood cover the ground here.&0");
      new_descr->description = str_dup(buf);
      new_descr->next = bloodd->ex_description;
      bloodd->ex_description = new_descr;
      obj_to_room(bloodd, ch->in_room);}}

  if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE))
    mag_damage(GET_LEVEL(ch), ch, ch, SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
  char_from_room(ch);
  char_to_room(ch, world[was_in].dir_option[dir]->to_room);
  if (riding && same_room && RIDING(ch)->in_room != ch->in_room) {
    char_from_room(RIDING(ch));
    char_to_room(RIDING(ch), ch->in_room);
    look_at_room(RIDING(ch), 1);
    /*lookmark*/
  }else if (ridden_by && same_room && RIDDEN_BY(ch)->in_room != ch->in_room)
    {
      char_from_room(RIDDEN_BY(ch));
      char_to_room(RIDDEN_BY(ch), ch->in_room);
      look_at_room(RIDDEN_BY(ch), ch->in_room);
    }

  {
    if (riding && same_room) {
      sprintf(tmp, "$n arrives from %s%s, riding",
	      (dir < UP  ? "the " : ""),
	      (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
    } else if (!riding || (riding && !same_room))
      sprintf(buf, "$n %s from %s%s.", movewords(ch, dir, ch->in_room, FALSE),
	      (dir < UP  ? "the " : ""),
	      (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
    LOOP_THRU_PEOPLE(people, ch) {
      if ((ch == people) || !AWAKE(people))
	continue;
      if(people == RIDING(ch))
	continue;
      if (riding) {
	sprintf(buf2, "%s%s", tmp,
		CAN_SEE(people, RIDING(ch)) ? GET_NAME(RIDING(ch)) : "something");
	act(buf2, TRUE, ch, 0, people, TO_VICT);
	if (is_aggr_to(people, ch))    /*NEW FASTER AGGRO! */
	  /*if(number(0, 5))*/
	  hit(people, ch, TYPE_UNDEFINED);
	else if (is_aggr_to(people, RIDING(ch)))
	  /*if(number(0, 5))*/
	  hit(people, RIDING(ch), TYPE_UNDEFINED);
      }else if (!IS_AFFECTED(ch, AFF_SNEAK) && !OUTDOOR_SNEAK(ch) &&
		CAN_SEE(people, ch)) {
	act(buf, TRUE, ch, 0, people, TO_VICT);
	if (is_aggr_to(people, ch))
	  /*if(number(0, 5))*/
	  hit(people, ch, TYPE_UNDEFINED);
      }else {
	if (GET_LEVEL(people) >= LVL_IMMORT ||
	    ((IS_AFFECTED(people, AFF_SENSE_LIFE) || IS_AFFECTED3(people,AFF3_AWARE)) &&
	     statsave(people, APPLY_INT, -4))) {
	  act(buf, TRUE, ch, 0, people, TO_VICT);
	  if (is_aggr_to(people, ch))    /*NEW FASTER AGGRO! */
	    hit(people, ch, TYPE_UNDEFINED);
	  /*MARK56*/
	}else {
	  if (is_aggr_to(people, ch))
	    hit(people, ch, TYPE_UNDEFINED);
	}
      }
    }
  }

  if (ch->desc != NULL)
    look_at_room(ch, 0);
  /* silly deathtraps thee will be none in Hubis*/
  /*if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_DEATH) && GET_LEVEL(ch) < LVL_IMMORT) {
    log_death_trap(ch);
    death_cry(ch);
    extract_char(ch);*/
  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_DEATH)) {
    if (GET_LEVEL(ch) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }

    if (riding && GET_LEVEL(RIDING(ch)) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }

    if (ridden_by && GET_LEVEL(RIDDEN_BY(ch)) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }
    return 0;
  }

  if (!greet_mtrigger(ch, dir)) {
    char_from_room(ch);
    char_to_room(ch, was_in);
    look_at_room(ch, 0);
  }

  justice_trigger(ch);
  if (!IS_AFFECTED(ch, AFF_SNEAK)) {
    mprog_entry_trigger(ch);
    mprog_greet_trigger(ch);}
  return 1;
}



int perform_move(struct char_data *ch, int dir, int need_specials_check)
{
  int was_in;
  struct follow_type *k, *next;

  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS)
    return 0;
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
    send_to_char("Alas, you cannot go that way...\r\n", ch);
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN))
    send_to_char("Alas, you cannot go that way...\r\n", ch);
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
    if (EXIT(ch, dir)->keyword) {
      sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf2, ch);
    } else
      send_to_char("It seems to be closed.\r\n", ch);
  } else {
    if (!ch->followers)
      return (do_simple_move(ch, dir, need_specials_check));

    was_in = ch->in_room;
    if (!do_simple_move(ch, dir, need_specials_check))
      return 0;

    for (k = ch->followers; k; k = next) {
      next = k->next;
      if ((k->follower->in_room == was_in) &&
	  (GET_POS(k->follower) >= POS_STANDING) &&
	  (!IS_FIGHTING(k->follower)) && (!PLR_FLAGGED(k->follower, PLR_CASTING))) {
	act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
	perform_move(k->follower, dir, 1);
      }
    }
    return 1;
  }
  return 0;
}


ACMD(do_move)
{
  /*
   * This is basically a mapping of cmd numbers to perform_move indices.
   * It cannot be done in perform_move because perform_move is called
   * by other functions which do not require the remapping.
   */
  if (IS_FIGHTING(ch)) {
    send_to_char("You are to busy fighting to turn you back and walk away!\r\n", ch);
    return;
  }
  perform_move(ch, cmd - 1, 0);
}


int find_door(struct char_data *ch, char *type, char *dir, char *cmdname)
{
  int door;

  if (*dir) {			/* a direction was specified */
    if ((door = search_block(dir, dirs, FALSE)) == -1) {	/* Partial Match */
      send_to_char("That's not a direction.\r\n", ch);
      return -1;
    }
    if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
      if (EXIT(ch, door)->keyword)
	if (isname(type, EXIT(ch, door)->keyword))
	  return door;
	else {
	  sprintf(buf2, "I see no %s there.\r\n", type);
	  send_to_char(buf2, ch);
	  return -1;
	} else
	  return door;
    else {
      send_to_char("I really don't see how you can close anything there.\r\n", ch);
      return -1;
    }
  } else {			/* try to locate the keyword */
    if (!*type) {
      sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
      send_to_char(buf2, ch);
      return -1;
    }
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
	if (EXIT(ch, door)->keyword)
	  if (isname(type, EXIT(ch, door)->keyword))
	    return door;

    sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
    send_to_char(buf2, ch);
    return -1;
  }
}


int has_key(struct char_data *ch, int key)
{
  struct obj_data *o;

  for (o = ch->carrying; o; o = o->next_content)
    if (GET_OBJ_VNUM(o) == key)
      return 1;

  if (GET_EQ(ch, WEAR_HOLD))
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD)) == key)
      return 1;

  return 0;
}

#define NEED_OPEN	1
#define NEED_CLOSED	2
#define NEED_UNLOCKED	4
#define NEED_LOCKED	8

char *cmd_door[] =
{
  "open",
  "close",
  "unlock",
  "lock",
  "pick"
};

const int flags_door[] =
{
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_OPEN,
  NEED_CLOSED | NEED_LOCKED,
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_CLOSED | NEED_LOCKED
};


#define EXITN(room, door)		(world[room].dir_option[door])
#define OPEN_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_CLOSED)))
#define LOCK_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_LOCKED)))

void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd)
{
  int other_room = 0;
  struct room_direction_data *back = 0;

  if(IS_FIGHTING(ch)) {
    send_to_char("You better hope your gut doesnt get opened by whom you are fighting!\r\n",ch);
    return;
  }

  sprintf(buf, "$n %ss ", cmd_door[scmd]);
  if (!obj && ((other_room = EXIT(ch, door)->to_room) != NOWHERE))
    if ((back = world[other_room].dir_option[rev_dir[door]]))
      if (back->to_room != ch->in_room)
	back = 0;

  switch (scmd) {
  case SCMD_OPEN:
  case SCMD_CLOSE:
    OPEN_DOOR(ch->in_room, obj, door);
    if (back)
      OPEN_DOOR(other_room, obj, rev_dir[door]);
    /* Since the door is open, it's no longer secret on the other side. --Fingon */
    if (back) {
      if (IS_SET(back->exit_info, EX_HIDDEN)) {
	REMOVE_BIT(back->exit_info, EX_HIDDEN);
      }
    }
    send_to_char(OK, ch);
    break;
  case SCMD_UNLOCK:
  case SCMD_LOCK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("*Click*\r\n", ch);
    break;
  case SCMD_PICK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("The lock quickly yields to your skills.\r\n", ch);
    strcpy(buf, "$n skillfully picks the lock on ");
    improve_skill(ch, SKILL_PICK_LOCK);
    break;
  }

  /* Notify the room */
  sprintf(buf + strlen(buf), "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
	  (EXIT(ch, door)->keyword ? "$F" : "door"));
  if (!(obj) || (obj->in_room != NOWHERE))
    act(buf, FALSE, ch, obj, obj ? 0 : EXIT(ch, door)->keyword, TO_ROOM);

  /* Notify the other room */
  if ((scmd == SCMD_OPEN || scmd == SCMD_CLOSE) && back) {
    sprintf(buf, "The %s is %s%s from the other side.\r\n",
	    (back->keyword ? fname(back->keyword) : "door"), cmd_door[scmd],
	    (scmd == SCMD_CLOSE) ? "d" : "ed");
    if (world[EXIT(ch, door)->to_room].people) {
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_ROOM);
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_CHAR);
    }
  }
}


int ok_pick(struct char_data *ch, int keynum, int pickproof, int scmd)
{
  int percent;

  percent = number(1, 101);

  if (scmd == SCMD_PICK) {
    if (keynum < 0)
      send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
    else if (pickproof)
      send_to_char("It resists your attempts to pick it.\r\n", ch);
    else if (percent > GET_SKILL(ch, SKILL_PICK_LOCK))
      send_to_char("You failed to pick the lock.\r\n", ch);
    else
      return (1);
    return (0);
  }
  return (1);
}


#define DOOR_IS_OPENABLE(ch, obj, door)	((obj) ? \
			((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && \
			(IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSEABLE))) :\
			(IS_SET(EXIT(ch, door)->exit_info, EX_ISDOOR)))
#define DOOR_IS_OPEN(ch, obj, door)	((obj) ? \
			(!IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
			(!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED)))
#define DOOR_IS_UNLOCKED(ch, obj, door)	((obj) ? \
			(!IS_SET(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
			(!IS_SET(EXIT(ch, door)->exit_info, EX_LOCKED)))
#define DOOR_IS_PICKPROOF(ch, obj, door) ((obj) ? \
			(IS_SET(GET_OBJ_VAL(obj, 1), CONT_PICKPROOF)) : \
			(IS_SET(EXIT(ch, door)->exit_info, EX_PICKPROOF)))

#define DOOR_IS_CLOSED(ch, obj, door)	(!(DOOR_IS_OPEN(ch, obj, door)))
#define DOOR_IS_LOCKED(ch, obj, door)	(!(DOOR_IS_UNLOCKED(ch, obj, door)))
#define DOOR_KEY(ch, obj, door)		((obj) ? (GET_OBJ_VAL(obj, 2)) : \
					(EXIT(ch, door)->key))
#define DOOR_LOCK(ch, obj, door)	((obj) ? (GET_OBJ_VAL(obj, 1)) : \
					(EXIT(ch, door)->exit_info))

ACMD(do_gen_door)
{
  int door = -1, keynum;
  char type[MAX_INPUT_LENGTH], dir[MAX_INPUT_LENGTH];
  struct obj_data *obj = NULL;
  struct char_data *victim = NULL;

  skip_spaces(&argument);
  if (!*argument) {
    sprintf(buf, "%s what?\r\n", cmd_door[subcmd]);
    send_to_char(CAP(buf), ch);
    return;
  }
  two_arguments(argument, type, dir);
  if (!generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
    door = find_door(ch, type, dir, cmd_door[subcmd]);

  if ((obj) || (door >= 0)) {
    keynum = DOOR_KEY(ch, obj, door);
    if (!(DOOR_IS_OPENABLE(ch, obj, door)) || ((obj) && IS_CORPSE(obj)))
      act("You can't $F that!", FALSE, ch, 0, cmd_door[subcmd], TO_CHAR);
    else if (!DOOR_IS_OPEN(ch, obj, door) &&
	     IS_SET(flags_door[subcmd], NEED_OPEN))
      send_to_char("But it's already closed!\r\n", ch);
    else if (!DOOR_IS_CLOSED(ch, obj, door) &&
	     IS_SET(flags_door[subcmd], NEED_CLOSED))
      send_to_char("But it's currently open!\r\n", ch);
    else if (!(DOOR_IS_LOCKED(ch, obj, door)) &&
	     IS_SET(flags_door[subcmd], NEED_LOCKED))
      send_to_char("Oh.. it wasn't locked, after all..\r\n", ch);
    else if (!(DOOR_IS_UNLOCKED(ch, obj, door)) &&
	     IS_SET(flags_door[subcmd], NEED_UNLOCKED))
      send_to_char("It seems to be locked.\r\n", ch);
    else if (!has_key(ch, keynum) && (GET_LEVEL(ch) < LVL_GOD) &&
	     ((subcmd == SCMD_LOCK) || (subcmd == SCMD_UNLOCK)))
      send_to_char("You don't seem to have the proper key.\r\n", ch);
    else if (ok_pick(ch, keynum, DOOR_IS_PICKPROOF(ch, obj, door), subcmd))
      do_doorcmd(ch, obj, door, subcmd);
  }
  return;
}



ACMD(do_enter)
{
  struct obj_data *obj = NULL;
  /*extern int top_of_world;*/
  int door, rnum;

  one_argument(argument, buf);

  if (*buf) {
    if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
      if (CAN_SEE_OBJ(ch, obj)) {
        if (GET_OBJ_TYPE(obj) == ITEM_PORTAL) {

	  /* Random portals: ie, obj# 4119 sends to rooms between 4100 and 4999.
	     Add more as desired. */

	  if (GET_OBJ_VNUM(obj) == 4119){
	    GET_OBJ_VAL(obj, 0) = number(4100, 4999);}
	  if (GET_OBJ_VNUM(obj) == 4137){
	    GET_OBJ_VAL(obj, 0) = number(32200, 32399);}
	  if (GET_OBJ_VNUM(obj) == 4138){
	    GET_OBJ_VAL(obj, 0) = number(32400, 32590);}
	  if (GET_OBJ_VNUM(obj) == 4139){
	    GET_OBJ_VAL(obj, 0) = number(32000, 32152);}
	  if (GET_OBJ_VNUM(obj) == 4140){
	    GET_OBJ_VAL(obj, 0) = number(5700, 5810);}
	  if (GET_OBJ_VAL(obj, 0) != 0) {
	    if (GET_OBJ_VNUM(obj) == 5604){
	      GET_OBJ_VAL(obj, 0) = number(5601, 5618);}
	    if (GET_OBJ_VNUM(obj) == 5605){
	      GET_OBJ_VAL(obj, 0) = number(5622, 5639);}
	    if (GET_OBJ_VNUM(obj) == 5606){
	      GET_OBJ_VAL(obj, 0) = number(5642, 5659);}
	    if (GET_OBJ_VNUM(obj) == 5607){
	      GET_OBJ_VAL(obj, 0) = number(5662, 5679);}
	    /* The formatting here makes me want to cry, so I am putting it here anyway  --Nechtrous */
	    if (GET_OBJ_VNUM(obj) == HEAVENSGATE_OBJ) {
	      if(GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500){
		act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE,ch,obj,0,TO_CHAR);
		act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.",TRUE,ch,obj,0,TO_ROOM);
		return;
	      }
	      else if(GET_ALIGNMENT(ch) <= -500) {
		act("&9&bUpon entering $p&9&b, you begin to &1burn&9... Your screams can be heard throughtout the &7heavens&9...&0",FALSE,ch,obj,0,TO_CHAR);
		act("&9&b$n&9&b enters $p&9&b... Following a &0&1blood&9&b curdling scream that spans the &7heavens&9, $n&9&b flails back out of the tunnel, &1&bon fire!&0",FALSE,ch,obj,0,TO_ROOM);
		damage(ch,ch,(int)(abs(GET_ALIGNMENT(ch))/10),TYPE_SUFFERING);
		SET_BIT(AFF2_FLAGS(ch), AFF2_ON_FIRE);
		return;
	      }
	    }
	    if (GET_OBJ_VNUM(obj) == HELLGATE_OBJ) {
	      if(GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500){
		act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE,ch,obj,0,TO_CHAR);
		act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.",TRUE,ch,obj,0,TO_ROOM);
		return;
	      }
	      else if(GET_ALIGNMENT(ch) >= 500) {
		act("&9&bUpon catching a glimpse of &1hell&9 itself, your &0&5mind&9&b twists and distorts... &0",FALSE,ch,obj,0,TO_CHAR);
		act("&9&b$n&9&b enters $p&9&b... Strange moaning sounds can be heard as $n&9&b wanders back out, twitching and drooling on $mself.&0",FALSE,ch,obj,0,TO_ROOM);
		damage(ch,ch,(int)(abs(GET_ALIGNMENT(ch))/10),TYPE_SUFFERING);
		mag_affects(70, ch, ch, SPELL_INSANITY, SAVING_SPELL);
		mag_affects(70, ch, ch, SPELL_DISEASE, SAVING_SPELL);
		return;
	      }
	    }
	    /* ENTRY MESSAGES */
	    if (GET_OBJ_VAL(obj, 1)==0){
	      act("$p &0&b&8flares white as $n enters it and disappears.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 1))==1){
	      act("$p &0&b&8flares as $n enters it and disappears.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 1))==2){
	      act("$p &0&b&8vibrates violently as $n enters it and then stops.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    char_from_room(ch);
	    /* CHARACTER MESSAGE */
	    if ((GET_OBJ_VAL(obj, 2))==(1)){
	      send_to_char("&0&b&8You feel your body being ripped apart!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(2)){
	      act("$p &0&b&8vibrates violently as you enter.&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(3)){
	      act("&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(4)){
	      send_to_char("&0&b&8You appear in a completely different location!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(5)){
	      send_to_char("&0&b&9You feel your energy being drained!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(6)){
	      act("&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n"
		  "\r\n"
		  "\r\n"
		  "&0&b&8You catch a glimpse of a giant white leopard!&0\r\n"
		  "\r\n"
		  "\r\n"
		  "&0&b&9You feel your energy being drained!&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    /* ROOM EXIT MESSAGE */
	    rnum = real_room(GET_OBJ_VAL(obj, 0));
	    char_to_room(ch, rnum);
	    if ((GET_OBJ_VAL(obj, 3))==(0)){
	      act("$p flares white as $n emerges from it.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(1)){
	      act("$p flares as $n emerges from it.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(2)){
	      act("$n appears from nowhere!&0\r\n", FALSE, ch, 0, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(3)){
	      act("&0There is a loud POP sound as $n emerges from $p.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    look_at_room(ch, 1);
          } else if (real_room(GET_OBJ_VAL(obj, 0)) == 0) {
	    act("$p flares for a second then dies down.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    send_to_char("&0It flares and then dies down - it must be broken!&0\r\n", ch);
	  }
          return;}}}

    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
	if (EXIT(ch, door)->keyword)
	  if (!str_cmp(EXIT(ch, door)->keyword, buf)) {
	    perform_move(ch, door, 1);
	    return;
	  }
    sprintf(buf2, "There is no %s here.\r\n", buf);
    send_to_char(buf2, ch);
  } else if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS))
    send_to_char("You are already indoors.\r\n", ch);
  else {
    /* try to locate an entrance */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED) &&
	      IS_SET(ROOM_FLAGS(EXIT(ch, door)->to_room), ROOM_INDOORS)) {
	    perform_move(ch, door, 1);
	    return;
	  }
    send_to_char("You can't seem to find anything to enter.\r\n", ch);
  }
}


ACMD(do_leave)
{
  int door;

  if (!IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS))
    send_to_char("You are outside.. where do you want to go?\r\n", ch);
  else {
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED) &&
	      !IS_SET(ROOM_FLAGS(EXIT(ch, door)->to_room), ROOM_INDOORS)) {
	    perform_move(ch, door, 1);
	    return;
	  }
    send_to_char("I see no obvious exits to the outside.\r\n", ch);
  }
}

ACMD(do_fly)
{
  if(!IS_AFFECTED(ch, AFF_FLYING)) {
    send_to_char("You do not have the means to fly.\r\n",ch);
    return;
  }
  if(GET_POS(ch) == POS_FLYING) {
    send_to_char("You are already flying.\r\n",ch);
    return;
  }
  if(GET_POS(ch) != POS_STANDING || GET_POS1(ch) != POS1_STANDING){
    send_to_char("Your not in the proper position to fly.\r\n",ch);
    return;
  }
  act("&6&bYou lift into the air.&0",FALSE,ch,0,0,TO_CHAR);
  act("&6&b$n&6&b lifts into the air.&0",TRUE,ch,0,0,TO_ROOM);
  GET_POS(ch) = POS_FLYING;
}

ACMD(do_stand)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
    if(GET_POS1(ch) == POS1_PRONE) {
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_STANDING)
      act("You are already standing.", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_SITTING:
    act("You stand up.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_POS1(ch) = POS1_STANDING;
    break;
  case POS_RESTING:
    if(GET_POS1(ch) == POS1_PRONE) {
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_STANDING)
      act("You are already standing.", FALSE, ch, 0, 0, TO_CHAR);
    else{
      act("You stop resting, and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops resting, and clambers on $s feet.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_POS1(ch) = POS1_STANDING;
    }
    break;
  case POS_SLEEPING:
    act("You have to wake up first!", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FIGHTING:
    if(GET_POS1(ch) == POS1_PRONE) {
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS1(ch) = POS1_STANDING;
    }else
      act("Do you not consider fighting as standing?", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FLYING:
    act("You stop floating around, and put your feet on the ground.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops floating around, and puts $s feet on the ground.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_POS1(ch) = POS1_STANDING;
    break;
  default:
    act("You stop floating around, and put your feet on the ground.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops floating around, and puts $s feet on the ground.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_POS1(ch) = POS1_STANDING;
    break;
  }
}

ACMD(do_sit)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
    if(GET_POS1(ch) == POS1_KNEELING) {
      act("You stop kneeling and sit down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and sits down.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
    }else if((GET_POS1(ch) == POS1_RESTING) ||
	     (GET_POS1(ch) == POS1_PRONE)) {
      act("You stop standing at ease and sit down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops standing at ease, and sits down.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      GET_POS1(ch) = POS1_SITTING;
    }else
      act("You sit down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
    break;
  case POS_SITTING:
    send_to_char("You're sitting already.\r\n", ch);
    GET_POS1(ch) = POS1_SITTING;
    break;
  case POS_RESTING:
    act("You stop resting, and sit up.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops resting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
    break;
  case POS_SLEEPING:
    act("You have to wake up first.", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FIGHTING:
    act("You sit down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
    break;
  default:
    act("You stop floating around, and sit down.", FALSE, ch, 0, 0,
	TO_CHAR);
    act("$n stops floating around, and sits down.", TRUE, ch, 0, 0,
	TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
    break;
  }
}

ACMD(do_kneel)
{
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
  case POS_STUNNED:
    send_to_char("Posture is far from your biggest problem right now!\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You seem to be having a dream of infancy.\r\n", ch);
    return;
    break;
  case POS_RESTING:
  case POS_STANDING:
    if (IS_AFFECTED2(ch, AFF2_KNOCKED_OUT)) {
      send_to_char("You should probably worry more about becoming conscious again.\r\n", ch);
      return;
    }
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less get to your knees!\r\n", ch);
	return;
      }
      act("You swing up onto your knees.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n levers up onto $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_KNEELING:
      send_to_char("You are kneeling already.\r\n", ch);
      return;
      break;
    case POS1_SITTING:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      act("You move from your butt to your knees.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops sitting around and gets to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_RESTING:
    case POS1_STANDING:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less kneel!\r\n", ch);
	return;
      }
      act("You kneel.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    }
    break;
  }
  GET_POS1(ch) = POS1_KNEELING;
}

ACMD(do_recline)
{
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
  case POS_STUNNED:
    send_to_char("Posture is far from your biggest problem right now!\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of laying down.\r\n", ch);
    return;
    break;
  case POS_SITTING:
    act("You stop sitting around and lay down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops sitting around and lays down.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS1(ch) = POS1_PRONE;
    return;
    break;
  case POS_RESTING:
  case POS_STANDING:
    if (IS_AFFECTED2(ch, AFF2_KNOCKED_OUT)) {
      send_to_char("You should probably worry more about becoming conscious again.\r\n", ch);
      return;
    }
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
      send_to_char("You are already laying down.\r\n", ch);
      return;
      break;
    case POS1_KNEELING:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less lay down!\r\n", ch);
	return;
      }
      act("You recline.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n eases off $s knees and lays down.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_SITTING:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      act("You stop sitting around and lay down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops sitting around and lays down.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_STANDING:
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      act("You drop to your belly.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);

      break;
    }
    break;
  }
  GET_POS1(ch) = POS1_PRONE;
}




ACMD(do_rest)
{
  switch (GET_POS(ch)) {
  case POS_RESTING:
    send_to_char("You are already resting.\r\n", ch);
    return;
    break;
  case POS_SITTING:
    act("You find a comfortable spot where you are sitting.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n finds a comfortable spot where $e is sitting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS1(ch) = POS1_RESTING;
    GET_POS(ch) = POS_RESTING;
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of relaxing.\r\n", ch);
    return;
    break;
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
    send_to_char("Just wait a bit, you'll soon be VERY relaxed.\r\n", ch);
    return;
    break;
  case POS_STANDING:
    if (IS_FIGHTING(ch)) {
      send_to_char("Resting now will most likely lead to your final rest!\r\n", ch);
      return;
    }

    if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
      send_to_char("You can't even twitch, much less relax!\r\n", ch);
      return;
    }
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
      send_to_char("You close your eyes and relax.\r\n", ch);
      act("You see some of the tension leave $n's body.", TRUE, ch, 0, 0,
	  TO_ROOM);
      break;
    case POS1_KNEELING:
      send_to_char("You slump and relax your posture.\r\n", ch);
      act("$n relaxes a bit.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS1(ch) = POS1_KNEELING;
      GET_POS(ch) = POS_RESTING;
      return;
      break;
    case POS1_SITTING:
      send_to_char("You wiggle to find the most comfortable position.\r\n", ch);
      act("$n relaxes a bit.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_STANDING:
      send_to_char("You sit down and relax.\r\n", ch);
      act("$n sits down in a comfortable spot.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    }
    break;
  case POS_FLYING:
    send_to_char("You stop floating and rest your tired bones.\r\n", ch);
    act("$n stops floating and takes a rest.", TRUE, ch, 0, 0, TO_ROOM);
    break;
  }
  GET_POS1(ch) = POS1_RESTING;
  GET_POS(ch) = POS_RESTING;

}

/* new, does opposite of 'rest' */

ACMD(do_alert)
{
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
    send_to_char("Just wait a bit, you'll soon be VERY relaxed.\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of being alert.\r\n", ch);
    return;
    break;
  case POS_SITTING:
  case POS_STANDING:
    if(GET_POS1(ch) != POS1_STANDING) {
      send_to_char("You tense up and become more alert.\r\n", ch);
      GET_POS1(ch) = POS1_STANDING;
      return;
    }else
      send_to_char("You are already about as tense as you can get.\r\n", ch);
    return;
    break;
  case POS_RESTING:
    if (IS_FIGHTING(ch))
      send_to_char("Since your fighting, you better be alert!\r\n", ch);

    switch (GET_POS1(ch)) {
    case POS1_PRONE:
      send_to_char("You stop relaxing and try to become more aware of your surroundings.\r\n", ch);
      break;
    case POS1_KNEELING:
      send_to_char("You straighten up a bit.\r\n", ch);
      act("$n straightens up a bit.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_SITTING:
      send_to_char("You sit up straight and start to pay attention.\r\n",
		   ch);
      act("$n sits at attention.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case POS1_STANDING:
      send_to_char("You tense up and become more alert.\r\n", ch);
      break;
    }
    break;
  }
  GET_POS(ch) = POS_STANDING;
}



ACMD(do_sleep)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
  case POS_SITTING:
  case POS_RESTING:
    send_to_char("You lie down and go to sleep.\r\n", ch);
    act("$n lies down and goes to asleep.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    GET_POS1(ch) = POS1_PRONE;
    break;
  case POS_SLEEPING:
    send_to_char("You are already sound asleep.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    break;
  default:
    act("You stop floating around, and lie down to sleep.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops floating around, and lie down to sleep.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    GET_POS1(ch) = POS1_PRONE;
    break;
  }
}


ACMD(do_wake)
{
  struct char_data *vict;
  int self = 0;

  one_argument(argument, arg);
  if (*arg) {
    if (GET_POS(ch) == POS_SLEEPING)
      send_to_char("Maybe you should wake yourself up first.\r\n", ch);
    else if ((vict = get_char_room_vis(ch, arg)) == NULL)
      send_to_char(NOPERSON, ch);
    else if (vict == ch)
      self = 1;
    else if (GET_POS(vict) > POS_SLEEPING)
      act("$E is already awake.", FALSE, ch, 0, vict, TO_CHAR);
    else if (IS_AFFECTED(vict, AFF_SLEEP))
      act("You can't wake $M up!", FALSE, ch, 0, vict, TO_CHAR);
    else if (GET_POS(vict) < POS_SLEEPING)
      act("$E's in pretty bad shape!", FALSE, ch, 0, vict, TO_CHAR);
    else {
      act("You wake $M up.", FALSE, ch, 0, vict, TO_CHAR);
      act("You are awakened by $n.", FALSE, ch, 0, vict, TO_VICT |
	  TO_SLEEP);
      GET_POS(vict) = POS_RESTING;
      GET_POS1(ch) = POS1_PRONE;
    }
    if (!self)
      return;
  }
  if (IS_AFFECTED(ch, AFF_SLEEP))
    send_to_char("You can't wake up!\r\n", ch);
  else if (GET_POS(ch) > POS_SLEEPING)
    send_to_char("You are already awake...\r\n", ch);
  else {
    send_to_char("You awaken, and sit up.\r\n", ch);
    act("$n awakens.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    GET_POS1(ch) = POS1_PRONE;
  }
}


ACMD(do_follow)
{
  struct char_data *leader;

  void stop_follower(struct char_data *ch);
  void add_follower(struct char_data *ch, struct char_data *leader);

  one_argument(argument, buf);

  if (*buf) {
    if (!(leader = get_char_room_vis(ch, buf))) {
      send_to_char(NOPERSON, ch);
      return;
    }
  } else {
    send_to_char("Whom do you wish to follow?\r\n", ch);
    return;
  }

  if (ch->master == leader) {
    act("You are already following $M.", FALSE, ch, 0, leader, TO_CHAR);
    return;
  }
  if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master)) {
    act("But you only feel like following $N!", FALSE, ch, 0, ch->master, TO_CHAR);
  } else {			/* Not Charmed follow person */
    if (leader == ch) {
      if (!ch->master) {
	send_to_char("You are already following yourself.\r\n", ch);
	return;
      }
      stop_follower(ch);
    } else {
      if (ch->master)
	stop_follower(ch);
      add_follower(ch, leader);
    }
  }
}

ACMD(do_mount) {
  char arg[MAX_INPUT_LENGTH];
  struct char_data *vict;

  one_argument(argument, arg);

  if (!arg || !*arg) {
    send_to_char("Mount who?\r\n", ch);
    return;
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("There is no-one by that name here.\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("Ehh... no.\r\n", ch);
    return;
  } else if (RIDING(ch) || RIDDEN_BY(ch)) {
    send_to_char("You are already mounted.\r\n", ch);
    return;
  } else if (RIDING(vict) || RIDDEN_BY(vict)) {
    send_to_char("It is already mounted.\r\n", ch);
    return;
  } else if (GET_LEVEL(ch) < LVL_IMMORT && IS_NPC(vict) && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
    send_to_char("You can't mount that!\r\n", ch);
    return;
  } else if (!GET_SKILL(ch, SKILL_MOUNT)) {
    send_to_char("First you need to learn *how* to mount.\r\n", ch);
    return;
  } else if (GET_SKILL(ch, SKILL_MOUNT) <= number(1, 101)) {
    act("You try to mount $N, but slip and fall off.", FALSE, ch, 0, vict, TO_CHAR);
    act("$n tries to mount you, but slips and falls off.", FALSE, ch, 0, vict, TO_VICT);
    act("$n tries to mount $N, but slips and falls off.", TRUE, ch, 0, vict, TO_NOTVICT);
    damage(ch, ch, dice(1, 2), -1);
    return;
  }

  act("You mount $N.", FALSE, ch, 0, vict, TO_CHAR);
  act("$n mounts you.", FALSE, ch, 0, vict, TO_VICT);
  act("$n mounts $N.", TRUE, ch, 0, vict, TO_NOTVICT);
  mount_char(ch, vict);
  improve_skill(ch, SKILL_MOUNT);

  if (IS_NPC(vict) && !AFF_FLAGGED(vict, AFF_TAMED) && GET_SKILL(ch, SKILL_MOUNT) <= number(1, 101)) {
    act("$N suddenly bucks upwards, throwing you violently to the ground!", FALSE, ch, 0, vict, TO_CHAR);
    act("$n is thrown to the ground as $N violently bucks!", TRUE, ch, 0, vict, TO_NOTVICT);
    act("You buck violently and throw $n to the ground.", FALSE, ch, 0, vict, TO_VICT);
    dismount_char(ch);
    damage(ch, ch, dice(1,3), -1);
  }
}


ACMD(do_dismount) {
  if (!RIDING(ch)) {
    send_to_char("You aren't even riding anything.\r\n", ch);
    return;
  } else if (SECT(ch->in_room) == SECT_WATER_NOSWIM && !has_boat(ch)) {
    send_to_char("Yah, right, and then drown...\r\n", ch);
    return;
  }

  act("You dismount $N.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
  act("$n dismounts from you.", FALSE, ch, 0, RIDING(ch), TO_VICT);
  act("$n dismounts $N.", TRUE, ch, 0, RIDING(ch), TO_NOTVICT);
  dismount_char(ch);
}


ACMD(do_buck) {
  if (!RIDDEN_BY(ch)) {
    send_to_char("You're not even being ridden!\r\n", ch);
    return;
  } else if (AFF_FLAGGED(ch, AFF_TAMED)) {
    send_to_char("But you're tamed!\r\n", ch);
    return;
  }

  act("You quickly buck, throwing $N to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_CHAR);
  act("$n quickly bucks, throwing you to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_VICT);
  act("$n quickly bucks, throwing $N to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_NOTVICT);
  GET_POS(RIDDEN_BY(ch)) = POS_SITTING;
  dismount_char(ch);

  if (number(0, 4)) {
    send_to_char("You hit the ground hard!\r\n", ch);
    damage(ch, ch, dice(10,4), -1);
  }

  /* you might want to call set_fighting() or some non-sense here if you
     / want the mount to attack the unseated rider or vice-versa.*/
  /*This is not my code here check out credits */
}


ACMD(do_tame) {
  char arg[MAX_INPUT_LENGTH];
  struct affected_type af;
  struct char_data *vict;

  one_argument(argument, arg);

  if (!arg || !*arg) {
    send_to_char("Tame who?\r\n", ch);
    return;
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("They're not here.\r\n", ch);
    return;
  } else if (GET_LEVEL(ch) < LVL_IMMORT && IS_NPC(vict) && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
    send_to_char("You can't do that to them.\r\n", ch);
    return;
  } else if (!GET_SKILL(ch, SKILL_TAME)) {
    send_to_char("You don't even know how to tame something.\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You can't do that.\r\n", ch);
    return;
  } else if (GET_SKILL(ch, SKILL_TAME) <= number(1, 101)) {
    send_to_char("You fail to tame it.\r\n", ch);
    return;
  }
  improve_skill(ch, SKILL_TAME);

  af.type = SKILL_TAME;
  af.duration = 24;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_TAMED;
  affect_join(vict, &af, FALSE, FALSE, FALSE, FALSE, FALSE);

  act("You tame $N.", FALSE, ch, 0, vict, TO_CHAR);
  act("$n tames you.", FALSE, ch, 0, vict, TO_VICT);
  act("$n tames $N.", FALSE, ch, 0, vict, TO_NOTVICT);
}

ACMD(do_disembark)
{
  /* The actual functionality for this exists in spec_procs.c */
  return;
}

struct current_info current[] = {
/*  Room  Direction Percent
   -------------------------  */
  { 1204, WEST,    50 },
  {23242, DOWN, 20},
  {23241, DOWN, 75},
  {23240, DOWN, 70},
  {23239, DOWN, 80},
  {23238, DOWN, 80},
  {23237, DOWN, 90},
  {23000, DOWN, 90},
  {23001, SOUTH, 90},
  { -1, -1, -1 }
};
@


1.173
log
@Fix all warnings for "the address of X will always evaluate to 'true'",
where X is a variable.
@
text
@/***************************************************************************
 * $Id: act.movement.c,v 1.172 2010/06/05 04:43:57 mud Exp myc $
 ***************************************************************************/
/***************************************************************************
 *   File: act.movement.c                                 Part of FieryMUD *
 *  Usage: movement commands, door handling, & sleep/rest/etc state        *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <math.h>

#include "structs.h"
#include "utils.h"
#include "constants.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "casting.h"
#include "house.h"
#include "dg_scripts.h"
#include "weather.h"
#include "races.h"
#include "skills.h"
#include "events.h"
#include "math.h"
#include "screen.h"
#include "regen.h"
#include "exits.h"
#include "rooms.h"
#include "fight.h"
#include "magic.h"
#include "modify.h"
#include "act.h"
#include "movement.h"
#include "composition.h"
#include "charsize.h"
#include "board.h"
#include "directions.h"

/* external vars  */
extern int pk_allowed;

/* external functs */
int special(struct char_data *ch, int cmd, char *arg);
void appear(struct char_data *ch);
bool senses_living(struct char_data *ch, struct char_data *vict, int basepct); /* act.informative.c */

#define BLOOD_DROP_OBJ     34   /* the vnum of the blood object */
#define BLOOD_POOL_OBJ     35   /* the vnum of the blood object */

void spill_blood(struct char_data *ch) {
  struct obj_data *obj, *next;

  if (GET_HIT(ch) > (GET_MAX_HIT(ch) * 3) / 10)
    return;

  if (ch->in_room == NOWHERE)
    return;

  for (obj = world[ch->in_room].contents; obj; obj = next) {
    next = obj->next_content;
    if (GET_OBJ_VNUM(obj) == 34 || GET_OBJ_VNUM(obj) == 35)
      extract_obj(obj);
  }

  if (GET_HIT(ch) > GET_MAX_HIT(ch) / 10) {
    obj = read_object(BLOOD_POOL_OBJ, VIRTUAL);
    GET_OBJ_DECOMP(obj) = 3;
  }
  else {
    obj = read_object(BLOOD_DROP_OBJ, VIRTUAL);
    GET_OBJ_DECOMP(obj) = 2;
  }

  GET_OBJ_VAL(obj, 0) = ch->in_room;
  obj_to_room(obj, ch->in_room);
}

int do_misdirected_move(struct char_data *actor, int dir)
{
   struct char_data *people;
   char mmsg[MAX_STRING_LENGTH];
   char rmsg[MAX_STRING_LENGTH];

   sprintf(mmsg, "$n %s %s.",
         movewords(actor, dir, actor->in_room, TRUE), dirs[dir]);
   sprintf(rmsg, "$n's &5illusion &0%s %s.",
         movewords(actor, dir, actor->in_room, TRUE), dirs[dir]);

   LOOP_THRU_PEOPLE(people, actor) {
      if (actor == people) {
         sprintf(buf, "Your &5illusion&0 %s %s.\r\n",
            movewords(actor, dir, actor->in_room, TRUE), dirs[dir]);
         send_to_char(buf, actor);
      } else if (!AWAKE(people))
         ;
      else if (SEES_THROUGH_MISDIRECTION(people, actor))
         act(rmsg, FALSE, actor, 0, people, TO_VICT);
      else
         act(mmsg, FALSE, actor, 0, people, TO_VICT);
   }

   return 1;
}

bool try_to_sense_arrival(struct char_data *observer, struct char_data *mover)
{
   if (senses_living(observer, mover, 50)) {
      send_to_char("You sense that a living creature has arrived.\r\n", observer);
      return TRUE;
   } else {
      return FALSE;
   }
}


bool try_to_sense_departure(struct char_data *observer, struct char_data *mover)
{
   if (senses_living(observer, mover, 50)) {
      send_to_char("You feel that a living creature has departed.\r\n", observer);
      return TRUE;
   } else {
      return FALSE;
   }
}

void observe_char_leaving(struct char_data *observer, struct char_data *mover,
      struct char_data *mount, char *msg, int direction)
{
   if (observer == mover || observer == mount || !AWAKE(observer))
      return;

   if (observer == RIDING(mover)) {
      sprintf(buf, "%s you.", msg);
      act(buf, FALSE, mover, 0, observer, TO_VICT);
      return;
   }

   if (mount) {
      /* MOUNTED MOVEMENT */
      if (CAN_SEE(observer, mount) || CAN_SEE(observer, mover)) {
         sprintf(buf, "%s %s.", msg, CAN_SEE(observer, mount) ?
            GET_NAME(mount) : "something");
         act(buf, FALSE, mover, 0, observer, TO_VICT);
      } else if (CAN_SEE_BY_INFRA(observer, mover) || CAN_SEE_BY_INFRA(observer, mount)) {
         sprintf(buf, "&1&bA %s-sized creature rides %s on a %s mount.&0\r\n",
               SIZE_DESC(mover),
               dirs[direction],
               SIZE_DESC(mount));
         send_to_char(buf, observer);
      } else if (!try_to_sense_departure(observer, mount)) {
         /* Try sensing because it's too dark or mover is invis
          * (sneaking and misdirection do not apply when mounted) */
         try_to_sense_departure(observer, mover);
      }
   /* NO MOUNT */
   } else if (EFF_FLAGGED(mover, EFF_MISDIRECTING)) {
      if (SEES_THROUGH_MISDIRECTION(observer, mover))
         act(msg, FALSE, mover, 0, observer, TO_VICT);
   } else if (!CAN_SEE(observer, mover)) {
      if (CAN_SEE_BY_INFRA(observer, mover)) {
         sprintf(buf1, "&1&bA %s-sized creature leaves %s.&0\r\n",
                  SIZE_DESC(mover),
                  dirs[direction]);
         send_to_char(buf1, observer);
      } else {
         /* Try sensing because it's too dark, or mover is invis */
         try_to_sense_departure(observer, mover);
      }
   } else if (!IS_HIDDEN(mover) && !OUTDOOR_SNEAK(mover) && !EFF_FLAGGED(mover, EFF_SNEAK))
      act(msg, FALSE, mover, 0, observer, TO_VICT);
   else if (GET_LEVEL(observer) >= LVL_IMMORT ?
              GET_LEVEL(observer) >= GET_LEVEL(mover) :
              GET_PERCEPTION(observer) >= GET_HIDDENNESS(mover))
      act(msg, FALSE, mover, 0, observer, TO_VICT);
   else
      /* Try sensing because mover is sneaking */
      try_to_sense_departure(observer, mover);
}

void observe_char_arriving(struct char_data *observer, struct char_data *mover,
      struct char_data *mount, char *mountmsg, char *stdmsg, int direction)
{
   if (observer == mover || observer == mount || !AWAKE(observer))
      return;

   if (mount) {
      /* MOUNTED MOVEMENT */
      sprintf(buf2, "%s%s.", mountmsg,
         CAN_SEE(observer, mount) ? GET_NAME(mount) : "something");
      if (CAN_SEE(observer, mount) || CAN_SEE(observer, mover)) {
         act(buf2, FALSE, mover, 0, observer, TO_VICT);
      } else if (CAN_SEE_BY_INFRA(observer, mover) || CAN_SEE_BY_INFRA(observer, mount)) {
         sprintf(buf1, "&1&bA %s-sized creature arrives from %s%s, riding a %s mount.&0\r\n",
               SIZE_DESC(mover),
               (direction < UP  ? "the " : ""),
               (direction == UP ? "below": direction == DOWN ? "above" : dirs[rev_dir[direction]]),
               SIZE_DESC(mount));
         send_to_char(buf1, observer);
      } else if (!try_to_sense_arrival(observer, mount)) {
         try_to_sense_arrival(observer, mover);
      }
   /* NO MOUNT */
   } else if (!CAN_SEE(observer, mover)) {
      /* Invisibility or darkness - try to see by infra, or sense life. */
      if (CAN_SEE_BY_INFRA(observer, mover)) {
         sprintf(buf1, "&1&bA %s-sized creature arrives from %s%s.&0\r\n",
                  SIZE_DESC(mover),
                  (direction < UP  ? "the " : ""),
                  (direction == UP ? "below": direction == DOWN ? "above" : dirs[rev_dir[direction]]));
         send_to_char(buf1, observer);
      } else {
         try_to_sense_arrival(observer, mover);
      }
   } else if (!IS_HIDDEN(mover) && !OUTDOOR_SNEAK(mover) && !EFF_FLAGGED(mover, EFF_SNEAK))
      /* No invisibility, darkness, or sneaking - mover is visible */
      act(stdmsg, FALSE, mover, 0, observer, TO_VICT);
   else if (PRF_FLAGGED(observer, PRF_HOLYLIGHT) ?
            GET_LEVEL(observer) >= GET_LEVEL(mover) :
            GET_PERCEPTION(observer) >= GET_HIDDENNESS(mover))
      act(stdmsg, FALSE, mover, 0, observer, TO_VICT);
      /* Not visible by any standard means - try to sense life */
   else
      try_to_sense_arrival(observer, mover);
}

/* do_simple_move assumes
 *    1. That there is no master and no followers.
 *    2. That the direction exists.
 */

bool do_simple_move(struct char_data *ch, int dir, int need_specials_check)
{
   int flying = 0, levitating = 0;
   bool boat;
   int need_movement, vnum;
   char mmsg[MAX_STRING_LENGTH];
   char tmp[MAX_STRING_LENGTH];
   struct char_data *observer;

   /* Possible situations:
    *                             Actor           Motivator      Mount
    * 1. ch alone                 ch              ch             NULL
    * 2. ch mounted upon someone  ch              RIDING(ch)     RIDING(ch)
    * 3. ch ridden by someone     RIDDEN_BY(ch)   ch             ch
    *
    * actor      - the one who is *said* to be moving
    * motivator  - the one who is doing the work
    */
   struct char_data *actor = ch, *motivator = ch, *mount = NULL;
   int was_in = IN_ROOM(actor);

  /*
   * Check for special routines (North is 1 in command list, but 0 here) Note
   * -- only check if following; this avoids 'double spec-proc' bug
   */
   if (need_specials_check && special(ch, dir + 1, ""))
      return FALSE;

   /* Check in room afterwards in case there was a teleport in the trigger. */
   if (!leave_mtrigger(ch, dir) || IN_ROOM(ch) != was_in)
     return FALSE;
   if (!leave_wtrigger(&world[IN_ROOM(ch)], ch, dir) || IN_ROOM(ch) != was_in)
     return FALSE;
   if (!leave_otrigger(&world[IN_ROOM(ch)], ch, dir) || IN_ROOM(ch) != was_in)
     return FALSE;

   if (EVENT_FLAGGED(ch, EVENT_GRAVITY) && !EFF_FLAGGED(ch, EFF_LEVITATE)) {
      send_to_char("You're in free fall!\r\n", ch);
      return FALSE;
   }

   if (EFF_FLAGGED(ch, EFF_IMMOBILIZED)) {
      send_to_char("You're unable to move!\r\n", ch);
      return FALSE;
   }

   /* Work out who's the actor and who's the motivator */

   if (RIDING(ch)) {
      /* Sanity check - are you in the same room as your mount? */
      if (IN_ROOM(ch) == IN_ROOM(RIDING(ch)))
         motivator = RIDING(ch);
      else {
         sprintf(buf, "do_simple_move: %s is at %d, while mount %s is at %d",
               GET_NAME(ch), IN_ROOM(ch), GET_NAME(RIDING(ch)), IN_ROOM(RIDING(ch)));
         mudlog(buf, NRM, LVL_IMMORT, FALSE);
      }
      mount = motivator;
   } else if (RIDDEN_BY(ch)) {
      /* Sanity check - are you in the same room as your rider? */
      if (IN_ROOM(ch) == IN_ROOM(RIDDEN_BY(ch)))
         actor = RIDDEN_BY(ch);
      else {
         sprintf(buf, "do_simple_move: %s is at %d, while rider %s is at %d",
               GET_NAME(ch), IN_ROOM(ch), GET_NAME(RIDDEN_BY(ch)), IN_ROOM(RIDDEN_BY(ch)));
         mudlog(buf, NRM, LVL_IMMORT, FALSE);
      }
      mount = motivator;
   }

   /* Is mount standing and conscious? */
   if (mount) {
      if (GET_STANCE(mount) < STANCE_RESTING) {
         sprintf(buf, "You aren't riding $N anywhere while $E's %s.",
               stance_types[GET_STANCE(mount)]);
         act(buf, FALSE, actor, 0, mount, TO_CHAR);
         sprintf(buf, "$n tries to ride the %s $D.", stance_types[GET_STANCE(mount)]);
         act(buf, TRUE, actor, 0, mount, TO_ROOM);
         return FALSE;
      }
      if (GET_POS(mount) < POS_STANDING) {
         sprintf(buf, "You can't ride away on $N while $E's %s.",
               position_types[GET_POS(mount)]);
         act(buf, FALSE, actor, 0, mount, TO_CHAR);
         return FALSE;
      }
      if (GET_STANCE(mount) == STANCE_RESTING) {
         alter_pos(mount, GET_POS(mount), STANCE_ALERT);
         act("$n stops resting and looks ready to head out.", TRUE, mount, 0, 0, TO_ROOM);
      }
   }

   /* BOAT */
   boat = can_travel_on_water(actor) || can_travel_on_water(motivator);

   /* FLYING */
   flying =
      GET_POS(actor) == POS_FLYING ||
      GET_POS(motivator) == POS_FLYING ||
      GET_LEVEL(actor) >= LVL_IMMORT ||
      GET_LEVEL(motivator) >= LVL_IMMORT;

   /* LEVITATING */
   if (!flying &&
         (EFF_FLAGGED(actor, EFF_LEVITATE) ||
          EFF_FLAGGED(motivator, EFF_LEVITATE)))
      levitating = 1;

   /* Determine movement points needed */

   if (GET_LEVEL(motivator) >= LVL_IMMORT)
      need_movement = 0;
   else if (flying)
      need_movement = 1;
   else if (boat && SECT(motivator->in_room) == SECT_SHALLOWS)
      need_movement = 2;
   else
      need_movement = (sectors[SECT(CH_NDEST(motivator, dir))].mv
            + sectors[SECT(motivator->in_room)].mv) / 2;

   if (levitating && need_movement > 2)
      need_movement = 2;

   /* Do you have enough energy? */

   if (GET_MOVE(motivator) < need_movement) {
      if (need_specials_check && motivator->master)
         send_to_char("You are too exhausted to follow.\r\n", motivator);
      else
         send_to_char("You are too exhausted.\r\n", motivator);
      if (mount) {
         if (need_specials_check && motivator->master)
            send_to_char("Your mount is too exhausted to follow.\r\n", actor);
         else
            send_to_char("You mount is too exhausted.\r\n", actor);
      }
      return FALSE;
   }

   /* What to do if a mount attempts to wander */

   if (mount && ch != actor) {

      /* A tamed mount shouldn't wander off while you're mounted upon it */
      if (EFF_FLAGGED(ch, EFF_TAMED))
         send_to_char("You've been tamed.  Now act it!\r\n", ch);

      /* A non-tamed mount will attempt to buck instead of wandering, during a fight */
      else if (FIGHTING(actor) && movement_bucked(actor, mount)) {
         act("$N rears backwards, throwing you to the ground.",
               FALSE, actor, 0, mount, TO_CHAR);
         act("You rear backwards, throwing $n to the ground.",
               FALSE, actor, 0, mount, TO_VICT);
         act("$N rears backwards, throwing $n to the ground.",
               FALSE, actor, 0, mount, TO_NOTVICT);
         improve_skill(actor, SKILL_RIDING);
         damage(actor, actor, dice(1,6), -1);
         dismount_char(actor);
      }

      return FALSE;
   }

   /* If load 90% and over, bite the dust. */
   if (!mount && !flying && CURRENT_LOAD(actor) >= 9 && GET_LEVEL(actor) < LVL_IMMORT) {
      act("You stagger about, then fall under your heavy load.",
            FALSE, actor, 0, 0, TO_CHAR);
      act("$n staggers about, then collapses under $s heavy load.",
            TRUE, actor, 0, 0, TO_ROOM);
      alter_pos(actor, POS_SITTING, STANCE_ALERT);
      return FALSE;
   }

   /* Charmed critters can't wander off (unless animated) */
   if (EFF_FLAGGED(actor, EFF_CHARM) && !MOB_FLAGGED(actor, MOB_ANIMATED) &&
            actor->master && actor->in_room == actor->master->in_room) {
      send_to_char("The thought of leaving your master makes you weep.\r\n", actor);
      return FALSE;
   }

   /* check for a wall in room */
   if (wall_block_check(actor, motivator, dir))
      return FALSE;

   /* Fishes and the like can't enter land rooms. */
   if (MOB_FLAGGED(actor, MOB_AQUATIC) && !flying) {
     if (!IS_WATER(actor->in_room)) {
       send_to_char("There isn't enough water here to swim that way!\r\n", actor);
       act("$n flounders on the ground, gasping for air!", FALSE, actor, 0, 0, TO_ROOM);
       return FALSE;
     }
     if (!IS_WATER(CH_NDEST(actor, dir)) &&
         SECT(CH_NDEST(actor, dir)) != SECT_AIR) {
       send_to_char("You can't swim that way!\r\n", actor);
       return FALSE;
     }
   }
   else if (mount && MOB_FLAGGED(mount, MOB_AQUATIC) && !flying) {
     if (!IS_WATER(actor->in_room)) {
       send_to_char("There isn't enough water here to swim that way!\r\n", actor);
       act("$n flounders on the ground, gasping for air!", FALSE, mount, 0, 0, TO_ROOM);
       return FALSE;
     }
     if (!IS_WATER(CH_NDEST(actor, dir)) &&
         SECT(CH_NDEST(actor, dir)) != SECT_AIR) {
       act("$N can't swim that way!", FALSE, actor, 0, mount, TO_CHAR);
       return FALSE;
     }
   }

   if ((SECT(actor->in_room) == SECT_AIR) ||
         (SECT(CH_NDEST(actor, dir)) == SECT_AIR)) {
      if (!flying && dir == UP) {
         send_to_char("&7Try flapping your wings.&0\r\n", actor);
         return FALSE;
      }
   }

   /* We need either a boat or fly spell in water rooms */
   if ((SECT(actor->in_room) == SECT_WATER) ||
         (SECT(CH_NDEST(actor, dir)) == SECT_WATER)) {
      if (!boat && !flying) {
         send_to_char("You need a boat or wings to go there.\r\n", actor);
         return FALSE;
      }
   }

   /* Riding check for each move to see if the rider gets tossed */

   if (mount) {
      improve_skill(actor, SKILL_RIDING);
      if (movement_bucked(actor, mount)) {
         act("$N rears backwards, throwing you to the ground.",
               FALSE, actor, 0, mount, TO_CHAR);
         act("You rear backwards, throwing $n to the ground.",
               FALSE, actor, 0, mount, TO_VICT);
         act("$N rears backwards, throwing $n to the ground.",
               FALSE, actor, 0, mount, TO_NOTVICT);
         dismount_char(actor);
         damage(actor, actor, dice(1, 6), -1);
         return FALSE;
      }
   }

   vnum = CH_VDEST(actor, dir);

   if (ROOM_FLAGGED(CH_NROOM(actor), ROOM_ATRIUM)) {
      if (!House_can_enter(actor, vnum)) {
         send_to_char("That's private property -- no trespassing!\r\n", actor);
         return FALSE;
      }
   }

   if (ROOM_FLAGGED(CH_NDEST(actor, dir), ROOM_TUNNEL)) {
      if (mount) {
         send_to_char("There isn't enough room there, while mounted.\r\n", actor);
         return FALSE;
      }
      if (num_pc_in_room(CH_DEST(actor, dir)) > 1) {
         send_to_char("There isn't enough room there for more than one person!\r\n", actor);
         return FALSE;
      }
   }

   /* see if an entry trigger disallows the move */
   if (!entry_mtrigger(actor, vnum))
      return FALSE;
   if (!preentry_wtrigger(CH_DEST(actor, dir), actor, dir))
      return FALSE;

   /* Don't allow people in god rooms (unless following a deity) */
   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (ch->master) {
         if (GET_LEVEL(ch->master) < LVL_IMMORT) {
            if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
               send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
               return FALSE;
            }
         } else {
            if (ch->master->in_room != CH_NDEST(ch, dir)) {
               if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
                  send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
                  return FALSE;
               }
            }
         }
      } else {
         if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
            send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
            return FALSE;
         }
      }
   }

   /* alter the need_movement depending on wind direction and speed */
   if (CH_OUTSIDE(motivator) &&
         (zone_table[world[motivator->in_room].zone]).wind_speed >= WIND_GALE) {
      if ((zone_table[world[motivator->in_room].zone]).wind_dir == (dir + 2) % 4) {
         need_movement *= 2;
         send_to_char("The wind beats hard upon your body as you forge ahead.\r\n", actor);
      }
   }

   /* If camouflaged and entering a building, snap into visibility */
   if (EFF_FLAGGED(ch, EFF_CAMOUFLAGED) && INDOORS(CH_NDEST(actor, dir))) {
     send_to_char("You reveal yourself as you step indoors.\r\n", ch);
     effect_from_char(ch, SPELL_NATURES_EMBRACE);
     GET_HIDDENNESS(ch) = 0;
   }

   alter_move(motivator, need_movement);

   if (mount) {
      sprintf(buf2, "You ride %s on %s.\r\n", dirs[dir], PERS(mount, actor));
      act(buf2, TRUE, actor, 0, 0, TO_CHAR);
      sprintf(mmsg, "$n rides %s on", dirs[dir]);
   } else {
      sprintf(mmsg, "$n %s %s.", movewords(actor, dir, actor->in_room, TRUE), dirs[dir]);
   }

   if (IS_HIDDEN(motivator) || EFF_FLAGGED(motivator, EFF_SNEAK)) {
     if (EFF_FLAGGED(motivator, EFF_SNEAK)) {
       if (!IS_NPC(motivator))
         GET_HIDDENNESS(motivator) = MAX(0, GET_HIDDENNESS(motivator) - number(2, 5));
     }
     /* Camouflage makes you lose minimal hide points per move */
     else if (EFF_FLAGGED(motivator, EFF_CAMOUFLAGED))
       GET_HIDDENNESS(motivator) = MAX(0, GET_HIDDENNESS(motivator) - number(3, 7));
     /* Chance for hiddenness to decrease with a bonus for dex apply
      * and for already sneaking. */
     else if (number(1, 101) > GET_SKILL(motivator, SKILL_SNEAK) +
         dex_app_skill[GET_DEX(motivator)].sneak + 15)
       GET_HIDDENNESS(motivator) = MAX(0, GET_HIDDENNESS(motivator) - GET_LEVEL(motivator) / 2);
     if (!IS_HIDDEN(motivator))
       effect_from_char(motivator, SPELL_NATURES_EMBRACE);
     if (GET_SKILL(motivator, SKILL_SNEAK))
       improve_skill(motivator, SKILL_SNEAK);
     if (GET_SKILL(motivator, SKILL_STEALTH))
       improve_skill(motivator, SKILL_STEALTH);
   }

   LOOP_THRU_PEOPLE(observer, actor) {
      observe_char_leaving(observer, actor, mount, mmsg, dir);
   }

   /* BLOOD TRAILS (pk only) */
   if (pk_allowed)
     spill_blood(actor);

   /* If the room is affected by a circle of fire, damage the person */
   if (ROOM_EFF_FLAGGED(actor->in_room, ROOM_EFF_CIRCLE_FIRE) &&
         !EFF_FLAGGED(actor, EFF_NEGATE_HEAT)) {
      if (GET_LEVEL(actor) < LVL_IMMORT) {
         mag_damage(GET_LEVEL(actor) + number(1, 10), actor, actor,
               SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
      }
      if (mount && GET_LEVEL(mount) < LVL_IMMORT) {
         mag_damage(GET_LEVEL(mount) + number(1, 10), mount, mount,
               SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
      }
      if (DECEASED(actor) || (mount && DECEASED(mount)))
         return FALSE;
   }

   /* At last, it is time to actually move */
   char_from_room(actor);
   char_to_room(actor, world[was_in].exits[dir]->to_room);
   if (mount) {
      char_from_room(mount);
      char_to_room(mount, actor->in_room);
      look_at_room(mount, TRUE);

      sprintf(tmp, "$n arrives from %s%s, riding ",
            (dir < UP  ? "the " : ""),
            (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
   } else {
      sprintf(buf, "$n %s from %s%s.", movewords(actor, dir, actor->in_room, FALSE),
            (dir < UP  ? "the " : ""),
            (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
   }

   LOOP_THRU_PEOPLE(observer, actor) {
      observe_char_arriving(observer, actor, mount, tmp, buf, dir);
   }

   /* If the room is affected by a circle of fire, damage the person */
   /* if it dies, don't do anything else */
   if (ROOM_EFF_FLAGGED(actor->in_room, ROOM_EFF_CIRCLE_FIRE) &&
         !EFF_FLAGGED(actor, EFF_NEGATE_HEAT)) {
      mag_damage(GET_LEVEL(actor) + number(1, 5), actor, actor,
            SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
      if (DECEASED(actor))
         return TRUE;
   }

   if (actor->desc != NULL)
      look_at_room(actor, FALSE);

   if (!greet_mtrigger(actor, dir)) {
      if (DECEASED(actor))
         return FALSE;
      char_from_room(actor);
      char_to_room(actor, was_in);
      look_at_room(actor, TRUE);
   }

   /* Check for post-entry triggers */

   postentry_wtrigger(actor, dir);
   /* Please leave this death check, in case anything substantive ever
    * gets added beyond this point. The trigger may kill the actor. */
   if (DECEASED(actor))
      return TRUE;

   return TRUE;
}


bool perform_move(struct char_data *ch, int dir, int need_specials_check, bool misdirection)
{
  room_num was_in, to_room;
  struct follow_type *k, *next;

  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS)
    return 0;
  else if (!misdirection && !check_can_go(ch, dir, FALSE))
    return 0;
  else {
    if (!ch->followers) {
      if (misdirection)
        return do_misdirected_move(ch, dir);
      else
        return do_simple_move(ch, dir, need_specials_check);
    }

    /* Could the followers see the leader before he leaves? */
    for (k = ch->followers; k; k = k->next)
      if (CAN_SEE_MOVING(k->follower, ch))
        k->can_see_master = TRUE;
      else
        k->can_see_master = FALSE;

    was_in = ch->in_room;
    /* During misdirection, there might not even be an exit... */
    if (!CH_EXIT(ch, dir))
       to_room= NOWHERE;
    else
       to_room = CH_NDEST(ch, dir);

    if (misdirection)
      do_misdirected_move(ch, dir);
    else if (!do_simple_move(ch, dir, need_specials_check))
      /* Failed the move for some reason.  No one follows. */
      return 0;

      for (k = ch->followers; k; k = next) {
         next = k->next;
         if (k->follower->in_room != to_room &&
               k->follower->in_room == was_in &&
               GET_POS(k->follower) >= POS_STANDING &&
               !FIGHTING(k->follower) &&
               !CASTING(k->follower) &&
               k->can_see_master) {
            if (CONFUSED(k->follower) && number(1, 5) == 1) {
               act("&5You tried to follow $N&0&5, but got all turned around.&0",
                     FALSE, k->follower, 0, ch, TO_CHAR);
               perform_move(k->follower, number(0, 5), 1, FALSE);
               if (IN_ROOM(k->follower) != IN_ROOM(ch))
                  act("&3Oops!  $n&0&3 seems to have wandered off again.&0",
                        FALSE, k->follower, 0, ch, TO_VICT);
            } else {
               act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
               perform_move(k->follower, dir, 1, FALSE);
            }
         }
      }
      return 1;
   }
   return 0;
}


ACMD(do_move)
{
  /*
   * This is basically a mapping of cmd numbers to perform_move indices.
   * It cannot be done in perform_move because perform_move is called
   * by other functions which do not require the remapping.
   */

  int misdir;

  one_argument(argument, arg);

  if (*arg && EFF_FLAGGED(ch, EFF_MISDIRECTION) &&
        subcmd >= SCMD_STAY && subcmd <= SCMD_DOWN) {

     if (RIDING(ch) || RIDDEN_BY(ch)) {
        send_to_char("You can't misdirect people while riding.\r\n", ch);
        return;
     }

     if (!strncmp("st", arg, 2)) {
        /* Misdirection is "stay" */
        misdir = -1;
     } else {
        misdir = parse_direction(arg);
        if (misdir < 0) {
           send_to_char("That isn't a direction.\r\n", ch);
           return;
        }
     }

     if (misdir > -1)
        perform_move(ch, misdir, 0, TRUE);
     SET_FLAG(EFF_FLAGS(ch), EFF_MISDIRECTING);
     /* Send confused people off in a random direction. */
     if (CONFUSED(ch) && number(0, 1) == 0) {
       send_to_char("&5You are confused!&0\r\n", ch);
       subcmd = SCMD_STAY + number(1, 6);
     }
     perform_move(ch, subcmd - 1, 0, FALSE);
     REMOVE_FLAG(EFF_FLAGS(ch), EFF_MISDIRECTING);
     return;
  }

  /* Send confused people off in a random direction. */
  if (CONFUSED(ch) && number(0, 1) == 0) {
    send_to_char("&5You are confused!&0\r\n", ch);
    subcmd = SCMD_STAY + number(1, 6);
  }

  switch (subcmd) {
    case SCMD_STAY:
       send_to_char("Ok, you stay put.\r\n", ch);
       break;
    case SCMD_NORTH:
    case SCMD_EAST:
    case SCMD_SOUTH:
    case SCMD_WEST:
    case SCMD_UP:
    case SCMD_DOWN:
      perform_move(ch, subcmd - 1, 0, FALSE);
      break;
    default:
      if (argument && *arg &&
          (subcmd = searchblock(arg, dirs, 0)) >= 0)
        perform_move(ch, subcmd, 0, FALSE);
      else
        send_to_char("Which way do you want to go?\r\n", ch);
  }
}


int find_door(struct char_data *ch, char *name, char *dirname, char *cmdname, int quiet)
{
   int dir;
   struct exit *exit;

   if (*dirname) {   /* a direction was specified */

      if ((dir = parse_direction(dirname)) == -1) {  /* Partial Match */
         if (!quiet)
            send_to_char("That's not a direction.\r\n", ch);
         return -1;
      }

      if ((exit = CH_EXIT(ch, dir)) && !EXIT_IS_HIDDEN(exit)) {
         if (exit_has_keyword(exit, name))
            return dir;
         else {
            if (!quiet) {
               sprintf(buf2, "I see no %s there.\r\n", name);
               send_to_char(buf2, ch);
            }
            return -1;
         }
      } else {
         if (!quiet)
            send_to_char("I really don't see how you can close anything there.\r\n", ch);
         return -1;
      }
   } else {            /* try to locate the keyword */
      if (!name || !*name) {
         if (!quiet) {
            sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
            send_to_char(buf2, ch);
         }
         return -1;
      }
      for (dir = 0; dir < NUM_OF_DIRS; dir++) {
         if ((exit = CH_EXIT(ch, dir)) && !EXIT_IS_HIDDEN(exit) &&
               exit_has_keyword(exit, name))
            return dir;
      }
      if (!quiet) {
         sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(name), name);
         send_to_char(buf2, ch);
      }
      return -1;
   }
}


struct obj_data *carried_key(struct char_data *ch, int keyvnum)
{
  struct obj_data *o;

  if (keyvnum < 0 || !ch) return NULL;

  for (o = ch->carrying; o; o = o->next_content)
    if (GET_OBJ_VNUM(o) == keyvnum)
      return o;

  if (GET_EQ(ch, WEAR_HOLD))
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD)) == keyvnum)
      return GET_EQ(ch, WEAR_HOLD);

  if (GET_EQ(ch, WEAR_HOLD2))
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD2)) == keyvnum)
      return GET_EQ(ch, WEAR_HOLD2);

  return NULL;
}

char *cmd_door[] =
{
  "open",
  "close",
  "unlock",
  "lock",
  "pick"
};


/* For the following four functions - for opening, closing, locking, and
 * unlocking objects - it is assumed that the object is a closeable
 * container. The caller should have verified this. */

void open_object(struct char_data *ch, struct obj_data *obj, bool quiet)
{
   /* The object must:
    *
    * 1. Be closed
    * 2. Be unlocked
    */

   if (OBJ_IS_OPEN(obj)) {
      if (!quiet && ch)
         send_to_char("It's already open.\r\n", ch);
      return;
   }

   if (!OBJ_IS_UNLOCKED(obj)) {
      if (!quiet && ch) {
         send_to_char("It seems to be locked.\r\n", ch);
         act("$n tries to open $p, but it's locked.",
               FALSE, ch, obj, 0, TO_ROOM);
      }
      return;
   }

   /* Success. */

   REMOVE_BIT(GET_OBJ_VAL(obj, VAL_CONTAINER_BITS), CONT_CLOSED);

   /* Feedback. */

   if (ch && !quiet) {
      act("$n opens $p.", FALSE, ch, obj, 0, TO_ROOM);
      send_to_char(OK, ch);
   }
}

void close_object(struct char_data *ch, struct obj_data *obj, bool quiet)
{
   /* The object must:
    *
    * 1. Be open
    */

   if (!OBJ_IS_OPEN(obj)) {
      if (!quiet && ch)
         send_to_char("It's already closed.\r\n", ch);
      return;
   }

   /* Success. */

   SET_BIT(GET_OBJ_VAL(obj, VAL_CONTAINER_BITS), CONT_CLOSED);

   /* Feedback. */

   if (ch && !quiet) {
      act("$n closes $p.", FALSE, ch, obj, 0, TO_ROOM);
      send_to_char(OK, ch);
   }
}

void unlock_object(struct char_data *ch, struct obj_data *obj, bool quiet)
{
   int keyvnum;
   struct obj_data *key = NULL;

   /* The object must:
    *
    * 1. Be closed
    * 2. Be locked
    */

   if (OBJ_IS_OPEN(obj)) {
      if (!quiet && ch)
         send_to_char("It's already open!\r\n", ch);
      return;
   }

   /* If you aren't a god, you may need a key. */

   if (ch && GET_LEVEL(ch) < LVL_IMMORT) {
      keyvnum = GET_OBJ_VAL(obj, VAL_CONTAINER_KEY);
      if (keyvnum < 0) {
         if (!quiet)
            send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
         return;
      }
      if (!(key = carried_key(ch, keyvnum))) {
         if (!quiet)
            send_to_char("You don't seem to have the proper key.\r\n", ch);
         return;
      }
   }

   /* Now that the key is known to be in hand, see whether the object
    * is already unlocked. */

   if (OBJ_IS_UNLOCKED(obj)) {
      if (!quiet && ch) {
         if (key) {
            act("You insert $P, only to find that $p isn't locked.",
                  FALSE, ch, obj, key, TO_CHAR);
            act("$n inserts $P into $p, only to find that it isn't locked.",
                  FALSE, ch, obj, key, TO_ROOM);
         } else {
            send_to_char("Oh... it wasn't locked.\r\n", ch);
         }
      }
      return;
   }

   /* Success. */

   REMOVE_BIT(GET_OBJ_VAL(obj, VAL_CONTAINER_BITS), CONT_LOCKED);

   /* Feedback. */

   if (ch && !quiet) {
      if (key) {
         act("$n unlocks $p with $P.", FALSE, ch, obj, key, TO_ROOM);
         act("You unlock $p with $P.", FALSE, ch, obj, key, TO_CHAR);
      } else {
         act("$n unlocks $p.", FALSE, ch, obj, 0, TO_ROOM);
         act("You unlock $p.", FALSE, ch, obj, 0, TO_CHAR);
      }
   }
}

void lock_object(struct char_data *ch, struct obj_data *obj, bool quiet)
{
   int keyvnum;
   struct obj_data *key = NULL;

   /* The object must:
    *
    * 1. Be closed
    * 2. Be unlocked
    */

   if (OBJ_IS_OPEN(obj)) {
      if (!quiet && ch)
         send_to_char("You'll need to close it first.\r\n", ch);
      return;
   }

   /* If you aren't a god, you may need a key. */

   if (ch && GET_LEVEL(ch) < LVL_IMMORT) {
      keyvnum = GET_OBJ_VAL(obj, VAL_CONTAINER_KEY);
      if (keyvnum < 0) {
         if (!quiet)
            send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
         return;
      }
      if (!(key = carried_key(ch, keyvnum))) {
         if (!quiet)
            send_to_char("You don't seem to have the proper key.\r\n", ch);
         return;
      }
   }

   /* Now that the key is known to be in hand, see whether the object
    * is already locked. */

   if (!OBJ_IS_UNLOCKED(obj)) {
      if (!quiet && ch) {
         if (key) {
            act("You insert $P, only to find that $p is already locked.",
                  FALSE, ch, obj, key, TO_CHAR);
            act("$n inserts $P into $p, only to find that it's already locked.",
                  FALSE, ch, obj, key, TO_ROOM);
         } else {
            send_to_char("It seems to be locked already.\r\n", ch);
         }
      }
      return;
   }

   /* Success. */

   SET_BIT(GET_OBJ_VAL(obj, VAL_CONTAINER_BITS), CONT_LOCKED);

   /* Feedback. */

   if (ch && !quiet) {
      if (key) {
         act("$n inserts $P into $p and locks it.", FALSE, ch, obj, key, TO_ROOM);
         act("You insert $P into $p and lock it.", FALSE, ch, obj, key, TO_CHAR);
      } else {
         act("$n locks $p.", FALSE, ch, obj, 0, TO_ROOM);
         act("You lock $p.", FALSE, ch, obj, 0, TO_CHAR);
      }
   }
}

void pick_object(struct char_data *ch, struct obj_data *obj)
{
   struct obj_data *key = NULL;

   if (!ch) {
      mudlog("SYSERR: pick_object() called with no actor", BRF, LVL_GOD, FALSE);
      return;
   }

   /* The object must:
    *
    * 1. Be closed
    * 2. Be locked
    * 3. Be pickable
    */

   if (OBJ_IS_OPEN(obj)) {
      send_to_char("It's already open!\r\n", ch);
      return;
   }

   if (OBJ_IS_UNLOCKED(obj)) {
      send_to_char("Oh... it wasn't locked, after all.\r\n", ch);
      act("$n sets to picking $p, but soon realizes that it isn't locked.",
            FALSE, ch, obj, 0, TO_ROOM);
      return;
   }

   if (OBJ_IS_PICKPROOF(obj)) {
      send_to_char("It resists your attempts to pick it.\r\n", ch);
      act("$n sets to picking $p, but soon gives up.",
            FALSE, ch, obj, 0, TO_ROOM);
      return;
   }

   /* Try your skill. */

   if (number(1, 101) > GET_SKILL(ch, SKILL_PICK_LOCK)) {
      send_to_char("You failed to pick the lock.\r\n", ch);
      improve_skill(ch, SKILL_PICK_LOCK);
      return;
   }

   /* Success. */

   REMOVE_BIT(GET_OBJ_VAL(obj, VAL_CONTAINER_BITS), CONT_LOCKED);

   /* Feedback. */

   act("$n skillfully picks the lock on $p.", FALSE, ch, obj, key, TO_ROOM);
   send_to_char("You skillfully pick the lock.\r\n", ch);
}

void perform_door_action(struct char_data *ch, int subcmd, int door)
{
   if (!SOLIDCHAR(ch) && GET_LEVEL(ch) < LVL_IMMORT) {
      cprintf(ch, "You can't operate doors in your %s%s&0 state.\r\n",
               COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
      return;
   }

   if (!door_mtrigger(ch, subcmd, door) || !door_wtrigger(ch, subcmd, door))
      return;

   switch (subcmd) {
      case SCMD_OPEN:
         open_door(ch, CH_NROOM(ch), door, FALSE);
         break;
      case SCMD_CLOSE:
         close_door(ch, CH_NROOM(ch), door, FALSE);
         break;
      case SCMD_UNLOCK:
         unlock_door(ch, CH_NROOM(ch), door, FALSE);
         break;
      case SCMD_LOCK:
         lock_door(ch, CH_NROOM(ch), door, FALSE);
         break;
      case SCMD_PICK:
         pick_door(ch, CH_NROOM(ch), door);
         break;
      default:
         sprintf(buf, "SYSERR: perform_door_action() called with invalid subcommand %d",
               subcmd);
         mudlog(buf, BRF, LVL_GOD, FALSE);
         cprintf(ch, "Sorry, there's been an internal error.\r\n");
         break;
   }
}

ACMD(do_gen_door)
{
   int door = -1, bits;
   char type[MAX_INPUT_LENGTH], dir[MAX_INPUT_LENGTH];
   struct obj_data *obj = NULL;
   struct char_data *victim = NULL;

   if (FIGHTING(ch)) {
      send_to_char("You are too busy fighting to concentrate on that right now.\r\n",
               ch);
      return;
   }

   skip_spaces(&argument);
   if (!*argument) {
      sprintf(buf, "%s what?\r\n", cmd_door[subcmd]);
      send_to_char(CAP(buf), ch);
      return;
   }

   two_arguments(argument, type, dir);

   /* Identify the thing to be manipulated.
    * If a direction is specified, or no such object could be found, we'll
    * try to find a door. */

   if (*dir ||
            !(bits =
                generic_find(type, FIND_OBJ_EQUIP |
                                   FIND_OBJ_INV |
                                   FIND_OBJ_ROOM,
                             ch, &victim, &obj))) {
      door = find_door(ch, type, dir, cmd_door[subcmd], FALSE);
      if (door > -1) perform_door_action(ch, subcmd, door);
      return;
   }

   if (!obj) return;

   /* If you've named a board and you're trying to lock/unlock
    * it, see if you're allowed to do so. */
   if (GET_OBJ_TYPE(obj) == ITEM_BOARD && 
       (subcmd == SCMD_LOCK || subcmd == SCMD_UNLOCK)) {
     struct board_data *brd = board(GET_OBJ_VAL(obj, VAL_BOARD_NUMBER));
     if (!brd || !has_board_privilege(ch, brd, BPRIV_LOCK))
       send_to_char("You can't figure out how.\r\n", ch);
     else if (subcmd == SCMD_LOCK) {
       if (brd->locked)
         cprintf(ch, "%s is already locked.\r\n", obj->short_description);
       else
         cprintf(ch, "You lock %s, preventing others from posting.\r\n", obj->short_description);
       brd->locked = TRUE;
     }
     else {
       if (brd->locked)
         cprintf(ch, "You unlock %s, allowing others to post.\r\n", obj->short_description);
       else
         cprintf(ch, "%s is already unlocked.\r\n", obj->short_description);
       brd->locked = FALSE;
     }
     return;
   }

   /* If you've named an object that doesn't open/close, you might have
    * intended to manipulate a door. */

   if (!OBJ_IS_OPENABLE(obj)) {
      door = find_door(ch, type, dir, cmd_door[subcmd], TRUE);
      if (door >= 0) {
         perform_door_action(ch, subcmd, door);
      } else {
         cprintf(ch, "You can't %s that.\r\n", cmd_door[subcmd]);
      }
      return;
   }

   /* If you're made of fluid, the only way you can open/close/etc. something
    * is if it's an object in your inventory. */
   if (!SOLIDCHAR(ch) && obj->carried_by != ch && GET_LEVEL(ch) < LVL_IMMORT) {
      cprintf(ch, "You can't manipulate solid objects in your %s%s&0 state.\r\n",
               COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
      return;
   }

   switch (subcmd) {
      case SCMD_OPEN:
         open_object(ch, obj, FALSE);
         break;
      case SCMD_CLOSE:
         close_object(ch, obj, FALSE);
         break;
      case SCMD_UNLOCK:
         unlock_object(ch, obj, FALSE);
         break;
      case SCMD_LOCK:
         lock_object(ch, obj, FALSE);
         break;
      case SCMD_PICK:
         pick_object(ch, obj);
         break;
      default:
         sprintf(buf, "SYSERR: do_gen_door() called with invalid subcommand %d",
               subcmd);
         mudlog(buf, BRF, LVL_GOD, FALSE);
         cprintf(ch, "Sorry, there's been an internal error.\r\n");
         break;
   }
}

const char *portal_entry_messages[] = {
  "&8&b$p &0&b&8flares white as $n enters it and disappears.&0\r\n",
  "&8&b$p &0&b&8flares as $n enters it and disappears.&0\r\n",
  "&8&b$p &0&b&8vibrates violently as $n enters it and then stops.&0\r\n",
  "\n",
};

const char *portal_character_messages[] = {
  "",
  "&8&bYou feel your body being ripped apart!&0\r\n",
  "&8&b$p &0&b&8vibrates violently as you enter.&0\r\n",
  "&8&bYour molecules are ripped apart as you enter $p.&0\r\n",
  "&8&bYou appear in a completely different location!&0\r\n",
  "&9&bYou feel your energy being drained!&0\r\n",
  "&8&bYour molecules are ripped apart as you enter $p.&0\r\n\r\n"
    "&8&bYou catch a glimpse of a giant white leopard!&0\r\n\r\n"
    "&9&bYou feel your energy being drained!&0\r\n",
  "\n",
};

const char *portal_exit_messages[] = {
  "$p flares white as $n emerges from it.\r\n",
  "$p flares as $n emerges from it.\r\n",
  "$n appears from nowhere!\r\n",
  "There is a loud POP sound as $n emerges from $p.\r\n",
  "\n",
};

ACMD(do_enter)
{
  struct obj_data *obj = NULL;
  int i, rnum;

  if (FIGHTING(ch)) {
    send_to_char("You are too busy fighting to leave right now.\r\n",ch);
    return;
  }

  one_argument(argument, arg);

  /* Enter without args: try to enter an adjacent building. */
  if (!*arg) {
    if (ROOM_FLAGGED(CH_NROOM(ch), ROOM_INDOORS))
      send_to_char("You are already indoors.\r\n", ch);
    else
      for (i = 0; i < NUM_OF_DIRS; ++i)
        if (CH_EXIT(ch, i) &&
              !EXIT_IS_CLOSED(CH_EXIT(ch, i)) &&
            ROOM_FLAGGED(CH_NDEST(ch, i), ROOM_INDOORS)) {
          if (CONFUSED(ch)) {
             send_to_char("&5You are confused!&0\r\n", ch);
             i = number(0, 5);
          }
          perform_move(ch, i, 1, FALSE);
          return;
        }
    send_to_char("You can't seem to find anything to enter.\r\n", ch);
    return;
  }

  if (!(obj = find_obj_in_list(world[ch->in_room].contents, find_vis_by_name(ch, arg)))) {
    sprintf(buf, "There is no %s here.\r\n", arg);
    send_to_char(buf, ch);
    return;
  }

  if (GET_OBJ_TYPE(obj) != ITEM_PORTAL) {
    send_to_char("You can't enter that!\r\n", ch);
    return;
  }

  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
    act("You are not experienced enough to use $p.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }

  if ((rnum = real_room(GET_OBJ_VAL(obj, VAL_PORTAL_DESTINATION))) == NOWHERE) {
    act("$p flares for a second then dies down.&0", FALSE, ch, obj, 0, TO_ROOM);
    send_to_char("It flares and then dies down - it must be broken!\r\n", ch);
    return;
  }

  /* Some special cases */
  if (GET_OBJ_VNUM(obj) == OBJ_VNUM_HEAVENSGATE) {
    if (GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500) {
      act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE, ch, obj, 0, TO_CHAR);
      act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.", TRUE, ch, obj, 0, TO_ROOM);
      return;
    }
    else if (GET_ALIGNMENT(ch) <= -500) {
      act("&9&bUpon entering $p&9&b, you begin to &1burn&9... Your screams can be heard throughtout the &7heavens&9...&0", FALSE, ch, obj, 0, TO_CHAR);
      act("&9&b$n&9&b enters $p&9&b... Following a &0&1blood&9&b curdling scream that spans the &7heavens&9, $n&9&b flails back out of the tunnel, &1&bon fire!&0", FALSE, ch, obj, 0, TO_ROOM);
      damage(ch, ch, abs(GET_ALIGNMENT(ch)) / 10, TYPE_SUFFERING);
      SET_FLAG(EFF_FLAGS(ch), EFF_ON_FIRE);
      return;
    }
  }
  else if (GET_OBJ_VNUM(obj) == OBJ_VNUM_HELLGATE) {
    if (GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500) {
      act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE, ch, obj, 0, TO_CHAR);
      act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.", TRUE, ch, obj, 0, TO_ROOM);
      return;
    }
    else if (GET_ALIGNMENT(ch) >= 500) {
      act("&9&bUpon catching a glimpse of &1hell&9 itself, your &0&5mind&9&b twists and distorts... &0", FALSE, ch, obj, 0, TO_CHAR);
      act("&9&b$n&9&b enters $p&9&b... Strange moaning sounds can be heard as $n&9&b wanders back out, twitching and drooling on $mself.&0", FALSE, ch, obj, 0, TO_ROOM);
      damage(ch, ch, abs(GET_ALIGNMENT(ch)) /10, TYPE_SUFFERING);
      mag_affect(70, ch, ch, SPELL_INSANITY, SAVING_SPELL, CAST_SPELL);
      mag_affect(70, ch, ch, SPELL_DISEASE, SAVING_SPELL, CAST_SPELL);
      return;
    }
  }

  /* Display entry message. */
  if (GET_OBJ_VAL(obj, VAL_PORTAL_ENTRY_MSG) >= 0) {
    for (i = 0; i < GET_OBJ_VAL(obj, VAL_PORTAL_ENTRY_MSG) &&
         *portal_entry_messages[i] != '\n' ; ++i);
    if (*portal_entry_messages[i] != '\n')
      act(portal_entry_messages[i], TRUE, ch, obj, 0, TO_ROOM);
  }

  /* Display character message. */
  if (GET_OBJ_VAL(obj, 2) >= VAL_PORTAL_CHAR_MSG) {
    for (i = 0; i < GET_OBJ_VAL(obj, VAL_PORTAL_CHAR_MSG) &&
         *portal_character_messages[i] != '\n'; ++i);
    if (*portal_character_messages[i] != '\n')
      act(portal_character_messages[i], TRUE, ch, obj, 0, TO_CHAR);
  }

  char_from_room(ch);
  char_to_room(ch, rnum);

  /* Display exit message. */
  if (GET_OBJ_VAL(obj, VAL_PORTAL_EXIT_MSG) >= 0) {
    for (i = 0; i < GET_OBJ_VAL(obj, VAL_PORTAL_EXIT_MSG) &&
         *portal_exit_messages[i] != '\n'; ++i);
    if (*portal_exit_messages[i] != '\n')
      act(portal_exit_messages[i], TRUE, ch, obj, 0, TO_ROOM);
  }

  look_at_room(ch, TRUE);

  if (RIDING(ch)) {
    char_from_room(RIDING(ch));
    char_to_room(RIDING(ch), rnum);
    look_at_room(RIDING(ch), TRUE);
  }
}


ACMD(do_leave)
{
  int door;

  if (FIGHTING(ch)) {
    send_to_char("You are too busy fighting to leave!\r\n",ch);
    return;
  }
  if (!ROOM_FLAGGED(CH_NROOM(ch), ROOM_INDOORS))
    send_to_char("You are outside.. where do you want to go?\r\n", ch);
  else {
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (CH_NDEST(ch, door) != NOWHERE)
        if (!EXIT_IS_CLOSED(CH_EXIT(ch, door)) &&
            !ROOM_FLAGGED(CH_NDEST(ch, door), ROOM_INDOORS)) {
          if (CONFUSED(ch)) {
            send_to_char("&5You are confused!&0\r\n", ch);
            door = number(0, 5);
          }
        perform_move(ch, door, 1, FALSE);
        return;
      }
    send_to_char("I see no obvious exits to the outside.\r\n", ch);
  }
}

ACMD(do_doorbash)
#define EXITK(room, dir) (world[room].exits[dir])
#define OPEN_DOORK(room, door) (TOGGLE_BIT(EXITK(room, door)->exit_info,EX_CLOSED))
{
   char arg[MAX_INPUT_LENGTH];
   int dir = 0, chance, probability, dam;
   struct exit *exit;
   struct room_data *dest;
   room_num ndest;
   int was_in = IN_ROOM(ch);

   chance = number(0, 101);

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (FIGHTING(ch)) {
         send_to_char("You can't take time out to do that just yet!\r\n",ch);
         return ;
      }
      if (GET_SIZE(ch) < SIZE_LARGE) {
         send_to_char("&0You do not feel massive enough!&0\r\n", ch);
         return;
      }
      if (!GET_SKILL(ch, SKILL_DOORBASH)) {
         send_to_char("You don't have that skill.", ch);
         return;
      }
      probability = chance + GET_LEVEL(ch);
   } else {
      probability = 101;
   }

   one_argument(argument, arg);
   if (!*arg) {
      cprintf(ch, "What direction?\r\n");
      return;
   }

   if ((dir = parse_direction(arg)) < 0) {
      cprintf(ch, "That isn't a valid direction.\r\n");
      return;
   }

   if (CONFUSED(ch) && number(0, 1) == 0) {
       send_to_char("&5You are confused!&0\r\n", ch);
       dir = number(0, 5);
   }

   /* There can be walls even where there aren't exits.  So now, prior to
    * checking for an exit, we check to see if you're bashing a wall. */

   /* Returns true if you ran into a wall, in which case our work here is done. */
   if (wall_charge_check(ch, dir)) return;

   exit = CH_EXIT(ch, dir);
   if (!exit || EXIT_NDEST(exit) == NOWHERE || EXIT_IS_HIDDEN(exit)) {
      cprintf(ch, "Even YOU couldn't bash through that!\r\n");
      return;
   }

   dest = EXIT_DEST(exit);
   ndest = EXIT_NDEST(exit);

   /* Is the way open already? */
   if (EXIT_IS_OPEN(exit)) {
      cprintf(ch, "There is no obstruction!\r\n");
      return;
   }

   /* Is the exit broken? */
   if (exit->keyword == NULL) {
      mprintf(L_WARN, LVL_GOD,
            "SYSERR:act.item.c:do_doorbash():A one sided door in room %d",
            world[ch->in_room].vnum);
      cprintf(ch, "This exit seems broken.   Please tell a god.\r\n");
      return;
   } else if (!EXIT_IS_DOOR(exit)) {
      mprintf(L_WARN, LVL_GOD,
            "SYSERR:act.item.c:do_doorbash():A closed nondoor exit in room %d",
            world[ch->in_room].vnum);
      cprintf(ch, "This exit seems broken.   Please tell a god.\r\n");
      return;
   }

   /* Established:
    *  - There is an exit that way
    *  - It goes to a room
    *  - It is not hidden
    *  - It is not broken
    *  - It is closed or locked (distinct in this mud...)
    */

   if (EXIT_IS_LOCKED(exit) && (EXIT_IS_PICKPROOF(exit) || chance < 80)) {
      /* You failed, or it was unbashable. */
      cprintf(ch, "You CHARGE at the %s &0but merely bounce off!&0\r\n",
            exit_name(exit));
      sprintf(buf, "$n &0CHARGES at the %s&0 and literally bounces off!",
            exit_name(exit));
      act(buf, FALSE, ch, 0, 0, TO_ROOM);

      if (GET_LEVEL(ch) < LVL_IMMORT) {
         /* You're going to get hurt... */
         dam = ((chance / 10) * (GET_LEVEL(ch) / 10)) + GET_LEVEL(ch);
         /* But you won't die... */
         if (GET_HIT(ch) - dam < -5)
             dam = GET_HIT(ch) + 5;
         hurt_char(ch, NULL, dam, TRUE);
         /* You fell to a sitting position (unless you were knocked out) */
         if (GET_POS(ch) >= POS_STANDING)
            alter_pos(ch, POS_SITTING, STANCE_ALERT);
         WAIT_STATE(ch, PULSE_VIOLENCE * 3);
      }

      room_printf(ndest, "There is a *CRASH* and %s shudders a bit.\r\n",
            exit_name(exit));
      return;
   }

   /* Success */
   OPEN_DOORK(ch->in_room, dir);

   sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", exit_name(exit));
   act(buf, FALSE, ch, 0, 0, TO_ROOM);
   sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n",
         exit_name(exit));
   send_to_char(buf, ch);

   if (dest->exits[rev_dir[dir]]) {
      OPEN_DOORK(ndest, rev_dir[dir]);
   }

   /* This next bit is tricky. I wans to call perform_move so it will handle
    * movement points, circle of fire, etc., but I need to send a message
    * WITH this guy as the subject first. */

   /* The things we do to send a message to the destination room... */
   char_from_room(ch);
   char_to_room(ch, ndest);
   sprintf(buf, "&b&8Splinters and dust fly as $n &0&b&8*CRASHES* into the room!&0");
   act(buf, FALSE, ch, 0, 0, TO_ROOM);
   char_from_room(ch);
   char_to_room(ch, was_in);

   /* Wish this wouldn't send a message, but there would be significant coding to
    * replicate the movement here */
   perform_move(ch, dir, 1, FALSE);
   WAIT_STATE(ch, PULSE_VIOLENCE);
}

void char_drag_entry(struct char_data *ch, struct char_data *vict)
{
   act("&3$n&3 drags $N&3 behind $m.&0", TRUE, ch, 0, vict, TO_NOTVICT);

   /* Get awakened by being dragged? */
   if (GET_STANCE(vict) == STANCE_SLEEPING && !EFF_FLAGGED(vict, EFF_SLEEP)) {
      GET_STANCE(vict) = STANCE_ALERT;

      act("&3You are rudely awakened, and discover $N&3 dragging you along!",
         FALSE, vict, 0, ch, TO_CHAR);
      act("&3$n&3 awakes from $s slumber and looks around.&0", TRUE, vict, 0, 0, TO_ROOM);
   }

   if (AWAKE(vict))
      look_at_room(vict, FALSE);
   else
      send_to_char("Your dreams grow bumpy, as if someone were dragging you...\r\n",
      vict);
}

ACMD(do_drag)
{
  int from_room, to_room, move_cost, found, dir;
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  struct obj_data *portal = NULL;

  argument = one_argument(argument, arg);
  skip_spaces(&argument);

  if (!*arg || !*argument) {
    send_to_char("Drag what? Where?\r\n", ch);
    return;
  }

  if (GET_POS(ch) != POS_STANDING) {
    send_to_char("You don't have the proper leverage to do that.  Try standing.\r\n", ch);
    return;
  }

  /*
   * Start by figuring out what (or whom) we're dragging.
   */
  if (!(found = generic_find(arg, FIND_OBJ_ROOM | FIND_CHAR_ROOM, ch, &tch, &tobj))) {
    send_to_char("Can't find that!\r\n", ch);
    return;
  }

  /* If you're made of fluid, you can only drag a similar person */
  /* (we don't do illusory here because that would give it away
   * also, you might think they're substantial-feeling because that's
   * part of the illusion) */
  if (tobj && !RIGID(ch) && GET_LEVEL(ch) < LVL_IMMORT) {
     sprintf(buf, "You can't handle solid objects in your %s%s&0 condition.\r\n",
           COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
     send_to_char(buf, ch);
     return;
  } else if (tch && GET_LEVEL(ch) < LVL_IMMORT) {
     if (RIGID(ch) && !RIGID(tch)) {
        sprintf(buf, "$N's %s%s&0 seems to pass right through your fingers.",
              COMPOSITION_COLOR(tch), COMPOSITION_MASS(tch));
        act(buf, FALSE, ch, 0, tch, TO_CHAR);
        sprintf(buf, "$n tries to grab $N, but $e can't get a grip on $N's %s%s&0 flesh.",
              COMPOSITION_COLOR(tch), COMPOSITION_ADJECTIVE(tch));
        act(buf, TRUE, ch, 0, tch, TO_NOTVICT);
        sprintf(buf, "$n tries to grab you, but $e can't get a grip on your %s%s&0 flesh.",
              COMPOSITION_COLOR(tch), COMPOSITION_ADJECTIVE(tch));
        act(buf, TRUE, ch, 0, tch, TO_VICT);
        return;
     } else if (!RIGID(ch) && RIGID(tch)) {
        sprintf(buf, "You can't get hold of $N with your %s%s&0 grip.",
              COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
        act(buf, FALSE, ch, 0, tch, TO_CHAR);
        sprintf(buf, "$n tries to grab $N, but $s %s%s&0 fingers can't get a grip.",
              COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
        act(buf, TRUE, ch, 0, tch, TO_NOTVICT);
        sprintf(buf, "$n tries to grab you, but $s %s%s&0 fingers can't get a grip.",
              COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
        act(buf, TRUE, ch, 0, tch, TO_VICT);
        return;
     }
  }

  /* Trying to drag a character? */
  if (found == FIND_CHAR_ROOM) {

    if (ch == tch) {
      send_to_char("One foot in front of the other, now...\r\n", ch);
      return;
    }

    if (GET_LEVEL(ch) < LVL_IMMORT && GET_LEVEL(tch) < LVL_IMMORT) {
      if (IS_NPC(tch)) {
        send_to_char("You can't drag NPC's!\r\n", ch);
        return;
      }

      if (CONSENT(tch) != ch) {
        send_to_char("Not without consent you don't!\r\n", ch);
        return;
      }

      /*
       * The code below can handle the maximum dragging position set to
       * as high as POS_SITTING.  I wouldn't recommend setting it any
       * higher.
       */
      if (GET_POS(tch) > POS_SITTING) {
        act("$N isn't quite relaxed enough to be dragged.", FALSE, ch, 0, tch, TO_CHAR);
        return;
      }

      if (GET_WEIGHT(tch) > 3 * CAN_CARRY_W(ch)) {
        act("$N is too heavy for you to drag.\r\n", FALSE, ch, 0, tch, TO_CHAR);
        return;
      }
    } else if (GET_LEVEL(tch) >= GET_LEVEL(ch) && CONSENT(tch) != ch) {
      /* Immorts can drag anyone, except other immorts of same or higher level */
      send_to_char("You can't drag someone a higher level than you.\r\n", ch);
      return;
    }

    move_cost = MIN(4, GET_WEIGHT(tch) / 50 + sectors[SECT(ch->in_room)].mv);
  }

  /* Trying to drag an object in the room? */
  else if (found == FIND_OBJ_ROOM) {

    if (GET_LEVEL(ch) < LVL_GOD) {
      /*
       * Items can be made draggable by giving them the TAKE wear flag.
       * Here we check for that flag.  But an exception is made so that
       * you can also drag corpses.
       */
      if (!CAN_WEAR(tobj, ITEM_WEAR_TAKE) && !IS_CORPSE(tobj)) {
        send_to_char("You cant drag that!\r\n", ch);
        return;
      }

      if (GET_OBJ_WEIGHT(tobj) > 3 * CAN_CARRY_W(ch)) {
        send_to_char("It is too heavy for you to drag.\r\n", ch);
        return;
      }
    }

    if (IS_PLR_CORPSE(tobj) && !has_corpse_consent(ch, tobj)) {
      mprintf(L_STAT, LVL_IMMORT,
              "CORPSE: %s tried to drag %s without CONSENT!",
              GET_NAME(ch), tobj->short_description);
      return;
    }

    move_cost = MIN(4, GET_OBJ_WEIGHT(tobj) / 50 + sectors[SECT(ch->in_room)].mv);
  }

  else {
    send_to_char("You can't drag that!\r\n", ch);
    return;
  }

  from_room = IN_ROOM(ch);

  /* Now determine the direction. */
  argument = any_one_arg(argument, arg);

  if ((dir = parse_direction(arg)) < 0) {
    /* Not a valid direction.  Try to drag into a portal. */
    if (!(portal = find_obj_in_list(world[from_room].contents, find_vis_by_name(ch, arg)))) {
      sprintf(buf, "Can't find a '%s' to drag into!\r\n", arg);
      send_to_char(buf, ch);
      return;
    }

    if (GET_OBJ_TYPE(portal) != ITEM_PORTAL) {
      send_to_char("You can only drag things into portals!\r\n", ch);
      return;
    }

    if (portal == tobj) {
      act("You tug and pull, but are unable to drag $p into itself.",
          FALSE, ch, tobj, portal, TO_CHAR);
      return;
    }

    if (tobj) {
      act("&3$n&3 drags $p&3 into $P&3.&0", TRUE, ch, tobj, portal, TO_ROOM);
      act("&3You drag $p&3 into $P&3.&0", FALSE, ch, tobj, portal, TO_CHAR);
    }
    else if (tch) {
      act("&3$n&3 drags $N&3 into $p&3.&0", TRUE, ch, portal, tch, TO_NOTVICT);
      act("&3$n&3 drags you into $p&3.&0", TRUE, ch, portal, tch, TO_VICT);
      act("&3You drag $N&3 into $p&3.&0", FALSE, ch, portal, tch, TO_CHAR);
    }
    do_enter(ch, arg, 0, 0);
    to_room = IN_ROOM(ch);
    if (tobj) {
      act("&3$n&3 drags $p&3 from $P.&0", TRUE, ch, tobj, portal, TO_ROOM);
      obj_from_room(tobj);
      obj_to_room(tobj, to_room);
    }
    else if (tch) {
      act("&3$n&3 drags $N&3 from $p.&0", TRUE, ch, portal, tch, TO_ROOM);
      char_from_room(tch);
      char_to_room(tch, to_room);
      char_drag_entry(ch, tch);
    }

    if (tobj && IS_PLR_CORPSE(tobj))
      log("CORPSE: %s dragged %s through %s from room %d to room %d",
          GET_NAME(ch), tobj->short_description,
          strip_ansi(portal->short_description),
          world[from_room].vnum, world[to_room].vnum);
  }

  else {
    /* Try to drag in a direction. */

    if (GET_LEVEL(ch) < LVL_GOD) {
      if (GET_MOVE(ch) < move_cost + 6) {
        send_to_char("You are too exhausted!\r\n", ch);
        return;
      }
    }

    if (CONFUSED(ch)) {
       send_to_char("&5You are confused!&0\r\n", ch);
       dir = number(0, 5);
    }

    /* Take tch from the room so they don't see ch's leave message */
    if (tch)
      char_from_room(tch);
    if (!perform_move(ch, dir, FALSE, FALSE)) {
      if (tch)
        char_to_room(tch, from_room);
      sprintf(buf, "&3Looking confused, $n&0&3 tried to drag $N&0&3 %s.&0",
            dirs[dir]);
      act(buf, FALSE, ch, 0, tch, TO_NOTVICT);
      sprintf(buf, "&3Looking confused, $n&0&3 tried to drag you %s.&0",
            dirs[dir]);
      act(buf, FALSE, ch, 0, tch, TO_VICT);
      return;
    }

    alter_move(ch, move_cost);

    to_room = IN_ROOM(ch);

    /*
     * perform_move was successful, so move ch back to from_room so
     * we can display act() messages
     */
    char_from_room(ch);
    char_to_room(ch, from_room);
    if (tobj) {
      act("&3You drag $p&3 behind you.&0", FALSE, ch, tobj, 0, TO_CHAR);
      act("&3$n&3 drags $p&3 behind $m.&0", TRUE, ch, tobj, 0, TO_ROOM);
    }
    else if (tch) {
      act("&3You drag $N&3 behind you.&0", FALSE, ch, 0, tch, TO_CHAR);
      act("&3$n&3 drags you $t behind $m.&0", TRUE, ch, (void *) dirs[dir], tch, TO_VICT);
      act("&3$n&3 drags $N&3 behind $m.&0", TRUE, ch, 0, tch, TO_NOTVICT);
    }

    /* now display act() messages to the target room */
    char_from_room(ch);
    char_to_room(ch, to_room);
    if (tobj) {
      obj_from_room(tobj);
      obj_to_room(tobj, to_room);
      act("&3$n&3 drags $p&3 behind $m.&0", TRUE, ch, tobj, 0, TO_ROOM);
    }
    else if (tch) {
      /* char_from_room already called above. */
      char_to_room(tch, to_room);
      char_drag_entry(ch, tch);
    }

    if (tobj && IS_PLR_CORPSE(tobj))
      log("CORPSE: %s drags %s from room %d to room %d.",
          GET_NAME(ch), tobj->short_description,
          world[from_room].vnum, world[to_room].vnum);
  }
}

ACMD(do_fly)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("Alas, you cannot summon the will.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         act("You have to wake up first!", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less fly!\r\n", ch);
      return;
   }

   if (!EFF_FLAGGED(ch, EFF_FLY) && GET_LEVEL(ch) < LVL_IMMORT) {
      send_to_char("You do not have the means to fly.\r\n",ch);
      return;
   }

   if (GET_POS(ch) != POS_FLYING && too_heavy_to_fly(ch)) {
      cprintf(ch, "You try to rise up, but you can't get off the ground!\r\n");
      act("$n rises up on $s toes, as if trying to fly.", TRUE, ch, 0, 0, TO_ROOM);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_STANDING:
         act("&6&bYou begin to float.&0", FALSE, ch, 0, 0, TO_CHAR);
         act("&6&b$n&6&b begins to float.&0", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_FLYING:
         send_to_char("You are already flying.\r\n",ch);
         return;
      case POS_PRONE:
      case POS_SITTING:
      case POS_KNEELING:
      default:
         act("&6&bYou get to your feet and begin floating.&0", FALSE, ch, 0, 0, TO_CHAR);
         act("&6&b$n&6&b gets to $s feet and begins to float.&0", TRUE, ch, 0, 0, TO_ROOM);
         break;
   }

   GET_POS(ch) = POS_FLYING;
   GET_STANCE(ch) = FIGHTING(ch) ? STANCE_FIGHTING : STANCE_ALERT;
   mount_pos_check(ch);
}

ACMD(do_stand)
{
   if (IS_NPC(ch)) {
      WAIT_STATE(ch, PULSE_VIOLENCE * 2);
   };

   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("Alas, you cannot summon the will.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         act("You have to wake up first!", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less stand up!\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         act("You sit up and rise to your feet.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n sits up, and rises to $s feet.", FALSE, ch, 0, 0, TO_ROOM);
         break;
      case POS_STANDING:
         act("You are already standing.", FALSE, ch, 0, 0, TO_CHAR);
         return;
         break;
      case POS_FLYING:
         act("You slowly descend to the surface beneath you.",
               FALSE, ch, 0, 0, TO_CHAR);
         act("$n gently descends to the surface beneath $s feet.",
               TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_SITTING:
      case POS_KNEELING:
      default:
         act("You stand up.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
         break;
   }

   GET_POS(ch) = POS_STANDING;
   GET_STANCE(ch) = FIGHTING(ch) ? STANCE_FIGHTING : STANCE_ALERT;
   falling_check(ch);
   mount_pos_check(ch);
}

ACMD(do_sit)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("Alas, you cannot summon the will.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         act("You have to wake up first!", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_FIGHTING:
         act("Sit down while fighting?  Are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less sit down!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too incensed to sit down!\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         act("You sit up.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n sits up.", FALSE, ch, 0, 0, TO_ROOM);
         break;
      case POS_SITTING:
         send_to_char("You're sitting already.\r\n", ch);
         return;
      case POS_KNEELING:
         act("You stop kneeling and sit down.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops kneeling, and sits down.", FALSE, ch, 0, 0, TO_ROOM);
         break;
      case POS_FLYING:
         act("You stop flying and sit down.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops flying and sits down.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_STANDING:
      default:
         act("You sit down.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
         break;
   }

   GET_POS(ch) = POS_SITTING;
   GET_STANCE(ch) = STANCE_ALERT;
   falling_check(ch);
   mount_pos_check(ch);
}


ACMD(do_kneel)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("Alas, you cannot summon the will.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         send_to_char("You seem to be having a dream of infancy.\r\n", ch);
         return;
      case STANCE_FIGHTING:
         act("Kneel while fighting?  Are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too incensed to kneel down!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less get to your knees!\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         act("You swing up onto your knees.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n levers up onto $s knees.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_SITTING:
         act("You move from your butt to your knees.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops sitting and gets to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_KNEELING:
         send_to_char("You are kneeling already.\r\n", ch);
         return;
      case POS_FLYING:
         act("You stop flying and kneel.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops flying and settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_STANDING:
      default:
         act("You kneel.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
   }
   GET_POS(ch) = POS_KNEELING;
   falling_check(ch);
   mount_pos_check(ch);
}

ACMD(do_recline)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("Alas, you cannot summon the will.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         send_to_char("You dream of lying down.\r\n", ch);
         return;
      case STANCE_FIGHTING:
         act("Lie down while fighting?  Are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less lie down!\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too incensed to lie down!\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         send_to_char("You are already lying down.\r\n", ch);
         return;
      case POS_SITTING:
         act("You stop sitting and lie down.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops sitting and lies down.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_KNEELING:
         act("You recline.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n eases off $s knees and lies down.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_FLYING:
         act("You gently land on your belly.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops flying and drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_STANDING:
      default:
         act("You drop to your belly.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);
         break;
   }

   GET_POS(ch) = POS_PRONE;
   falling_check(ch);
   mount_pos_check(ch);
}

ACMD(do_rest)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("You are already resting, after a fashion.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("That is the least of your concerns.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         send_to_char("You seem to be quite restful already.\r\n", ch);
         return;
      case STANCE_RESTING:
         send_to_char("You are already resting.\r\n", ch);
         return;
      case STANCE_FIGHTING:
         act("Rest while fighting?  Are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("In your paralyzed state, you find this impossible.\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too incensed to rest!\r\n", ch);
     return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         send_to_char("You relax.\r\n", ch);
         act("You see some of the tension leave $n's body.", TRUE, ch, 0, 0,
            TO_ROOM);
         break;
      case POS_SITTING:
         act("You find a comfortable spot where you are sitting.", FALSE, ch, 0, 0, TO_CHAR);
         act("$n finds a comfortable spot where $e is sitting.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_KNEELING:
         send_to_char("You slump and relax your posture.\r\n", ch);
         act("$n relaxes a bit.", TRUE, ch, 0, 0, TO_ROOM);
         GET_POS(ch) = POS_SITTING;
         break;
      case POS_FLYING:
         send_to_char("You stop floating and rest your tired bones.\r\n", ch);
         act("$n stops floating and takes a rest.", TRUE, ch, 0, 0, TO_ROOM);
         GET_POS(ch) = POS_SITTING;
         break;
      case POS_STANDING:
      default:
         send_to_char("You sit down and relax.\r\n", ch);
         act("$n sits down in a comfortable spot.", TRUE, ch, 0, 0, TO_ROOM);
         GET_POS(ch) = POS_SITTING;
         break;
   }

   GET_STANCE(ch) = STANCE_RESTING;
   falling_check(ch);
   mount_pos_check(ch);
}

/* new, does opposite of 'rest' */

ACMD(do_alert)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Totally impossible.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("That is utterly beyond your current abilities.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         send_to_char("Let's try this in stages.  How about waking up first?\r\n", ch);
         return;
      case STANCE_ALERT:
         send_to_char("You are already about as tense as you can get.\r\n", ch);
         return;
      case STANCE_FIGHTING:
         send_to_char("Being as you're in a battle and all, you're pretty alert already!\r\n", ch);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("In your paralyzed state, you find this impossible.\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         send_to_char("You stop relaxing and try to become more aware of your surroundings.\r\n", ch);
         break;
      case POS_SITTING:
         send_to_char("You sit up straight and start to pay attention.\r\n", ch);
         act("$n sits at attention.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_KNEELING:
         send_to_char("You straighten up a bit.\r\n", ch);
         act("$n straightens up a bit.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      default:
         send_to_char("You tense up and become more alert.\r\n", ch);
         break;
   }

   GET_STANCE(ch) = STANCE_ALERT;
   mount_pos_check(ch);
}

ACMD(do_sleep)
{
   switch (GET_STANCE(ch)) {
      case STANCE_DEAD:
         act("Rest in peace.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_MORT:
      case STANCE_INCAP:
      case STANCE_STUNNED:
         act("You are beyond sleep.", FALSE, ch, 0, 0, TO_CHAR);
         return;
      case STANCE_SLEEPING:
         send_to_char("You are already sound asleep.\r\n", ch);
         return;
      case STANCE_FIGHTING:
         send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
         return;
   }

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("In your paralyzed state, you find this impossible.\r\n", ch);
      return;
   }

   if (EFF_FLAGGED(ch, EFF_BERSERK)) {
      send_to_char("You're too incensed to take a nap!\r\n", ch);
      return;
   }

   switch (GET_POS(ch)) {
      case POS_PRONE:
         send_to_char("You go to sleep.\r\n", ch);
         act("$n goes to sleep.", TRUE, ch, 0, 0, TO_ROOM);
         break;
      case POS_FLYING:
         act("You stop floating, and lie down to sleep.",
               FALSE, ch, 0, 0, TO_CHAR);
         act("$n stops floating, and lies down to sleep.",
               TRUE, ch, 0, 0, TO_ROOM);
         break;
      default:
         send_to_char("You lie down and go to sleep.\r\n", ch);
         act("$n lies down and goes to sleep.", TRUE, ch, 0, 0, TO_ROOM);
   }

   GET_POS(ch) = POS_PRONE;
   GET_STANCE(ch) = STANCE_SLEEPING;
   falling_check(ch);
   mount_pos_check(ch);
}


ACMD(do_wake)
{
  struct char_data *vict;
  int self = 0;

  one_argument(argument, arg);
  if (*arg) {
    if (GET_STANCE(ch) < STANCE_RESTING)
      send_to_char("Maybe you should wake yourself up first.\r\n", ch);
    else if ((vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg))) == NULL)
      send_to_char(NOPERSON, ch);
    else if (vict == ch)
      self = 1;
    else if (GET_STANCE(vict) > STANCE_SLEEPING)
      act("$E is already awake.", FALSE, ch, 0, vict, TO_CHAR);
    else if (EFF_FLAGGED(vict, EFF_SLEEP))
      act("You can't wake $M up!", FALSE, ch, 0, vict, TO_CHAR);
    else if (GET_STANCE(vict) < STANCE_SLEEPING)
      act("$E's in pretty bad shape!", FALSE, ch, 0, vict, TO_CHAR);
    else {
      act("You wake $M up.", FALSE, ch, 0, vict, TO_CHAR);
      act("You are awakened by $n.", FALSE, ch, 0, vict, TO_VICT |
          TO_SLEEP);
      GET_POS(vict) = POS_SITTING;
      GET_STANCE(vict) = STANCE_RESTING;
    }
    if (!self)
      return;
  }
  if (EFF_FLAGGED(ch, EFF_SLEEP))
    send_to_char("You can't wake up!\r\n", ch);
  else if (GET_STANCE(ch) > STANCE_SLEEPING)
    send_to_char("You are already awake...\r\n", ch);
  else {
    send_to_char("You awaken.\r\n", ch);
    act("$n awakens.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_RESTING;
  }
   mount_pos_check(ch);
}

ACMD(do_follow)
{
  struct char_data *leader;

  if (subcmd == SCMD_SHADOW && !GET_SKILL(ch, SKILL_SHADOW)) {
    send_to_char("You aren't skilled enough to shadow someone.\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!*arg) {
    if (ch->master)
      act("You are following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
    else
      send_to_char("You are not following anyone.\r\n", ch);
    return;
  }

  if (!str_cmp(arg, "off"))
    leader = ch;
  else if (!(leader = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
    send_to_char(NOPERSON, ch);
    return;
  }

  /* Charmies aren't allowed to stop following. */
  if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master)
    act("But you only feel like following $N!", FALSE, ch, 0, ch->master, TO_CHAR);
  /* If 'fol self' then stop following. */
  else if (ch == leader) {
    if (ch->master)
      stop_follower(ch, 0);
    else
      send_to_char("You aren't following anyone.\r\n", ch);
  }
  else if (ch->master == leader)
    act("You are already following $N.", FALSE, ch, 0, leader, TO_CHAR);
  else if (GET_LEVEL(ch) < LVL_GOD && PRF_FLAGGED(leader, PRF_NOFOLLOW))
    send_to_char("That person would rather not have followers right now.\r\n", ch);
  else {
    if (ch->master)
      stop_follower(ch, 0);

    if (subcmd == SCMD_SHADOW)
      SET_FLAG(EFF_FLAGS(ch), EFF_SHADOWING);

    add_follower(ch, leader);

    if (subcmd == SCMD_SHADOW) {
      int chance = GET_SKILL(ch, SKILL_SHADOW);
      chance += dex_app_skill[GET_DEX(ch)].sneak;

      if (chance < number(1, 101)) {
        REMOVE_FLAG(EFF_FLAGS(ch), EFF_SHADOWING);
        act("You are noticed as you attempt to secretly follow $N.", FALSE, ch, 0, leader, TO_CHAR);
        act("$n attempts to secretly follow you, but you spot $m.", TRUE, ch, 0, leader, TO_VICT);
        act("$n attempts to follow $N secretly, but you notice $m.", TRUE, ch, 0, leader, TO_NOTVICT);
      }
      else
        act("You start shadowing $N.", FALSE, ch, 0, leader, TO_CHAR);

      WAIT_STATE(ch, PULSE_VIOLENCE / 2);
      improve_skill(ch, SKILL_SHADOW);
    }
  }
}

ACMD(do_abandon)
{
  bool found = FALSE;
  struct char_data *follower;
  struct follow_type *k;
  char buf[MAX_STRING_LENGTH];

  one_argument(argument, arg);

  buf[0] = 0;


  if (pk_allowed) {

    if (!*arg) {
      if (ch->followers) {
        sprintf(buf, "You are being followed by:\r\n");
        for (k = ch->followers; k; k = k->next) {
          if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
            if (CAN_SEE_MOVING(ch, k->follower)) {
              sprintf(buf,"%s  %s\r\n", buf, GET_NAME(k->follower));
              found = TRUE;
            }
          }
        }
      }
      if (found) {
        page_string(ch, buf);
      }
      else {
        send_to_char("Nobody is following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "all")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if(GET_LEVEL(k->follower) < LVL_GOD) {
            if (CAN_SEE_MOVING(ch, k->follower)) {
              stop_follower(k->follower, 0);
              found = TRUE;
            }
          }
          else {
            if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
              send_to_char("You can not abandon immortals.\r\n", ch);
              found = TRUE;
            }
          }
        }
      }
      if (!found) {
        send_to_char("Nobody is following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "pets")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if (EFF_FLAGGED(k->follower, EFF_CHARM)) {
            stop_follower(k->follower, 0);
            found = TRUE;
          }
        }
      }
      if(!found) {
        send_to_char("You do not have any pets following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "players")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if (!(EFF_FLAGGED(k->follower, EFF_CHARM))) {
            if(GET_LEVEL(k->follower) < LVL_GOD) {
              if (CAN_SEE_MOVING(ch, k->follower)) {
                stop_follower(k->follower, 0);
                found = TRUE;
              }
            }
            else {
              if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
                send_to_char("You can not abandon immortals.\r\n", ch);
                found = TRUE;
              }
            }
          }
        }
      }
      if(!found){
        send_to_char("You do not have any players following you.\r\n", ch);
      }
      return;
    }

    if (!(follower = find_char_for_mtrig(ch, arg))) {
      send_to_char(NOPERSON, ch);
      return;
    }
    else if (ch == follower) {
      send_to_char("You can't abandon yourself.\r\n", ch);
      return;
    }
    else if (ch->followers) {
      for (k = ch->followers; k; k = k->next) {
        if((k->follower == follower) && (CAN_SEE_MOVING(ch, k->follower))) {
          if(GET_LEVEL(k->follower) < LVL_GOD) {
            stop_follower(k->follower, 0);
            found = TRUE;
          }
          else {
            send_to_char("You can not abandon immortals.\r\n", ch);
            found = TRUE;
          }
        }
      }
    }
    else if(!found) {
      send_to_char(NOPERSON, ch);
    }
    return;
  }
  else {
    if (!*arg) {
      if (ch->followers) {
        sprintf(buf, "You are being followed by:\r\n");
        for (k = ch->followers; k; k = k->next) {
          if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
            if (EFF_FLAGGED(k->follower, EFF_INVISIBLE)) {
              sprintf(buf,"%s  %s (invis)\r\n", buf, GET_NAME(k->follower));
              found = TRUE;
            }
            else {
              sprintf(buf,"%s  %s\r\n", buf, GET_NAME(k->follower));
              found = TRUE;
            }
          }
        }
      }
      if (found) {
        page_string(ch, buf);
      }
      else {
        send_to_char("Nobody is following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "all")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if(GET_LEVEL(k->follower) < LVL_GOD) {
            if ((EFF_FLAGGED(k->follower, EFF_INVISIBLE)) && (!CAN_SEE(ch, k->follower))) {
              sprintf(buf,"%s stops following you.\r\n", GET_NAME(k->follower));
              send_to_char(buf, ch);
            }
            stop_follower(k->follower, 0);
            found = TRUE;
          }
          else {
            if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
              send_to_char("You can not abandon immortals.\r\n", ch);
              found = TRUE;
            }
          }
        }
      }
      if (!found) {
        send_to_char("Nobody is following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "pets")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if (EFF_FLAGGED(k->follower, EFF_CHARM)) {
            stop_follower(k->follower, 0);
            found = TRUE;
          }
        }
      }
      if(!found) {
        send_to_char("You do not have any pets following you.\r\n", ch);
      }
      return;
    }

    if (!str_cmp(arg, "players")) {
      if (ch->followers) {
        for (k = ch->followers; k; k = k->next) {
          if (!(EFF_FLAGGED(k->follower, EFF_CHARM))) {
            if(GET_LEVEL(k->follower) < LVL_GOD) {
              if ((EFF_FLAGGED(k->follower, EFF_INVISIBLE)) && (!CAN_SEE(ch, k->follower))) {
                sprintf(buf,"%s stops following you.\r\n", GET_NAME(k->follower));
                send_to_char(buf, ch);
              }
              stop_follower(k->follower, 0);
              found = TRUE;
            }
            else {
              if(GET_INVIS_LEV(k->follower) < GET_LEVEL(ch)) {
                send_to_char("You can not abandon immortals.\r\n", ch);
                found = TRUE;
              }
            }
          }
        }
      }
      if(!found) {
        send_to_char("You do not have any players following you.\r\n", ch);
      }
      return;
    }

    if (!(follower = find_char_for_mtrig(ch, arg))) {
      send_to_char(NOPERSON, ch);
      return;
    }
    else if (ch == follower) {
      send_to_char("You can't abandon yourself.\r\n", ch);
      return;
    }
    else if (ch->followers) {
      for (k = ch->followers; k; k = k->next) {
        if(k->follower == follower) {
          if(GET_LEVEL(k->follower) < LVL_GOD) {
            if ((EFF_FLAGGED(k->follower, EFF_INVISIBLE)) && (!CAN_SEE(ch, k->follower))) {
              sprintf(buf,"%s stops following you.\r\n", GET_NAME(k->follower));
              send_to_char(buf, ch);
            }
            stop_follower(k->follower, 0);
            found = TRUE;
          }
          else {
            send_to_char("You can not abandon immortals.\r\n", ch);
            found = TRUE;
          }
        }
      }
    }
    if(!found) {
      send_to_char(NOPERSON, ch);
    }
    return;
  }
}

void perform_buck(struct char_data *mount, int whilemounting)
{
   struct char_data *rider = RIDDEN_BY(mount);

   if (!rider) return;

   if (IS_SPLASHY(IN_ROOM(mount))) {
      if (whilemounting) {
         act("$N suddenly bucks upwards, throwing you violently into the water!",
               FALSE, rider, 0, mount, TO_CHAR);
         act("$n is thrown down with a splash as $N violently bucks!", TRUE, rider, 0, mount, TO_NOTVICT);
         act("You buck violently and throw $n into the water.", FALSE, rider, 0, mount, TO_VICT);
      } else {
         act("You quickly buck, throwing $N into the water.", FALSE, mount, 0, rider, TO_CHAR);
         act("$n quickly bucks, throwing you into the water.", FALSE, mount, 0, rider, TO_VICT);
         act("$n quickly bucks, throwing $N into the water.", FALSE, mount, 0, rider, TO_NOTVICT);
      }
   } else {
      if (whilemounting) {
         act("$N suddenly bucks upwards, throwing you violently to the ground!",
               FALSE, rider, 0, mount, TO_CHAR);
         act("$n is thrown to the ground as $N violently bucks!", TRUE, rider, 0, mount, TO_NOTVICT);
         act("You buck violently and throw $n to the ground.", FALSE, rider, 0, mount, TO_VICT);
      } else {
         act("You quickly buck, throwing $N to the ground.", FALSE, mount, 0, rider, TO_CHAR);
         act("$n quickly bucks, throwing you to the ground.", FALSE, mount, 0, rider, TO_VICT);
         act("$n quickly bucks, throwing $N to the ground.", FALSE, mount, 0, rider, TO_NOTVICT);
      }
   }

   dismount_char(rider);
   if (!whilemounting)
      alter_pos(rider, POS_SITTING, STANCE_ALERT);
   hurt_char(rider, NULL, dice(1, 3), TRUE);
}

ACMD(do_mount) {
   char arg[MAX_INPUT_LENGTH];
   struct char_data *vict;

   if (FIGHTING(ch)) {
      send_to_char("You are too busy fighting to try that right now.\r\n",ch);
      return;
   }

   one_argument(argument, arg);

   if (!*arg) {
      send_to_char("Mount who?\r\n", ch);
      return;
   } else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      send_to_char("There is no-one by that name here.\r\n", ch);
      return;
   } else if (!IS_NPC(vict)) {
      send_to_char("Ehh... no.\r\n", ch);
      return;
   } else if (RIDING(ch) || RIDDEN_BY(ch)) {
      send_to_char("You are already mounted.\r\n", ch);
      return;
   } else if (RIDING(vict) || RIDDEN_BY(vict)) {
      send_to_char("It is already mounted.\r\n", ch);
      return;
   } else if (GET_LEVEL(ch) < LVL_IMMORT && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
      send_to_char("You can't mount that!\r\n", ch);
      return;
   } else if (!GET_SKILL(ch, SKILL_MOUNT)) {
      send_to_char("First you need to learn *how* to mount.\r\n", ch);
      return;
   } else if (ch == vict) {
      send_to_char("Not likely.\r\n", ch);
      return;
   } else if (RIGID(ch) && !RIGID(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
      if (GET_COMPOSITION(vict) == COMP_ETHER) {
         act("You go to mount $N, but you pass right through $M.", FALSE,
               ch, 0, vict, TO_CHAR);
         act("$n tries to mount you",
               FALSE, ch, 0, vict, TO_VICT);
         act("$n tries to mount $N, but only flails about in a vain attempt to touch $M.",
               TRUE, ch, 0, vict, TO_NOTVICT);
      } else {
         act("You lay a hand on $N, but it slips right through.", FALSE,
               ch, 0, vict, TO_CHAR);
         act("$n tries to mount you, but you are too fluid to support $m",
               FALSE, ch, 0, vict, TO_VICT);
         act("$n tries to mount $N, but $E isn't solid enough to support a rider.",
               TRUE, ch, 0, vict, TO_NOTVICT);
      }
      return;
   } else if (!RIGID(ch) && RIGID(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
      if (GET_COMPOSITION(ch) == COMP_ETHER) {
         act("You try to climb $N, but you simply pass through $M.",
               FALSE, ch, 0, vict, TO_CHAR);
         act("$n tries to mount you, but $e can't seem to touch you.",
               FALSE, ch, 0, vict, TO_VICT);
         act("$n tries to mount $N, but makes $M shudder as $e passes through.",
               FALSE, ch, 0, vict, TO_NOTVICT);
      } else {
         act("You try to climb $M, but you just flow right off.",
               FALSE, ch, 0, vict, TO_CHAR);
         act("$n tries to mount you, but just flows right off.",
               FALSE, ch, 0, vict, TO_VICT);
         act("$n tries to mount $N, but just flows right off.",
               FALSE, ch, 0, vict, TO_NOTVICT);
      }
      return;
   }

   WAIT_STATE(ch, PULSE_VIOLENCE / 2);

   if (mount_fall(ch, vict)) {
      act("You try to mount $N, but slip and fall off.", FALSE, ch, 0, vict, TO_CHAR);
      act("$n tries to mount you, but slips and falls off.", FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to mount $N, but slips and falls off.", TRUE, ch, 0, vict, TO_NOTVICT);
      mount_warning(ch, vict);
      alter_pos(ch, POS_SITTING, STANCE_ALERT);
      improve_skill(ch, SKILL_MOUNT);
      hurt_char(ch, NULL, dice(1, 2), TRUE);
      return;
   }

   act("You mount $N.", FALSE, ch, 0, vict, TO_CHAR);
   act("$n mounts you.", FALSE, ch, 0, vict, TO_VICT);
   act("$n mounts $N.", TRUE, ch, 0, vict, TO_NOTVICT);
   mount_char(ch, vict);
   improve_skill(ch, SKILL_MOUNT);

   if (IS_NPC(vict) && !EFF_FLAGGED(vict, EFF_TAMED) && mount_bucked(ch, vict)) {
      perform_buck(vict, TRUE);
      mount_warning(ch, vict);
   }
}



ACMD(do_dismount) {
  if (!RIDING(ch))
    send_to_char("You aren't even riding anything.\r\n", ch);
  else if (FIGHTING(ch))
    send_to_char("You would get hacked to pieces if you dismount now!\r\n",ch);
  else if (SECT(ch->in_room) == SECT_WATER &&
        !can_travel_on_water(ch) && GET_POS(ch) != POS_FLYING)
    send_to_char("Yah, right, and then drown...\r\n", ch);
  else if (mount_fall(ch, RIDING(ch)) && number(0, 1) == 0) {
    act("As you begin dismounting, you slip and fall down.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
    act("$n starts to dismount, but slips and falls down.", FALSE, ch, 0, RIDING(ch), TO_ROOM);
    alter_pos(ch, POS_SITTING, STANCE_ALERT);
    improve_skill(ch, SKILL_MOUNT);
    hurt_char(ch, NULL, dice(1, 2), TRUE);
  } else {
    act("You dismount $N.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
    act("$n dismounts from you.", FALSE, ch, 0, RIDING(ch), TO_VICT);
    act("$n dismounts $N.", TRUE, ch, 0, RIDING(ch), TO_NOTVICT);
    dismount_char(ch);
  }
}


ACMD(do_buck) {
  if (!RIDDEN_BY(ch))
    send_to_char("You're not even being ridden!\r\n", ch);
  else if (FIGHTING(ch))
    send_to_char("Worry about this &bafter&0 the battle!\r\n",ch);
  else if (EFF_FLAGGED(ch, EFF_TAMED))
    send_to_char("But you're tamed!\r\n", ch);
  else
    perform_buck(ch, FALSE);
}


ACMD(do_tame) {
   char arg[MAX_INPUT_LENGTH];
   struct effect eff;
   struct char_data *vict;
   int tame_duration = 0;
   int chance_tame, chance_attack, lvldiff;

   if (FIGHTING(ch)) {
      send_to_char("You can't tame while fighting!\r\n",ch);
      return;
   }
   one_argument(argument, arg);

   if (!*arg) {
      send_to_char("Tame who?\r\n", ch);
      return;
   } else if (!(vict = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, arg)))) {
      send_to_char("There is no such creature here.\r\n", ch);
      return;
   } else if (!IS_NPC(vict) || (GET_LEVEL(ch) < LVL_IMMORT && !MOB_FLAGGED(vict, MOB_MOUNTABLE))) {
      act("You can't tame $N.", FALSE, ch, 0, vict, TO_CHAR);
      return;
   } else if (EFF_FLAGGED(vict, EFF_TAMED)) {
      act("$E seems quite tame already.", FALSE, ch, 0, vict, TO_CHAR);
      return;
   } else if (!GET_SKILL(ch, SKILL_TAME)) {
      send_to_char("You don't even know how to tame something.\r\n", ch);
      return;
   }

   WAIT_STATE(ch, PULSE_VIOLENCE);

   lvldiff = mountlevel(vict) - ideal_tamelevel(ch);
   if (lvldiff < 1) {
      chance_tame = 1100;
      chance_attack = 0;
   } else {
      chance_tame = 5 + pow(2 * (MOUNT_LEVEL_FUDGE - lvldiff + 1) / MOUNT_LEVEL_FUDGE, 3) * 900 / 8;
      chance_attack = 5 + pow(2 * lvldiff / MOUNT_LEVEL_FUDGE, 3) * 600 / 8;
   }

   if (number(0, 999) >= chance_tame) {
      if (number(0, 999) < chance_attack) {
         act("Your shocking lack of tact has greatly annoyed $N!", FALSE, ch, 0, vict, TO_CHAR);
         act("$n has really pissed $N off!", FALSE, ch, 0, vict, TO_ROOM);
         if (IS_NPC(vict) && AWAKE(vict))
            attack(vict, ch);
      } else {
         act("You failed to tame $M.", FALSE, ch, 0, vict, TO_CHAR);
         act("$n tries lamely to tame $N.", FALSE, ch, 0, vict, TO_ROOM);
         improve_skill(ch, SKILL_TAME);
      }
      return;
   }

   improve_skill(ch, SKILL_TAME);

   tame_duration = (int)(GET_CHA(ch) / 3) + 10;
   if (GET_CLASS(ch) == CLASS_DRUID) {
      tame_duration += 30;
   }
   if (GET_CLASS(ch) == CLASS_RANGER) {
      tame_duration += 15;
   }

  memset(&eff, 0, sizeof(struct effect));
  eff.type = SKILL_TAME;
  eff.duration = tame_duration;
  eff.modifier = 0;
  eff.location = APPLY_NONE;
  SET_FLAG(eff.flags, EFF_TAMED);
  effect_to_char(vict, &eff);

  act("You tame $N.", FALSE, ch, 0, vict, TO_CHAR);
  act("$n tames you.", FALSE, ch, 0, vict, TO_VICT);
  act("$n tames $N.", FALSE, ch, 0, vict, TO_NOTVICT);
}


/***************************************************************************
 * $Log: act.movement.c,v $
 * Revision 1.172  2010/06/05 04:43:57  mud
 * Replacing ocean sector type with cave.
 *
 * Revision 1.171  2009/07/18 01:17:23  myc
 * Immobilized characters can't move.
 *
 * Revision 1.170  2009/03/19 23:16:23  myc
 * Renamed corpse_consent -> has_corpse_consent.
 *
 * Revision 1.169  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.168  2009/03/09 02:22:32  myc
 * Added functionality for locking new boards to the lock/unlock
 * command.
 *
 * Revision 1.167  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.166  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.165  2009/03/07 09:34:47  jps
 * Changed name of room Entry trigger to Preentry. Added a Postentry room trigger type.
 *
 * Revision 1.164  2009/03/03 19:41:50  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.163  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default; assert
 * L_NOFILE to prevent that.
 *
 * Revision 1.162  2008/12/03 03:14:16  myc
 * Make the stand and fly commands set stance to FIGHTING if the character
 * is fighting and ALERT otherwise.
 *
 * Revision 1.161  2008/09/21 21:04:20  jps
 * Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
 *
 * Revision 1.160  2008/09/20 17:38:00  jps
 * Fixed messages about riding incapacitated mounts.
 *
 * Revision 1.159  2008/09/20 08:00:09  jps
 * Don't allow anyone to mount players.
 *
 * Revision 1.158  2008/09/20 07:58:01  jps
 * Don't allow anyone to tame players.
 *
 * Revision 1.157  2008/09/13 17:20:55  jps
 * Don't allow riding when your mount can't move. Check for falling off a mount
 * when it changes position. Move the god-room-enter check after such things as
 * walls.
 *
 * Revision 1.156  2008/09/11 04:22:04  jps
 * Fix bug in do_gen_door regarding rooms with no doors.
 *
 * Revision 1.155  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.154  2008/09/07 01:27:15  jps
 * Moved functions to movement.c. If you stop flying while in an air
 * room (e.g., by sitting or standing) you will fall.
 *
 * Revision 1.153  2008/09/04 06:47:36  jps
 * Changed sector constants to match their strings
 *
 * Revision 1.152  2008/09/02 07:16:00  mud
 * Changing object TIMER uses into DECOMP where appropriate
 *
 * Revision 1.151  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.150  2008/09/01 08:35:04  jps
 * Pass vnum not rnum to entry trigger
 *
 * Revision 1.149  2008/08/30 22:02:42  myc
 * Actions affecting corpses just go to the syslog now, not the RIP log.
 *
 * Revision 1.148  2008/08/29 04:16:26  myc
 * Changed calls to look_at_room and moved its prototype to a header file.
 *
 * Revision 1.147  2008/08/28 23:42:53  rbr
 * Added do_abandon (abandon (lists follower), abandon players (abandon all players), abandon pets (abandon all charmies), abandon <player> (abandons a specific player) Note there are slight differences in whether PK is on or off.
 *
 * Revision 1.146  2008/08/19 02:11:14  jps
 * Don't apply fluid/rigidity restrictions to immortals.
 *
 * Revision 1.145  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.144  2008/08/17 20:24:31  jps
 * Rewrite doorbash.
 *
 * Revision 1.143  2008/08/09 20:35:57  jps
 * Changed sense life so that it has a chance of detecting the presence and movement
 * of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
 *
 * Revision 1.142  2008/07/10 21:23:54  jps
 * Add some fail-to-mount messages for ether critters, which are different from
 * the messages involving other "fluid" critters.
 *
 * Revision 1.141  2008/06/09 23:00:13  myc
 * Got rid of the disembark command and the ocean current list.
 *
 * Revision 1.140  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.139  2008/05/19 06:53:45  jps
 * Got rid of fup and fdown directions.
 *
 * Revision 1.138  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.137  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.136  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.135  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.134  2008/05/14 05:11:28  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.133  2008/05/11 05:43:26  jps
 * Using alter_hit() and alter_pos() instead of calling damage and update_pos.
 *
 * Revision 1.132  2008/04/19 22:43:09  jps
 * There's a chance of falling when you dismount.
 *
 * Revision 1.131  2008/04/14 05:11:40  jps
 * Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
 * to fly - not that the characer is actually flying.
 *
 * Revision 1.130  2008/04/14 02:18:45  jps
 * Removing unused function prototype.
 *
 * Revision 1.129  2008/04/14 01:26:18  jps
 * Change confused movement to happen only 50% of the time.
 *
 * Revision 1.128  2008/04/13 21:56:22  jps
 * Moved doorbash here from act.item.c.
 *
 * Revision 1.127  2008/04/13 20:07:25  jps
 * Implemented confusion, making it hard to walk around or
 * drag people.  Following will succeed 80% of the time, though.
 *
 * Revision 1.126  2008/04/13 01:09:51  jps
 * Don't allow rigid/fluid mount/rider pairs.
 *
 * Revision 1.125  2008/04/07 17:22:12  jps
 * Fix bug waking other characters.
 *
 * Revision 1.124  2008/04/07 15:35:47  jps
 * Updated the fly command.
 *
 * Revision 1.123  2008/04/07 04:54:55  jps
 * Fix drag bug.
 *
 * Revision 1.122  2008/04/07 03:02:37  jps
 * Made it impossible to drag solid people when you're fluid.
 *
 * Revision 1.121  2008/04/06 19:48:19  jps
 * Don't allow open/close/lock/unlock of solid objects when you're in a fluid state.
 *
 * Revision 1.120  2008/04/04 06:12:52  myc
 * Removed justice code.
 *
 * Revision 1.119  2008/04/03 02:05:34  myc
 * Depending on screen.h now.
 *
 * Revision 1.118  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.117  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.116  2008/03/09 18:16:08  jps
 * Implement misdirection. When you have AFF3_MISDIRECTION, you can enter
 * "<dir> <dir>" to go the first direction while pretending to go the
 * second. Each dir can be "stay".
 *
 * Revision 1.115  2008/03/08 23:31:22  jps
 * Typo!
 *
 * Revision 1.114  2008/03/08 23:28:44  jps
 * Separate AFF_CHARM from MOB2_ILLUSORY.
 *
 * Revision 1.113  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.112  2008/02/07 01:46:14  myc
 * Removing the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
 * which points to the sizes array.
 *
 * Revision 1.111  2008/02/06 21:53:53  myc
 * do_enter was reading through the portal messages incorrectly.
 *
 * Revision 1.110  2008/02/02 04:27:55  myc
 * Adding leave and door manipulation triggers.
 *
 * Revision 1.109  2008/01/30 19:20:57  myc
 * Gravity is now a delayed event; don't allow people to 'move' while falling.
 * Putting the flight room check before the water room one so you get
 * the right message when trying to go up into a flight room from a
 * water one.
 *
 * Revision 1.108  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.107  2008/01/27 21:09:12  myc
 * Prevent characters from sitting, kneeling, reclining, resting, or
 * sleeping while berserking.
 *
 * Revision 1.106  2008/01/26 12:30:01  jps
 * Use skills.h to import improve_skill().
 *
 * Revision 1.105  2008/01/25 21:05:45  myc
 * Added attack() as a macro alias for hit() with fewer arguments.
 *
 * Revision 1.104  2008/01/24 15:43:47  myc
 * Sneak and camouflaged flags were too powereful for players.  Made them
 * lose more hide points per move.
 *
 * Revision 1.103  2008/01/15 03:18:19  myc
 * Rewrote give command so it always gives feedback.  Also made REMOVE
 * triggers not prevent immortals from removing items.
 *
 * Revision 1.102  2008/01/13 23:06:04  myc
 * Removed the statsave function.
 *
 * Revision 1.101  2008/01/11 03:35:36  myc
 * Disallow dragging live mobiles.
 *
 * Revision 1.100  2008/01/11 02:06:07  myc
 * Moved do_drag here from act.item.c.  It now allows you to drag
 * characters.  Also both characters and items may be dragged through
 * portals.
 *
 * Revision 1.99  2008/01/09 10:08:48  jps
 * Allow folks with infrared to see people moving to and from dark rooms.
 *
 * Revision 1.98  2008/01/07 11:56:31  jps
 * Allow illusory mobs to wander even if charmed.
 *
 * Revision 1.97  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.96  2008/01/01 03:20:19  jps
 * Allow open/close/lock/unlock on doors even if you have a same-named
 * item in your inventory, provided it doesn't open.
 *
 * Revision 1.95  2007/12/08 21:02:45  jps
 * Abort processing of do_simple_move if a mob greet trigger has
 * killed the actor (fixes crash bug).
 *
 * Revision 1.94  2007/11/24 20:57:29  jps
 * Fix crash bug in enter - act() was being used to send a message
 * to a player while not in a room, which can cause segfaults.
 * Also fixed the markup in portal messages.
 *
 * Revision 1.93  2007/11/24 01:21:25  jps
 * Allow "open <str> <dir>" to ignore all objects and be used to
 * force the target to be a room's door.  Add a relative location string
 * to the failure message when trying to open/close/etc. an object.
 *
 * Revision 1.92  2007/10/20 19:01:48  myc
 * Make pick lock skill improve on failures.
 *
 * Revision 1.91  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.90  2007/10/11 20:14:48  myc
 * Make immortals able to mount, ride, and tame anyone.
 *
 * Revision 1.89  2007/10/04 16:20:24  myc
 * Fixed a variable bug in do_enter.
 *
 * Revision 1.88  2007/10/02 02:52:27  myc
 * Changed AFF_SNEAK flag to be perma sneak so we can still have permasneak
 * mobs and permasneak items.
 *
 * Revision 1.87  2007/09/28 20:49:35  myc
 * Removed a redundant IS_AFFECTED check.
 *
 * Revision 1.86  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  AFF_HIDE and ITEM_HIDDEN are now
 * unused.  Sneak chance is now calculated based on hiddenness.  Cleaned
 * up blood pool code too.  Cleaned up do_enter a lot.  Portal messages
 * are now in arrays.
 *
 * Revision 1.85  2007/09/15 15:36:48  myc
 * Natures embrace now sets camouflage bit, which lets you be hidden as long
 * as you are outside.
 *
 * Revision 1.84  2007/09/12 22:23:04  myc
 * You can now use the 'walk' and 'go' commands to travel in different
 * directions.
 *
 * Revision 1.83  2007/09/11 19:41:07  myc
 * Being an AQUATIC mobile now counts as being able to travel through water
 * squares.  Also, can't ride an aquatic mobile onto land now.
 *
 * Revision 1.82  2007/09/11 16:34:24  myc
 * Adding MOB_AQUATIC flag that prevents water mobs from entering non-water
 * rooms.
 *
 * Revision 1.81  2007/09/08 22:03:19  jps
 * Fix typo, change message in position -> standing messages.
 *
 * Revision 1.80  2007/09/03 21:20:46  jps
 * Moved the code that checks whether a magic wall is blocking movement
 * to magic.c.
 *
 * Revision 1.79  2007/08/31 05:36:19  jps
 * Add variable "destination" to mob Entry trigger.
 *
 * Revision 1.78  2007/08/20 00:41:16  jps
 * Pets won't follow anyone if someone is mounted on them. do_simple_move()
 * will handle any combination of rider/ridee correctly.
 *
 * Revision 1.77  2007/08/14 22:43:07  myc
 * Adding 'shadow' skill, which lets you follow someone sneakily.
 *
 * Revision 1.76  2007/08/05 20:21:51  myc
 * Moved do_simple_move's comments closer to the function.
 *
 * Revision 1.75  2007/08/05 01:50:16  myc
 * Follow, guard, and consent all follow similar usage patterns now.
 * <action> off/self/me stops whatever it is, <action> target starts
 * on the target, and <action> shows who is currently targeted.
 *
 * Revision 1.74  2007/08/04 22:20:38  jps
 * Different buck messages whether you're in a splashy room or not.
 *
 * Revision 1.73  2007/08/04 02:13:27  myc
 * Circle of fire damage should occur before you enter the room.
 *
 * Revision 1.72  2007/08/04 02:10:57  myc
 * You now take damage from circle of fire when entering and exiting a room.
 *
 * Revision 1.71  2007/08/03 22:00:11  myc
 * Fixed several \r\n typos in send_to_chars.
 *
 * Revision 1.70  2007/08/01 02:10:39  jps
 * Make mounts more difficult to handle.
 *
 * Revision 1.69  2007/07/14 04:17:35  jps
 * Updated call to stop_follower(), which cares whether this is being
 * done due to a violent action or not.
 *
 * Revision 1.68  2007/07/14 02:16:22  jps
 * Major revamp of mounts. The character's skill in mount/ride/tame
 * is pitted against the victim's level. Thus, a player with poor
 * skill could use a low-level mount, which would, of course, not
 * be as good as a higher-level mount.
 *
 * Revision 1.67  2007/07/14 01:42:58  jps
 * Doors can now properly lock only from one side, if builders have
 * made them that way.
 *
 * Revision 1.66  2007/05/28 23:51:35  jps
 * Make open/close interact first with equipped items.
 *
 * Revision 1.65  2007/04/25 06:41:27  jps
 * Fixed bug where you buy a mount, then mount it, and suddenly the other
 * folks following you wouldn't be any more.
 *
 * Revision 1.64  2007/04/19 00:53:54  jps
 * Create macros for stopping spellcasting.
 *
 * Revision 1.63  2007/02/08 01:30:00  myc
 * If circle of fire kills someone, hopefully the game won't crash now.
 *
 * Revision 1.62  2006/11/21 20:15:01  jps
 * Use correct pronouns in "tame" feedback.
 *
 * Revision 1.61  2006/11/20 19:52:04  jps
 * Movement cost with levitate is max 2
 *
 * Revision 1.60  2006/11/18 07:17:16  jps
 * *** empty log message ***
 *
 * Revision 1.59  2006/11/14 23:24:39  jps
 * Stop the gale winds from blowing hard on you while indoors.
 *
 * Revision 1.58  2006/11/14 22:38:04  jps
 * Fix bug of lower-level imms seeing "someone" move about when a higher
 * level invis imm moves.
 *
 * Revision 1.57  2006/11/13 15:54:22  jps
 * Fix widespread misuse of the hide_invisible parameter to act().
 *
 * Revision 1.56  2006/11/13 14:57:54  jps
 * Fix typos when mortal tried to enter a godroom.
 * Don't allow mortals to see that an imm is following, even with sense life.
 *
 * Revision 1.55  2006/11/13 13:32:25  jps
 * Prevent characters from mounting themselves.
 *
 * Revision 1.54  2006/11/12 02:31:01  jps
 * Mount goes with you through portals.
 *
 * Revision 1.53  2006/11/08 08:51:58  jps
 * Fix missing period in message about trying to fly while fighting.
 *
 * Revision 1.52  2006/11/08 08:36:54  jps
 * Fixed a lot of lay/lie typos.
 *
 * Revision 1.51  2006/11/08 08:16:14  jps
 * Fix missing period at the end of arrival message, when riding.
 *
 * Revision 1.50  2006/11/07 16:53:29  jps
 * A boat will reduce movement cost in WATER_NOSWIM from 4 to 2.
 *
 * Revision 1.49  2006/07/20 07:42:36  cjd
 * Typo fixes.
 *
 * Revision 1.48  2005/02/12 00:12:52  rls
 * Commented out that damned annoying wind knockdown effect.
 *
 * Revision 1.47  2004/11/29 01:56:31  rls
 * Fixed a bug where you could have two mobs follow each other though
 * a loop room and lag/crash the mud.  See... Druids ARE so broken!
 *
 * Revision 1.45  2004/11/01 05:18:24  jjl
 * CI'd too quick
 *
 * Revision 1.44  2004/11/01 05:17:05  jjl
 * Added pk_checks for act.movement.c
 *
 * Revision 1.43  2003/07/04 22:10:55  jjl
 * Let gods walk through doors.
 *
 * Revision 1.42  2003/06/23 01:47:09  jjl
 * Added a NOFOLLOW flag, and the "note" command, and show notes <player>
 *
 * Revision 1.41  2003/06/20 13:17:47  rls
 * Changed scale and added bonus to already sneaking people so it
 * isn't as hard to remain sneaking while walking.  Works 99.9
 * of the time for high level skill... about 1/2 the time for
 * mid range and low skill.
 *
 * Revision 1.40  2003/02/02 01:33:17  jjl
 * Fixing stand, removing the 8 second delay. Doh
 *
 * Revision 1.39  2002/12/28 21:56:42  jjl
 * Added delay for punk-mobs standing up and fleeing.
 *
 * Revision 1.38  2002/11/30 19:44:06  jjl
 * Goes to asleep?  The hell you say!
 *
 * Revision 1.37  2002/09/22 19:33:05  jjl
 * Fixed a bug pergy introduced, whereby the AFF_SNEAK bit was stripped,
 * but the actual spell wasn'. The net affect is you could get infinite
 * sneak "spells" upon yourself.
 * /
 *
 * Revision 1.36  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.35  2002/07/17 17:04:37  rls
 * fixed hide & sneak check to 100 pnt based chance (get_skill uses /10)
 *
 * Revision 1.34  2002/07/16 19:38:44  rls
 * Adjusted sneak w/ hide to a 5% chance failure for those without sneak
 *
 * Revision 1.33  2002/07/16 19:29:35  rls
 * Changed movement while sneaking to require a successful sneak check every
 * round... also allowed the ability to move while hidden if successfully sneaking.
 *
 * Revision 1.32  2002/02/13 23:30:07  dce
 * Went through all of the change position commands (sit, stand
 * , kneel, sleep, etc..) to make sure that it accounted for
 * fighting and floating positions.
 *
 * Revision 1.31  2002/02/11 02:47:57  dce
 * When you stagger under a heavy load in do_simple_move, I
 * added a update_pos call.
 *
 * Revision 1.30  2001/10/16 00:13:58  rjd
 * Fly semantics improved.
 *
 * Revision 1.29  2001/10/11 07:19:25  rjd
 * Immorts+ can now fly upon demand, walk on water, and travel about
 * without having to worry about staggering under any weight.
 *
 * Revision 1.28  2001/04/07 14:14:30  dce
 * You must be the proper level to enter a portal.
 *
 * Revision 1.27  2001/03/04 15:11:33  dce
 * Fixed a crash bug in do_simple_move, changed riding to
 * RIDING(ch).
 *
 * Revision 1.26  2001/01/23 23:48:26  dce
 * Fixed's someones double declaration error
 *
 * Revision 1.25  2000/11/28 00:42:15  mtp
 * removed mobprog references
 *
 * Revision 1.24  2000/11/20 03:43:03  rsd
 * Added back rlog messages from prior to the addition of
 * the $log$ string
 *
 * Revision 1.23  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.22  2000/09/19 21:37:17  rsd
 * fixed a typo in riding.
 *
 * Revision 1.21  2000/09/18 01:32:48  rsd
 * altered the mount and riding code checks to add skill bonus'
 * for the mount being charmed.
 *
 * Revision 1.20  2000/09/07 01:54:32  rsd
 * added a space at the end of the riding message to fix a typo.
 *
 * Revision 1.19  2000/06/05 18:43:56  rsd
 * Revision 1.18  2000/06/05 00:21:06  rsd
 * Retabbed and braced sections of do_dimple_move also fixed
 * the riding check in do simple move to be a little more
 * sane. I think.
 * For 1.19
 * I added bonuses for charisma and class to tame.
 * I added bonuses for class to mount and riding.
 * I also added a tame check to riding.
 *
 * Revision 1.17  2000/05/31 21:54:14  rsd
 * made the likelyhood of getting bucked decrease dramatically
 *
 * Revision 1.16  2000/04/22 22:25:46  rsd
 * removed hubis reference
 *
 * Revision 1.15  2000/04/21 00:56:44  rsd
 * tabbed and braced perform_move as well as fixed the following
 * into dark bug associated with can see.
 *
 * Revision 1.14  2000/04/17 00:49:58  rsd
 * altered comment header while browsing the file
 *
 * Revision 1.13  1999/12/06 20:19:59  cso
 * Fixed a typo in line "You are too busy fighting.."
 *
 * Revision 1.12  1999/11/28 22:35:18  cso
 * mobs affected by charm can now do_move if they're also animated.
 * this allows 'order fol north'.
 *
 * Revision 1.11  1999/09/08 07:06:03  jimmy
 * More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
 * with blood and killing
 * --gurlaek
 *
 * Revision 1.10  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.9  1999/09/03 23:05:48  mtp
 * added soe IS_FIGHTING checks
 *
 * Revision 1.8  1999/07/25 04:33:11  jimmy
 * No more following people if you can't see them. Invis/dark etc.
 * gurlaek
 *
 * Revision 1.7  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.6  1999/04/07 01:20:18  dce
 * Allows extra descriptions on no exits.
 *
 * Revision 1.5  1999/03/14 14:28:11  jimmy
 * Movement now has bite!  removed extra "flying" from
 * movement_loss in constants.c to fix the mv bug.  reduced the
 * movement gain by 5 for all ages in limits.c.  Removed the +5
 * and +6 static movement gain so that it now actually updates
 * based on the function in regen.c.  Gosh i'm a bastard.
 * Fingon
 *
 * Revision 1.4  1999/03/14 03:18:02  jimmy
 * Fixed the mount fleeing while your fighting after his TAME wear's off
 * crashbug i hope.  Also, fixed do_tame to work properly.  fixed
 * do_dismount to check for flying in water rooms. fixed do_simple_move
 * to properly handle boats and fly in water rooms while mounted or not
 * mounted.  Lots of little things in the mount code.
 * fingon
 *
 * Revision 1.3  1999/03/12 18:05:43  dce
 * No flying over oceans
 *
 * Revision 1.2  1999/02/20 18:41:36  dce
 * Adds improve_skill calls so that players can imprve their skills.
 *
 * Revision 1.1  1999/01/29 01:23:30  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.172
log
@Replacing ocean sector type with cave.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.171 2009/07/18 01:17:23 myc Exp mud $
d2735 1
a2735 1
   if (!arg || !*arg) {
d2870 1
a2870 1
   if (!arg || !*arg) {
d2938 3
@


1.171
log
@Immobilized characters can't move.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.170 2009/03/19 23:16:23 myc Exp myc $
a467 6
   if (SECT(CH_NDEST(actor, dir)) == SECT_OCEAN &&
         (IS_NPC(actor) || GET_LEVEL(actor) < LVL_IMMORT)) {
      send_to_char("The rough currents would be hazardous to your health.\r\n", actor);
      return FALSE;
   }

d2938 3
@


1.170
log
@Renamed corpse_consent -> has_corpse_consent.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.169 2009/03/09 04:33:20 jps Exp myc $
d282 5
d2944 3
@


1.169
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.168 2009/03/09 02:22:32 myc Exp jps $
a1623 2
  extern bool corpse_consent(struct char_data *ch, struct obj_data *cont);

d1742 1
a1742 1
    if (IS_PLR_CORPSE(tobj) && !corpse_consent(ch, tobj)) {
d2939 4
@


1.168
log
@Added functionality for locking new boards to the lock/unlock
command.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.167 2009/03/08 23:34:14 jps Exp myc $
d47 1
d2941 4
@


1.167
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.166 2009/03/08 21:43:27 jps Exp jps $
d46 1
d1202 24
d2940 3
@


1.166
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.165 2009/03/07 09:34:47 jps Exp jps $
d27 1
a27 1
#include "spells.h"
d2915 3
@


1.165
log
@Changed name of room Entry trigger to Preentry. Added a Postentry room trigger type.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.164 2009/03/03 19:41:50 myc Exp jps $
d44 2
d2915 3
@


1.164
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.163 2009/02/21 03:30:16 myc Exp myc $
d505 1
a505 1
   if (!enter_wtrigger(CH_DEST(actor, dir), actor, dir))
d624 1
a624 1
   /* if they die, don't do anything else */
d644 8
d2913 3
@


1.163
log
@Removed L_FILE flag--mprintf now logs to file by default; assert
L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.162 2008/12/03 03:14:16 myc Exp myc $
a51 1
struct char_data *get_char_vis_mscript(struct char_data * ch, char *name); /* handler.c */
d1297 1
a1297 1
  if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
d1730 1
a1730 1
    if (!(portal = get_obj_in_list_vis(ch, arg, world[from_room].contents))) {
d2303 1
a2303 1
    else if ((vict = get_char_room_vis(ch, arg)) == NULL)
d2357 1
a2357 1
  else if (!(leader = get_char_room_vis(ch, arg))) {
d2502 1
a2502 1
    if (!(follower = get_char_vis_mscript(ch, arg))) {
d2622 1
a2622 1
    if (!(follower = get_char_vis_mscript(ch, arg))) {
d2705 1
a2705 1
   } else if (!(vict = get_char_room_vis(ch, arg))) {
d2840 1
a2840 1
   } else if (!(vict = get_char_room_vis(ch, arg))) {
d2905 4
@


1.162
log
@Make the stand and fly commands set stance to FIGHTING if the character
is fighting and ALERT otherwise.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.161 2008/09/21 21:04:20 jps Exp myc $
d1484 1
a1484 1
      mprintf(L_WARN | L_FILE, LVL_GOD,
d1490 1
a1490 1
      mprintf(L_WARN | L_FILE, LVL_GOD,
d1710 1
a1710 1
      mprintf(L_STAT | L_FILE, LVL_IMMORT,
d2906 4
@


1.161
log
@Passing cast type to mag_affect so that potions of bless/dark presence can be quaffed by neutral people.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.160 2008/09/20 17:38:00 jps Exp jps $
d1899 1
a1899 1
   GET_STANCE(ch) = STANCE_ALERT;
d1952 1
a1952 1
   GET_STANCE(ch) = STANCE_ALERT;
d2906 3
@


1.160
log
@Fixed messages about riding incapacitated mounts.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.159 2008/09/20 08:00:09 jps Exp jps $
d1345 2
a1346 2
      mag_affect(70, ch, ch, SPELL_INSANITY, SAVING_SPELL);
      mag_affect(70, ch, ch, SPELL_DISEASE, SAVING_SPELL);
d2906 3
@


1.159
log
@Don't allow anyone to mount players.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.158 2008/09/20 07:58:01 jps Exp jps $
d306 1
a306 1
         sprintf(buf, "You aren't riding $N anywhere $E's %s.",
d309 1
a309 1
         sprintf(buf, "$n tries to ride the %s $N.", stance_types[GET_STANCE(mount)]);
d2906 3
@


1.158
log
@Don't allow anyone to tame players.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.157 2008/09/13 17:20:55 jps Exp jps $
d2709 1
a2709 1
   } else if (!IS_NPC(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
d2718 1
a2718 1
   } else if (GET_LEVEL(ch) < LVL_IMMORT && IS_NPC(vict) && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
d2906 3
@


1.157
log
@Don't allow riding when your mount can't move. Check for falling off a mount
when it changes position. Move the god-room-enter check after such things as
walls.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.156 2008/09/11 04:22:04 jps Exp jps $
d2826 5
a2830 5
  char arg[MAX_INPUT_LENGTH];
  struct effect eff;
  struct char_data *vict;
  int tame_duration = 0;
  int chance_tame, chance_attack, lvldiff;
d2832 5
a2836 5
  if (FIGHTING(ch)) {
    send_to_char("You can't tame while fighting!\r\n",ch);
    return;
  }
  one_argument(argument, arg);
d2838 16
a2853 19
  if (!arg || !*arg) {
    send_to_char("Tame who?\r\n", ch);
    return;
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("They're not here.\r\n", ch);
    return;
  } else if (GET_LEVEL(ch) < LVL_IMMORT && IS_NPC(vict) && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
    act("You can't tame $N.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  } else if (EFF_FLAGGED(vict, EFF_TAMED)) {
    act("$E seems quite tame already.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  } else if (!GET_SKILL(ch, SKILL_TAME)) {
    send_to_char("You don't even know how to tame something.\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You can't do that.\r\n", ch);
    return;
  }
d2855 1
a2855 1
  WAIT_STATE(ch, PULSE_VIOLENCE);
d2906 5
@


1.156
log
@Fix bug in do_gen_door regarding rooms with no doors.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.155 2008/09/09 08:23:37 jps Exp jps $
a278 24
   /* Don't allow people in god rooms (unless following a deity) */
   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (ch->master) {
         if (GET_LEVEL(ch->master) < LVL_IMMORT) {
            if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
               send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
               return FALSE;
            }
         } else {
            if (ch->master->in_room != CH_NDEST(ch, dir)) {
               if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
                  send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
                  return FALSE;
               }
            }
         }
      } else {
         if (ROOM_FLAGGED(CH_NDEST(ch, dir), ROOM_GODROOM)) {
            send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
            return FALSE;
         }
      }
   }

d303 22
d509 24
a1848 1

d1900 1
d1954 1
d2012 1
d2068 1
d2125 1
a2159 1

d2190 1
d2240 1
d2291 1
d2334 1
d2909 3
@


1.155
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.154 2008/09/07 01:27:15 jps Exp jps $
d1095 35
d1162 1
a1162 1
                             ch, &victim, &obj)))
d1164 5
d1173 1
a1173 1
   if (obj && !OBJ_IS_OPENABLE(obj)) {
d1175 4
a1178 6
      if (door >= 0)
         obj = 0;
      else {
         sprintf(buf, "You can't %s that.\r\n", cmd_door[subcmd]);
         send_to_char(buf, ch);
         return;
d1180 1
d1185 2
a1186 2
   if (!SOLIDCHAR(ch) && (!obj || obj->carried_by != ch) && GET_LEVEL(ch) < LVL_IMMORT) {
      sprintf(buf, "You can't manipulate solid objects in your %s%s&0 state.\r\n",
a1187 1
      send_to_char(buf, ch);
d1191 22
a1212 39
   if (!door_mtrigger(ch, subcmd, door) || !door_wtrigger(ch, subcmd, door))
      return;

   if (obj) {
      switch (subcmd) {
         case SCMD_OPEN:
            open_object(ch, obj, FALSE);
            break;
         case SCMD_CLOSE:
            close_object(ch, obj, FALSE);
            break;
         case SCMD_UNLOCK:
            unlock_object(ch, obj, FALSE);
            break;
         case SCMD_LOCK:
            lock_object(ch, obj, FALSE);
            break;
         case SCMD_PICK:
            pick_object(ch, obj);
            break;
      }
   } else {
      switch (subcmd) {
         case SCMD_OPEN:
            open_door(ch, CH_NROOM(ch), door, FALSE);
            break;
         case SCMD_CLOSE:
            close_door(ch, CH_NROOM(ch), door, FALSE);
            break;
         case SCMD_UNLOCK:
            unlock_door(ch, CH_NROOM(ch), door, FALSE);
            break;
         case SCMD_LOCK:
            lock_door(ch, CH_NROOM(ch), door, FALSE);
            break;
         case SCMD_PICK:
            pick_door(ch, CH_NROOM(ch), door);
            break;
         }
a1213 1
   return;
d2880 3
@


1.154
log
@Moved functions to movement.c. If you stop flying while in an air
room (e.g., by sitting or standing) you will fall.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.153 2008/09/04 06:47:36 jps Exp jps $
d352 2
a353 2
      need_movement = (movement_loss[SECT(CH_NDEST(motivator, dir))]
            + movement_loss[SECT(motivator->in_room)]) / 2;
d512 1
a512 1
   if (OUTSIDE(motivator) &&
d521 1
a521 3
   if (EFF_FLAGGED(ch, EFF_CAMOUFLAGED) &&
       (SECT(CH_NDEST(actor, dir)) == SECT_INSIDE ||
        ROOM_FLAGGED(CH_NDEST(actor, dir), ROOM_INDOORS))) {
d1644 1
a1644 1
    move_cost = MIN(4, GET_WEIGHT(tch) / 50 + movement_loss[SECT(ch->in_room)]);
d1674 1
a1674 1
    move_cost = MIN(4, GET_OBJ_WEIGHT(tobj) / 50 + movement_loss[SECT(ch->in_room)]);
d2860 4
@


1.153
log
@Changed sector constants to match their strings
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.152 2008/09/02 07:16:00 mud Exp jps $
d1836 6
d1913 1
d1970 1
d2025 1
d2081 1
d2146 1
d2245 1
a2858 274
/*
 * Gravity
 *
 * Makes mobiles and objects fall.
 */

/* falling_yell - when you first start falling, your yell of surprise is heard
 * in the surrounding rooms. */
void falling_yell(struct char_data *ch)
{
   int dir, was_in, backdir, i;
   char *dirstr;
   struct room_data *oroom;

   if (EFF_FLAGGED(ch, EFF_SILENCE))
     return;

   was_in = ch->in_room;

   for (dir = 0; dir < NUM_OF_DIRS; dir++) {
      if (CAN_GO(ch, dir) && ((oroom = CH_DEST(ch, dir)))) {
         /* other_room will get a scream.
          * If it has an exit back to this room, use that direction as where
          * the scream "came from". Otherwise, use the opposite of the direction
          * going to other_room. */
         backdir = -1;

         /* does the destination room have an exit pointing back? */
         if (oroom->exits[rev_dir[dir]])
            /* does that exit point back to this room? */
            if (EXIT_NDEST(oroom->exits[rev_dir[dir]]) == was_in)
               backdir = rev_dir[dir];

         /* No exit pointing directly back?  Search for any exit pointing back. */
         if (backdir == -1) {
            for (i = 0; i < NUM_OF_DIRS; i++)
               if (oroom->exits[i] && EXIT_NDEST(oroom->exits[i]) == was_in) {
                  backdir = i;
                  break;
               }
         }

         /* Couldn't find any exits back. But since *this* room does have an exit going
          * to that room, we *will* send the sound. */
         if (backdir == -1)
            backdir = rev_dir[dir];

         if (backdir == 5)
            dirstr = "below";
         else if (backdir == 4)
            continue; /* No yell - you'll receive "<person> falls screaming from above" */
         else {
            sprintf(buf2, "the %s", dirs[backdir]);
            dirstr = buf2;
         }

         sprintf(buf, "You hear a %s %s from %s, which quickly fades.",
               number(0, 10) < 5 ? "surprised" : "sudden",
               number(0, 10) < 6 ? "shriek" : "yelp", dirstr);

         ch->in_room = EXIT_NDEST(world[was_in].exits[dir]);
         act(buf, FALSE, ch, 0, 0, TO_ROOM);
         ch->in_room = was_in;
      }
   }
}


void gravity_assisted_landing(struct char_data *ch, int distance_fallen)
{
  int damage = 0;

  /* Levitation protects from damage */
  if (EFF_FLAGGED(ch, EFF_LEVITATE)) {
    if (IS_WATER(IN_ROOM(ch))) {
      send_to_char("\r\nYou come to rest above the surface of the water.\r\n", ch);
      act("$n comes to rest above the surface of the water.", FALSE, ch, 0, 0, TO_ROOM);
    }
    else {
      send_to_char("\r\nYou come to rest just above the ground.\r\n", ch);
      act("$n's descent ends just above the ground.", FALSE, ch, 0, 0, TO_ROOM);
    }
    return;
  }

  GET_POS(ch) = POS_SITTING;
  GET_STANCE(ch) = STANCE_ALERT;

  /* Are we landing in water? It hurts MUCH less... */
  /* If we have safe fall skill, then we take no damage
     for five rooms, partially for 5-15 and full at 15 David Endre 3/8/99 */
  if (IS_WATER(IN_ROOM(ch))) {
    send_to_char("\r\nYou land with a tremendous &4SPLASH&2!&0\r\n", ch);
    act("$n lands with a tremendous &4SPLASH&2!&0", FALSE, ch, 0, 0, TO_ROOM);
  }
  else {
    if (GET_SKILL(ch, SKILL_SAFEFALL) && distance_fallen <= 5) {
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_ALERT;
      send_to_char("\r\nYou tuck and roll, performing a beautiful landing!\r\n", ch);
      act("$n tucks and rolls, performing a beautiful landing!", FALSE, ch, 0, 0, TO_ROOM);
    }
    else if (GET_SKILL(ch, SKILL_SAFEFALL) && distance_fallen < 15) {
      send_to_char("\r\nYou gracefully land without taking too much damage.\r\n", ch);
      act("$n gracefully lands without taking too much damage.", FALSE, ch, 0, 0, TO_ROOM);
    }
    else {
      send_to_char("\r\nYou land with a resounding &1S&2P&1L&2A&1T&2!&0\r\n", ch);
      act("$n lands with a resounding &1S&2P&1L&2A&1T&2!&0", FALSE, ch, 0, 0, TO_ROOM);
    }
  }

  damage = ((distance_fallen * (GET_SIZE(ch) + 1)) / 50.0) * GET_MAX_HIT(ch);

  if (IS_WATER(IN_ROOM(ch)))
    damage /= 4;

  if (GET_SKILL(ch, SKILL_SAFEFALL)) {
    if (distance_fallen <= 5)
      damage = 0;
    else if (distance_fallen < 15)
      damage *= distance_fallen / 15.0;
  }

  hurt_char(ch, NULL, damage, TRUE);
}

#define CANCEL_GRAVITY \
        { if (ch) REMOVE_FLAG(GET_EVENT_FLAGS(ch), EVENT_GRAVITY); \
          else    REMOVE_FLAG(GET_EVENT_FLAGS(obj), EVENT_GRAVITY); \
          return  EVENT_FINISHED; }
EVENTFUNC(gravity_event)
{
  extern void dismount_char(struct char_data *ch);

  struct gravity_event_obj *event = (struct gravity_event_obj *) event_obj;
  struct char_data *ch = event->ch;
  struct obj_data *obj = event->obj;
  int in_room = ch ? IN_ROOM(ch) : IN_ROOM(obj);
  int to_room;

  if (in_room == NOWHERE)
    CANCEL_GRAVITY;

  if (world[in_room].sector_type != SECT_AIR ||
      (ch ? !CAN_GO(ch, DOWN) : !CAN_GO(obj, DOWN)))
    CANCEL_GRAVITY;

  to_room = world[in_room].exits[DOWN]->to_room;

  if (ch) {
    if (EFF_FLAGGED(ch, EFF_FLY))
      CANCEL_GRAVITY;
    if (RIDING(ch) && EFF_FLAGGED(RIDING(ch), EFF_FLY))
      CANCEL_GRAVITY;
    if (RIDDEN_BY(ch) && EFF_FLAGGED(RIDDEN_BY(ch), EFF_FLY))
      CANCEL_GRAVITY;
    if (GET_LEVEL(ch) >= LVL_IMMORT)
      CANCEL_GRAVITY;

    if (RIDING(ch))
      dismount_char(ch);
    if (RIDDEN_BY(ch))
      dismount_char(RIDDEN_BY(ch));

    if (event->distance_fallen == 0) {
      if (EFF_FLAGGED(ch, EFF_LEVITATE)) {
        act("&1&bYou find yourself in midair and begin descending.&0\r\n\r\n",
            FALSE, ch, 0, 0, TO_CHAR);
        act("&1&b$n finds $mself in midair and begins descending.&0",
            FALSE, ch, 0, 0, TO_ROOM);
      }
      else {
        act("&1&bYou find yourself on thin air and fall&0 &2DOWN!&0\r\n\r\n",
            FALSE, ch, 0, 0, TO_CHAR);
        act("&1&b$n finds $mself on thin air and falls&0 &2DOWN!&0",
            FALSE, ch, 0, 0, TO_ROOM);
        falling_yell(ch);
      }
    }

    char_from_room(ch);
    char_to_room(ch, to_room);

    if (EFF_FLAGGED(ch, EFF_LEVITATE)) {
      send_to_char("\r\n&2You float slowly downward.&0\r\n\r\n", ch);
      act("&2$n floats slowly down from above.&0", FALSE, ch, 0, 0, TO_ROOM);
    }
    else if (GET_SKILL(ch, SKILL_SAFEFALL)) {
      send_to_char("\r\n&2You fall gracefully DOWN!&0\r\n\r\n", ch);
      act("&2$n gracefully falls from above.&0", FALSE, ch, 0, 0, TO_ROOM);
    }
    else {
      send_to_char("\r\n&2DOWN!&0\r\n\r\n", ch);
      act("&2$n falls screaming from above.&0", FALSE, ch, 0, 0, TO_ROOM);
    }

    if (ch->desc)
      look_at_room(ch, FALSE);
  }
  else if (obj) {
    if (event->distance_fallen == 0)
      act("$p &1&8plummets&0 &2downward!&0", FALSE, 0, obj, 0, TO_ROOM);

    obj_from_room(obj);
    obj_to_room(obj, to_room);

    act("$p &1&8falls from above.&0", FALSE, 0, obj, 0, TO_ROOM);
  }

  /* to_room is now the room the char/obj is currently in */
  if (to_room == event->start_room) {
    sprintf(buf, "Falling room loop detected: "
            "%s started falling in room %d; is now in %d",
            ch ? "char" : "obj", world[event->start_room].vnum,
            world[in_room].vnum);
    log(buf);
    if (ch)
      send_to_char("\r\nParadoxically, you end up where you began.\r\n", ch);
    CANCEL_GRAVITY;
  }

  event->distance_fallen++;

  /* If you can still fall, then queue up the event again. */
  if ((ch ? SECT(IN_ROOM(ch)) : SECT(IN_ROOM(obj))) == SECT_AIR)
    if (ch ? CAN_GO(ch, DOWN) : CAN_GO(obj, DOWN)) {
      /* return 1 makes it happen immediately; we want to wait a pulse or so */
      if (ch && EFF_FLAGGED(ch, EFF_LEVITATE))
        return 4;
      else
        return 2;
    }

  /* No exit down means we've hit the bottom. */
  if (obj) {
    if (IS_SPLASHY(to_room))
      act("$p &1&8lands with a loud&0 &1SPLASH!&0", FALSE, 0, obj, 0, TO_ROOM);
    else
      act("$p &1&8lands with a dull&0 &1THUD!&0", FALSE, 0, obj, 0, TO_ROOM);
  }
  else if (ch) {
    if (GET_LEVEL(ch) < LVL_IMMORT)
      gravity_assisted_landing(ch, event->distance_fallen);
  }

  CANCEL_GRAVITY;
}

void start_char_falling(struct char_data *ch) {
  struct gravity_event_obj *event_obj;
  if (!EVENT_FLAGGED(ch, EVENT_GRAVITY)) {
    CREATE(event_obj, struct gravity_event_obj, 1);
    event_obj->ch = ch;
    event_obj->start_room = IN_ROOM(ch);
    event_create(EVENT_GRAVITY, gravity_event, event_obj, TRUE,
                 &(ch->events), 0);
    SET_FLAG(GET_EVENT_FLAGS(ch), EVENT_GRAVITY);
  }
}

void start_obj_falling(struct obj_data *obj) {
  struct gravity_event_obj *event_obj;
  if (!EVENT_FLAGGED(obj, EVENT_GRAVITY)) {
    CREATE(event_obj, struct gravity_event_obj, 1);
    event_obj->obj = obj;
    event_obj->start_room = IN_ROOM(obj);
    event_create(EVENT_GRAVITY, gravity_event, event_obj, TRUE,
                 &(obj->events), 0);
    SET_FLAG(GET_EVENT_FLAGS(obj), EVENT_GRAVITY);
  }
}


d2862 3
@


1.152
log
@Changing object TIMER uses into DECOMP where appropriate
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.151 2008/09/01 23:47:49 jps Exp mud $
d349 1
a349 1
   else if (boat && SECT(motivator->in_room) == SECT_WATER_SWIM)
d427 1
a427 1
         SECT(CH_NDEST(actor, dir)) != SECT_FLYING) {
d439 1
a439 1
         SECT(CH_NDEST(actor, dir)) != SECT_FLYING) {
d445 2
a446 2
   if ((SECT(actor->in_room) == SECT_FLYING) ||
         (SECT(CH_NDEST(actor, dir)) == SECT_FLYING)) {
d454 2
a455 2
   if ((SECT(actor->in_room) == SECT_WATER_NOSWIM) ||
         (SECT(CH_NDEST(actor, dir)) == SECT_WATER_NOSWIM)) {
d2736 1
a2736 1
  else if (SECT(ch->in_room) == SECT_WATER_NOSWIM &&
d2991 1
a2991 1
  if (world[in_room].sector_type != SECT_FLYING ||
d3072 1
a3072 1
  if ((ch ? SECT(IN_ROOM(ch)) : SECT(IN_ROOM(obj))) == SECT_FLYING)
d3124 3
@


1.151
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.150 2008/09/01 08:35:04 jps Exp jps $
d74 1
a74 1
    GET_OBJ_TIMER(obj) = 3;
d78 1
a78 1
    GET_OBJ_TIMER(obj) = 2;
d3124 3
@


1.150
log
@Pass vnum not rnum to entry trigger
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.149 2008/08/30 22:02:42 myc Exp jps $
d43 1
a49 3
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void dismount_char(struct char_data * ch);
void mount_char(struct char_data *ch, struct char_data *mount);
a53 159
/* simple function to determine if char can walk on water */
int has_boat(struct char_data *ch)
{
  struct obj_data *obj;
  int i;

  /* if this is an immortal or god, this being can do whatever
     the hell it wants to in this universe (DEMOLITUM) */
  if(GET_LEVEL(ch) >= LVL_IMMORT)
    return 1;

  if (EFF_FLAGGED(ch, EFF_WATERWALK))
    return 1;

  if (MOB_FLAGGED(ch, MOB_AQUATIC))
    return 1;

  /* non-wearable boats in inventory will do it */
  for (obj = ch->carrying; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == ITEM_BOAT && (find_eq_pos(ch, obj, NULL) < 0))
      return 1;

  /* and any boat you're wearing will do it too */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_BOAT)
      return 1;

  return 0;
}




/* ideal_mountlevel
 *
 * Returns the highest level of mob which this character could mount and ride
 * with no difficulty.
 */

int ideal_mountlevel(struct char_data *ch) {
   if (GET_LEVEL(ch) >= LVL_IMMORT)
      return 1000; /* arbitrarily large number */

   if (GET_SKILL(ch, SKILL_MOUNT) < 1)
      return -1 - 2 * MOUNT_LEVEL_FUDGE; /* Make it impossible to mount anything with 0 skill */

   return GET_SKILL(ch, SKILL_MOUNT) * (MAX_MOUNT_LEVEL - 1) / 100 - 5;
}

int ideal_ridelevel(struct char_data *ch) {
   if (GET_LEVEL(ch) >= LVL_IMMORT)
      return 1000; /* arbitrarily large number */

   if (GET_SKILL(ch, SKILL_RIDING) < 1)
      return -1 - 2 * MOUNT_LEVEL_FUDGE; /* Make it impossible to ride anything with 0 skill */

   return GET_SKILL(ch, SKILL_RIDING) * (MAX_MOUNT_LEVEL - 1) / 100 - 5;
}

int ideal_tamelevel(struct char_data *ch) {
   int tame_skill, tame_bonus;

   if (GET_LEVEL(ch) >= LVL_IMMORT)
      return 1000; /* arbitrarily large number */

   if (GET_SKILL(ch, SKILL_TAME) < 1)
      return -1 - 2 * MOUNT_LEVEL_FUDGE; /* Make it impossible to tame anything with 0 skill */

   tame_skill = GET_SKILL(ch, SKILL_TAME);

   tame_bonus = (int)(GET_CHA(ch) / 3);

   if (GET_CLASS(ch) == CLASS_DRUID) {
     tame_bonus += 30;
   }
   if (GET_CLASS(ch) == CLASS_RANGER) {
     tame_bonus += 15;
   }

   tame_skill += tame_bonus / 10;
   return tame_skill * (MAX_MOUNT_LEVEL - 1) / 100 - 5;
}

int mountlevel(struct char_data *ch) {
   int l = GET_LEVEL(ch);

   if (EFF_FLAGGED(ch, EFF_TAMED))
      l -= 2;
   if (EFF_FLAGGED(ch, EFF_CHARM))
      l -= 2;

   return l;
}


/* movement_bucked
 *
 * True or false: will this character be bucked while moving?
 */

int movement_bucked(struct char_data *ch, struct char_data *mount) {
   int diff = mountlevel(mount) - ideal_ridelevel(ch);

   if (diff < 1)
      return 0;
   if (diff > MOUNT_LEVEL_FUDGE)
      return 1;

   return number(0, 999) <
      1 + pow((double)(2 * diff) / MOUNT_LEVEL_FUDGE, 3) * 150 / 8;
}

/* mount_bucked
 *
 * True or false: will this character be bucked while trying to mount?
 */

int mount_bucked(struct char_data *ch, struct char_data *mount) {
   int diff = mountlevel(mount) - ideal_mountlevel(ch);

   if (diff < 1)
      return 0;
   if (diff > MOUNT_LEVEL_FUDGE)
      return 1;

   return number(0, 999) <
      50 + pow((double)(2 * diff) / MOUNT_LEVEL_FUDGE, 3) * 850 / 8;
}

/* mount_fall
 *
 * True or false: will this character fall while trying to mount?
 */

int mount_fall(struct char_data *ch, struct char_data *mount) {
   int diff = mountlevel(mount) - ideal_mountlevel(ch);

   if (diff < 1)
      return 0;
   if (diff > MOUNT_LEVEL_FUDGE)
      return 1;

   return number(0, 999) <
      10 + pow((double)(2 * diff) / MOUNT_LEVEL_FUDGE, 3) * 250 / 8;
}

void mount_warning(struct char_data *ch, struct char_data *vict) {
   int diff = mountlevel(vict) - ideal_mountlevel(ch);

   if (diff > 15) {
      act("You can't even imagine controlling $N!", FALSE, ch, 0, vict, TO_CHAR);
   } else if (diff > MOUNT_LEVEL_FUDGE + 2) {
      act("You're nowhere near being able to control such a powerful beast.",
            FALSE, ch, 0, 0, TO_CHAR);
   } else if (diff > MOUNT_LEVEL_FUDGE) {
      act("You don't feel quite up to riding $N.", FALSE, ch, 0, vict, TO_CHAR);
   }
}

a235 4
 *
 *   Returns :
 *   1 : If success.
 *   0 : If fail
d238 1
a238 1
int do_simple_move(struct char_data *ch, int dir, int need_specials_check)
d240 2
a241 1
   int flying = 0, boat = 0, levitating = 0;
d264 1
a264 1
      return 0;
d268 1
a268 1
     return 0;
d270 1
a270 1
     return 0;
d272 1
a272 1
     return 0;
d276 1
a276 1
      return 0;
d285 1
a285 1
               return 0;
d291 1
a291 1
                  return 0;
d298 1
a298 1
            return 0;
d328 1
a328 1
   boat = has_boat(actor) || has_boat(motivator);
d371 1
a371 1
      return 0;
d395 1
a395 1
      return 0;
d405 1
a405 1
      return 0;
d412 1
a412 1
      return 0;
d417 1
a417 1
      return 0;
d424 1
a424 1
       return 0;
d429 1
a429 1
       return 0;
d436 1
a436 1
       return 0;
d441 1
a441 1
       return 0;
d449 1
a449 1
         return 0;
d458 1
a458 1
         return 0;
d465 1
a465 1
      return 0;
d481 1
a481 1
         return 0;
d490 1
a490 1
         return 0;
d497 1
a497 1
         return 0;
d501 1
a501 1
         return 0;
d507 1
a507 1
      return 0;
d509 1
a509 1
      return 0;
d580 1
a580 1
         return 0;
d606 2
a607 1
   if (ROOM_EFF_FLAGGED(actor->in_room, ROOM_EFF_CIRCLE_FIRE) && !EFF_FLAGGED(actor, EFF_NEGATE_HEAT)) {
d611 1
a611 1
         return 0;
a616 15
   if (ROOM_FLAGGED(CH_NROOM(actor), ROOM_DEATH)) {
      if (GET_LEVEL(actor) < LVL_IMMORT) {
         log_death_trap(actor);
         death_cry(actor);
         extract_char(actor);
      }

      if (mount && GET_LEVEL(mount) < LVL_IMMORT) {
         log_death_trap(mount);
         death_cry(mount);
         extract_char(mount);
      }
      return 0;
   }

d619 1
a619 1
         return 0;
d625 1
a625 1
   return 1;
d629 1
a629 1
int perform_move(struct char_data *ch, int dir, int need_specials_check, bool misdirection)
a2281 3
  void stop_follower(struct char_data *ch, int violent);
  void add_follower(struct char_data *ch, struct char_data *leader);

a2352 2
  void stop_follower(struct char_data *ch, int violent);

d2736 2
a2737 1
  else if (SECT(ch->in_room) == SECT_WATER_NOSWIM && !has_boat(ch) && GET_POS(ch) != POS_FLYING)
d3124 3
@


1.149
log
@Actions affecting corpses just go to the syslog now, not the RIP log.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.148 2008/08/29 04:16:26 myc Exp myc $
d649 1
a649 1
   vnum = CH_NDEST(actor, dir);
d670 1
a670 1
   if (!entry_mtrigger(actor, CH_NDEST(actor, dir)))
d3306 3
@


1.148
log
@Changed calls to look_at_room and moved its prototype to a header file.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.147 2008/08/28 23:42:53 rbr Exp myc $
d1848 2
a1849 1
      sprintf(buf,"killed: %s tried to drag %s without CONSENT!",
a1850 2
      mudlog(buf, BRF, LVL_IMMORT, TRUE);
      log(buf);
d1909 5
a1913 11
    if (tobj && IS_PLR_CORPSE(tobj)) {
      /*
       * Note: killed is the keyword autorun greps on to sort corpse
       * info into the rip log.
       */
      sprintf(buf, "killed: %s dragged %s through %s from room %d to room %d",
              GET_NAME(ch), tobj->short_description,
              strip_ansi(portal->short_description),
              world[from_room].vnum, world[to_room].vnum);
      log(buf);
    }
d1980 4
a1983 10
    if (tobj && IS_PLR_CORPSE(tobj)) {
      /*
       * Note: killed is the keyword autorun greps on to sort corpse
       * info into the rip log.
       */
      sprintf(buf, "killed: %s drags %s from room %d to room %d.",
            GET_NAME(ch), tobj->short_description,
            world[from_room].vnum, world[to_room].vnum);
      log(buf);
    }
d3306 3
@


1.147
log
@Added do_abandon (abandon (lists follower), abandon players (abandon all players), abandon pets (abandon all charmies), abandon <player> (abandons a specific player) Note there are slight differences in whether PK is on or off.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.146 2008/08/19 02:11:14 jps Exp rbr $
d42 1
d753 1
a753 1
      look_at_room(mount, 1);
d778 1
a778 1
      look_at_room(actor, 0);
d800 1
a800 1
      look_at_room(actor, 0);
a1277 1
   extern char *relative_location_str(int bits);
d1516 1
a1516 1
  look_at_room(ch, 1);
d1521 1
a1521 1
    look_at_room(RIDING(ch), 1);
d1714 1
a1714 1
      look_at_room(vict, 0);
d3042 275
d3319 3
@


1.146
log
@Don't apply fluid/rigidity restrictions to immortals.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.145 2008/08/18 01:35:38 jps Exp jps $
d41 1
d53 1
a2468 1

d2540 253
d3044 3
@


1.145
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.144 2008/08/17 20:24:31 jps Exp jps $
d1324 1
a1324 1
   if (!SOLIDCHAR(ch) && (!obj || obj->carried_by != ch)) {
d1752 1
a1752 1
  if (tobj && !RIGID(ch)) {
d1757 1
a1757 1
  } else if (tch) {
d2610 1
a2610 1
   } else if (RIGID(ch) && !RIGID(vict)) {
d2627 1
a2627 1
   } else if (!RIGID(ch) && RIGID(vict)) {
d2790 3
@


1.144
log
@Rewrite doorbash.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.143 2008/08/09 20:35:57 jps Exp jps $
d1282 1
a1282 1
      send_to_char("You are too busy fighting to concentrate on that right now.\n\r",
d1408 1
a1408 1
    send_to_char("You are too busy fighting to leave right now.\n\r",ch);
d1529 1
a1529 1
    send_to_char("You are too busy fighting to leave!\n\r",ch);
d1565 1
a1565 1
         send_to_char("You can't take time out to do that just yet!\n\r",ch);
d2580 1
a2580 1
      send_to_char("You are too busy fighting to try that right now.\n\r",ch);
d2677 1
a2677 1
    send_to_char("You would get hacked to pieces if you dismount now!\n\r",ch);
d2699 1
a2699 1
    send_to_char("Worry about this &bafter&0 the battle!\n\r",ch);
d2715 1
a2715 1
    send_to_char("You can't tame while fighting!\n\r",ch);
d2790 3
@


1.143
log
@Changed sense life so that it has a chance of detecting the presence and movement
of creatures with a "healable" life force. Increased spell duration to 17-50 hrs.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.142 2008/07/10 21:23:54 jps Exp jps $
d40 1
a401 2
   bool wall_block_check(struct char_data *actor, struct char_data *motivator, int dir);

d892 1
a892 1
        misdir = searchblock(arg, dirs, FALSE);
d947 1
a947 1
      if ((dir = searchblock(dirname, dirs, FALSE)) == -1) {  /* Partial Match */
d1554 8
a1561 5
  char arg[MAX_INPUT_LENGTH];
  int dir = 0, percent, temp, dam;
  struct exit *exit;
  struct room_data *dest;
  room_num ndest;
d1563 17
a1579 3
  one_argument(argument, arg);
  percent = number(0, 101);
  temp = percent + GET_LEVEL(ch);
d1581 3
a1583 18
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    temp = 101;
  }
  if (GET_SKILL(ch, SKILL_DOORBASH) == 0 && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("You don't have that skill.", ch);
    return;
  }
  if (!*arg && ((GET_SKILL(ch, SKILL_DOORBASH)) || (GET_LEVEL(ch) >= LVL_IMMORT))) {
    send_to_char("&0What direction?&0\r\n", ch);
    return;
  }
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (FIGHTING(ch)) {
      send_to_char("You can't take time out to do that just yet!\n\r",ch);
      return ;
    }
    if (GET_SIZE(ch) < SIZE_LARGE) {
      send_to_char("&0You do not feel massive enough!&0\r\n", ch);
d1585 1
a1585 2
    }
  }
d1587 2
a1588 28
  if (*arg){
    switch (*arg) {
    case 'n':
    case 'N':
      dir = 0;
      break;
    case 'e':
    case 'E':
      dir = 1;
      break;
    case 's':
    case 'S':
      dir = 2;
      break;
    case 'w':
    case 'W':
      dir = 3;
      break;
    case 'u':
    case 'U':
      dir = 4;
      break;
    case 'd':
    case 'D':
      dir = 5;
      break;
    default:
      send_to_char("Doorbash where?\r\n", ch);
d1590 9
a1598 3
      break;
    }
  }
d1600 2
a1601 4
  if (CONFUSED(ch) && number(0, 1) == 0) {
     send_to_char("&5You are confused!&0\r\n", ch);
     dir = number(0, 5);
  }
d1603 3
a1605 4
  if ((GET_SKILL(ch, SKILL_DOORBASH) || (GET_LEVEL(ch) >= LVL_IMMORT))) {
    exit = CH_EXIT(ch, dir);
    if (!exit || EXIT_NDEST(exit) == NOWHERE || EXIT_IS_HIDDEN(exit)) {
      send_to_char("&0Even YOU couldn't bash through that!...\r\n&0", ch);
d1607 8
a1614 5
    }
    dest = EXIT_DEST(exit);
    ndest = EXIT_NDEST(exit);
    if (CH_DEST(ch, dir) && !EXIT_IS_CLOSED(exit)) {
      send_to_char("&0There is no obstruction!&0\r\n", ch);
d1616 6
a1621 3
    }
    if (exit->keyword == NULL) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A one sided door in room %d",
d1623 1
a1623 2
      log(buf);
      send_to_char("&0This exit seems broken.  Please tell a god.&0\r\n", ch);
d1625 3
a1627 3
    }
    else if (!EXIT_IS_DOOR(exit)) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A closed nondoor exit in room %d",
d1629 1
a1629 2
      log(buf);
      send_to_char("&0This exit seems broken.  Please tell a god.&0\r\n", ch);
d1631 1
a1631 1
    }
d1633 7
a1639 47
    if (!EXIT_IS_PICKPROOF(exit)) {
      if (EXIT_IS_CLOSED(exit) || EXIT_IS_LOCKED(exit)) {
        if (temp < 80) {
          /*           improve_skill(ch, SKILL_DOORBASH); */
          sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n",
                exit_name(exit));
          send_to_char(buf, ch);
          sprintf(buf, "&0$n &0charges at the %s but simply bounces off!&0",
                exit_name(exit));
          act(buf, FALSE, ch, 0, 0, TO_ROOM);

          WAIT_STATE(ch, PULSE_VIOLENCE*3);
          if (GET_LEVEL(ch) < LVL_IMMORT) {
            dam = ((percent / 10) * (GET_LEVEL(ch) / 10)) + GET_LEVEL(ch);
            if (GET_HIT(ch) - dam < -5)
               dam = GET_HIT(ch) + 5;
            hurt_char(ch, NULL, dam, TRUE);
            return;
          }
        }

        if (temp > 79) {
          /*           improve_skill(ch, SKILL_DOORBASH); */
          OPEN_DOORK(ch->in_room, dir);

          sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", exit_name(exit));
          act(buf, FALSE, ch, 0, 0, TO_ROOM);
          sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n",
                exit_name(exit));
          send_to_char(buf, ch);
          sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
          /* FIXME - won't this just send the message to one person in the room? */
          act(buf, FALSE, dest->people, 0, ch, TO_CHAR);

          if (dest->exits[rev_dir[dir]]) {
            OPEN_DOORK(ndest, rev_dir[dir]);
            WAIT_STATE(ch, PULSE_VIOLENCE);
            perform_move(ch, dir, 1, FALSE);
          } else {
            WAIT_STATE(ch, PULSE_VIOLENCE);
            perform_move(ch, dir, 1, FALSE);
            return;
          }
          return;
        }
      } else {
        /*       improve_skill(ch, SKILL_DOORBASH); */
d1641 13
a1653 11
        sprintf(buf, "&0You CHARGE at the %s &0but merely bounce off!&0\r\n",
              exit_name(exit));
        send_to_char(buf, ch);
        sprintf(buf, "&0$n &0CHARGES at the %s&0 and literally bounces off!&0",
              exit_name(exit));
        act(buf, FALSE, ch, 0, 0, TO_ROOM);

        WAIT_STATE(ch, PULSE_VIOLENCE*3);
        if (GET_LEVEL(ch) < LVL_IMMORT) {
         dam = ((percent / 10) * (GET_LEVEL(ch) / 10)) + GET_LEVEL(ch);
          if (GET_HIT(ch) - dam < -5)
d1655 5
a1659 3
          hurt_char(ch, NULL, dam, TRUE);
          return;
        }
d1661 35
a1695 2
    }
  }
d1866 1
a1866 1
  if ((dir = search_block(arg, dirs, FALSE)) < 0) {
d2790 4
@


1.142
log
@Add some fail-to-mount messages for ether critters, which are different from
the messages involving other "fluid" critters.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.141 2008/06/09 23:00:13 myc Exp jps $
d50 1
a50 1

d269 121
d395 1
a395 1
 *   1 : If succes.
d407 1
a407 1
   struct char_data *people;
d682 1
a682 1
   /* If camoflauged and entering a building, snap into visibility */
d706 1
a706 1
     /* Camo flag makes you lose minimal hide points per move */
d710 1
a710 2
      * and for already sneaking.
      */
d722 2
a723 38

   LOOP_THRU_PEOPLE(people, actor) {
      if ((actor == people) || !AWAKE(people))
         continue;
      if (people == RIDING(actor)) {
         sprintf(tmp, "%s you.", mmsg);
         act(tmp, FALSE, actor, 0, people, TO_VICT);
         continue;
      }
      if (mount) {
         if (!CAN_SEE(people, mount) && !CAN_SEE(people, actor) &&
               (CAN_SEE_BY_INFRA(people, actor) || CAN_SEE_BY_INFRA(people, mount))) {
            sprintf(buf1, "&1&bA %s-sized creature rides %s on a %s mount.&0\r\n",
                  SIZE_DESC(actor),
                  dirs[dir],
                  SIZE_DESC(mount));
            send_to_char(buf1, people);
         } else {
            sprintf(tmp, "%s %s.", mmsg, CAN_SEE(people, mount) ?
               GET_NAME(mount) : "something");
            act(tmp, FALSE, actor, 0, people, TO_VICT);
         }
      } else if (EFF_FLAGGED(actor, EFF_MISDIRECTING)) {
         if (SEES_THROUGH_MISDIRECTION(people, actor))
            act(mmsg, FALSE, actor, 0, people, TO_VICT);
      } else if (!CAN_SEE(people, actor)) {
         if (!CAN_SEE_BY_INFRA(people, actor))
            continue;
         sprintf(buf1, "&1&bA %s-sized creature leaves %s.&0\r\n",
                  SIZE_DESC(actor),
                  dirs[dir]);
         send_to_char(buf1, people);
      } else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !EFF_FLAGGED(actor, EFF_SNEAK))
         act(mmsg, FALSE, actor, 0, people, TO_VICT);
      else if (GET_LEVEL(people) >= LVL_IMMORT ?
                 GET_LEVEL(people) >= GET_LEVEL(actor) :
                 GET_PERCEPTION(people) >= GET_HIDDENNESS(actor))
         act(mmsg, FALSE, actor, 0, people, TO_VICT);
d762 2
a763 32
   LOOP_THRU_PEOPLE(people, actor) {
      if ((actor == people) || !AWAKE(people))
         continue;
      if (people == mount)
         continue;
      if (mount) {
         sprintf(buf2, "%s%s.", tmp,
            CAN_SEE(people, mount) ? GET_NAME(mount) : "something");
         if (!CAN_SEE(people, mount) && !CAN_SEE(people, actor) &&
               (CAN_SEE_BY_INFRA(people, actor) || CAN_SEE_BY_INFRA(people, mount))) {
            sprintf(buf1, "&1&bA %s-sized creature arrives from %s%s, riding a %s mount.&0\r\n",
                  SIZE_DESC(actor),
                  (dir < UP  ? "the " : ""),
                  (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]),
                  SIZE_DESC(mount));
            send_to_char(buf1, people);
         } else
            act(buf2, FALSE, actor, 0, people, TO_VICT);
      } else if (!CAN_SEE(people, actor)) {
         if (!CAN_SEE_BY_INFRA(people, actor))
            continue;
         sprintf(buf1, "&1&bA %s-sized creature arrives from %s%s.&0\r\n",
                  SIZE_DESC(actor),
                  (dir < UP  ? "the " : ""),
                  (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
         send_to_char(buf1, people);
      } else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !EFF_FLAGGED(actor, EFF_SNEAK))
         act(buf, FALSE, actor, 0, people, TO_VICT);
      else if (PRF_FLAGGED(people, PRF_HOLYLIGHT) ?
               GET_LEVEL(people) >= GET_LEVEL(actor) :
               GET_PERCEPTION(people) >= GET_HIDDENNESS(actor))
         act(buf, FALSE, actor, 0, people, TO_VICT);
d2812 4
@


1.141
log
@Got rid of the disembark command and the ocean current list.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.140 2008/06/07 19:06:46 myc Exp myc $
d2579 15
a2593 6
      act("You lay a hand on $N, but it slips right through.", FALSE,
            ch, 0, vict, TO_CHAR);
      act("$n tries to mount you, but you are too fluid to support $m",
            FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to mount $N, but $E isn't solid enough to support a rider.",
            TRUE, ch, 0, vict, TO_NOTVICT);
d2596 15
a2610 6
      act("You try to climb $M, but you just flow right off.",
            FALSE, ch, 0, vict, TO_CHAR);
      act("$n tries to mount you, but just flows right off.",
            FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to mount $N, but just flows right off.",
            FALSE, ch, 0, vict, TO_NOTVICT);
d2758 3
@


1.140
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.139 2008/05/19 06:53:45 jps Exp myc $
a2737 22
ACMD(do_disembark)
{
  /* The actual functionality for this exists in spec_procs.c */
  return;
}

struct current_info current[] = {
/*  Room  Direction Percent
   -------------------------  */
  { 1204, WEST,    50 },
  {23242, DOWN, 20},
  {23241, DOWN, 75},
  {23240, DOWN, 70},
  {23239, DOWN, 80},
  {23238, DOWN, 80},
  {23237, DOWN, 90},
  {23000, DOWN, 90},
  {23001, SOUTH, 90},
  { -1, -1, -1 }
};


d2740 3
@


1.139
log
@Got rid of fup and fdown directions.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.138 2008/05/18 20:16:11 jps Exp jps $
a967 7
#define OBJ_IS_OPENABLE(obj) (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
      IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSEABLE))
#define OBJ_IS_OPEN(obj) (!IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSED))
#define OBJ_IS_UNLOCKED(obj) (!IS_SET(GET_OBJ_VAL(obj, 1), CONT_LOCKED))
#define OBJ_IS_PICKPROOF(obj) (IS_SET(GET_OBJ_VAL(obj, 1), CONT_PICKPROOF))
#define OBJ_KEY_VNUM(obj) (GET_OBJ_VAL(obj, 2))

d997 1
a997 1
   REMOVE_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED);
d1022 1
a1022 1
   SET_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED);
d1052 1
a1052 1
      keyvnum = GET_OBJ_VAL(obj, 2);
d1084 1
a1084 1
   REMOVE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED);
d1119 1
a1119 1
      keyvnum = GET_OBJ_VAL(obj, 2);
d1151 1
a1151 1
   SET_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED);
d1211 1
a1211 1
   REMOVE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED);
d1397 1
a1397 1
  if ((rnum = real_room(GET_OBJ_VAL(obj, 0))) == NOWHERE) {
d1404 1
a1404 1
  if (GET_OBJ_VNUM(obj) == HEAVENSGATE_OBJ) {
d1418 1
a1418 1
  else if (GET_OBJ_VNUM(obj) == HELLGATE_OBJ) {
d1435 2
a1436 2
  if (GET_OBJ_VAL(obj, 1) >= 0) {
    for (i = 0; i < GET_OBJ_VAL(obj, 1) &&
d1443 2
a1444 2
  if (GET_OBJ_VAL(obj, 2) >= 0) {
    for (i = 0; i < GET_OBJ_VAL(obj, 2) &&
d1454 2
a1455 2
  if (GET_OBJ_VAL(obj, 1) >= 0) {
    for (i = 0; i < GET_OBJ_VAL(obj, 1) &&
d2762 3
@


1.138
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.137 2008/05/18 05:18:06 jps Exp jps $
d828 1
a828 1
        subcmd >= SCMD_STAY && subcmd <= SCMD_FDOWN) {
a874 2
    case SCMD_FUP:
    case SCMD_FDOWN:
d2769 3
@


1.137
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.136 2008/05/17 22:03:01 jps Exp jps $
d39 1
a45 1
void death_cry(struct char_data *ch);
d2771 4
@


1.136
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.135 2008/05/17 04:32:25 jps Exp jps $
d1311 1
a1311 1
            open_door(ch, CH_ROOM(ch), door, FALSE);
d1314 1
a1314 1
            close_door(ch, CH_ROOM(ch), door, FALSE);
d1317 1
a1317 1
            unlock_door(ch, CH_ROOM(ch), door, FALSE);
d1320 1
a1320 1
            lock_door(ch, CH_ROOM(ch), door, FALSE);
d1323 1
a1323 1
            pick_door(ch, CH_ROOM(ch), door);
d1514 1
d1587 1
d1594 1
a1594 1
            world[ch->in_room].number);
d1601 1
a1601 1
            world[ch->in_room].number);
d1642 1
a1642 1
            OPEN_DOORK(dest->number, rev_dir[dir]);
d1893 1
a1893 1
              world[from_room].number, world[to_room].number);
d1969 1
a1969 1
            world[from_room].number, world[to_room].number);
d2771 3
@


1.135
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.134 2008/05/14 05:11:28 jps Exp jps $
d38 1
d324 1
a324 1
            if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_GODROOM)) {
d329 2
a330 2
            if ((ch->master->in_room) != (EXIT(ch, dir)->to_room)) {
               if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_GODROOM)) {
d337 1
a337 1
         if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_GODROOM)) {
d393 1
a393 1
      need_movement = (movement_loss[SECT(EXIT(motivator, dir)->to_room)]
d467 2
a468 2
     if (!IS_WATER(EXIT(actor, dir)->to_room) &&
         SECT(EXIT(actor, dir)->to_room) != SECT_FLYING) {
d479 2
a480 2
     if (!IS_WATER(EXIT(actor, dir)->to_room) &&
         SECT(EXIT(actor, dir)->to_room) != SECT_FLYING) {
d487 1
a487 1
         (SECT(EXIT(actor, dir)->to_room) == SECT_FLYING)) {
d496 1
a496 1
         (SECT(EXIT(actor, dir)->to_room) == SECT_WATER_NOSWIM)) {
d503 1
a503 1
   if (SECT(EXIT(actor, dir)->to_room) == SECT_OCEAN &&
d526 1
a526 1
   vnum = world[EXIT(actor, dir)->to_room].number;
d528 1
a528 1
   if (ROOM_FLAGGED(actor->in_room, ROOM_ATRIUM)) {
d535 1
a535 1
   if (ROOM_FLAGGED(EXIT(actor, dir)->to_room, ROOM_TUNNEL)) {
d540 1
a540 1
      if (num_pc_in_room(&(world[EXIT(actor, dir)->to_room])) > 1) {
d547 1
a547 1
   if (!entry_mtrigger(actor, world[EXIT(actor, dir)->to_room].number))
d549 1
a549 1
   if (!enter_wtrigger(&world[EXIT(actor, dir)->to_room], actor, dir))
d563 2
a564 2
       (SECT(EXIT(actor, dir)->to_room) == SECT_INSIDE ||
        ROOM_FLAGGED(EXIT(actor, dir)->to_room, ROOM_INDOORS))) {
d724 1
a724 1
   if (ROOM_FLAGGED(actor->in_room, ROOM_DEATH)) {
a749 150
void cantgo_msg(struct char_data *ch, int dir)
{
   char *bumpinto = NULL;

   if (!CONFUSED(ch)) {
      send_to_char("Alas, you cannot go that way...\r\n", ch);
      return;
   }

   if (ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
      bumpinto = "a wall";
   else
   switch (SECT(ch->in_room)) {
      case SECT_CITY:
         switch (number(0, 1)) {
            case 0:
               bumpinto = "a wall";
               break;
            default:
               bumpinto = "a fence";
               break;
         }
         break;
      case SECT_FIELD:
      case SECT_GRASSLANDS:
         bumpinto = "a large bush";
         break;
      case SECT_FOREST:
      case SECT_SWAMP:
         switch(number(0, 3)) {
            case 0:
               bumpinto = "a large bush";
               break;
            case 1:
               bumpinto = "a nearby rock";
               break;
            default:
               bumpinto = "a tree";
               break;
         }
         break;
      case SECT_HILLS:
      case SECT_MOUNTAIN:
         switch(number(0, 5)) {
            case 0:
               bumpinto = "an old stump";
               break;
            case 1:
               bumpinto = "a boulder";
               break;
            case 2:
               bumpinto = "a large rock";
               break;
            case 3:
               bumpinto = "a scraggly tree";
               break;
            default:
               bumpinto = "a steep hillside";
               break;
         }
         break;
      case SECT_WATER_SWIM:
         switch(number(0, 4)) {
            case 0:
               bumpinto = "a steep bank";
               break;
            case 1:
               bumpinto = "a submerged log";
               break;
            case 2:
               bumpinto = "some tree trunks";
               break;
            default:
               bumpinto = "an embankment";
               break;
         }
         break;
      case SECT_WATER_NOSWIM:
      case SECT_OCEAN:
         switch(number(0, 3)) {
            case 0:
               bumpinto = "a crashing wave";
               break;
            case 1:
               bumpinto = "a spinning eddy";
               break;
            default:
               bumpinto = "a powerful current";
               break;
         }
         break;
      case SECT_UNDERWATER:
         switch(number(0, 4)) {
            case 0:
               bumpinto = "a spinning eddy";
               break;
            case 1:
               bumpinto = "a submerged whirlpool";
               break;
            case 2:
               bumpinto = "an underwater cliff";
               break;
            case 3:
               bumpinto = "a wall";
               break;
            default:
               bumpinto = "a powerful current";
               break;
         }
         break;
      case SECT_FLYING:
         switch(number(0, 2)) {
            case 0:
               bumpinto = "a gust of wind";
               break;
            default:
               bumpinto = "a blustery gale";
               break;
         }
         break;
      case SECT_BEACH:
         switch(number(0, 2)) {
            case 0:
               bumpinto = "a steep sand dune";
               break;
            case 1:
               bumpinto = "a massive boulder";
               break;
            default:
               bumpinto = "a huge tuft of sandgrass";
               break;
         }
         break;
      case SECT_ROAD:
      case SECT_RUINS:
      case SECT_INSIDE:
      case SECT_UNDERDARK:
      default:
         bumpinto = "a wall";
         break;
   }

   if (bumpinto) {
      act("Oops!  You bumped into $T!", FALSE, ch, 0, bumpinto, TO_CHAR);
      sprintf(buf, "$n tried to walk away and bumped into %s!",
            bumpinto);
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
   }
}

d753 1
a753 1
  int was_in, to_room;
d758 3
a760 20
  else if (!misdirection && (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE))
    cantgo_msg(ch, dir);
  else if (!misdirection &&
        (
           (GET_LEVEL(ch) < LVL_GOD && IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN)) ||
           IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT)
        ))
    cantgo_msg(ch, dir);
  else if (!misdirection && IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED) &&
        GET_LEVEL(ch) < LVL_GOD) {
    if (EXIT(ch, dir)->keyword) {
       if (isplural(EXIT(ch, dir)->keyword))
         sprintf(buf2, "The %s seem to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
       else
         sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf2, ch);
    }
    else
      send_to_char("It seems to be closed.\r\n", ch);
  } else {
d777 1
a777 1
    if (!EXIT(ch, dir))
d780 1
a780 1
       to_room = EXIT(ch, dir)->to_room;
d889 1
a889 1
int find_door(struct char_data *ch, char *type, char *dir, char *cmdname, int quiet)
d891 2
a892 1
   int door;
d894 3
a896 2
   if (*dir) {   /* a direction was specified */
      if ((door = searchblock(dir, dirs, FALSE)) == -1) {	/* Partial Match */
d901 12
a912 13
      if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
         if (EXIT(ch, door)->keyword)
            if (isname(type, EXIT(ch, door)->keyword))
               return door;
            else {
               if (!quiet) {
                  sprintf(buf2, "I see no %s there.\r\n", type);
                  send_to_char(buf2, ch);
               }
               return -1;
            } else
               return door;
      else {
d917 2
a918 2
   } else {            		/* try to locate the keyword */
      if (!*type) {
d925 5
a929 5
      for (door = 0; door < NUM_OF_DIRS; door++)
         if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
            if (EXIT(ch, door)->keyword)
               if (isname(type, EXIT(ch, door)->keyword))
                  return door;
d931 1
a931 1
         sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
d939 1
a939 1
int has_key(struct char_data *ch, int key)
d943 2
d946 2
a947 2
    if (GET_OBJ_VNUM(o) == key)
      return 1;
d950 2
a951 2
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD)) == key)
      return 1;
d954 2
a955 2
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD2)) == key)
      return 1;
d957 1
a957 1
  return 0;
a959 5
#define NEED_OPEN	1
#define NEED_CLOSED	2
#define NEED_UNLOCKED	4
#define NEED_LOCKED	8

d969 73
a1041 1
const int flags_door[] =
d1043 51
a1093 6
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_OPEN,
  NEED_CLOSED | NEED_LOCKED,
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_CLOSED | NEED_LOCKED
};
d1095 1
d1097 10
a1106 7
#define EXITN(room, door)		(world[room].exits[door])
#define OPEN_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_CLOSED)))
#define LOCK_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_LOCKED)))
d1108 1
a1108 1
void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd)
d1110 14
a1123 2
  int other_room = 0;
  struct exit *back = 0;
d1125 36
a1160 4
  if (FIGHTING(ch)) {
    send_to_char("You better hope your gut doesnt get opened by whom you are fighting!\r\n",ch);
    return;
  }
d1162 1
a1162 2
  if (!door_mtrigger(ch, scmd, door) || !door_wtrigger(ch, scmd, door))
    return;
d1164 9
a1172 59
  sprintf(buf, "$n %ss ", cmd_door[scmd]);
  if (!obj && ((other_room = EXIT(ch, door)->to_room) != NOWHERE))
    if ((back = world[other_room].exits[rev_dir[door]]))
      if (back->to_room != ch->in_room)
	back = 0;

  switch (scmd) {
  case SCMD_OPEN:
  case SCMD_CLOSE:
    OPEN_DOOR(ch->in_room, obj, door);
    if (back)
      OPEN_DOOR(other_room, obj, rev_dir[door]);
    /* Since the door is open, it's no longer secret on the other side. --Fingon */
    if (back) {
      if (IS_SET(back->exit_info, EX_HIDDEN)) {
	REMOVE_BIT(back->exit_info, EX_HIDDEN);
      }
    }
    send_to_char(OK, ch);
    break;
  case SCMD_UNLOCK:
  case SCMD_LOCK:
    LOCK_DOOR(ch->in_room, obj, door);
    /* (un)Lock the opposite side if it uses the same key. */
    if (
          back &&
          back->exit_info & EX_ISDOOR &&
          back->key == EXITN(ch->in_room, door)->key &&
          (back->exit_info & EX_LOCKED) != (EXITN(ch->in_room, door)->exit_info & EX_LOCKED)
          )
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("*Click*\r\n", ch);
    break;
  case SCMD_PICK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back && back->exit_info & EX_LOCKED)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("The lock quickly yields to your skills.\r\n", ch);
    strcpy(buf, "$n skillfully picks the lock on ");
    improve_skill(ch, SKILL_PICK_LOCK);
    break;
  }

  /* Notify the room */
  sprintf(buf + strlen(buf), "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
	  (EXIT(ch, door)->keyword ? "$F" : "door"));
  if (!(obj) || (obj->in_room != NOWHERE))
    act(buf, FALSE, ch, obj, obj ? 0 : EXIT(ch, door)->keyword, TO_ROOM);

  /* Notify the other room */
  if ((scmd == SCMD_OPEN || scmd == SCMD_CLOSE) && back) {
    sprintf(buf, "The %s is %s%s from the other side.\r\n",
	    (back->keyword ? fname(back->keyword) : "door"), cmd_door[scmd],
	    (scmd == SCMD_CLOSE) ? "d" : "ed");
    if (world[EXIT(ch, door)->to_room].people) {
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_ROOM);
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_CHAR);
    }
  }
d1175 15
d1191 13
a1203 10
int ok_pick(struct char_data *ch, int keynum, int pickproof, int scmd)
{
  int percent;

  percent = number(1, 101);

  if (scmd == SCMD_PICK) {
    if (keynum < 0)
      send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
    else if (pickproof)
d1205 8
a1212 1
    else if (percent > GET_SKILL(ch, SKILL_PICK_LOCK)) {
d1215 11
a1225 6
    }
    else
      return (1);
    return (0);
  }
  return (1);
a1228 21
#define DOOR_IS_OPENABLE(ch, obj, door)	((obj) ? \
			((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && \
			(IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSEABLE))) :\
			(IS_SET(EXIT(ch, door)->exit_info, EX_ISDOOR)))
#define DOOR_IS_OPEN(ch, obj, door)	((obj) ? \
			(!IS_SET(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
			(!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED)))
#define DOOR_IS_UNLOCKED(ch, obj, door)	((obj) ? \
			(!IS_SET(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
			(!IS_SET(EXIT(ch, door)->exit_info, EX_LOCKED)))
#define DOOR_IS_PICKPROOF(ch, obj, door) ((obj) ? \
			(IS_SET(GET_OBJ_VAL(obj, 1), CONT_PICKPROOF)) : \
			(IS_SET(EXIT(ch, door)->exit_info, EX_PICKPROOF)))

#define DOOR_IS_CLOSED(ch, obj, door)	(!(DOOR_IS_OPEN(ch, obj, door)))
#define DOOR_IS_LOCKED(ch, obj, door)	(!(DOOR_IS_UNLOCKED(ch, obj, door)))
#define DOOR_KEY(ch, obj, door)		((obj) ? (GET_OBJ_VAL(obj, 2)) : \
					(EXIT(ch, door)->key))
#define DOOR_LOCK(ch, obj, door)	((obj) ? (GET_OBJ_VAL(obj, 1)) : \
					(EXIT(ch, door)->exit_info))

d1231 11
a1241 5
  extern char *relative_location_str(int bits);
  int door = -1, keynum, bits;
  char type[MAX_INPUT_LENGTH], dir[MAX_INPUT_LENGTH];
  struct obj_data *obj = NULL;
  struct char_data *victim = NULL;
d1243 6
a1248 4
  if (FIGHTING(ch)) {
    send_to_char("You are too busy fighting to concentrate on that right now.\n\r",ch);
    return;
  }
d1250 1
a1250 6
  skip_spaces(&argument);
  if (!*argument) {
    sprintf(buf, "%s what?\r\n", cmd_door[subcmd]);
    send_to_char(CAP(buf), ch);
    return;
  }
d1252 3
a1254 1
  two_arguments(argument, type, dir);
d1256 7
a1262 3
  /* Identify the thing to be manipulated.
   * If a directory is specified, or no such object could be found, we'll
   * try to find a door. */
d1264 2
a1265 4
  if (*dir ||
        !(bits =
           generic_find(type, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj)))
    door = find_door(ch, type, dir, cmd_door[subcmd], FALSE);
d1267 10
a1276 2
  /* If you've named an object that doesn't open/close, you might have
   * intended to manipulate a door. */
d1278 8
a1285 4
  if (obj && !DOOR_IS_OPENABLE(ch, obj, door)) {
    door = find_door(ch, type, dir, cmd_door[subcmd], TRUE);
    if (door >= 0) obj = 0;
  }
d1287 2
a1288 8
  /* If you're made of fluid, the only way you can open/close/etc. something
   * is if it's an object in your inventory. */
  if (!SOLIDCHAR(ch) && (!obj || obj->carried_by != ch)) {
    sprintf(buf, "You can't manipulate solid objects in your %s%s&0 state.\r\n",
          COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
    send_to_char(buf, ch);
    return;
  }
d1290 38
a1327 27
  if ((obj) || (door >= 0)) {
    keynum = DOOR_KEY(ch, obj, door);
    if (!(DOOR_IS_OPENABLE(ch, obj, door)) || ((obj) && IS_CORPSE(obj))) {
      if (obj) {
        sprintf(buf, "You can't $F $p %s.", relative_location_str(bits));
        act(buf, FALSE, ch, obj, cmd_door[subcmd], TO_CHAR);
      } else
        act("You can't $F that!", FALSE, ch, 0, cmd_door[subcmd], TO_CHAR);
    } else if (!DOOR_IS_OPEN(ch, obj, door) &&
       IS_SET(flags_door[subcmd], NEED_OPEN))
      send_to_char("But it's already closed!\r\n", ch);
    else if (!DOOR_IS_CLOSED(ch, obj, door) &&
       IS_SET(flags_door[subcmd], NEED_CLOSED))
      send_to_char("But it's currently open!\r\n", ch);
    else if (!(DOOR_IS_LOCKED(ch, obj, door)) &&
       IS_SET(flags_door[subcmd], NEED_LOCKED))
      send_to_char("Oh... it wasn't locked, after all.\r\n", ch);
    else if (!(DOOR_IS_UNLOCKED(ch, obj, door)) &&
       IS_SET(flags_door[subcmd], NEED_UNLOCKED))
      send_to_char("It seems to be locked.\r\n", ch);
    else if (!has_key(ch, keynum) && (GET_LEVEL(ch) < LVL_GOD) &&
       ((subcmd == SCMD_LOCK) || (subcmd == SCMD_UNLOCK)))
      send_to_char("You don't seem to have the proper key.\r\n", ch);
    else if (ok_pick(ch, keynum, DOOR_IS_PICKPROOF(ch, obj, door), subcmd))
      do_doorcmd(ch, obj, door, subcmd);
  }
  return;
d1372 1
a1372 1
    if (ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
d1376 3
a1378 3
        if (EXIT(ch, i) &&
            !IS_SET(EXIT(ch, i)->exit_info, EX_CLOSED) &&
            ROOM_FLAGGED(EXIT(ch, i)->to_room, ROOM_INDOORS)) {
d1488 1
a1488 1
  if (!ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
d1492 10
a1501 11
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED) &&
	      !ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS)) {
       if (CONFUSED(ch)) {
          send_to_char("&5You are confused!&0\r\n", ch);
          door = number(0, 5);
       }
	    perform_move(ch, door, 1, FALSE);
	    return;
	  }
d1512 2
d1580 2
a1581 1
    if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) {
d1585 2
a1586 2
    if (EXIT(ch, dir) && EXIT(ch, dir)->to_room != NOWHERE &&
        !IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
d1590 3
a1592 2
    if(EXIT(ch, dir)->keyword == NULL) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A one sided door in room %d", world[ch->in_room].number);
d1594 1
a1594 1
      send_to_char("&0This exit seems broken, tell a god.&0\r\n", ch);
d1597 3
a1599 2
    else if(!IS_SET(EXIT(ch, dir)->exit_info, EX_ISDOOR)) {
      sprintf(buf, "SYSERR:act.item.c:do_doorbash():A closed nondoor exit in room %d", world[ch->in_room].number);
d1601 1
a1601 1
      send_to_char("&0This exit seems broken, tell a god.&0\r\n", ch);
d1605 18
a1622 21
    if (EXIT(ch, dir)) {
      if (!(IS_SET(EXIT(ch, dir)->exit_info, EX_PICKPROOF))) {
        if ((IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) ||
            (IS_SET(EXIT(ch, dir)->exit_info, EX_LOCKED))) {
          if (temp < 80) {
            /*           improve_skill(ch, SKILL_DOORBASH); */
            sprintf(buf, "&0You charge at the %s &0but merely bounce off!&0\r\n",
                    fname(EXIT(ch, dir)->keyword));
            send_to_char(buf, ch);
            sprintf(buf, "&0$n &0charges at the %s but simply bounces off!&0",
                    fname(EXIT(ch, dir)->keyword));
            act(buf, FALSE, ch, 0, 0, TO_ROOM);

            WAIT_STATE(ch, PULSE_VIOLENCE*3);
            if (GET_LEVEL(ch) < LVL_IMMORT) {
              dam = ((percent / 10) * (GET_LEVEL(ch) / 10)) + GET_LEVEL(ch);
              if (GET_HIT(ch) - dam < -5)
                 dam = GET_HIT(ch) + 5;
              hurt_char(ch, NULL, dam, TRUE);
              return;
            }
d1624 1
d1626 21
a1646 23
          if (temp > 79) {
            /*           improve_skill(ch, SKILL_DOORBASH); */
            OPEN_DOORK(ch->in_room, dir);

            sprintf(buf, "&0$n &0*CRASHES* through the %s&0!", fname(EXIT(ch, dir)->keyword));
            act(buf, FALSE, ch, 0, 0, TO_ROOM);
            sprintf(buf, "&0You *CHARGE* at the %s &0and crash through it!&0\r\n",
                    fname(EXIT(ch, dir)->keyword));
            send_to_char(buf, ch);
            sprintf(buf, "&0&b&8Splinters and dust fly as $N &0&b&8*CRASHES* into the room!&0");
            act(buf, FALSE, (world[EXIT(ch, dir)->to_room].people), 0, ch, TO_CHAR);

            if (world[EXIT(ch, dir)->to_room].exits[rev_dir[dir]]) {
              OPEN_DOORK(EXIT(ch, dir)->to_room, rev_dir[dir]);
              WAIT_STATE(ch, PULSE_VIOLENCE);
              perform_move(ch, dir, 1, FALSE);
            } else {
              WAIT_STATE(ch, PULSE_VIOLENCE);
              perform_move(ch, dir, 1, FALSE);
              return;
            }


d1654 1
a1654 1
                fname(EXIT(ch, dir)->keyword));
d1657 1
a1657 1
                fname(EXIT(ch, dir)->keyword));
d2769 3
@


1.134
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.133 2008/05/11 05:43:26 jps Exp jps $
d37 1
d662 1
a662 1
   char_to_room(actor, world[was_in].dir_option[dir]->to_room);
d1147 1
a1147 1
#define EXITN(room, door)		(world[room].dir_option[door])
d1158 1
a1158 1
  struct room_direction_data *back = 0;
d1170 1
a1170 1
    if ((back = world[other_room].dir_option[rev_dir[door]]))
d1529 1
a1529 1
#define EXITK(room, dir) (world[room].dir_option[dir])
d1657 1
a1657 1
            if (world[EXIT(ch, dir)->to_room].dir_option[rev_dir[dir]]) {
d2790 3
@


1.133
log
@Using alter_hit() and alter_pos() instead of calling damage and update_pos.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.132 2008/04/19 22:43:09 jps Exp jps $
d1639 1
a1639 1
              alter_hit(ch, NULL, dam, TRUE);
d1685 1
a1685 1
          alter_hit(ch, NULL, dam, TRUE);
d2567 1
a2567 1
   alter_hit(rider, NULL, dice(1, 3), TRUE);
d2632 1
a2632 1
      alter_hit(ch, NULL, dice(1, 2), TRUE);
d2662 1
a2662 1
    alter_hit(ch, NULL, dice(1, 2), TRUE);
d2789 3
@


1.132
log
@There's a chance of falling when you dismount.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.131 2008/04/14 05:11:40 jps Exp jps $
d36 1
d443 1
a443 3
      GET_POS(actor) = POS_SITTING;
      GET_STANCE(actor) = STANCE_ALERT;
      update_pos(actor);
d1532 1
a1532 1
  int dir = 0, percent, temp;
d1635 5
a1639 8
            if(GET_LEVEL(ch) < LVL_IMMORT) {
              if ((GET_HIT(ch) - (((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch))) > -5) {
                GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
                update_pos(ch);
              } else {
                GET_HIT(ch) = -5;
                update_pos(ch);
              }
d1681 6
a1686 7
        if(GET_LEVEL(ch) < LVL_IMMORT) {
          if ((GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch)))>-5) {
            GET_HIT(ch) = GET_HIT(ch)-(((percent/10)*(GET_LEVEL(ch)/10))+GET_LEVEL(ch));
            update_pos(ch);
          } else {
            GET_HIT(ch) = -5;
            update_pos(ch);}
a1687 1
        return;
d2565 3
a2567 6
   damage(rider, rider, dice(1, 3), -1);

   if (!whilemounting) {
      GET_POS(rider) = POS_SITTING;
      update_pos(rider);
   }
d2630 1
a2630 1
      damage(ch, ch, dice(1, 2), -1);
d2632 1
a2632 3
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_ALERT;
      update_pos(ch);
d2660 1
a2660 1
    damage(ch, ch, dice(1, 2), -1);
d2662 1
a2662 3
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_ALERT;
    update_pos(ch);
d2789 3
@


1.131
log
@Renamed EFF_FLYING to EFF_FLY, since it only indicates an ability
to fly - not that the characer is actually flying.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.130 2008/04/14 02:18:45 jps Exp jps $
d2641 3
d2668 9
a2676 1
  else {
d2802 4
@


1.130
log
@Removing unused function prototype.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.129 2008/04/14 01:26:18 jps Exp jps $
d2021 1
a2021 1
   if (!EFF_FLAGGED(ch, EFF_FLYING) && GET_LEVEL(ch) < LVL_IMMORT) {
d2791 3
@


1.129
log
@Change confused movement to happen only 50% of the time.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.128 2008/04/13 21:56:22 jps Exp jps $
a45 1
bool is_aggr_to(struct char_data *ch,struct char_data *target);
d2791 3
@


1.128
log
@Moved doorbash here from act.item.c.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.127 2008/04/13 20:07:25 jps Exp jps $
d1017 1
a1017 1
     if (CONFUSED(ch)) {
d1027 1
a1027 1
  if (CONFUSED(ch)) {
d2792 3
@


1.127
log
@Implemented confusion, making it hard to walk around or
drag people.  Following will succeed 80% of the time, though.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.126 2008/04/13 01:09:51 jps Exp jps $
d1529 171
d2792 4
@


1.126
log
@Don't allow rigid/fluid mount/rider pairs.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.125 2008/04/07 17:22:12 jps Exp jps $
d750 149
d909 1
a909 1
    send_to_char("Alas, you cannot go that way...\r\n", ch);
d915 1
a915 1
    send_to_char("Alas, you cannot go that way...\r\n", ch);
d963 11
a973 2
            act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
            perform_move(k->follower, dir, 1, FALSE);
d1016 5
d1026 6
d1401 4
d1518 4
a1539 2
   } else {
      act("&3$n&3 drags you behind $m.&0", FALSE, ch, 0, vict, TO_VICT);
d1647 1
a1647 1
    } else if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
d1762 5
d1773 6
d2621 3
@


1.125
log
@Fix bug waking other characters.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.124 2008/04/07 15:35:47 jps Exp jps $
d2258 16
d2435 3
@


1.124
log
@Updated the fly command.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.123 2008/04/07 04:54:55 jps Exp jps $
d2095 1
a2095 1
      GET_STANCE(ch) = STANCE_RESTING;
d2419 3
@


1.123
log
@Fix drag bug.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.122 2008/04/07 03:02:37 jps Exp jps $
d1646 43
a1688 34
  /* Immortals+ should have the ability to fly at will. */
  if(GET_LEVEL(ch) >= LVL_IMMORT)
  {
    act("&6&bYou begin to float.&0",FALSE,ch,0,0,TO_CHAR);
    act("&6&b$n&6&b begins to float.&0",TRUE,ch,0,0,TO_ROOM);
    GET_POS(ch) = POS_FLYING;
    return;
  }
  else if(!EFF_FLAGGED(ch, EFF_FLYING))  /* if affected by fly spell */
  {
    send_to_char("You do not have the means to fly.\r\n",ch);
    return;
  }
  else if (FIGHTING(ch))  /* fighting and then attempting to fly */
  {
    send_to_char("You are too busy fighting to worry about flying.\n\r",ch);
    return;
  }
  else if(GET_POS(ch) == POS_FLYING)  /* already flying */
  {
    send_to_char("You are already flying.\r\n",ch);
    return;
  }
  else if(GET_POS(ch) != POS_STANDING) {
    send_to_char("Your not in the proper position to fly.\r\n",ch);
    return;
  }
  else /* default case */
  {
    act("&6&bYou begin to float.&0",FALSE,ch,0,0,TO_CHAR);
    act("&6&b$n&6&b begins to float.&0",TRUE,ch,0,0,TO_ROOM);
    GET_POS(ch) = POS_FLYING;
    GET_STANCE(ch) = STANCE_ALERT;
  }
d2419 3
@


1.122
log
@Made it impossible to drag solid people when you're fluid.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.121 2008/04/06 19:48:19 jps Exp jps $
d1413 24
a1436 22
  } else if (RIGID(ch) && !RIGID(tch)) {
     sprintf(buf, "$N's %s%s&0 seems to pass right through your fingers.",
           COMPOSITION_COLOR(tch), COMPOSITION_MASS(tch));
     act(buf, FALSE, ch, 0, tch, TO_CHAR);
     sprintf(buf, "$n tries to grab $N, but $e can't get a grip on $N's %s%s&0 flesh.",
           COMPOSITION_COLOR(tch), COMPOSITION_ADJECTIVE(tch));
     act(buf, TRUE, ch, 0, tch, TO_NOTVICT);
     sprintf(buf, "$n tries to grab you, but $e can't get a grip on your %s%s&0 flesh.",
           COMPOSITION_COLOR(tch), COMPOSITION_ADJECTIVE(tch));
     act(buf, TRUE, ch, 0, tch, TO_VICT);
     return;
  } else if (!RIGID(ch) && RIGID(tch)) {
     sprintf(buf, "You can't get hold of $N with your %s%s&0 grip.",
           COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
     act(buf, FALSE, ch, 0, tch, TO_CHAR);
     sprintf(buf, "$n tries to grab $N, but $s %s%s&0 fingers can't get a grip.",
           COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
     act(buf, TRUE, ch, 0, tch, TO_NOTVICT);
     sprintf(buf, "$n tries to grab you, but $s %s%s&0 fingers can't get a grip.",
           COMPOSITION_COLOR(ch), COMPOSITION_ADJECTIVE(ch));
     act(buf, TRUE, ch, 0, tch, TO_VICT);
     return;
d2410 3
@


1.121
log
@Don't allow open/close/lock/unlock of solid objects when you're in a fluid state.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.120 2008/04/04 06:12:52 myc Exp jps $
d443 2
a444 2
      GET_POS(actor) = POS_RESTING;
      GET_STANCE(actor) = STANCE_RESTING;
d657 1
a657 1
      if (GET_POS(actor) == POS_DEAD || (mount && GET_POS(mount) == POS_DEAD))
d717 1
a717 1
      if (GET_POS(actor) == POS_DEAD)
d740 1
a740 1
      if (GET_POS(actor) == POS_DEAD)
d1352 22
d1391 1
a1391 1
  if (GET_POS(ch) == POS_FLYING) {
d1397 1
a1397 1
   * Start by figuring out what (or who) we're dragging.
d1406 2
a1407 1
   * also, you might think they're substantial-feeling because that's part of the illusion) */
d1445 1
a1445 1
    if (GET_LEVEL(ch) < LVL_GOD) {
d1458 2
a1459 2
       * as high as POS_SITTING.  I wouldn't recognize setting it any
       * higher.  It's currently set to POS_STUNNED, though.
d1461 1
a1461 1
      if (GET_POS(tch) > POS_STUNNED) {
d1470 2
a1471 2
    }
    else if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
d1540 2
a1541 2
      act("$n drags $p into $P.", TRUE, ch, tobj, portal, TO_ROOM);
      act("You drag $p into $P.", FALSE, ch, tobj, portal, TO_CHAR);
d1544 3
a1546 3
      act("$n drags $N into $p.", TRUE, ch, portal, tch, TO_NOTVICT);
      act("$n drags you into $p.", TRUE, ch, portal, tch, TO_VICT);
      act("You drag $N into $p.", FALSE, ch, portal, tch, TO_CHAR);
d1551 1
a1551 1
      act("$n drags $p from $P.", TRUE, ch, tobj, portal, TO_ROOM);
d1556 1
a1556 1
      act("$n drags $N from $p.", TRUE, ch, portal, tch, TO_ROOM);
d1559 1
a1559 4
      if (AWAKE(tch))
        look_at_room(tch, 0);
      else if (GET_POS(tch) == POS_SLEEPING)
        send_to_char("Your dreams grow bumpy, as if someone were dragging you...\r\n", tch);
d1605 2
a1606 2
      act("You drag $p behind you.", FALSE, ch, tobj, 0, TO_CHAR);
      act("$n drags $p behind $m.", TRUE, ch, tobj, 0, TO_ROOM);
d1609 3
a1611 3
      act("You drag $N behind you.", FALSE, ch, 0, tch, TO_CHAR);
      act("$n drags you $t behind $m.", TRUE, ch, (void *) dirs[dir], tch, TO_VICT);
      act("$n drags $N behind $m.", TRUE, ch, 0, tch, TO_NOTVICT);
d1620 1
a1620 1
      act("$n drags $p behind $m.", TRUE, ch, tobj, 0, TO_ROOM);
d1625 1
a1625 5
      if (AWAKE(tch))
        look_at_room(tch, 0);
      else if (GET_POS(tch) == POS_SLEEPING)
        send_to_char("Your dreams grow bumpy, as if someone were dragging you...\r\n", tch);
      act("$n drags $N behind $m.", TRUE, ch, 0, tch, TO_NOTVICT);
d1667 1
a1667 1
  else if(GET_POS(ch) != POS_STANDING || GET_STANCE(ch) != STANCE_STANDING){
d1676 1
a1676 1
    GET_STANCE(ch) = STANCE_STANDING;
d1682 48
a1729 77
  if (IS_NPC(ch)) {
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
  };

  switch (GET_POS(ch)) {
  case POS_STANDING:
    if(GET_STANCE(ch) == STANCE_PRONE) {
      act("You sit up and rise to your feet.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n sits up, and rises to $s feet.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
    }else if(GET_STANCE(ch) == STANCE_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
    }else if(GET_STANCE(ch) == STANCE_STANDING)
      act("You are already standing.", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_SITTING:
    act("You stand up.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_STANCE(ch) = STANCE_STANDING;
    break;
  case POS_RESTING:
    if(GET_STANCE(ch) == STANCE_PRONE) {
      act("You sit up and rise to your feet.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n sits up, and rises to $s feet.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
    }else if(GET_STANCE(ch) == STANCE_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
    }else if(GET_STANCE(ch) == STANCE_STANDING)
      act("You are already standing.", FALSE, ch, 0, 0, TO_CHAR);
    else{
      act("You stop resting, and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops resting, and clambers onto $s feet.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_STANDING;
    }
    break;
  case POS_SLEEPING:
    act("You have to wake up first!", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FIGHTING:
    if(GET_STANCE(ch) == STANCE_PRONE) {
      act("You sit up and rise to your feet.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n sits up, and rises to $s feet.", FALSE, ch, 0, 0, TO_ROOM);
      GET_STANCE(ch) = STANCE_STANDING;
    }else if(GET_STANCE(ch) == STANCE_KNEELING) {
      act("You stop kneeling and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
      GET_STANCE(ch) = STANCE_STANDING;
    }else
      act("Do you not consider fighting as standing?", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FLYING:
    act("You slowly descend to the surface beneath you.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n gently descends to the surface beneath $s feet.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_STANCE(ch) = STANCE_STANDING;
    break;
  default:
    act("You stop floating and slowly descend to the surface beneath you.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n gently descends to the surface beneath $s feet.",
	TRUE, 0, 0, ch, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    GET_STANCE(ch) = STANCE_STANDING;
    break;
  }
d1734 49
a1782 4
  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too incensed to sit down!\r\n", ch);
    return;
  }
d1784 2
a1785 42
  switch (GET_POS(ch)) {
  case POS_STANDING:
    if(GET_STANCE(ch) == STANCE_KNEELING) {
      act("You stop kneeling and sit down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops kneeling, and sits down.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_SITTING;
    }else if((GET_STANCE(ch) == STANCE_RESTING) ||
	     (GET_STANCE(ch) == STANCE_PRONE)) {
      act("You stop standing at ease and sit down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops standing at ease, and sits down.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      GET_STANCE(ch) = STANCE_SITTING;
    }else
      act("You sit down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_SITTING;
    break;
  case POS_SITTING:
    send_to_char("You're sitting already.\r\n", ch);
    GET_STANCE(ch) = STANCE_SITTING;
    break;
  case POS_RESTING:
    act("You stop resting, and sit up.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops resting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_SITTING;
    break;
  case POS_SLEEPING:
    act("You have to wake up first.", FALSE, ch, 0, 0, TO_CHAR);
    break;
  case POS_FIGHTING:
    act("Sit down while fighting? are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
    break;
  default:
    act("You stop floating around, and sit down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops floating around, and sits down.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_STANCE(ch) = STANCE_SITTING;
    break;
  }
d1788 1
d1791 21
a1811 4
  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too incensed to kneel down!\r\n", ch);
    return;
  }
d1813 2
a1814 30
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
  case POS_STUNNED:
    send_to_char("Posture is far from your biggest problem right now!\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You seem to be having a dream of infancy.\r\n", ch);
    return;
    break;
  case POS_FIGHTING:
    act("Kneel while fighting? are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
    return;
    break;
  case POS_RESTING:
  case POS_STANDING:
  case POS_FLYING:
    switch (GET_STANCE(ch)) {
    case STANCE_PRONE:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less get to your knees!\r\n", ch);
	return;
      }
      act("You swing up onto your knees.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n levers up onto $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_KNEELING:
      send_to_char("You are kneeling already.\r\n", ch);
d1816 24
a1839 27
      break;
    case STANCE_SITTING:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      act("You move from your butt to your knees.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops sitting around and gets to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_RESTING:
    case STANCE_STANDING:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less kneel!\r\n", ch);
	return;
      }
      if (GET_POS(ch) == POS_FLYING) {
        act("You stop flying and kneel.", FALSE, ch, 0, 0, TO_CHAR);
        act("$n stops flying and settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      } else {
        act("You kneel.", FALSE, ch, 0, 0, TO_CHAR);
        act("$n settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
      }
      break;
    }
    break;
  }
  GET_STANCE(ch) = STANCE_KNEELING;
d1844 21
a1864 4
  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too incensed to lie down!\r\n", ch);
    return;
  }
d1866 2
a1867 27
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
  case POS_STUNNED:
    send_to_char("Posture is far from your biggest problem right now!\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of lying down.\r\n", ch);
    return;
    break;
  case POS_FIGHTING:
    act("Recline while fighting? are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
    return;
    break;
  case POS_SITTING:
    act("You stop sitting around and lie down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops sitting around and lies down.", TRUE, ch, 0, 0, TO_ROOM);
    GET_STANCE(ch) = STANCE_PRONE;
    return;
    break;
  case POS_RESTING:
  case POS_STANDING:
  case POS_FLYING:
    if (FIGHTING(ch)) {
      send_to_char("Resting now will most likely lead to your final rest!\r\n", ch);
d1869 26
a1894 39
    }
    switch (GET_STANCE(ch)) {
    case STANCE_PRONE:
      send_to_char("You are already lying down.\r\n", ch);
      return;
      break;
    case STANCE_KNEELING:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less lie down!\r\n", ch);
	return;
      }
      act("You recline.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n eases off $s knees and lies down.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_SITTING:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      act("You stop sitting around and lie down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops sitting around and lies down.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_STANDING:
      if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
	send_to_char("You can't even twitch, much less change position!\r\n", ch);
	return;
      }
      if (GET_POS(ch) == POS_FLYING) {
        act("You gently land on your belly.", FALSE, ch, 0, 0, TO_CHAR);
        act("$n stops flying and drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);
      } else {
        act("You drop to your belly.", FALSE, ch, 0, 0, TO_CHAR);
        act("$n drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);
      }
      break;
    }
    break;
  }
  GET_STANCE(ch) = STANCE_PRONE;
d1899 19
a1917 4
  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too incensed to rest!\r\n", ch);
    return;
  }
d1919 2
a1920 29
  switch (GET_POS(ch)) {
  case POS_RESTING:
    send_to_char("You are already resting.\r\n", ch);
    return;
    break;
  case POS_SITTING:
    act("You find a comfortable spot where you are sitting.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n finds a comfortable spot where $e is sitting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_STANCE(ch) = STANCE_RESTING;
    GET_POS(ch) = POS_RESTING;
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of relaxing.\r\n", ch);
    return;
    break;
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
    send_to_char("Just wait a bit, you'll soon be VERY relaxed.\r\n", ch);
    return;
    break;
  case POS_FIGHTING:
    act("Rest while fighting?  Are you MAD?", FALSE, ch, 0, 0, TO_CHAR);
    return;
    break;
  case POS_STANDING:
    if (FIGHTING(ch)) {
      send_to_char("Resting now will most likely lead to your final rest!\r\n", ch);
d1922 7
a1928 1
    }
d1930 27
a1956 34
    if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You can't even twitch, much less relax!\r\n", ch);
      return;
    }
    switch (GET_STANCE(ch)) {
    case STANCE_PRONE:
      send_to_char("You close your eyes and relax.\r\n", ch);
      act("You see some of the tension leave $n's body.", TRUE, ch, 0, 0,
	  TO_ROOM);
      break;
    case STANCE_KNEELING:
      send_to_char("You slump and relax your posture.\r\n", ch);
      act("$n relaxes a bit.", TRUE, ch, 0, 0, TO_ROOM);
      GET_STANCE(ch) = STANCE_KNEELING;
      GET_POS(ch) = POS_RESTING;
      return;
      break;
    case STANCE_SITTING:
      send_to_char("You wiggle to find the most comfortable position.\r\n", ch);
      act("$n relaxes a bit.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_STANDING:
      send_to_char("You sit down and relax.\r\n", ch);
      act("$n sits down in a comfortable spot.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    }
    break;
  case POS_FLYING:
    send_to_char("You stop floating and rest your tired bones.\r\n", ch);
    act("$n stops floating and takes a rest.", TRUE, ch, 0, 0, TO_ROOM);
    break;
  }
  GET_STANCE(ch) = STANCE_RESTING;
  GET_POS(ch) = POS_RESTING;
d1958 1
d1965 22
a1986 21
  switch (GET_POS(ch)) {
  case POS_DEAD:
  case POS_MORTALLYW:
  case POS_INCAP:
    send_to_char("Just wait a bit, you'll soon be VERY relaxed.\r\n", ch);
    return;
    break;
  case POS_SLEEPING:
    send_to_char("You dream of being alert.\r\n", ch);
    return;
    break;
  case POS_FIGHTING:
    send_to_char("You're fighting, you don't have time to be alert!\r\n", ch);
    return;
    break;
  case POS_SITTING:
  case POS_STANDING:
  case POS_FLYING:
    if(GET_STANCE(ch) != STANCE_STANDING) {
      send_to_char("You tense up and become more alert.\r\n", ch);
      GET_STANCE(ch) = STANCE_STANDING;
d1988 20
a2007 30
    }else
      send_to_char("You are already about as tense as you can get.\r\n", ch);
    return;
    break;
  case POS_RESTING:
    if (FIGHTING(ch)) {
      send_to_char("Since your fighting, you better be alert!\r\n", ch);
      return;
      break;
    }
    switch (GET_STANCE(ch)) {
    case STANCE_PRONE:
      send_to_char("You stop relaxing and try to become more aware of your surroundings.\r\n", ch);
      break;
    case STANCE_KNEELING:
      send_to_char("You straighten up a bit.\r\n", ch);
      act("$n straightens up a bit.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_SITTING:
      send_to_char("You sit up straight and start to pay attention.\r\n",
		   ch);
      act("$n sits at attention.", TRUE, ch, 0, 0, TO_ROOM);
      break;
    case STANCE_STANDING:
      send_to_char("You tense up and become more alert.\r\n", ch);
      break;
    }
    break;
  }
  GET_POS(ch) = POS_STANDING;
d2012 42
a2053 8
  if (FIGHTING(ch)) {
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    return;
  }
  if (EFF_FLAGGED(ch, EFF_BERSERK)) {
    send_to_char("You're too incensed to take a nap!\r\n", ch);
    return;
  }
d2055 2
a2056 25
  switch (GET_POS(ch)) {
  case POS_FIGHTING:
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    return;
    break;
  case POS_STANDING:
  case POS_SITTING:
  case POS_RESTING:
    send_to_char("You lie down and go to sleep.\r\n", ch);
    act("$n lies down and goes to sleep.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    GET_STANCE(ch) = STANCE_PRONE;
    break;
  case POS_SLEEPING:
    send_to_char("You are already sound asleep.\r\n", ch);
    break;
  default:
    act("You stop floating around, and lie down to sleep.",
	FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops floating around, and lie down to sleep.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    GET_STANCE(ch) = STANCE_PRONE;
    break;
  }
d2067 1
a2067 1
    if (GET_POS(ch) == POS_SLEEPING)
d2073 1
a2073 1
    else if (GET_POS(vict) > POS_SLEEPING)
d2077 1
a2077 1
    else if (GET_POS(vict) < POS_SLEEPING)
d2082 3
a2084 3
	  TO_SLEEP);
      GET_POS(vict) = POS_RESTING;
      GET_STANCE(ch) = STANCE_PRONE;
d2091 1
a2091 1
  else if (GET_POS(ch) > POS_SLEEPING)
d2094 1
a2094 1
    send_to_char("You awaken, and sit up.\r\n", ch);
d2096 2
a2097 2
    GET_POS(ch) = POS_RESTING;
    GET_STANCE(ch) = STANCE_PRONE;
d2408 3
@


1.120
log
@Removed justice code.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.119 2008/04/03 02:05:34 myc Exp myc $
d1145 9
d1170 1
a1170 1
      send_to_char("Oh... it wasn't locked, after all..\r\n", ch);
a1182 2


d1382 32
d2460 3
@


1.119
log
@Depending on screen.h now.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.118 2008/03/28 17:54:53 myc Exp myc $
a46 1
void justice_trigger(struct char_data *tch);
a746 1
   justice_trigger(actor);
d2421 3
@


1.118
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.117 2008/03/10 20:46:55 myc Exp myc $
d35 1
d2423 4
@


1.117
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.116 2008/03/09 18:16:08 jps Exp myc $
d61 1
a61 1
  if (AFF_FLAGGED(ch, AFF_WATERWALK))
d136 1
a136 1
   if (AFF_FLAGGED(ch, AFF_TAMED))
d138 1
a138 1
   if (AFF_FLAGGED(ch, AFF_CHARM))
d313 1
a313 1
   if (EVENT_FLAGGED(ch, EVENT_GRAVITY) && !AFF2_FLAGGED(ch, AFF2_LEVITATE)) {
d322 1
a322 1
            if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
d328 1
a328 1
               if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
d335 1
a335 1
         if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
d378 2
a379 2
         (IS_AFFECTED2(actor, AFF2_LEVITATE) ||
          IS_AFFECTED2(motivator, AFF2_LEVITATE)))
d418 1
a418 1
      if (AFF_FLAGGED(ch, AFF_TAMED))
d450 1
a450 1
   if (AFF_FLAGGED(actor, AFF_CHARM) && !MOB_FLAGGED(actor, MOB_ANIMATED) &&
d528 1
a528 1
   if (IS_SET(ROOM_FLAGS(actor->in_room), ROOM_ATRIUM)) {
d535 1
a535 1
   if (IS_SET(ROOM_FLAGS(EXIT(actor, dir)->to_room), ROOM_TUNNEL)) {
d562 1
a562 1
   if (AFF3_FLAGGED(ch, AFF3_CAMOUFLAGED) &&
d566 1
a566 1
     affect_from_char(ch, SPELL_NATURES_EMBRACE);
d580 2
a581 2
   if (IS_HIDDEN(motivator) || AFF_FLAGGED(motivator, AFF_SNEAK)) {
     if (AFF_FLAGGED(motivator, AFF_SNEAK)) {
d586 1
a586 1
     else if (AFF3_FLAGGED(motivator, AFF3_CAMOUFLAGED))
d595 1
a595 1
       affect_from_char(motivator, SPELL_NATURES_EMBRACE);
d624 1
a624 1
      } else if (AFF3_FLAGGED(actor, AFF3_MISDIRECTING)) {
d634 1
a634 1
      } else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !AFF_FLAGGED(actor, AFF_SNEAK))
d647 2
a648 2
   if (ROOM_AFFECTED(actor->in_room, RAFF_CIRCLE_FIRE) &&
         !AFF2_FLAGGED(actor, AFF2_NEGATE_HEAT)) {
d704 1
a704 1
      } else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !AFF_FLAGGED(actor, AFF_SNEAK))
d714 1
a714 1
   if (ROOM_AFFECTED(actor->in_room, RAFF_CIRCLE_FIRE) && !AFF2_FLAGGED(actor, AFF2_NEGATE_HEAT)) {
d724 1
a724 1
   if (IS_SET(ROOM_FLAGS(actor->in_room), ROOM_DEATH)) {
d837 1
a837 1
  if (*arg && AFF3_FLAGGED(ch, AFF3_MISDIRECTION) &&
d858 1
a858 1
     SET_BIT(AFF3_FLAGS(ch), AFF3_MISDIRECTING);
d860 1
a860 1
     REMOVE_BIT(AFF3_FLAGS(ch), AFF3_MISDIRECTING);
d1266 1
a1266 1
      SET_BIT(AFF2_FLAGS(ch), AFF2_ON_FIRE);
d1280 2
a1281 2
      mag_affects(70, ch, ch, SPELL_INSANITY, SAVING_SPELL);
      mag_affects(70, ch, ch, SPELL_DISEASE, SAVING_SPELL);
d1331 1
a1331 1
  if (!IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS))
d1338 1
a1338 1
	      !IS_SET(ROOM_FLAGS(EXIT(ch, door)->to_room), ROOM_INDOORS)) {
d1598 1
a1598 1
  else if(!IS_AFFECTED(ch, AFF_FLYING))  /* if affected by fly spell */
d1709 1
a1709 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
d1760 1
a1760 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
a1783 4
    if (IS_AFFECTED2(ch, AFF2_KNOCKED_OUT)) {
      send_to_char("You should probably worry more about becoming conscious again.\r\n", ch);
      return;
    }
d1786 1
a1786 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1798 1
a1798 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1807 1
a1807 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1827 1
a1827 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
a1860 4
    if (IS_AFFECTED2(ch, AFF2_KNOCKED_OUT)) {
      send_to_char("You should probably worry more about becoming conscious again.\r\n", ch);
      return;
    }
d1867 1
a1867 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1875 1
a1875 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1883 1
a1883 1
      if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d1903 1
a1903 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
d1940 1
a1940 1
    if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) || IS_AFFECTED(ch, AFF_MAJOR_PARA)) {
d2041 1
a2041 1
  if (AFF_FLAGGED(ch, AFF_BERSERK)) {
d2089 1
a2089 1
    else if (IS_AFFECTED(vict, AFF_SLEEP))
d2103 1
a2103 1
  if (IS_AFFECTED(ch, AFF_SLEEP))
d2146 1
a2146 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master)
d2164 1
a2164 1
      SET_BIT(AFF3_FLAGS(ch), AFF3_SHADOWING);
d2173 1
a2173 1
        REMOVE_BIT(AFF3_FLAGS(ch), AFF3_SHADOWING);
d2281 1
a2281 1
   if (IS_NPC(vict) && !AFF_FLAGGED(vict, AFF_TAMED) && mount_bucked(ch, vict)) {
d2310 1
a2310 1
  else if (AFF_FLAGGED(ch, AFF_TAMED))
d2319 1
a2319 1
  struct affected_type af;
d2339 1
a2339 1
  } else if (AFF_FLAGGED(vict, AFF_TAMED)) {
d2385 7
a2391 8
  af.type = SKILL_TAME;
  af.duration = tame_duration;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_TAMED;
  af.bitvector2 = 0;
  af.bitvector3 = 0;
  affect_to_char(vict, &af);
d2422 3
@


1.116
log
@Implement misdirection. When you have AFF3_MISDIRECTION, you can enter
"<dir> <dir>" to go the first direction while pretending to go the
second. Each dir can be "stay".
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.115 2008/03/08 23:31:22 jps Exp jps $
d444 1
a444 1
      GET_POS1(actor) = POS1_RESTING;
d1613 1
a1613 1
  else if(GET_POS(ch) != POS_STANDING || GET_POS1(ch) != POS1_STANDING){
d1622 1
a1622 1
    GET_POS1(ch) = POS1_STANDING;
d1634 1
a1634 1
    if(GET_POS1(ch) == POS1_PRONE) {
d1638 2
a1639 2
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
d1643 2
a1644 2
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_STANDING)
d1651 1
a1651 1
    GET_POS1(ch) = POS1_STANDING;
d1654 1
a1654 1
    if(GET_POS1(ch) == POS1_PRONE) {
d1658 2
a1659 2
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
d1663 2
a1664 2
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_STANDING)
d1670 1
a1670 1
      GET_POS1(ch) = POS1_STANDING;
d1677 1
a1677 1
    if(GET_POS1(ch) == POS1_PRONE) {
d1680 2
a1681 2
      GET_POS1(ch) = POS1_STANDING;
    }else if(GET_POS1(ch) == POS1_KNEELING) {
d1684 1
a1684 1
      GET_POS1(ch) = POS1_STANDING;
d1694 1
a1694 1
    GET_POS1(ch) = POS1_STANDING;
d1702 1
a1702 1
    GET_POS1(ch) = POS1_STANDING;
d1716 1
a1716 1
    if(GET_POS1(ch) == POS1_KNEELING) {
d1720 3
a1722 3
      GET_POS1(ch) = POS1_SITTING;
    }else if((GET_POS1(ch) == POS1_RESTING) ||
	     (GET_POS1(ch) == POS1_PRONE)) {
d1726 1
a1726 1
      GET_POS1(ch) = POS1_SITTING;
d1731 1
a1731 1
    GET_POS1(ch) = POS1_SITTING;
d1735 1
a1735 1
    GET_POS1(ch) = POS1_SITTING;
d1741 1
a1741 1
    GET_POS1(ch) = POS1_SITTING;
d1753 1
a1753 1
    GET_POS1(ch) = POS1_SITTING;
d1788 2
a1789 2
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
d1797 1
a1797 1
    case POS1_KNEELING:
d1801 1
a1801 1
    case POS1_SITTING:
d1809 2
a1810 2
    case POS1_RESTING:
    case POS1_STANDING:
d1826 1
a1826 1
  GET_POS1(ch) = POS1_KNEELING;
d1855 1
a1855 1
    GET_POS1(ch) = POS1_PRONE;
d1869 2
a1870 2
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
d1874 1
a1874 1
    case POS1_KNEELING:
d1882 1
a1882 1
    case POS1_SITTING:
d1890 1
a1890 1
    case POS1_STANDING:
d1906 1
a1906 1
  GET_POS1(ch) = POS1_PRONE;
d1924 1
a1924 1
    GET_POS1(ch) = POS1_RESTING;
d1952 2
a1953 2
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
d1958 1
a1958 1
    case POS1_KNEELING:
d1961 1
a1961 1
      GET_POS1(ch) = POS1_KNEELING;
d1965 1
a1965 1
    case POS1_SITTING:
d1969 1
a1969 1
    case POS1_STANDING:
d1980 1
a1980 1
  GET_POS1(ch) = POS1_RESTING;
d2007 1
a2007 1
    if(GET_POS1(ch) != POS1_STANDING) {
d2009 1
a2009 1
      GET_POS1(ch) = POS1_STANDING;
d2021 2
a2022 2
    switch (GET_POS1(ch)) {
    case POS1_PRONE:
d2025 1
a2025 1
    case POS1_KNEELING:
d2029 1
a2029 1
    case POS1_SITTING:
d2034 1
a2034 1
    case POS1_STANDING:
d2065 1
a2065 1
    GET_POS1(ch) = POS1_PRONE;
d2076 1
a2076 1
    GET_POS1(ch) = POS1_PRONE;
d2106 1
a2106 1
      GET_POS1(ch) = POS1_PRONE;
d2119 1
a2119 1
    GET_POS1(ch) = POS1_PRONE;
d2431 5
@


1.115
log
@Typo!
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.114 2008/03/08 23:28:44 jps Exp jps $
d240 26
d624 4
a627 2
      }
      else if (!CAN_SEE(people, actor)) {
d696 1
a696 2
      }
      else if (!CAN_SEE(people, actor)) {
d753 1
a753 1
int perform_move(struct char_data *ch, int dir, int need_specials_check)
d760 1
a760 1
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
d762 5
a766 1
  else if ((GET_LEVEL(ch) < LVL_GOD && IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN)) || IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT))
d768 2
a769 1
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED) && GET_LEVEL(ch) < LVL_GOD) {
d779 7
a785 4
  }
  else {
    if (!ch->followers)
      return (do_simple_move(ch, dir, need_specials_check));
d789 1
a789 1
      if (CAN_SEE(k->follower, ch))
d795 5
a799 1
    to_room = EXIT(ch, dir)->to_room;
d801 3
a803 1
    if (!do_simple_move(ch, dir, need_specials_check))
d816 1
a816 1
            perform_move(k->follower, dir, 1);
d832 32
d865 3
d876 1
a876 1
      perform_move(ch, subcmd - 1, 0);
d879 1
a879 1
      if (argument && one_argument(argument, arg) &&
d881 1
a881 1
        perform_move(ch, subcmd, 0);
d1226 1
a1226 1
          perform_move(ch, i, 1);
d1339 1
a1339 1
	    perform_move(ch, door, 1);
d1530 1
a1530 1
    if (!perform_move(ch, dir, FALSE)) {
d2431 3
@


1.114
log
@Separate AFF_CHARM from MOB2_ILLUSORY.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.113 2008/02/09 04:27:47 myc Exp jps $
d424 1
a424 1
   if (AFF_FLAGGED(actor, AFF_CHARM) && !MOB_FLAGGED(actor, MOB_ANIMATED)
d2355 3
@


1.113
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.112 2008/02/07 01:46:14 myc Exp myc $
d45 1
a45 1
bool is_aggr_to(struct char_data *ch,struct char_data *target);  
d60 1
a60 1
  
d63 1
a63 1
  
d71 1
a71 1
  
d76 1
a76 1
  
d80 1
a80 1
  
d158 1
a158 1
   return number(0, 999) < 
d314 1
a314 1
   }  
d325 1
a325 1
         mudlog(buf, NRM, LVL_IMMORT, FALSE); 
d335 1
a335 1
         mudlog(buf, NRM, LVL_IMMORT, FALSE); 
d364 1
a364 1
   else 
d421 4
a424 5
   } 
  
   /* Charmed critters can't wander off (unless animated or illusory) */
   if (AFF_FLAGGED(actor, AFF_CHARM) && !MOB_FLAGGED(actor, MOB_ANIMATED) && 
         !MOB2_FLAGGED(actor, MOB2_ILLUSORY) &&
d429 1
a429 1
  
d482 1
a482 1
  
d519 1
a519 1
  
d525 1
a525 1
  
d562 1
a562 1
     /* Chance for hiddenness to decrease with a bonus for dex apply 
d565 1
a565 1
     else if (number(1, 101) > GET_SKILL(motivator, SKILL_SNEAK) + 
d622 1
a622 1
         mag_damage(GET_LEVEL(actor) + number(1, 10), actor, actor, 
d626 1
a626 1
         mag_damage(GET_LEVEL(mount) + number(1, 10), mount, mount, 
d638 1
a638 1
      char_to_room(mount, actor->in_room);   
d656 1
a656 1
         sprintf(buf2, "%s%s.", tmp, 
d679 1
a679 1
      else if (PRF_FLAGGED(people, PRF_HOLYLIGHT) ? 
d688 1
a688 1
      mag_damage(GET_LEVEL(actor) + number(1, 5), actor, actor, 
d744 2
a745 2
    } 
    else 
d747 1
a747 1
  } 
d749 1
a749 1
    if (!ch->followers) 
d754 1
a754 1
      if (CAN_SEE(k->follower, ch)) 
d761 2
a762 2
    
    if (!do_simple_move(ch, dir, need_specials_check)) 
d765 1
a765 1
    
d777 1
a777 1
      }    
d815 1
a815 1
   
d864 1
a864 1
  
d868 1
a868 1
  
d876 1
a876 1
  
d916 1
a916 1
  
d924 1
a924 1
  
d930 1
a930 1
  
d967 1
a967 1
  
d973 1
a973 1
  
d990 1
a990 1
  
d992 1
a992 1
  
d1038 1
a1038 1
  
d1069 1
a1069 1
  
d1133 1
a1133 1
  
d1250 1
a1250 1
  
d1278 1
a1278 1
  
d1281 1
a1281 1
  
d1348 1
a1348 1
       * Here we check for that flag.  But an exception is made so that 
d1353 1
a1353 1
        return; 
d1357 1
a1357 1
        send_to_char("It is too heavy for you to drag.\r\n", ch); 
d1430 1
a1430 1
       * Note: killed is the keyword autorun greps on to sort corpse 
d1446 1
a1446 1
        send_to_char("You are too exhausted!\r\n", ch);              
d1500 1
a1500 1
       * Note: killed is the keyword autorun greps on to sort corpse 
d1553 1
a1553 1
    WAIT_STATE(ch, PULSE_VIOLENCE * 2); 
d1609 1
a1609 1
    }else 
d1819 1
a1819 1
      if (GET_POS(ch) == POS_FLYING) {    
d1825 1
a1825 1
      }  
d1848 1
a1848 1
    GET_POS1(ch) = POS1_RESTING; 
d1871 1
a1871 1
    
d1906 1
a1906 1
  
d2010 1
a2010 1
  
d2051 1
a2051 1
  
d2059 1
a2059 1
  
d2061 1
a2061 1
  
d2149 1
a2149 1
   dismount_char(rider);  
d2195 1
a2195 1
   WAIT_STATE(ch, PULSE_VIOLENCE / 2); 
d2206 1
a2206 1
  
d2216 1
a2216 1
   }  
d2261 1
a2261 1
  
d2273 1
a2273 1
    return;    
d2282 1
a2282 1
  WAIT_STATE(ch, PULSE_VIOLENCE); 
d2308 1
a2308 1
  
d2355 3
d2736 1
a2736 1
 * This fixes all of the warnings associated with the new compiler and 
d2758 1
a2758 1
 * to properly handle boats and fly in water rooms while mounted or not 
@


1.112
log
@Removing the size_abbrevs array and renaming SIZE_ABBR to SIZE_DESC,
which points to the sizes array.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.111 2008/02/06 21:53:53 myc Exp myc $
d34 1
d2356 4
@


1.111
log
@do_enter was reading through the portal messages incorrectly.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.110 2008/02/02 04:27:55 myc Exp myc $
d589 1
a589 1
                  size_abbrevs[(int)GET_SIZE(actor)],
d591 1
a591 1
                  size_abbrevs[(int)GET_SIZE(mount)]);
d603 1
a603 1
                  size_abbrevs[(int)GET_SIZE(actor)],
d661 1
a661 1
                  size_abbrevs[(int)GET_SIZE(actor)],
d664 1
a664 1
                  size_abbrevs[(int)GET_SIZE(mount)]);
d673 1
a673 1
                  size_abbrevs[(int)GET_SIZE(actor)],
d2355 3
@


1.110
log
@Adding leave and door manipulation triggers.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.109 2008/01/30 19:20:57 myc Exp myc $
d1212 4
a1215 6

    for (i = 0; i < GET_OBJ_VAL(obj, 1) && portal_entry_messages[i]; ++i);
    if (*portal_entry_messages[i] != '\n') {
      strcpy(buf, portal_entry_messages[i]);
      act(buf, TRUE, ch, obj, 0, TO_ROOM);
    }
d1220 4
a1223 5
    for (i = 0; i < GET_OBJ_VAL(obj, 2) && portal_character_messages[i]; ++i);
    if (*portal_character_messages[i] != '\n') {
      strcpy(buf, portal_character_messages[i]);
      act(buf, TRUE, ch, obj, 0, TO_CHAR);
    }
d1231 4
a1234 5
    for (i = 0; i < GET_OBJ_VAL(obj, 1) && portal_exit_messages[i]; ++i);
    if (!portal_exit_messages[i] != '\n') {
      strcpy(buf, portal_exit_messages[i]);
      act(buf, TRUE, ch, obj, 0, TO_ROOM);
    }
d2355 3
@


1.109
log
@Gravity is now a delayed event; don't allow people to 'move' while falling.
Putting the flight room check before the water room one so you get
the right message when trying to go up into a flight room from a
water one.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.108 2008/01/29 21:02:31 myc Exp myc $
d254 1
a254 1
   int was_in, need_movement, vnum;
d269 1
d278 8
a612 1
   was_in = actor->in_room;
d713 2
a717 2
      if (GET_POS(actor) == POS_DEAD)
         return 0;
d917 1
a917 1
  if(FIGHTING(ch)) {
d921 3
d2359 6
@


1.108
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.107 2008/01/27 21:09:12 myc Exp myc $
d33 1
d277 5
d451 8
a473 8
   if ((SECT(actor->in_room) == SECT_FLYING) ||
         (SECT(EXIT(actor, dir)->to_room) == SECT_FLYING)) {
      if (!flying && dir == UP) {
         send_to_char("&7Try flapping your wings.&0\r\n", actor);
         return 0;
      }
   }

d2348 4
@


1.107
log
@Prevent characters from sitting, kneeling, reclining, resting, or
sleeping while berserking.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.106 2008/01/26 12:30:01 jps Exp myc $
d22 1
a34 9
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *obj_index;
extern int rev_dir[];
extern char *dirs[];
extern int movement_loss[];
extern const struct str_app_type str_app[];
extern struct dex_skill_type dex_app_skill[];
d2342 4
@


1.106
log
@Use skills.h to import improve_skill().
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.105 2008/01/25 21:05:45 myc Exp jps $
a676 7

      /* Disabling this for now, it should be an event
      if (is_aggr_to(people, actor))
         hit(people, actor, TYPE_UNDEFINED);
      else if (mount && is_aggr_to(people, mount))
         hit(people, mount, TYPE_UNDEFINED);
      */
d1628 5
d1679 5
d1750 5
d1830 5
d1968 5
a1972 1
  
d2350 3
@


1.105
log
@Added attack() as a macro alias for hit() with fewer arguments.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.104 2008/01/24 15:43:47 myc Exp $
d31 1
a50 1
void improve_skill(struct char_data *ch, int skill);
d2333 3
@


1.104
log
@Sneak and camouflaged flags were too powereful for players.  Made them
lose more hide points per move.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.103 2008/01/15 03:18:19 myc Exp myc $
d2276 1
a2276 1
            hit(vict, ch, TYPE_UNDEFINED);
d2285 1
a2285 1
  improve_skill(ch, SKILL_TAME);
d2333 4
@


1.103
log
@Rewrote give command so it always gives feedback.  Also made REMOVE
triggers not prevent immortals from removing items.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.102 2008/01/13 23:06:04 myc Exp myc $
d548 4
a551 2
     if (AFF_FLAGGED(motivator, AFF_SNEAK))
       /* sneak flag makes you lose no hide points per move */;
d554 1
a554 1
       GET_HIDDENNESS(motivator) = MAX(0, GET_HIDDENNESS(motivator) - 1);
d2333 4
@


1.102
log
@Removed the statsave function.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.101 2008/01/11 03:35:36 myc Exp myc $
d675 2
d681 1
d2331 3
@


1.101
log
@Disallow dragging live mobiles.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.100 2008/01/11 02:06:07 myc Exp myc $
a51 1
bool statsave(struct char_data *ch, int stat, int mod);
d2328 3
@


1.100
log
@Moved do_drag here from act.item.c.  It now allows you to drag
characters.  Also both characters and items may be dragged through
portals.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.99 2008/01/09 10:08:48 jps Exp myc $
d1308 2
a1309 1

d2329 5
@


1.99
log
@Allow folks with infrared to see people moving to and from dark rooms.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.98 2008/01/07 11:56:31 jps Exp jps $
d1268 241
d2328 3
@


1.98
log
@Allow illusory mobs to wander even if charmed.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.97 2008/01/04 01:53:26 jps Exp jps $
d578 12
a589 3
         sprintf(tmp, "%s %s.", mmsg, CAN_SEE(people, mount) ?
            GET_NAME(mount) : "something");
         act(tmp, FALSE, actor, 0, people, TO_VICT);
d591 8
a598 3
      else if (!CAN_SEE(people, actor))
         continue;
      else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !AFF_FLAGGED(actor, AFF_SNEAK))
d651 20
a670 5
         act(buf2, FALSE, actor, 0, people, TO_VICT);
      }
      else if (!CAN_SEE(people, actor))
         continue;
      else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor) && !AFF_FLAGGED(actor, AFF_SNEAK))
d2087 3
@


1.97
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.96 2008/01/01 03:20:19 jps Exp jps $
d416 1
a416 1
   /* Charmed critters can't wander off (unless animated) */
d418 1
d2058 4
@


1.96
log
@Allow open/close/lock/unlock on doors even if you have a same-named
item in your inventory, provided it doesn't open.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.95 2007/12/08 21:02:45 jps Exp jps $
d30 1
d2057 4
@


1.95
log
@Abort processing of do_simple_move if a mob greet trigger has
killed the actor (fixes crash bug).
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.94 2007/11/24 20:57:29 jps Exp jps $
d778 1
a778 1
int find_door(struct char_data *ch, char *type, char *dir, char *cmdname)
d780 42
a821 5
  int door;
  
  if (*dir) {			/* a direction was specified */
    if ((door = searchblock(dir, dirs, FALSE)) == -1) {	/* Partial Match */
      send_to_char("That's not a direction.\r\n", ch);
d823 1
a823 31
    }
    if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
      if (EXIT(ch, door)->keyword)
	if (isname(type, EXIT(ch, door)->keyword))
	  return door;
	else {
	  sprintf(buf2, "I see no %s there.\r\n", type);
	  send_to_char(buf2, ch);
	  return -1;
	} else
	  return door;
    else {
      send_to_char("I really don't see how you can close anything there.\r\n", ch);
      return -1;
    }
  } else {			/* try to locate the keyword */
    if (!*type) {
      sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
      send_to_char(buf2, ch);
      return -1;
    }
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door) && (!IS_SET(EXIT(ch, door)->exit_info, EX_HIDDEN)))
	if (EXIT(ch, door)->keyword)
	  if (isname(type, EXIT(ch, door)->keyword))
	    return door;
    
    sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
    send_to_char(buf2, ch);
    return -1;
  }
d1006 1
d1013 1
d1015 17
a1031 2
  if (*dir || !(bits = generic_find(type, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj)))
    door = find_door(ch, type, dir, cmd_door[subcmd]);
d2056 4
@


1.94
log
@Fix crash bug in enter - act() was being used to send a message
to a player while not in a room, which can cause segfaults.
Also fixed the markup in portal messages.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.93 2007/11/24 01:21:25 jps Exp jps $
d682 2
d2032 5
@


1.93
log
@Allow "open <str> <dir>" to ignore all objects and be used to
force the target to be a room's door.  Add a relative location string
to the failure message when trying to open/close/etc. an object.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.92 2007/10/20 19:01:48 myc Exp jps $
d1039 3
a1041 3
  "$p &0&b&8flares white as $n enters it and disappears.&0\r\n",
  "$p &0&b&8flares as $n enters it and disappears.&0\r\n",
  "$p &0&b&8vibrates violently as $n enters it and then stops.&0\r\n",
d1047 8
a1054 8
  "&0&b&8You feel your body being ripped apart!&0\r\n",
  "$p &0&b&8vibrates violently as you enter.&0\r\n",
  "&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n",
  "&0&b&8You appear in a completely different location!&0\r\n",
  "&0&b&9You feel your energy being drained!&0\r\n",
  "&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n\r\n"
    "&0&b&8You catch a glimpse of a giant white leopard!&0\r\n\r\n"
    "&0&b&9You feel your energy being drained!&0\r\n",
d1059 4
a1062 4
  "$p flares white as $n emerges from it.&0\r\n",
  "$p flares as $n emerges from it.&0\r\n",
  "$n appears from nowhere!&0\r\n",
  "&0There is a loud POP sound as $n emerges from $p.&0\r\n",
d1069 1
a1069 1
  int i, rnum, was_in;
a1156 3
  was_in = ch->in_room;
  char_from_room(ch);

d1166 1
d2030 5
@


1.92
log
@Make pick lock skill improve on failures.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.91 2007/10/17 17:18:04 myc Exp myc $
d987 2
a988 1
  int door = -1, keynum;
d1004 1
a1004 1
  if (!generic_find(type, FIND_OBJ_EQUIP | FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
d1009 8
a1016 4
    if (!(DOOR_IS_OPENABLE(ch, obj, door)) || ((obj) && IS_CORPSE(obj)))
      act("You can't $F that!", FALSE, ch, 0, cmd_door[subcmd], TO_CHAR);
    else if (!DOOR_IS_OPEN(ch, obj, door) &&
	     IS_SET(flags_door[subcmd], NEED_OPEN))
d1019 1
a1019 1
	     IS_SET(flags_door[subcmd], NEED_CLOSED))
d1022 2
a1023 2
	     IS_SET(flags_door[subcmd], NEED_LOCKED))
      send_to_char("Oh.. it wasn't locked, after all..\r\n", ch);
d1025 1
a1025 1
	     IS_SET(flags_door[subcmd], NEED_UNLOCKED))
d1028 1
a1028 1
	     ((subcmd == SCMD_LOCK) || (subcmd == SCMD_UNLOCK)))
d2032 3
@


1.91
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.90 2007/10/11 20:14:48 myc Exp myc $
d874 1
a874 1
  if(IS_FIGHTING(ch)) {
d952 1
a952 1
    else if (percent > GET_SKILL(ch, SKILL_PICK_LOCK))
d954 2
d992 1
a992 1
  if (IS_FIGHTING(ch)) {
d1189 1
a1189 1
  if(IS_FIGHTING(ch)) {
d1223 1
a1223 1
  else if (IS_FIGHTING(ch))  /* fighting and then attempting to fly */
d1466 1
a1466 1
    if (IS_FIGHTING(ch)) {
d1543 1
a1543 1
    if (IS_FIGHTING(ch)) {
d1616 1
a1616 1
    if (IS_FIGHTING(ch)) {
d1645 1
a1645 1
  if (IS_FIGHTING(ch)) {
d2027 4
@


1.90
log
@Make immortals able to mount, ride, and tame anyone.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.89 2007/10/04 16:20:24 myc Exp myc $
d768 1
a768 1
          (subcmd = search_block(arg, dirs, 0)) >= 0)
d781 1
a781 1
    if ((door = search_block(dir, dirs, FALSE)) == -1) {	/* Partial Match */
d2025 3
@


1.89
log
@Fixed a variable bug in do_enter.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.88 2007/10/02 02:52:27 myc Exp myc $
d96 3
d106 3
d118 3
d384 1
a384 1
      if (AFF_FLAGGED(ch, AFF_TAMED)) {
a385 2
         return 0;
      }
d388 1
a388 1
      if (IS_FIGHTING(actor) && movement_bucked(actor, mount)) {
d416 1
a416 1
   if ((IS_AFFECTED(actor, AFF_CHARM) && !MOB_FLAGGED(actor, MOB_ANIMATED)) && 
d1832 1
a1832 1
   if (IS_FIGHTING(ch)) {
d1892 1
a1892 1
  if (!RIDING(ch)) {
d1894 1
a1894 2
    return;
  } else if (IS_FIGHTING(ch)) {
d1896 1
a1896 2
    return;
  } else if (SECT(ch->in_room) == SECT_WATER_NOSWIM && !has_boat(ch) && GET_POS(ch) != POS_FLYING) {
d1898 5
a1902 1
    return;
a1903 5

  act("You dismount $N.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
  act("$n dismounts from you.", FALSE, ch, 0, RIDING(ch), TO_VICT);
  act("$n dismounts $N.", TRUE, ch, 0, RIDING(ch), TO_NOTVICT);
  dismount_char(ch);
d1908 1
a1908 2

  if (!RIDDEN_BY(ch)) {
d1910 3
a1912 5
    return;
  } else if (IS_FIGHTING(ch)) {
    send_to_char("Worry about this _after_ the battle!\n\r",ch);
    return;
  } else if (AFF_FLAGGED(ch, AFF_TAMED)) {
d1914 2
a1915 4
    return;
  }
  
  perform_buck(ch, FALSE);
d1926 1
a1926 1
  if(IS_FIGHTING(ch)) {
d2025 3
@


1.88
log
@Changed AFF_SNEAK flag to be perma sneak so we can still have permasneak
mobs and permasneak items.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.87 2007/09/28 20:49:35 myc Exp myc $
d1080 1
a1080 1
  if (!(obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
d2026 4
@


1.87
log
@Removed a redundant IS_AFFECTED check.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.86 2007/09/20 21:20:43 myc Exp myc $
d539 5
a543 2
   if (IS_HIDDEN(motivator)) {
     if (AFF3_FLAGGED(motivator, AFF3_CAMOUFLAGED))
d575 1
a575 1
      else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor))
d632 1
a632 1
      else if (!IS_HIDDEN(actor) && !OUTDOOR_SNEAK(actor))
d2026 3
@


1.86
log
@Hide points and perception are in.  AFF_HIDE and ITEM_HIDDEN are now
unused.  Sneak chance is now calculated based on hiddenness.  Cleaned
up blood pool code too.  Cleaned up do_enter a lot.  Portal messages
are now in arrays.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.85 2007/09/15 15:36:48 myc Exp myc $
d1939 1
a1939 1
  } else if (AFF_FLAGGED(vict, AFF_TAMED) || IS_AFFECTED(vict, AFF_TAMED)) {
d2023 6
@


1.85
log
@Natures embrace now sets camouflage bit, which lets you be hidden as long
as you are outside.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.84 2007/09/12 22:23:04 myc Exp myc $
d206 32
a246 3
#define BLOOD_DROP_OBJ     34   /* the vnum of the blood object */
#define BLOOD_POOL_OBJ     35   /* the vnum of the blood object */

d252 1
a252 4
   int was_in, need_movement;
   int vnum, chance;
   struct obj_data *bloodp, *bloodd, *i, *j;
   struct extra_descr_data *new_descr;
d526 1
d539 15
a553 11
   /* skill check for ability to sneak and remain hidden while sneaking */
   chance = number(1,101);
   /* scaled chance to a 101 point scale and added in dex apply for sneak, as well
      a bonus for already sneaking... since you were successful the first time.*/
   if ((chance > (GET_SKILL(motivator, SKILL_SNEAK) +
               dex_app_skill[GET_DEX(motivator)].sneak) + 15)  
         || ((GET_SKILL(motivator, SKILL_SNEAK) == 0) && chance < 5))
   {
      if (!AFF3_FLAGGED(motivator, AFF3_CAMOUFLAGED))
        REMOVE_BIT(AFF_FLAGS(motivator), AFF_HIDE);
      affect_from_char(motivator, SKILL_SNEAK); 
d555 2
a556 1
 
d569 8
a576 2
      } else if (!IS_AFFECTED(actor, AFF_SNEAK) && !OUTDOOR_SNEAK(actor) &&
            CAN_SEE(people, actor)) {
a577 7
      } else {
         if ((GET_LEVEL(people) >= LVL_IMMORT && GET_LEVEL(people) >= GET_LEVEL(actor)) || 
                (GET_LEVEL(actor) < LVL_IMMORT && (IS_AFFECTED(people, AFF_SENSE_LIFE) ||
                IS_AFFECTED3(people, AFF3_AWARE)) && statsave(people, APPLY_INT, -4))) {
           act(mmsg, FALSE, actor, 0, people, TO_VICT);
         }
      }
d582 2
a583 43

   if (pk_allowed) {

      /* If this person is going to bleed, get ready for them to leave blood.
       * First we remove all other blood from the room. */
      if (GET_HIT(actor) < (((int)(0.3 * GET_MAX_HIT(actor))))) {
         for (i = world[actor->in_room].contents; i; i = j) {
            j = i->next_content;
            if (GET_OBJ_VNUM(i) == 34) {
               extract_obj(i);
            } else if (GET_OBJ_VNUM(i) == 35) {
               extract_obj(i);
            }
         }
      }

      if (GET_HIT(actor) < ((int)(0.1 * GET_MAX_HIT(actor)))) {
         bloodp = read_object(BLOOD_POOL_OBJ, VIRTUAL);
         GET_OBJ_VAL(bloodp, 0) = actor->in_room;
         GET_OBJ_TIMER(bloodp) = 3;
         CREATE(new_descr, struct extra_descr_data, 1);
         new_descr->keyword = str_dup("blood pool");
         sprintf(buf, "&0&1Quite a large pool of blood.&0");
         new_descr->description = str_dup(buf);
         new_descr->next = bloodp->ex_description;
         bloodp->ex_description = new_descr;
         obj_to_room(bloodp, actor->in_room);
      }
      if (GET_HIT(actor) >= ((int)(0.1 * GET_MAX_HIT(actor))) && pk_allowed) {
         if (GET_HIT(actor)<((int)(0.3*GET_MAX_HIT(actor)))) {
            bloodd = read_object(BLOOD_DROP_OBJ, VIRTUAL);
            GET_OBJ_VAL(bloodd, 0) = actor->in_room;
            GET_OBJ_TIMER(bloodd) = 2;
            CREATE(new_descr, struct extra_descr_data, 1);
            new_descr->keyword = str_dup("blood drops");
            sprintf(buf, "&0&1Several drops of blood cover the ground here.&0");
            new_descr->description = str_dup(buf);
            new_descr->next = bloodd->ex_description;
            bloodd->ex_description = new_descr;
            obj_to_room(bloodd, actor->in_room);
         }
      }
   } /* end of pk_allowed blood trails section */
d626 8
a633 9

         if (is_aggr_to(people, actor))    /*NEW FASTER AGGRO! */
         /*if(number(0, 5))*/
            hit (people, actor, TYPE_UNDEFINED);
         else if (is_aggr_to(people, mount))
         /*if(number(0, 5))*/
            hit(people, mount, TYPE_UNDEFINED);
      } else if (!IS_AFFECTED(actor, AFF_SNEAK) && !OUTDOOR_SNEAK(actor) &&
            CAN_SEE(people, actor)) {
d635 4
a638 16
         if (is_aggr_to(people, actor))
         /*if(number(0, 5))*/
            hit(people, actor, TYPE_UNDEFINED);
      } else {
         if ((GET_LEVEL(people) >= LVL_IMMORT && GET_LEVEL(people) >= GET_LEVEL(actor)) || 
               (GET_LEVEL(actor) < LVL_IMMORT &&
               (IS_AFFECTED(people, AFF_SENSE_LIFE) || IS_AFFECTED3(people,AFF3_AWARE)) &&
               statsave(people, APPLY_INT, -4))) {
            act(buf, FALSE, actor, 0, people, TO_VICT);
            if (is_aggr_to(people, actor))    /*NEW FASTER AGGRO! */
               hit(people, actor, TYPE_UNDEFINED);
         } else {
            if (is_aggr_to(people, actor))
               hit(people, actor, TYPE_UNDEFINED);
         }
      }
d685 8
a692 10
  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS) 
  { return 0; } 
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) 
  { send_to_char("Alas, you cannot go that way...\r\n", ch); } 
  else if ((GET_LEVEL(ch) < LVL_GOD && IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN)) || IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT)) 
  { send_to_char("Alas, you cannot go that way...\r\n", ch);} 
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED) && GET_LEVEL(ch) < LVL_GOD) 
  {
    if (EXIT(ch, dir)->keyword) 
    {
d700 1
a700 1
    { send_to_char("It seems to be closed.\r\n", ch); }  
d702 1
a702 2
  else 
  {
d704 1
a704 1
    { return (do_simple_move(ch, dir, need_specials_check)); }
d707 1
a707 5
    for (k = ch->followers; k; k = next) 
    {
      next = k->next;
      k->can_see_master = FALSE;

d709 3
a711 2
      {	k->can_see_master = TRUE; }
    }   
d717 2
a718 1
    { return 0; }
d723 4
a726 4
               (k->follower->in_room == was_in) &&
               (GET_POS(k->follower) >= POS_STANDING) &&
               (!IS_FIGHTING(k->follower)) &&
               (!CASTING(k->follower)) &&
d819 4
d1021 28
d1052 1
a1052 2
  /*extern int top_of_world;*/
  int door, rnum, was_in;
d1054 1
a1054 1
  if (IS_FIGHTING(ch)) {
d1058 13
a1070 131
  one_argument(argument, buf);
  
  if (*buf) {	
    if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
      if (CAN_SEE_OBJ(ch, obj)) {
        if (GET_OBJ_TYPE(obj) == ITEM_PORTAL) {
	  if (GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) {
            send_to_char("You are not experienced enough to use this portal.\r\n", ch);
            return;
          }
	  /* Random portals: ie, obj# 4119 sends to rooms between 4100 and 4999. 
	     Add more as desired. */
	  
	  if (GET_OBJ_VNUM(obj) == 4119){
	    GET_OBJ_VAL(obj, 0) = number(4100, 4999);}
	  if (GET_OBJ_VNUM(obj) == 4137){
	    GET_OBJ_VAL(obj, 0) = number(32200, 32399);}
	  if (GET_OBJ_VNUM(obj) == 4138){
	    GET_OBJ_VAL(obj, 0) = number(32400, 32590);}
	  if (GET_OBJ_VNUM(obj) == 4139){
	    GET_OBJ_VAL(obj, 0) = number(32000, 32152);}
	  if (GET_OBJ_VNUM(obj) == 4140){
	    GET_OBJ_VAL(obj, 0) = number(5700, 5810);}
	  if (GET_OBJ_VAL(obj, 0) != 0) {
	    if (GET_OBJ_VNUM(obj) == 5604){
	      GET_OBJ_VAL(obj, 0) = number(5601, 5618);}
	    if (GET_OBJ_VNUM(obj) == 5605){
	      GET_OBJ_VAL(obj, 0) = number(5622, 5639);}
	    if (GET_OBJ_VNUM(obj) == 5606){
	      GET_OBJ_VAL(obj, 0) = number(5642, 5659);}
	    if (GET_OBJ_VNUM(obj) == 5607){
	      GET_OBJ_VAL(obj, 0) = number(5662, 5679);}
	    /* The formatting here makes me want to cry, so I am putting it here anyway  --Nechtrous */
	    if (GET_OBJ_VNUM(obj) == HEAVENSGATE_OBJ) {
	      if(GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500){
		act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE,ch,obj,0,TO_CHAR);
		act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.",TRUE,ch,obj,0,TO_ROOM);
		return;
	      }
	      else if(GET_ALIGNMENT(ch) <= -500) {
		act("&9&bUpon entering $p&9&b, you begin to &1burn&9... Your screams can be heard throughtout the &7heavens&9...&0",FALSE,ch,obj,0,TO_CHAR);
		act("&9&b$n&9&b enters $p&9&b... Following a &0&1blood&9&b curdling scream that spans the &7heavens&9, $n&9&b flails back out of the tunnel, &1&bon fire!&0",FALSE,ch,obj,0,TO_ROOM);
		damage(ch,ch,(int)(abs(GET_ALIGNMENT(ch))/10),TYPE_SUFFERING);
		SET_BIT(AFF2_FLAGS(ch), AFF2_ON_FIRE);
		return;
	      }
	    }
	    if (GET_OBJ_VNUM(obj) == HELLGATE_OBJ) {
	      if(GET_ALIGNMENT(ch) < 500 && GET_ALIGNMENT(ch) > -500){
		act("&0Upon attempting to enter $p&0, you are pushed back by a powerful force.", FALSE,ch,obj,0,TO_CHAR);
		act("&0Upon attempting to enter $p&0, $n&0 is pushed back by a powerful force.",TRUE,ch,obj,0,TO_ROOM);
		return;
	      }
	      else if(GET_ALIGNMENT(ch) >= 500) {
		act("&9&bUpon catching a glimpse of &1hell&9 itself, your &0&5mind&9&b twists and distorts... &0",FALSE,ch,obj,0,TO_CHAR);
		act("&9&b$n&9&b enters $p&9&b... Strange moaning sounds can be heard as $n&9&b wanders back out, twitching and drooling on $mself.&0",FALSE,ch,obj,0,TO_ROOM);
		damage(ch,ch,(int)(abs(GET_ALIGNMENT(ch))/10),TYPE_SUFFERING);
		mag_affects(70, ch, ch, SPELL_INSANITY, SAVING_SPELL);
		mag_affects(70, ch, ch, SPELL_DISEASE, SAVING_SPELL);
		return;
	      }
	    }
	    /* ENTRY MESSAGES */
	    if (GET_OBJ_VAL(obj, 1)==0){
	      act("$p &0&b&8flares white as $n enters it and disappears.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 1))==1){
	      act("$p &0&b&8flares as $n enters it and disappears.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 1))==2){
	      act("$p &0&b&8vibrates violently as $n enters it and then stops.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    was_in = ch->in_room;
	    char_from_room(ch);
	    /* CHARACTER MESSAGE */
	    if ((GET_OBJ_VAL(obj, 2))==(1)){
	      send_to_char("&0&b&8You feel your body being ripped apart!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(2)){
	      act("$p &0&b&8vibrates violently as you enter.&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(3)){
	      act("&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(4)){
	      send_to_char("&0&b&8You appear in a completely different location!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(5)){
	      send_to_char("&0&b&9You feel your energy being drained!&0\r\n", ch);
	    }
	    if ((GET_OBJ_VAL(obj, 2))==(6)){
	      act("&0&b&8Your molecules are ripped apart as you enter $p.&0\r\n"
		  "\r\n"
		  "\r\n"
		  "&0&b&8You catch a glimpse of a giant white leopard!&0\r\n"
		  "\r\n"
		  "\r\n"
		  "&0&b&9You feel your energy being drained!&0\r\n", FALSE, ch, obj, 0,TO_CHAR);
	    }
	    /* ROOM EXIT MESSAGE */
	    rnum = real_room(GET_OBJ_VAL(obj, 0));
	    if(rnum == NOWHERE) {
	      send_to_char("Cannot go to room NOWHERE.  Please report this bug to a god.\r\n", ch);
	      sprintf(buf, "SYSERR:act.movement.c:do_enter():Attempting to place ch %s in room NOWHERE", GET_NAME(ch));
	      log(buf);
	      char_to_room(ch, was_in);
	      return;
	    }
	    char_to_room(ch, rnum);
	    if ((GET_OBJ_VAL(obj, 3))==(0)){
	      act("$p flares white as $n emerges from it.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(1)){
	      act("$p flares as $n emerges from it.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(2)){
	      act("$n appears from nowhere!&0\r\n", FALSE, ch, 0, 0,TO_ROOM);
	    }
	    if ((GET_OBJ_VAL(obj, 3))==(3)){
	      act("&0There is a loud POP sound as $n emerges from $p.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    }		  
	    look_at_room(ch, 1);
       if (RIDING(ch)) {
          char_from_room(RIDING(ch));
          char_to_room(RIDING(ch), rnum);
          look_at_room(RIDING(ch), 1);
       }
          } else if (real_room(GET_OBJ_VAL(obj, 0)) == 0) {
	    act("$p flares for a second then dies down.&0\r\n", FALSE, ch, obj, 0,TO_ROOM);
	    send_to_char("&0It flares and then dies down - it must be broken!&0\r\n", ch);
	  }
d1072 88
a1159 2
	}
      }
d1161 8
a1168 23
    
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
	if (EXIT(ch, door)->keyword)
	  if (!str_cmp(EXIT(ch, door)->keyword, buf)) {
	    perform_move(ch, door, 1);
	    return;
	  }
    sprintf(buf2, "There is no %s here.\r\n", buf);
    send_to_char(buf2, ch);
  } else if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS)) {
    send_to_char("You are already indoors.\r\n", ch);
  } else {
    /* try to locate an entrance */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED) &&
	      IS_SET(ROOM_FLAGS(EXIT(ch, door)->to_room), ROOM_INDOORS)) {
	    perform_move(ch, door, 1);
	    return;
	  }
    send_to_char("You can't seem to find anything to enter.\r\n", ch);
d2023 4
@


1.84
log
@You can now use the 'walk' and 'go' commands to travel in different
directions.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.83 2007/09/11 19:41:07 myc Exp myc $
d53 1
d494 8
d520 2
a521 1
      REMOVE_BIT(AFF_FLAGS(motivator), AFF_HIDE);
d2067 4
@


1.83
log
@Being an AQUATIC mobile now counts as being able to travel through water
squares.  Also, can't ride an aquatic mobile onto land now.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.82 2007/09/11 16:34:24 myc Exp myc $
d763 17
a779 4
  if (IS_FIGHTING(ch)) 
  {
    send_to_char("You are too busy fighting to turn and walk away!\r\n", ch);
    return;
a780 1
  perform_move(ch, cmd - 1, 0);
d2057 4
@


1.82
log
@Adding MOB_AQUATIC flag that prevents water mobs from entering non-water
rooms.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.81 2007/09/08 22:03:19 jps Exp myc $
d66 1
a66 1
  if (IS_AFFECTED(ch, AFF_WATERWALK))
d69 3
d396 1
a396 1
       act("$n flops around on the ground, gasping for air!", FALSE, actor, 0, 0, TO_ROOM);
d399 2
a400 1
     if (!IS_WATER(EXIT(actor, dir)->to_room)) {
d405 12
d2045 4
@


1.81
log
@Fix typo, change message in position -> standing messages.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.80 2007/09/03 21:20:46 jps Exp jps $
d388 14
a401 1
  
d2029 3
@


1.80
log
@Moved the code that checks whether a magic wall is blocking movement
to magic.c.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.79 2007/08/31 05:36:19 jps Exp jps $
d1236 2
a1237 2
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
d1256 2
a1257 2
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
d1269 1
a1269 1
      act("$n stops resting, and clambers on $s feet.", TRUE, ch, 0, 0, TO_ROOM);
d1279 2
a1280 2
      act("You stop lying around and stand up.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops lying around, and stands up.", FALSE, ch, 0, 0, TO_ROOM);
d2016 4
@


1.79
log
@Add variable "destination" to mob Entry trigger.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.78 2007/08/20 00:41:16 jps Exp jps $
d216 2
d221 1
a221 1
   struct obj_data *bloodp, *bloodd, *i, *j, *obj;
d386 2
a387 9
   for (obj = world[actor->in_room].contents; obj; obj = obj->next_content) {
      if (GET_OBJ_TYPE(obj) == ITEM_WALL && 
            GET_OBJ_VAL(obj, 0) == dir && 
            GET_LEVEL(actor) < LVL_GOD) {
         act("Oof. You bump into $p.", FALSE, motivator, obj, 0, TO_CHAR);
         act("$n bumps into $p.", FALSE, motivator, obj, 0, TO_ROOM);
         return 0;
      }
   }
d2016 3
@


1.78
log
@Pets won't follow anyone if someone is mounted on them. do_simple_move()
will handle any combination of rider/ridee correctly.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.77 2007/08/14 22:43:07 myc Exp jps $
d455 1
a455 1
   if (!entry_mtrigger(actor))
d2021 4
@


1.77
log
@Adding 'shadow' skill, which lets you follow someone sneakily.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.76 2007/08/05 20:21:51 myc Exp myc $
a213 3
/*Buru coded blood trail, and this fucntion was getting sludgy,
  with all the new stuff, I redid most making it so can take into
  account gods and sense life with sneak amd outdoor sneak*/
d216 19
a234 9
  int same_room = 0, riding = 0, ridden_by = 0, flying = 0, boat = 0, levitating = 0;
  int was_in, need_movement;
  int vnum, chance;
  struct obj_data *bloodp, *bloodd, *i, *j, *obj;
  struct extra_descr_data *new_descr;
  char mmsg[MAX_STRING_LENGTH];
  char tmp[MAX_STRING_LENGTH];
  struct char_data *people;

d240 2
a241 2
  if (need_specials_check && special(ch, dir + 1, ""))
    return 0;
d243 16
a258 8
  /*dont allow people in God rooms*/
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    if (ch->master) {
      if (GET_LEVEL(ch->master) < LVL_IMMORT) {
	if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
	  send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
	  return 0;
	}
d260 4
a263 6
	if ((ch->master->in_room) != (EXIT(ch, dir)->to_room)) {
	  if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
	    send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
	    return 0;
	  }
	}
d265 1
a265 23
    } else {
      if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM)) {
	send_to_char("&0&8A mysterious powerful force pushes you back.&0\r\n", ch);
	    return 0;
      }
    }
  }  
  /* Mounted?*/
  if (RIDING(ch)) {
    riding = 1;
    if (has_boat(RIDING(ch))) {
      boat = 1;
    }
  }   
  if (RIDDEN_BY(ch)) {
    ridden_by = 1;
    if(has_boat(RIDDEN_BY(ch))) {
      boat = 1;
    }
  }
  if (has_boat(ch)) {
    boat = 1;
  }
d267 1
a267 1
  /*  This allows mounts/mountee's to fly if either are flying */
d269 21
a289 26
  if (GET_POS(ch) == POS_FLYING)  flying = 1;
  if (riding && GET_POS(RIDING(ch)) == POS_FLYING)  flying = 1;
  if (ridden_by && GET_POS(RIDDEN_BY(ch)) == POS_FLYING)  flying = 1;
  /* immorts+ should be free of mortal influences such as gravity */
  if (GET_LEVEL(ch) >= LVL_IMMORT) flying = 1;

  if (!flying && GET_POS(ch) >= POS_STANDING) {
     if (IS_AFFECTED2(ch, AFF2_LEVITATE)) levitating = 1;
     if (riding && IS_AFFECTED2(RIDING(ch), AFF2_LEVITATE)) levitating = 1;
     if (ridden_by && IS_AFFECTED2(RIDDEN_BY(ch), AFF2_LEVITATE)) levitating = 1;
  }

  /* if they're mounted, are they in the same room w/ their mount(ee)?*/
  if (riding && RIDING(ch)->in_room == ch->in_room)
    same_room = 1;
  else if (ridden_by && RIDDEN_BY(ch)->in_room == ch->in_room)
    same_room = 1;
  
  /* move points needed is avg. move loss for src and destination sect type */
  if(flying)
    need_movement = 1;
  else if (boat && SECT(ch->in_room) == SECT_WATER_SWIM)
    need_movement = 2;
  else 
    need_movement = (movement_loss[SECT(EXIT(ch, dir)->to_room)]
		     + movement_loss[SECT(ch->in_room)]) / 2;
d291 2
a292 2
  if (levitating && need_movement > 2)
     need_movement = 2;
d294 33
a326 9
  if (riding) {
    if (GET_MOVE(RIDING(ch)) < need_movement) {
      send_to_char("Your mount is too exhausted.\r\n", ch);
      return 0;
    }
  } else {
    if (GET_MOVE(ch) < need_movement && !IS_NPC(ch)) {
      if (need_specials_check && ch->master)
	send_to_char("You are too exhausted to follow.\r\n", ch);
d328 7
a334 1
	send_to_char("You are too exhausted.\r\n", ch);
d336 11
a346 2
    }
  }
d348 12
a359 14
  /* Tamed?*/
  if (ridden_by && same_room && AFF_FLAGGED(ch, AFF_TAMED)) {
    send_to_char("You've been tamed.  Now act it!\r\n", ch);
    return 0;
  } else if (ridden_by && same_room && IS_FIGHTING(RIDDEN_BY(ch))) {

    if (movement_bucked(RIDDEN_BY(ch), ch)) {
      act("$N rears backwards, throwing you to the ground.", FALSE, RIDDEN_BY(ch), 0, ch, TO_CHAR);
      act("You rear backwards, throwing $n to the ground.", FALSE, RIDDEN_BY(ch), 0, ch, TO_VICT);
      act("$N rears backwards, throwing $n to the ground.", FALSE, RIDDEN_BY(ch), 0, ch, TO_NOTVICT);
      improve_skill(RIDDEN_BY(ch), SKILL_RIDING);
      damage(RIDDEN_BY(ch), RIDDEN_BY(ch), dice(1,6), -1);
      dismount_char(RIDDEN_BY(ch));
    }
d361 2
a362 3
    /* couldn't buck the rider so, don't move */
    return 0;
  }
d364 18
a381 11
  /* if load 90% and over, bite the dust. Nechtrous */
  /* addendum: if not an immortal+ (DEMOLITUM) */
  if((!riding) && (!flying) && 
     (CURRENT_LOAD(ch) >= 9) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    act("You stagger about, then fall under your heavy load.",FALSE,ch,0,0,TO_CHAR);
    act("$n staggers about, then collapses under $s heavy load.",TRUE,ch,0,0,TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    GET_POS1(ch) = POS1_RESTING;
    update_pos(ch);
    return 0;
  } 
d383 10
a392 7
  /* charmed?*/
  /* modified so animated critters CAN even though they're charmed - 321 */
  if ((IS_AFFECTED(ch, AFF_CHARM) && !MOB_FLAGGED(ch, MOB_ANIMATED)) && 
      ch->master && ch->in_room == ch->master->in_room) {
    send_to_char("The thought of leaving your master makes you weep.\r\n", ch);
    return 0;
  }
d394 12
a405 7
  /* check for a wall in room */
  for(obj = world[ch->in_room].contents;obj;obj = obj->next_content) {
    if(GET_OBJ_TYPE(obj) == ITEM_WALL && 
       GET_OBJ_VAL(obj,0) == dir && 
       GET_LEVEL(ch) < LVL_GOD){
      act("Oof. You bump into $p.",FALSE,ch,obj,0,TO_CHAR);
      act("$n bumps into $p.",FALSE,ch,obj,0,TO_ROOM);
d407 1
a407 2
    }
  }
d409 24
a432 8
  /* we need either a boat or fly spell in water rooms */
  if ((SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_WATER_NOSWIM)) {
    if (!boat && !flying) {
      send_to_char("You need a boat or wings to go there.\r\n", ch);
      return 0;
    }
  }
d434 1
a434 13
  if(SECT(EXIT(ch,dir)->to_room) == SECT_OCEAN && (IS_NPC(ch) || GET_LEVEL(ch) < LVL_IMMORT)) {
    send_to_char("The rough currents would be hazardous to your health.\r\n",ch);
    return 0;
  }
  
  if ((SECT(ch->in_room) == SECT_FLYING) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_FLYING)) {
    
    if (!flying && dir == UP) {
      send_to_char("&7Try flapping your wings.&0\r\n", ch);
      return 0;
    }
  }
d436 6
a441 1
  /* Riding check for each move to see if the rider gets tossed 6/4/2000 RSD */
d443 10
a452 11
  if (riding) {
    improve_skill(ch, SKILL_RIDING);
    if (movement_bucked(ch, RIDING(ch))) {
      act("$N rears backwards, throwing you to the ground.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
      act("You rear backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_VICT);
      act("$N rears backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_NOTVICT);
      dismount_char(ch);
      damage(ch, ch, dice(1,6), -1);
      return 0;
    }
  }
d454 2
a455 6
  vnum = world[EXIT(ch, dir)->to_room].number;
  
  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_ATRIUM)) {
    /*if (!House_can_enter(ch, world[EXIT(ch, dir)->to_room].number)) {*/
    if (!House_can_enter(ch, vnum)) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
d457 1
a457 10
    }
  }
  
  if ((riding || ridden_by) && IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_TUNNEL)) {
    send_to_char("There isn't enough room there, while mounted.\r\n", ch);
    return 0;
  } else {
    if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_TUNNEL) &&
	num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) > 1) {
      send_to_char("There isn't enough room there for more than one person!\r\n", ch);
a458 8
    }
  }
  
  /* see if an entry trigger disallows the move */
  if (!entry_mtrigger(ch))
    return 0;
  if (!enter_wtrigger(&world[EXIT(ch, dir)->to_room], ch, dir))
    return 0;
d461 3
a463 2
   if (OUTSIDE(ch) && (zone_table[world[ch->in_room].zone]).wind_speed >= WIND_GALE) {
      if ((zone_table[world[ch->in_room].zone]).wind_dir == (dir + 2) % 4) {
d465 13
a477 1
         send_to_char("The wind beats hard upon your body as you forge ahead.\r\n", ch);
d479 32
a510 9
         /* nifty affect for the little guys!:) */
         if ( (GET_SIZE(ch)  <= SIZE_SMALL) && (GET_LEVEL(ch) < LVL_IMMORT) ) {
	      /* uh... no, removed by RLS 
	       * if (number(0,9) > 7)  20% chance 
	       * {
	       *  GET_POS(ch) = POS_SITTING;
	       *  send_to_char("The wind is so powerful that your small body is knocked backward and you fall to the ground!\r\n", ch);
	       *  act("$n is knocked backward by the force of the wind!", FALSE, ch, 0, 0, TO_ROOM);
		}*/
d514 3
d518 13
a530 55
  if (GET_LEVEL(ch) < LVL_IMMORT && !IS_NPC(ch) && !(riding || ridden_by)) {
    alter_move(ch, need_movement);
  }
  else if (riding)
    /*GET_MOVE(RIDING(ch)) -= need_movement;*/
    alter_move(RIDING(ch), need_movement);
  else if (ridden_by)
    /*GET_MOVE(RIDDEN_BY(ch)) -= need_movement;*/
    alter_move(RIDDEN_BY(ch), need_movement);
  
  if (riding)
  {
    sprintf(buf2, "You ride %s on %s.\r\n", dirs[dir], PERS(RIDING(ch), ch));
    act(buf2, TRUE, ch, 0, 0, TO_CHAR);
    sprintf(mmsg, "$n rides %s on", dirs[dir]);
  } 
  else 
  {
    sprintf(mmsg, "$n %s %s.", movewords(ch, dir, ch->in_room, TRUE), dirs[dir]);
  }
  
  /* skill check for ability to sneak and remain hidden while sneaking */
  chance = number(1,101);
  /* scaled chance to a 101 point scale and added in dex apply for sneak, as well
  a bonus for already sneaking... since you were successful the first time.*/
  if ((chance > (GET_SKILL(ch, SKILL_SNEAK) + dex_app_skill[GET_DEX(ch)].sneak) + 15)  
  || ((GET_SKILL(ch, SKILL_SNEAK) == 0) && chance < 5))
  {
    /*   Fixed this for pergy so people don't get 18 bazillion "Sneak" 
	 affects (without the bit being set  - 9-22-02 jjl */
    /*    REMOVE_BIT(AFF_FLAGS(ch), AFF_SNEAK); */
    REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
    affect_from_char(ch, SKILL_SNEAK); 
  }
 
  LOOP_THRU_PEOPLE(people, ch) {
    if ((ch == people) || !AWAKE(people))
      continue;
    if (people == RIDING(ch)) {
      sprintf(tmp, "%s you.", mmsg);
      act(tmp, FALSE, ch, 0, people, TO_VICT);
      continue;
    }
    if(riding){
      sprintf(tmp, "%s %s.", mmsg, CAN_SEE(people, RIDING(ch)) ?
	      GET_NAME(RIDING(ch)) : "something");
      act(tmp, FALSE, ch, 0, people, TO_VICT);
    }else if (!IS_AFFECTED(ch, AFF_SNEAK) && !OUTDOOR_SNEAK(ch) &&
	      CAN_SEE(people, ch)) {
      act(mmsg, FALSE, ch, 0, people, TO_VICT);
    } else {
      if ((GET_LEVEL(people) >= LVL_IMMORT && GET_LEVEL(people) >= GET_LEVEL(ch)) || 
	          (GET_LEVEL(ch) < LVL_IMMORT && (IS_AFFECTED(people, AFF_SENSE_LIFE) ||
	          IS_AFFECTED3(people, AFF3_AWARE)) && statsave(people, APPLY_INT, -4))) {
	     act(mmsg, FALSE, ch, 0, people, TO_VICT);
a531 3
    }
  }
  was_in = ch->in_room;
d533 11
a543 9
  if (GET_HIT(ch) < (((int)(0.3 * GET_MAX_HIT(ch))))) {
    for (i = world[ch->in_room].contents; i; i = j) {
      /* added next line so list doesn't break after a free 
	 --gurlaek 9/7/1999 */
      j = i->next_content;
      if(GET_OBJ_VNUM(i)==34) {
	extract_obj(i);
      } else if(GET_OBJ_VNUM(i)==35){
	extract_obj(i);
d545 15
a559 2
    }
  }
d561 9
a569 29
  if (GET_HIT(ch)<((int)(0.1*GET_MAX_HIT(ch))) && pk_allowed){
    bloodp = read_object(BLOOD_POOL_OBJ, VIRTUAL);
    GET_OBJ_VAL(bloodp, 0) = ch->in_room;
    GET_OBJ_TIMER(bloodp) = 3;
    CREATE(new_descr, struct extra_descr_data, 1);
    new_descr->keyword = str_dup("blood pool");
    sprintf(buf, "&0&1Quite a large pool of blood.&0");
    new_descr->description = str_dup(buf);
    new_descr->next = bloodp->ex_description;
    bloodp->ex_description = new_descr;
    obj_to_room(bloodp, ch->in_room);}
  if (GET_HIT(ch)>=((int)(0.1*GET_MAX_HIT(ch))) && pk_allowed){
    if (GET_HIT(ch)<((int)(0.3*GET_MAX_HIT(ch)))){
      bloodd = read_object(BLOOD_DROP_OBJ, VIRTUAL);
      GET_OBJ_VAL(bloodd, 0) = ch->in_room;
      GET_OBJ_TIMER(bloodd) = 2;
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = str_dup("blood drops");
      sprintf(buf, "&0&1Several drops of blood cover the ground here.&0");
      new_descr->description = str_dup(buf);
      new_descr->next = bloodd->ex_description;
      bloodd->ex_description = new_descr;
      obj_to_room(bloodd, ch->in_room);}}

  /* If the room is affected by a circle of fire, damage the person */
  /* but not if they have negate heat -myc 4 Feb 2007 */
  /* if they die, don't move them -myc 2 Feb 2007 */
  if (ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE) && !AFF2_FLAGGED(ch, AFF2_NEGATE_HEAT)) {
    mag_damage(GET_LEVEL(ch) + number(1, 10), ch, ch, 
d571 12
a582 3
    if (GET_POS(ch) == POS_DEAD)
      return 0;
  }
a583 16
  char_from_room(ch);
  char_to_room(ch, world[was_in].dir_option[dir]->to_room);
  if (riding && same_room && RIDING(ch)->in_room != ch->in_room) {
    char_from_room(RIDING(ch));
    char_to_room(RIDING(ch), ch->in_room);   
    look_at_room(RIDING(ch), 1);
    /*lookmark*/
  }else if (ridden_by && same_room && RIDDEN_BY(ch)->in_room != ch->in_room)
    {
      char_from_room(RIDDEN_BY(ch));
      char_to_room(RIDDEN_BY(ch), ch->in_room);
      look_at_room(RIDDEN_BY(ch), ch->in_room);
    }
  
  {
    if (riding && same_room) {
d585 68
a652 40
	      (dir < UP  ? "the " : ""),
	      (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
    } else if (!riding || (riding && !same_room))
      sprintf(buf, "$n %s from %s%s.", movewords(ch, dir, ch->in_room, FALSE),
	      (dir < UP  ? "the " : ""),
	      (dir == UP ? "below": dir == DOWN ? "above" : dirs[rev_dir[dir]]));
    LOOP_THRU_PEOPLE(people, ch) {
      if ((ch == people) || !AWAKE(people))
	continue;
      if(people == RIDING(ch))
	continue;
      if (RIDING(ch)) {
	sprintf(buf2, "%s%s.", tmp, 
		CAN_SEE(people, RIDING(ch)) ? GET_NAME(RIDING(ch)) : "something");
	act(buf2, FALSE, ch, 0, people, TO_VICT);
	if (is_aggr_to(people, ch))    /*NEW FASTER AGGRO! */
	  /*if(number(0, 5))*/
	  hit(people, ch, TYPE_UNDEFINED);
	else if (is_aggr_to(people, RIDING(ch)))
	  /*if(number(0, 5))*/
	  hit(people, RIDING(ch), TYPE_UNDEFINED);
      }else if (!IS_AFFECTED(ch, AFF_SNEAK) && !OUTDOOR_SNEAK(ch) &&
		CAN_SEE(people, ch)) {
	act(buf, FALSE, ch, 0, people, TO_VICT);
	if (is_aggr_to(people, ch))
	  /*if(number(0, 5))*/
	  hit(people, ch, TYPE_UNDEFINED);
      }else {
      if ((GET_LEVEL(people) >= LVL_IMMORT && GET_LEVEL(people) >= GET_LEVEL(ch)) || 
	    (GET_LEVEL(ch) < LVL_IMMORT &&
        (IS_AFFECTED(people, AFF_SENSE_LIFE) || IS_AFFECTED3(people,AFF3_AWARE)) &&
	     statsave(people, APPLY_INT, -4))) {
	  act(buf, FALSE, ch, 0, people, TO_VICT);
	  if (is_aggr_to(people, ch))    /*NEW FASTER AGGRO! */
	    hit(people, ch, TYPE_UNDEFINED);
	  /*MARK56*/
	}else {
	  if (is_aggr_to(people, ch))
	    hit(people, ch, TYPE_UNDEFINED);
	}
a653 10
    }
  }	
  
  /* If the room is affected by a circle of fire, damage the person */
  /* but not if they have negate heat -myc 4 Feb 2007 */
  /* if they die, don't do anything else */
  if (ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE) && !AFF2_FLAGGED(ch, AFF2_NEGATE_HEAT)) {
    mag_damage(GET_LEVEL(ch) + number(1, 5), ch, ch, 
               SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
    if (GET_POS(ch) == POS_DEAD)
d655 1
a655 1
  }
d657 5
a661 2
  if (ch->desc != NULL)
    look_at_room(ch, 0);
d663 2
a664 29
  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_DEATH)) {
    if (GET_LEVEL(ch) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }
    
    if (riding && GET_LEVEL(RIDING(ch)) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }
    
    if (ridden_by && GET_LEVEL(RIDDEN_BY(ch)) < LVL_IMMORT) {
      log_death_trap(ch);
      death_cry(ch);
      extract_char(ch);
    }
    return 0;
  }

  if (!greet_mtrigger(ch, dir)) {
    char_from_room(ch);
    char_to_room(ch, was_in);
    look_at_room(ch, 0);
  }
  
  justice_trigger(ch);
  return 1;
d2021 3
@


1.76
log
@Moved do_simple_move's comments closer to the function.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.75 2007/08/05 01:50:16 myc Exp myc $
d1713 5
d1753 4
d1758 17
d2022 3
@


1.75
log
@Follow, guard, and consent all follow similar usage patterns now.
<action> off/self/me stops whatever it is, <action> target starts
on the target, and <action> shows who is currently targeted.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.74 2007/08/04 22:20:38 jps Exp myc $
a83 12
/* do_simple_move assumes
 *    1. That there is no master and no followers.
 *    2. That the direction exists.
 *
 *   Returns :
 *   1 : If succes.
 *   0 : If fail
 */

#define BLOOD_DROP_OBJ     34   /* the vnum of the blood object */
#define BLOOD_POOL_OBJ     35   /* the vnum of the blood object */

d202 12
d1996 5
@


1.74
log
@Different buck messages whether you're in a splashy room or not.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.73 2007/08/04 02:13:27 myc Exp jps $
d1714 1
a1714 1
  one_argument(argument, buf);
d1716 5
a1720 7
  if (*buf) {
    if (!(leader = get_char_room_vis(ch, buf))) {
      send_to_char(NOPERSON, ch);
      return;
    }
  } else {
    send_to_char("Whom do you wish to follow?\r\n", ch);
d1723 5
a1727 3
  
  if (ch->master == leader) {
    act("You are already following $M.", FALSE, ch, 0, leader, TO_CHAR);
a1729 5
  
  if (GET_LEVEL(ch) < LVL_GOD && PRF_FLAGGED(leader, PRF_NOFOLLOW) && leader != ch) {
    send_to_char("That person would rather not have followers right now.\r\n", ch);
    return; 
  }
d1731 2
a1732 1
  if (IS_AFFECTED(ch, AFF_CHARM) && (ch->master)) {
d1734 13
a1746 6
  } else {			/* Not Charmed follow person */
    if (leader == ch) {
      if (!ch->master) {
	send_to_char("You are already following yourself.\r\n", ch);
	return;
      }
d1748 1
a1748 5
    } else {
      if (ch->master)
	stop_follower(ch, 0);
      add_follower(ch, leader);
    }
d1996 3
@


1.73
log
@Circle of fire damage should occur before you enter the room.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.72 2007/08/04 02:10:57 myc Exp myc $
d1753 39
d1848 1
a1848 5
      act("$N suddenly bucks upwards, throwing you violently to the ground!",
            FALSE, ch, 0, vict, TO_CHAR);
      act("$n is thrown to the ground as $N violently bucks!", TRUE, ch, 0, vict, TO_NOTVICT);
      act("You buck violently and throw $n to the ground.", FALSE, ch, 0, vict, TO_VICT);
      dismount_char(ch);
a1849 1
      damage(ch, ch, dice(1,3), -1);
d1866 1
a1866 1
  
d1887 1
a1887 16
  act("You quickly buck, throwing $N to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_CHAR);
  act("$n quickly bucks, throwing you to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_VICT);
  act("$n quickly bucks, throwing $N to the ground.", FALSE, ch, 0, RIDDEN_BY(ch), TO_NOTVICT);
  GET_POS(RIDDEN_BY(ch)) = POS_SITTING;

  
  if (number(0, 4)) {
    send_to_char("You hit the ground hard!\r\n", ch);
    damage(RIDDEN_BY(ch), RIDDEN_BY(ch), dice(10,4), -1);
  }

  dismount_char(ch);  

  /* you might want to call set_fighting() or some non-sense here if you
     / want the mount to attack the unseated rider or vice-versa.*/
  /*This is not my code here check out credits */
d1997 3
@


1.72
log
@You now take damage from circle of fire when entering and exiting a room.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.71 2007/08/03 22:00:11 myc Exp myc $
a623 3
  if (ch->desc != NULL)
    look_at_room(ch, 0);

d634 3
d1978 3
@


1.71
log
@Fixed several \r\n typos in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.70 2007/08/01 02:10:39 jps Exp myc $
d556 1
a556 1
  if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE) && !IS_AFFECTED2(ch, AFF2_NEGATE_HEAT)) {
d559 1
a559 1
    if(ch == NULL|| GET_POS(ch) == POS_DEAD)
d626 11
a636 7
  /* We will not let lame builders attempt to use DeathTraps to make an
     area challenging 
   */
  /*if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_DEATH) && GET_LEVEL(ch) < LVL_IMMORT) {
    log_death_trap(ch);
    death_cry(ch);
    extract_char(ch);*/
d657 1
a657 1
  
d1978 3
@


1.70
log
@Make mounts more difficult to handle.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.69 2007/07/14 04:17:35 jps Exp jps $
d1728 1
a1728 1
    send_to_char("That person would rather not have followers right now.", ch);
d1974 3
@


1.69
log
@Updated call to stop_follower(), which cares whether this is being
done due to a violent action or not.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.68 2007/07/14 02:16:22 jps Exp jps $
d107 1
a107 1
   return GET_SKILL(ch, SKILL_MOUNT) * (MAX_MOUNT_LEVEL - 1) / 100 + 1;
d114 1
a114 1
   return GET_SKILL(ch, SKILL_RIDING) * (MAX_MOUNT_LEVEL - 1) / 100 + 1;
d135 1
a135 1
   return GET_SKILL(ch, SKILL_TAME) * (MAX_MOUNT_LEVEL - 1) / 100 + 1;
d160 1
a160 1
   if (diff >= MOUNT_LEVEL_FUDGE)
d177 1
a177 1
   if (diff >= MOUNT_LEVEL_FUDGE)
d180 1
a180 1
   return number(0, 999) < 
d194 1
a194 1
   if (diff >= MOUNT_LEVEL_FUDGE)
d197 1
a197 1
   return number(0, 999) < 
d1974 4
@


1.68
log
@Major revamp of mounts. The character's skill in mount/ride/tame
is pitted against the victim's level. Thus, a player with poor
skill could use a low-level mount, which would, of course, not
be as good as a higher-level mount.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.67 2007/07/14 01:42:58 jps Exp jps $
d1707 1
a1707 1
  void stop_follower(struct char_data *ch);
d1740 1
a1740 1
      stop_follower(ch);
d1743 1
a1743 1
	stop_follower(ch);
d1974 6
@


1.67
log
@Doors can now properly lock only from one side, if builders have
made them that way.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.66 2007/05/28 23:51:35 jps Exp jps $
d18 1
d96 118
a226 1
  int ride_bonus = 0;
d329 1
a329 4
    /* added to stop crashes when untamed mounts left a fight while   */
    /* their rider was fighting --Fingon                              */                   
    /* No longer tamed but the rider is fighting, try to buck him off */
    if (GET_SKILL(RIDDEN_BY(ch), SKILL_RIDING) < number(1, 101)-number(-4,need_movement)) {
d400 1
a400 13
    if (GET_CLASS(ch) == CLASS_PALADIN || GET_CLASS(ch) == CLASS_ANTI_PALADIN) {
      ride_bonus = 30;
    }
    if (GET_CLASS(ch) == CLASS_DRUID || GET_CLASS(ch) == CLASS_RANGER) {
      ride_bonus = 15;
    }
    if (AFF_FLAGGED(RIDING(ch), AFF_TAMED) || IS_AFFECTED(RIDING(ch), AFF_TAMED)) {
      ride_bonus += 30;
    }
    if (AFF_FLAGGED(RIDING(ch), AFF_CHARM) || IS_AFFECTED(RIDING(ch), AFF_CHARM)) {
      ride_bonus += 60;
    }
    if ((GET_SKILL(ch, SKILL_RIDING) + ride_bonus) < number(1, 101) - number(-4,need_movement) && (GET_DEX(ch) <= number(1, 101))) {
d1750 7
a1756 3
  char arg[MAX_INPUT_LENGTH];
  struct char_data *vict;
  int mount_bonus = 0;
d1758 1
a1758 31
  if(IS_FIGHTING(ch)) {
    send_to_char("You are too busy fighting to try that right now.\n\r",ch);
    return;
  }
  one_argument(argument, arg);
  
  if (!arg || !*arg) {
    send_to_char("Mount who?\r\n", ch);
    return;
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("There is no-one by that name here.\r\n", ch);
    return;
  } else if (!IS_NPC(vict) && GET_LEVEL(ch) < LVL_IMMORT) {
    send_to_char("Ehh... no.\r\n", ch);
    return;
  } else if (RIDING(ch) || RIDDEN_BY(ch)) {
    send_to_char("You are already mounted.\r\n", ch);
    return;
  } else if (RIDING(vict) || RIDDEN_BY(vict)) {
    send_to_char("It is already mounted.\r\n", ch);
    return;
  } else if (GET_LEVEL(ch) < LVL_IMMORT && IS_NPC(vict) && !MOB_FLAGGED(vict, MOB_MOUNTABLE)) {
    send_to_char("You can't mount that!\r\n", ch);
    return;
  } else if (!GET_SKILL(ch, SKILL_MOUNT)) {
    send_to_char("First you need to learn *how* to mount.\r\n", ch);
    return;
  } else if (ch == vict) {
    send_to_char("Not likely.\r\n", ch);
    return;
  }
d1760 25
a1784 12
  if (GET_CLASS(ch) == CLASS_PALADIN || GET_CLASS(ch) == CLASS_ANTI_PALADIN) {
    mount_bonus = 30;
  }
  if (GET_CLASS(ch) == CLASS_DRUID || GET_CLASS(ch) == CLASS_RANGER) {
    mount_bonus = 15;
  }
  if (AFF_FLAGGED(vict, AFF_TAMED) || IS_AFFECTED(vict, AFF_TAMED)) {
    mount_bonus += 30;
  }
  if (AFF_FLAGGED(vict, AFF_CHARM) || IS_AFFECTED(vict, AFF_CHARM)) {
    mount_bonus += 90;
  }
d1786 1
d1788 9
a1796 9
  if ( (GET_SKILL(ch, SKILL_MOUNT) <=  ( number(1, 101) + GET_LEVEL(vict) ) / 2) 
       && GET_DEX(ch) <= number(1, 101)) {
    act("You try to mount $N, but slip and fall off.", FALSE, ch, 0, vict, TO_CHAR);
    act("$n tries to mount you, but slips and falls off.", FALSE, ch, 0, vict, TO_VICT);
    act("$n tries to mount $N, but slips and falls off.", TRUE, ch, 0, vict, TO_NOTVICT);
    damage(ch, ch, dice(1, 2), -1);
    improve_skill(ch, SKILL_MOUNT);
    return;
  }
d1798 15
a1812 14
  act("You mount $N.", FALSE, ch, 0, vict, TO_CHAR);
  act("$n mounts you.", FALSE, ch, 0, vict, TO_VICT);
  act("$n mounts $N.", TRUE, ch, 0, vict, TO_NOTVICT);
  mount_char(ch, vict);
  improve_skill(ch, SKILL_MOUNT);

  if (IS_NPC(vict) && !AFF_FLAGGED(vict, AFF_TAMED) && GET_SKILL(ch, SKILL_MOUNT) <= number(1, 101)) {
    act("$N suddenly bucks upwards, throwing you violently to the ground!",
	FALSE, ch, 0, vict, TO_CHAR);
    act("$n is thrown to the ground as $N violently bucks!", TRUE, ch, 0, vict, TO_NOTVICT);
    act("You buck violently and throw $n to the ground.", FALSE, ch, 0, vict, TO_VICT);
    dismount_char(ch);
    damage(ch, ch, dice(1,3), -1);
  }  
d1872 2
a1873 1
  int tame_bonus = 0;
d1901 24
a1924 1
  tame_bonus = (int)(GET_CHA(ch) / 3);
a1925 12
  if (GET_CLASS(ch) == CLASS_DRUID) {
    tame_bonus += 30;
  }
  if (GET_CLASS(ch) == CLASS_RANGER) {
    tame_bonus += 15;
  }
  
  if (GET_SKILL(ch, SKILL_TAME) + tame_bonus <= number(1, 121)) {
    act("You failed to tame $M.", FALSE, ch, 0, vict, TO_CHAR);
    improve_skill(ch, SKILL_TAME);
    return;
  }
d1928 8
d1937 1
a1937 1
  af.duration = (tame_bonus + 10);
a1940 1
  /* fixed by fingon */
d1974 4
@


1.66
log
@Make open/close interact first with equipped items.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.65 2007/04/25 06:41:27 jps Exp jps $
d764 7
a770 1
    if (back)
d776 1
a776 1
    if (back)
d1863 3
@


1.65
log
@Fixed bug where you buy a mount, then mount it, and suddenly the other
folks following you wouldn't be any more.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.64 2007/04/19 00:53:54 jps Exp jps $
d857 1
a857 1
  if (!generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
d1857 4
@


1.64
log
@Create macros for stopping spellcasting.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.63 2007/02/08 01:30:00 myc Exp jps $
d608 15
a622 21
    for (k = ch->followers; k; k = next) 
    {
      next = k->next;

      /* Added this to prevent loop room lag/crash bug... RLS - 04/11/28 */
      if (k->follower->in_room == to_room)
      { return 1; }

      if ( ( k->follower->in_room == was_in ) &&
	   ( GET_POS(k->follower) >= POS_STANDING ) &&
	   ( !IS_FIGHTING(k->follower) ) &&
	   ( !CASTING(k->follower) ) &&
	   k->can_see_master ) 
      {
	act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
	perform_move(k->follower, dir, 1);
      }
    }    
    return 1;
  }
  return 0;
d1857 3
@


1.63
log
@If circle of fire kills someone, hopefully the game won't crash now.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.62 2006/11/21 20:15:01 jps Exp myc $
d619 1
a619 1
	   ( !PLR_FLAGGED(k->follower, PLR_CASTING) ) &&
d1863 3
@


1.62
log
@Use correct pronouns in "tame" feedback.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.61 2006/11/20 19:52:04 jps Exp jps $
d449 11
a459 3
  
  if(ROOM_AFFECTED(ch->in_room, RAFF_CIRCLE_FIRE))
    mag_damage(GET_LEVEL(ch), ch, ch, SPELL_CIRCLE_OF_FIRE, SAVING_SPELL);
d1863 3
@


1.61
log
@Movement cost with levitate is max 2
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.60 2006/11/18 07:17:16 jps Exp jps $
d1787 1
a1787 1
    send_to_char("You can't do that to them.\r\n", ch);
d1790 1
a1790 1
    send_to_char("It seems quite tame already.\r\n", ch);
d1810 1
a1810 1
    send_to_char("You fail to tame it.\r\n", ch);
d1855 3
@


1.60
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.59 2006/11/14 23:24:39 jps Exp jps $
d100 1
a100 1
  int same_room = 0, riding = 0, ridden_by = 0, flying = 0, boat = 0;
d166 6
d187 3
d1855 3
@


1.59
log
@Stop the gale winds from blowing hard on you while indoors.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.58 2006/11/14 22:38:04 jps Exp jps $
d561 4
a564 1
      sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
d1846 3
@


1.58
log
@Fix bug of lower-level imms seeing "someone" move about when a higher
level invis imm moves.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.57 2006/11/13 15:54:22 jps Exp jps $
d325 8
a332 11
  /* alter the need_movement depending on wind direction and speed */
  if ((zone_table[world[ch->in_room].zone]).wind_speed >= WIND_GALE)
    {
      if ((zone_table[world[ch->in_room].zone]).wind_dir == (dir + 2) % 4)
	{  
	  need_movement *= 2;
	  send_to_char("The wind beats hard upon your body as you forge ahead.\r\n", ch);

	  /* nifty affect for the little guys!:) */
	  if ( (GET_SIZE(ch)  <= SIZE_SMALL) && (GET_LEVEL(ch) < LVL_IMMORT) ) 
	    {
d340 3
a342 3
	    }
	}    
    }
d1843 4
@


1.57
log
@Fix widespread misuse of the hide_invisible parameter to act().
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.56 2006/11/13 14:57:54 jps Exp jps $
d398 1
a398 1
      if (GET_LEVEL(people) >= LVL_IMMORT || 
d491 1
a491 1
	if (GET_LEVEL(people) >= LVL_IMMORT ||
d1846 3
@


1.56
log
@Fix typos when mortal tried to enter a godroom.
Don't allow mortals to see that an imm is following, even with sense life.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.55 2006/11/13 13:32:25 jps Exp jps $
d387 1
a387 1
      act(tmp, TRUE, ch, 0, people, TO_VICT);
d393 1
a393 1
      act(tmp, TRUE, ch, 0, people, TO_VICT);
d396 1
a396 1
      act(mmsg, TRUE, ch, 0, people, TO_VICT);
d401 1
a401 1
	     act(mmsg, TRUE, ch, 0, people, TO_VICT);
d477 1
a477 1
	act(buf2, TRUE, ch, 0, people, TO_VICT);
d486 1
a486 1
	act(buf, TRUE, ch, 0, people, TO_VICT);
d495 1
a495 1
	  act(buf, TRUE, ch, 0, people, TO_VICT);
d1846 4
@


1.55
log
@Prevent characters from mounting themselves.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.54 2006/11/12 02:31:01 jps Exp jps $
d123 1
a123 1
	  send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
d129 1
a129 1
	    send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
d136 1
a136 1
	send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
d399 4
a402 3
	  ((IS_AFFECTED(people,AFF_SENSE_LIFE) ||
	    IS_AFFECTED3(people,AFF3_AWARE)) && statsave(people, APPLY_INT, -4)))
	act(mmsg, TRUE, ch, 0, people, TO_VICT);
d492 2
a493 1
	    ((IS_AFFECTED(people, AFF_SENSE_LIFE) || IS_AFFECTED3(people,AFF3_AWARE)) &&
d1846 3
@


1.54
log
@Mount goes with you through portals.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.53 2006/11/08 08:51:58 jps Exp jps $
d1659 3
d1663 1
d1844 3
@


1.53
log
@Fix missing period in message about trying to fly while fighting.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.52 2006/11/08 08:36:54 jps Exp jps $
d1006 5
d1840 3
@


1.52
log
@Fixed a lot of lay/lie typos.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.51 2006/11/08 08:16:14 jps Exp jps $
d1081 1
a1081 1
    send_to_char("You are too busy fighting to worry about flying\n\r",ch);
d1835 3
@


1.51
log
@Fix missing period at the end of arrival message, when riding.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.50 2006/11/07 16:53:29 jps Exp jps $
d1306 1
a1306 1
    send_to_char("You dream of laying down.\r\n", ch);
d1314 2
a1315 2
    act("You stop sitting around and lay down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n stops sitting around and lays down.", TRUE, ch, 0, 0, TO_ROOM);
d1332 1
a1332 1
      send_to_char("You are already laying down.\r\n", ch);
d1337 1
a1337 1
	send_to_char("You can't even twitch, much less lay down!\r\n", ch);
d1341 1
a1341 1
      act("$n eases off $s knees and lays down.", TRUE, ch, 0, 0, TO_ROOM);
d1348 2
a1349 2
      act("You stop sitting around and lay down.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n stops sitting around and lays down.", TRUE, ch, 0, 0, TO_ROOM);
d1835 3
@


1.50
log
@A boat will reduce movement cost in WATER_NOSWIM from 4 to 2.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.49 2006/07/20 07:42:36 cjd Exp jps $
d474 1
a474 1
	sprintf(buf2, "%s%s", tmp, 
d1835 3
@


1.49
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.48 2005/02/12 00:12:52 rls Exp $
d175 2
d1835 3
@


1.48
log
@Commented out that damned annoying wind knockdown effect.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.47 2004/11/29 01:56:31 rls Exp $
d620 1
a620 1
    send_to_char("You are to busy fighting to turn and walk away!\r\n", ch);
d1833 3
@


1.47
log
@Fixed a bug where you could have two mobs follow each other though
a loop room and lag/crash the mud.  See... Druids ARE so broken!
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.46 2004/11/28 18:08:25 rls Exp $
d334 7
a340 6
	      if (number(0,9) > 7) /* 20% chance */
		{
		  GET_POS(ch) = POS_SITTING;
		  send_to_char("The wind is so powerful that your small body is knocked backward and you fall to the ground!\r\n", ch);
		  act("$n is knocked backward by the force of the wind!", FALSE, ch, 0, 0, TO_ROOM);
		}
d1833 4
@


1.46
log
@Fixed a bug where you could have to shapechangers or mobs follow each other
through loop rooms (inf) and thus hang and or crash the mud... er, two (typo)
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.45 2004/11/01 05:18:24 jjl Exp $
d546 1
a546 1
  int was_in;
d581 1
d591 2
a592 2
      if (k->follower->in_room == EXIT(ch, dir)->to_room)
      { return 0; }
d617 2
a618 1
  if (IS_FIGHTING(ch)) {
@


1.45
log
@CI'd too quick
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.44 2004/11/01 05:17:05 jjl Exp jjl $
d549 10
a558 9
  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS) {
    return 0;
  } else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE) {
    send_to_char("Alas, you cannot go that way...\r\n", ch);
  } else if ((GET_LEVEL(ch) < LVL_GOD && IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN)) || IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT)) {
    send_to_char("Alas, you cannot go that way...\r\n", ch);
  } else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED) && 
	     GET_LEVEL(ch) < LVL_GOD) {
    if (EXIT(ch, dir)->keyword) {
d561 9
a569 7
    } else {
      send_to_char("It seems to be closed.\r\n", ch);
    }  
  } else {
    if (!ch->followers) {
      return (do_simple_move(ch, dir, need_specials_check));
    }
d571 2
a572 1
    for (k = ch->followers; k; k = next) {
d575 3
a577 3
      if (CAN_SEE(k->follower, ch)) {
	k->can_see_master = TRUE;
      }
d579 1
d581 6
a586 4
    if (!do_simple_move(ch, dir, need_specials_check)) {
      return 0;
    }
    for (k = ch->followers; k; k = next) {
d588 5
d597 2
a598 1
	   k->can_see_master ) {
d1830 3
@


1.44
log
@Added pk_checks for act.movement.c
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.43 2003/07/04 22:10:55 jjl Exp $
d40 1
d1817 3
@


1.43
log
@Let gods walk through doors.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.42 2003/06/23 01:47:09 jjl Exp $
d415 1
a415 1
  if (GET_HIT(ch)<((int)(0.1*GET_MAX_HIT(ch)))){
d426 1
a426 1
  if (GET_HIT(ch)>=((int)(0.1*GET_MAX_HIT(ch)))){
d1816 3
@


1.42
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.41 2003/06/20 13:17:47 rls Exp $
d237 3
a239 1
    if(GET_OBJ_TYPE(obj) == ITEM_WALL && GET_OBJ_VAL(obj,0) == dir){
d552 1
a552 1
  } else if (IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN) || IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT)) {
d554 2
a555 1
  } else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
d1816 3
@


1.41
log
@Changed scale and added bonus to already sneaking people so it
isn't as hard to remain sneaking while walking.  Works 99.9
of the time for high level skill... about 1/2 the time for
mid range and low skill.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.40 2003/02/02 01:33:17 jjl Exp $
d1577 6
d1813 6
@


1.40
log
@Fixing stand, removing the 8 second delay. Doh
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.39 2002/12/28 21:56:42 jjl Exp $
d39 1
d363 5
a367 3
  chance = number(1,100);
  if ( (chance > GET_SKILL(ch, SKILL_SNEAK))
  || ( (GET_SKILL(ch, SKILL_SNEAK) == 0) && chance < 5))
d1807 3
@


1.39
log
@Added delay for punk-mobs standing up and fleeing.
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.38 2002/11/30 19:44:06 jjl Exp jjl $
d1079 3
a1081 1
  WAIT_STATE(ch, PULSE_VIOLENCE * 2); 
d1804 3
@


1.38
log
@Goes to asleep?  The hell you say!
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.37 2002/09/22 19:33:05 jjl Exp $
d1079 2
d1802 3
@


1.37
log
@Fixed a bug pergy introduced, whereby the AFF_SNEAK bit was stripped,
but the actual spell wasn'. The net affect is you could get infinite
sneak "spells" upon yourself.
/
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.36 2002/09/13 02:32:10 jjl Exp $
d1486 1
a1486 1
    act("$n lies down and goes to asleep.", TRUE, ch, 0, 0, TO_ROOM);
d1800 6
@


1.36
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: act.movement.c,v 1.35 2002/07/17 17:04:37 rls Exp $
d366 3
a368 1
    REMOVE_BIT(AFF_FLAGS(ch), AFF_SNEAK);
d370 1
d1800 3
@


1.35
log
@fixed hide & sneak check to 100 pnt based chance (get_skill uses /10)
@
text
@d1 3
a3 1
// $Id: act.movement.c,v 1.34 2002/07/16 19:38:44 rls Exp $
d1795 143
a1937 138
// $Log: act.movement.c,v $
// Revision 1.34  2002/07/16 19:38:44  rls
// Adjusted sneak w/ hide to a 5% chance failure for those without sneak
//
// Revision 1.33  2002/07/16 19:29:35  rls
// Changed movement while sneaking to require a successful sneak check every
// round... also allowed the ability to move while hidden if successfully sneaking.
//
// Revision 1.32  2002/02/13 23:30:07  dce
// Went through all of the change position commands (sit, stand
// , kneel, sleep, etc..) to make sure that it accounted for
// fighting and floating positions.
//
// Revision 1.31  2002/02/11 02:47:57  dce
// When you stagger under a heavy load in do_simple_move, I
// added a update_pos call.
//
// Revision 1.30  2001/10/16 00:13:58  rjd
// Fly semantics improved.
//
// Revision 1.29  2001/10/11 07:19:25  rjd
// Immorts+ can now fly upon demand, walk on water, and travel about
// without having to worry about staggering under any weight.
//
// Revision 1.28  2001/04/07 14:14:30  dce
// You must be the proper level to enter a portal.
//
// Revision 1.27  2001/03/04 15:11:33  dce
// Fixed a crash bug in do_simple_move, changed riding to
// RIDING(ch).
//
// Revision 1.26  2001/01/23 23:48:26  dce
// Fixed's someones double declaration error
//
// Revision 1.25  2000/11/28 00:42:15  mtp
// removed mobprog references
//
// Revision 1.24  2000/11/20 03:43:03  rsd
// Added back rlog messages from prior to the addition of
// the $log$ string
//
// Revision 1.23  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.22  2000/09/19 21:37:17  rsd
// fixed a typo in riding.
//
// Revision 1.21  2000/09/18 01:32:48  rsd
// altered the mount and riding code checks to add skill bonus'
// for the mount being charmed.
//
// Revision 1.20  2000/09/07 01:54:32  rsd
// added a space at the end of the riding message to fix a typo.
//
// Revision 1.19  2000/06/05 18:43:56  rsd
// Revision 1.18  2000/06/05 00:21:06  rsd
// Retabbed and braced sections of do_dimple_move also fixed
// the riding check in do simple move to be a little more
// sane. I think.
// For 1.19
// I added bonuses for charisma and class to tame.
// I added bonuses for class to mount and riding.
// I also added a tame check to riding.
//
// Revision 1.17  2000/05/31 21:54:14  rsd
// made the likelyhood of getting bucked decrease dramatically
//
// Revision 1.16  2000/04/22 22:25:46  rsd
// removed hubis reference
//
// Revision 1.15  2000/04/21 00:56:44  rsd
// tabbed and braced perform_move as well as fixed the following
// into dark bug associated with can see.
//
// Revision 1.14  2000/04/17 00:49:58  rsd
// altered comment header while browsing the file
//
// Revision 1.13  1999/12/06 20:19:59  cso
// Fixed a typo in line "You are too busy fighting.."
//
// Revision 1.12  1999/11/28 22:35:18  cso
// mobs affected by charm can now do_move if they're also animated.
// this allows 'order fol north'.
//
// Revision 1.11  1999/09/08 07:06:03  jimmy
// More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
// with blood and killing
// --gurlaek
//
// Revision 1.10  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.9  1999/09/03 23:05:48  mtp
// added soe IS_FIGHTING checks
//
// Revision 1.8  1999/07/25 04:33:11  jimmy
// No more following people if you can't see them. Invis/dark etc.
// gurlaek
//
// Revision 1.7  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.6  1999/04/07 01:20:18  dce
// Allows extra descriptions on no exits.
//
// Revision 1.5  1999/03/14 14:28:11  jimmy
// Movement now has bite!  removed extra "flying" from
// movement_loss in constants.c to fix the mv bug.  reduced the
// movement gain by 5 for all ages in limits.c.  Removed the +5
// and +6 static movement gain so that it now actually updates
// based on the function in regen.c.  Gosh i'm a bastard.
// Fingon
//
// Revision 1.4  1999/03/14 03:18:02  jimmy
// Fixed the mount fleeing while your fighting after his TAME wear's off
// crashbug i hope.  Also, fixed do_tame to work properly.  fixed
// do_dismount to check for flying in water rooms. fixed do_simple_move
// to properly handle boats and fly in water rooms while mounted or not 
// mounted.  Lots of little things in the mount code.
// fingon
//
// Revision 1.3  1999/03/12 18:05:43  dce
// No flying over oceans
//
// Revision 1.2  1999/02/20 18:41:36  dce
// Adds improve_skill calls so that players can imprve their skills.
//
// Revision 1.1  1999/01/29 01:23:30  mud
// Initial revision
//
@


1.34
log
@Adjusted sneak w/ hide to a 5% chance failure for those without sneak
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.33 2002/07/16 19:29:35 rls Exp rls $
d360 1
a360 1
  chance = number(1,1000);
d362 1
a362 1
  || ( (GET_SKILL(ch, SKILL_SNEAK) == 0) && chance < 50))
d1794 3
@


1.33
log
@Changed movement while sneaking to require a successful sneak check every
round... also allowed the ability to move while hidden if successfully sneaking.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.32 2002/02/13 23:30:07 dce Exp $
d361 2
a362 1
  if (chance < GET_SKILL(ch, SKILL_SNEAK))
d1794 4
@


1.32
log
@Went through all of the change position commands (sit, stand
, kneel, sleep, etc..) to make sure that it accounted for
fighting and floating positions.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.31 2002/02/11 02:47:57 dce Exp $
d98 1
a98 1
  int vnum;
d326 1
a326 1
	  if (GET_SIZE(ch) <= SIZE_SMALL)
d348 3
a350 3
  if (riding) {
    sprintf(buf2, "You ride %s on %s.\r\n", dirs[dir],
	    PERS(RIDING(ch), ch));
d353 4
a356 3
  } else {
    sprintf(mmsg, "$n %s %s.",
	    movewords(ch, dir, ch->in_room, TRUE), dirs[dir]);
d359 8
d1793 5
@


1.31
log
@When you stagger under a heavy load in do_simple_move, I
added a update_pos call.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.30 2001/10/16 00:13:58 rjd Exp $
d1058 1
d1174 1
a1174 4
    act("You sit down.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    GET_POS1(ch) = POS1_SITTING;
d1177 2
a1178 4
    act("You stop floating around, and sit down.", FALSE, ch, 0, 0,
	TO_CHAR);
    act("$n stops floating around, and sits down.", TRUE, ch, 0, 0,
	TO_ROOM);
d1199 4
d1205 1
d1237 7
a1243 2
      act("You kneel.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n settles to $s knees.", TRUE, ch, 0, 0, TO_ROOM);
d1265 4
d1277 5
d1312 7
a1318 3
      act("You drop to your belly.", FALSE, ch, 0, 0, TO_CHAR);
      act("$n drops flat to the ground.", TRUE, ch, 0, 0, TO_ROOM);
      
d1350 4
d1412 4
d1418 1
d1428 1
a1428 1
    if (IS_FIGHTING(ch))
d1430 3
a1432 1
    
d1457 5
d1463 4
a1477 3
  case POS_FIGHTING:
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    break;
d1784 4
@


1.30
log
@Fly semantics improved.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.29 2001/10/11 07:19:25 rjd Exp $
d220 1
d1748 3
@


1.29
log
@Immorts+ can now fly upon demand, walk on water, and travel about
without having to worry about staggering under any weight.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.28 2001/04/07 14:14:30 dce Exp $
d1028 2
a1029 2
    act("&6&bYou lift into the air.&0",FALSE,ch,0,0,TO_CHAR);
    act("&6&b$n&6&b lifts into the air.&0",TRUE,ch,0,0,TO_ROOM);
d1054 2
a1055 2
    act("&6&bYou lift into the air.&0",FALSE,ch,0,0,TO_CHAR);
    act("&6&b$n&6&b lifts into the air.&0",TRUE,ch,0,0,TO_ROOM);
d1119 1
a1119 1
    act("You stop floating around, and put your feet on the ground.",
d1121 1
a1121 1
    act("$n stops floating around, and puts $s feet on the ground.",
d1127 1
a1127 1
    act("You stop floating around, and put your feet on the ground.",
d1129 2
a1130 2
    act("$n stops floating around, and puts $s feet on the ground.",
	TRUE, ch, 0, 0, TO_ROOM);
d1747 4
@


1.28
log
@You must be the proper level to enter a portal.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.27 2001/03/04 15:11:33 dce Exp $
d55 5
d159 2
d213 3
a215 1
  if(!riding && !flying && CURRENT_LOAD(ch) >= 9) {
d1025 10
a1034 1
  if(!IS_AFFECTED(ch, AFF_FLYING)) {
d1038 2
a1039 1
  if (IS_FIGHTING(ch)) {
d1043 2
a1044 1
  if(GET_POS(ch) == POS_FLYING) {
d1048 1
a1048 1
  if(GET_POS(ch) != POS_STANDING || GET_POS1(ch) != POS1_STANDING){
d1052 6
a1057 3
  act("&6&bYou lift into the air.&0",FALSE,ch,0,0,TO_CHAR);
  act("&6&b$n&6&b lifts into the air.&0",TRUE,ch,0,0,TO_ROOM);
  GET_POS(ch) = POS_FLYING;
a1305 3



a1423 2


d1747 3
@


1.27
log
@Fixed a crash bug in do_simple_move, changed riding to
RIDING(ch).
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.26 2001/01/23 23:48:26 dce Exp $
d840 4
a843 1
	  
d1729 4
@


1.26
log
@Fixed's someones double declaration error
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.25 2000/11/28 00:42:15 mtp Exp $
d439 1
a439 1
      if (riding) {
d1726 3
@


1.25
log
@removed mobprog references
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.24 2000/11/20 03:43:03 rsd Exp mtp $
a98 1
  int special(struct char_data *ch, int cmd, char *arg);
d1726 3
@


1.24
log
@Added back rlog messages from prior to the addition of
the $log$ string
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.23 2000/11/03 17:28:33 jimmy Exp $
a46 2
void mprog_greet_trigger(struct char_data * ch);
void mprog_entry_trigger(struct char_data * mob);
a508 3
  if (!IS_AFFECTED(ch, AFF_SNEAK)) {
    mprog_entry_trigger(ch);
    mprog_greet_trigger(ch);}
d1727 4
@


1.23
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.22 2000/09/19 21:37:17 rsd Exp $
d1732 5
d1784 44
@


1.22
log
@fixed a typo in riding.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.21 2000/09/18 01:32:48 rsd Exp $
d834 1
a834 1
  int door, rnum;
d909 1
d938 7
d963 4
a966 1
          return;}}}
d977 1
a977 1
  } else if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_INDOORS))
d979 1
a979 1
  else {
d1732 3
@


1.21
log
@altered the mount and riding code checks to add skill bonus'
for the mount being charmed.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.20 2000/09/07 01:54:32 rsd Exp $
d345 1
a345 1
    sprintf(mmsg, "$n rides %s on ", dirs[dir]);
d1721 4
@


1.20
log
@added a space at the end of the riding message to fix a typo.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.19 2000/06/05 18:43:56 rsd Exp $
d270 3
d1551 4
d1721 3
@


1.19
log
@Revision 1.18  2000/06/05 00:21:06  rsd
Retabbed and braced sections of do_dimple_move also fixed
the riding check in do simple move to be a little more
sane. I think.
For 1.19
I added bonuses for charisma and class to tame.
I added bonuses for class to mount and riding.
I also added a tame check to riding.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.17 2000/05/31 21:54:14 rsd Exp $
d427 1
a427 1
      sprintf(tmp, "$n arrives from %s%s, riding",
d1714 10
@


1.18
log
@Retabbed and braced sections of do_dimple_move also fixed
the riding check in do simple move to be a little more
sane. I think.
@
text
@d103 2
a104 1
  
d267 4
a270 1
    if ((GET_SKILL(ch, SKILL_RIDING) + ride_bonus) < number(1, 75) - number(-4,need_movement) && (GET_DEX(ch) <= number(1, 101))) {
d1509 2
a1510 1
  
d1538 13
a1550 2
  } else if ( (GET_SKILL(ch, SKILL_MOUNT) <=  ( number(1, 101) + GET_LEVEL(vict) ) / 2) 
	      && GET_DEX(ch) <= number(1, 101)) {
d1632 2
a1633 1
  
d1649 3
d1658 12
a1669 1
  } else if (GET_SKILL(ch, SKILL_TAME) <= number(1, 101)) {
d1671 1
d1677 1
a1677 1
  af.duration = 24;
@


1.17
log
@made the likelyhood of getting bucked decrease dramatically
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.16 2000/04/22 22:25:46 rsd Exp $
d102 1
d113 9
a121 25
    if (ch->master)
      {
	if (GET_LEVEL(ch->master) < LVL_IMMORT)
	  {
	    if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
	      {
		send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
		return 0;
	      }
	  }else
	    {
	      if ((ch->master->in_room) != (EXIT(ch, dir)->to_room))
		{
		  if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
		    {
		      send_to_char("&0&8A mysterious powerful force pushes you back&0\r\n", ch);
		      return 0;
		    }
		}
	    }
      }
    else
      {
	if (IS_SET(ROOM_FLAGS(EXIT(ch, dir)->to_room), ROOM_GODROOM))
	  {
d125 6
d132 1
d255 4
a258 6
  
  if (riding && GET_SKILL(ch, SKILL_RIDING) < number(1, 101)-number(-4,need_movement)) {
    act("$N rears backwards, throwing you to the ground.", FALSE, ch, 0, RIDING(ch), TO_CHAR);
    act("You rear backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_VICT);
    act("$N rears backwards, throwing $n to the ground.", FALSE, ch, 0, RIDING(ch), TO_NOTVICT);
    dismount_char(ch);
d260 14
a273 2
    damage(ch, ch, dice(10,6), -1);
    return 0;
d275 1
d1682 3
@


1.16
log
@removed hubis reference
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.15 2000/04/21 00:56:44 rsd Exp $
d207 1
a207 1
      damage(RIDDEN_BY(ch), RIDDEN_BY(ch), dice(10,6), -1);
d1530 2
a1531 1
  } else if (GET_SKILL(ch, SKILL_MOUNT) <= number(1, 101)) {
d1545 1
a1545 1
  
d1547 2
a1548 1
    act("$N suddenly bucks upwards, throwing you violently to the ground!", FALSE, ch, 0, vict, TO_CHAR);
d1553 1
a1553 1
  }
d1557 1
d1679 3
@


1.15
log
@tabbed and braced perform_move as well as fixed the following
into dark bug associated with can see.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.14 2000/04/17 00:49:58 rsd Exp $
d466 3
a468 1
  /* silly deathtraps thee will be none in Hubis*/
d1676 4
@


1.14
log
@altered comment header while browsing the file
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.13 1999/12/06 20:19:59 cso Exp $
d511 2
a512 2
  
  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS)
d514 1
a514 1
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
d516 1
a516 1
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN) || IS_SET(EXIT(ch, dir)->exit_info, EX_DESCRIPT))
d518 1
a518 1
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)) {
d522 1
a522 1
    } else
d524 1
d526 1
a526 1
    if (!ch->followers)
d528 9
a536 1
    
d538 1
a538 1
    if (!do_simple_move(ch, dir, need_specials_check))
d540 1
a540 1
    
d543 5
a547 6
      if ((k->follower->in_room == was_in) &&
	  (GET_POS(k->follower) >= POS_STANDING) &&
	  (!IS_FIGHTING(k->follower)) && 
	  (!PLR_FLAGGED(k->follower, PLR_CASTING)) &&
	  /* no more following if you can't see who you're following --gurlaek 7/25/1999 */
	  (CAN_SEE(k->follower, ch))) {
d551 1
a551 1
    }
d1674 3
@


1.13
log
@Fixed a typo in line "You are too busy fighting.."
@
text
@d1 3
a3 3
// $Id: act.movement.c,v 1.12 1999/11/28 22:35:18 cso Exp $
/* ************************************************************************
 *   File: act.movement.c                                Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
a16 1

d1666 3
@


1.12
log
@mobs affected by charm can now do_move if they're also animated.
this allows 'order fol north'.
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.11 1999/09/08 07:06:03 jimmy Exp $
d557 1
a557 1
    send_to_char("You are to busy fighting to turn you back and walk away!\r\n", ch);
d1665 4
@


1.11
log
@More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
with blood and killing
--gurlaek
@
text
@d1 1
a1 1
// $Id: act.movement.c,v 1.10 1999/09/05 07:00:39 jimmy Exp $
d224 3
a226 1
  if (IS_AFFECTED(ch, AFF_CHARM) && ch->master && ch->in_room == ch->master->in_room) {
d1665 5
@


1.10
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d95 1
a95 1
  struct obj_data *bloodp, *bloodd, *i, *obj;
d361 9
a369 3
  if (GET_HIT(ch)<(((int)(0.3*GET_MAX_HIT(ch))))){
    for (i = world[ch->in_room].contents; i; i = i->next_content) {
      if(GET_OBJ_VNUM(i)==34){
d371 4
a374 2
      }else if(GET_OBJ_VNUM(i)==35){
	extract_obj(i);}}}
d1662 4
a1665 1
// $Log$
@


1.9
log
@added soe IS_FIGHTING checks
@
text
@d1 1
d1654 1
@


1.8
log
@No more following people if you can't see them. Invis/dark etc.
gurlaek
@
text
@d757 4
d804 4
d955 4
d980 4
d1481 4
d1537 3
d1553 1
d1557 3
d1589 4
@


1.7
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d524 4
a527 1
	  (!IS_FIGHTING(k->follower)) && (!PLR_FLAGGED(k->follower, PLR_CASTING))) {
@


1.6
log
@Allows extra descriptions on no exits.
@
text
@d109 1
a109 1
  if (GET_LEVEL(ch) < LVL_IMMORT)
d139 1
a139 1
  
@


1.5
log
@Movement now has bite!  removed extra "flying" from
movement_loss in constants.c to fix the mv bug.  reduced the
movement gain by 5 for all ages in limits.c.  Removed the +5
and +6 static movement gain so that it now actually updates
based on the function in regen.c.  Gosh i'm a bastard.
Fingon
@
text
@d504 1
a504 1
  else if (IS_SET(EXIT(ch, dir)->exit_info, EX_HIDDEN))
@


1.4
log
@Fixed the mount fleeing while your fighting after his TAME wear's off
crashbug i hope.  Also, fixed do_tame to work properly.  fixed
do_dismount to check for flying in water rooms. fixed do_simple_move
to properly handle boats and fly in water rooms while mounted or not mounted.
Lots of little things in the mount code.
fingon
@
text
@d170 1
a170 1
  if(GET_POS(ch) == POS_FLYING && !riding)
d173 3
a175 2
    need_movement = (movement_loss[SECT(ch->in_room)] +
		     movement_loss[SECT(EXIT(ch, dir)->to_room)]) >> 1;
a206 1
      log("TAME: buck the rider and run like hell!");
d208 1
a208 1
    log("TAME: unable to move cause rider is in combat");
d303 1
a303 1
	  
d316 2
a317 1
  if (GET_LEVEL(ch) < LVL_IMMORT && !IS_NPC(ch) && !(riding || ridden_by))
d319 1
@


1.3
log
@No flying over oceans
@
text
@d91 1
a91 1
  int same_room = 0, riding = 0, ridden_by = 0, flying = 0;
d107 1
a107 1
  
a139 1
  if (GET_POS(ch) == POS_FLYING)  flying = 1;
d141 15
a155 2
  if (RIDING(ch))    riding = 1;
  if (RIDDEN_BY(ch)) ridden_by = 1;
d159 3
a161 2
  if (riding && IS_AFFECTED(RIDING(ch), AFF_FLYING))  flying = 1;
  if (ridden_by && IS_AFFECTED(RIDDEN_BY(ch), AFF_FLYING))  flying = 1;
a162 2

  
d169 21
d194 17
d212 1
d237 1
a237 1
  /* if this room or the one we're going to needs a boat, check for one */
d240 2
a241 3
    
    if ((riding && !has_boat(RIDING(ch))) || !has_boat(ch) || !flying) {
      send_to_char("You need a boat to go there.\r\n", ch);
a245 10
  if ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_WATER_SWIM)) {
    
    if ((riding && !has_boat(RIDING(ch))) || !has_boat(ch) || !flying) {
      send_to_char("You need a boat to go there.\r\n", ch);
      return 0;
    }
  }


a259 22
  /* move points needed is avg. move loss for src and destination sect type */
  if(GET_POS(ch) == POS_FLYING && !riding)
    need_movement = 1;
  else 
    need_movement = (movement_loss[SECT(ch->in_room)] +
		     movement_loss[SECT(EXIT(ch, dir)->to_room)]) >> 1;
  
  if (riding) {
    if (GET_MOVE(RIDING(ch)) < need_movement) {
      send_to_char("Your mount is too exhausted.\r\n", ch);
      return 0;
    }
  } else {
    if (GET_MOVE(ch) < need_movement && !IS_NPC(ch)) {
      if (need_specials_check && ch->master)
	send_to_char("You are too exhausted to follow.\r\n", ch);
      else
	send_to_char("You are too exhausted.\r\n", ch);
      return 0;
    }
  }
  
d1512 1
a1512 1
  } else if (SECT(ch->in_room) == SECT_WATER_NOSWIM && !has_boat(ch)) {
d1537 1
a1537 1
  dismount_char(ch);
d1541 1
a1541 1
    damage(ch, ch, dice(10,4), -1);
d1543 3
a1545 1
  
d1585 5
a1589 2
  affect_join(vict, &af, FALSE, FALSE, FALSE, FALSE, FALSE);
  
@


1.2
log
@Adds improve_skill calls so that players can imprve their skills.
@
text
@d196 11
@


1.1
log
@Initial revision
@
text
@d1460 1
@
