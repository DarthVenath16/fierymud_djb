head	1.29;
access;
symbols;
locks; strict;
comment	@ * @;


1.29
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.30.20.42.50;	author myc;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.20.18.39.39;	author jps;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.27.01.42.03;	author jps;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.24.23.02.52;	author jps;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.04.13.31.02;	author jps;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.24.07.47.55;	author jps;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.24.18.44.07;	author rsd;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.24.17.41.22;	author rsd;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.03.01.45.14;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.23.02.21.19;	author rsd;	state Exp;
branches;
next	1.8;

1.8
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.04.30.19.12.56;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.04.09.20.52.29;	author dce;	state Exp;
branches;
next	1.5;

1.5
date	99.04.09.04.14.32;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.04.09.03.19.41;	author dce;	state Exp;
branches;
next	1.3;

1.3
date	99.04.08.16.56.24;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.16.42.27;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: mail.c                                        Part of CircleMUD *
*  Usage: Internal funcs and player spec-procs of mud-mail system         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/******* MUD MAIL SYSTEM MAIN FILE ***************************************

Written by Jeremy Elson (jelson@@cs.jhu.edu)

*************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "handler.h"
#include "mail.h"

void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg);
void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg);
void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg);

extern struct room_data *world;
extern struct index_data *mob_index;
extern int no_mail;
int find_name(char *name);

mail_index_type *mail_index = 0;/* list of recs in the mail file  */
position_list_type *free_list = 0;	/* list of free positions in file */
long file_end_pos = 0;		/* length of file */


void push_free_list(long pos)
{
  position_list_type *new_pos;

  CREATE(new_pos, position_list_type, 1);
  new_pos->position = pos;
  new_pos->next = free_list;
  free_list = new_pos;
}



long pop_free_list(void)
{
  position_list_type *old_pos;
  long return_value;

  if ((old_pos = free_list) != 0) {
    return_value = free_list->position;
    free_list = old_pos->next;
    free(old_pos);
    return return_value;
  } else
    return file_end_pos;
}



mail_index_type *find_char_in_index(long searchee)
{
  mail_index_type *tmp;

  if (searchee < 0) {
    log("SYSERR: Mail system -- non fatal error #1.");
    return 0;
  }
  for (tmp = mail_index; (tmp && tmp->recipient != searchee); tmp = tmp->next);

  return tmp;
}



void write_to_file(void *buf, int size, long filepos)
{
  FILE *mail_file;

  mail_file = fopen(MAIL_FILE, "r+b");

  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #2!!!");
    no_mail = 1;
    return;
  }
  fseek(mail_file, filepos, SEEK_SET);
  fwrite(buf, size, 1, mail_file);

  /* find end of file */
  fseek(mail_file, 0L, SEEK_END);
  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  return;
}


void read_from_file(void *buf, int size, long filepos)
{
  FILE *mail_file;

  mail_file = fopen(MAIL_FILE, "r+b");

  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #3!!!");
    no_mail = 1;
    return;
  }
  fseek(mail_file, filepos, SEEK_SET);
  fread(buf, size, 1, mail_file);
  fclose(mail_file);
  return;
}




void index_mail(long id_to_index, long pos)
{
  mail_index_type *new_index;
  position_list_type *new_position;

  if (id_to_index < 0) {
    log("SYSERR: Mail system -- non-fatal error #4.");
    return;
  }
  if (!(new_index = find_char_in_index(id_to_index))) {
    /* name not already in index.. add it */
    CREATE(new_index, mail_index_type, 1);
    new_index->recipient = id_to_index;
    new_index->list_start = NULL;

    /* add to front of list */
    new_index->next = mail_index;
    mail_index = new_index;
  }
  /* now, add this position to front of position list */
  CREATE(new_position, position_list_type, 1);
  new_position->position = pos;
  new_position->next = new_index->list_start;
  new_index->list_start = new_position;
}


/* SCAN_FILE */
/* scan_file is called once during boot-up.  It scans through the mail file
   and indexes all entries currently in the mail file. */
int scan_file(void)
{
  FILE *mail_file;
  header_block_type next_block;
  int total_messages = 0, block_num = 0;
  char buf[100];

  if (!(mail_file = fopen(MAIL_FILE, "r"))) {
    log("Mail file non-existant... creating new file.");
    mail_file = fopen(MAIL_FILE, "w");
    fclose(mail_file);
    return 1;
  }
  while (fread(&next_block, sizeof(header_block_type), 1, mail_file)) {
    if (next_block.block_type == HEADER_BLOCK) {
      index_mail(next_block.header_data.to, block_num * BLOCK_SIZE);
      total_messages++;
    } else if (next_block.block_type == DELETED_BLOCK)
      push_free_list(block_num * BLOCK_SIZE);
    block_num++;
  }

  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  sprintf(buf, "   %ld bytes read.", file_end_pos);
  log(buf);
  if (file_end_pos % BLOCK_SIZE) {
    log("SYSERR: Error booting mail system -- Mail file corrupt!");
    log("SYSERR: Mail disabled!");
    return 0;
  }
  sprintf(buf, "   Mail file read -- %d messages.", total_messages);
  log(buf);
  return 1;
}				/* end of scan_file */


/* HAS_MAIL */
/* a simple little function which tells you if the guy has mail or not */
int has_mail(long recipient)
{
  if (find_char_in_index(recipient))
    return 1;
  return 0;
}



/* STORE_MAIL  */
/* call store_mail to store mail.  (hard, huh? :-) )  Pass 3 arguments:
   who the mail is to (long), who it's from (long), and a pointer to the
   actual message text (char *).
*/

/*void store_mail(long to, long from, char *message_pointer)*/
void store_mail(long to, long from, int vnum, char *message_pointer)
{
  header_block_type header;
  data_block_type data;
  long last_address, target_address;
  char *msg_txt = message_pointer;
  int bytes_written = 0;
  int total_length = strlen(message_pointer);

  assert(sizeof(header_block_type) == sizeof(data_block_type));
  assert(sizeof(header_block_type) == BLOCK_SIZE);

  if (from < 0 || to < 0 || !*message_pointer) {
    log("SYSERR: Mail system -- non-fatal error #5.");
    return;
  }
  memset((char *) &header, 0, sizeof(header));	/* clear the record */
  header.block_type = HEADER_BLOCK;
  header.header_data.next_block = LAST_BLOCK;
  header.header_data.from = from;
  header.header_data.to = to;
  header.header_data.vnum = vnum;
  header.header_data.mail_time = time(0);
  strncpy(header.txt, msg_txt, HEADER_BLOCK_DATASIZE);
  header.txt[HEADER_BLOCK_DATASIZE] = '\0';

  target_address = pop_free_list();	/* find next free block */
  index_mail(to, target_address);	/* add it to mail index in memory */
  write_to_file(&header, BLOCK_SIZE, target_address);

  if (strlen(msg_txt) <= HEADER_BLOCK_DATASIZE)
    return;			/* that was the whole message */

  bytes_written = HEADER_BLOCK_DATASIZE;
  msg_txt += HEADER_BLOCK_DATASIZE;	/* move pointer to next bit of text */

  /*
   * find the next block address, then rewrite the header to reflect where
   * the next block is.
   */
  last_address = target_address;
  target_address = pop_free_list();
  header.header_data.next_block = target_address;
  write_to_file(&header, BLOCK_SIZE, last_address);

  /* now write the current data block */
  memset((char *) &data, 0, sizeof(data));	/* clear the record */
  data.block_type = LAST_BLOCK;
  strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
  data.txt[DATA_BLOCK_DATASIZE] = '\0';
  write_to_file(&data, BLOCK_SIZE, target_address);
  bytes_written += strlen(data.txt);
  msg_txt += strlen(data.txt);

  /*
   * if, after 1 header block and 1 data block there is STILL part of the
   * message left to write to the file, keep writing the new data blocks and
   * rewriting the old data blocks to reflect where the next block is.  Yes,
   * this is kind of a hack, but if the block size is big enough it won't
   * matter anyway.  Hopefully, MUD players won't pour their life stories out
   * into the Mud Mail System anyway.
   *
   * Note that the block_type data field in data blocks is either a number >=0,
   * meaning a link to the next block, or LAST_BLOCK flag (-2) meaning the
   * last block in the current message.  This works much like DOS' FAT.
   */

  while (bytes_written < total_length) {
    last_address = target_address;
    target_address = pop_free_list();

    /* rewrite the previous block to link it to the next */
    data.block_type = target_address;
    write_to_file(&data, BLOCK_SIZE, last_address);

    /* now write the next block, assuming it's the last.  */
    data.block_type = LAST_BLOCK;
    strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
    data.txt[DATA_BLOCK_DATASIZE] = '\0';
    write_to_file(&data, BLOCK_SIZE, target_address);

    bytes_written += strlen(data.txt);
    msg_txt += strlen(data.txt);
  }
}				/* store mail */




/* READ_DELETE */
/* read_delete takes 1 char pointer to the name of the person whose mail
you're retrieving.  It returns to you a char pointer to the message text.
The mail is then discarded from the file and the mail index. */

/*char *read_delete(long recipient)*/
char *read_delete(long recipient, int *obj_vnum)
/* recipient is the name as it appears in the index.
   recipient_formatted is the name as it should appear on the mail
   header (i.e. the text handed to the player) */
{
  header_block_type header;
  data_block_type data;
  mail_index_type *mail_pointer, *prev_mail;
  position_list_type *position_pointer;
  long mail_address, following_block;
  char *message, *tmstr, buf[200];
  size_t string_size;

  if (recipient < 0) {
    log("SYSERR: Mail system -- non-fatal error #6.");
    return 0;
  }
  if (!(mail_pointer = find_char_in_index(recipient))) {
    log("SYSERR: Mail system -- post office spec_proc error?  Error #7.");
    return 0;
  }
  if (!(position_pointer = mail_pointer->list_start)) {
    log("SYSERR: Mail system -- non-fatal error #8.");
    return 0;
  }
  if (!(position_pointer->next)) {	/* just 1 entry in list. */
    mail_address = position_pointer->position;
    free(position_pointer);

    /* now free up the actual name entry */
    if (mail_index == mail_pointer) {	/* name is 1st in list */
      mail_index = mail_pointer->next;
      free(mail_pointer);
    } else {
      /* find entry before the one we're going to del */
      for (prev_mail = mail_index;
	   prev_mail->next != mail_pointer;
	   prev_mail = prev_mail->next);
      prev_mail->next = mail_pointer->next;
      free(mail_pointer);
    }
  } else {
    /* move to next-to-last record */
    while (position_pointer->next->next)
      position_pointer = position_pointer->next;
    mail_address = position_pointer->next->position;
    free(position_pointer->next);
    position_pointer->next = 0;
  }

  /* ok, now lets do some readin'! */
  read_from_file(&header, BLOCK_SIZE, mail_address);

  if (header.block_type != HEADER_BLOCK) {
    log("SYSERR: Oh dear.");
    no_mail = 1;
    log("SYSERR: Mail system disabled!  -- Error #9.");
    return 0;
  }
  tmstr = asctime(localtime(&header.header_data.mail_time));
  *(tmstr + strlen(tmstr) - 1) = '\0';
  *obj_vnum = header.header_data.vnum;

  sprintf(buf, " * * * * &2Hubis Mail System&0 * * * *\r\n"
	  "Date: %s\r\n"
	  "  To: %s\r\n"
	  "From: %s\r\n\r\n", tmstr, get_name_by_id(recipient),
	  get_name_by_id(header.header_data.from));

  string_size = (sizeof(char) * (strlen(buf) + strlen(header.txt) + 1));
  CREATE(message, char, string_size);
  strcpy(message, buf);
  strcat(message, header.txt);
  message[string_size - 1] = '\0';
  following_block = header.header_data.next_block;

  /* mark the block as deleted */
  header.block_type = DELETED_BLOCK;
  write_to_file(&header, BLOCK_SIZE, mail_address);
  push_free_list(mail_address);

  while (following_block != LAST_BLOCK) {
    read_from_file(&data, BLOCK_SIZE, following_block);

    string_size = (sizeof(char) * (strlen(message) + strlen(data.txt) + 1));
    RECREATE(message, char, string_size);
    strcat(message, data.txt);
    message[string_size - 1] = '\0';
    mail_address = following_block;
    following_block = data.block_type;
    data.block_type = DELETED_BLOCK;
    write_to_file(&data, BLOCK_SIZE, mail_address);
    push_free_list(mail_address);
  }

  return message;
}


/*****************************************************************
** Below is the spec_proc for a postmaster using the above       **
** routines.  Written by Jeremy Elson (jelson@@server.cs.jhu.edu) **
*****************************************************************/

SPECIAL(postmaster)
{
  if (!ch->desc || IS_NPC(ch))
    return 0;			/* so mobs don't get caught here */

  if (!(CMD_IS("mail") || CMD_IS("check") || CMD_IS("receive")))
    return 0;

  if (no_mail) {
    send_to_char("Sorry, the mail system is having technical difficulties.\r\n", ch);
    return 0;
  }

  if (CMD_IS("mail")) {
    postmaster_send_mail(ch, me, cmd, argument);
    return 1;
  } else if (CMD_IS("check")) {
    postmaster_check_mail(ch, me, cmd, argument);
    return 1;
  } else if (CMD_IS("receive")) {
    postmaster_receive_mail(ch, me, cmd, argument);
    return 1;
  } else
    return 0;
}


void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg)
{
  long recipient;
  char buf[256];
  char buf2[256];
  int price = STAMP_PRICE;
  struct obj_data *obj;
  extern struct index_data *obj_index;

  obj = NULL;

  if (GET_LEVEL(ch) < MIN_MAIL_LEVEL) {
    sprintf(buf, "$n tells you, 'Sorry, you have to be level %d to send mail!'",
	    MIN_MAIL_LEVEL);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  /*one_argument(arg, buf);*/
  two_arguments(arg, buf, buf2);

  if (!*buf) {			/* you'll get no argument from me! */
    act("$n tells you, 'You need to specify an addressee!'",
	FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  /*if (GET_GOLD(ch) < STAMP_PRICE) {
    sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
	    "$n tells you, '...which I see you can't afford.'", STAMP_PRICE);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }*/

  if (*buf2 && (obj = get_obj_in_list_vis(ch, buf2, ch->carrying))) {
     act("$n takes $p and prepares it for packaging.", FALSE, mailman, obj, ch, TO_VICT);
     price += STAMP_PRICE*.1;
     price += GET_OBJ_WEIGHT(obj)*10;
   }

   if (GET_GOLD(ch) < price) {
     sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
 	    "$n tells you, '...which I see you can't afford.'", price);
     act(buf, FALSE, mailman, 0, ch, TO_VICT);
     return;
   }

   if (obj != NULL) {
     ch->desc->mail_vnum = GET_OBJ_VNUM(obj);
     extract_obj(obj);
   } else
     ch->desc->mail_vnum = NOTHING;

  if ((recipient = get_id_by_name(buf)) < 0) {
    act("$n tells you, 'No one by that name is registered here!'",
	FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  act("$n starts to write some mail.", TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf, "$n tells you, 'I'll take %d coins for the stamp.'\r\n"
      "$n tells you, 'Write your message, (/s saves /h for help)'",
	  price);

  act(buf, FALSE, mailman, 0, ch, TO_VICT);
  GET_GOLD(ch) -= price;
  SET_BIT(PLR_FLAGS(ch), PLR_MAILING | PLR_WRITING);

  ch->desc->mail_to = recipient;
  ch->desc->str = (char **) malloc(sizeof(char *));
  *(ch->desc->str) = NULL;
  ch->desc->max_str = MAX_MAIL_SIZE;
}


void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg)
{
  char buf[256];

  if (has_mail(GET_IDNUM(ch)))
    sprintf(buf, "$n tells you, 'You have mail waiting.'");
  else
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
  act(buf, FALSE, mailman, 0, ch, TO_VICT);
}


void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg)
{
  char buf[256];
  /*struct obj_data *obj;*/
  struct obj_data *obj, *mail_obj;
  int obj_vnum = NOTHING;

  if (!has_mail(GET_IDNUM(ch))) {
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  while (has_mail(GET_IDNUM(ch))) {
    obj = create_obj();
    obj->item_number = NOTHING;
    obj->name = str_dup("mail paper letter");
    obj->short_description = str_dup("a piece of mail");
    obj->description = str_dup("Someone has left a piece of mail here.");

    GET_OBJ_TYPE(obj) = ITEM_NOTE;
    GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE | ITEM_WEAR_HOLD;
    GET_OBJ_WEIGHT(obj) = 1;
    GET_OBJ_COST(obj) = 30;
    GET_OBJ_RENT(obj) = 10;
    /*obj->action_description = read_delete(GET_IDNUM(ch));*/
	obj->action_description = read_delete(GET_IDNUM(ch), &obj_vnum);

    if (obj->action_description == NULL)
      obj->action_description =
	str_dup("Mail system error - please report.  Error #11.\r\n");

    obj_to_char(obj, ch);

	if (obj_vnum != NOTHING && real_object(obj_vnum) != NOTHING) {
       mail_obj = read_object(real_object(obj_vnum), REAL);
       obj_to_char(mail_obj, ch);
       act("$n gives you $p, which was attached to your mail.", FALSE, mailman, mail_obj, ch, TO_VICT);
       act("$N gives $n $p, which was attached to $S mail.", FALSE, ch, mail_obj, mailman, TO_ROOM);
     }

    act("$n gives you a piece of mail.", FALSE, mailman, 0, ch, TO_VICT);
    act("$N gives $n a piece of mail.", FALSE, ch, 0, mailman, TO_ROOM);
  }
}
@


1.29
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: mail.c,v 1.28 2009/03/09 04:33:20 jps Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: mail.c                                        Part of FieryMUD  *
 *  Usage: Internal funcs and player spec-procs of mud-mail system         *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

/******* MUD MAIL SYSTEM MAIN FILE ***************************************
	 
	 Written by Jeremy Elson (jelson@@cs.jhu.edu)

*************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "handler.h"
#include "mail.h"
#include "players.h"
#include "modify.h"
#include "specprocs.h"

char *RICK_SALA =

"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=\r\n"
"=~=~=  Rick Sala known to many as his admin character Pergus        =~=~=\r\n"
"=~=~=  passed away on June 21, 2006.                                =~=~=\r\n"
"=~=~=  Rick was a valuable friend and asset to us all and is sorely =~=~=\r\n"
"=~=~=  missed for his wit, humor, and the friend he was to us all.  =~=~=\r\n"
"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=\r\n";


void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg);
void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
			   int cmd, char *arg);
void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
			     int cmd, char *arg);

void money_convert(struct char_data* ch, int amount);
extern int no_mail;
int find_name(char *name);

mail_index_type *mail_index = 0;/* list of recs in the mail file  */
position_list_type *free_list = 0;	/* list of free positions in file */
long file_end_pos = 0;		/* length of file */


void push_free_list(long pos)
{
  position_list_type *new_pos;
  
  CREATE(new_pos, position_list_type, 1);
  new_pos->position = pos;
  new_pos->next = free_list;
  free_list = new_pos;
}



long pop_free_list(void)
{
  position_list_type *old_pos;
  long return_value;
  
  if ((old_pos = free_list) != 0) {
    return_value = free_list->position;
    free_list = old_pos->next;
    free(old_pos);
    return return_value;
  } else
    return file_end_pos;
}



mail_index_type *find_char_in_index(long searchee)
{
  mail_index_type *tmp;
  
  if (searchee < 0) {
    log("SYSERR: Mail system -- non fatal error #1.");
    return 0;
  }
  for (tmp = mail_index; (tmp && tmp->recipient != searchee); tmp = tmp->next);
  
  return tmp;
}



void write_to_file(void *buf, int size, long filepos)
{
  FILE *mail_file;
  
  mail_file = fopen(MAIL_FILE, "r+b");
  
  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #2!!!");
    no_mail = 1;
    return;
  }
  fseek(mail_file, filepos, SEEK_SET);
  fwrite(buf, size, 1, mail_file);
  
  /* find end of file */
  fseek(mail_file, 0L, SEEK_END);
  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  return;
}


void read_from_file(void *buf, int size, long filepos)
{
  FILE *mail_file;
  
  mail_file = fopen(MAIL_FILE, "r+b");
  
  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #3!!!");
    no_mail = 1;
    return;
  }
  fseek(mail_file, filepos, SEEK_SET);
  fread(buf, size, 1, mail_file);
  fclose(mail_file);
  return;
}




void index_mail(long id_to_index, long pos)
{
  mail_index_type *new_index;
  position_list_type *new_position;
  
  if (id_to_index < 0) {
    log("SYSERR: Mail system -- non-fatal error #4.");
    return;
  }
  if (!(new_index = find_char_in_index(id_to_index))) {
    /* name not already in index.. add it */
    CREATE(new_index, mail_index_type, 1);
    new_index->recipient = id_to_index;
    new_index->list_start = NULL;
    
    /* add to front of list */
    new_index->next = mail_index;
    mail_index = new_index;
  }
  /* now, add this position to front of position list */
  CREATE(new_position, position_list_type, 1);
  new_position->position = pos;
  new_position->next = new_index->list_start;
  new_index->list_start = new_position;
}


/* SCAN_FILE */
/* scan_file is called once during boot-up.  It scans through the mail file
   and indexes all entries currently in the mail file. */
int scan_file(void)
{
  FILE *mail_file;
  header_block_type next_block;
  int total_messages = 0, block_num = 0;
  char buf[100];
  
  if (!(mail_file = fopen(MAIL_FILE, "r"))) {
    log("Mail file non-existent... creating new file.");
    mail_file = fopen(MAIL_FILE, "w");
    fclose(mail_file);
    return 1;
  }
  while (fread(&next_block, sizeof(header_block_type), 1, mail_file)) {
    if (next_block.block_type == HEADER_BLOCK) {
      index_mail(next_block.header_data.to, block_num * BLOCK_SIZE);
      total_messages++;
    } else if (next_block.block_type == DELETED_BLOCK)
      push_free_list(block_num * BLOCK_SIZE);
    block_num++;
  }
  
  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  sprintf(buf, "   %ld bytes read.", file_end_pos);
  log("%s",buf);
  if (file_end_pos % BLOCK_SIZE) {
    log("SYSERR: Error booting mail system -- Mail file corrupt!");
    log("SYSERR: Mail disabled!");
    return 0;
  }
  sprintf(buf, "   Mail file read -- %d messages.", total_messages);
  log("%s",buf);
  return 1;
}				/* end of scan_file */


/* HAS_MAIL */
/* a simple little function which tells you if the guy has mail or not */
int has_mail(long recipient)
{
  if (find_char_in_index(recipient))
    return 1;
  return 0;
}



/* STORE_MAIL  */
/* call store_mail to store mail.  (hard, huh? :-) )  Pass 3 arguments:
   who the mail is to (long), who it's from (long), and a pointer to the
   actual message text (char *).
*/

/*void store_mail(long to, long from, char *message_pointer)*/
void store_mail(long to, long from, int vnum, char *message_pointer)
{
  header_block_type header;
  data_block_type data;
  long last_address, target_address;
  char *msg_txt = message_pointer;
  int bytes_written = 0;
  int total_length = strlen(message_pointer);
  
  assert(sizeof(header_block_type) == sizeof(data_block_type));
  assert(sizeof(header_block_type) == BLOCK_SIZE);
  
  if (from < 0 || to < 0 || !*message_pointer) {
    log("SYSERR: Mail system -- non-fatal error #5.");
    return;
  }
  memset((char *) &header, 0, sizeof(header));	/* clear the record */
  header.block_type = HEADER_BLOCK;
  header.header_data.next_block = LAST_BLOCK;
  header.header_data.from = from;
  header.header_data.to = to;
  header.header_data.vnum = vnum;
  header.header_data.mail_time = time(0);
  strncpy(header.txt, msg_txt, HEADER_BLOCK_DATASIZE);
  header.txt[HEADER_BLOCK_DATASIZE] = '\0';
  
  target_address = pop_free_list();	/* find next free block */
  index_mail(to, target_address);	/* add it to mail index in memory */
  write_to_file(&header, BLOCK_SIZE, target_address);
  
  if (strlen(msg_txt) <= HEADER_BLOCK_DATASIZE)
    return;			/* that was the whole message */
  
  bytes_written = HEADER_BLOCK_DATASIZE;
  msg_txt += HEADER_BLOCK_DATASIZE;	/* move pointer to next bit of text */
  
  /*
   * find the next block address, then rewrite the header to reflect where
   * the next block is.
   */
  last_address = target_address;
  target_address = pop_free_list();
  header.header_data.next_block = target_address;
  write_to_file(&header, BLOCK_SIZE, last_address);
  
  /* now write the current data block */
  memset((char *) &data, 0, sizeof(data));	/* clear the record */
  data.block_type = LAST_BLOCK;
  strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
  data.txt[DATA_BLOCK_DATASIZE] = '\0';
  write_to_file(&data, BLOCK_SIZE, target_address);
  bytes_written += strlen(data.txt);
  msg_txt += strlen(data.txt);
  
  /*
   * if, after 1 header block and 1 data block there is STILL part of the
   * message left to write to the file, keep writing the new data blocks and
   * rewriting the old data blocks to reflect where the next block is.  Yes,
   * this is kind of a hack, but if the block size is big enough it won't
   * matter anyway.  Hopefully, MUD players won't pour their life stories out
   * into the Mud Mail System anyway.
   * 
   * Note that the block_type data field in data blocks is either a number >=0,
   * meaning a link to the next block, or LAST_BLOCK flag (-2) meaning the
   * last block in the current message.  This works much like DOS' FAT.
   */

  while (bytes_written < total_length) {
    last_address = target_address;
    target_address = pop_free_list();
    
    /* rewrite the previous block to link it to the next */
    data.block_type = target_address;
    write_to_file(&data, BLOCK_SIZE, last_address);
    
    /* now write the next block, assuming it's the last.  */
    data.block_type = LAST_BLOCK;
    strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
    data.txt[DATA_BLOCK_DATASIZE] = '\0';
    write_to_file(&data, BLOCK_SIZE, target_address);
    
    bytes_written += strlen(data.txt);
    msg_txt += strlen(data.txt);
  }
}				/* store mail */




/* READ_DELETE */
/* read_delete takes 1 char pointer to the name of the person whose mail
you're retrieving.  It returns to you a char pointer to the message text.
The mail is then discarded from the file and the mail index. */

/*char *read_delete(long recipient)*/
char *read_delete(long recipient, int *obj_vnum)
     /* recipient is the name as it appears in the index.
	recipient_formatted is the name as it should appear on the mail
	header (i.e. the text handed to the player) */
{
  header_block_type header;
  data_block_type data;
  mail_index_type *mail_pointer, *prev_mail;
  position_list_type *position_pointer;
  long mail_address, following_block;
  char *message, buf[200];
  size_t string_size;
  
  if (recipient < 0) {
    log("SYSERR: Mail system -- non-fatal error #6.");
    return 0;
  }
  if (!(mail_pointer = find_char_in_index(recipient))) {
    log("SYSERR: Mail system -- post office spec_proc error?  Error #7.");
    return 0;
  }
  if (!(position_pointer = mail_pointer->list_start)) {
    log("SYSERR: Mail system -- non-fatal error #8.");
    return 0;
  }
  if (!(position_pointer->next)) {	/* just 1 entry in list. */
    mail_address = position_pointer->position;
    free(position_pointer);
    
    /* now free up the actual name entry */
    if (mail_index == mail_pointer) {	/* name is 1st in list */
      mail_index = mail_pointer->next;
      free(mail_pointer);
    } else {
      /* find entry before the one we're going to del */
      for (prev_mail = mail_index;
	   prev_mail->next != mail_pointer;
	   prev_mail = prev_mail->next);
      prev_mail->next = mail_pointer->next;
      free(mail_pointer);
    }
  } else {
    /* move to next-to-last record */
    while (position_pointer->next->next)
      position_pointer = position_pointer->next;
    mail_address = position_pointer->next->position;
    free(position_pointer->next);
    position_pointer->next = 0;
  }
  
  /* ok, now lets do some readin'! */
  read_from_file(&header, BLOCK_SIZE, mail_address);
  
  if (header.block_type != HEADER_BLOCK) {
    log("SYSERR: Oh dear.");
    no_mail = 1;
    log("SYSERR: Mail system disabled!  -- Error #9.");
    return 0;
  }
  strftime(buf1, 15, TIMEFMT_DATE, localtime(&header.header_data.mail_time));
  *obj_vnum = header.header_data.vnum;
  
  sprintf(buf, " * * * * &2FieryMUD Mail System&0 * * * *\r\n"
	  "Date: %s\r\n"
	  "  To: %s\r\n"
	  "From: %s\r\n\r\n", buf1, get_name_by_id(recipient),
	  get_name_by_id(header.header_data.from));
  
  string_size = (sizeof(char) * (strlen(buf) + strlen(header.txt) + 3));
  CREATE(message, char, string_size);
  strcpy(message, buf);
  strcat(message, header.txt);
  strcat(message, "@@0");
  message[string_size - 1] = '\0';
  following_block = header.header_data.next_block;
  
  /* mark the block as deleted */
  header.block_type = DELETED_BLOCK;
  write_to_file(&header, BLOCK_SIZE, mail_address);
  push_free_list(mail_address);
  
  while (following_block != LAST_BLOCK) {
    read_from_file(&data, BLOCK_SIZE, following_block);
    
    string_size = (sizeof(char) * (strlen(message) + strlen(data.txt) + 1));
    RECREATE(message, char, string_size);
    strcat(message, data.txt);
    message[string_size - 1] = '\0';
    mail_address = following_block;
    following_block = data.block_type;
    data.block_type = DELETED_BLOCK;
    write_to_file(&data, BLOCK_SIZE, mail_address);
    push_free_list(mail_address);
  }
  
  return message;
}


/*******************************************************************
 ** Below is the spec_proc for a postmaster using the above       **
 ** routines.  Written by Jeremy Elson (jelson@@server.cs.jhu.edu) **
 *******************************************************************/

SPECIAL(postmaster)
{
  if (!ch->desc || IS_NPC(ch))
    return 0;			/* so mobs don't get caught here */
  
  if (!(CMD_IS("mail") || CMD_IS("check") || CMD_IS("receive")))
    return 0;
  
  if (no_mail) {
    send_to_char("Sorry, the mail system is having technical difficulties.\r\n", ch);
    return 0;
  }
  
  if (CMD_IS("mail")) {
    postmaster_send_mail(ch, me, cmd, argument);
    return 1;
  } else if (CMD_IS("check")) {
    postmaster_check_mail(ch, me, cmd, argument);
    return 1;
  } else if (CMD_IS("receive")) {
    postmaster_receive_mail(ch, me, cmd, argument);
    return 1;
  } else
    return 0;
}


void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
			  int cmd, char *arg)
{
  long recipient;
  char buf[256];
  char buf2[256];
  int price = STAMP_PRICE;
  struct obj_data *obj;
  
  obj = NULL;
  
  if (GET_LEVEL(ch) < MIN_MAIL_LEVEL) {
    sprintf(buf, "$n tells you, 'Sorry, you have to be level %d to send mail!'",
	    MIN_MAIL_LEVEL);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  /*one_argument(arg, buf);*/
  two_arguments(arg, buf, buf2);
  
  if (!*buf) {			/* you'll get no argument from me! */
    act("$n tells you, 'You need to specify an addressee!'",
	FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  /* =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
     Code to let players know if another player has passed away and
     not generate any mail for them. - RSD 6/24/2006
     =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */
  if (strcasecmp(buf, "pergus") == 0) {
      act("$n tells you, 'I'm sorry, that character has passed away....'", FALSE, mailman, 0, ch, TO_VICT);
      act(RICK_SALA, FALSE, mailman, 0, ch, TO_VICT);
      return;
  }
  if (strcasecmp(buf, "daroowise") == 0) {
      act("$n tells you, 'I'm sorry, that character has passed away....'", FALSE, mailman, 0, ch, TO_VICT);
      act(RICK_SALA, FALSE, mailman, 0, ch, TO_VICT);
      return;
  }
  if (strcasecmp(buf, "ninmei") == 0) {
      act("$n tells you, 'I'm sorry, that character has passed away....'", FALSE, mailman, 0, ch, TO_VICT);
      act(RICK_SALA, FALSE, mailman, 0, ch, TO_VICT);
      return;
  }
  if (strcasecmp(buf, "brilan") == 0) {
      act("$n tells you, 'I'm sorry, that character has passed away....'", FALSE, mailman, 0, ch, TO_VICT);
      act(RICK_SALA, FALSE, mailman, 0, ch, TO_VICT);
      return;
  }

  if (*buf2 && (obj = find_obj_in_list(ch->carrying, find_vis_by_name(ch, buf2)))) {
    if (OBJ_FLAGGED(obj, ITEM_NODROP)) {
      act("You can't mail $p.  It's CURSED!", FALSE, ch, obj, obj, TO_CHAR);
      return;
    }
    if (OBJ_FLAGGED(obj, ITEM_NORENT)) {
      act("$n tells you, 'I'm not sending that!'", FALSE, mailman, 0, ch, TO_VICT);
      return;
    }
    price += STAMP_PRICE*.1;
    price += GET_OBJ_WEIGHT(obj)*100;
  } else if (*buf2) {
    cprintf(ch, "You don't seem to have a %s to mail.\r\n", buf2);
    return;
  }
  
  if (GET_CASH(ch) < price) {
    if (GET_LEVEL(ch) < 100) {
       sprintf(buf, "$n tells you, 'A stamp costs %d copper coins.'\r\n"
    	    "$n tells you, '...which I see you can't afford.'", price);
       act(buf, FALSE, mailman, 0, ch, TO_VICT);
       return;
    } else {
       price = 0;
    }
  }
  
  if (GET_LEVEL(ch) >= 100)
     price = 0;

  if ((recipient = get_id_by_name(buf)) < 0) {
    act("$n tells you, 'No one by that name is registered here!'",
	FALSE, mailman, 0, ch, TO_VICT);
    return;
  }

  if (obj != NULL) {
    ch->desc->mail_vnum = GET_OBJ_VNUM(obj);
    act("$n takes $p and prepares it for packaging.", FALSE, mailman, obj, ch, TO_VICT);
    extract_obj(obj);
  } else
    ch->desc->mail_vnum = NOTHING;
  
  act("$n starts to write some mail.", TRUE, ch, 0, 0, TO_ROOM);

  if (GET_LEVEL(ch) < 100)
     sprintf(buf, "$n tells you, 'I'll take %d coins for the stamp.'\r\n"
	  "$n tells you, 'Write your message, (/s saves /h for help)'",
	  price);
  else
     sprintf(buf, "$n tells you, 'I refuse to take money from a deity.  This stamp is on me.'\r\n"
                  "$n tells you, 'Write your message, (/s saves /h for help)'");
  
  act(buf, FALSE, mailman, 0, ch, TO_VICT);
  money_convert(ch, price);
  GET_COPPER(ch) -= price;
  SET_FLAG(PLR_FLAGS(ch), PLR_MAILING);
  SET_FLAG(PLR_FLAGS(ch), PLR_WRITING);
  
  mail_write(ch->desc, NULL, MAX_MAIL_SIZE, recipient);
}


void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
			   int cmd, char *arg)
{
  char buf[256];
  
  if (has_mail(GET_IDNUM(ch)))
    sprintf(buf, "$n tells you, 'You have mail waiting.'");
  else
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
  act(buf, FALSE, mailman, 0, ch, TO_VICT);
}


void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
			     int cmd, char *arg)
{
  char buf[256];
  /*struct obj_data *obj;*/
  struct obj_data *obj, *mail_obj;
  int obj_vnum = NOTHING;
  
  if (!has_mail(GET_IDNUM(ch))) {
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  while (has_mail(GET_IDNUM(ch))) {
    obj = create_obj();
    obj->item_number = NOTHING;
    obj->name = strdup("mail paper letter");
    obj->short_description = strdup("a piece of mail");
    obj->description = strdup("Someone has left a piece of mail here.");
    
    GET_OBJ_TYPE(obj) = ITEM_NOTE;
    GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE | ITEM_WEAR_HOLD;
    GET_OBJ_WEIGHT(obj) = 1;
    GET_OBJ_COST(obj) = 30;
    /* GET_OBJ_RENT(obj) = 10; */
    obj->action_description = read_delete(GET_IDNUM(ch), &obj_vnum);
    
    if (obj->action_description == NULL)
      obj->action_description =
	strdup("Mail system error - please report.  Error #11.\r\n");
    
    obj_to_char(obj, ch);
    
    if (obj_vnum != NOTHING && real_object(obj_vnum) != NOTHING) {
      mail_obj = read_object(real_object(obj_vnum), REAL);
      obj_to_char(mail_obj, ch);
      act("$n gives you $p, which was attached to your mail.", FALSE, mailman, mail_obj, ch, TO_VICT);
      act("$N gives $n $p, which was attached to $S mail.", FALSE, ch, mail_obj, mailman, TO_ROOM);
    }
    
    act("$n gives you a piece of mail.", FALSE, mailman, 0, ch, TO_VICT);
    act("$N gives $n a piece of mail.", FALSE, ch, 0, mailman, TO_ROOM);
  }
}

void free_mail_index(void) {
  mail_index_type *next_mail;
  position_list_type *next_pos;

  extern mail_index_type *mail_index;
  extern position_list_type *free_list;

  while (mail_index) {
    next_mail = mail_index->next;
    while (mail_index->list_start) {
      next_pos = mail_index->list_start->next;
      free(mail_index->list_start);
      mail_index->list_start = next_pos;
    }
    free(mail_index);
    mail_index = next_mail;
  }

  while (free_list) {
    next_pos = free_list->next;
    free(free_list);
    free_list = next_pos;
  }
}


/***************************************************************************
 * $Log: mail.c,v $
 * Revision 1.28  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.27  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.26  2008/08/30 20:42:50  myc
 * Ending all communication with a color reset.
 *
 * Revision 1.25  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.24  2008/06/05 02:07:43  myc
 * Changed object flags to use flagvectors and removed object's
 * cost_per_day field.
 *
 * Revision 1.23  2008/04/20 18:39:39  jps
 * Fix postmaster grammer
 *
 * Revision 1.22  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.21  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.20  2008/03/05 03:03:54  myc
 * Now depending on players.h for get_player_id or something.
 *
 * Revision 1.19  2008/02/16 20:31:32  myc
 * Adding function to free mail index at program termination.
 *
 * Revision 1.18  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.17  2008/01/27 01:42:03  jps
 * Fix grammar when informing player of cursed objects.
 *
 * Revision 1.16  2007/07/24 23:02:52  jps
 * Minor typo fix.
 *
 * Revision 1.15  2007/04/04 13:31:02  jps
 * Add year to log timestamps and other dates.
 *
 * Revision 1.14  2006/11/24 07:47:55  jps
 * Don't allow mailing of !RENT items
 *
 * Revision 1.13  2006/06/24 18:44:07  rsd
 * Corrected the Date of Rick's death..
 *
 * Revision 1.12  2006/06/24 17:41:22  rsd
 * added code to not send mail to players who have passed
 * away.
 *
 * Revision 1.11  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.10  2001/05/03 01:45:14  dce
 * Mail should no longer eat objects unless a player
 * aborts a mail message. Also players can no longer
 * mail a cursed item.
 *
 * Revision 1.9  2000/11/23 02:21:19  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.8  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.7  1999/04/30 19:12:56  dce
 * Free mail for gods
 *
 * Revision 1.6  1999/04/09 20:52:29  dce
 * Adjusted rates.
 *
 * Revision 1.5  1999/04/09 04:14:32  dce
 * Allow any type of coins.
 *
 * Revision 1.4  1999/04/09 03:19:41  dce
 * Fixed a dumb mistake.
 *
 * Revision 1.3  1999/04/08 16:56:24  dce
 * Mail is back!
 *
 * Revision 1.2  1999/01/31 16:42:27  mud
 * Indented file
 * Replaced references to hubis with Fiery
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.28
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.27 2009/03/03 19:43:44 myc Exp jps $
d203 1
a203 1
  log(buf);
d210 1
a210 1
  log(buf);
d658 4
@


1.27
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.26 2008/08/30 20:42:50 myc Exp myc $
d35 1
d658 3
@


1.26
log
@Ending all communication with a color reset.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.25 2008/08/14 09:45:22 jps Exp myc $
d508 1
a508 1
  if (*buf2 && (obj = get_obj_in_list_vis(ch, buf2, ch->carrying))) {
d510 1
a510 2
      sprintf(buf, "You can't mail $p.  It's CURSED!");
      act(buf, FALSE, ch, obj, obj, TO_CHAR);
d520 1
a520 2
    sprintf(buf, "You don't seem to have a %s to mail.\r\n", buf2);
    send_to_char(buf, ch);
d657 3
@


1.25
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.24 2008/06/05 02:07:43 myc Exp jps $
d395 1
a395 1
  string_size = (sizeof(char) * (strlen(buf) + strlen(header.txt) + 1));
d399 1
d659 3
@


1.24
log
@Changed object flags to use flagvectors and removed object's
cost_per_day field.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.23 2008/04/20 18:39:39 jps Exp myc $
d34 1
d658 4
@


1.23
log
@Fix postmaster grammer
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.22 2008/03/28 17:54:53 myc Exp jps $
d507 1
a507 1
    if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d512 1
a512 1
    if (IS_OBJ_STAT(obj, ITEM_NORENT)) {
d608 1
a608 2
    GET_OBJ_RENT(obj) = 10;
    /*obj->action_description = read_delete(GET_IDNUM(ch));*/
d657 3
@


1.22
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.21 2008/03/22 03:22:38 myc Exp myc $
d558 1
a558 1
     sprintf(buf, "$n tells you, 'I refuse to take money from a deity, this stamp is on me.'\r\n"
d658 4
@


1.21
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.20 2008/03/05 03:03:54 myc Exp myc $
d564 2
a565 1
  SET_BIT(PLR_FLAGS(ch), PLR_MAILING | PLR_WRITING);
d600 3
a602 3
    obj->name = str_dup("mail paper letter");
    obj->short_description = str_dup("a piece of mail");
    obj->description = str_dup("Someone has left a piece of mail here.");
d614 1
a614 1
	str_dup("Mail system error - please report.  Error #11.\r\n");
d658 6
@


1.20
log
@Now depending on players.h for get_player_id or something.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.19 2008/02/16 20:31:32 myc Exp myc $
d566 1
a566 4
  ch->desc->mail_to = recipient;
  ch->desc->str = (char **) malloc(sizeof(char *));
  *(ch->desc->str) = NULL;
  ch->desc->max_str = MAX_MAIL_SIZE;
d657 3
@


1.19
log
@Adding function to free mail index at program termination.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.18 2008/01/29 21:02:31 myc Exp myc $
d33 1
d660 3
@


1.18
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.17 2008/01/27 01:42:03 jps Exp myc $
d631 26
d659 4
@


1.17
log
@Fix grammar when informing player of cursed objects.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.16 2007/07/24 23:02:52 jps Exp jps $
a51 2
extern struct room_data *world;
extern struct index_data *mob_index;
a462 1
  extern struct index_data *obj_index;
d633 3
@


1.16
log
@Minor typo fix.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.15 2007/04/04 13:31:02 jps Exp jps $
d510 1
a510 1
      sprintf(buf, "You can't mail $p, it's CURSED!");
d636 3
@


1.15
log
@Add year to log timestamps and other dates.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.14 2006/11/24 07:47:55 jps Exp jps $
d185 1
a185 1
    log("Mail file non-existant... creating new file.");
d636 3
@


1.14
log
@Don't allow mailing of !RENT items
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.13 2006/06/24 18:44:07 rsd Exp jps $
d337 1
a337 1
  char *message, *tmstr, buf[200];
d386 1
a386 2
  tmstr = asctime(localtime(&header.header_data.mail_time));
  *(tmstr + strlen(tmstr) - 1) = '\0';
d392 1
a392 1
	  "From: %s\r\n\r\n", tmstr, get_name_by_id(recipient),
d636 3
@


1.13
log
@Corrected the Date of Rick's death..
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.12 2006/06/24 17:41:22 rsd Exp $
a508 7
  /*if (GET_GOLD(ch) < STAMP_PRICE) {
    sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
    "$n tells you, '...which I see you can't afford.'", STAMP_PRICE);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
    }*/
  
d515 4
d637 3
@


1.12
log
@added code to not send mail to players who have passed
away.
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.11 2002/09/13 02:32:10 jjl Exp $
d38 1
a38 1
"=~=~=  passed away on June 22, 2006.                                =~=~=\r\n"
d640 4
@


1.11
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: mail.c,v 1.10 2001/05/03 01:45:14 dce Exp $
d34 10
d484 25
d640 3
@


1.10
log
@Mail should no longer eat objects unless a player
aborts a mail message. Also players can no longer
mail a cursed item.
@
text
@d1 3
a3 1
// $Id: mail.c,v 1.9 2000/11/23 02:21:19 rsd Exp $
d603 37
a639 30
// $Log: mail.c,v $
// Revision 1.9  2000/11/23 02:21:19  rsd
// Altered comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.8  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.7  1999/04/30 19:12:56  dce
// Free mail for gods
//
// Revision 1.6  1999/04/09 20:52:29  dce
// Adjusted rates.
//
// Revision 1.5  1999/04/09 04:14:32  dce
// Allow any type of coins.
//
// Revision 1.4  1999/04/09 03:19:41  dce
// Fixed a dumb mistake.
//
// Revision 1.3  1999/04/08 16:56:24  dce
// Mail is back!
//
// Revision 1.2  1999/01/31 16:42:27  mud
// Indented file
// Replaced references to hubis with Fiery
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.9
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: mail.c,v 1.8 1999/09/05 07:00:39 jimmy Exp $
d480 5
a484 1
    act("$n takes $p and prepares it for packaging.", FALSE, mailman, obj, ch, TO_VICT);
d487 4
d507 6
d515 1
a519 5
  if ((recipient = get_id_by_name(buf)) < 0) {
    act("$n tells you, 'No one by that name is registered here!'",
	FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
d602 4
@


1.8
log
@Added RCS Log and Id strings to each source file
@
text
@d1 3
a3 3
// $Id$
/* ************************************************************************
 *   File: mail.c                                        Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d12 1
a12 1
 ************************************************************************ */
d591 26
a616 3


// $Log$
@


1.7
log
@Free mail for gods
@
text
@d1 1
d591 1
@


1.6
log
@Adjusted rates.
@
text
@d483 8
a490 4
    sprintf(buf, "$n tells you, 'A stamp costs %d copper coins.'\r\n"
 	    "$n tells you, '...which I see you can't afford.'", price);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
d493 3
d508 3
a510 1
  sprintf(buf, "$n tells you, 'I'll take %d coins for the stamp.'\r\n"
d513 3
@


1.5
log
@Allow any type of coins.
@
text
@d479 1
a479 1
    price += GET_OBJ_WEIGHT(obj)*10;
d483 1
a483 1
    sprintf(buf, "$n tells you, 'A stamp costs %d silver coins.'\r\n"
@


1.4
log
@Fixed a dumb mistake.
@
text
@d36 1
d482 1
a482 1
  if (GET_SILVER(ch) < price) {
d506 2
a507 1
  GET_SILVER(ch) -= price;
@


1.3
log
@Mail is back!
@
text
@d505 1
a505 1
  GET_GOLD(ch) -= price;
@


1.2
log
@Indented file
Replaced references to hubis with Fiery
@
text
@d481 2
a482 2
  if (GET_GOLD(ch) < price) {
    sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
@


1.1
log
@Initial revision
@
text
@d2 8
a9 8
*   File: mail.c                                        Part of CircleMUD *
*  Usage: Internal funcs and player spec-procs of mud-mail system         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d12 2
a13 2

Written by Jeremy Elson (jelson@@cs.jhu.edu)
d32 1
a32 1
			  int cmd, char *arg);
d34 1
a34 1
			  int cmd, char *arg);
d49 1
a49 1

d62 1
a62 1

d77 1
a77 1

d83 1
a83 1

d92 1
a92 1

d94 1
a94 1

d102 1
a102 1

d114 1
a114 1

d116 1
a116 1

d135 1
a135 1

d145 1
a145 1

d167 1
a167 1

d182 1
a182 1

d224 1
a224 1

d227 1
a227 1

d241 1
a241 1

d245 1
a245 1

d248 1
a248 1

d251 1
a251 1

d260 1
a260 1

d269 1
a269 1

d286 1
a286 1

d290 1
a290 1

d296 1
a296 1

d312 3
a314 3
/* recipient is the name as it appears in the index.
   recipient_formatted is the name as it should appear on the mail
   header (i.e. the text handed to the player) */
d323 1
a323 1

d339 1
a339 1

d360 1
a360 1

d363 1
a363 1

d373 2
a374 2

  sprintf(buf, " * * * * &2Hubis Mail System&0 * * * *\r\n"
d379 1
a379 1

d386 1
a386 1

d391 1
a391 1

d394 1
a394 1

d405 1
a405 1

d410 4
a413 4
/*****************************************************************
** Below is the spec_proc for a postmaster using the above       **
** routines.  Written by Jeremy Elson (jelson@@server.cs.jhu.edu) **
*****************************************************************/
d419 1
a419 1

d422 1
a422 1

d427 1
a427 1

d451 1
a451 1
 
d453 1
a453 1

d462 1
a462 1

d470 1
a470 1
	    "$n tells you, '...which I see you can't afford.'", STAMP_PRICE);
d473 2
a474 2
  }*/

d476 7
a482 7
     act("$n takes $p and prepares it for packaging.", FALSE, mailman, obj, ch, TO_VICT);
     price += STAMP_PRICE*.1;
     price += GET_OBJ_WEIGHT(obj)*10;
   }
     
   if (GET_GOLD(ch) < price) {
     sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
d484 10
a493 10
     act(buf, FALSE, mailman, 0, ch, TO_VICT);
     return;
   }
 
   if (obj != NULL) {
     ch->desc->mail_vnum = GET_OBJ_VNUM(obj);
     extract_obj(obj);
   } else
     ch->desc->mail_vnum = NOTHING;

d501 1
a501 1
      "$n tells you, 'Write your message, (/s saves /h for help)'",
d503 1
a503 1

d507 1
a507 1

d516 1
a516 1
			  int cmd, char *arg)
d519 1
a519 1

d529 1
a529 1
			  int cmd, char *arg)
d535 1
a535 1

d547 1
a547 1

d554 2
a555 2
	obj->action_description = read_delete(GET_IDNUM(ch), &obj_vnum);

d559 1
a559 1

d561 8
a568 8

	if (obj_vnum != NOTHING && real_object(obj_vnum) != NOTHING) {
       mail_obj = read_object(real_object(obj_vnum), REAL);
       obj_to_char(mail_obj, ch);
       act("$n gives you $p, which was attached to your mail.", FALSE, mailman, mail_obj, ch, TO_VICT);
       act("$N gives $n $p, which was attached to $S mail.", FALSE, ch, mail_obj, mailman, TO_ROOM);
     }

d573 3
@
