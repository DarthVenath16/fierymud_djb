head	1.283;
access;
symbols;
locks; strict;
comment	@ * @;


1.283
date	2012.01.25.18.20.31;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	2011.08.06.15.46.10;	author rsd;	state Exp;
branches;
next	1.281;

1.281
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.280;

1.280
date	2010.07.02.14.09.16;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	2010.06.20.19.53.47;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	2010.06.05.18.58.19;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	2010.04.25.22.57.16;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	2010.04.25.22.13.38;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	2009.07.18.01.17.23;	author myc;	state Exp;
branches;
next	1.273;

1.273
date	2009.06.20.23.14.13;	author myc;	state Exp;
branches;
next	1.272;

1.272
date	2009.06.10.18.40.33;	author myc;	state Exp;
branches;
next	1.271;

1.271
date	2009.06.09.21.48.21;	author myc;	state Exp;
branches;
next	1.270;

1.270
date	2009.06.09.19.44.45;	author myc;	state Exp;
branches;
next	1.269;

1.269
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.268;

1.268
date	2009.03.20.16.00.38;	author jps;	state Exp;
branches;
next	1.267;

1.267
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.266;

1.266
date	2009.03.19.23.09.50;	author jps;	state Exp;
branches;
next	1.265;

1.265
date	2009.03.19.22.47.41;	author jps;	state Exp;
branches;
next	1.264;

1.264
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.263;

1.263
date	2009.03.15.08.12.53;	author jps;	state Exp;
branches;
next	1.262;

1.262
date	2009.03.13.04.40.10;	author jps;	state Exp;
branches;
next	1.261;

1.261
date	2009.03.11.21.13.13;	author jps;	state Exp;
branches;
next	1.260;

1.260
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.259;

1.259
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.258;

1.258
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.257;

1.257
date	2009.03.08.21.43.27;	author jps;	state Exp;
branches;
next	1.256;

1.256
date	2009.03.07.22.30.52;	author jps;	state Exp;
branches;
next	1.255;

1.255
date	2009.03.07.08.18.33;	author jps;	state Exp;
branches;
next	1.254;

1.254
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.253;

1.253
date	2009.02.16.14.21.04;	author myc;	state Exp;
branches;
next	1.252;

1.252
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.251;

1.251
date	2009.01.16.23.36.34;	author myc;	state Exp;
branches;
next	1.250;

1.250
date	2008.10.31.19.48.33;	author myc;	state Exp;
branches;
next	1.249;

1.249
date	2008.09.26.18.37.49;	author jps;	state Exp;
branches;
next	1.248;

1.248
date	2008.09.26.09.23.25;	author jps;	state Exp;
branches;
next	1.247;

1.247
date	2008.09.26.04.59.02;	author jps;	state Exp;
branches;
next	1.246;

1.246
date	2008.09.25.15.19.37;	author jps;	state Exp;
branches;
next	1.245;

1.245
date	2008.09.21.21.49.59;	author jps;	state Exp;
branches;
next	1.244;

1.244
date	2008.09.21.21.23.32;	author jps;	state Exp;
branches;
next	1.243;

1.243
date	2008.09.21.21.16.27;	author jps;	state Exp;
branches;
next	1.242;

1.242
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.241;

1.241
date	2008.09.20.07.44.21;	author jps;	state Exp;
branches;
next	1.240;

1.240
date	2008.09.20.07.26.52;	author jps;	state Exp;
branches;
next	1.239;

1.239
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.238;

1.238
date	2008.09.14.04.34.30;	author jps;	state Exp;
branches;
next	1.237;

1.237
date	2008.09.14.03.53.01;	author jps;	state Exp;
branches;
next	1.236;

1.236
date	2008.09.14.03.02.35;	author jps;	state Exp;
branches;
next	1.235;

1.235
date	2008.09.14.02.08.01;	author jps;	state Exp;
branches;
next	1.234;

1.234
date	2008.09.06.19.09.42;	author jps;	state Exp;
branches;
next	1.233;

1.233
date	2008.09.02.07.16.00;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2008.09.02.06.52.30;	author jps;	state Exp;
branches;
next	1.231;

1.231
date	2008.09.01.23.47.49;	author jps;	state Exp;
branches;
next	1.230;

1.230
date	2008.09.01.18.29.29;	author jps;	state Exp;
branches;
next	1.229;

1.229
date	2008.08.31.20.53.44;	author jps;	state Exp;
branches;
next	1.228;

1.228
date	2008.08.30.22.44.44;	author myc;	state Exp;
branches;
next	1.227;

1.227
date	2008.08.30.20.25.38;	author jps;	state Exp;
branches;
next	1.226;

1.226
date	2008.08.30.18.20.53;	author myc;	state Exp;
branches;
next	1.225;

1.225
date	2008.08.30.01.31.51;	author myc;	state Exp;
branches;
next	1.224;

1.224
date	2008.08.24.19.29.11;	author jps;	state Exp;
branches;
next	1.223;

1.223
date	2008.08.23.13.17.07;	author jps;	state Exp;
branches;
next	1.222;

1.222
date	2008.08.21.08.05.56;	author jps;	state Exp;
branches;
next	1.221;

1.221
date	2008.08.16.17.24.14;	author jps;	state Exp;
branches;
next	1.220;

1.220
date	2008.08.09.18.16.21;	author jps;	state Exp;
branches;
next	1.219;

1.219
date	2008.07.29.17.52.47;	author jps;	state Exp;
branches;
next	1.218;

1.218
date	2008.06.07.19.06.46;	author myc;	state Exp;
branches;
next	1.217;

1.217
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.216;

1.216
date	2008.05.25.21.00.49;	author myc;	state Exp;
branches;
next	1.215;

1.215
date	2008.05.19.05.48.09;	author jps;	state Exp;
branches;
next	1.214;

1.214
date	2008.05.18.20.46.02;	author jps;	state Exp;
branches;
next	1.213;

1.213
date	2008.05.18.20.15.37;	author jps;	state Exp;
branches;
next	1.212;

1.212
date	2008.05.18.17.59.24;	author jps;	state Exp;
branches;
next	1.211;

1.211
date	2008.05.18.05.18.06;	author jps;	state Exp;
branches;
next	1.210;

1.210
date	2008.05.17.22.03.01;	author jps;	state Exp;
branches;
next	1.209;

1.209
date	2008.05.17.04.32.25;	author jps;	state Exp;
branches;
next	1.208;

1.208
date	2008.05.14.05.11.51;	author jps;	state Exp;
branches;
next	1.207;

1.207
date	2008.05.12.01.10.57;	author jps;	state Exp;
branches;
next	1.206;

1.206
date	2008.05.12.00.42.30;	author jps;	state Exp;
branches;
next	1.205;

1.205
date	2008.05.11.22.31.58;	author jps;	state Exp;
branches;
next	1.204;

1.204
date	2008.05.11.06.14.05;	author jps;	state Exp;
branches;
next	1.203;

1.203
date	2008.05.11.05.57.56;	author jps;	state Exp;
branches;
next	1.202;

1.202
date	2008.04.19.21.01.56;	author jps;	state Exp;
branches;
next	1.201;

1.201
date	2008.04.18.00.31.16;	author jps;	state Exp;
branches;
next	1.200;

1.200
date	2008.04.16.01.53.23;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2008.04.14.02.32.07;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2008.04.13.20.53.25;	author jps;	state Exp;
branches;
next	1.197;

1.197
date	2008.04.13.10.23.34;	author jps;	state Exp;
branches;
next	1.196;

1.196
date	2008.04.13.00.57.53;	author jps;	state Exp;
branches;
next	1.195;

1.195
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.194;

1.194
date	2008.04.05.06.35.03;	author myc;	state Exp;
branches;
next	1.193;

1.193
date	2008.04.04.20.47.43;	author jps;	state Exp;
branches;
next	1.192;

1.192
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.191;

1.191
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.190;

1.190
date	2008.04.02.17.41.56;	author myc;	state Exp;
branches;
next	1.189;

1.189
date	2008.04.02.05.36.19;	author myc;	state Exp;
branches;
next	1.188;

1.188
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.187;

1.187
date	2008.03.30.16.05.08;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2008.03.30.15.37.36;	author jps;	state Exp;
branches;
next	1.185;

1.185
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.184;

1.184
date	2008.03.27.17.29.51;	author jps;	state Exp;
branches;
next	1.183;

1.183
date	2008.03.27.00.20.35;	author jps;	state Exp;
branches;
next	1.182;

1.182
date	2008.03.26.23.11.17;	author jps;	state Exp;
branches;
next	1.181;

1.181
date	2008.03.26.22.14.01;	author jps;	state Exp;
branches;
next	1.180;

1.180
date	2008.03.26.18.12.32;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2008.03.26.16.44.36;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2008.03.24.08.44.03;	author jps;	state Exp;
branches;
next	1.177;

1.177
date	2008.03.16.00.21.36;	author jps;	state Exp;
branches;
next	1.176;

1.176
date	2008.03.11.19.50.55;	author myc;	state Exp;
branches;
next	1.175;

1.175
date	2008.03.10.20.46.55;	author myc;	state Exp;
branches;
next	1.174;

1.174
date	2008.03.09.09.00.20;	author jps;	state Exp;
branches;
next	1.173;

1.173
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.172;

1.172
date	2008.03.09.02.07.48;	author jps;	state Exp;
branches;
next	1.171;

1.171
date	2008.03.09.01.55.01;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2008.03.08.23.51.22;	author jps;	state Exp;
branches;
next	1.169;

1.169
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.168;

1.168
date	2008.03.06.05.11.51;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.166;

1.166
date	2008.02.23.01.03.54;	author myc;	state Exp;
branches;
next	1.165;

1.165
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.164;

1.164
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.163;

1.163
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.162;

1.162
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.161;

1.161
date	2008.02.08.14.13.25;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2008.02.06.03.45.08;	author myc;	state Exp;
branches;
next	1.159;

1.159
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2008.01.29.16.51.12;	author myc;	state Exp;
branches;
next	1.157;

1.157
date	2008.01.28.03.05.33;	author jps;	state Exp;
branches;
next	1.156;

1.156
date	2008.01.28.00.46.05;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.154;

1.154
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2008.01.27.12.12.40;	author jps;	state Exp;
branches;
next	1.152;

1.152
date	2008.01.27.02.25.25;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2008.01.26.12.28.32;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.25.21.05.45;	author myc;	state Exp;
branches;
next	1.149;

1.149
date	2008.01.23.05.31.24;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.16.04.12.00;	author myc;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.14.21.29.06;	author myc;	state Exp;
branches;
next	1.146;

1.146
date	2008.01.13.23.06.04;	author myc;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.12.19.08.14;	author myc;	state Exp;
branches;
next	1.144;

1.144
date	2008.01.10.23.12.07;	author myc;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.10.06.47.49;	author myc;	state Exp;
branches;
next	1.142;

1.142
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.141;

1.141
date	2008.01.06.23.50.47;	author jps;	state Exp;
branches;
next	1.140;

1.140
date	2008.01.06.17.34.15;	author jps;	state Exp;
branches;
next	1.139;

1.139
date	2007.12.23.20.42.21;	author myc;	state Exp;
branches;
next	1.138;

1.138
date	2007.12.23.20.36.54;	author myc;	state Exp;
branches;
next	1.137;

1.137
date	2007.12.09.03.30.55;	author jps;	state Exp;
branches;
next	1.136;

1.136
date	2007.10.27.18.56.26;	author myc;	state Exp;
branches;
next	1.135;

1.135
date	2007.10.25.20.38.55;	author myc;	state Exp;
branches;
next	1.134;

1.134
date	2007.10.13.20.56.00;	author myc;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.13.20.13.37;	author myc;	state Exp;
branches;
next	1.132;

1.132
date	2007.10.04.16.20.24;	author myc;	state Exp;
branches;
next	1.131;

1.131
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.130;

1.130
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.129;

1.129
date	2007.09.20.09.15.14;	author jps;	state Exp;
branches;
next	1.128;

1.128
date	2007.09.15.15.36.48;	author myc;	state Exp;
branches;
next	1.127;

1.127
date	2007.09.15.05.03.46;	author myc;	state Exp;
branches;
next	1.126;

1.126
date	2007.09.08.22.37.42;	author jps;	state Exp;
branches;
next	1.125;

1.125
date	2007.09.03.23.49.40;	author jps;	state Exp;
branches;
next	1.124;

1.124
date	2007.08.26.21.10.42;	author jps;	state Exp;
branches;
next	1.123;

1.123
date	2007.08.23.01.40.10;	author jps;	state Exp;
branches;
next	1.122;

1.122
date	2007.08.22.22.47.43;	author jps;	state Exp;
branches;
next	1.121;

1.121
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.120;

1.120
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.119;

1.119
date	2007.08.04.21.13.22;	author myc;	state Exp;
branches;
next	1.118;

1.118
date	2007.08.04.14.40.35;	author myc;	state Exp;
branches;
next	1.117;

1.117
date	2007.08.04.01.15.50;	author jps;	state Exp;
branches;
next	1.116;

1.116
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.115;

1.115
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.114;

1.114
date	2007.08.02.01.04.10;	author myc;	state Exp;
branches;
next	1.113;

1.113
date	2007.08.01.02.10.16;	author jps;	state Exp;
branches;
next	1.112;

1.112
date	2007.07.18.23.54.07;	author jps;	state Exp;
branches;
next	1.111;

1.111
date	2007.07.18.21.04.26;	author jps;	state Exp;
branches;
next	1.110;

1.110
date	2007.07.18.16.47.37;	author jps;	state Exp;
branches;
next	1.109;

1.109
date	2007.07.14.04.17.35;	author jps;	state Exp;
branches;
next	1.108;

1.108
date	2007.06.24.23.55.25;	author myc;	state Exp;
branches;
next	1.107;

1.107
date	2007.06.15.00.47.05;	author myc;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.07.23.53.38;	author myc;	state Exp;
branches;
next	1.105;

1.105
date	2007.06.03.03.46.27;	author jps;	state Exp;
branches;
next	1.104;

1.104
date	2007.05.11.20.13.28;	author myc;	state Exp;
branches;
next	1.103;

1.103
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.102;

1.102
date	2007.04.18.00.37.17;	author myc;	state Exp;
branches;
next	1.101;

1.101
date	2007.04.11.05.47.40;	author jps;	state Exp;
branches;
next	1.100;

1.100
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.99;

1.99
date	2007.02.20.17.16.27;	author myc;	state Exp;
branches;
next	1.98;

1.98
date	2007.02.14.03.54.53;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2007.02.08.01.30.00;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2006.11.20.06.50.59;	author jps;	state Exp;
branches;
next	1.95;

1.95
date	2006.11.20.06.44.26;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2006.11.18.21.00.28;	author jps;	state Exp;
branches;
next	1.93;

1.93
date	2006.11.18.07.03.30;	author jps;	state Exp;
branches;
next	1.92;

1.92
date	2006.11.13.15.54.22;	author jps;	state Exp;
branches;
next	1.91;

1.91
date	2006.11.08.09.16.04;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2006.07.20.07.40.22;	author cjd;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.04.02.41.19;	author jjl;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.02.17.42.50;	author jjl;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.19.05.07.16;	author jjl;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.25.05.06.59;	author jjl;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.20.15.06.03;	author rls;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.20.12.57.37;	author rls;	state Exp;
branches;
next	1.83;

1.83
date	2003.02.01.19.59.36;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2003.01.04.08.51.09;	author jjl;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.30.01.10.52;	author jjl;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.15.04.53.08;	author jjl;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.78;

1.78
date	2002.07.24.04.11.23;	author rls;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.09.13.52.41;	author dce;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.07.01.03.58;	author rls;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.06.01.02.13;	author dce;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.06.00.34.33;	author rls;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.05.01.16.05;	author dce;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.24.03.16.48;	author rls;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.23.00.21.17;	author rls;	state Exp;
branches;
next	1.70;

1.70
date	2002.03.30.19.20.14;	author dce;	state Exp;
branches;
next	1.69;

1.69
date	2002.03.30.13.33.32;	author dce;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.27.02.25.04;	author dce;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.15.02.45.14;	author dce;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.18.02.26.19;	author dce;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.14.02.07.33;	author dce;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.13.23.27.11;	author dce;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.11.23.49.39;	author dce;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.11.02.28.31;	author dce;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.14.03.33.48;	author dce;	state Exp;
branches;
next	1.60;

1.60
date	2001.12.14.03.27.46;	author dce;	state Exp;
branches;
next	1.59;

1.59
date	2001.12.14.03.20.45;	author dce;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.13.02.06.32;	author dce;	state Exp;
branches;
next	1.57;

1.57
date	2001.12.12.02.45.03;	author dce;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.05.18.03.40;	author rjd;	state Exp;
branches;
next	1.55;

1.55
date	2001.04.06.03.25.25;	author dce;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.25.12.44.50;	author dce;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.10.18.45.33;	author dce;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.09.03.05.21;	author dce;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.07.01.45.18;	author dce;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.24.04.04.33;	author dce;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.28.01.22.42;	author mtp;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.27.08.12.52;	author mtp;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.21.18.33.41;	author rsd;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.17.01.47.42;	author mtp;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.13.03.23.23;	author rsd;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.13.03.08.30;	author rsd;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.10.00.28.04;	author mtp;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.10.00.22.30;	author mtp;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.01.19.52.46;	author rsd;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.17.00.54.12;	author rsd;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.14.00.53.27;	author rsd;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.05.01.24.43;	author rsd;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.25.03.14.19;	author cso;	state Exp;
branches;
next	1.36;

1.36
date	99.12.10.22.13.45;	author jimmy;	state Exp;
branches;
next	1.35;

1.35
date	99.12.06.10.46.06;	author jimmy;	state Exp;
branches;
next	1.34;

1.34
date	99.11.28.23.21.22;	author cso;	state Exp;
branches;
next	1.33;

1.33
date	99.11.28.19.36.58;	author jimmy;	state Exp;
branches;
next	1.32;

1.32
date	99.11.23.15.48.23;	author jimmy;	state Exp;
branches;
next	1.31;

1.31
date	99.10.30.15.35.19;	author rsd;	state Exp;
branches;
next	1.30;

1.30
date	99.09.16.01.15.11;	author dce;	state Exp;
branches;
next	1.29;

1.29
date	99.09.08.07.06.03;	author jimmy;	state Exp;
branches;
next	1.28;

1.28
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.27;

1.27
date	99.08.29.17.48.53;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	99.08.14.22.55.36;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.24;

1.24
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.23;

1.23
date	99.07.25.05.40.18;	author jimmy;	state Exp;
branches;
next	1.22;

1.22
date	99.07.24.02.55.05;	author dce;	state Exp;
branches;
next	1.21;

1.21
date	99.07.23.15.01.50;	author dce;	state Exp;
branches;
next	1.20;

1.20
date	99.07.15.03.27.34;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	99.07.14.19.24.03;	author jimmy;	state Exp;
branches;
next	1.18;

1.18
date	99.07.07.15.46.44;	author jimmy;	state Exp;
branches;
next	1.17;

1.17
date	99.07.02.19.23.18;	author jimmy;	state Exp;
branches;
next	1.16;

1.16
date	99.06.11.16.56.55;	author jimmy;	state Exp;
branches;
next	1.15;

1.15
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.05.02.16.20.32;	author dce;	state Exp;
branches;
next	1.13;

1.13
date	99.04.08.04.26.36;	author dce;	state Exp;
branches;
next	1.12;

1.12
date	99.03.23.16.07.04;	author dce;	state Exp;
branches;
next	1.11;

1.11
date	99.03.21.21.49.37;	author dce;	state Exp;
branches;
next	1.10;

1.10
date	99.03.10.19.12.17;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.03.10.00.03.37;	author dce;	state Exp;
branches;
next	1.8;

1.8
date	99.02.09.12.40.17;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	99.02.08.23.01.47;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.07.20.00.55;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.07.19.14.40;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.04.00.02.59;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.02.02.07.51.02;	author jimmy;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.02.40.03;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
   *   File: fight.c                                       Part of CircleMUD *
   *  Usage: Combat system                                                   *
   *                                                                         *
   *  All rights reserved.  See license.doc for complete information.        *
   *                                                                         *
   *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
   *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
   ************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "dg_scripts.h"
#include "corpse_save.h"

/* Structures */
struct char_data *combat_list = NULL;	/* head of l-list of fighting chars */
struct char_data *next_combat_list = NULL;
void improve_skill (struct char_data *ch, int skill);
void update_pos (struct char_data *victim);
void make_fun_body_pieces (struct char_data *ch, struct char_data *killer);
bool DisarmRecovery (struct char_data *ch);

/* External structures */
extern struct room_data *world;
extern struct message_list fight_messages[MAX_MESSAGES];
extern struct obj_data *object_list;
extern int pk_allowed;		/* see config.c */
extern int auto_save;		/* see config.c */
extern int summon_allowed;	/*       "      */
extern int sleep_allowed;	/*       "      */
extern int charm_allowed;	/*       "      */
int max_exp_gain (struct char_data *ch);	/* see config.c */
int exp_death_loss (struct char_data *ch, int level);
void check_justice (struct char_data *ch, struct char_data *vict);
void StopMercifulAttackers (struct char_data *ch);
int return_max_skill (struct char_data *ch, int skill);

/* External procedures */
char *fread_action (FILE * fl, int nr);
char *fread_string (FILE * fl, char *error);
void stop_follower (struct char_data *ch);
void decrease_modifier (struct char_data *i);

ACMD (do_get);
ACMD (do_flee);
ACMD (do_return);
ACMD (do_bash);
ACMD (do_kick);
ACMD (do_cast);
void slow_death (struct char_data *victim);
void hit (struct char_data *ch, struct char_data *victim, int type);
void hit2 (struct char_data *ch, struct char_data *victim, int type);
void forget (struct char_data *ch, struct char_data *victim);
void remember (struct char_data *ch, struct char_data *victim);
int ok_damage_shopkeeper (struct char_data *ch, struct char_data *victim);
void mprog_hitprcnt_trigger (struct char_data *mob, struct char_data *ch);
void mprog_death_trigger (struct char_data *mob, struct char_data *killer);
void mprog_fight_trigger (struct char_data *mob, struct char_data *ch);
void gain_condition (struct char_data *ch, int condition, int value);
void frag_update (struct char_data *ch, struct char_data *victim, float amount);
void trophy_update (struct char_data *ch, struct char_data *vict, float amount);
int number_of_groupees (struct char_data *ch);
int perform_trophy_decrease (struct char_data *ch, struct char_data *vict, int exp);
bool is_aggr_to (struct char_data *ch, struct char_data *target);
void dismount_char (struct char_data *ch);
int mem_inMemory (struct char_data *ch, struct char_data *vict);
void Forgive_The_Basterd(struct char_data *ch);

/*globals */



/* Weapon attack texts */
struct attack_hit_type attack_hit_text[] =
{
   {"hit", "hits"},		/* 0 */
   {"sting", "stings"},
   {"whip", "whips"},
   {"slash", "slashes"},
   {"bite", "bites"},
   {"bludgeon", "bludgeons"},	/* 5 */
   {"crush", "crushes"},
   {"pound", "pounds"},
   {"claw", "claws"},
   {"maul", "mauls"},
   {"thrash", "thrashes"},	/* 10 */
   {"pierce", "pierces"},
   {"blast", "blasts"},
   {"punch", "punches"},
   {"stab", "stabs"}
};

#define IS_WEAPON(type) (((type) >= TYPE_HIT) && ((type) < TYPE_SUFFERING))

/* The Fight related routines */

void
appear (struct char_data *ch)
{
   if (affected_by_spell (ch, SPELL_INVISIBLE))
      affect_from_char (ch, SPELL_INVISIBLE);
   if (affected_by_spell (ch, SPELL_CONCEALMENT))
      affect_from_char (ch, SPELL_CONCEALMENT);


   REMOVE_BIT (AFF_FLAGS (ch), AFF_INVISIBLE | AFF_HIDE);

   if (GET_LEVEL (ch) < LVL_IMMORT)
   {
      act ("$n snaps into visibility.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You fade back into view.", FALSE, ch, 0, 0, TO_CHAR);
   }
   else
      act ("You feel a strange presence as $n appears, seemingly from nowhere.",
	   FALSE, ch, 0, 0, TO_ROOM);
}



void
load_messages (void)
{
   FILE *fl;
   int i, type;
   struct message_type *messages;
   char chk[128];

   if (!(fl = fopen (MESS_FILE, "r")))
   {
      sprintf (buf2, "Error reading combat message file %s", MESS_FILE);
      perror (buf2);
      exit (1);
   }
   for (i = 0; i < MAX_MESSAGES; i++)
   {
      fight_messages[i].a_type = 0;
      fight_messages[i].number_of_attacks = 0;
      fight_messages[i].msg = 0;
   }


   fgets (chk, 128, fl);
   while (!feof (fl) && (*chk == '\n' || *chk == '*'))
      fgets (chk, 128, fl);

   while (*chk == 'M')
   {
      fgets (chk, 128, fl);
      sscanf (chk, " %d\n", &type);
      for (i = 0; (i < MAX_MESSAGES) && (fight_messages[i].a_type != type) &&
	   (fight_messages[i].a_type); i++);
      if (i >= MAX_MESSAGES)
      {
	 fprintf (stderr, "Too many combat messages.  Increase MAX_MESSAGES and recompile.");
	 exit (1);
      }
      CREATE (messages, struct message_type, 1);

      fight_messages[i].number_of_attacks++;
      fight_messages[i].a_type = type;
      messages->next = fight_messages[i].msg;
      fight_messages[i].msg = messages;

      messages->die_msg.attacker_msg = fread_action (fl, i);
      messages->die_msg.victim_msg = fread_action (fl, i);
      messages->die_msg.room_msg = fread_action (fl, i);
      messages->miss_msg.attacker_msg = fread_action (fl, i);
      messages->miss_msg.victim_msg = fread_action (fl, i);
      messages->miss_msg.room_msg = fread_action (fl, i);
      messages->hit_msg.attacker_msg = fread_action (fl, i);
      messages->hit_msg.victim_msg = fread_action (fl, i);
      messages->hit_msg.room_msg = fread_action (fl, i);
      messages->god_msg.attacker_msg = fread_action (fl, i);
      messages->god_msg.victim_msg = fread_action (fl, i);
      messages->god_msg.room_msg = fread_action (fl, i);
      fgets (chk, 128, fl);
      while (!feof (fl) && (*chk == '\n' || *chk == '*'))
	 fgets (chk, 128, fl);
   }

   fclose (fl);
}




void
update_pos (struct char_data *victim)
{
   int tmp, pos, pos1;

   ACMD (do_wake);

   if(event_target_valid(victim) == FALSE)
     return;

   if (IS_FIGHTING (victim))
      if (victim->in_room != FIGHTING (victim)->in_room)
	 stop_fighting (victim);

   if (RIDING (victim))
      if (RIDING (victim)->in_room != victim->in_room)
	 dismount_char (victim);


/* some chesck to make pos cleaner and work well with the mud Banyal */
   if (!AWAKE (victim) || IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS)
       || IS_AFFECTED (victim, AFF_MAJOR_PARA) ||
       IS_AFFECTED2 (victim, AFF2_KNOCKED_OUT) || (GET_POS (victim) < POS_SLEEPING))
   {
      if (IS_FIGHTING (victim))
	 stop_fighting (victim);
      StopMercifulAttackers (victim);
   }
   /* check for mobs, if they can assume their default position */
   if (IS_NPC (victim) && (GET_POS (victim) > POS_SLEEPING) &&
       !IS_FIGHTING (victim) && !GET_MOB_WAIT (victim) &&
       ((victim->mob_specials.default_pos) > POS_SLEEPING) &&
       (MOB_FLAGGED (victim, MOB_MEMORY) && !MEMORY (victim)))
   {
      GET_POS (victim) = victim->mob_specials.default_pos;
   }

/* Lets dive into updating for current hitpoints this MUSt be first
   so that any following checks are current and reflect the
   players  current diliema...Banyal */

   if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
   {
      GET_POS (victim) = POS_STANDING;
      GET_POS1 (victim) = POS1_PRONE;
   }
   else if (GET_HIT (victim) <= HIT_DEAD)
   {
      GET_POS (victim) = POS_DEAD;
   }
   else if (GET_HIT (victim) <= HIT_MORTALLYW)
   {
      GET_POS (victim) = POS_MORTALLYW;
      StopMercifulAttackers (victim);
      if (GET_LEVEL (victim) >= LVL_IMMORT)
	 if (victim->desc && victim->desc->original)
	    do_return (victim, "", 0, 0);
   }
   else if (GET_HIT (victim) <= HIT_INCAP)
   {
      GET_POS (victim) = POS_INCAP;
      StopMercifulAttackers (victim);
      if (GET_LEVEL (victim) >= LVL_IMMORT)
	 if (victim->desc && victim->desc->original)
	    do_return (victim, "", 0, 0);
   }
   else if (GET_HIT (victim) < 0)
   {
      GET_POS (victim) = POS_STUNNED;
   }
   else
   {
      pos = GET_POS (victim);
   }
/* Lets cut out some typing heh Banyal */
   pos = GET_POS (victim);
   pos1 = GET_POS1 (victim);

/* Now lets use our new dual position system and riding to victimeck(I hope)
   all the possible positions and perhaps problems in those postions the
   poor mortals get themselves into. Banyal */


   if (pos < POS_RESTING)
   {
      tmp = 0;
      switch (GET_POS1 (victim))
      {
      case POS1_PRONE:
	 break;
      case POS1_KNEELING:
	 switch (GET_POS (victim))
	 {
	 case POS_DEAD:
	    if (RIDING (victim))
	       tmp = 1;
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 case POS_MORTALLYW:
	 case POS_INCAP:
	 case POS_SLEEPING:
	    /*mark new */
	    if (RIDING (victim))
	    {
	       if (!number (0, 1))
		  tmp = 1;
	    }
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 }
	 break;
      case POS_SITTING:
	 switch (pos)
	 {
	 case POS_DEAD:
	    if (RIDING (victim))
	    {
	       if (!number (0, 1))
		  tmp = 1;
	    }
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 }
	 break;
/*end mark */

      case POS1_STANDING:
	 switch (pos)
	 {
	 case POS_DEAD:
	    tmp = 1;
	    break;
	 case POS_MORTALLYW:
	 case POS_INCAP:
	 case POS_SLEEPING:
	    if (RIDING (victim))
	       tmp = 1;
	    else
	    {
	       if (!number (0, 5))
		  tmp = 1;
	    }
	    break;
	 }
	 break;
      }
      if (tmp)
      {
	 tmp = 0;
	 if (RIDING (victim))
	 {
	    tmp = 1;
	    switch (GET_POS1 (RIDING (victim)))
	    {
	    case POS1_PRONE:
	    case POS1_KNEELING:
	    case POS1_SITTING:
	       break;
	    case POS1_STANDING:
	       alter_hit (victim, dice (3, 8), 2);
	       WAIT_STATE (victim, PULSE_VIOLENCE + 2);		/* this will be stun when it
								   it is coded MARKSTUN */
	       break;
	    }
	    act ("$n falls of $s mount!", TRUE, victim, 0, 0, TO_ROOM);
	    dismount_char (victim);
	 }
	 else
	 {
	    switch (pos1)
	    {
	    case POS1_PRONE:
	    case POS1_KNEELING:
	    case POS1_SITTING:
	       break;
	    case POS_STANDING:
	       tmp = 0;
	       if (!number (0, 2))
	       {
		  alter_hit (victim, dice (3, 5), 2);
		  if (GET_POS (victim) > POS_INCAP)
		     WAIT_STATE (victim, PULSE_VIOLENCE + 2);
		  tmp = 1;
	       }
	       act ("$n slumps to the ground.", TRUE, victim, 0, 0, TO_ROOM);
	       break;
	    }
	 }
	 pos1 = POS1_PRONE;

	 /* RE-chECK POSTION WITH NEW HITPOINTS */
	 if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
	 {
	    GET_POS (victim) = POS_SITTING;
	    GET_POS1 (victim) = POS1_PRONE;
	 }
	 else if (GET_HIT (victim) <= HIT_DEAD)
	    GET_POS (victim) = POS_DEAD;
	 else if (GET_HIT (victim) <= HIT_MORTALLYW)
	 {
	    GET_POS (victim) = POS_MORTALLYW;
	    StopMercifulAttackers (victim);
	    if (GET_LEVEL (victim) >= LVL_IMMORT)
	       if (victim->desc && victim->desc->original)
		  do_return (victim, "", 0, 0);
	 }
	 else if (GET_HIT (victim) <= HIT_INCAP)
	 {
	    GET_POS (victim) = POS_INCAP;
	    StopMercifulAttackers (victim);
	    if (GET_LEVEL (victim) >= LVL_IMMORT)
	       if (victim->desc && victim->desc->original)
		  do_return (victim, "", 0, 0);
	 }
	 else
	 {
	    pos = GET_POS (victim);
	 }

	 if (tmp && (pos < POS_RESTING))
	 {
	    if (affected_by_spell (victim, SPELL_SLEEP))
	       affect_from_char (victim, SPELL_SLEEP);
	    if (pos == POS_SLEEPING)
	    {
	       pos = POS_RESTING;
	       send_to_char ("Huh?!? You find yourself laying on the ground!\r\n", victim);
	    }
	 }
      }
   }
   if ((GET_POS (victim) == POS_SLEEPING) && (pos > POS_SLEEPING))
   {
      act ("$n has a RUDE awakening!", TRUE, victim, 0, 0, TO_ROOM);
      affect_from_char (victim, SPELL_SLEEP);
      do_wake (victim, "", 0, 0);
   }
   GET_POS (victim) = pos;
   GET_POS1 (victim) = pos1;

   /*Some sanity checks lets not leave dead people to be found by code
      elsewhere */
   if (pos == POS_DEAD)
   {
      if (IS_FIGHTING (victim))
	 stop_fighting (victim);
      pos = POS_MORTALLYW;	/* TO NOT HAVE DAMAGE CORPSE BUG */

   }
   /*mark69 */
}


void
check_killer (struct char_data *ch, struct char_data *vict)
{
   if (!PLR_FLAGGED (vict, PLR_KILLER) && !PLR_FLAGGED (vict, PLR_THIEF)
       && !PLR_FLAGGED (ch, PLR_KILLER) && !IS_NPC (ch) && !IS_NPC (vict) &&
       (ch != vict))
   {
      char buf[256];

      SET_BIT (PLR_FLAGS (ch), PLR_KILLER);
      sprintf (buf, "PC Killer bit set on %s for initiating attack on %s at %s.",
	       GET_NAME (ch), GET_NAME (vict), world[vict->in_room].name);
      mudlog (buf, BRF, LVL_IMMORT, TRUE);
      send_to_char ("If you want to be a PLAYER KILLER, so be it...\r\n", ch);
   }
}


/* start one char fighting another (yes, it is horrible, I know... )  */
void
set_fighting (struct char_data *ch, struct char_data *vict)
{
   if (ch == vict)
      return;

   assert (!FIGHTING (ch));	/*Setmark game crashing due to assertion failing */

   ch->next_fighting = combat_list;
   combat_list = ch;

   if (IS_AFFECTED (ch, AFF_SLEEP))
      affect_from_char (ch, SPELL_SLEEP);

   FIGHTING (ch) = vict;
   /*GET_POS(ch) = POS_FIGHTING; */

   if (!pk_allowed)
      check_killer (ch, vict);
   check_justice (ch, vict);
if(ch != vict)
if (ch->desc && ch->desc->original)
  check_justice(ch->desc->original, vict);
}



/* remove a char from the list of fighting chars */
void
stop_fighting (struct char_data *ch)
{
   extern char *spell_wear_off_msg[];
   struct char_data *temp;

   if (ch == next_combat_list)
      next_combat_list = ch->next_fighting;

   REMOVE_FROM_LIST (ch, combat_list, next_fighting);
   ch->next_fighting = NULL;
   FIGHTING (ch) = NULL;
   if (IS_AFFECTED2 (ch, AFF2_HARNESS))
   {
      affect_from_char (ch, SPELL_HARNESS);
      send_to_char (spell_wear_off_msg[SPELL_HARNESS], ch);
      send_to_char ("\r\n", ch);
   }
   GET_POS (ch) = POS_STANDING;
   update_pos (ch);
}



void
make_corpse (struct char_data *ch)
{
   struct obj_data *corpse, *o;
   struct obj_data *money;
   int i;
   extern int max_npc_corpse_time, max_pc_corpse_time, top_of_corpse_list;
   struct obj_data *create_money (int pamount, int gamount, int samount, int camount);

   corpse = create_obj ();

   corpse->item_number = NOTHING;
   corpse->in_room = NOWHERE;
   sprintf (buf2, "corpse %s", strip_ansi ((ch)->player.name));
   corpse->name = str_dup (buf2);

   sprintf (buf2, "&0The corpse of %s&0 is lying here.", GET_NAME (ch));
   corpse->description = str_dup (buf2);

   sprintf (buf2, "the corpse of %s", GET_NAME (ch));
   corpse->short_description = str_dup (buf2);

   GET_OBJ_TYPE (corpse) = ITEM_CONTAINER;
   /*GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE; */
   GET_OBJ_EXTRA (corpse) = (ITEM_NODONATE | ITEM_FLOAT);
   GET_OBJ_VAL (corpse, 0) = 0;	/* You can't store stuff in a corpse */
   if (!IS_NPC (ch))
      GET_OBJ_VAL (corpse, 1) = 1;	/* player corpse */
   else
      GET_OBJ_VAL (corpse, 1) = 0;	/* npc corpse    */
   GET_OBJ_VAL (corpse, 2) = top_of_corpse_list;
   GET_OBJ_VAL (corpse, 3) = 1;	/* corpse identifier */
   GET_OBJ_WEIGHT (corpse) = GET_WEIGHT (ch) + IS_CARRYING_W (ch) + 100;
   GET_OBJ_RENT (corpse) = 100000;
   GET_OBJ_RENT (corpse) = GET_LEVEL (ch);
   if (IS_NPC (ch))
      GET_OBJ_MOB_FROM (corpse) = GET_MOB_RNUM (ch);
   else
      GET_OBJ_MOB_FROM (corpse) = 0;

   if (IS_NPC (ch))
      GET_OBJ_TIMER (corpse) = max_npc_corpse_time;
   else
      GET_OBJ_TIMER (corpse) = max_pc_corpse_time;

   /* transfer character's inventory to the corpse */
   corpse->contains = ch->carrying;
   if (!(MOB_FLAGGED (ch, MOB_NOGEAR)))
      for (o = corpse->contains; o != NULL; o = o->next_content)
	 o->in_obj = corpse;
   object_list_new_owner (corpse, NULL);

   /* transfer character's equipment to the corpse */
   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ (ch, i))
	 obj_to_obj (unequip_char (ch, i), corpse);

   /* transfer gold */
   if (GET_CASH (ch) > 0)
   {
      /* following 'if' clause added to fix gold duplication loophole */
      if (IS_NPC (ch) || (!IS_NPC (ch) && ch->desc))
      {
	 money = create_money (GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
	 obj_to_obj (money, corpse);
      }
      GET_GOLD (ch) = 0;
      GET_PLAT (ch) = 0;
      GET_COPPER (ch) = 0;
      GET_SILVER (ch) = 0;
   }
   ch->carrying = NULL;
   IS_CARRYING_N (ch) = 0;
   IS_CARRYING_W (ch) = 0;

   obj_to_room (corpse, ch->in_room);
   if (!IS_NPC (ch))
      ccontrol_make_corpse (world[ch->in_room].number, corpse);
}


/* When ch kills victim */
void
change_alignment (struct char_data *ch, struct char_data *victim)
{
   int change = 0;

   /*
    * new alignment change algorithm: if you kill a monster with alignment A,
    * you move 1/16th of the way to having alignment -A.  Simple and fast.
    Yeah and it sucks so i changed it....Banyal */
/*proky had a go at it */
/*      if ((GET_ALIGNMENT(ch) == -1000) && (GET_ALIGNMENT(victim)  > 500))
   return;
   if ((GET_ALIGNMENT(ch) == 1000) && (GET_ALIGNMENT(victim)  < -500))
   return;
 */
   if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
      change = ((GET_ALIGNMENT (victim)) - (GET_ALIGNMENT (ch)));
   else
      change = ((GET_ALIGNMENT (ch)) - (GET_ALIGNMENT (victim)));
   /*basically the higher the level of victim more alig change */
   change = (int) (change / (50 + number (75, 120) - GET_LEVEL (victim)));
   /*just decrease it again randomly */
   if (number (0, 2))
      change = (int) (change / 2);
   if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
      GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) - change;
   else
      GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) + change;

   GET_ALIGNMENT (ch) = MIN (1000, (MAX (-1000, GET_ALIGNMENT (ch))));
/*      sprintf(buf, " alignment change %d.\r\n", change);
   send_to_char(buf, ch);
 */

/*  GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 4;


   if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) > 600)
   GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 9;
   if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) < 601)
   GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 7;
 */
}



void
death_cry (struct char_data *ch)
{
   int door, was_in;

   act ("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);
   was_in = ch->in_room;

   for (door = 0; door < NUM_OF_DIRS; door++)
   {
      if (CAN_GO (ch, door))
      {
	 ch->in_room = world[was_in].dir_option[door]->to_room;
	 act ("Your blood freezes as you hear someone's death cry.", FALSE, ch, 0, 0, TO_ROOM);
	 ch->in_room = was_in;
      }
   }
}



void
raw_kill (struct char_data *ch, struct char_data *killer)
{
   struct char_data *real_char;
   struct mem_list *cur;
   int i;
//   register struct char_data *j;
//   extern struct char_data *character_list;

   /*check for switched victim */
   if (ch->desc && ch->desc->original)
   {
      real_char = ch->desc->original;
      char_from_room (real_char);
      char_to_room (real_char, ch->in_room);
   }
   else
      real_char = ch;

   if (FIGHTING (ch))
      stop_fighting (ch);

   while (ch->affected)
      affect_remove (ch, ch->affected);
   while (real_char->affected)
      affect_remove (real_char, real_char->affected);

   /* this guy died ..zero the mem_list */
   if (ch->spell_list)
   {
      cur = ch->spell_list;
      if (cur != NULL)
	 for (i = 0; i < ch->num_spells && cur; i++)
	 {
	    cur->can_cast = 0;
	    cur = cur->next;
	 }
      ch->num_memmed = 0;
      ch->mem_status = FALSE;
   }

//   if (!IS_NPC (ch))
//      for (j = character_list; j; j = j->next)
//      {
//	 if (IS_NPC (j))
//	    if (MEMORY (j))
//	       if (mem_inMemory (j, ch))
//		  forget (j, ch);
//      }
    Forgive_The_Basterd(ch);

   if (killer)
   {
      if (death_mtrigger (ch, killer))
	 death_cry (ch);
   }
   else if (killer)
      mprog_death_trigger (ch, killer);
/*if (!IS_NPC(ch))
   make_fun_body_pieces(ch, killer); */
   if (GET_LEVEL (real_char) < LVL_IMMORT)
   {
      make_corpse (real_char);
      extract_char (ch);
      if (ch != real_char)
	 extract_char (real_char);
      if (!IS_NPC (real_char))	/* If killed dont save in room he died in */
	 GET_LOADROOM (real_char) = GET_HOME (real_char);
   }
   else if (ch != real_char)
   {
      do_return (real_char, "", 0, 0);
      extract_char (ch);
   }
}

void
kill_to_group (struct char_data *ch, struct char_data *killer, void *infunc (struct char_data *ch, struct char_data *killer, float amount))
{/*want to loop through all group and major group members for this */

//   int groupees;
   int tot_members = 0;
   struct char_data *groupmaster;
   struct char_data *majorgroupmaster = NULL;
   struct group_type *g;
   struct mgroup_type *m;
//   float tot_percent;
//   float leader_percent;

   groupmaster = (ch->groupmaster ? ch->groupmaster : ch);
   if (!(IS_AFFECTED (groupmaster, AFF_GROUP)))
   {
      sprintf (buf, "In group exp give and leader not grouped?:%s exiting without exp gain", GET_NAME (ch));
      mudlog (buf, NRM, LVL_GOD, FALSE);
      return;
   }
   if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
   {
      majorgroupmaster = (groupmaster->mgroupmaster ? groupmaster->mgroupmaster : groupmaster);
      if (majorgroupmaster->in_room == ch->in_room)
	 tot_members = 1;
      for (g = majorgroupmaster->groupees; g; g = g->next)
	 if (g->groupee->in_room == ch->in_room)
	    tot_members++;
      for (m = majorgroupmaster->mgroupees; m; m = m->next)
      {
	 if (m->mgroupee->in_room == ch->in_room)
	    tot_members++;
	 for (g = m->mgroupee->groupees; g; g = g->next)
	    if (g->groupee->in_room == ch->in_room)
	       tot_members++;
      }
   }
   else
   {				/*just group count */
      if (groupmaster->in_room == ch->in_room)
	 tot_members = 1;
      for (g = groupmaster->groupees; g; g = g->next)
	 if (g->groupee->in_room == ch->in_room)
	    tot_members++;
   }

   if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
   {
      if (majorgroupmaster->in_room == ch->in_room)
	 infunc (majorgroupmaster, killer, (1 / (float) tot_members));
      for (g = majorgroupmaster->groupees; g; g = g->next)
	 if (g->groupee->in_room == ch->in_room)
	    infunc (g->groupee, killer, (1 / (float) tot_members));
      for (m = majorgroupmaster->mgroupees; m; m = m->next)
      {
	 if (m->mgroupee->in_room == ch->in_room)
	    infunc (m->mgroupee, killer, (1 / (float) tot_members));
	 for (g = m->mgroupee->groupees; g; g = g->next)
	    if (g->groupee->in_room == ch->in_room)
	       infunc (g->groupee, killer, (1 / (float) tot_members));
      }
   }
   else
   {				/*just group count */
      if (groupmaster->in_room == ch->in_room)
	 infunc (groupmaster, killer, (1 / (float) tot_members));
      for (g = groupmaster->groupees; g; g = g->next)
	 if (g->groupee->in_room == ch->in_room)
	    infunc (g->groupee, killer, (1 / (float) tot_members));
   }
}


void
die (struct char_data *ch, struct char_data *killer)
{
 //  register struct char_data *i;
 //  extern struct char_data *character_list;

   /*check for switch. Original char loses exp */
 //  int groupees;

   if (ch->desc && ch->desc->original)
   {
/*    gain_exp(ch->desc->original, -(GET_EXP(ch->desc->original) >> 1)); */
      gain_exp (ch->desc->original, -(exp_death_loss (ch->desc->original, GET_LEVEL (ch->desc->original))));
   }
   else
   {
/*    gain_exp(ch, -(GET_EXP(ch) >> 1)); */
      gain_exp (ch, -(exp_death_loss (ch, GET_LEVEL (ch))));
   }
   if (IS_AFFECTED (killer, AFF_GROUP))
   {				/*loop through group */
      /*if a BIG person got kill then dont let rest of group bludge: */
      if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25))
	 if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)))
	    ;
	 else
	 {
	    kill_to_group (killer, ch, (void *) frag_update);
	 }
      kill_to_group (killer, ch, (void *) trophy_update);
   }
   else
   {
      // frag_update (killer, ch, 1.0);
     // Temp fix till kill-to_group is made to update frags
      trophy_update (killer, ch, 1.0);
   }


   if (IS_AFFECTED2 (ch, AFF2_ON_FIRE))
      REMOVE_BIT (AFF2_FLAGS (ch), AFF2_ON_FIRE);
   if (!IS_NPC (ch))
   {
      REMOVE_BIT (PLR_FLAGS (ch), PLR_KILLER | PLR_THIEF);
      GET_COND (ch, THIRST) = 24;
      GET_COND (ch, FULL) = 24;
      GET_COND (ch, DRUNK) = 0;
   }
frag_update (killer, ch, 1.0);
   raw_kill (ch, killer);

     // forget(killer, ch);
   Forgive_The_Basterd(ch);

/*New to solve memory problem with mobs, as was the mob that killed the pc
   was the ONLY one that forgot him. Now all does using a utility
   Mem_inMemory   Banyal */
//  if (!IS_NPC (ch))
//     for (i = character_list; i; i = i->next)
//     {
//	 if (IS_NPC (i))
//	    if (MEMORY (i))
//	       if (mem_inMemory (i, ch))
//		  forget (i, ch);
//    }

   if (PLR_FLAGGED (ch, PLR_CASTING))
   {
      if (IS_NPC (ch))
	 REMOVE_BIT (MOB_FLAGS (ch), MOB_CASTING);
      REMOVE_BIT (PLR_FLAGS (ch), PLR_CASTING);
      act ("You stop chanting abruptly!", FALSE, ch, 0, 0, TO_CHAR);
      act ("$n stops chanting abruptly!", FALSE, ch, 0, 0, TO_ROOM);
   }
}




void
perform_group_gain (struct char_data *ch, int base,
		    struct char_data *victim)
{
   int share;

   /*add level bonus and group bonus */
   /*add group bonus */
   /*sprintf(buf, " base before modifier within group exp %d.\r\n", base);
      send_to_char(buf, ch);
    */ if (GET_LEVEL (ch) < GET_LEVEL (victim))
      base = exp_highlevel_bonus (base, (GET_LEVEL (victim) - GET_LEVEL (ch)));
   base = exp_group_bonus (base);

/*This shows exp people getting turn on at will */
   /* sprintf(buf, " base within group exp %d.\r\n", base);
      send_to_char(buf, ch);
    */
   share = MIN (max_exp_gain (ch), MAX (1, base));

   if (share > 1)
   {
      sprintf (buf2, "You receive your share of experience.\r\n");
      send_to_char (buf2, ch);
   }
   if (!IS_NPC (victim))
      share = 1;
   gain_exp (ch, share);
   change_alignment (ch, victim);
}

void
group_gain (struct char_data *ch, struct char_data *victim)
{
   int tot_members = 0, base, lbase, exp;
   struct char_data *k;
   struct char_data *m;
   struct group_type *f;
   struct mgroup_type *g;
   float tot_percent;
   float leader_percent;

   k = (ch->groupmaster ? ch->groupmaster : ch);


   if (IS_AFFECTED (k, AFF_GROUP))
      ;
   else
   {
      sprintf (buf, "In group exp give and leader not grouped?:%s exiting without exp gain", GET_NAME (ch));
      mudlog (buf, NRM, LVL_GOD, FALSE);
      return;
   }
   if (IS_AFFECTED2 (k, AFF2_MGROUP))
   {
      m = (k->mgroupmaster ? k->mgroupmaster : k);
      if (m->in_room == ch->in_room)
	 tot_members = 1;
      for (f = m->groupees; f; f = f->next)
	 if (f->groupee->in_room == ch->in_room)
	    tot_members++;
      for (g = m->mgroupees; g; g = g->next)
      {
	 if (g->mgroupee->in_room == ch->in_room)
	    tot_members++;
	 for (f = g->mgroupee->groupees; f; f = f->next)
	    if (f->groupee->in_room == ch->in_room)
	       tot_members++;
      }
   }
   else
   {				/*just group count */
      if (k->in_room == ch->in_room)
	 tot_members = 1;
      for (f = k->groupees; f; f = f->next)
	 if (f->groupee->in_room == ch->in_room)
	    tot_members++;
   }

   /* round up to the next highest tot_members */
   tot_percent = (float) 100 / tot_members;
   leader_percent = (float) .02 *tot_percent;

   tot_percent = (100 - leader_percent) / tot_members;
   leader_percent = tot_percent + leader_percent;
   if (IS_NPC (victim))
      exp = GET_EXP (victim);
   else
      /*I will give 8 k exp per level for a opp race pkill
         and a 3 k exp per level for a sim race pkill */
   if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
      exp = GET_LEVEL (victim) * 8000;
   else
      exp = GET_LEVEL (victim) * 3000;

   if (tot_members >= 1)	/*changed line below it had no affect as it was */
/*Mark may need worked on */
      base = MAX (1, ((int) ((GET_EXP (victim) * (float) tot_percent / 100) + 1)));
   else
      base = 0;
   lbase = MAX (1, ((int) ((GET_EXP (victim) * (float) leader_percent / 100) + 1)));


   if (IS_AFFECTED2 (k, AFF2_MGROUP))
   {
      m = (k->mgroupmaster ? k->mgroupmaster : k);
      if (m->in_room == ch->in_room)
	 perform_group_gain (k, lbase, victim);
      for (f = m->groupees; f; f = f->next)
	 if (f->groupee->in_room == ch->in_room)
	    perform_group_gain (f->groupee, base, victim);
      for (g = m->mgroupees; g; g = g->next)
      {
	 if (g->mgroupee->in_room == ch->in_room)
	    perform_group_gain (g->mgroupee, base, victim);
	 for (f = g->mgroupee->groupees; f; f = f->next)
	    if (f->groupee->in_room == ch->in_room)
	       perform_group_gain (f->groupee, base, victim);
      }
   }
   else
   {				/*just group count */
      if (k->in_room == ch->in_room)
	 perform_group_gain (k, lbase, victim);
      for (f = k->groupees; f; f = f->next)
	 if (f->groupee->in_room == ch->in_room)
	    perform_group_gain (f->groupee, base, victim);
   }


}




char *
replace_string (char *str, char *weapon_singular, char *weapon_plural)
{
   static char buf[256];
   char *cp;

   cp = buf;

   for (; *str; str++)
   {
      if (*str == '#')
      {
	 switch (*(++str))
	 {
	 case 'W':
	    for (; *weapon_plural; *(cp++) = *(weapon_plural++));
	    break;
	 case 'w':
	    for (; *weapon_singular; *(cp++) = *(weapon_singular++));
	    break;
	 default:
	    *(cp++) = '#';
	    break;
	 }
      }
      else
	 *(cp++) = *str;

      *cp = 0;
   }				/* For */

   return (buf);
}


/* message for doing damage with a weapon */
void
dam_message (int dam, struct char_data *ch, struct char_data *victim,
	     int w_type)
{
   char *buf;
   int msgnum;
   int percent = 0;



   static struct dam_weapon_type
   {
      char *to_room;
      char *to_char;
      char *to_victim;
   }
   dam_weapons[] =
   {

      /* use #w for singular (i.e. "slash") and #W for plural (i.e. "slashes") */

      {
	 "$n tries to #w $N, but misses.&0",	/* 0: 0     */
	    "You try to #w $N, but miss.&0",
	    "$n tries to #w you, but misses.&0"
      }
      ,

      {
	 "$n grazes $N as $e #W $M.&0",		/* 1: 1..2  */
	    "You graze $N as you #w $M.&0",
	    "$n grazes you as $e #W you.&0"
      }
      ,

      {
	 "$n barely #W $N.&0",	/* 2: 3..4  */
	    "You barely #w $N.&0",
	    "$n barely #W you.&0"
      }
      ,

      {
	 "$n #W $N.&0",		/* 3: 5..6  */
	    "You #w $N.&0",
	    "$n #W you.&0"
      }
      ,

      {
	 "$n #W $N hard.&0",	/* 4: 7..10  */
	    "You #w $N hard.&0",
	    "$n #W you hard.&0"
      }
      ,

      {
	 "$n #W $N very hard.&0",	/* 5: 11..14  */
	    "You #w $N very hard.&0",
	    "$n #W you very hard.&0"
      }
      ,

      {
	 "$n #W $N extremely hard.&0",	/* 6: 15..19  */
	    "You #w $N extremely hard.&0",
	    "$n #W you extremely hard.&0"
      }
      ,

      {
	 "$n massacres $N to small fragments with $s #w.&0",	/* 7: 19..23 */
	    "You massacre $N to small fragments with your #w.&0",
	    "$n massacres you to small fragments with $s #w.&0"
      }
      ,

      {
	 "$n nearly rip $N in two with $s deadly #w!!&0",	/* 8: > 23   */
	    "You nearly rip $N in two with your deadly #w!!&0",
	    "$n nearly rips you in two with $s  deadly #w!!&0"
      }
   };


   w_type -= TYPE_HIT;		/* Change to base of table with text */
/*
   sprintf(buf2, "dam is:%d", dam);
   act(buf2, TRUE, ch, 0, 0, TO_ROOM);
 */


   if (GET_HIT (victim) > 0)
      percent = (int) (dam * 100 / GET_HIT (victim));
   else
      percent = 100;
   /* percent = MIN(percent, 1); */
   if (percent == 0)
      ;				/*percent += 1; */
   if ((percent <= 1) && (dam >= 20))
      percent += 1;
   if ((percent <= 1) && (dam >= 50))
      percent += 1;


   if (percent == 0)
      msgnum = 0;
   else if (percent <= 2)
      msgnum = 1;
   else if (percent <= 4)
      msgnum = 2;
   else if (percent <= 6)
      msgnum = 3;
   else if (percent <= 10)
      msgnum = 4;
   else if (percent <= 15)
      msgnum = 5;
   else if (percent <= 19)
      msgnum = 6;
   else if (percent <= 35)
      msgnum = 7;
   else if (percent <= 55)
      msgnum = 8;
   else
      msgnum = 8;

   /* damage message to onlookers */
   buf = replace_string (dam_weapons[msgnum].to_room,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_NOTVICT);

   /* damage message to damager */
   send_to_char (CCNRM (ch, C_CMP), ch);
   buf = replace_string (dam_weapons[msgnum].to_char,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_CHAR);
   send_to_char (CCNRM (ch, C_CMP), ch);

   /* damage message to damagee */
   send_to_char (CCNRM (victim, C_CMP), victim);
   buf = replace_string (dam_weapons[msgnum].to_victim,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
   send_to_char (CCNRM (victim, C_CMP), victim);
}


/*
 * message for doing damage with a spell or skill
 *  C3.0: Also used for weapon damage on miss and death blows
 */
int
skill_message (int dam, struct char_data *ch, struct char_data *vict,
	       int attacktype)
{
   int i, j, nr;
   struct message_type *msg;

   struct obj_data *weap = GET_EQ (ch, WEAR_WIELD);
   struct obj_data *weap2 = GET_EQ (ch, WEAR_WIELD2);

   for (i = 0; i < MAX_MESSAGES; i++)
   {
      if (fight_messages[i].a_type == attacktype)
      {
	 nr = dice (1, fight_messages[i].number_of_attacks);
	 for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
	    msg = msg->next;

	 if (!IS_NPC (vict) && (GET_LEVEL (vict) >= LVL_IMMORT))
	 {
	    act (msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	    act (msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
	    act (msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	 }
	 else if (dam != 0)
	 {
	    if (GET_POS (vict) == POS_DEAD)
	    {
	       send_to_char (CCNRM (ch, C_CMP), ch);
	       act (msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	       send_to_char (CCNRM (ch, C_CMP), ch);

	       send_to_char (CCNRM (vict, C_CMP), vict);
	       act (msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	       send_to_char (CCNRM (vict, C_CMP), vict);

	       act (msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	    else
	    {
	       send_to_char (CCNRM (ch, C_CMP), ch);
	       if (attacktype == SKILL_2BACK)
		  act (msg->hit_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
	       else
		  act (msg->hit_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	       send_to_char (CCNRM (ch, C_CMP), ch);

	       send_to_char (CCNRM (vict, C_CMP), vict);
	       if (attacktype == SKILL_2BACK)
		  act (msg->hit_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
	       else
		  act (msg->hit_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	       send_to_char (CCNRM (vict, C_CMP), vict);

	       act (msg->hit_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	 }
	 else if (ch != vict)
	 {			/* Dam == 0 */
	    send_to_char (CCNRM (ch, C_CMP), ch);
	    if (attacktype == SKILL_2BACK)
	       act (msg->miss_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
	    else
	       act (msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	    send_to_char (CCNRM (ch, C_CMP), ch);

	    send_to_char (CCNRM (vict, C_CMP), vict);
	    if (attacktype == SKILL_2BACK)
	       act (msg->miss_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
	    else
	       act (msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	    send_to_char (CCNRM (vict, C_CMP), vict);

	    act (msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	 }
	 return 1;
      }
   }
   return 0;
}


void damage (struct char_data *ch, struct char_data *victim, int dam,
	int attacktype)
{
   int exp;
   struct obj_data *wielded;
   struct obj_data *hwielded;
   struct obj_data *vwielded;
   struct obj_data *vhwielded;
   wielded = GET_EQ (ch, WEAR_WIELD);
   hwielded = GET_EQ (ch, WEAR_2HWIELD);
   vwielded = GET_EQ (victim, WEAR_WIELD);
   vhwielded = GET_EQ (victim, WEAR_2HWIELD);

   if (GET_POS (victim) <= POS_DEAD)
   {
      log ("SYSERR: Attempt to damage a corpse.");
      return;			/* -je, 7/7/92 */
   }

   /* peaceful rooms */
   if (ch != victim && ROOM_FLAGGED (ch->in_room, ROOM_PEACEFUL))
   {
      send_to_char ("You feel ashamed trying to disrurb the peace of this room.\r\n", ch);
      return;
   }



   /* Checks for Proc Rooms */
   if (ch->in_room == real_room (30761))
   {
      if (GET_LEVEL (ch) < LVL_IMMORT && (!IS_NPC (ch)))
      {
	 GET_HIT (ch) = 1;
      }
      send_to_char ("&0&6As you prepare to attack, a beam of &0&b&8white energy&0&6 blasts from the wall and assaults your spirit!&0\r\n", ch);
      act ("&0$n is struck by a bolt of &0&b&8white energy&0 leaving $m badly injured.\r\n", FALSE, ch, 0, 0, TO_ROOM);
      return;
   }


   /* shopkeeper protection */
/*temp disable due to crashing - proky */
/*Disabled again! please do not un comment this Banyal*/
/*
   if (!ok_damage_shopkeeper (ch, victim))
      return;
*/
/*reduces damage for all things bar spells */
   if (!IS_NPC (ch) && !IS_NPC (victim))
      if (attacktype > MAX_SPELLS)
	 /* dam >>= 1; */
	 /* new to lower a little more Banyal */
	 dam = dam / 3;
   /* You can't damage an immortal! */
   if (!IS_NPC (victim) && (GET_LEVEL (victim) >= LVL_IMMORT))
      dam = 0;
   if (victim != ch)
   {
      if (GET_POS (ch) > POS_STUNNED)
      {
	 if (attacktype >= MAX_SPELLS)
	    if (!(FIGHTING (ch)))
	       set_fighting (ch, victim);

	 if (IS_NPC (ch) && IS_NPC (victim) && victim->master &&
	     (number (0, 100) == 0) && IS_AFFECTED (victim, AFF_CHARM) &&
	     (victim->master->in_room == ch->in_room))
	 {
	    if (FIGHTING (ch))
	       stop_fighting (ch);
	    hit (ch, victim->master, TYPE_UNDEFINED);
	    return;
	 }
      }
      if (GET_POS (victim) > POS_STUNNED && !FIGHTING (victim))
      {
	 if (attacktype >= MAX_SPELLS ||
	     (!PRF_FLAGGED (victim, PRF_PASSIVE) && attacktype < MAX_SPELLS)
	     || (IS_NPC (victim) && attacktype < MAX_SPELLS))
	    set_fighting (victim, ch);
      }
      if (MOB_FLAGGED (victim, MOB_MEMORY) && !IS_NPC (ch) &&
	  (GET_LEVEL (ch) < LVL_IMMORT))
	 remember (victim, ch);

   }
   if (victim->master == ch)
      stop_follower (victim);

   if (IS_AFFECTED (ch, AFF_INVISIBLE | AFF_HIDE))
      appear (ch);

/* Pets and charmes act as pc's*/

 if(IS_AFFECTED (ch, AFF_CHARM))
   dam >>= 1;
if(IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))
    dam >>= 1;

   if (IS_AFFECTED (victim, AFF_SANCTUARY))
      dam >>= 1;		/* 1/2 damage when sanctuary */

   if (IS_AFFECTED (victim, AFF_STONE_SKIN))
      dam >>= 1;

   if (IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS))
   {
      act ("$n's crushing blow frees $N from a magic which held $M motionless.",
	   FALSE, ch, 0, victim, TO_ROOM);
      act ("$n's blow shatters the magic paralyzing you!", FALSE, ch, 0,
	   victim, TO_VICT);
      act ("Your blow disrupts the magic keeping $N frozen.", FALSE, ch, 0,
	   victim, TO_CHAR);

      affect_from_char (victim, SPELL_MINOR_PARALYSIS);
      REMOVE_BIT (AFF2_FLAGS (ch), AFF2_MINOR_PARALYSIS);
   }
check_justice (ch, victim);
if (ch->desc && ch->desc->original)
  check_justice(ch->desc->original, victim);
   if (!pk_allowed)
   {
      check_killer (ch, victim);
     //  check_justice (ch, victim);

      if (PLR_FLAGGED (ch, PLR_KILLER) && (ch != victim))
	 dam = 0;
   }

   dam = MAX (MIN (dam, 1000), 0);
   alter_hit (victim, dam, 2);
   update_pos (victim);

if(!wielded && !hwielded && !vhwielded && !vwielded) {
 if (IS_AFFECTED3(ch, AFF3_VAMP_TOUCH)) {
   if(IS_NPC(ch))
   alter_hit (ch,( -1 * dam / 2), 2);
   else
   alter_hit (ch,(-1 * dam), 2);
 }
if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0)
 if(!IS_NPC(ch)) {
 if((GET_SKILL(ch, SKILL_VAMP_TOUCH)) > (number(0, 101)))
   alter_hit(ch, ( -1 * dam / 2), 2);
  if(number(0, 2))
  improve_skill(ch, SKILL_VAMP_TOUCH);
  }
}

   if (ch != victim)
      if (IS_NPC (ch));
/*  gain_exp(ch, ((GET_LEVEL(victim)/2) * (dam/4))); */
      else
      {
	 if ((GET_LEVEL (ch) - GET_LEVEL (victim)) > 10)
	    gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
	 else
	    gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
      }

   /*
    * skill_message sends a message from the messages file in lib/misc.
    * dam_message just sends a generic "You hit $n extremely hard.".
    * skill_message is preferable to dam_message because it is more
    * descriptive.
    *
    * If we are _not_ attacking with a weapon (i.e. a spell), always use
    * skill_message. If we are attacking with a weapon: If this is a miss or a
    * death blow, send a skill_message if one exists; if not, default to a
    * dam_message. Otherwise, always send a dam_message.
    */
   if (!IS_WEAPON (attacktype))
      skill_message (dam, ch, victim, attacktype);
   else
   {
      if (GET_POS (victim) == POS_DEAD || dam == 0)
      {
	 if (!skill_message (dam, ch, victim, attacktype))
	    dam_message (dam, ch, victim, attacktype);
      }
      else
	 dam_message (dam, ch, victim, attacktype);
   }
// stops these shileds from hurting casters from spells casted -Banyal
if (attacktype > MAX_SPELLS) {
   if (IS_AFFECTED2 (victim, AFF2_FIRESHIELD))
   {
      if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	 act ("&1&bThe globe around your body absorbs the burning flames!&0", FALSE, ch, 0, 0, TO_CHAR);
      else
      {
	 act ("&1Your limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_CHAR);
	 act ("&1$n&0&1's limbs are seared by your shield of flames.&0", FALSE, ch, 0, victim, TO_VICT);
	 act ("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_NOTVICT);
      }
   }
   if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD))
   {
      if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	 act ("&4&bThe globe around your body absorbs the killing ice!&0", FALSE, ch, 0, 0, TO_CHAR);
      else
      {
	 act ("&4You are impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_CHAR);
	 act ("&4$n&0&4 is impaled on your shield of ice.&0", FALSE, ch, 0, victim, TO_VICT);
	 act ("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_NOTVICT);
      }
   }
   if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
   {
      if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
      {
	 act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	 act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	 act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      }
      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
      {
	 act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	 act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	 act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      }
   }
} // end attacktype check

   /* Use send_to_char -- act() doesn't send message if you are DEAD. */
   switch (GET_POS (victim))
   {
   case POS_MORTALLYW:
      act ("$n is mortally wounded, and will die soon, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are mortally wounded, and will die soon, if not aided.\r\n", victim);
      break;
   case POS_INCAP:
      act ("$n is incapacitated and will slowly die, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are incapacitated an will slowly die, if not aided.\r\n", victim);
      break;
   case POS_STUNNED:
      act ("$n is stunned, but will probably regain consciousness again.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You're stunned, but will probably regain consciousness again.\r\n", victim);
      break;
   case POS_DEAD:
      act ("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are dead!\r\n", victim);
      break;

   default:			/* >= POSITION SLEEPING */
      if (dam > (GET_MAX_HIT (victim) >> 2))
	 act ("That really did HURT!", FALSE, victim, 0, 0, TO_CHAR);

      if (GET_HIT (victim) < (GET_MAX_HIT (victim) >> 2))
      {
	 sprintf (buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		  CCRED (victim, C_SPR), CCNRM (victim, C_SPR));
	 send_to_char (buf2, victim);
	 if (MOB_FLAGGED (victim, MOB_WIMPY) && (ch != victim))
	 {
	    do_flee (victim, "", 0, 0);
	    if (FIGHTING (ch))
	       stop_fighting (ch);
	 }




      }
      if (!IS_NPC (victim) && GET_WIMP_LEV (victim) && (victim != ch) &&
	  GET_HIT (victim) < GET_WIMP_LEV (victim))
      {
	 send_to_char ("You attempt to flee!\r\n", victim);
	 do_flee (victim, "", 0, 0);
	 if (FIGHTING (ch))
	    stop_fighting (ch);

      }
      break;
   }

   if (!AWAKE (victim))
      if (FIGHTING (victim))
	 stop_fighting (victim);

   if (GET_POS (victim) == POS_DEAD)
   {
      if (IS_NPC (victim) || victim->desc)
	 if (IS_AFFECTED (ch, AFF_GROUP))
	    group_gain (ch, victim);
	 else
	 {
	    exp = MIN (max_exp_gain (ch), GET_EXP (victim));
	    /* Calculate level-difference bonus */
	    if (IS_NPC (ch))
	       exp += MAX (0, (exp * MIN (2, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);
	    else
	       exp += MAX (0, (exp * MIN (3, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);
	    exp = MAX (exp, 1);
	    /*check for mortal */
	    if (IS_NPC (victim))
	       exp = GET_EXP (victim);
	    else
	       /*I will give 10 k exp per level for a opp race pkill
	          and a 3 k exp per level for a sim race pkill */
	    if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
	       /* This was being badly abused, ask me Banyal */
	       /* exp = GET_LEVEL(victim) * 7000; */
	       exp = 70;
	    else
	       /*  exp = GET_LEVEL(victim) * 2000; */
	       exp = 70;
	    /*Trophy decrease */
	    exp = perform_trophy_decrease (ch, victim, exp);
	    if (exp > 1)
	    {
	       sprintf (buf2, "You receive your share of experience.\r\n");
	       send_to_char (buf2, ch);
	    }
	    else
	       send_to_char ("You receive your share of experience.\r\n", ch);
	    /*  sprintf(buf, "Not grouped before modified %d.\r\n",
	       exp);
	       send_to_char(buf, ch);
	     */
	    if (GET_LEVEL (ch) < GET_LEVEL (victim))
	       exp = exp_highlevel_bonus (exp, (GET_LEVEL (victim) - GET_LEVEL (ch)));
	    /*              sprintf(buf, "Not grouped after modified
	       %d.\r\n", exp);
	       send_to_char(buf, ch);
	     */ gain_exp (ch, exp);
	    change_alignment (ch, victim);
	 }
      if (!IS_NPC (victim))
      {
	 sprintf (buf2, "%s killed by %s at %s", GET_NAME (victim), GET_NAME (ch),
		  world[victim->in_room].name);
	 mudlog (buf2, BRF, LVL_IMMORT, TRUE);
	 if (MOB_FLAGGED(ch, MOB_MEMORY))
	 //   forget(ch, victim);
        Forgive_The_Basterd(victim);
      }
    Forgive_The_Basterd(ch);
      die (victim, ch);
   }
}



void
hit (struct char_data *ch, struct char_data *victim, int type)
{
   int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vw_type= 0,
     vdam = 0;
   struct obj_data *wielded;
   struct obj_data *hwielded;
   struct obj_data *vwielded;
   struct obj_data *vhwielded;
   extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
   extern struct str_app_type str_app[];
   extern struct dex_app_type dex_app[];
   int backstab_mult (int level);

   bool RIPOSTT = FALSE;
   bool DODGE = FALSE;
   bool PARRY = FALSE;

   if(event_target_valid(victim) == 0 )
   {
      if(ch)
	 stop_fighting (ch);
      return;
   }

   if(event_target_valid(ch) == 0 )
   {
	 stop_fighting (victim);
         return;
   }

   wielded = GET_EQ (ch, WEAR_WIELD);
   hwielded = GET_EQ (ch, WEAR_2HWIELD);
   vwielded = GET_EQ (victim, WEAR_WIELD);
   vhwielded = GET_EQ (victim, WEAR_2HWIELD);

   /* check if the character has a fight trigger */
   fight_mtrigger (ch);


   if (ch->in_room != victim->in_room)
   {
      if (FIGHTING (ch) && FIGHTING (ch) == victim)
	 stop_fighting (ch);
      return;
   }

if((FIGHTING(ch) != victim) &&
 ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell(ch, SPELL_BLINDNESS)))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
}


   if (GET_SKILL (victim, SKILL_DODGE))
   {
      if (GET_POS (victim) > POS_SITTING)
      {
	 hurm = number (35, 131);
	 hurm1 = number (20, 50);
	 hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	 hurm += GET_HITROLL (ch);
	 hurm1 += dex_app[GET_DEX (victim)].defensive;
         if(IS_NPC(victim))
	 hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
         else
         hurm1 += GET_SKILL (victim, SKILL_DODGE);
	 if (number (1, 10) < 5)
	    improve_skill (victim, SKILL_DODGE);
	 if (hurm1 > hurm)
	    DODGE = TRUE;
      }
   }


   if (GET_SKILL (victim, SKILL_PARRY))
   {
      if (vwielded || vhwielded)
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (45, 141);
	    hurm1 = number (20, 60);
	    hurm += GET_HITROLL (ch);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_PARRY);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_PARRY);
	    if (hurm1 > hurm)
	    {
	       PARRY = TRUE;
	    }
	 }
      }
   }

   if (GET_SKILL (victim, SKILL_RIPOST))
   {
      if (vwielded || vhwielded)
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (55, 200);
	    hurm1 = number (20, 50);
	    hurm += GET_HITROLL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .85;
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_RIPOST);
	    if (hurm1 > hurm)
	    {
	       RIPOSTT = TRUE;
	       vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
	       vdam += GET_DAMROLL (victim);

	       if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
	       else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
	       else
	       {
		  if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
		     vw_type = victim->mob_specials.attack_type + TYPE_HIT;
		  else
		     vw_type = TYPE_HIT;
	       }
	       if (vwielded)
		  vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
	       else if (vhwielded)
		  vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
	       else
	       {
		  if (IS_NPC (victim))
		  {
		     vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
		  }
		  else
		     vdam += number (0, 2);
	       }
	       if (GET_POS (ch) < POS_FIGHTING)
		  vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
	       vdam = MAX (1, 70);
	    }
	 }
      }
   }

   mprog_hitprcnt_trigger (ch, FIGHTING (ch));
   mprog_fight_trigger (ch, FIGHTING (ch));

   if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
   else if (hwielded && GET_OBJ_TYPE (hwielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (hwielded, 3) + TYPE_HIT;
   else
   {
      if (IS_NPC (ch) && (ch->mob_specials.attack_type != 0))
	 w_type = ch->mob_specials.attack_type + TYPE_HIT;
      else
	 w_type = TYPE_HIT;
   }



   /* Calculate the raw armor including magic armor.  Lower AC is better. */

   if (!IS_NPC (ch))
      calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
   else				/* THAC0 for monsters is set in the HitRoll */
      calc_thaco = 20;

   calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
   calc_thaco -= GET_HITROLL (ch);
   calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
   calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
   diceroll = number (1, 29);

   victim_ac = GET_AC (victim) / 15;

   if (AWAKE (victim))
      victim_ac += dex_app[GET_DEX (victim)].defensive;

   victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */

   /* decide whether this is a hit or a miss */
   if ((((diceroll < 20) && AWAKE (victim)) &&
	((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
   {
      if (type == SKILL_BACKSTAB)
	 damage (ch, victim, 0, SKILL_BACKSTAB);
      else
	 damage (ch, victim, 0, w_type);
   }
   else
   {
      /* okay, we know the guy has been hit.  now calculate damage. */
      dam = str_app[STRENGTH_APPLY_INDEX (ch)].todam;
      dam += GET_DAMROLL (ch);

      if (wielded)
      {
	 if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
	 else
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
      else if (hwielded)
      {
	 if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2));
	 else
	    dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2)) +
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
      else
      {
	 if (IS_NPC (ch))
	 {
	    dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	 }
	 else
	    dam += number (0, 2);	/* Max. 2 dam with bare hands */
      }

      if (GET_POS (victim) < POS_FIGHTING)
	 dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;	/*mark */
      /* Position  sitting  x 1.33 */
      /* Position  resting  x 1.66 */
      /* Position  sleeping x 2.00 */
      /* Position  stunned  x 2.33 */
      /* Position  incap    x 2.66 */
      /* Position  mortally x 3.00 */

      dam = MAX (1, dam);	/* at least 1 hp damage min per hit */

      if (type == SKILL_BACKSTAB)
      {
	 dam *= backstab_mult (GET_LEVEL (ch));
	 damage (ch, victim, dam, SKILL_BACKSTAB);
      }
      else
      {
	 if (RIPOSTT)
	 {
	    act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    damage (victim, ch, vdam, vw_type);
	 }
	 else if (PARRY)
	 {
	    act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_PARRY);
	    if (!FIGHTING (ch))
	       set_fighting (ch, victim);
	    if (!FIGHTING (victim))
	       set_fighting (victim, ch);
	 }
	 else if (DODGE)
	 {
	    act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_DODGE);
	    if (!FIGHTING (ch))
	       set_fighting (ch, victim);
	    if (!FIGHTING (victim))
	       set_fighting (victim, ch);
	 }
	 else
	 {
	    if (dam > 0)
	    {
	       /*ok here we hit victem so check for stone skin */
	       if (IS_AFFECTED (victim, AFF_STONE_SKIN))
	       {
		  if (number (0, 10) <= 9)
		  {
		     decrease_modifier (victim);
		     dam = number (0, 3);
		  }
	       }
	       if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
	       {
		  if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
		  if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
	       }
	       if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD | AFF2_FIRESHIELD))
	       {
		  if (!IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
		     GET_HIT (ch) -= (int) (dam / 3);
	       }
	    }
	    if (victim)
	       hitprcnt_mtrigger (victim);
	    damage (ch, victim, dam, w_type);
	 }
      }

      /* check if the victim has a hitprcnt trigger */

   }
}

void
hit2 (struct char_data *ch, struct char_data *victim, int type)
{
   struct obj_data *wielded = GET_EQ (ch, WEAR_WIELD2);
   struct obj_data *vwielded = GET_EQ (victim, WEAR_WIELD);
   struct obj_data *vhwielded = GET_EQ (victim, WEAR_2HWIELD);
   int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vdam = 0,
     vw_type = 0;
   bool RIPOSTT = FALSE;
   bool DODGE = FALSE;
   bool PARRY = FALSE;

   extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
   extern struct str_app_type str_app[];
   extern struct dex_app_type dex_app[];

   int backstab_mult (int level);

   if (ch->in_room != victim->in_room)
   {
      if (FIGHTING (ch) && FIGHTING (ch) == victim)
	 stop_fighting (ch);
      return;
   }


   if (GET_SKILL (victim, SKILL_DODGE))
   {
      if (GET_POS (victim) > POS_SITTING)
      {
	 hurm = number (55, 141);
	 hurm1 = number (20, 40);
	 hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	 hurm += GET_HITROLL (ch);
	 hurm1 += dex_app[GET_DEX (victim)].defensive;
         if(IS_NPC(victim))
         hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
         else
	 hurm1 += GET_SKILL (victim, SKILL_DODGE);
	 if (number (1, 10) < 5)
	    improve_skill (victim, SKILL_DODGE);
	 if (hurm1 > hurm)
	 {
	    DODGE = TRUE;
	 }
      }
   }
/* Parry dodge rip harder on secound hand */
   if (GET_SKILL (victim, SKILL_PARRY))
   {
      if (vwielded || vhwielded)
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (65, 141);
	    hurm1 = number (15, 40);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm += GET_HITROLL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_PARRY);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_PARRY);
	    if (hurm1 > hurm)
	    {
	       PARRY = TRUE;
	    }
	 }
      }
   }

   if (GET_SKILL (victim, SKILL_RIPOST))
   {
      if (vwielded || vhwielded)
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (90, 400);
	    hurm1 = number (15, 40);
	    hurm += GET_HITROLL (ch);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .8;
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_RIPOST);
	    if (hurm1 > hurm)
	    {
	       RIPOSTT = TRUE;
	       vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
	       vdam += GET_DAMROLL (victim);
	       if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
	       else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
	       else
	       {
		  if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
		     vw_type = victim->mob_specials.attack_type + TYPE_HIT;
		  else
		     vw_type = TYPE_HIT;
	       }

	       if (vwielded)
		  vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
	       else if (vhwielded)
		  vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
	       else
	       {
		  if (IS_NPC (victim))
		  {
		     vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
		  }
		  else
		     vdam += number (0, 2);
	       }

	       if (GET_POS (ch) < POS_FIGHTING)
		  vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;

	       vdam = MAX (1, 70);
	    }
	 }
      }
   }

   mprog_hitprcnt_trigger (ch, FIGHTING (ch));
   mprog_fight_trigger (ch, FIGHTING (ch));

   if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
   else
   {
      if (IS_NPC (ch) && (ch->mob_specials.attack_type != 0))
	 w_type = ch->mob_specials.attack_type + TYPE_HIT;
      else
	 w_type = TYPE_HIT;
   }



   /* Calculate the raw armor including magic armor.  Lower AC is better. */

   if (!IS_NPC (ch))
      calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
   else				/* THAC0 for monsters is set in the HitRoll */
      calc_thaco = 20;

   calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
   calc_thaco -= GET_HITROLL (ch);
   calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
   calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
   diceroll = number (1, 25);

   victim_ac = GET_AC (victim) / 15;

   if (AWAKE (victim))
      victim_ac += dex_app[GET_DEX (victim)].defensive;

   victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */

   /* decide whether this is a hit or a miss */
   if ((((diceroll < 20) && AWAKE (victim)) &&
	((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
   {
      if (type == SKILL_2BACK)
	 damage (ch, victim, 0, SKILL_2BACK);
      else
	 damage (ch, victim, 0, w_type);
   }
   else
   {
      /* okay, we know the guy has been hit.  now calculate damage. */
      dam = str_app[STRENGTH_APPLY_INDEX (ch)].todam;
      dam += GET_DAMROLL (ch);

      if (wielded)
      {
	 if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
	 else
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
      else
      {
	 if (IS_NPC (ch))
	 {
	    dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	 }
	 else
	    dam += number (0, 2);	/* Max. 2 dam with bare hands */
      }				/*Banyal add class mods here */

      if (GET_POS (victim) < POS_FIGHTING)
	 dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;
      /* Position  sitting  x 1.33 */
      /* Position  resting  x 1.66 */
      /* Position  sleeping x 2.00 */
      /* Position  stunned  x 2.33 */
      /* Position  incap    x 2.66 */
      /* Position  mortally x 3.00 */

      dam = MAX (1, dam);	/* at least 1 hp damage min per hit */

      if (type == SKILL_2BACK)
      {
	 dam *= backstab_mult (GET_LEVEL (ch));
	 damage (ch, victim, dam, SKILL_2BACK);
      }
      else
      {
	 if (RIPOSTT)
	 {
	    act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    damage (victim, ch, vdam, vw_type);
	    improve_skill (victim, SKILL_RIPOST);
	 }
	 else if (PARRY)
	 {
	    act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_PARRY);
	 }
	 else if (DODGE)
	 {
	    act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_DODGE);
	 }
	 else
	 {
	    if (dam > 0)
	    {
	       /*ok here we hit victem so check for stone skin */
	       if (IS_AFFECTED (victim, AFF_STONE_SKIN))
	       {
		  if (number (0, 10) <= 9)
		  {
		     decrease_modifier (victim);
		     dam = number (0, 3);
		  }
	       }
	       else if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
	       {
		  if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
		  if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
	       }

	    }
	    damage (ch, victim, dam, w_type);
	 }
      }
   }
}


int
weapon_special (struct obj_data *wpn, struct char_data *ch)
{
   extern struct index_data *obj_index;
   int (*name) (struct char_data * ch, void *me, int cmd, char *argument);

   SPECIAL (blind_weapon);
   SPECIAL (fireball_weapon);
   SPECIAL (lightning_weapon);
   SPECIAL (vampiric_weapon);
   SPECIAL (fullharm_weapon);
   SPECIAL (curse_weapon);
   SPECIAL (holyw_weapon);

   name = obj_index[GET_OBJ_RNUM (wpn)].func;
   if (name != blind_weapon && name != fireball_weapon &&
       name != curse_weapon && name != fullharm_weapon &&
       name != vampiric_weapon && name != lightning_weapon &&
       name != holyw_weapon)
      return 0;
   return (name) (ch, wpn, 0, "");
}


#define MAJORPCODE 1
/* control the fights going on.  Called every 2 seconds from comm.c. */
void
perform_violence (void)
{
   struct char_data *ch;
   struct char_data *tch;
   struct char_data *vict;
   struct obj_data *wpn;
   extern struct index_data *mob_index;
   int prob, hurm, hurm2;
   bool tmp_flag;

   for (ch = combat_list; ch; ch = next_combat_list)
   {
      next_combat_list = ch->next_fighting;
      if (FIGHTING (ch) == NULL || ch->in_room != FIGHTING (ch)->in_room)
      {
	 stop_fighting (ch);
	 continue;
      }
      tmp_flag = FALSE;
#ifdef MAJORPCODE
      if (ch->char_specials.action_delays[ACT_DELAY_DISARM] > 0)
	 --ch->char_specials.action_delays[ACT_DELAY_DISARM];

      if (IS_AFFECTED (ch, AFF_MAJOR_PARA))
      {
	 send_to_char ("You remain paralyzed and can't do a thing to defend yourself..\r\n",
		       ch);
	 act ("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
	      FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
	 continue;
      }
      if (IS_AFFECTED (ch, AFF_MAJOR_PARA))
      {
	 act ("You couldn't budge a feather in your present condition.", FALSE, ch, 0, 0, TO_CHAR);
	 act ("$n is too preoccupied with $s nervous system problem to fight.", FALSE, ch, 0, 0, TO_ROOM);
	 continue;
      }
#endif

      if (DisarmRecovery (ch) == FALSE)
	 continue;
      if (PLR_FLAGGED (ch, PLR_CASTING))
	 continue;


      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
      {
	 hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	 if (IS_AFFECTED (ch, AFF_HASTE) && FIGHTING (ch))
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	    }
	 }
	 if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	    }
	 }
      }


      if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
	 (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");

      if (IS_NPC (ch))
	 if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
	 {
	    vict = NULL;
	    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
	       if (FIGHTING (tch) == ch && !IS_NPC (tch))
		  if (vict == NULL || GET_HIT (tch) < GET_HIT (vict))
		     vict = tch;

	    if (vict != NULL && FIGHTING (ch) != vict)
	    {

	       if (!IS_AFFECTED (ch, AFF_BLIND))
                if (!affected_by_spell (ch, SPELL_BLINDNESS))
               if (!affected_by_spell (ch, SPELL_SMOKE))
              if (CAN_SEE(ch, vict))
		  if (!number (0, (MAX (10, (30 - GET_LEVEL (ch))))))
		  {
		     stop_fighting (ch);
		     act ("$n switches to $N", FALSE, ch, 0, vict, TO_ROOM);
		     hit (ch, vict, TYPE_UNDEFINED);
		  }
	    }
	 }


      if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
      {

	 struct obj_data *wielded2 = GET_EQ (ch, WEAR_WIELD2);

	 if (wielded2)
	 {
	    prob = 0;
	    prob = GET_SKILL (ch, SKILL_DUAL_WIELD);
	    if (GET_LEVEL (ch) < 15)
	       if (number (0, 2))
		  prob = prob - 10;
	    if (number (1, 101) < prob)
	    {
	       if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	       {
		  hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		  improve_skill (ch, SKILL_DUAL_WIELD);
	       }
	       if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		  (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
	       if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
	       {
		  hurm = 0;
		  hurm = number (1, 100);
		  hurm2 = 0;
		  hurm2 = number (1, 101);
		  if (hurm < prob)
		  {
		     if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		     {
			hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
			improve_skill (ch, SKILL_DUAL_WIELD);
		     }
		  }
	       }
	    }

	    if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
	    {
	       prob = 0;
	       prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
	       if (GET_LEVEL (ch) < 15)
		  if (number (0, 2))
		     prob = prob - 10;

	       if (number (1, 101) < prob)
	       {
		  if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON ||
		      !weapon_special (wpn, ch))
		     hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		  if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		     (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
		  improve_skill (ch, SKILL_DUAL_WIELD);
	       }
	    }
	 }
      }

      if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
      {
	 prob = 0;
	 prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);

	 if (GET_LEVEL (ch) < 15)
	    if (number (0, 2))
	       prob = prob - 10;

	 if (number (1, 101) < prob)
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);

	    if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
	       (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
	    improve_skill (ch, SKILL_DOUBLE_ATTACK);
	 }
      }

      if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
      {
	 prob = 0;
	 prob = number (1, 101);
	 if ((number (1, 101) - GET_LEVEL (ch) + 10) < prob)
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	    }
	 }
      }

      if (tmp_flag)
	 continue;

   }
}




void
improve_skill (struct char_data *ch, int skill)
{
   extern char *spells[];
   int percent = GET_ISKILL (ch, skill);
   int newpercent;
   int maxpercent;
   char skillbuf[MAX_STRING_LENGTH];

   if (number (1, 140) > GET_WIS (ch) + GET_INT (ch))
      return;
   if (skill == SKILL_DOUBLE_ATTACK ||
       SKILL_DUAL_WIELD || SKILL_PARRY ||
       SKILL_DODGE || SKILL_RIPOST)
      if (number (15, 45) > GET_WIS (ch) + GET_INT (ch))
	 return;
   if (percent >= 999 || percent <= 0)
      return;
   if (skill == SKILL_DOUBLE_ATTACK ||
       SKILL_DUAL_WIELD || SKILL_PARRY ||
       SKILL_DODGE || SKILL_RIPOST || SKILL_VAMP_TOUCH)
   {
      newpercent = 1;
   }
   else
   {
      newpercent = number (1, 5);
   }
   percent += newpercent;
   maxpercent = return_max_skill (ch, skill);
   if (percent > maxpercent)
   {
      SET_SKILL (ch, skill, maxpercent);
      return;
   }
   percent = MIN (percent, 1000);
   SET_SKILL (ch, skill, percent);
   sprintf (skillbuf, "&8You feel your skill in %s improving.\r\n&0", spells[skill]);
   send_to_char (skillbuf, ch);
}

#define NUM_OF_FUN_PARTS 13	/* the following is some sicko's code
				   named Patrick J. Dughi, I changed it a great deal
				   to fit Hubis' theme. */

struct fun_body_piece
{
   int number;			/* this parts number */
   char name[40];		/* names of this part */
   int nname;			/* some parts you couldn't trace to an owner */
   char sdesc[128];		/* short desc: that of inventory  */
   char rdesc[128];		/* room desc: when on ground */
   int take;			/* some body parts don't transfer well */
   char actout[128];		/* what people in room see upon death, using
				   act() */
   char actkil[128];		/* what the killer sees upon dismemberment, using
				   act() */
};

struct fun_body_piece parts[NUM_OF_FUN_PARTS] =
{
   {0, "eyeball eye", 1, "the eye of %s", "The eyeball of %s is lying here.",
    1, "$n's attack knocks an eye out of $N!",
    "Your attack knocks an eye out of $N!"},
   {1, "arm", 1, "one of %s's arms", "%s'arm is lying here on the ground.",
    1, "$n's removes $N's arm!",
    "You remove $N's arm!"},
   {2, "right leg", 1, "%s's right leg", "%s's right leg is here.",
    1, "$N gracefully cuts his leg off! $n chortles merrily!",
    "You watch in awe as $N cuts his leg off!"},
{3, "left leg", 1, "the left leg of %s", "The left leg of %s is lying here.",
 1, "$n's screams and strikes $N leg off at the hip!",
 "With a scream of rage, you strike $N's leg off!"},
{4, "head", 1, "%s's ugly head", "%s's head is lying here, staring at you.",
 1, "$n severs $N's in a move composed of speed and grace!",
 "With speed and grace, you sever $N's head!"},
   {5, "thumb", 1, "%s's thumb", "One of %s's thumbs is lying here.",
    1, "$n's attack severs a thumb from $N!",
    "Your attack severs a thumb from $N!"},
   {6, "finger", 1, "%s's finger", "One of %s fingers is lying here.",
    1, "$n's attack severs a finger from $N!",
    "Your attack severs a finger from $N!"},
   {7, "heart", 1, "the once beating heart of %s",
    "%s's once beating heart lies here.",
    1, "$n's uses pure strength to eviscirate $N!",
    "Your depend on your fierce strength, and eviscerate $N!"},
   {8, "spine", 1, "the spine of %s", "The spine of %s is lying here.",
    1, "$n's attack shatters $N's spine!",
    "Your attack shatters $N's spine!"},
   {9, "intestine", 0, "An icky pile of intestines",
    "An icky pile of intestines is here - colon and all.",
    0, "$n hits so hard, that $N pukes up his intestines !",
    "You hit $N so hard that he pukes up his intestines!"},
   {10, "puke vomit", 0, "chunky vomit", "Some one upchucked on the floor here.",
    0, "$N throws up all over!",
    "$N throws up all over you!"},
   {11, "nose", 1, "%s's nose", "%s lost his nose here.",
    1, "$n cackles gleefuly as he removes $N's nose!",
    "You cackle as you sever $N's nose!"},
   {12, "ear", 1, "%s's ear", "%'s bloody severed ear is here.",
    1, "$n's grabs $N's ear and rips it off!",
    "Your rip off $N's ear!"}
};

void
make_fun_body_pieces (struct char_data *ch, struct char_data *killer)
{
   struct obj_data *piece;
   int i;
   extern int max_npc_corpse_time;

   /*lets check and see if we even GET body parts eh - i mean, they're
      fun, but it wouldn't be quite as fun if they were always there! */

   if (number (1, 5) < 4)
      return;

   /*Then Horray! We's got parts! */
   /* But which part? */
   i = number (0, 20);		/* 20 pieces should be okay */
   piece = create_obj ();

   /*now, everything we have should be in the structures neh? */
   /*name first */
   piece->name = str_dup (parts[i].name);
   /*then lets see about the descs */
   if (parts[i].nname)
   {
      sprintf (buf2, parts[i].sdesc, GET_NAME (ch));
      piece->short_description = str_dup (buf2);
      sprintf (buf2, parts[i].rdesc, GET_NAME (ch));
      piece->description = str_dup (buf2);
   }
   else
   {
      piece->short_description = str_dup (parts[i].sdesc);
      piece->description = str_dup (parts[i].rdesc);
   }
   /*well, now we know how it looks, lets see if we wanna take it. */
   if (parts[i].take)
   {
      GET_OBJ_WEAR (piece) = ITEM_WEAR_TAKE;
   }
   /*  and lets see how it got here in the first place neh? */
   act (parts[i].actout, FALSE, killer, 0, ch, TO_ROOM);
   act (parts[i].actkil, FALSE, killer, 0, ch, TO_CHAR);

/* setup the rest of the stats any object needs */
   piece->item_number = NOTHING;
   piece->in_room = NOWHERE;
   GET_OBJ_TYPE (piece) = ITEM_CONTAINER;
   GET_OBJ_VAL (piece, 0) = 0;	/* You can't store stuff in a corpse */
   GET_OBJ_VAL (piece, 3) = 1;	/* corpse identifier */
   GET_OBJ_EXTRA (piece) = ITEM_NODONATE;
   GET_OBJ_WEIGHT (piece) = 1;
   GET_OBJ_RENT (piece) = 1;

   /* Note - you may have some trouble with corpse decay here -
      improper settings WILL cause the mud to crash if you do not correcly
      decay.  Right now, the pieces are setup as a corpse, so if you made any
      changes to your corpse identifiers, fix it above. */

   GET_OBJ_TIMER (piece) = max_npc_corpse_time;

   /* and thats all folks! */
   obj_to_room (piece, ch->in_room);
}

bool
PickupDisarmedWeapon (struct char_data *ch)
{
   struct obj_data *obj_i;
   bool retval = FALSE, done = FALSE;
   char arg[MAX_INPUT_LENGTH];

   ACMD (do_wield);
   int cmd_wield;

   cmd_wield = find_command ("wield");

   for (obj_i = world[ch->in_room].contents; obj_i && !done; obj_i = obj_i->next_content)
   {

      if (IS_SET (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED) && (obj_i->last_to_hold == ch))
      {
	 obj_from_room (obj_i);
	 obj_to_char (obj_i, ch);

	 if (!IS_FIGHTING (ch))
	 {
	    act ("$n eagerly reaches for $o.", FALSE, ch, obj_i, 0, TO_ROOM);
	 }
	 else
	 {
	    act ("$n extends $s hands, finally getting a steady hold of $o.", FALSE, ch, obj_i, 0, TO_ROOM);
	 }

	 REMOVE_BIT (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED);

	 if (obj_i->name)
	    sprintf (arg, "%s", obj_i->name);



	 if (IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_WIELD) ||
	     IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_2HWIELD))
	    do_wield (ch, arg, cmd_wield, -4);

	 done = TRUE;
	 retval = TRUE;
      }
   }

   return retval;
}

/* Make sure 'ch' is still fighting someone.  If not, disarm penalties don't apply anymore so remove them.
 *
 */

bool
DisarmCheck (struct char_data * ch)
{
   bool retval;
   struct affected_type *af, *af_next;

   if (ch->char_specials.fighting == NULL)
   {
      ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = 0;
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = 0;
      ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = 0;
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = 0;

      if (IS_AFFECTED (ch, AFF_DROPPED_PRIM) || IS_AFFECTED (ch, AFF_DROPPED_SECOND))
      {
	 while (PickupDisarmedWeapon (ch));

	 for (af = ch->affected; af; af = af_next)
	 {
	    af_next = af->next;
	    if (af->type == SKILL_DISARM_DROPPED_WEAP)
	    {
	       affect_remove (ch, af);
	    }
	 }
      }
      if (IS_AFFECTED (ch, AFF_FUMBLING_PRIM) || IS_AFFECTED (ch, AFF_FUMBLING_SECOND))
      {
	 for (af = ch->affected; af; af = af_next)
	 {
	    af_next = af->next;
	    if (af->type == SKILL_DISARM_FUMBLING_WEAP)
	    {
	       affect_remove (ch, af);
	    }
	 }
      }
      retval = TRUE;
   }
   else
   {
      retval = FALSE;
   }

   return retval;
}

void
HandleFumblingWeapon (struct char_data *ch, int action_delay_type, int affect_type)
{
   bool done = FALSE;
   struct affected_type *af, *af_next;

   --ch->char_specials.action_delays[(int) action_delay_type];

   if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
   {
      for (af = ch->affected; !done && af; af = af_next)
      {
	 af_next = af->next;
	 if (af->type == SKILL_DISARM_FUMBLING_WEAP && af->bitvector & affect_type)
	 {
	    affect_remove (ch, af);
	    done = TRUE;
	 }
      }

      act ("$n finally regains full control of $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You finally regain full control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
   }
   else
   {
      act ("$n is fumbling for a steady hold of $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You can't seem to get a firm, steady hold of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
   }
}

void
HandleDroppedWeapon (struct char_data *ch, int action_delay_type, int affect_type)
{
   bool get_weap = FALSE, aff_drop_expired = FALSE, done;
   struct affected_type *af, *af_next;

   --ch->char_specials.action_delays[(int) action_delay_type];

   if (IS_NPC (ch))
   {
      if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
      {
	 get_weap = TRUE;
      }
   }
   else
   {
      if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
      {
	 aff_drop_expired = TRUE;
      }
   }

   /* Here, if get_weap is true, it's time for a _MOB_ to look in room for its dropped weapon.
      When none can be found, another char picked it up, so it stops trying for it and all penalties
      don't apply anymore.  this is why the drop affect expires regardless. */

   if (get_weap)
   {
      if (PickupDisarmedWeapon (ch) == FALSE)
      {
	 ch->char_specials.action_delays[(int) action_delay_type] = 0;
      }
      aff_drop_expired = TRUE;
   }
   else
   {				/* if time to look for MOB's dislodged item */
      if (IS_NPC (ch))
      {
	 act ("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      }
   }

   /* remove either
      a) all the affect for dropped weapon if either all weapons were recovered or the weapons to be
      recovered are no longer in the room or
      b) some of the affect for dropped weapons if all weapons haven't been recovered. */

   if (aff_drop_expired)
   {
      for (af = ch->affected, done = FALSE; !done && af; af = af_next)
      {
	 af_next = af->next;
	 if (af->type == SKILL_DISARM_DROPPED_WEAP && af->bitvector & affect_type)
	 {
	    affect_remove (ch, af);
	    done = TRUE;
	 }
      }
   }
}

/* This function serves to allow:

 *  1) MOBs/PCs to have their penalties removed upon recovery from a fumble.
 *     If they're fighting no one (ie. vict fleed), they recover immediately.
 *  2) MOBs to pick up and re-wield both weapons when their ACT_DELAY_DROPPED_WEAP action_delay[] expires.
 *
 *  PCs don't need automatic weapon recovery, as they can manually do it.
 *
 *  This function is called from perform_violence(), and thus is only called
 *  when the PC/MOB (whose ACT_DELAY_FUMBLING_* or ACT_DELAY_DROPPED_*
 *  action_delays are still valid) is in combat.  Since 'disarm' can't be used
 *  until after combat has been initiated, and the affects it produces are
 *  really only useful while in combat; so when the affected PC/MOB's assailant
 *  has fled the room, it'll be perfectly fine to just clear all AFFECT-flags
 *  and clear all action_delays[] associated with 'disarm'.  This includes when
 *  a weapon is dislodged and laying on the ground--the disarmed MOB will
 *  immediately pick it up, and the disarmed PC may immediately pick his/hers
 *  up.
 *
 *  Note: MOB/PCs can NOT be both FUMBLING_WEAP and DROPPED_WEAP for same weap.
 *
 *  Return TRUE if the PC/MOB can attack.  Otherwise, return FALSE.
 */

bool
DisarmRecovery (struct char_data *ch)
{
   bool retval = FALSE;

   /* if not fumbling nor regaining dropped weap, let em strike back */
   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] == 0)
   {
      retval = TRUE;
   }
   /* if PC/MOB isn't fighting anyone anymore (vict fleed), remove
      all affect-flags and pick up all dropped weapons */

   if (DisarmCheck (ch))
   {
      retval = TRUE;
   }
   /* handle PC/MOB who is fumbling their primary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0 && AWAKE (ch))
   {
      HandleFumblingWeapon (ch, ACT_DELAY_FUMBLING_PRIM, AFF_FUMBLING_PRIM);
      retval = TRUE;
   }
   /* handle PCs/MOBs that are fumbling their secondary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0 && AWAKE (ch))
   {
      HandleFumblingWeapon (ch, ACT_DELAY_FUMBLING_SECOND, AFF_FUMBLING_SECOND);
      retval = TRUE;
   }
   /* handle PC/MOB who has been disarmed of their primary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0 && AWAKE (ch))
   {
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_PRIM, AFF_DROPPED_PRIM);
   }
   /* handle PC/MOB who has been disarmed of their secondary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0 && AWAKE (ch))
   {
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_SECOND, AFF_DROPPED_SECOND);
   }
   /* this point can only be reached if MOB/PC is affected by disarm in some way */

   return retval;
}



void
StopMercifulAttackers (struct char_data *ch)
{
   struct char_data *t_ch;
   struct char_data *hold;

   if (!ch)
      return;

   for (t_ch = combat_list; t_ch; t_ch = hold)
   {
      hold = t_ch->next_fighting;
      if ((t_ch->char_specials.fighting == ch) &&
	  ((!IS_NPC (t_ch) && !PRF_FLAGGED (t_ch, PRF_VICIOUS)) ||
	   (IS_NPC (t_ch) && !is_aggr_to (t_ch, ch))))
	 stop_fighting (t_ch);	/* mob check above commented out till i finish code */
   }
}

/*This is command to sets pc's aggressive state. When set the pc will
   attack aggressive monsters. Depending on thier current hitpoints
   Banyal */
ACMD (do_aggr)
{
   char Abuf[MAX_STRING_LENGTH];

   if (IS_NPC (ch))
      return;

   one_argument (argument, Abuf);

   if (*Abuf == '\0')
   {				/*No argument is a check of aggressivity */

      if (ch->player_specials->saved.aggressive == -1)
      {
	 send_to_char ("You are not aggressive to monsters.\r\n", ch);
	 return;
      }
      sprintf (Abuf, "You will be aggressive unless hp < %d.\r\n",
	       ch->player_specials->saved.aggressive);

      send_to_char (Abuf, ch);
      return;
   }
   else if (!str_cmp (Abuf, "off") || atoi (Abuf) >= GET_MAX_HIT (ch))

      if (GET_CLASS (ch) == CLASS_ANTI_PALADIN)
      {
	 send_to_char ("What?  Let somebody else get the first blow?  Not a chance!\r\n", ch);
	 return;
      }
      else
      {
	 ch->player_specials->saved.aggressive = -1;
	 send_to_char ("You are no longer aggressive to monsters.\r\n", ch);
	 return;
      }
   else
   {				/* Turn on aggressivity */

      int hp = atoi (Abuf);

      if (hp < 0)
      {
	 send_to_char ("Aggressive while dying?  Not likely!\r\n", ch);
	 return;
      }
      ch->player_specials->saved.aggressive = hp;
      send_to_char ("OK.\r\n", ch);
      return;
   }
}
@


1.283
log
@Fix bug in hit() so it calculates damage based on the type of weapon being
wielded instead of TYPE_HIT.  (This should make it use piercing instead of
crushing.)
@
text
@/***************************************************************************
 * $Id: fight.c,v 1.282 2011/08/06 15:46:10 rsd Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: fight.c                                        Part of FieryMUD *
 *  Usage: Combat system                                                   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "casting.h"
#include "screen.h"
#include "dg_scripts.h"
#include "corpse_save.h"
#include "races.h"
#include "events.h"
#include "skills.h"
#include "cooldowns.h"
#include "constants.h"
#include "math.h"
#include "players.h"
#include "trophy.h"
#include "regen.h"
#include "magic.h"
#include "exits.h"
#include "fight.h"
#include "pfiles.h"
#include "movement.h"
#include "limits.h"
#include "composition.h"
#include "lifeforce.h"
#include "damage.h"
#include "specprocs.h"
#include "directions.h"
#include "act.h"
#include "clan.h"


/* Structures */
struct char_data *combat_list = NULL;        /* head of l-list of fighting chars */
struct char_data *next_combat_list = NULL;

/* External structures */
extern struct message_list fight_messages[MAX_MESSAGES];

/* The following are from config.c */
extern int pk_allowed;
extern int auto_save;
extern int summon_allowed;
extern int sleep_allowed;
extern int charm_allowed;
extern int damage_amounts;

/* External procedures */
char *fread_action(FILE * fl, int nr);
char *fread_string(FILE * fl, char *error);
void decrease_modifier(struct char_data *i, int spell);
void check_new_surroundings(struct char_data *ch, bool old_room_was_dark, bool tx_obvious);
bool in_memory(struct char_data *ch, struct char_data *tch);
long exp_death_loss(struct char_data *ch, int level);
EVENTFUNC(die_event);

ACMD(do_get);
ACMD(do_return);
void remove_from_all_memories(struct char_data *ch);
void abort_casting(struct char_data *ch);
void aggro_lose_spells(struct char_data *ch);

/* Weapon attack texts */
struct attack_hit_type attack_hit_text[] =
{
   {"hit", "hits"},                        /* 0 */
   {"sting", "stings"},
   {"whip", "whips"},
   {"slash", "slashes"},
   {"bite", "bites"},
   {"bludgeon", "bludgeons"},            /* 5 */
   {"crush", "crushes"},
   {"pound", "pounds"},
   {"claw", "claws"},
   {"maul", "mauls"},
   {"thrash", "thrashes"},            /* 10 */
   {"pierce", "pierces"},
   {"blast", "blasts"},
   {"punch", "punches"},
   {"stab", "stabs"}
};

/****************************/
/*  General target linking  */
/****************************/

/* The following functions - set_battling and stop_battling - are utility
 * functions that simply link or unlink attackers and their targets, and make
 * sure that people who are fighting are in the mudwide combat list.
 *
 * Any and all sanity checks, permissions, and so forth that govern whether
 * the battle may take place must be performed before calling these functions.
 *
 * These are the only functions that should modify ch->target.  Call these
 * functions instead of setting the value elsewhere. */

/* Cause ch to be battling target */
void set_battling(struct char_data *ch, struct char_data *target)
{
   struct char_data *c; /* Error check/debug */
   static int set_battling_corecount_1 = 0;
   static int set_battling_corecount_2 = 0;
   static int set_battling_corecount_3 = 0;

   /* Caller should not blindly set one person fighting another, when the
    * attacker is already in battle.  That's a special circumstance, like the
    * switch skill, and the caller should be aware of the situation and call
    * stop_battling() if it decides that ch will change its target */
   if (ch->target) {
      mprintf(L_ERROR, LVL_GOD, "set_battling: %s is already battling %s",
            GET_NAME(ch), GET_NAME(ch->target));
      if (set_battling_corecount_1 < 3) {
         drop_core(NULL, "set_battling_I");
         mprintf(L_ERROR, LVL_GOD, "set_battling: core dropped (I)");
         set_battling_corecount_1++;
      }
      stop_battling(ch);
   }

   ch->target = target;

   /* ch will be placed in the target's attacker list.
    * It should not be there already.  Check it's there - it would be an error. */
   for (c = target->attackers; c; c = c->next_attacker)
      if (c == ch) {
         mprintf(L_ERROR, LVL_GOD, "set_battling: %s is already in attacker list for %s",
               GET_NAME(ch), GET_NAME(target));
         if (set_battling_corecount_2 < 3) {
            drop_core(NULL, "set_battling_II");
            mprintf(L_ERROR, LVL_GOD, "set_battling: core dropped (II)");
            set_battling_corecount_2++;
         }
         return;
      }

   ch->next_attacker = target->attackers;
   target->attackers = ch;

   /* ch will be placed in the mudwide combat list.
    * It should not be there already.  Check it's there - it would be an error. */
   for (c = combat_list; c; c = c->next_fighting)
      if (c == ch) {
         mprintf(L_ERROR, LVL_GOD, "set_battling: %s is already in the combat list",
               GET_NAME(ch));
         if (set_battling_corecount_3 < 3) {
            drop_core(NULL, "set_battling_III");
            mprintf(L_ERROR, LVL_GOD, "set_battling: core dropped (III)");
            set_battling_corecount_3++;
         }
         return;
      }

   ch->next_fighting = combat_list;
   combat_list = ch;
   GET_STANCE(ch) = STANCE_FIGHTING;
   if (!pk_allowed)
      check_killer(ch, target);
}

/* Stop ch from battling its target */
void stop_battling(struct char_data *ch)
{
   static int stop_battling_corecount = 0;

   struct char_data *temp;

   if (ch->target) {
      REMOVE_FROM_LIST(ch, ch->target->attackers, next_attacker);
      ch->target = NULL;
   } else {
      mprintf(L_ERROR, LVL_GOD, "SYSERR: stop_battling: %s has no target",
            GET_NAME(ch));
      if (stop_battling_corecount < 3) {
         drop_core(NULL, "stop_battling_no_target");
         mprintf(L_ERROR, LVL_GOD, "stop_battling: core dropped");
         stop_battling_corecount++;
      }
   }

   /* Remove ch from the mudwide combat list. */

   /* If we're in the middle of another loop, and ch is the one that it's
    * processing, we need to advance this pointer. */
   if (ch == next_combat_list)
      next_combat_list = ch->next_fighting;
   REMOVE_FROM_LIST(ch, combat_list, next_fighting);
   ch->next_fighting = NULL;

   /* This function is called from alter_pos(), so in the interest of avoiding
    * infinite loops -- and because this is a pretty safe stance change --
    * we'll directly modify the stance. */
   if (GET_STANCE(ch) == STANCE_FIGHTING)
      GET_STANCE(ch) = STANCE_ALERT;
}

/* Stop everyone from fighting this character */
void stop_attackers(struct char_data *ch)
{
   struct char_data *a, *next;

   if (ch->attackers) {
      for (a = ch->attackers; a;) {
         next = a->next_attacker;
         stop_battling(a);
         a = next;
      }
   }
}

/* Stop non-VICIOUS folks from fighting this character */
void stop_merciful_attackers(struct char_data *ch)
{
   struct char_data *a, *next;

   if (ch->attackers) {
      for (a = ch->attackers; a;) {
         next = a->next_attacker;
         if (!IS_VICIOUS(a))
            stop_battling(a);
         a = next;
      }
   }
}

/* This switches ch to attacking someone new.
 * It does not involve an immediate hit - it just switches who ch is battling.
 * For that reason, it isn't called when the "switch" skill is invoked --
 * that does involve an extra hit. */
void switch_target(struct char_data *ch, struct char_data *newvict)
{
   if (ch->target)
      stop_battling(ch);
   set_battling(ch, newvict);
}

/* start one char fighting another (yes, it is horrible, I know... )   */
void set_fighting(struct char_data *ch, struct char_data *vict, bool reciprocate)
{
   if (ch != vict) {
     /* Not sure how the attacker could be stunned or sleeping, but whatever... */
     if (GET_STANCE(ch) > STANCE_STUNNED && !FIGHTING(ch)) {
         if (EFF_FLAGGED(ch, EFF_SLEEP))
            effect_from_char(ch, SPELL_SLEEP);
         set_battling(ch, vict);
      }

      if (reciprocate && AWAKE(vict) &&
            attack_ok(vict, ch, FALSE) && !FIGHTING(vict)) {
         set_battling(vict, ch);
      }
   }
}

/* Move battle targets and such from one character to another.
 * Useful for shapechange. */
void transfer_battle(struct char_data *ch, struct char_data *tch)
{
   struct char_data *c;
   struct char_data *temp;

   /* Replacement will fight whoever the original was fighting */
   tch->target = ch->target;
   ch->target = NULL;

   /* Those fighting the original will fight the replacement */
   tch->attackers = ch->attackers;
   ch->attackers = NULL;
   for (c = tch->attackers; c; c = c->next_attacker)
      c->target = tch;

   /* Replacement will take the place of the original in a list of attackers */
   if (FIGHTING(tch)) {
      for (c = FIGHTING(tch)->attackers; c; c = c->next_attacker)
         if (c->next_attacker == ch)
            c->next_attacker = tch;
      if (FIGHTING(tch)->attackers == ch)
         FIGHTING(tch)->attackers = tch;
   }
   tch->next_attacker = ch->next_attacker;
   ch->next_attacker = NULL;

   /* Swap them in the main combat list */
   if (FIGHTING(tch)) {
      REMOVE_FROM_LIST(ch, combat_list, next_fighting);
      tch->next_fighting = combat_list;
      combat_list = tch;
   }
}

#define IS_WEAPON(type) (((type) >= TYPE_HIT) && ((type) < TYPE_SUFFERING))

EVENTFUNC(quick_aggro_event)
{
   struct generic_event_data *data = (struct generic_event_data *) event_obj;
   struct char_data *ch = data->ch;
   struct char_data *vict = data->vict;

   if (ch && !FIGHTING(ch) && GET_STANCE(ch) >= STANCE_ALERT &&
         vict && room_contains_char(IN_ROOM(ch), vict) &&
         attack_ok(ch, vict, FALSE))
      attack(ch, vict);

   return EVENT_FINISHED;
}

/*
 * This function determines whether ch attacking victim should be
 * allowed.   Returns TRUE if this is an unallowed action, and FALSE
 * if the action should go forward.
 */
bool attack_ok(struct char_data *ch, struct char_data *victim, bool verbose) {
   bool pet = FALSE;

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) ||
         EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS) ||
         EFF_FLAGGED(ch, EFF_MESMERIZED))
      return FALSE;

   if (ch != victim &&
         (ROOM_FLAGGED(victim->in_room, ROOM_PEACEFUL) ||
          ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL))) {
      if (verbose)
         send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
      return FALSE;
   }

   if (MOB_FLAGGED(victim, MOB_PEACEFUL)) {
      if (verbose)
         act("But $N just has such a calm, peaceful feeling about $Mself!",
               FALSE, ch, 0, victim, TO_CHAR);
      return FALSE;
   }

   if (DECEASED(victim)) {
       if (verbose)
            act("$N is already dead.", TRUE, ch, 0, victim, TO_CHAR);
       return FALSE;
   }

   /* From here on, we consider PK, so if PK is on, the attack is ok */
   if (pk_allowed)
      return TRUE;

   /* Also, PK is ok if we're in an arena room */
   if (ROOM_FLAGGED(victim->in_room, ROOM_ARENA) &&
         ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
      return TRUE;

   /* Is one of the parties a pet?   Use the master for calculations.*/
   if (ch->master && EFF_FLAGGED(ch, EFF_CHARM))
      ch = ch->master;
   if (victim->master && EFF_FLAGGED(victim, EFF_CHARM)) {
      victim = victim->master;
      pet = TRUE;
   }

   /* Feel free to hit yourself as much as you please.
    * Note that this test, coming after pet detection, will also allow
    * you to attack your own pet. */
   if (ch == victim)
      return TRUE;

   /* Unallowed PK if both attacker and victim are players */
   if (IS_PC(ch) && IS_PC(victim)) {
      /* But allow it if one of them is a switched god. */
      if (IS_NPC(ch) && GET_LEVEL(REAL_CHAR(ch)) >= LVL_GOD)
         return TRUE;
      if (IS_NPC(victim) && GET_LEVEL(REAL_CHAR(victim)) >= LVL_GOD)
         return TRUE;
      if (verbose) {
         if (pet)
            send_to_char("Sorry, you can't attack someone else's pet!\r\n", ch);
         else
            send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
      }
      return FALSE;
   }

   return TRUE;
}

/* mass_attack_ok - like attack_ok, but for widespread violence like area spells
 * and "hitall all".  Avoids your pets - where attack_ok wouldn't. */

bool mass_attack_ok(struct char_data *ch, struct char_data *victim, bool verbose) {

   if (!attack_ok(ch, victim, verbose))
      return FALSE;

   if (IS_PC(ch) && PLAYERALLY(victim) && 
       !ROOM_FLAGGED(victim->in_room, ROOM_ARENA)) {
      if (verbose)
         send_to_char("You can't attack someone's pet!\r\n", ch);
      return FALSE;
   }

   return TRUE;
}

int blessed_blow(struct char_data *ch, struct obj_data *weapon)
{
   if (EFF_FLAGGED(ch, EFF_BLESS) || EFF_FLAGGED(ch, EFF_HEX)) {
      return TRUE;
   }
   return FALSE;
}

/* Whether tch will be selected in some sort of area attack by ch.
 * The types of area attacks include:
 * -- mass attack skills like hitall and stomp
 * -- area spells like chain lighting and earthquake
 */
bool area_attack_target(struct char_data *ch, struct char_data *tch)
{
   extern int roomeffect_allowed;

   /* Not yourself */
   if (ch == tch) return FALSE;

   /* Not your group members */
   if (is_grouped(ch, tch)) return FALSE;

   /* Not your followers, or leader */
   if (tch->master == ch || ch->master == tch) return FALSE;

   /* Players can't attack players unless... this is set or something */
   if (!roomeffect_allowed && !IS_NPC(ch) && !IS_NPC(tch)) return FALSE;

   /* Check whether you're ALLOWED to attack this person */
   if (!mass_attack_ok(ch, tch, FALSE)) return FALSE;

   /* The following checks will be overridden if they're already in battle */
   if (!battling_my_group(ch, tch)) {
      /* Mobs don't include mobs, except player allies */
      if (!PLAYERALLY(ch) && !PLAYERALLY(tch))
         return FALSE;
      /* Yeah, no hassle! */
      if (PRF_FLAGGED(tch, PRF_NOHASSLE))
         return FALSE;
   }
   return TRUE;
}

char *fread_message(FILE * fl, int nr)
{
   char *action = fread_action (fl, nr);
   if (action) return action;
   sprintf(buf, "ERROR!   Message #%d missing.", nr);
   return strdup(buf);
}

void load_messages(void)
{
   FILE *fl;
   int i, type;
   struct message_type *messages;
   char chk[256];

   if (!(fl = fopen (MESS_FILE, "r")))
      {
         sprintf (buf2, "Error reading combat message file %s", MESS_FILE);
         perror (buf2);
         exit (1);
      }
   for (i = 0; i < MAX_MESSAGES; i++)
      {
         fight_messages[i].a_type = 0;
         fight_messages[i].number_of_attacks = 0;
         fight_messages[i].msg = 0;
      }


   fgets (chk, 256, fl);
   while (!feof (fl) && (*chk == '\n' || *chk == '*'))
      fgets (chk, 256, fl);

   while (*chk == 'M')
      {
         fgets (chk, 256, fl);
         sscanf (chk, " %d\n", &type);
         for (i = 0; (i < MAX_MESSAGES) && (fight_messages[i].a_type != type) &&
                   (fight_messages[i].a_type); i++);
         if (i >= MAX_MESSAGES)
            {
               fprintf (stderr, "Too many combat messages.   Increase MAX_MESSAGES and recompile.");
               exit (1);
            }
         CREATE (messages, struct message_type, 1);

         fight_messages[i].number_of_attacks++;
         fight_messages[i].a_type = type;
         messages->next = fight_messages[i].msg;
         fight_messages[i].msg = messages;

         messages->die_msg.attacker_msg = fread_message (fl, i);
         messages->die_msg.victim_msg = fread_message (fl, i);
         messages->die_msg.room_msg = fread_message (fl, i);
         messages->miss_msg.attacker_msg = fread_message (fl, i);
         messages->miss_msg.victim_msg = fread_message (fl, i);
         messages->miss_msg.room_msg = fread_message (fl, i);
         messages->hit_msg.attacker_msg = fread_message (fl, i);
         messages->hit_msg.victim_msg = fread_message (fl, i);
         messages->hit_msg.room_msg = fread_message (fl, i);
         messages->god_msg.attacker_msg = fread_message (fl, i);
         messages->god_msg.victim_msg = fread_message (fl, i);
         messages->god_msg.room_msg = fread_message (fl, i);
         messages->heal_msg.attacker_msg = fread_message (fl, i);
         messages->heal_msg.victim_msg = fread_message (fl, i);
         messages->heal_msg.room_msg = fread_message (fl, i);
         fgets (chk, 256, fl);
         while (!feof (fl) && (*chk == '\n' || *chk == '*'))
             fgets (chk, 256, fl);
    }

   fclose (fl);
}

void free_messages_type(struct msg_type *msg)
{
   if (msg->attacker_msg)            free(msg->attacker_msg);
   if (msg->victim_msg)               free(msg->victim_msg);
   if (msg->room_msg)                  free(msg->room_msg);
}

void free_messages() {
   int i;

   for (i = 0; i < MAX_MESSAGES; i++)
      while (fight_messages[i].msg) {
         struct message_type *former = fight_messages[i].msg;

         free_messages_type(&former->die_msg);
         free_messages_type(&former->miss_msg);
         free_messages_type(&former->hit_msg);
         free_messages_type(&former->god_msg);
         free_messages_type(&former->heal_msg);

         fight_messages[i].msg = fight_messages[i].msg->next;
         free(former);
      }
}


void check_killer(struct char_data *ch, struct char_data *vict)
{
   if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA))
       return;

   if (!PLR_FLAGGED (vict, PLR_KILLER) && !PLR_FLAGGED (vict, PLR_THIEF)
         && !PLR_FLAGGED (ch, PLR_KILLER) && !IS_NPC (ch) && !IS_NPC (vict) &&
         (ch != vict))
      {
         SET_FLAG (PLR_FLAGS (ch), PLR_KILLER);
         mprintf(BRF, LVL_IMMORT, "PC Killer bit set on %s for initiating attack on %s at %s.",
                 GET_NAME(ch), GET_NAME(vict), world[vict->in_room].name);
         send_to_char ("If you want to be a PLAYER KILLER, so be it...\r\n", ch);
      }
}

void fluid_death(struct char_data *ch, struct char_data *killer) {
   struct obj_data *obj;
   struct obj_data *money;
   int i, numcoins, numitems;
   struct obj_data *next_obj;

   /* FIXME: Dumping all your crap on the ground should be centralized.
    *        This also occurs in do_quit. */

   numitems = 0;

   /* transfer objects to room */
   while (ch->carrying) {
      obj = ch->carrying;
      obj_from_char(obj);
      obj_to_room(obj, ch->in_room);
      start_decomposing(obj);
      numitems++;
   }

   /* transfer equipment to room */
   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i)) {
         obj = unequip_char(ch, i);
         obj_to_room(obj, ch->in_room);
         start_decomposing(obj);
         numitems++;
      }

   /* And money */
   numcoins = GET_GOLD(ch) + GET_PLATINUM(ch) + GET_COPPER(ch) + GET_SILVER(ch);
   if (numcoins > 0) {
      money = create_money(GET_COINS(ch));
      obj_to_room(money, ch->in_room);
      start_decomposing(money);
      GET_GOLD(ch) = 0;
      GET_PLATINUM(ch) = 0;
      GET_COPPER(ch) = 0;
      GET_SILVER(ch) = 0;
   }

   /* Describe what happens to the creature's body, and state whether anything
    * is dropped. */
   if (numitems + numcoins > 1) {
      if (PHASE(ch) == PHASE_LIQUID)
         act("$n's remains fall with a splatter, dropping a few items.",
               TRUE, ch, 0, 0, TO_ROOM);
      else
         act("The remnants of $n dissipate, dropping a few things.", TRUE, ch, 0, 0, TO_ROOM);
   } else if (numitems + numcoins == 1) {
      if (PHASE(ch) == PHASE_LIQUID)
         act("$n falls with a splatter, dropping something.",
               TRUE, ch, 0, 0, TO_ROOM);
      else
         act("The remnants of $n dissipate, dropping something.", TRUE, ch, 0, 0, TO_ROOM);
   } else  {
      if (PHASE(ch) == PHASE_LIQUID)
         act("$n's body loses cohesion and falls with a splatter.",
               TRUE, ch, 0, 0, TO_ROOM);
      else
         act("The remnants of $n dissipate.", TRUE, ch, 0, 0, TO_ROOM);
   }

   if (numitems + numcoins > 0 && killer && IN_ROOM(killer) == IN_ROOM(ch) &&
         AWAKE(killer)) {
      if (PRF_FLAGGED(killer, PRF_AUTOLOOT)) {
         struct get_context *context = begin_get_transaction(killer);
         if (numcoins)
           perform_get_from_room(context, CH_ROOM(ch)->contents);
         for (obj = CH_ROOM(ch)->contents; obj; obj = next_obj) {
            next_obj = obj->next_content;
            if (numitems-- > 0)
               perform_get_from_room(context, obj);
            else
               break;
         }
         end_get_transaction(context, NULL);
      }
      else if (PRF_FLAGGED(killer, PRF_AUTOTREAS)) {
         struct get_context *context = begin_get_transaction(killer);
         for (obj = CH_ROOM(ch)->contents; obj; obj = next_obj) {
            next_obj = obj->next_content;
            if (GET_OBJ_TYPE(obj) == ITEM_MONEY || GET_OBJ_TYPE(obj) == ITEM_TREASURE)
               perform_get_from_room(context, obj);
         }
         end_get_transaction(context, NULL);
      }
   }

   return;
}

struct obj_data *make_corpse(struct char_data *ch, struct char_data *killer)
{
   struct obj_data *corpse, *o;
   struct obj_data *money;
   int i;
   extern int max_npc_corpse_time, max_pc_corpse_time, short_pc_corpse_time;

   /* Some folks don't make corpses */
   if (MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      act("$n seems to have vanished entirely.", TRUE, ch, 0, 0, TO_ROOM);
      return NULL;
   } else if (PHASE(ch) != PHASE_SOLID) {
      fluid_death(ch, killer);
      return NULL;
   }

   corpse = create_obj();

   corpse->item_number = NOTHING;
   corpse->in_room = NOWHERE;
   sprintf(buf2, "corpse %s", strip_ansi ((ch)->player.namelist));
   corpse->name = strdup (buf2);

   sprintf(buf2, "&0The corpse of %s&0 is lying here.", GET_NAME (ch));
   corpse->description = strdup (buf2);

   sprintf(buf2, "the corpse of %s", GET_NAME (ch));
   corpse->short_description = strdup (buf2);

   GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
   SET_FLAG(GET_OBJ_FLAGS(corpse), ITEM_NODONATE);
   SET_FLAG(GET_OBJ_FLAGS(corpse), ITEM_FLOAT);
   /* You can't store stuff in a corpse */
   GET_OBJ_VAL(corpse, VAL_CONTAINER_CAPACITY) = 0;

   if (!IS_NPC(ch))
      GET_OBJ_VAL(corpse, VAL_CONTAINER_CORPSE) = CORPSE_PC;
   else if (GET_LIFEFORCE(ch) == LIFE_UNDEAD)
      GET_OBJ_VAL(corpse, VAL_CONTAINER_CORPSE) = CORPSE_NPC_NORAISE;
   else
      GET_OBJ_VAL(corpse, VAL_CONTAINER_CORPSE) = CORPSE_NPC;

   GET_OBJ_VAL(corpse, VAL_CONTAINER_BITS) = 0; /* not closable */
   GET_OBJ_WEIGHT(corpse) = GET_WEIGHT(ch) + IS_CARRYING_W(ch) + 100;
   if (IS_NPC(ch))
      GET_OBJ_MOB_FROM(corpse) = GET_MOB_RNUM(ch);
   else
      GET_OBJ_MOB_FROM(corpse) = NOBODY;

   GET_OBJ_LEVEL(corpse) = GET_LEVEL(ch);

   /* transfer character's inventory to the corpse */
   corpse->contains = ch->carrying;
   for (o = corpse->contains; o != NULL; o = o->next_content) {
      o->in_obj = corpse;
      o->carried_by = NULL;
   }

   /* transfer character's equipment to the corpse */
   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i))
         obj_to_obj(unequip_char(ch, i), corpse);

   /* transfer coins */
   if (GET_CASH(ch) > 0)
      {
         /* following 'if' clause added to fix gold duplication loophole */
         if (IS_NPC(ch) || (!IS_NPC(ch) && ch->desc))
            {
               money = create_money(GET_COINS(ch));
               obj_to_obj(money, corpse);
            }
         GET_GOLD(ch) = 0;
         GET_PLATINUM(ch) = 0;
         GET_COPPER(ch) = 0;
         GET_SILVER(ch) = 0;
      }
   ch->carrying = NULL;
   IS_CARRYING_N(ch) = 0;
   IS_CARRYING_W(ch) = 0;

   /* DECOMPOSITION */
   if (IS_NPC(ch))
      GET_OBJ_DECOMP(corpse) = max_npc_corpse_time;
   else if (
         /* Corpse is empty */
         !corpse->contains ||
         /* Corpse contains just one object, and it's cash */
         (corpse->contains && !corpse->contains->next_content &&
          GET_OBJ_TYPE(corpse->contains) == ITEM_MONEY))
      /* Therefore, a fairly short decomp time for a player corpse */
      GET_OBJ_DECOMP(corpse) = short_pc_corpse_time;
   else
      /* Corpse contains other objects - long decomp time */
      GET_OBJ_DECOMP(corpse) = max_pc_corpse_time;

   /* Ensure that the items inside aren't marked for decomposition. */
   stop_decomposing(corpse);
   /* And mark the corpse itself as decomposing. */
   SET_FLAG(GET_OBJ_FLAGS(corpse), ITEM_DECOMP);

   obj_to_room(corpse, ch->in_room);
   if (!IS_NPC(ch)) {
      register_corpse(corpse);
      delete_player_obj_file(ch);
   }

   return corpse;
}


void change_alignment(struct char_data *ch, struct char_data *victim)
{
   int k_al, v_al, change;

   k_al = GET_ALIGNMENT(ch);
   v_al = GET_ALIGNMENT(victim);

   /* If victim was !good, and killer was good, make victim seem eviler */
   if (MOB_FLAGGED(victim, MOB_AGGR_GOOD) && IS_GOOD(ch))
      v_al -= 100;
   else if (MOB_FLAGGED(victim, MOB_AGGR_EVIL) && IS_EVIL(ch))
      v_al += 100;

   /* if we are a 'good' class then our effective align is higher, ie
    * even if a paladin of align 800 kills someone its as if they were align
    * 900 compared to a wariror 800 (cos they should know better!)
    */
   switch (GET_CLASS(ch)) {
   /* using drop through cases to accumulate the align*/
   case CLASS_PALADIN:
   case CLASS_PRIEST:          k_al += 50;
   case CLASS_RANGER:
   case CLASS_DRUID:            k_al += 50;
                                        break;

   /* same deal for 'bad' classes */
   case CLASS_ANTI_PALADIN:
   case CLASS_DIABOLIST:
   case CLASS_NECROMANCER:   k_al -= 50;
   case CLASS_THIEF:
   case CLASS_ASSASSIN:       k_al -=50;
   }

   change = (v_al / (-75 - (25 * abs((k_al - 1000) / 200)))) - (2 * abs(k_al / 1000));

   /* modifier based on level? */
   if (change < 0 && GET_LEVEL(ch) > GET_LEVEL(victim) + 10)
      change *= (GET_LEVEL(ch) - GET_LEVEL(victim)) / 10;

   GET_ALIGNMENT(ch) += change;
   GET_ALIGNMENT(ch) = LIMIT(MIN_ALIGNMENT, GET_ALIGNMENT(ch), MAX_ALIGNMENT);
}

void death_cry(struct char_data *ch)
{
   int door, was_in;

   act("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);
   was_in = ch->in_room;

   for (door = 0; door < NUM_OF_DIRS; door++) {
      if (CAN_GO(ch, door) &&
            (!ROOM_FLAGGED(was_in, ROOM_ARENA) ||
            !ROOM_FLAGGED(world[was_in].exits[door]->to_room, ROOM_OBSERVATORY)) &&
            (!ROOM_FLAGGED(was_in, ROOM_OBSERVATORY) ||
            !ROOM_FLAGGED(world[was_in].exits[door]->to_room, ROOM_ARENA))) {
         ch->in_room = world[was_in].exits[door]->to_room;
         act("Your blood freezes as you hear someone's death cry.", FALSE, ch, 0, 0, TO_ROOM);
         ch->in_room = was_in;
      }
   }
}

void arena_death(struct char_data *ch)
{
   int door, destination, wasdark;
   extern int r_mortal_start_room;

   /* Make sure they have positive hit points */

   /* Not a good idea to restore someone to full health here, because
    * they could use that as a way to get healed from wounds acquired
    * on other fields of battle. */
   if (GET_HIT(ch) < 1)
      hurt_char(ch, NULL, -(abs(GET_HIT(ch)) + 5), TRUE);

   /* Move it out of the room */
   /* Choose the destination */
   destination = NOWHERE;
   for (door = 0; door < NUM_OF_DIRS; door++) {
      if (CAN_GO(ch, door) &&
            ROOM_FLAGGED(world[IN_ROOM(ch)].exits[door]->to_room, ROOM_OBSERVATORY)) {
         destination = world[IN_ROOM(ch)].exits[door]->to_room;
         break;
      }
   }

   if (destination == NOWHERE) {
      destination = real_room(GET_HOMEROOM(ch));
      if (destination < 0) {
         log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
         destination = r_mortal_start_room;
      }
   }
   alter_pos(ch, POS_SITTING, STANCE_RESTING);

   wasdark = IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch);
   send_to_char("An invisible hand removes you from the battlefield.\r\n", ch);
   act("$n's still body is lifted away by an invisible force.", TRUE,
         ch, NULL, NULL, TO_ROOM);
   dismount_char(ch);
   char_from_room(ch);
   char_to_room(ch, destination);
   act("$n is deposited gently in the middle of the room.", TRUE,
         ch, NULL, NULL, TO_ROOM);
   check_new_surroundings(ch, wasdark, TRUE);
   WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}

void perform_die(struct char_data *ch, struct char_data *killer)
{
   struct char_data *real_char;
   struct obj_data *corpse = NULL, *obj, *next_obj;
   struct mem_list *cur;

   /*check for switched victim */
   real_char = REAL_CHAR(ch);
   if (POSSESSED(ch)) {
      char_from_room(real_char);
      char_to_room(real_char, ch->in_room);
   }

   while (ch->effects)
      effect_remove(ch, ch->effects);
   while (real_char->effects)
      effect_remove(real_char, real_char->effects);

   if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA)) {
       arena_death(ch);
       return;
   }
   /* Everything beyond this point applies to normal, non-arena deaths */

   /* Set all spells in the memory list to unmemorized, but don't remove. */
   for (cur = GET_SPELL_MEM(ch).list_head; cur; cur = cur->next)
      cur->can_cast = 0;
   GET_SPELL_MEM(ch).num_memmed = 0;
   GET_SPELL_MEM(ch).mem_status = FALSE;

   clear_cooldowns(ch);

   /* Stop NPCs from hunting you */
   remove_from_all_memories(ch);

   if (IS_NPC(real_char) && GET_LEVEL(real_char) < 60 &&
         !MOB_FLAGGED(real_char, MOB_ILLUSORY))
      perform_random_gem_drop(ch);

   if (GET_LEVEL(real_char) < LVL_IMMORT) {
      corpse = make_corpse(real_char, killer);
      if (!IS_NPC(real_char)) {
         /* If killed dont save in room he died in */
         GET_LOADROOM(real_char) = GET_HOMEROOM(real_char);
         if (!PRF_FLAGGED(real_char, PRF_QUEST))
            init_trophy(real_char);
      }
      if (ch != real_char)
         extract_char(real_char);
      extract_char(ch);
   } else if (ch != real_char) {
      do_return(real_char, "", 0, 1);
      corpse = make_corpse(ch, killer);
      extract_char(ch);
   }

   if (killer && ch != killer && corpse && corpse->contains) {
      if (PRF_FLAGGED(killer, PRF_AUTOLOOT))
         get_from_container(killer, corpse, "all", NULL);
      else if (PRF_FLAGGED(killer, PRF_AUTOTREAS)) {
         struct get_context *context = begin_get_transaction(killer);
         for (obj = corpse->contains; obj; obj = next_obj) {
            next_obj = obj->next_content;
            if (GET_OBJ_TYPE(obj) == ITEM_MONEY || GET_OBJ_TYPE(obj) == ITEM_TREASURE)
               perform_get_from_container(context, obj, corpse);
         }
         end_get_transaction(context, corpse);
      }
   }
}

void kill_to_group_trophy(struct char_data *ch, struct char_data *victim)
{
   int members = 0;
   struct char_data *group_master;
   struct group_type *g;

   group_master = (ch->group_master ? ch->group_master : ch);

   if (group_master->in_room == ch->in_room)
      members = 1;
   for (g = group_master->groupees; g; g = g->next)
      if (g->groupee->in_room == ch->in_room)
         ++members;

   if (group_master->in_room == ch->in_room)
      if (!IS_NPC(group_master))
         kill_to_trophy(victim, group_master, 1.0 / members);
   for (g = group_master->groupees; g; g = g->next)
      if (g->groupee->in_room == ch->in_room)
         if (!IS_NPC(g->groupee))
            kill_to_trophy(victim, g->groupee, 1.0 / members);
}

void die(struct char_data *ch, struct char_data *killer)
{
   int i;

   GET_HIT(ch) = -15;
   alter_pos(ch, POS_PRONE, STANCE_DEAD);

   /* Record player death in log */
   if (!IS_NPC(ch)) {
     if (killer)
       sprintf(buf2, "%s was killed by %s", GET_NAME(ch), GET_NAME(killer));
     else
       sprintf(buf2, "%s died", GET_NAME(ch));
     clan_notification(GET_CLAN(ch), ch, "%s.", buf2);
     mprintf(L_STAT, LVL_IMMORT, "%s in %s [%d]", buf2,
             world[ch->in_room].name, world[ch->in_room].vnum);
   }

   /* Stop the fighting */
   if (FIGHTING(ch))
      stop_fighting(ch);
   stop_attackers(ch);

   /* Victim loses exp */
   /* Only if a player.  Exp for killing a mob has not been disbursed yet. */
   if (!IS_NPC(ch))
      gain_exp(ch, -exp_death_loss(REAL_CHAR(ch), GET_LEVEL(REAL_CHAR(ch))), GAIN_REGULAR);

   /* Trophy for the killer */
   if (killer && !MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      if (IS_GROUPED(killer))
         kill_to_group_trophy(killer, ch);
      else if (!IS_NPC(killer))
         kill_to_trophy(ch, killer, 1.0);
   }

   if (EFF_FLAGGED(ch, EFF_ON_FIRE))
      REMOVE_FLAG(EFF_FLAGS(ch), EFF_ON_FIRE);

   if (!IS_NPC(ch)) {
      REMOVE_FLAG(PLR_FLAGS(ch), PLR_KILLER);
      REMOVE_FLAG(PLR_FLAGS(ch), PLR_THIEF);
      GET_COND(ch, THIRST) = 24;
      GET_COND(ch, FULL) = 24;
      GET_COND(ch, DRUNK) = 0;
   }
   abort_casting(ch);

   /* Cancel events */
   if (ch->events)
      cancel_event_list(&(ch->events));
   for (i = 0; i < EVENT_FLAG_FIELDS; ++i)
      ch->event_flags[i] = 0;

   /* show death cry if there's a killer */
   if (!MOB_PERFORMS_SCRIPTS(ch)) {
      if (killer)
         death_cry(ch);
   }
   /* run the death trigger, but don't death cry if it returns 0
    * or if there's no killer */
   else if (death_mtrigger(ch, killer) && killer)
      death_cry(ch);

   event_create(EVENT_DIE, die_event,
         mkgenericevent(ch, killer, 0), TRUE, &(ch->events), 0);
   /* perform_die() will be called by this event. */
}


static float exp_level_bonus(int level_diff)
{
   /* Can't use MAX() because it returns an int. */
   if (level_diff > 0)
      return 1.0 + (0.015 * level_diff);
   else
      return 1.0;
}

static void receive_kill_credit(struct char_data *ch, struct char_data *vict, long exp)
{
   /* Calculate level-difference bonus */
   exp *= exp_level_bonus(GET_LEVEL(vict) - GET_LEVEL(ch));

   /* Trophy decrease */
   exp *= exp_trophy_modifier(ch, vict);

   exp = MAX(exp, 1);

   send_to_char("You receive your share of experience.\r\n", ch);

   /* Adjust exp for paladins */
   if (GET_CLASS(ch) == CLASS_PALADIN) {
       if (IS_EVIL(vict))
          exp *= 1.25;
       else if (GET_ALIGNMENT(vict) > -350 && GET_ALIGNMENT(ch) < -150)  
          exp *= 0.5;
       else if (GET_ALIGNMENT(vict) >= -150 && GET_ALIGNMENT(ch) <= 150) 
          exp = 0;
       else if (GET_ALIGNMENT(vict) > 150 && GET_ALIGNMENT(ch) < 350)    
          exp *= -0.5;
       else if (IS_GOOD(vict))
          exp *= -1;
   }

   gain_exp(ch, exp, GAIN_REGULAR);
   change_alignment(ch, vict);
}

static void group_gain(struct char_data *killer, struct char_data *vict)
{
   struct char_data *group_master;
   struct group_type *g;
   long total_exp, exp_share;
   int groupees = 0;

   group_master = killer->group_master ? killer->group_master : killer;

   if (group_master->in_room == killer->in_room)
      ++groupees;
   for (g = group_master->groupees; g; g = g->next)
      if (g->groupee->in_room == killer->in_room)
         ++groupees;

   total_exp = GET_EXP(vict);
   total_exp *= 1.3;
   exp_share = total_exp / groupees;

   if (group_master->in_room == killer->in_room)
      receive_kill_credit(group_master, vict, exp_share);
   for (g = group_master->groupees; g; g = g->next)
      if (g->groupee->in_room == killer->in_room)
         receive_kill_credit(g->groupee, vict, exp_share);
}


void disburse_kill_exp(struct char_data *killer, struct char_data *vict)
{
   /* No exp for killing a disconnected player */
   if (!IS_NPC(vict) && !vict->desc)
      return;

   if (MOB_FLAGGED(vict, MOB_ILLUSORY))
      return;

   if (ROOM_FLAGGED(killer->in_room, ROOM_ARENA))
      return;

   if (IS_GROUPED(killer))
      group_gain(killer, vict);

   /* Lone killer */
   else
     receive_kill_credit(killer, vict, GET_EXP(vict));

   /* cap for exp is in max_exp_gain() in gain_exp() */
}


char *replace_string(char *str, char *weapon_singular, char *weapon_plural)
{
   static char buf[1024];
   char *cp;

   cp = buf;

   for (; *str; str++)
      {
         if (*str == '#')
            {
               switch (*(++str))
                  {
                  case 'W':
                     for (; *weapon_plural; *(cp++) = *(weapon_plural++));
                     break;
                  case 'w':
                     for (; *weapon_singular; *(cp++) = *(weapon_singular++));
                     break;
                  default:
                     *(cp++) = '#';
                     break;
                  }
            }
         else
            *(cp++) = *str;

         *cp = 0;
      }                                                /* For */

   return (buf);
}

static void append_damage_amount(char *b, const char *msg, int dam, int type) {
   /*
    * In comm.h, TO_ROOM is 1, TO_VICT is 2, TO_NOTVICT is 3, TO_CHAR is 4
    */
   const char *colors[6] = {
      "",
      "&4",
      "&1&8",
      "&4",
      "&3",
      "&2&8", /* healing */
   };
   if (damage_amounts) {
      if (type != TO_VICT && type != TO_NOTVICT && type != TO_CHAR && type != TO_ROOM) {
         sprintf(b, "SYSERR: append_damage_amounts: unrecognized target type %d", type);
         log("%s", b);
         type = TO_NOTVICT;
      }
      if (dam < 0) {
         dam *= -1;
         type = 5; /* healing */
      }
      sprintf(b, "%s (%s%d&0)", msg, colors[type], dam);
   }
   else
      strcpy(b, msg);
}



/* message for doing damage with a weapon */
void dam_message(int dam, struct char_data *ch, struct char_data *victim,
                   int w_type)
{
   const char *msg;
   char b2[1024];
   int msgnum;
   int percent = 0;

   static struct dam_barehand
   {
      char *to_room;
      char *to_char;
      char *to_victim;
   }
   bare_attack[] =
   {
      {
         "$n threw $s punch just a little wide, missing $N completely.&0",            /* 0: 0       */
         "You thought you saw $N somewhere where $E wasn't.&0",
         "$n takes aim at you, but loses communication with $s fists!&0"
      }
      ,

      {
         "$n slaps $N before tweaking $S nose.&0",                        /* 1: 1..2   */
         "You slap $N, and while $E is distracted, make a grab for $S nose.&0",
         "$n slaps your cheek, then tries to twist your nose off!&0"
      }
      ,

      {
         "$n delivers a swift kick to $N's shin, causing a yelp of pain.&0",            /* 2: 3..4   */
         "You send a swift kick to $N's shin.&0",
         "You yelp in pain as $n kicks you in the shin!&0"
      }
      ,

      {
         "$N howls in pain as $n nearly rips $S ear off!&0",                        /* 3: 5..6   */
         "You grab $N's ears and almost pull them off!&0",
         "You cannot help but scream in pain as $n gets a good grasp on your ears.&0"
      }
      ,

      {
         "$N nearly doubles over choking as $n collapses $S trachea!&0",            /* 4: 7..10   */
         "You sink your stiffened fingers into $N's throat.&0",
         "$n strikes you in the throat, making you cough involuntarily.&0"
      }
      ,

      {
         "$n dances up to $N and throws $s elbow into $S gut!&0",            /* 5: 11..14   */
         "You spin around so your back is against $N and throw your elbow into $S gut!&0",
         "$n dances up to you, and throws $s elbow into your stomach!   OUCH!&0"
      }
      ,

      {
         "Cupping $s hands, $n slaps $N's ears, bursting $S eardrums.&0",            /* 6: 15..19   */
         "You cup your hands and slap $N's ears, hoping to cause deafness.&0",
         "You feel as if $n inserted long daggers into your ears, piercing your brain!&0"
      }
      ,

      {
         "$n punches $N repeatedly in the kidneys!&0",            /* 7: 19..23 */
         "You wallop $N in the kidneys!&0",
         "$n repeatedly punches you in the kidneys, and you feel like hurling!&0"
      }
      ,

      {
         "$n punches $N in the throat, causing $M to choke!&0",            /* 8: > 23    */
         "You punch $N in the throat causing $M to nearly choke to death!&0",
         "$n nails you in the throat, and you barely avoid choking to death!&0"
      }
   };

   static struct dam_weapon_type
   {
      char *to_room;
      char *to_char;
      char *to_victim;
   }
   dam_weapons[] =
   {

      /* use #w for singular (i.e. "slash") and #W for plural (i.e. "slashes") */

      {
         "$n tries to #w $N, but misses.&0",            /* 0: 0       */
         "You try to #w $N, but miss.&0",
         "$n tries to #w you, but misses.&0"
      }
      ,

      {
         "$n grazes $N as $e #W $M.&0",                        /* 1: 1..2   */
         "You graze $N as you #w $M.&0",
         "$n grazes you as $e #W you.&0"
      }
      ,

      {
         "$n barely #W $N.&0",            /* 2: 3..4   */
         "You barely #w $N.&0",
         "$n barely #W you.&0"
      }
      ,

      {
         "$n #W $N.&0",                        /* 3: 5..6   */
         "You #w $N.&0",
         "$n #W you.&0"
      }
      ,

      {
         "$n #W $N hard.&0",            /* 4: 7..10   */
         "You #w $N hard.&0",
         "$n #W you hard.&0"
      }
      ,

      {
         "$n #W $N very hard.&0",            /* 5: 11..14   */
         "You #w $N very hard.&0",
         "$n #W you very hard.&0"
      }
      ,

      {
         "$n #W $N extremely hard.&0",            /* 6: 15..19   */
         "You #w $N extremely hard.&0",
         "$n #W you extremely hard.&0"
      }
      ,

      {
         "$n massacres $N to small fragments with $s #w.&0",            /* 7: 19..23 */
         "You massacre $N to small fragments with your #w.&0",
         "$n massacres you to small fragments with $s #w.&0"
      }
      ,

      {
         "$n nearly rips $N in two with $s deadly #w!!&0",            /* 8: > 23    */
         "You nearly rip $N in two with your deadly #w!!&0",
         "$n nearly rips you in two with $s deadly #w!!&0"
      }
   };

   memset(b2, 0x0, 1024);

   if (w_type != SKILL_BAREHAND)
         w_type -= TYPE_HIT;                        /* Change to base of table with text */

   if (GET_HIT (victim) > 0)
      percent = (int) (dam * 100 / GET_HIT (victim));
   else
      percent = 100;

   if ((percent <= 1) && (dam >= 20))
      percent += 1;
   if ((percent <= 1) && (dam >= 50))
      percent += 1;

   /* this fixes the false message due to the rounding error --gurlaek 11/22/1999 */
   percent = MAX(percent, 1);

   if (dam == 0)
      percent = 0;

   if (percent == 0)
      msgnum = 0;
   else if (percent <= 2)
      msgnum = 1;
   else if (percent <= 4)
      msgnum = 2;
   else if (percent <= 6)
      msgnum = 3;
   else if (percent <= 10)
      msgnum = 4;
   else if (percent <= 15)
      msgnum = 5;
   else if (percent <= 19)
      msgnum = 6;
   else if (percent <= 35)
      msgnum = 7;
   else if (percent <= 55)
      msgnum = 8;
   else
      msgnum = 8;

   /* damage message to onlookers */
   if (w_type == SKILL_BAREHAND)
       msg = bare_attack[msgnum].to_room;
   else
       msg = replace_string (dam_weapons[msgnum].to_room,
                                    attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   append_damage_amount(b2, msg, dam, TO_NOTVICT);
   act (b2, FALSE, ch, NULL, victim, TO_NOTVICT);

   /* damage message to damager */
   if (w_type == SKILL_BAREHAND)
       msg = bare_attack[msgnum].to_char;
   else
       msg = replace_string (dam_weapons[msgnum].to_char,
                                    attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   append_damage_amount(b2, msg, dam, TO_CHAR);
   act (b2, FALSE, ch, NULL, victim, TO_CHAR);

   /* damage message to damagee */
   if (w_type == SKILL_BAREHAND)
       msg = bare_attack[msgnum].to_victim;
   else
       msg = replace_string (dam_weapons[msgnum].to_victim,
                                    attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   append_damage_amount(b2, msg, dam, TO_VICT);
   act (b2, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
}


/*
 * Send messages for doing damage with a spell or skill, or
 * for weapon damage on miss and death blows.
 *
 * Returns TRUE if any messages were sent, FALSE otherwise.
 */
bool skill_message(int dam, struct char_data *ch, struct char_data *vict,
               int attacktype, bool death)
{
   int i, j, nr;
   char b2[1024];
   struct message_type *msg;
   struct msg_type *type;


   struct obj_data *weap = GET_EQ (ch, WEAR_WIELD);

   memset(b2, 0x0, 1024);

   /* Try the 2H weapon */
   if (!weap)
     weap = GET_EQ(ch, WEAR_2HWIELD);

   /* Secondary hand uses second weapon */
   if (attacktype == SKILL_2BACK)
     weap = GET_EQ(ch, WEAR_WIELD2);

   for (i = 0; i < MAX_MESSAGES; i++) {
      if (fight_messages[i].a_type == attacktype) {
         nr = dice(1, fight_messages[i].number_of_attacks);

         for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
            msg = msg->next;


         if (dam < 0)
            type = &msg->heal_msg;
         else if (!IS_NPC(vict) && GET_LEVEL(vict) >= LVL_IMMORT)
            type = &msg->god_msg;
         else if (dam != 0) {
            if (death)
               type = &msg->die_msg;
            else
               type = &msg->hit_msg;
         }
         else if (ch != vict)
            type = &msg->miss_msg;
         else
            return TRUE; /* don't show a message */

         /* to damager */
         if (ch != vict) {
            append_damage_amount(b2, type->attacker_msg, dam, TO_CHAR);
            act(b2, FALSE, ch, weap, vict, TO_CHAR);
         }

         /* to target */
         append_damage_amount(b2, type->victim_msg, dam, TO_VICT);
         act(b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);

         /* to room */
         append_damage_amount(b2, type->room_msg, dam, TO_ROOM);
         act(b2, FALSE, ch, weap, vict, TO_NOTVICT | TO_VICTROOM);

         return TRUE;
      }
   }
   return FALSE;
}

int damage(struct char_data *ch, struct char_data *victim, int dam,
                int attacktype)
{
   int attacker_weapons, dummy, shdam;
   struct char_data *was_fighting = FIGHTING(victim);
   bool death = FALSE;

   if (DECEASED(victim)) {
      sprintf(buf, "SYSERR: Attempt to damage a corpse in room num %d",
               world[victim->in_room].vnum);
      log("%s",buf);
      return VICTIM_DEAD;
   }

   /*
    * Eventually, I hope to implement V3's resistances here.
    * The resistance check needs to come before healing in case
    * the victim has inverse resistance to the damage.
    */

   /*
    * If damage is negative and healing should occur, take care of it
    * up here so as not to confuse the real damage code below.
    */
   if (dam < 0) {
      int orig_hp = GET_HIT(victim);

      hurt_char(victim, ch, dam, TRUE);

      if (!skill_message(dam, ch, victim, attacktype, FALSE)) {
         /* Default message */
      }

      /* Return the actual amount of healing that occured. */
      return orig_hp - GET_HIT(victim);
   }

   if (!attack_ok(ch, victim, TRUE))
      return 0;

   if (victim != ch) {
      if (GET_STANCE(ch) > STANCE_STUNNED) {

         /* Start the attacker fighting the victim. */
         if (!IS_SPELL(attacktype))
            /* Caller can decide whether vict should fight back */
            set_fighting(ch, victim, FALSE);

         /*
          * If this is a pet attacking, there is a chance the victim will
          * notice the master and switch targets.
          */
         if (IS_NPC(ch) && IS_NPC(victim) && victim->master &&
               !number(0, 100) && EFF_FLAGGED(victim, EFF_CHARM) &&
               (victim->master->in_room == ch->in_room) &&
               CAN_SEE(ch, victim->master)) {
            if (FIGHTING(ch))
               stop_fighting(ch);

            sprintf(buf, "&6&b$n observes your command over %s and attacks YOU instead!&0",
                        GET_NAME(victim));
            act(buf, FALSE, ch, 0, victim->master, TO_VICT);

            sprintf(buf, "&6&b$n observes $N commanding %s and attacks $M instead!&0",
                        GET_NAME(victim));
            act(buf, FALSE, ch, 0, victim->master, TO_NOTVICT);
            sprintf(buf, "&6&bYou observes $N commanding %s and attacks $M instead!&0",
            GET_NAME(victim));
            act(buf, FALSE, ch, 0, victim->master, TO_CHAR);

            attack(ch, victim->master);
            return 0;
         }
      }

      /* Start the attacker fighting the victim. */
      if (GET_STANCE(victim) > STANCE_STUNNED && !FIGHTING(victim)) {
         /*
          * NPC's always start fighting, but PC's can ignore spells via
          * the PASSIVE flag.
          */
         if (IS_NPC(victim) ||
               (!IS_SPELL(attacktype) || !PRF_FLAGGED(victim, PRF_PASSIVE)))
            /* Caller can decide whether vict should fight back */
            set_fighting(victim, ch, FALSE);
      }

      /*
       * If the mob has memory, make it remember this player.
       */
      if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch))
         remember(victim, ch);
   }

   /* If ch is attacking his/her pet, cancel charming */
   if (victim->master == ch)
      stop_follower(victim, TRUE);

   /* Appear, lose glory */
   aggro_lose_spells(ch);

   if (attacktype != SPELL_ON_FIRE && attacktype != SPELL_POISON) {

      /* Reduce damage for PVP for everything except spells */
      if (!IS_NPC(ch) && !IS_NPC(victim) && attacktype > MAX_SPELLS)
         dam /= 3;

      /* Charmies do half damage. */
      if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
         dam >>= 1;

      /* Sanctuary and stone skin take half damage. */
      if (EFF_FLAGGED(victim, EFF_SANCTUARY) ||
            EFF_FLAGGED(victim, EFF_STONE_SKIN))
         dam >>= 1;

      /* Protection from evil/good takes 90% damage */
      if (EFF_FLAGGED(victim, EFF_PROTECT_EVIL) &&
            GET_ALIGNMENT(ch) <= -500 && GET_ALIGNMENT(victim) >= 500)
         dam *= 0.9;

      else if (EFF_FLAGGED(victim, EFF_PROTECT_GOOD) &&
            GET_ALIGNMENT(ch) >= 500 && GET_ALIGNMENT(victim) <= -500)
         dam *= 0.9;

   }

   /* You can't damage an immortal! */
   if (!IS_NPC(victim) && GET_LEVEL(victim) >= LVL_IMMORT)
      dam = 0;

   if (EFF_FLAGGED(victim, EFF_MINOR_PARALYSIS)) {
      act("$n's attack frees $N from magic which held $M motionless.",
            FALSE, ch, 0, victim, TO_NOTVICT);
      act("$n's blow shatters the magic paralyzing you!", FALSE, ch, 0,
            victim, TO_VICT);
      act("Your blow disrupts the magic keeping $N frozen.", FALSE, ch, 0,
            victim, TO_CHAR);
      effect_from_char(victim, SPELL_MINOR_PARALYSIS);
      effect_from_char(victim, SPELL_ENTANGLE);
      REMOVE_FLAG(EFF_FLAGS(victim), EFF_MINOR_PARALYSIS);
   }

   if (EFF_FLAGGED(victim, EFF_MESMERIZED)) {
      act("$n's attack distracts $N from whatever was fascinating $M.",
            FALSE, ch, 0, victim, TO_NOTVICT);
      act("$n attacks, jolting you out of your reverie!", FALSE, ch, 0,
            victim, TO_VICT);
      act("You drew $N's attention from whatever $E was pondering.", FALSE, ch, 0,
            victim, TO_CHAR);
      effect_from_char(victim, SPELL_MESMERIZE);
      REMOVE_FLAG(EFF_FLAGS(victim), EFF_MESMERIZED);
   }

   if (!pk_allowed)
      check_killer(ch, victim);

   /* Cap damage */
   dam = MAX(MIN(dam, MAX_DAMAGE), 0);

   if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      /* Will the victim die? */
      death = DAMAGE_WILL_KILL(victim, dam);

      /* Vampiric touch */
      if (IS_WEAPON(attacktype) || SKILL_IS_TARGET(attacktype, TAR_CONTACT)) {
         count_hand_eq(ch, &dummy, &attacker_weapons);
         if (ch != victim && attacker_weapons == 0) {
            if (EFF_FLAGGED(ch, EFF_VAMP_TOUCH)) {
                  hurt_char(ch, NULL, -dam, FALSE);
            } else if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0) {
               if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > number(0, 101))
                  hurt_char(ch,   NULL, -dam / 2, TRUE);
               if (number(0, 2))
                  improve_skill(ch, SKILL_VAMP_TOUCH);
            }
         }
      }
   }

   /* You get some exp for doing damage (but not to players or illusions) */
   if (ch != victim && !IS_NPC(ch) && !MOB_FLAGGED(victim, MOB_ILLUSORY))
      gain_exp(ch, (GET_LEVEL(victim) * dam) /
                   MAX(GET_LEVEL(ch) - GET_LEVEL(victim) > 10 ? 30 : 15,
                       50 - GET_LEVEL(ch)),
               GAIN_REGULAR);

   /*
    * skill_message sends a message from the messages file in lib/misc.
    * dam_message just sends a generic "You hit $n extremely hard.".
    * skill_message is preferable to dam_message because it is more
    * descriptive.
    *
    * If we are _not_ attacking with a weapon (i.e. a spell), always use
    * skill_message. If we are attacking with a weapon: If this is a miss or a
    * death blow, send a skill_message if one exists; if not, default to a
    * dam_message. Otherwise, always send a dam_message.
    */
   if (attacktype == SKILL_BAREHAND) {
      if (death)
         skill_message(dam, ch, victim, attacktype, death);
      else
         dam_message(dam, ch, victim, attacktype);
   }
   else if (!IS_WEAPON (attacktype))
      skill_message(dam, ch, victim, attacktype, death);
   else {
      if (death || dam == 0) {
         if (!skill_message(dam, ch, victim, attacktype, death))
            dam_message(dam, ch, victim, attacktype);
      }
      else
         dam_message(dam, ch, victim, attacktype);
   }

   /* Defensive spells bite back */
   if (ch != victim && GET_LEVEL(ch) < LVL_IMMORT && (IS_WEAPON(attacktype) ||
         SKILL_IS_TARGET(attacktype, TAR_CONTACT))) {
      shdam = defensive_spell_damage(ch, victim, dam);
      if (shdam > 0 && !MOB_FLAGGED(victim, MOB_ILLUSORY))
          hurt_char(ch, victim, shdam, TRUE);
   }

   /* Do the damage. */
   if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) {
      hurt_char(victim, ch, dam, TRUE);
      /* Sanity check */
      if (death && !DECEASED(victim)) {
         sprintf(buf,
                  "Error: Damage of %d was predicted to kill %s, but victim survived with %d hp",
                  dam, GET_NAME(victim), GET_HIT(victim));
         mudlog(buf, BRF, LVL_GOD, TRUE);
      }
   }

   /* If the victim is somehow sleeping after all this, then they can't fight. */
   if (!AWAKE(victim)) {
      if (FIGHTING(victim))
         stop_fighting(victim);
      abort_casting(victim);
   }

   /* If the victim died, award exp and quit. */
   if (DECEASED(victim)) {
      /* If the victim is about to die by something like fire or poison,
       * AND they are in combat with someone, let their opponent get the
       * exp for killing it. */
      if (ch == victim && was_fighting) {
         switch (attacktype) {
            case SPELL_ON_FIRE:
            case SPELL_POISON:
            case TYPE_SUFFERING:
               ch = was_fighting;
               break;
         }
      }

      disburse_kill_exp(ch, victim);
      return VICTIM_DEAD;
   }

   /* Response: stand or flee */
   if (AWAKE(victim)) {
      if (GET_POS(victim) < POS_STANDING) {
         delayed_command(victim, "stand", 4 + (100 - GET_DEX(victim)) * 3 / 10, FALSE);
      } else if (IS_NPC(victim) && GET_HIT(victim) < (GET_MAX_HIT(victim) >> 2)) {
         if (MOB_FLAGGED(victim, MOB_WIMPY) && (ch != victim) &&
               !EFF_FLAGGED(victim, EFF_CHARM))
            delayed_command(victim, "flee", 0, FALSE);
      } else if (!IS_NPC(victim) && GET_WIMP_LEV(victim) && (victim != ch) &&
            GET_HIT(victim) < GET_WIMP_LEV(victim)) {
         send_to_char("You attempt to flee!\r\n", victim);
         delayed_command(victim, "flee", 0, FALSE);
      }
   }

   return dam;
}


bool riposte(struct char_data *ch, struct char_data *victim) {
   int ch_hit, vict_riposte;

   if (!GET_SKILL(victim, SKILL_RIPOSTE))
      return FALSE;

   if (GET_POS(victim) <= POS_SITTING)
      return FALSE;

   if (!GET_EQ(victim, WEAR_WIELD) && !GET_EQ(victim, WEAR_2HWIELD) &&
         !GET_SKILL(victim, SKILL_BAREHAND))
      return FALSE;

   ch_hit = number(55, 200);
   ch_hit += GET_HITROLL(ch);
   ch_hit -= monk_weight_penalty(ch);
   vict_riposte = number(20, 50);
   vict_riposte += GET_LEVEL(victim) - GET_LEVEL(ch);
   vict_riposte -= dex_app[GET_DEX(victim)].defensive;
   vict_riposte += GET_SKILL(victim, SKILL_RIPOSTE) * 0.085;

   if (number(1, 10) < 5)
      improve_skill_offensively(victim, ch, SKILL_RIPOSTE);

   if (vict_riposte <= ch_hit)
      return FALSE;

   if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
      act("&8You grab $n's arm and twist it, causing $m to strike $mself!&0",
            FALSE, ch, 0, victim, TO_VICT);
      act("&8$N grabs your arm and twists it, causing you to damage to yourself!&0",
            FALSE, ch, 0, victim, TO_CHAR);
      act("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0",
            FALSE, ch, 0, victim, TO_NOTVICT);
   }
   else {
      act("&8You block $n's attack, and strike back!&0",
            FALSE, ch, 0, victim, TO_VICT);
      act("&8$N blocks your attack, and strikes back!&0",
            FALSE, ch, 0, victim, TO_CHAR);
      act("&7$N blocks $n's attack, and strikes back at $m!&0",
            FALSE, ch, 0, victim, TO_NOTVICT);
   }

   hit(victim, ch, SKILL_RIPOSTE);
   return TRUE;
}

bool parry(struct char_data *ch, struct char_data *victim) {
   int ch_hit, vict_parry;

   if (!GET_SKILL(victim, SKILL_PARRY))
      return FALSE;

   if (GET_POS(victim) <= POS_SITTING)
      return FALSE;

   if (!GET_EQ(victim, WEAR_WIELD) && !GET_EQ(victim, WEAR_2HWIELD) &&
         !GET_SKILL(victim, SKILL_BAREHAND))
      return FALSE;

   ch_hit = number(45, 181);
   ch_hit += GET_HITROLL(ch);
   ch_hit -= monk_weight_penalty(ch);
   vict_parry = number(20, 50);
   vict_parry += GET_LEVEL(victim) - GET_LEVEL(ch);
   vict_parry -= dex_app[GET_DEX(victim)].defensive;
   vict_parry += GET_SKILL(victim, SKILL_PARRY) / 10;
   if (number(1, 10) < 5)
      improve_skill_offensively(victim, ch, SKILL_PARRY);

   if (vict_parry <= ch_hit)
      return FALSE;

   if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
      act("&7You smirk and slap $n's attack away with ease.&0",
            FALSE, ch, 0, victim, TO_VICT);
      act("&7$N smirks and slaps your attack away.&0",
            FALSE, ch, 0, victim, TO_CHAR);
      act("&7$N smirks as $E slaps $n's attack away.&0",
            FALSE, ch, 0, victim, TO_NOTVICT);
   }
   else {
      act("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
   }

   set_fighting(ch, victim, TRUE);

   return TRUE;
}

bool dodge(struct char_data *ch, struct char_data *victim) {
   int ch_hit, vict_dodge;

   if (!GET_SKILL(victim, SKILL_DODGE))
      return FALSE;
   if (GET_POS(victim) <= POS_SITTING)
      return FALSE;

   ch_hit = number(35, 171);
   ch_hit += GET_HITROLL(ch);
   ch_hit -= monk_weight_penalty(ch);
   vict_dodge = number(20, 50);
   vict_dodge += GET_LEVEL(victim) - GET_LEVEL(ch);
   vict_dodge -= dex_app[GET_DEX(victim)].defensive;
   vict_dodge += GET_SKILL(victim, SKILL_DODGE) / 10;
   if (number(1, 10) < 5)
      improve_skill_offensively(victim, ch, SKILL_DODGE);

   if (vict_dodge <= ch_hit)
      return FALSE;

   if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
      if (CAN_SEE(ch, victim))
         act("&7You twist in place and watch $n attack the air nearby.&0",
               FALSE, ch, 0, victim, TO_VICT);
      else
         act("&7You twist in place, avoiding $n's attack.&0",
               FALSE, ch, 0, victim, TO_VICT);
      act("&7$N twists in place causing you to strike nothing but air!&0",
            TRUE, ch, 0, victim, TO_CHAR);
      act("&7$N twists in place as $n attacks the air nearby $M.&0",
            TRUE, ch, 0, victim, TO_NOTVICT);
   }
   else {
      act("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
      act("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
      act("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
   }

   set_fighting(ch, victim, TRUE);

   return TRUE;
}


int weapon_special(struct obj_data *wpn, struct char_data *ch)
{
   int (*name) (struct char_data * ch, void *me, int cmd, char *argument);

   SPECIAL(lightning_weapon);
   SPECIAL(frost_weapon);
   SPECIAL(fire_weapon);
   SPECIAL(vampiric_weapon);
   SPECIAL(holyw_weapon);

   if (GET_OBJ_RNUM(wpn) == NOTHING)
      return 0;
   name = obj_index[GET_OBJ_RNUM(wpn)].func;
   if (name != vampiric_weapon && name != lightning_weapon &&
         name != holyw_weapon && name != fire_weapon &&
         name != frost_weapon)
      return 0;
   return (name)(ch, wpn, 0, "");
}


void hit(struct char_data *ch, struct char_data *victim, int type)
{
   int victim_ac, calc_thaco, dam, diceroll, weapon_position;
   struct obj_data *weapon;
   int thac0_01 = 25;
   int thac0_00 = classes[(int)GET_CLASS(ch)].thac0;
   bool no_defense_check = FALSE;
   int dtype;

   if (!ch || !victim || !event_target_valid(victim) || !event_target_valid(ch) || ch == victim) {
      if (ch && FIGHTING(ch))
         stop_fighting(ch);
      return;
   }

   /* This should not happen */
   if (IN_ROOM(ch) != IN_ROOM(victim)) {
      mprintf(L_ERROR, LVL_GOD, "hit(): %s [%d] is not in the same room as %s [%d]",
            GET_NAME(ch), CH_RVNUM(ch), GET_NAME(victim), CH_RVNUM(victim));
      return;
   }

   /* check if the character has a fight trigger */
   fight_mtrigger(ch);

   /* Check for PK, pets, shapechanged...etc. */
   if (!attack_ok(ch, victim, TRUE)) {
      if (FIGHTING(ch))
         stop_fighting(ch);
      return;
   }

   if (FIGHTING(ch) != victim && EFF_FLAGGED(ch, EFF_BLIND)) {
      send_to_char("You cant see a thing!\r\n", ch);
      mprintf(L_ERROR, LVL_GOD, "hit(): %s is blind but tried to attack new target %s [room %d]",
            GET_NAME(ch), GET_NAME(victim), CH_RVNUM(ch));
      return;
   }

   /* If you were fighting someone else, you're going to switch targets. */
   if (ch->target && ch->target != victim)
      stop_fighting(ch);

   aggro_lose_spells(ch);

   /*
    * This is a hack.   TYPE_UNDEFINED signifies to hit() that
    * we should figure out the damage type based on weapons
    * or barehand.   SKILL_RIPOSTE extends that but signifies
    * that this attack cannot be riposted back (or parried or
    * dodged).   SKILL_DUAL_WIELD signifies that the secondary
    * hand should be used.
    */

   /* Figure out which weapon we want. */
   weapon_position = -1;
   if (type == SKILL_DUAL_WIELD || type == SKILL_2BACK) {
      if (GET_EQ(ch, WEAR_WIELD2) &&
            GET_OBJ_TYPE(GET_EQ(ch, WEAR_WIELD2)) == ITEM_WEAPON)
         weapon_position = WEAR_WIELD2;
   }
   else if (GET_EQ(ch, WEAR_WIELD) &&
                GET_OBJ_TYPE(GET_EQ(ch, WEAR_WIELD)) == ITEM_WEAPON)
      weapon_position = WEAR_WIELD;
   else if (GET_EQ(ch, WEAR_2HWIELD) &&
                GET_OBJ_TYPE(GET_EQ(ch, WEAR_2HWIELD)) == ITEM_WEAPON)
      weapon_position = WEAR_2HWIELD;

   weapon = weapon_position >= 0 ? GET_EQ(ch, weapon_position) : NULL;

   /* If riposting, don't allow a defensive skill check. */
   if (type == SKILL_RIPOSTE)
      no_defense_check = TRUE;

   /* Figure out what kind of damage we're doing. */
   if (type == SKILL_BACKSTAB || type == SKILL_2BACK) {
      if (weapon)
         dtype = skill_to_dtype(GET_OBJ_VAL(weapon, VAL_WEAPON_DAM_TYPE) + TYPE_HIT);
      else
         dtype = DAM_PIERCE;
   }
   else {
      if (type == TYPE_UNDEFINED || type == SKILL_RIPOSTE ||
            type == SKILL_DUAL_WIELD || !type) {
         if (weapon)
            type = GET_OBJ_VAL(weapon, VAL_WEAPON_DAM_TYPE) + TYPE_HIT;
         else if (GET_SKILL(ch, SKILL_BAREHAND))
            type = SKILL_BAREHAND;
         else if (IS_NPC(ch) && ch->mob_specials.attack_type != 0)
            type = ch->mob_specials.attack_type + TYPE_HIT;
         else
            type = TYPE_HIT;
      }
      dtype = skill_to_dtype(type);
   }

   /* Common (fleshy) folks will do crushing damage when not wielding a
    * weapon.   That's how fists work.   But other folks, like for example
    * fire elementals, would do other kinds of damage... like fire. */

   if (!weapon && COMPOSITION_DAM(ch) != DAM_PIERCE &&
            COMPOSITION_DAM(ch) != DAM_SLASH &&
            COMPOSITION_DAM(ch) != DAM_CRUSH) {
       dtype = COMPOSITION_DAM(ch);
   }

   /* Time to see whether it's a hit or a miss */

      /* VALUES: 240 to -50 */
   calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00) * 10;
      /* VALUES: -50 to 70 */
   calc_thaco -= str_app[GET_STR(ch)].tohit * 10;
      /* VALUES: 0 to 40    (max hitroll is 40) */
   calc_thaco -= GET_HITROLL(ch);
      /* VALUES: 0 to 40 */
   calc_thaco -= (4 * GET_INT(ch)) / 10;            /* Int helps! */
      /* VALUES: 0 to 40 */
   calc_thaco -= (4 * GET_WIS(ch)) / 10;            /* So does wis */
      /* calc_thaco ranges from 290 to -240 */

   diceroll = number(1, 200);

      /* VALUES: 100 to -100 */
   victim_ac = GET_AC(victim);
      /* VALUES: 60 to -60 */
   victim_ac += dex_app[GET_DEX (victim)].defensive * 10;
   victim_ac = MAX(-100, victim_ac);            /* -100 is lowest */
      /* victim_ac ranges from 160 to -100 */

   /*
    *    Victim asleep = hit, otherwise:
    *      1..10       = Automatic miss
    *      11..190    = Checked vs. AC
    *      191..200   = Automatic hit
    */
   if (diceroll > 190 || !AWAKE(victim))
      dam = TRUE;
   else if (diceroll < 11)
      dam = FALSE;
   else
      dam = (calc_thaco - diceroll <= victim_ac);

   /* See if the victim evades damage due to non-susceptibility
    * (this applies when asleep, too!)
    */
   if (damage_evasion(victim, ch, weapon, dtype)) {
       damage_evasion_message(ch, victim, weapon, dtype);
       set_fighting(victim, ch, TRUE);
       return;
   }

   /* The attacker missed the victim. */
   if (!dam) {
      damage(ch, victim, 0, type);
   }

   /*
    * Some skills don't get a chance for riposte, parry, and dodge,
    * so short-circuit those function calls here.
    */
   else if (type == SKILL_BACKSTAB ||
                type == SKILL_2BACK ||
                type == SKILL_BAREHAND ||
                no_defense_check ||
                (!riposte(ch, victim) &&
                  !parry(ch, victim) &&
                  !dodge(ch, victim) &&
                  (!weapon || !weapon_special(weapon, ch)))) {
      /*
       * Okay, we know the guy has been hit.   Now calculate damage,
       * starting with the damage bonuses: damroll and strength apply.
       */
      dam = str_app[GET_STR(ch)].todam;
      dam += GET_DAMROLL(ch);

      if (diceroll == 20)
         dam += dam;

      /* Mob barehand damage is always applied */
      if (IS_NPC(ch))
         dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      /* Apply weapon damage if there is one */
      if (weapon)
         dam += dice(GET_OBJ_VAL(weapon, VAL_WEAPON_DICE_NUM),
                     GET_OBJ_VAL(weapon, VAL_WEAPON_DICE_SIZE));
      /* Apply player barehand damage if no weapon*/
      else if (!IS_NPC(ch))
         dam += number(0, 2); /* Yeah, you better wield a weapon. */

      /*
       * Include a damage multiplier if the victim isn't ready to fight.
       * alert     x 1.33
       * resting   x 1.66
       * sleeping  x 2.00
       * stunned   x 2.33
       * incap     x 2.66
       * mortally  x 3.00
       * Note, this is a hack because it depends on the particular
       * values of the STANCE_XXX constants.
       */
      if (GET_STANCE(victim) < STANCE_FIGHTING)
         dam *= 1 + (STANCE_FIGHTING - GET_STANCE(victim)) / 3;

      dam = MAX(1, dam);            /* at least 1 hp damage min per hit */

      if (type == SKILL_BACKSTAB || type == SKILL_2BACK)
         dam *= GET_SKILL(ch, SKILL_BACKSTAB) / 10 + 1;

      else if (type == SKILL_BAREHAND)
         dam += GET_SKILL(ch, SKILL_BAREHAND) / 4 +
                   number(1, GET_SKILL(ch, SKILL_BAREHAND) / 2);

      else {
         /* Spirit of the bear increases the damage you do by up to 10%. */
         if (EFF_FLAGGED(ch, EFF_SPIRIT_BEAR))
            dam *= 1.0 + GET_LEVEL(ch) / 1000.0;

         /* Berserk increases damage done and taken by 10%. */
         if (EFF_FLAGGED(victim, EFF_BERSERK) || EFF_FLAGGED(ch, EFF_BERSERK))
            dam *= 1.1;

         if (EFF_FLAGGED(victim, EFF_STONE_SKIN) && number(0, 10) <= 9) {
            decrease_modifier(victim, SPELL_STONE_SKIN);
            dam = number(0, 3);
         }
      }

      if (type == TYPE_HIT && !dam)
         type = SKILL_PUNCH;

      /* Adjust damage for susceptibility */
      dam = dam_suscept_adjust(ch, victim, weapon, dam, dtype);

      /* Do the damage */
      damage(ch, victim, dam, type);

      if (ALIVE(victim) && EFF_FLAGGED(victim, EFF_IMMOBILIZED))
         decrease_modifier(victim, SPELL_BONE_DRAW);

      /* Do after the damage() so we don't send the wrong type. */
      if (ALIVE(ch) && weapon && !number(0, 9) &&
            (type = weapon_proficiency(weapon, weapon_position)) != -1) {
         improve_skill_offensively(ch, victim, type);
      }
   }

   /* check if the victim has a hitprcnt trigger */
   if (victim)
      hitprcnt_mtrigger(victim);
}


/* Get the skill associated with a weapon. */
int weapon_proficiency(struct obj_data *weapon, int position) {
   int w_type;

   w_type = GET_OBJ_VAL(weapon, VAL_WEAPON_DAM_TYPE) + TYPE_HIT;

   switch(w_type) {
   /* These are generic type weapons.*/
   case TYPE_HIT:
   case TYPE_BITE:
   case TYPE_THRASH:
   case TYPE_PUNCH:
   case TYPE_BLAST:
      return -1;

   /* These are slashing weapons. */
   case TYPE_WHIP:
   case TYPE_SLASH:
   case TYPE_CLAW:
      return position == WEAR_2HWIELD ? SKILL_2H_SLASHING : SKILL_SLASHING;

   /* These are bludgeoning weapons. */
   case TYPE_BLUDGEON:
   case TYPE_CRUSH:
   case TYPE_POUND:
   case TYPE_MAUL:
      return position == WEAR_2HWIELD ? SKILL_2H_BLUDGEONING : SKILL_BLUDGEONING;

   /* These are piercing weapons. */
   case TYPE_STING:
   case TYPE_PIERCE:
   case TYPE_STAB:
      return position == WEAR_2HWIELD ? SKILL_2H_PIERCING : SKILL_PIERCING;

   default:
      log("SYSERR:fight.c:weapon_proficiency: Unknown weapon type");
      return -1;
   }
}



#define MAJORPCODE 1

/* control the fights going on.   Called every 2 seconds from comm.c. */
void perform_violence(void)
{
   struct char_data *ch, *newvict;
   int hits, secondary_hits;

   struct char_data *random_attack_target(struct char_data *ch,
                     struct char_data *target, bool verbose);

   for (ch = combat_list; ch; ch = next_combat_list) {
      next_combat_list = ch->next_fighting;

      if (FIGHTING(ch) == NULL || DECEASED(FIGHTING(ch)) ||
            ch->in_room != FIGHTING(ch)->in_room ||
            EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS)) {
         stop_fighting(ch);
         continue;
      }

#ifdef MAJORPCODE
      if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
         send_to_char("You remain paralyzed and can't do a thing to defend yourself..\r\n", ch);
         act("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
               FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
         if (MOB_FLAGGED(ch, MOB_MEMORY))
            remember(ch, FIGHTING(ch));
         stop_fighting(ch);
         continue;
      }
#endif

      if (check_disarmed(ch))
         continue;

      if (CASTING(ch))
         continue;

      if (GET_POS(ch) < POS_STANDING) {
         send_to_char("You can't fight while sitting!!\r\n", ch);
         continue;
      }

      if (GET_SKILL(ch, SKILL_BERSERK))
         GET_RAGE(ch) += 10 + number(0, GET_SKILL(ch, SKILL_BERSERK) / 10);

      /* Everybody gets at least one hit */
      hits = 1;
      if (GET_SKILL(ch, SKILL_DOUBLE_ATTACK) &&
            GET_SKILL(ch, SKILL_DOUBLE_ATTACK) >= number(1, 101))
         hits *= 2;
      if (EFF_FLAGGED(ch, EFF_HASTE))
         hits += 1;
      if (EFF_FLAGGED(ch, EFF_BLUR))
         hits += 1;
      if (EFF_FLAGGED(ch, EFF_SPIRIT_WOLF) &&
            GET_LEVEL(ch) > number(0, 100))
         hits += 1;

      secondary_hits = 0;
      if (GET_EQ(ch, WEAR_WIELD2) && GET_SKILL(ch, SKILL_DUAL_WIELD) &&
            GET_SKILL(ch, SKILL_DUAL_WIELD) >= number(1, 101)) {
         secondary_hits = 1;
         if (GET_SKILL(ch, SKILL_DOUBLE_ATTACK) &&
               GET_SKILL(ch, SKILL_DOUBLE_ATTACK) >= number(1, 101))
            secondary_hits *= 2;
         if (EFF_FLAGGED(ch, EFF_BLUR))
            secondary_hits += 2;
      }

      /* Chance for NPCs to switch. */
      if (IS_NPC(ch) && GET_SKILL(ch, SKILL_SWITCH) &&
            !EFF_FLAGGED(ch, EFF_BLIND) &&
            !number(0, MAX(10, 30 - GET_LEVEL(ch)))) {
         struct char_data *victim = NULL, *tch;

         /* Find the player fighting this NPC who has the lowest hp in the room */
         for (tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
            if (FIGHTING(tch) == ch && !IS_NPC(tch) && CAN_SEE(ch, tch))
               if (victim == NULL || GET_HIT(tch) < GET_HIT(victim))
                  victim = tch;

         if (victim && FIGHTING(ch) != victim) {
            act("$n switches to $N!", FALSE, ch, 0, victim, TO_NOTVICT);
            act("$n switches to YOU!", FALSE, ch, 0, 0, TO_VICT);
            switch_target(ch, victim);
            hits = 1;
            secondary_hits = 0;
         }
      }

      /* If you're confused, you may spontaneously switch.   But only once per
       * round, not once per hit. */
      if (CONFUSED(ch) && number(0, 3) == 0) {
          newvict = random_attack_target(ch, FIGHTING(ch), TRUE);
          if (newvict != FIGHTING(ch))
             switch_target(ch, newvict);
      }

      do {
         if (hits) {
            hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
            --hits;
         }
         if (FIGHTING(ch) && ALIVE(ch) && secondary_hits) {
            hit(ch, FIGHTING(ch), SKILL_DUAL_WIELD);
            --secondary_hits;
         }
      } while ((hits > 0 || secondary_hits > 0) &&
                   FIGHTING(ch) && ALIVE(ch));

      if (!ALIVE(ch))
         continue;

      if (GET_EQ(ch, WEAR_WIELD2) && GET_SKILL(ch, SKILL_DUAL_WIELD) && number(0, 9) < 3)
         improve_skill_offensively(ch, FIGHTING(ch), SKILL_DUAL_WIELD);

      if (GET_SKILL(ch, SKILL_DOUBLE_ATTACK) && number(0, 9) < 3)
         improve_skill_offensively(ch, FIGHTING(ch), SKILL_DOUBLE_ATTACK);

      if (MOB_FLAGGED (ch, MOB_SPEC) &&
          mob_index[GET_MOB_RNUM(ch)].func != NULL)
         (mob_index[GET_MOB_RNUM(ch)].func)(ch, ch, 0, "");
   }
}


void pickup_dropped_weapon(struct char_data *ch)
{
   struct obj_data *obj;
   char arg[MAX_INPUT_LENGTH];

   ACMD (do_wield);
   int cmd_wield;

   cmd_wield = find_command ("wield");

   for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj->next_content) {
      if (OBJ_FLAGGED(obj, ITEM_WAS_DISARMED) && obj->last_to_hold == ch) {
         obj_from_room(obj);
         obj_to_char(obj, ch);

         if (FIGHTING(ch))
            act("$n finally gets a steady grip on $p.", FALSE, ch, obj, 0, TO_ROOM);
         else
            act("$n eagerly reaches for $p.", FALSE, ch, obj, 0, TO_ROOM);

         REMOVE_FLAG(GET_OBJ_FLAGS(obj), ITEM_WAS_DISARMED);

         strncpy(arg, obj->name, sizeof(arg) - 1);
         do_wield(ch, arg, 0, 0);
         return;
      }
   }
}

/* This function serves to allow:

 *   1) MOBs/PCs to have their penalties removed upon recovery from a fumble.
 *       If they're fighting no one (ie. vict fleed), they recover immediately.
 *   2) MOBs to pick up and re-wield both weapons when their ACT_DELAY_DROPPED_WEAP action_delay[] expires.
 *
 *   PCs don't need automatic weapon recovery, as they can manually do it.
 *
 *   This function is called from perform_violence(), and thus is only called
 *   when the character has valid disarm cooldowns and is combat.   Since disarm
 *   can't be used until after combat has been initiated, and the affects 
 *   it produces are really only useful while in combat, when the affected
 *   char's assailant has fled the room, it'll be perfectly fine to just 
 *   clear all EFFECT-flags and clear all action_delays[] associated with
 *   'disarm'.   This includes when a weapon is dislodged and laying on the
 *   ground--the disarmed MOB will immediately pick it up, and the disarmed
 *   PC may immediately pick his/hers up.
 *
 *   Note: MOB/PCs can NOT be both FUMBLING_WEAP and DROPPED_WEAP for same weap.
 *
 *   Return FALSE if the PC/MOB can attack.   Otherwise, return TRUE.
 */
bool check_disarmed(struct char_data *ch)
{
   /* if not fumbling nor regaining dropped weap, let em strike back */
   if (!GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) &&
         !GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY) &&
         !GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) &&
         !GET_COOLDOWN(ch, CD_DROPPED_SECONDARY))
      return FALSE;

   /* if PC/MOB isn't fighting anyone anymore (vict fleed), remove
       all affect-flags and pick up all dropped weapons */
   if (!FIGHTING(ch)) {
      if (GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) ||
            GET_COOLDOWN(ch, CD_DROPPED_SECONDARY))
         pickup_dropped_weapon(ch);
      GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) = 0;
      GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY) = 0;
      GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) = 0;
      GET_COOLDOWN(ch, CD_DROPPED_SECONDARY) = 0;      
      return FALSE;
   }
   else {
      if (GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) ||
            GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY)) {
         act("$n is trying to get a steady grip on $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You can't seem to get a steady grip on your weapon.\r\n", ch);
      }
      else if (IS_NPC(ch))
         act("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
   }

   return TRUE;
}

/*This is command to sets pc's aggressive state. When set the pc will
   attack aggressive monsters. Depending on thier current hitpoints
   Banyal */
ACMD(do_aggr)
{
   int hp;

   if (IS_NPC(ch)) {
      send_to_char("NPCs can't set their aggressiveness!\r\n", ch);
      return;
   }

   one_argument(argument, buf);

   /* No argument?   Check aggressiveness. */
   if (!*buf) {
      if (GET_AGGR_LEV(ch) <= 0) {
         send_to_char("You are not aggressive to monsters.\r\n", ch);
         return;
      }
      sprintf(buf, "You will be aggressive unless your hitpoints drop below %d.\r\n",
                  GET_AGGR_LEV(ch));
      send_to_char(buf, ch);
      return;
   }

   hp = atoi(buf);

   if (str_cmp(buf, "off") == 0 || (!hp && *buf == '0') ) {
      GET_AGGR_LEV(ch) = 0;
      send_to_char("You are no longer aggressive to monsters.\r\n", ch);
      return;
   }

   if (hp < 0) {
      send_to_char("Aggressive while dying?   Not likely!\r\n", ch);
      return;
   }

   GET_AGGR_LEV(ch) = hp;
   do_aggr(ch, "", 0, 0); /* show aggr status message. */
}


/* new function to calculate thac0 for PCs instead of tabled data */
int calc_thac0( int level, int thac0_01, int thac0_00)
{ return thac0_01 + level * (thac0_00 - thac0_01) / 100; }



/***************************************************************************
 * $Log: fight.c,v $
 * Revision 1.282  2011/08/06 15:46:10  rsd
 * fixed - warning: format not a string literal and no format arguments
 *
 * Revision 1.281  2011/08/06 15:22:51  rsd
 * Fixed log(buf) to log(%s buf)
 *
 * Revision 1.280  2010/07/02 14:09:16  mud
 * Adding cone of cold weapon.
 *
 * Revision 1.279  2010/06/20 19:53:47  mud
 * Log to file errors we might want to see.
 *
 * Revision 1.278  2010/06/05 18:58:19  mud
 * Don't decrease damage for protection spells for being on fire
 * or being poisoned.
 *
 * Revision 1.277  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.276  2010/04/25 22:57:16  mud
 * Changing Celestial Betrayer to shoot fireballs.
 *
 * Revision 1.275  2010/04/25 22:13:38  mud
 * Adding frost weapon spec proc.
 *
 * Revision 1.274  2009/07/18 01:17:23  myc
 * Adding immobilization for bone draw.
 *
 * Revision 1.273  2009/06/20 23:14:13  myc
 * Fix autoloot so it only picks up items actually dropped by a
 * mob who doesn't leave a corpse behind.
 *
 * Revision 1.272  2009/06/10 18:40:33  myc
 * Area spells will work in the arena now.
 *
 * Revision 1.271  2009/06/09 21:48:21  myc
 * Add an action verb to the 'killed by' death message.
 *
 * Revision 1.270  2009/06/09 19:44:45  myc
 * Clans receive a notification when a member dies.
 *
 * Revision 1.269  2009/06/09 19:33:50  myc
 * Rewrote gain_exp and retired gain_exp_regardless.
 *
 * Revision 1.268  2009/03/20 16:00:38  jps
 * Make autoloot/autotreas work when no corpse is left.
 *
 * Revision 1.267  2009/03/19 23:16:23  myc
 * Moved get functions to their own file.
 *
 * Revision 1.266  2009/03/19 23:09:50  jps
 * Make objects decompose properly when dropped by non-corpse-leaving mobs
 *
 * Revision 1.265  2009/03/19 22:47:41  jps
 * Don't attempt to create money with 0 coins!
 *
 * Revision 1.264  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.263  2009/03/15 08:12:53  jps
 * Use a delayed command to make creatures stand when attacked
 *
 * Revision 1.262  2009/03/13 04:40:10  jps
 * Fix up some money macros.
 *
 * Revision 1.261  2009/03/11 21:13:13  jps
 * Don't drop a corpse unless you're of solid composition.
 *
 * Revision 1.260  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.259  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.258  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.257  2009/03/08 21:43:27  jps
 * Split lifeforce, composition, charsize, and damage types from chars.c
 *
 * Revision 1.256  2009/03/07 22:30:52  jps
 * Have skill_message use TO_VICTROOM for the victim damage messages.
 *
 * Revision 1.255  2009/03/07 08:18:33  jps
 * Add debugging messages and core dumping to set_fighting, to help
 * fix that bash-and-they-stand bug.
 *
 * Revision 1.254  2009/02/21 03:30:16  myc
 * Removed L_FILE flag--mprintf now logs to file by default;
 * assert L_NOFILE to prevent that.
 *
 * Revision 1.253  2009/02/16 14:21:04  myc
 * Do decomposition logic before registering corpse (which saves
 * the corpse to file).  We want the decomp timer being saved to disk.
 *
 * Revision 1.252  2009/01/19 09:25:23  myc
 * Removed MOB_PET flag.
 *
 * Revision 1.251  2009/01/16 23:36:34  myc
 * Increase string buffer sizes in attempt to prevent overflow.
 *
 * Revision 1.250  2008/10/31 19:48:33  myc
 * Fix bug in perform_vio where secondary_hits wasn't necessarily being
 * reinitialized each iteration.
 *
 * Revision 1.249  2008/09/26 18:37:49  jps
 * Don't use FIGHTING macro when changing target.
 *
 * Revision 1.248  2008/09/26 09:23:25  jps
 * Bug in hit() fixed.
 *
 * Revision 1.247  2008/09/26 04:59:02  jps
 * A) In stop_battling, the prior target's list of attackers that it was in was
 * improperly truncated at the target.
 * B) In hit(), you'll stop targetting the old person if you're now attacking
 * someone new.
 * C) In perform_violence, there are two situations where you could switch to
 * a new target. This needs to be done so that you're no longer in your old
 * target's attacker list.
 *
 * Revision 1.246  2008/09/25 15:19:37  jps
 * Add some debugging coredumping for attacker linking errors.
 *
 * Revision 1.245  2008/09/21 21:49:59  jps
 * Added transfer_battle(), which allows one character to seamlessly
 * take the place of another in a battle.
 *
 * Revision 1.244  2008/09/21 21:23:32  jps
 * Fix grammar in some monk hit messages.
 *
 * Revision 1.243  2008/09/21 21:16:27  jps
 * Don't allow "flee" to be in a character's event list multiple times.
 *
 * Revision 1.242  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.241  2008/09/20 07:44:21  jps
 * Fix set_fighting a bit.
 *
 * Revision 1.240  2008/09/20 07:26:52  jps
 * Causing set_fighting to take a boolean parameter reciprocate, which indicates that
 * the attackee should also be set fighting, if possible.
 *
 * Revision 1.239  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.238  2008/09/14 04:34:30  jps
 * Set folks fighting even if the initial attack was completely ineffective.
 *
 * Revision 1.237  2008/09/14 03:53:01  jps
 * Implement wimpy-fleeing as a delayed command.
 *
 * Revision 1.236  2008/09/14 03:02:35  jps
 * More sanity checks in quick_aggro_event will prevent attacks happening
 * when the attacker is unconscious.
 *
 * Revision 1.235  2008/09/14 02:08:01  jps
 * Use standardized area attack targetting
 *
 * Revision 1.234  2008/09/06 19:09:42  jps
 * Change decomp time for player corpses so it's longer with equipment inside,
 * but short with nothing or just money inside.
 *
 * Revision 1.233  2008/09/02 07:16:00  mud
 * Changing object TIMER uses into DECOMP where appropriate
 *
 * Revision 1.232  2008/09/02 06:52:30  jps
 * Using limits.h.
 *
 * Revision 1.231  2008/09/01 23:47:49  jps
 * Using movement.h/c for movement functions.
 *
 * Revision 1.230  2008/09/01 18:29:29  jps
 * Clearing cooldowns upon death.
 *
 * Revision 1.229  2008/08/31 20:53:44  jps
 * Moved several ai-related functions to ai_utils.c
 *
 * Revision 1.228  2008/08/30 22:44:44  myc
 * Fix change_alignment so it doesn't force alignment to 1000.
 *
 * Revision 1.227  2008/08/30 20:25:38  jps
 * Moved count_hand_eq() into handler.c and mentioned it in handler.h.
 *
 * Revision 1.226  2008/08/30 18:20:53  myc
 * Made weapon_special check for a NOTHING rnum before trying to
 * access the index.
 *
 * Revision 1.225  2008/08/30 01:31:51  myc
 * Changed the way stats are calculated in effect_total; ability
 * stats are saved in a raw form now, and only capped when accessed.
 * Damroll and hitroll are recalculated everytime effect_total
 * is called, using cached base values.
 *
 * Revision 1.224  2008/08/24 19:29:11  jps
 * Apply damage susceptibility reductions to the various physical attack skills.
 *
 * Revision 1.223  2008/08/23 13:17:07  jps
 * Don't let aggros get distracted by GLORY-ous folks they can't see.
 *
 * Revision 1.222  2008/08/21 08:05:56  jps
 * Move dead-player object file deletion to the point at which their stuff
 * drops on the ground with the corpse.  Hopefully this will eliminate the
 * kit-duplication bug.
 *
 * Revision 1.221  2008/08/16 17:24:14  jps
 * Clear the trophy when a player dies, unless QUEST preference is on.
 *
 * Revision 1.220  2008/08/09 18:16:21  jps
 * Got rid of weapon-slinging.
 *
 * Revision 1.219  2008/07/29 17:52:47  jps
 * Changed set_fighting so it merely does nothing if the subject was already
 * fighting.
 *
 * Revision 1.218  2008/06/07 19:06:46  myc
 * Moved all object-related constants and structures to objects.h
 *
 * Revision 1.217  2008/06/05 02:07:43  myc
 * Changed object flags to use flagvectors.  Corpses now save their
 * level in the normal object level field instead of in cost_per_day.
 * Rewrote corpse saving and loading to use ascii object files.
 *
 * Revision 1.216  2008/05/25 21:00:49  myc
 * Fix dual wield and double attack to move skill normally.
 *
 * Revision 1.215  2008/05/19 05:48:09  jps
 * Don't allow aggression when mesmerized. Being attacked will break
 * you out of mesmerization.
 *
 * Revision 1.214  2008/05/18 20:46:02  jps
 * Cause GLORY to be removed when you're offensive, just like invis.
 *
 * Revision 1.213  2008/05/18 20:15:37  jps
 * Changed aggro/glory checking.
 *
 * Revision 1.212  2008/05/18 17:59:24  jps
 * Prevent aggro attacks upon folks with familiarity.
 *
 * Revision 1.211  2008/05/18 05:18:06  jps
 * Renaming room_data struct's member "number" to "vnum", cos it's
 * a virtual number.
 *
 * Revision 1.210  2008/05/17 22:03:01  jps
 * Moving room-related code into rooms.h and rooms.c.
 *
 * Revision 1.209  2008/05/17 04:32:25  jps
 * Moved exits into exits.h/exits.c and changed the name to "exit".
 *
 * Revision 1.208  2008/05/14 05:11:51  jps
 * Using hurt_char for play-time harm, while alter_hit is for changing hp only.
 *
 * Revision 1.207  2008/05/12 01:10:57  jps
 * Return the flee-checking code to damage().
 *
 * Revision 1.206  2008/05/12 00:42:30  jps
 * Pass "death" to skill_message since it wouldn't otherwise know
 * whether the victim died due to the attack.
 *
 * Revision 1.205  2008/05/11 22:31:58  jps
 * Don't remove xp from dying mobs - you still need it for disbursement
 * to the player who killed it.
 *
 * Revision 1.204  2008/05/11 06:14:05  jps
 * Calculations and messages about defensive spells lie fireshield
 * are now handled in magic.c.
 *
 * Revision 1.203  2008/05/11 05:57:56  jps
 * Got rid of update_pos. alter_pos should be used instead. Changed damage()
 * a lot due to alter_hit, which handles messages and dying.
 *
 * Revision 1.202  2008/04/19 21:01:56  jps
 * Don't mark spell circles empty when unmemming spells at death.
 *
 * Revision 1.201  2008/04/18 00:31:16  jps
 * Prevent skill improvement crash with TYPE_UNDEFINED.
 *
 * Revision 1.200  2008/04/16 01:53:23  jps
 * Increase the intra-calculation values by a factor of 10 when
 * determining THAC0, AC, and whether a hit connects.  This doesn't
 * change the overall form of the calculations, but it does make
 * individual point changes in hitroll, AC, wis, and int significant.
 * In other words, you no longer have the same hitroll bonus for all
 * values of hitroll between 10 and 19.  The little extra ones help.
 *
 * Revision 1.199  2008/04/14 02:32:07  jps
 *  Consolidate the loss of hiddenness when being violent into a single
 * function.  It also removes glory.
 *
 * Revision 1.198  2008/04/13 20:53:25  jps
 * Make confused people switch to random targets during battle.
 *
 * Revision 1.197  2008/04/13 10:23:34  jps
 * Allow auxiliary skills like dual wield to improve.
 *
 * Revision 1.196  2008/04/13 00:57:53  jps
 * Implement the auto treasure toggle, which makes you loot coins
 * and "treasure" type objects.  Which includes gems.
 *
 * Revision 1.195  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.194  2008/04/05 06:35:03  myc
 * Fix another crash bug: perform_die assumed killer would be non-null,
 * when this is not necessarily the case.
 *
 * Revision 1.193  2008/04/04 20:47:43  jps
 * Make a macro for checking skill targets, since some places will
 * query it with invalid skills.
 *
 * Revision 1.192  2008/04/04 06:12:52  myc
 * Removed justice code and several old spec procs.
 *
 * Revision 1.191  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.190  2008/04/02 17:41:56  myc
 * Fixed vampiric touch.
 *
 * Revision 1.189  2008/04/02 05:36:19  myc
 * Added the autoloot toggle, which allows players to automatically
 * pick the items up from a corpse.
 *
 * Revision 1.188  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.  Cleaned
 * up death code.
 *
 * Revision 1.187  2008/03/30 16:05:08  jps
 * Cancel other events when you're about to die.  This may prevent
 * those 'double deaths' from recurring.
 *
 * Revision 1.186  2008/03/30 15:37:36  jps
 * Fix spelling of riposte.
 *
 * Revision 1.185  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.184  2008/03/27 17:29:51  jps
 * Ethereal creatures are now attackable when you have the spell
 * effect of bless or hex.
 *
 * Revision 1.183  2008/03/27 00:20:35  jps
 * Use the default damage type according to one's composition, if
 * your default attack is not physical.
 *
 * Revision 1.182  2008/03/26 23:11:17  jps
 * Stop doing special checks for waterform and vaporform, since
 * now they actually change your body's composition.
 *
 * Revision 1.181  2008/03/26 22:14:01  jps
 * Add some stance modifications to prevent loops between alter_hit and update_pos.
 *
 * Revision 1.180  2008/03/26 18:12:32  jps
 * Ethereal creatures are now vulnerable to blessed physical attacks.
 *
 * Revision 1.179  2008/03/26 16:44:36  jps
 * Replaced all checks for undead race with checks for undead lifeforce.
 * Replaced the undead race with the plant race.
 *
 * Revision 1.178  2008/03/24 08:44:03  jps
 * Checking composition to see if a victim will evade physical damage
 * entirely, and to change the damage amount.
 *
 * Revision 1.177  2008/03/16 00:21:36  jps
 * Updated calls to kill_to_trophy().
 *
 * Revision 1.176  2008/03/11 19:50:55  myc
 * Make rage depend on skill in berserking.
 *
 * Revision 1.175  2008/03/10 20:46:55  myc
 * Renamed POS1 to 'stance'.
 *
 * Revision 1.174  2008/03/09 09:00:20  jps
 * Fix paralysis-breakage message. Don't let paralyzed folks fight.
 *
 * Revision 1.173  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.172  2008/03/09 02:07:48  jps
 * Fix previous change.
 *
 * Revision 1.171  2008/03/09 01:55:01  jps
 * Don't let active-defense shields of illusions hurt their attackers.
 *
 * Revision 1.170  2008/03/08 23:51:22  jps
 * Adjust death cry logic for script vs. non-script mobs.
 *
 * Revision 1.169  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.168  2008/03/06 05:11:51  myc
 * Combined the 'saved' and 'unsaved' portions of the char_specials and
 * player_specials structures by moving all fields of each saved structure
 * to its parent structure.  Also combined the skills array from the
 * player and mob structures since they are identical.
 *
 * Revision 1.167  2008/03/05 03:03:54  myc
 * Changed the spell memory and trophy structures.
 *
 * Revision 1.166  2008/02/23 01:03:54  myc
 * Fixed the code that empties the spell list when a character dies.
 *
 * Revision 1.165  2008/02/16 20:31:32  myc
 * Adding functions to free messages at program termination.
 *
 * Revision 1.164  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.
 *
 * Revision 1.163  2008/02/09 18:29:11  myc
 * The event code now handles freeing of event objects.
 *
 * Revision 1.162  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.161  2008/02/08 14:13:25  jps
 * Tone down damage from shield-spells.
 *
 * Revision 1.160  2008/02/06 03:45:08  myc
 * Fixing a bug with some damage messages not being sent (when
 * skill improvements occured).
 *
 * Revision 1.159  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.158  2008/01/29 16:51:12  myc
 * Adding the concept of contact skills and spells, for stuff like
 * fireshield and coldshield.  Fixing weapon specials.  Disabling
 * the use of non weapons as weapons.
 *
 * Revision 1.157  2008/01/28 03:05:33  jps
 * Change some messages to punch, when missing.
 *
 * Revision 1.156  2008/01/28 00:46:05  jps
 * Add more info to missing-message string.
 *
 * Revision 1.155  2008/01/27 21:09:12  myc
 * Stop fireshield, coldshield, and soulshield from hurting immortals.
 * Make characters use SKILL_PUNCH when hitting instead of TYPE_HIT
 * (this is the way it was before).  Initial implementation of spirit
 * of the wolf, spirit of the bear, and berserk.  Make players aggro
 * while berserking.
 *
 * Revision 1.154  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.153  2008/01/27 12:12:40  jps
 * Changed IS_THIEF macro to IS_ROGUE.
 *
 * Revision 1.152  2008/01/27 02:25:25  jps
 * When starting a fight, you don't get to stand up if you're lagged.
 *
 * Revision 1.151  2008/01/26 12:28:32  jps
 * Using improve_skill_offensively so that your skills won't improve
 * if used against illusions.  Made death into an event.
 *
 * Revision 1.150  2008/01/25 21:05:45  myc
 * Rewrote perform_violence and hit.  Removed hit2.  Fireshield,
 * coldshield, and soulshield damage now happens in damage instead
 * of hit.  Functionalized riposte, parry, and dodge.  The hit function
 * now handles physical attacks for both hands, using the damage
 * type passed to it to figure out which hand.  sling_weapon no
 * longer requires both the weapon and position; just the position
 * must be passed to it now.  perform_violence has a loop for hits,
 * instead of repeated calls to hit.
 * In short, revamped the core of the combat system.  But it shouldn't
 * be noticable.  Everything should behave exactly the same...
 *
 * Revision 1.149  2008/01/23 05:31:24  jps
 * Move exp gain/trophy/align change to receive_kill_credit().
 *
 * Revision 1.148  2008/01/16 04:12:00  myc
 * Adding quick-aggro event.  Moved pick_target from mobact and named
 * it find_aggr_target.
 *
 * Revision 1.147  2008/01/14 21:29:06  myc
 * Moved is_aggr_to here from mobact.c.  Fixed up the do_aggr command,
 * but disabled the player quick-aggro feature.
 *
 * Revision 1.146  2008/01/13 23:06:04  myc
 * Removed the number_of_groupees function.  Use group_size.
 *
 * Revision 1.145  2008/01/12 19:08:14  myc
 * Renamed 'Forgive_the_basterd' as 'remove_from_all_memories'.
 *
 * Revision 1.144  2008/01/10 23:12:07  myc
 * When returning to a conscious position from incapacitation or below,
 * a message will be shown saying the victim sits up. (update_pos)
 * Also cleaned up update_pos a lot more, and (I think) determined the
 * purpose of the crazy code.
 *
 * Revision 1.143  2008/01/10 06:47:49  myc
 * Updated skill_message to work with healing messages.  Also cleaned it
 * up significantly.  Moved the call to update_pos in damage to occur after
 * the call to skill_message, since update_pos may display some messages
 * that make more sense after the damage message.
 *
 * Revision 1.142  2008/01/10 05:39:43  myc
 * Tried to clean up the formatting in update_pos a bit.  It still seems
 * to have a great deal of superfluous code, but I can't tell what it's
 * supposed to do, so I don't want to remove it.
 *
 * damage() now returns the amount of damage it caused.  Negative values
 * indicate healing, and a return value of VICTIM_DEAD indicates that the
 * victim is dead.
 *
 * alter_hit now takes a boolean specifying whether to cap any increase in
 * hitpoints by the victim's max hp.
 *
 * Revision 1.141  2008/01/06 23:50:47  jps
 * Added spells project and simulacrum, and MOB2_ILLUSORY flag.
 *
 * Revision 1.140  2008/01/06 17:34:15  jps
 * Use thac0 in classes array.
 *
 * Revision 1.139  2007/12/23 20:42:21  myc
 * Make vamp touch only work when hurting someone else.
 *
 * Revision 1.138  2007/12/23 20:36:54  myc
 * Don't show damage messages for immortals when ch == vict.  Also,
 * if a message is missing in the messages file, replace it with an
 * error message.
 *
 * Revision 1.137  2007/12/09 03:30:55  jps
 * Don't allow incap'd folks to start fighting. Handled this at the source
 * rather than changing all the calls to start_fighting.
 *
 * Revision 1.136  2007/10/27 18:56:26  myc
 * When a mob dies of fire, poison, of suffering, if they were fighting
 * someone, their opponent gets the exp for the kill.
 *
 * Revision 1.135  2007/10/25 20:38:55  myc
 * Make death log show room vnum the player died in.
 *
 * Revision 1.134  2007/10/13 20:56:00  myc
 * Slinging into other rooms wasn't working.
 *
 * Revision 1.133  2007/10/13 20:13:37  myc
 * Cleaned up sling-weapon code.  There were some apparent mistakes that
 * made you much more likely to sling your weapon than should be true.
 *
 * Revision 1.132  2007/10/04 16:20:24  myc
 * Transient item flag now makes things decay when they are on the ground.
 * Added this flag to corpses.
 *
 * Revision 1.131  2007/10/02 02:52:27  myc
 * Incapacitation via damage() now stops casting.  Skills won't
 * improve in the PK arena anymore.
 *
 * Revision 1.130  2007/09/20 21:20:43  myc
 * Hide points and perception are in.
 *
 * Revision 1.129  2007/09/20 09:15:14  jps
 * Typo fix
 *
 * Revision 1.128  2007/09/15 15:36:48  myc
 * Natures embrace now sets camouflage bit, which lets you be hidden as long
 * as you are outside.
 *
 * Revision 1.127  2007/09/15 05:03:46  myc
 * AFF_DROPPED_PRIM and AFF_DROPPED_SECOND were incorrectly marked as
 * Aff1 flags.  They should be Aff 2 flags.
 *
 * Revision 1.126  2007/09/08 22:37:42  jps
 * Stop appending extra damage amounts to riposte messages.
 *
 * Revision 1.125  2007/09/03 23:49:40  jps
 * Add mass_attack_ok() so that you could kill your own pet specifically,
 * but your area spells will not harm it.
 *
 * Revision 1.124  2007/08/26 21:10:42  jps
 * Don't append (0) to deity-immunity messages about damage.
 *
 * Revision 1.123  2007/08/23 01:40:10  jps
 * Make it so you can attack your own pet again.
 *
 * Revision 1.122  2007/08/22 22:47:43  jps
 * Add cr/lf to messages in appear().
 *
 * Revision 1.121  2007/08/14 22:43:07  myc
 * Cleaned up appear().
 *
 * Revision 1.120  2007/08/05 20:21:51  myc
 * Arena death sets pos1 to resting now.
 *
 * Revision 1.119  2007/08/04 21:13:22  myc
 * append_damage_amount now accepts negative values (and makes them green)
 * to signify healing.
 *
 * Revision 1.118  2007/08/04 14:40:35  myc
 * Added MOB_PEACEFUL flag to prevent players from attacking certain mobs.
 * Won't hear death cry echoed into arena when standing in observatory.
 * Cleaned up damage amounts code with append_damage_amount function.  All
 * attacks should now have damage amounts appended (if damage_amounts is on).
 *
 * Revision 1.117  2007/08/04 01:15:50  jps
 * Prevent killer flagging and real death in arena rooms.
 *
 * Revision 1.116  2007/08/03 22:00:11  myc
 * Added PK observatories that work adjacent to arena rooms.
 *
 * Revision 1.115  2007/08/03 03:51:44  myc
 * check_pk is now attack_ok, and covers many more cases than before,
 * including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
 * offensive attacks now use attack_ok to determine whether an attack is
 * allowed.
 *
 * Revision 1.114  2007/08/02 01:04:10  myc
 * check_pk() now works for all PK cases.  Moved from magic.c to fight.c
 *
 * Revision 1.113  2007/08/01 02:10:16  jps
 * Reduce the speed at which tame improves a bit.
 *
 * Revision 1.112  2007/07/18 23:54:07  jps
 * Messages will reflect the actual weapon used when someone backstabs
 * with a piercing weapon in their off hand.
 *
 * Revision 1.111  2007/07/18 21:04:26  jps
 * Make mobs behave mercifully toward other mobs only when
 * they are flagged NOVICIOUS.
 *
 * Revision 1.110  2007/07/18 16:47:37  jps
 * Stop active-defense spells such as fireshield from harming self.
 * This problem had cropped up when someone was ON_FIRE and had
 * fireshield at the same time.
 *
 * Revision 1.109  2007/07/14 04:17:35  jps
 * Updated call to stop_follower(), which cares whether this is being
 * done due to a violent action or not.
 *
 * Revision 1.108  2007/06/24 23:55:25  myc
 * Removed the double skill improvement for dodge, parry, and riposte.
 *
 * Revision 1.107  2007/06/15 00:47:05  myc
 * Vaporform is a bit overpowered, toning it down.
 *
 * Revision 1.106  2007/06/07 23:53:38  myc
 * Fixing skill messages to work with 2H weapons.
 *
 * Revision 1.105  2007/06/03 03:46:27  jps
 * Formatted skill_message.
 *
 * Revision 1.104  2007/05/11 20:13:28  myc
 * Vaporform is a new circle 13 spell for cryomancers.  It significantly
 * increases the caster's chance of dodging a hit.  It is a quest spell.
 *
 * Revision 1.103  2007/04/19 00:53:54  jps
 * Create macros for stopping spellcasting.
 *
 * Revision 1.102  2007/04/18 00:37:17  myc
 * Fixing death triggers so that returning a value is still meaningful
 * (returning 0 suppresses the death cry).
 *
 * Revision 1.101  2007/04/11 05:47:40  jps
 * Different message for unhiding, as opposed to losing invisibility.
 *
 * Revision 1.100  2007/03/27 04:27:05  myc
 * Improve skill function now increases skill more for certain harder-to-use
 * skills.
 *
 * Revision 1.99  2007/02/20 17:16:27  myc
 * When combat removes minor paralysis, it zaps entangle too.
 *
 * Revision 1.98  2007/02/14 03:54:53  myc
 * Waterform reduces damage by 1/3, protection from evil and good reduce damage
 * by 10%.
 *
 * Revision 1.97  2007/02/08 01:30:00  myc
 * If the victim and damager of a damage() call are the same person, no longer
 * shows the damager message, getting rid of some of those pesky (null)s.
 *
 * Revision 1.96  2006/11/20 06:50:59  jps
 * Call death trigger even when there isn't a killer.
 *
 * Revision 1.95  2006/11/20 06:44:26  jps
 * Fix creatures dying of bloodloss as you're fighting them.
 *
 * Revision 1.94  2006/11/18 21:00:28  jps
 * Reworked disarm skill and disarmed-weapon retrieval.
 *
 * Revision 1.93  2006/11/18 07:03:30  jps
 * Minor typo fixes
 *
 * Revision 1.92  2006/11/13 15:54:22  jps
 * Fix widespread misuse of the hide_invisible parameter to act().
 *
 * Revision 1.91  2006/11/08 09:16:04  jps
 * Fixed some loose-lose typos.
 *
 * Revision 1.90  2006/07/20 07:40:22  cjd
 * Typo fixes.
 *
 * Revision 1.89  2003/08/04 02:41:19  jjl
 * Removed the killer level restriction
 * for zzur's gem drop quest thing.
 *
 * Revision 1.88  2003/08/02 17:42:50  jjl
 * Added a random gem drop for mobs under level 60, for Zzur's insano-quest.
 *
 * Revision 1.87  2003/07/19 05:07:16  jjl
 * Fixed entangle.
 *
 * Revision 1.86  2003/06/25 05:06:59  jjl
 * More updates.  I seem to be off of my game.
 *
 * Revision 1.85  2003/06/20 15:06:03  rls
 * Added back in sanct functionality... PLEASE see me before undoing this! RLS
 *
 * Revision 1.84  2003/06/20 12:57:37  rls
 * *** empty log message ***
 *
 * Revision 1.83  2003/02/01 19:59:36  mud
 * *** empty log message ***
 *
 * Revision 1.81  2002/09/30 01:10:52  jjl
 * Put in checks so guard actually does something.
 *
 * Revision 1.80  2002/09/15 04:53:08  jjl
 * No more throwing your primary weapon and winding up with only a secondary.  This ought to make me friends
 * with the monk population.
 *
 * Revision 1.79  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.78  2002/07/24 04:11:23  rls
 * Added message to charmies aggressor switch.. and made it check
 * to see if charmie's master IS invis or not!!!
 *
 * Revision 1.77  2002/06/09 13:52:41  dce
 * Now, only if you have a critical miss (diceroll == 1) you
 * have a chance to sling your weapon.
 *
 * Revision 1.76  2002/06/07 01:03:58  rls
 * Adjusted die roll for thac0, some stuff with dam messages as well.
 *
 * Revision 1.75  2002/06/06 01:02:13  dce
 * Opps that should have been divided by 10 not 100.
 *
 * Revision 1.74  2002/06/06 00:34:33  rls
 * THAC0 same for PC clases and Mob Classes, same div by for hr bonus
 *
 * Revision 1.73  2002/06/05 01:16:05  dce
 * Adjusted Dodge, Parry, and Ripost. Basically I divided the
 * skill checks by 100. It apears they were still based on the
 * 100 max skill system.
 *
 * Revision 1.72  2002/05/24 03:16:48  rls
 * Slight mod to thac0 stuff (PC hitroll /5 due to eq bonuses)
 *
 * Revision 1.71  2002/05/23 00:21:17  rls
 * Improved thac0 to use linear calc_thac0 function instead of tables.
 * Lessened the gain from int and wis on thac0 as well as toned down
 * NPC hitroll due to overmaxing the thac0 scores.
 *
 * Revision 1.70  2002/03/30 19:20:14  dce
 * Added damage amounts as a toggable item.
 *
 * Revision 1.69  2002/03/30 13:33:32  dce
 * Reduced the damage of riposte.
 *
 * Revision 1.68  2002/03/27 02:25:04  dce
 * Added damage to messages, per Zzur's request.
 *
 * Revision 1.67  2002/03/15 02:45:14  dce
 * Fixed set_fighting so that a resting player's pos1 is also
 * set to standing.
 *
 * Revision 1.66  2002/02/18 02:26:19  dce
 * After battle, added a check to see if player/mob was in position
 * fighting. If so set them to standing other wise leave them.
 *
 * Revision 1.65  2002/02/14 02:07:33  dce
 * Adjusted the way you wake up from sleeping when you get
 * attacked. Was POS1_PRONE, put it POS1_STANDING/SITTING.
 *
 * Revision 1.64  2002/02/13 23:27:11  dce
 * Modified set_fighting. The GET_POS = POS_FIGHTING was commented
 * out casuing problems in the fighting routine, so I uncommented
 * it. I also made it you that you can not hit while your position
 * is < POS_STANDING.
 *
 * Revision 1.63  2002/02/11 23:49:39  dce
 * Removed the only NOGEAR functionality because it was
 * crashing the mud when a corpse was removed.
 *
 * Revision 1.62  2002/02/11 02:28:31  dce
 * The wimpy check always made a mob or player stop fighting
 * even if the do_flee failed. The do_flee routine should
 * do the stop fighting call so I removed those two lines.
 * /s
 *
 * Revision 1.61  2001/12/14 03:33:48  dce
 * Ok, it should be illegal to code when you are tired and it
 * is late. Removed the last thing mentioned.
 *
 * Revision 1.60  2001/12/14 03:27:46  dce
 * Forgot to add the reverse check for the blob bug.
 * Added right under the other check.
 *
 * Revision 1.59  2001/12/14 03:20:45  dce
 * Fixed the 'blob bug', in the perform violence. The
 * mob was dying from a riposte in a hit function call.
 * Then when it reached the MOB_FLAGGED line the mud crashed
 * beacuse the pointer had been freed. Added a check to see
 * if the mob is dead before that call.
 *
 * Revision 1.58  2001/12/13 02:06:32  dce
 * Another attempt to fix the blob crash bug.
 * Here I added a check in void hit that checks if
 * the player and mob are fighting after a riposte...
 * both parry and dodge already had this check.
 *
 * Revision 1.57  2001/12/12 02:45:03  dce
 * Fixed it so gods switched in a creature that dies should
 * now produce a corpse.
 *
 * Revision 1.56  2001/12/05 18:03:40  rjd
 * Parry typo corrected. It now outputs the correct verbage when appropriate (i.e. "parries"
 * instead of "parry" for lines such as "Demolitum parries your attack." and "Demolitum
 * parries Kharnez's attack."
 *
 * Revision 1.55  2001/04/06 03:25:25  dce
 * Corpses will now have a level.
 *
 * Revision 1.54  2001/03/25 12:44:50  dce
 * Mobs should now become visible when fighting.
 *
 * Revision 1.53  2001/03/10 18:45:33  dce
 * Changed do_return function to pass a subcommand of 1.
 * This way I can make it so players can't use the return command.
 *
 * Revision 1.52  2001/03/09 03:05:21  dce
 * Shapechanged players can no longer kill shapechanged players.
 *
 * Revision 1.51  2001/03/07 01:45:18  dce
 * Added checks so that players can not kill shapechanged players and
 * vise versa. Hopefully I didn't miss any...
 *
 * Revision 1.50  2001/02/24 04:04:33  dce
 * Shapechanged players die, lose their hp, and corpse
 * shows up in the right room
 *
 * Revision 1.49  2000/11/28 01:22:42  mtp
 * removed mprog code
 *
 * Revision 1.48  2000/11/27 08:12:52  mtp
 * oops = mistake at end of change_align in the bounding
 *
 * Revision 1.47  2000/11/21 18:33:41  rsd
 * Added back rlog messages from prior to the addition
 * of the $log$ string.
 *
 * Revision 1.46  2000/11/17 01:47:42  mtp
 * new align change code, based on a series of curves (well, lines)
 * that are determined by the killers align
 *
 * Revision 1.45  2000/11/13 03:23:23  rsd
 * Oooook, someone put in a one line if before the log
 * message I deleted earlier so since I didn't see braces
 * I didn't see to delete the if.  The if was if (whatver)
 * log debug
 * So, deleting the debug made the if apply to the next line.
 * Man was the code pissed off.
 *
 * Revision 1.44  2000/11/13 03:08:30  rsd
 * Removed an unnecessary log message.
 *
 * Revision 1.43  2000/11/10 00:28:04  mtp
 * oops..would have sent message to start room rather than finish room!
 *
 * Revision 1.42  2000/11/10 00:22:30  mtp
 * moved the obj_to_room() to AFTER the attempt to ref it in the sling out of room..
 * just in case the next room is a water room and the obj gets extracted...
 *
 * Revision 1.41  2000/06/01 19:52:46  rsd
 * added more detail to a mysterious log message in sling_weapon
 *
 * Revision 1.40  2000/04/17 00:54:12  rsd
 * weapon slinging is now in very loud yellow and reversed
 * BLUE wooo!
 *
 * Revision 1.39  2000/04/14 00:53:27  rsd
 * Someone had me check to see if coldshield/fireshield actually caused
 * damage so while in the file, I fixed the comment header and stylized
 * do_hit, tabs and }'s ...
 *
 * Revision 1.38  2000/03/05 01:24:43  rsd
 * added dispel_good_weapon type to the proper function.
 *
 * Revision 1.37  2000/02/25 03:14:19  cso
 * fixed a typo in peaceful rooms -- disrurb to disturb. yay!
 *
 * Revision 1.36  1999/12/10 22:13:45  jimmy
 * Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
 * level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
 * exp code.
 *
 * Revision 1.35  1999/12/06 10:46:06  jimmy
 * Fixed crash that happened when a weapon was slung into a room with noone there.
 *
 * Revision 1.34  1999/11/28 23:21:22  cso
 * make_corpse: modified values for corpses
 * damage: animated mobs no longer flee
 *
 * Revision 1.33  1999/11/28 19:36:58  jimmy
 * Added stun time associated with slinging a weapon.  Also, a one in five chance
 * will sling the weapon into another room.
 *
 * Revision 1.32  1999/11/23 15:48:23  jimmy
 * Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
 * Reinstated dual wield.
 * Allowed mobs/players to pick up items while fighting.
 * Fixed a bug in the damage message that wrongfully indicated a miss
 * due to a rounding error in the math.
 * This was all done in order to facilitate the chance to sling your
 * weapon in combat.  Dex and proficiency checks are now made on any missed
 * attact and a failure of both causes the weapon to be slung.
 *
 * Revision 1.31  1999/10/30 15:35:19  rsd
 * Jimmy coded alignment restrictions on Paladins for exp.
 * Altered gain_exp() to add a victim check for alignment.
 * l
 *
 * Revision 1.30  1999/09/16 01:15:11  dce
 * Weight restrictions for monks...-hitroll, -damroll + ac
 *
 * Revision 1.29  1999/09/08 07:06:03  jimmy
 * More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
 * with blood and killing
 * --gurlaek
 *
 * Revision 1.28  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.27  1999/08/29 17:48:53  mud
 * corrected the spelling of dirstacted in the monk combat semantics.
 *
 * Revision 1.26  1999/08/14 22:55:36  mud
 * removed a double space from nearly rips you in two with $s deadly #w!!&0"
 *
 * Revision 1.25  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.24  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.23  1999/07/25 05:40:18  jimmy
 * Fixed the skill advancement in peace rooms bug.
 * --gurlaek
 *
 * Revision 1.22  1999/07/24 02:55:05  dce
 * Tweaked alignment code
 *
 * Revision 1.21  1999/07/23 15:01:50  dce
 * Alignment completely redone.
 *
 * Revision 1.20  1999/07/15 03:27:34  jimmy
 * Mob casters can not hit while casting.
 * Updated spell cast times to be more realistic
 * changed combat to 4 seconds per round.
 * Removed do_order semantics that told the order to onlookers.
 *
 * Revision 1.19  1999/07/14 19:24:03  jimmy
 * The combat system was enhanced/improved in the following ways:  Mobs
 * can no longer flee while bashed or sitting.  Fleeing causes casters to
 * stop casting.  You can now flee while flying.  pk checks were added to
 * bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
 * fixes. spellcasting for mobs is now very similar to PC spellcasting.
 * MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
 * Mobs no longer improve skills.  Bash now requires mobs to have a shield
 * just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
 * --gurlaek
 *
 * Revision 1.18  1999/07/07 15:46:44  jimmy
 * Fixed the group NPC issue.  Players can no longer group NPC's and
 * crash the mud at will
 * --gurlaek 7/7/1999
 *
 * Revision 1.17  1999/07/02 19:23:18  jimmy
 * Fixed ANSI compile warnings in fight.c by removing the void *
 * function pointer and adding a type field
 * --gurlaek
 *
 * Revision 1.16  1999/06/11 16:56:55  jimmy
 * Ok, fixed do_quit to check for fighting and also not crash when mortally
 * wounded.  This was done in die() by checking for killer=NULL.
 * since no one killed you if you quit while morted the die code
 * didn't know how to deal with a NULL killer.
 * --Gurlaek 6/11/1999
 *
 * Revision 1.15  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.14  1999/05/02 16:20:32  dce
 * Clean up
 *
 * Revision 1.13  1999/04/08 04:26:36  dce
 * Fixed the mounting problem.
 *
 * Revision 1.12  1999/03/23 16:07:04  dce
 * No pkilling with mobs
 *
 * Revision 1.11  1999/03/21 21:49:37  dce
 * Disallows pkilling.
 *
 * Revision 1.10  1999/03/10 19:12:17  dce
 * Fixes death blow for monks.
 *
 * Revision 1.9  1999/03/10 00:03:37  dce
 * Monk semantics for dodge/parry/riposte/attack
 *
 * Revision 1.8  1999/02/09 12:40:17  mud
 *  "$n nearly rips $N in two with $s deadly #w!!&0",      / * 8: > 23   * /
 *  Added the RIPS as opposed to RIP
 *
 * Revision 1.7  1999/02/08 23:01:47  jimmy
 * Fixed mortally wounded bug.  Mortally wounded
 * victims now die when they read -11.  Also,
 * no more "attempt to damage corpse"
 * fingon
 *
 * Revision 1.6  1999/02/07 20:00:55  jimmy
 * fixed debug messages
 *
 * Revision 1.5  1999/02/07 19:14:40  jimmy
 * added debug statement
 *
 * Revision 1.4  1999/02/04 00:02:59  jimmy
 * max/min exp loss/gain set to 2 notches.
 *
 * Revision 1.3  1999/02/02 07:51:02  jimmy
 * fixed spell mem at death bug
 *
 * Revision 1.2  1999/01/31 02:40:03  mud
 * Altered comment header
 * indented file
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.282
log
@fixed - warning: format not a string literal and no format arguments
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.281 2011/08/06 15:22:51 rsd Exp $
d2017 1
a2017 2
   if (type == TYPE_UNDEFINED || type == SKILL_RIPOSTE ||
         type == SKILL_DUAL_WIELD || !type) {
d2019 1
a2019 5
         type = GET_OBJ_VAL(weapon, VAL_WEAPON_DAM_TYPE) + TYPE_HIT;
      else if (GET_SKILL(ch, SKILL_BAREHAND))
         type = SKILL_BAREHAND;
      else if (IS_NPC(ch) && ch->mob_specials.attack_type != 0)
         type = ch->mob_specials.attack_type + TYPE_HIT;
d2021 15
a2035 1
         type = TYPE_HIT;
a2036 1
   dtype = skill_to_dtype(type);
d2501 3
@


1.281
log
@Fixed log(buf) to log(%s buf)
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.280 2010/07/02 14:09:16 mud Exp $
d1193 1
a1193 1
         log(b);
d2493 3
@


1.280
log
@Adding cone of cold weapon.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.279 2010/06/20 19:53:47 mud Exp mud $
d1513 1
a1513 1
      log(buf);
d2493 3
@


1.279
log
@Log to file errors we might want to see.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.278 2010/06/05 18:58:19 mud Exp mud $
d1926 1
d1935 2
a1936 1
         name != holyw_weapon && name != fire_weapon)
d2493 3
@


1.278
log
@Don't decrease damage for protection spells for being on fire
or being poisoned.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.277 2010/06/05 14:56:27 mud Exp $
d1734 1
a1734 1
         mudlog(buf, BRF, LVL_GOD, FALSE);
d2491 4
@


1.277
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.276 2010/04/25 22:57:16 mud Exp mud $
d1604 25
a1628 21
   /* Reduce damage for PVP for everything except spells */
   if (!IS_NPC(ch) && !IS_NPC(victim) && attacktype > MAX_SPELLS)
      dam /= 3;

   /* Charmies do half damage. */
   if (EFF_FLAGGED(ch, EFF_CHARM) && ch->master && IS_PC(ch->master))
      dam >>= 1;

   /* Sanctuary and stone skin take half damage. */
   if (EFF_FLAGGED(victim, EFF_SANCTUARY) ||
         EFF_FLAGGED(victim, EFF_STONE_SKIN))
      dam >>= 1;

   /* Protection from evil/good takes 90% damage */
   if (EFF_FLAGGED(victim, EFF_PROTECT_EVIL) &&
         GET_ALIGNMENT(ch) <= -500 && GET_ALIGNMENT(victim) >= 500)
      dam *= 0.9;

   else if (EFF_FLAGGED(victim, EFF_PROTECT_GOOD) &&
         GET_ALIGNMENT(ch) >= 500 && GET_ALIGNMENT(victim) <= -500)
      dam *= 0.9;
d2491 3
@


1.276
log
@Changing Celestial Betrayer to shoot fireballs.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.275 2010/04/25 22:13:38 mud Exp mud $
d32 1
d2487 3
@


1.275
log
@Adding frost weapon spec proc.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.274 2009/07/18 01:17:23 myc Exp mud $
d1921 1
a1921 1
   SPECIAL(frost_weapon);
d1929 1
a1929 1
         name != holyw_weapon && name != frost_weapon)
d2486 3
@


1.274
log
@Adding immobilization for bone draw.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.273 2009/06/20 23:14:13 myc Exp myc $
d1921 1
d1929 1
a1929 1
         name != holyw_weapon)
d2486 3
@


1.273
log
@Fix autoloot so it only picks up items actually dropped by a
mob who doesn't leave a corpse behind.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.272 2009/06/10 18:40:33 myc Exp myc $
d70 1
a70 1
void decrease_modifier(struct char_data *i);
d2148 1
a2148 1
            decrease_modifier(victim);
d2162 3
d2485 4
@


1.272
log
@Area spells will work in the arena now.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.271 2009/06/09 21:48:21 myc Exp myc $
d644 13
a656 2
      if (PRF_FLAGGED(killer, PRF_AUTOLOOT))
         delayed_command(killer, "get all", 0, FALSE);
d2482 3
@


1.271
log
@Add an action verb to the 'killed by' death message.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.270 2009/06/09 19:44:45 myc Exp myc $
d409 2
a410 1
   if (IS_PC(ch) && PLAYERALLY(victim)) {
d2471 3
@


1.270
log
@Clans receive a notification when a member dies.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.269 2009/06/09 19:33:50 myc Exp myc $
d983 1
a983 1
       sprintf(buf2, "%s killed by %s", GET_NAME(ch), GET_NAME(killer));
d986 1
a986 1
     clan_notification(GET_CLAN(ch), ch, AFMAG "%s" ANRM, buf2);
d2470 3
@


1.269
log
@Rewrote gain_exp and retired gain_exp_regardless.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.268 2009/03/20 16:00:38 jps Exp myc $
d49 1
d983 1
a983 3
       sprintf(buf2, "%s killed by %s in %s [%d]", GET_NAME(ch),
               GET_NAME(killer), world[ch->in_room].name,
               world[ch->in_room].vnum);
d985 4
a988 3
       sprintf(buf2, "%s died in %s [%d]", GET_NAME(ch),
               world[ch->in_room].name, world[ch->in_room].vnum);
     mudlog(buf2, BRF, LVL_IMMORT, TRUE);
d2470 3
@


1.268
log
@Make autoloot/autotreas work when no corpse is left.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.267 2009/03/19 23:16:23 myc Exp jps $
d999 1
a999 2
      gain_exp(ch, NULL, -exp_death_loss(REAL_CHAR(ch),
               GET_LEVEL(REAL_CHAR(ch))));
d1064 15
a1078 1
   gain_exp(ch, vict, exp);
d1668 4
a1671 3
      gain_exp(ch, victim, (GET_LEVEL(victim) * dam) /
                   MAX((GET_LEVEL(ch) - GET_LEVEL(victim) > 10 ? 30 : 15),
                         50 - GET_LEVEL(ch)));
d2470 3
@


1.267
log
@Moved get functions to their own file.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.266 2009/03/19 23:09:50 jps Exp myc $
d577 1
a577 1
void fluid_death(struct char_data *ch) {
d581 1
d640 15
d658 1
a658 1
struct obj_data *make_corpse(struct char_data *ch)
d670 1
a670 1
      fluid_death(ch);
d918 1
a918 1
      corpse = make_corpse(real_char);
d930 1
a930 1
      corpse = make_corpse(ch);
d2456 3
@


1.266
log
@Make objects decompose properly when dropped by non-corpse-leaving mobs
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.265 2009/03/19 22:47:41 jps Exp jps $
d48 2
a867 5
   void get_from_container(struct char_data *ch, struct obj_data *obj, char *arg, int mode);
   void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
                                                struct obj_data * cont, int mode);


d920 1
a920 1
         get_from_container(killer, corpse, "all", FIND_OBJ_ROOM);
d922 1
d925 2
a926 4
            if (GET_OBJ_TYPE(obj) == ITEM_MONEY ||
                     GET_OBJ_TYPE(obj) == ITEM_TREASURE) {
               perform_get_from_container(killer, obj, corpse, 0);
            }
d928 1
d2440 3
@


1.265
log
@Don't attempt to create money with 0 coins!
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.264 2009/03/16 19:17:52 jps Exp jps $
d590 1
d597 3
a599 1
         obj_to_room(unequip_char(ch, i), ch->in_room);
d608 1
d2443 3
@


1.264
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.263 2009/03/15 08:12:53 jps Exp jps $
d602 8
a609 6
   money = create_money(GET_COINS(ch));
   obj_to_room(money, ch->in_room);
   GET_GOLD(ch) = 0;
   GET_PLATINUM(ch) = 0;
   GET_COPPER(ch) = 0;
   GET_SILVER(ch) = 0;
d2439 3
@


1.263
log
@Use a delayed command to make creatures stand when attacked
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.262 2009/03/13 04:40:10 jps Exp jps $
d833 1
a833 1
      destination = real_room(GET_HOME(ch));
d902 1
a902 1
         GET_LOADROOM(real_char) = GET_HOME (real_char);
d2437 3
@


1.262
log
@Fix up some money macros.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.261 2009/03/11 21:13:13 jps Exp jps $
a254 2
   static int waiter_standing_corecount = 0;

d256 3
a258 11
      /* FIXME: Here we ignore the position, and then just set it to standing.
       *
       * This means that a player who's just sitting around and gets attacked will
       * stand to fight, which is good.
       *
       * But it also means that someone who was bashed or knocked over and is
       * supposed to be recovering might spontaneously stand, as well.
       *
       * Possible solution: if ch has a wait state, do not change position. */
      if (GET_STANCE(ch) > STANCE_STUNNED && !FIGHTING(ch)) {
         if (EFF_FLAGGED (ch, EFF_SLEEP))
a259 19

         /* Here we have a character who will be made to stand, but also
          * has a wait state. Advertising the situation (and dropping a
          * core) will make it easier to judge whether the solution is
          * simply to not change the position in these circumstances. */
         if (CHECK_WAIT(ch) && GET_POS(ch) != POS_FLYING && GET_POS(ch) != POS_STANDING) {
            mprintf(L_ERROR, LVL_GOD,
               "set_fighting: %s has a wait state and is being set to standing...",
               GET_NAME(ch));
               if (waiter_standing_corecount < 3) {
                  drop_core(NULL, "set_fighting");
                  waiter_standing_corecount++;
                  mprintf(L_ERROR, LVL_GOD, "set_fighting: core dropped (%d of 3)",
                        waiter_standing_corecount);
            }
         }

         if (GET_POS(ch) != POS_FLYING)
             GET_POS(ch) = POS_STANDING;
d263 2
a264 3
      if (reciprocate && GET_STANCE(vict) == STANCE_ALERT &&
            attack_ok(vict, ch, FALSE) && GET_POS(vict) >= POS_STANDING &&
            !FIGHTING(vict)) {
d1714 1
a1714 1
   /* Fleeing */
d1716 3
a1718 1
      if (IS_NPC(victim) && GET_HIT(victim) < (GET_MAX_HIT(victim) >> 2)) {
d2437 3
@


1.261
log
@Don't drop a corpse unless you're of solid composition.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.260 2009/03/09 20:36:00 myc Exp jps $
d631 2
a632 2
   numcoins = GET_GOLD(ch) + GET_PLAT(ch) + GET_COPPER(ch) + GET_SILVER(ch);
   money = create_money(GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
d635 1
a635 1
   GET_PLAT(ch) = 0;
d733 1
a733 1
               money = create_money(GET_PLAT(ch), GET_GOLD(ch), GET_SILVER(ch), GET_COPPER(ch));
d737 1
a737 1
         GET_PLAT(ch) = 0;
d2465 3
@


1.260
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.259 2009/03/09 04:33:20 jps Exp myc $
d605 55
d661 2
d671 1
d673 5
a677 2
       act("$n seems to have vanished entirely.", TRUE, ch, 0, 0, TO_ROOM);
       return NULL;
d733 1
a733 1
               money = create_money(GET_COINS(ch));
d737 1
a737 1
         GET_PLATINUM(ch) = 0;
d2465 3
@


1.259
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.258 2009/03/08 23:34:14 jps Exp jps $
a612 1
   struct obj_data *create_money (int pamount, int gamount, int samount, int camount);
d672 1
a672 1
               money = create_money(GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
d676 1
a676 1
         GET_PLAT(ch) = 0;
d2404 4
@


1.258
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.257 2009/03/08 21:43:27 jps Exp jps $
d46 2
d2405 3
@


1.257
log
@Split lifeforce, composition, charsize, and damage types from chars.c
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.256 2009/03/07 22:30:52 jps Exp jps $
d25 1
a25 1
#include "spells.h"
d2403 3
@


1.256
log
@Have skill_message use TO_VICTROOM for the victim damage messages.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.255 2009/03/07 08:18:33 jps Exp jps $
a18 1

d43 3
d2403 3
@


1.255
log
@Add debugging messages and core dumping to set_fighting, to help
fix that bash-and-they-stand bug.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.254 2009/02/21 03:30:16 myc Exp jps $
d1416 1
a1416 1
         act(b2, FALSE, ch, weap, vict, TO_NOTVICT);
d2401 4
@


1.254
log
@Removed L_FILE flag--mprintf now logs to file by default;
assert L_NOFILE to prevent that.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.253 2009/02/16 14:21:04 myc Exp myc $
d251 2
d266 17
d2401 4
@


1.253
log
@Do decomposition logic before registering corpse (which saves
the corpse to file).  We want the decomp timer being saved to disk.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.252 2009/01/19 09:25:23 myc Exp myc $
d122 1
a122 1
      mprintf(L_ERR, LVL_GOD, "set_battling: %s is already battling %s",
d126 1
a126 1
         mprintf(L_ERR, LVL_GOD, "set_battling: core dropped (I)");
d138 1
a138 1
         mprintf(L_ERR, LVL_GOD, "set_battling: %s is already in attacker list for %s",
d142 1
a142 1
            mprintf(L_ERR, LVL_GOD, "set_battling: core dropped (II)");
d155 1
a155 1
         mprintf(L_ERR, LVL_GOD, "set_battling: %s is already in the combat list",
d159 1
a159 1
            mprintf(L_ERR, LVL_GOD, "set_battling: core dropped (III)");
d183 1
a183 1
      mprintf(L_ERR, LVL_GOD, "SYSERR: stop_battling: %s has no target",
d187 1
a187 1
         mprintf(L_ERR, LVL_GOD, "stop_battling: core dropped");
d1851 1
a1851 1
      mprintf(L_ERR, LVL_GOD, "hit(): %s [%d] is not in the same room as %s [%d]",
d1868 1
a1868 1
      mprintf(L_ERR, LVL_GOD, "hit(): %s is blind but tried to attack new target %s [room %d]",
d2382 4
@


1.252
log
@Removed MOB_PET flag.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.251 2009/01/16 23:36:34 myc Exp myc $
a661 6
   obj_to_room(corpse, ch->in_room);
   if (!IS_NPC(ch)) {
      register_corpse(corpse);
      delete_player_obj_file(ch);
   }

d682 6
d2382 3
@


1.251
log
@Increase string buffer sizes in attempt to prevent overflow.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.250 2008/10/31 19:48:33 myc Exp myc $
d413 1
a413 1
   if (!IS_NPC(ch) && (EFF_FLAGGED(victim, EFF_CHARM) || MOB_FLAGGED(victim, MOB_PET))) {
d1511 1
a1511 1
   if (EFF_FLAGGED(ch, EFF_CHARM) || MOB_FLAGGED(ch, MOB_PET))
d2382 3
@


1.250
log
@Fix bug in perform_vio where secondary_hits wasn't necessarily being
reinitialized each iteration.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.249 2008/09/26 18:37:49 jps Exp myc $
d479 1
a479 1
   char chk[128];
d495 1
a495 1
   fgets (chk, 128, fl);
d497 1
a497 1
      fgets (chk, 128, fl);
d501 1
a501 1
         fgets (chk, 128, fl);
d532 1
a532 1
         fgets (chk, 128, fl);
d534 1
a534 1
             fgets (chk, 128, fl);
a574 2
         char buf[256];

d576 2
a577 3
         sprintf (buf, "PC Killer bit set on %s for initiating attack on %s at %s.",
                      GET_NAME (ch), GET_NAME (vict), world[vict->in_room].name);
         mudlog (buf, BRF, LVL_IMMORT, TRUE);
d1049 1
a1049 1
   static char buf[256];
d1080 1
a1080 1
void append_damage_amount(char *b, const char *msg, int dam, int type) {
d1105 1
a1105 1
      sprintf(b, "%s", msg);
d1114 2
a1115 2
   char *buf;
   char b2[256];
d1264 1
a1264 1
   memset(b2, 0x0, 256);
d1308 1
a1308 1
       buf = bare_attack[msgnum].to_room;
d1310 1
a1310 1
       buf = replace_string (dam_weapons[msgnum].to_room,
d1312 1
a1312 1
   append_damage_amount(b2, buf, dam, TO_NOTVICT);
d1317 1
a1317 1
       buf = bare_attack[msgnum].to_char;
d1319 1
a1319 1
       buf = replace_string (dam_weapons[msgnum].to_char,
d1321 1
a1321 1
   append_damage_amount(b2, buf, dam, TO_CHAR);
d1326 1
a1326 1
       buf = bare_attack[msgnum].to_victim;
d1328 1
a1328 1
       buf = replace_string (dam_weapons[msgnum].to_victim,
d1330 1
a1330 1
   append_damage_amount(b2, buf, dam, TO_VICT);
d1345 1
a1345 1
   char b2[256];
d1352 1
a1352 1
   memset(b2, 0x0, 256);
d2382 4
@


1.249
log
@Don't use FIGHTING macro when changing target.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.248 2008/09/26 09:23:25 jps Exp jps $
d2126 1
a2126 1
   int hits, secondary_hits = 0;
d2180 1
d2385 3
@


1.248
log
@Bug in hit() fixed.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.247 2008/09/26 04:59:02 jps Exp jps $
d104 4
a107 1
 * the battle may take place must be performed before calling these functions. */
d285 2
a286 2
   FIGHTING(tch) = FIGHTING(ch);
   FIGHTING(ch) = NULL;
d292 1
a292 1
      FIGHTING(c) = tch;
d2384 3
@


1.247
log
@A) In stop_battling, the prior target's list of attackers that it was in was
improperly truncated at the target.
B) In hit(), you'll stop targetting the old person if you're now attacking
someone new.
C) In perform_violence, there are two situations where you could switch to
a new target. This needs to be done so that you're no longer in your old
target's attacker list.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.246 2008/09/25 15:19:37 jps Exp jps $
d1874 2
a1875 1
   if (ch->target != victim) stop_fighting(ch);
d2381 9
@


1.246
log
@Add some debugging coredumping for attacker linking errors.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.245 2008/09/21 21:49:59 jps Exp jps $
a177 1
      ch->target->next_attacker = NULL;
d234 11
d1873 3
d2201 1
a2201 1
            FIGHTING(ch) = victim;
d2212 1
a2212 1
               FIGHTING(ch) = newvict;
d2380 3
@


1.245
log
@Added transfer_battle(), which allows one character to seamlessly
take the place of another in a battle.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.244 2008/09/21 21:23:32 jps Exp jps $
d110 3
d121 5
d137 5
d154 5
d172 2
d181 1
a181 1
      mprintf(L_ERR, LVL_GOD, "stop_battling: %s has no target",
d183 5
d2367 4
@


1.244
log
@Fix grammar in some monk hit messages.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.243 2008/09/21 21:16:27 jps Exp jps $
d239 36
d2342 3
@


1.243
log
@Don't allow "flee" to be in a character's event list multiple times.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.242 2008/09/21 20:40:40 jps Exp jps $
d1108 1
a1108 1
         "$n repeatedly punches you in the kidneys, you feel like hurling!&0"
d1115 1
a1115 1
         "$n nails you in the throat, you barely survive from choking to death!&0"
d2306 3
@


1.242
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.241 2008/09/20 07:44:21 jps Exp jps $
d1595 1
a1595 1
            delayed_command(victim, "flee", 0);
d1599 1
a1599 1
         delayed_command(victim, "flee", 0);
d2306 4
@


1.241
log
@Fix set_fighting a bit.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.240 2008/09/20 07:26:52 jps Exp jps $
d95 144
a240 2
/* The Fight related routines */

a511 52
/* start one char fighting another (yes, it is horrible, I know... )   */
void set_fighting(struct char_data *ch, struct char_data *vict, bool reciprocate)
{
   if (ch != vict && GET_STANCE(ch) > STANCE_STUNNED && !FIGHTING(ch)) {
      ch->next_fighting = combat_list;
      combat_list = ch;

      if (EFF_FLAGGED (ch, EFF_SLEEP))
         effect_from_char(ch, SPELL_SLEEP);

      FIGHTING(ch) = vict;
      if (GET_POS(ch) != POS_FLYING)
          GET_POS(ch) = POS_STANDING;
      GET_STANCE(ch) = STANCE_FIGHTING;

      if (!pk_allowed)
         check_killer(ch, vict);
   }

   if (reciprocate && GET_STANCE(vict) == STANCE_ALERT &&
         attack_ok(vict, ch, FALSE) && GET_POS(vict) >= POS_STANDING &&
         !FIGHTING(vict)) {
      vict->next_fighting = combat_list;
      combat_list = vict;
      FIGHTING(vict) = ch;
      GET_STANCE(vict) = STANCE_FIGHTING;
      if (!pk_allowed)
         check_killer(vict, ch);
   }
}


/* remove a char from the list of fighting chars */
void stop_fighting(struct char_data *ch)
{
   struct char_data *temp;

   if (ch == next_combat_list)
      next_combat_list = ch->next_fighting;

   REMOVE_FROM_LIST(ch, combat_list, next_fighting);
   ch->next_fighting = NULL;
   FIGHTING(ch) = NULL;

   /* This function is called from alter_pos(), so in the interest of avoiding
    * infinite loops -- and because this is a pretty safe stance change --
    * we'll directly modify the stance. */
   if (GET_STANCE(ch) == STANCE_FIGHTING)
      GET_STANCE(ch) = STANCE_ALERT;
}


a830 1
   struct char_data *tch;
d851 1
a851 4
   for (tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
      if (FIGHTING(tch) == ch)
         stop_fighting(tch);

d1772 3
a1774 3
   if (event_target_valid(victim) == 0) {
      if (ch)
         stop_fighting (ch);
d1778 4
a1781 7
   if (event_target_valid(ch) == 0) {
      stop_fighting (victim);
      return;
   }

   if (ch == victim) {
      stop_fighting(ch);
a1787 7
   /* Do some sanity checking, in case someone flees, etc. */
   if (IN_ROOM(ch) != IN_ROOM(victim)) {
      if (FIGHTING(ch) && FIGHTING(ch) == victim)
         stop_fighting(ch);
      return;
   }

d1790 1
a1790 3
      if (FIGHTING(ch)) {
         if (FIGHTING(victim) == ch)
            stop_fighting(victim);
a1791 1
      }
d1797 2
d2059 1
a2059 1
         stop_fighting (ch);
a2253 15
void StopMercifulAttackers(struct char_data *ch)
{
   struct char_data *t_ch;
   struct char_data *hold;

   if (!ch)
      return;

   for (t_ch = combat_list; t_ch; t_ch = hold) {
      hold = t_ch->next_fighting;
      if (t_ch->char_specials.fighting == ch && !IS_VICIOUS(t_ch))
         stop_fighting (t_ch);
   }
}

d2306 3
@


1.240
log
@Causing set_fighting to take a boolean parameter reciprocate, which indicates that
the attackee should also be set fighting, if possible.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.239 2008/09/20 06:05:06 jps Exp jps $
d373 11
a383 2
   if (ch == vict || GET_STANCE(ch) <= STANCE_STUNNED || FIGHTING(ch))
      return;
d385 3
a387 13
   ch->next_fighting = combat_list;
   combat_list = ch;

   if (EFF_FLAGGED (ch, EFF_SLEEP))
      effect_from_char(ch, SPELL_SLEEP);

   FIGHTING(ch) = vict;
   if (GET_POS(ch) != POS_FLYING)
       GET_POS(ch) = POS_STANDING;
   GET_STANCE(ch) = STANCE_FIGHTING;

   if (!pk_allowed)
      check_killer(ch, vict);
d2246 4
@


1.239
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.238 2008/09/14 04:34:30 jps Exp jps $
a70 1
void remember(struct char_data *ch, struct char_data *victim);
d371 1
a371 1
void set_fighting(struct char_data *ch, struct char_data *vict)
d388 12
a399 1
      check_killer (ch, vict);
d1294 2
a1295 1
            set_fighting(ch, victim);
d1332 2
a1333 1
            set_fighting(victim, ch);
d1610 1
a1610 2
   set_fighting(ch, victim);
   set_fighting(victim, ch);
d1654 1
a1654 2
   set_fighting(ch, victim);
   set_fighting(victim, ch);
d1824 1
a1824 1
       set_fighting(victim, ch);
d2247 3
@


1.238
log
@Set folks fighting even if the initial attack was completely ineffective.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.237 2008/09/14 03:53:01 jps Exp jps $
d643 4
a646 4
   if (ch->desc && ch->desc->original) {
         real_char = ch->desc->original;
         char_from_room (real_char);
         char_to_room (real_char, ch->in_room);
a647 2
   else
      real_char = ch;
d2237 3
@


1.237
log
@Implement wimpy-fleeing as a delayed command.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.236 2008/09/14 03:02:35 jps Exp jps $
d598 1
a598 1
   /* Move them out of the room */
d1327 1
a1327 1
       * If the mob has memory, make them remember this player.
d1480 1
a1480 1
       * exp for killing them. */
d1816 1
d1986 3
a1988 7
         continue;
      }
      if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
         act ("You couldn't budge a feather in your present condition.",
               FALSE, ch, 0, 0, TO_CHAR);
         act ("$n is too preoccupied with $s nervous system problem to fight.",
               FALSE, ch, 0, 0, TO_ROOM);
d2239 3
@


1.236
log
@More sanity checks in quick_aggro_event will prevent attacks happening
when the attacker is unconscious.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.235 2008/09/14 02:08:01 jps Exp jps $
a69 1
ACMD(do_flee);
d1500 1
a1500 1
            do_flee (victim, "", 0, 0);
d1504 1
a1504 1
         do_flee(victim, "", 0, 0);
d2242 4
@


1.235
log
@Use standardized area attack targetting
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.234 2008/09/06 19:09:42 jps Exp jps $
d107 3
a109 1
   if (ch && !FIGHTING(ch) && vict && IN_ROOM(ch) == IN_ROOM(vict))
d2243 3
@


1.234
log
@Change decomp time for player corpses so it's longer with equipment inside,
but short with nothing or just money inside.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.233 2008/09/02 07:16:00 mud Exp jps $
d214 36
d2241 4
@


1.233
log
@Changing object TIMER uses into DECOMP where appropriate
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.232 2008/09/02 06:52:30 jps Exp mud $
d382 1
a382 1
   extern int max_npc_corpse_time, max_pc_corpse_time;
a405 1
   SET_FLAG(GET_OBJ_FLAGS(corpse), ITEM_DECOMP);
a408 4
   /* someone made value 1 represent pc/npc corpse, but value 1 is already
    * open/closed. moving it to value 3, and modifying other code
    * as appropriate */
   /* unraisable corpse if-clause added 11/5/99 by 321 */
d417 1
a417 1
   GET_OBJ_WEIGHT(corpse) = GET_WEIGHT (ch) + IS_CARRYING_W (ch) + 100;
d419 1
a419 1
      GET_OBJ_MOB_FROM(corpse) = GET_MOB_RNUM (ch);
a422 5
   if (IS_NPC(ch))
      GET_OBJ_DECOMP(corpse) = max_npc_corpse_time;
   else
      GET_OBJ_DECOMP(corpse) = max_pc_corpse_time;

d437 1
a437 1
   /* transfer gold */
d461 20
d2205 3
@


1.232
log
@Using limits.h.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.231 2008/09/01 23:47:49 jps Exp jps $
d406 1
a406 1
   SET_FLAG(GET_OBJ_FLAGS(corpse), ITEM_TRANSIENT);
d429 1
a429 1
      GET_OBJ_TIMER(corpse) = max_npc_corpse_time;
d431 1
a431 1
      GET_OBJ_TIMER(corpse) = max_pc_corpse_time;
d2195 3
@


1.231
log
@Using movement.h/c for movement functions.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.230 2008/09/01 18:29:29 jps Exp jps $
d43 1
d2195 3
@


1.230
log
@Clearing cooldowns upon death.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.229 2008/08/31 20:53:44 jps Exp jps $
d42 1
a61 1
void stop_follower(struct char_data *ch, int violent);
a71 1
void dismount_char(struct char_data *ch);
d2194 3
@


1.229
log
@Moved several ai-related functions to ai_utils.c
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.228 2008/08/30 22:44:44 myc Exp jps $
d621 2
d2195 3
@


1.228
log
@Fix change_alignment so it doesn't force alignment to 1000.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.227 2008/08/30 20:25:38 jps Exp myc $
a2140 219

bool is_aggr_to(struct char_data *ch, struct char_data *tch) {
   if (!ch || !tch || ch == tch || !AWAKE(ch))
      return FALSE;

   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) ||
         EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS) ||
         EFF_FLAGGED(ch, EFF_MESMERIZED))
      return FALSE;

   if (!CAN_SEE(ch, tch) || PRF_FLAGGED(tch, PRF_NOHASSLE) ||
         EFF_FLAGGED(tch, EFF_FAMILIARITY))
      return FALSE;

   if (is_grouped(ch, tch))
      return FALSE;

   if (!attack_ok(ch, tch, FALSE))
      return FALSE;

   if (IS_NPC(ch)) {
      if (IS_NPC(tch) && !MOB_FLAGGED(tch, MOB_PLAYER_PHANTASM))
         return FALSE;

      if (MOB_FLAGGED(ch, MOB_WIMPY) && AWAKE(tch))
         return FALSE;

      /* Now if the mob is marked any kind of aggro that matches the
          target, attack! */
      if (MOB_FLAGGED(ch, MOB_AGGRESSIVE))
         return TRUE;
      if (MOB_FLAGGED(ch, MOB_AGGR_GOOD_RACE) &&
            GET_RACE_ALIGN(tch) == RACE_ALIGN_GOOD)
         return TRUE;
      if (MOB_FLAGGED(ch, MOB_AGGR_EVIL_RACE) &&
            GET_RACE_ALIGN(tch) == RACE_ALIGN_EVIL)
         return TRUE;
      if (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(tch))
         return TRUE;
      if (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(tch))
         return TRUE;
      if (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(tch))
         return TRUE;

      /* If target is in memory, then it acts as if it's aggro, even if it's not. */
      if (MOB_FLAGGED(ch, MOB_MEMORY) && in_memory(ch, tch))
         return TRUE;
   }
   /* Otherwise is a player */
   else {
      /* Berserkers are aggressive. */
      if (IS_NPC(tch) && EFF_FLAGGED(ch, EFF_BERSERK))
         return TRUE;

      if (GET_WIMP_LEV(ch) >= GET_HIT(ch))
         return FALSE;
      if (GET_AGGR_LEV(ch) <= 0 || GET_AGGR_LEV(ch) > GET_HIT(ch))
         return FALSE;

      /* If not vicious, be merciful to sleeping/paralyzed mobs */
      if (!PRF_FLAGGED(ch, PRF_VICIOUS) && (!AWAKE(tch) ||
            EFF_FLAGGED(tch, EFF_MINOR_PARALYSIS) ||
            EFF_FLAGGED(tch, EFF_MAJOR_PARALYSIS)))
         return FALSE;

      /*
       * The target must be an NPC or else you'll end up with an infinite
       * recursion situation.   Can you say segfault?
       */
      if (IS_NPC(tch) && is_aggr_to(tch, ch))
         return TRUE;
   }

   return FALSE;
}


int appraise_opponent(struct char_data *ch, struct char_data *vict) {
   int val;

   if (!IS_NPC(ch))
      return -1;

   val = GET_HIT(vict);

   if (IS_CLERIC(vict) || IS_MAGIC_USER(vict))
      val *= 2 / 3;
   else if (IS_WARRIOR(vict))
      val *= 2;
   if (!FIGHTING(vict))
      val /= (IS_ROGUE(ch) ? 4 : 2);
   if (EFF_FLAGGED(vict, EFF_AWARE) && IS_ROGUE(ch))
      val *= 1.5;
   if (GET_LEVEL(vict) < 60)
      val /= number(40 + GET_LEVEL(vict), 160 - GET_LEVEL(vict));
   return val;
}

void glorion_distraction(struct char_data *ch, struct char_data *glorion)
{
   /* Will the glorion be attacked? */
   if (number(1, 100) < 3 && !PRF_FLAGGED(glorion, PRF_NOHASSLE)) {
      /* It's attacked! */
      act("$n forgets $s appreciation of $N's glorious appearance, and attacks!",
            TRUE, ch, 0, glorion, TO_NOTVICT);
      act("The look of awe in $N's eyes falters, and $e attacks!",
            TRUE, glorion, 0, ch, TO_CHAR);
      act("You see right through $N's magical disguise!",
            FALSE, ch, 0, glorion, TO_CHAR);
      event_create(EVENT_QUICK_AGGRO, quick_aggro_event,
            mkgenericevent(ch, glorion, 0), TRUE, &(ch->events), 0);
   } else {
      /* Glory wins: no attack. */
      if (number(1, 8) == 1) {
         act("$n looks upon $N with awe in $s eyes.",
               TRUE, ch, 0, glorion, TO_NOTVICT);
         act("$n gazes at you in wonder.", TRUE, ch, 0, glorion, TO_VICT);
         act("You are distracted by $N's unearthly beauty.",
               TRUE, ch, 0, glorion, TO_CHAR);
      }
   }
}

#define MAX_TARGETS 10
struct char_data *find_aggr_target(struct char_data *ch) {
   struct char_data *tch;
   struct aggr_target {
      struct char_data *target;
      int difficulty;
   } targets[MAX_TARGETS + 1];
   int i, j, k, num_targets, chosen_targets;

   struct char_data *glorion;
   int glorion_count;

   if (!ch || CH_NROOM(ch) == NOWHERE)
      return NULL;

   if (ROOM_FLAGGED(CH_NROOM(ch), ROOM_PEACEFUL)) return NULL;

   if (!IS_NPC(ch) && !EFF_FLAGGED(ch, EFF_BERSERK)) {
      if (GET_WIMP_LEV(ch) >= GET_HIT(ch))
         return NULL;
      if (GET_AGGR_LEV(ch) <= 0 || GET_AGGR_LEV(ch) > GET_HIT(ch))
         return NULL;
   }

   if (PLR_FLAGGED(ch, PLR_BOUND) || !AWAKE(ch) ||
         EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) ||
         EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
      return NULL;

   /* Your intelligence determines how many targets you will evaluate. */
   num_targets = MAX(1, GET_INT(ch) * MAX_TARGETS / 100);

   /* Choose #num_targets characters at random */
   glorion_count = 0;
   for (i = 0, tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
      /* If there are any folks in the room with GLORY, they will
       * interfere with aggression.  One will be chosen at random,
       * because there's a chance the mob will attack it.  But no
       * one else will be. */
      if (CAN_SEE(ch, tch)) {
         if (EFF_FLAGGED(tch, EFF_GLORY)) {
            glorion_count++;
            if (number(1, glorion_count) == 1)
               glorion = tch;
         } else if (is_aggr_to(ch, tch)) {
            if (i >= num_targets)
               j = number(0, i);
            else
               j = i;
            if (j < num_targets) {
               targets[j].target = tch;
               targets[j].difficulty = appraise_opponent(ch, tch);
            }
            i++;
         }
      }

   if (glorion_count) {
      glorion_distraction(ch, glorion);
      return NULL;
   }

   if (i == 0)
      /* Didn't find anyone I was aggro to. */
      return NULL;

   /* This is the number of folks I decided I was aggro to, and stored in
    * targets[]. */
   if (i >= num_targets)
      chosen_targets = num_targets;
   else
      chosen_targets = i;

   /* Now choose one of them to attack. */

   /* Players and illusions just choose at random. */
   if (!IS_NPC(ch) || MOB_FLAGGED(ch, MOB_PLAYER_PHANTASM))
      return targets[number(0, chosen_targets - 1)].target;

   /* Normal mobiles choose the weakest enemy. */

   /* The extra struct-aggr_target is used to initialize the search for
    * the easiest opponent. */
   k = chosen_targets;
   targets[k].difficulty = 100000000; /* Arbitrarily large number */
   for (j = 0; j < chosen_targets; ++j)
      if (targets[j].difficulty < targets[k].difficulty)
         k = j;

   /* No potential targets in the room? */
   if (k >= chosen_targets)
      return NULL;

   return targets[k].target;
}

d2193 3
@


1.227
log
@Moved count_hand_eq() into handler.c and mentioned it in handler.h.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.226 2008/08/30 18:20:53 myc Exp jps $
d515 1
a515 1
   GET_ALIGNMENT(ch) = LIMIT(-MIN_ALIGNMENT, GET_ALIGNMENT(ch), MAX_ALIGNMENT);
d2412 3
@


1.226
log
@Made weapon_special check for a NOTHING rnum before trying to
access the index.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.225 2008/08/30 01:31:51 myc Exp myc $
a63 1
void count_hand_eq(struct char_data *ch, int *hands_used, int *weapon_hands_used);
d2412 4
@


1.225
log
@Changed the way stats are calculated in effect_total; ability
stats are saved in a raw form now, and only capped when accessed.
Damroll and hitroll are recalculated everytime effect_total
is called, using cached base values.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.224 2008/08/24 19:29:11 jps Exp myc $
d1612 2
a1613 1

d2413 6
@


1.224
log
@Apply damage susceptibility reductions to the various physical attack skills.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.223 2008/08/23 13:17:07 jps Exp jps $
d516 1
a516 1
   GET_ALIGNMENT(ch) = LIMIT(-1000, GET_ALIGNMENT(ch), 1000);
d2412 3
@


1.223
log
@Don't let aggros get distracted by GLORY-ous folks they can't see.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.222 2008/08/21 08:05:56 jps Exp jps $
d1850 1
a1850 2
      if (!(GET_COMPOSITION(victim) == COMP_ETHER && blessed_blow(ch, weapon)))
         dam = dam * susceptibility(victim, dtype) / 100;
d2412 3
@


1.222
log
@Move dead-player object file deletion to the point at which their stuff
drops on the ground with the corpse.  Hopefully this will eliminate the
kit-duplication bug.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.221 2008/08/16 17:24:14 jps Exp jps $
d2304 15
a2318 12
      if (EFF_FLAGGED(tch, EFF_GLORY)) {
         glorion_count++;
         if (number(1, glorion_count) == 1)
            glorion = tch;
      } else if (is_aggr_to(ch, tch)) {
         if (i >= num_targets)
            j = number(0, i);
         else
            j = i;
         if (j < num_targets) {
            targets[j].target = tch;
            targets[j].difficulty = appraise_opponent(ch, tch);
a2319 1
         i++;
d2413 5
@


1.221
log
@Clear the trophy when a player dies, unless QUEST preference is on.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.220 2008/08/09 18:16:21 jps Exp jps $
d41 1
d467 1
a467 1
   if (!IS_NPC(ch))
d469 2
d2411 3
@


1.220
log
@Got rid of weapon-slinging.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.219 2008/07/29 17:52:47 jps Exp jps $
d628 2
a629 1
      if (!IS_NPC(real_char))            /* If killed dont save in room he died in */
d631 3
d2408 3
@


1.219
log
@Changed set_fighting so it merely does nothing if the subject was already
fighting.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.218 2008/06/07 19:06:46 myc Exp jps $
d48 8
a55 6
extern int pk_allowed;           /* see config.c */
extern int auto_save;            /* see config.c */
extern int summon_allowed;       /*       "      */
extern int sleep_allowed;        /*       "      */
extern int charm_allowed;        /*       "      */
extern int damage_amounts;       /*       "      */
a432 1
   /* 4/5/01 - Zantir - Give corpses a level */
a1765 2
      if (weapon && diceroll == 1)
         sling_weapon(ch, weapon_position);
d1803 1
a1803 1
       * alert      x 1.33
d1805 1
a1805 1
       * sleeping x 2.00
d1807 2
a1808 2
       * incap      x 2.66
       * mortally x 3.00
d1862 1
a1862 93
/* Now if you miss, you have a chance to sling your weapon. --Gurlaek 11/21/1999 */
bool sling_weapon(struct char_data *ch, int position) {
   int skill, proficiency, dir, temp, room, valid_dirs[NUM_OF_DIRS];
   struct obj_data *weapon = GET_EQ(ch, position);

   /* Find the appropriate skill to make the check */
   if ((skill = weapon_proficiency(weapon, position)) != -1)
      proficiency = GET_SKILL(ch, skill);
   /* Misc types of weapons get an average of all the scores */
   else if (position == WEAR_2HWIELD)
      proficiency = (GET_SKILL(ch, SKILL_2H_SLASHING) +
                            GET_SKILL(ch, SKILL_2H_BLUDGEONING) +
                            GET_SKILL(ch, SKILL_2H_PIERCING)) / 3;
   else
      proficiency = (GET_SKILL(ch, SKILL_SLASHING) +
                            GET_SKILL(ch, SKILL_BLUDGEONING) +
                            GET_SKILL(ch, SKILL_PIERCING)) / 3;

   /* Improve the skill if it's not a misc weapon */
   if (skill != -1)
      improve_skill(ch, skill);

   /* Make a dex check first */
   if (number(1, 81) < GET_DEX(ch))
      return FALSE;

   /* Check against weapon skill to see if it was slung */
   if (number(1, 81) < proficiency)
      return FALSE;

   /* remove the weapon */
   unequip_char(ch, position);

   /*
    * If it was wielded in the primary hand, and there was also something
    * wielded in the secondary hand, move it to the primary hand.
    */
   if (position == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD2))
      equip_char(ch, unequip_char(ch, WEAR_WIELD2), WEAR_WIELD);

   if (OBJ_FLAGGED(weapon, ITEM_NODROP)) {
      /* Weapon is cursed, so it remains in the inventory of the PC/NPC */
      act("&3&bYou lose your grip on your&0 $o&3&b, and it magically returns to your&0 &B&3inventory!&0", FALSE, ch, weapon, NULL, TO_CHAR);
      act("$n &3&bloses $s grip on $s&0 $o&3&b, and it magically returns to $s&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_ROOM);
      obj_to_char(weapon, ch);
   }
   else {
      room = ch->in_room;

      /* 1 in 5 chance to sling the weapon into the next room */
      if (!number(0, 4)) {
         /* Find a valid direction to sling it. */
         for (dir = temp = 0; dir < NUM_OF_DIRS; ++dir)
            if (CAN_GO(ch, dir))
               valid_dirs[temp++] = dir;
         if (temp > 0) {
            dir = valid_dirs[number(0, temp - 1)];
            room = CH_NDEST(ch, dir);
         }
      }

      /* Display messages for slinging into the same room. */
      if (room == ch->in_room) {
         act("&3&bYou lose your grip on your&0 $o &3&band send it&0 &B&3flying!&0",
               FALSE, ch, weapon, NULL, TO_CHAR);
         act("$n &3&bloses $s grip on $s&0 $o &3&band sends it&0 &B&3flying!&0",
               TRUE, ch, weapon, NULL, TO_ROOM);
      }
      /* Display messages for slinging into another room. */
      else {
         act("&3&bWith a mighty&0 &B&3HEAVE&0 &3&byou sling your&0 $o &3&bout of reach $Twards!&0",
               TRUE, ch, weapon, dirs[dir], TO_CHAR);
         act("&3&bWith a mighty&0 &B&3HEAVE&0 $n &3&bslings $s&0 $o &3&bout of reach $Twards!&0",
               TRUE, ch, weapon, dirs[dir], TO_ROOM);

         sprintf(buf, "A $o is slung violently in from %s%s.",
               rev_dir[dir] == UP ? "" : rev_dir[dir] == DOWN ? "" : "the ",
               rev_dir[dir] == UP ? "above" : rev_dir[dir] == DOWN ? "below" : dirs[rev_dir[dir]]);
         act(buf, TRUE, world[room].people, weapon, NULL, TO_CHAR);
         act(buf, TRUE, world[room].people, weapon, NULL, TO_ROOM);
      }

      /* Place the weapon in the room */
      obj_to_room(weapon, room);
   }

   WAIT_STATE(ch, 2 * PULSE_VIOLENCE);   /* lag the poor bastard */

   return TRUE;
}

/* this returns the skill associated with the weapon or -1 if no */
/* match is found --gurlaek 11/21/1999 */
d2404 4
@


1.218
log
@Moved all object-related constants and structures to objects.h
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.217 2008/06/05 02:07:43 myc Exp myc $
d335 1
a335 1
   if (ch == vict || GET_STANCE(ch) <= STANCE_STUNNED)
a337 2
   assert(!FIGHTING (ch));            /*Setmark game crashing due to assertion failing */

d1229 1
a1229 1
         if (!IS_SPELL(attacktype) && !FIGHTING(ch))
d1544 2
a1545 4
   if (!FIGHTING(ch))
      set_fighting(ch, victim);
   if (!FIGHTING(victim))
      set_fighting(victim, ch);
d1589 2
a1590 4
   if (!FIGHTING(ch))
      set_fighting(ch, victim);
   if (!FIGHTING(victim))
      set_fighting(victim, ch);
d2497 3
@


1.217
log
@Changed object flags to use flagvectors.  Corpses now save their
level in the normal object level field instead of in cost_per_day.
Rewrote corpse saving and loading to use ascii object files.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.216 2008/05/25 21:00:49 myc Exp myc $
d407 2
a408 1
   GET_OBJ_VAL(corpse, 0) = 0;            /* You can't store stuff in a corpse */
d415 1
a415 1
      GET_OBJ_VAL(corpse, 3) = CORPSE_PC;             /* player corpse               */
d417 1
a417 1
      GET_OBJ_VAL(corpse, 3) = CORPSE_NPC_NORAISE;/* npc corpse - unraisable */
d419 1
a419 1
      GET_OBJ_VAL(corpse, 3) = CORPSE_NPC;            /* npc corpse - raisable    */
d421 1
a421 1
   GET_OBJ_VAL(corpse, 1) = 0; /* not closable */
d1704 1
a1704 1
         type = GET_OBJ_VAL(weapon, 3) + TYPE_HIT;
d1802 2
a1803 1
         dam += dice(GET_OBJ_VAL(weapon, 1), GET_OBJ_VAL(weapon, 2));
d1965 1
a1965 1
   w_type = GET_OBJ_VAL(weapon, 3) + TYPE_HIT;
d2503 5
@


1.216
log
@Fix dual wield and double attack to move skill normally.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.215 2008/05/19 05:48:09 jps Exp myc $
d382 1
a382 1
   extern int max_npc_corpse_time, max_pc_corpse_time, top_of_corpse_list;
d404 3
a406 1
   GET_OBJ_EXTRA(corpse) = (ITEM_NODONATE | ITEM_FLOAT | ITEM_TRANSIENT);
a420 1
   GET_OBJ_VAL(corpse, 2) = top_of_corpse_list;
a421 2
   GET_OBJ_RENT(corpse) = 100000;
   GET_OBJ_RENT(corpse) = GET_LEVEL (ch);
d433 1
a433 1
   GET_OBJ_LEVEL(corpse) = 1;
d437 4
a440 9
   /* DCE - 2/11/02 - Removed the if statment below. NOGEAR was
       causing the mud to crash when extracting the corpse. So
       I am unimplementing NOGEAR until we determine it's use.
       My guess is that when the corpse is eaten or decompesess
       the object->conatins stuff isn't freed properly.
   if (!(MOB_FLAGGED(ch, MOB_NOGEAR))) */
      for (o = corpse->contains; o != NULL; o = o->next_content)
         o->in_obj = corpse;
   object_list_new_owner(corpse, NULL);
d445 1
a445 1
         obj_to_obj(unequip_char (ch, i), corpse);
d467 1
a467 1
      ccontrol_make_corpse(world[ch->in_room].vnum, corpse);
d1907 1
a1907 1
   if (IS_OBJ_STAT(weapon, ITEM_NODROP)) {
d2143 1
a2143 1
      if (IS_OBJ_STAT(obj, ITEM_WAS_DISARMED) && obj->last_to_hold == ch) {
d2152 1
a2152 1
         REMOVE_BIT(GET_OBJ_EXTRA(obj), ITEM_WAS_DISARMED);
d2501 3
@


1.215
log
@Don't allow aggression when mesmerized. Being attacked will break
you out of mesmerization.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.214 2008/05/18 20:46:02 jps Exp jps $
d1631 1
a1631 1
   int dtype, imptype;
a1704 3
   /* Save the initial skill type so it can be improved */
   imptype = type;

a1866 5
    /* imptype holds a skill like dual wield, if that's what
      * type used to be*/
    if (imptype != type && imptype != TYPE_UNDEFINED)
       improve_skill_offensively(ch, victim, imptype);

d2122 11
a2132 2
      if (ALIVE(ch) && MOB_FLAGGED (ch, MOB_SPEC) &&
            mob_index[GET_MOB_RNUM(ch)].func != NULL)
d2507 4
@


1.214
log
@Cause GLORY to be removed when you're offensive, just like invis.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.213 2008/05/18 20:15:37 jps Exp jps $
d119 5
d344 1
a344 1
      effect_from_char (ch, SPELL_SLEEP);
d1329 11
d2242 3
a2244 1
   if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
d2247 2
a2248 1
   if (!CAN_SEE(ch, tch) || PRF_FLAGGED(tch, PRF_NOHASSLE) || EFF_FLAGGED(tch, EFF_FAMILIARITY))
d2506 3
@


1.213
log
@Changed aggro/glory checking.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.212 2008/05/18 17:59:24 jps Exp jps $
a2326 1
      effect_from_char(glorion, SPELL_GLORY);
d2487 3
@


1.212
log
@Prevent aggro attacks upon folks with familiarity.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.211 2008/05/18 05:18:06 jps Exp jps $
d40 1
a45 4
void make_fun_body_pieces (struct char_data *ch, struct char_data *killer);
bool check_disarmed(struct char_data *ch);
bool is_aggr_to(struct char_data *ch, struct char_data *target);

d48 3
a50 3
extern int pk_allowed;                /* see config.c */
extern int auto_save;                /* see config.c */
extern int summon_allowed;        /*       "      */
d53 1
a53 4
extern int damage_amounts;        /*       "      */
long exp_death_loss (struct char_data *ch, int level);
void StopMercifulAttackers (struct char_data *ch);
int return_max_skill (struct char_data *ch, int skill);
d56 4
a59 4
char *fread_action (FILE * fl, int nr);
char *fread_string (FILE * fl, char *error);
void stop_follower (struct char_data *ch, int violent);
void decrease_modifier (struct char_data *i);
d63 1
d66 5
a70 14
ACMD (do_get);
ACMD (do_flee);
ACMD (do_return);
ACMD (do_bash);
ACMD (do_kick);
ACMD (do_cast);
void slow_death (struct char_data *victim);
void forget (struct char_data *ch, struct char_data *victim);
void remember (struct char_data *ch, struct char_data *victim);
int ok_damage_shopkeeper (struct char_data *ch, struct char_data *victim);
void gain_condition (struct char_data *ch, int condition, int value);
long perform_trophy_decrease (struct char_data *ch, struct char_data *vict, long exp);
void dismount_char (struct char_data *ch);
int mem_inMemory (struct char_data *ch, struct char_data *vict);
a71 2
bool sling_weapon(struct char_data *ch, int position);
int weapon_proficiency(struct obj_data *weapon, int position);
a74 7
/* new thac0 function RLS: 05-21-02 */
int calc_thac0(int level, int thac0_01, int thac0_00);

/*globals */



d78 15
a92 15
  {"hit", "hits"},                /* 0 */
  {"sting", "stings"},
  {"whip", "whips"},
  {"slash", "slashes"},
  {"bite", "bites"},
  {"bludgeon", "bludgeons"},        /* 5 */
  {"crush", "crushes"},
  {"pound", "pounds"},
  {"claw", "claws"},
  {"maul", "mauls"},
  {"thrash", "thrashes"},        /* 10 */
  {"pierce", "pierces"},
  {"blast", "blasts"},
  {"punch", "punches"},
  {"stab", "stabs"}
d99 11
d113 1
a113 1
 * allowed.  Returns TRUE if this is an unallowed action, and FALSE
d117 1
a117 1
  bool pet = FALSE;
d119 23
a141 48
  if (ch != victim &&
      (ROOM_FLAGGED(victim->in_room, ROOM_PEACEFUL) ||
       ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL))) {
    if (verbose)
      send_to_char("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
    return FALSE;
  }

  if (MOB_FLAGGED(victim, MOB_PEACEFUL)) {
    if (verbose)
      act("But $N just has such a calm, peaceful feeling about $Mself!",
          FALSE, ch, 0, victim, TO_CHAR);
    return FALSE;
  }

  if (DECEASED(victim)) {
     if (verbose)
        act("$N is already dead.", TRUE, ch, 0, victim, TO_CHAR);
     return FALSE;
  }

  /* From here on, we consider PK, so if PK is on, the attack is ok */
  if (pk_allowed)
    return TRUE;

  /* Also, PK is ok if we're in an arena room */
  if (ROOM_FLAGGED(victim->in_room, ROOM_ARENA) &&
      ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
    return TRUE;

  /* Is one of the parties a pet?  Use the master for calculations.*/
  if (ch->master && EFF_FLAGGED(ch, EFF_CHARM))
    ch = ch->master;
  if (victim->master && EFF_FLAGGED(victim, EFF_CHARM)) {
    victim = victim->master;
    pet = TRUE;
  }

  /* Feel free to hit yourself as much as you please.
   * Note that this test, coming after pet detection, will also allow
   * you to attack your own pet. */
  if (ch == victim)
    return TRUE;

  /* Unallowed PK if both attacker and victim are players */
  if (IS_PC(ch) && IS_PC(victim)) {
    /* But allow it if one of them is a switched god. */
    if (IS_NPC(ch) && GET_LEVEL(REAL_CHAR(ch)) >= LVL_GOD)
d143 4
a146 1
    if (IS_NPC(victim) && GET_LEVEL(REAL_CHAR(victim)) >= LVL_GOD)
a147 8
    if (verbose) {
      if (pet)
        send_to_char("Sorry, you can't attack someone else's pet!\r\n", ch);
      else
        send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
    }
    return FALSE;
  }
d149 31
a179 1
  return TRUE;
d207 1
a207 1
void appear(struct char_data *ch)
d209 24
a232 18
   bool was_hidden;

   effect_from_char(ch, SPELL_INVISIBLE);
   effect_from_char(ch, SPELL_NATURES_EMBRACE);

   was_hidden = IS_HIDDEN(ch);

   REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
   REMOVE_FLAG(EFF_FLAGS(ch), EFF_CAMOUFLAGED);
   GET_HIDDENNESS(ch) = 0;

   if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (was_hidden) {
         act("$n steps out of the shadows.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You step out of the shadows.\r\n", ch);
      } else {
         act("$n snaps into visibility.", FALSE, ch, 0, 0, TO_ROOM);
         send_to_char("You fade back into view.\r\n", ch);
a233 4
   } else
      act ("You feel a strange presence as $n appears, seemingly from nowhere.",
         FALSE, ch, 0, 0, TO_ROOM);
}
d236 3
a238 6
char *fread_message (FILE * fl, int nr) {
  char *action = fread_action (fl, nr);
  if (action) return action;
  sprintf(buf, "ERROR!  Message #%d missing.", nr);
  return strdup(buf);
}
d240 12
a251 6
void load_messages (void)
{
  FILE *fl;
  int i, type;
  struct message_type *messages;
  char chk[128];
d253 23
a275 11
  if (!(fl = fopen (MESS_FILE, "r")))
    {
      sprintf (buf2, "Error reading combat message file %s", MESS_FILE);
      perror (buf2);
      exit (1);
    }
  for (i = 0; i < MAX_MESSAGES; i++)
    {
      fight_messages[i].a_type = 0;
      fight_messages[i].number_of_attacks = 0;
      fight_messages[i].msg = 0;
d278 1
a278 44

  fgets (chk, 128, fl);
  while (!feof (fl) && (*chk == '\n' || *chk == '*'))
    fgets (chk, 128, fl);

  while (*chk == 'M')
    {
      fgets (chk, 128, fl);
      sscanf (chk, " %d\n", &type);
      for (i = 0; (i < MAX_MESSAGES) && (fight_messages[i].a_type != type) &&
             (fight_messages[i].a_type); i++);
      if (i >= MAX_MESSAGES)
        {
          fprintf (stderr, "Too many combat messages.  Increase MAX_MESSAGES and recompile.");
          exit (1);
        }
      CREATE (messages, struct message_type, 1);

      fight_messages[i].number_of_attacks++;
      fight_messages[i].a_type = type;
      messages->next = fight_messages[i].msg;
      fight_messages[i].msg = messages;

      messages->die_msg.attacker_msg = fread_message (fl, i);
      messages->die_msg.victim_msg = fread_message (fl, i);
      messages->die_msg.room_msg = fread_message (fl, i);
      messages->miss_msg.attacker_msg = fread_message (fl, i);
      messages->miss_msg.victim_msg = fread_message (fl, i);
      messages->miss_msg.room_msg = fread_message (fl, i);
      messages->hit_msg.attacker_msg = fread_message (fl, i);
      messages->hit_msg.victim_msg = fread_message (fl, i);
      messages->hit_msg.room_msg = fread_message (fl, i);
      messages->god_msg.attacker_msg = fread_message (fl, i);
      messages->god_msg.victim_msg = fread_message (fl, i);
      messages->god_msg.room_msg = fread_message (fl, i);
      messages->heal_msg.attacker_msg = fread_message (fl, i);
      messages->heal_msg.victim_msg = fread_message (fl, i);
      messages->heal_msg.room_msg = fread_message (fl, i);
      fgets (chk, 128, fl);
      while (!feof (fl) && (*chk == '\n' || *chk == '*'))
         fgets (chk, 128, fl);
   }

  fclose (fl);
d283 3
a285 3
  if (msg->attacker_msg)        free(msg->attacker_msg);
  if (msg->victim_msg)          free(msg->victim_msg);
  if (msg->room_msg)            free(msg->room_msg);
d289 1
a289 1
  int i;
d291 9
a299 9
  for (i = 0; i < MAX_MESSAGES; i++)
    while (fight_messages[i].msg) {
      struct message_type *former = fight_messages[i].msg;

      free_messages_type(&former->die_msg);
      free_messages_type(&former->miss_msg);
      free_messages_type(&former->hit_msg);
      free_messages_type(&former->god_msg);
      free_messages_type(&former->heal_msg);
d301 3
a303 3
      fight_messages[i].msg = fight_messages[i].msg->next;
      free(former);
    }
d307 1
a307 1
void check_killer (struct char_data *ch, struct char_data *vict)
d309 2
a310 2
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA))
     return;
d312 12
a323 12
  if (!PLR_FLAGGED (vict, PLR_KILLER) && !PLR_FLAGGED (vict, PLR_THIEF)
      && !PLR_FLAGGED (ch, PLR_KILLER) && !IS_NPC (ch) && !IS_NPC (vict) &&
      (ch != vict))
    {
      char buf[256];

      SET_FLAG (PLR_FLAGS (ch), PLR_KILLER);
      sprintf (buf, "PC Killer bit set on %s for initiating attack on %s at %s.",
               GET_NAME (ch), GET_NAME (vict), world[vict->in_room].name);
      mudlog (buf, BRF, LVL_IMMORT, TRUE);
      send_to_char ("If you want to be a PLAYER KILLER, so be it...\r\n", ch);
    }
d327 1
a327 1
/* start one char fighting another (yes, it is horrible, I know... )  */
d330 2
a331 2
  if (ch == vict || GET_STANCE(ch) <= STANCE_STUNNED)
    return;
d333 1
a333 1
  assert(!FIGHTING (ch));        /*Setmark game crashing due to assertion failing */
d335 2
a336 2
  ch->next_fighting = combat_list;
  combat_list = ch;
d338 2
a339 2
  if (EFF_FLAGGED (ch, EFF_SLEEP))
    effect_from_char (ch, SPELL_SLEEP);
d341 4
a344 4
  FIGHTING(ch) = vict;
  if (GET_POS(ch) != POS_FLYING)
     GET_POS(ch) = POS_STANDING;
  GET_STANCE(ch) = STANCE_FIGHTING;
d346 2
a347 2
  if (!pk_allowed)
    check_killer (ch, vict);
d354 1
a354 1
  struct char_data *temp;
d356 2
a357 2
  if (ch == next_combat_list)
    next_combat_list = ch->next_fighting;
d359 3
a361 106
  REMOVE_FROM_LIST(ch, combat_list, next_fighting);
  ch->next_fighting = NULL;
  FIGHTING(ch) = NULL;

  /* This function is called from alter_pos(), so in the interest of avoiding
   * infinite loops -- and because this is a pretty safe stance change --
   * we'll directly modify the stance. */
  if (GET_STANCE(ch) == STANCE_FIGHTING)
    GET_STANCE(ch) = STANCE_ALERT;
}



struct obj_data *make_corpse (struct char_data *ch)
{
  struct obj_data *corpse, *o;
  struct obj_data *money;
  int i;
  extern int max_npc_corpse_time, max_pc_corpse_time, top_of_corpse_list;
  struct obj_data *create_money (int pamount, int gamount, int samount, int camount);

  if (MOB_FLAGGED(ch, MOB_ILLUSORY)) {
     act("$n seems to have vanished entirely.", TRUE, ch, 0, 0, TO_ROOM);
     return NULL;
  }

  corpse = create_obj();

  corpse->item_number = NOTHING;
  corpse->in_room = NOWHERE;
  sprintf(buf2, "corpse %s", strip_ansi ((ch)->player.namelist));
  corpse->name = strdup (buf2);

  sprintf(buf2, "&0The corpse of %s&0 is lying here.", GET_NAME (ch));
  corpse->description = strdup (buf2);

  sprintf(buf2, "the corpse of %s", GET_NAME (ch));
  corpse->short_description = strdup (buf2);

  GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
  GET_OBJ_EXTRA(corpse) = (ITEM_NODONATE | ITEM_FLOAT | ITEM_TRANSIENT);
  GET_OBJ_VAL(corpse, 0) = 0;        /* You can't store stuff in a corpse */

  /* someone made value 1 represent pc/npc corpse, but value 1 is already
   * open/closed. moving it to value 3, and modifying other code
   * as appropriate */
  /* unraisable corpse if-clause added 11/5/99 by 321 */
  if (!IS_NPC(ch))
    GET_OBJ_VAL(corpse, 3) = CORPSE_PC;         /* player corpse          */
  else if (GET_LIFEFORCE(ch) == LIFE_UNDEAD)
    GET_OBJ_VAL(corpse, 3) = CORPSE_NPC_NORAISE;/* npc corpse - unraisable */
  else
    GET_OBJ_VAL(corpse, 3) = CORPSE_NPC;        /* npc corpse - raisable   */

  GET_OBJ_VAL(corpse, 1) = 0; /* not closable */
  GET_OBJ_VAL(corpse, 2) = top_of_corpse_list;
  GET_OBJ_WEIGHT(corpse) = GET_WEIGHT (ch) + IS_CARRYING_W (ch) + 100;
  GET_OBJ_RENT(corpse) = 100000;
  GET_OBJ_RENT(corpse) = GET_LEVEL (ch);
  if (IS_NPC(ch))
    GET_OBJ_MOB_FROM(corpse) = GET_MOB_RNUM (ch);
  else
    GET_OBJ_MOB_FROM(corpse) = NOBODY;

  if (IS_NPC(ch))
    GET_OBJ_TIMER(corpse) = max_npc_corpse_time;
  else
    GET_OBJ_TIMER(corpse) = max_pc_corpse_time;

  /* 4/5/01 - Zantir - Give corpses a level */
  GET_OBJ_LEVEL(corpse) = 1;

  /* transfer character's inventory to the corpse */
  corpse->contains = ch->carrying;
  /* DCE - 2/11/02 - Removed the if statment below. NOGEAR was
     causing the mud to crash when extracting the corpse. So
     I am unimplementing NOGEAR until we determine it's use.
     My guess is that when the corpse is eaten or decompesess
     the object->conatins stuff isn't freed properly.
  if (!(MOB_FLAGGED(ch, MOB_NOGEAR))) */
    for (o = corpse->contains; o != NULL; o = o->next_content)
      o->in_obj = corpse;
  object_list_new_owner(corpse, NULL);

  /* transfer character's equipment to the corpse */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_obj(unequip_char (ch, i), corpse);

  /* transfer gold */
  if (GET_CASH(ch) > 0)
    {
      /* following 'if' clause added to fix gold duplication loophole */
      if (IS_NPC(ch) || (!IS_NPC(ch) && ch->desc))
        {
          money = create_money(GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
          obj_to_obj(money, corpse);
        }
      GET_GOLD(ch) = 0;
      GET_PLAT(ch) = 0;
      GET_COPPER(ch) = 0;
      GET_SILVER(ch) = 0;
    }
  ch->carrying = NULL;
  IS_CARRYING_N(ch) = 0;
  IS_CARRYING_W(ch) = 0;
d363 6
a368 3
  obj_to_room(corpse, ch->in_room);
  if (!IS_NPC(ch))
    ccontrol_make_corpse(world[ch->in_room].vnum, corpse);
a369 2
  return corpse;
}
d372 1
a372 1
void change_alignment (struct char_data *ch, struct char_data *victim)
d374 5
a378 1
  int k_al, v_al, change;
d380 4
a383 2
  k_al = GET_ALIGNMENT(ch);
  v_al = GET_ALIGNMENT(victim);
d385 1
a385 5
  /* If victim was !good, and killer was good, make victim seem eviler */
  if (MOB_FLAGGED(victim, MOB_AGGR_GOOD) && IS_GOOD(ch))
    v_al -= 100;
  else if (MOB_FLAGGED(victim, MOB_AGGR_EVIL) && IS_EVIL(ch))
    v_al += 100;
d387 25
a411 11
  /* if we are a 'good' class then our effective align is higher, ie
   * even if a paladin of align 800 kills someone its as if they were align
   * 900 compared to a wariror 800 (cos they should know better!)
   */
  switch (GET_CLASS(ch)) {
  /* using drop through cases to accumulate the align*/
  case CLASS_PALADIN:
  case CLASS_PRIEST:       k_al += 50;
  case CLASS_RANGER:
  case CLASS_DRUID:        k_al += 50;
                           break;
d413 9
a421 7
  /* same deal for 'bad' classes */
  case CLASS_ANTI_PALADIN:
  case CLASS_DIABOLIST:
  case CLASS_NECROMANCER:  k_al -= 50;
  case CLASS_THIEF:
  case CLASS_ASSASSIN:     k_al -=50;
  }
d423 4
a426 1
  change = (v_al / (-75 - (25 * abs((k_al - 1000) / 200)))) - (2 * abs(k_al / 1000));
d428 2
a429 3
  /* modifier based on level? */
  if (change < 0 && GET_LEVEL(ch) > GET_LEVEL(victim) + 10)
    change *= (GET_LEVEL(ch) - GET_LEVEL(victim)) / 10;
d431 40
a470 2
  GET_ALIGNMENT(ch) += change;
  GET_ALIGNMENT(ch) = LIMIT(-1000, GET_ALIGNMENT(ch), 1000);
d473 2
a474 1
void death_cry (struct char_data *ch)
d476 30
a505 1
  int door, was_in;
d507 9
a515 2
  act("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);
  was_in = ch->in_room;
d517 18
a534 11
  for (door = 0; door < NUM_OF_DIRS; door++) {
    if (CAN_GO(ch, door) &&
        (!ROOM_FLAGGED(was_in, ROOM_ARENA) ||
        !ROOM_FLAGGED(world[was_in].exits[door]->to_room, ROOM_OBSERVATORY)) &&
        (!ROOM_FLAGGED(was_in, ROOM_OBSERVATORY) ||
        !ROOM_FLAGGED(world[was_in].exits[door]->to_room, ROOM_ARENA))) {
      ch->in_room = world[was_in].exits[door]->to_room;
      act("Your blood freezes as you hear someone's death cry.", FALSE, ch, 0, 0, TO_ROOM);
      ch->in_room = was_in;
    }
  }
d585 66
a650 65
  struct char_data *real_char;
  struct obj_data *corpse = NULL, *obj, *next_obj;
  struct mem_list *cur;

  void get_from_container(struct char_data *ch, struct obj_data *obj, char *arg, int mode);
  void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
                                struct obj_data * cont, int mode);


  /*check for switched victim */
  if (ch->desc && ch->desc->original) {
      real_char = ch->desc->original;
      char_from_room (real_char);
      char_to_room (real_char, ch->in_room);
  }
  else
    real_char = ch;

  while (ch->effects)
    effect_remove(ch, ch->effects);
  while (real_char->effects)
    effect_remove(real_char, real_char->effects);

  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA)) {
     arena_death(ch);
     return;
  }
  /* Everything beyond this point applies to normal, non-arena deaths */

  /* Set all spells in the memory list to unmemorized, but don't remove. */
  for (cur = GET_SPELL_MEM(ch).list_head; cur; cur = cur->next)
    cur->can_cast = 0;
  GET_SPELL_MEM(ch).num_memmed = 0;
  GET_SPELL_MEM(ch).mem_status = FALSE;

  /* Stop NPCs from hunting you */
  remove_from_all_memories(ch);

  if (IS_NPC(real_char) && GET_LEVEL(real_char) < 60 &&
      !MOB_FLAGGED(real_char, MOB_ILLUSORY))
    perform_random_gem_drop(ch);

  if (GET_LEVEL(real_char) < LVL_IMMORT) {
    corpse = make_corpse(real_char);
    if (!IS_NPC(real_char))        /* If killed dont save in room he died in */
      GET_LOADROOM(real_char) = GET_HOME (real_char);
    if (ch != real_char)
      extract_char(real_char);
    extract_char(ch);
  } else if (ch != real_char) {
    do_return(real_char, "", 0, 1);
    corpse = make_corpse(ch);
    extract_char(ch);
  }

  if (killer && ch != killer && corpse && corpse->contains) {
    if (PRF_FLAGGED(killer, PRF_AUTOLOOT))
      get_from_container(killer, corpse, "all", FIND_OBJ_ROOM);
    else if (PRF_FLAGGED(killer, PRF_AUTOTREAS)) {
      for (obj = corpse->contains; obj; obj = next_obj) {
        next_obj = obj->next_content;
        if (GET_OBJ_TYPE(obj) == ITEM_MONEY ||
              GET_OBJ_TYPE(obj) == ITEM_TREASURE) {
          perform_get_from_container(killer, obj, corpse, 0);
        }
d652 1
a652 2
    }
  }
d657 19
a675 19
  int members = 0;
  struct char_data *group_master;
  struct group_type *g;

  group_master = (ch->group_master ? ch->group_master : ch);

  if (group_master->in_room == ch->in_room)
    members = 1;
  for (g = group_master->groupees; g; g = g->next)
    if (g->groupee->in_room == ch->in_room)
      ++members;

  if (group_master->in_room == ch->in_room)
    if (!IS_NPC(group_master))
      kill_to_trophy(victim, group_master, 1.0 / members);
  for (g = group_master->groupees; g; g = g->next)
    if (g->groupee->in_room == ch->in_room)
      if (!IS_NPC(g->groupee))
        kill_to_trophy(victim, g->groupee, 1.0 / members);
d756 5
a760 5
  /* Can't use MAX() because it returns an int. */
  if (level_diff > 0)
    return 1.0 + (0.015 * level_diff);
  else
    return 1.0;
d781 8
a788 11
  struct char_data *group_master;
  struct group_type *g;
  long total_exp, exp_share;
  int groupees = 0;

  group_master = killer->group_master ? killer->group_master : killer;

  if (group_master->in_room == killer->in_room)
    ++groupees;
  for (g = group_master->groupees; g; g = g->next)
    if (g->groupee->in_room == killer->in_room)
d790 13
a802 10

  total_exp = GET_EXP(vict);
  total_exp *= 1.3;
  exp_share = total_exp / groupees;
  
  if (group_master->in_room == killer->in_room)
    receive_kill_credit(group_master, vict, exp_share);
  for (g = group_master->groupees; g; g = g->next)
    if (g->groupee->in_room == killer->in_room)
      receive_kill_credit(g->groupee, vict, exp_share);
d831 2
a832 2
  static char buf[256];
  char *cp;
d834 1
a834 1
  cp = buf;
d836 3
a838 5
  for (; *str; str++)
    {
      if (*str == '#')
        {
          switch (*(++str))
d840 12
a851 9
            case 'W':
              for (; *weapon_plural; *(cp++) = *(weapon_plural++));
              break;
            case 'w':
              for (; *weapon_singular; *(cp++) = *(weapon_singular++));
              break;
            default:
              *(cp++) = '#';
              break;
d853 2
a854 3
        }
      else
        *(cp++) = *str;
d856 2
a857 2
      *cp = 0;
    }                                /* For */
d859 1
a859 1
  return (buf);
d863 25
a887 25
  /*
   * In comm.h, TO_ROOM is 1, TO_VICT is 2, TO_NOTVICT is 3, TO_CHAR is 4
   */
  const char *colors[6] = {
    "",
    "&4",
    "&1&8",
    "&4",
    "&3",
    "&2&8", /* healing */
  };
  if (damage_amounts) {
    if (type != TO_VICT && type != TO_NOTVICT && type != TO_CHAR && type != TO_ROOM) {
      sprintf(b, "SYSERR: append_damage_amounts: unrecognized target type %d", type);
      log(b);
      type = TO_NOTVICT;
    }
    if (dam < 0) {
      dam *= -1;
      type = 5; /* healing */
    }
    sprintf(b, "%s (%s%d&0)", msg, colors[type], dam);
  }
  else
    sprintf(b, "%s", msg);
d893 2
a894 2
void dam_message (int dam, struct char_data *ch, struct char_data *victim,
             int w_type)
d896 47
a942 19
  char *buf;
  char b2[256];
  int msgnum;
  int percent = 0;

  static struct dam_barehand
  {
    char *to_room;
    char *to_char;
    char *to_victim;
  }
  bare_attack[] =
  {
    {
      "$n threw $s punch just a little wide, missing $N completely.&0",        /* 0: 0     */
      "You thought you saw $N somewhere where $E wasn't.&0",
      "$n takes aim at you, but loses communication with $s fists!&0"
    }
    ,
d944 6
a949 6
    {
      "$n slaps $N before tweaking $S nose.&0",                /* 1: 1..2  */
      "You slap $N, and while $E is distracted, make a grab for $S nose.&0",
      "$n slaps your cheek, then tries to twist your nose off!&0"
    }
    ,
d951 6
a956 6
    {
      "$n delivers a swift kick to $N's shin, causing a yelp of pain.&0",        /* 2: 3..4  */
      "You send a swift kick to $N's shin.&0",
      "You yelp in pain as $n kicks you in the shin!&0"
    }
    ,
d958 6
a963 6
    {
      "$N howls in pain as $n nearly rips $S ear off!&0",                /* 3: 5..6  */
      "You grab $N's ears and almost pull them off!&0",
      "You cannot help but scream in pain as $n gets a good grasp on your ears.&0"
    }
    ,
d965 6
a970 6
    {
      "$N nearly doubles over choking as $n collapses $S trachea!&0",        /* 4: 7..10  */
      "You sink your stiffened fingers into $N's throat.&0",
      "$n strikes you in the throat, making you cough involuntarily.&0"
    }
    ,
d972 8
a979 6
    {
      "$n dances up to $N and throws $s elbow into $S gut!&0",        /* 5: 11..14  */
      "You spin around so your back is against $N and throw your elbow into $S gut!&0",
      "$n dances up to you, and throws $s elbow into your stomach!  OUCH!&0"
    }
    ,
d981 1
a981 6
    {
      "Cupping $s hands, $n slaps $N's ears, bursting $S eardrums.&0",        /* 6: 15..19  */
      "You cup your hands and slap $N's ears, hoping to cause deafness.&0",
      "You feel as if $n inserted long daggers into your ears, piercing your brain!&0"
    }
    ,
d983 6
a988 6
    {
      "$n punches $N repeatedly in the kidneys!&0",        /* 7: 19..23 */
      "You wallop $N in the kidneys!&0",
      "$n repeatedly punches you in the kidneys, you feel like hurling!&0"
    }
    ,
d990 6
a995 6
    {
      "$n punches $N in the throat, causing $M to choke!&0",        /* 8: > 23   */
      "You punch $N in the throat causing $M to nearly choke to death!&0",
      "$n nails you in the throat, you barely survive from choking to death!&0"
    }
  };
d997 6
a1002 17
  static struct dam_weapon_type
  {
    char *to_room;
    char *to_char;
    char *to_victim;
  }
  dam_weapons[] =
  {

    /* use #w for singular (i.e. "slash") and #W for plural (i.e. "slashes") */

    {
      "$n tries to #w $N, but misses.&0",        /* 0: 0     */
      "You try to #w $N, but miss.&0",
      "$n tries to #w you, but misses.&0"
    }
    ,
d1004 6
a1009 6
    {
      "$n grazes $N as $e #W $M.&0",                /* 1: 1..2  */
      "You graze $N as you #w $M.&0",
      "$n grazes you as $e #W you.&0"
    }
    ,
d1011 6
a1016 6
    {
      "$n barely #W $N.&0",        /* 2: 3..4  */
      "You barely #w $N.&0",
      "$n barely #W you.&0"
    }
    ,
d1018 6
a1023 6
    {
      "$n #W $N.&0",                /* 3: 5..6  */
      "You #w $N.&0",
      "$n #W you.&0"
    }
    ,
d1025 6
a1030 6
    {
      "$n #W $N hard.&0",        /* 4: 7..10  */
      "You #w $N hard.&0",
      "$n #W you hard.&0"
    }
    ,
d1032 6
a1037 6
    {
      "$n #W $N very hard.&0",        /* 5: 11..14  */
      "You #w $N very hard.&0",
      "$n #W you very hard.&0"
    }
    ,
d1039 6
a1044 6
    {
      "$n #W $N extremely hard.&0",        /* 6: 15..19  */
      "You #w $N extremely hard.&0",
      "$n #W you extremely hard.&0"
    }
    ,
d1046 1
a1046 6
    {
      "$n massacres $N to small fragments with $s #w.&0",        /* 7: 19..23 */
      "You massacre $N to small fragments with your #w.&0",
      "$n massacres you to small fragments with $s #w.&0"
    }
    ,
d1048 2
a1049 6
    {
      "$n nearly rips $N in two with $s deadly #w!!&0",        /* 8: > 23   */
      "You nearly rip $N in two with your deadly #w!!&0",
      "$n nearly rips you in two with $s deadly #w!!&0"
    }
  };
d1051 4
a1054 1
  memset(b2, 0x0, 256);
d1056 31
a1086 2
  if (w_type != SKILL_BAREHAND)
      w_type -= TYPE_HIT;                /* Change to base of table with text */
d1088 26
a1113 63
  if (GET_HIT (victim) > 0)
    percent = (int) (dam * 100 / GET_HIT (victim));
  else
    percent = 100;

  if ((percent <= 1) && (dam >= 20))
    percent += 1;
  if ((percent <= 1) && (dam >= 50))
    percent += 1;

  /* this fixes the false message due to the rounding error --gurlaek 11/22/1999 */
  percent = MAX(percent, 1);

  if (dam == 0)
    percent = 0;

  if (percent == 0)
    msgnum = 0;
  else if (percent <= 2)
    msgnum = 1;
  else if (percent <= 4)
    msgnum = 2;
  else if (percent <= 6)
    msgnum = 3;
  else if (percent <= 10)
    msgnum = 4;
  else if (percent <= 15)
    msgnum = 5;
  else if (percent <= 19)
    msgnum = 6;
  else if (percent <= 35)
    msgnum = 7;
  else if (percent <= 55)
    msgnum = 8;
  else
    msgnum = 8;

  /* damage message to onlookers */
  if (w_type == SKILL_BAREHAND)
     buf = bare_attack[msgnum].to_room;
  else
     buf = replace_string (dam_weapons[msgnum].to_room,
                        attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  append_damage_amount(b2, buf, dam, TO_NOTVICT);
  act (b2, FALSE, ch, NULL, victim, TO_NOTVICT);

  /* damage message to damager */
  if (w_type == SKILL_BAREHAND)
     buf = bare_attack[msgnum].to_char;
  else
     buf = replace_string (dam_weapons[msgnum].to_char,
                        attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  append_damage_amount(b2, buf, dam, TO_CHAR);
  act (b2, FALSE, ch, NULL, victim, TO_CHAR);

  /* damage message to damagee */
  if (w_type == SKILL_BAREHAND)
     buf = bare_attack[msgnum].to_victim;
  else
     buf = replace_string (dam_weapons[msgnum].to_victim,
                        attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  append_damage_amount(b2, buf, dam, TO_VICT);
  act (b2, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
d1123 1
a1123 1
bool skill_message (int dam, struct char_data *ch, struct char_data *vict,
d1188 1
a1188 1
           int attacktype)
d1190 29
a1218 23
  int attacker_weapons, dummy, shdam;
  struct char_data *was_fighting = FIGHTING(victim);
  bool death = FALSE;

  if (DECEASED(victim)) {
    sprintf(buf, "SYSERR: Attempt to damage a corpse in room num %d",
          world[victim->in_room].vnum);
    log(buf);
    return VICTIM_DEAD;
  }

  /*
   * Eventually, I hope to implement V3's resistances here.
   * The resistance check needs to come before healing in case
   * the victim has inverse resistance to the damage.
   */

  /*
   * If damage is negative and healing should occur, take care of it
   * up here so as not to confuse the real damage code below.
   */
  if (dam < 0) {
    int orig_hp = GET_HIT(victim);
d1220 3
a1222 1
    hurt_char(victim, ch, dam, TRUE);
d1224 2
a1225 3
    if (!skill_message(dam, ch, victim, attacktype, FALSE)) {
      /* Default message */
    }
d1227 2
a1228 3
    /* Return the actual amount of healing that occured. */
    return orig_hp - GET_HIT(victim);
  }
d1230 25
a1254 2
  if (!attack_ok(ch, victim, TRUE))
    return 0;
d1256 4
a1259 2
  if (victim != ch) {
    if (GET_STANCE(ch) > STANCE_STUNNED) {
d1262 9
a1270 2
      if (!IS_SPELL(attacktype) && !FIGHTING(ch))
        set_fighting(ch, victim);
d1273 1
a1273 2
       * If this is a pet attacking, there is a chance the victim will
       * notice the master and switch targets.
d1275 3
a1277 17
      if (IS_NPC(ch) && IS_NPC(victim) && victim->master &&
          !number(0, 100) && EFF_FLAGGED(victim, EFF_CHARM) &&
          (victim->master->in_room == ch->in_room) &&
          CAN_SEE(ch, victim->master)) {
        if (FIGHTING(ch))
          stop_fighting(ch);

        sprintf(buf, "&6&b$n observes your command over %s and attacks YOU instead!&0",
                GET_NAME(victim));
        act(buf, FALSE, ch, 0, victim->master, TO_VICT);

        sprintf(buf, "&6&b$n observes $N commanding %s and attacks $M instead!&0",
                GET_NAME(victim));
        act(buf, FALSE, ch, 0, victim->master, TO_NOTVICT);
        sprintf(buf, "&6&bYou observes $N commanding %s and attacks $M instead!&0",
        GET_NAME(victim));
        act(buf, FALSE, ch, 0, victim->master, TO_CHAR);
d1279 68
a1346 2
        attack(ch, victim->master);
        return 0;
d1348 35
a1382 1
    }
d1384 7
a1390 10
    /* Start the attacker fighting the victim. */
    if (GET_STANCE(victim) > STANCE_STUNNED && !FIGHTING(victim)) {
      /*
       * NPC's always start fighting, but PC's can ignore spells via
       * the PASSIVE flag.
       */
      if (IS_NPC(victim) ||
          (!IS_SPELL(attacktype) || !PRF_FLAGGED(victim, PRF_PASSIVE)))
        set_fighting(victim, ch);
    }
d1392 9
a1400 74
    /*
     * If the mob has memory, make them remember this player.
     */
    if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch))
      remember(victim, ch);
  }

  /* If ch is attacking his/her pet, cancel charming */
  if (victim->master == ch)
    stop_follower(victim, TRUE);

  /* Appear, lose glory */
  aggro_lose_spells(ch);

  /* Reduce damage for PVP for everything except spells */
  if (!IS_NPC(ch) && !IS_NPC(victim) && attacktype > MAX_SPELLS)
    dam /= 3;

  /* Charmies do half damage. */
  if (EFF_FLAGGED(ch, EFF_CHARM) || MOB_FLAGGED(ch, MOB_PET))
    dam >>= 1;

  /* Sanctuary and stone skin take half damage. */
  if (EFF_FLAGGED(victim, EFF_SANCTUARY) ||
      EFF_FLAGGED(victim, EFF_STONE_SKIN))
    dam >>= 1;

  /* Protection from evil/good takes 90% damage */
  if (EFF_FLAGGED(victim, EFF_PROTECT_EVIL) &&
      GET_ALIGNMENT(ch) <= -500 && GET_ALIGNMENT(victim) >= 500)
    dam *= 0.9;

  else if (EFF_FLAGGED(victim, EFF_PROTECT_GOOD) &&
      GET_ALIGNMENT(ch) >= 500 && GET_ALIGNMENT(victim) <= -500)
    dam *= 0.9;

  /* You can't damage an immortal! */
  if (!IS_NPC(victim) && GET_LEVEL(victim) >= LVL_IMMORT)
    dam = 0;

  if (EFF_FLAGGED(victim, EFF_MINOR_PARALYSIS)) {
    act("$n's attack frees $N from magic which held $M motionless.",
        FALSE, ch, 0, victim, TO_NOTVICT);
    act("$n's blow shatters the magic paralyzing you!", FALSE, ch, 0,
        victim, TO_VICT);
    act("Your blow disrupts the magic keeping $N frozen.", FALSE, ch, 0,
        victim, TO_CHAR);
    effect_from_char(victim, SPELL_MINOR_PARALYSIS);
    effect_from_char(victim, SPELL_ENTANGLE);
    REMOVE_FLAG(EFF_FLAGS(victim), EFF_MINOR_PARALYSIS);
  }

  if (!pk_allowed)
    check_killer(ch, victim);

  /* Cap damage */
  dam = MAX(MIN(dam, MAX_DAMAGE), 0);

  if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) {
    /* Will the victim die? */
    death = DAMAGE_WILL_KILL(victim, dam);

    /* Vampiric touch */
    if (IS_WEAPON(attacktype) || SKILL_IS_TARGET(attacktype, TAR_CONTACT)) {
      count_hand_eq(ch, &dummy, &attacker_weapons);
      if (ch != victim && attacker_weapons == 0) {
        if (EFF_FLAGGED(ch, EFF_VAMP_TOUCH)) {
            hurt_char(ch, NULL, -dam, FALSE);
        } else if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0) {
          if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > number(0, 101))
            hurt_char(ch,  NULL, -dam / 2, TRUE);
          if (number(0, 2))
            improve_skill(ch, SKILL_VAMP_TOUCH);
        }
d1402 1
a1402 2
    }
  }
d1404 6
a1409 53
  /* You get some exp for doing damage (but not to players or illusions) */
  if (ch != victim && !IS_NPC(ch) && !MOB_FLAGGED(victim, MOB_ILLUSORY))
    gain_exp(ch, victim, (GET_LEVEL(victim) * dam) /
             MAX((GET_LEVEL(ch) - GET_LEVEL(victim) > 10 ? 30 : 15),
                 50 - GET_LEVEL(ch)));

  /*
   * skill_message sends a message from the messages file in lib/misc.
   * dam_message just sends a generic "You hit $n extremely hard.".
   * skill_message is preferable to dam_message because it is more
   * descriptive.
   *
   * If we are _not_ attacking with a weapon (i.e. a spell), always use
   * skill_message. If we are attacking with a weapon: If this is a miss or a
   * death blow, send a skill_message if one exists; if not, default to a
   * dam_message. Otherwise, always send a dam_message.
   */
  if (attacktype == SKILL_BAREHAND) {
    if (death)
      skill_message(dam, ch, victim, attacktype, death);
    else
      dam_message(dam, ch, victim, attacktype);
  }
  else if (!IS_WEAPON (attacktype))
    skill_message(dam, ch, victim, attacktype, death);
  else {
    if (death || dam == 0) {
      if (!skill_message(dam, ch, victim, attacktype, death))
        dam_message(dam, ch, victim, attacktype);
    }
    else
      dam_message(dam, ch, victim, attacktype);
  }

  /* Defensive spells bite back */
  if (ch != victim && GET_LEVEL(ch) < LVL_IMMORT && (IS_WEAPON(attacktype) ||
      SKILL_IS_TARGET(attacktype, TAR_CONTACT))) {
    shdam = defensive_spell_damage(ch, victim, dam);
    if (shdam > 0 && !MOB_FLAGGED(victim, MOB_ILLUSORY))
       hurt_char(ch, victim, shdam, TRUE);
  }

  /* Do the damage. */
  if (!MOB_FLAGGED(ch, MOB_ILLUSORY)) {
    hurt_char(victim, ch, dam, TRUE);
    /* Sanity check */
    if (death && !DECEASED(victim)) {
      sprintf(buf,
            "Error: Damage of %d was predicted to kill %s, but victim survived with %d hp",
            dam, GET_NAME(victim), GET_HIT(victim));
      mudlog(buf, BRF, LVL_GOD, FALSE);
    }
  }
d1411 13
a1423 19
  /* If the victim is somehow sleeping after all this, then they can't fight. */
  if (!AWAKE(victim)) {
    if (FIGHTING(victim))
      stop_fighting(victim);
    abort_casting(victim);
  }

  /* If the victim died, award exp and quit. */
  if (DECEASED(victim)) {
    /* If the victim is about to die by something like fire or poison,
     * AND they are in combat with someone, let their opponent get the
     * exp for killing them. */
    if (ch == victim && was_fighting) {
      switch (attacktype) {
        case SPELL_ON_FIRE:
        case SPELL_POISON:
        case TYPE_SUFFERING:
          ch = was_fighting;
          break;
a1424 1
    }
d1426 16
a1441 16
    disburse_kill_exp(ch, victim);
    return VICTIM_DEAD;
  }

  /* Fleeing */
  if (AWAKE(victim)) {
    if (IS_NPC(victim) && GET_HIT(victim) < (GET_MAX_HIT(victim) >> 2)) {
      if (MOB_FLAGGED(victim, MOB_WIMPY) && (ch != victim) &&
          !EFF_FLAGGED(victim, EFF_CHARM))
        do_flee (victim, "", 0, 0);
    } else if (!IS_NPC(victim) && GET_WIMP_LEV(victim) && (victim != ch) &&
        GET_HIT(victim) < GET_WIMP_LEV(victim)) {
      send_to_char("You attempt to flee!\r\n", victim);
      do_flee(victim, "", 0, 0);
    }
  }
d1443 1
a1443 1
  return dam;
d1448 19
a1466 1
  int ch_hit, vict_riposte;
d1468 2
a1469 2
  if (!GET_SKILL(victim, SKILL_RIPOSTE))
    return FALSE;
d1471 2
a1472 2
  if (GET_POS(victim) <= POS_SITTING)
    return FALSE;
d1474 16
a1489 34
  if (!GET_EQ(victim, WEAR_WIELD) && !GET_EQ(victim, WEAR_2HWIELD) &&
      !GET_SKILL(victim, SKILL_BAREHAND))
    return FALSE;

  ch_hit = number(55, 200);
  ch_hit += GET_HITROLL(ch);
  ch_hit -= monk_weight_penalty(ch);
  vict_riposte = number(20, 50);
  vict_riposte += GET_LEVEL(victim) - GET_LEVEL(ch);
  vict_riposte -= dex_app[GET_DEX(victim)].defensive;
  vict_riposte += GET_SKILL(victim, SKILL_RIPOSTE) * 0.085;

  if (number(1, 10) < 5)
    improve_skill_offensively(victim, ch, SKILL_RIPOSTE);

  if (vict_riposte <= ch_hit)
    return FALSE;

  if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
    act("&8You grab $n's arm and twist it, causing $m to strike $mself!&0",
        FALSE, ch, 0, victim, TO_VICT);
    act("&8$N grabs your arm and twists it, causing you to damage to yourself!&0",
        FALSE, ch, 0, victim, TO_CHAR);
    act("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0",
        FALSE, ch, 0, victim, TO_NOTVICT);
  }
  else {
    act("&8You block $n's attack, and strike back!&0",
        FALSE, ch, 0, victim, TO_VICT);
    act("&8$N blocks your attack, and strikes back!&0",
        FALSE, ch, 0, victim, TO_CHAR);
    act("&7$N blocks $n's attack, and strikes back at $m!&0",
        FALSE, ch, 0, victim, TO_NOTVICT);
  }
d1491 2
a1492 2
  hit(victim, ch, SKILL_RIPOSTE);
  return TRUE;
d1496 11
a1506 1
  int ch_hit, vict_parry;
d1508 9
a1516 2
  if (!GET_SKILL(victim, SKILL_PARRY))
    return FALSE;
d1518 16
a1533 2
  if (GET_POS(victim) <= POS_SITTING)
    return FALSE;
d1535 4
a1538 35
  if (!GET_EQ(victim, WEAR_WIELD) && !GET_EQ(victim, WEAR_2HWIELD) &&
      !GET_SKILL(victim, SKILL_BAREHAND))
    return FALSE;

  ch_hit = number(45, 181);
  ch_hit += GET_HITROLL(ch);
  ch_hit -= monk_weight_penalty(ch);
  vict_parry = number(20, 50);
  vict_parry += GET_LEVEL(victim) - GET_LEVEL(ch);
  vict_parry -= dex_app[GET_DEX(victim)].defensive;
  vict_parry += GET_SKILL(victim, SKILL_PARRY) / 10;
  if (number(1, 10) < 5)
    improve_skill_offensively(victim, ch, SKILL_PARRY);

  if (vict_parry <= ch_hit)
    return FALSE;

  if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
    act("&7You smirk and slap $n's attack away with ease.&0",
        FALSE, ch, 0, victim, TO_VICT);
    act("&7$N smirks and slaps your attack away.&0",
        FALSE, ch, 0, victim, TO_CHAR);
    act("&7$N smirks as $E slaps $n's attack away.&0",
        FALSE, ch, 0, victim, TO_NOTVICT);
  }
  else {
    act("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
    act("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
  }

  if (!FIGHTING(ch))
    set_fighting(ch, victim);
  if (!FIGHTING(victim))
    set_fighting(victim, ch);
d1540 1
a1540 1
  return TRUE;
d1544 19
a1562 1
  int ch_hit, vict_dodge;
d1564 24
a1587 42
  if (!GET_SKILL(victim, SKILL_DODGE))
    return FALSE;
  if (GET_POS(victim) <= POS_SITTING)
    return FALSE;

  ch_hit = number(35, 171);
  ch_hit += GET_HITROLL(ch);
  ch_hit -= monk_weight_penalty(ch);
  vict_dodge = number(20, 50);
  vict_dodge += GET_LEVEL(victim) - GET_LEVEL(ch);
  vict_dodge -= dex_app[GET_DEX(victim)].defensive;
  vict_dodge += GET_SKILL(victim, SKILL_DODGE) / 10;
  if (number(1, 10) < 5)
    improve_skill_offensively(victim, ch, SKILL_DODGE);

  if (vict_dodge <= ch_hit)
    return FALSE;

  if (GET_SKILL(ch, SKILL_BAREHAND) > 20) {
    if (CAN_SEE(ch, victim))
      act("&7You twist in place and watch $n attack the air nearby.&0",
          FALSE, ch, 0, victim, TO_VICT);
    else
      act("&7You twist in place, avoiding $n's attack.&0",
          FALSE, ch, 0, victim, TO_VICT);
    act("&7$N twists in place causing you to strike nothing but air!&0",
        TRUE, ch, 0, victim, TO_CHAR);
    act("&7$N twists in place as $n attacks the air nearby $M.&0",
        TRUE, ch, 0, victim, TO_NOTVICT);
  }
  else {
    act("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
    act("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
    act("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
  }

  if (!FIGHTING(ch))
    set_fighting(ch, victim);
  if (!FIGHTING(victim))
    set_fighting(victim, ch);

  return TRUE;
d1591 14
a1604 14
int weapon_special (struct obj_data *wpn, struct char_data *ch)
{
  int (*name) (struct char_data * ch, void *me, int cmd, char *argument);

  SPECIAL(lightning_weapon);
  SPECIAL(vampiric_weapon);
  SPECIAL(holyw_weapon);


  name = obj_index[GET_OBJ_RNUM(wpn)].func;
  if (name != vampiric_weapon && name != lightning_weapon &&
      name != holyw_weapon)
    return 0;
  return (name)(ch, wpn, 0, "");
d1610 19
a1628 29
  int victim_ac, calc_thaco, dam, diceroll, weapon_position;
  struct obj_data *weapon;
  int thac0_01 = 25;
  int thac0_00 = classes[(int)GET_CLASS(ch)].thac0;
  bool no_defense_check = FALSE;
  int dtype, imptype;

  if (event_target_valid(victim) == 0) {
    if (ch)
      stop_fighting (ch);
    return;
  }

  if (event_target_valid(ch) == 0) {
    stop_fighting (victim);
    return;
  }

  if (ch == victim) {
    stop_fighting(ch);
    return;
  }

  /* check if the character has a fight trigger */
  fight_mtrigger(ch);

  /* Do some sanity checking, in case someone flees, etc. */
  if (IN_ROOM(ch) != IN_ROOM(victim)) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
d1630 5
a1634 2
    return;
  }
d1636 181
a1816 9
  /* Check for PK, pets, shapechanged...etc. */
  if (!attack_ok(ch, victim, TRUE)) {
    if (FIGHTING(ch)) {
      if (FIGHTING(victim) == ch)
        stop_fighting(victim);
      stop_fighting(ch);
    }
    return;
  }
d1818 17
a1834 181
  if (FIGHTING(ch) != victim && EFF_FLAGGED(ch, EFF_BLIND)) {
    send_to_char("You cant see a thing!\r\n", ch);
    return;
  }

  aggro_lose_spells(ch);

  /*
   * This is a hack.  TYPE_UNDEFINED signifies to hit() that
   * we should figure out the damage type based on weapons
   * or barehand.  SKILL_RIPOSTE extends that but signifies
   * that this attack cannot be riposted back (or parried or
   * dodged).  SKILL_DUAL_WIELD signifies that the secondary
   * hand should be used.
   */

  /* Figure out which weapon we want. */
  weapon_position = -1;
  if (type == SKILL_DUAL_WIELD || type == SKILL_2BACK) {
    if (GET_EQ(ch, WEAR_WIELD2) &&
        GET_OBJ_TYPE(GET_EQ(ch, WEAR_WIELD2)) == ITEM_WEAPON)
      weapon_position = WEAR_WIELD2;
  }
  else if (GET_EQ(ch, WEAR_WIELD) &&
           GET_OBJ_TYPE(GET_EQ(ch, WEAR_WIELD)) == ITEM_WEAPON)
    weapon_position = WEAR_WIELD;
  else if (GET_EQ(ch, WEAR_2HWIELD) &&
           GET_OBJ_TYPE(GET_EQ(ch, WEAR_2HWIELD)) == ITEM_WEAPON)
    weapon_position = WEAR_2HWIELD;

  weapon = weapon_position >= 0 ? GET_EQ(ch, weapon_position) : NULL;

  /* If riposting, don't allow a defensive skill check. */
  if (type == SKILL_RIPOSTE)
    no_defense_check = TRUE;

  /* Save the initial skill type so it can be improved */
  imptype = type;

  /* Figure out what kind of damage we're doing. */
  if (type == TYPE_UNDEFINED || type == SKILL_RIPOSTE ||
      type == SKILL_DUAL_WIELD || !type) {
    if (weapon)
      type = GET_OBJ_VAL(weapon, 3) + TYPE_HIT;
    else if (GET_SKILL(ch, SKILL_BAREHAND))
      type = SKILL_BAREHAND;
    else if (IS_NPC(ch) && ch->mob_specials.attack_type != 0)
      type = ch->mob_specials.attack_type + TYPE_HIT;
    else
      type = TYPE_HIT;
  }
  dtype = skill_to_dtype(type);

  /* Common (fleshy) folks will do crushing damage when not wielding a
   * weapon.  That's how fists work.  But other folks, like for example
   * fire elementals, would do other kinds of damage... like fire. */

  if (!weapon && COMPOSITION_DAM(ch) != DAM_PIERCE &&
        COMPOSITION_DAM(ch) != DAM_SLASH &&
        COMPOSITION_DAM(ch) != DAM_CRUSH) {
     dtype = COMPOSITION_DAM(ch);
  }

  /* Time to see whether it's a hit or a miss */

    /* VALUES: 240 to -50 */
  calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00) * 10;
    /* VALUES: -50 to 70 */
  calc_thaco -= str_app[GET_STR(ch)].tohit * 10;
    /* VALUES: 0 to 40   (max hitroll is 40) */
  calc_thaco -= GET_HITROLL(ch);
    /* VALUES: 0 to 40 */
  calc_thaco -= (4 * GET_INT(ch)) / 10;        /* Int helps! */
    /* VALUES: 0 to 40 */
  calc_thaco -= (4 * GET_WIS(ch)) / 10;        /* So does wis */
    /* calc_thaco ranges from 290 to -240 */

  diceroll = number(1, 200);

    /* VALUES: 100 to -100 */
  victim_ac = GET_AC(victim);
    /* VALUES: 60 to -60 */
  victim_ac += dex_app[GET_DEX (victim)].defensive * 10;
  victim_ac = MAX(-100, victim_ac);        /* -100 is lowest */
    /* victim_ac ranges from 160 to -100 */

  /*
   *   Victim asleep = hit, otherwise:
   *    1..10     = Automatic miss
   *    11..190   = Checked vs. AC
   *    191..200  = Automatic hit
   */
  if (diceroll > 190 || !AWAKE(victim))
    dam = TRUE;
  else if (diceroll < 11)
    dam = FALSE;
  else
    dam = (calc_thaco - diceroll <= victim_ac);

  /* See if the victim evades damage due to non-susceptibility
   * (this applies when asleep, too!)
   */
  if (damage_evasion(victim, ch, weapon, dtype)) {
     damage_evasion_message(ch, victim, weapon, dtype);
     return;
  }

  /* The attacker missed the victim. */
  if (!dam) {
    damage(ch, victim, 0, type);
    if (weapon && diceroll == 1)
      sling_weapon(ch, weapon_position);
  }

  /*
   * Some skills don't get a chance for riposte, parry, and dodge,
   * so short-circuit those function calls here.
   */
  else if (type == SKILL_BACKSTAB ||
           type == SKILL_2BACK ||
           type == SKILL_BAREHAND ||
           no_defense_check ||
           (!riposte(ch, victim) &&
            !parry(ch, victim) &&
            !dodge(ch, victim) &&
            (!weapon || !weapon_special(weapon, ch)))) {
    /*
     * Okay, we know the guy has been hit.  Now calculate damage,
     * starting with the damage bonuses: damroll and strength apply.
     */
    dam = str_app[GET_STR(ch)].todam;
    dam += GET_DAMROLL(ch);

    if (diceroll == 20)
      dam += dam;

    /* Mob barehand damage is always applied */
    if (IS_NPC(ch))
      dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
    /* Apply weapon damage if there is one */
    if (weapon)
      dam += dice(GET_OBJ_VAL(weapon, 1), GET_OBJ_VAL(weapon, 2));
    /* Apply player barehand damage if no weapon*/
    else if (!IS_NPC(ch))
      dam += number(0, 2); /* Yeah, you better wield a weapon. */

    /*
     * Include a damage multiplier if the victim isn't ready to fight.
     * alert    x 1.33
     * resting  x 1.66
     * sleeping x 2.00
     * stunned  x 2.33
     * incap    x 2.66
     * mortally x 3.00
     * Note, this is a hack because it depends on the particular
     * values of the STANCE_XXX constants.
     */
    if (GET_STANCE(victim) < STANCE_FIGHTING)
      dam *= 1 + (STANCE_FIGHTING - GET_STANCE(victim)) / 3;

    dam = MAX(1, dam);        /* at least 1 hp damage min per hit */

    if (type == SKILL_BACKSTAB || type == SKILL_2BACK)
      dam *= GET_SKILL(ch, SKILL_BACKSTAB) / 10 + 1;

    else if (type == SKILL_BAREHAND)
      dam += GET_SKILL(ch, SKILL_BAREHAND) / 4 +
             number(1, GET_SKILL(ch, SKILL_BAREHAND) / 2);

    else {
      /* Spirit of the bear increases the damage you do by up to 10%. */
      if (EFF_FLAGGED(ch, EFF_SPIRIT_BEAR))
        dam *= 1.0 + GET_LEVEL(ch) / 1000.0;

      /* Berserk increases damage done and taken by 10%. */
      if (EFF_FLAGGED(victim, EFF_BERSERK) || EFF_FLAGGED(ch, EFF_BERSERK))
        dam *= 1.1;

      if (EFF_FLAGGED(victim, EFF_STONE_SKIN) && number(0, 10) <= 9) {
        decrease_modifier(victim);
        dam = number(0, 3);
a1835 1
    }
d1837 2
a1838 2
    if (type == TYPE_HIT && !dam)
      type = SKILL_PUNCH;
d1840 13
a1852 13
    /* Adjust damage for susceptibility */
    if (!(GET_COMPOSITION(victim) == COMP_ETHER && blessed_blow(ch, weapon)))
      dam = dam * susceptibility(victim, dtype) / 100;

    /* Do the damage */
    damage(ch, victim, dam, type);

    /* Do after the damage() so we don't send the wrong type. */
    if (ALIVE(ch) && weapon && !number(0, 9) &&
        (type = weapon_proficiency(weapon, weapon_position)) != -1) {
      improve_skill_offensively(ch, victim, type);
    }
  }
d1854 8
a1861 8
   /* imptype holds a skill like dual wield, if that's what
    * type used to be*/
   if (imptype != type && imptype != TYPE_UNDEFINED)
     improve_skill_offensively(ch, victim, imptype);

  /* check if the victim has a hitprcnt trigger */
  if (victim)
    hitprcnt_mtrigger(victim);
d1867 2
a1868 2
  int skill, proficiency, dir, temp, room, valid_dirs[NUM_OF_DIRS];
  struct obj_data *weapon = GET_EQ(ch, position);
d1870 54
a1923 53
  /* Find the appropriate skill to make the check */
  if ((skill = weapon_proficiency(weapon, position)) != -1)
    proficiency = GET_SKILL(ch, skill);
  /* Misc types of weapons get an average of all the scores */
  else if (position == WEAR_2HWIELD)
    proficiency = (GET_SKILL(ch, SKILL_2H_SLASHING) +
                   GET_SKILL(ch, SKILL_2H_BLUDGEONING) +
                   GET_SKILL(ch, SKILL_2H_PIERCING)) / 3;
  else
    proficiency = (GET_SKILL(ch, SKILL_SLASHING) +
                   GET_SKILL(ch, SKILL_BLUDGEONING) +
                   GET_SKILL(ch, SKILL_PIERCING)) / 3;

  /* Improve the skill if it's not a misc weapon */
  if (skill != -1)
    improve_skill(ch, skill);

  /* Make a dex check first */
  if (number(1, 81) < GET_DEX(ch))
    return FALSE;

  /* Check against weapon skill to see if it was slung */
  if (number(1, 81) < proficiency)
    return FALSE;

  /* remove the weapon */
  unequip_char(ch, position);

  /*
   * If it was wielded in the primary hand, and there was also something
   * wielded in the secondary hand, move it to the primary hand.
   */
  if (position == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD2))
    equip_char(ch, unequip_char(ch, WEAR_WIELD2), WEAR_WIELD);

  if (IS_OBJ_STAT(weapon, ITEM_NODROP)) {
    /* Weapon is cursed, so it remains in the inventory of the PC/NPC */
    act("&3&bYou lose your grip on your&0 $o&3&b, and it magically returns to your&0 &B&3inventory!&0", FALSE, ch, weapon, NULL, TO_CHAR);
    act("$n &3&bloses $s grip on $s&0 $o&3&b, and it magically returns to $s&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_ROOM);
    obj_to_char(weapon, ch);
  }
  else {
    room = ch->in_room;

    /* 1 in 5 chance to sling the weapon into the next room */
    if (!number(0, 4)) {
      /* Find a valid direction to sling it. */
      for (dir = temp = 0; dir < NUM_OF_DIRS; ++dir)
        if (CAN_GO(ch, dir))
          valid_dirs[temp++] = dir;
      if (temp > 0) {
        dir = valid_dirs[number(0, temp - 1)];
        room = CH_NDEST(ch, dir);
a1924 1
    }
d1926 20
a1945 20
    /* Display messages for slinging into the same room. */
    if (room == ch->in_room) {
      act("&3&bYou lose your grip on your&0 $o &3&band send it&0 &B&3flying!&0",
          FALSE, ch, weapon, NULL, TO_CHAR);
      act("$n &3&bloses $s grip on $s&0 $o &3&band sends it&0 &B&3flying!&0",
          TRUE, ch, weapon, NULL, TO_ROOM);
    }
    /* Display messages for slinging into another room. */
    else {
      act("&3&bWith a mighty&0 &B&3HEAVE&0 &3&byou sling your&0 $o &3&bout of reach $Twards!&0",
          TRUE, ch, weapon, dirs[dir], TO_CHAR);
      act("&3&bWith a mighty&0 &B&3HEAVE&0 $n &3&bslings $s&0 $o &3&bout of reach $Twards!&0",
          TRUE, ch, weapon, dirs[dir], TO_ROOM);

      sprintf(buf, "A $o is slung violently in from %s%s.",
          rev_dir[dir] == UP ? "" : rev_dir[dir] == DOWN ? "" : "the ",
          rev_dir[dir] == UP ? "above" : rev_dir[dir] == DOWN ? "below" : dirs[rev_dir[dir]]);
      act(buf, TRUE, world[room].people, weapon, NULL, TO_CHAR);
      act(buf, TRUE, world[room].people, weapon, NULL, TO_ROOM);
    }
d1947 3
a1949 3
    /* Place the weapon in the room */
    obj_to_room(weapon, room);
  }
d1951 1
a1951 1
  WAIT_STATE(ch, 2 * PULSE_VIOLENCE);  /* lag the poor bastard */
d1953 1
a1953 1
  return TRUE;
d1959 1
a1959 1
  int w_type;
d1961 1
a1961 1
  w_type = GET_OBJ_VAL(weapon, 3) + TYPE_HIT;
d1963 32
a1994 32
  switch(w_type) {
  /* These are generic type weapons.*/
  case TYPE_HIT:
  case TYPE_BITE:
  case TYPE_THRASH:
  case TYPE_PUNCH:
  case TYPE_BLAST:
    return -1;

  /* These are slashing weapons. */
  case TYPE_WHIP:
  case TYPE_SLASH:
  case TYPE_CLAW:
    return position == WEAR_2HWIELD ? SKILL_2H_SLASHING : SKILL_SLASHING;

  /* These are bludgeoning weapons. */
  case TYPE_BLUDGEON:
  case TYPE_CRUSH:
  case TYPE_POUND:
  case TYPE_MAUL:
    return position == WEAR_2HWIELD ? SKILL_2H_BLUDGEONING : SKILL_BLUDGEONING;

  /* These are piercing weapons. */
  case TYPE_STING:
  case TYPE_PIERCE:
  case TYPE_STAB:
    return position == WEAR_2HWIELD ? SKILL_2H_PIERCING : SKILL_PIERCING;

  default:
    log("SYSERR:fight.c:weapon_proficiency: Unknown weapon type");
    return -1;
  }
d2001 2
a2002 2
/* control the fights going on.  Called every 2 seconds from comm.c. */
void perform_violence (void)
d2004 2
a2005 2
  struct char_data *ch, *newvict;
  int hits, secondary_hits = 0;
d2007 2
a2008 2
  struct char_data *random_attack_target(struct char_data *ch,
              struct char_data *target, bool verbose);
d2010 9
a2018 9
  for (ch = combat_list; ch; ch = next_combat_list) {
    next_combat_list = ch->next_fighting;

    if (FIGHTING(ch) == NULL || DECEASED(FIGHTING(ch)) ||
        ch->in_room != FIGHTING(ch)->in_room ||
        EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS)) {
      stop_fighting (ch);
      continue;
    }
d2021 13
a2033 11
    if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      send_to_char("You remain paralyzed and can't do a thing to defend yourself..\r\n", ch);
      act("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
          FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
      continue;
    }
    if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS)) {
      act ("You couldn't budge a feather in your present condition.", FALSE, ch, 0, 0, TO_CHAR);
      act ("$n is too preoccupied with $s nervous system problem to fight.", FALSE, ch, 0, 0, TO_ROOM);
      continue;
    }
d2036 2
a2037 2
    if (check_disarmed(ch))
      continue;
d2039 2
a2040 2
    if (CASTING(ch))
      continue;
d2042 4
a2045 4
    if (GET_POS(ch) < POS_STANDING) {
      send_to_char("You can't fight while sitting!!\r\n", ch);
      continue;
    }
d2047 2
a2048 2
    if (GET_SKILL(ch, SKILL_BERSERK))
      GET_RAGE(ch) += 10 + number(0, GET_SKILL(ch, SKILL_BERSERK) / 10);
d2050 2
a2051 16
    /* Everybody gets at least one hit */
    hits = 1;
    if (GET_SKILL(ch, SKILL_DOUBLE_ATTACK) &&
        GET_SKILL(ch, SKILL_DOUBLE_ATTACK) >= number(1, 101))
      hits *= 2;
    if (EFF_FLAGGED(ch, EFF_HASTE))
      hits += 1;
    if (EFF_FLAGGED(ch, EFF_BLUR))
      hits += 1;
    if (EFF_FLAGGED(ch, EFF_SPIRIT_WOLF) &&
        GET_LEVEL(ch) > number(0, 100))
      hits += 1;

    if (GET_EQ(ch, WEAR_WIELD2) && GET_SKILL(ch, SKILL_DUAL_WIELD) &&
        GET_SKILL(ch, SKILL_DUAL_WIELD) >= number(1, 101)) {
      secondary_hits = 1;
d2053 4
a2056 2
          GET_SKILL(ch, SKILL_DOUBLE_ATTACK) >= number(1, 101))
        secondary_hits *= 2;
d2058 35
a2092 2
        secondary_hits += 2;
    }
d2094 6
a2099 18
    /* Chance for NPCs to switch. */
    if (IS_NPC(ch) && GET_SKILL(ch, SKILL_SWITCH) &&
        !EFF_FLAGGED(ch, EFF_BLIND) &&
        !number(0, MAX(10, 30 - GET_LEVEL(ch)))) {
      struct char_data *victim = NULL, *tch;

      /* Find the player fighting this NPC who has the lowest hp in the room */
      for (tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
        if (FIGHTING(tch) == ch && !IS_NPC(tch) && CAN_SEE(ch, tch))
          if (victim == NULL || GET_HIT(tch) < GET_HIT(victim))
            victim = tch;

      if (victim && FIGHTING(ch) != victim) {
        act("$n switches to $N!", FALSE, ch, 0, victim, TO_NOTVICT);
        act("$n switches to YOU!", FALSE, ch, 0, 0, TO_VICT);
        FIGHTING(ch) = victim;
        hits = 1;
        secondary_hits = 0;
a2100 1
    }
d2102 11
a2112 7
    /* If you're confused, you may spontaneously switch.  But only once per
     * round, not once per hit. */
    if (CONFUSED(ch) && number(0, 3) == 0) {
       newvict = random_attack_target(ch, FIGHTING(ch), TRUE);
       if (newvict != FIGHTING(ch))
          FIGHTING(ch) = newvict;
    }
d2114 4
a2117 16
    do {
      if (hits) {
        hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
        --hits;
      }
      if (FIGHTING(ch) && ALIVE(ch) && secondary_hits) {
        hit(ch, FIGHTING(ch), SKILL_DUAL_WIELD);
        --secondary_hits;
      }
    } while ((hits > 0 || secondary_hits > 0) &&
             FIGHTING(ch) && ALIVE(ch));

    if (ALIVE(ch) && MOB_FLAGGED (ch, MOB_SPEC) &&
        mob_index[GET_MOB_RNUM(ch)].func != NULL)
      (mob_index[GET_MOB_RNUM(ch)].func)(ch, ch, 0, "");
  }
a2120 126
#define NUM_OF_FUN_PARTS 13        /* the following is some sicko's code
                                   named Patrick J. Dughi, I changed it a great deal
                                   to fit Hubis' theme. */

struct fun_body_piece
{
  int number;                        /* this parts number */
  char name[40];                /* names of this part */
  int nname;                        /* some parts you couldn't trace to an owner */
  char sdesc[128];                /* short desc: that of inventory  */
  char rdesc[128];                /* room desc: when on ground */
  int take;                        /* some body parts don't transfer well */
  char actout[128];                /* what people in room see upon death, using
                                   act() */
  char actkil[128];                /* what the killer sees upon dismemberment, using
                                   act() */
};

struct fun_body_piece parts[NUM_OF_FUN_PARTS] =
{
  {0, "eyeball eye", 1, "the eye of %s", "The eyeball of %s is lying here.",
   1, "$n's attack knocks an eye out of $N!",
   "Your attack knocks an eye out of $N!"},
  {1, "arm", 1, "one of %s's arms", "%s'arm is lying here on the ground.",
   1, "$n's removes $N's arm!",
   "You remove $N's arm!"},
  {2, "right leg", 1, "%s's right leg", "%s's right leg is here.",
   1, "$N gracefully cuts his leg off! $n chortles merrily!",
   "You watch in awe as $N cuts his leg off!"},
  {3, "left leg", 1, "the left leg of %s", "The left leg of %s is lying here.",
   1, "$n's screams and strikes $N leg off at the hip!",
   "With a scream of rage, you strike $N's leg off!"},
  {4, "head", 1, "%s's ugly head", "%s's head is lying here, staring at you.",
   1, "$n severs $N's in a move composed of speed and grace!",
   "With speed and grace, you sever $N's head!"},
  {5, "thumb", 1, "%s's thumb", "One of %s's thumbs is lying here.",
   1, "$n's attack severs a thumb from $N!",
   "Your attack severs a thumb from $N!"},
  {6, "finger", 1, "%s's finger", "One of %s fingers is lying here.",
   1, "$n's attack severs a finger from $N!",
   "Your attack severs a finger from $N!"},
  {7, "heart", 1, "the once beating heart of %s",
   "%s's once beating heart lies here.",
   1, "$n's uses pure strength to eviscirate $N!",
   "Your depend on your fierce strength, and eviscerate $N!"},
  {8, "spine", 1, "the spine of %s", "The spine of %s is lying here.",
   1, "$n's attack shatters $N's spine!",
   "Your attack shatters $N's spine!"},
  {9, "intestine", 0, "An icky pile of intestines",
   "An icky pile of intestines is here - colon and all.",
   0, "$n hits so hard, that $N pukes up his intestines !",
   "You hit $N so hard that he pukes up his intestines!"},
  {10, "puke vomit", 0, "chunky vomit", "Some one upchucked on the floor here.",
   0, "$N throws up all over!",
   "$N throws up all over you!"},
  {11, "nose", 1, "%s's nose", "%s lost his nose here.",
   1, "$n cackles gleefuly as he removes $N's nose!",
   "You cackle as you sever $N's nose!"},
  {12, "ear", 1, "%s's ear", "%'s bloody severed ear is here.",
   1, "$n's grabs $N's ear and rips it off!",
   "Your rip off $N's ear!"}
};

void make_fun_body_pieces (struct char_data *ch, struct char_data *killer)
{
  struct obj_data *piece;
  int i;
  extern int max_npc_corpse_time;

  /*lets check and see if we even GET body parts eh - i mean, they're
    fun, but it wouldn't be quite as fun if they were always there! */

  if (number (1, 5) < 4)
    return;

  /*Then Horray! We's got parts! */
  /* But which part? */
  i = number (0, 20);                /* 20 pieces should be okay */
  piece = create_obj ();

  /*now, everything we have should be in the structures neh? */
  /*name first */
  piece->name = strdup (parts[i].name);
  /*then lets see about the descs */
  if (parts[i].nname)
    {
      sprintf (buf2, parts[i].sdesc, GET_NAME (ch));
      piece->short_description = strdup (buf2);
      sprintf (buf2, parts[i].rdesc, GET_NAME (ch));
      piece->description = strdup (buf2);
    }
  else
    {
      piece->short_description = strdup (parts[i].sdesc);
      piece->description = strdup (parts[i].rdesc);
    }
  /*well, now we know how it looks, lets see if we wanna take it. */
  if (parts[i].take)
    {
      GET_OBJ_WEAR (piece) = ITEM_WEAR_TAKE;
    }
  /*  and lets see how it got here in the first place neh? */
  act (parts[i].actout, FALSE, killer, 0, ch, TO_ROOM);
  act (parts[i].actkil, FALSE, killer, 0, ch, TO_CHAR);

  /* setup the rest of the stats any object needs */
  piece->item_number = NOTHING;
  piece->in_room = NOWHERE;
  GET_OBJ_TYPE (piece) = ITEM_CONTAINER;
  GET_OBJ_VAL (piece, 0) = 0;        /* You can't store stuff in a corpse */
  GET_OBJ_VAL (piece, 3) = 1;        /* corpse identifier */
  GET_OBJ_EXTRA (piece) = (ITEM_NODONATE | ITEM_FLOAT | ITEM_TRANSIENT);
  GET_OBJ_WEIGHT (piece) = 1;
  GET_OBJ_RENT (piece) = 1;

  /* Note - you may have some trouble with corpse decay here -
     improper settings WILL cause the mud to crash if you do not correcly
     decay.  Right now, the pieces are setup as a corpse, so if you made any
     changes to your corpse identifiers, fix it above. */

  GET_OBJ_TIMER (piece) = max_npc_corpse_time;

  /* and thats all folks! */
  obj_to_room (piece, ch->in_room);
}

d2123 2
a2124 2
  struct obj_data *obj;
  char arg[MAX_INPUT_LENGTH];
d2126 2
a2127 2
  ACMD (do_wield);
  int cmd_wield;
d2129 1
a2129 1
  cmd_wield = find_command ("wield");
d2131 4
a2134 4
  for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj->next_content) {
    if (IS_OBJ_STAT(obj, ITEM_WAS_DISARMED) && obj->last_to_hold == ch) {
      obj_from_room(obj);
      obj_to_char(obj, ch);
d2136 4
a2139 4
      if (FIGHTING(ch))
        act("$n finally gets a steady grip on $p.", FALSE, ch, obj, 0, TO_ROOM);
      else
        act("$n eagerly reaches for $p.", FALSE, ch, obj, 0, TO_ROOM);
d2141 1
a2141 1
      REMOVE_BIT(GET_OBJ_EXTRA(obj), ITEM_WAS_DISARMED);
d2143 5
a2147 5
      strncpy(arg, obj->name, sizeof(arg) - 1);
      do_wield(ch, arg, 0, 0);
      return;
    }
  }
d2152 15
a2166 15
 *  1) MOBs/PCs to have their penalties removed upon recovery from a fumble.
 *     If they're fighting no one (ie. vict fleed), they recover immediately.
 *  2) MOBs to pick up and re-wield both weapons when their ACT_DELAY_DROPPED_WEAP action_delay[] expires.
 *
 *  PCs don't need automatic weapon recovery, as they can manually do it.
 *
 *  This function is called from perform_violence(), and thus is only called
 *  when the character has valid disarm cooldowns and is combat.  Since disarm
 *  can't be used until after combat has been initiated, and the affects 
 *  it produces are really only useful while in combat, when the affected
 *  char's assailant has fled the room, it'll be perfectly fine to just 
 *  clear all EFFECT-flags and clear all action_delays[] associated with
 *  'disarm'.  This includes when a weapon is dislodged and laying on the
 *  ground--the disarmed MOB will immediately pick it up, and the disarmed
 *  PC may immediately pick his/hers up.
d2168 1
a2168 1
 *  Note: MOB/PCs can NOT be both FUMBLING_WEAP and DROPPED_WEAP for same weap.
d2170 1
a2170 1
 *  Return FALSE if the PC/MOB can attack.  Otherwise, return TRUE.
d2174 28
a2201 28
  /* if not fumbling nor regaining dropped weap, let em strike back */
  if (!GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) &&
      !GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY) &&
      !GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) &&
      !GET_COOLDOWN(ch, CD_DROPPED_SECONDARY))
    return FALSE;

  /* if PC/MOB isn't fighting anyone anymore (vict fleed), remove
     all affect-flags and pick up all dropped weapons */
  if (!FIGHTING(ch)) {
    if (GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) ||
        GET_COOLDOWN(ch, CD_DROPPED_SECONDARY))
      pickup_dropped_weapon(ch);
    GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) = 0;
    GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY) = 0;
    GET_COOLDOWN(ch, CD_DROPPED_PRIMARY) = 0;
    GET_COOLDOWN(ch, CD_DROPPED_SECONDARY) = 0;    
    return FALSE;
  }
  else {
    if (GET_COOLDOWN(ch, CD_FUMBLING_PRIMARY) ||
        GET_COOLDOWN(ch, CD_FUMBLING_SECONDARY)) {
      act("$n is trying to get a steady grip on $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You can't seem to get a steady grip on your weapon.\r\n", ch);
    }
    else if (IS_NPC(ch))
      act("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
  }
d2203 1
a2203 1
  return TRUE;
d2206 1
a2206 1
void StopMercifulAttackers (struct char_data *ch)
d2223 2
a2224 2
  if (!ch || !tch || ch == tch || !AWAKE(ch))
    return FALSE;
d2226 2
a2227 2
  if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) || EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
    return FALSE;
d2229 2
a2230 8
  if (!CAN_SEE(ch, tch) || PRF_FLAGGED(tch, PRF_NOHASSLE) || EFF_FLAGGED(tch, EFF_FAMILIARITY))
    return FALSE;

  if (is_grouped(ch, tch))
    return FALSE;

  if (!attack_ok(ch, tch, FALSE))
    return FALSE;
d2232 1
a2232 2
  if (IS_NPC(ch)) {
    if (IS_NPC(tch) && !MOB_FLAGGED(tch, MOB_PLAYER_PHANTASM))
d2235 1
a2235 1
    if (MOB_FLAGGED(ch, MOB_WIMPY) && AWAKE(tch))
d2238 23
a2260 16
    /* Now if the mob is marked any kind of aggro that matches the
       target, attack! */
    if (MOB_FLAGGED(ch, MOB_AGGRESSIVE))
      return TRUE;
    if (MOB_FLAGGED(ch, MOB_AGGR_GOOD_RACE) &&
        GET_RACE_ALIGN(tch) == RACE_ALIGN_GOOD)
      return TRUE;
    if (MOB_FLAGGED(ch, MOB_AGGR_EVIL_RACE) &&
        GET_RACE_ALIGN(tch) == RACE_ALIGN_EVIL)
      return TRUE;
    if (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(tch))
      return TRUE;
    if (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(tch))
      return TRUE;
    if (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(tch))
      return TRUE;
d2262 9
a2270 9
    /* If target is in memory, then it acts as if it's aggro, even if it's not. */
    if (MOB_FLAGGED(ch, MOB_MEMORY) && in_memory(ch, tch))
      return TRUE;
  }
  /* Otherwise is a player */
  else {
    /* Berserkers are aggressive. */
    if (IS_NPC(tch) && EFF_FLAGGED(ch, EFF_BERSERK))
      return TRUE;
d2272 10
a2281 4
    if (GET_WIMP_LEV(ch) >= GET_HIT(ch))
      return FALSE;
    if (GET_AGGR_LEV(ch) <= 0 || GET_AGGR_LEV(ch) > GET_HIT(ch))
      return FALSE;
d2283 7
a2289 5
    /* If not vicious, be merciful to sleeping/paralyzed mobs */
    if (!PRF_FLAGGED(ch, PRF_VICIOUS) && (!AWAKE(tch) ||
        EFF_FLAGGED(tch, EFF_MINOR_PARALYSIS) ||
        EFF_FLAGGED(tch, EFF_MAJOR_PARALYSIS)))
      return FALSE;
d2291 1
a2291 9
    /*
     * The target must be an NPC or else you'll end up with an infinite
     * recursion situation.  Can you say segfault?
     */
    if (IS_NPC(tch) && is_aggr_to(tch, ch))
      return TRUE;
  }

  return FALSE;
d2296 1
a2296 1
  int val;
d2298 2
a2299 2
  if (!IS_NPC(ch))
    return -1;
d2301 1
a2301 1
  val = GET_HIT(vict);
d2303 37
a2339 11
  if (IS_CLERIC(vict) || IS_MAGIC_USER(vict))
    val *= 2 / 3;
  else if (IS_WARRIOR(vict))
    val *= 2;
  if (!FIGHTING(vict))
    val /= (IS_ROGUE(ch) ? 4 : 2);
  if (EFF_FLAGGED(vict, EFF_AWARE) && IS_ROGUE(ch))
    val *= 1.5;
  if (GET_LEVEL(vict) < 60)
    val /= number(40 + GET_LEVEL(vict), 160 - GET_LEVEL(vict));
  return val;
d2342 11
d2354 1
a2354 15
#define MAX_TARGETS 20
struct char_data *find_aggr_target(struct char_data *ch) {
  struct char_data *tch;
  struct aggr_target {
    struct char_data *target;
    int difficulty;
  } targets[MAX_TARGETS + 1];
  int i, j, k;

  if (!ch || ch->in_room == NOWHERE)
    return NULL;

  /* If is a player, no need to find a target if not aggro */
  if (!IS_NPC(ch) && !EFF_FLAGGED(ch, EFF_BERSERK)) {
    if (GET_WIMP_LEV(ch) >= GET_HIT(ch))
d2356 13
a2368 1
    if (GET_AGGR_LEV(ch) <= 0 || GET_AGGR_LEV(ch) > GET_HIT(ch))
a2369 1
  }
d2371 34
a2404 13
  if (PLR_FLAGGED(ch, PLR_BOUND) || !AWAKE(ch) ||
      EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) ||
      EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS))
    return NULL;

  i = 0;
  for (tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
    if (is_aggr_to(ch, tch)) {
      targets[i].target = tch;
      targets[i].difficulty = appraise_opponent(ch, tch);
      if (++i >= MAX_TARGETS)
        break;
    }
d2406 6
a2411 2
  if (i == 0)
    return NULL;
d2413 1
a2413 2
  if (!IS_NPC(ch) || MOB_FLAGGED(ch, MOB_PLAYER_PHANTASM))
    return targets[number(0, i - 1)].target;
d2415 13
a2427 5
  k = i;
  targets[k].difficulty = 100000000; /* Arbitrarily large number */
  for (j = 0; j < i; ++j)
    if (targets[j].difficulty < targets[k].difficulty)
      k = j;
d2429 3
a2431 3
  /* No potential targets in the room? */
  if (k == i || k >= MAX_TARGETS)
    return NULL;
d2433 1
a2433 1
  return targets[k].target;
d2436 11
a2446 4
EVENTFUNC(quick_aggro_event) {
  struct generic_event_data *data = (struct generic_event_data *) event_obj;
  struct char_data *ch = data->ch;
  struct char_data *vict = data->vict;
d2448 1
a2448 2
  if (ch && !FIGHTING(ch) && vict && IN_ROOM(ch) == IN_ROOM(vict))
    attack(ch, vict);
d2450 11
a2460 2
  return EVENT_FINISHED;
}
d2462 1
d2464 8
a2471 18
/*This is command to sets pc's aggressive state. When set the pc will
  attack aggressive monsters. Depending on thier current hitpoints
  Banyal */
ACMD (do_aggr)
{
  int hp;

  if (IS_NPC(ch)) {
    send_to_char("NPCs can't set their aggressiveness!\r\n", ch);
    return;
  }

  one_argument(argument, buf);

  /* No argument?  Check aggressiveness. */
  if (!*buf) {
    if (GET_AGGR_LEV(ch) <= 0) {
      send_to_char("You are not aggressive to monsters.\r\n", ch);
d2473 1
a2473 19
    }
    sprintf(buf, "You will be aggressive unless your hitpoints drop below %d.\r\n",
            GET_AGGR_LEV(ch));
    send_to_char(buf, ch);
    return;
  }

  hp = atoi(buf);

  if (str_cmp(buf, "off") == 0 || (!hp && *buf == '0') ) {
    GET_AGGR_LEV(ch) = 0;
    send_to_char("You are no longer aggressive to monsters.\r\n", ch);
    return;
  }

  if (hp < 0) {
    send_to_char("Aggressive while dying?  Not likely!\r\n", ch);
    return;
  }
d2475 2
a2476 2
  GET_AGGR_LEV(ch) = hp;
  do_aggr(ch, "", 0, 0); /* show aggr status message. */
d2488 3
@


1.211
log
@Renaming room_data struct's member "number" to "vnum", cos it's
a virtual number.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.210 2008/05/17 22:03:01 jps Exp jps $
d2391 1
a2391 1
  if (!CAN_SEE(ch, tch) || PRF_FLAGGED(tch, PRF_NOHASSLE))
d2596 4
@


1.210
log
@Moving room-related code into rooms.h and rooms.c.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.209 2008/05/17 04:32:25 jps Exp jps $
d506 1
a506 1
    ccontrol_make_corpse(world[ch->in_room].number, corpse);
d729 1
a729 1
               world[ch->in_room].number);
d732 1
a732 1
               world[ch->in_room].name, world[ch->in_room].number);
d1234 1
a1234 1
          world[victim->in_room].number);
d2596 3
@


1.209
log
@Moved exits into exits.h/exits.c and changed the name to "exit".
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.208 2008/05/14 05:11:51 jps Exp jps $
d1960 1
a1960 1
        room = EXIT(ch, dir)->to_room;
d2596 3
@


1.208
log
@Using hurt_char for play-time harm, while alter_hit is for changing hp only.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.207 2008/05/12 01:10:57 jps Exp jps $
d39 1
d565 1
a565 1
        !ROOM_FLAGGED(world[was_in].dir_option[door]->to_room, ROOM_OBSERVATORY)) &&
d567 2
a568 2
        !ROOM_FLAGGED(world[was_in].dir_option[door]->to_room, ROOM_ARENA))) {
      ch->in_room = world[was_in].dir_option[door]->to_room;
d593 2
a594 2
            ROOM_FLAGGED(world[IN_ROOM(ch)].dir_option[door]->to_room, ROOM_OBSERVATORY)) {
         destination = world[IN_ROOM(ch)].dir_option[door]->to_room;
d2596 3
@


1.207
log
@Return the flee-checking code to damage().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.206 2008/05/12 00:42:30 jps Exp jps $
d585 1
a585 1
      alter_hit(ch, NULL, -(abs(GET_HIT(ch)) + 5), TRUE);
d1251 1
a1251 1
    alter_hit(victim, ch, dam, TRUE);
d1376 1
a1376 1
            alter_hit(ch, NULL, -dam, FALSE);
d1379 1
a1379 1
            alter_hit(ch,  NULL, -dam / 2, TRUE);
d1426 1
a1426 1
       alter_hit(ch, victim, shdam, TRUE);
d1431 1
a1431 1
    alter_hit(victim, ch, dam, TRUE);
d2595 3
@


1.206
log
@Pass "death" to skill_message since it wouldn't otherwise know
whether the victim died due to the attack.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.205 2008/05/11 22:31:58 jps Exp jps $
d1448 1
a1449 1

d1467 13
d2595 4
@


1.205
log
@Don't remove xp from dying mobs - you still need it for disbursement
to the player who killed it.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.204 2008/05/11 06:14:05 jps Exp jps $
d1161 1
a1161 1
               int attacktype)
d1194 1
a1194 1
            if (DECEASED(vict))
d1253 1
a1253 1
    if (!skill_message(dam, ch, victim, attacktype)) {
d1406 1
a1406 1
      skill_message(dam, ch, victim, attacktype);
d1411 1
a1411 1
    skill_message(dam, ch, victim, attacktype);
d1414 1
a1414 1
      if (!skill_message(dam, ch, victim, attacktype))
d2582 4
@


1.204
log
@Calculations and messages about defensive spells lie fireshield
are now handled in magic.c.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.203 2008/05/11 05:57:56 jps Exp jps $
d744 4
a747 1
   gain_exp(ch, NULL, -exp_death_loss(REAL_CHAR(ch), GET_LEVEL(REAL_CHAR(ch))));
d2582 4
@


1.203
log
@Got rid of update_pos. alter_pos should be used instead. Changed damage()
a lot due to alter_hit, which handles messages and dying.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.202 2008/04/19 21:01:56 jps Exp jps $
d38 1
d1418 1
a1418 7
  /*
   * Check for active defense spells
   *
   * Instead of IS_SPELL, it would be better if we could differentiate
   * between contact and missile spells and skills, and then check that
   * here.
   */
d1421 1
a1421 50
    shdam = 0;
    if (EFF_FLAGGED(victim, EFF_FIRESHIELD)) {
      if (EFF_FLAGGED(ch, EFF_MAJOR_GLOBE))
        act ("&1&bThe globe around your body absorbs the burning flames!&0",
              FALSE, ch, 0, 0, TO_CHAR);
      else {
        act("&1Your limbs are seared by $N&0&1's shield of flames.&0",
              FALSE, ch, 0, victim, TO_CHAR);
        act("&1$n&0&1's limbs are seared by your shield of flames.&0",
              FALSE, ch, 0, victim, TO_VICT);
        act("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0",
              FALSE, ch, 0, victim, TO_NOTVICT);
        shdam += MIN((GET_LEVEL(victim) / 2 + number(1, GET_LEVEL(victim) / 10)),
              dam / 3 + number(1, 1 + GET_LEVEL(victim) / 10));
      }
    }
    if (EFF_FLAGGED(victim, EFF_COLDSHIELD)) {
      if (EFF_FLAGGED(ch, EFF_MAJOR_GLOBE))
        act("&4&bThe globe around your body absorbs the killing ice!&0", FALSE, ch, 0, 0, TO_CHAR);
      else {

        act("&4You are impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_CHAR);
        act("&4$n&0&4 is impaled on your shield of ice.&0", FALSE, ch, 0, victim, TO_VICT);
        act("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_NOTVICT);
        shdam += MIN((GET_LEVEL(victim) / 2 + number(1, 1 + GET_LEVEL(victim) / 10)),
              dam / 3 + number(1, 1 + GET_LEVEL(victim) / 10));
      }
    }
    if (EFF_FLAGGED(victim, EFF_SOULSHIELD)) {
      if (GET_ALIGNMENT(ch) >= 500 && GET_ALIGNMENT(victim) <= -500) {
        act("&7&b$n's soul suffers upon contact with your aura.&0",
              TRUE, ch, 0, victim, TO_VICT);
        act("&7&bYour soul suffers upon contact with $N's aura.&0",
              TRUE, ch, 0, victim, TO_CHAR);
        act("&7&b$n's soul suffers upon contact with $N's aura.&0",
              TRUE, ch, 0, victim, TO_NOTVICT);
        shdam += MIN(2 * GET_LEVEL(victim) / 5 + number(1, 1 + GET_LEVEL(victim) / 10),
              3 * dam / 16 + number(1, 1 + GET_LEVEL(victim) / 10));
      }
      if (GET_ALIGNMENT(ch) <= -500 && GET_ALIGNMENT (victim) >= 500) {
        act("&7&b$n's soul suffers upon contact with your aura.&0",
              TRUE, ch, 0, victim, TO_VICT);
        act("&7&bYour soul suffers upon contact with $N's aura.&0",
              TRUE, ch, 0, victim, TO_CHAR);
        act("&7&b$n's soul suffers upon contact with $N's aura.&0",
              TRUE, ch, 0, victim, TO_NOTVICT);
        shdam += MIN(2 * GET_LEVEL(victim) / 5 + number(1, 1 + GET_LEVEL(victim) / 10),
              3 * dam / 16 + number(1, 1 + GET_LEVEL(victim) / 10));
      }
    }
d1424 1
a1424 1
  }  /*  end attacktype check */
d1426 1
a1426 1
    /* Do the damage. */
d2579 4
@


1.202
log
@Don't mark spell circles empty when unmemming spells at death.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.201 2008/04/18 00:31:16 jps Exp jps $
d37 1
a42 1
void update_pos (struct char_data *victim);
a342 158

void perform_update_pos(struct char_data *victim)
{
  if (GET_HIT(victim) > 0 && GET_STANCE(victim) < STANCE_SLEEPING) {
    GET_POS(victim) = POS_STANDING;
    GET_STANCE(victim) = STANCE_ALERT;
  } else if (GET_HIT(victim) <= HIT_DEAD) {
    GET_POS(victim) = POS_PRONE;
    GET_STANCE(victim) = STANCE_DEAD;
  } else if (GET_HIT(victim) <= HIT_MORTALLYW) {
    GET_POS(victim) = POS_PRONE;
    GET_STANCE(victim) = STANCE_MORT;
    StopMercifulAttackers(victim);
    if (GET_LEVEL(victim) >= LVL_IMMORT && victim->desc &&
        victim->desc->original)
      do_return(victim, "", 0, 1);
  } else if (GET_HIT(victim) <= HIT_INCAP) {
    GET_POS(victim) = POS_PRONE;
    GET_STANCE(victim) = STANCE_INCAP;
    StopMercifulAttackers(victim);
    if (GET_LEVEL (victim) >= LVL_IMMORT && victim->desc &&
        victim->desc->original)
      do_return(victim, "", 0, 1);
  } else if (GET_HIT(victim) < 0) {
    GET_POS(victim) = POS_PRONE;
    GET_STANCE(victim) = STANCE_STUNNED;
  }
}


void update_pos(struct char_data *victim)
{
  bool fall_over = FALSE;
  int old_stance = GET_STANCE(victim);

  ACMD(do_wake);

  if (!event_target_valid(victim))
    return;

  /*
   * If the victim is fighting someone, but isn't in the same room, stop
   * the fight.
   */
  if (FIGHTING(victim) && FIGHTING(victim)->in_room != victim->in_room)
    stop_fighting(victim);

  /*
   * If the victim is riding someone, but isn't in the same room, stop
   * the ride.
   */
  if (RIDING(victim) && RIDING(victim)->in_room != victim->in_room)
    dismount_char (victim);


  /*
   * If the victim is incapable of fighting, make sure they aren't
   * fighting anyone and that any merciful attackers stop fighting
   * them.
   *
   * This seems like it could be pretty process-intensive. -L
   */
  if (!AWAKE(victim) || EFF_FLAGGED(victim, EFF_MINOR_PARALYSIS) ||
      EFF_FLAGGED(victim, EFF_MAJOR_PARALYSIS)) {
    if (FIGHTING(victim))
      stop_fighting(victim);
    StopMercifulAttackers(victim);
  }

  /*
   * Make sure mobs assume their default position if possible.
   * This may not necessary... mob AI should take care of it... -L
   */
  if (IS_NPC(victim) && AWAKE(victim) && !FIGHTING(victim) &&
      !GET_MOB_WAIT(victim) && GET_DEFAULT_POS(victim) > POS_PRONE)
    GET_POS(victim) = GET_DEFAULT_POS(victim);

  /*
   * Update the character's position based on their hitpoints.
   */
  perform_update_pos(victim);

  /* Now lets use our new dual position system and riding to victimeck(I hope)
     all the possible positions and perhaps problems in those postions the
     poor mortals get themselves into. Banyal */


  /*
   * Determine whether the position change should warrant some further
   * action, like slumping over or sitting up.
   */
  if (DECEASED(victim)) {
    if (GET_POS(victim) != POS_PRONE || RIDING(victim))
      fall_over = TRUE;
  }
  else if (GET_STANCE(victim) < STANCE_RESTING) {
    if (RIDING(victim))
      fall_over = !number(0, 1);
    else if (GET_POS(victim) != POS_PRONE)
      fall_over = !number(0, 9);
  }

  if (fall_over) {
    if (RIDING(victim)) {
      if (GET_POS(RIDING(victim)) == POS_STANDING) {
        GET_POS(victim) = POS_PRONE;
        alter_hit(victim, dice(3, 8), TRUE);
        WAIT_STATE(victim, PULSE_VIOLENCE + 2);
      }
      act("$n falls off $s mount!", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You fall off your mount!\r\n", victim);
      dismount_char(victim);
      effect_from_char(victim, SPELL_SLEEP);
      do_wake(victim, "", 0, 0);
    }
    else if (GET_POS(victim) == POS_STANDING) {
      if (!number(0, 2)) {
        GET_POS(victim) = POS_PRONE;
        alter_hit(victim, dice(3, 5), TRUE);
        if (GET_STANCE(victim) > STANCE_INCAP)
          WAIT_STATE(victim, PULSE_VIOLENCE + 3);
        act("$n slumps to the ground.", TRUE, victim, 0, 0, TO_ROOM);
      }
    }
    GET_POS(victim) = POS_PRONE;

    /* Re-check position with new hitpoints. */
    perform_update_pos(victim);
  }


  /* Display messages if the pos change warrants it. */
  if (old_stance <= STANCE_INCAP && GET_STANCE(victim) > STANCE_SLEEPING) {
    if (affected_by_spell(victim, SPELL_SLEEP))
      effect_from_char (victim, SPELL_SLEEP);
    GET_POS(victim) = POS_SITTING;
    GET_STANCE(victim) = STANCE_RESTING;
    act("$n regains consciousness and sits up.", FALSE, victim, 0, 0, TO_ROOM);
    send_to_char("You regain consciousness and sit up.\r\n", victim);
  }

  if (old_stance == STANCE_SLEEPING && GET_STANCE(victim) > STANCE_SLEEPING) {
    act("$n has a RUDE awakening!", TRUE, victim, 0, 0, TO_ROOM);
    effect_from_char(victim, SPELL_SLEEP);
    do_wake(victim, "", 0, 0);
  }

  /*
   * Some sanity checks: lets not leave dead people to be found by code
   * elsewhere
   */
  if (DECEASED(victim)) {
    if (FIGHTING(victim))
      stop_fighting(victim);
  }
}


d388 1
a388 1
void stop_fighting (struct char_data *ch)
d398 4
a403 1
  update_pos (ch);
d584 1
a584 1
      alter_hit(ch, -(abs(GET_HIT(ch)) + 5), TRUE);
d604 1
a604 3
   GET_POS(ch) = POS_SITTING;
   GET_STANCE(ch) = STANCE_RESTING;
   update_pos(ch);
d691 2
a692 1
void kill_to_group_trophy (struct char_data *ch, struct char_data *victim) {
d720 13
a732 3
   GET_POS(ch) = POS_PRONE;
   GET_STANCE(ch) = STANCE_DEAD;
   update_pos(ch);
d787 2
a788 1
static float exp_level_bonus(int level_diff) {
d862 1
a862 1
char *replace_string (char *str, char *weapon_singular, char *weapon_plural)
a1121 1

d1223 1
a1223 1
  int attacker_weapons, victim_weapons, dummy, shdam;
d1225 1
d1247 1
a1247 2
    alter_hit(victim, dam, TRUE);
    update_pos(victim);
d1346 1
a1346 1
    act("$n's crushing blow frees $N from a magic which held $M motionless.",
a1362 1
  /* Skip actual damage and vampiric touch if attacker is illusory */
d1364 2
a1365 2
    /* Do the damage. */
    alter_hit(victim, dam, TRUE);
d1367 1
a1367 4
    /*
     * Vampiric touch if neither the attacker nor victim are wielding
     * weapons and this is a contact attack.
     */
d1370 1
a1370 2
      count_hand_eq(victim, &dummy, &victim_weapons);
      if (ch != victim && attacker_weapons == 0 && victim_weapons == 0) {
d1372 2
a1373 7
          if (IS_NPC(ch))
            alter_hit(ch, -dam / 2, FALSE);
          else
            alter_hit(ch, -dam, FALSE);
        }
        /* Only players can vamp touch using the skill. */
        if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0)
d1375 1
a1375 1
            alter_hit(ch,  -dam / 2, TRUE);
d1378 1
d1401 1
a1401 1
    if (DECEASED(victim))
d1409 1
a1409 1
    if (DECEASED(victim) || dam == 0) {
a1416 3
  if (!MOB_FLAGGED(ch, MOB_ILLUSORY))
    update_pos(victim);

d1429 2
a1430 1
        act ("&1&bThe globe around your body absorbs the burning flames!&0", FALSE, ch, 0, 0, TO_CHAR);
d1432 6
a1437 3
        act("&1Your limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_CHAR);
        act("&1$n&0&1's limbs are seared by your shield of flames.&0", FALSE, ch, 0, victim, TO_VICT);
        act("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_NOTVICT);
d1456 6
a1461 3
        act("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
        act("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
        act("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d1466 6
a1471 3
        act("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
        act("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
        act("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d1477 1
a1477 1
       alter_hit(ch, shdam, TRUE);
d1480 9
a1488 57
  /* Use send_to_char -- act() doesn't send message if you are DEAD. */
  switch (GET_STANCE(victim)) {
    case STANCE_MORT:
      act("$n is mortally wounded, and will die soon, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", victim);
      break;
    case STANCE_INCAP:
      act("$n is incapacitated and will slowly die, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", victim);
      break;
    case STANCE_STUNNED:
      act("$n is stunned, but will probably regain consciousness again.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You're stunned, but will probably regain consciousness again.\r\n", victim);
      break;
    case STANCE_DEAD:
      /*
       * Note - for death from bloodloss (TYPE_SUFFERING), the death
       * message is different, and will be sent later when we call
       * slow_death (see below).
       */
      if (attacktype != TYPE_SUFFERING) {
         act("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
         send_to_char("You are dead!\r\n", victim);
      }
      break;

    default:                        /* >= POSITION SLEEPING */
      if (dam > (GET_MAX_HIT(victim) >> 2))
        act("That really did HURT!", FALSE, victim, 0, 0, TO_CHAR);

      if (GET_HIT(victim) < (GET_MAX_HIT(victim) >> 2)) {
        sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
                CLRLV(victim, FRED, C_SPR), CLRLV(victim, ANRM, C_SPR));
        send_to_char(buf2, victim);
        if (MOB_FLAGGED(victim, MOB_WIMPY) && (ch != victim) &&
            !EFF_FLAGGED(victim, EFF_CHARM))
          do_flee (victim, "", 0, 0);
      }
      if (!IS_NPC(victim) && GET_WIMP_LEV(victim) && (victim != ch) &&
          GET_HIT(victim) < GET_WIMP_LEV(victim)) {
        send_to_char("You attempt to flee!\r\n", victim);
        do_flee(victim, "", 0, 0);
      }
      break;
  }

  /* If the victim is about to die by something like fire or poison,
   * AND they are in combat with someone, let their opponent get the
   * exp for killing them.
   */
  if (DECEASED(victim) && ch == victim && was_fighting) {
    switch (attacktype) {
      case SPELL_ON_FIRE:
      case SPELL_POISON:
      case TYPE_SUFFERING:
        ch = was_fighting;
        break;
d1500 14
a1514 10
    if (!IS_NPC(victim)) {
      sprintf(buf2, "%s killed by %s at %s [%d]", GET_NAME(victim),
              GET_NAME(ch), world[victim->in_room].name,
              world[victim->in_room].number);
      mudlog(buf2, BRF, LVL_IMMORT, TRUE);
    }
    if (attacktype == TYPE_SUFFERING)
      slow_death(victim);
    else
      die(victim, ch);
d2633 3
@


1.201
log
@Prevent skill improvement crash with TYPE_UNDEFINED.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.200 2008/04/16 01:53:23 jps Exp jps $
a780 1
  int i;
a811 2
  for (i = 0; i < NUM_SPELL_CIRCLES + 1; ++i)
    GET_SPELL_MEM(ch).num_circle[i] = 0;
d2825 3
@


1.200
log
@Increase the intra-calculation values by a factor of 10 when
determining THAC0, AC, and whether a hit connects.  This doesn't
change the overall form of the calculations, but it does make
individual point changes in hitroll, AC, wis, and int significant.
In other words, you no longer have the same hitroll bonus for all
values of hitroll between 10 and 19.  The little extra ones help.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.199 2008/04/14 02:32:07 jps Exp jps $
d2126 1
a2126 1
   if (imptype != type)
d2828 8
@


1.199
log
@ Consolidate the loss of hiddenness when being violent into a single
function.  It also removes glory.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.198 2008/04/13 20:53:25 jps Exp jps $
d1976 4
d1986 1
a1986 6
  /* Calculate the raw armor including magic armor.  Lower AC is better. */

  calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00);
  calc_thaco -= str_app[GET_STR(ch)].tohit;

  calc_thaco -= GET_HITROLL (ch) / 10;
d1988 20
a2007 8
  calc_thaco -= GET_INT(ch) / 25;        /* Int helps! */
  calc_thaco -= GET_WIS(ch) / 25;        /* So does wis */

  diceroll = number(1, 20);

  victim_ac = GET_AC(victim) / 10;
  victim_ac += dex_app[GET_DEX (victim)].defensive;
  victim_ac = MAX(-10, victim_ac);        /* -10 is lowest */
a2009 1
   * Decide whether this is a hit or a miss.
d2011 3
a2013 3
   *      1   = Automatic miss
   *    2..19 = Checked vs. AC
   *     20   = Automatic hit
d2015 1
a2015 1
  if (diceroll == 20 || !AWAKE(victim))
d2017 1
a2017 1
  else if (diceroll == 1)
d2828 4
@


1.198
log
@Make confused people switch to random targets during battle.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.197 2008/04/13 10:23:34 jps Exp jps $
d87 1
d1465 2
a1466 3
  /* Abra cadabra appear! */
  if (EFF_FLAGGED(ch, EFF_INVISIBLE) || IS_HIDDEN(ch))
    appear(ch);
d1928 1
a1928 2
  if (EFF_FLAGGED(ch, EFF_INVISIBLE) || IS_HIDDEN(ch))
    appear (ch);
d2818 3
@


1.197
log
@Allow auxiliary skills like dual wield to improve.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.196 2008/04/13 00:57:53 jps Exp jps $
d2265 1
a2265 1
  struct char_data *ch;
d2268 3
d2353 8
d2819 3
@


1.196
log
@Implement the auto treasure toggle, which makes you loot coins
and "treasure" type objects.  Which includes gems.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.195 2008/04/07 03:02:54 jps Exp jps $
d1885 1
a1885 1
  int dtype;
d1960 3
d2115 5
d2808 4
@


1.195
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.194 2008/04/05 06:35:03 myc Exp jps $
d778 1
a778 1
  struct obj_data *corpse = NULL;
d782 3
a784 1
  extern void get_from_container(struct char_data *ch, struct obj_data *obj, char *arg, int mode);
d835 13
a847 3
  if (killer && ch != killer && PRF_FLAGGED(killer, PRF_AUTOLOOT) &&
      corpse && corpse->contains)
    get_from_container(killer, corpse, "all", FIND_OBJ_ROOM);
d2800 4
@


1.194
log
@Fix another crash bug: perform_die assumed killer would be non-null,
when this is not necessarily the case.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.193 2008/04/04 20:47:43 jps Exp myc $
d143 1
a143 1
  if (GET_POS(victim) == POS_DEAD) {
d345 1
a345 1
  if (GET_HIT(victim) > 0 && GET_POS(victim) < POS_SLEEPING) {
d347 7
a353 6
    GET_STANCE(victim) = STANCE_STANDING;
  }
  else if (GET_HIT(victim) <= HIT_DEAD)
    GET_POS(victim) = POS_DEAD;
  else if (GET_HIT(victim) <= HIT_MORTALLYW) {
    GET_POS(victim) = POS_MORTALLYW;
d358 3
a360 3
  }
  else if (GET_HIT(victim) <= HIT_INCAP) {
    GET_POS(victim) = POS_INCAP;
d365 3
a368 2
  else if (GET_HIT(victim) < 0)
    GET_POS (victim) = POS_STUNNED;
d375 1
a375 1
  int old_pos = GET_POS(victim);
d416 1
a416 1
      !GET_MOB_WAIT(victim) && GET_DEFAULT_POS(victim) > POS_SLEEPING)
d433 2
a434 2
  if (GET_POS(victim) == POS_DEAD) {
    if (GET_STANCE(victim) != STANCE_PRONE || RIDING(victim))
d437 1
a437 1
  else if (GET_POS(victim) < POS_RESTING) {
d440 1
a440 1
    else if (GET_STANCE(victim) != STANCE_PRONE)
d446 2
a447 2
      if (GET_STANCE(RIDING(victim)) == STANCE_STANDING) {
        GET_STANCE(victim) = STANCE_PRONE;
d457 1
a457 1
    else if (GET_STANCE(victim) == STANCE_STANDING) {
d459 1
a459 1
        GET_STANCE(victim) = STANCE_PRONE;
d461 1
a461 1
        if (GET_POS(victim) > POS_INCAP)
d466 1
a466 1
    GET_STANCE(victim) = STANCE_PRONE;
d474 1
a474 1
  if (old_pos <= POS_INCAP && GET_POS(victim) > POS_SLEEPING) {
d478 1
a478 1
    GET_STANCE(victim) = STANCE_PRONE;
d483 1
a483 1
  if (old_pos == POS_SLEEPING && GET_POS(victim) > POS_SLEEPING) {
d493 1
a493 1
  if (GET_POS(victim) == POS_DEAD) {
d521 1
a521 1
void set_fighting (struct char_data *ch, struct char_data *vict)
d523 1
a523 1
  if (ch == vict || GET_POS(ch) <= POS_STUNNED)
d526 1
a526 1
  assert (!FIGHTING (ch));        /*Setmark game crashing due to assertion failing */
d534 4
a537 3
  FIGHTING (ch) = vict;
  GET_POS(ch) = POS_FIGHTING;
  GET_STANCE(ch) = STANCE_STANDING;
a543 1

d552 1
a552 1
  REMOVE_FROM_LIST (ch, combat_list, next_fighting);
d554 3
a556 5
  FIGHTING (ch) = NULL;
  if (GET_POS(ch) == POS_FIGHTING) {
    GET_POS(ch) = POS_STANDING;
    GET_STANCE(ch) = STANCE_STANDING;
  }
d758 1
a758 1
   GET_POS(ch) = POS_RESTING;
d866 2
a867 2
   GET_POS(ch) = POS_DEAD;
   GET_STANCE(ch) = STANCE_PRONE;
d1326 1
a1326 1
            if (GET_POS(vict) == POS_DEAD)
d1362 1
a1362 1
  if (GET_POS(victim) <= POS_DEAD) {
d1397 1
a1397 1
    if (GET_POS(ch) > POS_STUNNED) {
d1431 1
a1431 1
    if (GET_POS(victim) > POS_STUNNED && !FIGHTING(victim)) {
d1547 1
a1547 1
    if (GET_POS(victim) == POS_DEAD)
d1555 1
a1555 1
    if (GET_POS(victim) == POS_DEAD || dam == 0) {
d1620 2
a1621 2
  switch (GET_POS(victim)) {
    case POS_MORTALLYW:
d1625 1
a1625 1
    case POS_INCAP:
d1629 1
a1629 1
    case POS_STUNNED:
d1633 1
a1633 1
    case POS_DEAD:
d1669 1
a1669 1
  if (GET_POS(victim) == POS_DEAD && ch == victim && was_fighting) {
d1686 1
a1686 1
  if (GET_POS(victim) == POS_DEAD) {
d2047 6
a2052 6
     * Position sitting  x 1.33
     * Position resting  x 1.66
     * Position sleeping x 2.00
     * Position stunned  x 2.33
     * Position incap    x 2.66
     * Position mortally x 3.00
d2054 1
a2054 1
     * values of the POSITION_XXX constants.
d2056 2
a2057 2
    if (GET_POS (victim) < POS_FIGHTING)
      dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;
d2094 1
a2094 1
    if (GET_POS(ch) != POS_DEAD && weapon && !number(0, 9) &&
d2251 1
a2251 1
    if (FIGHTING(ch) == NULL || GET_POS(FIGHTING(ch)) == POS_DEAD ||
d2278 1
a2278 1
    if (GET_POS(ch) < POS_FIGHTING) {
d2335 1
a2335 1
      if (FIGHTING(ch) && ALIVE_POS(ch) && secondary_hits) {
d2340 1
a2340 1
             FIGHTING(ch) && ALIVE_POS(ch));
d2342 1
a2342 1
    if (ALIVE_POS(ch) && MOB_FLAGGED (ch, MOB_SPEC) &&
d2788 4
@


1.193
log
@Make a macro for checking skill targets, since some places will
query it with invalid skills.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.192 2008/04/04 06:12:52 myc Exp jps $
d833 1
a833 1
  if (ch != killer && PRF_FLAGGED(killer, PRF_AUTOLOOT) &&
d2788 4
@


1.192
log
@Removed justice code and several old spec procs.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.191 2008/04/03 02:02:05 myc Exp myc $
d1509 1
a1509 1
    if (IS_WEAPON(attacktype) || IS_SET(skills[attacktype].targets, TAR_CONTACT)) {
d1574 1
a1574 1
      IS_SET(skills[attacktype].targets, TAR_CONTACT))) {
d2788 3
@


1.191
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.190 2008/04/02 17:41:56 myc Exp myc $
a55 1
void check_justice (struct char_data *ch, struct char_data *vict);
a537 8
  /*
   * Justice is no longer used.
   *
  check_justice (ch, vict);
  if(ch != vict)
    if (ch->desc && ch->desc->original)
      check_justice(ch->desc->original, vict);
  */
a1852 2
  SPECIAL(blind_weapon);
  SPECIAL(fireball_weapon);
a1854 2
  SPECIAL(fullharm_weapon);
  SPECIAL(curse_weapon);
a1855 1
  SPECIAL(dispel_good_weapon);
d1859 2
a1860 4
  if (name != blind_weapon && name != fireball_weapon &&
      name != curse_weapon && name != fullharm_weapon &&
      name != vampiric_weapon && name != lightning_weapon &&
      name != holyw_weapon && name != dispel_good_weapon)
d2788 3
@


1.190
log
@Fixed vampiric touch.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.189 2008/04/02 05:36:19 myc Exp myc $
d1660 1
a1660 1
                CCRED (victim, C_SPR), CCNRM (victim, C_SPR));
d2804 3
@


1.189
log
@Added the autoloot toggle, which allows players to automatically
pick the items up from a corpse.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.188 2008/04/02 03:24:44 myc Exp myc $
d1516 1
a1516 1
     * weapons.
d1518 10
a1527 10
    count_hand_eq(ch, &dummy, &attacker_weapons);
    count_hand_eq(victim, &dummy, &victim_weapons);
    if (ch != victim && attacker_weapons == 0 && victim_weapons == 0) {
      if (EFF_FLAGGED(ch, EFF_VAMP_TOUCH)) {
        if (IS_NPC(ch))
          alter_hit(ch, -dam / 2, FALSE);
        else
          alter_hit(ch, -dam, FALSE);
      }
      if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0)
d1529 1
a1529 1
        if (!IS_NPC(ch)) {
d1531 1
a1531 1
            alter_hit(ch,  -dam / 2, FALSE);
d1534 1
a1534 1
        }
d2804 4
@


1.188
log
@Rewrote group code and removed major group code.  Cleaned
up death code.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.187 2008/03/30 16:05:08 jps Exp myc $
d571 1
a571 1
void make_corpse (struct char_data *ch)
d581 1
a581 1
     return;
d584 1
a584 1
  corpse = create_obj ();
d588 1
a588 1
  sprintf (buf2, "corpse %s", strip_ansi ((ch)->player.namelist));
d591 1
a591 1
  sprintf (buf2, "&0The corpse of %s&0 is lying here.", GET_NAME (ch));
d594 1
a594 1
  sprintf (buf2, "the corpse of %s", GET_NAME (ch));
d597 3
a599 4
  GET_OBJ_TYPE (corpse) = ITEM_CONTAINER;
  /*GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE; */
  GET_OBJ_EXTRA (corpse) = (ITEM_NODONATE | ITEM_FLOAT | ITEM_TRANSIENT);
  GET_OBJ_VAL (corpse, 0) = 0;        /* You can't store stuff in a corpse */
d605 2
a606 2
  if (!IS_NPC (ch))
    GET_OBJ_VAL (corpse, 3) = CORPSE_PC;         /* player corpse          */
d608 1
a608 1
    GET_OBJ_VAL (corpse, 3) = CORPSE_NPC_NORAISE;/* npc corpse - unraisable */
d610 1
a610 1
    GET_OBJ_VAL (corpse, 3) = CORPSE_NPC;        /* npc corpse - raisable   */
d613 6
a618 6
  GET_OBJ_VAL (corpse, 2) = top_of_corpse_list;
  GET_OBJ_WEIGHT (corpse) = GET_WEIGHT (ch) + IS_CARRYING_W (ch) + 100;
  GET_OBJ_RENT (corpse) = 100000;
  GET_OBJ_RENT (corpse) = GET_LEVEL (ch);
  if (IS_NPC (ch))
    GET_OBJ_MOB_FROM (corpse) = GET_MOB_RNUM (ch);
d620 1
a620 1
    GET_OBJ_MOB_FROM (corpse) = NOBODY;
d622 2
a623 2
  if (IS_NPC (ch))
    GET_OBJ_TIMER (corpse) = max_npc_corpse_time;
d625 1
a625 1
    GET_OBJ_TIMER (corpse) = max_pc_corpse_time;
d637 1
a637 1
  if (!(MOB_FLAGGED (ch, MOB_NOGEAR))) */
d640 1
a640 1
  object_list_new_owner (corpse, NULL);
d644 2
a645 2
    if (GET_EQ (ch, i))
      obj_to_obj (unequip_char (ch, i), corpse);
d648 1
a648 1
  if (GET_CASH (ch) > 0)
d651 1
a651 1
      if (IS_NPC (ch) || (!IS_NPC (ch) && ch->desc))
d653 2
a654 2
          money = create_money (GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
          obj_to_obj (money, corpse);
d656 4
a659 4
      GET_GOLD (ch) = 0;
      GET_PLAT (ch) = 0;
      GET_COPPER (ch) = 0;
      GET_SILVER (ch) = 0;
d662 6
a667 2
  IS_CARRYING_N (ch) = 0;
  IS_CARRYING_W (ch) = 0;
d669 1
a669 3
  obj_to_room (corpse, ch->in_room);
  if (!IS_NPC (ch))
    ccontrol_make_corpse (world[ch->in_room].number, corpse);
d787 1
d791 3
d830 1
a830 1
    make_corpse(real_char);
d838 1
a838 1
    make_corpse(ch);
d841 4
d2804 4
@


1.187
log
@Cancel other events when you're about to die.  This may prevent
those 'double deaths' from recurring.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.186 2008/03/30 15:37:36 jps Exp jps $
a80 1
/* void frag_update (struct char_data *ch, struct char_data *victim, float amount); */
d674 36
a709 33
        /* local copies of the aligns which could be modified */
        int k_al,v_al,change;
        k_al = GET_ALIGNMENT(ch);
        v_al = GET_ALIGNMENT(victim);

        /* if victim was anti good, and killer was good, make victim 'more evil'*/
        if (MOB_FLAGGED(victim,MOB_AGGR_GOOD) && IS_GOOD(ch))
                v_al -= 100;
        else if (MOB_FLAGGED(victim,MOB_AGGR_EVIL) && IS_EVIL(ch))
                v_al += 100;
        /* sojourn code has some stuff for STAYZONE and NICETHIEF here too?*/

        /* if we a re a 'good' class then our effective align is higher, ie
         * even if a paladin of align 800 kills someone its as if they were align
         * 900 compared to a wariror 800 (cos they should know better!)
         */
        switch (GET_CLASS(ch))
        {
                /* using drop through cases to accumulate the align*/
                case CLASS_PALADIN:
                case CLASS_PRIEST:        k_al += 50;
                case CLASS_RANGER:
                case CLASS_DRUID:        k_al += 50;
                                        break;

                /* same deal for 'bad' classes */
                case CLASS_ANTI_PALADIN:
                case CLASS_DIABOLIST:
                case CLASS_NECROMANCER:        k_al -= 50;
                case CLASS_THIEF:
                case CLASS_ASSASSIN:        k_al -=50;
                                        break;
        }
d711 2
a712 6
        change = (v_al/(-75 - (25 * abs((k_al-1000)/200)))) - (2 * abs(k_al/1000));
        /* modifier based on level?*/
        if (change < 0 && (GET_LEVEL(ch) > (GET_LEVEL(victim) +10)))
                change *= (GET_LEVEL(ch)-GET_LEVEL(victim))/10;
        GET_ALIGNMENT(ch) += change;
        GET_ALIGNMENT(ch) = LIMIT(-1000, GET_ALIGNMENT(ch), 1000);
d783 1
a783 1
void raw_kill (struct char_data *ch, struct char_data *killer)
d790 1
a790 2
  if (ch->desc && ch->desc->original)
    {
d794 1
a794 1
    }
d799 1
a799 1
    effect_remove (ch, ch->effects);
d801 1
a801 1
    effect_remove (real_char, real_char->effects);
d809 1
a809 1
  /* Set all spells in the memory list to unmemorized. */
a813 1
  GET_SPELL_MEM(ch).num_spells = 0;
d820 11
a830 10
  if (GET_LEVEL (real_char) < LVL_IMMORT) {
    make_corpse (real_char);
    if (!IS_NPC (real_char))        /* If killed dont save in room he died in */
      GET_LOADROOM (real_char) = GET_HOME (real_char);
    if (ch != real_char) {
      extract_char (real_char);
      extract_char (ch);
    } else {
      extract_char (ch);
    }
d832 1
a832 1
    do_return (real_char, "", 0, 1);
d834 1
a834 1
    extract_char (ch);
d838 3
a840 8
/* type is TRUE for frags and FALSE for trophys */
void kill_to_group (struct char_data *ch, struct char_data *victim, bool type) {
  /*want to loop through all group and major group members for this */

   /*    int groupees; */
  int tot_members = 0;
  struct char_data *groupmaster;
  struct char_data *majorgroupmaster = NULL;
a841 102
  struct mgroup_type *m;
   /*    float tot_percent; */
   /*    float leader_percent; */

  groupmaster = (ch->groupmaster ? ch->groupmaster : ch);
  if (!(EFF_FLAGGED (groupmaster, EFF_GROUP))) {
    sprintf (buf, "In group exp give and leader not grouped?:%s exiting without exp gain", GET_NAME (ch));
    mudlog (buf, NRM, LVL_GOD, FALSE);
    return;
  }
  if (EFF_FLAGGED (groupmaster, EFF_MAJOR_GROUP)) {
    majorgroupmaster = (groupmaster->mgroupmaster ? groupmaster->mgroupmaster : groupmaster);
    if (majorgroupmaster->in_room == ch->in_room)
      tot_members = 1;
    for (g = majorgroupmaster->groupees; g; g = g->next)
      if (g->groupee->in_room == ch->in_room)
        tot_members++;
    for (m = majorgroupmaster->mgroupees; m; m = m->next) {
      if (m->mgroupee->in_room == ch->in_room)
        tot_members++;
      for (g = m->mgroupee->groupees; g; g = g->next)
        if (g->groupee->in_room == ch->in_room)
          tot_members++;
    }
  } else { /* just group count */
    if (groupmaster->in_room == ch->in_room)
      tot_members = 1;
    for (g = groupmaster->groupees; g; g = g->next)
      if (g->groupee->in_room == ch->in_room)
        tot_members++;
  }

  if (EFF_FLAGGED (groupmaster, EFF_MAJOR_GROUP)) {
    if (majorgroupmaster->in_room == ch->in_room) {
      if(type) {
        /* frag_update(majorgroupmaster, killer, (1 / (float) tot_members)); */
      } else if (!IS_NPC(majorgroupmaster)) {
        kill_to_trophy(victim, majorgroupmaster, (1 / (float) tot_members));
      }
    }
    for (g = majorgroupmaster->groupees; g; g = g->next) {
      if (g->groupee->in_room == ch->in_room) {
        if(type) {
          /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
        } else if (!IS_NPC(g->groupee)) {
          kill_to_trophy(victim, g->groupee, (1 / (float) tot_members));
        }
      }
    }
    for (m = majorgroupmaster->mgroupees; m; m = m->next) {
      if (m->mgroupee->in_room == ch->in_room) {
        if(type) {
          /*  frag_update(m->mgroupee, killer, (1 / (float) tot_members)); */
        } else if (!IS_NPC(m->mgroupee)) {
          kill_to_trophy(victim, m->mgroupee, (1 / (float) tot_members));
        }
      }
      for (g = m->mgroupee->groupees; g; g = g->next) {
        if (g->groupee->in_room == ch->in_room) {
          if(type) {
            /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
          } else if (!IS_NPC(g->groupee)) {
            kill_to_trophy(victim, g->groupee, (1 / (float) tot_members));
          }
        }
      }
    }
  } else {                                /*just group count */
    if (groupmaster->in_room == ch->in_room) {
      if(type) {
        /* frag_update(groupmaster, killer, (1 / (float) tot_members)); */
      } else if (!IS_NPC(groupmaster)) {
        kill_to_trophy(victim, groupmaster, (1 / (float) tot_members));
      }
    }
    for (g = groupmaster->groupees; g; g = g->next) {
      if (g->groupee->in_room == ch->in_room) {
        if(type) {
          /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
        } else if (!IS_NPC(g->groupee)) {
          kill_to_trophy(victim, g->groupee, (1 / (float) tot_members));
        }
      }
    }
  }
}

void perform_die(struct char_data *ch, struct char_data *killer)
{
  int shapechanged = 0;
  struct char_data *sc;

  /* This -IF- statement was added in an attempt to allow
     shapechanged players to lose experience. If there are
     any new problems with players losing experience please
     talk to me. Zantir 02/20/00 */
  if (IS_NPC(ch) && ch->desc && ch->desc->original) {
    sc = ch;
    shapechanged = 1;
    ch = ch->desc->original;
    ch->points.hit = 1;
  }
d843 1
a843 3
  if (GET_LEVEL(ch) < 60 && !MOB_FLAGGED(ch, MOB_ILLUSORY)) {
    perform_random_gem_drop(ch);
  }
d845 13
a857 8
  /* Need to pass the right pointer to raw_kill...I changed it
     for shapechange...so now we need to change it back.
     Zantir 2/20/01 */
  if (shapechanged == 1) {
    raw_kill(sc, killer);
  } else {
    raw_kill(ch, killer);
  }
a876 7
   /*check for switch. Original char loses exp */
   if (ch->desc && ch->desc->original) {
      gain_exp (ch->desc->original, NULL,
            -(exp_death_loss (ch->desc->original, GET_LEVEL (ch->desc->original))));
   } else {
      gain_exp (ch, NULL, -(exp_death_loss (ch, GET_LEVEL (ch))));
   }
d878 4
a881 1
   /* Exp and trophy for the killer */
d883 4
a886 13
      if (EFF_FLAGGED (killer, EFF_GROUP)) {
         /*loop through group */
         /*if a BIG person got kill then dont let rest of group bludge: */
         if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25)) {
            if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)));
            else {
               kill_to_group (killer, ch, TRUE);
            }
         }
         kill_to_group (killer, ch, FALSE);
      } else if (!IS_NPC(killer)) {
         kill_to_trophy (ch, killer, 1.0);
      }
d889 2
a890 2
   if (EFF_FLAGGED (ch, EFF_ON_FIRE))
      REMOVE_FLAG (EFF_FLAGS (ch), EFF_ON_FIRE);
d892 6
a897 6
   if (!IS_NPC (ch)) {
      REMOVE_FLAG (PLR_FLAGS (ch), PLR_KILLER);
      REMOVE_FLAG (PLR_FLAGS (ch), PLR_THIEF);
      GET_COND (ch, THIRST) = 24;
      GET_COND (ch, FULL) = 24;
      GET_COND (ch, DRUNK) = 0;
d910 1
a910 1
         death_cry (ch);
d914 2
a915 2
   else if (death_mtrigger (ch, killer) && killer)
      death_cry (ch);
d923 7
a929 1
void perform_group_gain (struct char_data *ch, long base, struct char_data *victim) {
d931 4
a934 7
  /*add level bonus and group bonus */
  /*add group bonus */
  /*sprintf(buf, " base before modifier within group exp %d.\r\n", base);
    send_to_char(buf, ch);
  */
  if (GET_LEVEL (ch) < GET_LEVEL (victim))
    base = exp_highlevel_bonus (base, (GET_LEVEL (victim) - GET_LEVEL (ch)));
d936 2
a937 1
  base = exp_group_bonus (base);
d939 1
a939 6
  /*This shows exp people getting turn on at will */
  /*
  sprintf(buf, " base within group exp %ld.\r\n", base);
  log(buf);
  */
  /* share = MIN (max_exp_gain (ch), MAX (1, base)); this get's checked inside of gain_exp */
d941 1
a941 4
  if (base > 1) {
    sprintf (buf2, "You receive your share of experience.\r\n");
    send_to_char (buf2, ch);
  }
d943 2
a944 2
  gain_exp (ch, victim, base);
  change_alignment (ch, victim);
d947 1
a947 1
void group_gain (struct char_data *ch, struct char_data *victim)
d949 4
a952 11
  int tot_members = 0;
  long base, lbase, exp;
  struct char_data *k;
  struct char_data *m;
  struct group_type *f;
  struct mgroup_type *g;
  float tot_percent;
  float leader_percent;

  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
     return;
d954 1
a954 1
  k = (ch->groupmaster ? ch->groupmaster : ch);
d956 5
d962 9
a970 83
  if (EFF_FLAGGED (k, EFF_GROUP))
    ;
  else
    {
      sprintf (buf, "In group exp give and leader not grouped?:%s exiting without exp gain", GET_NAME (ch));
      mudlog (buf, NRM, LVL_GOD, FALSE);
      return;
    }
  if (EFF_FLAGGED (k, EFF_MAJOR_GROUP))
    {
      m = (k->mgroupmaster ? k->mgroupmaster : k);
      if (m->in_room == ch->in_room)
        tot_members = 1;
      for (f = m->groupees; f; f = f->next)
        if (f->groupee->in_room == ch->in_room)
          tot_members++;
      for (g = m->mgroupees; g; g = g->next)
        {
          if (g->mgroupee->in_room == ch->in_room)
            tot_members++;
          for (f = g->mgroupee->groupees; f; f = f->next)
            if (f->groupee->in_room == ch->in_room)
              tot_members++;
        }
    }
  else
    {                                /*just group count */
      if (k->in_room == ch->in_room)
        tot_members = 1;
      for (f = k->groupees; f; f = f->next)
        if (f->groupee->in_room == ch->in_room)
          tot_members++;
    }

  /* round up to the next highest tot_members */
  tot_percent = (float) 100 / tot_members;
  leader_percent = (float) .02 *tot_percent;

  tot_percent = (100 - leader_percent) / tot_members;
  leader_percent = tot_percent + leader_percent;
  if (IS_NPC (victim))
    exp = GET_EXP (victim);
  else
    /*I will give 8 k exp per level for a opp race pkill
      and a 3 k exp per level for a sim race pkill */
    if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
      exp = GET_LEVEL (victim) * 8000;
    else
      exp = GET_LEVEL (victim) * 3000;

  if (tot_members >= 1)        /*changed line below it had no affect as it was */
    /*Mark may need worked on */
    base = MAX (1, ((long) ((GET_EXP (victim) * (float) tot_percent / 100) + 1)));
  else
    base = 0;
  lbase = MAX (1, ((long) ((GET_EXP (victim) * (float) leader_percent / 100) + 1)));


  if (EFF_FLAGGED (k, EFF_MAJOR_GROUP))
    {
      m = (k->mgroupmaster ? k->mgroupmaster : k);
      if (m->in_room == ch->in_room)
        perform_group_gain (k, lbase, victim);
      for (f = m->groupees; f; f = f->next)
        if (f->groupee->in_room == ch->in_room)
          perform_group_gain (f->groupee, base, victim);
      for (g = m->mgroupees; g; g = g->next)
        {
          if (g->mgroupee->in_room == ch->in_room)
            perform_group_gain (g->mgroupee, base, victim);
          for (f = g->mgroupee->groupees; f; f = f->next)
            if (f->groupee->in_room == ch->in_room)
              perform_group_gain (f->groupee, base, victim);
        }
    }
  else
    {                                /*just group count */
      if (k->in_room == ch->in_room)
        perform_group_gain (k, lbase, victim);
      for (f = k->groupees; f; f = f->next)
        if (f->groupee->in_room == ch->in_room)
          perform_group_gain (f->groupee, base, victim);
    }
d974 1
a974 1
void receive_kill_credit(struct char_data *ch, struct char_data *vict)
d976 2
a977 3
   int exp;

   if (!(IS_NPC(vict) || vict->desc))
d983 1
a983 2
   if (EFF_FLAGGED(ch, EFF_GROUP)) {
      group_gain (ch, vict);
d985 3
a987 1
   }
a989 6

   exp = GET_EXP(vict); /* cap for exp is in max_exp_gain() in gain_exp() */

   /* Calculate level-difference bonus */
   if (IS_NPC (ch))
      exp += MAX (0, exp * MIN(2, GET_LEVEL(vict) - GET_LEVEL(ch)) >> 3);
d991 1
a991 7
      exp += MAX (0, exp * MIN(3, GET_LEVEL(vict) - GET_LEVEL(ch)) >> 3);

   exp = MAX(exp, 1);

   /*check for mortal */
   if (IS_NPC(vict))
      exp = GET_EXP(vict);
d993 1
a993 10
   /*Trophy decrease */
   exp = perform_trophy_decrease(ch, vict, exp);

   if (!ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
      send_to_char("You receive your share of experience.\r\n", ch);

   if (GET_LEVEL(ch) < GET_LEVEL(vict))
      exp = exp_highlevel_bonus(exp, GET_LEVEL(vict) - GET_LEVEL(ch));
   gain_exp(ch, vict, exp);
   change_alignment(ch, vict);
d1687 2
a1688 2
    receive_kill_credit(ch, victim);
    if (!IS_NPC (victim)) {
a1692 2
      if (MOB_FLAGGED(ch, MOB_MEMORY))
        remove_from_all_memories(victim);
a1693 1
    remove_from_all_memories(ch);
d2795 4
@


1.186
log
@Fix spelling of riposte.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.185 2008/03/28 17:54:53 myc Exp jps $
d970 1
d1021 6
d3019 3
@


1.185
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.184 2008/03/27 17:29:51 jps Exp myc $
d1922 2
a1923 2
bool ripost(struct char_data *ch, struct char_data *victim) {
  int ch_hit, vict_ripost;
d1925 1
a1925 1
  if (!GET_SKILL(victim, SKILL_RIPOST))
d1938 4
a1941 4
  vict_ripost = number(20, 50);
  vict_ripost += GET_LEVEL(victim) - GET_LEVEL(ch);
  vict_ripost -= dex_app[GET_DEX(victim)].defensive;
  vict_ripost += GET_SKILL(victim, SKILL_RIPOST) * 0.085;
d1944 1
a1944 1
    improve_skill_offensively(victim, ch, SKILL_RIPOST);
d1946 1
a1946 1
  if (vict_ripost <= ch_hit)
d1966 1
a1966 1
  hit(victim, ch, SKILL_RIPOST);
d2146 1
a2146 1
   * or barehand.  SKILL_RIPOST extends that but signifies
d2169 1
a2169 1
  if (type == SKILL_RIPOST)
d2173 1
a2173 1
  if (type == TYPE_UNDEFINED || type == SKILL_RIPOST ||
d2238 1
a2238 1
   * Some skills don't get a chance for ripost, parry, and dodge,
d2245 1
a2245 1
           (!ripost(ch, victim) &&
d3012 4
d3143 1
a3143 1
 * of hit.  Functionalized ripost, parry, and dodge.  The hit function
d3442 1
a3442 1
 * Reduced the damage of ripost.
d3485 1
a3485 1
 * mob was dying from a ripost in a hit function call.
d3493 1
a3493 1
 * the player and mob are fighting after a ripost...
d3707 1
a3707 1
 * Monk semantics for dodge/parry/ripost/attack
@


1.184
log
@Ethereal creatures are now attackable when you have the spell
effect of bless or hex.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.183 2008/03/27 00:20:35 jps Exp jps $
d161 1
a161 1
  if (ch->master && AFF_FLAGGED(ch, AFF_CHARM))
d163 1
a163 1
  if (victim->master && AFF_FLAGGED(victim, AFF_CHARM)) {
d201 1
a201 1
   if (!IS_NPC(ch) && (AFF_FLAGGED(victim, AFF_CHARM) || MOB_FLAGGED(victim, MOB_PET))) {
d212 1
a212 1
   if (AFF3_FLAGGED(ch, AFF3_BLESS) || AFF3_FLAGGED(ch, AFF3_HEX)) {
d222 2
a223 2
   affect_from_char(ch, SPELL_INVISIBLE);
   affect_from_char(ch, SPELL_NATURES_EMBRACE);
d227 2
a228 2
   REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
   REMOVE_BIT(AFF3_FLAGS(ch), AFF3_CAMOUFLAGED);
d404 2
a405 3
  if (!AWAKE(victim) || AFF2_FLAGGED(victim, AFF2_MINOR_PARALYSIS) ||
      AFF_FLAGGED(victim, AFF_MAJOR_PARA) ||
      AFF2_FLAGGED(victim, AFF2_KNOCKED_OUT)) {
d454 1
a454 1
      affect_from_char(victim, SPELL_SLEEP);
d476 1
a476 1
      affect_from_char (victim, SPELL_SLEEP);
d485 1
a485 1
    affect_from_char(victim, SPELL_SLEEP);
d511 1
a511 1
      SET_BIT (PLR_FLAGS (ch), PLR_KILLER);
d531 2
a532 2
  if (IS_AFFECTED (ch, AFF_SLEEP))
    affect_from_char (ch, SPELL_SLEEP);
d535 2
a536 4
  if (!CHECK_WAIT(ch)) {
    GET_POS(ch) = POS_FIGHTING;
    GET_STANCE(ch) = STANCE_STANDING;
  }
d580 1
a580 1
  if (MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d590 1
a590 1
  corpse->name = str_dup (buf2);
d593 1
a593 1
  corpse->description = str_dup (buf2);
d596 1
a596 1
  corpse->short_description = str_dup (buf2);
d801 4
a804 4
  while (ch->affected)
    affect_remove (ch, ch->affected);
  while (real_char->affected)
    affect_remove (real_char, real_char->affected);
d855 1
a855 1
  if (!(IS_AFFECTED (groupmaster, AFF_GROUP))) {
d860 1
a860 1
  if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP)) {
d882 1
a882 1
  if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP)) {
d953 1
a953 1
  if (GET_LEVEL(ch) < 60 && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d992 2
a993 2
   if (killer && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
      if (IS_AFFECTED (killer, AFF_GROUP)) {
d1008 2
a1009 2
   if (IS_AFFECTED2 (ch, AFF2_ON_FIRE))
      REMOVE_BIT (AFF2_FLAGS (ch), AFF2_ON_FIRE);
d1012 2
a1013 1
      REMOVE_BIT (PLR_FLAGS (ch), PLR_KILLER | PLR_THIEF);
d1081 1
a1081 1
  if (IS_AFFECTED (k, AFF_GROUP))
d1089 1
a1089 1
  if (IS_AFFECTED2 (k, AFF2_MGROUP))
d1139 1
a1139 1
  if (IS_AFFECTED2 (k, AFF2_MGROUP))
d1174 1
a1174 1
   if (MOB2_FLAGGED(vict, MOB2_ILLUSORY))
d1177 1
a1177 1
   if (AFF_FLAGGED(ch, AFF_GROUP)) {
d1622 1
a1622 1
          !number(0, 100) && AFF_FLAGGED(victim, AFF_CHARM) &&
d1667 1
a1667 1
  if (AFF_FLAGGED(ch, AFF_INVISIBLE) || IS_HIDDEN(ch))
d1675 1
a1675 1
  if (AFF_FLAGGED(ch, AFF_CHARM) || MOB_FLAGGED(ch, MOB_PET))
d1679 2
a1680 1
  if (AFF_FLAGGED(victim, AFF_SANCTUARY | AFF_STONE_SKIN))
d1684 1
a1684 1
  if (AFF_FLAGGED(victim, AFF_PROTECT_EVIL) &&
d1688 1
a1688 1
  else if (AFF_FLAGGED(victim, AFF_PROTECT_GOOD) &&
d1696 1
a1696 1
  if (AFF2_FLAGGED(victim, AFF2_MINOR_PARALYSIS)) {
d1703 3
a1705 3
    affect_from_char(victim, SPELL_MINOR_PARALYSIS);
    affect_from_char(victim, SPELL_ENTANGLE);
    REMOVE_BIT(AFF2_FLAGS(victim), AFF2_MINOR_PARALYSIS);
d1715 1
a1715 1
  if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
d1726 1
a1726 1
      if (AFF3_FLAGGED(ch, AFF3_VAMP_TOUCH)) {
d1744 1
a1744 1
  if (ch != victim && !IS_NPC(ch) && !MOB2_FLAGGED(victim, MOB2_ILLUSORY))
d1777 1
a1777 1
  if (!MOB2_FLAGGED(ch, MOB2_ILLUSORY))
d1790 2
a1791 2
    if (AFF2_FLAGGED(victim, AFF2_FIRESHIELD)) {
      if (AFF2_FLAGGED(ch, AFF2_MAJOR_GLOBE))
d1801 2
a1802 2
    if (AFF2_FLAGGED(victim, AFF2_COLDSHIELD)) {
      if (AFF2_FLAGGED(ch, AFF2_MAJOR_GLOBE))
d1813 1
a1813 1
    if (AFF2_FLAGGED(victim, AFF2_SOULSHIELD)) {
d1829 1
a1829 1
    if (shdam > 0 && !MOB2_FLAGGED(victim, MOB2_ILLUSORY))
d1868 1
a1868 1
            !AFF_FLAGGED(victim, AFF_CHARM))
d2135 1
a2135 1
  if (FIGHTING(ch) != victim && AFF_FLAGGED(ch, AFF_BLIND)) {
d2140 1
a2140 1
  if (AFF_FLAGGED(ch, AFF_INVISIBLE) || IS_HIDDEN(ch))
d2195 1
a2195 1
  calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
d2253 1
a2253 1
    dam = str_app[STRENGTH_APPLY_INDEX(ch)].todam;
d2294 1
a2294 1
      if (AFF3_FLAGGED(ch, AFF3_SPIRIT_BEAR))
d2298 1
a2298 1
      if (AFF_FLAGGED(victim, AFF_BERSERK) || AFF_FLAGGED(ch, AFF_BERSERK))
d2301 1
a2301 1
      if (AFF_FLAGGED(victim, AFF_STONE_SKIN) && number(0, 10) <= 9) {
d2477 1
a2477 1
        AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS)) {
d2483 1
a2483 1
    if (AFF_FLAGGED(ch, AFF_MAJOR_PARA)) {
d2489 1
a2489 1
    if (AFF_FLAGGED(ch, AFF_MAJOR_PARA)) {
d2515 1
a2515 1
    if (AFF_FLAGGED(ch, AFF_HASTE))
d2517 1
a2517 1
    if (AFF_FLAGGED(ch, AFF_BLUR))
d2519 1
a2519 1
    if (AFF3_FLAGGED(ch, AFF3_SPIRIT_WOLF) &&
d2529 1
a2529 1
      if (AFF_FLAGGED(ch, AFF_BLUR))
d2535 1
a2535 1
        !AFF_FLAGGED(ch, AFF_BLIND) &&
d2655 1
a2655 1
  piece->name = str_dup (parts[i].name);
d2660 1
a2660 1
      piece->short_description = str_dup (buf2);
d2662 1
a2662 1
      piece->description = str_dup (buf2);
d2666 2
a2667 2
      piece->short_description = str_dup (parts[i].sdesc);
      piece->description = str_dup (parts[i].rdesc);
d2741 1
a2741 1
 *  clear all AFFECT-flags and clear all action_delays[] associated with
d2804 1
a2804 1
  if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) || AFF_FLAGGED(ch, AFF_MAJOR_PARA))
d2817 1
a2817 1
    if (IS_NPC(tch) && !MOB2_FLAGGED(tch, MOB2_PLAYER_PHANTASM))
d2847 1
a2847 1
    if (IS_NPC(tch) && AFF_FLAGGED(ch, AFF_BERSERK))
d2857 2
a2858 2
        AFF2_FLAGGED(tch, AFF2_MINOR_PARALYSIS) ||
        AFF_FLAGGED(tch, AFF_MAJOR_PARA)))
d2887 1
a2887 1
  if (AFF3_FLAGGED(vict, AFF3_AWARE) && IS_ROGUE(ch))
d2908 1
a2908 1
  if (!IS_NPC(ch) && !AFF_FLAGGED(ch, AFF_BERSERK)) {
d2916 2
a2917 2
      AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) ||
      AFF_FLAGGED(ch, AFF_MAJOR_PARA))
d2932 1
a2932 1
  if (!IS_NPC(ch) || MOB2_FLAGGED(ch, MOB2_PLAYER_PHANTASM))
d3012 4
@


1.183
log
@Use the default damage type according to one's composition, if
your default attack is not physical.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.182 2008/03/26 23:11:17 jps Exp jps $
d212 1
a212 3
   if (weapon && IS_OBJ_STAT(weapon, ITEM_BLESS))
      return TRUE;
   if (AFF3_FLAGGED(ch, AFF3_BLESS))
d214 1
d3013 4
@


1.182
log
@Stop doing special checks for waterform and vaporform, since
now they actually change your body's composition.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.181 2008/03/26 22:14:01 jps Exp jps $
d2188 6
d3014 4
@


1.181
log
@Add some stance modifications to prevent loops between alter_hit and update_pos.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.180 2008/03/26 18:12:32 jps Exp jps $
a1684 4
  /* Waterform takes 2/3 damage */
  if (AFF2_FLAGGED(victim, AFF2_WATERFORM))
    dam *= 0.66;

d2034 1
a2034 4
  if (AFF3_FLAGGED(victim, AFF3_VAPORFORM))
    vict_dodge += GET_SKILL(victim, SKILL_DODGE) / 2;
  else
    vict_dodge += GET_SKILL(victim, SKILL_DODGE) / 10;
d3008 3
@


1.180
log
@Ethereal creatures are now vulnerable to blessed physical attacks.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.179 2008/03/26 16:44:36 jps Exp jps $
d449 1
d461 1
a467 1

d3015 3
@


1.179
log
@Replaced all checks for undead race with checks for undead lifeforce.
Replaced the undead race with the plant race.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.178 2008/03/24 08:44:03 jps Exp jps $
d210 8
d2225 3
a2227 2
   * (this applies when asleep, too!) */
  if (damage_evasion(victim, dtype)) {
d2313 2
a2314 1
    dam = dam * susceptibility(victim, dtype) / 100;
d3014 4
@


1.178
log
@Checking composition to see if a victim will evade physical damage
entirely, and to change the damage amount.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.177 2008/03/16 00:21:36 jps Exp jps $
d604 1
a604 1
  else if (GET_RACE(ch) == RACE_UNDEAD)
d3004 4
@


1.177
log
@Updated calls to kill_to_trophy().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.176 2008/03/11 19:50:55 myc Exp jps $
d2090 1
a2090 1
void hit (struct char_data *ch, struct char_data *victim, int type)
d2097 1
d2184 1
d2216 7
d2302 5
d3004 3
@


1.176
log
@Make rage depend on skill in berserking.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.175 2008/03/10 20:46:55 myc Exp myc $
d36 1
d882 1
a882 1
        kill_to_trophy(victim, &GET_TROPHY(majorgroupmaster), (1 / (float) tot_members));
d890 1
a890 1
          kill_to_trophy(victim, &GET_TROPHY(g->groupee), (1 / (float) tot_members));
d899 1
a899 1
          kill_to_trophy(victim, &GET_TROPHY(m->mgroupee), (1 / (float) tot_members));
d907 1
a907 1
            kill_to_trophy(victim, &GET_TROPHY(g->groupee), (1 / (float) tot_members));
d917 1
a917 1
        kill_to_trophy(victim, &GET_TROPHY(groupmaster), (1 / (float) tot_members));
d925 1
a925 1
          kill_to_trophy(victim, &GET_TROPHY(g->groupee), (1 / (float) tot_members));
d999 1
a999 1
         kill_to_trophy (ch, &GET_TROPHY(killer), 1.0);
d2990 3
@


1.175
log
@Renamed POS1 to 'stance'.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.174 2008/03/09 09:00:20 jps Exp myc $
d2485 1
a2485 1
      GET_RAGE(ch) += number(10, 15);
d2989 3
@


1.174
log
@Fix paralysis-breakage message. Don't let paralyzed folks fight.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.173 2008/03/09 06:38:37 jps Exp jps $
d341 1
a341 1
    GET_POS1(victim) = POS1_STANDING;
d427 1
a427 1
    if (GET_POS1(victim) != POS1_PRONE || RIDING(victim))
d433 1
a433 1
    else if (GET_POS1(victim) != POS1_PRONE)
d439 1
a439 1
      if (GET_POS1(RIDING(victim)) == POS1_STANDING) {
d449 1
a449 1
    else if (GET_POS1(victim) == POS1_STANDING) {
d458 1
a458 1
    GET_POS1(victim) = POS1_PRONE;
d470 1
a470 1
    GET_POS1(victim) = POS1_PRONE;
d529 1
a529 1
    GET_POS1(ch) = POS1_STANDING;
d559 1
a559 1
    GET_POS1(ch) = POS1_STANDING;
d763 1
a763 1
   GET_POS1(ch) = POS1_RESTING;
d967 1
a967 1
   GET_POS1(ch) = POS1_PRONE;
d2989 3
@


1.173
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.172 2008/03/09 02:07:48 jps Exp jps $
d1694 1
a1694 1
        FALSE, ch, 0, victim, TO_ROOM);
d2453 2
a2454 1
        ch->in_room != FIGHTING(ch)->in_room) {
d2989 5
@


1.172
log
@Fix previous change.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.171 2008/03/09 01:55:01 jps Exp jps $
d583 1
a583 1
  sprintf (buf2, "corpse %s", strip_ansi ((ch)->player.name));
d2988 3
@


1.171
log
@Don't let active-defense shields of illusions hurt their attackers.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.170 2008/03/08 23:51:22 jps Exp jps $
d1825 1
a1825 1
    if (shdam > 0 && !MOB2_FLAGGED(ch, MOB2_ILLUSORY))
d2988 3
@


1.170
log
@Adjust death cry logic for script vs. non-script mobs.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.169 2008/03/07 21:21:57 myc Exp jps $
d1825 1
a1825 1
    if (shdam > 0)
d2988 3
@


1.169
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.168 2008/03/06 05:11:51 myc Exp myc $
d1013 2
a1014 2
   /* show death cry if its charmed and there's a killer */
   if (IS_AFFECTED(ch, AFF_CHARM)) {
d1018 2
a1019 2
   /* always run the death trigger for uncharmed mobs, but don't death cry
    * if it returns 0 or if there's no killer */
d2988 5
@


1.168
log
@Combined the 'saved' and 'unsaved' portions of the char_specials and
player_specials structures by moving all fields of each saved structure
to its parent structure.  Also combined the skills array from the
player and mob structures since they are identical.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.167 2008/03/05 03:03:54 myc Exp myc $
d43 1
a43 1
bool DisarmRecovery (struct char_data *ch);
a2458 3
    if (ch->char_specials.action_delays[ACT_DELAY_DISARM] > 0)
      --ch->char_specials.action_delays[ACT_DELAY_DISARM];

d2472 1
a2472 1
    if (DisarmRecovery (ch) == FALSE)
d2675 1
a2675 1
bool PickupDisarmedWeapon (struct char_data *ch)
d2677 1
a2677 2
  struct obj_data *obj_i;
  bool retval = FALSE, done = FALSE;
d2685 4
a2688 2
  for (obj_i = world[ch->in_room].contents; obj_i && !done; obj_i = obj_i->next_content)
    {
d2690 4
a2693 4
      if (IS_SET (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED) && (obj_i->last_to_hold == ch))
        {
          obj_from_room (obj_i);
          obj_to_char (obj_i, ch);
d2695 1
a2695 8
          if (!IS_FIGHTING (ch))
            {
              act ("$n eagerly reaches for $p.", FALSE, ch, obj_i, 0, TO_ROOM);
            }
          else
            {
              act ("$n finally gets a steady grip on $p.", FALSE, ch, obj_i, 0, TO_ROOM);
            }
d2697 3
a2699 156
          REMOVE_BIT (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED);

          if (obj_i->name)
            sprintf (arg, "%s", obj_i->name);



          if (IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_WIELD) ||
              IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_2HWIELD))
            do_wield (ch, arg, cmd_wield, -4);

          done = TRUE;
          retval = TRUE;
        }
    }

  return retval;
}

/* Make sure 'ch' is still fighting someone.  If not, disarm penalties don't apply anymore so remove them.
 *
 */

bool DisarmCheck (struct char_data * ch)
{
  bool retval;
  struct affected_type *af, *af_next;

  if (ch->char_specials.fighting == NULL)
    {
      ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] = 0;
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] = 0;
      ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] = 0;
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] = 0;

      if (IS_AFFECTED2 (ch, AFF2_DROPPED_PRIM | AFF2_DROPPED_SECOND))
        {
          while (PickupDisarmedWeapon (ch));

          for (af = ch->affected; af; af = af_next)
            {
              af_next = af->next;
              if (af->type == SKILL_DISARM_DROPPED_WEAP)
                {
                  affect_remove (ch, af);
                }
            }
        }
      if (IS_AFFECTED (ch, AFF_FUMBLING_PRIM) || IS_AFFECTED (ch, AFF_FUMBLING_SECOND))
        {
          for (af = ch->affected; af; af = af_next)
            {
              af_next = af->next;
              if (af->type == SKILL_DISARM_FUMBLING_WEAP)
                {
                  affect_remove (ch, af);
                }
            }
        }
      retval = TRUE;
    }
  else
    {
      retval = FALSE;
    }

  return retval;
}

void HandleFumblingWeapon (struct char_data *ch, int action_delay_type, int affect_type)
{
  bool done = FALSE;
  struct affected_type *af, *af_next;

  --ch->char_specials.action_delays[(int) action_delay_type];

  if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
    {
      for (af = ch->affected; !done && af; af = af_next)
        {
          af_next = af->next;
          if (af->type == SKILL_DISARM_FUMBLING_WEAP && af->bitvector & affect_type)
            {
              affect_remove (ch, af);
              done = TRUE;
            }
        }

      act ("$n finally regains control of $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You finally regain control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
    }
  else
    {
      act ("$n is trying to get a steady grip on $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You can't seem to get a steady grip on your weapon.", FALSE, ch, 0, 0, TO_CHAR);
    }
}

void HandleDroppedWeapon (struct char_data *ch, int action_delay_type, int affect_type)
{
  bool get_weap = FALSE, aff_drop_expired = FALSE, done;
  struct affected_type *af, *af_next;

  --ch->char_specials.action_delays[(int) action_delay_type];

  if (IS_NPC (ch))
    {
      if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
        {
          get_weap = TRUE;
        }
    }
  else
    {
      if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
        {
          aff_drop_expired = TRUE;
        }
    }

  /* Here, if get_weap is true, it's time for a _MOB_ to look in room for its dropped weapon.
     When none can be found, another char picked it up, so it stops trying for it and all penalties
     don't apply anymore.  this is why the drop affect expires regardless. */

  if (get_weap)
    {
      if (PickupDisarmedWeapon (ch) == FALSE)
        {
          ch->char_specials.action_delays[(int) action_delay_type] = 0;
        }
      aff_drop_expired = TRUE;
    }
  else
    {                                /* if time to look for MOB's dislodged item */
      if (IS_NPC (ch))
        {
          act ("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
        }
    }

  /* remove either
     a) all the affect for dropped weapon if either all weapons were recovered or the weapons to be
     recovered are no longer in the room or
     b) some of the affect for dropped weapons if all weapons haven't been recovered. */

  if (aff_drop_expired)
    {
      for (af = ch->affected, done = FALSE; !done && af; af = af_next)
        {
          af_next = af->next;
          if (af->type == SKILL_DISARM_DROPPED_WEAP && af->bitvector2 & affect_type)
            {
              affect_remove (ch, af);
              done = TRUE;
            }
        }
d2701 1
d2713 8
a2720 9
 *  when the PC/MOB (whose ACT_DELAY_FUMBLING_* or ACT_DELAY_DROPPED_*
 *  action_delays are still valid) is in combat.  Since 'disarm' can't be used
 *  until after combat has been initiated, and the affects it produces are
 *  really only useful while in combat; so when the affected PC/MOB's assailant
 *  has fled the room, it'll be perfectly fine to just clear all AFFECT-flags
 *  and clear all action_delays[] associated with 'disarm'.  This includes when
 *  a weapon is dislodged and laying on the ground--the disarmed MOB will
 *  immediately pick it up, and the disarmed PC may immediately pick his/hers
 *  up.
d2724 1
a2724 1
 *  Return TRUE if the PC/MOB can attack.  Otherwise, return FALSE.
d2726 1
a2726 2

bool DisarmRecovery (struct char_data *ch)
d2728 6
a2733 1
  bool retval = FALSE;
a2734 8
  /* if not fumbling nor regaining dropped weap, let em strike back */
  if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] == 0 &&
      ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] == 0 &&
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] == 0 &&
      ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] == 0)
    {
      retval = TRUE;
    }
d2737 15
a2751 4

  if (DisarmCheck (ch))
    {
      retval = TRUE;
d2753 3
a2755 1
  /* handle PC/MOB who is fumbling their primary weapon */
d2757 1
a2757 27
  if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0 && AWAKE (ch))
    {
      HandleFumblingWeapon (ch, ACT_DELAY_FUMBLING_PRIM, AFF_FUMBLING_PRIM);
      retval = TRUE;
    }
  /* handle PCs/MOBs that are fumbling their secondary weapon */

  if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0 && AWAKE (ch))
    {
      HandleFumblingWeapon (ch, ACT_DELAY_FUMBLING_SECOND, AFF_FUMBLING_SECOND);
      retval = TRUE;
    }
  /* handle PC/MOB who has been disarmed of their primary weapon */

  if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0 && AWAKE (ch))
    {
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_PRIM, AFF2_DROPPED_PRIM);
    }
  /* handle PC/MOB who has been disarmed of their secondary weapon */

  if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0 && AWAKE (ch))
    {
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_SECOND, AFF2_DROPPED_SECOND);
    }
  /* this point can only be reached if MOB/PC is affected by disarm in some way */

  return retval;
a2759 2


d2988 6
@


1.167
log
@Changed the spell memory and trophy structures.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.166 2008/02/23 01:03:54 myc Exp myc $
d3133 1
a3133 1
    if (ch->player_specials->saved.aggressive <= 0) {
d3169 3
@


1.166
log
@Fixed the code that empties the spell list when a character dies.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.165 2008/02/16 20:31:32 myc Exp myc $
d35 1
a80 1
void trophy_update (struct char_data *ch, struct char_data *vict, float amount);
d708 1
a708 1
        GET_ALIGNMENT(ch) = BOUNDED(-1000,GET_ALIGNMENT(ch),1000);
d807 1
a807 1
  for (cur = ch->spell_list; cur; cur = cur->next)
d809 3
a811 3
  ch->num_memmed = 0;
  ch->mem_status = FALSE;
  ch->num_spells = 0;
d813 1
a813 1
    ch->spells_memmed_circle[i] = 0;
d836 1
a836 1
void kill_to_group (struct char_data *ch, struct char_data *killer, bool type) {
d880 2
a881 2
      } else {
        trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d888 2
a889 2
        } else {
          trophy_update(g->groupee, killer, (1 / (float) tot_members));
d897 2
a898 2
        } else {
          trophy_update(m->mgroupee, killer, (1 / (float) tot_members));
d905 2
a906 2
          } else {
            trophy_update(g->groupee, killer, (1 / (float) tot_members));
d915 2
a916 2
      } else {
        trophy_update(groupmaster, killer, (1 / (float) tot_members));
d923 2
a924 2
        } else {
          trophy_update(g->groupee, killer, (1 / (float) tot_members));
d997 2
a998 2
      } else {
         trophy_update (killer, ch, 1.0);
d3169 3
@


1.165
log
@Adding functions to free messages at program termination.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.164 2008/02/09 21:07:50 myc Exp myc $
d806 8
a813 16
  /* zero the mem_list */
  if (ch->spell_list) {
    cur = ch->spell_list;
    if (cur != NULL) {
      for (i = 0; i < ch->num_spells && cur; i++) {
        cur->can_cast = 0;
        cur = cur->next;
      }
      ch->num_memmed = 0;
      ch->mem_status = FALSE;
      ch->num_spells = 0;
      for (i = 0; i < (NUM_SPELL_CIRCLES + 1); i++) {
        ch->spells_memmed_circle[i] = 0;
      }
    }
  }
d3169 3
@


1.164
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.163 2008/02/09 18:29:11 myc Exp myc $
d310 26
d3177 4
@


1.163
log
@The event code now handles freeing of event objects.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.162 2008/02/09 04:27:47 myc Exp myc $
d1006 1
a1006 1
         mkgenericevent(ch, killer, 0), &(ch->events), 0);
d3151 3
@


1.162
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.161 2008/02/08 14:13:25 jps Exp myc $
d3095 1
a3095 1
  return 0;
d3151 3
@


1.161
log
@Tone down damage from shield-spells.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.160 2008/02/06 03:45:08 myc Exp jps $
d34 1
d3151 3
@


1.160
log
@Fixing a bug with some damage messages not being sent (when
skill improvements occured).
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.159 2008/01/29 21:02:31 myc Exp myc $
d1547 1
a1547 1
  int attacker_weapons, victim_weapons, dummy;
d1764 1
a1764 1
  if (ch != victim && (IS_WEAPON(attacktype) || 
d1766 1
d1774 2
a1775 2
        if (GET_LEVEL(ch) < LVL_IMMORT)
          alter_hit(ch, dam / 3, TRUE);
d1782 1
d1786 2
a1787 2
        if (GET_LEVEL(ch) < LVL_IMMORT)
          alter_hit(ch, dam / 3, TRUE);
d1795 2
a1796 2
        if (GET_LEVEL(ch) < LVL_IMMORT)
          alter_hit(ch, 3 * dam / 16, TRUE);
d1802 2
a1803 2
        if (GET_LEVEL(ch) < LVL_IMMORT)
          alter_hit(ch, 3 * dam / 16, TRUE);
d1806 2
d3150 4
@


1.159
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.158 2008/01/29 16:51:12 myc Exp myc $
d2129 3
a2131 2
  if ((type == SKILL_DUAL_WIELD || type == SKILL_2BACK)) {
    if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_WIELD2)) == ITEM_WEAPON)
d2267 6
a2272 1
    if (weapon && !number(0, 9) &&
a2275 4

    if (type == TYPE_HIT && !dam)
      type = SKILL_PUNCH;
    damage(ch, victim, dam, type);
d2516 1
a2516 1
        hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
d3146 4
@


1.158
log
@Adding the concept of contact skills and spells, for stuff like
fireshield and coldshield.  Fixing weapon specials.  Disabling
the use of non weapons as weapons.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.157 2008/01/28 03:05:33 jps Exp myc $
d33 1
a44 1
extern struct room_data *world;
a45 1
extern struct obj_data *object_list;
a51 1
extern struct dex_app_type dex_app[];
a2043 1
  extern struct index_data *obj_index;
a2069 1
  extern struct str_app_type str_app[];
a2286 3
  extern char *dirs[];
  extern int rev_dir[];

a2421 1
  extern struct index_data *mob_index;
d3144 5
@


1.157
log
@Change some messages to punch, when missing.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.156 2008/01/28 00:46:05 jps Exp jps $
d1766 2
a1767 1
  if (!IS_SPELL(attacktype) && ch != victim) {
d2044 25
d2132 13
a2144 4
  weapon_position = GET_EQ(ch, WEAR_WIELD) ? WEAR_WIELD : WEAR_2HWIELD;
  if (type == SKILL_DUAL_WIELD || type == SKILL_2BACK)
    weapon_position = WEAR_WIELD2;
  weapon = GET_EQ(ch, weapon_position);
d2153 1
a2153 1
    if (weapon && GET_OBJ_TYPE(weapon) == ITEM_WEAPON)
d2210 2
a2211 1
            !dodge(ch, victim))) {
a2422 25
int weapon_special (struct obj_data *wpn, struct char_data *ch)
{
  extern struct index_data *obj_index;
  int (*name) (struct char_data * ch, void *me, int cmd, char *argument);

  SPECIAL(blind_weapon);
  SPECIAL(fireball_weapon);
  SPECIAL(lightning_weapon);
  SPECIAL(vampiric_weapon);
  SPECIAL(fullharm_weapon);
  SPECIAL(curse_weapon);
  SPECIAL(holyw_weapon);
  SPECIAL(dispel_good_weapon);


  name = obj_index[GET_OBJ_RNUM(wpn)].func;
  if (name != blind_weapon && name != fireball_weapon &&
      name != curse_weapon && name != fullharm_weapon &&
      name != vampiric_weapon && name != lightning_weapon &&
      name != holyw_weapon && name != dispel_good_weapon)
    return 0;
  return (name)(ch, wpn, 0, "");
}


d3152 3
@


1.156
log
@Add more info to missing-message string.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.155 2008/01/27 21:09:12 myc Exp jps $
d2125 1
a2125 1
      type = SKILL_PUNCH;
d2239 2
a2241 1

d3141 3
@


1.155
log
@Stop fireshield, coldshield, and soulshield from hurting immortals.
Make characters use SKILL_PUNCH when hitting instead of TYPE_HIT
(this is the way it was before).  Initial implementation of spirit
of the wolf, spirit of the bear, and berserk.  Make players aggro
while berserking.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.154 2008/01/27 13:43:50 jps Exp myc $
d240 3
a242 1
  return action ? action : strdup("ERROR!  Message missing.");
d3140 7
@


1.154
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.153 2008/01/27 12:12:40 jps Exp jps $
d1772 2
a1773 1
        alter_hit(ch, dam / 3, TRUE);
d1783 2
a1784 1
        alter_hit(ch, dam / 3, TRUE);
d1792 2
a1793 1
        alter_hit(ch, 3 * dam / 16, TRUE);
d1799 2
a1800 1
        alter_hit(ch, 3 * dam / 16, TRUE);
d2123 1
a2123 1
      type = TYPE_HIT;
d2217 13
a2229 3
    else if (AFF_FLAGGED(victim, AFF_STONE_SKIN) && number(0, 10) <= 9) {
      decrease_modifier(victim);
      dam = number(0, 3);
d2456 1
a2456 1
      GET_RAGE(ch) += number(2, 5);
d2467 3
a2476 2
      if (AFF_FLAGGED(ch, AFF_HASTE))
        secondary_hits += 1;
d2478 1
a2478 1
        secondary_hits += 1;
d2939 3
d2972 4
d3034 1
a3034 1
  if (!IS_NPC(ch)) {
d3076 2
d3079 2
a3080 2
  if (data->ch && data->vict && data->ch->in_room == data->vict->in_room)
    hit(data->ch, data->vict, TYPE_UNDEFINED);
d3138 3
@


1.153
log
@Changed IS_THIEF macro to IS_ROGUE.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.152 2008/01/27 02:25:25 jps Exp jps $
d576 1
a576 1
  else if (GET_SPECIES(ch) == SPECIES_UNDEAD)
d3114 3
@


1.152
log
@When starting a fight, you don't get to stand up if you're lagged.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.151 2008/01/26 12:28:32 jps Exp jps $
d2990 2
a2991 2
    val /= (IS_THIEF(ch) ? 4 : 2);
  if (AFF3_FLAGGED(vict, AFF3_AWARE) && IS_THIEF(ch))
d3114 3
@


1.151
log
@Using improve_skill_offensively so that your skills won't improve
if used against illusions.  Made death into an event.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.150 2008/01/25 21:05:45 myc Exp jps $
d500 4
a503 2
  GET_POS(ch) = POS_FIGHTING;
  GET_POS1(ch) = POS1_STANDING;
d3114 4
@


1.150
log
@Rewrote perform_violence and hit.  Removed hit2.  Fireshield,
coldshield, and soulshield damage now happens in damage instead
of hit.  Functionalized ripost, parry, and dodge.  The hit function
now handles physical attacks for both hands, using the damage
type passed to it to figure out which hand.  sling_weapon no
longer requires both the weapon and position; just the position
must be passed to it now.  perform_violence has a loop for hits,
instead of repeated calls to hit.
In short, revamped the core of the combat system.  But it shouldn't
be noticable.  Everything should behave exactly the same...
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.149 2008/01/23 05:31:24 jps Exp $
d32 1
a37 1
void improve_skill (struct char_data *ch, int skill);
d67 1
d145 6
d156 1
a156 1
  if (ROOM_FLAGGED(victim->in_room, ROOM_ARENA) && 
d249 1
a249 1
  
d262 2
a263 2
  
  
d267 1
a267 1
  
d280 1
a280 1
      
d285 1
a285 1
      
d305 1
a305 1
  
d321 1
a321 1
    if (GET_LEVEL(victim) >= LVL_IMMORT && victim->desc && 
d328 1
a328 1
    if (GET_LEVEL (victim) >= LVL_IMMORT && victim->desc && 
d341 1
a341 1
  
d343 1
a343 1
  
d348 1
a348 1
   * If the victim is fighting someone, but isn't in the same room, stop 
d357 1
a357 1
   */  
d360 2
a361 2
  
  
d363 1
a363 1
   * If the victim is incapable of fighting, make sure they aren't 
d389 1
a389 1
  
d393 2
a394 2
  
  
d396 1
a396 1
   * Determine whether the position change should warrant some further 
d453 1
a453 1
  
d475 1
a475 1
      
d490 1
a490 1
  
d492 1
a492 1
  
d495 1
a495 1
  
d498 1
a498 1
  
d502 1
a502 1
  
d521 1
a521 1
  
d524 1
a524 1
  
d551 1
a551 1
  
d556 1
a556 1
  
d559 1
a559 1
  
d562 1
a562 1
  
d588 1
a588 1
  
d593 1
a593 1
  
d608 1
a608 1
  
d613 1
a613 1
  
d631 1
a631 1
  
d685 1
a685 1
  
d688 1
a688 1
  
d754 2
a755 2
  int i, is_charmed = FALSE;
  
a764 11
  
  if (FIGHTING (ch))
    stop_fighting (ch);

  /*
   * We need to save this affect before spells are removed below
   * so we can determine later on whether we should run the death
   * trigger or not. - myc 4/1/2007
   */
  if (IS_AFFECTED(ch, AFF_CHARM))
    is_charmed = TRUE;
a769 12
  
  /* show death cry if its charmed and there's a killer */
  if (is_charmed) {
    if (killer)
      death_cry (ch);
  }
  /*
   * always run the death trigger for uncharmed mobs, but don't death cry
   * if it returns 0 or if there's no killer
   */
  else if (death_mtrigger (ch, killer) && killer)
    death_cry (ch);
d791 1
a791 1
    } 
d793 1
a793 1
  
d817 1
a817 1
  
d826 1
a826 1
  
d854 1
a854 1
  
d910 1
a910 2

void die(struct char_data *ch, struct char_data *killer)
d926 35
a960 8
  /*check for switch. Original char loses exp */
  
  if (ch->desc && ch->desc->original)
    {
      gain_exp (ch->desc->original, NULL, -(exp_death_loss (ch->desc->original, GET_LEVEL (ch->desc->original))));
    }
  else
    {
d962 1
a962 1
    }
d964 9
a972 11
  /* Exp and trophy for the killer */
  if (killer && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
    if (IS_AFFECTED (killer, AFF_GROUP))
      { /*loop through group */
        /*if a BIG person got kill then dont let rest of group bludge: */
        if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25)) {
          if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)))
            ;
          else
            {
              kill_to_group (killer, ch, TRUE);
d974 4
a977 2
        }
        kill_to_group (killer, ch, FALSE);
d979 4
a982 6
    else
      {
        trophy_update (killer, ch, 1.0);
      }
    /* frag_update (killer, ch, 1.0); */
  }  
d984 1
a984 5
  if (IS_AFFECTED2 (ch, AFF2_ON_FIRE))
    REMOVE_BIT (AFF2_FLAGS (ch), AFF2_ON_FIRE);
  
  if (!IS_NPC (ch))
    {
d989 2
a990 15
    }
  abort_casting(ch);
  if (GET_LEVEL(ch) < 60 && !MOB2_FLAGGED(ch, MOB2_ILLUSORY)) {
    perform_random_gem_drop(ch); 
  }
  
  /* Need to pass the right pointer to raw_kill...I changed it
     for shapechange...so now we need to change it back.
     Zantir 2/20/01 */
  if (shapechanged == 1) {
    raw_kill (sc, killer);
  } else {
    raw_kill (ch, killer);
  }
}  
d992 9
d1002 4
d1008 1
a1009 2
void perform_group_gain (struct char_data *ch, long base, struct char_data *victim) {
  
d1014 1
a1014 1
  */ 
d1019 1
a1019 1
  
d1026 1
a1026 1
  
d1046 1
a1046 1
  
d1051 2
a1052 2
  
  
d1086 1
a1086 1
  
d1090 1
a1090 1
  
d1102 1
a1102 1
  
d1109 2
a1110 2
  
  
d1260 1
a1260 1
  }  
d1269 1
a1269 1
    
d1276 1
a1276 1
    
d1283 1
a1283 1
    
d1290 1
a1290 1
    
d1297 1
a1297 1
    
d1304 1
a1304 1
    
d1311 1
a1311 1
    
d1318 1
a1318 1
    
d1325 1
a1325 1
  
d1334 1
a1334 1
    
d1336 1
a1336 1
    
d1343 1
a1343 1
    
d1350 1
a1350 1
    
d1357 1
a1357 1
    
d1364 1
a1364 1
    
d1371 1
a1371 1
    
d1378 1
a1378 1
    
d1385 1
a1385 1
    
d1392 1
a1392 1
    
d1404 1
a1404 1
  
d1441 1
a1441 1
  
d1444 1
a1444 1
  if (w_type == SKILL_BAREHAND) 
d1451 1
a1451 1
  
d1453 1
a1453 1
  if (w_type == SKILL_BAREHAND) 
d1460 1
a1460 1
  
d1462 1
a1462 1
  if (w_type == SKILL_BAREHAND) 
d1505 1
a1505 1
 
d1535 1
a1535 1
 
d1590 1
a1590 1
       * If this is a pet attacking, there is a chance the victim will 
d1604 1
a1604 1
        sprintf(buf, "&6&b$n observes $N commanding %s and attacks $M instead!&0", 
d1607 1
a1607 1
        sprintf(buf, "&6&bYou observes $N commanding %s and attacks $M instead!&0", 
d1619 1
a1619 1
       * NPC's always start fighting, but PC's can ignore spells via 
d1637 1
a1637 1
  
d1653 1
a1653 1
  
d1717 1
a1717 1
  
d1729 1
a1729 1
   * 
d1798 1
a1798 1
  
d1815 2
a1816 2
       * Note - for death from bloodloss (TYPE_SUFFERING), the death 
       * message is different, and will be sent later when we call 
d1824 1
a1824 1
      
d1828 1
a1828 1
      
d1865 1
a1865 1
  
d1869 1
a1869 1
      sprintf(buf2, "%s killed by %s at %s [%d]", GET_NAME(victim), 
d1910 1
a1910 1
    improve_skill(victim, SKILL_RIPOST);
d1957 1
a1957 1
    improve_skill(victim, SKILL_PARRY);
d1963 1
a1963 1
    act("&7You smirk and slap $n's attack away with ease.&0", 
d2003 1
a2003 1
    improve_skill(victim, SKILL_DODGE);
d2049 1
a2049 1
  
d2054 1
a2054 1
  
d2069 1
a2069 1
  
d2084 1
a2084 1
  
d2087 1
a2087 1
  
a2215 2
    damage(ch, victim, dam, type);

d2218 1
a2218 1
      improve_skill(ch, type);
d2221 2
d2224 1
a2224 1
    
d2244 2
a2245 2
    proficiency = (GET_SKILL(ch, SKILL_2H_SLASHING) + 
                   GET_SKILL(ch, SKILL_2H_BLUDGEONING) + 
d2248 2
a2249 2
    proficiency = (GET_SKILL(ch, SKILL_SLASHING) + 
                   GET_SKILL(ch, SKILL_BLUDGEONING) + 
d2267 2
a2268 2
  /* 
   * If it was wielded in the primary hand, and there was also something 
d2372 1
a2372 1
  
d2382 1
a2382 1
  
d2401 1
a2401 1
  
d2414 1
a2414 1
      
d2427 1
a2427 1
      
d2497 1
a2497 1
    if (ALIVE_POS(ch) && MOB_FLAGGED (ch, MOB_SPEC) && 
a2503 46


void improve_skill (struct char_data *ch, int skill) {
  extern char *spells[];
  int percent, maxpercent;
  char skillbuf[MAX_STRING_LENGTH];
  
  if (IS_NPC(ch)) /* mobs don't need these CPU cycles */
    return;

  /* Skills don't improve in the PK arena. */
  if (ch->in_room != NOWHERE && ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
    return;

  percent = GET_ISKILL(ch, skill);
  maxpercent = return_max_skill(ch, skill);
  if (percent <= 0 || percent >= maxpercent)
    return;
  if (number (0, 140) > GET_WIS (ch) + GET_INT (ch))
    return;
  /* Skills with increased improvement. */
  if (skill == SKILL_FIRST_AID ||
      skill == SKILL_BANDAGE ||
      skill == SKILL_DOUSE ||
      skill == SKILL_CHANT)
    percent += number(4, 7);
  else if (skill == SKILL_TAME ||
           skill == SKILL_BASH ||
           skill == SKILL_DISARM ||
           skill == SKILL_SCRIBE ||
           skill == SKILL_SWITCH)
    percent += 2;
  else
    percent++;
  /* returns 1000 for most skills, but caps some others lower */
  if (percent >= maxpercent) {
    SET_SKILL (ch, skill, maxpercent);
    sprintf (skillbuf, "&8You feel about as skilled in %s as possible!&0\r\n", spells[skill]);
  }
  else {
    SET_SKILL (ch, skill, percent);
    sprintf (skillbuf, "&8You feel your skill in %s improving.\r\n&0", spells[skill]);
  }
  send_to_char (skillbuf, ch);
}

d2572 1
a2572 1
  
d2575 1
a2575 1
  
d2578 1
a2578 1
  
d2583 1
a2583 1
  
d2608 1
a2608 1
  
d2618 1
a2618 1
  
d2623 1
a2623 1
  
d2625 1
a2625 1
  
d2635 1
a2635 1
  
d2638 1
a2638 1
  
d2640 1
a2640 1
  
d2643 1
a2643 1
      
d2648 1
a2648 1
          
d2657 1
a2657 1
          
d2659 1
a2659 1
          
d2662 3
a2664 3
          
          
          
d2668 1
a2668 1
          
d2673 1
a2673 1
  
d2678 1
a2678 1
 * 
d2685 1
a2685 1
  
d2692 1
a2692 1
      
d2696 1
a2696 1
          
d2723 1
a2723 1
  
d2731 1
a2731 1
  
d2733 1
a2733 1
  
d2745 1
a2745 1
      
d2760 1
a2760 1
  
d2762 1
a2762 1
  
d2777 1
a2777 1
  
d2781 1
a2781 1
  
d2797 1
a2797 1
  
d2802 1
a2802 1
  
d2818 1
a2818 1
   
d2844 1
a2844 1
  
d2855 1
a2855 1
  
d2861 1
a2861 1
  
d2868 1
a2868 1
  
d2875 1
a2875 1
  
d2881 1
a2881 1
  
d2887 1
a2887 1
  
d2958 1
a2958 1
    if (!PRF_FLAGGED(ch, PRF_VICIOUS) && (!AWAKE(tch) || 
d3071 1
a3071 1
  
d3073 1
a3073 1
  
d3112 12
d3656 1
a3656 1
 * This fixes all of the warnings associated with the new compiler and 
@


1.149
log
@Move exp gain/trophy/align change to receive_kill_credit().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.148 2008/01/16 04:12:00 myc Exp jps $
d36 1
d53 1
a74 2
void hit (struct char_data *ch, struct char_data *victim, int type);
void hit2 (struct char_data *ch, struct char_data *victim, int type);
d85 1
a85 1
bool sling_weapon(struct char_data *ch, struct obj_data *weapon, int position);
d1608 1
a1608 1
        hit(ch, victim->master, TYPE_UNDEFINED);
d1767 1
d1777 1
d1785 1
d1791 1
d1885 146
d2034 2
a2035 6
  int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vw_type= 0,
    vdam = 0, skill;
  struct obj_data *wielded;
  struct obj_data *hwielded;
  struct obj_data *vwielded;
  struct obj_data *vhwielded;
a2036 1
  extern struct dex_app_type dex_app[];
d2039 1
a2039 7
  int backstab_mult (int level);
  int barehand_mult (int level);

  char b2[265];
  bool RIPOSTT = FALSE;
  bool DODGE = FALSE;
  bool PARRY = FALSE;
a2040 2
  memset(b2, 0x0, 256);
  
a2056 5
  wielded = GET_EQ (ch, WEAR_WIELD);
  hwielded = GET_EQ (ch, WEAR_2HWIELD);
  vwielded = GET_EQ (victim, WEAR_WIELD);
  vhwielded = GET_EQ (victim, WEAR_2HWIELD);
  
d2060 7
a2076 6
  if (ch->in_room != victim->in_room) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }
  
d2085 32
a2116 121
  if (GET_SKILL(victim, SKILL_DODGE))
    {
      if (GET_POS (victim) > POS_SITTING)
        {
          hurm = number (35, 171);
          hurm1 = number (20, 50);
          hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
          hurm += GET_HITROLL (ch);
          hurm -= monk_weight_pen(ch);
          /* with dex_app defensive, negative is better! -myc */
          hurm1 -= dex_app[GET_DEX (victim)].defensive;
          /* Vaporform is like a variation on waterform,
             and helps you not get hit. */
          if (IS_AFFECTED3(victim, AFF3_VAPORFORM))
            hurm1 += GET_SKILL (victim, SKILL_DODGE) / 2;
          else
            hurm1 += GET_SKILL (victim, SKILL_DODGE) / 10; 
          if (number (1, 10) < 5)
            improve_skill (victim, SKILL_DODGE);
          if (hurm1 > hurm)
            DODGE = TRUE;
        }
    }
  
  
  if (GET_SKILL (victim, SKILL_PARRY))
    {
      if (vwielded || vhwielded || GET_SKILL(victim, SKILL_BAREHAND) > 0)
        {
          if (GET_POS (victim) > POS_SITTING)
            {
              hurm = number (45, 181);
              hurm1 = number (20, 60);
              hurm += GET_HITROLL (ch);
              hurm -= monk_weight_pen(ch);
              hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
              /* with dex_app defensive, negative is better! -myc */
              hurm1 -= dex_app[GET_DEX (victim)].defensive;
              hurm1 += GET_SKILL (victim, SKILL_PARRY) / 10;
              if (number (1, 10) < 5)
                improve_skill (victim, SKILL_PARRY);
              if (hurm1 > hurm)
                {
                  PARRY = TRUE;
                }
            }
        }
    }
  
  if (GET_SKILL (victim, SKILL_RIPOST))
    {
      if (vwielded || vhwielded || GET_SKILL(victim, SKILL_BAREHAND) > 0)
        {
          if (GET_POS (victim) > POS_SITTING)
            {
              hurm = number (55, 200);
              hurm1 = number (20, 50);
              hurm += GET_HITROLL (ch);
              hurm -= monk_weight_pen(ch);
              /* with dex_app defensive, negative is better! -myc */
              hurm1 -= dex_app[GET_DEX (victim)].defensive;
              hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/10) * .85;
              hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
              if (number (1, 10) < 5)
                improve_skill (victim, SKILL_RIPOST);
              if (hurm1 > hurm)
                {
                  RIPOSTT = TRUE;
                  vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
                  vdam += GET_DAMROLL (victim);
                  
                  if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
                    vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
                  else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
                    vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
                  else
                    {
                      if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
                        vw_type = victim->mob_specials.attack_type + TYPE_HIT;
                      else if (GET_SKILL(victim, SKILL_BAREHAND) > 0)
                        vw_type = SKILL_BAREHAND;
                      else
                        vw_type = TYPE_HIT;
                    }
                  if (vwielded)
                    vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
                  else if (vhwielded)
                    vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
                  else
                    {
                      if (IS_NPC (victim))
                        {
                          vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
                        }
                      else
                        vdam += number (0, 2);
                    }
                  if (vw_type == SKILL_BAREHAND)
                    vdam += barehand_mult(GET_LEVEL(victim));
                  if (GET_POS (ch) < POS_FIGHTING)
                    vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
                  vdam = MAX (1, 70);
                }
            }
        }
    }
  
  if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
  else if (hwielded && GET_OBJ_TYPE (hwielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL (hwielded, 3) + TYPE_HIT;
  else
    {
      if (IS_NPC (ch) && (ch->mob_specials.attack_type != 0))
        w_type = ch->mob_specials.attack_type + TYPE_HIT;
      else if (GET_SKILL(ch, SKILL_BAREHAND) > 0)
        w_type = SKILL_BAREHAND;
      else
        w_type = TYPE_HIT;
    }
  
d2122 1
a2122 1
  calc_thaco -= GET_HITROLL (ch) /10 ;
d2124 2
a2125 2
  calc_thaco -= (int) ((GET_INT (ch)) / 25);        /* Int helps! */
  calc_thaco -= (int) ((GET_WIS (ch)) / 25);        /* So does wis */
d2127 1
a2127 1
  diceroll = number (1, 20);
d2129 24
a2152 6
  victim_ac = GET_AC (victim) / 10;
  
  if (AWAKE (victim))
    victim_ac += dex_app[GET_DEX (victim)].defensive;
  
  victim_ac = MAX (-10, victim_ac);        /* -10 is lowest */
d2154 17
a2170 44
/* decide whether this is a hit or a miss */
  if (((diceroll < 19) && AWAKE (victim)) 
  &&  ((diceroll == 1) || (diceroll < calc_thaco - victim_ac))) 
  {
    if (type == SKILL_BACKSTAB) 
    {
      /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
      damage (ch, victim, 0, SKILL_BACKSTAB);
      if(wielded) {
        if (diceroll == 1)
          sling_weapon(ch, wielded, WEAR_WIELD);
      } else if(hwielded) {
        if (diceroll == 1)
            sling_weapon(ch, hwielded, WEAR_2HWIELD);
      }
    } 
    else if (type == SKILL_BAREHAND) 
    {
      damage (ch, victim, 0, SKILL_BAREHAND);
    } 
    else 
   {
      /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
      if(wielded) 
      {
         damage (ch, victim, 0, w_type);
         if (diceroll == 1)
           sling_weapon(ch, wielded, WEAR_WIELD); 
      } 
      else if(hwielded) 
      {
        damage (ch, victim, 0, w_type);
        if (diceroll == 1)
          sling_weapon(ch, hwielded, WEAR_2HWIELD); 
      }
      else
        damage(ch, victim, 0, SKILL_PUNCH);
    }
  } 
  else 
  {
    /* okay, we know the guy has been hit.  now calculate damage. */
    dam = str_app[STRENGTH_APPLY_INDEX (ch)].todam;
    dam += GET_DAMROLL (ch);
d2172 1
a2172 1
    if(diceroll == 20)
a2173 108
    
    if (wielded) {
      if (!IS_NPC (ch))
        dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
      else
        dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
          dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
    } else if (hwielded) {
      if (!IS_NPC (ch))
        dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2));
      else
        dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2)) +
          dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
    } else {
      if (IS_NPC (ch)) {
        dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      } else 
        dam += number (0, 2);        /* Max. 2 dam with bare hands */
    }
      
    if (GET_POS (victim) < POS_FIGHTING)
      dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;        /*mark */
    /* Position  sitting  x 1.33 */
    /* Position  resting  x 1.66 */
    /* Position  sleeping x 2.00 */
    /* Position  stunned  x 2.33 */
    /* Position  incap    x 2.66 */
    /* Position  mortally x 3.00 */
    
    dam = MAX (1, dam);        /* at least 1 hp damage min per hit */
    
    if (type == SKILL_BACKSTAB) {
      dam *= backstab_mult (GET_LEVEL (ch));
      damage (ch, victim, dam, SKILL_BACKSTAB);
    } else if (type == SKILL_BAREHAND) {
      dam += barehand_mult (GET_LEVEL(ch));
      damage (ch, victim, dam, SKILL_BAREHAND);
    } else {
      if (RIPOSTT) {
        vdam = vdam/5;
        if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
          act ("&8You grab $n's arm and twist it, causing $m to strike $mself!&0",
              FALSE, ch, 0, victim, TO_VICT);
          act ("&8$N grabs your arm and twists it, causing you to damage to yourself!&0",
              FALSE, ch, 0, victim, TO_CHAR);
          act ("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0",
              FALSE, ch, 0, victim, TO_NOTVICT);
        } else {
          act ("&8You block $n's attack, and strike back!&0",
              FALSE, ch, 0, victim, TO_VICT);
          act ("&8$N blocks your attack, and strikes back!&0",
              FALSE, ch, 0, victim, TO_CHAR);
          act ("&7$N blocks $n's attack, and strikes back at $m!&0",
              FALSE, ch, 0, victim, TO_NOTVICT);
        }
        damage (victim, ch, vdam, vw_type);
        if (!FIGHTING (ch))
          set_fighting (ch, victim);
        if (!FIGHTING (victim))
          set_fighting (victim, ch);
      } else if (PARRY) {
        if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
          act ("&7You smirk and slap $n's attack away with ease.&0", FALSE, ch, 0, victim, TO_VICT);
          act ("&7$N smirks and slaps your attack away.&0", FALSE, ch, 0, victim, TO_CHAR);
          act ("&7$N smirks as $E slaps $n's attack away.&0", FALSE, ch, 0, victim, TO_NOTVICT);
        } else {
          act ("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
          act ("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
          act ("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
        }
        if (!FIGHTING (ch))
          set_fighting (ch, victim);
        if (!FIGHTING (victim))
          set_fighting (victim, ch);
      } else if (DODGE) {
        if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
     if (CAN_SEE(ch, victim))
        act ("&7You twist in place and watch $n attack the air nearby.&0", FALSE, ch, 0, victim, TO_VICT);
     else
        act ("&7You twist in place, avoiding $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
          act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
          act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
        } else {
          act ("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
          act ("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
          act ("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
        }
        /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
        if(wielded) {
          if (diceroll == 1)
            sling_weapon(ch, wielded, WEAR_WIELD);
        } else if(hwielded) {
          if (diceroll == 1)
            sling_weapon(ch, hwielded, WEAR_2HWIELD);
        }
        if (!FIGHTING (ch))
          set_fighting (ch, victim);
        if (!FIGHTING (victim))
          set_fighting (victim, ch);
      } else {
        if (dam > 0) {
          /*ok here we hit victem so check for stone skin */
          if (IS_AFFECTED (victim, AFF_STONE_SKIN)) {
            if (number (0, 10) <= 9) {
              decrease_modifier (victim);
              dam = number (0, 3);
            }
          }
d2175 9
a2183 18
          /* Active-defense spells hurt you! */
          if (!MOB2_FLAGGED(victim, MOB2_ILLUSORY)) {
            if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD)) {
              if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500) {
                dam = (int) (3 * dam / 4);
                GET_HIT (ch) -= (int) (dam / 4);
              }
              if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500) {
                dam = (int) (3 * dam / 4);
                GET_HIT (ch) -= (int) (dam / 4);
              }
            }
            if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD | AFF2_FIRESHIELD)) {
              if (!IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE)) {
                GET_HIT (ch) -= (int) (dam / 3);
              }
            }
          }
d2185 13
a2197 18
        }
        if (victim)
          hitprcnt_mtrigger (victim);
        damage (ch, victim, dam, w_type);
        /* improve weapon proficiencies --gurlaek 11/21/1999 */
        if(number(1,10) == 10) {
          if(wielded && (skill = weapon_proficiency(wielded, WEAR_WIELD)) != -1)
            improve_skill(ch, skill);
          if(hwielded && (skill = weapon_proficiency(hwielded, WEAR_2HWIELD)) != -1)
            improve_skill(ch, skill);
        }
      }
    }
    
    /* check if the victim has a hitprcnt trigger */
    
  }
}
d2199 1
a2199 31
void hit2 (struct char_data *ch, struct char_data *victim, int type)
{
  struct obj_data *wielded = GET_EQ (ch, WEAR_WIELD2);
  struct obj_data *vwielded = GET_EQ (victim, WEAR_WIELD);
  struct obj_data *vhwielded = GET_EQ (victim, WEAR_2HWIELD);
  int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vdam = 0,
    vw_type = 0, skill;
  int thac0_01 = 25;
  int thac0_00 = classes[(int)GET_CLASS(ch)].thac0;
  bool RIPOSTT = FALSE;
  bool DODGE = FALSE;
  bool PARRY = FALSE;
  char b2[256];  

  extern struct str_app_type str_app[];
  extern struct dex_app_type dex_app[];
  
  int backstab_mult (int level);
  int barehand_mult (int level);

  memset(b2, 0x0, 256);
  
  /* Check for PK, pets, shapechanged...etc. */
  if (!attack_ok(ch, victim, TRUE)) {
    if (FIGHTING(ch)) {
      if (FIGHTING(victim) == ch)
        stop_fighting(victim);
      stop_fighting(ch);
    }
    return;
  }
d2201 2
a2202 5
  if (ch->in_room != victim->in_room) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }
d2204 3
d2208 3
a2210 27
  if (AFF_FLAGGED(ch, AFF_INVISIBLE) || IS_HIDDEN(ch))
    appear (ch);
  
  if (GET_SKILL (victim, SKILL_DODGE))
    {
      if (GET_POS (victim) > POS_SITTING)
        {
          hurm = number (55, 171);
          hurm1 = number (20, 40);
          hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
          hurm += GET_HITROLL (ch);
          hurm -= monk_weight_pen(ch);
          /* with dex_app defensive, negative is better! -myc */
          hurm1 -= dex_app[GET_DEX (victim)].defensive;
          /* Vaporform is a sort of variation on waterform
             that helps you not get hit. */
          if (IS_AFFECTED3(victim, AFF3_VAPORFORM))
            hurm1 += GET_SKILL (victim, SKILL_DODGE) / 2;
          else
            hurm1 += GET_SKILL (victim, SKILL_DODGE) / 10; 
          if (number (1, 10) < 5)
            improve_skill (victim, SKILL_DODGE);
          if (hurm1 > hurm)
            {
              DODGE = TRUE;
            }
        }
a2211 102
  /* Parry dodge rip harder on secound hand */
  if (GET_SKILL (victim, SKILL_PARRY))
    {
      if (vwielded || vhwielded || GET_SKILL(victim, SKILL_BAREHAND) > 0)
        {
          if (GET_POS (victim) > POS_SITTING)
            {
              hurm = number (65, 171);
              hurm1 = number (15, 40);
              hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
              hurm += GET_HITROLL (ch);
              hurm -= monk_weight_pen(ch);
              /* with dex_app defensive, negative is better! -myc */
              hurm1 -= dex_app[GET_DEX (victim)].defensive;
              hurm1 += GET_SKILL (victim, SKILL_PARRY)/10;
              if (number (1, 10) < 5)
                improve_skill (victim, SKILL_PARRY);
              if (hurm1 > hurm)
                {
                  PARRY = TRUE;
                }
            }
        }
    }
  
  if (GET_SKILL (victim, SKILL_RIPOST))
    {
      if (vwielded || vhwielded || GET_SKILL(victim, SKILL_BAREHAND) > 0)
        {
          if (GET_POS (victim) > POS_SITTING)
            {
              hurm = number (90, 400);
              hurm1 = number (15, 40);
              hurm += GET_HITROLL (ch);
              hurm -= monk_weight_pen(ch);
              hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
              /* with dex_app defensive, negative is better! -myc */
              hurm1 -= dex_app[GET_DEX (victim)].defensive;
              hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/10) * .8;
              if (number (1, 10) < 5)
                improve_skill (victim, SKILL_RIPOST);
              if (hurm1 > hurm)
                {
                  RIPOSTT = TRUE;
                  vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
                  vdam += GET_DAMROLL (victim);
                  if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
                    vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
                  else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
                    vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
                  else
                    {
                      if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
                        vw_type = victim->mob_specials.attack_type + TYPE_HIT;
                      else if (GET_SKILL(victim, SKILL_BAREHAND) > 0)
                        vw_type = SKILL_BAREHAND;
                      else
                        vw_type = TYPE_HIT;
                    }
                  
                  if (vwielded)
                    vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
                  else if (vhwielded)
                    vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
                  else
                    {
                      if (IS_NPC (victim))
                        {
                          vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
                        }
                      else
                        vdam += number (0, 2);
                    }
                  
                  if (vw_type == SKILL_BAREHAND)
                    vdam += barehand_mult(GET_LEVEL(victim));
                  if (GET_POS (ch) < POS_FIGHTING)
                    vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
                  
                  vdam = MAX (1, 70);
                }
            }
        }
    }
  
  if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
  else
    {
      if (IS_NPC (ch) && (ch->mob_specials.attack_type != 0))
        w_type = ch->mob_specials.attack_type + TYPE_HIT;
      else if (GET_SKILL(ch, SKILL_BAREHAND) > 0)
        w_type = SKILL_BAREHAND;
      else
        w_type = TYPE_HIT;
    }
  
  
  
  /* Calculate the raw armor including magic armor.  Lower AC is better. */
  calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00);
  calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
d2213 1
a2213 1
  calc_thaco -= GET_HITROLL (ch) /10 ;
d2215 3
a2217 37
  calc_thaco -= (int) ((GET_INT (ch)) / 25);        /* Int helps! */
  calc_thaco -= (int) ((GET_WIS (ch)) / 25);        /* So does wis */
  diceroll = number (1, 20);
  
  victim_ac = GET_AC (victim) / 10;
  
  if (AWAKE (victim))
    victim_ac += dex_app[GET_DEX (victim)].defensive;
  
  victim_ac = MAX (-10, victim_ac);        /* -10 is lowest */

  /* decide whether this is a hit or a miss */

  /* Miss */
  if (((diceroll < 19) && AWAKE (victim)) 
  &&  ((diceroll == 1) || (diceroll < calc_thaco - victim_ac))) 
    {
      if (type == SKILL_2BACK) 
      {
        /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
        damage (ch, victim, 0, SKILL_2BACK);
        if(wielded)
          if (diceroll == 1)
            sling_weapon(ch, wielded, WEAR_WIELD2);
      } 
      else if (type == SKILL_BAREHAND) 
      {
        damage (ch, victim, 0, SKILL_BAREHAND);
      } 
      else 
      {
        /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
        damage (ch, victim, 0, w_type);
        if(wielded)
          if (diceroll == 1)
            sling_weapon(ch, wielded, WEAR_WIELD2);
      }
a2218 5
  else
    {
      /* okay, we know the guy has been hit.  now calculate damage. */
      dam = str_app[STRENGTH_APPLY_INDEX (ch)].todam;
      dam += GET_DAMROLL (ch);
d2220 5
a2224 131
      if(diceroll == 20)
        dam += dam;
      
      if (wielded)
        {
          if (!IS_NPC (ch))
            dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
          else
            dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
              dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
        }
      else
        {
          if (IS_NPC (ch))
            {
              dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
            }
          else
            dam += number (0, 2);        /* Max. 2 dam with bare hands */
        }                                /*Banyal add class mods here */
      
      if (GET_POS (victim) < POS_FIGHTING)
        dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;
      /* Position  sitting  x 1.33 */
      /* Position  resting  x 1.66 */
      /* Position  sleeping x 2.00 */
      /* Position  stunned  x 2.33 */
      /* Position  incap    x 2.66 */
      /* Position  mortally x 3.00 */
      
      dam = MAX (1, dam);        /* at least 1 hp damage min per hit */
      
      if (type == SKILL_2BACK)
        {
          dam *= backstab_mult (GET_LEVEL (ch));
          damage (ch, victim, dam, SKILL_2BACK);
        }
      else if (type == SKILL_BAREHAND)
        {
          dam += barehand_mult (GET_LEVEL(ch));
          damage (ch, victim, dam, SKILL_BAREHAND);
        }
      else
        {
          if (RIPOSTT)
            {
                vdam = vdam/5;
                if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
                  append_damage_amount(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself!&0", vdam, TO_VICT);
                  act (b2, FALSE, ch, 0, victim, TO_VICT);
                  append_damage_amount(b2, "&8$Ngrabs your arm and twists it, causing you to damage to yourself!&0", vdam, TO_CHAR);
                  act (b2, FALSE, ch, 0, victim, TO_CHAR);
                  append_damage_amount(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0", vdam, TO_NOTVICT);
                  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
                } else {
                  append_damage_amount(b2, "&8You block $n's attack, and strike back!&0", vdam, TO_VICT);
                  act (b2, FALSE, ch, 0, victim, TO_VICT);
                  append_damage_amount(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", vdam, TO_CHAR);
                  act (b2, FALSE, ch, 0, victim, TO_CHAR);
                  append_damage_amount(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", vdam, TO_NOTVICT);
                  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
                }
              damage (victim, ch, vdam, vw_type);
            }
          else if (PARRY)
            {
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
                 act ("&7You smirk and slap $n's attack away with ease.&0", FALSE, ch, 0, victim, TO_VICT);
                 act ("&7$N smirks and slaps your attack away.&0", FALSE, ch, 0, victim, TO_CHAR);
                 act ("&7$N smirks as $E slaps $n's attack away.&0", FALSE, ch, 0, victim, TO_NOTVICT);
              } else {
                 act ("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
                 act ("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
                 act ("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
              }
            }
          else if (DODGE)
            {
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
      if (CAN_SEE(ch, victim))
                  act ("&7You twist in place and watch $n attack the air nearby.&0", FALSE, ch, 0, victim, TO_VICT);
      else
        act ("&7You twist in place, avoiding $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
                act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
                act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
              } else {
                act ("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
                act ("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
                act ("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
              }
              /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
              if(wielded)
                if (diceroll == 1)
                  sling_weapon(ch, wielded, WEAR_WIELD2);
            }
          else
            {
              if (dam > 0)
                {
                  /*ok here we hit victem so check for stone skin */
                  if (IS_AFFECTED (victim, AFF_STONE_SKIN))
                    {
                      if (number (0, 10) <= 9)
                        {
                          decrease_modifier (victim);
                          dam = number (0, 3);
                        }
                    }
                  else if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
                    {
                      if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
                        {
                          dam = (int) (3 * dam / 4);
                          GET_HIT (ch) -= (int) (dam / 4);
                        }
                      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
                        {
                          dam = (int) (3 * dam / 4);
                          GET_HIT (ch) -= (int) (dam / 4);
                        }
                    }
                  
                }
              damage (ch, victim, dam, w_type);
              if(number(1,10) == 10) {
                if(wielded && (skill = weapon_proficiency(wielded, WEAR_WIELD2)) != -1)
                  improve_skill(ch, skill);
              }
            }
        }
    }
d2227 1
d2229 4
a2232 2
bool sling_weapon(struct char_data *ch, struct obj_data *weapon, int position) {
  int skill, skill_number, dir, temp, room, valid_dirs[NUM_OF_DIRS];
d2237 11
a2247 13
  if ((skill_number = weapon_proficiency(weapon, position)) == -1) {
    /* Misc types of weapons get an average of all the scores */
    if (position == WEAR_2HWIELD)
      skill = (GET_SKILL(ch, SKILL_2H_SLASHING) + 
               GET_SKILL(ch, SKILL_2H_BLUDGEONING) + 
               GET_SKILL(ch, SKILL_2H_PIERCING)) / 3;
    else
      skill = (GET_SKILL(ch, SKILL_SLASHING) + 
               GET_SKILL(ch, SKILL_BLUDGEONING) + 
               GET_SKILL(ch, SKILL_PIERCING)) / 3;
  }
  else
    skill = GET_SKILL(ch, skill_number);
d2250 2
a2251 2
  if (skill_number != -1)
    improve_skill(ch, skill_number);
d2258 1
a2258 1
  if (number(1, 81) < skill)
d2263 1
d2330 1
a2335 1
    /* these are generic type weapons.*/
d2337 2
d2342 3
a2344 5
    /* slashing weapons */
    if(position == WEAR_2HWIELD)
      return SKILL_2H_SLASHING;
    else
      return SKILL_SLASHING;
d2349 3
a2351 5
    /* bludgeoning weapons */
    if(position == WEAR_2HWIELD)
      return SKILL_2H_BLUDGEONING;
    else
      return SKILL_BLUDGEONING;
d2355 2
a2356 5
    /* piercing weapons */
    if(position == WEAR_2HWIELD)
      return SKILL_2H_PIERCING;
    else
      return SKILL_PIERCING;
d2370 8
a2377 8
  SPECIAL (blind_weapon);
  SPECIAL (fireball_weapon);
  SPECIAL (lightning_weapon);
  SPECIAL (vampiric_weapon);
  SPECIAL (fullharm_weapon);
  SPECIAL (curse_weapon);
  SPECIAL (holyw_weapon);
  SPECIAL (dispel_good_weapon);
d2380 1
a2380 1
  name = obj_index[GET_OBJ_RNUM (wpn)].func;
d2386 1
a2386 1
  return (name) (ch, wpn, 0, "");
d2391 1
a2395 3
  struct char_data *tch;
  struct char_data *vict;
  struct obj_data *wpn;
d2397 1
a2397 2
  int prob, hurm, hurm2;
  bool tmp_flag;
d2399 9
a2407 11
  for (ch = combat_list; ch; ch = next_combat_list)
    {
      next_combat_list = ch->next_fighting;
      if (FIGHTING (ch) == NULL
          || ch->in_room != FIGHTING (ch)->in_room
          || GET_POS(FIGHTING(ch)) == POS_DEAD)
        {
          stop_fighting (ch);
          continue;
        }
      tmp_flag = FALSE;
d2409 2
a2410 2
      if (ch->char_specials.action_delays[ACT_DELAY_DISARM] > 0)
        --ch->char_specials.action_delays[ACT_DELAY_DISARM];
d2412 11
a2422 14
      if (IS_AFFECTED (ch, AFF_MAJOR_PARA))
        {
          send_to_char ("You remain paralyzed and can't do a thing to defend yourself..\r\n",
                        ch);
          act ("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
               FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
          continue;
        }
      if (IS_AFFECTED (ch, AFF_MAJOR_PARA))
        {
          act ("You couldn't budge a feather in your present condition.", FALSE, ch, 0, 0, TO_CHAR);
          act ("$n is too preoccupied with $s nervous system problem to fight.", FALSE, ch, 0, 0, TO_ROOM);
          continue;
        }
d2425 5
a2429 8
      if (DisarmRecovery (ch) == FALSE)
        continue;
      if (CASTING(ch))
        continue;
      if (GET_POS(ch) < POS_FIGHTING) {
        send_to_char("You can't fight while sitting!!\r\n", ch);
        continue;
      }
d2431 67
a2497 189
      
      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
          GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
        {
          if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
            hit (ch, FIGHTING(ch), SKILL_BAREHAND);
          else
            hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
          if (IS_AFFECTED (ch, AFF_HASTE) && FIGHTING (ch))
            {
              if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
                  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                {
                  if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                    hit (ch, FIGHTING(ch), SKILL_BAREHAND);
                  else
                    hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
                }
            }
          if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
            {
              if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
                  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                {
                  if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                    hit (ch, FIGHTING(ch), SKILL_BAREHAND);
                  else
                     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
                }
            }
        }
      
      /* Make sure the person didn't die from a ripost above...
         This fixes the blob bug, which isn't specific to the blob
         it just happened that the mob was dying from a ripost
         above then coming to the MOB_FLAGGED line and the mud
         barfed...because the mob died and had been freed.
         DCE 12-13-01 */
      if (GET_POS(ch) == POS_DEAD) {
        stop_fighting(ch);
        continue;
      }
      
      if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
        (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
      
      if (IS_NPC (ch))
        if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
          {
            vict = NULL;
            for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
              if (FIGHTING (tch) == ch && !IS_NPC (tch))
                if (vict == NULL || GET_HIT (tch) < GET_HIT (vict))
                  vict = tch;
            
            if (vict != NULL && FIGHTING (ch) != vict)
              {
                
                if (!IS_AFFECTED (ch, AFF_BLIND))
                  if (!affected_by_spell (ch, SPELL_BLINDNESS))
                    if (!affected_by_spell (ch, SPELL_SMOKE))
                      if (CAN_SEE(ch, vict))
                        if (!number (0, (MAX (10, (30 - GET_LEVEL (ch))))))
                          {
                            stop_fighting (ch);
                            act ("$n switches to $N!", FALSE, ch, 0, vict, TO_ROOM);
                            if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                               hit (ch, vict, SKILL_BAREHAND);
                            else
                               hit (ch, vict, TYPE_UNDEFINED);
                          }
              }
          }
      
      
      if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
        {
          
          struct obj_data *wielded2 = GET_EQ (ch, WEAR_WIELD2);
          
          if (wielded2)
            {
              prob = 0;
              prob = GET_SKILL (ch, SKILL_DUAL_WIELD);
              if (GET_LEVEL (ch) < 15)
                if (number (0, 2))
                  prob = prob - 10;
              if (number (1, 101) < prob)
                {
                  if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                    {
                      if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                         hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
                      else
                         hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
                      improve_skill (ch, SKILL_DUAL_WIELD);
                    }
                  if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
                    (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
                  if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
                    {
                      hurm = 0;
                      hurm = number (1, 100);
                      hurm2 = 0;
                      hurm2 = number (1, 101);
                      if (hurm < prob)
                        {
                          if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                            {
                             if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                                      hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
                                else
                                 hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
                              improve_skill (ch, SKILL_DUAL_WIELD);
                            }
                        }
                    }
                }
              
              if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
                {
                  prob = 0;
                  prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
                  if (GET_LEVEL (ch) < 15)
                    if (number (0, 2))
                      prob = prob - 10;
                  
                  if (number (1, 101) < prob)
                    {
                      if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON ||
                          !weapon_special (wpn, ch)) {
                        if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                          hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
                        else
                          hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
                      }
                      if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
                        (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
                      improve_skill (ch, SKILL_DUAL_WIELD);
                    }
                }
            }
        }
      
      if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
        {
          prob = 0;
          prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
          
          if (GET_LEVEL (ch) < 15)
            if (number (0, 2))
              prob = prob - 10;
          
          if (number (1, 101) < prob)
            {
              if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
                  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch)) {
                if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                  hit (ch, FIGHTING(ch), SKILL_BAREHAND);
                  else
                    hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
              }              
              if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
                (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
              improve_skill (ch, SKILL_DOUBLE_ATTACK);
            }
        }
      
      if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
        {
          prob = 0;
          prob = number (1, 101);
          if ((number (1, 101) - GET_LEVEL (ch) + 10) < prob)
            {
              if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
                  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                {
                  if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
                     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
                  else
                     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
                }
            }
        }
      
      if (tmp_flag)
        continue;
      
    }
d2523 3
a2525 3
          skill == SKILL_BANDAGE ||
          skill == SKILL_DOUSE ||
          skill == SKILL_CHANT)
d2528 4
a2531 4
          skill == SKILL_BASH ||
          skill == SKILL_DISARM ||
          skill == SKILL_SCRIBE ||
          skill == SKILL_SWITCH)
d3155 3
@


1.148
log
@Adding quick-aggro event.  Moved pick_target from mobact and named
it find_aggr_target.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.147 2008/01/14 21:29:06 myc Exp myc $
a1132 2
  
  
d1136 42
d1184 1
a1184 1
  
d1186 1
a1186 1
  
d1206 1
a1206 1
      
d1209 1
a1209 1
  
a1541 2

  long exp;
d1557 1
a1557 1
  
d1860 1
a1860 30
    if (IS_NPC(victim) || victim->desc) {
      if (MOB2_FLAGGED(victim, MOB2_ILLUSORY));
      else if (AFF_FLAGGED(ch, AFF_GROUP))
        group_gain (ch, victim);
      else {
        exp = GET_EXP (victim); /* cap for exp is in max_exp_gain() in gain_exp() */
        /* Calculate level-difference bonus */
        if (IS_NPC (ch))
          exp += MAX (0, exp * MIN(2, GET_LEVEL(victim) - GET_LEVEL(ch)) >> 3);
        else
          exp += MAX (0, exp * MIN(3, GET_LEVEL(victim) - GET_LEVEL(ch)) >> 3);

        exp = MAX(exp, 1);

        /*check for mortal */
        if (IS_NPC (victim))
          exp = GET_EXP (victim);

        /*Trophy decrease */
        exp = perform_trophy_decrease(ch, victim, exp);

        if (!ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
           send_to_char("You receive your share of experience.\r\n", ch);

        if (GET_LEVEL(ch) < GET_LEVEL(victim))
          exp = exp_highlevel_bonus(exp, GET_LEVEL(victim) - GET_LEVEL(ch));
        gain_exp(ch, victim, exp);
        change_alignment (ch, victim);
      }
    }
d3699 4
@


1.147
log
@Moved is_aggr_to here from mobact.c.  Fixed up the do_aggr command,
but disabled the player quick-aggro feature.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.146 2008/01/13 23:06:04 myc Exp myc $
d31 1
d3532 2
d3545 1
a3545 2
    if (IS_NPC(tch) && GET_AGGR_LEV(ch) > 0 &&
        GET_AGGR_LEV(ch) < GET_HIT(ch) && is_aggr_to(tch, ch))
d3552 86
d3690 4
@


1.146
log
@Removed the number_of_groupees function.  Use group_size.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.145 2008/01/12 19:08:14 myc Exp myc $
d30 1
d39 1
d63 1
a80 1
bool is_aggr_to (struct char_data *ch, struct char_data *target);
d3485 65
d3555 4
a3558 3
  char Abuf[MAX_STRING_LENGTH];
  
  if (IS_NPC (ch))
d3560 1
d3562 1
a3562 1
  one_argument (argument, Abuf);
d3564 4
a3567 39
  if (*Abuf == '\0')
    {                                /*No argument is a check of aggressivity */
      
      if (ch->player_specials->saved.aggressive == -1)
        {
          send_to_char ("You are not aggressive to monsters.\r\n", ch);
          return;
        }
      sprintf (Abuf, "You will be aggressive unless hp < %d.\r\n",
               ch->player_specials->saved.aggressive);
      
      send_to_char (Abuf, ch);
      return;
    }
  else if (!str_cmp (Abuf, "off") || atoi (Abuf) >= GET_MAX_HIT (ch))
    
    if (GET_CLASS (ch) == CLASS_ANTI_PALADIN)
      {
        send_to_char ("What?  Let somebody else get the first blow?  Not a chance!\r\n", ch);
        return;
      }
    else
      {
        ch->player_specials->saved.aggressive = -1;
        send_to_char ("You are no longer aggressive to monsters.\r\n", ch);
        return;
      }
  else
    {                                /* Turn on aggressivity */
      
      int hp = atoi (Abuf);
      
      if (hp < 0)
        {
          send_to_char ("Aggressive while dying?  Not likely!\r\n", ch);
          return;
        }
      ch->player_specials->saved.aggressive = hp;
      send_to_char ("OK.\r\n", ch);
d3570 21
d3602 3
@


1.145
log
@Renamed 'Forgive_the_basterd' as 'remove_from_all_memories'.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.144 2008/01/10 23:12:07 myc Exp myc $
a76 1
int number_of_groupees (struct char_data *ch);
d3547 3
@


1.144
log
@When returning to a conscious position from incapacitation or below,
a message will be shown saying the victim sits up. (update_pos)
Also cleaned up update_pos a lot more, and (I think) determined the
purpose of the crazy code.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.143 2008/01/10 06:47:49 myc Exp myc $
d82 1
a82 1
void Forgive_The_Basterd(struct char_data *ch);
d809 1
a809 1
  Forgive_The_Basterd(ch);
a996 1
  /* Forgive_The_Basterd(ch); this is done it raw_kill */
d1856 1
a1856 1
        Forgive_The_Basterd(victim);
d1858 1
a1858 1
    Forgive_The_Basterd(ch);
d3548 6
@


1.143
log
@Updated skill_message to work with healing messages.  Also cleaned it
up significantly.  Moved the call to update_pos in damage to occur after
the call to skill_message, since update_pos may display some messages
that make more sense after the damage message.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.142 2008/01/10 05:39:43 myc Exp myc $
d301 25
d330 2
a331 1
  int tmp;
d379 1
a379 23
  if (GET_HIT(victim) > 0 && GET_POS(victim) < POS_SLEEPING) {
    GET_POS(victim) = POS_STANDING;
    GET_POS1(victim) = POS1_STANDING;
  }
  else if (GET_HIT(victim) <= HIT_DEAD) {
    GET_POS(victim) = POS_DEAD;
  }
  else if (GET_HIT(victim) <= HIT_MORTALLYW) {
    GET_POS(victim) = POS_MORTALLYW;
    StopMercifulAttackers(victim);
    if (GET_LEVEL(victim) >= LVL_IMMORT && victim->desc && 
        victim->desc->original)
      do_return(victim, "", 0, 1);
  }
  else if (GET_HIT(victim) <= HIT_INCAP) {
    GET_POS(victim) = POS_INCAP;
    StopMercifulAttackers(victim);
    if (GET_LEVEL (victim) >= LVL_IMMORT && victim->desc && 
        victim->desc->original)
      do_return(victim, "", 0, 1);
  }
  else if (GET_HIT(victim) < 0)
    GET_POS (victim) = POS_STUNNED;
d386 14
a399 34
  if (GET_POS(victim) < POS_RESTING) {
    tmp = 0;
    switch (GET_POS1(victim)) {
      case POS1_KNEELING:
        switch(GET_POS(victim)) {
          case POS_DEAD:
            if (RIDING(victim))
              tmp = 1;
            else if (!number(0, 9))
              tmp = 1;
            break;
          case POS_MORTALLYW:
          case POS_INCAP:
          case POS_SLEEPING:
            if (RIDING(victim)) {
              if (!number(0, 1))
                tmp = 1;
            }
            else if (!number(0, 9))
              tmp = 1;
            break;
        }
        break;

      case POS1_SITTING:
        if (GET_POS(victim) == POS_DEAD) {
          if (RIDING(victim)) {
            if (!number(0, 1))
              tmp = 1;
          }
          else if (!number(0, 9))
            tmp = 1;
        }
        break;
d401 5
a405 27
      case POS1_STANDING:
        switch (GET_POS(victim)) {
          case POS_DEAD:
            tmp = 1;
            break;
          case POS_MORTALLYW:
          case POS_INCAP:
          case POS_SLEEPING:
            if (RIDING (victim))
              tmp = 1;
            else if (!number (0, 5))
              tmp = 1;
            break;
        }
        break;
    }

    if (tmp) {
      tmp = 0;
      if (RIDING (victim)) {
        tmp = 1;
        if (GET_POS1(RIDING(victim)) == POS1_STANDING) {
          alter_hit(victim, dice (3, 8), TRUE);
          WAIT_STATE(victim, PULSE_VIOLENCE + 2);
        }
        act ("$n falls of $s mount!", TRUE, victim, 0, 0, TO_ROOM);
        dismount_char (victim);
d407 11
a417 8
      else if (GET_POS1(victim) == POS1_STANDING) {
        tmp = 0;
        if (!number(0, 2)) {
          alter_hit (victim, dice (3, 5), TRUE);
          if (GET_POS (victim) > POS_INCAP)
            WAIT_STATE (victim, PULSE_VIOLENCE + 2);
          tmp = 1;
        }
d425 12
a436 29
    if (GET_HIT(victim) > 0 && GET_POS(victim) < POS_SLEEPING) {
      GET_POS(victim) = POS_SITTING;
      GET_POS1(victim) = POS1_SITTING;
    }
    else if (GET_HIT(victim) <= HIT_DEAD)
      GET_POS(victim) = POS_DEAD;
    else if (GET_HIT(victim) <= HIT_MORTALLYW) {
      GET_POS(victim) = POS_MORTALLYW;
      StopMercifulAttackers(victim);
      if (GET_LEVEL(victim) >= LVL_IMMORT && victim->desc && 
          victim->desc->original)
        do_return(victim, "", 0, 1);
    }
    else if (GET_HIT(victim) <= HIT_INCAP) {
      GET_POS(victim) = POS_INCAP;
      StopMercifulAttackers(victim);
      if (GET_LEVEL(victim) >= LVL_IMMORT && victim->desc && 
          victim->desc->original)
        do_return(victim, "", 0, 1);
    }
         
    if (tmp && GET_POS(victim) < POS_RESTING) {
      if (affected_by_spell(victim, SPELL_SLEEP))
        affect_from_char (victim, SPELL_SLEEP);
      if (GET_POS(victim) == POS_SLEEPING) {
        GET_POS(victim) = POS_RESTING;
        send_to_char ("Huh?!? You find yourself lying on the ground!\r\n", victim);
      }
    }
d439 4
a442 5
  /*
  if (GET_POS(victim) == POS_SLEEPING) && (pos > POS_SLEEPING)) {
    act ("$n has a RUDE awakening!", TRUE, victim, 0, 0, TO_ROOM);
    affect_from_char (victim, SPELL_SLEEP);
    do_wake (victim, "", 0, 0);
a443 1
  */
d3549 6
@


1.142
log
@Tried to clean up the formatting in update_pos a bit.  It still seems
to have a great deal of superfluous code, but I can't tell what it's
supposed to do, so I don't want to remove it.

damage() now returns the amount of damage it caused.  Negative values
indicate healing, and a return value of VICTIM_DEAD indicates that the
victim is dead.

alter_hit now takes a boolean specifying whether to cap any increase in
hitpoints by the victim's max hp.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.141 2008/01/06 23:50:47 jps Exp myc $
d1494 2
d1515 1
a1515 12
          
         if (!IS_NPC (vict) && (GET_LEVEL (vict) >= LVL_IMMORT)) {
            /* IMMORTAL MESSAGE */

            /* to damager */
            if (ch != vict) {
               if (dam > 0)
                  append_damage_amount(b2, msg->god_msg.attacker_msg, dam, TO_CHAR);
               else
                  sprintf(b2, "%s", msg->god_msg.attacker_msg);
               act(b2, FALSE, ch, weap, vict, TO_CHAR);
            }
d1517 7
a1523 3
            /* to victim */
            if (dam > 0)
               append_damage_amount(b2, msg->god_msg.victim_msg, dam, TO_VICT);
d1525 10
a1534 49
               sprintf(b2, "%s", msg->god_msg.victim_msg);
            act(b2, FALSE, ch, weap, vict, TO_VICT);

            /* to room */
            if (dam > 0)
               append_damage_amount(b2, msg->god_msg.room_msg, dam, TO_NOTVICT);
            else
               sprintf(b2, "%s", msg->god_msg.room_msg);
            act(b2, FALSE, ch, weap, vict, TO_NOTVICT);
         } else if (dam != 0) {
            if (GET_POS (vict) == POS_DEAD) {
               /* DEATH MESSAGE */

               /* to damager */
               if (ch != vict) {
                  append_damage_amount(b2, msg->die_msg.attacker_msg, dam, TO_CHAR);
                  act(b2, FALSE, ch, weap, vict, TO_CHAR);
               }

               /* TO VICTIM */
               append_damage_amount(b2, msg->die_msg.victim_msg, dam, TO_VICT);
               act(b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);

               /* TO ROOM */
               append_damage_amount(b2, msg->die_msg.room_msg, dam, TO_NOTVICT);
               act(b2, FALSE, ch, weap, vict, TO_NOTVICT);
            } else {
               /* NORMAL DAMAGE */

               /* to damager: don't display if damaging self, otherwise
                  you get (null) for poison, on fire, circle of fire */
               if (ch != vict) {
                  append_damage_amount(b2, msg->hit_msg.attacker_msg, dam, TO_CHAR);
                  act(b2, FALSE, ch, weap, vict, TO_CHAR);
               }

               /* to victim */
               append_damage_amount(b2, msg->hit_msg.victim_msg, dam, TO_VICT);
               act(b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);

               /* to room */
               append_damage_amount(b2, msg->hit_msg.room_msg, dam, TO_NOTVICT);
               act(b2, FALSE, ch, weap, vict, TO_NOTVICT);
            }
         } else if (ch != vict) {
            /* MISS MESSAGE (dam == 0) */

            /* TO DAMAGER */
            append_damage_amount(b2, msg->miss_msg.attacker_msg, dam, TO_CHAR);
d1536 1
d1538 8
a1545 8
            /* TO VICTIM */
            append_damage_amount(b2, msg->miss_msg.victim_msg, dam, TO_CHAR);
            act(b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);

            /* TO ROOM */
            append_damage_amount(b2, msg->miss_msg.room_msg, dam, TO_NOTVICT);
            act(b2, FALSE, ch, weap, vict, TO_NOTVICT);
         }
a1704 1
    update_pos(victim);
d1764 3
d3603 12
@


1.141
log
@Added spells project and simulacrum, and MOB2_ILLUSORY flag.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.140 2008/01/06 17:34:15 jps Exp jps $
d60 1
d289 3
d303 1
a303 1
void update_pos (struct char_data *victim)
d305 1
a305 1
  int tmp, pos, pos1;
d307 1
a307 1
  ACMD (do_wake);
d309 1
a309 1
  if(event_target_valid(victim) == FALSE)
d311 14
a325 3
  if (IS_FIGHTING (victim))
    if (victim->in_room != FIGHTING (victim)->in_room)
      stop_fighting (victim);
d327 22
a348 26
  if (RIDING (victim))
    if (RIDING (victim)->in_room != victim->in_room)
      dismount_char (victim);
  
  
  /* some chesck to make pos cleaner and work well with the mud Banyal */
  if (!AWAKE (victim) || IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS)
      || IS_AFFECTED (victim, AFF_MAJOR_PARA) ||
      IS_AFFECTED2 (victim, AFF2_KNOCKED_OUT) || (GET_POS (victim) < POS_SLEEPING))
    {
      if (IS_FIGHTING (victim))
        stop_fighting (victim);
      StopMercifulAttackers (victim);
    }
  /* check for mobs, if they can assume their default position */
  if (IS_NPC (victim) && (GET_POS (victim) > POS_SLEEPING) &&
      !IS_FIGHTING (victim) && !GET_MOB_WAIT (victim) &&
      ((victim->mob_specials.default_pos) > POS_SLEEPING) &&
      (MOB_FLAGGED (victim, MOB_MEMORY) && !MEMORY (victim)))
    {
      GET_POS (victim) = victim->mob_specials.default_pos;
    }
  
  /* Lets dive into updating for current hitpoints this MUSt be first
     so that any following checks are current and reflect the
     players  current diliema...Banyal */
d350 26
a375 36
  if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
    {
      GET_POS (victim) = POS_STANDING;
      GET_POS1 (victim) = POS1_STANDING;
    }
  else if (GET_HIT (victim) <= HIT_DEAD)
    {
      GET_POS (victim) = POS_DEAD;
    }
  else if (GET_HIT (victim) <= HIT_MORTALLYW)
    {
      GET_POS (victim) = POS_MORTALLYW;
      StopMercifulAttackers (victim);
      if (GET_LEVEL (victim) >= LVL_IMMORT)
        if (victim->desc && victim->desc->original)
          do_return (victim, "", 0, 1);
    }
  else if (GET_HIT (victim) <= HIT_INCAP)
    {
      GET_POS (victim) = POS_INCAP;
      StopMercifulAttackers (victim);
      if (GET_LEVEL (victim) >= LVL_IMMORT)
        if (victim->desc && victim->desc->original)
          do_return (victim, "", 0, 1);
    }
  else if (GET_HIT (victim) < 0)
    {
      GET_POS (victim) = POS_STUNNED;
    }
  else
    {
      pos = GET_POS (victim);
    }
  /* Lets cut out some typing heh Banyal */
  pos = GET_POS (victim);
  pos1 = GET_POS1 (victim);
d382 16
a397 12
  if (pos < POS_RESTING)
    {
      tmp = 0;
      switch (GET_POS1 (victim))
        {
        case POS1_PRONE:
          break;
        case POS1_KNEELING:
          switch (GET_POS (victim))
            {
            case POS_DEAD:
              if (RIDING (victim))
a398 21
              else
                {
                  if (!number (0, 9))
                    tmp = 1;
                }
              break;
            case POS_MORTALLYW:
            case POS_INCAP:
            case POS_SLEEPING:
              /*mark new */
              if (RIDING (victim))
                {
                  if (!number (0, 1))
                    tmp = 1;
                }
              else
                {
                  if (!number (0, 9))
                    tmp = 1;
                }
              break;
d400 10
a409 24
          break;
        case POS_SITTING:
          switch (pos)
            {
            case POS_DEAD:
              if (RIDING (victim))
                {
                  if (!number (0, 1))
                    tmp = 1;
                }
              else
                {
                  if (!number (0, 9))
                    tmp = 1;
                }
              break;
            }
          break;
          /*end mark */
          
        case POS1_STANDING:
          switch (pos)
            {
            case POS_DEAD:
d411 3
a413 14
              break;
            case POS_MORTALLYW:
            case POS_INCAP:
            case POS_SLEEPING:
              if (RIDING (victim))
                tmp = 1;
              else
                {
                  if (!number (0, 5))
                    tmp = 1;
                }
              break;
            }
          break;
d415 13
a427 5
      if (tmp)
        {
          tmp = 0;
          if (RIDING (victim))
            {
d429 23
a451 77
              switch (GET_POS1 (RIDING (victim)))
                {
                case POS1_PRONE:
                case POS1_KNEELING:
                case POS1_SITTING:
                  break;
                case POS1_STANDING:
                  alter_hit (victim, dice (3, 8), 2);
                  WAIT_STATE (victim, PULSE_VIOLENCE + 2);                /* this will be stun when it
                                                                           it is coded MARKSTUN */
                  break;
                }
              act ("$n falls of $s mount!", TRUE, victim, 0, 0, TO_ROOM);
              dismount_char (victim);
            }
          else
            {
              switch (pos1)
                {
                case POS1_PRONE:
                case POS1_KNEELING:
                case POS1_SITTING:
                  break;
                case POS_STANDING:
                  tmp = 0;
                  if (!number (0, 2))
                    {
                      alter_hit (victim, dice (3, 5), 2);
                      if (GET_POS (victim) > POS_INCAP)
                        WAIT_STATE (victim, PULSE_VIOLENCE + 2);
                      tmp = 1;
                    }
                  act ("$n slumps to the ground.", TRUE, victim, 0, 0, TO_ROOM);
                  break;
                }
            }
          pos1 = POS1_PRONE;
          
          /* RE-chECK POSTION WITH NEW HITPOINTS */
         if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
           {
             GET_POS (victim) = POS_SITTING;
             GET_POS1 (victim) = POS1_SITTING;
           }
         else if (GET_HIT (victim) <= HIT_DEAD)
           GET_POS (victim) = POS_DEAD;
         else if (GET_HIT (victim) <= HIT_MORTALLYW)
           {
             GET_POS (victim) = POS_MORTALLYW;
             StopMercifulAttackers (victim);
             if (GET_LEVEL (victim) >= LVL_IMMORT)
               if (victim->desc && victim->desc->original)
                 do_return (victim, "", 0, 1);
           }
         else if (GET_HIT (victim) <= HIT_INCAP)
           {
             GET_POS (victim) = POS_INCAP;
             StopMercifulAttackers (victim);
             if (GET_LEVEL (victim) >= LVL_IMMORT)
               if (victim->desc && victim->desc->original)
                 do_return (victim, "", 0, 1);
           }
         else
           {
             pos = GET_POS (victim);
           }
         
         if (tmp && (pos < POS_RESTING))
           {
             if (affected_by_spell (victim, SPELL_SLEEP))
               affect_from_char (victim, SPELL_SLEEP);
             if (pos == POS_SLEEPING)
               {
                 pos = POS_RESTING;
                 send_to_char ("Huh?!? You find yourself lying on the ground!\r\n", victim);
               }
           }
d453 2
d456 32
a487 5
  if ((GET_POS (victim) == POS_SLEEPING) && (pos > POS_SLEEPING))
    {
      act ("$n has a RUDE awakening!", TRUE, victim, 0, 0, TO_ROOM);
      affect_from_char (victim, SPELL_SLEEP);
      do_wake (victim, "", 0, 0);
d489 9
a497 2
  GET_POS (victim) = pos;
  GET_POS1 (victim) = pos1;
d499 8
a506 8
  /*Some sanity checks lets not leave dead people to be found by code
    elsewhere */
  if (pos == POS_DEAD)
    {
      if (IS_FIGHTING (victim))
        stop_fighting (victim);
    }
  /*mark69 */
d758 1
a758 1
      alter_hit(ch, -(abs(GET_HIT(ch)) + 5), 1);
d1595 2
a1596 2
void damage (struct char_data *ch, struct char_data *victim, int dam,
             int attacktype)
d1600 1
a1600 4
  struct obj_data *wielded = GET_EQ(ch, WEAR_WIELD);
  struct obj_data *hwielded = GET_EQ(ch, WEAR_2HWIELD);
  struct obj_data *vwielded = GET_EQ(victim, WEAR_WIELD);
  struct obj_data *vhwielded = GET_EQ(victim, WEAR_2HWIELD);
d1603 1
a1603 1
  if (GET_POS (victim) <= POS_DEAD) {
d1606 2
a1607 2
    log (buf);
    return;
d1609 6
d1616 18
d1635 1
a1635 1
    return;
d1639 3
a1641 1
      if (attacktype >= MAX_SPELLS && !FIGHTING(ch))
d1643 5
d1667 1
a1667 1
        return;
d1670 2
d1673 14
a1686 8
      if (attacktype >= MAX_SPELLS ||
          (!PRF_FLAGGED(victim, PRF_PASSIVE) && attacktype < MAX_SPELLS) ||
          (IS_NPC(victim) && attacktype < MAX_SPELLS))
        set_fighting (victim, ch);
    }
    if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch) &&
        (GET_LEVEL(ch) < LVL_IMMORT))
      remember (victim, ch);
a1700 4
  /* You can't damage an immortal! */
  if (!IS_NPC(victim) && GET_LEVEL(victim) >= LVL_IMMORT)
    dam = 0;

d1722 4
a1737 8
  /*
   * Justice is defunct now.
   *
  check_justice(ch, victim);
  if (ch->desc && ch->desc->original)        
    check_justice(ch->desc->original, victim);
  */

d1741 2
a1742 2
  /* Cap damage at 1000 */
  dam = MAX(MIN (dam, 1000), 0);
d1747 1
a1747 1
    alter_hit(victim, dam, 2);
d1750 7
a1756 2
    /* Vampiric touch? */
    if (!wielded && !hwielded && !vhwielded && !vwielded && ch != victim) {
d1759 1
a1759 1
          alter_hit(ch, -dam / 2, 2);
d1761 1
a1761 1
          alter_hit(ch, -dam, 2);
d1767 1
a1767 1
            alter_hit(ch,  -dam / 2, 2);
d1793 1
a1793 1
      skill_message (dam, ch, victim, attacktype);
d1795 1
a1795 1
      dam_message (dam, ch, victim, attacktype);
d1798 1
a1798 1
    skill_message (dam, ch, victim, attacktype);
d1801 2
a1802 2
      if (!skill_message (dam, ch, victim, attacktype))
        dam_message (dam, ch, victim, attacktype);
d1805 1
a1805 1
      dam_message (dam, ch, victim, attacktype);
d1808 8
a1815 2
  /* Check for active defense spells */
  if (attacktype > MAX_SPELLS && ch != victim) {
d1840 1
a1840 1
      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500) {
d1851 2
a1852 2
      act ("$n is mortally wounded, and will die soon, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are mortally wounded, and will die soon, if not aided.\r\n", victim);
d1855 2
a1856 2
      act ("$n is incapacitated and will slowly die, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are incapacitated an will slowly die, if not aided.\r\n", victim);
d1859 2
a1860 2
      act ("$n is stunned, but will probably regain consciousness again.", TRUE, victim, 0, 0, TO_ROOM);
      send_to_char ("You're stunned, but will probably regain consciousness again.\r\n", victim);
d1863 5
a1867 2
      /* Note - for death from bloodloss (TYPE_SUFFERING), the death message is
       * different, and will be sent later when we call slow_death (see below). */
d1869 2
a1870 2
         act ("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
         send_to_char ("You are dead!\r\n", victim);
d1875 2
a1876 2
      if (dam > (GET_MAX_HIT (victim) >> 2))
        act ("That really did HURT!", FALSE, victim, 0, 0, TO_CHAR);
d1959 1
d1961 2
d3644 3
@


1.140
log
@Use thac0 in classes array.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.139 2007/12/23 20:42:21 myc Exp jps $
d32 1
a32 1
struct char_data *combat_list = NULL;	/* head of l-list of fighting chars */
d43 6
a48 6
extern int pk_allowed;		/* see config.c */
extern int auto_save;		/* see config.c */
extern int summon_allowed;	/*       "      */
extern int sleep_allowed;	/*       "      */
extern int charm_allowed;	/*       "      */
extern int damage_amounts;	/*       "      */
d96 1
a96 1
  {"hit", "hits"},		/* 0 */
d101 1
a101 1
  {"bludgeon", "bludgeons"},	/* 5 */
d106 1
a106 1
  {"thrash", "thrashes"},	/* 10 */
d263 1
a263 1
	     (fight_messages[i].a_type); i++);
d265 4
a268 4
	{
	  fprintf (stderr, "Too many combat messages.  Increase MAX_MESSAGES and recompile.");
	  exit (1);
	}
d290 1
a290 1
	 fgets (chk, 128, fl);
d323 1
a323 1
	stop_fighting (victim);
d353 2
a354 2
	if (victim->desc && victim->desc->original)
	  do_return (victim, "", 0, 1);
d361 2
a362 2
	if (victim->desc && victim->desc->original)
	  do_return (victim, "", 0, 1);
d385 71
a455 71
	{
	case POS1_PRONE:
	  break;
	case POS1_KNEELING:
	  switch (GET_POS (victim))
	    {
	    case POS_DEAD:
	      if (RIDING (victim))
		tmp = 1;
	      else
		{
		  if (!number (0, 9))
		    tmp = 1;
		}
	      break;
	    case POS_MORTALLYW:
	    case POS_INCAP:
	    case POS_SLEEPING:
	      /*mark new */
	      if (RIDING (victim))
		{
		  if (!number (0, 1))
		    tmp = 1;
		}
	      else
		{
		  if (!number (0, 9))
		    tmp = 1;
		}
	      break;
	    }
	  break;
	case POS_SITTING:
	  switch (pos)
	    {
	    case POS_DEAD:
	      if (RIDING (victim))
		{
		  if (!number (0, 1))
		    tmp = 1;
		}
	      else
		{
		  if (!number (0, 9))
		    tmp = 1;
		}
	      break;
	    }
	  break;
	  /*end mark */
	  
	case POS1_STANDING:
	  switch (pos)
	    {
	    case POS_DEAD:
	      tmp = 1;
	      break;
	    case POS_MORTALLYW:
	    case POS_INCAP:
	    case POS_SLEEPING:
	      if (RIDING (victim))
		tmp = 1;
	      else
		{
		  if (!number (0, 5))
		    tmp = 1;
		}
	      break;
	    }
	  break;
	}
d457 83
a539 83
	{
	  tmp = 0;
	  if (RIDING (victim))
	    {
	      tmp = 1;
	      switch (GET_POS1 (RIDING (victim)))
		{
		case POS1_PRONE:
		case POS1_KNEELING:
		case POS1_SITTING:
		  break;
		case POS1_STANDING:
		  alter_hit (victim, dice (3, 8), 2);
		  WAIT_STATE (victim, PULSE_VIOLENCE + 2);		/* this will be stun when it
									   it is coded MARKSTUN */
		  break;
		}
	      act ("$n falls of $s mount!", TRUE, victim, 0, 0, TO_ROOM);
	      dismount_char (victim);
	    }
	  else
	    {
	      switch (pos1)
		{
		case POS1_PRONE:
		case POS1_KNEELING:
		case POS1_SITTING:
		  break;
		case POS_STANDING:
		  tmp = 0;
		  if (!number (0, 2))
		    {
		      alter_hit (victim, dice (3, 5), 2);
		      if (GET_POS (victim) > POS_INCAP)
			WAIT_STATE (victim, PULSE_VIOLENCE + 2);
		      tmp = 1;
		    }
		  act ("$n slumps to the ground.", TRUE, victim, 0, 0, TO_ROOM);
		  break;
		}
	    }
	  pos1 = POS1_PRONE;
	  
	  /* RE-chECK POSTION WITH NEW HITPOINTS */
	 if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
	   {
	     GET_POS (victim) = POS_SITTING;
	     GET_POS1 (victim) = POS1_SITTING;
	   }
	 else if (GET_HIT (victim) <= HIT_DEAD)
	   GET_POS (victim) = POS_DEAD;
	 else if (GET_HIT (victim) <= HIT_MORTALLYW)
	   {
	     GET_POS (victim) = POS_MORTALLYW;
	     StopMercifulAttackers (victim);
	     if (GET_LEVEL (victim) >= LVL_IMMORT)
	       if (victim->desc && victim->desc->original)
		 do_return (victim, "", 0, 1);
	   }
	 else if (GET_HIT (victim) <= HIT_INCAP)
	   {
	     GET_POS (victim) = POS_INCAP;
	     StopMercifulAttackers (victim);
	     if (GET_LEVEL (victim) >= LVL_IMMORT)
	       if (victim->desc && victim->desc->original)
		 do_return (victim, "", 0, 1);
	   }
	 else
	   {
	     pos = GET_POS (victim);
	   }
	 
	 if (tmp && (pos < POS_RESTING))
	   {
	     if (affected_by_spell (victim, SPELL_SLEEP))
	       affect_from_char (victim, SPELL_SLEEP);
	     if (pos == POS_SLEEPING)
	       {
		 pos = POS_RESTING;
		 send_to_char ("Huh?!? You find yourself lying on the ground!\r\n", victim);
	       }
	   }
	}
d555 1
a555 1
	stop_fighting (victim);
d574 1
a574 1
	       GET_NAME (ch), GET_NAME (vict), world[vict->in_room].name);
d587 1
a587 1
  assert (!FIGHTING (ch));	/*Setmark game crashing due to assertion failing */
d640 6
a645 1
  
d662 1
a662 1
  GET_OBJ_VAL (corpse, 0) = 0;	/* You can't store stuff in a corpse */
d715 4
a718 4
	{
	  money = create_money (GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
	  obj_to_obj (money, corpse);
	}
d736 40
a775 40
	/* local copies of the aligns which could be modified */
	int k_al,v_al,change;
	k_al = GET_ALIGNMENT(ch);
	v_al = GET_ALIGNMENT(victim);

	/* if victim was anti good, and killer was good, make victim 'more evil'*/
	if (MOB_FLAGGED(victim,MOB_AGGR_GOOD) && IS_GOOD(ch))
		v_al -= 100;
	else if (MOB_FLAGGED(victim,MOB_AGGR_EVIL) && IS_EVIL(ch))
		v_al += 100;
	/* sojourn code has some stuff for STAYZONE and NICETHIEF here too?*/

	/* if we a re a 'good' class then our effective align is higher, ie
	 * even if a paladin of align 800 kills someone its as if they were align
	 * 900 compared to a wariror 800 (cos they should know better!)
	 */
	switch (GET_CLASS(ch))
	{
		/* using drop through cases to accumulate the align*/
		case CLASS_PALADIN:
		case CLASS_PRIEST:	k_al += 50;
		case CLASS_RANGER:
		case CLASS_DRUID:	k_al += 50;
					break;

		/* same deal for 'bad' classes */
		case CLASS_ANTI_PALADIN:
		case CLASS_DIABOLIST:
		case CLASS_NECROMANCER:	k_al -= 50;
		case CLASS_THIEF:
		case CLASS_ASSASSIN:	k_al -=50;
					break;
	}

	change = (v_al/(-75 - (25 * abs((k_al-1000)/200)))) - (2 * abs(k_al/1000));
	/* modifier based on level?*/
	if (change < 0 && (GET_LEVEL(ch) > (GET_LEVEL(victim) +10)))
		change *= (GET_LEVEL(ch)-GET_LEVEL(victim))/10;
	GET_ALIGNMENT(ch) += change;
	GET_ALIGNMENT(ch) = BOUNDED(-1000,GET_ALIGNMENT(ch),1000);
d901 2
a902 2
	cur->can_cast = 0;
	cur = cur->next;
d918 1
a918 1
    if (!IS_NPC (real_char))	/* If killed dont save in room he died in */
d958 1
a958 1
	tot_members++;
d961 1
a961 1
	tot_members++;
d963 2
a964 2
	if (g->groupee->in_room == ch->in_room)
	  tot_members++;
d971 1
a971 1
	tot_members++;
d977 1
a977 1
	/* frag_update(majorgroupmaster, killer, (1 / (float) tot_members)); */
d979 1
a979 1
	trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d984 5
a988 5
	if(type) {
	  /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
	} else {
	  trophy_update(g->groupee, killer, (1 / (float) tot_members));
	}
d993 5
a997 5
	if(type) {
	  /*  frag_update(m->mgroupee, killer, (1 / (float) tot_members)); */
	} else {
	  trophy_update(m->mgroupee, killer, (1 / (float) tot_members));
	}
d1000 7
a1006 7
	if (g->groupee->in_room == ch->in_room) {
	  if(type) {
	    /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
	  } else {
	    trophy_update(g->groupee, killer, (1 / (float) tot_members));
	  }
	}
d1009 1
a1009 1
  } else {				/*just group count */
d1012 1
a1012 1
	/* frag_update(groupmaster, killer, (1 / (float) tot_members)); */
d1014 1
a1014 1
	trophy_update(groupmaster, killer, (1 / (float) tot_members));
d1019 5
a1023 5
	if(type) {
	  /* frag_update(g->groupee, killer, (1 / (float) tot_members)); */
	} else {
	  trophy_update(g->groupee, killer, (1 / (float) tot_members));
	}
d1056 3
a1058 1
  if(killer) { /* What if killer is NULL? Doh!!! --Gurlaek 6/11/1999 */
d1061 10
a1070 10
	/*if a BIG person got kill then dont let rest of group bludge: */
	if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25)) {
	  if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)))
	    ;
	  else
	    {
	      kill_to_group (killer, ch, TRUE);
	    }
	}
	kill_to_group (killer, ch, FALSE);
d1074 1
a1074 1
	trophy_update (killer, ch, 1.0);
d1090 1
a1090 1
  if (GET_LEVEL(ch) < 60) {
d1166 1
a1166 1
	tot_members = 1;
d1168 2
a1169 2
	if (f->groupee->in_room == ch->in_room)
	  tot_members++;
d1171 7
a1177 7
	{
	  if (g->mgroupee->in_room == ch->in_room)
	    tot_members++;
	  for (f = g->mgroupee->groupees; f; f = f->next)
	    if (f->groupee->in_room == ch->in_room)
	      tot_members++;
	}
d1180 1
a1180 1
    {				/*just group count */
d1182 1
a1182 1
	tot_members = 1;
d1184 2
a1185 2
	if (f->groupee->in_room == ch->in_room)
	  tot_members++;
d1204 1
a1204 1
  if (tot_members >= 1)	/*changed line below it had no affect as it was */
d1216 1
a1216 1
	perform_group_gain (k, lbase, victim);
d1218 2
a1219 2
	if (f->groupee->in_room == ch->in_room)
	  perform_group_gain (f->groupee, base, victim);
d1221 7
a1227 7
	{
	  if (g->mgroupee->in_room == ch->in_room)
	    perform_group_gain (g->mgroupee, base, victim);
	  for (f = g->mgroupee->groupees; f; f = f->next)
	    if (f->groupee->in_room == ch->in_room)
	      perform_group_gain (f->groupee, base, victim);
	}
d1230 1
a1230 1
    {				/*just group count */
d1232 1
a1232 1
	perform_group_gain (k, lbase, victim);
d1234 2
a1235 2
	if (f->groupee->in_room == ch->in_room)
	  perform_group_gain (f->groupee, base, victim);
d1254 14
a1267 14
	{
	  switch (*(++str))
	    {
	    case 'W':
	      for (; *weapon_plural; *(cp++) = *(weapon_plural++));
	      break;
	    case 'w':
	      for (; *weapon_singular; *(cp++) = *(weapon_singular++));
	      break;
	    default:
	      *(cp++) = '#';
	      break;
	    }
	}
d1269 1
a1269 1
	*(cp++) = *str;
d1272 1
a1272 1
    }				/* For */
d1309 1
a1309 1
	     int w_type)
d1325 1
a1325 1
      "$n threw $s punch just a little wide, missing $N completely.&0",	/* 0: 0     */
d1332 1
a1332 1
      "$n slaps $N before tweaking $S nose.&0",		/* 1: 1..2  */
d1339 1
a1339 1
      "$n delivers a swift kick to $N's shin, causing a yelp of pain.&0",	/* 2: 3..4  */
d1346 1
a1346 1
      "$N howls in pain as $n nearly rips $S ear off!&0",		/* 3: 5..6  */
d1353 1
a1353 1
      "$N nearly doubles over choking as $n collapses $S trachea!&0",	/* 4: 7..10  */
d1360 1
a1360 1
      "$n dances up to $N and throws $s elbow into $S gut!&0",	/* 5: 11..14  */
d1367 1
a1367 1
      "Cupping $s hands, $n slaps $N's ears, bursting $S eardrums.&0",	/* 6: 15..19  */
d1374 1
a1374 1
      "$n punches $N repeatedly in the kidneys!&0",	/* 7: 19..23 */
d1381 1
a1381 1
      "$n punches $N in the throat, causing $M to choke!&0",	/* 8: > 23   */
d1399 1
a1399 1
      "$n tries to #w $N, but misses.&0",	/* 0: 0     */
d1406 1
a1406 1
      "$n grazes $N as $e #W $M.&0",		/* 1: 1..2  */
d1413 1
a1413 1
      "$n barely #W $N.&0",	/* 2: 3..4  */
d1420 1
a1420 1
      "$n #W $N.&0",		/* 3: 5..6  */
d1427 1
a1427 1
      "$n #W $N hard.&0",	/* 4: 7..10  */
d1434 1
a1434 1
      "$n #W $N very hard.&0",	/* 5: 11..14  */
d1441 1
a1441 1
      "$n #W $N extremely hard.&0",	/* 6: 15..19  */
d1448 1
a1448 1
      "$n massacres $N to small fragments with $s #w.&0",	/* 7: 19..23 */
d1455 1
a1455 1
      "$n nearly rips $N in two with $s deadly #w!!&0",	/* 8: > 23   */
d1464 1
a1464 1
      w_type -= TYPE_HIT;		/* Change to base of table with text */
d1509 1
a1509 1
			attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
d1518 1
a1518 1
			attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
d1527 1
a1527 1
			attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
d1540 1
a1540 1
	       int attacktype)
d1564 1
a1564 1
	  
d1647 1
a1647 1
	     int attacktype)
d1658 2
a1659 1
    sprintf(buf, "SYSERR: Attempt to damage a corpse in room num %d", world[victim->in_room].number);
d1661 1
a1661 1
    return;			/* -je, 7/7/92 */
a1666 8
  /* shopkeeper protection */
  /*temp disable due to crashing - proky */
  /*Disabled again! please do not un comment this Banyal*/ 
  /*
    if (!ok_damage_shopkeeper (ch, victim))
    return;
  */

d1767 22
a1788 11
  /* Do the damage. */
  alter_hit(victim, dam, 2);
  update_pos(victim);

  /* Vampiric touch? */
  if (!wielded && !hwielded && !vhwielded && !vwielded && ch != victim) {
    if (AFF3_FLAGGED(ch, AFF3_VAMP_TOUCH)) {
      if (IS_NPC(ch))
	alter_hit(ch, -dam / 2, 2);
      else
	alter_hit(ch, -dam, 2);
a1789 8
    if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0)
      /* Only players can vamp touch using the skill. */
      if (!IS_NPC(ch)) {
	if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > number(0, 101))
	  alter_hit(ch,  -dam / 2, 2);
	if (number(0, 2))
	  improve_skill(ch, SKILL_VAMP_TOUCH);
      }
d1792 2
a1793 2
  /* You get some exp for doing damage. */
  if (ch != victim && !IS_NPC(ch))
d1883 1
a1883 1
    default:			/* >= POSITION SLEEPING */
d1885 1
a1885 1
	act ("That really did HURT!", FALSE, victim, 0, 0, TO_CHAR);
d1896 1
a1896 1
	  GET_HIT(victim) < GET_WIMP_LEV(victim)) {
d1926 2
a1927 1
      if (AFF_FLAGGED(ch, AFF_GROUP))
d2046 6
a2051 6
	{
	  hurm = number (35, 171);
	  hurm1 = number (20, 50);
	  hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	  hurm += GET_HITROLL (ch);
	  hurm -= monk_weight_pen(ch);
d2053 1
a2053 1
	  hurm1 -= dex_app[GET_DEX (victim)].defensive;
d2058 7
a2064 7
	  else
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) / 10; 
	  if (number (1, 10) < 5)
	    improve_skill (victim, SKILL_DODGE);
	  if (hurm1 > hurm)
	    DODGE = TRUE;
	}
d2071 6
a2076 6
	{
	  if (GET_POS (victim) > POS_SITTING)
	    {
	      hurm = number (45, 181);
	      hurm1 = number (20, 60);
	      hurm += GET_HITROLL (ch);
d2078 1
a2078 1
	      hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
d2080 10
a2089 10
	      hurm1 -= dex_app[GET_DEX (victim)].defensive;
	      hurm1 += GET_SKILL (victim, SKILL_PARRY) / 10;
	      if (number (1, 10) < 5)
		improve_skill (victim, SKILL_PARRY);
	      if (hurm1 > hurm)
		{
		  PARRY = TRUE;
		}
	    }
	}
d2095 6
a2100 6
	{
	  if (GET_POS (victim) > POS_SITTING)
	    {
	      hurm = number (55, 200);
	      hurm1 = number (20, 50);
	      hurm += GET_HITROLL (ch);
d2103 45
a2147 45
	      hurm1 -= dex_app[GET_DEX (victim)].defensive;
	      hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/10) * .85;
	      hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	      if (number (1, 10) < 5)
		improve_skill (victim, SKILL_RIPOST);
	      if (hurm1 > hurm)
		{
		  RIPOSTT = TRUE;
		  vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
		  vdam += GET_DAMROLL (victim);
		  
		  if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		    vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
		  else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		    vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
		  else
		    {
		      if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
			vw_type = victim->mob_specials.attack_type + TYPE_HIT;
		      else if (GET_SKILL(victim, SKILL_BAREHAND) > 0)
			vw_type = SKILL_BAREHAND;
		      else
			vw_type = TYPE_HIT;
		    }
		  if (vwielded)
		    vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
		  else if (vhwielded)
		    vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
		  else
		    {
		      if (IS_NPC (victim))
			{
			  vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
			}
		      else
			vdam += number (0, 2);
		    }
		  if (vw_type == SKILL_BAREHAND)
		    vdam += barehand_mult(GET_LEVEL(victim));
		  if (GET_POS (ch) < POS_FIGHTING)
		    vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
		  vdam = MAX (1, 70);
		}
	    }
	}
d2157 1
a2157 1
	w_type = ch->mob_specials.attack_type + TYPE_HIT;
d2159 1
a2159 1
	w_type = SKILL_BAREHAND;
d2161 1
a2161 1
	w_type = TYPE_HIT;
d2171 2
a2172 2
  calc_thaco -= (int) ((GET_INT (ch)) / 25);	/* Int helps! */
  calc_thaco -= (int) ((GET_WIS (ch)) / 25);	/* So does wis */
d2181 1
a2181 1
  victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */
d2193 1
a2193 1
	  sling_weapon(ch, wielded, WEAR_WIELD);
d2196 1
a2196 1
  	  sling_weapon(ch, hwielded, WEAR_2HWIELD);
d2208 1
a2208 1
	 damage (ch, victim, 0, w_type);
d2214 1
a2214 1
	damage (ch, victim, 0, w_type);
d2216 1
a2216 1
	  sling_weapon(ch, hwielded, WEAR_2HWIELD); 
d2219 1
a2219 1
	damage(ch, victim, 0, SKILL_PUNCH);
d2233 1
a2233 1
	dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
d2235 2
a2236 2
	dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
	  dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
d2239 1
a2239 1
	dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2));
d2241 2
a2242 2
	dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2)) +
	  dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
d2245 1
a2245 1
	dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
d2247 1
a2247 1
	dam += number (0, 2);	/* Max. 2 dam with bare hands */
d2251 1
a2251 1
      dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;	/*mark */
d2259 1
a2259 1
    dam = MAX (1, dam);	/* at least 1 hp damage min per hit */
d2291 13
a2303 13
	if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
	  act ("&7You smirk and slap $n's attack away with ease.&0", FALSE, ch, 0, victim, TO_VICT);
	  act ("&7$N smirks and slaps your attack away.&0", FALSE, ch, 0, victim, TO_CHAR);
	  act ("&7$N smirks as $E slaps $n's attack away.&0", FALSE, ch, 0, victim, TO_NOTVICT);
	} else {
	  act ("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
	  act ("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
	  act ("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
	}
	if (!FIGHTING (ch))
	  set_fighting (ch, victim);
	if (!FIGHTING (victim))
	  set_fighting (victim, ch);
d2305 1
a2305 1
	if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
d2310 9
a2318 9
	  act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	} else {
	  act ("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
	  act ("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
	  act ("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
	}
	/* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	if(wielded) {
d2320 2
a2321 2
	    sling_weapon(ch, wielded, WEAR_WIELD);
	} else if(hwielded) {
d2323 6
a2328 6
	    sling_weapon(ch, hwielded, WEAR_2HWIELD);
	}
	if (!FIGHTING (ch))
	  set_fighting (ch, victim);
	if (!FIGHTING (victim))
	  set_fighting (victim, ch);
d2330 39
a2368 34
	if (dam > 0) {
	  /*ok here we hit victem so check for stone skin */
	  if (IS_AFFECTED (victim, AFF_STONE_SKIN)) {
	    if (number (0, 10) <= 9) {
	      decrease_modifier (victim);
	      dam = number (0, 3);
	    }
	  }
	  if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD)) {
	    if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500) {
	      dam = (int) (3 * dam / 4);
	      GET_HIT (ch) -= (int) (dam / 4);
	    }
	    if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500) {
	      dam = (int) (3 * dam / 4);
	      GET_HIT (ch) -= (int) (dam / 4);
	    }
	  }
	  if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD | AFF2_FIRESHIELD)) {
	    if (!IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE)) {
	      GET_HIT (ch) -= (int) (dam / 3);
	    }
	  }
	}
	if (victim)
	  hitprcnt_mtrigger (victim);
	damage (ch, victim, dam, w_type);
	/* improve weapon proficiencies --gurlaek 11/21/1999 */
	if(number(1,10) == 10) {
	  if(wielded && (skill = weapon_proficiency(wielded, WEAR_WIELD)) != -1)
	    improve_skill(ch, skill);
	  if(hwielded && (skill = weapon_proficiency(hwielded, WEAR_2HWIELD)) != -1)
	    improve_skill(ch, skill);
	}
d2422 5
a2426 5
	{
	  hurm = number (55, 171);
	  hurm1 = number (20, 40);
	  hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	  hurm += GET_HITROLL (ch);
d2429 1
a2429 1
	  hurm1 -= dex_app[GET_DEX (victim)].defensive;
d2435 8
a2442 8
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) / 10; 
	  if (number (1, 10) < 5)
	    improve_skill (victim, SKILL_DODGE);
	  if (hurm1 > hurm)
	    {
	      DODGE = TRUE;
	    }
	}
d2448 7
a2454 7
	{
	  if (GET_POS (victim) > POS_SITTING)
	    {
	      hurm = number (65, 171);
	      hurm1 = number (15, 40);
	      hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	      hurm += GET_HITROLL (ch);
d2457 10
a2466 10
	      hurm1 -= dex_app[GET_DEX (victim)].defensive;
	      hurm1 += GET_SKILL (victim, SKILL_PARRY)/10;
	      if (number (1, 10) < 5)
		improve_skill (victim, SKILL_PARRY);
	      if (hurm1 > hurm)
		{
		  PARRY = TRUE;
		}
	    }
	}
d2472 6
a2477 6
	{
	  if (GET_POS (victim) > POS_SITTING)
	    {
	      hurm = number (90, 400);
	      hurm1 = number (15, 40);
	      hurm += GET_HITROLL (ch);
d2479 1
a2479 1
	      hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
d2481 46
a2526 46
	      hurm1 -= dex_app[GET_DEX (victim)].defensive;
	      hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/10) * .8;
	      if (number (1, 10) < 5)
		improve_skill (victim, SKILL_RIPOST);
	      if (hurm1 > hurm)
		{
		  RIPOSTT = TRUE;
		  vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
		  vdam += GET_DAMROLL (victim);
		  if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		    vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
		  else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		    vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
		  else
		    {
		      if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
			vw_type = victim->mob_specials.attack_type + TYPE_HIT;
		      else if (GET_SKILL(victim, SKILL_BAREHAND) > 0)
			vw_type = SKILL_BAREHAND;
		      else
			vw_type = TYPE_HIT;
		    }
		  
		  if (vwielded)
		    vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
		  else if (vhwielded)
		    vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
		  else
		    {
		      if (IS_NPC (victim))
			{
			  vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
			}
		      else
			vdam += number (0, 2);
		    }
		  
		  if (vw_type == SKILL_BAREHAND)
		    vdam += barehand_mult(GET_LEVEL(victim));
		  if (GET_POS (ch) < POS_FIGHTING)
		    vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
		  
		  vdam = MAX (1, 70);
		}
	    }
	}
d2534 1
a2534 1
	w_type = ch->mob_specials.attack_type + TYPE_HIT;
d2536 1
a2536 1
	w_type = SKILL_BAREHAND;
d2538 1
a2538 1
	w_type = TYPE_HIT;
d2549 2
a2550 2
  calc_thaco -= (int) ((GET_INT (ch)) / 25);	/* Int helps! */
  calc_thaco -= (int) ((GET_WIS (ch)) / 25);	/* So does wis */
d2558 1
a2558 1
  victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */
d2568 3
a2570 3
	/* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	damage (ch, victim, 0, SKILL_2BACK);
	if(wielded)
d2572 1
a2572 1
	    sling_weapon(ch, wielded, WEAR_WIELD2);
d2576 1
a2576 1
	damage (ch, victim, 0, SKILL_BAREHAND);
d2580 3
a2582 3
	/* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	damage (ch, victim, 0, w_type);
	if(wielded)
d2597 7
a2603 7
	{
	  if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
	  else
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
	      dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	}
d2605 8
a2612 8
	{
	  if (IS_NPC (ch))
	    {
	      dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	    }
	  else
	    dam += number (0, 2);	/* Max. 2 dam with bare hands */
	}				/*Banyal add class mods here */
d2615 1
a2615 1
	dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;
d2623 1
a2623 1
      dam = MAX (1, dam);	/* at least 1 hp damage min per hit */
d2626 4
a2629 4
	{
	  dam *= backstab_mult (GET_LEVEL (ch));
	  damage (ch, victim, dam, SKILL_2BACK);
	}
d2631 4
a2634 4
	{
	  dam += barehand_mult (GET_LEVEL(ch));
	  damage (ch, victim, dam, SKILL_BAREHAND);
	}
d2636 3
a2638 3
	{
	  if (RIPOSTT)
	    {
d2640 1
a2640 1
		if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
d2642 1
a2642 1
		  act (b2, FALSE, ch, 0, victim, TO_VICT);
d2644 1
a2644 1
		  act (b2, FALSE, ch, 0, victim, TO_CHAR);
d2646 2
a2647 2
		  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
		} else {
d2649 1
a2649 1
		  act (b2, FALSE, ch, 0, victim, TO_VICT);
d2651 1
a2651 1
		  act (b2, FALSE, ch, 0, victim, TO_CHAR);
d2653 6
a2658 6
		  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
		}
	      damage (victim, ch, vdam, vw_type);
	    }
	  else if (PARRY)
	    {
d2660 3
a2662 3
	         act ("&7You smirk and slap $n's attack away with ease.&0", FALSE, ch, 0, victim, TO_VICT);
	         act ("&7$N smirks and slaps your attack away.&0", FALSE, ch, 0, victim, TO_CHAR);
	         act ("&7$N smirks as $E slaps $n's attack away.&0", FALSE, ch, 0, victim, TO_NOTVICT);
d2664 3
a2666 3
	         act ("&7You parry $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
	         act ("&7$N parries your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
	         act ("&7$N parries $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
d2668 3
a2670 3
	    }
	  else if (DODGE)
	    {
d2673 1
a2673 1
		  act ("&7You twist in place and watch $n attack the air nearby.&0", FALSE, ch, 0, victim, TO_VICT);
d2676 2
a2677 2
		act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
		act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2679 3
a2681 3
		act ("&7You dodge $n's attack.&0", FALSE, ch, 0, victim, TO_VICT);
		act ("&7$N dodges your attack.&0", FALSE, ch, 0, victim, TO_CHAR);
		act ("&7$N dodges $n's attack.&0", FALSE, ch, 0, victim, TO_NOTVICT);
d2683 2
a2684 2
	      /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	      if(wielded)
d2686 37
a2722 37
		  sling_weapon(ch, wielded, WEAR_WIELD2);
	    }
	  else
	    {
	      if (dam > 0)
		{
		  /*ok here we hit victem so check for stone skin */
		  if (IS_AFFECTED (victim, AFF_STONE_SKIN))
		    {
		      if (number (0, 10) <= 9)
			{
			  decrease_modifier (victim);
			  dam = number (0, 3);
			}
		    }
		  else if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
		    {
		      if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
			{
			  dam = (int) (3 * dam / 4);
			  GET_HIT (ch) -= (int) (dam / 4);
			}
		      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
			{
			  dam = (int) (3 * dam / 4);
			  GET_HIT (ch) -= (int) (dam / 4);
			}
		    }
		  
		}
	      damage (ch, victim, dam, w_type);
	      if(number(1,10) == 10) {
		if(wielded && (skill = weapon_proficiency(wielded, WEAR_WIELD2)) != -1)
		  improve_skill(ch, skill);
	      }
	    }
	}
d2737 2
a2738 2
	       GET_SKILL(ch, SKILL_2H_BLUDGEONING) + 
	       GET_SKILL(ch, SKILL_2H_PIERCING)) / 3;
d2741 2
a2742 2
	       GET_SKILL(ch, SKILL_BLUDGEONING) + 
	       GET_SKILL(ch, SKILL_PIERCING)) / 3;
d2908 6
a2913 6
	  || ch->in_room != FIGHTING (ch)->in_room
	  || GET_POS(FIGHTING(ch)) == POS_DEAD)
	{
	  stop_fighting (ch);
	  continue;
	}
d2917 1
a2917 1
	--ch->char_specials.action_delays[ACT_DELAY_DISARM];
d2920 7
a2926 7
	{
	  send_to_char ("You remain paralyzed and can't do a thing to defend yourself..\r\n",
			ch);
	  act ("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
	       FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
	  continue;
	}
d2928 5
a2932 5
	{
	  act ("You couldn't budge a feather in your present condition.", FALSE, ch, 0, 0, TO_CHAR);
	  act ("$n is too preoccupied with $s nervous system problem to fight.", FALSE, ch, 0, 0, TO_ROOM);
	  continue;
	}
d2936 1
a2936 1
	continue;
d2938 1
a2938 1
	continue;
d2946 2
a2947 2
	  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	{
d2949 8
a2956 8
	    hit (ch, FIGHTING(ch), SKILL_BAREHAND);
	  else
	    hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	  if (IS_AFFECTED (ch, AFF_HASTE) && FIGHTING (ch))
	    {
	      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
		  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		{
d2958 1
a2958 1
		    hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2960 8
a2967 8
		    hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
		}
	    }
	  if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
	    {
	      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
		  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		{
d2969 1
a2969 1
		    hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2971 4
a2974 4
		     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
		}
	    }
	}
d2988 1
a2988 1
	(mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
d2991 21
a3011 21
	if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
	  {
	    vict = NULL;
	    for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
	      if (FIGHTING (tch) == ch && !IS_NPC (tch))
		if (vict == NULL || GET_HIT (tch) < GET_HIT (vict))
		  vict = tch;
	    
	    if (vict != NULL && FIGHTING (ch) != vict)
	      {
		
		if (!IS_AFFECTED (ch, AFF_BLIND))
		  if (!affected_by_spell (ch, SPELL_BLINDNESS))
		    if (!affected_by_spell (ch, SPELL_SMOKE))
		      if (CAN_SEE(ch, vict))
			if (!number (0, (MAX (10, (30 - GET_LEVEL (ch))))))
			  {
			    stop_fighting (ch);
			    act ("$n switches to $N!", FALSE, ch, 0, vict, TO_ROOM);
	                    if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
		               hit (ch, vict, SKILL_BAREHAND);
d3013 4
a3016 4
			       hit (ch, vict, TYPE_UNDEFINED);
			  }
	      }
	  }
d3020 15
a3034 15
	{
	  
	  struct obj_data *wielded2 = GET_EQ (ch, WEAR_WIELD2);
	  
	  if (wielded2)
	    {
	      prob = 0;
	      prob = GET_SKILL (ch, SKILL_DUAL_WIELD);
	      if (GET_LEVEL (ch) < 15)
		if (number (0, 2))
		  prob = prob - 10;
	      if (number (1, 101) < prob)
		{
		  if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		    {
d3036 1
a3036 1
		         hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
d3038 15
a3052 15
		         hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		      improve_skill (ch, SKILL_DUAL_WIELD);
		    }
		  if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		    (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
		  if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
		    {
		      hurm = 0;
		      hurm = number (1, 100);
		      hurm2 = 0;
		      hurm2 = number (1, 101);
		      if (hurm < prob)
			{
			  if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
			    {
d3054 33
a3086 33
		     		 hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
                  	      else
				 hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
			      improve_skill (ch, SKILL_DUAL_WIELD);
			    }
			}
		    }
		}
	      
	      if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
		{
		  prob = 0;
		  prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
		  if (GET_LEVEL (ch) < 15)
		    if (number (0, 2))
		      prob = prob - 10;
		  
		  if (number (1, 101) < prob)
		    {
		      if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON ||
			  !weapon_special (wpn, ch)) {
			if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
			  hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
			else
			  hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		      }
		      if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
			(mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
		      improve_skill (ch, SKILL_DUAL_WIELD);
		    }
		}
	    }
	}
d3089 14
a3102 14
	{
	  prob = 0;
	  prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
	  
	  if (GET_LEVEL (ch) < 15)
	    if (number (0, 2))
	      prob = prob - 10;
	  
	  if (number (1, 101) < prob)
	    {
	      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
		  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch)) {
		if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
		  hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d3104 7
a3110 7
		    hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	      }	      
	      if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		(mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
	      improve_skill (ch, SKILL_DOUBLE_ATTACK);
	    }
	}
d3113 8
a3120 8
	{
	  prob = 0;
	  prob = number (1, 101);
	  if ((number (1, 101) - GET_LEVEL (ch) + 10) < prob)
	    {
	      if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
		  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		{
d3122 1
a3122 1
		     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d3124 4
a3127 4
		     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
		}
	    }
	}
d3130 1
a3130 1
	continue;
d3182 3
a3184 3
#define NUM_OF_FUN_PARTS 13	/* the following is some sicko's code
				   named Patrick J. Dughi, I changed it a great deal
				   to fit Hubis' theme. */
d3188 10
a3197 10
  int number;			/* this parts number */
  char name[40];		/* names of this part */
  int nname;			/* some parts you couldn't trace to an owner */
  char sdesc[128];		/* short desc: that of inventory  */
  char rdesc[128];		/* room desc: when on ground */
  int take;			/* some body parts don't transfer well */
  char actout[128];		/* what people in room see upon death, using
				   act() */
  char actkil[128];		/* what the killer sees upon dismemberment, using
				   act() */
d3259 1
a3259 1
  i = number (0, 20);		/* 20 pieces should be okay */
d3291 2
a3292 2
  GET_OBJ_VAL (piece, 0) = 0;	/* You can't store stuff in a corpse */
  GET_OBJ_VAL (piece, 3) = 1;	/* corpse identifier */
d3323 27
a3349 27
	{
	  obj_from_room (obj_i);
	  obj_to_char (obj_i, ch);
	  
	  if (!IS_FIGHTING (ch))
	    {
	      act ("$n eagerly reaches for $p.", FALSE, ch, obj_i, 0, TO_ROOM);
	    }
	  else
	    {
	      act ("$n finally gets a steady grip on $p.", FALSE, ch, obj_i, 0, TO_ROOM);
	    }
	  
	  REMOVE_BIT (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED);
	  
	  if (obj_i->name)
	    sprintf (arg, "%s", obj_i->name);
	  
	  
	  
	  if (IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_WIELD) ||
	      IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_2HWIELD))
	    do_wield (ch, arg, cmd_wield, -4);
	  
	  done = TRUE;
	  retval = TRUE;
	}
d3372 12
a3383 12
	{
	  while (PickupDisarmedWeapon (ch));
	  
	  for (af = ch->affected; af; af = af_next)
	    {
	      af_next = af->next;
	      if (af->type == SKILL_DISARM_DROPPED_WEAP)
		{
		  affect_remove (ch, af);
		}
	    }
	}
d3385 10
a3394 10
	{
	  for (af = ch->affected; af; af = af_next)
	    {
	      af_next = af->next;
	      if (af->type == SKILL_DISARM_FUMBLING_WEAP)
		{
		  affect_remove (ch, af);
		}
	    }
	}
d3415 8
a3422 8
	{
	  af_next = af->next;
	  if (af->type == SKILL_DISARM_FUMBLING_WEAP && af->bitvector & affect_type)
	    {
	      affect_remove (ch, af);
	      done = TRUE;
	    }
	}
d3444 3
a3446 3
	{
	  get_weap = TRUE;
	}
d3451 3
a3453 3
	{
	  aff_drop_expired = TRUE;
	}
d3463 3
a3465 3
	{
	  ch->char_specials.action_delays[(int) action_delay_type] = 0;
	}
d3469 1
a3469 1
    {				/* if time to look for MOB's dislodged item */
d3471 3
a3473 3
	{
	  act ("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
	}
d3484 8
a3491 8
	{
	  af_next = af->next;
	  if (af->type == SKILL_DISARM_DROPPED_WEAP && af->bitvector2 & affect_type)
	    {
	      affect_remove (ch, af);
	      done = TRUE;
	    }
	}
d3599 1
a3599 1
    {				/*No argument is a check of aggressivity */
d3602 4
a3605 4
	{
	  send_to_char ("You are not aggressive to monsters.\r\n", ch);
	  return;
	}
d3607 1
a3607 1
	       ch->player_specials->saved.aggressive);
d3616 2
a3617 2
	send_to_char ("What?  Let somebody else get the first blow?  Not a chance!\r\n", ch);
	return;
d3621 3
a3623 3
	ch->player_specials->saved.aggressive = -1;
	send_to_char ("You are no longer aggressive to monsters.\r\n", ch);
	return;
d3626 1
a3626 1
    {				/* Turn on aggressivity */
d3631 4
a3634 4
	{
	  send_to_char ("Aggressive while dying?  Not likely!\r\n", ch);
	  return;
	}
d3650 3
@


1.139
log
@Make vamp touch only work when hurting someone else.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.138 2007/12/23 20:36:54 myc Exp myc $
d1979 2
a1980 4
  extern struct class_thac0 thac0_table[];
  int class = GET_CLASS(ch);
  int thac0_01 = thac0_table[class].thac0_01;
  int thac0_00 = thac0_table[class].thac0_00;
d2375 2
a2376 4
  extern struct class_thac0 thac0_table[];
  int class = GET_CLASS(ch);
  int thac0_01 = thac0_table[class].thac0_01;
  int thac0_00 = thac0_table[class].thac0_00;
d3641 3
@


1.138
log
@Don't show damage messages for immortals when ch == vict.  Also,
if a message is missing in the messages file, replace it with an
error message.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.137 2007/12/09 03:30:55 jps Exp myc $
d1772 1
a1772 1
  if (!wielded && !hwielded && !vhwielded && !vwielded) {
d3645 5
@


1.137
log
@Don't allow incap'd folks to start fighting. Handled this at the source
rather than changing all the calls to start_fighting.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.136 2007/10/27 18:56:26 myc Exp jps $
d228 4
d276 12
a287 12
      messages->die_msg.attacker_msg = fread_action (fl, i);
      messages->die_msg.victim_msg = fread_action (fl, i);
      messages->die_msg.room_msg = fread_action (fl, i);
      messages->miss_msg.attacker_msg = fread_action (fl, i);
      messages->miss_msg.victim_msg = fread_action (fl, i);
      messages->miss_msg.room_msg = fread_action (fl, i);
      messages->hit_msg.attacker_msg = fread_action (fl, i);
      messages->hit_msg.victim_msg = fread_action (fl, i);
      messages->hit_msg.room_msg = fread_action (fl, i);
      messages->god_msg.attacker_msg = fread_action (fl, i);
      messages->god_msg.victim_msg = fread_action (fl, i);
      messages->god_msg.room_msg = fread_action (fl, i);
d1562 7
a1568 5
            if (dam > 0)
               append_damage_amount(b2, msg->god_msg.attacker_msg, dam, TO_CHAR);
            else
               sprintf(b2, "%s", msg->god_msg.attacker_msg);
            act(b2, FALSE, ch, weap, vict, TO_CHAR);
d1588 4
a1591 2
               append_damage_amount(b2, msg->die_msg.attacker_msg, dam, TO_CHAR);
               act(b2, FALSE, ch, weap, vict, TO_CHAR);
d3645 4
@


1.136
log
@When a mob dies of fire, poison, of suffering, if they were fighting
someone, their opponent gets the exp for the kill.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.135 2007/10/25 20:38:55 myc Exp myc $
d580 1
a580 1
  if (ch == vict)
d3637 4
@


1.135
log
@Make death log show room vnum the player died in.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.134 2007/10/13 20:56:00 myc Exp myc $
d1636 5
a1640 9
  struct obj_data *wielded;
  struct obj_data *hwielded;
  struct obj_data *vwielded;
  struct obj_data *vhwielded;

  wielded = GET_EQ (ch, WEAR_WIELD);
  hwielded = GET_EQ (ch, WEAR_2HWIELD);
  vwielded = GET_EQ (victim, WEAR_WIELD);
  vhwielded = GET_EQ (victim, WEAR_2HWIELD);
d1721 1
a1721 1
  if (IS_AFFECTED2 (victim, AFF2_WATERFORM))
d1892 14
d3637 3
@


1.134
log
@Slinging into other rooms wasn't working.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.133 2007/10/13 20:13:37 myc Exp myc $
d1934 3
a1936 2
      sprintf(buf2, "%s killed by %s at %s", GET_NAME (victim), GET_NAME (ch),
              world[victim->in_room].name);
d3627 3
@


1.133
log
@Cleaned up sling-weapon code.  There were some apparent mistakes that
made you much more likely to sling your weapon than should be true.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.132 2007/10/04 16:20:24 myc Exp myc $
d2704 1
a2704 1
  int skill, skill_number, dir, room;
d2756 5
a2760 5
      for (dir = 0; dir < NUM_OF_DIRS; ++dir)
        if (CAN_GO(ch, dir) && !number(0, NUM_OF_DIRS - dir))
          break;
      if (dir < NUM_OF_DIRS)
        /* Valid direction */
d2762 1
d2778 2
a2779 1
      sprintf(buf, "A $o is slung violently in from %s%s",
d2787 1
a2787 1
    obj_to_room(weapon, ch->in_room);
d3626 4
@


1.132
log
@Transient item flag now makes things decay when they are on the ground.
Added this flag to corpses.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.131 2007/10/02 02:52:27 myc Exp myc $
d2704 1
a2704 3
  int spercent, dpercent, skill, skill_number;
  int x, y, dir[6], direction = -1;
  bool screwed = FALSE;
a2706 1
  struct char_data *tch;
d2708 4
a2711 4
  /* find the appropriate skill to make the check */
  if((skill_number = weapon_proficiency(weapon, position)) == -1) {
    /* misc types of weapons get an average of all the scores */
    if(position == WEAR_2HWIELD)
d2714 1
a2714 1
	       GET_SKILL(ch, SKILL_2H_PIERCING))/3;
d2718 4
a2721 3
	       GET_SKILL(ch, SKILL_PIERCING))/3;
  } else
    skill = GET_SKILL(ch, skill_number)/10;
d2723 2
a2724 10
  dpercent = number(1, 81);
  spercent = number(1, 81);
  /*
  if(!IS_NPC(ch)) {
    sprintf(buf, "[%s] dex: %d roll: %d skill: %d roll %d", GET_NAME(ch), GET_DEX(ch), dpercent, skill, spercent);  
    log(buf);
  }
  */
  /* advance the skill if it's not a misc weapon */
  if(skill_number != -1)
d2727 7
a2733 4
  /* make a dex check first */
  if(dpercent < GET_DEX(ch)) {
    return screwed;
  }
d2735 8
a2742 4
  /* check to see if it was slung */
  if(spercent > skill) {
    screwed = TRUE;
    /* remove the weapon */
d2744 8
a2751 15
    
    if (position == WEAR_WIELD && GET_EQ(ch, WEAR_WIELD2))
      {
	struct obj_data* temp; 
	unequip_char(ch,WEAR_WIELD); 
	temp = unequip_char(ch, WEAR_WIELD2);
	if (temp != NULL)
	  {
	    equip_char(ch, temp, WEAR_WIELD); 
	  };
      }
    else
      {
	unequip_char(ch, position); 
      };
d2753 29
a2781 40
    if (!(IS_OBJ_STAT(weapon, ITEM_NODROP))) { /* Cursed? */
      /* one in five chance to sling the weapon into the next room */
      if (number(1, 5) == 5) {
	/* find a valid direction to sling it */
	for (x = 0, y = -1; x <= 5; x++) {
	  if(CAN_GO(ch, x)) {
	    y++;
	    dir[y] = x;
	  }
	}
	if(y >= 0)
	  direction = dir[number(0, y)];
      }
      if(direction != -1) {
	      int room;
	/* sling into next room */
	sprintf(buf, "&3&bWith a mighty&0 &B&3HEAVE&0 &3&byou sling your&0 $o &3&bout of reach %swards!&0", dirs[direction]);
	act(buf, TRUE, ch, weapon, NULL, TO_CHAR);
	sprintf(buf, "&3&bWith a mighty&0 &B&3HEAVE&0 $n &3&bslings $s&0 $o &3&bout of reach %swards!&0", dirs[direction]);
	act(buf, TRUE, ch, weapon, NULL, TO_ROOM);
	/* see if anyone is in the next room */
	room = world[ch->in_room].dir_option[direction]->to_room;
	for (tch = world[room].people; tch; tch = tch->next_in_room) {
	  sprintf(buf, "A $o is slung violently in from %swards!", dirs[rev_dir[direction]]);
	  act(buf, TRUE, tch, weapon, NULL, TO_CHAR);
	}
	/* place the weapon in the room */
	obj_to_room(weapon, room);
      } else {
	/* sling into same room */
	act("&3&bYou lose your grip on your&0 $o &3&band send it&0 &B&3flying!&0", TRUE, ch, weapon, NULL, TO_CHAR);
	act("$n &3&bloses $s grip on $s&0 $o &3&band sends it&0 &B&3flying!&0", TRUE, ch, weapon, NULL, TO_ROOM);
	/* place the weapon in the room */
	obj_to_room(weapon, ch->in_room);
      }      
    } else {
      /* weapon is cursed so it remains in the inventory of the PC/NPC */
      act("&3&bYou lose your grip on your&0 $o &3&band it magically returns to your&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_CHAR);
      act("$n &3&bloses $s grip on $s&0 $o&3&b, and it magically returns to $s&0 &B&3inventory!&0", TRUE, ch, weapon, NULL, TO_ROOM);
      obj_to_char(weapon, ch);
d2783 3
a2785 1
    WAIT_STATE(ch, 2 * PULSE_VIOLENCE);  /* lag the poor bastard */
d2787 4
a2790 2
    
  return screwed;
d3267 1
a3267 1
  GET_OBJ_EXTRA (piece) = ITEM_NODONATE;
d3624 4
@


1.131
log
@Incapacitation via damage() now stops casting.  Skills won't
improve in the PK arena anymore.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.130 2007/09/20 21:20:43 myc Exp myc $
d652 1
a652 1
  GET_OBJ_EXTRA (corpse) = (ITEM_NODONATE | ITEM_FLOAT);
d3641 4
@


1.130
log
@Hide points and perception are in.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.129 2007/09/20 09:15:14 jps Exp myc $
d167 1
a167 1
    if (IS_NPC(ch) && GET_LEVEL(ORIG_CHAR(ch)) >= LVL_GOD)
d169 1
a169 1
    if (IS_NPC(victim) && GET_LEVEL(ORIG_CHAR(victim)) >= LVL_GOD)
d1897 1
a1897 1
  if (!AWAKE(victim))
d1900 2
d3134 5
a3138 1
  if(IS_NPC(ch)) /* mobs don't need these CPU cycles */
d3140 1
d3641 3
@


1.129
log
@Typo fix
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.128 2007/09/15 15:36:48 myc Exp jps $
a205 1
   affect_from_char(ch, SPELL_CONCEALMENT);
d208 1
a208 1
   was_hidden = AFF_FLAGGED(ch, AFF_HIDE);
d210 1
a210 1
   REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE | AFF_HIDE);
d212 1
d1705 1
a1705 1
  if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
d2017 1
a2017 1
  if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
d2390 1
a2390 1
  if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
d3634 3
@


1.128
log
@Natures embrace now sets camouflage bit, which lets you be hidden as long
as you are outside.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.127 2007/09/15 05:03:46 myc Exp myc $
d2998 1
a2998 1
			    act ("$n switches to $N", FALSE, ch, 0, vict, TO_ROOM);
d3634 4
@


1.127
log
@AFF_DROPPED_PRIM and AFF_DROPPED_SECOND were incorrectly marked as
Aff1 flags.  They should be Aff 2 flags.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.126 2007/09/08 22:37:42 jps Exp myc $
d207 1
d212 1
d3634 4
@


1.126
log
@Stop appending extra damage amounts to riposte messages.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.125 2007/09/03 23:49:40 jps Exp jps $
d3353 1
a3353 1
      if (IS_AFFECTED2 (ch, AFF_DROPPED_PRIM) || IS_AFFECTED2 (ch, AFF_DROPPED_SECOND))
d3538 1
a3538 1
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_PRIM, AFF_DROPPED_PRIM);
d3544 1
a3544 1
      HandleDroppedWeapon (ch, ACT_DELAY_DROPPED_SECOND, AFF_DROPPED_SECOND);
d3632 3
@


1.125
log
@Add mass_attack_ok() so that you could kill your own pet specifically,
but your area spells will not harm it.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.124 2007/08/26 21:10:42 jps Exp jps $
d2245 20
a2264 20
	if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
          append_damage_amount(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself!&0", vdam, TO_VICT);
	  act (b2, FALSE, ch, 0, victim, TO_VICT);
          append_damage_amount(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself!&0", vdam, TO_CHAR);
          act (b2, FALSE, ch, 0, victim, TO_CHAR);
          append_damage_amount(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0", vdam, TO_NOTVICT);
	  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
	} else {
          append_damage_amount(b2, "&8You block $n's attack, and strike back!&0", vdam, TO_VICT);
	  act (b2, FALSE, ch, 0, victim, TO_VICT);
          append_damage_amount(b2, "&8$N blocks your attack, and strikes back!&0", vdam, TO_CHAR);
	  act (b2, FALSE, ch, 0, victim, TO_CHAR);
          append_damage_amount(b2, "&7$N blocks $n's attack, and strikes back at $m!&0", vdam, TO_NOTVICT);
	  act (b2, FALSE, ch, 0, victim, TO_NOTVICT);
	}
	damage (victim, ch, vdam, vw_type);
	if (!FIGHTING (ch))
	  set_fighting (ch, victim);
	if (!FIGHTING (victim))
	  set_fighting (victim, ch);
d3632 4
@


1.124
log
@Don't append (0) to deity-immunity messages about damage.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.123 2007/08/23 01:40:10 jps Exp jps $
d183 16
d3632 3
@


1.123
log
@Make it so you can attack your own pet again.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.122 2007/08/22 22:47:43 jps Exp jps $
d1505 4
a1508 2
 * message for doing damage with a spell or skill
 *  C3.0: Also used for weapon damage on miss and death blows
d1510 1
a1510 1
int skill_message (int dam, struct char_data *ch, struct char_data *vict,
d1540 4
a1543 1
            append_damage_amount(b2, msg->god_msg.attacker_msg, dam, TO_CHAR);
d1547 4
a1550 1
            append_damage_amount(b2, msg->god_msg.victim_msg, dam, TO_VICT);
d1554 4
a1557 1
            append_damage_amount(b2, msg->god_msg.room_msg, dam, TO_NOTVICT);
d1607 1
a1607 1
         return 1;
d1610 1
a1610 1
   return 0;
d3616 3
@


1.122
log
@Add cr/lf to messages in appear().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.121 2007/08/14 22:43:07 myc Exp jps $
a144 4
  /* Feel free to hit yourself as much as you please. */
  if (ch == victim)
    return TRUE;

d158 6
d3605 3
@


1.121
log
@Cleaned up appear().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.120 2007/08/05 20:21:51 myc Exp myc $
d197 1
a197 1
         send_to_char("You step out of the shadows.", ch);
d200 1
a200 1
         send_to_char("You fade back into view.", ch);
d3603 3
@


1.120
log
@Arena death sets pos1 to resting now.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.119 2007/08/04 21:13:22 myc Exp myc $
d183 1
a183 1
void appear (struct char_data *ch)
d185 1
a185 1
   int was_hidden;
d187 2
a188 4
   if (affected_by_spell (ch, SPELL_INVISIBLE))
      affect_from_char (ch, SPELL_INVISIBLE);
   if (affected_by_spell (ch, SPELL_CONCEALMENT))
      affect_from_char (ch, SPELL_CONCEALMENT);
d190 1
a190 1
   was_hidden = AFF_FLAGS(ch) & AFF_HIDE;
d192 1
a192 1
   REMOVE_BIT (AFF_FLAGS (ch), AFF_INVISIBLE | AFF_HIDE);
d194 1
a194 1
   if (GET_LEVEL (ch) < LVL_IMMORT) {
d197 1
a197 1
         act("You step out of the shadows.", FALSE, ch, 0, 0, TO_CHAR);
d200 1
a200 1
         act("You fade back into view.", FALSE, ch, 0, 0, TO_CHAR);
d3603 3
@


1.119
log
@append_damage_amount now accepts negative values (and makes them green)
to signify healing.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.118 2007/08/04 14:40:35 myc Exp myc $
d803 1
a803 1
   GET_POS1(ch) = POS1_PRONE;
d3605 4
@


1.118
log
@Added MOB_PEACEFUL flag to prevent players from attacking certain mobs.
Won't hear death cry echoed into arena when standing in observatory.
Cleaned up damage amounts code with append_damage_amount function.  All
attacks should now have damage amounts appended (if damage_amounts is on).
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.117 2007/08/04 01:15:50 jps Exp myc $
d1252 1
a1252 1
  const char *colors[5] = {
d1258 1
d1266 4
d3605 6
@


1.117
log
@Prevent killer flagging and real death in arena rooms.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.116 2007/08/03 22:00:11 myc Exp jps $
d134 7
d761 3
a763 1
        !ROOM_FLAGGED(world[was_in].dir_option[door]->to_room, ROOM_OBSERVATORY))) {
d1248 25
d1476 1
a1476 4
  if (damage_amounts)
    sprintf(b2, "%s (&4%d&0)", buf, dam);
  else
    sprintf(b2, "%s", buf);
a1479 1
  send_to_char (CCNRM (ch, C_CMP), ch);
d1485 1
a1485 4
  if (damage_amounts)
    sprintf(b2, "%s (&3%d&0)", buf, dam);
  else
    sprintf(b2, "%s", buf);
a1486 1
  send_to_char (CCNRM (ch, C_CMP), ch);
a1488 1
  send_to_char (CCNRM (victim, C_CMP), victim);
d1494 1
a1494 4
  if (damage_amounts)
    sprintf(b2, "%s (&1&b%d&0)", buf, dam);
  else
    sprintf(b2, "%s", buf);
a1495 1
  send_to_char (CCNRM (victim, C_CMP), victim);
a1510 1
   struct obj_data *weap2 = GET_EQ (ch, WEAR_WIELD2);
d1518 3
a1520 13
   if (attacktype == SKILL_BAREHAND) {
      send_to_char(CCNRM (ch, C_CMP), ch);
      act("You punch $N in the throat causing $M to choke and die from $S own blood!",
            FALSE, ch, 0, vict, TO_CHAR);
      send_to_char(CCNRM (ch, C_CMP), ch);
      send_to_char(CCNRM (vict, C_CMP), vict);
      act("You gasp for air as your own blood chokes you to death!",
            FALSE, ch, 0, vict, TO_VICT);
      send_to_char(CCNRM (vict, C_CMP), vict);
      act("$n punches $N in the throat causing $M to choke and die from $S own blood!",
            FALSE, ch, 0, vict, TO_NOTVICT);
      return 1;
   }
d1530 13
a1542 4
            /* IMMORTAL MESSAGE*/
            act(msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
            act(msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
            act(msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
d1547 3
a1549 10
               /* TO DAMAGER */
               send_to_char (CCNRM (ch, C_CMP), ch);
               if (attacktype == SKILL_BAREHAND)
                  act("You punch $N in the throat causing $M to choke and die from $S own blood!",
                        FALSE, ch, 0, vict, TO_CHAR);
               else if (attacktype == SKILL_2BACK)
                  act(msg->die_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
               else
                  act(msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
               send_to_char(CCNRM (ch, C_CMP), ch);
d1552 2
a1553 9
               send_to_char(CCNRM (vict, C_CMP), vict);
               if (attacktype == SKILL_BAREHAND)
               act("You gasp for air as your own blood chokes you to death!",
                     FALSE, ch, 0, vict, TO_VICT);
               else if (attacktype == SKILL_2BACK)
                  act(msg->die_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
               else
                  act(msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
               send_to_char(CCNRM (vict, C_CMP), vict);
d1556 2
a1557 7
               if (attacktype == SKILL_BAREHAND)
                  act("$n punches $N in the throat causing $M to choke and die from $S own blood!",
                        FALSE, ch, 0, vict, TO_NOTVICT);
               else if (attacktype == SKILL_2BACK)
                  act(msg->die_msg.room_msg, FALSE, ch, weap2, vict, TO_NOTVICT);
               else
                  act(msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
d1561 2
a1562 5
               /* TO DAMAGER */

                  /* Don't display the damager message if they are 
                     damaging themself. Otherwise there will be (null)
                     messages for poison, on fire, and circle of fire. */
d1564 2
a1565 15
                  send_to_char(CCNRM (ch, C_CMP), ch);
                  if (attacktype == SKILL_2BACK) {
                     if (damage_amounts)
                        sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
                     else
                        sprintf(b2, "%s", msg->hit_msg.attacker_msg); 
                     act(b2, FALSE, ch, weap2, vict, TO_CHAR);
                  } else {
                     if (damage_amounts)
                        sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
                     else
                        sprintf(b2, "%s", msg->hit_msg.attacker_msg); 
                     act(b2, FALSE, ch, weap, vict, TO_CHAR);
                  }
                  send_to_char(CCNRM (ch, C_CMP), ch);
d1568 3
a1570 16
               /* TO VICTIM */
               send_to_char (CCNRM (vict, C_CMP), vict);
               if (attacktype == SKILL_2BACK) {
                  if (damage_amounts)
                     sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
                  else
                     sprintf(b2, "%s", msg->hit_msg.victim_msg); 
                  act(b2, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
               } else {
                  if (damage_amounts)
                     sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
                  else
                     sprintf(b2, "%s", msg->hit_msg.victim_msg); 
                  act(b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
               }
               send_to_char (CCNRM (vict, C_CMP), vict);
d1572 2
a1573 5
               /* TO ROOM */
               if (damage_amounts)
                  sprintf(b2, "%s (&4%d&0)", msg->hit_msg.room_msg, dam); 
               else
                  sprintf(b2, "%s", msg->hit_msg.room_msg); 
d1577 1
a1577 3
            /* MISS MESSAGE */

            /* Dam == 0 */
d1580 2
a1581 6
            send_to_char (CCNRM (ch, C_CMP), ch);
            if (attacktype == SKILL_2BACK)
               act(msg->miss_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
            else
               act(msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
            send_to_char(CCNRM (ch, C_CMP), ch);
d1584 2
a1585 6
            send_to_char(CCNRM (vict, C_CMP), vict);
            if (attacktype == SKILL_2BACK)
               act(msg->miss_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
            else
               act(msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
            send_to_char(CCNRM (vict, C_CMP), vict);
d1588 2
a1589 1
            act(msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
d2214 1
a2214 4
          if (damage_amounts)
            sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", vdam);
          else
            sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself!");
d2216 1
a2216 4
          if (damage_amounts)
    	    sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", vdam);
	  else
            sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself!");
d2218 1
a2218 4
          if (damage_amounts)
	    sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", vdam);
          else
	    sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself!");
d2221 1
a2221 4
          if (damage_amounts)
  	    sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", vdam);
          else
	    sprintf(b2, "&8You block $n's attack, and strike back!");
d2223 1
a2223 4
          if (damage_amounts)
	    sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", vdam);
          else
 	    sprintf(b2, "&8$N blocks your attack, and strikes back!");
d2225 1
a2225 4
          if (damage_amounts)
	    sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&1&b%d&0&7)&0", vdam);
          else
	    sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m!");
d2581 1
a2581 4
                  if (damage_amounts)
        	    sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", vdam);
                  else
        	    sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself!");
d2583 1
a2583 4
                  if (damage_amounts)
		    sprintf(b2, "&8$Ngrabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", vdam);
                  else
		    sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself!");
d2585 1
a2585 4
                  if (damage_amounts)
		    sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", vdam);
                  else
		    sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself!");
d2588 1
a2588 4
                  if (damage_amounts)
		    sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", vdam);
                  else
		    sprintf(b2, "&8You block $n's attack, and strike back!");
d2590 1
a2590 4
                  if (damage_amounts)
		    sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", vdam);
                  else
		    sprintf(b2, "&8$N blocks your attack, and strikes back!");
d2592 1
a2592 4
                  if (damage_amounts)
		    sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", vdam);
                  else
		    sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", vdam);
d3600 3
@


1.116
log
@Added PK observatories that work adjacent to arena rooms.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.115 2007/08/03 03:51:44 myc Exp myc $
d59 1
d534 3
d762 23
d786 23
d842 19
a860 1
  /* this guy died ..zero the mem_list */
d877 1
a878 12
  
  /* show death cry if its charmed and there's a killer */
  if (is_charmed) {
    if (killer)
      death_cry (ch);
  }
  /*
   * always run the death trigger for uncharmed mobs, but don't death cry
   * if it returns 0 or if there's no killer
   */
  else if (death_mtrigger (ch, killer) && killer)
    death_cry (ch);
a879 1
  /* moved the extract_char functions so that they are the last things to be executed. gurlaek 9/7/1999 */
d1110 3
d1929 2
a1930 1
        send_to_char("You receive your share of experience.\r\n", ch);
d3677 3
@


1.115
log
@check_pk is now attack_ok, and covers many more cases than before,
including peaced rooms, shapeshifted pk, and arena rooms.  Almost all
offensive attacks now use attack_ok to determine whether an attack is
allowed.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.114 2007/08/02 01:04:10 myc Exp myc $
d142 2
a143 2
  if (ROOM_FLAGGED(victim->in_room, ROOM_PK) && 
      ROOM_FLAGGED(ch->in_room, ROOM_PK))
d748 3
a750 1
    if (CAN_GO(ch, door)) {
d3617 6
@


1.114
log
@check_pk() now works for all PK cases.  Moved from magic.c to fight.c
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.113 2007/08/01 02:10:16 jps Exp myc $
d118 3
a120 3
 * This function determines whether ch attacking victim would be
 * considered PK.  Returns TRUE if this is an unallowed PK action,
 * and FALSE if the action should go forward.
d122 12
a133 2
bool check_pk(struct char_data *ch, struct char_data *victim) {
  /* PK is on, the attack is ok */
d135 18
a152 1
    return FALSE;
d155 1
a155 1
  if (IS_PC(ch) && IS_PC(victim))
d157 12
a168 2
    return !((IS_NPC(ch) && GET_LEVEL(ORIG_CHAR(ch)) >= LVL_GOD) ||
             (IS_NPC(victim) && GET_LEVEL(ORIG_CHAR(victim)) >= LVL_GOD));
d175 1
a175 2
void 
appear (struct char_data *ch)
d203 1
a203 2
void 
load_messages (void)
d269 1
a269 2
void 
update_pos (struct char_data *victim)
d531 1
a531 2
void 
check_killer (struct char_data *ch, struct char_data *vict)
d549 1
a549 2
void 
set_fighting (struct char_data *ch, struct char_data *vict)
d568 3
d575 1
d581 1
a581 2
void 
stop_fighting (struct char_data *ch)
d696 1
a696 2
void 
change_alignment (struct char_data *ch, struct char_data *victim)
a738 50
/* When ch kills victim */
void 
old_change_alignment (struct char_data *ch, struct char_data *victim)
{
  int change = 0;
 
  /* If the character is good */
  if(GET_ALIGNMENT(ch) > 350) {
    /* Vict Good */
    if(GET_ALIGNMENT(victim) > 350) {
       if(GET_ALIGNMENT(victim) > GET_ALIGNMENT(ch))
         change += ((GET_ALIGNMENT(ch)-GET_ALIGNMENT(victim))/40-9);
       else
         change += ((GET_ALIGNMENT(victim)-GET_ALIGNMENT(ch))/50-6);
    } else if(GET_ALIGNMENT(victim) > -351) {
       change += (GET_ALIGNMENT(victim)/-80);
       if((change == 0) && (GET_ALIGNMENT(victim) >= 0))
         change += -1;
    } else {
       change += (GET_ALIGNMENT(victim)/-150);
    }
  } else if(GET_ALIGNMENT(ch) > -351) { /* Char is neutral */
    if(GET_ALIGNMENT(victim) > 0)
       change -= ((1135 - GET_ALIGNMENT(victim))/100);
    else
       change += ((1275 + GET_ALIGNMENT(victim))/100);
  } else { /* Char is evil */
    if(GET_ALIGNMENT(victim) < GET_ALIGNMENT(ch))
       change += MAX(1, ((GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch))/-200));
    else
       change += ((GET_ALIGNMENT(victim)-GET_ALIGNMENT(ch))/-100);
  }
  
  if ((GET_ALIGNMENT(ch) < -350) && (change > 1))
    change = BOUNDED(1, change - (GET_LEVEL(ch) / 15), change); 
  if ((GET_ALIGNMENT(ch) > 350) && (change < 0))
    change -= (GET_LEVEL(ch) / 3);
  if (change < 0) {
    while (change < 0) {
      GET_ALIGNMENT(ch) -= (number(0, 9) < MIN(10, -(change)));
      change += 7;
    }
  } else {
    while (change > 0) {
      GET_ALIGNMENT(ch) += (number(0, 9) < MIN(10, change));
      change -= 10;
    }
  }
  GET_ALIGNMENT(ch) = BOUNDED(-1000, GET_ALIGNMENT(ch), 1000);
}
d740 1
a740 2
void 
death_cry (struct char_data *ch)
d744 1
a744 1
  act ("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);
d747 5
a751 8
  for (door = 0; door < NUM_OF_DIRS; door++)
    {
      if (CAN_GO (ch, door))
	{
	  ch->in_room = world[was_in].dir_option[door]->to_room;
	  act ("Your blood freezes as you hear someone's death cry.", FALSE, ch, 0, 0, TO_ROOM);
	  ch->in_room = was_in;
	}
d753 1
d1041 1
a1041 2
void 
group_gain (struct char_data *ch, struct char_data *victim)
d1145 1
a1145 2
char *
replace_string (char *str, char *weapon_singular, char *weapon_plural)
d1179 1
a1179 2
void 
dam_message (int dam, struct char_data *ch, struct char_data *victim,
d1421 1
a1421 2
int 
skill_message (int dam, struct char_data *ch, struct char_data *vict,
a1585 2
  char bugbuf[MAX_STRING_LENGTH];
  char buf[MAX_STRING_LENGTH];
d1592 5
a1596 7
  if (GET_POS (victim) <= POS_DEAD)
    {
      sprintf(bugbuf, "room num %d", victim->in_room);
      log (bugbuf);
      log ("SYSERR: Attempt to damage a corpse.");
      return;			/* -je, 7/7/92 */
    }
d1598 2
a1599 39
  /* peaceful rooms */
  if (ch != victim && ROOM_FLAGGED (ch->in_room, ROOM_PEACEFUL))
    {
      send_to_char ("You feel ashamed trying to disturb the peace of this room.\r\n", ch);
      return;
    }
  
  if (!pk_allowed) {
     if (!IS_NPC(ch) && !IS_NPC(victim) && ch != victim) {
        send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
        return;
     }
     if (ch->master != NULL)
        if (!IS_NPC(ch->master) && !IS_NPC(victim)) {
           if (FIGHTING(ch)) {
           send_to_char("Sorry, player killing isn't allowed.\r\n", ch->master);
           send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
           return;
           }
        }
     /* Check for a shapechanged player */
     if (!IS_NPC(ch) && victim->desc && victim->desc->original &&
         GET_LEVEL(victim->desc->original) < 100) {
        send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
        return;
     }
     if (!IS_NPC(victim) && ch->desc && ch->desc->original &&
         GET_LEVEL(ch->desc->original) < 100) {
        send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
        return;
     }
     if (victim->desc && victim->desc->original &&
         GET_LEVEL(victim->desc->original) < 100 &&
         ch->desc && ch->desc->original &&
         GET_LEVEL(ch->desc->original) < 100) {
        send_to_char("Sorry, player killing isn't allowed.\r\n", ch);
        return;
     }
  }
a1600 13
  /* Checks for Proc Rooms */
  if (ch->in_room == real_room (30761))
    {
      if (GET_LEVEL (ch) < LVL_IMMORT && (!IS_NPC (ch)))
	{
	  GET_HIT (ch) = 1;
	}
      send_to_char ("&0&6As you prepare to attack, a beam of &0&b&8white energy&0&6 blasts from the wall and assaults your spirit!&0\r\n", ch);
      act ("&0$n is struck by a bolt of &0&b&8white energy&0 leaving $m badly injured.\r\n", FALSE, ch, 0, 0, TO_ROOM);
      return;
    }
  
  
a1607 23
  /*reduces damage for all things bar spells */
  if (!IS_NPC (ch) && !IS_NPC (victim))
    if (attacktype > MAX_SPELLS)
      /* dam >>= 1; */
      /* new to lower a little more Banyal */
      dam = dam / 3;
  /* You can't damage an immortal! */
  if (!IS_NPC (victim) && (GET_LEVEL (victim) >= LVL_IMMORT))
    dam = 0;
  if (victim != ch)
    {
      if (GET_POS (ch) > POS_STUNNED)
	{
	  if (attacktype >= MAX_SPELLS)
	    if (FIGHTING (ch) == NULL)
	      set_fighting (ch, victim);
	  
	  if (IS_NPC (ch) && IS_NPC (victim) && victim->master &&
	      (number (0, 100) == 0) && IS_AFFECTED (victim, AFF_CHARM) &&
	      (victim->master->in_room == ch->in_room) && CAN_SEE(ch, victim->master))
	    {
	      if (FIGHTING (ch))
		stop_fighting (ch);
d1609 21
a1629 10
	      sprintf (buf, "&6&b$n observes your command over %s and attacks YOU instead!&0",
	      GET_NAME(victim));
	      act (buf, FALSE, ch, 0, victim->master, TO_VICT);

	      sprintf (buf, "&6&b$n observes $N commanding %s and attacks $M instead!&0", 
	      GET_NAME(victim));
	      act (buf, FALSE, ch, 0, victim->master, TO_NOTVICT);
	      sprintf (buf, "&6&bYou observes $N commanding %s and attacks $M instead!&0", 
	      GET_NAME(victim));
	      act (buf, FALSE, ch, 0, victim->master, TO_CHAR);
d1631 3
a1633 15
	      hit (ch, victim->master, TYPE_UNDEFINED);
	      return;
	    }
	}
      if (GET_POS (victim) > POS_STUNNED && (FIGHTING (victim) == NULL))
	{
	  if (attacktype >= MAX_SPELLS ||
	      (!PRF_FLAGGED (victim, PRF_PASSIVE) && attacktype < MAX_SPELLS)
	      || (IS_NPC (victim) && attacktype < MAX_SPELLS))
	    set_fighting (victim, ch);
	}
      if (MOB_FLAGGED (victim, MOB_MEMORY) && !IS_NPC (ch) &&
	  (GET_LEVEL (ch) < LVL_IMMORT))
	remember (victim, ch);
      
d1635 12
d1648 1
a1648 1
    stop_follower (victim, 1);
d1650 14
a1663 6
  if (IS_AFFECTED (ch, AFF_INVISIBLE | AFF_HIDE))
    appear (ch);
  
  /* Pets and charmes act as pc's*/
  
  if(IS_AFFECTED (ch, AFF_CHARM))
d1665 3
a1667 1
  if(IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))
d1670 1
a1670 6
  if (IS_AFFECTED (victim, AFF_SANCTUARY))
    dam /= 2;		/* 1/2 damage when sanctuary */
  
  if (IS_AFFECTED (victim, AFF_STONE_SKIN))
    dam >>= 1;

d1672 1
a1672 1
    dam = (dam * 2) / 3;
d1674 3
a1676 2
  if (IS_AFFECTED (victim, AFF_PROTECT_EVIL) &&
      GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
d1678 3
a1680 2
  else if (IS_AFFECTED (victim, AFF_PROTECT_GOOD) &&
      GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
d1683 16
a1698 14
  if (IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS))
    {
      act ("$n's crushing blow frees $N from a magic which held $M motionless.",
	   FALSE, ch, 0, victim, TO_ROOM);
      act ("$n's blow shatters the magic paralyzing you!", FALSE, ch, 0,
	   victim, TO_VICT);
      act ("Your blow disrupts the magic keeping $N frozen.", FALSE, ch, 0,
	   victim, TO_CHAR);
      
      affect_from_char (victim, SPELL_MINOR_PARALYSIS);
      affect_from_char (victim, SPELL_ENTANGLE);
      REMOVE_BIT (AFF2_FLAGS(victim), AFF2_MINOR_PARALYSIS);
    }
  check_justice (ch, victim);
d1701 2
d1704 4
a1707 7
    {
      check_killer (ch, victim);
       /*   check_justice (ch, victim); */
      
      /*  if (PLR_FLAGGED (ch, PLR_KILLER) && (ch != victim)) */
	 /*  dam = 0; */
    }
d1709 9
a1717 8
  dam = MAX (MIN (dam, 1000), 0);
  alter_hit (victim, dam, 2);
  update_pos (victim);
  
  if(!wielded && !hwielded && !vhwielded && !vwielded) {
    if (IS_AFFECTED3(ch, AFF3_VAMP_TOUCH)) {
      if(IS_NPC(ch))
	alter_hit (ch,( -1 * dam / 2), 2);
d1719 1
a1719 1
	alter_hit (ch,(-1 * dam), 2);
d1722 5
a1726 4
      if(!IS_NPC(ch)) {
	if((GET_SKILL(ch, SKILL_VAMP_TOUCH)) > (number(0, 101)))
	  alter_hit(ch, ( -1 * dam / 2), 2);
	if(number(0, 2))
d1731 6
a1736 11
  if (ch != victim) {
    if (IS_NPC (ch)) {
      ;			
      /*  gain_exp(ch, ((GET_LEVEL(victim)/2) * (dam/4))); */
    } else {
      if ((GET_LEVEL (ch) - GET_LEVEL (victim)) > 10)
	gain_exp (ch, victim, (GET_LEVEL (victim) * (long) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
      else
	gain_exp (ch, victim, (GET_LEVEL (victim) * (long) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
    }
  }  
d1748 11
a1758 4
  if (attacktype == SKILL_BAREHAND)
     if (GET_POS(victim) == POS_DEAD)
	skill_message (dam, ch, victim, attacktype);
     else
d1760 3
a1762 2
  else if (!IS_WEAPON (attacktype)) {
    skill_message (dam, ch, victim, attacktype);
a1763 10
  else
    {
      if (GET_POS (victim) == POS_DEAD || dam == 0)
	{
	  if (!skill_message (dam, ch, victim, attacktype))
	    dam_message (dam, ch, victim, attacktype);
	}
      else
	dam_message (dam, ch, victim, attacktype);
    }
d1767 28
a1794 36
    if (IS_AFFECTED2 (victim, AFF2_FIRESHIELD))
      {
	if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	  act ("&1&bThe globe around your body absorbs the burning flames!&0", FALSE, ch, 0, 0, TO_CHAR);
	else
	  {
	    act ("&1Your limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_CHAR);
	    act ("&1$n&0&1's limbs are seared by your shield of flames.&0", FALSE, ch, 0, victim, TO_VICT);
	    act ("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_NOTVICT);
	  }
      }
    if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD))
      {
	if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	  act ("&4&bThe globe around your body absorbs the killing ice!&0", FALSE, ch, 0, 0, TO_CHAR);
	else
	  {
	 act ("&4You are impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_CHAR);
	 act ("&4$n&0&4 is impaled on your shield of ice.&0", FALSE, ch, 0, victim, TO_VICT);
	 act ("&4$n&0&4 is impaled on $N&0&4's shield of ice.&0", FALSE, ch, 0, victim, TO_NOTVICT);
	  }
      }
    if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
      {
	if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
	  {
	    act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	  }
	if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
	  {
	    act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	  }
d1796 1
d1800 1
a1800 2
  switch (GET_POS (victim))
    {
d1826 12
a1837 36
      if (GET_HIT (victim) < (GET_MAX_HIT (victim) >> 2))
	{
	  sprintf (buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		   CCRED (victim, C_SPR), CCNRM (victim, C_SPR));
	  send_to_char (buf2, victim);
	  if (MOB_FLAGGED (victim, MOB_WIMPY) && (ch != victim) &&
	      !(IS_AFFECTED(victim, AFF_CHARM)))
	    {
	      do_flee (victim, "", 0, 0);
          /* 2/10/02 - DCE - Removed the following two statements. I am
             fairly certain that they are causing a lot of problems in
             the fighting routine. The do_flee function takes care of the
             stop fighting call, and it should, because you can fail a
             flee. As it was, wimpy always made a person stop fighting
             even if they didn't flee.
	      if (FIGHTING (ch))
		stop_fighting (ch); */
	    }
	  
	  
	  
	  
      }
      if (!IS_NPC (victim) && GET_WIMP_LEV (victim) && (victim != ch) &&
	  GET_HIT (victim) < GET_WIMP_LEV (victim))
	{
          send_to_char ("You attempt to flee!\r\n", victim);
	  do_flee (victim, "", 0, 0);
          /* 2/10/02 - DCE - Removed the following two statements. I am
             fairly certain that they are causing a lot of problems in
             the fighting routine. The do_flee function takes care of the
             stop fighting call, and it should, because you can fail a
             flee. As it was, wimpy always made a person stop fighting
             even if they didn't flee.
                if (FIGHTING (ch))
                  stop_fighting (ch); */
d1840 49
a1888 72
    }
  
  if (!AWAKE (victim))
    if (FIGHTING (victim))
      stop_fighting (victim);
  
  if (GET_POS (victim) == POS_DEAD)
    {
      if (IS_NPC (victim) || victim->desc) {
	if (IS_AFFECTED (ch, AFF_GROUP))
	  group_gain (ch, victim);
	else
	  {
	    exp = GET_EXP (victim); /* cap for exp is in max_exp_gain() in gain_exp() */
	    /* Calculate level-difference bonus */
	    if (IS_NPC (ch))
	      exp += MAX (0, (exp * MIN (2, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);
	    else
	      exp += MAX (0, (exp * MIN (3, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);

	    exp = MAX (exp, 1);
	    /*check for mortal */
	    if (IS_NPC (victim))
	      exp = GET_EXP (victim);
	    else
	      /*I will give 10 k exp per level for a opp race pkill
		and a 3 k exp per level for a sim race pkill */
	      if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
		/* This was being badly abused, ask me Banyal */
		/* exp = GET_LEVEL(victim) * 7000; */
		exp = 70;
	      else
		/*  exp = GET_LEVEL(victim) * 2000; */
		exp = 70;
	    /*Trophy decrease */
	    exp = perform_trophy_decrease (ch, victim, exp);
	    if (exp > 1)
	      {
		sprintf (buf2, "You receive your share of experience.\r\n");
		send_to_char (buf2, ch);
	      }
	    else
	      send_to_char ("You receive your share of experience.\r\n", ch);
	    /*  sprintf(buf, "Not grouped before modified %d.\r\n",
		exp);
		send_to_char(buf, ch);
	    */
	    if (GET_LEVEL (ch) < GET_LEVEL (victim))
	      exp = exp_highlevel_bonus (exp, (GET_LEVEL (victim) - GET_LEVEL (ch)));
	    /*              sprintf(buf, "Not grouped after modified
			    %d.\r\n", exp);
			    send_to_char(buf, ch);
	    */ 
	    gain_exp (ch, victim, exp);
	    change_alignment (ch, victim);
	  }
      }
      if (!IS_NPC (victim))
	{
	  sprintf (buf2, "%s killed by %s at %s", GET_NAME (victim), GET_NAME (ch),
		   world[victim->in_room].name);
	  mudlog (buf2, BRF, LVL_IMMORT, TRUE);
	  if (MOB_FLAGGED(ch, MOB_MEMORY))
	     /*    forget(ch, victim);  */
	    Forgive_The_Basterd(victim);
	}
      Forgive_The_Basterd(ch);
      if (attacktype == TYPE_SUFFERING)
         slow_death(victim);
      else
         die(victim, ch);
    }
d1917 2
a1918 3
  /* no more skill advancement in peace rooms --gurlaek 7/25/1999 */
  if (ROOM_FLAGGED(victim->in_room, ROOM_PEACEFUL)) {
    if(ch)
d1920 4
a1926 13

  if(event_target_valid(victim) == 0 )
    {
      if(ch)
	stop_fighting (ch);
      return;
    }
  
  if(event_target_valid(ch) == 0 )
    {
      stop_fighting (victim);
      return;
    }
d1939 10
a1948 42
  fight_mtrigger (ch);
  
  if (!pk_allowed) {
     if (!IS_NPC(ch) && !IS_NPC(victim)) {
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
     }
     if (ch->master != NULL)
        if (!IS_NPC(ch->master) && !IS_NPC(victim)) {
           if (FIGHTING(ch)) {
              stop_fighting(ch);
              stop_fighting(victim);
              return;
           }
        }
    /* Check for a shapechanged player */
    if (!IS_NPC(ch) && victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
    if (!IS_NPC(victim) && ch->desc && ch->desc->original &&
        GET_LEVEL(ch->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
    if (victim->desc && victim->desc->original && 
        GET_LEVEL(victim->desc->original) < 100 &&
        ch->desc && ch->desc->original &&
        GET_LEVEL(ch->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
d1951 5
a1955 6
  if (ch->in_room != victim->in_room)
    {
      if (FIGHTING (ch) && FIGHTING (ch) == victim)
	stop_fighting (ch);
      return;
    }
d1957 1
a1957 2
  if((FIGHTING(ch) != victim) &&
     ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell(ch, SPELL_BLINDNESS)))) {
d1960 1
a1960 1
  } 
d1962 1
a1962 1
  if (IS_AFFECTED (ch, AFF_INVISIBLE | AFF_HIDE))
d1965 1
a1965 1
  if (GET_SKILL (victim, SKILL_DODGE))
d2336 13
a2348 5
  /* no more skill advancement in peace rooms --gurlaek 7/25/1999 */
  if (ROOM_FLAGGED(victim->in_room, ROOM_PEACEFUL)) {
    if(ch)
      stop_fighting (ch);
    stop_fighting (victim);
a2351 48
  if (ch->in_room != victim->in_room)
    {
      if (FIGHTING (ch) && FIGHTING (ch) == victim)
	stop_fighting (ch);
      return;
    }
  
  if (!pk_allowed) {
     if (!IS_NPC(ch) && !IS_NPC(victim)) {
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
     }
     if (ch->master != NULL)
        if (!IS_NPC(ch->master) && !IS_NPC(victim)) {
           if (FIGHTING(ch)) {
              stop_fighting(ch);
              stop_fighting(victim);
              return;
           }
        }
     /* Check for a shapechanged player */
    if (!IS_NPC(ch) && victim->desc && victim->desc->original &&
        GET_LEVEL(victim->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
    if (!IS_NPC(victim) && ch->desc && ch->desc->original &&
        GET_LEVEL(ch->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
    if (victim->desc && victim->desc->original && 
        GET_LEVEL(victim->desc->original) < 100 &&
        ch->desc && ch->desc->original &&
        GET_LEVEL(ch->desc->original) < 100)
        if (FIGHTING(ch)) {
           stop_fighting(ch);
           stop_fighting(victim);
           return;
        }
 }
d2353 1
a2353 1
  if (IS_AFFECTED (ch, AFF_INVISIBLE | AFF_HIDE))
d2837 1
a2837 2
int 
weapon_special (struct obj_data *wpn, struct char_data *ch)
d3210 1
a3210 2
void 
make_fun_body_pieces (struct char_data *ch, struct char_data *killer)
d3273 1
a3273 2
bool 
PickupDisarmedWeapon (struct char_data *ch)
d3324 1
a3324 2
bool 
DisarmCheck (struct char_data * ch)
d3370 1
a3370 2
void 
HandleFumblingWeapon (struct char_data *ch, int action_delay_type, int affect_type)
d3399 1
a3399 2
void 
HandleDroppedWeapon (struct char_data *ch, int action_delay_type, int affect_type)
d3484 1
a3484 2
bool 
DisarmRecovery (struct char_data *ch)
d3536 1
a3536 2
void 
StopMercifulAttackers (struct char_data *ch)
d3615 3
@


1.113
log
@Reduce the speed at which tame improves a bit.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.112 2007/07/18 23:54:07 jps Exp jps $
d116 22
d3848 3
@


1.112
log
@Messages will reflect the actual weapon used when someone backstabs
with a piercing weapon in their off hand.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.111 2007/07/18 21:04:26 jps Exp jps $
d3326 1
a3326 2
  if (skill == SKILL_TAME ||
          skill == SKILL_FIRST_AID ||
d3331 2
a3332 1
  else if (skill == SKILL_BASH ||
d3826 4
@


1.111
log
@Make mobs behave mercifully toward other mobs only when
they are flagged NOVICIOUS.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.110 2007/07/18 16:47:37 jps Exp jps $
d1473 2
d1484 2
d1494 2
d3826 4
@


1.110
log
@Stop active-defense spells such as fireshield from harming self.
This problem had cropped up when someone was ON_FIRE and had
fireshield at the same time.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.109 2007/07/14 04:17:35 jps Exp jps $
d3743 7
a3749 8
  struct char_data *t_ch;
  struct char_data *hold;
  
  if (!ch)
    return;
  
  for (t_ch = combat_list; t_ch; t_ch = hold)
    {
d3751 3
a3753 5
      if ((t_ch->char_specials.fighting == ch) &&
	  ((!IS_NPC (t_ch) && !PRF_FLAGGED (t_ch, PRF_VICIOUS)) ||
	   (IS_NPC (t_ch) && !is_aggr_to (t_ch, ch))))
	stop_fighting (t_ch);	/* mob check above commented out till i finish code */
    }
d3820 5
@


1.109
log
@Updated call to stop_follower(), which cares whether this is being
done due to a violent action or not.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.108 2007/06/24 23:55:25 myc Exp jps $
d1822 3
a1824 2
   /*  stops these shileds from hurting casters from spells casted -Banyal */
  if (attacktype > MAX_SPELLS) {
d3823 4
@


1.108
log
@Removed the double skill improvement for dodge, parry, and riposte.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.107 2007/06/15 00:47:05 myc Exp myc $
d57 1
a57 1
void stop_follower (struct char_data *ch);
d1709 1
a1709 1
    stop_follower (victim);
d3822 3
@


1.107
log
@Vaporform is a bit overpowered, toning it down.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.106 2007/06/07 23:53:38 myc Exp myc $
a2381 1
	improve_skill (victim, SKILL_RIPOST);
a2395 1
	improve_skill (victim, SKILL_PARRY);
a2420 1
	improve_skill (victim, SKILL_DODGE);
a2806 1
	      improve_skill (victim, SKILL_RIPOST);
a2818 1
	      improve_skill (victim, SKILL_PARRY);
a2837 2
	      
	      improve_skill (victim, SKILL_DODGE);
d3822 3
@


1.106
log
@Fixing skill messages to work with 2H weapons.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.105 2007/06/03 03:46:27 jps Exp myc $
d2135 1
a2135 1
            hurm1 += GET_SKILL (victim, SKILL_DODGE);
d2569 1
a2569 1
            hurm1 += GET_SKILL (victim, SKILL_DODGE);
d3829 3
@


1.105
log
@Formatted skill_message.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.104 2007/05/11 20:13:28 myc Exp jps $
d1434 4
d3829 3
@


1.104
log
@Vaporform is a new circle 13 spell for cryomancers.  It significantly
increases the caster's chance of dodging a hit.  It is a quest spell.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.103 2007/04/19 00:53:54 jps Exp myc $
d1425 22
a1446 8
  int i, j, nr;
  char b2[256];
  struct message_type *msg;
  
  struct obj_data *weap = GET_EQ (ch, WEAR_WIELD);
  struct obj_data *weap2 = GET_EQ (ch, WEAR_WIELD2);

  memset(b2, 0x0, 256);
d1448 3
a1450 16
  if (attacktype == SKILL_BAREHAND) {
     send_to_char (CCNRM (ch, C_CMP), ch);
     act ("You punch $N in the throat causing $M to choke and die from $S own blood!", FALSE, ch, 0, vict, TO_CHAR);
     send_to_char (CCNRM (ch, C_CMP), ch);
     send_to_char (CCNRM (vict, C_CMP), vict);
     act ("You gasp for air as your own blood chokes you to death!", FALSE, ch, 0, vict, TO_VICT);
     send_to_char (CCNRM (vict, C_CMP), vict);
     act ("$n punches $N in the throat causing $M to choke and die from $S own blood!", FALSE, ch, 0, vict, TO_NOTVICT);
     return 1;
  }

  for (i = 0; i < MAX_MESSAGES; i++)
    {
      if (fight_messages[i].a_type == attacktype)
	{
	  nr = dice (1, fight_messages[i].number_of_attacks);
d1452 2
a1453 2
	  for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
	    msg = msg->next;
d1455 35
a1489 19
          /* IMMORTAL MESSAGE*/
	  if (!IS_NPC (vict) && (GET_LEVEL (vict) >= LVL_IMMORT))
	    {
	      act (msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	      act (msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
	      act (msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	  else if (dam != 0)
	    {
              /* DEATH MESSAGE */
	      if (GET_POS (vict) == POS_DEAD)
		{
                  /* TO DAMAGER */
		  send_to_char (CCNRM (ch, C_CMP), ch);
                  if (attacktype == SKILL_BAREHAND)
		     act ("You punch $N in the throat causing $M to choke and die from $S own blood!", FALSE, ch, 0, vict, TO_CHAR);
		  else
		     act (msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
		  send_to_char (CCNRM (ch, C_CMP), ch);
d1491 1
a1491 7
		  /* TO VICTIM */
		  send_to_char (CCNRM (vict, C_CMP), vict);
                  if (attacktype == SKILL_BAREHAND)
		     act ("You gasp for air as your own blood chokes you to death!", FALSE, ch, 0, vict, TO_VICT);
		  else
		     act (msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
		  send_to_char (CCNRM (vict, C_CMP), vict);
a1492 10
		  /* TO ROOM */
                  if (attacktype == SKILL_BAREHAND)
		     act ("$n punches $N in the throat causing $M to choke and die from $S own blood!", FALSE, ch, 0, vict, TO_NOTVICT);
		  else
		     act (msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
		}
              /* NORMAL DAMAGE */
	      else
		{
                  /* TO DAMAGER */
d1494 6
a1499 7
                     damaging themself.  This will get rid of the (null)
                     messages for poison, on fire, and circle of fire.
                     -myc 28 Jan 2007 */
                  if(ch != vict) {
		    send_to_char (CCNRM (ch, C_CMP), ch);
		    if (attacktype == SKILL_2BACK) {
                      if (damage_amounts)
d1501 1
a1501 1
                      else
d1503 3
a1505 3
		      act (b2, FALSE, ch, weap2, vict, TO_CHAR);
		    } else {
                      if (damage_amounts)
d1507 1
a1507 1
                      else
d1509 1
a1509 3
		      act (b2, FALSE, ch, weap, vict, TO_CHAR);
                    }
		    send_to_char (CCNRM (ch, C_CMP), ch);
d1511 2
d1514 9
a1522 18
		  /* TO VICTIM */
		  send_to_char (CCNRM (vict, C_CMP), vict);
		  if (attacktype == SKILL_2BACK) {
                    if (damage_amounts)
                      sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
                    else
                      sprintf(b2, "%s", msg->hit_msg.victim_msg); 
		    act (b2, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
		  } else {
                    if (damage_amounts)
                      sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
                    else
                      sprintf(b2, "%s", msg->hit_msg.victim_msg); 
		    act (b2, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
		  }
		  send_to_char (CCNRM (vict, C_CMP), vict);

		  /* TO ROOM */
d1524 1
a1524 1
                    sprintf(b2, "%s (&4%d&0)", msg->hit_msg.room_msg, dam); 
d1526 40
a1565 30
                    sprintf(b2, "%s", msg->hit_msg.room_msg); 
		  act (b2, FALSE, ch, weap, vict, TO_NOTVICT);
		}
	    }
          /* MISS MESSAGE */
	  else if (ch != vict)
	    {			/* Dam == 0 */
              /* TO DAMAGER */
	      send_to_char (CCNRM (ch, C_CMP), ch);
	      if (attacktype == SKILL_2BACK)
		act (msg->miss_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
	      else
		act (msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	      send_to_char (CCNRM (ch, C_CMP), ch);

	      /* TO VICTIM */
	      send_to_char (CCNRM (vict, C_CMP), vict);
	      if (attacktype == SKILL_2BACK)
		act (msg->miss_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
	      else
		act (msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	      send_to_char (CCNRM (vict, C_CMP), vict);

	      /* TO ROOM */
	      act (msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	  return 1;
	}
    }
  return 0;
d3825 4
@


1.103
log
@Create macros for stopping spellcasting.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.102 2007/04/18 00:37:17 myc Exp jps $
d2045 5
d2125 7
a2131 4
	  hurm1 += dex_app[GET_DEX (victim)].defensive;
/*	  if(IS_NPC(victim))
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
	  else */
d2152 2
a2153 1
	      hurm1 += dex_app[GET_DEX (victim)].defensive;
d2175 2
a2176 1
	      hurm1 += dex_app[GET_DEX (victim)].defensive;
d2559 7
a2565 5
	  hurm1 += dex_app[GET_DEX (victim)].defensive;
/*	  if(IS_NPC(victim))
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
	  else
	    hurm1 += GET_SKILL (victim, SKILL_DODGE); */
d2587 2
a2588 1
	      hurm1 += dex_app[GET_DEX (victim)].defensive;
d2611 2
a2612 1
	      hurm1 += dex_app[GET_DEX (victim)].defensive;
d3824 3
@


1.102
log
@Fixing death triggers so that returning a value is still meaningful
(returning 0 suppresses the death cry).
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.101 2007/04/11 05:47:40 jps Exp myc $
d83 1
d990 1
a990 10
  /* this was placed above raw_kill because raw_kill frees the ch --gurlaek 9/7/1999 */
  if (PLR_FLAGGED (ch, PLR_CASTING))
    {
      if (IS_NPC (ch))
	REMOVE_BIT (MOB_FLAGS (ch), MOB_CASTING);
      REMOVE_BIT (PLR_FLAGS (ch), PLR_CASTING);
      act ("You stop chanting abruptly!", FALSE, ch, 0, 0, TO_CHAR);
      act ("$n stops chanting abruptly!", FALSE, ch, 0, 0, TO_ROOM);
    }

d3092 1
a3092 1
      if (PLR_FLAGGED (ch, PLR_CASTING))
a3093 5
      /* no more hitting while casting for mobs! --gurlaek 7/14/1999 */
      if(IS_NPC(ch)) 
	if(MOB_FLAGGED(ch, MOB_CASTING))
	  continue;

d3810 4
@


1.101
log
@Different message for unhiding, as opposed to losing invisibility.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.100 2007/03/27 04:27:05 myc Exp jps $
d758 1
a758 1
  int i;
d772 9
a780 1
  
d805 3
a807 2
  if (death_mtrigger (ch, killer));
  if (killer) {      
d810 7
d3823 3
@


1.100
log
@Improve skill function now increases skill more for certain harder-to-use
skills.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.99 2007/02/20 17:16:27 myc Exp myc $
d118 22
a139 16
  if (affected_by_spell (ch, SPELL_INVISIBLE))
    affect_from_char (ch, SPELL_INVISIBLE);
  if (affected_by_spell (ch, SPELL_CONCEALMENT))
    affect_from_char (ch, SPELL_CONCEALMENT);
  
  
  REMOVE_BIT (AFF_FLAGS (ch), AFF_INVISIBLE | AFF_HIDE);
  
  if (GET_LEVEL (ch) < LVL_IMMORT)
    {
      act ("$n snaps into visibility.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You fade back into view.", FALSE, ch, 0, 0, TO_CHAR);
    }
  else
    act ("You feel a strange presence as $n appears, seemingly from nowhere.",
	 FALSE, ch, 0, 0, TO_ROOM);
d3807 4
@


1.99
log
@When combat removes minor paralysis, it zaps entangle too.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.98 2007/02/14 03:54:53 myc Exp myc $
d3286 1
a3286 3
  int percent = GET_ISKILL (ch, skill);
  int newpercent;
  int maxpercent;
d3291 3
a3293 1
  if (number (1, 140) > GET_WIS (ch) + GET_INT (ch))
d3295 1
a3295 6
  if (skill == SKILL_DOUBLE_ATTACK ||
      SKILL_DUAL_WIELD || SKILL_PARRY ||
      SKILL_DODGE || SKILL_RIPOST)
    if (number (15, 45) > GET_WIS (ch) + GET_INT (ch))
      return;
  if (percent >= 999 || percent <= 0)
d3297 12
a3308 6
  if (skill == SKILL_DOUBLE_ATTACK ||
      SKILL_DUAL_WIELD || SKILL_PARRY ||
      SKILL_DODGE || SKILL_RIPOST || SKILL_VAMP_TOUCH)
    {
      newpercent = 1;
    }
d3310 10
a3319 13
    {
      newpercent = number (1, 5);
    }
  percent += newpercent;
  maxpercent = return_max_skill (ch, skill);
  if (percent > maxpercent)
    {
      SET_SKILL (ch, skill, maxpercent);
      return;
    }
  percent = MIN (percent, 1000);
  SET_SKILL (ch, skill, percent);
  sprintf (skillbuf, "&8You feel your skill in %s improving.\r\n&0", spells[skill]);
d3801 3
@


1.98
log
@Waterform reduces damage by 1/3, protection from evil and good reduce damage
by 10%.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.97 2007/02/08 01:30:00 myc Exp myc $
d1728 1
d3803 4
@


1.97
log
@If the victim and damager of a damage() call are the same person, no longer
shows the damager message, getting rid of some of those pesky (null)s.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.96 2006/11/20 06:50:59 jps Exp myc $
a518 1
  extern char *spell_wear_off_msg[];
a526 6
  if (IS_AFFECTED2 (ch, AFF2_HARNESS))
    {
      affect_from_char (ch, SPELL_HARNESS);
      send_to_char (spell_wear_off_msg[SPELL_HARNESS], ch);
      send_to_char ("\r\n", ch);
    }
d1707 11
a1717 1
  
d3802 4
@


1.96
log
@Call death trigger even when there isn't a killer.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.95 2006/11/20 06:44:26 jps Exp jps $
d1447 1
d1456 1
d1459 1
d1466 2
a1467 1
		  
d1474 2
a1475 1
		  
d1481 1
d1484 21
a1504 13
		  send_to_char (CCNRM (ch, C_CMP), ch);
		  if (attacktype == SKILL_2BACK) {
                    if (damage_amounts)
                      sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
                    else
                      sprintf(b2, "%s", msg->hit_msg.attacker_msg); 
		    act (b2, FALSE, ch, weap2, vict, TO_CHAR);
		  } else {
                    if (damage_amounts)
                      sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
                    else
                      sprintf(b2, "%s", msg->hit_msg.attacker_msg); 
		    act (b2, FALSE, ch, weap, vict, TO_CHAR);
d1506 2
a1507 2
		  send_to_char (CCNRM (ch, C_CMP), ch);
		  
d1523 2
a1524 1
		  
d1532 1
d1535 1
d1542 2
a1543 1
	      
d1550 2
a1551 1
	      
d3799 3
@


1.95
log
@Fix creatures dying of bloodloss as you're fighting them.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.94 2006/11/18 21:00:28 jps Exp jps $
d798 1
a799 1
    if (death_mtrigger (ch, killer))
d3780 3
@


1.94
log
@Reworked disarm skill and disarmed-weapon retrieval.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.93 2006/11/18 07:03:30 jps Exp jps $
d1837 6
a1842 2
      act ("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
      send_to_char ("You are dead!\r\n", victim);
d1954 4
a1957 1
      die (victim, ch);
d3780 3
@


1.93
log
@Minor typo fixes
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.92 2006/11/13 15:54:22 jps Exp jps $
d3444 1
a3444 1
	      act ("$n eagerly reaches for $o.", FALSE, ch, obj_i, 0, TO_ROOM);
d3448 1
a3448 1
	      act ("$n extends $s hands, finally getting a steady hold of $o.", FALSE, ch, obj_i, 0, TO_ROOM);
d3487 1
a3487 1
      if (IS_AFFECTED (ch, AFF_DROPPED_PRIM) || IS_AFFECTED (ch, AFF_DROPPED_SECOND))
d3541 2
a3542 2
      act ("$n finally regains full control of $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You finally regain full control of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
d3546 2
a3547 2
      act ("$n is fumbling for a steady hold of $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      act ("You can't seem to get a firm, steady hold of your weapon.", FALSE, ch, 0, 0, TO_CHAR);
d3604 1
a3604 1
	  if (af->type == SKILL_DISARM_DROPPED_WEAP && af->bitvector & affect_type)
d3773 3
@


1.92
log
@Fix widespread misuse of the hide_invisible parameter to act().
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.91 2006/11/08 09:16:04 jps Exp jps $
d1210 1
a1210 1
      "$N howls in pain as $n nearly rips $N's ear off!&0",		/* 3: 5..6  */
d1217 1
a1217 1
      "$N nearly doubles over choking as $n collapses $N's trachea!&0",	/* 4: 7..10  */
d1224 1
a1224 1
      "$n dances up to $N and throws $s elbow into $N's gut!&0",	/* 5: 11..14  */
d3773 3
@


1.91
log
@Fixed some loose-lose typos.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.90 2006/07/20 07:40:22 cjd Exp jps $
d2294 1
a2294 1
	  act (b2, TRUE, ch, 0, victim, TO_VICT);
d2299 1
a2299 1
          act (b2, TRUE, ch, 0, victim, TO_CHAR);
d2304 1
a2304 1
	  act (b2, TRUE, ch, 0, victim, TO_NOTVICT);
d2310 1
a2310 1
	  act (b2, TRUE, ch, 0, victim, TO_VICT);
d2315 1
a2315 1
	  act (b2, TRUE, ch, 0, victim, TO_CHAR);
d2320 1
a2320 1
	  act (b2, TRUE, ch, 0, victim, TO_NOTVICT);
d2330 3
a2332 3
	  act ("&7You smirk and slap $n's attack away with ease.&0", TRUE, ch, 0, victim, TO_VICT);
	  act ("&7$N smirks and slaps your attack away.&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N smirks as $E slaps $n's attack away.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2334 3
a2336 3
	  act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	  act ("&7$N parries your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N parries $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2345 4
a2348 1
	  act ("&7You twist in place and watch $n attack the air nearby.&0", TRUE, ch, 0, victim, TO_VICT);
d2352 3
a2354 3
	  act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	  act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2718 1
a2718 1
		  act (b2, TRUE, ch, 0, victim, TO_VICT);
d2723 1
a2723 1
		  act (b2, TRUE, ch, 0, victim, TO_CHAR);
d2728 1
a2728 1
		  act (b2, TRUE, ch, 0, victim, TO_NOTVICT);
d2734 1
a2734 1
		  act (b2, TRUE, ch, 0, victim, TO_VICT);
d2739 1
a2739 1
		  act (b2, TRUE, ch, 0, victim, TO_CHAR);
d2744 1
a2744 1
		  act (b2, TRUE, ch, 0, victim, TO_NOTVICT);
d2752 3
a2754 3
	         act ("&7You smirk and slap $n's attack away with ease.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N smirks and slaps your attack away.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N smirks as $E slaps $n's attack away.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2756 3
a2758 3
	         act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N parries your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N parries $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2765 4
a2768 1
		act ("&7You twist in place and watch $n attack the air nearby.&0", TRUE, ch, 0, victim, TO_VICT);
d2772 3
a2774 3
		act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
		act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
		act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d3773 3
@


1.90
log
@Typo fixes.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.89 2003/08/04 02:41:19 jjl Exp $
d443 1
a443 1
		 send_to_char ("Huh?!? You find yourself laying on the ground!\r\n", victim);
d3767 3
@


1.89
log
@Removed the killer level restriction
for zzur's gem drop quest thing.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.88 2003/08/02 17:42:50 jjl Exp jjl $
d1189 1
a1189 1
      "$n threw his punch just a little wide, missing $N completely.&0",	/* 0: 0     */
d1197 2
a1198 2
      "You slap $N, and while he is distracted, make a grab for $S nose.&0",
      "$n slap's your cheek, then tries to twist your nose off!&0"
d1246 1
a1246 1
      "You punch $N in the throat causing him to nearly choke to death!&0",
d2317 1
a2317 1
	    sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&1&b%d&0&7", vdam);
d3767 4
@


1.88
log
@Added a random gem drop for mobs under level 60, for Zzur's insano-quest.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.87 2003/07/19 05:07:16 jjl Exp $
d984 1
a984 1
  if (GET_LEVEL(ch) < 60 && GET_LEVEL(killer) < 66) {
d3767 3
@


1.87
log
@Fixed entangle.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.86 2003/06/25 05:06:59 jjl Exp $
d983 4
d3767 3
@


1.86
log
@More updates.  I seem to be off of my game.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.85 2003/06/20 15:06:03 rls Exp $
d1702 1
a1702 1
      REMOVE_BIT (AFF2_FLAGS (ch), AFF2_MINOR_PARALYSIS);
d3763 3
@


1.85
log
@Added back in sanct functionality... PLEASE see me before undoing this! RLS
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.84 2003/06/20 12:57:37 rls Exp $
d1422 1
a1422 1
  
d1439 1
d1763 1
a1763 1
  else if (!IS_WEAPON (attacktype))
d1765 1
d3763 3
@


1.84
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.83 2003/02/01 19:59:36 mud Exp $
d1686 1
a1686 1
    dam /= dam;		/* 1/2 damage when sanctuary */
d3761 3
@


1.83
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.81 2002/09/30 01:10:52 jjl Exp $
d1686 1
a1686 1
    dam >>= 1;		/* 1/2 damage when sanctuary */
d3761 3
@


1.82
log
@*** empty log message ***
@
text
@d3123 1
a3123 1
      if ((GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch)))
d3128 1
a3128 1
	  if (wielded2 || GET_SKILL(ch, SKILL_BAREHAND))
@


1.81
log
@Put in checks so guard actually does something.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.80 2002/09/15 04:53:08 jjl Exp $
d3123 1
a3123 1
      if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
d3128 1
a3128 1
	  if (wielded2)
d3761 3
@


1.80
log
@No more throwing your primary weapon and winding up with only a secondary.  This ought to make me friends
with the monk population.
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.79 2002/09/13 02:32:10 jjl Exp $
d1649 1
a1649 1
	      sprintf (buf, "&6&bn observes $N commanding %s and attacks $M instead!&0", 
d3761 4
@


1.79
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: fight.c,v 1.78 2002/07/24 04:11:23 rls Exp $
d1187 1
a1187 1
      "$n takes aim at you, but looses communication with $s fists!&0"
d1194 1
a1194 1
      "$n slap's your cheak, then tries to twist your nose off!&0"
d2853 17
a2869 1
    unequip_char(ch, position);
d3761 3
@


1.78
log
@Added message to charmies aggressor switch.. and made it check
to see if charmie's master IS invis or not!!!
@
text
@d1 3
a3 1
// $Id: fight.c,v 1.77 2002/06/09 13:52:41 dce Exp $
d824 1
a824 1
  //   int groupees;
d830 2
a831 2
  //   float tot_percent;
  //   float leader_percent;
d1709 1
a1709 1
      //  check_justice (ch, victim);
d1711 2
a1712 2
     // if (PLR_FLAGGED (ch, PLR_KILLER) && (ch != victim))
	// dam = 0;
d1774 1
a1774 1
  // stops these shileds from hurting casters from spells casted -Banyal
d1813 1
a1813 1
  } // end attacktype check
d1940 1
a1940 1
	    //   forget(ch, victim); 
d3743 333
a4075 327
// $Log: fight.c,v $
// Revision 1.77  2002/06/09 13:52:41  dce
// Now, only if you have a critical miss (diceroll == 1) you
// have a chance to sling your weapon.
//
// Revision 1.76  2002/06/07 01:03:58  rls
// Adjusted die roll for thac0, some stuff with dam messages as well.
//
// Revision 1.75  2002/06/06 01:02:13  dce
// Opps that should have been divided by 10 not 100.
//
// Revision 1.74  2002/06/06 00:34:33  rls
// THAC0 same for PC clases and Mob Classes, same div by for hr bonus
//
// Revision 1.73  2002/06/05 01:16:05  dce
// Adjusted Dodge, Parry, and Ripost. Basically I divided the
// skill checks by 100. It apears they were still based on the
// 100 max skill system.
//
// Revision 1.72  2002/05/24 03:16:48  rls
// Slight mod to thac0 stuff (PC hitroll /5 due to eq bonuses)
//
// Revision 1.71  2002/05/23 00:21:17  rls
// Improved thac0 to use linear calc_thac0 function instead of tables.
// Lessened the gain from int and wis on thac0 as well as toned down
// NPC hitroll due to overmaxing the thac0 scores.
//
// Revision 1.70  2002/03/30 19:20:14  dce
// Added damage amounts as a toggable item.
//
// Revision 1.69  2002/03/30 13:33:32  dce
// Reduced the damage of ripost.
//
// Revision 1.68  2002/03/27 02:25:04  dce
// Added damage to messages, per Zzur's request.
//
// Revision 1.67  2002/03/15 02:45:14  dce
// Fixed set_fighting so that a resting player's pos1 is also
// set to standing.
//
// Revision 1.66  2002/02/18 02:26:19  dce
// After battle, added a check to see if player/mob was in position
// fighting. If so set them to standing other wise leave them.
//
// Revision 1.65  2002/02/14 02:07:33  dce
// Adjusted the way you wake up from sleeping when you get
// attacked. Was POS1_PRONE, put it POS1_STANDING/SITTING.
//
// Revision 1.64  2002/02/13 23:27:11  dce
// Modified set_fighting. The GET_POS = POS_FIGHTING was commented
// out casuing problems in the fighting routine, so I uncommented
// it. I also made it you that you can not hit while your position
// is < POS_STANDING.
//
// Revision 1.63  2002/02/11 23:49:39  dce
// Removed the only NOGEAR functionality because it was
// crashing the mud when a corpse was removed.
//
// Revision 1.62  2002/02/11 02:28:31  dce
// The wimpy check always made a mob or player stop fighting
// even if the do_flee failed. The do_flee routine should
// do the stop fighting call so I removed those two lines.
// /s
//
// Revision 1.61  2001/12/14 03:33:48  dce
// Ok, it should be illegal to code when you are tired and it
// is late. Removed the last thing mentioned.
//
// Revision 1.60  2001/12/14 03:27:46  dce
// Forgot to add the reverse check for the blob bug.
// Added right under the other check.
//
// Revision 1.59  2001/12/14 03:20:45  dce
// Fixed the 'blob bug', in the perform violence. The
// mob was dying from a ripost in a hit function call.
// Then when it reached the MOB_FLAGGED line the mud crashed
// beacuse the pointer had been freed. Added a check to see
// if the mob is dead before that call.
//
// Revision 1.58  2001/12/13 02:06:32  dce
// Another attempt to fix the blob crash bug.
// Here I added a check in void hit that checks if
// the player and mob are fighting after a ripost...
// both parry and dodge already had this check.
//
// Revision 1.57  2001/12/12 02:45:03  dce
// Fixed it so gods switched in a creature that dies should
// now produce a corpse.
//
// Revision 1.56  2001/12/05 18:03:40  rjd
// Parry typo corrected. It now outputs the correct verbage when appropriate (i.e. "parries"
// instead of "parry" for lines such as "Demolitum parries your attack." and "Demolitum
// parries Kharnez's attack."
//
// Revision 1.55  2001/04/06 03:25:25  dce
// Corpses will now have a level.
//
// Revision 1.54  2001/03/25 12:44:50  dce
// Mobs should now become visible when fighting.
//
// Revision 1.53  2001/03/10 18:45:33  dce
// Changed do_return function to pass a subcommand of 1.
// This way I can make it so players can't use the return command.
//
// Revision 1.52  2001/03/09 03:05:21  dce
// Shapechanged players can no longer kill shapechanged players.
//
// Revision 1.51  2001/03/07 01:45:18  dce
// Added checks so that players can not kill shapechanged players and
// vise versa. Hopefully I didn't miss any...
//
// Revision 1.50  2001/02/24 04:04:33  dce
// Shapechanged players die, lose their hp, and corpse
// shows up in the right room
//
// Revision 1.49  2000/11/28 01:22:42  mtp
// removed mprog code
//
// Revision 1.48  2000/11/27 08:12:52  mtp
// oops = mistake at end of change_align in the bounding
//
// Revision 1.47  2000/11/21 18:33:41  rsd
// Added back rlog messages from prior to the addition
// of the $log$ string.
//
// Revision 1.46  2000/11/17 01:47:42  mtp
// new align change code, based on a series of curves (well, lines)
// that are determined by the killers align
//
// Revision 1.45  2000/11/13 03:23:23  rsd
// Oooook, someone put in a one line if before the log
// message I deleted earlier so since I didn't see braces
// I didn't see to delete the if.  The if was if (whatver)
// log debug
// So, deleting the debug made the if apply to the next line.
// Man was the code pissed off.
//
// Revision 1.44  2000/11/13 03:08:30  rsd
// Removed an unnecessary log message.
//
// Revision 1.43  2000/11/10 00:28:04  mtp
// oops..would have sent message to start room rather than finish room!
//
// Revision 1.42  2000/11/10 00:22:30  mtp
// moved the obj_to_room() to AFTER the attempt to ref it in the sling out of room..
// just in case the next room is a water room and the obj gets extracted...
//
// Revision 1.41  2000/06/01 19:52:46  rsd
// added more detail to a mysterious log message in sling_weapon
//
// Revision 1.40  2000/04/17 00:54:12  rsd
// weapon slinging is now in very loud yellow and reversed
// BLUE wooo!
//
// Revision 1.39  2000/04/14 00:53:27  rsd
// Someone had me check to see if coldshield/fireshield actually caused
// damage so while in the file, I fixed the comment header and stylized
// do_hit, tabs and }'s ...
//
// Revision 1.38  2000/03/05 01:24:43  rsd
// added dispel_good_weapon type to the proper function.
//
// Revision 1.37  2000/02/25 03:14:19  cso
// fixed a typo in peaceful rooms -- disrurb to disturb. yay!
//
// Revision 1.36  1999/12/10 22:13:45  jimmy
// Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
// level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
// exp code.
//
// Revision 1.35  1999/12/06 10:46:06  jimmy
// Fixed crash that happened when a weapon was slung into a room with noone there.
//
// Revision 1.34  1999/11/28 23:21:22  cso
// make_corpse: modified values for corpses
// damage: animated mobs no longer flee
//
// Revision 1.33  1999/11/28 19:36:58  jimmy
// Added stun time associated with slinging a weapon.  Also, a one in five chance
// will sling the weapon into another room.
//
// Revision 1.32  1999/11/23 15:48:23  jimmy
// Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
// Reinstated dual wield.
// Allowed mobs/players to pick up items while fighting.
// Fixed a bug in the damage message that wrongfully indicated a miss
// due to a rounding error in the math.
// This was all done in order to facilitate the chance to sling your
// weapon in combat.  Dex and proficiency checks are now made on any missed
// attact and a failure of both causes the weapon to be slung.
//
// Revision 1.31  1999/10/30 15:35:19  rsd
// Jimmy coded alignment restrictions on Paladins for exp.
// Altered gain_exp() to add a victim check for alignment.
// l
//
// Revision 1.30  1999/09/16 01:15:11  dce
// Weight restrictions for monks...-hitroll, -damroll + ac
//
// Revision 1.29  1999/09/08 07:06:03  jimmy
// More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
// with blood and killing
// --gurlaek
//
// Revision 1.28  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.27  1999/08/29 17:48:53  mud
// corrected the spelling of dirstacted in the monk combat semantics.
//
// Revision 1.26  1999/08/14 22:55:36  mud
// removed a double space from nearly rips you in two with $s deadly #w!!&0"
//
// Revision 1.25  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.24  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.23  1999/07/25 05:40:18  jimmy
// Fixed the skill advancement in peace rooms bug.
// --gurlaek
//
// Revision 1.22  1999/07/24 02:55:05  dce
// Tweaked alignment code
//
// Revision 1.21  1999/07/23 15:01:50  dce
// Alignment completely redone.
//
// Revision 1.20  1999/07/15 03:27:34  jimmy
// Mob casters can not hit while casting.
// Updated spell cast times to be more realistic
// changed combat to 4 seconds per round.
// Removed do_order semantics that told the order to onlookers.
//
// Revision 1.19  1999/07/14 19:24:03  jimmy
// The combat system was enhanced/improved in the following ways:  Mobs
// can no longer flee while bashed or sitting.  Fleeing causes casters to
// stop casting.  You can now flee while flying.  pk checks were added to
// bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
// fixes. spellcasting for mobs is now very similar to PC spellcasting.
// MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
// Mobs no longer improve skills.  Bash now requires mobs to have a shield
// just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
// --gurlaek
//
// Revision 1.18  1999/07/07 15:46:44  jimmy
// Fixed the group NPC issue.  Players can no longer group NPC's and
// crash the mud at will
// --gurlaek 7/7/1999
//
// Revision 1.17  1999/07/02 19:23:18  jimmy
// Fixed ANSI compile warnings in fight.c by removing the void *
// function pointer and adding a type field
// --gurlaek
//
// Revision 1.16  1999/06/11 16:56:55  jimmy
// Ok, fixed do_quit to check for fighting and also not crash when mortally
// wounded.  This was done in die() by checking for killer=NULL.
// since no one killed you if you quit while morted the die code
// didn't know how to deal with a NULL killer.
// --Gurlaek 6/11/1999
//
// Revision 1.15  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
//
// Revision 1.14  1999/05/02 16:20:32  dce
// Clean up
//
// Revision 1.13  1999/04/08 04:26:36  dce
// Fixed the mounting problem.
//
// Revision 1.12  1999/03/23 16:07:04  dce
// No pkilling with mobs
//
// Revision 1.11  1999/03/21 21:49:37  dce
// Disallows pkilling.
//
// Revision 1.10  1999/03/10 19:12:17  dce
// Fixes death blow for monks.
//
// Revision 1.9  1999/03/10 00:03:37  dce
// Monk semantics for dodge/parry/ripost/attack
//
// Revision 1.8  1999/02/09 12:40:17  mud
//  "$n nearly rips $N in two with $s deadly #w!!&0",      /* 8: > 23   */
//  Added the RIPS as opposed to RIP
//
// Revision 1.7  1999/02/08 23:01:47  jimmy
// Fixed mortally wounded bug.  Mortally wounded
// victims now die when they read -11.  Also,
// no more "attempt to damage corpse"
// fingon
//
// Revision 1.6  1999/02/07 20:00:55  jimmy
// fixed debug messages
//
// Revision 1.5  1999/02/07 19:14:40  jimmy
// added debug statement
//
// Revision 1.4  1999/02/04 00:02:59  jimmy
// max/min exp loss/gain set to 2 notches.
//
// Revision 1.3  1999/02/02 07:51:02  jimmy
// fixed spell mem at death bug
//
// Revision 1.2  1999/01/31 02:40:03  mud
// Altered comment header
// indented file
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.77
log
@Now, only if you have a critical miss (diceroll == 1) you
have a chance to sling your weapon.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.76 2002/06/07 01:03:58 rls Exp $
d1544 1
d1638 1
a1638 1
	      (victim->master->in_room == ch->in_room))
d1642 12
d3742 4
@


1.76
log
@Adjusted die roll for thac0, some stuff with dam messages as well.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.75 2002/06/06 01:02:13 dce Exp $
d2189 7
a2195 4
      if(wielded)
	sling_weapon(ch, wielded, WEAR_WIELD);
      else if(hwielded)
	sling_weapon(ch, hwielded, WEAR_2HWIELD);
d2207 2
a2208 1
         sling_weapon(ch, wielded, WEAR_WIELD); 
d2213 2
a2214 1
	sling_weapon(ch, hwielded, WEAR_2HWIELD); 
d2334 2
a2335 1
	  sling_weapon(ch, wielded, WEAR_WIELD);
d2337 2
a2338 1
	  sling_weapon(ch, hwielded, WEAR_2HWIELD);
d2620 2
a2621 1
	  sling_weapon(ch, wielded, WEAR_WIELD2);
d2632 2
a2633 1
          sling_weapon(ch, wielded, WEAR_WIELD2);
d2751 2
a2752 1
		sling_weapon(ch, wielded, WEAR_WIELD2);
d3729 3
@


1.75
log
@Opps that should have been divided by 10 not 100.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.74 2002/06/06 00:34:33 rls Exp $
d1337 3
d2172 2
a2173 2
  diceroll = number (1, 25);
  
d2180 1
a2180 1
  
d2182 1
a2182 1
  if (((diceroll < 20) && AWAKE (victim)) 
d2220 3
d2593 1
a2593 1
  diceroll = number (1, 25);
d2601 1
a2601 1
  
d2605 1
a2605 1
  if (((diceroll < 20) && AWAKE (victim)) 
d2632 3
d3719 3
@


1.74
log
@THAC0 same for PC clases and Mob Classes, same div by for hr bonus
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.73 2002/06/05 01:16:05 dce Exp $
d2047 1
a2047 1
	  hurm = number (35, 131);
d2056 1
a2056 1
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) / 100; 
d2071 1
a2071 1
	      hurm = number (45, 141);
d2077 1
a2077 1
	      hurm1 += GET_SKILL (victim, SKILL_PARRY) / 100;
d2099 1
a2099 1
	      hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/100) * .85;
d2463 1
a2463 1
	  hurm = number (55, 141);
d2473 1
a2473 1
	    hurm1 += GET_SKILL (victim, SKILL_DODGE) / 100; 
d2489 1
a2489 1
	      hurm = number (65, 141);
d2495 1
a2495 1
	      hurm1 += GET_SKILL (victim, SKILL_PARRY)/100;
d2518 1
a2518 1
	      hurm1 += (GET_SKILL (victim, SKILL_RIPOST)/100) * .8;
d3710 3
@


1.73
log
@Adjusted Dodge, Parry, and Ripost. Basically I divided the
skill checks by 100. It apears they were still based on the
100 max skill system.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.72 2002/05/24 03:16:48 rls Exp $
a2158 2
  
  
a2159 5
  
  if (!IS_NPC (ch))
    calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00);
  else				/* THAC0 for NPCs set here (standard) */
    calc_thaco = calc_thac0(GET_LEVEL(ch), 25, -4); /* as good as a thief */
d2161 1
d2164 1
a2164 4
  if (!IS_NPC(ch))
     calc_thaco -= GET_HITROLL (ch)/ 5;
  else
    calc_thaco -= GET_HITROLL (ch) /10 ;
d2168 2
a2169 1
  diceroll = number (1, 29);
d2181 3
a2183 2
{
    if (type == SKILL_BACKSTAB) {
d2190 3
a2192 1
    } else if (type == SKILL_BAREHAND) {
d2194 3
a2196 1
    } else {
d2198 9
a2206 8
      if(wielded) {
	if(!(sling_weapon(ch, wielded, WEAR_WIELD))) {
	  damage (ch, victim, 0, w_type);
	}
      } else if(hwielded) {
	if(!(sling_weapon(ch, hwielded, WEAR_2HWIELD))) {
	  damage (ch, victim, 0, w_type);
	}
d2208 2
d2211 3
a2213 1
  } else {
d2580 1
a2580 5
  if (!IS_NPC (ch))
    calc_thaco = calc_thac0(GET_LEVEL(ch), thac0_01, thac0_00);
  else				/* THAC0 for NPCs set here (standard) */
    calc_thaco = calc_thac0(GET_LEVEL(ch), 25, -4); /* as good as a thief */

d2583 1
a2583 4
  if (!IS_NPC(ch))
     calc_thaco -= GET_HITROLL (ch) / 5;
  else
    calc_thaco -= GET_HITROLL (ch) /10 ;
d2587 1
a2587 1
  diceroll = number (1, 29);
d2597 2
d2602 2
a2603 1
      if (type == SKILL_2BACK) {
d2608 3
a2610 1
      } else if (type == SKILL_BAREHAND) {
d2612 3
a2614 1
      } else {
d2616 3
a2618 2
	if(wielded && !sling_weapon(ch, wielded, WEAR_WIELD2))
	  damage (ch, victim, 0, w_type);
d3710 5
@


1.72
log
@Slight mod to thac0 stuff (PC hitroll /5 due to eq bonuses)
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.71 2002/05/23 00:21:17 rls Exp rls $
d2053 1
a2053 1
	  if(IS_NPC(victim))
d2055 2
a2056 2
	  else
	    hurm1 += GET_SKILL (victim, SKILL_DODGE);
d2077 1
a2077 1
	      hurm1 += GET_SKILL (victim, SKILL_PARRY);
d2099 1
a2099 1
	      hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .85;
d2467 1
a2467 1
	  if(IS_NPC(victim))
d2470 2
a2471 1
	    hurm1 += GET_SKILL (victim, SKILL_DODGE);
d2493 1
a2493 1
	      hurm1 += GET_SKILL (victim, SKILL_PARRY);
d2516 1
a2516 1
	      hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .8;
d2793 1
a2793 1
    skill = GET_SKILL(ch, skill_number);
d2795 2
a2796 2
  dpercent = number(1, 101);
  spercent = number(1, 101);
d3707 3
@


1.71
log
@Improved thac0 to use linear calc_thac0 function instead of tables.
Lessened the gain from int and wis on thac0 as well as toned down
NPC hitroll due to overmaxing the thac0 scores.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.70 2002/03/30 19:20:14 dce Exp $
d2171 1
a2171 1
     calc_thaco -= GET_HITROLL (ch);
d2585 1
a2585 1
     calc_thaco -= GET_HITROLL (ch);
d3706 5
@


1.70
log
@Added damage amounts as a toggable item.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.69 2002/03/30 13:33:32 dce Exp $
d82 3
a1939 1
  extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
d1942 4
d2164 4
a2167 4
    calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)] + (monk_weight_pen(ch)*5);
  else				/* THAC0 for monsters is set in the HitRoll */
    calc_thaco = 20;
  
d2169 8
a2176 3
  calc_thaco -= GET_HITROLL (ch);
  calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
  calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
d2179 1
a2179 1
  victim_ac = GET_AC (victim) / 15;
d2186 4
a2189 3
  /* decide whether this is a hit or a miss */
  if ((((diceroll < 20) && AWAKE (victim)) &&
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac)))) {
d2265 1
a2265 1
	  act (b2, TRUE, ch, 0, victim, TO_CHAR);
d2380 4
a2388 1
  extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
a2576 1
  
d2578 4
a2581 4
    calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)] + (monk_weight_pen(ch)*5);
  else				/* THAC0 for monsters is set in the HitRoll */
    calc_thaco = 20;
  
d2583 9
a2591 4
  calc_thaco -= GET_HITROLL (ch);
  calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
  calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
  diceroll = number (1, 25);
d2593 1
a2593 1
  victim_ac = GET_AC (victim) / 15;
d2601 2
a2602 2
  if ((((diceroll < 20) && AWAKE (victim)) &&
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
d2674 1
a2674 1
		    sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", vdam);
d3698 7
d3706 3
@


1.69
log
@Reduced the damage of ripost.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.68 2002/03/27 02:25:04 dce Exp $
d46 1
d1362 4
a1365 1
  sprintf(b2, "%s (&4%d&0)", buf, dam);
d1375 4
a1378 1
  sprintf(b2, "%s (&3%d&0)", buf, dam);
d1389 4
a1392 1
  sprintf(b2, "%s (&1&b%d&0)", buf, dam);
d1467 4
a1470 1
                    sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
d1473 4
a1476 1
                    sprintf(b2, "%s (&3%d&0)", msg->hit_msg.attacker_msg, dam); 
d1483 4
a1486 1
                    sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
d1489 4
a1492 1
                    sprintf(b2, "%s (&1&b%d&0)", msg->hit_msg.victim_msg, dam); 
d1497 4
a1500 1
                  sprintf(b2, "%s (&4%d&0)", msg->hit_msg.room_msg, dam); 
d2244 4
a2247 1
          sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", vdam);
d2249 4
a2252 1
	  sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", vdam);
d2254 4
a2257 1
	  sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", vdam);
d2260 4
a2263 1
	  sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", vdam);
d2265 4
a2268 1
	  sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", vdam);
d2270 4
a2273 1
	  sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", vdam);
d2649 4
a2652 1
        	  sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", vdam);
d2654 4
a2657 1
		  sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", vdam);
d2659 4
a2662 1
		  sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", vdam);
d2665 4
a2668 1
		  sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", vdam);
d2670 4
a2673 1
		  sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", vdam);
d2675 4
a2678 1
		  sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", vdam);
d3680 3
@


1.68
log
@Added damage to messages, per Zzur's request.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.67 2002/03/15 02:45:14 dce Exp $
d2217 1
d2219 1
a2219 1
          sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", dam);
d2221 1
a2221 1
	  sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", dam);
d2223 1
a2223 1
	  sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", dam);
d2226 1
a2226 1
	  sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", dam);
d2228 1
a2228 1
	  sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", dam);
d2230 1
a2230 1
	  sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", dam);
d2604 1
d2606 1
a2606 1
        	  sprintf(b2, "&8You grab $n's arm and twist it, causing $m to strike $mself! (&3%d&0&8)&0", dam);
d2608 1
a2608 1
		  sprintf(b2, "&8$N grabs your arm and twists it, causing you to damage to yourself! (&1&b%d&0&8)&0", dam);
d2610 1
a2610 1
		  sprintf(b2, "&7$N grabs and twists $n's arm, causing $n to hurt $mself! (&4%d&0&7)&0", dam);
d2613 1
a2613 1
		  sprintf(b2, "&8You block $n's attack, and strike back! (&3%d&0&8)&0", dam);
d2615 1
a2615 1
		  sprintf(b2, "&8$N blocks your attack, and strikes back! (&1&b%d&0&8)&0", dam);
d2617 1
a2617 1
		  sprintf(b2, "&7$N blocks $n's attack, and strikes back at $m! (&4%d&0&7)&0", dam);
a2619 1

d3619 3
@


1.67
log
@Fixed set_fighting so that a resting player's pos1 is also
set to standing.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.66 2002/02/18 02:26:19 dce Exp $
d1166 1
d1169 1
a1169 1
  
d1315 2
d1361 2
a1362 1
  act (buf, FALSE, ch, NULL, victim, TO_NOTVICT);
d1371 2
a1372 1
  act (buf, FALSE, ch, NULL, victim, TO_CHAR);
d1382 2
a1383 1
  act (buf, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
d1397 1
d1402 2
d1456 7
a1462 4
		  if (attacktype == SKILL_2BACK)
		    act (msg->hit_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
		  else
		    act (msg->hit_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
d1466 7
a1472 4
		  if (attacktype == SKILL_2BACK)
		    act (msg->hit_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
		  else
		    act (msg->hit_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
d1475 2
a1476 1
		  act (msg->hit_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
d1918 1
d1922 2
d2218 6
a2223 3
	  act ("&8You grab $n's arm and twist it, causing $m to strike $mself!&0", TRUE, ch, 0, victim, TO_VICT);
	  act ("&8$N grabs your arm and twists it, causing you to damage to yourself!&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2225 6
a2230 3
	  act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	  act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2327 2
a2328 1
  
d2336 2
d2603 16
a2618 9
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
	         act ("&8You grab $n's arm and twist it, causing $m to strike $mself!&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&8$N grabs your arm and twists it, causing you to damage to yourself!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0", TRUE, ch, 0, victim, TO_NOTVICT);
              } else {
	         act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
              }
d3618 4
@


1.66
log
@After battle, added a check to see if player/mob was in position
fighting. If so set them to standing other wise leave them.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.65 2002/02/14 02:07:33 dce Exp $
d497 1
d3583 4
@


1.65
log
@Adjusted the way you wake up from sleeping when you get
attacked. Was POS1_PRONE, put it POS1_STANDING/SITTING.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.64 2002/02/13 23:27:11 dce Exp $
d527 4
a530 1
  GET_POS (ch) = POS_STANDING;
d3582 4
@


1.64
log
@Modified set_fighting. The GET_POS = POS_FIGHTING was commented
out casuing problems in the fighting routine, so I uncommented
it. I also made it you that you can not hit while your position
is < POS_STANDING.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.63 2002/02/11 23:49:39 dce Exp $
d243 1
a243 1
      GET_POS1 (victim) = POS1_PRONE;
d405 1
a405 1
	     GET_POS1 (victim) = POS1_PRONE;
d3579 6
@


1.63
log
@Removed the only NOGEAR functionality because it was
crashing the mud when a corpse was removed.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.62 2002/02/11 02:28:31 dce Exp $
d496 1
a496 1
  /*GET_POS(ch) = POS_FIGHTING; */
d1581 1
a1581 1
	    if (!(FIGHTING (ch)))
d1594 1
a1594 1
      if (GET_POS (victim) > POS_STUNNED && !FIGHTING (victim))
d2868 6
d3579 4
@


1.62
log
@The wimpy check always made a mob or player stop fighting
even if the do_flee failed. The do_flee routine should
do the stop fighting call so I removed those two lines.
/s
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.61 2001/12/14 03:33:48 dce Exp $
d590 6
a595 1
  if (!(MOB_FLAGGED (ch, MOB_NOGEAR)))
d3573 6
@


1.61
log
@Ok, it should be illegal to code when you are tired and it
is late. Removed the last thing mentioned.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.60 2001/12/14 03:27:46 dce Exp $
d1777 6
d1784 1
a1784 1
		stop_fighting (ch);
d1794 10
a1803 5
	  send_to_char ("You attempt to flee!\r\n", victim);
	 do_flee (victim, "", 0, 0);
	 if (FIGHTING (ch))
	   stop_fighting (ch);
	 
d3568 4
@


1.60
log
@Forgot to add the reverse check for the blob bug.
Added right under the other check.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.59 2001/12/14 03:20:45 dce Exp $
a2893 4
      if (GET_POS(FIGHTING(ch)) == POS_DEAD) {
        stop_fighting(FIGHTING(ch));
        continue;
      }
d3557 4
@


1.59
log
@Fixed the 'blob bug', in the perform violence. The
mob was dying from a ripost in a hit function call.
Then when it reached the MOB_FLAGGED line the mud crashed
beacuse the pointer had been freed. Added a check to see
if the mob is dead before that call.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.58 2001/12/13 02:06:32 dce Exp $
d2891 5
a2895 1
        stop_fighting (ch);
d3561 7
@


1.58
log
@Another attempt to fix the blob crash bug.
Here I added a check in void hit that checks if
the player and mob are fighting after a ripost...
both parry and dodge already had this check.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.57 2001/12/12 02:45:03 dce Exp $
d2803 1
a2803 2
void 
perform_violence (void)
d2884 10
d3557 6
@


1.57
log
@Fixed it so gods switched in a creature that dies should
now produce a corpse.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.56 2001/12/05 18:03:40 rjd Exp $
d2189 4
d3548 4
@


1.56
log
@Parry typo corrected. It now outputs the correct verbage when appropriate (i.e. "parries"
instead of "parry" for lines such as "Demolitum parries your attack." and "Demolitum
parries Kharnez's attack."
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.55 2001/04/06 03:25:25 dce Exp $
d800 1
d3544 5
@


1.55
log
@Corpses will now have a level.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.54 2001/03/25 12:44:50 dce Exp $
d2195 2
a2196 2
	  act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	  act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2570 2
a2571 2
	         act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d3543 3
@


1.54
log
@Mobs should now become visible when fighting.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.53 2001/03/10 18:45:33 dce Exp $
d585 3
d3543 3
@


1.53
log
@Changed do_return function to pass a subcommand of 1.
This way I can make it so players can't use the return command.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.52 2001/03/09 03:05:21 dce Exp $
d1966 2
d2339 2
d3540 4
@


1.52
log
@Shapechanged players can no longer kill shapechanged players.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.51 2001/03/07 01:45:18 dce Exp $
d255 1
a255 1
	  do_return (victim, "", 0, 0);
d263 1
a263 1
	  do_return (victim, "", 0, 0);
d415 1
a415 1
		 do_return (victim, "", 0, 0);
d423 1
a423 1
		 do_return (victim, "", 0, 0);
d796 1
a796 1
    do_return (real_char, "", 0, 0);
d3536 3
@


1.51
log
@Added checks so that players can not kill shapechanged players and
vise versa. Hopefully I didn't miss any...
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.50 2001/02/24 04:04:33 dce Exp $
d1529 7
d1942 9
d2326 9
d3536 4
@


1.50
log
@Shapechanged players die, lose their hp, and corpse
shows up in the right room
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.49 2000/11/28 01:22:42 mtp Exp $
d1518 11
d1920 15
d2295 16
a2310 1
  }
d3511 4
@


1.49
log
@removed mprog code
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.48 2000/11/27 08:12:52 mtp Exp mtp $
d900 14
d965 8
a972 2
  raw_kill (ch, killer);
  
d3470 3
@


1.48
log
@oops = mistake at end of change_align in the bounding
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.47 2000/11/21 18:33:41 rsd Exp mtp $
a68 3
void mprog_hitprcnt_trigger (struct char_data *mob, struct char_data *ch);
void mprog_death_trigger (struct char_data *mob, struct char_data *killer);
void mprog_fight_trigger (struct char_data *mob, struct char_data *ch);
a782 2
  } else if (killer) { /* how the Fuck does this get executed? --gurlaek */
    mprog_death_trigger (ch, killer);
a2006 3
  mprog_hitprcnt_trigger (ch, FIGHTING (ch));
  mprog_fight_trigger (ch, FIGHTING (ch));
  
a2356 3
  mprog_hitprcnt_trigger (ch, FIGHTING (ch));
  mprog_fight_trigger (ch, FIGHTING (ch));
  
d3450 3
@


1.47
log
@Added back rlog messages from prior to the addition
of the $log$ string.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.46 2000/11/17 01:47:42 mtp Exp $
d666 1
a666 1
	BOUNDED(-1000,GET_ALIGNMENT(ch),1000);
d3461 4
@


1.46
log
@new align change code, based on a series of curves (well, lines)
that are determined by the killers align
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.45 2000/11/13 03:23:23 rsd Exp mtp $
d3461 4
d3542 120
@


1.45
log
@Oooook, someone put in a one line if before the log
message I deleted earlier so since I didn't see braces
I didn't see to delete the if.  The if was if (whatver)
log debug
So, deleting the debug made the if apply to the next line.
Man was the code pissed off.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.44 2000/11/13 03:08:30 rsd Exp $
d624 44
d670 1
a670 1
change_alignment (struct char_data *ch, struct char_data *victim)
d3461 8
@


1.44
log
@Removed an unnecessary log message.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.43 2000/11/10 00:28:04 mtp Exp $
a2555 1
	    if(!IS_NPC(ch))
d3417 3
@


1.43
log
@oops..would have sent message to start room rather than finish room!
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.42 2000/11/10 00:22:30 mtp Exp mtp $
a2556 1
	      log("FIGHT.C:sling_weapon() - found a dir: Why does this log message exist?");
d3418 3
@


1.42
log
@moved the obj_to_room() to AFTER the attempt to ref it in the sling out of room..
just in case the next room is a water room and the obj gets extracted...
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.41 2000/06/01 19:52:46 rsd Exp mtp $
d2565 1
d2572 2
a2573 1
	for (tch = world[weapon->in_room].people; tch; tch = tch->next_in_room) {
d2578 1
a2578 1
	obj_to_room(weapon, world[ch->in_room].dir_option[direction]->to_room);
d3419 4
@


1.41
log
@added more detail to a mysterious log message in sling_weapon
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.40 2000/04/17 00:54:12 rsd Exp $
a2569 2
	/* place the weapon in the room */
	obj_to_room(weapon, world[ch->in_room].dir_option[direction]->to_room);
d2575 2
d3417 3
@


1.40
log
@weapon slinging is now in very loud yellow and reversed
BLUE wooo!
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.39 2000/04/14 00:53:27 rsd Exp $
d2557 1
a2557 1
	      log("found a dir");
d3417 4
@


1.39
log
@Someone had me check to see if coldshield/fireshield actually caused
damage so while in the file, I fixed the comment header and stylized
do_hit, tabs and }'s ...
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.38 2000/03/05 01:24:43 rsd Exp $
d2566 1
a2566 1
	sprintf(buf, "With a mighty HEAVE you sling your $o out of reach %swards!", dirs[direction]);
d2568 1
a2568 1
	sprintf(buf, "With a mighty HEAVE $n slings $s $o out of reach %swards!", dirs[direction]);
d2579 2
a2580 2
	act("You lose your grip on your $o and send it flying!", TRUE, ch, weapon, NULL, TO_CHAR);
	act("$n loses $s grip on $s $o and sends it flying!", TRUE, ch, weapon, NULL, TO_ROOM);
d2586 2
a2587 2
      act("You lose your grip on your $o and it magically returns to your inventory!", TRUE, ch, weapon, NULL, TO_CHAR);
      act("$n loses $s grip on $s $o, and it magically returns to $s inventory!", TRUE, ch, weapon, NULL, TO_ROOM);
d3417 5
@


1.38
log
@added dispel_good_weapon type to the proper function.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.37 2000/02/25 03:14:19 cso Exp $
d3 2
a4 2
 *   File: fight.c                                       Part of CircleMUD *
 *  Usage: Combat system                             NOW Part of FieryMUD  *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d1418 1
d2009 19
a2027 21
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
    {
      if (type == SKILL_BACKSTAB) {
	/* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	damage (ch, victim, 0, SKILL_BACKSTAB);
        if(wielded)
	  sling_weapon(ch, wielded, WEAR_WIELD);
	else if(hwielded)
	  sling_weapon(ch, hwielded, WEAR_2HWIELD);
      } else if (type == SKILL_BAREHAND) {
	damage (ch, victim, 0, SKILL_BAREHAND);
      } else {
	/* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	if(wielded) {
	  if(!(sling_weapon(ch, wielded, WEAR_WIELD))) {
	    damage (ch, victim, 0, w_type);
	  }
	} else if(hwielded) {
	  if(!(sling_weapon(ch, hwielded, WEAR_2HWIELD))) {
	    damage (ch, victim, 0, w_type);
	  }
d2031 14
a2044 22
  else
    {
      /* okay, we know the guy has been hit.  now calculate damage. */
      dam = str_app[STRENGTH_APPLY_INDEX (ch)].todam;
      dam += GET_DAMROLL (ch);
      
      if (wielded)
	{
	  if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2));
	  else
	    dam += dice (GET_OBJ_VAL (wielded, 1), GET_OBJ_VAL (wielded, 2)) +
	      dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	}
      else if (hwielded)
	{
	  if (!IS_NPC (ch))
	    dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2));
	  else
	    dam += dice (GET_OBJ_VAL (hwielded, 1), GET_OBJ_VAL (hwielded, 2)) +
	      dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	}
d2046 8
a2053 8
	{
	  if (IS_NPC (ch))
	    {
	      dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	    }
	  else
	    dam += number (0, 2);	/* Max. 2 dam with bare hands */
	}
d2055 54
a2108 15
      if (GET_POS (victim) < POS_FIGHTING)
	dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;	/*mark */
      /* Position  sitting  x 1.33 */
      /* Position  resting  x 1.66 */
      /* Position  sleeping x 2.00 */
      /* Position  stunned  x 2.33 */
      /* Position  incap    x 2.66 */
      /* Position  mortally x 3.00 */
      
      dam = MAX (1, dam);	/* at least 1 hp damage min per hit */
      
      if (type == SKILL_BACKSTAB)
	{
	  dam *= backstab_mult (GET_LEVEL (ch));
	  damage (ch, victim, dam, SKILL_BACKSTAB);
d2110 5
a2114 4
      else if (type == SKILL_BAREHAND)
	{
	  dam += barehand_mult (GET_LEVEL(ch));
	  damage (ch, victim, dam, SKILL_BAREHAND);
d2116 12
a2127 15
      else
	{
	  if (RIPOSTT)
	    {
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
	         act ("&8You grab $n's arm and twist it, causing $m to strike $mself!&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&8$N grabs your arm and twists it, causing you to damage to yourself!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N grabs and twists $n's arm, causing $n to hurt $mself!&0", TRUE, ch, 0, victim, TO_NOTVICT);
              } else {
	         act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
              }
	      damage (victim, ch, vdam, vw_type);
              improve_skill (victim, SKILL_RIPOST);
d2129 9
a2137 16
	  else if (PARRY)
	    {
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
	         act ("&7You smirk and slap $n's attack away with ease.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N smirks and slaps your attack away.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N smirks as $E slaps $n's attack away.&0", TRUE, ch, 0, victim, TO_NOTVICT);
              } else {
	         act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
              }
	      improve_skill (victim, SKILL_PARRY);
	      if (!FIGHTING (ch))
		set_fighting (ch, victim);
	      if (!FIGHTING (victim))
		set_fighting (victim, ch);
d2139 4
a2142 65
	  else if (DODGE)
	    {
              if (GET_LEVEL(ch) > 20 && GET_CLASS(ch) == CLASS_MONK) {
 	         act ("&7You twist in place and watch $n attack the air nearby.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
              } else {
	         act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
              }
	      /* If you miss it is now possible to accidently sling your weapon --Gurlaek 11/21/1999 */
	      if(wielded) {
		sling_weapon(ch, wielded, WEAR_WIELD);
	      } else if(hwielded) {
		sling_weapon(ch, hwielded, WEAR_2HWIELD);
	      }
	      improve_skill (victim, SKILL_DODGE);
	      if (!FIGHTING (ch))
		set_fighting (ch, victim);
	      if (!FIGHTING (victim))
		set_fighting (victim, ch);
	    }
	  else
	    {
	      if (dam > 0)
		{
		  /*ok here we hit victem so check for stone skin */
		  if (IS_AFFECTED (victim, AFF_STONE_SKIN))
		    {
		      if (number (0, 10) <= 9)
			{
			  decrease_modifier (victim);
			  dam = number (0, 3);
			}
		    }
		  if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
		    {
		      if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
			{
			  dam = (int) (3 * dam / 4);
			  GET_HIT (ch) -= (int) (dam / 4);
			}
		      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
			{
			  dam = (int) (3 * dam / 4);
			  GET_HIT (ch) -= (int) (dam / 4);
			}
		    }
		  if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD | AFF2_FIRESHIELD))
		    {
		      if (!IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
			GET_HIT (ch) -= (int) (dam / 3);
		    }
		}
	      if (victim)
		hitprcnt_mtrigger (victim);
	      damage (ch, victim, dam, w_type);
	      /* improve weapon proficiencies --gurlaek 11/21/1999 */
	      if(number(1,10) == 10) {
		if(wielded && (skill = weapon_proficiency(wielded, WEAR_WIELD)) != -1)
		  improve_skill(ch, skill);
		if(hwielded && (skill = weapon_proficiency(hwielded, WEAR_2HWIELD)) != -1)
		  improve_skill(ch, skill);
	      }
d2144 11
d2156 1
a2156 3
      
      /* check if the victim has a hitprcnt trigger */
      
d2158 4
d3417 3
@


1.37
log
@fixed a typo in peaceful rooms -- disrurb to disturb. yay!
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.36 1999/12/10 22:13:45 jimmy Exp $
d2682 2
d2689 1
a2689 1
      name != holyw_weapon)
d3442 3
@


1.36
log
@Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
exp code.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.35 1999/12/06 10:46:06 jimmy Exp $
d1439 1
a1439 1
      send_to_char ("You feel ashamed trying to disrurb the peace of this room.\r\n", ch);
d3440 5
@


1.35
log
@Fixed crash that happened when a weapon was slung into a room with noone there.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.34 1999/11/28 23:21:22 cso Exp jimmy $
a43 1
extern long max_exp_gain (struct char_data *ch);	/* see config.c */
d919 1
a919 5
void 
perform_group_gain (struct char_data *ch, long base,
		    struct char_data *victim)
{
  long share;
d925 2
a926 1
  */ if (GET_LEVEL (ch) < GET_LEVEL (victim))
d928 1
d932 3
a934 2
  /* sprintf(buf, " base within group exp %d.\r\n", base);
     send_to_char(buf, ch);
d936 1
a936 1
  share = MIN (max_exp_gain (ch), MAX (1, base));
d938 6
a943 8
  if (share > 1)
    {
      sprintf (buf2, "You receive your share of experience.\r\n");
      send_to_char (buf2, ch);
    }
  if (!IS_NPC (victim))
    share = 1;
  gain_exp (ch, victim, share);
d1724 1
a1724 1
	    exp = MIN (max_exp_gain (ch), GET_EXP (victim));
d1730 1
d3440 3
@


1.34
log
@make_corpse: modified values for corpses
damage: animated mobs no longer flee
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.33 1999/11/28 19:36:58 jimmy Exp cso $
d2539 1
d2600 5
a2604 2
	sprintf(buf, "A $o is slung violently in from %swards!", dirs[rev_dir[direction]]);
	act(buf, TRUE, NULL, weapon, NULL, TO_ROOM);
d3443 4
@


1.33
log
@Added stun time associated with slinging a weapon.  Also, a one in five chance
will sling the weapon into another room.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.32 1999/11/23 15:48:23 jimmy Exp $
d560 5
d566 3
a568 1
    GET_OBJ_VAL (corpse, 1) = 1;	/* player corpse */
d570 3
a572 1
    GET_OBJ_VAL (corpse, 1) = 0;	/* npc corpse    */
a573 1
  GET_OBJ_VAL (corpse, 3) = 1;	/* corpse identifier */
d580 1
a580 1
    GET_OBJ_MOB_FROM (corpse) = 0;
d730 1
a730 1
      for (i = 0; i <= (NUM_SPELL_CIRCLES + 1); i++) {
d1693 2
a1694 1
	  if (MOB_FLAGGED (victim, MOB_WIMPY) && (ch != victim))
d3439 4
@


1.32
log
@Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
Reinstated dual wield.
Allowed mobs/players to pick up items while fighting.
Fixed a bug in the damage message that wrongfully indicated a miss
due to a rounding error in the math.
This was all done in order to facilitate the chance to sling your
weapon in combat.  Dex and proficiency checks are now made on any missed
attact and a failure of both causes the weapon to be slung.
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.31 1999/10/30 15:35:19 rsd Exp $
d2526 1
d2528 2
d2568 31
a2598 4
      act("You lose your grip on your $o and send it flying!", TRUE, ch, weapon, NULL, TO_CHAR);
      act("$n loses $s grip on $s $o and sends it flying!", TRUE, ch, weapon, NULL, TO_ROOM);
      /* place the weapon in the room */
      obj_to_room(weapon, ch->in_room);
d2605 1
d2611 2
d3430 10
@


1.31
log
@Jimmy coded alignment restrictions on Paladins for exp.
Altered gain_exp() to add a victim check for alignment.
l
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.30 1999/09/16 01:15:11 dce Exp $
d80 2
d1161 1
a1161 1

a1237 5
  /*
    sprintf(buf2, "dam is:%d", dam);
    act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  */
  
d1243 1
a1243 3
  /* percent = MIN(percent, 1); */
  if (percent == 0)
    ;				/*percent += 1; */
d1248 4
a1251 2
  
  
d1781 1
a1781 1
    vdam = 0;
d1852 1
a1852 1
    send_to_char("You cant see a damn thing\r\n", ch);
d2002 2
a2003 1
      if (type == SKILL_BACKSTAB)
d2005 5
a2009 1
      else if (type == SKILL_BAREHAND)
d2011 12
a2022 2
      else
	damage (ch, victim, 0, w_type);
d2121 6
d2168 7
d2189 1
a2189 1
    vw_type = 0;
d2381 2
a2382 1
      if (type == SKILL_2BACK)
d2384 3
a2386 1
      else if (type == SKILL_BAREHAND)
d2388 5
a2392 2
      else
	damage (ch, victim, 0, w_type);
d2471 3
a2473 3
 	         act ("&7You twist in place and watch $n attack the air nearby.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N twists in place causing you to strike nothing but air!&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N twists in place as $n attacks the air nearby $M.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2475 3
a2477 3
	         act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	         act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	         act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2479 4
d2514 4
d2523 102
d2707 1
a2707 1
	     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2709 1
a2709 1
 	     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2716 1
a2716 1
		     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2718 1
a2718 1
		     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2727 1
a2727 1
		     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2886 1
a2886 3
void 
improve_skill (struct char_data *ch, int skill)
{
d3397 5
@


1.30
log
@Weight restrictions for monks...-hitroll, -damroll + ac
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.29 1999/09/08 07:06:03 jimmy Exp dce $
d854 1
a854 1
      gain_exp (ch->desc->original, -(exp_death_loss (ch->desc->original, GET_LEVEL (ch->desc->original))));
d858 1
a858 1
      gain_exp (ch, -(exp_death_loss (ch, GET_LEVEL (ch))));
d937 1
a937 1
  gain_exp (ch, share);
d1585 1
a1585 1
	gain_exp (ch, (GET_LEVEL (victim) * (long) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
d1587 1
a1587 1
	gain_exp (ch, (GET_LEVEL (victim) * (long) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
d1760 2
a1761 1
	    */ gain_exp (ch, exp);
d3258 3
@


1.29
log
@More insure++ runtime fixes.  Some small, but hardcore fixes mostly to do
with blood and killing
--gurlaek
@
text
@d1 1
a1 1
// $Id: fight.c,v 1.28 1999/09/05 07:00:39 jimmy Exp $
d1867 1
d1890 1
d1913 1
d1983 1
a1983 1
    calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
d2217 1
d2242 1
d2264 1
d2334 1
a2334 1
    calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
d3257 5
@


1.28
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d734 7
a740 3
  if (GET_LEVEL (real_char) < LVL_IMMORT)
    {
      make_corpse (real_char);
d742 1
a742 8
      if (ch != real_char)
	extract_char (real_char);
      if (!IS_NPC (real_char))	/* If killed dont save in room he died in */
	GET_LOADROOM (real_char) = GET_HOME (real_char);
    }
  else if (ch != real_char)
    {
      do_return (real_char, "", 0, 0);
d745 4
d891 1
a891 5

  raw_kill (ch, killer);
  
  Forgive_The_Basterd(ch);
  
d900 6
a905 1
}
d3250 4
a3253 1
// $Log$
@


1.27
log
@corrected the spelling of dirstacted in the monk combat semantics.
@
text
@d1 1
d3248 1
@


1.26
log
@removed a double space from nearly rips you in two with $s deadly #w!!&0"
@
text
@d1103 1
a1103 1
      "You slap $N, and while he is dirstacted, make a grab for $S nose.&0",
@


1.25
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d1227 1
a1227 1
      "$n nearly rips you in two with $s  deadly #w!!&0"
@


1.24
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d43 2
a44 2
extern int max_exp_gain (struct char_data *ch);	/* see config.c */
int exp_death_loss (struct char_data *ch, int level);
d74 1
a74 1
int perform_trophy_decrease (struct char_data *ch, struct char_data *vict, int exp);
d908 1
a908 1
perform_group_gain (struct char_data *ch, int base,
d911 1
a911 1
  int share;
d941 2
a942 1
  int tot_members = 0, base, lbase, exp;
d1005 1
a1005 1
    base = MAX (1, ((int) ((GET_EXP (victim) * (float) tot_percent / 100) + 1)));
d1008 1
a1008 1
  lbase = MAX (1, ((int) ((GET_EXP (victim) * (float) leader_percent / 100) + 1)));
d1412 1
a1412 1
  int exp;
d1582 1
a1582 1
	gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
d1584 1
a1584 1
	gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
@


1.23
log
@Fixed the skill advancement in peace rooms bug.
--gurlaek
@
text
@d71 1
a71 1
void frag_update (struct char_data *ch, struct char_data *victim, float amount);
d793 1
a793 1
	frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d801 1
a801 1
	  frag_update(g->groupee, killer, (1 / (float) tot_members));
d810 1
a810 1
	  frag_update(m->mgroupee, killer, (1 / (float) tot_members));
d818 1
a818 1
	    frag_update(g->groupee, killer, (1 / (float) tot_members));
d828 1
a828 1
	frag_update(groupmaster, killer, (1 / (float) tot_members));
d836 1
a836 1
	  frag_update(g->groupee, killer, (1 / (float) tot_members));
a873 2
	// frag_update (killer, ch, 1.0);
	// Temp fix till kill-to_group is made to update frags
d876 1
a876 1
    frag_update (killer, ch, 1.0);
@


1.22
log
@Tweaked alignment code
@
text
@d1796 8
d2169 8
@


1.21
log
@Alignment completely redone.
@
text
@d628 2
@


1.20
log
@Mob casters can not hit while casting.
Updated spell cast times to be more realistic
changed combat to 4 seconds per round.
Removed do_order semantics that told the order to onlookers.
@
text
@d617 25
d643 16
a658 37
  /*
   * new alignment change algorithm: if you kill a monster with alignment A,
   * you move 1/16th of the way to having alignment -A.  Simple and fast.
   Yeah and it sucks so i changed it....Banyal */
  /*proky had a go at it */
  /*      if ((GET_ALIGNMENT(ch) == -1000) && (GET_ALIGNMENT(victim)  > 500))
	  return;
	  if ((GET_ALIGNMENT(ch) == 1000) && (GET_ALIGNMENT(victim)  < -500))
	  return;
  */
  if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
    change = ((GET_ALIGNMENT (victim)) - (GET_ALIGNMENT (ch)));
  else
    change = ((GET_ALIGNMENT (ch)) - (GET_ALIGNMENT (victim)));
  /*basically the higher the level of victim more alig change */
  change = (int) (change / (50 + number (75, 120) - GET_LEVEL (victim)));
  /*just decrease it again randomly */
  if (number (0, 2))
    change = (int) (change / 2);
  if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
    GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) - change;
  else
    GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) + change;
  
  GET_ALIGNMENT (ch) = MIN (1000, (MAX (-1000, GET_ALIGNMENT (ch))));
  /*      sprintf(buf, " alignment change %d.\r\n", change);
	  send_to_char(buf, ch);
  */
  
  /*  GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 4;
      
      
      if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) > 600)
      GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 9;
      if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) < 601)
      GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 7;
  */ 
a659 2


@


1.19
log
@The combat system was enhanced/improved in the following ways:  Mobs
can no longer flee while bashed or sitting.  Fleeing causes casters to
stop casting.  You can now flee while flying.  pk checks were added to
bash, bodyslam, throatcut, etc etc.  Lots of reformatting and little
fixes. spellcasting for mobs is now very similar to PC spellcasting.
MObs will now unhide/unconceal/univis/ etc when casting offensive spells.
Mobs no longer improve skills.  Bash now requires mobs to have a shield
just like PC's.  It's aT 25% with no shield and 50% with a 2handed weapon.
--gurlaek
@
text
@d2528 4
a2531 1
      
@


1.18
log
@Fixed the group NPC issue.  Players can no longer group NPC's and
crash the mud at will
--gurlaek 7/7/1999
@
text
@d2722 2
@


1.17
log
@Fixed ANSI compile warnings in fight.c by removing the void *
function pointer and adding a type field
--gurlaek
@
text
@d778 1
a778 1
  } else {				/*just group count */
d797 1
a797 1
	  frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d799 1
a799 1
	  trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d806 1
a806 1
	  frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d808 1
a808 1
	  trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d814 1
a814 1
	    frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d816 1
a816 1
	    trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d824 1
a824 1
	frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d826 1
a826 1
	trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
d832 1
a832 1
	  frag_update(majorgroupmaster, killer, (1 / (float) tot_members));
d834 1
a834 1
	  trophy_update(majorgroupmaster, killer, (1 / (float) tot_members));
@


1.16
log
@Ok, fixed do_quit to check for fighting and also not crash when mortally
wounded.  This was done in die() by checking for killer=NULL.
since no one killed you if you quit while morted the die code
didn't know how to deal with a NULL killer.
--Gurlaek 6/11/1999
@
text
@d745 3
a747 3
void 
kill_to_group (struct char_data *ch, struct char_data *killer, void *infunc (struct char_data *ch, struct char_data *killer, float amount))
{/*want to loop through all group and major group members for this */
d759 16
a774 12
  if (!(IS_AFFECTED (groupmaster, AFF_GROUP)))
    {
      sprintf (buf, "In group exp give and leader not grouped?:%s exiting without exp gain", GET_NAME (ch));
      mudlog (buf, NRM, LVL_GOD, FALSE);
      return;
    }
  if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
    {
      majorgroupmaster = (groupmaster->mgroupmaster ? groupmaster->mgroupmaster : groupmaster);
      if (majorgroupmaster->in_room == ch->in_room)
	tot_members = 1;
      for (g = majorgroupmaster->groupees; g; g = g->next)
d777 23
a799 7
      for (m = majorgroupmaster->mgroupees; m; m = m->next)
	{
	  if (m->mgroupee->in_room == ch->in_room)
	    tot_members++;
	  for (g = m->mgroupee->groupees; g; g = g->next)
	    if (g->groupee->in_room == ch->in_room)
	      tot_members++;
d801 1
d803 17
a819 7
  else
    {				/*just group count */
      if (groupmaster->in_room == ch->in_room)
	tot_members = 1;
      for (g = groupmaster->groupees; g; g = g->next)
	if (g->groupee->in_room == ch->in_room)
	  tot_members++;
d821 14
a834 15
  
  if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
    {
      if (majorgroupmaster->in_room == ch->in_room)
	infunc (majorgroupmaster, killer, (1 / (float) tot_members));
      for (g = majorgroupmaster->groupees; g; g = g->next)
	if (g->groupee->in_room == ch->in_room)
	  infunc (g->groupee, killer, (1 / (float) tot_members));
      for (m = majorgroupmaster->mgroupees; m; m = m->next)
	{
	  if (m->mgroupee->in_room == ch->in_room)
	    infunc (m->mgroupee, killer, (1 / (float) tot_members));
	  for (g = m->mgroupee->groupees; g; g = g->next)
	    if (g->groupee->in_room == ch->in_room)
	      infunc (g->groupee, killer, (1 / (float) tot_members));
d836 1
d838 1
a838 8
  else
    {				/*just group count */
      if (groupmaster->in_room == ch->in_room)
	infunc (groupmaster, killer, (1 / (float) tot_members));
      for (g = groupmaster->groupees; g; g = g->next)
	if (g->groupee->in_room == ch->in_room)
	  infunc (g->groupee, killer, (1 / (float) tot_members));
    }
d863 1
a863 1
	      kill_to_group (killer, ch, (void *) frag_update);
d866 1
a866 1
	kill_to_group (killer, ch, (void *) trophy_update);
@


1.15
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@a684 2
  //   register struct char_data *j;
  //   extern struct char_data *character_list;
a720 8
  //   if (!IS_NPC (ch))
  //      for (j = character_list; j; j = j->next)
  //      {
  //	 if (IS_NPC (j))
  //	    if (MEMORY (j))
  //	       if (mem_inMemory (j, ch))
  //		  forget (j, ch);
  //      }
d723 4
a726 6
  if (killer)
    {
      if (death_mtrigger (ch, killer))
	death_cry (ch);
    }
  else if (killer)
d728 1
a728 2
  /*if (!IS_NPC(ch))
    make_fun_body_pieces(ch, killer); */
a819 3
  //  register struct char_data *i;
  //  extern struct char_data *character_list;
  
a820 1
  //  int groupees;
a823 1
      /*    gain_exp(ch->desc->original, -(GET_EXP(ch->desc->original) >> 1)); */
a827 1
      /*    gain_exp(ch, -(GET_EXP(ch) >> 1)); */
d830 23
a852 21
  if (IS_AFFECTED (killer, AFF_GROUP))
   {				/*loop through group */
     /*if a BIG person got kill then dont let rest of group bludge: */
     if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25)) {
       if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)))
	 ;
       else
	 {
	   kill_to_group (killer, ch, (void *) frag_update);
	 }
     }
     kill_to_group (killer, ch, (void *) trophy_update);
   }
  else
    {
      // frag_update (killer, ch, 1.0);
      // Temp fix till kill-to_group is made to update frags
      trophy_update (killer, ch, 1.0);
    }
  
  
d855 1
d863 1
a863 1
  frag_update (killer, ch, 1.0);
a865 1
  // forget(killer, ch);
a867 12
  /*New to solve memory problem with mobs, as was the mob that killed the pc
    was the ONLY one that forgot him. Now all does using a utility
    Mem_inMemory   Banyal */
  //  if (!IS_NPC (ch))
  //     for (i = character_list; i; i = i->next)
  //     {
  //	 if (IS_NPC (i))
  //	    if (MEMORY (i))
  //	       if (mem_inMemory (i, ch))
  //		  forget (i, ch);
  //    }
  
a875 1

@


1.14
log
@Clean up
@
text
@d852 1
a852 1
     if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25))
d859 1
d1579 11
a1589 11
  if (ch != victim)
    if (IS_NPC (ch));			
  /*  gain_exp(ch, ((GET_LEVEL(victim)/2) * (dam/4))); */
    else
      {
	if ((GET_LEVEL (ch) - GET_LEVEL (victim)) > 10)
	  gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
	else
	  gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
      }
  
d1717 1
a1717 1
      if (IS_NPC (victim) || victim->desc)
d1719 1
a1719 1
	    group_gain (ch, victim);
d1738 1
a1738 1
	       exp = 70;
d1763 1
d2655 6
a2660 5
			  !weapon_special (wpn, ch))
                          if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
		     		hit2 (ch, FIGHTING(ch), SKILL_BAREHAND);
                  	  else
				hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2681 3
a2683 3
		  GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
                  if (GET_SKILL(ch, SKILL_BAREHAND) > 0 && !GET_EQ(ch, WEAR_WIELD) && !GET_EQ(ch, WEAR_2HWIELD))
		     hit (ch, FIGHTING(ch), SKILL_BAREHAND);
d2685 2
a2686 2
		     hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	      
@


1.13
log
@Fixed the mounting problem.
@
text
@d532 1
a532 2
void 
make_corpse (struct char_data *ch)
d680 1
a680 2
void 
raw_kill (struct char_data *ch, struct char_data *killer)
d831 1
a831 2
void 
die (struct char_data *ch, struct char_data *killer)
@


1.12
log
@No pkilling with mobs
@
text
@d1445 1
a1445 1
     if (!IS_NPC(ch) && !IS_NPC(victim)) {
@


1.11
log
@Disallows pkilling.
@
text
@d1450 1
a1450 1
        if (!IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(victim)) {
d1452 1
d1829 1
a1829 1
        if (!IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(victim)) {
d2181 1
a2181 1
        if (!IS_AFFECTED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(victim)) {
@


1.10
log
@Fixes death blow for monks.
@
text
@a1081 1

a1090 1
  
d1235 1
a1235 1
  
a1413 1

d1444 14
a1457 2
  
  
d1556 2
a1557 2
      if (PLR_FLAGGED (ch, PLR_KILLER) && (ch != victim))
	dam = 0;
d1780 1
a1780 2
void 
hit (struct char_data *ch, struct char_data *victim, int type)
d1819 18
a1836 1
  
d2146 1
a2146 2
void 
hit2 (struct char_data *ch, struct char_data *victim, int type)
d2171 18
@


1.9
log
@Monk semantics for dodge/parry/ripost/attack
@
text
@d1325 11
@


1.8
log
@ "$n nearly rips $N in two with $s deadly #w!!&0",	/* 8: > 23   */
Added the RIPS as opposed to RIP
@
text
@d1093 71
a1163 1
  
d1238 2
a1239 2
  
  w_type -= TYPE_HIT;		/* Change to base of table with text */
d1281 5
a1285 1
  buf = replace_string (dam_weapons[msgnum].to_room,
d1291 4
a1294 1
  buf = replace_string (dam_weapons[msgnum].to_char,
d1301 4
a1304 1
  buf = replace_string (dam_weapons[msgnum].to_victim,
d1344 4
a1347 1
		  act (msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
d1351 4
a1354 1
		  act (msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
d1357 4
a1360 1
		  act (msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
d1582 6
a1587 1
  if (!IS_WEAPON (attacktype))
d1773 2
a1774 1
  
d1838 1
a1838 1
      if (vwielded || vhwielded)
d1860 1
a1860 1
      if (vwielded || vhwielded)
d1886 2
d1904 2
d1925 2
d1959 2
d2012 5
d2021 9
a2029 3
	      act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2031 1
d2035 9
a2043 3
	      act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2052 9
a2060 3
	      act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2127 2
a2128 1
  
d2161 1
a2161 1
      if (vwielded || vhwielded)
d2183 1
a2183 1
      if (vwielded || vhwielded)
d2208 2
d2228 2
d2248 2
d2282 2
d2327 5
d2336 9
a2344 3
	      act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2350 9
a2358 3
	      act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2363 9
a2371 3
	      act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	      act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	      act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
d2486 4
a2489 1
	  hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2495 4
a2498 1
		  hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2506 4
a2509 1
		  hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2538 4
a2541 1
			    hit (ch, vict, TYPE_UNDEFINED);
d2563 4
a2566 1
		      hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2581 4
a2584 1
			      hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2603 4
a2606 1
			hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2628 4
a2631 1
		hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2648 4
a2651 1
		  hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
@


1.7
log
@Fixed mortally wounded bug.  Mortally wounded
victims now die when they read -11.  Also,
no more "attempt to damage corpse"
fingon
@
text
@d1162 1
a1162 1
      "$n nearly rip $N in two with $s deadly #w!!&0",	/* 8: > 23   */
@


1.6
log
@fixed debug messages
@
text
@a455 2
      pos = POS_MORTALLYW;	/* TO NOT HAVE DAMAGE CORPSE BUG */
      
d2290 3
a2292 1
      if (FIGHTING (ch) == NULL || ch->in_room != FIGHTING (ch)->in_room)
@


1.5
log
@added debug statement
@
text
@d1337 1
a1337 1
      log ("bugbuf");
@


1.4
log
@max/min exp loss/gain set to 2 notches.
@
text
@d1327 2
d1333 1
a1333 1
  
d1336 2
@


1.3
log
@fixed spell mem at death bug
@
text
@d43 1
a43 1
int max_exp_gain (struct char_data *ch);	/* see config.c */
@


1.2
log
@Altered comment header
indented file
@
text
@d711 7
a717 9
  if (ch->spell_list)
    {
      cur = ch->spell_list;
      if (cur != NULL)
	for (i = 0; i < ch->num_spells && cur; i++)
	  {
	    cur->can_cast = 0;
	    cur = cur->next;
	  }
d720 6
a725 1
    }
d909 1
@


1.1
log
@Initial revision
@
text
@d1 9
a9 9
/* ************************************************************************
   *   File: fight.c                                       Part of CircleMUD *
   *  Usage: Combat system                                                   *
   *                                                                         *
   *  All rights reserved.  See license.doc for complete information.        *
   *                                                                         *
   *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
   *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
   ************************************************************************ */
d87 15
a101 15
   {"hit", "hits"},		/* 0 */
   {"sting", "stings"},
   {"whip", "whips"},
   {"slash", "slashes"},
   {"bite", "bites"},
   {"bludgeon", "bludgeons"},	/* 5 */
   {"crush", "crushes"},
   {"pound", "pounds"},
   {"claw", "claws"},
   {"maul", "mauls"},
   {"thrash", "thrashes"},	/* 10 */
   {"pierce", "pierces"},
   {"blast", "blasts"},
   {"punch", "punches"},
   {"stab", "stabs"}
d111 10
a120 10
   if (affected_by_spell (ch, SPELL_INVISIBLE))
      affect_from_char (ch, SPELL_INVISIBLE);
   if (affected_by_spell (ch, SPELL_CONCEALMENT))
      affect_from_char (ch, SPELL_CONCEALMENT);


   REMOVE_BIT (AFF_FLAGS (ch), AFF_INVISIBLE | AFF_HIDE);

   if (GET_LEVEL (ch) < LVL_IMMORT)
   {
d123 4
a126 4
   }
   else
      act ("You feel a strange presence as $n appears, seemingly from nowhere.",
	   FALSE, ch, 0, 0, TO_ROOM);
d134 7
a140 7
   FILE *fl;
   int i, type;
   struct message_type *messages;
   char chk[128];

   if (!(fl = fopen (MESS_FILE, "r")))
   {
d144 3
a146 3
   }
   for (i = 0; i < MAX_MESSAGES; i++)
   {
d150 9
a158 9
   }


   fgets (chk, 128, fl);
   while (!feof (fl) && (*chk == '\n' || *chk == '*'))
      fgets (chk, 128, fl);

   while (*chk == 'M')
   {
d162 1
a162 1
	   (fight_messages[i].a_type); i++);
d164 4
a167 4
      {
	 fprintf (stderr, "Too many combat messages.  Increase MAX_MESSAGES and recompile.");
	 exit (1);
      }
d169 1
a169 1

d174 1
a174 1

d191 2
a192 2

   fclose (fl);
d201 21
a221 21
   int tmp, pos, pos1;

   ACMD (do_wake);

   if(event_target_valid(victim) == FALSE)
     return;

   if (IS_FIGHTING (victim))
      if (victim->in_room != FIGHTING (victim)->in_room)
	 stop_fighting (victim);

   if (RIDING (victim))
      if (RIDING (victim)->in_room != victim->in_room)
	 dismount_char (victim);


/* some chesck to make pos cleaner and work well with the mud Banyal */
   if (!AWAKE (victim) || IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS)
       || IS_AFFECTED (victim, AFF_MAJOR_PARA) ||
       IS_AFFECTED2 (victim, AFF2_KNOCKED_OUT) || (GET_POS (victim) < POS_SLEEPING))
   {
d223 1
a223 1
	 stop_fighting (victim);
d225 7
a231 7
   }
   /* check for mobs, if they can assume their default position */
   if (IS_NPC (victim) && (GET_POS (victim) > POS_SLEEPING) &&
       !IS_FIGHTING (victim) && !GET_MOB_WAIT (victim) &&
       ((victim->mob_specials.default_pos) > POS_SLEEPING) &&
       (MOB_FLAGGED (victim, MOB_MEMORY) && !MEMORY (victim)))
   {
d233 5
a237 1
   }
d239 2
a240 6
/* Lets dive into updating for current hitpoints this MUSt be first
   so that any following checks are current and reflect the
   players  current diliema...Banyal */

   if (GET_HIT (victim) > 0 && GET_POS (victim) < POS_SLEEPING)
   {
d243 3
a245 3
   }
   else if (GET_HIT (victim) <= HIT_DEAD)
   {
d247 3
a249 3
   }
   else if (GET_HIT (victim) <= HIT_MORTALLYW)
   {
d253 5
a257 5
	 if (victim->desc && victim->desc->original)
	    do_return (victim, "", 0, 0);
   }
   else if (GET_HIT (victim) <= HIT_INCAP)
   {
d261 5
a265 5
	 if (victim->desc && victim->desc->original)
	    do_return (victim, "", 0, 0);
   }
   else if (GET_HIT (victim) < 0)
   {
d267 3
a269 3
   }
   else
   {
d271 12
a282 12
   }
/* Lets cut out some typing heh Banyal */
   pos = GET_POS (victim);
   pos1 = GET_POS1 (victim);

/* Now lets use our new dual position system and riding to victimeck(I hope)
   all the possible positions and perhaps problems in those postions the
   poor mortals get themselves into. Banyal */


   if (pos < POS_RESTING)
   {
d285 68
a352 66
      {
      case POS1_PRONE:
	 break;
      case POS1_KNEELING:
	 switch (GET_POS (victim))
	 {
	 case POS_DEAD:
	    if (RIDING (victim))
	       tmp = 1;
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 case POS_MORTALLYW:
	 case POS_INCAP:
	 case POS_SLEEPING:
	    /*mark new */
	    if (RIDING (victim))
	    {
	       if (!number (0, 1))
		  tmp = 1;
	    }
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 }
	 break;
      case POS_SITTING:
	 switch (pos)
	 {
	 case POS_DEAD:
	    if (RIDING (victim))
	    {
	       if (!number (0, 1))
		  tmp = 1;
	    }
	    else
	    {
	       if (!number (0, 9))
		  tmp = 1;
	    }
	    break;
	 }
	 break;
/*end mark */

      case POS1_STANDING:
	 switch (pos)
	 {
	 case POS_DEAD:
	    tmp = 1;
	    break;
	 case POS_MORTALLYW:
	 case POS_INCAP:
	 case POS_SLEEPING:
	    if (RIDING (victim))
	       tmp = 1;
	    else
	    {
	       if (!number (0, 5))
		  tmp = 1;
d354 2
a355 4
	    break;
	 }
	 break;
      }
d357 44
a400 44
      {
	 tmp = 0;
	 if (RIDING (victim))
	 {
	    tmp = 1;
	    switch (GET_POS1 (RIDING (victim)))
	    {
	    case POS1_PRONE:
	    case POS1_KNEELING:
	    case POS1_SITTING:
	       break;
	    case POS1_STANDING:
	       alter_hit (victim, dice (3, 8), 2);
	       WAIT_STATE (victim, PULSE_VIOLENCE + 2);		/* this will be stun when it
								   it is coded MARKSTUN */
	       break;
	    }
	    act ("$n falls of $s mount!", TRUE, victim, 0, 0, TO_ROOM);
	    dismount_char (victim);
	 }
	 else
	 {
	    switch (pos1)
	    {
	    case POS1_PRONE:
	    case POS1_KNEELING:
	    case POS1_SITTING:
	       break;
	    case POS_STANDING:
	       tmp = 0;
	       if (!number (0, 2))
	       {
		  alter_hit (victim, dice (3, 5), 2);
		  if (GET_POS (victim) > POS_INCAP)
		     WAIT_STATE (victim, PULSE_VIOLENCE + 2);
		  tmp = 1;
	       }
	       act ("$n slumps to the ground.", TRUE, victim, 0, 0, TO_ROOM);
	       break;
	    }
	 }
	 pos1 = POS1_PRONE;

	 /* RE-chECK POSTION WITH NEW HITPOINTS */
d402 4
a405 4
	 {
	    GET_POS (victim) = POS_SITTING;
	    GET_POS1 (victim) = POS1_PRONE;
	 }
d407 1
a407 1
	    GET_POS (victim) = POS_DEAD;
d409 4
a412 4
	 {
	    GET_POS (victim) = POS_MORTALLYW;
	    StopMercifulAttackers (victim);
	    if (GET_LEVEL (victim) >= LVL_IMMORT)
d414 2
a415 2
		  do_return (victim, "", 0, 0);
	 }
d417 4
a420 4
	 {
	    GET_POS (victim) = POS_INCAP;
	    StopMercifulAttackers (victim);
	    if (GET_LEVEL (victim) >= LVL_IMMORT)
d422 2
a423 2
		  do_return (victim, "", 0, 0);
	 }
d425 4
a428 4
	 {
	    pos = GET_POS (victim);
	 }

d430 2
a431 2
	 {
	    if (affected_by_spell (victim, SPELL_SLEEP))
d433 10
a442 10
	    if (pos == POS_SLEEPING)
	    {
	       pos = POS_RESTING;
	       send_to_char ("Huh?!? You find yourself laying on the ground!\r\n", victim);
	    }
	 }
      }
   }
   if ((GET_POS (victim) == POS_SLEEPING) && (pos > POS_SLEEPING))
   {
d446 8
a453 8
   }
   GET_POS (victim) = pos;
   GET_POS1 (victim) = pos1;

   /*Some sanity checks lets not leave dead people to be found by code
      elsewhere */
   if (pos == POS_DEAD)
   {
d455 1
a455 1
	 stop_fighting (victim);
d457 3
a459 3

   }
   /*mark69 */
d466 4
a469 4
   if (!PLR_FLAGGED (vict, PLR_KILLER) && !PLR_FLAGGED (vict, PLR_THIEF)
       && !PLR_FLAGGED (ch, PLR_KILLER) && !IS_NPC (ch) && !IS_NPC (vict) &&
       (ch != vict))
   {
d471 1
a471 1

d477 1
a477 1
   }
d485 20
a504 20
   if (ch == vict)
      return;

   assert (!FIGHTING (ch));	/*Setmark game crashing due to assertion failing */

   ch->next_fighting = combat_list;
   combat_list = ch;

   if (IS_AFFECTED (ch, AFF_SLEEP))
      affect_from_char (ch, SPELL_SLEEP);

   FIGHTING (ch) = vict;
   /*GET_POS(ch) = POS_FIGHTING; */

   if (!pk_allowed)
      check_killer (ch, vict);
   check_justice (ch, vict);
if(ch != vict)
if (ch->desc && ch->desc->original)
  check_justice(ch->desc->original, vict);
d513 11
a523 11
   extern char *spell_wear_off_msg[];
   struct char_data *temp;

   if (ch == next_combat_list)
      next_combat_list = ch->next_fighting;

   REMOVE_FROM_LIST (ch, combat_list, next_fighting);
   ch->next_fighting = NULL;
   FIGHTING (ch) = NULL;
   if (IS_AFFECTED2 (ch, AFF2_HARNESS))
   {
d527 3
a529 3
   }
   GET_POS (ch) = POS_STANDING;
   update_pos (ch);
d537 57
a593 57
   struct obj_data *corpse, *o;
   struct obj_data *money;
   int i;
   extern int max_npc_corpse_time, max_pc_corpse_time, top_of_corpse_list;
   struct obj_data *create_money (int pamount, int gamount, int samount, int camount);

   corpse = create_obj ();

   corpse->item_number = NOTHING;
   corpse->in_room = NOWHERE;
   sprintf (buf2, "corpse %s", strip_ansi ((ch)->player.name));
   corpse->name = str_dup (buf2);

   sprintf (buf2, "&0The corpse of %s&0 is lying here.", GET_NAME (ch));
   corpse->description = str_dup (buf2);

   sprintf (buf2, "the corpse of %s", GET_NAME (ch));
   corpse->short_description = str_dup (buf2);

   GET_OBJ_TYPE (corpse) = ITEM_CONTAINER;
   /*GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE; */
   GET_OBJ_EXTRA (corpse) = (ITEM_NODONATE | ITEM_FLOAT);
   GET_OBJ_VAL (corpse, 0) = 0;	/* You can't store stuff in a corpse */
   if (!IS_NPC (ch))
      GET_OBJ_VAL (corpse, 1) = 1;	/* player corpse */
   else
      GET_OBJ_VAL (corpse, 1) = 0;	/* npc corpse    */
   GET_OBJ_VAL (corpse, 2) = top_of_corpse_list;
   GET_OBJ_VAL (corpse, 3) = 1;	/* corpse identifier */
   GET_OBJ_WEIGHT (corpse) = GET_WEIGHT (ch) + IS_CARRYING_W (ch) + 100;
   GET_OBJ_RENT (corpse) = 100000;
   GET_OBJ_RENT (corpse) = GET_LEVEL (ch);
   if (IS_NPC (ch))
      GET_OBJ_MOB_FROM (corpse) = GET_MOB_RNUM (ch);
   else
      GET_OBJ_MOB_FROM (corpse) = 0;

   if (IS_NPC (ch))
      GET_OBJ_TIMER (corpse) = max_npc_corpse_time;
   else
      GET_OBJ_TIMER (corpse) = max_pc_corpse_time;

   /* transfer character's inventory to the corpse */
   corpse->contains = ch->carrying;
   if (!(MOB_FLAGGED (ch, MOB_NOGEAR)))
      for (o = corpse->contains; o != NULL; o = o->next_content)
	 o->in_obj = corpse;
   object_list_new_owner (corpse, NULL);

   /* transfer character's equipment to the corpse */
   for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ (ch, i))
	 obj_to_obj (unequip_char (ch, i), corpse);

   /* transfer gold */
   if (GET_CASH (ch) > 0)
   {
d596 4
a599 4
      {
	 money = create_money (GET_PLAT (ch), GET_GOLD (ch), GET_SILVER (ch), GET_COPPER (ch));
	 obj_to_obj (money, corpse);
      }
d604 8
a611 8
   }
   ch->carrying = NULL;
   IS_CARRYING_N (ch) = 0;
   IS_CARRYING_W (ch) = 0;

   obj_to_room (corpse, ch->in_room);
   if (!IS_NPC (ch))
      ccontrol_make_corpse (world[ch->in_room].number, corpse);
d619 39
a657 39
   int change = 0;

   /*
    * new alignment change algorithm: if you kill a monster with alignment A,
    * you move 1/16th of the way to having alignment -A.  Simple and fast.
    Yeah and it sucks so i changed it....Banyal */
/*proky had a go at it */
/*      if ((GET_ALIGNMENT(ch) == -1000) && (GET_ALIGNMENT(victim)  > 500))
   return;
   if ((GET_ALIGNMENT(ch) == 1000) && (GET_ALIGNMENT(victim)  < -500))
   return;
 */
   if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
      change = ((GET_ALIGNMENT (victim)) - (GET_ALIGNMENT (ch)));
   else
      change = ((GET_ALIGNMENT (ch)) - (GET_ALIGNMENT (victim)));
   /*basically the higher the level of victim more alig change */
   change = (int) (change / (50 + number (75, 120) - GET_LEVEL (victim)));
   /*just decrease it again randomly */
   if (number (0, 2))
      change = (int) (change / 2);
   if (GET_ALIGNMENT (ch) > GET_ALIGNMENT (victim))
      GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) - change;
   else
      GET_ALIGNMENT (ch) = GET_ALIGNMENT (ch) + change;

   GET_ALIGNMENT (ch) = MIN (1000, (MAX (-1000, GET_ALIGNMENT (ch))));
/*      sprintf(buf, " alignment change %d.\r\n", change);
   send_to_char(buf, ch);
 */

/*  GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 4;


   if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) > 600)
   GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 9;
   if ((-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) < 601)
   GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) >> 7;
 */ 
d665 7
a671 7
   int door, was_in;

   act ("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);
   was_in = ch->in_room;

   for (door = 0; door < NUM_OF_DIRS; door++)
   {
d673 6
a678 6
      {
	 ch->in_room = world[was_in].dir_option[door]->to_room;
	 act ("Your blood freezes as you hear someone's death cry.", FALSE, ch, 0, 0, TO_ROOM);
	 ch->in_room = was_in;
      }
   }
d686 9
a694 9
   struct char_data *real_char;
   struct mem_list *cur;
   int i;
//   register struct char_data *j;
//   extern struct char_data *character_list;

   /*check for switched victim */
   if (ch->desc && ch->desc->original)
   {
d698 15
a712 15
   }
   else
      real_char = ch;

   if (FIGHTING (ch))
      stop_fighting (ch);

   while (ch->affected)
      affect_remove (ch, ch->affected);
   while (real_char->affected)
      affect_remove (real_char, real_char->affected);

   /* this guy died ..zero the mem_list */
   if (ch->spell_list)
   {
d715 2
a716 2
	 for (i = 0; i < ch->num_spells && cur; i++)
	 {
d719 1
a719 1
	 }
d722 14
a735 14
   }

//   if (!IS_NPC (ch))
//      for (j = character_list; j; j = j->next)
//      {
//	 if (IS_NPC (j))
//	    if (MEMORY (j))
//	       if (mem_inMemory (j, ch))
//		  forget (j, ch);
//      }
    Forgive_The_Basterd(ch);

   if (killer)
   {
d737 8
a744 8
	 death_cry (ch);
   }
   else if (killer)
      mprog_death_trigger (ch, killer);
/*if (!IS_NPC(ch))
   make_fun_body_pieces(ch, killer); */
   if (GET_LEVEL (real_char) < LVL_IMMORT)
   {
d748 1
a748 1
	 extract_char (real_char);
d750 4
a753 4
	 GET_LOADROOM (real_char) = GET_HOME (real_char);
   }
   else if (ch != real_char)
   {
d756 1
a756 1
   }
d762 13
a774 13

//   int groupees;
   int tot_members = 0;
   struct char_data *groupmaster;
   struct char_data *majorgroupmaster = NULL;
   struct group_type *g;
   struct mgroup_type *m;
//   float tot_percent;
//   float leader_percent;

   groupmaster = (ch->groupmaster ? ch->groupmaster : ch);
   if (!(IS_AFFECTED (groupmaster, AFF_GROUP)))
   {
d778 3
a780 3
   }
   if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
   {
d783 1
a783 1
	 tot_members = 1;
d785 2
a786 2
	 if (g->groupee->in_room == ch->in_room)
	    tot_members++;
d788 2
a789 2
      {
	 if (m->mgroupee->in_room == ch->in_room)
d791 1
a791 1
	 for (g = m->mgroupee->groupees; g; g = g->next)
d793 5
a797 5
	       tot_members++;
      }
   }
   else
   {				/*just group count */
d799 1
a799 1
	 tot_members = 1;
d801 6
a806 6
	 if (g->groupee->in_room == ch->in_room)
	    tot_members++;
   }

   if (IS_AFFECTED2 (groupmaster, AFF2_MGROUP))
   {
d808 1
a808 1
	 infunc (majorgroupmaster, killer, (1 / (float) tot_members));
d810 2
a811 2
	 if (g->groupee->in_room == ch->in_room)
	    infunc (g->groupee, killer, (1 / (float) tot_members));
d813 2
a814 2
      {
	 if (m->mgroupee->in_room == ch->in_room)
d816 1
a816 1
	 for (g = m->mgroupee->groupees; g; g = g->next)
d818 5
a822 5
	       infunc (g->groupee, killer, (1 / (float) tot_members));
      }
   }
   else
   {				/*just group count */
d824 1
a824 1
	 infunc (groupmaster, killer, (1 / (float) tot_members));
d826 3
a828 3
	 if (g->groupee->in_room == ch->in_room)
	    infunc (g->groupee, killer, (1 / (float) tot_members));
   }
d835 9
a843 9
 //  register struct char_data *i;
 //  extern struct char_data *character_list;

   /*check for switch. Original char loses exp */
 //  int groupees;

   if (ch->desc && ch->desc->original)
   {
/*    gain_exp(ch->desc->original, -(GET_EXP(ch->desc->original) >> 1)); */
d845 4
a848 4
   }
   else
   {
/*    gain_exp(ch, -(GET_EXP(ch) >> 1)); */
d850 2
a851 2
   }
   if (IS_AFFECTED (killer, AFF_GROUP))
d853 5
a857 5
      /*if a BIG person got kill then dont let rest of group bludge: */
      if ((GET_LEVEL (ch) < 20) && (GET_LEVEL (killer) > 25))
	 if ((!IS_NPC (ch)) || (IS_NPC (ch) && (ch->desc && ch->desc->original)))
	    ;
	 else
d859 1
a859 1
	    kill_to_group (killer, ch, (void *) frag_update);
d861 1
a861 1
      kill_to_group (killer, ch, (void *) trophy_update);
d863 2
a864 2
   else
   {
d866 1
a866 1
     // Temp fix till kill-to_group is made to update frags
d868 7
a874 7
   }


   if (IS_AFFECTED2 (ch, AFF2_ON_FIRE))
      REMOVE_BIT (AFF2_FLAGS (ch), AFF2_ON_FIRE);
   if (!IS_NPC (ch))
   {
d879 21
a899 21
   }
frag_update (killer, ch, 1.0);
   raw_kill (ch, killer);
         
     // forget(killer, ch);
   Forgive_The_Basterd(ch);

/*New to solve memory problem with mobs, as was the mob that killed the pc
   was the ONLY one that forgot him. Now all does using a utility
   Mem_inMemory   Banyal */
//  if (!IS_NPC (ch))
//     for (i = character_list; i; i = i->next)
//     {
//	 if (IS_NPC (i))
//	    if (MEMORY (i))
//	       if (mem_inMemory (i, ch))
//		  forget (i, ch);
//    }

   if (PLR_FLAGGED (ch, PLR_CASTING))
   {
d901 1
a901 1
	 REMOVE_BIT (MOB_FLAGS (ch), MOB_CASTING);
d905 1
a905 1
   }
d915 18
a932 18
   int share;

   /*add level bonus and group bonus */
   /*add group bonus */
   /*sprintf(buf, " base before modifier within group exp %d.\r\n", base);
      send_to_char(buf, ch);
    */ if (GET_LEVEL (ch) < GET_LEVEL (victim))
      base = exp_highlevel_bonus (base, (GET_LEVEL (victim) - GET_LEVEL (ch)));
   base = exp_group_bonus (base);

/*This shows exp people getting turn on at will */
   /* sprintf(buf, " base within group exp %d.\r\n", base);
      send_to_char(buf, ch);
    */
   share = MIN (max_exp_gain (ch), MAX (1, base));

   if (share > 1)
   {
d935 5
a939 5
   }
   if (!IS_NPC (victim))
      share = 1;
   gain_exp (ch, share);
   change_alignment (ch, victim);
d945 15
a959 15
   int tot_members = 0, base, lbase, exp;
   struct char_data *k;
   struct char_data *m;
   struct group_type *f;
   struct mgroup_type *g;
   float tot_percent;
   float leader_percent;

   k = (ch->groupmaster ? ch->groupmaster : ch);


   if (IS_AFFECTED (k, AFF_GROUP))
      ;
   else
   {
d963 3
a965 3
   }
   if (IS_AFFECTED2 (k, AFF2_MGROUP))
   {
d968 1
a968 1
	 tot_members = 1;
d970 2
a971 2
	 if (f->groupee->in_room == ch->in_room)
	    tot_members++;
d973 2
a974 2
      {
	 if (g->mgroupee->in_room == ch->in_room)
d976 1
a976 1
	 for (f = g->mgroupee->groupees; f; f = f->next)
d978 5
a982 5
	       tot_members++;
      }
   }
   else
   {				/*just group count */
d984 1
a984 1
	 tot_members = 1;
d986 16
a1001 16
	 if (f->groupee->in_room == ch->in_room)
	    tot_members++;
   }

   /* round up to the next highest tot_members */
   tot_percent = (float) 100 / tot_members;
   leader_percent = (float) .02 *tot_percent;

   tot_percent = (100 - leader_percent) / tot_members;
   leader_percent = tot_percent + leader_percent;
   if (IS_NPC (victim))
      exp = GET_EXP (victim);
   else
      /*I will give 8 k exp per level for a opp race pkill
         and a 3 k exp per level for a sim race pkill */
   if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
d1003 1
a1003 1
   else
d1005 11
a1015 11

   if (tot_members >= 1)	/*changed line below it had no affect as it was */
/*Mark may need worked on */
      base = MAX (1, ((int) ((GET_EXP (victim) * (float) tot_percent / 100) + 1)));
   else
      base = 0;
   lbase = MAX (1, ((int) ((GET_EXP (victim) * (float) leader_percent / 100) + 1)));


   if (IS_AFFECTED2 (k, AFF2_MGROUP))
   {
d1018 1
a1018 1
	 perform_group_gain (k, lbase, victim);
d1020 2
a1021 2
	 if (f->groupee->in_room == ch->in_room)
	    perform_group_gain (f->groupee, base, victim);
d1023 2
a1024 2
      {
	 if (g->mgroupee->in_room == ch->in_room)
d1026 1
a1026 1
	 for (f = g->mgroupee->groupees; f; f = f->next)
d1028 5
a1032 5
	       perform_group_gain (f->groupee, base, victim);
      }
   }
   else
   {				/*just group count */
d1034 1
a1034 1
	 perform_group_gain (k, lbase, victim);
d1036 5
a1040 5
	 if (f->groupee->in_room == ch->in_room)
	    perform_group_gain (f->groupee, base, victim);
   }


d1049 7
a1055 7
   static char buf[256];
   char *cp;

   cp = buf;

   for (; *str; str++)
   {
d1057 14
a1070 14
      {
	 switch (*(++str))
	 {
	 case 'W':
	    for (; *weapon_plural; *(cp++) = *(weapon_plural++));
	    break;
	 case 'w':
	    for (; *weapon_singular; *(cp++) = *(weapon_singular++));
	    break;
	 default:
	    *(cp++) = '#';
	    break;
	 }
      }
d1072 2
a1073 2
	 *(cp++) = *str;

d1075 3
a1077 3
   }				/* For */

   return (buf);
d1086 140
a1225 140
   char *buf;
   int msgnum;
   int percent = 0;



   static struct dam_weapon_type
   {
      char *to_room;
      char *to_char;
      char *to_victim;
   }
   dam_weapons[] =
   {

      /* use #w for singular (i.e. "slash") and #W for plural (i.e. "slashes") */

      {
	 "$n tries to #w $N, but misses.&0",	/* 0: 0     */
	    "You try to #w $N, but miss.&0",
	    "$n tries to #w you, but misses.&0"
      }
      ,

      {
	 "$n grazes $N as $e #W $M.&0",		/* 1: 1..2  */
	    "You graze $N as you #w $M.&0",
	    "$n grazes you as $e #W you.&0"
      }
      ,

      {
	 "$n barely #W $N.&0",	/* 2: 3..4  */
	    "You barely #w $N.&0",
	    "$n barely #W you.&0"
      }
      ,

      {
	 "$n #W $N.&0",		/* 3: 5..6  */
	    "You #w $N.&0",
	    "$n #W you.&0"
      }
      ,

      {
	 "$n #W $N hard.&0",	/* 4: 7..10  */
	    "You #w $N hard.&0",
	    "$n #W you hard.&0"
      }
      ,

      {
	 "$n #W $N very hard.&0",	/* 5: 11..14  */
	    "You #w $N very hard.&0",
	    "$n #W you very hard.&0"
      }
      ,

      {
	 "$n #W $N extremely hard.&0",	/* 6: 15..19  */
	    "You #w $N extremely hard.&0",
	    "$n #W you extremely hard.&0"
      }
      ,

      {
	 "$n massacres $N to small fragments with $s #w.&0",	/* 7: 19..23 */
	    "You massacre $N to small fragments with your #w.&0",
	    "$n massacres you to small fragments with $s #w.&0"
      }
      ,

      {
	 "$n nearly rip $N in two with $s deadly #w!!&0",	/* 8: > 23   */
	    "You nearly rip $N in two with your deadly #w!!&0",
	    "$n nearly rips you in two with $s  deadly #w!!&0"
      }
   };


   w_type -= TYPE_HIT;		/* Change to base of table with text */
/*
   sprintf(buf2, "dam is:%d", dam);
   act(buf2, TRUE, ch, 0, 0, TO_ROOM);
 */


   if (GET_HIT (victim) > 0)
      percent = (int) (dam * 100 / GET_HIT (victim));
   else
      percent = 100;
   /* percent = MIN(percent, 1); */
   if (percent == 0)
      ;				/*percent += 1; */
   if ((percent <= 1) && (dam >= 20))
      percent += 1;
   if ((percent <= 1) && (dam >= 50))
      percent += 1;


   if (percent == 0)
      msgnum = 0;
   else if (percent <= 2)
      msgnum = 1;
   else if (percent <= 4)
      msgnum = 2;
   else if (percent <= 6)
      msgnum = 3;
   else if (percent <= 10)
      msgnum = 4;
   else if (percent <= 15)
      msgnum = 5;
   else if (percent <= 19)
      msgnum = 6;
   else if (percent <= 35)
      msgnum = 7;
   else if (percent <= 55)
      msgnum = 8;
   else
      msgnum = 8;

   /* damage message to onlookers */
   buf = replace_string (dam_weapons[msgnum].to_room,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_NOTVICT);

   /* damage message to damager */
   send_to_char (CCNRM (ch, C_CMP), ch);
   buf = replace_string (dam_weapons[msgnum].to_char,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_CHAR);
   send_to_char (CCNRM (ch, C_CMP), ch);

   /* damage message to damagee */
   send_to_char (CCNRM (victim, C_CMP), victim);
   buf = replace_string (dam_weapons[msgnum].to_victim,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
   act (buf, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
   send_to_char (CCNRM (victim, C_CMP), victim);
d1237 8
a1244 8
   int i, j, nr;
   struct message_type *msg;

   struct obj_data *weap = GET_EQ (ch, WEAR_WIELD);
   struct obj_data *weap2 = GET_EQ (ch, WEAR_WIELD2);

   for (i = 0; i < MAX_MESSAGES; i++)
   {
d1246 3
a1248 3
      {
	 nr = dice (1, fight_messages[i].number_of_attacks);
	 for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
d1250 2
a1251 10

	 if (!IS_NPC (vict) && (GET_LEVEL (vict) >= LVL_IMMORT))
	 {
	    act (msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	    act (msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
	    act (msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	 }
	 else if (dam != 0)
	 {
	    if (GET_POS (vict) == POS_DEAD)
d1253 59
a1311 51
	       send_to_char (CCNRM (ch, C_CMP), ch);
	       act (msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	       send_to_char (CCNRM (ch, C_CMP), ch);

	       send_to_char (CCNRM (vict, C_CMP), vict);
	       act (msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	       send_to_char (CCNRM (vict, C_CMP), vict);

	       act (msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	    else
	    {
	       send_to_char (CCNRM (ch, C_CMP), ch);
	       if (attacktype == SKILL_2BACK)
		  act (msg->hit_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
	       else
		  act (msg->hit_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	       send_to_char (CCNRM (ch, C_CMP), ch);

	       send_to_char (CCNRM (vict, C_CMP), vict);
	       if (attacktype == SKILL_2BACK)
		  act (msg->hit_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
	       else
		  act (msg->hit_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	       send_to_char (CCNRM (vict, C_CMP), vict);

	       act (msg->hit_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	    }
	 }
	 else if (ch != vict)
	 {			/* Dam == 0 */
	    send_to_char (CCNRM (ch, C_CMP), ch);
	    if (attacktype == SKILL_2BACK)
	       act (msg->miss_msg.attacker_msg, FALSE, ch, weap2, vict, TO_CHAR);
	    else
	       act (msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	    send_to_char (CCNRM (ch, C_CMP), ch);

	    send_to_char (CCNRM (vict, C_CMP), vict);
	    if (attacktype == SKILL_2BACK)
	       act (msg->miss_msg.victim_msg, FALSE, ch, weap2, vict, TO_VICT | TO_SLEEP);
	    else
	       act (msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	    send_to_char (CCNRM (vict, C_CMP), vict);

	    act (msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	 }
	 return 1;
      }
   }
   return 0;
d1316 1
a1316 1
	int attacktype)
d1318 12
a1329 12
   int exp;
   struct obj_data *wielded;
   struct obj_data *hwielded;
   struct obj_data *vwielded;
   struct obj_data *vhwielded;
   wielded = GET_EQ (ch, WEAR_WIELD);
   hwielded = GET_EQ (ch, WEAR_2HWIELD);
   vwielded = GET_EQ (victim, WEAR_WIELD);
   vhwielded = GET_EQ (victim, WEAR_2HWIELD);

   if (GET_POS (victim) <= POS_DEAD)
   {
d1332 5
a1336 5
   }

   /* peaceful rooms */
   if (ch != victim && ROOM_FLAGGED (ch->in_room, ROOM_PEACEFUL))
   {
d1339 7
a1345 7
   }



   /* Checks for Proc Rooms */
   if (ch->in_room == real_room (30761))
   {
d1347 3
a1349 3
      {
	 GET_HIT (ch) = 1;
      }
d1353 21
a1373 21
   }


   /* shopkeeper protection */
/*temp disable due to crashing - proky */
/*Disabled again! please do not un comment this Banyal*/ 
/*
   if (!ok_damage_shopkeeper (ch, victim))
      return;
*/
/*reduces damage for all things bar spells */
   if (!IS_NPC (ch) && !IS_NPC (victim))
      if (attacktype > MAX_SPELLS)
	 /* dam >>= 1; */
	 /* new to lower a little more Banyal */
	 dam = dam / 3;
   /* You can't damage an immortal! */
   if (!IS_NPC (victim) && (GET_LEVEL (victim) >= LVL_IMMORT))
      dam = 0;
   if (victim != ch)
   {
d1375 2
a1376 2
      {
	 if (attacktype >= MAX_SPELLS)
d1378 12
a1389 12
	       set_fighting (ch, victim);

	 if (IS_NPC (ch) && IS_NPC (victim) && victim->master &&
	     (number (0, 100) == 0) && IS_AFFECTED (victim, AFF_CHARM) &&
	     (victim->master->in_room == ch->in_room))
	 {
	    if (FIGHTING (ch))
	       stop_fighting (ch);
	    hit (ch, victim->master, TYPE_UNDEFINED);
	    return;
	 }
      }
d1391 4
a1394 4
      {
	 if (attacktype >= MAX_SPELLS ||
	     (!PRF_FLAGGED (victim, PRF_PASSIVE) && attacktype < MAX_SPELLS)
	     || (IS_NPC (victim) && attacktype < MAX_SPELLS))
d1396 1
a1396 1
      }
d1399 20
a1418 14
	 remember (victim, ch);

   }
   if (victim->master == ch)
      stop_follower (victim);

   if (IS_AFFECTED (ch, AFF_INVISIBLE | AFF_HIDE))
      appear (ch);

/* Pets and charmes act as pc's*/

 if(IS_AFFECTED (ch, AFF_CHARM))
   dam >>= 1;
if(IS_NPC (ch) && MOB_FLAGGED (ch, MOB_PET))
d1420 3
a1422 9

   if (IS_AFFECTED (victim, AFF_SANCTUARY))
      dam >>= 1;		/* 1/2 damage when sanctuary */

   if (IS_AFFECTED (victim, AFF_STONE_SKIN))
      dam >>= 1;

   if (IS_AFFECTED2 (victim, AFF2_MINOR_PARALYSIS))
   {
d1429 1
a1429 1

d1432 6
a1437 6
   }
check_justice (ch, victim);
if (ch->desc && ch->desc->original)        
  check_justice(ch->desc->original, victim);
   if (!pk_allowed)
   {
d1439 2
a1440 2
     //  check_justice (ch, victim);

d1442 2
a1443 2
	 dam = 0;
   }
d1445 8
a1452 23
   dam = MAX (MIN (dam, 1000), 0);
   alter_hit (victim, dam, 2);
   update_pos (victim);

if(!wielded && !hwielded && !vhwielded && !vwielded) {
 if (IS_AFFECTED3(ch, AFF3_VAMP_TOUCH)) {
   if(IS_NPC(ch))
   alter_hit (ch,( -1 * dam / 2), 2);
   else
   alter_hit (ch,(-1 * dam), 2);
 }
if (GET_SKILL(ch, SKILL_VAMP_TOUCH) > 0)
 if(!IS_NPC(ch)) {
 if((GET_SKILL(ch, SKILL_VAMP_TOUCH)) > (number(0, 101)))
   alter_hit(ch, ( -1 * dam / 2), 2);
  if(number(0, 2))
  improve_skill(ch, SKILL_VAMP_TOUCH);
  }
}

   if (ch != victim)
      if (IS_NPC (ch));			
/*  gain_exp(ch, ((GET_LEVEL(victim)/2) * (dam/4))); */
d1454 8
a1461 5
      {
	 if ((GET_LEVEL (ch) - GET_LEVEL (victim)) > 10)
	    gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (30, (50 - GET_LEVEL (ch))))));
	 else
	    gain_exp (ch, (GET_LEVEL (victim) * (int) ((float) dam / MAX (15, (50 - GET_LEVEL (ch))))));
d1463 28
a1490 16

   /*
    * skill_message sends a message from the messages file in lib/misc.
    * dam_message just sends a generic "You hit $n extremely hard.".
    * skill_message is preferable to dam_message because it is more
    * descriptive.
    * 
    * If we are _not_ attacking with a weapon (i.e. a spell), always use
    * skill_message. If we are attacking with a weapon: If this is a miss or a
    * death blow, send a skill_message if one exists; if not, default to a
    * dam_message. Otherwise, always send a dam_message.
    */
   if (!IS_WEAPON (attacktype))
      skill_message (dam, ch, victim, attacktype);
   else
   {
d1492 2
a1493 2
      {
	 if (!skill_message (dam, ch, victim, attacktype))
d1495 1
a1495 21
      }
      else
	 dam_message (dam, ch, victim, attacktype);
   }
// stops these shileds from hurting casters from spells casted -Banyal
if (attacktype > MAX_SPELLS) {
   if (IS_AFFECTED2 (victim, AFF2_FIRESHIELD))
   {
      if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	 act ("&1&bThe globe around your body absorbs the burning flames!&0", FALSE, ch, 0, 0, TO_CHAR);
      else
      {
	 act ("&1Your limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_CHAR);
	 act ("&1$n&0&1's limbs are seared by your shield of flames.&0", FALSE, ch, 0, victim, TO_VICT);
	 act ("&1$n&0&1's limbs are seared by $N&0&1's shield of flames.&0", FALSE, ch, 0, victim, TO_NOTVICT);
      }
   }
   if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD))
   {
      if (IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
	 act ("&4&bThe globe around your body absorbs the killing ice!&0", FALSE, ch, 0, 0, TO_CHAR);
d1497 21
a1517 1
      {
d1521 1
d1523 1
a1523 4
   }
   if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
   {
      if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
d1525 19
a1543 17
	 act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	 act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	 act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      }
      if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
      {
	 act ("&7&b$n's soul suffers upon contact with your aura.&0", TRUE, ch, 0, victim, TO_VICT);
	 act ("&7&bYour soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_CHAR);
	 act ("&7&b$n's soul suffers upon contact with $N's aura.&0", TRUE, ch, 0, victim, TO_NOTVICT);
      }
   }
} // end attacktype check

   /* Use send_to_char -- act() doesn't send message if you are DEAD. */
   switch (GET_POS (victim))
   {
   case POS_MORTALLYW:
d1547 1
a1547 1
   case POS_INCAP:
d1551 1
a1551 1
   case POS_STUNNED:
d1555 1
a1555 1
   case POS_DEAD:
d1559 2
a1560 2

   default:			/* >= POSITION SLEEPING */
d1562 2
a1563 2
	 act ("That really did HURT!", FALSE, victim, 0, 0, TO_CHAR);

d1565 14
a1578 14
      {
	 sprintf (buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		  CCRED (victim, C_SPR), CCNRM (victim, C_SPR));
	 send_to_char (buf2, victim);
	 if (MOB_FLAGGED (victim, MOB_WIMPY) && (ch != victim))
	 {
	    do_flee (victim, "", 0, 0);
	    if (FIGHTING (ch))
	       stop_fighting (ch);
	 }




d1582 2
a1583 2
      {
	 send_to_char ("You attempt to flee!\r\n", victim);
d1586 2
a1587 2
	    stop_fighting (ch);

d1590 8
a1597 8
   }

   if (!AWAKE (victim))
      if (FIGHTING (victim))
	 stop_fighting (victim);

   if (GET_POS (victim) == POS_DEAD)
   {
d1599 1
a1599 1
	 if (IS_AFFECTED (ch, AFF_GROUP))
d1601 2
a1602 2
	 else
	 {
d1606 1
a1606 1
	       exp += MAX (0, (exp * MIN (2, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);
d1608 1
a1608 1
	       exp += MAX (0, (exp * MIN (3, (GET_LEVEL (victim) - GET_LEVEL (ch)))) >> 3);
d1612 1
a1612 8
	       exp = GET_EXP (victim);
	    else
	       /*I will give 10 k exp per level for a opp race pkill
	          and a 3 k exp per level for a sim race pkill */
	    if (GET_RACE_ALIGN (victim) != GET_RACE_ALIGN (ch))
	       /* This was being badly abused, ask me Banyal */
	       /* exp = GET_LEVEL(victim) * 7000; */
	       exp = 70;
d1614 5
a1618 1
	       /*  exp = GET_LEVEL(victim) * 2000; */
d1620 3
d1626 4
a1629 4
	    {
	       sprintf (buf2, "You receive your share of experience.\r\n");
	       send_to_char (buf2, ch);
	    }
d1631 1
a1631 1
	       send_to_char ("You receive your share of experience.\r\n", ch);
d1633 3
a1635 3
	       exp);
	       send_to_char(buf, ch);
	     */
d1637 1
a1637 1
	       exp = exp_highlevel_bonus (exp, (GET_LEVEL (victim) - GET_LEVEL (ch)));
d1639 3
a1641 3
	       %d.\r\n", exp);
	       send_to_char(buf, ch);
	     */ gain_exp (ch, exp);
d1643 1
a1643 1
	 }
d1645 9
a1653 9
      {
	 sprintf (buf2, "%s killed by %s at %s", GET_NAME (victim), GET_NAME (ch),
		  world[victim->in_room].name);
	 mudlog (buf2, BRF, LVL_IMMORT, TRUE);
	 if (MOB_FLAGGED(ch, MOB_MEMORY))
	 //   forget(ch, victim); 
        Forgive_The_Basterd(victim);
      }
    Forgive_The_Basterd(ch);
d1655 1
a1655 1
   }
d1663 17
a1679 17
   int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vw_type= 0,
     vdam = 0;
   struct obj_data *wielded;
   struct obj_data *hwielded;
   struct obj_data *vwielded;
   struct obj_data *vhwielded;
   extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
   extern struct str_app_type str_app[];
   extern struct dex_app_type dex_app[];
   int backstab_mult (int level);

   bool RIPOSTT = FALSE;
   bool DODGE = FALSE;
   bool PARRY = FALSE;

   if(event_target_valid(victim) == 0 )
   {
d1681 1
a1681 1
	 stop_fighting (ch);
d1683 19
a1701 19
   }

   if(event_target_valid(ch) == 0 )
   {
	 stop_fighting (victim);
         return;
   }
     
   wielded = GET_EQ (ch, WEAR_WIELD);
   hwielded = GET_EQ (ch, WEAR_2HWIELD);
   vwielded = GET_EQ (victim, WEAR_WIELD);
   vhwielded = GET_EQ (victim, WEAR_2HWIELD);

   /* check if the character has a fight trigger */
   fight_mtrigger (ch);


   if (ch->in_room != victim->in_room)
   {
d1703 1
a1703 1
	 stop_fighting (ch);
d1705 11
a1715 11
   }

if((FIGHTING(ch) != victim) &&
 ((IS_AFFECTED (ch, AFF_BLIND)) || (affected_by_spell(ch, SPELL_BLINDNESS)))) {
send_to_char("You cant see a damn thing\r\n", ch);
return;
} 


   if (GET_SKILL (victim, SKILL_DODGE))
   {
d1717 11
a1727 11
      {
	 hurm = number (35, 131);
	 hurm1 = number (20, 50);
	 hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	 hurm += GET_HITROLL (ch);
	 hurm1 += dex_app[GET_DEX (victim)].defensive;
         if(IS_NPC(victim))
	 hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
         else
         hurm1 += GET_SKILL (victim, SKILL_DODGE);
	 if (number (1, 10) < 5)
d1729 1
a1729 1
	 if (hurm1 > hurm)
d1731 6
a1736 6
      }
   }


   if (GET_SKILL (victim, SKILL_PARRY))
   {
d1738 2
a1739 12
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (45, 141);
	    hurm1 = number (20, 60);
	    hurm += GET_HITROLL (ch);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_PARRY);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_PARRY);
	    if (hurm1 > hurm)
d1741 18
a1758 8
	       PARRY = TRUE;
	    }
	 }
      }
   }

   if (GET_SKILL (victim, SKILL_RIPOST))
   {
d1760 21
a1780 25
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (55, 200);
	    hurm1 = number (20, 50);
	    hurm += GET_HITROLL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .85;
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_RIPOST);
	    if (hurm1 > hurm)
	    {
	       RIPOSTT = TRUE;
	       vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
	       vdam += GET_DAMROLL (victim);

	       if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
	       else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
	       else
	       {
		  if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
		     vw_type = victim->mob_specials.attack_type + TYPE_HIT;
d1782 10
a1791 12
		     vw_type = TYPE_HIT;
	       }
	       if (vwielded)
		  vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
	       else if (vhwielded)
		  vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
	       else
	       {
		  if (IS_NPC (victim))
		  {
		     vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
		  }
d1793 25
a1817 19
		     vdam += number (0, 2);
	       }
	       if (GET_POS (ch) < POS_FIGHTING)
		  vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;
	       vdam = MAX (1, 70);
	    }
	 }
      }
   }

   mprog_hitprcnt_trigger (ch, FIGHTING (ch));
   mprog_fight_trigger (ch, FIGHTING (ch));

   if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
   else if (hwielded && GET_OBJ_TYPE (hwielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (hwielded, 3) + TYPE_HIT;
   else
   {
d1819 1
a1819 1
	 w_type = ch->mob_specials.attack_type + TYPE_HIT;
d1821 29
a1849 29
	 w_type = TYPE_HIT;
   }



   /* Calculate the raw armor including magic armor.  Lower AC is better. */

   if (!IS_NPC (ch))
      calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
   else				/* THAC0 for monsters is set in the HitRoll */
      calc_thaco = 20;

   calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
   calc_thaco -= GET_HITROLL (ch);
   calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
   calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
   diceroll = number (1, 29);

   victim_ac = GET_AC (victim) / 15;

   if (AWAKE (victim))
      victim_ac += dex_app[GET_DEX (victim)].defensive;

   victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */

   /* decide whether this is a hit or a miss */
   if ((((diceroll < 20) && AWAKE (victim)) &&
	((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
   {
d1851 1
a1851 1
	 damage (ch, victim, 0, SKILL_BACKSTAB);
d1853 4
a1856 4
	 damage (ch, victim, 0, w_type);
   }
   else
   {
d1860 1
a1860 1

d1862 2
a1863 2
      {
	 if (!IS_NPC (ch))
d1865 1
a1865 1
	 else
d1867 2
a1868 2
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
d1870 2
a1871 2
      {
	 if (!IS_NPC (ch))
d1873 1
a1873 1
	 else
d1875 2
a1876 2
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
d1878 6
a1883 6
      {
	 if (IS_NPC (ch))
	 {
	    dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	 }
	 else
d1885 2
a1886 2
      }

d1888 1
a1888 1
	 dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;	/*mark */
d1895 1
a1895 1

d1897 1
a1897 1

d1899 4
a1902 4
      {
	 dam *= backstab_mult (GET_LEVEL (ch));
	 damage (ch, victim, dam, SKILL_BACKSTAB);
      }
d1904 2
a1905 33
      {
	 if (RIPOSTT)
	 {
	    act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    damage (victim, ch, vdam, vw_type);
	 }
	 else if (PARRY)
	 {
	    act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_PARRY);
	    if (!FIGHTING (ch))
	       set_fighting (ch, victim);
	    if (!FIGHTING (victim))
	       set_fighting (victim, ch);
	 }
	 else if (DODGE)
	 {
	    act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_DODGE);
	    if (!FIGHTING (ch))
	       set_fighting (ch, victim);
	    if (!FIGHTING (victim))
	       set_fighting (victim, ch);
	 }
	 else
	 {
	    if (dam > 0)
d1907 62
a1968 27
	       /*ok here we hit victem so check for stone skin */
	       if (IS_AFFECTED (victim, AFF_STONE_SKIN))
	       {
		  if (number (0, 10) <= 9)
		  {
		     decrease_modifier (victim);
		     dam = number (0, 3);
		  }
	       }
	       if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
	       {
		  if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
		  if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
	       }
	       if (IS_AFFECTED2 (victim, AFF2_COLDSHIELD | AFF2_FIRESHIELD))
	       {
		  if (!IS_AFFECTED2 (ch, AFF2_MAJOR_GLOBE))
		     GET_HIT (ch) -= (int) (dam / 3);
	       }
d1970 2
a1971 6
	    if (victim)
	       hitprcnt_mtrigger (victim);
	    damage (ch, victim, dam, w_type);
	 }
      }

d1973 2
a1974 2

   }
d1980 17
a1996 17
   struct obj_data *wielded = GET_EQ (ch, WEAR_WIELD2);
   struct obj_data *vwielded = GET_EQ (victim, WEAR_WIELD);
   struct obj_data *vhwielded = GET_EQ (victim, WEAR_2HWIELD);
   int w_type, victim_ac, calc_thaco, dam, diceroll, hurm, hurm1, vdam = 0,
     vw_type = 0;
   bool RIPOSTT = FALSE;
   bool DODGE = FALSE;
   bool PARRY = FALSE;

   extern int thaco[NUM_CLASSES][LVL_IMPL + 1];
   extern struct str_app_type str_app[];
   extern struct dex_app_type dex_app[];

   int backstab_mult (int level);

   if (ch->in_room != victim->in_room)
   {
d1998 1
a1998 1
	 stop_fighting (ch);
d2000 5
a2004 5
   }


   if (GET_SKILL (victim, SKILL_DODGE))
   {
d2006 11
a2016 11
      {
	 hurm = number (55, 141);
	 hurm1 = number (20, 40);
	 hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	 hurm += GET_HITROLL (ch);
	 hurm1 += dex_app[GET_DEX (victim)].defensive;
         if(IS_NPC(victim))
         hurm1 += GET_SKILL (victim, SKILL_DODGE) * .60;
         else
	 hurm1 += GET_SKILL (victim, SKILL_DODGE);
	 if (number (1, 10) < 5)
d2018 9
a2026 9
	 if (hurm1 > hurm)
	 {
	    DODGE = TRUE;
	 }
      }
   }
/* Parry dodge rip harder on secound hand */
   if (GET_SKILL (victim, SKILL_PARRY))
   {
d2028 2
a2029 12
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (65, 141);
	    hurm1 = number (15, 40);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm += GET_HITROLL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_PARRY);
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_PARRY);
	    if (hurm1 > hurm)
d2031 18
a2048 8
	       PARRY = TRUE;
	    }
	 }
      }
   }

   if (GET_SKILL (victim, SKILL_RIPOST))
   {
d2050 20
a2069 24
      {
	 if (GET_POS (victim) > POS_SITTING)
	 {
	    hurm = number (90, 400);
	    hurm1 = number (15, 40);
	    hurm += GET_HITROLL (ch);
	    hurm1 += GET_LEVEL (victim) - GET_LEVEL (ch);
	    hurm1 += dex_app[GET_DEX (victim)].defensive;
	    hurm1 += GET_SKILL (victim, SKILL_RIPOST) * .8;
	    if (number (1, 10) < 5)
	       improve_skill (victim, SKILL_RIPOST);
	    if (hurm1 > hurm)
	    {
	       RIPOSTT = TRUE;
	       vdam = str_app[STRENGTH_APPLY_INDEX (victim)].todam;
	       vdam += GET_DAMROLL (victim);
	       if (vwielded && GET_OBJ_TYPE (vwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vwielded, 3) + TYPE_HIT;
	       else if (vhwielded && GET_OBJ_TYPE (vhwielded) == ITEM_WEAPON)
		  vw_type = GET_OBJ_VAL (vhwielded, 3) + TYPE_HIT;
	       else
	       {
		  if (IS_NPC (victim) && (victim->mob_specials.attack_type != 0))
		     vw_type = victim->mob_specials.attack_type + TYPE_HIT;
d2071 11
a2081 13
		     vw_type = TYPE_HIT;
	       }

	       if (vwielded)
		  vdam += dice (GET_OBJ_VAL (vwielded, 1), GET_OBJ_VAL (vwielded, 2));
	       else if (vhwielded)
		  vdam += dice (GET_OBJ_VAL (vhwielded, 1), GET_OBJ_VAL (vhwielded, 2));
	       else
	       {
		  if (IS_NPC (victim))
		  {
		     vdam += dice (victim->mob_specials.damnodice, victim->mob_specials.damsizedice);
		  }
d2083 25
a2107 19
		     vdam += number (0, 2);
	       }

	       if (GET_POS (ch) < POS_FIGHTING)
		  vdam *= 1 + (POS_FIGHTING - GET_POS (ch)) / 3;

	       vdam = MAX (1, 70);
	    }
	 }
      }
   }

   mprog_hitprcnt_trigger (ch, FIGHTING (ch));
   mprog_fight_trigger (ch, FIGHTING (ch));

   if (wielded && GET_OBJ_TYPE (wielded) == ITEM_WEAPON)
      w_type = GET_OBJ_VAL (wielded, 3) + TYPE_HIT;
   else
   {
d2109 1
a2109 1
	 w_type = ch->mob_specials.attack_type + TYPE_HIT;
d2111 29
a2139 29
	 w_type = TYPE_HIT;
   }



   /* Calculate the raw armor including magic armor.  Lower AC is better. */

   if (!IS_NPC (ch))
      calc_thaco = thaco[(int) GET_CLASS (ch)][(int) GET_LEVEL (ch)];
   else				/* THAC0 for monsters is set in the HitRoll */
      calc_thaco = 20;

   calc_thaco -= str_app[STRENGTH_APPLY_INDEX (ch)].tohit;
   calc_thaco -= GET_HITROLL (ch);
   calc_thaco -= (int) ((GET_INT (ch) - 13) / 1.5);	/* Intelligence helps! */
   calc_thaco -= (int) ((GET_WIS (ch) - 13) / 1.5);	/* So does wisdom */
   diceroll = number (1, 25);

   victim_ac = GET_AC (victim) / 15;

   if (AWAKE (victim))
      victim_ac += dex_app[GET_DEX (victim)].defensive;

   victim_ac = MAX (-10, victim_ac);	/* -10 is lowest */

   /* decide whether this is a hit or a miss */
   if ((((diceroll < 20) && AWAKE (victim)) &&
	((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
   {
d2141 1
a2141 1
	 damage (ch, victim, 0, SKILL_2BACK);
d2143 4
a2146 4
	 damage (ch, victim, 0, w_type);
   }
   else
   {
d2150 1
a2150 1

d2152 2
a2153 2
      {
	 if (!IS_NPC (ch))
d2155 1
a2155 1
	 else
d2157 2
a2158 2
	       dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      }
d2160 6
a2165 6
      {
	 if (IS_NPC (ch))
	 {
	    dam += dice (ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
	 }
	 else
d2167 2
a2168 2
      }				/*Banyal add class mods here */

d2170 1
a2170 1
	 dam *= 1 + (POS_FIGHTING - GET_POS (victim)) / 3;
d2177 1
a2177 1

d2179 1
a2179 1

d2181 4
a2184 4
      {
	 dam *= backstab_mult (GET_LEVEL (ch));
	 damage (ch, victim, dam, SKILL_2BACK);
      }
d2186 2
a2187 26
      {
	 if (RIPOSTT)
	 {
	    act ("&8You block $n's attack, and strike back!&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&8$N blocks your attack, and strikes back!&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N blocks $n's attack, and strikes back at $m!&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    damage (victim, ch, vdam, vw_type);
	    improve_skill (victim, SKILL_RIPOST);
	 }
	 else if (PARRY)
	 {
	    act ("&7You parry $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N parry your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N parry $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_PARRY);
	 }
	 else if (DODGE)
	 {
	    act ("&7You dodge $n's attack.&0", TRUE, ch, 0, victim, TO_VICT);
	    act ("&7$N dodges your attack.&0", TRUE, ch, 0, victim, TO_CHAR);
	    act ("&7$N dodges $n's attack.&0", TRUE, ch, 0, victim, TO_NOTVICT);
	    improve_skill (victim, SKILL_DODGE);
	 }
	 else
	 {
	    if (dam > 0)
d2189 49
a2237 23
	       /*ok here we hit victem so check for stone skin */
	       if (IS_AFFECTED (victim, AFF_STONE_SKIN))
	       {
		  if (number (0, 10) <= 9)
		  {
		     decrease_modifier (victim);
		     dam = number (0, 3);
		  }
	       }
	       else if (IS_AFFECTED2 (victim, AFF2_SOULSHIELD))
	       {
		  if (GET_ALIGNMENT (ch) >= 500 && GET_ALIGNMENT (victim) <= -500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
		  if (GET_ALIGNMENT (ch) <= -500 && GET_ALIGNMENT (victim) >= 500)
		  {
		     dam = (int) (3 * dam / 4);
		     GET_HIT (ch) -= (int) (dam / 4);
		  }
	       }

d2239 2
a2240 4
	    damage (ch, victim, dam, w_type);
	 }
      }
   }
d2247 18
a2264 18
   extern struct index_data *obj_index;
   int (*name) (struct char_data * ch, void *me, int cmd, char *argument);

   SPECIAL (blind_weapon);
   SPECIAL (fireball_weapon);
   SPECIAL (lightning_weapon);
   SPECIAL (vampiric_weapon);
   SPECIAL (fullharm_weapon);
   SPECIAL (curse_weapon);
   SPECIAL (holyw_weapon);

   name = obj_index[GET_OBJ_RNUM (wpn)].func;
   if (name != blind_weapon && name != fireball_weapon &&
       name != curse_weapon && name != fullharm_weapon &&
       name != vampiric_weapon && name != lightning_weapon &&
       name != holyw_weapon)
      return 0;
   return (name) (ch, wpn, 0, "");
d2273 10
a2282 10
   struct char_data *ch;
   struct char_data *tch;
   struct char_data *vict;
   struct obj_data *wpn;
   extern struct index_data *mob_index;
   int prob, hurm, hurm2;
   bool tmp_flag;

   for (ch = combat_list; ch; ch = next_combat_list)
   {
d2285 4
a2288 4
      {
	 stop_fighting (ch);
	 continue;
      }
d2292 2
a2293 2
	 --ch->char_specials.action_delays[ACT_DELAY_DISARM];

d2295 7
a2301 7
      {
	 send_to_char ("You remain paralyzed and can't do a thing to defend yourself..\r\n",
		       ch);
	 act ("$n strains to respond to $N's attack, but the paralysis is too overpowering.",
	      FALSE, ch, 0, FIGHTING (ch), TO_ROOM);
	 continue;
      }
d2303 5
a2307 5
      {
	 act ("You couldn't budge a feather in your present condition.", FALSE, ch, 0, 0, TO_CHAR);
	 act ("$n is too preoccupied with $s nervous system problem to fight.", FALSE, ch, 0, 0, TO_ROOM);
	 continue;
      }
d2309 1
a2309 1

d2311 1
a2311 1
	 continue;
d2313 3
a2315 3
	 continue;


d2318 21
a2338 21
      {
	 hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	 if (IS_AFFECTED (ch, AFF_HASTE) && FIGHTING (ch))
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	    }
	 }
	 if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
	    }
	 }
      }


d2340 2
a2341 2
	 (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");

d2343 2
a2344 2
	 if (GET_SKILL (ch, SKILL_DUAL_WIELD) && FIGHTING (ch))
	 {
d2347 4
a2350 4
	       if (FIGHTING (tch) == ch && !IS_NPC (tch))
		  if (vict == NULL || GET_HIT (tch) < GET_HIT (vict))
		     vict = tch;

d2352 16
a2367 16
	    {

	       if (!IS_AFFECTED (ch, AFF_BLIND))
                if (!affected_by_spell (ch, SPELL_BLINDNESS))
               if (!affected_by_spell (ch, SPELL_SMOKE))
              if (CAN_SEE(ch, vict))
		  if (!number (0, (MAX (10, (30 - GET_LEVEL (ch))))))
		  {
		     stop_fighting (ch);
		     act ("$n switches to $N", FALSE, ch, 0, vict, TO_ROOM);
		     hit (ch, vict, TYPE_UNDEFINED);
		  }
	    }
	 }


d2369 10
a2378 10
      {

	 struct obj_data *wielded2 = GET_EQ (ch, WEAR_WIELD2);

	 if (wielded2)
	 {
	    prob = 0;
	    prob = GET_SKILL (ch, SKILL_DUAL_WIELD);
	    if (GET_LEVEL (ch) < 15)
	       if (number (0, 2))
d2380 38
a2417 19
	    if (number (1, 101) < prob)
	    {
	       if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	       {
		  hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		  improve_skill (ch, SKILL_DUAL_WIELD);
	       }
	       if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		  (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
	       if (IS_AFFECTED (ch, AFF_BLUR) && FIGHTING (ch))
	       {
		  hurm = 0;
		  hurm = number (1, 100);
		  hurm2 = 0;
		  hurm2 = number (1, 101);
		  if (hurm < prob)
		  {
		     if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
		     {
d2419 5
a2423 4
			improve_skill (ch, SKILL_DUAL_WIELD);
		     }
		  }
	       }
d2425 2
a2426 22

	    if (GET_SKILL (ch, SKILL_DOUBLE_ATTACK) && FIGHTING (ch))
	    {
	       prob = 0;
	       prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);
	       if (GET_LEVEL (ch) < 15)
		  if (number (0, 2))
		     prob = prob - 10;

	       if (number (1, 101) < prob)
	       {
		  if (!(wpn = GET_EQ (ch, WEAR_WIELD2)) || GET_OBJ_TYPE (wpn) != ITEM_WEAPON ||
		      !weapon_special (wpn, ch))
		     hit2 (ch, FIGHTING (ch), TYPE_UNDEFINED);
		  if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
		     (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
		  improve_skill (ch, SKILL_DUAL_WIELD);
	       }
	    }
	 }
      }

d2428 5
a2432 5
      {
	 prob = 0;
	 prob = GET_SKILL (ch, SKILL_DOUBLE_ATTACK);

	 if (GET_LEVEL (ch) < 15)
d2434 14
a2447 14
	       prob = prob - 10;

	 if (number (1, 101) < prob)
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);

	    if (MOB_FLAGGED (ch, MOB_SPEC) && mob_index[GET_MOB_RNUM (ch)].func != NULL)
	       (mob_index[GET_MOB_RNUM (ch)].func) (ch, ch, 0, "");
	    improve_skill (ch, SKILL_DOUBLE_ATTACK);
	 }
      }

d2449 10
a2458 9
      {
	 prob = 0;
	 prob = number (1, 101);
	 if ((number (1, 101) - GET_LEVEL (ch) + 10) < prob)
	 {
	    if ((!(wpn = GET_EQ (ch, WEAR_WIELD)) && !(wpn = GET_EQ (ch, WEAR_2HWIELD))) ||
	     GET_OBJ_TYPE (wpn) != ITEM_WEAPON || !weapon_special (wpn, ch))
	    {
	       hit (ch, FIGHTING (ch), TYPE_UNDEFINED);
d2460 2
a2461 3
	 }
      }

d2463 3
a2465 3
	 continue;

   }
d2474 12
a2485 14
   extern char *spells[];
   int percent = GET_ISKILL (ch, skill);
   int newpercent;
   int maxpercent;
   char skillbuf[MAX_STRING_LENGTH];

   if (number (1, 140) > GET_WIS (ch) + GET_INT (ch))
      return;
   if (skill == SKILL_DOUBLE_ATTACK ||
       SKILL_DUAL_WIELD || SKILL_PARRY ||
       SKILL_DODGE || SKILL_RIPOST)
      if (number (15, 45) > GET_WIS (ch) + GET_INT (ch))
	 return;
   if (percent >= 999 || percent <= 0)
d2487 6
a2492 4
   if (skill == SKILL_DOUBLE_ATTACK ||
       SKILL_DUAL_WIELD || SKILL_PARRY ||
       SKILL_DODGE || SKILL_RIPOST || SKILL_VAMP_TOUCH)
   {
d2494 3
a2496 3
   }
   else
   {
d2498 5
a2502 5
   }
   percent += newpercent;
   maxpercent = return_max_skill (ch, skill);
   if (percent > maxpercent)
   {
d2505 5
a2509 5
   }
   percent = MIN (percent, 1000);
   SET_SKILL (ch, skill, percent);
   sprintf (skillbuf, "&8You feel your skill in %s improving.\r\n&0", spells[skill]);
   send_to_char (skillbuf, ch);
d2518 7
a2524 7
   int number;			/* this parts number */
   char name[40];		/* names of this part */
   int nname;			/* some parts you couldn't trace to an owner */
   char sdesc[128];		/* short desc: that of inventory  */
   char rdesc[128];		/* room desc: when on ground */
   int take;			/* some body parts don't transfer well */
   char actout[128];		/* what people in room see upon death, using
d2526 1
a2526 1
   char actkil[128];		/* what the killer sees upon dismemberment, using
d2532 41
a2572 41
   {0, "eyeball eye", 1, "the eye of %s", "The eyeball of %s is lying here.",
    1, "$n's attack knocks an eye out of $N!",
    "Your attack knocks an eye out of $N!"},
   {1, "arm", 1, "one of %s's arms", "%s'arm is lying here on the ground.",
    1, "$n's removes $N's arm!",
    "You remove $N's arm!"},
   {2, "right leg", 1, "%s's right leg", "%s's right leg is here.",
    1, "$N gracefully cuts his leg off! $n chortles merrily!",
    "You watch in awe as $N cuts his leg off!"},
{3, "left leg", 1, "the left leg of %s", "The left leg of %s is lying here.",
 1, "$n's screams and strikes $N leg off at the hip!",
 "With a scream of rage, you strike $N's leg off!"},
{4, "head", 1, "%s's ugly head", "%s's head is lying here, staring at you.",
 1, "$n severs $N's in a move composed of speed and grace!",
 "With speed and grace, you sever $N's head!"},
   {5, "thumb", 1, "%s's thumb", "One of %s's thumbs is lying here.",
    1, "$n's attack severs a thumb from $N!",
    "Your attack severs a thumb from $N!"},
   {6, "finger", 1, "%s's finger", "One of %s fingers is lying here.",
    1, "$n's attack severs a finger from $N!",
    "Your attack severs a finger from $N!"},
   {7, "heart", 1, "the once beating heart of %s",
    "%s's once beating heart lies here.",
    1, "$n's uses pure strength to eviscirate $N!",
    "Your depend on your fierce strength, and eviscerate $N!"},
   {8, "spine", 1, "the spine of %s", "The spine of %s is lying here.",
    1, "$n's attack shatters $N's spine!",
    "Your attack shatters $N's spine!"},
   {9, "intestine", 0, "An icky pile of intestines",
    "An icky pile of intestines is here - colon and all.",
    0, "$n hits so hard, that $N pukes up his intestines !",
    "You hit $N so hard that he pukes up his intestines!"},
   {10, "puke vomit", 0, "chunky vomit", "Some one upchucked on the floor here.",
    0, "$N throws up all over!",
    "$N throws up all over you!"},
   {11, "nose", 1, "%s's nose", "%s lost his nose here.",
    1, "$n cackles gleefuly as he removes $N's nose!",
    "You cackle as you sever $N's nose!"},
   {12, "ear", 1, "%s's ear", "%'s bloody severed ear is here.",
    1, "$n's grabs $N's ear and rips it off!",
    "Your rip off $N's ear!"}
d2578 21
a2598 21
   struct obj_data *piece;
   int i;
   extern int max_npc_corpse_time;

   /*lets check and see if we even GET body parts eh - i mean, they're
      fun, but it wouldn't be quite as fun if they were always there! */

   if (number (1, 5) < 4)
      return;

   /*Then Horray! We's got parts! */
   /* But which part? */
   i = number (0, 20);		/* 20 pieces should be okay */
   piece = create_obj ();

   /*now, everything we have should be in the structures neh? */
   /*name first */
   piece->name = str_dup (parts[i].name);
   /*then lets see about the descs */
   if (parts[i].nname)
   {
d2603 3
a2605 3
   }
   else
   {
d2608 4
a2611 4
   }
   /*well, now we know how it looks, lets see if we wanna take it. */
   if (parts[i].take)
   {
d2613 24
a2636 24
   }
   /*  and lets see how it got here in the first place neh? */
   act (parts[i].actout, FALSE, killer, 0, ch, TO_ROOM);
   act (parts[i].actkil, FALSE, killer, 0, ch, TO_CHAR);

/* setup the rest of the stats any object needs */
   piece->item_number = NOTHING;
   piece->in_room = NOWHERE;
   GET_OBJ_TYPE (piece) = ITEM_CONTAINER;
   GET_OBJ_VAL (piece, 0) = 0;	/* You can't store stuff in a corpse */
   GET_OBJ_VAL (piece, 3) = 1;	/* corpse identifier */
   GET_OBJ_EXTRA (piece) = ITEM_NODONATE;
   GET_OBJ_WEIGHT (piece) = 1;
   GET_OBJ_RENT (piece) = 1;

   /* Note - you may have some trouble with corpse decay here -
      improper settings WILL cause the mud to crash if you do not correcly
      decay.  Right now, the pieces are setup as a corpse, so if you made any
      changes to your corpse identifiers, fix it above. */

   GET_OBJ_TIMER (piece) = max_npc_corpse_time;

   /* and thats all folks! */
   obj_to_room (piece, ch->in_room);
d2642 12
a2653 12
   struct obj_data *obj_i;
   bool retval = FALSE, done = FALSE;
   char arg[MAX_INPUT_LENGTH];

   ACMD (do_wield);
   int cmd_wield;

   cmd_wield = find_command ("wield");

   for (obj_i = world[ch->in_room].contents; obj_i && !done; obj_i = obj_i->next_content)
   {

d2655 16
a2670 16
      {
	 obj_from_room (obj_i);
	 obj_to_char (obj_i, ch);

	 if (!IS_FIGHTING (ch))
	 {
	    act ("$n eagerly reaches for $o.", FALSE, ch, obj_i, 0, TO_ROOM);
	 }
	 else
	 {
	    act ("$n extends $s hands, finally getting a steady hold of $o.", FALSE, ch, obj_i, 0, TO_ROOM);
	 }

	 REMOVE_BIT (obj_i->obj_flags.extra_flags, ITEM_WAS_DISARMED);

	 if (obj_i->name)
d2672 5
a2676 5



	 if (IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_WIELD) ||
	     IS_SET (obj_i->obj_flags.wear_flags, ITEM_WEAR_2HWIELD))
d2678 7
a2684 7

	 done = TRUE;
	 retval = TRUE;
      }
   }

   return retval;
d2694 5
a2698 5
   bool retval;
   struct affected_type *af, *af_next;

   if (ch->char_specials.fighting == NULL)
   {
d2703 1
a2703 1

d2705 10
a2714 9
      {
	 while (PickupDisarmedWeapon (ch));

	 for (af = ch->affected; af; af = af_next)
	 {
	    af_next = af->next;
	    if (af->type == SKILL_DISARM_DROPPED_WEAP)
	    {
	       affect_remove (ch, af);
d2716 1
a2716 2
	 }
      }
d2718 2
a2719 5
      {
	 for (af = ch->affected; af; af = af_next)
	 {
	    af_next = af->next;
	    if (af->type == SKILL_DISARM_FUMBLING_WEAP)
d2721 5
a2725 1
	       affect_remove (ch, af);
d2727 1
a2727 2
	 }
      }
d2729 3
a2731 3
   }
   else
   {
d2733 3
a2735 3
   }

   return retval;
d2741 7
a2747 7
   bool done = FALSE;
   struct affected_type *af, *af_next;

   --ch->char_specials.action_delays[(int) action_delay_type];

   if (ch->char_specials.action_delays[(int) action_delay_type] == 0)
   {
d2749 9
a2757 9
      {
	 af_next = af->next;
	 if (af->type == SKILL_DISARM_FUMBLING_WEAP && af->bitvector & affect_type)
	 {
	    affect_remove (ch, af);
	    done = TRUE;
	 }
      }

d2760 3
a2762 3
   }
   else
   {
d2765 1
a2765 1
   }
d2771 7
a2777 7
   bool get_weap = FALSE, aff_drop_expired = FALSE, done;
   struct affected_type *af, *af_next;

   --ch->char_specials.action_delays[(int) action_delay_type];

   if (IS_NPC (ch))
   {
d2779 6
a2784 6
      {
	 get_weap = TRUE;
      }
   }
   else
   {
d2786 11
a2796 11
      {
	 aff_drop_expired = TRUE;
      }
   }

   /* Here, if get_weap is true, it's time for a _MOB_ to look in room for its dropped weapon.
      When none can be found, another char picked it up, so it stops trying for it and all penalties
      don't apply anymore.  this is why the drop affect expires regardless. */

   if (get_weap)
   {
d2798 3
a2800 3
      {
	 ch->char_specials.action_delays[(int) action_delay_type] = 0;
      }
d2802 3
a2804 3
   }
   else
   {				/* if time to look for MOB's dislodged item */
d2806 12
a2817 12
      {
	 act ("$n struggles to regain $s weapon.", FALSE, ch, 0, 0, TO_ROOM);
      }
   }

   /* remove either
      a) all the affect for dropped weapon if either all weapons were recovered or the weapons to be
      recovered are no longer in the room or
      b) some of the affect for dropped weapons if all weapons haven't been recovered. */

   if (aff_drop_expired)
   {
d2819 9
a2827 9
      {
	 af_next = af->next;
	 if (af->type == SKILL_DISARM_DROPPED_WEAP && af->bitvector & affect_type)
	 {
	    affect_remove (ch, af);
	    done = TRUE;
	 }
      }
   }
d2831 1
a2831 1

d2857 8
a2864 8
   bool retval = FALSE;

   /* if not fumbling nor regaining dropped weap, let em strike back */
   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] == 0 &&
       ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] == 0)
   {
d2866 6
a2871 6
   }
   /* if PC/MOB isn't fighting anyone anymore (vict fleed), remove
      all affect-flags and pick up all dropped weapons */

   if (DisarmCheck (ch))
   {
d2873 5
a2877 5
   }
   /* handle PC/MOB who is fumbling their primary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_PRIM] > 0 && AWAKE (ch))
   {
d2880 5
a2884 5
   }
   /* handle PCs/MOBs that are fumbling their secondary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_FUMBLING_SECOND] > 0 && AWAKE (ch))
   {
d2887 5
a2891 5
   }
   /* handle PC/MOB who has been disarmed of their primary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_PRIM] > 0 && AWAKE (ch))
   {
d2893 5
a2897 5
   }
   /* handle PC/MOB who has been disarmed of their secondary weapon */

   if (ch->char_specials.action_delays[ACT_DELAY_DROPPED_SECOND] > 0 && AWAKE (ch))
   {
d2899 4
a2902 4
   }
   /* this point can only be reached if MOB/PC is affected by disarm in some way */

   return retval;
d2910 8
a2917 8
   struct char_data *t_ch;
   struct char_data *hold;

   if (!ch)
      return;

   for (t_ch = combat_list; t_ch; t_ch = hold)
   {
d2922 2
a2923 2
	 stop_fighting (t_ch);	/* mob check above commented out till i finish code */
   }
d2927 2
a2928 2
   attack aggressive monsters. Depending on thier current hitpoints
   Banyal */
d2931 10
a2940 10
   char Abuf[MAX_STRING_LENGTH];

   if (IS_NPC (ch))
      return;

   one_argument (argument, Abuf);

   if (*Abuf == '\0')
   {				/*No argument is a check of aggressivity */

d2942 4
a2945 4
      {
	 send_to_char ("You are not aggressive to monsters.\r\n", ch);
	 return;
      }
d2948 1
a2948 1

d2951 17
a2967 17
   }
   else if (!str_cmp (Abuf, "off") || atoi (Abuf) >= GET_MAX_HIT (ch))

      if (GET_CLASS (ch) == CLASS_ANTI_PALADIN)
      {
	 send_to_char ("What?  Let somebody else get the first blow?  Not a chance!\r\n", ch);
	 return;
      }
      else
      {
	 ch->player_specials->saved.aggressive = -1;
	 send_to_char ("You are no longer aggressive to monsters.\r\n", ch);
	 return;
      }
   else
   {				/* Turn on aggressivity */

d2969 1
a2969 1

d2971 4
a2974 4
      {
	 send_to_char ("Aggressive while dying?  Not likely!\r\n", ch);
	 return;
      }
d2978 1
a2978 1
   }
d2980 1
@
