head	1.329;
access;
symbols;
locks; strict;
comment	@ * @;


1.329
date	2011.08.06.15.22.51;	author rsd;	state Exp;
branches;
next	1.328;

1.328
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.327;

1.327
date	2009.07.16.19.15.54;	author myc;	state Exp;
branches;
next	1.326;

1.326
date	2009.07.14.01.22.48;	author myc;	state Exp;
branches;
next	1.325;

1.325
date	2009.06.09.21.50.21;	author myc;	state Exp;
branches;
next	1.324;

1.324
date	2009.06.09.05.41.36;	author myc;	state Exp;
branches;
next	1.323;

1.323
date	2009.03.20.23.02.59;	author myc;	state Exp;
branches;
next	1.322;

1.322
date	2009.03.16.19.17.52;	author jps;	state Exp;
branches;
next	1.321;

1.321
date	2009.03.09.02.22.32;	author myc;	state Exp;
branches;
next	1.320;

1.320
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.319;

1.319
date	2009.03.07.11.12.05;	author jps;	state Exp;
branches;
next	1.318;

1.318
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.317;

1.317
date	2009.02.21.03.30.16;	author myc;	state Exp;
branches;
next	1.316;

1.316
date	2009.02.11.17.03.39;	author myc;	state Exp;
branches;
next	1.315;

1.315
date	2009.01.18.06.58.53;	author myc;	state Exp;
branches;
next	1.314;

1.314
date	2008.12.03.03.13.43;	author myc;	state Exp;
branches;
next	1.313;

1.313
date	2008.09.28.19.06.49;	author jps;	state Exp;
branches;
next	1.312;

1.312
date	2008.09.25.04.48.10;	author jps;	state Exp;
branches;
next	1.311;

1.311
date	2008.09.21.21.51.18;	author jps;	state Exp;
branches;
next	1.310;

1.310
date	2008.09.21.20.40.40;	author jps;	state Exp;
branches;
next	1.309;

1.309
date	2008.09.21.04.54.23;	author myc;	state Exp;
branches;
next	1.308;

1.308
date	2008.09.20.06.05.06;	author jps;	state Exp;
branches;
next	1.307;

1.307
date	2008.09.14.02.08.01;	author jps;	state Exp;
branches;
next	1.306;

1.306
date	2008.09.08.05.24.50;	author jps;	state Exp;
branches;
next	1.305;

1.305
date	2008.09.07.20.05.27;	author jps;	state Exp;
branches;
next	1.304;

1.304
date	2008.09.07.07.21.56;	author jps;	state Exp;
branches;
next	1.303;

1.303
date	2008.09.01.22.15.59;	author jps;	state Exp;
branches;
next	1.302;

1.302
date	2008.08.31.21.04.46;	author myc;	state Exp;
branches;
next	1.301;

1.301
date	2008.08.29.19.18.05;	author myc;	state Exp;
branches;
next	1.300;

1.300
date	2008.08.29.04.16.26;	author myc;	state Exp;
branches;
next	1.299;

1.299
date	2008.08.29.03.02.40;	author myc;	state Exp;
branches;
next	1.298;

1.298
date	2008.08.28.23.48.29;	author rbr;	state Exp;
branches;
next	1.297;

1.297
date	2008.08.24.18.24.20;	author myc;	state Exp;
branches;
next	1.296;

1.296
date	2008.08.24.02.34.26;	author myc;	state Exp;
branches;
next	1.295;

1.295
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.294;

1.294
date	2008.08.16.08.25.13;	author jps;	state Exp;
branches;
next	1.293;

1.293
date	2008.08.15.05.50.54;	author jps;	state Exp;
branches;
next	1.292;

1.292
date	2008.08.15.03.59.08;	author jps;	state Exp;
branches;
next	1.291;

1.291
date	2008.08.14.23.10.35;	author myc;	state Exp;
branches;
next	1.290;

1.290
date	2008.08.14.09.45.22;	author jps;	state Exp;
branches;
next	1.289;

1.289
date	2008.08.10.02.58.40;	author jps;	state Exp;
branches;
next	1.288;

1.288
date	2008.07.27.05.13.23;	author jps;	state Exp;
branches;
next	1.287;

1.287
date	2008.07.27.01.33.51;	author jps;	state Exp;
branches;
next	1.286;

1.286
date	2008.07.26.21.33.55;	author jps;	state Exp;
branches;
next	1.285;

1.285
date	2008.07.22.07.25.26;	author myc;	state Exp;
branches;
next	1.284;

1.284
date	2008.07.15.19.22.25;	author myc;	state Exp;
branches;
next	1.283;

1.283
date	2008.07.15.19.14.33;	author myc;	state Exp;
branches;
next	1.282;

1.282
date	2008.07.15.18.53.39;	author myc;	state Exp;
branches;
next	1.281;

1.281
date	2008.07.15.17.49.24;	author myc;	state Exp;
branches;
next	1.280;

1.280
date	2008.07.13.16.48.09;	author jps;	state Exp;
branches;
next	1.279;

1.279
date	2008.06.21.08.53.09;	author myc;	state Exp;
branches;
next	1.278;

1.278
date	2008.06.09.23.00.13;	author myc;	state Exp;
branches;
next	1.277;

1.277
date	2008.06.05.02.07.43;	author myc;	state Exp;
branches;
next	1.276;

1.276
date	2008.05.19.06.53.04;	author jps;	state Exp;
branches;
next	1.275;

1.275
date	2008.05.19.06.17.07;	author jps;	state Exp;
branches;
next	1.274;

1.274
date	2008.05.18.20.16.11;	author jps;	state Exp;
branches;
next	1.273;

1.273
date	2008.05.18.03.24.14;	author jps;	state Exp;
branches;
next	1.272;

1.272
date	2008.05.09.22.04.33;	author jps;	state Exp;
branches;
next	1.271;

1.271
date	2008.04.20.04.11.08;	author jps;	state Exp;
branches;
next	1.270;

1.270
date	2008.04.07.04.32.11;	author jps;	state Exp;
branches;
next	1.269;

1.269
date	2008.04.07.03.02.54;	author jps;	state Exp;
branches;
next	1.268;

1.268
date	2008.04.05.16.49.38;	author myc;	state Exp;
branches;
next	1.267;

1.267
date	2008.04.05.16.38.56;	author jps;	state Exp;
branches;
next	1.266;

1.266
date	2008.04.05.06.28.50;	author myc;	state Exp;
branches;
next	1.265;

1.265
date	2008.04.05.05.05.42;	author myc;	state Exp;
branches;
next	1.264;

1.264
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.263;

1.263
date	2008.04.04.05.13.46;	author myc;	state Exp;
branches;
next	1.262;

1.262
date	2008.04.03.17.36.42;	author jps;	state Exp;
branches;
next	1.261;

1.261
date	2008.04.03.02.02.05;	author myc;	state Exp;
branches;
next	1.260;

1.260
date	2008.04.02.03.24.44;	author myc;	state Exp;
branches;
next	1.259;

1.259
date	2008.03.30.17.30.38;	author jps;	state Exp;
branches;
next	1.258;

1.258
date	2008.03.30.16.32.18;	author jps;	state Exp;
branches;
next	1.257;

1.257
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.256;

1.256
date	2008.03.27.22.57.29;	author jps;	state Exp;
branches;
next	1.255;

1.255
date	2008.03.22.03.22.38;	author myc;	state Exp;
branches;
next	1.254;

1.254
date	2008.03.21.15.01.17;	author myc;	state Exp;
branches;
next	1.253;

1.253
date	2008.03.16.23.30.14;	author jps;	state Exp;
branches;
next	1.252;

1.252
date	2008.03.10.18.01.17;	author myc;	state Exp;
branches;
next	1.251;

1.251
date	2008.03.09.18.15.45;	author jps;	state Exp;
branches;
next	1.250;

1.250
date	2008.03.09.08.57.56;	author jps;	state Exp;
branches;
next	1.249;

1.249
date	2008.03.09.08.52.21;	author jps;	state Exp;
branches;
next	1.248;

1.248
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.247;

1.247
date	2008.03.09.04.01.55;	author jps;	state Exp;
branches;
next	1.246;

1.246
date	2008.03.08.20.18.09;	author jps;	state Exp;
branches;
next	1.245;

1.245
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.244;

1.244
date	2008.03.05.03.03.54;	author myc;	state Exp;
branches;
next	1.243;

1.243
date	2008.02.24.17.31.13;	author myc;	state Exp;
branches;
next	1.242;

1.242
date	2008.02.16.20.31.32;	author myc;	state Exp;
branches;
next	1.241;

1.241
date	2008.02.13.21.27.31;	author myc;	state Exp;
branches;
next	1.240;

1.240
date	2008.02.11.21.04.01;	author myc;	state Exp;
branches;
next	1.239;

1.239
date	2008.02.10.20.30.03;	author myc;	state Exp;
branches;
next	1.238;

1.238
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.237;

1.237
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.236;

1.236
date	2008.02.09.07.05.37;	author myc;	state Exp;
branches;
next	1.235;

1.235
date	2008.02.09.06.19.44;	author jps;	state Exp;
branches;
next	1.234;

1.234
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.233;

1.233
date	2008.02.09.03.06.17;	author myc;	state Exp;
branches;
next	1.232;

1.232
date	2008.02.06.21.53.53;	author myc;	state Exp;
branches;
next	1.231;

1.231
date	2008.02.05.04.22.42;	author myc;	state Exp;
branches;
next	1.230;

1.230
date	2008.02.05.03.07.26;	author myc;	state Exp;
branches;
next	1.229;

1.229
date	2008.02.04.01.48.53;	author myc;	state Exp;
branches;
next	1.228;

1.228
date	2008.02.04.01.46.12;	author myc;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.03.08.46.52;	author myc;	state Exp;
branches;
next	1.226;

1.226
date	2008.02.02.19.38.20;	author myc;	state Exp;
branches;
next	1.225;

1.225
date	2008.02.02.04.27.55;	author myc;	state Exp;
branches;
next	1.224;

1.224
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.223;

1.223
date	2008.01.27.21.09.12;	author myc;	state Exp;
branches;
next	1.222;

1.222
date	2008.01.27.13.43.50;	author jps;	state Exp;
branches;
next	1.221;

1.221
date	2008.01.27.11.15.52;	author jps;	state Exp;
branches;
next	1.220;

1.220
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.219;

1.219
date	2008.01.23.05.13.26;	author jps;	state Exp;
branches;
next	1.218;

1.218
date	2008.01.23.04.38.34;	author jps;	state Exp;
branches;
next	1.217;

1.217
date	2008.01.22.22.29.25;	author myc;	state Exp;
branches;
next	1.216;

1.216
date	2008.01.22.05.32.22;	author myc;	state Exp;
branches;
next	1.215;

1.215
date	2008.01.17.01.29.10;	author myc;	state Exp;
branches;
next	1.214;

1.214
date	2008.01.11.02.06.50;	author myc;	state Exp;
branches;
next	1.213;

1.213
date	2008.01.10.05.39.43;	author myc;	state Exp;
branches;
next	1.212;

1.212
date	2008.01.09.13.04.40;	author jps;	state Exp;
branches;
next	1.211;

1.211
date	2008.01.05.21.55.32;	author jps;	state Exp;
branches;
next	1.210;

1.210
date	2008.01.05.05.38.51;	author jps;	state Exp;
branches;
next	1.209;

1.209
date	2008.01.04.03.03.48;	author jps;	state Exp;
branches;
next	1.208;

1.208
date	2008.01.04.02.31.33;	author jps;	state Exp;
branches;
next	1.207;

1.207
date	2008.01.04.01.53.26;	author jps;	state Exp;
branches;
next	1.206;

1.206
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.205;

1.205
date	2008.01.02.02.10.16;	author jps;	state Exp;
branches;
next	1.204;

1.204
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.203;

1.203
date	2007.12.24.18.22.36;	author myc;	state Exp;
branches;
next	1.202;

1.202
date	2007.12.20.23.12.50;	author myc;	state Exp;
branches;
next	1.201;

1.201
date	2007.12.19.20.51.52;	author myc;	state Exp;
branches;
next	1.200;

1.200
date	2007.11.23.07.10.41;	author jps;	state Exp;
branches;
next	1.199;

1.199
date	2007.11.22.21.30.18;	author jps;	state Exp;
branches;
next	1.198;

1.198
date	2007.11.21.02.34.43;	author jps;	state Exp;
branches;
next	1.197;

1.197
date	2007.11.21.01.29.37;	author jps;	state Exp;
branches;
next	1.196;

1.196
date	2007.11.18.16.51.55;	author myc;	state Exp;
branches;
next	1.195;

1.195
date	2007.10.25.20.39.37;	author myc;	state Exp;
branches;
next	1.194;

1.194
date	2007.10.23.20.21.00;	author myc;	state Exp;
branches;
next	1.193;

1.193
date	2007.10.17.17.18.04;	author myc;	state Exp;
branches;
next	1.192;

1.192
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.191;

1.191
date	2007.10.02.02.52.27;	author myc;	state Exp;
branches;
next	1.190;

1.190
date	2007.09.28.20.49.35;	author myc;	state Exp;
branches;
next	1.189;

1.189
date	2007.09.21.08.44.45;	author jps;	state Exp;
branches;
next	1.188;

1.188
date	2007.09.20.21.20.43;	author myc;	state Exp;
branches;
next	1.187;

1.187
date	2007.09.20.20.00.01;	author jps;	state Exp;
branches;
next	1.186;

1.186
date	2007.09.12.22.23.04;	author myc;	state Exp;
branches;
next	1.185;

1.185
date	2007.09.12.19.28.56;	author myc;	state Exp;
branches;
next	1.184;

1.184
date	2007.09.11.16.34.24;	author myc;	state Exp;
branches;
next	1.183;

1.183
date	2007.09.07.19.41.27;	author jps;	state Exp;
branches;
next	1.182;

1.182
date	2007.08.27.21.18.00;	author myc;	state Exp;
branches;
next	1.181;

1.181
date	2007.08.26.08.49.36;	author jps;	state Exp;
branches;
next	1.180;

1.180
date	2007.08.25.00.10.41;	author jps;	state Exp;
branches;
next	1.179;

1.179
date	2007.08.24.22.49.05;	author jps;	state Exp;
branches;
next	1.178;

1.178
date	2007.08.24.22.10.43;	author jps;	state Exp;
branches;
next	1.177;

1.177
date	2007.08.24.17.01.36;	author myc;	state Exp;
branches;
next	1.176;

1.176
date	2007.08.24.10.24.16;	author jps;	state Exp;
branches;
next	1.175;

1.175
date	2007.08.22.18.01.09;	author jps;	state Exp;
branches;
next	1.174;

1.174
date	2007.08.16.19.53.38;	author myc;	state Exp;
branches;
next	1.173;

1.173
date	2007.08.15.20.47.41;	author myc;	state Exp;
branches;
next	1.172;

1.172
date	2007.08.14.22.43.07;	author myc;	state Exp;
branches;
next	1.171;

1.171
date	2007.08.14.20.13.22;	author jps;	state Exp;
branches;
next	1.170;

1.170
date	2007.08.05.20.21.51;	author myc;	state Exp;
branches;
next	1.169;

1.169
date	2007.08.04.20.07.54;	author jps;	state Exp;
branches;
next	1.168;

1.168
date	2007.08.03.03.51.44;	author myc;	state Exp;
branches;
next	1.167;

1.167
date	2007.07.31.23.03.11;	author jps;	state Exp;
branches;
next	1.166;

1.166
date	2007.07.19.15.32.01;	author jps;	state Exp;
branches;
next	1.165;

1.165
date	2007.07.18.23.10.31;	author jps;	state Exp;
branches;
next	1.164;

1.164
date	2007.06.30.00.38.39;	author jps;	state Exp;
branches;
next	1.163;

1.163
date	2007.06.24.02.51.44;	author jps;	state Exp;
branches;
next	1.162;

1.162
date	2007.06.04.22.24.41;	author jps;	state Exp;
branches;
next	1.161;

1.161
date	2007.05.28.03.59.05;	author jps;	state Exp;
branches;
next	1.160;

1.160
date	2007.05.24.05.25.14;	author jps;	state Exp;
branches;
next	1.159;

1.159
date	2007.05.11.21.33.10;	author myc;	state Exp;
branches;
next	1.158;

1.158
date	2007.05.11.21.03.12;	author myc;	state Exp;
branches;
next	1.157;

1.157
date	2007.04.26.15.20.34;	author myc;	state Exp;
branches;
next	1.156;

1.156
date	2007.04.25.07.53.01;	author jps;	state Exp;
branches;
next	1.155;

1.155
date	2007.04.19.07.01.19;	author myc;	state Exp;
branches;
next	1.154;

1.154
date	2007.04.19.00.53.54;	author jps;	state Exp;
branches;
next	1.153;

1.153
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.152;

1.152
date	2006.11.26.08.31.17;	author jps;	state Exp;
branches;
next	1.151;

1.151
date	2006.11.23.00.36.24;	author jps;	state Exp;
branches;
next	1.150;

1.150
date	2006.11.18.21.10.03;	author jps;	state Exp;
branches;
next	1.149;

1.149
date	2006.11.14.21.45.51;	author jps;	state Exp;
branches;
next	1.148;

1.148
date	2006.11.08.07.55.17;	author jps;	state Exp;
branches;
next	1.147;

1.147
date	2006.07.20.10.09.06;	author dce;	state Exp;
branches;
next	1.146;

1.146
date	2006.05.11.03.07.50;	author cjd;	state Exp;
branches;
next	1.145;

1.145
date	2006.04.11.08.53.58;	author rls;	state Exp;
branches;
next	1.144;

1.144
date	2006.04.09.01.01.39;	author rls;	state Exp;
branches;
next	1.143;

1.143
date	2005.07.26.05.39.08;	author jwk;	state Exp;
branches;
next	1.142;

1.142
date	2005.06.26.03.20.52;	author cjd;	state Exp;
branches;
next	1.141;

1.141
date	2005.06.05.01.51.11;	author cjd;	state Exp;
branches;
next	1.140;

1.140
date	2005.02.14.07.12.35;	author rls;	state Exp;
branches;
next	1.139;

1.139
date	2004.11.28.06.43.14;	author rsd;	state Exp;
branches;
next	1.138;

1.138
date	2004.11.13.18.37.51;	author rsd;	state Exp;
branches;
next	1.137;

1.137
date	2004.11.12.05.23.08;	author rsd;	state Exp;
branches;
next	1.136;

1.136
date	2004.11.11.23.24.53;	author rsd;	state Exp;
branches;
next	1.135;

1.135
date	2004.11.11.23.03.22;	author rsd;	state Exp;
branches;
next	1.134;

1.134
date	2004.11.01.01.15.52;	author rsd;	state Exp;
branches;
next	1.133;

1.133
date	2004.10.31.20.38.11;	author jjl;	state Exp;
branches;
next	1.132;

1.132
date	2004.09.12.20.23.57;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2003.07.24.22.22.30;	author jjl;	state Exp;
branches;
next	1.130;

1.130
date	2003.06.30.04.05.29;	author jjl;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.28.02.02.55;	author jjl;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.28.00.54.15;	author jjl;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.25.03.08.38;	author jjl;	state Exp;
branches;
next	1.126;

1.126
date	2003.06.25.02.21.03;	author jjl;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.23.01.47.09;	author jjl;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.21.01.01.08;	author jjl;	state Exp;
branches;
next	1.123;

1.123
date	2003.03.26.11.55.35;	author rsd;	state Exp;
branches;
next	1.122;

1.122
date	2002.10.22.02.14.49;	author dce;	state Exp;
branches;
next	1.121;

1.121
date	2002.09.14.00.12.50;	author dce;	state Exp;
branches;
next	1.120;

1.120
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.119;

1.119
date	2002.09.05.01.54.41;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2002.08.29.17.32.58;	author rsd;	state Exp;
branches;
next	1.117;

1.117
date	2002.07.17.17.05.50;	author rls;	state Exp;
branches;
next	1.116;

1.116
date	2002.07.17.02.38.16;	author rls;	state Exp;
branches;
next	1.115;

1.115
date	2002.07.16.19.28.24;	author rls;	state Exp;
branches;
next	1.114;

1.114
date	2002.07.14.02.43.37;	author rls;	state Exp;
branches;
next	1.113;

1.113
date	2002.07.13.21.01.56;	author rls;	state Exp;
branches;
next	1.112;

1.112
date	2002.06.09.21.48.36;	author rls;	state Exp;
branches;
next	1.111;

1.111
date	2002.06.09.21.27.13;	author rls;	state Exp;
branches;
next	1.110;

1.110
date	2002.04.26.18.54.01;	author mpg;	state Exp;
branches;
next	1.109;

1.109
date	2002.04.25.23.48.06;	author mpg;	state Exp;
branches;
next	1.108;

1.108
date	2002.04.25.23.22.13;	author mpg;	state Exp;
branches;
next	1.107;

1.107
date	2002.04.24.22.33.09;	author mpg;	state Exp;
branches;
next	1.106;

1.106
date	2002.04.17.23.42.43;	author dce;	state Exp;
branches;
next	1.105;

1.105
date	2002.02.19.02.07.20;	author dce;	state Exp;
branches;
next	1.104;

1.104
date	2002.02.16.02.14.02;	author dce;	state Exp;
branches;
next	1.103;

1.103
date	2001.11.14.18.18.02;	author dce;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.14.16.24.30;	author dce;	state Exp;
branches;
next	1.101;

1.101
date	2001.10.15.23.41.13;	author rjd;	state Exp;
branches;
next	1.100;

1.100
date	2001.07.12.23.14.17;	author mtp;	state Exp;
branches;
next	1.99;

1.99
date	2001.05.13.16.15.58;	author dce;	state Exp;
branches;
next	1.98;

1.98
date	2001.04.24.03.30.32;	author dce;	state Exp;
branches;
next	1.97;

1.97
date	2001.04.07.17.02.30;	author dce;	state Exp;
branches;
next	1.96;

1.96
date	2001.04.02.23.31.21;	author dce;	state Exp;
branches;
next	1.95;

1.95
date	2001.03.29.03.11.04;	author dce;	state Exp;
branches;
next	1.94;

1.94
date	2001.03.06.03.10.18;	author dce;	state Exp;
branches;
next	1.93;

1.93
date	2001.02.27.00.53.23;	author mtp;	state Exp;
branches;
next	1.92;

1.92
date	2001.01.20.03.33.21;	author rsd;	state Exp;
branches;
next	1.91;

1.91
date	2000.11.28.00.40.00;	author mtp;	state Exp;
branches;
next	1.90;

1.90
date	2000.11.26.00.27.42;	author rsd;	state Exp;
branches;
next	1.89;

1.89
date	2000.11.23.00.57.04;	author mtp;	state Exp;
branches;
next	1.88;

1.88
date	2000.11.22.01.51.17;	author mtp;	state Exp;
branches;
next	1.87;

1.87
date	2000.11.22.00.01.41;	author rsd;	state Exp;
branches;
next	1.86;

1.86
date	2000.11.15.04.07.13;	author rsd;	state Exp;
branches;
next	1.85;

1.85
date	2000.11.11.22.44.07;	author rsd;	state Exp;
branches;
next	1.84;

1.84
date	2000.10.31.23.33.20;	author mtp;	state Exp;
branches;
next	1.83;

1.83
date	2000.10.31.23.27.01;	author mtp;	state Exp;
branches;
next	1.82;

1.82
date	2000.10.27.00.34.45;	author mtp;	state Exp;
branches;
next	1.81;

1.81
date	2000.10.15.04.41.00;	author cmc;	state Exp;
branches;
next	1.80;

1.80
date	2000.10.13.17.51.45;	author cmc;	state Exp;
branches;
next	1.79;

1.79
date	2000.10.11.23.50.45;	author rsd;	state Exp;
branches;
next	1.78;

1.78
date	2000.10.11.22.11.14;	author rsd;	state Exp;
branches;
next	1.77;

1.77
date	2000.10.07.00.43.55;	author mtp;	state Exp;
branches;
next	1.76;

1.76
date	2000.09.13.22.19.22;	author rsd;	state Exp;
branches;
next	1.75;

1.75
date	2000.05.22.22.35.53;	author rsd;	state Exp;
branches;
next	1.74;

1.74
date	2000.05.21.23.56.43;	author rsd;	state Exp;
branches;
next	1.73;

1.73
date	2000.05.14.05.19.29;	author rsd;	state Exp;
branches;
next	1.72;

1.72
date	2000.04.26.22.52.36;	author rsd;	state Exp;
branches;
next	1.71;

1.71
date	2000.04.22.22.36.25;	author rsd;	state Exp;
branches;
next	1.70;

1.70
date	2000.04.17.00.55.48;	author rsd;	state Exp;
branches;
next	1.69;

1.69
date	2000.03.20.04.33.38;	author rsd;	state Exp;
branches;
next	1.68;

1.68
date	2000.02.24.01.04.18;	author dce;	state Exp;
branches;
next	1.67;

1.67
date	2000.02.22.00.51.30;	author rsd;	state Exp;
branches;
next	1.66;

1.66
date	2000.02.16.07.59.10;	author mtp;	state Exp;
branches;
next	1.65;

1.65
date	2000.02.14.19.48.49;	author mtp;	state Exp;
branches;
next	1.64;

1.64
date	2000.02.13.08.53.18;	author rsd;	state Exp;
branches;
next	1.63;

1.63
date	2000.01.31.04.46.25;	author rsd;	state Exp;
branches;
next	1.62;

1.62
date	2000.01.31.00.25.15;	author rsd;	state Exp;
branches;
next	1.61;

1.61
date	2000.01.30.23.33.23;	author rsd;	state Exp;
branches;
next	1.60;

1.60
date	99.12.10.22.13.45;	author jimmy;	state Exp;
branches;
next	1.59;

1.59
date	99.12.06.20.28.08;	author cso;	state Exp;
branches;
next	1.58;

1.58
date	99.11.29.00.23.31;	author cso;	state Exp;
branches;
next	1.57;

1.57
date	99.11.28.23.28.50;	author cso;	state Exp;
branches;
next	1.56;

1.56
date	99.11.23.15.48.23;	author jimmy;	state Exp;
branches;
next	1.55;

1.55
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.54;

1.54
date	99.08.31.22.02.58;	author mtp;	state Exp;
branches;
next	1.53;

1.53
date	99.08.31.21.54.44;	author mtp;	state Exp;
branches;
next	1.52;

1.52
date	99.08.29.23.01.41;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.08.29.17.56.51;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.08.12.17.54.46;	author dce;	state Exp;
branches;
next	1.49;

1.49
date	99.08.12.04.25.39;	author jimmy;	state Exp;
branches;
next	1.48;

1.48
date	99.07.24.20.50.18;	author dce;	state Exp;
branches;
next	1.47;

1.47
date	99.07.23.23.41.47;	author jimmy;	state Exp;
branches;
next	1.46;

1.46
date	99.07.22.17.43.59;	author jimmy;	state Exp;
branches;
next	1.45;

1.45
date	99.07.11.04.18.23;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.07.10.03.17.44;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.07.07.22.51.54;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.07.07.21.57.44;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.06.30.18.11.09;	author jimmy;	state Exp;
branches;
next	1.40;

1.40
date	99.06.18.22.24.33;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.06.10.16.56.28;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.05.05.17.37.18;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.05.04.17.19.33;	author dce;	state Exp;
branches;
next	1.36;

1.36
date	99.05.01.18.01.21;	author dce;	state Exp;
branches;
next	1.35;

1.35
date	99.04.23.23.27.10;	author jimmy;	state Exp;
branches;
next	1.34;

1.34
date	99.04.22.18.57.27;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.04.18.20.14.23;	author dce;	state Exp;
branches;
next	1.32;

1.32
date	99.04.16.19.48.20;	author dce;	state Exp;
branches;
next	1.31;

1.31
date	99.04.16.03.55.09;	author dce;	state Exp;
branches;
next	1.30;

1.30
date	99.04.09.20.33.04;	author dce;	state Exp;
branches;
next	1.29;

1.29
date	99.04.09.03.38.36;	author dce;	state Exp;
branches;
next	1.28;

1.28
date	99.04.07.18.12.04;	author jen;	state Exp;
branches;
next	1.27;

1.27
date	99.04.07.15.39.34;	author jen;	state Exp;
branches;
next	1.26;

1.26
date	99.03.26.19.54.57;	author dce;	state Exp;
branches;
next	1.25;

1.25
date	99.03.26.19.44.35;	author jen;	state Exp;
branches;
next	1.24;

1.24
date	99.03.22.21.55.12;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	99.03.20.18.54.39;	author tph;	state Exp;
branches;
next	1.22;

1.22
date	99.03.14.00.53.03;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.03.05.20.02.36;	author dce;	state Exp;
branches;
next	1.20;

1.20
date	99.03.04.20.13.51;	author jimmy;	state Exp;
branches;
next	1.19;

1.19
date	99.03.01.05.31.34;	author jimmy;	state Exp;
branches;
next	1.18;

1.18
date	99.02.26.22.30.30;	author dce;	state Exp;
branches;
next	1.17;

1.17
date	99.02.23.16.48.06;	author dce;	state Exp;
branches;
next	1.16;

1.16
date	99.02.13.19.35.06;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.02.12.21.43.38;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.02.12.21.41.28;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	99.02.10.22.21.42;	author jimmy;	state Exp;
branches;
next	1.12;

1.12
date	99.02.07.07.29.01;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	99.02.06.05.32.46;	author jimmy;	state Exp;
branches;
next	1.10;

1.10
date	99.02.06.04.29.51;	author dce;	state Exp;
branches;
next	1.9;

1.9
date	99.02.06.00.40.36;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.16.42.34;	author jimmy;	state Exp;
branches;
next	1.7;

1.7
date	99.02.04.00.02.59;	author jimmy;	state Exp;
branches;
next	1.6;

1.6
date	99.02.01.22.40.16;	author jimmy;	state Exp;
branches;
next	1.5;

1.5
date	99.02.01.08.15.46;	author jimmy;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.04.18.50;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.01.31.06.43.09;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	99.01.29.04.06.46;	author jimmy;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.31;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: interpreter.c                                 Part of CircleMUD *
*  Usage: parse user commands, search for specials, call ACMD functions   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __INTERPRETER_C__

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "comm.h"
#include "interpreter.h"
#include "db.h"
#include "utils.h"
#include "spells.h"
#include "handler.h"
#include "mail.h"
#include "screen.h"
#include "olc.h"
#include "dg_scripts.h"
#include "clan.h"
#include "worship.h"

/*extern const struct title_type titles[NUM_CLASSES][LVL_IMPL + 1];*/
extern char *question1;
extern char *question2;
extern char *question3;
extern char *question4;
extern char *question5;
extern char *question6;
extern char *motd;
extern char *imotd;
extern char *background;
extern char *MENU;
extern char *WELC_MESSG;
extern char *START_MESSG;
extern char *subclass_descrip;
extern char *pc_class_types[];
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
extern int restrict;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct room_data *world;
extern int warrior_subclasses[WARRIOR_SUBCLASSES];
extern int mage_subclasses[MAGE_SUBCLASSES];
extern int cleric_subclasses[CLERIC_SUBCLASSES];
extern int rogue_subclasses[ROGUE_SUBCLASSES];

#define EMPTY_HOME -1
#define UNDEFINED_HOME_NO -1

/* external functions */
bool ask_question(struct descriptor_data *d, int question, char *arg);
void echo_on(struct descriptor_data *d);
void echo_off(struct descriptor_data *d);
void do_start(struct char_data *ch);
void init_char(struct char_data *ch);
int create_entry(char *name);
int special(struct char_data *ch, int cmd, char *arg);
int isbanned(char *hostname);
int Valid_Name(char *newname);
extern int class_ok_race[NUM_RACES][NUM_CLASSES];
extern char *class_display[];
extern char *char_hometown[];
void oedit_parse(struct descriptor_data *d, char *arg);
void redit_parse(struct descriptor_data *d, char *arg);
void zedit_parse(struct descriptor_data *d, char *arg);
void medit_parse(struct descriptor_data *d, char *arg);
void sedit_parse(struct descriptor_data *d, char *arg);
void hedit_parse(struct descriptor_data *d, char *arg);
void sdedit_parse(struct descriptor_data *d, char *arg);
int roll_table[6];

extern char *rolls_abils_result[];
void display_question(struct descriptor_data *d);
void change_affected_stats(struct char_data * ch);
void load_results(struct char_data * ch);
/*void rolls_display(struct char_data *ch, char *[], char *[]);*/
void roll_view_abils(struct char_data *ch, int []);
int set_race_align(struct char_data *ch);
void new_rollor_display(struct char_data *ch, int[]);
void room_selector(int race, int class, int result_rooms[], short int add);
int bonus_stat(struct char_data *ch, char arg);
int parse_race(char arg);
long exp_to_level(int, int);
void do_newbie(struct char_data *vict);
void set_innate(struct char_data * ch, char *arg);
void trigedit_parse(struct descriptor_data *d, char *arg);
char *strip_ansi(char *the_string);
extern char *diety_selection;
void appear(struct char_data * ch);

/* prototypes for all do_x functions. */
ACMD(do_abort);
ACMD(do_action);
ACMD(do_advance);
ACMD(do_aggr);
ACMD(do_alert);
ACMD(do_alias);
ACMD(do_assist);
ACMD(do_at);
ACMD(do_backstab);
ACMD(do_ban);
ACMD(do_bandage);
ACMD(do_bash);
ACMD(do_bind);
ACMD(do_disarm);
ACMD(do_disengage);
ACMD(do_bodyslam);
ACMD(do_breath);
ACMD(do_buck);
ACMD(do_cast);
ACMD(do_camp);
ACMD(do_circle);
ACMD(do_clan);
ACMD(do_color);
ACMD(do_commands);
ACMD(do_consider);
ACMD(do_consent);
ACMD(do_copyto);
ACMD(do_credits);
ACMD(do_ctell);
ACMD(do_date);
ACMD(do_dc);
ACMD(do_disembark);
ACMD(do_diagnose);
ACMD(do_dismount);
ACMD(do_display);
ACMD(do_disband);
ACMD(do_dig);
ACMD(do_doorbash);
ACMD(do_douse);
ACMD(do_drag);
ACMD(do_drink);
ACMD(do_drop);
ACMD(do_dump);
ACMD(do_eat);
ACMD(do_echo);
ACMD(do_enter);
ACMD(do_equipment);
ACMD(do_examine);
ACMD(do_exit);
ACMD(do_exits);
ACMD(do_flee);
ACMD(do_fly);
ACMD(do_follow);
ACMD(do_force);
ACMD(do_forget);
ACMD(do_frag);
ACMD(do_gecho);
ACMD(do_gen_comm);
ACMD(do_gen_door);
ACMD(do_gen_ps);
ACMD(do_gen_write);
ACMD(do_get);
ACMD(do_give);
ACMD(do_goto);
ACMD(do_grab);
ACMD(do_grep);
ACMD(do_group);
ACMD(do_gsay);
ACMD(do_guard);
ACMD(do_hcontrol);
ACMD(do_help);
ACMD(do_hide);
ACMD(do_hit);
ACMD(do_hitall);
ACMD(do_home);
ACMD(do_house);
ACMD(do_hunt);
ACMD(do_ignore);
ACMD(do_innate);
ACMD(do_info);
ACMD(do_insult);
ACMD(do_inventory);
ACMD(do_invis);
ACMD(do_justice);
#ifndef CIRCLE_WINDOWS
ACMD(do_ispell);
#endif
ACMD(do_kick);
ACMD(do_kill);
ACMD(do_kneel);
ACMD(do_last);
ACMD(do_leave);
/*ACMD(do_levels);*/
ACMD(do_linkload);
ACMD(do_listclass);
ACMD(do_listspells);
ACMD(do_load);
ACMD(do_look);
ACMD(do_map);
ACMD(do_mdisband);
ACMD(do_meditate);
ACMD(do_memorize);
ACMD(do_mgroup);
ACMD(do_mount);
ACMD(do_mpasound);
ACMD(do_mpjunk);
ACMD(do_mpecho);
ACMD(do_mpechoat);
ACMD(do_mpechoaround);
ACMD(do_mpkill);
ACMD(do_mpmload);
ACMD(do_mpoload);
ACMD(do_mppurge);
ACMD(do_mpgoto);
ACMD(do_mpat);
ACMD(do_mptransfer);
ACMD(do_mpforce);
ACMD(do_move);
ACMD(do_mlist);
ACMD(do_msay);
ACMD(do_not_here);
ACMD(do_offer);
ACMD(do_olc);
ACMD(do_order);
ACMD(do_olist);
ACMD(do_page);
ACMD(do_peace);
ACMD(do_petition);
ACMD(do_players);
ACMD(do_poofset);
ACMD(do_pour);
ACMD(do_practice);
ACMD(do_pray);
ACMD(do_prompt);
ACMD(do_ptell);
ACMD(do_purge);
ACMD(do_put);
ACMD(do_qcomm);
ACMD(do_quit);
ACMD(do_recline);
ACMD(do_rest);
ACMD(do_reboot);
ACMD(do_remove);
ACMD(do_rent);
ACMD(do_report);
ACMD(do_rescue);
ACMD(do_reply);
ACMD(do_restore);
ACMD(do_rrestore);
ACMD(do_return);
ACMD(do_retreat);
ACMD(do_rlist);
ACMD(do_rsdiamimp);
ACMD(do_rclone);
ACMD(do_readlist);
ACMD(do_rename);
ACMD(do_roar);
ACMD(do_save);
ACMD(do_say);
ACMD(do_score);
ACMD(do_scribe);
ACMD(do_scan);
ACMD(do_search);
ACMD(do_speak);
ACMD(do_attributes);
ACMD(do_send);
ACMD(do_set);
ACMD(do_shapechange);
ACMD(do_show);
ACMD(do_shutdown);
ACMD(do_sit);
ACMD(do_skillset);
ACMD(do_skills);
ACMD(do_sleep);
ACMD(do_sneak);
ACMD(do_snoop);
ACMD(do_spec_comm);
ACMD(do_spells);
ACMD(do_split);
ACMD(do_springleap);
ACMD(do_sdedit);
ACMD(do_stand);
ACMD(do_stat);
ACMD(do_steal);
ACMD(do_subclass);
ACMD(do_sweep);
ACMD(do_switch);
ACMD(do_syslog);
ACMD(do_tame);
ACMD(do_tedit);
ACMD(do_teleport);
ACMD(do_tell);
ACMD(do_terminate);
ACMD(do_throatcut);
ACMD(do_time);
ACMD(do_title);
ACMD(do_toggle);
ACMD(do_trophy);
ACMD(do_track);
ACMD(do_trans);
ACMD(do_unban);
ACMD(do_unbind);
ACMD(do_use);
ACMD(do_users);
ACMD(do_visible);
ACMD(do_viewdam);
ACMD(do_vnum);
ACMD(do_vstat);
ACMD(do_wake);
ACMD(do_wear);
ACMD(do_weather);
ACMD(do_where);
ACMD(do_who);
ACMD(do_wield);
ACMD(do_wizlock);
ACMD(do_wiznet);
ACMD(do_wizutil);
ACMD(do_wworld);
ACMD(do_write);
ACMD(do_zreset);
ACMD(do_experience);

ACMD(do_world);

/* DG Script ACMD's */
ACMD(do_attach);
ACMD(do_detach);
ACMD(do_tlist);
ACMD(do_tstat);
ACMD(do_masound);
ACMD(do_mkill);
ACMD(do_mjunk);
ACMD(do_mechoaround);
ACMD(do_msend);
ACMD(do_mecho);
ACMD(do_mload);
ACMD(do_mpurge);
ACMD(do_mgoto);
ACMD(do_mat);
ACMD(do_mteleport);
ACMD(do_mforce);
ACMD(do_mexp);
ACMD(do_mgold);
ACMD(do_DumbMobTrack);
ACMD(do_layhand);
ACMD(do_first_aid);
ACMD(do_summon_mount);
// void do_layhand(struct char_data *ch, char *arg, int cmd);
// void do_first_aid(struct char_data *ch, char *arg, int cmd);
// void do_summon_mount(struct char_data *ch, char *arg, int cmd);

/* This is the Master Command List(tm).

 * You can put new commands in, take commands out, change the order
 * they appear in, etc.  You can adjust the "priority" of commands
 * simply by changing the order they appear in the command list.
 * (For example, if you want "as" to mean "assist" instead of "ask",
 * just put "assist" above "ask" in the Master Command List(tm).
 *
 * In general, utility commands such as "at" should have high priority;
 * infrequently used and dangerously destructive commands should have low
 * priority.
 */

const struct command_info cmd_info[] = {
  { "RESERVED", 0, 0, 0, 0 , 0, 0, 0, 0, 0 ,0 },	/* this must be first -- for specprocs */
/*0's are:
name , position, acmd, min level, mediate, min/maj para, hide, bound*/
  /* directions must come before other commands but after RESERVED */
  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH , 0, 0, 0, 0, 0 ,0 },
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST , 0, 0, 0, 0, 0 ,0 },
  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH , 0, 0, 0, 0, 0 ,0 },
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST , 0, 0, 0, 0, 0 ,0 },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP , 0, 0, 0, 0, 0 ,0 },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN , 0, 0, 0, 0, 0 ,0 },

/* now, the main list */
  { "abort" , POS_DEAD, do_abort, 0, 0, 0, 0, 0, 0, 0, 1},
  { "at"       , POS_DEAD    , do_at       , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ack"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "advance"  , POS_DEAD    , do_advance  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
 { "aggr" , POS_DEAD, do_aggr, 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "alert"     , POS_RESTING , do_alert     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "alias"    , POS_DEAD    , do_alias    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "accuse"   , POS_SITTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "afk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "agree"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "amaze"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "apologize"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "applaud"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "appear"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "assist"   , POS_FIGHTING, do_assist   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ask"      , POS_RESTING , do_spec_comm, 0, SCMD_ASK , 0, 0, 0, 0, 0 ,0 },
  { "auction"  , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_AUCTION , 0, 0, 0, 0, 0 ,0 },
  { "ayt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "backstab" , POS_STANDING, do_backstab , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bandage"      , POS_STANDING    , do_bandage      , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "balance"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bang"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bark"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bash"     , POS_FIGHTING, do_bash     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bind"    , POS_STANDING, do_bind      , 1, 0, 0, 0, 0, 0, 0 ,0 },
  { "bodyslam" , POS_FIGHTING, do_bodyslam , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "beer"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "beg"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bird"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bite"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "blink"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bleed"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "blush"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "boggle"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bonk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bored"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bounce"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bow"      , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "brb"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "breath"   , POS_FIGHTING, do_breath   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "buck"     , POS_STANDING, do_buck     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "burp"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "buy"      , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG , 0, 0, 0, 0, 0 ,0 },
  { "bye"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "cast"     , POS_SITTING , do_cast     , 1, 0 , 0, 0, 0, 0, 0 ,1},
  { "cackle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "camp"     , POS_STANDING, do_camp , 1, 0 , 0, 0, 0, 0, 0 ,0 },

  { "chuckle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "check"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cheer"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "choke"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "clan"     , POS_SLEEPING, do_clan     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "clap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "circle"   , POS_FIGHTING, do_circle   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 0, 0, 0, 0, 0 ,0 },
  { "close"    , POS_SITTING , do_gen_door , 0, SCMD_CLOSE , 0, 0, 0, 0, 0 ,0 },
  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 0, 0, 0, 0, 0 ,0 },
  { "consider" , POS_RESTING , do_consider , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "copyto"   , POS_STANDING, do_copyto   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "color"    , POS_DEAD    , do_color    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "comfort"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "comb"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS , 0, 0, 0, 0, 0 ,0 },
  { "consent"  , POS_RESTING, do_consent, 0, 0, 0, 0, 0, 0, 0, 0},
  { "cough"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "credits"  , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS , 0, 0, 0, 0, 0 ,0 },
  { "cringe"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cry"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ctell"    , POS_SLEEPING, do_ctell    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cuddle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "curse"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "curtsey"  , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "dance"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "date"     , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_DATE , 0, 0, 0, 0, 0 ,0 },
  { "daydream" , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dc"       , POS_DEAD    , do_dc       , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "deposit"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disembark", POS_STANDING, do_disembark, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dismount" , POS_STANDING, do_dismount , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "display"  , POS_DEAD    , do_display  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
{ "disband"  , POS_RESTING , do_disband  , 1, 0 , 0, 0, 0, 0, 0 , 0},
{ "dig"      , POS_STANDING, do_dig      , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disappear"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disarm", POS_FIGHTING, do_disarm, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disengage", POS_FIGHTING, do_disengage, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "doorbash" , POS_STANDING, do_doorbash , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "douse"    , POS_STANDING, do_douse    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "drag"     , POS_STANDING, do_drag     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dream"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "drink"    , POS_RESTING , do_drink    , 0, SCMD_DRINK , 0, 0, 0, 0, 0 ,0 },
  { "drop"     , POS_RESTING , do_drop     , 0, SCMD_DROP , 0, 0, 0, 0, 0 ,0 },
  { "drool"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "duck"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "duh"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dump"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "eat"      , POS_RESTING , do_eat      , 0, SCMD_EAT , 0, 0, 0, 0, 0 ,0 },
  { "echo"     , POS_SLEEPING, do_echo     , LVL_IMMORT, SCMD_ECHO , 0, 0, 0, 0, 0 ,0 },
  { "emote"    , POS_RESTING , do_echo     , 1, SCMD_EMOTE , 0, 0, 0, 0, 0 ,0 },
  { ":"        , POS_RESTING, do_echo      , 1, SCMD_EMOTE , 0, 0, 0, 0, 0 ,0 },
  { "embrace"  , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "enter"    , POS_STANDING, do_enter    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "envy"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "equipment", POS_SLEEPING, do_equipment, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "exits"    , POS_RESTING , do_exits    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "examine"  , POS_SITTING , do_examine  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "experience" , POS_DEAD  , do_experience ,0, 0, 0, 0, 0, 0, 0 ,0 },
  { "eyebrow"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "force"    , POS_SLEEPING, do_force    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fart"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "first aid"     , POS_STANDING, do_first_aid     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fill"     , POS_STANDING, do_pour     , 0, SCMD_FILL , 0, 0, 0, 0, 0 ,0 },
  { "flee"     , POS_RESTING, do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flex"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flip"     , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flirt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fly"      , POS_STANDING, do_fly      , 0, 0, 0, 0, 0, 0, 0, 0 },
  { "follow"   , POS_RESTING , do_follow   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fool"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "forget"   , POS_RESTING , do_forget   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fondle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
 { "frag"   , POS_DEAD    , do_frag  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "freeze"   , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE , 0, 0, 0, 0, 0 ,0 },
  { "french"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "frown"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fume"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "get"      , POS_RESTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gag"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gape"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gasp"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gecho"    , POS_DEAD    , do_gecho    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "give"     , POS_RESTING , do_give     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "giggle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "glance"   , POS_DEAD    , do_diagnose , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "glare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "goto"     , POS_SLEEPING, do_goto     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GOSSIP , 0, 0, 0, 0, 0 ,0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "group"    , POS_RESTING , do_group    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grab"     , POS_RESTING , do_grab     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grats"    , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GRATZ , 0, 0, 0, 0, 0 ,0 },
  { "grep"     , POS_RESTING , do_grep     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "greet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grin"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grope"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grovel"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "growl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grumble"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gsay"     , POS_SLEEPING, do_gsay     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gtell"    , POS_SLEEPING, do_gsay     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "guard"    , POS_STANDING, do_guard    , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "help"     , POS_DEAD    , do_help     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
  { "handbook" , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK , 0, 0, 0, 0, 0 ,0 },
  { "halo"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hi5"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hiccup"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hide"     , POS_STANDING , do_hide     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hiss"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hit"      , POS_FIGHTING    , do_hit      , 0, SCMD_HIT , 0, 0, 0, 0, 0 ,0 },
 { "hitall"      , POS_FIGHTING    , do_hitall      , 0, 0, 0, 0, 0, 0,0,0},

  { "hold"     , POS_RESTING , do_grab     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hop"      , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "home"     , POS_DEAD    , do_not_here     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "house"    , POS_RESTING , do_house    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hunt"    , POS_STANDING, do_hunt    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hug"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hunger"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "inventory", POS_DEAD    , do_inventory, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA , 0, 0, 0, 0, 0 ,0 },
  { "imitate"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "imotd"    , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD , 0, 0, 0, 0, 0 ,0 },
  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST , 0, 0, 0, 0, 0 ,0 },
  { "impale"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "innate"   , POS_DEAD    , do_innate   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "ignore"   , POS_DEAD    , do_ignore   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO , 0, 0, 0, 0, 0 ,0 },
  { "insult"   , POS_RESTING , do_insult   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "invis"    , POS_DEAD    , do_invis    , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "justice"    , POS_DEAD    , do_justice    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  #ifndef CIRCLE_WINDOWS
  { "ispell"   , POS_DEAD    , do_ispell   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#endif

  /*{ "junk"     , POS_RESTING , do_drop     , 0, SCMD_JUNK , 0, 0, 0, 0,0 ,0 },
*/
  { "kick"     , POS_FIGHTING, do_kick     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kill"     , POS_FIGHTING, do_kill     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kiss"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kneel"     , POS_RESTING , do_kneel     , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK , 1, 1, 0, 1, 0,0 },
  { "lag"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "laugh"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "layhand"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "last"     , POS_DEAD    , do_last     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "lean"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "leave"    , POS_STANDING, do_leave    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
 /* { "levels"   , POS_DEAD    , do_levels   , 0, 0 , 0, 0, 0, 0, 0 ,0 },*/
  { "list"     , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "listclass", POS_DEAD    , do_listclass  , LVL_HEAD_C, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , 0, 0, 0, 0, 0, 0, 0, 0 },
  { "lick"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "lock"     , POS_SITTING , do_gen_door , 0, SCMD_LOCK , 0, 0, 0, 0, 0 ,0 },
  { "linkload" , POS_DEAD    , do_linkload , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "load"     , POS_DEAD    , do_load     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "love"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "map"      , POS_DEAD    , do_map      ,LVL_IMMORT, 0,0,0,0,0,0,0 },
 { "mdisband"  , POS_RESTING , do_mdisband  , 1, 0 , 0, 0, 0, 0, 0 , 0},
  { "moan"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "medit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
  { "motd"     , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD , 0, 0, 0, 0, 0 ,0 },
  { "mail"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "massage"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "meditate" , POS_RESTING , do_meditate , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "memorize" , POS_RESTING, do_memorize , 0, 0 , 1, 0, 0, 1, 0 ,0 },
{ "mgroup"   , POS_RESTING , do_mgroup    , 1, 0 , 0, 0, 0, 0, 0 , 0},
  { "moon"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mosh"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mount"    , POS_STANDING, do_mount    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mourn"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mute"     , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH , 0, 0, 0, 0, 0 ,0 },
  { "mutter"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "murder"   , POS_FIGHTING, do_hit      , 0, SCMD_MURDER , 0, 0, 0, 0, 0 ,0 },
  { "mpasound" , POS_DEAD    , do_mpasound , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpjunk"   , POS_DEAD    , do_mpjunk   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpecho"   , POS_DEAD    , do_mpecho   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpechoat" , POS_DEAD    , do_mpechoat , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpechoaround" , POS_DEAD, do_mpechoaround, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpkill"   , POS_DEAD    , do_mpkill   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpmload"  , POS_DEAD    , do_mpmload  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpoload"  , POS_DEAD    , do_mpoload  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mppurge"  , POS_DEAD    , do_mppurge  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpgoto"   , POS_DEAD    , do_mpgoto   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpat"     , POS_DEAD    , do_mpat     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mptransfer" , POS_DEAD  , do_mptransfer, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpforce"  , POS_DEAD    , do_mpforce  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },

  { "msay"     , POS_SLEEPING, do_msay     , 0, 0, 0 , 0, 0, 0, 0, 0 },
 {"anews" , POS_SLEEPING, do_gen_ps , LVL_GOD, SCMD_ANEWS , 0, 0, 0, 0, 0,0 },
  { "nap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS , 0, 0, 0, 0, 0 ,0 },
  { "nibble"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nod"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nog"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "noogie"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_NOTITLE , 0, 0, 0, 0, 0 ,0 },
  { "nudge"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nuzzle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  /*{ "olc"      , POS_DEAD    , do_olc      , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },*/
  { "order"    , POS_RESTING , do_order    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "offer"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "open"     , POS_SITTING , do_gen_door , 0, SCMD_OPEN , 0, 0, 0, 0, 0 ,0 },
  { "olc"      , POS_DEAD    , do_olc      , LVL_GOD, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
  { "olist"    , POS_DEAD    , do_olist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },

  { "put"      , POS_RESTING , do_put      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "panic"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pant"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pat"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "page"     , POS_DEAD    , do_page     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_PARDON , 0, 0, 0, 0, 0 ,0 },
  { "peace"    , POS_DEAD    , do_peace    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "peer"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "petition" , POS_DEAD    , do_petition , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pick"     , POS_STANDING, do_gen_door , 1, SCMD_PICK , 0, 0, 0, 0, 0 ,0 },
  { "players"  , POS_DEAD    , do_players  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "point"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "poke"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES , 0, 0, 0, 0, 0 ,0 },
  { "ponder"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "poofin"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN , 0, 0, 0, 0, 0 ,0 },
  { "poofout"  , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT , 0, 0, 0, 0, 0 ,0 },
  { "pounce"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pour"     , POS_STANDING, do_pour     , 0, SCMD_POUR , 0, 0, 0, 0, 0 ,0 },
  { "pout"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "protect"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
 /* { "practice" , POS_RESTING , do_practice , 1, 0 , 0, 0, 0, 0, 0 ,0},*/
  { "pray"     , POS_RESTING , do_pray   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ptell"    , POS_DEAD    , do_ptell    , LVL_BUILDER, 0, 0, 0, 0, 0, 0, 0 },
  { "puke"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "punch"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pull"    , POS_RESTING , do_not_here   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "push"    , POS_RESTING , do_not_here   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "purr"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "purge"    , POS_DEAD    , do_purge    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },

  { "quaff"    , POS_RESTING , do_use      , 0, SCMD_QUAFF , 0, 0, 0, 0, 0 ,0 },
  { "qecho"    , POS_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO , 0, 0, 0, 0, 0 ,0 },
  { "qui"      , POS_DEAD    , do_camp     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "quit"     , POS_DEAD    , do_camp     , 0, SCMD_QUIT , 0, 0, 0, 0, 0 ,0 },
  { "qsay"     , POS_RESTING , do_qcomm    , 0, SCMD_QSAY , 0, 0, 0, 0, 0 ,0 },

  { "rest"     , POS_RESTING , do_rest     , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "raise"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "recline"  , POS_RESTING , do_recline     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "report"   , POS_RESTING , do_report   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "reply"    , POS_SLEEPING, do_reply    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "read"     , POS_RESTING , do_look     , 0, SCMD_READ , 0, 0, 0, 0, 0 ,0 },
  { "reload"   , POS_DEAD    , do_reboot   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "recite"   , POS_RESTING , do_use      , 0, SCMD_RECITE , 0, 0, 0, 0, 0 ,0 },
  { "receive"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "remove"   , POS_RESTING , do_remove   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rent"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },

  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_HEAD_B, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
  { "rescue"   , POS_FIGHTING, do_rescue   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
 /* { "readlist"  , POS_DEAD    , do_readlist     , LVL_GOD, 0 , 0, 0,
0,0,0, 0 },*/
  { "restore"  , POS_DEAD    , do_restore  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "return"   , POS_DEAD    , do_return   , 1, 0 , 0, 0, 0, 0, 0
,0 },
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp, -1, 0, 0, 0, 0, 0, 0 ,0 },
  { "retreat"  , POS_FIGHTING, do_retreat, 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "redit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
  { "rename"   , POS_DEAD    , do_rename   , LVL_HEAD_C, 0, 0,0,0,0,0,0},
  { "roar"    , POS_FIGHTING , do_roar   ,  0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rofl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "roll"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ready"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ruffle"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },

  { "say"      , POS_RESTING , do_say      , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "'"        , POS_RESTING , do_say      , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "save"     , POS_SLEEPING, do_save     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "attributes" , POS_DEAD , do_attributes , 0, 0 , 1, 1, 1, 1, 1 ,0 },

  { "score"    , POS_DEAD    , do_score    , 0, 0 , 1, 1, 1, 1, 1 ,0 },
  { "scan"     , POS_STANDING, do_scan     , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "salute"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scribe"    , POS_RESTING , do_scribe   , 0, 0, 0, 0, 0, 0, 0, 0 },
  { "scare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scold"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scratch"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scream"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "screw"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
 { "sdedit"    , POS_DEAD , do_olc   , LVL_HEAD_B, SCMD_OLC_SDEDIT , 0, 0, 0, 0, 0 ,0 },
  { "seduce"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sell"     , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "send"     , POS_SLEEPING, do_send     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "set"      , POS_DEAD    , do_set      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "search"   , POS_DEAD    , do_search   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
  { "shout"    , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT , 0, 0, 0, 0, 0 ,0 },
  { "shake"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shapechange", POS_STANDING, do_shapechange, 0,0,0,0,0,0,0,0},
  { "shit"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shiver"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "show"     , POS_DEAD    , do_show     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shrug"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shudder"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_HEAD_C, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
  { "sigh"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sing"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sip"      , POS_RESTING , do_drink    , 0, SCMD_SIP , 0, 0, 0, 0, 0 ,0 },
  { "sit"      , POS_RESTING , do_sit      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "skillset" , POS_SLEEPING, do_skillset , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "skills"   , POS_RESTING,  do_skills   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sleep"    , POS_SLEEPING, do_sleep    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slobber"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smell"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smile"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smirk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smoke"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snicker"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snarl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sneeze"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sneak"    , POS_STANDING, do_sneak    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sniff"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snoogie"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snore"    , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snort"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snowball" , POS_STANDING, do_action   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snuggle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "socials"  , POS_DEAD    , do_commands , 0, SCMD_SOCIALS , 0, 0, 0, 0, 0 ,0 },
  { "spam"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "speak"    , POS_DEAD    , do_speak    , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "split"    , POS_SITTING , do_split    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "spells"   , POS_RESTING , do_spells   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "spank"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "spit"     , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "springleap", POS_SITTING, do_springleap, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "squeeze"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stand"    , POS_RESTING , do_stand    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stat"     , POS_DEAD    , do_stat     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "steal"    , POS_STANDING, do_steal    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "steam"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stomp"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stroke"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "strut"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sulk"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "summon mount" , POS_STANDING , do_summon_mount   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "swat"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sweat"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sweep"    , POS_FIGHTING, do_sweep    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "switch"   , POS_DEAD    , do_switch   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stone"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "subclass" , POS_RESTING , do_subclass ,0,0,0,0,0,0,0,0 },


  { "tell"     , POS_RESTING    , do_tell     , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "terminate"    , POS_DEAD    , do_terminate    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tackle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "take"     , POS_RESTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tango"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tame"     , POS_STANDING, do_tame     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tarzan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "taunt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "taste"    , POS_RESTING , do_eat      , 0, SCMD_TASTE , 0, 0, 0, 0, 0 ,0 },
  { "tease"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "tedit"    , POS_DEAD    , do_tedit    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "teleport" , POS_DEAD    , do_teleport , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "thank"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "think"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "thaw"     , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW , 0, 0, 0, 0, 0 ,0 },
  { "thirst"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "throatcut", POS_STANDING, do_throatcut, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "throw"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "title"    , POS_DEAD    , do_title    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tickle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "time"     , POS_DEAD    , do_time     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tongue"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "track"    , POS_STANDING, do_track    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "transfer" , POS_SLEEPING, do_trans    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "trigedit" , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
  { "trip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "trophy", POS_DEAD     , do_trophy    , 0, 0, 0, 0, 0, 0, 0, 0},
 { "tug"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twibble"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twiddle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO , 0, 0, 0, 0, 0 ,0 },

  { "unlock"   , POS_SITTING , do_gen_door , 0, SCMD_UNLOCK , 0, 0, 0, 0, 0 ,0 },
  { "unban"    , POS_DEAD    , do_unban    , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "unbind" , POS_DEAD, do_unbind, 0, 0, 0, 0, 0, 0, 1,0 },
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "uptime"   , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_UPTIME , 0, 0, 0, 0, 0 ,0 },
  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE , 0, 0, 0, 0, 0 ,0 },
  { "users"    , POS_DEAD    , do_users    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },

  { "value"    , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "version"  , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION , 0, 0, 0, 0, 0 ,0 },
  { "veto"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "visible"  , POS_RESTING , do_visible  , 1, 0 , 0, 0, 0, 0, 0 ,0 },
 { "viewdam"  , POS_DEAD , do_viewdam  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },

  { "wake"     , POS_SLEEPING, do_wake     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wave"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wear"     , POS_RESTING , do_wear     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wait"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "weather"  , POS_RESTING , do_weather  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whatever"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "who"      , POS_DEAD    , do_who      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI , 0, 0, 0, 0, 0 ,0 },
  { "where"    , POS_RESTING , do_where    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whisper"  , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER , 0, 0, 0, 0, 0 ,0 },
  { "whine"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whistle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wield"    , POS_RESTING , do_wield    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wiggle"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wince"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wink"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "withdraw" , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wiznet"   , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { ";"        , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wizhelp"  , POS_SLEEPING, do_commands , LVL_IMMORT, SCMD_WIZHELP , 0, 0, 0, 0, 0 ,0 },
  { "wizlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST , 0, 0, 0, 0, 0 ,0 },
  { "wizlock"  , POS_DEAD    , do_wizlock  , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "worship"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "write"    , POS_STANDING, do_write    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },

  { "yawn"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "yodel"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "zedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
  { "zone"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "zreset"   , POS_DEAD    , do_zreset   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },

  { "world"    , POS_DEAD    , do_world    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fup"      , POS_STANDING, do_move     , 0, SCMD_FUP , 0, 0, 0, 0, 0 ,0 },
  { "fdown"    , POS_STANDING, do_move     , 0, SCMD_FDOWN , 0, 0, 0, 0, 0 ,0 },


  /* DG trigger commands */
  { "attach"   , POS_DEAD    , do_attach   , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },
  { "z001#@@#"    , POS_SLEEPING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "detach"   , POS_DEAD    , do_detach   , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "masound"  , POS_DEAD    , do_masound  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mkill"    , POS_STANDING, do_mkill    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mjunk"    , POS_SITTING , do_mjunk    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mechoaround" , POS_DEAD , do_mechoaround    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "msend"    , POS_DEAD    , do_msend    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mecho"    , POS_DEAD    , do_mecho    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mload"    , POS_DEAD    , do_mload    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpurge"   , POS_DEAD    , do_mpurge    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mgoto"    , POS_DEAD    , do_mgoto    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mat"      , POS_DEAD    , do_mat      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mteleport", POS_DEAD    , do_mteleport, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mforce"   , POS_DEAD    , do_mforce   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "DumbMobTrack"    , POS_STANDING, do_DumbMobTrack , 0, 0 , 0, 0, 0, 0, 0 ,0},
  { "mexp"     , POS_DEAD    , do_mexp     , 0, 0 , 0, 0, 0, 0, 0 ,0 },




  { "\n", 0, 0, 0, 0 , 0, 0, 0, 0, 0 ,0 } };	/* this must be last */


char *fill[] =
{
  "in",
  "from",
  "with",
  "the",
  "on",
  "at",
  "to",
  "\n"
};

char *reserved[] =
{
  "self",
  "me",
  "all",
  "room",
  "someone",
  "something",
  "\n"
};

/*
 * This is the actual command interpreter called from game_loop() in comm.c
 * It makes sure you are the proper level and position to execute the command,
 * then calls the appropriate function.
 */
void command_interpreter(struct char_data *ch, char *argument)
{
  int cmd, length;
  extern int no_specials;
  char *line;

  /* just drop to next line for hitting CR */
  skip_spaces(&argument);
  if (!*argument)
    return;

  /*
   * special case to handle one-character, non-alphanumeric commands;
   * requested by many people so "'hi" or ";godnet test" is possible.
   * Patch sent by Eric Green and Stefan Wasilewski.
   */
 if (ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL]) {
	if (IS_FIGHTING(ch)) {
	  act("You ARE too determined to kill $N at the moment.",
	      FALSE, ch, 0, FIGHTING(ch), TO_CHAR);
	  return;
	}
      }
  if (!isalpha(*argument)) {
    arg[0] = argument[0];
    arg[1] = '\0';
    line = argument + 1;
  } else
    line = any_one_arg(argument, arg);

  /* otherwise, find the command */
   if ((GET_LEVEL(ch)<LVL_IMMORT) &&
      (command_wtrigger(ch, arg, line) ||
       command_mtrigger(ch, arg, line) ||
       command_otrigger(ch, arg, line)))
    return; /* command trigger took over */

  for (length = strlen(arg), cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
    if (!strncmp(cmd_info[cmd].command, arg, length))
      if (GET_LEVEL(ch) >= cmd_info[cmd].minimum_level)
	break;
  if (AFF_FLAGGED(ch, AFF_HIDE) && (cmd_info[cmd].hide == 0))
  REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);

  if(PLR_FLAGGED(ch, PLR_MEDITATE))
   if (cmd_info[cmd].meditate == 0){
          REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
          send_to_char("&8You stop meditating.\r\n&0", ch);}
  if(PLR_FLAGGED(ch, PLR_SCRIBE))
   if (cmd_info[cmd].meditate == 0){
          REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
          send_to_char("&8You stop scribing.\r\n&0", ch);}
  if(affected_by_spell(ch, SPELL_CONCEALMENT))
   if (cmd_info[cmd].hide == 0)
     appear(ch);

  if (*cmd_info[cmd].command == '\n')
    send_to_char("Huh?!?\r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_FROZEN) && GET_LEVEL(ch) < LVL_HEAD_B)
    send_to_char("You try, but the mind-numbing cold prevents you...\r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_BOUND) && GET_LEVEL(ch) < LVL_IMMORT &&
	  (cmd_info[cmd].bound == 0))
    send_to_char("You try, but your bound tight...\r\n", ch);
  else if (IS_AFFECTED(ch, AFF_MAJOR_PARA) && (cmd_info[cmd].major_p == 0))
    send_to_char("&6Your paralized to the bone!\r\n&0", ch);
  else if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) &&
       (cmd_info[cmd].minor_p == 0))
    send_to_char("&6Your paralized to the bone!\r\n&0", ch);
else if(PLR_FLAGGED(ch, PLR_CASTING) && (cmd_info[cmd].cast == 0))
	  send_to_char("&8You are busy spellcasting......\r\n&0", ch);
  else if (cmd_info[cmd].command_pointer == NULL)
    send_to_char("Sorry, that command hasn't been implemented yet.\r\n", ch);
  else if (IS_NPC(ch) && cmd_info[cmd].minimum_level >= LVL_IMMORT)
    send_to_char("You can't use immortal commands while switched.\r\n", ch);
  else if (GET_POS(ch) < cmd_info[cmd].minimum_position)
    switch (GET_POS(ch)) {
    case POS_DEAD:
      send_to_char("Lie still; you are DEAD!!! :-(\r\n", ch);
      break;
    case POS_INCAP:
    case POS_MORTALLYW:
      send_to_char("You are in a pretty bad shape, unable to do anything!\r\n", ch);
      break;
    case POS_STUNNED:
      send_to_char("All you can do right now is think about the stars!\r\n", ch);
      break;
    case POS_SLEEPING:
      send_to_char("In your dreams, or what?\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("Nah... You feel too relaxed to do that..\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("Maybe you should get on your feet first?\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("No way!  You're fighting for your life!\r\n", ch);
      break;
  }else if (no_specials || !special(ch, cmd, line))
    ((*cmd_info[cmd].command_pointer) (ch, line, cmd, cmd_info[cmd].subcmd));
}

/**************************************************************************
 * Routines to handle aliasing                                             *
  **************************************************************************/


struct alias *find_alias(struct alias *alias_list, char *str)
{
  while (alias_list != NULL) {
    if (*str == *alias_list->alias)	/* hey, every little bit counts :-) */
      if (!strcmp(str, alias_list->alias))
	return alias_list;

    alias_list = alias_list->next;
  }

  return NULL;
}



void display_question(struct descriptor_data *d)
{
//	bool used = FALSE;
	int i;
	char *stats[6] = {	"\r\n1)Working up a sweat at work or training, from dusk to dawn",
						"2)Physical Strength and Power",
						"3)Cunningness and speed on feet",
						"4)Religeon, Historical and Political Study's",
						"5)Spending most your time in the library",
						"6)Helping out your fellow neighbour"};

/*colours:	norm:CCNRM(d->character,C_SPR)
			green:CCGRN(d->character,C_SPR)
			bold:CCBLD(d->character,C_SPR)
*/
	strcpy(buf, "");
	for (i=0;i<6;i++)
	{
		if (GET_ROLL(d->character, i))
			sprintf(buf, "%s",CCGRN(d->character,C_SPR));
		else
			sprintf(buf, "%s%s",CCGRN(d->character,C_SPR), CCBLD(d->character,C_SPR));
		sprintf(buf, "%s%s&0", buf, stats[i]);
		if (GET_ROLL(d->character, i))
			sprintf(buf, "%s&0&6[&0&6&b%d&0&6]&0\r\n",buf, (int)GET_ROLL(d->character, i));
		else
			sprintf(buf, "%s\r\n", buf);

		send_to_char(buf, d->character);
	}
	send_to_char("\r\n>", d->character);
}

bool ask_question(struct descriptor_data *d, int question, char *arg)
{
	int result;
	if (!is_number(arg))
			return FALSE;
	result = atoi(arg) - 1;

	if ((result < 0) || (result > 5))
	{
		send_to_char("Incorrect choice\r\n", d->character);
		display_question(d);
		return FALSE;
	}
	if (GET_ROLL(d->character, result))
	{
		send_to_char("Sorry that option is already used.\r\n", d->character);
		return FALSE;
	}
	GET_ROLL(d->character, result) ^= question;
	return TRUE;
}


void free_alias(struct alias *a)
{
  if (a->alias)
    free(a->alias);
  if (a->replacement)
    free(a->replacement);
  free(a);
}


/* The interface to the outside world: do_alias */
ACMD(do_alias)
{
  char *repl;
  struct alias *a, *temp;

  if (IS_NPC(ch))
    return;

  repl = any_one_arg(argument, arg);

  if (!*arg) {			/* no argument specified -- list currently defined aliases */
    send_to_char("Currently defined aliases:\r\n", ch);
    if ((a = GET_ALIASES(ch)) == NULL)
      send_to_char(" None.\r\n", ch);
    else {
      while (a != NULL) {
	sprintf(buf, "%-15s %s\r\n", a->alias, a->replacement);
	send_to_char(buf, ch);
	a = a->next;
      }
    }
  } else {			/* otherwise, add or remove aliases */
    /* is this an alias we've already defined? */
    if ((a = find_alias(GET_ALIASES(ch), arg)) != NULL) {
      REMOVE_FROM_LIST(a, GET_ALIASES(ch), next);
      free_alias(a);
    }
    /* if no replacement string is specified, assume we want to delete */
    if (!*repl) {
      if (a == NULL)
	send_to_char("No such alias.\r\n", ch);
      else
	send_to_char("Alias deleted.\r\n", ch);
    } else {			/* otherwise, either add or redefine an alias */
      if (!str_cmp(arg, "alias")) {
	send_to_char("You can't alias 'alias'.\r\n", ch);
	return;
      }
      CREATE(a, struct alias, 1);
      a->alias = str_dup(arg);
      delete_doubledollar(repl);
      a->replacement = str_dup(repl);
      if (strchr(repl, ALIAS_SEP_CHAR) || strchr(repl, ALIAS_VAR_CHAR))
	a->type = ALIAS_COMPLEX;
      else
	a->type = ALIAS_SIMPLE;
      a->next = GET_ALIASES(ch);
      GET_ALIASES(ch) = a;
      send_to_char("Alias added.\r\n", ch);
    }
  }
}

/*
 * Valid numeric replacements are only $1 .. $9 (makes parsing a little
 * easier, and it's not that much of a limitation anyway.)  Also valid
 * is "$*", which stands for the entire original line after the alias.
 * ";" is used to delimit commands.
 */
#define NUM_TOKENS       9

void perform_complex_alias(struct txt_q *input_q, char *orig, struct alias *a)
{
  struct txt_q temp_queue;
  char *tokens[NUM_TOKENS], *temp, *write_point;
  int num_of_tokens = 0, num;

  /* First, parse the original string */
  temp = strtok(strcpy(buf2, orig), " ");
  while (temp != NULL && num_of_tokens < NUM_TOKENS) {
    tokens[num_of_tokens++] = temp;
    temp = strtok(NULL, " ");
  }

  /* initialize */
  write_point = buf;
  temp_queue.head = temp_queue.tail = NULL;

  /* now parse the alias */
  for (temp = a->replacement; *temp; temp++) {
    if (*temp == ALIAS_SEP_CHAR) {
      *write_point = '\0';
      buf[MAX_INPUT_LENGTH - 1] = '\0';
      write_to_q(buf, &temp_queue, 1);
      write_point = buf;
    } else if (*temp == ALIAS_VAR_CHAR) {
      temp++;
      if ((num = *temp - '1') < num_of_tokens && num >= 0) {
	strcpy(write_point, tokens[num]);
	write_point += strlen(tokens[num]);
      } else if (*temp == ALIAS_GLOB_CHAR) {
	strcpy(write_point, orig);
	write_point += strlen(orig);
      } else if ((*(write_point++) = *temp) == '$')	/* redouble $ for act safety */
	*(write_point++) = '$';
    } else
      *(write_point++) = *temp;
  }

  *write_point = '\0';
  buf[MAX_INPUT_LENGTH - 1] = '\0';
  write_to_q(buf, &temp_queue, 1);

  /* push our temp_queue on to the _front_ of the input queue */
  if (input_q->head == NULL)
    *input_q = temp_queue;
  else {
    temp_queue.tail->next = input_q->head;
    input_q->head = temp_queue.head;
  }
}


/*
 * Given a character and a string, perform alias replacement on it.
 *
 * Return values:
 *   0: String was modified in place; call command_interpreter immediately.
 *   1: String was _not_ modified in place; rather, the expanded aliases
 *      have been placed at the front of the character's input queue.
 */
int perform_alias(struct descriptor_data *d, char *orig)
{
  char first_arg[MAX_INPUT_LENGTH], *ptr;
  struct alias *a, *tmp;

  /* bail out immediately if the guy doesn't have any aliases */
  if ((tmp = GET_ALIASES(d->character)) == NULL)
    return 0;

  /* find the alias we're supposed to match */
  ptr = any_one_arg(orig, first_arg);

  /* bail out if it's null */
  if (!*first_arg)
    return 0;

  /* if the first arg is not an alias, return without doing anything */
  if ((a = find_alias(tmp, first_arg)) == NULL)
    return 0;

  if (a->type == ALIAS_SIMPLE) {
    strcpy(orig, a->replacement);
    return 0;
  } else {
    perform_complex_alias(&d->input, ptr, a);
    return 1;
  }
}



/***************************************************************************
 * Various other parsing utilities                                         *
 **************************************************************************/

/*
 * searches an array of strings for a target string.  "exact" can be
 * 0 or non-0, depending on whether or not the match must be exact for
 * it to be returned.  Returns -1 if not found; 0..n otherwise.  Array
 * must be terminated with a '\n' so it knows to stop searching.
 */
int search_block(char *arg, char **list, bool exact)
{
  register int i, l;

  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strcmp(arg, *(list + i)))
	return (i);
  } else {
    if (!l)
      l = 1;			/* Avoid "" to match the first available
				 * string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strncmp(arg, *(list + i), l))
	return (i);
  }

  return -1;
}

int search_block2(char *arg, char **list, int exact)
{
  register int i, l;

  if (!arg)
    return -1;

  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!str_cmp(arg, *(list + i)))
	return (i);
  } else {
    if (!l)
      l = 1;			/* Avoid "" to match the first available
string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strn_cmp(arg, *(list + i), (unsigned) l))
	return (i);
  }

  return (-1);
}

int is_number(char *str)
{
  while (*str)
    if (!isdigit(*(str++)))
      return 0;

  return 1;
}


void skip_spaces(char **string)
{
  for (; **string && isspace(**string); (*string)++);
}


char *delete_doubledollar(char *string)
{
  char *read, *write;

  if ((write = strchr(string, '$')) == NULL)
    return string;

  read = write;

  while (*read)
    if ((*(write++) = *(read++)) == '$')
      if (*read == '$')
	read++;

  *write = '\0';

  return string;
}


int fill_word(char *argument)
{
  return (search_block(argument, fill, TRUE) >= 0);
}


int reserved_word(char *argument)
{
  return (search_block(argument, reserved, TRUE) >= 0);
}


/*
 * copy the first non-fill-word, space-delimited argument of 'argument'
 * to 'first_arg'; return a pointer to the remainder of the string.
 */
char *one_argument(char *argument, char *first_arg)
{
  char *begin = first_arg;

  do {
    skip_spaces(&argument);

    first_arg = begin;
    while (*argument && !isspace(*argument)) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }

    *first_arg = '\0';
  } while (fill_word(begin));

  return argument;
}


/*
 * one_word is like one_argument, except that words in quotes ("") are
 * considered one word.
 */
char *one_word(char *argument, char *first_arg)
{
  char *begin = first_arg;

  do {
    skip_spaces(&argument);

    first_arg = begin;

    if (*argument == '\"') {
      argument++;
      while (*argument && *argument != '\"') {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
      argument++;
    } else {
      while (*argument && !isspace(*argument)) {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
    }

    *first_arg = '\0';
  } while (fill_word(begin));

  return argument;
}


/* same as one_argument except that it doesn't ignore fill words */
char *any_one_arg(char *argument, char *first_arg)
{
  skip_spaces(&argument);

  while (*argument && !isspace(*argument)) {
    *(first_arg++) = LOWER(*argument);
    argument++;
  }

  *first_arg = '\0';

  return argument;
}


/*
 * Same as one_argument except that it takes two args and returns the rest;
 * ignores fill words
 */
char *two_arguments(char *argument, char *first_arg, char *second_arg)
{
  return one_argument(one_argument(argument, first_arg), second_arg); /* :-) */
}



/*
 * determine if a given string is an abbreviation of another
 * (now works symmetrically -- JE 7/25/94)
 *
 * that was dumb.  it shouldn't be symmetrical.  JE 5/1/95
 *
 * returnss 1 if arg1 is an abbreviation of arg2
 */
int is_abbrev(char *arg1, char *arg2)
{
  if (!*arg1)
    return 0;

  for (; *arg1 && *arg2; arg1++, arg2++)
    if (LOWER(*arg1) != LOWER(*arg2))
      return 0;

  if (!*arg1)
    return 1;
  else
    return 0;
}
void display_classes(struct descriptor_data *d, int select) {
  int x;
  int char_race;
  int mageok, warriorok, rogueok, clericok, shamanok;

  char_race = (int)GET_RACE(d->character);
  *buf = '\0';
  *buf2 = '\0';
  mageok = class_ok_race[char_race][CLASS_MAGIC_USER];
  warriorok = class_ok_race[char_race][CLASS_WARRIOR];
  rogueok = class_ok_race[char_race][CLASS_ROGUE];
  clericok = class_ok_race[char_race][CLASS_CLERIC];
  shamanok = 0;
  /* commenter out by Fingh 11/7 class_ok_race[char_race][CLASS_SHAMAN]; */
  if(select){
    send_to_char(subclass_descrip, d->character);
    send_to_char("\r\n&5Class selection menu - ",d->character);
  }
  send_to_char("&1&b(&0&5*&1&b) denotes a class available to your race!&0&5\r\n\r\n", d->character);

/*
  for (x = 0; x < NUM_CLASSES; x++)
    if (class_ok_race[(int)GET_RACE(d->character)][x])
      send_to_char(class_display[x], d->character);
      send_to_char("\nClass: ", d->character);
*/
/* Subclassing explaination/preface */
  sprintf(buf,"&5&b");
  if(warriorok){
    sprintf(buf, "%s%-16.16s ", buf,
     strip_ansi(pc_class_types[CLASS_WARRIOR]));
    sprintf(buf2, "%-16.16s ", "=======");
  }
  if(clericok) {
    sprintf(buf, "%s%-16.16s ", buf,
     strip_ansi(pc_class_types[CLASS_CLERIC]));
    sprintf(buf2, "%s%-16.16s ", buf2, "======");
  }
  if(mageok) {
    sprintf(buf, "%s%-16.16s ", buf,
     strip_ansi(pc_class_types[CLASS_MAGIC_USER]));
    sprintf(buf2, "%s%-16.16s ", buf2, "========");
  }
  if(rogueok) {
    sprintf(buf, "%s%-16.16s ", buf,
     strip_ansi(pc_class_types[CLASS_ROGUE]));
    sprintf(buf2, "%s%-16.16s ", buf2, "=====");
  }
  if(shamanok) {
    sprintf(buf, "%s%-16.16s", buf,
     strip_ansi(pc_class_types[CLASS_SHAMAN]));
    sprintf(buf2, "%s%-16.16s", buf2, "======");
  }
  sprintf(buf,"%s\r\n", buf);
  send_to_char(buf, d->character);
  send_to_char(buf2, d->character);
  sprintf(buf, "\r\n&5");
  for (x=0;x<MAX(MAX(MAX(WARRIOR_SUBCLASSES, CLERIC_SUBCLASSES), MAGE_SUBCLASSES), ROGUE_SUBCLASSES);x++) {
   if(warriorok)
    if (x < WARRIOR_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf,
	class_ok_race[char_race][warrior_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[warrior_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(clericok)
    if (x < CLERIC_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf,
	class_ok_race[char_race][cleric_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[cleric_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(mageok)
    if (x < MAGE_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf,
	class_ok_race[char_race][mage_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[mage_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(rogueok)
    if (x < ROGUE_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s", buf,
	class_ok_race[char_race][rogue_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[rogue_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s", buf, " ");

   sprintf(buf, "%s\r\n", buf);
  }
  if(select)
    sprintf(buf, "%s\r\n&1Choose %s %s %s %s %s or [&b?&0&1] for help: &0", buf,
	warriorok ? "[&bw&0&1]arrior," : "",
	clericok ? "[&bc&0&1]leric," : "",
	mageok ? "[&bs&0&1]orcerer," : "",
	rogueok ? "[&br&0&1]ogue," : "",
	shamanok ? "s[&bh&0&1]aman," : "");
  send_to_char(buf, d->character);
  send_to_char("&0", d->character);

}

void display_hometown(int race, int class, struct descriptor_data *d)
{
	int a = 0;
	int c = 0;
	char *b[] = {"1)", "2)", "3)", "4)", "5)"};
	int result_rooms[10];
	int x;
	room_selector(race, class, result_rooms, TRUE);

	send_to_char("\n\n\r&0&8&bPlease choose a hometown.&0\r\n", d->character);

	for (a = 0; result_rooms[a] != -1; a++)
	{
		x = result_rooms[a];
		send_to_char(b[c], d->character);c++;
		send_to_char(char_hometown[x], d->character);
	}

}

/* return first space-delimited token in arg1; remainder of string in arg2 */
void half_chop(char *string, char *arg1, char *arg2)
{
  char *temp;

  temp = any_one_arg(string, arg1);
  skip_spaces(&temp);
  strcpy(arg2, temp);
}



/* Used in specprocs, mostly.  (Exactly) matches "command" to cmd number */
int find_command(char *command)
{
  int cmd;

  for (cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
    if (!strcmp(cmd_info[cmd].command, command))
      return cmd;

  return -1;
}


int special(struct char_data *ch, int cmd, char *arg)
{
  register struct obj_data *i;
  register struct char_data *k;
  int j;

  /* special in room? */
  if (GET_ROOM_SPEC(ch->in_room) != NULL)
    if (GET_ROOM_SPEC(ch->in_room) (ch, world + ch->in_room, cmd, arg))
      return 1;

  /* special in equipment list? */
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j) && GET_OBJ_SPEC(GET_EQ(ch, j)) != NULL)
      if (GET_OBJ_SPEC(GET_EQ(ch, j)) (ch, GET_EQ(ch, j), cmd, arg))
	return 1;

  /* special in inventory? */
  for (i = ch->carrying; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
	return 1;

  /* special in mobile present? */
  for (k = world[ch->in_room].people; k; k = k->next_in_room)
    if (GET_MOB_SPEC(k) != NULL)
      if (GET_MOB_SPEC(k) (ch, k, cmd, arg))
	return 1;

  /* special in object present? */
  for (i = world[ch->in_room].contents; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
	return 1;

  return 0;
}



/* *************************************************************************
*  Stuff for controlling the non-playing sockets (get name, pwd etc)       *
************************************************************************* */


/* locate entry in p_table with entry->name == name. -1 mrks failed search */
int find_name(char *name)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++) {
    if (!str_cmp((player_table + i)->name, name))
      return i;
  }

  return -1;
}


#define RECON		1
#define USURP		2
#define UNSWITCH	3

int perform_dupe_check(struct descriptor_data *d)
{
  struct descriptor_data *k, *next_k;
  struct char_data *target = NULL, *ch, *next_ch;
  int mode = 0;

  int id = GET_IDNUM(d->character);

  /*
   * Now that this descriptor has successfully logged in, disconnect all
   * other descriptors controlling a character with the same ID number.
   */

  for (k = descriptor_list; k; k = next_k) {
    next_k = k->next;

    if (k == d)
      continue;

    if (k->original && (GET_IDNUM(k->original) == id)) {    /* switched char */
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
      if (!target) {
	target = k->original;
	mode = UNSWITCH;
      }
      if (k->character)
	k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
    } else if (k->character && (GET_IDNUM(k->character) == id)) {
      if (!target && STATE(k) == CON_PLAYING) {
	SEND_TO_Q("\r\nThis body has been usurped!\r\n", k);
	target = k->character;
	mode = USURP;
      }
      k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
    }
  }

 /*
  * now, go through the character list, deleting all characters that
  * are not already marked for deletion from the above step (i.e., in the
  * CON_HANGUP state), and have not already been selected as a target for
  * switching into.  In addition, if we haven't already found a target,
  * choose one if one is available (while still deleting the other
  * duplicates, though theoretically none should be able to exist).
  */

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    if (IS_NPC(ch))
      continue;
    if (GET_IDNUM(ch) != id)
      continue;

    /* ignore chars with descriptors (already handled by above step) */
    if (ch->desc)
      continue;

    /* don't extract the target char we've found one already */
    if (ch == target)
      continue;

    /* we don't already have a target and found a candidate for switching */
    if (!target) {
      target = ch;
      mode = RECON;
      continue;
    }

    /* we've found a duplicate - blow him away, dumping his eq in limbo. */
    if (ch->in_room != NOWHERE)
      char_from_room(ch);
    char_to_room(ch, 1);
    extract_char(ch);
  }

  /* no target for swicthing into was found - allow login to continue */
  if (!target)
    return 0;

  /* Okay, we've found a target.  Connect d to target. */
  free_char(d->character); /* get rid of the old char */
  d->character = target;
  d->character->desc = d;
  d->original = NULL;
  d->character->char_specials.timer = 0;
  REMOVE_BIT(PLR_FLAGS(d->character), PLR_MAILING | PLR_WRITING);
  STATE(d) = CON_PLAYING;

  switch (mode) {
  case RECON:
    SEND_TO_Q("Reconnecting.\r\n", d);
    act("$n has reconnected.", TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case USURP:
    SEND_TO_Q("Overriding old connection.\r\n", d);
    act("$n suddenly keels over in pain, surrounded by a white aura...\r\n"
	"$n's body has been taken over by a new spirit!",
	TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s has re-logged in ... disconnecting old socket.",
	    GET_NAME(d->character));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case UNSWITCH:
    SEND_TO_Q("Reconnecting to unswitched char.", d);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  }

  return 1;
}



/* deal with newcomers and other non-playing sockets */
void nanny(struct descriptor_data *d, char *arg)
{
  char buf[128];
  int player_i, load_result;
  char tmp_name[MAX_INPUT_LENGTH];
  struct char_file_u tmp_store;
  extern int r_mortal_start_room;
  extern int r_immort_start_room;
  extern int r_frozen_start_room;
  extern char *race_menu;
  extern char *stats_display;
  extern char *ANSI;
  extern char *GREETINGS;
  extern int max_bad_pws;
  int load_room;
  int choice_table[6] = {0};


  int color = 0;
  int set_new_home_town(int race, int class, char);
  int i;

  int load_char(char *name, struct char_file_u *char_element);
  /*int parse_class(char arg);*/
  int parse_class(struct char_data *ch, char arg);

  skip_spaces(&arg);

  if (d->character == NULL) {
    CREATE(d->character, struct char_data, 1);
    clear_char(d->character);
    CREATE(d->character->player_specials, struct player_special_data, 1);
    d->character->desc = d;
  }


  switch (STATE(d)) {
   /*. OLC states .*/
   case CON_OEDIT:
     oedit_parse(d, arg);
     break;
   case CON_REDIT:
     redit_parse(d, arg);
     break;
   case CON_ZEDIT:
     zedit_parse(d, arg);
     break;
   case CON_MEDIT:
     medit_parse(d, arg);
     break;
   case CON_SEDIT:
     sedit_parse(d, arg);
     break;
   case CON_HEDIT:
    hedit_parse(d, arg);
    break;
   case CON_TRIGEDIT:
    trigedit_parse(d, arg);
    break;
      case CON_SDEDIT:
       sdedit_parse(d, arg);
       break;
   /*. End of OLC states .*/


   case CON_QANSI:
     if (!*arg || LOWER(*arg) == 'y') {
       SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
       SEND_TO_Q("Color is on.\r\n", d);
       SEND_TO_Q(GREETINGS, d);
     } else if (LOWER(*arg) == 'n') {
       REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
       SEND_TO_Q("Color is off.\r\n", d);
       SEND_TO_Q(GREETINGS, d);
     } else {
       SEND_TO_Q("That is not a proper response.\r\n", d);
       SEND_TO_Q(ANSI, d);
       return;
    }
    STATE(d) = CON_GET_NAME;
    break;
  case CON_GET_NAME:
    if (!*arg)
      close_socket(d);
    else {
      if ((_parse_name(arg, tmp_name)) || strlen(tmp_name) < 2 ||
	  strlen(tmp_name) > MAX_NAME_LENGTH ||
	  fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
	SEND_TO_Q("Invalid name, please try another.\r\n"
		  "Name: ", d);
	return;
      }
      if ((player_i = load_char(tmp_name, &tmp_store)) > -1) {
        if (PRF_FLAGGED(d->character, PRF_COLOR_1))
          color = 1;

	store_to_char(&tmp_store, d->character);
	GET_PFILEPOS(d->character) = player_i;
	/*Loads real stats*/
load_results(d->character);
change_affected_stats(d->character);

	if (PLR_FLAGGED(d->character, PLR_DELETED)) {
	  free_char(d->character);
	  CREATE(d->character, struct char_data, 1);
	  clear_char(d->character);
	  CREATE(d->character->player_specials, struct player_special_data, 1);
	  d->character->desc = d;
	  CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
	  strcpy(d->character->player.name, CAP(tmp_name));
	  GET_PFILEPOS(d->character) = player_i;

  	  if (color)
  	    SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
  	  else
   	    REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);

	  sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
	  SEND_TO_Q(buf, d);
	  STATE(d) = CON_NAME_CNFRM;
	} else {
	  /* undo it just in case they are set */
	  REMOVE_BIT(PLR_FLAGS(d->character),
		     PLR_WRITING | PLR_MAILING | PLR_CRYO);

           if (color)
             SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
           else
             REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);

	  SEND_TO_Q("Password: ", d);
	  echo_off(d);
	  d->idle_tics = 0;
	  STATE(d) = CON_PASSWORD;
	}
      } else {
	/* player unknown -- make new character */

	if (!Valid_Name(tmp_name)) {
	  SEND_TO_Q("Invalid name, please try another.\r\n", d);
	  SEND_TO_Q("Name: ", d);
	  return;
	}
	CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
	strcpy(d->character->player.name, CAP(tmp_name));

	sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
	SEND_TO_Q(buf, d);
	STATE(d) = CON_NAME_CNFRM;
      }
    }
    break;
  case CON_NAME_CNFRM:		/* wait for conf. of new name    */
    if (UPPER(*arg) == 'Y') {
      if (isbanned(d->host) >= BAN_NEW) {
	sprintf(buf, "Request for new char %s denied from [%s] (siteban)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	SEND_TO_Q("Sorry, new characters are not allowed from your site!\r\n", d);
	STATE(d) = CON_CLOSE;
	return;
      }
      if (restrict) {
	SEND_TO_Q("Sorry, new players can't be created at the moment.\r\n", d);
	sprintf(buf, "Request for new char %s denied from %s (wizlock)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	STATE(d) = CON_CLOSE;
	return;
      }
      SEND_TO_Q("New character.\r\n", d);
      sprintf(buf, "Give me a password for %s: ", GET_NAME(d->character));
      SEND_TO_Q(buf, d);
      echo_off(d);
      STATE(d) = CON_NEWPASSWD;
    } else if (*arg == 'n' || *arg == 'N') {
      SEND_TO_Q("Okay, what IS it, then? ", d);
      free(d->character->player.name);
      d->character->player.name = NULL;
      STATE(d) = CON_GET_NAME;
    } else {
      SEND_TO_Q("Please type Yes or No: ", d);
    }
    break;
  case CON_PASSWORD:		/* get pwd for known player      */
    /*
     * To really prevent duping correctly, the player's record should
     * be reloaded from disk at this point (after the password has been
     * typed).  However I'm afraid that trying to load a character over
     * an already loaded character is going to cause some problem down the
     * road that I can't see at the moment.  So to compensate, I'm going to
     * (1) add a 15 or 20-second time limit for entering a password, and (2)
     * re-add the code to cut off duplicates when a player quits.  JE 6 Feb 96
     */

    echo_on(d);    /* turn echo back on */

    if (!*arg)
      close_socket(d);
    else {
      if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
	sprintf(buf, "Bad PW: %s [%s]", GET_NAME(d->character), d->host);
	mudlog(buf, BRF, LVL_GOD, TRUE);
	GET_BAD_PWS(d->character)++;
	save_char(d->character, NOWHERE);
	if (++(d->bad_pws) >= max_bad_pws) {	/* 3 strikes and you're out. */
	  SEND_TO_Q("Wrong password... disconnecting.\r\n", d);
	  STATE(d) = CON_CLOSE;
	} else {
	  SEND_TO_Q("Wrong password.\r\nPassword: ", d);
	  echo_off(d);
	}
	return;
      }
      load_result = GET_BAD_PWS(d->character);
      GET_BAD_PWS(d->character) = 0;

      if (isbanned(d->host) == BAN_SELECT &&
	  !PLR_FLAGGED(d->character, PLR_SITEOK)) {
	SEND_TO_Q("Sorry, this char has not been cleared for login from your site!\r\n", d);
	STATE(d) = CON_CLOSE;
	sprintf(buf, "Connection attempt for %s denied from %s",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	return;
      }
      if (GET_LEVEL(d->character) < restrict) {
	SEND_TO_Q("The game is temporarily restricted.. try again later.\r\n", d);
	STATE(d) = CON_CLOSE;
	sprintf(buf, "Request for login denied for %s [%s] (wizlock)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	return;
      }
      /* check and make sure no other copies of this player are logged in */
      if (perform_dupe_check(d))
	return;

      if (GET_LEVEL(d->character) >= LVL_IMMORT)
	SEND_TO_Q(imotd, d);
      else
	SEND_TO_Q(motd, d);

      sprintf(buf, "%s [%s] has connected.", GET_NAME(d->character), d->host);
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);

      if (load_result) {
	sprintf(buf, "\r\n\r\n\007\007\007"
		"%s%d LOGIN FAILURE%s SINCE LAST SUCCESSFUL LOGIN.%s\r\n",
		CCRED(d->character, C_SPR), load_result,
		(load_result > 1) ? "S" : "", CCNRM(d->character, C_SPR));
	SEND_TO_Q(buf, d);
	GET_BAD_PWS(d->character) = 0;
      }
      SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
      STATE(d) = CON_RMOTD;
    }
    break;

  case CON_NEWPASSWD:
  case CON_CHPWD_GETNEW:
    if (!*arg || strlen(arg) > MAX_PWD_LENGTH || strlen(arg) < 3 ||
	!str_cmp(arg, GET_NAME(d->character))) {
      SEND_TO_Q("\r\nIllegal password.\r\n", d);
      SEND_TO_Q("Password: ", d);
      return;
    }
    strncpy(GET_PASSWD(d->character), CRYPT(arg, GET_NAME(d->character)), MAX_PWD_LENGTH);
    *(GET_PASSWD(d->character) + MAX_PWD_LENGTH) = '\0';

    SEND_TO_Q("\r\nPlease retype password: ", d);
    if (STATE(d) == CON_NEWPASSWD)
      STATE(d) = CON_CNFPASSWD;
    else
      STATE(d) = CON_CHPWD_VRFY;

    break;

  case CON_CNFPASSWD:
  case CON_CHPWD_VRFY:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character),
		MAX_PWD_LENGTH)) {
      SEND_TO_Q("\r\nPasswords don't match... start over.\r\n", d);
      SEND_TO_Q("Password: ", d);
      if (STATE(d) == CON_CNFPASSWD)
	STATE(d) = CON_NEWPASSWD;
      else
	STATE(d) = CON_CHPWD_GETNEW;
      return;
    }
    echo_on(d);

    if (STATE(d) == CON_CNFPASSWD) {
      SEND_TO_Q("What is your sex (M/F)? ", d);
      STATE(d) = CON_QSEX;
    } else {
      save_char(d->character, NOWHERE);
      echo_on(d);
      SEND_TO_Q("\r\nDone.\n\r", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    }

    break;

  case CON_QSEX:		/* query sex of new user         */
    switch (*arg) {
    case 'm':
    case 'M':
      d->character->player.sex = SEX_MALE;
      break;
    case 'f':
    case 'F':
      d->character->player.sex = SEX_FEMALE;
      break;
    default:
      SEND_TO_Q("That is not a sex..\r\n"
		"What IS your sex? ", d);
      return;
      break;
    }

    SEND_TO_Q(race_menu, d);
    SEND_TO_Q("\r\nRace: ", d);
    STATE(d) = CON_QRACE;
    break;
	case CON_QRACE:
		load_result = parse_race(*arg);
		if (load_result == RACE_UNDEFINED) {
			SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
			return;
		} else
			GET_RACE(d->character) = load_result;


	display_classes(d,1);

			STATE(d) = CON_QCLASS;
			break;






 case CON_QCLASS:
/*
    load_result = parse_class(d->character, *arg);
    if (load_result == CLASS_UNDEFINED) {
      SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
      return;
    } else
      GET_CLASS(d->character) = load_result;
*/
   switch (*arg) {
     case 'w':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_WARRIOR])
	  load_result = CLASS_WARRIOR;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'c':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_CLERIC])
	  load_result = CLASS_CLERIC;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 's':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_MAGIC_USER])
	  load_result = CLASS_MAGIC_USER;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'r':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_ROGUE])
	  load_result = CLASS_ROGUE;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'h':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_SHAMAN])
	  load_result = CLASS_SHAMAN;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case '?':
	sprintf(buf2, "Class Help Menu\r\n-=-=-=-=-=-=-=-\r\n");
	for(i=0;i<NUM_CLASSES;i++)
	  sprintf(buf2, "%s%s\r\n", buf2, class_display[i]);
	sprintf(buf2, "%s0) Back to Class Selection\r\n\r\nSelection: ",buf2);
	page_string(d, buf2, 0);
	  STATE(d) = CON_CLASSHELP;
	  return;
     default:
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;

   }
   GET_CLASS(d->character) = load_result;

/*Start of Rollor opperations*/



	display_hometown(GET_RACE(d->character), GET_CLASS(d->character),
d);

	STATE(d) = CON_QHOMETOWN;
	break;

case CON_CLASSHELP:
	if (!*arg || *arg == '0') {
	  display_classes(d,1);
	  STATE(d) = CON_QCLASS;
	  return;
	}
        load_result = parse_class(NULL, *arg);
        if (load_result == CLASS_UNDEFINED) {
          SEND_TO_Q("\r\nInvalid selection.\r\nSelection (0 to quit): ", d);
          return;
        } else {
          do_help(d->character, strip_ansi(class_display[load_result]+3),0,0);
	  send_to_char("Select a-x,  0 to quit: ",d->character);
	  return;
	}
	break;

case CON_QHOMETOWN:

	load_result = set_new_home_town(GET_RACE(d->character),
GET_CLASS(d->character), *arg);

	  if (load_result == UNDEFINED_HOME_NO) {
      SEND_TO_Q("\r\n&0&1That's not a hometown.\r\n&0&8&bHometown:&0 ", d);
      return;
    } else
      GET_HOME(d->character) = load_result;
     /* commented out by FINGH, do NOT delete.
      * SEND_TO_Q(diety_selection, d);
      * SEND_TO_Q("\r\nDiety:", d);
      * STATE(d) = CON_QDIETY;
     */
		send_to_char("Please put these in the order they most appeal to you:", d->character);
        display_question(d);
		STATE(d) = CON_QQUESTION1;
        break;

      /* illegal case as of 10/31/98 -fingh */
      case CON_QDIETY:
        load_result = 0;
        load_result = parse_diety(d->character, *arg);
	if(load_result == INVALID_DIETY)
        {
          SEND_TO_Q("You cannot worship that diety.\r\nDiety:", d);
          return;
        }
        else
          GET_DIETY(d->character) = load_result;
        SEND_TO_Q(question1, d);
        STATE(d) = CON_QQUESTION1;
        break;

	  case CON_QQUESTION1:
		if (!ask_question(d, 1, arg))
		{
			send_to_char("Please re-try your first choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your second stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION2;
		break;

	  case CON_QQUESTION2:

		if (!ask_question(d, 2, arg))
		{
			send_to_char("Please re-try your second choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your third stat:", d->character);
		display_question(d);
	STATE(d) = CON_QQUESTION3;
		  break;


	  case CON_QQUESTION3:
		if (!ask_question(d, 3, arg))
		{
			send_to_char("Please re-try your third choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your fourth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION4;
		break;

	  case CON_QQUESTION4:

		if (!ask_question(d, 4, arg))
		{
			send_to_char("Please re-try your fourth choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your fifth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION5;
		break;

	  case CON_QQUESTION5:

		if (!ask_question(d, 5, arg))
		{
			send_to_char("Please re-try your fifth choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your sixth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION6;
		break;


	  case CON_QQUESTION6:

		if (!ask_question(d, 6, arg))
		{
			send_to_char("Please re-try your sixth choice:", d->character);
			display_question(d);
			return;
		}
		display_question(d);
		send_to_char("Your choices are complete.\r\n", d->character);
		SEND_TO_Q("Please press return to roll your stats", d);
		STATE(d) = CON_QROLLSTATS;
		break;


	 case CON_QROLLSTATS:

		  switch (*arg) {
      case 'y':
      case 'Y':
          if ((GET_STR_VIEW(d->character)) > 0)
		  break;
      case 'n':
      case 'N':
      default:


		roll_view_abils(d->character, choice_table);
		load_results(d->character);
		change_affected_stats(d->character);
		new_rollor_display(d->character, roll_table);
		sprintf(buf, "\r\n\r	Con:  %s		Wis:  %s\r\n"
		"	Str:  %s		Intel:%s\r\n"
		"	Dex:  %s		Char: %s\r\r\r\r\n",
rolls_abils_result[roll_table[4]],  rolls_abils_result[roll_table[2]],
		rolls_abils_result[roll_table[0]],
rolls_abils_result[roll_table[1]], rolls_abils_result[roll_table[3]],
rolls_abils_result[roll_table[5]]);
		SEND_TO_Q(buf, d);
        SEND_TO_Q("\r\n\nYou may keep these stats if you wish (&0&6Enter y&0),\r\nor if you wish"
		" you may try for better stats (&0&6Enter n&0)(y/n):", d);
		return;

	}


    	 SEND_TO_Q("\r\r\n\n&0&7&bYou have three bonus's to use choose the stat carefully:&0\n\r", d);
		 SEND_TO_Q(stats_display, d);
		 SEND_TO_Q("\r\n&0&7&bPlease enter your first bonus selection:&0\n\r",d);
		 STATE(d) = CON_QBONUS1;
	   	break;
		case CON_QBONUS1:
		load_result = bonus_stat(d->character, *arg);
		if (!load_result) {
			SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}
		SEND_TO_Q(stats_display, d);
    	 SEND_TO_Q("\r\n&0&7&bPlease enter your second bonus selection:&0\n\r",d);


			STATE(d) = CON_QBONUS2;
		break;
		case CON_QBONUS2:
		load_result = bonus_stat(d->character, *arg);
		if (!load_result) {
			SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}
			SEND_TO_Q(stats_display, d);
    	SEND_TO_Q("\r\n&0&7&bPlease enter your third bonus selection:&0\n\r",d);


			STATE(d) = CON_QBONUS3;
			 break;
		case CON_QBONUS3:
			load_result = bonus_stat(d->character, *arg);
	load_results(d->character);
change_affected_stats(d->character);
			if (!load_result) {
			  	SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}

 		SEND_TO_Q("&0&4\r\n\r\nRolling for this character is complete!!\r\n"
			"&0&4&bDo you wish to keep this character(y)?('n' will take you back to start menu)\r\n&0", d);
			STATE(d) = CON_QCANCHAR;
			break;
		case CON_QCANCHAR:
		 	*arg = LOWER(*arg);
			if (*arg == 'n') {
				GET_STR_VIEW(d->character) = 0;
            for (i=0;i<6;i++)
	         {
		         (int)GET_ROLL(d->character, i) = NULL;
            }

            SEND_TO_Q("What is your sex (M/F)? ", d);
				STATE(d) = CON_QSEX;
			break;
			}


if (GET_PFILEPOS(d->character) < 0)
      GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
    init_char(d->character);
    save_char(d->character, NOWHERE);

  SEND_TO_Q(motd, d);
    SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
    STATE(d) = CON_RMOTD;

    sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, LVL_IMMORT, TRUE);
    break;



  case CON_RMOTD:		/* read CR after printing motd   */
    SEND_TO_Q(MENU, d);
    STATE(d) = CON_MENU;
    break;

  case CON_MENU:		/* get selection from main menu  */
    switch (*arg) {
    case '0':
      close_socket(d);
      break;
  case '1':
     	 reset_char(d->character);
      if (PLR_FLAGGED(d->character, PLR_INVSTART))
	GET_INVIS_LEV(d->character) = GET_LEVEL(d->character);
	  GET_RACE_ALIGN(d->character) = set_race_align(d->character);
      if ((load_room = GET_LOADROOM(d->character)) != NOWHERE)
	load_room = real_room(load_room);

      /* If char was saved with NOWHERE, or real_room above failed... */
      if (load_room == NOWHERE) {
		  if (GET_LEVEL(d->character) >= LVL_IMMORT) {
		  	  load_room = real_room(GET_HOME(d->character));
			  if (load_room < 0) {
			  log("SYSERR:  A Immortal start room does not exis.");
			  load_room = r_immort_start_room;
					}
		  } else {
			  load_room = real_room(GET_HOME(d->character));
			  if (load_room < 0) {
			  log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
			  load_room = r_mortal_start_room;
					}
		  }
	  }

      if (PLR_FLAGGED(d->character, PLR_FROZEN))

	load_room = r_frozen_start_room;

      char_to_room(d->character, load_room);
	   if ((load_result = Crash_load(d->character)))
 	if (GET_LEVEL(d->character) < LVL_IMMORT &&
 	    !PLR_FLAGGED(d->character, PLR_FROZEN)) {
 	  char_from_room(d->character);
 	  char_to_room(d->character, load_room);
 	}
       GET_ID(d->character) = GET_IDNUM(d->character);
       save_char(d->character, NOWHERE);
       send_to_char(WELC_MESSG, d->character);
       d->character->next = character_list;
       character_list = d->character;
      act("$n has entered the game.", TRUE, d->character, 0, 0, TO_ROOM);

      STATE(d) = CON_PLAYING;
      if (!GET_LEVEL(d->character)) {
	do_start(d->character);
	send_to_char(START_MESSG, d->character);
	do_newbie(d->character);
      }
      look_at_room(d->character, 0);
      if (has_mail(GET_IDNUM(d->character)))
	send_to_char("You have mail waiting.\r\n", d->character);
      if (load_result == 2) {	/* rented items lost */
	send_to_char("\r\n\007You could not afford your rent!\r\n"
	  "Your possesions have been donated to the Salvation Army!\r\n",
		     d->character);
      }
      d->prompt_mode = 1;
	  break;

    case '2': /*This may be cause of pfile barfing. -Nechtrous */
      SEND_TO_Q("Player description disabled temporarily\r\n", d);
      STATE(d) = CON_MENU;
      break;
      /* Remove above 3 lines when description debugged */
      SEND_TO_Q("Enter the text you'd like others to see when they look at you.\r\n", d);
      SEND_TO_Q("(/s saves /h for help)\r\n", d);
        if (d->character->player.description) {
 	SEND_TO_Q("Current description:\r\n", d);
  	SEND_TO_Q(d->character->player.description, d);
 	/* don't free this now... so that the old description gets loaded */
 	/* as the current buffer in the editor */
 	/* free(d->character->player.description); */
 	/* d->character->player.description = NULL; */
 	/* BUT, do setup the ABORT buffer here */
 	d->backstr = str_dup(d->character->player.description);
      }
      d->str = &d->character->player.description;
      d->max_str = EXDSCR_LENGTH;
      STATE(d) = CON_EXDESC;
      break;

    case '3':
      page_string(d, background, 0);
      STATE(d) = CON_RMOTD;
      break;

    case '4':
      SEND_TO_Q("\r\nEnter your old password: ", d);
      echo_off(d);
      STATE(d) = CON_CHPWD_GETOLD;
      break;

    case '5':
      SEND_TO_Q("\r\nEnter your password for verification: ", d);
      echo_off(d);
      STATE(d) = CON_DELCNF1;
      break;

    default:
      SEND_TO_Q("\r\nThat's not a menu choice!\r\n", d);
      SEND_TO_Q(MENU, d);
      break;
    }

    break;

  case CON_CHPWD_GETOLD:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      echo_on(d);
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
      return;
    } else {
      SEND_TO_Q("\r\nEnter a new password: ", d);
      STATE(d) = CON_CHPWD_GETNEW;
      return;
    }
    break;

  case CON_DELCNF1:
    echo_on(d);
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    } else {
      SEND_TO_Q("\r\nYOU ARE ABOUT TO DELETE THIS CHARACTER PERMANENTLY.\r\n"
		"ARE YOU ABSOLUTELY SURE?\r\n\r\n"
		"Please type \"yes\" to confirm: ", d);
      STATE(d) = CON_DELCNF2;
    }
    break;

  case CON_DELCNF2:
    if (!strcmp(arg, "yes") || !strcmp(arg, "YES")) {
      if (PLR_FLAGGED(d->character, PLR_FROZEN)) {
	SEND_TO_Q("You try to kill yourself, but the ice stops you.\r\n", d);
	SEND_TO_Q("Character not deleted.\r\n\r\n", d);
	STATE(d) = CON_CLOSE;
	return;
      }
      if (GET_LEVEL(d->character) < LVL_GRGOD){
        if(GET_CLAN(d->character)){
          int clan_num;
          clan_num = find_clan_by_id(GET_CLAN(d->character));
          if(GET_CLAN_RANK(d->character)){
            clan[clan_num].members--;
            clan[clan_num].power-=GET_LEVEL(d->character);
	  }
          GET_CLAN(d->character) = 0;
          GET_CLAN_RANK(d->character) = 0;
          update_clan(NULL,clan_num);
	}
	SET_BIT(PLR_FLAGS(d->character), PLR_DELETED);
      }
      save_char(d->character, NOWHERE);
      Crash_delete_file(GET_NAME(d->character));
      sprintf(buf, "Character '%s' deleted!\r\n"
	      "Goodbye.\r\n", GET_NAME(d->character));
      SEND_TO_Q(buf, d);
      sprintf(buf, "%s (lev %d) has self-deleted.", GET_NAME(d->character),
	      GET_LEVEL(d->character));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      STATE(d) = CON_CLOSE;
      return;
    } else {
      SEND_TO_Q("\r\nCharacter not deleted.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    }
    break;

  case CON_CLOSE:
    close_socket(d);
    break;

  default:
    log("SYSERR: Nanny: illegal state of con'ness; closing connection");
    close_socket(d);
    break;
  }
};



int exp_death_loss(struct char_data * ch, int level)
{
int percent, total;
int current;
if (abs(GET_LEVEL(ch) - level) > 2)
level = GET_LEVEL(ch);
if (level >= 65)
percent = 3;
else if (level >= 55)
percent = 5;
else if (level >= 50)
percent = 10;
else if (level >= 40)
percent = 20;
else if (level >= 30)
percent = 25;
else if (level >= 20)
percent = 30;
else
percent = 35;
total = (int) exp_to_level(level, GET_CLASS(ch)) - exp_to_level((level - 1), GET_CLASS(ch));

current = (int)((percent * total)/100);
/*This is a test display to character*/
/*
sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
	send_to_char(buf, ch);
  */
return current;


}

int max_exp_gain(struct char_data *ch)
{
int percent, total;
int current;
if (GET_LEVEL(ch) >= 40)
percent = 15;
else if (GET_LEVEL(ch) >= 30)
percent = 15;
else if (GET_LEVEL(ch) >= 20)
percent = 15;
else
percent = 30;
total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));

current = (int)((percent * total)/100);
/*sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
	send_to_char(buf, ch);
  */
return current;

}
char *exp_mesg(struct char_data *ch)
{
	long percent, current, total;


	current = exp_to_level((GET_LEVEL(ch)), GET_CLASS(ch)) - GET_EXP(ch);
	total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
	current = total - current;
 percent = (long) ((100 * current) / total);

/* sprintf(buf, "percent is %d\r\nbut total %d, current %d", percent, total, current);
	send_to_char(buf, ch);
  */


  if (percent >= 90)
    return ("\r\n&0&4&bYou should level anytime now!&0\r\n");
  else if (percent >= 80)
    return ("\r\n&0&6You are almost ready to attain your next level.&0\r\n");
  else if (percent >= 70)
    return ("\r\n&0&4You are three-quarters of the way to your next level.&0\r\n");
  else if (percent >= 60)
    return ("\r\n&0&4You are well on your way to your next level.&0\r\n");
  else if (percent >= 50)
    return ("\r\n&0&4You are just passed the half-way point to your next level.&0\r\n");
  else if (percent >= 40)
    return ("\r\n&0&4You are at the half-way point to your next level.&0\r\n");
  else if (percent >= 30)
    return ("\r\n&0&4You are nearing the half-way point to your next level.&0\r\n");
  else if (percent >= 20)
    return ("\r\n&0&4You are one-quarter of the way to your next level.&0\r\n");
  else if (percent >= 10)
    return ("\r\n&0&4You have gained some progress towards your next level.&0\r\n");
  else if (percent > 4)
    return ("\r\n&0&4You still have a very long way to go to your next level.&0\r\n");
  else
    return ("\r\n&0&4You have just begun the journey to your next level.&0\r\n");
}

void new_rollor_display(struct char_data *ch, int word[6])
{
 int statts[6];
 int j;


 statts[0] = GET_STR_VIEW(ch);
 statts[1] = GET_INT_VIEW(ch);
 statts[2] = GET_WIS_VIEW(ch);
 statts[3] = GET_DEX_VIEW(ch);
 statts[4] = GET_CON_VIEW(ch);
 statts[5] = GET_CHA_VIEW(ch);

for (j = 0; j <= 5; j++)	{
	  if (statts[j] > 90)
		  word[j] = 0;
	  else if (statts[j] > 80)
		  word[j] = 1;
	  else if (statts[j] > 62)
		  word[j] = 2;
	  else if (statts[j] > 52)
		  word[j] = 3;
	  else
		  word[j] = 4;
 }

}

int bonus_stat(struct char_data *ch, char arg)
{
int b;
int a;
arg = LOWER(arg);
switch(arg)
{
	case 'w':
		b = number(2, 6);
		GET_WIS_VIEW(ch) = MIN(100, (GET_WIS_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'i':
		b = number(2, 6);
		GET_INT_VIEW(ch) = MIN(100, (GET_INT_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'm':
		b = number(2, 6);
		GET_CHA_VIEW(ch) = MIN(100, (GET_CHA_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'c':
		b = number(2, 6);
		GET_CON_VIEW(ch) = MIN(100, (GET_CON_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'd':		b = number(2, 6);
		GET_DEX_VIEW(ch) = MIN(100, (GET_DEX_VIEW(ch) +b));
		a = TRUE;
		break;
	case 's':
		b = number(2, 6);
		GET_STR_VIEW(ch) = GET_STR_VIEW(ch) + b;
		if (GET_STR_VIEW(ch) > 100) {
			GET_ADD_VIEW(ch) = MIN(100, ((GET_ADD_VIEW(ch) +
(GET_STR_VIEW(ch) % 100))));
			GET_STR_VIEW(ch) = 100;
		}
		a = TRUE;
		break;
	default:
		a = FALSE;
		break;
	}
ch->vaff_abils = ch->view_abils;
return a;
}


const char *iscommand[] =
{
  "north",			/* 1 */
  "east",
  "south",
  "west",
  "up",
  "down",
  "enter",
  "exits",
  "kiss",
  "get",
  "drink",			/* 11 */
  "eat",
  "wear",
  "wield",
  "look",
  "score",
  "say",
  "gshout",
  "tell",
  "inventory",
  "qui",			/* 21 */
  "bounce",
  "smile",
  "dance",
  "kill",
  "cast",
  "laugh",
  "giggle",
  "shake",
  "puke",
  "growl",			/* 31 */
  "scream",
  "insult",
  "comfort",
  "nod",
  "sigh",
  "sulk",
  "help",
  "who",
  "emote",
  "echo",			/* 41 */
  "stand",
  "sit",
  "rest",
  "sleep",
  "wake",
  "force",
  "transfer",
  "hug",
  "snuggle",
  "cuddle",			/* 51 */
  "nuzzle",
  "cry",
  "news",
  "equipment",
  "buy",
  "sell",
  "value",
  "list",
  "drop",
  "goto",			/* 61 */
  "weather",
  "read",
  "pour",
  "grab",
  "remove",
  "put",
  "shutdow",
  "save",
  "hit",
  "string",			/* 71 */
  "give",
  "quit",
  "stat",
  "innate",
  "time",
  "load",
  "purge",
  "shutdown",
  "idea",
  "typo",			/* 81 */
  "bug",
  "whisper",
  "cackle",
  "at",
  "ask",
  "order",
  "sip",
  "taste",
  "snoop",
  "follow",			/* 91 */
  "rent",
  "offer",
  "poke",
  "advance",
  "accuse",
  "grin",
  "bow",
  "open",
  "close",
  "lock",			/* 101 */
  "unlock",
  "mreport",
  "applaud",
  "blush",
  "burp",
  "chuckle",
  "clap",
  "cough",
  "curtsey",
  "fart",			/* 111 */
  "flip",
  "fondle",
  "frown",
  "gasp",
  "glare",
  "groan",
  "grope",
  "hiccup",
  "lick",
  "love",			/* 121 */
  "moan",
  "nibble",
  "pout",
  "purr",
  "ruffle",
  "shiver",
  "shrug",
  "sing",			/* 129 - special case for bards */
  "slap",
  "smirk",			/* 131 */
  "snap",
  "sneeze",
  "snicker",
  "sniff",
  "snore",
  "spit",
  "squeeze",
  "stare",
  "strut",
  "thank",			/* 141 */
  "twiddle",
  "wave",
  "whistle",
  "wiggle",
  "wink",
  "yawn",
  "snowball",
  "write",
  "hold",
  "flee",			/* 151 */
  "sneak",
  "hide",
  "backstab",
  "pick",
  "steal",
  "bash",
  "rescue",
  "kick",
  "french",
  "comb",			/* 161 */
  "massage",
  "tickle",
  "practice",
  "pat",
  "examine",
  "take",
  "info",
  "spells",
  "practise",
  "curse",			/* 171 */
  "use",
  "where",
  "levels",
  "reroll",
  "pray",
  ":",
  "beg",
  "bleed",
  "cringe",
  "dream",			/* 181 */
  "fume",
  "grovel",
  "hop",
  "nudge",
  "peer",
  "point",
  "ponder",
  "punch",
  "snarl",
  "spank",			/* 191 */
  "steam",
  "tackle",
  "taunt",
  "think",
  "whine",
  "worship",
  "yodel",
  "toggle",
  "wizmsg",
  "consider",			/* 201 */
  "group",
  "restore",
  "return",
  "switch",			/* 205 */
  "quaff",
  "recite",
  "users",
  "pose",
  "silence",
  "wizhelp",			/* 211 */
  "credits",
  "disband",
  "vis",
  "lflags",			/* 215 */
  "poofin",
  "wizlist",
  "display",
  "echoa",
  "demote",			/* 220 */
  "poofout",
  "circle",
  "balance",
  "wizlock",
  "deposit",			/* 225 */
  "withdraw",
  "ignore",
  "setattr",
  "title",
  "aggr",			/* 230 */
  "gsay",
  "consent",
  "setbit",
  "hitall",
  "trap",			/* 235 */
  "murder",
  "glance",
  "auction",
  "channel",
  "fill",			/* 240 */
  "ooc",
  "nokill",
  "page",
  "commands",
  "attributes",			/* 245 */
  "rules",
  "track",
  "analyze",
  "listen",
  "disarm",
  "pet",			/* 250 */
  "delete",
  "ban",
  "allow",
  "play",
  "move",			/* 255 */
  "bribe",
  "bonk",
  "calm",
  "rub",
  "censor",			/* 260 */
  "choke",
  "drool",
  "flex",
  "jump",
  "lean",			/* 265 */
  "moon",
  "ogle",
  "pant",
  "pinch",
  "push",			/* 270 */
  "scare",
  "scold",
  "seduce",
  "shove",
  "shudder",			/* 275 */
  "shush",
  "slobber",
  "smell",
  "sneer",
  "spin",			/* 280 */
  "squirm",
  "stomp",
  "strangle",
  "stretch",
  "tap",			/* 285 */
  "tease",
  "tip",
  "tweak",
  "twirl",
  "undress",			/* 290 */
  "whimper",
  "exchange",
  "release",
  "search",
  "join",			/* 295 */
  "camp",
  "secret",
  "lookup",
  "report",
  "split",			/* 300 */
  "world",
  "junk",
  "petition",
  "do",
  "'",				/* 305 */
  "caress",
  "bury",
  "donate",
  "shout",
  "disembark",			/* 310 */
  "panic",
  "nog",
  "twibble",
  "bleh",
  "lightning",			/* 315 */
  "sweep",
  "apologize",
  "afk",
  "lag",
  "touch",			/* 320 */
  "scratch",
  "wince",
  "toss",
  "flame",
  "arch",			/* 325 */
  "amaze",
  "bathe",
  "embrace",
  "brb",
  "ack",			/* 330 */
  "cheer",
  "snort",
  "eyebrow",
  "bang",
  "pillow",			/* 335 */
  "nap",
  "nose",
  "raise",
  "hand",
  "pull",			/* 340 */
  "tug",
  "wet",
  "mosh",
  "wait",
  "hi5",			/* 345 */
  "envy",
  "flirt",
  "bark",
  "whap",
  "roll",			/* 350 */
  "blink",
  "doh",
  "gag",
  "grumble",
  "dropkick",			/* 355 */
  "whatever",
  "fool",
  "noogie",
  "melt",
  "smoke",			/* 360 */
  "wheeze",
  "bird",
  "boggle",
  "hiss",
  "bite",			/* 365 */
  "teleport",
  "bandage",
  "blow",
  "bored",
  "bye",			/* 370 */
  "congratulate",
  "duck",
  "flutter",
  "goose",
  "gulp",			/* 375 */
  "halo",
  "hello",
  "hickey",
  "hose",
  "hum",			/* 380 */
  "impale",
  "jam",
  "kneel",
  "mourn",
  "protect",			/* 385 */
  "puzzle",
  "roar",
  "rose",
  "salute",
  "skip",			/* 390 */
  "swat",
  "tongue",
  "woops",
  "zone",
  "trip",			/* 395 */
  "meditate",
  "shapechange",
  "assist",
  "doorbash",
  "exp",			/* 400 */
  "rofl",
  "agree",
  "happy",
  "pucker",
  "spam",			/* 405 */
  "beer",
  "bodyslam",
  "sacrifice",
  "terminate",
  "cd",				/* 410 */
  "memorize",
  "forget",
  "headbutt",
  "shadow",
  "ride",			/* 415 */
  "mount",
  "dismount",
  "debug",
  "freeze",
  "bbl",			/* 420 */
  "gape",
  "veto",
  "jk",
  "tiptoe",
  "grunt",			/* 425 */
  "holdon",
  "imitate",
  "tango",
  "tarzan",
  "pounce",			/* 430 */
  "cheek",
  "layhand",
  "awareness",
  "firstaid",
  "springleap",			/* 435 */
  "feigndeath",
  "chant",
  "drag",
  "speak",
  "reload",			/* 440 */
  "dragonpunch",
  "revoke",
  "grant",
  "whod",
  "motd",			/* 445 */
  "zreset",
  "full",
  "welcome",
  "introduce",
  "sweat",			/* 450 */
  "mutter",
  "lucky",
  "ayt",
  "fidget",
  "fuzzy",			/* 455 */
  "snoogie",
  "ready",
  "plonk",
  "hero",
  "lost",			/* 460 */
  "clear",
  "flash",
  "curious",
  "hunger",
  "thirst",			/* 465 */
  "echoz",
  "ptell",
  "scribe",
  "teach",
  "reinitphys",			/* 470 */
  "finger",
  "accept",
  "decline",
  "summon",
  "clone",			/* 475 */
  "trophy",
  "zap",
  "alert",
  "recline",
  "knock",			/* 480 */
  "skills",
  "powercast",
  "berserk",
  "faq",
  "disengage",			/* 485 */
  "retreat",
  "inroom",
  "which",
  "revoketitle",
  "sethome",                    /* 490 */
  "notes",
  "wiznews",
  "abort",
  "ceasefire",
  "athrow",                     /* 495 */
  "afire",
  "throw",
  "fire",
  "ammo",
  "\n"				/* 500 */
};
@


1.329
log
@Fixed log(buf) to log(%s buf)
@
text
@/***************************************************************************
 * $Id: interpreter.c,v 1.328 2010/06/05 14:56:27 mud Exp $
 ***************************************************************************/
/***************************************************************************
 *   File: interpreter.c                                  Part of FieryMUD *
 *  Usage: parse user commands, search for specials, call ACMD functions   *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#define __INTERPRETER_C__

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "comm.h"
#include "interpreter.h"
#include "db.h"
#include "commands.h"
#include "utils.h"
#include "casting.h"
#include "handler.h"
#include "mail.h"
#include "screen.h"
#include "olc.h"
#include "dg_scripts.h"
#include "clan.h"
#include "events.h"
#include "class.h"
#include "races.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "players.h"
#include "pfiles.h"
#include "fight.h"
#include "privileges.h"
#include "modify.h"
#include "act.h"
#include "cooldowns.h"
#include "textfiles.h"

extern char *MENU;
extern char *WELC_MESSG;
extern char *START_MESSG;
extern char *subclass_descrip;
extern char *subclass_descrip2;
extern int restrict;
extern int restrict_reason;
extern int approve_names;
extern int napprove_pause;
extern int races_allowed;
extern int good_races_allowed;


/* external functions */
void broadcast_name(char *name);
void echo_on(struct descriptor_data *d);
void echo_off(struct descriptor_data *d);
int special(struct char_data *ch, int cmd, char *arg);
int isbanned(char *hostname);
int Valid_Name(char *newname);
void oedit_parse(struct descriptor_data *d, char *arg);
void redit_parse(struct descriptor_data *d, char *arg);
void zedit_parse(struct descriptor_data *d, char *arg);
void medit_parse(struct descriptor_data *d, char *arg);
void sedit_parse(struct descriptor_data *d, char *arg);
void hedit_parse(struct descriptor_data *d, char *arg);
void sdedit_parse(struct descriptor_data *d, char *arg);
int roll_table[6];
void send_to_xnames(char *name);
void personal_reboot_warning(struct char_data *ch);

void display_question(struct descriptor_data *d);
/*void rolls_display(struct char_data *ch, char *[], char *[]);*/
void roll_natural_abils(struct char_data *ch);
void new_rollor_display(struct char_data *ch, int[]);
int bonus_stat(struct char_data *ch, char arg);
int parse_good_race(char arg); /* Put in until such time that all races are allowed */
void set_innate(struct char_data * ch, char *arg);
void trigedit_parse(struct descriptor_data *d, char *arg);
extern char *diety_selection;
void appear(struct char_data * ch);
int make_count = 0;
EVENTFUNC(name_timeout);
extern bool ispell_name_check(char *);


/* prototypes for all do_x functions. */
ACMD(do_abort);
ACMD(do_abandon);
ACMD(do_action);
ACMD(do_advance);
ACMD(do_aggr);
ACMD(do_alert);
ACMD(do_alias);
ACMD(do_assist);
ACMD(do_at);
ACMD(do_backstab);
ACMD(do_ban);
ACMD(do_bandage);
ACMD(do_bash);
ACMD(do_berserk);
ACMD(do_bind);
ACMD(do_boardadmin);
ACMD(do_disarm);
ACMD(do_disengage);
ACMD(do_breathe);
ACMD(do_buck);
ACMD(do_cast);
ACMD(do_camp);
ACMD(do_clan);
ACMD(do_claw);
ACMD(do_compare);
ACMD(do_conceal);
ACMD(do_consent);
ACMD(do_coredump);
ACMD(do_corner);
ACMD(do_credits);
ACMD(do_ctell);
ACMD(do_date);
ACMD(do_dc);
ACMD(do_desc);
ACMD(do_diagnose);
ACMD(do_dismount);
ACMD(do_display);
ACMD(do_disband);
ACMD(do_dig);
ACMD(do_doorbash);
ACMD(do_douse);
ACMD(do_drag);
ACMD(do_drink);
ACMD(do_drop);
ACMD(do_dump);
ACMD(do_eat);
ACMD(do_echo);
ACMD(do_edit);
ACMD(do_electrify);
ACMD(do_enter);
ACMD(do_estat);
ACMD(do_exit);
ACMD(do_extinguish);
ACMD(do_eye_gouge);
ACMD(do_flee);
ACMD(do_fly);
ACMD(do_follow);
ACMD(do_force);
ACMD(do_forget);
ACMD(do_gecho);
ACMD(do_gen_comm);
ACMD(do_gen_door);
ACMD(do_gen_write);
ACMD(do_get);
ACMD(do_give);
ACMD(do_goto);
ACMD(do_grab);
ACMD(do_gretreat);
ACMD(do_group);
ACMD(do_gsay);
ACMD(do_guard);
ACMD(do_hcontrol);
ACMD(do_hide);
ACMD(do_hit);
ACMD(do_hitall);
ACMD(do_hotboot);
ACMD(do_house);
ACMD(do_hunt);
ACMD(do_iedit);
ACMD(do_ignore);
ACMD(do_inctime);
ACMD(do_info);
ACMD(do_infodump);
ACMD(do_insult);
ACMD(do_invis);
ACMD(do_iptables);
#ifndef CIRCLE_WINDOWS
ACMD(do_ispell);
#endif
ACMD(do_kick);
ACMD(do_kill);
ACMD(do_kneel);
ACMD(do_ksearch);
ACMD(do_last);
ACMD(do_leave);
ACMD(do_level);
ACMD(do_light);
ACMD(do_linkload);
ACMD(do_load);
ACMD(do_meditate);
ACMD(do_memorize);
ACMD(do_mob_log);
ACMD(do_mount);
ACMD(do_move);
ACMD(do_name);
ACMD(do_note);
ACMD(do_not_here);
ACMD(do_olc);
ACMD(do_order);
ACMD(do_page);
ACMD(do_pain);
ACMD(do_palm);
ACMD(do_peace);
ACMD(do_peck);
ACMD(do_petition);
ACMD(do_pfilemaint);
ACMD(do_point);
ACMD(do_players);
ACMD(do_poofset);
ACMD(do_pour);
ACMD(do_practice);
ACMD(do_pray);
ACMD(do_prompt);
ACMD(do_pscan);
ACMD(do_ptell);
ACMD(do_purge);
ACMD(do_put);
ACMD(do_qcomm);
ACMD(do_quest);
ACMD(do_qadd);
ACMD(do_qdel);
ACMD(do_qlist);
ACMD(do_qstat);
ACMD(do_quit);
ACMD(do_read);
ACMD(do_recline);
ACMD(do_rest);
ACMD(do_reload);
ACMD(do_remove);
ACMD(do_report);
ACMD(do_rescue);
ACMD(do_reply);
ACMD(do_restore);
ACMD(do_rrestore);
ACMD(do_return);
ACMD(do_retreat);
ACMD(do_rpain);
ACMD(do_rsdiamimp);
ACMD(do_rclone);
ACMD(do_readlist);
ACMD(do_rename);
ACMD(do_roar);
ACMD(do_save);
ACMD(do_say);
ACMD(do_scribe);
ACMD(do_send);
ACMD(do_set);
ACMD(do_shapechange);
ACMD(do_show);
ACMD(do_shutdown);
ACMD(do_sit);
ACMD(do_skillset);
ACMD(do_mskillset);
ACMD(do_sleep);
ACMD(do_snoop);
ACMD(do_spec_comm);
ACMD(do_split);
ACMD(do_springleap);
ACMD(do_sdedit);
ACMD(do_stand);
ACMD(do_stat);
ACMD(do_steal);
ACMD(do_stomp);
ACMD(do_stow);
ACMD(do_subclass);
ACMD(do_sweep);
ACMD(do_switch);
ACMD(do_syslog);
ACMD(do_tame);
ACMD(do_tedit);
ACMD(do_teleport);
ACMD(do_tell);
ACMD(do_terminate);
ACMD(do_throatcut);
ACMD(do_title);
ACMD(do_toggle);
ACMD(do_touch);
ACMD(do_track);
ACMD(do_trans);
ACMD(do_unban);
ACMD(do_unbind);
ACMD(do_use);
ACMD(do_varset);
ACMD(do_varunset);
ACMD(do_visible);
ACMD(do_vsearch);
ACMD(do_csearch);
ACMD(do_esearch);
ACMD(do_msearch);
ACMD(do_osearch);
ACMD(do_rsearch);
ACMD(do_ssearch);
ACMD(do_tsearch);
ACMD(do_zsearch);
ACMD(do_vstat);
ACMD(do_vitem);
ACMD(do_vwear);
ACMD(do_wake);
ACMD(do_wear);
ACMD(do_where);
ACMD(do_wield);
ACMD(do_wizlock);
ACMD(do_wiznet);
ACMD(do_wizutil);
ACMD(do_write);
ACMD(do_zreset);
ACMD(do_zstat);

ACMD(do_game);
ACMD(do_autoboot);
ACMD(do_world);
ACMD(do_objupdate);

/* DG Script ACMD's */
ACMD(do_attach);
ACMD(do_detach);
ACMD(do_tstat);
ACMD(do_masound);
ACMD(do_mkill);
ACMD(do_mjunk);
ACMD(do_mechoaround);
ACMD(do_msend);
ACMD(do_mecho);
ACMD(do_mload);
ACMD(do_mpurge);
ACMD(do_mgoto);
ACMD(do_mat);
ACMD(do_mteleport);
ACMD(do_mforce);
ACMD(do_mexp);
ACMD(do_mdamage);
ACMD(do_mgold);
ACMD(do_m_run_room_trig);
ACMD(do_msave);
ACMD(do_layhand);
ACMD(do_first_aid);
ACMD(do_summon_mount);


int num_of_cmds;
struct sort_struct *cmd_sort_info = NULL;

/* This is the Master Command List(tm).

 * You can put new commands in, take commands out, change the order
 * they appear in, etc.  You can adjust the "priority" of commands
 * simply by changing the order they appear in the command list.
 * (For example, if you want "as" to mean "assist" instead of "ask",
 * just put "assist" above "ask" in the Master Command List(tm).
 *
 * In general, utility commands such as "at" should have high priority;
 * infrequently used and dangerously destructive commands should have low
 * priority.
 */


const struct command_info cmd_info[] = {
  { "RESERVED", 0, 0, 0, 0, 0, 0 },        /* this must be first -- for specprocs */
  /* Name      , min position, min stance, ACMD,         min level, sub cmd, flags */
  /* directions must come before other commands but after RESERVED */
  { "north"    , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_NORTH , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "east"     , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_EAST  , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "south"    , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_SOUTH , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "west"     , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_WEST  , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "up"       , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_UP    , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "down"     , POS_STANDING, STANCE_ALERT   , do_move     , 0, SCMD_DOWN  , CMD_HIDE | CMD_OLC | CMD_NOFIGHT },

  /* now, the main list */
  { "at"       , POS_PRONE   , STANCE_DEAD    , do_at       , LVL_ATTENDANT - 1, 0, CMD_ANY },
  { "abort"    , POS_PRONE   , STANCE_DEAD    , do_abort    , 0, 0, CMD_ANY ^ CMD_BOUND },
  { "abandon"  , POS_PRONE   , STANCE_RESTING , do_abandon  , 0, 0, 0 },
  { "ack"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "advance"  , POS_PRONE   , STANCE_DEAD    , do_advance  , LVL_ADMIN, 0, CMD_ANY },
  { "aggr"     , POS_PRONE   , STANCE_DEAD    , do_aggr     , 0, 0, 0 },
  { "alert"    , POS_PRONE   , STANCE_RESTING , do_alert    , 0, 0, CMD_CAST },
  { "alias"    , POS_PRONE   , STANCE_DEAD    , do_alias    , 0, 0, CMD_MEDITATE | CMD_HIDE },
  { "accuse"   , POS_SITTING , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "afk"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "agree"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "amaze"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "anews"    , POS_PRONE   , STANCE_DEAD    , do_textview , LVL_IMMORT, SCMD_ANEWS, CMD_ANY },
  { "apologize", POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "applaud"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "appear"   , POS_STANDING, STANCE_ALERT   , do_not_here ,-1, 0, CMD_NOFIGHT },
  { "assist"   , POS_STANDING, STANCE_ALERT   , do_assist   , 1, 0, 0 },
  { "ask"      , POS_PRONE   , STANCE_RESTING , do_spec_comm, 0, SCMD_ASK, CMD_OLC },
  { "autoboot" , POS_PRONE   , STANCE_DEAD    , do_autoboot,  LVL_REBOOT_VIEW, 0, CMD_ANY },
/*{ "auction"  , POS_PRONE   , STANCE_SLEEPING, do_gen_comm , LVL_GOD, SCMD_AUCTION, 0 },*/
  { "ayt"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "backstab" , POS_STANDING, STANCE_ALERT   , do_backstab , 1, 0, 0 },
  { "ban"      , POS_PRONE   , STANCE_DEAD    , do_ban      , LVL_GRGOD, 0, CMD_ANY },
  { "bandage"  , POS_STANDING, STANCE_ALERT   , do_bandage  , 1, 0, CMD_NOFIGHT },
  { "balance"  , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "bang"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bark"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bash"     , POS_STANDING, STANCE_ALERT   , do_bash     , 1, SCMD_BASH, 0 },
/*{ "bind"     , POS_STANDING, STANCE_ALERT   , do_bind     ,-1, 0, 0 },*/
  { "bodyslam" , POS_STANDING, STANCE_ALERT   , do_bash     , 1, SCMD_BODYSLAM, 0 },
  { "beckon"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "beer"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "beg"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "berserk"  , POS_STANDING, STANCE_ALERT   , do_berserk  , 0, 0, 0 },
  { "bite"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bird"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "blink"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bleed"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "blush"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "boardadmin",POS_PRONE   , STANCE_DEAD    , do_boardadmin,LVL_ADMIN, 0, 0 },
  { "boggle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bonk"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bored"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bounce"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "bow"      , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "brb"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "breathe"  , POS_STANDING, STANCE_ALERT   , do_breathe  ,-1, 0, 0 },
  { "buck"     , POS_STANDING, STANCE_ALERT   , do_buck     , 0, 0, CMD_NOFIGHT },
  { "burp"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "buy"      , POS_STANDING, STANCE_ALERT   , do_not_here , 0, 0, CMD_NOFIGHT },
  { "bug"      , POS_PRONE   , STANCE_DEAD    , do_gen_write, 0, SCMD_BUG, CMD_ANY },
  { "bye"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "cast"     , POS_SITTING, STANCE_RESTING , do_cast     , 1, SCMD_CAST, 0},
  { "cackle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "camp"     , POS_STANDING, STANCE_ALERT   , do_camp     , 1, 0, CMD_NOFIGHT },
  { "chant"    , POS_STANDING, STANCE_ALERT   , do_cast     , 0, SCMD_CHANT, 0 },
  { "chuckle"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "check"    , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "cheer"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "choke"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "clan"     , POS_PRONE   , STANCE_SLEEPING, do_clan     , 1, 0, CMD_MEDITATE },
  { "clap"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "claw"     , POS_STANDING, STANCE_ALERT   , do_claw     , 1, 0, 0 },
  { "clear"    , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "close"    , POS_SITTING , STANCE_RESTING , do_gen_door , 0, SCMD_CLOSE, 0 },
  { "cls"      , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "consider" , POS_PRONE   , STANCE_RESTING , do_consider , 0, 0, 0 },
  { "color"    , POS_PRONE   , STANCE_DEAD    , do_color    , 0, 0, CMD_ANY },
  { "compare"  , POS_PRONE   , STANCE_RESTING , do_compare  , 0, 0, CMD_MEDITATE },
  { "comfort"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "comb"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "commands" , POS_PRONE   , STANCE_DEAD    , do_commands , 0, SCMD_COMMANDS, CMD_ANY },
  { "consent"  , POS_PRONE   , STANCE_INCAP   , do_consent  , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_CAST | CMD_OLC },
  { "conceal"  , POS_STANDING, STANCE_ALERT   , do_conceal  , 0, 0, CMD_HIDE | CMD_NOFIGHT },
  { "coredump" , POS_PRONE   , STANCE_DEAD    , do_coredump , LVL_HEAD_C, 0, 0 },
  { "corner"   , POS_STANDING, STANCE_ALERT   , do_corner   , 0, 0, 0 },
  { "cough"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "credits"  , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_CREDITS, CMD_ANY },
  { "cringe"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "cry"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "clist"    , POS_PRONE   , STANCE_DEAD    , do_csearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "csearch"  , POS_PRONE   , STANCE_DEAD    , do_csearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ctell"    , POS_PRONE   , STANCE_SLEEPING, do_ctell    , 0, 0, CMD_ANY },
  { "cuddle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "curse"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "curtsey"  , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },

  { "dance"    , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "date"     , POS_PRONE   , STANCE_DEAD    , do_date     , 0, SCMD_DATE, CMD_ANY },
  { "daydream" , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "dc"       , POS_PRONE   , STANCE_DEAD    , do_dc       , LVL_ATTENDANT, 0, CMD_ANY },
  { "deposit"  , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "desc"     , POS_PRONE   , STANCE_SLEEPING, do_desc     , 0, 0, CMD_NOFIGHT },
  { "diagnose" , POS_PRONE   , STANCE_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "dismount" , POS_STANDING, STANCE_ALERT   , do_dismount , 0, 0, CMD_NOFIGHT },
  { "display"  , POS_PRONE   , STANCE_DEAD    , do_display  , 0, 0, CMD_ANY },
  { "disband"  , POS_PRONE   , STANCE_SLEEPING, do_disband  , 1, 0, 0 },
  { "dig"      , POS_PRONE   , STANCE_DEAD    , do_dig      , LVL_BUILDER, 0, CMD_ANY ^ CMD_OLC },
  { "disappear", POS_STANDING, STANCE_ALERT   , do_not_here ,-1, 0, CMD_NOFIGHT },
  { "disarm"   , POS_STANDING, STANCE_ALERT   , do_disarm   , 0, 0, 0 },
  { "disengage", POS_STANDING, STANCE_ALERT   , do_disengage, 0, 0, CMD_CAST },
  { "doorbash" , POS_STANDING, STANCE_ALERT   , do_doorbash , 0, 0, CMD_NOFIGHT },
  { "douse"    , POS_STANDING, STANCE_ALERT   , do_douse    , 0, 0, CMD_NOFIGHT },
  { "drag"     , POS_STANDING, STANCE_ALERT   , do_drag     , 1, 0, CMD_NOFIGHT },
  { "dream"    , POS_PRONE   , STANCE_SLEEPING, do_action  , 0, 0, 0 },
  { "drink"    , POS_PRONE   , STANCE_RESTING , do_drink    , 0, SCMD_DRINK, 0 },
  { "drop"     , POS_PRONE   , STANCE_RESTING , do_drop     , 0, SCMD_DROP, 0 },
  { "drool"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "duck"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "duh"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "dump"     , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },

  { "eat"      , POS_PRONE   , STANCE_RESTING , do_eat      , 0, SCMD_EAT, 0 },
  { "edit"     , POS_SITTING , STANCE_RESTING , do_edit     , 3, 0, CMD_NOFIGHT },
  { "echo"     , POS_PRONE   , STANCE_DEAD    , do_echo     , LVL_IMMORT, SCMD_ECHO, CMD_ANY },
  { "electrify", POS_STANDING, STANCE_ALERT   , do_electrify, 1, 0, 0 },
  { "emote"    , POS_PRONE   , STANCE_RESTING , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { "emote's"  , POS_PRONE   , STANCE_RESTING , do_echo     , 1, SCMD_EMOTES, CMD_OLC },
  { ":"        , POS_PRONE   , STANCE_RESTING , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { "embrace"  , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "enter"    , POS_STANDING, STANCE_ALERT   , do_enter    , 0, 0, CMD_NOFIGHT },
  { "envy"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "equipment", POS_PRONE   , STANCE_SLEEPING, do_equipment, 0, 0, CMD_ANY },
  { "exits"    , POS_PRONE   , STANCE_RESTING , do_exits    , 0, 0, CMD_HIDE | CMD_MEDITATE | CMD_OLC },
  { "examine"  , POS_PRONE   , STANCE_RESTING , do_examine  , 0, 0, CMD_HIDE | CMD_OLC },
  { "exchange" , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "experience",POS_PRONE   , STANCE_DEAD    , do_experience,0, 0, CMD_ANY },
  { "extinguish",POS_PRONE   , STANCE_RESTING , do_light    , 0, SCMD_EXTINGUISH, 0 },
  { "eyebrow"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, CMD_HIDE },
  { "elist"    , POS_PRONE   , STANCE_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "enum"     , POS_PRONE   , STANCE_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "esearch"  , POS_PRONE   , STANCE_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "force"    , POS_PRONE   , STANCE_DEAD    , do_force    , LVL_ATTENDANT, 0, CMD_ANY },
  { "flee"     , POS_PRONE   , STANCE_RESTING , do_flee     , 1, 0, CMD_CAST },
  { "fart"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "first aid", POS_PRONE   , STANCE_RESTING , do_first_aid, 0, 0, 0 },
  { "fill"     , POS_STANDING, STANCE_ALERT   , do_pour     , 0, SCMD_FILL, CMD_NOFIGHT },
  { "flanic"   , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "flex"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "flip"     , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "flirt"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "fly"      , POS_STANDING, STANCE_ALERT   , do_fly      , 0, 0, CMD_HIDE },
  { "follow"   , POS_PRONE   , STANCE_RESTING , do_follow   , 0, SCMD_FOLLOW, 0 },
  { "fool"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "forget"   , POS_PRONE   , STANCE_RESTING , do_forget   , 0, 0, CMD_MEDITATE },
  { "fondle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "freeze"   , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE, CMD_ANY },
  { "french"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "frown"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, CMD_HIDE },
  { "fume"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "get"      , POS_PRONE   , STANCE_RESTING , do_get      , 0, 0, 0 },
  { "gag"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "gape"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "gasp"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "gecho"    , POS_PRONE   , STANCE_DEAD    , do_gecho    , LVL_GOD, 0, CMD_ANY },
  { "give"     , POS_PRONE   , STANCE_RESTING , do_give     , 0, 0, 0 },
  { "giggle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "glance"   , POS_PRONE   , STANCE_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "glare"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "glomp"    , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "glower"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "goto"     , POS_PRONE   , STANCE_DEAD    , do_goto     , LVL_IMMORT, 0, CMD_ANY },
  { "go"       , POS_STANDING, STANCE_ALERT   , do_move     , 0, 0, CMD_HIDE | CMD_OLC | CMD_NOFIGHT },
  { "gossip"   , POS_PRONE   , STANCE_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP, CMD_MEDITATE | CMD_CAST | CMD_HIDE | CMD_OLC },
  { "gouge"    , POS_STANDING, STANCE_ALERT   , do_eye_gouge, 1, 0, 0 },
  { "groan"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "group"    , POS_PRONE   , STANCE_SLEEPING, do_group    , 1, 0, CMD_HIDE | CMD_OLC },
  { "grab"     , POS_PRONE   , STANCE_RESTING , do_grab     , 0, 0, 0 },
/*{ "grats"    , POS_PRONE   , STANCE_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GRATZ, 0 },*/
  { "greport"  , POS_PRONE   , STANCE_SLEEPING, do_report   , 0, SCMD_GREPORT, CMD_ANY },
  { "greet"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "gretreat" , POS_STANDING, STANCE_ALERT   , do_gretreat , 0, 0, 0 },
  { "grin"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "groan"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "grope"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "grovel"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "growl"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "grumble"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "gsay"     , POS_PRONE   , STANCE_SLEEPING, do_gsay     , 0, 0, CMD_ANY },
  { "gtell"    , POS_PRONE   , STANCE_SLEEPING, do_gsay     , 0, 0, CMD_ANY },
  { "guard"    , POS_STANDING, STANCE_ALERT   , do_guard    , 0, 0, CMD_NOFIGHT },
  { "grant"    , POS_PRONE   , STANCE_DEAD    , do_grant    , LVL_ADMIN, SCMD_GRANT, CMD_ANY },
  { "gedit"    , POS_PRONE   , STANCE_DEAD    , do_gedit    , LVL_ADMIN, 0, 0 },

  { "help"     , POS_PRONE   , STANCE_DEAD    , do_help     , 0, 0, CMD_ANY },
  { "hedit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_GAMEMASTER, SCMD_OLC_HEDIT, 0 },
  { "handbook" , POS_PRONE   , STANCE_DEAD    , do_textview , LVL_IMMORT, SCMD_HANDBOOK, CMD_ANY },
  { "halo"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "hcontrol" , POS_PRONE   , STANCE_DEAD    , do_hcontrol , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "hhroom"   , POS_PRONE   , STANCE_DEAD    , do_rclone   , LVL_BUILDER, 0, 0 },
  { "hi5"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "hiccup"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "hide"     , POS_STANDING, STANCE_ALERT   , do_hide     , 1, 0, CMD_HIDE | CMD_NOFIGHT },
  { "hiss"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "hit"      , POS_STANDING, STANCE_ALERT   , do_hit      , 0, SCMD_HIT, 0 },
  { "hitall"   , POS_STANDING, STANCE_ALERT   , do_hitall   , 0, SCMD_HITALL, 0 },
  { "hold"     , POS_PRONE   , STANCE_RESTING , do_grab     , 1, 0, 0 },
  { "hop"      , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "hotboot"  , POS_PRONE   , STANCE_DEAD    , do_hotboot  , LVL_REBOOT_MASTER, 0, 0 },
  { "house"    , POS_PRONE   , STANCE_RESTING , do_house    ,-1, 0, 0 },
  { "howl"     , POS_STANDING, STANCE_ALERT   , do_roar     , 0, SCMD_HOWL, 0 },
  { "hunt"     , POS_STANDING, STANCE_ALERT   , do_hunt     ,-1, 0, CMD_NOFIGHT },
  { "hug"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "hunger"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "inventory", POS_PRONE   , STANCE_SLEEPING, do_inventory, 0, 0, CMD_ANY },
  { "identify" , POS_PRONE   , STANCE_RESTING , do_identify , 0, 0, CMD_HIDE | CMD_OLC },
  { "idea"     , POS_PRONE   , STANCE_DEAD    , do_gen_write, 0, SCMD_IDEA, CMD_ANY },
  { "iedit"    , POS_PRONE   , STANCE_DEAD    , do_iedit    , LVL_BUILDER, 0, 0 },
  { "imitate"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "imotd"    , POS_PRONE   , STANCE_DEAD    , do_textview , LVL_IMMORT, SCMD_IMOTD, CMD_ANY },
  { "impale"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "innate"   , POS_PRONE   , STANCE_DEAD    , do_innate   , 0, 0, CMD_ANY },
  { "infodump" , POS_PRONE   , STANCE_DEAD    , do_infodump , LVL_HEAD_C, 0, CMD_ANY },
  { "ignore"   , POS_PRONE   , STANCE_DEAD    , do_ignore   , 0, 0, CMD_ANY },
  { "inctime"  , POS_PRONE   , STANCE_DEAD    , do_inctime  , LVL_HEAD_C, 0, CMD_ANY },
  { "hour"     , POS_PRONE   , STANCE_DEAD    , do_inctime  , LVL_HEAD_C, 0, CMD_ANY },
  { "info"     , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_INFO, CMD_ANY },
  { "insult"   , POS_PRONE   , STANCE_RESTING , do_insult   , 0, 0, 0 },
  { "invis"    , POS_PRONE   , STANCE_DEAD    , do_invis    , LVL_IMMORT, 0, CMD_ANY },
  { "iptables" , POS_PRONE   , STANCE_DEAD    , do_iptables , LVL_HEAD_C, 0, CMD_ANY },
#ifndef CIRCLE_WINDOWS
  { "ispell"   , POS_PRONE   , STANCE_DEAD    , do_ispell   , LVL_IMMORT, 0, CMD_ANY },
#endif

  { "junk"     , POS_PRONE   , STANCE_RESTING , do_drop     , 0, SCMD_JUNK, 0 },

  { "kick"     , POS_STANDING, STANCE_ALERT   , do_kick     , 1, 0, 0 },
  { "kill"     , POS_STANDING, STANCE_ALERT   , do_kill     , 0, 0, 0 },
  { "kiss"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "kneel"    , POS_PRONE   , STANCE_RESTING , do_kneel    , 0, 0, 0 },
  { "ksearch"  , POS_PRONE   , STANCE_DEAD    , do_ksearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "look"     , POS_PRONE   , STANCE_RESTING , do_look     , 0, 0, CMD_MINOR_PARA | CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST | CMD_OLC },
  { "lag"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "laugh"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "layhands" , POS_STANDING, STANCE_ALERT   , do_layhand  , 0, 0, 0 },
  { "last"     , POS_PRONE   , STANCE_DEAD    , do_last     , LVL_GRGOD, 0, CMD_ANY },
  { "lean"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "leave"    , POS_STANDING, STANCE_ALERT   , do_leave    , 0, 0, CMD_NOFIGHT },
  { "level"    , POS_PRONE   , STANCE_DEAD    , do_level    , 0, 0, CMD_ANY },
  { "light"    , POS_PRONE   , STANCE_RESTING , do_light    , 0, SCMD_LIGHT, 0 },
  { "list"     , POS_STANDING, STANCE_ALERT   , do_not_here , 0, 0, CMD_NOFIGHT },
  { "listspells",POS_PRONE   , STANCE_DEAD    , do_listspells,LVL_ATTENDANT, 0, CMD_ANY },
  { "lick"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "lock"     , POS_SITTING, STANCE_RESTING , do_gen_door , 0, SCMD_LOCK, 0 },
  { "linkload" , POS_PRONE   , STANCE_DEAD    , do_linkload , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "load"     , POS_PRONE   , STANCE_DEAD    , do_load     , LVL_ATTENDANT, 0, CMD_ANY ^ CMD_OLC },
  { "love"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "memorize" , POS_PRONE   , STANCE_RESTING , do_memorize , 0, 0, CMD_MEDITATE },
  { "maul"     , POS_STANDING, STANCE_ALERT   , do_bash     , 1, SCMD_MAUL, 0 },
  { "moan"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "medit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT, 0 },
  { "motd"     , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_MOTD, CMD_ANY },
  { "mail"     , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_HIDE | CMD_NOFIGHT },
  { "massage"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "meditate" , POS_PRONE   , STANCE_RESTING , do_meditate , 0, 0, CMD_MEDITATE },
  { "moon"     , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, 0 },
  { "mosh"     , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "mount"    , POS_STANDING, STANCE_ALERT   , do_mount    , 0, 0, CMD_NOFIGHT },
  { "mourn"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "mumble"   , POS_PRONE   , STANCE_SLEEPING, do_action   , 0, 0, 0 },
  { "mute"     , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH, CMD_ANY },
  { "mutter"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "murder"   , POS_STANDING, STANCE_ALERT   , do_hit      , 0, SCMD_MURDER, 0 },
  { "mlist"    , POS_PRONE   , STANCE_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "mnum"     , POS_PRONE   , STANCE_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "msearch"  , POS_PRONE   , STANCE_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "mstat"    , POS_PRONE   , STANCE_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_MSTAT, CMD_ANY },

  { "nap"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "news"     , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_NEWS, CMD_ANY },
  { "nibble"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "nod"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "nog"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "noogie"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "notitle"  , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE, CMD_ANY },
  { "note"     , POS_PRONE   , STANCE_DEAD    , do_gen_write, LVL_IMMORT, SCMD_NOTE, CMD_ANY },
  { "nudge"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "nuzzle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "naccept"  , POS_PRONE   , STANCE_DEAD    , do_name     , LVL_IMMORT, SCMD_ACCEPT, CMD_ANY },
  { "ndecline" , POS_PRONE   , STANCE_DEAD    , do_name     , LVL_IMMORT, SCMD_DECLINE, CMD_ANY },
  { "nlist"    , POS_PRONE   , STANCE_DEAD    , do_name     , LVL_IMMORT, SCMD_LIST, CMD_ANY },

  { "order"    , POS_PRONE   , STANCE_RESTING , do_order    , 1, 0, 0 },
  { "open"     , POS_SITTING, STANCE_RESTING , do_gen_door , 0, SCMD_OPEN, 0 },
  { "olc"      , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SAVEINFO, CMD_ANY },
  { "oedit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT, 0 },
  { "olist"    , POS_PRONE   , STANCE_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "onum"     , POS_PRONE   , STANCE_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "osearch"  , POS_PRONE   , STANCE_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ostat"    , POS_PRONE   , STANCE_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_OSTAT, CMD_ANY },

  { "put"      , POS_PRONE   , STANCE_RESTING , do_put      , 0, 0, 0 },
  { "palm"     , POS_PRONE   , STANCE_RESTING , do_palm     , 0, 0, CMD_HIDE },
  { "panic"    , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "pant"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "pat"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "page"     , POS_PRONE   , STANCE_DEAD    , do_page     , LVL_GOD, 0, CMD_ANY },
  { "pardon"   , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_OVERLORD, SCMD_PARDON, CMD_ANY },
  { "peace"    , POS_PRONE   , STANCE_DEAD    , do_peace    , LVL_GRGOD, 0, CMD_ANY },
  { "peck"     , POS_STANDING, STANCE_ALERT   , do_peck     , 1, 0, 0 },
  { "peer"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "pet"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "petition" , POS_PRONE   , STANCE_DEAD    , do_petition , 0, 0, CMD_ANY },
  { "pfilemaint", POS_PRONE   , STANCE_DEAD    , do_pfilemaint, LVL_OVERLORD, 0, 0 },
  { "pick"     , POS_STANDING, STANCE_ALERT   , do_gen_door , 1, SCMD_PICK, CMD_HIDE | CMD_NOFIGHT },
  { "players"  , POS_PRONE   , STANCE_DEAD    , do_players  , LVL_HEAD_C, 0, CMD_ANY },
  { "point"    , POS_PRONE   , STANCE_RESTING , do_point    , 0, 0, 0 },
  { "poke"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "policy"   , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_POLICIES, CMD_ANY },
  { "ponder"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "poofin"   , POS_PRONE   , STANCE_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN, CMD_ANY },
  { "poofout"  , POS_PRONE   , STANCE_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT, CMD_ANY },
  { "pounce"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "pour"     , POS_STANDING, STANCE_ALERT   , do_pour     , 0, SCMD_POUR, CMD_NOFIGHT },
  { "pout"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "pray"     , POS_PRONE   , STANCE_RESTING , do_pray     , 0, 0, CMD_MEDITATE },
  { "prompt"   , POS_PRONE   , STANCE_DEAD    , do_prompt   , 0, 0, CMD_ANY },
  { "protect"  , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, 0 },
  { "pscan"    , POS_PRONE   , STANCE_DEAD    , do_pscan    , LVL_HEAD_C, 0, CMD_ANY},
  { "ptell"    , POS_PRONE   , STANCE_DEAD    , do_ptell    , LVL_IMMORT, 0, CMD_ANY },
  { "puke"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "punch"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "purr"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "purge"    , POS_PRONE   , STANCE_DEAD    , do_purge    , LVL_PURGE, 0, CMD_ANY },

  { "quaff"    , POS_PRONE   , STANCE_RESTING , do_use      , 0, SCMD_QUAFF, 0 },
  { "qecho"    , POS_PRONE   , STANCE_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO, CMD_ANY },
  { "qui"      , POS_PRONE   , STANCE_DEAD    , do_quit     ,-1, 0, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "quit"     , POS_PRONE   , STANCE_DEAD    , do_quit     , 0, SCMD_QUIT, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "qsay"     , POS_PRONE   , STANCE_RESTING , do_qcomm    , 0, SCMD_QSAY, CMD_ANY },

  { "rest"     , POS_PRONE   , STANCE_RESTING , do_rest     , 0, 0, CMD_MEDITATE },
  { "raise"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "read"     , POS_PRONE   , STANCE_RESTING , do_read     , 0, 0, 0 },
  { "report"   , POS_PRONE   , STANCE_RESTING , do_report   , 0, SCMD_REPORT, 0 },
  { "reply"    , POS_PRONE   , STANCE_SLEEPING, do_reply    , 0, 0, CMD_ANY },
  { "reload"   , POS_PRONE   , STANCE_DEAD    , do_reload   , LVL_HEAD_C, 0, 0 },
  { "recite"   , POS_PRONE   , STANCE_RESTING , do_use      , 0, SCMD_RECITE, 0 },
  { "receive"  , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "recline"  , POS_PRONE   , STANCE_RESTING , do_recline  , 0, 0, 0 },
  { "remove"   , POS_PRONE   , STANCE_RESTING , do_remove   , 0, 0, 0 },
  { "rent"     , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "reroll"   , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL, 0 },
  { "rescue"   , POS_STANDING, STANCE_ALERT   , do_rescue   , 0, 0, 0 },
/*{ "readlist" , POS_PRONE   , STANCE_DEAD    , do_readlist , LVL_GOD, 0, 0 },*/
  { "restore"  , POS_PRONE   , STANCE_DEAD    , do_restore  , LVL_RESTORE, 0, CMD_OLC },
  { "rrestore" , POS_PRONE   , STANCE_DEAD    , do_rrestore , LVL_RESTORE, 0, CMD_OLC },
  { "pain"     , POS_PRONE   , STANCE_DEAD    , do_pain     , LVL_RESTORE, 0, CMD_OLC },
  { "rpain"    , POS_PRONE   , STANCE_DEAD    , do_rpain    , LVL_RESTORE, 0, CMD_OLC },
  { "retreat"  , POS_STANDING, STANCE_ALERT   , do_retreat  , 0, 0, 0 },
  { "return"   , POS_PRONE   , STANCE_DEAD    , do_return   ,-1, 0, CMD_MINOR_PARA | CMD_MAJOR_PARA | CMD_BOUND },
  { "redit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT, 0 },
  { "rename"   , POS_PRONE   , STANCE_DEAD    , do_rename   , LVL_GRGOD, 0, 0 },
  { "revoke"   , POS_PRONE   , STANCE_DEAD    , do_grant    , LVL_ADMIN, SCMD_REVOKE, CMD_ANY },
  { "roar"     , POS_STANDING, STANCE_ALERT   , do_roar     , 0, SCMD_ROAR, 0 },
  { "rofl"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "roll"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "ready"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "ruffle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "rlist"    , POS_PRONE   , STANCE_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "rnum"     , POS_PRONE   , STANCE_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "rsearch"  , POS_PRONE   , STANCE_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "rstat"    , POS_PRONE   , STANCE_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_RSTAT, CMD_ANY },
  { "sstat"    , POS_PRONE   , STANCE_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_SSTAT, CMD_ANY },
  { "rsdiamimp", POS_PRONE   , STANCE_DEAD    , do_rsdiamimp,-1, 0, 0 },

  { "say"      , POS_PRONE   , STANCE_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "'"        , POS_PRONE   , STANCE_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "save"     , POS_PRONE   , STANCE_SLEEPING, do_save     , LVL_GOD, 0 , CMD_ANY ^ CMD_CAST },
  { "score"    , POS_PRONE   , STANCE_DEAD    , do_score    , 0, 0, CMD_ANY },
  { "scan"     , POS_STANDING, STANCE_ALERT   , do_scan     , 0, 0, CMD_NOFIGHT },
  { "salute"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "scribe"   , POS_PRONE   , STANCE_RESTING , do_scribe   , 0, 0, 0 },
  { "scare"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "scold"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "scratch"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "scream"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "screw"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sdedit"   , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SDEDIT, 0 },
  { "sell"     , POS_STANDING, STANCE_ALERT   , do_not_here , 0, 0, CMD_NOFIGHT },
  { "send"     , POS_PRONE   , STANCE_DEAD    , do_send     , LVL_GRGOD, 0, CMD_ANY },
  { "set"      , POS_PRONE   , STANCE_DEAD    , do_set      , LVL_GOD, 0, CMD_ANY },
  { "search"   , POS_STANDING, STANCE_ALERT   , do_search   , 0, 0, CMD_NOFIGHT },
  { "sedit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT, 0 },
  { "seduce"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "shout"    , POS_PRONE   , STANCE_RESTING , do_gen_comm , 0, SCMD_SHOUT, CMD_OLC },
  { "shake"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "shadow"   , POS_PRONE   , STANCE_RESTING , do_follow   , 0, SCMD_SHADOW, CMD_HIDE },
  { "shapechange",POS_STANDING, STANCE_ALERT   , do_shapechange, 0, 0, CMD_NOFIGHT },
  { "shiver"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "show"     , POS_PRONE   , STANCE_DEAD    , do_show     , LVL_IMMORT, 0, CMD_ANY },
  { "shrug"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "shudder"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "shutdow"  , POS_PRONE   , STANCE_DEAD    , do_shutdown , LVL_REBOOT_MASTER, 0, 0 },
  { "shutdown" , POS_PRONE   , STANCE_DEAD    , do_shutdown , LVL_REBOOT_MASTER, SCMD_SHUTDOWN, 0 },
  { "sigh"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sing"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sip"      , POS_PRONE   , STANCE_RESTING , do_drink    , 0, SCMD_SIP, 0 },
  { "sit"      , POS_PRONE   , STANCE_RESTING , do_sit      , 0, 0, 0 },
  { "skills"   , POS_PRONE   , STANCE_SLEEPING, do_skills   , 1, 0, CMD_ANY },
  { "skillset" , POS_PRONE   , STANCE_DEAD    , do_skillset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "slist"    , POS_PRONE   , STANCE_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "snum"     , POS_PRONE   , STANCE_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "ssearch"  , POS_PRONE   , STANCE_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "sleep"    , POS_PRONE   , STANCE_SLEEPING, do_sleep    , 0, 0, 0 },
  { "slap"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "slobber"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "smell"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "smile"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "smirk"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "smoke"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snicker"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snap"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snarl"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sneeze"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sniff"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snoogie"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snore"    , POS_PRONE   , STANCE_SLEEPING, do_action   , 0, 0, 0 },
  { "snort"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "snowball" , POS_STANDING, STANCE_ALERT   , do_action   , LVL_OVERLORD, 0, CMD_NOFIGHT },
  { "snoop"    , POS_PRONE   , STANCE_DEAD    , do_snoop    , LVL_HEAD_B, 0, 0 },
  { "snuggle"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "songs"    , POS_PRONE   , STANCE_DEAD    , do_songs    , 0, 0, CMD_ANY },
  { "socials"  , POS_PRONE   , STANCE_DEAD    , do_commands , 0, SCMD_SOCIALS, CMD_ANY },
  { "spam"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "split"    , POS_PRONE   , STANCE_RESTING , do_split    , 1, 0, 0 },
  { "spells"   , POS_PRONE   , STANCE_DEAD    , do_spells   , 1, 0, CMD_ANY },
  { "spank"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "spit"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "springleap",POS_PRONE   , STANCE_RESTING , do_springleap, 0, 0, 0 },
  { "squeeze"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "stand"    , POS_PRONE   , STANCE_RESTING , do_stand    , 0, 0, 0 },
  { "stare"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "stat"     , POS_PRONE   , STANCE_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_STAT, CMD_ANY },
  { "stay"     , POS_PRONE   , STANCE_RESTING ,  do_move     , 0, SCMD_STAY  , CMD_HIDE | CMD_OLC },
  { "steal"    , POS_STANDING, STANCE_ALERT   , do_steal    , 1, 0, CMD_HIDE | CMD_NOFIGHT },
  { "steam"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "stow"     , POS_PRONE   , STANCE_RESTING , do_stow     , 0, 0, CMD_HIDE },
  { "stomp"    , POS_STANDING, STANCE_ALERT   , do_stomp    , 0, 0, 0 },
  { "stroke"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "strut"    , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "sulk"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "summon"   , POS_STANDING, STANCE_ALERT   , do_summon_mount, 0, 0, CMD_NOFIGHT },
  { "swat"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sweat"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "sweep"    , POS_STANDING, STANCE_ALERT   , do_sweep    ,-1, 0, 0 },
  { "switch"   , POS_PRONE   , STANCE_DEAD    , do_switch   , LVL_GOD, 0, CMD_ANY ^ CMD_OLC },
  { "syslog"   , POS_PRONE   , STANCE_DEAD    , do_syslog   , LVL_ATTENDANT, 0, CMD_ANY },
  { "stone"    , POS_STANDING, STANCE_ALERT   , do_not_here ,-1, 0, CMD_NOFIGHT },
  { "subclass" , POS_PRONE   , STANCE_RESTING , do_subclass , 0, 0, CMD_HIDE },

  { "tell"     , POS_PRONE   , STANCE_SLEEPING, do_tell     , 0, 0, CMD_ANY },
  { "terminate", POS_PRONE   , STANCE_DEAD    , do_terminate, LVL_HEAD_C, 0, 0 },
  { "tackle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "take"     , POS_STANDING, STANCE_ALERT   , do_get      , 0, 0, 0 },
  { "tantrum"  , POS_STANDING, STANCE_ALERT   , do_hitall   , 0, SCMD_TANTRUM, 0 },
  { "tango"    , POS_STANDING, STANCE_ALERT   , do_action   , 0, 0, CMD_NOFIGHT },
  { "tame"     , POS_STANDING, STANCE_ALERT   , do_tame     , 0, 0, CMD_NOFIGHT },
  { "tap"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "tarzan"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "taunt"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "taste"    , POS_PRONE   , STANCE_RESTING , do_eat      , 0, SCMD_TASTE, 0 },
  { "tease"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "tedit"    , POS_PRONE   , STANCE_DEAD    , do_tedit    , LVL_HEAD_C, 0, 0 },
  { "teleport" , POS_PRONE   , STANCE_DEAD    , do_teleport , LVL_GOD, 0, CMD_ANY },
  { "thank"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "think"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "thaw"     , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW, CMD_ANY },
  { "thirst"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "throatcut", POS_STANDING, STANCE_ALERT   , do_throatcut, 0, 0, CMD_NOFIGHT },
  { "throw"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "tip"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "title"    , POS_PRONE   , STANCE_DEAD    , do_title    , 1, 0, CMD_ANY },
  { "tickle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "time"     , POS_PRONE   , STANCE_DEAD    , do_time     , 0, 0, CMD_ANY },
  { "tip"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "toggle"   , POS_PRONE   , STANCE_DEAD    , do_toggle   , 0, 0, CMD_ANY ^ CMD_CAST },
  { "tongue"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "touch"    , POS_PRONE   , STANCE_RESTING , do_touch    , 0, 0, 0 },
  { "track"    , POS_STANDING, STANCE_ALERT   , do_track    , 0, 0, CMD_NOFIGHT },
  { "transfer" , POS_PRONE   , STANCE_DEAD    , do_trans    , LVL_GOD, 0, CMD_ANY },
  { "trigedit" , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT, 0 },
  { "trip"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "trophy"   , POS_PRONE   , STANCE_DEAD    , do_trophy   , 0, 0, CMD_ANY },
  { "tug"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "twibble"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "twiddle"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "twitch"   , POS_PRONE   , STANCE_SLEEPING, do_action   , 0, 0, 0 },
  { "typo"     , POS_PRONE   , STANCE_DEAD    , do_gen_write, 0, SCMD_TYPO , CMD_ANY },

  { "unlock"   , POS_SITTING, STANCE_RESTING , do_gen_door , 0, SCMD_UNLOCK, 0 },
  { "unban"    , POS_PRONE   , STANCE_DEAD    , do_unban    , LVL_GRGOD, 0, CMD_ANY },
/*{ "unbind"   , POS_PRONE   , STANCE_DEAD    , do_unbind   ,-1, 0, CMD_HIDE },*/
  { "ungrant"  , POS_PRONE   , STANCE_DEAD    , do_grant    , LVL_ADMIN, SCMD_UNGRANT, CMD_ANY },
  { "use"      , POS_SITTING, STANCE_RESTING , do_use      , 1, SCMD_USE, 0 },
  { "unaffect" , POS_PRONE   , STANCE_DEAD    , do_wizutil  , LVL_ATTENDANT, SCMD_UNAFFECT, CMD_ANY },
  { "users"    , POS_PRONE   , STANCE_DEAD    , do_users    , LVL_ATTENDANT, 0, CMD_ANY },
  { "uptime"   , POS_PRONE   , STANCE_DEAD    , do_date     , 0, SCMD_UPTIME, CMD_ANY },

  { "value"    , POS_STANDING, STANCE_ALERT   , do_not_here , 0, 0, CMD_HIDE | CMD_NOFIGHT },
  { "varset"   , POS_PRONE   , STANCE_DEAD    , do_varset   , LVL_GAMEMASTER, 0, CMD_ANY },
  { "varunset" , POS_PRONE   , STANCE_DEAD    , do_varunset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "version"  , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_VERSION, CMD_ANY },
  { "veto"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "visible"  , POS_PRONE   , STANCE_RESTING , do_visible  , 1, 0, CMD_HIDE },
  { "viewdam"  , POS_PRONE   , STANCE_DEAD    , do_viewdam  , LVL_GRGOD, 0, CMD_ANY },
  { "vnum"     , POS_PRONE   , STANCE_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "vlist"    , POS_PRONE   , STANCE_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "vsearch"  , POS_PRONE   , STANCE_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "vstat"    , POS_PRONE   , STANCE_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_VSTAT, CMD_ANY },
  { "zstat"    , POS_PRONE   , STANCE_DEAD    , do_zstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "estat"    , POS_PRONE   , STANCE_DEAD    , do_estat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "oestat"   , POS_PRONE   , STANCE_DEAD    , do_estat    , LVL_ATTENDANT, SCMD_OESTAT, CMD_ANY },
  { "restat"   , POS_PRONE   , STANCE_DEAD    , do_estat    , LVL_ATTENDANT, SCMD_RESTAT, CMD_ANY },
  { "vitem"    , POS_PRONE   , STANCE_DEAD    , do_vitem    , LVL_ATTENDANT, 0, CMD_ANY },
  { "vwear"    , POS_PRONE   , STANCE_DEAD    , do_vwear    , LVL_ATTENDANT, 0, CMD_ANY },

  { "wake"     , POS_PRONE   , STANCE_SLEEPING, do_wake     , 0, 0, 0 },
  { "walk"     , POS_STANDING, STANCE_ALERT   , do_move     , 0, 0, CMD_HIDE | CMD_NOFIGHT },
  { "wave"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "wear"     , POS_PRONE   , STANCE_RESTING , do_wear     , 0, 0, 0 },
  { "wait"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "weather"  , POS_PRONE   , STANCE_RESTING , do_weather  , 0, 0, CMD_ANY },
  { "wet"      , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "who"      , POS_PRONE   , STANCE_DEAD    , do_who      , 0, 0, CMD_ANY },
  { "whap"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "whatever" , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "whoami"   , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI, CMD_ANY },
  { "where"    , POS_PRONE   , STANCE_DEAD    , do_where    , LVL_ATTENDANT, 0, CMD_ANY },
  { "whisper"  , POS_PRONE   , STANCE_RESTING , do_spec_comm, 0, SCMD_WHISPER, CMD_OLC },
  { "whine"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "whistle"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "wield"    , POS_PRONE   , STANCE_RESTING , do_wield    , 0, 0, 0 },
  { "wiggle"   , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "wince"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "wink"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "withdraw" , POS_STANDING, STANCE_ALERT   , do_not_here , 1, 0, CMD_NOFIGHT },
  { "wiznet"   , POS_PRONE   , STANCE_DEAD    , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { ";"        , POS_PRONE   , STANCE_DEAD    , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { "wizhelp"  , POS_PRONE   , STANCE_DEAD    , do_commands , LVL_IMMORT, SCMD_WIZHELP, CMD_ANY },
  { "wizlist"  , POS_PRONE   , STANCE_DEAD    , do_textview , 0, SCMD_WIZLIST, CMD_ANY },
  { "wizlock"  , POS_PRONE   , STANCE_DEAD    , do_wizlock  , LVL_HEAD_B, 0, 0 },
  { "worship"  , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "write"    , POS_STANDING, STANCE_ALERT   , do_write    , 3, 0, CMD_NOFIGHT },

  { "yawn"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "yodel"    , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },

  { "zone"     , POS_PRONE   , STANCE_RESTING , do_action   , 0, 0, 0 },
  { "zedit"    , POS_PRONE   , STANCE_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT, 0 },
  { "zlist"    , POS_PRONE   , STANCE_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "znum"     , POS_PRONE   , STANCE_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "zreset"   , POS_PRONE   , STANCE_DEAD    , do_zreset   , LVL_ATTENDANT, 0, CMD_ANY },
  { "zsearch"  , POS_PRONE   , STANCE_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "game"     , POS_PRONE   , STANCE_DEAD    , do_game     , LVL_ATTENDANT, 0, CMD_ANY },
  { "world"    , POS_PRONE   , STANCE_DEAD    , do_world    , 0, 0, CMD_ANY },

  /* DG trigger commands */
  { "attach"   , POS_PRONE   , STANCE_DEAD    , do_attach   , LVL_IMPL, 0, 0 },
  { "z001#@@#"  , POS_PRONE   , STANCE_SLEEPING, do_action   ,-1, 0, 0 },
  { "detach"   , POS_PRONE   , STANCE_DEAD    , do_detach   , LVL_IMPL, 0, 0 },
  { "tlist"    , POS_PRONE   , STANCE_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "tnum"     , POS_PRONE   , STANCE_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "tsearch"  , POS_PRONE   , STANCE_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "tstat"    , POS_PRONE   , STANCE_DEAD    , do_tstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "log"      , POS_PRONE   , STANCE_DEAD    , do_mob_log  ,-1, 0, CMD_ANY },
  { "m_run_room_trig", POS_PRONE   , STANCE_DEAD    , do_m_run_room_trig, -1, 0, CMD_ANY },
  { "masound"  , POS_PRONE   , STANCE_DEAD    , do_masound  ,-1, 0, CMD_ANY },
  { "mat"      , POS_PRONE   , STANCE_DEAD    , do_mat      ,-1, 0, CMD_ANY },
  { "mdamage"  , POS_PRONE   , STANCE_DEAD    , do_mdamage  ,-1, 0, CMD_HIDE },
  { "mecho"    , POS_PRONE   , STANCE_DEAD    , do_mecho    ,-1, 0, CMD_ANY },
  { "mechoaround",POS_PRONE   , STANCE_DEAD    ,do_mechoaround,-1, 0, CMD_ANY },
  { "mexp"     , POS_PRONE   , STANCE_DEAD    , do_mexp     ,-1, 0, CMD_ANY },
  { "mforce"   , POS_PRONE   , STANCE_DEAD    , do_mforce   ,-1, 0, CMD_ANY },
  { "mgoto"    , POS_PRONE   , STANCE_DEAD    , do_mgoto    ,-1, 0, CMD_HIDE },
  { "mjunk"    , POS_PRONE   , STANCE_DEAD    , do_mjunk    ,-1, 0, CMD_ANY },
  { "mkill"    , POS_STANDING, STANCE_ALERT   , do_mkill    ,-1, 0, CMD_NOFIGHT },
  { "mload"    , POS_PRONE   , STANCE_DEAD    , do_mload    ,-1, 0, CMD_ANY },
  { "mpurge"   , POS_PRONE   , STANCE_DEAD    , do_mpurge   ,-1, 0, CMD_ANY },
  { "msave"    , POS_PRONE   , STANCE_DEAD    , do_msave    ,-1, 0, CMD_ANY },
  { "msend"    , POS_PRONE   , STANCE_DEAD    , do_msend    ,-1, 0, CMD_ANY },
  { "mskillset", POS_PRONE   , STANCE_DEAD    , do_mskillset,-1, 0, CMD_ANY },
  { "mteleport", POS_PRONE   , STANCE_DEAD    , do_mteleport,-1, 0, CMD_ANY },
  { "quest"    , POS_PRONE   , STANCE_DEAD    , do_quest    ,-1, 0, CMD_ANY },
  { "qadd"     , POS_PRONE   , STANCE_DEAD    , do_qadd     , LVL_HEAD_B, 0, CMD_ANY },
  { "qdel"     , POS_PRONE   , STANCE_DEAD    , do_qdel     , LVL_HEAD_B, 0, CMD_ANY },
  { "qlist"    , POS_PRONE   , STANCE_DEAD    , do_qlist    , LVL_ATTENDANT, 0, CMD_ANY },
  { "qstat"    , POS_PRONE   , STANCE_DEAD    , do_qstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "objupdate", POS_PRONE   , STANCE_DEAD    , do_objupdate, LVL_HEAD_C, 0, CMD_ANY },

  { "\n", 0, 0, 0, 0, 0, CMD_HIDE } };        /* this must be last */

const char *command_flags[] =
{
  "MEDITATE",
  "MAJOR PARA",
  "MINOR PARA",
  "HIDE",
  "BOUND",
  "CAST",
  "OLC",
  "NOFIGHT",
  "\n"
};

const char *fill[] =
{
  "in",
  "from",
  "with",
  "the",
  "on",
  "at",
  "to",
  "\n"
};

const char *reserved[] =
{
  "self",
  "me",
  "all",
  "room",
  "someone",
  "something",
  "\n"
};


void list_similar_commands(struct char_data *ch, char *arg)
{
  int found = FALSE, cmd;

  if (!PRF_FLAGGED(ch, PRF_NOHINTS)) {
    /* Display similar commands. */
    for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd) {
      if (*arg != *cmd_info[cmd].command)
        continue;
      if (!can_use_command(ch, cmd))
        continue;
      if (cmd_info[cmd].minimum_level < 0)
        continue;
      /* skip socials */
      if (cmd_info[cmd].command_pointer == do_action)
        continue;
      if (levenshtein_distance(arg, cmd_info[cmd].command) <= 2) {
        if (!found) {
          send_to_char("\r\nDid you mean:\r\n", ch);
          found = TRUE;
        }
        sprintf(buf, "  %s\r\n", cmd_info[cmd].command);
        send_to_char(buf, ch);
      }
    }
  }
}

/*
 * This is the actual command interpreter called from game_loop() in comm.c
 * It makes sure you are the proper level and position to execute the command,
 * then calls the appropriate function.
 */
void command_interpreter(struct char_data *ch, char *argument)
{
  int cmd, length;
  extern int no_specials;
  char *line;

  /* just drop to next line for hitting CR */
  skip_slash(&argument);
  skip_spaces(&argument);
  if (!*argument)
    return;

  /*
   * special case to handle one-character, non-alphanumeric commands;
   * requested by many people so "'hi" or ";godnet test" is possible.
   * Patch sent by Eric Green and Stefan Wasilewski.
   */
  if (!isalpha(*argument)) {
    arg[0] = argument[0];
    arg[1] = '\0';
    line = argument + 1;
  } else
    line = any_one_arg(argument, arg);

  /* otherwise, find the command */
  if (GET_LEVEL(ch) < LVL_IMMORT &&
      (command_wtrigger(ch, arg, line) ||
       command_mtrigger(ch, arg, line) ||
       command_otrigger(ch, arg, line)))
    return; /* command trigger took over */

  for (length = strlen(arg), cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
    if (!strncmp(cmd_info[cmd].command, arg, length))
      if (can_use_command(ch, cmd))
        break;

  if (IS_HIDDEN(ch) && !IS_SET(cmd_info[cmd].flags, CMD_HIDE)) {
    effect_from_char(ch, SPELL_NATURES_EMBRACE);
    GET_HIDDENNESS(ch) = 0;
  }

  if (PLR_FLAGGED(ch, PLR_MEDITATE) && !IS_SET(cmd_info[cmd].flags, CMD_MEDITATE)) {
    REMOVE_FLAG(PLR_FLAGS(ch), PLR_MEDITATE);
    act("$n ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
    send_to_char("&8You stop meditating.\r\n&0", ch);
  }

  if (*cmd_info[cmd].command == '\n') {
    send_to_char(HUH, ch);
    list_similar_commands(ch, arg);
  }
  else if (PLR_FLAGGED(ch, PLR_FROZEN) && GET_LEVEL(ch) < LVL_HEAD_B)
    send_to_char("You try, but the mind-numbing cold prevents you...\r\n", ch);
  else if (ch->desc && STATE(ch->desc) != CON_PLAYING &&
           !IS_SET(cmd_info[cmd].flags, CMD_OLC)) {
    if (ch->desc->olc)
      send_to_char("You can't use that command while in OLC.\r\n", ch);
    else
      send_to_char("You can't use that command while writing.\r\n", ch);
  }
  else if (PLR_FLAGGED(ch, PLR_BOUND) && GET_LEVEL(ch) < LVL_IMMORT &&
           !IS_SET(cmd_info[cmd].flags, CMD_BOUND))
    send_to_char("You try, but you're bound tight...\r\n", ch);
  else if (EFF_FLAGGED(ch, EFF_MAJOR_PARALYSIS) &&
           !IS_SET(cmd_info[cmd].flags, CMD_MAJOR_PARA))
    send_to_char("&6You're paralyzed to the bone!\r\n&0", ch);
  else if (EFF_FLAGGED(ch, EFF_MINOR_PARALYSIS) &&
           !IS_SET(cmd_info[cmd].flags, CMD_MINOR_PARA))
    send_to_char("&6You're paralyzed to the bone!\r\n&0", ch);
  else if (EFF_FLAGGED(ch, EFF_MESMERIZED) && GET_LEVEL(ch) < 100)
    send_to_char("You are too preoccupied with pretty illusions to do anything.\r\n", ch);
  else if (CASTING(ch) && !IS_SET(cmd_info[cmd].flags, CMD_CAST))
    send_to_char("&8You are busy spellcasting...&0\r\n", ch);
  else if (cmd_info[cmd].command_pointer == NULL)
    send_to_char("Sorry, that command hasn't been implemented yet.\r\n", ch);
  else if (IS_NPC(ch) && cmd_info[cmd].minimum_level >= LVL_IMMORT)
    send_to_char("You can't use immortal commands while switched.\r\n", ch);
  else if (GET_STANCE(ch) == STANCE_FIGHTING && cmd_info[cmd].flags & CMD_NOFIGHT)
      send_to_char("No way!  You're fighting for your life!\r\n", ch);
  else if (GET_STANCE(ch) < cmd_info[cmd].minimum_stance) {
     switch (GET_STANCE(ch)) {
       case STANCE_DEAD:
         send_to_char("Lie still; you are DEAD!!! :-(\r\n", ch);
         break;
       case STANCE_INCAP:
       case STANCE_MORT:
         send_to_char("You are in a pretty bad shape, unable to do anything!\r\n", ch);
         break;
       case STANCE_STUNNED:
         send_to_char("All you can do right now is think about the stars!\r\n", ch);
         break;
       case STANCE_SLEEPING:
         send_to_char("In your dreams, or what?\r\n", ch);
         break;
       case STANCE_RESTING:
         send_to_char("Nah... You feel too relaxed to do that..\r\n", ch);
         break;
       default:
         send_to_char("I don't know what you're up to, but you can't do that!\r\n", ch);
         break;
      }
  }
  else if (GET_POS(ch) < cmd_info[cmd].minimum_position)
    switch (cmd_info[cmd].minimum_position) {
       case POS_PRONE:
          send_to_char("I don't know what kind of pretzel you've twisted yourself into!\r\n", ch);
          break;
       case POS_SITTING:
          send_to_char("Maybe you should sit up first?\r\n", ch);
          break;
       case POS_KNEELING:
          send_to_char("Maybe you should kneel first?\r\n", ch);
          break;
       case POS_STANDING:
          send_to_char("Maybe you should get on your feet first?\r\n", ch);
          break;
       default:
          send_to_char("You'd better take to the air first.\r\n", ch);
          break;
    }
  else if (no_specials || !special(ch, cmd, line))
    ((*cmd_info[cmd].command_pointer) (ch, line, cmd, cmd_info[cmd].subcmd));
}

/**************************************************************************
 * Routines to handle aliasing                                            *
 **************************************************************************/
/* These routines were heavily modified to incorporate aliases            */
/* into the pfile.  --Fingon                                              */


/* completely rewritten --Fingon */
struct alias_data *find_alias(struct alias_data *alias, char *str)
{
  for (; alias; alias = alias->next)
    if (!str_cmp(alias->alias, str))
      return alias;

  return NULL;
}

void free_alias(struct alias_data *a)
{
  if (a->alias)
    free(a->alias);
  if (a->replacement)
    free(a->replacement);
  free(a);
}

void free_aliases(struct alias_data *alias_list) {
  struct alias_data *alias;
  while ((alias = alias_list)) {
    alias_list = alias->next;
    free_alias(alias);
  }
}

/* The interface to the outside world: do_alias */
/* Modified heavily --Fingon                    */
ACMD(do_alias)
{
  char *repl;
  struct alias_data *alias, *temp;
  struct char_data *vict;

  repl = any_one_arg(argument, arg);

  if (GET_LEVEL(ch) >= LVL_GOD && (vict = find_char_around_char(ch, find_vis_plr_by_name(ch, arg))))
    repl = any_one_arg(repl, arg);
  else
    vict = ch;

  if (IS_NPC(vict)) {
    send_to_char("NPCs don't have aliases.\r\n", ch);
    return;
  }

  if (!*arg) {
    /* no argument specified -- list currently defined aliases */
    send_to_char("Currently defined aliases:\r\n", ch);

    if ((alias = GET_ALIASES(vict)))
      for (; alias; alias = alias->next) {
        sprintf(buf, "%-15s %s\r\n", alias->alias, alias->replacement);
        send_to_char(buf, ch);
      }
    else
      send_to_char(" None.\r\n", ch);
  }
  else if (ch == vict || (GET_LEVEL(ch) >= LVL_ADMIN && GET_LEVEL(ch) > GET_LEVEL(vict))) {
    /* otherwise, add or remove aliases */

    /* is this an alias we've already defined? */
    if ((alias = find_alias(GET_ALIASES(vict), arg))) {
      REMOVE_FROM_LIST(alias, GET_ALIASES(vict), next);
      free_alias(alias);
    }

    skip_spaces(&repl);

    /* if no replacement string is specified, assume we want to delete */
    if (!*repl) {
      if (alias)
        send_to_char("Alias deleted.\r\n", ch);
      else
        send_to_char("No such alias.\r\n", ch);
    }
    else {

      /* otherwise, either add or redefine an alias */

      if (!str_cmp(arg, "alias")) {
        send_to_char("You can't alias 'alias'.\r\n", ch);
        return;
      }

      /* find a blank alias slot */
      CREATE(alias, struct alias_data, 1);
      alias->alias = strdup(arg);
      delete_doubledollar(repl);
      alias->replacement = strdup(repl);
      if (strchr(repl, ALIAS_SEP_CHAR) || strchr(repl, ALIAS_VAR_CHAR))
        alias->type = ALIAS_COMPLEX;
      else
        alias->type = ALIAS_SIMPLE;
      alias->next = GET_ALIASES(vict);
      GET_ALIASES(vict) = alias;
      send_to_char("Alias added.\r\n", ch);
    }
  }
  else {
    sprintf(buf, "You cannot modify %s's aliases.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
  }
}

/*
 * Valid numeric replacements are only $1 .. $9 (makes parsing a little
 * easier, and it's not that much of a limitation anyway.)  Also valid
 * is "$*", which stands for the entire original line after the alias.
 * ";" is used to delimit commands.
 */
#define NUM_TOKENS       9

void perform_complex_alias(struct char_data *ch, struct txt_q *input_q, char *orig, struct alias_data *alias)
{
  struct txt_q temp_queue;
  char *tokens[NUM_TOKENS], *temp, *write_point;
  int num_of_tokens = 0, num;

  /* First, parse the original string */
  temp = strtok(strcpy(buf2, orig), " ");
  while (temp != NULL && num_of_tokens < NUM_TOKENS) {
    tokens[num_of_tokens++] = temp;
    temp = strtok(NULL, " ");
  }

  /* initialize */
  write_point = buf;
  temp_queue.head = temp_queue.tail = NULL;

  /* now parse the alias */
  for (temp = alias->replacement; *temp; temp++) {
    if (*temp == ALIAS_SEP_CHAR) {
      *write_point = '\0';
      buf[MAX_INPUT_LENGTH - 1] = '\0';
      write_to_q(buf, &temp_queue, 1, ch->desc);
      write_point = buf;
    } else if (*temp == ALIAS_VAR_CHAR) {
      temp++;
      if ((num = *temp - '1') < num_of_tokens && num >= 0) {
        strcpy(write_point, tokens[num]);
        write_point += strlen(tokens[num]);
      } else if (*temp == ALIAS_GLOB_CHAR) {
        strcpy(write_point, orig);
        write_point += strlen(orig);
      } else if ((*(write_point++) = *temp) == '$')        /* redouble $ for act safety */
        *(write_point++) = '$';
    } else
      *(write_point++) = *temp;
  }

  *write_point = '\0';
  buf[MAX_INPUT_LENGTH - 1] = '\0';
  write_to_q(buf, &temp_queue, 1, ch->desc);

  /* push our temp_queue on to the _front_ of the input queue */
  if (input_q->head == NULL)
    *input_q = temp_queue;
  else {
    temp_queue.tail->next = input_q->head;
    input_q->head = temp_queue.head;
  }
}


/*
 * Given a character and a string, perform alias replacement on it.
 *
 * Return values:
 *   0: String was modified in place; call command_interpreter immediately.
 *   1: String was _not_ modified in place; rather, the expanded aliases
 *      have been placed at the front of the character's input queue.
 */
int perform_alias(struct descriptor_data *d, char *orig)
{
  char first_arg[MAX_INPUT_LENGTH], *ptr;
  struct alias_data *alias;

  /* Mobs don't have aliases. */
  if (IS_NPC(d->character))
    return (0);

  /* Quit now if there aren't any aliases */
  if (!GET_ALIASES(d->character))
    return (0);

  /* find the alias we're supposed to match */
  ptr = any_one_arg(orig, first_arg);

  /* bail out if it's null */
  if (!*first_arg)
    return 0;

  /* if the first arg is not an alias, return without doing anything */
  if (!(alias = find_alias(GET_ALIASES(d->character), first_arg)))
    return 0;

  if (alias->type == ALIAS_SIMPLE) {
    strcpy(orig, alias->replacement);
    return 0;
  } else {
    perform_complex_alias(d->character, &d->input, ptr, alias);
    return 1;
  }
}



/***************************************************************************
 * Various other parsing utilities                                         *
 **************************************************************************/

/*
 * searches an array of strings for a target string.  "exact" can be
 * 0 or non-0, depending on whether or not the match must be exact for
 * it to be returned.  Returns -1 if not found; 0..n otherwise.  Array
 * must be terminated with a '\n' so it knows to stop searching.
 *
 * searchblock follows a similar naming convention to strcmp:
 * searchblock is case-sensitive, search_block is case-insensitive.
 * Often, which one you use only depends on the case of items in your
 * list, because any_one_arg and one_argument always return lower case
 * arguments.
 */
int searchblock(char *arg, const char **list, bool exact)
{
  register int i, l;

  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strcmp(arg, *(list + i)))
        return (i);
  } else {
    if (!l)
      l = 1;                        /* Avoid "" to match the first available
                                 * string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strncmp(arg, *(list + i), l))
        return (i);
  }

  return -1;
}

int search_block(const char *arg, const char **list, bool exact)
{
  register int i, len;

  if (!arg)
    return -1;

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!str_cmp(arg, *(list + i)))
        return (i);
  } else {
    len = strlen(arg);
    if (!len)
      len = 1;                        /* Avoid "" to match the first available
                                   string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strn_cmp(arg, *(list + i), (unsigned) len))
        return (i);
  }

  return (-1);
}


/* \s*\d+ */
bool is_number(const char *str)
{
  if (!str || !*str)
    return FALSE;

  while (*str && isspace(*str))
    ++str;

  while (*str)
    if (!isdigit(*(str++)))
      return FALSE;

  return TRUE;
}

/* \d+ */
bool is_positive_integer(const char *str)
{
  if (!str || (!*str))
    return FALSE;

  while (*str)
    if (!isdigit(*(str++)))
      return FALSE;

  return TRUE;

}

/* [+-]\d+ */
bool is_integer(const char *str)
{
  if (!str)
    return FALSE;

  if (*str == '-')
    ++str;

  return is_positive_integer(str);
}

/* -\d+ For completeness sake */
bool is_negative_integer(const char *str)
{
  if (!str || *(str++) != '-')
    return FALSE;

  return is_positive_integer(str);
}

void skip_slash(char **string)
{
  if (**string && ((**string == '/') || (**string == '\\')))
    (*string)++;
}


void skip_spaces(char **string)
{
  for (; **string && isspace(**string); (*string)++);
}


/* Given a string, change all instances of double dollar signs ($$) to single
 * dollar signs ($).  When strings come in, all $'s are changed to $$'s to
 * avoid having users be able to crash the system if the inputted string is
 * eventually sent to act().  If you are using user input to produce screen
 * output AND YOU ARE SURE IT WILL NOT BE SENT THROUGH THE act() FUNCTION
 * (i.e., do_gecho, do_title, but NOT do_gsay), you can call
 * delete_doubledollar() to make the output look correct.
 * Modifies the string in-place. */
char *delete_doubledollar(char *string)
{
  char *read, *write;

  /* If the string has no dollar signs, return immediately */
  if ((write = strchr(string, '$')) == NULL)
    return string;

  /* Start from the location of the first dollar sign */
  read = write;

  /* Until we reach the end of the string... */
  while (*read)
    if ((*(write++) = *(read++)) == '$') /* copy one char */
      if (*read == '$')
        read++; /* skip if we saw 2 $'s in a row */

  *write = '\0';

  return string;
}


int fill_word(char *argument)
{
  /* Needs to be case-insensitive since fill_word is used by the nanny for
   * name-checking */
  return (search_block(argument, fill, TRUE) >= 0);
}


int reserved_word(char *argument)
{
  /* Needs to be case-insensitive since fill_word is used by the nanny for
   * name-checking */
  return (search_block(argument, reserved, TRUE) >= 0);
}


/*
 * copy the first non-fill-word, space-delimited argument of 'argument'
 * to 'first_arg'; return a pointer to the remainder of the string.
 */
char *one_argument(char *argument, char *first_arg)
{
  char *begin = first_arg;

  do {
    skip_spaces(&argument);

    first_arg = begin;
    while (*argument && !isspace(*argument)) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }

    *first_arg = '\0';
  } while (fill_word(begin));

  return argument;
}


char *delimited_arg(char *argument, char *first_arg, char delimiter)
{
  skip_spaces(&argument);

  if (*argument == delimiter) {
    argument++;
    while (*argument && *argument != delimiter) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }
    argument++;
  }
  else {
    while (*argument && !isspace(*argument)) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }
  }

  *first_arg = '\0';

  return argument;
}

/* Like delimited_arg, but don't lowercase everything */
char *delimited_arg_case(char *argument, char *first_arg, char delimiter)
{
  skip_spaces(&argument);

  if (*argument == delimiter) {
    argument++;
    while (*argument && *argument != delimiter) {
      *(first_arg++) = *argument;
      argument++;
    }
    argument++;
  }
  else {
    while (*argument && !isspace(*argument)) {
      *(first_arg++) = *argument;
      argument++;
    }
  }

  *first_arg = '\0';

  return argument;
}

char *delimited_arg_all(char *argument, char *first_arg, char delimiter)
{
  skip_spaces(&argument);

  if (*argument == delimiter) {
    argument++;
    while (*argument && *argument != delimiter) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }
    argument++;
  }
  else {
    while (*argument) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }
  }

  *first_arg = '\0';

  return argument;
}

/*
 * one_word is like one_argument, except that words in quotes ("") are
 * considered one word.
 */
char *one_word(char *argument, char *first_arg)
{
  return delimited_arg(argument, first_arg, '\"');
}


/* same as one_argument except that it doesn't ignore fill words */
char *any_one_arg(char *argument, char *first_arg)
{
  skip_spaces(&argument);

  while (*argument && !isspace(*argument)) {
    *(first_arg++) = LOWER(*argument);
    argument++;
  }

  *first_arg = '\0';

  return argument;
}


/*
 * Same as one_argument except that it takes two args and returns the rest;
 * ignores fill words
 */
char *two_arguments(char *argument, char *first_arg, char *second_arg)
{
  return one_argument(one_argument(argument, first_arg), second_arg); /* :-) */
}



/*
 * determine if a given string is an abbreviation of another
 * (now works symmetrically -- JE 7/25/94)
 *
 * that was dumb.  it shouldn't be symmetrical.  JE 5/1/95
 *
 * returnss 1 if arg1 is an abbreviation of arg2
 */
int is_abbrev(const char *arg1, const char *arg2)
{
  if (!*arg1)
    return 0;

  for (; *arg1 && *arg2; arg1++, arg2++)
    if (LOWER(*arg1) != LOWER(*arg2))
      return 0;

  if (!*arg1)
    return 1;
  else
    return 0;
}
void display_classes(struct descriptor_data *d, int select) {
  /*  int x; */ /* Commented out for commenting of - Subclassing explaination/preface RSD */
  int char_race;
  int mageok, warriorok, rogueok, clericok, shamanok;

  char_race = (int)GET_RACE(d->character);
  *buf = '\0';
  *buf2 = '\0';
  mageok = class_ok_race[char_race][CLASS_SORCERER];
  warriorok = class_ok_race[char_race][CLASS_WARRIOR];
  rogueok = class_ok_race[char_race][CLASS_ROGUE];
  clericok = class_ok_race[char_race][CLASS_CLERIC];
  shamanok = 0;
  /* commenter out by Fingh 11/7 class_ok_race[char_race][CLASS_SHAMAN]; */
  if(select){
    send_to_char(subclass_descrip, d->character);
    send_to_char(subclass_descrip2, d->character);
    send_to_char("\r\n&5Class selection menu - \r\n ",d->character);  /* Added return newline after menu - RSD */
  }
  /*  send_to_char("&1&b(&0&5*&1&b) denotes a class available to your race!&0&5\r\n\r\n", d->character); */

  /*
    for (x = 0; x < NUM_CLASSES; x++)
    if (class_ok_race[(int)GET_RACE(d->character)][x])
    send_to_char(class_display[x], d->character);
    send_to_char("\nClass: ", d->character);
  */
  /* Subclassing explaination/preface */
/*  sprintf(buf,"&5&b");
  if(warriorok){
    sprintf(buf, "%s%-16.16s ", buf,
            strip_ansi(pc_class_types[CLASS_WARRIOR]));
    sprintf(buf2, "%-16.16s ", "=======");
  }
  if(clericok) {
    sprintf(buf, "%s%-16.16s ", buf,
            strip_ansi(pc_class_types[CLASS_CLERIC]));
    sprintf(buf2, "%s%-16.16s ", buf2, "======");
  }
  if(mageok) {
    sprintf(buf, "%s%-16.16s ", buf,
            strip_ansi(pc_class_types[CLASS_SORCERER]));
    sprintf(buf2, "%s%-16.16s ", buf2, "========");
  }
  if(rogueok) {
    sprintf(buf, "%s%-16.16s ", buf,
            strip_ansi(pc_class_types[CLASS_ROGUE]));
    sprintf(buf2, "%s%-16.16s ", buf2, "=====");
  }
  if(shamanok) {
    sprintf(buf, "%s%-16.16s", buf,
            strip_ansi(pc_class_types[CLASS_SHAMAN]));
    sprintf(buf2, "%s%-16.16s", buf2, "======");
  }
  sprintf(buf,"%s\r\n", buf);
  send_to_char(buf, d->character);
  send_to_char(buf2, d->character);
  sprintf(buf, "\r\n&5");
  for (x=0;x<MAX(MAX(MAX(WARRIOR_SUBCLASSES, CLERIC_SUBCLASSES), MAGE_SUBCLASSES), ROGUE_SUBCLASSES);x++) {
    if(warriorok)
      if (x < WARRIOR_SUBCLASSES)
        sprintf(buf, "%s%s%-15.15s ", buf,
                class_ok_race[char_race][warrior_subclasses[x]] ? "*" : " ",
                strip_ansi(pc_class_types[warrior_subclasses[x]]));
      else
        sprintf(buf, "%s%-16.16s ", buf, " ");
    if(clericok)
      if (x < CLERIC_SUBCLASSES)
        sprintf(buf, "%s%s%-15.15s ", buf,
                class_ok_race[char_race][cleric_subclasses[x]] ? "*" : " ",
                strip_ansi(pc_class_types[cleric_subclasses[x]]));
      else
        sprintf(buf, "%s%-16.16s ", buf, " ");
    if(mageok)
      if (x < MAGE_SUBCLASSES)
        sprintf(buf, "%s%s%-15.15s ", buf,
                class_ok_race[char_race][mage_subclasses[x]] ? "*" : " ",
                strip_ansi(pc_class_types[mage_subclasses[x]]));
      else
        sprintf(buf, "%s%-16.16s ", buf, " ");
    if(rogueok)
      if (x < ROGUE_SUBCLASSES)
        sprintf(buf, "%s%s%-15.15s", buf,
                class_ok_race[char_race][rogue_subclasses[x]] ? "*" : " ",
                strip_ansi(pc_class_types[rogue_subclasses[x]]));
      else
        sprintf(buf, "%s%-16.16s", buf, " ");

    sprintf(buf, "%s\r\n", buf);
  }
*/
  if(select)
    sprintf(buf, "%s\r\n&6Choose -%s%s%s%s: ", buf,
            warriorok ? " [&0&1&bw&0&6]arrior" : "",
            clericok ? " [&0&1&bc&0&6]leric" : "",
            mageok ? " [&0&1&bs&0&6]orcerer" : "",
            rogueok ? " [&0&1&br&0&6]ogue" : "");
  send_to_char(buf, d->character);
  send_to_char("&0", d->character);

}

/* return first space-delimited token in arg1; remainder of string in arg2 */
void half_chop(char *string, char *arg1, char *arg2)
{
  char *temp;

  temp = any_one_arg(string, arg1);
  skip_spaces(&temp);
  strcpy(arg2, temp);
}



/* Used in specprocs, mostly.  (Exactly) matches "command" to cmd number */
int find_command(char *command)
{
  int cmd;

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (!strcmp(cmd_info[cmd].command, command))
      return cmd;

  return -1;
}


int parse_command(char *command)
{
  int cmd, length = strlen(command);

  for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd)
    if (!strncmp(cmd_info[cmd].command, command, length))
      return cmd;

  return -1;
}


int special(struct char_data *ch, int cmd, char *arg)
{
  register struct obj_data *i;
  register struct char_data *k;
  int j;

  /* special in room? */
  if (GET_ROOM_SPEC(ch->in_room) != NULL)
    if (GET_ROOM_SPEC(ch->in_room) (ch, world + ch->in_room, cmd, arg))
      return 1;

  /* special in equipment list? */
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j) && GET_OBJ_SPEC(GET_EQ(ch, j)) != NULL)
      if (GET_OBJ_SPEC(GET_EQ(ch, j)) (ch, GET_EQ(ch, j), cmd, arg))
        return 1;

  /* special in inventory? */
  for (i = ch->carrying; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
        return 1;

  /* special in mobile present? */
  for (k = world[ch->in_room].people; k; k = k->next_in_room)
    if (GET_MOB_SPEC(k) != NULL && !MOB_FLAGGED(k, MOB_NOSCRIPT))
      if (GET_MOB_SPEC(k) (ch, k, cmd, arg))
        return 1;

  /* special in object present? */
  for (i = world[ch->in_room].contents; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
        return 1;

  return 0;
}



/* *************************************************************************
 *  Stuff for controlling the non-playing sockets (get name, pwd etc)      *
 ************************************************************************* */


/* locate entry in p_table with entry->name == name. -1 mrks failed search */
int find_name(char *name)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++) {
    if (!str_cmp((player_table + i)->name, name))
      return i;
  }

  return -1;
}


#define RECON                1
#define USURP                2
#define UNSWITCH        3

int perform_dupe_check(struct descriptor_data *d)
{
  struct descriptor_data *k, *next_k;
  struct char_data *target = NULL, *ch, *next_ch;
  int mode = 0;

  int id = GET_IDNUM(d->character);

  /*
   * Now that this descriptor has successfully logged in, disconnect all
   * other descriptors controlling a character with the same ID number.
   */

  for (k = descriptor_list; k; k = next_k) {
    next_k = k->next;

    if (k == d)
      continue;

    if (k->original && (GET_IDNUM(k->original) == id)) {    /* switched char */
      write_to_output("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
      if (k->character && k->original->player.level <= 100) {
        if (POSSESSED(k->character))
          do_shapechange(k->character, "me", 0, 1);
        mode = UNSWITCH;
      } else if (!target) {
        target = k->original;
        mode = UNSWITCH;
      }
      if (k->character)
        k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
    } else if (k->character && (GET_IDNUM(k->character) == id)) {
      if (!target && STATE(k) == CON_PLAYING) {
        write_to_output("\r\nThis body has been usurped!\r\n", k);
        target = k->character;
        mode = USURP;
      }
      k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
      write_to_output("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
    }
  }

  /*
   * now, go through the character list, deleting all characters that
   * are not already marked for deletion from the above step (i.e., in the
   * CON_HANGUP state), and have not already been selected as a target for
   * switching into.  In addition, if we haven't already found a target,
   * choose one if one is available (while still deleting the other
   * duplicates, though theoretically none should be able to exist).
   */

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    if (IS_NPC(ch))
      continue;
    if (GET_IDNUM(ch) != id)
      continue;

    /* ignore chars with descriptors (already handled by above step) */
    if (ch->desc)
      continue;

    /* don't extract the target char we've found one already */
    if (ch == target)
      continue;

    /* we don't already have a target and found a candidate for switching */
    if (!target) {
      target = ch;
      mode = RECON;
      continue;
    }

    /* we've found a duplicate - blow him away, dumping his eq in limbo. */
    if (ch->in_room != NOWHERE)
      char_from_room(ch);
    char_to_room(ch, 1);
    extract_char(ch);
  }

  /* no target for swicthing into was found - allow login to continue */
  if (!target)
    return 0;

  /* Okay, we've found a target.  Connect d to target. */
  free_char(d->character); /* get rid of the old char */
  d->character = target;
  d->character->desc = d;
  d->original = NULL;
  d->character->char_specials.timer = 0;
  d->character->forward = NULL;
  REMOVE_FLAG(PLR_FLAGS(d->character), PLR_WRITING);
  REMOVE_FLAG(PLR_FLAGS(d->character), PLR_MAILING);
  STATE(d) = CON_PLAYING;

  switch (mode) {
  case RECON:
    write_to_output("Reconnecting.\r\n", d);
    act("$n has reconnected.", TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case USURP:
    write_to_output("Overriding old connection.\r\n", d);
    act("$n suddenly keels over in pain, surrounded by a white aura...\r\n"
        "$n's body has been taken over by a new spirit!",
        TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s has re-logged in ... disconnecting old socket.",
            GET_NAME(d->character));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case UNSWITCH:
    write_to_output("Reconnecting to unswitched char.", d);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  }

  return 1;
}


int enter_player_game(struct descriptor_data *d)
{
  int load_result;
  int load_room;
  int i;

  extern int r_mortal_start_room;
  extern int r_immort_start_room;
  extern int r_frozen_start_room;

  reset_char(d->character);
  if (GET_AUTOINVIS(d->character) > -1)
     GET_INVIS_LEV(d->character) =
        MIN(GET_LEVEL(d->character), GET_AUTOINVIS(d->character));

  if ((load_room = GET_LOADROOM(d->character)) != NOWHERE)
    load_room = real_room(load_room);

  /* If char was saved with NOWHERE, or real_room above failed... */
  if (load_room == NOWHERE) {
    if (GET_LEVEL(d->character) >= LVL_IMMORT) {
      load_room = real_room(GET_HOMEROOM(d->character));
      if (load_room < 0) {
        log("SYSERR: An immortal start room does not exist.");
        load_room = r_immort_start_room;
      }
    }
    else {
      load_room = real_room(GET_HOMEROOM(d->character));
      if (load_room < 0) {
        log("SYSERR: Mortal start room does not exist.  Change in config.c.");
        load_room = r_mortal_start_room;
      }
    }
  }

  if (PLR_FLAGGED(d->character, PLR_FROZEN))
    load_room = r_frozen_start_room;

  char_to_room(d->character, load_room);
  if ((load_result = load_objects(d->character)))
    if (GET_LEVEL(d->character) < LVL_IMMORT &&
        !PLR_FLAGGED(d->character, PLR_FROZEN)) {
      char_from_room(d->character);
      char_to_room(d->character, load_room);
    }
  load_quests(d->character);

  d->character->player.time.logon = time(0);
  GET_ID(d->character) = GET_IDNUM(d->character);
  d->character->next = character_list;
  character_list = d->character;

  /* send_save_description() will use this actual, error-checked value for the load room */
  GET_LOADROOM(d->character) = load_room == NOWHERE ? NOWHERE : world[load_room].vnum;
  send_save_description(d->character, NULL, TRUE);
  save_player_char(d->character);
  GET_QUIT_REASON(d->character) = QUIT_AUTOSAVE;

  /*
   * A couple of hacks to reconnect things if the player logged out
   * to the menu and then re-entered the game
   */
  if (GET_CLAN_MEMBERSHIP(d->character))
    GET_CLAN_MEMBERSHIP(d->character)->player = d->character;
  /* restart cooldowns */
  for (i = 0; i < NUM_COOLDOWNS; ++i)
    if (GET_COOLDOWN(d->character, i)) {
      SET_COOLDOWN(d->character, i, GET_COOLDOWN(d->character, i));
      break;
    }

  clan_notification(GET_CLAN(d->character), d->character,
                    "%s has entered the game.", GET_NAME(d->character));

  return load_result;
}

void clear_player_name(struct char_data *ch)
{
   if (ch->player.short_descr) {
      free(ch->player.short_descr);
      ch->player.short_descr = NULL;
   }
   if (ch->player.namelist) {
      free(ch->player.namelist);
      ch->player.namelist = NULL;
   }
}

void set_player_name(struct char_data *ch, char *name)
{
   char *s;

   clear_player_name(ch);
   ch->player.short_descr = strdup(CAP(name));
   ch->player.namelist = strdup(name);

   for (s = ch->player.namelist; *s; s++)
      *s = tolower(*s);
}


/* deal with newcomers and other non-playing sockets */
void nanny(struct descriptor_data *d, char *arg)
{
  char bcbuf[15] = "0";
  int player_i, load_result;
  char tmp_name[MAX_INPUT_LENGTH];
#ifdef PRODUCTION
  extern char *GREETINGS;
  extern char *GREETINGS2;
  extern char *GREETINGS3;
  extern char *GREETINGS4;
#else
  extern char *TEST_GREETING;
  extern char *TEST_GREETING2;
  extern char *TEST_GREETING3;
#endif
  extern char *WHOAREYOU;
#ifdef PRODUCTION
  extern char *NAMES_EXPLANATION;
#else
#endif
  extern int max_bad_pws;
  extern void modify_player_index_file(char *name, char *newname);
  extern int make_count;
  int color = 0;
  int set_new_home_town(int race, int class, char);
  int i;

  struct {
    int state;
    void (*func)(struct descriptor_data *, char *);
  } olc_functions[] = {
    { CON_OEDIT,    oedit_parse },
    { CON_IEDIT,    oedit_parse },
    { CON_ZEDIT,    zedit_parse },
    { CON_SEDIT,    sedit_parse },
    { CON_MEDIT,    medit_parse },
    { CON_REDIT,    redit_parse },
    { CON_TRIGEDIT, trigedit_parse },
    { CON_HEDIT,    hedit_parse },
    { CON_SDEDIT,   sdedit_parse },
    { CON_GEDIT,    gedit_parse },
    { -1,           NULL },
  };

  skip_spaces(&arg);

  if (d->character == NULL) {
    CREATE(d->character, struct char_data, 1);
    clear_char(d->character);
    CREATE(d->character->player_specials, struct player_special_data, 1);
    d->character->desc = d;
  }

  /* Quick check for the OLC states. */
  for (player_i = 0; olc_functions[player_i].state >= 0; ++player_i)
    if (STATE(d) == olc_functions[player_i].state) {
      /* Allow lines starting with ~ to go to the command interpreter */
      if (*arg == '~') {
        if (PRF_FLAGGED(d->character, PRF_OLCCOMM)) {
          command_interpreter(d->character, ++arg);
          write_to_output("~: ", d);
        }
        else
          write_to_output("You must have OLCComm toggled on to use commands in OLC.\r\n", d);
      }
      else
        (*olc_functions[player_i].func)(d, arg);
      return;
    }

  switch (STATE(d)) {
  case CON_QANSI:
    if ((make_count >=0 )) {
      sprintf(bcbuf, " %d", make_count);
    }
    switch (yesno_result(arg)) {
       case YESNO_YES:
       case YESNO_NONE:
         SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
         SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
         write_to_output("Color is on.\r\n", d);
#ifdef PRODUCTION
         write_to_output(GREETINGS, d);
         write_to_output(GREETINGS2, d);
         write_to_output(GREETINGS3, d);
         write_to_output(GREETINGS4, d);
#else
         write_to_output(TEST_GREETING, d);
         write_to_output(TEST_GREETING2, d);
         write_to_output(TEST_GREETING3, d);
#endif
         write_to_output(bcbuf, d);
         write_to_output(WHOAREYOU, d);
         STATE(d) = CON_GET_NAME;
         break;
      case YESNO_NO:
         REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
         REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
         write_to_output("Color is off.\r\n", d);
#ifdef PRODUCTION
         write_to_output(GREETINGS, d);
         write_to_output(GREETINGS2, d);
         write_to_output(GREETINGS3, d);
         write_to_output(GREETINGS4, d);
#else
         write_to_output(TEST_GREETING, d);
         write_to_output(TEST_GREETING2, d);
         write_to_output(TEST_GREETING3, d);
#endif
         write_to_output(bcbuf, d);
         write_to_output(WHOAREYOU, d);
         STATE(d) = CON_GET_NAME;
         break;
      default:
         write_to_output("Please answer Y or N.\r\n", d);
         write_to_output("Do you want ANSI terminal support? (Y/n) ", d);
    }
    break;
   case CON_GET_NAME:
      /* They merely pressed enter... disconnect them. */
      if (!*arg) {
         close_socket(d);
         return;
      }

      /* Basic name kosherness check:
       *  - must be at least 2 characters long
       *  - must be no more than MAX_NAME_LENGTH long
       *  - fill_word()  (??)
       *  - reserved_word()  (??)
       */

      if ((_parse_name(arg, tmp_name)) || strlen(tmp_name) < 2 ||
            strlen(tmp_name) > MAX_NAME_LENGTH ||
            fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
         write_to_output("Invalid name, please try another.\r\n"
            "Name: ", d);
         return;
      }

      if ((player_i = load_player(tmp_name, d->character)) > -1) {

         /* See if a deleted player's file was loaded... */
         if (PLR_FLAGGED(d->character, PLR_DELETED)) {
            if ((player_i = get_ptable_by_name(tmp_name)) >= 0)
               delete_player(player_i);
            free_char(d->character);
            CREATE(d->character, struct char_data, 1);
            clear_char(d->character);
            CREATE(d->character->player_specials, struct player_special_data, 1);
            d->character->desc = d;
            set_player_name(d->character, tmp_name);
            GET_PFILEPOS(d->character) = player_i;

            if (color) {
               SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
               SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
            }
            else {
               REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
               REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
            }
            sprintf(buf, "\r\nDo you want to make a new character called %s? ", tmp_name);
            write_to_output(buf, d);
            STATE(d) = CON_NAME_CNFRM;
         }
         else {
            /* An existing player's name was entered, and the pfile was successfully loaded */

            if (PRF_FLAGGED(d->character, PRF_COLOR_1))
               color = 1;

            /* undo it just in case they are set */
            REMOVE_FLAG(PLR_FLAGS(d->character), PLR_WRITING);
            REMOVE_FLAG(PLR_FLAGS(d->character), PLR_MAILING);
            REMOVE_FLAG(PLR_FLAGS(d->character), PLR_CRYO);

            if (color) {
               SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
               SET_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
            }
            else {
               REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1);
               REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_2);
            }

            write_to_output("Password: ", d);
            echo_off(d);
            d->idle_tics = 0;
            STATE(d) = CON_PASSWORD;
         }
      }
      else {
         /* No player loaded: we might make a new character. */

         if (ispell_name_check(tmp_name)) {
            /* Take a character name that is a word in the dictionary or
               closely resembles a word in the dictionary and make them
               think it's a valid existing character name and boot the
               connection.  Yes I'm evil - RSD 8/29/2002 <-- genius
             */
            sprintf(buf,"%s is being ninja rejected by the name approval code.", tmp_name);
            log("%s",buf);
            write_to_output("Welcome back!\r\n",d);
            write_to_output("Password: ", d);
            echo_off(d);
            d->idle_tics = 0;
            STATE(d) = CON_ISPELL_BOOT;
            return;
         }

         if (!Valid_Name(tmp_name)) {
            write_to_output("Invalid name, please try another.\r\n", d);
            write_to_output("Name: ", d);
            return;
         }

         set_player_name(d->character, tmp_name);

         sprintf(buf, "\r\nDo you want to make a new character called %s? ", tmp_name);
         write_to_output(buf, d);
         STATE(d) = CON_NAME_CNFRM;
         /* End of new player business */
      }

    break;
  case CON_NAME_CNFRM:                /* wait for conf. of new name    */
    switch (yesno_result(arg)) {
       case YESNO_YES:
         if (isbanned(d->host) >= BAN_NEW) {
            sprintf(buf, "Request for new char %s denied from [%s] (siteban)",
                  GET_NAME(d->character), d->host);
            mudlog(buf, NRM, LVL_GOD, TRUE);
            write_to_output("Sorry, new characters are not allowed from your site!\r\n", d);
            STATE(d) = CON_CLOSE;
            return;
         }
         if (restrict) {
            if (restrict_reason == RESTRICT_AUTOBOOT) {
               write_to_output("Sorry, no new players because the mud is rebooting shortly.\r\n", d);
               write_to_output("Please try again in five minutes.\r\n", d);
            } else {
               write_to_output("Sorry, new players can't be created at the moment.\r\n", d);
            }
            sprintf(buf, "Request for new char %s denied from %s (wizlock)",
                  GET_NAME(d->character), d->host);
            mudlog(buf, NRM, LVL_GOD, TRUE);
            STATE(d) = CON_CLOSE;
            return;
         }

         /* This deletes any existing files a NEW character might have from a leftover old
            character of the same name... I hope RSD 10/11/2000 */
         get_pfilename(GET_NAME(d->character), buf, PLR_FILE);
         if (unlink(buf) == 0) {
            sprintf(buf,"SYSERR: Deleted existing player file for NEW ch %s.",
                  GET_NAME(d->character));
            log("%s",buf);
         }
         get_pfilename(GET_NAME(d->character), buf, OBJ_FILE);
         if (unlink(buf) == 0) {
            sprintf(buf,"SYSERR: Deleted existing object file for NEW ch %s.",
                  GET_NAME(d->character));
            log("%s",buf);
         }

#ifdef PRODUCTION
         STATE(d) = CON_NAME_CHECK;
         write_to_output(NAMES_EXPLANATION, d);
         sprintf(buf, "Do you believe \"%s\" is acceptable by these standards? (Y/N) ",
               GET_NAME(d->character));
         write_to_output(buf, d);
         break;
#else
         sprintf(buf, "\r\nGive me a password for %s: ", GET_NAME(d->character));
         write_to_output(buf, d);
         echo_off(d);
         STATE(d) = CON_NEWPASSWD;
#endif

         break;
      case YESNO_NO:
         write_to_output("Okay, what IS it, then? ", d);
         clear_player_name(d->character);
         STATE(d) = CON_GET_NAME;
         break;
      default:
         write_to_output("Please answer yes or no: ", d);
      }
      break;
  case CON_NEW_NAME:
    if(!*arg) {
      write_to_output("Name: ",d);
      return;
    }
    if ((_parse_name(arg, tmp_name)) || strlen(tmp_name) < 2 ||
          strlen(tmp_name) > MAX_NAME_LENGTH ||
          fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
        write_to_output("c> Invalid name, please try another.\r\n"
                  "Name: ", d);
      return;
    }
    if ((player_i = load_player(tmp_name, d->character)) > -1) {
      write_to_output("That name is already taken!\r\n", d);
      write_to_output("Name: ", d);
      return;
    }
    if (!Valid_Name(arg))
    {
      write_to_output("d> Invalid name, please try another.\r\n", d);
      write_to_output("Name: ", d);
      return;
    }
    else
    {
      if (PLR_FLAGGED(d->character, PLR_NEWNAME)) {
         sprintf(buf, "Renaming player %s to %s!", GET_NAME(d->character), arg);
         log("%s",buf);

         /* send the old name to the invalid list */
         send_to_xnames(GET_NAME(d->character));

         /* Rename the player's files */
         rename_player(d->character, arg);
         set_player_name(d->character, arg);
         save_player_char(d->character);
      } else {
         set_player_name(d->character, arg);
      }

      write_to_output("Now you must wait to be re-approved.\r\n", d);
      if (!PLR_FLAGGED(d->character, PLR_NAPPROVE))
        SET_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);
      event_create(EVENT_NAME_TIMEOUT, name_timeout, d, FALSE, NULL, NAME_TIMEOUT);
      REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);
      write_to_output("Now you must wait for your name to be approved by an immortal.\r\n"
                "If no one is available, you will be granted entry in a VERY short time.\r\n", d);
      broadcast_name(GET_NAME(d->character));
      STATE(d) = CON_NAME_WAIT_APPROVAL;
    }
    break;
  case CON_NAME_WAIT_APPROVAL:
    write_to_output("You must wait to be approved.\r\n", d);
    break;
  case CON_ISPELL_BOOT:
    write_to_output("\r\nWrong password... disconnecting.\r\n", d);
    STATE(d) = CON_CLOSE;
    break;
  case CON_PASSWORD:                /* get pwd for known player      */
    /*
     * To really prevent duping correctly, the player's record should
     * be reloaded from disk at this point (after the password has been
     * typed).  However I'm afraid that trying to load a character over
     * an already loaded character is going to cause some problem down the
     * road that I can't see at the moment.  So to compensate, I'm going to
     * (1) add a 15 or 20-second time limit for entering a password, and (2)
     * re-add the code to cut off duplicates when a player quits.  JE 6 Feb 96
     */

    echo_on(d);    /* turn echo back on */

    if (!*arg)
      close_socket(d);
    else {
      if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
        sprintf(buf, "Bad PW: %s [%s]", GET_NAME(d->character), d->host);
        mudlog(buf, BRF, LVL_GOD, TRUE);
        GET_BAD_PWS(d->character)++;
        save_player_char(d->character);
        if (++(d->bad_pws) >= max_bad_pws) {        /* 3 strikes and you're out. */
          write_to_output("Wrong password... disconnecting.\r\n", d);
          STATE(d) = CON_CLOSE;
        } else {
          write_to_output("Wrong password.\r\nPassword: ", d);
          echo_off(d);
        }
        return;
      }
      load_result = GET_BAD_PWS(d->character);
      GET_BAD_PWS(d->character) = 0;

      if (isbanned(d->host) == BAN_SELECT &&
          !PLR_FLAGGED(d->character, PLR_SITEOK)) {
        write_to_output("Sorry, this char has not been cleared for login from your site!\r\n", d);
        STATE(d) = CON_CLOSE;
        sprintf(buf, "Connection attempt for %s denied from %s",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        return;
      }
      if (GET_LEVEL(d->character) < restrict) {
         if (restrict_reason == RESTRICT_AUTOBOOT) {
            write_to_output("The game is restricted due to an imminent reboot.\r\n", d);
            write_to_output("Please try again in 2-3 minutes.\r\n", d);
         } else {
            write_to_output("The game is temporarily restricted.  Please Try again later.\r\n", d);
         }
        STATE(d) = CON_CLOSE;
        sprintf(buf, "Request for login denied for %s [%s] (wizlock)",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        return;
      }
      /* check and make sure no other copies of this player are logged in */
      if (perform_dupe_check(d))
        return;

      if (PLR_FLAGGED(d->character, PLR_NEWNAME)) {
        write_to_output("Your name has been deemed unacceptable.  Please choose a new one.\r\n", d);
        write_to_output("Name: ",d);
        STATE(d) = CON_NEW_NAME;
        return;
      }

      if (GET_LEVEL(d->character) >= LVL_IMMORT)
        write_to_output(get_text(TEXT_IMOTD), d);
      else
        write_to_output(get_text(TEXT_MOTD), d);

      if (GET_CLAN(d->character) && GET_CLAN(d->character)->motd)
        dprintf(d, "\r\n%s%s news:\r\n%s",
                GET_CLAN(d->character)->name, ANRM,
                GET_CLAN(d->character)->motd);

      sprintf(buf, "%s [%s] has connected.", GET_NAME(d->character), d->host);
      mudlog(buf, BRF, MAX(LVL_IMMORT,
               MIN(GET_LEVEL(d->character),
               MAX(GET_AUTOINVIS(d->character), GET_INVIS_LEV(d->character)))),
            TRUE);
      if (load_result) {
        sprintf(buf, "\r\n\r\n\007\007\007"
                "%s%d LOGIN FAILURE%s SINCE LAST SUCCESSFUL LOGIN.%s\r\n",
                CLRLV(d->character, FRED, C_SPR), load_result,
                (load_result > 1) ? "S" : "", CLRLV(d->character, ANRM, C_SPR));
        write_to_output(buf, d);
        GET_BAD_PWS(d->character) = 0;
      }
      write_to_output("\r\n\n*** PRESS RETURN: ", d);
      STATE(d) = CON_RMOTD;
    }
    break;

  case CON_NEWPASSWD:
  case CON_CHPWD_GETNEW:
    if (!*arg || strlen(arg) > MAX_PWD_LENGTH || strlen(arg) < 3 ||
        !str_cmp(arg, GET_NAME(d->character))) {
      write_to_output("\r\nIllegal password.\r\n", d);
      write_to_output("Password: ", d);
      return;
    }
    strncpy(GET_PASSWD(d->character), CRYPT(arg, GET_NAME(d->character)), MAX_PWD_LENGTH);
    *(GET_PASSWD(d->character) + MAX_PWD_LENGTH) = '\0';

    write_to_output("\r\nPlease retype password: ", d);
    if (STATE(d) == CON_NEWPASSWD)
      STATE(d) = CON_CNFPASSWD;
    else
      STATE(d) = CON_CHPWD_VRFY;

    break;

  case CON_CNFPASSWD:
  case CON_CHPWD_VRFY:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character),
                MAX_PWD_LENGTH)) {
      write_to_output("\r\nPasswords don't match... start over.\r\n", d);
      write_to_output("Password: ", d);
      if (STATE(d) == CON_CNFPASSWD)
        STATE(d) = CON_NEWPASSWD;
      else
        STATE(d) = CON_CHPWD_GETNEW;
      return;
    }
    echo_on(d);

    if (STATE(d) == CON_CNFPASSWD) {
      write_to_output("\r\nWhat is your sex (M/F)? ", d);
      STATE(d) = CON_QSEX;
    } else {
      save_player_char(d->character);
      echo_on(d);
      write_to_output("\r\nDone.\r\n", d);
      write_to_output(MENU, d);
      STATE(d) = CON_MENU;
    }

    break;

  case CON_QSEX:                /* query sex of new user         */
    switch (*arg) {
    case 'm':
    case 'M':
      d->character->player.sex = SEX_MALE;
      break;
    case 'f':
    case 'F':
      d->character->player.sex = SEX_FEMALE;
      break;
    default:
      write_to_output("\r\nThat is not a sex!\r\n"
                "What IS your sex? (M/F) ", d);
      return;
      break;
    }
    if (races_allowed) {
      send_race_menu(d);
      write_to_output("\r\nRace: ", d);
      STATE(d) = CON_QRACE;
      break;
    } else {
      GET_RACE(d->character) = RACE_HUMAN;
    STATE(d) = CON_QCLASS;
    display_classes(d,1);
    break;
    }
  case CON_QGOODRACE:
    /* This state is no longer valid. Here's some code to GTFO. */
    GET_RACE(d->character) = RACE_HUMAN;
    STATE(d) = CON_QCLASS;
    display_classes(d, 1);
    break;
  case CON_QRACE:
    load_result = interpret_race_selection(*arg);
    sprintf(buf, " Argument: %d, Result: %d", *arg, load_result);
    log("%s",buf);
    if (load_result == RACE_UNDEFINED) {
      write_to_output("\r\n&3Please choose by entering the letter next to the race of your choice.&0\r\n", d);
      send_race_menu(d);
      write_to_output("\r\nRace: ", d);
      return;
    } else
      GET_RACE(d->character) = load_result;
    STATE(d) = CON_QCLASS;
    display_classes(d,1);
    break;
  case CON_NAME_CHECK:  /* extended cases for arg with the or's RSD */
    switch (yesno_result(arg)) {
       case YESNO_YES:
         sprintf(buf, "\r\nGive me a password for %s: ", GET_NAME(d->character));
         write_to_output(buf, d);
         echo_off(d);
         STATE(d) = CON_NEWPASSWD;
         break;
      default:
         tmp_name[0] = '\0';
         write_to_output("\r\nPlease enter a different name: ", d);
         clear_player_name(d->character);
         STATE(d) = CON_GET_NAME;
         break;
    }
    break;
  case CON_QCLASS:
    /*
      load_result = parse_class(NULL, d->character, *arg);
      if (load_result == CLASS_UNDEFINED) {
      write_to_output("\r\nInvalid selection.\r\nClass: ", d);
      return;
      } else
      GET_CLASS(d->character) = load_result;
    */
    switch (*arg) {
    case 'w':
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_WARRIOR])
        load_result = CLASS_WARRIOR;
      else {
        write_to_output("\r\nInvalid selection.\r\nClass: ", d);
        return;
      }
      break;
    case 'c':
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_CLERIC])
        load_result = CLASS_CLERIC;
      else {
        write_to_output("\r\nInvalid selection.\r\nClass: ", d);
        return;
      }
      break;
    case 's':
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_SORCERER])
        load_result = CLASS_SORCERER;
      else {
        write_to_output("\r\nInvalid selection.\r\nClass: ", d);
        return;
      }
      break;
    case 'r':
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_ROGUE])
        load_result = CLASS_ROGUE;
      else {
        write_to_output("\r\nInvalid selection.\r\nClass: ", d);
        return;
      }
      break;
 /*   case 'h':
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_SHAMAN])
        load_result = CLASS_SHAMAN;
      else {
        write_to_output("\r\nInvalid selection.\r\nClass: ", d);
        return;
      }
      break; */
/*    case '?':
      sprintf(buf2, "Class Help Menu\r\n-=-=-=-=-=-=-=-\r\n");
      for(i=0;i<NUM_CLASSES;i++)
        sprintf(buf2, "%s%s\r\n", buf2, class_display[i]);
      sprintf(buf2, "%s0) Back to Class Selection\r\n\r\nSelection: ",buf2);
      page_string(d, buf2);
      STATE(d) = CON_CLASSHELP;
      return; */
    default:
      write_to_output("\r\nInvalid selection.\r\nClass: ", d);
      return;

    }
    GET_CLASS(d->character) = load_result;

    /* Hometown selection disabled. Here is the code for when you
     * DON'T ask about a hometown: */

    GET_HOMEROOM(d->character) = classes[(int)GET_CLASS(d->character)].homeroom;

    write_to_output("\r\nPlease press ENTER to roll your attributes: ", d);
    STATE(d) = CON_QROLLSTATS;

    /* This is the place we'd ask about hometown selection. */
    /* (code to display choices) */
    /* STATE(d) = CON_QHOMETOWN; */
    break;

  case CON_CLASSHELP:
    /* This state is not currently entered.  It would be useful.  This
     * would be a nice place to describe the classes that are being offered
     * for starting players. */

    /* Here is some code to gracefully exit this state if it gets entered
     * by mistake. */
    display_classes(d, 1);
    STATE(d) = CON_QCLASS;
    break;

  case CON_QHOMETOWN:
    /* Parse player's hometown choice */
    /* Attempt to set the player's hometown */

    /* The next step could be deity selection. */
    /* (display deity choices) */
    /* STATE(d) = CON_QDIETY; */

    /* Here is some code to gracefully exit this state if it gets entered
     * by mistake. */
    write_to_output("\r\nPlease press ENTER to roll your attributes: ", d);
    STATE(d) = CON_QROLLSTATS;
    break;

  case CON_QROLLSTATS:

    switch (*arg) {
    case 'y':
    case 'Y':
      if ((GET_NATURAL_STR(d->character)) > 0)
        break;
    case 'n':
    case 'N':
    default:


      roll_natural_abils(d->character);
      new_rollor_display(d->character, roll_table);
      sprintf(buf, "\r\n\r        Con:  %s                Wis:  %s\r\n"
              "        Str:  %s                Intel:%s\r\n"
              "        Dex:  %s                Char: %s\r\r\r\r\n",
              rolls_abils_result[roll_table[4]],  rolls_abils_result[roll_table[2]],
              rolls_abils_result[roll_table[0]],
              rolls_abils_result[roll_table[1]], rolls_abils_result[roll_table[3]],
              rolls_abils_result[roll_table[5]]);
      write_to_output(buf, d);
      write_to_output("\r\n\nYou may keep these stats if you wish (&0&6Enter y&0),\r\nor if you wish"
                " you may try for better stats (&0&6Enter n&0)(y/n):", d);
      return;

    }


    write_to_output("\r\r\n\n&0&7&bYou have three bonus's to use choose the stat carefully:&0\r\n", d);
    write_to_output(stats_display, d);
    write_to_output("\r\n&0&7&bPlease enter your first bonus selection:&0\r\n",d);
    STATE(d) = CON_QBONUS1;
    break;
  case CON_QBONUS1:
    load_result = bonus_stat(d->character, *arg);
    if (!load_result) {
      write_to_output("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
      return;
    }
    write_to_output(stats_display, d);
    write_to_output("\r\n&0&7&bPlease enter your second bonus selection:&0\r\n",d);


    STATE(d) = CON_QBONUS2;
    break;
  case CON_QBONUS2:
    load_result = bonus_stat(d->character, *arg);
    if (!load_result) {
      write_to_output("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
      return;
    }
    write_to_output(stats_display, d);
    write_to_output("\r\n&0&7&bPlease enter your third bonus selection:&0\r\n",d);


    STATE(d) = CON_QBONUS3;
    break;
  case CON_QBONUS3:
    load_result = bonus_stat(d->character, *arg);

    if (!load_result) {
      write_to_output("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
      return;
    }

    d->character->actual_abils = d->character->natural_abils;
    scale_attribs(d->character);

    write_to_output("&0&4\r\n\r\nRolling for this character is complete!!\r\n"
              "&0&4&bDo you wish to keep this character (Y/n)?\r\n"
         "(Answering 'n' will take you back to gender selection.)&0  ", d);
    STATE(d) = CON_QCANCHAR;
    break;
  case CON_QCANCHAR:
    switch (yesno_result(arg)) {
       case YESNO_NO:
          /* They didn't want to keep this character */
         GET_NATURAL_STR(d->character) = 0;
         for (i = 0; i < 6; i++) {
            GET_ROLL(d->character, i) = 0;
         }
         write_to_output("\r\nWhat is your sex (M/F)? ", d);
         STATE(d) = CON_QSEX;
         break;
      case YESNO_OTHER:
         write_to_output("\r\nPlease answer yes or no.\r\n", d);
         write_to_output(
                    "&0&4&bDo you wish to keep this character (Y/n)?\r\n"
               "(Answering 'n' will take you back to gender selection.)&0  ", d);
         break;
      default:
         if (approve_names && (top_of_p_table + 1) && napprove_pause) {
            if (!PLR_FLAGGED(d->character, PLR_NAPPROVE)) {
               SET_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);
            }
            event_create(EVENT_NAME_TIMEOUT, name_timeout, d, FALSE, NULL, NAME_TIMEOUT);
            REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);
            write_to_output("\r\nNow you must wait for your name to be approved by an immortal.\r\n"
                   "If no one is available, you will be auto approved in a short time.\r\n", d);
            broadcast_name(GET_NAME(d->character));
            STATE(d) = CON_NAME_WAIT_APPROVAL;
            break;
         } else {
            if (approve_names && !PLR_FLAGGED(d->character, PLR_NAPPROVE)) {
               SET_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);
            }
            if (GET_PFILEPOS(d->character) < 0) {
               GET_PFILEPOS(d->character) = create_player_index_entry(GET_NAME(d->character));
            }
            init_player(d->character);
            save_player_char(d->character);
            sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
            mudlog(buf, NRM, LVL_IMMORT, TRUE);
            write_to_output("\r\n*** PRESS RETURN: ", d);
            STATE(d) = CON_RMOTD;
            break;
         }
    }
    break;
  case CON_RMOTD:                /* read CR after printing motd   */
    write_to_output(MENU, d);
    STATE(d) = CON_MENU;
    break;

  case CON_MENU:                /* get selection from main menu  */
    switch (*arg) {
    case '0':
      save_player_char(d->character);
      close_socket(d);
      break;
    case '1':

      load_result = enter_player_game(d);
      send_to_char(WELC_MESSG, d->character);
      act("$n has entered the game.", TRUE, d->character, 0, 0, TO_ROOM);

      STATE(d) = CON_PLAYING;
      if (!GET_LEVEL(d->character)) {
        start_player(d->character);
        send_to_char(START_MESSG, d->character);
        give_newbie_eq(d->character);
      }
      look_at_room(d->character, FALSE);
      if (has_mail(GET_IDNUM(d->character)))
        send_to_char("You have mail waiting.\r\n", d->character);
      if (load_result == 2) {        /* rented items lost */
        send_to_char("\r\n\007You could not afford your rent!\r\n"
                     "Your possesions have been donated to the Salvation Army!\r\n",
                     d->character);
      }
      personal_reboot_warning(d->character);
      d->prompt_mode = 1;
      break;

    case '2':
      page_string_desc(d, get_text(TEXT_BACKGROUND));
      STATE(d) = CON_RMOTD;
      break;

    case '3':
      write_to_output("\r\nEnter your old password: ", d);
      echo_off(d);
      STATE(d) = CON_CHPWD_GETOLD;
      break;
/*    case '5':
      write_to_output("\r\n This has been temporarily removed.\r\n", d);
      write_to_output(MENU, d);
      STATE(d) = CON_MENU; */
      /*      write_to_output("\r\nEnter your password for verification: ", d);
              echo_off(d);
              STATE(d) = CON_DELCNF1; */
/*      break; */
    default:
      write_to_output("\r\nUnknown menu option.\r\n", d);
      write_to_output(MENU, d);
      break;
    }

    break;

  case CON_CHPWD_GETOLD:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      echo_on(d);
      write_to_output("\r\nIncorrect password.\r\n", d);
      write_to_output(MENU, d);
      STATE(d) = CON_MENU;
      return;
    } else {
      write_to_output("\r\nEnter a new password: ", d);
      STATE(d) = CON_CHPWD_GETNEW;
      return;
    }
    break;

  case CON_DELCNF1:
    echo_on(d);
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      write_to_output("\r\nIncorrect password.\r\n", d);
      write_to_output(MENU, d);
      STATE(d) = CON_MENU;
    } else {
      write_to_output("\r\nYOU ARE ABOUT TO DELETE THIS CHARACTER PERMANENTLY.\r\n"
                "ARE YOU ABSOLUTELY SURE?\r\n\r\n"
                "Please type \"yes\" to confirm: ", d);
      STATE(d) = CON_DELCNF2;
    }
    break;

  case CON_DELCNF2:
    if (!str_cmp(arg, "yes")) {
      if (PLR_FLAGGED(d->character, PLR_FROZEN)) {
        write_to_output("You try to kill yourself, but the ice stops you.\r\n", d);
        write_to_output("Character not deleted.\r\n\r\n", d);
        STATE(d) = CON_CLOSE;
        return;
      }
      if (GET_CLAN_MEMBERSHIP(d->character))
        revoke_clan_membership(GET_CLAN_MEMBERSHIP(d->character));

      if ((player_i = get_ptable_by_name(GET_NAME(d->character))) >= 0) {
        SET_BIT(player_table[player_i].flags, PINDEX_DELETED);
        delete_player(player_i);
      }
      sprintf(buf, "Character '%s' deleted!\r\n"
              "Goodbye.\r\n", GET_NAME(d->character));
      write_to_output(buf, d);
      sprintf(buf, "%s (lev %d) has self-deleted.", GET_NAME(d->character),
              GET_LEVEL(d->character));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      STATE(d) = CON_CLOSE;
      return;
    } else {
      write_to_output("\r\nCharacter not deleted.\r\n", d);
      write_to_output(MENU, d);
      STATE(d) = CON_MENU;
    }
    break;

  case CON_CLOSE:
    close_socket(d);
    break;

  default:
    log("SYSERR: Nanny: illegal state of con'ness; closing connection");
    close_socket(d);
    break;
  }
}

/* now hardcoded 25% loss every time you die */
long exp_death_loss(struct char_data * ch, int level) {
  long total;

  total = (long) exp_next_level(level, GET_CLASS(ch)) -
     exp_next_level((level - 1), GET_CLASS(ch));

  return (.25 * (float)total); /* percent you lose every time you die */
}

long max_exp_gain(struct char_data *ch) {
  long current, total;
  total = exp_next_level(GET_LEVEL(ch), GET_CLASS(ch)) -
     exp_next_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));

  current = (long)(0.2 * (float)total);
  /*sprintf(buf, "max exp gain is %ld, but total %ld, percent 20\r\n", current, total);
    send_to_char(buf, ch);
  */
  return current;
}


void new_rollor_display(struct char_data *ch, int word[6])
{
  int statts[6];
  int j;


  statts[0] = GET_NATURAL_STR(ch);
  statts[1] = GET_NATURAL_INT(ch);
  statts[2] = GET_NATURAL_WIS(ch);
  statts[3] = GET_NATURAL_DEX(ch);
  statts[4] = GET_NATURAL_CON(ch);
  statts[5] = GET_NATURAL_CHA(ch);

  for (j = 0; j <= 5; j++)        {
    if (statts[j] > 90)
      word[j] = 0;
    else if (statts[j] > 80)
      word[j] = 1;
    else if (statts[j] > 62)
      word[j] = 2;
    else if (statts[j] > 52)
      word[j] = 3;
    else
      word[j] = 4;
  }

}

/* this addes a number from 2-6 to the stat but doesn't exceed 100 */
int bonus_stat(struct char_data *ch, char arg)
{
  int b;
  int a;
  arg = LOWER(arg);
  switch(arg)
    {
    case 'w':
      b = number(2, 6);
      GET_NATURAL_WIS(ch) = MIN(100, (GET_NATURAL_WIS(ch) +b));
      a = TRUE;
      break;
    case 'i':
      b = number(2, 6);
      GET_NATURAL_INT(ch) = MIN(100, (GET_NATURAL_INT(ch) +b));
      a = TRUE;
      break;
    case 'm':
      b = number(2, 6);
      GET_NATURAL_CHA(ch) = MIN(100, (GET_NATURAL_CHA(ch) +b));
      a = TRUE;
      break;
    case 'c':
      b = number(2, 6);
      GET_NATURAL_CON(ch) = MIN(100, (GET_NATURAL_CON(ch) +b));
      a = TRUE;
      break;
    case 'd':
      b = number(2, 6);
      GET_NATURAL_DEX(ch) = MIN(100, (GET_NATURAL_DEX(ch) +b));
      a = TRUE;
      break;
    case 's':
      b = number(2, 6);
      GET_NATURAL_STR(ch) = MIN(100, (GET_NATURAL_STR(ch) +b));
      a = TRUE;
      break;
    default:
      a = FALSE;
      break;
    }
  return a;
}


EVENTFUNC(name_timeout)
{
   struct descriptor_data *d = (struct descriptor_data *) event_obj;

   if (STATE(d) != CON_NAME_WAIT_APPROVAL)
     return EVENT_FINISHED;

   if (d->character->desc == NULL)
     return EVENT_FINISHED;

   if (GET_PFILEPOS(d->character) < 0)
     GET_PFILEPOS(d->character) = create_player_index_entry(GET_NAME(d->character));

   if (!PLR_FLAGGED(d->character, PLR_NEWNAME))
     init_player(d->character);

   save_player_char(d->character);

   if (!PLR_FLAGGED(d->character, PLR_NAPPROVE))
     SET_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);

   if (!PLR_FLAGGED(d->character, PLR_NEWNAME)) {
     /* This IF was placed here so players whose names had been
        FREAKING DECLINED wouldn't sneak online anyway if they
        sat at the prompt not choosing a new name. - RSD 11/11/2000
      */
     write_to_output("You have been auto-approved.\r\n", d);
     write_to_output(get_text(TEXT_MOTD), d);
     write_to_output("\r\n\n*** PRESS RETURN: ", d);
     if (PLR_FLAGGED(d->character, PLR_NEWNAME)) {
       sprintf(buf, "%s [%s] has connected with a new name.", GET_NAME(d->character), d->host);
       mudlog(buf, NRM, LVL_IMMORT, TRUE);
       REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);
     } else {
       sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
       mudlog(buf, NRM, LVL_IMMORT, TRUE);
     }
     STATE(d) = CON_RMOTD;

   }
   if (PLR_FLAGGED(d->character, PLR_NEWNAME))
     REMOVE_FLAG(PLR_FLAGS(d->character), PLR_NEWNAME);

   return EVENT_FINISHED;

}


void sort_commands(void)
{
  int a, b, tmp;

  /* global variable */
  num_of_cmds = 0;

  /*
   * first, count commands.  num_of_cmds includes the 'reserved' 
   * command, which is not copied to the cmd_sort_info array
   */
  while (*cmd_info[num_of_cmds].command != '\n')
    ++num_of_cmds;

  /* create data array */
  CREATE(cmd_sort_info, struct sort_struct, num_of_cmds);

  /* initialize it */
  for (a = 1; a < num_of_cmds; a++) {
    cmd_sort_info[a].sort_pos = a;
    cmd_sort_info[a].is_social = (cmd_info[a].command_pointer == do_action);
  }

  /* the infernal special case */
  cmd_sort_info[find_command("insult")].is_social = TRUE;
  cmd_sort_info[find_command("roar")].is_social = TRUE;
  cmd_sort_info[find_command("z001#@@#")].is_social = FALSE;


  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < num_of_cmds - 1; a++)
    for (b = a + 1; b < num_of_cmds; b++)
      if (strcmp(cmd_info[cmd_sort_info[a].sort_pos].command,
                 cmd_info[cmd_sort_info[b].sort_pos].command) > 0) {
        tmp = cmd_sort_info[a].sort_pos;
        cmd_sort_info[a].sort_pos = cmd_sort_info[b].sort_pos;
        cmd_sort_info[b].sort_pos = tmp;
      }
}


/***************************************************************************
 * $Log: interpreter.c,v $
 * Revision 1.328  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.327  2009/07/16 19:15:54  myc
 * Moved command stuff from grant.c to commands.c
 *
 * Revision 1.326  2009/07/14 01:22:48  myc
 * If a clan has a special motd, give some warning on the motd screen.
 *
 * Revision 1.325  2009/06/09 21:50:21  myc
 * Adding a couple of hacks to enter_player_game to make sure
 * clans and cooldowns are always handled correctly.
 *
 * Revision 1.324  2009/06/09 05:41:36  myc
 * Adding a hook for the clan motd, and adjusting delete player
 * to work with the new clan interface.
 *
 * Revision 1.323  2009/03/20 23:02:59  myc
 * Move text file handling routines into text.c
 *
 * Revision 1.322  2009/03/16 19:17:52  jps
 * Change macro GET_HOME to GET_HOMEROOM
 *
 * Revision 1.321  2009/03/09 02:22:32  myc
 * Added edit command.  Modified is_number to allow leading spaces.
 *
 * Revision 1.320  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.319  2009/03/07 11:12:05  jps
 * Separated the read command from the look command.
 *
 * Revision 1.318  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.317  2009/02/21 03:30:16  myc
 * Adding hook for boardadmin command.
 *
 * Revision 1.316  2009/02/11 17:03:39  myc
 * Adding delimited_arg_case, which is exactly like delimited_arg,
 * but it doesn't make everything lower case.  (There's got to be
 * a better way to do this.)
 *
 * Revision 1.315  2009/01/18 06:58:53  myc
 * Adding "emote's" command so you can emote stuff like
 * "Laoris's arms are tired."
 *
 * Revision 1.314  2008/12/03 03:13:43  myc
 * Don't allow shapechanging during battle; it leaves the original character
 * in the fighting stance, which wrecks havoc later.
 *
 * Revision 1.313  2008/09/28 19:06:49  jps
 * Change SCMD_NOTES to SCMD_NOTE.
 *
 * Revision 1.312  2008/09/25 04:48:10  jps
 * Add coredump command for lvl 104+
 *
 * Revision 1.311  2008/09/21 21:51:18  jps
 * Stop trying to keep track of who's attacking who when there's a shapechange,
 * since do_shapechange handles that internally now.  Also, you can shapechange
 * during a battle now.
 *
 * Revision 1.310  2008/09/21 20:40:40  jps
 * Keep a list of attackers with each character, so that at the proper times -
 * such as char_from_room - they can be stopped from battling.
 *
 * Revision 1.309  2008/09/21 04:54:23  myc
 * Added ungrant command.
 *
 * Revision 1.308  2008/09/20 06:05:06  jps
 * Add macros POSSESSED and POSSESSOR.
 *
 * Revision 1.307  2008/09/14 02:08:01  jps
 * Use standardized area attack targetting
 *
 * Revision 1.306  2008/09/08 05:24:50  jps
 * Put autosave as the "quit reason" when autosaving. This is a temporary fix
 * that should stop people from losing keys when autosave code thinks their
 * quit reason is something else, like renting.
 *
 * Revision 1.305  2008/09/07 20:05:27  jps
 * Renamed exp_to_level to exp_next_level to make it clearer what it means.
 *
 * Revision 1.304  2008/09/07 07:21:56  jps
 * Raised pscan to level 104.
 *
 * Revision 1.303  2008/09/01 22:15:59  jps
 * Saving and reporting players' game-leaving reasons and locations.
 *
 * Revision 1.302  2008/08/31 21:04:46  myc
 * Abort command gives a useful message when not casting.
 *
 * Revision 1.301  2008/08/29 19:18:05  myc
 * Fixed abilities so that no information is lost; the caps occur
 * only when the viewed stats are accessed.
 *
 * Revision 1.300  2008/08/29 04:16:26  myc
 * Moved all ACMD prototypes for commands in act.informative.c
 * to the act.h file.
 *
 * Revision 1.299  2008/08/29 03:02:40  myc
 * Misspelling of STANC_.
 *
 * Revision 1.298  2008/08/28 23:48:29  rbr
 * Added the do_abandon command to the command list.
 *
 * Revision 1.297  2008/08/24 18:24:20  myc
 * Change iptables to level 104.
 *
 * Revision 1.296  2008/08/24 02:34:26  myc
 * Add hook for ksearch command.
 *
 * Revision 1.295  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.294  2008/08/16 08:25:13  jps
 * Took desc and delete out of the pre-game menu.
 * Added a desc command so players can edit their descriptions in game.
 *
 * Revision 1.293  2008/08/15 05:50:54  jps
 * Moved pray command above prompt.
 *
 * Revision 1.292  2008/08/15 03:59:08  jps
 * Added pprintf for paging, and changed page_string to take a character.
 *
 * Revision 1.291  2008/08/14 23:10:35  myc
 * Made one of the arguments to search_block const.  Hardcoded the
 * ANSI string in there.
 *
 * Revision 1.290  2008/08/14 09:45:22  jps
 * Replaced the pager.
 *
 * Revision 1.289  2008/08/10 02:58:40  jps
 * Added infodump command for outputting game data to text files.
 *
 * Revision 1.288  2008/07/27 05:13:23  jps
 * Changed name of save_player to save_player_char, since it only saves the
 * character, not other stuff like objects and quests.
 *
 * Revision 1.287  2008/07/27 01:33:51  jps
 * Removed unused ACMD do_rent.
 *
 * Revision 1.286  2008/07/26 21:33:55  jps
 * Removed objfix command and added objupdate command.
 *
 * Revision 1.285  2008/07/22 07:25:26  myc
 * Added iedit (unique item editor).
 *
 * Revision 1.284  2008/07/15 19:22:25  myc
 * Don't let gods change aliases of people of a higher level.
 *
 * Revision 1.283  2008/07/15 19:14:33  myc
 * Modified do_alias to allow gods to see/modify players' aliases.
 *
 * Revision 1.282  2008/07/15 18:53:39  myc
 * Added an array of strings for command flags.
 *
 * Revision 1.281  2008/07/15 17:49:24  myc
 * Whether you can use a command depends not only on level now, but
 * also on command grants.  Added the grant, gedit, and revoke commands.
 * Functionalized the levenshtein similar commands code.  Added
 * parse_command, which is the same as find_command, but it allows
 * abbreviations.
 * Added a hook for gedit to the nanny.
 *
 * Revision 1.280  2008/07/13 16:48:09  jps
 * Make the MESMERIZED effect ineffective against immortals.
 *
 * Revision 1.279  2008/06/21 08:53:09  myc
 * Set the player's last logon time in enter_player_game.
 *
 * Revision 1.278  2008/06/09 23:00:13  myc
 * Got rid of the disembark command..
 *
 * Revision 1.277  2008/06/05 02:07:43  myc
 * Rewrote rent saving to use ascii object files.  Moved quest loading
 * into enter_player_game.
 *
 * Revision 1.276  2008/05/19 06:53:04  jps
 * Got rid of fup and fdown commands.
 *
 * Revision 1.275  2008/05/19 06:17:07  jps
 * You can't do things when mesmerized.
 *
 * Revision 1.274  2008/05/18 20:16:11  jps
 * Created fight.h and set dependents.
 *
 * Revision 1.273  2008/05/18 03:24:14  jps
 * Added inctime/hour wiz command to advance time 1 hour.
 *
 * Revision 1.272  2008/05/09 22:04:33  jps
 * Add delimited_arg_all(), which is like delimited_arg() except that
 * when there's no delimiter, it will return everything as the arg
 * (not just the first word).
 *
 * Revision 1.271  2008/04/20 04:11:08  jps
 * Removing unused ACMD
 *
 * Revision 1.270  2008/04/07 04:32:11  jps
 * Use CMD_NOFIGHT bit for commands that shouldn't be available in a fight.
 *
 * Revision 1.269  2008/04/07 03:02:54  jps
 * Changed the POS/STANCE system so that POS reflects the position
 * of your body, while STANCE describes your condition or activity.
 *
 * Revision 1.268  2008/04/05 16:49:38  myc
 * Adding worship social back in.
 *
 * Revision 1.267  2008/04/05 16:38:56  jps
 * Rename the function that handles the "reload" command from do_reboot
 * to do_reload.
 *
 * Revision 1.266  2008/04/05 06:28:50  myc
 * Fixed that crash bug: was a buffer overflow because of a tiny local
 * buffer.
 *
 * Revision 1.265  2008/04/05 05:05:42  myc
 * Removed SEND_TO_Q macro, so call write_to_output directly.
 *
 * Revision 1.264  2008/04/04 06:12:52  myc
 * Removed justice and dieites/worship code.
 *
 * Revision 1.263  2008/04/04 05:13:46  myc
 * Removing maputil code.
 *
 * Revision 1.262  2008/04/03 17:36:42  jps
 * Stopped using the PLR_INVSTART flag.  Instead, using the autoinvis toggle.
 *
 * Revision 1.261  2008/04/03 02:02:05  myc
 * Upgraded ansi color handling code.
 *
 * Revision 1.260  2008/04/02 03:24:44  myc
 * Rewrote group code and removed major group code.
 *
 * Revision 1.259  2008/03/30 17:30:38  jps
 * Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
 * from pfiles.c now include pfiles.h and depend on it in the makefile.
 *
 * Revision 1.258  2008/03/30 16:32:18  jps
 * Don't need to set player race align when entering game.
 *
 * Revision 1.257  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.256  2008/03/27 22:57:29  jps
 * Added objfix command.
 *
 * Revision 1.255  2008/03/22 03:22:38  myc
 * All invocations of the string editor now go through string_write()
 * instead of messing with the descriptor variables itself.  Also added
 * a toggle, LineNums, to decide whether to do /l or /n when entering
 * the string editor.
 *
 * Revision 1.254  2008/03/21 15:01:17  myc
 * Removed languages.
 *
 * Revision 1.253  2008/03/16 23:30:14  jps
 * Move 'stay' down to its alphabetical position, so that 'sta' resolves
 * to 'stand' like people are accustomed to.
 *
 * Revision 1.252  2008/03/10 18:01:17  myc
 * Made bodyslam and maul subcommands of bash.  Made tantrum a subcommand
 * of hitall.  Made battle howl a subcommand of roar.  Added ground
 * shaker command as stomp.
 *
 * Revision 1.251  2008/03/09 18:15:45  jps
 * Added a movement subcommand of 'stay', which is most useful when
 * misdirecting your movements.
 *
 * Revision 1.250  2008/03/09 08:57:56  jps
 * Also allow 'look' during minor paralysis.
 *
 * Revision 1.249  2008/03/09 08:52:21  jps
 * Fix typos and make sure that the return command is available when paralyzed.
 *
 * Revision 1.248  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.247  2008/03/09 04:01:55  jps
 * Don't apply mob_spec to mobs with MOB2_NOSCRIPT flag.
 *
 * Revision 1.246  2008/03/08 20:18:09  jps
 * Added 'pscan' command so you can see how many of a type of object
 * are saved in player object files.
 *
 * Revision 1.245  2008/03/05 05:21:56  myc
 * Removed char_file_u function declarations.
 *
 * Revision 1.244  2008/03/05 03:03:54  myc
 * Changed alias structures, and updated all alias functions.  Player
 * files are now ascii format so they are loaded differently than before.
 *
 * Revision 1.243  2008/02/24 17:31:13  myc
 * You can now execute certain actions by preceding them with a ~
 * in OLC if the command is marked CMD_OLC (or CMD_ANY).
 *
 * Revision 1.242  2008/02/16 20:31:32  myc
 * Moving command sorting code here from act.informative.c.
 *
 * Revision 1.241  2008/02/13 21:27:31  myc
 * Make it so you don't get the Welcome to Fierymud message twice when
 * logging in.
 *
 * Revision 1.240  2008/02/11 21:04:01  myc
 * Removing a few unused spec-proc command placeholders: home, pull, and
 * push.  Making the stone, appear, and disappear placeholders 'invisible'
 * on the commands and hints list.  Also making hunt and qui invisible.
 *
 * Revision 1.239  2008/02/10 20:30:03  myc
 * Adding notes to the delete_doubledollar function so we actually
 * know what it does.
 *
 * Revision 1.238  2008/02/09 21:07:50  myc
 * Instead of creating a name_timeout_event object for name approval
 * timeouts, we'll just pass the descriptor itself to the event,
 * saving us a tiny bit of memory.
 *
 * Revision 1.237  2008/02/09 18:29:11  myc
 * The event code now handles freeing of event objects.
 *
 * Revision 1.236  2008/02/09 07:05:37  myc
 * Copyover is now renamed to hotboot.
 *
 * Revision 1.235  2008/02/09 06:19:44  jps
 * Add "nohints" toggle for whether you receive command suggestions
 * after entering a typo.
 *
 * Revision 1.234  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.233  2008/02/09 03:06:17  myc
 * Adding the 'copyover' command, which allows you to do a hot-boot
 * without disconnecting anybody.
 *
 * Revision 1.232  2008/02/06 21:53:53  myc
 * Adding exit search as part of the vsearch command suite.
 *
 * Revision 1.231  2008/02/05 04:22:42  myc
 * Removing the listexp, listclass, and listrace commands.  Their
 * functionality is now part of the show command.
 *
 * Revision 1.230  2008/02/05 03:07:26  myc
 * Shortening all the vsearch command function names.  Adding
 * csearch and ssearch.  Moving slist and snum to the vsearch
 * command system.
 *
 * Revision 1.229  2008/02/04 01:48:53  myc
 * Removing the old implementations of znum and zlist.
 *
 * Revision 1.228  2008/02/04 01:46:12  myc
 * Removing the *find aliases for *search.  Too much command spam.
 *
 * Revision 1.227  2008/02/03 08:46:52  myc
 * Don't display socials for the 'did you mean' command list.
 *
 * Revision 1.226  2008/02/02 19:38:20  myc
 * Title command is now available to mortals to switch between
 * 'permanent titles'.  Added a levenshtein distance thingy to
 * the interpreter so if you misspell a command it says,
 * 'Did you mean...' and lists a few suggestions.
 *
 * Revision 1.225  2008/02/02 04:27:55  myc
 * Changing delimited_arg so it doesn't skip fill words.
 *
 * Revision 1.224  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.223  2008/01/27 21:09:12  myc
 * Add berserk command.  Replaced hit() with attack().
 *
 * Revision 1.222  2008/01/27 13:43:50  jps
 * Moved race and species-related data to races.h/races.c and merged species into races.
 *
 * Revision 1.221  2008/01/27 11:15:52  jps
 * Renamed do_newbie to give_newbie_eq.
 *
 * Revision 1.220  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.219  2008/01/23 05:13:26  jps
 * Make "point" into a regular command.
 *
 * Revision 1.218  2008/01/23 04:38:34  jps
 * Use the delay from instant kill to prevent another instant kill for
 * a while. NOT to prevent all commands during the next fight.
 *
 * Revision 1.217  2008/01/22 22:29:25  myc
 * Removed attributes command.
 *
 * Revision 1.216  2008/01/22 05:32:22  myc
 * Fixing a bug in is_integer.
 *
 * Revision 1.215  2008/01/17 01:29:10  myc
 * Replaced is_number with is_integer, is_positive_integer, and
 * is_negative_integer.  is_number is now a macro aliased to
 * is_positive_integer.
 *
 * Revision 1.214  2008/01/11 02:06:50  myc
 * Allow consent while incapacitated.
 *
 * Revision 1.213  2008/01/10 05:39:43  myc
 * The purge command is now 101 on test and 103 on production.
 *
 * Revision 1.212  2008/01/09 13:04:40  jps
 * Removed the "offer" command.
 *
 * Revision 1.211  2008/01/05 21:55:32  jps
 * Remove unused extern.
 *
 * Revision 1.210  2008/01/05 05:38:51  jps
 * Changed name of save_char() to save_player().
 *
 * Revision 1.209  2008/01/04 03:03:48  jps
 * Added msave command, so mobs can save players during triggers.
 *
 * Revision 1.208  2008/01/04 02:31:33  jps
 * The race selection menu is dynamic, so there is only a need for one
 * race-selection state.
 *
 * Revision 1.207  2008/01/04 01:53:26  jps
 * Added races.h file and created global array "races" for much
 * race-related information.
 *
 * Revision 1.206  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.205  2008/01/02 02:10:16  jps
 * Modified the (unused) bit about displaying help for classes.
 *
 * Revision 1.204  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.203  2007/12/24 18:22:36  myc
 * Removing 'bind' and 'unbind' from the command list since they are unused
 * and just screw things up anyway.
 *
 * Revision 1.202  2007/12/20 23:12:50  myc
 * Moved exp_mesg to act.informative.c as exp_message.
 *
 * Revision 1.201  2007/12/19 20:51:52  myc
 * Put "Huh?!?" in a macro.  Added a const modifier to is_number.
 * save_player() no longer requries you to supply a save/load room
 * (which wasn't being used anyway).  Updated code to remove a
 * player from a clan when they self-delete.
 *
 * Revision 1.200  2007/11/23 07:10:41  jps
 * Ok, that was bad.. back to LVL_ADMIN + 1 for iptables.
 *
 * Revision 1.199  2007/11/22 21:30:18  jps
 * Use correct def for level 105 in iptables settings.
 *
 * Revision 1.198  2007/11/21 02:34:43  jps
 * Back to god-only title command - we have better plans...
 *
 * Revision 1.197  2007/11/21 01:29:37  jps
 * Made the title command available to all players.
 *
 * Revision 1.196  2007/11/18 16:51:55  myc
 * Renaming LVL_QUESTMASTER as LVL_GAMEMASTER.
 *
 * Revision 1.195  2007/10/25 20:39:37  myc
 * Added compare command.  Made a number of god and informative commands
 * POS_DEAD.
 *
 * Revision 1.194  2007/10/23 20:21:00  myc
 * Slightly redesigned the master command list, replacing the six boolean
 * variables on each line with a single bitvector.  Also replaced all of
 * the compiler ifdef checks with administration levels defined in
 * structs.h.
 *
 * Revision 1.193  2007/10/17 17:18:04  myc
 * Renamed the search_block and search_block2 functions.
 * searchblock is now case sensitive, and search_block is not.
 *
 * Revision 1.192  2007/10/11 20:14:48  myc
 * Chant command is now a subcommand of do_cast.  Songs command moved
 * to act.informative.c.
 *
 * Revision 1.191  2007/10/02 02:52:27  myc
 * Disengage now works as abort when casting.  Report command now has
 * subcommands for greport and mreport.
 *
 * Revision 1.190  2007/09/28 20:49:35  myc
 * The vnum, mnum, onum, rnum, tnum, mlist, olist, rlist, tlist, slist,
 * vwear, and vitem commands now use the vsearch command suite, which is
 * now also available through the vsearch, vfind, osearch, ofind, msearch,
 * mfind, tsearch, tfind, ssearch, sfind, rsearch, rfind, and vlist
 * commands.
 * Added a delimited_arg() function (actually just renamed one_word) that
 * lets you return multi-word arguments surrounded by a given character,
 * such as a quote.  This is useful for spell casting, for example.
 *
 * Revision 1.189  2007/09/21 08:44:45  jps
 * Added object type "touchstone" and command "touch" so you can set
 * your home room by touching specific objects.
 *
 * Revision 1.188  2007/09/20 21:20:43  myc
 * Hide points and perception are in.  The sneak command no longer exists.
 *
 * Revision 1.187  2007/09/20 20:00:01  jps
 * Make gtell, gsay, and tell not interrupt meditation.
 *
 * Revision 1.186  2007/09/12 22:23:04  myc
 * You can now use the 'walk' and 'go' commands to travel in different
 * directions.
 *
 * Revision 1.185  2007/09/12 19:28:56  myc
 * Allow springleap for POS_RESTING.
 *
 * Revision 1.184  2007/09/11 16:34:24  myc
 * Added claw, electrify, and peck skills.
 * Changed is_abbrev to accept const strings.
 *
 * Revision 1.183  2007/09/07 19:41:27  jps
 * Added "identify" command.
 *
 * Revision 1.182  2007/08/27 21:18:00  myc
 * You can now queue up commands while casting as well as abort midcast.
 * Casting commands such as look and abort are caught and interpreted
 * before the input is normally queued up by the game loop.
 *
 * Revision 1.181  2007/08/26 08:49:36  jps
 * Added commands estat, oestat, and restat, for viewing extra
 * descriptions on objects and rooms.
 *
 * Revision 1.180  2007/08/25 00:10:41  jps
 * Added qstat command.
 *
 * Revision 1.179  2007/08/24 22:49:05  jps
 * Added "snum" and "tnum" commands.
 *
 * Revision 1.178  2007/08/24 22:10:43  jps
 * Add sstat (shop stat) as a subcommand of stat.
 *
 * Revision 1.177  2007/08/24 17:01:36  myc
 * Adding ostat and mstat commands as shorthand for vstat, rstat for stat
 * room, and mnum and onum for vnum.  Also adding rnum and znum with new
 * functionality.
 *
 * Revision 1.176  2007/08/24 10:24:16  jps
 * Added zlist command.
 *
 * Revision 1.175  2007/08/22 18:01:09  jps
 * Warn of an imminent reboot immediately when logging in.
 * Use some global constants to determine who can use the
 * autoboot and shutdown commands.
 *
 * Revision 1.174  2007/08/16 19:53:38  myc
 * Adding stow/palm commands as secondary functionality to conceal skill.
 *
 * Revision 1.173  2007/08/15 20:47:41  myc
 * Conceal and shadow skills can be used while hidden now.
 *
 * Revision 1.172  2007/08/14 22:43:07  myc
 * Adding corner, conceal, stealth, and shadow skills.  Also making
 * stat usable while meditating.
 *
 * Revision 1.171  2007/08/14 20:13:22  jps
 * Added command "autoboot" to manage the mud's automatic rebooting.
 *
 * Revision 1.170  2007/08/05 20:21:51  myc
 * Added retreat and group retreat skills.
 *
 * Revision 1.169  2007/08/04 20:07:54  jps
 * Added socials: flanic, glomp, mumble, twitch, beckon, glower.
 *
 * Revision 1.168  2007/08/03 03:51:44  myc
 * You can now abort spells mid-cast.
 *
 * Revision 1.167  2007/07/31 23:03:11  jps
 * Add command "zstat" to stat a zone.
 *
 * Revision 1.166  2007/07/19 15:32:01  jps
 * Add "extinguish" as a subcommand of light.
 *
 * Revision 1.165  2007/07/18 23:10:31  jps
 * Allow use of 'consent' while sleeping.
 *
 * Revision 1.164  2007/06/30 00:38:39  jps
 * Correctly free and then CREATE the 'name' section of player_table
 * when renaming a player. The prior method, which simply strcpy'd
 * the new name into the old space, probably performed buffer overruns.
 *
 * Revision 1.163  2007/06/24 02:51:44  jps
 * Move "skills" command up so that even big deities can use it.
 *
 * Revision 1.162  2007/06/04 22:24:41  jps
 * Add game-toggle for name approval pause and set name approval to default on.
 *
 * Revision 1.161  2007/05/28 03:59:05  jps
 * Stop 'forget' from breaking meditation.
 *
 * Revision 1.160  2007/05/24 05:25:14  jps
 * Don't break meditation or hiding for 'petition'.
 *
 * Revision 1.159  2007/05/11 21:33:10  myc
 * Made a number of commands (unused, mob-only, etc.) level -1 so they
 * wouldn't show up on the commands list.  Return is level 0 so I don't
 * get stuck in level 0 bugs when I switch.  Dig is 104 to go along
 * with other editing command levels on production.  Turned on the
 * commands command again.
 *
 * Revision 1.158  2007/05/11 21:03:12  myc
 * New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
 * complicated skill.  :P  Fixed cure blind's logic, and made it support
 * eye gouge too.
 *
 * Revision 1.157  2007/04/26 15:20:34  myc
 * Attempting to fix the check-in comment log.
 *
 * Revision 1.112  2002/06/09 21:48:36  rls
 * adjusted users and dc to lvl_head_b (where users was)
 *
 * Revision 1.111  2002/06/09 21:27:13  rls
 * Adjusted users level to grgod (seeing as they have dc)
 * and adjusted switch-return level to immortal for quest night.
 *
 * Revision 1.110  2002/04/26 18:54:01  mpg
 * modified "group" so group info can be accessed while sleeping
 *
 * Revision 1.109  2002/04/25 23:48:06  mpg
 * modified "glance" and "gossip" so they don't interrupt meditation
 *
 * Revision 1.108  2002/04/25 23:22:13  mpg
 * modified "skskills so it won't interrupt meditating
 *
 * Revision 1.107  2002/04/24 22:33:09  mpg
 * adjusted dmeditate Changed the time command so players could use it while meditating
 *
 * Revision 1.106  2002/04/17 23:42:43  dce
 * Fixed shapechange when you relogin it removes the mob.
 *
 * Revision 1.105  2002/02/19 02:07:20  dce
 * Changed do flee from POS_FIGHTING to POS_STANDING.
 *
 * Revision 1.104  2002/02/16 02:14:02  dce
 * Changed flee to a minimum positiong of standing, from resting.
 *
 * Revision 1.103  2001/11/14 18:18:02  dce
 * Sedit and Seduce have been switched.
 * Must be at least standing to search.
 *
 * Revision 1.102  2001/11/14 16:24:30  dce
 * Level 101+ can now set titles.
 *
 * Revision 1.101  2001/10/15 23:41:13  rjd
 * Lowered minimum position of the "get" command to POS_RESTING
 * to allow for chars to get things from bags/backpacks/containers
 * while resting. For those who nitpick, a person can roll around
 * while resting to grab stuff from the ground, as well. :P
 *
 * Revision 1.100  2001/07/12 23:14:17  mtp
 * added varset and varunset from dg_debug.c
 *
 * Revision 1.99  2001/05/13 16:15:58  dce
 * Fixed a bug where somethings wouldn't save when a player
 * died and exitied menu option 0 rather than menu option 1.
 *
 * Revision 1.98  2001/04/24 03:30:32  dce
 * Removed the "shit" social/command.
 *
 * Revision 1.97  2001/04/07 17:02:30  dce
 * Added the vitem command.
 *
 * Revision 1.96  2001/04/02 23:31:21  dce
 * Put vwear command into the command list
 *
 * Revision 1.95  2001/03/29 03:11:04  dce
 * Removed the ability to create a shaman from the main menu.
 *
 * Revision 1.94  2001/03/06 03:10:18  dce
 * Fixed a bug where players awaiting a name approval could
 * cut their link and then crash the mud.
 *
 * Revision 1.93  2001/02/27 00:53:23  mtp
 * made it possible to do mjunk in death trigger
 *
 * Revision 1.92  2001/01/20 03:33:21  rsd
 * made some god commands on test higher level
 *
 * Revision 1.91  2000/11/28 00:40:00  mtp
 * removed mobprog commands
 *
 * Revision 1.90  2000/11/26 00:27:42  rsd
 * moved recline a ways down in the list of commands so it
 * wouldn't be the first 're' parsed on.
 *
 * Revision 1.89  2000/11/23 00:57:04  mtp
 * added mskillset to allow a mob to set skill/spell proficiency
 *
 * Revision 1.88  2000/11/22 01:51:17  mtp
 * allow removeal of quests from global list with dqdel
 * note: qdel removes from list but not players, their quest structs are
 * managed on login
 *
 * Revision 1.87  2000/11/22 00:01:41  rsd
 * Added all 1 zillion back rlog messages from prior to
 * the addition of the $log$ string.
 *
 * Revision 1.86  2000/11/15 04:07:13  rsd
 * made ispell a god command, it was avail to mortals.
 *
 * Revision 1.85  2000/11/11 22:44:07  rsd
 * Fixed tabbing in the master commands array, retabbed part of
 * the code while trying to figure out where players get their
 * names auto-approved.  Fixed said code not to let players
 * whose names have been DECLINED from sitting at the new
 * name prompt and getting their new declined names into
 * the game anyway.
 *
 * Revision 1.84  2000/10/31 23:33:20  mtp
 * typo fix
 *
 * Revision 1.83  2000/10/31 23:27:01  mtp
 * added qlist and qadd
 *
 * Revision 1.82  2000/10/27 00:34:45  mtp
 * new command quest
 *
 * Revision 1.81  2000/10/15 04:41:00  cmc
 * changes for exp_mesg() and level ** characters
 *
 * Revision 1.80  2000/10/13 17:51:45  cmc
 * re-implemented modified level command.
 * modified exp_mesg() for "level gain" code.
 *
 * Revision 1.79  2000/10/11 23:50:45  rsd
 * Chris and jimmy seem to think this will delete any old
 * pfile stuff that may exist for a new char left over from
 * any old deleted chars,  Added code to check this in
 * nanny
 *
 * Also Checked to see if a player was level 0 on login, if
 * they are they are removed from the player index essentially
 * deleteing them and push the player requesting the name to
 * a new character login.
 *
 * Revision 1.77  2000/10/07 00:43:55  mtp
 * new mob command for triggers m_run_room_trig to run room triggers (mainly for use in death trigs)
 *
 * Revision 1.76  2000/09/13 22:19:22  rsd
 * Altered the level at which some commands are avail as well as
 * removed some if defs
 *
 * Revision 1.75  2000/05/22 22:35:53  rsd
 * Added char star for test mud greeting to reflect the old
 * FieryMUD test mud banner. They call me the doctor cuz I'm
 * always operatin'
 *
 * Revision 1.74  2000/05/21 23:56:43  rsd
 * Altered the level of prompt so mortals can get it to work.
 * So they can then be redirected at do_display.
 *
 * Revision 1.73  2000/05/14 05:19:29  rsd
 * made rebooting possible by 103's in test, also
 * removed player delete ability due to it's leakyness.
 *
 * Revision 1.72  2000/04/26 22:52:36  rsd
 * altered player menu to add player deletion.
 *
 * Revision 1.71  2000/04/22 22:36:25  rsd
 * fixed spelling of deity in player output, fixed grammar
 * error associated with exp indicators. move who to the
 * top of the wh's in the command parser so it's first for
 * wh.
 *
 * Revision 1.70  2000/04/17 00:55:48  rsd
 * altered the comment header.  Made prompt LVL_IMMORT
 *
 * Revision 1.69  2000/03/20 04:33:38  rsd
 * added ifdefs for test/prod builds to not have to name check
 * for the test build.
 *
 * Revision 1.68  2000/02/24 01:04:18  dce
 * Changed wiztitle from a command to a set.
 *
 * Revision 1.67  2000/02/22 00:51:30  rsd
 * Changed text on name autoapprove to be a short time
 * instead of a static 5 minutes.
 *
 * Revision 1.66  2000/02/16 07:59:10  mtp
 * added listrace to act.wizard.c it prints the race choice menu that new
 * players have (for Az)
 *
 * Revision 1.65  2000/02/14 19:48:49  mtp
 * moved mechoaround to after mecho cos a substring of mechoaround is mecho
 * and the wrong cmd was getting run *doh*
 * /s
 *
 * Revision 1.64  2000/02/13 08:53:18  rsd
 * Added the PRODUCTION flag ifdef replaceing the TESTMUD
 * flag.  Also mucked about with the god commands, giving
 * builders more commands on the test muds, and less on
 * production.
 *
 * Revision 1.63  2000/01/31 04:46:25  rsd
 * Added ifdefs for a production build to make gods on
 * production have different commands than on test.
 * Also mopped up several sloppy spacing issues.
 *
 * Revision 1.61  2000/01/30 23:33:23  rsd
 * Added necessary compentents to the menues for good race login.
 *
 * Revision 1.60  1999/12/10 22:13:45  jimmy
 * Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
 * level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
 * exp code.
 *
 * Revision 1.59  1999/12/06 20:28:08  cso
 * Made "skills" and "tell" doable while sleeping.
 *
 * Revision 1.58  1999/11/29 00:23:31  cso
 * removed unused variables to kill compile warnings
 *
 * Revision 1.57  1999/11/28 23:28:50  cso
 * removed unused arg from roll_natural_abils
 *
 * Revision 1.56  1999/11/23 15:48:23  jimmy
 * Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
 * Reinstated dual wield.
 * Allowed mobs/players to pick up items while fighting.
 * Fixed a bug in the damage message that wrongfully indicated a miss
 * due to a rounding error in the math.
 * This was all done in order to facilitate the chance to sling your
 * weapon in combat.  Dex and proficiency checks are now made on any missed
 * attact and a failure of both causes the weapon to be slung.
 *
 * Revision 1.55  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.54  1999/08/31 22:02:58  mtp
 * changed posn of get to STANDING
 *
 * Revision 1.53  1999/08/31 21:54:44  mtp
 * changed examine to a rting (resting) type command
 *
 * Revision 1.52  1999/08/29 23:01:41  mud
 * removed auction since it was being used for a congratulate channel.
 *
 * Revision 1.51  1999/08/29 17:56:51  mud
 * commented out the grats command, it was buggy and I don't want a global
 * method to communicate game stuff like that anyway.
 *
 * Revision 1.50  1999/08/12 17:54:46  dce
 * Fixed experience so that there are no overflows of integers that are placed into longs.
 * Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
 * Hubis coding.
 *
 * Revision 1.49  1999/08/12 04:25:39  jimmy
 * This is a Mass ci of the new pfile system.  The pfile has been split into
 * one file for each player in a directory A-Z.  The object files are also
 * located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
 * screwed up the IDNUM of the person who typed it.  Commented out the frag
 * system completely.  It is slated for removal.  Fixed the rename command.
 * Fixed all supporting functions for the new system, I hope!
 * --Gurlaek 8/11/1999
 *
 * Revision 1.48  1999/07/24 20:50:18  dce
 * Exchange command for banks added.
 *
 * Revision 1.47  1999/07/23 23:41:47  jimmy
 * moved send_toxnames back to where it belongs.
 * my fault. --gurlaek
 *
 * Revision 1.46  1999/07/22 17:43:59  jimmy
 * Added pfilemaint command
 * --gurlaek
 *
 * Revision 1.45  1999/07/11 04:18:23  mud
 * commented out case5 in the MENU for game login
 * players deleting themselves is producing some
 * problems as they aren't completely deleted.
 *
 * Revision 1.44  1999/07/10 03:17:44  mud
 * Changed the menue message "That's not a menu choice!" to
 * 'Wrong Option!" to continue to Fiery-ify the code...
 *
 * Revision 1.43  1999/07/07 22:51:54  mud
 * added the world command back to reflect the combination of
 * uptime and date.
 *
 * Revision 1.42  1999/07/07 21:57:44  mud
 * made the do_world command the do_game command to free up
 * world for a similar use to the old fiery.
 *
 * Revision 1.41  1999/06/30 18:11:09  jimmy
 * act.offensive.c    config.c      handler.c    spells.c
 * This is a major conversion from the 18 point attribute system to the
 * 100 point attribute system.  A few of the major changes are:
 * All attributes are now on a scale from 0-100
 * Everyone views attribs the same but, the attribs for one race
 *   may be differeent for that of another even if they are the
 *   same number.
 * Mobs attribs now get rolled and scaled using the same algorithim as PC's
 * Mobs now have individual random attributes based on race/class.
 * The STR_ADD attrib has been completely removed.
 * All bonus tables for attribs in constants.c have been replaced by
 *   algorithims that closely duplicate the tables except on a 100 scale.
 * Some minor changes:
 * Race selection at char creation can now be toggled by using
 *   <world races off>
 * Lots of cleanup done to affected areas of code.
 * Setting attributes for mobs in the .mob file no longer functions
 *   but is still in the code for later use.
 * We now have a spare attribut structure in the pfile because the new
 *   system only used three instead of four.
 * --gurlaek 6/30/1999
 *
 * Revision 1.40  1999/06/18 22:24:33  mud
 * Cut a piece of name code from case GET_NAME that was
 * preventing a password check for player names that were
 * declined in file.
 * Removed a line of code sending those names to xnames because
 * it duped code added to ban.c earlier in this process.
 *
 * Revision 1.39  1999/06/10 16:56:28  mud
 * This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
 * This fixes all of the warnings associated with the new compiler and
 * libraries.  Many many curly braces had to be added to "if" statements to
 * clarify their behavior to the compiler.  The name approval code was also
 * debugged, and tested to be stable.  The xnames list was converted from an
 * array to a linked list to allow for on the fly adding of names to the
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0
 *
 * Revision 1.38  1999/05/05 17:37:18  mud
 * made listspell a level 103+ command
 *
 * Revision 1.37  1999/05/04 17:19:33  dce
 * Name accept system...version one...original code by Fingh, fixed up to work
 * by Zantir.
 *
 * Revision 1.36  1999/05/01 18:01:21  dce
 * Allow players to drop all eq and quit.
 *
 * Revision 1.35  1999/04/23 23:27:10  jimmy
 * Fixed warnings/errors associated with the addition of the pendantic compiler flag
 * yeeeeehaaawwww.  --gurlaek
 *
 * Revision 1.34  1999/04/22 18:57:27  mud
 * added bold to each of the exp notch indicators.
 *
 * Revision 1.33  1999/04/18 20:14:23  dce
 * *** empty log message ***
 *
 * Revision 1.32  1999/04/16 19:48:20  dce
 * Must be level 3 to post/write
 *
 * Revision 1.31  1999/04/16 03:55:09  dce
 * Removed some things temporarly until they can be fixed.
 *
 * Revision 1.30  1999/04/09 20:33:04  dce
 * Added listexp command
 *
 * Revision 1.29  1999/04/09 03:38:36  dce
 * Junk command is back!
 *
 * Revision 1.28  1999/04/07 18:12:04  jen
 * Added a msg to the room when a player stops meditating
 *
 * Revision 1.27  1999/04/07 15:39:34  jen
 * Two changes:
 * 1) Made prayer a command that doesn't interrupt meditation
 * 2) Made 'listclass' a GRGOD command since GRGODs can set classes;
 * they need the reference list!
 *
 * Selandria / JEN II
 *
 * Revision 1.26  1999/03/26 19:54:57  dce
 * Added new command old -> shows the old do_score
 *
 * Revision 1.25  1999/03/26 19:44:35  jen
 * Added a mortal gossip channel with 103+ godly control
 *
 * Revision 1.24  1999/03/22 21:55:12  mud
 * Added extended cases for name acceptance ye and yes
 *
 * Revision 1.23  1999/03/20 18:54:39  tph
 * removed attribute priority questions, removed hunter, illusionist, mystic from char generation
 *
 * Revision 1.22  1999/03/14 00:53:03  mud
 * In class.c added a new line before the fiery mud class explanation
 * in config.c added the variable for name explanations and added the
 * text for the variable
 * in interpreter.c added the con_state stuff, whatever that was and
 * added the CON_NAME_CHECK affirmation section to the creation menu
 * loop or nanny.
 * In structs.h added the CON_NAME_CHECK define..
 * I also drove Jimmy absolutely insane with the deail in information
 * I put into our change control system.
 * lala
 *
 * Revision 1.21  1999/03/05 20:02:36  dce
 * Chant added to, and songs craeted
 *
 * Revision 1.20  1999/03/04 20:13:51  jimmy
 * removed silly debug message
 * fingon
 *
 * Revision 1.19  1999/03/01 05:31:34  jimmy
 * Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
 * list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
 * on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
 * and take 20 seconds to scribe each page.  This will be more dynamic when the
 * SCRIBE skill is introduced.  --Fingon.
 *
 * Revision 1.18  1999/02/26 22:30:30  dce
 * Monk additions/fixes
 *
 * Revision 1.17  1999/02/23 16:48:06  dce
 * Creates a new command called file. Allows us to view files
 * through the mud.
 *
 * Revision 1.16  1999/02/13 19:35:06  mud
 * commented out unused variable in line 1554 associated with
 *    / * Subclassing explaination/preface * / which was commented
 * earlier to hide subclasses from players at login.
 *
 * Revision 1.15  1999/02/12 21:43:38  mud
 * Ok, I finished moving the subclass issue from the class selection view
 * the todo list will have more on the work remaining on this.
 *
 * Revision 1.14  1999/02/12 21:41:28  mud
 * I removed the View of the subclasses from the class Selection screen
 * In doing so I've created a warning, I have no idea how to fix it,
 * someone take a peek at it?
 *
 * Revision 1.13  1999/02/10 22:21:42  jimmy
 * Added do_wiztitle that allows gods to edit their
 * godly title ie Overlord.  Also added this title
 * to the playerfile
 * fingon
 *
 * Revision 1.12  1999/02/07 07:29:01  mud
 * removed debug message
 *
 * Revision 1.11  1999/02/06 05:32:46  jimmy
 * Fixed buffer overflow in do_alias
 * fingon
 *
 * Revision 1.10  1999/02/06 04:29:51  dce
 * David Endre 2/5/99
 * Added do_light
 *
 * Revision 1.9  1999/02/06 00:40:36  jimmy
 * Major change to incorporate aliases into the pfile
 * moved alias structure from interpreter.h to structs.h
 * heavily modified alias code in interpreter.c
 * Jimmy Kincaid AKA fingon
 *
 * Revision 1.8  1999/02/04 16:42:34  jimmy
 * Combined attributes, score, and exp commands.
 *
 * Revision 1.7  1999/02/04 00:02:59  jimmy
 * max/min exp loss/gain set to 2 notches.
 *
 * Revision 1.6  1999/02/01 22:40:16  jimmy
 * made listspells an LVL_IMMORT command
 *
 * Revision 1.5  1999/02/01 08:15:46  jimmy
 * improved build counter
 *
 * Revision 1.4  1999/02/01 04:18:50  jimmy
 * Added buildcounter to GREETING --Fingon
 *
 * Revision 1.3  1999/01/31 06:43:09  mud
 * Indented file
 *
 * Revision 1.2  1999/01/29 04:06:46  jimmy
 * temp remove races from login menu
 *
 * Revision 1.1  1999/01/29 01:23:31  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.328
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.327 2009/07/16 19:15:54 myc Exp mud $
d2354 1
a2354 1
            log(buf);
d2409 1
a2409 1
            log(buf);
d2415 1
a2415 1
            log(buf);
d2469 1
a2469 1
         log(buf);
d2676 1
a2676 1
    log(buf);
d3244 3
@


1.327
log
@Moved command stuff from grant.c to commands.c
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.326 2009/07/14 01:22:48 myc Exp myc $
d47 1
d3244 3
@


1.326
log
@If a clan has a special motd, give some warning on the motd screen.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.325 2009/06/09 21:50:21 myc Exp myc $
d26 1
d44 1
a44 1
#include "grant.h"
a75 1
void gedit_parse(struct descriptor_data *d, char *arg);
d3243 3
@


1.325
log
@Adding a couple of hacks to enter_player_game to make sure
clans and cooldowns are always handled correctly.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.324 2009/06/09 05:41:36 myc Exp myc $
d2571 3
a2573 1
        dprintf(d, "\r\n%s", GET_CLAN(d->character)->motd);
d3243 4
@


1.324
log
@Adding a hook for the clan motd, and adjusting delete player
to work with the new clan interface.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.323 2009/03/20 23:02:59 myc Exp myc $
d2051 1
d2106 16
d3241 4
@


1.323
log
@Move text file handling routines into text.c
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.322 2009/03/16 19:17:52 jps Exp myc $
d46 1
a46 1
#include "text.h"
d2553 3
d3003 2
a3004 2
      if (GET_CLAN(d->character))
        remove_player_from_clan(GET_NAME(d->character), GET_CLAN(d->character));
d3224 3
@


1.322
log
@Change macro GET_HOME to GET_HOMEROOM
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.321 2009/03/09 02:22:32 myc Exp jps $
d46 1
a47 3
extern char *motd;
extern char *imotd;
extern char *background;
d386 1
a386 1
  { "anews"    , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_ANEWS, CMD_ANY },
d440 1
a440 1
  { "close"    , POS_SITTING, STANCE_RESTING , do_gen_door , 0, SCMD_CLOSE, 0 },
d453 1
a453 1
  { "credits"  , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_CREDITS, CMD_ANY },
d564 1
a564 1
  { "handbook" , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK, CMD_ANY },
d588 1
a588 2
  { "imotd"    , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD, CMD_ANY },
  { "immlist"  , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST, CMD_ANY },
d595 1
a595 1
  { "info"     , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_INFO, CMD_ANY },
d632 1
a632 1
  { "motd"     , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_MOTD, CMD_ANY },
d650 1
a650 1
  { "news"     , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_NEWS, CMD_ANY },
d689 1
a689 1
  { "policy"   , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_POLICIES, CMD_ANY },
d921 1
a921 1
  { "wizlist"  , POS_PRONE   , STANCE_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST, CMD_ANY },
d2549 1
a2549 1
        write_to_output(imotd, d);
d2551 1
a2551 1
        write_to_output(motd, d);
d2939 1
a2939 1
      page_string_desc(d, background);
d3157 1
a3157 1
     write_to_output(motd, d);
d3221 3
@


1.321
log
@Added edit command.  Modified is_number to allow leading spaces.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.320 2009/03/08 23:34:14 jps Exp myc $
d2070 1
a2070 1
      load_room = real_room(GET_HOME(d->character));
d2077 1
a2077 1
      load_room = real_room(GET_HOME(d->character));
d2751 1
a2751 1
    GET_HOME(d->character) = classes[(int)GET_CLASS(d->character)].homeroom;
d3224 3
@


1.320
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.319 2009/03/07 11:12:05 jps Exp jps $
d145 1
d491 1
d1451 17
d3224 3
@


1.319
log
@Separated the read command from the look command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.318 2009/03/03 19:43:44 myc Exp jps $
d27 1
a27 1
#include "spells.h"
d3205 3
@


1.318
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.317 2009/02/21 03:30:16 myc Exp myc $
d231 1
d612 1
a612 1
  { "look"     , POS_PRONE   , STANCE_RESTING , do_look     , 0, SCMD_LOOK, CMD_MINOR_PARA | CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST | CMD_OLC },
d715 1
a717 1
  { "read"     , POS_PRONE   , STANCE_RESTING , do_look     , 0, SCMD_READ, 0 },
d3205 3
@


1.317
log
@Adding hook for boardadmin command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.316 2009/02/11 17:03:39 myc Exp myc $
d1212 1
a1212 1
  if (GET_LEVEL(ch) >= LVL_GOD && (vict = get_player_vis(ch, arg, FALSE)))
d3204 3
@


1.316
log
@Adding delimited_arg_case, which is exactly like delimited_arg,
but it doesn't make everything lower case.  (There's got to be
a better way to do this.)
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.315 2009/01/18 06:58:53 myc Exp myc $
d113 1
d414 1
d3204 5
@


1.315
log
@Adding "emote's" command so you can emote stuff like
"Laoris's arms are tired."
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.314 2008/12/03 03:13:43 myc Exp myc $
d1589 25
d3202 4
@


1.314
log
@Don't allow shapechanging during battle; it leaves the original character
in the fighting stance, which wrecks havoc later.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.313 2008/09/28 19:06:49 jps Exp myc $
d490 1
d3177 4
@


1.313
log
@Change SCMD_NOTES to SCMD_NOTE.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.312 2008/09/25 04:48:10 jps Exp jps $
d766 1
a766 1
  { "shapechange",POS_STANDING, STANCE_ALERT   , do_shapechange, 0, 0, 0 },
d3176 3
@


1.312
log
@Add coredump command for lvl 104+
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.311 2008/09/21 21:51:18 jps Exp jps $
d653 1
a653 1
  { "note"     , POS_PRONE   , STANCE_DEAD    , do_gen_write, LVL_IMMORT, SCMD_NOTES, CMD_ANY },
d3176 3
@


1.311
log
@Stop trying to keep track of who's attacking who when there's a shapechange,
since do_shapechange handles that internally now.  Also, you can shapechange
during a battle now.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.310 2008/09/21 20:40:40 jps Exp jps $
d124 1
d448 1
d3176 5
@


1.310
log
@Keep a list of attackers with each character, so that at the proper times -
such as char_from_room - they can be stopped from battling.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.309 2008/09/21 04:54:23 myc Exp jps $
d764 1
a764 1
  { "shapechange",POS_STANDING, STANCE_ALERT   , do_shapechange, 0, 0, CMD_NOFIGHT },
a1874 1
  struct char_data *attacker;
d1894 2
a1895 17
        attacker = NULL;
        if (POSSESSED(k->character)) {
           /* I assume that we're forcing a player to shapechange to normal, and
            * making anyone who was fighting the shapechange mob attack the player,
            * after the shapechange. This is the WRONG place for this code -
            * such battle-maintenance should be handled somewhere else.
            *
            * Also, there could be multiple attackers and this will only cause
            * one of them to continue fighting the player. */
          if (FIGHTING(k->character)) {
            attacker = k->character->target;
            stop_battling(k->character);
           }
           do_shapechange(k->character, "me", 0, 1);
           if (attacker)
              set_fighting(attacker, k->character, TRUE);
        }
d3174 4
@


1.309
log
@Added ungrant command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.308 2008/09/20 06:05:06 jps Exp myc $
d1897 7
d1905 2
a1906 2
            attacker = k->character->char_specials.fighting;
            stop_fighting(k->character);
d1910 1
a1910 1
              attack(attacker, k->character);
d3190 3
@


1.308
log
@Add macros POSSESSED and POSSESSOR.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.307 2008/09/14 02:08:01 jps Exp jps $
d869 1
d3144 1
d3148 2
a3149 2
   * first, count commands (num_of_commands is actually one greater than
   * the number of commands; it inclues the '\n'.
d3152 1
a3152 1
    num_of_cmds++;
d3183 3
@


1.307
log
@Use standardized area attack targetting
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.306 2008/09/08 05:24:50 jps Exp jps $
d1895 1
a1895 1
        if(k->character->desc && k->character->desc->original) {
d3181 3
@


1.306
log
@Put autosave as the "quit reason" when autosaving. This is a temporary fix
that should stop people from losing keys when autosave code thinks their
quit reason is something else, like renting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.305 2008/09/07 20:05:27 jps Exp jps $
a118 1
ACMD(do_circle);
a435 1
/*{ "circle"   , POS_STANDING, STANCE_ALERT   , do_circle   , 1, 0, 0 },*/
d3181 5
@


1.305
log
@Renamed exp_to_level to exp_next_level to make it clearer what it means.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.304 2008/09/07 07:21:56 jps Exp jps $
d2066 1
d3183 3
@


1.304
log
@Raised pscan to level 104.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.303 2008/09/01 22:15:59 jps Exp jps $
a87 1
long exp_to_level(int, int);
d2999 2
a3000 1
  total = (long) exp_to_level(level, GET_CLASS(ch)) - exp_to_level((level - 1), GET_CLASS(ch));
d3007 2
a3008 1
  total=exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
d3182 3
@


1.303
log
@Saving and reporting players' game-leaving reasons and locations.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.302 2008/08/31 21:04:46 myc Exp jps $
d697 1
a697 1
  { "pscan"    , POS_PRONE   , STANCE_DEAD    , do_pscan    , LVL_GRGOD, 0, CMD_ANY},
d3181 3
@


1.302
log
@Abort command gives a useful message when not casting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.301 2008/08/29 19:18:05 myc Exp myc $
a2059 1
  save_player_char(d->character);
d2063 5
d3181 3
@


1.301
log
@Fixed abilities so that no information is lost; the caps occur
only when the viewed stats are accessed.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.300 2008/08/29 04:16:26 myc Exp myc $
d375 1
a376 1
  { "abort"    , POS_PRONE   , STANCE_DEAD    , do_abort    , 0, 0, CMD_ANY ^ CMD_BOUND },
d3177 4
@


1.300
log
@Moved all ACMD prototypes for commands in act.informative.c
to the act.h file.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.299 2008/08/29 03:02:40 myc Exp myc $
d2808 1
a2808 1
    d->character->viewed_abils = d->character->natural_abils;
d3177 4
@


1.299
log
@Misspelling of STANC_.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.298 2008/08/28 23:48:29 rbr Exp myc $
d45 1
a122 2
ACMD(do_color);
ACMD(do_commands);
a124 1
ACMD(do_consider);
a146 1
ACMD(do_equipment);
a147 1
ACMD(do_examine);
a148 2
ACMD(do_exits);
ACMD(do_experience);
a158 1
ACMD(do_gen_ps);
a168 1
ACMD(do_help);
a174 1
ACMD(do_identify);
a177 1
ACMD(do_innate);
a180 1
ACMD(do_inventory);
a194 1
ACMD(do_listspells);
a195 1
ACMD(do_look);
a249 1
ACMD(do_score);
a250 2
ACMD(do_scan);
ACMD(do_search);
a258 1
ACMD(do_skills);
a260 1
ACMD(do_songs);
a261 1
ACMD(do_spells);
a279 1
ACMD(do_time);
a282 1
ACMD(do_trophy);
a287 1
ACMD(do_users);
a290 1
ACMD(do_viewdam);
a304 1
ACMD(do_weather);
a305 1
ACMD(do_who);
d2885 1
a2885 1
      look_at_room(d->character, 0);
d3177 3
@


1.298
log
@Added the do_abandon command to the command list.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.297 2008/08/24 18:24:20 myc Exp rbr $
d400 1
a400 1
  { "abandon"  , POS_PRONE   , STANC_RESTING  , do_abandon  , 0, 0, 0 },
d3202 3
@


1.297
log
@Change iptables to level 104.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.296 2008/08/24 02:34:26 myc Exp myc $
d99 1
d400 1
d3202 3
@


1.296
log
@Add hook for ksearch command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.295 2008/08/18 01:35:38 jps Exp myc $
d619 1
a619 1
  { "iptables" , POS_PRONE   , STANCE_DEAD    , do_iptables , LVL_ADMIN + 1, 0, CMD_ANY },
d3200 3
@


1.295
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.294 2008/08/16 08:25:13 jps Exp jps $
d199 1
d630 1
d3200 3
@


1.294
log
@Took desc and delete out of the pre-game menu.
Added a desc command so players can edit their descriptions in game.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.293 2008/08/15 05:50:54 jps Exp jps $
d2590 1
a2590 1
      write_to_output("\r\nDone.\n\r", d);
d2792 1
a2792 1
    write_to_output("\r\r\n\n&0&7&bYou have three bonus's to use choose the stat carefully:&0\n\r", d);
d2794 1
a2794 1
    write_to_output("\r\n&0&7&bPlease enter your first bonus selection:&0\n\r",d);
d2804 1
a2804 1
    write_to_output("\r\n&0&7&bPlease enter your second bonus selection:&0\n\r",d);
d2816 1
a2816 1
    write_to_output("\r\n&0&7&bPlease enter your third bonus selection:&0\n\r",d);
d3198 4
@


1.293
log
@Moved pray command above prompt.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.292 2008/08/15 03:59:08 jps Exp jps $
d132 1
d489 1
a2918 7
      write_to_output("Enter the text you'd like others to see when they look at you.\r\n", d);
      write_to_output("(/s saves /h for help)\r\n", d);
      string_write(d, &d->character->player.description, EXDSCR_LENGTH - 1);
      STATE(d) = CON_EXDESC;
      break;

    case '3':
d2923 1
a2923 1
    case '4':
d2928 1
a2928 1
    case '5':
d2931 1
a2931 1
      STATE(d) = CON_MENU;
d2935 1
a2935 1
      break;
d2937 1
a2937 1
      write_to_output("\r\nWrong Option!\r\n", d);
d3198 3
@


1.292
log
@Added pprintf for paging, and changed page_string to take a character.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.291 2008/08/14 23:10:35 myc Exp jps $
d713 1
a715 1
  { "pray"     , POS_PRONE   , STANCE_RESTING , do_pray     , 0, 0, CMD_MEDITATE },
d3203 3
@


1.291
log
@Made one of the arguments to search_block const.  Hardcoded the
ANSI string in there.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.290 2008/08/14 09:45:22 jps Exp myc $
d2924 1
a2924 1
      page_string(d, background);
d3203 4
@


1.290
log
@Replaced the pager.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.289 2008/08/10 02:58:40 jps Exp jps $
d1440 1
a1440 1
int search_block(char *arg, const char **list, bool exact)
a2116 1
  extern char *ANSI;
d2227 1
a2227 1
         write_to_output(ANSI, d);
d3203 3
@


1.289
log
@Added infodump command for outputting game data to text files.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.288 2008/07/27 05:13:23 jps Exp jps $
d44 1
d2714 1
a2714 1
      page_string(d, buf2, 0);
d2925 1
a2925 1
      page_string(d, background, 0);
d3204 3
@


1.288
log
@Changed name of save_player to save_player_char, since it only saves the
character, not other stuff like objects and quests.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.287 2008/07/27 01:33:51 jps Exp jps $
d186 1
d608 1
d3203 4
@


1.287
log
@Removed unused ACMD do_rent.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.286 2008/07/26 21:33:55 jps Exp jps $
d2076 1
a2076 1
  save_player(d->character);
d2435 1
a2435 1
         save_player(d->character);
d2478 1
a2478 1
        save_player(d->character);
d2584 1
a2584 1
      save_player(d->character);
d2870 1
a2870 1
            save_player(d->character);
d2887 1
a2887 1
      save_player(d->character);
d3127 1
a3127 1
   save_player(d->character);
d3201 3
@


1.286
log
@Removed objfix command and added objupdate command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.285 2008/07/22 07:25:26 myc Exp jps $
a242 1
ACMD(do_rent);
d3201 3
@


1.285
log
@Added iedit (unique item editor).
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.284 2008/07/15 19:22:25 myc Exp myc $
d338 1
a338 1
ACMD(do_objfix);
d984 1
a984 1
  { "objfix"   , POS_PRONE   , STANCE_DEAD    , do_objfix   , LVL_HEAD_C, 0, CMD_ANY },
d3202 3
@


1.284
log
@Don't let gods change aliases of people of a higher level.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.283 2008/07/15 19:14:33 myc Exp myc $
d181 1
d602 1
d2143 1
d3202 3
@


1.283
log
@Modified do_alias to allow gods to see/modify players' aliases.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.282 2008/07/15 18:53:39 myc Exp myc $
d1246 1
a1246 1
  else if (ch == vict || GET_LEVEL(ch) >= LVL_ADMIN) {
d1287 4
d3199 3
@


1.282
log
@Added an array of strings for command flags.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.281 2008/07/15 17:49:24 myc Exp myc $
d1220 1
d1222 9
a1230 1
  if (IS_NPC(ch))
d1232 1
a1232 2

  repl = any_one_arg(argument, arg);
d1238 1
a1238 1
    if ((alias = GET_ALIASES(ch)))
d1246 1
a1246 1
  else {
d1250 2
a1251 2
    if ((alias = find_alias(GET_ALIASES(ch), arg))) {
      REMOVE_FROM_LIST(alias, GET_ALIASES(ch), next);
d1260 2
a1262 2
      else
        send_to_char("Alias deleted.\r\n", ch);
d1282 2
a1283 2
      alias->next = GET_ALIASES(ch);
      GET_ALIASES(ch) = alias;
d3195 3
@


1.281
log
@Whether you can use a command depends not only on level now, but
also on command grants.  Added the grant, gedit, and revoke commands.
Functionalized the levenshtein similar commands code.  Added
parse_command, which is the same as find_command, but it allows
abbreviations.
Added a hook for gedit to the nanny.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.280 2008/07/13 16:48:09 jps Exp myc $
d986 13
d3187 8
@


1.280
log
@Make the MESMERIZED effect ineffective against immortals.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.279 2008/06/21 08:53:09 myc Exp jps $
d43 1
d75 1
d574 2
d747 1
d1010 28
d1076 1
a1076 1
      if (GET_LEVEL(ch) >= cmd_info[cmd].minimum_level)
a1090 1
    int found = FALSE;
d1092 1
a1092 22
    if (!PRF_FLAGGED(ch, PRF_NOHINTS)) {
      /* Display similar commands. */
      for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd) {
        if (*arg != *cmd_info[cmd].command)
          continue;
        if (cmd_info[cmd].minimum_level > GET_LEVEL(ch))
          continue;
        if (cmd_info[cmd].minimum_level < 0)
          continue;
        /* skip socials */
        if (cmd_info[cmd].command_pointer == do_action)
          continue;
        if (levenshtein_distance(arg, cmd_info[cmd].command) <= 2) {
          if (!found) {
            send_to_char("\r\nDid you mean:\r\n", ch);
            found = TRUE;
          }
          sprintf(buf, "  %s\r\n", cmd_info[cmd].command);
          send_to_char(buf, ch);
        }
      }
    }
d1780 1
a1780 1
  for (cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
d1788 12
d2123 1
d3174 3
@


1.279
log
@Set the player's last logon time in enter_player_game.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.278 2008/06/09 23:00:13 myc Exp myc $
d1101 1
a1101 1
  else if (EFF_FLAGGED(ch, EFF_MESMERIZED))
d3150 3
@


1.278
log
@Got rid of the disembark command..
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.277 2008/06/05 02:07:43 myc Exp myc $
d2025 1
d3150 3
@


1.277
log
@Rewrote rent saving to use ascii object files.  Moved quest loading
into enter_player_game.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.276 2008/05/19 06:53:04 jps Exp myc $
a128 1
ACMD(do_disembark);
a491 1
  { "disembark", POS_STANDING, STANCE_ALERT   , do_disembark,-1, 0, CMD_NOFIGHT },
d3149 4
@


1.276
log
@Got rid of fup and fdown commands.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.275 2008/05/19 06:17:07 jps Exp jps $
d400 1
a400 1
  { "accuse"   , POS_SITTING, STANCE_RESTING , do_action   , 0, 0, 0 },
d2019 1
a2019 1
  if ((load_result = loadpfile_objs(d->character)))
d2025 1
d2319 1
a2319 1
         get_pfilename(GET_NAME(d->character), buf, CRASH_FILE);
a2492 1
      loadpfile_quest(d->character);
d3151 3
@


1.275
log
@You can't do things when mesmerized.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.274 2008/05/18 20:16:11 jps Exp jps $
a946 2
  { "fup"      , POS_STANDING, STANCE_ALERT   , do_move     ,-1, SCMD_FUP, CMD_HIDE | CMD_NOFIGHT },
  { "fdown"    , POS_STANDING, STANCE_ALERT   , do_move     ,-1, SCMD_FDOWN, CMD_HIDE | CMD_NOFIGHT },
d3151 3
@


1.274
log
@Created fight.h and set dependents.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.273 2008/05/18 03:24:14 jps Exp jps $
d1105 2
d3153 3
@


1.273
log
@Added inctime/hour wiz command to advance time 1 hour.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.272 2008/05/09 22:04:33 jps Exp jps $
d42 1
d3151 3
@


1.272
log
@Add delimited_arg_all(), which is like delimited_arg() except that
when there's no delimiter, it will return everything as the arg
(not just the first word).
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.271 2008/04/20 04:11:08 jps Exp jps $
d180 1
d604 2
d3150 5
@


1.271
log
@Removing unused ACMD
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.270 2008/04/07 04:32:11 jps Exp jps $
d1565 24
d3147 3
@


1.270
log
@Use CMD_NOFIGHT bit for commands that shouldn't be available in a fight.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.269 2008/04/07 03:02:54 jps Exp jps $
a356 1
ACMD(do_DumbMobTrack);
d3123 3
@


1.269
log
@Changed the POS/STANCE system so that POS reflects the position
of your body, while STANCE describes your condition or activity.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.268 2008/04/05 16:49:38 myc Exp jps $
d379 1
d381 1
a381 1
  { "RESERVED", 0, 0, 0, 0, 0 },        /* this must be first -- for specprocs */
d384 6
a389 6
  { "north"    , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_NORTH , CMD_HIDE | CMD_OLC },
  { "east"     , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_EAST  , CMD_HIDE | CMD_OLC },
  { "south"    , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_SOUTH , CMD_HIDE | CMD_OLC },
  { "west"     , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_WEST  , CMD_HIDE | CMD_OLC },
  { "up"       , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_UP    , CMD_HIDE | CMD_OLC },
  { "down"     , POS_PRONE   , STANCE_ALERT    , do_move     , 0, SCMD_DOWN  , CMD_HIDE | CMD_OLC },
d392 216
a607 215
  { "at"       , POS_PRONE   , STANCE_DEAD     , do_at       , LVL_ATTENDANT - 1, 0, CMD_ANY },
  { "abort"    , POS_PRONE   , STANCE_DEAD     , do_abort    , 0, 0, CMD_ANY ^ CMD_BOUND },
  { "ack"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "advance"  , POS_PRONE   , STANCE_DEAD     , do_advance  , LVL_ADMIN, 0, CMD_ANY },
  { "aggr"     , POS_PRONE   , STANCE_DEAD     , do_aggr     , 0, 0, 0 },
  { "alert"    , POS_PRONE   , STANCE_RESTING  , do_alert    , 0, 0, CMD_CAST },
  { "alias"    , POS_PRONE   , STANCE_DEAD     , do_alias    , 0, 0, CMD_MEDITATE | CMD_HIDE },
  { "accuse"   , POS_SITTING , STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "afk"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "agree"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "amaze"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "anews"    , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , LVL_IMMORT, SCMD_ANEWS, CMD_ANY },
  { "apologize", POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "applaud"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "appear"   , POS_STANDING, STANCE_ALERT    , do_not_here ,-1, 0, 0 },
  { "assist"   , POS_STANDING, STANCE_FIGHTING , do_assist   , 1, 0, 0 },
  { "ask"      , POS_PRONE   , STANCE_RESTING  , do_spec_comm, 0, SCMD_ASK, CMD_OLC },
  { "autoboot" , POS_PRONE   , STANCE_DEAD     , do_autoboot,  LVL_REBOOT_VIEW, 0, CMD_ANY },
/*{ "auction"  , POS_PRONE   , STANCE_SLEEPING , do_gen_comm , LVL_GOD, SCMD_AUCTION, 0 },*/
  { "ayt"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "backstab" , POS_STANDING, STANCE_FIGHTING , do_backstab , 1, 0, 0 },
  { "ban"      , POS_PRONE   , STANCE_DEAD     , do_ban      , LVL_GRGOD, 0, CMD_ANY },
  { "bandage"  , POS_STANDING, STANCE_ALERT    , do_bandage  , 1, 0, 0 },
  { "balance"  , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "bang"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bark"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bash"     , POS_STANDING, STANCE_FIGHTING , do_bash     , 1, SCMD_BASH, 0 },
/*{ "bind"     , POS_STANDING, STANCE_ALERT    , do_bind     ,-1, 0, 0 },*/
  { "bodyslam" , POS_STANDING, STANCE_FIGHTING , do_bash     , 1, SCMD_BODYSLAM, 0 },
  { "beckon"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "beer"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "beg"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "berserk"  , POS_STANDING, STANCE_FIGHTING , do_berserk  , 0, 0, 0 },
  { "bite"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bird"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "blink"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bleed"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "blush"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "boggle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bonk"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bored"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bounce"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "bow"      , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "brb"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "breathe"  , POS_STANDING, STANCE_FIGHTING , do_breathe  ,-1, 0, 0 },
  { "buck"     , POS_STANDING, STANCE_ALERT    , do_buck     , 0, 0, 0 },
  { "burp"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "buy"      , POS_STANDING, STANCE_ALERT    , do_not_here , 0, 0, 0 },
  { "bug"      , POS_PRONE   , STANCE_DEAD     , do_gen_write, 0, SCMD_BUG, CMD_ANY },
  { "bye"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "cast"     , POS_SITTING , STANCE_ALERT    , do_cast     , 1, SCMD_CAST, 0},
  { "cackle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "camp"     , POS_STANDING, STANCE_ALERT    , do_camp     , 1, 0, 0 },
  { "chant"    , POS_STANDING, STANCE_FIGHTING , do_cast     , 0, SCMD_CHANT, 0 },
  { "chuckle"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "check"    , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "cheer"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "choke"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "clan"     , POS_PRONE   , STANCE_SLEEPING , do_clan     , 1, 0, CMD_MEDITATE },
  { "clap"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "claw"     , POS_STANDING, STANCE_FIGHTING , do_claw     , 1, 0, 0 },
  { "clear"    , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "close"    , POS_SITTING , STANCE_ALERT    , do_gen_door , 0, SCMD_CLOSE, 0 },
  { "cls"      , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "consider" , POS_PRONE   , STANCE_RESTING  , do_consider , 0, 0, 0 },
  { "color"    , POS_PRONE   , STANCE_DEAD     , do_color    , 0, 0, CMD_ANY },
  { "compare"  , POS_PRONE   , STANCE_RESTING  , do_compare  , 0, 0, CMD_MEDITATE },
  { "comfort"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "comb"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "commands" , POS_PRONE   , STANCE_DEAD     , do_commands , 0, SCMD_COMMANDS, CMD_ANY },
  { "consent"  , POS_PRONE   , STANCE_INCAP    , do_consent  , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_CAST | CMD_OLC },
  { "conceal"  , POS_STANDING, STANCE_ALERT    , do_conceal  , 0, 0, CMD_HIDE },
  { "corner"   , POS_STANDING, STANCE_FIGHTING , do_corner   , 0, 0, 0 },
  { "cough"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "credits"  , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_CREDITS, CMD_ANY },
  { "cringe"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "cry"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "clist"    , POS_PRONE   , STANCE_DEAD     , do_csearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "csearch"  , POS_PRONE   , STANCE_DEAD     , do_csearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ctell"    , POS_PRONE   , STANCE_SLEEPING , do_ctell    , 0, 0, CMD_ANY },
  { "cuddle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "curse"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "curtsey"  , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },

  { "dance"    , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "date"     , POS_PRONE   , STANCE_DEAD     , do_date     , 0, SCMD_DATE, CMD_ANY },
  { "daydream" , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "dc"       , POS_PRONE   , STANCE_DEAD     , do_dc       , LVL_ATTENDANT, 0, CMD_ANY },
  { "deposit"  , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "diagnose" , POS_PRONE   , STANCE_RESTING  , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "dismount" , POS_STANDING, STANCE_ALERT    , do_dismount , 0, 0, 0 },
  { "display"  , POS_PRONE   , STANCE_DEAD     , do_display  , 0, 0, CMD_ANY },
  { "disband"  , POS_PRONE   , STANCE_SLEEPING , do_disband  , 1, 0, 0 },
  { "dig"      , POS_PRONE   , STANCE_DEAD     , do_dig      , LVL_BUILDER, 0, CMD_ANY ^ CMD_OLC },
  { "disappear", POS_STANDING, STANCE_ALERT    , do_not_here ,-1, 0, 0 },
  { "disarm"   , POS_STANDING, STANCE_FIGHTING , do_disarm   , 0, 0, 0 },
  { "disengage", POS_STANDING, STANCE_FIGHTING , do_disengage, 0, 0, CMD_CAST },
  { "disembark", POS_STANDING, STANCE_ALERT    , do_disembark,-1, 0, 0 },
  { "doorbash" , POS_STANDING, STANCE_ALERT    , do_doorbash , 0, 0, 0 },
  { "douse"    , POS_STANDING, STANCE_ALERT    , do_douse    , 0, 0, 0 },
  { "drag"     , POS_STANDING, STANCE_ALERT    , do_drag     , 1, 0, 0 },
  { "dream"    , POS_PRONE   , STANCE_SLEEPING  , do_action  , 0, 0, 0 },
  { "drink"    , POS_PRONE   , STANCE_RESTING  , do_drink    , 0, SCMD_DRINK, 0 },
  { "drop"     , POS_PRONE   , STANCE_RESTING  , do_drop     , 0, SCMD_DROP, 0 },
  { "drool"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "duck"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "duh"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "dump"     , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },

  { "eat"      , POS_PRONE   , STANCE_RESTING  , do_eat      , 0, SCMD_EAT, 0 },
  { "echo"     , POS_PRONE   , STANCE_DEAD     , do_echo     , LVL_IMMORT, SCMD_ECHO, CMD_ANY },
  { "electrify", POS_STANDING, STANCE_FIGHTING , do_electrify, 1, 0, 0 },
  { "emote"    , POS_PRONE   , STANCE_RESTING  , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { ":"        , POS_PRONE   , STANCE_RESTING  , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { "embrace"  , POS_PRONE   , STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "enter"    , POS_PRONE   , STANCE_ALERT    , do_enter    , 0, 0, 0 },
  { "envy"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "equipment", POS_PRONE   , STANCE_SLEEPING , do_equipment, 0, 0, CMD_ANY },
  { "exits"    , POS_PRONE   , STANCE_RESTING  , do_exits    , 0, 0, CMD_HIDE | CMD_MEDITATE | CMD_OLC },
  { "examine"  , POS_PRONE   , STANCE_RESTING  , do_examine  , 0, 0, CMD_HIDE | CMD_OLC },
  { "exchange" , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "experience",POS_PRONE   , STANCE_DEAD     , do_experience,0, 0, CMD_ANY },
  { "extinguish",POS_PRONE   , STANCE_RESTING  , do_light    , 0, SCMD_EXTINGUISH, 0 },
  { "eyebrow"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, CMD_HIDE },
  { "elist"    , POS_PRONE   , STANCE_DEAD     , do_esearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "enum"     , POS_PRONE   , STANCE_DEAD     , do_esearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "esearch"  , POS_PRONE   , STANCE_DEAD     , do_esearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "force"    , POS_PRONE   , STANCE_DEAD     , do_force    , LVL_ATTENDANT, 0, CMD_ANY },
  { "flee"     , POS_PRONE   , STANCE_RESTING  , do_flee     , 1, 0, CMD_CAST },
  { "fart"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "first aid", POS_PRONE   , STANCE_RESTING  , do_first_aid, 0, 0, 0 },
  { "fill"     , POS_STANDING, STANCE_ALERT    , do_pour     , 0, SCMD_FILL, 0 },
  { "flanic"   , POS_PRONE   , STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "flex"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "flip"     , POS_PRONE   , STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "flirt"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "fly"      , POS_PRONE   , STANCE_RESTING  , do_fly      , 0, 0, CMD_HIDE },
  { "follow"   , POS_PRONE   , STANCE_RESTING  , do_follow   , 0, SCMD_FOLLOW, 0 },
  { "fool"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "forget"   , POS_PRONE   , STANCE_RESTING  , do_forget   , 0, 0, CMD_MEDITATE },
  { "fondle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "freeze"   , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_FREEZE, SCMD_FREEZE, CMD_ANY },
  { "french"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "frown"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, CMD_HIDE },
  { "fume"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "get"      , POS_PRONE   , STANCE_RESTING  , do_get      , 0, 0, 0 },
  { "gag"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "gape"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "gasp"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "gecho"    , POS_PRONE   , STANCE_DEAD     , do_gecho    , LVL_GOD, 0, CMD_ANY },
  { "give"     , POS_PRONE   , STANCE_RESTING  , do_give     , 0, 0, 0 },
  { "giggle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "glance"   , POS_PRONE   , STANCE_RESTING  , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "glare"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "glomp"    , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "glower"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "goto"     , POS_PRONE   , STANCE_DEAD     , do_goto     , LVL_IMMORT, 0, CMD_ANY },
  { "go"       , POS_STANDING, STANCE_ALERT    , do_move     , 0, 0, CMD_HIDE | CMD_OLC },
  { "gossip"   , POS_PRONE   , STANCE_SLEEPING , do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP, CMD_MEDITATE | CMD_CAST | CMD_HIDE | CMD_OLC },
  { "gouge"    , POS_STANDING, STANCE_FIGHTING , do_eye_gouge, 1, 0, 0 },
  { "groan"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "group"    , POS_PRONE   , STANCE_SLEEPING , do_group    , 1, 0, CMD_HIDE | CMD_OLC },
  { "grab"     , POS_PRONE   , STANCE_RESTING  , do_grab     , 0, 0, 0 },
/*{ "grats"    , POS_PRONE   , STANCE_SLEEPING , do_gen_comm , LVL_GOD, SCMD_GRATZ, 0 },*/
  { "greport"  , POS_PRONE   , STANCE_SLEEPING , do_report   , 0, SCMD_GREPORT, CMD_ANY },
  { "greet"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "gretreat" , POS_STANDING, STANCE_FIGHTING , do_gretreat , 0, 0, 0 },
  { "grin"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "groan"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "grope"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "grovel"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "growl"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "grumble"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "gsay"     , POS_PRONE   , STANCE_SLEEPING , do_gsay     , 0, 0, CMD_ANY },
  { "gtell"    , POS_PRONE   , STANCE_SLEEPING , do_gsay     , 0, 0, CMD_ANY },
  { "guard"    , POS_STANDING, STANCE_ALERT    , do_guard    , 0, 0, 0 },

  { "help"     , POS_PRONE   , STANCE_DEAD     , do_help     , 0, 0, CMD_ANY },
  { "hedit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_GAMEMASTER, SCMD_OLC_HEDIT, 0 },
  { "handbook" , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK, CMD_ANY },
  { "halo"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "hcontrol" , POS_PRONE   , STANCE_DEAD     , do_hcontrol , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "hhroom"   , POS_PRONE   , STANCE_DEAD     , do_rclone   , LVL_BUILDER, 0, 0 },
  { "hi5"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "hiccup"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "hide"     , POS_STANDING, STANCE_ALERT    , do_hide     , 1, 0, CMD_HIDE },
  { "hiss"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "hit"      , POS_STANDING, STANCE_FIGHTING , do_hit      , 0, SCMD_HIT, 0 },
  { "hitall"   , POS_STANDING, STANCE_FIGHTING , do_hitall   , 0, SCMD_HITALL, 0 },
  { "hold"     , POS_PRONE   , STANCE_RESTING  , do_grab     , 1, 0, 0 },
  { "hop"      , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "hotboot"  , POS_PRONE   , STANCE_DEAD     , do_hotboot  , LVL_REBOOT_MASTER, 0, 0 },
  { "house"    , POS_PRONE   , STANCE_RESTING  , do_house    ,-1, 0, 0 },
  { "howl"     , POS_STANDING, STANCE_FIGHTING , do_roar     , 0, SCMD_HOWL, 0 },
  { "hunt"     , POS_STANDING, STANCE_ALERT    , do_hunt     ,-1, 0, 0 },
  { "hug"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "hunger"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "inventory", POS_PRONE   , STANCE_SLEEPING , do_inventory, 0, 0, CMD_ANY },
  { "identify" , POS_PRONE   , STANCE_RESTING  , do_identify , 0, 0, CMD_HIDE | CMD_OLC },
  { "idea"     , POS_PRONE   , STANCE_DEAD     , do_gen_write, 0, SCMD_IDEA, CMD_ANY },
  { "imitate"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "imotd"    , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD, CMD_ANY },
  { "immlist"  , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_IMMLIST, CMD_ANY },
  { "impale"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "innate"   , POS_PRONE   , STANCE_DEAD     , do_innate   , 0, 0, CMD_ANY },
  { "ignore"   , POS_PRONE   , STANCE_DEAD     , do_ignore   , 0, 0, CMD_ANY },
  { "info"     , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_INFO, CMD_ANY },
  { "insult"   , POS_PRONE   , STANCE_RESTING  , do_insult   , 0, 0, 0 },
  { "invis"    , POS_PRONE   , STANCE_DEAD     , do_invis    , LVL_IMMORT, 0, CMD_ANY },
  { "iptables" , POS_PRONE   , STANCE_DEAD     , do_iptables , LVL_ADMIN + 1, 0, CMD_ANY },
d609 1
a609 1
  { "ispell"   , POS_PRONE   , STANCE_DEAD     , do_ispell   , LVL_IMMORT, 0, CMD_ANY },
d612 1
a612 1
  { "junk"     , POS_PRONE   , STANCE_RESTING  , do_drop     , 0, SCMD_JUNK, 0 },
d614 332
a945 332
  { "kick"     , POS_STANDING, STANCE_FIGHTING , do_kick     , 1, 0, 0 },
  { "kill"     , POS_STANDING, STANCE_FIGHTING , do_kill     , 0, 0, 0 },
  { "kiss"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "kneel"    , POS_PRONE   , STANCE_RESTING  , do_kneel    , 0, 0, 0 },

  { "look"     , POS_PRONE   , STANCE_RESTING  , do_look     , 0, SCMD_LOOK, CMD_MINOR_PARA | CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST | CMD_OLC },
  { "lag"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "laugh"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "layhands" , POS_STANDING, STANCE_FIGHTING , do_layhand  , 0, 0, 0 },
  { "last"     , POS_PRONE   , STANCE_DEAD     , do_last     , LVL_GRGOD, 0, CMD_ANY },
  { "lean"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "leave"    , POS_STANDING, STANCE_ALERT    , do_leave    , 0, 0, 0 },
  { "level"    , POS_PRONE   , STANCE_DEAD     , do_level    , 0, 0, CMD_ANY },
  { "light"    , POS_PRONE   , STANCE_RESTING  , do_light    , 0, SCMD_LIGHT, 0 },
  { "list"     , POS_STANDING, STANCE_ALERT    , do_not_here , 0, 0, 0 },
  { "listspells",POS_PRONE   , STANCE_DEAD     , do_listspells,LVL_ATTENDANT, 0, CMD_ANY },
  { "lick"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "lock"     , POS_SITTING , STANCE_ALERT    , do_gen_door , 0, SCMD_LOCK, 0 },
  { "linkload" , POS_PRONE   , STANCE_DEAD     , do_linkload , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "load"     , POS_PRONE   , STANCE_DEAD     , do_load     , LVL_ATTENDANT, 0, CMD_ANY ^ CMD_OLC },
  { "love"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "memorize" , POS_PRONE   , STANCE_RESTING  , do_memorize , 0, 0, CMD_MEDITATE },
  { "maul"     , POS_STANDING, STANCE_FIGHTING , do_bash     , 1, SCMD_MAUL, 0 },
  { "moan"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "medit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT, 0 },
  { "motd"     , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_MOTD, CMD_ANY },
  { "mail"     , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, CMD_HIDE },
  { "massage"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "meditate" , POS_PRONE   , STANCE_RESTING  , do_meditate , 0, 0, CMD_MEDITATE },
  { "moon"     , POS_STANDING, STANCE_FIGHTING , do_action   , 0, 0, 0 },
  { "mosh"     , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "mount"    , POS_STANDING, STANCE_ALERT    , do_mount    , 0, 0, 0 },
  { "mourn"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "mumble"   , POS_PRONE   , STANCE_SLEEPING , do_action   , 0, 0, 0 },
  { "mute"     , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_GOD, SCMD_SQUELCH, CMD_ANY },
  { "mutter"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "murder"   , POS_STANDING, STANCE_FIGHTING , do_hit      , 0, SCMD_MURDER, 0 },
  { "mlist"    , POS_PRONE   , STANCE_DEAD     , do_msearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "mnum"     , POS_PRONE   , STANCE_DEAD     , do_msearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "msearch"  , POS_PRONE   , STANCE_DEAD     , do_msearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "mstat"    , POS_PRONE   , STANCE_DEAD     , do_vstat    , LVL_ATTENDANT, SCMD_MSTAT, CMD_ANY },

  { "nap"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "news"     , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_NEWS, CMD_ANY },
  { "nibble"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "nod"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "nog"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "noogie"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "notitle"  , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE, CMD_ANY },
  { "note"     , POS_PRONE   , STANCE_DEAD     , do_gen_write, LVL_IMMORT, SCMD_NOTES, CMD_ANY },
  { "nudge"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "nuzzle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "naccept"  , POS_PRONE   , STANCE_DEAD     , do_name     , LVL_IMMORT, SCMD_ACCEPT, CMD_ANY },
  { "ndecline" , POS_PRONE   , STANCE_DEAD     , do_name     , LVL_IMMORT, SCMD_DECLINE, CMD_ANY },
  { "nlist"    , POS_PRONE   , STANCE_DEAD     , do_name     , LVL_IMMORT, SCMD_LIST, CMD_ANY },

  { "order"    , POS_PRONE   , STANCE_RESTING  , do_order    , 1, 0, 0 },
  { "open"     , POS_SITTING , STANCE_ALERT    , do_gen_door , 0, SCMD_OPEN, 0 },
  { "olc"      , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_SAVEINFO, CMD_ANY },
  { "oedit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT, 0 },
  { "olist"    , POS_PRONE   , STANCE_DEAD     , do_osearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "onum"     , POS_PRONE   , STANCE_DEAD     , do_osearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "osearch"  , POS_PRONE   , STANCE_DEAD     , do_osearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ostat"    , POS_PRONE   , STANCE_DEAD     , do_vstat    , LVL_ATTENDANT, SCMD_OSTAT, CMD_ANY },

  { "put"      , POS_PRONE   , STANCE_RESTING  , do_put      , 0, 0, 0 },
  { "palm"     , POS_PRONE   , STANCE_RESTING  , do_palm     , 0, 0, CMD_HIDE },
  { "panic"    , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "pant"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "pat"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "page"     , POS_PRONE   , STANCE_DEAD     , do_page     , LVL_GOD, 0, CMD_ANY },
  { "pardon"   , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_OVERLORD, SCMD_PARDON, CMD_ANY },
  { "peace"    , POS_PRONE   , STANCE_DEAD     , do_peace    , LVL_GRGOD, 0, CMD_ANY },
  { "peck"     , POS_STANDING, STANCE_FIGHTING , do_peck     , 1, 0, 0 },
  { "peer"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "pet"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "petition" , POS_PRONE   , STANCE_DEAD     , do_petition , 0, 0, CMD_ANY },
  { "pfilemaint", POS_PRONE  , STANCE_DEAD     , do_pfilemaint, LVL_OVERLORD, 0, 0 },
  { "pick"     , POS_STANDING, STANCE_ALERT    , do_gen_door , 1, SCMD_PICK, CMD_HIDE },
  { "players"  , POS_PRONE   , STANCE_DEAD     , do_players  , LVL_HEAD_C, 0, CMD_ANY },
  { "point"    , POS_PRONE   , STANCE_RESTING  , do_point    , 0, 0, 0 },
  { "poke"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "policy"   , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_POLICIES, CMD_ANY },
  { "ponder"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "poofin"   , POS_PRONE   , STANCE_DEAD     , do_poofset  , LVL_IMMORT, SCMD_POOFIN, CMD_ANY },
  { "poofout"  , POS_PRONE   , STANCE_DEAD     , do_poofset  , LVL_IMMORT, SCMD_POOFOUT, CMD_ANY },
  { "pounce"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "pour"     , POS_STANDING, STANCE_ALERT    , do_pour     , 0, SCMD_POUR, 0 },
  { "pout"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "prompt"   , POS_PRONE   , STANCE_DEAD     , do_prompt   , 0, 0, CMD_ANY },
  { "protect"  , POS_STANDING, STANCE_FIGHTING , do_action   , 0, 0, 0 },
  { "pray"     , POS_PRONE   , STANCE_RESTING  , do_pray     , 0, 0, CMD_MEDITATE },
  { "pscan"    , POS_PRONE   , STANCE_DEAD     , do_pscan    , LVL_GRGOD, 0, CMD_ANY},
  { "ptell"    , POS_PRONE   , STANCE_DEAD     , do_ptell    , LVL_IMMORT, 0, CMD_ANY },
  { "puke"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "punch"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "purr"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "purge"    , POS_PRONE   , STANCE_DEAD     , do_purge    , LVL_PURGE, 0, CMD_ANY },

  { "quaff"    , POS_PRONE   , STANCE_RESTING  , do_use      , 0, SCMD_QUAFF, 0 },
  { "qecho"    , POS_PRONE   , STANCE_DEAD     , do_qcomm    , LVL_IMMORT, SCMD_QECHO, CMD_ANY },
  { "qui"      , POS_PRONE   , STANCE_DEAD     , do_quit     ,-1, 0, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "quit"     , POS_PRONE   , STANCE_DEAD     , do_quit     , 0, SCMD_QUIT, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "qsay"     , POS_PRONE   , STANCE_RESTING  , do_qcomm    , 0, SCMD_QSAY, CMD_ANY },

  { "rest"     , POS_PRONE   , STANCE_RESTING  , do_rest     , 0, 0, CMD_MEDITATE },
  { "raise"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "report"   , POS_PRONE   , STANCE_RESTING  , do_report   , 0, SCMD_REPORT, 0 },
  { "reply"    , POS_PRONE   , STANCE_SLEEPING , do_reply    , 0, 0, CMD_ANY },
  { "read"     , POS_PRONE   , STANCE_RESTING  , do_look     , 0, SCMD_READ, 0 },
  { "reload"   , POS_PRONE   , STANCE_DEAD     , do_reload   , LVL_HEAD_C, 0, 0 },
  { "recite"   , POS_PRONE   , STANCE_RESTING  , do_use      , 0, SCMD_RECITE, 0 },
  { "receive"  , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "recline"  , POS_PRONE   , STANCE_RESTING  , do_recline  , 0, 0, 0 },
  { "remove"   , POS_PRONE   , STANCE_RESTING  , do_remove   , 0, 0, 0 },
  { "rent"     , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "reroll"   , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_GRGOD, SCMD_REROLL, 0 },
  { "rescue"   , POS_STANDING, STANCE_FIGHTING , do_rescue   , 0, 0, 0 },
/*{ "readlist" , POS_PRONE   , STANCE_DEAD     , do_readlist , LVL_GOD, 0, 0 },*/
  { "restore"  , POS_PRONE   , STANCE_DEAD     , do_restore  , LVL_RESTORE, 0, CMD_OLC },
  { "rrestore" , POS_PRONE   , STANCE_DEAD     , do_rrestore , LVL_RESTORE, 0, CMD_OLC },
  { "pain"     , POS_PRONE   , STANCE_DEAD     , do_pain     , LVL_RESTORE, 0, CMD_OLC },
  { "rpain"    , POS_PRONE   , STANCE_DEAD     , do_rpain    , LVL_RESTORE, 0, CMD_OLC },
  { "retreat"  , POS_STANDING, STANCE_FIGHTING , do_retreat  , 0, 0, 0 },
  { "return"   , POS_PRONE   , STANCE_DEAD     , do_return   ,-1, 0, CMD_MINOR_PARA | CMD_MAJOR_PARA | CMD_BOUND },
  { "redit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT, 0 },
  { "rename"   , POS_PRONE   , STANCE_DEAD     , do_rename   , LVL_GRGOD, 0, 0 },
  { "roar"     , POS_STANDING, STANCE_FIGHTING , do_roar     , 0, SCMD_ROAR, 0 },
  { "rofl"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "roll"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "ready"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "ruffle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "rlist"    , POS_PRONE   , STANCE_DEAD     , do_rsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "rnum"     , POS_PRONE   , STANCE_DEAD     , do_rsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "rsearch"  , POS_PRONE   , STANCE_DEAD     , do_rsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "rstat"    , POS_PRONE   , STANCE_DEAD     , do_stat     , LVL_ATTENDANT, SCMD_RSTAT, CMD_ANY },
  { "sstat"    , POS_PRONE   , STANCE_DEAD     , do_stat     , LVL_ATTENDANT, SCMD_SSTAT, CMD_ANY },
  { "rsdiamimp", POS_PRONE   , STANCE_DEAD     , do_rsdiamimp,-1, 0, 0 },

  { "say"      , POS_PRONE   , STANCE_RESTING  , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "'"        , POS_PRONE   , STANCE_RESTING  , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "save"     , POS_PRONE   , STANCE_SLEEPING , do_save     , LVL_GOD, 0 , CMD_ANY ^ CMD_CAST },
  { "score"    , POS_PRONE   , STANCE_DEAD     , do_score    , 0, 0, CMD_ANY },
  { "scan"     , POS_STANDING, STANCE_ALERT    , do_scan     , 0, 0, 0 },
  { "salute"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "scribe"   , POS_PRONE   , STANCE_RESTING  , do_scribe   , 0, 0, 0 },
  { "scare"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "scold"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "scratch"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "scream"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "screw"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sdedit"   , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_HEAD_C, SCMD_OLC_SDEDIT, 0 },
  { "sell"     , POS_STANDING, STANCE_ALERT    , do_not_here , 0, 0, 0 },
  { "send"     , POS_PRONE   , STANCE_DEAD     , do_send     , LVL_GRGOD, 0, CMD_ANY },
  { "set"      , POS_PRONE   , STANCE_DEAD     , do_set      , LVL_GOD, 0, CMD_ANY },
  { "search"   , POS_STANDING, STANCE_ALERT    , do_search   , 0, 0, 0 },
  { "sedit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT, 0 },
  { "seduce"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "shout"    , POS_PRONE   , STANCE_RESTING  , do_gen_comm , 0, SCMD_SHOUT, CMD_OLC },
  { "shake"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "shadow"   , POS_PRONE   , STANCE_RESTING  , do_follow   , 0, SCMD_SHADOW, CMD_HIDE },
  { "shapechange",POS_STANDING, STANCE_ALERT    , do_shapechange, 0, 0, 0 },
  { "shiver"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "show"     , POS_PRONE   , STANCE_DEAD     , do_show     , LVL_IMMORT, 0, CMD_ANY },
  { "shrug"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "shudder"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "shutdow"  , POS_PRONE   , STANCE_DEAD     , do_shutdown , LVL_REBOOT_MASTER, 0, 0 },
  { "shutdown" , POS_PRONE   , STANCE_DEAD     , do_shutdown , LVL_REBOOT_MASTER, SCMD_SHUTDOWN, 0 },
  { "sigh"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sing"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sip"      , POS_PRONE   , STANCE_RESTING  , do_drink    , 0, SCMD_SIP, 0 },
  { "sit"      , POS_PRONE   , STANCE_RESTING  , do_sit      , 0, 0, 0 },
  { "skills"   , POS_PRONE   , STANCE_SLEEPING , do_skills   , 1, 0, CMD_ANY },
  { "skillset" , POS_PRONE   , STANCE_DEAD     , do_skillset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "slist"    , POS_PRONE   , STANCE_DEAD     , do_ssearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "snum"     , POS_PRONE   , STANCE_DEAD     , do_ssearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "ssearch"  , POS_PRONE   , STANCE_DEAD     , do_ssearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "sleep"    , POS_PRONE   , STANCE_SLEEPING , do_sleep    , 0, 0, 0 },
  { "slap"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "slobber"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "smell"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "smile"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "smirk"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "smoke"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snicker"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snap"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snarl"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sneeze"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sniff"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snoogie"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snore"    , POS_PRONE   , STANCE_SLEEPING , do_action   , 0, 0, 0 },
  { "snort"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "snowball" , POS_STANDING, STANCE_ALERT    , do_action   , LVL_OVERLORD, 0, 0 },
  { "snoop"    , POS_PRONE   , STANCE_DEAD     , do_snoop    , LVL_HEAD_B, 0, 0 },
  { "snuggle"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "songs"    , POS_PRONE   , STANCE_DEAD     , do_songs    , 0, 0, CMD_ANY },
  { "socials"  , POS_PRONE   , STANCE_DEAD     , do_commands , 0, SCMD_SOCIALS, CMD_ANY },
  { "spam"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "split"    , POS_PRONE   , STANCE_RESTING  , do_split    , 1, 0, 0 },
  { "spells"   , POS_PRONE   , STANCE_DEAD     , do_spells   , 1, 0, CMD_ANY },
  { "spank"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "spit"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "springleap",POS_PRONE   , STANCE_RESTING  , do_springleap, 0, 0, 0 },
  { "squeeze"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "stand"    , POS_PRONE   , STANCE_RESTING  , do_stand    , 0, 0, 0 },
  { "stare"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "stat"     , POS_PRONE   , STANCE_DEAD     , do_stat     , LVL_ATTENDANT, SCMD_STAT, CMD_ANY },
  { "stay"     , POS_PRONE   , STANCE_RESTING  , do_move     , 0, SCMD_STAY  , CMD_HIDE | CMD_OLC },
  { "steal"    , POS_STANDING, STANCE_ALERT    , do_steal    , 1, 0, CMD_HIDE },
  { "steam"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "stow"     , POS_PRONE   , STANCE_RESTING  , do_stow     , 0, 0, CMD_HIDE },
  { "stomp"    , POS_STANDING, STANCE_FIGHTING , do_stomp    , 0, 0, 0 },
  { "stroke"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "strut"    , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "sulk"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "summon"   , POS_STANDING, STANCE_ALERT    , do_summon_mount, 0, 0, 0 },
  { "swat"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sweat"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "sweep"    , POS_STANDING, STANCE_FIGHTING , do_sweep    ,-1, 0, 0 },
  { "switch"   , POS_PRONE   , STANCE_DEAD     , do_switch   , LVL_GOD, 0, CMD_ANY ^ CMD_OLC },
  { "syslog"   , POS_PRONE   , STANCE_DEAD     , do_syslog   , LVL_ATTENDANT, 0, CMD_ANY },
  { "stone"    , POS_STANDING, STANCE_ALERT    , do_not_here ,-1, 0, 0 },
  { "subclass" , POS_PRONE   , STANCE_RESTING  , do_subclass , 0, 0, CMD_HIDE },

  { "tell"     , POS_PRONE   , STANCE_SLEEPING , do_tell     , 0, 0, CMD_ANY },
  { "terminate", POS_PRONE   , STANCE_DEAD     , do_terminate, LVL_HEAD_C, 0, 0 },
  { "tackle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "take"     , POS_STANDING, STANCE_FIGHTING , do_get      , 0, 0, 0 },
  { "tantrum"  , POS_STANDING, STANCE_FIGHTING , do_hitall   , 0, SCMD_TANTRUM, 0 },
  { "tango"    , POS_STANDING, STANCE_ALERT    , do_action   , 0, 0, 0 },
  { "tame"     , POS_STANDING, STANCE_ALERT    , do_tame     , 0, 0, 0 },
  { "tap"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "tarzan"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "taunt"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "taste"    , POS_PRONE   , STANCE_RESTING  , do_eat      , 0, SCMD_TASTE, 0 },
  { "tease"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "tedit"    , POS_PRONE   , STANCE_DEAD     , do_tedit    , LVL_HEAD_C, 0, 0 },
  { "teleport" , POS_PRONE   , STANCE_DEAD     , do_teleport , LVL_GOD, 0, CMD_ANY },
  { "thank"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "think"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "thaw"     , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_FREEZE, SCMD_THAW, CMD_ANY },
  { "thirst"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "throatcut", POS_STANDING, STANCE_ALERT    , do_throatcut, 0, 0, 0 },
  { "throw"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "tip"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "title"    , POS_PRONE   , STANCE_DEAD     , do_title    , 1, 0, CMD_ANY },
  { "tickle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "time"     , POS_PRONE   , STANCE_DEAD     , do_time     , 0, 0, CMD_ANY },
  { "tip"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "toggle"   , POS_PRONE   , STANCE_DEAD     , do_toggle   , 0, 0, CMD_ANY ^ CMD_CAST },
  { "tongue"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "touch"    , POS_PRONE   , STANCE_RESTING  , do_touch    , 0, 0, 0 },
  { "track"    , POS_STANDING, STANCE_ALERT    , do_track    , 0, 0, 0 },
  { "transfer" , POS_PRONE   , STANCE_DEAD     , do_trans    , LVL_GOD, 0, CMD_ANY },
  { "trigedit" , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT, 0 },
  { "trip"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "trophy"   , POS_PRONE   , STANCE_DEAD     , do_trophy   , 0, 0, CMD_ANY },
  { "tug"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "twibble"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "twiddle"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "twitch"   , POS_PRONE   , STANCE_SLEEPING , do_action   , 0, 0, 0 },
  { "typo"     , POS_PRONE   , STANCE_DEAD     , do_gen_write, 0, SCMD_TYPO , CMD_ANY },

  { "unlock"   , POS_SITTING , STANCE_ALERT    , do_gen_door , 0, SCMD_UNLOCK, 0 },
  { "unban"    , POS_PRONE   , STANCE_DEAD     , do_unban    , LVL_GRGOD, 0, CMD_ANY },
/*{ "unbind"   , POS_PRONE   , STANCE_DEAD     , do_unbind   ,-1, 0, CMD_HIDE },*/
  { "use"      , POS_SITTING , STANCE_ALERT    , do_use      , 1, SCMD_USE, 0 },
  { "unaffect" , POS_PRONE   , STANCE_DEAD     , do_wizutil  , LVL_ATTENDANT, SCMD_UNAFFECT, CMD_ANY },
  { "users"    , POS_PRONE   , STANCE_DEAD     , do_users    , LVL_ATTENDANT, 0, CMD_ANY },
  { "uptime"   , POS_PRONE   , STANCE_DEAD     , do_date     , 0, SCMD_UPTIME, CMD_ANY },

  { "value"    , POS_STANDING, STANCE_ALERT    , do_not_here , 0, 0, CMD_HIDE },
  { "varset"   , POS_PRONE   , STANCE_DEAD     , do_varset   , LVL_GAMEMASTER, 0, CMD_ANY },
  { "varunset" , POS_PRONE   , STANCE_DEAD     , do_varunset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "version"  , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_VERSION, CMD_ANY },
  { "veto"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "visible"  , POS_PRONE   , STANCE_RESTING  , do_visible  , 1, 0, CMD_HIDE },
  { "viewdam"  , POS_PRONE   , STANCE_DEAD     , do_viewdam  , LVL_GRGOD, 0, CMD_ANY },
  { "vnum"     , POS_PRONE   , STANCE_DEAD     , do_vsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "vlist"    , POS_PRONE   , STANCE_DEAD     , do_vsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "vsearch"  , POS_PRONE   , STANCE_DEAD     , do_vsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "vstat"    , POS_PRONE   , STANCE_DEAD     , do_vstat    , LVL_ATTENDANT, SCMD_VSTAT, CMD_ANY },
  { "zstat"    , POS_PRONE   , STANCE_DEAD     , do_zstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "estat"    , POS_PRONE   , STANCE_DEAD     , do_estat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "oestat"   , POS_PRONE   , STANCE_DEAD     , do_estat    , LVL_ATTENDANT, SCMD_OESTAT, CMD_ANY },
  { "restat"   , POS_PRONE   , STANCE_DEAD     , do_estat    , LVL_ATTENDANT, SCMD_RESTAT, CMD_ANY },
  { "vitem"    , POS_PRONE   , STANCE_DEAD     , do_vitem    , LVL_ATTENDANT, 0, CMD_ANY },
  { "vwear"    , POS_PRONE   , STANCE_DEAD     , do_vwear    , LVL_ATTENDANT, 0, CMD_ANY },

  { "wake"     , POS_PRONE   , STANCE_SLEEPING , do_wake     , 0, 0, 0 },
  { "walk"     , POS_STANDING, STANCE_ALERT    , do_move     , 0, 0, CMD_HIDE },
  { "wave"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "wear"     , POS_PRONE   , STANCE_RESTING  , do_wear     , 0, 0, 0 },
  { "wait"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "weather"  , POS_PRONE   , STANCE_RESTING  , do_weather  , 0, 0, CMD_ANY },
  { "wet"      , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "who"      , POS_PRONE   , STANCE_DEAD     , do_who      , 0, 0, CMD_ANY },
  { "whap"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "whatever" , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "whoami"   , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_WHOAMI, CMD_ANY },
  { "where"    , POS_PRONE   , STANCE_DEAD     , do_where    , LVL_ATTENDANT, 0, CMD_ANY },
  { "whisper"  , POS_PRONE   , STANCE_RESTING  , do_spec_comm, 0, SCMD_WHISPER, CMD_OLC },
  { "whine"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "whistle"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "wield"    , POS_PRONE   , STANCE_RESTING  , do_wield    , 0, 0, 0 },
  { "wiggle"   , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "wince"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "wink"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "withdraw" , POS_STANDING, STANCE_ALERT    , do_not_here , 1, 0, 0 },
  { "wiznet"   , POS_PRONE   , STANCE_DEAD     , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { ";"        , POS_PRONE   , STANCE_DEAD     , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { "wizhelp"  , POS_PRONE   , STANCE_DEAD     , do_commands , LVL_IMMORT, SCMD_WIZHELP, CMD_ANY },
  { "wizlist"  , POS_PRONE   , STANCE_DEAD     , do_gen_ps   , 0, SCMD_WIZLIST, CMD_ANY },
  { "wizlock"  , POS_PRONE   , STANCE_DEAD     , do_wizlock  , LVL_HEAD_B, 0, 0 },
  { "worship"  , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "write"    , POS_STANDING, STANCE_ALERT    , do_write    , 3, 0, 0 },

  { "yawn"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "yodel"    , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },

  { "zone"     , POS_PRONE   , STANCE_RESTING  , do_action   , 0, 0, 0 },
  { "zedit"    , POS_PRONE   , STANCE_DEAD     , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT, 0 },
  { "zlist"    , POS_PRONE   , STANCE_DEAD     , do_zsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "znum"     , POS_PRONE   , STANCE_DEAD     , do_zsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "zreset"   , POS_PRONE   , STANCE_DEAD     , do_zreset   , LVL_ATTENDANT, 0, CMD_ANY },
  { "zsearch"  , POS_PRONE   , STANCE_DEAD     , do_zsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "game"     , POS_PRONE   , STANCE_DEAD     , do_game     , LVL_ATTENDANT, 0, CMD_ANY },
  { "world"    , POS_PRONE   , STANCE_DEAD     , do_world    , 0, 0, CMD_ANY },
  { "fup"      , POS_STANDING, STANCE_ALERT    , do_move     ,-1, SCMD_FUP, CMD_HIDE },
  { "fdown"    , POS_STANDING, STANCE_ALERT    , do_move     ,-1, SCMD_FDOWN, CMD_HIDE },
d948 31
a978 33
  { "attach"   , POS_PRONE   , STANCE_DEAD     , do_attach   , LVL_IMPL, 0, 0 },
  { "z001#@@#"  , POS_PRONE   , STANCE_SLEEPING , do_action   ,-1, 0, 0 },
  { "detach"   , POS_PRONE   , STANCE_DEAD     , do_detach   , LVL_IMPL, 0, 0 },
  { "tlist"    , POS_PRONE   , STANCE_DEAD     , do_tsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "tnum"     , POS_PRONE   , STANCE_DEAD     , do_tsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "tsearch"  , POS_PRONE   , STANCE_DEAD     , do_tsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "tstat"    , POS_PRONE   , STANCE_DEAD     , do_tstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "log"      , POS_PRONE   , STANCE_DEAD     , do_mob_log  ,-1, 0, CMD_ANY },
  { "m_run_room_trig", POS_PRONE, STANCE_DEAD  ,do_m_run_room_trig, -1, 0, CMD_ANY },
  { "masound"  , POS_PRONE   , STANCE_DEAD     , do_masound  ,-1, 0, CMD_ANY },
  { "mat"      , POS_PRONE   , STANCE_DEAD     , do_mat      ,-1, 0, CMD_ANY },
  { "mdamage"  , POS_PRONE   , STANCE_DEAD     , do_mdamage  ,-1, 0, CMD_HIDE },
  { "mecho"    , POS_PRONE   , STANCE_DEAD     , do_mecho    ,-1, 0, CMD_ANY },
  { "mechoaround",POS_PRONE  , STANCE_DEAD     , do_mechoaround,-1, 0, CMD_ANY },
  { "mexp"     , POS_PRONE   , STANCE_DEAD     , do_mexp     ,-1, 0, CMD_ANY },
  { "mforce"   , POS_PRONE   , STANCE_DEAD     , do_mforce   ,-1, 0, CMD_ANY },
  { "mgoto"    , POS_PRONE   , STANCE_DEAD     , do_mgoto    ,-1, 0, CMD_HIDE },
  { "mjunk"    , POS_PRONE   , STANCE_DEAD     , do_mjunk    ,-1, 0, CMD_ANY },
  { "mkill"    , POS_STANDING, STANCE_ALERT    , do_mkill    ,-1, 0, 0 },
  { "mload"    , POS_PRONE   , STANCE_DEAD     , do_mload    ,-1, 0, CMD_ANY },
  { "mpurge"   , POS_PRONE   , STANCE_DEAD     , do_mpurge   ,-1, 0, CMD_ANY },
  { "msave"    , POS_PRONE   , STANCE_DEAD     , do_msave    ,-1, 0, CMD_ANY },
  { "msend"    , POS_PRONE   , STANCE_DEAD     , do_msend    ,-1, 0, CMD_ANY },
  { "mskillset", POS_PRONE   , STANCE_DEAD     , do_mskillset,-1, 0, CMD_ANY },
  { "mteleport", POS_PRONE   , STANCE_DEAD     , do_mteleport,-1, 0, CMD_ANY },
  { "quest"    , POS_PRONE   , STANCE_DEAD     , do_quest    ,-1, 0, CMD_ANY },
  { "qadd"     , POS_PRONE   , STANCE_DEAD     , do_qadd     , LVL_HEAD_B, 0, CMD_ANY },
  { "qdel"     , POS_PRONE   , STANCE_DEAD     , do_qdel     , LVL_HEAD_B, 0, CMD_ANY },
  { "qlist"    , POS_PRONE   , STANCE_DEAD     , do_qlist    , LVL_ATTENDANT, 0, CMD_ANY },
  { "qstat"    , POS_PRONE   , STANCE_DEAD     , do_qstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "objfix"   , POS_PRONE   , STANCE_DEAD     , do_objfix   , LVL_HEAD_C, 0, CMD_ANY },

  { "\n", 0, 0, 0, 0 , CMD_HIDE } };        /* this must be last */
d980 1
d1108 1
a1108 1
  else if (GET_STANCE(ch) == STANCE_FIGHTING && cmd_info[cmd].minimum_position == POS_STANDING)
d3124 4
@


1.268
log
@Adding worship social back in.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.267 2008/04/05 16:38:56 jps Exp myc $
d381 1
a381 1
  /* Name      , min position, ACMD,         min level, sub cmd, flags */
d383 6
a388 6
  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH , CMD_HIDE | CMD_OLC },
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST  , CMD_HIDE | CMD_OLC },
  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH , CMD_HIDE | CMD_OLC },
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST  , CMD_HIDE | CMD_OLC },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP    , CMD_HIDE | CMD_OLC },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN  , CMD_HIDE | CMD_OLC },
d391 215
a605 216
  { "at"       , POS_DEAD    , do_at       , LVL_ATTENDANT - 1, 0, CMD_ANY },
  { "abort"    , POS_DEAD    , do_abort    , 0, 0, CMD_ANY ^ CMD_BOUND },
  { "ack"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "advance"  , POS_DEAD    , do_advance  , LVL_ADMIN, 0, CMD_ANY },
  { "aggr"     , POS_DEAD    , do_aggr     , 0, 0, 0 },
  { "alert"    , POS_RESTING , do_alert    , 0, 0, CMD_CAST },
  { "alias"    , POS_DEAD    , do_alias    , 0, 0, CMD_MEDITATE | CMD_HIDE },
  { "accuse"   , POS_SITTING , do_action   , 0, 0, 0 },
  { "afk"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "agree"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "amaze"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "anews"    , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_ANEWS, CMD_ANY },
  { "apologize", POS_RESTING , do_action   , 0, 0, 0 },
  { "applaud"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "appear"   , POS_STANDING, do_not_here ,-1, 0, 0 },
  { "assist"   , POS_FIGHTING, do_assist   , 1, 0, 0 },
  { "ask"      , POS_RESTING , do_spec_comm, 0, SCMD_ASK, CMD_OLC },
  { "autoboot" , POS_DEAD    , do_autoboot,  LVL_REBOOT_VIEW, 0, CMD_ANY },
/*{ "auction"  , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_AUCTION, 0 },*/
  { "ayt"      , POS_RESTING , do_action   , 0, 0, 0 },

  { "backstab" , POS_FIGHTING, do_backstab , 1, 0, 0 },
  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0, CMD_ANY },
  { "bandage"  , POS_STANDING, do_bandage  , 1, 0, 0 },
  { "balance"  , POS_STANDING, do_not_here , 1, 0, 0 },
  { "bang"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "bark"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "bash"     , POS_FIGHTING, do_bash     , 1, SCMD_BASH, 0 },
/*{ "bind"     , POS_STANDING, do_bind     ,-1, 0, 0 },*/
  { "bodyslam" , POS_FIGHTING, do_bash     , 1, SCMD_BODYSLAM, 0 },
  { "beckon"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "beer"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "beg"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "berserk"  , POS_FIGHTING, do_berserk  , 0, 0, 0 },
  { "bite"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "bird"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "blink"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "bleed"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "blush"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "boggle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "bonk"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "bored"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "bounce"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "bow"      , POS_STANDING, do_action   , 0, 0, 0 },
  { "brb"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "breathe"  , POS_FIGHTING, do_breathe  ,-1, 0, 0 },
  { "buck"     , POS_STANDING, do_buck     , 0, 0, 0 },
  { "burp"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "buy"      , POS_STANDING, do_not_here , 0, 0, 0 },
  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG, CMD_ANY },
  { "bye"      , POS_RESTING , do_action   , 0, 0, 0 },

  { "cast"     , POS_SITTING , do_cast     , 1, SCMD_CAST, 0},
  { "cackle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "camp"     , POS_STANDING, do_camp     , 1, 0, 0 },
  { "chant"    , POS_FIGHTING, do_cast     , 0, SCMD_CHANT, 0 },
  { "chuckle"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "check"    , POS_STANDING, do_not_here , 1, 0, 0 },
  { "cheer"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "choke"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "clan"     , POS_SLEEPING, do_clan     , 1, 0, CMD_MEDITATE },
  { "clap"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "claw"     , POS_FIGHTING, do_claw     , 1, 0, 0 },
/*{ "circle"   , POS_FIGHTING, do_circle   , 1, 0, 0 },*/
  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "close"    , POS_SITTING , do_gen_door , 0, SCMD_CLOSE, 0 },
  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR, CMD_ANY },
  { "consider" , POS_RESTING , do_consider , 0, 0, 0 },
  { "color"    , POS_DEAD    , do_color    , 0, 0, CMD_ANY },
  { "compare"  , POS_RESTING , do_compare  , 0, 0, CMD_MEDITATE },
  { "comfort"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "comb"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS, CMD_ANY },
  { "consent"  , POS_INCAP   , do_consent  , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_CAST | CMD_OLC },
  { "conceal"  , POS_STANDING, do_conceal  , 0, 0, CMD_HIDE },
  { "corner"   , POS_FIGHTING, do_corner   , 0, 0, 0 },
  { "cough"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "credits"  , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS, CMD_ANY },
  { "cringe"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "cry"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "clist"    , POS_DEAD    , do_csearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "csearch"  , POS_DEAD    , do_csearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ctell"    , POS_SLEEPING, do_ctell    , 0, 0, CMD_ANY },
  { "cuddle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "curse"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "curtsey"  , POS_STANDING, do_action   , 0, 0, 0 },

  { "dance"    , POS_STANDING, do_action   , 0, 0, 0 },
  { "date"     , POS_DEAD    , do_date     , 0, SCMD_DATE, CMD_ANY },
  { "daydream" , POS_RESTING , do_action   , 0, 0, 0 },
  { "dc"       , POS_DEAD    , do_dc       , LVL_ATTENDANT, 0, CMD_ANY },
  { "deposit"  , POS_STANDING, do_not_here , 1, 0, 0 },
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "dismount" , POS_STANDING, do_dismount , 0, 0, 0 },
  { "display"  , POS_DEAD    , do_display  , 0, 0, CMD_ANY },
  { "disband"  , POS_SLEEPING, do_disband  , 1, 0, 0 },
  { "dig"      , POS_DEAD    , do_dig      , LVL_BUILDER, 0, CMD_ANY ^ CMD_OLC },
  { "disappear", POS_STANDING, do_not_here ,-1, 0, 0 },
  { "disarm"   , POS_FIGHTING, do_disarm   , 0, 0, 0 },
  { "disengage", POS_FIGHTING, do_disengage, 0, 0, CMD_CAST },
  { "disembark", POS_STANDING, do_disembark,-1, 0, 0 },
  { "doorbash" , POS_STANDING, do_doorbash , 0, 0, 0 },
  { "douse"    , POS_STANDING, do_douse    , 0, 0, 0 },
  { "drag"     , POS_STANDING, do_drag     , 1, 0, 0 },
  { "dream"    , POS_SLEEPING , do_action  , 0, 0, 0 },
  { "drink"    , POS_RESTING , do_drink    , 0, SCMD_DRINK, 0 },
  { "drop"     , POS_RESTING , do_drop     , 0, SCMD_DROP, 0 },
  { "drool"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "duck"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "duh"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "dump"     , POS_STANDING, do_not_here , 1, 0, 0 },

  { "eat"      , POS_RESTING , do_eat      , 0, SCMD_EAT, 0 },
  { "echo"     , POS_DEAD    , do_echo     , LVL_IMMORT, SCMD_ECHO, CMD_ANY },
  { "electrify", POS_FIGHTING, do_electrify, 1, 0, 0 },
  { "emote"    , POS_RESTING , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { ":"        , POS_RESTING , do_echo     , 1, SCMD_EMOTE, CMD_OLC },
  { "embrace"  , POS_STANDING, do_action   , 0, 0, 0 },
  { "enter"    , POS_STANDING, do_enter    , 0, 0, 0 },
  { "envy"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "equipment", POS_SLEEPING, do_equipment, 0, 0, CMD_ANY },
  { "exits"    , POS_RESTING , do_exits    , 0, 0, CMD_HIDE | CMD_MEDITATE | CMD_OLC },
  { "examine"  , POS_RESTING , do_examine  , 0, 0, CMD_HIDE | CMD_OLC },
  { "exchange" , POS_STANDING, do_not_here , 1, 0, 0 },
  { "experience",POS_DEAD    , do_experience,0, 0, CMD_ANY },
  { "extinguish",POS_RESTING , do_light    , 0, SCMD_EXTINGUISH, 0 },
  { "eyebrow"  , POS_RESTING , do_action   , 0, 0, CMD_HIDE },
  { "elist"    , POS_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "enum"     , POS_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "esearch"  , POS_DEAD    , do_esearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "force"    , POS_DEAD    , do_force    , LVL_ATTENDANT, 0, CMD_ANY },
  { "flee"     , POS_RESTING , do_flee     , 1, 0, CMD_CAST },
  { "fart"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "first aid", POS_RESTING , do_first_aid, 0, 0, 0 },
  { "fill"     , POS_STANDING, do_pour     , 0, SCMD_FILL, 0 },
  { "flanic"   , POS_STANDING, do_action   , 0, 0, 0 },
  { "flex"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "flip"     , POS_STANDING, do_action   , 0, 0, 0 },
  { "flirt"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "fly"      , POS_STANDING, do_fly      , 0, 0, CMD_HIDE },
  { "follow"   , POS_RESTING , do_follow   , 0, SCMD_FOLLOW, 0 },
  { "fool"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "forget"   , POS_RESTING , do_forget   , 0, 0, CMD_MEDITATE },
  { "fondle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "freeze"   , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE, CMD_ANY },
  { "french"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "frown"    , POS_RESTING , do_action   , 0, 0, CMD_HIDE },
  { "fume"     , POS_RESTING , do_action   , 0, 0, 0 },

  { "get"      , POS_RESTING , do_get      , 0, 0, 0 },
  { "gag"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "gape"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "gasp"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "gecho"    , POS_DEAD    , do_gecho    , LVL_GOD, 0, CMD_ANY },
  { "give"     , POS_RESTING , do_give     , 0, 0, 0 },
  { "giggle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "glance"   , POS_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_OLC },
  { "glare"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "glomp"    , POS_STANDING, do_action   , 0, 0, 0 },
  { "glower"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "goto"     , POS_DEAD    , do_goto     , LVL_IMMORT, 0, CMD_ANY },
  { "go"       , POS_STANDING, do_move     , 0, 0, CMD_HIDE | CMD_OLC },
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP, CMD_MEDITATE | CMD_CAST | CMD_HIDE | CMD_OLC },
  { "gouge"    , POS_FIGHTING, do_eye_gouge, 1, 0, 0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "group"    , POS_SLEEPING, do_group    , 1, 0, CMD_HIDE | CMD_OLC },
  { "grab"     , POS_RESTING , do_grab     , 0, 0, 0 },
/*{ "grats"    , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GRATZ, 0 },*/
  { "greport"  , POS_SLEEPING, do_report   , 0, SCMD_GREPORT, CMD_ANY },
  { "greet"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "gretreat" , POS_FIGHTING, do_gretreat , 0, 0, 0 },
  { "grin"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "grope"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "grovel"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "growl"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "grumble"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "gsay"     , POS_SLEEPING, do_gsay     , 0, 0, CMD_ANY },
  { "gtell"    , POS_SLEEPING, do_gsay     , 0, 0, CMD_ANY },
  { "guard"    , POS_STANDING, do_guard    , 0, 0, 0 },

  { "help"     , POS_DEAD    , do_help     , 0, 0, CMD_ANY },
  { "hedit"    , POS_DEAD    , do_olc      , LVL_GAMEMASTER, SCMD_OLC_HEDIT, 0 },
  { "handbook" , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK, CMD_ANY },
  { "halo"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "hhroom"   , POS_DEAD    , do_rclone   , LVL_BUILDER, 0, 0 },
  { "hi5"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "hiccup"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "hide"     , POS_STANDING, do_hide     , 1, 0, CMD_HIDE },
  { "hiss"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "hit"      , POS_FIGHTING, do_hit      , 0, SCMD_HIT, 0 },
  { "hitall"   , POS_FIGHTING, do_hitall   , 0, SCMD_HITALL, 0 },
  { "hold"     , POS_RESTING , do_grab     , 1, 0, 0 },
  { "hop"      , POS_STANDING, do_action   , 0, 0, 0 },
  { "hotboot"  , POS_DEAD    , do_hotboot  , LVL_REBOOT_MASTER, 0, 0 },
  { "house"    , POS_RESTING , do_house    ,-1, 0, 0 },
  { "howl"     , POS_FIGHTING, do_roar     , 0, SCMD_HOWL, 0 },
  { "hunt"     , POS_STANDING, do_hunt     ,-1, 0, 0 },
  { "hug"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "hunger"   , POS_RESTING , do_action   , 0, 0, 0 },

  { "inventory", POS_SLEEPING, do_inventory, 0, 0, CMD_ANY },
  { "identify" , POS_RESTING , do_identify , 0, 0, CMD_HIDE | CMD_OLC },
  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA, CMD_ANY },
  { "imitate"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "imotd"    , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD, CMD_ANY },
  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST, CMD_ANY },
  { "impale"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "innate"   , POS_DEAD    , do_innate   , 0, 0, CMD_ANY },
  { "ignore"   , POS_DEAD    , do_ignore   , 0, 0, CMD_ANY },
  { "info"     , POS_DEAD    , do_gen_ps   , 0, SCMD_INFO, CMD_ANY },
  { "insult"   , POS_RESTING , do_insult   , 0, 0, 0 },
  { "invis"    , POS_DEAD    , do_invis    , LVL_IMMORT, 0, CMD_ANY },
  { "iptables" , POS_DEAD    , do_iptables , LVL_ADMIN + 1, 0, CMD_ANY },
d607 1
a607 1
  { "ispell"   , POS_DEAD    , do_ispell   , LVL_IMMORT, 0, CMD_ANY },
d610 1
a610 1
  { "junk"     , POS_RESTING , do_drop     , 0, SCMD_JUNK, 0 },
d612 332
a943 332
  { "kick"     , POS_FIGHTING, do_kick     , 1, 0, 0 },
  { "kill"     , POS_FIGHTING, do_kill     , 0, 0, 0 },
  { "kiss"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "kneel"    , POS_RESTING , do_kneel    , 0, 0, 0 },

  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK, CMD_MINOR_PARA | CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST | CMD_OLC },
  { "lag"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "laugh"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "layhands" , POS_FIGHTING, do_layhand  , 0, 0, 0 },
  { "last"     , POS_DEAD    , do_last     , LVL_GRGOD, 0, CMD_ANY },
  { "lean"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "leave"    , POS_STANDING, do_leave    , 0, 0, 0 },
  { "level"    , POS_DEAD    , do_level    , 0, 0, CMD_ANY },
  { "light"    , POS_RESTING , do_light    , 0, SCMD_LIGHT, 0 },
  { "list"     , POS_STANDING, do_not_here , 0, 0, 0 },
  { "listspells",POS_DEAD    , do_listspells,LVL_ATTENDANT, 0, CMD_ANY },
  { "lick"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "lock"     , POS_SITTING , do_gen_door , 0, SCMD_LOCK, 0 },
  { "linkload" , POS_DEAD    , do_linkload , LVL_HEAD_C, 0, CMD_ANY ^ CMD_OLC },
  { "load"     , POS_DEAD    , do_load     , LVL_ATTENDANT, 0, CMD_ANY ^ CMD_OLC },
  { "love"     , POS_RESTING , do_action   , 0, 0, 0 },

  { "memorize" , POS_RESTING , do_memorize , 0, 0, CMD_MEDITATE },
  { "maul"     , POS_FIGHTING, do_bash     , 1, SCMD_MAUL, 0 },
  { "moan"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "medit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT, 0 },
  { "motd"     , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD, CMD_ANY },
  { "mail"     , POS_STANDING, do_not_here , 1, 0, CMD_HIDE },
  { "massage"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "meditate" , POS_RESTING , do_meditate , 0, 0, CMD_MEDITATE },
  { "moon"     , POS_FIGHTING, do_action   , 0, 0, 0 },
  { "mosh"     , POS_STANDING, do_action   , 0, 0, 0 },
  { "mount"    , POS_STANDING, do_mount    , 0, 0, 0 },
  { "mourn"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "mumble"   , POS_SLEEPING, do_action   , 0, 0, 0 },
  { "mute"     , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH, CMD_ANY },
  { "mutter"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "murder"   , POS_FIGHTING, do_hit      , 0, SCMD_MURDER, 0 },
  { "mlist"    , POS_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "mnum"     , POS_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "msearch"  , POS_DEAD    , do_msearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "mstat"    , POS_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_MSTAT, CMD_ANY },

  { "nap"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "news"     , POS_DEAD    , do_gen_ps   , 0, SCMD_NEWS, CMD_ANY },
  { "nibble"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "nod"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "nog"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "noogie"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE, CMD_ANY },
  { "note"     , POS_DEAD    , do_gen_write, LVL_IMMORT, SCMD_NOTES, CMD_ANY },
  { "nudge"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "nuzzle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "naccept"  , POS_DEAD    , do_name     , LVL_IMMORT, SCMD_ACCEPT, CMD_ANY },
  { "ndecline" , POS_DEAD    , do_name     , LVL_IMMORT, SCMD_DECLINE, CMD_ANY },
  { "nlist"    , POS_DEAD    , do_name     , LVL_IMMORT, SCMD_LIST, CMD_ANY },

  { "order"    , POS_RESTING , do_order    , 1, 0, 0 },
  { "open"     , POS_SITTING , do_gen_door , 0, SCMD_OPEN, 0 },
  { "olc"      , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SAVEINFO, CMD_ANY },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT, 0 },
  { "olist"    , POS_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "onum"     , POS_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "osearch"  , POS_DEAD    , do_osearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "ostat"    , POS_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_OSTAT, CMD_ANY },

  { "put"      , POS_RESTING , do_put      , 0, 0, 0 },
  { "palm"     , POS_RESTING , do_palm     , 0, 0, CMD_HIDE },
  { "panic"    , POS_STANDING, do_action   , 0, 0, 0 },
  { "pant"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "pat"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "page"     , POS_DEAD    , do_page     , LVL_GOD, 0, CMD_ANY },
  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_OVERLORD, SCMD_PARDON, CMD_ANY },
  { "peace"    , POS_DEAD    , do_peace    , LVL_GRGOD, 0, CMD_ANY },
  { "peck"     , POS_FIGHTING, do_peck     , 1, 0, 0 },
  { "peer"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "pet"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "petition" , POS_DEAD    , do_petition , 0, 0, CMD_ANY },
  { "pfilemaint", POS_DEAD  , do_pfilemaint, LVL_OVERLORD, 0, 0 },
  { "pick"     , POS_STANDING, do_gen_door , 1, SCMD_PICK, CMD_HIDE },
  { "players"  , POS_DEAD    , do_players  , LVL_HEAD_C, 0, CMD_ANY },
  { "point"    , POS_RESTING , do_point    , 0, 0, 0 },
  { "poke"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES, CMD_ANY },
  { "ponder"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "poofin"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN, CMD_ANY },
  { "poofout"  , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT, CMD_ANY },
  { "pounce"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "pour"     , POS_STANDING, do_pour     , 0, SCMD_POUR, 0 },
  { "pout"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0, CMD_ANY },
  { "protect"  , POS_FIGHTING, do_action   , 0, 0, 0 },
  { "pray"     , POS_RESTING , do_pray     , 0, 0, CMD_MEDITATE },
  { "pscan"    , POS_DEAD    , do_pscan    , LVL_GRGOD, 0, CMD_ANY},
  { "ptell"    , POS_DEAD    , do_ptell    , LVL_IMMORT, 0, CMD_ANY },
  { "puke"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "punch"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "purr"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "purge"    , POS_DEAD    , do_purge    , LVL_PURGE, 0, CMD_ANY },

  { "quaff"    , POS_RESTING , do_use      , 0, SCMD_QUAFF, 0 },
  { "qecho"    , POS_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO, CMD_ANY },
  { "qui"      , POS_DEAD    , do_quit     ,-1, 0, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "quit"     , POS_DEAD    , do_quit     , 0, SCMD_QUIT, CMD_ANY ^ (CMD_CAST | CMD_OLC) },
  { "qsay"     , POS_RESTING , do_qcomm    , 0, SCMD_QSAY, CMD_ANY },

  { "rest"     , POS_RESTING , do_rest     , 0, 0, CMD_MEDITATE },
  { "raise"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "report"   , POS_RESTING , do_report   , 0, SCMD_REPORT, 0 },
  { "reply"    , POS_SLEEPING, do_reply    , 0, 0, CMD_ANY },
  { "read"     , POS_RESTING , do_look     , 0, SCMD_READ, 0 },
  { "reload"   , POS_DEAD    , do_reload   , LVL_HEAD_C, 0, 0 },
  { "recite"   , POS_RESTING , do_use      , 0, SCMD_RECITE, 0 },
  { "receive"  , POS_STANDING, do_not_here , 1, 0, 0 },
  { "recline"  , POS_RESTING , do_recline  , 0, 0, 0 },
  { "remove"   , POS_RESTING , do_remove   , 0, 0, 0 },
  { "rent"     , POS_STANDING, do_not_here , 1, 0, 0 },
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL, 0 },
  { "rescue"   , POS_FIGHTING, do_rescue   , 0, 0, 0 },
/*{ "readlist" , POS_DEAD    , do_readlist , LVL_GOD, 0, 0 },*/
  { "restore"  , POS_DEAD    , do_restore  , LVL_RESTORE, 0, CMD_OLC },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_RESTORE, 0, CMD_OLC },
  { "pain"     , POS_DEAD    , do_pain     , LVL_RESTORE, 0, CMD_OLC },
  { "rpain"    , POS_DEAD    , do_rpain    , LVL_RESTORE, 0, CMD_OLC },
  { "retreat"  , POS_FIGHTING, do_retreat  , 0, 0, 0 },
  { "return"   , POS_DEAD    , do_return   ,-1, 0, CMD_MINOR_PARA | CMD_MAJOR_PARA | CMD_BOUND },
  { "redit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT, 0 },
  { "rename"   , POS_DEAD    , do_rename   , LVL_GRGOD, 0, 0 },
  { "roar"     , POS_FIGHTING, do_roar     , 0, SCMD_ROAR, 0 },
  { "rofl"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "roll"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "ready"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "ruffle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "rlist"    , POS_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "rnum"     , POS_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "rsearch"  , POS_DEAD    , do_rsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "rstat"    , POS_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_RSTAT, CMD_ANY },
  { "sstat"    , POS_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_SSTAT, CMD_ANY },
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp,-1, 0, 0 },

  { "say"      , POS_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "'"        , POS_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND | CMD_OLC },
  { "save"     , POS_SLEEPING, do_save     , LVL_GOD, 0 , CMD_ANY ^ CMD_CAST },
  { "score"    , POS_DEAD    , do_score    , 0, 0, CMD_ANY },
  { "scan"     , POS_STANDING, do_scan     , 0, 0, 0 },
  { "salute"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "scribe"   , POS_RESTING , do_scribe   , 0, 0, 0 },
  { "scare"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "scold"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "scratch"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "scream"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "screw"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "sdedit"   , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SDEDIT, 0 },
  { "sell"     , POS_STANDING, do_not_here , 0, 0, 0 },
  { "send"     , POS_DEAD    , do_send     , LVL_GRGOD, 0, CMD_ANY },
  { "set"      , POS_DEAD    , do_set      , LVL_GOD, 0, CMD_ANY },
  { "search"   , POS_STANDING, do_search   , 0, 0, 0 },
  { "sedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT, 0 },
  { "seduce"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "shout"    , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT, CMD_OLC },
  { "shake"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "shadow"   , POS_RESTING , do_follow   , 0, SCMD_SHADOW, CMD_HIDE },
  { "shapechange",POS_STANDING, do_shapechange, 0, 0, 0 },
  { "shiver"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "show"     , POS_DEAD    , do_show     , LVL_IMMORT, 0, CMD_ANY },
  { "shrug"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "shudder"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_REBOOT_MASTER, 0, 0 },
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_REBOOT_MASTER, SCMD_SHUTDOWN, 0 },
  { "sigh"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "sing"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "sip"      , POS_RESTING , do_drink    , 0, SCMD_SIP, 0 },
  { "sit"      , POS_RESTING , do_sit      , 0, 0, 0 },
  { "skills"   , POS_SLEEPING, do_skills   , 1, 0, CMD_ANY },
  { "skillset" , POS_DEAD    , do_skillset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "slist"    , POS_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "snum"     , POS_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "ssearch"  , POS_DEAD    , do_ssearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "sleep"    , POS_SLEEPING, do_sleep    , 0, 0, 0 },
  { "slap"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "slobber"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "smell"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "smile"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "smirk"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "smoke"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "snicker"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "snap"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "snarl"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "sneeze"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "sniff"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "snoogie"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "snore"    , POS_SLEEPING, do_action   , 0, 0, 0 },
  { "snort"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "snowball" , POS_STANDING, do_action   , LVL_OVERLORD, 0, 0 },
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_HEAD_B, 0, 0 },
  { "snuggle"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "songs"    , POS_DEAD    , do_songs    , 0, 0, CMD_ANY },
  { "socials"  , POS_DEAD    , do_commands , 0, SCMD_SOCIALS, CMD_ANY },
  { "spam"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "split"    , POS_RESTING , do_split    , 1, 0, 0 },
  { "spells"   , POS_DEAD    , do_spells   , 1, 0, CMD_ANY },
  { "spank"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "spit"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "springleap",POS_RESTING , do_springleap, 0, 0, 0 },
  { "squeeze"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "stand"    , POS_RESTING , do_stand    , 0, 0, 0 },
  { "stare"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "stat"     , POS_DEAD    , do_stat     , LVL_ATTENDANT, SCMD_STAT, CMD_ANY },
  { "stay"     , POS_RESTING,  do_move     , 0, SCMD_STAY  , CMD_HIDE | CMD_OLC },
  { "steal"    , POS_STANDING, do_steal    , 1, 0, CMD_HIDE },
  { "steam"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "stow"     , POS_RESTING , do_stow     , 0, 0, CMD_HIDE },
  { "stomp"    , POS_FIGHTING, do_stomp    , 0, 0, 0 },
  { "stroke"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "strut"    , POS_STANDING, do_action   , 0, 0, 0 },
  { "sulk"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "summon"   , POS_STANDING, do_summon_mount, 0, 0, 0 },
  { "swat"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "sweat"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "sweep"    , POS_FIGHTING, do_sweep    ,-1, 0, 0 },
  { "switch"   , POS_DEAD    , do_switch   , LVL_GOD, 0, CMD_ANY ^ CMD_OLC },
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_ATTENDANT, 0, CMD_ANY },
  { "stone"    , POS_STANDING, do_not_here ,-1, 0, 0 },
  { "subclass" , POS_RESTING , do_subclass , 0, 0, CMD_HIDE },

  { "tell"     , POS_SLEEPING, do_tell     , 0, 0, CMD_ANY },
  { "terminate", POS_DEAD    , do_terminate, LVL_HEAD_C, 0, 0 },
  { "tackle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "take"     , POS_FIGHTING, do_get      , 0, 0, 0 },
  { "tantrum"  , POS_FIGHTING, do_hitall   , 0, SCMD_TANTRUM, 0 },
  { "tango"    , POS_STANDING, do_action   , 0, 0, 0 },
  { "tame"     , POS_STANDING, do_tame     , 0, 0, 0 },
  { "tap"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "tarzan"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "taunt"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "taste"    , POS_RESTING , do_eat      , 0, SCMD_TASTE, 0 },
  { "tease"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "tedit"    , POS_DEAD    , do_tedit    , LVL_HEAD_C, 0, 0 },
  { "teleport" , POS_DEAD    , do_teleport , LVL_GOD, 0, CMD_ANY },
  { "thank"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "think"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "thaw"     , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW, CMD_ANY },
  { "thirst"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "throatcut", POS_STANDING, do_throatcut, 0, 0, 0 },
  { "throw"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "tip"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "title"    , POS_DEAD    , do_title    , 1, 0, CMD_ANY },
  { "tickle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "time"     , POS_DEAD    , do_time     , 0, 0, CMD_ANY },
  { "tip"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0, CMD_ANY ^ CMD_CAST },
  { "tongue"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "touch"    , POS_RESTING , do_touch    , 0, 0, 0 },
  { "track"    , POS_STANDING, do_track    , 0, 0, 0 },
  { "transfer" , POS_DEAD    , do_trans    , LVL_GOD, 0, CMD_ANY },
  { "trigedit" , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT, 0 },
  { "trip"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "trophy"   , POS_DEAD    , do_trophy   , 0, 0, CMD_ANY },
  { "tug"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "twibble"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "twiddle"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "twitch"   , POS_SLEEPING, do_action   , 0, 0, 0 },
  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO , CMD_ANY },

  { "unlock"   , POS_SITTING , do_gen_door , 0, SCMD_UNLOCK, 0 },
  { "unban"    , POS_DEAD    , do_unban    , LVL_GRGOD, 0, CMD_ANY },
/*{ "unbind"   , POS_DEAD    , do_unbind   ,-1, 0, CMD_HIDE },*/
  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE, 0 },
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_ATTENDANT, SCMD_UNAFFECT, CMD_ANY },
  { "users"    , POS_DEAD    , do_users    , LVL_ATTENDANT, 0, CMD_ANY },
  { "uptime"   , POS_DEAD    , do_date     , 0, SCMD_UPTIME, CMD_ANY },

  { "value"    , POS_STANDING, do_not_here , 0, 0, CMD_HIDE },
  { "varset"   , POS_DEAD    , do_varset   , LVL_GAMEMASTER, 0, CMD_ANY },
  { "varunset" , POS_DEAD    , do_varunset , LVL_GAMEMASTER, 0, CMD_ANY },
  { "version"  , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION, CMD_ANY },
  { "veto"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "visible"  , POS_RESTING , do_visible  , 1, 0, CMD_HIDE },
  { "viewdam"  , POS_DEAD    , do_viewdam  , LVL_GRGOD, 0, CMD_ANY },
  { "vnum"     , POS_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "vlist"    , POS_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "vsearch"  , POS_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_ATTENDANT, SCMD_VSTAT, CMD_ANY },
  { "zstat"    , POS_DEAD    , do_zstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "estat"    , POS_DEAD    , do_estat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "oestat"   , POS_DEAD    , do_estat    , LVL_ATTENDANT, SCMD_OESTAT, CMD_ANY },
  { "restat"   , POS_DEAD    , do_estat    , LVL_ATTENDANT, SCMD_RESTAT, CMD_ANY },
  { "vitem"    , POS_DEAD    , do_vitem    , LVL_ATTENDANT, 0, CMD_ANY },
  { "vwear"    , POS_DEAD    , do_vwear    , LVL_ATTENDANT, 0, CMD_ANY },

  { "wake"     , POS_SLEEPING, do_wake     , 0, 0, 0 },
  { "walk"     , POS_STANDING, do_move     , 0, 0, CMD_HIDE },
  { "wave"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "wear"     , POS_RESTING , do_wear     , 0, 0, 0 },
  { "wait"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "weather"  , POS_RESTING , do_weather  , 0, 0, CMD_ANY },
  { "wet"      , POS_RESTING , do_action   , 0, 0, 0 },
  { "who"      , POS_DEAD    , do_who      , 0, 0, CMD_ANY },
  { "whap"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "whatever" , POS_RESTING , do_action   , 0, 0, 0 },
  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI, CMD_ANY },
  { "where"    , POS_DEAD    , do_where    , LVL_ATTENDANT, 0, CMD_ANY },
  { "whisper"  , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER, CMD_OLC },
  { "whine"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "whistle"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "wield"    , POS_RESTING , do_wield    , 0, 0, 0 },
  { "wiggle"   , POS_RESTING , do_action   , 0, 0, 0 },
  { "wince"    , POS_RESTING , do_action   , 0, 0, 0 },
  { "wink"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "withdraw" , POS_STANDING, do_not_here , 1, 0, 0 },
  { "wiznet"   , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { ";"        , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0, CMD_ANY },
  { "wizhelp"  , POS_DEAD    , do_commands , LVL_IMMORT, SCMD_WIZHELP, CMD_ANY },
  { "wizlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST, CMD_ANY },
  { "wizlock"  , POS_DEAD    , do_wizlock  , LVL_HEAD_B, 0, 0 },
  { "worship"  , POS_RESTING , do_action   , 0, 0, 0 },
  { "write"    , POS_STANDING, do_write    , 3, 0, 0 },

  { "yawn"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "yodel"    , POS_RESTING , do_action   , 0, 0, 0 },

  { "zone"     , POS_RESTING , do_action   , 0, 0, 0 },
  { "zedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT, 0 },
  { "zlist"    , POS_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "znum"     , POS_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "zreset"   , POS_DEAD    , do_zreset   , LVL_ATTENDANT, 0, CMD_ANY },
  { "zsearch"  , POS_DEAD    , do_zsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },

  { "game"     , POS_DEAD    , do_game     , LVL_ATTENDANT, 0, CMD_ANY },
  { "world"    , POS_DEAD    , do_world    , 0, 0, CMD_ANY },
  { "fup"      , POS_STANDING, do_move     ,-1, SCMD_FUP, CMD_HIDE },
  { "fdown"    , POS_STANDING, do_move     ,-1, SCMD_FDOWN, CMD_HIDE },
d946 31
a976 31
  { "attach"   , POS_DEAD    , do_attach   , LVL_IMPL, 0, 0 },
  { "z001#@@#"  , POS_SLEEPING, do_action   ,-1, 0, 0 },
  { "detach"   , POS_DEAD    , do_detach   , LVL_IMPL, 0, 0 },
  { "tlist"    , POS_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "tnum"     , POS_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "tsearch"  , POS_DEAD    , do_tsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "log"      , POS_DEAD    , do_mob_log  ,-1, 0, CMD_ANY },
  { "m_run_room_trig", POS_DEAD, do_m_run_room_trig, -1, 0, CMD_ANY },
  { "masound"  , POS_DEAD    , do_masound  ,-1, 0, CMD_ANY },
  { "mat"      , POS_DEAD    , do_mat      ,-1, 0, CMD_ANY },
  { "mdamage"  , POS_DEAD    , do_mdamage  ,-1, 0, CMD_HIDE },
  { "mecho"    , POS_DEAD    , do_mecho    ,-1, 0, CMD_ANY },
  { "mechoaround",POS_DEAD  ,do_mechoaround,-1, 0, CMD_ANY },
  { "mexp"     , POS_DEAD    , do_mexp     ,-1, 0, CMD_ANY },
  { "mforce"   , POS_DEAD    , do_mforce   ,-1, 0, CMD_ANY },
  { "mgoto"    , POS_DEAD    , do_mgoto    ,-1, 0, CMD_HIDE },
  { "mjunk"    , POS_DEAD    , do_mjunk    ,-1, 0, CMD_ANY },
  { "mkill"    , POS_STANDING, do_mkill    ,-1, 0, 0 },
  { "mload"    , POS_DEAD    , do_mload    ,-1, 0, CMD_ANY },
  { "mpurge"   , POS_DEAD    , do_mpurge   ,-1, 0, CMD_ANY },
  { "msave"    , POS_DEAD    , do_msave    ,-1, 0, CMD_ANY },
  { "msend"    , POS_DEAD    , do_msend    ,-1, 0, CMD_ANY },
  { "mskillset", POS_DEAD    , do_mskillset,-1, 0, CMD_ANY },
  { "mteleport", POS_DEAD    , do_mteleport,-1, 0, CMD_ANY },
  { "quest"    , POS_DEAD    , do_quest    ,-1, 0, CMD_ANY },
  { "qadd"     , POS_DEAD    , do_qadd     , LVL_HEAD_B, 0, CMD_ANY },
  { "qdel"     , POS_DEAD    , do_qdel     , LVL_HEAD_B, 0, CMD_ANY },
  { "qlist"    , POS_DEAD    , do_qlist    , LVL_ATTENDANT, 0, CMD_ANY },
  { "qstat"    , POS_DEAD    , do_qstat    , LVL_ATTENDANT, 0, CMD_ANY },
  { "objfix"   , POS_DEAD    , do_objfix   , LVL_HEAD_C, 0, CMD_ANY },
d1107 25
d1133 16
a1148 23
    switch (GET_POS(ch)) {
    case POS_DEAD:
      send_to_char("Lie still; you are DEAD!!! :-(\r\n", ch);
      break;
    case POS_INCAP:
    case POS_MORTALLYW:
      send_to_char("You are in a pretty bad shape, unable to do anything!\r\n", ch);
      break;
    case POS_STUNNED:
      send_to_char("All you can do right now is think about the stars!\r\n", ch);
      break;
    case POS_SLEEPING:
      send_to_char("In your dreams, or what?\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("Nah... You feel too relaxed to do that..\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("Maybe you should get on your feet first?\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("No way!  You're fighting for your life!\r\n", ch);
      break;
d3123 3
@


1.267
log
@Rename the function that handles the "reload" command from do_reboot
to do_reload.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.266 2008/04/05 06:28:50 myc Exp jps $
d928 1
d3106 4
@


1.266
log
@Fixed that crash bug: was a buffer overflow because of a tiny local
buffer.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.265 2008/04/05 05:05:42 myc Exp myc $
d237 1
a237 1
ACMD(do_reboot);
d724 1
a724 1
  { "reload"   , POS_DEAD    , do_reboot   , LVL_HEAD_C, 0, 0 },
d3105 4
@


1.265
log
@Removed SEND_TO_Q macro, so call write_to_output directly.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.264 2008/04/04 06:12:52 myc Exp myc $
a2015 1
  char buf[128];
d3105 3
@


1.264
log
@Removed justice and dieites/worship code.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.263 2008/04/04 05:13:46 myc Exp myc $
d1817 1
a1817 1
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
d1841 1
a1841 1
        SEND_TO_Q("\r\nThis body has been usurped!\r\n", k);
d1848 1
a1848 1
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
d1909 1
a1909 1
    SEND_TO_Q("Reconnecting.\r\n", d);
d1915 1
a1915 1
    SEND_TO_Q("Overriding old connection.\r\n", d);
d1924 1
a1924 1
    SEND_TO_Q("Reconnecting to unswitched char.", d);
d2074 1
a2074 1
          SEND_TO_Q("~: ", d);
d2077 1
a2077 1
          SEND_TO_Q("You must have OLCComm toggled on to use commands in OLC.\r\n", d);
d2094 1
a2094 1
         SEND_TO_Q("Color is on.\r\n", d);
d2096 4
a2099 4
         SEND_TO_Q(GREETINGS, d);
         SEND_TO_Q(GREETINGS2, d);
         SEND_TO_Q(GREETINGS3, d);
         SEND_TO_Q(GREETINGS4, d);
d2101 3
a2103 3
         SEND_TO_Q(TEST_GREETING, d);
         SEND_TO_Q(TEST_GREETING2, d);
         SEND_TO_Q(TEST_GREETING3, d);
d2105 2
a2106 2
         SEND_TO_Q(bcbuf, d);
         SEND_TO_Q(WHOAREYOU, d);
d2112 1
a2112 1
         SEND_TO_Q("Color is off.\r\n", d);
d2114 4
a2117 4
         SEND_TO_Q(GREETINGS, d);
         SEND_TO_Q(GREETINGS2, d);
         SEND_TO_Q(GREETINGS3, d);
         SEND_TO_Q(GREETINGS4, d);
d2119 3
a2121 3
         SEND_TO_Q(TEST_GREETING, d);
         SEND_TO_Q(TEST_GREETING2, d);
         SEND_TO_Q(TEST_GREETING3, d);
d2123 2
a2124 2
         SEND_TO_Q(bcbuf, d);
         SEND_TO_Q(WHOAREYOU, d);
d2128 2
a2129 2
         SEND_TO_Q("Please answer Y or N.\r\n", d);
         SEND_TO_Q(ANSI, d);
d2149 1
a2149 1
         SEND_TO_Q("Invalid name, please try another.\r\n"
d2177 1
a2177 1
            SEND_TO_Q(buf, d);
d2200 1
a2200 1
            SEND_TO_Q("Password: ", d);
d2217 2
a2218 2
            SEND_TO_Q("Welcome back!\r\n",d);
            SEND_TO_Q("Password: ", d);
d2226 2
a2227 2
            SEND_TO_Q("Invalid name, please try another.\r\n", d);
            SEND_TO_Q("Name: ", d);
d2234 1
a2234 1
         SEND_TO_Q(buf, d);
d2247 1
a2247 1
            SEND_TO_Q("Sorry, new characters are not allowed from your site!\r\n", d);
d2253 2
a2254 2
               SEND_TO_Q("Sorry, no new players because the mud is rebooting shortly.\r\n", d);
               SEND_TO_Q("Please try again in five minutes.\r\n", d);
d2256 1
a2256 1
               SEND_TO_Q("Sorry, new players can't be created at the moment.\r\n", d);
d2282 1
a2282 1
         SEND_TO_Q(NAMES_EXPLANATION, d);
d2285 1
a2285 1
         SEND_TO_Q(buf, d);
d2289 1
a2289 1
         SEND_TO_Q(buf, d);
d2296 1
a2296 1
         SEND_TO_Q("Okay, what IS it, then? ", d);
d2301 1
a2301 1
         SEND_TO_Q("Please answer yes or no: ", d);
d2306 1
a2306 1
      SEND_TO_Q("Name: ",d);
d2312 1
a2312 1
        SEND_TO_Q("c> Invalid name, please try another.\r\n"
d2317 2
a2318 2
      SEND_TO_Q("That name is already taken!\r\n", d);
      SEND_TO_Q("Name: ", d);
d2323 2
a2324 2
      SEND_TO_Q("d> Invalid name, please try another.\r\n", d);
      SEND_TO_Q("Name: ", d);
d2344 1
a2344 1
      SEND_TO_Q("Now you must wait to be re-approved.\r\n", d);
d2349 1
a2349 1
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\n"
d2356 1
a2356 1
    SEND_TO_Q("You must wait to be approved.\r\n", d);
d2359 1
a2359 1
    SEND_TO_Q("\r\nWrong password... disconnecting.\r\n", d);
d2384 1
a2384 1
          SEND_TO_Q("Wrong password... disconnecting.\r\n", d);
d2387 1
a2387 1
          SEND_TO_Q("Wrong password.\r\nPassword: ", d);
d2397 1
a2397 1
        SEND_TO_Q("Sorry, this char has not been cleared for login from your site!\r\n", d);
d2406 2
a2407 2
            SEND_TO_Q("The game is restricted due to an imminent reboot.\r\n", d);
            SEND_TO_Q("Please try again in 2-3 minutes.\r\n", d);
d2409 1
a2409 1
            SEND_TO_Q("The game is temporarily restricted.  Please Try again later.\r\n", d);
d2422 2
a2423 2
        SEND_TO_Q("Your name has been deemed unacceptable.  Please choose a new one.\r\n", d);
        SEND_TO_Q("Name: ",d);
d2429 1
a2429 1
        SEND_TO_Q(imotd, d);
d2431 1
a2431 1
        SEND_TO_Q(motd, d);
d2443 1
a2443 1
        SEND_TO_Q(buf, d);
d2446 1
a2446 1
      SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
d2456 2
a2457 2
      SEND_TO_Q("\r\nIllegal password.\r\n", d);
      SEND_TO_Q("Password: ", d);
d2463 1
a2463 1
    SEND_TO_Q("\r\nPlease retype password: ", d);
d2475 2
a2476 2
      SEND_TO_Q("\r\nPasswords don't match... start over.\r\n", d);
      SEND_TO_Q("Password: ", d);
d2486 1
a2486 1
      SEND_TO_Q("\r\nWhat is your sex (M/F)? ", d);
d2491 2
a2492 2
      SEND_TO_Q("\r\nDone.\n\r", d);
      SEND_TO_Q(MENU, d);
d2509 1
a2509 1
      SEND_TO_Q("\r\nThat is not a sex!\r\n"
d2516 1
a2516 1
      SEND_TO_Q("\r\nRace: ", d);
d2536 1
a2536 1
      SEND_TO_Q("\r\n&3Please choose by entering the letter next to the race of your choice.&0\r\n", d);
d2538 1
a2538 1
      SEND_TO_Q("\r\nRace: ", d);
d2549 1
a2549 1
         SEND_TO_Q(buf, d);
d2555 1
a2555 1
         SEND_TO_Q("\r\nPlease enter a different name: ", d);
d2565 1
a2565 1
      SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2575 1
a2575 1
        SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2583 1
a2583 1
        SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2591 1
a2591 1
        SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2599 1
a2599 1
        SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2607 1
a2607 1
        SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2620 1
a2620 1
      SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
d2631 1
a2631 1
    SEND_TO_Q("\r\nPlease press ENTER to roll your attributes: ", d);
d2660 1
a2660 1
    SEND_TO_Q("\r\nPlease press ENTER to roll your attributes: ", d);
d2685 2
a2686 2
      SEND_TO_Q(buf, d);
      SEND_TO_Q("\r\n\nYou may keep these stats if you wish (&0&6Enter y&0),\r\nor if you wish"
d2693 3
a2695 3
    SEND_TO_Q("\r\r\n\n&0&7&bYou have three bonus's to use choose the stat carefully:&0\n\r", d);
    SEND_TO_Q(stats_display, d);
    SEND_TO_Q("\r\n&0&7&bPlease enter your first bonus selection:&0\n\r",d);
d2701 1
a2701 1
      SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
d2704 2
a2705 2
    SEND_TO_Q(stats_display, d);
    SEND_TO_Q("\r\n&0&7&bPlease enter your second bonus selection:&0\n\r",d);
d2713 1
a2713 1
      SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
d2716 2
a2717 2
    SEND_TO_Q(stats_display, d);
    SEND_TO_Q("\r\n&0&7&bPlease enter your third bonus selection:&0\n\r",d);
d2726 1
a2726 1
      SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
d2733 1
a2733 1
    SEND_TO_Q("&0&4\r\n\r\nRolling for this character is complete!!\r\n"
d2746 1
a2746 1
         SEND_TO_Q("\r\nWhat is your sex (M/F)? ", d);
d2750 2
a2751 2
         SEND_TO_Q("\r\nPlease answer yes or no.\r\n", d);
         SEND_TO_Q(
d2762 1
a2762 1
            SEND_TO_Q("\r\nNow you must wait for your name to be approved by an immortal.\r\n"
d2778 1
a2778 1
            SEND_TO_Q("\r\n*** PRESS RETURN: ", d);
d2785 1
a2785 1
    SEND_TO_Q(MENU, d);
d2820 2
a2821 2
      SEND_TO_Q("Enter the text you'd like others to see when they look at you.\r\n", d);
      SEND_TO_Q("(/s saves /h for help)\r\n", d);
d2832 1
a2832 1
      SEND_TO_Q("\r\nEnter your old password: ", d);
d2837 2
a2838 2
      SEND_TO_Q("\r\n This has been temporarily removed.\r\n", d);
      SEND_TO_Q(MENU, d);
d2840 1
a2840 1
      /*      SEND_TO_Q("\r\nEnter your password for verification: ", d);
d2845 2
a2846 2
      SEND_TO_Q("\r\nWrong Option!\r\n", d);
      SEND_TO_Q(MENU, d);
d2855 2
a2856 2
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
d2860 1
a2860 1
      SEND_TO_Q("\r\nEnter a new password: ", d);
d2869 2
a2870 2
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
d2873 1
a2873 1
      SEND_TO_Q("\r\nYOU ARE ABOUT TO DELETE THIS CHARACTER PERMANENTLY.\r\n"
d2883 2
a2884 2
        SEND_TO_Q("You try to kill yourself, but the ice stops you.\r\n", d);
        SEND_TO_Q("Character not deleted.\r\n\r\n", d);
d2897 1
a2897 1
      SEND_TO_Q(buf, d);
d2904 2
a2905 2
      SEND_TO_Q("\r\nCharacter not deleted.\r\n", d);
      SEND_TO_Q(MENU, d);
d3042 3
a3044 3
     SEND_TO_Q("You have been auto-approved.\r\n", d);
     SEND_TO_Q(motd, d);
     SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
d3106 3
@


1.263
log
@Removing maputil code.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.262 2008/04/03 17:36:42 jps Exp myc $
a33 1
#include "worship.h"
a185 1
ACMD(do_justice);
a611 1
  { "justice"  , POS_DEAD    , do_justice  , 1, 0, CMD_ANY },
a927 1
  { "worship"  , POS_RESTING , do_action   , 0, 0, 0 },
a2663 13
    /* illegal case as of 10/31/98 -fingh */
  case CON_QDIETY:
    load_result = 0;
    load_result = parse_diety(d->character, *arg);
    if(load_result == INVALID_DIETY)
      {
        SEND_TO_Q("You cannot worship that deity.\r\nDiety:", d);
        return;
      }
    else
      GET_DIETY(d->character) = load_result;
    break;

d3106 3
@


1.262
log
@Stopped using the PLR_INVSTART flag.  Instead, using the autoinvis toggle.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.261 2008/04/03 02:02:05 myc Exp jps $
a201 1
ACMD(do_map);
a639 1
  { "map"      , POS_DEAD    , do_map      , LVL_BUILDER, 0, CMD_ANY },
d3123 3
@


1.261
log
@Upgraded ansi color handling code.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.260 2008/04/02 03:24:44 myc Exp myc $
d1950 3
a1952 2
  if (PLR_FLAGGED(d->character, PLR_INVSTART))
    GET_INVIS_LEV(d->character) = GET_LEVEL(d->character);
d2441 2
a2442 2
            PLR_FLAGGED(d->character, PLR_INVSTART) ? GET_LEVEL(d->character) :
               GET_INVIS_LEV(d->character)),
d3125 3
@


1.260
log
@Rewrote group code and removed major group code.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.259 2008/03/30 17:30:38 jps Exp myc $
a86 1
char *strip_ansi(char *the_string);
d2446 2
a2447 2
                CCRED(d->character, C_SPR), load_result,
                (load_result > 1) ? "S" : "", CCNRM(d->character, C_SPR));
d3124 3
@


1.259
log
@Renamed objsave.c to pfiles.c and introduced pfiles.h. Files using functions
from pfiles.c now include pfiles.h and depend on it in the makefile.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.258 2008/03/30 16:32:18 jps Exp jps $
a158 1
/* ACMD(do_frag); */
a203 1
ACMD(do_mdisband);
a205 1
ACMD(do_mgroup);
a208 1
ACMD(do_msay);
a539 1
/*{ "frag"     , POS_DEAD    , do_frag     , 0, 0, 0 },*/
a642 1
  { "mdisband" , POS_SLEEPING, do_mdisband , 1, 0, 0 },
a648 1
  { "mgroup"   , POS_SLEEPING, do_mgroup   , 1, 0, 0 },
a660 3
  { "msay"     , POS_SLEEPING, do_msay     , 0, 0, CMD_ANY },
  { "mreport"  , POS_SLEEPING, do_report   , 0, SCMD_MREPORT, CMD_ANY },
  { "mtell"    , POS_SLEEPING, do_msay     , 0, 0, CMD_ANY },
d3125 4
@


1.258
log
@Don't need to set player race align when entering game.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.257 2008/03/28 17:54:53 myc Exp jps $
d42 1
d388 1
a388 1
  { "RESERVED", 0, 0, 0, 0, 0 },	/* this must be first -- for specprocs */
d995 1
a995 1
  { "\n", 0, 0, 0, 0 , CMD_HIDE } };	/* this must be last */
d1061 1
a1061 1
	break;
d1205 2
a1206 2
	sprintf(buf, "%-15s %s\r\n", alias->alias, alias->replacement);
	send_to_char(buf, ch);
d1211 1
a1211 1
  else {			
d1225 1
a1225 1
	send_to_char("No such alias.\r\n", ch);
d1227 1
a1227 1
	send_to_char("Alias deleted.\r\n", ch);
d1229 1
a1229 1
    else {			
d1234 2
a1235 2
	send_to_char("You can't alias 'alias'.\r\n", ch);
	return;
d1289 2
a1290 2
	strcpy(write_point, tokens[num]);
	write_point += strlen(tokens[num]);
d1292 4
a1295 4
	strcpy(write_point, orig);
	write_point += strlen(orig);
      } else if ((*(write_point++) = *temp) == '$')	/* redouble $ for act safety */
	*(write_point++) = '$';
d1384 1
a1384 1
	return (i);
d1387 2
a1388 2
      l = 1;			/* Avoid "" to match the first available
				 * string */
d1391 1
a1391 1
	return (i);
d1407 1
a1407 1
	return (i);
d1411 2
a1412 2
      len = 1;			/* Avoid "" to match the first available
				   string */
d1415 1
a1415 1
	return (i);
d1492 1
a1492 1
	read++; /* skip if we saw 2 $'s in a row */
d1654 1
a1654 1
	    strip_ansi(pc_class_types[CLASS_WARRIOR]));
d1659 1
a1659 1
	    strip_ansi(pc_class_types[CLASS_CLERIC]));
d1664 1
a1664 1
	    strip_ansi(pc_class_types[CLASS_SORCERER]));
d1669 1
a1669 1
	    strip_ansi(pc_class_types[CLASS_ROGUE]));
d1674 1
a1674 1
	    strip_ansi(pc_class_types[CLASS_SHAMAN]));
d1684 3
a1686 3
	sprintf(buf, "%s%s%-15.15s ", buf,
		class_ok_race[char_race][warrior_subclasses[x]] ? "*" : " ",
		strip_ansi(pc_class_types[warrior_subclasses[x]]));
d1688 1
a1688 1
	sprintf(buf, "%s%-16.16s ", buf, " ");
d1691 3
a1693 3
	sprintf(buf, "%s%s%-15.15s ", buf,
		class_ok_race[char_race][cleric_subclasses[x]] ? "*" : " ",
		strip_ansi(pc_class_types[cleric_subclasses[x]]));
d1695 1
a1695 1
	sprintf(buf, "%s%-16.16s ", buf, " ");
d1698 3
a1700 3
	sprintf(buf, "%s%s%-15.15s ", buf,
		class_ok_race[char_race][mage_subclasses[x]] ? "*" : " ",
		strip_ansi(pc_class_types[mage_subclasses[x]]));
d1702 1
a1702 1
	sprintf(buf, "%s%-16.16s ", buf, " ");
d1705 3
a1707 3
	sprintf(buf, "%s%s%-15.15s", buf,
		class_ok_race[char_race][rogue_subclasses[x]] ? "*" : " ",
		strip_ansi(pc_class_types[rogue_subclasses[x]]));
d1709 1
a1709 1
	sprintf(buf, "%s%-16.16s", buf, " ");
d1716 4
a1719 4
	    warriorok ? " [&0&1&bw&0&6]arrior" : "",
	    clericok ? " [&0&1&bc&0&6]leric" : "",
	    mageok ? " [&0&1&bs&0&6]orcerer" : "",
	    rogueok ? " [&0&1&br&0&6]ogue" : "");
d1765 1
a1765 1
	return 1;
d1771 1
a1771 1
	return 1;
d1777 1
a1777 1
	return 1;
d1783 1
a1783 1
	return 1;
d1809 3
a1811 3
#define RECON		1
#define USURP		2
#define UNSWITCH	3
d1847 1
a1847 1
	mode = UNSWITCH;
d1849 2
a1850 2
	target = k->original;
	mode = UNSWITCH;
d1853 1
a1853 1
	k->character->desc = NULL;
d1858 3
a1860 3
	SEND_TO_Q("\r\nThis body has been usurped!\r\n", k);
	target = k->character;
	mode = USURP;
d1934 2
a1935 2
	"$n's body has been taken over by a new spirit!",
	TRUE, d->character, 0, 0, TO_ROOM);
d1937 1
a1937 1
	    GET_NAME(d->character));
d1989 1
a1989 1
  if ((load_result = Crash_load(d->character)))
d2126 1
a2126 1
         REMOVE_FLAG(PRF_FLAGS(d->character), PRF_COLOR_1); 
d2232 1
a2232 1
            log(buf);	
d2236 1
a2236 1
            d->idle_tics = 0;	
d2240 1
a2240 1
	
d2256 1
a2256 1
  case CON_NAME_CNFRM:		/* wait for conf. of new name    */
d2326 4
a2329 4
	  strlen(tmp_name) > MAX_NAME_LENGTH ||
	  fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
	SEND_TO_Q("c> Invalid name, please try another.\r\n"
		  "Name: ", d);
d2362 1
a2362 1
	SET_FLAG(PLR_FLAGS(d->character), PLR_NAPPROVE);
d2378 1
a2378 1
  case CON_PASSWORD:		/* get pwd for known player      */
d2395 12
a2406 12
	sprintf(buf, "Bad PW: %s [%s]", GET_NAME(d->character), d->host);
	mudlog(buf, BRF, LVL_GOD, TRUE);
	GET_BAD_PWS(d->character)++;
	save_player(d->character);
	if (++(d->bad_pws) >= max_bad_pws) {	/* 3 strikes and you're out. */
	  SEND_TO_Q("Wrong password... disconnecting.\r\n", d);
	  STATE(d) = CON_CLOSE;
	} else {
	  SEND_TO_Q("Wrong password.\r\nPassword: ", d);
	  echo_off(d);
	}
	return;
d2412 7
a2418 7
	  !PLR_FLAGGED(d->character, PLR_SITEOK)) {
	SEND_TO_Q("Sorry, this char has not been cleared for login from your site!\r\n", d);
	STATE(d) = CON_CLOSE;
	sprintf(buf, "Connection attempt for %s denied from %s",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	return;
d2427 5
a2431 5
	STATE(d) = CON_CLOSE;
	sprintf(buf, "Request for login denied for %s [%s] (wizlock)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	return;
d2435 1
a2435 1
	return;
d2445 1
a2445 1
	SEND_TO_Q(imotd, d);
d2447 1
a2447 1
	SEND_TO_Q(motd, d);
d2455 6
a2460 6
	sprintf(buf, "\r\n\r\n\007\007\007"
		"%s%d LOGIN FAILURE%s SINCE LAST SUCCESSFUL LOGIN.%s\r\n",
		CCRED(d->character, C_SPR), load_result,
		(load_result > 1) ? "S" : "", CCNRM(d->character, C_SPR));
	SEND_TO_Q(buf, d);
	GET_BAD_PWS(d->character) = 0;
d2463 1
d2471 1
a2471 1
	!str_cmp(arg, GET_NAME(d->character))) {
d2490 1
a2490 1
		MAX_PWD_LENGTH)) {
d2494 1
a2494 1
	STATE(d) = CON_NEWPASSWD;
d2496 1
a2496 1
	STATE(d) = CON_CHPWD_GETNEW;
d2514 1
a2514 1
  case CON_QSEX:		/* query sex of new user         */
d2526 1
a2526 1
		"What IS your sex? (M/F) ", d);
d2589 1
a2589 1
	load_result = CLASS_WARRIOR;
d2591 2
a2592 2
	SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
	return;
d2597 1
a2597 1
	load_result = CLASS_CLERIC;
d2599 2
a2600 2
	SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
	return;
d2605 1
a2605 1
	load_result = CLASS_SORCERER;
d2607 2
a2608 2
	SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
	return;
d2613 1
a2613 1
	load_result = CLASS_ROGUE;
d2615 2
a2616 2
	SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
	return;
d2621 1
a2621 1
	load_result = CLASS_SHAMAN;
d2623 2
a2624 2
	SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
	return;
d2630 1
a2630 1
	sprintf(buf2, "%s%s\r\n", buf2, class_display[i]);
d2637 1
a2637 1
      return;	
d2686 2
a2687 2
	SEND_TO_Q("You cannot worship that deity.\r\nDiety:", d);
	return;
d2699 1
a2699 1
	break;
d2701 1
a2701 1
    case 'N':	
d2707 7
a2713 7
      sprintf(buf, "\r\n\r	Con:  %s		Wis:  %s\r\n"
	      "	Str:  %s		Intel:%s\r\n"
	      "	Dex:  %s		Char: %s\r\r\r\r\n",
	      rolls_abils_result[roll_table[4]],  rolls_abils_result[roll_table[2]],
	      rolls_abils_result[roll_table[0]],
	      rolls_abils_result[roll_table[1]], rolls_abils_result[roll_table[3]],
	      rolls_abils_result[roll_table[5]]);
d2716 1
a2716 1
		" you may try for better stats (&0&6Enter n&0)(y/n):", d);
d2720 1
a2720 1
		
d2726 1
a2726 1
    break;	
d2738 1
a2738 1
    break;	
d2763 1
a2763 1
	      "&0&4&bDo you wish to keep this character (Y/n)?\r\n"
d2781 1
a2781 1
	            "&0&4&bDo you wish to keep this character (Y/n)?\r\n"
d2813 1
a2813 1
  case CON_RMOTD:		/* read CR after printing motd   */
d2818 1
a2818 1
  case CON_MENU:		/* get selection from main menu  */
d2832 2
a2833 2
	start_player(d->character);
	send_to_char(START_MESSG, d->character);
d2838 5
a2842 5
	send_to_char("You have mail waiting.\r\n", d->character);
      if (load_result == 2) {	/* rented items lost */
	send_to_char("\r\n\007You could not afford your rent!\r\n"
		     "Your possesions have been donated to the Salvation Army!\r\n",
		     d->character);
d2870 2
a2871 2
	      echo_off(d);
	      STATE(d) = CON_DELCNF1; */
d2903 2
a2904 2
		"ARE YOU ABSOLUTELY SURE?\r\n\r\n"
		"Please type \"yes\" to confirm: ", d);
d2912 4
a2915 4
	SEND_TO_Q("You try to kill yourself, but the ice stops you.\r\n", d);
	SEND_TO_Q("Character not deleted.\r\n\r\n", d);
	STATE(d) = CON_CLOSE;
	return;
d2925 1
a2925 1
	      "Goodbye.\r\n", GET_NAME(d->character));
d2928 1
a2928 1
	      GET_LEVEL(d->character));
d2984 1
a2984 1
  for (j = 0; j <= 5; j++)	{
d3001 1
a3001 1
{	
d3003 2
a3004 2
  int a;	
  arg = LOWER(arg);	
d3010 2
a3011 2
      a = TRUE;		
      break;	
d3026 1
a3026 1
      break;	
d3037 1
a3037 1
    default:	
d3040 1
a3040 1
    }	
d3135 3
@


1.257
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.256 2008/03/27 22:57:29 jps Exp myc $
a1962 2
  GET_RACE_ALIGN(d->character) = races[(int)GET_RACE(d->character)].racealign;

d3133 4
@


1.256
log
@Added objfix command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.255 2008/03/22 03:22:38 myc Exp jps $
d1063 1
a1063 1
    affect_from_char(ch, SPELL_NATURES_EMBRACE);
d1068 1
a1068 1
    REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
d1111 1
a1111 1
  else if (AFF_FLAGGED(ch, AFF_MAJOR_PARA) &&
d1114 1
a1114 1
  else if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) &&
d1774 1
a1774 1
    if (GET_MOB_SPEC(k) != NULL && !MOB2_FLAGGED(k, MOB2_NOSCRIPT))
d1838 1
a1838 1
          if (IS_FIGHTING(k->character)) {
d1919 2
a1920 1
  REMOVE_BIT(PLR_FLAGS(d->character), PLR_MAILING | PLR_WRITING);
d2109 2
a2110 1
         SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
d2127 2
a2128 1
         REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
d2185 8
a2192 4
            if (color)
               SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
            else
               REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
d2204 12
a2215 6
            REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING | PLR_MAILING | PLR_CRYO);

            if (color)
               SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
            else
               REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
d2363 1
a2363 1
	SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
d2365 1
a2365 1
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d2787 1
a2787 1
               SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
d2790 1
a2790 1
            REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d2798 1
a2798 1
               SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
d3064 1
a3064 1
     SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
d3077 1
a3077 1
       REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d3086 1
a3086 1
     REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d3135 3
@


1.255
log
@All invocations of the string editor now go through string_write()
instead of messing with the descriptor variables itself.  Also added
a toggle, LineNums, to decide whether to do /l or /n when entering
the string editor.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.254 2008/03/21 15:01:17 myc Exp myc $
d341 1
d992 1
d3122 6
@


1.254
log
@Removed languages.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.253 2008/03/16 23:30:14 jps Exp myc $
d2836 1
a2836 12
      if (d->character->player.description) {
         SEND_TO_Q("Current description:\r\n", d);
         SEND_TO_Q(d->character->player.description, d);
 	/* don't free this now... so that the old description gets loaded */
 	/* as the current buffer in the editor */
 	/* free(d->character->player.description); */
 	/* d->character->player.description = NULL; */
 	/* BUT, do setup the ABORT buffer here */
 	d->backstr = str_dup(d->character->player.description);
      }
      d->str = &d->character->player.description;
      d->max_str = EXDSCR_LENGTH - 1;
d3120 3
@


1.253
log
@Move 'stay' down to its alphabetical position, so that 'sta' resolves
to 'stand' like people are accustomed to.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.252 2008/03/10 18:01:17 myc Exp jps $
a265 1
ACMD(do_speak);
a825 1
  { "speak"    , POS_DEAD    , do_speak    , 0, 0, CMD_ANY },
d3131 4
@


1.252
log
@Made bodyslam and maul subcommands of bash.  Made tantrum a subcommand
of hitall.  Made battle howl a subcommand of roar.  Added ground
shaker command as stomp.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.251 2008/03/09 18:15:45 jps Exp myc $
d187 1
a187 1
ACMD(do_iptables); 
d213 1
a213 1
ACMD(do_note); 
d396 1
a396 2
  { "stay"     , POS_RESTING,  do_move     , 0, SCMD_STAY  , CMD_HIDE | CMD_OLC },
  
d625 2
a626 2
  { "kneel"    , POS_RESTING , do_kneel    , 0, 0, 0 }, 
  
d630 1
a630 1
  { "layhands" , POS_FIGHTING, do_layhand  , 0, 0, 0 }, 
d742 1
a742 1
  { "recline"  , POS_RESTING , do_recline  , 0, 0, 0 }, 
d837 1
d886 1
a886 1
  { "trophy"   , POS_DEAD    , do_trophy   , 0, 0, CMD_ANY }, 
d1049 1
a1049 1
  
d1056 1
a1056 1
  
d1066 1
a1066 1
  
d1108 1
a1108 1
  else if (PLR_FLAGGED(ch, PLR_BOUND) && GET_LEVEL(ch) < LVL_IMMORT && 
d1192 1
a1192 1
  
d1195 1
a1195 1
  
d1197 1
a1197 1
  
d1229 1
a1229 1
      
d1266 1
a1266 1
  
d1273 1
a1273 1
  
d1277 1
a1277 1
  
d1298 1
a1298 1
  
d1302 1
a1302 1
  
d1336 1
a1336 1
  
d1340 1
a1340 1
  
d1344 1
a1344 1
  
d1375 1
a1375 1
  
d1379 1
a1379 1
  
d1392 1
a1392 1
  
d1399 1
a1399 1
  
d1402 1
a1402 1
  
d1416 1
a1416 1
  
d1483 1
a1483 1
  
d1486 1
a1486 1
  
d1492 1
a1492 1
  
d1494 1
a1494 1
  
d1501 1
a1501 1
  /* Needs to be case-insensitive since fill_word is used by the nanny for 
d1509 1
a1509 1
  /* Needs to be case-insensitive since fill_word is used by the nanny for 
d1522 1
a1522 1
  
d1525 1
a1525 1
    
d1531 1
a1531 1
    
d1534 1
a1534 1
  
d1542 1
a1542 1
    
d1557 1
a1557 1
    
d1559 1
a1559 1
  
d1577 1
a1577 1
  
d1582 1
a1582 1
  
d1584 1
a1584 1
  
d1605 1
a1605 1
 * 
d1612 1
a1612 1
  
d1616 1
a1616 1
  
d1626 1
a1626 1
  
d1634 1
a1634 1
  shamanok = 0; 
d1642 1
a1642 1
  
d1652 2
a1653 2
    sprintf(buf, "%s%-16.16s ", buf, 
	    strip_ansi(pc_class_types[CLASS_WARRIOR])); 
d1657 1
a1657 1
    sprintf(buf, "%s%-16.16s ", buf,     
d1662 2
a1663 2
    sprintf(buf, "%s%-16.16s ", buf, 
	    strip_ansi(pc_class_types[CLASS_SORCERER])); 
d1667 1
a1667 1
    sprintf(buf, "%s%-16.16s ", buf, 
d1672 1
a1672 1
    sprintf(buf, "%s%-16.16s", buf, 
d1683 1
a1683 1
	sprintf(buf, "%s%s%-15.15s ", buf, 
d1690 1
a1690 1
	sprintf(buf, "%s%s%-15.15s ", buf, 
d1697 1
a1697 1
	sprintf(buf, "%s%s%-15.15s ", buf, 
d1704 1
a1704 1
	sprintf(buf, "%s%s%-15.15s", buf, 
d1709 1
a1709 1
    
d1721 1
a1721 1
  
d1728 1
a1728 1
  
d1740 1
a1740 1
  
d1744 1
a1744 1
  
d1754 1
a1754 1
  
d1759 1
a1759 1
  
d1765 1
a1765 1
  
d1771 1
a1771 1
  
d1777 1
a1777 1
  
d1783 1
a1783 1
  
d1798 1
a1798 1
  
d1803 1
a1803 1
  
d1828 1
a1828 1
    
d1831 1
a1831 1
    
d1845 1
a1845 1
        } 
d1847 1
a1847 1
      } else if (!target) { 
d1868 1
a1868 1
  
d1877 1
a1877 1
  
d1880 1
a1880 1
    
d1885 1
a1885 1
    
d1889 1
a1889 1
    
d1893 1
a1893 1
    
d1900 1
a1900 1
    
d1907 1
a1907 1
  
d1911 1
a1911 1
  
d1921 1
a1921 1
  
d1944 1
a1944 1
  
d1966 1
a1966 1
      
d1987 1
a1987 1
      
d2072 1
a2072 1
  };  
d2075 1
a2075 1
  
d2082 1
a2082 1
  
d2182 1
a2182 1
            if (color) 
d2214 3
a2216 3
            /* Take a character name that is a word in the dictionary or 
               closely resembles a word in the dictionary and make them 
               think it's a valid existing character name and boot the 
d2220 2
a2221 2
            log(buf);	  
            SEND_TO_Q("Welcome back!\r\n",d);        
d2285 2
a2286 2
         STATE(d) = CON_NAME_CHECK;    
         SEND_TO_Q(NAMES_EXPLANATION, d);    
d2297 1
a2297 1
      
d2325 1
a2325 1
    if (!Valid_Name(arg)) 
d2376 1
a2376 1
    
d2378 1
a2378 1
    
d2398 1
a2398 1
      
d2431 1
a2431 1
      
d2436 1
a2436 1
      
d2454 1
a2454 1
    
d2465 1
a2465 1
    
d2471 1
a2471 1
    
d2473 1
a2473 1
    
d2487 1
a2487 1
    
d2498 1
a2498 1
    
d2500 1
a2500 1
    
d2519 1
a2519 1
      SEND_TO_Q("\r\nRace: ", d); 
d2525 1
a2525 1
    display_classes(d,1); 
d2532 1
a2532 1
    display_classes(d, 1); 
d2541 1
a2541 1
      SEND_TO_Q("\r\nRace: ", d); 
d2546 1
a2546 1
    display_classes(d,1); 
d2616 1
a2616 1
      for(i=0;i<NUM_CLASSES;i++) 
d2625 1
a2625 1
      
d2628 1
a2628 1
    
d2633 1
a2633 1
    
d2641 1
a2641 1
    
d2652 1
a2652 1
    
d2660 1
a2660 1
    
d2666 1
a2666 1
    
d2677 2
a2678 2
      GET_DIETY(d->character) = load_result;            
    break; 
d2681 1
a2681 1
    
d2690 2
a2691 2
      
      
d2696 1
a2696 1
	      "	Dex:  %s		Char: %s\r\r\r\r\n", 
d2698 2
a2699 2
	      rolls_abils_result[roll_table[0]], 
	      rolls_abils_result[roll_table[1]], rolls_abils_result[roll_table[3]], 
d2705 1
a2705 1
      
d2707 2
a2708 2
		 
    
d2722 2
a2723 2
    
    
d2734 2
a2735 2
    
    
d2748 1
a2748 1
   
d2804 1
a2804 1
    
d2816 1
a2816 1
      
d2834 1
a2834 1
      
d2852 1
a2852 1
      
d2857 1
a2857 1
      
d2866 1
a2866 1
      STATE(d) = CON_MENU;      
d2906 1
a2906 1
    
d2936 1
a2936 1
    
d2940 1
a2940 1
    
d2953 1
a2953 1
  
d2960 1
a2960 1
  
d2971 1
a2971 1
  int statts[6]; 
d2973 2
a2974 2
  
  
d2981 1
a2981 1
  
d2994 1
a2994 1
  
d3003 1
a3003 1
  switch(arg) 
d3049 1
a3049 1
   
d3055 2
a3056 2
   
   if (!PLR_FLAGGED(d->character, PLR_NEWNAME))   
d3060 1
a3060 1
   
d3063 1
a3063 1
  
d3082 1
a3082 1
   } 
d3087 1
a3087 1
   
d3098 1
a3098 1
   * first, count commands (num_of_commands is actually one greater than 
d3133 5
d3796 1
a3796 1
 * This fixes all of the warnings associated with the new compiler and 
d3801 1
a3801 1
 * xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0 
d3835 1
a3835 1
 * Revision 1.28  1999/04/07 18:12:04  jen 
d3843 1
a3843 1
 * 
d3849 1
a3849 1
 * Revision 1.25  1999/03/26 19:44:35  jen  
@


1.251
log
@Added a movement subcommand of 'stay', which is most useful when
misdirecting your movements.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.250 2008/03/09 08:57:56 jps Exp jps $
a110 1
ACMD(do_bodyslam);
d287 1
d426 1
a426 1
  { "bash"     , POS_FIGHTING, do_bash     , 1, 0, 0 },
d428 1
a428 1
  { "bodyslam" , POS_FIGHTING, do_bodyslam , 1, 0, 0 },
d593 1
a593 1
  { "hitall"   , POS_FIGHTING, do_hitall   , 0, 0, 0 },
d598 1
d646 1
d757 1
a757 1
  { "roar"     , POS_FIGHTING, do_roar     , 0, 0, 0 },
d841 1
a841 1
  { "stomp"    , POS_STANDING, do_action   , 0, 0, 0 },
d858 1
d3133 4
@


1.250
log
@Also allow 'look' during minor paralysis.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.249 2008/03/09 08:52:21 jps Exp jps $
d396 1
d3130 3
@


1.249
log
@Fix typos and make sure that the return command is available when paralyzed.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.248 2008/03/09 06:38:37 jps Exp jps $
d626 1
a626 1
  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST | CMD_OLC },
d3129 3
@


1.248
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.247 2008/03/09 04:01:55 jps Exp jps $
d751 1
a751 1
  { "return"   , POS_DEAD    , do_return   ,-1, 0, 0 },
d1109 1
a1109 1
    send_to_char("&6Your paralyzed to the bone!\r\n&0", ch);
d1112 1
a1112 1
    send_to_char("&6Your paralyzed to the bone!\r\n&0", ch);
d3129 5
@


1.247
log
@Don't apply mob_spec to mobs with MOB2_NOSCRIPT flag.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.246 2008/03/08 20:18:09 jps Exp jps $
d2000 24
d2175 1
a2175 1
            d->character->player.name = strdup(CAP(tmp_name));
d2231 1
a2231 1
         d->character->player.name = strdup(CAP(tmp_name));
d2297 1
a2297 2
         free(d->character->player.name);
         d->character->player.name = NULL;
d2338 1
a2338 2

         d->character->player.name = strdup(CAP(arg));
d2341 1
a2341 3
         if (d->character->player.name)
           free(d->character->player.name);
         d->character->player.name = strdup(CAP(arg));
d2351 1
a2351 1
      broadcast_name(d->character->player.name);
d2555 1
a2555 2
         free(d->character->player.name);
         d->character->player.name = NULL;
d2776 1
a2776 1
            broadcast_name(d->character->player.name);
d3129 3
@


1.246
log
@Added 'pscan' command so you can see how many of a type of object
are saved in player object files.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.245 2008/03/05 05:21:56 myc Exp jps $
d1770 1
a1770 1
    if (GET_MOB_SPEC(k) != NULL)
d3110 4
@


1.245
log
@Removed char_file_u function declarations.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.244 2008/03/05 03:03:54 myc Exp myc $
d232 1
d237 5
a271 5
ACMD(do_quest);
ACMD(do_qadd);
ACMD(do_qdel);
ACMD(do_qlist);
ACMD(do_qstat);
a717 1
/*{ "practice" , POS_RESTING , do_practice , 1, 0, 0},*/
d719 1
d3110 3
@


1.244
log
@Changed alias structures, and updated all alias functions.  Player
files are now ascii format so they are loaded differently than before.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.243 2008/02/24 17:31:13 myc Exp myc $
a56 1
extern void save_char_file_u(struct char_file_u st);
a2029 2
  int load_char(char *name, struct char_file_u *char_element);

d3109 4
@


1.243
log
@You can now execute certain actions by preceding them with a ~
in OLC if the command is marked CMD_OLC (or CMD_ANY).
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.242 2008/02/16 20:31:32 myc Exp myc $
d41 1
a63 2
void init_player(struct char_data *ch);
int create_entry(char *name);
a178 1
ACMD(do_home);
d1156 1
a1156 1
int find_alias(struct char_data *ch, char *str)
d1158 3
a1160 1
  int a_num;
d1162 1
a1162 9
  for(a_num = 0; a_num < NUM_ALIASES; a_num++) {

    if(GET_ALIAS_NUM(ch, a_num)) {
      if (str_cmp(str, GET_ALIAS_NUM(ch, a_num)) == 0) {
	return a_num;
      }
    }
  }
  return ALIAS_NONE;
d1165 1
a1165 2
/* This is no longer used --Fingon
void free_alias(struct alias *a)
d1173 8
a1180 1
*/
d1187 1
a1187 1
  int a_num, found = FALSE;
d1194 1
a1194 1
  if (!*arg) {		
d1198 3
a1200 4
    for(a_num = 0; a_num < NUM_ALIASES; a_num++) {
      if(GET_ALIAS_TYPE(ch, a_num) != ALIAS_NONE) {
	found = TRUE;
	sprintf(buf, "%-15s %s\r\n", GET_ALIAS_NUM(ch, a_num), GET_ALIAS_REPL(ch, a_num));
d1203 1
a1203 3
    }

    if (found == FALSE) {
d1205 3
a1207 1
    }
a1208 2
  } else {			
    /* otherwise, add or remove aliases */
d1210 4
d1215 1
a1215 1
    a_num = find_alias(ch, arg);
a1217 1

d1219 1
a1219 1
      if (a_num == ALIAS_NONE) {
d1221 1
a1221 1
      } else {
d1223 2
a1224 6
	strcpy(GET_ALIAS_NUM(ch, a_num), "\0");
	strcpy(GET_ALIAS_REPL(ch, a_num), "\0");
	GET_ALIAS_TYPE(ch, a_num) = ALIAS_NONE;
      }

    } else {			
d1234 2
a1235 20

      if(a_num == ALIAS_NONE) {
	a_num = 0;
	while((GET_ALIAS_TYPE(ch, a_num) != ALIAS_NONE)) {
	  if (a_num == NUM_ALIASES) {
	    send_to_char("You can't have any more aliases.\r\n", ch);
	    return;
	  }
	  a_num++;
	}
      }
      if(strlen(repl) >= MAX_REPLACE_LENGTH) {
	send_to_char("Aliasing yes, scripting no. Shorter please.\r\n", ch);
        return;
      }
      if(strlen(arg) >= MAX_ALIAS_LENGTH) {
        send_to_char("Aliases are supposed to be short silly.\r\n", ch);
        return;
      }
      strcpy(GET_ALIAS_NUM(ch, a_num), arg);
d1237 1
a1237 1
      strcpy(GET_ALIAS_REPL(ch, a_num), repl);
d1239 1
a1239 1
	GET_ALIAS_TYPE(ch, a_num) = ALIAS_COMPLEX;
d1241 3
a1243 1
	GET_ALIAS_TYPE(ch, a_num) = ALIAS_SIMPLE;
d1257 1
a1257 1
void perform_complex_alias(struct char_data *ch, struct txt_q *input_q, char *orig, int a_num)
d1275 1
a1275 1
  for (temp = GET_ALIAS_REPL(ch, a_num); *temp; temp++) {
d1320 9
a1328 1
  int a_num;
d1338 1
a1338 1
  if ((a_num = find_alias(d->character, first_arg)) == ALIAS_NONE)
d1341 2
a1342 2
  if (GET_ALIAS_TYPE(d->character, a_num) == ALIAS_SIMPLE) {
    strcpy(orig, GET_ALIAS_REPL(d->character, a_num));
d1345 1
a1345 1
    perform_complex_alias(d->character, &d->input, ptr, a_num);
d1980 1
a1980 1
      
a2007 3
  char sys_command[512];
  struct char_file_u tmp_store;
  extern void delete_player_from_index(char *name);
a2019 1
  extern int delete_player(char *name);
d2137 1
a2137 1
         SEND_TO_Q("a> Invalid name, please try another.\r\n"
d2142 27
a2168 1
      player_i = load_char(tmp_name, &tmp_store);
d2170 2
a2171 7
      /* WTF!? A player is level 0?! Remove them from index before they crash the mud! */
      if (player_i > -1 && tmp_store.level == 0) {
         sprintf(buf,"SYSERR: Deleted level zero ch %s from player index.", tmp_name); 
         log(buf);
         delete_player_from_index(tmp_name);
         player_i = -1;
      }
d2173 4
a2176 15
      /* See if a deleted player's file was loaded... */
      if (player_i > -1 && PLR_FLAGGED(d->character, PLR_DELETED)) {
         free_char(d->character);
         CREATE(d->character, struct char_data, 1);
         clear_char(d->character);
         CREATE(d->character->player_specials, struct player_special_data, 1);
         d->character->desc = d;
         CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
         strcpy(d->character->player.name, CAP(tmp_name));
         GET_PFILEPOS(d->character) = player_i;

         if (color) 
            SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
         else
            REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
d2178 5
a2182 4
         sprintf(buf, "\r\nDo you want to make a new character called %s? ", tmp_name);
         SEND_TO_Q(buf, d);
         STATE(d) = CON_NAME_CNFRM;
         return;
d2184 2
a2185 3

      /* No player loaded: we might make a new character. */
      if (player_i == -1) {
d2188 5
a2192 5
           /* Take a character name that is a word in the dictionary or closely
              resembles a word in the dictionary and make them think it's a 
              valid existing character name and boot the connection.  Yes I'm
              evil - RSD 8/29/2002 <-- genius
           */
d2204 1
a2204 1
            SEND_TO_Q("b> Invalid name, please try another.\r\n", d);
d2209 1
a2209 2
         CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
         strcpy(d->character->player.name, CAP(tmp_name));
a2213 1
         return;
a2216 21
      /* An existing player's name was entered, and the pfile was successfully loaded */

      if (PRF_FLAGGED(d->character, PRF_COLOR_1))
         color = 1;

      store_to_char(&tmp_store, d->character);
      GET_PFILEPOS(d->character) = player_i;

      /* undo it just in case they are set */
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING | PLR_MAILING | PLR_CRYO);

      if (color)
         SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
      else
         REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);

      SEND_TO_Q("Password: ", d);
      echo_off(d);
      d->idle_tics = 0;
      STATE(d) = CON_PASSWORD;

d2245 1
a2245 1
         get_filename(GET_NAME(d->character), buf, PLR_FILE);
d2251 1
a2251 1
         get_filename(GET_NAME(d->character), buf, CRASH_FILE);
d2295 1
a2295 1
    if ((player_i = load_char(tmp_name, &tmp_store)) > -1) {
a2311 4
         /* Load the player from the pfile */
         load_char(GET_NAME(d->character), &tmp_store);
         strcpy(tmp_store.name, arg);

d2316 3
a2318 25
         sprintf(sys_command, "mv %s", get_fname(GET_NAME(d->character), CRASH_FILE));
         sprintf(sys_command, "%s %s", sys_command, get_fname(arg, CRASH_FILE));
         system(sys_command);
         sprintf(sys_command, "mv %s", get_fname(GET_NAME(d->character), PLR_FILE));
         sprintf(sys_command, "%s %s", sys_command, get_fname(arg, PLR_FILE));
         system(sys_command);

         /* change the name in the text player index file */
         modify_player_index_file(GET_NAME(d->character), arg);

         /* change the name in this big ass list whatever it's for */
         for (i = 0; i <= top_of_p_table; i++) {
            if (!str_cmp(((player_table) + i)->name, GET_NAME(d->character))) {
               free(((player_table)+i)->name);
               CREATE(((player_table)+i)->name, char, strlen(tmp_store.name) + 1);
               strcpy(((player_table)+i)->name, tmp_store.name);
            }
         }
         char_to_store(d->character, &tmp_store);
         save_char_file_u(tmp_store);
	 
         if (d->character->player.name)
           free(d->character->player.name);
         CREATE(d->character->player.name, char, strlen(arg) + 1);
         strcpy(d->character->player.name, CAP(arg));
d2323 1
a2323 2
         CREATE(d->character->player.name, char, strlen(arg) + 1);
         strcpy(d->character->player.name, CAP(arg));
d2767 1
a2767 1
               GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
d2897 4
a2900 1
      delete_player(GET_NAME(d->character));
d3029 1
a3029 1
  if (d->character->desc == NULL)
d3033 1
a3033 1
     GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
d3112 4
@


1.242
log
@Moving command sorting code here from act.informative.c.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.241 2008/02/13 21:27:31 myc Exp myc $
d392 6
a397 6
  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH , CMD_HIDE },
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST  , CMD_HIDE },
  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH , CMD_HIDE },
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST  , CMD_HIDE },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP    , CMD_HIDE },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN  , CMD_HIDE },
d416 1
a416 1
  { "ask"      , POS_RESTING , do_spec_comm, 0, SCMD_ASK, 0 },
d473 1
a473 1
  { "consent"  , POS_INCAP   , do_consent  , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_CAST },
d492 1
a492 1
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND},
d496 1
a496 1
  { "dig"      , POS_DEAD    , do_dig      , LVL_BUILDER, 0, CMD_ANY },
d515 2
a516 2
  { "emote"    , POS_RESTING , do_echo     , 1, SCMD_EMOTE, 0 },
  { ":"        , POS_RESTING , do_echo     , 1, SCMD_EMOTE, 0 },
d521 2
a522 2
  { "exits"    , POS_RESTING , do_exits    , 0, 0, CMD_HIDE | CMD_MEDITATE },
  { "examine"  , POS_RESTING , do_examine  , 0, 0, CMD_HIDE },
d558 1
a558 1
  { "glance"   , POS_RESTING , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND },
d563 2
a564 2
  { "go"       , POS_STANDING, do_move     , 0, 0, CMD_HIDE },
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP, CMD_MEDITATE | CMD_CAST | CMD_HIDE },
d567 1
a567 1
  { "group"    , POS_SLEEPING, do_group    , 1, 0, CMD_HIDE },
d587 1
a587 1
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_HEAD_C, 0, CMD_ANY },
d604 1
a604 1
  { "identify" , POS_RESTING , do_identify , 0, 0, CMD_HIDE },
d628 1
a628 1
  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK, CMD_MEDITATE | CMD_HIDE | CMD_BOUND | CMD_CAST },
d641 2
a642 2
  { "linkload" , POS_DEAD    , do_linkload , LVL_HEAD_C, 0, CMD_ANY },
  { "load"     , POS_DEAD    , do_load     , LVL_ATTENDANT, 0, CMD_ANY },
d700 1
a700 1
  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_OVERLORD, SCMD_PARDON , CMD_ANY },
d730 2
a731 2
  { "qui"      , POS_DEAD    , do_quit     ,-1, 0, CMD_ANY ^ CMD_CAST },
  { "quit"     , POS_DEAD    , do_quit     , 0, SCMD_QUIT, CMD_ANY ^ CMD_CAST },
d748 4
a751 4
  { "restore"  , POS_DEAD    , do_restore  , LVL_RESTORE, 0, 0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_RESTORE, 0, 0 },
  { "pain"     , POS_DEAD    , do_pain     , LVL_RESTORE, 0, 0 },
  { "rpain"    , POS_DEAD    , do_rpain    , LVL_RESTORE, 0, 0 },
d768 2
a769 2
  { "say"      , POS_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND },
  { "'"        , POS_RESTING , do_say      , 0, 0, CMD_MINOR_PARA | CMD_BOUND },
d787 1
a787 1
  { "shout"    , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT, 0 },
d848 1
a848 1
  { "switch"   , POS_DEAD    , do_switch   , LVL_GOD, 0, CMD_ANY },
d929 1
a929 1
  { "whisper"  , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER, 0 },
d937 2
a938 2
  { "wiznet"   , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0, 0 },
  { ";"        , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0, 0 },
d1099 7
d2051 15
d2075 17
a2091 1
  
a2092 28
    /*. OLC states .*/
  case CON_OEDIT: 
    oedit_parse(d, arg);
    break;
  case CON_REDIT: 
    redit_parse(d, arg);
    break;
  case CON_ZEDIT: 
    zedit_parse(d, arg);
    break;
  case CON_MEDIT: 
    medit_parse(d, arg);
    break;
  case CON_SEDIT: 
    sedit_parse(d, arg);
    break;
  case CON_HEDIT: 
    hedit_parse(d, arg);
    break;
  case CON_TRIGEDIT:
    trigedit_parse(d, arg);
    break;
  case CON_SDEDIT:
    sdedit_parse(d, arg);
    break;
    /*. End of OLC states .*/
    
    
d3167 3
@


1.241
log
@Make it so you don't get the Welcome to Fierymud message twice when
logging in.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.240 2008/02/11 21:04:01 myc Exp myc $
d370 4
a373 5
/***************************************************************************
 * void do_layhand(struct char_data *ch, char *arg, int cmd);
 * void do_first_aid(struct char_data *ch, char *arg, int cmd);
 * void do_summon_mount(struct char_data *ch, char *arg, int cmd);
 ***************************************************************************/
d3115 40
d3157 4
@


1.240
log
@Removing a few unused spec-proc command placeholders: home, pull, and
push.  Making the stone, appear, and disappear placeholders 'invisible'
on the commands and hints list.  Also making hunt and qui invisible.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.239 2008/02/10 20:30:03 myc Exp myc $
a2001 1
  send_to_char(WELC_MESSG, d->character);
d3118 5
@


1.239
log
@Adding notes to the delete_doubledollar function so we actually
know what it does.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.238 2008/02/09 21:07:50 myc Exp myc $
d415 1
a415 1
  { "appear"   , POS_STANDING, do_not_here , 1, 0, 0 },
a597 1
  { "home"     , POS_DEAD    , do_not_here , LVL_IMMORT, 0, 0 },
d600 1
a600 1
  { "hunt"     , POS_STANDING, do_hunt     , 0, 0, 0 },
a725 2
  { "pull"     , POS_RESTING , do_not_here , 0, 0, 0 },
  { "push"     , POS_RESTING , do_not_here , 0, 0, 0 },
d731 1
a731 1
  { "qui"      , POS_DEAD    , do_quit     , 0, 0, CMD_ANY ^ CMD_CAST },
d851 1
a851 1
  { "stone"    , POS_STANDING, do_not_here , 1, 0, 0 },
d3119 4
@


1.238
log
@Instead of creating a name_timeout_event object for name approval
timeouts, we'll just pass the descriptor itself to the event,
saving us a tiny bit of memory.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.237 2008/02/09 18:29:11 myc Exp myc $
d1475 8
d1486 2
a1487 1
  
d1491 1
d1494 1
d1496 1
a1496 1
    if ((*(write++) = *(read++)) == '$')
d1498 1
a1498 1
	read++;
d3122 5
@


1.237
log
@The event code now handles freeing of event objects.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.236 2008/02/09 07:05:37 myc Exp myc $
a2010 1
  struct name_timeout_event *name_event;
d2371 1
a2371 3
      CREATE(name_event, struct name_timeout_event, 1);
      name_event->d = d;
      event_create(EVENT_NAME_TIMEOUT, name_timeout, name_event, NULL, NAME_TIMEOUT);
d2797 1
a2797 3
            CREATE(name_event, struct name_timeout_event, 1);
            name_event->d = d;
            event_create(EVENT_NAME_TIMEOUT, name_timeout, name_event, NULL, NAME_TIMEOUT);
d3063 1
a3063 1
   struct name_timeout_event *event = (struct name_timeout_event *) event_obj;
d3065 1
a3065 1
   if (STATE(event->d) != CON_NAME_WAIT_APPROVAL)
d3068 1
a3068 1
  if (event->d->character->desc == NULL)
d3071 2
a3072 2
   if (GET_PFILEPOS(event->d->character) < 0)
     GET_PFILEPOS(event->d->character) = create_entry(GET_NAME(event->d->character));
d3074 2
a3075 2
   if (!PLR_FLAGGED(event->d->character, PLR_NEWNAME))   
     init_player(event->d->character);
d3077 1
a3077 1
   save_player(event->d->character);
d3079 2
a3080 2
   if (!PLR_FLAGGED(event->d->character, PLR_NAPPROVE))
     SET_BIT(PLR_FLAGS(event->d->character), PLR_NAPPROVE);
d3082 1
a3082 1
   if (!PLR_FLAGGED(event->d->character, PLR_NEWNAME)) {
d3087 5
a3091 5
     SEND_TO_Q("You have been auto-approved.\r\n", event->d);
     SEND_TO_Q(motd, event->d);
     SEND_TO_Q("\r\n\n*** PRESS RETURN: ", event->d);
     if (PLR_FLAGGED(event->d->character, PLR_NEWNAME)) {
       sprintf(buf, "%s [%s] has connected with a new name.", GET_NAME(event->d->character), event->d->host);
d3093 1
a3093 1
       REMOVE_BIT(PLR_FLAGS(event->d->character), PLR_NEWNAME);
d3095 1
a3095 1
       sprintf(buf, "%s [%s] new player.", GET_NAME(event->d->character), event->d->host);
d3098 1
a3098 1
     STATE(event->d) = CON_RMOTD;
d3101 2
a3102 2
   if (PLR_FLAGGED(event->d->character, PLR_NEWNAME))
     REMOVE_BIT(PLR_FLAGS(event->d->character), PLR_NEWNAME);
d3111 3
@


1.236
log
@Copyover is now renamed to hotboot.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.235 2008/02/09 06:19:44 jps Exp myc $
d3070 2
a3071 5
   if (STATE(event->d) != CON_NAME_WAIT_APPROVAL) {
     free(event_obj);
     event_obj=NULL;
     return 0;
   }
d3073 2
a3074 5
  if (event->d->character->desc == NULL) {
     free(event_obj);
     event_obj=NULL;
     return 0;
  }
d3108 2
a3109 3
   free(event_obj);
   event_obj=NULL;
   return 0;
d3116 3
@


1.235
log
@Add "nohints" toggle for whether you receive command suggestions
after entering a typo.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.234 2008/02/09 04:27:47 myc Exp jps $
a126 1
ACMD(do_copyover);
d181 1
a475 1
  { "copyover" , POS_DEAD    , do_copyover , LVL_REBOOT_MASTER, 0, 0 },
d599 1
d3123 4
@


1.234
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.233 2008/02/09 03:06:17 myc Exp myc $
d1078 19
a1096 15
    /* Display similar commands. */
    for (cmd = 0; *cmd_info[cmd].command != '\n'; ++cmd) {
      if (*arg != *cmd_info[cmd].command)
        continue;
      if (cmd_info[cmd].minimum_level > GET_LEVEL(ch))
        continue;
      if (cmd_info[cmd].minimum_level < 0)
        continue;
      /* skip socials */
      if (cmd_info[cmd].command_pointer == do_action)
        continue;
      if (levenshtein_distance(arg, cmd_info[cmd].command) <= 2) {
        if (!found) {
          send_to_char("\r\nDid you mean:\r\n", ch);
          found = TRUE;
a1097 2
        sprintf(buf, "  %s\r\n", cmd_info[cmd].command);
        send_to_char(buf, ch);
d3123 3
@


1.233
log
@Adding the 'copyover' command, which allows you to do a hot-boot
without disconnecting anybody.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.232 2008/02/06 21:53:53 myc Exp myc $
d40 1
d3121 4
@


1.232
log
@Adding exit search as part of the vsearch command suite.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.231 2008/02/05 04:22:42 myc Exp myc $
d126 1
a126 1
ACMD(do_copyto);
d475 1
d1942 56
a2008 3
  extern int r_mortal_start_room;
  extern int r_immort_start_room;
  extern int r_frozen_start_room;
a2028 1
  int load_room;
d2815 2
d2835 2
a2836 37
      reset_char(d->character);
      if (PLR_FLAGGED(d->character, PLR_INVSTART))
	GET_INVIS_LEV(d->character) = GET_LEVEL(d->character);
      GET_RACE_ALIGN(d->character) = races[(int)GET_RACE(d->character)].racealign;
      if ((load_room = GET_LOADROOM(d->character)) != NOWHERE)
	load_room = real_room(load_room);
      
      /* If char was saved with NOWHERE, or real_room above failed... */
      if (load_room == NOWHERE) {
	if (GET_LEVEL(d->character) >= LVL_IMMORT) {
	  load_room = real_room(GET_HOME(d->character));
	  if (load_room < 0) {
	    log("SYSERR:  A Immortal start room does not exis.");
	    load_room = r_immort_start_room;
	  }
	} else {
	  load_room = real_room(GET_HOME(d->character));
	  if (load_room < 0) {
	    log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
	    load_room = r_mortal_start_room;
	  }
	}
      }
      
      if (PLR_FLAGGED(d->character, PLR_FROZEN))
	
	load_room = r_frozen_start_room;
      
      char_to_room(d->character, load_room);
      if ((load_result = Crash_load(d->character)))
 	if (GET_LEVEL(d->character) < LVL_IMMORT &&
 	    !PLR_FLAGGED(d->character, PLR_FROZEN)) {
 	  char_from_room(d->character);
 	  char_to_room(d->character, load_room);
 	}
      GET_ID(d->character) = GET_IDNUM(d->character);
      save_player(d->character);
a2837 2
      d->character->next = character_list;
      character_list = d->character;
d2844 1
a2844 1
   give_newbie_eq(d->character);
d3120 3
@


1.231
log
@Removing the listexp, listclass, and listrace commands.  Their
functionality is now part of the show command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.230 2008/02/05 03:07:26 myc Exp myc $
d316 2
a323 1
ACMD(do_csearch);
d527 3
d3102 4
@


1.230
log
@Shortening all the vsearch command function names.  Adding
csearch and ssearch.  Moving slist and snum to the vsearch
command system.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.229 2008/02/04 01:48:53 myc Exp myc $
a202 2
ACMD(do_listclass);
ACMD(do_listrace);
a203 1
ACMD(do_listexp);
a633 2
  { "listclass", POS_DEAD    , do_listclass, LVL_ATTENDANT, 0, CMD_ANY },
  { "listrace" , POS_DEAD    , do_listrace , LVL_ATTENDANT, 0, CMD_ANY },
a634 1
  { "listexp"  , POS_DEAD    , do_listexp  , LVL_ATTENDANT, 0, CMD_ANY },
d3098 5
@


1.229
log
@Removing the old implementations of znum and zlist.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.228 2008/02/04 01:46:12 myc Exp myc $
a270 1
ACMD(do_snum);
d319 7
a325 6
ACMD(do_vsearch_mobile);
ACMD(do_vsearch_object);
ACMD(do_vsearch_room);
ACMD(do_vsearch_shop);
ACMD(do_vsearch_trigger);
ACMD(do_vsearch_zone);
d482 2
d665 3
a667 3
  { "mlist"    , POS_DEAD    , do_vsearch_mobile, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "mnum"     , POS_DEAD    , do_vsearch_mobile, LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "msearch"  , POS_DEAD    , do_vsearch_mobile, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d691 3
a693 3
  { "olist"    , POS_DEAD    , do_vsearch_object, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "onum"     , POS_DEAD    , do_vsearch_object, LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "osearch"  , POS_DEAD    , do_vsearch_object, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d765 3
a767 3
  { "rlist"    , POS_DEAD    , do_vsearch_room, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "rnum"     , POS_DEAD    , do_vsearch_room, LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "rsearch"  , POS_DEAD    , do_vsearch_room, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d807 3
a809 3
  { "slist"    , POS_DEAD    , do_vsearch_shop, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "snum"     , POS_DEAD    , do_snum     , LVL_ATTENDANT, 0, CMD_ANY },
  { "ssearch"  , POS_DEAD    , do_vsearch_shop, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d954 2
a955 2
  { "zlist"    , POS_DEAD    , do_vsearch_zone, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "znum"     , POS_DEAD    , do_vsearch_zone, LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
d957 1
a957 1
  { "zsearch"  , POS_DEAD    , do_vsearch_zone, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d968 3
a970 3
  { "tlist"    , POS_DEAD    , do_vsearch_trigger, LVL_ATTENDANT, SCMD_VLIST, CMD_ANY },
  { "tnum"     , POS_DEAD    , do_vsearch_trigger, LVL_ATTENDANT, SCMD_VNUM, CMD_ANY },
  { "tsearch"  , POS_DEAD    , do_vsearch_trigger, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d3104 3
@


1.228
log
@Removing the *find aliases for *search.  Too much command spam.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.227 2008/02/03 08:46:52 myc Exp myc $
a338 1
ACMD(do_znum);
a339 1
ACMD(do_zlist);
d3102 3
@


1.227
log
@Don't display socials for the 'did you mean' command list.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.226 2008/02/02 19:38:20 myc Exp myc $
a667 1
  { "mfind"    , POS_DEAD    , do_vsearch_mobile, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
a693 1
  { "ofind"    , POS_DEAD    , do_vsearch_object, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
a767 1
  { "rfind"    , POS_DEAD    , do_vsearch_room, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
a809 1
  { "sfind"    , POS_DEAD    , do_vsearch_shop, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
a912 1
  { "vfind"    , POS_DEAD    , do_vsearch  , LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d954 2
a955 1
  { "znum"     , POS_DEAD    , do_znum     , LVL_ATTENDANT, 0, CMD_ANY },
d957 1
a957 1
  { "zlist"    , POS_DEAD    , do_zlist    , LVL_ATTENDANT, 0, CMD_ANY },
a970 1
  { "tfind"    , POS_DEAD    , do_vsearch_trigger, LVL_ATTENDANT, SCMD_VSEARCH, CMD_ANY },
d3104 3
@


1.226
log
@Title command is now available to mortals to switch between
'permanent titles'.  Added a levenshtein distance thingy to
the interpreter so if you misspell a command it says,
'Did you mean...' and lists a few suggestions.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.225 2008/02/02 04:27:55 myc Exp myc $
d1085 8
a1092 1
      if (*arg != *cmd_info[cmd].command || cmd_info[cmd].minimum_level > GET_LEVEL(ch))
d3109 6
@


1.225
log
@Changing delimited_arg so it doesn't skip fill words.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.224 2008/01/29 21:02:31 myc Exp myc $
d881 1
a881 1
  { "title"    , POS_DEAD    , do_title    , LVL_GOD, 0, CMD_ANY },
d1080 2
a1081 1
  if (*cmd_info[cmd].command == '\n')
d1083 14
d3102 3
@


1.224
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.223 2008/01/27 21:09:12 myc Exp myc $
d1518 1
a1518 4
  char *begin = first_arg;
  
  do {
    skip_spaces(&argument);
d1520 4
a1523 3
    first_arg = begin;
    
    if (*argument == delimiter) {
d1525 6
a1530 4
      while (*argument && *argument != delimiter) {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
a1531 5
    } else {
      while (*argument && !isspace(*argument)) {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
d1533 1
d1535 1
a1535 2
    *first_arg = '\0';
  } while (fill_word(begin));
d3087 4
@


1.223
log
@Add berserk command.  Replaced hit() with attack().
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.222 2008/01/27 13:43:50 jps Exp myc $
d39 1
a40 7
/*extern const struct title_type titles[NUM_CLASSES][LVL_IMPL + 1];*/
extern char *question1;
extern char *question2;
extern char *question3;
extern char *question4;
extern char *question5;
extern char *question6;
a48 4
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
a52 3
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct room_data *world;
a66 2
extern int class_ok_race[NUM_RACES][NUM_CLASSES];
extern char *char_hometown[];
a77 1
extern char *rolls_abils_result[];
a91 1
extern struct xname *xname_list;
d1004 1
a1004 1
char *fill[] =
d1016 1
a1016 1
char *reserved[] =
d1360 1
a1360 1
int searchblock(char *arg, char **list, bool exact)
d1384 1
a1384 1
int search_block(char *arg, char **list, bool exact)
d1386 1
a1386 1
  register int i, l;
a1390 4
  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));
  
d1396 3
a1398 2
    if (!l)
      l = 1;			/* Avoid "" to match the first available
d1401 1
a1401 1
      if (!strn_cmp(arg, *(list + i), (unsigned) l))
a3034 517
const char *iscommand[] =
{
  "north",			/* 1 */
  "east",
  "south",
  "west",
  "up",
  "down",
  "enter",
  "exits",
  "kiss",
  "get",
  "drink",			/* 11 */
  "eat",
  "wear",
  "wield",
  "look",
  "score",
  "say",
  "gshout",
  "tell",
  "inventory",
  "qui",			/* 21 */
  "bounce",
  "smile",
  "dance",
  "kill",
  "cast",
  "laugh",
  "giggle",
  "shake",
  "puke",
  "growl",			/* 31 */
  "scream",
  "insult",
  "comfort",
  "nod",
  "sigh",
  "sulk",
  "help",
  "who",
  "emote",
  "echo",			/* 41 */
  "stand",
  "sit",
  "rest",
  "sleep",
  "wake",
  "force",
  "transfer",
  "hug",
  "snuggle",
  "cuddle",			/* 51 */
  "nuzzle",
  "cry",
  "news",
  "equipment",
  "buy",
  "sell",
  "value",
  "list",
  "drop",
  "goto",			/* 61 */
  "weather",
  "read",
  "pour",
  "grab",
  "remove",
  "put",
  "shutdow",
  "save",
  "hit",
  "string",			/* 71 */
  "give",
  "quit",
  "stat",
  "innate",
  "time",
  "load",
  "purge",
  "shutdown",
  "idea",
  "typo",			/* 81 */
  "bug",
  "whisper",
  "cackle",
  "at",
  "ask",
  "order",
  "sip",
  "taste",
  "snoop",
  "follow",			/* 91 */
  "rent",
  "offer",
  "poke",
  "advance",
  "accuse",
  "grin",
  "bow",
  "open",
  "close",
  "lock",			/* 101 */
  "unlock",
  "mreport",
  "applaud",
  "blush",
  "burp",
  "chuckle",
  "clap",
  "cough",
  "curtsey",
  "fart",			/* 111 */
  "flip",
  "fondle",
  "frown",
  "gasp",
  "glare",
  "groan",
  "grope",
  "hiccup",
  "lick",
  "love",			/* 121 */
  "moan",
  "nibble",
  "pout",
  "purr",
  "ruffle",
  "shiver",
  "shrug",
  "sing",			/* 129 - special case for bards */
  "slap",
  "smirk",			/* 131 */
  "snap",
  "sneeze",
  "snicker",
  "sniff",
  "snore",
  "spit",
  "squeeze",
  "stare",
  "strut",
  "thank",			/* 141 */
  "twiddle",
  "wave",
  "whistle",
  "wiggle",
  "wink",
  "yawn",
  "snowball",
  "write",
  "hold",
  "flee",			/* 151 */
  "sneak",
  "hide",
  "backstab",
  "pick",
  "steal",
  "bash",
  "rescue",
  "kick",
  "french",
  "comb",			/* 161 */
  "massage",
  "tickle",
  "practice",
  "pat",
  "examine",
  "take",
  "info",
  "spells",
  "practise",
  "curse",			/* 171 */
  "use",
  "where",
  "levels",
  "reroll",
  "pray",
  ":",
  "beg",
  "bleed",
  "cringe",
  "dream",			/* 181 */
  "fume",
  "grovel",
  "hop",
  "nudge",
  "peer",
  "point",
  "ponder",
  "punch",
  "snarl",
  "spank",			/* 191 */
  "steam",
  "tackle",
  "taunt",
  "think",
  "whine",
  "worship",
  "yodel",
  "toggle",
  "wizmsg",
  "consider",			/* 201 */
  "group",
  "restore",
  "return",
  "switch",			/* 205 */
  "quaff",
  "recite",
  "sockets",
  "pose",
  "silence",
  "wizhelp",			/* 211 */
  "credits",
  "disband",
  "vis",
  "lflags",			/* 215 */
  "poofin",
  "wizlist",
  "display",
  "echoa",
  "demote",			/* 220 */
  "poofout",
  "circle",
  "balance",
  "wizlock",
  "deposit",			/* 225 */
  "withdraw",
  "ignore",
  "setattr",
  "title",
  "aggr",			/* 230 */
  "gsay",
  "consent",
  "setbit",
  "hitall",
  "trap",			/* 235 */
  "murder",
  "glance",
  "auction",
  "channel",
  "fill",			/* 240 */
  "ooc",
  "nokill",
  "page",
  "commands",
  "attributes",			/* 245 */
  "rules",
  "track",
  "analyze",
  "listen",
  "disarm",
  "pet",			/* 250 */
  "delete",
  "ban",
  "allow",
  "play",
  "move",			/* 255 */
  "bribe",
  "bonk",
  "calm",
  "rub",
  "censor",			/* 260 */
  "choke",
  "drool",
  "flex",
  "jump",
  "lean",			/* 265 */
  "moon",
  "ogle",
  "pant",
  "pinch",
  "push",			/* 270 */
  "scare",
  "scold",
  "seduce",
  "shove",
  "shudder",			/* 275 */
  "shush",
  "slobber",
  "smell",
  "sneer",
  "spin",			/* 280 */
  "squirm",
  "stomp",
  "strangle",
  "stretch",
  "tap",			/* 285 */
  "tease",
  "tip",
  "tweak",
  "twirl",
  "undress",			/* 290 */
  "whimper",
  "exchange",
  "release",
  "search",
  "join",			/* 295 */
  "camp",
  "secret",
  "lookup",
  "report",
  "split",			/* 300 */
  "world",
  "junk",
  "petition",
  "do",
  "'",				/* 305 */
  "caress",
  "bury",
  "donate",
  "shout",
  "disembark",			/* 310 */
  "panic",
  "nog",
  "twibble",
  "bleh",
  "lightning",			/* 315 */
  "sweep",
  "apologize",
  "afk",
  "lag",
  "touch",			/* 320 */
  "scratch",
  "wince",
  "toss",
  "flame",
  "arch",			/* 325 */
  "amaze",
  "bathe",
  "embrace",
  "brb",
  "ack",			/* 330 */
  "cheer",
  "snort",
  "eyebrow",
  "bang",
  "pillow",			/* 335 */
  "nap",
  "nose",
  "raise",
  "hand",
  "pull",			/* 340 */
  "tug",
  "wet",
  "mosh",
  "wait",
  "hi5",			/* 345 */
  "envy",
  "flirt",
  "bark",
  "whap",
  "roll",			/* 350 */
  "blink",
  "doh",
  "gag",
  "grumble",
  "dropkick",			/* 355 */
  "whatever",
  "fool",
  "noogie",
  "melt",
  "smoke",			/* 360 */
  "wheeze",
  "bird",
  "boggle",
  "hiss",
  "bite",			/* 365 */
  "teleport",
  "bandage",
  "blow",
  "bored",
  "bye",			/* 370 */
  "congratulate",
  "duck",
  "flutter",
  "goose",
  "gulp",			/* 375 */
  "halo",
  "hello",
  "hickey",
  "hose",
  "hum",			/* 380 */
  "impale",
  "jam",
  "kneel",
  "mourn",
  "protect",			/* 385 */
  "puzzle",
  "roar",
  "rose",
  "salute",
  "skip",			/* 390 */
  "swat",
  "tongue",
  "woops",
  "zone",
  "trip",			/* 395 */
  "meditate",
  "shapechange",
  "assist",
  "doorbash",
  "exp",			/* 400 */
  "rofl",
  "agree",
  "happy",
  "pucker",
  "spam",			/* 405 */
  "beer",
  "bodyslam",
  "sacrifice",
  "terminate",
  "cd",				/* 410 */
  "memorize",
  "forget",
  "headbutt",
  "shadow",
  "ride",			/* 415 */
  "mount",
  "dismount",
  "debug",
  "freeze",
  "bbl",			/* 420 */
  "gape",
  "veto",
  "jk",
  "tiptoe",
  "grunt",			/* 425 */
  "holdon",
  "imitate",
  "tango",
  "tarzan",
  "pounce",			/* 430 */
  "cheek",
  "layhands",
  "awareness",
  "firstaid",
  "springleap",			/* 435 */
  "feigndeath",
  "chant",
  "drag",
  "speak",
  "reload",			/* 440 */
  "dragonpunch",
  "revoke",
  "grant",
  "whod",
  "motd",			/* 445 */
  "zreset",
  "full",
  "welcome",
  "introduce",
  "sweat",			/* 450 */
  "mutter",
  "lucky",
  "ayt",
  "fidget",
  "fuzzy",			/* 455 */
  "snoogie",
  "ready",
  "plonk",
  "hero",
  "lost",			/* 460 */
  "clear",
  "flash",
  "curious",
  "hunger",
  "thirst",			/* 465 */
  "echoz",
  "ptell",
  "scribe",
  "teach",
  "reinitphys",			/* 470 */
  "finger",
  "accept",
  "decline",
  "summon",
  "clone",			/* 475 */
  "trophy",
  "zap",
  "alert",
  "recline",
  "knock",			/* 480 */
  "skills",
  "powercast",
  "berserk",
  "faq",
  "disengage",			/* 485 */
  "retreat",
  "inroom",
  "which",
  "revoketitle",
  "sethome",                    /* 490 */
  "notes",
  "wiznews",
  "abort",
  "ceasefire",
  "athrow",                     /* 495 */ 
  "afire",
  "throw",
  "fire",  
  "ammo",
  "wiztitle",		        /* 500 */
  "pfilemaint",
  "pain",
  "rpain",
  "gouge",
  "flanic",
  "glomp",
  "mumble",
  "twitch",
  "beckon",
  "glower",
  "\n"		
}; 


d3092 3
@


1.222
log
@Moved race and species-related data to races.h/races.c and merged species into races.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.221 2008/01/27 11:15:52 jps Exp jps $
d125 1
d454 1
d1846 1
a1846 1
              hit(attacker, k->character, TYPE_UNDEFINED);
d3629 3
@


1.221
log
@Renamed do_newbie to give_newbie_eq.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.220 2008/01/26 14:26:31 jps Exp jps $
a94 1
void scale_attribs(struct char_data * ch);
d3627 3
@


1.220
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.219 2008/01/23 05:13:26 jps Exp jps $
a101 1
void do_newbie(struct char_data *vict);
d2835 1
a2835 1
	do_newbie(d->character);
d3628 3
@


1.219
log
@Make "point" into a regular command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.218 2008/01/23 04:38:34 jps Exp jps $
d38 1
d3629 3
@


1.218
log
@Use the delay from instant kill to prevent another instant kill for
a while. NOT to prevent all commands during the next fight.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.217 2008/01/22 22:29:25 myc Exp jps $
d247 1
d729 1
a729 1
  { "point"    , POS_RESTING , do_action   , 0, 0, 0 },
d3628 4
@


1.217
log
@Removed attributes command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.216 2008/01/22 05:32:22 myc Exp myc $
a1058 6
  
  if (ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL] && FIGHTING(ch)) {
    act("You ARE too determined to kill $N at the moment.",
        FALSE, ch, 0, FIGHTING(ch), TO_CHAR);
    return;
  }
d3627 3
@


1.216
log
@Fixing a bug in is_integer.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.215 2008/01/17 01:29:10 myc Exp myc $
a282 1
ACMD(do_attributes);
a792 1
  { "attributes",POS_DEAD    , do_attributes, 0, 0, CMD_ANY },
d3633 3
@


1.215
log
@Replaced is_number with is_integer, is_positive_integer, and
is_negative_integer.  is_number is now a macro aliased to
is_positive_integer.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.214 2008/01/11 02:06:50 myc Exp myc $
d1451 1
a1451 1
  if (!str || (!isdigit(*str) && *str != '-'))
d1453 3
a1455 1
  ++str;
d3635 5
@


1.214
log
@Allow consent while incapacitated.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.213 2008/01/10 05:39:43 myc Exp myc $
d1434 2
a1435 1
int is_number(const char *str)
d1437 3
d1442 14
a1455 3
      return 0;
  
  return 1;
d1458 8
d3633 3
@


1.213
log
@The purge command is now 101 on test and 103 on production.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.212 2008/01/09 13:04:40 jps Exp myc $
d493 1
a493 1
  { "consent"  , POS_SLEEPING, do_consent  , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_CAST },
d3610 3
@


1.212
log
@Removed the "offer" command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.211 2008/01/05 21:55:32 jps Exp jps $
d748 1
a748 1
  { "purge"    , POS_DEAD    , do_purge    , LVL_GAMEMASTER, 0, CMD_ANY },
d3610 3
@


1.211
log
@Remove unused extern.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.210 2008/01/05 05:38:51 jps Exp jps $
a237 1
ACMD(do_offer);
a704 1
  { "offer"    , POS_STANDING, do_not_here , 1, 0, 0 },
d3610 3
@


1.210
log
@Changed name of save_char() to save_player().
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.209 2008/01/04 03:03:48 jps Exp jps $
a1948 1
  extern char *stats_display;
d3612 3
@


1.209
log
@Added msave command, so mobs can save players during triggers.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.208 2008/01/04 02:31:33 jps Exp jps $
d74 1
a74 2
void do_start(struct char_data *ch);
void init_char(struct char_data *ch);
d2299 1
a2299 1
         save_char(d->character);
d2347 1
a2347 1
	save_char(d->character);
d2453 1
a2453 1
      save_char(d->character);
d2754 2
a2755 2
            init_char(d->character);
            save_char(d->character);
d2770 1
a2770 1
      save_char(d->character);
d2810 1
a2810 1
      save_char(d->character);
d2818 1
a2818 1
	do_start(d->character);
d3576 1
a3576 1
     init_char(event->d->character);
d3578 1
a3578 1
   save_char(event->d->character);
d3613 3
d3645 1
a3645 1
 * save_char() no longer requries you to supply a save/load room
@


1.208
log
@The race selection menu is dynamic, so there is only a need for one
race-selection state.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.207 2008/01/04 01:53:26 jps Exp jps $
d387 1
d1011 1
d3614 4
@


1.207
log
@Added races.h file and created global array "races" for much
race-related information.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.206 2008/01/03 12:44:03 jps Exp jps $
a1947 2
  extern char *race_menu;
  extern char *good_race_menu;
d2477 2
a2478 7
    if(good_races_allowed) {
      SEND_TO_Q(good_race_menu, d);
      SEND_TO_Q("\r\nRace: ", d); 
      STATE(d) = CON_QGOODRACE;
      break;
    } else if(races_allowed) {
      SEND_TO_Q(race_menu, d);
d2489 2
a2490 9
    load_result = parse_good_race(*arg);
    if (load_result == RACE_UNDEFINED) {
      SEND_TO_Q("\r\n&3Please choose by entering the letter next to the race of your choice.&0\r\n", d);
      SEND_TO_Q(good_race_menu, d);
      SEND_TO_Q("\r\nRace: ", d); 
      return;
    } else
      
      GET_RACE(d->character) = load_result;    
d2492 1
a2492 1
    display_classes(d,1);
d2495 1
a2495 1
    load_result = race_by_menu(*arg);
d2500 1
a2500 1
      SEND_TO_Q(race_menu, d);
d3612 4
@


1.206
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.205 2008/01/02 02:10:16 jps Exp jps $
d37 1
a69 3
#define EMPTY_HOME -1
#define UNDEFINED_HOME_NO -1

a97 1
int set_race_align(struct char_data *ch);
a98 1
void room_selector(int race, int class, int result_rooms[], short int add);
a99 1
int parse_race(char arg);
a1707 20
void display_hometown(int race, int class, struct descriptor_data *d)
{
  int a = 0;
  int c = 0;
  char *b[] = {"1)", "2)", "3)", "4)", "5)"};
  int result_rooms[10];
  int x;
  room_selector(race, class, result_rooms, TRUE);
  
  send_to_char("\n\n\r&0&8&bPlease choose a hometown.&0\r\n", d->character);
  
  for (a = 0; result_rooms[a] != -1; a++) 
    {
      x = result_rooms[a];	
      send_to_char(b[c], d->character);c++;	 
      send_to_char(char_hometown[x], d->character); 
    }
  
}

d2509 1
a2509 1
    load_result = parse_race(*arg);
d2607 1
a2607 2
    GET_HOME(d->character) = set_new_home_town(GET_RACE(d->character), 
         GET_CLASS(d->character), '1');
d2612 3
a2614 6
    /* Here is the code for when you DO ask about a hometown: */
    
/*    display_hometown(GET_RACE(d->character), GET_CLASS(d->character), 
		     d); 
    
    STATE(d) = CON_QHOMETOWN; */
d2628 7
a2634 1
  case CON_QHOMETOWN:   
d2636 2
a2637 17
    load_result = set_new_home_town(GET_RACE(d->character), 
				    GET_CLASS(d->character), *arg);
    
    if (load_result == UNDEFINED_HOME_NO) {
      SEND_TO_Q("\r\n&0&1That's not a hometown.\r\n&0&8&bHometown:&0 ", d);
      return;
    } else
      GET_HOME(d->character) = load_result;
    /* commented out by FINGH, do NOT delete. 
     * SEND_TO_Q(diety_selection, d);
     * SEND_TO_Q("\r\nDiety:", d);
     * STATE(d) = CON_QDIETY;    
     */
    /* remove the attrib questions 
      * display_question(d);
      * STATE(d) = CON_QQUESTION1;        
    */
d2790 1
a2790 1
      GET_RACE_ALIGN(d->character) = set_race_align(d->character);
d3626 4
@


1.205
log
@Modified the (unused) bit about displaying help for classes.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.204 2007/12/25 05:41:49 jps Exp jps $
d36 1
a52 1
extern char *pc_class_types[];
a63 4
extern int warrior_subclasses[WARRIOR_SUBCLASSES];
extern int mage_subclasses[MAGE_SUBCLASSES];
extern int cleric_subclasses[CLERIC_SUBCLASSES];
extern int rogue_subclasses[ROGUE_SUBCLASSES];
a82 1
extern char *class_display[];
d1619 1
a1619 1
  mageok = class_ok_race[char_race][CLASS_MAGIC_USER];
d1652 1
a1652 1
	    strip_ansi(pc_class_types[CLASS_MAGIC_USER])); 
a2001 2
  /*int parse_class(char arg);*/
  int parse_class(struct char_data *ch, char arg); 
d2566 1
a2566 1
      load_result = parse_class(d->character, *arg);
d2591 2
a2592 2
      if (class_ok_race[(int)GET_RACE(d->character)][CLASS_MAGIC_USER])
	load_result = CLASS_MAGIC_USER;
d3664 3
@


1.204
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.203 2007/12/24 18:22:36 myc Exp jps $
d2654 8
a2661 14
    if (!*arg || *arg == '0') {
      display_classes(d,1);
      STATE(d) = CON_QCLASS;
      return;
    }
    load_result = parse_class(NULL, *arg);
    if (load_result == CLASS_UNDEFINED) {
      SEND_TO_Q("\r\nInvalid selection.\r\nSelection (0 to quit): ", d);
      return;
    } else {
      do_help(d->character, strip_ansi(class_display[load_result]+3),0,0);
      send_to_char("Select a-x,  0 to quit: ",d->character);
      return;
    }
d3671 5
@


1.203
log
@Removing 'bind' and 'unbind' from the command list since they are unused
and just screw things up anyway.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.202 2007/12/20 23:12:50 myc Exp myc $
d2345 1
a2345 1
      event_create(name_timeout, name_event, NAME_TIMEOUT);
d2804 1
a2804 1
            event_create(name_timeout, name_event, NAME_TIMEOUT);
d3677 4
@


1.202
log
@Moved exp_mesg to act.informative.c as exp_message.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.201 2007/12/19 20:51:52 myc Exp myc $
d460 1
a460 1
  { "bind"     , POS_STANDING, do_bind     ,-1, 0, 0 },
d465 1
a466 1
  { "bite"     , POS_RESTING , do_action   , 0, 0, 0 },
d930 1
a930 1
  { "unbind"   , POS_DEAD    , do_unbind   ,-1, 0, CMD_HIDE },
d3677 3
@


1.201
log
@Put "Huh?!?" in a macro.  Added a const modifier to is_number.
save_char() no longer requries you to supply a save/load room
(which wasn't being used anyway).  Updated code to remove a
player from a clan when they self-delete.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.200 2007/11/23 07:10:41 jps Exp myc $
a3028 45
char *exp_mesg(struct char_data *ch)
{
  long percent, current, total;
  
  
  current = exp_to_level((GET_LEVEL(ch)), GET_CLASS(ch)) - GET_EXP(ch);
  total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
  current = total - current;
  percent = (long) ((100 * current) / total);
  
  /*
  sprintf(buf, "percent is %ld\r\nbut total %ld, current %ld", percent, total, current);
  send_to_char(buf, ch);
  */
  
  
  if ((total - current) == 1) {
    if (GET_LEVEL(ch) == LVL_MAX_MORT)
      return ("&0&4&bYou are as powerful as a mortal can be!&0");
    else
      return ("&0&4&bYou are ready for the next level!&0");
  } else if (percent >= 90)
    return ("&0&4&bYou should level anytime now!&0");
  else if (percent >= 80)
    return ("&0&6You are almost ready to attain your next level.&0");
  else if (percent >= 70)
    return ("&0&4&bYou are three-quarters of the way to your next level.&0");
  else if (percent >= 60)
    return ("&0&4&bYou are well on your way to your next level.&0");
  else if (percent >= 50)
    return ("&0&4&bYou are just past the half-way point to your next level.&0");
  else if (percent >= 40)
    return ("&0&4&bYou are at the half-way point to your next level.&0");
  else if (percent >= 30)
    return ("&0&4&bYou are nearing the half-way point to your next level.&0");
  else if (percent >= 20)
    return ("&0&4&bYou are one-quarter of the way to your next level.&0");
  else if (percent >= 10)
    return ("&0&4&bYou have gained some progress towards your next level.&0");
  else if (percent > 4)
    return ("&0&4&bYou still have a very long way to go to your next level.&0");
  else
    return ("&0&4&bYou have just begun the journey to your next level.&0");
}

d3677 6
@


1.200
log
@Ok, that was bad.. back to LVL_ADMIN + 1 for iptables.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.199 2007/11/22 21:30:18 jps Exp jps $
d1115 1
a1115 1
    send_to_char("Huh?!?\r\n", ch);
d1445 1
a1445 1
int is_number(char *str)
d2332 1
a2332 1
         save_char(d->character, NOWHERE);
d2380 1
a2380 1
	save_char(d->character, NOWHERE);
d2486 1
a2486 1
      save_char(d->character, NOWHERE);
d2819 1
a2819 1
            save_char(d->character, NOWHERE);
d2834 1
a2834 1
      save_char(d->character, NOWHERE);
d2874 1
a2874 1
      save_char(d->character, NOWHERE);
d2978 2
a2979 13
      if (GET_LEVEL(d->character) < LVL_GRGOD){
        if(GET_CLAN(d->character)) {
          int clan_num;
          clan_num = find_clan_by_id(GET_CLAN(d->character));
          if(GET_CLAN_RANK(d->character)){
            clan[clan_num].members--;
            clan[clan_num].power-=GET_LEVEL(d->character);
	  }
          GET_CLAN(d->character) = 0;
          GET_CLAN_RANK(d->character) = 0;
          update_clan(NULL,clan_num);
	}
      }
d3687 1
a3687 1
   save_char(event->d->character, NOWHERE);
d3722 3
@


1.199
log
@Use correct def for level 105 in iptables settings.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.198 2007/11/21 02:34:43 jps Exp jps $
d641 1
a641 1
  { "iptables" , POS_DEAD    , do_iptables , LVL_OVERLORD, 0, CMD_ANY },
d3733 3
@


1.198
log
@Back to god-only title command - we have better plans...
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.197 2007/11/21 01:29:37 jps Exp jps $
d641 1
a641 1
  { "iptables" , POS_DEAD    , do_iptables , LVL_ADMIN + 1, 0, CMD_ANY },
d3733 3
@


1.197
log
@Made the title command available to all players.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.196 2007/11/18 16:51:55 myc Exp jps $
d910 1
a910 1
  { "title"    , POS_DEAD    , do_title    , 0, 0, CMD_ANY },
d3733 3
@


1.196
log
@Renaming LVL_QUESTMASTER as LVL_GAMEMASTER.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.195 2007/10/25 20:39:37 myc Exp myc $
d910 1
a910 1
  { "title"    , POS_DEAD    , do_title    , LVL_GOD, 0, CMD_ANY },
d3733 3
@


1.195
log
@Added compare command.  Made a number of god and informative commands
POS_DEAD.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.194 2007/10/23 20:21:00 myc Exp myc $
d610 1
a610 1
  { "hedit"    , POS_DEAD    , do_olc      , LVL_QUESTMASTER, SCMD_OLC_HEDIT, 0 },
d760 1
a760 1
  { "purge"    , POS_DEAD    , do_purge    , LVL_QUESTMASTER, 0, CMD_ANY },
d805 1
a805 1
  { "save"     , POS_SLEEPING, do_save     , LVL_BUILDER, 0 , CMD_ANY ^ CMD_CAST },
d838 1
a838 1
  { "skillset" , POS_DEAD    , do_skillset , LVL_QUESTMASTER, 0, CMD_ANY },
d937 2
a938 2
  { "varset"   , POS_DEAD    , do_varset   , LVL_QUESTMASTER, 0, CMD_ANY },
  { "varunset" , POS_DEAD    , do_varunset , LVL_QUESTMASTER, 0, CMD_ANY },
d3733 4
@


1.194
log
@Slightly redesigned the master command list, replacing the six boolean
variables on each line with a single bitvector.  Also replaced all of
the compiler ifdef checks with administration levels defined in
structs.h.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.193 2007/10/17 17:18:04 myc Exp myc $
d150 1
d443 1
a443 1
  { "anews"    , POS_SLEEPING, do_gen_ps   , LVL_IMMORT, SCMD_ANEWS, CMD_ANY },
d449 1
a449 1
  { "autoboot" , POS_DEAD,     do_autoboot,  LVL_REBOOT_VIEW, 0, CMD_ANY },
d500 1
d518 1
a518 1
  { "daydream" , POS_SLEEPING, do_action   , 0, 0, 0 },
d524 2
a525 2
  { "disband"  , POS_RESTING , do_disband  , 1, 0, 0 },
  { "dig"      , POS_STANDING, do_dig      , LVL_BUILDER, 0, CMD_ANY },
d540 1
d542 1
a542 1
  { "echo"     , POS_SLEEPING, do_echo     , LVL_IMMORT, SCMD_ECHO, CMD_ANY },
d553 2
a554 2
  { "experience", POS_DEAD   , do_experience,0, 0, CMD_ANY },
  { "extinguish", POS_RESTING, do_light    , 0, SCMD_EXTINGUISH, 0 },
d557 2
a558 2
  { "force"    , POS_SLEEPING, do_force    , LVL_ATTENDANT, 0, CMD_ANY },
  { "flee"     , POS_FIGHTING, do_flee     , 1, 0, CMD_CAST },
d560 1
a560 1
  { "first aid", POS_STANDING, do_first_aid, 0, 0, 0 },
d584 1
a584 1
  { "glance"   , POS_DEAD    , do_diagnose , 0, 0, CMD_MEDITATE | CMD_HIDE | CMD_BOUND },
d587 2
a588 2
  { "glower"   , POS_RESTING,  do_action   , 0, 0, 0 },
  { "goto"     , POS_SLEEPING, do_goto     , LVL_IMMORT, 0, CMD_ANY },
d596 1
a596 1
  { "greport"  , POS_RESTING , do_report   , 0, SCMD_GREPORT, CMD_ANY },
d614 1
a614 1
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_BUILDER, 0, 0 },
d629 1
a629 1
  { "inventory", POS_DEAD    , do_inventory, 0, 0, CMD_ANY },
d638 1
a638 1
  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO, CMD_ANY },
d661 1
a661 1
  { "level"    , POS_SLEEPING, do_level    , 0, 0, CMD_ANY },
d666 2
a667 2
  { "listspells",POS_STANDING, do_listspells,LVL_ATTENDANT, 0, CMD_ANY },
  { "listexp"  , POS_STANDING, do_listexp  , LVL_ATTENDANT, 0, CMD_ANY },
d676 1
a676 1
  { "mdisband" , POS_RESTING , do_mdisband , 1, 0, 0 },
d683 2
a684 2
  { "mgroup"   , POS_RESTING , do_mgroup   , 1, 0, 0 },
  { "moon"     , POS_RESTING , do_action   , 0, 0, 0 },
d702 1
a702 1
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS, CMD_ANY },
d711 3
a713 3
  { "naccept"  , POS_RESTING , do_name     , LVL_IMMORT, SCMD_ACCEPT, CMD_ANY },
  { "ndecline" , POS_RESTING , do_name     , LVL_IMMORT, SCMD_DECLINE, CMD_ANY },
  { "nlist"    , POS_RESTING , do_name     , LVL_IMMORT, SCMD_LIST, CMD_ANY },
d751 1
a751 1
  { "protect"  , POS_RESTING , do_action   , 0, 0, 0 },
d806 1
a806 1
  { "attributes", POS_DEAD   , do_attributes, 0, 0, CMD_ANY },
d818 1
a818 1
  { "send"     , POS_SLEEPING, do_send     , LVL_GRGOD, 0, CMD_ANY },
d838 1
a838 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_QUESTMASTER, 0, CMD_ANY },
d865 2
a866 2
  { "split"    , POS_SITTING , do_split    , 1, 0, 0 },
  { "spells"   , POS_RESTING , do_spells   , 1, 0, CMD_ANY },
d918 1
a918 1
  { "transfer" , POS_SLEEPING, do_trans    , LVL_GOD, 0, CMD_ANY },
d966 1
a966 1
  { "where"    , POS_RESTING , do_where    , LVL_ATTENDANT, 0, CMD_ANY },
d977 1
a977 1
  { "wizhelp"  , POS_SLEEPING, do_commands , LVL_IMMORT, SCMD_WIZHELP, CMD_ANY },
d3733 6
@


1.193
log
@Renamed the search_block and search_block2 functions.
searchblock is now case sensitive, and search_block is not.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.192 2007/10/11 20:14:48 myc Exp myc $
a77 1
bool ask_question(struct descriptor_data *d, int question, char *arg);
d420 2
a421 3
  { "RESERVED", 0, 0, 0, 0 , 0, 0, 0, 0, 0 ,0 },	/* this must be first -- for specprocs */
  /*0's are:
    name , min position, acmd, min level, sub cmd, mediate, major para, minor para, hide, bound, cast*/
d423 6
a428 6
  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH , 0, 0, 0, 1, 0 ,0 },
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST  , 0, 0, 0, 1, 0 ,0 },
  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH , 0, 0, 0, 1, 0 ,0 },
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST  , 0, 0, 0, 1, 0 ,0 },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP    , 0, 0, 0, 1, 0 ,0 },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN  , 0, 0, 0, 1, 0 ,0 },
d431 208
a638 243
#ifdef PRODUCTION
  { "at"       , POS_DEAD    , do_at       , LVL_GOD, 0 , 0, 0, 0, 0, 0, 0 },
#else
  { "at"       , POS_DEAD    , do_at       , LVL_IMMORT, 0 , 0, 0, 0, 0, 0, 0 },
#endif
  { "abort"    , POS_DEAD    , do_abort    , 0, 0, 1, 1, 1, 1, 0, 1 },
  { "ack"      , POS_RESTING , do_action   , 0, 0, 0, 0, 0, 0, 0, 0 },
#ifdef PRODUCTION
  { "advance"  , POS_DEAD    , do_advance  , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "advance"  , POS_DEAD    , do_advance  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "aggr"     , POS_DEAD    , do_aggr     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "alert"    , POS_RESTING , do_alert    , 0, 0 , 0, 0, 0, 0, 0 ,1 }, 
  { "alias"    , POS_DEAD    , do_alias    , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "accuse"   , POS_SITTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "afk"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "agree"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "amaze"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "apologize", POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "applaud"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "appear"   , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "assist"   , POS_FIGHTING, do_assist   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ask"      , POS_RESTING , do_spec_comm, 0, SCMD_ASK , 0, 0, 0, 0, 0 ,0 },
  { "autoboot" , POS_DEAD,     do_autoboot,  LVL_REBOOT_VIEW, 0, 0, 0, 0, 0, 0 },
  /* { "auction"  , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_AUCTION , 0, 0, 0, 0, 0 ,0 }, */
  { "ayt"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "backstab" , POS_FIGHTING, do_backstab , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bandage"  , POS_STANDING, do_bandage  , 1, 0 , 0, 0, 0, 0, 0 ,0 }, 
  { "balance"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bang"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bark"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bash"     , POS_FIGHTING, do_bash     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bind"     , POS_STANDING, do_bind     ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bodyslam" , POS_FIGHTING, do_bodyslam , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "beckon"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "beer"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "beg"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bird"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bite"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "blink"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bleed"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "blush"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "boggle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bonk"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bored"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bounce"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bow"      , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "brb"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "breathe"  , POS_FIGHTING, do_breathe  ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "buck"     , POS_STANDING, do_buck     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "burp"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "buy"      , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG , 1, 0, 0, 1, 0 ,0 },
  { "bye"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "cast"     , POS_SITTING , do_cast     , 1, SCMD_CAST , 0, 0, 0, 0, 0 ,0},
  { "cackle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "camp"     , POS_STANDING, do_camp     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  
  { "chant"    , POS_FIGHTING, do_cast     , 0, SCMD_CHANT, 0, 0, 0, 0, 0 ,0 },
  { "chuckle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "check"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cheer"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "choke"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "clan"     , POS_SLEEPING, do_clan     , 1, 0 , 1, 0, 0, 0, 0 ,0 },
  { "clap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "claw"     , POS_FIGHTING, do_claw     , 1, 0, 0, 0, 0, 0, 0, 0 },
/*  { "circle"   , POS_FIGHTING, do_circle   , 1, 0 , 0, 0, 0, 0, 0 ,0 }, */
  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 1, 0, 0, 0, 0 ,1 },
  { "close"    , POS_SITTING , do_gen_door , 0, SCMD_CLOSE , 0, 0, 0, 0, 0 ,0 },
  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 1, 0, 0, 0, 0 ,1 },
  { "consider" , POS_RESTING , do_consider , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  /* #ifdef PRODUCTION
  { "copyto"   , POS_STANDING, do_copyto   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "copyto"   , POS_STANDING, do_copyto   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  #endif */
  { "color"    , POS_DEAD    , do_color    , 0, 0 , 1, 0, 0, 0, 1 ,0 },
  { "comfort"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "comb"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS, 1, 0, 0, 0, 0 ,0 },
  { "consent"  , POS_SLEEPING, do_consent  , 0, 0 , 0, 0, 0, 0, 0, 0},
  { "conceal"  , POS_STANDING, do_conceal  , 0, 0 , 0, 0, 0, 1, 0, 0},
  { "corner"   , POS_FIGHTING, do_corner   , 0, 0 , 0, 0, 0, 0, 0, 0},
  { "cough"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "credits"  , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS , 0, 0, 0, 0, 1 ,0 },
  { "cringe"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cry"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ctell"    , POS_SLEEPING, do_ctell    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "cuddle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "curse"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "curtsey"  , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "dance"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "date"     , POS_DEAD    , do_date     , 0, SCMD_DATE , 0, 0, 0, 1, 0 ,0 },
  { "daydream" , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "dc"       , POS_DEAD    , do_dc       , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "dc"       , POS_DEAD    , do_dc       , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "deposit"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "dismount" , POS_STANDING, do_dismount , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "display"  , POS_DEAD    , do_display  , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "disband"  , POS_RESTING , do_disband  , 1, 0 , 0, 0, 0, 0, 0 , 0},  
#ifdef PRODUCTION
  { "dig"      , POS_STANDING, do_dig      , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "dig"      , POS_STANDING, do_dig      , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "disappear", POS_STANDING, do_not_here ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disarm"   , POS_FIGHTING, do_disarm   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disengage", POS_FIGHTING, do_disengage, 0, 0 , 0, 0, 0, 0, 0 ,1 },
  { "disembark", POS_STANDING, do_disembark,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "doorbash" , POS_STANDING, do_doorbash , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "douse"    , POS_STANDING, do_douse    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "drag"     , POS_STANDING, do_drag     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dream"    , POS_SLEEPING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "drink"    , POS_RESTING , do_drink    , 0, SCMD_DRINK , 0, 0, 0, 0, 0 ,0 },
  { "drop"     , POS_RESTING , do_drop     , 0, SCMD_DROP , 0, 0, 0, 0, 0 ,0 },
  { "drool"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "duck"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "duh"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "dump"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "eat"      , POS_RESTING , do_eat      , 0, SCMD_EAT , 0, 0, 0, 0, 0 ,0 },
  { "echo"     , POS_SLEEPING, do_echo     , LVL_IMMORT, SCMD_ECHO , 0, 0, 0, 0, 0 ,0 },
  { "electrify", POS_FIGHTING, do_electrify, 1, 0 , 0, 0, 0, 0, 0, 0 },
  { "emote"    , POS_RESTING , do_echo     , 1, SCMD_EMOTE , 0, 0, 0, 0, 0 ,0 },
  { ":"        , POS_RESTING , do_echo     , 1, SCMD_EMOTE , 0, 0, 0, 0, 0 ,0 },
  { "embrace"  , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "enter"    , POS_STANDING, do_enter    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "envy"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "equipment", POS_SLEEPING, do_equipment, 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "exits"    , POS_RESTING , do_exits    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "examine"  , POS_RESTING , do_examine  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "exchange" , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "experience", POS_DEAD   , do_experience,0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "extinguish", POS_RESTING, do_light    , 0, SCMD_EXTINGUISH,  0, 0, 0, 0, 0, 0 },
  { "eyebrow"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "force"    , POS_SLEEPING, do_force    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "force"    , POS_SLEEPING, do_force    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "flee"     , POS_FIGHTING , do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,1 },
  { "fart"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "first aid", POS_STANDING, do_first_aid, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fill"     , POS_STANDING, do_pour     , 0, SCMD_FILL , 0, 0, 0, 0, 0 ,0 },
  { "flanic"   , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flex"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flip"     , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flirt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fly"      , POS_STANDING, do_fly      , 0, 0, 0, 0, 0, 0, 0, 0 },
  { "follow"   , POS_RESTING , do_follow   , 0, SCMD_FOLLOW , 0, 0, 0, 0, 0 ,0 },
  { "fool"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "forget"   , POS_RESTING , do_forget   , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "fondle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  /*  { "frag"   , POS_DEAD    , do_frag  , 0, 0 , 0, 0, 0, 0, 0 ,0 },*/
  { "freeze"   , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE , 0, 0, 0, 0, 0 ,0 },
  { "french"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "frown"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "fume"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "get"      , POS_RESTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gag"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gape"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gasp"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gecho"    , POS_DEAD    , do_gecho    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "give"     , POS_RESTING , do_give     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "giggle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "glance"   , POS_DEAD    , do_diagnose , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "glare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "glomp"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "glower"   , POS_RESTING,  do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "goto"     , POS_SLEEPING, do_goto     , LVL_IMMORT, 0, 0, 0, 0, 0, 0 ,0 },
  { "go"       , POS_STANDING, do_move     , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP , 1, 0, 0, 1, 0 ,0 },
  { "gouge"    , POS_FIGHTING, do_eye_gouge, 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "group"    , POS_SLEEPING, do_group    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grab"     , POS_RESTING , do_grab     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  /*  { "grats"    , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GRATZ , 0, 0, 0, 0, 0 ,0 }, */
  { "greport"  , POS_RESTING , do_report   , 0, SCMD_GREPORT , 0, 0, 0, 0, 0 ,0 },
  { "greet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gretreat" , POS_FIGHTING, do_gretreat , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grin"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "groan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grope"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grovel"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "growl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "grumble"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gsay"     , POS_SLEEPING, do_gsay     , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "gtell"    , POS_SLEEPING, do_gsay     , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "guard"    , POS_STANDING, do_guard    , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "help"     , POS_DEAD    , do_help     , 0, 0 , 1, 0, 0, 1, 0 ,0 },
#ifdef PRODUCTION
  { "hedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
#else
  { "hedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
#endif
  { "handbook" , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK , 0, 0, 0, 0, 0 ,0 },
  { "halo"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_HEAD_C, 0, 0, 0, 0, 0, 0 ,0 },
#else
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
#endif
  { "hi5"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hiccup"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hide"     , POS_STANDING, do_hide     , 1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "hiss"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hit"      , POS_FIGHTING, do_hit      , 0, SCMD_HIT , 0, 0, 0, 0, 0 ,0 },
  { "hitall"   , POS_FIGHTING, do_hitall   , 0, 0 , 0, 0, 0, 0, 0, 0 },  
  { "hold"     , POS_RESTING , do_grab     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hop"      , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "home"     , POS_DEAD    , do_not_here , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "house"    , POS_RESTING , do_house    ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hunt"     , POS_STANDING, do_hunt     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hug"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hunger"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "inventory", POS_DEAD    , do_inventory, 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "identify" , POS_RESTING , do_identify , 0, 0,  0, 0, 0, 1, 0, 0 },
  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA , 1, 0, 0, 1, 0 ,0 },
  { "imitate"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "imotd"    , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD , 0, 0, 0, 0, 0 ,0 },
  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST , 1, 0, 0, 1, 0 ,0 },
  { "impale"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "innate"   , POS_DEAD    , do_innate   , 0, 0, 0, 0, 0, 1, 0 ,0 },
  { "ignore"   , POS_DEAD    , do_ignore   , 0, 0, 0, 0, 0, 1, 0 ,0 },
  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO , 1, 0, 0, 1, 0 ,0 },
  { "insult"   , POS_RESTING , do_insult   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "invis"    , POS_DEAD    , do_invis    , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "iptables"    , POS_DEAD    , do_iptables    , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "iptables"    , POS_DEAD    , do_iptables    , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
d640 1
a640 143
  { "ispell"   , POS_DEAD    , do_ispell   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "junk"     , POS_RESTING , do_drop     , 0, SCMD_JUNK , 0, 0, 0, 0,0 ,0 },
  { "justice"  , POS_DEAD    , do_justice  , 1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "kick"     , POS_FIGHTING, do_kick     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kill"     , POS_FIGHTING, do_kill     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kiss"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "kneel"    , POS_RESTING , do_kneel    , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
  
  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK , 1, 1, 0, 1, 0,1 },
  { "lag"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "laugh"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "layhands"    , POS_FIGHTING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
  { "last"     , POS_DEAD    , do_last     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "lean"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "leave"    , POS_STANDING, do_leave    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "level"    , POS_SLEEPING, do_level    , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "light"    , POS_RESTING , do_light    , 0, SCMD_LIGHT , 0, 0, 0, 0, 0 ,0 },
  { "list"     , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "listclass", POS_DEAD    , do_listclass, LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listrace" , POS_DEAD    , do_listrace , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listexp"  , POS_STANDING, do_listexp  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "lick"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "lock"     , POS_SITTING , do_gen_door , 0, SCMD_LOCK , 0, 0, 0, 0, 0 ,0 },
  { "linkload" , POS_DEAD    , do_linkload , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "load"     , POS_DEAD    , do_load     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "map"      , POS_DEAD    , do_map      , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "load"     , POS_DEAD    , do_load     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "map"      , POS_DEAD    , do_map      , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "love"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mdisband" , POS_RESTING , do_mdisband , 1, 0 , 0, 0, 0, 0, 0 , 0},
  { "moan"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "medit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
#else
  { "medit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
#endif
  { "motd"     , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD , 0, 0, 0, 1, 0 ,0 },
  { "mail"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "massage"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "meditate" , POS_RESTING , do_meditate , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "memorize" , POS_RESTING , do_memorize , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "mgroup"   , POS_RESTING , do_mgroup   , 1, 0 , 0, 0, 0, 0, 0 , 0},
  { "moon"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mosh"     , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mount"    , POS_STANDING, do_mount    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mourn"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mumble"   , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mute"     , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH , 0, 0, 0, 0, 0 ,0 },
  { "mutter"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "murder"   , POS_FIGHTING, do_hit      , 0, SCMD_MURDER , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "mlist"    , POS_DEAD    , do_vsearch_mobile, LVL_GRGOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "mnum"     , POS_DEAD    , do_vsearch_mobile, LVL_GRGOD, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "msearch"  , POS_DEAD    , do_vsearch_mobile, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "mfind"    , POS_DEAD    , do_vsearch_mobile, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "mstat"    , POS_DEAD    , do_vstat    , LVL_GRGOD, SCMD_MSTAT , 0, 0, 0, 0, 0 ,0 },
#else
  { "mlist"    , POS_DEAD    , do_vsearch_mobile, LVL_BUILDER, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "mnum"     , POS_DEAD    , do_vsearch_mobile, LVL_BUILDER, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "msearch"  , POS_DEAD    , do_vsearch_mobile, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "mfind"    , POS_DEAD    , do_vsearch_mobile, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "mstat"    , POS_DEAD    , do_vstat    , LVL_BUILDER, SCMD_MSTAT , 0, 0, 0, 0, 0 ,0 },
#endif  
  { "msay"     , POS_SLEEPING, do_msay     , 0, 0, 0 , 0, 0, 0, 0, 0 },
  { "mreport"  , POS_SLEEPING, do_report   , 0, SCMD_MREPORT, 0 , 0, 0, 0, 0, 0 },
  { "anews"    , POS_SLEEPING, do_gen_ps   , LVL_IMMORT, SCMD_ANEWS, 0, 0, 0, 0, 0,0 },
  { "nap"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS, 1, 0, 0, 1, 0 ,0 },
  { "nibble"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nod"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nog"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "noogie"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE , 0, 0, 0, 0, 0 ,0 },
  { "note"     , POS_DEAD    , do_gen_write     , LVL_IMMORT, SCMD_NOTES ,0,0,0,0,0,0},
  { "nudge"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "nuzzle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "naccept"  , POS_RESTING , do_name     , LVL_IMMORT, SCMD_ACCEPT, 0, 0, 0, 0, 0, 0},
  { "ndecline" , POS_RESTING , do_name     , LVL_IMMORT, SCMD_DECLINE, 0, 0, 0, 0, 0, 0},
  { "nlist"    , POS_RESTING , do_name     , LVL_IMMORT, SCMD_LIST, 0, 0, 0, 0, 0, 0},
/*{ "olc"      , POS_DEAD    , do_olc      , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },*/
  { "order"    , POS_RESTING , do_order    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "offer"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "open"     , POS_SITTING , do_gen_door , 0, SCMD_OPEN , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "olc"      , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
  { "olist"    , POS_DEAD    , do_vsearch_object, LVL_GRGOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "onum"     , POS_DEAD    , do_vsearch_object, LVL_GRGOD, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "osearch"  , POS_DEAD    , do_vsearch_object, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "ofind"    , POS_DEAD    , do_vsearch_object, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "ostat"    , POS_DEAD    , do_vstat    , LVL_GRGOD, SCMD_OSTAT , 0, 0, 0, 0, 0 ,0 },
#else
  { "olc"      , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
  { "olist"    , POS_DEAD    , do_vsearch_object, LVL_BUILDER, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "onum"     , POS_DEAD    , do_vsearch_object, LVL_BUILDER, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "osearch"  , POS_DEAD    , do_vsearch_object, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "ofind"    , POS_DEAD    , do_vsearch_object, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "ostat"    , POS_DEAD    , do_vstat    , LVL_BUILDER, SCMD_OSTAT , 0, 0, 0, 0, 0 ,0 },
#endif
  { "put"      , POS_RESTING , do_put      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "palm"     , POS_RESTING , do_palm     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "panic"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pant"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pat"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "page"     , POS_DEAD    , do_page     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_OVERLORD, SCMD_PARDON , 0, 0, 0, 0, 0 ,0 },
  { "peace"    , POS_DEAD    , do_peace    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "peck"     , POS_FIGHTING, do_peck     , 1, 0, 0, 0, 0, 0, 0, 0 },
  { "peer"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pet"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "petition" , POS_DEAD    , do_petition , 0, 0 , 1, 0, 0, 1, 1 ,0 },
  { "pfilemaint", POS_DEAD  , do_pfilemaint, LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pick"     , POS_STANDING, do_gen_door , 1, SCMD_PICK , 0, 0, 0, 0, 0 ,0 },
  { "players"  , POS_DEAD    , do_players  , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "point"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "poke"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES , 1, 0, 0, 1, 0, 0 },
  { "ponder"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "poofin"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN , 0, 0, 0, 0, 0 ,0 },
  { "poofout"  , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT , 0, 0, 0, 0, 0 ,0 },
  { "pounce"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pour"     , POS_STANDING, do_pour     , 0, SCMD_POUR , 0, 0, 0, 0, 0 ,0 },
  { "pout"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "protect"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
/*{ "practice" , POS_RESTING , do_practice , 1, 0 , 0, 0, 0, 0, 0 ,0},*/
  { "pray"     , POS_RESTING , do_pray     , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "ptell"    , POS_DEAD    , do_ptell    , LVL_IMMORT, 0, 0, 0, 0, 0, 0, 0 },
  { "puke"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "punch"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pull"     , POS_RESTING , do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "push"     , POS_RESTING , do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "purr"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "purge"    , POS_DEAD    , do_purge    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "purge"    , POS_DEAD    , do_purge    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d643 2
a644 307
  { "quaff"    , POS_RESTING , do_use      , 0, SCMD_QUAFF , 0, 0, 0, 0, 0 ,0 },
  { "qecho"    , POS_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO , 0, 0, 0, 0, 0 ,0 },
  { "qui"      , POS_DEAD    , do_quit     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "quit"     , POS_DEAD    , do_quit     , 0, SCMD_QUIT , 0, 0, 0, 0, 0 ,0 },
  { "qsay"     , POS_RESTING , do_qcomm    , 0, SCMD_QSAY , 0, 0, 0, 1, 0 ,0 },

  { "rest"     , POS_RESTING , do_rest     , 0, 0 , 1, 0, 0, 0, 0 ,0 },
  { "raise"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "report"   , POS_RESTING , do_report   , 0, SCMD_REPORT , 0, 0, 0, 0, 0 ,0 },
  { "reply"    , POS_SLEEPING, do_reply    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "read"     , POS_RESTING , do_look     , 0, SCMD_READ , 0, 0, 0, 0, 0 ,0 },
  { "reload"   , POS_DEAD    , do_reboot   , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "recite"   , POS_RESTING , do_use      , 0, SCMD_RECITE , 0, 0, 0, 0, 0 ,0 },
  { "receive"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "recline"  , POS_RESTING , do_recline  , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
  { "remove"   , POS_RESTING , do_remove   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rent"     , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
  { "rescue"   , POS_FIGHTING, do_rescue   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
/*{ "readlist" , POS_DEAD    , do_readlist , LVL_GOD, 0 , 0, 0,0,0,0, 0 },*/
#ifdef PRODUCTION
  { "restore"  , POS_DEAD    , do_restore  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pain"     , POS_DEAD    , do_pain     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rpain"    , POS_DEAD    , do_rpain    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "restore"  , POS_DEAD    , do_restore  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pain"     , POS_DEAD    , do_pain     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rpain"    , POS_DEAD    , do_rpain    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "retreat"  , POS_FIGHTING, do_retreat  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "return"   , POS_DEAD    , do_return   ,-1, 0 , 0, 0, 0, 0, 0,0 },
#ifdef PRODUCTION
  { "redit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
#else
  { "redit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
#endif
  { "rename"   , POS_DEAD    , do_rename   , LVL_GRGOD, 0, 0,0,0,0,0,0},
  { "roar"     , POS_FIGHTING, do_roar     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rofl"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "roll"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ready"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "ruffle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "rlist"    , POS_DEAD    , do_vsearch_room, LVL_GRGOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "rnum"     , POS_DEAD    , do_vsearch_room, LVL_GRGOD, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "rsearch"  , POS_DEAD    , do_vsearch_room, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "rfind"    , POS_DEAD    , do_vsearch_room, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "rstat"    , POS_DEAD    , do_stat     , LVL_GRGOD, SCMD_RSTAT , 1, 1, 1, 1, 1 ,1 },
  { "sstat"    , POS_DEAD    , do_stat     , LVL_GRGOD, SCMD_SSTAT , 0, 0, 0, 0, 0 ,0 },
#else
  { "rlist"    , POS_DEAD    , do_vsearch_room, LVL_BUILDER, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "rnum"     , POS_DEAD    , do_vsearch_room, LVL_BUILDER, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "rsearch"  , POS_DEAD    , do_vsearch_room, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "rfind"    , POS_DEAD    , do_vsearch_room, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "rstat"    , POS_DEAD    , do_stat     , LVL_BUILDER, SCMD_RSTAT , 1, 1, 1, 1, 1 ,1 },
  { "sstat"    , POS_DEAD    , do_stat     , LVL_BUILDER, SCMD_SSTAT , 0, 0, 0, 0, 0 ,0 },
#endif
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp,-1, 0, 0, 0, 0, 0, 0 ,0 },
  { "say"      , POS_RESTING , do_say      , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "'"        , POS_RESTING , do_say      , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "save"     , POS_SLEEPING, do_save     , LVL_BUILDER, 0 , 1, 0, 0, 1, 1 ,0 },
  { "attributes", POS_DEAD , do_attributes , 0, 0 , 1, 1, 1, 1, 1 ,0 },  
  { "score"    , POS_DEAD    , do_score, 0, 0 , 1, 1, 1, 1, 1 ,0 },
  { "scan"     , POS_STANDING, do_scan     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "salute"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scribe"   , POS_RESTING , do_scribe   , 0, 0, 0, 0, 0, 0, 0, 0 },
  { "scare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scold"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scratch"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scream"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "screw"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sdedit"   , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SDEDIT , 0, 0, 0, 0, 0 ,0 },
  { "sell"     , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "send"     , POS_SLEEPING, do_send     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "set"      , POS_DEAD    , do_set      , LVL_GOD,    0 , 0, 0, 0, 0, 0 ,0 },
  { "search"   , POS_STANDING, do_search   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "sedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
#else
  { "sedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
#endif
  { "seduce"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shout"    , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT , 0, 0, 0, 0, 0 ,0 },
  { "shake"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shadow"   , POS_RESTING , do_follow   , 0, SCMD_SHADOW , 0, 0, 0, 1, 0 ,0 },
  { "shapechange", POS_STANDING, do_shapechange, 0,0,0,0,0,0,0,0},
  { "shiver"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "show"     , POS_DEAD    , do_show     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shrug"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shudder"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_REBOOT_MASTER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_REBOOT_MASTER, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
  { "sigh"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sing"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sip"      , POS_RESTING , do_drink    , 0, SCMD_SIP , 0, 0, 0, 0, 0 ,0 },
  { "sit"      , POS_RESTING , do_sit      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "skills"   , POS_SLEEPING, do_skills   , 1, 0 , 1, 0, 0, 1, 0 ,0 },
#ifdef PRODUCTION
  { "skillset" , POS_SLEEPING, do_skillset , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slist"    , POS_DEAD    , do_vsearch_shop, LVL_GRGOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "snum"     , POS_DEAD    , do_snum     , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "ssearch"  , POS_DEAD    , do_vsearch_shop, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "sfind"    , POS_DEAD    , do_vsearch_shop, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
#else
  { "skillset" , POS_SLEEPING, do_skillset , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slist"    , POS_DEAD    , do_vsearch_shop, LVL_BUILDER, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "snum"     , POS_DEAD    , do_snum     , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
  { "ssearch"  , POS_DEAD    , do_vsearch_shop, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "sfind"    , POS_DEAD    , do_vsearch_shop, LVL_BUILDER, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
#endif
  { "sleep"    , POS_SLEEPING, do_sleep    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "slobber"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smell"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smile"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smirk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "smoke"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snicker"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snarl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sneeze"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sniff"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snoogie"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snore"    , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snort"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snowball" , POS_STANDING, do_action   , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snuggle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "songs"    , POS_DEAD    , do_songs    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "socials"  , POS_DEAD    , do_commands , 0, SCMD_SOCIALS , 0, 0, 0, 1, 0 ,0 },
  { "spam"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "speak"    , POS_DEAD    , do_speak    , 0, 0, 0, 0, 0, 1, 0 ,0 },
  { "split"    , POS_SITTING , do_split    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "spells"   , POS_RESTING , do_spells   , 1, 0 , 1, 0, 0, 1, 0 ,0 },
  { "spank"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "spit"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "springleap",POS_RESTING , do_springleap, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "squeeze"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stand"    , POS_RESTING , do_stand    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stare"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "stat"     , POS_DEAD    , do_stat     , LVL_GRGOD, SCMD_STAT , 1, 1, 1, 1, 1 ,1 },
#else
  { "stat"     , POS_DEAD    , do_stat     , LVL_BUILDER, SCMD_STAT , 1, 1, 1, 1, 1 ,1 },
#endif
  { "steal"    , POS_STANDING, do_steal    , 1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "steam"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stow"     , POS_RESTING , do_stow     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stomp"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "stroke"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "strut"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sulk"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "summon mount" , POS_STANDING , do_summon_mount   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "swat"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sweat"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "sweep"    , POS_FIGHTING, do_sweep    ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "switch"   , POS_DEAD    , do_switch   , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "stone"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "subclass" , POS_RESTING , do_subclass ,0,0,0,0,0,0,0,0 },

  
  { "tell"     , POS_SLEEPING, do_tell     , 0, 0 , 1, 0, 1, 0, 0 ,0 },
  { "terminate", POS_DEAD    , do_terminate, LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tackle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "take"     , POS_FIGHTING, do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tango"    , POS_STANDING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tame"     , POS_STANDING, do_tame     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tap"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tarzan"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "taunt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "taste"    , POS_RESTING , do_eat      , 0, SCMD_TASTE , 0, 0, 0, 0, 0 ,0 },
  { "tease"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tedit"    , POS_DEAD    , do_tedit    , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
  { "teleport" , POS_DEAD    , do_teleport , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "thank"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "think"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "thaw"     , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW , 0, 0, 0, 0, 0 ,0 },
  { "thirst"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "throatcut", POS_STANDING, do_throatcut, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "throw"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tip"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "title"    , POS_DEAD    , do_title    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tickle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "time"     , POS_DEAD    , do_time     , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "tip"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "tongue"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "touch"    , POS_RESTING , do_touch    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "track"    , POS_STANDING, do_track    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "transfer" , POS_SLEEPING, do_trans    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "trigedit" , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
#else
  { "trigedit" , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
#endif
  { "trip"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "trophy"   , POS_DEAD    , do_trophy   , 0, 0 , 1, 0, 0, 1, 0, 0 }, 
  { "tug"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twibble"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twiddle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twitch"   , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO , 1, 0, 0, 1, 0 ,0 },

  { "unlock"   , POS_SITTING , do_gen_door , 0, SCMD_UNLOCK , 0, 0, 0, 0, 0 ,0 },
  { "unban"    , POS_DEAD    , do_unban    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "unbind"   , POS_DEAD    , do_unbind   ,-1, 0 , 0, 0, 0, 0, 1, 0 },
  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "users"    , POS_DEAD    , do_users    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "users"    , POS_DEAD    , do_users    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "uptime"   , POS_DEAD    , do_date     , 0, SCMD_UPTIME , 1, 0, 0, 0, 1 ,0 },
  

  { "value"    , POS_STANDING, do_not_here , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "varset"     , POS_DEAD    , do_varset     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "varunset"     , POS_DEAD    , do_varunset     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "version"  , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION , 0, 0, 0, 1, 0 ,0 },
  { "veto"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "visible"  , POS_RESTING , do_visible  , 1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "viewdam"  , POS_DEAD    , do_viewdam  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "vnum"     , POS_DEAD    , do_vsearch  , LVL_GRGOD, SCMD_VNUM , 0, 0, 0, 0, 0 ,0 },
  { "vlist"    , POS_DEAD    , do_vsearch  , LVL_GRGOD, SCMD_VLIST , 0, 0, 0, 0, 0 ,0 },
  { "vsearch"  , POS_DEAD    , do_vsearch  , LVL_GRGOD, SCMD_VSEARCH , 0, 0, 0, 0, 0 ,0 },
  { "vfind"    , POS_DEAD    , do_vsearch  , LVL_GRGOD, SCMD_VSEARCH , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_GRGOD, SCMD_VSTAT , 0, 0, 0, 0, 0 ,0 },
  { "zstat"    , POS_DEAD    , do_zstat    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "estat"    , POS_DEAD    , do_estat    , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "oestat"   , POS_DEAD    , do_estat    , LVL_GRGOD, SCMD_OESTAT, 0, 0, 0, 0, 0, 0 },
  { "restat"   , POS_DEAD    , do_estat    , LVL_GRGOD, SCMD_RESTAT, 0, 0, 0, 0, 0, 0 },
#else
  { "vnum"     , POS_DEAD    , do_vsearch  , LVL_BUILDER, SCMD_VNUM , 0, 0, 0, 0, 0 ,0 },
  { "vlist"    , POS_DEAD    , do_vsearch  , LVL_BUILDER, SCMD_VLIST , 0, 0, 0, 0, 0 ,0 },
  { "vsearch"  , POS_DEAD    , do_vsearch  , LVL_BUILDER, SCMD_VSEARCH , 0, 0, 0, 0, 0 ,0 },
  { "vfind"    , POS_DEAD    , do_vsearch  , LVL_BUILDER, SCMD_VSEARCH , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_BUILDER, SCMD_VSTAT , 0, 0, 0, 0, 0 ,0 },
  { "zstat"    , POS_DEAD    , do_zstat    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "estat"    , POS_DEAD    , do_estat    , LVL_BUILDER, 0, 0, 0, 0, 0, 0, 0 },
  { "oestat"   , POS_DEAD    , do_estat    , LVL_BUILDER, SCMD_OESTAT, 0, 0, 0, 0, 0, 0 },
  { "restat"   , POS_DEAD    , do_estat    , LVL_BUILDER, SCMD_RESTAT, 0, 0, 0, 0, 0, 0 },
#endif
  { "vitem"    , POS_DEAD    , do_vitem    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vwear"    , POS_DEAD    , do_vwear    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },

  { "wake"     , POS_SLEEPING, do_wake     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "walk"     , POS_STANDING, do_move     , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "wave"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wear"     , POS_RESTING , do_wear     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wait"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "weather"  , POS_RESTING , do_weather  , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "wet"      , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "who"      , POS_DEAD    , do_who      , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "whap"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whatever" , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI , 1, 0, 0, 1, 0 ,0 },
#ifdef PRODUCTION
  { "where"    , POS_RESTING , do_where    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "where"    , POS_RESTING , do_where    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "whisper"  , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER , 0, 0, 0, 0, 0 ,0 },
  { "whine"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whistle"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wield"    , POS_RESTING , do_wield    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wiggle"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wince"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wink"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "withdraw" , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wiznet"   , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { ";"        , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "wizhelp"  , POS_SLEEPING, do_commands , LVL_IMMORT, SCMD_WIZHELP , 0, 0, 0, 0, 0 ,0 },
  { "wizlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST , 0, 0, 0, 0, 0 ,0 },
  { "wizlock"  , POS_DEAD    , do_wizlock  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "worship"  , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "write"    , POS_STANDING, do_write    , 3, 0 , 0, 0, 0, 0, 0 ,0 },

  { "yawn"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "yodel"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "zone"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "zedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
  { "znum"     , POS_DEAD    , do_znum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "zreset"   , POS_DEAD    , do_zreset   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "zlist"    , POS_DEAD    , do_zlist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
#else
  { "zedit"    , POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
  { "znum"     , POS_DEAD    , do_znum     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "zreset"   , POS_DEAD    , do_zreset   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
  { "zlist"    , POS_DEAD    , do_zlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
#endif

  { "game"     , POS_DEAD    , do_game     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },  
  { "world"    , POS_DEAD    , do_world    , 0, 0 , 0, 0, 0, 0, 0 ,0 },  
  { "fup"      , POS_STANDING, do_move     ,-1, SCMD_FUP , 0, 0, 0, 0, 0 ,0 },
  { "fdown"    , POS_STANDING, do_move     ,-1, SCMD_FDOWN , 0, 0, 0, 0, 0 ,0 },
d646 347
d995 30
a1024 41
  { "attach"   , POS_DEAD    , do_attach   , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },
  { "z001#@@#"  , POS_SLEEPING, do_action   ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "detach"   , POS_DEAD    , do_detach   , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "tlist"    , POS_DEAD    , do_vsearch_trigger, LVL_GRGOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "tnum"     , POS_DEAD    , do_vsearch_trigger, LVL_GRGOD, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "tsearch"  , POS_DEAD    , do_vsearch_trigger, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "tfind"    , POS_DEAD    , do_vsearch_trigger, LVL_GRGOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "tlist"    , POS_DEAD    , do_vsearch_trigger, LVL_GOD, SCMD_VLIST, 0, 0, 0, 0, 0 ,0 },
  { "tnum"     , POS_DEAD    , do_vsearch_trigger, LVL_GOD, SCMD_VNUM, 0, 0, 0, 0, 0 ,0 },
  { "tsearch"  , POS_DEAD    , do_vsearch_trigger, LVL_GOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "tfind"    , POS_DEAD    , do_vsearch_trigger, LVL_GOD, SCMD_VSEARCH, 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
  { "masound"  , POS_DEAD    , do_masound  ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mkill"    , POS_STANDING, do_mkill    ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mjunk"    , POS_DEAD    , do_mjunk    ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "log"      , POS_DEAD    , do_mob_log  ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "msend"    , POS_DEAD    , do_msend    ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mecho"    , POS_DEAD    , do_mecho    ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mechoaround", POS_DEAD, do_mechoaround,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mskillset", POS_DEAD    , do_mskillset,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mload"    , POS_DEAD    , do_mload    ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mpurge"   , POS_DEAD    , do_mpurge   ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mgoto"    , POS_DEAD    , do_mgoto    ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mat"      , POS_DEAD    , do_mat      ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mteleport", POS_DEAD    , do_mteleport,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "quest"    , POS_DEAD    , do_quest    ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qadd"     , POS_DEAD    , do_qadd     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qdel"     , POS_DEAD    , do_qdel     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qlist"    , POS_DEAD    , do_qlist    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qstat"    , POS_DEAD    , do_qstat    , LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "mforce"   , POS_DEAD    , do_mforce   ,-1, 0 , 0, 0, 0, 1, 0 ,0 },
  { "m_run_room_trig", POS_DEAD, do_m_run_room_trig, -1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "DumbMobTrack", POS_STANDING, do_DumbMobTrack ,-1, 0 , 0, 0, 0, 0, 0 ,0},
  { "mexp"     , POS_DEAD    , do_mexp     ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mdamage"  , POS_DEAD    , do_mdamage  ,-1, 0 , 0, 0, 0, 1, 0 ,0 },


d1026 1
a1026 2

  { "\n", 0, 0, 0, 0 , 0, 0, 0, 1, 0 ,0 } };	/* this must be last */
d1070 4
a1073 6
  if (ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL]) {
    if (IS_FIGHTING(ch)) {
      act("You ARE too determined to kill $N at the moment.",
	  FALSE, ch, 0, FIGHTING(ch), TO_CHAR);
      return;
    }
d1075 1
d1100 1
a1100 1
  if (IS_HIDDEN(ch) && !cmd_info[cmd].hide) {
d1105 1
a1105 1
  if (PLR_FLAGGED(ch, PLR_MEDITATE) && cmd_info[cmd].meditate == 0) {
d1116 1
a1116 1
           !cmd_info[cmd].bound)
d1118 2
a1119 1
  else if (AFF_FLAGGED(ch, AFF_MAJOR_PARA) && !cmd_info[cmd].major_p)
d1121 2
a1122 1
  else if (AFF2_FLAGGED(ch, AFF2_MINOR_PARALYSIS) && !cmd_info[cmd].minor_p)
d1124 1
a1124 1
  else if (CASTING(ch) && cmd_info[cmd].cast == 0)
a1181 55
void display_question(struct descriptor_data *d)
{
   /* 	bool used = FALSE; */
  int i;
  char *stats[6] = {	"\r\n1)Working up a sweat at work or training, from dusk to dawn",			
			"2)Physical Strength and Power",
			"3)Cunningness and speed on feet",
			"4)Religeon, Historical and Political Study's",	
			"5)Spending most your time in the library",
			"6)Helping out your fellow neighbour"};
  
  /*colours:	norm:CCNRM(d->character,C_SPR)
    green:CCGRN(d->character,C_SPR)
    bold:CCBLD(d->character,C_SPR)
  */
  strcpy(buf, "");
  for (i=0;i<6;i++)
    {
      if (GET_ROLL(d->character, i))
	sprintf(buf, "%s",CCGRN(d->character,C_SPR));
      else
	sprintf(buf, "%s%s",CCGRN(d->character,C_SPR), CCBLD(d->character,C_SPR)); 
      sprintf(buf, "%s%s&0", buf, stats[i]);
      if (GET_ROLL(d->character, i))
	sprintf(buf, "%s&0&6[&0&6&b%d&0&6]&0\r\n",buf, (int)GET_ROLL(d->character, i));
      else
	sprintf(buf, "%s\r\n", buf);
      
      send_to_char(buf, d->character);
    }
  send_to_char("\r\n>", d->character);
}

bool ask_question(struct descriptor_data *d, int question, char *arg)
{
  int result;
  if (!is_number(arg))
    return FALSE;
  result = atoi(arg) - 1;
  
  if ((result < 0) || (result > 5))
    {
      send_to_char("Incorrect choice\r\n", d->character);
      display_question(d);
      return FALSE;
    }
  if (GET_ROLL(d->character, result))
    {
      send_to_char("Sorry that option is already used.\r\n", d->character);
      return FALSE;
    }
  GET_ROLL(d->character, result) ^= question;
  return TRUE;
}

d3730 4
@


1.192
log
@Chant command is now a subcommand of do_cast.  Songs command moved
to act.informative.c.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.191 2007/10/02 02:52:27 myc Exp myc $
d1587 6
d1594 1
a1594 1
int search_block(char *arg, char **list, bool exact)
d1618 1
a1618 1
int search_block2(char *arg, char **list, bool exact)
d1690 2
d1698 2
d3933 4
@


1.191
log
@Disengage now works as abort when casting.  Report command now has
subcommands for greport and mreport.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.190 2007/09/28 20:49:35 myc Exp myc $
a144 1
ACMD(do_chant);
d313 1
a313 1
ACMD(do_song);
d490 1
a490 1
  { "cast"     , POS_SITTING , do_cast     , 1, 0 , 0, 0, 0, 0, 0 ,0},
d494 1
a494 1
  { "chant"    , POS_STANDING, do_chant    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d952 1
a952 1
  { "songs"    , POS_DEAD    , do_song     , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d3923 4
@


1.190
log
@The vnum, mnum, onum, rnum, tnum, mlist, olist, rlist, tlist, slist,
vwear, and vitem commands now use the vsearch command suite, which is
now also available through the vsearch, vfind, osearch, ofind, msearch,
mfind, tsearch, tfind, ssearch, sfind, rsearch, rfind, and vlist
commands.
Added a delimited_arg() function (actually just renamed one_word) that
lets you return multi-word arguments surrounded by a given character,
such as a quote.  This is useful for spell casting, for example.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.189 2007/09/21 08:44:45 jps Exp myc $
a199 1
ACMD(do_grep);
d549 1
a549 1
  { "disengage", POS_FIGHTING, do_disengage, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d619 1
a619 1
  { "grep"     , POS_RESTING , do_grep     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d747 1
d831 1
a831 1
  { "report"   , POS_RESTING , do_report   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1240 1
a1240 1
  if ((GET_LEVEL(ch)<LVL_IMMORT) &&
d1303 3
a1305 2
    }else if (no_specials || !special(ch, cmd, line))
      ((*cmd_info[cmd].command_pointer) (ch, line, cmd, cmd_info[cmd].subcmd));
d2123 1
d3924 10
@


1.189
log
@Added object type "touchstone" and command "touch" so you can set
your home room by touching specific objects.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.188 2007/09/20 21:20:43 myc Exp jps $
d178 1
a246 2
ACMD(do_mlist);
ACMD(do_mnum);
a252 1
ACMD(do_onum);
a253 1
ACMD(do_olist);
a283 2
ACMD(do_rlist);
ACMD(do_rnum);
a301 1
ACMD(do_slist);
a302 1
ACMD(do_tnum);
d350 7
a356 1
ACMD(do_vnum);
a357 2
ACMD(do_zstat);
ACMD(do_estat);
a368 1
ACMD(do_wworld);
d373 1
a381 1
ACMD(do_tlist);
d735 4
a738 2
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "mnum"     , POS_DEAD    , do_mnum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d741 4
a744 2
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
  { "mnum"     , POS_DEAD    , do_mnum     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d769 4
a772 2
  { "olist"    , POS_DEAD    , do_olist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "onum"     , POS_DEAD    , do_onum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d777 4
a780 2
  { "olist"    , POS_DEAD    , do_olist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
  { "onum"     , POS_DEAD    , do_onum     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
a853 1
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp,-1, 0, 0, 0, 0, 0, 0 ,0 },
d868 4
a871 2
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
  { "rnum"     , POS_DEAD    , do_rnum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d875 4
a878 2
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
  { "rnum"     , POS_DEAD    , do_rnum     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d882 1
d924 1
a924 1
  { "slist"    , POS_DEAD    , do_slist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d926 2
a927 1
  { "tnum"     , POS_DEAD    , do_tnum     , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d930 1
a930 1
  { "slist"    , POS_DEAD    , do_slist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
d932 2
a933 1
  { "tnum"     , POS_DEAD    , do_tnum     , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
d1055 4
a1058 1
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1065 4
a1068 1
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
a1108 5
#ifdef PRODUCTION
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
d1137 4
a1140 1
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1143 4
a1146 1
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1612 1
a1612 1
int search_block2(char *arg, char **list, int exact)
d1718 1
a1718 5
/*
 * one_word is like one_argument, except that words in quotes ("") are
 * considered one word.
 */
char *one_word(char *argument, char *first_arg)
d1727 1
a1727 1
    if (*argument == '\"') {
d1729 1
a1729 1
      while (*argument && *argument != '\"') {
d1747 9
d3922 4
@


1.188
log
@Hide points and perception are in.  The sneak command no longer exists.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.187 2007/09/20 20:00:01 jps Exp myc $
d345 1
d1007 1
d3900 3
@


1.187
log
@Make gtell, gsay, and tell not interrupt meditation.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.186 2007/09/12 22:23:04 myc Exp jps $
a320 1
ACMD(do_sneak);
d652 1
a652 1
  { "hide"     , POS_STANDING, do_hide     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
a934 1
  { "sneak"    , POS_STANDING, do_sneak    , 1, 0 , 0, 0, 0, 1, 0 ,0 },
d1232 3
a1234 4
  if (AFF_FLAGGED(ch, AFF_HIDE) && cmd_info[cmd].hide == 0) {
    if (affected_by_spell(ch, SPELL_CONCEALMENT))
      appear(ch);
    REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
d3898 3
@


1.186
log
@You can now use the 'walk' and 'go' commands to travel in different
directions.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.185 2007/09/12 19:28:56 myc Exp myc $
d633 2
a634 2
  { "gsay"     , POS_SLEEPING, do_gsay     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gtell"    , POS_SLEEPING, do_gsay     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d982 1
a982 1
  { "tell"     , POS_SLEEPING, do_tell     , 0, 0 , 0, 0, 1, 0, 0 ,0 },
d3901 4
@


1.185
log
@Allow springleap for POS_RESTING.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.184 2007/09/11 16:34:24 myc Exp myc $
d617 1
d1063 1
d3901 3
@


1.184
log
@Added claw, electrify, and peck skills.
Changed is_abbrev to accept const strings.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.183 2007/09/07 19:41:27 jps Exp myc $
d951 1
a951 1
  { "springleap", POS_SITTING, do_springleap, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3899 4
@


1.183
log
@Added "identify" command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.182 2007/08/27 21:18:00 myc Exp jps $
d149 1
d175 1
d261 1
d507 1
d568 1
d786 1
d1769 1
a1769 1
int is_abbrev(char *arg1, char *arg2)
d3899 3
@


1.182
log
@You can now queue up commands while casting as well as abort midcast.
Casting commands such as look and abort are caught and interpreted
before the input is normally queued up by the game loop.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.181 2007/08/26 08:49:36 jps Exp myc $
d210 1
d660 1
d3893 5
@


1.181
log
@Added commands estat, oestat, and restat, for viewing extra
descriptions on objects and rooms.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.180 2007/08/25 00:10:41 jps Exp jps $
d440 1
a440 1
  { "abort"    , POS_DEAD    , do_abort    , 0, 0, 0, 0, 0, 0, 0, 1 },
d492 1
a492 1
  { "cast"     , POS_SITTING , do_cast     , 1, 0 , 0, 0, 0, 0, 0 ,1},
d1487 1
a1487 1
      write_to_q(buf, &temp_queue, 1);
d1505 1
a1505 1
  write_to_q(buf, &temp_queue, 1);
d3891 4
@


1.180
log
@Added qstat command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.179 2007/08/24 22:49:05 jps Exp jps $
d356 1
d1038 4
a1041 1
  { "zstat"    , POS_DEAD    , do_zstat    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1046 3
d3891 3
@


1.179
log
@Added "snum" and "tnum" commands.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.178 2007/08/24 22:10:43 jps Exp jps $
d310 1
d1132 1
d3884 3
@


1.178
log
@Add sstat (shop stat) as a subcommand of stat.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.177 2007/08/24 17:01:36 myc Exp jps $
d304 2
d905 3
d910 3
a915 1
  { "slist"    , POS_DEAD    , do_slist    , LVL_IMMORT, 0, 0, 0, 0, 0, 0 ,0 },
d1089 1
d1094 1
a1095 1
  { "zlist"    , POS_DEAD    , do_zlist    , LVL_IMMORT, 0, 0, 0, 0, 0, 0 ,0 },
d3882 3
@


1.177
log
@Adding ostat and mstat commands as shorthand for vstat, rstat for stat
room, and mnum and onum for vnum.  Also adding rnum and znum with new
functionality.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.176 2007/08/24 10:24:16 jps Exp myc $
d303 1
d855 1
d860 1
d908 1
d3874 5
@


1.176
log
@Added zlist command.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.175 2007/08/22 18:01:09 jps Exp jps $
d244 1
d251 1
d284 1
d365 1
d727 2
d731 2
d757 2
d763 2
d852 2
d856 2
a858 1

d935 1
a935 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_GRGOD, 0 , 1, 1, 1, 1, 1 ,1 },
d937 1
a937 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_BUILDER, 0 , 1, 1, 1, 1, 1 ,1 },
d1024 1
a1024 1
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1028 1
a1028 1
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d1076 1
d1080 1
d3870 3
@


1.175
log
@Warn of an imminent reboot immediately when logging in.
Use some global constants to determine who can use the
autoboot and shutdown commands.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.174 2007/08/16 19:53:38 myc Exp jps $
d363 1
d1066 1
d3853 5
@


1.174
log
@Adding stow/palm commands as secondary functionality to conceal skill.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.173 2007/08/15 20:47:41 myc Exp myc $
d58 1
d99 1
d449 1
a449 1
  { "autoboot" , POS_DEAD,     do_autoboot,  LVL_GOD, 0, 0, 0, 0, 0, 0 },
d875 2
a876 6
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#ifdef PRODUCTION
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_HEAD_C, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
#else
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_HEAD_B, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
#endif
d2335 6
a2340 1
            SEND_TO_Q("Sorry, new players can't be created at the moment.\r\n", d);
d2521 6
a2526 1
	SEND_TO_Q("The game is temporarily restricted.. try again later.\r\n", d);
d2538 1
a2538 1
        SEND_TO_Q("Your name has been deemed unacceptable, please choose a new one.\r\n", d);
d3012 1
d3851 3
@


1.173
log
@Conceal and shadow skills can be used while hidden now.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.172 2007/08/14 22:43:07 myc Exp myc $
d252 1
d319 1
d752 1
d927 1
d3842 3
@


1.172
log
@Adding corner, conceal, stealth, and shadow skills.  Also making
stat usable while meditating.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.171 2007/08/14 20:13:22 jps Exp myc $
d504 1
a504 1
  { "conceal"  , POS_STANDING, do_conceal  , 0, 0 , 0, 0, 0, 0, 0, 0},
d864 1
a864 1
  { "shadow"   , POS_RESTING , do_follow   , 0, SCMD_SHADOW , 0, 0, 0, 0, 0 ,0 },
d3838 4
@


1.171
log
@Added command "autoboot" to manage the mud's automatic rebooting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.170 2007/08/05 20:21:51 myc Exp jps $
d149 1
d153 1
d504 2
d575 1
a575 1
  { "follow"   , POS_RESTING , do_follow   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d864 1
d918 1
a918 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d920 1
a920 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d1181 4
a1184 1
  if (AFF_FLAGGED(ch, AFF_HIDE) && (cmd_info[cmd].hide == 0))
d1186 1
d1188 5
a1192 9
  if(PLR_FLAGGED(ch, PLR_MEDITATE))
    if (cmd_info[cmd].meditate == 0){
      REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
      act("$n ceases $s meditative trance.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("&8You stop meditating.\r\n&0", ch);}

  if(affected_by_spell(ch, SPELL_CONCEALMENT))
    if (cmd_info[cmd].hide == 0)
      appear(ch);
d3838 3
@


1.170
log
@Added retreat and group retreat skills.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.169 2007/08/04 20:07:54 jps Exp myc $
d359 1
d443 1
d3833 3
@


1.169
log
@Added socials: flanic, glomp, mumble, twitch, beckon, glower.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.168 2007/08/03 03:51:44 myc Exp jps $
d194 1
d599 1
d812 2
a814 2
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp,-1, 0, 0, 0, 0, 0, 0 ,0 },
  { "retreat"  , POS_FIGHTING, do_retreat  ,-1, 0 , 0, 0, 0, 0, 0 ,0 },
d3831 3
@


1.168
log
@You can now abort spells mid-cast.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.167 2007/07/31 23:03:11 jps Exp myc $
d452 1
d563 1
d587 2
d704 1
d971 1
d3762 6
d3829 3
@


1.167
log
@Add command "zstat" to stat a zone.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.166 2007/07/19 15:32:01 jps Exp jps $
d418 1
a418 1
  { "at"       , POS_DEAD    , do_at       , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d420 1
a420 1
  { "at"       , POS_DEAD    , do_at       , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d422 2
a423 2
  { "abort"    , POS_DEAD    , do_abort    , 0, 0, 0, 0, 0, 0, 0, 1},
  { "ack"      , POS_RESTING , do_action   , 0, 0, 0, 0, 0, 0, 0 ,0 },
d430 1
a430 1
  { "alert"    , POS_RESTING , do_alert    , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
d484 1
a484 1
  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 1, 0, 0, 0, 0 ,0 },
d486 1
a486 1
  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 1, 0, 0, 0, 0 ,0 },
d558 1
a561 1
  { "flee"     , POS_FIGHTING , do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d658 1
a658 1
  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK , 1, 1, 0, 1, 0,0 },
d1183 2
a1184 2
  else if (PLR_FLAGGED(ch, PLR_BOUND) && GET_LEVEL(ch) < LVL_IMMORT &&
	   (cmd_info[cmd].bound == 0))
d1186 1
a1186 1
  else if (IS_AFFECTED(ch, AFF_MAJOR_PARA) && (cmd_info[cmd].major_p == 0))
d1188 1
a1188 2
  else if (IS_AFFECTED2(ch, AFF2_MINOR_PARALYSIS) &&
	   (cmd_info[cmd].minor_p == 0))
d1190 2
a1191 2
  else if(CASTING(ch) && (cmd_info[cmd].cast == 0))
    send_to_char("&8You are busy spellcasting......\r\n&0", ch);
d3817 3
@


1.166
log
@Add "extinguish" as a subcommand of light.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.165 2007/07/18 23:10:31 jps Exp jps $
d341 1
d992 1
d996 1
d3818 3
@


1.165
log
@Allow use of 'consent' while sleeping.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.164 2007/06/30 00:38:39 jps Exp jps $
d175 2
a354 1
ACMD(do_experience);
d550 1
d665 1
a665 1
  { "light"    , POS_RESTING , do_light    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3815 3
@


1.164
log
@Correctly free and then CREATE the 'name' section of player_table
when renaming a player. The prior method, which simply strcpy'd
the new name into the old space, probably performed buffer overruns.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.163 2007/06/24 02:51:44 jps Exp jps $
d495 1
a495 1
  { "consent"  , POS_RESTING , do_consent  , 0, 0 , 0, 0, 0, 0, 0, 0},
d3813 5
@


1.163
log
@Move "skills" command up so that even big deities can use it.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.162 2007/06/04 22:24:41 jps Exp jps $
a2387 11
         player_i = load_char(d->character->player.name, &tmp_store);
         strcpy(tmp_store.name, arg);
         *buf = '\0';
	 /* send the old name to the invalid list */
	 send_to_xnames(GET_NAME(d->character));
	 sprintf(sys_command, "mv %s", get_fname(GET_NAME(d->character), CRASH_FILE));
	 sprintf(sys_command, "%s %s", sys_command, get_fname(arg, CRASH_FILE));
	 system(sys_command);
	 sprintf(sys_command, "mv %s", get_fname(GET_NAME(d->character), PLR_FILE));
	 sprintf(sys_command, "%s %s", sys_command, get_fname(arg, PLR_FILE));
	 system(sys_command);
d2390 24
a2413 4
	 /* change the name in the text player index file */
	 modify_player_index_file(GET_NAME(d->character), arg);
         for(i=0;i<=top_of_p_table;i++) {
            if(!str_cmp(((player_table)+i)->name, d->character->player.name)) {
d3813 3
@


1.162
log
@Add game-toggle for name approval pause and set name approval to default on.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.161 2007/05/28 03:59:05 jps Exp jps $
d863 1
a868 1
  { "skills"   , POS_SLEEPING, do_skills   , 1, 0 , 1, 0, 0, 1, 0 ,0 },
d3804 3
@


1.161
log
@Stop 'forget' from breaking meditation.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.160 2007/05/24 05:25:14 jps Exp jps $
d59 1
d2876 1
a2876 1
         if (approve_names && (top_of_p_table + 1)) {
d2890 3
a2892 1

d3804 3
@


1.160
log
@Don't break meditation or hiding for 'petition'.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.159 2007/05/11 21:33:10 myc Exp jps $
d564 1
a564 1
  { "forget"   , POS_RESTING , do_forget   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3801 3
@


1.159
log
@Made a number of commands (unused, mob-only, etc.) level -1 so they
wouldn't show up on the commands list.  Return is level 0 so I don't
get stuck in level 0 bugs when I switch.  Dig is 104 to go along
with other editing command levels on production.  Turned on the
commands command again.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.158 2007/05/11 21:03:12 myc Exp myc $
d741 1
a741 1
  { "petition" , POS_DEAD    , do_petition , 0, 0 , 0, 0, 0, 0, 1 ,0 },
d3801 7
@


1.158
log
@New rogue skill, eye gouge, allows rogues to gouge out eyes.  A very
complicated skill.  :P  Fixed cure blind's logic, and made it support
eye gouge too.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.157 2007/04/26 15:20:34 myc Exp myc $
d447 1
a447 1
  { "bind"     , POS_STANDING, do_bind     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d462 1
a462 1
  { "breathe"  , POS_FIGHTING, do_breathe  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d493 1
a493 1
  /* { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS , 0, 0, 0, 0, 0 ,0 }, */
a513 1
  { "disembark", POS_STANDING, do_disembark, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d518 1
a518 1
  { "dig"      , POS_STANDING, do_dig      , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d522 1
a522 1
  { "disappear", POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d525 1
d623 1
a623 1
  { "house"    , POS_RESTING , do_house    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d788 1
a788 1
  { "rescue"   , POS_FIGHTING, do_rescue   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d801 3
a803 3
  { "return"   , POS_DEAD    , do_return   , 1, 0 , 0, 0, 0, 0, 0,0 },
  { "rsdiamimp", POS_DEAD    , do_rsdiamimp, -1, 0, 0, 0, 0, 0, 0 ,0 },
  { "retreat"  , POS_FIGHTING, do_retreat  , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d913 1
a913 1
  { "sweep"    , POS_FIGHTING, do_sweep    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d966 1
a966 1
  { "unbind"   , POS_DEAD    , do_unbind   , 0, 0 , 0, 0, 0, 0, 1, 0 },
d1045 2
a1046 2
  { "fup"      , POS_STANDING, do_move     , 0, SCMD_FUP , 0, 0, 0, 0, 0 ,0 },
  { "fdown"    , POS_STANDING, do_move     , 0, SCMD_FDOWN , 0, 0, 0, 0, 0 ,0 },
d1051 1
a1051 1
  { "z001#@@#"  , POS_SLEEPING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1060 14
a1073 14
  { "masound"  , POS_DEAD    , do_masound  , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mkill"    , POS_STANDING, do_mkill    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mjunk"    , POS_DEAD , do_mjunk    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "log"      , POS_DEAD    , do_mob_log, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "msend"    , POS_DEAD    , do_msend    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mecho"    , POS_DEAD    , do_mecho    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mechoaround", POS_DEAD, do_mechoaround , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mskillset", POS_DEAD, do_mskillset , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mload"    , POS_DEAD    , do_mload    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mpurge"   , POS_DEAD    , do_mpurge   , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mgoto"    , POS_DEAD    , do_mgoto    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mat"      , POS_DEAD    , do_mat      , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "mteleport", POS_DEAD    , do_mteleport, 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "quest"    , POS_DEAD    , do_quest    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1077 5
a1081 5
  { "mforce"   , POS_DEAD    , do_mforce   , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "m_run_room_trig" , POS_DEAD , do_m_run_room_trig , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "DumbMobTrack", POS_STANDING, do_DumbMobTrack , 0, 0 , 0, 0, 0, 0, 0 ,0},
  { "mexp"     , POS_DEAD    , do_mexp     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mdamage"  , POS_DEAD    , do_mdamage  , 0, 0 , 0, 0, 0, 1, 0 ,0 },
a1129 5
  /*
   * special case to handle one-character, non-alphanumeric commands;
   * requested by many people so "'hi" or ";godnet test" is possible.
   * Patch sent by Eric Green and Stefan Wasilewski.
   */
d1137 5
d3801 5
@


1.157
log
@Attempting to fix the check-in comment log.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.156 2007/04/25 07:53:01 jps Exp myc $
d174 1
d583 1
d585 1
a585 1
  { "group"    , POS_SLEEPING , do_group    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d3738 2
a3739 1
  "rpain",  
d3801 3
@


1.156
log
@Allow 'visible' to properly terminate hiding.  Don't make an unrecognized
command break hiding.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.155 2007/04/19 07:01:19 myc Exp jps $
d480 1
a480 1
  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 0, 0, 0, 0, 0 ,0 },
d3797 1
@


1.155
log
@Made several informational commands usable during meditation.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.154 2007/04/19 00:53:54 jps Exp myc $
d981 1
a981 1
  { "visible"  , POS_RESTING , do_visible  , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d1084 1
a1084 1
  { "\n", 0, 0, 0, 0 , 0, 0, 0, 0, 0 ,0 } };	/* this must be last */
@


1.154
log
@Create macros for stopping spellcasting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.153 2007/03/27 04:27:05 myc Exp jps $
d425 1
a425 1
  { "aggr"     , POS_DEAD    , do_aggr     , 0, 0, 0, 0, 0, 0, 0 ,0 },
d427 1
a427 1
  { "alias"    , POS_DEAD    , do_alias    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d465 1
a465 1
  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG , 0, 0, 0, 1, 0 ,0 },
d477 1
a477 1
  { "clan"     , POS_SLEEPING, do_clan     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d479 1
a479 1
  { "circle"   , POS_FIGHTING, do_circle   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d482 1
a482 1
  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR , 0, 0, 0, 0, 0 ,0 },
d489 1
a489 1
  { "color"    , POS_DEAD    , do_color    , 0, 0 , 0, 0, 0, 0, 1 ,0 },
d493 1
a493 1
  { "consent"  , POS_RESTING , do_consent  , 0, 0, 0, 0, 0, 0, 0, 0},
d512 1
a512 1
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d515 1
a515 1
  { "display"  , POS_DEAD    , do_display  , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d546 1
a546 1
  { "experience", POS_DEAD   , do_experience ,0, 0, 0, 0, 0, 1, 0 ,0 },
d598 1
a598 1
  { "help"     , POS_DEAD    , do_help     , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d627 1
a627 1
  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA , 0, 0, 0, 1, 0 ,0 },
d630 1
a630 1
  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST , 0, 0, 0, 1, 0 ,0 },
d634 1
a634 1
  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO , 0, 0, 0, 1, 0 ,0 },
d646 1
a646 1
  { "justice"  , POS_DEAD    , do_justice  , 1, 0 , 0, 0, 0, 1, 0 ,0 },  
d659 1
a659 1
  { "level"    , POS_SLEEPING, do_level    , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d705 1
a705 1
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS, 0, 0, 0, 1, 0 ,0 },
d745 1
a745 1
  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES , 0, 0, 0, 1, 0, 0 },
d752 1
a752 1
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d821 1
a821 1
  { "save"     , POS_SLEEPING, do_save     , LVL_BUILDER, 0 , 0, 0, 0, 1, 1 ,0 },
d890 1
a890 1
  { "spells"   , POS_RESTING , do_spells   , 1, 0 , 0, 0, 0, 1, 0 ,0 },
d946 1
a946 1
  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d956 1
a956 1
  { "trophy"   , POS_DEAD    , do_trophy   , 0, 0, 0, 0, 0, 1, 0, 0}, 
d960 1
a960 1
  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO , 0, 0, 0, 1, 0 ,0 },
d973 1
a973 1
  { "uptime"   , POS_DEAD    , do_date     , 0, SCMD_UPTIME , 0, 0, 0, 0, 1 ,0 },
d999 1
a999 1
  { "who"      , POS_DEAD    , do_who      , 0, 0 , 0, 0, 0, 1, 0 ,0 },
d1002 1
a1002 1
  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI , 0, 0, 0, 1, 0 ,0 },
@


1.153
log
@Decreased extra description length by 1 to try and prevent buffer overrun.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.152 2006/11/26 08:31:17 jps Exp myc $
d1177 1
a1177 1
    send_to_char("You try, but your bound tight...\r\n", ch);
d1179 1
a1179 1
    send_to_char("&6Your paralized to the bone!\r\n&0", ch);
d1182 2
a1183 2
    send_to_char("&6Your paralized to the bone!\r\n&0", ch);
  else if(PLR_FLAGGED(ch, PLR_CASTING) && (cmd_info[cmd].cast == 0))
@


1.152
log
@Changed name acceptability blurb, and moved it up in the character creation process.
Disabled hometown selection since we only have one choice for it.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.151 2006/11/23 00:36:24 jps Exp jps $
d2984 1
a2984 1
      d->max_str = EXDSCR_LENGTH;
@


1.151
log
@Re-enable player descriptions, because string_add in modify.c
is fixed.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.150 2006/11/18 21:10:03 jps Exp jps $
d1803 5
a1807 6
    sprintf(buf, "%s\r\n&6&bChoose %s %s %s %s %s or [?] for help: ", buf,
	    warriorok ? "[&0&1&bw&0&6&b]arrior," : "",
	    clericok ? "[&0&1&bc&0&6&b]leric," : "",
	    mageok ? "[&0&1&bs&0&6&b]orcerer," : "",
	    rogueok ? "[&0&1&br&0&6&b]ogue," : "",
	    shamanok ? "s[&bh&0&1]aman," : "");
d2114 1
a2114 1
  switch (STATE(d)) { 
d2147 5
a2151 3
    if (!*arg || LOWER(*arg) == 'y') {
      SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
      SEND_TO_Q("Color is on.\r\n", d);
d2153 4
a2156 4
      SEND_TO_Q(GREETINGS, d);
      SEND_TO_Q(GREETINGS2, d);
      SEND_TO_Q(GREETINGS3, d);
      SEND_TO_Q(GREETINGS4, d);
d2158 3
a2160 3
      SEND_TO_Q(TEST_GREETING, d);
      SEND_TO_Q(TEST_GREETING2, d);
      SEND_TO_Q(TEST_GREETING3, d);
d2162 7
a2168 5
      SEND_TO_Q(bcbuf, d);
      SEND_TO_Q(WHOAREYOU, d);
    } else if (LOWER(*arg) == 'n') {
      REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
      SEND_TO_Q("Color is off.\r\n", d);
d2170 4
a2173 4
      SEND_TO_Q(GREETINGS, d);
      SEND_TO_Q(GREETINGS2, d);
      SEND_TO_Q(GREETINGS3, d);
      SEND_TO_Q(GREETINGS4, d);
d2175 3
a2177 3
      SEND_TO_Q(TEST_GREETING, d);
      SEND_TO_Q(TEST_GREETING2, d);
      SEND_TO_Q(TEST_GREETING3, d);
d2179 7
a2185 6
      SEND_TO_Q(bcbuf, d);
      SEND_TO_Q(WHOAREYOU, d);
    } else {
      SEND_TO_Q("That is not a proper response.\r\n", d);
      SEND_TO_Q(ANSI, d);
      return;
a2186 1
    STATE(d) = CON_GET_NAME;
d2188 14
a2201 4
  case CON_GET_NAME:
    if (!*arg)
      close_socket(d);
    else {
d2203 5
a2207 5
	  strlen(tmp_name) > MAX_NAME_LENGTH ||
	  fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
	SEND_TO_Q("Invalid name, please try another.\r\n"
		  "Name: ", d);
	return;
a2209 1

d2212 7
a2218 7
      /* Ispell check here */
      /* What ever genius coded this stopped players who already had characters
         from suddenly being able to login. Dude.. that's bad m'kay?  Hopefully
         This level check will let any existing player into the mud so if they
         have bad names they can be fixed without runing their character. -
         RSD 3/26/2003
      */
d2220 20
a2239 16
      if (tmp_store.level == 0) {
	if (ispell_name_check(tmp_name)) {
	  /* Take a character name that is a word in the dictionary or closely
	     resembles a word in the dictionary and make them think it's a 
	     valid existing character name and boot the connection.  Yes I'm
	     evil - RSD 8/29/2002 <-- genius
	  */
	  sprintf(buf,"%s is being ninja rejected by the name approval code.", tmp_name);
	  log(buf);	  
	  SEND_TO_Q("Welcome back!\r\n",d);        
	  SEND_TO_Q("Password: ", d);
	  echo_off(d);
	  d->idle_tics = 0;	
	  STATE(d) = CON_ISPELL_BOOT;
	  return;
	}
a2240 1
    
d2242 2
a2243 49
      /* WTF!? A player is level 0?! Remove them from index before they crash the mud!
         RSD 10/11/2000 */
      if (player_i > -1 && tmp_store.level == 0) {
	sprintf(buf,"SYSERR: Deleted level zero ch %s from player index.", tmp_name); 
	log(buf);
	delete_player_from_index(tmp_name);
      }
      
      if (player_i > -1 && tmp_store.level != 0) {
	
        if (PRF_FLAGGED(d->character, PRF_COLOR_1))
          color = 1;
	
	store_to_char(&tmp_store, d->character);
	GET_PFILEPOS(d->character) = player_i;
	if (PLR_FLAGGED(d->character, PLR_DELETED)) {
	  free_char(d->character);
	  CREATE(d->character, struct char_data, 1);
	  clear_char(d->character);
	  CREATE(d->character->player_specials, struct player_special_data, 1);
	  d->character->desc = d;
	  CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
	  strcpy(d->character->player.name, CAP(tmp_name));
	  GET_PFILEPOS(d->character) = player_i;
	  
  	  if (color) 
  	    SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
  	  else
   	    REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
	  
	  sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
	  SEND_TO_Q(buf, d);
	  STATE(d) = CON_NAME_CNFRM;
	} else {
	  /* undo it just in case they are set */
	  REMOVE_BIT(PLR_FLAGS(d->character),
		     PLR_WRITING | PLR_MAILING | PLR_CRYO);
	  
	  if (color)
	    SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
	  else
	    REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
	  
	  SEND_TO_Q("Password: ", d);
	  echo_off(d);
	  d->idle_tics = 0;
	  STATE(d) = CON_PASSWORD;
	}
      } else {
d2245 15
a2259 1
	/* player unknown -- make new character */
d2261 5
a2265 5
	if (!Valid_Name(tmp_name)) {
	  SEND_TO_Q("Invalid name, please try another.\r\n", d);
	  SEND_TO_Q("Name: ", d);
	  return;
	}
d2267 2
d2270 5
a2274 6
	CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
	strcpy(d->character->player.name, CAP(tmp_name));
	
	sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
	SEND_TO_Q(buf, d);
	STATE(d) = CON_NAME_CNFRM;
d2276 22
a2297 1
    }
d2300 33
a2332 18
    if (UPPER(*arg) == 'Y') {
      if (isbanned(d->host) >= BAN_NEW) {
	sprintf(buf, "Request for new char %s denied from [%s] (siteban)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	SEND_TO_Q("Sorry, new characters are not allowed from your site!\r\n", d);
	STATE(d) = CON_CLOSE;
	return;
      }
      if (restrict) {
	SEND_TO_Q("Sorry, new players can't be created at the moment.\r\n", d);
	sprintf(buf, "Request for new char %s denied from %s (wizlock)",
		GET_NAME(d->character), d->host);
	mudlog(buf, NRM, LVL_GOD, TRUE);
	STATE(d) = CON_CLOSE;
	return;
      }
      SEND_TO_Q("New character.\r\n", d);
d2334 23
a2356 6
      /* This deletes any existing files a NEW character might have from a leftover old
         character of the same name... I hope RSD 10/11/2000 */
      get_filename(GET_NAME(d->character), buf, PLR_FILE);
      if(unlink(buf) == 0) {
	sprintf(buf,"SYSERR: Deleted existing player file for NEW ch %s.", GET_NAME(d->character));
	log(buf);
d2358 1
a2358 19
      get_filename(GET_NAME(d->character), buf, CRASH_FILE);
      if(unlink(buf) == 0) {
	sprintf(buf,"SYSERR: Deleted existing object file for NEW ch %s.", GET_NAME(d->character));
	log(buf);
      }
      
      sprintf(buf, "Give me a password for %s: ", GET_NAME(d->character));
      SEND_TO_Q(buf, d);
      echo_off(d);
      STATE(d) = CON_NEWPASSWD;
    } else if (*arg == 'n' || *arg == 'N') {
      SEND_TO_Q("Okay, what IS it, then? ", d);
      free(d->character->player.name);
      d->character->player.name = NULL;
      STATE(d) = CON_GET_NAME;
    } else {
      SEND_TO_Q("Please type Yes or No: ", d);
    }
    break;
d2367 1
a2367 1
	SEND_TO_Q("Invalid name, please try another.\r\n"
d2378 1
a2378 1
      SEND_TO_Q("Invalid name, please try another.\r\n", d);
d2558 1
a2558 1
      SEND_TO_Q("What is your sex (M/F)? ", d);
d2581 2
a2582 2
      SEND_TO_Q("That is not a sex..\r\n"
		"What IS your sex? ", d);
a2597 5
#ifdef PRODUCTION
    STATE(d) = CON_NAME_CHECK;    
    SEND_TO_Q(NAMES_EXPLANATION, d);    
    break;
#else
a2600 1
#endif
d2605 3
a2607 1
      SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
a2611 5
#ifdef PRODUCTION
    STATE(d) = CON_NAME_CHECK;    
    SEND_TO_Q(NAMES_EXPLANATION, d);    
    break;
#else
a2614 1
#endif
d2620 3
a2622 1
      SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
a2625 6

#ifdef PRODUCTION
    STATE(d) = CON_NAME_CHECK;    
    SEND_TO_Q(NAMES_EXPLANATION, d);    
    break;
#else
a2628 3
#endif


d2630 14
a2643 7
    if ( !str_cmp(arg, "y") || !str_cmp(arg, "ye") || !str_cmp(arg, "yes") ) {
      STATE(d) = CON_QCLASS;
      display_classes(d,1); 
      return;     
    } else {
      STATE(d) = CON_CLOSE;
      break;
d2645 1
a2645 1
    
d2696 1
a2696 1
    case '?':
d2703 1
a2703 1
      return;
d2711 5
a2715 2
    /*Start of Rollor opperations*/
    
d2717 4
d2722 1
a2722 1
    display_hometown(GET_RACE(d->character), GET_CLASS(d->character), 
d2725 1
a2725 1
    STATE(d) = CON_QHOMETOWN;
d2764 1
a2764 1
    SEND_TO_Q("Please press ENTER to roll your attributes\r\n", d);
d2851 2
a2852 1
	      "&0&4&bDo you wish to keep this character(y)?('n' will take you back to start menu)\r\n&0", d);
d2856 31
a2886 3
    *arg = LOWER(*arg);
    if (*arg == 'n') {
      GET_NATURAL_STR(d->character) = 0;
d2888 9
a2896 7
      for (i=0;i<6;i++) {
	GET_ROLL(d->character, i) = 0;
      }
      
      SEND_TO_Q("What is your sex (M/F)? ", d);
      STATE(d) = CON_QSEX;
      break;
d2898 1
a2898 28
    
    if (approve_names && (top_of_p_table + 1)) {
      
      if (!PLR_FLAGGED(d->character, PLR_NAPPROVE)) {
	SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
      }
      CREATE(name_event, struct name_timeout_event, 1);
      name_event->d = d;
      event_create(name_timeout, name_event, NAME_TIMEOUT);
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\n"
                "If no one is available, you will be auto approved in a short time.\r\n", d);
      broadcast_name(d->character->player.name);
      STATE(d) = CON_NAME_WAIT_APPROVAL;
      break;

    } else {

      if (GET_PFILEPOS(d->character) < 0) {
	GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
      }
      init_char(d->character);
      save_char(d->character, NOWHERE);
      SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
      STATE(d) = CON_RMOTD;
      break;
    }
    
@


1.150
log
@Add mdamage for dg scripting.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.149 2006/11/14 21:45:51 jps Exp jps $
d2951 1
a2951 5
    case '2': /*This may be cause of pfile barfing. -Nechtrous */
      SEND_TO_Q("Player description disabled temporarily\r\n", d);
      STATE(d) = CON_MENU;
      break;
      /* Remove above 3 lines when description debugged */
d2955 2
a2956 2
 	SEND_TO_Q("Current description:\r\n", d);
  	SEND_TO_Q(d->character->player.description, d);
@


1.149
log
@Check invstart as well when determining the level of the syslog
message to send when a god connects.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.148 2006/11/08 07:55:17 jps Exp jps $
d374 1
d1079 1
@


1.148
log
@Change verbal instances of "breath" to "breathe"
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.147 2006/07/20 10:09:06 dce Exp $
d2487 4
a2490 2
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
      
@


1.147
log
@Hedit to level 103
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.146 2006/05/11 03:07:50 cjd Exp dce $
d139 1
a139 1
ACMD(do_breath);
d460 1
a460 1
  { "breath"   , POS_FIGHTING, do_breath   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.146
log
@adjusted olc levels to make all minimum L104 on PRODUCTION
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.145 2006/04/11 08:53:58 rls Exp $
d599 1
a599 1
  { "hedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
@


1.145
log
@reverted to previous command levels.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.143 2005/07/26 05:39:08 jwk Exp rls $
d599 1
a599 1
  { "hedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
d607 1
a607 1
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
d679 1
a679 1
  { "medit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
d721 2
a722 2
  { "olc"      , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
d802 1
a802 1
  { "redit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
d837 1
a837 1
  { "sedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
d950 1
a950 1
  { "trigedit" , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
d1023 1
a1023 1
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d1033 1
a1033 1
  { "zedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
@


1.144
log
@updated command access levels
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.143 2005/07/26 05:39:08 jwk Exp $
d439 1
a439 1
  { "ban"      , POS_DEAD    , do_ban      , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d506 1
a506 1
  { "dc"       , POS_DEAD    , do_dc       , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d517 1
a517 1
  { "dig"      , POS_STANDING, do_dig      , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
d555 1
a555 1
  { "flee"     , POS_FIGHTING , do_flee    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d582 1
a582 1
  { "group"    , POS_SLEEPING , do_group   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d599 1
a599 1
  { "hedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
d654 2
a655 2
  { "layhands" , POS_FIGHTING, do_layhand  , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
  { "last"     , POS_DEAD    , do_last     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d661 4
a664 4
  { "listclass", POS_DEAD    , do_listclass, LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listrace" , POS_DEAD    , do_listrace , LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listexp"  , POS_STANDING, do_listexp  , LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
d679 1
a679 1
  { "medit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
d697 1
a697 1
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
d709 1
a709 1
  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_NOTITLE , 0, 0, 0, 0, 0 ,0 },
d721 3
a723 3
  { "olc"      , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
  { "olist"    , POS_DEAD    , do_olist    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
d735 1
a735 1
  { "peace"    , POS_DEAD    , do_peace    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
d741 1
a741 1
  { "players"  , POS_DEAD    , do_players  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d784 1
a784 1
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
d788 4
a791 4
  { "restore"  , POS_DEAD    , do_restore  , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pain"     , POS_DEAD    , do_pain     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rpain"    , POS_DEAD    , do_rpain    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d802 1
a802 1
  { "redit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
d806 1
a806 1
  { "rename"   , POS_DEAD    , do_rename   , LVL_GOD, 0, 0,0,0,0,0,0},
d813 1
a813 1
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
d833 1
a833 1
  { "send"     , POS_SLEEPING, do_send     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d837 1
a837 1
  { "sedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
d849 1
a849 1
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d851 1
a851 1
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_GRGOD, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
d853 1
a853 1
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_GOD, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
d860 1
a860 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d862 1
a862 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d882 1
a882 1
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d897 1
a897 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d913 1
a913 1
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d950 1
a950 1
  { "trigedit" , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
d966 2
a967 2
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "users"    , POS_DEAD    , do_users    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d976 1
a976 1
  { "varset"   , POS_DEAD    , do_varset   , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d981 1
a981 1
  { "viewdam"  , POS_DEAD    , do_viewdam  , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d983 2
a984 2
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1003 1
a1003 1
  { "where"    , POS_RESTING , do_where    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1023 1
a1023 1
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1033 1
a1033 1
  { "zedit"    , POS_DEAD    , do_olc      , LVL_HEAD_C, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
d1051 2
a1052 2
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.143
log
@Added function to remove any initial slash whether \ or /
as long as it's the first character in the line.  This function
is run before stripping any spaces. -Snobol-
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.142 2005/06/26 03:20:52 cjd Exp $
d439 1
a439 1
  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d506 1
a506 1
  { "dc"       , POS_DEAD    , do_dc       , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d517 1
a517 1
  { "dig"      , POS_STANDING, do_dig      , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d555 1
a555 1
  { "flee"     , POS_FIGHTING , do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d582 1
a582 1
  { "group"    , POS_SLEEPING , do_group    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d599 1
a599 1
  { "hedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_HEDIT , 0, 0, 0, 0, 0 ,0 },
d654 2
a655 2
  { "layhands"    , POS_FIGHTING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
  { "last"     , POS_DEAD    , do_last     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d661 4
a664 4
  { "listclass", POS_DEAD    , do_listclass, LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listrace" , POS_DEAD    , do_listrace , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listexp"  , POS_STANDING, do_listexp  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
d679 1
a679 1
  { "medit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_MEDIT, 0, 0, 0, 0, 0 ,0 },
d697 1
a697 1
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d709 1
a709 1
  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE , 0, 0, 0, 0, 0 ,0 },
d721 3
a723 3
  { "olc"      , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "oedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_OEDIT, 0, 0, 0, 0, 0 ,0 },
  { "olist"    , POS_DEAD    , do_olist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d735 1
a735 1
  { "peace"    , POS_DEAD    , do_peace    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d741 1
a741 1
  { "players"  , POS_DEAD    , do_players  , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
d784 1
a784 1
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
d788 4
a791 4
  { "restore"  , POS_DEAD    , do_restore  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pain"     , POS_DEAD    , do_pain     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rpain"    , POS_DEAD    , do_rpain    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d802 1
a802 1
  { "redit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_REDIT, 0, 0, 0, 0, 0 ,0 },
d806 1
a806 1
  { "rename"   , POS_DEAD    , do_rename   , LVL_GRGOD, 0, 0,0,0,0,0,0},
d813 1
a813 1
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_GRGOD, 0, 0, 0, 0, 0, 0 ,0 },
d833 1
a833 1
  { "send"     , POS_SLEEPING, do_send     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d837 1
a837 1
  { "sedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_SEDIT, 0, 0, 0, 0, 0 ,0 },
d849 1
a849 1
  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
d851 1
a851 1
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_HEAD_C, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
d853 1
a853 1
  { "shutdown" , POS_DEAD    , do_shutdown , LVL_HEAD_B, SCMD_SHUTDOWN , 0, 0, 0, 0, 0 ,0 },
d860 1
a860 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d862 1
a862 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d882 1
a882 1
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d897 1
a897 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d913 1
a913 1
  { "syslog"   , POS_DEAD    , do_syslog   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d950 1
a950 1
  { "trigedit" , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_TRIGEDIT, 0, 0, 0, 0, 0 ,0 },
d966 2
a967 2
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "users"    , POS_DEAD    , do_users    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d976 1
a976 1
  { "varset"     , POS_DEAD    , do_varset     , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d981 1
a981 1
  { "viewdam"  , POS_DEAD    , do_viewdam  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d983 2
a984 2
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1003 1
a1003 1
  { "where"    , POS_RESTING , do_where    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1023 1
a1023 1
  { "wworld"   , POS_DEAD    , do_wworld   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d1033 1
a1033 1
  { "zedit"    , POS_DEAD    , do_olc      , LVL_HEAD_B, SCMD_OLC_ZEDIT, 0, 0, 0, 0, 0 ,0 },
d1051 2
a1052 2
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.142
log
@added the pain and rpain command as the opposite of restore
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.141 2005/06/05 01:51:11 cjd Exp $
d1121 1
d1557 7
@


1.141
log
@Adjusted skillset and rrestore command to allow for L103 access
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.140 2005/02/14 07:12:35 rls Exp $
d244 1
d272 1
d790 2
d795 2
d3708 2
@


1.140
log
@Changed a few command levels, such as users, dc, ban, mostly imm justice and
troubleshooting such as stat, etc.  Moved qadd/qdel to head_b since they gr
doesn't really need it, prolly shouldn't have it.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.139 2004/11/28 06:43:14 rsd Exp $
d787 1
a787 1
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
d854 1
a854 1
  { "skillset" , POS_SLEEPING, do_skillset , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.139
log
@changed pfilemaint to be level 105, not sure why it wasn't.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.138 2004/11/13 18:37:51 rsd Exp $
d437 1
a437 1
  { "ban"      , POS_DEAD    , do_ban      , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d504 1
a504 1
  { "dc"       , POS_DEAD    , do_dc       , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d577 1
a577 1
  { "goto"     , POS_SLEEPING, do_goto     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d603 1
a603 1
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
d653 1
a653 1
  { "last"     , POS_DEAD    , do_last     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d659 4
a662 4
  { "listclass", POS_DEAD    , do_listclass, LVL_HEAD_B, 0, 0, 0, 0, 0, 0, 0 },
  { "listrace" , POS_DEAD    , do_listrace , LVL_HEAD_B, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , LVL_HEAD_B, 0, 0, 0, 0, 0, 0, 0 },
  { "listexp"  , POS_STANDING, do_listexp  , LVL_HEAD_C, 0, 0, 0, 0, 0, 0, 0 },
d667 1
a667 1
  { "load"     , POS_DEAD    , do_load     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d695 1
a695 1
  { "mlist"    , POS_DEAD    , do_mlist    , LVL_HEAD_B, 0, 0, 0, 0, 0, 0 ,0 },
d721 1
a721 1
  { "olist"    , POS_DEAD    , do_olist    , LVL_HEAD_B, 0, 0, 0, 0, 0, 0 ,0 },
d782 1
a782 1
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_HEAD_C, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
d800 1
a800 1
  { "rename"   , POS_DEAD    , do_rename   , LVL_HEAD_C, 0, 0,0,0,0,0,0},
d807 1
a807 1
  { "rlist"    , POS_DEAD    , do_rlist    , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
d891 1
a891 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d956 1
a956 1
  { "unban"    , POS_DEAD    , do_unban    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d960 2
a961 2
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_HEAD_C, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "users"    , POS_DEAD    , do_users    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d975 1
a975 1
  { "viewdam"  , POS_DEAD    , do_viewdam  , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
d1045 2
a1046 2
  { "tlist"    , POS_DEAD    , do_tlist    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tstat"    , POS_DEAD    , do_tstat    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d1065 2
a1066 2
  { "qadd"     , POS_DEAD    , do_qadd     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qdel"     , POS_DEAD    , do_qdel     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.138
log
@made the save command 101+ to frustrate players in their
attempts to duplicate equipment.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.137 2004/11/12 05:23:08 rsd Exp $
d737 1
a737 1
  { "pfilemaint", POS_DEAD  , do_pfilemaint, LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.137
log
@I missed a place to add the additional buffers to the
login splash screens, got them fixed now.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.136 2004/11/11 23:24:53 rsd Exp $
d814 1
a814 1
  { "save"     , POS_SLEEPING, do_save     , 0, 0 , 0, 0, 0, 1, 1 ,0 },
@


1.136
log
@Split up the subclass_descrip into 2 parts so the compiler
would stop crying about the buffer being larger than 509
bytes.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.135 2004/11/11 23:03:22 rsd Exp $
d2152 3
d2157 2
@


1.135
log
@Added more char stars to output to Q for the greeting
because the compiler didn't like them being over
509 bytes.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.134 2004/11/01 01:15:52 rsd Exp $
d51 1
d1711 1
@


1.134
log
@Changed the level iptables can be used.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.133 2004/10/31 20:38:11 jjl Exp $
d2061 3
d2066 2
d2135 3
d2140 2
@


1.133
log
@Adding iptables command
for zzur to hack on
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.132 2004/09/12 20:23:57 mud Exp $
d633 5
a637 2
  { "iptables"    , POS_DEAD    , do_iptables    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },

a640 1

@


1.132
log
@changed vnum and vstat to be level 102 for production
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.131 2003/07/24 22:22:30 jjl Exp mud $
d206 1
d633 2
@


1.131
log
@Added the "log" command for mob, room, and object triggers.  Spits
whatever you want into the log.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.130 2003/06/30 04:05:29 jjl Exp $
d971 2
a972 2
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.130
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.129 2003/06/28 02:02:55 jjl Exp $
d229 1
d1048 1
@


1.129
log
@Added the ability for shapechangers and switched gods to use the "score"
command to see their original stats.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.128 2003/06/28 00:54:15 jjl Exp $
d645 1
a645 1
  { "layhands"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
@


1.128
log
@layhand => layhands (I could swear I've done this before).
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.127 2003/06/25 03:08:38 jjl Exp jjl $
a233 1
ACMD(do_new_score);
a719 2
  { "old"      , POS_DEAD    , do_score    , 0, 0, 0, 0, 0, 1, 0 ,0 },

d809 1
a809 1
  { "score"    , POS_DEAD    , do_new_score, 0, 0 , 1, 1, 1, 1, 1 ,0 },
@


1.127
log
@Layhand => layhands
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.126 2003/06/25 02:21:03 jjl Exp jjl $
d646 1
a646 1
  { "layhand"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
@


1.126
log
@Revised lay hands to not suck.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.125 2003/06/23 01:47:09 jjl Exp $
d3611 1
a3611 1
  "layhand",
@


1.125
log
@Added a NOFOLLOW flag, and the "note" command, and show notes <player>
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.124 2003/06/21 01:01:08 jjl Exp $
d646 1
a646 1
/*{ "layhand"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, */
@


1.124
log
@Modified rogues.  Removed circle - backstab is now circlicious.  Updated
damage on backstab to give a little more pop.  Throatcut is now a once a day.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.123 2003/03/26 11:55:35 rsd Exp $
d235 1
d702 1
@


1.123
log
@CRAP, I fixed the ispel_name check code to allow
existing players to login regardless.  The code was
booting valid players with names it didn't like, so
we had level 90+ players denied their characters. bad bad
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.122 2002/10/22 02:14:49 dce Exp $
d433 1
a433 1
  { "backstab" , POS_STANDING, do_backstab , 1, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.122
log
@Moved ptell to level immort.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.121 2002/09/14 00:12:50 dce Exp $
d2157 4
d2162 23
a2184 12
      if (ispell_name_check(tmp_name)) {
	/* Take a character name that is a word in the dictionary or closely
           resembles a word in the dictionary and make them think it's a 
           valid existing character name and boot the connection.  Yes I'm
           evil - RSD 8/29/2002
         */
	SEND_TO_Q("Welcome back!\r\n",d);        
	SEND_TO_Q("Password: ", d);
	echo_off(d);
	d->idle_tics = 0;	
	STATE(d) = CON_ISPELL_BOOT;
	return;
d2186 1
a2186 2

      player_i = load_char(tmp_name, &tmp_store);
@


1.121
log
@Returned switch to level 101.
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.120 2002/09/13 02:32:10 jjl Exp $
d747 1
a747 1
  { "ptell"    , POS_DEAD    , do_ptell    , LVL_BUILDER, 0, 0, 0, 0, 0, 0, 0 },
@


1.120
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: interpreter.c,v 1.119 2002/09/05 01:54:41 mud Exp $
d899 1
a899 1
  { "switch"   , POS_DEAD    , do_switch   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.119
log
@Fixed a compiler warning message.
@
text
@d1 3
a3 1
// $Id: interpreter.c,v 1.118 2002/08/29 17:32:58 rsd Exp $
d375 5
a379 3
// void do_layhand(struct char_data *ch, char *arg, int cmd);
// void do_first_aid(struct char_data *ch, char *arg, int cmd);
// void do_summon_mount(struct char_data *ch, char *arg, int cmd);
d1226 1
a1226 1
  //	bool used = FALSE;
d3724 465
a4188 463
// Revision 1.112  2002/06/09 21:48:36  rls
// adjusted users and dc to lvl_head_b (where users was)
//
// Revision 1.111  2002/06/09 21:27:13  rls
// Adjusted users level to grgod (seeing as they have dc)
// and adjusted switch-return level to immortal for quest night.
//
// Revision 1.110  2002/04/26 18:54:01  mpg
// modified "group" so group info can be accessed while sleeping
//
// Revision 1.109  2002/04/25 23:48:06  mpg
// modified "glance" and "gossip" so they don't interrupt meditation
//
// Revision 1.108  2002/04/25 23:22:13  mpg
// modified "skskills so it won't interrupt meditating
//
// Revision 1.107  2002/04/24 22:33:09  mpg
// adjusted dmeditate Changed the time command so players could use it while meditating
//
// Revision 1.106  2002/04/17 23:42:43  dce
// Fixed shapechange when you relogin it removes the mob.
//
// Revision 1.105  2002/02/19 02:07:20  dce
// Changed do flee from POS_FIGHTING to POS_STANDING.
//
// Revision 1.104  2002/02/16 02:14:02  dce
// Changed flee to a minimum positiong of standing, from resting.
//
// Revision 1.103  2001/11/14 18:18:02  dce
// Sedit and Seduce have been switched.
// Must be at least standing to search.
//
// Revision 1.102  2001/11/14 16:24:30  dce
// Level 101+ can now set titles.
//
// Revision 1.101  2001/10/15 23:41:13  rjd
// Lowered minimum position of the "get" command to POS_RESTING
// to allow for chars to get things from bags/backpacks/containers
// while resting. For those who nitpick, a person can roll around
// while resting to grab stuff from the ground, as well. :P
//
// Revision 1.100  2001/07/12 23:14:17  mtp
// added varset and varunset from dg_debug.c
//
// Revision 1.99  2001/05/13 16:15:58  dce
// Fixed a bug where somethings wouldn't save when a player
// died and exitied menu option 0 rather than menu option 1.
//
// Revision 1.98  2001/04/24 03:30:32  dce
// Removed the "shit" social/command.
//
// Revision 1.97  2001/04/07 17:02:30  dce
// Added the vitem command.
//
// Revision 1.96  2001/04/02 23:31:21  dce
// Put vwear command into the command list
//
// Revision 1.95  2001/03/29 03:11:04  dce
// Removed the ability to create a shaman from the main menu.
//
// Revision 1.94  2001/03/06 03:10:18  dce
// Fixed a bug where players awaiting a name approval could
// cut their link and then crash the mud.
//
// Revision 1.93  2001/02/27 00:53:23  mtp
// made it possible to do mjunk in death trigger
//
// Revision 1.92  2001/01/20 03:33:21  rsd
// made some god commands on test higher level
//
// Revision 1.91  2000/11/28 00:40:00  mtp
// removed mobprog commands
//
// Revision 1.90  2000/11/26 00:27:42  rsd
// moved recline a ways down in the list of commands so it
// wouldn't be the first 're' parsed on.
//
// Revision 1.89  2000/11/23 00:57:04  mtp
// added mskillset to allow a mob to set skill/spell proficiency
//
// Revision 1.88  2000/11/22 01:51:17  mtp
// allow removeal of quests from global list with dqdel
// note: qdel removes from list but not players, their quest structs are
// managed on login
//
// Revision 1.87  2000/11/22 00:01:41  rsd
// Added all 1 zillion back rlog messages from prior to
// the addition of the $log$ string.
//
// Revision 1.86  2000/11/15 04:07:13  rsd
// made ispell a god command, it was avail to mortals.
//
// Revision 1.85  2000/11/11 22:44:07  rsd
// Fixed tabbing in the master commands array, retabbed part of
// the code while trying to figure out where players get their
// names auto-approved.  Fixed said code not to let players
// whose names have been DECLINED from sitting at the new
// name prompt and getting their new declined names into
// the game anyway.
//
// Revision 1.84  2000/10/31 23:33:20  mtp
// typo fix
//
// Revision 1.83  2000/10/31 23:27:01  mtp
// added qlist and qadd
//
// Revision 1.82  2000/10/27 00:34:45  mtp
// new command quest
//
// Revision 1.81  2000/10/15 04:41:00  cmc
// changes for exp_mesg() and level ** characters
//
// Revision 1.80  2000/10/13 17:51:45  cmc
// re-implemented modified level command.
// modified exp_mesg() for "level gain" code.
//
// Revision 1.79  2000/10/11 23:50:45  rsd
// Chris and jimmy seem to think this will delete any old
// pfile stuff that may exist for a new char left over from
// any old deleted chars,  Added code to check this in
// nanny
//
// Also Checked to see if a player was level 0 on login, if
// they are they are removed from the player index essentially
// deleteing them and push the player requesting the name to
// a new character login.
//
// Revision 1.77  2000/10/07 00:43:55  mtp
// new mob command for triggers m_run_room_trig to run room triggers (mainly for use in death trigs)
//
// Revision 1.76  2000/09/13 22:19:22  rsd
// Altered the level at which some commands are avail as well as
// removed some if defs
//
// Revision 1.75  2000/05/22 22:35:53  rsd
// Added char star for test mud greeting to reflect the old
// FieryMUD test mud banner. They call me the doctor cuz I'm
// always operatin'
//
// Revision 1.74  2000/05/21 23:56:43  rsd
// Altered the level of prompt so mortals can get it to work.
// So they can then be redirected at do_display.
//
// Revision 1.73  2000/05/14 05:19:29  rsd
// made rebooting possible by 103's in test, also
// removed player delete ability due to it's leakyness.
//
// Revision 1.72  2000/04/26 22:52:36  rsd
// altered player menu to add player deletion.
//
// Revision 1.71  2000/04/22 22:36:25  rsd
// fixed spelling of deity in player output, fixed grammar
// error associated with exp indicators. move who to the
// top of the wh's in the command parser so it's first for
// wh.
//
// Revision 1.70  2000/04/17 00:55:48  rsd
// altered the comment header.  Made prompt LVL_IMMORT
//
// Revision 1.69  2000/03/20 04:33:38  rsd
// added ifdefs for test/prod builds to not have to name check
// for the test build.
//
// Revision 1.68  2000/02/24 01:04:18  dce
// Changed wiztitle from a command to a set.
//
// Revision 1.67  2000/02/22 00:51:30  rsd
// Changed text on name autoapprove to be a short time
// instead of a static 5 minutes.
//
// Revision 1.66  2000/02/16 07:59:10  mtp
// added listrace to act.wizard.c it prints the race choice menu that new
// players have (for Az)
//
// Revision 1.65  2000/02/14 19:48:49  mtp
// moved mechoaround to after mecho cos a substring of mechoaround is mecho
// and the wrong cmd was getting run *doh*
// /s
//
// Revision 1.64  2000/02/13 08:53:18  rsd
// Added the PRODUCTION flag ifdef replaceing the TESTMUD
// flag.  Also mucked about with the god commands, giving
// builders more commands on the test muds, and less on
// production.
//
// Revision 1.63  2000/01/31 04:46:25  rsd
// Added ifdefs for a production build to make gods on
// production have different commands than on test.
// Also mopped up several sloppy spacing issues.
//
// Revision 1.61  2000/01/30 23:33:23  rsd
// Added necessary compentents to the menues for good race login.
//
// Revision 1.60  1999/12/10 22:13:45  jimmy
// Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
// level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
// exp code.
//
// Revision 1.59  1999/12/06 20:28:08  cso
// Made "skills" and "tell" doable while sleeping.
//
// Revision 1.58  1999/11/29 00:23:31  cso
// removed unused variables to kill compile warnings
//
// Revision 1.57  1999/11/28 23:28:50  cso
// removed unused arg from roll_natural_abils
//
// Revision 1.56  1999/11/23 15:48:23  jimmy
// Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
// Reinstated dual wield.
// Allowed mobs/players to pick up items while fighting.
// Fixed a bug in the damage message that wrongfully indicated a miss
// due to a rounding error in the math.
// This was all done in order to facilitate the chance to sling your
// weapon in combat.  Dex and proficiency checks are now made on any missed
// attact and a failure of both causes the weapon to be slung.
//
// Revision 1.55  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.54  1999/08/31 22:02:58  mtp
// changed posn of get to STANDING
//
// Revision 1.53  1999/08/31 21:54:44  mtp
// changed examine to a rting (resting) type command
//
// Revision 1.52  1999/08/29 23:01:41  mud
// removed auction since it was being used for a congratulate channel.
//
// Revision 1.51  1999/08/29 17:56:51  mud
// commented out the grats command, it was buggy and I don't want a global
// method to communicate game stuff like that anyway.
//
// Revision 1.50  1999/08/12 17:54:46  dce
// Fixed experience so that there are no overflows of integers that are placed into longs.
// Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
// Hubis coding.
//
// Revision 1.49  1999/08/12 04:25:39  jimmy
// This is a Mass ci of the new pfile system.  The pfile has been split into
// one file for each player in a directory A-Z.  The object files are also
// located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
// screwed up the IDNUM of the person who typed it.  Commented out the frag
// system completely.  It is slated for removal.  Fixed the rename command.
// Fixed all supporting functions for the new system, I hope!
// --Gurlaek 8/11/1999
//
// Revision 1.48  1999/07/24 20:50:18  dce
// Exchange command for banks added.
//
// Revision 1.47  1999/07/23 23:41:47  jimmy
// moved send_toxnames back to where it belongs.
// my fault. --gurlaek
//
// Revision 1.46  1999/07/22 17:43:59  jimmy
// Added pfilemaint command
// --gurlaek
//
// Revision 1.45  1999/07/11 04:18:23  mud
// commented out case5 in the MENU for game login
// players deleting themselves is producing some
// problems as they aren't completely deleted.
//
// Revision 1.44  1999/07/10 03:17:44  mud
// Changed the menue message "That's not a menu choice!" to
// 'Wrong Option!" to continue to Fiery-ify the code...
//
// Revision 1.43  1999/07/07 22:51:54  mud
// added the world command back to reflect the combination of
// uptime and date.
//
// Revision 1.42  1999/07/07 21:57:44  mud
// made the do_world command the do_game command to free up
// world for a similar use to the old fiery.
//
// Revision 1.41  1999/06/30 18:11:09  jimmy
// act.offensive.c    config.c      handler.c    spells.c
// This is a major conversion from the 18 point attribute system to the
// 100 point attribute system.  A few of the major changes are:
// All attributes are now on a scale from 0-100
// Everyone views attribs the same but, the attribs for one race
//   may be differeent for that of another even if they are the
//   same number.
// Mobs attribs now get rolled and scaled using the same algorithim as PC's
// Mobs now have individual random attributes based on race/class.
// The STR_ADD attrib has been completely removed.
// All bonus tables for attribs in constants.c have been replaced by
//   algorithims that closely duplicate the tables except on a 100 scale.
// Some minor changes:
// Race selection at char creation can now be toggled by using
//   <world races off>
// Lots of cleanup done to affected areas of code.
// Setting attributes for mobs in the .mob file no longer functions
//   but is still in the code for later use.
// We now have a spare attribut structure in the pfile because the new
//   system only used three instead of four.
// --gurlaek 6/30/1999
//
// Revision 1.40  1999/06/18 22:24:33  mud
// Cut a piece of name code from case GET_NAME that was
// preventing a password check for player names that were
// declined in file.
// Removed a line of code sending those names to xnames because
// it duped code added to ban.c earlier in this process.
//
// Revision 1.39  1999/06/10 16:56:28  mud
// This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.
// This fixes all of the warnings associated with the new compiler and 
// libraries.  Many many curly braces had to be added to "if" statements to
// clarify their behavior to the compiler.  The name approval code was also
// debugged, and tested to be stable.  The xnames list was converted from an
// array to a linked list to allow for on the fly adding of names to the
// xnames list.  This code compiles fine under both gcc RH5.2 and egcs RH6.0 
//
// Revision 1.38  1999/05/05 17:37:18  mud
// made listspell a level 103+ command
//
// Revision 1.37  1999/05/04 17:19:33  dce
// Name accept system...version one...original code by Fingh, fixed up to work
// by Zantir.
//
// Revision 1.36  1999/05/01 18:01:21  dce
// Allow players to drop all eq and quit.
//
// Revision 1.35  1999/04/23 23:27:10  jimmy
// Fixed warnings/errors associated with the addition of the pendantic compiler flag
// yeeeeehaaawwww.  --gurlaek
//
// Revision 1.34  1999/04/22 18:57:27  mud
// added bold to each of the exp notch indicators.
//
// Revision 1.33  1999/04/18 20:14:23  dce
// *** empty log message ***
//
// Revision 1.32  1999/04/16 19:48:20  dce
// Must be level 3 to post/write
//
// Revision 1.31  1999/04/16 03:55:09  dce
// Removed some things temporarly until they can be fixed.
//
// Revision 1.30  1999/04/09 20:33:04  dce
// Added listexp command
//
// Revision 1.29  1999/04/09 03:38:36  dce
// Junk command is back!
//
// Revision 1.28  1999/04/07 18:12:04  jen 
// Added a msg to the room when a player stops meditating
//
// Revision 1.27  1999/04/07 15:39:34  jen
// Two changes:
// 1) Made prayer a command that doesn't interrupt meditation
// 2) Made 'listclass' a GRGOD command since GRGODs can set classes;
// they need the reference list!
// 
// Selandria / JEN II
//
// Revision 1.26  1999/03/26 19:54:57  dce
// Added new command old -> shows the old do_score
//
// Revision 1.25  1999/03/26 19:44:35  jen  
// Added a mortal gossip channel with 103+ godly control
//
// Revision 1.24  1999/03/22 21:55:12  mud
// Added extended cases for name acceptance ye and yes
//
// Revision 1.23  1999/03/20 18:54:39  tph
// removed attribute priority questions, removed hunter, illusionist, mystic from char generation
//
// Revision 1.22  1999/03/14 00:53:03  mud
// In class.c added a new line before the fiery mud class explanation
// in config.c added the variable for name explanations and added the
// text for the variable
// in interpreter.c added the con_state stuff, whatever that was and
// added the CON_NAME_CHECK affirmation section to the creation menu
// loop or nanny.
// In structs.h added the CON_NAME_CHECK define..
// I also drove Jimmy absolutely insane with the deail in information
// I put into our change control system.
// lala
//
// Revision 1.21  1999/03/05 20:02:36  dce
// Chant added to, and songs craeted
//
// Revision 1.20  1999/03/04 20:13:51  jimmy
// removed silly debug message
// fingon
//
// Revision 1.19  1999/03/01 05:31:34  jimmy
// Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
// list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
// on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
// and take 20 seconds to scribe each page.  This will be more dynamic when the
// SCRIBE skill is introduced.  --Fingon.
//
// Revision 1.18  1999/02/26 22:30:30  dce
// Monk additions/fixes
//
// Revision 1.17  1999/02/23 16:48:06  dce
// Creates a new command called file. Allows us to view files
// through the mud.
//
// Revision 1.16  1999/02/13 19:35:06  mud
// commented out unused variable in line 1554 associated with
//    /* Subclassing explaination/preface */ which was commented
// earlier to hide subclasses from players at login.
//
// Revision 1.15  1999/02/12 21:43:38  mud
// Ok, I finished moving the subclass issue from the class selection view
// the todo list will have more on the work remaining on this.
//
// Revision 1.14  1999/02/12 21:41:28  mud
// I removed the View of the subclasses from the class Selection screen
// In doing so I've created a warning, I have no idea how to fix it,
// someone take a peek at it?
//
// Revision 1.13  1999/02/10 22:21:42  jimmy
// Added do_wiztitle that allows gods to edit their
// godly title ie Overlord.  Also added this title
// to the playerfile
// fingon
//
// Revision 1.12  1999/02/07 07:29:01  mud
// removed debug message
//
// Revision 1.11  1999/02/06 05:32:46  jimmy
// Fixed buffer overflow in do_alias
// fingon
//
// Revision 1.10  1999/02/06 04:29:51  dce
// David Endre 2/5/99
// Added do_light
//
// Revision 1.9  1999/02/06 00:40:36  jimmy
// Major change to incorporate aliases into the pfile
// moved alias structure from interpreter.h to structs.h
// heavily modified alias code in interpreter.c
// Jimmy Kincaid AKA fingon
//
// Revision 1.8  1999/02/04 16:42:34  jimmy
// Combined attributes, score, and exp commands.
//
// Revision 1.7  1999/02/04 00:02:59  jimmy
// max/min exp loss/gain set to 2 notches.
//
// Revision 1.6  1999/02/01 22:40:16  jimmy
// made listspells an LVL_IMMORT command
//
// Revision 1.5  1999/02/01 08:15:46  jimmy
// improved build counter
//
// Revision 1.4  1999/02/01 04:18:50  jimmy
// Added buildcounter to GREETING --Fingon
//
// Revision 1.3  1999/01/31 06:43:09  mud
// Indented file
//
// Revision 1.2  1999/01/29 04:06:46  jimmy
// temp remove races from login menu
//
// Revision 1.1  1999/01/29 01:23:31  mud
// Initial revision
//
@


1.118
log
@added extern prototype for ispell_name_check as well as added
the function to nanny after initial name validation to further
check for potential player names in the dictionary. Created a
con_state to send the connecting players to in order to
simulate a valid password prompt, when all it will do is just
close socket regardless of input.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.117 2002/07/17 17:05:50 rls Exp $
d2352 2
a2353 2
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\n
                 If no one is available, you will be granted entry in a VERY short time.\r\n", d);
@


1.117
log
@fixed min pos of dream, wrote corrected header for commands
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.116 2002/07/17 02:38:16 rls Exp $
d67 1
d116 2
d2153 14
d2219 1
d2227 2
d2352 2
a2353 1
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\nIf no one is available, you will be auto approved in a short time.\r\n", d);
d2360 4
@


1.116
log
@Fixed production users back to do_users
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.115 2002/07/16 19:28:24 rls Exp rls $
d515 1
a515 1
  { "dream"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d613 1
a613 1
  { "inventory", POS_DEAD    , do_inventory, 0, 0 , 0, 0, 0, 0, 1 ,0 },
@


1.115
log
@Adjusted commands to allow function while remaining hidded, this also allows
certain mob script commands to work and keep the mobile hidden as well.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.114 2002/07/14 02:43:37 rls Exp $
d948 1
a948 1
  { "users"    , POS_DEAD    , do_sockets    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.114
log
@*** empty log message ***
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.113 2002/07/13 21:01:56 rls Exp $
d390 1
a390 1
    name , position, acmd, min level, mediate, min/maj para, hide, bound*/
d392 6
a397 6
  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH , 0, 0, 0, 0, 0 ,0 },
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST  , 0, 0, 0, 0, 0 ,0 },
  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH , 0, 0, 0, 0, 0 ,0 },
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST  , 0, 0, 0, 0, 0 ,0 },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP    , 0, 0, 0, 0, 0 ,0 },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN  , 0, 0, 0, 0, 0 ,0 },
d414 1
a414 1
  { "alias"    , POS_DEAD    , do_alias    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d452 1
a452 1
  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG , 0, 0, 0, 0, 0 ,0 },
d471 1
a471 1
#ifdef PRODUCTION
d475 2
a476 2
#endif
  { "color"    , POS_DEAD    , do_color    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d482 1
a482 1
  { "credits"  , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS , 0, 0, 0, 0, 0 ,0 },
d491 1
a491 1
  { "date"     , POS_DEAD    , do_date     , 0, SCMD_DATE , 0, 0, 0, 0, 0 ,0 },
d499 1
a499 1
  { "diagnose" , POS_RESTING , do_diagnose , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d502 1
a502 1
  { "display"  , POS_DEAD    , do_display  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d529 2
a530 2
  { "equipment", POS_SLEEPING, do_equipment, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "exits"    , POS_RESTING , do_exits    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d533 1
a533 1
  { "experience", POS_DEAD   , do_experience ,0, 0, 0, 0, 0, 0, 0 ,0 },
d565 1
a565 1
  { "glance"   , POS_DEAD    , do_diagnose , 0, 0 , 1, 0, 0, 0, 0 ,0 },
d568 1
a568 1
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP , 1, 0, 0, 0, 0 ,0 },
d585 1
a585 1
  { "help"     , POS_DEAD    , do_help     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d613 2
a614 2
  { "inventory", POS_DEAD    , do_inventory, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA , 0, 0, 0, 0, 0 ,0 },
d617 1
a617 1
  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST , 0, 0, 0, 0, 0 ,0 },
d619 3
a621 3
  { "innate"   , POS_DEAD    , do_innate   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "ignore"   , POS_DEAD    , do_ignore   , 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO , 0, 0, 0, 0, 0 ,0 },
d629 1
a629 1
  { "justice"  , POS_DEAD    , do_justice  , 1, 0 , 0, 0, 0, 0, 0 ,0 },  
d642 1
a642 1
  { "level"    , POS_SLEEPING, do_level    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d667 1
a667 1
  { "motd"     , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD , 0, 0, 0, 0, 0 ,0 },
d670 2
a671 2
  { "meditate" , POS_RESTING , do_meditate , 0, 0 , 0, 0, 0, 1, 0 ,0 },
  { "memorize" , POS_RESTING , do_memorize , 0, 0 , 1, 0, 0, 1, 0 ,0 },
d688 1
a688 1
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS, 0, 0, 0, 0, 0 ,0 },
d712 1
a712 1
  { "old"      , POS_DEAD    , do_score    , 0, 0, 0, 0, 0, 0, 0 ,0 },
d723 1
a723 1
  { "petition" , POS_DEAD    , do_petition , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d729 1
a729 1
  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES , 0, 0, 0, 0, 0 ,0 },
d736 1
a736 1
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d756 1
a756 1
  { "qsay"     , POS_RESTING , do_qcomm    , 0, SCMD_QSAY , 0, 0, 0, 0, 0 ,0 },
d758 1
a758 1
  { "rest"     , POS_RESTING , do_rest     , 0, 0 , 1, 0, 0, 1, 0 ,0 },
d801 1
a801 1
  { "save"     , POS_SLEEPING, do_save     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d845 1
a845 1
  { "skills"   , POS_SLEEPING, do_skills   , 1, 0 , 1, 0, 0, 0, 0 ,0 },
d857 1
a857 1
  { "sneak"    , POS_STANDING, do_sneak    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d865 2
a866 2
  { "songs"    , POS_DEAD    , do_song     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "socials"  , POS_DEAD    , do_commands , 0, SCMD_SOCIALS , 0, 0, 0, 0, 0 ,0 },
d868 1
a868 1
  { "speak"    , POS_DEAD    , do_speak    , 0, 0, 0, 0, 0, 0, 0 ,0 },
d870 1
a870 1
  { "spells"   , POS_RESTING , do_spells   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d882 1
a882 1
  { "steal"    , POS_STANDING, do_steal    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d902 1
a902 1
  { "tell"     , POS_SLEEPING, do_tell     , 0, 0 , 0, 0, 1, 0, 1 ,0 },
d924 1
a924 1
  { "time"     , POS_DEAD    , do_time     , 0, 0 , 1, 0, 0, 0, 0 ,0 },
d926 1
a926 1
  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d936 1
a936 1
  { "trophy"   , POS_DEAD    , do_trophy   , 0, 0, 0, 0, 0, 0, 0, 0}, 
d940 1
a940 1
  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO , 0, 0, 0, 0, 0 ,0 },
d944 1
a944 1
  { "unbind"   , POS_DEAD    , do_unbind   , 0, 0 , 0, 0, 0, 0, 1 ,0 },
d953 1
a953 1
  { "uptime"   , POS_DEAD    , do_date     , 0, SCMD_UPTIME , 0, 0, 0, 0, 0 ,0 },
d959 1
a959 1
  { "version"  , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION , 0, 0, 0, 0, 0 ,0 },
d977 1
a977 1
  { "weather"  , POS_RESTING , do_weather  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d979 1
a979 1
  { "who"      , POS_DEAD    , do_who      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d982 1
a982 1
  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI , 0, 0, 0, 0, 0 ,0 },
d1038 1
a1038 1
  { "masound"  , POS_DEAD    , do_masound  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1041 9
a1049 9
  { "msend"    , POS_DEAD    , do_msend    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mecho"    , POS_DEAD    , do_mecho    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mechoaround", POS_DEAD, do_mechoaround , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mskillset", POS_DEAD, do_mskillset , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mload"    , POS_DEAD    , do_mload    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpurge"   , POS_DEAD    , do_mpurge   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mgoto"    , POS_DEAD    , do_mgoto    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mat"      , POS_DEAD    , do_mat      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mteleport", POS_DEAD    , do_mteleport, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1054 1
a1054 1
  { "mforce"   , POS_DEAD    , do_mforce   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.113
log
@Changed do_users to do_sockets
.s
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.112 2002/06/09 21:48:36 rls Exp $
a318 1
ACMD(do_sockets);
d320 1
d945 1
d948 1
a948 1
  { "sockets"    , POS_DEAD    , do_sockets    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d951 1
a951 2
  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE , 0, 0, 0, 0, 0 ,0 },
  { "sockets"    , POS_DEAD    , do_sockets    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
a3694 1
// $Log: interpreter.c,v $
@


1.112
log
@adjusted users and dc to lvl_head_b (where users was)
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.111 2002/06/09 21:27:13 rls Exp rls $
d319 1
a320 1
ACMD(do_users);
d947 1
a947 1
  { "users"    , POS_DEAD    , do_users    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d951 1
a951 1
  { "users"    , POS_DEAD    , do_users    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d3341 1
a3341 1
  "users",
d3696 3
@


1.111
log
@Adjusted users level to grgod (seeing as they have dc)
and adjusted switch-return level to immortal for quest night.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.110 2002/04/26 18:54:01 mpg Exp $
d494 2
a496 2
#else
  { "dc"       , POS_DEAD    , do_dc       , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d947 1
a947 1
  { "users"    , POS_DEAD    , do_users    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d3696 4
@


1.110
log
@modified "group" so group info can be accessed while sleeping
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.109 2002/04/25 23:48:06 mpg Exp $
d892 1
a892 1
  { "switch"   , POS_DEAD    , do_switch   , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d947 1
a947 1
  { "users"    , POS_DEAD    , do_users    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d950 1
d954 1
a954 1
  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE , 0, 0, 0, 0, 0 ,0 },
d3696 3
@


1.109
log
@modified "glance" and "gossip" so they don't interrupt meditation
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.108 2002/04/25 23:22:13 mpg Exp $
d570 1
a570 1
  { "group"    , POS_RESTING , do_group    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d3695 3
@


1.108
log
@modified "skskills so it won't interrupt meditating
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.107 2002/04/24 22:33:09 mpg Exp $
d565 1
a565 1
  { "glance"   , POS_DEAD    , do_diagnose , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d568 1
a568 1
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOSSIP, SCMD_GOSSIP , 0, 0, 0, 0, 0 ,0 },
d3695 3
@


1.107
log
@adjusted dmeditate Changed the time command so players could use it while meditating
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.106 2002/04/17 23:42:43 dce Exp $
d845 1
a845 1
  { "skills"   , POS_SLEEPING, do_skills   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d3695 3
@


1.106
log
@Fixed shapechange when you relogin it removes the mob.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.105 2002/02/19 02:07:20 dce Exp $
d924 1
a924 1
  { "time"     , POS_DEAD    , do_time     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3695 3
@


1.105
log
@Changed do flee from POS_FIGHTING to POS_STANDING.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.104 2002/02/16 02:14:02 dce Exp $
d1894 1
d1913 13
a1925 1
      if (!target) {
d3695 3
@


1.104
log
@Changed flee to a minimum positiong of standing, from resting.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.103 2001/11/14 18:18:02 dce Exp $
d543 1
a543 1
  { "flee"     , POS_STANDING , do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d3682 3
@


1.103
log
@Sedit and Seduce have been switched.
Must be at least standing to search.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.102 2001/11/14 16:24:30 dce Exp $
d543 1
a543 1
  { "flee"     , POS_RESTING , do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d1087 1
d1146 1
a1146 1
  
d3682 4
@


1.102
log
@Level 101+ can now set titles.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.101 2001/10/15 23:41:13 rjd Exp $
a812 1
  { "seduce"   , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d816 1
a816 1
  { "search"   , POS_DEAD    , do_search   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d822 1
d3681 3
@


1.101
log
@Lowered minimum position of the "get" command to POS_RESTING
to allow for chars to get things from bags/backpacks/containers
while resting. For those who nitpick, a person can roll around
while resting to grab stuff from the ground, as well. :P
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.100 2001/07/12 23:14:17 mtp Exp $
d922 1
a922 1
  { "title"    , POS_DEAD    , do_title    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d3681 6
@


1.100
log
@added varset and varunset from dg_debug.c
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.99 2001/05/13 16:15:58 dce Exp mtp $
d558 1
a558 1
  { "get"      , POS_FIGHTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3681 3
@


1.99
log
@Fixed a bug where somethings wouldn't save when a player
died and exitied menu option 0 rather than menu option 1.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.98 2001/04/24 03:30:32 dce Exp $
d321 2
d956 2
d3681 4
@


1.98
log
@Removed the "shit" social/command.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.97 2001/04/07 17:02:30 dce Exp $
d2785 1
d3677 3
@


1.97
log
@Added the vitem command.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.96 2001/04/02 23:31:21 dce Exp $
a823 1
  { "shit"     , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3676 3
@


1.96
log
@Put vwear command into the command list
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.95 2001/03/29 03:11:04 dce Exp $
d325 1
d966 1
d3677 3
@


1.95
log
@Removed the ability to create a shaman from the main menu.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.94 2001/03/06 03:10:18 dce Exp $
d325 1
d965 1
d3675 3
@


1.94
log
@Fixed a bug where players awaiting a name approval could
cut their link and then crash the mud.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.93 2001/02/27 00:53:23 mtp Exp $
d2574 1
a2574 1
    case 'h':
d2581 1
a2581 1
      break;
d3673 4
@


1.93
log
@made it possible to do mjunk in death trigger
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.92 2001/01/20 03:33:21 rsd Exp mtp $
d3627 6
d3673 3
@


1.92
log
@made some god commands on test higher level
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.91 2000/11/28 00:40:00 mtp Exp $
d1032 1
a1032 1
  { "mjunk"    , POS_SITTING , do_mjunk    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3667 3
@


1.91
log
@removed mobprog commands
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.90 2000/11/26 00:27:42 rsd Exp mtp $
a422 1
#ifdef PRODUCTION
a423 3
#else
  { "ban"      , POS_DEAD    , do_ban      , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
a640 1
#ifdef PRODUCTION
d642 1
a642 1
  { "listrace", POS_DEAD    , do_listrace, LVL_HEAD_B, 0, 0, 0, 0, 0, 0, 0 },
a643 6
#else
  { "listclass", POS_DEAD    , do_listclass, LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listrace", POS_DEAD    , do_listrace, LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells, LVL_GOD, 0, 0, 0, 0, 0, 0, 0 },
#endif

d3667 3
@


1.90
log
@moved recline a ways down in the list of commands so it
wouldn't be the first 're' parsed on.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.89 2000/11/23 00:57:04 mtp Exp $
a224 13
ACMD(do_mpasound);
ACMD(do_mpjunk);
ACMD(do_mpecho);
ACMD(do_mpechoat);
ACMD(do_mpechoaround);
ACMD(do_mpkill);
ACMD(do_mpmload);
ACMD(do_mpoload);
ACMD(do_mppurge);
ACMD(do_mpgoto);
ACMD(do_mpat);
ACMD(do_mptransfer);
ACMD(do_mpforce);
a686 13
  { "mpasound" , POS_DEAD    , do_mpasound , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpjunk"   , POS_DEAD    , do_mpjunk   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpecho"   , POS_DEAD    , do_mpecho   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpechoat" , POS_DEAD    , do_mpechoat , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpechoaround" , POS_DEAD, do_mpechoaround, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpkill"   , POS_DEAD    , do_mpkill   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpmload"  , POS_DEAD    , do_mpmload  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpoload"  , POS_DEAD    , do_mpoload  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mppurge"  , POS_DEAD    , do_mppurge  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpgoto"   , POS_DEAD    , do_mpgoto   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpat"     , POS_DEAD    , do_mpat     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mptransfer", POS_DEAD  , do_mptransfer, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mpforce"  , POS_DEAD    , do_mpforce  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3678 4
@


1.89
log
@added mskillset to allow a mob to set skill/spell proficiency
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.88 2000/11/22 01:51:17 mtp Exp mtp $
a792 1
  { "recline"  , POS_RESTING , do_recline     , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
d799 1
d3704 3
@


1.88
log
@allow removeal of quests from global list with dqdel
note: qdel removes from list but not players, their quest structs are
managed on login
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.87 2000/11/22 00:01:41 rsd Exp $
d300 1
d1073 1
d3704 5
@


1.87
log
@Added all 1 zillion back rlog messages from prior to
the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.86 2000/11/15 04:07:13 rsd Exp $
d295 1
d1079 1
d3702 4
@


1.86
log
@made ispell a god command, it was avail to mortals.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.85 2000/11/11 22:44:07 rsd Exp $
d3700 3
d3830 243
@


1.85
log
@Fixed tabbing in the master commands array, retabbed part of
the code while trying to figure out where players get their
names auto-approved.  Fixed said code not to let players
whose names have been DECLINED from sitting at the new
name prompt and getting their new declined names into
the game anyway.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.84 2000/10/31 23:33:20 mtp Exp $
d636 1
a636 1
  { "ispell"   , POS_DEAD    , do_ispell   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3700 8
@


1.84
log
@typo fix
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.83 2000/10/31 23:27:01 mtp Exp mtp $
d1076 3
a1078 3
  { "quest", POS_DEAD    , do_quest, 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qadd", POS_DEAD    , do_qadd, LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "qlist", POS_DEAD    , do_qlist, LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d1080 1
a1080 1
  { "m_run_room_trig"    , POS_DEAD    , do_m_run_room_trig    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
a1167 7
/* Removed so scribe will work --Fingon
  if(PLR_FLAGGED(ch, PLR_SCRIBE))
    if (cmd_info[cmd].meditate == 0){
      REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
      send_to_char("&8You stop scribing.\r\n&0", ch);}
*/

d2770 4
a2773 4
      for (i=0;i<6;i++)
	{
	  GET_ROLL(d->character, i) = 0;
	}
d2780 3
a2782 5

    if (approve_names && (top_of_p_table + 1))
    {

      if (!PLR_FLAGGED(d->character, PLR_NAPPROVE))
d2784 1
d2789 2
a2790 2

      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\nIf no one is available, you will be auto approved in a short time.\r\n", d);
d2794 11
d2806 1
a2806 11
    else
    {
        if (GET_PFILEPOS(d->character) < 0)
             GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
        init_char(d->character);
        save_char(d->character, NOWHERE);
        SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
        STATE(d) = CON_RMOTD;
        break;
    }

d3670 20
a3689 13
   
   SEND_TO_Q("You have been auto-approved.\r\n", event->d);
   SEND_TO_Q(motd, event->d);
   SEND_TO_Q("\r\n\n*** PRESS RETURN: ", event->d);
   if (PLR_FLAGGED(event->d->character, PLR_NEWNAME)) {
     sprintf(buf, "%s [%s] has connected with a new name.", GET_NAME(event->d->character), event->d->host);
     mudlog(buf, NRM, LVL_IMMORT, TRUE);
     REMOVE_BIT(PLR_FLAGS(event->d->character), PLR_NEWNAME);
   } else {
     sprintf(buf, "%s [%s] new player.", GET_NAME(event->d->character), event->d->host);
     mudlog(buf, NRM, LVL_IMMORT, TRUE);
   }
   STATE(event->d) = CON_RMOTD;
d3695 1
d3700 3
@


1.83
log
@added qlist and qadd
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.82 2000/10/27 00:34:45 mtp Exp mtp $
d1078 1
a1078 1
  { "qlist", POS_DEAD    , do_qlist, LVL_GOD0, 0 , 0, 0, 0, 0, 0 ,0 },
d3699 3
@


1.82
log
@new command quest
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.81 2000/10/15 04:41:00 cmc Exp mtp $
d294 2
d1077 2
d3699 3
@


1.81
log
@changes for exp_mesg() and level ** characters
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.80 2000/10/13 17:51:45 cmc Exp cmc $
d293 1
d1074 1
d3695 3
@


1.80
log
@re-implemented modified level command.
modified exp_mesg() for "level gain" code.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.79 2000/10/11 23:50:45 rsd Exp $
d3040 6
a3045 3
  if ((total - current) == 1)
    return ("&0&4&bYou are ready for the next level!&0");
  else if (percent >= 90)
d3693 4
@


1.79
log
@Chris and jimmy seem to think this will delete any old
pfile stuff that may exist for a new char left over from
any old deleted chars,  Added code to check this in
nanny

Also Checked to see if a player was level 0 on login, if
they are they are removed from the player index essentially
deleteing them and push the player requesting the name to
a new character login.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.77 2000/10/07 00:43:55 mtp Exp $
d210 1
a210 1
/*ACMD(do_levels);*/
d650 1
a650 1
/*{ "levels"   , POS_DEAD    , do_levels   , 0, 0 , 0, 0, 0, 0, 0 ,0 },*/
d3034 3
a3036 2
  /* sprintf(buf, "percent is %d\r\nbut total %d, current %d", percent, total, current);
     send_to_char(buf, ch);
d3040 3
a3042 1
  if (percent >= 90)
d3690 11
@


1.78
log
@Chris and jimmy seem to think this will delete any old
pfile stuff that may exist for a new char left over from
any old deleted chars,  Added code to check this in
nanny
@
text
@d2053 1
d2162 13
a2174 1
      if ((player_i = load_char(tmp_name, &tmp_store)) > -1) {
d2262 1
@


1.77
log
@new mob command for triggers m_run_room_trig to run room triggers (mainly for use in death trigs)
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.76 2000/09/13 22:19:22 rsd Exp mtp $
d2236 13
d3673 3
@


1.76
log
@Altered the level at which some commands are avail as well as
removed some if defs
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.75 2000/05/22 22:35:53 rsd Exp $
d369 1
d1074 1
d3660 4
@


1.75
log
@Added char star for test mud greeting to reflect the old
FieryMUD test mud banner. They call me the doctor cuz I'm
always operatin'
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.74 2000/05/21 23:56:43 rsd Exp $
d396 1
a396 1
  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST , 0, 0, 0, 0, 0 ,0 },
d398 3
a400 3
  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST , 0, 0, 0, 0, 0 ,0 },
  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP , 0, 0, 0, 0, 0 ,0 },
  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN , 0, 0, 0, 0, 0 ,0 },
a402 1
  { "abort"    , POS_DEAD    , do_abort    , 0, 0, 0, 0, 0, 0, 0, 1},
d404 1
a404 1
  { "at"       , POS_DEAD    , do_at       , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d408 1
d452 1
a452 1
  { "bounce"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d460 1
a460 1
  { "bye"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d487 1
a487 1
  { "consent"  , POS_RESTING, do_consent, 0, 0, 0, 0, 0, 0, 0, 0},
a842 3
#ifdef PRODUCTION
  { "set"      , POS_DEAD    , do_set      , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
a843 1
#endif
d3658 5
@


1.74
log
@Altered the level of prompt so mortals can get it to work.
So they can then be redirected at do_display.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.73 2000/05/14 05:19:29 rsd Exp $
d2059 1
d2061 3
d2128 1
d2130 3
d2138 1
d2140 3
d3662 4
@


1.73
log
@made rebooting possible by 103's in test, also
removed player delete ability due to it's leakyness.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.72 2000/04/26 22:52:36 rsd Exp $
d763 1
a763 1
  { "prompt"   , POS_DEAD    , do_prompt   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d3650 4
@


1.72
log
@altered player menu to add player deletion.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.71 2000/04/22 22:36:25 rsd Exp $
d863 1
d865 3
d2874 6
a2879 3
      SEND_TO_Q("\r\nEnter your password for verification: ", d);
      echo_off(d);
      STATE(d) = CON_DELCNF1;
d3650 3
@


1.71
log
@fixed spelling of deity in player output, fixed grammar
error associated with exp indicators. move who to the
top of the wh's in the command parser so it's first for
wh.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.70 2000/04/17 00:55:48 rsd Exp $
d2057 1
a2868 2
      /* The delete fucntion needs to be rewritten due to split player files */
      /* Gurlaek 8/11/1999
a2873 1
      */
d2931 2
a2932 2
      save_char(d->character, NOWHERE);
      Crash_delete_file(GET_NAME(d->character));
d3643 6
@


1.70
log
@altered the comment header.  Made prompt LVL_IMMORT
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.69 2000/03/20 04:33:38 rsd Exp $
d1002 1
a1004 1
  { "who"      , POS_DEAD    , do_who      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d2645 1
a2645 1
	SEND_TO_Q("You cannot worship that diety.\r\nDiety:", d);
d3006 1
a3006 1
    return ("&0&4&bYou are just passed the half-way point to your next level.&0");
d3645 3
@


1.69
log
@added ifdefs for test/prod builds to not have to name check
for the test build.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.68 2000/02/24 01:04:18 dce Exp $
d3 1
a3 1
 *   File: interpreter.c                                 Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d763 1
a763 1
  { "prompt"   , POS_DEAD    , do_prompt   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3645 4
@


1.68
log
@Changed wiztitle from a command to a set.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.67 2000/02/22 00:51:30 rsd Exp $
d2055 1
d2057 2
d2464 9
a2472 3
      STATE(d) = CON_NAME_CHECK;    
      SEND_TO_Q(NAMES_EXPLANATION, d);    
      break;
d2482 1
d2486 5
d2493 2
d2501 1
d2505 6
d3643 3
@


1.67
log
@Changed text on name autoapprove to be a short time
instead of a static 5 minutes.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.66 2000/02/16 07:59:10 mtp Exp $
a338 1
ACMD(do_wiztitle);
a1021 5
#ifdef PRODUCTION
  { "wiztitle" , POS_DEAD    , do_wiztitle , LVL_HEAD_C, 0 , 0, 0, 0, 0, 0 ,0 },
#else
  { "wiztitle" , POS_DEAD    , do_wiztitle , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
#endif
d3619 4
@


1.66
log
@added listrace to act.wizard.c it prints the race choice menu that new
players have (for Az)
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.65 2000/02/14 19:48:49 mtp Exp mtp $
d2303 1
a2303 1
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\nIf no one is available, you will be auto approved in 5 minutes.\r\n", d);
d2730 1
a2730 1
      SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\nIf no one is available, you will be auto approved in 5 minutes.\r\n", d);
d3625 4
@


1.65
log
@moved mechoaround to after mecho cos a substring of mechoaround is mecho
and the wrong cmd was getting run *doh*
/s
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.64 2000/02/13 08:53:18 rsd Exp mtp $
d212 1
d653 1
d657 1
d3625 5
@


1.64
log
@Added the PRODUCTION flag ifdef replaceing the TESTMUD
flag.  Also mucked about with the god commands, giving
builders more commands on the test muds, and less on
production.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.63 2000/01/31 04:46:25 rsd Exp $
a1064 1
  { "mechoaround", POS_DEAD, do_mechoaround , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1067 1
d3622 6
@


1.63
log
@Added ifdefs for a production build to make gods on
production have different commands than on test.
Also mopped up several sloppy spacing issues.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.61 2000/01/30 23:33:23 rsd Exp $
d402 1
a402 1
#ifdef TESTMUD
d408 1
a408 1
#ifdef TESTMUD
d428 1
d430 3
d476 1
a476 1
#ifdef TESTMUD
d498 3
d502 1
d509 1
a509 1
#ifdef TESTMUD
d540 1
a540 1
#ifdef TESTMUD
d591 1
a591 1
#ifdef TESTMUD
d599 1
a599 1
#ifdef TESTMUD
d650 1
d653 5
d662 1
a662 1
#ifdef TESTMUD
d664 1
d667 1
a669 1
  { "map"      , POS_DEAD    , do_map      ,LVL_HEAD_C, 0,0,0,0,0,0,0 },
d672 1
a672 1
#ifdef TESTMUD
d703 1
a703 1
#ifdef TESTMUD
d726 1
a726 1
#ifdef TESTMUD
d769 1
a769 1
#ifdef TESTMUD
d795 1
a795 1
#ifdef TESTMUD
d805 1
a805 1
#ifdef TESTMUD
d816 1
a816 1
#ifdef TESTMUD
d839 1
a839 1
#ifdef TESTMUD
d842 1
a842 1
  { "set"      , POS_DEAD    , do_set      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d845 1
a845 1
#ifdef TESTMUD
d864 1
a864 1
#ifdef TESTMUD
d901 1
a901 1
#ifdef TESTMUD
d917 1
d919 3
d954 1
a954 1
#ifdef TESTMUD
d969 1
d971 5
a977 1
  { "users"    , POS_DEAD    , do_users    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d984 1
a984 1
#ifdef TESTMUD
d1002 1
a1002 1
#ifdef TESTMUD
d1020 1
d1022 3
d1027 1
a1027 1
#ifdef TESTMUD
d1037 1
a1037 1
#ifdef TESTMUD
d1055 1
a1055 1
#ifdef TESTMUD
d3622 5
@


1.62
log
@removed lay hands from the game until it can be fixed
@
text
@d401 4
a404 1
  { "abort" , POS_DEAD, do_abort, 0, 0, 0, 0, 0, 0, 0, 1},
d406 5
a410 1
  { "ack"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d412 3
a414 2
  { "aggr" , POS_DEAD, do_aggr, 0, 0, 0, 0, 0, 0, 0 ,0 },
  { "alert"     , POS_RESTING , do_alert     , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
d417 1
a417 1
  { "afk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d420 1
a420 1
  { "apologize"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d422 1
a422 1
  { "appear"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d426 1
a426 2
  { "ayt"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

d428 2
a429 2
  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bandage"      , POS_STANDING    , do_bandage      , 1, 0 , 0, 0, 0, 0, 0 ,0 }, 
d431 2
a432 2
  { "bang"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bark"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d434 1
a434 1
  { "bind"    , POS_STANDING, do_bind      , 1, 0, 0, 0, 0, 0, 0 ,0 },
d436 1
a436 1
  { "beer"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d438 2
a439 2
  { "bird"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bite"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d443 2
a444 2
  { "boggle"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "bonk"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d458 1
a458 1
  { "camp"     , POS_STANDING, do_camp , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d472 3
d476 1
d492 1
a492 1
  { "date"     , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_DATE , 0, 0, 0, 0, 0 ,0 },
d494 1
a494 1
  { "dc"       , POS_DEAD    , do_dc       , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d501 3
d505 3
a507 2
  { "disappear"    , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "disarm", POS_FIGHTING, do_disarm, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d516 2
a517 3

  { "duck"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "duh"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d522 1
a522 1
  { ":"        , POS_RESTING, do_echo      , 1, SCMD_EMOTE , 0, 0, 0, 0, 0 ,0 },
d525 1
a525 1
  { "envy"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d529 6
a534 4
  { "exchange"  , POS_STANDING, do_not_here , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "experience" , POS_DEAD  , do_experience ,0, 0, 0, 0, 0, 0, 0 ,0 },
  { "eyebrow"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

d536 1
d538 1
a538 1
  { "first aid"     , POS_STANDING, do_first_aid     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d540 2
a541 2
  { "flee"     , POS_RESTING, do_flee     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "flex"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d546 1
a546 1
  { "fool"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d556 2
a557 2
  { "gag"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "gape"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d577 1
a577 1
  { "grumble"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d583 3
d587 1
d589 8
a596 3
  { "halo"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hi5"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d598 4
a601 5
  { "hide"     , POS_STANDING , do_hide     , 1, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hiss"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "hit"      , POS_FIGHTING    , do_hit      , 0, SCMD_HIT , 0, 0, 0, 0, 0 ,0 },
  { "hitall"      , POS_FIGHTING    , do_hitall      , 0, 0, 0, 0, 0, 0,0,0},
  
d603 2
a604 2
  { "hop"      , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "home"     , POS_DEAD    , do_not_here     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d606 1
a606 1
  { "hunt"    , POS_STANDING, do_hunt    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d608 1
a608 1
  { "hunger"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d612 1
a612 1
  { "imitate"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d615 1
a615 1
  { "impale"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
a620 1
  { "justice"    , POS_DEAD    , do_justice    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d626 1
a626 1
  
d630 1
a630 1
  { "kneel"     , POS_RESTING , do_kneel     , 0, 0 , 0, 0, 0, 0, 0 ,0 }, 
d633 1
a633 1
  { "lag"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d635 3
a637 3
  /* { "layhand"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 }, */
  { "last"     , POS_DEAD    , do_last     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "lean"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d639 2
a640 2
  /* { "levels"   , POS_DEAD    , do_levels   , 0, 0 , 0, 0, 0, 0, 0 ,0 },*/
  { "light"     , POS_RESTING, do_light , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d642 3
a644 3
  { "listclass", POS_DEAD    , do_listclass  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listspells", POS_STANDING, do_listspells  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
  { "listexp", POS_STANDING, do_listexp  , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0 },
d648 3
d652 1
d654 2
a655 2
  { "map"      , POS_DEAD    , do_map      ,LVL_IMMORT, 0,0,0,0,0,0,0 },
  { "mdisband"  , POS_RESTING , do_mdisband  , 1, 0 , 0, 0, 0, 0, 0 , 0},
d657 3
d661 1
d666 4
a669 4
  { "memorize" , POS_RESTING, do_memorize , 0, 0 , 1, 0, 0, 1, 0 ,0 },
  { "mgroup"   , POS_RESTING , do_mgroup    , 1, 0 , 0, 0, 0, 0, 0 , 0},
  { "moon"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "mosh"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d673 1
a673 1
  { "mutter"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d686 1
a686 1
  { "mptransfer" , POS_DEAD  , do_mptransfer, 0, 0 , 0, 0, 0, 0, 0 ,0 },
d688 3
d692 1
a692 1
  
d694 3
a696 3
  {"anews" , POS_SLEEPING, do_gen_ps , LVL_GOD, SCMD_ANEWS , 0, 0, 0, 0, 0,0 },
  { "nap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS , 0, 0, 0, 0, 0 ,0 },
d699 3
a701 4
  { "nog"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "noogie"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },

  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_NOTITLE , 0, 0, 0, 0, 0 ,0 },
d704 4
a707 4
  { "naccept"    , POS_RESTING , do_name     , LVL_GOD, SCMD_ACCEPT, 0, 0, 0, 0, 0, 0},
  { "ndecline"    , POS_RESTING , do_name     , LVL_GOD, SCMD_DECLINE, 0, 0, 0, 0, 0, 0},
  { "nlist"    , POS_RESTING , do_name     , LVL_GOD, SCMD_LIST, 0, 0, 0, 0, 0, 0},
  /*{ "olc"      , POS_DEAD    , do_olc      , LVL_IMPL, 0 , 0, 0, 0, 0, 0 ,0 },*/
d711 6
a716 2
  { "olc"      , POS_DEAD    , do_olc      , LVL_GOD, SCMD_OLC_SAVEINFO , 0, 0, 0, 0, 0 ,0 },
  { "old"      , POS_DEAD    , do_score    , 0, 0, 0, 0, 0, 0, 0 ,0 },
d719 2
d723 2
a724 2
  { "panic"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "pant"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d727 2
a728 2
  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_PARDON , 0, 0, 0, 0, 0 ,0 },
  { "peace"    , POS_DEAD    , do_peace    , LVL_GOD, 0, 0, 0, 0, 0, 0 ,0 },
d730 1
a730 1
  { "pet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d734 1
a734 1
  { "players"  , POS_DEAD    , do_players  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d741 1
a741 1
  { "pounce"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d745 3
a747 3
  { "protect"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  /* { "practice" , POS_RESTING , do_practice , 1, 0 , 0, 0, 0, 0, 0 ,0},*/
  { "pray"     , POS_RESTING , do_pray   , 0, 0 , 1, 0, 0, 0, 0 ,0 },
d751 2
a752 2
  { "pull"    , POS_RESTING , do_not_here   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "push"    , POS_RESTING , do_not_here   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d754 3
d758 1
d772 1
a772 1
  { "reload"   , POS_DEAD    , do_reboot   , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d777 1
a777 2
  
  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_HEAD_B, SCMD_REROLL , 0, 0, 0, 0, 0 ,0 },
d779 8
a786 3
  /* { "readlist"  , POS_DEAD    , do_readlist     , LVL_GOD, 0 , 0, 0,0,0,0, 0 },*/
  { "restore"  , POS_DEAD    , do_restore  , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rrestore" , POS_DEAD    , do_rrestore , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d789 4
a792 1
  { "retreat"  , POS_FIGHTING, do_retreat, 1, 0 , 0, 0, 0, 0, 0 ,0 },
d794 1
d796 2
a797 2
  { "roar"    , POS_FIGHTING , do_roar   ,  0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "rofl"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d800 4
a803 1
  { "ruffle"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d805 1
a805 1
  { "hhroom"   , POS_STANDING, do_rclone   , LVL_BUILDER, 0, 0, 0, 0, 0, 0 ,0 },
d810 2
a811 3
  { "attributes" , POS_DEAD , do_attributes , 0, 0 , 1, 1, 1, 1, 1 ,0 },
  
  { "score"    , POS_DEAD    , do_new_score    , 0, 0 , 1, 1, 1, 1, 1 ,0 },
d813 2
a814 3

  { "salute"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "scribe"    , POS_RESTING , do_scribe   , 0, 0, 0, 0, 0, 0, 0, 0 },
d817 1
a817 1
  { "scratch"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d820 2
a821 2
  { "sdedit"    , POS_DEAD , do_olc   , LVL_HEAD_B, SCMD_OLC_SDEDIT , 0, 0, 0, 0, 0 ,0 },
  { "seduce"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d823 4
a826 1
  { "send"     , POS_SLEEPING, do_send     , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d828 1
d830 3
d834 1
d838 1
a838 1
  { "shit"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d842 1
a842 1
  { "shudder"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d849 3
d853 2
a854 1
  { "skills"   , POS_SLEEPING,  do_skills   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d857 1
a857 1
  { "slobber"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d868 1
a868 1
  { "snoogie"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d871 2
a872 2
  { "snowball" , POS_STANDING, do_action   , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "snoop"    , POS_DEAD    , do_snoop    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d874 1
a874 1
  { "songs"    , POS_DEAD    , do_song    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d876 1
a876 1
  { "spam"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d881 1
a881 1
  { "spit"     , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d886 5
a890 1
  { "stat"     , POS_DEAD    , do_stat     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d893 1
a893 1
  { "stomp"    , POS_STANDING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d907 2
a908 2
  { "tell"     , POS_SLEEPING    , do_tell     , 0, 0 , 0, 0, 1, 0, 1 ,0 },
  { "terminate"    , POS_DEAD    , do_terminate    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d910 1
a910 1
  { "take"     , POS_FIGHTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d913 2
a914 2
  { "tap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "tarzan"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d918 1
a918 2
  
  { "tedit"    , POS_DEAD    , do_tedit    , LVL_GRGOD, 0 , 0, 0, 0, 0, 0 ,0 },
d923 1
a923 1
  { "thirst"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d926 2
a927 2
  { "tip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "title"    , POS_DEAD    , do_title    , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d930 1
a930 1
  { "tip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d932 1
a932 1
  { "tongue"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d935 3
d939 5
a943 4
  { "trip"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "trophy", POS_DEAD     , do_trophy    , 0, 0, 0, 0, 0, 0, 0, 0}, 
  { "tug"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "twibble"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d948 4
a951 4
  { "unban"    , POS_DEAD    , do_unban    , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
  { "unbind" , POS_DEAD, do_unbind, 0, 0, 0, 0, 0, 0, 1,0 },
  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_UNAFFECT ,1, 1, 1, 1, 1 ,1 },
  { "uptime"   , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_UPTIME , 0, 0, 0, 0, 0 ,0 },
d953 1
a953 1
  { "users"    , POS_DEAD    , do_users    , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d957 1
a957 1
  { "veto"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d959 8
a966 3
  { "viewdam"  , POS_DEAD , do_viewdam  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vnum"     , POS_DEAD    , do_vnum     , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
  { "vstat"    , POS_DEAD    , do_vstat    , LVL_IMMORT, 0 , 0, 0, 0, 0, 0 ,0 },
d971 1
a971 1
  { "wait"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d973 3
a975 3
  { "wet"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whap"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "whatever"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d978 3
d982 1
d987 1
a987 1
  { "wiggle"   , POS_RESTING, do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d996 1
a996 1
  { "wiztitle" , POS_DEAD    , do_wiztitle , LVL_GOD, 0 , 0, 0, 0, 0, 0 ,0 },
d999 3
d1003 1
d1008 5
a1013 1
  { "zone"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1015 1
d1017 1
a1017 1
  { "game"    , POS_DEAD    , do_game    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },  
d1025 1
a1025 1
  { "z001#@@#"    , POS_SLEEPING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1027 4
d1033 1
d1037 1
a1037 1
  { "mechoaround" , POS_DEAD , do_mechoaround    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1041 1
a1041 1
  { "mpurge"   , POS_DEAD    , do_mpurge    , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1046 1
a1046 1
  { "DumbMobTrack"    , POS_STANDING, do_DumbMobTrack , 0, 0 , 0, 0, 0, 0, 0 ,0},
@


1.61
log
@Added necessary compentents to the menues for good race login.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.60 1999/12/10 22:13:45 jimmy Exp rsd $
d611 1
a611 1
  { "layhand"    , POS_STANDING , do_layhand   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3499 3
@


1.60
log
@Exp tweaks.  Made Exp loss for dying a hardcoded 25% of what was needed for the next
level.  Fixed problems with grouping and exp.  Removed some redundant and unnecessary
exp code.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.59 1999/12/06 20:28:08 cso Exp $
d62 1
d102 1
d1930 1
d2329 6
a2334 1
    if(races_allowed) {
d2345 11
d3499 5
@


1.59
log
@Made "skills" and "tell" doable while sleeping.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.58 1999/11/29 00:23:31 cso Exp $
d2796 3
a2799 21

long exp_death_loss(struct char_data * ch, int level)
{
  long percent, total;
  long current;
  if (abs(GET_LEVEL(ch) - level) > 2)
    level = GET_LEVEL(ch); 
  if (level >= 65)
    percent = 3;
  else if (level >= 55)
    percent = 5;
  else if (level >= 50)
    percent = 10;
  else if (level >= 40)
    percent = 20;
  else if (level >= 30)
    percent = 25;
  else if (level >= 20)
    percent = 30;
  else
    percent = 35;
d2802 1
a2802 24
  current = (long)((percent * total)/100);
  /*This is a test display to character*/
  /*
    sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
    send_to_char(buf, ch);
  */
  return current;
  
  
}

long max_exp_loss(struct char_data *ch)
{
  float percent;
  long current, total;
  percent = 20;
  total=exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
  
  current = (long)(0.2 * (float)total);
  /*sprintf(buf, "max exp loss is %d\r\nbut total %d, percent %d", current, total, percent);
    send_to_char(buf, ch);
  */
  return current;
  
d2805 1
a2805 3
long max_exp_gain(struct char_data *ch)
{
  float percent;
a2806 1
  percent = 20;
d2810 1
a2810 1
  /*sprintf(buf, "max exp gain is %ld, but total %ld, percent %f\r\n", current, total, percent);
a2813 1
  
d3480 3
@


1.58
log
@removed unused variables to kill compile warnings
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.57 1999/11/28 23:28:50 cso Exp cso $
d787 1
a787 1
  { "skills"   , POS_RESTING,  do_skills   , 1, 0 , 0, 0, 0, 0, 0 ,0 },
d836 1
a836 1
  { "tell"     , POS_RESTING    , do_tell     , 0, 0 , 0, 0, 1, 0, 1 ,0 },
d3525 3
@


1.57
log
@removed unused arg from roll_natural_abils
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.56 1999/11/23 15:48:23 jimmy Exp cso $
a1935 1
  int choice_table[6] = {0};
d3525 3
@


1.56
log
@Fixed the slashing weapon skill.  I had it erroneously as stabbing. Doh.
Reinstated dual wield.
Allowed mobs/players to pick up items while fighting.
Fixed a bug in the damage message that wrongfully indicated a miss
due to a rounding error in the math.
This was all done in order to facilitate the chance to sling your
weapon in combat.  Dex and proficiency checks are now made on any missed
attact and a failure of both causes the weapon to be slung.
@
text
@d1 1
a1 1
// $Id: interpreter.c,v 1.55 1999/09/05 07:00:39 jimmy Exp $
d95 1
a95 1
void roll_natural_abils(struct char_data *ch, int []);
d2500 1
a2500 1
      roll_natural_abils(d->character, choice_table);	
d3526 10
@


1.55
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d536 1
a536 1
  { "get"      , POS_STANDING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d839 1
a839 1
  { "take"     , POS_RESTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d3525 4
a3528 1
// $Log$
@


1.54
log
@changed posn of get to STANDING
@
text
@d1 1
d3525 1
@


1.53
log
@changed examine to a resting (resting) type command
@
text
@d535 1
a535 1
  { "get"      , POS_RESTING , do_get      , 0, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.52
log
@removed auction since it was being used for a congratulate channel.
@
text
@d511 1
a511 1
  { "examine"  , POS_SITTING , do_examine  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.51
log
@commented out the grats command, it was buggy and I don't want a global
method to communicate game stuff like that anyway.
@
text
@d414 1
a414 1
  { "auction"  , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_AUCTION , 0, 0, 0, 0, 0 ,0 },
@


1.50
log
@Fixed experience so that there are no overflows of integers that are placed into longs.
Main problem was max_exp_gain and max_exp_loss. Both were overflowing due to poor
Hubis coding.
@
text
@d549 1
a549 1
  { "grats"    , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GRATZ , 0, 0, 0, 0, 0 ,0 },
@


1.49
log
@This is a Mass ci of the new pfile system.  The pfile has been split into
one file for each player in a directory A-Z.  The object files are also
located in the A-Z directories.  Fixed a stupid bug in pfilemaint that
screwed up the IDNUM of the person who typed it.  Commented out the frag
system completely.  It is slated for removal.  Fixed the rename command.
Fixed all supporting functions for the new system, I hope!
--Gurlaek 8/11/1999
@
text
@d2798 1
a2798 1
int exp_death_loss(struct char_data * ch, int level)
d2800 2
a2801 2
  int percent, total;
  int current;
d2818 1
a2818 1
  total = (int) exp_to_level(level, GET_CLASS(ch)) - exp_to_level((level - 1), GET_CLASS(ch));
d2820 1
a2820 1
  current = (int)((percent * total)/100);
d2831 1
a2831 1
int max_exp_loss(struct char_data *ch)
d2833 2
a2834 2
  int percent, total;
  int current;
d2838 1
a2838 1
  current = (int)((percent * total)/100);
d2846 1
a2846 1
int max_exp_gain(struct char_data *ch)
d2848 2
a2849 2
  int percent, total;
  int current;
d2853 2
a2854 2
  current = (int)((percent * total)/100);
  /*sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
@


1.48
log
@Exchange command for banks added.
@
text
@d168 1
a168 1
ACMD(do_frag);
d529 1
a529 1
  { "frag"   , POS_DEAD    , do_frag  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d1920 1
d1933 1
d2137 7
a2143 4
         sprintf(buf, "mv %s", get_fname(d->character->player.name, 0));
         sprintf(buf, "%s %s", buf, get_fname(arg, 0));
         system(buf);
         log("Moving plrobj file for a renamed char!");
d2145 2
a2146 1

a2149 1
               log(((player_table)+i)->name);
d2154 1
a2154 1

d2575 1
a2575 1
    if (approve_names)
d2703 2
a2704 5

      /*****************************************************
	This case was removed because characters aren't being
	deleted properly.  Someone fix deletion and re-enable
	this.  RSD
d2710 1
a2710 2
      ******************************************************/

d2748 1
a2748 1
    if (!strcmp(arg, "yes") || !strcmp(arg, "YES")) {
d2756 1
a2756 1
        if(GET_CLAN(d->character)){
a2766 1
	SET_BIT(PLR_FLAGS(d->character), PLR_DELETED);
@


1.47
log
@moved send_toxnames back to where it belongs.
my fault. --gurlaek
@
text
@d512 1
@


1.46
log
@Added pfilemaint command
--gurlaek
@
text
@d2132 2
@


1.45
log
@commented out case5 in the MENU for game login
players deleting themselves is producing some
problems as they aren't completely deleted.
@
text
@d245 1
d688 1
d3474 3
a3476 2
  "wiztitle",
  "\n"				/* 500 */
@


1.44
log
@Changed the menue message "That's not a menu choice!" to
'Wrong Option!" to continue to Fiery-ify the code...
@
text
@d2694 4
d2703 1
@


1.43
log
@added the world command back to reflect the combination of
uptime and date.
@
text
@d2701 1
a2701 1
      SEND_TO_Q("\r\nThat's not a menu choice!\r\n", d);
@


1.42
log
@made the do_world command the do_game command to free up
world for a similar use to the old fiery.
@
text
@d342 1
d922 1
@


1.41
log
@act.item.c         class.c       db.c         medit.c        utils.hact.offensive.c    config.c      handler.c    spells.cThis is a major conversion from the 18 point attribute system to the
100 point attribute system.  A few of the major changes are:
All attributes are now on a scale from 0-100
Everyone views attribs the same but, the attribs for one race
  may be differeent for that of another even if they are the
  same number.
Mobs attribs now get rolled and scaled using the same algorithim as PC's
Mobs now have individual random attributes based on race/class.
The STR_ADD attrib has been completely removed.
All bonus tables for attribs in constants.c have been replaced by
  algorithims that closely duplicate the tables except on a 100 scale.
Some minor changes:
Race selection at char creation can now be toggled by using
  <world races off>
Lots of cleanup done to affected areas of code.
Setting attributes for mobs in the .mob file no longer functions
  but is still in the code for later use.
We now have a spare attribut structure in the pfile because the new
  system only used three instead of four.
--gurlaek 6/30/1999
@
text
@d341 1
a341 1
ACMD(do_world);
d920 1
a920 1
  { "world"    , POS_DEAD    , do_world    , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },  
@


1.40
log
@Cut a piece of name code from case GET_NAME that was
preventing a password check for player names that were
declined in file.
Removed a line of code sending those names to xnames because
it duped code added to ban.c earlier in this process.
@
text
@d60 1
a60 1

d92 1
a92 2
void change_affected_stats(struct char_data * ch);
void load_results(struct char_data * ch);
d94 1
a94 1
void roll_view_abils(struct char_data *ch, int []);
d1920 1
a1920 1
  /*  extern char *race_menu; */
a2016 9
	/*Loads real stats*/
	load_results(d->character);
	change_affected_stats(d->character);

	


	

d2314 18
a2331 16
    
    /*    SEND_TO_Q(race_menu, d);
     *    SEND_TO_Q("\r\nRace: ", d); 
     *   STATE(d) = CON_QRACE;
     *   break;
     *	case CON_QRACE:
     *		load_result = parse_race(*arg);
     *		if (load_result == RACE_UNDEFINED) {
     *			SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
     *			return;
     *		} else
     *			GET_RACE(d->character) = load_result;
     *		    
     */

    GET_RACE(d->character) = RACE_HUMAN;
d2480 1
a2480 1
      if ((GET_STR_VIEW(d->character)) > 0)
d2487 1
a2487 3
      roll_view_abils(d->character, choice_table);	
      load_results(d->character);
      change_affected_stats(d->character);
d2535 1
a2535 2
    load_results(d->character);
    change_affected_stats(d->character);
d2540 4
a2543 1
    
d2551 1
a2551 1
      GET_STR_VIEW(d->character) = 0;
d2895 6
a2900 6
  statts[0] = GET_STR_VIEW(ch);
  statts[1] = GET_INT_VIEW(ch);
  statts[2] = GET_WIS_VIEW(ch);
  statts[3] = GET_DEX_VIEW(ch);
  statts[4] = GET_CON_VIEW(ch);
  statts[5] = GET_CHA_VIEW(ch);
d2917 1
d2927 1
a2927 1
      GET_WIS_VIEW(ch) = MIN(100, (GET_WIS_VIEW(ch) +b));
d2932 1
a2932 1
      GET_INT_VIEW(ch) = MIN(100, (GET_INT_VIEW(ch) +b));
d2937 1
a2937 1
      GET_CHA_VIEW(ch) = MIN(100, (GET_CHA_VIEW(ch) +b));
d2942 1
a2942 1
      GET_CON_VIEW(ch) = MIN(100, (GET_CON_VIEW(ch) +b));
d2945 3
a2947 2
    case 'd':		b = number(2, 6);
      GET_DEX_VIEW(ch) = MIN(100, (GET_DEX_VIEW(ch) +b));
d2952 1
a2952 6
      GET_STR_VIEW(ch) = GET_STR_VIEW(ch) + b;
      if (GET_STR_VIEW(ch) > 100) {
	GET_ADD_VIEW(ch) = MIN(100, ((GET_ADD_VIEW(ch) +
				      (GET_STR_VIEW(ch) % 100))));
	GET_STR_VIEW(ch) = 100;
      }
a2958 1
  ch->vaff_abils = ch->view_abils;
@


1.39
log
@This is a mass check in after a code freeze due to an upgrade to RedHat 6.0.  This fixes all of the warnings associated
with the new compiler and libraries.  Many many curly braces had to be added to "if" statements to clarify
their behavior to the compiler.  The name approval code was also debugged, and tested to be stable.  The xnames
list was converted from an array to a linked list to allow for on the fly adding of names to the xnames list.
This code compiles fine under both gcc RH5.2 and egcs RH6.0.
--Gurlaek 6/10/1999
@
text
@d2021 5
a2025 6
	/* added by gurlaek 6/9/1999 */
	if (PLR_FLAGGED(d->character, PLR_NEWNAME)) {
	  SEND_TO_Q("You must choose a new name for this character.\r\n", d);
	  STATE(d) = CON_NEW_NAME;
	  return;
	}
a2234 1
        send_to_xnames(d->character->player.name);
@


1.38
log
@made listspell a level 103+ command
@
text
@d61 1
a61 1
extern save_char_file_u(struct char_file_u st);
d110 1
d2021 7
a2027 1
	
d2165 1
a2165 1
      broadcast_name(d->character->player.name);
d2167 6
a2172 4
      if (PLR_FLAGGED(d->character, PLR_NEWNAME)) {
         if (!PLR_FLAGGED(d->character, PLR_NAPPROVE))
            SET_BIT(PLR_FLAGS(d->character), PLR_NAPPROVE);
      }
d2174 1
a2178 5
    CREATE(name_event, struct name_timeout_event, 1);
    name_event->d = d;
    event_create(name_timeout, name_event, 5 * (60 RL_SEC));
    if (PLR_FLAGGED(d->character, PLR_NEWNAME))
       REMOVE_BIT(PLR_FLAGS(d->character), PLR_NEWNAME);
d2575 12
a2586 4
        SEND_TO_Q("Now you must wait for your name to be approved by an immortal.\r\nIf no one is available, you will be auto approved in 5 minutes.\r\n", d);
        STATE(d) = CON_NAME_WAIT_APPROVAL;
        broadcast_name(d->character->player.name);
        break;
d3489 3
a3491 2
      free(event_obj);
      return 0;
d3493 1
a3493 1

d3496 3
a3499 2
   if (!PLR_FLAGGED(event->d->character, PLR_NEWNAME))   
      init_char(event->d->character);
d3501 1
a3501 1

d3503 2
a3504 1
      SET_BIT(PLR_FLAGS(event->d->character), PLR_NAPPROVE);
d3518 1
a3518 1
      REMOVE_BIT(PLR_FLAGS(event->d->character), PLR_NEWNAME);
d3520 2
a3521 1
   return 1;
@


1.37
log
@Name accept system...version one...original code by Fingh, fixed up to work
by Zantir.
@
text
@d613 1
a613 1
  { "listspells", POS_STANDING, do_listspells  , LVL_IMMORT, 0, 0, 0, 0, 0, 0, 0 },
@


1.36
log
@Allow players to drop all eq and quit.
@
text
@d30 1
d52 1
d61 2
d67 1
d88 1
d109 1
d235 1
d664 3
a666 1

d1916 1
d1937 1
a1937 1
  
d2103 73
d2229 8
a2477 2
    SEND_TO_Q(question1, d);
    STATE(d) = CON_QQUESTION1;        
d2479 1
a2479 81
    
  case CON_QQUESTION1:
    if (!ask_question(d, 1, arg))
      {
	send_to_char("Please re-try your first choice:", d->character);
	display_question(d);
	return;
      }
    send_to_char("Please enter choose your second stat:", d->character);
    display_question(d);
    STATE(d) = CON_QQUESTION2;
    break;
    
  case CON_QQUESTION2:
    
    if (!ask_question(d, 2, arg))
      {
	send_to_char("Please re-try your second choice:", d->character);
	display_question(d);
	return;
      }
    send_to_char("Please enter choose your third stat:", d->character);
    display_question(d);
    STATE(d) = CON_QQUESTION3;
    break;
    
    
  case CON_QQUESTION3:
    if (!ask_question(d, 3, arg))
      {
	send_to_char("Please re-try your third choice:", d->character);
	display_question(d);
	return;
      }
    send_to_char("Please enter choose your fourth stat:", d->character);
    display_question(d);
    STATE(d) = CON_QQUESTION4;
    break;
    
  case CON_QQUESTION4:
    
    if (!ask_question(d, 4, arg))
      {
	send_to_char("Please re-try your fourth choice:", d->character);
	display_question(d);
	return;
      }
    send_to_char("Please enter choose your fifth stat:", d->character);
    display_question(d);
    STATE(d) = CON_QQUESTION5;
    break;
    
  case CON_QQUESTION5:
    
    if (!ask_question(d, 5, arg))
      {
	send_to_char("Please re-try your fifth choice:", d->character);
	display_question(d);
	return;
      }
    send_to_char("Please enter choose your sixth stat:", d->character);
    display_question(d);
    STATE(d) = CON_QQUESTION6;
    break;
    
    
  case CON_QQUESTION6:
    
    if (!ask_question(d, 6, arg))
      {
	send_to_char("Please re-try your sixth choice:", d->character);
	display_question(d);
	return;
      }
    display_question(d);
    send_to_char("Your choices are complete.\r\n", d->character);
    SEND_TO_Q("Please press return to roll your stats", d);
    STATE(d) = CON_QROLLSTATS;
    break;
    
    
d2567 19
a2585 16
    
    if (GET_PFILEPOS(d->character) < 0)
      GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));
    init_char(d->character);
    save_char(d->character, NOWHERE);
    
    SEND_TO_Q(motd, d);
    SEND_TO_Q("\r\n\n*** PRESS RETURN: ", d);
    STATE(d) = CON_RMOTD;
    
    sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, LVL_IMMORT, TRUE);
    break;
    
    
    
d3471 8
d3480 26
@


1.35
log
@Fixed warnings/errors associated with the addition of the pendantic compiler flag
yeeeeehaaawwww.  --gurlaek
@
text
@d701 2
a702 2
  { "qui"      , POS_DEAD    , do_camp     , 0, 0 , 0, 0, 0, 0, 0 ,0 },
  { "quit"     , POS_DEAD    , do_camp     , 0, SCMD_QUIT , 0, 0, 0, 0, 0 ,0 },
@


1.34
log
@added bold to each of the exp notch indicators.
@
text
@d2549 1
a2549 1
	  (int)GET_ROLL(d->character, i) = NULL;
d2766 1
a2766 1
};
@


1.33
log
@*** empty log message ***
@
text
@d2854 1
a2854 1
    return ("&0&4You are three-quarters of the way to your next level.&0");
d2856 1
a2856 1
    return ("&0&4You are well on your way to your next level.&0");
d2858 1
a2858 1
    return ("&0&4You are just passed the half-way point to your next level.&0");
d2860 1
a2860 1
    return ("&0&4You are at the half-way point to your next level.&0");
d2862 1
a2862 1
    return ("&0&4You are nearing the half-way point to your next level.&0");
d2864 1
a2864 1
    return ("&0&4You are one-quarter of the way to your next level.&0");
d2866 1
a2866 1
    return ("&0&4You have gained some progress towards your next level.&0");
d2868 1
a2868 1
    return ("&0&4You still have a very long way to go to your next level.&0");
d2870 1
a2870 1
    return ("&0&4You have just begun the journey to your next level.&0");
@


1.32
log
@Must be level 3 to post/write
/
@
text
@d897 1
a897 1
  { "wizlock"  , POS_DEAD    , do_wizlock  , LVL_OVERLORD, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.31
log
@Removed some things temporarly until they can be fixed.
@
text
@d900 1
a900 1
  { "write"    , POS_STANDING, do_write    , 1, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.30
log
@Added listexp command
@
text
@d456 1
a456 1
  { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS , 0, 0, 0, 0, 0 ,0 },
@


1.29
log
@Junk command is back!
@
text
@d203 1
d606 1
@


1.28
log
@Added a msg to the room when a player stops meditating
@
text
@d586 2
a587 2
  /*{ "junk"     , POS_RESTING , do_drop     , 0, SCMD_JUNK , 0, 0, 0, 0,0 ,0 },
   */
@


1.27
log
@Two changes:
1) Made prayer a command that doesn't interrupt meditation
2) Made 'listclass' a GRGOD command since GRGODs can set classes;
they need the reference list!

Selandria / JEN II
@
text
@d1015 1
@


1.26
log
@Added new command old -> shows the old do_score
@
text
@d603 1
a603 1
  { "listclass", POS_DEAD    , do_listclass  , LVL_HEAD_C, 0, 0, 0, 0, 0, 0, 0 },
d688 1
a688 1
  { "pray"     , POS_RESTING , do_pray   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
@


1.25
log
@Added a mortal gossip channel with 103+ godly control
@
text
@d267 1
a267 1
/*ACMD(do_score);*/
d660 1
@


1.24
log
@Added extended cases for name acceptance ye and yes
@
text
@d533 1
a533 1
  { "gossip"   , POS_SLEEPING, do_gen_comm , LVL_GOD, SCMD_GOSSIP , 0, 0, 0, 0, 0 ,0 },
@


1.23
log
@removed attribute priority questions, removed hunter, illusionist, mystic from char generation
@
text
@d2246 6
a2251 3
  case CON_NAME_CHECK:

    if (str_cmp(arg, "y")) {
d2253 1
a2253 1
      return;
d2255 1
a2255 5

    STATE(d) = CON_QCLASS;
    display_classes(d,1); 
    break;

@


1.22
log
@In class.c added a new line before the fiery mud class explanation
in config.c added the variable for name explanations and added the
text for the variable
in interpreter.c added the con_state stuff, whatever that was and
added the CON_NAME_CHECK affirmation section to the creation menu
loop or nanny.
In structs.h added the CON_NAME_CHECK define..
I also drove Jimmy absolutely insane with the deail in information
I put into our change control system.
lala
@
text
@d2364 6
a2369 3
    send_to_char("Please put these in the order they most appeal to you:", d->character);
    display_question(d); 
    STATE(d) = CON_QQUESTION1;        
@


1.21
log
@Chant added to, and songs craeted
@
text
@d1910 1
d2239 1
d2241 13
a2253 1
    
a2254 2
    
    STATE(d) = CON_QCLASS;
d2256 1
a2256 6
    
    
    
    
    
    
@


1.20
log
@removed silly debug message
fingon
@
text
@d284 1
d789 1
@


1.19
log
@Rewrote spellbooks.  Moved the spells from fingh's PSE to a standard linked
list.  Added Spellbook pages.  Rewrote Scribe to be a time based event based
on the spell mem code.  Very basic at this point.  All spells are 5 pages long,
and take 20 seconds to scribe each page.  This will be more dynamic when the
SCRIBE skill is introduced.  --Fingon.
@
text
@a1086 1
	log("it's the one");
@


1.18
log
@Monk additions/fixes
@
text
@d1013 2
d1019 2
@


1.17
log
@Creates a new command called file. Allows us to view files
through the mud.
@
text
@d124 1
a155 1
ACMD(do_file);
d438 1
a506 1
  { "file"     , POS_DEAD  , do_file      , LVL_GRGOD, 0, 0, 0, 0, 0, 0, 0},
@


1.16
log
@commented out unused variable in line 1554 associated with
  /* Subclassing explaination/preface */ which was commented
earlier to hide subclasses from players at login.
@
text
@d155 1
d506 1
@


1.15
log
@Ok, I finished moving the subclass issue from the class selection view
the todo list will have more on the work remaining on this.
@
text
@d1 1
a1 1
/* ************************************************************************
d9 1
a9 1
 ************************************************************************ */
d1554 1
a1554 1
  int x;
@


1.14
log
@I removed the View of the subclasses from the class Selection screen
In doing so I've created a warning, I have no idea how to fix it,
someone take a peek at it?
@
text
@d1571 1
a1571 1
  send_to_char("&1&b(&0&5*&1&b) denotes a class available to your race!&0&5\r\n\r\n", d->character);
@


1.13
log
@Added do_wiztitle that allows gods to edit their
godly title ie Overlord.  Also added this title
to the playerfile
fingon
@
text
@d1569 1
a1569 1
    send_to_char("\r\n&5Class selection menu - ",d->character);
d1580 1
a1580 1
  sprintf(buf,"&5&b");
d1642 1
d1644 5
a1648 5
    sprintf(buf, "%s\r\n&1Choose %s %s %s %s %s or [&b?&0&1] for help: &0", buf,
	    warriorok ? "[&bw&0&1]arrior," : "",
	    clericok ? "[&bc&0&1]leric," : "",
	    mageok ? "[&bs&0&1]orcerer," : "",
	    rogueok ? "[&br&0&1]ogue," : "",
@


1.12
log
@removed debug message
@
text
@d323 1
d891 1
d3432 1
@


1.11
log
@Fixed buffer overflow in do_alias
fingon
@
text
@a1077 1
      log("found an alias...");
@


1.10
log
@David Endre 2/5/99
Added do_light
@
text
@d1221 8
a1228 1

@


1.9
log
@Major change to incorporate aliases into the pfile
moved alias structure from interpreter.h to structs.h
heavily modified alias code in interpreter.c
Jimmy Kincaid AKA fingon
@
text
@d198 1
d597 1
@


1.8
log
@Combined attributes, score, and exp commands.
@
text
@d1064 2
d1068 2
a1069 1
struct alias *find_alias(struct alias *alias_list, char *str)
d1071 11
a1081 6
  while (alias_list != NULL) {
    if (*str == *alias_list->alias)	/* hey, every little bit counts :-) */
      if (!strcmp(str, alias_list->alias))
	return alias_list;
    
    alias_list = alias_list->next;
d1083 1
a1083 2
  
  return NULL;
a1085 2


d1141 1
a1141 1

d1150 1
a1150 1

d1153 1
d1157 1
a1157 1
  struct alias *a, *temp;
d1164 2
a1165 1
  if (!*arg) {			/* no argument specified -- list currently defined aliases */
d1167 5
a1171 5
    if ((a = GET_ALIASES(ch)) == NULL)
      send_to_char(" None.\r\n", ch);
    else {
      while (a != NULL) {
	sprintf(buf, "%-15s %s\r\n", a->alias, a->replacement);
a1172 1
	a = a->next;
d1175 7
a1181 1
  } else {			/* otherwise, add or remove aliases */
d1183 3
a1185 4
    if ((a = find_alias(GET_ALIASES(ch), arg)) != NULL) {
      REMOVE_FROM_LIST(a, GET_ALIASES(ch), next);
      free_alias(a);
    }
d1187 1
d1189 1
a1189 1
      if (a == NULL)
d1191 1
a1191 1
      else
d1193 9
a1201 1
    } else {			/* otherwise, either add or redefine an alias */
d1206 15
a1220 2
      CREATE(a, struct alias, 1);
      a->alias = str_dup(arg);
d1222 1
a1222 1
      a->replacement = str_dup(repl);
d1224 1
a1224 1
	a->type = ALIAS_COMPLEX;
d1226 1
a1226 3
	a->type = ALIAS_SIMPLE;
      a->next = GET_ALIASES(ch);
      GET_ALIASES(ch) = a;
d1240 1
a1240 1
void perform_complex_alias(struct txt_q *input_q, char *orig, struct alias *a)
d1258 1
a1258 1
  for (temp = a->replacement; *temp; temp++) {
d1303 2
a1304 6
  struct alias *a, *tmp;
  
  /* bail out immediately if the guy doesn't have any aliases */
  if ((tmp = GET_ALIASES(d->character)) == NULL)
    return 0;
  
d1313 1
a1313 1
  if ((a = find_alias(tmp, first_arg)) == NULL)
d1316 2
a1317 2
  if (a->type == ALIAS_SIMPLE) {
    strcpy(orig, a->replacement);
d1320 1
a1320 1
    perform_complex_alias(&d->input, ptr, a);
@


1.7
log
@max/min exp loss/gain set to 2 notches.
@
text
@d225 1
d265 1
a265 1
ACMD(do_score);
d731 1
a731 1
  { "score"    , POS_DEAD    , do_score    , 0, 0 , 1, 1, 1, 1, 1 ,0 },
d2792 1
a2792 1
    return ("\r\n&0&4&bYou should level anytime now!&0\r\n");
d2794 1
a2794 1
    return ("\r\n&0&6You are almost ready to attain your next level.&0\r\n");
d2796 1
a2796 1
    return ("\r\n&0&4You are three-quarters of the way to your next level.&0\r\n");
d2798 1
a2798 1
    return ("\r\n&0&4You are well on your way to your next level.&0\r\n");
d2800 1
a2800 1
    return ("\r\n&0&4You are just passed the half-way point to your next level.&0\r\n");
d2802 1
a2802 1
    return ("\r\n&0&4You are at the half-way point to your next level.&0\r\n");
d2804 1
a2804 1
    return ("\r\n&0&4You are nearing the half-way point to your next level.&0\r\n");
d2806 1
a2806 1
    return ("\r\n&0&4You are one-quarter of the way to your next level.&0\r\n");
d2808 1
a2808 1
    return ("\r\n&0&4You have gained some progress towards your next level.&0\r\n");
d2810 1
a2810 1
    return ("\r\n&0&4You still have a very long way to go to your next level.&0\r\n");
d2812 1
a2812 1
    return ("\r\n&0&4You have just begun the journey to your next level.&0\r\n");
@


1.6
log
@made listspells an LVEL_IMMORT command
@
text
@d2744 15
d2763 2
a2764 9
  if (GET_LEVEL(ch) >= 40)
    percent = 15;
  else if (GET_LEVEL(ch) >= 30)
    percent = 15;
  else if (GET_LEVEL(ch) >= 20)
    percent = 15;
  else
    percent = 30;
  total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
d2773 2
@


1.5
log
@improved build counter
@
text
@d597 1
a597 1
  { "listspells", POS_STANDING, do_listspells  , 0, 0, 0, 0, 0, 0, 0, 0 },
@


1.4
log
@Added buildcounter to GREETING --Fingon
@
text
@d102 1
a1850 1
  FILE *fd;
d1852 1
d1867 1
a1867 1
  int build_count = 0;
d1916 2
a1917 3
    if((fd=fopen(MAKE_COUNT, "r"))) {
      fscanf(fd, "%d", &build_count);
      fclose(fd);
a1918 1
    sprintf(buf, " %d", build_count);
d1923 1
a1923 1
      SEND_TO_Q(buf, d);
d1929 1
a1929 1
      SEND_TO_Q(buf, d);
@


1.3
log
@Indented file
@
text
@d1850 1
d1862 1
d1866 1
a1866 2


d1915 5
d1924 2
d1930 2
@


1.2
log
@fixedtemp remove races from login menu
@
text
@d2 8
a9 8
*   File: interpreter.c                                 Part of CircleMUD *
*  Usage: parse user commands, search for specials, call ACMD functions   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d370 2
a371 2
/*0's are:
name , position, acmd, min level, mediate, min/maj para, hide, bound*/
d380 1
a380 1
/* now, the main list */
d385 1
a385 1
 { "aggr" , POS_DEAD, do_aggr, 0, 0, 0, 0, 0, 0, 0 ,0 },
d468 2
a469 2
{ "disband"  , POS_RESTING , do_disband  , 1, 0 , 0, 0, 0, 0, 0 , 0},  
{ "dig"      , POS_STANDING, do_dig      , LVL_BUILDER, 0 , 0, 0, 0, 0, 0 ,0 },
d510 1
a510 1
 { "frag"   , POS_DEAD    , do_frag  , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d553 1
a553 1
 { "hitall"      , POS_FIGHTING    , do_hitall      , 0, 0, 0, 0, 0, 0,0,0},
d575 1
a575 1
  #ifndef CIRCLE_WINDOWS
d580 1
a580 1
*/
d585 1
a585 1

d593 1
a593 1
 /* { "levels"   , POS_DEAD    , do_levels   , 0, 0 , 0, 0, 0, 0, 0 ,0 },*/
d603 1
a603 1
 { "mdisband"  , POS_RESTING , do_mdisband  , 1, 0 , 0, 0, 0, 0, 0 , 0},
d611 1
a611 1
{ "mgroup"   , POS_RESTING , do_mgroup    , 1, 0 , 0, 0, 0, 0, 0 , 0},
d635 1
a635 1
 {"anews" , POS_SLEEPING, do_gen_ps , LVL_GOD, SCMD_ANEWS , 0, 0, 0, 0, 0,0 },
d678 1
a678 1
 /* { "practice" , POS_RESTING , do_practice , 1, 0 , 0, 0, 0, 0, 0 ,0},*/
d708 1
a708 2
 /* { "readlist"  , POS_DEAD    , do_readlist     , LVL_GOD, 0 , 0, 0,
0,0,0, 0 },*/
d711 1
a711 2
  { "return"   , POS_DEAD    , do_return   , 1, 0 , 0, 0, 0, 0, 0
,0 },
d739 1
a739 1
 { "sdedit"    , POS_DEAD , do_olc   , LVL_HEAD_B, SCMD_OLC_SDEDIT , 0, 0, 0, 0, 0 ,0 },
d841 1
a841 1
 { "tug"    , POS_RESTING , do_action   , 0, 0 , 0, 0, 0, 0, 0 ,0 },
d858 1
a858 1
 { "viewdam"  , POS_DEAD , do_viewdam  , LVL_HEAD_B, 0 , 0, 0, 0, 0, 0 ,0 },
d967 1
a967 1

d973 7
a979 7
 if (ch->char_specials.action_delays[ACT_DELAY_INSTANTKILL]) {
	if (IS_FIGHTING(ch)) {
	  act("You ARE too determined to kill $N at the moment.",
	      FALSE, ch, 0, FIGHTING(ch), TO_CHAR);
	  return;
	}
      }
d986 1
a986 1

d988 1
a988 1
   if ((GET_LEVEL(ch)<LVL_IMMORT) &&
d993 1
a993 1

d999 1
a999 1
  REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
d1002 3
a1004 3
   if (cmd_info[cmd].meditate == 0){
          REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
          send_to_char("&8You stop meditating.\r\n&0", ch);}
d1006 3
a1008 3
   if (cmd_info[cmd].meditate == 0){
          REMOVE_BIT(PLR_FLAGS(ch), PLR_SCRIBE);
          send_to_char("&8You stop scribing.\r\n&0", ch);}
d1010 2
a1011 2
   if (cmd_info[cmd].hide == 0)
     appear(ch);
d1018 1
a1018 1
	  (cmd_info[cmd].bound == 0))
d1023 1
a1023 1
       (cmd_info[cmd].minor_p == 0))
d1025 2
a1026 2
else if(PLR_FLAGGED(ch, PLR_CASTING) && (cmd_info[cmd].cast == 0))
	  send_to_char("&8You are busy spellcasting......\r\n&0", ch);
d1055 2
a1056 2
  }else if (no_specials || !special(ch, cmd, line))
    ((*cmd_info[cmd].command_pointer) (ch, line, cmd, cmd_info[cmd].subcmd));
d1060 2
a1061 2
 * Routines to handle aliasing                                             *
  **************************************************************************/
d1070 1
a1070 1

d1073 1
a1073 1

d1081 29
a1109 29
//	bool used = FALSE;
	int i;
	char *stats[6] = {	"\r\n1)Working up a sweat at work or training, from dusk to dawn",			
						"2)Physical Strength and Power",
						"3)Cunningness and speed on feet",
						"4)Religeon, Historical and Political Study's",	
						"5)Spending most your time in the library",
						"6)Helping out your fellow neighbour"};

/*colours:	norm:CCNRM(d->character,C_SPR)
			green:CCGRN(d->character,C_SPR)
			bold:CCBLD(d->character,C_SPR)
*/
	strcpy(buf, "");
	for (i=0;i<6;i++)
	{
		if (GET_ROLL(d->character, i))
			sprintf(buf, "%s",CCGRN(d->character,C_SPR));
		else
			sprintf(buf, "%s%s",CCGRN(d->character,C_SPR), CCBLD(d->character,C_SPR)); 
		sprintf(buf, "%s%s&0", buf, stats[i]);
		if (GET_ROLL(d->character, i))
			sprintf(buf, "%s&0&6[&0&6&b%d&0&6]&0\r\n",buf, (int)GET_ROLL(d->character, i));
		else
			sprintf(buf, "%s\r\n", buf);

		send_to_char(buf, d->character);
	}
	send_to_char("\r\n>", d->character);
d1114 18
a1131 18
	int result;
	if (!is_number(arg))
			return FALSE;
	result = atoi(arg) - 1;
	
	if ((result < 0) || (result > 5))
	{
		send_to_char("Incorrect choice\r\n", d->character);
		display_question(d);
		return FALSE;
	}
	if (GET_ROLL(d->character, result))
	{
		send_to_char("Sorry that option is already used.\r\n", d->character);
		return FALSE;
	}
	GET_ROLL(d->character, result) ^= question;
	return TRUE;
d1150 1
a1150 1

d1153 1
a1153 1

d1155 1
a1155 1

d1212 1
a1212 1

d1219 1
a1219 1

d1223 1
a1223 1

d1244 1
a1244 1

d1248 1
a1248 1

d1271 1
a1271 1

d1275 1
a1275 1

d1278 1
a1278 1

d1282 1
a1282 1

d1286 1
a1286 1

d1311 1
a1311 1

d1315 1
a1315 1

d1328 1
a1328 1

d1335 1
a1335 1

d1338 1
a1338 1

d1342 1
a1342 1

d1350 1
a1350 1
string */
d1355 1
a1355 1

d1364 1
a1364 1

d1378 1
a1378 1

d1381 1
a1381 1

d1383 1
a1383 1

d1388 1
a1388 1

d1390 1
a1390 1

d1414 1
a1414 1

d1417 1
a1417 1

d1423 1
a1423 1

d1426 1
a1426 1

d1438 1
a1438 1

d1441 1
a1441 1

d1443 1
a1443 1

d1457 1
a1457 1

d1460 1
a1460 1

d1469 1
a1469 1

d1474 1
a1474 1

d1476 1
a1476 1

d1504 1
a1504 1

d1508 1
a1508 1

d1518 1
a1518 1

d1533 3
a1535 3

/*
  for (x = 0; x < NUM_CLASSES; x++)
d1537 4
a1540 4
      send_to_char(class_display[x], d->character);
      send_to_char("\nClass: ", d->character);
*/
/* Subclassing explaination/preface */
d1544 1
a1544 1
     strip_ansi(pc_class_types[CLASS_WARRIOR])); 
d1549 1
a1549 1
     strip_ansi(pc_class_types[CLASS_CLERIC]));
d1554 1
a1554 1
     strip_ansi(pc_class_types[CLASS_MAGIC_USER])); 
d1559 1
a1559 1
     strip_ansi(pc_class_types[CLASS_ROGUE]));
d1564 1
a1564 1
     strip_ansi(pc_class_types[CLASS_SHAMAN]));
d1572 30
a1601 30
   if(warriorok)
    if (x < WARRIOR_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf, 
	class_ok_race[char_race][warrior_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[warrior_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(clericok)
    if (x < CLERIC_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf, 
	class_ok_race[char_race][cleric_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[cleric_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(mageok)
    if (x < MAGE_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s ", buf, 
	class_ok_race[char_race][mage_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[mage_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s ", buf, " ");
   if(rogueok)
    if (x < ROGUE_SUBCLASSES)
      sprintf(buf, "%s%s%-15.15s", buf, 
	class_ok_race[char_race][rogue_subclasses[x]] ? "*" : " ",
	  strip_ansi(pc_class_types[rogue_subclasses[x]]));
    else
      sprintf(buf, "%s%-16.16s", buf, " ");

   sprintf(buf, "%s\r\n", buf);
d1605 5
a1609 5
	warriorok ? "[&bw&0&1]arrior," : "",
	clericok ? "[&bc&0&1]leric," : "",
	mageok ? "[&bs&0&1]orcerer," : "",
	rogueok ? "[&br&0&1]ogue," : "",
	shamanok ? "s[&bh&0&1]aman," : "");
d1612 1
a1612 1

d1617 16
a1632 16
	int a = 0;
	int c = 0;
	char *b[] = {"1)", "2)", "3)", "4)", "5)"};
	int result_rooms[10];
	int x;
	room_selector(race, class, result_rooms, TRUE);
	
	send_to_char("\n\n\r&0&8&bPlease choose a hometown.&0\r\n", d->character);
	
	for (a = 0; result_rooms[a] != -1; a++) 
	{
		x = result_rooms[a];	
		send_to_char(b[c], d->character);c++;	 
		send_to_char(char_hometown[x], d->character); 
	}

d1639 1
a1639 1

d1651 1
a1651 1

d1655 1
a1655 1

d1665 1
a1665 1

d1670 1
a1670 1

d1676 1
a1676 1

d1682 1
a1682 1

d1688 1
a1688 1

d1694 1
a1694 1

d1701 2
a1702 2
*  Stuff for controlling the non-playing sockets (get name, pwd etc)       *
************************************************************************* */
d1709 1
a1709 1

d1714 1
a1714 1

d1738 1
a1738 1

d1741 1
a1741 1

d1766 10
a1775 10

 /*
  * now, go through the character list, deleting all characters that
  * are not already marked for deletion from the above step (i.e., in the
  * CON_HANGUP state), and have not already been selected as a target for
  * switching into.  In addition, if we haven't already found a target,
  * choose one if one is available (while still deleting the other
  * duplicates, though theoretically none should be able to exist).
  */

d1778 1
a1778 1

d1783 1
a1783 1

d1787 1
a1787 1

d1791 1
a1791 1

d1798 1
a1798 1

d1805 1
a1805 1

d1809 1
a1809 1

d1818 1
a1818 1

d1841 1
a1841 1

d1857 1
a1857 1
/*  extern char *race_menu; */
d1873 1
a1873 1

d1875 1
a1875 1

d1882 2
a1883 2


d1885 17
a1901 17
   /*. OLC states .*/
   case CON_OEDIT: 
     oedit_parse(d, arg);
     break;
   case CON_REDIT: 
     redit_parse(d, arg);
     break;
   case CON_ZEDIT: 
     zedit_parse(d, arg);
     break;
   case CON_MEDIT: 
     medit_parse(d, arg);
     break;
   case CON_SEDIT: 
     sedit_parse(d, arg);
     break;
   case CON_HEDIT: 
d1904 1
a1904 1
   case CON_TRIGEDIT:
d1907 19
a1925 19
      case CON_SDEDIT:
       sdedit_parse(d, arg);
       break;
   /*. End of OLC states .*/

 
   case CON_QANSI:
     if (!*arg || LOWER(*arg) == 'y') {
       SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
       SEND_TO_Q("Color is on.\r\n", d);
       SEND_TO_Q(GREETINGS, d);
     } else if (LOWER(*arg) == 'n') {
       REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
       SEND_TO_Q("Color is off.\r\n", d);
       SEND_TO_Q(GREETINGS, d);
     } else {
       SEND_TO_Q("That is not a proper response.\r\n", d);
       SEND_TO_Q(ANSI, d);
       return;
d1943 1
a1943 1
       
d1947 3
a1949 3
load_results(d->character);
change_affected_stats(d->character);

d1964 1
a1964 1
  	    
d1972 6
a1977 6

           if (color)
             SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
           else
             REMOVE_BIT(PRF_FLAGS(d->character), PRF_COLOR_1 | PRF_COLOR_2);
  
d1985 1
a1985 1

d1993 1
a1993 1

d2042 1
a2042 1

d2044 1
a2044 1

d2064 1
a2064 1

d2085 1
a2085 1

d2090 1
a2090 1

d2093 1
a2093 1

d2106 1
a2106 1

d2117 1
a2117 1

d2123 1
a2123 1

d2125 1
a2125 1

d2139 1
a2139 1

d2150 1
a2150 1

d2152 1
a2152 1

d2169 30
a2198 30

/*    SEND_TO_Q(race_menu, d);
 *    SEND_TO_Q("\r\nRace: ", d); 
 *   STATE(d) = CON_QRACE;
 *   break;
 *	case CON_QRACE:
 *		load_result = parse_race(*arg);
 *		if (load_result == RACE_UNDEFINED) {
 *			SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
 *			return;
 *		} else
 *			GET_RACE(d->character) = load_result;
 *		    
 */
	GET_RACE(d->character) = RACE_HUMAN;

	display_classes(d,1); 

			STATE(d) = CON_QCLASS;
			break;






 case CON_QCLASS:
/*
    load_result = parse_class(d->character, *arg);
    if (load_result == CLASS_UNDEFINED) {
d2201 1
a2201 1
    } else
d2203 85
a2287 59
*/
   switch (*arg) {
     case 'w':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_WARRIOR])
	  load_result = CLASS_WARRIOR;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'c':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_CLERIC])
	  load_result = CLASS_CLERIC;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 's':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_MAGIC_USER])
	  load_result = CLASS_MAGIC_USER;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'r':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_ROGUE])
	  load_result = CLASS_ROGUE;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case 'h':
	if (class_ok_race[(int)GET_RACE(d->character)][CLASS_SHAMAN])
	  load_result = CLASS_SHAMAN;
	else {
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;
	}
	break;
     case '?':
	sprintf(buf2, "Class Help Menu\r\n-=-=-=-=-=-=-=-\r\n");
	for(i=0;i<NUM_CLASSES;i++) 
	  sprintf(buf2, "%s%s\r\n", buf2, class_display[i]);
	sprintf(buf2, "%s0) Back to Class Selection\r\n\r\nSelection: ",buf2);
	page_string(d, buf2, 0);
	  STATE(d) = CON_CLASSHELP;
	  return;
     default:
          SEND_TO_Q("\r\nInvalid selection.\r\nClass: ", d);
          return;	

   }
   GET_CLASS(d->character) = load_result;

/*Start of Rollor opperations*/

d2289 2
a2290 28

	display_hometown(GET_RACE(d->character), GET_CLASS(d->character), 
d); 
		   
	STATE(d) = CON_QHOMETOWN;
	break;
   
case CON_CLASSHELP:
	if (!*arg || *arg == '0') {
	  display_classes(d,1);
	  STATE(d) = CON_QCLASS;
	  return;
	}
        load_result = parse_class(NULL, *arg);
        if (load_result == CLASS_UNDEFINED) {
          SEND_TO_Q("\r\nInvalid selection.\r\nSelection (0 to quit): ", d);
          return;
        } else {
          do_help(d->character, strip_ansi(class_display[load_result]+3),0,0);
	  send_to_char("Select a-x,  0 to quit: ",d->character);
	  return;
	}
	break;
  
case CON_QHOMETOWN:   
	
	load_result = set_new_home_town(GET_RACE(d->character), 
GET_CLASS(d->character), *arg);
d2292 1
a2292 1
	  if (load_result == UNDEFINED_HOME_NO) {
d2297 4
a2300 4
     /* commented out by FINGH, do NOT delete. 
      * SEND_TO_Q(diety_selection, d);
      * SEND_TO_Q("\r\nDiety:", d);
      * STATE(d) = CON_QDIETY;    
d2302 129
a2430 101
		send_to_char("Please put these in the order they most appeal to you:", d->character);
        display_question(d); 
		STATE(d) = CON_QQUESTION1;        
        break;

      /* illegal case as of 10/31/98 -fingh */
      case CON_QDIETY:
        load_result = 0;
        load_result = parse_diety(d->character, *arg);
	if(load_result == INVALID_DIETY)
        {
          SEND_TO_Q("You cannot worship that diety.\r\nDiety:", d);
          return;
        }
        else
          GET_DIETY(d->character) = load_result;            
        SEND_TO_Q(question1, d);
        STATE(d) = CON_QQUESTION1;        
        break; 

	  case CON_QQUESTION1:
		if (!ask_question(d, 1, arg))
		{
			send_to_char("Please re-try your first choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your second stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION2;
		break;
		  
	  case CON_QQUESTION2:
		
		if (!ask_question(d, 2, arg))
		{
			send_to_char("Please re-try your second choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your third stat:", d->character);
		display_question(d);
	STATE(d) = CON_QQUESTION3;
		  break;


	  case CON_QQUESTION3:
		if (!ask_question(d, 3, arg))
		{
			send_to_char("Please re-try your third choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your fourth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION4;
		break;
		
	  case CON_QQUESTION4:
		
		if (!ask_question(d, 4, arg))
		{
			send_to_char("Please re-try your fourth choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your fifth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION5;
		break;
		
	  case CON_QQUESTION5:
		
		if (!ask_question(d, 5, arg))
		{
			send_to_char("Please re-try your fifth choice:", d->character);
			display_question(d);
			return;
		}
		send_to_char("Please enter choose your sixth stat:", d->character);
		display_question(d);
		STATE(d) = CON_QQUESTION6;
		break;

	
	  case CON_QQUESTION6:
		
		if (!ask_question(d, 6, arg))
		{
			send_to_char("Please re-try your sixth choice:", d->character);
			display_question(d);
			return;
		}
		display_question(d);
		send_to_char("Your choices are complete.\r\n", d->character);
		SEND_TO_Q("Please press return to roll your stats", d);
		STATE(d) = CON_QROLLSTATS;
		break;
	

	 case CON_QROLLSTATS:
d2432 50
a2481 26
		  switch (*arg) {
      case 'y':
      case 'Y':
          if ((GET_STR_VIEW(d->character)) > 0)
		  break;
      case 'n':
      case 'N':	
      default:

       
		roll_view_abils(d->character, choice_table);	
		load_results(d->character);
		change_affected_stats(d->character);
		new_rollor_display(d->character, roll_table);
		sprintf(buf, "\r\n\r	Con:  %s		Wis:  %s\r\n"
		"	Str:  %s		Intel:%s\r\n"
		"	Dex:  %s		Char: %s\r\r\r\r\n", 
rolls_abils_result[roll_table[4]],  rolls_abils_result[roll_table[2]],
		rolls_abils_result[roll_table[0]], 
rolls_abils_result[roll_table[1]], rolls_abils_result[roll_table[3]], 
rolls_abils_result[roll_table[5]]);
		SEND_TO_Q(buf, d);
        SEND_TO_Q("\r\n\nYou may keep these stats if you wish (&0&6Enter y&0),\r\nor if you wish"
		" you may try for better stats (&0&6Enter n&0)(y/n):", d);
		return;

d2483 8
a2490 60
		 
		 
    	 SEND_TO_Q("\r\r\n\n&0&7&bYou have three bonus's to use choose the stat carefully:&0\n\r", d);
		 SEND_TO_Q(stats_display, d);
		 SEND_TO_Q("\r\n&0&7&bPlease enter your first bonus selection:&0\n\r",d);
		 STATE(d) = CON_QBONUS1;
	   	break;	
		case CON_QBONUS1:
		load_result = bonus_stat(d->character, *arg);
		if (!load_result) {
			SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}
		SEND_TO_Q(stats_display, d);
    	 SEND_TO_Q("\r\n&0&7&bPlease enter your second bonus selection:&0\n\r",d);
	
			
			STATE(d) = CON_QBONUS2;
		break;	
		case CON_QBONUS2:
		load_result = bonus_stat(d->character, *arg);
		if (!load_result) {
			SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}
			SEND_TO_Q(stats_display, d);
    	SEND_TO_Q("\r\n&0&7&bPlease enter your third bonus selection:&0\n\r",d);
	
			
			STATE(d) = CON_QBONUS3;
			 break;
		case CON_QBONUS3:
			load_result = bonus_stat(d->character, *arg);
	load_results(d->character);
change_affected_stats(d->character);
			if (!load_result) {
			  	SEND_TO_Q("&0&1That selection was not offered, please try again&0\r\n\r\n", d);
			return;
		}

 		SEND_TO_Q("&0&4\r\n\r\nRolling for this character is complete!!\r\n"
			"&0&4&bDo you wish to keep this character(y)?('n' will take you back to start menu)\r\n&0", d);
			STATE(d) = CON_QCANCHAR;
			break;
		case CON_QCANCHAR:
		 	*arg = LOWER(*arg);
			if (*arg == 'n') {
				GET_STR_VIEW(d->character) = 0;
            for (i=0;i<6;i++)
	         {
		         (int)GET_ROLL(d->character, i) = NULL;
            }
	
            SEND_TO_Q("What is your sex (M/F)? ", d);
				STATE(d) = CON_QSEX;
			break;
			}


if (GET_PFILEPOS(d->character) < 0)
d2494 2
a2495 2

  SEND_TO_Q(motd, d);
d2498 1
a2498 1

d2502 3
a2504 3



d2509 1
a2509 1

d2515 2
a2516 2
  case '1':
     	 reset_char(d->character);
d2519 1
a2519 1
	  GET_RACE_ALIGN(d->character) = set_race_align(d->character);
d2522 1
a2522 1

d2525 11
a2535 13
		  if (GET_LEVEL(d->character) >= LVL_IMMORT) {
		  	  load_room = real_room(GET_HOME(d->character));
			  if (load_room < 0) {
			  log("SYSERR:  A Immortal start room does not exis.");
			  load_room = r_immort_start_room;
					}
		  } else {
			  load_room = real_room(GET_HOME(d->character));
			  if (load_room < 0) {
			  log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
			  load_room = r_mortal_start_room;
					}
		  }
d2537 3
a2539 1
	  
d2541 1
a2541 1

d2543 1
a2543 1

d2545 1
a2545 1
	   if ((load_result = Crash_load(d->character)))
d2551 5
a2555 5
       GET_ID(d->character) = GET_IDNUM(d->character);
       save_char(d->character, NOWHERE);
       send_to_char(WELC_MESSG, d->character);
       d->character->next = character_list;
       character_list = d->character;
d2557 1
a2557 1

d2569 1
a2569 1
	  "Your possesions have been donated to the Salvation Army!\r\n",
d2573 2
a2574 2
	  break;

d2582 1
a2582 1
        if (d->character->player.description) {
d2596 1
a2596 1

d2601 1
a2601 1

d2649 1
a2649 1

d2688 1
a2688 1

d2692 1
a2692 1

d2704 25
a2728 25
int percent, total;
int current;
if (abs(GET_LEVEL(ch) - level) > 2)
level = GET_LEVEL(ch); 
if (level >= 65)
percent = 3;
else if (level >= 55)
percent = 5;
else if (level >= 50)
percent = 10;
else if (level >= 40)
percent = 20;
else if (level >= 30)
percent = 25;
else if (level >= 20)
percent = 30;
else
percent = 35;
total = (int) exp_to_level(level, GET_CLASS(ch)) - exp_to_level((level - 1), GET_CLASS(ch));

current = (int)((percent * total)/100);
/*This is a test display to character*/
/*
sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
	send_to_char(buf, ch);
d2730 3
a2732 3
return current;


d2737 15
a2751 15
int percent, total;
int current;
if (GET_LEVEL(ch) >= 40)
percent = 15;
else if (GET_LEVEL(ch) >= 30)
percent = 15;
else if (GET_LEVEL(ch) >= 20)
percent = 15;
else
percent = 30;
total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));

current = (int)((percent * total)/100);
/*sprintf(buf, "max exp gain is %d\r\nbut total %d, percent %d", current, total, percent);
	send_to_char(buf, ch);
d2753 2
a2754 2
return current;

d2758 10
a2767 10
	long percent, current, total;

	
	current = exp_to_level((GET_LEVEL(ch)), GET_CLASS(ch)) - GET_EXP(ch);
	total = exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)) - exp_to_level((GET_LEVEL(ch) - 1), GET_CLASS(ch));
	current = total - current;
 percent = (long) ((100 * current) / total);

/* sprintf(buf, "percent is %d\r\nbut total %d, current %d", percent, total, current);
	send_to_char(buf, ch);
d2769 2
a2770 2


d2797 23
a2819 2
 int statts[6]; 
 int j;
a2820 21

 statts[0] = GET_STR_VIEW(ch);
 statts[1] = GET_INT_VIEW(ch);
 statts[2] = GET_WIS_VIEW(ch);
 statts[3] = GET_DEX_VIEW(ch);
 statts[4] = GET_CON_VIEW(ch);
 statts[5] = GET_CHA_VIEW(ch);
 
for (j = 0; j <= 5; j++)	{
	  if (statts[j] > 90)
		  word[j] = 0;
	  else if (statts[j] > 80)
		  word[j] = 1;
	  else if (statts[j] > 62)
		  word[j] = 2;
	  else if (statts[j] > 52)
		  word[j] = 3;
	  else
		  word[j] = 4;
 }
 
d2825 45
a2869 45
int b;
int a;	
arg = LOWER(arg);	
switch(arg) 
{
	case 'w':
		b = number(2, 6);
		GET_WIS_VIEW(ch) = MIN(100, (GET_WIS_VIEW(ch) +b));
		a = TRUE;		
		break;	
	case 'i':
		b = number(2, 6);
		GET_INT_VIEW(ch) = MIN(100, (GET_INT_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'm':
		b = number(2, 6);
		GET_CHA_VIEW(ch) = MIN(100, (GET_CHA_VIEW(ch) +b));
		a = TRUE;
		break;
	case 'c':
		b = number(2, 6);
		GET_CON_VIEW(ch) = MIN(100, (GET_CON_VIEW(ch) +b));
		a = TRUE;
		break;	
	case 'd':		b = number(2, 6);
		GET_DEX_VIEW(ch) = MIN(100, (GET_DEX_VIEW(ch) +b));
		a = TRUE;
		break;
	case 's':
		b = number(2, 6);
		GET_STR_VIEW(ch) = GET_STR_VIEW(ch) + b;
		if (GET_STR_VIEW(ch) > 100) {
			GET_ADD_VIEW(ch) = MIN(100, ((GET_ADD_VIEW(ch) +
(GET_STR_VIEW(ch) % 100))));
			GET_STR_VIEW(ch) = 100;
		}
		a = TRUE;
		break;
	default:	
		a = FALSE;
		break;
	}	
ch->vaff_abils = ch->view_abils;
return a;
d3377 5
@


1.1
log
@Initial revision
@
text
@d1859 1
a1859 1
  extern char *race_menu;
d2172 14
a2185 12
    SEND_TO_Q(race_menu, d);
    SEND_TO_Q("\r\nRace: ", d);
    STATE(d) = CON_QRACE;
    break;
	case CON_QRACE:
		load_result = parse_race(*arg);
		if (load_result == RACE_UNDEFINED) {
			SEND_TO_Q("\r\nThat's not a race DUH! \r\nRACE: ", d);
			return;
		} else
			GET_RACE(d->character) = load_result;
		    
@
