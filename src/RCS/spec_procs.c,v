head	1.103;
access;
symbols;
locks
	mud:1.103; strict;
comment	@ * @;


1.103
date	2010.07.06.03.07.02;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.02.14.09.16;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.05.14.56.27;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.25.22.57.16;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.25.22.13.38;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.18.06.02.11;	author myc;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.11.13.38.13;	author myc;	state Exp;
branches;
next	1.96;

1.96
date	2009.06.09.19.33.50;	author myc;	state Exp;
branches;
next	1.95;

1.95
date	2009.03.20.13.56.22;	author jps;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.19.23.16.23;	author myc;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.09.21.43.50;	author myc;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.09.20.36.00;	author myc;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.09.04.33.20;	author jps;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.08.23.34.14;	author jps;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.03.19.43.44;	author myc;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.19.09.25.23;	author myc;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.17.00.28.02;	author myc;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.20.07.51.45;	author jps;	state Exp;
branches;
next	1.85;

1.85
date	2008.09.20.07.25.50;	author jps;	state Exp;
branches;
next	1.84;

1.84
date	2008.09.09.08.23.37;	author jps;	state Exp;
branches;
next	1.83;

1.83
date	2008.09.07.20.05.27;	author jps;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.02.06.56.39;	author jps;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.29.16.55.00;	author myc;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.18.01.35.38;	author jps;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.18.05.39.59;	author jps;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.04.06.12.52;	author myc;	state Exp;
branches;
next	1.77;

1.77
date	2008.03.28.17.54.53;	author myc;	state Exp;
branches;
next	1.76;

1.76
date	2008.03.09.06.38.37;	author jps;	state Exp;
branches;
next	1.75;

1.75
date	2008.03.07.21.21.57;	author myc;	state Exp;
branches;
next	1.74;

1.74
date	2008.03.05.05.21.56;	author myc;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.09.21.07.50;	author myc;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.09.18.29.11;	author myc;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.09.04.27.47;	author myc;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.09.03.06.17;	author myc;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.29.21.02.31;	author myc;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.27.21.14.59;	author myc;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.26.14.26.31;	author jps;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.23.02.34.43;	author jps;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.23.02.33.26;	author jps;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.18.20.30.11;	author myc;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.05.05.44.45;	author jps;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.04.01.42.50;	author jps;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.03.12.44.03;	author jps;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.02.02.10.34;	author jps;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.02.01.04.26;	author jps;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.25.05.41.49;	author jps;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.19.20.55.56;	author myc;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.11.20.14.48;	author myc;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.12.19.23.04;	author myc;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.23.00.58.13;	author jps;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.16.11.54.19;	author jps;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.03.22.00.11;	author myc;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.14.02.16.22;	author jps;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.29.20.16.32;	author jps;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.29.19.45.25;	author jps;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.28.23.22.14;	author jps;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.11.16.05.27;	author jps;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.11.14.18.12;	author jps;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.04.13.40.12;	author jps;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.27.04.27.05;	author myc;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.20.03.47.24;	author jps;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.11.23.52.32;	author jps;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.08.09.16.04;	author jps;	state Exp;
branches;
next	1.40;

1.40
date	2006.10.07.02.09.23;	author dce;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.06.01.54.48;	author dce;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.24.21.45.41;	author cjd;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.13.21.39.28;	author cjd;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.13.06.14.00;	author jjl;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.09.19.18.27;	author jjl;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.19.19.14.02;	author jjl;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.19.19.07.17;	author jjl;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.19.18.58.37;	author jjl;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.19.18.56.09;	author jjl;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.19.18.29.52;	author jjl;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.13.02.32.10;	author jjl;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.14.00.19.07;	author dce;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.06.22.02.55;	author rsd;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.25.02.33.15;	author rsd;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.03.17.28.33;	author jimmy;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.21.12.08.09;	author mtp;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.15.05.20.41;	author cmc;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.15.05.19.47;	author cmc;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.13.17.55.52;	author cmc;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.19.21.38.58;	author rsd;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.18.02.52.43;	author rsd;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.18.01.31.23;	author rsd;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.16.21.58.27;	author rsd;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.06.06.59.55;	author rsd;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.05.02.33.30;	author rsd;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.05.01.26.34;	author rsd;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.04.21.54.31;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.04.21.25.53;	author rsd;	state Exp;
branches;
next	1.11;

1.11
date	99.11.16.00.18.51;	author rsd;	state Exp;
branches;
next	1.10;

1.10
date	99.10.30.16.03.05;	author rsd;	state Exp;
branches;
next	1.9;

1.9
date	99.09.05.07.00.39;	author jimmy;	state Exp;
branches;
next	1.8;

1.8
date	99.08.24.03.05.35;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	99.07.24.20.50.18;	author dce;	state Exp;
branches;
next	1.6;

1.6
date	99.07.07.16.49.04;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	99.04.30.19.12.56;	author dce;	state Exp;
branches;
next	1.4;

1.4
date	99.04.24.03.07.01;	author jimmy;	state Exp;
branches;
next	1.3;

1.3
date	99.04.24.02.12.56;	author dce;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.16.15.46;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.01.23.32;	author mud;	state Exp;
branches;
next	;


desc
@/* ************************************************************************
*   File: spec_procs.c                                  Part of CircleMUD *
*  Usage: implementation of special procedures for mobiles/objects/rooms  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "ships.h"
#include "clan.h"

/*   external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct time_info_data time_info;
extern struct command_info cmd_info[];
extern struct spell_info_type spell_info[];


/* extern functions */
void add_follower(struct char_data * ch, struct char_data * leader);
void perform_remove(struct char_data * ch, int pos);
void clear_skills(struct char_data *ch);
void assign_skills(struct char_data *ch);
struct obj_data *get_obj_in_list_vnum(int num, struct obj_data * list);
int parse_class(struct char_data *ch, char arg);
void set_skills(struct char_data *ch);
void update_skills(struct char_data *ch);

struct social_type {
  char *cmd;
  int next_line;
};


/* ********************************************************************
*  Special procedures for mobiles                                     *
******************************************************************** */

int spell_sort_info[MAX_SKILLS+1];

extern char *spells[];

void sort_spells(void)
{
  int a, b, tmp;

  /* initialize array */
  for (a = 1; a < MAX_SKILLS; a++)
    spell_sort_info[a] = a;

  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < MAX_SKILLS - 1; a++)
    for (b = a + 1; b < MAX_SKILLS; b++)
      if (strcmp(spells[spell_sort_info[a]], spells[spell_sort_info[b]]) > 0) {
	tmp = spell_sort_info[a];
	spell_sort_info[a] = spell_sort_info[b];
	spell_sort_info[b] = tmp;
      }
}


char *how_good(int percent)
{
  static char buf[256];

  if (percent == 0)
    strcpy(buf, " (not learned)");
  else if (percent <= 10)
    strcpy(buf, " (awful)");
  else if (percent <= 20)
    strcpy(buf, " (bad)");
  else if (percent <= 40)
    strcpy(buf, " (poor)");
  else if (percent <= 55)
    strcpy(buf, " (average)");
  else if (percent <= 70)
    strcpy(buf, " (fair)");
  else if (percent <= 80)
    strcpy(buf, " (good)");
  else if (percent <= 85)
    strcpy(buf, " (very good)");
  else
    strcpy(buf, " (superb)");

  return (buf);
}

char *prac_types[] = {
  "spell",
  "skill"
};

#define LEARNED_LEVEL	0	/* % known which is considered "learned" */
#define MAX_PER_PRAC	1	/* max percent gain in skill per practice */
#define MIN_PER_PRAC	2	/* min percent gain in skill per practice */
#define PRAC_TYPE	3	/* should it say 'spell' or 'skill'?	 */

/* actual prac_params are in class.c */
extern int prac_params[4][NUM_CLASSES];

#define LEARNED(ch) (prac_params[LEARNED_LEVEL][(int)GET_CLASS(ch)])
#define MINGAIN(ch) (prac_params[MIN_PER_PRAC][(int)GET_CLASS(ch)])
#define MAXGAIN(ch) (prac_params[MAX_PER_PRAC][(int)GET_CLASS(ch)])
#define SPLSKL(ch) (prac_types[prac_params[PRAC_TYPE][(int)GET_CLASS(ch)]])

void list_skills(struct char_data * ch)
{
  extern char *spells[];

  int i, sortpos;

  if (!GET_PRACTICES(ch))
    strcpy(buf, "You have no practice sessions remaining.\r\n");
  else
    sprintf(buf, "You have %d practice session%s remaining.\r\n",
	    GET_PRACTICES(ch), (GET_PRACTICES(ch) == 1 ? "" : "s"));

  sprintf(buf, "%sYou know of the following %ss:\r\n", buf, SPLSKL(ch));

  strcpy(buf2, buf);

  for (sortpos = 1; sortpos < MAX_SKILLS; sortpos++) {
    i = spell_sort_info[sortpos];
    if (strlen(buf2) >= MAX_STRING_LENGTH - 32) {
      strcat(buf2, "**OVERFLOW**\r\n");
      break;
    }
    if (GET_LEVEL(ch) >= spell_info[i].min_level[(int) GET_CLASS(ch)]) {
      sprintf(buf, "%-20s %s\r\n", spells[i], how_good(GET_SKILL(ch, i)));
      strcat(buf2, buf);
    }
  }

  page_string(ch->desc, buf2, 1);
}

SPECIAL(assassin_subclasser)
{
 int i = 0;
 struct obj_data *qobj;
 int type;

 if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
 type = GET_CLASS(ch);
 if(type == CLASS_ASSASSIN){
 act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
  FALSE,me,0,ch, TO_VICT);
    return 1;
  }
 if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of teh rogue.'&0",
     FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type != CLASS_ROGUE) || ((i = parse_class(ch, 'j')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'An assassin you will never be, now begone!'&0",
    FALSE,me,0,ch, TO_VICT);
    return 1;
  }

 if (GET_ALIGNMENT(ch) > -500) {
act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

 if (!(qobj = get_obj_in_list_vnum(32026, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the roguish quest.'&0",
FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
TRUE,me,0,ch,TO_ROOM);
act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues!
You are an Assassin!&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

SPECIAL(mercenary_subclasser)
{
 int i = 0;
 struct obj_data *qobj;
 int type;

 if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
 type = GET_CLASS(ch);
 if(type == CLASS_MERCENARY){
 act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
  FALSE,me,0,ch, TO_VICT);
    return 1;
  }
 if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of teh rogue.'&0",
     FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type != CLASS_WARRIOR) ||
 ((i = parse_class(ch, 'k')) == CLASS_UNDEFINED))
{
    act("&2&b$n&2&b tells you, 'A mercenary you will never be, now begone!'&0",
    FALSE,me,0,ch, TO_VICT);
    return 1;
  }

 if (!(qobj = get_obj_in_list_vnum(55601, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the roguish quest.'&0",
FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
TRUE,me,0,ch,TO_ROOM);
act("&2&b$n&2&b tells you, 'Congratulations! You are now a sword for hire!
You are a Mercenary!&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

SPECIAL(diabolist_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  type = GET_CLASS(ch);
  if((type == CLASS_DIABOLIST) || (type == CLASS_ANTI_PALADIN)){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'Your path will never lead to true evil. Begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if(GET_LEVEL(ch) < 21) {
act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of evil.'&0",
FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type == CLASS_CLERIC) && ((i = parse_class(ch, 'q')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'A diabolist you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && ((i = parse_class(ch, 'f')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'An anti-paladin you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (GET_ALIGNMENT(ch) > -500) {
act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj = get_obj_in_list_vnum(2300, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the unholy quest.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a &4blue flame!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_CLERIC)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy cleric! You are a Diabolist!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy
warrior! You are an Anti-Paladin!'&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}


SPECIAL(druid_subclasser)
{
  int i = 0;
  struct obj_data *qobj1, *qobj2, *qobj3, *qobj4;
  int type;
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  type = GET_CLASS(ch);
  if((type == CLASS_DRUID) || (type == CLASS_RANGER)){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'Your path will never lead to true neutrality.  Leave this place!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of evil.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type == CLASS_CLERIC) && ((i = parse_class(ch, 'h')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'A druid you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && ((i = parse_class(ch, 'g')) == CLASS_UNDEFINED))
{
    act("&2&b$n&2&b tells you, 'A ranger you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (GET_ALIGNMENT(ch) < -300) {
    act("&2&b$n&2&b tells you, 'You have strayed to far from the path of neutrality.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj1 = get_obj_in_list_vnum(2330, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj2 = get_obj_in_list_vnum(2331, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj3 = get_obj_in_list_vnum(2332, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj4 = get_obj_in_list_vnum(2333, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj1,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj1,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj2,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj2,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj3,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj3,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj4,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj4,me,TO_ROOM);
  obj_from_char(qobj1);
  extract_obj(qobj1);
  obj_from_char(qobj2);
  extract_obj(qobj2);
  obj_from_char(qobj3);
  extract_obj(qobj3);
  obj_from_char(qobj4);
  extract_obj(qobj4);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a &4blue flame!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_CLERIC)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most natural of clerics! You are a Druid!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most naturalistic warrior! You are a Ranger!'&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

#define DQ_ROOM1 real_room(2475)
#define DQ_ROOM2 real_room(2460)
#define DQ_ROOM3 real_room(2498)
#define DQ_ROOM4 real_room(2499)

SPECIAL(druid_quest_room)
{
  int class, align, level;
  struct obj_data *obj = NULL;

  if(IS_NPC(ch) || !CMD_IS("say"))
    return FALSE;

  skip_spaces(&argument);

  class = GET_CLASS(ch);
  align = GET_ALIGNMENT(ch);
  level = GET_LEVEL(ch);

  if(strcmp(argument, "I pray for a blessing from mother earth, creator of life and bringer of death") == 0)
  {
  if((class != CLASS_CLERIC) && (class != CLASS_WARRIOR))
    return FALSE;

  if(align < 0)
    return FALSE;

  if(level < 21)
    return FALSE;

  if (ch->in_room == DQ_ROOM1)
    obj = read_object(2330, VIRTUAL);
  if (ch->in_room == DQ_ROOM2)
    obj = read_object(2331, VIRTUAL);
  if (ch->in_room == DQ_ROOM3)
    obj = read_object(2332, VIRTUAL);
  if (ch->in_room == DQ_ROOM4)
    obj = read_object(2333, VIRTUAL);

  obj_to_char(obj, ch);
  send_to_char("You recieve the blessings of Mother Earth\r\n", ch);
  }
  else
    return FALSE;
  return TRUE;
}

SPECIAL(priest_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type = CLASS_PRIEST;  /* default to priest */

  type = GET_CLASS(ch);

  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  if ((type == CLASS_PRIEST) || type == CLASS_PALADIN) {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if ((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but your path will never lead to priesthood. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the holy ways.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type == CLASS_CLERIC) && (i = parse_class(ch, 'p')) == CLASS_UNDEFINED) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but the priesthood is not for you. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && (i = parse_class(ch, 'e')) == CLASS_UNDEFINED) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but knighthood is not for you. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if (GET_ALIGNMENT(ch) < 500) {
    act("&2&b$n&2&b tells you, 'You have strayed to far from the path of righteousness. Return after you have made amends for your evil deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj = get_obj_in_list_vnum(2300, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the holy quest.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a blinding light!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_PRIEST)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the holiest of clerics! You are a Priest!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the holiest of warriors! You are a Paladin!'&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

/* pryo */

SPECIAL(pyro_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  type = GET_CLASS(ch);

  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  if (type == CLASS_PYROMANCER)
  {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if (type != CLASS_MAGIC_USER) {
    act("&2&b$n&2&b tells you, 'You cannot learn the way of the flame.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if(GET_LEVEL(ch) < 25) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of magic.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type == CLASS_MAGIC_USER) && (i = parse_class(ch, 'u')) == CLASS_UNDEFINED)
  {
    act("&2&b$n&2&b tells you, 'You will never be able to control the flames.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if (!(qobj = get_obj_in_list_vnum(101, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have captured the living flame.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
    act("&2&b$n&2&b tells you, 'Congratulations! You can now control flames and fire! You are a Pyromancer!'&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

/* necro */

SPECIAL(necro_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  type = GET_CLASS(ch);

  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  if (type == CLASS_NECROMANCER)
  {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if (type != CLASS_MAGIC_USER) {
    act("&2&b$n&2&b tells you, 'You cannot commune with the dead.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if(GET_LEVEL(ch) < 25) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of magic.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }

  if ((type == CLASS_MAGIC_USER) && (i = parse_class(ch, 'l')) == CLASS_UNDEFINED)
  {
    act("&2&b$n&2&b tells you, 'You will never be able to control the dead.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

  if (!(qobj = get_obj_in_list_vnum(3014, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the book.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
  act("&2&b$n&2&b tells you, 'Congratulations! You can now control the dead! You are a Necromancer!'&0",FALSE,me,0,ch,TO_VICT);

  return 1;
}

SPECIAL(guild)
{
  int skill_num, percent;

  extern struct spell_info_type spell_info[];
  extern struct int_app_type int_app[];

  if (IS_NPC(ch) || !CMD_IS("practice"))
    return 0;

  skip_spaces(&argument);

  if (!*argument) {
    list_skills(ch);
    return 1;
  }
  if (GET_PRACTICES(ch) <= 0) {
    send_to_char("You do not seem to be able to practice now.\r\n", ch);
    return 1;
  }

  skill_num = find_skill_num(argument);

  if (skill_num < 1 ||
      GET_LEVEL(ch) < spell_info[skill_num].min_level[(int) GET_CLASS(ch)]) {
    sprintf(buf, "You do not know of that %s.\r\n", SPLSKL(ch));
    send_to_char(buf, ch);
    return 1;
  }
  if (GET_SKILL(ch, skill_num) >= LEARNED(ch)) {
    send_to_char("You are already learned in that area.\r\n", ch);
    return 1;
  }
  send_to_char("You practice for a while...\r\n", ch);
  GET_PRACTICES(ch)--;

  percent = GET_SKILL(ch, skill_num);
  percent += MIN(MAXGAIN(ch), MAX(MINGAIN(ch), int_app[GET_INT(ch)].learn));

  SET_SKILL(ch, skill_num, MIN(LEARNED(ch), percent));

  if (GET_SKILL(ch, skill_num) >= LEARNED(ch))
    send_to_char("You are now learned in that area.\r\n", ch);

  return 1;
}



SPECIAL(dump)
{
  struct obj_data *k;
  int value = 0;

  ACMD(do_drop);
  char *fname(char *namelist);

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    extract_obj(k);
  }

  if (!CMD_IS("drop"))
    return 0;

  do_drop(ch, argument, cmd, 0);

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    value += MAX(1, MIN(50, GET_OBJ_COST(k) / 10));
    extract_obj(k);
  }

  if (value) {
    act("You are awarded for outstanding performance.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n has been awarded for being a good citizen.", TRUE, ch, 0, 0, TO_ROOM);

    if (GET_LEVEL(ch) < 3)
      gain_exp(ch, value);
    else
      GET_GOLD(ch) += value;
  }
  return 1;
}


SPECIAL(mayor)
{
  ACMD(do_gen_door);

  static char open_path[] =
  "W3a3003b33000c111d0d111Oe333333Oe22c222112212111a1S.";

  static char close_path[] =
  "W3a3003b33000c111d0d111CE333333CE22c222112212111a1S.";

  static char *path;
  static int index;
  static bool move = FALSE;

  if (!move) {
    if (time_info.hours == 6) {
      move = TRUE;
      path = open_path;
      index = 0;
    } else if (time_info.hours == 20) {
      move = TRUE;
      path = close_path;
      index = 0;
    }
  }
  if (cmd || !move || (GET_POS(ch) < POS_SLEEPING) ||
      (GET_POS(ch) == POS_FIGHTING))
    return FALSE;

  switch (path[index]) {
  case '0':
  case '1':
  case '2':
  case '3':
    perform_move(ch, path[index] - '0', 1);
    break;

  case 'W':
    GET_POS(ch) = POS_STANDING;
    act("$n awakens and groans loudly.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'S':
    GET_POS(ch) = POS_SLEEPING;
    act("$n lies down and instantly falls asleep.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'a':
    act("$n says 'Hello Honey!'", FALSE, ch, 0, 0, TO_ROOM);
    act("$n smirks.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'b':
    act("$n says 'What a view!  I must get something done about that dump!'",
	FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'c':
    act("$n says 'Vandals!  Youngsters nowadays have no respect for anything!'",
	FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'd':
    act("$n says 'Good day, citizens!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'e':
    act("$n says 'I hereby declare the bazaar open!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'E':
    act("$n says 'I hereby declare Midgaard closed!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'O':
    do_gen_door(ch, "gate", 0, SCMD_UNLOCK);
    do_gen_door(ch, "gate", 0, SCMD_OPEN);
    break;

  case 'C':
    do_gen_door(ch, "gate", 0, SCMD_CLOSE);
    do_gen_door(ch, "gate", 0, SCMD_LOCK);
    break;

  case '.':
    move = FALSE;
    break;

  }

  index++;
  return FALSE;
}


/* ********************************************************************
*  General special procedures for mobiles                             *
******************************************************************** */


void npc_steal(struct char_data * ch, struct char_data * victim)
{
  int gold;

  if (IS_NPC(victim))
    return;
  if (GET_LEVEL(victim) >= LVL_IMMORT)
    return;

  if (AWAKE(victim) && (number(0, GET_LEVEL(ch)) == 0)) {
    act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, victim, TO_VICT);
    act("$n tries to steal gold from $N.", TRUE, ch, 0, victim, TO_NOTVICT);
  } else {
    /* Steal some gold coins */
    gold = (int) ((GET_GOLD(victim) * number(1, 10)) / 100);
    if (gold > 0) {
      GET_GOLD(ch) += gold;
      GET_GOLD(victim) -= gold;
    }
  }
}


SPECIAL(snake)
{
  if (cmd)
    return FALSE;

  if (GET_POS(ch) != POS_FIGHTING)
    return FALSE;

  if (FIGHTING(ch) && (FIGHTING(ch)->in_room == ch->in_room) &&
      (number(0, 42 - GET_LEVEL(ch)) == 0)) {
    act("$n bites $N!", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("$n bites you!", 1, ch, 0, FIGHTING(ch), TO_VICT);
    call_magic(ch, FIGHTING(ch), 0, SPELL_POISON, GET_LEVEL(ch), CAST_SPELL);
    return TRUE;
  }
  return FALSE;
}


SPECIAL(thief)
{
  struct char_data *cons;

  if (cmd)
    return FALSE;

  if (GET_POS(ch) != POS_STANDING)
    return FALSE;

  for (cons = world[ch->in_room].people; cons; cons = cons->next_in_room)
    if (!IS_NPC(cons) && (GET_LEVEL(cons) < LVL_IMMORT) && (!number(0, 4))) {
      npc_steal(ch, cons);
      return TRUE;
    }
  return FALSE;
}


SPECIAL(magic_user)
{
  struct char_data *vict;

  if (cmd || GET_POS(ch) != POS_FIGHTING)
    return FALSE;

  /* pseudo-randomly choose someone in the room who is fighting me */
  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
    if (FIGHTING(vict) == ch && !number(0, 4))
      break;

  /* if I didn't pick any of those, then just slam the guy I'm fighting */
  if (vict == NULL)
    vict = FIGHTING(ch);

  if ((GET_LEVEL(ch) > 13) && (number(0, 10) == 0))
    cast_spell(ch, vict, NULL, SPELL_SLEEP);

  if ((GET_LEVEL(ch) > 7) && (number(0, 8) == 0))
    cast_spell(ch, vict, NULL, SPELL_BLINDNESS);

  if ((GET_LEVEL(ch) > 12) && (number(0, 12) == 0)) {
    if (IS_EVIL(ch))
      cast_spell(ch, vict, NULL, SPELL_ENERGY_DRAIN);
    else if (IS_GOOD(ch))
      cast_spell(ch, vict, NULL, SPELL_DISPEL_EVIL);
  }
  if (number(0, 4))
    return TRUE;

  switch (GET_LEVEL(ch)) {
  case 4:
  case 5:
    cast_spell(ch, vict, NULL, SPELL_MAGIC_MISSILE);
    break;
  case 6:
  case 7:
    cast_spell(ch, vict, NULL, SPELL_CHILL_TOUCH);
    break;
  case 8:
  case 9:
    cast_spell(ch, vict, NULL, SPELL_BURNING_HANDS);
    break;
  case 10:
  case 11:
    cast_spell(ch, vict, NULL, SPELL_SHOCKING_GRASP);
    break;
  case 12:
  case 13:
    cast_spell(ch, vict, NULL, SPELL_LIGHTNING_BOLT);
    break;
  case 14:
  case 15:
  case 16:
  case 17:
    cast_spell(ch, vict, NULL, SPELL_COLOR_SPRAY);
    break;
  default:
    cast_spell(ch, vict, NULL, SPELL_FIREBALL);
    break;
  }
  return TRUE;

}


/* ********************************************************************
*  Special procedures for mobiles                                      *
******************************************************************** */

SPECIAL(guild_guard)
{
  int i;
  extern int guild_info[][3];
  struct char_data *guard = (struct char_data *) me;
  char *buf = "The guard humiliates you, and blocks your way.\r\n";
  char *buf2 = "The guard humiliates $n, and blocks $s way.";

  if (!IS_MOVE(cmd) || IS_AFFECTED(guard, AFF_BLIND))
    return FALSE;

  if (GET_LEVEL(ch) >= LVL_IMMORT)
    return FALSE;

  for (i = 0; guild_info[i][0] != -1; i++) {
    if ((IS_NPC(ch) || GET_CLASS(ch) != guild_info[i][0]) &&
	world[ch->in_room].number == guild_info[i][1] &&
	cmd == guild_info[i][2]) {
      send_to_char(buf, ch);
      act(buf2, FALSE, ch, 0, 0, TO_ROOM);
      return TRUE;
    }
  }

  return FALSE;
}



SPECIAL(puff)
{
  ACMD(do_say);

  if (cmd)
    return (0);

  switch (number(0, 60)) {
  case 0:
    do_say(ch, "My god!  It's full of stars!", 0, 0);
    return (1);
  case 1:
    do_say(ch, "How'd all those fish get up here?", 0, 0);
    return (1);
  case 2:
    do_say(ch, "I'm a very female dragon.", 0, 0);
    return (1);
  case 3:
    do_say(ch, "I've got a peaceful, easy feeling.", 0, 0);
    return (1);
  default:
    return (0);
  }
}



SPECIAL(fido)
{

  struct obj_data *i, *temp, *next_obj;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (GET_OBJ_TYPE(i) == ITEM_CONTAINER && GET_OBJ_VAL(i, 3)) {
      act("$n savagely devours a corpse.", FALSE, ch, 0, 0, TO_ROOM);
      for (temp = i->contains; temp; temp = next_obj) {
	next_obj = temp->next_content;
	obj_from_obj(temp);
	obj_to_room(temp, ch->in_room);
      }
      extract_obj(i);
      return (TRUE);
    }
  }
  return (FALSE);
}



SPECIAL(janitor)
{
  struct obj_data *i;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (!CAN_WEAR(i, ITEM_WEAR_TAKE))
      continue;
    if (GET_OBJ_TYPE(i) != ITEM_DRINKCON && GET_OBJ_COST(i) >= 15)
      continue;
    act("$n picks up some trash.", FALSE, ch, 0, 0, TO_ROOM);
    obj_from_room(i);
    obj_to_char(i, ch);
    return TRUE;
  }

  return FALSE;
}


SPECIAL(cityguard)
{
  struct char_data *tch, *evil;
  int max_evil;

  if (cmd || !AWAKE(ch) || FIGHTING(ch))
    return FALSE;

  max_evil = 1000;
  evil = 0;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && IS_SET(PLR_FLAGS(tch), PLR_KILLER)) {
      act("$n screams 'HEY!!!  You're one of those PLAYER KILLERS!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      hit(ch, tch, TYPE_UNDEFINED);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && IS_SET(PLR_FLAGS(tch), PLR_THIEF)){
      act("$n screams 'HEY!!!  You're one of those PLAYER THIEVES!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      hit(ch, tch, TYPE_UNDEFINED);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (CAN_SEE(ch, tch) && FIGHTING(tch)) {
      if ((GET_ALIGNMENT(tch) < max_evil) &&
	  (IS_NPC(tch) || IS_NPC(FIGHTING(tch)))) {
	max_evil = GET_ALIGNMENT(tch);
	evil = tch;
      }
    }
  }

  if (evil && (GET_ALIGNMENT(FIGHTING(evil)) >= 0)) {
    act("$n screams 'PROTECT THE INNOCENT!  BANZAI!  CHARGE!  ARARARAGGGHH!'", FALSE, ch, 0, 0, TO_ROOM);
    hit(ch, evil, TYPE_UNDEFINED);
    return (TRUE);
  }
  return (FALSE);
}


void convert_coins_copper(struct char_data * ch)
{
	if (GET_CASH(ch) < 1){
	return;}
	do {
	if(GET_SILVER(ch)>0){
		GET_SILVER(ch)=(GET_SILVER(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+10);}
	if(GET_GOLD(ch)>0){
		GET_GOLD(ch)=(GET_GOLD(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+(100));}
	if(GET_PLAT(ch)>0){
		GET_PLAT(ch)=(GET_PLAT(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+(1000));}
	}while(!(GET_CASH(ch)==GET_COPPER(ch)));
return;	}
/* turning copper to coins */
void copper_to_coins(struct char_data * ch)
  /* BURU 13/12/97*/
  {       if (GET_CASH(ch) < 1){
  return;}
  do{     if (GET_COPPER(ch)>9){
                  (GET_COPPER(ch) = (GET_COPPER(ch)-(10)));
                  (GET_SILVER(ch) = (GET_SILVER(ch)+(1)));}
  }while(GET_COPPER(ch)>9);
    do {
          if(GET_SILVER(ch)>9){
                  (GET_SILVER(ch) = (GET_SILVER(ch)-(10)));
                  (GET_GOLD(ch) = (GET_GOLD(ch)+(1)));}
            }while(GET_SILVER(ch)>9);
  do{
          if(GET_GOLD(ch)>9){
                  (GET_GOLD(ch) = (GET_GOLD(ch)-(10)));
                  (GET_PLAT(ch) = (GET_PLAT(ch)+(1)));}
         }while(GET_GOLD(ch)>9);
   return;}




void money_convert(struct char_data * ch, int amount)
  /* BURU 13/12/97*/
  {  	  if (GET_CASH(ch) < 1){
	send_to_char("You don't have enough!", ch);
  return;}
	  if (amount<GET_COPPER(ch)){
		  return;}
	  do{ if(GET_SILVER(ch)>0){
			  (GET_SILVER(ch) = (GET_SILVER(ch)-(1)));
			  (GET_COPPER(ch) = (GET_COPPER(ch)+(10)));}
		  if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)>0)){
			  if(GET_COPPER(ch)<amount){
			  (GET_GOLD(ch) = (GET_GOLD(ch)-(1)));
			  (GET_SILVER(ch) = (GET_SILVER(ch)+(10)));}}
		  if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)<1)){
			  if(((GET_COPPER(ch)+GET_SILVER(ch))<amount)&&(GET_PLAT(ch)>0)){
			  (GET_PLAT(ch) = (GET_PLAT(ch)-(1)));
			  (GET_GOLD(ch) = (GET_GOLD(ch)+(10)));}}
			  }while(amount>GET_COPPER(ch));
	  return;}

#define PET_PRICE(pet) (GET_LEVEL(pet) * 300)

SPECIAL(pet_shops)
{
  char buf[MAX_STRING_LENGTH], pet_name[256];
  int pet_room, amount;
  struct char_data *pet;

  pet_room = ch->in_room + 1;

  if (CMD_IS("list")) {
    send_to_char("Available pets are:\r\n", ch);
    for (pet = world[pet_room].people; pet; pet = pet->next_in_room) {
      sprintf(buf, "%8d - %s\r\n", PET_PRICE(pet), GET_NAME(pet));
      send_to_char(buf, ch);
    }
    return (TRUE);
  } else if (CMD_IS("buy")) {

    argument = one_argument(argument, buf);
    argument = one_argument(argument, pet_name);

    if (!(pet = get_char_room(buf, pet_room))) {
      send_to_char("There is no such pet!\r\n", ch);
      return (TRUE);
    }
    if (GET_CASH(ch) < PET_PRICE(pet)) {
      send_to_char("You don't have enough gold!\r\n", ch);
      return (TRUE);
    }
amount = (GET_LEVEL(pet) * 300);
	money_convert(ch, amount);
    GET_COPPER(ch) = (GET_COPPER(ch)-PET_PRICE(pet));

    pet = read_mobile(GET_MOB_RNUM(pet), REAL);
    GET_EXP(pet) = 0;
    SET_BIT(AFF_FLAGS(pet), AFF_CHARM);

    if (*pet_name) {
      sprintf(buf, "%s %s", pet->player.name, pet_name);
      /* free(pet->player.name); don't free the prototype! */
      pet->player.name = str_dup(buf);

      sprintf(buf, "%sA small sign on a chain around the neck says 'My name is %s'\r\n",
	      pet->player.description, pet_name);
      /* free(pet->player.description); don't free the prototype! */
      pet->player.description = str_dup(buf);
    }
    char_to_room(pet, ch->in_room);
    add_follower(pet, ch);

    /* Be certain that pets can't get/carry/use/wield/wear items */
    IS_CARRYING_W(pet) = 1000;
    IS_CARRYING_N(pet) = 100;

    send_to_char("May you enjoy your pet.\r\n", ch);
    act("$n buys $N as a pet.", FALSE, ch, 0, pet, TO_ROOM);

    return 1;
  }
  /* All commands except list and buy */
  return 0;
}


/* ********************************************************************
*  Special procedures for objects                                     *
******************************************************************** */

/* part of pryo class quest Fingh */
SPECIAL(rift_portal)
{
  int class;

  if (!CMD_IS("enter") || IS_NPC(ch))
    return FALSE;

  class = GET_CLASS(ch);

  act("&9&bThe dark pentagram &0&1glows &bred &9as $n enters.&0", FALSE, ch, 0, 0, TO_ROOM);
  act("&9&bThe dark pentagram &0&1glows &bred &9as you enter.&0", FALSE, ch, 0, 0, TO_CHAR);
  if(class != CLASS_MAGIC_USER)
  {
    act("&b&3$n is thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
    act("&b&3You are thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
    alter_hit(ch, dice(50, 6), 2);
    GET_POS(ch) = POS_SITTING;
    return TRUE;
  }

  look_at_room(ch, 0);
  return FALSE;
}


/* bank redid by buru */

SPECIAL(bank)
/* bank redone by buru 19/12/97 */
{
  int amount;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];


if (CMD_IS("balance")) {
sprintf(buf, "Coins carried:   &0&b&6%d &0Platinum, &0&b&3%d &0Gold, &0%d Silver and &0&3%d &0Copper\r\n", GET_PLAT(ch), GET_GOLD(ch), GET_SILVER(ch), GET_COPPER(ch));
sprintf(buf, "%sCoins in bank:   &0&b&6%ld &0Platinum, &0&b&3%ld &0Gold, &0%ld Silver and &0&3%ld &0Copper\r\n", buf, GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
send_to_char(buf, ch);
  return 1;
}

 else if (CMD_IS("deposit")) {

 two_arguments(argument, arg1, arg2);

 if (is_number(arg1)) {
   amount = atoi(arg1);
  if(!*arg2) {
sprintf(buf, "Deposit %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
    send_to_char(buf, ch);
	return 1;
   }
 if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2)) {

 if (amount <= GET_PLAT(ch)) {

  if(amount==1) {
 sprintf(buf, "You deposit &0&b&6%s&0 platinum coin.", arg1);
  send_to_char(buf, ch);
  }else{
 sprintf(buf, "You deposit &0&b&6%s&0 platinum coins.", arg1);
 send_to_char(buf, ch);
       }
  act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_PLAT(ch) -= amount;
	   GET_BANK_PLAT(ch) += amount;
      return 1;
  }
if (GET_PLAT(ch) < amount) {
send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
    }
}
    if (!str_cmp("gold", arg2) || !str_cmp("g", arg2)){
	   if (amount <= GET_GOLD(ch)) {
		   if(amount==1){
	sprintf(buf, "You deposit &0&b&3%s&0 gold coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You deposit &0&b&3%s&0 gold coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_GOLD(ch) -= amount;
	   GET_BANK_GOLD(ch) += amount;
      return 1;
    }
    if (GET_GOLD(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
    }}
	    if (!str_cmp("silver", arg2) || !str_cmp("s", arg2)){
	   if (amount <= GET_SILVER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You deposit &0%s&0 silver coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{sprintf(buf, "You deposit &0%s&0 silver coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_SILVER(ch) -= amount;
	   GET_BANK_SILVER(ch) += amount;
      return 1;
    }
    if (GET_SILVER(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
		}}
	    if (!str_cmp("copper", arg2) || !str_cmp("c", arg2)){
	   if (amount <= GET_COPPER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You deposit &0&3%s&0 copper coin.", arg1);
		  		   send_to_char(buf, ch); }
		   else {sprintf(buf, "You deposit &0&3%s&0 copper coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_COPPER(ch) -= amount;
	   GET_BANK_COPPER(ch) += amount;
      return 1;
    }
    if (GET_COPPER(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
		}
  }}
  } else if (CMD_IS("dump"))
  {
  if (GET_CASH(ch)>0){
	send_to_char("You dump all your coins on the counter to be deposited.\r\n", ch);
    GET_BANK_PLAT(ch) += GET_PLAT(ch);
    GET_BANK_GOLD(ch) += GET_GOLD(ch);
	GET_BANK_SILVER(ch) += GET_SILVER(ch);
	GET_BANK_COPPER(ch) += GET_COPPER(ch);
	GET_PLAT(ch) -= GET_PLAT(ch);
	GET_GOLD(ch) -= GET_GOLD(ch);
	GET_SILVER(ch) -= GET_SILVER(ch);
	GET_COPPER(ch) -= GET_COPPER(ch);
	  sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
  send_to_char(buf, ch);
 return 1;
  }	  	 if (GET_CASH(ch)<1){
      send_to_char("You don't have any coins to deposit!\r\n", ch);}
  sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
  send_to_char(buf, ch);
    return 1;
}
  else if (CMD_IS("withdraw")) {
two_arguments(argument, arg1, arg2);
  if (is_number(arg1)) {
    amount = atoi(arg1);
	if(!*arg2){
		sprintf(buf, "Withdraw %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
		send_to_char(buf, ch);
	return 1;}
    if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2)){
	   if (amount <= GET_BANK_PLAT(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0&b&6%s&0 platinum coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You withdraw &0&b&6%s&0 platinum coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_PLAT(ch) += amount;
	   GET_BANK_PLAT(ch) -= amount;
      return 1;
    }
    if (GET_BANK_PLAT(ch) < amount) {
      send_to_char("You don't have that many platinum coins deposited!\r\n", ch);
      return 1;
    }}
    if (!str_cmp("gold", arg2) || !str_cmp("g", arg2)){
	   if (amount <= GET_BANK_GOLD(ch)) {
		   if(amount==1){
	sprintf(buf, "You withdraw &0&b&3%s&0 gold coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You withdraw &0&b&3%s&0 gold coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_GOLD(ch) += amount;
	   GET_BANK_GOLD(ch) -= amount;
      return 1;
    }
    if (GET_BANK_GOLD(ch) < amount) {
      send_to_char("You don't have that many gold coins deposited!\r\n", ch);
      return 1;
    }}
	    if (!str_cmp("silver", arg2) || !str_cmp("s", arg2)){
	   if (amount <= GET_BANK_SILVER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0%s&0 silver coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{sprintf(buf, "You withdraw &0%s&0 silver coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_SILVER(ch) += amount;
	   GET_BANK_SILVER(ch) -= amount;
      return 1;
    }
    if (GET_SILVER(ch) < amount) {
      send_to_char("You don't have that many silver coins deposited!\r\n", ch);
      return 1;
		}}
	    if (!str_cmp("copper", arg2) || !str_cmp("c", arg2)){
	   if (amount <= GET_BANK_COPPER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0&3%s&0 copper coin.", arg1);
		  		   send_to_char(buf, ch); }
		   else {sprintf(buf, "You withdraw &0&3%s&0 copper coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_COPPER(ch) += amount;
	   GET_BANK_COPPER(ch) -= amount;
      return 1;
    }
    if (GET_BANK_COPPER(ch) < amount) {
      send_to_char("You don't have that many copper coins deposited!\r\n", ch);
      return 1;
		}
  }}
  } else {
    return 0;
}
return 0;
}

  /* weapon_spell() function and special procedures -dak */
  void weapon_spell(char *to_ch, char *to_vict, char *to_room,
                    struct char_data *ch, struct char_data *vict,
                    struct obj_data *obj, int spl)
  {
    int level = LVL_IMPL+1, i;

    for (i=0; i<NUM_CLASSES; i++)
      if (spell_info[spl].min_level[i] < level)
        level = spell_info[spl].min_level[i];
    level = MAX(1, MIN(LVL_IMMORT-1, level));

    act(to_ch, FALSE, ch, obj, vict, TO_CHAR);
    act(to_vict, FALSE, ch, obj, vict, TO_VICT);
    act(to_room, FALSE, ch, obj, vict, TO_NOTVICT);
    call_magic(ch, vict, 0, spl, level, CAST_SPELL);
  }

  SPECIAL(holyw_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 9))
      return 0;
    if (number(1, 100) > 5)
      return 0;

    weapon_spell("&3&bYour The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade!&0",
"&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade and strikes you!&0",
"&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade to strike $N!&0",
                 ch, vict, (struct obj_data *) me, SPELL_HOLY_WORD);
    return 1;
  }

  SPECIAL(blind_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 9))
      return 0;
    if (IS_AFFECTED(vict, AFF_BLIND) || MOB_FLAGGED(vict, MOB_NOBLIND))
      return 0;

    weapon_spell("You scream, \"MIDNIGHT!\" at $N.",
                 "$n screams, \"Midnight!\" at you.",
                 "$n screams, \"Midnight!\" at $N.",
                 ch, vict, (struct obj_data *) me, SPELL_BLINDNESS);
    return 1;
  }

 SPECIAL(fullharm_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 14))
      return 0;

    weapon_spell("Your $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 onto $N!",
                 "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon you!",
                 "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon $N!.",
                 ch, vict, (struct obj_data *) me, SPELL_FULL_HARM);
    return 1;
  }

  SPECIAL(vampiric_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 14))
      return 0;

    weapon_spell("A &9&bblack haze&0 forms around your $p as your strike $N!",
                 "A &9&nblack haze&0 forms around $n's $p as $e strikes you!",
                 "A &9&nblack haze&0 forms around $n's $p as $e strikes $N.",
                 ch, vict, (struct obj_data *) me, SPELL_VAMPIRIC_BREATH);
    return 1;
  }


  SPECIAL(fireball_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 14))
      return 0;

    weapon_spell("Fire seems to shoot from your $p and roar through the air at $N!",
                 "Fire tears from $n's $p and roars through the air at you!",
                 "$n's $p comes alive with a fireball that roars towards $N.",
                 ch, vict, (struct obj_data *) me, SPELL_FIREBALL);
    return 1;
  }

  SPECIAL(lightning_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict)
      return 0;
   if(number(0, 100) < 90)
      return 0;

    weapon_spell("Your $p glows &4blue&0 and a bolt rushs through the air at $N!",
                 "$n's $p glows &4blue&0 and a bolt rushs through the air at you!",
                 "$n's $p glows &4blue&0 and a bolt rushs through the air at $N.",
                 ch, vict, (struct obj_data *) me, SPELL_LIGHTNING_BOLT);
    return 1;
  }
  SPECIAL(curse_weapon)
  {
    struct char_data *vict = FIGHTING(ch);

    if (cmd || !vict || !number(0, 11))
      return 0;
    if (IS_AFFECTED(vict, AFF_CURSE))
      return 0;

    weapon_spell("Your $p turns black for a brief moment.",
                 "$n's $p turns obsidian as it nears contact with you.",
                 "$n's $p turns black as it contacts $N.",
                 ch, vict, (struct obj_data *) me, SPELL_CURSE);
    return 1;
  }

#define NUM_ARCHERS      2              /* # of rooms archers can shoot from */
#define NUM_TARGETS      3              /* # of rooms an archer can shoot at */
#define HIT_CHANCE       30             /* accuracy 30% chance to hit */
#define ARCHER_NUM_DICE  2              /*  archer damage dice */
#define ARCHER_SIZE_DICE 5              /*  archer does 2d5 each hit */

SPECIAL(archer)
{
  struct char_data *targ;
  int i, j, k;
  int damage;

  int to_from_rooms[NUM_ARCHERS][NUM_TARGETS + 1] = {
   /* archer room     target room #1     #2       #3 */
      { 30503,              30502,        30501,     -1},   /* archer room #1 */
      { 3041,              3053,        3503,     -1}    /* room #2 */
  };

  char *mssgs[] = {
    "You feel a sharp pain in your side as an arrow finds its mark!",
    "You hear a dull thud as an arrow pierces $N!",
    "An arrow whistles by your ear, barely missing you!",
    "An arrow narrowly misses $N!"
  };

  if(cmd)
    return FALSE;

  if(GET_POS(ch) != POS_STANDING)
    return FALSE;

  for(i = 0; i < NUM_ARCHERS; i++) {
    if(real_room(to_from_rooms[i][0]) == ch->in_room) {
      for(j = 1; j <= NUM_TARGETS; j++) {
        if((k = real_room(to_from_rooms[i][j])) >= 0) {
          for(targ = world[k].people; targ; targ = targ->next_in_room) {
            if(!IS_NPC(targ) && (GET_LEVEL(targ) < LVL_IMMORT) &&
              (!number(0, 4))) {
              if(number(1, 100) <= HIT_CHANCE) {
                act(mssgs[0], 1, ch, 0, targ, TO_VICT);
                act(mssgs[1], 1, ch, 0, targ, TO_NOTVICT);
                damage = number(5, 50);
                GET_HIT(targ) -= damage + (number(1, 5));
                /*  these above numbers can be changed for different
                 *  damage levels.
                 */
                update_pos(targ);
                return TRUE;
              } else {
                act(mssgs[2], 1, ch, 0, targ, TO_VICT);
                act(mssgs[3], 1, ch, 0, targ, TO_NOTVICT);
                return TRUE;
              }
            }
          }
        }
      }
    }
  }
  return FALSE;
}

SPECIAL(invis_item)
{
 int i;
 char arg1[MAX_INPUT_LENGTH];
 struct obj_data *invis_obj = (struct obj_data *)me;
        /* cast the "me" pointer and assign it to invis_obj */
 if (invis_obj->worn_by == ch) {
        /* check to see if the person carrying the invis_obj is the character */
      if(CMD_IS("disappear")) {
      send_to_char("You slowly fade out of view.\r\n", ch);
      act("$n slowly fades out of view.\r\n", FALSE, ch, 0, 0,TO_ROOM);
      SET_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
      return (TRUE);
      }

      if (CMD_IS("appear")) {
      REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
      send_to_char("You snap into visibility.\r\n", ch);

      act("$n snaps into visibility.\r\n", FALSE, ch, 0, 0,TO_ROOM);
      return(TRUE);
      }

    one_argument(argument, arg1);

    if (is_abbrev(arg1, "magical")) {
     for (i=0; i< NUM_WEARS; i++)
     if(GET_EQ(ch,i)){
        if (IS_SET(AFF_FLAGS(ch), AFF_INVISIBLE)) {

          REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
          perform_remove(ch,i);
          send_to_char("You slowly fade into view.\r\n", ch);
          act("$n slowly fades into view.\r\n", FALSE, ch, 0, 0, TO_ROOM);
          return (TRUE);
          } else {
          perform_remove(ch, i);
          return (TRUE);
          }
     return (FALSE);
     }
  return (FALSE);
  }
 return (FALSE);
 }
return (FALSE);
}

SPECIAL(stone_item)
{
 char arg1[MAX_INPUT_LENGTH];
 struct obj_data *stone_obj = (struct obj_data *)me;

 if (IS_AFFECTED(ch, AFF_STONE_SKIN)){
	 return (FALSE);}
 if (stone_obj->worn_by == ch) {

      if(CMD_IS("stone")) {
      send_to_char("&9&bYour skin hardens and turns to stone!&0\r\n", ch);
      act("&9&b$n's skin hardens and turns to stone.&0\r\n", FALSE, ch, 0, 0,TO_ROOM);
      SET_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
      return (TRUE);
      }



    one_argument(argument, arg1);


 return (FALSE);
 }
return (FALSE);
}


SPECIAL(uklor)
{struct char_data;
 int to_room, num, tim, num2, tim2;
	num = number(1,3);
	num2 = number(0, 1000);
	tim2 = number(0, 1);
	tim=time_info.hours+tim2;
	/* SETTING DESTINATION*/
   to_room=ch->in_room-1;
/* GOOD ALIGN PROC (cure blind/poison/curse */
   if(tim==3||tim==6||tim==9||tim==12||tim==15||tim==18||tim==21||tim==0){
		 if(GET_ALIGNMENT(ch) >= 350){
 if (IS_AFFECTED(ch, AFF_BLIND)) {
	 if (num2>500){
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you can see!&0\r\n", ch);
		 affect_from_char(ch, SPELL_BLINDNESS);}}
 if (IS_AFFECTED(ch, AFF_POISON)) {
	 if (num2>800){
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you feel much better!&0\r\n", ch);
		 affect_from_char(ch, SPELL_POISON);}}
if (IS_AFFECTED(ch, AFF_CURSE)) {
	 if (num2>850){
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you feel much more comfortable!&0\r\n", ch);
		 affect_from_char(ch, SPELL_CURSE);}}
		 return 0;}

 /*EVIL align proc: throws PC out of room + damages */
		 if((GET_ALIGNMENT(ch) <= -350)&&(GET_LEVEL(ch)<LVL_IMMORT)){
act("$n&0's eyes widen in suprise as a swirl of energy throws him out of the room!\r\n", FALSE, ch, 0, 0, TO_ROOM);
    	  char_from_room(ch);
		  char_to_room(ch, to_room);
		  sprintf(buf, "&0&b&8A swirl of energy wraps around you, and tosses you out of the room!&0\r\n");
		  send_to_char(buf, ch);
		  look_at_room(ch, 1);
act("$n&0 looks like he has been THROWN as he enters through the air from the west.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		  if((num==1)||(num==2)){
		  sprintf(buf, "&0&b&8You are thrown against the wall!&0\r\n");
		  send_to_char(buf, ch);
act("$n&0 hits the wall with a powerful *THUD*.\r\n", FALSE, ch, 0, 0, TO_ROOM);
          if(num==1){
			  GET_HIT(ch)=(GET_HIT(ch)-((int)(0.2*GET_HIT(ch))));}
          if(num==2){
			  GET_HIT(ch)=(GET_HIT(ch)-((int)(0.8*GET_HIT(ch))));}}
			  return 0;}}
return 0;}


void special_update(struct char_data * ch)
 {	 if (++(ch->char_specials.timer) > 0){
	command_interpreter(ch, "z001#@@#");}}

void el_passage(struct char_data * ch)
{
	int prob, temp;
		temp = number(1, 3);
		prob = ((number(1, 100))+GET_LEVEL(ch));
				if(IS_NPC(ch)||(GET_HIT(ch)<0)){
					return;}
		do{
			if((GET_POS(ch)!=POS_SLEEPING)){
		switch (number(1, 8)){
		case 1:
		send_to_char("&0&3The earth of the wall starts forming the shape of an arm!&0\r\n", ch);
		send_to_char("&0&3The arm extends and thumps you extremely hard.&0\r\n", ch);
		send_to_char("&0&3The arm retracts and flattens into nothing.&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 2:
		send_to_char("&0&b&6The wall fires a series of tiny icy missiles at YOU!&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 3:
		send_to_char("&0&1The layer of fire condenses into a concentrated flame scorching you!&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 4:
		send_to_char("&0&4The water on the walls begins to swirl at an incredible rate.&0\r\n", ch);
		if(GET_POS(ch)>POS_SITTING){
		send_to_char("&0&4The water shoots from the wall at sufficient velocity to knock you down!&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;}
		break;
		case 5:
		send_to_char("&0&3A large clump of earth shoots out at you knocking you off balance!&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;
		break;
		case 6:
		send_to_char("&0&b&6Millions of icy fragments drop from the ceiling before you.&0\r\n", ch);
		if(GET_POS(ch)>POS_SITTING){
		send_to_char("&0You try your best, but eventually you &b&8SLIP&0 and fall!&0 &0\r\n", ch);
		GET_POS(ch)=POS_SITTING;}
		break;
		case 7:
		send_to_char("&0&1The fire dances and skips across the passageway before you.&0\r\n", ch);
		send_to_char("&0A &1fiery&0 blast knocks you backwards causing you to loose your balance.&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;
		break;
		case 8:
		send_to_char("&0&4The water forms strange and mysterious patterns on the wall before you.&0\r\n", ch);
		send_to_char("&0You are involuntarily mesmerized by the &4swirls&0 and &4swoshes.&0\r\n", ch);
		send_to_char("&0Before long your eyelids close and you drift off to sleep.&0\r\n", ch);
		GET_POS(ch)=POS_SLEEPING;}}
		if(GET_POS(ch)==POS_SLEEPING){
		send_to_char("You have terrible nightmares as your body is overtaken with *PAIN*.&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
		GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}}
	if(GET_HIT(ch)<0){
		GET_HIT(ch)=-5;
		update_pos(ch);}
	switch(number(1, 4)){
	case 1:
	if(ch->in_room == real_room(9807)){
		temp=6;}
	case 2:
	if(ch->in_room == real_room(9806)){
		temp=6;}
	case 3:
	if(ch->in_room == real_room(9805)){
		temp=6;}
	case 4:
	if(ch->in_room == real_room(9801)){
		temp=6;}}
		}while((((number(0, 10))+temp)>9)&&(GET_HIT(ch)>-1));
sprintf(buf2, "Something happens to $n but its hard to see with all this kaos!");
act(buf2, FALSE, ch, 0, 0, TO_ROOM);
return;}

	/* part of ship system. see ships.h for DOCKx values */
	SPECIAL(ship_exit)
	{
		int i = 0;
		struct obj_data *ship_obj = 0;

		if(!CMD_IS("disembark"))
			return FALSE;

		/* find out which ship the player is on */
		for(i = 0;i<NUM_SHIPS;i++)
			if(real_room(ships[i].ship_ptr->obj_flags.value[1]) == ch->in_room)
				ship_obj = ships[i].ship_ptr;

		/* the player isn't in the right room */
		if(!ship_obj)
		{
			send_to_char("You can't do that here!\r\n", ch);
			return FALSE;
		}
		else if( (ship_obj->in_room != DOCK1) &&
			(ship_obj->in_room != DOCK2) &&
			(ship_obj->in_room != DOCK3) )
		{
			send_to_char("You aren't near land!\r\n", ch);
			return FALSE;
		}
		else
		{
			/* send the message to those in ship */
			act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);

			char_from_room(ch);
			char_to_room(ch, ship_obj->in_room);

			/* send mesages to ch and those on the dock */
			act("You disembark from $p", FALSE, ch, ship_obj, 0, TO_CHAR);
			act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);
			look_at_room(ch, 0);
		}

		return FALSE;
	}

	SPECIAL(ship)
	{
		ACMD(do_look);
		struct obj_data *obj = (struct obj_data *) me;
		struct obj_data *temp_ship;
		char obj_name[MAX_STRING_LENGTH];

		if(!CMD_IS("enter"))
		return FALSE;

		argument = one_argument(argument, obj_name);

		if(!(temp_ship = get_obj_in_list_vis(ch, obj_name, world[ch->in_room].contents)))
			return FALSE;

		if (temp_ship != obj)
		   return FALSE;

		if(temp_ship->obj_flags.value[1] <= 0 || temp_ship->obj_flags.value[1] > 32000)
		{
			send_to_char("You can't enter that ship.\r\n", ch);
			return TRUE;
		}

		act("$n &1walks up the gang-plank and boards&0 $p.", FALSE, ch, temp_ship, 0, TO_ROOM);
		act("&1You walk up the gang-plank and board&0 $p.", FALSE, ch, temp_ship, 0, TO_CHAR);

		char_from_room(ch);
		char_to_room(ch, real_room(temp_ship->obj_flags.value[1]));
		look_at_room(ch, 0);

		act("$n &1climbs aboard&0 $p", FALSE, ch, temp_ship, 0, TO_ROOM);
		return TRUE;
	}

	SPECIAL(current_proc)
{

   extern const char *dirs[];
   extern struct current_info current[];
   int i, found, perm_num, new_room;

   found = FALSE;
   perm_num = 0;

   if(!cmd)
      return FALSE;


   for(i=0; current[i].room_vnum != -1;i++)
      if(ch->in_room == real_room(current[i].room_vnum)) {
         perm_num = i;
         found = TRUE;
         break;
       }

   if(found)
      if(number(0,100) < current[perm_num].percent) {
         sprintf(buf, "The strong current carries you %s!\r\n",
                   dirs[current[perm_num].direction]);
         send_to_char(buf, ch);
         sprintf(buf, "$n is taken %s by the rough current!",
                       dirs[current[perm_num].direction]);
         act(buf, FALSE, ch, 0, 0, TO_NOTVICT);

/* You can use your favorite way to record errors here. */

if(!EXIT(ch, current[perm_num].direction)) {
   send_to_char("Error in this room.  Please report this! ERROR 1\r\n", ch);
   return FALSE;
 }

if(EXIT(ch, current[perm_num].direction)->to_room == NOWHERE) {
   send_to_char("Error in this room.  Please report this! ERROR 2\r\n", ch);
   return FALSE;
  }

         /* Here we want to use char_from_room / char_to_room instead of a
do_simple_move
            because the current should take them no matter if they have a
boat, no
            movement points left, etc. */
         new_room = EXIT(ch, current[perm_num].direction)->to_room;
         char_from_room(ch);
         char_to_room(ch, new_room);
         act("$n is swept into the room by the rough current!", FALSE, ch,
0, 0, TO_NOTVICT);
       }
 return FALSE;
}

SPECIAL(clan0_guard_proc)
{
 struct char_data *clan_guard = (struct char_data *) me;

 if(!cmd)
 return FALSE;

if (!IS_MOVE(cmd))
  return FALSE;

 if (!ch || !clan_guard)
    return FALSE;

 if(!IS_NPC(ch) && GET_LEVEL(ch) >= LVL_IMMORT)
    return FALSE;

if ((clan_guard->in_room != real_room(4000)) ||
 (clan_guard->in_room == NOWHERE))
    return FALSE;

 if (cmd == SCMD_DOWN){
     if(GET_CLAN(ch) != clan[0].id || GET_CLAN_RANK(ch) < 1){
act("$n shoves $N to the ground to prevent his entry.", FALSE, clan_guard, 0, ch,
TO_NOTVICT);
sprintf(buf, "%s shoves you to the ground!\r\n", GET_NAME(clan_guard));
GET_POS(ch) = POS_SITTING;
GET_POS1(ch) = POS1_PRONE;
send_to_char(buf, ch);
return TRUE;
}else
return FALSE;
}


return FALSE;

}
@


1.103
log
@Changed lightweight baton's frequency to 20%.
@
text
@/***************************************************************************
 * $Id: spec_procs.c,v 1.102 2010/07/02 14:09:16 mud Exp mud $
 ***************************************************************************/
/***************************************************************************
 *   File: spec_procs.c                                   Part of FieryMUD *
 *  Usage: implementation of special procedures for mobiles/objects/rooms  *
 *                                                                         *
 *  All rights reserved.  See license.doc for complete information.        *
 *                                                                         *
 *  FieryMUD Copyright (C) 1998, 1999, 2000 by the Fiery Consortium        *
 *  FieryMUD is based on CircleMUD Copyright (C) 1993, 94 by the Trustees  *
 *  of the Johns Hopkins University                                        *
 *  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <math.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "casting.h"
#include "clan.h"
#include "events.h"
#include "skills.h"
#include "constants.h"
#include "math.h"
#include "limits.h"
#include "movement.h"
#include "class.h"
#include "fight.h"
#include "specprocs.h"
#include "act.h"
#include "cooldowns.h"

/* extern functions */
EVENTFUNC(recall_event);
void money_convert(struct char_data* ch, int amount);
int room_recall_check(struct char_data *ch, struct char_data *victim, struct obj_data *obj);
void apply_cost(int cost, struct char_data *ch);

int red_recall_room(struct char_data *ch);
int green_recall_room(struct char_data *ch);
int blue_recall_room(struct char_data *ch);
int gray_recall_room(struct char_data *ch);


struct social_type {
  char *cmd;
  int next_line;
};


/********************************************************************
 *              Special procedures for mobiles                      *
 ********************************************************************/

SPECIAL(guild)
{
   ACMD(do_save);

   if (IS_NPC(ch))
      return 0;


   if (CMD_IS("level")) {
      skip_spaces(&argument);

      if (!*argument)
         return 0;      /* process via the regular command */

      if (str_cmp(argument,"gain"))
         return 0;      /* process via the regular command */

      if (getbaseclass(GET_CLASS((struct char_data *)(me))) !=
            getbaseclass(GET_CLASS(ch))) {
            act("$N tells you \"I can't raise you!  Find your own guildmaster.\"",
                  FALSE, ch, 0, me, TO_CHAR);
            return TRUE;
      }

      if (GET_EXP(ch) == exp_next_level(GET_LEVEL(ch), GET_CLASS(ch)) - 1) {
         if (GET_LEVEL(ch) < LVL_MAX_MORT) {
            sprintf(buf, "$n says \"$N is ready for level %d!\"",
                  GET_LEVEL(ch) + 1);
            act(buf, FALSE, me, 0, ch, TO_ROOM);
            /* advance to the next level! */
            gain_exp(ch, 1, GAIN_IGNORE_LEVEL_BOUNDARY);
            GET_HIT(ch) = MAX(GET_HIT(ch), GET_MAX_HIT(ch));
            GET_MOVE(ch) = MAX(GET_MOVE(ch), GET_MAX_MOVE(ch));
            do_save(ch, "", 0, 0);
         } else {
            act("$N tells you \"You are as powerful as a mortal can be.\"",
                  FALSE, ch, 0, me, TO_CHAR);
         }
      } else {
         sprintf(buf,"$N tells you \"You are not ready for level %d yet.\"",
               GET_LEVEL(ch) + 1);
         act(buf, FALSE, ch, 0, me, TO_CHAR);
    }
   return TRUE;
   }

  return 0;  /* command not intercepted above (level, practice) */
}


SPECIAL(dump)
{
  struct obj_data *k;
  /*  int value = 0; */

  ACMD(do_drop);

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    extract_obj(k);
  }

  if (!CMD_IS("drop"))
    return 0;

  do_drop(ch, argument, cmd, 0);

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    /*   value += MAX(1, MIN(50, GET_OBJ_COST(k) / 10)); */
    extract_obj(k);
  }
  return 1;
}


/*******************************************************************
 *              Special procedures for mobiles                     *
 *******************************************************************/

SPECIAL(guild_guard)
{
  int i, IS_GUARDED = FALSE;
  extern int guild_info[][3];
  struct char_data *guard = (struct char_data *) me;
  char *buf = "The guard humiliates you, and blocks your way.\r\n";
  char *buf2 = "The guard humiliates $n, and blocks $s way.";

  if (!IS_MOVE(cmd) || EFF_FLAGGED(guard, EFF_BLIND))
    return FALSE;

  if (GET_LEVEL(ch) >= LVL_IMMORT)
    return FALSE;

  /* Is the direction even being guarded? */

  for (i = 0; guild_info[i][0] != -1; i++) {
    if(world[ch->in_room].vnum == guild_info[i][1] &&
       cmd == guild_info[i][2]) {
      IS_GUARDED = TRUE;
    }
  }

  if(!IS_GUARDED) {
    return FALSE;
  }

  /* Ok, it's guarded, can you class get in? */

  for (i = 0; guild_info[i][0] != -1; i++) {
    if (!IS_NPC(ch) && GET_CLASS(ch) == guild_info[i][0] &&
        world[ch->in_room].vnum == guild_info[i][1] &&
        cmd == guild_info[i][2]) {
      return FALSE;
    }
  }

  /* Ok, it's guarded and you can't get in :P and no other case
     will allow you in */

  send_to_char(buf, ch);
  act(buf2, FALSE, ch, 0, 0, TO_ROOM);
  return TRUE;
}



SPECIAL(puff)
{
  ACMD(do_say);

  if (cmd)
    return (0);

  switch (number(0, 60)) {
  case 0:
    do_say(ch, "My god!  It's full of stars!", 0, 0);
    return (1);
  case 1:
    do_say(ch, "How'd all those fish get up here?", 0, 0);
    return (1);
  case 2:
    do_say(ch, "I'm a very female dragon.", 0, 0);
    return (1);
  case 3:
    do_say(ch, "I've got a peaceful, easy feeling.", 0, 0);
    return (1);
  default:
    return (0);
  }
}



SPECIAL(janitor)
{
  struct obj_data *i;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (!CAN_WEAR(i, ITEM_WEAR_TAKE))
      continue;
    if (GET_OBJ_TYPE(i) != ITEM_DRINKCON && GET_OBJ_COST(i) >= 15)
      continue;
    act("$n picks up some trash.", FALSE, ch, 0, 0, TO_ROOM);
    obj_from_room(i);
    obj_to_char(i, ch);
    get_check_money(ch, i);
    return TRUE;
  }

  return FALSE;
}


SPECIAL(cityguard)
{
  struct char_data *tch, *evil;
  int max_evil;

  if (cmd || !AWAKE(ch) || FIGHTING(ch))
    return FALSE;

  max_evil = 1000;
  evil = 0;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && PLR_FLAGGED(tch, PLR_KILLER)) {
      act("$n screams 'HEY!!!  You're one of those PLAYER KILLERS!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      attack(ch, tch);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && PLR_FLAGGED(tch, PLR_THIEF)){
      act("$n screams 'HEY!!!  You're one of those PLAYER THIEVES!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      attack(ch, tch);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (CAN_SEE(ch, tch) && FIGHTING(tch)) {
      if ((GET_ALIGNMENT(tch) < max_evil) &&
          (IS_NPC(tch) || IS_NPC(FIGHTING(tch)))) {
        max_evil = GET_ALIGNMENT(tch);
        evil = tch;
      }
    }
  }

  if (evil && (GET_ALIGNMENT(FIGHTING(evil)) >= 0)) {
    act("$n screams 'PROTECT THE INNOCENT!  BANZAI!  CHARGE!  ARARARAGGGHH!'", FALSE, ch, 0, 0, TO_ROOM);
    attack(ch, evil);
    return (TRUE);
  }
  return (FALSE);
}


void convert_coins_copper(struct char_data * ch)
{
  if (GET_CASH(ch) < 1){
    return;}
  do {
    if(GET_SILVER(ch)>0){
      GET_SILVER(ch)=(GET_SILVER(ch)-(1));
      GET_COPPER(ch)=(GET_COPPER(ch)+10);}
    if(GET_GOLD(ch)>0){
      GET_GOLD(ch)=(GET_GOLD(ch)-(1));
      GET_COPPER(ch)=(GET_COPPER(ch)+(100));}
    if(GET_PLATINUM(ch)>0){
      GET_PLATINUM(ch)=(GET_PLATINUM(ch)-(1));
      GET_COPPER(ch)=(GET_COPPER(ch)+(1000));}
  }while(!(GET_CASH(ch)==GET_COPPER(ch)));
  return;        }

void copper_to_coins(struct char_data * ch)
{
  if (GET_CASH(ch) < 1)
    {
      return;
    }
  do
    {
      if (GET_COPPER(ch)>9)
        {
          (GET_COPPER(ch) = (GET_COPPER(ch)-(10)));
          (GET_SILVER(ch) = (GET_SILVER(ch)+(1)));
        }
    }
  while(GET_COPPER(ch)>9);
  do
    {
      if(GET_SILVER(ch)>9)
        {
          (GET_SILVER(ch) = (GET_SILVER(ch)-(10)));
          (GET_GOLD(ch) = (GET_GOLD(ch)+(1)));
        }
    }
  while(GET_SILVER(ch)>9);
  do
    {
      if(GET_GOLD(ch)>9)
        {
          (GET_GOLD(ch) = (GET_GOLD(ch)-(10)));
          (GET_PLATINUM(ch) = (GET_PLATINUM(ch)+(1)));
        }
    }
  while(GET_GOLD(ch)>9);
  return;
}


void money_convert(struct char_data * ch, int amount)
{
  if (GET_CASH(ch) < 1)
    {
      if (GET_LEVEL(ch) < 100)
         send_to_char("You don't have enough!\r\n", ch);
      else
         return;
      return;
    }
  if (amount<GET_COPPER(ch))
    {
      return;
    }
  do
    {
      if(GET_SILVER(ch)>0)
        {
          (GET_SILVER(ch) = (GET_SILVER(ch)-(1)));
          (GET_COPPER(ch) = (GET_COPPER(ch)+(10)));
        }
      if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)>0))
        {
          if(GET_COPPER(ch)<amount)
            {
              (GET_GOLD(ch) = (GET_GOLD(ch)-(1)));
              (GET_SILVER(ch) = (GET_SILVER(ch)+(10)));
            }
        }
      if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)<1))
        {
          if(((GET_COPPER(ch)+GET_SILVER(ch))<amount)&&(GET_PLATINUM(ch)>0))
            {
              (GET_PLATINUM(ch) = (GET_PLATINUM(ch)-(1)));
              (GET_GOLD(ch) = (GET_GOLD(ch)+(10)));
            }
        }
    }
  while(amount>GET_COPPER(ch));
  return;
}

#define PET_PRICE(pet) ((GET_LEVEL(pet) * GET_LEVEL(pet)) + (3 * GET_LEVEL(pet)))

SPECIAL(pet_shop)
{
  int ideal_mountlevel(struct char_data *ch);
  int mountlevel(struct char_data *ch);

  char buf[MAX_STRING_LENGTH], pet_name[256];
  int pet_room, bp, temp, temp2, temp3, temp4, mountdiff;
  struct char_data *pet;
  struct follow_type *flw;

  pet_room = ch->in_room + 1;

  if (CMD_IS("list")) {
      send_to_char("Pet                                     Cost           Ridability\r\n", ch);
      send_to_char("--------------------------------------  -------------  ----------\r\n", ch);
      for (pet = world[pet_room].people; pet; pet = pet->next_in_room) {
         mountdiff = mountlevel(pet) - ideal_mountlevel(ch);
         bp = PET_PRICE(pet);
         temp = ((int)(bp)/1000);
         temp2 = ((int)((int)(bp/100)-(temp*10)));
         temp3 = ((int)((((int)(bp/10))-(temp*100))-temp2*10));
         temp4 = ((int)((((bp)-(temp*1000))-(temp2*100))-(temp3*10)));
         sprintf(buf, "%-36s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c    %s\r\n",
            GET_NAME(pet), temp, temp2, temp3, temp4,
            !MOB_FLAGGED(pet, MOB_MOUNTABLE) ? "n/a" :
               mountdiff > MOUNT_LEVEL_FUDGE ? "impossible" :
                  mountdiff < 1 ? "good" :
                     mountdiff < 2 ? "fair" :
                     mountdiff < 4 ? "bad" :
                        "awful"
            );
         send_to_char(buf, ch);
      }
    return (TRUE);
  } else if (CMD_IS("buy")) {
    argument = one_argument(argument, buf);
    argument = one_argument(argument, pet_name);

    if (!*buf) {
      send_to_char("What do you want to buy?\r\n", ch);
      return (TRUE);
    }
    for (flw=ch->followers; flw; flw = flw->next) {
      if (EFF_FLAGGED(flw->follower, EFF_CHARM)) {
        send_to_char("You already have a pet!\r\n", ch);
        return (TRUE);
      }
    }

    if (!(pet = find_char_in_room(&world[pet_room], find_by_name(buf)))) {
      send_to_char("There is no such pet!\r\n", ch);
      return (TRUE);
    }
    if (GET_LEVEL(ch) < LVL_IMMORT) {
      if (GET_CASH(ch) < PET_PRICE(pet)) {
        send_to_char("You don't have enough money!\r\n", ch);
        return TRUE;
      }
      apply_cost(PET_PRICE(pet), ch);
    }

    pet = read_mobile(GET_MOB_RNUM(pet), REAL);
    GET_EXP(pet) = 0;
    SET_FLAG(EFF_FLAGS(pet), EFF_CHARM);

    if (*pet_name) {
      sprintf(buf, "%s %s", GET_NAMELIST(pet), pet_name);
      GET_NAMELIST(pet) = strdup(buf);

      sprintf(buf, "%sA small sign on a chain around the neck says 'My name is %s'\r\n",
          pet->player.description, pet_name);
      pet->player.description = strdup(buf);
    }
    char_to_room(pet, ch->in_room);
    add_follower(pet, ch);

    send_to_char("May you enjoy your pet.\r\n", ch);
    act("$n buys $N as a pet.", FALSE, ch, 0, pet, TO_ROOM);

    return 1;
  }
  /* All commands except list and buy */
  return 0;
}


/********************************************************************
 *                Special procedures for objects                    *
 ********************************************************************/


SPECIAL(bank)
{
  int coins[NUM_COIN_TYPES], i;

  if (CMD_IS("balance")) {
    statemoney(buf, GET_COINS(ch));
    cprintf(ch, "Coins carried:   %s\r\n", buf);
    statemoney(buf, GET_BANK_COINS(ch));
    cprintf(ch, "Coins in bank:   %s\r\n", buf);
    return TRUE;
  }

  else if (CMD_IS("deposit")) {

    if (!parse_money(&argument, coins)) {
      send_to_char("You can only deposit platinum, gold, silver, and copper coins.\r\n", ch);
      return TRUE;
    }

    for (i = 0; i < NUM_COIN_TYPES; ++i)
      if (coins[i] > GET_COINS(ch)[i]) {
        cprintf(ch, "You don't have enough %s!\r\n", COIN_NAME(i));
        return TRUE;
      }

    act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
    statemoney(buf, coins);
    cprintf(ch, "You deposit %s.\r\n", buf);

    for (i = 0; i < NUM_COIN_TYPES; ++i) {
      GET_COINS(ch)[i] -= coins[i];
      GET_BANK_COINS(ch)[i] += coins[i];
    }

    return TRUE;
  }

  else if (CMD_IS("dump")) {
    if (GET_CASH(ch) <= 0)
      send_to_char("You don't have any coins to deposit!\r\n", ch);
    else {
      send_to_char("You dump all your coins on the counter to be deposited.\r\n", ch);
      for (i = 0; i < NUM_COIN_TYPES; ++i) {
        GET_BANK_COINS(ch)[i] += GET_COINS(ch)[i];
        coins[i] = GET_COINS(ch)[i];
        GET_COINS(ch)[i] = 0;
      }
      statemoney(buf, coins);
      cprintf(ch, "You were carrying %s.\r\n", buf);
    }
    return TRUE;
  }

  else if (CMD_IS("withdraw")) {
    if (!parse_money(&argument, coins)) {
      send_to_char("You can only withdraw platinum, gold, silver, and copper coins.\r\n", ch);
      return TRUE;
    }

    for (i = 0; i < NUM_COIN_TYPES; ++i)
      if (coins[i] > GET_BANK_COINS(ch)[i]) {
        sprintf(buf, "You don't have enough %s in the bank!\r\n", COIN_NAME(i));
        send_to_char(buf, ch);
        return TRUE;
      }

    act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
    statemoney(buf, coins);
    cprintf(ch, "You withdraw %s.\r\n", buf);

    for (i = 0; i < NUM_COIN_TYPES; ++i) {
      GET_BANK_COINS(ch)[i] -= coins[i];
      GET_COINS(ch)[i] += coins[i];
    }

    return TRUE;
  }

 else if (CMD_IS("exchange"))
   {
  int amount, ok = 0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];
  char arg4[MAX_INPUT_LENGTH];
  char ctype2[10];
  double exchange_rate;
  int copper, charge;
  int multto, multfrom;
  int type1, type2;

     half_chop(argument, arg1, arg2);
     if (is_number(arg1)) {
        amount = atoi(arg1);
        if(!*arg2) {
            sprintf(buf, "Exchange %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
            send_to_char(buf, ch);
            return 1;
        }
        half_chop(arg2, arg3, arg2);
        if(!*arg3) {
            sprintf(buf, "Exchange %s to what? Platinum? Gold? Silver? Copper?\r\n", arg2);
            send_to_char(buf, ch);
            return 1;
        }
        half_chop(arg2, arg4, arg2);
        if(!*arg4) {
            sprintf(buf, "Exchange %s to what? Platinum? Gold? Silver? Copper?\r\n", arg3);
            send_to_char(buf, ch);
            return 1;
        }
        if (is_abbrev(arg3, "copper")) {
           type1 = 1;
           multfrom = 1;
        } else if (is_abbrev(arg3, "silver")) {
           type1 = 2;
           multfrom = 10;
        } else if (is_abbrev(arg3, "gold")) {
           type1 = 3;
           multfrom = 100;
        } else if (is_abbrev(arg3, "platinum")) {
           type1 = 4;
           multfrom = 1000;
        } else {
            sprintf(buf, "What kind of currency is that?\r\n");
            send_to_char(buf, ch);
            return 1;
        }
        if (is_abbrev(arg4, "copper")) {
           type2 = 1;
        } else if (is_abbrev(arg4, "silver")) {
           type2 = 2;
        } else if (is_abbrev(arg4, "gold")) {
           type2 = 3;
        } else if (is_abbrev(arg4, "platinum")) {
           type2 = 4;
        } else {
            sprintf(buf, "What kind of currency is that?\r\n");
            send_to_char(buf, ch);
            return 1;
        }

        if (type1 == type2) {
           send_to_char("That would be pointless, try using two different types of currency.\r\n", ch);
           return 1;
        }

        if (amount <= 0) {
           send_to_char("The bank doesn't make money because it's dumb! Try a positive value.\r\n",ch);
           return 1;
        }

        switch(type1) {
           case 1:
              if (GET_COPPER(ch) >= amount)
                 ok = 1;
           break;
           case 2:
              if (GET_SILVER(ch) >= amount)
                 ok = 1;
           break;
           case 3:
              if (GET_GOLD(ch) >= amount)
                 ok = 1;
           break;
           case 4:
              if (GET_PLATINUM(ch) >= amount)
                 ok = 1;
           break;
        }

        if (ok == 0) {
           send_to_char("You don't have that many coins of that type!\r\n", ch);
           return 1;
        }

        ok = 0;
        exchange_rate = ((17-(GET_CHA(ch)/6.0)+number(0,2)-(number(0,4)/10.0)+(number(0,9)/10.0))/100.0);
        amount = amount * multfrom;
        charge = (int)(ceil(exchange_rate*amount));

        switch(type2) {
           case 1:
              strcpy(ctype2, "copper");
              multto = 1;
              if ((amount/1 >= 1) && (amount%1 == 0))
                 ok = 1;
           break;
           case 2:
              strcpy(ctype2, "silver");
              multto = 10;
              if ((amount/10 >= 1) && (amount%10 == 0))
                 ok = 1;
           break;
           case 3:
              strcpy(ctype2, "gold");
              multto = 100;
              if ((amount/100 >= 1) && (amount%100 == 0))
                 ok = 1;
           break;
           case 4:
              strcpy(ctype2, "platinum");
              multto = 1000;
              if ((amount/1000 >= 1) && (amount%1000 == 0))
                 ok = 1;
           break;
           default:
              log("SYSERR: bank error: invalid type2 in spec proc");
              send_to_char("Bank error.", ch);
              return 1;
        }

        if ((ok == 0) && type2 > type1) {
           send_to_char("That's not the right multiple to convert to that type!\r\n", ch);
           return 1;
        }

        if (GET_CASH(ch) < (amount+charge)) {
           send_to_char("You don't have enough money!\r\n", ch);
           sprintf(buf, "The fee for that transaction would be %d copper.\r\n", charge);
           send_to_char(buf, ch);
           return 1;
        }

        switch(type1) {
           case 1:
              GET_COPPER(ch) -= amount/multfrom;
           break;
           case 2:
              GET_SILVER(ch) -= amount/multfrom;
           break;
           case 3:
              GET_GOLD(ch) -= amount/multfrom;
           break;
           case 4:
              GET_PLATINUM(ch) -= amount/multfrom;
           break;
        }

        money_convert(ch, charge);
        GET_COPPER(ch) -= charge;
        copper = amount/multto;
        sprintf(buf, "You receive %d %s.\r\n", copper, ctype2);
        sprintf(buf, "%sYou pay %d copper for the transaction.\r\n", buf, charge);
        send_to_char(buf, ch);

        switch(type2) {
           case 1:
              GET_COPPER(ch) += copper;
           break;
           case 2:
              GET_SILVER(ch) += copper;
           break;
           case 3:
              GET_GOLD(ch) += copper;
           break;
           case 4:
              GET_PLATINUM(ch) += copper;
           break;
        }

        return  1;
     } else {
        send_to_char("Format: exchange <quantity> <from type> <to type>\r\n        exchange 10 copper silver\r\n", ch);
        return 1;
     }
 } else
   {
     return 0;
   }
 return 0;
}

/* weapon_spell() function and special procedures -dak */
void weapon_spell(char *to_ch, char *to_vict, char *to_room,
                  struct char_data *ch, struct char_data *vict,
                  struct obj_data *obj, int spl)
{
  int level = LVL_IMPL+1, i;

  for (i=0; i<NUM_CLASSES; i++)
    if (skills[spl].min_level[i] < level)
      level = skills[spl].min_level[i];
  level = MAX(1, MIN(LVL_IMMORT-1, level));

  act(to_ch, FALSE, ch, obj, vict, TO_CHAR);
  act(to_vict, FALSE, ch, obj, vict, TO_VICT);
  act(to_room, FALSE, ch, obj, vict, TO_NOTVICT);
  call_magic(ch, vict, 0, spl, level, CAST_SPELL);
}

SPECIAL(holyw_weapon)
{
  struct char_data *vict = FIGHTING(ch);

  if (cmd || !vict || !number(0, 9))
    return 0;
  if (number(1, 100) > 5)
    return 0;

  weapon_spell("&3&bYour The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade!&0",
               "&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade and strikes you!&0",
               "&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade to strike $N!&0",
               ch, vict, (struct obj_data *) me, SPELL_HOLY_WORD);
  return 1;
}

SPECIAL(vampiric_weapon)
{
  struct char_data *vict = FIGHTING(ch);

  if (!(GET_CLASS(ch) == CLASS_ANTI_PALADIN) || cmd || !vict || number(0, 100) < 97 )
    return 0;

  weapon_spell("A &9&bblack haze&0 forms around your $p as you strike $N!",
               "A &9&bblack haze&0 forms around $n's $p as $e strikes you!",
               "A &9&bblack haze&0 forms around $n's $p as $e strikes $N.",
               ch, vict, (struct obj_data *) me, SPELL_VAMPIRIC_BREATH);
  return 1;
}


SPECIAL(fire_weapon)
{
  struct char_data *vict = FIGHTING(ch);

  if (cmd || !vict)
    return 0;
  if (number(0, 100) < 90)
    return 0;

  weapon_spell("Your $o twinkles &3brightly&0 and sends waves of &6plasma&0 into $N!",
               "$n's $o twinkles &3brightly&0 and sends waves of &6plasma&0 into you!",
               "$n's $o twinkles &3brightly&0 and sends waves of &6plasma&0 into $N!",
               ch, vict, (struct obj_data *) me, SPELL_FIREBALL);

  return 1;
}


SPECIAL(lightning_weapon)
{
  struct char_data *vict = FIGHTING(ch);

  if (cmd || !vict)
    return 0;
  if(number(0, 100) < 90)
    return 0;

  weapon_spell("Your $o glows &4blue&0 and a bolt rushes through the air at $N!",
               "$n's $o glows &4blue&0 and a bolt rushes through the air at you!",
               "$n's $o glows &4blue&0 and a bolt rushes through the air at $N.",
               ch, vict, (struct obj_data *) me, SPELL_LIGHTNING_BOLT);
  return 1;
}

SPECIAL(frost_weapon)
{
  struct char_data *vict = FIGHTING(ch);

  if (cmd || !vict)
    return 0;

  if (number(0, 100) < 80)
    return 0;

  weapon_spell("A burst of freezing air suddenly bursts from your $o!",
               "A burst of freezing air suddenly bursts from $n's $o!",
               "A burst of freezing air suddenly bursts from $n's $o!",
               ch, vict, (struct obj_data *) me, SPELL_CONE_OF_COLD);

  return 1;
}

/*
 *  This is a generic function to implement the core of the recall scripts.
 *  Additional recall types (K-town, or whatever) should be easily addable
 *  by adding additional colors and indices.
 */

int do_recall(struct char_data *ch, struct obj_data* obj, int cmd,
      char* argument, int color)
{
   char arg_1[MAX_INPUT_LENGTH];
   char target[MAX_INPUT_LENGTH];
   char* tmp;
   struct char_data* targ;
   struct recall_event_obj* recall;
   int room;
   char *color_names[] = {"red", "green", "blue", "gray"};

   if (!CMD_IS("recite")) return FALSE;

   tmp = one_argument(argument, arg_1);
   one_argument(tmp, target);

   /* Make sure the command given was "recite scroll" or "recite recall"
    * (Not sure if this is at all necessary...) */

   if (!is_abbrev(arg_1, "scroll") && !is_abbrev(arg_1, "recall") &&
         !is_abbrev(arg_1, color_names[color])) {
      return FALSE;
   }

   /* Identify the target (who will be recalled). */

   if (strlen(target) < 1) {
      targ = ch;
   } else {
      targ = find_char_in_room(&world[ch->in_room], find_vis_by_name(ch, target));
   }

   if (!strcmp(target, "self") || !str_cmp(target, "me")) {
      targ = ch;
   }

   /* Make sure the target is valid. */

   if (!targ) {
      send_to_char("You do not see that person here!\r\n", ch);
      return TRUE;
   }

   if (IS_NPC(targ)) {
      send_to_char("The guildmaster would think you funny...\r\n", ch);
      return TRUE;
   }

   if (!room_recall_check(ch, targ, obj))
      return TRUE;

   if (GET_LEVEL(targ) >= LVL_IMMORT && targ != ch) {
      send_to_char("Mortal magicks on a GOD?! Are you CRAZY?!\r\n", ch);
      return TRUE;
   }

   /* Determine the destination room. */

   room = NOWHERE;
   switch(color) {
      case 0: room = red_recall_room(targ); break;
      case 1: room = green_recall_room(targ); break;
      case 2: room = blue_recall_room(targ); break;
      case 3: room = gray_recall_room(targ); break;
   };

   if (room == NOWHERE) return TRUE;

   /* Create the event that will actually move the target in a few seconds. */

   CREATE(recall, struct recall_event_obj, 1);
   recall->ch = targ;
   recall->from_room = ch->in_room;

   recall->room = room;
   event_create(EVENT_RECALL, recall_event, recall, TRUE, &(ch->events), 8 RL_SEC);

   /* Finally, after all sanity-checking, we know the scroll is going
    * to work and that it has a proper target.  We can destroy it and
    * send out the appropriate messages. */

   send_to_char("You recite the scroll, which dissolves.\r\n",ch);

   if (targ == ch) {
      act("$n recites a scroll of recall at $mself.", FALSE, ch,
         0, targ,TO_ROOM);
   } else {
      act("$n recites a scroll of recall at YOU!", FALSE, ch,
         0, targ, TO_VICT);
      act("$n recites a scroll of recall at $N.", FALSE, ch,
         0, targ, TO_NOTVICT);
   }

   extract_obj(obj);

   return TRUE;
}

/*
 * The recalls are all done through a common function above.  It simplifies
 * things a lot, and should help out on keeping th code clean.
 */

SPECIAL(gray_recall)
{
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 3);
}
SPECIAL(blue_recall)
{
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 2);
}
SPECIAL(green_recall)
{
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 1);
}
SPECIAL(red_recall)
{
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 0);
}



int red_recall_room(struct char_data *ch)
{
  int room;
  switch(GET_CLASS(ch))
    {
    case CLASS_SORCERER: room = 6231; break;
    case CLASS_NECROMANCER: room = 6223; break;
    case CLASS_PYROMANCER: room = 6220; break;
    case CLASS_CRYOMANCER: room = 6221; break;

    case CLASS_ROGUE: room = 6068; break;
    case CLASS_THIEF: room = 6068; break;
    case CLASS_ASSASSIN: room = 6088; break;
    case CLASS_MERCENARY: room = 6170; break;


    case CLASS_CLERIC: room = 6218; break;
    case CLASS_PRIEST: room = 6218; break;
    case CLASS_DIABOLIST: room = 6075; break;
    case CLASS_DRUID: room = 6222; break;

    case CLASS_ANTI_PALADIN: room = 6080; break;

      /* Other warrior types, and anyone we missed */
    default: room = 6149; break;

    };

  if (real_room(room) == NOWHERE)
    {
      if (real_room(6001) == NOWHERE)
        {
          send_to_char("ERROR: Could not find your guild, nor the gates "
                       "of Anduin. Please tell a god!\r\n", ch);
          sprintf(buf, "ERROR: Couldn't find the real room for vnums "
                  "%i or %i", room, 6001);

          mudlog(buf, NRM, LVL_IMMORT, TRUE);
          return NOWHERE;
        };

      send_to_char("ERROR: Could not find your guild! Please tell a "
                   "god!\r\n", ch);
      return real_room(6001);
    };

  return real_room(room);
}


int green_recall_room(struct char_data *ch)
{
  int room;
  switch(GET_CLASS(ch))
    {
    case CLASS_SORCERER: room = 3046; break;
    case CLASS_NECROMANCER: room = 16932; break;
    case CLASS_PYROMANCER: room = 3094; break;
    case CLASS_CRYOMANCER: room = 3093; break;

    case CLASS_ROGUE:
    case CLASS_THIEF:
    case CLASS_ASSASSIN:
    case CLASS_MERCENARY: room = 3038; break;


      /* Do diabolists have their own guild? */
    case CLASS_DIABOLIST: room = 3003; break;
    case CLASS_CLERIC: room = 3003; break;
    case CLASS_PRIEST: room = 3095; break;
    case CLASS_DRUID: room = 3087; break;



    case CLASS_PALADIN: room = 5306; break;
    case CLASS_MONK: room = 5308; break;

    case CLASS_RANGER: room = 3550; break;

      /* Other warrior types, and anyone we missed */
    case CLASS_ANTI_PALADIN:
    default: room = 3022; break;

    };


  if (real_room(room) == NOWHERE)
    {
      if (real_room(3002) == NOWHERE)
        {
          send_to_char("ERROR: Could not find your guild, nor the Mielikki "
                       "altar. Please tell a god!\r\n", ch);
          sprintf(buf, "ERROR: Couldn't find the real room for vnums "
                  "%i or %i", room, 3002);

          mudlog(buf, NRM, LVL_IMMORT, TRUE);
          return NOWHERE;
        };

      send_to_char("ERROR: Could not find your guild! Please tell a "
                   "god!\r\n", ch);
      return real_room(3002);
    };

  return real_room(room);
}


int blue_recall_room(struct char_data *ch)
{
  int room;
  switch(GET_CLASS(ch))
    {
    case CLASS_SORCERER:
    case CLASS_NECROMANCER:
    case CLASS_PYROMANCER:
    case CLASS_CRYOMANCER: room = 10030; break;

    case CLASS_ROGUE:
    case CLASS_THIEF:
    case CLASS_ASSASSIN:
    case CLASS_MERCENARY: room = 10048; break;


    case CLASS_CLERIC:
    case CLASS_PRIEST:
    case CLASS_DIABOLIST:
    case CLASS_DRUID: room = 10003; break;

    default: room = 10013; break;

    };

  if (real_room(room) == NOWHERE)
    {
      if (real_room(10001) == NOWHERE)
        {
          send_to_char("ERROR: Could not find your guild, nor the the "
                       "Arctic Temple. Please tell a god!\r\n", ch);
          sprintf(buf, "ERROR: Couldn't find the real room for vnums "
                  "%i or %i", room, 6001);

          mudlog(buf, NRM, LVL_IMMORT, TRUE);
          return NOWHERE;
        };

      send_to_char("ERROR: Could not find your guild! Please tell a "
                   "god!\r\n", ch);
      return real_room(6001);
    };

  return real_room(room);
}

int gray_recall_room(struct char_data *ch)
{
  int room;
  switch(GET_CLASS(ch))
    {
    case CLASS_SORCERER:
    case CLASS_NECROMANCER:
    case CLASS_PYROMANCER:
    case CLASS_CRYOMANCER: room = 30073; break;

    case CLASS_ROGUE:
    case CLASS_THIEF:
    case CLASS_ASSASSIN:
    case CLASS_MERCENARY: room = 30066; break;


    case CLASS_CLERIC:
    case CLASS_PRIEST:
    case CLASS_DIABOLIST:
    case CLASS_DRUID: room = 30070; break;

    default: room = 30030; break;

    };

  if (real_room(room) == NOWHERE)
    {
      if (real_room(30030) == NOWHERE)
        {
          send_to_char("ERROR: Could not find your guild, nor the the "
                       "Ogakh itself. Please tell a god!\r\n", ch);
          sprintf(buf, "ERROR: Couldn't find the real room for vnums "
                  "%i or %i", room, 30030);

          mudlog(buf, NRM, LVL_IMMORT, TRUE);
          return NOWHERE;
        };

      send_to_char("ERROR: Could not find your guild! Please tell a "
                   "god!\r\n", ch);
      return real_room(30030);
    };

  return real_room(room);
}


SPECIAL(summon_dragon) {
  struct follow_type *fol;
  struct obj_data *item;
  extern void summon_mount(struct char_data *ch, int mob_vnum, int base_hp, int base_mv);

  if(!cmd || !CMD_IS("summon"))
    return FALSE;

  if (!ch || IS_NPC(ch))
    return FALSE;

  if (FIGHTING(ch)) {
    send_to_char("You can't concentrate enough while you are fighting.\r\n", ch);
    return TRUE;
  }

  if ((GET_CLASS(ch) != CLASS_PALADIN) && (GET_CLASS(ch) != CLASS_ANTI_PALADIN)) {
    send_to_char("You have no idea what you are trying to accomplish.\r\n", ch);
    return TRUE;
  }

  /* Must be wearing the dragon summoning item to use it */
  if ((item = (struct obj_data*) me) == NULL || item->worn_by != ch)
    return FALSE;

  /* Fewer limitations for gods */
  if (GET_LEVEL(ch) < LVL_GOD) {
    if (CH_INDOORS(ch)) {
      send_to_char("That won't work indoors!\r\n", ch);
      return TRUE;
    }

    if (GET_COOLDOWN(ch, CD_SUMMON_MOUNT)) {
      int i = GET_COOLDOWN(ch, CD_SUMMON_MOUNT) / (1 MUD_HR) + 1;
      if (i == 1)
        strcpy(buf1, "hour");
      else
        sprintf(buf1, "%d hours", i);
      cprintf(ch, "You must wait another %s before you can summon your mount.\r\n", buf1);
      return TRUE;
    }

    /* Only allow one mount */
    for (fol = ch->followers; fol; fol = fol->next)
      if (IS_NPC(fol->follower) && MOB_FLAGGED(fol->follower, MOB_MOUNTABLE)) {
        send_to_char("You already have a mount!\r\n", ch);
        return TRUE;
      }
  }

  send_to_char("You begin calling for a mount...\r\n", ch);

  if (GET_CLASS(ch) == CLASS_PALADIN)
    summon_mount(ch, 18890, 4 * GET_LEVEL(ch), GET_ALIGNMENT(ch) / 2);
  else if (GET_CLASS(ch) == CLASS_ANTI_PALADIN)
    summon_mount(ch, 18891, 4 * GET_LEVEL(ch), -(GET_ALIGNMENT(ch) / 2));
  return TRUE;
}

/***************************************************************************
 * $Log: spec_procs.c,v $
 * Revision 1.102  2010/07/02 14:09:16  mud
 * Adding cone of cold weapon.
 *
 * Revision 1.101  2010/06/05 14:56:27  mud
 * Moving cooldowns to their own file.
 *
 * Revision 1.100  2010/04/25 22:57:16  mud
 * Changing Celestial Betrayer to shoot fireballs.
 *
 * Revision 1.99  2010/04/25 22:13:38  mud
 * Adding frost weapon spec proc.
 *
 * Revision 1.98  2009/06/18 06:02:11  myc
 * Fix command reference in summon_dragon.
 *
 * Revision 1.97  2009/06/11 13:38:13  myc
 * When you level gain, you're healed to full.
 *
 * Revision 1.96  2009/06/09 19:33:50  myc
 * Rewrote gain_exp and retired gain_exp_regardless.
 *
 * Revision 1.95  2009/03/20 13:56:22  jps
 * Moved coin info into an array of struct coindef.
 *
 * Revision 1.94  2009/03/19 23:16:23  myc
 * parse_money now takes a char** and moves the pointer up to
 * just past any money phrase it parses.
 *
 * Revision 1.93  2009/03/09 21:43:50  myc
 * Change statemoney from strcat to strcpy semantics.
 *
 * Revision 1.92  2009/03/09 20:36:00  myc
 * Renamed all *PLAT macros to *PLATINUM.
 *
 * Revision 1.91  2009/03/09 04:33:20  jps
 * Moved direction information from structs.h, constants.h, and constants.c
 * into directions.h and directions.c.
 *
 * Revision 1.90  2009/03/08 23:34:14  jps
 * Renamed spells.[ch] to casting.
 *
 * Revision 1.89  2009/03/03 19:43:44  myc
 * New target finding mechanism in find.c.
 *
 * Revision 1.88  2009/01/19 09:25:23  myc
 * Changed summon mount cooldown to count 12 hours from time
 * mount is lost.
 *
 * Revision 1.87  2009/01/17 00:28:02  myc
 * Fix possible use of uninitialized variable.
 *
 * Revision 1.86  2008/09/20 07:51:45  jps
 * Don't charge immortals money in shops.
 *
 * Revision 1.85  2008/09/20 07:25:50  jps
 * Including fight.h since fight.c-related header material was move from
 * handler.h to fight.h.
 *
 * Revision 1.84  2008/09/09 08:23:37  jps
 * Placed sector info into a struct and moved its macros into rooms.h.
 *
 * Revision 1.83  2008/09/07 20:05:27  jps
 * Renamed exp_to_level to exp_next_level to make it clearer what it means.
 *
 * Revision 1.82  2008/09/02 06:56:39  jps
 * Updated header file use
 *
 * Revision 1.81  2008/08/29 16:55:00  myc
 * room_recall_check now asks for a target char too.
 *
 * Revision 1.80  2008/08/18 01:35:38  jps
 * Replaced all \\n\\r with \\r\\n, not that it was really necessary...
 *
 * Revision 1.79  2008/05/18 05:39:59  jps
 * Changed room_data member number to "vnum".
 *
 * Revision 1.78  2008/04/04 06:12:52  myc
 * Removed several old spec procs.
 *
 * Revision 1.77  2008/03/28 17:54:53  myc
 * Now using flagvectors for effect, mob, player, preference, room, and
 * room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
 *
 * Revision 1.76  2008/03/09 06:38:37  jps
 * Replaced name with namelist in struct char_data.player. GET_NAME macro
 * now points to short_descr. The uses of these strings is the same for
 * NPCs and players.
 *
 * Revision 1.75  2008/03/07 21:21:57  myc
 * Replaced action delays and skill delays with a single list of
 * 'cooldowns', which are decremented by a recurring event and
 * also save to the player file.
 *
 * Revision 1.74  2008/03/05 05:21:56  myc
 * Bank coins are ints instead of longs now.
 *
 * Revision 1.73  2008/02/09 21:07:50  myc
 * Must provide a boolean to event_create saying whether to
 * free the event obj when done or not.
 *
 * Revision 1.72  2008/02/09 18:29:11  myc
 * Typo in recall scrolls (extra newline).  Allow immortals to use
 * recall scrolls on themselves.
 *
 * Revision 1.71  2008/02/09 04:27:47  myc
 * Now relying on math header file.
 *
 * Revision 1.70  2008/02/09 03:06:17  myc
 * Was incorrectly including math.h.
 *
 * Revision 1.69  2008/01/29 21:02:31  myc
 * Removing a lot of extern declarations from code files and moving
 * them to header files, mostly db.h and constants.h.
 *
 * Revision 1.68  2008/01/27 21:14:59  myc
 * Replace hit() with attack().
 *
 * Revision 1.67  2008/01/26 14:26:31  jps
 * Moved a lot of skill-related code into skills.h and skills.c.
 *
 * Revision 1.66  2008/01/23 02:34:43  jps
 * Lose unused variables.
 *
 * Revision 1.65  2008/01/23 02:33:26  jps
 * Fix payment for pets.
 *
 * Revision 1.64  2008/01/18 20:30:11  myc
 * Fixing some send_to_char strings that don't end with a newline.
 *
 * Revision 1.63  2008/01/05 05:44:45  jps
 * Removing unused function prototypes.
 *
 * Revision 1.62  2008/01/04 01:42:50  jps
 * Removed unused practice code.
 *
 * Revision 1.61  2008/01/03 12:44:03  jps
 * Created an array of structs for class information. Renamed CLASS_MAGIC_USER
 * to CLASS_SORCERER.
 *
 * Revision 1.60  2008/01/02 02:10:34  jps
 * Removed unused external function definitions.
 *
 * Revision 1.59  2008/01/02 01:04:26  jps
 * Removing unused external function clear_skills().
 *
 * Revision 1.58  2007/12/25 05:41:49  jps
 * Updated event code so the each event type is positively identified.
 * Events may be tied to objects or characters so that when that object
 * or character is extracted, its events can be canceled.
 *
 * Revision 1.57  2007/12/19 20:55:56  myc
 * Getting rid of a defunct spec proc for a defunct clan.
 *
 * Revision 1.56  2007/10/11 20:14:48  myc
 * Changed skill defines to support chants and songs as skills, but
 * slightly distinguished from spells and skills.  TOP_SKILL is the
 * old MAX_SKILLS.
 *
 * Revision 1.55  2007/09/12 19:23:04  myc
 * Shop keepers give correct response when 'buy' is typed without arguments.
 * Shop keepers won't throw up on you anymore.
 *
 * Revision 1.54  2007/08/23 00:58:13  jps
 * Pet shops will indicate how easy it is for you to ride a mount
 * in the "list" so you can avoid buying impossible mounts.
 *
 * Revision 1.53  2007/08/16 11:54:19  jps
 * Remove defunct specprocs, such as hardcoded subclass quests, and others.
 *
 * Revision 1.52  2007/08/03 22:00:11  myc
 * Fixed some \r\n typoes in send_to_chars.
 *
 * Revision 1.51  2007/07/14 02:16:22  jps
 * Stop calculating mv points of pets here, because it's now
 * handled in db.c.
 *
 * Revision 1.50  2007/05/29 20:16:32  jps
 * Abstracted getting base class.
 *
 * Revision 1.49  2007/05/29 19:45:25  jps
 * Disable same-class-only level gains for now.
 *
 * Revision 1.48  2007/05/28 23:22:14  jps
 * You can only level gain by your own guildmaster.
 *
 * Revision 1.47  2007/04/11 16:05:27  jps
 * Scavengers who pick up money won't end up with the money pile object in inventory.
 *
 * Revision 1.46  2007/04/11 14:18:12  jps
 * Don't have to hold recalls.
 *
 * Revision 1.45  2007/04/04 13:40:12  jps
 * Implement NORECALL flag for rooms.
 *
 * Revision 1.44  2007/03/27 04:27:05  myc
 * Dragonmount special proc.  Fixed typo in stone dagger proc.
 *
 * Revision 1.43  2006/11/20 03:47:24  jps
 * Make petstore list like other store lists.
 *
 * Revision 1.42  2006/11/11 23:52:32  jps
 * Change Ogakh scroll spelling to "gray"
 *
 * Revision 1.41  2006/11/08 09:16:04  jps
 * Fixed some loose-lose typos.
 *
 * Revision 1.40  2006/10/07 02:09:23  dce
 * Fixed typo in grey recall that sent players to blue recall locations.
 *
 * Revision 1.39  2006/10/06 01:54:48  dce
 * Added spec_procs for Ogakh and associated grey recall.
 *
 * Revision 1.38  2006/07/24 21:45:41  cjd
 * Added check in recall scrolls for immortals and "self"
 *
 * Revision 1.37  2005/07/13 21:39:28  cjd
 * commented the recall scroll fail code.
 *
 * Revision 1.36  2003/10/13 06:14:00  jjl
 * Fixed rangers and anti-paladins for green recalls.
 *
 * Revision 1.35  2002/11/09 19:18:27  jjl
 * Moved a NULL check to be BEFORE something that used the variable.  It was
 * causing crashes if you targetted someone who wasn't there.
 *
 * Revision 1.34  2002/10/19 19:14:02  jjl
 * DUH
 * I feel like such an idiot
 * I had left a return real_room(3001) from testing in.  Blue recalls are fixed
 * now.
 *
 * Revision 1.30  2002/10/19 18:29:52  jjl
 * New and improved red green and blue scrolls of recall. Yummy!
 *
 * Revision 1.29  2002/09/13 02:32:10  jjl
 * Updated header comments
 *
 * Revision 1.28  2001/03/14 00:19:07  dce
 * Pet price increased.
 *
 * Revision 1.27  2001/01/06 22:02:55  rsd
 * Altered the guild guard proc to work for when builders
 * don't listen to you and add multiple classes for the
 * same direction in a guild entrance. Mutha fukas
 *
 * Revision 1.26  2000/11/25 02:33:15  rsd
 * Altered comment header and added back rlog messages
 * from prior to the addition of the $log$ string.
 *
 * Revision 1.25  2000/11/03 17:28:33  jimmy
 * Added better checks for real_room to stop players/objs from
 * being placed in room NOWHERE.  This should help pinpoint any
 * weirdness.
 *
 * Revision 1.24  2000/10/21 12:08:09  mtp
 * subclasser has been removed...
 *
 * Revision 1.23  2000/10/15 05:20:41  cmc
 * oops.. compiler warning corrected!
 *
 * Revision 1.22  2000/10/15 05:19:47  cmc
 * commented out guildmaster gossip
 * (by request)
 *
 * Revision 1.21  2000/10/13 17:55:52  cmc
 * why oh why did the guild() procedure still exist if it
 * wasn't being used anymore? and the only command it was
 * intercepting was practice, which no longer exists... sheesh!
 *
 * guild() modified for "level gain" code, now functional,
 * but further tweaks may be forthcoming in the near future.
 *
 * Happy Friday the 13th!
 *
 * Revision 1.20  2000/09/19 21:38:58  rsd
 * Metamorpho coded the for loop that checks to see if a
 * player already has a pet and prevents them from purchasing
 * more than one.  I just typed it in.
 *
 * Revision 1.19  2000/09/18 02:52:43  rsd
 * tweaked cost of pets
 *
 * Revision 1.17  2000/03/16 21:58:27  rsd
 * Altered weapon proc so that if hasted, not proper class, and
 * at limit of HP then it won't go off.
 *
 * Revision 1.16  2000/03/06 06:59:55  rsd
 * fixed the BoP guild areas guild guard
 *
 * Revision 1.15  2000/03/05 02:33:30  rsd
 * more grammar and ansi fixes
 * ,
 *
 * Revision 1.14  2000/03/05 01:26:34  rsd
 * fixed grammar in dispel_good weapon proc as well as changed the frequency
 *
 * Revision 1.13  2000/03/04 21:54:31  mud
 * altered the frequency of the vamp weapon proc
 *
 * Revision 1.12  2000/03/04 21:25:53  rsd
 * Altered the frequency at which the vamp weapon proc will
 * go off. Fixed a typo in the procs output. Added w/o
 * success the SPECIAL(dispel_good_weapon) proc.
 *
 * Revision 1.11  1999/11/16 00:18:51  rsd
 * altered the clan0 guild guard spec proc to match the current
 * clan zero.
 *
 * Revision 1.10  1999/10/30 16:03:05  rsd
 * Jimmy coded alignment restrictions for Paladins and exp.
 * Altered gain_exp() to check for a victim.
 *
 * Revision 1.9  1999/09/05 07:00:39  jimmy
 * Added RCS Log and Id strings to each source file
 *
 * Revision 1.8  1999/08/24 03:05:35  mud
 * commented out sections of dump that gave exp and money to players
 * for dropping stuff.
 *
 * Revision 1.7  1999/07/24 20:50:18  dce
 * Exchange command for banks added.
 *
 * Revision 1.6  1999/07/07 16:49:04  mud
 * added the quest obect for diabs and antis
 *
 * Revision 1.5  1999/04/30 19:12:56  dce
 * Free mail for gods
 *
 * Revision 1.4  1999/04/24 03:07:01  jimmy
 * fixed errors related to adding the pendantic compiler flag
 * -gurlaek
 *
 * Revision 1.3  1999/04/24 02:12:56  dce
 * Fixed warning messages
 *
 * Revision 1.2  1999/02/02 16:15:46  mud
 * dos2unix
 * indented entire file after putting all {}'s
 * on lines by themselves.
 *
 * Revision 1.1  1999/01/29 01:23:32  mud
 * Initial revision
 *
 ***************************************************************************/
@


1.102
log
@Adding cone of cold weapon.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.101 2010/06/05 14:56:27 mud Exp mud $
d837 1
a837 1
  if (number(0, 100) < 90)
d1238 3
@


1.101
log
@Moving cooldowns to their own file.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.100 2010/04/25 22:57:16 mud Exp mud $
d830 18
d1238 3
@


1.100
log
@Changing Celestial Betrayer to shoot fireballs.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.99 2010/04/25 22:13:38 mud Exp mud $
d38 1
a38 1

d1220 3
@


1.99
log
@Adding frost weapon spec proc.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.98 2009/06/18 06:02:11 myc Exp mud $
d796 1
a796 1
SPECIAL(frost_weapon)
d802 1
a802 1
  if (number(0, 100) < 80)
d805 4
a808 4
  weapon_spell("Your $o twinkles &3brightly&0 and sends waves of &6cold&0 into $N!",
               "$n's $o twinkles &3brightly&0 and sends waves of &6cold&0 into you!",
               "$n's $o twinkles &3brightly&0 and sends waves of &6cold&0 into $N!",
               ch, vict, (struct obj_data *) me, SPELL_CHILL_TOUCH);
d1220 3
@


1.98
log
@Fix command reference in summon_dragon.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.97 2009/06/11 13:38:13 myc Exp myc $
d796 18
d1220 3
@


1.97
log
@When you level gain, you're healed to full.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.96 2009/06/09 19:33:50 myc Exp myc $
d1146 1
a1146 1
  if(!cmd || !CMD_IS("summon mount"))
d1202 3
@


1.96
log
@Rewrote gain_exp and retired gain_exp_regardless.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.95 2009/03/20 13:56:22 jps Exp myc $
d93 2
d1202 3
@


1.95
log
@Moved coin info into an array of struct coindef.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.94 2009/03/19 23:16:23 myc Exp jps $
d86 1
a86 1
      if (GET_EXP(ch) == ((exp_next_level(GET_LEVEL(ch), GET_CLASS(ch)))) - 1) {
a90 5
            /* comment out, but retain, gossip code! */ /*
            sprintf(guild_scratch,"%s has achieved level %d!",
                  GET_NAME(ch),GET_LEVEL(ch)+1);
            do_gen_comm(me,guild_scratch,0,SCMD_GOSSIP);
            */
d92 1
a92 1
            gain_exp_regardless(ch, 1);
d1200 3
@


1.94
log
@parse_money now takes a char** and moves the pointer up to
just past any money phrase it parses.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.93 2009/03/09 21:43:50 myc Exp myc $
d498 1
a498 1
        cprintf(ch, "You don't have enough %s!\r\n", coin_names[i]);
d538 1
a538 1
        sprintf(buf, "You don't have enough %s in the bank!\r\n", coin_names[i]);
d1205 4
@


1.93
log
@Change statemoney from strcat to strcpy semantics.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.92 2009/03/09 20:36:00 myc Exp myc $
d37 1
a43 1
void get_check_money(struct char_data * ch, struct obj_data * obj);
d491 1
a491 1
    if (!parse_money(argument, coins)) {
d531 1
a531 1
    if (!parse_money(argument, coins)) {
d1205 3
@


1.92
log
@Renamed all *PLAT macros to *PLATINUM.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.91 2009/03/09 04:33:20 jps Exp myc $
a481 1
    strcpy(buf, "Coins carried:   ");
d483 1
a483 2
    send_to_char(buf, ch);
    strcpy(buf, "Coins in bank:   ");
d485 1
a485 1
    send_to_char(buf, ch);
a502 1
    strcpy(buf, "You deposit");
d504 1
a504 1
    send_to_char(strcat(buf, ".\r\n"), ch);
a523 1
      strcpy(buf, "You were carrying");
d525 1
a525 1
      send_to_char(strcat(buf, ".\r\n"), ch);
a543 1
    strcpy(buf, "You withdraw");
d545 1
a545 1
    send_to_char(strcat(buf, ".\r\n"), ch);
d1205 3
@


1.91
log
@Moved direction information from structs.h, constants.h, and constants.c
into directions.h and directions.c.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.90 2009/03/08 23:34:14 jps Exp jps $
d299 2
a300 2
    if(GET_PLAT(ch)>0){
      GET_PLAT(ch)=(GET_PLAT(ch)-(1));
d334 1
a334 1
          (GET_PLAT(ch) = (GET_PLAT(ch)+(1)));
d373 1
a373 1
          if(((GET_COPPER(ch)+GET_SILVER(ch))<amount)&&(GET_PLAT(ch)>0))
d375 1
a375 1
              (GET_PLAT(ch) = (GET_PLAT(ch)-(1)));
d648 1
a648 1
              if (GET_PLAT(ch) >= amount)
d717 1
a717 1
              GET_PLAT(ch) -= amount/multfrom;
d739 1
a739 1
              GET_PLAT(ch) += copper;
d1210 4
@


1.90
log
@Renamed spells.[ch] to casting.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.89 2009/03/03 19:43:44 myc Exp jps $
d36 1
d1210 3
@


1.89
log
@New target finding mechanism in find.c.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.88 2009/01/19 09:25:23 myc Exp myc $
d26 1
a26 1
#include "spells.h"
d1209 3
@


1.88
log
@Changed summon mount cooldown to count 12 hours from time
mount is lost.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.87 2009/01/17 00:28:02 myc Exp myc $
d434 1
a434 1
    if (!(pet = get_char_room(buf, pet_room))) {
d499 1
a499 2
        sprintf(buf, "You don't have enough %s!\r\n", coin_names[i]);
        send_to_char(buf, ch);
d854 1
a854 1
      targ = get_char_room(target, (ch->in_room));
d1209 4
@


1.87
log
@Fix possible use of uninitialized variable.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.86 2008/09/20 07:51:45 jps Exp myc $
d1182 6
a1187 1
      send_to_char("You may only summon one mount per week!\r\n", ch);
a1196 3

    /* Set the summon mount timer */
    SET_COOLDOWN(ch, CD_SUMMON_MOUNT, 7 * SECS_PER_MUD_DAY RL_SEC);
d1210 3
@


1.86
log
@Don't charge immortals money in shops.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.85 2008/09/20 07:25:50 jps Exp jps $
d688 4
d1208 3
@


1.85
log
@Including fight.h since fight.c-related header material was move from
handler.h to fight.h.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.84 2008/09/09 08:23:37 jps Exp jps $
d438 6
a443 3
    if (GET_CASH(ch) < PET_PRICE(pet)) {
      send_to_char("You don't have enough money!\r\n", ch);
      return (TRUE);
a444 1
    apply_cost(PET_PRICE(pet), ch);
d1204 4
@


1.84
log
@Placed sector info into a struct and moved its macros into rooms.h.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.83 2008/09/07 20:05:27 jps Exp jps $
d35 1
d1202 3
@


1.83
log
@Renamed exp_to_level to exp_next_level to make it clearer what it means.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.82 2008/09/02 06:56:39 jps Exp jps $
d1169 1
a1169 1
    if (!OUTSIDE(ch)) {
d1201 3
@


1.82
log
@Updated header file use
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.81 2008/08/29 16:55:00 myc Exp jps $
d84 1
a84 1
      if (GET_EXP(ch) == ((exp_to_level(GET_LEVEL(ch), GET_CLASS(ch)))) - 1) {
d1201 3
@


1.81
log
@room_recall_check now asks for a target char too.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.80 2008/08/18 01:35:38 jps Exp myc $
d32 3
a38 3
void add_follower(struct char_data * ch, struct char_data * leader);
void perform_remove(struct char_data * ch, int pos);
struct obj_data *get_obj_in_list_vnum(int num, struct obj_data * list);
a39 1
long exp_to_level(int, int);
a41 1
int getbaseclass(int class);
d1201 3
@


1.80
log
@Replaced all \\n\\r with \\r\\n, not that it was really necessary...
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.79 2008/05/18 05:39:59 jps Exp jps $
d41 1
a41 1
int room_recall_check(struct char_data *ch, struct obj_data *obj);
d869 1
a869 1
   if (!room_recall_check(ch, obj))
d1203 3
@


1.79
log
@Changed room_data member number to "vnum".
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.78 2008/04/04 06:12:52 myc Exp jps $
d399 2
a400 2
      send_to_char("Pet                                     Cost           Ridability\n\r", ch);
      send_to_char("--------------------------------------  -------------  ----------\n\r", ch);
d408 1
a408 1
         sprintf(buf, "%-36s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c    %s\n\r",
d1203 3
@


1.78
log
@Removed several old spec procs.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.77 2008/03/28 17:54:53 myc Exp myc $
d72 1
a72 1
  
d119 1
a119 1
  
d121 1
a121 1
  
d126 1
a126 1
  
d129 1
a129 1
  
d131 1
a131 1
  
d155 1
a155 1
  
d159 1
a159 1
  /* Is the direction even being guarded? */	
d162 1
a162 1
    if(world[ch->in_room].number == guild_info[i][1] &&
d167 1
a167 1
  
d176 2
a177 2
	world[ch->in_room].number == guild_info[i][1] &&
	cmd == guild_info[i][2]) {
d187 1
a187 1
  return TRUE;  
d195 1
a195 1
  
d198 1
a198 1
  
d222 1
a222 1
  
d225 1
a225 1
  
d246 1
a246 1
  
d249 1
a249 1
  
d252 1
a252 1
  
d260 1
a260 1
  
d268 1
a268 1
  
d272 3
a274 3
	  (IS_NPC(tch) || IS_NPC(FIGHTING(tch)))) {
	max_evil = GET_ALIGNMENT(tch);
	evil = tch;
d278 1
a278 1
  
d303 1
a303 1
  return;	}
d306 1
a306 1
{       
d312 1
a312 1
    {     
d314 4
a317 4
	{
	  (GET_COPPER(ch) = (GET_COPPER(ch)-(10)));
	  (GET_SILVER(ch) = (GET_SILVER(ch)+(1)));
	}
d320 1
a320 1
  do 
d323 4
a326 4
	{
	  (GET_SILVER(ch) = (GET_SILVER(ch)-(10)));
	  (GET_GOLD(ch) = (GET_GOLD(ch)+(1)));
	}
d332 4
a335 4
	{
	  (GET_GOLD(ch) = (GET_GOLD(ch)-(10)));
	  (GET_PLAT(ch) = (GET_PLAT(ch)+(1)));
	}
d343 1
a343 1
{  	  
d357 1
a357 1
    { 
d359 4
a362 4
	{
	  (GET_SILVER(ch) = (GET_SILVER(ch)-(1)));
	  (GET_COPPER(ch) = (GET_COPPER(ch)+(10)));
	}
d364 7
a370 7
	{
	  if(GET_COPPER(ch)<amount)
	    {
	      (GET_GOLD(ch) = (GET_GOLD(ch)-(1)));
	      (GET_SILVER(ch) = (GET_SILVER(ch)+(10)));
	    }
	}
d372 7
a378 7
	{
	  if(((GET_COPPER(ch)+GET_SILVER(ch))<amount)&&(GET_PLAT(ch)>0))
	    {
	      (GET_PLAT(ch) = (GET_PLAT(ch)-(1)));
	      (GET_GOLD(ch) = (GET_GOLD(ch)+(10)));
	    }
	}
d395 1
a395 1
  
d397 1
a397 1
  
d423 1
a423 1
    
d430 2
a431 2
	send_to_char("You already have a pet!\r\n", ch);
	return (TRUE);
d557 1
a557 1
  } 
d559 1
a559 1
 else if (CMD_IS("exchange")) 
d574 6
a579 6
	amount = atoi(arg1);
	if(!*arg2) {
	    sprintf(buf, "Exchange %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
	    send_to_char(buf, ch);
	    return 1;
	}
d581 5
a585 5
	if(!*arg3) {
	    sprintf(buf, "Exchange %s to what? Platinum? Gold? Silver? Copper?\r\n", arg2);
	    send_to_char(buf, ch);
	    return 1;
	}
d587 5
a591 5
	if(!*arg4) {
	    sprintf(buf, "Exchange %s to what? Platinum? Gold? Silver? Copper?\r\n", arg3);
	    send_to_char(buf, ch);
	    return 1;
	}
d661 1
a661 1
        
d743 1
a743 1
 } else 
d752 2
a753 2
		  struct char_data *ch, struct char_data *vict, 
		  struct obj_data *obj, int spl)
d756 1
a756 1
  
d761 1
a761 1
  
d771 1
a771 1
  
d776 1
a776 1
  
d778 3
a780 3
	       "&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade and strikes you!&0",
	       "&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade to strike $N!&0",
	       ch, vict, (struct obj_data *) me, SPELL_HOLY_WORD);
d792 3
a794 3
	       "A &9&bblack haze&0 forms around $n's $p as $e strikes you!",
	       "A &9&bblack haze&0 forms around $n's $p as $e strikes $N.",
	       ch, vict, (struct obj_data *) me, SPELL_VAMPIRIC_BREATH);
d802 1
a802 1
  
d807 1
a807 1
  
d809 3
a811 3
	       "$n's $o glows &4blue&0 and a bolt rushes through the air at you!",
	       "$n's $o glows &4blue&0 and a bolt rushes through the air at $N.",
	       ch, vict, (struct obj_data *) me, SPELL_LIGHTNING_BOLT);
d816 1
a816 1
 *  This is a generic function to implement the core of the recall scripts. 
d818 1
a818 1
 *  by adding additional colors and indices. 
d821 1
a821 1
int do_recall(struct char_data *ch, struct obj_data* obj, int cmd, 
d825 4
a828 4
   char target[MAX_INPUT_LENGTH]; 
   char* tmp; 
   struct char_data* targ; 
   struct recall_event_obj* recall; 
d830 1
a830 1
   char *color_names[] = {"red", "green", "blue", "gray"}; 
d832 1
a832 1
   if (!CMD_IS("recite")) return FALSE; 
d835 1
a835 1
   one_argument(tmp, target); 
d840 1
a840 1
   if (!is_abbrev(arg_1, "scroll") && !is_abbrev(arg_1, "recall") && 
d848 1
a848 1
      targ = ch; 
d850 1
a850 1
      targ = get_char_room(target, (ch->in_room)); 
d852 1
a852 1
  
d855 1
a855 1
   } 
d860 2
a861 2
      send_to_char("You do not see that person here!\r\n", ch); 
      return TRUE; 
d865 2
a866 2
      send_to_char("The guildmaster would think you funny...\r\n", ch); 
      return TRUE; 
d892 2
a893 2
   recall->ch = targ; 
   recall->from_room = ch->in_room; 
d895 2
a896 2
   recall->room = room; 
   event_create(EVENT_RECALL, recall_event, recall, TRUE, &(ch->events), 8 RL_SEC); 
d902 1
a902 1
   send_to_char("You recite the scroll, which dissolves.\r\n",ch); 
d905 1
a905 1
      act("$n recites a scroll of recall at $mself.", FALSE, ch, 
d908 4
a911 4
      act("$n recites a scroll of recall at YOU!", FALSE, ch, 
         0, targ, TO_VICT); 
      act("$n recites a scroll of recall at $N.", FALSE, ch, 
         0, targ, TO_NOTVICT); 
d914 1
a914 1
   extract_obj(obj); 
d919 1
a919 1
/* 
d921 1
a921 1
 * things a lot, and should help out on keeping th code clean. 
d926 1
a926 1
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 3); 
d930 1
a930 1
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 2); 
d934 1
a934 1
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 1); 
d938 1
a938 1
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 0); 
d943 1
a943 1
int red_recall_room(struct char_data *ch) 
d945 1
a945 1
  int room; 
d949 12
a960 12
    case CLASS_NECROMANCER: room = 6223; break; 
    case CLASS_PYROMANCER: room = 6220; break; 
    case CLASS_CRYOMANCER: room = 6221; break; 
      
    case CLASS_ROGUE: room = 6068; break; 
    case CLASS_THIEF: room = 6068; break; 
    case CLASS_ASSASSIN: room = 6088; break;      
    case CLASS_MERCENARY: room = 6170; break; 
      
	  
    case CLASS_CLERIC: room = 6218; break;        
    case CLASS_PRIEST: room = 6218; break; 
d962 4
a965 4
    case CLASS_DRUID: room = 6222; break;     
      
    case CLASS_ANTI_PALADIN: room = 6080; break; 
      
d967 2
a968 2
    default: room = 6149; break; 
      
d970 1
a970 1
  
d974 10
a983 10
	{
	  send_to_char("ERROR: Could not find your guild, nor the gates "
		       "of Anduin. Please tell a god!\r\n", ch); 
	  sprintf(buf, "ERROR: Couldn't find the real room for vnums "
		  "%i or %i", room, 6001); 
	  
	  mudlog(buf, NRM, LVL_IMMORT, TRUE); 
	  return NOWHERE; 
	};
      
d985 2
a986 2
		   "god!\r\n", ch);
      return real_room(6001); 
d988 1
a988 1
  
d993 1
a993 1
int green_recall_room(struct char_data *ch) 
d995 1
a995 1
  int room; 
d999 5
a1003 5
    case CLASS_NECROMANCER: room = 16932; break; 
    case CLASS_PYROMANCER: room = 3094; break; 
    case CLASS_CRYOMANCER: room = 3093; break; 
      
    case CLASS_ROGUE: 
d1006 2
a1007 2
    case CLASS_MERCENARY: room = 3038; break; 
      
d1010 4
a1013 5
    case CLASS_DIABOLIST: room = 3003; break;	  
    case CLASS_CLERIC: room = 3003; break;        
    case CLASS_PRIEST: room = 3095; break; 
    case CLASS_DRUID: room = 3087; break;     
      
d1016 2
a1017 1
    case CLASS_PALADIN: room = 5306; break; 
d1020 1
a1020 1
    case CLASS_RANGER: room = 3550; break; 
d1024 2
a1025 2
    default: room = 3022; break; 
      
d1028 1
a1028 1
  
d1032 10
a1041 10
	{
	  send_to_char("ERROR: Could not find your guild, nor the Mielikki "
		       "altar. Please tell a god!\r\n", ch); 
	  sprintf(buf, "ERROR: Couldn't find the real room for vnums "
		  "%i or %i", room, 3002); 
	  
	  mudlog(buf, NRM, LVL_IMMORT, TRUE); 
	  return NOWHERE; 
	};
      
d1043 2
a1044 2
		   "god!\r\n", ch);
      return real_room(3002); 
d1046 1
a1046 1
  
d1051 1
a1051 1
int blue_recall_room(struct char_data *ch) 
d1053 1
a1053 1
  int room; 
d1059 2
a1060 2
    case CLASS_CRYOMANCER: room = 10030; break; 
      
d1063 5
a1067 5
    case CLASS_ASSASSIN: 
    case CLASS_MERCENARY: room = 10048; break; 
      
	  
    case CLASS_CLERIC: 
d1069 5
a1073 5
    case CLASS_DIABOLIST: 
    case CLASS_DRUID: room = 10003; break;     
      
    default: room = 10013; break; 
      
d1075 1
a1075 1
  
d1079 10
a1088 10
	{
	  send_to_char("ERROR: Could not find your guild, nor the the "
		       "Arctic Temple. Please tell a god!\r\n", ch); 
	  sprintf(buf, "ERROR: Couldn't find the real room for vnums "
		  "%i or %i", room, 6001); 
	  
	  mudlog(buf, NRM, LVL_IMMORT, TRUE); 
	  return NOWHERE; 
	};
      
d1090 2
a1091 2
		   "god!\r\n", ch);
      return real_room(6001); 
d1093 1
a1093 1
  
d1097 1
a1097 1
int gray_recall_room(struct char_data *ch) 
d1099 1
a1099 1
  int room; 
d1105 2
a1106 2
    case CLASS_CRYOMANCER: room = 30073; break; 
      
d1109 5
a1113 5
    case CLASS_ASSASSIN: 
    case CLASS_MERCENARY: room = 30066; break; 
      
	  
    case CLASS_CLERIC: 
d1115 5
a1119 5
    case CLASS_DIABOLIST: 
    case CLASS_DRUID: room = 30070; break;     
      
    default: room = 30030; break; 
      
d1121 1
a1121 1
  
d1125 10
a1134 10
	{
	  send_to_char("ERROR: Could not find your guild, nor the the "
		       "Ogakh itself. Please tell a god!\r\n", ch); 
	  sprintf(buf, "ERROR: Couldn't find the real room for vnums "
		  "%i or %i", room, 30030); 
	  
	  mudlog(buf, NRM, LVL_IMMORT, TRUE); 
	  return NOWHERE; 
	};
      
d1136 2
a1137 2
		   "god!\r\n", ch);
      return real_room(30030); 
d1139 1
a1139 1
  
d1151 1
a1151 1
  
d1203 3
@


1.77
log
@Now using flagvectors for effect, mob, player, preference, room, and
room effect flags.  AFF, AFF2, and AFF3 flags are now just EFF flags.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.76 2008/03/09 06:38:37 jps Exp myc $
a26 1
#include "ships.h"
a140 133
/********************************************************************
 *           General special procedures for mobiles                 *
 ********************************************************************/


void npc_steal(struct char_data * ch, struct char_data * victim)
{
  int gold;
  
  if (IS_NPC(victim))
    return;
  if (GET_LEVEL(victim) >= LVL_IMMORT)
    return;
  
  if (AWAKE(victim) && (number(0, GET_LEVEL(ch)) == 0)) {
    act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, victim, TO_VICT);
    act("$n tries to steal gold from $N.", TRUE, ch, 0, victim, TO_NOTVICT);
  } else {
    /* Steal some gold coins */
    gold = (int) ((GET_GOLD(victim) * number(1, 10)) / 100);
    if (gold > 0) {
      GET_GOLD(ch) += gold;
      GET_GOLD(victim) -= gold;
    }
  }
}


SPECIAL(snake)
{
  if (cmd)
    return FALSE;
  
  if (GET_POS(ch) != POS_FIGHTING)
    return FALSE;
  
  if (FIGHTING(ch) && (FIGHTING(ch)->in_room == ch->in_room) &&
      (number(0, 42 - GET_LEVEL(ch)) == 0)) {
    act("$n bites $N!", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("$n bites you!", 1, ch, 0, FIGHTING(ch), TO_VICT);
    call_magic(ch, FIGHTING(ch), 0, SPELL_POISON, GET_LEVEL(ch), CAST_SPELL);
    return TRUE;
  }
  return FALSE;
}


SPECIAL(thief)
{
  struct char_data *cons;
  
  if (cmd)
    return FALSE;
  
  if (GET_POS(ch) != POS_STANDING)
    return FALSE;
  
  for (cons = world[ch->in_room].people; cons; cons = cons->next_in_room)
    if (!IS_NPC(cons) && (GET_LEVEL(cons) < LVL_IMMORT) && (!number(0, 4))) {
      npc_steal(ch, cons);
      return TRUE;
    }
  return FALSE;
}


SPECIAL(magic_user)
{
  struct char_data *vict;
  
  if (cmd || GET_POS(ch) != POS_FIGHTING)
    return FALSE;
  
  /* pseudo-randomly choose someone in the room who is fighting me */
  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
    if (FIGHTING(vict) == ch && !number(0, 4))
      break;
  
  /* if I didn't pick any of those, then just slam the guy I'm fighting */
  if (vict == NULL)
    vict = FIGHTING(ch);
  
  if ((GET_LEVEL(ch) > 13) && (number(0, 10) == 0))
    cast_spell(ch, vict, NULL, SPELL_SLEEP);
  
  if ((GET_LEVEL(ch) > 7) && (number(0, 8) == 0))
    cast_spell(ch, vict, NULL, SPELL_BLINDNESS);
  
  if ((GET_LEVEL(ch) > 12) && (number(0, 12) == 0)) {
    if (IS_EVIL(ch))
      cast_spell(ch, vict, NULL, SPELL_ENERGY_DRAIN);
    else if (IS_GOOD(ch))
      cast_spell(ch, vict, NULL, SPELL_DISPEL_EVIL);
  }
  if (number(0, 4))
    return TRUE;
  
  switch (GET_LEVEL(ch)) {
  case 4:
  case 5:
    cast_spell(ch, vict, NULL, SPELL_MAGIC_MISSILE);
    break;
  case 6:
  case 7:
    cast_spell(ch, vict, NULL, SPELL_CHILL_TOUCH);
    break;
  case 8:
  case 9:
    cast_spell(ch, vict, NULL, SPELL_BURNING_HANDS);
    break;
  case 10:
  case 11:
    cast_spell(ch, vict, NULL, SPELL_SHOCKING_GRASP);
    break;
  case 12:
  case 13:
    cast_spell(ch, vict, NULL, SPELL_LIGHTNING_BOLT);
    break;
  case 14:
  case 15:
  case 16:
  case 17:
    cast_spell(ch, vict, NULL, SPELL_COLOR_SPRAY);
    break;
  default:
    cast_spell(ch, vict, NULL, SPELL_FIREBALL);
    break;
  }
  return TRUE;

}


a218 25
SPECIAL(fido)
{
  
  struct obj_data *i, *temp, *next_obj;
  
  if (cmd || !AWAKE(ch))
    return (FALSE);
  
  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (GET_OBJ_TYPE(i) == ITEM_CONTAINER && GET_OBJ_VAL(i, 3)) {
      act("$n savagely devours a corpse.", FALSE, ch, 0, 0, TO_ROOM);
      for (temp = i->contains; temp; temp = next_obj) {
	next_obj = temp->next_content;
	obj_from_obj(temp);
	obj_to_room(temp, ch->in_room);
      }
      extract_obj(i);
      return (TRUE);
    }
  }
  return (FALSE);
}



d477 84
a571 250
if (CMD_IS("balance")) 
  {
    sprintf(buf, "Coins carried:   &0&b&6%d &0Platinum, &0&b&3%d &0Gold, &0%d Silver and &0&3%d &0Copper\r\n", GET_PLAT(ch), GET_GOLD(ch), GET_SILVER(ch), GET_COPPER(ch));
    sprintf(buf, "%sCoins in bank:   &0&b&6%d &0Platinum, &0&b&3%d &0Gold, &0%d Silver and &0&3%d &0Copper\r\n", buf, GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
    send_to_char(buf, ch);
    return 1;
}

 else if (CMD_IS("deposit")) {

 two_arguments(argument, arg1, arg2);

 if (is_number(arg1)) 
   {
     amount = atoi(arg1);
     if(!*arg2) {
       sprintf(buf, "Deposit %s of what? Platinum? Gold? Silver? Copper?\r\n", arg1);
       send_to_char(buf, ch);
       return 1;
     }
     if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2)) 
       {

	 if (amount <= GET_PLAT(ch)) 
	   {
	     
	     if(amount==1) 
	       {
		 sprintf(buf, "You deposit &0&b&6%s&0 platinum coin.\r\n", arg1);
		 send_to_char(buf, ch);
	       }
	     else
	       {
		 sprintf(buf, "You deposit &0&b&6%s&0 platinum coins.\r\n", arg1);
		 send_to_char(buf, ch);
	       }
	     act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	     GET_PLAT(ch) -= amount;
	     GET_BANK_PLAT(ch) += amount;
	     return 1;
	   }
	 if (GET_PLAT(ch) < amount) 
	   {
	     send_to_char("You don't have that many coins!\r\n", ch);
	     return 1;
	   }
       }
     if (!str_cmp("gold", arg2) || !str_cmp("g", arg2)){
       if (amount <= GET_GOLD(ch)) 
	 {
	   if(amount==1)
	     {
	       sprintf(buf, "You deposit &0&b&3%s&0 gold coin.\r\n", arg1);
	       send_to_char(buf, ch);
	     }
	   else
	     {	
	       sprintf(buf, "You deposit &0&b&3%s&0 gold coins.\r\n", arg1);
	       send_to_char(buf, ch);
	     }
	   act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_GOLD(ch) -= amount;
	   GET_BANK_GOLD(ch) += amount;
	   return 1;
	 }
       if (GET_GOLD(ch) < amount) 
	 {
	   send_to_char("You don't have that many coins!\r\n", ch);
	   return 1;
	 }
     }
     if (!str_cmp("silver", arg2) || !str_cmp("s", arg2))
       {
	 if (amount <= GET_SILVER(ch)) 
	   {
	     if(amount==1)
		 send_to_char("You deposit 1 silver coin.\r\n", ch);
	     else {
		sprintf(buf, "You deposit %s silver coins.", arg1);
	 	send_to_char(buf, ch);
	     }
	     act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	     GET_SILVER(ch) -= amount;
	     GET_BANK_SILVER(ch) += amount;
	     return 1;
	   }
	 if (GET_SILVER(ch) < amount) 
	   {
	     send_to_char("You don't have that many coins!\r\n", ch);
	     return 1;
	   }
       }
     if (!str_cmp("copper", arg2) || !str_cmp("c", arg2))
       {
	 if (amount <= GET_COPPER(ch)) 
	   {
	     if(amount==1)
	       {
		 send_to_char("You deposit &31&0 copper coin.\r\n", ch); 
	       }
	     else {sprintf(buf, "You deposit &0&3%s&0 copper coins.\r\n", arg1);
	     send_to_char(buf, ch);
	     }
	     act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	     GET_COPPER(ch) -= amount;
	     GET_BANK_COPPER(ch) += amount;
	     return 1;
	   }
	 if (GET_COPPER(ch) < amount) 
	   {
	     send_to_char("You don't have that many coins!\r\n", ch);
	     return 1;
	   }
       }
   }
 } 
 else if (CMD_IS("dump")) 
   {  
     if (GET_CASH(ch)>0)
       {
	 send_to_char("You dump all your coins on the counter to be deposited.\r\n", ch);
	 GET_BANK_PLAT(ch) += GET_PLAT(ch);
	 GET_BANK_GOLD(ch) += GET_GOLD(ch);
	 GET_BANK_SILVER(ch) += GET_SILVER(ch);
	 GET_BANK_COPPER(ch) += GET_COPPER(ch);
	 GET_PLAT(ch) -= GET_PLAT(ch); 
	 GET_GOLD(ch) -= GET_GOLD(ch);
	 GET_SILVER(ch) -= GET_SILVER(ch);
	 GET_COPPER(ch) -= GET_COPPER(ch);
	 sprintf(buf, "Your current balance is &0&b&6%d &0platinum, &0&b&3%d &0gold, &0%d silver and &0&3%d &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
	 send_to_char(buf, ch);
	 return 1;
       }
     if (GET_CASH(ch)<1)
       {
	 send_to_char("You don't have any coins to deposit!\r\n", ch);
       }
     sprintf(buf, "Your current balance is &0&b&6%d &0platinum, &0&b&3%d &0gold, &0%d silver and &0&3%d &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
     send_to_char(buf, ch);
     return 1; 
   } 
 else if (CMD_IS("withdraw")) 
   {
     two_arguments(argument, arg1, arg2);
     if (is_number(arg1)) 
       {
	 amount = atoi(arg1);
	 if(!*arg2)
	   {
	     sprintf(buf, "Withdraw %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
	     send_to_char(buf, ch);
	     return 1;
	   }
	 if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2))
	   {
	     if (amount <= GET_BANK_PLAT(ch)) 
	       {
		 if(amount==1)
		   {
		     send_to_char("You withdraw &6&81&0 platinum coin.\r\n", ch);}
		 else
		   {
		     sprintf(buf, "You withdraw &0&b&6%s&0 platinum coins.\r\n", arg1);
		     send_to_char(buf, ch);
		   }
		 act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
		 GET_PLAT(ch) += amount;
		 GET_BANK_PLAT(ch) -= amount;
		 return 1;
	       }
	     if (GET_BANK_PLAT(ch) < amount) {
	       send_to_char("You don't have that many platinum coins deposited!\r\n", ch);
	       return 1;
	     }
	   }
	 if (!str_cmp("gold", arg2) || !str_cmp("g", arg2))
	   {
	     if (amount <= GET_BANK_GOLD(ch)) 
	       {
		 if(amount==1)
		   {
		     sprintf(buf, "You withdraw &0&b&3%s&0 gold coin.\r\n", arg1);
		     send_to_char(buf, ch);
		   }
		 else
		   {	
		     sprintf(buf, "You withdraw &0&b&3%s&0 gold coins.\r\n", arg1);
		     send_to_char(buf, ch);
		   }
		 act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
		 GET_GOLD(ch) += amount;
		 GET_BANK_GOLD(ch) -= amount;
		 return 1;
	       }
	     if (GET_BANK_GOLD(ch) < amount) 
	       {
		 send_to_char("You don't have that many gold coins deposited!\r\n", ch);
		 return 1;
	       }
	   }
	 if (!str_cmp("silver", arg2) || !str_cmp("s", arg2))
	   {
	     if (amount <= GET_BANK_SILVER(ch)) 
	       {
		 if(amount==1)
		   {
		     sprintf(buf, "You withdraw &0%s&0 silver coin.\r\n", arg1);
		     send_to_char(buf, ch);
		   }
		 else{sprintf(buf, "You withdraw &0%s&0 silver coins.\r\n", arg1);
		 send_to_char(buf, ch);
		 }
		 act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
		 GET_SILVER(ch) += amount;
		 GET_BANK_SILVER(ch) -= amount;
		 return 1;
	       }
	     if (GET_SILVER(ch) < amount) 
	       {
		 send_to_char("You don't have that many silver coins deposited!\r\n", ch);
		 return 1;
	       }
	   }
	 if (!str_cmp("copper", arg2) || !str_cmp("c", arg2))
	   {
	     if (amount <= GET_BANK_COPPER(ch)) 
	       {
		 if(amount==1)
		   {
		     sprintf(buf, "You withdraw &0&3%s&0 copper coin.\r\n", arg1);
		     send_to_char(buf, ch); 
		   }
		 else {sprintf(buf, "You withdraw &0&3%s&0 copper coins.\r\n", arg1);
		 send_to_char(buf, ch);
		 }
		 act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
		 GET_COPPER(ch) += amount;
		 GET_BANK_COPPER(ch) -= amount;
		 return 1;
	       }
	     if (GET_BANK_COPPER(ch) < amount) 
	       {
		 send_to_char("You don't have that many copper coins deposited!\r\n", ch);
		 return 1;
	       }
	   }
       }
   } 
 else if (CMD_IS("exchange")) 
   {
a783 30
SPECIAL(blind_weapon)
{
  struct char_data *vict = FIGHTING(ch);
  
  if (cmd || !vict || !number(0, 9))
    return 0;
  if (EFF_FLAGGED(vict, EFF_BLIND) || MOB_FLAGGED(vict, MOB_NOBLIND))
    return 0;
  
  weapon_spell("You scream, \"MIDNIGHT!\" at $N.",
	       "$n screams, \"Midnight!\" at you.",
	       "$n screams, \"Midnight!\" at $N.",
	       ch, vict, (struct obj_data *) me, SPELL_BLINDNESS);
  return 1;
}

SPECIAL(fullharm_weapon)
{
  struct char_data *vict = FIGHTING(ch);
  
  if (cmd || !vict || !number(0, 14))
    return 0;
  
  weapon_spell("Your $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 onto $N!",
	       "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon you!",
	       "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon $N!.",
	       ch, vict, (struct obj_data *) me, SPELL_FULL_HARM);
  return 1;
}

a798 14
SPECIAL(fireball_weapon) 
{
  struct char_data *vict = FIGHTING(ch);
  
  if (cmd || !vict || !number(0, 14))
    return 0;
  
  weapon_spell("Fire seems to shoot from your $p and roar through the air at $N!",
	       "Fire tears from $n's $p and roars through the air at you!",
	       "$n's $p comes alive with a fireball that roars towards $N.",
	       ch, vict, (struct obj_data *) me, SPELL_FIREBALL);
  return 1;
}

a814 102
SPECIAL(curse_weapon)
{
  struct char_data *vict = FIGHTING(ch);
  
  if (cmd || !vict || !number(0, 11))
    return 0;
  if (EFF_FLAGGED(vict, EFF_CURSE))
    return 0;
  
  weapon_spell("Your $p turns black for a brief moment.",
	       "$n's $p turns obsidian as it nears contact with you.",
	       "$n's $p turns black as it contacts $N.",
	       ch, vict, (struct obj_data *) me, SPELL_CURSE);
  return 1;
}
SPECIAL(dispel_good_weapon)
{
  struct char_data *vict = FIGHTING(ch);
  
  if (cmd || !vict || number(0, 100) < 80 )
    return 0;
  
  weapon_spell("Your $p glows &1&bred&0 as it touches $N causing $m to wince in pain!",
	       "$n's $p glows &1&bred&0 as it touches you and YOU wince in pain!",
	       "$n's $p glows &1&bred&0 as it touches $N causing $m to wince in pain!",
	       ch, vict, (struct obj_data *) me, SPELL_DISPEL_GOOD);
  return 1;
}

#define NUM_ARCHERS      2              /* # of rooms archers can shoot from */
#define NUM_TARGETS      3              /* # of rooms an archer can shoot at */
#define HIT_CHANCE       30             /* accuracy 30% chance to hit */
#define ARCHER_NUM_DICE  2              /*  archer damage dice */
#define ARCHER_SIZE_DICE 5              /*  archer does 2d5 each hit */

SPECIAL(archer)
{
  struct char_data *targ;
  int i, j, k;
  int damage;
  
  int to_from_rooms[NUM_ARCHERS][NUM_TARGETS + 1] = {
   /* archer room     target room #1     #2       #3 */
    { 30503,              30502,        30501,     -1},   /* archer room #1 */
    { 3041,              3053,        3503,     -1}    /* room #2 */
  };

  char *mssgs[] = {
    "You feel a sharp pain in your side as an arrow finds its mark!",
    "You hear a dull thud as an arrow pierces $N!",
    "An arrow whistles by your ear, barely missing you!",
    "An arrow narrowly misses $N!"
  };
  
  if(cmd)
    return FALSE;
  
  if(GET_POS(ch) != POS_STANDING)
    return FALSE;
  
  for(i = 0; i < NUM_ARCHERS; i++) 
    {
      if(real_room(to_from_rooms[i][0]) == ch->in_room) 
	{
	  for(j = 1; j <= NUM_TARGETS; j++) 
	    {
	      if((k = real_room(to_from_rooms[i][j])) >= 0) 
		{
		  for(targ = world[k].people; targ; targ = targ->next_in_room) 
		    {
		      if(!IS_NPC(targ) && (GET_LEVEL(targ) < LVL_IMMORT) &&
			 (!number(0, 4))) 
			{
			  if(number(1, 100) <= HIT_CHANCE) 
			    {
			      act(mssgs[0], 1, ch, 0, targ, TO_VICT);
			      act(mssgs[1], 1, ch, 0, targ, TO_NOTVICT);
			      damage = number(5, 50);
			      GET_HIT(targ) -= damage + (number(1, 5));
			      /*  these above numbers can be changed for different
			       *  damage levels.
			       */
			      update_pos(targ);
			      return TRUE;
			    } 
			  else 
			    {
			      act(mssgs[2], 1, ch, 0, targ, TO_VICT);
			      act(mssgs[3], 1, ch, 0, targ, TO_NOTVICT);
			      return TRUE;
			    }
			}
		    }
		}
	    }
	}
    }
  return FALSE;
}



a1143 234
SPECIAL(invis_item)
{
  int i;
  char arg1[MAX_INPUT_LENGTH];
  struct obj_data *invis_obj = (struct obj_data *)me;
  /* cast the "me" pointer and assign it to invis_obj */
  if (invis_obj->worn_by == ch) 
    {
      /* check to see if the person carrying the invis_obj is the character */
      if(CMD_IS("disappear")) 
	{
	  send_to_char("You slowly fade out of view.\r\n", ch);
	  act("$n slowly fades out of view.\r\n", FALSE, ch, 0, 0,TO_ROOM);
	  SET_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
	  return (TRUE);
	}
      
      if (CMD_IS("appear")) 
	{
	  REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
	  send_to_char("You snap into visibility.\r\n", ch);
	  
	  act("$n snaps into visibility.\r\n", FALSE, ch, 0, 0,TO_ROOM);
	  return(TRUE);
	}
      
      one_argument(argument, arg1);
      
      if (is_abbrev(arg1, "magical")) 
	{
	  for (i=0; i< NUM_WEARS; i++)
	    if(GET_EQ(ch,i))
	      {
		if (EFF_FLAGGED(ch, EFF_INVISIBLE)) 
		  {
		    
		    REMOVE_FLAG(EFF_FLAGS(ch), EFF_INVISIBLE);
		    perform_remove(ch,i);
		    send_to_char("You slowly fade into view.\r\n", ch);
		    act("$n slowly fades into view.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		    return (TRUE);
		  } 
		else 
		  {
		    perform_remove(ch, i);
		    return (TRUE);
		  }
		return (FALSE);
	      }
	  return (FALSE);
	}
      return (FALSE);
    }
  return (FALSE);
}

SPECIAL(stone_item)
{
  char arg1[MAX_INPUT_LENGTH];
  struct obj_data *stone_obj = (struct obj_data *)me;
  
  if (EFF_FLAGGED(ch, EFF_STONE_SKIN))
    {
      return (FALSE);
    }
  if (stone_obj->worn_by == ch) 
    {
      
      if(CMD_IS("stone")) 
	{
	  send_to_char("&9&bYour skin hardens and turns to stone!&0\r\n", ch);
	  act("&9&b$n's skin hardens and turns to stone.&0\r\n", FALSE, ch, 0, 0,TO_ROOM);
	  SET_FLAG(EFF_FLAGS(ch), EFF_STONE_SKIN);
	  return (TRUE);
	}
           
      one_argument(argument, arg1);
      
      return (FALSE);
    }
  return (FALSE);
}


/* part of ship system. see ships.h for DOCKx values */	
SPECIAL(ship_exit)
{
  int i = 0;
  struct obj_data *ship_obj = 0;
  
  if(!CMD_IS("disembark"))
    return FALSE;

  /* find out which ship the player is on */
  for(i = 0;i<NUM_SHIPS;i++)
    if(real_room(ships[i].ship_ptr->obj_flags.value[1]) == ch->in_room) 
      ship_obj = ships[i].ship_ptr;
  
  /* the player isn't in the right room */
  if(!ship_obj)
    {
      send_to_char("You can't do that here!\r\n", ch);
      return FALSE;
    }
  else if( (ship_obj->in_room != DOCK1) &&
	   (ship_obj->in_room != DOCK2) &&
	   (ship_obj->in_room != DOCK3) )
    {
      send_to_char("You aren't near land!\r\n", ch);
      return FALSE;
    }
  else
    {
      /* send the message to those in ship */
      act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);
      
      char_from_room(ch);
      char_to_room(ch, ship_obj->in_room);
      
      /* send mesages to ch and those on the dock */
      act("You disembark from $p", FALSE, ch, ship_obj, 0, TO_CHAR);
      act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);
      look_at_room(ch, 0);
    }
  
  return FALSE;
}

SPECIAL(ship)
{
  ACMD(do_look);
  struct obj_data *obj = (struct obj_data *) me;
  struct obj_data *temp_ship;
  char obj_name[MAX_STRING_LENGTH];
  int rnum;

  if(!CMD_IS("enter"))
    return FALSE;
  
  argument = one_argument(argument, obj_name);
  
  if(!(temp_ship = get_obj_in_list_vis(ch, obj_name, world[ch->in_room].contents)))
    return FALSE;
  
  if (temp_ship != obj)
    return FALSE;
  
  if(temp_ship->obj_flags.value[1] <= 0 || temp_ship->obj_flags.value[1] > 32000)
    {
      send_to_char("You can't enter that ship.\r\n", ch);
      return TRUE;
    }
  
  act("$n &1walks up the gang-plank and boards&0 $p.", FALSE, ch, temp_ship, 0, TO_ROOM);
  act("&1You walk up the gang-plank and board&0 $p.", FALSE, ch, temp_ship, 0, TO_CHAR);
  rnum = real_room(temp_ship->obj_flags.value[1]);
  if(rnum == NOWHERE) {
    sprintf(buf, "SYSERR:special_procs.c:ship():Attempting to place ch %s in room NOWHERE.", GET_NAME(ch));
    log(buf);
    send_to_char("This is a bug.  Unable to board ship.  Please report", ch);
    return FALSE;
  }
  char_from_room(ch);
  char_to_room(ch, rnum);
  look_at_room(ch, 0);
  
  act("$n &1climbs aboard&0 $p", FALSE, ch, temp_ship, 0, TO_ROOM);
		return TRUE;
}

/* current_proc implements strong watery currents.
 * It is not used in Fiery at this time (August 2007).
 *
 * The plan is, apparently, to give specific rooms currents. Each one
 * has a direction and a strength (a percentage likelihood to move a character).
 */
SPECIAL(current_proc)
{
  extern struct current_info current[];
  int i, found, perm_num, new_room;
  
  found = FALSE;
  perm_num = 0;
  
  if(!cmd)
    return FALSE;
  
  
  for(i=0; current[i].room_vnum != -1;i++)
    if(ch->in_room == real_room(current[i].room_vnum)) 
      {
	perm_num = i;
	found = TRUE;
	break;
      }
  
  if(found)
      if(number(0,100) < current[perm_num].percent) 
	{
	  sprintf(buf, "The strong current carries you %s!\r\n",
		  dirs[current[perm_num].direction]);
	  send_to_char(buf, ch);
	  sprintf(buf, "$n is taken %s by the rough current!",
		  dirs[current[perm_num].direction]);
	  act(buf, FALSE, ch, 0, 0, TO_NOTVICT);
	  
	  /* You can use your favorite way to record errors here. */
	  
	  if(!EXIT(ch, current[perm_num].direction)) 
	    {
	      send_to_char("Error in this room.  Please report this! ERROR 1\r\n", ch);
	      return FALSE;
	    }

	  if(EXIT(ch, current[perm_num].direction)->to_room == NOWHERE) 
	    {
	      send_to_char("Error in this room.  Please report this! ERROR 2\r\n", ch);
	      return FALSE;
	    }

	  /* Here we want to use char_from_room / char_to_room instead of a
	     do_simple_move
	     because the current should take them no matter if they have a
	     boat, no
	     movement points left, etc. */
	  new_room = EXIT(ch, current[perm_num].direction)->to_room;
	  char_from_room(ch);
	  char_to_room(ch, new_room);
	  act("$n is swept into the room by the rough current!", FALSE, ch,
	      0, 0, TO_NOTVICT);
	}
  return FALSE;
}

d1203 4
@


1.76
log
@Replaced name with namelist in struct char_data.player. GET_NAME macro
now points to short_descr. The uses of these strings is the same for
NPCs and players.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.75 2008/03/07 21:21:57 myc Exp jps $
d287 1
a287 1
  if (!IS_MOVE(cmd) || IS_AFFECTED(guard, AFF_BLIND))
d413 1
a413 1
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && IS_SET(PLR_FLAGS(tch), PLR_KILLER)) {
d421 1
a421 1
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && IS_SET(PLR_FLAGS(tch), PLR_THIEF)){
d588 1
a588 1
      if (IS_AFFECTED(flw->follower, AFF_CHARM)) {
d606 1
a606 1
    SET_BIT(AFF_FLAGS(pet), AFF_CHARM);
d610 1
a610 1
      GET_NAMELIST(pet) = str_dup(buf);
d614 1
a614 1
      pet->player.description = str_dup(buf);
d1115 1
a1115 1
  if (IS_AFFECTED(vict, AFF_BLIND) || MOB_FLAGGED(vict, MOB_NOBLIND))
d1190 1
a1190 1
  if (IS_AFFECTED(vict, AFF_CURSE))
d1628 1
a1628 1
	  SET_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
d1634 1
a1634 1
	  REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
d1648 1
a1648 1
		if (IS_SET(AFF_FLAGS(ch), AFF_INVISIBLE)) 
d1651 1
a1651 1
		    REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
d1676 1
a1676 1
  if (IS_AFFECTED(ch, AFF_STONE_SKIN))
d1687 1
a1687 1
	  SET_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
d1860 1
a1860 1
  if (IS_FIGHTING(ch)) {
d1908 5
@


1.75
log
@Replaced action delays and skill delays with a single list of
'cooldowns', which are decremented by a recurring event and
also save to the player file.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.74 2008/03/05 05:21:56 myc Exp myc $
d591 1
a591 1
      }	
d609 3
a611 3
      sprintf(buf, "%s %s", pet->player.name, pet_name);
      pet->player.name = str_dup(buf);
      
d613 1
a613 1
	      pet->player.description, pet_name);
d618 1
a618 1
    
d621 1
a621 1
    
d1908 5
@


1.74
log
@Bank coins are ints instead of longs now.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.73 2008/02/09 21:07:50 myc Exp myc $
d1881 1
a1881 1
    if (ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT]) {
d1894 1
a1894 1
    ch->char_specials.action_delays[ACT_DELAY_SUMMON_MOUNT] = 7 * SECS_PER_MUD_DAY * PASSES_PER_SEC;
d1908 3
@


1.73
log
@Must provide a boolean to event_create saying whether to
free the event obj when done or not.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.72 2008/02/09 18:29:11 myc Exp myc $
d650 1
a650 1
    sprintf(buf, "%sCoins in bank:   &0&b&6%ld &0Platinum, &0&b&3%ld &0Gold, &0%ld Silver and &0&3%ld &0Copper\r\n", buf, GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
d776 1
a776 1
	 sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
d784 1
a784 1
     sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
d1908 4
@


1.72
log
@Typo in recall scrolls (extra newline).  Allow immortals to use
recall scrolls on themselves.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.71 2008/02/09 04:27:47 myc Exp myc $
d1367 1
a1367 1
   event_create(EVENT_RECALL, recall_event, recall, &(ch->events), 8 RL_SEC); 
d1908 4
@


1.71
log
@Now relying on math header file.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.70 2008/02/09 03:06:17 myc Exp myc $
a33 2
#define EVENTFUNC(name) long (name)(void *event_obj)

d1343 1
a1343 1
   if (GET_LEVEL(targ) >= LVL_IMMORT) {
d1449 1
a1449 1
		  "%i or %i \r\n", room, 6001); 
d1507 1
a1507 1
		  "%i or %i \r\n", room, 3002); 
d1554 1
a1554 1
		  "%i or %i \r\n", room, 6001); 
d1598 1
a1598 1
		       "Arctic Temple. Please tell a god!\r\n", ch); 
d1600 1
a1600 1
		  "%i or %i \r\n", room, 30030); 
d1908 3
@


1.70
log
@Was incorrectly including math.h.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.69 2008/01/29 21:02:31 myc Exp myc $
d32 1
d1910 3
@


1.69
log
@Removing a lot of extern declarations from code files and moving
them to header files, mostly db.h and constants.h.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.68 2008/01/27 21:14:59 myc Exp myc $
d18 1
a18 1
#include "math.h"
d1909 4
@


1.68
log
@Replace hit() with attack().
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.67 2008/01/26 14:26:31 jps Exp myc $
d31 1
a35 11
/*   external vars  */
extern int top_of_world; 
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct time_info_data time_info;
extern struct command_info cmd_info[];


a122 1
  char *fname(char *namelist);
a1793 2
  
  extern const char *dirs[];
d1909 3
@


1.67
log
@Moved a lot of skill-related code into skills.h and skills.c.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.66 2008/01/23 02:34:43 jps Exp jps $
d427 1
a427 1
      hit(ch, tch, TYPE_UNDEFINED);
d435 1
a435 1
      hit(ch, tch, TYPE_UNDEFINED);
d452 1
a452 1
    hit(ch, evil, TYPE_UNDEFINED);
d1922 3
@


1.66
log
@Lose unused variables.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.65 2008/01/23 02:33:26 jps Exp jps $
d30 1
a43 1
extern struct spell_info_type spell_info[];
a49 1
void assign_skills(struct char_data *ch);
a69 2


a73 23
int spell_sort_info[TOP_SKILL+1];

extern char *spells[];

void sort_spells(void)
{
  int a, b, tmp;
  
  /* initialize array */
  for (a = 1; a <= TOP_SKILL; a++)
    spell_sort_info[a] = a;
  
  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < TOP_SKILL; a++)
    for (b = a + 1; b <= TOP_SKILL; b++)
      if (strcmp(spells[spell_sort_info[a]], spells[spell_sort_info[b]]) > 0) {
	tmp = spell_sort_info[a];
	spell_sort_info[a] = spell_sort_info[b];
	spell_sort_info[b] = tmp;
      }
}


d1095 2
a1096 2
    if (spell_info[spl].min_level[i] < level)
      level = spell_info[spl].min_level[i];
d1922 3
@


1.65
log
@Fix payment for pets.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.64 2008/01/18 20:30:11 myc Exp jps $
d589 1
a589 1
  int pet_room, amount, bp, temp, temp2, temp3, temp4, mountdiff;
d1948 3
@


1.64
log
@Fixing some send_to_char strings that don't end with a newline.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.63 2008/01/05 05:44:45 jps Exp myc $
d57 1
d59 4
a62 4
int red_recall_room(struct char_data *ch); 
int green_recall_room(struct char_data *ch); 
int blue_recall_room(struct char_data *ch); 
int gray_recall_room(struct char_data *ch); 
d640 2
a641 4
    amount = (GET_LEVEL(pet));
    money_convert(ch, amount);
    GET_COPPER(ch) = (GET_COPPER(ch)-PET_PRICE(pet));
      
d1948 3
@


1.63
log
@Removing unused function prototypes.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.62 2008/01/04 01:42:50 jps Exp jps $
d543 1
a543 1
         send_to_char("You don't have enough!", ch);
d1949 3
@


1.62
log
@Removed unused practice code.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.61 2008/01/03 12:44:03 jps Exp jps $
a51 2
void set_skills(struct char_data *ch);
void update_skills(struct char_data *ch);
d1949 3
@


1.61
log
@Created an array of structs for class information. Renamed CLASS_MAGIC_USER
to CLASS_SORCERER.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.60 2008/01/02 02:10:34 jps Exp jps $
a100 76
char *how_good(int percent)
{
  static char buf[256];
  
  if (percent == 0)
    strcpy(buf, " (not learned)");
  else if (percent <= 10)
    strcpy(buf, " (awful)");
  else if (percent <= 20)
    strcpy(buf, " (bad)");
  else if (percent <= 40)
    strcpy(buf, " (poor)");
  else if (percent <= 55)
    strcpy(buf, " (average)");
  else if (percent <= 70)
    strcpy(buf, " (fair)");
  else if (percent <= 80)
    strcpy(buf, " (good)");
  else if (percent <= 85)
    strcpy(buf, " (very good)");
  else
    strcpy(buf, " (superb)");
  
  return (buf);
}

char *prac_types[] = {
  "spell",
  "skill"
};

#define LEARNED_LEVEL	0	/* % known which is considered "learned" */
#define MAX_PER_PRAC	1	/* max percent gain in skill per practice */
#define MIN_PER_PRAC	2	/* min percent gain in skill per practice */
#define PRAC_TYPE	3	/* should it say 'spell' or 'skill'?	 */

/* actual prac_params are in class.c */
extern int prac_params[4][NUM_CLASSES];

#define LEARNED(ch) (prac_params[LEARNED_LEVEL][(int)GET_CLASS(ch)])
#define MINGAIN(ch) (prac_params[MIN_PER_PRAC][(int)GET_CLASS(ch)])
#define MAXGAIN(ch) (prac_params[MAX_PER_PRAC][(int)GET_CLASS(ch)])
#define SPLSKL(ch) (prac_types[prac_params[PRAC_TYPE][(int)GET_CLASS(ch)]])

void list_skills(struct char_data * ch)
{
  extern char *spells[];
  
  int i, sortpos;
  
  if (!GET_PRACTICES(ch))
    strcpy(buf, "You have no practice sessions remaining.\r\n");
  else
    sprintf(buf, "You have %d practice session%s remaining.\r\n",
	    GET_PRACTICES(ch), (GET_PRACTICES(ch) == 1 ? "" : "s"));
  
  sprintf(buf, "%sYou know of the following %ss:\r\n", buf, SPLSKL(ch));
  
  strcpy(buf2, buf);
  
  for (sortpos = 1; sortpos < TOP_SKILL; sortpos++) {
    i = spell_sort_info[sortpos];
    if (strlen(buf2) >= MAX_STRING_LENGTH - 32) {
      strcat(buf2, "**OVERFLOW**\r\n");
      break;
    }
    if (GET_LEVEL(ch) >= spell_info[i].min_level[(int) GET_CLASS(ch)]) {
      sprintf(buf, "%-20s %s\r\n", spells[i], how_good(GET_SKILL(ch, i)));
      strcat(buf2, buf);
    }
  }
  
  page_string(ch->desc, buf2, 1);
}


d1951 4
@


1.60
log
@Removed unused external function definitions.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.59 2008/01/02 01:04:26 jps Exp jps $
d1536 1
a1536 1
    case CLASS_MAGIC_USER: room = 6231; break;
d1586 1
a1586 1
    case CLASS_MAGIC_USER: room = 3046; break;
d1644 1
a1644 1
    case CLASS_MAGIC_USER:
d1690 1
a1690 1
    case CLASS_MAGIC_USER:
d2027 3
@


1.59
log
@Removing unused external function clear_skills().
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.58 2007/12/25 05:41:49 jps Exp jps $
a51 1
int parse_class(struct char_data *ch, char arg);
d2027 3
@


1.58
log
@Updated event code so the each event type is positively identified.
Events may be tied to objects or characters so that when that object
or character is extracted, its events can be canceled.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.57 2007/12/19 20:55:56 myc Exp jps $
a49 1
void clear_skills(struct char_data *ch);
d2028 5
@


1.57
log
@Getting rid of a defunct spec proc for a defunct clan.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.56 2007/10/11 20:14:48 myc Exp myc $
d29 1
a57 1
struct event *event_create(EVENTFUNC(*func), void *event_obj, long when );
d1486 1
a1486 1
   event_create(recall_event, recall, 8 RL_SEC); 
d2029 3
@


1.56
log
@Changed skill defines to support chants and songs as skills, but
slightly distinguished from spells and skills.  TOP_SKILL is the
old MAX_SKILLS.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.55 2007/09/12 19:23:04 myc Exp myc $
a1969 42
/* This specproc is only used for the Balance of Pandor guild guard.
 * However, their clan hall is basically shut down and the guard does not load.
 * Hasn't that clan been dissolved? */
SPECIAL(clan0_guard_proc)
{
  struct char_data *clan_guard = (struct char_data *) me;
  
  if(!cmd)
    return FALSE;
  
  if (!IS_MOVE(cmd))
    return FALSE;
  
  if (!ch || !clan_guard)
    return FALSE;
  
  if(!IS_NPC(ch) && GET_LEVEL(ch) >= LVL_IMMORT)
    return FALSE;
  
  if ((clan_guard->in_room != real_room(18700)) ||
      (clan_guard->in_room == NOWHERE))
    return FALSE;
  
  if (cmd == SCMD_NORTH)
    {
     if(GET_CLAN(ch) != clan[0].id || GET_CLAN_RANK(ch) < 1)
       {
	 act("$n places his LARGE stone hand on $N's chest to prevent $s entry.", FALSE, clan_guard, 0, ch,
	     TO_NOTVICT); 
	 sprintf(buf, "%s prevents you from entering!\r\n", GET_NAME(clan_guard));
	 /*	 GET_POS(ch) = POS_SITTING;
		 GET_POS1(ch) = POS1_PRONE; */
	 send_to_char(buf, ch);
	 return TRUE;
       }
     else
       return FALSE;
    }
  return FALSE;
}


d2029 5
@


1.55
log
@Shop keepers give correct response when 'buy' is typed without arguments.
Shop keepers won't throw up on you anymore.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.54 2007/08/23 00:58:13 jps Exp myc $
d80 1
a80 1
int spell_sort_info[MAX_SKILLS+1];
d89 1
a89 1
  for (a = 1; a < MAX_SKILLS; a++)
d93 2
a94 2
  for (a = 1; a < MAX_SKILLS - 1; a++)
    for (b = a + 1; b < MAX_SKILLS; b++)
d163 1
a163 1
  for (sortpos = 1; sortpos < MAX_SKILLS; sortpos++) {
d2071 4
@


1.54
log
@Pet shops will indicate how easy it is for you to ride a mount
in the "list" so you can avoid buying impossible mounts.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.53 2007/08/16 11:54:19 jps Exp jps $
d700 4
d2071 4
@


1.53
log
@Remove defunct specprocs, such as hardcoded subclass quests, and others.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.52 2007/08/03 22:00:11 myc Exp jps $
d664 3
d668 1
a668 1
  int pet_room, amount, bp, temp, temp2, temp3, temp4;
d675 2
a676 2
      send_to_char("Pet                                          Cost\n\r", ch);
      send_to_char("--------------------------------------  -------------\n\r", ch);
d678 1
d684 9
a692 2
         sprintf(buf, "%-38s  &0&b&6%3d&0p,&b&3%d&0g,&0%ds,&0&3%d&0c\n\r",
            GET_NAME(pet), temp, temp2, temp3, temp4);
d2067 3
@


1.52
log
@Fixed some \r\n typoes in send_to_chars.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.51 2007/07/14 02:16:22 jps Exp myc $
a61 6

SPECIAL(red_recall);
SPECIAL(green_recall);
SPECIAL(blue_recall);
SPECIAL(gray_recall);

a178 451
SPECIAL(assassin_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  type = GET_CLASS(ch);
  if(type == CLASS_ASSASSIN){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
	FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of teh rogue.'&0",
	FALSE,me,0,ch, TO_VICT);
     return 1;
  }
  
  if ((type != CLASS_ROGUE) || ((i = parse_class(ch, 'j')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'An assassin you will never be, now begone!'&0",
	FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if (GET_ALIGNMENT(ch) > -500) {
    act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  
  if (!(qobj = get_obj_in_list_vnum(32026, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the roguish quest.'&0",
	FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);  
  act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
      TRUE,me,0,ch,TO_ROOM);
  act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues!\r\nYou are an Assassin!&0",FALSE,me,0,ch,TO_VICT);
  return 1;
}

SPECIAL(mercenary_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  type = GET_CLASS(ch);
  if(type == CLASS_MERCENARY){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
	FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of teh rogue.'&0",
	FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type != CLASS_WARRIOR) ||
      ((i = parse_class(ch, 'k')) == CLASS_UNDEFINED))
    {
      act("&2&b$n&2&b tells you, 'A mercenary you will never be, now begone!'&0",
	  FALSE,me,0,ch, TO_VICT);
      return 1;
    }
  
  if (!(qobj = get_obj_in_list_vnum(55601, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the roguish quest.'&0",
	FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);  
  act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
      TRUE,me,0,ch,TO_ROOM);
  act("&2&b$n&2&b tells you, 'Congratulations! You are now a sword for hire!\r\nYou are a Mercenary!&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}

SPECIAL(diabolist_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  
  type = GET_CLASS(ch);
  if((type == CLASS_DIABOLIST) || (type == CLASS_ANTI_PALADIN)){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }    
  
  if((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'Your path will never lead to true evil. Begone!'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }
  
  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of evil.'&0",
	FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type == CLASS_CLERIC) && ((i = parse_class(ch, 'q')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'A diabolist you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && ((i = parse_class(ch, 'f')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'An anti-paladin you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (GET_ALIGNMENT(ch) > -500) {
    act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj = get_obj_in_list_vnum(8504, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the unholy quest.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a &4blue flame!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_CLERIC)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy cleric! You are a Diabolist!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy warrior!\r\nYou are an Anti-Paladin!'&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}


SPECIAL(druid_subclasser)
{
  int i = 0;
  struct obj_data *qobj1, *qobj2, *qobj3, *qobj4;
  int type;
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  
  type = GET_CLASS(ch);
  if((type == CLASS_DRUID) || (type == CLASS_RANGER)){
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }    
  
  if((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'Your path will never lead to true neutrality.  Leave this place!'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }
  
  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of evil.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type == CLASS_CLERIC) && ((i = parse_class(ch, 'h')) == CLASS_UNDEFINED)) {
    act("&2&b$n&2&b tells you, 'A druid you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && ((i = parse_class(ch, 'g')) == CLASS_UNDEFINED))
    {
      act("&2&b$n&2&b tells you, 'A ranger you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
      return 1;
    }
  if (GET_ALIGNMENT(ch) < -300) {
    act("&2&b$n&2&b tells you, 'You have strayed to far from the path of neutrality.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj1 = get_obj_in_list_vnum(2330, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  if (!(qobj2 = get_obj_in_list_vnum(2331, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  if (!(qobj3 = get_obj_in_list_vnum(2332, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  if (!(qobj4 = get_obj_in_list_vnum(2333, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the required objects.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  act("You give $p to $N.",TRUE,ch,qobj1,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj1,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj2,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj2,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj3,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj3,me,TO_ROOM);
  act("You give $p to $N.",TRUE,ch,qobj4,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj4,me,TO_ROOM);
  obj_from_char(qobj1);
  extract_obj(qobj1);
  obj_from_char(qobj2);
  extract_obj(qobj2);
  obj_from_char(qobj3);
  extract_obj(qobj3);
  obj_from_char(qobj4);
  extract_obj(qobj4);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a &4blue flame!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_CLERIC)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most natural of clerics! You are a Druid!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most naturalistic warrior! You are a Ranger!'&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}

#define DQ_ROOM1 real_room(2475)
#define DQ_ROOM2 real_room(2460)
#define DQ_ROOM3 real_room(2498)
#define DQ_ROOM4 real_room(2499)

SPECIAL(druid_quest_room)
{
  int class, align, level;
  struct obj_data *obj = NULL;
  
  if(IS_NPC(ch) || !CMD_IS("say"))
    return FALSE;
  
  skip_spaces(&argument);
  
  class = GET_CLASS(ch);
  align = GET_ALIGNMENT(ch);
  level = GET_LEVEL(ch);
  
  if(strcmp(argument, "I pray for a blessing from mother earth, creator of life and bringer of death") == 0)
    {  
      if((class != CLASS_CLERIC) && (class != CLASS_WARRIOR))
	return FALSE;
      
      if(align < 0)
	return FALSE;
      
      if(level < 21)
	return FALSE;
      
      if (ch->in_room == DQ_ROOM1)
	obj = read_object(2330, VIRTUAL);
      if (ch->in_room == DQ_ROOM2)
	obj = read_object(2331, VIRTUAL);
      if (ch->in_room == DQ_ROOM3)
	obj = read_object(2332, VIRTUAL);
      if (ch->in_room == DQ_ROOM4)
	obj = read_object(2333, VIRTUAL);
      
      obj_to_char(obj, ch);
      send_to_char("You recieve the blessings of Mother Earth\r\n", ch); 
    }
  else
    return FALSE;
  return TRUE;
}

SPECIAL(priest_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type = CLASS_PRIEST;  /* default to priest */
  
  type = GET_CLASS(ch);
  
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  
  if ((type == CLASS_PRIEST) || type == CLASS_PALADIN) {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }    
  
  if ((type != CLASS_CLERIC) && (type != CLASS_WARRIOR)) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but your path will never lead to priesthood. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }
  
  if(GET_LEVEL(ch) < 21) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the holy ways.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type == CLASS_CLERIC) && (i = parse_class(ch, 'p')) == CLASS_UNDEFINED) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but the priesthood is not for you. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if ((type == CLASS_WARRIOR) && (i = parse_class(ch, 'e')) == CLASS_UNDEFINED) {
    act("&2&b$n&2&b tells you, 'I am sorry my child, but knighthood is not for you. You best choose another path.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  
  if (GET_ALIGNMENT(ch) < 500) {
    act("&2&b$n&2&b tells you, 'You have strayed to far from the path of righteousness. Return after you have made amends for your evil deeds.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
  if (!(qobj = get_obj_in_list_vnum(2300, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have completed the holy quest.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  check_regen_rates(ch);
  act("&7&b$n&7&b glows with a blinding light!&0",TRUE,ch,0,0,TO_ROOM);
  if (type == CLASS_PRIEST)
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the holiest of clerics! You are a Priest!'&0",FALSE,me,0,ch,TO_VICT);
  else
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the holiest of warriors! You are a Paladin!'&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}

/* pryo */

SPECIAL(pyro_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  type = GET_CLASS(ch);
  
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  
  if (type == CLASS_PYROMANCER)
    {
      act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
      return 1;
    }    
  
  if (type != CLASS_MAGIC_USER) {
    act("&2&b$n&2&b tells you, 'You cannot learn the way of the flame.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }
  
  if(GET_LEVEL(ch) < 25) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of magic.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type == CLASS_MAGIC_USER) && (i = parse_class(ch, 'u')) == CLASS_UNDEFINED)
    {
      act("&2&b$n&2&b tells you, 'You will never be able to control the flames.'&0",FALSE,me,0,ch,TO_VICT);
      return 1;
    }
  
  if (!(qobj = get_obj_in_list_vnum(101, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have captured the living flame.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
  act("&2&b$n&2&b tells you, 'Congratulations! You can now control flames and fire! You are a Pyromancer!'&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}

/* necro */

SPECIAL(necro_subclasser)
{
  int i = 0;
  struct obj_data *qobj;
  int type;
  type = GET_CLASS(ch);
  
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;
  
  if (type == CLASS_NECROMANCER)
    {
      act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
      return 1;
    }    
  
  if (type != CLASS_MAGIC_USER) {
    act("&2&b$n&2&b tells you, 'You cannot commune with the dead.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }
  
  if(GET_LEVEL(ch) < 25) {
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of magic.'&0",FALSE,me,0,ch, TO_VICT);
    return 1;
  }
  
  if ((type == CLASS_MAGIC_USER) && (i = parse_class(ch, 'l')) == CLASS_UNDEFINED)
    {
      act("&2&b$n&2&b tells you, 'You will never be able to control the dead.'&0",FALSE,me,0,ch,TO_VICT);
      return 1;
    }
  
  if (!(qobj = get_obj_in_list_vnum(3014, ch->carrying))) {
    act("&2&b$n&2&b tells you, 'Return when you have retrieved the book.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }  
  act("You give $p to $N.",TRUE,ch,qobj,me,TO_CHAR);
  act("$n gives $p to $N.",TRUE,ch,qobj,me,TO_ROOM);
  obj_from_char(qobj);
  extract_obj(qobj);
  clear_skills(ch);
  GET_CLASS(ch) = i;
  set_skills(ch);
  update_skills(ch);
  check_regen_rates(ch);
  act("&2&b$n&2&b tells you, 'Congratulations! You can now control the dead! You are a Necromancer!'&0",FALSE,me,0,ch,TO_VICT);
  
  return 1;
}

a227 41
  /* apparently the "practice" command no longer exists..

  if (CMD_IS("practice")) {  
    skip_spaces(&argument);
  
    if (!*argument) {
      list_skills(ch);
      return 1;
    }
    if (GET_PRACTICES(ch) <= 0) {
      send_to_char("You do not seem to be able to practice now.\r\n", ch);
      return 1;
    }
  
    skill_num = find_skill_num(argument);
  
    if (skill_num < 1 ||
	GET_LEVEL(ch) < spell_info[skill_num].min_level[(int) GET_CLASS(ch)]) {
      sprintf(buf, "You do not know of that %s.\r\n", SPLSKL(ch));
      send_to_char(buf, ch);
      return 1;
    }
    if (GET_SKILL(ch, skill_num) >= LEARNED(ch)) {
      send_to_char("You are already learned in that area.\r\n", ch);
      return 1;
    }
    send_to_char("You practice for a while...\r\n", ch);
    GET_PRACTICES(ch)--;
  
    percent = GET_SKILL(ch, skill_num);
    percent += MIN(MAXGAIN(ch), MAX(MINGAIN(ch), int_app[GET_INT(ch)].learn));
  
    SET_SKILL(ch, skill_num, MIN(LEARNED(ch), percent));
  
    if (GET_SKILL(ch, skill_num) >= LEARNED(ch))
      send_to_char("You are now learned in that area.\r\n", ch);
  
    return 1;
  }
  */ /* end of practice special proc */

a231 1

a254 13
  /*  Commented out to attempt to not give money or exp for dropping stuff in
   *   a dump! RSD 8/23/99

  if (value) {
    act("You are awarded for outstanding performance.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n has been awarded for being a good citizen.", TRUE, ch, 0, 0, TO_ROOM);
    
    if (GET_LEVEL(ch) < 3)
      gain_exp(ch, NULL, value);
    else
      GET_GOLD(ch) += value;
  }
  */
a258 95
SPECIAL(mayor)
{
  ACMD(do_gen_door);
  
  static char open_path[] =
    "W3a3003b33000c111d0d111Oe333333Oe22c222112212111a1S.";
  
  static char close_path[] =
    "W3a3003b33000c111d0d111CE333333CE22c222112212111a1S.";
  
  static char *path;
  static int index;
  static bool move = FALSE;
  
  if (!move) {
    if (time_info.hours == 6) {
      move = TRUE;
      path = open_path;
      index = 0;
    } else if (time_info.hours == 20) {
      move = TRUE;
      path = close_path;
      index = 0;
    }
  }
  if (cmd || !move || (GET_POS(ch) < POS_SLEEPING) ||
      (GET_POS(ch) == POS_FIGHTING))
    return FALSE;
  
  switch (path[index]) {
  case '0':
  case '1':
  case '2':
  case '3':
    perform_move(ch, path[index] - '0', 1);
    break;
    
  case 'W':
    GET_POS(ch) = POS_STANDING;
    act("$n awakens and groans loudly.", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'S':
    GET_POS(ch) = POS_SLEEPING;
    act("$n lies down and instantly falls asleep.", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'a':
    act("$n says 'Hello Honey!'", FALSE, ch, 0, 0, TO_ROOM);
    act("$n smirks.", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'b':
    act("$n says 'What a view!  I must get something done about that dump!'",
	FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'c':
    act("$n says 'Vandals!  Youngsters nowadays have no respect for anything!'",
	FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'd':
    act("$n says 'Good day, citizens!'", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'e':
    act("$n says 'I hereby declare the bazaar open!'", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'E':
    act("$n says 'I hereby declare Midgaard closed!'", FALSE, ch, 0, 0, TO_ROOM);
    break;
    
  case 'O':
    do_gen_door(ch, "gate", 0, SCMD_UNLOCK);
    do_gen_door(ch, "gate", 0, SCMD_OPEN);
    break;
    
  case 'C':
    do_gen_door(ch, "gate", 0, SCMD_CLOSE);
    do_gen_door(ch, "gate", 0, SCMD_LOCK);
    break;
    
  case '.':
    move = FALSE;
    break;
    
  }
  
  index++;
  return FALSE;
}


d580 1
a580 1
/* turning copper to coins */
a581 1
     /* BURU 13/12/97*/
a618 1
  /* BURU 13/12/97*/
d662 1
a662 1
SPECIAL(pet_shops)
a713 1
      /* free(pet->player.name); don't free the prototype! */
a717 1
      /* free(pet->player.description); don't free the prototype! */
a722 4
    /* Be certain that pets can't get/carry/use/wield/wear items */
/*      IS_CARRYING_W(pet) = 1000; */
/*      IS_CARRYING_N(pet) = 100; */

a736 25
/* part of pryo class quest Fingh */
SPECIAL(rift_portal)
{
  int class;
  
  if (!CMD_IS("enter") || IS_NPC(ch))
    return FALSE; 
  
  class = GET_CLASS(ch);
  
  act("&9&bThe dark pentagram &0&1glows &bred &9as $n enters.&0", FALSE, ch, 0, 0, TO_ROOM);
  act("&9&bThe dark pentagram &0&1glows &bred &9as you enter.&0", FALSE, ch, 0, 0, TO_CHAR);
  if(class != CLASS_MAGIC_USER)
    {
      act("&b&3$n is thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
      act("&b&3You are thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
      alter_hit(ch, dice(50, 6), 2);
      GET_POS(ch) = POS_SITTING;
      return TRUE;
    }
  
  look_at_room(ch, 0);
  return FALSE;
}

a737 1
/* Exchange added by David Endre 7/23/99 */
a738 1
     /* bank redone by buru 19/12/97 */
a1718 2


a1802 193
SPECIAL(uklor)
{struct char_data;
 int to_room, num, tim, num2, tim2;
 num = number(1,3);
 num2 = number(0, 1000);
 tim2 = number(0, 1);
 tim=time_info.hours+tim2;
 /* SETTING DESTINATION*/
 to_room=ch->in_room-1;
 /* GOOD ALIGN PROC (cure blind/poison/curse */
 if(tim==3||tim==6||tim==9||tim==12||tim==15||tim==18||tim==21||tim==0)
   {
     if(GET_ALIGNMENT(ch) >= 350)
       {
	 if (IS_AFFECTED(ch, AFF_BLIND)) 
	   {
	     if (num2>500)
	       {
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you can see!&0\r\n", ch);
		 affect_from_char(ch, SPELL_BLINDNESS);
	       }
	   }
	 if (IS_AFFECTED(ch, AFF_POISON)) 
	   {
	     if (num2>800)
	       {
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you feel much better!&0\r\n", ch);
		 affect_from_char(ch, SPELL_POISON);
	       }
	   }
	 if (IS_AFFECTED(ch, AFF_CURSE)) 
	   {
	     if (num2>850)
	       {
		 send_to_char("&0&b&8A gentle swirl of energy fills your body, you feel much more comfortable!&0\r\n", ch);
		 affect_from_char(ch, SPELL_CURSE);
	       }
	   }
	 return 0;
       }

 /*EVIL align proc: throws PC out of room + damages */
		 if((GET_ALIGNMENT(ch) <= -350)&&(GET_LEVEL(ch)<LVL_IMMORT))
		   {
		     act("$n&0's eyes widen in suprise as a swirl of energy throws him out of the room!\r\n", FALSE, ch, 0, 0, TO_ROOM);
		     char_from_room(ch);
		     char_to_room(ch, to_room);
		     sprintf(buf, "&0&b&8A swirl of energy wraps around you, and tosses you out of the room!&0\r\n");
		     send_to_char(buf, ch);
		     look_at_room(ch, 1);
		     act("$n&0 looks like he has been THROWN as he enters through the air from the west.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		     if((num==1)||(num==2))
		       {
			 sprintf(buf, "&0&b&8You are thrown against the wall!&0\r\n");
			 send_to_char(buf, ch);
			 act("$n&0 hits the wall with a powerful *THUD*.\r\n", FALSE, ch, 0, 0, TO_ROOM);
			 if(num==1)
			   {
			     GET_HIT(ch)=(GET_HIT(ch)-((int)(0.2*GET_HIT(ch))));
			   }
			 if(num==2)
			   {
			     GET_HIT(ch)=(GET_HIT(ch)-((int)(0.8*GET_HIT(ch))));
			   }
		       }
		     return 0;
		   }
   }
 return 0;
}


void special_update(struct char_data * ch)
{
  if (++(ch->char_specials.timer) > 0)
    {
      command_interpreter(ch, "z001#@@#");
    }
}

void el_passage(struct char_data * ch)
{
  int prob, temp;
  temp = number(1, 3);
  prob = ((number(1, 100))+GET_LEVEL(ch));
  if(IS_NPC(ch)||(GET_HIT(ch)<0))
    {
      return;
    }
  do
    {
      if((GET_POS(ch)!=POS_SLEEPING))
	{
	  switch (number(1, 8))
	    {
	    case 1:
	      send_to_char("&0&3The earth of the wall starts forming the shape of an arm!&0\r\n", ch);
	      send_to_char("&0&3The arm extends and thumps you extremely hard.&0\r\n", ch);
	      send_to_char("&0&3The arm retracts and flattens into nothing.&0\r\n", ch);
	      if(GET_LEVEL(ch)<LVL_IMMORT)
		{
		  GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));
		}
	      break;
	    case 2:
	      send_to_char("&0&b&6The wall fires a series of tiny icy missiles at YOU!&0\r\n", ch);
	      if(GET_LEVEL(ch)<LVL_IMMORT)
		{
		  GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));
		}
	      break;
	    case 3:
	      send_to_char("&0&1The layer of fire condenses into a concentrated flame scorching you!&0\r\n", ch);
	      if(GET_LEVEL(ch)<LVL_IMMORT)
		{
		  GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));
		}
	      break;
	    case 4:
	      send_to_char("&0&4The water on the walls begins to swirl at an incredible rate.&0\r\n", ch);
	      if(GET_POS(ch)>POS_SITTING)
		{
		  send_to_char("&0&4The water shoots from the wall at sufficient velocity to knock you down!&0\r\n", ch);
		  GET_POS(ch)=POS_SITTING;
		}
	      break;
	    case 5:
	      send_to_char("&0&3A large clump of earth shoots out at you knocking you off balance!&0\r\n", ch);
	      GET_POS(ch)=POS_SITTING;
	      break;
	    case 6:
	      send_to_char("&0&b&6Millions of icy fragments drop from the ceiling before you.&0\r\n", ch);
	      if(GET_POS(ch)>POS_SITTING)
		{
		  send_to_char("&0You try your best, but eventually you &b&8SLIP&0 and fall!&0 &0\r\n", ch);
		  GET_POS(ch)=POS_SITTING;
		}
	      break;
	    case 7:
	      send_to_char("&0&1The fire dances and skips across the passageway before you.&0\r\n", ch);
	      send_to_char("&0A &1fiery&0 blast knocks you backwards causing you to lose your balance.&0\r\n", ch);
	      GET_POS(ch)=POS_SITTING;
	      break;
	    case 8:
	      send_to_char("&0&4The water forms strange and mysterious patterns on the wall before you.&0\r\n", ch);
	      send_to_char("&0You are involuntarily mesmerized by the &4swirls&0 and &4swoshes.&0\r\n", ch);
	      send_to_char("&0Before long your eyelids close and you drift off to sleep.&0\r\n", ch);
	      GET_POS(ch)=POS_SLEEPING;
	    }
	}
      if(GET_POS(ch)==POS_SLEEPING)
	{
	  send_to_char("You have terrible nightmares as your body is overtaken with *PAIN*.&0\r\n", ch);
	  if(GET_LEVEL(ch)<LVL_IMMORT)
	    {
	      GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));
	    }
	}
      if(GET_HIT(ch)<0)
	{
	  GET_HIT(ch)=-5;
	  update_pos(ch);
	}
      switch(number(1, 4))
	{
	case 1:
	  if(ch->in_room == real_room(9807))
	    {
	      temp=6;
	    }
	case 2:
	  if(ch->in_room == real_room(9806))
	    {
	      temp=6;
	    }
	case 3:
	  if(ch->in_room == real_room(9805))
	    {
	      temp=6;
	    }
	case 4:
	  if(ch->in_room == real_room(9801))
	    {
	      temp=6;
	    }
	}
    }
  while((((number(0, 10))+temp)>9)&&(GET_HIT(ch)>-1));
  sprintf(buf2, "Something happens to $n but its hard to see with all this kaos!");
  act(buf2, FALSE, ch, 0, 0, TO_ROOM);
  return;
}

d1889 6
d1955 3
d2056 3
@


1.51
log
@Stop calculating mv points of pets here, because it's now
handled in db.c.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.50 2007/05/29 20:16:32 jps Exp jps $
d1409 1
a1409 1
       sprintf(buf, "Deposit %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
d1421 1
a1421 1
		 sprintf(buf, "You deposit &0&b&6%s&0 platinum coin.", arg1);
d1426 1
a1426 1
		 sprintf(buf, "You deposit &0&b&6%s&0 platinum coins.", arg1);
d1445 1
a1445 1
	       sprintf(buf, "You deposit &0&b&3%s&0 gold coin.", arg1);
d1450 1
a1450 1
	       sprintf(buf, "You deposit &0&b&3%s&0 gold coins.", arg1);
d1469 4
a1472 6
	       {
		 sprintf(buf, "You deposit &0%s&0 silver coin.", arg1);
		 send_to_char(buf, ch);
	       }
	     else{sprintf(buf, "You deposit &0%s&0 silver coins.", arg1);
	     send_to_char(buf, ch);
d1491 1
a1491 2
		 sprintf(buf, "You deposit &0&3%s&0 copper coin.", arg1);
		 send_to_char(buf, ch); 
d1493 1
a1493 1
	     else {sprintf(buf, "You deposit &0&3%s&0 copper coins.", arg1);
d1552 1
a1552 2
		     sprintf(buf, "You withdraw &0&b&6%s&0 platinum coin.", arg1);
		     send_to_char(buf, ch);}
d1554 2
a1555 2
		   {	
		     sprintf(buf, "You withdraw &0&b&6%s&0 platinum coins.", arg1);
d1574 1
a1574 1
		     sprintf(buf, "You withdraw &0&b&3%s&0 gold coin.", arg1);
d1579 1
a1579 1
		     sprintf(buf, "You withdraw &0&b&3%s&0 gold coins.", arg1);
d1599 1
a1599 1
		     sprintf(buf, "You withdraw &0%s&0 silver coin.", arg1);
d1602 1
a1602 1
		 else{sprintf(buf, "You withdraw &0%s&0 silver coins.", arg1);
d1622 1
a1622 1
		     sprintf(buf, "You withdraw &0&3%s&0 copper coin.", arg1);
d1625 1
a1625 1
		 else {sprintf(buf, "You withdraw &0&3%s&0 copper coins.", arg1);
d2884 4
@


1.50
log
@Abstracted getting base class.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.49 2007/05/29 19:45:25 jps Exp jps $
a1320 5
    if (MOB_FLAGGED(pet, MOB_MOUNTABLE)) {
      GET_MAX_MOVE(pet) = (100 + (3 * GET_LEVEL(pet))); 
      GET_MOVE(pet) = (100 + (3 * GET_LEVEL(pet)));
    }

d2888 3
@


1.49
log
@Disable same-class-only level gains for now.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.48 2007/05/28 23:22:14 jps Exp jps $
d60 1
d653 2
a654 3
      /* Disabled for now */
      /*
      if (GET_CLASS((struct char_data *)(me)) != GET_CLASS(ch)) {
a658 1
      */
d2893 3
@


1.48
log
@You can only level gain by your own guildmaster.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.47 2007/04/11 16:05:27 jps Exp jps $
d652 2
d659 1
d2894 3
@


1.47
log
@Scavengers who pick up money won't end up with the money pile object in inventory.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.46 2007/04/11 14:18:12 jps Exp jps $
d637 1
a637 5
  /* char guild_scratch[500]; */ /* used for guildmaster gossip */
  /* int skill_num, percent; */
  
  /* extern struct spell_info_type spell_info[]; */
  /* extern struct int_app_type int_app[]; */
d639 2
a640 5
  ACMD(do_save);
  /* ACMD(do_gen_comm); */
  
  if (IS_NPC(ch))
    return 0;
a641 1
  /* reinflict "level gain" code on players - Metamorpho - Friday 10/13/2000 */
d643 2
a644 2
  if (CMD_IS("level")) {
    skip_spaces(&argument);
d646 5
a650 2
    if (!*argument)
      return 0;      /* process via the regular command */
d652 5
a656 2
    if (str_cmp(argument,"gain"))
      return 0;      /* process via the regular command */
d658 17
a674 14
    if (GET_EXP(ch) == ((exp_to_level(GET_LEVEL(ch),GET_CLASS(ch))))-1) {
      if (GET_LEVEL(ch) < LVL_MAX_MORT) {
	sprintf(buf,
		"$n says \"$N is ready for level %d!\"",
		GET_LEVEL(ch) + 1);
	act(buf,FALSE,me,0,ch,TO_ROOM);
	/* comment out, but retain, gossip code! */ /*
	sprintf(guild_scratch,"%s has achieved level %d!",
		GET_NAME(ch),GET_LEVEL(ch)+1);
	do_gen_comm(me,guild_scratch,0,SCMD_GOSSIP);
	*/
	/* advance to the next level! */
	gain_exp_regardless(ch,1);
	do_save(ch,"",0,0);
d676 3
a678 7
	act("$N tells you \"You are as powerful as a mortal can be.\"",
	    FALSE,ch,0,me,TO_CHAR);
      }
    } else {
      sprintf(buf,"$N tells you \"You are not ready for level %d yet.\"",
              GET_LEVEL(ch) + 1);
      act(buf,FALSE,ch,0,me,TO_CHAR);
d680 2
a681 2
    return TRUE;
  }
d2891 3
@


1.46
log
@Don't have to hold recalls.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.45 2007/04/04 13:40:12 jps Exp jps $
d59 1
d1118 1
d2894 3
@


1.45
log
@Implement NORECALL flag for rooms.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.44 2007/03/27 04:27:05 myc Exp jps $
d2047 1
a2047 1
	       char* argument, int color)
d2049 15
a2063 16
  char arg_1[MAX_INPUT_LENGTH];
  char target[MAX_INPUT_LENGTH]; 
  char* tmp; 
  struct char_data* targ; 
  struct recall_event_obj* recall; 
  int room;
  /*int chance; */
  char *color_names[] = {"red","green","blue","gray"}; 
  
  if (!CMD_IS("recite"))
    {
      return FALSE; 
    }
  
  tmp = one_argument(argument, arg_1);
  one_argument(tmp, target); 
d2065 2
a2066 3
  if (!is_abbrev(arg_1, "scroll") && !is_abbrev(arg_1, "recall") && 
      !is_abbrev(arg_1, color_names[color]))
    {
d2068 3
a2070 1
    }
d2072 1
a2072 10
   
  if (obj->worn_by != ch)
    {
      send_to_char("You must be holding a scroll of recall to "
		   "activate it.\r\n",ch); 
      return TRUE;
    }
  
  if (strlen(target) < 1) 
    {
d2074 1
a2074 3
    }
  else
    {
d2076 1
a2076 1
    }
d2078 5
a2082 4
  if (!strcmp(target,"self")||!str_cmp(target,"me"))
    {
     targ = ch;
    } 
d2084 1
a2084 2
  if (!targ)
    {
d2087 1
a2087 2
    }

d2089 1
a2089 2
  if (IS_NPC(targ))
    {
d2092 1
a2092 1
    }
d2094 2
a2095 2
  if (!room_recall_check(ch, obj))
     return TRUE;
d2097 4
a2100 23
  send_to_char("You recite the scroll, which dissolves.\r\n",ch); 


  if (GET_LEVEL(targ) >= LVL_IMMORT)
    {
     send_to_char("Mortal magicks on a GOD?! Are you CRAZY?!\r\n",ch);
     free(recall);
     return TRUE;
    }
/*  send_to_char("You recite the scroll, which dissolves.\r\n", ch);*/

  if (targ == ch)
    {
      act("$n recites a scroll of recall at $mself.", FALSE, ch, 
	  0, targ,TO_ROOM);
    }
  else
    {
      act("$n recites a scroll of recall at YOU!", FALSE, ch, 
	  0, targ, TO_VICT); 
      act("$n recites a scroll of recall at $N.", FALSE, ch, 
	  0, targ, TO_NOTVICT); 
    }
d2102 1
d2104 7
a2110 2
  unequip_char(ch, obj->worn_on); 
  extract_obj(obj); 
d2112 1
a2112 1
  /*commented out to remove the chance of failing recalls. - CJD
d2114 1
a2114 15
  chance = GET_INT(ch) + GET_WIS(ch); 
  
   If you're used to magic, get a bonus!
  if (IS_MAGIC_USER(ch) || IS_CLERIC(ch))
    {
      chance += 20; 
    };
  
  if (number(1,201) < chance)
    {  
  */
      CREATE(recall, struct recall_event_obj, 1);
      recall->ch = targ; 
      recall->from_room = ch->in_room; 
      
d2116 3
a2118 7
      room = 3001; 
      switch(color)
	{
	case 0:	room = red_recall_room(targ); break;
	case 1: room = green_recall_room(targ); break;
	case 2: room = blue_recall_room(targ); break;
	case 3: room = gray_recall_room(targ); break;
d2120 2
a2121 1
	};
d2123 3
a2125 1
      recall->room = room; 
d2127 1
d2129 9
a2137 27
      if (recall->room != NOWHERE)
	{
	  event_create(recall_event, recall, 8 RL_SEC); 
	}
      else
	{
	  free(recall); 
	};
  /*  }
 
  continue commented out the failing -CJD
  else
    {
      Oops!  You screwed up.  Do not go home, do not collect 200 dollars.
      int failure_code = number(1,20); 
      
      send_to_char("Your invocation of the scroll fails!\r\n", ch); 
      act("$n fails to properly invoke the scroll of recall!.\r\n", 
	  FALSE, ch, 0, 0,TO_ROOM);
      
      switch(failure_code)
	{
	case 20: 
	  GET_HIT(ch) =  GET_MAX_HIT(ch); 
	  send_to_char("You have been FULLY healed!  How odd!\r\n", ch);
	  
	  break; 
d2139 1
a2139 45
	case 5:
	case 4:
	case 3:
	case 2:
	  {
	    int room = number(1, top_of_world);
	    send_to_char("You feel the scroll's energy start to envelop "
			 "you, something has gone wrong!\r\n",ch);
	    act("$N disappears in a bright flash.\r\n", 
		FALSE, ch, 0, ch,TO_NOTVICT);
	    
	    char_from_room(ch);
	    char_to_room(ch, room);
	    act("$N appears in a bright flash of light.\r\n", 
		FALSE, ch, 0, ch, TO_NOTVICT);

	    look_at_room(ch,0);
	    
	  };
	  break; 
	case 1:
	  if (GET_HIT(ch) > 0)
	    {
	      GET_HIT(ch) -= (100 + number(2, 25));
	      if (GET_HIT(ch) < 0) GET_HIT(ch) = 1;
	      
	      send_to_char("The scroll of recall explodes in your face!\r\n",
			   ch ); 
	      
	      act("$n misspeaks the scroll of recall,"
		  " causing it to explode!\r\n", FALSE, ch, 0, 0,TO_ROOM);

	    };
	  break; 
	case 6:
	  
	  Yeah, it's mean.
	  GET_CON(ch)--; 
	default:
	  send_to_char( "You fail to invoke the scroll!\r\n",ch);
	  break; 
	  
	}
    }*/
  return TRUE;
d2141 2
a2143 1
}
d2261 1
a2261 1
		  "%i or %i \r\n", room, 6001); 
d2269 1
a2269 1
      return real_room(6001); 
d2892 3
@


1.44
log
@Dragonmount special proc.  Fixed typo in stone dagger proc.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.43 2006/11/20 03:47:24 jps Exp myc $
d58 1
d2107 3
d2993 3
@


1.43
log
@Make petstore list like other store lists.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.42 2006/11/11 23:52:32 jps Exp jps $
d1896 2
a1897 3
  /* Give a player not affected with haste that has less than 999 hitpoints
   * a 3% chance of having the proc go off. RSD 3/16/00  
   */
a1898 5
  if (GET_HIT(ch) >= 999 || IS_AFFECTED(ch, AFF_HASTE) || !(GET_CLASS(ch) == CLASS_ANTI_PALADIN)) {
    return 0;
  } else if (cmd || !vict || number(0, 100) < 97 ) {
    return 0;
  }
d1930 3
a1932 3
  weapon_spell("Your $p glows &4blue&0 and a bolt rushs through the air at $N!",
	       "$n's $p glows &4blue&0 and a bolt rushs through the air at you!",
	       "$n's $p glows &4blue&0 and a bolt rushs through the air at $N.",
d2928 59
d2989 3
@


1.42
log
@Change Ogakh scroll spelling to "gray"
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.41 2006/11/08 09:16:04 jps Exp jps $
d1272 1
a1272 1
  int pet_room, amount;
d1279 12
a1290 5
    send_to_char("Available pets are:\r\n", ch);
    for (pet = world[pet_room].people; pet; pet = pet->next_in_room) {
      sprintf(buf, "%8s - &3%d&0 c\r\n", GET_NAME(pet), PET_PRICE(pet));
      send_to_char(buf, ch);
    }
d2936 3
@


1.41
log
@Fixed some loose-lose typos.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.40 2006/10/07 02:09:23 dce Exp jps $
d63 1
a63 1
SPECIAL(grey_recall);
d68 1
a68 1
int grey_recall_room(struct char_data *ch); 
d2054 1
a2054 1
  char *color_names[] = {"red","green","blue","grey"}; 
d2157 1
a2157 1
	case 3: room = grey_recall_room(targ); break;
d2245 1
a2245 1
SPECIAL(grey_recall)
d2418 1
a2418 1
int grey_recall_room(struct char_data *ch) 
d2929 3
@


1.40
log
@Fixed typo in grey recall that sent players to blue recall locations.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.39 2006/10/06 01:54:48 dce Exp dce $
d2691 1
a2691 1
	      send_to_char("&0A &1fiery&0 blast knocks you backwards causing you to loose your balance.&0\r\n", ch);
d2929 3
@


1.39
log
@Added spec_procs for Ogakh and associated grey recall.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.38 2006/07/24 21:45:41 cjd Exp $
d2247 1
a2247 1
  return do_recall(ch, (struct obj_data*)me, cmd, argument, 2); 
d2929 3
@


1.38
log
@Added check in recall scrolls for immortals and "self"
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.37 2005/07/13 21:39:28 cjd Exp $
d63 1
d68 1
d2054 1
a2054 1
  char *color_names[] = {"red","green","blue"}; 
d2157 1
d2245 4
d2418 46
d2929 3
@


1.37
log
@commented the recall scroll fail code.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.36 2003/10/13 06:14:00 jjl Exp $
d2057 1
a2057 1
    };
d2066 1
a2066 1
    };
d2074 1
a2074 1
    };
d2083 1
a2083 1
    };
d2085 4
d2094 1
a2094 1
    };
d2101 12
a2112 4
    };
  
  
  send_to_char("You recite the scroll, which dissolves.\r\n", ch);
d2125 1
a2125 1
    };
d2876 3
@


1.36
log
@Fixed rangers and anti-paladins for green recalls.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.35 2002/11/09 19:18:27 jjl Exp $
d2051 1
a2051 1
  int chance; 
d2119 2
d2123 1
a2123 1
  /* If you're used to magic, get a bonus! */ 
d2131 1
a2131 1
      
d2157 3
a2159 1
    }
d2162 1
a2162 1
      /* Oops!  You screwed up.  Do not go home, do not collect 200 dollars. */
d2212 2
a2213 1
	  /* Yeah, it's mean. */
d2219 2
a2220 3
	  
	};
    };
d2864 3
@


1.35
log
@Moved a NULL check to be BEFORE something that used the variable.  It was
causing crashes if you targetted someone who wasn't there.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.34 2002/10/19 19:14:02 jjl Exp $
d2314 1
a2314 1
    case CLASS_ANTI_PALADIN: room = 6080; break; 
d2318 2
d2321 1
d2860 4
@


1.34
log
@DUH
I feel like such an idiot
I had left a return real_room(3001) from testing in.  Blue recalls are fixed
now.
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.30 2002/10/19 18:29:52 jjl Exp $
d2085 8
a2098 5
  if (!targ)
    {
      send_to_char("You do not see that person here!\r\n", ch); 
      return TRUE; 
    };
d2857 6
@


1.33
log
@I just wanted to bump the revision number a few times by being dumb.  No biggie.
@
text
@d2386 1
a2386 1
  return real_room(3001);
@


1.32
log
@DOH
Actually gave a message to the people NOT being targetted too. Duh
@
text
@d2109 1
a2109 1
	  0, targ, TO_ROOM); 
@


1.31
log
@Updated to give target messages for recall
@
text
@d2108 2
@


1.30
log
@New and improved red green and blue scrolls of recall. Yummy!
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.29 2002/09/13 02:32:10 jjl Exp $
d2098 12
a2109 1
  act("$n recites a scroll of recall.\r\n", FALSE, ch, 0, 0,TO_ROOM);
d2852 3
@


1.29
log
@Updated header comments
@
text
@d2 1
a2 1
 * $Id: spec_procs.c,v 1.28 2001/03/14 00:19:07 dce Exp $
d30 3
d34 1
d46 1
d57 11
d75 2
d197 1
a197 1
    return 1;
d1933 1
d2034 345
d2841 3
@


1.28
log
@Pet price increased.
@
text
@d1 3
a3 1
// $Id: spec_procs.c,v 1.27 2001/01/06 22:02:55 rsd Exp $
d2475 109
a2583 104
// $Log: spec_procs.c,v $
// Revision 1.27  2001/01/06 22:02:55  rsd
// Altered the guild guard proc to work for when builders
// don't listen to you and add multiple classes for the
// same direction in a guild entrance. Mutha fukas
//
// Revision 1.26  2000/11/25 02:33:15  rsd
// Altered comment header and added back rlog messages
// from prior to the addition of the $log$ string.
//
// Revision 1.25  2000/11/03 17:28:33  jimmy
// Added better checks for real_room to stop players/objs from
// being placed in room NOWHERE.  This should help pinpoint any
// weirdness.
//
// Revision 1.24  2000/10/21 12:08:09  mtp
// subclasser has been removed...
//
// Revision 1.23  2000/10/15 05:20:41  cmc
// oops.. compiler warning corrected!
//
// Revision 1.22  2000/10/15 05:19:47  cmc
// commented out guildmaster gossip
// (by request)
//
// Revision 1.21  2000/10/13 17:55:52  cmc
// why oh why did the guild() procedure still exist if it
// wasn't being used anymore? and the only command it was
// intercepting was practice, which no longer exists... sheesh!
//
// guild() modified for "level gain" code, now functional,
// but further tweaks may be forthcoming in the near future.
//
// Happy Friday the 13th!
//
// Revision 1.20  2000/09/19 21:38:58  rsd
// Metamorpho coded the for loop that checks to see if a
// player already has a pet and prevents them from purchasing
// more than one.  I just typed it in.
//
// Revision 1.19  2000/09/18 02:52:43  rsd
// tweaked cost of pets
//
// Revision 1.17  2000/03/16 21:58:27  rsd
// Altered weapon proc so that if hasted, not proper class, and
// at limit of HP then it won't go off.
//
// Revision 1.16  2000/03/06 06:59:55  rsd
// fixed the BoP guild areas guild guard
//
// Revision 1.15  2000/03/05 02:33:30  rsd
// more grammar and ansi fixes
// ,
//
// Revision 1.14  2000/03/05 01:26:34  rsd
// fixed grammar in dispel_good weapon proc as well as changed the frequency
//
// Revision 1.13  2000/03/04 21:54:31  mud
// altered the frequency of the vamp weapon proc
//
// Revision 1.12  2000/03/04 21:25:53  rsd
// Altered the frequency at which the vamp weapon proc will
// go off. Fixed a typo in the procs output. Added w/o
// success the SPECIAL(dispel_good_weapon) proc.
//
// Revision 1.11  1999/11/16 00:18:51  rsd
// altered the clan0 guild guard spec proc to match the current
// clan zero.
//
// Revision 1.10  1999/10/30 16:03:05  rsd
// Jimmy coded alignment restrictions for Paladins and exp.
// Altered gain_exp() to check for a victim.
//
// Revision 1.9  1999/09/05 07:00:39  jimmy
// Added RCS Log and Id strings to each source file
//
// Revision 1.8  1999/08/24 03:05:35  mud
// commented out sections of dump that gave exp and money to players
// for dropping stuff.
//
// Revision 1.7  1999/07/24 20:50:18  dce
// Exchange command for banks added.
//
// Revision 1.6  1999/07/07 16:49:04  mud
// added the quest obect for diabs and antis
//
// Revision 1.5  1999/04/30 19:12:56  dce
// Free mail for gods
//
// Revision 1.4  1999/04/24 03:07:01  jimmy
// fixed errors related to adding the pendantic compiler flag
// -gurlaek
//
// Revision 1.3  1999/04/24 02:12:56  dce
// Fixed warning messages
//
// Revision 1.2  1999/02/02 16:15:46  mud
// dos2unix
// indented entire file after putting all {}'s
// on lines by themselves.
//
// Revision 1.1  1999/01/29 01:23:32  mud
// Initial revision
//
@


1.27
log
@Altered the guild guard proc to work for when builders
don't listen to you and add multiple classes for the
same direction in a guild entrance. Mutha fukas
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.26 2000/11/25 02:33:15 rsd Exp $
d1245 1
a1245 1
#define PET_PRICE(pet) (GET_LEVEL(pet))
d2474 5
@


1.26
log
@Altered comment header and added back rlog messages
from prior to the addition of the $log$ string.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.25 2000/11/03 17:28:33 jimmy Exp $
d982 1
a982 1
  int i;
d987 1
a987 1
  
d993 9
d1003 6
d1010 1
a1010 1
    if ((IS_NPC(ch) || GET_CLASS(ch) != guild_info[i][0]) &&
d1013 1
a1013 3
      send_to_char(buf, ch);
      act(buf2, FALSE, ch, 0, 0, TO_ROOM);
      return TRUE;
d1016 7
a1022 2
  
  return FALSE;
d2474 4
@


1.25
log
@Added better checks for real_room to stop players/objs from
being placed in room NOWHERE.  This should help pinpoint any
weirdness.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.24 2000/10/21 12:08:09 mtp Exp $
d2456 5
d2521 28
@


1.24
log
@subclasser has been removed...
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.23 2000/10/15 05:20:41 cmc Exp mtp $
d2322 2
a2323 1
  
d2343 7
a2349 1
  
d2351 1
a2351 1
  char_to_room(ch, real_room(temp_ship->obj_flags.value[1]));
d2456 3
@


1.23
log
@oops.. compiler warning corrected!
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.22 2000/10/15 05:19:47 cmc Exp cmc $
a47 2
int subclasser(struct char_data *ch, int original_class, int subclass, int minlev, int maxlev,
               int aless, int agreater, int objnum, struct char_data *mobile);
a158 44
SPECIAL(test_subclasser)
{
  if (IS_NPC(ch) || !CMD_IS("subclass"))
    return 0;

  switch(subclasser(ch,CLASS_WARRIOR,CLASS_MONK,10,15,-500,500,3062,me))
  {
    case 1:
      act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
	FALSE,me,0,ch, TO_VICT);
      break;
    case 2:
    act("&2&b$n&2&b tells you, 'An assassin you will never be, now begone!'&0",
	FALSE,me,0,ch, TO_VICT);
      break;
    case 3:
    act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of teh rogue.'&0",
	FALSE,me,0,ch, TO_VICT);
      break;
    case 4:
    act("&2&b$n&2&b tells you, 'Come back when you have achieved LES experience in the ways of teh rogue.'&0",
	FALSE,me,0,ch, TO_VICT);
      break;
    case 5:
    act("&2&b$n&2&b tells you, 'You have Less strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
      break;
    case 6:
    act("&2&b$n&2&b tells you, 'You have Greater strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
      break;
    case 7:
      act("&2&b$n&2&b tells you, 'Return when you have completed the roguish quest.'&0",
	FALSE,me,0,ch,TO_VICT);
      break;
    case 100:
  act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
      TRUE,me,0,ch,TO_ROOM);
  act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues!\r\nYou are an Assassin!&0",FALSE,me,0,ch,TO_VICT);
      break;
    default:
      send_to_char("Fatal Error in subclassing code. Please report to a god!", ch);
      break;
  }
  return 1;
}
d2449 3
@


1.22
log
@commented out guildmaster gossip
(by request)
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.21 2000/10/13 17:55:52 cmc Exp cmc $
d659 1
a659 1
  char guild_scratch[500];
d2495 4
@


1.21
log
@why oh why did the guild() procedure still exist if it
wasn't being used anymore? and the only command it was
intercepting was practice, which no longer exists... sheesh!

guild() modified for "level gain" code, now functional,
but further tweaks may be forthcoming in the near future.

Happy Friday the 13th!
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.20 2000/09/19 21:38:58 rsd Exp $
d666 1
a666 1
  ACMD(do_gen_comm);
d688 1
a688 7
	/* commented out temporarily - gotta find the equivalent here
	sprintf(buf,
		"MONITOR: %s has achieved level %d at %s [%d]\n\r",
		GET_NAME(ch),GET_LEVEL(ch)+1,
		world[ch->in_room].name,world[ch->in_room].number);
	send_to_monitoring(buf,0);
	*/
d692 1
d2495 10
@


1.20
log
@Metamorpho coded the for loop that checks to see if a
player already has a pet and prevents them from purchasing
more than one.  I just typed it in.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.19 2000/09/18 02:52:43 rsd Exp $
d51 1
d659 2
a660 1
  int skill_num, percent;
d662 5
a666 2
  extern struct spell_info_type spell_info[];
  extern struct int_app_type int_app[];
d668 49
a716 2
  if (IS_NPC(ch) || !CMD_IS("practice"))
    return 0;
d718 8
a725 10
  skip_spaces(&argument);
  
  if (!*argument) {
    list_skills(ch);
    return 1;
  }
  if (GET_PRACTICES(ch) <= 0) {
    send_to_char("You do not seem to be able to practice now.\r\n", ch);
    return 1;
  }
d727 1
a727 1
  skill_num = find_skill_num(argument);
d729 12
a740 12
  if (skill_num < 1 ||
      GET_LEVEL(ch) < spell_info[skill_num].min_level[(int) GET_CLASS(ch)]) {
    sprintf(buf, "You do not know of that %s.\r\n", SPLSKL(ch));
    send_to_char(buf, ch);
    return 1;
  }
  if (GET_SKILL(ch, skill_num) >= LEARNED(ch)) {
    send_to_char("You are already learned in that area.\r\n", ch);
    return 1;
  }
  send_to_char("You practice for a while...\r\n", ch);
  GET_PRACTICES(ch)--;
d742 2
a743 2
  percent = GET_SKILL(ch, skill_num);
  percent += MIN(MAXGAIN(ch), MAX(MINGAIN(ch), int_app[GET_INT(ch)].learn));
d745 1
a745 1
  SET_SKILL(ch, skill_num, MIN(LEARNED(ch), percent));
d747 2
a748 2
  if (GET_SKILL(ch, skill_num) >= LEARNED(ch))
    send_to_char("You are now learned in that area.\r\n", ch);
d750 5
a754 1
  return 1;
d2500 5
@


1.19
log
@tweaked cost of pets
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.17 2000/03/16 21:58:27 rsd Exp $
d3 1
a3 1
 *   File: spec_procs.c                                  Part of CircleMUD *
d8 3
a10 1
 *  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
d1231 1
d1246 7
d2446 3
@


1.18
log
@tweaked pet shop code a bit to account for horses as well
as fixed the pricing.
@
text
@d1222 1
a1222 1
#define PET_PRICE(pet) (GET_LEVEL(pet) / 10)
d1235 1
a1235 1
      sprintf(buf, "%8d - %s\r\n", PET_PRICE(pet), GET_NAME(pet));
d1251 1
a1251 1
    amount = (GET_LEVEL(pet) / 10);
@


1.17
log
@Altered weapon proc so that if hasted, not proper class, and
at limit of HP then it won't go off.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.16 2000/03/06 06:59:55 rsd Exp $
d1222 1
a1222 1
#define PET_PRICE(pet) (GET_LEVEL(pet) * 300)
d1234 4
a1237 5
    for (pet = world[pet_room].people; pet; pet = pet->next_in_room) 
      {
	sprintf(buf, "%8d - %s\r\n", PET_PRICE(pet), GET_NAME(pet));
	send_to_char(buf, ch);
      }
d1239 15
a1253 20
  } 
  else if (CMD_IS("buy")) 
    {
      
      argument = one_argument(argument, buf);
      argument = one_argument(argument, pet_name);
      
      if (!(pet = get_char_room(buf, pet_room))) 
	{
	  send_to_char("There is no such pet!\r\n", ch);
	  return (TRUE);
	}
      if (GET_CASH(ch) < PET_PRICE(pet)) 
	{
	  send_to_char("You don't have enough gold!\r\n", ch);
	  return (TRUE);
	}
      amount = (GET_LEVEL(pet) * 300);
      money_convert(ch, amount);
      GET_COPPER(ch) = (GET_COPPER(ch)-PET_PRICE(pet));
d1258 16
a1273 12
    
    if (*pet_name) 
      {
	sprintf(buf, "%s %s", pet->player.name, pet_name);
	/* free(pet->player.name); don't free the prototype! */
	pet->player.name = str_dup(buf);
	
	sprintf(buf, "%sA small sign on a chain around the neck says 'My name is %s'\r\n",
		pet->player.description, pet_name);
	/* free(pet->player.description); don't free the prototype! */
	pet->player.description = str_dup(buf);
      }
d1278 2
a1279 2
    IS_CARRYING_W(pet) = 1000;
    IS_CARRYING_N(pet) = 100;
d1285 1
a1285 1
    }
d2436 4
@


1.16
log
@fixed the BoP guild areas guild guard
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.15 2000/03/05 02:33:30 rsd Exp $
d1837 8
a1844 3
  
  /*    if (cmd || !vict || !number(0, 14)) */
  if (cmd || !vict || number(0, 100) < 93 )
d1846 1
a1846 1
  
d2438 3
@


1.15
log
@more grammar and ansi fixes
,
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.14 2000/03/05 01:26:34 rsd Exp rsd $
d2411 1
a2411 1
  if ((clan_guard->in_room != real_room(3601)) ||
d2433 4
@


1.14
log
@fixed grammar in dispel_good weapon proc as well as changed the frequency
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.13 2000/03/04 21:54:31 mud Exp $
d1843 2
a1844 2
	       "A &9&nblack haze&0 forms around $n's $p as $e strikes you!",
	       "A &9&nblack haze&0 forms around $n's $p as $e strikes $N.",
d2433 3
@


1.13
log
@altered the frequency of the vamp weapon proc
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.12 2000/03/04 21:25:53 rsd Exp $
d1898 1
a1898 1
  if (cmd || !vict || number(0, 100) < 1)
d1901 3
a1903 3
  weapon_spell("Your $p glows &4red&0 as it touches $N causing them to wince in pain!",
	       "$n's $p glows &4red&0 as it touches you and YOU wince in pain!",
	       "$n's $p glows &4red&0 as it touches $N causing them to wince in pain!",
d2433 3
@


1.12
log
@Altered the frequency at which the vamp weapon proc will
go off. Fixed a typo in the procs output. Added w/o
success the SPECIAL(dispel_good_weapon) proc.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.11 1999/11/16 00:18:51 rsd Exp $
d1839 1
a1839 1
  if (cmd || !vict || number(0, 100) < 85)
d2433 5
@


1.11
log
@altered the clan0 guild guard spec proc to match the current
clan zero.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.10 1999/10/30 16:03:05 rsd Exp $
d1838 2
a1839 1
  if (cmd || !vict || !number(0, 14))
d1842 1
a1842 1
  weapon_spell("A &9&bblack haze&0 forms around your $p as your strike $N!",
d1894 13
d2433 4
@


1.10
log
@Jimmy coded alignment restrictions for Paladins and exp.
Altered gain_exp() to check for a victim.
@
text
@d1 1
a1 1
// $Id: spec_procs.c,v 1.9 1999/09/05 07:00:39 jimmy Exp $
d2397 1
a2397 1
  if ((clan_guard->in_room != real_room(4000)) ||
d2401 1
a2401 1
  if (cmd == SCMD_DOWN)
d2405 1
a2405 1
	 act("$n shoves $N to the ground to prevent his entry.", FALSE, clan_guard, 0, ch,
d2407 3
a2409 3
	 sprintf(buf, "%s shoves you to the ground!\r\n", GET_NAME(clan_guard));
	 GET_POS(ch) = POS_SITTING;
	 GET_POS1(ch) = POS1_PRONE;
d2419 4
@


1.9
log
@Added RCS Log and Id strings to each source file
@
text
@d1 1
a1 1
// $Id$
d727 1
a727 1
      a dump! RSD 8/23/99
d734 1
a734 1
      gain_exp(ch, value);
d2418 4
a2421 1
// $Log$
@


1.8
log
@commented out sections of dump that gave exp and money to players
for dropping stuff.
@
text
@d1 1
d2418 1
@


1.7
log
@Exchange command for banks added.
@
text
@d705 1
a705 1
  int value = 0;
d722 1
a722 1
    value += MAX(1, MIN(50, GET_OBJ_COST(k) / 10));
d725 3
a727 1
  
d737 1
@


1.6
log
@added the quest obect for diabs and antis
@
text
@d13 1
a13 1

d45 3
d157 45
d1319 1
a1319 1

d1323 1
a1323 1
  int amount;
d1326 7
a1332 1

d1586 174
a1759 1
 else 
@


1.5
log
@Free mail for gods
@
text
@d289 1
a289 1
  if (!(qobj = get_obj_in_list_vnum(2300, ch->carrying))) {
@


1.4
log
@fixed errors related to adding the pendantic compiler flag
-gurlaek
@
text
@d1132 4
a1135 1
      send_to_char("You don't have enough!", ch);
@


1.3
log
@Fixed warning messages
@
text
@d200 1
a200 2
  act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues! You are an Assassin!&0",FALSE,me,0,ch,TO_VICT);
  
d247 1
a247 1
  act("&2&b$n&2&b tells you, 'Congratulations! You are now a sword for hire! You are a Mercenary!&0",FALSE,me,0,ch,TO_VICT);
d305 1
a305 1
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy warrior! You are an Anti-Paladin!'&0",FALSE,me,0,ch,TO_VICT);
@


1.2
log
@dos2unix
indented entire file adfter putting all }{}'s
on lineds by themselves.
@
text
@d200 1
a200 2
  act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues!
       You are an Assassin!&0",FALSE,me,0,ch,TO_VICT);
d248 1
a248 2
  act("&2&b$n&2&b tells you, 'Congratulations! You are now a sword for hire!
       You are a Mercenary!&0",FALSE,me,0,ch,TO_VICT);
d306 1
a306 2
    act("&2&b$n&2&b tells you, 'Congratulations! You are now the most unholy
warrior! You are an Anti-Paladin!'&0",FALSE,me,0,ch,TO_VICT);
@


1.1
log
@Initial revision
@
text
@d1 9
a9 9
/* ************************************************************************
*   File: spec_procs.c                                  Part of CircleMUD *
*  Usage: implementation of special procedures for mobiles/objects/rooms  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */
d52 3
a54 3
/* ********************************************************************
*  Special procedures for mobiles                                     *
******************************************************************** */
d63 1
a63 1

d67 1
a67 1

d82 1
a82 1

d101 1
a101 1

d126 1
a126 1
 
d128 1
a128 1

d134 1
a134 1

d136 1
a136 1

d138 1
a138 1

d150 1
a150 1

d156 5
a160 5
 int i = 0;
 struct obj_data *qobj;
 int type;

 if (IS_NPC(ch) || !CMD_IS("subclass"))
d162 4
a165 4
 type = GET_CLASS(ch);
 if(type == CLASS_ASSASSIN){
 act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
  FALSE,me,0,ch, TO_VICT);
d168 1
a168 1
 if(GET_LEVEL(ch) < 21) {
d170 1
a170 1
     FALSE,me,0,ch, TO_VICT);
d173 1
a173 1
    
d176 1
a176 1
    FALSE,me,0,ch, TO_VICT);
d179 3
a181 3

 if (GET_ALIGNMENT(ch) > -500) {
act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
d184 2
a185 2

 if (!(qobj = get_obj_in_list_vnum(32026, ch->carrying))) {
d187 1
a187 1
FALSE,me,0,ch,TO_VICT);
d198 4
a201 4
act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
TRUE,me,0,ch,TO_ROOM);
act("&2&b$n&2&b tells you, 'Congratulations! You are now the vilest of the rogues!
You are an Assassin!&0",FALSE,me,0,ch,TO_VICT);
d208 5
a212 5
 int i = 0;
 struct obj_data *qobj;
 int type;

 if (IS_NPC(ch) || !CMD_IS("subclass"))
d214 4
a217 4
 type = GET_CLASS(ch);
 if(type == CLASS_MERCENARY){
 act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",
  FALSE,me,0,ch, TO_VICT);
d220 1
a220 1
 if(GET_LEVEL(ch) < 21) {
d222 1
a222 1
     FALSE,me,0,ch, TO_VICT);
d225 1
a225 1
    
d227 8
a234 8
 ((i = parse_class(ch, 'k')) == CLASS_UNDEFINED))
{
    act("&2&b$n&2&b tells you, 'A mercenary you will never be, now begone!'&0",
    FALSE,me,0,ch, TO_VICT);
    return 1;
  }

 if (!(qobj = get_obj_in_list_vnum(55601, ch->carrying))) {
d236 1
a236 1
FALSE,me,0,ch,TO_VICT);
d247 4
a250 4
act("&7&b$n&7&b eyes glows &1red&0 as he speaks quietly with $N&0",
TRUE,me,0,ch,TO_ROOM);
act("&2&b$n&2&b tells you, 'Congratulations! You are now a sword for hire!
You are a Mercenary!&0",FALSE,me,0,ch,TO_VICT);
d268 1
a268 1

d273 1
a273 1

d275 2
a276 2
act("&2&b$n&2&b tells you, 'Come back when you have achieved more experience in the ways of evil.'&0",
FALSE,me,0,ch, TO_VICT);
d279 1
a279 1

d289 1
a289 1
act("&2&b$n&2&b tells you, 'You have strayed to far toward the path of righteousness. Return after you have made amends for your good deeds.'&0",FALSE,me,0,ch,TO_VICT);
d310 1
a310 1

d328 1
a328 1

d333 1
a333 1

d338 1
a338 1

d344 4
a347 4
{
    act("&2&b$n&2&b tells you, 'A ranger you will never be, now begone!'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }
d394 1
a394 1

d407 1
a407 1

d410 1
a410 1

d412 1
a412 1

d416 1
a416 1

d418 22
a439 22
  {  
  if((class != CLASS_CLERIC) && (class != CLASS_WARRIOR))
    return FALSE;

  if(align < 0)
    return FALSE;

  if(level < 21)
    return FALSE;

  if (ch->in_room == DQ_ROOM1)
    obj = read_object(2330, VIRTUAL);
  if (ch->in_room == DQ_ROOM2)
    obj = read_object(2331, VIRTUAL);
  if (ch->in_room == DQ_ROOM3)
    obj = read_object(2332, VIRTUAL);
  if (ch->in_room == DQ_ROOM4)
    obj = read_object(2333, VIRTUAL);

  obj_to_char(obj, ch);
  send_to_char("You recieve the blessings of Mother Earth\r\n", ch); 
  }
d450 1
a450 1

d452 1
a452 1

d460 1
a460 1

d465 1
a465 1

d470 1
a470 1

d479 1
a479 1

d501 1
a501 1

d513 1
a513 1

d518 5
a522 5
  {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }    

d527 1
a527 1

d532 1
a532 1

d534 5
a538 5
  {
    act("&2&b$n&2&b tells you, 'You will never be able to control the flames.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

d552 2
a553 2
    act("&2&b$n&2&b tells you, 'Congratulations! You can now control flames and fire! You are a Pyromancer!'&0",FALSE,me,0,ch,TO_VICT);

d565 1
a565 1

d570 5
a574 5
  {
    act("&2&b$n&2&b tells you, 'I have already taught you what I know.'&0",FALSE,me,0,ch,TO_VICT); 
    return 1;
  }    

d579 1
a579 1

d584 1
a584 1

d586 5
a590 5
  {
    act("&2&b$n&2&b tells you, 'You will never be able to control the dead.'&0",FALSE,me,0,ch,TO_VICT);
    return 1;
  }

d605 1
a605 1

d612 1
a612 1

d615 1
a615 1

d618 1
a618 1

d620 1
a620 1

d629 1
a629 1

d631 1
a631 1

d644 1
a644 1

d647 1
a647 1

d649 1
a649 1

d652 1
a652 1

d662 1
a662 1

d665 1
a665 1

d670 1
a670 1

d673 1
a673 1

d675 1
a675 1

d681 1
a681 1

d685 1
a685 1

d698 1
a698 1

d700 2
a701 2
  "W3a3003b33000c111d0d111Oe333333Oe22c222112212111a1S.";

d703 2
a704 2
  "W3a3003b33000c111d0d111CE333333CE22c222112212111a1S.";

d708 1
a708 1

d723 1
a723 1

d731 1
a731 1

d736 1
a736 1

d741 1
a741 1

d746 1
a746 1

d751 1
a751 1

d756 1
a756 1

d760 1
a760 1

d764 1
a764 1

d768 1
a768 1

d773 1
a773 1

d778 1
a778 1

d782 1
a782 1

d784 1
a784 1

d790 3
a792 3
/* ********************************************************************
*  General special procedures for mobiles                             *
******************************************************************** */
d798 1
a798 1

d803 1
a803 1

d822 1
a822 1

d825 1
a825 1

d840 1
a840 1

d843 1
a843 1

d846 1
a846 1

d859 1
a859 1

d862 1
a862 1

d867 1
a867 1

d871 1
a871 1

d874 1
a874 1

d877 1
a877 1

d886 1
a886 1

d923 3
a925 3
/* ********************************************************************
*  Special procedures for mobiles                                      *
******************************************************************** */
d934 1
a934 1

d937 1
a937 1

d940 1
a940 1

d950 1
a950 1

d959 1
a959 1

d962 1
a962 1

d985 1
a985 1

d987 1
a987 1

d990 1
a990 1

d1011 1
a1011 1

d1014 1
a1014 1

d1034 1
a1034 1

d1037 1
a1037 1

d1040 1
a1040 1

d1048 1
a1048 1

d1056 1
a1056 1

d1066 1
a1066 1

d1078 14
a1091 14
	if (GET_CASH(ch) < 1){
	return;}
	do {
	if(GET_SILVER(ch)>0){
		GET_SILVER(ch)=(GET_SILVER(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+10);}
	if(GET_GOLD(ch)>0){
		GET_GOLD(ch)=(GET_GOLD(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+(100));}
	if(GET_PLAT(ch)>0){
		GET_PLAT(ch)=(GET_PLAT(ch)-(1));
		GET_COPPER(ch)=(GET_COPPER(ch)+(1000));}
	}while(!(GET_CASH(ch)==GET_COPPER(ch)));
return;	}
d1094 35
a1128 20
  /* BURU 13/12/97*/
  {       if (GET_CASH(ch) < 1){
  return;}
  do{     if (GET_COPPER(ch)>9){
                  (GET_COPPER(ch) = (GET_COPPER(ch)-(10)));
                  (GET_SILVER(ch) = (GET_SILVER(ch)+(1)));}
  }while(GET_COPPER(ch)>9);
    do {
          if(GET_SILVER(ch)>9){
                  (GET_SILVER(ch) = (GET_SILVER(ch)-(10)));
                  (GET_GOLD(ch) = (GET_GOLD(ch)+(1)));}
            }while(GET_SILVER(ch)>9);
  do{
          if(GET_GOLD(ch)>9){
                  (GET_GOLD(ch) = (GET_GOLD(ch)-(10)));
                  (GET_PLAT(ch) = (GET_PLAT(ch)+(1)));}
         }while(GET_GOLD(ch)>9);
   return;}


d1133 37
a1169 18
  {  	  if (GET_CASH(ch) < 1){
	send_to_char("You don't have enough!", ch);
  return;}
	  if (amount<GET_COPPER(ch)){
		  return;}
	  do{ if(GET_SILVER(ch)>0){
			  (GET_SILVER(ch) = (GET_SILVER(ch)-(1)));
			  (GET_COPPER(ch) = (GET_COPPER(ch)+(10)));}
		  if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)>0)){
			  if(GET_COPPER(ch)<amount){
			  (GET_GOLD(ch) = (GET_GOLD(ch)-(1)));
			  (GET_SILVER(ch) = (GET_SILVER(ch)+(10)));}}
		  if((GET_SILVER(ch)<1)&&(GET_GOLD(ch)<1)){
			  if(((GET_COPPER(ch)+GET_SILVER(ch))<amount)&&(GET_PLAT(ch)>0)){
			  (GET_PLAT(ch) = (GET_PLAT(ch)-(1)));
			  (GET_GOLD(ch) = (GET_GOLD(ch)+(10)));}}
			  }while(amount>GET_COPPER(ch));
	  return;}
d1178 1
a1178 1

d1180 1
a1180 1

d1183 5
a1187 4
    for (pet = world[pet_room].people; pet; pet = pet->next_in_room) {
      sprintf(buf, "%8d - %s\r\n", PET_PRICE(pet), GET_NAME(pet));
      send_to_char(buf, ch);
    }
d1189 21
a1209 17
  } else if (CMD_IS("buy")) {

    argument = one_argument(argument, buf);
    argument = one_argument(argument, pet_name);

    if (!(pet = get_char_room(buf, pet_room))) {
      send_to_char("There is no such pet!\r\n", ch);
      return (TRUE);
    }
    if (GET_CASH(ch) < PET_PRICE(pet)) {
      send_to_char("You don't have enough gold!\r\n", ch);
      return (TRUE);
    }
amount = (GET_LEVEL(pet) * 300);
	money_convert(ch, amount);
    GET_COPPER(ch) = (GET_COPPER(ch)-PET_PRICE(pet));

d1213 12
a1224 11

    if (*pet_name) {
      sprintf(buf, "%s %s", pet->player.name, pet_name);
      /* free(pet->player.name); don't free the prototype! */
      pet->player.name = str_dup(buf);

      sprintf(buf, "%sA small sign on a chain around the neck says 'My name is %s'\r\n",
	      pet->player.description, pet_name);
      /* free(pet->player.description); don't free the prototype! */
      pet->player.description = str_dup(buf);
    }
d1227 1
a1227 1

d1234 1
a1234 1

d1236 1
a1236 1
  }
d1242 3
a1244 3
/* ********************************************************************
*  Special procedures for objects                                     *
******************************************************************** */
d1250 1
a1250 1

d1255 1
a1255 1
 
d1259 8
a1266 8
  {
    act("&b&3$n is thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_ROOM);
    act("&b&3You are thrown backwards in a &1b&3urs&1t &3of &1flame!&0\r\n", FALSE, ch, 0, 0, TO_CHAR);
    alter_hit(ch, dice(50, 6), 2);
    GET_POS(ch) = POS_SITTING;
    return TRUE;
  }

a1271 1
/* bank redid by buru */
d1274 1
a1274 1
/* bank redone by buru 19/12/97 */
d1281 6
a1286 5
if (CMD_IS("balance")) {
sprintf(buf, "Coins carried:   &0&b&6%d &0Platinum, &0&b&3%d &0Gold, &0%d Silver and &0&3%d &0Copper\r\n", GET_PLAT(ch), GET_GOLD(ch), GET_SILVER(ch), GET_COPPER(ch));
sprintf(buf, "%sCoins in bank:   &0&b&6%ld &0Platinum, &0&b&3%ld &0Gold, &0%ld Silver and &0&3%ld &0Copper\r\n", buf, GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
send_to_char(buf, ch);
  return 1;
d1293 10
a1302 8
 if (is_number(arg1)) {
   amount = atoi(arg1);
  if(!*arg2) {
sprintf(buf, "Deposit %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
    send_to_char(buf, ch);
	return 1;
   }
 if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2)) {
d1304 23
a1326 8
 if (amount <= GET_PLAT(ch)) {

  if(amount==1) {
 sprintf(buf, "You deposit &0&b&6%s&0 platinum coin.", arg1);
  send_to_char(buf, ch);
  }else{
 sprintf(buf, "You deposit &0&b&6%s&0 platinum coins.", arg1);
 send_to_char(buf, ch);
d1328 14
a1341 18
  act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_PLAT(ch) -= amount;
	   GET_BANK_PLAT(ch) += amount;
      return 1;
  }
if (GET_PLAT(ch) < amount) {
send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
    }
}
    if (!str_cmp("gold", arg2) || !str_cmp("g", arg2)){
	   if (amount <= GET_GOLD(ch)) {
		   if(amount==1){
	sprintf(buf, "You deposit &0&b&3%s&0 gold coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You deposit &0&b&3%s&0 gold coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
d1344 221
a1564 134
      return 1;
    }
    if (GET_GOLD(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
    }}
	    if (!str_cmp("silver", arg2) || !str_cmp("s", arg2)){
	   if (amount <= GET_SILVER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You deposit &0%s&0 silver coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{sprintf(buf, "You deposit &0%s&0 silver coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_SILVER(ch) -= amount;
	   GET_BANK_SILVER(ch) += amount;
      return 1;
    }
    if (GET_SILVER(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
		}}
	    if (!str_cmp("copper", arg2) || !str_cmp("c", arg2)){
	   if (amount <= GET_COPPER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You deposit &0&3%s&0 copper coin.", arg1);
		  		   send_to_char(buf, ch); }
		   else {sprintf(buf, "You deposit &0&3%s&0 copper coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_COPPER(ch) -= amount;
	   GET_BANK_COPPER(ch) += amount;
      return 1;
    }
    if (GET_COPPER(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
		}
  }}
  } else if (CMD_IS("dump")) 
  {  
  if (GET_CASH(ch)>0){
	send_to_char("You dump all your coins on the counter to be deposited.\r\n", ch);
    GET_BANK_PLAT(ch) += GET_PLAT(ch);
    GET_BANK_GOLD(ch) += GET_GOLD(ch);
	GET_BANK_SILVER(ch) += GET_SILVER(ch);
	GET_BANK_COPPER(ch) += GET_COPPER(ch);
	GET_PLAT(ch) -= GET_PLAT(ch); 
	GET_GOLD(ch) -= GET_GOLD(ch);
	GET_SILVER(ch) -= GET_SILVER(ch);
	GET_COPPER(ch) -= GET_COPPER(ch);
	  sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
  send_to_char(buf, ch);
 return 1;
  }	  	 if (GET_CASH(ch)<1){
      send_to_char("You don't have any coins to deposit!\r\n", ch);}
  sprintf(buf, "Your current balance is &0&b&6%ld &0platinum, &0&b&3%ld &0gold, &0%ld silver and &0&3%ld &0copper coins.\r\n", GET_BANK_PLAT(ch), GET_BANK_GOLD(ch), GET_BANK_SILVER(ch), GET_BANK_COPPER(ch));
  send_to_char(buf, ch);
    return 1; 
} 
  else if (CMD_IS("withdraw")) {
two_arguments(argument, arg1, arg2);
  if (is_number(arg1)) {
    amount = atoi(arg1);
	if(!*arg2){
		sprintf(buf, "Withdraw %s of what? Platinum?Gold?Silver?Copper?\r\n", arg1);
		send_to_char(buf, ch);
	return 1;}
    if (!str_cmp("platinum", arg2) || !str_cmp("p", arg2)){
	   if (amount <= GET_BANK_PLAT(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0&b&6%s&0 platinum coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You withdraw &0&b&6%s&0 platinum coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_PLAT(ch) += amount;
	   GET_BANK_PLAT(ch) -= amount;
      return 1;
    }
    if (GET_BANK_PLAT(ch) < amount) {
      send_to_char("You don't have that many platinum coins deposited!\r\n", ch);
      return 1;
    }}
    if (!str_cmp("gold", arg2) || !str_cmp("g", arg2)){
	   if (amount <= GET_BANK_GOLD(ch)) {
		   if(amount==1){
	sprintf(buf, "You withdraw &0&b&3%s&0 gold coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{	sprintf(buf, "You withdraw &0&b&3%s&0 gold coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_GOLD(ch) += amount;
	   GET_BANK_GOLD(ch) -= amount;
      return 1;
    }
    if (GET_BANK_GOLD(ch) < amount) {
      send_to_char("You don't have that many gold coins deposited!\r\n", ch);
      return 1;
    }}
	    if (!str_cmp("silver", arg2) || !str_cmp("s", arg2)){
	   if (amount <= GET_BANK_SILVER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0%s&0 silver coin.", arg1);
		   		   send_to_char(buf, ch);}
		   else{sprintf(buf, "You withdraw &0%s&0 silver coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_SILVER(ch) += amount;
	   GET_BANK_SILVER(ch) -= amount;
      return 1;
    }
    if (GET_SILVER(ch) < amount) {
      send_to_char("You don't have that many silver coins deposited!\r\n", ch);
      return 1;
		}}
	    if (!str_cmp("copper", arg2) || !str_cmp("c", arg2)){
	   if (amount <= GET_BANK_COPPER(ch)) {
		   if(amount==1){
			   sprintf(buf, "You withdraw &0&3%s&0 copper coin.", arg1);
		  		   send_to_char(buf, ch); }
		   else {sprintf(buf, "You withdraw &0&3%s&0 copper coins.", arg1);
		   send_to_char(buf, ch);}
	act("$n makes a bank transaction.", TRUE, ch, 0, 0, TO_ROOM);
	   GET_COPPER(ch) += amount;
	   GET_BANK_COPPER(ch) -= amount;
      return 1;
    }
    if (GET_BANK_COPPER(ch) < amount) {
      send_to_char("You don't have that many copper coins deposited!\r\n", ch);
      return 1;
		}
  }}
  } else {
d1566 6
d1573 15
a1587 1
return 0;
d1590 6
a1595 17
  /* weapon_spell() function and special procedures -dak */
  void weapon_spell(char *to_ch, char *to_vict, char *to_room,
                    struct char_data *ch, struct char_data *vict, 
                    struct obj_data *obj, int spl)
  {
    int level = LVL_IMPL+1, i;
    
    for (i=0; i<NUM_CLASSES; i++)
      if (spell_info[spl].min_level[i] < level)
        level = spell_info[spl].min_level[i];
    level = MAX(1, MIN(LVL_IMMORT-1, level));
  
    act(to_ch, FALSE, ch, obj, vict, TO_CHAR);
    act(to_vict, FALSE, ch, obj, vict, TO_VICT);
    act(to_room, FALSE, ch, obj, vict, TO_NOTVICT);
    call_magic(ch, vict, 0, spl, level, CAST_SPELL);
  }
d1597 6
a1602 15
  SPECIAL(holyw_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
 
    if (cmd || !vict || !number(0, 9))
      return 0;
    if (number(1, 100) > 5)
      return 0;
      
    weapon_spell("&3&bYour The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade!&0",
"&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade and strikes you!&0",
"&3&b$n's The Holy Avenger of &0&6&bSalinth&0&3&b glows with a soft light as holy wrath pours from its blade to strike $N!&0",
                 ch, vict, (struct obj_data *) me, SPELL_HOLY_WORD);
    return 1;
  }
d1604 13
a1616 15
  SPECIAL(blind_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict || !number(0, 9))
      return 0;
    if (IS_AFFECTED(vict, AFF_BLIND) || MOB_FLAGGED(vict, MOB_NOBLIND))
      return 0;
      
    weapon_spell("You scream, \"MIDNIGHT!\" at $N.",
                 "$n screams, \"Midnight!\" at you.",
                 "$n screams, \"Midnight!\" at $N.",
                 ch, vict, (struct obj_data *) me, SPELL_BLINDNESS);
    return 1;
  }
a1617 13
 SPECIAL(fullharm_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict || !number(0, 14))
      return 0;
      
    weapon_spell("Your $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 onto $N!",
                 "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon you!",
                 "$n's $p &6glows&0&8 white hot&0 as it calls a beam of pure &8holy wrath&0 upon $N!.",
                 ch, vict, (struct obj_data *) me, SPELL_FULL_HARM);
    return 1;
  }
d1619 13
a1631 13
  SPECIAL(vampiric_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict || !number(0, 14))
      return 0;
      
    weapon_spell("A &9&bblack haze&0 forms around your $p as your strike $N!",
                 "A &9&nblack haze&0 forms around $n's $p as $e strikes you!",
                 "A &9&nblack haze&0 forms around $n's $p as $e strikes $N.",
                 ch, vict, (struct obj_data *) me, SPELL_VAMPIRIC_BREATH);
    return 1;
  }
d1633 18
d1652 4
a1655 13
  SPECIAL(fireball_weapon) 
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict || !number(0, 14))
      return 0;
      
    weapon_spell("Fire seems to shoot from your $p and roar through the air at $N!",
                 "Fire tears from $n's $p and roars through the air at you!",
                 "$n's $p comes alive with a fireball that roars towards $N.",
                 ch, vict, (struct obj_data *) me, SPELL_FIREBALL);
    return 1;
  }
d1657 6
a1662 30
  SPECIAL(lightning_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict)
      return 0;
   if(number(0, 100) < 90)
      return 0;
                 
    weapon_spell("Your $p glows &4blue&0 and a bolt rushs through the air at $N!",
                 "$n's $p glows &4blue&0 and a bolt rushs through the air at you!",
                 "$n's $p glows &4blue&0 and a bolt rushs through the air at $N.",
                 ch, vict, (struct obj_data *) me, SPELL_LIGHTNING_BOLT);
    return 1;
  }
  SPECIAL(curse_weapon)
  {
    struct char_data *vict = FIGHTING(ch);
    
    if (cmd || !vict || !number(0, 11))
      return 0;
    if (IS_AFFECTED(vict, AFF_CURSE))
      return 0;
      
    weapon_spell("Your $p turns black for a brief moment.",
                 "$n's $p turns obsidian as it nears contact with you.",
                 "$n's $p turns black as it contacts $N.",
                 ch, vict, (struct obj_data *) me, SPELL_CURSE);
    return 1;
  }
d1675 1
a1675 1

d1678 2
a1679 2
      { 30503,              30502,        30501,     -1},   /* archer room #1 */
      { 3041,              3053,        3503,     -1}    /* room #2 */
d1688 1
a1688 1

d1691 1
a1691 1

d1694 37
a1730 27

  for(i = 0; i < NUM_ARCHERS; i++) {
    if(real_room(to_from_rooms[i][0]) == ch->in_room) {
      for(j = 1; j <= NUM_TARGETS; j++) {
        if((k = real_room(to_from_rooms[i][j])) >= 0) {
          for(targ = world[k].people; targ; targ = targ->next_in_room) {
            if(!IS_NPC(targ) && (GET_LEVEL(targ) < LVL_IMMORT) &&
              (!number(0, 4))) {
              if(number(1, 100) <= HIT_CHANCE) {
                act(mssgs[0], 1, ch, 0, targ, TO_VICT);
                act(mssgs[1], 1, ch, 0, targ, TO_NOTVICT);
                damage = number(5, 50);
                GET_HIT(targ) -= damage + (number(1, 5));
                /*  these above numbers can be changed for different
                 *  damage levels.
                 */
                update_pos(targ);
                return TRUE;
              } else {
                act(mssgs[2], 1, ch, 0, targ, TO_VICT);
                act(mssgs[3], 1, ch, 0, targ, TO_NOTVICT);
                return TRUE;
              }
            }
          }
        }
      }
a1731 1
  }
d1737 51
a1787 39
 int i;
 char arg1[MAX_INPUT_LENGTH];
 struct obj_data *invis_obj = (struct obj_data *)me;
        /* cast the "me" pointer and assign it to invis_obj */
 if (invis_obj->worn_by == ch) {
        /* check to see if the person carrying the invis_obj is the character */
      if(CMD_IS("disappear")) {
      send_to_char("You slowly fade out of view.\r\n", ch);
      act("$n slowly fades out of view.\r\n", FALSE, ch, 0, 0,TO_ROOM);
      SET_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
      return (TRUE);
      }

      if (CMD_IS("appear")) {
      REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
      send_to_char("You snap into visibility.\r\n", ch);

      act("$n snaps into visibility.\r\n", FALSE, ch, 0, 0,TO_ROOM);
      return(TRUE);
      }

    one_argument(argument, arg1);

    if (is_abbrev(arg1, "magical")) {
     for (i=0; i< NUM_WEARS; i++)
     if(GET_EQ(ch,i)){
        if (IS_SET(AFF_FLAGS(ch), AFF_INVISIBLE)) {

          REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE);
          perform_remove(ch,i);
          send_to_char("You slowly fade into view.\r\n", ch);
          act("$n slowly fades into view.\r\n", FALSE, ch, 0, 0, TO_ROOM);
          return (TRUE);
          } else {
          perform_remove(ch, i);
          return (TRUE);
          }
     return (FALSE);
     }
a1788 4
  }
 return (FALSE);
 }
return (FALSE);
d1793 19
a1811 14
 char arg1[MAX_INPUT_LENGTH];
 struct obj_data *stone_obj = (struct obj_data *)me;
    
 if (IS_AFFECTED(ch, AFF_STONE_SKIN)){
	 return (FALSE);}
 if (stone_obj->worn_by == ch) {
        
      if(CMD_IS("stone")) {
      send_to_char("&9&bYour skin hardens and turns to stone!&0\r\n", ch);
      act("&9&b$n's skin hardens and turns to stone.&0\r\n", FALSE, ch, 0, 0,TO_ROOM);
      SET_BIT(AFF_FLAGS(ch), AFF_STONE_SKIN);
      return (TRUE);
      }

d1813 4
a1817 8
    one_argument(argument, arg1);

    
 return (FALSE);
 }
return (FALSE);
}
 
d1822 15
a1836 11
	num = number(1,3);
	num2 = number(0, 1000);
	tim2 = number(0, 1);
	tim=time_info.hours+tim2;
	/* SETTING DESTINATION*/
   to_room=ch->in_room-1;
/* GOOD ALIGN PROC (cure blind/poison/curse */
   if(tim==3||tim==6||tim==9||tim==12||tim==15||tim==18||tim==21||tim==0){
		 if(GET_ALIGNMENT(ch) >= 350){
 if (IS_AFFECTED(ch, AFF_BLIND)) {
	 if (num2>500){
d1838 7
a1844 3
		 affect_from_char(ch, SPELL_BLINDNESS);}}
 if (IS_AFFECTED(ch, AFF_POISON)) {
	 if (num2>800){
d1846 7
a1852 3
		 affect_from_char(ch, SPELL_POISON);}}
if (IS_AFFECTED(ch, AFF_CURSE)) {
	 if (num2>850){
d1854 5
a1858 2
		 affect_from_char(ch, SPELL_CURSE);}}
		 return 0;}
d1861 28
a1888 18
		 if((GET_ALIGNMENT(ch) <= -350)&&(GET_LEVEL(ch)<LVL_IMMORT)){
act("$n&0's eyes widen in suprise as a swirl of energy throws him out of the room!\r\n", FALSE, ch, 0, 0, TO_ROOM);
    	  char_from_room(ch);
		  char_to_room(ch, to_room);
		  sprintf(buf, "&0&b&8A swirl of energy wraps around you, and tosses you out of the room!&0\r\n");
		  send_to_char(buf, ch);
		  look_at_room(ch, 1);
act("$n&0 looks like he has been THROWN as he enters through the air from the west.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		  if((num==1)||(num==2)){
		  sprintf(buf, "&0&b&8You are thrown against the wall!&0\r\n");
		  send_to_char(buf, ch);
act("$n&0 hits the wall with a powerful *THUD*.\r\n", FALSE, ch, 0, 0, TO_ROOM);
          if(num==1){
			  GET_HIT(ch)=(GET_HIT(ch)-((int)(0.2*GET_HIT(ch))));}
          if(num==2){
			  GET_HIT(ch)=(GET_HIT(ch)-((int)(0.8*GET_HIT(ch))));}}
			  return 0;}}
return 0;}
d1892 6
a1897 2
 {	 if (++(ch->char_specials.timer) > 0){
	command_interpreter(ch, "z001#@@#");}}
d1901 10
a1910 78
	int prob, temp;
		temp = number(1, 3);
		prob = ((number(1, 100))+GET_LEVEL(ch));
				if(IS_NPC(ch)||(GET_HIT(ch)<0)){
					return;}
		do{
			if((GET_POS(ch)!=POS_SLEEPING)){
		switch (number(1, 8)){
		case 1:
		send_to_char("&0&3The earth of the wall starts forming the shape of an arm!&0\r\n", ch);
		send_to_char("&0&3The arm extends and thumps you extremely hard.&0\r\n", ch);
		send_to_char("&0&3The arm retracts and flattens into nothing.&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 2:
		send_to_char("&0&b&6The wall fires a series of tiny icy missiles at YOU!&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 3:
		send_to_char("&0&1The layer of fire condenses into a concentrated flame scorching you!&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
			GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}
		break;
		case 4:
		send_to_char("&0&4The water on the walls begins to swirl at an incredible rate.&0\r\n", ch);
		if(GET_POS(ch)>POS_SITTING){
		send_to_char("&0&4The water shoots from the wall at sufficient velocity to knock you down!&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;}
		break;
		case 5:
		send_to_char("&0&3A large clump of earth shoots out at you knocking you off balance!&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;
		break;
		case 6:
		send_to_char("&0&b&6Millions of icy fragments drop from the ceiling before you.&0\r\n", ch);
		if(GET_POS(ch)>POS_SITTING){
		send_to_char("&0You try your best, but eventually you &b&8SLIP&0 and fall!&0 &0\r\n", ch);
		GET_POS(ch)=POS_SITTING;}
		break;
		case 7:
		send_to_char("&0&1The fire dances and skips across the passageway before you.&0\r\n", ch);
		send_to_char("&0A &1fiery&0 blast knocks you backwards causing you to loose your balance.&0\r\n", ch);
		GET_POS(ch)=POS_SITTING;
		break;
		case 8:
		send_to_char("&0&4The water forms strange and mysterious patterns on the wall before you.&0\r\n", ch);
		send_to_char("&0You are involuntarily mesmerized by the &4swirls&0 and &4swoshes.&0\r\n", ch);
		send_to_char("&0Before long your eyelids close and you drift off to sleep.&0\r\n", ch);
		GET_POS(ch)=POS_SLEEPING;}}
		if(GET_POS(ch)==POS_SLEEPING){
		send_to_char("You have terrible nightmares as your body is overtaken with *PAIN*.&0\r\n", ch);
		if(GET_LEVEL(ch)<LVL_IMMORT){
		GET_HIT(ch)=GET_HIT(ch)-(((int)((GET_LEVEL(ch)/3)*temp)+20));}}
	if(GET_HIT(ch)<0){
		GET_HIT(ch)=-5;
		update_pos(ch);}
	switch(number(1, 4)){
	case 1:
	if(ch->in_room == real_room(9807)){
		temp=6;}
	case 2:
	if(ch->in_room == real_room(9806)){
		temp=6;}
	case 3:
	if(ch->in_room == real_room(9805)){
		temp=6;}
	case 4:
	if(ch->in_room == real_room(9801)){
		temp=6;}}
		}while((((number(0, 10))+temp)>9)&&(GET_HIT(ch)>-1));
sprintf(buf2, "Something happens to $n but its hard to see with all this kaos!");
act(buf2, FALSE, ch, 0, 0, TO_ROOM);
return;}

	/* part of ship system. see ships.h for DOCKx values */	
	SPECIAL(ship_exit)
d1912 21
a1932 13
		int i = 0;
		struct obj_data *ship_obj = 0;
    
		if(!CMD_IS("disembark"))
			return FALSE;

		/* find out which ship the player is on */
		for(i = 0;i<NUM_SHIPS;i++)
			if(real_room(ships[i].ship_ptr->obj_flags.value[1]) == ch->in_room) 
				ship_obj = ships[i].ship_ptr;

		/* the player isn't in the right room */
		if(!ship_obj)
d1934 1
a1934 2
			send_to_char("You can't do that here!\r\n", ch);
			return FALSE;
d1936 4
a1939 3
		else if( (ship_obj->in_room != DOCK1) &&
			(ship_obj->in_room != DOCK2) &&
			(ship_obj->in_room != DOCK3) )
d1941 2
a1942 2
			send_to_char("You aren't near land!\r\n", ch);
			return FALSE;
d1944 8
a1951 1
		else
d1953 2
a1954 10
			/* send the message to those in ship */
			act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);

			char_from_room(ch);
			char_to_room(ch, ship_obj->in_room);

			/* send mesages to ch and those on the dock */
			act("You disembark from $p", FALSE, ch, ship_obj, 0, TO_CHAR);
			act("$n disembarks from $p", FALSE, ch, ship_obj, 0, TO_ROOM);
			look_at_room(ch, 0);
d1956 25
a1980 2

		return FALSE;
d1982 1
a1982 2

	SPECIAL(ship)
d1984 20
a2003 31
		ACMD(do_look);
		struct obj_data *obj = (struct obj_data *) me;
		struct obj_data *temp_ship;
		char obj_name[MAX_STRING_LENGTH];

		if(!CMD_IS("enter"))
		return FALSE;
    
		argument = one_argument(argument, obj_name);

		if(!(temp_ship = get_obj_in_list_vis(ch, obj_name, world[ch->in_room].contents)))
			return FALSE;

		if (temp_ship != obj)
		   return FALSE;

		if(temp_ship->obj_flags.value[1] <= 0 || temp_ship->obj_flags.value[1] > 32000)
		{
			send_to_char("You can't enter that ship.\r\n", ch);
			return TRUE;
		}

		act("$n &1walks up the gang-plank and boards&0 $p.", FALSE, ch, temp_ship, 0, TO_ROOM);
		act("&1You walk up the gang-plank and board&0 $p.", FALSE, ch, temp_ship, 0, TO_CHAR);

		char_from_room(ch);
		char_to_room(ch, real_room(temp_ship->obj_flags.value[1]));
		look_at_room(ch, 0);
   
		act("$n &1climbs aboard&0 $p", FALSE, ch, temp_ship, 0, TO_ROOM);
		return TRUE;
d2005 6
d2012 2
a2013 1
	SPECIAL(current_proc)
d2015 5
d2021 16
a2036 8
   extern const char *dirs[];
   extern struct current_info current[];
   int i, found, perm_num, new_room;

   found = FALSE;
   perm_num = 0;

   if(!cmd)
d2038 17
d2056 34
d2091 58
a2148 40
   for(i=0; current[i].room_vnum != -1;i++)
      if(ch->in_room == real_room(current[i].room_vnum)) {
         perm_num = i;
         found = TRUE;
         break;
       }

   if(found)
      if(number(0,100) < current[perm_num].percent) {
         sprintf(buf, "The strong current carries you %s!\r\n",
                   dirs[current[perm_num].direction]);
         send_to_char(buf, ch);
         sprintf(buf, "$n is taken %s by the rough current!",
                       dirs[current[perm_num].direction]);
         act(buf, FALSE, ch, 0, 0, TO_NOTVICT);

/* You can use your favorite way to record errors here. */

if(!EXIT(ch, current[perm_num].direction)) {
   send_to_char("Error in this room.  Please report this! ERROR 1\r\n", ch);
   return FALSE;
 }

if(EXIT(ch, current[perm_num].direction)->to_room == NOWHERE) {
   send_to_char("Error in this room.  Please report this! ERROR 2\r\n", ch);
   return FALSE;
  }

         /* Here we want to use char_from_room / char_to_room instead of a
do_simple_move
            because the current should take them no matter if they have a
boat, no
            movement points left, etc. */
         new_room = EXIT(ch, current[perm_num].direction)->to_room;
         char_from_room(ch);
         char_to_room(ch, new_room);
         act("$n is swept into the room by the rough current!", FALSE, ch,
0, 0, TO_NOTVICT);
       }
 return FALSE;
d2153 9
a2161 9
 struct char_data *clan_guard = (struct char_data *) me;

 if(!cmd)
 return FALSE;

if (!IS_MOVE(cmd))
  return FALSE;

 if (!ch || !clan_guard)
d2163 2
a2164 2

 if(!IS_NPC(ch) && GET_LEVEL(ch) >= LVL_IMMORT)
d2166 3
a2168 3

if ((clan_guard->in_room != real_room(4000)) ||
 (clan_guard->in_room == NOWHERE))
d2170 17
a2186 17

 if (cmd == SCMD_DOWN){
     if(GET_CLAN(ch) != clan[0].id || GET_CLAN_RANK(ch) < 1){
act("$n shoves $N to the ground to prevent his entry.", FALSE, clan_guard, 0, ch,
TO_NOTVICT); 
sprintf(buf, "%s shoves you to the ground!\r\n", GET_NAME(clan_guard));
GET_POS(ch) = POS_SITTING;
GET_POS1(ch) = POS1_PRONE;
send_to_char(buf, ch);
return TRUE;
}else
return FALSE;
}


return FALSE;

@
